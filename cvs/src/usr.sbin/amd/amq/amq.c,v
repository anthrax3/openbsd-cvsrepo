head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.2
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.14.0.8
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.14
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.10
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.8
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.5.0.22
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.20
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.18
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2017.01.21.08.33.51;	author krw;	state Exp;
branches;
next	1.20;
commitid	xpTSTOgSQRGS1RiF;

1.20
date	2016.12.20.22.19.08;	author krw;	state Exp;
branches;
next	1.19;
commitid	he6NK9EzIygmfrzo;

1.19
date	2015.12.11.04.26.01;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	QfxsBeGJitJUAfkd;

1.18
date	2015.01.21.09.50.25;	author guenther;	state Exp;
branches;
next	1.17;
commitid	cGf82el9lnnFrg2e;

1.17
date	2015.01.21.08.24.41;	author guenther;	state Exp;
branches;
next	1.16;
commitid	fwWHCHQH9uktPmic;

1.16
date	2014.10.26.03.28.41;	author guenther;	state Exp;
branches;
next	1.15;
commitid	RUbgWdu1CNTVPIOS;

1.15
date	2014.10.20.00.20.04;	author guenther;	state Exp;
branches;
next	1.14;
commitid	ciYfifbFHhmQvDo5;

1.14
date	2013.04.17.15.55.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.18.08.34.38;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.10.05.39.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.10.05.34.39;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.03.21.49.24;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.03.08.29.32;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.43.46;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.08.13.06.06.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.04.16.10.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.04.15.54.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.13;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)amq.c	8.1 (Berkeley) 6/7/93
 *	$Id: amq.c,v 1.20 2016/12/20 22:19:08 krw Exp $
 */

/*
 * Automounter query tool
 */

#include "am.h"
#include "amq.h"
#include <stdio.h>
#include <fcntl.h>
#include <netdb.h>
#include <unistd.h>

static int privsock(int);

static int flush_flag;
static int minfo_flag;
static int unmount_flag;
static int stats_flag;
static int getvers_flag;
static char *debug_opts;
static char *logfile;
static char *xlog_optstr;
static char localhost[] = "localhost";
static char *def_server = localhost;

extern int optind;
extern char *optarg;

static struct timeval tmo = { 10, 0 };
#define	TIMEOUT tmo

enum show_opt { Full, Stats, Calc, Short, ShowDone };

/*
 * If (e) is Calc then just calculate the sizes
 * Otherwise display the mount node on stdout
 */
static void
show_mti(amq_mount_tree *mt, enum show_opt e, int *mwid, int *dwid,
    int *twid)
{
	switch (e) {
	case Calc: {
		int mw = strlen(mt->mt_mountinfo);
		int dw = strlen(mt->mt_directory);
		int tw = strlen(mt->mt_type);

		if (mw > *mwid)
			*mwid = mw;
		if (dw > *dwid)
			*dwid = dw;
		if (tw > *twid)
			*twid = tw;
		break;
	    }

	case Full: {
		time_t t = mt->mt_mounttime;

		struct tm *tp = localtime(&t);

		printf("%-*.*s %-*.*s %-*.*s %s\n\t%-5d %-7d %-6d"
		    " %-7d %-7d %-6d %02d/%02d/%02d %02d:%02d:%02d\n",
		    *dwid, *dwid, *mt->mt_directory ? mt->mt_directory : "/",
		    *twid, *twid, mt->mt_type, *mwid, *mwid, 
		    mt->mt_mountinfo, mt->mt_mountpoint, mt->mt_mountuid,
		    mt->mt_getattr, mt->mt_lookup, mt->mt_readdir,
		    mt->mt_readlink, mt->mt_statfs,
		    tp->tm_year > 99 ? tp->tm_year - 100 : tp->tm_year,
		    tp->tm_mon+1, tp->tm_mday,
		    tp->tm_hour, tp->tm_min, tp->tm_sec);
		break;
	    }

	case Stats: {
		time_t t = mt->mt_mounttime;

		struct tm *tp = localtime(&t);

		printf("%-*.*s %-5d %-7d %-6d %-7d %-7d %-6d"
		    " %02d/%02d/%02d %02d:%02d:%02d\n",
		    *dwid, *dwid, *mt->mt_directory ? mt->mt_directory : "/",
		    mt->mt_mountuid, mt->mt_getattr, mt->mt_lookup,
		    mt->mt_readdir, mt->mt_readlink, mt->mt_statfs,
		    tp->tm_year > 99 ? tp->tm_year - 100 : tp->tm_year,
		    tp->tm_mon+1, tp->tm_mday,
		    tp->tm_hour, tp->tm_min, tp->tm_sec);
		break;
	    }

	case Short: {
		printf("%-*.*s %-*.*s %-*.*s %s\n",
		    *dwid, *dwid, *mt->mt_directory ? mt->mt_directory : "/",
		    *twid, *twid, mt->mt_type, *mwid, *mwid,
		    mt->mt_mountinfo, mt->mt_mountpoint);
		break;
	    }

	default:
		break;
	}
}

/*
 * Display a mount tree.
 */
static void
show_mt(amq_mount_tree *mt, enum show_opt e, int *mwid, int *dwid,
    int *pwid)
{
	while (mt) {
		show_mti(mt, e, mwid, dwid, pwid);
		show_mt(mt->mt_next, e, mwid, dwid, pwid);
		mt = mt->mt_child;
	}
}

static void
show_mi(amq_mount_info_list *ml, enum show_opt e, int *mwid,
    int *dwid, int *twid)
{
	int i;

	switch (e) {
	case Calc: {
		for (i = 0; i < ml->amq_mount_info_list_len; i++) {
			amq_mount_info *mi = &ml->amq_mount_info_list_val[i];
			int mw = strlen(mi->mi_mountinfo);
			int dw = strlen(mi->mi_mountpt);
			int tw = strlen(mi->mi_type);

			if (mw > *mwid)
				*mwid = mw;
			if (dw > *dwid)
				*dwid = dw;
			if (tw > *twid)
				*twid = tw;
		}
		break;
	    }

	case Full: {
		for (i = 0; i < ml->amq_mount_info_list_len; i++) {
			amq_mount_info *mi = &ml->amq_mount_info_list_val[i];
			printf("%-*.*s %-*.*s %-*.*s %-3d %s is %s",
			    *mwid, *mwid, mi->mi_mountinfo,
			    *dwid, *dwid, mi->mi_mountpt,
			    *twid, *twid, mi->mi_type,
			    mi->mi_refc, mi->mi_fserver,
			    mi->mi_up > 0 ? "up" :
			    mi->mi_up < 0 ? "starting" : "down");
			if (mi->mi_error > 0) {
				printf(" (%s)", strerror(mi->mi_error));
			} else if (mi->mi_error < 0) {
				fputs(" (in progress)", stdout);
			}
			fputc('\n', stdout);
		}
		break;
	    }
	default:
		break;
	}
}

/*
 * Display general mount statistics
 */
static void
show_ms(amq_mount_stats *ms)
{
	printf("requests  stale     mount     mount     unmount\n"
	    "deferred  fhandles  ok        failed    failed\n"
	    "%-9d %-9d %-9d %-9d %-9d\n",
	    ms->as_drops, ms->as_stale, ms->as_mok, ms->as_merr, ms->as_uerr);
}

static bool_t
xdr_pri_free(xdrproc_t xdr_args, void *args_ptr)
{
	XDR xdr;

	xdr.x_op = XDR_FREE;
	return ((*xdr_args)(&xdr, args_ptr));
}

/*
 * MAIN
 */
int
main(int argc, char *argv[])
{
	int nodefault = 0, opt_ch, errs = 0, s;
	struct sockaddr_in server_addr;
	struct hostent *hp;
	CLIENT *clnt;
	char *server;

	/*
	 * Parse arguments
	 */
	while ((opt_ch = getopt(argc, argv, "fh:l:msuvx:D:")) != -1)
		switch (opt_ch) {
		case 'f':
			flush_flag = 1;
			nodefault = 1;
			break;

		case 'h':
			def_server = optarg;
			break;

		case 'l':
			logfile = optarg;
			nodefault = 1;
			break;

		case 'm':
			minfo_flag = 1;
			nodefault = 1;
			break;

		case 's':
			stats_flag = 1;
			nodefault = 1;
			break;

		case 'u':
			unmount_flag = 1;
			nodefault = 1;
			break;

		case 'v':
			getvers_flag = 1;
			nodefault = 1;
			break;

		case 'x':
			xlog_optstr = optarg;
			nodefault = 1;
			break;

		case 'D':
			debug_opts = optarg;
			nodefault = 1;
			break;

		default:
			errs = 1;
			break;
		}

	if (optind == argc) {
		if (unmount_flag)
			errs = 1;
	}

	if (errs) {
show_usage:
		fprintf(stderr, "usage: %s [-fmsuv] [-h hostname] "
	    "[directory ...]\n", __progname);
		exit(1);
	}

	server = def_server;

	/*
	 * Get address of server
	 */
	if ((hp = gethostbyname(server)) == 0 && strcmp(server, localhost) != 0) {
		fprintf(stderr, "%s: Can't get address of %s\n", __progname, server);
		exit(1);
	}
	bzero(&server_addr, sizeof server_addr);
	server_addr.sin_family = AF_INET;
	if (hp) {
		bcopy(hp->h_addr, &server_addr.sin_addr,
			sizeof(server_addr.sin_addr));
	} else {
		/* fake "localhost" */
		server_addr.sin_addr.s_addr = htonl(0x7f000001);
	}

	/*
	 * Create RPC endpoint
	 */
	s = privsock(SOCK_STREAM);
	clnt = clnttcp_create(&server_addr, AMQ_PROGRAM, AMQ_VERSION, &s, 0, 0);
	if (clnt == 0) {
		close(s);
		s = privsock(SOCK_DGRAM);
		clnt = clntudp_create(&server_addr, AMQ_PROGRAM,
		    AMQ_VERSION, TIMEOUT, &s);
	}
	if (clnt == 0) {
		fprintf(stderr, "%s: ", __progname);
		clnt_pcreateerror(server);
		exit(1);
	}

	/*
	 * Control debugging
	 */
	if (debug_opts) {
		int *rc;
		amq_setopt opt;
		opt.as_opt = AMOPT_DEBUG;
		opt.as_str = debug_opts;
		rc = amqproc_setopt_57(&opt, clnt);
		if (rc && *rc < 0) {
			fprintf(stderr,
			    "%s: daemon not compiled for debug", __progname);
			errs = 1;
		} else if (!rc || *rc > 0) {
			fprintf(stderr,
			    "%s: debug setting for \"%s\" failed\n",
			    __progname, debug_opts);
			errs = 1;
		}
	}

	/*
	 * Control logging
	 */
	if (xlog_optstr) {
		int *rc;
		amq_setopt opt;
		opt.as_opt = AMOPT_XLOG;
		opt.as_str = xlog_optstr;
		rc = amqproc_setopt_57(&opt, clnt);
		if (!rc || *rc) {
			fprintf(stderr, "%s: setting log level to \"%s\" failed\n",
			    __progname, xlog_optstr);
			errs = 1;
		}
	}

	/*
	 * Control log file
	 */
	if (logfile) {
		int *rc;
		amq_setopt opt;
		opt.as_opt = AMOPT_LOGFILE;
		opt.as_str = logfile;
		rc = amqproc_setopt_57(&opt, clnt);
		if (!rc || *rc) {
			fprintf(stderr, "%s: setting logfile to \"%s\" failed\n",
			    __progname, logfile);
			errs = 1;
		}
	}

	/*
	 * Flush map cache
	 */
	if (flush_flag) {
		int *rc;
		amq_setopt opt;
		opt.as_opt = AMOPT_FLUSHMAPC;
		opt.as_str = "";
		rc = amqproc_setopt_57(&opt, clnt);
		if (!rc || *rc) {
			fprintf(stderr,
			    "%s: amd on %s cannot flush the map cache\n",
			    __progname, server);
			errs = 1;
		}
	}

	/*
	 * Mount info
	 */
	if (minfo_flag) {
		int dummy;
		amq_mount_info_list *ml = amqproc_getmntfs_57(&dummy, clnt);
		if (ml) {
			int mwid = 0, dwid = 0, twid = 0;
			show_mi(ml, Calc, &mwid, &dwid, &twid);
			mwid++; dwid++; twid++;
			show_mi(ml, Full, &mwid, &dwid, &twid);
		} else {
			fprintf(stderr, "%s: amd on %s cannot provide mount info\n",
			    __progname, server);
		}
	}

	/*
	 * Get Version
	 */
	if (getvers_flag) {
		amq_string *spp = amqproc_getvers_57(NULL, clnt);
		if (spp && *spp) {
			printf("%s.\n", *spp);
			free(*spp);
		} else {
			fprintf(stderr, "%s: failed to get version information\n",
			    __progname);
			errs = 1;
		}
	}

	/*
	 * Apply required operation to all remaining arguments
	 */
	if (optind < argc) {
		do {
			char *fs = argv[optind++];
			if (unmount_flag) {
				/*
				 * Unmount request
				 */
				amqproc_umnt_57(&fs, clnt);
			} else {
				/*
				 * Stats request
				 */
				amq_mount_tree_p *mtp = amqproc_mnttree_57(&fs, clnt);
				if (mtp) {
					amq_mount_tree *mt = *mtp;
					if (mt) {
						int mwid = 0, dwid = 0, twid = 0;

						show_mt(mt, Calc, &mwid, &dwid, &twid);
						mwid++;
						dwid++;
						twid++;

						printf("%-*.*s Uid   Getattr "
						    "Lookup RdDir   RdLnk   "
						    "Statfs Mounted@@\n",
						    dwid, dwid, "What");
						show_mt(mt, Stats, &mwid, &dwid, &twid);
					} else {
						fprintf(stderr,
						    "%s: %s not automounted\n",
						    __progname, fs);
					}
					xdr_pri_free(xdr_amq_mount_tree_p, mtp);
				} else {
					fprintf(stderr, "%s: ", __progname);
					clnt_perror(clnt, server);
					errs = 1;
				}
			}
		} while (optind < argc);
	} else if (unmount_flag) {
		goto show_usage;
	} else if (stats_flag) {
		amq_mount_stats *ms = amqproc_stats_57(NULL, clnt);
		if (ms) {
			show_ms(ms);
		} else {
			fprintf(stderr, "%s: ", __progname);
			clnt_perror(clnt, server);
			errs = 1;
		}
	} else if (!nodefault) {
		amq_mount_tree_list *mlp = amqproc_export_57(NULL, clnt);
		if (mlp) {
			enum show_opt e = Calc;
			int mwid = 0, dwid = 0, pwid = 0;

			while (e != ShowDone) {
				int i;

				for (i = 0; i < mlp->amq_mount_tree_list_len; i++) {
					show_mt(mlp->amq_mount_tree_list_val[i],
					    e, &mwid, &dwid, &pwid);
				}
				mwid++;
				dwid++;
				pwid++;
				if (e == Calc)
					e = Short;
				else if (e == Short)
					e = ShowDone;
			}
		} else {
			fprintf(stderr, "%s: ", __progname);
			clnt_perror(clnt, server);
			errs = 1;
		}
	}

	exit(errs);
}

/*
 * udpresport creates a datagram socket and attempts to bind it to a
 * secure port.
 * returns: The bound socket, or -1 to indicate an error.
 */
static int
inetresport(int ty)
{
	struct sockaddr_in addr;
	int alport, sock;

	/* Use internet address family */
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	if ((sock = socket(AF_INET, ty, 0)) < 0)
		return -1;
	for (alport = IPPORT_RESERVED-1; alport > IPPORT_RESERVED/2 + 1; alport--) {
		addr.sin_port = htons((u_short)alport);
		if (bind(sock, (struct sockaddr *)&addr, sizeof (addr)) >= 0)
			return sock;
		if (errno != EADDRINUSE) {
			close(sock);
			return -1;
		}
	}
	close(sock);
	errno = EAGAIN;
	return -1;
}

/*
 * Privsock() calls inetresport() to attempt to bind a socket to a secure
 * port.  If inetresport() fails, privsock returns a magic socket number which
 * indicates to RPC that it should make its own socket.
 * returns: A privileged socket # or RPC_ANYSOCK.
 */
static int
privsock(int ty)
{
	int sock = inetresport(ty);

	if (sock < 0) {
		errno = 0;
		/* Couldn't get a secure port, let RPC make an insecure one */
		sock = RPC_ANYSOCK;
	}
	return sock;
}
@


1.20
log
@Add 'default:' cases to switch statements that gcc whines about.

ok jung@@
@
text
@d35 1
a35 1
 *	$Id: amq.c,v 1.19 2015/12/11 04:26:01 mmcc Exp $
d293 1
a293 1
	
d297 1
a297 1
		    "[directory ...]\n", __progname);
d526 1
a526 1
 * udpresport creates a datagram socket and attempts to bind it to a 
@


1.19
log
@Remove debugging fluff from allocation functions. There's probably more
of this stuff elsewhere in amd.

"such clutter just makes people not care" deraadt@@
@
text
@d35 1
a35 1
 *	$Id: amq.c,v 1.18 2015/01/21 09:50:25 guenther Exp $
d134 3
d197 2
@


1.18
log
@Pass times as int64_t and eliminate the (long disabled) mount request.
ABI change, so roll the RPC protocol version; how about 57 for OpenBSD 5.7?
@
text
@d35 1
a35 1
 *	$Id: amq.c,v 1.17 2015/01/21 08:24:41 guenther Exp $
a567 8

#ifdef DEBUG
void
xfree(char *f, char *l, void *p)
{
	free(p);
}
#endif /* DEBUG */
@


1.17
log
@Regenerate the amq RPC stubs with a -current rpcgen, with some
post-processing of the server stub to match previous local changes.
This corrects the type handling of mt_mounttime, so "amq /mountpoint"
doesn't segv trying to treat a time_t as a pointer.
With the file (re)generation fixed, we can more easily update the
protocol to support 64bit time_t...
@
text
@d35 1
a35 1
 *	$Id: amq.c,v 1.16 2014/10/26 03:28:41 guenther Exp $
a57 1
static char *mount_map;
d233 1
a233 1
	while ((opt_ch = getopt(argc, argv, "fh:l:msuvx:D:M:")) != -1)
a278 5
		case 'M':
			mount_map = optarg;
			nodefault = 1;
			break;

d340 1
a340 1
		rc = amqproc_setopt_1(&opt, clnt);
d361 1
a361 1
		rc = amqproc_setopt_1(&opt, clnt);
d377 1
a377 1
		rc = amqproc_setopt_1(&opt, clnt);
d393 1
a393 1
		rc = amqproc_setopt_1(&opt, clnt);
d407 1
a407 1
		amq_mount_info_list *ml = amqproc_getmntfs_1(&dummy, clnt);
a419 18
	 * Mount map
	 */
	if (mount_map) {
		int *rc;
		do {
			rc = amqproc_mount_1(&mount_map, clnt);
		} while (rc && *rc < 0);
		if (!rc || *rc > 0) {
			if (rc)
				errno = *rc;
			else
				errno = ETIMEDOUT;
			fprintf(stderr, "%s: could not start new ", __progname);
			perror("autmount point");
		}
	}

	/*
d423 1
a423 1
		amq_string *spp = amqproc_getvers_1(NULL, clnt);
d444 1
a444 1
				amqproc_umnt_1(&fs, clnt);
d449 1
a449 1
				amq_mount_tree_p *mtp = amqproc_mnttree_1(&fs, clnt);
d481 1
a481 1
		amq_mount_stats *ms = amqproc_stats_1(NULL, clnt);
d490 1
a490 1
		amq_mount_tree_list *mlp = amqproc_export_1(NULL, clnt);
@


1.16
log
@Remove a gazillion useless casts to void*
Eliminate a couple function pointer casts, fixing the function to match
    in one case
@
text
@d35 1
a35 1
 *	$Id: amq.c,v 1.15 2014/10/20 00:20:04 guenther Exp $
d95 1
a95 1
		time_t t = *mt->mt_mounttime;
d113 1
a113 1
		time_t t = *mt->mt_mounttime;
@


1.15
log
@Start removing portability goo: we have syslog(), strerror(), POSIX regexp,
    BSD-style getmntinfo(), BSD signals, 4.4BSD unmount(), etc
Delete configurations for other OSes
Delete fsinfo and mk-amd-map, as we don't build them.

ok deraadt@@
@
text
@d35 1
a35 1
 *	$Id: amq.c,v 1.14 2013/04/17 15:55:46 deraadt Exp $
d314 1
a314 1
		bcopy((void *)hp->h_addr, (void *)&server_addr.sin_addr,
d447 1
a447 1
		amq_string *spp = amqproc_getvers_1((void *)0, clnt);
d505 1
a505 1
		amq_mount_stats *ms = amqproc_stats_1((void *)0, clnt);
d514 1
a514 1
		amq_mount_tree_list *mlp = amqproc_export_1((void *)0, clnt);
@


1.14
log
@first few large time_t changes; more might be required -- still digging.
@
text
@d35 1
a35 1
 *	$Id: amq.c,v 1.13 2009/10/27 23:59:50 deraadt Exp $
a186 1
#ifdef HAS_STRERROR
a187 9
#else
				extern char *sys_errlist[];
				extern int sys_nerr;

				if (mi->mi_error < sys_nerr)
					printf(" (%s)", sys_errlist[mi->mi_error]);
				else
					printf(" (Error %d)", mi->mi_error);
#endif
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d35 1
a35 1
 *	$Id: amq.c,v 1.12 2007/02/18 08:34:38 jmc Exp $
d95 3
a97 1
		struct tm *tp = localtime((time_t *) &mt->mt_mounttime);
d113 3
a115 1
		struct tm *tp = localtime((time_t *) &mt->mt_mounttime);
@


1.12
log
@simplify synopsis/usage; mostly from Igor Sobrado
@
text
@d35 1
a35 1
 *	$Id: amq.c,v 1.11 2003/06/02 23:36:51 millert Exp $
a40 13

#ifndef lint
char copyright[] = "\
@@(#)Copyright (c) 1990 Jan-Simon Pendry\n\
@@(#)Copyright (c) 1990 Imperial College of Science, Technology & Medicine\n\
@@(#)Copyright (c) 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char rcsid[] = "$Id: amq.c,v 1.11 2003/06/02 23:36:51 millert Exp $";
static char sccsid[] = "@@(#)amq.c	8.1 (Berkeley) 6/7/93";
#endif /* not lint */
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
 *	$Id: amq.c,v 1.10 2002/09/10 05:39:26 deraadt Exp $
d51 1
a51 1
static char rcsid[] = "$Id: amq.c,v 1.10 2002/09/10 05:39:26 deraadt Exp $";
d316 2
a317 4
		fprintf(stderr, "usage: %s [-h host] [[-f] [-m] [-v] [-s]]"
		    " | [[-u] directory ...]] |\n"
		    "\t[-l logfile|\"syslog\"] [-x log_flags] "
		    "[-D dbg_opts] [-M mapent]\n", __progname);
@


1.10
log
@more knf
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: amq.c,v 1.9 2002/09/10 05:34:39 deraadt Exp $
d51 1
a51 1
static char rcsid[] = "$Id: amq.c,v 1.9 2002/09/10 05:34:39 deraadt Exp $";
@


1.9
log
@various cleanups
@
text
@d39 1
a39 1
 *	$Id: amq.c,v 1.8 2002/08/05 07:24:26 pvalchev Exp $
d55 1
a55 1
static char rcsid[] = "$Id: amq.c,v 1.8 2002/08/05 07:24:26 pvalchev Exp $";
d543 1
d546 1
d549 1
a549 1
						 e, &mwid, &dwid, &pwid);
d551 7
a557 3
				mwid++; dwid++, pwid++;
				if (e == Calc) e = Short;
				else if (e == Short) e = ShowDone;
@


1.8
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d39 1
a39 1
 *	$Id: amq.c,v 1.7 2002/08/03 21:49:24 deraadt Exp $
d55 1
a55 1
static char rcsid[] = "$Id: amq.c,v 1.7 2002/08/03 21:49:24 deraadt Exp $";
d66 1
a66 1
static int privsock();
d101 9
a109 4
		if (mw > *mwid) *mwid = mw;
		if (dw > *dwid) *dwid = dw;
		if (tw > *twid) *twid = tw;
	} break;
d113 13
a125 20
printf("%-*.*s %-*.*s %-*.*s %s\n\t%-5d %-7d %-6d %-7d %-7d %-6d %02d/%02d/%02d %02d:%02d:%02d\n",
			*dwid, *dwid,
			*mt->mt_directory ? mt->mt_directory : "/",	/* XXX */
			*twid, *twid,
			mt->mt_type,
			*mwid, *mwid, 
			mt->mt_mountinfo,
			mt->mt_mountpoint,

			mt->mt_mountuid,
			mt->mt_getattr,
			mt->mt_lookup,
			mt->mt_readdir,
			mt->mt_readlink,
			mt->mt_statfs,

			tp->tm_year > 99 ? tp->tm_year - 100 : tp->tm_year,
			tp->tm_mon+1, tp->tm_mday,
			tp->tm_hour, tp->tm_min, tp->tm_sec);
	} break;
d129 11
a139 15
printf("%-*.*s %-5d %-7d %-6d %-7d %-7d %-6d %02d/%02d/%02d %02d:%02d:%02d\n",
			*dwid, *dwid,
			*mt->mt_directory ? mt->mt_directory : "/",	/* XXX */

			mt->mt_mountuid,
			mt->mt_getattr,
			mt->mt_lookup,
			mt->mt_readdir,
			mt->mt_readlink,
			mt->mt_statfs,

			tp->tm_year > 99 ? tp->tm_year - 100 : tp->tm_year,
			tp->tm_mon+1, tp->tm_mday,
			tp->tm_hour, tp->tm_min, tp->tm_sec);
	} break;
d143 5
a147 8
			*dwid, *dwid,
			*mt->mt_directory ? mt->mt_directory : "/",
			*twid, *twid,
			mt->mt_type,
			*mwid, *mwid,
			mt->mt_mountinfo,
			mt->mt_mountpoint);
	} break;
d178 7
a184 3
			if (mw > *mwid) *mwid = mw;
			if (dw > *dwid) *dwid = dw;
			if (tw > *twid) *twid = tw;
d186 2
a187 1
	} break;
d193 6
a198 6
						*mwid, *mwid, mi->mi_mountinfo,
						*dwid, *dwid, mi->mi_mountpt,
						*twid, *twid, mi->mi_type,
						mi->mi_refc, mi->mi_fserver,
						mi->mi_up > 0 ? "up" :
						mi->mi_up < 0 ? "starting" : "down");
d205 1
d216 2
a217 1
	} break;
d227 4
a230 5
	printf("\
requests  stale     mount     mount     unmount\n\
deferred  fhandles  ok        failed    failed\n\
%-9d %-9d %-9d %-9d %-9d\n",
	ms->as_drops, ms->as_stale, ms->as_mok, ms->as_merr, ms->as_uerr);
d237 1
a241 23
#ifdef hpux
#include <cluster.h>
static char *
cluster_server()
{
	struct cct_entry *cp;

	if (cnodeid() == 0) {
		/*
		 * Not clustered
		 */
		return def_server;
	}

	while (cp = getccent())
		if (cp->cnode_type == 'r')
			return cp->cnode_name;


	return def_server;
}
#endif /* hpux */

d248 1
a248 3
	int opt_ch;
	int errs = 0;
	char *server;
d250 1
a250 4

	/* In order to pass the Amd security check, we must use a priv port. */
	int s;

d252 1
a252 2
	struct hostent *hp;
	int nodefault = 0;
d320 4
a323 3
		fprintf(stderr, "\
Usage: %s [-h host] [[-f] [-m] [-v] [-s]] | [[-u] directory ...]] |\n\
\t[-l logfile|\"syslog\"] [-x log_flags] [-D dbg_opts] [-M mapent]\n", __progname);
a326 8
#ifdef hpux
	/*
	 * Figure out root server of cluster
	 */
	if (def_server == localhost)
		server = cluster_server();
	else
#endif /* hpux */
d354 2
a355 1
		clnt = clntudp_create(&server_addr, AMQ_PROGRAM, AMQ_VERSION, TIMEOUT, &s);
d373 2
a374 1
			fprintf(stderr, "%s: daemon not compiled for debug", __progname);
d377 3
a379 1
			fprintf(stderr, "%s: debug setting for \"%s\" failed\n", __progname, debug_opts);
d394 2
a395 1
			fprintf(stderr, "%s: setting log level to \"%s\" failed\n", __progname, xlog_optstr);
d410 2
a411 1
			fprintf(stderr, "%s: setting logfile to \"%s\" failed\n", __progname, logfile);
d426 3
a428 1
			fprintf(stderr, "%s: amd on %s cannot flush the map cache\n", __progname, server);
a443 1

d445 2
a446 1
			fprintf(stderr, "%s: amd on %s cannot provide mount info\n", __progname, server);
d477 2
a478 1
			fprintf(stderr, "%s: failed to get version information\n", __progname);
d503 1
d505 8
a512 3
						mwid++; dwid++, twid++;
		printf("%-*.*s Uid   Getattr Lookup RdDir   RdLnk   Statfs Mounted@@\n",
			dwid, dwid, "What");
d515 3
a517 1
						fprintf(stderr, "%s: %s not automounted\n", __progname, fs);
d568 2
a569 2
static int inetresport(ty)
int ty;
a570 1
	int alport;
d572 1
a572 1
	int sock;
d599 2
a600 2
static int privsock(ty)
int ty;
d613 2
a614 3
xfree(f, l, p)
char *f, *l;
void *p;
@


1.7
log
@xdr_pri_free() ansi; pvalchev ok
@
text
@d39 1
a39 1
 *	$Id: amq.c,v 1.6 2002/08/03 08:29:32 pvalchev Exp $
d55 1
a55 1
static char rcsid[] = "$Id: amq.c,v 1.6 2002/08/03 08:29:32 pvalchev Exp $";
d377 1
a377 1
		bcopy((voidp) hp->h_addr, (voidp) &server_addr.sin_addr,
d502 1
a502 1
		amq_string *spp = amqproc_getvers_1((voidp) 0, clnt);
d551 1
a551 1
		amq_mount_stats *ms = amqproc_stats_1((voidp) 0, clnt);
d560 1
a560 1
		amq_mount_tree_list *mlp = amqproc_export_1((voidp) 0, clnt);
d637 1
a637 1
voidp p;
@


1.6
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d39 1
a39 1
 *	$Id: amq.c,v 1.5 1997/01/15 23:43:46 millert Exp $
d55 1
a55 1
static char rcsid[] = "$Id: amq.c,v 1.5 1997/01/15 23:43:46 millert Exp $";
d237 1
a237 1
xdr_pri_free(xdrproc_t xdr_args, caddr_t args_ptr)
d540 1
a540 1
					xdr_pri_free(xdr_amq_mount_tree_p, (caddr_t) mtp);
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d39 1
a39 1
 *	$Id: amq.c,v 1.4 1996/08/13 06:06:53 deraadt Exp $
d55 1
a55 1
static char rcsid[] = "$Id: amq.c,v 1.4 1996/08/13 06:06:53 deraadt Exp $";
d64 1
a67 1
char *progname;
d92 3
a94 6
static void show_mti(mt, e, mwid, dwid, twid)
amq_mount_tree *mt;
enum show_opt e;
int *mwid;
int *dwid;
int *twid;
d163 3
a165 6
static void show_mt(mt, e, mwid, dwid, pwid)
amq_mount_tree *mt;
enum show_opt e;
int *mwid;
int *dwid;
int *pwid;
d174 3
a176 6
static void show_mi(ml, e, mwid, dwid, twid)
amq_mount_info_list *ml;
enum show_opt e;
int *mwid;
int *dwid;
int *twid;
d179 1
d226 2
a227 2
static void show_ms(ms)
amq_mount_stats *ms;
d237 1
a237 3
xdr_pri_free(xdr_args, args_ptr)
xdrproc_t xdr_args;
caddr_t args_ptr;
d246 2
a247 1
static char *cluster_server()
d270 2
a271 3
main(argc, argv)
int argc;
char *argv[];
a285 13
	 * Compute program name
	 */
	if (argv[0]) {
		progname = strrchr(argv[0], '/');
		if (progname && progname[1])
			progname++;
		else
			progname = argv[0];
	}
	if (!progname)
		progname = "amq";

	/*
d289 54
a342 54
	switch (opt_ch) {
	case 'f':
		flush_flag = 1;
		nodefault = 1;
		break;

	case 'h':
		def_server = optarg;
		break;

	case 'l':
		logfile = optarg;
		nodefault = 1;
		break;

	case 'm':
		minfo_flag = 1;
		nodefault = 1;
		break;

	case 's':
		stats_flag = 1;
		nodefault = 1;
		break;

	case 'u':
		unmount_flag = 1;
		nodefault = 1;
		break;

	case 'v':
		getvers_flag = 1;
		nodefault = 1;
		break;

	case 'x':
		xlog_optstr = optarg;
		nodefault = 1;
		break;

	case 'D':
		debug_opts = optarg;
		nodefault = 1;
		break;

	case 'M':
		mount_map = optarg;
		nodefault = 1;
		break;

	default:
		errs = 1;
		break;
	}
d353 1
a353 1
\t[-l logfile|\"syslog\"] [-x log_flags] [-D dbg_opts] [-M mapent]\n", progname);
d371 1
a371 1
		fprintf(stderr, "%s: Can't get address of %s\n", progname, server);
d395 1
a395 1
		fprintf(stderr, "%s: ", progname);
d410 1
a410 1
			fprintf(stderr, "%s: daemon not compiled for debug", progname);
d413 1
a413 1
			fprintf(stderr, "%s: debug setting for \"%s\" failed\n", progname, debug_opts);
d428 1
a428 1
			fprintf(stderr, "%s: setting log level to \"%s\" failed\n", progname, xlog_optstr);
d443 1
a443 1
			fprintf(stderr, "%s: setting logfile to \"%s\" failed\n", progname, logfile);
d458 1
a458 1
			fprintf(stderr, "%s: amd on %s cannot flush the map cache\n", progname, server);
d476 1
a476 1
			fprintf(stderr, "%s: amd on %s cannot provide mount info\n", progname, server);
d493 1
a493 1
			fprintf(stderr, "%s: could not start new ", progname);
d507 1
a507 1
			fprintf(stderr, "%s: failed to get version information\n", progname);
d538 1
a538 1
						fprintf(stderr, "%s: %s not automounted\n", progname, fs);
d542 1
a542 1
					fprintf(stderr, "%s: ", progname);
d555 1
a555 1
			fprintf(stderr, "%s: ", progname);
d575 1
a575 1
			fprintf(stderr, "%s: ", progname);
@


1.4
log
@do not play with the dog; messed up socket type
@
text
@d39 1
a39 1
 *	$Id: amq.c,v 1.1 1995/10/18 08:47:13 deraadt Exp $
d55 1
a55 1
static char rcsid[] = "$Id: amq.c,v 1.1 1995/10/18 08:47:13 deraadt Exp $";
d311 1
a311 1
	while ((opt_ch = getopt(argc, argv, "fh:l:msuvx:D:M:")) != EOF)
@


1.3
log
@use rresvport() instead.. it is even better
@
text
@d39 1
a39 1
 *	$Id: amq.c,v 1.2 1996/08/04 15:54:43 deraadt Exp $
d55 1
a55 1
static char rcsid[] = "$Id: amq.c,v 1.2 1996/08/04 15:54:43 deraadt Exp $";
d615 2
a616 1
	int port = IPPORT_RESERVED - 1;
d619 4
a622 3
	sock = rresvport(&port);
	if (sock == -1) {
		errno = EAGAIN;
d624 8
d633 3
a635 1
	return sock;
@


1.2
log
@bzero sin, bindresvport
@
text
@d39 1
a39 1
 *	$Id: amq.c,v 1.1.1.1 1995/10/18 08:47:13 deraadt Exp $
d55 1
a55 1
static char rcsid[] = "$Id: amq.c,v 1.1.1.1 1995/10/18 08:47:13 deraadt Exp $";
d615 1
a615 1
	struct sockaddr_in addr;
d618 2
a619 8
	/* Use internet address family */
	bzero(&addr, sizeof addr);
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	if ((sock = socket(AF_INET, ty, 0)) < 0)
		return -1;
	if (bindresvport(sock, &addr) < 0) {
		close(sock);
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: amq.c,v 1.4 1994/06/13 20:48:20 mycroft Exp $
d55 1
a55 1
static char rcsid[] = "$Id: amq.c,v 1.4 1994/06/13 20:48:20 mycroft Exp $";
a614 1
	int alport;
d619 1
d624 4
a627 8
	for (alport = IPPORT_RESERVED-1; alport > IPPORT_RESERVED/2 + 1; alport--) {
		addr.sin_port = htons((u_short)alport);
		if (bind(sock, (struct sockaddr *)&addr, sizeof (addr)) >= 0)
			return sock;
		if (errno != EADDRINUSE) {
			close(sock);
			return -1;
		}
d629 1
a629 3
	close(sock);
	errno = EAGAIN;
	return -1;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
