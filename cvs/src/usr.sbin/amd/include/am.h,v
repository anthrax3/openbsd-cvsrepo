head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.26
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.22
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.20
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.18
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.16
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.14
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.12
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.10
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.8
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.3.0.22
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.09.11.19.03.31;	author millert;	state Exp;
branches;
next	1.18;
commitid	2QXXvPxjHIjOK2wR;

1.18
date	2015.03.14.23.02.21;	author millert;	state Exp;
branches;
next	1.17;
commitid	FUPdEjTFvnSZMkIS;

1.17
date	2015.01.21.09.51.23;	author guenther;	state Exp;
branches;
next	1.16;
commitid	oYdZZDXoGpj7Akgt;

1.16
date	2014.10.26.03.03.34;	author guenther;	state Exp;
branches;
next	1.15;
commitid	RhupU2WFUkfzry1g;

1.15
date	2014.10.26.02.50.44;	author guenther;	state Exp;
branches;
next	1.14;
commitid	qpzQ4gwGycI1ULjc;

1.14
date	2014.10.20.06.55.59;	author guenther;	state Exp;
branches;
next	1.13;
commitid	1xnKI9ul35JBjA4W;

1.13
date	2014.10.20.02.33.42;	author guenther;	state Exp;
branches;
next	1.12;
commitid	bZbpWDoZDVt0RPe1;

1.12
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.17.18.00.24;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.03.08.29.32;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.18.00.58.58;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.11.05.29.55;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.26.02.49.50;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.31.14.42.18;	author graichen;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.54.54;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.21;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Since immediate_abort is modified by a signal handler it must be
volatile sig_atomic_t.
@
text
@/*	$OpenBSD: am.h,v 1.18 2015/03/14 23:02:21 millert Exp $	*/

/*
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)am.h	5.6 (Berkeley) 6/6/93
 */

#include "config.h"

/*
 * Global declarations
 */
#include <sys/param.h>
#include <sys/socket.h>
#include <rpc/rpc.h>
#include <sys/mount.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include "nfs_prot.h"
#include <assert.h>

/* max length of mount options */
#define	MNTMAXSTR	128

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif /* FALSE */

#ifndef ROOT_MAP
#define	ROOT_MAP "\"root\""
#endif /* ROOT_MAP */

/*
 * Flags from command line
 */
extern int print_pid;		/* Print pid to stdout */
extern int normalize_hosts;	/* Normalize host names before use */
extern int restart_existing_mounts;
extern char *domain;		/* NIS domain to use */
extern int am_timeo;		/* Cache period */
extern int afs_timeo;		/* AFS timeout */
extern int afs_retrans;		/* AFS retrans */
extern int am_timeo_w;		/* Unmount timeout */
extern char *mtab;		/* Mount table */

typedef enum {
	Start,
	Run,
	Finishing,
	Quit,
	Done
} serv_state;

extern serv_state amd_state;	/* Should we go now */
extern volatile sig_atomic_t immediate_abort;
				/* Should close-down unmounts be retried */
extern time_t do_mapc_reload;	/* Flush & reload mount map cache */

/*
 * Useful constants
 */
extern char pid_fsname[];	/* kiska.southseas.nz:(pid%d) */
extern char hostd[];		/* "kiska.southseas.nz" */
extern char *hostdomain;	/* "southseas.nz" */
extern char *op_sys;		/* "sos4" */
extern char *arch;		/* "sun4" */
extern char *karch;		/* "sun4c" */
extern char *cluster;		/* "r+d-kluster" */
extern char *endian;		/* "big" */
extern char *auto_dir;		/* "/a" */
extern char version[];		/* Version info */

typedef struct am_ops am_ops;
typedef struct am_node am_node;
typedef struct am_opts am_opts;
typedef struct mntfs mntfs;
typedef struct fserver fserver;
typedef struct fsrvinfo fsrvinfo;

/*
 * Debug defns.
 */
#ifdef DEBUG
#define	DEBUG_MTAB	"./mtab"

extern int debug_flags;		/* Debug options */

#define	D_DAEMON	0x0001	/* Enter daemon mode */
#define	D_TRACE		0x0002	/* Do protocol trace */
#define	D_FULL		0x0004	/* Do full trace */
#define	D_MTAB		0x0008	/* Use local mtab */
#define	D_AMQ		0x0010	/* Register amq program */
#define	D_STR		0x0020	/* Debug string munging */
#define	D_MEM		0x0040	/* Trace memory allocations */

/*
 * Normally, don't enter daemon mode, and don't register amq
 */
#define	D_TEST	(~(D_DAEMON|D_MEM|D_STR))
#endif /* DEBUG */

/*
 * Global variables.
 */
extern unsigned short nfs_port;	/* Our NFS service port */
extern struct in_addr myipaddr;	/* (An) IP address of this host */

extern int foreground;		/* Foreground process */
extern time_t next_softclock;	/* Time to call softclock() */
extern int task_notify_todo;	/* Task notifier needs running */
#ifdef HAS_TFS
extern int nfs_server_code_available;
#endif /* HAS_TFS */
extern int last_used_map;	/* Last map being used for mounts */
extern AUTH *nfs_auth;		/* Dummy uthorisation for remote servers */
extern am_node **exported_ap;	/* List of nodes */
extern int first_free_map;	/* First free node */
extern am_node *root_node;	/* Node for "root" */
extern char *wire;		/* Name of primary connected network */
#define	NEXP_AP	(254)
#define NEXP_AP_MARGIN (128)

typedef int (*task_fun)(void *);
typedef void (*cb_fun)(int, int, void *);
typedef void (*fwd_fun)(void *, int, struct sockaddr_in *,
				struct sockaddr_in *, void *, int);

/*
 * String comparison macros
 */
#define STREQ(s1, s2) (strcmp((s1), (s2)) == 0)
#define FSTREQ(s1, s2) ((*(s1) == *(s2)) && STREQ((s1),(s2)))

/*
 * Linked list
 */
typedef struct qelem qelem;
struct qelem {
	qelem *q_forw;
	qelem *q_back;
};
#define	FIRST(ty, q)	((ty *) ((q)->q_forw))
#define	LAST(ty, q)	((ty *) ((q)->q_back))
#define	NEXT(ty, q)	((ty *) (((qelem *) q)->q_forw))
#define	PREV(ty, q)	((ty *) (((qelem *) q)->q_back))
#define	HEAD(ty, q)	((ty *) q)
#define	ITER(v, ty, q) \
	for ((v) = FIRST(ty,(q)); (v) != HEAD(ty,(q)); (v) = NEXT(ty,(v)))


struct mntent {
	char	*mnt_fsname;	/* name of mounted file system */
	char	*mnt_dir;	/* file system path prefix */
	char	*mnt_type;	/* MNTTYPE_* */
	char	*mnt_opts;	/* MNTOPT* */
	int	mnt_freq;	/* dump frequency, in days */
	int	mnt_passno;	/* pass number on parallel fsck */
};

/*
 * List of mount table entries
 */
typedef struct mntlist mntlist;
struct mntlist {
	struct mntlist *mnext;
	struct mntent *mnt;
};

/*
 * Mount map
 */
typedef struct mnt_map mnt_map;

struct fhstatus;

/*
 * Global routines
 */
extern void	 am_mounted(am_node *);
extern void	 am_unmounted(am_node *);
extern void	 amq_program_57(struct svc_req *, SVCXPRT *);
extern pid_t	 background(void);
extern int	 bind_resv_port(int, unsigned short *);
extern int	 compute_mount_flags(struct mntent *);
extern int	 softclock(void);
#ifdef DEBUG
extern int	 debug_option(char *);
#endif /* DEBUG */
extern void	 deslashify(char *);
extern void	 discard_mntlist(mntlist *mp);
/*extern void	 domain_strip(char *, char *);*/
extern mntfs	*dup_mntfs(mntfs *);
extern fserver	*dup_srvr(fserver*);
extern int	eval_fs_opts(am_opts *, char *, char *, char *, char *, char *);
extern char	*expand_key(char *);
extern am_node	*exported_ap_alloc(void);
extern am_node	*find_ap(char *);
extern am_node	*find_mf(mntfs *);
extern mntfs	*find_mntfs(am_ops *, am_opts *, char *, char *, char *,
		 char *, char *);
extern void	 flush_mntfs(void);
extern void	 flush_nfs_fhandle_cache(fserver *);
extern void	 flush_srvr_nfs_cache(void);
extern void	 forcibly_timeout_mp(am_node *);
extern void	 free_mntfs(void *);
extern void	 free_opts(am_opts *);
extern void	 free_map(am_node *);
extern void	 free_mntlist(mntlist *);
extern void	 free_srvr(fserver *);
extern int	 fwd_init(void);
extern int	 fwd_packet(int, void *, int, struct sockaddr_in *,
		 struct sockaddr_in *, void *, fwd_fun);
extern void	 fwd_reply(void);
extern void	 get_args(int, char *[]);
extern char	*getwire(void);
extern char	*hasmntopt(struct mntent *, char *);
extern int	 hasmntval(struct mntent *, char *);
extern void	 host_normalize(char **);
extern char	*inet_dquad(char *, size_t, u_int32_t);
extern void	 init_map(am_node *, char *);
extern void	 insert_am(am_node *, am_node *);
extern void	 ins_que(qelem *, qelem *);
extern int	 islocalnet(in_addr_t);
extern int	 make_nfs_auth(void);
extern void	 make_root_node(void);
extern int	 make_rpc_packet(char *, int, u_long, struct rpc_msg *,
		 void *, xdrproc_t, AUTH *);
extern void	 map_flush_srvr(fserver *);
extern void	 mapc_add_kv(mnt_map *, char *, char *);
extern mnt_map	*mapc_find(char *, char *);
extern void	 mapc_free(void *);
extern int	 mapc_keyiter(mnt_map*, void (*)(char *,void *), void *);
extern int	 mapc_search(mnt_map *, char *, char **);
extern void	 mapc_reload(void);
extern void	 mapc_showtypes(FILE *);
extern void	 mf_mounted(mntfs *mf);
extern int	 mkdirs(char *, int);
extern void	 mk_fattr(am_node *, int);
extern void	 mnt_free(struct mntent *);
extern int	 mount_auto_node(char *, void *);
extern int	 mount_automounter(pid_t);
extern int	 mount_exported(void);
extern int	 mount_fs(struct mntent *, int, caddr_t, int, const char *);
extern int	 mount_nfs_fh(struct fhstatus *, char *, char *, char *, mntfs *);
extern int	 mount_node(am_node *);
extern mntfs	*new_mntfs(void);
extern void	 new_ttl(am_node *);
extern am_node	*next_map(int *);
extern int	 nfs_srvr_port(fserver *, u_short *, void *);
extern void	 nfs_program_2(struct svc_req *, SVCXPRT *);
extern void	 normalize_slash(char *);
extern void	 ops_showfstypes(FILE *);
extern int	 pickup_rpc_reply(void *, int, void *, xdrproc_t);
extern mntlist	*read_mtab(char *);
extern mntfs	*realloc_mntfs(mntfs *, am_ops *, am_opts *, char *,
		 char *, char *, char *, char *);
extern void	 rem_que(qelem *);
extern void	 reschedule_timeout_mp(void);
extern void	 reschedule_timeouts(time_t, time_t);
extern void	 restart(void);
extern nfs_fh	*root_fh(char *);
extern void	 rmdirs(char *);
extern am_node	*root_ap(char *, int);
extern int	 root_keyiter(void (*)(char *,void *), void *);
extern void	 root_newmap(char *, char *, char *);
extern void	 rpc_msg_init(struct rpc_msg *, u_long, u_long, u_long);
extern void	 run_task(task_fun, void *, cb_fun, void *);
extern void	 sched_task(cb_fun, void *, void *);
extern void	 show_rcs_info(const char *, char *);
extern void	 sigchld(int);
extern void	 srvrlog(fserver *, char *);
extern char	*str3cat(char *, char *, char *, char *);
extern char	*strnsave(const char *, int);
extern char	*strealloc(char *, char *);
extern char	**strsplit(char *, int, int);
extern int	 switch_option(char *);
extern int	 switch_to_logfile(char *);
extern void	 do_task_notify(void);
extern int	 timeout(unsigned int, void (*fn)(void *), void *);
extern void	 umount_exported(void);
extern int	 umount_fs(char *);
/*extern int unmount_node(am_node*);
extern int unmount_node_wrap(void *);*/
extern void	 unregister_amq(void);
extern void	 untimeout(int);
extern int	 valid_key(char *);
extern void	 wakeup(void *);
extern void	 wakeup_task(int, int, void *);
extern void	 wakeup_srvr(fserver *);
extern void	 write_mntent(struct mntent *);


#define	ALLOC(ty)	((struct ty *) xmalloc(sizeof(struct ty)))

/*
 * Options
 */
struct am_opts {
	char	*fs_glob;		/* Smashed copy of global options */
	char	*fs_local;		/* Expanded copy of local options */
	char	*fs_mtab;		/* Mount table entry */
	/* Other options ... */
	char	*opt_dev;
	char	*opt_delay;
	char	*opt_dir;
	char	*opt_fs;
	char	*opt_group;
	char	*opt_mount;
	char	*opt_opts;
	char	*opt_remopts;
	char	*opt_pref;
	char	*opt_cache;
	char	*opt_rfs;
	char	*opt_rhost;
	char	*opt_sublink;
	char	*opt_type;
	char	*opt_unmount;
	char	*opt_user;
};

/*
 * File Handle
 *
 * This is interpreted by indexing the exported array
 * by fhh_id.
 *
 * The whole structure is mapped onto a standard fhandle_t
 * when transmitted.
 */
struct am_fh {
	int	fhh_pid;		/* process id */
	int	fhh_id;			/* map id */
	int	fhh_gen;		/* generation number */
};

extern am_node	*fh_to_mp(nfs_fh *);
extern am_node	*fh_to_mp3(nfs_fh *, int *, int);
extern void	 mp_to_fh(am_node *, nfs_fh *);
#define	fh_to_mp2(fhp, rp) fh_to_mp3(fhp, rp, VLOOK_CREATE)
extern int	 auto_fmount(am_node *mp);
extern int	 auto_fumount(am_node *mp);

#define	MAX_READDIR_ENTRIES	16

typedef char	*(*vfs_match)(am_opts *);
typedef int	 (*vfs_init)(mntfs *);
typedef int	 (*vmount_fs)(am_node *);
typedef int	 (*vfmount_fs)(mntfs *);
typedef int	 (*vumount_fs)(am_node *);
typedef int	 (*vfumount_fs)(mntfs *);
typedef am_node	*(*vlookuppn)(am_node *, char *, int *, int);
typedef int	 (*vreaddir)(am_node *, nfscookie, dirlist *, entry *, int);
typedef am_node	*(*vreadlink)(am_node *, int *);
typedef void	 (*vmounted)(mntfs *);
typedef void	 (*vumounted)(am_node *);
typedef fserver	*(*vffserver)(mntfs *);

struct am_ops {
	char		*fs_type;
	vfs_match	fs_match;
	vfs_init	fs_init;
	vmount_fs	mount_fs;
	vfmount_fs	fmount_fs;
	vumount_fs	umount_fs;
	vfumount_fs	fumount_fs;
	vlookuppn	lookuppn;
	vreaddir	readdir;
	vreadlink	readlink;
	vmounted	mounted;
	vumounted	umounted;
	vffserver	ffserver;
	int		fs_flags;
};
extern am_node	*efs_lookuppn(am_node *, char *, int *, int);
extern int	 efs_readdir(am_node *, nfscookie, dirlist *, entry *, int);

#define	VLOOK_CREATE	0x1
#define	VLOOK_DELETE	0x2

#define FS_DIRECTORY	0x0001		/* This looks like a dir, not a link */
#define	FS_MBACKGROUND	0x0002		/* Should background this mount */
#define	FS_NOTIMEOUT	0x0004		/* Don't bother with timeouts */
#define FS_MKMNT	0x0008		/* Need to make the mount point */
#define FS_UBACKGROUND	0x0010		/* Unmount in background */
#define	FS_BACKGROUND	(FS_MBACKGROUND|FS_UBACKGROUND)
#define	FS_DISCARD	0x0020		/* Discard immediately on last reference */
#define	FS_AMQINFO	0x0040		/* Amq is interested in this fs type */

#ifdef SUNOS4_COMPAT
extern am_ops	*sunos4_match(am_opts *, char *, char *, char *, char *, char *);
#endif /* SUNOS4_COMPAT */
extern am_ops	*ops_match(am_opts *, char *, char *, char *, char *, char *);
#include "fstype.h"

/*
 * Per-mountpoint statistics
 */
struct am_stats {
	time_t	s_mtime;	/* Mount time */
	u_short	s_uid;		/* Uid of mounter */
	int	s_getattr;	/* Count of getattrs */
	int	s_lookup;	/* Count of lookups */
	int	s_readdir;	/* Count of readdirs */
	int	s_readlink;	/* Count of readlinks */
	int	s_statfs;	/* Count of statfs */
};
typedef struct am_stats am_stats;

/*
 * System statistics
 */
struct amd_stats {
	int	d_drops;	/* Dropped requests */
	int	d_stale;	/* Stale NFS handles */
	int	d_mok;		/* Successful mounts */
	int	d_merr;		/* Failed mounts */
	int	d_uerr;		/* Failed unmounts */
};
extern struct amd_stats amd_stats;

/*
 * List of fileservers
 */
struct fserver {
	qelem		fs_q;		/* List of fileservers */
	int		fs_refc;	/* Number of references to this node */
	char		*fs_host;	/* Normalized hostname of server */
	struct sockaddr_in *fs_ip;	/* Network address of server */
	int		fs_cid;		/* Callout id */
	int		fs_pinger;	/* Ping (keepalive) interval */
	int		fs_flags;	/* Flags */
	char		*fs_type;	/* File server type */
	void 		*fs_private;	/* Private data */
	void		(*fs_prfree)(void *);	/* Free private data */
};
#define	FSF_VALID	0x0001		/* Valid information available */
#define	FSF_DOWN	0x0002		/* This fileserver is thought to be down */
#define	FSF_ERROR	0x0004		/* Permanent error has occured */
#define	FSF_WANT	0x0008		/* Want a wakeup call */
#define	FSF_PINGING	0x0010		/* Already doing pings */
#define	FSRV_ISDOWN(fs)	(((fs)->fs_flags & (FSF_DOWN|FSF_VALID)) == (FSF_DOWN|FSF_VALID))
#define	FSRV_ISUP(fs)	(((fs)->fs_flags & (FSF_DOWN|FSF_VALID)) == (FSF_VALID))

/*
 * List of mounted filesystems
 */
struct mntfs {
	qelem		mf_q;		/* List of mounted filesystems */
	am_ops		*mf_ops;	/* Operations on this mountpoint */
	am_opts		*mf_fo;		/* File opts */
	char		*mf_mount;	/* "/a/kiska/home/kiska" */
	char		*mf_info;	/* Mount info */
	char		*mf_auto;	/* Automount opts */
	char		*mf_mopts;	/* FS mount opts */
	char		*mf_remopts;	/* Remote FS mount opts */
	fserver		*mf_server;	/* File server */
	int		mf_flags;	/* Flags */
	int		mf_error;	/* Error code from background mount */
	int		mf_refc;	/* Number of references to this node */
	int		mf_cid;		/* Callout id */
	void		(*mf_prfree)(void *);	/* Free private space */
	void 		*mf_private;	/* Private - per-fs data */
};

#define	MFF_MOUNTED	0x0001		/* Node is mounted */
#define	MFF_MOUNTING	0x0002		/* Mount is in progress */
#define	MFF_UNMOUNTING	0x0004		/* Unmount is in progress */
#define	MFF_RESTART	0x0008		/* Restarted node */
#define MFF_MKMNT	0x0010		/* Delete this node's am_mount */
#define	MFF_ERROR	0x0020		/* This node failed to mount */
#define	MFF_LOGDOWN	0x0040		/* Logged that this mount is down */
#define	MFF_RSTKEEP	0x0080		/* Don't timeout this filesystem - restarted */
#define	MFF_WANTTIMO	0x0100		/* Need a timeout call when not busy */

/*
 * Map of auto-mount points.
 */
struct am_node {
	int		am_mapno;	/* Map number */
	mntfs		*am_mnt;	/* Mounted filesystem */
	char		*am_name;	/* "kiska"
					   Name of this node */
	char		*am_path;	/* "/home/kiska"
					   Path of this node's mount point */
	char		*am_link;	/* "/a/kiska/home/kiska/this/that"
					   Link to sub-directory */
	am_node		*am_parent,	/* Parent of this node */
			*am_ysib,	/* Younger sibling of this node */
			*am_osib,	/* Older sibling of this node */
			*am_child;	/* First child of this node */
	struct attrstat	am_attr;	/* File attributes */
#define am_fattr	am_attr.attrstat_u.attributes
	int		am_flags;	/* Boolean flags */
	int		am_error;	/* Specific mount error */
	time_t		am_ttl;		/* Time to live */
	int		am_timeo_w;	/* Wait interval */
	int		am_timeo;	/* Timeout interval */
	unsigned int	am_gen;		/* Generation number */
	char		*am_pref;	/* Mount info prefix */
	am_stats	am_stats;	/* Statistics gathering */
};

#define	AMF_NOTIMEOUT	0x0001		/* This node never times out */
#define	AMF_ROOT	0x0002		/* This is a root node */

#define	ONE_HOUR	(60 * 60)	/* One hour in seconds */

/*
 * The following values can be tuned...
 */
#define	ALLOWED_MOUNT_TIME	40		/* 40s for a mount */
#define	AM_TTL			(5 * 60)	/* Default cache period */
#define	AM_TTL_W		(2 * 60)	/* Default unmount interval */
#define	AM_PINGER		30		/* NFS ping interval for live systems */
#define	AFS_TIMEO		8		/* Default afs timeout - .8s */
#define	AFS_RETRANS		((ALLOWED_MOUNT_TIME*10+5*afs_timeo)/afs_timeo * 2)
						/* Default afs retrans - 1/10th seconds */

#define	RPC_XID_PORTMAP		0
#define	RPC_XID_MOUNTD		1
#define	RPC_XID_NFSPING		2
#define	RPC_XID_MASK		(0x0f)		/* 16 id's for now */
#define	MK_RPC_XID(type_id, uniq)	((type_id) | ((uniq) << 4))
@


1.18
log
@Add missing #include <stdint.h> for SIZE_MAX.
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.17 2015/01/21 09:51:23 guenther Exp $	*/
d88 2
a89 1
extern int immediate_abort;	/* Should close-down unmounts be retried */
@


1.17
log
@Pass times as int64_t and eliminate the (long disabled) mount request.
ABI change, so roll the RPC protocol version; how about 57 for OpenBSD 5.7?
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.16 2014/10/26 03:03:34 guenther Exp $	*/
d49 1
@


1.16
log
@Update to the modern RPC style with different names for server and client
    stubs (they have different prototypes, after all).
Fill in missing prototypes.
Use void* arguments on closure-style callbacks, with local variables of
    the expected type.
Keep deleting unnecessary casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.15 2014/10/26 02:50:44 guenther Exp $	*/
d212 1
a212 1
extern void	 amq_program_1(struct svc_req *, SVCXPRT *);
@


1.15
log
@timeout_mp() is static now
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.14 2014/10/20 06:55:59 guenther Exp $	*/
d212 1
d236 1
a236 1
extern void	 free_mntfs(mntfs *);
d262 1
a262 1
extern void	 mapc_free(mnt_map *);
d281 1
d290 1
d292 1
d310 1
a310 1
extern int	 timeout(unsigned int, void (*fn)(), void *);
d465 1
a465 1
	void		(*fs_prfree)();	/* Free private data */
d492 1
a492 1
	void		(*mf_prfree)();	/* Free private space */
@


1.14
log
@Change MTAB_TYPE_UFS from "ufs" to "ffs", fixing mount-restarting for them.
Perform one level of expansion on the various "portability" macros from os-*.h
Delete support for Hesiod and the pre-4.4 versions of the NFS API
Delete the no-op unlock_mntlist()
unifdef -UFASCIST_DF_COMMAND -UMOUNT_HELPER_SOURCE
Move the struct mntent and MNTMAXSTR definitions into include/am.h
Move the commented-out -DHAS_NDBM_MAPS into amd/Makefile
Expand OS_REP to "bsd44".
With config/* empty, delete them.

"lot of stuff...but I know your process on this" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.13 2014/10/20 02:33:42 guenther Exp $	*/
a306 1
extern void	 timeout_mp(void);
@


1.13
log
@unifdef -DHAS_REGEXP -DHAS_PASSWD_MAPS -DHAS_FILE_MAPS \
  -DHAS_NIS_MAPS -DHAS_NIS_RELOAD -DRPC_4 -DHAS_UNION_MAPS \
  -DHAS_TCP_NFS -DOS_HAS_NDBM -DNFS_PROTOCOL_VERSION=3 \
  -DNFS_ARGS_NEEDS_PATH -DPRECISE_SYMLINKS -DHAS_EMPTY_AUTOMOUNTS \
  -DNEED_MNTOPT_PARSER -DSHORT_MOUNT_NAME -DHAS_NFS_QUALIFIED_NAMES \
  -UUPDATE_MTAB -UFIXUP_MNTENT -UMNTENT_HDR -UMNTINFO_DEV \
  -UMNTOPT_COMPRESS -UMNTOPT_NQNFS -UINFORM_MOUNTD \
  -USUNOS4_WORKAROUND -UULTRIX_HACK

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.12 2009/10/27 23:59:51 deraadt Exp $	*/
d53 2
a54 11
#ifdef DEBUG_MEM
#include <malloc.h>
#endif /* DEBUG_MEM */

#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN 64
#endif /* MAXHOSTNAMELEN */

#ifndef MNTTYPE_AUTO
#define MNTTYPE_AUTO "auto"
#endif /* MNTTYPE_AUTO */
d181 10
d273 1
a273 1
extern int	 mount_fs(struct mntent *, int, caddr_t, int, MTYPE_TYPE);
a318 1
#define	unlock_mntlist()
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.11 2003/11/08 19:17:29 jmc Exp $	*/
a49 8
#ifdef MNTENT_HDR
#include MNTENT_HDR
#endif /* MNTENT_HDR */
#ifndef NFS_PROTOCOL_VERSION
#if NFS_ARGSVERSION >= 3
#define NFS_PROTOCOL_VERSION 3
#endif /* NFS_ARGSVERSION >= 3 */
#endif /* NFS_PROTOCOL_VERSION */
a79 1
#ifdef HAS_NIS_MAPS
a80 1
#endif /* HAS_NIS_MAPS */
a244 1
#ifdef NEED_MNTOPT_PARSER
a245 1
#endif /* NEED_MNTOPT_PARSER */
a287 3
#ifdef UPDATE_MTAB
extern void	 rewrite_mtab(mntlist *);
#endif /* UPDATE_MTAB */
a317 3
#ifdef UPDATE_MTAB
extern void	 unlock_mntlist(void);
#else
a318 1
#endif /* UPDATE_MTAB */
@


1.11
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.10 2003/06/17 18:00:24 millert Exp $	*/
a120 1
extern char copyright[];	/* Copyright info */
@


1.10
log
@Use getifaddrs() to get the list of interfaces.  This fixes the
"wire" variable which may be used in amd maps to select an NFS
server based on the subnet.  Tested by matthieu@@; OK by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.9 2003/06/02 23:36:52 millert Exp $	*/
d463 1
a463 1
	int	d_mok;		/* Succesful mounts */
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.8 2002/08/05 07:24:26 pvalchev Exp $	*/
d265 1
a265 1
extern int	 islocalnet(u_int32_t);
@


1.8
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.7 2002/08/03 08:29:32 pvalchev Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.6 2002/07/18 00:58:58 pvalchev Exp $	*/
d178 4
a181 4
typedef int (*task_fun)(voidp);
typedef void (*cb_fun)(int, int, voidp);
typedef void (*fwd_fun)(voidp, int, struct sockaddr_in *,
				struct sockaddr_in *, voidp, int);
d226 1
a226 1
extern pid_t	 background(P_void);
d229 1
a229 1
extern int	 softclock(P_void);
d235 1
a235 1
/*extern void	 domain_strip(char*, char *);*/
d240 1
a240 1
extern am_node	*exported_ap_alloc(P_void);
d245 1
a245 1
extern void	 flush_mntfs(P_void);
d254 4
a257 4
extern int	 fwd_init(P_void);
extern int	 fwd_packet(int, voidp, int, struct sockaddr_in *,
		 struct sockaddr_in *, voidp, fwd_fun);
extern void	 fwd_reply(P_void);
d271 1
a271 1
extern void	 make_root_node(P_void);
d273 1
a273 1
		 voidp, xdrproc_t, AUTH *);
d278 1
a278 1
extern int	 mapc_keyiter(mnt_map*, void (*)(char *,voidp), voidp);
d280 1
a280 1
extern void	 mapc_reload(P_void);
d286 1
a286 1
extern int	 mount_auto_node(char *, voidp);
d288 1
a288 1
extern int	 mount_exported(P_void);
d292 1
a292 1
extern mntfs	*new_mntfs(P_void);
d295 1
a295 1
extern int	 nfs_srvr_port(fserver *, u_short *, voidp);
d298 1
a298 1
extern int	 pickup_rpc_reply(voidp, int, voidp, xdrproc_t);
d303 2
a304 2
extern void	 reschedule_timeout_mp(P_void);
extern void	 restart(P_void);
d310 1
a310 1
extern int	 root_keyiter(void (*)(char *,voidp), voidp);
d313 3
a315 3
extern void	 run_task(task_fun, voidp, cb_fun, voidp);
extern void	 sched_task(cb_fun, voidp, voidp);
extern void	 show_rcs_info(Const char *, char *);
d319 1
a319 1
extern char	*strnsave(Const char *, int);
d324 4
a327 4
extern void	 do_task_notify(P_void);
extern int	 timeout(unsigned int, void (*fn)(), voidp);
extern void	 timeout_mp(P_void);
extern void	 umount_exported(P_void);
d330 2
a331 2
extern int unmount_node_wrap(voidp);*/
extern void	 unregister_amq(P_void);
d334 2
a335 2
extern void	 wakeup(voidp);
extern void	 wakeup_task(int, int, voidp);
d485 1
a485 1
	voidp		fs_private;	/* Private data */
d514 1
a514 1
	voidp		mf_private;	/* Private - per-fs data */
@


1.6
log
@ansify, style changes, removal of bogus libc function prototypes; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.5 2002/06/11 05:29:55 itojun Exp $	*/
d178 4
a181 4
typedef int (*task_fun)P((voidp));
typedef void (*cb_fun)P((int, int, voidp));
typedef void (*fwd_fun)P((voidp, int, struct sockaddr_in *,
				struct sockaddr_in *, voidp, int));
d219 2
d234 1
d247 1
d282 1
d290 1
a290 1
/*extern int	 mount_nfs_fh(struct fhstatus *, char *, char *, char *, mntfs *);*/
d329 2
a330 2
/*extern int unmount_node P((am_node*));
extern int unmount_node_wrap P((voidp));*/
d388 3
a390 3
extern am_node *fh_to_mp P((nfs_fh*));
extern am_node *fh_to_mp3 P((nfs_fh*,int*,int));
extern void mp_to_fh P((am_node*, nfs_fh*));
d392 2
a393 2
extern int auto_fmount P((am_node *mp));
extern int auto_fumount P((am_node *mp));
d397 12
a408 12
typedef char*	(*vfs_match)P((am_opts*));
typedef int	(*vfs_init)P((mntfs*));
typedef int	(*vmount_fs)P((am_node*));
typedef int	(*vfmount_fs)P((mntfs*));
typedef int	(*vumount_fs)P((am_node*));
typedef int	(*vfumount_fs)P((mntfs*));
typedef am_node*(*vlookuppn)P((am_node*, char*, int*, int));
typedef int	(*vreaddir)P((am_node*, nfscookie, dirlist*, entry*, int));
typedef am_node*(*vreadlink)P((am_node*, int*));
typedef void	(*vmounted)P((mntfs*));
typedef void	(*vumounted)P((am_node*));
typedef fserver*(*vffserver)P((mntfs*));
d426 2
a427 2
extern am_node *efs_lookuppn P((am_node*, char*, int*, int));
extern int efs_readdir P((am_node*, nfscookie, dirlist*, entry*, int));
@


1.5
log
@use snprintf.
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.4 2002/05/26 02:49:50 deraadt Exp $	*/
d222 6
a227 7
extern int atoi P((Const char *)); /* C */
extern void am_mounted P((am_node*));
extern void am_unmounted P((am_node*));
extern pid_t background(P_void);
extern int bind_resv_port P((int, unsigned short*));
extern int compute_mount_flags P((struct mntent *));
extern int softclock(P_void);
d229 1
a229 1
extern int debug_option P((char*));
d231 25
a255 25
extern void deslashify P((char*));
/*extern void domain_strip P((char*, char*));*/
extern mntfs* dup_mntfs P((mntfs*));
extern fserver* dup_srvr P((fserver*));
extern int eval_fs_opts P((am_opts*, char*, char*, char*, char*, char*));
extern char* expand_key P((char*));
extern am_node* exported_ap_alloc(P_void);
extern am_node* find_ap P((char*));
extern am_node* find_mf P((mntfs*));
extern mntfs* find_mntfs P((am_ops*, am_opts*, char*, char*, char*, char*, char*));
extern void flush_mntfs(P_void);
extern void flush_nfs_fhandle_cache P((fserver*));
extern void forcibly_timeout_mp P((am_node*));
extern FREE_RETURN_TYPE free P((voidp)); /* C */
extern void free_mntfs P((mntfs*));
extern void free_opts P((am_opts*));
extern void free_map P((am_node*));
extern void free_mntlist P((mntlist*));
extern void free_srvr P((fserver*));
extern int fwd_init(P_void);
extern int fwd_packet P((int, voidp, int, struct sockaddr_in *,
		struct sockaddr_in *, voidp, fwd_fun));
extern void fwd_reply(P_void);
extern void get_args P((int, char*[]));
extern char *getwire P((void));
d257 1
a257 1
extern char *hasmntopt P((struct mntent*, char*));
d259 41
a299 39
extern int hasmntval P((struct mntent*, char*));
extern void host_normalize P((char **));
extern char *inet_dquad P((char*, size_t, u_int32_t));
extern void init_map P((am_node*, char*));
extern void insert_am P((am_node*, am_node*));
extern void ins_que P((qelem*, qelem*));
extern int islocalnet P((u_int32_t));
extern int make_nfs_auth P((void));
extern void make_root_node(P_void);
extern int make_rpc_packet P((char*, int, u_long, struct rpc_msg*, voidp, xdrproc_t, AUTH*));
extern void map_flush_srvr P((fserver*));
extern void mapc_add_kv P((mnt_map*, char*, char*));
extern mnt_map* mapc_find P((char*, char*));
extern void mapc_free P((mnt_map*));
extern int mapc_keyiter P((mnt_map*, void (*)(char*,voidp), voidp));
extern int mapc_search P((mnt_map*, char*, char**));
extern void mapc_reload(P_void);
extern void mapc_showtypes P((FILE*));
extern int mkdirs P((char*, int));
extern void mk_fattr P((am_node*, int));
extern void mnt_free P((struct mntent*));
extern int mount_auto_node P((char*, voidp));
extern int mount_automounter P((pid_t));
extern int mount_exported(P_void);
extern int mount_fs P((struct mntent*, int, caddr_t, int, MTYPE_TYPE));
/*extern int mount_nfs_fh P((struct fhstatus*, char*, char*, char*, mntfs*));*/
extern int mount_node P((am_node*));
extern mntfs* new_mntfs(P_void);
extern void new_ttl P((am_node*));
extern am_node* next_map P((int*));
extern int nfs_srvr_port P((fserver*, u_short*, voidp));
extern void normalize_slash P((char*));
extern void ops_showfstypes P((FILE*));
extern int pickup_rpc_reply P((voidp, int, voidp, xdrproc_t));
extern mntlist* read_mtab P((char*));
extern mntfs* realloc_mntfs  P((mntfs*, am_ops*, am_opts*, char*, char*, char*, char*, char*));
extern void rem_que P((qelem*));
extern void reschedule_timeout_mp(P_void);
extern void restart(P_void);
d301 1
a301 1
extern void rewrite_mtab P((mntlist *));
d303 21
a323 25
extern void rmdirs P((char*));
extern am_node* root_ap P((char*, int));
extern int root_keyiter P((void (*)(char*,voidp), voidp));
extern void root_newmap P((char*, char*, char*));
extern void rpc_msg_init P((struct rpc_msg*, u_long, u_long, u_long));
extern void run_task P((task_fun, voidp, cb_fun, voidp));
extern void sched_task P((cb_fun, voidp, voidp));
extern void show_rcs_info P((Const char*, char*));
extern void sigchld P((int));
extern void srvrlog P((fserver*, char*));
extern char* str3cat P((char*, char*, char*, char*));
extern char* strcat P((char*, Const char*)); /* C */
extern int strcmp P((Const char*, Const char*)); /* C */
extern char* strdup P((Const char*));
extern char* strnsave P((Const char*, int));
extern char* strrchr P((Const char*, int)); /* C */
extern char* strealloc P((char*, char *));
extern char** strsplit P((char*, int, int));
extern int switch_option P((char*));
extern int switch_to_logfile P((char*));
extern void do_task_notify(P_void);
extern int timeout P((unsigned int, void (*fn)(), voidp));
extern void timeout_mp(P_void);
extern void umount_exported(P_void);
extern int umount_fs P((char*));
d326 7
a332 7
extern void unregister_amq(P_void);
extern void untimeout P((int));
extern int valid_key P((char*));
extern void wakeup P((voidp));
extern void wakeup_task P((int,int,voidp));
extern void wakeup_srvr P((fserver*));
extern void write_mntent P((struct mntent*));
d334 1
a334 1
extern void unlock_mntlist P((void));
d437 1
a437 1
extern am_ops *sunos4_match P((am_opts*, char*, char*, char*, char*, char*));
d439 1
a439 1
extern am_ops *ops_match P((am_opts*, char*, char*, char*, char*, char*));
@


1.4
log
@pid_cleanup, inspired by work by jason@@ackley.net
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.3 1997/01/31 14:42:18 graichen Exp $	*/
d262 1
a262 1
extern char *inet_dquad P((char*, u_int32_t));
@


1.3
log
@make amd 64bit ready for the alpha (from NetBSD/thorpej)
@
text
@d1 1
a1 1
/*	$OpenBSD: am.h,v 1.2 1996/03/25 15:54:54 niklas Exp $	*/
d225 1
a225 1
extern int background(P_void);
d282 1
a282 1
extern int mount_automounter P((int));
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 2
d262 1
a262 1
extern char *inet_dquad P((char*, unsigned long));
d266 1
a266 1
extern int islocalnet P((unsigned long));
a315 1
extern int strlen P((Const char*)); /* C */
@


1.1
log
@Initial revision
@
text
@d1 2
a40 2
 *	$Id: am.h,v 1.3 1994/06/13 20:50:34 mycroft Exp $
 *
d51 1
a51 1
#include "nfs_prot.h"
d55 6
d277 1
a277 1
extern void mk_fattr P((am_node*, enum ftype));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
