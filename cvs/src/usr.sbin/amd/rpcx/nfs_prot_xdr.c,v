head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.6
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.4
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.4.0.8
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.4
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.48
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.46
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.42
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.40
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.1.0.24
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.22
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.20
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2016.12.25.16.35.07;	author krw;	state Exp;
branches;
next	1.4;
commitid	UQSWJgrFZY0Qexil;

1.4
date	2015.01.22.03.43.58;	author guenther;	state Exp;
branches;
next	1.3;
commitid	rWRB7wdvhHzZsMSB;

1.3
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.10.05.41.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.23;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Regenerate with -current rpcgen, eliminating "unused variable 'i'"
warning.

ok millert@@
@
text
@/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "nfs_prot.h"

bool_t
xdr_nfs_fh(XDR *xdrs, nfs_fh *objp)
{


	if (!xdr_opaque(xdrs, objp->data, NFS_FHSIZE))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_nfstime(XDR *xdrs, nfstime *objp)
{


	if (!xdr_u_int(xdrs, &objp->seconds))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->useconds))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fattr(XDR *xdrs, fattr *objp)
{


	if (!xdr_int(xdrs, &objp->type))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->mode))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->nlink))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->uid))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->gid))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->size))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->blocksize))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->rdev))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->blocks))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->fsid))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->fileid))
		return (FALSE);
	if (!xdr_nfstime(xdrs, &objp->atime))
		return (FALSE);
	if (!xdr_nfstime(xdrs, &objp->mtime))
		return (FALSE);
	if (!xdr_nfstime(xdrs, &objp->ctime))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_sattr(XDR *xdrs, sattr *objp)
{


	if (!xdr_u_int(xdrs, &objp->mode))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->uid))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->gid))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->size))
		return (FALSE);
	if (!xdr_nfstime(xdrs, &objp->atime))
		return (FALSE);
	if (!xdr_nfstime(xdrs, &objp->mtime))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_filename(XDR *xdrs, filename *objp)
{

	if (!xdr_string(xdrs, objp, NFS_MAXNAMLEN))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_nfspath(XDR *xdrs, nfspath *objp)
{

	if (!xdr_string(xdrs, objp, NFS_MAXPATHLEN))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_attrstat(XDR *xdrs, attrstat *objp)
{

	if (!xdr_int(xdrs, &objp->status))
		return (FALSE);
	switch (objp->status) {
	case NFS_OK:
		if (!xdr_fattr(xdrs, &objp->attrstat_u.attributes))
			return (FALSE);
		break;
	default:
		break;
	}
	return (TRUE);
}

bool_t
xdr_sattrargs(XDR *xdrs, sattrargs *objp)
{


	if (!xdr_nfs_fh(xdrs, &objp->file))
		return (FALSE);
	if (!xdr_sattr(xdrs, &objp->attributes))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_diropargs(XDR *xdrs, diropargs *objp)
{


	if (!xdr_nfs_fh(xdrs, &objp->dir))
		return (FALSE);
	if (!xdr_filename(xdrs, &objp->name))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_diropokres(XDR *xdrs, diropokres *objp)
{


	if (!xdr_nfs_fh(xdrs, &objp->file))
		return (FALSE);
	if (!xdr_fattr(xdrs, &objp->attributes))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_diropres(XDR *xdrs, diropres *objp)
{

	if (!xdr_int(xdrs, &objp->status))
		return (FALSE);
	switch (objp->status) {
	case NFS_OK:
		if (!xdr_diropokres(xdrs, &objp->diropres_u.diropres))
			return (FALSE);
		break;
	default:
		break;
	}
	return (TRUE);
}

bool_t
xdr_readlinkres(XDR *xdrs, readlinkres *objp)
{

	if (!xdr_int(xdrs, &objp->status))
		return (FALSE);
	switch (objp->status) {
	case NFS_OK:
		if (!xdr_nfspath(xdrs, &objp->readlinkres_u.data))
			return (FALSE);
		break;
	default:
		break;
	}
	return (TRUE);
}

bool_t
xdr_readargs(XDR *xdrs, readargs *objp)
{


	if (!xdr_nfs_fh(xdrs, &objp->file))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->offset))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->count))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->totalcount))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_readokres(XDR *xdrs, readokres *objp)
{


	if (!xdr_fattr(xdrs, &objp->attributes))
		return (FALSE);
	if (!xdr_bytes(xdrs, (char **)&objp->data.data_val,
	    (u_int *)&objp->data.data_len,
	    NFS_MAXDATA))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_readres(XDR *xdrs, readres *objp)
{

	if (!xdr_int(xdrs, &objp->status))
		return (FALSE);
	switch (objp->status) {
	case NFS_OK:
		if (!xdr_readokres(xdrs, &objp->readres_u.reply))
			return (FALSE);
		break;
	default:
		break;
	}
	return (TRUE);
}

bool_t
xdr_writeargs(XDR *xdrs, writeargs *objp)
{


	if (!xdr_nfs_fh(xdrs, &objp->file))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->beginoffset))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->offset))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->totalcount))
		return (FALSE);
	if (!xdr_bytes(xdrs, (char **)&objp->data.data_val,
	    (u_int *)&objp->data.data_len,
	    NFS_MAXDATA))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_createargs(XDR *xdrs, createargs *objp)
{


	if (!xdr_diropargs(xdrs, &objp->where))
		return (FALSE);
	if (!xdr_sattr(xdrs, &objp->attributes))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_renameargs(XDR *xdrs, renameargs *objp)
{


	if (!xdr_diropargs(xdrs, &objp->from))
		return (FALSE);
	if (!xdr_diropargs(xdrs, &objp->to))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_linkargs(XDR *xdrs, linkargs *objp)
{


	if (!xdr_nfs_fh(xdrs, &objp->from))
		return (FALSE);
	if (!xdr_diropargs(xdrs, &objp->to))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_symlinkargs(XDR *xdrs, symlinkargs *objp)
{


	if (!xdr_diropargs(xdrs, &objp->from))
		return (FALSE);
	if (!xdr_nfspath(xdrs, &objp->to))
		return (FALSE);
	if (!xdr_sattr(xdrs, &objp->attributes))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_nfscookie(XDR *xdrs, nfscookie objp)
{

	if (!xdr_opaque(xdrs, objp, NFS_COOKIESIZE))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_readdirargs(XDR *xdrs, readdirargs *objp)
{


	if (!xdr_nfs_fh(xdrs, &objp->dir))
		return (FALSE);
	if (!xdr_nfscookie(xdrs, objp->cookie))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->count))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_entry(XDR *xdrs, entry *objp)
{


	if (!xdr_u_int(xdrs, &objp->fileid))
		return (FALSE);
	if (!xdr_filename(xdrs, &objp->name))
		return (FALSE);
	if (!xdr_nfscookie(xdrs, objp->cookie))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->nextentry, sizeof(entry), (xdrproc_t)xdr_entry))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_dirlist(XDR *xdrs, dirlist *objp)
{


	if (!xdr_pointer(xdrs, (char **)&objp->entries, sizeof(entry), (xdrproc_t)xdr_entry))
		return (FALSE);
	if (!xdr_bool(xdrs, &objp->eof))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_readdirres(XDR *xdrs, readdirres *objp)
{

	if (!xdr_int(xdrs, &objp->status))
		return (FALSE);
	switch (objp->status) {
	case NFS_OK:
		if (!xdr_dirlist(xdrs, &objp->readdirres_u.reply))
			return (FALSE);
		break;
	default:
		break;
	}
	return (TRUE);
}

bool_t
xdr_statfsokres(XDR *xdrs, statfsokres *objp)
{


	if (!xdr_u_int(xdrs, &objp->tsize))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->bsize))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->blocks))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->bfree))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->bavail))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_statfsres(XDR *xdrs, statfsres *objp)
{

	if (!xdr_int(xdrs, &objp->status))
		return (FALSE);
	switch (objp->status) {
	case NFS_OK:
		if (!xdr_statfsokres(xdrs, &objp->statfsres_u.reply))
			return (FALSE);
		break;
	default:
		break;
	}
	return (TRUE);
}
@


1.4
log
@amd's nfs_prot.x file has some tweaks from the standard; automate them with ed.
Regenerate the amd's NFS RPC stubs with a current rpcgen, automating the
  post-generation tweaks to the svc stubs.  However, do follow the modern
  naming style where the svc stubs have a _svc suffix.
As a side benefit, this eliminates the need to #include <nfs/nfsproto.h>
This is all a prelude to updating amd to talk NFSv3 with the kernel for
  its own "toplvl" mounts, to squash another y2038 issue.
@
text
@a10 1
	int i;
d115 2
d168 2
d185 2
d232 2
d370 2
d404 2
@


1.3
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 2
a3 35
 * Copyright (c) 1989 Jan-Simon Pendry
 * Copyright (c) 1989 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)nfs_prot_xdr.c	8.1 (Berkeley) 6/6/93
 *	$Id: nfs_prot_xdr.c,v 1.2 2002/09/10 05:41:04 deraadt Exp $
 *
d6 1
a6 1
#include "am.h"
a7 2

#ifndef xdr_nfsstat
d9 1
a9 3
xdr_nfsstat(xdrs, objp)
	XDR *xdrs;
	nfsstat *objp;
d11 1
a11 7
	if (!xdr_enum(xdrs, (enum_t *)objp)) {
		return (FALSE);
	}
	return (TRUE);
}
#endif /* xdr_nfsstat */

d14 1
a14 7
#ifndef xdr_ftype
static bool_t
xdr_ftype(xdrs, objp)
	XDR *xdrs;
	ftype *objp;
{
	if (!xdr_enum(xdrs, (enum_t *)objp)) {
a15 1
	}
a17 3
#endif /* xdr_ftype */


d20 1
a20 3
xdr_nfs_fh(xdrs, objp)
	XDR *xdrs;
	nfs_fh *objp;
a21 6
	if (!xdr_opaque(xdrs, objp->data, NFS_FHSIZE)) {
		return (FALSE);
	}
	return (TRUE);
}

d24 1
a24 7

static bool_t
xdr_nfstime(xdrs, objp)
	XDR *xdrs;
	nfstime *objp;
{
	if (!xdr_u_int(xdrs, &objp->seconds)) {
d26 1
a26 2
	}
	if (!xdr_u_int(xdrs, &objp->useconds)) {
a27 1
	}
d31 3
d36 1
a36 7

static bool_t
xdr_fattr(xdrs, objp)
	XDR *xdrs;
	fattr *objp;
{
	if (!xdr_ftype(xdrs, (enum_t *) &objp->type)) {
d38 1
a38 2
	}
	if (!xdr_u_int(xdrs, &objp->mode)) {
d40 1
a40 2
	}
	if (!xdr_u_int(xdrs, &objp->nlink)) {
d42 1
a42 2
	}
	if (!xdr_u_int(xdrs, &objp->uid)) {
d44 1
a44 2
	}
	if (!xdr_u_int(xdrs, &objp->gid)) {
d46 1
a46 2
	}
	if (!xdr_u_int(xdrs, &objp->size)) {
d48 1
a48 2
	}
	if (!xdr_u_int(xdrs, &objp->blocksize)) {
d50 1
a50 2
	}
	if (!xdr_u_int(xdrs, &objp->rdev)) {
d52 1
a52 2
	}
	if (!xdr_u_int(xdrs, &objp->blocks)) {
d54 1
a54 2
	}
	if (!xdr_u_int(xdrs, &objp->fsid)) {
d56 1
a56 2
	}
	if (!xdr_u_int(xdrs, &objp->fileid)) {
d58 1
a58 2
	}
	if (!xdr_nfstime(xdrs, &objp->atime)) {
d60 1
a60 2
	}
	if (!xdr_nfstime(xdrs, &objp->mtime)) {
d62 1
a62 2
	}
	if (!xdr_nfstime(xdrs, &objp->ctime)) {
a63 1
	}
d67 3
d72 1
a72 7

static bool_t
xdr_sattr(xdrs, objp)
	XDR *xdrs;
	sattr *objp;
{
	if (!xdr_u_int(xdrs, &objp->mode)) {
d74 1
a74 2
	}
	if (!xdr_u_int(xdrs, &objp->uid)) {
d76 1
a76 2
	}
	if (!xdr_u_int(xdrs, &objp->gid)) {
d78 1
a78 2
	}
	if (!xdr_u_int(xdrs, &objp->size)) {
d80 1
a80 2
	}
	if (!xdr_nfstime(xdrs, &objp->atime)) {
d82 1
a82 2
	}
	if (!xdr_nfstime(xdrs, &objp->mtime)) {
a83 1
	}
d87 3
d91 1
a91 8


static bool_t
xdr_filename(xdrs, objp)
	XDR *xdrs;
	filename *objp;
{
	if (!xdr_string(xdrs, objp, NFS_MAXNAMLEN)) {
a92 1
	}
a95 3



d97 1
a97 3
xdr_nfspath(xdrs, objp)
	XDR *xdrs;
	nfspath *objp;
d99 2
a100 1
	if (!xdr_string(xdrs, objp, NFS_MAXPATHLEN)) {
a101 1
	}
a104 3



d106 1
a106 3
xdr_attrstat(xdrs, objp)
	XDR *xdrs;
	attrstat *objp;
d108 2
a109 1
	if (!xdr_nfsstat(xdrs, (enum_t *) &objp->status)) {
a110 1
	}
d113 1
a113 1
		if (!xdr_fattr(xdrs, &objp->attrstat_u.attributes)) {
a114 1
		}
d120 3
d125 1
a125 7

bool_t
xdr_sattrargs(xdrs, objp)
	XDR *xdrs;
	sattrargs *objp;
{
	if (!xdr_nfs_fh(xdrs, &objp->file)) {
d127 1
a127 2
	}
	if (!xdr_sattr(xdrs, &objp->attributes)) {
a128 1
	}
d132 3
d137 1
a137 7

bool_t
xdr_diropargs(xdrs, objp)
	XDR *xdrs;
	diropargs *objp;
{
	if (!xdr_nfs_fh(xdrs, &objp->dir)) {
d139 1
a139 2
	}
	if (!xdr_filename(xdrs, &objp->name)) {
a140 1
	}
d144 3
d149 1
a149 7

bool_t
xdr_diropokres(xdrs, objp)
	XDR *xdrs;
	diropokres *objp;
{
	if (!xdr_nfs_fh(xdrs, &objp->file)) {
d151 1
a151 2
	}
	if (!xdr_fattr(xdrs, &objp->attributes)) {
a152 1
	}
a155 3



d157 1
a157 3
xdr_diropres(xdrs, objp)
	XDR *xdrs;
	diropres *objp;
d159 2
a160 1
	if (!xdr_nfsstat(xdrs, (enum_t *) &objp->status)) {
a161 1
	}
d164 1
a164 1
		if (!xdr_diropokres(xdrs, &objp->diropres_u.diropres)) {
a165 1
		}
a170 3



d172 1
a172 3
xdr_readlinkres(xdrs, objp)
	XDR *xdrs;
	readlinkres *objp;
d174 2
a175 1
	if (!xdr_nfsstat(xdrs, (enum_t *) &objp->status)) {
a176 1
	}
d179 1
a179 1
		if (!xdr_nfspath(xdrs, &objp->readlinkres_u.data)) {
a180 1
		}
d186 3
d191 1
a191 7

bool_t
xdr_readargs(xdrs, objp)
	XDR *xdrs;
	readargs *objp;
{
	if (!xdr_nfs_fh(xdrs, &objp->file)) {
d193 1
a193 2
	}
	if (!xdr_u_int(xdrs, &objp->offset)) {
d195 1
a195 2
	}
	if (!xdr_u_int(xdrs, &objp->count)) {
d197 1
a197 2
	}
	if (!xdr_u_int(xdrs, &objp->totalcount)) {
a198 1
	}
d202 3
d207 1
a207 7

bool_t
xdr_readokres(xdrs, objp)
	XDR *xdrs;
	readokres *objp;
{
	if (!xdr_fattr(xdrs, &objp->attributes)) {
a208 1
	}
d210 2
a211 1
	    (u_int *)&objp->data.data_len, NFS_MAXDATA)) {
a212 1
	}
a215 3



d217 1
a217 3
xdr_readres(xdrs, objp)
	XDR *xdrs;
	readres *objp;
d219 2
a220 1
	if (!xdr_nfsstat(xdrs, (enum_t *) &objp->status)) {
a221 1
	}
d224 1
a224 1
		if (!xdr_readokres(xdrs, &objp->readres_u.reply)) {
a225 1
		}
d231 3
d236 1
a236 7

bool_t
xdr_writeargs(xdrs, objp)
	XDR *xdrs;
	writeargs *objp;
{
	if (!xdr_nfs_fh(xdrs, &objp->file)) {
d238 1
a238 2
	}
	if (!xdr_u_int(xdrs, &objp->beginoffset)) {
d240 1
a240 2
	}
	if (!xdr_u_int(xdrs, &objp->offset)) {
d242 1
a242 2
	}
	if (!xdr_u_int(xdrs, &objp->totalcount)) {
a243 1
	}
d245 2
a246 1
	    (u_int *)&objp->data.data_len, NFS_MAXDATA)) {
a247 1
	}
d251 3
d256 1
a256 7

bool_t
xdr_createargs(xdrs, objp)
	XDR *xdrs;
	createargs *objp;
{
	if (!xdr_diropargs(xdrs, &objp->where)) {
d258 1
a258 2
	}
	if (!xdr_sattr(xdrs, &objp->attributes)) {
a259 1
	}
d263 3
d268 1
a268 7

bool_t
xdr_renameargs(xdrs, objp)
	XDR *xdrs;
	renameargs *objp;
{
	if (!xdr_diropargs(xdrs, &objp->from)) {
d270 1
a270 2
	}
	if (!xdr_diropargs(xdrs, &objp->to)) {
a271 1
	}
d275 3
d280 1
a280 7

bool_t
xdr_linkargs(xdrs, objp)
	XDR *xdrs;
	linkargs *objp;
{
	if (!xdr_nfs_fh(xdrs, &objp->from)) {
d282 1
a282 2
	}
	if (!xdr_diropargs(xdrs, &objp->to)) {
a283 1
	}
d287 3
d292 1
a292 7

bool_t
xdr_symlinkargs(xdrs, objp)
	XDR *xdrs;
	symlinkargs *objp;
{
	if (!xdr_diropargs(xdrs, &objp->from)) {
d294 1
a294 2
	}
	if (!xdr_nfspath(xdrs, &objp->to)) {
d296 1
a296 2
	}
	if (!xdr_sattr(xdrs, &objp->attributes)) {
a297 1
	}
d301 3
d305 1
a305 8


static bool_t
xdr_nfscookie(xdrs, objp)
	XDR *xdrs;
	nfscookie objp;
{
	if (!xdr_opaque(xdrs, objp, NFS_COOKIESIZE)) {
a306 1
	}
d310 3
d315 1
a315 7

bool_t
xdr_readdirargs(xdrs, objp)
	XDR *xdrs;
	readdirargs *objp;
{
	if (!xdr_nfs_fh(xdrs, &objp->dir)) {
d317 1
a317 2
	}
	if (!xdr_nfscookie(xdrs, objp->cookie)) {
d319 1
a319 2
	}
	if (!xdr_u_int(xdrs, &objp->count)) {
a320 1
	}
d324 3
d329 1
a329 7

static bool_t
xdr_entry(xdrs, objp)
	XDR *xdrs;
	entry *objp;
{
	if (!xdr_u_int(xdrs, &objp->fileid)) {
d331 1
a331 2
	}
	if (!xdr_filename(xdrs, &objp->name)) {
d333 1
a333 2
	}
	if (!xdr_nfscookie(xdrs, objp->cookie)) {
d335 1
a335 3
	}
	if (!xdr_pointer(xdrs, (char **)&objp->nextentry,
	    sizeof(entry), xdr_entry)) {
a336 1
	}
d340 3
d345 1
a345 8

static bool_t
xdr_dirlist(xdrs, objp)
	XDR *xdrs;
	dirlist *objp;
{
	if (!xdr_pointer(xdrs, (char **)&objp->entries,
	    sizeof(entry), xdr_entry)) {
d347 1
a347 2
	}
	if (!xdr_bool(xdrs, &objp->eof)) {
a348 1
	}
a351 3



d353 1
a353 3
xdr_readdirres(xdrs, objp)
	XDR *xdrs;
	readdirres *objp;
d355 2
a356 1
	if (!xdr_nfsstat(xdrs, (enum_t *) &objp->status)) {
a357 1
	}
d360 1
a360 1
		if (!xdr_dirlist(xdrs, &objp->readdirres_u.reply)) {
a361 1
		}
d367 3
d372 1
a372 7

bool_t
xdr_statfsokres(xdrs, objp)
	XDR *xdrs;
	statfsokres *objp;
{
	if (!xdr_u_int(xdrs, &objp->tsize)) {
d374 1
a374 2
	}
	if (!xdr_u_int(xdrs, &objp->bsize)) {
d376 1
a376 2
	}
	if (!xdr_u_int(xdrs, &objp->blocks)) {
d378 1
a378 2
	}
	if (!xdr_u_int(xdrs, &objp->bfree)) {
d380 1
a380 2
	}
	if (!xdr_u_int(xdrs, &objp->bavail)) {
a381 1
	}
a384 3



d386 1
a386 3
xdr_statfsres(xdrs, objp)
	XDR *xdrs;
	statfsres *objp;
d388 2
a389 1
	if (!xdr_nfsstat(xdrs, (enum_t *) &objp->status)) {
a390 1
	}
d393 1
a393 1
		if (!xdr_statfsokres(xdrs, &objp->statfsres_u.reply)) {
a394 1
		}
@


1.2
log
@knf
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: nfs_prot_xdr.c,v 1.1.1.1 1995/10/18 08:47:23 deraadt Exp $
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: nfs_prot_xdr.c,v 1.3 1994/12/08 21:41:26 christos Exp $
d362 2
a363 1
	if (!xdr_bytes(xdrs, (char **)&objp->data.data_val, (u_int *)&objp->data.data_len, NFS_MAXDATA)) {
d410 2
a411 1
	if (!xdr_bytes(xdrs, (char **)&objp->data.data_val, (u_int *)&objp->data.data_len, NFS_MAXDATA)) {
d539 2
a540 1
	if (!xdr_pointer(xdrs, (char **)&objp->nextentry, sizeof(entry), xdr_entry)) {
d554 2
a555 1
	if (!xdr_pointer(xdrs, (char **)&objp->entries, sizeof(entry), xdr_entry)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
