head	1.79;
access;
symbols
	OPENBSD_6_1:1.79.0.2
	OPENBSD_6_1_BASE:1.79
	OPENBSD_6_0:1.71.0.2
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.69.0.2
	OPENBSD_5_9_BASE:1.69
	OPENBSD_5_8:1.61.0.4
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.53.0.6
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.45.0.16
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.14
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.12
	OPENBSD_5_0:1.45.0.10
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.8
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.6
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.4
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.42.0.4
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.36.0.4
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.35.0.4
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	kame_19991210:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.79
date	2016.11.29.08.55.06;	author mpi;	state Exp;
branches;
next	1.78;
commitid	awzig7PvB0qy9Fec;

1.78
date	2016.08.15.08.52.03;	author mpi;	state Exp;
branches;
next	1.77;
commitid	8i3DyGsufTuTSqaS;

1.77
date	2016.08.05.11.53.23;	author jca;	state Exp;
branches;
next	1.76;
commitid	kRFKdgDz3sWQRdBN;

1.76
date	2016.08.05.11.44.10;	author jca;	state Exp;
branches;
next	1.75;
commitid	KbfxYKonoL4wetaf;

1.75
date	2016.08.02.16.17.54;	author jca;	state Exp;
branches;
next	1.74;
commitid	QZrGVx5D7PRnUSOJ;

1.74
date	2016.07.31.19.23.24;	author jca;	state Exp;
branches;
next	1.73;
commitid	kWl18wEg0evuK2Nn;

1.73
date	2016.07.31.19.17.41;	author jca;	state Exp;
branches;
next	1.72;
commitid	BV3ZdVi6pflQQgVJ;

1.72
date	2016.07.31.19.12.26;	author jca;	state Exp;
branches;
next	1.71;
commitid	0dh33zMFYsdGeLWf;

1.71
date	2016.04.05.18.09.30;	author jca;	state Exp;
branches;
next	1.70;
commitid	0e1xbALUpjnzgivi;

1.70
date	2016.04.04.11.37.09;	author jca;	state Exp;
branches;
next	1.69;
commitid	kugbqZUhw011VKFt;

1.69
date	2016.01.26.18.26.19;	author mmcc;	state Exp;
branches;
next	1.68;
commitid	W1L20xeSwlpa0n3G;

1.68
date	2016.01.12.09.47.13;	author mpi;	state Exp;
branches;
next	1.67;
commitid	bOWUiieTKPaNFj9r;

1.67
date	2015.10.28.12.14.25;	author florian;	state Exp;
branches;
next	1.66;
commitid	Ajb0hNGeCqGFHjjg;

1.66
date	2015.10.25.11.44.30;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	2V57UUXkCcAIaK6t;

1.65
date	2015.10.25.08.07.31;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	EEPtLI45uWGuccH1;

1.64
date	2015.10.24.20.41.40;	author matthieu;	state Exp;
branches;
next	1.63;
commitid	aoYdojdVno5mMvLs;

1.63
date	2015.10.23.15.47.54;	author benno;	state Exp;
branches;
next	1.62;
commitid	TG9ceZBh8xr4Y7yC;

1.62
date	2015.08.23.14.12.05;	author naddy;	state Exp;
branches;
next	1.61;
commitid	7ZJGrCYKkPxvwAk3;

1.61
date	2015.06.03.08.10.53;	author mpi;	state Exp;
branches;
next	1.60;
commitid	E9xoXPx8h6lAYIn5;

1.60
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	6b2lLILbgCR1fvia;

1.59
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	Uu5nFG3wCl0LACBb;

1.58
date	2014.09.07.22.40.30;	author bluhm;	state Exp;
branches;
next	1.57;
commitid	NdR4d7j03xj7THfp;

1.57
date	2014.09.03.10.39.41;	author mpi;	state Exp;
branches;
next	1.56;
commitid	tx59KIWMEk8nbHq7;

1.56
date	2014.08.22.22.37.32;	author sthen;	state Exp;
branches;
next	1.55;
commitid	150I9830y29F4HQu;

1.55
date	2014.08.19.12.39.36;	author mpi;	state Exp;
branches;
next	1.54;
commitid	fCh9nGSviO7kTgAQ;

1.54
date	2014.08.11.09.47.56;	author mpi;	state Exp;
branches;
next	1.53;
commitid	UIxLUweL387FY4Lo;

1.53
date	2013.10.21.12.41.52;	author jmc;	state Exp;
branches;
next	1.52;

1.52
date	2013.10.21.08.46.07;	author phessler;	state Exp;
branches;
next	1.51;

1.51
date	2013.10.07.12.46.57;	author jca;	state Exp;
branches;
next	1.50;

1.50
date	2013.08.15.13.43.33;	author bluhm;	state Exp;
branches;
next	1.49;

1.49
date	2013.08.09.17.52.12;	author bluhm;	state Exp;
branches;
next	1.48;

1.48
date	2013.07.19.09.12.51;	author bluhm;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.21.04.43.17;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.11.14.02.37;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2009.06.25.15.44.43;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.17.15.31.23;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.05.22.40.24;	author chris;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.09.15.49.31;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.40;

1.40
date	2008.05.05.13.53.48;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.22.15.06.57;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.18.23.50.47;	author ray;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.10.22.08.33;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.04.09.03.08;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.24.03.56.22;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.16.01.11.09;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.10.14.47.22;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.08.06.51.44;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.02.03.26.07;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.26.15.51.43;	author avsm;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.26.21.33.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.26.21.32.01;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.11.23.33.29;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.17.13.49.03;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.03.19.30.49;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.03.04.44.50;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.03.04.32.14;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.03.03.33.53;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.02.15.23.30;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.02.01.31.14;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.29.22.22.20;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.29.18.40.21;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.29.08.05.39;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.26.01.21.12;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.17.19.42.38;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.28.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.08.09.52.02;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.23.18.42.32;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.21.15.32.27;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.08.08.35.17;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.21.07.51.38;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.09.22.10.05;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.20.21.53.43;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.17.04.44.51;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.28.11.56.41;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.01.03.24.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.07.26.56;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.10.07.17.08;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.10.07.17.08;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.79
log
@Tweak output to keep it aligned when interfaces with big names, like
vether0 are used.

ok jca@@, deraadt@@
@
text
@/*	$OpenBSD: ndp.c,v 1.78 2016/08/15 08:52:03 mpi Exp $	*/
/*	$KAME: ndp.c,v 1.101 2002/07/17 08:46:33 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Copyright (c) 1984, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Sun Microsystems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Based on:
 * "@@(#) Copyright (c) 1984, 1993\n\
 *	The Regents of the University of California.  All rights reserved.\n";
 *
 * "@@(#)arp.c	8.2 (Berkeley) 1/2/94";
 */

/*
 * ndp - display, set, delete and flush neighbor cache
 */


#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>

#include <netinet/icmp6.h>
#include <netinet6/in6_var.h>
#include <netinet6/nd6.h>

#include <arpa/inet.h>

#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <err.h>

#include "gmt2local.h"

/* packing rule for routing socket */
#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

static pid_t pid;
static int nflag;
static int tflag;
static int32_t thiszone;	/* time difference with gmt */
static int rtsock = -1;
static int repeat = 0;

char ntop_buf[INET6_ADDRSTRLEN];	/* inet_ntop() */
char host_buf[NI_MAXHOST];		/* getnameinfo() */
char ifix_buf[IFNAMSIZ];		/* if_indextoname() */

int file(char *);
void getsocket(void);
int set(int, char **);
void get(char *);
int delete(char *);
void dump(struct in6_addr *, int);
static struct in6_nbrinfo *getnbrinfo(struct in6_addr *, int, int);
static char *ether_str(struct sockaddr_dl *);
int ndp_ether_aton(char *, u_char *);
void usage(void);
int rtmsg(int);
int rtget(struct sockaddr_in6 **, struct sockaddr_dl **);
void ifinfo(char *, int, char **);
void rtrlist(void);
void plist(void);
void pfx_flush(void);
void rtr_flush(void);
void harmonize_rtr(void);
static char *sec2str(time_t);
static void ts_print(const struct timeval *);
static int rdomain = 0;

static char *rtpref_str[] = {
	"medium",		/* 00 */
	"high",			/* 01 */
	"rsv",			/* 10 */
	"low"			/* 11 */
};

int
main(int argc, char *argv[])
{
	int		 ch;
	int		 mode = 0;
	char		*arg = NULL;
	const char	*errstr;

	pid = getpid();
	thiszone = gmt2local(0);
	while ((ch = getopt(argc, argv, "acd:f:i:nprstA:HPRV:")) != -1)
		switch (ch) {
		case 'a':
		case 'c':
		case 'p':
		case 'r':
		case 'H':
		case 'P':
		case 'R':
		case 's':
			if (mode) {
				usage();
				/*NOTREACHED*/
			}
			mode = ch;
			arg = NULL;
			break;
		case 'd':
		case 'f':
		case 'i' :
			if (mode) {
				usage();
				/*NOTREACHED*/
			}
			mode = ch;
			arg = optarg;
			break;
		case 'n':
			nflag = 1;
			break;
		case 't':
			tflag = 1;
			break;
		case 'A':
			if (mode) {
				usage();
				/*NOTREACHED*/
			}
			mode = 'a';
			repeat = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr) {
				usage();
				/*NOTREACHED*/
			}
			break;
		case 'V':
			rdomain = strtonum(optarg, 0, RT_TABLEID_MAX, &errstr);
			if (errstr != NULL) {
				warn("bad rdomain: %s", errstr);
				usage();
				/*NOTREACHED*/
			}
			break;
		default:
			usage();
		}

	argc -= optind;
	argv += optind;

	switch (mode) {
	case 'a':
	case 'c':
		if (argc != 0) {
			usage();
			/*NOTREACHED*/
		}
		dump(0, mode == 'c');
		break;
	case 'd':
		if (argc != 0) {
			usage();
			/*NOTREACHED*/
		}
		delete(arg);
		break;
	case 'f':
		if (argc != 0)
			usage();
		file(arg);
		break;
	case 'p':
		if (argc != 0) {
			usage();
			/*NOTREACHED*/
		}
		plist();
		break;
	case 'i':
		ifinfo(arg, argc, argv);
		break;
	case 'r':
		if (argc != 0) {
			usage();
			/*NOTREACHED*/
		}
		rtrlist();
		break;
	case 's':
		if (argc < 2 || argc > 4)
			usage();
		exit(set(argc, argv) ? 1 : 0);
	case 'H':
		if (argc != 0) {
			usage();
			/*NOTREACHED*/
		}
		harmonize_rtr();
		break;
	case 'P':
		if (argc != 0) {
			usage();
			/*NOTREACHED*/
		}
		pfx_flush();
		break;
	case 'R':
		if (argc != 0) {
			usage();
			/*NOTREACHED*/
		}
		rtr_flush();
		break;
	case 0:
		if (argc != 1) {
			usage();
			/*NOTREACHED*/
		}
		get(argv[0]);
		break;
	}
	exit(0);
}

/*
 * Process a file to set standard ndp entries
 */
int
file(char *name)
{
	FILE *fp;
	int i, retval;
	char line[100], arg[5][50], *args[5];

	if ((fp = fopen(name, "r")) == NULL) {
		fprintf(stderr, "ndp: cannot open %s\n", name);
		exit(1);
	}
	args[0] = &arg[0][0];
	args[1] = &arg[1][0];
	args[2] = &arg[2][0];
	args[3] = &arg[3][0];
	args[4] = &arg[4][0];
	retval = 0;
	while (fgets(line, sizeof(line), fp) != NULL) {
		i = sscanf(line, "%49s %49s %49s %49s %49s",
		    arg[0], arg[1], arg[2], arg[3], arg[4]);
		if (i < 2) {
			fprintf(stderr, "ndp: bad line: %s\n", line);
			retval = 1;
			continue;
		}
		if (set(i, args))
			retval = 1;
	}
	fclose(fp);
	return (retval);
}

void
getsocket(void)
{
	if (rtsock < 0) {
		rtsock = socket(PF_ROUTE, SOCK_RAW, 0);
		if (rtsock < 0) {
			err(1, "socket");
			/* NOTREACHED */
		}
	}
}

struct	sockaddr_in6 so_mask = {sizeof(so_mask), AF_INET6 };
struct	sockaddr_in6 blank_sin = {sizeof(blank_sin), AF_INET6 }, sin_m;
struct	sockaddr_dl blank_sdl = {sizeof(blank_sdl), AF_LINK }, sdl_m;
struct	sockaddr_dl ifp_m = { sizeof(&ifp_m), AF_LINK };
time_t	expire_time;
int	flags, found_entry;
struct	{
	struct	rt_msghdr m_rtm;
	char	m_space[512];
}	m_rtmsg;

/*
 * Set an individual neighbor cache entry
 */
int
set(int argc, char **argv)
{
	struct sockaddr_in6 *sin = &sin_m;
	struct sockaddr_dl *sdl;
	struct rt_msghdr *rtm = &(m_rtmsg.m_rtm);
	struct addrinfo hints, *res;
	int gai_error;
	u_char *ea;
	char *host = argv[0], *eaddr = argv[1];

	getsocket();
	argc -= 2;
	argv += 2;
	sdl_m = blank_sdl;
	sin_m = blank_sin;

	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_INET6;
	gai_error = getaddrinfo(host, NULL, &hints, &res);
	if (gai_error) {
		fprintf(stderr, "ndp: %s: %s\n", host,
			gai_strerror(gai_error));
		return 1;
	}
	sin->sin6_addr = ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;
#ifdef __KAME__
	if (IN6_IS_ADDR_LINKLOCAL(&sin->sin6_addr)) {
		*(u_int16_t *)&sin->sin6_addr.s6_addr[2] =
		    htons(((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id);
	}
#endif
	ea = (u_char *)LLADDR(&sdl_m);
	if (ndp_ether_aton(eaddr, ea) == 0)
		sdl_m.sdl_alen = 6;
	expire_time = 0;
	flags = 0;
	while (argc-- > 0) {
		if (strncmp(argv[0], "temp", 4) == 0) {
			struct timeval now;

			gettimeofday(&now, 0);
			expire_time = now.tv_sec + 20 * 60;
		} else if (strncmp(argv[0], "proxy", 5) == 0)
			flags |= RTF_ANNOUNCE;
		argv++;
	}

	if (rtget(&sin, &sdl)) {
		errx(1, "RTM_GET(%s) failed", host);
		/* NOTREACHED */
	}

	if (IN6_ARE_ADDR_EQUAL(&sin->sin6_addr, &sin_m.sin6_addr)) {
		if (sdl->sdl_family == AF_LINK &&
		    (rtm->rtm_flags & RTF_LLINFO) &&
		    !(rtm->rtm_flags & RTF_GATEWAY)) {
			switch (sdl->sdl_type) {
			case IFT_ETHER: case IFT_FDDI: case IFT_ISO88023:
			case IFT_ISO88024: case IFT_ISO88025:
				goto overwrite;
			}
		}
		/*
		 * IPv4 arp command retries with sin_other = SIN_PROXY here.
		 */
		fprintf(stderr, "set: cannot configure a new entry\n");
		return 1;
	}

overwrite:
	if (sdl->sdl_family != AF_LINK) {
		printf("cannot intuit interface index and type for %s\n", host);
		return (1);
	}
	sdl_m.sdl_type = sdl->sdl_type;
	sdl_m.sdl_index = sdl->sdl_index;
	return (rtmsg(RTM_ADD));
}

/*
 * Display an individual neighbor cache entry
 */
void
get(char *host)
{
	struct sockaddr_in6 *sin = &sin_m;
	struct addrinfo hints, *res;
	int gai_error;

	sin_m = blank_sin;
	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_INET6;
	gai_error = getaddrinfo(host, NULL, &hints, &res);
	if (gai_error) {
		fprintf(stderr, "ndp: %s: %s\n", host,
		    gai_strerror(gai_error));
		return;
	}
	sin->sin6_addr = ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;
#ifdef __KAME__
	if (IN6_IS_ADDR_LINKLOCAL(&sin->sin6_addr)) {
		*(u_int16_t *)&sin->sin6_addr.s6_addr[2] =
		    htons(((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id);
	}
#endif
	dump(&sin->sin6_addr, 0);
	if (found_entry == 0) {
		getnameinfo((struct sockaddr *)sin, sin->sin6_len, host_buf,
		    sizeof(host_buf), NULL ,0,
		    (nflag ? NI_NUMERICHOST : 0));
		printf("%s (%s) -- no entry\n", host, host_buf);
		exit(1);
	}
}

/*
 * Delete a neighbor cache entry
 */
int
delete(char *host)
{
	struct sockaddr_in6 *sin = &sin_m;
	struct rt_msghdr *rtm = &m_rtmsg.m_rtm;
	struct sockaddr_dl *sdl;
	struct addrinfo hints, *res;
	int gai_error;

	getsocket();
	sin_m = blank_sin;

	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_INET6;
	if (nflag)
		hints.ai_flags = AI_NUMERICHOST;
	gai_error = getaddrinfo(host, NULL, &hints, &res);
	if (gai_error) {
		fprintf(stderr, "ndp: %s: %s\n", host,
		    gai_strerror(gai_error));
		return 1;
	}
	sin->sin6_addr = ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;
#ifdef __KAME__
	if (IN6_IS_ADDR_LINKLOCAL(&sin->sin6_addr)) {
		*(u_int16_t *)&sin->sin6_addr.s6_addr[2] =
		    htons(((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id);
	}
#endif

	if (rtget(&sin, &sdl)) {
		errx(1, "RTM_GET(%s) failed", host);
		/* NOTREACHED */
	}

	if (IN6_ARE_ADDR_EQUAL(&sin->sin6_addr, &sin_m.sin6_addr)) {
		if (sdl->sdl_family == AF_LINK && rtm->rtm_flags & RTF_LLINFO) {
			if (rtm->rtm_flags & RTF_LOCAL)
				return (0);
			if (!(rtm->rtm_flags & RTF_GATEWAY))
				goto delete;
		}
		/*
		 * IPv4 arp command retries with sin_other = SIN_PROXY here.
		 */
		fprintf(stderr, "delete: cannot delete non-NDP entry\n");
		return 1;
	}

delete:
	if (sdl->sdl_family != AF_LINK) {
		printf("cannot locate %s\n", host);
		return (1);
	}
	if (rtmsg(RTM_DELETE) == 0) {
		struct sockaddr_in6 s6 = *sin; /* XXX: for safety */

#ifdef __KAME__
		if (IN6_IS_ADDR_LINKLOCAL(&s6.sin6_addr)) {
			s6.sin6_scope_id = ntohs(*(u_int16_t *)&s6.sin6_addr.s6_addr[2]);
			*(u_int16_t *)&s6.sin6_addr.s6_addr[2] = 0;
		}
#endif
		getnameinfo((struct sockaddr *)&s6,
		    s6.sin6_len, host_buf,
		    sizeof(host_buf), NULL, 0,
		    (nflag ? NI_NUMERICHOST : 0));
		printf("%s (%s) deleted\n", host, host_buf);
	}

	return 0;
}

#define W_ADDR	36
#define W_LL	17
#define W_IF	7

/*
 * Dump the entire neighbor cache
 */
void
dump(struct in6_addr *addr, int cflag)
{
	int mib[7];
	size_t needed;
	char *lim, *buf = NULL, *next;
	struct rt_msghdr *rtm;
	struct sockaddr_in6 *sin;
	struct sockaddr_dl *sdl;
	struct in6_nbrinfo *nbi;
	struct timeval now;
	int addrwidth;
	int llwidth;
	int ifwidth;
	char *ifname;

	/* Print header */
	if (!tflag && !cflag)
		printf("%-*.*s %-*.*s %*.*s %-9.9s %1s %5s\n",
		    W_ADDR, W_ADDR, "Neighbor", W_LL, W_LL, "Linklayer Address",
		    W_IF, W_IF, "Netif", "Expire", "S", "Flags");

again:;
	lim = NULL;
	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET6;
	mib[4] = NET_RT_FLAGS;
	mib[5] = RTF_LLINFO;
	mib[6] = rdomain;
	while (1) {
		if (sysctl(mib, 7, NULL, &needed, NULL, 0) == -1)
			err(1, "sysctl(PF_ROUTE estimate)");
		if (needed == 0)
			break;
		if ((buf = realloc(buf, needed)) == NULL)
			err(1, "realloc");
		if (sysctl(mib, 7, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			err(1, "sysctl(PF_ROUTE, NET_RT_FLAGS)");
		}
		lim = buf + needed;
		break;
	}

	for (next = buf; next && lim && next < lim; next += rtm->rtm_msglen) {
		int isrouter = 0, prbs = 0;

		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		sin = (struct sockaddr_in6 *)(next + rtm->rtm_hdrlen);
		sdl = (struct sockaddr_dl *)((char *)sin + ROUNDUP(sin->sin6_len));

		/*
		 * Some OSes can produce a route that has the LINK flag but
		 * has a non-AF_LINK gateway (e.g. fe80::xx%lo0 on FreeBSD
		 * and BSD/OS, where xx is not the interface identifier on
		 * lo0).  Such routes entry would annoy getnbrinfo() below,
		 * so we skip them.
		 * XXX: such routes should have the GATEWAY flag, not the
		 * LINK flag.  However, there is rotten routing software
		 * that advertises all routes that have the GATEWAY flag.
		 * Thus, KAME kernel intentionally does not set the LINK flag.
		 * What is to be fixed is not ndp, but such routing software
		 * (and the kernel workaround)...
		 */
		if (sdl->sdl_family != AF_LINK)
			continue;

		if (!(rtm->rtm_flags & RTF_HOST))
			continue;

		if (addr) {
			if (!IN6_ARE_ADDR_EQUAL(addr, &sin->sin6_addr))
				continue;
			found_entry = 1;
		} else if (IN6_IS_ADDR_MULTICAST(&sin->sin6_addr))
			continue;
		if (IN6_IS_ADDR_LINKLOCAL(&sin->sin6_addr) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&sin->sin6_addr)) {
			/* XXX: should scope id be filled in the kernel? */
			if (sin->sin6_scope_id == 0)
				sin->sin6_scope_id = sdl->sdl_index;
#ifdef __KAME__
			/* KAME specific hack; removed the embedded id */
			*(u_int16_t *)&sin->sin6_addr.s6_addr[2] = 0;
#endif
		}
		getnameinfo((struct sockaddr *)sin, sin->sin6_len, host_buf,
		    sizeof(host_buf), NULL, 0, (nflag ? NI_NUMERICHOST : 0));
		if (cflag) {
			if (rtm->rtm_flags & RTF_CLONED)
				delete(host_buf);
			continue;
		}
		gettimeofday(&now, 0);
		if (tflag)
			ts_print(&now);

		addrwidth = strlen(host_buf);
		if (addrwidth < W_ADDR)
			addrwidth = W_ADDR;
		llwidth = strlen(ether_str(sdl));
		if (W_ADDR + W_LL - addrwidth > llwidth)
			llwidth = W_ADDR + W_LL - addrwidth;
		ifname = if_indextoname(sdl->sdl_index, ifix_buf);
		if (!ifname)
			ifname = "?";
		ifwidth = strlen(ifname);
		if (W_ADDR + W_LL + W_IF - addrwidth - llwidth > ifwidth)
			ifwidth = W_ADDR + W_LL + W_IF - addrwidth - llwidth;

		printf("%-*.*s %-*.*s %*.*s", addrwidth, addrwidth, host_buf,
		    llwidth, llwidth, ether_str(sdl), ifwidth, ifwidth, ifname);

		/* Print neighbor discovery specific informations */
		nbi = getnbrinfo(&sin->sin6_addr, sdl->sdl_index, 1);
		if (nbi) {
			if (nbi->expire > now.tv_sec) {
				printf(" %-9.9s",
				    sec2str(nbi->expire - now.tv_sec));
			} else if (nbi->expire == 0)
				printf(" %-9.9s", "permanent");
			else
				printf(" %-9.9s", "expired");

			switch (nbi->state) {
			case ND6_LLINFO_NOSTATE:
				 printf(" N");
				 break;
			case ND6_LLINFO_INCOMPLETE:
				 printf(" I");
				 break;
			case ND6_LLINFO_REACHABLE:
				 printf(" R");
				 break;
			case ND6_LLINFO_STALE:
				 printf(" S");
				 break;
			case ND6_LLINFO_DELAY:
				 printf(" D");
				 break;
			case ND6_LLINFO_PROBE:
				 printf(" P");
				 break;
			default:
				 printf(" ?");
				 break;
			}

			isrouter = nbi->isrouter;
			prbs = nbi->asked;
		} else {
			warnx("failed to get neighbor information");
			printf("  ");
		}

		printf(" %s%s%s",
		    (rtm->rtm_flags & RTF_LOCAL) ? "l" : "",
		    isrouter ? "R" : "",
		    (rtm->rtm_flags & RTF_ANNOUNCE) ? "p" : "");

		if (prbs)
			printf(" %d", prbs);

		printf("\n");
	}

	if (repeat) {
		printf("\n");
		fflush(stdout);
		sleep(repeat);
		goto again;
	}

	free(buf);
}

static struct in6_nbrinfo *
getnbrinfo(struct in6_addr *addr, int ifindex, int warning)
{
	static struct in6_nbrinfo nbi;
	int s;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");

	bzero(&nbi, sizeof(nbi));
	if_indextoname(ifindex, nbi.ifname);
	nbi.addr = *addr;
	if (ioctl(s, SIOCGNBRINFO_IN6, (caddr_t)&nbi) < 0) {
		if (warning)
			warn("ioctl(SIOCGNBRINFO_IN6)");
		close(s);
		return(NULL);
	}

	close(s);
	return(&nbi);
}

static char *
ether_str(struct sockaddr_dl *sdl)
{
	static char hbuf[NI_MAXHOST];
	u_char *cp;

	if (sdl->sdl_alen) {
		cp = (u_char *)LLADDR(sdl);
		snprintf(hbuf, sizeof(hbuf), "%02x:%02x:%02x:%02x:%02x:%02x",
		    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
	} else
		snprintf(hbuf, sizeof(hbuf), "(incomplete)");

	return(hbuf);
}

int
ndp_ether_aton(char *a, u_char *n)
{
	int i, o[6];

	i = sscanf(a, "%x:%x:%x:%x:%x:%x", &o[0], &o[1], &o[2],
	    &o[3], &o[4], &o[5]);
	if (i != 6) {
		fprintf(stderr, "ndp: invalid Ethernet address '%s'\n", a);
		return (1);
	}
	for (i = 0; i < 6; i++)
		n[i] = o[i];
	return (0);
}

void
usage(void)
{
	printf("usage: ndp [-nrt] [-a | -c | -p] [-H | -P | -R] ");
	printf("[-A wait] [-d hostname]\n");
	printf("\t[-f filename] [-i interface [flag ...]]\n");
	printf("\t[-s nodename ether_addr [temp] [proxy]] ");
	printf("[-V rdomain] [hostname]\n");
	exit(1);
}

int
rtmsg(int cmd)
{
	static int seq;
	int rlen;
	struct rt_msghdr *rtm = &m_rtmsg.m_rtm;
	char *cp = m_rtmsg.m_space;
	int l;

	errno = 0;
	if (cmd == RTM_DELETE)
		goto doit;
	bzero((char *)&m_rtmsg, sizeof(m_rtmsg));
	rtm->rtm_flags = flags;
	rtm->rtm_version = RTM_VERSION;
	rtm->rtm_tableid = rdomain;

	switch (cmd) {
	default:
		fprintf(stderr, "ndp: internal wrong cmd\n");
		exit(1);
	case RTM_ADD:
		rtm->rtm_addrs |= RTA_GATEWAY;
		if (expire_time) {
			rtm->rtm_rmx.rmx_expire = expire_time;
			rtm->rtm_inits = RTV_EXPIRE;
		}
		rtm->rtm_flags |= (RTF_HOST | RTF_STATIC);
#if 0	/* we don't support ipv6addr/128 type proxying. */
		if (rtm->rtm_flags & RTF_ANNOUNCE) {
			rtm->rtm_flags &= ~RTF_HOST;
			rtm->rtm_addrs |= RTA_NETMASK;
		}
#endif
		/* FALLTHROUGH */
	case RTM_GET:
		rtm->rtm_addrs |= (RTA_DST | RTA_IFP);
	}
#define NEXTADDR(w, s) \
	if (rtm->rtm_addrs & (w)) { \
		bcopy((char *)&s, cp, sizeof(s)); cp += ROUNDUP(sizeof(s));}

	NEXTADDR(RTA_DST, sin_m);
	NEXTADDR(RTA_GATEWAY, sdl_m);
#if 0	/* we don't support ipv6addr/128 type proxying. */
	memset(&so_mask.sin6_addr, 0xff, sizeof(so_mask.sin6_addr));
	NEXTADDR(RTA_NETMASK, so_mask);
#endif
	NEXTADDR(RTA_IFP, ifp_m);

	rtm->rtm_msglen = cp - (char *)&m_rtmsg;
doit:
	l = rtm->rtm_msglen;
	rtm->rtm_seq = ++seq;
	rtm->rtm_type = cmd;
	if ((rlen = write(rtsock, (char *)&m_rtmsg, l)) < 0) {
		if (errno != ESRCH || cmd != RTM_DELETE) {
			err(1, "writing to routing socket");
			/* NOTREACHED */
		}
	}
	do {
		l = read(rtsock, (char *)&m_rtmsg, sizeof(m_rtmsg));
	} while (l > 0 && (rtm->rtm_version != RTM_VERSION ||
	    rtm->rtm_seq != seq || rtm->rtm_pid != pid));
	if (l < 0)
		(void) fprintf(stderr, "ndp: read from routing socket: %s\n",
		    strerror(errno));
	return (0);
}

int
rtget(struct sockaddr_in6 **sinp, struct sockaddr_dl **sdlp)
{
	struct rt_msghdr *rtm = &(m_rtmsg.m_rtm);
	struct sockaddr_in6 *sin = NULL;
	struct sockaddr_dl *sdl = NULL;
	struct sockaddr *sa;
	char *cp;
	unsigned int i;

	if (rtmsg(RTM_GET) < 0)
		return (1);

	if (rtm->rtm_addrs) {
		cp = ((char *)rtm + rtm->rtm_hdrlen);
		for (i = 1; i; i <<= 1) {
			if (i & rtm->rtm_addrs) {
				sa = (struct sockaddr *)cp;
				switch (i) {
				case RTA_DST:
					sin = (struct sockaddr_in6 *)sa;
					break;
				case RTA_IFP:
					sdl = (struct sockaddr_dl *)sa;
					break;
				default:
					break;
				}
				cp += ROUNDUP(sa->sa_len);
			}
		}
	}

	if (sin == NULL || sdl == NULL)
		return (1);

	*sinp = sin;
	*sdlp = sdl;

	return (0);
}

void
ifinfo(char *ifname, int argc, char **argv)
{
	struct in6_ndireq nd;
	int i, s;
	u_int32_t newflags;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		err(1, "socket");
		/* NOTREACHED */
	}
	bzero(&nd, sizeof(nd));
	strlcpy(nd.ifname, ifname, sizeof(nd.ifname));
	if (ioctl(s, SIOCGIFINFO_IN6, (caddr_t)&nd) < 0) {
		err(1, "ioctl(SIOCGIFINFO_IN6)");
		/* NOTREACHED */
	}
	newflags = nd.ndi.flags;
	for (i = 0; i < argc; i++) {
		int clear = 0;
		char *cp = argv[i];

		if (*cp == '-') {
			clear = 1;
			cp++;
		}

#define SETFLAG(s, f) \
	do {\
		if (strcmp(cp, (s)) == 0) {\
			if (clear)\
				newflags &= ~(f);\
			else\
				newflags |= (f);\
		}\
	} while (0)
		SETFLAG("nud", ND6_IFF_PERFORMNUD);
		SETFLAG("accept_rtadv", ND6_IFF_ACCEPT_RTADV);

		nd.ndi.flags = newflags;
		if (ioctl(s, SIOCSIFINFO_FLAGS, (caddr_t)&nd) < 0) {
			err(1, "ioctl(SIOCSIFINFO_FLAGS)");
			/* NOTREACHED */
		}
#undef SETFLAG
	}

	if (!nd.ndi.initialized) {
		errx(1, "%s: not initialized yet", ifname);
		/* NOTREACHED */
	}

	printf("basereachable=%ds%dms",
	    nd.ndi.basereachable / 1000, nd.ndi.basereachable % 1000);
	printf(", reachable=%ds", nd.ndi.reachable);
	printf(", retrans=%ds%dms", nd.ndi.retrans / 1000,
	    nd.ndi.retrans % 1000);
	if (nd.ndi.flags) {
		printf("\nFlags: ");
		if ((nd.ndi.flags & ND6_IFF_PERFORMNUD))
			printf("nud ");
		if ((nd.ndi.flags & ND6_IFF_ACCEPT_RTADV))
			printf("accept_rtadv ");
	}
	putc('\n', stdout);

	close(s);
}

#ifndef ND_RA_FLAG_RTPREF_MASK	/* XXX: just for compilation on *BSD release */
#define ND_RA_FLAG_RTPREF_MASK	0x18 /* 00011000 */
#endif

void
rtrlist(void)
{
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_ICMPV6, ICMPV6CTL_ND6_DRLIST };
	char *buf;
	struct in6_defrouter *p, *ep;
	size_t l;
	struct timeval now;

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), NULL, &l, NULL, 0) < 0) {
		err(1, "sysctl(ICMPV6CTL_ND6_DRLIST)");
		/*NOTREACHED*/
	}
	if (l == 0)
		return;
	buf = malloc(l);
	if (buf == NULL) {
		err(1, "malloc");
		/*NOTREACHED*/
	}
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), buf, &l, NULL, 0) < 0) {
		err(1, "sysctl(ICMPV6CTL_ND6_DRLIST)");
		/*NOTREACHED*/
	}

	ep = (struct in6_defrouter *)(buf + l);
	for (p = (struct in6_defrouter *)buf; p < ep; p++) {
		int rtpref;

		if (getnameinfo((struct sockaddr *)&p->rtaddr,
		    p->rtaddr.sin6_len, host_buf, sizeof(host_buf), NULL, 0,
		    (nflag ? NI_NUMERICHOST : 0)) != 0)
			strlcpy(host_buf, "?", sizeof(host_buf));

		printf("%s if=%s", host_buf,
		    if_indextoname(p->if_index, ifix_buf));
		printf(", flags=%s%s",
		    p->flags & ND_RA_FLAG_MANAGED ? "M" : "",
		    p->flags & ND_RA_FLAG_OTHER   ? "O" : "");
		rtpref = ((p->flags & ND_RA_FLAG_RTPREF_MASK) >> 3) & 0xff;
		printf(", pref=%s", rtpref_str[rtpref]);

		gettimeofday(&now, 0);
		if (p->expire == 0)
			printf(", expire=Never\n");
		else
			printf(", expire=%s\n",
			    sec2str(p->expire - now.tv_sec));
	}
	free(buf);
}

void
plist(void)
{
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_ICMPV6, ICMPV6CTL_ND6_PRLIST };
	char *buf, *p, *ep;
	struct in6_prefix pfx;
	size_t l;
	struct timeval now;
	const int niflags = NI_NUMERICHOST;
	int ninflags = nflag ? NI_NUMERICHOST : 0;
	char namebuf[NI_MAXHOST];

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), NULL, &l, NULL, 0) < 0) {
		err(1, "sysctl(ICMPV6CTL_ND6_PRLIST)");
		/*NOTREACHED*/
	}
	if (l == 0)
		return;
	buf = malloc(l);
	if (buf == NULL) {
		err(1, "malloc");
		/*NOTREACHED*/
	}
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), buf, &l, NULL, 0) < 0) {
		err(1, "sysctl(ICMPV6CTL_ND6_PRLIST)");
		/*NOTREACHED*/
	}

	ep = buf + l;
	for (p = buf; p < ep; ) {
		memcpy(&pfx, p, sizeof(pfx));
		p += sizeof(pfx);

		if (getnameinfo((struct sockaddr *)&pfx.prefix,
		    pfx.prefix.sin6_len, namebuf, sizeof(namebuf),
		    NULL, 0, niflags) != 0)
			strlcpy(namebuf, "?", sizeof(namebuf));
		printf("%s/%d if=%s\n", namebuf, pfx.prefixlen,
		    if_indextoname(pfx.if_index, ifix_buf));

		gettimeofday(&now, 0);
		/*
		 * meaning of fields, especially flags, is very different
		 * by origin.  notify the difference to the users.
		 */
		printf("flags=%s%s%s%s%s",
		    pfx.raflags.onlink ? "L" : "",
		    pfx.raflags.autonomous ? "A" : "",
		    (pfx.flags & NDPRF_ONLINK) != 0 ? "O" : "",
		    (pfx.flags & NDPRF_DETACHED) != 0 ? "D" : "",
		    (pfx.flags & NDPRF_HOME) != 0 ? "H" : ""
		    );
		if (pfx.vltime == ND6_INFINITE_LIFETIME)
			printf(" vltime=infinity");
		else
			printf(" vltime=%lu", (unsigned long)pfx.vltime);
		if (pfx.pltime == ND6_INFINITE_LIFETIME)
			printf(", pltime=infinity");
		else
			printf(", pltime=%lu", (unsigned long)pfx.pltime);
		if (pfx.expire == 0)
			printf(", expire=Never");
		else if (pfx.expire >= now.tv_sec)
			printf(", expire=%s",
			    sec2str(pfx.expire - now.tv_sec));
		else
			printf(", expired");
		printf(", ref=%d", pfx.refcnt);
		printf("\n");
		/*
		 * "advertising router" list is meaningful only if the prefix
		 * information is from RA.
		 */
		if (pfx.advrtrs) {
			int j;
			struct sockaddr_in6 sin6;

			printf("  advertised by\n");
			for (j = 0; j < pfx.advrtrs && p <= ep; j++) {
				struct in6_nbrinfo *nbi;

				memcpy(&sin6, p, sizeof(sin6));
				p += sizeof(sin6);

				if (getnameinfo((struct sockaddr *)&sin6,
				    sin6.sin6_len, namebuf, sizeof(namebuf),
				    NULL, 0, ninflags) != 0)
					strlcpy(namebuf, "?", sizeof(namebuf));
				printf("    %s", namebuf);

				nbi = getnbrinfo(&sin6.sin6_addr,
				    pfx.if_index, 0);
				if (nbi) {
					switch (nbi->state) {
					case ND6_LLINFO_REACHABLE:
					case ND6_LLINFO_STALE:
					case ND6_LLINFO_DELAY:
					case ND6_LLINFO_PROBE:
						printf(" (reachable)\n");
						break;
					default:
						printf(" (unreachable)\n");
					}
				} else
					printf(" (no neighbor state)\n");
			}
		} else
			printf("  No advertising router\n");
	}
	free(buf);
}

void
pfx_flush(void)
{
	char dummyif[IFNAMSIZ+8];
	int s;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");
	strlcpy(dummyif, "lo0", sizeof(dummyif)); /* dummy */
	if (ioctl(s, SIOCSPFXFLUSH_IN6, (caddr_t)&dummyif) < 0)
		err(1, "ioctl(SIOCSPFXFLUSH_IN6)");
	close(s);
}

void
rtr_flush(void)
{
	char dummyif[IFNAMSIZ+8];
	int s;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");
	strlcpy(dummyif, "lo0", sizeof(dummyif)); /* dummy */
	if (ioctl(s, SIOCSRTRFLUSH_IN6, (caddr_t)&dummyif) < 0)
		err(1, "ioctl(SIOCSRTRFLUSH_IN6)");

	close(s);
}

void
harmonize_rtr(void)
{
	char dummyif[IFNAMSIZ+8];
	int s;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");
	strlcpy(dummyif, "lo0", sizeof(dummyif)); /* dummy */
	if (ioctl(s, SIOCSNDFLUSH_IN6, (caddr_t)&dummyif) < 0)
		err(1, "ioctl(SIOCSNDFLUSH_IN6)");

	close(s);
}

static char *
sec2str(time_t total)
{
	static char result[256];
	int days, hours, mins, secs;
	int first = 1;
	char *p = result;
	char *ep = &result[sizeof(result)];
	int n;

	days = total / 3600 / 24;
	hours = (total / 3600) % 24;
	mins = (total / 60) % 60;
	secs = total % 60;

	if (days) {
		first = 0;
		n = snprintf(p, ep - p, "%dd", days);
		if (n < 0 || n >= ep - p)
			return "?";
		p += n;
	}
	if (!first || hours) {
		first = 0;
		n = snprintf(p, ep - p, "%dh", hours);
		if (n < 0 || n >= ep - p)
			return "?";
		p += n;
	}
	if (!first || mins) {
		first = 0;
		n = snprintf(p, ep - p, "%dm", mins);
		if (n < 0 || n >= ep - p)
			return "?";
		p += n;
	}
	snprintf(p, ep - p, "%ds", secs);

	return(result);
}

/*
 * Print the timestamp
 * from tcpdump/util.c
 */
static void
ts_print(const struct timeval *tvp)
{
	int s;

	/* Default */
	s = (tvp->tv_sec + thiszone) % 86400;
	(void)printf("%02d:%02d:%02d.%06u ",
	    s / 3600, (s % 3600) / 60, s % 60, (u_int32_t)tvp->tv_usec);
}
@


1.78
log
@Checking for RTF_BROADCAST here makes no sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.77 2016/08/05 11:53:23 jca Exp $	*/
d553 1
a553 1
#define W_IF	6
@


1.77
log
@Using a macro to save 4 chars is mere obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.76 2016/08/05 11:44:10 jca Exp $	*/
d515 1
a515 1
			if (rtm->rtm_flags & (RTF_LOCAL|RTF_BROADCAST))
@


1.76
log
@Kill an unused macro

...instead of leaving an XXX about it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.75 2016/08/02 16:17:54 jca Exp $	*/
d935 1
a935 2
#define ND nd.ndi
	newflags = ND.flags;
d957 1
a957 1
		ND.flags = newflags;
d965 1
a965 1
	if (!ND.initialized) {
d971 5
a975 4
	    ND.basereachable / 1000, ND.basereachable % 1000);
	printf(", reachable=%ds", ND.reachable);
	printf(", retrans=%ds%dms", ND.retrans / 1000, ND.retrans % 1000);
	if (ND.flags) {
d977 1
a977 1
		if ((ND.flags & ND6_IFF_PERFORMNUD))
d979 1
a979 1
		if ((ND.flags & ND6_IFF_ACCEPT_RTADV))
a982 1
#undef ND
@


1.75
log
@Ensure that "lim" is initialized and reset at each loop run.

Avoids possible invalid memory accesses.  ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.74 2016/07/31 19:23:24 jca Exp $	*/
a112 2
/* XXX remove */
#define ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))
@


1.74
log
@Rename the route socket to a more useful name.

Avoid a bunch of "warning: declaration of 's' shadows a global
declaration" while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.73 2016/07/31 19:17:41 jca Exp $	*/
d113 1
d583 1
d607 1
a607 1
	for (next = buf; next && next < lim; next += rtm->rtm_msglen) {
@


1.73
log
@Turn two global variables into variables local to main.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.72 2016/07/31 19:12:26 jca Exp $	*/
d119 1
a119 1
static int s = -1;
d337 3
a339 3
	if (s < 0) {
		s = socket(PF_ROUTE, SOCK_RAW, 0);
		if (s < 0) {
d860 1
a860 1
	if ((rlen = write(s, (char *)&m_rtmsg, l)) < 0) {
d867 1
a867 1
		l = read(s, (char *)&m_rtmsg, sizeof(m_rtmsg));
@


1.72
log
@Duplicated decls
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.71 2016/04/05 18:09:30 jca Exp $	*/
a154 3
int mode = 0;
char *arg = NULL;

d159 2
@


1.71
log
@etheraddr -> ether_addr, as in arp(8); discussed with jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.70 2016/04/04 11:37:09 jca Exp $	*/
a141 1
void rtrlist(void);
a144 1
static char *ether_str(struct sockaddr_dl *);
@


1.70
log
@Hook up ndp -f.

Initial diff from Dimitris Papastamos.  Support from mikeb@@, ok benno@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.69 2016/01/26 18:26:19 mmcc Exp $	*/
d803 1
a803 1
	printf("\t[-s nodename etheraddr [temp] [proxy]] ");
@


1.69
log
@Use an unsigned int rather than an int when iterating through all 32
bits in the form:

for (i = 1; i; i <<= 1)

This avoids undefined operations when shifting into and out of the
highest-order bit.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.68 2016/01/12 09:47:13 mpi Exp $	*/
d243 5
@


1.68
log
@Do not print an error if the list of prefixes is empty.

This is becoming more and more comon now that the list is only
used for autoconfigured prefix.

From Florian Riehm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.67 2015/10/28 12:14:25 florian Exp $	*/
d882 1
a882 1
	int i;
@


1.67
log
@Remove linkmtu and maxmtu from struct nd_ifinfo. IN6_LINKMTU can now
die and ifp->if_mtu is the one true mtu.
Suggested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.66 2015/10/25 11:44:30 deraadt Exp $	*/
d1058 2
@


1.66
log
@backout; many issues remain...
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.64 2015/10/24 20:41:40 matthieu Exp $	*/
d969 1
a969 2
	printf("linkmtu=%d", ND.linkmtu);
	printf(", basereachable=%ds%dms",
@


1.65
log
@pledge the main usage patterns similar to arp(8).  Some akkorokamui
prevent doing this better, someone should try to refactor this more
like arp... also figure out what dawn-of-ipv6 options can be removed.
ok benno
@
text
@d335 6
a340 12
	if (s >= 0)
		return;
	s = socket(PF_ROUTE, SOCK_RAW, 0);
	if (s < 0)
		err(1, "socket");

	if (nflag) {
		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio dns", NULL) == -1)
			err(1, "pledge");
a602 8
	if (nflag) {
		if (pledge("stdio route", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio route dns", NULL) == -1)
			err(1, "pledge");
	}

d797 2
a798 2
	printf("           [-f filename] [-i interface [flag ...]]\n");
	printf("           [-s nodename etheraddr [temp] [proxy]] ");
@


1.64
log
@chlim has been removed from the nd_ifinfo structure.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.63 2015/10/23 15:47:54 benno Exp $	*/
d335 12
a346 6
	if (s < 0) {
		s = socket(PF_ROUTE, SOCK_RAW, 0);
		if (s < 0) {
			err(1, "socket");
			/* NOTREACHED */
		}
d609 8
d811 2
a812 2
	printf("\t[-f filename] [-i interface [flag ...]]\n");
	printf("\t[-s nodename etheraddr [temp] [proxy]] ");
@


1.63
log
@ndp -n -d <addr> does dns lookups, even with -n. it should not.
found through pledge. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.62 2015/08/23 14:12:05 naddy Exp $	*/
a969 1
	printf(", curhlim=%d", ND.chlim);
@


1.62
log
@Use simple byte pointer arithmetic and memcpy from/to aligned stack
variables to handle the "packed" binary format passed out to userland
when querying the prefix/router list.  From NetBSD (Martin Husemann).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.61 2015/06/03 08:10:53 mpi Exp $	*/
d491 2
@


1.61
log
@Explicitly request the sockaddr_dl when doing a RTM_GET rather than
assuming that it will be in the gateway sa.

Fixes a regression introduced with the support of multiple connected
routes, found the hardway by deraadt@@.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.60 2015/04/18 18:28:38 deraadt Exp $	*/
d1046 2
a1047 3
	char *buf;
	struct in6_prefix *p, *ep, *n;
	struct sockaddr_in6 *advrtr;
d1068 4
a1071 4
	ep = (struct in6_prefix *)(buf + l);
	for (p = (struct in6_prefix *)buf; p < ep; p = n) {
		advrtr = (struct sockaddr_in6 *)(p + 1);
		n = (struct in6_prefix *)&advrtr[p->advrtrs];
d1073 2
a1074 2
		if (getnameinfo((struct sockaddr *)&p->prefix,
		    p->prefix.sin6_len, namebuf, sizeof(namebuf),
d1077 2
a1078 2
		printf("%s/%d if=%s\n", namebuf, p->prefixlen,
		    if_indextoname(p->if_index, ifix_buf));
d1086 5
a1090 5
		    p->raflags.onlink ? "L" : "",
		    p->raflags.autonomous ? "A" : "",
		    (p->flags & NDPRF_ONLINK) != 0 ? "O" : "",
		    (p->flags & NDPRF_DETACHED) != 0 ? "D" : "",
		    (p->flags & NDPRF_HOME) != 0 ? "H" : ""
d1092 1
a1092 1
		if (p->vltime == ND6_INFINITE_LIFETIME)
d1095 2
a1096 2
			printf(" vltime=%lu", (unsigned long)p->vltime);
		if (p->pltime == ND6_INFINITE_LIFETIME)
d1099 2
a1100 2
			printf(", pltime=%lu", (unsigned long)p->pltime);
		if (p->expire == 0)
d1102 1
a1102 1
		else if (p->expire >= now.tv_sec)
d1104 1
a1104 1
			    sec2str(p->expire - now.tv_sec));
d1107 1
a1107 1
		printf(", ref=%d", p->refcnt);
d1113 1
a1113 1
		if (p->advrtrs) {
d1115 1
a1115 1
			struct sockaddr_in6 *sin6;
a1116 1
			sin6 = advrtr;
d1118 1
a1118 1
			for (j = 0; j < p->advrtrs; j++) {
d1121 5
a1125 2
				if (getnameinfo((struct sockaddr *)sin6,
				    sin6->sin6_len, namebuf, sizeof(namebuf),
d1130 2
a1131 2
				nbi = getnbrinfo(&sin6->sin6_addr,
				    p->if_index, 0);
a1144 1
				sin6++;
@


1.60
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.59 2015/01/16 06:40:18 deraadt Exp $	*/
d137 1
d347 1
d405 2
a406 1
	if (rtmsg(RTM_GET) < 0) {
d410 1
a410 2
	sin = (struct sockaddr_in6 *)((char *)rtm + rtm->rtm_hdrlen);
	sdl = (struct sockaddr_dl *)(ROUNDUP(sin->sin6_len) + (char *)sin);
d504 2
a505 1
	if (rtmsg(RTM_GET) < 0) {
d509 1
a509 2
	sin = (struct sockaddr_in6 *)((char *)rtm + rtm->rtm_hdrlen);
	sdl = (struct sockaddr_dl *)(ROUNDUP(sin->sin6_len) + (char *)sin);
d837 1
a837 1
		rtm->rtm_addrs |= RTA_DST;
d849 1
d869 42
@


1.59
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.58 2014/09/07 22:40:30 bluhm Exp $	*/
d105 1
d206 2
a207 2
			repeat = atoi(optarg);
			if (repeat < 0) {
@


1.58
log
@Remove useless comment, snprintf and if/else.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.57 2014/09/03 10:39:41 mpi Exp $	*/
a76 1
#include <sys/param.h>
@


1.57
log
@Be coherent in the way arp(8) and ndp(8) display local entries and
use a new flag `l' to ditinguish them.

Also skip broadcast entries, they are not reall ARP entries and will
never be resolved to anything, requested by deraadt@@.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.56 2014/08/22 22:37:32 sthen Exp $	*/
a566 1
	char flgbuf[8];
d712 4
a715 17
		/*
		 * other flags. R: router, P: proxy, W: ??
		 */
		if ((rtm->rtm_addrs & RTA_NETMASK) == 0) {
			snprintf(flgbuf, sizeof(flgbuf), "%s%s%s",
			    (rtm->rtm_flags & RTF_LOCAL) ? "l" : "",
			    isrouter ? "R" : "",
			    (rtm->rtm_flags & RTF_ANNOUNCE) ? "p" : "");
		} else {
			sin = (struct sockaddr_in6 *)
			    (sdl->sdl_len + (char *)sdl);
			snprintf(flgbuf, sizeof(flgbuf), "%s%s%s",
			    (rtm->rtm_flags & RTF_LOCAL) ? "l" : "",
			    isrouter ? "R" : "",
			    (rtm->rtm_flags & RTF_ANNOUNCE) ? "p" : "");
		}
		printf(" %s", flgbuf);
@


1.56
log
@switch ndp to display MAC addresses in 00:00:00:00:00:00 format, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.55 2014/08/19 12:39:36 mpi Exp $	*/
d717 2
a718 1
			snprintf(flgbuf, sizeof(flgbuf), "%s%s",
d724 2
a725 2
#if 0	/* W and P are mystery even for us */
			snprintf(flgbuf, sizeof(flgbuf), "%s%s%s%s",
a726 2
			    !IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr) ? "P" : "",
			    (sin->sin6_len != sizeof(struct sockaddr_in6)) ? "W" : "",
a727 5
#else
			snprintf(flgbuf, sizeof(flgbuf), "%s%s",
			    isrouter ? "R" : "",
			    (rtm->rtm_flags & RTF_ANNOUNCE) ? "p" : "");
#endif
@


1.55
log
@Entries for broadcast addresses should also be ignored, just like local
entries.

ok florian@@, mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.54 2014/08/11 09:47:56 mpi Exp $	*/
d784 1
a784 1
		snprintf(hbuf, sizeof(hbuf), "%x:%x:%x:%x:%x:%x",
@


1.54
log
@Do not try to delete RTF_LOCAL entries.  Such routes are automatically
created /deleted by the kernel when an IP address is added/removed
on/from an interface and should not be manipulated by userland tools.

ok henning@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.53 2013/10/21 12:41:52 jmc Exp $	*/
d510 1
a510 1
			if (rtm->rtm_flags & RTF_LOCAL)
@


1.53
log
@- -V after -t
- fix usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.52 2013/10/21 08:46:07 phessler Exp $	*/
d509 5
a513 4
		if (sdl->sdl_family == AF_LINK &&
		    (rtm->rtm_flags & RTF_LLINFO) &&
		    !(rtm->rtm_flags & RTF_GATEWAY)) {
			goto delete;
@


1.52
log
@Add rdomain support to IPv6 configuration tools

OK claudio@@ and bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.51 2013/10/07 12:46:57 jca Exp $	*/
d811 4
a814 4
	printf("[-A wait] [-d hostname] [-V rdomain]\n");
	printf("\t[-f filename] ");
	printf("[-i interface [flag ...]]\n");
	printf("\t[-s nodename etheraddr [temp] [proxy]] [hostname]\n");
@


1.51
log
@Fix a segfault in ndp -A by not freeing the buffer when not in repeat
mode.  Input from and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.50 2013/08/15 13:43:33 bluhm Exp $	*/
d147 1
d162 2
a163 1
	int ch;
d167 1
a167 1
	while ((ch = getopt(argc, argv, "acd:f:i:nprstA:HPR")) != -1)
d212 8
d555 1
a555 1
	int mib[6];
d582 1
d584 1
a584 1
		if (sysctl(mib, 6, NULL, &needed, NULL, 0) == -1)
d590 1
a590 1
		if (sysctl(mib, 6, buf, &needed, NULL, 0) == -1) {
d811 1
a811 1
	printf("[-A wait] [-d hostname]\n");
d833 1
@


1.50
log
@Reduce the warnings when arp, rarp, ndp are compiled with WARNINGS=yes.
warning: declaration of 'time' shadows a global declaration
No binary change; OK lteo@@ florian@@ henning@@ mikeb@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.49 2013/08/09 17:52:12 bluhm Exp $	*/
a729 2
	if (buf != NULL)
		free(buf);
d737 2
@


1.49
log
@Remove dead code and useless #include and #ifdef from ndp.
No binary change; OK deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.48 2013/07/19 09:12:51 bluhm Exp $	*/
d385 1
a385 1
			struct timeval time;
d387 2
a388 2
			gettimeofday(&time, 0);
			expire_time = time.tv_sec + 20 * 60;
d552 1
a552 1
	struct timeval time;
d639 1
a639 1
		gettimeofday(&time, 0);
d641 1
a641 1
			ts_print(&time);
d662 1
a662 1
			if (nbi->expire > time.tv_sec) {
d664 1
a664 1
				    sec2str(nbi->expire - time.tv_sec));
d959 1
a959 1
	struct timeval time;
d994 1
a994 1
		gettimeofday(&time, 0);
d999 1
a999 1
			    sec2str(p->expire - time.tv_sec));
d1012 1
a1012 1
	struct timeval time;
d1043 1
a1043 1
		gettimeofday(&time, 0);
d1065 1
a1065 1
		else if (p->expire >= time.tv_sec)
d1067 1
a1067 1
			    sec2str(p->expire - time.tv_sec));
@


1.48
log
@ndp used an int expire_time for time calculation.  Convert this
into time_t.
OK henning@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.47 2013/03/21 04:43:17 deraadt Exp $	*/
a147 1
#ifdef ICMPV6CTL_ND6_DRLIST
a153 1
#endif
a634 4
#ifdef RTF_WASCLONED
			if (rtm->rtm_flags & RTF_WASCLONED)
				delete(host_buf);
#elif defined(RTF_CLONED)
a636 3
#else
			delete(host_buf);
#endif
a673 5
#ifdef ND6_LLINFO_WAITDELETE
			case ND6_LLINFO_WAITDELETE:
				 printf(" W");
				 break;
#endif
a881 3
#ifdef IPV6CTL_USETEMPADDR
	u_int8_t nullbuf[8];
#endif
a913 1
#ifdef ND6_IFF_ACCEPT_RTADV
a914 4
#endif
#ifdef ND6_IFF_PREFER_SOURCE
		SETFLAG("prefer_source", ND6_IFF_PREFER_SOURCE);
#endif
a934 26
#ifdef IPV6CTL_USETEMPADDR
	memset(nullbuf, 0, sizeof(nullbuf));
	if (memcmp(nullbuf, ND.randomid, sizeof(nullbuf)) != 0) {
		int j;
		u_int8_t *rbuf;

		for (i = 0; i < 3; i++) {
			switch (i) {
			case 0:
				printf("\nRandom seed(0): ");
				rbuf = ND.randomseed0;
				break;
			case 1:
				printf("\nRandom seed(1): ");
				rbuf = ND.randomseed1;
				break;
			case 2:
				printf("\nRandom ID:      ");
				rbuf = ND.randomid;
				break;
			}
			for (j = 0; j < 8; j++)
				printf("%02x", rbuf[j]);
		}
	}
#endif
a938 1
#ifdef ND6_IFF_ACCEPT_RTADV
a940 5
#endif
#ifdef ND6_IFF_PREFER_SOURCE
		if ((ND.flags & ND6_IFF_PREFER_SOURCE))
			printf("prefer_source ");
#endif
a954 1
#ifdef ICMPV6CTL_ND6_DRLIST
a1001 42
#else
	struct in6_drlist dr;
	int s, i;
	struct timeval time;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		err(1, "socket");
		/* NOTREACHED */
	}
	bzero(&dr, sizeof(dr));
	strlcpy(dr.ifname, "lo0", sizeof(dr.ifname)); /* dummy */
	if (ioctl(s, SIOCGDRLST_IN6, (caddr_t)&dr) < 0) {
		err(1, "ioctl(SIOCGDRLST_IN6)");
		/* NOTREACHED */
	}
#define DR dr.defrouter[i]
	for (i = 0 ; DR.if_index && i < DRLSTSIZ ; i++) {
		struct sockaddr_in6 sin6;

		bzero(&sin6, sizeof(sin6));
		sin6.sin6_family = AF_INET6;
		sin6.sin6_len = sizeof(sin6);
		sin6.sin6_addr = DR.rtaddr;
		getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len, host_buf,
		    sizeof(host_buf), NULL, 0,
		    (nflag ? NI_NUMERICHOST : 0));

		printf("%s if=%s", host_buf,
		    if_indextoname(DR.if_index, ifix_buf));
		printf(", flags=%s%s",
		    DR.flags & ND_RA_FLAG_MANAGED ? "M" : "",
		    DR.flags & ND_RA_FLAG_OTHER   ? "O" : "");
		gettimeofday(&time, 0);
		if (DR.expire == 0)
			printf(", expire=Never\n");
		else
			printf(", expire=%s\n",
			    sec2str(DR.expire - time.tv_sec));
	}
#undef DR
	close(s);
#endif
a1006 1
#ifdef ICMPV6CTL_ND6_PRLIST
a1052 1
#ifdef NDPRF_HOME
a1053 3
#else
		    ""
#endif
a1111 171
#else
	struct in6_prlist pr;
	int s, i;
	struct timeval time;

	gettimeofday(&time, 0);

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		err(1, "socket");
		/* NOTREACHED */
	}
	bzero(&pr, sizeof(pr));
	strlcpy(pr.ifname, "lo0", sizeof(pr.ifname)); /* dummy */
	if (ioctl(s, SIOCGPRLST_IN6, (caddr_t)&pr) < 0) {
		err(1, "ioctl(SIOCGPRLST_IN6)");
		/* NOTREACHED */
	}
#define PR pr.prefix[i]
	for (i = 0; PR.if_index && i < PRLSTSIZ ; i++) {
		struct sockaddr_in6 p6;
		char namebuf[NI_MAXHOST];
		int niflags;

#ifdef NDPRF_ONLINK
		p6 = PR.prefix;
#else
		memset(&p6, 0, sizeof(p6));
		p6.sin6_family = AF_INET6;
		p6.sin6_len = sizeof(p6);
		p6.sin6_addr = PR.prefix;
#endif

		/*
		 * copy link index to sin6_scope_id field.
		 * XXX: KAME specific.
		 */
		if (IN6_IS_ADDR_LINKLOCAL(&p6.sin6_addr)) {
			u_int16_t linkid;

			memcpy(&linkid, &p6.sin6_addr.s6_addr[2],
			    sizeof(linkid));
			linkid = ntohs(linkid);
			p6.sin6_scope_id = linkid;
			p6.sin6_addr.s6_addr[2] = 0;
			p6.sin6_addr.s6_addr[3] = 0;
		}

		niflags = NI_NUMERICHOST;
		if (getnameinfo((struct sockaddr *)&p6,
		    sizeof(p6), namebuf, sizeof(namebuf),
		    NULL, 0, niflags)) {
			warnx("getnameinfo failed");
			continue;
		}
		printf("%s/%d if=%s\n", namebuf, PR.prefixlen,
		    if_indextoname(PR.if_index, ifix_buf));

		gettimeofday(&time, 0);
		/*
		 * meaning of fields, especially flags, is very different
		 * by origin.  notify the difference to the users.
		 */
#if 0
		printf("  %s",
		    PR.origin == PR_ORIG_RA ? "" : "advertise: ");
#endif
#ifdef NDPRF_ONLINK
		printf("flags=%s%s%s%s%s",
		    PR.raflags.onlink ? "L" : "",
		    PR.raflags.autonomous ? "A" : "",
		    (PR.flags & NDPRF_ONLINK) != 0 ? "O" : "",
		    (PR.flags & NDPRF_DETACHED) != 0 ? "D" : "",
#ifdef NDPRF_HOME
		    (PR.flags & NDPRF_HOME) != 0 ? "H" : ""
#else
		    ""
#endif
		    );
#else
		printf("flags=%s%s",
		    PR.raflags.onlink ? "L" : "",
		    PR.raflags.autonomous ? "A" : "");
#endif
		if (PR.vltime == ND6_INFINITE_LIFETIME)
			printf(" vltime=infinity");
		else
			printf(" vltime=%lu", PR.vltime);
		if (PR.pltime == ND6_INFINITE_LIFETIME)
			printf(", pltime=infinity");
		else
			printf(", pltime=%lu", PR.pltime);
		if (PR.expire == 0)
			printf(", expire=Never");
		else if (PR.expire >= time.tv_sec)
			printf(", expire=%s",
			    sec2str(PR.expire - time.tv_sec));
		else
			printf(", expired");
#ifdef NDPRF_ONLINK
		printf(", ref=%d", PR.refcnt);
#endif
#if 0
		switch (PR.origin) {
		case PR_ORIG_RA:
			printf(", origin=RA");
			break;
		case PR_ORIG_RR:
			printf(", origin=RR");
			break;
		case PR_ORIG_STATIC:
			printf(", origin=static");
			break;
		case PR_ORIG_KERNEL:
			printf(", origin=kernel");
			break;
		default:
			printf(", origin=?");
			break;
		}
#endif
		printf("\n");
		/*
		 * "advertising router" list is meaningful only if the prefix
		 * information is from RA.
		 */
		if (0 &&	/* prefix origin is almost obsolted */
		    PR.origin != PR_ORIG_RA)
			;
		else if (PR.advrtrs) {
			int j;
			printf("  advertised by\n");
			for (j = 0; j < PR.advrtrs; j++) {
				struct sockaddr_in6 sin6;
				struct in6_nbrinfo *nbi;

				bzero(&sin6, sizeof(sin6));
				sin6.sin6_family = AF_INET6;
				sin6.sin6_len = sizeof(sin6);
				sin6.sin6_addr = PR.advrtr[j];
				sin6.sin6_scope_id = PR.if_index; /* XXX */
				getnameinfo((struct sockaddr *)&sin6,
				    sin6.sin6_len, host_buf,
				    sizeof(host_buf), NULL, 0,
				    (nflag ? NI_NUMERICHOST : 0));
				printf("    %s", host_buf);

				nbi = getnbrinfo(&sin6.sin6_addr,
				    PR.if_index, 0);
				if (nbi) {
					switch (nbi->state) {
					case ND6_LLINFO_REACHABLE:
					case ND6_LLINFO_STALE:
					case ND6_LLINFO_DELAY:
					case ND6_LLINFO_PROBE:
						 printf(" (reachable)\n");
						 break;
					default:
						 printf(" (unreachable)\n");
					}
				} else
					printf(" (no neighbor state)\n");
			}
			if (PR.advrtrs > DRLSTSIZ)
				printf("    and %d routers\n",
				    PR.advrtrs - DRLSTSIZ);
		} else
			printf("  No advertising router\n");
	}
#undef PR
	close(s);
#endif
@


1.47
log
@create realloc() loops around sysctl for array-based mibs, in programs
which want a "full" dump
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.46 2013/03/11 14:02:37 mpi Exp $	*/
d338 2
a339 1
int	expire_time, flags, found_entry;
d383 2
a384 1
	flags = expire_time = 0;
@


1.46
log
@Remove the -I option, even if the ioctls for manipulating a default
interface are defined, nothing use it in the kernel since the on-link
assumption behavior removal back in 2004.

ok mikeb@@, bluhm@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.45 2009/06/25 15:44:43 claudio Exp $	*/
d547 1
a547 1
	char *lim, *buf, *next;
d572 10
a581 6
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
		err(1, "sysctl(PF_ROUTE estimate)");
	if (needed > 0) {
		if ((buf = malloc(needed)) == NULL)
			err(1, "malloc");
		if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
d583 1
d585 2
a586 2
	} else
		buf = lim = NULL;
@


1.45
log
@Another copy of the strange while loop seen in route(8). Add missing
RTM_VERSION check.  Tested and OK sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.44 2009/06/17 15:31:23 claudio Exp $	*/
a143 4
#ifdef SIOCSDEFIFACE_IN6	/* XXX: check SIOCGDEFIFACE_IN6 as well? */
static void getdefif(void);
static void setdefif(char *);
#endif
d167 1
a167 1
	while ((ch = getopt(argc, argv, "acd:f:Ii:nprstA:HPR")) != -1)
a176 1
		case 'I':
a234 18
	case 'I':
#ifdef SIOCSDEFIFACE_IN6	/* XXX: check SIOCGDEFIFACE_IN6 as well? */
		if (argc > 1) {
			usage();
			/*NOTREACHED*/
		} else if (argc == 1) {
			if (strcmp(*argv, "delete") == 0 ||
			    if_nametoindex(*argv))
				setdefif(*argv);
			else
				errx(1, "invalid interface %s", *argv);
		}
		getdefif(); /* always call it to print the result */
		break;
#else
		errx(1, "not supported yet");
		/*NOTREACHED*/
#endif
a808 3
#ifdef SIOCSDEFIFACE_IN6
	printf("[-I [interface | delete]] ");
#endif
a1422 54

#ifdef SIOCSDEFIFACE_IN6	/* XXX: check SIOCGDEFIFACE_IN6 as well? */
static void
setdefif(char *ifname)
{
	struct in6_ndifreq ndifreq;
	unsigned int ifindex;

	if (strcasecmp(ifname, "delete") == 0)
		ifindex = 0;
	else {
		if ((ifindex = if_nametoindex(ifname)) == 0)
			err(1, "failed to resolve i/f index for %s", ifname);
	}

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");

	strlcpy(ndifreq.ifname, "lo0", sizeof(ndifreq.ifname)); /* dummy */
	ndifreq.ifindex = ifindex;

	if (ioctl(s, SIOCSDEFIFACE_IN6, (caddr_t)&ndifreq) < 0)
		err(1, "ioctl(SIOCSDEFIFACE_IN6)");

	close(s);
}

static void
getdefif(void)
{
	struct in6_ndifreq ndifreq;
	char ifname[IFNAMSIZ+8];

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");

	memset(&ndifreq, 0, sizeof(ndifreq));
	strlcpy(ndifreq.ifname, "lo0", sizeof(ndifreq.ifname)); /* dummy */

	if (ioctl(s, SIOCGDEFIFACE_IN6, (caddr_t)&ndifreq) < 0)
		err(1, "ioctl(SIOCGDEFIFACE_IN6)");

	if (ndifreq.ifindex == 0)
		printf("No default interface.\n");
	else {
		if ((if_indextoname(ndifreq.ifindex, ifname)) == NULL)
			err(1, "failed to resolve ifname for index %lu",
			    ndifreq.ifindex);
		printf("ND default interface = %s\n", ifname);
	}

	close(s);
}
#endif
@


1.44
log
@Check for the correct RTM_VERSION before accessing anything in the rt message.
Fixes a SIGBUS seen on alpha by naddy@@. OK naddy@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.43 2009/06/05 22:40:24 chris Exp $	*/
d901 2
a902 1
	} while (l > 0 && (rtm->rtm_seq != seq || rtm->rtm_pid != pid));
@


1.43
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.42 2008/06/09 15:49:31 claudio Exp $	*/
d610 2
@


1.42
log
@Correctly round the sockaddrs so that ndp works on 64bit machines.
Stupid sockaddr_in6 has the worst size possible.
OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.41 2008/05/17 23:31:52 sobrado Exp $	*/
d420 1
a420 1
	sin = (struct sockaddr_in6 *)(rtm + 1);
d519 1
a519 1
	sin = (struct sockaddr_in6 *)(rtm + 1);
d610 1
a610 1
		sin = (struct sockaddr_in6 *)(rtm + 1);
@


1.41
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.40 2008/05/05 13:53:48 markus Exp $	*/
d877 1
a877 1
		bcopy((char *)&s, cp, sizeof(s)); cp += sizeof(s);}
@


1.40
log
@don't install a /128 bit net route for 'proxy' ndp entries
and show them with ndp -a, too. from KAME rev 1.121; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.39 2007/03/22 15:06:57 itojun Exp $	*/
d833 1
a833 1
	printf("[-i interface [flags...]]\n");
@


1.39
log
@do not try to grab default router list on "ndp -r" if it's empty
(happens when the machine is an IPv6 router).
from kame
ok deraadt, mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.38 2007/02/18 23:50:47 ray Exp $	*/
d865 1
d870 1
d881 1
d884 1
@


1.38
log
@Use sizeof(buf) instead of hard coded numbers.

From Charles Longeau <chl at tuxfamily dot org> long ago.

OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.37 2006/08/10 22:08:33 jmc Exp $	*/
d1032 2
@


1.37
log
@sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.36 2005/04/04 09:03:08 deraadt Exp $	*/
d331 1
a331 1
	while (fgets(line, 100, fp) != NULL) {
@


1.36
log
@nlist.h not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.35 2004/05/24 03:56:22 itojun Exp $	*/
d827 3
a829 6
	printf("usage: ndp [-nt] hostname\n");
	printf("       ndp [-nt] -a | -c | -p | -r | -H | -P | -R\n");
	printf("       ndp [-nt] -A wait\n");
	printf("       ndp [-nt] -d hostname\n");
	printf("       ndp [-nt] -f filename\n");
	printf("       ndp [-nt] -i interface [flags...]\n");
d831 1
a831 1
	printf("       ndp [-nt] -I [interface|delete]\n");
d833 2
a834 1
	printf("       ndp [-nt] -s nodename etheraddr [temp] [proxy]\n");
@


1.35
log
@missing close(2).  Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.34 2004/03/16 01:11:09 tedu Exp $	*/
a101 1
#include <nlist.h>
@


1.34
log
@errno is not specified to be int, but something from errno.h.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.33 2004/02/10 14:47:22 itojun Exp $	*/
d1411 1
@


1.33
log
@fflush(stdout).  kame pr 584
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.32 2004/01/08 06:51:44 itojun Exp $	*/
a574 1
	extern int h_errno;
@


1.32
log
@typo fix (must be rtm_addrs).  from fujitsu
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.31 2003/10/02 03:26:07 itojun Exp $	*/
d765 1
@


1.31
log
@style sync w/ kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.30 2003/09/26 15:51:43 avsm Exp $	*/
d870 1
a870 1
			rtm->rtm_flags |= RTA_NETMASK;
@


1.30
log
@add bounds to sscanf, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.29 2003/06/26 21:33:33 deraadt Exp $	*/
d333 2
a334 2
		i = sscanf(line, "%49s %49s %49s %49s %49s", arg[0], arg[1], arg[2],
		    arg[3], arg[4]);
@


1.29
log
@err() cleanup; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.28 2003/06/26 21:32:01 deraadt Exp $	*/
d333 1
a333 1
		i = sscanf(line, "%s %s %s %s %s", arg[0], arg[1], arg[2],
@


1.28
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.27 2003/06/11 23:33:29 deraadt Exp $	*/
d98 3
a101 1
#include <errno.h>
a102 2
#include <stdio.h>
#include <string.h>
a103 1
#include <err.h>
d105 1
a105 1
#include <fcntl.h>
d108 1
d353 1
a353 1
			err(1, "ndp: socket");
d601 1
a601 1
			errx(1, "malloc");
d1036 2
a1037 2
	if (!buf) {
		errx(1, "not enough core");
d1133 2
a1134 2
	if (!buf) {
		errx(1, "not enough core");
@


1.27
log
@some ansification, some de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.26 2003/06/02 23:36:54 millert Exp $	*/
d166 1
a166 3
main(argc, argv)
	int argc;
	char **argv;
d316 1
a316 2
file(name)
	char *name;
d348 1
a348 1
getsocket()
d372 1
a372 3
set(argc, argv)
	int argc;
	char **argv;
d454 1
a454 2
get(host)
	char *host;
d490 1
a490 2
delete(host)
	char *host;
d567 1
a567 3
dump(addr, cflag)
	struct in6_addr *addr;
	int cflag;
d771 1
a771 4
getnbrinfo(addr, ifindex, warning)
	struct in6_addr *addr;
	int ifindex;
	int warning;
d794 1
a794 2
ether_str(sdl)
	struct sockaddr_dl *sdl;
d810 1
a810 3
ndp_ether_aton(a, n)
	char *a;
	u_char *n;
d826 1
a826 1
usage()
d842 1
a842 2
rtmsg(cmd)
	int cmd;
d906 1
a906 4
ifinfo(ifname, argc, argv)
	char *ifname;
	int argc;
	char **argv;
d1022 1
a1022 1
rtrlist()
d1115 1
a1115 1
plist()
d1401 1
a1401 1
pfx_flush()
d1414 1
a1414 1
rtr_flush()
d1429 1
a1429 1
harmonize_rtr()
d1445 1
a1445 2
setdefif(ifname)
	char *ifname;
d1470 1
a1470 1
getdefif()
d1498 1
a1498 2
sec2str(total)
	time_t total;
d1543 1
a1543 2
ts_print(tvp)
	const struct timeval *tvp;
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.25 2002/07/17 13:49:03 itojun Exp $	*/
d379 3
a381 3
	register struct sockaddr_in6 *sin = &sin_m;
	register struct sockaddr_dl *sdl;
	register struct rt_msghdr *rtm = &(m_rtmsg.m_rtm);
d500 1
a500 1
	register struct rt_msghdr *rtm = &m_rtmsg.m_rtm;
d862 3
a864 3
	register struct rt_msghdr *rtm = &m_rtmsg.m_rtm;
	register char *cp = m_rtmsg.m_space;
	register int l;
@


1.25
log
@with -i, flag on command line and flag displayed are different, and it does
nothing but confuse users.  sync them.

for -nud and such, you need "-- -nud" due to posix arg parsing.

sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.24 2002/06/03 19:30:49 itojun Exp $	*/
d47 1
a47 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.24
log
@recover backward compatibility in -I behavior. sync w/kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ndp.c,v 1.23 2002/06/03 04:44:50 itojun Exp $	*/
/*	$KAME: ndp.c,v 1.100 2002/06/03 19:25:27 itojun Exp $	*/
d1024 1
a1024 1
			printf("PERFORMNUD ");
d1027 1
a1027 1
			printf("ACCEPT_RA ");
d1031 1
a1031 1
			printf("PREFER_SRC ");
@


1.23
log
@more nroff/KNF.  from deraadt
@
text
@d1 2
a2 2
/*	$OpenBSD: ndp.c,v 1.22 2002/06/03 04:32:14 itojun Exp $	*/
/*	$KAME: ndp.c,v 1.99 2002/06/03 04:39:03 itojun Exp $	*/
d178 1
a178 1
	while ((ch = getopt(argc, argv, "acd:f:I:i:nprstA:HPR")) != -1)
d188 1
a197 1
		case 'I':
d249 1
a249 1
		if (argc != 0) {
d252 6
a258 2
		if (strcmp(arg, "default") == 0 || if_nametoindex(arg))
			setdefif(arg);
d854 1
a854 2
	printf("       ndp [-nt] -I interface\n");
	printf("       ndp [-nt] -I delete\n");
@


1.22
log
@typo
@
text
@d1 2
a2 2
/*	$OpenBSD: ndp.c,v 1.21 2002/06/03 03:33:53 itojun Exp $	*/
/*	$KAME: ndp.c,v 1.97 2002/06/03 03:31:25 itojun Exp $	*/
a130 1
int main(int, char **);
d335 1
a335 1
	while(fgets(line, 100, fp) != NULL) {
d835 1
a835 1
	for (i=0; i<6; i++)
d843 2
a844 2
	printf("usage: ndp hostname\n");
	printf("       ndp [-nt] -a\n");
a845 1
	printf("       ndp [-nt] -c\n");
d848 1
a848 1
	printf("       ndp -i interface [flags...]\n");
d850 2
a851 2
	printf("       ndp -I interface\n");
	printf("       ndp -I delete\n");
d853 1
a853 6
	printf("       ndp -p\n");
	printf("       ndp -r\n");
	printf("       ndp -s hostname ether_addr [temp] [proxy]\n");
	printf("       ndp -H\n");
	printf("       ndp -P\n");
	printf("       ndp -R\n");
@


1.21
log
@more posix-compliant arg parsing.  sync w/kame.  help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.20 2002/06/02 15:23:30 itojun Exp $	*/
d847 1
a847 1
	printf("       ndp [-nt]- c\n");
@


1.20
log
@KNF (no variable name should be present on prototype)
@
text
@d1 2
a2 2
/*	$OpenBSD: ndp.c,v 1.19 2002/06/02 01:31:14 deraadt Exp $	*/
/*	$KAME: ndp.c,v 1.86 2002/05/26 01:16:10 itojun Exp $	*/
a120 1
static int cflag;
d137 1
a137 1
void dump(struct in6_addr *);
d143 1
a143 1
void ifinfo(int, char **);
d167 3
a175 2
	int aflag = 0, dflag = 0, sflag = 0, Hflag = 0;
	int pflag = 0, rflag = 0, Pflag = 0, Rflag = 0;
d179 2
a180 2
	while ((ch = getopt(argc, argv, "acndfIilprstA:HPR")) != -1)
		switch ((char)ch) {
a181 2
			aflag = 1;
			break;
d183 12
a194 1
			cflag = 1;
d197 1
a197 2
			dflag = 1;
			break;
a198 9
#ifdef SIOCSDEFIFACE_IN6	/* XXX: check SIOCGDEFIFACE_IN6 as well? */
			if (argc > 2)
				setdefif(argv[2]);
			getdefif(); /* always call it to print the result */
			exit(0);
#else
			errx(1, "not supported yet");
			/*NOTREACHED*/
#endif
d200 1
a200 3
			argc -= optind;
			argv += optind;
			if (argc < 1)
d202 5
a206 2
			ifinfo(argc, argv);
			exit(0);
a208 17
			continue;
		case 'p':
			pflag = 1;
			break;
		case 'f' :
			if (argc != 3)
				usage();
			file(argv[2]);
			exit(0);
		case 'l' :
			/* obsolete, ignored */
			break;
		case 'r' :
			rflag = 1;
			break;
		case 's':
			sflag = 1;
d214 5
a218 1
			aflag = 1;
d220 1
a220 1
			if (repeat < 0)
d222 2
a223 9
			break;
		case 'H' :
			Hflag = 1;
			break;
		case 'P':
			Pflag = 1;
			break;
		case 'R':
			Rflag = 1;
d232 32
a263 6
	if (aflag || cflag) {
		dump(0);
		exit(0);
	}
	if (dflag) {
		if (argc != 1)
d265 2
a266 4
		delete(argv[0]);
		exit(0);
	}
	if (pflag) {
d268 9
a276 3
		exit(0);
	}
	if (rflag) {
d278 2
a279 3
		exit(0);
	}
	if (sflag) {
d283 5
a287 2
	}
	if (Hflag) {
d289 6
a294 3
		exit(0);
	}
	if (Pflag) {
d296 6
a301 3
		exit(0);
	}
	if (Rflag) {
d303 8
a310 1
		exit(0);
a311 4

	if (argc != 1)
		usage();
	get(argv[0]);
d432 6
a437 4
		    !(rtm->rtm_flags & RTF_GATEWAY)) switch (sdl->sdl_type) {
		case IFT_ETHER: case IFT_FDDI: case IFT_ISO88023:
		case IFT_ISO88024: case IFT_ISO88025:
			goto overwrite;
d483 1
a483 1
	dump(&sin->sin6_addr);
d575 1
a575 1
dump(addr)
d577 1
d596 1
a596 1
		printf("%-*.*s %-*.*s %*.*s %-9.9s %1s %4s\n",
d598 1
a598 1
		    W_IF, W_IF, "Netif", "Expire", "S", "Flgs");
d661 2
a662 3
			    sizeof(host_buf), NULL, 0,
			    (nflag ? NI_NUMERICHOST : 0));
		if (cflag == 1) {
d845 1
a845 1
	printf("       ndp -a[nt]\n");
d847 3
a849 3
	printf("       ndp -c[nt]\n");
	printf("       ndp -d[nt] hostname\n");
	printf("       ndp -f[nt] filename\n");
d852 2
a853 1
	printf("       ndp -I [interface|delete]\n");
d930 2
a931 1
ifinfo(argc, argv)
a936 1
	char *ifname = argv[0];
d954 1
a954 1
	for (i = 1; i < argc; i++) {
@


1.19
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.18 2002/05/29 22:22:20 itojun Exp $	*/
d139 1
a139 1
static struct in6_nbrinfo *getnbrinfo(struct in6_addr *addr, int ifindex, int);
d155 2
a156 2
static char *sec2str(time_t t);
static char *ether_str(struct sockaddr_dl *sdl);
@


1.18
log
@sync more with kame.  sockaddr_dl printing
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.17 2002/05/29 18:40:21 deraadt Exp $	*/
d174 2
a175 2
	int aflag = 0, dflag = 0, sflag = 0, Hflag = 0,
		pflag = 0, rflag = 0, Pflag = 0, Rflag = 0;
d385 1
a385 1
			htons(((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id);
d395 1
d450 1
a450 1
			gai_strerror(gai_error));
d457 1
a457 1
			htons(((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id);
d463 2
a464 2
			    sizeof(host_buf), NULL ,0,
			    (nflag ? NI_NUMERICHOST : 0));
d491 1
a491 1
			gai_strerror(gai_error));
d498 1
a498 1
			htons(((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id);
d535 3
a537 3
			    s6.sin6_len, host_buf,
			    sizeof(host_buf), NULL, 0,
			    (nflag ? NI_NUMERICHOST : 0));
d676 1
a676 1
				       sec2str(nbi->expire - time.tv_sec));
d682 1
a682 1
			switch(nbi->state) {
d723 2
a724 2
				isrouter ? "R" : "",
				(rtm->rtm_flags & RTF_ANNOUNCE) ? "p" : "");
d727 1
a727 1
				(sdl->sdl_len + (char *)sdl);
d730 4
a733 6
				isrouter ? "R" : "",
				!IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr)
					? "P" : "",
				(sin->sin6_len != sizeof(struct sockaddr_in6))
					? "W" : "",
				(rtm->rtm_flags & RTF_ANNOUNCE) ? "p" : "");
d736 2
a737 2
				isrouter ? "R" : "",
				(rtm->rtm_flags & RTF_ANNOUNCE) ? "p" : "");
d793 1
a793 1
			cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
d808 1
a808 1
					   &o[3], &o[4], &o[5]);
d925 1
a925 1
 		err(1, "ioctl(SIOCGIFINFO_IN6)");
d927 1
a927 1
 	}
d972 1
a972 1
	       ND.basereachable / 1000, ND.basereachable % 1000);
d982 1
a982 1
			switch(i) {
d1016 1
a1016 1
	
d1056 1
a1056 1
		
d1058 1
a1058 1
		       if_indextoname(p->if_index, ifix_buf));
d1060 2
a1061 2
		       p->flags & ND_RA_FLAG_MANAGED ? "M" : "",
		       p->flags & ND_RA_FLAG_OTHER   ? "O" : "");
d1064 1
a1064 1
		
d1070 1
a1070 1
				sec2str(p->expire - time.tv_sec));
d1085 1
a1085 1
 		err(1, "ioctl(SIOCGDRLST_IN6)");
d1087 1
a1087 1
 	}
d1097 3
a1099 3
			    sizeof(host_buf), NULL, 0,
			    (nflag ? NI_NUMERICHOST : 0));
		
d1101 1
a1101 1
		       if_indextoname(DR.if_index, ifix_buf));
d1103 2
a1104 2
		       DR.flags & ND_RA_FLAG_MANAGED ? "M" : "",
		       DR.flags & ND_RA_FLAG_OTHER   ? "O" : "");
d1110 1
a1110 1
				sec2str(DR.expire - time.tv_sec));
d1155 1
a1155 1
		       if_indextoname(p->if_index, ifix_buf));
d1163 4
a1166 4
		       p->raflags.onlink ? "L" : "",
		       p->raflags.autonomous ? "A" : "",
		       (p->flags & NDPRF_ONLINK) != 0 ? "O" : "",
		       (p->flags & NDPRF_DETACHED) != 0 ? "D" : "",
d1168 1
a1168 1
		       (p->flags & NDPRF_HOME) != 0 ? "H" : ""
d1170 1
a1170 1
		       ""
d1172 1
a1172 1
		       );
d1185 1
a1185 1
				sec2str(p->expire - time.tv_sec));
d1209 2
a1210 2
				nbi = getnbrinfo(&sin6->sin6_addr, p->if_index,
						 0);
d1212 1
a1212 1
					switch(nbi->state) {
d1244 1
a1244 1
 		err(1, "ioctl(SIOCGPRLST_IN6)");
d1246 1
a1246 1
 	}
d1270 1
a1270 1
			       sizeof(linkid));
d1279 2
a1280 2
				sizeof(p6), namebuf, sizeof(namebuf),
				NULL, 0, niflags)) {
d1285 1
a1285 1
		       if_indextoname(PR.if_index, ifix_buf));
d1294 1
a1294 1
		       PR.origin == PR_ORIG_RA ? "" : "advertise: ");
d1298 4
a1301 4
		       PR.raflags.onlink ? "L" : "",
		       PR.raflags.autonomous ? "A" : "",
		       (PR.flags & NDPRF_ONLINK) != 0 ? "O" : "",
		       (PR.flags & NDPRF_DETACHED) != 0 ? "D" : "",
d1303 1
a1303 1
		       (PR.flags & NDPRF_HOME) != 0 ? "H" : ""
d1305 1
a1305 1
		       ""
d1307 1
a1307 1
		       );
d1310 2
a1311 2
		       PR.raflags.onlink ? "L" : "",
		       PR.raflags.autonomous ? "A" : "");
d1325 1
a1325 1
				sec2str(PR.expire - time.tv_sec));
d1371 3
a1373 3
					    sin6.sin6_len, host_buf,
					    sizeof(host_buf), NULL, 0,
					    (nflag ? NI_NUMERICHOST : 0));
d1376 2
a1377 2
				nbi = getnbrinfo(&sin6.sin6_addr, PR.if_index,
						 0);
d1379 5
a1383 5
					switch(nbi->state) {
					 case ND6_LLINFO_REACHABLE:
					 case ND6_LLINFO_STALE:
					 case ND6_LLINFO_DELAY:
					 case ND6_LLINFO_PROBE:
d1386 1
a1386 1
					 default:
d1394 1
a1394 1
				       PR.advrtrs - DRLSTSIZ);
d1413 1
a1413 1
 		err(1, "ioctl(SIOCSPFXFLUSH_IN6)");
d1426 1
a1426 1
 		err(1, "ioctl(SIOCSRTRFLUSH_IN6)");
d1441 1
a1441 1
 		err(1, "ioctl(SIOCSNDFLUSH_IN6)");
d1468 1
a1468 1
 		err(1, "ioctl(SIOCSDEFIFACE_IN6)");
d1486 1
a1486 1
 		err(1, "ioctl(SIOCGDEFIFACE_IN6)");
@


1.17
log
@even more strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.16 2002/05/29 08:05:39 itojun Exp $	*/
a89 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#include <net/if_var.h>
#endif /* __FreeBSD__ >= 3 */
a94 3
#ifndef __NetBSD__
#include <netinet/if_ether.h>
#endif
d788 1
a788 1
	static char ebuf[32];
d793 1
a793 1
		snprintf(ebuf, sizeof(ebuf), "%x:%x:%x:%x:%x:%x",
d795 2
a796 3
	} else {
		snprintf(ebuf, sizeof(ebuf), "(incomplete)");
	}
d798 1
a798 1
	return(ebuf);
@


1.16
log
@use new SIOCGIFINFO_IN6.  random other cleanups.  sync w/kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.15 2002/05/26 01:21:12 deraadt Exp $	*/
d931 1
a931 1
	strncpy(nd.ifname, ifname, sizeof(nd.ifname));
d1091 1
a1091 1
	strcpy(dr.ifname, "lo0"); /* dummy */
d1250 1
a1250 1
	strcpy(pr.ifname, "lo0"); /* dummy */
d1419 1
a1419 1
	strcpy(dummyif, "lo0"); /* dummy */
d1432 1
a1432 1
	strcpy(dummyif, "lo0"); /* dummy */
d1447 1
a1447 1
	strcpy(dummyif, "lo0"); /* dummy */
d1472 1
a1472 1
	strcpy(ndifreq.ifname, "lo0"); /* dummy */
d1491 1
a1491 1
	strcpy(ndifreq.ifname, "lo0"); /* dummy */
@


1.15
log
@pid_t cleanup; itojun ok
@
text
@d1 2
a2 2
/*	$OpenBSD: ndp.c,v 1.14 2002/02/17 19:42:38 millert Exp $	*/
/*	$KAME: ndp.c,v 1.69 2001/07/23 14:46:31 itojun Exp $	*/
a120 4
#ifndef NI_WITHSCOPEID
#define NI_WITHSCOPEID	0
#endif

d469 1
a469 1
			    NI_WITHSCOPEID | (nflag ? NI_NUMERICHOST : 0));
d542 1
a542 1
			    NI_WITHSCOPEID | (nflag ? NI_NUMERICHOST : 0));
d549 1
a549 1
#define W_ADDR	31
d577 1
a577 1
		printf("%-*.*s %-*.*s %*.*s %-9.9s %2s %4s %4s\n",
d579 1
a579 1
		    W_IF, W_IF, "Netif", "Expire", "St", "Flgs", "Prbs");
d622 3
d643 1
a643 1
			    NI_WITHSCOPEID | (nflag ? NI_NUMERICHOST : 0));
d645 7
d653 1
d688 1
a688 1
			 case ND6_LLINFO_NOSTATE:
d692 1
a692 1
			 case ND6_LLINFO_WAITDELETE:
d696 1
a696 1
			 case ND6_LLINFO_INCOMPLETE:
d699 1
a699 1
			 case ND6_LLINFO_REACHABLE:
d702 1
a702 1
			 case ND6_LLINFO_STALE:
d705 1
a705 1
			 case ND6_LLINFO_DELAY:
d708 1
a708 1
			 case ND6_LLINFO_PROBE:
d711 1
a711 1
			 default:
a721 1
		putchar(' ');
d733 1
d741 5
d747 1
a747 1
		printf(" %-4.4s", flgbuf);
d750 1
a750 1
			printf(" %4d", prbs);
d799 1
a799 1
		sprintf(ebuf, "%x:%x:%x:%x:%x:%x",
d802 1
a802 1
		sprintf(ebuf, "(incomplete)");
d871 4
a874 2
		rtm->rtm_rmx.rmx_expire = expire_time;
		rtm->rtm_inits = RTV_EXPIRE;
d957 6
d972 1
a972 1
	if (!ND.linkmtu) {
d1011 1
a1011 1
		if ((ND.flags & ND6_IFF_PERFORMNUD) != 0)
d1013 8
d1062 1
a1062 1
		    NI_WITHSCOPEID | (nflag ? NI_NUMERICHOST : 0)) != 0)
d1106 1
a1106 1
			    NI_WITHSCOPEID | (nflag ? NI_NUMERICHOST : 0));
a1134 4
#ifdef NI_WITHSCOPEID
	const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
	int ninflags = (nflag ? NI_NUMERICHOST : 0) | NI_WITHSCOPEID;
#else
a1136 1
#endif
d1184 1
a1184 1
			printf(" vltime=%ld", (long)p->vltime);
d1188 1
a1188 1
			printf(", pltime=%ld", (long)p->pltime);
d1206 1
a1206 1
			sin6 = (struct sockaddr_in6 *)(p + 1);
a1285 3
#ifdef __KAME__
		niflags |= NI_WITHSCOPEID;
#endif
d1324 1
a1324 1
			printf(" vltime=%ld", (long)PR.vltime);
d1328 1
a1328 1
			printf(", pltime=%ld", (long)PR.pltime);
d1381 1
a1381 1
					    NI_WITHSCOPEID | (nflag ? NI_NUMERICHOST : 0));
d1517 2
d1527 4
a1530 1
		p += sprintf(p, "%dd", days);
d1534 4
a1537 1
		p += sprintf(p, "%dh", hours);
d1541 4
a1544 1
		p += sprintf(p, "%dm", mins);
d1546 1
a1546 1
	sprintf(p, "%ds", secs);
@


1.14
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.13 2002/02/16 21:28:06 millert Exp $	*/
d130 1
a130 1
static int pid;
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.12 2001/11/08 09:52:02 itojun Exp $	*/
d149 1
a149 2
static struct in6_nbrinfo *getnbrinfo __P((struct in6_addr *addr,
					   int ifindex, int));
@


1.12
log
@use strncpy() to set ifname arg to ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.11 2001/07/23 18:42:32 itojun Exp $	*/
d142 7
a148 7
int main __P((int, char **));
int file __P((char *));
void getsocket __P((void));
int set __P((int, char **));
void get __P((char *));
int delete __P((char *));
void dump __P((struct in6_addr *));
d151 11
a161 11
static char *ether_str __P((struct sockaddr_dl *));
int ndp_ether_aton __P((char *, u_char *));
void usage __P((void));
int rtmsg __P((int));
void ifinfo __P((int, char **));
void rtrlist __P((void));
void plist __P((void));
void pfx_flush __P((void));
void rtrlist __P((void));
void rtr_flush __P((void));
void harmonize_rtr __P((void));
d163 2
a164 2
static void getdefif __P((void));
static void setdefif __P((char *));
d166 3
a168 3
static char *sec2str __P((time_t t));
static char *ether_str __P((struct sockaddr_dl *sdl));
static void ts_print __P((const struct timeval *));
@


1.11
log
@sync with latest kame.  do not print yet-to-be-initialized interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.10 2001/03/21 15:32:27 itojun Exp $	*/
d918 1
a918 1
	strcpy(nd.ifname, ifname);
@


1.10
log
@do not dereference null pointer.  from kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ndp.c,v 1.9 2001/02/08 08:35:17 itojun Exp $	*/
/*	$KAME: ndp.c,v 1.62 2001/03/21 15:26:32 itojun Exp $	*/
d118 1
d170 9
d190 1
a190 1
	while ((ch = getopt(argc, argv, "acndfIilprstA:HPR")) != EOF)
d347 2
a348 2
			perror("ndp: socket");
			exit(1);
d413 2
a414 2
		perror(host);
		return (1);
d512 2
a513 2
		perror(host);
		return (1);
d610 17
d887 2
a888 2
			perror("writing to routing socket");
			return (-1);
d914 2
a915 2
		perror("ndp: socket");
		exit(1);
d920 2
a921 2
 		perror("ioctl (SIOCGIFINFO_IN6)");
 		exit(1);
d947 2
a948 2
			perror("ioctl(SIOCSIFINFO_FLAGS)");
			exit(1);
d953 5
d1001 4
d1008 47
d1060 2
a1061 2
		perror("ndp: socket");
		exit(1);
d1066 2
a1067 2
 		perror("ioctl (SIOCGDRLST_IN6)");
 		exit(1);
d1070 1
a1070 1
	for (i = 0 ; DR.if_index && i < PRLSTSIZ ; i++) {
d1095 1
d1101 116
d1224 2
a1225 2
		perror("ndp: socket");
		exit(1);
d1230 2
a1231 2
 		perror("ioctl (SIOCGPRLST_IN6)");
 		exit(1);
d1281 4
a1284 1
		printf("  %s", PR.origin == PR_ORIG_RA ? "" : "advertise: ");
d1286 1
a1286 1
		printf("flags=%s%s%s%s",
d1290 7
a1296 1
		       (PR.flags & NDPRF_DETACHED) != 0 ? "D" : "");
d1320 1
d1338 1
d1344 2
a1345 1
		if (PR.origin != PR_ORIG_RA)
d1389 1
d1430 1
a1430 1
 		err(1, "ioctl (SIOCSNDFLUSH_IN6)");
d1457 1
a1457 1
 		err(1, "ioctl (SIOCSDEFIFACE_IN6)");
d1475 1
a1475 1
 		err(1, "ioctl (SIOCGDEFIFACE_IN6)");
@


1.9
log
@pull latest kame tree.  ndp -n -a printing is now prettier with long
IPv6 addresses.  -l is deprecated (ignored).
@
text
@d1 2
a2 2
/*	$OpenBSD: ndp.c,v 1.8 2001/01/21 07:51:38 itojun Exp $	*/
/*	$KAME: ndp.c,v 1.56 2001/02/08 07:36:45 itojun Exp $	*/
d568 1
d633 4
a636 2
		ifwidth = strlen(if_indextoname(sdl->sdl_index,
		    ifix_buf));
d641 1
a641 2
		    llwidth, llwidth, ether_str(sdl), ifwidth, ifwidth,
		    if_indextoname(sdl->sdl_index, ifix_buf));
@


1.8
log
@avoid memory leak.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ndp.c,v 1.7 2000/10/09 22:10:05 itojun Exp $	*/
/*	$KAME: ndp.c,v 1.49 2001/01/20 23:45:44 sumikawa Exp $	*/
a135 1
static int lflag = 0;
d220 1
a220 1
			lflag = 1;
d511 1
a511 5
			switch (sdl->sdl_type) {
			case IFT_ETHER: case IFT_FDDI: case IFT_ISO88023:
			case IFT_ISO88024: case IFT_ISO88025:
				goto delete;
			}
d544 4
d565 2
d571 3
a573 3
		printf("%-31.31s %-17.17s %6.6s %-9.9s %2s %4s %4s\n",
		       "Neighbor", "Linklayer Address", "Netif", "Expire",
		       "St", "Flgs", "Prbs");
d626 14
a639 10
		if (lflag) {
			addrwidth = strlen(host_buf);
			if (addrwidth < 31)
				addrwidth = 31;
		} else
			addrwidth = 31;

		printf("%-*.*s %-17.17s %6.6s", addrwidth, addrwidth, host_buf,
		       ether_str(sdl),
		       if_indextoname(sdl->sdl_index, ifix_buf));
d790 2
a791 2
	printf("       ndp -a[ntl]\n");
	printf("       ndp [-ntl] -A wait\n");
d880 3
d930 26
d1033 39
a1071 3
		printf("%s/%d if=%s\n",
		       inet_ntop(AF_INET6, &PR.prefix, ntop_buf,
				 sizeof(ntop_buf)), PR.prefixlen,
d1073 1
d1080 7
d1090 1
d1106 3
@


1.7
log
@fix ndp -c (flush link-locals properly)
sync with latest kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: ndp.c,v 1.6 2000/06/20 21:53:43 itojun Exp $	*/
/*	$KAME: ndp.c,v 1.48 2000/10/09 22:08:21 itojun Exp $	*/
d709 2
@


1.6
log
@sync with latest kame ndp(8).
accept scoped address notation.
avoid infinite loop in certain routing table setup.
@
text
@d1 2
a2 2
/*	$OpenBSD: ndp.c,v 1.5 2000/04/17 04:44:51 itojun Exp $	*/
/*	$KAME: ndp.c,v 1.40 2000/06/20 21:50:17 itojun Exp $	*/
d87 1
d130 1
a130 1
static int fflag;
d176 1
a176 1
	int aflag = 0, cflag = 0, dflag = 0, sflag = 0, Hflag = 0,
a186 1
			fflag = 1;
d531 12
a542 4
	       getnameinfo((struct sockaddr *)sin,
			   sin->sin6_len, host_buf,
			   sizeof(host_buf), NULL, 0,
			   NI_WITHSCOPEID | (nflag ? NI_NUMERICHOST : 0));
d569 1
a569 1
	if (!tflag)
a603 6
		if (fflag == 1) {
			delete((char *)inet_ntop(AF_INET6, &sin->sin6_addr,
						 ntop_buf, sizeof(ntop_buf)));
			continue;
		}

d609 2
a610 2

			/* XXX: KAME specific hack; removed the embedded id */
d612 1
d617 4
d642 1
a642 2
			}
			else if (nbi->expire == 0)
d651 1
d655 1
d678 1
a678 2
		}
		else {
d754 1
a754 2
	}
	else {
d1080 1
a1080 2
				}
				else
@


1.5
log
@revisit in6_ifattach().  (1) make it more persistent about initializaing an
interface (2) cleanup interface id selection.
run NUD on p2p interface (required by spec for bidir p2p interface).
add "ndp -i interface" (can tweak per-interface ND flag).
(sync with more recent kame)
@
text
@d1 2
a2 1
/*	$OpenBSD: ndp.c,v 1.4 2000/02/28 11:56:41 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d158 1
a176 2
	extern char *optarg;
	extern int optind;
d262 1
d384 6
a402 1
tryagain:
d417 5
a421 1
		goto tryagain;
d423 1
d455 6
d496 6
a501 1
/*tryagain:*/
d518 5
a523 1
	return 0;
d531 1
a531 1
	       getnameinfo((struct sockaddr *)sin, 
d1072 1
a1072 1
						 printf(" (unreachable)\n"); 
d1146 1
a1146 1
	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) 
d1164 1
a1164 1
	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) 
@


1.4
log
@bring in latest kame code.
- ndp -I (set default outgoing interface when no default router is defined)
- ndp -s proxy (proxy NDP)
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.3 2000/02/01 03:24:05 deraadt Exp $	*/
d153 1
a153 1
void ifinfo __P((char *));
d203 3
a205 1
			if (argc != 3)
d207 1
a207 1
			ifinfo(argv[2]);
d489 6
a494 4
		    !(rtm->rtm_flags & RTF_GATEWAY)) switch (sdl->sdl_type) {
		case IFT_ETHER: case IFT_FDDI: case IFT_ISO88023:
		case IFT_ISO88024: case IFT_ISO88025:
			goto delete;
d497 2
d701 1
a701 1
			warn("ioctl");
d756 1
a756 1
	printf("       ndp -i interface\n");
d833 3
a835 2
ifinfo(ifname)
	char *ifname;
d838 3
a840 1
	int s;
d853 29
d887 7
a893 1
	printf(", retrans=%ds%dms\n", ND.retrans / 1000, ND.retrans % 1000);
d895 1
@


1.3
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: ndp.c,v 1.2 1999/12/10 07:26:56 itojun Exp $	*/
d159 2
a160 1
#ifdef SIOCSDEFIFACE_IN6
d180 1
a180 1
	while ((ch = getopt(argc, argv, "acndfI:ilprstA:HPR")) != EOF)
d193 4
a196 2
#ifdef SIOCSDEFIFACE_IN6
			setdefif(optarg);
d341 1
a341 1
struct	sockaddr_in so_mask = {8, 0, 0, { 0xffffffff}};
d390 2
a391 1
		}
d649 3
a651 2
			snprintf(flgbuf, sizeof(flgbuf), "%s",
				isrouter ? "R" : "");
d655 1
a655 1
			snprintf(flgbuf, sizeof(flgbuf), "%s%s%s",
d660 2
a661 1
					? "W" : "");
d752 1
a752 1
	printf("       ndp -I interface\n");
d756 1
a756 1
	printf("       ndp -s hostname ether_addr [temp]\n");
d789 4
d803 1
d925 6
a930 1
		printf("  flags=%s%s",
d942 1
a942 1
			printf(", expire=Never\n");
d944 1
a944 1
			printf(", expire=%s\n",
d947 26
a972 2
			printf(", expired\n");
		if (PR.advrtrs) {
d1010 1
a1010 2
		}
		else
d1052 1
a1052 1
		err(1, "ndp: socket");
d1060 1
a1060 1
#ifdef SIOCSDEFIFACE_IN6
d1065 9
a1073 1
	int s;
d1076 4
a1079 1
		err(1, "ndp: socket");
d1081 1
a1081 1
	if (ioctl(s, SIOCSDEFIFACE_IN6, (caddr_t)ifname) < 0)
d1083 27
@


1.2
log
@add ndp(8), arp(8) lookalike for IPv6.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a126 1
extern int errno;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@arp(8) lookalike for IPv6, from KAME
@
text
@@
