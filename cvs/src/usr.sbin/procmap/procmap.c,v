head	1.63;
access;
symbols
	OPENBSD_6_0:1.62.0.2
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.59.0.4
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.59.0.6
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.42.0.2
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.41.0.2
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.34.0.6
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.4
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15;
locks; strict;
comment	@ * @;


1.63
date	2016.09.16.04.45.35;	author dlg;	state Exp;
branches;
next	1.62;
commitid	dGgXkqY8OAYTt6kH;

1.62
date	2016.05.26.17.23.50;	author stefan;	state Exp;
branches;
next	1.61;
commitid	6osrOkBoR3FQWrVC;

1.61
date	2016.05.25.15.45.53;	author stefan;	state Exp;
branches;
next	1.60;
commitid	lZK4lmYTclPZqGs5;

1.60
date	2016.04.16.18.39.30;	author stefan;	state Exp;
branches;
next	1.59;
commitid	4OGLhCEcSCff5pGJ;

1.59
date	2015.01.19.19.25.28;	author kettenis;	state Exp;
branches;
next	1.58;
commitid	00Lqd14aSKQxTn1X;

1.58
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	Uu5nFG3wCl0LACBb;

1.57
date	2014.11.16.12.31.01;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	yv0ECmCdICvq576h;

1.56
date	2014.09.08.01.47.06;	author guenther;	state Exp;
branches;
next	1.55;
commitid	QKTb36RFnfteZJPE;

1.55
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	EF98ch02VpFassUi;

1.54
date	2014.07.08.10.15.16;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	dQRX8Da8mglLMcxE;

1.53
date	2014.05.20.01.25.24;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2014.02.13.21.17.13;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2014.02.13.21.07.42;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2013.08.12.05.41.01;	author otto;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.14.20.18.52;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.24.14.29.00;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.21.00.40.08;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.26.08.58.00;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.23.10.46.04;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.20.15.24.17;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2013.03.20.14.53.35;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.16.00.13.23;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2012.03.09.13.02.45;	author ariane;	state Exp;
branches;
next	1.40;

1.40
date	2011.06.06.17.18.26;	author ariane;	state Exp;
branches;
next	1.39;

1.39
date	2011.05.24.15.27.36;	author ariane;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.23.01.01.34;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.10.03.20.59;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.05.18.51.26;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.12.20.13.12;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.12.16.42.24;	author beck;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.04.22.38.53;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.18.08.02.53;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.18.07.50.39;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.09.20.30.25;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.02.14.50.49;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.02.15.19.40;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.31.18.22.25;	author thib;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.26.04.59.39;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.01.22.02.02;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.06.20.18.57;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.24.12.08.17;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.26.05.22.15;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.03.03.41.11;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.25.16.54.17;	author jaredy;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.09.19.30.52;	author tdeval;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.01.23.17.11;	author tdeval;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.15.09.13.10;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.23.21.01.22;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.23.20.53.21;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.23.19.48.40;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.23.04.34.31;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.23.03.21.23;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.19.08.22.34;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.18.04.32.17;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.18.04.07.35;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.18.03.58.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.18.03.27.22;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.18.00.46.25;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.17.20.13.53;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.16.08.57.58;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.16.08.54.34;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.63
log
@procmap fumbles with uvm_map_addr structures, which are now in RBTs

it also does proper traversal of the tree (ie, it does FOREACH)
which in turn uses MIN and NEXT operations to iterate over the whole
tree. theyre complicated and need code.

so for now this pulls in subr_tree.c from the kernel and builds it
as part of procmap. that allows for traversal of the RBT using the
same code that the kernel uses.

it is a bit ugly though because procmap updates the pointers between
items in the tree so they point at local copies instead of kernel
addresses. its made worse because RBT code has pointers between
rb_entry structs, not between the nodes.

im putting this in now to unbreak the tree. it can be polished after
coffee/naps.
@
text
@/*	$OpenBSD: procmap.c,v 1.62 2016/05/26 17:23:50 stefan Exp $ */
/*	$NetBSD: pmap.c,v 1.1 2002/09/01 20:32:44 atatat Exp $ */

/*
 * Copyright (c) 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andrew Brown.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define _KERNEL
#include <sys/tree.h>
#undef _KERNEL

#include <sys/param.h>	/* MAXCOMLEN */
#include <sys/types.h>
#include <sys/time.h>
#include <sys/exec.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/uio.h>
#include <sys/namei.h>
#include <sys/sysctl.h>

/* XXX until uvm gets cleaned up */
typedef int boolean_t;

#include <uvm/uvm.h>
#include <uvm/uvm_device.h>
#include <uvm/uvm_amap.h>
#include <uvm/uvm_vnode.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#undef doff_t
#undef IN_ACCESS
#undef i_size
#undef i_devvp
#include <isofs/cd9660/iso.h>
#include <isofs/cd9660/cd9660_node.h>

#include <kvm.h>
#include <fcntl.h>
#include <errno.h>
#include <err.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>

/*
 * stolen (and munged) from #include <uvm/uvm_object.h>
 */
#define UVM_OBJ_IS_VNODE(uobj)	((uobj)->pgops == uvm_vnodeops)
#define UVM_OBJ_IS_AOBJ(uobj)	((uobj)->pgops == aobj_pager)
#define UVM_OBJ_IS_DEVICE(uobj)	((uobj)->pgops == uvm_deviceops)

#define PRINT_VMSPACE		0x00000001
#define PRINT_VM_MAP		0x00000002
#define PRINT_VM_MAP_HEADER	0x00000004
#define PRINT_VM_MAP_ENTRY	0x00000008
#define DUMP_NAMEI_CACHE	0x00000010

struct cache_entry {
	LIST_ENTRY(cache_entry) ce_next;
	struct vnode *ce_vp, *ce_pvp;
	u_long ce_cid, ce_pcid;
	unsigned int ce_nlen;
	char ce_name[256];
};

LIST_HEAD(cache_head, cache_entry) lcache;
TAILQ_HEAD(namecache_head, namecache) nclruhead;
int namecache_loaded;
void *uvm_vnodeops, *uvm_deviceops, *aobj_pager;
u_long kernel_map_addr, nclruhead_addr;
int debug, verbose;
int print_all, print_map, print_maps, print_solaris, print_ddb, print_amap;
int rwx = PROT_READ | PROT_WRITE | PROT_EXEC;
rlim_t maxssiz;

struct sum {
	unsigned long s_am_nslots;
	unsigned long s_am_nusedslots;
};

struct kbit {
	/*
	 * size of data chunk
	 */
	size_t k_size;

	/*
	 * something for printf() and something for kvm_read()
	 */
	union {
		void *k_addr_p;
		u_long k_addr_ul;
	} k_addr;

	/*
	 * where we actually put the "stuff"
	 */
	union {
		char data[1];
		struct vmspace vmspace;
		struct vm_map vm_map;
		struct vm_map_entry vm_map_entry;
		struct uvm_vnode uvm_vnode;
		struct vnode vnode;
		struct uvm_object uvm_object;
		struct mount mount;
		struct inode inode;
		struct iso_node iso_node;
		struct uvm_device uvm_device;
		struct vm_amap vm_amap;
	} k_data;
};

/* the size of the object in the kernel */
#define S(x)	((x)->k_size)
/* the address of the object in kernel, two forms */
#define A(x)	((x)->k_addr.k_addr_ul)
#define P(x)	((x)->k_addr.k_addr_p)
/* the data from the kernel */
#define D(x,d)	(&((x)->k_data.d))

/* suck the data from the kernel */
#define _KDEREF(kd, addr, dst, sz) do { \
	ssize_t len; \
	len = kvm_read((kd), (addr), (dst), (sz)); \
	if (len != (sz)) \
		errx(1, "%s == %ld vs. %lu @@ %lx", \
		    kvm_geterr(kd), (long)len, (unsigned long)(sz), (addr)); \
} while (0/*CONSTCOND*/)

/* suck the data using the structure */
#define KDEREF(kd, item) _KDEREF((kd), A(item), D(item, data), S(item))

struct nlist nl[] = {
	{ "_maxsmap" },
#define NL_MAXSSIZ		0
	{ "_uvm_vnodeops" },
#define NL_UVM_VNODEOPS		1
	{ "_uvm_deviceops" },
#define NL_UVM_DEVICEOPS	2
	{ "_aobj_pager" },
#define NL_AOBJ_PAGER		3
	{ "_kernel_map" },
#define NL_KERNEL_MAP		4
	{ "_nclruhead" },
#define NL_NCLRUHEAD		5
	{ NULL }
};

void load_symbols(kvm_t *);
void process_map(kvm_t *, pid_t, struct kinfo_proc *, struct sum *);
struct vm_map_entry *load_vm_map_entries(kvm_t *, struct vm_map_entry *,
    struct vm_map_entry *);
void unload_vm_map_entries(struct vm_map_entry *);
size_t dump_vm_map_entry(kvm_t *, struct kbit *, struct vm_map_entry *,
    struct sum *);
char *findname(kvm_t *, struct kbit *, struct vm_map_entry *, struct kbit *,
    struct kbit *, struct kbit *);
int search_cache(kvm_t *, struct kbit *, char **, char *, size_t);
void load_name_cache(kvm_t *);
void cache_enter(struct namecache *);
static void __dead usage(void);
static pid_t strtopid(const char *);
void print_sum(struct sum *, struct sum *);

/*
 * uvm_map address tree implementation.
 */
static int no_impl(const void *, const void *);
static int
no_impl(const void *p, const void *q)
{
	errx(1, "uvm_map address comparison not implemented");
	return 0;
}

RBT_PROTOTYPE(uvm_map_addr, vm_map_entry, daddrs.addr_entry, no_impl);
RBT_GENERATE(uvm_map_addr, vm_map_entry, daddrs.addr_entry, no_impl);

int
main(int argc, char *argv[])
{
	const char *errstr;
	char errbuf[_POSIX2_LINE_MAX], *kmem = NULL, *kernel = NULL;
	struct kinfo_proc *kproc;
	struct sum total_sum;
	int many, ch, rc;
	kvm_t *kd;
	pid_t pid = -1;
	gid_t gid;

	while ((ch = getopt(argc, argv, "AaD:dlmM:N:p:Prsvx")) != -1) {
		switch (ch) {
		case 'A':
			print_amap = 1;
			break;
		case 'a':
			print_all = 1;
			break;
		case 'd':
			print_ddb = 1;
			break;
		case 'D':
			debug = strtonum(optarg, 0, 0x1f, &errstr);
			if (errstr)
				errx(1, "invalid debug mask");
			break;
		case 'l':
			print_maps = 1;
			break;
		case 'm':
			print_map = 1;
			break;
		case 'M':
			kmem = optarg;
			break;
		case 'N':
			kernel = optarg;
			break;
		case 'p':
			pid = strtopid(optarg);
			break;
		case 'P':
			pid = getpid();
			break;
		case 's':
			print_solaris = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		case 'r':
		case 'x':
			errx(1, "-%c option not implemented, sorry", ch);
			/*NOTREACHED*/
		default:
			usage();
		}
	}

	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	gid = getgid();
	if (kernel != NULL || kmem != NULL)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

	argc -= optind;
	argv += optind;

	/* more than one "process" to dump? */
	many = (argc > 1 - (pid == -1 ? 0 : 1)) ? 1 : 0;

	/* apply default */
	if (print_all + print_map + print_maps + print_solaris +
	    print_ddb == 0)
		print_solaris = 1;

	/* start by opening libkvm */
	kd = kvm_openfiles(kernel, kmem, NULL, O_RDONLY, errbuf);

	if (kernel == NULL && kmem == NULL)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

	if (kd == NULL)
		errx(1, "%s", errbuf);

	/* get "bootstrap" addresses from kernel */
	load_symbols(kd);

	memset(&total_sum, 0, sizeof(total_sum));

	do {
		struct sum sum;

		memset(&sum, 0, sizeof(sum));

		if (pid == -1) {
			if (argc == 0)
				pid = getppid();
			else {
				pid = strtopid(argv[0]);
				argv++;
				argc--;
			}
		}

		/* find the process id */
		if (pid == 0)
			kproc = NULL;
		else {
			kproc = kvm_getprocs(kd, KERN_PROC_PID, pid,
			    sizeof(struct kinfo_proc), &rc);
			if (kproc == NULL || rc == 0) {
				warnc(ESRCH, "%d", pid);
				pid = -1;
				continue;
			}
		}

		/* dump it */
		if (many) {
			if (kproc)
				printf("process %d:\n", pid);
			else
				printf("kernel:\n");
		}

		process_map(kd, pid, kproc, &sum);
		if (print_amap)
			print_sum(&sum, &total_sum);
		pid = -1;
	} while (argc > 0);

	if (print_amap)
		print_sum(&total_sum, NULL);

	/* done.  go away. */
	rc = kvm_close(kd);
	if (rc == -1)
		err(1, "kvm_close");

	return (0);
}

void
print_sum(struct sum *sum, struct sum *total_sum)
{
	const char *t = total_sum == NULL ? "total " : "";
	printf("%samap mapped slots: %lu\n", t, sum->s_am_nslots);
	printf("%samap used slots: %lu\n", t, sum->s_am_nusedslots);

	if (total_sum) {
		total_sum->s_am_nslots += sum->s_am_nslots;
		total_sum->s_am_nusedslots += sum->s_am_nusedslots;
	}
}

void
process_map(kvm_t *kd, pid_t pid, struct kinfo_proc *proc, struct sum *sum)
{
	struct kbit kbit[3], *vmspace, *vm_map;
	struct vm_map_entry *vm_map_entry;
	size_t total = 0;
	char *thing;
	uid_t uid;
	int vmmap_flags;

	if ((uid = getuid())) {
		if (pid == 0) {
			warnx("kernel map is restricted");
			return;
		}
		if (uid != proc->p_uid) {
			warnx("other users' process maps are restricted");
			return;
		}
	}

	vmspace = &kbit[0];
	vm_map = &kbit[1];

	A(vmspace) = 0;
	A(vm_map) = 0;

	if (pid > 0) {
		A(vmspace) = (u_long)proc->p_vmspace;
		S(vmspace) = sizeof(struct vmspace);
		KDEREF(kd, vmspace);
		thing = "proc->p_vmspace.vm_map";
	} else {
		A(vmspace) = 0;
		S(vmspace) = 0;
		thing = "kernel_map";
	}

	if (pid > 0 && (debug & PRINT_VMSPACE)) {
		printf("proc->p_vmspace %p = {", P(vmspace));
		printf(" vm_refcnt = %d,", D(vmspace, vmspace)->vm_refcnt);
		printf(" vm_shm = %p,\n", D(vmspace, vmspace)->vm_shm);
		printf("    vm_rssize = %d,", D(vmspace, vmspace)->vm_rssize);
#if 0
		printf(" vm_swrss = %d,", D(vmspace, vmspace)->vm_swrss);
#endif
		printf(" vm_tsize = %d,", D(vmspace, vmspace)->vm_tsize);
		printf(" vm_dsize = %d,\n", D(vmspace, vmspace)->vm_dsize);
		printf("    vm_ssize = %d,", D(vmspace, vmspace)->vm_ssize);
		printf(" vm_taddr = %p,", D(vmspace, vmspace)->vm_taddr);
		printf(" vm_daddr = %p,\n", D(vmspace, vmspace)->vm_daddr);
		printf("    vm_maxsaddr = %p,",
		    D(vmspace, vmspace)->vm_maxsaddr);
		printf(" vm_minsaddr = %p }\n",
		    D(vmspace, vmspace)->vm_minsaddr);
	}

	S(vm_map) = sizeof(struct vm_map);
	if (pid > 0) {
		A(vm_map) = A(vmspace);
		memcpy(D(vm_map, vm_map), &D(vmspace, vmspace)->vm_map,
		    S(vm_map));
	} else {
		A(vm_map) = kernel_map_addr;
		KDEREF(kd, vm_map);
	}
	if (debug & PRINT_VM_MAP) {
		printf("%s %p = {", thing, P(vm_map));

		printf(" pmap = %p,\n", D(vm_map, vm_map)->pmap);
		printf("    lock = <struct lock>\n");
		printf("    size = %lx,", D(vm_map, vm_map)->size);
		printf(" ref_count = %d,", D(vm_map, vm_map)->ref_count);
		printf(" ref_lock = <struct simplelock>,\n");
		printf("    min_offset-max_offset = 0x%lx-0x%lx\n",
		    D(vm_map, vm_map)->min_offset,
		    D(vm_map, vm_map)->max_offset);
		printf("    b_start-b_end = 0x%lx-0x%lx\n",
		    D(vm_map, vm_map)->b_start,
		    D(vm_map, vm_map)->b_end);
		printf("    s_start-s_end = 0x%lx-0x%lx\n",
		    D(vm_map, vm_map)->s_start,
		    D(vm_map, vm_map)->s_end);
		vmmap_flags = D(vm_map, vm_map)->flags;
		printf("    flags = %x <%s%s%s%s%s%s >,\n",
		    vmmap_flags,
		    vmmap_flags & VM_MAP_PAGEABLE ? " PAGEABLE" : "",
		    vmmap_flags & VM_MAP_INTRSAFE ? " INTRSAFE" : "",
		    vmmap_flags & VM_MAP_WIREFUTURE ? " WIREFUTURE" : "",
		    vmmap_flags & VM_MAP_BUSY ? " BUSY" : "",
		    vmmap_flags & VM_MAP_WANTLOCK ? " WANTLOCK" : "",
#if VM_MAP_TOPDOWN > 0
		    vmmap_flags & VM_MAP_TOPDOWN ? " TOPDOWN" :
#endif
		    "");
		printf("    timestamp = %u }\n", D(vm_map, vm_map)->timestamp);
	}
	if (print_ddb) {
		printf("MAP %p: [0x%lx->0x%lx]\n", P(vm_map),
		    D(vm_map, vm_map)->min_offset,
		    D(vm_map, vm_map)->max_offset);
		printf("\tsz=%ld, ref=%d, version=%d, flags=0x%x\n",
		    D(vm_map, vm_map)->size,
		    D(vm_map, vm_map)->ref_count,
		    D(vm_map, vm_map)->timestamp,
		    D(vm_map, vm_map)->flags);
		printf("\tpmap=%p(resident=<unknown>)\n",
		    D(vm_map, vm_map)->pmap);
	}

	/* headers */
#ifdef DISABLED_HEADERS
	if (print_map)
		printf("%-*s %-*s rwx RWX CPY NCP I W A\n",
		    (int)sizeof(long) * 2 + 2, "Start",
		    (int)sizeof(long) * 2 + 2, "End");
	if (print_maps)
		printf("%-*s %-*s rwxp %-*s Dev   Inode      File\n",
		    (int)sizeof(long) * 2 + 0, "Start",
		    (int)sizeof(long) * 2 + 0, "End",
		    (int)sizeof(long) * 2 + 0, "Offset");
	if (print_solaris)
		printf("%-*s %*s Protection        File\n",
		    (int)sizeof(long) * 2 + 0, "Start",
		    (int)sizeof(int) * 2 - 1,  "Size ");
#endif
	if (print_all)
		printf("%-*s %-*s %*s %-*s rwxpc  RWX  I/W/A Dev  %*s - File\n",
		    (int)sizeof(long) * 2, "Start",
		    (int)sizeof(long) * 2, "End",
		    (int)sizeof(int)  * 2, "Size ",
		    (int)sizeof(long) * 2, "Offset",
		    (int)sizeof(int)  * 2, "Inode");

	/* these are the "sub entries" */
	vm_map_entry = load_vm_map_entries(kd,
	    RBT_ROOT(uvm_map_addr, &D(vm_map, vm_map)->addr), NULL);
	if (vm_map_entry != NULL) {
		/* RBTs point at rb_entries inside nodes */
		D(vm_map, vm_map)->addr.rbh_root.rbt_root =
		    &vm_map_entry->daddrs.addr_entry;
	} else
		RBT_INIT(uvm_map_addr, &D(vm_map, vm_map)->addr);

	RBT_FOREACH(vm_map_entry, uvm_map_addr, &D(vm_map, vm_map)->addr)
		total += dump_vm_map_entry(kd, vmspace, vm_map_entry, sum);
	unload_vm_map_entries(RBT_ROOT(uvm_map_addr, &D(vm_map, vm_map)->addr));

	if (print_solaris)
		printf("%-*s %8luK\n",
		    (int)sizeof(void *) * 2 - 2, " total",
		    (unsigned long)total);
	if (print_all)
		printf("%-*s %9luk\n",
		    (int)sizeof(void *) * 4 - 1, " total",
		    (unsigned long)total);
}

void
load_symbols(kvm_t *kd)
{
	int rc, i;

	rc = kvm_nlist(kd, &nl[0]);
	if (rc == -1)
		errx(1, "%s == %d", kvm_geterr(kd), rc);
	for (i = 0; i < sizeof(nl)/sizeof(nl[0]); i++)
		if (nl[i].n_value == 0 && nl[i].n_name)
			printf("%s not found\n", nl[i].n_name);

	uvm_vnodeops =	(void*)nl[NL_UVM_VNODEOPS].n_value;
	uvm_deviceops =	(void*)nl[NL_UVM_DEVICEOPS].n_value;
	aobj_pager =	(void*)nl[NL_AOBJ_PAGER].n_value;

	nclruhead_addr = nl[NL_NCLRUHEAD].n_value;

	_KDEREF(kd, nl[NL_MAXSSIZ].n_value, &maxssiz,
	    sizeof(maxssiz));
	_KDEREF(kd, nl[NL_KERNEL_MAP].n_value, &kernel_map_addr,
	    sizeof(kernel_map_addr));
}

/*
 * Recreate the addr tree of vm_map in local memory.
 */
struct vm_map_entry *
load_vm_map_entries(kvm_t *kd, struct vm_map_entry *kptr,
    struct vm_map_entry *parent)
{
	static struct kbit map_ent;
	struct vm_map_entry *result, *ld;

	if (kptr == NULL)
		return NULL;

	A(&map_ent) = (u_long)kptr;
	S(&map_ent) = sizeof(struct vm_map_entry);
	KDEREF(kd, &map_ent);

	result = malloc(sizeof(*result));
	if (result == NULL)
		err(1, "malloc");
	memcpy(result, D(&map_ent, vm_map_entry), sizeof(struct vm_map_entry));

	/*
	 * Recurse to download rest of the tree.
	 */

	/* RBTs point at rb_entries inside nodes */
	ld = load_vm_map_entries(kd, RBT_LEFT(uvm_map_addr, result), result);
	result->daddrs.addr_entry.rbt_left = &ld->daddrs.addr_entry;
	ld = load_vm_map_entries(kd, RBT_RIGHT(uvm_map_addr, result), result);
	result->daddrs.addr_entry.rbt_right = &ld->daddrs.addr_entry;
	result->daddrs.addr_entry.rbt_parent = &parent->daddrs.addr_entry;

	return result;
}

/*
 * Release the addr tree of vm_map.
 */
void
unload_vm_map_entries(struct vm_map_entry *ent)
{
	if (ent == NULL)
		return;

	unload_vm_map_entries(RBT_LEFT(uvm_map_addr, ent));
	unload_vm_map_entries(RBT_RIGHT(uvm_map_addr, ent));
	free(ent);
}

size_t
dump_vm_map_entry(kvm_t *kd, struct kbit *vmspace,
    struct vm_map_entry *vme, struct sum *sum)
{
	struct kbit kbit[5], *uvm_obj, *vp, *vfs, *amap, *uvn;
	ino_t inode = 0;
	dev_t dev = 0;
	size_t sz = 0;
	char *name;

	uvm_obj = &kbit[0];
	vp = &kbit[1];
	vfs = &kbit[2];
	amap = &kbit[3];
	uvn = &kbit[4];

	A(uvm_obj) = 0;
	A(vp) = 0;
	A(vfs) = 0;
	A(uvn) = 0;

	if (debug & PRINT_VM_MAP_ENTRY) {
		printf("%s = {", "vm_map_entry");
		printf(" start = %lx,", vme->start);
		printf(" end = %lx,", vme->end);
		printf(" fspace = %lx,\n", vme->fspace);
		printf("    object.uvm_obj/sub_map = %p,\n",
		    vme->object.uvm_obj);
		printf("    offset = %lx,", (unsigned long)vme->offset);
		printf(" etype = %x <%s%s%s%s%s >,", vme->etype,
		    vme->etype & UVM_ET_OBJ ? " OBJ" : "",
		    vme->etype & UVM_ET_SUBMAP ? " SUBMAP" : "",
		    vme->etype & UVM_ET_COPYONWRITE ? " COW" : "",
		    vme->etype & UVM_ET_NEEDSCOPY ? " NEEDSCOPY" : "",
		    vme->etype & UVM_ET_HOLE ? " HOLE" : "");
		printf(" protection = %x,\n", vme->protection);
		printf("    max_protection = %x,", vme->max_protection);
		printf(" inheritance = %d,", vme->inheritance);
		printf(" wired_count = %d,\n", vme->wired_count);
		printf("    aref = <struct vm_aref>,");
		printf(" advice = %d,", vme->advice);
		printf(" flags = %x <%s%s > }\n", vme->flags,
		    vme->flags & UVM_MAP_STATIC ? " STATIC" : "",
		    vme->flags & UVM_MAP_KMEM ? " KMEM" : "");
	}

	A(vp) = 0;
	A(uvm_obj) = 0;

	if (vme->object.uvm_obj != NULL) {
		P(uvm_obj) = vme->object.uvm_obj;
		S(uvm_obj) = sizeof(struct uvm_object);
		KDEREF(kd, uvm_obj);
		if (UVM_ET_ISOBJ(vme) &&
		    UVM_OBJ_IS_VNODE(D(uvm_obj, uvm_object))) {
			P(uvn) = P(uvm_obj);
			S(uvn) = sizeof(struct uvm_vnode);
			KDEREF(kd, uvn);

			P(vp) = D(uvn, uvm_vnode)->u_vnode;
			S(vp) = sizeof(struct vnode);
			KDEREF(kd, vp);
		}
	}

	if (vme->aref.ar_amap != NULL) {
		P(amap) = vme->aref.ar_amap;
		S(amap) = sizeof(struct vm_amap);
		KDEREF(kd, amap);
	}

	A(vfs) = 0;

	if (P(vp) != NULL && D(vp, vnode)->v_mount != NULL) {
		P(vfs) = D(vp, vnode)->v_mount;
		S(vfs) = sizeof(struct mount);
		KDEREF(kd, vfs);
		D(vp, vnode)->v_mount = D(vfs, mount);
	}

	/*
	 * dig out the device number and inode number from certain
	 * file system types.
	 */
#define V_DATA_IS(vp, type, d, i) do { \
	struct kbit data; \
	P(&data) = D(vp, vnode)->v_data; \
	S(&data) = sizeof(*D(&data, type)); \
	KDEREF(kd, &data); \
	dev = D(&data, type)->d; \
	inode = D(&data, type)->i; \
} while (0/*CONSTCOND*/)

	if (A(vp) &&
	    D(vp, vnode)->v_type == VREG &&
	    D(vp, vnode)->v_data != NULL) {
		switch (D(vp, vnode)->v_tag) {
		case VT_UFS:
		case VT_EXT2FS:
			V_DATA_IS(vp, inode, i_dev, i_number);
			break;
		case VT_ISOFS:
			V_DATA_IS(vp, iso_node, i_dev, i_number);
			break;
		case VT_NON:
		case VT_NFS:
		case VT_MFS:
		case VT_MSDOSFS:
		default:
			break;
		}
	}

	name = findname(kd, vmspace, vme, vp, vfs, uvm_obj);

	if (print_map) {
		printf("0x%lx 0x%lx %c%c%c %c%c%c %s %s %d %d %d",
		    vme->start, vme->end,
		    (vme->protection & PROT_READ) ? 'r' : '-',
		    (vme->protection & PROT_WRITE) ? 'w' : '-',
		    (vme->protection & PROT_EXEC) ? 'x' : '-',
		    (vme->max_protection & PROT_READ) ? 'r' : '-',
		    (vme->max_protection & PROT_WRITE) ? 'w' : '-',
		    (vme->max_protection & PROT_EXEC) ? 'x' : '-',
		    (vme->etype & UVM_ET_COPYONWRITE) ? "COW" : "NCOW",
		    (vme->etype & UVM_ET_NEEDSCOPY) ? "NC" : "NNC",
		    vme->inheritance, vme->wired_count,
		    vme->advice);
		if (verbose) {
			if (inode)
				printf(" %d,%d %llu",
				    major(dev), minor(dev),
				    (unsigned long long)inode);
			if (name[0])
				printf(" %s", name);
		}
		printf("\n");
	}

	if (print_maps)
		printf("%0*lx-%0*lx %c%c%c%c %0*lx %02x:%02x %llu     %s\n",
		    (int)sizeof(void *) * 2, vme->start,
		    (int)sizeof(void *) * 2, vme->end,
		    (vme->protection & PROT_READ) ? 'r' : '-',
		    (vme->protection & PROT_WRITE) ? 'w' : '-',
		    (vme->protection & PROT_EXEC) ? 'x' : '-',
		    (vme->etype & UVM_ET_COPYONWRITE) ? 'p' : 's',
		    (int)sizeof(void *) * 2,
		    (unsigned long)vme->offset,
		    major(dev), minor(dev), (unsigned long long)inode,
		    inode ? name : "");

	if (print_ddb) {
		printf(" - <lost address>: 0x%lx->0x%lx: "
		    "obj=%p/0x%lx, amap=%p/%d\n",
		    vme->start, vme->end,
		    vme->object.uvm_obj, (unsigned long)vme->offset,
		    vme->aref.ar_amap, vme->aref.ar_pageoff);
		printf("\tsubmap=%c, cow=%c, nc=%c, prot(max)=%d/%d, inh=%d, "
		    "wc=%d, adv=%d\n",
		    (vme->etype & UVM_ET_SUBMAP) ? 'T' : 'F',
		    (vme->etype & UVM_ET_COPYONWRITE) ? 'T' : 'F',
		    (vme->etype & UVM_ET_NEEDSCOPY) ? 'T' : 'F',
		    vme->protection, vme->max_protection,
		    vme->inheritance, vme->wired_count, vme->advice);
		if (inode && verbose)
			printf("\t(dev=%d,%d ino=%llu [%s] [%p])\n",
			    major(dev), minor(dev), (unsigned long long)inode,
			    inode ? name : "", P(vp));
		else if (name[0] == ' ' && verbose)
			printf("\t(%s)\n", &name[2]);
	}

	if (print_solaris) {
		char prot[30];

		prot[0] = '\0';
		prot[1] = '\0';
		if (vme->protection & PROT_READ)
			strlcat(prot, "/read", sizeof(prot));
		if (vme->protection & PROT_WRITE)
			strlcat(prot, "/write", sizeof(prot));
		if (vme->protection & PROT_EXEC)
			strlcat(prot, "/exec", sizeof(prot));

		sz = (size_t)((vme->end - vme->start) / 1024);
		printf("%0*lX %6luK %-15s   %s\n",
		    (int)sizeof(void *) * 2, (unsigned long)vme->start,
		    (unsigned long)sz, &prot[1], name);
	}

	if (print_all) {
		sz = (size_t)((vme->end - vme->start) / 1024);
		printf("%0*lx-%0*lx %7luk %0*lx %c%c%c%c%c (%c%c%c) %d/%d/%d %02d:%02d %7llu - %s",
		    (int)sizeof(void *) * 2, vme->start, (int)sizeof(void *) * 2,
		    vme->end - (vme->start != vme->end ? 1 : 0), (unsigned long)sz,
		    (int)sizeof(void *) * 2, (unsigned long)vme->offset,
		    (vme->protection & PROT_READ) ? 'r' : '-',
		    (vme->protection & PROT_WRITE) ? 'w' : '-',
		    (vme->protection & PROT_EXEC) ? 'x' : '-',
		    (vme->etype & UVM_ET_COPYONWRITE) ? 'p' : 's',
		    (vme->etype & UVM_ET_NEEDSCOPY) ? '+' : '-',
		    (vme->max_protection & PROT_READ) ? 'r' : '-',
		    (vme->max_protection & PROT_WRITE) ? 'w' : '-',
		    (vme->max_protection & PROT_EXEC) ? 'x' : '-',
		    vme->inheritance, vme->wired_count, vme->advice,
		    major(dev), minor(dev), (unsigned long long)inode, name);
		if (A(vp))
			printf(" [%p]", P(vp));
		printf("\n");
	}

	if (print_amap && vme->aref.ar_amap) {
		printf(" amap - ref: %d fl: 0x%x nsl: %d nuse: %d\n",
		    D(amap, vm_amap)->am_ref,
		    D(amap, vm_amap)->am_flags,
		    D(amap, vm_amap)->am_nslot,
		    D(amap, vm_amap)->am_nused);
		if (sum) {
			sum->s_am_nslots += D(amap, vm_amap)->am_nslot;
			sum->s_am_nusedslots += D(amap, vm_amap)->am_nused;
		}
	}

	/* no access allowed, don't count space */
	if ((vme->protection & rwx) == 0)
		sz = 0;

	return (sz);
}

char *
findname(kvm_t *kd, struct kbit *vmspace,
    struct vm_map_entry *vme, struct kbit *vp,
    struct kbit *vfs, struct kbit *uvm_obj)
{
	static char buf[1024], *name;
	size_t l;

	if (UVM_ET_ISOBJ(vme)) {
		if (A(vfs)) {
			l = strlen(D(vfs, mount)->mnt_stat.f_mntonname);
			switch (search_cache(kd, vp, &name, buf, sizeof(buf))) {
			case 0: /* found something */
				if (name - (1 + 11 + l) < buf)
					break;
				name--;
				*name = '/';
				/*FALLTHROUGH*/
			case 2: /* found nothing */
				name -= 11;
				memcpy(name, " -unknown- ", (size_t)11);
				name -= l;
				memcpy(name,
				    D(vfs, mount)->mnt_stat.f_mntonname, l);
				break;
			case 1: /* all is well */
				if (name - (1 + l) < buf)
					break;
				name--;
				*name = '/';
				if (l != 1) {
					name -= l;
					memcpy(name,
					    D(vfs, mount)->mnt_stat.f_mntonname, l);
				}
				break;
			}
		} else if (UVM_OBJ_IS_DEVICE(D(uvm_obj, uvm_object))) {
			struct kbit kdev;
			dev_t dev;

			P(&kdev) = P(uvm_obj);
			S(&kdev) = sizeof(struct uvm_device);
			KDEREF(kd, &kdev);
			dev = D(&kdev, uvm_device)->u_device;
			name = devname(dev, S_IFCHR);
			if (name != NULL)
				snprintf(buf, sizeof(buf), "/dev/%s", name);
			else
				snprintf(buf, sizeof(buf), "  [ device %d,%d ]",
				    major(dev), minor(dev));
			name = buf;
		} else if (UVM_OBJ_IS_AOBJ(D(uvm_obj, uvm_object)))
			name = "  [ uvm_aobj ]";
		else if (UVM_OBJ_IS_VNODE(D(uvm_obj, uvm_object)))
			name = "  [ ?VNODE? ]";
		else {
			snprintf(buf, sizeof(buf), "  [ unknown (%p) ]",
			    D(uvm_obj, uvm_object)->pgops);
			name = buf;
		}
	} else if (D(vmspace, vmspace)->vm_maxsaddr <= (caddr_t)vme->start &&
	    (D(vmspace, vmspace)->vm_maxsaddr + (size_t)maxssiz) >=
	    (caddr_t)vme->end) {
		name = "  [ stack ]";
	} else if (UVM_ET_ISHOLE(vme))
		name = "  [ hole ]";
	else
		name = "  [ anon ]";

	return (name);
}

int
search_cache(kvm_t *kd, struct kbit *vp, char **name, char *buf, size_t blen)
{
	struct cache_entry *ce;
	struct kbit svp;
	char *o, *e;
	u_long cid;

	if (!namecache_loaded)
		load_name_cache(kd);

	P(&svp) = P(vp);
	S(&svp) = sizeof(struct vnode);
	cid = D(vp, vnode)->v_id;

	e = &buf[blen - 1];
	o = e;
	do {
		LIST_FOREACH(ce, &lcache, ce_next)
			if (ce->ce_vp == P(&svp) && ce->ce_cid == cid)
				break;
		if (ce && ce->ce_vp == P(&svp) && ce->ce_cid == cid) {
			if (o != e) {
				if (o <= buf)
					break;
				*(--o) = '/';
			}
			if (o - ce->ce_nlen <= buf)
				break;
			o -= ce->ce_nlen;
			memcpy(o, ce->ce_name, ce->ce_nlen);
			P(&svp) = ce->ce_pvp;
			cid = ce->ce_pcid;
		} else
			break;
	} while (1/*CONSTCOND*/);
	*e = '\0';
	*name = o;

	if (e == o)
		return (2);

	KDEREF(kd, &svp);
	return (D(&svp, vnode)->v_flag & VROOT);
}

void
load_name_cache(kvm_t *kd)
{
	struct namecache n, *tmp;
	struct namecache_head nchead;

	LIST_INIT(&lcache);
	_KDEREF(kd, nclruhead_addr, &nchead, sizeof(nchead));
	tmp = TAILQ_FIRST(&nchead);
	while (tmp != NULL) {
		_KDEREF(kd, (u_long)tmp, &n, sizeof(n));

		if (n.nc_nlen > 0) {
			if (n.nc_nlen > 2 ||
			    n.nc_name[0] != '.' ||
			    (n.nc_nlen != 1 && n.nc_name[1] != '.'))
				cache_enter(&n);
		}
		tmp = TAILQ_NEXT(&n, nc_lru);
	}

	namecache_loaded = 1;
}

void
cache_enter(struct namecache *ncp)
{
	struct cache_entry *ce;

	if (debug & DUMP_NAMEI_CACHE)
		printf("ncp->nc_vp %10p, ncp->nc_dvp %10p, ncp->nc_nlen "
		    "%3d [%.*s] (nc_dvpid=%lu, nc_vpid=%lu)\n",
		    ncp->nc_vp, ncp->nc_dvp,
		    ncp->nc_nlen, ncp->nc_nlen, ncp->nc_name,
		    ncp->nc_dvpid, ncp->nc_vpid);

	ce = malloc(sizeof(struct cache_entry));
	if (ce == NULL)
		err(1, "cache_enter");

	ce->ce_vp = ncp->nc_vp;
	ce->ce_pvp = ncp->nc_dvp;
	ce->ce_cid = ncp->nc_vpid;
	ce->ce_pcid = ncp->nc_dvpid;
	ce->ce_nlen = (unsigned)ncp->nc_nlen;
	strlcpy(ce->ce_name, ncp->nc_name, sizeof(ce->ce_name));

	LIST_INSERT_HEAD(&lcache, ce, ce_next);
}

static void __dead
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-AadlmPsv] [-D number] "
	    "[-M core] [-N system] [-p pid] [pid ...]\n",
	    __progname);
	exit(1);
}

static pid_t
strtopid(const char *str)
{
	pid_t pid;

	errno = 0;
	pid = (pid_t)strtonum(str, 0, INT_MAX, NULL);
	if (errno != 0)
		usage();
	return (pid);
}
@


1.62
log
@Re-introduce vnode-to-filename mapping

The name cache walking code got adapted to the new name cache layout.
Along with the previous commit, procmap is now able to map a vnode
to a filename as long as it is in the name cache.

"nice stuff" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.61 2016/05/25 15:45:53 stefan Exp $ */
d33 4
d200 1
a200 1
static int no_impl(void *, void *);
d202 1
a202 1
no_impl(void *p, void *q)
d208 2
a209 1
RB_GENERATE(uvm_map_addr, vm_map_entry, daddrs.addr_entry, no_impl);
d508 10
a517 3
	RB_ROOT(&D(vm_map, vm_map)->addr) =
	    load_vm_map_entries(kd, RB_ROOT(&D(vm_map, vm_map)->addr), NULL);
	RB_FOREACH(vm_map_entry, uvm_map_addr, &D(vm_map, vm_map)->addr)
d519 1
a519 1
	unload_vm_map_entries(RB_ROOT(&D(vm_map, vm_map)->addr));
d563 1
a563 1
	struct vm_map_entry *result;
d580 8
a587 5
	RB_LEFT(result, daddrs.addr_entry) = load_vm_map_entries(kd,
	    RB_LEFT(result, daddrs.addr_entry), result);
	RB_RIGHT(result, daddrs.addr_entry) = load_vm_map_entries(kd,
	    RB_RIGHT(result, daddrs.addr_entry), result);
	RB_PARENT(result, daddrs.addr_entry) = parent;
d600 2
a601 2
	unload_vm_map_entries(RB_LEFT(ent, daddrs.addr_entry));
	unload_vm_map_entries(RB_RIGHT(ent, daddrs.addr_entry));
@


1.61
log
@Must extract uvm_vnode from uvm_object first before reading the vnode

Otherwise procmap interprets the uvm_vnode contents as a vnode,
yielding bogus values. This should cure the
"procmap: invalid address (ffffffffffffffff) == -1 vs. 656 @@ ffffffffffffffff"
error messages that appear sporadically.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.60 2016/04/16 18:39:30 stefan Exp $ */
d41 1
d83 1
d94 2
d97 1
a97 1
u_long kernel_map_addr;
d172 2
d187 2
d230 1
a230 1
			debug = strtonum(optarg, 0, 0xf, &errstr);
d535 2
d902 3
d916 3
a918 1
			if (o != e)
d920 1
d938 50
@


1.60
log
@Remove am_maxslot from amap.

am_maxslot represents the total number of slots an amap can be extended
to. Since we do not extend amaps, this field as well as rounding the
number of slots to the next malloc bucket is not useful.

This also removes the corresponding output from procmap(1).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.59 2015/01/19 19:25:28 kettenis Exp $ */
d49 1
d126 1
d584 1
a584 1
	struct kbit kbit[4], *uvm_obj, *vp, *vfs, *amap;
d594 1
d599 1
d635 5
a639 1
			P(vp) = P(uvm_obj);
@


1.59
log
@Also print the fspace member of map entries when PRINT_VM_MAP_ENTRY is
requested.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.58 2015/01/16 06:40:19 deraadt Exp $ */
a99 1
	unsigned long s_am_maxslots;
a348 1
	printf("%samap allocated slots: %lu\n", t, sum->s_am_maxslots);
a352 1
		total_sum->s_am_maxslots += sum->s_am_maxslots;
d785 1
a785 1
		printf(" amap - ref: %d fl: 0x%x maxsl: %d nsl: %d nuse: %d\n",
a787 1
		    D(amap, vm_amap)->am_maxslot,
a791 1
			sum->s_am_maxslots += D(amap, vm_amap)->am_maxslot;
@


1.58
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.57 2014/11/16 12:31:01 deraadt Exp $ */
d604 3
a606 1
		printf(" object.uvm_obj/sub_map = %p,\n", vme->object.uvm_obj);
@


1.57
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.56 2014/09/08 01:47:06 guenther Exp $ */
d33 1
a34 1
#include <sys/param.h>
@


1.56
log
@Delete procfs; it's always had races and is now unused: no one noticed for
months that I broke it before the 5.5 release.

confirmed as not being required by ports by sthen@@, ajacoutot@@, dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.55 2014/07/08 17:19:26 deraadt Exp $ */
d95 1
a95 1
int rwx = VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
d691 6
a696 6
		    (vme->protection & VM_PROT_READ) ? 'r' : '-',
		    (vme->protection & VM_PROT_WRITE) ? 'w' : '-',
		    (vme->protection & VM_PROT_EXECUTE) ? 'x' : '-',
		    (vme->max_protection & VM_PROT_READ) ? 'r' : '-',
		    (vme->max_protection & VM_PROT_WRITE) ? 'w' : '-',
		    (vme->max_protection & VM_PROT_EXECUTE) ? 'x' : '-',
d716 3
a718 3
		    (vme->protection & VM_PROT_READ) ? 'r' : '-',
		    (vme->protection & VM_PROT_WRITE) ? 'w' : '-',
		    (vme->protection & VM_PROT_EXECUTE) ? 'x' : '-',
d751 1
a751 1
		if (vme->protection & VM_PROT_READ)
d753 1
a753 1
		if (vme->protection & VM_PROT_WRITE)
d755 1
a755 1
		if (vme->protection & VM_PROT_EXECUTE)
d770 3
a772 3
		    (vme->protection & VM_PROT_READ) ? 'r' : '-',
		    (vme->protection & VM_PROT_WRITE) ? 'w' : '-',
		    (vme->protection & VM_PROT_EXECUTE) ? 'x' : '-',
d775 3
a777 3
		    (vme->max_protection & VM_PROT_READ) ? 'r' : '-',
		    (vme->max_protection & VM_PROT_WRITE) ? 'w' : '-',
		    (vme->max_protection & VM_PROT_EXECUTE) ? 'x' : '-',
@


1.55
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.54 2014/07/08 10:15:16 deraadt Exp $ */
a680 1
		case VT_PROCFS:
@


1.54
log
@There really isn't a strict "heap" anymore, so just call everything like
that an anon.  Useful change since BRKSIZ will soon leave the namespace.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.53 2014/05/20 01:25:24 guenther Exp $ */
d42 3
@


1.53
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.52 2014/02/13 21:17:13 tedu Exp $ */
a868 3
	} else if (D(vmspace, vmspace)->vm_daddr <= (caddr_t)vme->start &&
	    D(vmspace, vmspace)->vm_daddr + BRKSIZ >= (caddr_t)vme->end) {
		name = "  [ heap ]";
@


1.52
log
@remove tendrils of namei dumping code
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.51 2014/02/13 21:07:42 tedu Exp $ */
d312 1
a312 2
				errno = ESRCH;
				warn("%d", pid);
@


1.51
log
@use strtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.50 2013/08/12 05:41:01 otto Exp $ */
a40 1
#include <sys/namei.h>
a77 1
#define DUMP_NAMEI_CACHE	0x00000010
a125 1
		struct namecache namecache;
@


1.50
log
@get ready for big ino_t; ok gunther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.49 2013/05/14 20:18:52 miod Exp $ */
d200 1
d221 3
a223 1
			debug = atoi(optarg);
@


1.49
log
@Don't bother printing vm_swrss of a process, the current uvm accounting
logic never sets this value.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.48 2013/04/24 14:29:00 deraadt Exp $ */
d702 3
a704 2
				printf(" %d,%d %u",
				    major(dev), minor(dev), inode);
@


1.48
log
@pretty-print bigger ino_t variables
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.47 2013/04/21 00:40:08 tedu Exp $ */
d402 1
d404 1
@


1.47
log
@revert 1.45. it depended on a kernel change we will not be making, and
the old code was cleaner
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.44 2013/03/20 15:24:17 tedu Exp $ */
d709 1
a709 1
		printf("%0*lx-%0*lx %c%c%c%c %0*lx %02x:%02x %u     %s\n",
d718 2
a719 1
		    major(dev), minor(dev), inode, inode ? name : "");
d735 3
a737 2
			printf("\t(dev=%d,%d ino=%u [%s] [%p])\n",
			    major(dev), minor(dev), inode, inode ? name : "", P(vp));
d762 1
a762 1
		printf("%0*lx-%0*lx %7luk %0*lx %c%c%c%c%c (%c%c%c) %d/%d/%d %02d:%02d %7u - %s",
d775 1
a775 1
		    major(dev), minor(dev), inode, name);
@


1.46
log
@for the sake of argument, let's pretend this #if 0 code isn't wanted
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.45 2013/03/23 10:46:04 tedu Exp $ */
d201 1
a201 1
	struct kinfo_proc *kprocs, *kproc;
d203 1
a203 1
	int many, ch, rc, i, nprocs;
a206 2
	int mib[2];
	size_t len;
d278 4
d285 4
a289 13
	nprocs = 0;
	mib[0] = CTL_KERN;
	mib[1] = KERN_NPROCS;
	len = sizeof(nprocs);
	sysctl(mib, 2, &nprocs, &len, NULL, 0);
	kprocs = calloc(nprocs, sizeof(struct kinfo_proc));
	if (!kprocs)
		err(1, "calloc");
	/*
	 * we need to do this to get secret pointers via sysctl
	 * before we drop the kmem group
	 */
	i = 0;
d291 3
a293 2
		if (i == nprocs)
			errx(1, "too many procs at once");
d306 3
a308 1
		if (pid != 0) {
a316 1
			memcpy(&kprocs[i], kproc, sizeof(struct kinfo_proc));
a317 22
		pid = -1;

		i++;
	} while (argc > 0);

	nprocs = i;

	if (kernel == NULL && kmem == NULL)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

	/* get "bootstrap" addresses from kernel */
	load_symbols(kd);

	memset(&total_sum, 0, sizeof(total_sum));

	for (i = 0; i < nprocs; i++) {
		struct sum sum;

		memset(&sum, 0, sizeof(sum));

		kproc = &kprocs[i];
d322 1
a322 1
				printf("process %d:\n", kproc->p_pid);
d327 1
a327 1
		process_map(kd, kproc ? kproc->p_pid : 0, kproc, &sum);
d330 2
a331 1
	}
@


1.45
log
@rework the main loop so we can drop kmem privs a little later,
prepping for a coming kernel change. we need to call sysctl for
all the procs to get their vmspace pointer, then we drop, then
we go grovelling. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.44 2013/03/20 15:24:17 tedu Exp $ */
a179 4
#if 0
void load_name_cache(kvm_t *);
void cache_enter(struct namecache *);
#endif
a909 5
#if 0
	if (nchashtbl == NULL)
		load_name_cache(kd);
#endif

a940 69

#if 0
void
load_name_cache(kvm_t *kd)
{
	struct namecache _ncp, *ncp, *oncp;
	struct nchashhead _ncpp, *ncpp;
	u_long nchash;
	int i;

	LIST_INIT(&lcache);

	_KDEREF(kd, nchash_addr, &nchash, sizeof(nchash));
	nchashtbl = calloc(sizeof(nchashtbl), (int)nchash);
	if (nchashtbl == NULL)
		err(1, "load_name_cache");
	_KDEREF(kd, nchashtbl_addr, nchashtbl,
	    sizeof(nchashtbl) * (int)nchash);

	ncpp = &_ncpp;

	for (i = 0; i < nchash; i++) {
		ncpp = &nchashtbl[i];
		oncp = NULL;
		LIST_FOREACH(ncp, ncpp, nc_hash) {
			if (ncp == oncp ||
			    ncp == (void*)0xdeadbeef)
				break;
			oncp = ncp;
			_KDEREF(kd, (u_long)ncp, &_ncp, sizeof(*ncp));
			ncp = &_ncp;
			if (ncp->nc_nlen > 0) {
				if (ncp->nc_nlen > 2 ||
				    ncp->nc_name[0] != '.' ||
				    (ncp->nc_name[1] != '.' &&
				    ncp->nc_nlen != 1))
					cache_enter(ncp);
			}
		}
	}
}

void
cache_enter(struct namecache *ncp)
{
	struct cache_entry *ce;

	if (debug & DUMP_NAMEI_CACHE)
		printf("ncp->nc_vp %10p, ncp->nc_dvp %10p, ncp->nc_nlen "
		    "%3d [%.*s] (nc_dvpid=%lu, nc_vpid=%lu)\n",
		    ncp->nc_vp, ncp->nc_dvp,
		    ncp->nc_nlen, ncp->nc_nlen, ncp->nc_name,
		    ncp->nc_dvpid, ncp->nc_vpid);

	ce = malloc(sizeof(struct cache_entry));
	if (ce == NULL)
		err(1, "cache_enter");

	ce->ce_vp = ncp->nc_vp;
	ce->ce_pvp = ncp->nc_dvp;
	ce->ce_cid = ncp->nc_vpid;
	ce->ce_pcid = ncp->nc_dvpid;
	/* safe since nc_nlen is maximum NCHNAMLEN */
	ce->ce_nlen = (unsigned int)ncp->nc_nlen;
	strlcpy(ce->ce_name, ncp->nc_name, sizeof(ce->ce_name));

	LIST_INSERT_HEAD(&lcache, ce, ce_next);
}
#endif
@


1.44
log
@revert, that restriction is already enforced the right way
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.43 2013/03/20 14:53:35 deraadt Exp $ */
d205 1
a205 1
	struct kinfo_proc *kproc;
d207 1
a207 1
	int many, ch, rc;
d211 2
a283 4
	if (kernel == NULL && kmem == NULL)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

a286 4
	/* get "bootstrap" addresses from kernel */
	load_symbols(kd);

	memset(&total_sum, 0, sizeof(total_sum));
d288 13
d302 2
a303 3
		struct sum sum;

		memset(&sum, 0, sizeof(sum));
d316 1
a316 3
		if (pid == 0)
			kproc = NULL;
		else {
d325 1
d327 22
d353 1
a353 1
				printf("process %d:\n", pid);
d358 1
a358 1
		process_map(kd, pid, kproc, &sum);
d361 1
a361 2
		pid = -1;
	} while (argc > 0);
@


1.43
log
@Only root can look at the kernel address space.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.42 2013/01/16 00:13:23 deraadt Exp $ */
a257 3

	if (getuid() && pid == -1)
		errx(1, "only root may look at the kernel");
@


1.42
log
@document a safe cast, which should be (unsigned int) instead of simply
(unsigned)
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.41 2012/03/09 13:02:45 ariane Exp $ */
d258 3
@


1.41
log
@Userspace counterpart of new vmmap.

Allows memory walks to function.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.40 2011/06/06 17:18:26 ariane Exp $ */
d986 2
a987 1
	ce->ce_nlen = (unsigned)ncp->nc_nlen;
@


1.40
log
@Userland counterpart of the vmmap backout; cranks major version of libkvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.39 2011/05/24 15:27:36 ariane Exp $ */
d172 4
a175 1
size_t dump_vm_map_entry(kvm_t *, struct kbit *, struct kbit *, int,
d177 2
a178 2
char *findname(kvm_t *, struct kbit *, struct kbit *, struct kbit *,
	    struct kbit *, struct kbit *);
d188 13
d366 2
a367 3
	struct kbit kbit[4], *vmspace, *vm_map, *header, *vm_map_entry;
	struct vm_map_entry *last;
	u_long addr, next;
d371 1
a385 2
	header = &kbit[2];
	vm_map_entry = &kbit[3];
a388 2
	A(header) = 0;
	A(vm_map_entry) = 0;
d431 1
a431 3
		printf("    lock = <struct lock>,");
		printf(" header = <struct vm_map_entry>,");
		printf(" nentries = %d,\n", D(vm_map, vm_map)->nentries);
d435 17
a451 9
		printf("    hint = %p,", D(vm_map, vm_map)->hint);
		printf(" hint_lock = <struct simplelock>,\n");
		printf("    first_free = %p,", D(vm_map, vm_map)->first_free);
		printf(" flags = %x <%s%s%s%s%s%s >,\n", D(vm_map, vm_map)->flags,
		    D(vm_map, vm_map)->flags & VM_MAP_PAGEABLE ? " PAGEABLE" : "",
		    D(vm_map, vm_map)->flags & VM_MAP_INTRSAFE ? " INTRSAFE" : "",
		    D(vm_map, vm_map)->flags & VM_MAP_WIREFUTURE ? " WIREFUTURE" : "",
		    D(vm_map, vm_map)->flags & VM_MAP_BUSY ? " BUSY" : "",
		    D(vm_map, vm_map)->flags & VM_MAP_WANTLOCK ? " WANTLOCK" : "",
d453 1
a453 1
		    D(vm_map, vm_map)->flags & VM_MAP_TOPDOWN ? " TOPDOWN" :
d456 1
a456 2
		printf("    flags_lock = <struct simplelock>,");
		printf(" timestamp = %u }\n", D(vm_map, vm_map)->timestamp);
d462 1
a462 2
		printf("\t#ent=%d, sz=%ld, ref=%d, version=%d, flags=0x%x\n",
		    D(vm_map, vm_map)->nentries,
a470 5
	A(header) = A(vm_map) + offsetof(struct vm_map, header);
	S(header) = sizeof(struct vm_map_entry);
	memcpy(D(header, vm_map_entry), &D(vm_map, vm_map)->header, S(header));
	dump_vm_map_entry(kd, vmspace, header, 1, sum);

d496 6
a501 13
	next = (u_long)D(header, vm_map_entry)->next;
	D(vm_map_entry, vm_map_entry)->next =
	    D(header, vm_map_entry)->next + 1;
	last = P(header);

	while (next != 0 && D(vm_map_entry, vm_map_entry)->next != last) {
		addr = next;
		A(vm_map_entry) = addr;
		S(vm_map_entry) = sizeof(struct vm_map_entry);
		KDEREF(kd, vm_map_entry);
		total += dump_vm_map_entry(kd, vmspace, vm_map_entry, 0, sum);
		next = (u_long)D(vm_map_entry, vm_map_entry)->next;
	}
d534 47
d583 1
a583 1
    struct kbit *vm_map_entry, int ishead, struct sum *sum)
a585 1
	struct vm_map_entry *vme;
d600 3
a602 9
	vme = D(vm_map_entry, vm_map_entry);

	if ((ishead && (debug & PRINT_VM_MAP_HEADER)) ||
	    (!ishead && (debug & PRINT_VM_MAP_ENTRY))) {
		printf("%s %p = {", ishead ? "vm_map.header" : "vm_map_entry",
		    P(vm_map_entry));
		printf(" prev = %p,", vme->prev);
		printf(" next = %p,\n", vme->next);
		printf("    start = %lx,", vme->start);
a622 3
	if (ishead)
		return (0);

d687 1
a687 1
	name = findname(kd, vmspace, vm_map_entry, vp, vfs, uvm_obj);
d725 3
a727 2
		printf(" - %p: 0x%lx->0x%lx: obj=%p/0x%lx, amap=%p/%d\n",
		    P(vm_map_entry), vme->start, vme->end,
d806 1
a806 1
    struct kbit *vm_map_entry, struct kbit *vp,
a809 1
	struct vm_map_entry *vme;
a811 2
	vme = D(vm_map_entry, vm_map_entry);

d870 1
a870 3
	    D(vmspace, vmspace)->vm_daddr + BRKSIZ >= (caddr_t)vme->end &&
	    D(vmspace, vmspace)->vm_dsize * getpagesize() / 2 <
	    (vme->end - vme->start)) {
@


1.39
log
@Reimplement uvm/uvm_map.

vmmap is designed to perform address space randomized allocations,
without letting fragmentation of the address space go through the roof.

Some highlights:
- kernel address space randomization
- proper implementation of guardpages
- roughly 10% system time reduction during kernel build

Tested by alot of people on tech@@ and developers.
Theo's machines are still happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.38 2011/04/23 01:01:34 tedu Exp $ */
d172 1
a172 4
struct vm_map_entry *load_vm_map_entries(kvm_t *, struct vm_map_entry *,
    struct vm_map_entry *);
void unload_vm_map_entries(struct vm_map_entry *);
size_t dump_vm_map_entry(kvm_t *, struct kbit *, struct vm_map_entry *,
d174 2
a175 2
char *findname(kvm_t *, struct kbit *, struct vm_map_entry *, struct kbit *,
    struct kbit *, struct kbit *);
a184 13
/*
 * uvm_map address tree implementation.
 */
static int no_impl(void *, void *);
static int
no_impl(void *p, void *q)
{
	errx(1, "uvm_map address comparison not implemented");
	return 0;
}

RB_GENERATE(uvm_map_addr, vm_map_entry, daddrs.addr_entry, no_impl);

d350 3
a352 2
	struct kbit kbit[3], *vmspace, *vm_map;
	struct vm_map_entry *vm_map_entry;
a355 1
	int vmmap_flags;
d370 2
d375 2
d419 3
a421 1
		printf("    lock = <struct lock>\n");
d425 9
a433 17
		printf("    min_offset-max_offset = 0x%lx-0x%lx\n",
		    D(vm_map, vm_map)->min_offset,
		    D(vm_map, vm_map)->max_offset);
		printf("    b_start-b_end = 0x%lx-0x%lx\n",
		    D(vm_map, vm_map)->b_start,
		    D(vm_map, vm_map)->b_end);
		printf("    s_start-s_end = 0x%lx-0x%lx\n",
		    D(vm_map, vm_map)->s_start,
		    D(vm_map, vm_map)->s_end);
		vmmap_flags = D(vm_map, vm_map)->flags;
		printf("    flags = %x <%s%s%s%s%s%s >,\n",
		    vmmap_flags,
		    vmmap_flags & VM_MAP_PAGEABLE ? " PAGEABLE" : "",
		    vmmap_flags & VM_MAP_INTRSAFE ? " INTRSAFE" : "",
		    vmmap_flags & VM_MAP_WIREFUTURE ? " WIREFUTURE" : "",
		    vmmap_flags & VM_MAP_BUSY ? " BUSY" : "",
		    vmmap_flags & VM_MAP_WANTLOCK ? " WANTLOCK" : "",
d435 1
a435 1
		    vmmap_flags & VM_MAP_TOPDOWN ? " TOPDOWN" :
d438 2
a439 1
		printf("    timestamp = %u }\n", D(vm_map, vm_map)->timestamp);
d445 2
a446 1
		printf("\tsz=%ld, ref=%d, version=%d, flags=0x%x\n",
d455 5
d485 13
a497 6
	RB_ROOT(&D(vm_map, vm_map)->addr) =
	    load_vm_map_entries(kd, RB_ROOT(&D(vm_map, vm_map)->addr), NULL);
	RB_FOREACH(vm_map_entry, uvm_map_addr, &D(vm_map, vm_map)->addr)
		total += dump_vm_map_entry(kd, vmspace, vm_map_entry, sum);
	unload_vm_map_entries(RB_ROOT(&D(vm_map, vm_map)->addr));

a529 47
/*
 * Recreate the addr tree of vm_map in local memory.
 */
struct vm_map_entry *
load_vm_map_entries(kvm_t *kd, struct vm_map_entry *kptr,
    struct vm_map_entry *parent)
{
	static struct kbit map_ent;
	struct vm_map_entry *result;

	if (kptr == NULL)
		return NULL;

	A(&map_ent) = (u_long)kptr;
	S(&map_ent) = sizeof(struct vm_map_entry);
	KDEREF(kd, &map_ent);

	result = malloc(sizeof(*result));
	if (result == NULL)
		err(1, "malloc");
	memcpy(result, D(&map_ent, vm_map_entry), sizeof(struct vm_map_entry));

	/*
	 * Recurse to download rest of the tree.
	 */
	RB_LEFT(result, daddrs.addr_entry) = load_vm_map_entries(kd,
	    RB_LEFT(result, daddrs.addr_entry), result);
	RB_RIGHT(result, daddrs.addr_entry) = load_vm_map_entries(kd,
	    RB_RIGHT(result, daddrs.addr_entry), result);
	RB_PARENT(result, daddrs.addr_entry) = parent;
	return result;
}

/*
 * Release the addr tree of vm_map.
 */
void
unload_vm_map_entries(struct vm_map_entry *ent)
{
	if (ent == NULL)
		return;

	unload_vm_map_entries(RB_LEFT(ent, daddrs.addr_entry));
	unload_vm_map_entries(RB_RIGHT(ent, daddrs.addr_entry));
	free(ent);
}

d532 1
a532 1
    struct vm_map_entry *vme, struct sum *sum)
d535 1
d550 9
a558 3
	if (debug & PRINT_VM_MAP_ENTRY) {
		printf("%s = {", "vm_map_entry");
		printf(" start = %lx,", vme->start);
d579 3
d646 1
a646 1
	name = findname(kd, vmspace, vme, vp, vfs, uvm_obj);
d684 2
a685 3
		printf(" - <lost address>: 0x%lx->0x%lx: "
		    "obj=%p/0x%lx, amap=%p/%d\n",
		    vme->start, vme->end,
d764 1
a764 1
    struct vm_map_entry *vme, struct kbit *vp,
d768 1
d771 2
d831 3
a833 1
	    D(vmspace, vmspace)->vm_daddr + BRKSIZ >= (caddr_t)vme->end) {
@


1.38
log
@BRKSIZ is the right constant now, so I don't get lots of teeny tiny heaps
mixed up in my address space.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.38 2011/04/23 00:55:43 tedu Exp $ */
d172 4
a175 1
size_t dump_vm_map_entry(kvm_t *, struct kbit *, struct kbit *, int,
d177 2
a178 2
char *findname(kvm_t *, struct kbit *, struct kbit *, struct kbit *,
	    struct kbit *, struct kbit *);
d188 13
d366 2
a367 3
	struct kbit kbit[4], *vmspace, *vm_map, *header, *vm_map_entry;
	struct vm_map_entry *last;
	u_long addr, next;
d371 1
a385 2
	header = &kbit[2];
	vm_map_entry = &kbit[3];
a388 2
	A(header) = 0;
	A(vm_map_entry) = 0;
d431 1
a431 3
		printf("    lock = <struct lock>,");
		printf(" header = <struct vm_map_entry>,");
		printf(" nentries = %d,\n", D(vm_map, vm_map)->nentries);
d435 17
a451 9
		printf("    hint = %p,", D(vm_map, vm_map)->hint);
		printf(" hint_lock = <struct simplelock>,\n");
		printf("    first_free = %p,", D(vm_map, vm_map)->first_free);
		printf(" flags = %x <%s%s%s%s%s%s >,\n", D(vm_map, vm_map)->flags,
		    D(vm_map, vm_map)->flags & VM_MAP_PAGEABLE ? " PAGEABLE" : "",
		    D(vm_map, vm_map)->flags & VM_MAP_INTRSAFE ? " INTRSAFE" : "",
		    D(vm_map, vm_map)->flags & VM_MAP_WIREFUTURE ? " WIREFUTURE" : "",
		    D(vm_map, vm_map)->flags & VM_MAP_BUSY ? " BUSY" : "",
		    D(vm_map, vm_map)->flags & VM_MAP_WANTLOCK ? " WANTLOCK" : "",
d453 1
a453 1
		    D(vm_map, vm_map)->flags & VM_MAP_TOPDOWN ? " TOPDOWN" :
d456 1
a456 2
		printf("    flags_lock = <struct simplelock>,");
		printf(" timestamp = %u }\n", D(vm_map, vm_map)->timestamp);
d462 1
a462 2
		printf("\t#ent=%d, sz=%ld, ref=%d, version=%d, flags=0x%x\n",
		    D(vm_map, vm_map)->nentries,
a470 5
	A(header) = A(vm_map) + offsetof(struct vm_map, header);
	S(header) = sizeof(struct vm_map_entry);
	memcpy(D(header, vm_map_entry), &D(vm_map, vm_map)->header, S(header));
	dump_vm_map_entry(kd, vmspace, header, 1, sum);

d496 6
a501 13
	next = (u_long)D(header, vm_map_entry)->next;
	D(vm_map_entry, vm_map_entry)->next =
	    D(header, vm_map_entry)->next + 1;
	last = P(header);

	while (next != 0 && D(vm_map_entry, vm_map_entry)->next != last) {
		addr = next;
		A(vm_map_entry) = addr;
		S(vm_map_entry) = sizeof(struct vm_map_entry);
		KDEREF(kd, vm_map_entry);
		total += dump_vm_map_entry(kd, vmspace, vm_map_entry, 0, sum);
		next = (u_long)D(vm_map_entry, vm_map_entry)->next;
	}
d534 47
d583 1
a583 1
    struct kbit *vm_map_entry, int ishead, struct sum *sum)
a585 1
	struct vm_map_entry *vme;
d600 3
a602 9
	vme = D(vm_map_entry, vm_map_entry);

	if ((ishead && (debug & PRINT_VM_MAP_HEADER)) ||
	    (!ishead && (debug & PRINT_VM_MAP_ENTRY))) {
		printf("%s %p = {", ishead ? "vm_map.header" : "vm_map_entry",
		    P(vm_map_entry));
		printf(" prev = %p,", vme->prev);
		printf(" next = %p,\n", vme->next);
		printf("    start = %lx,", vme->start);
a622 3
	if (ishead)
		return (0);

d687 1
a687 1
	name = findname(kd, vmspace, vm_map_entry, vp, vfs, uvm_obj);
d725 3
a727 2
		printf(" - %p: 0x%lx->0x%lx: obj=%p/0x%lx, amap=%p/%d\n",
		    P(vm_map_entry), vme->start, vme->end,
d806 1
a806 1
    struct kbit *vm_map_entry, struct kbit *vp,
a809 1
	struct vm_map_entry *vme;
a811 2
	vme = D(vm_map_entry, vm_map_entry);

d870 1
a870 3
	    D(vmspace, vmspace)->vm_daddr + BRKSIZ >= (caddr_t)vme->end &&
	    D(vmspace, vmspace)->vm_dsize * getpagesize() / 2 <
	    (vme->end - vme->start)) {
@


1.37
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.36 2011/04/06 11:36:26 miod Exp $ */
d831 1
a831 1
	    D(vmspace, vmspace)->vm_daddr + MAXDSIZ >= (caddr_t)vme->end &&
@


1.36
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.35 2011/04/05 18:51:26 thib Exp $ */
d171 1
a171 1
void process_map(kvm_t *, pid_t, struct kinfo_proc2 *, struct sum *);
d189 1
a189 1
	struct kinfo_proc2 *kproc;
d297 2
a298 2
			kproc = kvm_getproc2(kd, KERN_PROC_PID, pid,
			    sizeof(struct kinfo_proc2), &rc);
d348 1
a348 1
process_map(kvm_t *kd, pid_t pid, struct kinfo_proc2 *proc, struct sum *sum)
@


1.35
log
@Remove portalfs.

While it is a terribly cool idea, it's just awful and since noone has stepped
up to the plate to keep it up with the current vop state, retire it to the
attic.

ok krw@@, deraadt@@, guenther@@, miod@@.
comments from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.33 2009/08/12 16:42:24 beck Exp $ */
d91 1
a91 1
u_long nchash_addr, kernel_map_addr;
a166 2
	{ "_nchash" },
#define NL_NCHASH		5
a523 2
	nchash_addr =	nl[NL_NCHASH].n_value;

d603 1
a603 1
	A(vfs) = NULL;
@


1.34
log
@Update nlist array and uncomment a few things to pave the way for upcoming
new name cache information gathering code.
@
text
@a643 1
		case VT_PORTAL:
a644 2
		case VT_AFS:
		case VT_ADOSFS:
@


1.33
log
@Namecache revamp.

This eliminates the large single namecache hash table, and implements
the name cache as a global lru of entires, and a redblack tree in each
vnode. It makes cache_purge actually purge the namecache entries associated
with a vnode when a vnode is recycled (very important for later on actually being
able to resize the vnode pool)

This commit does #if 0 out a bunch of procmap code that was
already broken before this change, but needs to be redone completely.

Tested by many, including in thib's nfs test setup.

ok oga@@,art@@,thib@@,miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.32 2009/06/04 22:38:53 miod Exp $ */
a89 1
LIST_HEAD(nchashhead, namecache) *nchashtbl = NULL;
d91 1
a91 1
u_long nchash_addr, nchashtbl_addr, kernel_map_addr;
a166 2
	{ "_nchashtbl" },
#define NL_NCHASHTBL		5
d168 1
a168 1
#define NL_NCHASH		6
d178 1
a179 1
int search_cache(kvm_t *, struct kbit *, char **, char *, size_t);
a529 2
	_KDEREF(kd, nl[NL_NCHASHTBL].n_value, &nchashtbl_addr,
	    sizeof(nchashtbl_addr));
a782 1
#if 0
a790 1
#endif
a795 1
#if 0
a808 1
#endif
a849 1
#if 0
d858 1
d861 1
d895 1
@


1.32
log
@No longer consider kernel pointers invalid if pointing under the kernel
load address (hello, PMAP_DIRECT architectures). Makes procmap walk the
kernel name cache correctly.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.31 2008/09/18 08:02:53 otto Exp $ */
d181 1
d185 1
d788 1
d797 1
d803 1
d817 1
d859 1
d968 1
@


1.31
log
@document -A and include in usage
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.30 2008/09/18 07:50:39 art Exp $ */
a73 3
#if 0
#define UVM_OBJ_IS_UBCPAGER(uobj) ((uobj)->pgops == ubc_pager)
#endif
a91 4
#if 0
void *ubc_pager;
#endif
void *kernel_floor;
a171 6
	{ "_kernel_text" },
#define NL_KENTER		7
#if 0
	{ "_ubc_pager" },
#define NL_UBC_PAGER		8
#endif
a520 3
#if defined(__m68k__)
			if (i != NL_KENTER)
#endif
a525 3
#if 0
	ubc_pager =	(void*)nl[NL_UBC_PAGER].n_value;
#endif
a526 1
	kernel_floor =	(void*)nl[NL_KENTER].n_value;
a828 4
#if 0
		else if (UVM_OBJ_IS_UBCPAGER(D(uvm_obj, uvm_object)))
			name = "  [ ubc_pager ]";
#endif
a919 1
			    (void*)ncp < kernel_floor ||
d925 1
a925 2
			if ((void*)ncp->nc_vp > kernel_floor &&
			    ncp->nc_nlen > 0) {
@


1.30
log
@Add a flag to print amap usage.
otto@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.29 2008/06/26 05:42:21 ray Exp $ */
d992 1
a992 1
	fprintf(stderr, "usage: %s [-adlmPsv] [-D number] "
@


1.29
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.28 2008/06/09 20:30:25 miod Exp $ */
d46 1
d101 1
a101 1
int print_all, print_map, print_maps, print_solaris, print_ddb;
d105 6
d140 1
d189 3
a191 2
void process_map(kvm_t *, pid_t, struct kinfo_proc2 *);
size_t dump_vm_map_entry(kvm_t *, struct kbit *, struct kbit *, int);
d199 1
d206 1
d212 1
a212 1
	while ((ch = getopt(argc, argv, "aD:dlmM:N:p:Prsvx")) != -1) {
d214 3
d292 2
d295 4
d331 3
a333 1
		process_map(kd, pid, kproc);
d337 3
d349 16
a364 1
process_map(kvm_t *kd, pid_t pid, struct kinfo_proc2 *proc)
d474 1
a474 1
	dump_vm_map_entry(kd, vmspace, header, 1);
d511 1
a511 1
		total += dump_vm_map_entry(kd, vmspace, vm_map_entry, 0);
d559 1
a559 1
    struct kbit *vm_map_entry, int ishead)
d561 1
a561 1
	struct kbit kbit[3], *uvm_obj, *vp, *vfs;
d571 1
d624 6
d769 14
@


1.28
log
@Define a new flag, UVM_FLAG_HOLE, for uvm_map to create a vm_map_entry of
a new etype, UVM_ET_HOLE, meaning it has no backend.

UVM_ET_HOLE entries (which should be created as UVM_PROT_NONE and with
UVM_FLAG_NOMERGE and UVM_FLAG_HOLE) are skipped in uvm_unmap_remove(), so
that pmap_{k,}remove() is not called on the entry.

This is intended to save time, and behave better, on pmaps with MMU holes
at process exit time.

ok art@@, kettenis@@ provided feedback as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.27 2007/10/02 14:50:49 kettenis Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.27
log
@Use kinfo_proc2 instead of kinfo_proc.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.26 2007/09/02 15:19:40 deraadt Exp $ */
d555 1
a555 1
		printf(" etype = %x <%s%s%s%s >,", vme->etype,
d559 2
a560 1
		    vme->etype & UVM_ET_NEEDSCOPY ? " NEEDSCOPY" : "");
d815 3
a817 1
	} else
@


1.26
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.25 2007/05/31 18:22:25 thib Exp $ */
d188 1
a188 1
void process_map(kvm_t *, pid_t, struct kinfo_proc *);
d202 1
a202 1
	struct kinfo_proc *kproc;
d300 2
a301 1
			kproc = kvm_getprocs(kd, KERN_PROC_PID, pid, &rc);
d331 1
a331 1
process_map(kvm_t *kd, pid_t pid, struct kinfo_proc *proc)
d345 1
a345 1
		if (uid != proc->kp_eproc.e_ucred.cr_uid) {
d362 1
a362 1
		A(vmspace) = (u_long)proc->kp_proc.p_vmspace;
@


1.25
log
@Zap a bunch of unused VT_* tags.

ok tedu@@,pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.24 2007/04/26 04:59:39 deraadt Exp $ */
d873 1
a873 1
	nchashtbl = malloc(sizeof(nchashtbl) * (int)nchash);
@


1.24
log
@kill some commented "struct proc *", and knf while there; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.23 2006/07/01 22:02:02 miod Exp $ */
a614 1
		case VT_LFS:
a624 1
		case VT_LOFS:
@


1.23
log
@Don't warn for kernel_text being zero on (some) m68k systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.22 2005/12/06 20:18:57 pedro Exp $ */
d201 3
d205 1
a205 7
	pid_t pid;
	int many, ch, rc;
	char errbuf[_POSIX2_LINE_MAX];
	/* u_long addr, next; */
	struct kinfo_proc *kproc;
	/* struct proc proc; */
	char *kmem, *kernel;
a207 5
	pid = -1;
	verbose = debug = 0;
	print_all = print_map = print_maps = print_solaris = print_ddb = 0;
	kmem = kernel = NULL;

a246 1
		case '?':
d332 1
a332 2
	struct kbit kbit[4];
	struct kbit *vmspace, *vm_map, *header, *vm_map_entry;
a333 1
	size_t total;
d335 1
a466 1
	total = 0;
d493 1
a493 2
	int rc;
	int i;
d527 1
a527 2
	struct kbit kbit[3];
	struct kbit *uvm_obj, *vp, *vfs;
d529 3
a531 1
	size_t sz;
a532 2
	dev_t dev;
	ino_t inode;
a609 3
	dev = 0;
	inode = 0;

d653 1
a653 1
				printf(" %d,%d %d",
d662 1
a662 1
		printf("%0*lx-%0*lx %c%c%c%c %0*lx %02x:%02x %d     %s\n",
d686 2
a687 3
			printf("\t(dev=%d,%d ino=%d [%s] [%p])\n",
			    major(dev), minor(dev), inode,
			    inode ? name : "", P(vp));
a691 1
	sz = 0;
d706 2
a707 5
		    (int)sizeof(void *) * 2,
		    (unsigned long)vme->start,
		    (unsigned long)sz,
		    &prot[1],
		    name);
d712 4
a715 10
		printf(A(vp) ?
		    "%0*lx-%0*lx %7luk %0*lx %c%c%c%c%c (%c%c%c) %d/%d/%d %02d:%02d %7d - %s [%p]\n" :
		    "%0*lx-%0*lx %7luk %0*lx %c%c%c%c%c (%c%c%c) %d/%d/%d %02d:%02d %7d - %s\n",
		    (int)sizeof(void *) * 2,
		    vme->start,
		    (int)sizeof(void *) * 2,
		    vme->end - (vme->start != vme->end ? 1 : 0),
		    (unsigned long)sz,
		    (int)sizeof(void *) * 2,
		    (unsigned long)vme->offset,
d724 5
a728 5
		    vme->inheritance,
		    vme->wired_count,
		    vme->advice,
		    major(dev), minor(dev), inode,
		    name, P(vp));
d738 1
a738 1
char*
d806 1
a806 2
	} else if (D(vmspace, vmspace)->vm_maxsaddr <=
	    (caddr_t)vme->start &&
a823 1
	char *o, *e;
d826 1
@


1.22
log
@Remove fdescfs
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.21 2005/11/24 12:08:17 pedro Exp $ */
d512 3
@


1.21
log
@Remove kernfs, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.20 2005/05/26 05:22:15 pedro Exp $ */
a639 1
		case VT_FDESC:
@


1.20
log
@kill stackable filesystems ghosts
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.19 2005/05/03 03:41:11 djm Exp $ */
a641 1
		case VT_KERNFS:
@


1.19
log
@setresgid; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.18 2005/03/25 16:54:17 jaredy Exp $ */
a641 2
		case VT_NULL:
		case VT_UMAP:
a644 1
		case VT_UNION:
@


1.18
log
@Use the return value from getopt() instead of optopt in non-error
cases since optopt is not set in these cases, and it is not required
by POSIX that it should be.

ok millert otto
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.17 2004/07/09 19:30:52 tdeval Exp $ */
d209 1
d265 4
a268 4
	if (kernel != NULL || kmem != NULL) {
		setegid(getgid());
		setgid(getgid());
	}
d284 3
a286 2
	setegid(getgid());
	setgid(getgid());
@


1.17
log
@[From: Joris Vink]
Use strtonum(3) instead of strtol(3). ok deraadt@@ & me
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.16 2004/04/01 23:17:11 tdeval Exp $ */
d252 1
a252 1
			errx(1, "-%c option not implemented, sorry", optopt);
@


1.16
log
@Off by 1 !   OK millert@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.15 2004/03/15 09:13:10 tedu Exp $ */
d973 1
a973 2
	unsigned long pid;
	char *endptr;
d976 2
a977 4
	pid = strtoul(str, &endptr, 10);
	if (str[0] == '\0' || *endptr != '\0')
		usage();
	if (errno == ERANGE && pid == ULONG_MAX)
@


1.15
log
@more accurate msg, pr3713 from Andre Lucas
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.14 2004/02/23 21:01:22 tedu Exp $ */
d911 1
a911 1
	for (i = 0; i <= nchash; i++) {
@


1.14
log
@make sure we don't backwards before buffer
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.13 2004/02/23 20:53:21 tedu Exp $ */
d353 1
a353 1
			warnx("other process's maps are restricted");
a356 2
		
		
@


1.13
log
@buffer len paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.12 2004/02/23 19:48:40 tedu Exp $ */
d783 2
d796 2
@


1.12
log
@if the heap is non-exec, it makes it hard to find by looking for an exec
mapping.  much better heuristic.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.11 2004/02/23 04:34:31 tedu Exp $ */
d94 1
a94 1
	int ce_nlen;
d871 2
d874 1
a874 1
			memcpy(o, ce->ce_name, (unsigned)ce->ce_nlen);
d877 1
a877 2
		}
		else
d952 1
a952 1
	ce->ce_nlen = ncp->nc_nlen;
@


1.11
log
@unknown is less ugly than ??, and not a trigraph.  requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.10 2004/02/23 03:21:23 tedu Exp $ */
d108 1
a108 1
int rwx = VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE, heapfound;
a370 1
		heapfound = 0;
a375 1
		heapfound = 1; /* but really, do kernels have a heap? */
d780 1
a780 1
			l = (unsigned)strlen(D(vfs, mount)->mnt_stat.f_mntonname);
d836 4
a839 3
	} else if ((vme->protection & rwx) == rwx && !heapfound) {
		/* XXX this could probably be done better */
		heapfound = 1;
@


1.10
log
@no peeking at kernel or other processes for normal users.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.9 2004/02/19 08:22:34 tedu Exp $ */
d789 2
a790 2
				name -= 6;
				memcpy(name, " -??- ", (size_t)6);
d829 1
a829 1
			snprintf(buf, sizeof(buf), "  [ ?? %p ?? ]",
@


1.9
log
@pedro martelletto tells me stroul returns an unsigned long which
may be bigger than a pid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.8 2004/02/18 04:32:17 tedu Exp $ */
d345 14
@


1.8
log
@strtoul for getting pid.  ok and numerous hints from deraadt@@
also correct errbuf size
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.7 2004/02/18 04:07:35 deraadt Exp $ */
d957 1
a957 1
	pid_t pid;
@


1.7
log
@revoke privs asap; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.6 2004/02/18 03:58:35 deraadt Exp $ */
d196 1
d204 1
a204 1
	char errbuf[_POSIX2_LINE_MAX + 1];
d239 1
a239 3
			if (!isdigit(optarg[0]))
				usage();
			pid = atoi(optarg);
a285 1
	errbuf[_POSIX2_LINE_MAX] = '\0';
d297 1
a297 3
				if (!isdigit(argv[0][0]))
					usage();
				pid = atoi(argv[0]);
d952 15
@


1.6
log
@a pinch of knf
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.5 2004/02/18 03:27:22 tedu Exp $ */
d260 10
d283 4
@


1.5
log
@little cleanup.  strlcat.  usage.  don't call atoi on non-numbers.
mostly spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.4 2004/02/18 00:46:25 tedu Exp $ */
d77 3
a79 3
#define UVM_OBJ_IS_VNODE(uobj)    ((uobj)->pgops == uvm_vnodeops)
#define UVM_OBJ_IS_AOBJ(uobj)     ((uobj)->pgops == aobj_pager)
#define UVM_OBJ_IS_DEVICE(uobj)   ((uobj)->pgops == uvm_deviceops)
d191 1
a191 1
	       struct kbit *, struct kbit *);
d371 1
a371 1
		       D(vmspace, vmspace)->vm_maxsaddr);
d373 1
a373 1
		       D(vmspace, vmspace)->vm_minsaddr);
d380 1
a380 1
		       S(vm_map));
d399 5
a403 5
		       D(vm_map, vm_map)->flags & VM_MAP_PAGEABLE ? " PAGEABLE" : "",
		       D(vm_map, vm_map)->flags & VM_MAP_INTRSAFE ? " INTRSAFE" : "",
		       D(vm_map, vm_map)->flags & VM_MAP_WIREFUTURE ? " WIREFUTURE" : "",
		       D(vm_map, vm_map)->flags & VM_MAP_BUSY ? " BUSY" : "",
		       D(vm_map, vm_map)->flags & VM_MAP_WANTLOCK ? " WANTLOCK" : "",
d405 1
a405 1
		       D(vm_map, vm_map)->flags & VM_MAP_TOPDOWN ? " TOPDOWN" :
d407 1
a407 1
		       "");
d413 2
a414 1
		       D(vm_map, vm_map)->min_offset, D(vm_map, vm_map)->max_offset);
d416 7
a422 4
		       D(vm_map, vm_map)->nentries, D(vm_map, vm_map)->size,
		       D(vm_map, vm_map)->ref_count, D(vm_map, vm_map)->timestamp,
		       D(vm_map, vm_map)->flags);
		printf("\tpmap=%p(resident=<unknown>)\n", D(vm_map, vm_map)->pmap);
d434 2
a435 2
		       (int)sizeof(long) * 2 + 2, "Start",
		       (int)sizeof(long) * 2 + 2, "End");
d438 3
a440 3
		       (int)sizeof(long) * 2 + 0, "Start",
		       (int)sizeof(long) * 2 + 0, "End",
		       (int)sizeof(long) * 2 + 0, "Offset");
d443 2
a444 2
		       (int)sizeof(long) * 2 + 0, "Start",
		       (int)sizeof(int) * 2 - 1,  "Size ");
d448 5
a452 5
		       (int)sizeof(long) * 2, "Start",
		       (int)sizeof(long) * 2, "End",
		       (int)sizeof(int)  * 2, "Size ",
		       (int)sizeof(long) * 2, "Offset",
		       (int)sizeof(int)  * 2, "Inode");
d458 1
a458 1
		D(header, vm_map_entry)->next + 1;
d471 2
a472 2
		       (int)sizeof(void *) * 2 - 2, " total",
		       (unsigned long)total);
d475 2
a476 2
		       (int)sizeof(void *) * 4 - 1, " total",
		       (unsigned long)total);
d503 1
a503 1
		sizeof(maxssiz));
d505 1
a505 1
	       sizeof(nchashtbl_addr));
d507 1
a507 1
		sizeof(kernel_map_addr));
d512 1
a512 2
		  struct kbit *vm_map_entry,
		  int ishead)
d535 1
a535 1
		       P(vm_map_entry));
d543 4
a546 4
		       vme->etype & UVM_ET_OBJ ? " OBJ" : "",
		       vme->etype & UVM_ET_SUBMAP ? " SUBMAP" : "",
		       vme->etype & UVM_ET_COPYONWRITE ? " COW" : "",
		       vme->etype & UVM_ET_NEEDSCOPY ? " NEEDSCOPY" : "");
d554 2
a555 2
		       vme->flags & UVM_MAP_STATIC ? " STATIC" : "",
		       vme->flags & UVM_MAP_KMEM ? " KMEM" : "");
d636 11
a646 11
		       vme->start, vme->end,
		       (vme->protection & VM_PROT_READ) ? 'r' : '-',
		       (vme->protection & VM_PROT_WRITE) ? 'w' : '-',
		       (vme->protection & VM_PROT_EXECUTE) ? 'x' : '-',
		       (vme->max_protection & VM_PROT_READ) ? 'r' : '-',
		       (vme->max_protection & VM_PROT_WRITE) ? 'w' : '-',
		       (vme->max_protection & VM_PROT_EXECUTE) ? 'x' : '-',
		       (vme->etype & UVM_ET_COPYONWRITE) ? "COW" : "NCOW",
		       (vme->etype & UVM_ET_NEEDSCOPY) ? "NC" : "NNC",
		       vme->inheritance, vme->wired_count,
		       vme->advice);
d650 1
a650 1
				       major(dev), minor(dev), inode);
d659 9
a667 9
		       (int)sizeof(void *) * 2, vme->start,
		       (int)sizeof(void *) * 2, vme->end,
		       (vme->protection & VM_PROT_READ) ? 'r' : '-',
		       (vme->protection & VM_PROT_WRITE) ? 'w' : '-',
		       (vme->protection & VM_PROT_EXECUTE) ? 'x' : '-',
		       (vme->etype & UVM_ET_COPYONWRITE) ? 'p' : 's',
		       (int)sizeof(void *) * 2,
		       (unsigned long)vme->offset,
		       major(dev), minor(dev), inode, inode ? name : "");
d671 3
a673 3
		       P(vm_map_entry), vme->start, vme->end,
		       vme->object.uvm_obj, (unsigned long)vme->offset,
		       vme->aref.ar_amap, vme->aref.ar_pageoff);
d675 6
a680 6
		       "wc=%d, adv=%d\n",
		       (vme->etype & UVM_ET_SUBMAP) ? 'T' : 'F',
		       (vme->etype & UVM_ET_COPYONWRITE) ? 'T' : 'F',
		       (vme->etype & UVM_ET_NEEDSCOPY) ? 'T' : 'F',
		       vme->protection, vme->max_protection,
		       vme->inheritance, vme->wired_count, vme->advice);
d683 2
a684 2
			       major(dev), minor(dev), inode,
			       inode ? name : "", P(vp));
d704 5
a708 5
		       (int)sizeof(void *) * 2,
		       (unsigned long)vme->start,
		       (unsigned long)sz,
		       &prot[1],
		       name);
d714 22
a735 22
		       "%0*lx-%0*lx %7luk %0*lx %c%c%c%c%c (%c%c%c) %d/%d/%d %02d:%02d %7d - %s [%p]\n" :
		       "%0*lx-%0*lx %7luk %0*lx %c%c%c%c%c (%c%c%c) %d/%d/%d %02d:%02d %7d - %s\n",
		       (int)sizeof(void *) * 2,
		       vme->start,
		       (int)sizeof(void *) * 2,
		       vme->end - (vme->start != vme->end ? 1 : 0),
		       (unsigned long)sz,
		       (int)sizeof(void *) * 2,
		       (unsigned long)vme->offset,
		       (vme->protection & VM_PROT_READ) ? 'r' : '-',
		       (vme->protection & VM_PROT_WRITE) ? 'w' : '-',
		       (vme->protection & VM_PROT_EXECUTE) ? 'x' : '-',
		       (vme->etype & UVM_ET_COPYONWRITE) ? 'p' : 's',
		       (vme->etype & UVM_ET_NEEDSCOPY) ? '+' : '-',
		       (vme->max_protection & VM_PROT_READ) ? 'r' : '-',
		       (vme->max_protection & VM_PROT_WRITE) ? 'w' : '-',
		       (vme->max_protection & VM_PROT_EXECUTE) ? 'x' : '-',
		       vme->inheritance,
		       vme->wired_count,
		       vme->advice,
		       major(dev), minor(dev), inode,
		       name, P(vp));
d747 2
a748 2
	 struct kbit *vm_map_entry, struct kbit *vp,
	 struct kbit *vfs, struct kbit *uvm_obj)
d759 4
a762 4
			switch (search_cache(kd, vp, &name, buf, sizeof(buf))) { 
			    case 0: /* found something */
                                name--;
                                *name = '/';
d764 1
a764 1
			    case 2: /* found nothing */
d769 1
a769 1
				       D(vfs, mount)->mnt_stat.f_mntonname, l);
d771 1
a771 1
			    case 1: /* all is well */
d777 1
a777 1
					       D(vfs, mount)->mnt_stat.f_mntonname, l);
d781 1
a781 2
		}
		else if (UVM_OBJ_IS_DEVICE(D(uvm_obj, uvm_object))) {
d794 1
a794 1
					 major(dev), minor(dev));
d796 1
a796 2
		}
		else if (UVM_OBJ_IS_AOBJ(D(uvm_obj, uvm_object))) 
d806 1
a806 1
				 D(uvm_obj, uvm_object)->pgops);
d809 4
a812 6
	}

	else if (D(vmspace, vmspace)->vm_maxsaddr <=
		 (caddr_t)vme->start &&
		 (D(vmspace, vmspace)->vm_maxsaddr + (size_t)maxssiz) >=
		 (caddr_t)vme->end)
d814 1
a814 2

	else if ((vme->protection & rwx) == rwx && !heapfound) {
d818 1
a818 3
	}

	else
d870 1
a870 1
	struct nchashhead _ncpp, *ncpp; 
d901 1
a901 1
				     ncp->nc_nlen != 1))
d915 4
a918 4
		       "%3d [%.*s] (nc_dvpid=%lu, nc_vpid=%lu)\n",
		       ncp->nc_vp, ncp->nc_dvp,
		       ncp->nc_nlen, ncp->nc_nlen, ncp->nc_name,
		       ncp->nc_dvpid, ncp->nc_vpid);
d923 1
a923 1
	
@


1.4
log
@printing (null) is not so useful.  instead print names of missing symbols
with a useful message.
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.3 2004/02/17 20:13:53 tedu Exp $ */
d195 1
a207 1
	extern char *__progname;
d238 2
d257 1
a257 4
			fprintf(stderr, "usage: %s [-adlmPsv] [-D number] "
				"[-M core] [-N system] [-p pid] [pid ...]\n",
				__progname);
			exit(1);
d285 2
d693 1
a693 1
			strcat(prot, "/read");
d695 1
a695 1
			strcat(prot, "/write");
d697 1
a697 1
			strcat(prot, "/exec");
d936 10
@


1.3
log
@malloc checks, strlcpy.  based on patch from Vink Joris <nimadeus@@pandora.be>
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.2 2004/02/16 08:57:58 tedu Exp $ */
d484 2
a485 2
		if (nl[i].n_value == 0)
			printf("%s\n", nl[i].n_name);
@


1.2
log
@catch all vnode types
@
text
@d1 1
a1 1
/*	$OpenBSD: procmap.c,v 1.1 2004/02/16 08:54:34 tedu Exp $ */
d881 2
d884 1
a884 1
		sizeof(nchashtbl) * (int)nchash);
d924 2
d932 1
a932 2
	strncpy(ce->ce_name, ncp->nc_name, sizeof(ce->ce_name));
	ce->ce_name[MIN(ce->ce_nlen, sizeof(ce->ce_name) - 1)] = '\0';
@


1.1
log
@rough cut of netbsd's pmap process memory map inspector.
initially from drahn@@, renamed to procmap to avoid conflict with
unrelated pmap(9).
works more or less as advertised, could definitely use some work though.
would be really nice if somebody made it use sysctl and not kmem.
more or less ok deraadt@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d623 1
@

