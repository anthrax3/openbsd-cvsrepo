head	1.24;
access;
symbols
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.6
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.26
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.22
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.20
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.18
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.16
	OPENBSD_5_0:1.18.0.14
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.12
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.10
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.6
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.4
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.09.01.10.02.13;	author tedu;	state Exp;
branches;
next	1.23;
commitid	petHaVosCy1ocvZp;

1.23
date	2016.09.01.10.00.38;	author tedu;	state Exp;
branches;
next	1.22;
commitid	vjLcvBltUiClWw6d;

1.22
date	2015.03.11.18.12.27;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	rVwhnU1eXVt1OP97;

1.21
date	2015.01.19.18.01.11;	author miod;	state Exp;
branches;
next	1.20;
commitid	UxVYXvGvXb4Uzvj6;

1.20
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	Uu5nFG3wCl0LACBb;

1.19
date	2014.07.24.19.19.26;	author miod;	state Exp;
branches;
next	1.18;
commitid	W6DcsexcyTvWU55k;

1.18
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.14.20.38.32;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.12.20.54.54;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.07.13.54.43;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.04.23.28.26;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.02.02.29.27;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.09.16.22.02;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.26.16.09.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.08.16.50.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.14.04.21.54;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.28.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.20.20.42.25;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.30.16.00.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.07.08.22.13.26;	author deraadt;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	96.07.22.02.01.50;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.24.09.20.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.21;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.33;	author deraadt;	state Exp;
branches;
next	;

1.5.8.1
date	2000.10.06.20.21.00;	author jason;	state Exp;
branches;
next	;


desc
@@


1.24
log
@now that openprom is always 1, remove conditionals
@
text
@/*	$OpenBSD: main.c,v 1.23 2016/09/01 10:00:38 tedu Exp $	*/
/*	$NetBSD: main.c,v 1.3 1996/05/16 16:00:55 thorpej Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <err.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


#include <machine/openpromio.h>

#include "defs.h"

static	void action(char *);
static	void dump_prom(void);
static	void usage(void);

char	*path_eeprom = "/dev/eeprom";
char	*path_openprom = "/dev/openprom";
int	fix_checksum = 0;
int	ignore_checksum = 0;
int	update_checksums = 0;
int	cksumfail = 0;
u_short	writecount;
int	eval = 0;
int	print_tree = 0;
int	verbose = 0;

extern	char *__progname;

int
main(int argc, char *argv[])
{
	int ch, do_stdin = 0;
	char *cp, line[BUFSIZE];
	char *optstring = "cf:ipvN:-";

	while ((ch = getopt(argc, argv, optstring)) != -1)
		switch (ch) {
		case '-':
			do_stdin = 1;
			break;

		case 'c':
			fix_checksum = 1;
			break;

		case 'f':
			path_eeprom = path_openprom = optarg;
			break;

		case 'i':
			ignore_checksum = 1;
			break;

		case 'p':
			print_tree = 1;
			break;

		case 'v':
			verbose = 1;
			break;

		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (print_tree) {
		op_tree();
		exit(0);
	}

	if (do_stdin) {
		while (fgets(line, BUFSIZE, stdin) != NULL) {
			if (line[0] == '\n')
				continue;
			if ((cp = strrchr(line, '\n')) != NULL)
				*cp = '\0';
			action(line);
		}
		if (ferror(stdin))
			err(++eval, "stdin");
	} else {
		if (argc == 0) {
			dump_prom();
			exit(eval + cksumfail);
		}

		while (argc) {
			action(*argv);
			++argv;
			--argc;
		}
	}

	exit(eval + cksumfail);
}

/*
 * Separate the keyword from the argument (if any), find the keyword in
 * the table, and call the corresponding handler function.
 */
static void
action(char *line)
{
	char *keyword, *arg, *cp;
	struct keytabent *ktent;

	keyword = strdup(line);
	if (!keyword)
		errx(1, "out of memory");
	if ((arg = strrchr(keyword, '=')) != NULL)
		*arg++ = '\0';

	/*
	 * The whole point of the Openprom is that one
	 * isn't required to know the keywords.  With this
	 * in mind, we just dump the whole thing off to
	 * the generic op_handler.
	 */
	if ((cp = op_handler(keyword, arg)) != NULL)
		warnx("%s", cp);
}

/*
 * Dump the contents of the prom corresponding to all known keywords.
 */
static void
dump_prom(void)
{
	struct keytabent *ktent;

	/*
	 * We have a special dump routine for this.
	 */
	op_dump();
}

static void
usage(void)
{

	fprintf(stderr,
	    "usage: %s [-cipv] [-f device] [field[=value] ...]\n",
	    __progname);
	exit(1);
}
@


1.23
log
@remove sparc support
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2015/03/11 18:12:27 deraadt Exp $	*/
a55 1
int	use_openprom = 0;
d101 1
a101 2
	use_openprom = 1;
	if (print_tree && use_openprom) {
d148 8
a155 14
	if (use_openprom) {
		/*
		 * The whole point of the Openprom is that one
		 * isn't required to know the keywords.  With this
		 * in mind, we just dump the whole thing off to
		 * the generic op_handler.
		 */
		if ((cp = op_handler(keyword, arg)) != NULL)
			warnx("%s", cp);
		return;
	}

	warnx("unknown keyword %s", keyword);
	++eval;
d166 4
a169 6
	if (use_openprom) {
		/*
		 * We have a special dump routine for this.
		 */
		op_dump();
	}
@


1.22
log
@drop setgid kmem.  If you want to play with eeprom, you generally
need to be root
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2015/01/19 18:01:11 miod Exp $	*/
a38 8
#if defined(__sparc__) && !defined(__sparc64__)
#include <fcntl.h>
#include <limits.h>
#include <sys/sysctl.h>
#include <machine/cpu.h>
#include <machine/eeprom.h>
#include <machine/param.h>
#endif /* __sparc__ && !__sparc64__ */
a43 36
#if defined(__sparc__) && !defined(__sparc64__)
static	char *nlistf = NULL;

struct	keytabent eekeytab[] = {
#ifndef SMALL
	{ "hwupdate",		0x10,	ee_hwupdate },
#else
	{ "hwupdate",		0x00,	ee_notsupp },
#endif
	{ "memsize",		0x14,	ee_num8 },
	{ "memtest",		0x15,	ee_num8 },
	{ "scrsize",		0x16,	ee_screensize },
	{ "watchdog_reboot",	0x17,	ee_truefalse },
	{ "default_boot",	0x18,	ee_truefalse },
	{ "bootdev",		0x19,	ee_bootdev },
	{ "kbdtype",		0x1e,	ee_kbdtype },
	{ "console",		0x1f,	ee_constype },
	{ "keyclick",		0x21,	ee_truefalse },
	{ "diagdev",		0x22,	ee_bootdev },
	{ "diagpath",		0x28,	ee_diagpath },
	{ "columns",		0x50,	ee_num8 },
	{ "rows",		0x51,	ee_num8 },
	{ "ttya_use_baud",	0x58,	ee_truefalse },
	{ "ttya_baud",		0x59,	ee_num16 },
	{ "ttya_no_rtsdtr",	0x5b,	ee_truefalse },
	{ "ttyb_use_baud",	0x60,	ee_truefalse },
	{ "ttyb_baud",		0x61,	ee_num16 },
	{ "ttyb_no_rtsdtr",	0x63,	ee_truefalse },
	{ "banner",		0x68,	ee_banner },
	{ "secure",		0,	ee_notsupp },
	{ "bad_login",		0,	ee_notsupp },
	{ "password",		0,	ee_notsupp },
	{ NULL,			0,	ee_notsupp },
};
#endif /* __sparc__ && !__sparc64__ */

a46 3
#if defined(__sparc__) && !defined(__sparc64__)
static	int getcputype(void);
#endif /* __sparc__ && !__sparc64__ */
a94 6
#if defined(__sparc__) && !defined(__sparc64__)
		case 'N':
			nlistf = optarg;
			break;
#endif /* __sparc__ && !__sparc64__ */

d102 1
a102 4
#if defined(__sparc__) && !defined(__sparc64__)
	if (getcputype() != CPU_SUN4)
#endif /* __sparc__ && !__sparc64__ */
		use_openprom = 1;
a107 8
#if defined(__sparc__) && !defined(__sparc64__)
	if (use_openprom == 0) {
		ee_verifychecksums();
		if (fix_checksum || cksumfail)
			exit(cksumfail);
	}
#endif /* __sparc__ && !__sparc64__ */

a130 8
#if defined(__sparc__) && !defined(__sparc64__)
	if (use_openprom == 0)
		if (update_checksums) {
			++writecount;
			ee_updatechecksums();
		}
#endif /* __sparc__ && !__sparc64__ */

a133 18
#if defined(__sparc__) && !defined(__sparc64__)
static int
getcputype(void)
{
	int mib[2];
	size_t len;
	int cputype;

	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CPUTYPE;
	len = sizeof(cputype);
	if (sysctl(mib, 2, &cputype, &len, NULL, 0) < 0)
		err(1, "sysctl(machdep.cputype)");

	return (cputype);
}
#endif /* __sparc__ && !__sparc64__ */

a160 9
#if defined(__sparc__) && !defined(__sparc64__)
	  else
		for (ktent = eekeytab; ktent->kt_keyword != NULL; ++ktent) {
			if (strcmp(ktent->kt_keyword, keyword) == 0) {
				(*ktent->kt_handler)(ktent, arg);
				return; 
			}
		}
#endif /* __sparc__ && !__sparc64__ */
a179 5
#if defined(__sparc__) && !defined(__sparc64__)
	  else
		for (ktent = eekeytab; ktent->kt_keyword != NULL; ++ktent)
			(*ktent->kt_handler)(ktent, NULL);
#endif /* __sparc__ && !__sparc64__ */
a185 5
#if defined(__sparc__) && !defined(__sparc64__)
	fprintf(stderr,
	    "usage: %s [-cipv] [-f device] [-N system] [field[=value] ...]\n",
	    __progname);
#else
a188 1
#endif /* __sparc__ && !__sparc64__ */
@


1.21
log
@sparc also needs <machine/param.h> for CPU_SUN*.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2015/01/16 06:40:16 deraadt Exp $	*/
a113 1
	gid_t gid;
a155 5
	if (nlistf != NULL) {
		gid = getgid();
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");
	}
@


1.20
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2014/07/24 19:19:26 miod Exp $	*/
d45 1
@


1.19
log
@Shunt hwupdate property decoding in sparc's old prom (sun4 only) if
defined(SMALL).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2008/06/26 05:42:21 ray Exp $	*/
a32 1
#include <sys/param.h>
@


1.18
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2007/11/14 20:38:32 kettenis Exp $	*/
d56 1
d58 3
@


1.17
log
@We don't have /dev/eeprom on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2007/11/12 20:54:54 kettenis Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.16
log
@Make this compile on macppc (OpenPROM support only) and build it there.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2007/09/07 13:54:43 jmc Exp $	*/
d47 1
a47 1
#ifdef __sparc__
d53 1
a53 1
#endif
d59 1
a59 1
#ifdef __sparc__
a65 3
#ifdef __sparc64__
	{ "scrsize",		0x16,	ee_notsupp },
#else
a66 1
#endif
a70 3
#ifdef __sparc64__
	{ "console",		0x1f,	ee_notsupp },
#else
a71 1
#endif
d89 1
a89 1
#endif
d94 1
a94 1
#ifdef __sparc__
d96 1
a96 1
#endif /* __sparc__ */
d146 1
a146 1
#ifdef __sparc__
d150 1
a150 1
#endif
d159 1
a159 1
#ifdef __sparc__
d166 1
a166 1
#endif /* __sparc__ */
d173 1
a173 1
#ifdef __sparc__
d179 1
a179 1
#endif
d204 1
a204 1
#ifdef __sparc__
d210 1
a210 1
#endif
d215 1
a215 1
#ifdef __sparc__
d231 1
a231 1
#endif /* __sparc__ */
d260 1
a260 1
#ifdef __sparc__
d268 1
a268 1
#endif /* __sparc__ */
d288 1
a288 1
#ifdef __sparc__
d292 1
a292 1
#endif /* __sparc__ */
d299 1
a299 1
#ifdef __sparc__
d307 1
a307 1
#endif /* __sparc__ */
@


1.15
log
@some small cleanup, including standard synopsis/usage and sort options;
ok fgsch deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2007/09/04 23:28:26 fgsch Exp $	*/
d52 2
d57 3
a60 5
#endif /* __sparc__ */

#include <machine/eeprom.h>

#include "defs.h"
d97 1
a124 1
#ifdef __sparc__
a126 3
#else
	char *optstring = "cf:i-";
#endif /* __sparc__ */
d145 1
a145 1
#ifdef __sparc__
d154 1
d158 1
a158 2

#endif /* __sparc__ */
d174 1
a179 1
#endif /* __sparc__ */
d181 1
d187 1
d212 1
d218 1
a256 1
#ifdef __sparc__
d267 3
a269 2
	} else
#endif /* __sparc__ */
d276 1
a289 1
#ifdef __sparc__
d295 3
a297 2
	} else
#endif /* __sparc__ */
d300 1
d313 1
a313 1
	    "usage: %s [-ci] [-f device] [field[=value] ...]\n",
@


1.14
log
@add support to print the derivated tree from the OpenPROM (alas devinfo or
prtconf); ok kettenis@@.
thanks to the various people who helped me test in different sparc* machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2005/05/02 02:29:27 djm Exp $	*/
d305 3
a307 3
	fprintf(stderr, "usage: %s %s %s\n", __progname,
	    "[-] [-c] [-f device] [-i] [-p] [-v]",
	    "[-N system] [field[=value] ...]");
d309 3
a311 2
	fprintf(stderr, "usage: %s %s\n", __progname,
	    "[-] [-c] [-f device] [-i] [field[=value] ...]");
@


1.13
log
@more setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2004/07/09 16:22:02 deraadt Exp $	*/
d44 1
d55 1
a55 1
static	char *system = NULL;
d114 1
d126 1
a126 1
	char *optstring = "cf:ivN:-";
d149 4
d158 1
a158 1
			system = optarg;
d171 1
a171 1
	if (system != NULL) {
d178 4
d306 1
a306 1
	    "[-] [-c] [-f device] [-i] [-v]",
@


1.12
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2003/09/26 16:09:27 deraadt Exp $	*/
d123 1
d166 3
a168 2
		setegid(getgid());
		setgid(getgid());
@


1.11
log
@check strdup failure; ok anil millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2002/12/08 16:50:07 millert Exp $	*/
d118 1
a118 3
main(argc, argv)
	int argc;
	char **argv;
d212 1
a212 1
getcputype()
d233 1
a233 2
action(line)
	char *line;
d272 1
a272 1
dump_prom()
d289 1
a289 1
usage()
@


1.10
log
@GNU semantics say that if optstring begins with '-' then
each non-option shall be treated as arguments to option '\1'.

BSD getopt match '-' in optstring with a '-' on the command line.
This is used to support deprecated options like "su -" that would
otherwise prevent the use of getopt().

Resolving this simply requires that the leading '-' be moved somewhere
else (I moved it to the end of optstring) since position within
optstring is not meaningful.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2002/06/14 04:21:54 art Exp $	*/
d242 2
@


1.9
log
@Get cpu type through sysctl. no more need for kvm.

miod says it still needs to be setgid kmem and I don't have time to check
the archives for the reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2002/02/16 21:28:02 millert Exp $	*/
d125 1
a125 1
	char *optstring = "-cf:ivN:";
d127 1
a127 1
	char *optstring = "-cf:i";
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2001/09/20 20:42:25 jason Exp $	*/
a47 1
#include <kvm.h>
d49 2
a50 1
#include <nlist.h>
a53 6
struct	nlist nl[] = {
	{ "_cputyp" },
#define SYM_CPUTYP	0
	{ NULL },
};

a212 5
#define KVM_ABORT(kd, str) {						\
	(void)kvm_close((kd));						\
	errx(1, "%s: %s", (str), kvm_geterr((kd)));			\
}

d216 2
a217 1
	char errbuf[_POSIX2_LINE_MAX];
a218 12
	kvm_t *kd;

	bzero(errbuf, sizeof(errbuf));

	if ((kd = kvm_openfiles(system, NULL, NULL, O_RDONLY, errbuf)) == NULL)
		errx(1, "can't open kvm: %s", errbuf);

	setegid(getgid());
	setgid(getgid());

	if (kvm_nlist(kd, nl))
		KVM_ABORT(kd, "can't read symbol table");
d220 5
a224 3
	if (kvm_read(kd, nl[SYM_CPUTYP].n_value, (char *)&cputype,
	    sizeof(cputype)) != sizeof(cputype))
		KVM_ABORT(kd, "can't determine cpu type");
a225 1
	(void)kvm_close(kd);
@


1.7
log
@sparc64 support
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2000/06/30 16:00:25 millert Exp $	*/
d103 3
a105 3
static	void action __P((char *));
static	void dump_prom __P((void));
static	void usage __P((void));
d107 1
a107 1
static	int getcputype __P((void));
@


1.6
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1998/07/08 22:13:26 deraadt Exp $	*/
d71 3
d75 1
d80 3
d84 1
@


1.5
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1996/07/22 02:01:50 deraadt Exp $	*/
d267 1
a267 1
			warnx(cp);
@


1.5.8.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1998/07/08 22:13:26 deraadt Exp $	*/
d267 1
a267 1
			warnx("%s", cp);
@


1.4
log
@setgid back; from kashmir@@umiacs.UMD.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1996/05/24 09:20:44 deraadt Exp $	*/
d164 2
a165 1
	if (system != NULL)
d167 1
d227 3
@


1.3
log
@fix multi-arg bug
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d164 2
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d2 1
a2 1
/*	$NetBSD: main.c,v 1.2 1996/02/28 01:13:26 thorpej Exp $	*/
d191 1
a191 1
			action(argv[argc - 1]);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: main.c,v 1.1 1995/07/13 18:15:44 thorpej Exp $	*/
d4 2
a5 2
/*
 * Copyright (c) 1995 Jason R. Thorpe.
d8 3
d21 5
a25 4
 *	This product includes software developed for the NetBSD Project
 *	by Jason R. Thorpe.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d27 11
a37 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
