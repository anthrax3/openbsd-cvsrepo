head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.28
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.26
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.22
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.20
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.18
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.16
	OPENBSD_5_0:1.12.0.14
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.12
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.10
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.6
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.22
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.20
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	z3HrihslRYb4HqW9;

1.13
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.12;
commitid	yCis8OrOsfixbKpI;

1.12
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.12.20.54.54;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.04.23.28.26;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.06.16.12.48;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.09.16.22.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.27.10.36.01;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.09.11.24.31;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.28.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.08.31.13.12.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.31.12.56.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@/*	$OpenBSD: ophandlers.c,v 1.13 2014/11/18 20:54:28 krw Exp $	*/
/*	$NetBSD: ophandlers.c,v 1.2 1996/02/28 01:13:30 thorpej Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <vis.h>

#include <machine/openpromio.h>

#include "defs.h"

extern	char *path_openprom;
extern	int eval;
extern	int verbose;

static	char err_str[BUFSIZE];

static	void op_notsupp(struct extabent *, struct opiocdesc *, char *);
static	void op_print(char *);

/*
 * There are several known fields that I either don't know how to
 * deal with or require special treatment.
 */
static	struct extabent opextab[] = {
	{ "security-password",		op_notsupp },
	{ "security-mode",		op_notsupp },
	{ "oem-logo",			op_notsupp },
	{ NULL,				op_notsupp },
};

#define BARF(str1, str2) {						\
	snprintf(err_str, sizeof err_str, "%s: %s", (str1), (str2));	\
	++eval;								\
	return (err_str);						\
};

char *
op_handler(char *keyword, char *arg)
{
	struct opiocdesc opio;
	struct extabent *ex;
	char opio_buf[BUFSIZE];
	int fd, optnode;

	if ((fd = open(path_openprom, arg ? O_RDWR : O_RDONLY, 0640)) < 0)
		BARF(path_openprom, strerror(errno));

	/* Check to see if it's a special-case keyword. */
	for (ex = opextab; ex->ex_keyword != NULL; ++ex)
		if (strcmp(ex->ex_keyword, keyword) == 0)
			break;

	if (ioctl(fd, OPIOCGETOPTNODE, (char *)&optnode) < 0)
		BARF("OPIOCGETOPTNODE", strerror(errno));

	bzero(&opio_buf[0], sizeof(opio_buf));
	bzero(&opio, sizeof(opio));
	opio.op_nodeid = optnode;
	opio.op_name = keyword;
	opio.op_namelen = strlen(opio.op_name);

	if (arg) {
		if (verbose) {
			printf("old: ");

			opio.op_buf = &opio_buf[0];
			opio.op_buflen = sizeof(opio_buf);
			if (ioctl(fd, OPIOCGET, (char *)&opio) < 0)
				BARF("OPIOCGET", strerror(errno));

			if (opio.op_buflen <= 0) {
				printf("nothing available for %s\n", keyword);
				goto out;
			}

			if (ex->ex_keyword != NULL)
				(*ex->ex_handler)(ex, &opio, NULL);
			else
				op_print(opio.op_buf);
		}
 out:
		if (ex->ex_keyword != NULL)
			(*ex->ex_handler)(ex, &opio, arg);
		else {
			opio.op_buf = arg;
			opio.op_buflen = strlen(arg);
		}

		if (ioctl(fd, OPIOCSET, (char *)&opio) < 0)
			BARF("invalid keyword", keyword);

		if (verbose) {
			printf("new: ");
			if (ex->ex_keyword != NULL)
				(*ex->ex_handler)(ex, &opio, NULL);
			else
				op_print(opio.op_buf);
		}
	} else {
		opio.op_buf = &opio_buf[0];
		opio.op_buflen = sizeof(opio_buf);
		if (ioctl(fd, OPIOCGET, (char *)&opio) < 0)
			BARF("OPIOCGET", strerror(errno));

		if (opio.op_buflen <= 0) {
			snprintf(err_str, sizeof err_str,
			    "nothing available for %s",
			    keyword);
			return (err_str);
		}

		if (ex->ex_keyword != NULL)
			(*ex->ex_handler)(ex, &opio, NULL);
		else {
			printf("%s=", keyword);
			op_print(opio.op_buf);
		}
	}

	(void)close(fd);
	return (NULL);
}

/* ARGSUSED */
static void
op_notsupp(struct extabent *exent, struct opiocdesc *opiop, char *arg)
{

	warnx("property `%s' not yet supported", exent->ex_keyword);
}

/*
 * XXX: This code is quite ugly.  You have been warned.
 * (Really!  This is the only way I could get it to work!)
 */
void
op_dump(void)
{
	struct opiocdesc opio1, opio2;
	struct extabent *ex;
	char buf1[BUFSIZE], buf2[BUFSIZE], buf3[BUFSIZE], buf4[BUFSIZE];
	int fd, optnode;

	if ((fd = open(path_openprom, O_RDONLY, 0640)) < 0)
		err(1, "open: %s", path_openprom);

	if (ioctl(fd, OPIOCGETOPTNODE, (char *)&optnode) < 0)
		err(1, "OPIOCGETOPTNODE");

	bzero(&opio1, sizeof(opio1));

	/* This will grab the first property name from OPIOCNEXTPROP. */
	bzero(buf1, sizeof(buf1));
	bzero(buf2, sizeof(buf2));

	opio1.op_nodeid = opio2.op_nodeid = optnode;

	opio1.op_name = buf1;
	opio1.op_buf = buf2;

	opio2.op_name = buf3;
	opio2.op_buf = buf4;

	/*
	 * For reference: opio1 is for obtaining the name.  Pass the
	 * name of the last property read in op_name, and the next one
	 * will be returned in op_buf.  To get the first name, pass
	 * an empty string.  There are no more properties when an
	 * empty string is returned.
	 *
	 * opio2 is for obtaining the value associated with that name.
	 * For some crazy reason, it seems as if we need to do all
	 * of that gratuitious zapping and copying.  *sigh*
	 */
	for (;;) {
		opio1.op_namelen = strlen(opio1.op_name);
		opio1.op_buflen = sizeof(buf2);

		if (ioctl(fd, OPIOCNEXTPROP, (char *)&opio1) < 0)
			err(1, "ioctl: OPIOCNEXTPROP");

		/*
		 * The name of the property we wish to get the
		 * value for has been stored in the value field
		 * of opio1.  If the length of the name is 0, there
		 * are no more properties left.
		 */
		strlcpy(opio2.op_name, opio1.op_buf, sizeof(buf3));
		opio2.op_namelen = strlen(opio2.op_name);

		if (opio2.op_namelen == 0) {
			(void)close(fd);
			return;
		}

		bzero(opio2.op_buf, sizeof(buf4));
		opio2.op_buflen = sizeof(buf4);

		if (ioctl(fd, OPIOCGET, (char *)&opio2) < 0)
			err(1, "ioctl: OPIOCGET");

		for (ex = opextab; ex->ex_keyword != NULL; ++ex)
			if (strcmp(ex->ex_keyword, opio2.op_name) == 0)
				break;

		if (ex->ex_keyword != NULL)
			(*ex->ex_handler)(ex, &opio2, NULL);
		else {
			printf("%s=", opio2.op_name);
			op_print(opio2.op_buf);
		}

		/*
		 * Place the name of the last read value back into
		 * opio1 so that we may obtain the next name.
		 */
		bzero(opio1.op_name, sizeof(buf1));
		bzero(opio1.op_buf, sizeof(buf2));
		strlcpy(opio1.op_name, opio2.op_name, sizeof(buf1));
	}
	/* NOTREACHED */
}

static void
op_print(char *op_buf)
{
	char *vistr;
	size_t size;

	size = 1 + 4 * strlen(op_buf);
	vistr = malloc(size);
	if (vistr == NULL)
		printf("(out of memory)\n");
	else {
		strnvis(vistr, op_buf, size, VIS_NL | VIS_TAB | VIS_OCTAL);
		printf("%s\n", vistr);
		free(vistr);
	}
}
@


1.13
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ophandlers.c,v 1.12 2008/06/26 05:42:21 ray Exp $	*/
d268 1
a268 1
	vistr = (char *)malloc(size);
@


1.12
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ophandlers.c,v 1.11 2007/11/12 20:54:54 kettenis Exp $	*/
a40 1
#include <string.h>
@


1.11
log
@Make this compile on macppc (OpenPROM support only) and build it there.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ophandlers.c,v 1.10 2007/09/04 23:28:26 fgsch Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.10
log
@add support to print the derivated tree from the OpenPROM (alas devinfo or
prtconf); ok kettenis@@.
thanks to the various people who helped me test in different sparc* machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: ophandlers.c,v 1.9 2005/03/06 16:12:48 miod Exp $	*/
a51 1
#include <machine/eeprom.h>
@


1.9
log
@Filter openprom environment strings with strnvis(); ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ophandlers.c,v 1.8 2004/07/09 16:22:02 deraadt Exp $	*/
d49 1
@


1.8
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: ophandlers.c,v 1.7 2003/11/27 10:36:01 henning Exp $	*/
d47 1
d49 1
d63 1
d124 1
a124 1
				printf("%s\n", opio.op_buf);
d142 1
a142 1
				printf("%s\n", opio.op_buf);
d159 4
a162 2
		else
			printf("%s=%s\n", keyword, opio.op_buf);
d253 4
a256 2
		else
			printf("%s=%s\n", opio2.op_name, opio2.op_buf);
d267 17
@


1.7
log
@fix printf
From: Alf Schlichting <leopold-bloom@@foni.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: ophandlers.c,v 1.6 2002/12/09 11:24:31 miod Exp $	*/
d80 1
a80 2
op_handler(keyword, arg)
	char *keyword, *arg;
d166 1
a166 4
op_notsupp(exent, opiop, arg)
	struct extabent *exent;
	struct opiocdesc *opiop;
	char *arg;
d177 1
a177 1
op_dump()
@


1.6
log
@Use strlcpy rather than unsafe string functions, especially in unreadable code.
Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ophandlers.c,v 1.5 2002/02/16 21:28:02 millert Exp $	*/
d115 1
a115 1
				printf("nothing available for %s\n");
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ophandlers.c,v 1.4 1996/08/31 13:12:12 deraadt Exp $	*/
d232 1
a232 1
		sprintf(opio2.op_name, opio1.op_buf);
d261 1
a261 1
		sprintf(opio1.op_name, opio2.op_name);
@


1.4
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ophandlers.c,v 1.3 1996/08/31 12:56:08 deraadt Exp $	*/
d60 1
a60 1
static	void op_notsupp __P((struct extabent *, struct opiocdesc *, char *));
@


1.3
log
@buf oflow in some more "NetBSD Foundation" code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
	snprintf(err_str, sizeof err_str "%s: %s", (str1), (str2));	\
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d74 1
a74 1
	sprintf(err_str, "%s: %s", (str1), (str2));			\
d149 2
a150 1
			sprintf(err_str, "nothing available for %s",
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ophandlers.c,v 1.1 1995/07/13 18:17:28 thorpej Exp $	*/
d4 2
a5 2
/*
 * Copyright (c) 1995 Jason R. Thorpe.
d8 3
d21 5
a25 4
 *	This product includes software developed for the NetBSD Project
 *	by Jason R. Thorpe.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d27 11
a37 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
