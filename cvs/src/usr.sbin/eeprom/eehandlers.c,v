head	1.21;
access;
symbols
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.15.0.22
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.20
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.18
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.16
	OPENBSD_5_0:1.15.0.14
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.12
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.10
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.10
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.10.0.8
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.6
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.14
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	z3HrihslRYb4HqW9;

1.20
date	2015.01.15.20.48.51;	author miod;	state Exp;
branches;
next	1.19;
commitid	jPvrfqTTpxA45UdY;

1.19
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.18;
commitid	yCis8OrOsfixbKpI;

1.18
date	2014.07.24.19.19.26;	author miod;	state Exp;
branches;
next	1.17;
commitid	W6DcsexcyTvWU55k;

1.17
date	2013.12.03.01.48.37;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2013.11.28.18.26.47;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.25.15.15.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.03.20.02.10;	author moritz;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.01.18.32.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.09.16.22.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.29.09.48.14;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.28.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.20.20.42.25;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.30.16.00.24;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.08.31.12.56.06;	author deraadt;	state Exp;
branches
	1.5.16.1;
next	1.4;

1.4
date	96.08.31.12.42.49;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.25.15.55.18;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.10.24.14.45.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.33;	author deraadt;	state Exp;
branches;
next	;

1.5.16.1
date	2000.10.06.20.21.00;	author jason;	state Exp;
branches;
next	;


desc
@@


1.21
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@/*	$OpenBSD: eehandlers.c,v 1.20 2015/01/15 20:48:51 miod Exp $	*/
/*	$NetBSD: eehandlers.c,v 1.2 1996/02/28 01:13:22 thorpej Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#include <machine/eeprom.h>
#include <machine/openpromio.h>

#include "defs.h"

extern	char *path_eeprom;
extern	int eval;
extern	int update_checksums;
extern	int ignore_checksum;
extern	int fix_checksum;
extern	int cksumfail;
extern	u_short writecount;

extern	time_t get_date(char *);

static	char err_str[BUFSIZE];

static	void badval(struct keytabent *, char *);
static	int doio(struct keytabent *, u_char *, ssize_t, int);

#define BARF(kt) {							\
	badval((kt), arg);						\
	++eval;								\
	return;								\
}

#define FAILEDREAD(kt) {						\
	warnx("%s", err_str);						\
	warnx("failed to read field `%s'", (kt)->kt_keyword);		\
	++eval;								\
	return;								\
}

#define FAILEDWRITE(kt) {						\
	warnx("%s", err_str);						\
	warnx("failed to update field `%s'", (kt)->kt_keyword);		\
	++eval;								\
	return;								\
}

#ifndef SMALL
void
ee_hwupdate(struct keytabent *ktent, char *arg)
{
	time_t t;
	char *cp, *cp2;

	if (arg) {
		if ((strcmp(arg, "now") == 0) ||
		    (strcmp(arg, "today") == 0)) {
			if ((t = time(NULL)) == (time_t)(-1)) {
				warnx("can't get current time");
				++eval;
				return;
			}
		} else
			if ((t = get_date(arg)) == (time_t)(-1))
				BARF(ktent);

		if (doio(ktent, (u_char *)&t, sizeof(t), IO_WRITE))
			FAILEDWRITE(ktent);
	} else
		if (doio(ktent, (u_char *)&t, sizeof(t), IO_READ))
			FAILEDREAD(ktent);

	cp = ctime(&t);
	if ((cp2 = strrchr(cp, '\n')) != NULL)
		*cp2 = '\0';

	printf("%s=%lld (%s)\n", ktent->kt_keyword, (long long)t, cp);
}
#endif

void
ee_num8(struct keytabent *ktent, char *arg)
{
	u_char num8 = 0;
	u_int num32;
	int i;

	if (arg) {
		for (i = 0; i < (strlen(arg) - 1); ++i)
			if (!isdigit((unsigned char)arg[i]))
				BARF(ktent);
		num32 = atoi(arg);
		if (num32 > 0xff)
			BARF(ktent);
		num8 += num32;
		if (doio(ktent, &num8, sizeof(num8), IO_WRITE))
			FAILEDWRITE(ktent);
	} else
		if (doio(ktent, &num8, sizeof(num8), IO_READ))
			FAILEDREAD(ktent);

	printf("%s=%d\n", ktent->kt_keyword, num8);
}

void
ee_num16(struct keytabent *ktent, char *arg)
{
	u_int16_t num16 = 0;
	u_int num32;
	int i;

	if (arg) {
		for (i = 0; i < (strlen(arg) - 1); ++i)
			if (!isdigit((unsigned char)arg[i]))
				BARF(ktent);
		num32 = atoi(arg);
		if (num32 > 0xffff)
			BARF(ktent);
		num16 += num32;
		if (doio(ktent, (u_char *)&num16, sizeof(num16), IO_WRITE))
			FAILEDWRITE(ktent);
	} else
		if (doio(ktent, (u_char *)&num16, sizeof(num16), IO_READ))
			FAILEDREAD(ktent);

	printf("%s=%d\n", ktent->kt_keyword, num16);
}

static	struct strvaltabent scrsizetab[] = {
	{ "640x480",		EED_SCR_640X480 },
	{ "1152x900",		EED_SCR_1152X900 },
	{ "1024x1024",		EED_SCR_1024X1024 },
	{ "1600x1280",		EED_SCR_1600X1280 },
	{ "1280x1024",		EED_SCR_1280X1024 },
	{ "1440x1440",		EED_SCR_1440X1440 },
	{ NULL,			0 },
};

void
ee_screensize(struct keytabent *ktent, char *arg)
{
	struct strvaltabent *svp;
	u_char scsize;

	if (arg) {
		for (svp = scrsizetab; svp->sv_str != NULL; ++svp)
			if (strcmp(svp->sv_str, arg) == 0)
				break;
		if (svp->sv_str == NULL)
			BARF(ktent);

		scsize = svp->sv_val;
		if (doio(ktent, &scsize, sizeof(scsize), IO_WRITE))
			FAILEDWRITE(ktent);
	} else {
		if (doio(ktent, &scsize, sizeof(scsize), IO_READ))
			FAILEDREAD(ktent);

		for (svp = scrsizetab; svp->sv_str != NULL; ++svp)
			if (svp->sv_val == scsize)
				break;
		if (svp->sv_str == NULL) {
			warnx("unknown %s value %d", ktent->kt_keyword,
			    scsize);
			return;
		}
	}
	printf("%s=%s\n", ktent->kt_keyword, svp->sv_str);
}

static	struct strvaltabent truthtab[] = {
	{ "true",		EE_TRUE },
	{ "false",		EE_FALSE },
	{ NULL,			0 },
};

void
ee_truefalse(struct keytabent *ktent, char *arg)
{
	struct strvaltabent *svp;
	u_char truth;

	if (arg) {
		for (svp = truthtab; svp->sv_str != NULL; ++svp)
			if (strcmp(svp->sv_str, arg) == 0)
				break;
		if (svp->sv_str == NULL)
			BARF(ktent);

		truth = svp->sv_val;
		if (doio(ktent, &truth, sizeof(truth), IO_WRITE))
			FAILEDWRITE(ktent);
	} else {
		if (doio(ktent, &truth, sizeof(truth), IO_READ))
			FAILEDREAD(ktent);

		for (svp = truthtab; svp->sv_str != NULL; ++svp)
			if (svp->sv_val == truth)
				break;
		if (svp->sv_str == NULL) {
			warnx("unknown truth value 0x%x for %s", truth,
			    ktent->kt_keyword);
			return;
		}
	}
	printf("%s=%s\n", ktent->kt_keyword, svp->sv_str);
}

void
ee_bootdev(struct keytabent *ktent, char *arg)
{
	u_char dev[5];
	int i;
	size_t arglen;
	char *cp;

	if (arg) {
		/*
		 * The format of the string we accept is the following:
		 *	cc(n,n,n)
		 * where:
		 *	c -- an alphabetical character [a-z]
		 *	n -- a number in hexadecimal, between 0 and ff,
		 *	     with no leading `0x'.
		 */
		arglen = strlen(arg);
		if (arglen < 9 || arglen > 12 || arg[2] != '(' ||
		     arg[arglen - 1] != ')')
			BARF(ktent);

		/* Handle the first 2 letters. */
		for (i = 0; i < 2; ++i) {
			if (arg[i] < 'a' || arg[i] > 'z')
				BARF(ktent);
			dev[i] = (u_char)arg[i];
		}

		/* Handle the 3 `0x'-less hex values. */
		cp = &arg[3];
		for (i = 2; i < 5; ++i) {
			if (*cp == '\0')
				BARF(ktent);

			if (*cp >= '0' && *cp <= '9')
				dev[i] = *cp++ - '0';
			else if (*cp >= 'a' && *cp <= 'f')
				dev[i] = 10 + (*cp++ - 'a');
			else
				BARF(ktent);

			/* Deal with a second digit. */
			if (*cp >= '0' && *cp <= '9') {
				dev[i] <<= 4;
				dev[i] &= 0xf0;
				dev[i] += *cp++ - '0';
			} else if (*cp >= 'a' && *cp <= 'f') {
				dev[i] <<= 4;
				dev[i] &= 0xf0;
				dev[i] += 10 + (*cp++ - 'a');
			}

			/* Ensure we have the correct delimiter. */
			if ((*cp == ',' && i < 4) || (*cp == ')' && i == 4)) {
				++cp;
				continue;
			} else
				BARF(ktent);
		}
		if (doio(ktent, (u_char *)&dev[0], sizeof(dev), IO_WRITE))
			FAILEDWRITE(ktent);
	} else
		if (doio(ktent, (u_char *)&dev[0], sizeof(dev), IO_READ))
			FAILEDREAD(ktent);

	printf("%s=%c%c(%x,%x,%x)\n", ktent->kt_keyword, dev[0],
	     dev[1], dev[2], dev[3], dev[4]);
}

void
ee_kbdtype(struct keytabent *ktent, char *arg)
{
	u_char kbd = 0;
	u_int kbd2;
	int i;

	if (arg) {
		for (i = 0; i < (strlen(arg) - 1); ++i)
			if (!isdigit((unsigned char)arg[i]))
				BARF(ktent);
		kbd2 = atoi(arg);
		if (kbd2 > 0xff)
			BARF(ktent);
		kbd += kbd2;
		if (doio(ktent, &kbd, sizeof(kbd), IO_WRITE))
			FAILEDWRITE(ktent);
	} else
		if (doio(ktent, &kbd, sizeof(kbd), IO_READ))
			FAILEDREAD(ktent);

	printf("%s=%d (%s)\n", ktent->kt_keyword, kbd, kbd ? "other" : "Sun");
}

static	struct strvaltabent constab[] = {
	{ "b&w",		EED_CONS_BW },
	{ "ttya",		EED_CONS_TTYA },
	{ "ttyb",		EED_CONS_TTYB },
	{ "color",		EED_CONS_COLOR },
	{ "p4opt",		EED_CONS_P4 },
	{ NULL,			0 },
};

void
ee_constype(struct keytabent *ktent, char *arg)
{
	struct strvaltabent *svp;
	u_char cons;

	if (arg) {
		for (svp = constab; svp->sv_str != NULL; ++svp)
			if (strcmp(svp->sv_str, arg) == 0)
				break;
		if (svp->sv_str == NULL)
			BARF(ktent);

		cons = svp->sv_val;
		if (doio(ktent, &cons, sizeof(cons), IO_WRITE))
			FAILEDWRITE(ktent);
	} else {
		if (doio(ktent, &cons, sizeof(cons), IO_READ))
			FAILEDREAD(ktent);

		for (svp = constab; svp->sv_str != NULL; ++svp)
			if (svp->sv_val == cons)
				break;
		if (svp->sv_str == NULL) {
			warnx("unknown type 0x%x for %s", cons,
			    ktent->kt_keyword);
			return;
		}
	}
	printf("%s=%s\n", ktent->kt_keyword, svp->sv_str);

}

void
ee_diagpath(struct keytabent *ktent, char *arg)
{
	char path[40];

	bzero(path, sizeof(path));
	if (arg) {
		if (strlcpy(path, arg, sizeof(path)) >= sizeof(path))
			BARF(ktent);
		if (doio(ktent, (u_char *)&path[0], sizeof(path), IO_WRITE))
			FAILEDWRITE(ktent);
	} else
		if (doio(ktent, (u_char *)&path[0], sizeof(path), IO_READ))
			FAILEDREAD(ktent);

	printf("%s=%s\n", ktent->kt_keyword, path);
}

void
ee_banner(struct keytabent *ktent, char *arg)
{
	char string[80];
	u_char enable;
	struct keytabent kt;

	kt.kt_keyword = "enable_banner";
	kt.kt_offset = EE_BANNER_ENABLE_LOC;
	kt.kt_handler = ee_notsupp;

	bzero(string, sizeof(string));
	if (arg) {
		if (*arg != '\0') {
			enable = EE_TRUE;
			if (strlcpy(string, arg, sizeof(string)) >=
			    sizeof(string))
				BARF(ktent);
			if (doio(ktent, (u_char *)string,
			    sizeof(string), IO_WRITE))
				FAILEDWRITE(ktent);
		} else {
			enable = EE_FALSE;
			if (doio(ktent, (u_char *)string,
			    sizeof(string), IO_READ))
				FAILEDREAD(ktent);
		}

		if (doio(&kt, &enable, sizeof(enable), IO_WRITE))
			FAILEDWRITE(&kt);
	} else {
		if (doio(ktent, (u_char *)string, sizeof(string), IO_READ))
			FAILEDREAD(ktent);
		if (doio(&kt, &enable, sizeof(enable), IO_READ))
			FAILEDREAD(&kt);
	}
	printf("%s=%s (%s)\n", ktent->kt_keyword, string,
	    enable == EE_TRUE ? "enabled" : "disabled");
}

/* ARGSUSED */
void
ee_notsupp(struct keytabent *ktent, char *arg)
{

	warnx("field `%s' not yet supported", ktent->kt_keyword);
}

static void
badval(struct keytabent *ktent, char *arg)
{

	warnx("inappropriate value `%s' for field `%s'", arg,
	    ktent->kt_keyword);
}

static int
doio(struct keytabent *ktent, u_char *buf, ssize_t len, int wr)
{
	int fd, rval = 0;
	u_char *buf2;

	buf2 = calloc(1, len);
	if (buf2 == NULL) {
		snprintf(err_str, sizeof err_str, "memory allocation failed");
		return (1);
	}

	fd = open(path_eeprom, wr == IO_WRITE ? O_RDWR : O_RDONLY, 0640);
	if (fd < 0) {
		snprintf(err_str, sizeof err_str, "open: %s: %s", path_eeprom,
		    strerror(errno));
		free(buf2);
		return (1);
	}

	if (lseek(fd, (off_t)ktent->kt_offset, SEEK_SET) < (off_t)0) {
		snprintf(err_str, sizeof err_str, "lseek: %s: %s", path_eeprom,
		    strerror(errno));
		rval = 1;
		goto done;
	}

	if (read(fd, buf2, len) != len) {
		snprintf(err_str, sizeof err_str, "read: %s: %s", path_eeprom,
		    strerror(errno));
		return (1);
	}

	if (wr == IO_WRITE) {
		if (bcmp(buf, buf2, len) == 0)
			goto done;

		if (lseek(fd, (off_t)ktent->kt_offset, SEEK_SET) < (off_t)0) {
			snprintf(err_str, sizeof err_str, "lseek: %s: %s",
			    path_eeprom, strerror(errno));
			rval = 1;
			goto done;
		}

		++update_checksums;
		if (write(fd, buf, len) < 0) {
			snprintf(err_str, sizeof err_str, "write: %s: %s",
			    path_eeprom, strerror(errno));
			rval = 1;
			goto done;
		}
	} else
		bcopy(buf2, buf, len);

 done:
	free(buf2);
	(void)close(fd);
	return (rval);
}

/*
 * Read from eeLastHwUpdate to just before eeReserved.  Calculate
 * a checksum, and deposit 3 copies of it sequentially starting at
 * eeChecksum[0].  Increment the write count, and deposit 3 copies
 * of it sequentially starting at eeWriteCount[0].
 */
void
ee_updatechecksums(void)
{
	struct keytabent kt;
	u_char checkme[EE_SIZE - EE_HWUPDATE_LOC];
	u_char checksum;
	int i;

	kt.kt_keyword = "eeprom contents";
	kt.kt_offset = EE_HWUPDATE_LOC;
	kt.kt_handler = ee_notsupp;

	if (doio(&kt, checkme, sizeof(checkme), IO_READ)) {
		cksumfail = 1;
		FAILEDREAD(&kt);
	}

	checksum = ee_checksum(checkme, sizeof(checkme));

	kt.kt_keyword = "eeprom checksum";
	for (i = 0; i < 4; ++i) {
		kt.kt_offset = EE_CKSUM_LOC + (i * sizeof(checksum));
		if (doio(&kt, &checksum, sizeof(checksum), IO_WRITE)) {
			cksumfail = 1;
			FAILEDWRITE(&kt);
		}
	}

	kt.kt_keyword = "eeprom writecount";
	for (i = 0; i < 4; ++i) {
		kt.kt_offset = EE_WC_LOC + (i * sizeof(writecount));
		if (doio(&kt, (u_char *)&writecount, sizeof(writecount),
		    IO_WRITE)) {
			cksumfail = 1;
			FAILEDWRITE(&kt);
		}
	}
}

void
ee_verifychecksums(void)
{
	struct keytabent kt;
	u_char checkme[EE_SIZE - EE_HWUPDATE_LOC];
	u_char checksum, ochecksum[3];
	u_short owritecount[3];

	/*
	 * Verify that the EEPROM's write counts match, and update the
	 * global copy for use later.
	 */
	kt.kt_keyword = "eeprom writecount";
	kt.kt_offset = EE_WC_LOC;
	kt.kt_handler = ee_notsupp;

	if (doio(&kt, (u_char *)&owritecount, sizeof(owritecount), IO_READ)) {
		cksumfail = 1;
		FAILEDREAD(&kt);
	}

	if (owritecount[0] != owritecount[1] ||
	    owritecount[0] != owritecount[2]) {
		warnx("eeprom writecount mismatch %s",
		    ignore_checksum ? "(ignoring)" :
		    (fix_checksum ? "(fixing)" : ""));

		if (!ignore_checksum && !fix_checksum) {
			cksumfail = 1;
			return;
		}

		writecount = MAXIMUM(owritecount[0], owritecount[1]);
		writecount = MAXIMUM(writecount, owritecount[2]);
	} else
		writecount = owritecount[0];

	/*
	 * Verify that the EEPROM's checksums match and are correct.
	 */
	kt.kt_keyword = "eeprom checksum";
	kt.kt_offset = EE_CKSUM_LOC;

	if (doio(&kt, ochecksum, sizeof(ochecksum), IO_READ)) {
		cksumfail = 1;
		FAILEDREAD(&kt);
	}

	if (ochecksum[0] != ochecksum[1] ||
	    ochecksum[0] != ochecksum[2]) {
		warnx("eeprom checksum mismatch %s",
		    ignore_checksum ? "(ignoring)" :
		    (fix_checksum ? "(fixing)" : ""));

		if (!ignore_checksum && !fix_checksum) {
			cksumfail = 1;
			return;
		}
	}

	kt.kt_keyword = "eeprom contents";
	kt.kt_offset = EE_HWUPDATE_LOC;

	if (doio(&kt, checkme, sizeof(checkme), IO_READ)) {
		cksumfail = 1;
		FAILEDREAD(&kt);
	}

	checksum = ee_checksum(checkme, sizeof(checkme));

	if (ochecksum[0] != checksum) {
		warnx("eeprom checksum incorrect %s",
		    ignore_checksum ? "(ignoring)" :
		    (fix_checksum ? "(fixing)" : ""));

		if (!ignore_checksum && !fix_checksum) {
			cksumfail = 1;
			return;
		}
	}

	if (fix_checksum)
		ee_updatechecksums();
}

u_char
ee_checksum(u_char *area, size_t len)
{
	u_char sum = 0;

	while (len--)
		sum += *area++;

	return (0x100 - sum);
}
@


1.20
log
@Be sure to print time_t with the appropriate format specifier. Repairs
dump of eeprom variables on sun4.
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.19 2014/11/18 20:54:28 krw Exp $	*/
d461 1
a461 1
	buf2 = (u_char *)calloc(1, len);
@


1.19
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.18 2014/07/24 19:19:26 miod Exp $	*/
d113 1
a113 1
	printf("%s=%d (%s)\n", ktent->kt_keyword, t, cp);
@


1.18
log
@Shunt hwupdate property decoding in sparc's old prom (sun4 only) if
defined(SMALL).
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.17 2013/12/03 01:48:37 millert Exp $	*/
a40 1
#include <string.h>
@


1.17
log
@Kill usage of timeb.h for upcoming removal of libcompat.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.16 2013/11/28 18:26:47 deraadt Exp $	*/
d85 1
d116 1
@


1.16
log
@unsigned char for ctype
ok okan krw
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.15 2008/06/26 05:42:21 ray Exp $	*/
d58 1
a58 2
struct	timeb;
extern	time_t get_date(char *, struct timeb *);
d100 1
a100 1
			if ((t = get_date(arg, NULL)) == (time_t)(-1))
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.14 2008/06/25 15:15:16 deraadt Exp $	*/
d126 1
a126 1
			if (!isdigit(arg[i]))
d150 1
a150 1
			if (!isdigit(arg[i]))
d324 1
a324 1
			if (!isdigit(arg[i]))
@


1.14
log
@no need for sparc/sparc64 ifdefs, since this file is sparc only
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.13 2007/01/03 20:02:10 moritz Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@Fix format string bugs by using strlcpy() instead of
snprintf() and fix truncation checks.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.12 2004/08/01 18:32:17 deraadt Exp $	*/
a52 1
#ifdef __sparc__
a53 1
#endif /* __sparc__ */
a171 1
#ifndef __sparc64__
a212 1
#endif
a345 1
#ifndef __sparc64__
a386 1
#endif
@


1.12
log
@ansi cleanup; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.11 2004/07/09 16:22:02 deraadt Exp $	*/
d401 1
a401 1
		if (strlen(arg) > sizeof(path))
a402 1
		snprintf(path, sizeof path, arg);
a424 2
		if (strlen(arg) > sizeof(string))
			BARF(ktent);
d427 3
a429 1
			snprintf(string, sizeof string, arg);
@


1.11
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.10 2002/05/30 19:09:05 deraadt Exp $	*/
d660 1
a660 3
ee_checksum(area, len)
	u_char *area;
	size_t len;
@


1.10
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.9 2002/05/29 09:48:14 deraadt Exp $	*/
d96 1
a96 3
ee_hwupdate(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d127 1
a127 3
ee_num8(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d151 1
a151 3
ee_num16(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d186 1
a186 3
ee_screensize(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d225 1
a225 3
ee_truefalse(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d257 1
a257 3
ee_bootdev(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d327 1
a327 3
ee_kbdtype(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d361 1
a361 3
ee_constype(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d395 1
a395 3
ee_diagpath(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d414 1
a414 3
ee_banner(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d455 1
a455 3
ee_notsupp(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d462 1
a462 3
badval(ktent, arg)
	struct keytabent *ktent;
	char *arg;
d470 1
a470 5
doio(ktent, buf, len, wr)
	struct keytabent *ktent;
	u_char *buf;
	ssize_t len;
	int wr;
d536 1
a536 1
ee_updatechecksums()
d575 1
a575 1
ee_verifychecksums()
@


1.9
log
@snprintf blah blah blah
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.8 2002/02/16 21:28:02 millert Exp $	*/
d205 1
a205 1
		
d406 1
a406 1
		
d617 1
a617 1
	
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.7 2001/09/20 20:42:25 jason Exp $	*/
d505 1
a505 1
		sprintf(err_str, "memory allocation failed");
@


1.7
log
@sparc64 support
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.6 2000/06/30 16:00:24 millert Exp $	*/
d68 1
a68 1
extern	time_t get_date __P((char *, struct timeb *));
d72 2
a73 2
static	void badval __P((struct keytabent *, char *));
static	int doio __P((struct keytabent *, u_char *, ssize_t, int));
@


1.6
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.5 1996/08/31 12:56:06 deraadt Exp $	*/
d180 1
d224 1
d364 1
d408 1
@


1.5
log
@buf oflow in some more "NetBSD Foundation" code
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.4 1996/08/31 12:42:49 deraadt Exp $	*/
d82 1
a82 1
	warnx(err_str);							\
d89 1
a89 1
	warnx(err_str);							\
@


1.5.16.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: eehandlers.c,v 1.5 1996/08/31 12:56:06 deraadt Exp $	*/
d82 1
a82 1
	warnx("%s", err_str);						\
d89 1
a89 1
	warnx("%s", err_str);						\
@


1.4
log
@buf oflow; from brian@@saturn.net
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d507 1
a507 1
		sprintf(err_str, "open: %s: %s", path_eeprom,
d514 1
a514 1
		sprintf(err_str, "lseek: %s:", path_eeprom,
d521 2
a522 2
		sprintf(err_str, "read: %s: %s", path_eeprom,
		     strerror(errno));
d531 2
a532 2
			sprintf(err_str, "lseek: %s: %s", path_eeprom,
			     strerror(errno));
d539 2
a540 2
			sprintf(err_str, "write: %s: %s", path_eeprom,
			     strerror(errno));
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d417 1
a417 1
		sprintf(path, arg);
d446 1
a446 1
			sprintf(string, arg);
@


1.2
log
@rename to match sun-compatible eeprom.h
@
text
@d1 2
a2 1
/*	$NetBSD: eehandlers.c,v 1.1 1995/07/13 18:10:29 thorpej Exp $	*/
d4 2
a5 2
/*
 * Copyright (c) 1995 Jason R. Thorpe.
d8 3
d21 5
a25 4
 *	This product includes software developed for the NetBSD Project
 *	by Jason R. Thorpe.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d27 11
a37 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.1
log
@Initial revision
@
text
@d176 6
a181 4
	{ "1152x900",		EE_SCR_1152X900 },
	{ "1024x1024",		EE_SCR_1024X1024 },
	{ "1600x1280",		EE_SCR_1600X1280 },
	{ "1440x1440",		EE_SCR_1440X1440 },
d358 5
a362 5
	{ "b&w",		EE_CONS_BW },
	{ "ttya",		EE_CONS_TTYA },
	{ "ttyb",		EE_CONS_TTYB },
	{ "color",		EE_CONS_COLOR },
	{ "p4opt",		EE_CONS_P4OPT },
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
