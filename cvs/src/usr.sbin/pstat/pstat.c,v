head	1.113;
access;
symbols
	OPENBSD_6_1_BASE:1.113
	OPENBSD_6_0:1.107.0.2
	OPENBSD_6_0_BASE:1.107
	OPENBSD_5_9:1.101.0.2
	OPENBSD_5_9_BASE:1.101
	OPENBSD_5_8:1.99.0.4
	OPENBSD_5_8_BASE:1.99
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.90.0.4
	OPENBSD_5_6_BASE:1.90
	OPENBSD_5_5:1.89.0.4
	OPENBSD_5_5_BASE:1.89
	OPENBSD_5_4:1.85.0.2
	OPENBSD_5_4_BASE:1.85
	OPENBSD_5_3:1.82.0.2
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.81.0.2
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.78
	OPENBSD_5_1:1.78.0.4
	OPENBSD_5_0:1.78.0.2
	OPENBSD_5_0_BASE:1.78
	OPENBSD_4_9:1.77.0.6
	OPENBSD_4_9_BASE:1.77
	OPENBSD_4_8:1.77.0.4
	OPENBSD_4_8_BASE:1.77
	OPENBSD_4_7:1.77.0.2
	OPENBSD_4_7_BASE:1.77
	OPENBSD_4_6:1.76.0.4
	OPENBSD_4_6_BASE:1.76
	OPENBSD_4_5:1.75.0.2
	OPENBSD_4_5_BASE:1.75
	OPENBSD_4_4:1.73.0.4
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.73.0.2
	OPENBSD_4_3_BASE:1.73
	OPENBSD_4_2:1.64.0.6
	OPENBSD_4_2_BASE:1.64
	OPENBSD_4_1:1.64.0.4
	OPENBSD_4_1_BASE:1.64
	OPENBSD_4_0:1.64.0.2
	OPENBSD_4_0_BASE:1.64
	OPENBSD_3_9:1.56.0.2
	OPENBSD_3_9_BASE:1.56
	OPENBSD_3_8:1.52.0.2
	OPENBSD_3_8_BASE:1.52
	OPENBSD_3_7:1.49.0.2
	OPENBSD_3_7_BASE:1.49
	OPENBSD_3_6:1.47.0.2
	OPENBSD_3_6_BASE:1.47
	OPENBSD_3_5:1.46.0.2
	OPENBSD_3_5_BASE:1.46
	OPENBSD_3_4:1.45.0.2
	OPENBSD_3_4_BASE:1.45
	OPENBSD_3_3:1.43.0.2
	OPENBSD_3_3_BASE:1.43
	OPENBSD_3_2:1.38.0.2
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.22.0.2
	OPENBSD_2_7_BASE:1.22
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.18.0.4
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.113
date	2017.02.09.22.21.53;	author jca;	state Exp;
branches;
next	1.112;
commitid	2hJpWyV9QIS52KLb;

1.112
date	2016.11.26.11.18.43;	author mpi;	state Exp;
branches;
next	1.111;
commitid	w5BGwu0VUCmpZ1gz;

1.111
date	2016.10.23.18.14.01;	author kettenis;	state Exp;
branches;
next	1.110;
commitid	UMXPoyE7GK3YvYfc;

1.110
date	2016.09.19.20.10.54;	author tb;	state Exp;
branches;
next	1.109;
commitid	tgVfoXh5ud2VSoX2;

1.109
date	2016.09.19.20.08.12;	author tb;	state Exp;
branches;
next	1.108;
commitid	3fPGxuixAtqMMYVB;

1.108
date	2016.08.14.22.47.26;	author guenther;	state Exp;
branches;
next	1.107;
commitid	FtUeHnQb6FbNlF9B;

1.107
date	2016.07.18.11.48.55;	author guenther;	state Exp;
branches;
next	1.106;
commitid	avWtEHMkvZ2UpUQ6;

1.106
date	2016.06.03.20.38.48;	author deraadt;	state Exp;
branches;
next	1.105;
commitid	YkF2aYFYf7gUd7XZ;

1.105
date	2016.05.27.19.45.04;	author deraadt;	state Exp;
branches;
next	1.104;
commitid	nQEqvpt7rKDi6fz0;

1.104
date	2016.05.25.13.32.29;	author deraadt;	state Exp;
branches;
next	1.103;
commitid	nRXaXyxw5q8aUMOK;

1.103
date	2016.04.25.19.19.34;	author tedu;	state Exp;
branches;
next	1.102;
commitid	mlmoaihxE19Z2idE;

1.102
date	2016.04.12.16.53.42;	author millert;	state Exp;
branches;
next	1.101;
commitid	OJ4acdUELuHhMACW;

1.101
date	2015.12.11.11.53.52;	author tedu;	state Exp;
branches;
next	1.100;
commitid	LQeDBKkKYNYcyrI9;

1.100
date	2015.08.28.04.38.47;	author guenther;	state Exp;
branches;
next	1.99;
commitid	plAZIJHa0HKzn8y4;

1.99
date	2015.03.11.14.59.04;	author deraadt;	state Exp;
branches;
next	1.98;
commitid	RH2DY6SsdfqD1gnK;

1.98
date	2015.02.10.11.16.04;	author miod;	state Exp;
branches;
next	1.97;
commitid	6bRdTEx7tfbEKUiB;

1.97
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.96;
commitid	Uu5nFG3wCl0LACBb;

1.96
date	2014.12.19.14.12.00;	author tedu;	state Exp;
branches;
next	1.95;
commitid	ZonIp1N2xO05Ufev;

1.95
date	2014.12.19.14.08.20;	author tedu;	state Exp;
branches;
next	1.94;
commitid	zkrRxNrMbjNQ9W8v;

1.94
date	2014.11.23.04.34.48;	author guenther;	state Exp;
branches;
next	1.93;
commitid	LIj2x3qvN0HcH7BW;

1.93
date	2014.11.19.18.04.54;	author tedu;	state Exp;
branches;
next	1.92;
commitid	DhpzIJGhCsFp0uYg;

1.92
date	2014.10.08.04.52.54;	author deraadt;	state Exp;
branches;
next	1.91;
commitid	1oac0UHabHHmLmRE;

1.91
date	2014.08.20.11.23.42;	author mikeb;	state Exp;
branches;
next	1.90;
commitid	vzc4wz1s3pDevb7K;

1.90
date	2014.03.19.04.17.33;	author guenther;	state Exp;
branches;
next	1.89;

1.89
date	2013.12.01.16.40.56;	author krw;	state Exp;
branches;
next	1.88;

1.88
date	2013.11.12.22.27.11;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2013.10.22.16.40.27;	author guenther;	state Exp;
branches;
next	1.86;

1.86
date	2013.08.22.04.43.41;	author guenther;	state Exp;
branches;
next	1.85;

1.85
date	2013.06.05.01.26.00;	author guenther;	state Exp;
branches;
next	1.84;

1.84
date	2013.04.21.20.49.39;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2013.03.24.15.09.12;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2012.12.18.21.28.45;	author millert;	state Exp;
branches;
next	1.81;

1.81
date	2012.07.11.07.50.39;	author guenther;	state Exp;
branches;
next	1.80;

1.80
date	2012.07.09.22.41.45;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2012.05.17.17.53.22;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2011.06.28.06.55.30;	author guenther;	state Exp;
branches;
next	1.77;

1.77
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2009.05.31.19.31.23;	author thib;	state Exp;
branches;
next	1.75;

1.75
date	2008.10.07.02.30.02;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2008.09.01.08.50.07;	author sobrado;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.20.09.49.08;	author thib;	state Exp;
branches;
next	1.72;

1.72
date	2007.12.28.19.22.07;	author chl;	state Exp;
branches;
next	1.71;

1.71
date	2007.12.08.18.23.24;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2007.11.28.17.02.56;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2007.11.28.16.33.43;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2007.11.28.11.37.41;	author tedu;	state Exp;
branches;
next	1.67;

1.67
date	2007.11.26.18.32.33;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.03.14.26.54;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2007.09.02.15.19.40;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2006.06.04.01.39.32;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2006.04.18.17.50.51;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.27.14.08.14;	author pedro;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.26.20.15.50;	author uwe;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.26.16.49.17;	author uwe;	state Exp;
branches;
next	1.59;

1.59
date	2006.03.26.15.04.10;	author uwe;	state Exp;
branches;
next	1.58;

1.58
date	2006.03.25.23.35.13;	author pedro;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.25.21.11.52;	author pedro;	state Exp;
branches;
next	1.56;

1.56
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.55;

1.55
date	2005.12.17.13.56.02;	author pedro;	state Exp;
branches;
next	1.54;

1.54
date	2005.12.11.20.46.29;	author pedro;	state Exp;
branches;
next	1.53;

1.53
date	2005.10.15.18.33.51;	author otto;	state Exp;
branches;
next	1.52;

1.52
date	2005.05.26.01.45.02;	author pedro;	state Exp;
branches;
next	1.51;

1.51
date	2005.05.26.01.44.38;	author pedro;	state Exp;
branches;
next	1.50;

1.50
date	2005.05.03.03.41.11;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2005.02.08.14.48.08;	author pat;	state Exp;
branches;
next	1.48;

1.48
date	2004.09.14.22.33.00;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2004.08.03.04.11.49;	author mjc;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.16.23.11.20;	author jmc;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.08.23.31.55;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.06.18.33.15;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.06.05.32.39;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.06.05.23.34;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.12.04.17.14;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.09.11.19.39;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.13.00.34.03;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.12.05.32.51;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.19.08.45.52;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.18.23.41.32;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.16.16.54.29;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.08.23.41.42;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.02.22.38.57;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.19.00.03.29;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.11.01.27.47;	author pvalchev;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.24.17.03.19;	author csapuntz;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.25.05.33.08;	author csapuntz;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.16.19.03.48;	author assar;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.24.03.24.23;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	99.12.05.08.49.18;	author art;	state Exp;
branches;
next	1.21;

1.21
date	99.06.23.15.56.36;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	99.06.03.15.49.31;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.05.22.21.43.52;	author weingart;	state Exp;
branches;
next	1.18;

1.18
date	98.07.08.22.13.29;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.06.25.17.04.29;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.11.09.22.03.29;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.09.18.08.59.54;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.09.18.08.54.09;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.09.12.04.07.19;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.08.10.04.55.18;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.08.07.20.58.30;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.05.31.08.48.20;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.05.31.07.37.58;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.05.30.13.28.38;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.12.22.03.29.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.11.24.23.42.11;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.06.10.08.37.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.05.16.15.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.25.15.56.06;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.11.06.21.19.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.113
log
@Teach pstat -d to also print untyped kernel symbols.

Storage defined in assembly code often doesn't define its type and size,
thus the nlist interface can't present it as N_DATA.  Instead of fixing
all the assembly by adding .type pseudo ops, work around the problem in
pstat.  Let's hope that allowing N_COMM is sufficient.  This makes
''pstat -d u cpuid_level'' useful.

Reported by mikeb@@, "looks sane" mikeb@@ guenther@@
@
text
@/*	$OpenBSD: pstat.c,v 1.112 2016/11/26 11:18:43 mpi Exp $	*/
/*	$NetBSD: pstat.c,v 1.27 1996/10/23 22:50:06 cgd Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXCOMLEN DEV_BSIZE */
#include <sys/types.h>
#include <sys/proc.h>
#include <sys/time.h>
#include <sys/vnode.h>
#include <sys/ucred.h>
#include <sys/stat.h>
#define _KERNEL
#include <sys/file.h>
#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <sys/mount.h>
#undef _KERNEL
#include <nfs/nfsproto.h>
#include <nfs/rpcv2.h>
#include <nfs/nfsnode.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/swap.h>

#include <sys/sysctl.h>

#include <stdint.h>
#include <endian.h>
#include <err.h>
#include <kvm.h>
#include <limits.h>
#include <nlist.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

struct nlist vnodenl[] = {
#define	FNL_NFILE	0		/* sysctl */
	{"_nfiles"},
#define FNL_MAXFILE	1		/* sysctl */
	{"_maxfiles"},
#define TTY_NTTY	2		/* sysctl */
	{"_tty_count"},
#define V_NUMV		3		/* sysctl */
	{ "_numvnodes" },
#define TTY_TTYLIST	4		/* sysctl */
	{"_ttylist"},
#define	V_MOUNTLIST	5		/* no sysctl */
	{ "_mountlist" },
	{ NULL }
};

struct itty *globalitp;
struct kinfo_file *kf;
struct nlist *globalnl;

struct e_vnode {
	struct vnode *vptr;
	struct vnode vnode;
};

int	kflag;
int	totalflag;
int	usenumflag;
int	hideroot;
int	maxfile;
int	need_nlist;
int	nfile;
int	ntty;
int	numvnodes;
char	*nlistf	= NULL;
char	*memf	= NULL;
kvm_t	*kd = NULL;

#define	SVAR(var) __STRING(var)	/* to force expansion */
#define	KGET(idx, var)							\
	KGET1(idx, &var, sizeof(var), SVAR(var))
#define	KGET1(idx, p, s, msg)						\
	KGET2(globalnl[idx].n_value, p, s, msg)
#define	KGET2(addr, p, s, msg)						\
	if (kvm_read(kd, (u_long)(addr), p, s) != s)			\
		warnx("cannot read %s: %s", msg, kvm_geterr(kd))
#define	KGETRET(addr, p, s, msg)					\
	if (kvm_read(kd, (u_long)(addr), p, s) != s) {			\
		warnx("cannot read %s: %s", msg, kvm_geterr(kd));	\
		return (0);						\
	}

void	filemode(void);
void	filemodeprep(void);
struct mount *
	getmnt(struct mount *);
struct e_vnode *
	kinfo_vnodes(void);
void	mount_print(struct mount *);
void	nfs_header(void);
int	nfs_print(struct vnode *);
void	swapmode(void);
void	ttymode(void);
void	ttymodeprep(void);
void	ttyprt(struct itty *);
void	tty2itty(struct tty *tp, struct itty *itp);
void	ufs_header(void);
int	ufs_print(struct vnode *);
void	ext2fs_header(void);
int	ext2fs_print(struct vnode *);
static void __dead	usage(void);
void	vnode_header(void);
void	vnode_print(struct vnode *, struct vnode *);
void	vnodemode(void);
void	vnodemodeprep(void);


int
main(int argc, char *argv[])
{
	int fileflag = 0, swapflag = 0, ttyflag = 0, vnodeflag = 0, ch;
	char buf[_POSIX2_LINE_MAX];
	const char *dformat = NULL;
	extern char *optarg;
	extern int optind;
	int i;

	hideroot = getuid();

	while ((ch = getopt(argc, argv, "d:TM:N:fiknstv")) != -1)
		switch (ch) {
		case 'd':
			dformat = optarg;
			break;
		case 'f':
			fileflag = 1;
			break;
		case 'M':
			memf = optarg;
			break;
		case 'N':
			nlistf = optarg;
			break;
		case 'n':
			usenumflag = 1;
			break;
		case 's':
			swapflag = 1;
			break;
		case 'T':
			totalflag = 1;
			break;
		case 't':
			ttyflag = 1;
			break;
		case 'k':
			kflag = 1;
			break;
		case 'v':
		case 'i':		/* Backward compatibility. */
			vnodeflag = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (dformat && getuid())
		errx(1, "Only root can use -d");

	if ((dformat == NULL && argc > 0) || (dformat && argc == 0))
		usage();

	need_nlist = dformat || vnodeflag;

	if (nlistf != NULL || memf != NULL) {
		if (fileflag || totalflag)
			need_nlist = 1;
	}

	if (vnodeflag || fileflag || dformat || need_nlist)
		if ((kd = kvm_openfiles(nlistf, memf, NULL,
		    O_RDONLY | (need_nlist ? 0 : KVM_NO_FILES), buf)) == 0)
			errx(1, "kvm_openfiles: %s", buf);

	if (need_nlist)
		if (kvm_nlist(kd, vnodenl) == -1)
			errx(1, "kvm_nlist: %s", kvm_geterr(kd));

	if (!(fileflag | vnodeflag | ttyflag | swapflag | totalflag || dformat))
		usage();

	if(!dformat) {
		if (fileflag || totalflag)
			filemodeprep();
		if (vnodeflag || totalflag)
			vnodemodeprep();
		if (ttyflag)
			ttymodeprep();
	}

	if (pledge("stdio rpath vminfo", NULL) == -1)
		err(1, "pledge");

	if (dformat) {
		struct nlist *nl;
		int longformat = 0, stringformat = 0, error = 0, n;
		uint32_t mask = ~0;
		char format[10], buf[1024];
		
		n = strlen(dformat);
		if (n == 0)
			errx(1, "illegal format");

		/*
		 * Support p, c, s, and {l, ll, h, hh, j, t, z, }[diouxX]
		 */
		if (strcmp(dformat, "p") == 0)
			longformat = sizeof(long) == 8;
		else if (strcmp(dformat, "c") == 0)
			mask = 0xff;
		else if (strcmp(dformat, "s") == 0)
			stringformat = 1;
		else if (strchr("diouxX", dformat[n - 1])) {
			char *ptbl[]= {"l", "ll", "h", "hh", "j", "t", "z", ""};
			int i;

			char *mod;
			for (i = 0; i < sizeof(ptbl)/sizeof(ptbl[0]); i++) {
				mod = ptbl[i];
				if (strlen(mod) == n - 1 &&
				    strncmp(mod, dformat, strlen(mod)) == 0)
					break;
			}
			if (i == sizeof(ptbl)/sizeof(ptbl[0])
			    && dformat[1] != '\0')
				errx(1, "illegal format");
			if (strcmp(mod, "l") == 0)
				longformat = sizeof(long) == sizeof(long long);
			else if (strcmp(mod, "h") == 0)
				mask = 0xffff;
			else if (strcmp(mod, "hh") == 0)
				mask = 0xff;
			else if (strcmp(mod, "") != 0)
				longformat = 1;

		} else
			errx(1, "illegal format");

		if (*dformat == 's') {
			stringformat = 1;
			snprintf(format, sizeof(format), "%%.%zus",
			    sizeof buf);
		} else
			snprintf(format, sizeof(format), "%%%s", dformat);

		nl = calloc(argc + 1, sizeof *nl);
		if (!nl)
			err(1, "calloc nl: ");
		for (i = 0; i < argc; i++) {
			if (asprintf(&nl[i].n_name, "_%s",
			    argv[i]) == -1)
				warn("asprintf");
		}
		kvm_nlist(kd, nl);
		globalnl = nl;
		for (i = 0; i < argc; i++) {
			uint64_t v;

			printf("%s ", argv[i]);
			if (!nl[i].n_value && argv[i][0] == '0') {
				nl[i].n_value = strtoul(argv[i], NULL, 16);
				nl[i].n_type = N_DATA;
			}
			if (!nl[i].n_value) {
				printf("not found\n");
				error++;
				continue;
			}

			printf("at %p: ", (void *)nl[i].n_value);
			if ((nl[i].n_type & N_TYPE) == N_DATA ||
			    (nl[i].n_type & N_TYPE) == N_COMM) {
				if (stringformat) {
					KGET1(i, &buf, sizeof(buf), argv[i]);
					buf[sizeof(buf) - 1] = '\0';
				} else
					KGET1(i, &v, sizeof(v), argv[i]);
				if (stringformat)
					printf(format, &buf);
				else if (longformat)
					printf(format, v);
				else {
#if BYTE_ORDER == BIG_ENDIAN
					switch (mask) {
					case 0xff:
						v >>= 8;
						/* FALLTHROUGH */
					case 0xffff:
						v >>= 16;
						/* FALLTHROUGH */
					case 0xffffffff:
						v >>= 32;
						break;
					}
#endif
					printf(format, ((uint32_t)v) & mask);
				}
			}
			printf("\n");
		}
		for (i = 0; i < argc; i++)
			free(nl[i].n_name);
		free(nl);
		return error;
	}

	if (fileflag || totalflag)
		filemode();
	if (vnodeflag || totalflag)
		vnodemode();
	if (ttyflag)
		ttymode();
	if (swapflag || totalflag)
		swapmode();
	return 0;
}

void
vnodemode(void)
{
	struct e_vnode *e_vnodebase, *endvnode, *evp;
	struct vnode *vp;
	struct mount *maddr, *mp = NULL;

	globalnl = vnodenl;

	e_vnodebase = kinfo_vnodes();
	if (totalflag) {
		(void)printf("%7d vnodes\n", numvnodes);
		return;
	}
	if (!e_vnodebase)
		return;
	endvnode = e_vnodebase + numvnodes;
	(void)printf("%d active vnodes\n", numvnodes);

	maddr = NULL;
	for (evp = e_vnodebase; evp < endvnode; evp++) {
		vp = &evp->vnode;
		if (vp->v_mount != maddr) {
			/*
			 * New filesystem
			 */
			if ((mp = getmnt(vp->v_mount)) == NULL)
				continue;
			maddr = vp->v_mount;
			mount_print(mp);
			vnode_header();
			if (!strncmp(mp->mnt_stat.f_fstypename, MOUNT_FFS, MFSNAMELEN) ||
			    !strncmp(mp->mnt_stat.f_fstypename, MOUNT_MFS, MFSNAMELEN)) {
				ufs_header();
			} else if (!strncmp(mp->mnt_stat.f_fstypename, MOUNT_NFS,
			    MFSNAMELEN)) {
				nfs_header();
			} else if (!strncmp(mp->mnt_stat.f_fstypename, MOUNT_EXT2FS,
			    MFSNAMELEN)) {
				ext2fs_header();
			}
			(void)printf("\n");
		}
		vnode_print(evp->vptr, vp);

		/* Syncer vnodes have no associated fs-specific data */
		if (vp->v_data == NULL) {
			printf(" %6c %5c %7c\n", '-', '-', '-');
			continue;
		}

		if (!strncmp(mp->mnt_stat.f_fstypename, MOUNT_FFS, MFSNAMELEN) ||
		    !strncmp(mp->mnt_stat.f_fstypename, MOUNT_MFS, MFSNAMELEN)) {
			ufs_print(vp);
		} else if (!strncmp(mp->mnt_stat.f_fstypename, MOUNT_NFS, MFSNAMELEN)) {
			nfs_print(vp);
		} else if (!strncmp(mp->mnt_stat.f_fstypename, MOUNT_EXT2FS,
		    MFSNAMELEN)) {
			ext2fs_print(vp);
		}
		(void)printf("\n");
	}
	free(e_vnodebase);
}

void
vnodemodeprep(void)
{
	int mib[2];
	size_t num;

	if (kd == NULL) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_NUMVNODES;
		num = sizeof(numvnodes);
		if (sysctl(mib, 2, &numvnodes, &num, NULL, 0) < 0)
			err(1, "sysctl(KERN_NUMVNODES) failed");
	}
}

void
vnode_header(void)
{
	(void)printf("%*s TYP VFLAG  USE HOLD", 2 * (int)sizeof(long), "ADDR");
}

void
vnode_print(struct vnode *avnode, struct vnode *vp)
{
	char *type, flags[16];
	char *fp;
	int flag;

	/*
	 * set type
	 */
	switch (vp->v_type) {
	case VNON:
		type = "non"; break;
	case VREG:
		type = "reg"; break;
	case VDIR:
		type = "dir"; break;
	case VBLK:
		type = "blk"; break;
	case VCHR:
		type = "chr"; break;
	case VLNK:
		type = "lnk"; break;
	case VSOCK:
		type = "soc"; break;
	case VFIFO:
		type = "fif"; break;
	case VBAD:
		type = "bad"; break;
	default:
		type = "unk"; break;
	}
	/*
	 * gather flags
	 */
	fp = flags;
	flag = vp->v_flag;
	if (flag & VROOT)
		*fp++ = 'R';
	if (flag & VTEXT)
		*fp++ = 'T';
	if (flag & VSYSTEM)
		*fp++ = 'S';
	if (flag & VISTTY)
		*fp++ = 'I';
	if (flag & VXLOCK)
		*fp++ = 'L';
	if (flag & VXWANT)
		*fp++ = 'W';
	if (vp->v_bioflag & VBIOWAIT)
		*fp++ = 'B';
	if (flag & VALIASED)
		*fp++ = 'A';
	if (vp->v_bioflag & VBIOONFREELIST)
		*fp++ = 'F';
	if (flag & VLOCKSWORK)
		*fp++ = 'l';
	if (vp->v_bioflag & VBIOONSYNCLIST)
		*fp++ = 's';
	if (fp == flags)
		*fp++ = '-';
	*fp = '\0';
	(void)printf("%0*lx %s %5s %4d %4u",
	    2 * (int)sizeof(long), hideroot ? 0L : (long)avnode,
	    type, flags, vp->v_usecount, vp->v_holdcnt);
}

void
ufs_header(void)
{
	(void)printf(" FILEID IFLAG RDEV|SZ");
}

int
ufs_print(struct vnode *vp)
{
	int flag;
	struct inode inode, *ip = &inode;
	struct ufs1_dinode di1;
	char flagbuf[16], *flags = flagbuf;
	char *name;
	mode_t type;

	KGETRET(VTOI(vp), &inode, sizeof(struct inode), "vnode's inode");
	KGETRET(inode.i_din1, &di1, sizeof(struct ufs1_dinode),
	    "vnode's dinode");

	inode.i_din1 = &di1;
	flag = ip->i_flag;
#if 0
	if (flag & IN_LOCKED)
		*flags++ = 'L';
	if (flag & IN_WANTED)
		*flags++ = 'W';
	if (flag & IN_LWAIT)
		*flags++ = 'Z';
#endif
	if (flag & IN_ACCESS)
		*flags++ = 'A';
	if (flag & IN_CHANGE)
		*flags++ = 'C';
	if (flag & IN_UPDATE)
		*flags++ = 'U';
	if (flag & IN_MODIFIED)
		*flags++ = 'M';
	if (flag & IN_LAZYMOD)
		*flags++ = 'm';
	if (flag & IN_RENAME)
		*flags++ = 'R';
	if (flag & IN_SHLOCK)
		*flags++ = 'S';
	if (flag & IN_EXLOCK)
		*flags++ = 'E';
	if (flag == 0)
		*flags++ = '-';
	*flags = '\0';

	(void)printf(" %6d %5s", ip->i_number, flagbuf);
	type = ip->i_ffs1_mode & S_IFMT;
	if (S_ISCHR(ip->i_ffs1_mode) || S_ISBLK(ip->i_ffs1_mode))
		if (usenumflag ||
		    ((name = devname(ip->i_ffs1_rdev, type)) == NULL))
			(void)printf("   %2d,%-2d",
			    major(ip->i_ffs1_rdev), minor(ip->i_ffs1_rdev));
		else
			(void)printf(" %7s", name);
	else
		(void)printf(" %7lld", (long long)ip->i_ffs1_size);
	return (0);
}

void
ext2fs_header(void)
{
	(void)printf(" FILEID IFLAG SZ");
}

int
ext2fs_print(struct vnode *vp)
{
	int flag;
	struct inode inode, *ip = &inode;
	struct ext2fs_dinode di;
	char flagbuf[16], *flags = flagbuf;

	KGETRET(VTOI(vp), &inode, sizeof(struct inode), "vnode's inode");
	KGETRET(inode.i_e2din, &di, sizeof(struct ext2fs_dinode),
	    "vnode's dinode");

	inode.i_e2din = &di;
	flag = ip->i_flag;

#if 0
	if (flag & IN_LOCKED)
		*flags++ = 'L';
	if (flag & IN_WANTED)
		*flags++ = 'W';
	if (flag & IN_LWAIT)
		*flags++ = 'Z';
#endif
	if (flag & IN_ACCESS)
		*flags++ = 'A';
	if (flag & IN_CHANGE)
		*flags++ = 'C';
	if (flag & IN_UPDATE)
		*flags++ = 'U';
	if (flag & IN_MODIFIED)
		*flags++ = 'M';
	if (flag & IN_RENAME)
		*flags++ = 'R';
	if (flag & IN_SHLOCK)
		*flags++ = 'S';
	if (flag & IN_EXLOCK)
		*flags++ = 'E';
	if (flag == 0)
		*flags++ = '-';
	*flags = '\0';

	(void)printf(" %6d %5s %2d", ip->i_number, flagbuf, ip->i_e2fs_size);
	return (0);
}

void
nfs_header(void)
{
	(void)printf(" FILEID NFLAG RDEV|SZ");
}

int
nfs_print(struct vnode *vp)
{
	struct nfsnode nfsnode, *np = &nfsnode;
	char flagbuf[16], *flags = flagbuf;
	int flag;
	char *name;
	mode_t type;

	KGETRET(VTONFS(vp), &nfsnode, sizeof(nfsnode), "vnode's nfsnode");
	flag = np->n_flag;
	if (flag & NFLUSHWANT)
		*flags++ = 'W';
	if (flag & NFLUSHINPROG)
		*flags++ = 'P';
	if (flag & NMODIFIED)
		*flags++ = 'M';
	if (flag & NWRITEERR)
		*flags++ = 'E';
	if (flag & NACC)
		*flags++ = 'A';
	if (flag & NUPD)
		*flags++ = 'U';
	if (flag & NCHG)
		*flags++ = 'C';
	if (flag == 0)
		*flags++ = '-';
	*flags = '\0';

	(void)printf(" %6lld %5s", (long long)np->n_vattr.va_fileid, flagbuf);
	type = np->n_vattr.va_mode & S_IFMT;
	if (S_ISCHR(np->n_vattr.va_mode) || S_ISBLK(np->n_vattr.va_mode))
		if (usenumflag ||
		    ((name = devname(np->n_vattr.va_rdev, type)) == NULL))
			(void)printf("   %2d,%-2d", major(np->n_vattr.va_rdev),
			    minor(np->n_vattr.va_rdev));
		else
			(void)printf(" %7s", name);
	else
		(void)printf(" %7lld", (long long)np->n_size);
	return (0);
}

/*
 * Given a pointer to a mount structure in kernel space,
 * read it in and return a usable pointer to it.
 */
struct mount *
getmnt(struct mount *maddr)
{
	static struct mtab {
		struct mtab *next;
		struct mount *maddr;
		struct mount mount;
	} *mhead = NULL;
	struct mtab *mt;

	for (mt = mhead; mt != NULL; mt = mt->next)
		if (maddr == mt->maddr)
			return (&mt->mount);
	if ((mt = malloc(sizeof(struct mtab))) == NULL)
		err(1, "malloc: mount table");
	KGETRET(maddr, &mt->mount, sizeof(struct mount), "mount table");
	mt->maddr = maddr;
	mt->next = mhead;
	mhead = mt;
	return (&mt->mount);
}

void
mount_print(struct mount *mp)
{
	int flags;

	(void)printf("*** MOUNT ");
	(void)printf("%.*s %s on %s", MFSNAMELEN,
	    mp->mnt_stat.f_fstypename, mp->mnt_stat.f_mntfromname,
	    mp->mnt_stat.f_mntonname);
	if ((flags = mp->mnt_flag)) {
		char *comma = "(";

		putchar(' ');
		/* user visible flags */
		if (flags & MNT_RDONLY) {
			(void)printf("%srdonly", comma);
			flags &= ~MNT_RDONLY;
			comma = ",";
		}
		if (flags & MNT_SYNCHRONOUS) {
			(void)printf("%ssynchronous", comma);
			flags &= ~MNT_SYNCHRONOUS;
			comma = ",";
		}
		if (flags & MNT_NOEXEC) {
			(void)printf("%snoexec", comma);
			flags &= ~MNT_NOEXEC;
			comma = ",";
		}
		if (flags & MNT_NOSUID) {
			(void)printf("%snosuid", comma);
			flags &= ~MNT_NOSUID;
			comma = ",";
		}
		if (flags & MNT_NODEV) {
			(void)printf("%snodev", comma);
			flags &= ~MNT_NODEV;
			comma = ",";
		}
		if (flags & MNT_ASYNC) {
			(void)printf("%sasync", comma);
			flags &= ~MNT_ASYNC;
			comma = ",";
		}
		if (flags & MNT_EXRDONLY) {
			(void)printf("%sexrdonly", comma);
			flags &= ~MNT_EXRDONLY;
			comma = ",";
		}
		if (flags & MNT_EXPORTED) {
			(void)printf("%sexport", comma);
			flags &= ~MNT_EXPORTED;
			comma = ",";
		}
		if (flags & MNT_DEFEXPORTED) {
			(void)printf("%sdefdexported", comma);
			flags &= ~MNT_DEFEXPORTED;
			comma = ",";
		}
		if (flags & MNT_EXPORTANON) {
			(void)printf("%sexportanon", comma);
			flags &= ~MNT_EXPORTANON;
			comma = ",";
		}
		if (flags & MNT_WXALLOWED) {
			(void)printf("%swxallowed", comma);
			flags &= ~MNT_WXALLOWED;
			comma = ",";
		}
		if (flags & MNT_LOCAL) {
			(void)printf("%slocal", comma);
			flags &= ~MNT_LOCAL;
			comma = ",";
		}
		if (flags & MNT_QUOTA) {
			(void)printf("%squota", comma);
			flags &= ~MNT_QUOTA;
			comma = ",";
		}
		if (flags & MNT_ROOTFS) {
			(void)printf("%srootfs", comma);
			flags &= ~MNT_ROOTFS;
			comma = ",";
		}
		if (flags & MNT_NOATIME) {
			(void)printf("%snoatime", comma);
			flags &= ~MNT_NOATIME;
			comma = ",";
		}
		/* filesystem control flags */
		if (flags & MNT_UPDATE) {
			(void)printf("%supdate", comma);
			flags &= ~MNT_UPDATE;
			comma = ",";
		}
		if (flags & MNT_DELEXPORT) {
			(void)printf("%sdelexport", comma);
			flags &= ~MNT_DELEXPORT;
			comma = ",";
		}
		if (flags & MNT_RELOAD) {
			(void)printf("%sreload", comma);
			flags &= ~MNT_RELOAD;
			comma = ",";
		}
		if (flags & MNT_FORCE) {
			(void)printf("%sforce", comma);
			flags &= ~MNT_FORCE;
			comma = ",";
		}
		if (flags & MNT_WANTRDWR) {
			(void)printf("%swantrdwr", comma);
			flags &= ~MNT_WANTRDWR;
			comma = ",";
		}
		if (flags & MNT_SOFTDEP) {
			(void)printf("%ssoftdep", comma);
			flags &= ~MNT_SOFTDEP;
			comma = ",";
		}
		if (flags)
			(void)printf("%sunknown_flags:%x", comma, flags);
		(void)printf(")");
	}
	(void)printf("\n");
}

/*
 * simulate what a running kernel does in kinfo_vnode
 */
struct e_vnode *
kinfo_vnodes(void)
{
	struct mntlist kvm_mountlist;
	struct mount *mp, mount;
	struct vnode *vp, vnode;
	char *vbuf, *evbuf, *bp;
	size_t num;

	if (kd != NULL)
		KGET(V_NUMV, numvnodes);
	if (totalflag)
		return NULL;
	if ((vbuf = calloc(numvnodes + 20,
	    sizeof(struct vnode *) + sizeof(struct vnode))) == NULL)
		err(1, "malloc: vnode buffer");
	bp = vbuf;
	evbuf = vbuf + (numvnodes + 20) *
	    (sizeof(struct vnode *) + sizeof(struct vnode));
	KGET(V_MOUNTLIST, kvm_mountlist);
	num = 0;
	for (mp = TAILQ_FIRST(&kvm_mountlist); mp != NULL;
	    mp = TAILQ_NEXT(&mount, mnt_list)) {
		KGETRET(mp, &mount, sizeof(mount), "mount entry");
		for (vp = LIST_FIRST(&mount.mnt_vnodelist);
		    vp != NULL; vp = LIST_NEXT(&vnode, v_mntvnodes)) {
			KGETRET(vp, &vnode, sizeof(vnode), "vnode");
			if ((bp + sizeof(struct vnode *) +
			    sizeof(struct vnode)) > evbuf)
				/* XXX - should realloc */
				errx(1, "no more room for vnodes");
			memmove(bp, &vp, sizeof(struct vnode *));
			bp += sizeof(struct vnode *);
			memmove(bp, &vnode, sizeof(struct vnode));
			bp += sizeof(struct vnode);
			num++;
		}
	}
	numvnodes = num;
	return ((struct e_vnode *)vbuf);
}

const char hdr[] =
"   LINE RAW  CAN  OUT  HWT LWT    COL STATE      SESS  PGID DISC\n";

void
tty2itty(struct tty *tp, struct itty *itp)
{
	itp->t_dev = tp->t_dev;
	itp->t_rawq_c_cc = tp->t_rawq.c_cc;
	itp->t_canq_c_cc = tp->t_canq.c_cc;
	itp->t_outq_c_cc = tp->t_outq.c_cc;
	itp->t_hiwat = tp->t_hiwat;
	itp->t_lowat = tp->t_lowat;
	itp->t_column = tp->t_column;
	itp->t_state = tp->t_state;
	itp->t_session = tp->t_session;
	if (tp->t_pgrp != NULL)
		KGET2(&tp->t_pgrp->pg_id, &itp->t_pgrp_pg_id, sizeof(pid_t), "pgid");
	itp->t_line = tp->t_line;
}

void
ttymode(void)
{
	struct ttylist_head tty_head;
	struct tty *tp, tty;
	int i;
	struct itty itty;

	if (need_nlist)
		KGET(TTY_NTTY, ntty);
	(void)printf("%d terminal device%s\n", ntty, ntty == 1 ? "" : "s");
	(void)printf("%s", hdr);
	if (!need_nlist) {
		for (i = 0; i < ntty; i++)
			ttyprt(&globalitp[i]);
		free(globalitp);
	} else {
		KGET(TTY_TTYLIST, tty_head);
		for (tp = TAILQ_FIRST(&tty_head); tp;
		    tp = TAILQ_NEXT(&tty, tty_link)) {
			KGET2(tp, &tty, sizeof tty, "tty struct");
			tty2itty(&tty, &itty);
			ttyprt(&itty);
		}
	}
}

void
ttymodeprep(void)
{
	int mib[3];
	size_t nlen;

	if (!need_nlist) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_TTYCOUNT;
		nlen = sizeof(ntty);
		if (sysctl(mib, 2, &ntty, &nlen, NULL, 0) < 0)
			err(1, "sysctl(KERN_TTYCOUNT) failed");

		mib[0] = CTL_KERN;
		mib[1] = KERN_TTY;
		mib[2] = KERN_TTY_INFO;
		if ((globalitp = reallocarray(NULL, ntty, sizeof(struct itty))) == NULL)
			err(1, "malloc");
		nlen = ntty * sizeof(struct itty);
		if (sysctl(mib, 3, globalitp, &nlen, NULL, 0) < 0)
			err(1, "sysctl(KERN_TTY_INFO) failed");
	}
}

struct {
	int flag;
	char val;
} ttystates[] = {
	{ TS_WOPEN,	'W'},
	{ TS_ISOPEN,	'O'},
	{ TS_CARR_ON,	'C'},
	{ TS_TIMEOUT,	'T'},
	{ TS_FLUSH,	'F'},
	{ TS_BUSY,	'B'},
	{ TS_ASLEEP,	'A'},
	{ TS_XCLUDE,	'X'},
	{ TS_TTSTOP,	'S'},
	{ TS_TBLOCK,	'K'},
	{ TS_ASYNC,	'Y'},
	{ TS_BKSL,	'D'},
	{ TS_ERASE,	'E'},
	{ TS_LNCH,	'L'},
	{ TS_TYPEN,	'P'},
	{ TS_CNTTB,	'N'},
	{ 0,		'\0'},
};

void
ttyprt(struct itty *tp)
{
	char *name, state[20];
	int i, j;

	if (usenumflag || (name = devname(tp->t_dev, S_IFCHR)) == NULL)
		(void)printf("%2d,%-3d   ", major(tp->t_dev), minor(tp->t_dev));
	else
		(void)printf("%7s ", name);
	(void)printf("%3d %4d ", tp->t_rawq_c_cc, tp->t_canq_c_cc);
	(void)printf("%4d %4d %3d %6d ", tp->t_outq_c_cc,
		tp->t_hiwat, tp->t_lowat, tp->t_column);
	for (i = j = 0; ttystates[i].flag; i++)
		if (tp->t_state&ttystates[i].flag)
			state[j++] = ttystates[i].val;
	if (j == 0)
		state[j++] = '-';
	state[j] = '\0';
	(void)printf("%-6s %8lx", state,
		hideroot ? 0 : (u_long)tp->t_session & 0xffffffff);
	(void)printf("%6d ", tp->t_pgrp_pg_id);
	switch (tp->t_line) {
	case TTYDISC:
		(void)printf("term\n");
		break;
	case PPPDISC:
		(void)printf("ppp\n");
		break;
	case NMEADISC:
		(void)printf("nmea\n");
		break;
	default:
		(void)printf("%d\n", tp->t_line);
		break;
	}
}

void
filemode(void)
{
	char flagbuf[16], *fbp;
	static char *dtypes[] = { "???", "inode", "socket", "pipe", "kqueue", "???", "???" };

	globalnl = vnodenl;

	if (nlistf != NULL || memf != NULL) {
		KGET(FNL_MAXFILE, maxfile);
		if (totalflag) {
			KGET(FNL_NFILE, nfile);
			(void)printf("%3d/%3d files\n", nfile, maxfile);
			return;
		}
	}

	(void)printf("%d/%d open files\n", nfile, maxfile);
	if (totalflag)
		return;

	(void)printf("%*s TYPE       FLG  CNT  MSG  %*s  OFFSET\n",
	    2 * (int)sizeof(long), "LOC", 2 * (int)sizeof(long), "DATA");
	for (; nfile-- > 0; kf++) {
		(void)printf("%0*llx ", 2 * (int)sizeof(long),
		    hideroot ? 0LL : kf->f_fileaddr);
		(void)printf("%-8.8s", dtypes[
		    (kf->f_type >= (sizeof(dtypes)/sizeof(dtypes[0])))
		    ? 0 : kf->f_type]);
		fbp = flagbuf;
		if (kf->f_flag & FREAD)
			*fbp++ = 'R';
		if (kf->f_flag & FWRITE)
			*fbp++ = 'W';
		if (kf->f_flag & FAPPEND)
			*fbp++ = 'A';
		if (kf->f_flag & FASYNC)
			*fbp++ = 'I';

		if (kf->f_iflags & FIF_HASLOCK)
			*fbp++ = 'L';
		if (kf->f_iflags & FIF_LARVAL)
			*fbp++ = 'l';

		*fbp = '\0';
		(void)printf("%6s  %3ld", flagbuf, (long)kf->f_count);
		(void)printf("  %3ld", (long)kf->f_msgcount);
		(void)printf("  %0*lx", 2 * (int)sizeof(long),
		    hideroot ? 0L : (long)kf->f_data);

		if (kf->f_offset == (uint64_t)-1)
			(void)printf("  *\n");
		else if (kf->f_offset > INT64_MAX) {
			/* would have been negative */
			(void)printf("  %llx\n",
			    hideroot ? 0LL : (long long)kf->f_offset);
		} else
			(void)printf("  %lld\n",
			    hideroot ? 0LL : (long long)kf->f_offset);
	}
}

void
filemodeprep(void)
{
	int mib[2];
	size_t len;

	if (nlistf == NULL && memf == NULL) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_MAXFILES;
		len = sizeof(maxfile);
		if (sysctl(mib, 2, &maxfile, &len, NULL, 0) < 0)
			err(1, "sysctl(KERN_MAXFILES) failed");
		if (totalflag) {
			mib[0] = CTL_KERN;
			mib[1] = KERN_NFILES;
			len = sizeof(nfile);
			if (sysctl(mib, 2, &nfile, &len, NULL, 0) < 0)
				err(1, "sysctl(KERN_NFILES) failed");
		}
	}

	if (!totalflag) {
		kf = kvm_getfiles(kd, KERN_FILE_BYFILE, 0, sizeof *kf, &nfile);
		if (kf == NULL) {
			warnx("kvm_getfiles: %s", kvm_geterr(kd));
			return;
		}
	}
}

/*
 * swapmode is based on a program called swapinfo written
 * by Kevin Lahey <kml@@rokkaku.atl.ga.us>.
 */
void
swapmode(void)
{
	char *header;
	int hlen = 10, nswap;
	int bdiv, i, avail, nfree, npfree, used;
	long blocksize;
	struct swapent *swdev;

	if (kflag) {
		header = "1K-blocks";
		blocksize = 1024;
		hlen = strlen(header);
	} else
		header = getbsize(&hlen, &blocksize);

	nswap = swapctl(SWAP_NSWAP, 0, 0);
	if (nswap == 0) {
		if (!totalflag)
			(void)printf("%-11s %*s %8s %8s %8s  %s\n",
			    "Device", hlen, header,
			    "Used", "Avail", "Capacity", "Priority");
		(void)printf("%-11s %*d %8d %8d %5.0f%%\n",
		    "Total", hlen, 0, 0, 0, 0.0);
		return;
	}
	if ((swdev = calloc(nswap, sizeof(*swdev))) == NULL)
		err(1, "malloc");
	if (swapctl(SWAP_STATS, swdev, nswap) == -1)
		err(1, "swapctl");

	if (!totalflag)
		(void)printf("%-11s %*s %8s %8s %8s  %s\n",
		    "Device", hlen, header,
		    "Used", "Avail", "Capacity", "Priority");

	/* Run through swap list, doing the funky monkey. */
	bdiv = blocksize / DEV_BSIZE;
	avail = nfree = npfree = 0;
	for (i = 0; i < nswap; i++) {
		int xsize, xfree;

		if (!(swdev[i].se_flags & SWF_ENABLE))
			continue;

		if (!totalflag) {
			if (usenumflag)
				(void)printf("%2d,%-2d       %*d ",
				    major(swdev[i].se_dev),
				    minor(swdev[i].se_dev),
				    hlen, swdev[i].se_nblks / bdiv);
			else
				(void)printf("%-11s %*d ", swdev[i].se_path,
				    hlen, swdev[i].se_nblks / bdiv);
		}

		xsize = swdev[i].se_nblks;
		used = swdev[i].se_inuse;
		xfree = xsize - used;
		nfree += (xsize - used);
		npfree++;
		avail += xsize;
		if (totalflag)
			continue;
		(void)printf("%8d %8d %5.0f%%    %d\n",
		    used / bdiv, xfree / bdiv,
		    (double)used / (double)xsize * 100.0,
		    swdev[i].se_priority);
	}
	free(swdev);

	/*
	 * If only one partition has been set up via swapon(8), we don't
	 * need to bother with totals.
	 */
	used = avail - nfree;
	if (totalflag) {
		(void)printf("%dM/%dM swap space\n",
		    used / (1048576 / DEV_BSIZE),
		    avail / (1048576 / DEV_BSIZE));
		return;
	}
	if (npfree > 1) {
		(void)printf("%-11s %*d %8d %8d %5.0f%%\n",
		    "Total", hlen, avail / bdiv, used / bdiv, nfree / bdiv,
		    (double)used / (double)avail * 100.0);
	}
}

static void __dead
usage(void)
{
	(void)fprintf(stderr, "usage: "
	    "pstat [-fknsTtv] [-M core] [-N system] [-d format symbol ...]\n");
	exit(1);
}
@


1.112
log
@Remove leftovers of line disciplines that are no more.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.111 2016/10/23 18:14:01 kettenis Exp $	*/
d311 2
a312 1
			if (nl[i].n_type == N_DATA) {
@


1.111
log
@For -d, if there is no modifier, don't go down the "longformat" path.
Fixes cases like "pstat -d x ticks" on armv7.

ok jca@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.110 2016/09/19 20:10:54 tb Exp $	*/
a991 6
	case TABLDISC:
		(void)printf("tab\n");
		break;
	case SLIPDISC:
		(void)printf("slip\n");
		break;
a993 3
		break;
	case STRIPDISC:
		(void)printf("strip\n");
@


1.110
log
@Add pledge support to pstat

The filemode(), ttymode() and vnodemode() functions can be split into two
pieces. The *_prep() piece must be hoisted to before pledge and the rest
can run under pledge "stdio rpath vminfo". The magic block that decides
which ones of the *_prep() pieces must be run with which combination of
command line switches is quite impressive.

Patch from Rob Pierce, thanks!

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.109 2016/09/19 20:08:12 tb Exp $	*/
d273 1
a273 1
			else
@


1.109
log
@Fix pstat -ft.  In presence of the -f flag, a logic error in ttymode()
leads to entering codepaths that try to work with only partially
initialized kvm structures -- with unsurprising outcomes.

Problem found by Rob Pierce, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.108 2016/08/14 22:47:26 guenther Exp $	*/
d85 2
d94 5
d100 3
a102 3
int	usenumflag;
int	totalflag;
int	kflag;
d122 1
d126 1
a126 1
	kinfo_vnodes(int *);
d132 1
d139 1
a139 1
void	usage(void);
d143 1
a144 1
int	hideroot;
d203 1
a203 1
	need_nlist = vnodeflag || dformat;
d215 19
d343 1
a343 1
		exit(error);
a345 6
	if (need_nlist)
		if (kvm_nlist(kd, vnodenl) == -1)
			errx(1, "kvm_nlist: %s", kvm_geterr(kd));

	if (!(fileflag | vnodeflag | ttyflag | swapflag | totalflag || dformat))
		usage();
d354 1
a354 1
	exit(0);
a362 1
	int numvnodes;
d366 1
a366 1
	e_vnodebase = kinfo_vnodes(&numvnodes);
d423 15
d831 1
a831 1
kinfo_vnodes(int *avnodes)
a836 1
	int mib[2], numvnodes;
d839 1
a839 7
	if (kd == 0) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_NUMVNODES;
		num = sizeof(numvnodes);
		if (sysctl(mib, 2, &numvnodes, &num, NULL, 0) < 0)
			err(1, "sysctl(KERN_NUMVNODES) failed");
	} else
a840 1
	*avnodes = numvnodes;
d868 1
a868 1
	*avnodes = num;
d897 26
a922 2
	int mib[3], ntty, i;
	struct itty itty, *itp;
d931 1
a931 5
	} else
		KGET(TTY_NTTY, ntty);
	(void)printf("%d terminal device%s\n", ntty, ntty == 1 ? "" : "s");
	(void)printf("%s", hdr);
	if (!need_nlist) {
d935 1
a935 1
		if ((itp = reallocarray(NULL, ntty, sizeof(struct itty))) == NULL)
d938 1
a938 1
		if (sysctl(mib, 3, itp, &nlen, NULL, 0) < 0)
a939 11
		for (i = 0; i < ntty; i++)
			ttyprt(&itp[i]);
		free(itp);
	} else {
		KGET(TTY_TTYLIST, tty_head);
		for (tp = TAILQ_FIRST(&tty_head); tp;
		    tp = TAILQ_NEXT(&tty, tty_link)) {
			KGET2(tp, &tty, sizeof tty, "tty struct");
			tty2itty(&tty, &itty);
			ttyprt(&itty);
		}
a1015 1
	struct kinfo_file *kf;
a1017 2
	int mib[2], maxfile, nfile;
	size_t len;
d1021 1
a1021 14
	if (nlistf == NULL && memf == NULL) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_MAXFILES;
		len = sizeof(maxfile);
		if (sysctl(mib, 2, &maxfile, &len, NULL, 0) < 0)
			err(1, "sysctl(KERN_MAXFILES) failed");
		if (totalflag) {
			mib[0] = CTL_KERN;
			mib[1] = KERN_NFILES;
			len = sizeof(nfile);
			if (sysctl(mib, 2, &nfile, &len, NULL, 0) < 0)
				err(1, "sysctl(KERN_NFILES) failed");
		}
	} else {
a1029 8
	if (!totalflag) {
		kf = kvm_getfiles(kd, KERN_FILE_BYFILE, 0, sizeof *kf, &nfile);
		if (kf == NULL) {
			warnx("kvm_getfiles: %s", kvm_geterr(kd));
			return;
		}
	}

d1075 30
d1198 1
a1198 1
void
@


1.108
log
@Convert %q to %ll and cast opaque system values to long long.
Use uint64_t for the KERN_INTRCNT_CNT sysctl()

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.107 2016/07/18 11:48:55 guenther Exp $	*/
d92 1
d145 1
a145 1
	int i, need_nlist;
d873 1
a873 1
	if (kd == 0) {
d883 1
a883 1
	if (kd == 0) {
@


1.107
log
@Fix VFLAG formatting

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.106 2016/06/03 20:38:48 deraadt Exp $	*/
d533 1
a533 1
		(void)printf(" %7qd", ip->i_ffs1_size);
d633 1
a633 1
		(void)printf(" %7qd", np->n_size);
@


1.106
log
@correct synopsis to make -d usage clearer.
The shed fell over because 15 layers of paint exceeded engineering margins.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.105 2016/05/27 19:45:04 deraadt Exp $	*/
d410 1
a410 1
	char *fp = flags;
d441 1
d465 1
a465 1
	if (flag == 0)
@


1.105
log
@W^X violations are no longer permitted by default.  A kernel log message
is generated, and mprotect/mmap return ENOTSUP.  If the sysctl(8) flag
kern.wxabort is set then a SIGABRT occurs instead, for gdb use or coredump
creation.

W^X violating programs can be permitted on a ffs/nfs filesystem-basis,
using the "wxallowed" mount option.  One day far in the future
upstream software developers will understand that W^X violations are a
tremendously risky practice and that style of programming will be
banished outright.  Until then, we recommend most users need to use the
wxallowed option on their /usr/local filesystem.  At least your other
filesystems don't permit such programs.

ok jca kettenis mlarkin natano
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.104 2016/05/25 13:32:29 deraadt Exp $	*/
d1157 1
a1157 1
	    "pstat [-fknsTtv] [-d format] [-M core] [-N system] [symbols]\n");
@


1.104
log
@remove code to display MNT_EXKERB bit
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.103 2016/04/25 19:19:34 tedu Exp $	*/
d724 5
@


1.103
log
@remove systrace
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.102 2016/04/12 16:53:42 millert Exp $	*/
a723 5
			comma = ",";
		}
		if (flags & MNT_EXKERB) {
			(void)printf("%sexkerb", comma);
			flags &= ~MNT_EXKERB;
@


1.102
log
@The -T flag consumes the same data as the -f flag so it requires
nlist too.  Fixes a crash when the -T flag is specified due to
calling kvm_read() with a NULL kvm_t.  From Rob Pierce
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.101 2015/12/11 11:53:52 tedu Exp $	*/
d979 1
a979 1
	static char *dtypes[] = { "???", "inode", "socket", "pipe", "kqueue", "???", "systrace" };
@


1.101
log
@dformat is pointer, don't compare with 0
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.100 2015/08/28 04:38:47 guenther Exp $	*/
d196 1
a196 1
		if (fileflag)
@


1.100
log
@Rework the UNIX domain socket garbage collector, including ideas from
{Free,Net}BSD
 - when a socket is closed with fds in its input, defer closing them to
   a task to avoid recursing.  This eliminates the complicated extra
   reference taking which had a 37 line(!) comment explanation
 - move flags, counts, and links only needed for this from struct file to
   struct unpcb
 - document the flow of the mark/sweep collector

much help from claudio@@ who made me explain the GC to him until we trusted it
ok claudio@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.99 2015/03/11 14:59:04 deraadt Exp $	*/
d190 1
a190 1
	if ((dformat == 0 && argc > 0) || (dformat && argc == 0))
@


1.99
log
@Remove setgid kmem support.  As a result, -d and -v will require you to
run this as root.
ok millert, also discussed with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.98 2015/02/10 11:16:04 miod Exp $	*/
a1040 4
		if (kf->f_iflags & FIF_MARK)
			*fbp++ = 'm';
		if (kf->f_iflags & FIF_DEFER)
			*fbp++ = 'd';
@


1.98
log
@Fix -d output of smaller than 64 bit values on big-endian systems.
ok mpi@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.97 2015/01/16 06:40:19 deraadt Exp $	*/
a143 1
	gid_t gid;
d193 1
a193 1
	need_nlist = vnodeflag || totalflag || dformat;
a194 5
	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	gid = getgid();
d196 1
a196 3
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");
		if (fileflag || totalflag)
a204 3
	if (nlistf == NULL && memf == NULL)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");
d811 2
@


1.97
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.96 2014/12/19 14:12:00 tedu Exp $	*/
d58 1
d219 1
a219 1
		int mask = ~0;
d279 1
a279 1
			long long v;
d303 16
a318 2
				else
					printf(format, ((int)v) & mask);
@


1.96
log
@don't print vnodes if we didn't read them
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.95 2014/12/19 14:08:20 tedu Exp $	*/
d33 2
a34 1
#include <sys/param.h>
@


1.95
log
@1. -T (totalflag) requires nlist too.
2. If we can't read a vnode, there's no way LIST_NEXT is going to be
meaningful.
3. set numvnodes before looping in case we return early.
getting better, but still not all fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.94 2014/11/23 04:34:48 guenther Exp $	*/
d344 2
@


1.94
log
@<sys/buf.h> isn't actually needed here

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.93 2014/11/19 18:04:54 tedu Exp $	*/
d192 1
a192 1
	need_nlist = vnodeflag || dformat;
d803 1
d814 1
a814 1
		KGET2(mp, &mount, sizeof(mount), "mount entry");
d817 1
a817 1
			KGET2(vp, &vnode, sizeof(vnode), "vnode");
@


1.93
log
@delete the KERN_VNODE sysctl. it fails to provide any isolation from the
kernel struct vnode defintion, and the only consumer (pstat) still needs
kvm to read much of the required information. no great loss to always use
kvm until there's a better replacement interface.
ok deraadt millert uebayasi
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.92 2014/10/08 04:52:54 deraadt Exp $	*/
a35 1
#include <sys/buf.h>
@


1.92
log
@use reallocarray(NULL, a, b) instead of malloc(a*b)
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.91 2014/08/20 11:23:42 mikeb Exp $	*/
d86 5
a116 2
struct e_vnode *
	loadvnodes(int *);
d340 1
a340 1
	e_vnodebase = loadvnodes(&numvnodes);
a782 28
struct e_vnode *
loadvnodes(int *avnodes)
{
	int mib[2];
	size_t copysize;
	struct e_vnode *vnodebase;

	if (memf != NULL) {
		/*
		 * do it by hand
		 */
		return (kinfo_vnodes(avnodes));
	}
	mib[0] = CTL_KERN;
	mib[1] = KERN_VNODE;
	if (sysctl(mib, 2, NULL, &copysize, NULL, 0) == -1)
		err(1, "sysctl: KERN_VNODE");
	if ((vnodebase = malloc(copysize)) == NULL)
		err(1, "malloc: vnode table");
	if (sysctl(mib, 2, vnodebase, &copysize, NULL, 0) == -1)
		err(1, "sysctl: KERN_VNODE");
	if (copysize % sizeof(struct e_vnode))
		errx(1, "vnode size mismatch");
	*avnodes = copysize / sizeof(struct e_vnode);

	return (vnodebase);
}

d812 2
a813 1
	TAILQ_FOREACH(mp, &kvm_mountlist, mnt_list) {
@


1.91
log
@Remove userland bits related to the crypto(4) interface;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.90 2014/03/19 04:17:33 guenther Exp $	*/
d900 2
a902 2
		if ((itp = malloc(nlen)) == NULL)
			err(1, "malloc");
@


1.90
log
@Pull in FreeBSD r37363 and r37887:
--
Sync timestamp changes for inodes of special files to disk as late
as possible (when the inode is reclaimed).  Temporarily only do
this if option UFS_LAZYMOD configured and softupdates aren't enabled.
UFS_LAZYMOD is intentionally left out of /sys/conf/options.

This is mainly to avoid almost useless disk i/o on battery powered
machines.  It's silly to write to disk (on the next sync or when the
inode becomes inactive) just because someone hit a key or something
wrote to the screen or /dev/null.
--
Made lazy syncing of timestamps for special files non-optional.
--

Also, include support in 'pstat -v' to display the IN_LAZYMOD flag.

ok tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.89 2013/12/01 16:40:56 krw Exp $	*/
d994 1
a994 1
	static char *dtypes[] = { "???", "inode", "socket", "pipe", "kqueue", "crypto", "systrace" };
@


1.89
log
@Change 'mountlist' from CIRCLEQ to TAILQ. Be paranoid and
use TAILQ_*_SAFE more than might be needed.

Bulk ports build by sthen@@ showed nobody sticking their fingers
so deep into the kernel.

Feedback and suggestions from millert@@. ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.88 2013/11/12 22:27:11 deraadt Exp $	*/
d501 2
@


1.88
log
@ensure there are prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.87 2013/10/22 16:40:27 guenther Exp $	*/
d834 2
a835 2
	for (num = 0, mp = CIRCLEQ_FIRST(&kvm_mountlist); ;
	    mp = CIRCLEQ_NEXT(&mount, mnt_list)) {
a849 2
		if (mp == CIRCLEQ_LAST(&kvm_mountlist))
			break;
@


1.87
log
@- add UNIX-domain socket info to struct kinfo_file2
- convert netstat from kvm_getfiles() to kvm_getfile2() using that
- delete kvm_getfiles() and KERN_FILE as no longer used (bump libkvm's major)
- rename kvm_getfile2() to kvm_getfiles(), kinfo_file2 to kinfo_file
  and KERN_FILE2 to KERN_FILE.

ok deraadt@@, millert@@
ports scan sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.86 2013/08/22 04:43:41 guenther Exp $	*/
d120 1
@


1.86
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.85 2013/06/05 01:26:00 guenther Exp $	*/
d991 1
a991 1
	struct kinfo_file2 *kf;
d1022 1
a1022 1
		kf = kvm_getfile2(kd, KERN_FILE_BYFILE, 0, sizeof *kf, &nfile);
d1024 1
a1024 1
			warnx("kvm_getfile2: %s", kvm_geterr(kd));
@


1.85
log
@Move FHASLOCK from f_flag to f_iflags, freeing up a bit for passing
O_* flags and eliminating an XXX comment.

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.84 2013/04/21 20:49:39 guenther Exp $	*/
d610 1
a610 1
	(void)printf(" %6ld %5s", np->n_vattr.va_fileid, flagbuf);
@


1.84
log
@Tweak #include order to work during the big time_t transition

noted by matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.83 2013/03/24 15:09:12 deraadt Exp $	*/
a1047 2
		if (kf->f_flag & FHASLOCK)
			*fbp++ = 'L';
d1051 2
@


1.83
log
@Do not leak kernel pointers, unless operating as root.  Some other display
functionality is lost, but one can argue that privacy was being violated
there...
ok various, including bluhm and guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.82 2012/12/18 21:28:45 millert Exp $	*/
d39 1
a45 1
#include <sys/stat.h>
@


1.82
log
@We no longer use struct eproc for kinfo_proc in sysctl.h so there
is no direct need for sys/proc.h or sys/resource.h.  Some consumers
of kinfo_proc need these for the proc flags and rlimit defines like
RLIM_INF so add the appropriate includes to them.
OK deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.81 2012/07/11 07:50:39 guenther Exp $	*/
d129 2
d142 2
d457 3
a459 2
	(void)printf("%0*lx %s %5s %4d %4u", 2 * (int)sizeof(long),
	    (long)avnode, type, flags, vp->v_usecount, vp->v_holdcnt);
d960 2
a961 1
	(void)printf("%-6s %8lx", state, (u_long)tp->t_session & 0xffffffff);
d1036 2
a1037 1
		(void)printf("%0*llx ", 2 * (int)sizeof(long), kf->f_fileaddr);
d1064 1
a1064 1
		    (long)kf->f_data);
d1070 2
a1071 1
			(void)printf("  %llx\n", (long long)kf->f_offset);
d1073 2
a1074 1
			(void)printf("  %lld\n", (long long)kf->f_offset);
@


1.81
log
@Don't skip pipe, kqueue, crypto, or systrace files in pstat -f output
Also, cast to long to make printf formatting portable

with help from matthew; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.80 2012/07/09 22:41:45 deraadt Exp $	*/
d34 1
@


1.80
log
@According to miod, KERNBASE used as a userland symbol should die
in a fire.  Start by removing the definitions, before we clean the
headers later.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.79 2012/05/17 17:53:22 deraadt Exp $	*/
d986 1
a986 1
	static char *dtypes[] = { "???", "inode", "socket" };
a1028 2
		if (kf->f_type > DTYPE_SOCKET)
			continue;
d1030 3
a1032 1
		(void)printf("%-8.8s", dtypes[kf->f_type]);
d1053 2
a1054 2
		(void)printf("%6s  %3ld", flagbuf, kf->f_count);
		(void)printf("  %3ld", kf->f_msgcount);
@


1.79
log
@show the f_iflags; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.78 2011/06/28 06:55:30 guenther Exp $	*/
d954 1
a954 1
	(void)printf("%-6s %8lx", state, (u_long)tp->t_session & ~KERNBASE);
@


1.78
log
@Use kvm_getfile2() instead of sysctl(KERN_FILE) for the -f option
Make -T behave as documented: only report totals
Only open the kvm files when necessary

prompted by a comment from matthew@@
ok and corrections millert@@, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.77 2009/10/27 23:59:53 deraadt Exp $	*/
d1044 8
@


1.77
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.76 2009/05/31 19:31:23 thib Exp $	*/
d56 1
a106 1
int	getfiles(char **, size_t *);
d137 1
a137 1
	int i;
d184 2
d191 1
a191 1
	if (nlistf != NULL || memf != NULL)
d194 3
d198 3
a200 2
	if (vnodeflag || dformat)
		if ((kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, buf)) == 0)
d304 1
a304 1
	if (vnodeflag)
d984 2
a985 2
	struct file fp, *ffp, *addr;
	char *buf, flagbuf[16], *fbp;
d992 1
a992 1
	if (kd == 0) {
d1014 7
a1020 10
	if (getfiles(&buf, &len) == -1)
		return;
	/*
	 * Getfiles returns in malloc'd memory a pointer to the first file
	 * structure, and then an array of file structs (whose addresses are
	 * derivable from the previous entry).
	 */
	addr = LIST_FIRST((struct filelist *)buf);
	ffp = (struct file *)(buf + sizeof(struct filelist));
	nfile = (len - sizeof(struct filelist)) / sizeof(struct file);
d1023 2
d1028 2
a1029 3
	for (; (char *)ffp < buf + len; addr = LIST_NEXT(ffp, f_list), ffp++) {
		memmove(&fp, ffp, sizeof fp);
		if ((unsigned)fp.f_type > DTYPE_SOCKET)
d1031 2
a1032 2
		(void)printf("%0*lx ", 2 * (int)sizeof(long), (long)addr);
		(void)printf("%-8.8s", dtypes[fp.f_type]);
d1034 1
a1034 1
		if (fp.f_flag & FREAD)
d1036 1
a1036 1
		if (fp.f_flag & FWRITE)
d1038 1
a1038 1
		if (fp.f_flag & FAPPEND)
d1040 1
a1040 1
		if (fp.f_flag & FHASLOCK)
d1042 1
a1042 1
		if (fp.f_flag & FASYNC)
d1045 4
a1048 3
		(void)printf("%6s  %3ld", flagbuf, fp.f_count);
		(void)printf("  %3ld", fp.f_msgcount);
		(void)printf("  %0*lx", 2 * (int)sizeof(long), (long)fp.f_data);
d1050 1
a1050 1
		if (fp.f_offset == (off_t)-1)
d1052 5
a1056 34
		else if (fp.f_offset < 0)
			(void)printf("  %llx\n", (long long)fp.f_offset);
		else
			(void)printf("  %lld\n", (long long)fp.f_offset);
	}
	free(buf);
}

int
getfiles(char **abuf, size_t *alen)
{
	size_t len;
	int mib[2];
	char *buf;

	/*
	 * XXX
	 * Add emulation of KINFO_FILE here.
	 */
	if (memf != NULL)
		errx(1, "files on dead kernel, not implemented");

	mib[0] = CTL_KERN;
	mib[1] = KERN_FILE;
	if (sysctl(mib, 2, NULL, &len, NULL, 0) == -1) {
		warn("sysctl: KERN_FILE");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL)
		err(1, "malloc: KERN_FILE");
	if (sysctl(mib, 2, buf, &len, NULL, 0) == -1) {
		warn("sysctl: KERN_FILE");
		free(buf);
		return (-1);
a1057 3
	*abuf = buf;
	*alen = len;
	return (0);
@


1.76
log
@Don't define NFS before including kernel header files,
besides it being gnarly its useless since no magic is
done if it is define.

pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.75 2008/10/07 02:28:33 deraadt Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
from: static char sccsid[] = "@@(#)pstat.c	8.9 (Berkeley) 2/16/94";
#else
static char *rcsid = "$OpenBSD: pstat.c,v 1.75 2008/10/07 02:28:33 deraadt Exp $";
#endif
#endif /* not lint */
@


1.75
log
@pstat can hide information too; also based on PR 5113
@
text
@a55 1
#define NFS
a56 1
#undef NFS
@


1.74
log
@sync synopsis and usage; KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.73 2008/02/20 09:49:08 thib Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.73 2008/02/20 09:49:08 thib Exp $";
d1061 3
a1063 1
		if (fp.f_offset < 0)
@


1.73
log
@set globalnl to vnodenl in filemode() so we access the right
thing in the KGET() macros. Fixes a segfault when pstat is
called with '-vT';

ok miod@@,krw@@,beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.72 2007/12/28 19:22:07 chl Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.72 2007/12/28 19:22:07 chl Exp $";
d1197 2
a1198 2
	(void)fprintf(stderr,
	    "usage: pstat [-fknsTtv] [-d format] [-M core] [-N system] [symbols ...]\n");
@


1.72
log
@printf field widths are always int, so add casts to remove
"warning: field width is not type int"

"looks good" otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.71 2007/12/08 18:23:24 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.71 2007/12/08 18:23:24 deraadt Exp $";
d999 2
@


1.71
log
@no need to pre-check for % in dformat, it will fail later anyways
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.70 2007/11/28 17:02:56 tedu Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.70 2007/11/28 17:02:56 tedu Exp $";
d398 1
a398 1
	(void)printf("%*s TYP VFLAG  USE HOLD", 2 * sizeof(long), "ADDR");
d462 1
a462 1
	(void)printf("%0*lx %s %5s %4d %4u", 2 * sizeof(long),
d1036 1
a1036 1
	    2 * sizeof(long), "LOC", 2 * sizeof(long), "DATA");
d1041 1
a1041 1
		(void)printf("%0*lx ", 2 * sizeof(long), (long)addr);
d1057 1
a1057 1
		(void)printf("  %0*lx", 2 * sizeof(long), (long)fp.f_data);
@


1.70
log
@refine format string, support hh and c for real. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.69 2007/11/28 16:33:43 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.69 2007/11/28 16:33:43 deraadt Exp $";
a158 2
			if (*dformat == '%')
				usage();
@


1.69
log
@Be more careful with printf-style formats, and fix a few other niggles
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.68 2007/11/28 11:37:41 tedu Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.68 2007/11/28 11:37:41 tedu Exp $";
d197 1
a197 1
		errx(1, "Only root can use -k");
d221 1
d229 1
a229 1
		 * Support p, c, s, and {l, ll, h, hh, j, t, }[diouxX]
d234 1
a234 1
			;
d238 1
a238 1
			char *ptable[] = { "l", "ll", "h", "hh", "j", "t", "" };
d241 5
a245 4
			for (i = 0; i < sizeof(ptable)/sizeof(ptable[0]); i++) {
				if (strlen(ptable[i]) == n - 1 &&
				    strncmp(ptable[i], dformat,
				    strlen(ptable[i])) == 0)
d248 2
a249 1
			if (i == sizeof(ptable)/sizeof(ptable[0]))
d251 8
a259 4
			if (*dformat == 'l')
				longformat = sizeof(long) == 8;
			if (dformat[0] == 'l' && dformat[1] == 'l')
				longformat = 1;
d306 1
a306 1
					printf(format, (int)v);
@


1.68
log
@add a -d argument, which can be used to peek at values in the kernel.
this is easier than using the ddb console.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.67 2007/11/26 18:32:33 tedu Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.67 2007/11/26 18:32:33 tedu Exp $";
d147 1
a147 1
	int fileflag = 0, swapflag = 0, ttyflag = 0, vnodeflag = 0;
a148 1
	int ch;
d198 4
d220 11
a230 3
		int longformat = 0, stringformat = 0;
		char format[5];
		if (*dformat == 'p' || *dformat == 'l')
d232 24
a255 2
		if (dformat[0] == 'l' && dformat[1] == 'l')
			longformat = 1;
d258 2
a259 1
			snprintf(format, sizeof(format), "%%.8s");
d274 2
d281 1
a281 1
			if (!nl[i].n_value)
d283 10
a292 4
			else {
				long long v;
				printf("at %p: ", nl[i].n_value);
				if (nl[i].n_type == N_DATA) {
d294 6
a299 8
					if (stringformat)
						printf(format, &v);
					else if (longformat)
						printf(format, v);
					else
						printf(format, (int)v);
				}
				printf("\n");
d301 1
d303 4
d1191 1
a1191 1
	    "usage: pstat [-fknsTtv] [-d format] [-M core] [-N system]\n");
@


1.67
log
@cleanup.  nl is a poor name for a global (accessed via macro no less).
also, man page says nlist ends with NULL name, not "".
ok art bob deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.66 2007/09/03 14:26:54 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.66 2007/09/03 14:26:54 deraadt Exp $";
d150 1
d154 1
d156 1
a156 1
	while ((ch = getopt(argc, argv, "TM:N:fiknstv")) != -1)
d158 5
d197 2
d208 1
a208 1
	if (vnodeflag)
d215 48
d268 1
a268 1
	if (!(fileflag | vnodeflag | ttyflag | swapflag | totalflag))
d1146 1
a1146 1
	    "usage: pstat [-fknsTtv] [-M core] [-N system]\n");
@


1.66
log
@malloc(n * m) -> calloc(n, m); ok espie
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.65 2007/09/02 15:19:40 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.65 2007/09/02 15:19:40 deraadt Exp $";
d82 1
a82 1
struct nlist nl[] = {
d95 1
a95 1
	{ "" }
d98 2
d111 1
a111 1
	KGET2(nl[idx].n_value, p, s, msg)
d208 1
a208 1
		if (kvm_nlist(kd, nl) == -1)
d231 2
@


1.65
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.64 2006/06/04 01:39:32 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.64 2006/06/04 01:39:32 deraadt Exp $";
d719 2
a720 2
	if ((vbuf = malloc((numvnodes + 20) *
	    (sizeof(struct vnode *) + sizeof(struct vnode)))) == NULL)
@


1.64
log
@teach this about NMEADISC too
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.63 2006/04/18 17:50:51 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.63 2006/04/18 17:50:51 deraadt Exp $";
d1018 1
a1018 1
	if ((swdev = malloc(nswap * sizeof(*swdev))) == NULL)
@


1.63
log
@simple variable renaming to please lint
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.62 2006/03/27 14:08:14 pedro Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.62 2006/03/27 14:08:14 pedro Exp $";
d870 3
@


1.62
log
@Check for syncer vnodes before the file system specific routine gets
called, so that we handle NFS and ext2fs as well, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.61 2006/03/26 20:15:50 uwe Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.61 2006/03/26 20:15:50 uwe Exp $";
d704 1
a704 1
	struct mntlist mountlist;
d725 2
a726 2
	KGET(V_MOUNTLIST, mountlist);
	for (num = 0, mp = CIRCLEQ_FIRST(&mountlist); ;
d742 1
a742 1
		if (mp == CIRCLEQ_LAST(&mountlist))
d994 1
a994 1
	int div, i, avail, nfree, npfree, used;
d1026 1
a1026 1
	div = blocksize / DEV_BSIZE;
d1039 1
a1039 1
				    hlen, swdev[i].se_nblks / div);
d1042 1
a1042 1
				    hlen, swdev[i].se_nblks / div);
d1054 1
a1054 1
		    used / div, xfree / div,
d1073 1
a1073 1
		    "Total", hlen, avail / div, used / div, nfree / div,
@


1.61
log
@Pretty-print addresses on 64-bit architectures; with input and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.60 2006/03/26 16:49:17 uwe Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.60 2006/03/26 16:49:17 uwe Exp $";
d263 7
a369 6

	/* Syncer vnodes have no associated inode/dinode. */
	if (VTOI(vp) == NULL) {
		printf(" %6c %5c %7c", '-', '-', '-');
		return (0);
	}
@


1.60
log
@Back out -r1.59. I did not follow the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.59 2006/03/26 15:04:10 uwe Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.59 2006/03/26 15:04:10 uwe Exp $";
d280 1
a280 1
	(void)printf("ADDR     TYP VFLAG  USE HOLD");
d344 1
a344 1
	(void)printf("%8lx %s %5s %4d %4u",
d921 1
a921 1
	    8, "LOC", 8, "DATA");
d926 1
a926 1
		(void)printf("%lx ", (long)addr);
d942 1
a942 1
		(void)printf("  %8.1lx", (long)fp.f_data);
@


1.59
log
@Set the width of address columns based on the machine word width.
pedro@@ likes the diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.58 2006/03/25 23:35:13 pedro Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.58 2006/03/25 23:35:13 pedro Exp $";
d280 1
a280 1
	(void)printf("%*s TYP VFLAG  USE HOLD", 2 * sizeof(long), "ADDR");
d344 1
a344 1
	(void)printf("%*lx %s %5s %4d %4u", 2 * sizeof(long), 
d921 1
a921 1
	    2 * sizeof(long), "LOC", 2 * sizeof(long), "DATA");
d926 1
a926 1
		(void)printf("%*lx ", 2 * sizeof(long), (long)addr);
d942 1
a942 1
		(void)printf("  %*.1lx", 2 * sizeof(long), (long)fp.f_data);
@


1.58
log
@Kill double word
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.57 2006/03/25 21:11:52 pedro Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.57 2006/03/25 21:11:52 pedro Exp $";
d280 1
a280 1
	(void)printf("ADDR     TYP VFLAG  USE HOLD");
d344 1
a344 1
	(void)printf("%8lx %s %5s %4d %4u",
d921 1
a921 1
	    8, "LOC", 8, "DATA");
d926 1
a926 1
		(void)printf("%lx ", (long)addr);
d942 1
a942 1
		(void)printf("  %8.1lx", (long)fp.f_data);
@


1.57
log
@Handle syncer vnodes gracefully, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.56 2005/12/28 20:48:18 pedro Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.56 2005/12/28 20:48:18 pedro Exp $";
d698 1
a698 1
 * simulate what a running kernel does in in kinfo_vnode
@


1.56
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.55 2005/12/17 13:56:02 pedro Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.55 2005/12/17 13:56:02 pedro Exp $";
d363 6
@


1.55
log
@Remove the 'on disk' inode (dinode) from the 'in memory' inode in UFS.
Instead of having the dinode inside the inode structure itself, we now
have just a pointer to it, and use a separate pool to allocate dinodes
as needed. Inspiration from FreeBSD, various testing for a while, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.54 2005/12/11 20:46:29 pedro Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.54 2005/12/11 20:46:29 pedro Exp $";
d397 2
a398 2
	type = ip->i_ffs_mode & S_IFMT;
	if (S_ISCHR(ip->i_ffs_mode) || S_ISBLK(ip->i_ffs_mode))
d400 1
a400 1
		    ((name = devname(ip->i_ffs_rdev, type)) == NULL))
d402 1
a402 1
			    major(ip->i_ffs_rdev), minor(ip->i_ffs_rdev));
d406 1
a406 1
		(void)printf(" %7qd", ip->i_ffs_size);
@


1.54
log
@inode/dinode separation for ext2fs
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.53 2005/10/15 18:33:51 otto Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.53 2005/10/15 18:33:51 otto Exp $";
d359 1
d365 4
@


1.53
log
@Use queue macros instead of directly accessing fields. ok miod@@ pat@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.52 2005/05/26 01:45:02 pedro Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.52 2005/05/26 01:45:02 pedro Exp $";
d416 1
d420 4
d425 1
@


1.52
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.51 2005/05/26 01:44:38 pedro Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.51 2005/05/26 01:44:38 pedro Exp $";
d708 2
a709 1
	for (num = 0, mp = mountlist.cqh_first; ; mp = mount.mnt_list.cqe_next) {
d711 2
a712 2
		for (vp = mount.mnt_vnodelist.lh_first;
		    vp != NULL; vp = vnode.v_mntvnodes.le_next) {
d724 1
a724 1
		if (mp == mountlist.cqh_last)
d784 2
a785 1
		for (tp = tty_head.tqh_first; tp; tp = tty.tty_link.tqe_next) {
d897 1
a897 1
	addr = ((struct filelist *)buf)->lh_first;
d905 1
a905 1
	for (; (char *)ffp < buf + len; addr = ffp->f_list.le_next, ffp++) {
@


1.51
log
@remove reference to MNT_UNION
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.50 2005/05/03 03:41:11 djm Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.50 2005/05/03 03:41:11 djm Exp $";
d538 1
a538 1
		/* user visable flags */
@


1.50
log
@setresgid; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.49 2005/02/08 14:48:08 pat Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.49 2005/02/08 14:48:08 pat Exp $";
a561 5
			comma = ",";
		}
		if (flags & MNT_UNION) {
			(void)printf("%sunion", comma);
			flags &= ~MNT_UNION;
@


1.49
log
@* plug memory leaks in some paths. From Andrey Matveev

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.48 2004/09/14 22:33:00 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.48 2004/09/14 22:33:00 deraadt Exp $";
d150 1
d192 4
a195 4
	if (nlistf != NULL || memf != NULL) {
		(void)setegid(getgid());
		(void)setgid(getgid());
	}
d201 3
a203 2
	(void)setegid(getgid());
	(void)setgid(getgid());
@


1.48
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.47 2004/08/03 04:11:49 mjc Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.47 2004/08/03 04:11:49 mjc Exp $";
d960 1
d1041 1
a1058 2

	free(swdev);
@


1.47
log
@make pstat -f show locking

ok art@@ tedu@@
much help from pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.46 2004/03/16 23:11:20 jmc Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.46 2004/03/16 23:11:20 jmc Exp $";
d147 1
a147 1
	int ch, ret;
d204 1
a204 1
		if ((ret = kvm_nlist(kd, nl)) == -1)
d975 1
a975 1
	int hlen = 10, nswap, rnswap;
d999 2
a1000 1
	rnswap = swapctl(SWAP_STATS, swdev, nswap);
@


1.46
log
@add -M and -N to options list;
sort options;
sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.45 2003/09/08 23:31:55 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.45 2003/09/08 23:31:55 deraadt Exp $";
d919 2
a920 6
#ifdef FSHLOCK	/* currently gone */
		if (fp.f_flag & FSHLOCK)
			*fbp++ = 'S';
		if (fp.f_flag & FEXLOCK)
			*fbp++ = 'X';
#endif
@


1.45
log
@insufficient size for mib; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.44 2003/06/02 23:36:54 millert Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.44 2003/06/02 23:36:54 millert Exp $";
d1068 1
a1068 1
	    "usage: pstat [-Tfknstv] [-M core] [-N system]\n");
@


1.44
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.43 2003/01/06 18:33:15 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.43 2003/01/06 18:33:15 deraadt Exp $";
d758 1
a758 1
	int mib[2], ntty, i;
@


1.43
log
@some cleanup; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.42 2003/01/06 05:32:39 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.42 2003/01/06 05:32:39 deraadt Exp $";
@


1.42
log
@only do kvm_openfiles for -v, all others use sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.41 2003/01/06 05:23:34 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.41 2003/01/06 05:23:34 deraadt Exp $";
d737 2
a738 1
char hdr[]="   LINE RAW  CAN  OUT  HWT LWT    COL STATE      SESS  PGID DISC\n";
d775 1
a775 1
	(void)printf(hdr);
d781 2
a782 1
		itp = malloc(nlen);
@


1.41
log
@minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.40 2002/12/12 04:17:14 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.40 2002/12/12 04:17:14 deraadt Exp $";
d200 3
a202 2
	if ((kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, buf)) == 0)
		errx(1, "kvm_openfiles: %s", buf);
d207 4
a210 2
	if ((ret = kvm_nlist(kd, nl)) == -1)
		errx(1, "kvm_nlist: %s", kvm_geterr(kd));
@


1.40
log
@can now get _ttylist via sysctl; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.39 2002/12/09 11:19:39 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.39 2002/12/09 11:19:39 deraadt Exp $";
d95 3
a97 1
#define	V_MOUNTLIST	4		/* no sysctl */
a98 2
#define TTY_TTYLIST	5		/* sysctl */
	{"_ttylist"},
d107 1
a107 1
kvm_t	*kd = 0;
@


1.39
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.38 2002/07/13 00:34:03 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.38 2002/07/13 00:34:03 deraadt Exp $";
d97 1
a97 1
#define TTY_TTYLIST	5		/* no sysctl */
d136 1
a136 1
void	ttyprt(struct tty *);
d737 17
d758 2
a759 1
	int mib[2], ntty;
a770 1
	KGET(TTY_TTYLIST, tty_head);
d772 18
a789 3
	for (tp = tty_head.tqh_first; tp; tp = tty.tty_link.tqe_next) {
		KGET2(tp, &tty, sizeof tty, "tty struct");
		ttyprt(&tty);
d817 1
a817 1
ttyprt(struct tty *tp)
a819 1
	pid_t pgid;
d826 2
a827 2
	(void)printf("%3d %4d ", tp->t_rawq.c_cc, tp->t_canq.c_cc);
	(void)printf("%4d %4d %3d %6d ", tp->t_outq.c_cc,
d836 1
a836 4
	pgid = 0;
	if (tp->t_pgrp != NULL)
		KGET2(&tp->t_pgrp->pg_id, &pgid, sizeof(pid_t), "pgid");
	(void)printf("%6d ", pgid);
@


1.38
log
@slight cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.37 2002/07/12 05:32:51 art Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.37 2002/07/12 05:32:51 art Exp $";
d218 1
a218 1
	exit (0);
@


1.37
log
@remove printing of soon-to-be-gone flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.36 2002/06/19 08:45:52 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.36 2002/06/19 08:45:52 deraadt Exp $";
d147 1
a147 3
main(argc, argv)
	int argc;
	char *argv[];
d149 3
a153 3
	int ch, ret;
	int fileflag, swapflag, ttyflag, vnodeflag;
	char buf[_POSIX2_LINE_MAX];
a154 1
	fileflag = swapflag = ttyflag = vnodeflag = 0;
d222 1
a222 1
vnodemode()
a236 2

#define ST	mp->mnt_stat
d249 2
a250 2
			if (!strncmp(ST.f_fstypename, MOUNT_FFS, MFSNAMELEN) ||
			    !strncmp(ST.f_fstypename, MOUNT_MFS, MFSNAMELEN)) {
d252 1
a252 1
			} else if (!strncmp(ST.f_fstypename, MOUNT_NFS,
d255 1
a255 1
			} else if (!strncmp(ST.f_fstypename, MOUNT_EXT2FS,
d262 2
a263 2
		if (!strncmp(ST.f_fstypename, MOUNT_FFS, MFSNAMELEN) ||
		    !strncmp(ST.f_fstypename, MOUNT_MFS, MFSNAMELEN)) {
d265 1
a265 1
		} else if (!strncmp(ST.f_fstypename, MOUNT_NFS, MFSNAMELEN)) {
d267 1
a267 1
		} else if (!strncmp(ST.f_fstypename, MOUNT_EXT2FS,
d277 1
a277 1
vnode_header()
d283 1
a283 3
vnode_print(avnode, vp)
	struct vnode *avnode;
	struct vnode *vp;
d348 1
a348 1
ufs_header()
d354 1
a354 2
ufs_print(vp)
	struct vnode *vp;
d405 1
a405 1
ext2fs_header()
d411 1
a411 2
ext2fs_print(vp)
	struct vnode *vp;
d450 1
a450 1
nfs_header()
d456 1
a456 2
nfs_print(vp)
	struct vnode *vp;
d484 7
a490 7
#define VT	np->n_vattr
	(void)printf(" %6ld %5s", VT.va_fileid, flagbuf);
	type = VT.va_mode & S_IFMT;
	if (S_ISCHR(VT.va_mode) || S_ISBLK(VT.va_mode))
		if (usenumflag || ((name = devname(VT.va_rdev, type)) == NULL))
			(void)printf("   %2d,%-2d",
			    major(VT.va_rdev), minor(VT.va_rdev));
d503 1
a503 2
getmnt(maddr)
	struct mount *maddr;
d525 1
a525 2
mount_print(mp)
	struct mount *mp;
a528 1
#define ST	mp->mnt_stat
d530 3
a532 2
	(void)printf("%.*s %s on %s", MFSNAMELEN, ST.f_fstypename,
	    ST.f_mntfromname, ST.f_mntonname);
a653 1
#undef ST
d657 1
a657 2
loadvnodes(avnodes)
	int *avnodes;
d688 1
a688 2
kinfo_vnodes(avnodes)
	int *avnodes;
a696 3
#define VPTRSZ  sizeof(struct vnode *)
#define VNODESZ sizeof(struct vnode)

d705 2
a706 1
	if ((vbuf = malloc((numvnodes + 20) * (VPTRSZ + VNODESZ))) == NULL)
d709 2
a710 1
	evbuf = vbuf + (numvnodes + 20) * (VPTRSZ + VNODESZ);
d717 2
a718 1
			if ((bp + VPTRSZ + VNODESZ) > evbuf)
d721 4
a724 4
			memmove(bp, &vp, VPTRSZ);
			bp += VPTRSZ;
			memmove(bp, &vnode, VNODESZ);
			bp += VNODESZ;
d737 1
a737 1
ttymode()
d781 1
a781 1
	{ 0,	       '\0'},
d785 1
a785 2
ttyprt(tp)
	struct tty *tp;
d787 2
a789 2
	pid_t pgid;
	char *name, state[20];
d832 1
a832 1
filemode()
d834 1
a834 2
	struct file fp, *ffp;
	struct file *addr;
d912 1
a912 3
getfiles(abuf, alen)
	char **abuf;
	size_t *alen;
d947 1
a947 1
swapmode()
d1036 1
a1036 1
usage()
@


1.36
log
@mark which nlist[] kmem entries are not needed in the sysctl case, and which are
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.35 2002/06/18 23:41:32 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.35 2002/06/18 23:41:32 deraadt Exp $";
a648 25
			comma = ",";
		}
		if (flags & MNT_MLOCK) {
			(void)printf("%slock", comma);
			flags &= ~MNT_MLOCK;
			comma = ",";
		}
		if (flags & MNT_MWAIT) {
			(void)printf("%swait", comma);
			flags &= ~MNT_MWAIT;
			comma = ",";
		}
		if (flags & MNT_MPBUSY) {
			(void)printf("%sbusy", comma);
			flags &= ~MNT_MPBUSY;
			comma = ",";
		}
		if (flags & MNT_MPWANT) {
			(void)printf("%swant", comma);
			flags &= ~MNT_MPWANT;
			comma = ",";
		}
		if (flags & MNT_UNMOUNT) {
			(void)printf("%sunmount", comma);
			flags &= ~MNT_UNMOUNT;
@


1.35
log
@size_t cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.34 2002/06/16 16:54:29 miod Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.34 2002/06/16 16:54:29 miod Exp $";
d87 1
a87 5
#define	V_MOUNTLIST	0
	{ "_mountlist" },	/* address of head of mount list. */
#define V_NUMV		1
	{ "_numvnodes" },
#define	FNL_NFILE	2
d89 1
a89 1
#define FNL_MAXFILE	3
d91 1
a91 1
#define TTY_NTTY	4
d93 5
a97 1
#define TTY_TTYLIST	5
a98 1
#define NLMANDATORY TTY_TTYLIST	/* names up to here are mandatory */
@


1.34
log
@When processing the KERN_VNODE sysctl, the kernel builds a packed structure,
while pstat(8) expects a C structure abiding the regular structure packing
rules. This caused pstat -v to break on powerpc.

Unbreak the confusion by defining the structure in a common header file,
and having the kernel use it.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.33 2002/06/08 23:41:42 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.33 2002/06/08 23:41:42 angelos Exp $";
d125 1
a125 1
int	getfiles(char **, int *);
d735 2
a736 2
	int num, numvnodes;
	int mib[2];
a779 1
	int ntty, nlen;
d782 2
a783 1
	int mib[2];
a878 1
	int len, maxfile, nfile;
d880 2
a881 1
	int mib[2];
d957 1
a957 1
	int *alen;
@


1.33
log
@Take advantage of sysctls for stats --- not in use, as we need the
mountlist and the ttylist. To come.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.32 2002/06/02 22:38:57 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.32 2002/06/02 22:38:57 deraadt Exp $";
a224 5
struct e_vnode {
	struct vnode *avnode;
	struct vnode vnode;
};

d267 1
a267 1
		vnode_print(evp->avnode, vp);
@


1.32
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.31 2002/05/30 19:09:05 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.31 2002/05/30 19:09:05 deraadt Exp $";
d108 1
a108 1
kvm_t	*kd;
d741 1
d746 8
a753 1
	KGET(V_NUMV, numvnodes);
d785 1
a785 1
	int ntty;
d788 1
d790 8
a797 1
	KGET(TTY_NTTY, ntty);
d886 1
d888 20
a907 5
	KGET(FNL_MAXFILE, maxfile);
	if (totalflag) {
		KGET(FNL_NFILE, nfile);
		(void)printf("%3d/%3d files\n", nfile, maxfile);
		return;
d909 1
@


1.31
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.30 2002/03/14 16:44:25 mpech Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.30 2002/03/14 16:44:25 mpech Exp $";
d305 1
a305 1
	switch(vp->v_type) {
@


1.30
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.29 2002/02/16 21:28:07 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.29 2002/02/16 21:28:07 millert Exp $";
d298 1
a298 1
	char *type, flags[16]; 
d324 1
a324 1
	default: 
d361 1
a361 1
ufs_header() 
d367 1
a367 1
ufs_print(vp) 
d409 1
a409 1
			(void)printf("   %2d,%-2d", 
d419 1
a419 1
ext2fs_header() 
d425 1
a425 1
ext2fs_print(vp) 
d465 1
a465 1
nfs_header() 
d471 1
a471 1
nfs_print(vp) 
d505 1
a505 1
			(void)printf("   %2d,%-2d", 
d513 1
a513 1
	
d771 1
a771 1
	
d827 1
a827 1
	(void)printf("%4d %4d %3d %6d ", tp->t_outq.c_cc, 
d887 1
a887 1
	
d1026 1
a1026 1
		(void)printf("%8d %8d %5.0f%%    %d\n", 
d1032 1
a1032 1
	/* 
@


1.29
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.28 2002/01/19 00:03:29 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.28 2002/01/19 00:03:29 millert Exp $";
d233 3
a235 3
	register struct e_vnode *e_vnodebase, *endvnode, *evp;
	register struct vnode *vp;
	register struct mount *maddr, *mp = NULL;
d300 1
a300 1
	register int flag;
d370 1
a370 1
	register int flag;
d428 1
a428 1
	register int flag;
d476 1
a476 1
	register int flag;
d527 1
a527 1
	register struct mtab *mt;
d545 1
a545 1
	register int flags;
d816 1
a816 1
	register struct tty *tp;
d818 1
a818 1
	register int i, j;
@


1.28
log
@We don't have <sys/map.h> any more; Tim Tickel
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.27 2001/08/11 01:27:47 pvalchev Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.27 2001/08/11 01:27:47 pvalchev Exp $";
d124 2
a125 2
void	filemode __P((void));
int	getfiles __P((char **, int *));
d127 1
a127 1
	getmnt __P((struct mount *));
d129 1
a129 1
	kinfo_vnodes __P((int *));
d131 15
a145 15
	loadvnodes __P((int *));
void	mount_print __P((struct mount *));
void	nfs_header __P((void));
int	nfs_print __P((struct vnode *));
void	swapmode __P((void));
void	ttymode __P((void));
void	ttyprt __P((struct tty *));
void	ufs_header __P((void));
int	ufs_print __P((struct vnode *));
void	ext2fs_header __P((void));
int	ext2fs_print __P((struct vnode *));
void	usage __P((void));
void	vnode_header __P((void));
void	vnode_print __P((struct vnode *, struct vnode *));
void	vnodemode __P((void));
@


1.27
log
@cleanup; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.26 2001/06/24 17:03:19 csapuntz Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.26 2001/06/24 17:03:19 csapuntz Exp $";
a54 1
#include <sys/map.h>
@


1.26
log
@

Get rid of NQNFS options
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.25 2001/02/25 05:33:08 csapuntz Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.25 2001/02/25 05:33:08 csapuntz Exp $";
d357 1
a357 1
	(void)printf("%8lx %s %5s %4d %4ld",
d892 1
a892 1
	    sizeof (long) * 2, "LOC", sizeof (long) *2, "DATA");
d920 1
a920 1
			(void)printf("  %qx\n", fp.f_offset);
d922 1
a922 1
			(void)printf("  %qd\n", fp.f_offset);
@


1.25
log
@

Update pstat to reflect vnode changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.24 2000/06/16 19:03:48 assar Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.24 2000/06/16 19:03:48 assar Exp $";
a490 6
	if (flag & NQNFSNONCACHE)
		*flags++ = 'X';
	if (flag & NQNFSWRITE)
		*flags++ = 'O';
	if (flag & NQNFSEVICTED)
		*flags++ = 'G';
@


1.24
log
@update and sort list of vflags, iflags, nfsflags, mntflags.  also
update man-page to be compatible with the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.23 2000/05/24 03:24:23 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.23 2000/05/24 03:24:23 deraadt Exp $";
d53 1
d344 1
a344 1
	if (flag & VBWAIT)
d348 1
a348 3
	if (flag & VDIROP)
		*fp++ = 'D';
	if (flag & VONFREELIST)
d352 1
a352 1
	if (flag & VONSYNCLIST)
@


1.23
log
@handle 64 bit arch in -f; janjaap@@stack.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.22 1999/12/05 08:49:18 art Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.22 1999/12/05 08:49:18 art Exp $";
d349 6
a387 4
	if (flag & IN_RENAME)
		*flags++ = 'R';
	if (flag & IN_UPDATE)
		*flags++ = 'U';
d392 2
d396 2
a443 4
	if (flag & IN_RENAME)
		*flags++ = 'R';
	if (flag & IN_UPDATE)
		*flags++ = 'U';
d448 2
d452 2
d498 6
d639 5
d650 15
d688 5
@


1.22
log
@Learn pstat about soft updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.21 1999/06/23 15:56:36 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.21 1999/06/23 15:56:36 millert Exp $";
d860 3
a862 1
	(void)printf("     LOC TYPE       FLG  CNT  MSG      DATA  OFFSET\n");
@


1.21
log
@Use DEV_BSIZE instead of hard-coding 512
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.20 1999/06/03 15:49:31 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.20 1999/06/03 15:49:31 deraadt Exp $";
d656 5
@


1.20
log
@sysctl of KERN_FILE returns a list of mis-aligned file structs; compensate
by copying to private space... since changing the kernel API will be difficult.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.19 1999/05/22 21:43:52 weingart Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.19 1999/05/22 21:43:52 weingart Exp $";
d963 1
a963 1
	div = blocksize / 512;
d1002 3
a1004 1
		(void)printf("%dM/%dM swap space\n", used / 2048, avail / 2048);
@


1.19
log
@Update for new vmswap code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.18 1998/07/08 22:13:29 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.18 1998/07/08 22:13:29 deraadt Exp $";
d831 1
a831 1
	register struct file *fp;
d851 1
a851 1
	fp = (struct file *)(buf + sizeof(struct filelist));
d856 3
a858 2
	for (; (char *)fp < buf + len; addr = fp->f_list.le_next, fp++) {
		if ((unsigned)fp->f_type > DTYPE_SOCKET)
d861 1
a861 1
		(void)printf("%-8.8s", dtypes[fp->f_type]);
d863 1
a863 1
		if (fp->f_flag & FREAD)
d865 1
a865 1
		if (fp->f_flag & FWRITE)
d867 1
a867 1
		if (fp->f_flag & FAPPEND)
d870 1
a870 1
		if (fp->f_flag & FSHLOCK)
d872 1
a872 1
		if (fp->f_flag & FEXLOCK)
d875 1
a875 1
		if (fp->f_flag & FASYNC)
d878 6
a883 5
		(void)printf("%6s  %3ld", flagbuf, fp->f_count);
		(void)printf("  %3ld", fp->f_msgcount);
		(void)printf("  %8.1lx", (long)fp->f_data);
		if (fp->f_offset < 0)
			(void)printf("  %qx\n", fp->f_offset);
d885 1
a885 1
			(void)printf("  %qd\n", fp->f_offset);
@


1.18
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.17 1998/06/25 17:04:29 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.17 1998/06/25 17:04:29 deraadt Exp $";
d72 1
d87 1
a87 13
#define VM_SWAPMAP	0
	{ "_swapmap" },	/* list of free swap areas */
#define VM_NSWAPMAP	1
	{ "_nswapmap" },/* size of the swap map */
#define VM_SWDEVT	2
	{ "_swdevt" },	/* list of swap devices and sizes */
#define VM_NSWAP	3
	{ "_nswap" },	/* size of largest swap device */
#define VM_NSWDEV	4
	{ "_nswdev" },	/* number of swap devices */
#define VM_DMMAX	5
	{ "_dmmax" },	/* maximum size of a swap block */
#define	V_MOUNTLIST	6
d89 1
a89 1
#define V_NUMV		7
d91 1
a91 1
#define	FNL_NFILE	8
d93 1
a93 1
#define FNL_MAXFILE	9
d95 1
a95 1
#define TTY_NTTY	10
d97 1
a97 1
#define TTY_TTYLIST	11
a99 4
#define VM_NISWAP	NLMANDATORY + 1
	{ "_niswap" },
#define VM_NISWDEV	NLMANDATORY + 2
	{ "_niswdev" },
d154 1
a154 1
	int ch, i, quit, ret;
d210 2
a211 11
	if ((ret = kvm_nlist(kd, nl)) != 0) {
		if (ret == -1)
			errx(1, "kvm_nlist: %s", kvm_geterr(kd));
		for (i = quit = 0; i <= NLMANDATORY; i++)
			if (!nl[i].n_value) {
				quit = 1;
				warnx("undefined symbol: %s", nl[i].n_name);
			}
		if (quit)
			exit(1);
	}
d235 1
a235 1
	register struct mount *maddr, *mp;
d352 2
a353 2
	(void)printf("%8x %s %5s %4d %4d",
	    avnode, type, flags, vp->v_usecount, vp->v_holdcnt);
a426 2
	char *name;
	mode_t type;
d497 1
a497 1
	(void)printf(" %6d %5s", VT.va_fileid, flagbuf);
d529 1
a529 1
		err(1, NULL);
a541 1
	char *type;
d547 1
a547 1
	if (flags = mp->mnt_flag) {
d685 1
a685 1
		err(1, NULL);
d713 1
a713 1
		err(1, NULL);
d743 1
a743 1
	int ntty, i;
d801 1
a801 1
	(void)printf("%-6s %8x", state, (u_long)tp->t_session & ~KERNBASE);
d859 1
a859 1
		(void)printf("%x ", addr);
d877 3
a879 3
		(void)printf("%6s  %3d", flagbuf, fp->f_count);
		(void)printf("  %3d", fp->f_msgcount);
		(void)printf("  %8.1x", fp->f_data);
d911 1
a911 1
		err(1, NULL);
d929 4
a932 6
	int hlen = 10, nswap, nswdev, dmmax, nswapmap, niswap, niswdev;
	int s, e, div, i, l, avail, nfree, npfree, used;
	struct swdevt *sw;
	long blocksize, *perdev;
	struct map *swapmap, *kswapmap;
	struct mapent *mp;
d941 1
a941 5
	KGET(VM_NSWAP, nswap);
	KGET(VM_NSWDEV, nswdev);
	KGET(VM_DMMAX, dmmax);
	KGET(VM_NSWAPMAP, nswapmap);
	KGET(VM_SWAPMAP, kswapmap);	/* kernel `swapmap' is a pointer */
d946 1
a946 1
			    "Used", "Avail", "Capacity", "Type");
d948 1
a948 1
		    "Total", hlen, 0, 0, 0, 0);
d951 1
a951 3
	if ((sw = malloc(nswdev * sizeof(*sw))) == NULL ||
	    (perdev = malloc(nswdev * sizeof(*perdev))) == NULL ||
	    (mp = malloc(nswapmap * sizeof(*mp))) == NULL)
d953 1
a953 74
	KGET1(VM_SWDEVT, sw, nswdev * sizeof(*sw), "swdevt");
	KGET2((long)kswapmap, mp, nswapmap * sizeof(*mp), "swapmap");

	/* Supports sequential swap */
	if (nl[VM_NISWAP].n_value != 0) {
		KGET(VM_NISWAP, niswap);
		KGET(VM_NISWDEV, niswdev);
	} else {
		niswap = nswap;
		niswdev = nswdev;
	}

	/* First entry in map is `struct map'; rest are mapent's. */
	swapmap = (struct map *)mp;
	if (nswapmap != swapmap->m_limit - (struct mapent *)kswapmap)
		errx(1, "panic: nswapmap goof");

	/* Count up swap space. */
	nfree = 0;
	memset(perdev, 0, nswdev * sizeof(*perdev));
	for (mp++; mp->m_addr != 0; mp++) {
		s = mp->m_addr;			/* start of swap region */
		e = mp->m_addr + mp->m_size;	/* end of region */
		nfree += mp->m_size;

		/*
		 * Swap space is split up among the configured disks.
		 *
		 * For interleaved swap devices, the first dmmax blocks
		 * of swap space some from the first disk, the next dmmax
		 * blocks from the next, and so on up to niswap blocks.
		 *
		 * Sequential swap devices follow the interleaved devices
		 * (i.e. blocks starting at niswap) in the order in which
		 * they appear in the swdev table.  The size of each device
		 * will be a multiple of dmmax.
		 *
		 * The list of free space joins adjacent free blocks,
		 * ignoring device boundries.  If we want to keep track
		 * of this information per device, we'll just have to
		 * extract it ourselves.  We know that dmmax-sized chunks
		 * cannot span device boundaries (interleaved or sequential)
		 * so we loop over such chunks assigning them to devices.
		 */
		i = -1;
		while (s < e) {		/* XXX this is inefficient */
			int bound = roundup(s+1, dmmax);

			if (bound > e)
				bound = e;
			if (bound <= niswap) {
				/* Interleaved swap chunk. */
				if (i == -1)
					i = (s / dmmax) % niswdev;
				perdev[i] += bound - s;
				if (++i >= niswdev)
					i = 0;
			} else {
				/* Sequential swap chunk. */
				if (i < niswdev) {
					i = niswdev;
					l = niswap + sw[i].sw_nblks;
				}
				while (s >= l) {
					/* XXX don't die on bogus blocks */
					if (i == nswdev-1)
						break;
					l += sw[++i].sw_nblks;
				}
				perdev[i] += bound - s;
			}
			s = bound;
		}
	}
d958 3
a960 1
		    "Used", "Avail", "Capacity", "Type");
d962 2
a963 2
	avail = npfree = 0;
	for (i = 0; i < nswdev; i++) {
d966 1
a966 5
		/*
		 * Don't report statistics for partitions which have not
		 * yet been activated via swapon(8).
		 */
		if (!(sw[i].sw_flags & SW_FREED))
d972 3
a974 2
				    major(sw[i].sw_dev), minor(sw[i].sw_dev),
				    hlen, sw[i].sw_nblks / div);
d976 2
a977 3
				(void)printf("%s%-6s %*d ", _PATH_DEV,
				    devname(sw[i].sw_dev, S_IFBLK),
				    hlen, sw[i].sw_nblks / div);
d980 4
a983 3
		xsize = sw[i].sw_nblks;
		xfree = perdev[i];
		used = xsize - xfree;
d988 1
a988 1
		(void)printf("%8d %8d %5.0f%%    %s\n", 
d991 1
a991 2
		    (sw[i].sw_flags & SW_SEQUENTIAL) ?
			     "Sequential" : "Interleaved");
d1008 2
@


1.17
log
@handle no swap case
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.16 1997/11/09 22:03:29 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.16 1997/11/09 22:03:29 millert Exp $";
d221 4
@


1.16
log
@#if 0 out references to IN_LOCKED, IN_WANTED, IN_LWAIT.
Need to merge in changes from lite2 pstat.c but this will do for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.15 1997/09/18 08:59:54 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.15 1997/09/18 08:59:54 deraadt Exp $";
d952 1
a952 1
	int hlen, nswap, nswdev, dmmax, nswapmap, niswap, niswdev;
d959 7
d971 9
a1058 6
	if (kflag) {
		header = "1K-blocks";
		blocksize = 1024;
		hlen = strlen(header);
	} else
		header = getbsize(&hlen, &blocksize);
@


1.15
log
@make pstat -f columns line up
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.14 1997/09/18 08:54:09 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.14 1997/09/18 08:54:09 deraadt Exp $";
d394 1
d399 3
a415 2
	if (flag & IN_LWAIT)
		*flags++ = 'Z';
d452 1
d457 3
a473 2
	if (flag & IN_LWAIT)
		*flags++ = 'Z';
@


1.14
log
@lengthen terminal name, make columns line up
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.13 1997/09/12 04:07:19 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.13 1997/09/12 04:07:19 millert Exp $";
d874 1
a874 1
	(void)printf("   LOC   TYPE    FLG     CNT  MSG    DATA    OFFSET\n");
@


1.13
log
@Kill extra newline in err()/warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.12 1997/08/10 04:55:18 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.12 1997/08/10 04:55:18 millert Exp $";
d757 1
a757 1
char hdr[]="  LINE  RAW  CAN  OUT  HWT LWT    COL STATE      SESS  PGID DISC\n";
d808 1
a808 1
		(void)printf("%2d,%-3d  ", major(tp->t_dev), minor(tp->t_dev));
d810 1
a810 1
		(void)printf("%6s ", name);
@


1.12
log
@Line up better with -t.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.11 1997/08/07 20:58:30 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.11 1997/08/07 20:58:30 millert Exp $";
d921 1
a921 1
		errx(1, "files on dead kernel, not implemented\n");
@


1.11
log
@Support -n in conjunction with -s.  Problem noted by
Carsten Hammer <chammer@@vogon.party.de>.  Fixes PR#297.
Also made "pstat -tn" consistent with -n in other modes
(and it now lines up correctly).
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.10 1997/05/31 08:48:20 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.10 1997/05/31 08:48:20 deraadt Exp $";
d808 1
a808 1
		(void)printf("%2d,%-2d   ", major(tp->t_dev), minor(tp->t_dev));
d810 1
a810 1
		(void)printf("%-7s ", name);
@


1.10
log
@various
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.9 1997/05/31 07:37:58 downsj Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.9 1997/05/31 07:37:58 downsj Exp $";
d79 1
d808 1
a808 1
		(void)printf("0x%3x:%1x ", major(tp->t_dev), minor(tp->t_dev)); 
d1061 10
a1070 4
		if (!totalflag)
			(void)printf("/dev/%-6s %*d ",
			    devname(sw[i].sw_dev, S_IFBLK),
			    hlen, sw[i].sw_nblks / div);
@


1.9
log
@Support for ext2fs vnodes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.8 1997/05/30 13:28:38 downsj Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.8 1997/05/30 13:28:38 downsj Exp $";
d366 2
@


1.8
log
@FFS changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.7 1996/12/22 03:29:03 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.7 1996/12/22 03:29:03 deraadt Exp $";
d154 2
d285 3
d297 3
d426 46
@


1.7
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: pstat.c,v 1.6 1996/11/24 23:42:11 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.6 1996/11/24 23:42:11 millert Exp $";
d408 4
a411 3
	type = ip->i_mode & S_IFMT;
	if (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode))
		if (usenumflag || ((name = devname(ip->i_rdev, type)) == NULL))
d413 1
a413 1
			    major(ip->i_rdev), minor(ip->i_rdev));
d417 1
a417 1
		(void)printf(" %7qd", ip->i_size);
@


1.6
log
@Add recognition for remaining mount flags (from <sys/mount.h>)
that make sense to "pstat -v".  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: $";
d211 2
a212 1
	if (nlistf != NULL || memf != NULL)
d214 1
@


1.5
log
@update ttystats
@
text
@d1 2
a2 1
/*	$NetBSD: pstat.c,v 1.19.4.3 1996/06/03 19:00:46 cgd Exp $	*/
d47 1
a47 1
static char *rcsid = "$NetBSD: pstat.c,v 1.19.4.3 1996/06/03 19:00:46 cgd Exp $";
d536 15
d556 13
a568 3
		if (flags & MNT_EXRDONLY) {
			(void)printf("%sexrdonly", comma);
			flags &= ~MNT_EXRDONLY;
@


1.4
log
@from netbsd:
handle the VISTTY vnode flag with the same letter ('I') that BSDI used.
Update the documentation of the vnode flags so that it lists only (and all)
of the flags understood by the program.  (The documentation is likely in need
of more cleanup.)
@
text
@d1 1
a1 2
/*	$OpenBSD: pstat.c,v 1.3 1996/03/25 15:56:06 niklas Exp $	*/
/*	$NetBSD: pstat.c,v 1.19 1996/05/02 00:13:19 cgd Exp $	*/
a44 1
from: static char *rcsid = "$NetBSD: pstat.c,v 1.19 1996/05/02 00:13:19 cgd Exp $";
d46 1
a46 1
static char *rcsid = "$OpenBSD: pstat.c,v 1.3 1996/03/25 15:56:06 niklas Exp $";
d104 5
a108 1
#define NLMANDATORY FNL_MAXFILE	/* names up to here are mandatory */
a112 65
#define	SCONS		NLMANDATORY + 3
	{ "_constty" },
#define	SPTY		NLMANDATORY + 4
	{ "_pt_tty" },
#define	SNPTY		NLMANDATORY + 5
	{ "_npty" },

#ifdef sparc
#define SZS	(SNPTY+1)
	{ "_zs_tty" },
#define SCZS	(SNPTY+2)
	{ "_zscd" },
#endif

#ifdef hp300
#define	SDCA	(SNPTY+1)
	{ "_dca_tty" },
#define	SNDCA	(SNPTY+2)
	{ "_ndca" },
#define	SDCM	(SNPTY+3)
	{ "_dcm_tty" },
#define	SNDCM	(SNPTY+4)
	{ "_ndcm" },
#define	SDCL	(SNPTY+5)
	{ "_dcl_tty" },
#define	SNDCL	(SNPTY+6)
	{ "_ndcl" },
#define	SITE	(SNPTY+7)
	{ "_ite_tty" },
#define	SNITE	(SNPTY+8)
	{ "_nite" },
#endif

#ifdef mips
#define SDC	(SNPTY+1)
	{ "_dc_tty" },
#define SNDC	(SNPTY+2)
	{ "_dc_cnt" },
#endif

#ifdef i386
#define SPC	(SNPTY+1)
	{ "_pc_tty" },
#define SCPC	(SNPTY+2)
	{ "_pccd" },
#define SCOM	(SNPTY+3)
	{ "_com_tty" },
#define SCCOM	(SNPTY+4)
	{ "_comcd" },
#endif
#ifdef amiga
#define SSER	(SNPTY + 1)
	{ "_ser_tty" },
#define SCSER	(SNPTY + 2)
	{ "_sercd" },
#define SITE	(SNPTY + 3)
	{ "_ite_tty" },
#define SCITE	(SNPTY + 4)
	{ "_itecd" },
#define SMFCS	(SNPTY + 5)
	{ "_mfcs_tty" },
#define SCMFCS	(SNPTY + 6)
	{ "_mfcscd" },
#endif

d150 1
a150 4
void	ttyprt __P((struct tty *, int));
void	ttytype __P((char *, int, int));
void	ttytype_newcf __P((char *, int, int));
void	ttytype_oldcf __P((char *, int, int));
d221 1
a221 1
				warnx("undefined symbol: %s\n", nl[i].n_name);
d671 1
a671 1
char hdr[]="  LINE  RAW  CAN  OUT  HWT LWT    COL STATE    SESS  PGID DISC\n";
d676 7
a682 96

#ifdef sparc
	ttytype("console", SCONS, 1);
	ttytype_newcf("zs", SZS, SCZS);
#endif

#ifdef vax
	/* May fill in this later */
#endif
#ifdef tahoe
	if (nl[SNVX].n_type != 0)
		ttytype_oldcf("vx", SVX, SNVX);
	if (nl[SNMP].n_type != 0)
		ttytype_oldcf("mp", SMP, SNMP);
#endif
#ifdef hp300
	if (nl[SNITE].n_type != 0)
		ttytype_oldcf("ite", SITE, SNITE);
	if (nl[SNDCA].n_type != 0)
		ttytype_oldcf("dca", SDCA, SNDCA);
	if (nl[SNDCM].n_type != 0)
		ttytype_oldcf("dcm", SDCM, SNDCM);
	if (nl[SNDCL].n_type != 0)
		ttytype_oldcf("dcl", SDCL, SNDCL);
#endif
#ifdef mips
	if (nl[SNDC].n_type != 0)
		ttytype_oldcf("dc", SDC, SNDC);
#endif
#ifdef i386
	if (nl[SCPC].n_type != 0)
		ttytype_newcf("pc", SPC, SCPC);
	if (nl[SCCOM].n_type != 0)
		ttytype_newcf("com", SCOM, SCCOM);
#endif
#ifdef amiga
	if (nl[SCSER].n_type != 0)
		ttytype_newcf("ser", SSER, SCSER);
	if (nl[SCITE].n_type != 0)
		ttytype_newcf("ite", SITE, SCITE);
	if (nl[SCMFCS].n_type != 0)
		ttytype_newcf("mfcs", SMFCS, SCMFCS);
#endif
	if (nl[SNPTY].n_type != 0)
		ttytype_oldcf("pty", SPTY, SNPTY);
}

void
ttytype_oldcf(name, type, number)
	char *name;
	int type, number;
{
	int ntty;

	KGET(number, ntty);
	ttytype(name, type, ntty);
}

void
ttytype_newcf(name, type, config)
	char *name;
	int type, config;
{
	struct cfdriver cf;
	void **cd;
	int i;

	KGET(config, cf);
	cd = malloc(cf.cd_ndevs * sizeof(void *));
	if (!cd)
		return;
	KGET2(cf.cd_devs, cd, cf.cd_ndevs * sizeof(void *), "cfdevicep");
	for (i = cf.cd_ndevs - 1; i >= 0; --i)
		if (cd[i])
			break;
	free(cd);
	ttytype(name, type, i + 1);
}

void
ttytype(name, type, number)
	char *name;
	int type, number;
{
	static struct tty **ttyp;
	static int nttyp;
	static struct tty tty;
	int ntty = number, i;

	(void)printf("%d %s %s\n", ntty, name, (ntty == 1) ? "line" : "lines");
	if (ntty > nttyp) {
		nttyp = ntty;
		if ((ttyp = realloc(ttyp, nttyp * sizeof(*ttyp))) == 0)
			err(1, NULL);
	}
	KGET1(type, ttyp, nttyp * sizeof(*ttyp), "tty pointers");
d684 3
a686 5
	for (i = 0; i < ntty; i++) {
		if (ttyp[i] == NULL)
			continue;
		KGET2(ttyp[i], &tty, sizeof(struct tty), "tty struct");
		ttyprt(&tty, i);
d714 1
a714 1
ttyprt(tp, line)
a715 1
	int line;
d721 2
a722 3
	if (usenumflag || tp->t_dev == 0 ||
	   (name = devname(tp->t_dev, S_IFCHR)) == NULL)
		(void)printf("%7d ", line); 
d734 1
a734 1
	(void)printf("%-6s %6x", state, (u_long)tp->t_session & ~KERNBASE);
d752 3
d968 7
a979 10
		/*
		 * Don't report statistics for partitions which have not
		 * yet been activated via swapon(8).
		 */
		if (!(sw[i].sw_flags & SW_FREED)) {
			if (totalflag)
				continue;
			(void)printf(" *** not available for swapping ***\n");
			continue;
		}
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pstat.c,v 1.17 1996/02/21 02:27:57 cgd Exp $	*/
d46 1
a46 1
from: static char *rcsid = "$NetBSD: pstat.c,v 1.17 1996/02/21 02:27:57 cgd Exp $";
d48 1
a48 1
static char *rcsid = "$OpenBSD$";
d411 2
d621 5
d716 1
a716 1
	for (num = 0, mp = mountlist.cqh_first; ; mp = mp->mnt_list.cqe_next) {
d719 1
a719 1
		    vp != NULL; vp = vp->v_mntvnodes.le_next) {
@


1.2
log
@complete ufs -> ffs change (From John Kohl; PR #1403)
@
text
@d1 3
d44 6
a49 2
/* from: static char sccsid[] = "@@(#)pstat.c	8.9 (Berkeley) 2/16/94"; */
static char *rcsid = "$Id: pstat.c,v 1.14.2.1 1995/11/01 00:06:38 jtc Exp $";
d66 2
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char *rcsid = "$Id: pstat.c,v 1.14 1995/08/24 19:58:07 ragge Exp $";
d331 1
a331 1
			if (!strncmp(ST.f_fstypename, MOUNT_UFS, MFSNAMELEN) ||
d341 1
a341 1
		if (!strncmp(ST.f_fstypename, MOUNT_UFS, MFSNAMELEN) ||
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
