head	1.28;
access;
symbols
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.20.0.20
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.18
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.14
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.12
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.10
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.8
	OPENBSD_5_0:1.20.0.6
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.19.0.8
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11;
locks; strict;
comment	@ * @;


1.28
date	2017.04.18.02.29.56;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	0b2VaK4OUJUaWS29;

1.27
date	2016.08.27.04.21.08;	author guenther;	state Exp;
branches;
next	1.26;
commitid	5Bg26nDF24JkfeXC;

1.26
date	2016.07.18.21.22.09;	author benno;	state Exp;
branches;
next	1.25;
commitid	tKWOroa43nDNjz1k;

1.25
date	2015.10.18.02.39.04;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	V1CXM3C8XhqLUe7U;

1.24
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	z3HrihslRYb4HqW9;

1.23
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	Uu5nFG3wCl0LACBb;

1.22
date	2014.10.26.14.47.37;	author chl;	state Exp;
branches;
next	1.21;
commitid	wq0TlPacQi5WHm0H;

1.21
date	2014.10.16.04.05.39;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	CDcd42NWtnAYrKGw;

1.20
date	2010.06.29.18.10.04;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.02.15.19.40;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.09.01.01.13.25;	author mpf;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.31.17.28.33;	author mpf;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.30.18.26.33;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.02.20.31.48;	author moritz;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.02.20.09.43;	author mcbride;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.15.05.09.29;	author david;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.26.09.53.46;	author moritz;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.28.01.07.52;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.27.18.05.27;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.26.19.19.51;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.26.05.34.17;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.26.00.55.03;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.24.03.15.11;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.24.02.49.32;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.24.02.35.39;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.23.19.53.27;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.22.20.35.48;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.30.18.44.49;	author ho;	state Exp;
branches;
next	;


desc
@@


1.28
log
@use freezero()
@
text
@/*	$OpenBSD: pfkey.c,v 1.27 2016/08/27 04:21:08 guenther Exp $	*/

/*
 * Copyright (c) 2005 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Multicom Security AB.
 */


#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/sysctl.h>
#include <net/pfkeyv2.h>
#include <netinet/ip_ipsp.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "sasyncd.h"
#include "monitor.h"
#include "net.h"

struct pfkey_msg
{
	SIMPLEQ_ENTRY(pfkey_msg)	next;

	u_int8_t	*buf;
	u_int32_t	 len;
};

SIMPLEQ_HEAD(, pfkey_msg)		pfkey_msglist;

static const char *msgtypes[] = {
	"RESERVED", "GETSPI", "UPDATE", "ADD", "DELETE", "GET", "ACQUIRE",
	"REGISTER", "EXPIRE", "FLUSH", "DUMP", "X_PROMISC", "X_ADDFLOW",
	"X_DELFLOW", "X_GRPSPIS", "X_ASKPOLICY", "X_SPDDUMP"
};

#define CHUNK sizeof(u_int64_t)

static const char *pfkey_print_type(struct sadb_msg *);

static int
pfkey_write(u_int8_t *buf, ssize_t len)
{
	struct sadb_msg *msg = (struct sadb_msg *)buf;
	ssize_t n;

	if (cfgstate.pfkey_socket == -1)
		return 0;

	do {
		n = write(cfgstate.pfkey_socket, buf, len);
	} while (n == -1 && (errno == EAGAIN || errno == EINTR));
	if (n == -1) {
		log_err("pfkey: msg %s write() failed on socket %d",
		    pfkey_print_type(msg), cfgstate.pfkey_socket);
		return -1;
	}

	return 0;
}

int
pfkey_set_promisc(void)
{
	struct sadb_msg	msg;
	static u_int32_t seq = 1;

	memset(&msg, 0, sizeof msg);
	msg.sadb_msg_version = PF_KEY_V2;
	msg.sadb_msg_seq = seq++;
	msg.sadb_msg_satype = 1; /* Special; 1 to enable, 0 to disable */
	msg.sadb_msg_type = SADB_X_PROMISC;
	msg.sadb_msg_pid = getpid();
	msg.sadb_msg_len = sizeof msg / CHUNK;

	return pfkey_write((u_int8_t *)&msg, sizeof msg);
}

/* Send a SADB_FLUSH PFKEY message to peer 'p' */
static void
pfkey_send_flush(struct syncpeer *p)
{
	struct sadb_msg *m = calloc(1, sizeof *m);
	static u_int32_t seq = 1;

	if (m) {
		memset(m, 0, sizeof *m);
		m->sadb_msg_version = PF_KEY_V2;
		m->sadb_msg_seq = seq++;
		m->sadb_msg_type = SADB_FLUSH;
		m->sadb_msg_satype = SADB_SATYPE_UNSPEC;
		m->sadb_msg_pid = getpid();
		m->sadb_msg_len = sizeof *m / CHUNK;

		log_msg(2, "pfkey_send_flush: sending FLUSH to peer %s",
		    p->name);
		net_queue(p, MSG_PFKEYDATA, (u_int8_t *)m, sizeof *m);
	}
}

static const char *
pfkey_print_type(struct sadb_msg *msg)
{
	static char	uk[20];

	if (msg->sadb_msg_type < sizeof msgtypes / sizeof msgtypes[0])
		return msgtypes[msg->sadb_msg_type];
	else {
		snprintf(uk, sizeof uk, "<unknown(%d)>", msg->sadb_msg_type);
		return uk;
	}
}

static struct sadb_ext *
pfkey_find_ext(struct sadb_msg *msg, u_int16_t type)
{
	struct sadb_ext	*ext;
	u_int8_t	*e;

	for (e = (u_int8_t *)msg + sizeof *msg;
	     e < (u_int8_t *)msg + msg->sadb_msg_len * CHUNK;
	     e += ext->sadb_ext_len * CHUNK) {
		ext = (struct sadb_ext *)e;
		if (ext->sadb_ext_len == 0)
			break;
		if (ext->sadb_ext_type != type)
			continue;
		return ext;
	}
	return NULL;
}

/* Return: 0 means ok to sync msg, 1 means to skip it */
static int
pfkey_msg_filter(struct sadb_msg *msg)
{
	struct sockaddr		*src = 0, *dst = 0;
	struct syncpeer		*p;
	struct sadb_ext		*ext;
	u_int8_t		*max;

	switch (msg->sadb_msg_type) {
	case SADB_X_PROMISC:
	case SADB_DUMP:
	case SADB_GET:
	case SADB_GETSPI:
	case SADB_ACQUIRE:
	case SADB_X_ASKPOLICY:
	case SADB_REGISTER:
		/* Some messages should not be synced. */
		return 1;

	case SADB_ADD:
		/* No point in syncing LARVAL SAs */
		if (pfkey_find_ext(msg, SADB_EXT_KEY_ENCRYPT) == 0)
			return 1;
	case SADB_DELETE:
	case SADB_X_ADDFLOW:
	case SADB_X_DELFLOW:
	case SADB_EXPIRE:
		/* Continue below */
		break;
	case SADB_FLUSH:
		if ((cfgstate.flags & FM_MASK) == FM_NEVER)
			return 1;
		break;
	default:
		return 0;
	}

	if ((cfgstate.flags & SKIP_LOCAL_SAS) == 0)
		return 0;

	/* SRC or DST address of this msg must not be one of our peers. */
	ext = pfkey_find_ext(msg, SADB_EXT_ADDRESS_SRC);
	if (ext)
		src = (struct sockaddr *)((struct sadb_address *)ext + 1);
	ext = pfkey_find_ext(msg, SADB_EXT_ADDRESS_DST);
	if (ext)
		dst = (struct sockaddr *)((struct sadb_address *)ext + 1);
	if (!src && !dst)
		return 0;

	max = (u_int8_t *)msg + msg->sadb_msg_len * CHUNK;
	if (src && ((u_int8_t *)src + src->sa_len) > max)
		return 1;
	if (dst && ((u_int8_t *)dst + dst->sa_len) > max)
		return 1;

	/* Found SRC or DST, check it against our peers */
	for (p = LIST_FIRST(&cfgstate.peerlist); p; p = LIST_NEXT(p, link)) {
		if (p->socket < 0 || p->sa->sa_family !=
		    (src ? src->sa_family : dst->sa_family))
			continue;

		switch (p->sa->sa_family) {
		case AF_INET:
			if (src && memcmp(
			    &((struct sockaddr_in *)p->sa)->sin_addr.s_addr,
			    &((struct sockaddr_in *)src)->sin_addr.s_addr,
			    sizeof(struct in_addr)) == 0)
				return 1;
			if (dst && memcmp(
			    &((struct sockaddr_in *)p->sa)->sin_addr.s_addr,
			    &((struct sockaddr_in *)dst)->sin_addr.s_addr,
			    sizeof(struct in_addr)) == 0)
				return 1;
			break;
		case AF_INET6:
			if (src &&
			    memcmp(&((struct sockaddr_in6 *)p->sa)->sin6_addr,
			    &((struct sockaddr_in6 *)src)->sin6_addr,
			    sizeof(struct in_addr)) == 0)
				return 1;
			if (dst &&
			    memcmp(&((struct sockaddr_in6 *)p->sa)->sin6_addr,
			    &((struct sockaddr_in6 *)dst)->sin6_addr,
			    sizeof(struct in_addr)) == 0)
				return 1;
			break;
		}
	}
	return 0;
}

static int
pfkey_handle_message(struct sadb_msg *m)
{
	struct sadb_msg	*msg = m;

	/*
	 * Report errors, but ignore for DELETE (both isakmpd and kernel will
	 * expire the SA, if the kernel is first, DELETE returns failure).
	 */
	if (msg->sadb_msg_errno && msg->sadb_msg_type != SADB_DELETE &&
	    msg->sadb_msg_pid == (u_int32_t)getpid()) {
		errno = msg->sadb_msg_errno;
		log_msg(1, "pfkey error (%s)", pfkey_print_type(msg));
	}

	/* We only want promiscuous messages here, skip all others. */
	if (msg->sadb_msg_type != SADB_X_PROMISC ||
	    (msg->sadb_msg_len * CHUNK) < 2 * sizeof *msg) {
		free(m);
		return 0;
	}
	/* Move next msg to start of the buffer. */
	msg++;

	/*
	 * We should not listen to PFKEY messages when we are not running
	 * as MASTER, or the pid is our own.
	 */
	if (cfgstate.runstate != MASTER ||
	    msg->sadb_msg_pid == (u_int32_t)getpid()) {
		free(m);
		return 0;
	}

	if (pfkey_msg_filter(msg)) {
		free(m);
		return 0;
	}

	switch (msg->sadb_msg_type) {
	case SADB_UPDATE:
		/*
		 * Tweak -- the peers do not have a larval SA to update, so
		 * instead we ADD it here.
		 */
		msg->sadb_msg_type = SADB_ADD;
		/* FALLTHROUGH */

	default:
		/* Pass the rest along to our peers. */
		memmove(m, msg, msg->sadb_msg_len * CHUNK); /* for realloc */
		return net_queue(NULL, MSG_PFKEYDATA, (u_int8_t *)m,
		    m->sadb_msg_len * CHUNK);
	}

	return 0;
}

static int
pfkey_read(void)
{
	struct sadb_msg  hdr, *msg;
	u_int8_t	*data;
	ssize_t		 datalen;
	int		 fd = cfgstate.pfkey_socket;

	if (recv(fd, &hdr, sizeof hdr, MSG_PEEK) != sizeof hdr) {
		log_err("pfkey_read: recv() failed");
		return -1;
	}
	datalen = hdr.sadb_msg_len * CHUNK;
	data = reallocarray(NULL, hdr.sadb_msg_len, CHUNK);
	if (!data) {
		log_err("pfkey_read: malloc(%lu) failed", datalen);
		return -1;
	}
	msg = (struct sadb_msg *)data;

	if (read(fd, data, datalen) != datalen) {
		log_err("pfkey_read: read() failed, %lu bytes", datalen);
		free(data);
		return -1;
	}

	return pfkey_handle_message(msg);
}

int
pfkey_init(int reinit)
{
	int fd;

	fd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2);
	if (fd == -1) {
		perror("failed to open PF_KEY socket");
		return -1;
	}
	cfgstate.pfkey_socket = fd;

	if (cfgstate.runstate == MASTER)
		pfkey_set_promisc();

	if (reinit)
		return (fd > -1 ? 0 : -1);

	SIMPLEQ_INIT(&pfkey_msglist);
	return 0;
}

void
pfkey_set_rfd(fd_set *fds)
{
	if (cfgstate.pfkey_socket != -1)
		FD_SET(cfgstate.pfkey_socket, fds);
}

void
pfkey_set_pending_wfd(fd_set *fds)
{
	if (cfgstate.pfkey_socket != -1 && SIMPLEQ_FIRST(&pfkey_msglist))
		FD_SET(cfgstate.pfkey_socket, fds);
}

void
pfkey_read_message(fd_set *fds)
{
	if (cfgstate.pfkey_socket != -1)
		if (FD_ISSET(cfgstate.pfkey_socket, fds))
			(void)pfkey_read();
}

void
pfkey_send_message(fd_set *fds)
{
	struct pfkey_msg *pmsg = SIMPLEQ_FIRST(&pfkey_msglist);

	if (!pmsg || !FD_ISSET(cfgstate.pfkey_socket, fds))
		return;

	if (cfgstate.pfkey_socket == -1)
		if (pfkey_init(1)) /* Reinit socket */
			return;

	(void)pfkey_write(pmsg->buf, pmsg->len);

	SIMPLEQ_REMOVE_HEAD(&pfkey_msglist, next);
	free(pmsg->buf);
	free(pmsg);

	return;
}

int
pfkey_queue_message(u_int8_t *data, u_int32_t datalen)
{
	struct pfkey_msg	*pmsg;
	struct sadb_msg		*sadb = (struct sadb_msg *)data;
	static u_int32_t	 seq = 1;

	pmsg = malloc(sizeof *pmsg);
	if (!pmsg) {
		log_err("malloc()");
		return -1;
	}
	memset(pmsg, 0, sizeof *pmsg);

	pmsg->buf = data;
	pmsg->len = datalen;

	sadb->sadb_msg_pid = getpid();
	sadb->sadb_msg_seq = seq++;
	log_msg(2, "pfkey_queue_message: pfkey %s len %zu seq %u",
	    pfkey_print_type(sadb), sadb->sadb_msg_len * CHUNK,
	    sadb->sadb_msg_seq);

	SIMPLEQ_INSERT_TAIL(&pfkey_msglist, pmsg, next);
	return 0;
}

void
pfkey_shutdown(void)
{
	struct pfkey_msg *p = SIMPLEQ_FIRST(&pfkey_msglist);

	while ((p = SIMPLEQ_FIRST(&pfkey_msglist))) {
		SIMPLEQ_REMOVE_HEAD(&pfkey_msglist, next);
		free(p->buf);
		free(p);
	}

	if (cfgstate.pfkey_socket > -1)
		close(cfgstate.pfkey_socket);
}

/* ------------------------------------------------------------------------- */

void
pfkey_snapshot(void *v)
{
	struct syncpeer		*p = (struct syncpeer *)v;
	struct sadb_msg		*m;
	u_int8_t		*sadb, *spd, *max, *next, *sendbuf;
	u_int32_t		 sadbsz, spdsz;

	if (!p)
		return;

	if (monitor_get_pfkey_snap(&sadb, &sadbsz, &spd, &spdsz)) {
		log_msg(0, "pfkey_snapshot: failed to get pfkey snapshot");
		return;
	}

	/* XXX needs moving if snapshot is called more than once per peer */
	if ((cfgstate.flags & FM_MASK) == FM_STARTUP)
		pfkey_send_flush(p);

	/* Parse SADB data */
	if (sadbsz && sadb) {
		dump_buf(2, sadb, sadbsz, "pfkey_snapshot: SADB data");
		max = sadb + sadbsz;
		for (next = sadb; next < max;
		     next += m->sadb_msg_len * CHUNK) {
			m = (struct sadb_msg *)next;
			if (m->sadb_msg_len == 0)
				break;

			/* Tweak and send this SA to the peer. */
			m->sadb_msg_type = SADB_ADD;

			if (pfkey_msg_filter(m))
				continue;

			/* Allocate msgbuffer, net_queue() will free it. */
			sendbuf = calloc(m->sadb_msg_len, CHUNK);
			if (sendbuf) {
				memcpy(sendbuf, m, m->sadb_msg_len * CHUNK);
				net_queue(p, MSG_PFKEYDATA, sendbuf,
				    m->sadb_msg_len * CHUNK);
				log_msg(2, "pfkey_snapshot: sync SA %p len %zu "
				    "to peer %s", m,
				    m->sadb_msg_len * CHUNK, p->name);
			}
		}
		freezero(sadb, sadbsz);
	}

	/* Parse SPD data */
	if (spdsz && spd) {
		dump_buf(2, spd, spdsz, "pfkey_snapshot: SPD data");
		max = spd + spdsz;
		for (next = spd; next < max; next += m->sadb_msg_len * CHUNK) {
			m = (struct sadb_msg *)next;
			if (m->sadb_msg_len == 0)
				break;

			/* Tweak msg type. */
			m->sadb_msg_type = SADB_X_ADDFLOW;

			if (pfkey_msg_filter(m))
				continue;

			/* Allocate msgbuffer, freed by net_queue(). */
			sendbuf = calloc(m->sadb_msg_len, CHUNK);
			if (sendbuf) {
				memcpy(sendbuf, m, m->sadb_msg_len * CHUNK);
				net_queue(p, MSG_PFKEYDATA, sendbuf,
				    m->sadb_msg_len * CHUNK);
				log_msg(2, "pfkey_snapshot: sync FLOW %p len "
				    "%zu to peer %s", m,
				    m->sadb_msg_len * CHUNK, p->name);
			}
		}
		/* Cleanup. */
		freezero(spd, spdsz);
	}

	net_ctl_send_endsnap(p);
	return;
}
@


1.27
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.26 2016/07/18 21:22:09 benno Exp $	*/
d500 1
a500 2
		explicit_bzero(sadb, sadbsz);
		free(sadb);
d530 1
a530 2
		explicit_bzero(spd, spdsz);
		free(spd);
@


1.26
log
@add format attributes to log functions and fix some errors

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.25 2015/10/18 02:39:04 mmcc Exp $	*/
d35 1
@


1.25
log
@Use explicit_bzero() when the memory is freed directly afterward.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.24 2015/08/20 22:39:29 deraadt Exp $	*/
d427 1
a427 1
	log_msg(2, "pfkey_queue_message: pfkey %s len %u seq %u",
d494 1
a494 1
				log_msg(2, "pfkey_snapshot: sync SA %p len %u "
d525 1
a525 1
				    "%u to peer %s", m,
@


1.24
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.23 2015/01/16 06:40:20 deraadt Exp $	*/
d499 1
a499 1
		memset(sadb, 0, sadbsz);
d530 1
a530 1
		memset(spd, 0, spdsz);
@


1.23
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.22 2014/10/26 14:47:37 chl Exp $	*/
d113 1
a113 1
	struct sadb_msg *m = (struct sadb_msg *)calloc(1, sizeof *m);
d415 1
a415 1
	pmsg = (struct pfkey_msg *)malloc(sizeof *pmsg);
d489 1
a489 1
			sendbuf = (u_int8_t *)calloc(m->sadb_msg_len, CHUNK);
d519 1
a519 1
			sendbuf = (u_int8_t *)calloc(m->sadb_msg_len, CHUNK);
@


1.22
log
@fix use of uninitialized variable in error path

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.21 2014/10/16 04:05:39 deraadt Exp $	*/
a32 1
#include <sys/param.h>
@


1.21
log
@simple reallocarray()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.20 2010/06/29 18:10:04 kjell Exp $	*/
d327 1
a332 1
	datalen = hdr.sadb_msg_len * CHUNK;
@


1.20
log
@Having more than 2 log levels is silly. Use only 3 verbosity levels:
 None (), Important (-v), All (-vv)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.19 2007/09/02 15:19:40 deraadt Exp $	*/
d327 1
a327 2
	datalen = hdr.sadb_msg_len * CHUNK;
	data = (u_int8_t *)malloc(datalen);
d332 1
@


1.19
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.18 2006/09/01 01:13:25 mpf Exp $	*/
d126 1
a126 1
		log_msg(3, "pfkey_send_flush: sending FLUSH to peer %s",
d428 1
a428 1
	log_msg(3, "pfkey_queue_message: pfkey %s len %u seq %u",
d475 1
a475 1
		dump_buf(3, sadb, sadbsz, "pfkey_snapshot: SADB data");
d495 1
a495 1
				log_msg(3, "pfkey_snapshot: sync SA %p len %u "
d506 1
a506 1
		dump_buf(3, spd, spdsz, "pfkey_snapshot: SPD data");
d525 1
a525 1
				log_msg(3, "pfkey_snapshot: sync FLOW %p len "
@


1.18
log
@Teach sasyncd to set isakmpd into active or passive mode, according
to our current carp state.
Based on a diff by ho@@.
OK ho@@, hshoexer@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.17 2006/08/31 17:28:33 mpf Exp $	*/
d490 1
a490 1
			sendbuf = (u_int8_t *)malloc(m->sadb_msg_len * CHUNK);
d520 1
a520 1
			sendbuf = (u_int8_t *)malloc(m->sadb_msg_len * CHUNK);
@


1.17
log
@Add more SADB types to the filter: ACQUIRE, X_ASKPOLICY, REGISTER.
While there put the message sieve into the more appropriate filter function.
Pointed out by markus.
OK ho@@, markus@@, hshoexer@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.16 2006/08/30 18:26:33 henning Exp $	*/
d49 1
@


1.16
log
@need to retry writing to pfkey socket on EAGAIN, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.15 2006/06/02 20:31:48 moritz Exp $	*/
d173 10
a295 9
	case SADB_X_PROMISC:
	case SADB_DUMP:
	case SADB_GET:
	case SADB_GETSPI:
	/* case SADB_REGISTER: */
		/* Some messages should not be synced. */
		free(m);
		break;

@


1.15
log
@whitespace cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.14 2006/06/02 20:09:43 mcbride Exp $	*/
d75 1
d80 4
a83 1
	if (write(cfgstate.pfkey_socket, buf, len) != len) {
@


1.14
log
@Make sasyncd fail back correctly with carp preemption enabled.

Hold the carp demotion when booting, to prevent carp from preempting until
we've sync'd with our peers.  This adds a new CTL_ENDSNAP message to the
exchange between the sasync daemons to indicate when the complete snapshot
has been sent. Undemote after 60 seconds, or when recieve a CTL_ENDSNAP from
all our peers.

Syntax is slightly changed, removing the 'carp' keyword (so do
"interface carp0" rather than "carp interface carp0". Adds 'group <ifgroup>',
defaults to the 'carp' group.

ok moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.13 2006/02/15 05:09:29 david Exp $	*/
d51 1
a51 1
struct pfkey_msg 
d131 1
a131 1
	
d226 1
a226 1
			if (src && 
d231 1
a231 1
			if (dst && 
d457 1
a457 1
		
d509 1
a509 1
			
@


1.13
log
@remove "the the" in comment; ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.12 2006/01/26 09:53:46 moritz Exp $	*/
d399 1
d528 2
@


1.12
log
@fix some format strings and add a missing
argument to a log_err() call. ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.11 2005/05/28 01:07:52 ho Exp $	*/
d300 1
a300 1
		/* Pass the the rest along to our peers. */
@


1.11
log
@Optionally prevent syncing failover node-node SA/SPD info (master side).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.10 2005/05/27 18:05:27 ho Exp $	*/
d80 1
a80 1
		log_err("pfkey: msg %s write() failed",
d421 1
a421 1
	log_msg(3, "pfkey_queue_message: pfkey %s len %d seq %d",
@


1.10
log
@Implement SPD (IPsec flow) snapshots.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.9 2005/05/26 19:19:51 ho Exp $	*/
d140 102
d276 1
a276 2
	if (msg->sadb_msg_type == SADB_FLUSH &&
	    cfgstate.flushmode == FM_NEVER) {
d463 1
a463 1
	if (cfgstate.flushmode == FM_STARTUP)
d479 3
d509 3
@


1.9
log
@add a 'flushmode' to control how the master handles FLUSH to slaves. tweak some loglevels.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.8 2005/05/26 05:34:17 ho Exp $	*/
d64 1
a64 1
	"X_DELFLOW", "X_GRPSPIS", "X_ASKPOLICY"
d384 3
a386 2
				log_msg(3, "pfkey_snapshot: sync SA %p to"
				    "peer %s", m, p->name);
a394 2
#ifdef notyet	
		struct ipsec_policy	*ip;
d396 5
d402 13
a414 7
		max = spd + spdsz;
		for (next = spd; next < max;
		     next += sizeof(struct ipsec_policy)) {
			ip = (struct ipsec_policy *)next;
			if (ip->ipo_flags & IPSP_POLICY_SOCKET)
				continue;
			/* XXX incomplete */
a415 2
#endif

@


1.8
log
@disable SPD snapshot for now
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.7 2005/05/26 00:55:03 ho Exp $	*/
d49 1
d105 22
d174 6
d361 4
d367 1
a367 1
		dump_buf(5, sadb, sadbsz, "pfkey_snapshot: SADB data");
a377 2
			/* XXX Locate lifetime_cur ext and zero bytes */

d384 2
a391 1
#ifdef notyet	
d394 1
d396 1
a396 1
		dump_buf(5, spd, spdsz, "pfkey_snapshot: SPD data");
d406 1
a411 1
#endif
@


1.7
log
@Don't alloc/free zero-sized SADB/SPD buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.6 2005/05/24 03:15:11 ho Exp $	*/
a320 1
	struct ipsec_policy	*ip;
d358 2
a359 1
	
d362 1
d378 1
@


1.6
log
@Now that all "other" SADB_DUMP fields are zero, we don't have fix it here.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.5 2005/05/24 02:49:32 ho Exp $	*/
d334 1
a334 1
	if (sadbsz)
d336 19
a354 17

	max = sadb + sadbsz;
	for (next = sadb; next < max; next += m->sadb_msg_len * CHUNK) {
		m = (struct sadb_msg *)next;

		if (m->sadb_msg_len == 0)
			break;

		/* Tweak and send this SA to the peer. */
		m->sadb_msg_type = SADB_ADD;

		/* Allocate a buffer for the msg, net_queue() will free it. */
		sendbuf = (u_int8_t *)malloc(m->sadb_msg_len * CHUNK);
		if (sendbuf) {
			memcpy(sendbuf, m, m->sadb_msg_len * CHUNK);
			net_queue(p, MSG_PFKEYDATA, sendbuf,
			    m->sadb_msg_len * CHUNK);
d356 2
d359 1
a359 1

d361 1
a361 1
	if (spdsz)
d364 12
a375 6
	max = spd + spdsz;
	for (next = spd; next < max; next += sizeof(struct ipsec_policy)) {
		ip = (struct ipsec_policy *)next;

		if (ip->ipo_flags & IPSP_POLICY_SOCKET)
			continue;
a376 6

	/* Cleanup. */
	memset(sadb, 0, sadbsz);
	free(sadb);
	memset(spd, 0, spdsz);
	free(spd);
@


1.5
log
@Remove some debugging cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.4 2005/05/24 02:35:39 ho Exp $	*/
a345 2
		m->sadb_msg_errno = 0;
		m->sadb_msg_reserved = 0; /* XXX DUMP msg has data here. */
@


1.4
log
@When peers connect, have the master daemon look at in-kernel SAs and feed
these to the new peer. Adds privsep as fetching SADB and SPD kernel data
requires privileges.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.3 2005/05/23 19:53:27 ho Exp $	*/
a340 3
		fprintf(stderr, "pfkey_snapshot: SPD %p type %s len %u\n",
		    m, pfkey_print_type(m), m->sadb_msg_len * CHUNK);

d344 1
a344 1
		/* Tweak and send */
d347 1
a347 1
		m->sadb_msg_reserved = 0;
a365 3
		fprintf(stderr, "pfkey_snapshot: SPD %p (%d)\n",ip,
		    sizeof(struct ipsec_policy));

a374 1
	log_msg(0, "pfkey_snapshot: done");
@


1.3
log
@Various logging fixes, handle peer disconnects better.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.2 2005/05/22 20:35:48 ho Exp $	*/
d40 1
d68 1
a68 1
static const char *pfkey_print_type(struct sadb_msg *msg);
d107 2
d111 4
a114 2
	else
		return "<unknown>";
d126 2
a127 1
	if (msg->sadb_msg_errno && msg->sadb_msg_type != SADB_DELETE) {
d129 1
a129 1
		log_err("pfkey error (%s)", pfkey_print_type(msg));
a150 4
	log_msg(3, "pfkey_handle_message: got %s len %u seq %d",
	    pfkey_print_type(msg), msg->sadb_msg_len * CHUNK,
	    msg->sadb_msg_seq);

d156 1
d319 5
a323 14
	struct sadb_msg *m;
	struct sadb_ext *e;
	u_int8_t	*buf;
	size_t		 sz, mlen, elen;
	int		 mib[5];

	mib[0] = CTL_NET;
	mib[1] = PF_KEY;
	mib[2] = PF_KEY_V2;
	mib[3] = NET_KEY_SADB_DUMP;
	mib[4] = 0; /* Unspec SA type */

	if (timer_add("pfkey_snapshot", 60, pfkey_snapshot, NULL))
		log_err("pfkey_snapshot: failed to renew event");
d325 1
a325 2
	if (sysctl(mib, sizeof mib / sizeof mib[0], NULL, &sz, NULL, 0) == -1
	    || sz == 0)
d327 3
a329 6
	if ((buf = malloc(sz)) == NULL) {
		log_err("malloc");
		return;
	}
	if (sysctl(mib, sizeof mib / sizeof mib[0], buf, &sz, NULL, 0) == -1) {
		log_err("sysctl");
d333 25
a357 13
	m = (struct sadb_msg *)buf;
	while (m < (struct sadb_msg *)(buf + sz) && m->sadb_msg_len > 0) {
		mlen = m->sadb_msg_len * CHUNK;
		
		fprintf(stderr, "pfkey_snapshot: sadb_msg %p type %s len %u\n",
		    m, pfkey_print_type(m), mlen);

		e = (struct sadb_ext *)(m + 1);
		while ((u_int8_t *)e - (u_int8_t *)m < mlen && 
		    e->sadb_ext_len > 0) {
			elen = e->sadb_ext_len * CHUNK;
			fprintf(stderr, "ext %p len %u\n", e, elen);
			e = (struct sadb_ext *)((u_int8_t *)e + elen);
a358 2
		/* ... */
		m = (struct sadb_msg *)((u_int8_t *)m + mlen);
d360 22
a381 2
	memset(buf, 0, sz);
	free(buf);
@


1.2
log
@No more SSL between peers, instead do shared key AES & SHA
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.1 2005/03/30 18:44:49 ho Exp $	*/
d145 3
a147 2
	log_msg(3, "pfkey: got %s len %u seq %d", pfkey_print_type(msg),
	    msg->sadb_msg_len * CHUNK, msg->sadb_msg_seq);
d288 3
a290 2
	log_msg(3, "sync: pfkey %s len %d seq %d", pfkey_print_type(sadb),
	    sadb->sadb_msg_len * CHUNK, sadb->sadb_msg_seq);
d347 1
a347 1
		fprintf(stderr, "snapshot: sadb_msg %p type %s len %u\n",
@


1.1
log
@Move sasyncd(8), for IPsec SA synchronization, in-tree. Work in progress.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d115 1
a115 1
	struct sadb_msg *msg = m;
d128 1
a128 1
	    (msg->sadb_msg_len * CHUNK) <= 2 * sizeof *msg) {
d132 1
d166 4
a169 3
		/* The rest should just be passed along to our peers. */
		return net_queue(NULL, MSG_PFKEYDATA, (u_int8_t *)m, sizeof *m,
		    msg->sadb_msg_len * CHUNK);
d216 4
a219 3
	if (reinit) {
		if (cfgstate.runstate == MASTER)
			pfkey_set_promisc();
a220 1
	}
@

