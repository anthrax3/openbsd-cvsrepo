head	1.24;
access;
symbols
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.16
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.8
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.12
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.10
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.6
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.8
	OPENBSD_5_0:1.20.0.6
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9;
locks; strict;
comment	@ * @;


1.24
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	z3HrihslRYb4HqW9;

1.23
date	2012.04.14.12.11.08;	author haesbaert;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.14.11.50.33;	author haesbaert;	state Exp;
branches;
next	1.21;

1.21
date	2012.04.14.11.47.54;	author haesbaert;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.16.17.39.05;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.11.23.05.40;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.17.20.30.17;	author sobrado;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.26.04.36.57;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.26.00.58.11;	author msf;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.25.08.27.58;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.24.05.01.08;	author msf;	state Exp;
branches;
next	1.13;

1.13
date	2006.09.01.01.13.25;	author mpf;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.02.20.31.48;	author moritz;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.02.20.09.43;	author mcbride;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.01.22.43.12;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.26.19.18.16;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.24.02.35.39;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.22.20.35.48;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.22.12.14.16;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.03.05.44.35;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.03.12.24.59;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.03.12.03.43;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.30.18.56.19;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.30.18.44.49;	author ho;	state Exp;
branches;
next	;


desc
@@


1.24
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@/*	$OpenBSD: sasyncd.c,v 1.23 2012/04/14 12:11:08 haesbaert Exp $	*/

/*
 * Copyright (c) 2005 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Multicom Security AB.
 */


#include <sys/types.h>
#include <sys/time.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include "sasyncd.h"

volatile sig_atomic_t	daemon_shutdown = 0;

/* Called by signal handler for controlled daemon shutdown. */
static void
sasyncd_stop(int s)
{
	daemon_shutdown++;
}

static int
sasyncd_run(pid_t ppid)
{
	struct timeval	*timeout, tv;
	fd_set		*rfds, *wfds;
	size_t		 fdsetsize;
	int		 maxfd, n;

	n = getdtablesize();
	fdsetsize = howmany(n, NFDBITS) * sizeof(fd_mask);

	rfds = malloc(fdsetsize);
	if (!rfds) {
		log_err("malloc(%lu) failed", (unsigned long)fdsetsize);
		return -1;
	}

	wfds = malloc(fdsetsize);
	if (!wfds) {
		log_err("malloc(%lu) failed", (unsigned long)fdsetsize);
		free(rfds);
		return -1;
	}

	control_setrun();

	signal(SIGINT, sasyncd_stop);
	signal(SIGTERM, sasyncd_stop);

	timer_add("carp_undemote", CARP_DEMOTE_MAXTIME,
	    monitor_carpundemote, NULL);

	while (!daemon_shutdown) {
		memset(rfds, 0, fdsetsize);
		memset(wfds, 0, fdsetsize);
		maxfd = net_set_rfds(rfds);
		n = net_set_pending_wfds(wfds);
		if (n > maxfd)
			maxfd = n;

		pfkey_set_rfd(rfds);
		pfkey_set_pending_wfd(wfds);
		if (cfgstate.pfkey_socket + 1 > maxfd)
			maxfd = cfgstate.pfkey_socket + 1;

		carp_set_rfd(rfds);
		if (cfgstate.route_socket + 1 > maxfd)
			maxfd = cfgstate.route_socket + 1;

		timeout = &tv;
		timer_next_event(&tv);

		n = select(maxfd, rfds, wfds, 0, timeout);
		if (n == -1) {
			if (errno != EINTR) {
				log_err("select()");
				sleep(1);
			}
		} else if (n) {
			net_handle_messages(rfds);
			net_send_messages(wfds);
			pfkey_read_message(rfds);
			pfkey_send_message(wfds);
			carp_read_message(rfds);
		}
		timer_run();

		/* Mostly for debugging. */
		if (getppid() != ppid) {
			log_msg(0, "sasyncd: parent died");
			daemon_shutdown++;
		}
	}
	free(rfds);
	free(wfds);
	return 0;
}

__dead static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dv] [-c config-file]\n", __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	extern char	*__progname;
	char		*cfgfile = 0;
	int		 ch;

	if (geteuid() != 0) {
		/* No point in continuing. */
		fprintf(stderr, "%s: This daemon needs to be run as root.\n",
		    __progname);
		return 1;
	}

	while ((ch = getopt(argc, argv, "c:dv")) != -1) {
		switch (ch) {
		case 'c':
			if (cfgfile)
				usage();
			cfgfile = optarg;
			break;
		case 'd':
			cfgstate.debug++;
			break;
		case 'v':
			cfgstate.verboselevel++;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc > 0)
		usage();

	log_init(__progname);
	timer_init();

	cfgstate.runstate = INIT;
	LIST_INIT(&cfgstate.peerlist);

	cfgstate.listen_port = SASYNCD_DEFAULT_PORT;
	cfgstate.flags |= CTL_DEFAULT;

	if (!cfgfile)
		cfgfile = SASYNCD_CFGFILE;

	if (conf_parse_file(cfgfile) == 0 ) {
		if (!cfgstate.sharedkey) {
			fprintf(stderr, "config: "
			    "no shared key specified, cannot continue");
			exit(1);
		}
	} else {
		exit(1);
	}

	carp_demote(CARP_INC, 0);

	if (carp_init())
		return 1;
	if (pfkey_init(0))
		return 1;
	if (net_init())
		return 1;

	if (!cfgstate.debug)
		if (daemon(1, 0)) {
			perror("daemon()");
			exit(1);
		}

	if (monitor_init()) {
		/* Parent, with privileges. */
		monitor_loop();
		exit(0);
	}

	/* Child, no privileges left. Run main loop. */
	sasyncd_run(getppid());

	/* Shutdown. */
	log_msg(0, "shutting down...");

	net_shutdown();
	pfkey_shutdown();
	return 0;
}
@


1.23
log
@Kill Boehms GC dead.

ok mikeb@@
sure deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.22 2012/04/14 11:50:33 haesbaert Exp $	*/
d66 1
a66 1
	rfds = (fd_set *)malloc(fdsetsize);
d72 1
a72 1
	wfds = (fd_set *)malloc(fdsetsize);
@


1.22
log
@Kill useless memset.

ok mikeb@@
"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.21 2012/04/14 11:47:54 haesbaert Exp $	*/
a231 11

/* Special for compiling with Boehms GC. See Makefile and sasyncd.h  */
#if defined (GC_DEBUG)
char *
gc_strdup(const char *x)
{
        char *strcpy(char *,const char *);
        char *y = malloc(strlen(x) + 1);
        return strcpy(y,x);
}
#endif
@


1.21
log
@Don't return from main with 2 uppon issuing double -c option, print
proper usage() message.

ok mikeb@@
"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.20 2010/06/16 17:39:05 reyk Exp $	*/
a154 2

	memset(&cfgstate, 0, sizeof cfgstate);
@


1.20
log
@Add support to use sasyncd(8) with iked(8) instead of isakmpd(8).  The
new config option "control isakmpd|iked|all|none" in sasyncd.conf(5)
is used to set the mode; the default is to control isakmpd like
before.  When controlling iked, sasyncd connects to the daemon using
the imsg socket and sends imsgs - this is easy because the imsg
framework has been imported into libutil. iked(8) already includes
the important bits to work with sasyncd(8) (the active/passive mode
option in ikectl).

manpage bits ok jsg@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.19 2009/11/11 23:05:40 deraadt Exp $	*/
d162 1
a162 1
				return 2;
@


1.19
log
@memory leak found by parfait
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.18 2008/03/17 20:30:17 sobrado Exp $	*/
d79 1
a79 1
	isakmpd_setrun();
d188 1
@


1.18
log
@sync the synopsis and usage; "usage:" is lowercase

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.17 2007/02/26 04:36:57 ray Exp $	*/
d75 1
@


1.17
log
@Zero out struct before using, not after.

From <sthen at symphytum dot spacehopper dot org>, PR 5388.

OK hshoexer@@ and mpf@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.16 2006/12/26 00:58:11 msf Exp $	*/
d137 1
a137 2
	fprintf(stderr, "Usage: %s [-c config-file] [-d] [-v[v]]\n",
	    __progname);
@


1.16
log
@make option processing happen first.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.15 2006/12/25 08:27:58 deraadt Exp $	*/
d156 2
a183 1
	memset(&cfgstate, 0, sizeof cfgstate);
@


1.15
log
@good day to remove a some poo
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.14 2006/12/24 05:01:08 msf Exp $	*/
a155 9
	log_init(__progname);
	timer_init();

	memset(&cfgstate, 0, sizeof cfgstate);
	cfgstate.runstate = INIT;
	LIST_INIT(&cfgstate.peerlist);

	cfgstate.listen_port = SASYNCD_DEFAULT_PORT;

d178 9
@


1.14
log
@first pass cleanup of sasyncd, based on some discussion with deraadt@@

inline conf_init into main() and remove it from conf.y.  add usage().
small amount of whitespace nits in sasync.h

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.13 2006/09/01 01:13:25 mpf Exp $	*/
a81 1
	signal(SIGHUP, sasyncd_stop);
d147 1
a147 1
	int	 	 ch, r;
d151 2
a152 1
		fprintf(stderr, "This daemon needs to be run as root.\n");
a154 9

	/* Init. */
	closefrom(STDERR_FILENO + 1);
	for (r = 0; r <= 2; r++)
		if (fcntl(r, F_GETFL, 0) == -1 && errno == EBADF)
			(void)open("/dev/null", r ? O_WRONLY : O_RDONLY, 0);

	for (r = 1; r < _NSIG; r++)
		signal(r, SIG_DFL);
@


1.13
log
@Teach sasyncd to set isakmpd into active or passive mode, according
to our current carp state.
Based on a diff by ho@@.
OK ho@@, hshoexer@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.12 2006/06/02 20:31:48 moritz Exp $	*/
d133 10
d147 2
a148 1
	int		r;
d168 40
a207 6
	r = conf_init(argc, argv);
	if (r > 1) {
		fprintf(stderr, "Usage: %s [-c config-file] [-d] [-v[v]]\n",
		    __progname);
		fprintf(stderr, "Default configuration file is %s\n",
		    SASYNCD_CFGFILE);
a208 2
	if (r)
		return 1;
@


1.12
log
@whitespace cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.11 2006/06/02 20:09:43 mcbride Exp $	*/
d77 2
@


1.11
log
@Make sasyncd fail back correctly with carp preemption enabled.

Hold the carp demotion when booting, to prevent carp from preempting until
we've sync'd with our peers.  This adds a new CTL_ENDSNAP message to the
exchange between the sasync daemons to indicate when the complete snapshot
has been sent. Undemote after 60 seconds, or when recieve a CTL_ENDSNAP from
all our peers.

Syntax is slightly changed, removing the 'carp' keyword (so do
"interface carp0" rather than "carp interface carp0". Adds 'group <ifgroup>',
defaults to the 'carp' group.

ok moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.10 2006/06/01 22:43:12 mcbride Exp $	*/
d104 1
a104 1
 
@


1.10
log
@Instead of polling the carp interface to detect a switch between MASTER and
BACKUP, listen to the routing socket for link change messages.

Based on a diff from nathanael at polymorpheous dot com.

ok moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.9 2005/05/26 19:18:16 ho Exp $	*/
d82 3
d104 1
a104 1

d164 2
@


1.9
log
@check ppid
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.8 2005/05/24 02:35:39 ho Exp $	*/
d95 4
d113 1
@


1.8
log
@When peers connect, have the master daemon look at in-kernel SAs and feed
these to the new peer. Adds privsep as fetching SADB and SPD kernel data
requires privileges.
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.7 2005/05/22 20:35:48 ho Exp $	*/
d56 1
a56 1
sasyncd_run(void)
d111 6
d177 1
a177 1
	sasyncd_run();
@


1.7
log
@No more SSL between peers, instead do shared key AES & SHA
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.6 2005/05/22 12:14:16 ho Exp $	*/
d46 1
a46 26
static void
privdrop(void)
{
	struct passwd	*pw = getpwnam(SASYNCD_USER);
	extern char	*__progname;

	if (!pw) {
		log_err("%s: getpwnam(\"%s\") failed", __progname,
		    SASYNCD_USER);
		exit(1);
	}

	if (chroot(pw->pw_dir) != 0 || chdir("/") != 0) {
		log_err("%s: chroot failed", __progname);
		exit(1);
	}

	if (setgroups(1, &pw->pw_gid) || 
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid)) {
		log_err("%s: failed to drop privileges", __progname);
		exit(1);
	}
}

volatile int daemon_shutdown = 0;
a157 3
	/* Drop privileges. */
	privdrop();

d164 7
a170 1
	/* Main loop. */
@


1.6
log
@style nits
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.5 2005/05/03 05:44:35 djm Exp $	*/
d148 6
a174 6

	if (geteuid() != 0) {
		/* No point in continuing. */
		fprintf(stderr, "This daemon needs to be run as root.\n");
		return 1;
	}
@


1.5
log
@setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.4 2005/04/03 12:24:59 ho Exp $	*/
d50 1
d145 2
a146 1
	int	r;
@


1.4
log
@Cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.3 2005/04/03 12:03:43 ho Exp $	*/
d62 3
a64 2
	if (setgroups(1, &pw->pw_gid) || setegid(pw->pw_gid) ||
	    setgid(pw->pw_gid) || seteuid(pw->pw_uid) || setuid(pw->pw_uid)) {
@


1.3
log
@Remove debugging code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.2 2005/03/30 18:56:19 ho Exp $	*/
d46 1
a46 1
static int
a66 2

	return 0;
d166 6
@


1.2
log
@Fix some stuff noted by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.1 2005/03/30 18:44:49 ho Exp $	*/
a157 3

	pfkey_snapshot(0);
	exit(1);
@


1.1
log
@Move sasyncd(8), for IPsec SA synchronization, in-tree. Work in progress.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
		return -1;
d59 1
a59 1
		return -1;
d65 1
a65 1
		return -1;
@

