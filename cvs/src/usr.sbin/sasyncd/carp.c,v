head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.2
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.16
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.8
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.12
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.10
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.6
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.4
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.8
	OPENBSD_5_0:1.12.0.6
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.8.0.10
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.8
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.6
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.4
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2017.08.31.16.19.22;	author otto;	state Exp;
branches;
next	1.15;
commitid	Z6IMh4MsFWDiZ9lt;

1.15
date	2016.08.27.04.21.08;	author guenther;	state Exp;
branches;
next	1.14;
commitid	5Bg26nDF24JkfeXC;

1.14
date	2015.11.12.09.27.09;	author otto;	state Exp;
branches;
next	1.13;
commitid	SYWXxLmOZYegeq74;

1.13
date	2012.04.14.11.46.09;	author haesbaert;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.29.21.25.37;	author kjell;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.16.17.39.05;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.26.13.25.23;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.25.18.50.22;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.16.11.35.18;	author mpf;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.01.01.13.25;	author mpf;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.02.20.31.48;	author moritz;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.02.20.09.43;	author mcbride;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.01.22.43.12;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.26.09.53.46;	author moritz;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.30.18.44.49;	author ho;	state Exp;
branches;
next	;


desc
@@


1.16
log
@enum can be signed or unsigned depending on the compiler; so make sure we
cast to unsigned and test for > X to avoid warnings that comparing an
unsigned < 0 make no sense; ok deraadt@@
@
text
@/*	$OpenBSD: carp.c,v 1.15 2016/08/27 04:21:08 guenther Exp $	*/

/*
 * Copyright (c) 2005 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Multicom Security AB.
 */


#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <net/if.h>
#include <net/route.h>

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "monitor.h"
#include "sasyncd.h"

int carp_demoted = 0;

/* Map CARP interface link state into RUNSTATE enum */
static enum RUNSTATE
carp_map_state(u_char link_state)
{
	enum RUNSTATE state = FAIL;

	switch(link_state) {
	case LINK_STATE_UP:
	case LINK_STATE_HALF_DUPLEX:
	case LINK_STATE_FULL_DUPLEX:
		state = MASTER;
		break;
	case LINK_STATE_DOWN:
		state = SLAVE;
		break;
	case LINK_STATE_UNKNOWN:
	case LINK_STATE_INVALID:
		state = INIT;
		break;
	}

	return state;
}

static enum RUNSTATE
carp_get_state(char *ifname)
{
	struct ifreq	ifr;
	struct if_data	ifrdat;
	int		s, saved_errno;

	if (!ifname || !*ifname) {
		errno = ENOENT;
		return FAIL;
	}

	memset(&ifr, 0, sizeof ifr);
	strlcpy(ifr.ifr_name, ifname, sizeof ifr.ifr_name);

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s < 0)
		return FAIL;

	ifr.ifr_data = (caddr_t)&ifrdat;
	if (ioctl(s, SIOCGIFDATA, (caddr_t)&ifr) == -1) {
		saved_errno = errno;
		close(s);
		errno = saved_errno;
		return FAIL;
	}
	close(s);
	return carp_map_state(ifrdat.ifi_link_state);
}

void
carp_demote(int demote, int force)
{
	struct ifgroupreq        ifgr;
	int s;

	if (carp_demoted + demote < 0) {
		log_msg(1, "carp_demote: mismatched promotion");
		return;
	}

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s < 0) {
		log_msg(1, "carp_demote: couldn't open socket");
		return;
	}

	bzero(&ifgr, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, cfgstate.carp_ifgroup, sizeof(ifgr.ifgr_name));

	/* Unless we force it, don't demote if we're not demoting already. */
	if (!force) {
		if (ioctl(s, SIOCGIFGATTR, (caddr_t)&ifgr) == -1) {
			log_msg(1, "carp_demote: unable to get "
			    "the demote state of group '%s'",
			    cfgstate.carp_ifgroup);
			    goto done;
		}

		if (ifgr.ifgr_attrib.ifg_carp_demoted == 0)
			goto done;
	}

	ifgr.ifgr_attrib.ifg_carp_demoted = demote;
	if (ioctl(s, SIOCSIFGATTR, (caddr_t)&ifgr) == -1)
		log_msg(1, "carp_demote: unable to %s the demote state "
		    "of group '%s'", (demote > 0) ?
		    "increment" : "decrement", cfgstate.carp_ifgroup);
	else {
		carp_demoted += demote;
		log_msg(1, "carp_demote: %sed the demote state "
		    "of group '%s'", (demote > 0) ?
		    "increment" : "decrement", cfgstate.carp_ifgroup);
	}
done:
	close(s);
}

const char*
carp_state_name(enum RUNSTATE state)
{
	static const char	*carpstate[] = CARPSTATES;

	if ((unsigned)state > FAIL)
		state = FAIL;
	return carpstate[state];
}

void
carp_update_state(enum RUNSTATE current_state)
{

	if ((unsigned)current_state > FAIL) {
		log_err("carp_update_state: invalid carp state, abort");
		cfgstate.runstate = FAIL;
		return;
	}

	if (current_state != cfgstate.runstate) {
		log_msg(1, "carp_update_state: switching state to %s",
		    carp_state_name(current_state));
		cfgstate.runstate = current_state;
		if (current_state == MASTER)
			pfkey_set_promisc();
		control_setrun();
		net_ctl_update_state();
	}
}

void
carp_check_state()
{
	carp_update_state(carp_get_state(cfgstate.carp_ifname));
}

void
carp_set_rfd(fd_set *fds)
{
	if (cfgstate.route_socket != -1)
		FD_SET(cfgstate.route_socket, fds);
}

static void
carp_read(void)
{
	char msg[2048];
	struct rt_msghdr *rtm = (struct rt_msghdr *)&msg;
	struct if_msghdr ifm;
	ssize_t len;

	len = read(cfgstate.route_socket, msg, sizeof(msg));

	if (len < (ssize_t)sizeof(struct rt_msghdr) ||
	    rtm->rtm_version != RTM_VERSION ||
	    rtm->rtm_type != RTM_IFINFO)
		return;

	memcpy(&ifm, rtm, sizeof(ifm));

	if (ifm.ifm_index == cfgstate.carp_ifindex)
		carp_update_state(carp_map_state(ifm.ifm_data.ifi_link_state));
}

void
carp_read_message(fd_set *fds)
{
	if (cfgstate.route_socket != -1)
		if (FD_ISSET(cfgstate.route_socket, fds))
			(void)carp_read();
}

/* Initialize the CARP state. */
int
carp_init(void)
{
	unsigned int rtfilter;

	cfgstate.route_socket = -1;
	if (cfgstate.lockedstate != INIT) {
		cfgstate.runstate = cfgstate.lockedstate;
		log_msg(1, "carp_init: locking runstate to %s",
		    carp_state_name(cfgstate.runstate));
		return 0;
	}

	if (!cfgstate.carp_ifname || !*cfgstate.carp_ifname) {
		fprintf(stderr, "No carp interface\n");
		return -1;
	}

	cfgstate.carp_ifindex = if_nametoindex(cfgstate.carp_ifname);
	if (!cfgstate.carp_ifindex) {
		fprintf(stderr, "No carp interface index\n");
		return -1;
	}

	cfgstate.route_socket = socket(PF_ROUTE, SOCK_RAW, 0);
	if (cfgstate.route_socket < 0) {
		fprintf(stderr, "No routing socket\n");
		return -1;
	}

	rtfilter = ROUTE_FILTER(RTM_IFINFO);
	if (setsockopt(cfgstate.route_socket, PF_ROUTE, ROUTE_MSGFILTER,
	    &rtfilter, sizeof(rtfilter)) == -1)         /* not fatal */
		log_msg(2, "carp_init: setsockopt");

	cfgstate.runstate = carp_get_state(cfgstate.carp_ifname);
	if (cfgstate.runstate == FAIL) {
		fprintf(stderr, "Failed to check interface \"%s\".\n",
		    cfgstate.carp_ifname);
		fprintf(stderr, "Correct or manually select runstate.\n");
		return -1;
	}
	log_msg(1, "carp_init: initializing runstate to %s",
	    carp_state_name(cfgstate.runstate));

	return 0;
}

/* Enable or disable isakmpd/iked connection checker. */
void
control_setrun(void)
{
	if (cfgstate.runstate == MASTER) {
		if (monitor_control_active(1))
			log_msg(0, "failed to activate controlled daemon");
	} else {
		if (monitor_control_active(0))
			log_msg(0, "failed to passivate controlled daemon");
	}
}
@


1.15
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.14 2015/11/12 09:27:09 otto Exp $	*/
d157 1
a157 1
	if (state < 0 || state > FAIL)
d166 1
a166 1
	if (current_state < 0 || current_state > FAIL) {
@


1.14
log
@an invalid carp link state is not a fatal error, since a while newly created
carp interfaces have this state for a while. ok mpi@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.13 2012/04/14 11:46:09 haesbaert Exp $	*/
d35 1
@


1.13
log
@Add CDIAGFLAGS infrastructure.
Fix signed vs unsigned and dup symbol shadow.

ok mikeb@@
"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.12 2010/06/29 21:25:37 kjell Exp $	*/
d65 1
@


1.12
log
@Fix an obviously wrong comment. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.11 2010/06/16 17:39:05 reyk Exp $	*/
d200 1
a200 1
	int len;
d204 1
a204 1
	if (len < sizeof(struct rt_msghdr) ||
@


1.11
log
@Add support to use sasyncd(8) with iked(8) instead of isakmpd(8).  The
new config option "control isakmpd|iked|all|none" in sasyncd.conf(5)
is used to set the mode; the default is to control isakmpd like
before.  When controlling iked, sasyncd connects to the daemon using
the imsg socket and sends imsgs - this is easy because the imsg
framework has been imported into libutil. iked(8) already includes
the important bits to work with sasyncd(8) (the active/passive mode
option in ikectl).

manpage bits ok jsg@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.10 2009/06/26 13:25:23 deraadt Exp $	*/
d49 1
a71 1
/* Returns 1 for the CARP MASTER, 0 for BACKUP/INIT, -1 on error.  */
@


1.10
log
@use standard safe C
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.9 2009/06/25 18:50:22 sthen Exp $	*/
d176 1
a176 1
		isakmpd_setrun();
d272 1
a272 1
/* Enable or disable isakmpd connection checker. */
d274 1
a274 1
isakmpd_setrun(void)
d277 2
a278 2
		if (monitor_isakmpd_active(1))
			log_msg(0, "failed to activate isakmpd");
d280 2
a281 2
		if (monitor_isakmpd_active(0))
			log_msg(0, "failed to passivate isakmpd");
@


1.9
log
@sasyncd isn't interested in messages on the routing socket other than
RTM_IFINFO to monitor the state of carp(4) interfaces; programme the
filter on the socket accordingly so it doesn't have to handle other
message types.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.8 2006/11/28 19:21:15 reyk Exp $	*/
a226 1
	cfgstate.route_socket = -1;
d229 1
@


1.8
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.7 2006/09/16 11:35:18 mpf Exp $	*/
d228 1
d253 5
@


1.7
log
@Only interpret link state routing messages for the monitored carp interface.
memcpy the if_msghdr to avoid alignment problems.
OK hshoexer@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.6 2006/09/01 01:13:25 mpf Exp $	*/
d56 2
@


1.6
log
@Teach sasyncd to set isakmpd into active or passive mode, according
to our current carp state.
Based on a diff by ho@@.
OK ho@@, hshoexer@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.5 2006/06/02 20:31:48 moritz Exp $	*/
d196 2
a197 1
	struct if_msghdr *ifm = (struct if_msghdr *)&msg;
d202 9
a210 4
	if (len >= sizeof(struct if_msghdr) &&
	    ifm->ifm_version == RTM_VERSION &&
	    ifm->ifm_type == RTM_IFINFO)
		carp_update_state(carp_map_state(ifm->ifm_data.ifi_link_state));
@


1.5
log
@whitespace cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.4 2006/06/02 20:09:43 mcbride Exp $	*/
d44 1
d174 1
d256 13
@


1.4
log
@Make sasyncd fail back correctly with carp preemption enabled.

Hold the carp demotion when booting, to prevent carp from preempting until
we've sync'd with our peers.  This adds a new CTL_ENDSNAP message to the
exchange between the sasync daemons to indicate when the complete snapshot
has been sent. Undemote after 60 seconds, or when recieve a CTL_ENDSNAP from
all our peers.

Syntax is slightly changed, removing the 'carp' keyword (so do
"interface carp0" rather than "carp interface carp0". Adds 'group <ifgroup>',
defaults to the 'carp' group.

ok moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.3 2006/06/01 22:43:12 mcbride Exp $	*/
d115 1
a115 1
		
d123 2
a124 2
			    "the demote state of group '%s'", 
			    cfgstate.carp_ifgroup);		
d127 1
a127 1
	
d251 1
a251 1
	    carp_state_name(cfgstate.runstate));	
@


1.3
log
@Instead of polling the carp interface to detect a switch between MASTER and
BACKUP, listen to the routing socket for link change messages.

Based on a diff from nathanael at polymorpheous dot com.

ok moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.2 2006/01/26 09:53:46 moritz Exp $	*/
d46 2
d97 48
@


1.2
log
@fix some format strings and add a missing
argument to a log_err() call. ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: carp.c,v 1.1 2005/03/30 18:44:49 ho Exp $	*/
d37 1
a37 1
#include <netinet/ip_carp.h>
d46 19
a64 4
/* For some reason, ip_carp.h does not define this.  */
#define CARP_INIT	0
#define CARP_BACKUP	1
#define CARP_MASTER	2
d71 1
a71 1
	struct carpreq	carp;
a72 1
	char		*state;
d86 2
a87 2
	ifr.ifr_data = (caddr_t)&carp;
	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1) {
d94 2
d97 4
a100 12
	switch (carp.carpr_state) {
	case CARP_INIT:
		state = "INIT";
		break;

	case CARP_BACKUP:
		state = "BACKUP";
		break;

	case CARP_MASTER:
		state = "MASTER";
		break;
d102 3
a104 12
	default:
		state = "<unknown>";
		break;
	}

	log_msg(4, "carp_get_state: %s vhid %d state %s(%d)", ifname,
	    carp.carpr_vhid, state, carp.carpr_state);

	if (carp.carpr_vhid > 0)
		return carp.carpr_state == CARP_MASTER ? MASTER : SLAVE;
	else
		return FAIL;
d108 1
a108 1
carp_check_state(void)
a109 2
	enum RUNSTATE	current_state = carp_get_state(cfgstate.carp_ifname);
	static char	*carpstate[] = CARPSTATES;
d112 1
a112 2
		log_err("carp_state_tracker: invalid result on interface "
		    "%s, abort", cfgstate.carp_ifname);
d118 2
a119 2
		log_msg(1, "carp_state_tracker: switching state to %s",
		    carpstate[current_state]);
d127 2
a128 2
static void
carp_state_tracker(void *v_arg)
d130 2
a131 2
	static int	failures = 0;
	u_int32_t	next_check;
d133 6
a138 1
	carp_check_state();
d140 14
a153 3
	if (cfgstate.runstate == FAIL)
		if (++failures < 3)
			log_err("carp_state_tracker");
d155 6
a160 9
	if (failures > 5)
		next_check = 600;
	else
		next_check = cfgstate.carp_check_interval + failures * 10;

	if (timer_add("carp_state_tracker", next_check, carp_state_tracker,
	    NULL))
		log_msg(0, "carp_state_tracker: failed to renew event");
	return;
d163 1
a163 1
/* Initialize the CARP state tracker. */
d167 1
a167 1
	enum RUNSTATE initial_state;
d172 1
a172 1
		    cfgstate.runstate == MASTER ? "MASTER" : "SLAVE");
d176 19
a194 2
	initial_state = carp_get_state(cfgstate.carp_ifname);
	if (initial_state == FAIL) {
d200 2
d203 1
a203 1
	return timer_add("carp_state_tracker", 0, carp_state_tracker, NULL);
@


1.1
log
@Move sasyncd(8), for IPsec SA synchronization, in-tree. Work in progress.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 1
a99 1
	log_msg(4, "carp_get_state: %s vhid %u state %s(%d)", ifname,
@

