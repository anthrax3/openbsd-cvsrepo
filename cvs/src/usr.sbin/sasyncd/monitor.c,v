head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.6
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.8
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.8
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.12.0.12
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.14
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.10
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.8
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6;
locks; strict;
comment	@ * @;


1.21
date	2015.10.18.02.39.04;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	V1CXM3C8XhqLUe7U;

1.20
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	z3HrihslRYb4HqW9;

1.19
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	Uu5nFG3wCl0LACBb;

1.18
date	2014.06.29.00.58.45;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	JPNyzoRAXfnuJx1K;

1.17
date	2012.09.12.07.45.19;	author haesbaert;	state Exp;
branches;
next	1.16;

1.16
date	2012.09.04.14.41.25;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2012.04.02.18.56.15;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.29.18.10.04;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.16.17.39.05;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.25.08.17.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.09.01.01.13.25;	author mpf;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.31.12.55.02;	author mpf;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.02.20.31.48;	author moritz;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.02.20.09.43;	author mcbride;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.26.09.53.46;	author moritz;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.19.17.46.12;	author moritz;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.07.19.29.24;	author moritz;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.26.19.19.51;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.26.05.33.48;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.26.00.55.03;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.24.02.35.39;	author ho;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Use explicit_bzero() when the memory is freed directly afterward.

ok deraadt@@
@
text
@/*	$OpenBSD: monitor.c,v 1.20 2015/08/20 22:39:29 deraadt Exp $	*/

/*
 * Copyright (c) 2005 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/queue.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <net/pfkeyv2.h>

#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <signal.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <imsg.h>

#include "types.h"	/* iked imsg types */

#include "monitor.h"
#include "sasyncd.h"

struct m_state {
	pid_t	pid;
	int	s;
} m_state;

volatile sig_atomic_t		sigchld = 0;

static void	got_sigchld(int);
static void	sig_to_child(int);
static void	m_priv_pfkey_snap(int);
static int	m_priv_control_activate(void);
static int	m_priv_control_passivate(void);
static ssize_t	m_write(int, void *, size_t);
static ssize_t	m_read(int, void *, size_t);

pid_t
monitor_init(void)
{
	struct passwd	*pw = getpwnam(SASYNCD_USER);
	extern char	*__progname;
	char		root[PATH_MAX];
	int		p[2];

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, p) != 0) {
		log_err("%s: socketpair failed - %s", __progname,
		    strerror(errno));
		exit(1);
	}

	if (!pw) {
		log_err("%s: getpwnam(\"%s\") failed", __progname,
		    SASYNCD_USER);
		exit(1);
	}
	strlcpy(root, pw->pw_dir, sizeof root);
	endpwent();

	signal(SIGCHLD, got_sigchld);
	signal(SIGTERM, sig_to_child);
	signal(SIGHUP, sig_to_child);
	signal(SIGINT, sig_to_child);

	m_state.pid = fork();

	if (m_state.pid == -1) {
		log_err("%s: fork failed - %s", __progname, strerror(errno));
		exit(1);
	} else if (m_state.pid == 0) {
		/* Child */
		m_state.s = p[0];
		close(p[1]);

		if (chroot(pw->pw_dir) != 0 || chdir("/") != 0) {
			log_err("%s: chroot failed", __progname);
			exit(1);
		}

		if (setgroups(1, &pw->pw_gid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid)) {
			log_err("%s: failed to drop privileges", __progname);
			exit(1);
		}
	} else {
		/* Parent */
		setproctitle("[priv]");
		m_state.s = p[1];
		close(p[0]);
	}
	return m_state.pid;
}

static void
got_sigchld(int s)
{
	sigchld = 1;
}

static void
sig_to_child(int s)
{
	if (m_state.pid != -1)
		kill(m_state.pid, s);
}

static void
monitor_drain_input(void)
{
	int		one = 1;
	u_int8_t	tmp;

	ioctl(m_state.s, FIONBIO, &one);
	while (m_read(m_state.s, &tmp, 1) > 0)
		;
	ioctl(m_state.s, FIONBIO, 0);
}

/* We only use privsep to get in-kernel SADB and SPD snapshots via sysctl */
void
monitor_loop(void)
{
	u_int32_t	 v, vn;
	ssize_t		 r;
	fd_set		 rfds;
	int		 ret;
	struct timeval	*tvp, tv;

	FD_ZERO(&rfds);
	tvp = NULL;
	vn = 0;

	for (;;) {
		ret = 0;
		v = 0;

		if (sigchld) {
			pid_t	pid;
			int	status;
			do {
				pid = waitpid(m_state.pid, &status, WNOHANG);
			} while (pid == -1 && errno == EINTR);

			if (pid == m_state.pid &&
			    (WIFEXITED(status) || WIFSIGNALED(status)))
				break;
		}

		FD_SET(m_state.s, &rfds);
		if (select(m_state.s + 1, &rfds, NULL, NULL, tvp) == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			log_err("monitor_loop: select()");
			break;
		}

		/* Wait for next task */
		if (FD_ISSET(m_state.s, &rfds)) {
			if ((r = m_read(m_state.s, &v, sizeof v)) < 1) {
				if (r == -1)
					log_err("monitor_loop: read()");
				break;
			}
		}

		/* Retry after timeout */
		if (v == 0 && tvp != NULL) {
			v = vn;
			tvp = NULL;
			vn = 0;
		}

		switch (v) {
		case MONITOR_GETSNAP:
			/* Get the data. */
			m_priv_pfkey_snap(m_state.s);
			break;
		case MONITOR_CARPINC:
			carp_demote(CARP_INC, 1);
			break;
		case MONITOR_CARPDEC:
			carp_demote(CARP_DEC, 1);
			break;
		case MONITOR_CONTROL_ACTIVATE:
			ret = m_priv_control_activate();
			break;
		case MONITOR_CONTROL_PASSIVATE:
			ret = m_priv_control_passivate();
			break;
		}

		if (ret == -1) {
			/* Trigger retry after timeout */
			tv.tv_sec = MONITOR_RETRY_TIMEOUT;
			tv.tv_usec = 0;
			tvp = &tv;
			vn = v;
		}
	}

	monitor_carpundemote(NULL);

	if (!sigchld)
		log_msg(0, "monitor_loop: priv process exiting abnormally");
	exit(0);
}

void
monitor_carpundemote(void *v)
{
	u_int32_t mtype = MONITOR_CARPDEC;
	if (!carp_demoted)
		return;
	if (m_write(m_state.s, &mtype, sizeof mtype) < 1)
		log_msg(1, "monitor_carpundemote: unable to write to monitor");
	else
		carp_demoted = 0;
}

void
monitor_carpdemote(void *v)
{
	u_int32_t mtype = MONITOR_CARPINC;
	if (carp_demoted)
		return;
	if (m_write(m_state.s, &mtype, sizeof mtype) < 1)
		log_msg(1, "monitor_carpdemote: unable to write to monitor");
	else
		carp_demoted = 1;
}

int
monitor_get_pfkey_snap(u_int8_t **sadb, u_int32_t *sadbsize, u_int8_t **spd,
    u_int32_t *spdsize)
{
	u_int32_t	v;
	ssize_t		rbytes;

	v = MONITOR_GETSNAP;
	if (m_write(m_state.s, &v, sizeof v) < 1)
		return -1;

	/* Read SADB data. */
	*sadb = *spd = NULL;
	*spdsize = 0;
	if (m_read(m_state.s, sadbsize, sizeof *sadbsize) < 1)
		return -1;
	if (*sadbsize) {
		*sadb = malloc(*sadbsize);
		if (!*sadb) {
			log_err("monitor_get_pfkey_snap: malloc()");
			monitor_drain_input();
			return -1;
		}
		rbytes = m_read(m_state.s, *sadb, *sadbsize);
		if (rbytes < 1) {
			explicit_bzero(*sadb, *sadbsize);
			free(*sadb);
			return -1;
		}
	}

	/* Read SPD data */
	if (m_read(m_state.s, spdsize, sizeof *spdsize) < 1) {
		if (*sadbsize) {
			explicit_bzero(*sadb, *sadbsize);
			free(*sadb);
		}
		return -1;
	}
	if (*spdsize) {
		*spd = malloc(*spdsize);
		if (!*spd) {
			log_err("monitor_get_pfkey_snap: malloc()");
			monitor_drain_input();
			if (*sadbsize) {
				explicit_bzero(*sadb, *sadbsize);
				free(*sadb);
			}
			return -1;
		}
		rbytes = m_read(m_state.s, *spd, *spdsize);
		if (rbytes < 1) {
			explicit_bzero(*spd, *spdsize);
			free(*spd);
			if (*sadbsize) {
				explicit_bzero(*sadb, *sadbsize);
				free(*sadb);
			}
			return -1;
		}
	}

	log_msg(2, "monitor_get_pfkey_snap: got %u bytes SADB, %u bytes SPD",
	    *sadbsize, *spdsize);
	return 0;
}

int
monitor_control_active(int active)
{
	u_int32_t	cmd =
	    active ? MONITOR_CONTROL_ACTIVATE : MONITOR_CONTROL_PASSIVATE;
	if (write(m_state.s, &cmd, sizeof cmd) < 1)
		return -1;
	return 0;
}

/* Privileged */
static void
m_priv_pfkey_snap(int s)
{
	u_int8_t	*sadb_buf = NULL, *spd_buf = NULL;
	size_t		 sadb_buflen = 0, spd_buflen = 0, sz;
	int		 mib[5];
	u_int32_t	 v;

	mib[0] = CTL_NET;
	mib[1] = PF_KEY;
	mib[2] = PF_KEY_V2;
	mib[3] = NET_KEY_SADB_DUMP;
	mib[4] = 0; /* Unspec SA type */

	/* First, fetch SADB data */
	for (;;) {
		if (sysctl(mib, sizeof mib / sizeof mib[0], NULL, &sz, NULL, 0)
		    == -1)
			break;

		if (!sz)
			break;

		/* Try to catch newly added data */
		sz *= 2;

		if ((sadb_buf = malloc(sz)) == NULL)
			break;

		if (sysctl(mib, sizeof mib / sizeof mib[0], sadb_buf, &sz, NULL, 0)
		    == -1) {
			free(sadb_buf);
			sadb_buf = NULL;
			/*
			 * If new SAs were added meanwhile and the given buffer is
			 * too small, retry.
			 */
			if (errno == ENOMEM)
				continue;
			break;
		}

		sadb_buflen = sz;
		break;
	}

	/* Next, fetch SPD data */
	mib[3] = NET_KEY_SPD_DUMP;

	for (;;) {
		if (sysctl(mib, sizeof mib / sizeof mib[0], NULL, &sz, NULL, 0)
		    == -1)
			break;

		if (!sz)
			break;

		/* Try to catch newly added data */
		sz *= 2;

		if ((spd_buf = malloc(sz)) == NULL)
			break;

		if (sysctl(mib, sizeof mib / sizeof mib[0], spd_buf, &sz, NULL, 0)
		    == -1) {
			free(spd_buf);
			spd_buf = NULL;
			/*
			 * If new SPDs were added meanwhile and the given buffer is
			 * too small, retry.
			 */
			if (errno == ENOMEM)
				continue;
			break;
		}

		spd_buflen = sz;
		break;
	}

	/* Return SADB data */
	v = (u_int32_t)sadb_buflen;
	if (m_write(s, &v, sizeof v) == -1) {
		log_err("m_priv_pfkey_snap: write");
		goto cleanup;
	}
	if (m_write(s, sadb_buf, sadb_buflen) == -1) {
		log_err("m_priv_pfkey_snap: write");
		goto cleanup;
	}

	/* Return SPD data */
	v = (u_int32_t)spd_buflen;
	if (m_write(s, &v, sizeof v) == -1) {
		log_err("m_priv_pfkey_snap: write");
		goto cleanup;
	}
	if (m_write(s, spd_buf, spd_buflen) == -1) {
		log_err("m_priv_pfkey_snap: write");
		goto cleanup;
	}

cleanup:
	if (sadb_buf) {
		explicit_bzero(sadb_buf, sadb_buflen);
		free(sadb_buf);
	}
	if (spd_buf) {
		explicit_bzero(spd_buf, spd_buflen);
		free(spd_buf);
	}
}

static int
m_priv_isakmpd_fifocmd(const char *cmd)
{
	struct stat	sb;
	int		fd = -1, ret = -1;

	if ((fd = open(ISAKMPD_FIFO, O_WRONLY)) == -1) {
		log_err("m_priv_isakmpd_fifocmd: open(%s)", ISAKMPD_FIFO);
		goto out;
	}
	if (fstat(fd, &sb) == -1) {
		log_err("m_priv_isakmpd_fifocmd: fstat(%s)", ISAKMPD_FIFO);
		goto out;
	}
	if (!S_ISFIFO(sb.st_mode)) {
		log_err("m_priv_isakmpd_fifocmd: %s not a fifo", ISAKMPD_FIFO);
		goto out;
	}

	if (write(fd, cmd, strlen(cmd)) == -1) {
		log_err("m_priv_isakmpd_fifocmd write");
		goto out;
	}

	ret = 0;
 out:
	if (fd != -1)
		close(fd);

	return (ret);
}

static int
m_priv_iked_imsg(u_int cmd)
{
	struct sockaddr_un	 sun;
	int			 fd = -1, ret = -1;
	struct imsgbuf		 ibuf;

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
		log_err("m_priv_iked_imsg: socket");
		goto out;
	}

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, IKED_SOCKET, sizeof(sun.sun_path));

	if (connect(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_err("m_priv_iked_imsg: connect");
		goto out;				
	}

	imsg_init(&ibuf, fd);
	if (imsg_compose(&ibuf, cmd, 0, 0, -1, NULL, 0) == -1) {
		log_err("m_priv_iked_imsg: compose");
		goto err;
	}
	if (imsg_flush(&ibuf) == -1) {
		log_err("m_priv_iked_imsg: flush");
		goto err;
	}

	ret = 0;
 err:
	imsg_clear(&ibuf);
 out:
	if (fd != -1)
		close(fd);

	return (ret);
}

static int
m_priv_control_activate(void)
{
	if (cfgstate.flags & CTL_ISAKMPD)
		if (m_priv_isakmpd_fifocmd("M active\n") == -1)
			return (-1);
	if (cfgstate.flags & CTL_IKED)
		if (m_priv_iked_imsg(IMSG_CTL_ACTIVE) == -1)
			return (-1);
	return (0);
}

static int
m_priv_control_passivate(void)
{
	if (cfgstate.flags & CTL_ISAKMPD)
		if (m_priv_isakmpd_fifocmd("M passive\n") == -1)
			return (-1);
	if (cfgstate.flags & CTL_IKED)
		if (m_priv_iked_imsg(IMSG_CTL_PASSIVE) == -1)
			return (-1);
	return (0);
}

ssize_t
m_write(int sock, void *buf, size_t len)
{
	ssize_t n;
	size_t pos = 0;
	char *ptr = buf;

	while (len > pos) {
		switch (n = write(sock, ptr + pos, len - pos)) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
			/* FALLTHROUGH */
		case 0:
			return n;
			/* NOTREACHED */
		default:
			pos += n;
		}
	}
	return pos;
}

ssize_t
m_read(int sock, void *buf, size_t len)
{
	ssize_t n;
	size_t pos = 0;
	char *ptr = buf;

	while (len > pos) {
		switch (n = read(sock, ptr + pos, len - pos)) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
			/* FALLTHROUGH */
		case 0:
			return n;
			/* NOTREACHED */
		default:
			pos += n;
		}
	}
	return pos;
}
@


1.20
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.19 2015/01/16 06:40:20 deraadt Exp $	*/
d288 1
a288 1
			memset(*sadb, 0, *sadbsize);
d297 1
a297 1
			memset(*sadb, 0, *sadbsize);
d308 1
a308 1
				memset(*sadb, 0, *sadbsize);
d315 1
a315 1
			memset(*spd, 0, *spdsize);
d318 1
a318 1
				memset(*sadb, 0, *sadbsize);
d445 1
a445 1
		memset(sadb_buf, 0, sadb_buflen);
d449 1
a449 1
		memset(spd_buf, 0, spd_buflen);
@


1.19
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.18 2014/06/29 00:58:45 deraadt Exp $	*/
d280 1
a280 1
		*sadb = (u_int8_t *)malloc(*sadbsize);
d303 1
a303 1
		*spd = (u_int8_t *)malloc(*spdsize);
@


1.18
log
@If you want <sys/queue.h>, you need to include it.  Don't assume that
<sys/sysctl.h> will pull in the universe (I am working on breaking that
assumption in a gentle fashion)
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.17 2012/09/12 07:45:19 haesbaert Exp $	*/
a27 1
#include <sys/param.h>
d45 1
d73 1
a73 1
	char		root[MAXPATHLEN];
@


1.17
log
@Fix a race condition which would cause segfault due to the kernel
sending less (or more) data than expected.

We do a sysctl to know how much data should be read, and then we try to
read that amount, but there is a window between this two calls that
things can change, this makes sure we have an "atomic view" of data.

From Patrick Wildt, tested with over 7000 SAs, thanks.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.16 2012/09/04 14:41:25 okan Exp $	*/
d34 1
@


1.16
log
@fix log_err() calls (from Patrick Wildt) and remove extra space.

ok haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.15 2012/04/02 18:56:15 millert Exp $	*/
d343 1
a343 1
	u_int8_t	*sadb_buf = 0, *spd_buf = 0;
d355 29
a383 18
	if (sysctl(mib, sizeof mib / sizeof mib[0], NULL, &sz, NULL, 0) == -1
	    || sz == 0) {
		sadb_buflen = 0;
		goto try_spd;
	}

	sadb_buflen = sz;
	if ((sadb_buf = malloc(sadb_buflen)) == NULL) {
		log_err("m_priv_pfkey_snap: malloc");
		sadb_buflen = 0;
		goto out;
	}

	if (sysctl(mib, sizeof mib / sizeof mib[0], sadb_buf, &sz, NULL, 0)
	    == -1) {
		log_err("m_priv_pfkey_snap: sysctl");
		sadb_buflen = 0;
		goto out;
a386 1
  try_spd:
d389 13
a401 5
	if (sysctl(mib, sizeof mib / sizeof mib[0], NULL, &sz, NULL, 0) == -1
	    || sz == 0) {
		spd_buflen = 0;
		goto out;
	}
d403 12
a414 6
	spd_buflen = sz;
	if ((spd_buf = malloc(spd_buflen)) == NULL) {
		log_err("m_priv_pfkey_snap: malloc");
		spd_buflen = 0;
		goto out;
	}
d416 2
a417 5
	if (sysctl(mib, sizeof mib / sizeof mib[0], spd_buf, &sz, NULL, 0)
	    == -1) {
		log_err("m_priv_pfkey_snap: sysctl");
		spd_buflen = 0;
		goto out;
a419 1
  out:
d426 1
a426 1
	if (m_write(s, sadb_buf, sadb_buflen) == -1)
d428 2
d437 1
a437 1
	if (m_write(s, spd_buf, spd_buflen) == -1)
d439 12
a450 5
  cleanup:
	memset(sadb_buf, 0, sadb_buflen);
	free(sadb_buf);
	memset(spd_buf, 0, spd_buflen);
	free(spd_buf);
@


1.15
log
@Fix memory leak in error path, originally based on a diff from jsg@@.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.14 2010/06/29 18:10:04 kjell Exp $	*/
d183 1
a183 1
			log_err(0, "monitor_loop: select() ");
d191 1
a191 1
					log_err(0, "monitor_loop: read() ");
@


1.14
log
@Having more than 2 log levels is silly. Use only 3 verbosity levels:
 None (), Important (-v), All (-vv)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.13 2010/06/16 17:39:05 reyk Exp $	*/
d404 1
a404 7
		return;
	}
	if (sadb_buflen) {
		if (m_write(s, sadb_buf, sadb_buflen) == -1)
			log_err("m_priv_pfkey_snap: write");
		memset(sadb_buf, 0, sadb_buflen);
		free(sadb_buf);
d406 2
d413 1
a413 1
		return;
d415 7
a421 7
	if (spd_buflen) {
		if (m_write(s, spd_buf, spd_buflen) == -1)
			log_err("m_priv_pfkey_snap: write");
		memset(spd_buf, 0, spd_buflen);
		free(spd_buf);
	}
	return;
@


1.13
log
@Add support to use sasyncd(8) with iked(8) instead of isakmpd(8).  The
new config option "control isakmpd|iked|all|none" in sasyncd.conf(5)
is used to set the mode; the default is to control isakmpd like
before.  When controlling iked, sasyncd connects to the daemon using
the imsg socket and sends imsgs - this is easy because the imsg
framework has been imported into libutil. iked(8) already includes
the important bits to work with sasyncd(8) (the active/passive mode
option in ikectl).

manpage bits ok jsg@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.12 2006/12/25 08:17:17 deraadt Exp $	*/
d324 1
a324 1
	log_msg(3, "monitor_get_pfkey_snap: got %u bytes SADB, %u bytes SPD",
@


1.12
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.11 2006/09/01 01:13:25 mpf Exp $	*/
d35 1
d45 3
d62 2
a63 2
static void	m_priv_isakmpd_activate(void);
static void	m_priv_isakmpd_passivate(void);
d153 9
a161 2
	u_int32_t	v;
	ssize_t		r;
d164 3
d179 8
d188 13
a200 4
		if ((r = m_read(m_state.s, &v, sizeof v)) < 1) {
			if (r == -1)
				log_err(0, "monitor_loop: read() ");
			break;
d214 2
a215 2
		case MONITOR_ISAKMPD_ACTIVATE:
			m_priv_isakmpd_activate();
d217 2
a218 2
		case MONITOR_ISAKMPD_PASSIVATE:
			m_priv_isakmpd_passivate();
d221 8
d330 1
a330 1
monitor_isakmpd_active(int active)
d333 1
a333 1
	    active ? MONITOR_ISAKMPD_ACTIVATE : MONITOR_ISAKMPD_PASSIVATE;
d428 1
a428 1
static void
d432 1
a432 1
	int		fd = -1;
d451 2
d456 2
a457 2
	/* No values returned. */
	return;
d460 2
a461 2
static void
m_priv_isakmpd_activate(void)
d463 36
a498 1
	m_priv_isakmpd_fifocmd("M active\n");
d501 2
a502 2
static void
m_priv_isakmpd_passivate(void)
d504 19
a522 1
	m_priv_isakmpd_fifocmd("M passive\n");
@


1.11
log
@Teach sasyncd to set isakmpd into active or passive mode, according
to our current carp state.
Based on a diff by ho@@.
OK ho@@, hshoexer@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.10 2006/08/31 12:55:02 mpf Exp $	*/
d293 1
a293 1
	u_int32_t	cmd = 
@


1.10
log
@Only chroot the unprivileged part of sasyncd(8).
OK deraadt@@ mcbride@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.9 2006/06/02 20:31:48 moritz Exp $	*/
d32 1
d38 1
d45 1
d58 2
a176 1

a179 1

d183 6
d290 10
d387 42
@


1.9
log
@whitespace cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.8 2006/06/02 20:09:43 mcbride Exp $	*/
a84 5
	if (chroot(pw->pw_dir) != 0 || chdir("/") != 0) {
		log_err("%s: chroot failed", __progname);
		exit(1);
	}

d94 5
@


1.8
log
@Make sasyncd fail back correctly with carp preemption enabled.

Hold the carp demotion when booting, to prevent carp from preempting until
we've sync'd with our peers.  This adds a new CTL_ENDSNAP message to the
exchange between the sasync daemons to indicate when the complete snapshot
has been sent. Undemote after 60 seconds, or when recieve a CTL_ENDSNAP from
all our peers.

Syntax is slightly changed, removing the 'carp' keyword (so do
"interface carp0" rather than "carp interface carp0". Adds 'group <ifgroup>',
defaults to the 'carp' group.

ok moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.7 2006/01/26 09:53:46 moritz Exp $	*/
d67 1
a67 1
		log_err("%s: socketpair failed - %s", __progname, 
d71 1
a71 1
	
d100 1
a100 1
		if (setgroups(1, &pw->pw_gid) || 
d302 1
a302 1
	
d326 1
a326 1
	
@


1.7
log
@fix some format strings and add a missing
argument to a log_err() call. ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.6 2005/07/19 17:46:12 moritz Exp $	*/
d160 1
a160 1
		/* Wait for next snapshot task. Disregard read data. */
d167 14
a180 2
		/* Get the data. */
		m_priv_pfkey_snap(m_state.s);
d183 2
d190 24
d221 1
a221 2
	/* We write a (any) value to the monitor socket to start a snapshot. */
	v = 0;
@


1.6
log
@handle short reads/writes. this fixes the
transfer of big SA/SPD snapshots. ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.5 2005/07/07 19:29:24 moritz Exp $	*/
d239 1
a239 1
	log_msg(3, "monitor_get_pfkey_snap: got %d bytes SADB, %d bytes SPD",
@


1.5
log
@when reading of sadb/spd data fails don't call
memset with a len of (unsigned)-1. ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.4 2005/05/26 19:19:51 ho Exp $	*/
d55 2
d135 1
a135 1
	while (read(m_state.s, &tmp, 1) > 0)
d161 1
a161 1
		if ((r = read(m_state.s, &v, sizeof v)) != sizeof v) {
d185 1
a185 1
	if (write(m_state.s, &v, sizeof v) < 1)
d191 1
a191 1
	if (read(m_state.s, sadbsize, sizeof *sadbsize) < 1)
d200 3
a202 4
		rbytes = read(m_state.s, *sadb, *sadbsize);
		if (rbytes != *sadbsize) {
			if (rbytes > 0)
				memset(*sadb, 0, rbytes);
d209 1
a209 1
	if (read(m_state.s, spdsize, sizeof *spdsize) < 1) {
d227 3
a229 4
		rbytes = read(m_state.s, *spd, *spdsize);
		if (rbytes != *spdsize) {
			if (rbytes > 0)
				memset(*spd, 0, rbytes);
d307 1
a307 1
	if (write(s, &v, sizeof v) == -1) {
d312 1
a312 1
		if (write(s, sadb_buf, sadb_buflen) == -1)
d320 1
a320 1
	if (write(s, &v, sizeof v) == -1) {
d325 1
a325 1
		if (write(s, spd_buf, spd_buflen) == -1)
d331 46
@


1.4
log
@add a 'flushmode' to control how the master handles FLUSH to slaves. tweak some loglevels.
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.3 2005/05/26 05:33:48 ho Exp $	*/
d178 3
a180 2
	u_int32_t	rbytes;
	
d182 2
a183 2
	rbytes = 0;
	if (write(m_state.s, &rbytes, sizeof rbytes) < 1)
@


1.3
log
@Initialize variables
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.2 2005/05/26 00:55:03 ho Exp $	*/
d126 12
a141 3
	extern volatile sig_atomic_t	daemon_shutdown;
	pid_t		pid;
	int		status;
d143 1
d145 1
a145 1
	while (!daemon_shutdown) {
d147 2
d154 1
a154 2
			    (WIFEXITED(status) || WIFSIGNALED(status))) {
				daemon_shutdown++;
a155 1
			}
d159 3
a161 1
		if (read(m_state.s, &v, sizeof v) != (ssize_t)sizeof v)
d163 1
d168 3
a170 1
	
a177 2
	int		one = 1;
	u_int8_t	tmp;
d181 2
a182 2
	*sadbsize = 0;
	if (write(m_state.s, sadbsize, sizeof *sadbsize) < 1)
d194 1
a194 4
			/* Drain input */
			ioctl(m_state.s, FIONBIO, &one);
			while (read(m_state.s, &tmp, 1) > 0);
			ioctl(m_state.s, FIONBIO, 0);
d218 1
a218 4
			/* Drain input */
			ioctl(m_state.s, FIONBIO, &one);
			while (read(m_state.s, &tmp, 1) > 0);
			ioctl(m_state.s, FIONBIO, 0);
d238 1
a238 1
	log_msg(5, "monitor_get_pfkey_snap: got %d bytes SADB, %d bytes SPD",
@


1.2
log
@Don't alloc/free zero-sized SADB/SPD buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.1 2005/05/24 02:35:39 ho Exp $	*/
d240 1
a240 1
	u_int8_t	*sadb_buf, *spd_buf;
a251 1

@


1.1
log
@When peers connect, have the master daemon look at in-kernel SAs and feed
these to the new peer. Adds privsep as fetching SADB and SPD kernel data
requires privileges.
@
text
@d1 1
a1 1
/*	$OpenBSD: sasyncd.c,v 1.7 2005/05/22 20:35:48 ho Exp $	*/
d173 2
d177 17
a193 15
	*sadb = (u_int8_t *)malloc(*sadbsize);
	if (!*sadb) {
		log_err("monitor_get_pfkey_snap: malloc()");
		/* Drain input */
		ioctl(m_state.s, FIONBIO, &one);
		while (read(m_state.s, &tmp, 1) > 0);
		ioctl(m_state.s, FIONBIO, 0);
		return -1;
	}
	rbytes = read(m_state.s, *sadb, *sadbsize);
	if (rbytes != *sadbsize) {
		if (rbytes > 0)
			memset(*sadb, 0, rbytes);
		free(*sadb);
		return -1;
d198 4
a201 2
		memset(*sadb, 0, *sadbsize);
		free(*sadb);
d204 25
a228 19
	*spd = (u_int8_t *)malloc(*spdsize);
	if (!*spd) {
		log_err("monitor_get_pfkey_snap: malloc()");
		/* Drain input */
		ioctl(m_state.s, FIONBIO, &one);
		while (read(m_state.s, &tmp, 1) > 0);
		ioctl(m_state.s, FIONBIO, 0);
		memset(*sadb, 0, *sadbsize);
		free(*sadb);
		return -1;
	}
	rbytes = read(m_state.s, *spd, *spdsize);
	if (rbytes != *spdsize) {
		if (rbytes > 0)
			memset(*spd, 0, rbytes);
		memset(*sadb, 0, *sadbsize);
		free(*spd);
		free(*sadb);
		return -1;
d304 1
a304 1
	if (sadb_buflen)
a306 1
	if (sadb_buf) {
d317 1
a317 1
	if (spd_buflen)
a319 1
	if (spd_buf) {
@

