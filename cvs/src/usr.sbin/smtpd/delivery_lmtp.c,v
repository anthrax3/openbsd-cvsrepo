head	1.17;
access;
symbols
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2016.06.05.12.10.28;	author gilles;	state Exp;
branches;
next	1.16;
commitid	6pXjFRJdnvTxY2O5;

1.16
date	2016.06.05.11.48.56;	author gilles;	state Exp;
branches;
next	1.15;
commitid	tGpVQ5OxA1WXVmCu;

1.15
date	2015.12.14.10.22.11;	author jung;	state Exp;
branches;
next	1.14;
commitid	HRAnniyhGW9Sadln;

1.14
date	2015.10.27.21.20.11;	author jung;	state Exp;
branches;
next	1.13;
commitid	YRcUZhsvrsRgoY3W;

1.13
date	2015.10.27.21.11.27;	author jung;	state Exp;
branches;
next	1.12;
commitid	9qZWELtvTv5Fm59K;

1.12
date	2015.10.19.09.15.35;	author sunil;	state Exp;
branches;
next	1.11;
commitid	HsD3RVVVb420pX2q;

1.11
date	2015.10.18.18.59.51;	author jung;	state Exp;
branches;
next	1.10;
commitid	erPrYBj4qCpJQHXb;

1.10
date	2015.10.17.16.07.03;	author sunil;	state Exp;
branches;
next	1.9;
commitid	mK6aIuARfMTmtYm0;

1.9
date	2015.10.14.22.01.43;	author gilles;	state Exp;
branches;
next	1.8;
commitid	XSq2zfqNj1sXRZRl;

1.8
date	2015.10.10.11.42.49;	author jung;	state Exp;
branches;
next	1.7;
commitid	6SQmKxFFyKAzB7di;

1.7
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	ZBTFreARDSMmzOIV;

1.6
date	2014.04.19.17.24.59;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.19.11.29.06;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.26.12.27.58;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2013.07.19.08.45.38;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	;


desc
@@


1.17
log
@LMTP banner is handled by a getline() call so it cannot handle multiline
banners, introduce lmtp_banner() which takes care of this.

ok sunil@@
@
text
@/* $OpenBSD: delivery_lmtp.c,v 1.16 2016/06/05 11:48:56 gilles Exp $ */

/*
 * Copyright (c) 2013 Ashish SHUKLA <ashish.is@@lostca.se>
 * Copyright (c) 2015 Sunil Nimmagadda <sunil@@nimmagadda.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/socket.h>
#include <sys/tree.h>
#include <sys/un.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "smtpd.h"

/* should be more than enough for any LMTP server */
#define	MAX_CONTINUATIONS	100

static int	inet_socket(char *);
static int	lmtp_banner(char **buf, size_t *, int, FILE *);
static int	lmtp_cmd(char **buf, size_t *, int, FILE *, const char *, ...)
		    __attribute__((__format__ (printf, 5, 6)))
		    __attribute__((__nonnull__ (5)));
static void	lmtp_open(struct deliver *);
static int	unix_socket(char *);

struct delivery_backend delivery_backend_lmtp = {
	 0, lmtp_open
};

static int
inet_socket(char *address)
{
	 struct addrinfo	 hints, *res, *res0;
	 char			*hostname, *servname;
	 const char		*cause = NULL;
	 int			 n, s = -1, save_errno;

	 if ((servname = strchr(address, ':')) == NULL)
		 errx(1, "invalid address: %s", address);

	 *servname++ = '\0';
	 hostname = address;
	 memset(&hints, 0, sizeof(hints));
	 hints.ai_family = PF_UNSPEC;
	 hints.ai_socktype = SOCK_STREAM;
	 hints.ai_flags = AI_NUMERICSERV;
	 n = getaddrinfo(hostname, servname, &hints, &res0);
	 if (n)
		 errx(1, "%s", gai_strerror(n));

	 for (res = res0; res; res = res->ai_next) {
		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (s == -1) {
			 cause = "socket";
			 continue;
		 }

		 if (connect(s, res->ai_addr, res->ai_addrlen) == -1) {
			 cause = "connect";
			 save_errno = errno;
			 close(s);
			 errno = save_errno;
			 s = -1;
			 continue;
		 }

		 break;
	 }

	 freeaddrinfo(res0);
	 if (s == -1)
		errx(1, "%s", cause);

	 return s;
}

static int
unix_socket(char *path)
{
	 struct sockaddr_un	addr;
	 int			s;

	 if ((s = socket(PF_LOCAL, SOCK_STREAM, 0)) == -1)
		 err(1, "socket");

	 memset(&addr, 0, sizeof(addr));
	 addr.sun_family = AF_UNIX;
	 if (strlcpy(addr.sun_path, path, sizeof(addr.sun_path))
	     >= sizeof(addr.sun_path))
		 errx(1, "socket path too long");

	 if (connect(s, (struct sockaddr *)&addr, sizeof(addr)) == -1)
		 err(1, "connect");

	 return s;
}

static void
lmtp_open(struct deliver *deliver)
{
	FILE		*fp;
	char		*buf = NULL, hn[HOST_NAME_MAX + 1],
			*rcpt = deliver->to, *to = deliver->to;
	size_t		 sz = 0;
	ssize_t		 len;
	int		 s;

	strsep(&rcpt, " ");
	s = (to[0] == '/') ? unix_socket(to) : inet_socket(to);
	if ((fp = fdopen(s, "r+")) == NULL)
		err(1, "fdopen");

	if (lmtp_banner(&buf, &sz, '2', fp) != 0)
		errx(1, "Invalid LHLO reply: %s", buf);

	if (gethostname(hn, sizeof hn) == -1)
		err(1, "gethostname");

	if (lmtp_cmd(&buf, &sz, '2', fp, "LHLO %s", hn) != 0)
		errx(1, "Invalid LHLO reply: %s", buf);

	if (lmtp_cmd(&buf, &sz, '2', fp, "MAIL FROM:<%s>", deliver->from) != 0)
		errx(1, "MAIL FROM rejected: %s", buf);

	if (lmtp_cmd(&buf, &sz, '2', fp, "RCPT TO:<%s>",
	    rcpt ? deliver->dest : deliver->user) != 0)
		errx(1, "RCPT TO rejected: %s", buf);

	if (lmtp_cmd(&buf, &sz, '3', fp, "DATA") != 0)
		errx(1, "Invalid DATA reply: %s", buf);

	while ((len = getline(&buf, &sz, stdin)) != -1) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';

		if (fprintf(fp, "%s%s\r\n", buf[0] == '.' ? "." : "", buf) < 0)
			errx(1, "fprintf failed");
	}

	if (lmtp_cmd(&buf, &sz, '2', fp, ".") != 0)
		errx(1, "Delivery error: %s", buf);

	if (lmtp_cmd(&buf, &sz, '2', fp, "QUIT") != 0)
		errx(1, "Error on QUIT: %s", buf);

	exit(0);
}

static int
lmtp_banner(char **buf, size_t *sz, int code, FILE *fp)
{
	char	*bufp;
	ssize_t	 len;
	size_t	 counter;

	counter = 0;
	do {
		if ((len = getline(buf, sz, fp)) == -1)
			err(1, "getline");
		if (len < 4)
			err(1, "line too short");

		bufp = *buf;
		if (len >= 2 && bufp[len - 2] == '\r')
			bufp[len - 2] = '\0';
		else if (bufp[len - 1] == '\n')
			bufp[len - 1] = '\0';

		if (bufp[3] == '\0' || bufp[3] == ' ')
			break;
		else if (bufp[3] == '-') {
			if (counter == MAX_CONTINUATIONS)
				errx(1, "LMTP server is sending too many continuations");
			counter++;
			continue;
		}
		else
			errx(1, "invalid line");
	} while (1);

	return bufp[0] != code;
}

static int
lmtp_cmd(char **buf, size_t *sz, int code, FILE *fp, const char *fmt, ...)
{
	va_list	 ap;
	char	*bufp;
	ssize_t	 len;
	size_t	 counter;

	va_start(ap, fmt);
	if (vfprintf(fp, fmt, ap) < 0)
		errx(1, "vfprintf failed");

	va_end(ap);
	if (fprintf(fp, "\r\n") < 0)
		errx(1, "fprintf failed");

	if (fflush(fp) != 0)
		err(1, "fflush");

	counter = 0;
	do {
		if ((len = getline(buf, sz, fp)) == -1)
			err(1, "getline");
		if (len < 4)
			err(1, "line too short");

		bufp = *buf;
		if (len >= 2 && bufp[len - 2] == '\r')
			bufp[len - 2] = '\0';
		else if (bufp[len - 1] == '\n')
			bufp[len - 1] = '\0';

		if (bufp[3] == '\0' || bufp[3] == ' ')
			break;
		else if (bufp[3] == '-') {
			if (counter == MAX_CONTINUATIONS)
				errx(1, "LMTP server is sending too many continuations");
			counter++;
			continue;
		}
		else
			errx(1, "invalid line");
	} while (1);

	return bufp[0] != code;
}
@


1.16
log
@delivery_lmtp does not know how to deal with LMTP servers returning
continuation lines, fix this.

reported and initial diff by parchd-1 @@ github, ok sunil@@
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.15 2015/12/14 10:22:11 jung Exp $ */
d43 1
d137 2
a138 5
	if (getline(&buf, &sz, fp) == -1)
		err(1, "getline");

	if (buf[0] != '2')
		errx(1, "Invalid LMTP greeting: %s", buf);
d171 35
@


1.15
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.14 2015/10/27 21:20:11 jung Exp $ */
d39 3
d181 1
d194 24
a217 8
	if ((len = getline(buf, sz, fp)) == -1)
		err(1, "getline");

	bufp = *buf;
	if (len >= 2 && bufp[len - 2] == '\r')
		bufp[len - 2] = '\0';
	else if (bufp[len - 1] == '\n')
		bufp[len - 1] = '\0';
@


1.14
log
@add a rcpt-to parameter to be able to use the original (probably expanded)
RCPT TO within LMTP sessions

ok gilles eric
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.13 2015/10/27 21:11:27 jung Exp $ */
d128 1
a128 1
	strsep(&rcpt, " "); 
@


1.13
log
@delivery lmtp gets fed with a message file as input which is guaranted to have
\n-terminated lines, so no need to strip \r here

also remove an unneeded len assignment while here

discussed with and ok gilles
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.12 2015/10/19 09:15:35 sunil Exp $ */
d122 2
a123 1
	char		*buf = NULL, hn[HOST_NAME_MAX+1], *to = deliver->to;
d128 1
d148 2
a149 1
	if (lmtp_cmd(&buf, &sz, '2', fp, "RCPT TO:<%s>", deliver->user) != 0)
@


1.12
log
@Kill whitespace at eol.

Ok gilles@@
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.11 2015/10/18 18:59:51 jung Exp $ */
d131 1
a131 1
	if ((len = getline(&buf, &sz, fp)) == -1)
d153 1
a153 3
		if (len >= 2 && buf[len - 2] == '\r')
			buf[len - 2] = '\0';
		else if (buf[len - 1] == '\n')
@


1.11
log
@fix lmtp delivery regressions introduced in previous:

- strip \r\n and add them explicitly to all DATA lines
- fix DATA termination
- add missing QUIT command (and check for reply)
- remove free() and fclose() and use exit(3) instead of _exit(2)
  to handle cleanup

ok sunil gilles
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.10 2015/10/17 16:07:03 sunil Exp $ */
d153 4
a156 4
		if (len >= 2 && buf[len - 2] == '\r')                    
			buf[len - 2] = '\0';                             
		else if (buf[len - 1] == '\n')                           
			buf[len - 1] = '\0';  
@


1.10
log
@Cleanup and simplify LMTP code.

Ok millert@@ gilles@@
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.8 2015/10/10 11:42:49 jung Exp $ */
d152 7
a158 2
	while ((len = getline(&buf, &sz, stdin)) != -1)
		if (fprintf(fp, "%s%s", buf[0] == '.' ? "." : "", buf) < 0)
d160 4
d165 2
a166 6
	free(buf);
	if (fprintf(fp, ".\r\n") < 0)
		errx(1, "fprintf failed");
		
	if (fclose(fp) != 0)
		err(1, "fclose");
d168 1
a168 1
	_exit(0);
@


1.9
log
@whitespaces
@
text
@d5 1
a19 1
#include <sys/types.h>
a20 1
#include <sys/queue.h>
d26 1
d30 1
a30 1
#include <paths.h>
a35 1
#include <limits.h>
a37 5
#include "log.h"


/* mda backend */
static void delivery_lmtp_open(struct deliver *);
d39 6
a44 3
static int inet_socket(char *);
static int unix_socket(char *);
static char* lmtp_getline(FILE *);
d47 1
a47 11
	 0, delivery_lmtp_open
};

enum lmtp_state {
	 LMTP_BANNER,
	 LMTP_LHLO,
	 LMTP_MAIL_FROM,
	 LMTP_RCPT_TO,
	 LMTP_DATA,
	 LMTP_QUIT,
	 LMTP_BYE
d51 1
a51 1
inet_socket (char *address)
d53 4
a56 4
	 int s, n;
	 char *hostname, *servname;
	 struct addrinfo hints;
	 struct addrinfo *result0, *result;
d58 1
a58 2
	 servname = strchr(address, ':');
	 if (servname == NULL)
a62 2
	 s = -1;

d67 1
a67 2

	 n = getaddrinfo(hostname, servname, &hints, &result0);
d71 4
a74 4
	 for (result = result0; s < 0 && result; result = result->ai_next) {
		 if ((s = socket(result->ai_family, result->ai_socktype,
			     result->ai_protocol)) == -1) {
			 warn("socket");
d77 4
a80 2
		 if (connect(s, result->ai_addr, result->ai_addrlen) == -1) {
			 warn("connect");
d82 1
d86 1
d90 3
a92 1
	 freeaddrinfo(result0);
d98 7
a104 3
unix_socket(char *path) {
	 struct sockaddr_un addr;
	 int s;
a106 6

	 if ((s = socket(PF_LOCAL, SOCK_STREAM, 0)) == -1) {
		 warn("socket");
		 return -1;
	 }

d109 2
a110 5
	     >= sizeof(addr.sun_path)) {
		 warnx("socket path too long");
		 close(s);
		 return -1;
	 }
d112 2
a113 5
	 if (connect(s, (struct sockaddr*) &addr, sizeof(addr)) == -1) {
		 warn("connect");
		 close(s);
		 return -1;
	 }
d119 1
a119 1
delivery_lmtp_open(struct deliver *deliver)
d121 21
a141 79
	 char *buffer;
	 char lhloname[255];
	 int s;
	 FILE	*fp;
	 enum lmtp_state state = LMTP_BANNER;
	 size_t sz;
	 ssize_t len;

	 fp = NULL;

	 if (deliver->to[0] == '/')
		 s = unix_socket(deliver->to);
	 else
		 s = inet_socket(deliver->to);

	 if (s == -1 || (fp = fdopen(s, "r+")) == NULL)
		 err(1, "couldn't establish connection");

	 while (!feof(fp) && !ferror(fp) && state != LMTP_BYE) {
		 buffer = lmtp_getline(fp);
		 if (buffer == NULL)
			 err(1, "No input received");

		 switch (state) {
		 case LMTP_BANNER:
			 if (strncmp("220 ", buffer, 4) != 0)
				 errx(1, "Invalid LMTP greeting: %s\n", buffer);
			 gethostname(lhloname, sizeof lhloname );
			 fprintf(fp, "LHLO %s\r\n", lhloname);
			 state = LMTP_LHLO;
			 break;

		 case LMTP_LHLO:
			 if (buffer[0] != '2')
				 errx(1, "LHLO rejected: %s\n", buffer);
			 if (strlen(buffer) < 4)
				 errx(1, "Invalid LMTP LHLO answer: %s\n", buffer);
			 if (buffer[3] == '-')
				 continue; /* multi-line */
			 fprintf(fp, "MAIL FROM:<%s>\r\n", deliver->from);
			 state = LMTP_MAIL_FROM;
			 break;

		 case LMTP_MAIL_FROM:
			 if (buffer[0] != '2')
				 errx(1, "MAIL FROM rejected: %s\n", buffer);
			 fprintf(fp, "RCPT TO:<%s>\r\n", deliver->user);
			 state = LMTP_RCPT_TO;
			 break;

		 case LMTP_RCPT_TO:
			 if (buffer[0] != '2')
				 errx(1, "RCPT TO rejected: %s\n", buffer);
			 fprintf(fp, "DATA\r\n");
			 state = LMTP_DATA;
			 break;

		 case LMTP_DATA:
			 if (buffer[0] != '3')
				 errx(1, "DATA rejected: %s\n", buffer);
			 buffer = NULL;
			 sz = 0;
			 while ((len = getline(&buffer, &sz, stdin)) != -1) {
				 if (buffer[len - 1] == '\n')
					 buffer[len - 1] = '\0';
				 fprintf(fp, "%s%s\r\n",
				     *buffer == '.' ? "." : "", buffer);
			 }
			 free(buffer);
			 fprintf(fp, ".\r\n");
			 state = LMTP_QUIT;
			 break;

		 case LMTP_QUIT:
			 if (buffer[0] != '2')
				 errx(1, "Delivery error: %s\n", buffer);
			 fprintf(fp, "QUIT\r\n");
			 state = LMTP_BYE;
			 break;
d143 19
a161 4
		 default:
			errx(1, "Bogus state %d", state);
		 }
	 }
d163 1
a163 1
	 _exit(0);
d166 2
a167 2
static char*
lmtp_getline(FILE *fp)
d169 23
a191 8
	char   *buffer;
	size_t	len;
	
	if ((buffer = fgetln(fp, &len)) != NULL) {
		if (len >= 2 && buffer[len-2] == '\r')
			buffer[len-2] = '\0';
		buffer[len-1] = '\0';
	}
d193 1
a193 1
	return buffer;
@


1.8
log
@three conversions of fgetln() to getline()

ok eric sunil
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.7 2015/01/20 17:37:54 deraadt Exp $ */
d189 1
a189 1
			 
d196 1
a196 1
			 
@


1.7
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.6 2014/04/19 17:24:59 gilles Exp $ */
a140 1
	 char *lbuf;
d145 2
a146 1
	 size_t	len;
d200 4
a203 3
			 lbuf = NULL;
			 while ((buffer = fgetln(stdin, &len))) {
				 if (buffer[len- 1] == '\n')
a204 7
				 else {
					 if ((lbuf = malloc(len + 1)) == NULL)
						 err(1, NULL);
					 memcpy(lbuf, buffer, len);
					 lbuf[len] = '\0';
					 buffer = lbuf;
				 }
d208 1
a208 1
			 free(lbuf);
@


1.6
log
@replace warnx message
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.5 2014/04/19 11:29:06 gilles Exp $ */
d20 1
a22 1
#include <sys/socket.h>
d31 1
d36 1
@


1.5
log
@when copying socket path, check that we didnt truncate it which would cause
the following connect() to fail.
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.4 2013/12/26 17:25:32 eric Exp $ */
d121 1
a121 1
		 warnx("strlcpy: socket path too long");
@


1.4
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d119 6
a124 1
	 strlcpy(addr.sun_path, path, sizeof(addr.sun_path));
@


1.3
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/* $OpenBSD: delivery_lmtp.c,v 1.2 2013/07/19 08:45:38 eric Exp $ */
d77 1
a77 1
	 bzero(&hints, sizeof(hints));
d111 1
a111 1
	 bzero(&addr, sizeof(addr));
@


1.2
log
@Make sure to report all errors
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d220 1
a220 1
			errx(1, "Bogus state %i", state);
@


1.1
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d70 3
d219 2
a220 2
		 case LMTP_BYE:
			 break;
@

