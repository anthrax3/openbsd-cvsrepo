head	1.195;
access;
symbols
	OPENBSD_6_1:1.195.0.2
	OPENBSD_6_1_BASE:1.195
	OPENBSD_6_0:1.186.0.4
	OPENBSD_6_0_BASE:1.186
	OPENBSD_5_9:1.183.0.2
	OPENBSD_5_9_BASE:1.183
	OPENBSD_5_8:1.152.0.6
	OPENBSD_5_8_BASE:1.152
	OPENBSD_5_7:1.152.0.2
	OPENBSD_5_7_BASE:1.152
	OPENBSD_5_6:1.146.0.4
	OPENBSD_5_6_BASE:1.146
	OPENBSD_5_5:1.137.0.2
	OPENBSD_5_5_BASE:1.137
	OPENBSD_5_4:1.123.0.2
	OPENBSD_5_4_BASE:1.123
	OPENBSD_5_3:1.115.0.2
	OPENBSD_5_3_BASE:1.115
	OPENBSD_5_2:1.89.0.2
	OPENBSD_5_2_BASE:1.89
	OPENBSD_5_1_BASE:1.84
	OPENBSD_5_1:1.84.0.2
	OPENBSD_5_0:1.76.0.2
	OPENBSD_5_0_BASE:1.76
	OPENBSD_4_9:1.72.0.2
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.64.0.2
	OPENBSD_4_8_BASE:1.64
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25;
locks; strict;
comment	@ * @;


1.195
date	2017.02.13.12.43.43;	author gilles;	state Exp;
branches;
next	1.194;
commitid	bSV1055oRPyMgllS;

1.194
date	2017.02.13.12.23.47;	author gilles;	state Exp;
branches;
next	1.193;
commitid	YoNQfVbDQc2kwy0s;

1.193
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.192;
commitid	3AKCl24jEn0sIt6p;

1.192
date	2017.01.05.12.42.19;	author krw;	state Exp;
branches;
next	1.191;
commitid	uzjOUwLRoN7KbcZI;

1.191
date	2016.11.25.09.21.21;	author gilles;	state Exp;
branches;
next	1.190;
commitid	i0WTm5qmEuQnkvJ0;

1.190
date	2016.09.12.07.33.00;	author eric;	state Exp;
branches;
next	1.189;
commitid	MDc6kSdQSkubRdwz;

1.189
date	2016.08.31.15.24.04;	author gilles;	state Exp;
branches;
next	1.188;
commitid	NECHGW1EDKL3apgc;

1.188
date	2016.08.31.10.18.08;	author gilles;	state Exp;
branches;
next	1.187;
commitid	jWkTljYAPNXFatSw;

1.187
date	2016.08.30.21.33.58;	author gilles;	state Exp;
branches;
next	1.186;
commitid	mXpU3sFZFJklKJFq;

1.186
date	2016.07.01.17.53.23;	author eric;	state Exp;
branches;
next	1.185;
commitid	eQAXyof5NBgxe8Jc;

1.185
date	2016.06.21.21.35.25;	author benno;	state Exp;
branches;
next	1.184;
commitid	AL6SnrmnHkmPOpjv;

1.184
date	2016.04.21.14.27.41;	author jsing;	state Exp;
branches;
next	1.183;
commitid	y261bjeJ4UOVSbjW;

1.183
date	2016.02.22.16.19.05;	author gilles;	state Exp;
branches;
next	1.182;
commitid	WZIC0TImRvWEm8e8;

1.182
date	2016.02.13.20.43.07;	author gilles;	state Exp;
branches;
next	1.181;
commitid	qHtqvYWG27YyW9EZ;

1.181
date	2016.01.18.09.19.41;	author jung;	state Exp;
branches;
next	1.180;
commitid	SYgNm3CQLYf2lUE2;

1.180
date	2016.01.12.17.29.43;	author sunil;	state Exp;
branches;
next	1.179;
commitid	bHpUcFTAHFMpObZb;

1.179
date	2016.01.04.13.30.20;	author jung;	state Exp;
branches;
next	1.178;
commitid	CF2whypVOFPTyiTY;

1.178
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.177;
commitid	ZxnqOQqX6IeYI9jW;

1.177
date	2015.12.12.20.02.31;	author gilles;	state Exp;
branches;
next	1.176;
commitid	eO2zB2XyKCWqQLmz;

1.176
date	2015.12.12.18.52.23;	author gilles;	state Exp;
branches;
next	1.175;
commitid	MJxm6PNUCY2TCfGJ;

1.175
date	2015.12.12.18.49.38;	author gilles;	state Exp;
branches;
next	1.174;
commitid	wCM0D96m6r1a6i9q;

1.174
date	2015.12.12.17.16.56;	author gilles;	state Exp;
branches;
next	1.173;
commitid	O1qQ3TEBrjXRGaeN;

1.173
date	2015.12.12.14.44.36;	author gilles;	state Exp;
branches;
next	1.172;
commitid	JjCgsh6C8Jkaso7n;

1.172
date	2015.12.12.12.38.36;	author gilles;	state Exp;
branches;
next	1.171;
commitid	xQLFbTs2E3dblbMB;

1.171
date	2015.12.12.12.34.51;	author gilles;	state Exp;
branches;
next	1.170;
commitid	yUWNMYAP61HQ6eob;

1.170
date	2015.12.12.12.28.04;	author gilles;	state Exp;
branches;
next	1.169;
commitid	oLLIztJ3cKOIKwSi;

1.169
date	2015.12.12.12.22.25;	author gilles;	state Exp;
branches;
next	1.168;
commitid	w98xM5rwyFdbQWM5;

1.168
date	2015.12.12.11.31.29;	author sunil;	state Exp;
branches;
next	1.167;
commitid	xbftp8DyefrEq9pW;

1.167
date	2015.12.12.09.00.22;	author gilles;	state Exp;
branches;
next	1.166;
commitid	fBIblfrnKYx0CCqR;

1.166
date	2015.12.11.08.27.04;	author gilles;	state Exp;
branches;
next	1.165;
commitid	ZiBh0WwWtYRoJDws;

1.165
date	2015.12.11.08.19.03;	author gilles;	state Exp;
branches;
next	1.164;
commitid	Q4cJewVGoX6JuDc6;

1.164
date	2015.12.03.21.11.33;	author jung;	state Exp;
branches;
next	1.163;
commitid	KMDOdtoOlQlcNX1b;

1.163
date	2015.12.02.09.06.36;	author gilles;	state Exp;
branches;
next	1.162;
commitid	dZqYWaTtjiyM5ed2;

1.162
date	2015.12.01.18.22.30;	author gilles;	state Exp;
branches;
next	1.161;
commitid	qHxbKaYfo1Z7mM09;

1.161
date	2015.12.01.15.43.01;	author gilles;	state Exp;
branches;
next	1.160;
commitid	rC1yAjexaYsaDWon;

1.160
date	2015.12.01.10.57.24;	author gilles;	state Exp;
branches;
next	1.159;
commitid	oE5R0jt6kWgoq86d;

1.159
date	2015.12.01.09.33.17;	author gilles;	state Exp;
branches;
next	1.158;
commitid	Y91zLTPzwb4lVNZb;

1.158
date	2015.11.30.14.13.03;	author gilles;	state Exp;
branches;
next	1.157;
commitid	uzQcYiSR90ELNfI7;

1.157
date	2015.11.30.12.26.55;	author sunil;	state Exp;
branches;
next	1.156;
commitid	aGcPak9vEg5kOQ24;

1.156
date	2015.11.05.12.35.58;	author jung;	state Exp;
branches;
next	1.155;
commitid	jasZAz9nQhjiEdTD;

1.155
date	2015.10.27.21.20.11;	author jung;	state Exp;
branches;
next	1.154;
commitid	YRcUZhsvrsRgoY3W;

1.154
date	2015.09.07.15.36.53;	author gilles;	state Exp;
branches;
next	1.153;
commitid	8taqn8BdlYqlAC0r;

1.153
date	2015.08.19.16.14.54;	author deraadt;	state Exp;
branches;
next	1.152;
commitid	AiiFoP3moZa72JE5;

1.152
date	2015.02.08.04.50.32;	author reyk;	state Exp;
branches;
next	1.151;
commitid	jVCsun3nRn9HXgv1;

1.151
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.150;
commitid	ZBTFreARDSMmzOIV;

1.150
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.149;
commitid	Uu5nFG3wCl0LACBb;

1.149
date	2014.11.20.05.51.21;	author jsg;	state Exp;
branches;
next	1.148;
commitid	3Z7yItGpFsmshk0c;

1.148
date	2014.11.16.19.07.50;	author bluhm;	state Exp;
branches;
next	1.147;
commitid	ohVlnYugDUFcNu2w;

1.147
date	2014.11.14.03.20.37;	author doug;	state Exp;
branches;
next	1.146;
commitid	M08zdkdK3z1pxKwF;

1.146
date	2014.07.09.12.44.54;	author eric;	state Exp;
branches;
next	1.145;
commitid	4IcOkOZNwhQIYGGx;

1.145
date	2014.07.09.09.53.37;	author eric;	state Exp;
branches;
next	1.144;
commitid	RHRCVJhvTqNHZi7Q;

1.144
date	2014.07.08.21.58.33;	author eric;	state Exp;
branches;
next	1.143;
commitid	AEY7C0r4blCyV4nd;

1.143
date	2014.04.19.17.23.19;	author gilles;	state Exp;
branches;
next	1.142;

1.142
date	2014.04.19.17.21.19;	author gilles;	state Exp;
branches;
next	1.141;

1.141
date	2014.04.19.17.18.58;	author gilles;	state Exp;
branches;
next	1.140;

1.140
date	2014.04.19.17.12.02;	author gilles;	state Exp;
branches;
next	1.139;

1.139
date	2014.04.19.17.08.49;	author gilles;	state Exp;
branches;
next	1.138;

1.138
date	2014.03.25.10.28.58;	author gilles;	state Exp;
branches;
next	1.137;

1.137
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.136;

1.136
date	2014.01.22.00.21.17;	author henning;	state Exp;
branches;
next	1.135;

1.135
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.134;

1.134
date	2013.12.05.15.04.09;	author eric;	state Exp;
branches;
next	1.133;

1.133
date	2013.11.30.10.11.57;	author eric;	state Exp;
branches;
next	1.132;

1.132
date	2013.11.28.13.13.56;	author eric;	state Exp;
branches;
next	1.131;

1.131
date	2013.11.25.19.17.07;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2013.11.21.08.52.57;	author eric;	state Exp;
branches;
next	1.129;

1.129
date	2013.11.20.09.22.42;	author eric;	state Exp;
branches;
next	1.128;

1.128
date	2013.11.19.10.01.20;	author eric;	state Exp;
branches;
next	1.127;

1.127
date	2013.11.13.08.39.33;	author eric;	state Exp;
branches;
next	1.126;

1.126
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.125;

1.125
date	2013.10.27.11.01.47;	author eric;	state Exp;
branches;
next	1.124;

1.124
date	2013.10.25.21.31.23;	author eric;	state Exp;
branches;
next	1.123;

1.123
date	2013.07.19.21.14.52;	author eric;	state Exp;
branches;
next	1.122;

1.122
date	2013.07.19.20.37.07;	author eric;	state Exp;
branches;
next	1.121;

1.121
date	2013.07.19.19.53.33;	author eric;	state Exp;
branches;
next	1.120;

1.120
date	2013.07.19.19.10.22;	author eric;	state Exp;
branches;
next	1.119;

1.119
date	2013.07.19.13.11.18;	author eric;	state Exp;
branches;
next	1.118;

1.118
date	2013.06.03.08.48.40;	author zhuk;	state Exp;
branches;
next	1.117;

1.117
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.116;

1.116
date	2013.03.06.21.42.40;	author sthen;	state Exp;
branches;
next	1.115;

1.115
date	2013.02.17.12.28.30;	author gilles;	state Exp;
branches;
next	1.114;

1.114
date	2013.02.14.12.30.49;	author gilles;	state Exp;
branches;
next	1.113;

1.113
date	2013.02.05.15.30.59;	author gilles;	state Exp;
branches;
next	1.112;

1.112
date	2013.01.28.15.14.02;	author gilles;	state Exp;
branches;
next	1.111;

1.111
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.110;

1.110
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.109;

1.109
date	2012.10.14.11.58.23;	author gilles;	state Exp;
branches;
next	1.108;

1.108
date	2012.10.11.21.14.32;	author gilles;	state Exp;
branches;
next	1.107;

1.107
date	2012.10.09.20.33.02;	author gilles;	state Exp;
branches;
next	1.106;

1.106
date	2012.10.08.20.35.16;	author gilles;	state Exp;
branches;
next	1.105;

1.105
date	2012.10.04.19.49.53;	author gilles;	state Exp;
branches;
next	1.104;

1.104
date	2012.09.30.17.25.09;	author chl;	state Exp;
branches;
next	1.103;

1.103
date	2012.09.30.14.28.16;	author gilles;	state Exp;
branches;
next	1.102;

1.102
date	2012.09.29.10.32.08;	author eric;	state Exp;
branches;
next	1.101;

1.101
date	2012.09.26.09.49.43;	author halex;	state Exp;
branches;
next	1.100;

1.100
date	2012.09.17.20.19.18;	author eric;	state Exp;
branches;
next	1.99;

1.99
date	2012.09.15.15.12.11;	author eric;	state Exp;
branches;
next	1.98;

1.98
date	2012.09.08.13.58.29;	author chl;	state Exp;
branches;
next	1.97;

1.97
date	2012.09.01.16.09.14;	author gilles;	state Exp;
branches;
next	1.96;

1.96
date	2012.08.30.18.25.44;	author gilles;	state Exp;
branches;
next	1.95;

1.95
date	2012.08.29.18.36.24;	author naddy;	state Exp;
branches;
next	1.94;

1.94
date	2012.08.29.16.26.17;	author gilles;	state Exp;
branches;
next	1.93;

1.93
date	2012.08.26.13.38.43;	author gilles;	state Exp;
branches;
next	1.92;

1.92
date	2012.08.25.23.35.09;	author chl;	state Exp;
branches;
next	1.91;

1.91
date	2012.08.21.20.19.46;	author eric;	state Exp;
branches;
next	1.90;

1.90
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.89;

1.89
date	2012.07.08.15.48.00;	author gilles;	state Exp;
branches;
next	1.88;

1.88
date	2012.05.13.00.10.49;	author gilles;	state Exp;
branches;
next	1.87;

1.87
date	2012.05.12.21.49.31;	author gilles;	state Exp;
branches;
next	1.86;

1.86
date	2012.05.12.18.41.10;	author gilles;	state Exp;
branches;
next	1.85;

1.85
date	2012.04.16.13.32.16;	author chl;	state Exp;
branches;
next	1.84;

1.84
date	2011.12.13.21.44.47;	author gilles;	state Exp;
branches;
next	1.83;

1.83
date	2011.12.08.17.04.19;	author todd;	state Exp;
branches;
next	1.82;

1.82
date	2011.10.27.14.32.57;	author chl;	state Exp;
branches;
next	1.81;

1.81
date	2011.10.23.15.36.53;	author eric;	state Exp;
branches;
next	1.80;

1.80
date	2011.09.01.16.23.33;	author chl;	state Exp;
branches;
next	1.79;

1.79
date	2011.09.01.09.42.15;	author chl;	state Exp;
branches;
next	1.78;

1.78
date	2011.08.31.18.56.30;	author gilles;	state Exp;
branches;
next	1.77;

1.77
date	2011.08.27.22.32.41;	author gilles;	state Exp;
branches;
next	1.76;

1.76
date	2011.06.09.17.41.52;	author gilles;	state Exp;
branches;
next	1.75;

1.75
date	2011.05.22.21.03.14;	author gilles;	state Exp;
branches;
next	1.74;

1.74
date	2011.05.21.16.58.04;	author gilles;	state Exp;
branches;
next	1.73;

1.73
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.72;

1.72
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.71;

1.71
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.70;

1.70
date	2010.10.29.09.16.08;	author gilles;	state Exp;
branches;
next	1.69;

1.69
date	2010.10.28.21.15.50;	author gilles;	state Exp;
branches;
next	1.68;

1.68
date	2010.10.18.13.28.00;	author sthen;	state Exp;
branches;
next	1.67;

1.67
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.66;

1.66
date	2010.09.20.09.01.09;	author gilles;	state Exp;
branches;
next	1.65;

1.65
date	2010.09.08.23.32.27;	author gilles;	state Exp;
branches;
next	1.64;

1.64
date	2010.08.03.18.42.41;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2010.06.10.19.34.51;	author chl;	state Exp;
branches;
next	1.62;

1.62
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.61;

1.61
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.60;

1.60
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.59;

1.59
date	2010.05.27.15.36.04;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2010.05.27.11.17.29;	author gilles;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.19.20.57.10;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2010.04.27.10.17.53;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2010.04.20.18.55.01;	author jacekm;	state Exp;
branches;
next	1.54;

1.54
date	2010.04.20.11.03.05;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.19.14.37.33;	author gilles;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.19.10.12.48;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2010.02.26.15.06.39;	author gilles;	state Exp;
branches;
next	1.50;

1.50
date	2009.12.10.14.57.51;	author jacekm;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.06.00.27.31;	author jacekm;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.05.18.42.31;	author chl;	state Exp;
branches;
next	1.47;

1.47
date	2009.11.12.12.35.03;	author jacekm;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.05.12.24.13;	author gilles;	state Exp;
branches;
next	1.45;

1.45
date	2009.11.03.22.57.41;	author gilles;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.03.20.55.23;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.19.21.09.55;	author gilles;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.19.20.48.13;	author gilles;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.19.20.00.46;	author gilles;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.11.17.40.49;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.16.20.22.18;	author jacekm;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.05.23.04.51;	author jacekm;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.02.22.23.35;	author gilles;	state Exp;
branches;
next	1.36;

1.36
date	2009.05.30.23.53.41;	author gilles;	state Exp;
branches;
next	1.35;

1.35
date	2009.05.27.16.51.26;	author jacekm;	state Exp;
branches;
next	1.34;

1.34
date	2009.05.21.01.27.48;	author gilles;	state Exp;
branches;
next	1.33;

1.33
date	2009.05.20.14.29.44;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2009.04.12.16.03.01;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2009.04.09.19.49.34;	author jacekm;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.31.21.03.49;	author tobias;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.19.00.40.34;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2009.03.16.23.26.40;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.09.01.43.19;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.08.21.50.33;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.30.10.09.58;	author form;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.28.21.44.15;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.14.23.36.52;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.04.16.40.58;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.20.00.18.03;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.18.22.13.57;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.11.23.19.00;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.11.23.06.39;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.10.23.04.24;	author jacekm;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.06.14.23.47;	author jacekm;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.06.02.04.56;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.04.17.24.13;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.04.00.10.15;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.25.20.26.40;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.22.20.26.08;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.13.23.24.19;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.10.22.35.23;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.10.17.24.24;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.10.02.13.40;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.10.00.57.35;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.10.00.29.33;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.01.21.41.53;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.195
log
@fix incoming tls-require regression, introduced with last parse.y cleanup
causing the flag not to be propagated down to the listener

ok eric@@
@
text
@/*	$OpenBSD: parse.y,v 1.194 2017/02/13 12:23:47 gilles Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <ifaddrs.h>
#include <imsg.h>
#include <inttypes.h>
#include <limits.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <util.h>

#include <openssl/ssl.h>

#include "smtpd.h"
#include "ssl.h"
#include "log.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

struct smtpd		*conf = NULL;
static int		 errors = 0;
static uint64_t		 ruleid = 0;

struct filter_conf	*filter = NULL;
struct table		*table = NULL;
struct rule		*rule = NULL;
struct mta_limits	*limits;
static struct pki	*pki;
static struct ca	*sca;

enum listen_options {
	LO_FAMILY	= 0x000001,
	LO_PORT		= 0x000002,
	LO_SSL		= 0x000004,
	LO_FILTER      	= 0x000008,
	LO_PKI      	= 0x000010,
	LO_AUTH      	= 0x000020,
	LO_TAG      	= 0x000040,
	LO_HOSTNAME   	= 0x000080,
	LO_HOSTNAMES   	= 0x000100,
	LO_MASKSOURCE  	= 0x000200,
	LO_NODSN	= 0x000400,
	LO_SENDERS	= 0x000800,
	LO_RECEIVEDAUTH = 0x001000,
	LO_MASQUERADE	= 0x002000,
	LO_CA		= 0x010000
};

static struct listen_opts {
	char	       *ifx;
	int		family;
	in_port_t	port;
	uint16_t	ssl;
	char	       *filtername;
	char	       *pki;
	char	       *ca;
	uint16_t       	auth;
	struct table   *authtable;
	char	       *tag;
	char	       *hostname;
	struct table   *hostnametable;
	struct table   *sendertable;
	uint16_t	flags;

	uint32_t       	options;
} listen_opts;

static void	create_sock_listener(struct listen_opts *);
static void	create_if_listener(struct listen_opts *);
static void	config_listener(struct listener *, struct listen_opts *);
static int	host_v4(struct listen_opts *);
static int	host_v6(struct listen_opts *);
static int	host_dns(struct listen_opts *);
static int	interface(struct listen_opts *);

void		 set_local(const char *);
void		 set_localaddrs(struct table *);
int		 delaytonum(char *);
int		 is_if_in_group(const char *, const char *);

static struct filter_conf *create_filter_proc(char *, char *);
static struct filter_conf *create_filter_chain(char *);
static int add_filter_arg(struct filter_conf *, char *);

static int config_lo_filter(struct listen_opts *, char *);
static int config_lo_mask_source(struct listen_opts *);

typedef struct {
	union {
		int64_t		 number;
		struct table	*table;
		char		*string;
		struct host	*host;
		struct mailaddr	*maddr;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	AS QUEUE COMPRESSION ENCRYPTION MAXMESSAGESIZE MAXMTADEFERRED LISTEN ON ANY PORT EXPIRE
%token	TABLE SECURE SMTPS CERTIFICATE DOMAIN BOUNCEWARN LIMIT INET4 INET6 NODSN SESSION
%token  RELAY BACKUP VIA DELIVER TO LMTP MAILDIR MBOX RCPTTO HOSTNAME HOSTNAMES
%token	ACCEPT REJECT INCLUDE ERROR MDA FROM FOR SOURCE MTA PKI SCHEDULER
%token	ARROW AUTH TLS LOCAL VIRTUAL TAG TAGGED ALIAS FILTER KEY CA DHE
%token	AUTH_OPTIONAL TLS_REQUIRE USERBASE SENDER SENDERS MASK_SOURCE VERIFY FORWARDONLY RECIPIENT
%token	CIPHERS RECEIVEDAUTH MASQUERADE SOCKET SUBADDRESSING_DELIM AUTHENTICATED
%token	<v.string>	STRING
%token  <v.number>	NUMBER
%type	<v.table>	table
%type	<v.number>	size negation
%type	<v.table>	tables tablenew tableref alias virtual userbase
%type	<v.string>	tagged
%%

grammar		: /* empty */
		| grammar '\n'
		| grammar include '\n'
		| grammar varset '\n'
		| grammar main '\n'
		| grammar table '\n'
		| grammar rule '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 0)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

varset		: STRING '=' STRING		{
			char *s = $1;
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

comma		: ','
		| nl
		| /* empty */
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl
		;

size		: NUMBER		{
			if ($1 < 0) {
				yyerror("invalid size: %" PRId64, $1);
				YYERROR;
			}
			$$ = $1;
		}
		| STRING			{
			long long result;

			if (scan_scaled($1, &result) == -1 || result < 0) {
				yyerror("invalid size: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			$$ = result;
		}
		;

tagged		: TAGGED negation STRING       		{
			if (strlcpy(rule->r_tag, $3, sizeof rule->r_tag)
			    >= sizeof rule->r_tag) {
				yyerror("tag name too long: %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
			rule->r_nottag = $2;
		}
		;

authenticated  	: negation AUTHENTICATED	{
			rule->r_wantauth = 1;
			rule->r_negwantauth = $1;
		}
		;

bouncedelay	: STRING {
			time_t	d;
			int	i;

			d = delaytonum($1);
			if (d < 0) {
				yyerror("invalid bounce delay: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			for (i = 0; i < MAX_BOUNCE_WARN; i++) {
				if (conf->sc_bounce_warn[i] != 0)
					continue;
				conf->sc_bounce_warn[i] = d;
				break;
			}
		}

bouncedelays	: bouncedelays ',' bouncedelay
		| bouncedelay
		| /* EMPTY */
		;

opt_limit_mda	: STRING NUMBER {
			if (!strcmp($1, "max-session")) {
				conf->sc_mda_max_session = $2;
			}
			else if (!strcmp($1, "max-session-per-user")) {
				conf->sc_mda_max_user_session = $2;
			}
			else if (!strcmp($1, "task-lowat")) {
				conf->sc_mda_task_lowat = $2;
			}
			else if (!strcmp($1, "task-hiwat")) {
				conf->sc_mda_task_hiwat = $2;
			}
			else if (!strcmp($1, "task-release")) {
				conf->sc_mda_task_release = $2;
			}
			else {
				yyerror("invalid scheduler limit keyword: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

limits_session	: opt_limit_session limits_session
		| /* empty */
		;

opt_limit_session : STRING NUMBER {
			if (!strcmp($1, "max-rcpt")) {
				conf->sc_session_max_rcpt = $2;
			}
			else if (!strcmp($1, "max-mails")) {
				conf->sc_session_max_mails = $2;
			}
			else {
				yyerror("invalid session limit keyword: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

limits_mda	: opt_limit_mda limits_mda
		| /* empty */
		;

opt_limit_mta	: INET4 {
			limits->family = AF_INET;
		}
		| INET6 {
			limits->family = AF_INET6;
		}
		| STRING NUMBER {
			if (!limit_mta_set(limits, $1, $2)) {
				yyerror("invalid mta limit keyword: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

limits_mta	: opt_limit_mta limits_mta
		| /* empty */
		;

opt_limit_scheduler : STRING NUMBER {
			if (!strcmp($1, "max-inflight")) {
				conf->sc_scheduler_max_inflight = $2;
			}
			else if (!strcmp($1, "max-evp-batch-size")) {
				conf->sc_scheduler_max_evp_batch_size = $2;
			}
			else if (!strcmp($1, "max-msg-batch-size")) {
				conf->sc_scheduler_max_msg_batch_size = $2;
			}
			else if (!strcmp($1, "max-schedule")) {
				conf->sc_scheduler_max_schedule = $2;
			}
			else {
				yyerror("invalid scheduler limit keyword: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

limits_scheduler: opt_limit_scheduler limits_scheduler
		| /* empty */
		;

opt_ca		: CERTIFICATE STRING {
			sca->ca_cert_file = $2;
		}
		;

ca		: opt_ca
		;

opt_pki		: CERTIFICATE STRING {
			pki->pki_cert_file = $2;
		}
		| KEY STRING {
			pki->pki_key_file = $2;
		}
		| DHE STRING {
			if (strcasecmp($2, "none") == 0)
				pki->pki_dhe = 0;
			else if (strcasecmp($2, "auto") == 0)
				pki->pki_dhe = 1;
			else if (strcasecmp($2, "legacy") == 0)
				pki->pki_dhe = 2;
			else {
				yyerror("invalid DHE keyword: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

pki		: opt_pki pki
		| /* empty */
		;

opt_sock_listen : FILTER STRING {
			if (config_lo_filter(&listen_opts, $2)) {
				YYERROR;
			}
		}
		| MASK_SOURCE {
			if (config_lo_mask_source(&listen_opts)) {
				YYERROR;
			}
		}
		;

opt_if_listen : INET4 {
			if (listen_opts.options & LO_FAMILY) {
				yyerror("address family already specified");
				YYERROR;
			}
			listen_opts.options |= LO_FAMILY;
			listen_opts.family = AF_INET;
		}
		| INET6			{
			if (listen_opts.options & LO_FAMILY) {
				yyerror("address family already specified");
				YYERROR;
			}
			listen_opts.options |= LO_FAMILY;
			listen_opts.family = AF_INET6;
		}
		| PORT STRING			{
			struct servent	*servent;

			if (listen_opts.options & LO_PORT) {
				yyerror("port already specified");
				YYERROR;
			}
			listen_opts.options |= LO_PORT;

			servent = getservbyname($2, "tcp");
			if (servent == NULL) {
				yyerror("invalid port: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
			listen_opts.port = ntohs(servent->s_port);
		}
		| PORT NUMBER			{
			if (listen_opts.options & LO_PORT) {
				yyerror("port already specified");
				YYERROR;
			}
			listen_opts.options |= LO_PORT;

			if ($2 <= 0 || $2 >= (int)USHRT_MAX) {
				yyerror("invalid port: %" PRId64, $2);
				YYERROR;
			}
			listen_opts.port = $2;
		}
		| FILTER STRING			{
			if (config_lo_filter(&listen_opts, $2)) {
				YYERROR;
			}
		}
		| SMTPS				{
			if (listen_opts.options & LO_SSL) {
				yyerror("TLS mode already specified");
				YYERROR;
			}
			listen_opts.options |= LO_SSL;
			listen_opts.ssl = F_SMTPS;
		}
		| SMTPS VERIFY 			{
			if (listen_opts.options & LO_SSL) {
				yyerror("TLS mode already specified");
				YYERROR;
			}
			listen_opts.options |= LO_SSL;
			listen_opts.ssl = F_SMTPS|F_TLS_VERIFY;
		}
		| TLS				{
			if (listen_opts.options & LO_SSL) {
				yyerror("TLS mode already specified");
				YYERROR;
			}
			listen_opts.options |= LO_SSL;
			listen_opts.ssl = F_STARTTLS;
		}
		| SECURE       			{
			if (listen_opts.options & LO_SSL) {
				yyerror("TLS mode already specified");
				YYERROR;
			}
			listen_opts.options |= LO_SSL;
			listen_opts.ssl = F_SSL;
		}
		| TLS_REQUIRE			{
			if (listen_opts.options & LO_SSL) {
				yyerror("TLS mode already specified");
				YYERROR;
			}
			listen_opts.options |= LO_SSL;
			listen_opts.ssl = F_STARTTLS|F_STARTTLS_REQUIRE;
		}
		| TLS_REQUIRE VERIFY   		{
			if (listen_opts.options & LO_SSL) {
				yyerror("TLS mode already specified");
				YYERROR;
			}
			listen_opts.options |= LO_SSL;
			listen_opts.ssl = F_STARTTLS|F_STARTTLS_REQUIRE|F_TLS_VERIFY;
		}
		| PKI STRING			{
			if (listen_opts.options & LO_PKI) {
				yyerror("pki already specified");
				YYERROR;
			}
			listen_opts.options |= LO_PKI;
			listen_opts.pki = $2;
		}
		| CA STRING			{
			if (listen_opts.options & LO_CA) {
				yyerror("ca already specified");
				YYERROR;
			}
			listen_opts.options |= LO_CA;
			listen_opts.ca = $2;
		}
		| AUTH				{
			if (listen_opts.options & LO_AUTH) {
				yyerror("auth already specified");
				YYERROR;
			}
			listen_opts.options |= LO_AUTH;
			listen_opts.auth = F_AUTH|F_AUTH_REQUIRE;
		}
		| AUTH_OPTIONAL			{
			if (listen_opts.options & LO_AUTH) {
				yyerror("auth already specified");
				YYERROR;
			}
			listen_opts.options |= LO_AUTH;
			listen_opts.auth = F_AUTH;
		}
		| AUTH tables  			{
			if (listen_opts.options & LO_AUTH) {
				yyerror("auth already specified");
				YYERROR;
			}
			listen_opts.options |= LO_AUTH;
			listen_opts.authtable = $2;
			listen_opts.auth = F_AUTH|F_AUTH_REQUIRE;
		}
		| AUTH_OPTIONAL tables 		{
			if (listen_opts.options & LO_AUTH) {
				yyerror("auth already specified");
				YYERROR;
			}
			listen_opts.options |= LO_AUTH;
			listen_opts.authtable = $2;
			listen_opts.auth = F_AUTH;
		}
		| TAG STRING			{
			if (listen_opts.options & LO_TAG) {
				yyerror("tag already specified");
				YYERROR;
			}
			listen_opts.options |= LO_TAG;

			if (strlen($2) >= SMTPD_TAG_SIZE) {
       				yyerror("tag name too long");
				free($2);
				YYERROR;
			}
			listen_opts.tag = $2;
		}
		| HOSTNAME STRING	{
			if (listen_opts.options & LO_HOSTNAME) {
				yyerror("hostname already specified");
				YYERROR;
			}
			listen_opts.options |= LO_HOSTNAME;

			listen_opts.hostname = $2;
		}
		| HOSTNAMES tables	{
			struct table	*t = $2;

			if (listen_opts.options & LO_HOSTNAMES) {
				yyerror("hostnames already specified");
				YYERROR;
			}
			listen_opts.options |= LO_HOSTNAMES;

			if (!table_check_use(t, T_DYNAMIC|T_HASH, K_ADDRNAME)) {
				yyerror("invalid use of table \"%s\" as "
				    "HOSTNAMES parameter", t->t_name);
				YYERROR;
			}
			listen_opts.hostnametable = t;
		}
		| MASK_SOURCE	{
			if (config_lo_mask_source(&listen_opts)) {
				YYERROR;
			}
		}
		| RECEIVEDAUTH	{
			if (listen_opts.options & LO_RECEIVEDAUTH) {
				yyerror("received-auth already specified");
				YYERROR;
			}
			listen_opts.options |= LO_RECEIVEDAUTH;
			listen_opts.flags |= F_RECEIVEDAUTH;
		}
		| NODSN	{
			if (listen_opts.options & LO_NODSN) {
				yyerror("no-dsn already specified");
				YYERROR;
			}
			listen_opts.options |= LO_NODSN;
			listen_opts.flags &= ~F_EXT_DSN;
		}
		| SENDERS tables	{
			struct table	*t = $2;

			if (listen_opts.options & LO_SENDERS) {
				yyerror("senders already specified");
				YYERROR;
			}
			listen_opts.options |= LO_SENDERS;

			if (!table_check_use(t, T_DYNAMIC|T_HASH, K_MAILADDRMAP)) {
				yyerror("invalid use of table \"%s\" as "
				    "SENDERS parameter", t->t_name);
				YYERROR;
			}
			listen_opts.sendertable = t;
		}
		| SENDERS tables MASQUERADE	{
			struct table	*t = $2;

			if (listen_opts.options & LO_SENDERS) {
				yyerror("senders already specified");
				YYERROR;
			}
			listen_opts.options |= LO_SENDERS|LO_MASQUERADE;

			if (!table_check_use(t, T_DYNAMIC|T_HASH, K_MAILADDRMAP)) {
				yyerror("invalid use of table \"%s\" as "
				    "SENDERS parameter", t->t_name);
				YYERROR;
			}
			listen_opts.sendertable = t;
		}
		;

listener_type	: socket_listener
		| if_listener
		;

socket_listener	: SOCKET sock_listen {
			if (conf->sc_sock_listener) {
				yyerror("socket listener already configured");
				YYERROR;
			}
			create_sock_listener(&listen_opts);
		}
		;

if_listener	: STRING if_listen {
			listen_opts.ifx = $1;
			create_if_listener(&listen_opts);
		}
		;

sock_listen	: opt_sock_listen sock_listen
		| /* empty */
		;

if_listen	: opt_if_listen if_listen
		| /* empty */
		;

opt_relay_common: AS STRING	{
			struct mailaddr maddr, *maddrp;

			if (!text_to_mailaddr(&maddr, $2)) {
				yyerror("invalid parameter to AS: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			if (maddr.user[0] == '\0' && maddr.domain[0] == '\0') {
				yyerror("invalid empty parameter to AS");
				YYERROR;
			}
			else if (maddr.domain[0] == '\0') {
				if (strlcpy(maddr.domain, conf->sc_hostname,
					sizeof (maddr.domain))
				    >= sizeof (maddr.domain)) {
					yyerror("hostname too long for AS parameter: %s",
					    conf->sc_hostname);
					YYERROR;
				}
			}
			rule->r_as = xmemdup(&maddr, sizeof (*maddrp), "parse relay_as: AS");
		}
		| SOURCE tables			{
			struct table	*t = $2;
			if (!table_check_use(t, T_DYNAMIC|T_LIST, K_SOURCE)) {
				yyerror("invalid use of table \"%s\" as "
				    "SOURCE parameter", t->t_name);
				YYERROR;
			}
			(void)strlcpy(rule->r_value.relayhost.sourcetable, t->t_name,
			    sizeof rule->r_value.relayhost.sourcetable);
		}
		| HOSTNAME STRING {
			(void)strlcpy(rule->r_value.relayhost.heloname, $2,
			    sizeof rule->r_value.relayhost.heloname);
			free($2);
		}
		| HOSTNAMES tables		{
			struct table	*t = $2;
			if (!table_check_use(t, T_DYNAMIC|T_HASH, K_ADDRNAME)) {
				yyerror("invalid use of table \"%s\" as "
				    "HOSTNAMES parameter", t->t_name);
				YYERROR;
			}
			(void)strlcpy(rule->r_value.relayhost.helotable, t->t_name,
			    sizeof rule->r_value.relayhost.helotable);
		}
		| PKI STRING {
			if (!lowercase(rule->r_value.relayhost.pki_name, $2,
				sizeof(rule->r_value.relayhost.pki_name))) {
				yyerror("pki name too long: %s", $2);
				free($2);
				YYERROR;
			}
			if (dict_get(conf->sc_pki_dict,
				rule->r_value.relayhost.pki_name) == NULL) {
				log_warnx("pki name not found: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		| CA STRING {
			if (!lowercase(rule->r_value.relayhost.ca_name, $2,
				sizeof(rule->r_value.relayhost.ca_name))) {
				yyerror("ca name too long: %s", $2);
				free($2);
				YYERROR;
			}
			if (dict_get(conf->sc_ca_dict,
				rule->r_value.relayhost.ca_name) == NULL) {
				log_warnx("ca name not found: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

opt_relay	: BACKUP STRING			{
			rule->r_value.relayhost.flags |= F_BACKUP;
			if (strlcpy(rule->r_value.relayhost.hostname, $2,
				sizeof (rule->r_value.relayhost.hostname))
			    >= sizeof (rule->r_value.relayhost.hostname)) {
				log_warnx("hostname too long: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		| BACKUP       			{
			rule->r_value.relayhost.flags |= F_BACKUP;
			(void)strlcpy(rule->r_value.relayhost.hostname,
			    conf->sc_hostname,
			    sizeof (rule->r_value.relayhost.hostname));
		}
		| TLS       			{
			rule->r_value.relayhost.flags |= F_STARTTLS;
		}
		| TLS VERIFY			{
			rule->r_value.relayhost.flags |= F_STARTTLS|F_TLS_VERIFY;
		}
		;

relay		: opt_relay_common relay
		| opt_relay relay
		| /* empty */
		;

opt_relay_via	: AUTH tables {
			struct table   *t = $2;

			if (!table_check_use(t, T_DYNAMIC|T_HASH, K_CREDENTIALS)) {
				yyerror("invalid use of table \"%s\" as AUTH parameter",
				    t->t_name);
				YYERROR;
			}
			(void)strlcpy(rule->r_value.relayhost.authtable, t->t_name,
			    sizeof(rule->r_value.relayhost.authtable));
		}
		| VERIFY {
			if (!(rule->r_value.relayhost.flags & F_SSL)) {
				yyerror("cannot \"verify\" with insecure protocol");
				YYERROR;
			}
			rule->r_value.relayhost.flags |= F_TLS_VERIFY;
		}
		;

relay_via	: opt_relay_common relay_via
		| opt_relay_via relay_via
		| /* empty */
		;

main		: BOUNCEWARN {
			memset(conf->sc_bounce_warn, 0, sizeof conf->sc_bounce_warn);
		} bouncedelays
		| SUBADDRESSING_DELIM STRING {
			if (strlen($2) != 1) {
				yyerror("subaddressing-delimiter must be one character");
				free($2);
				YYERROR;
			}

			if (isspace((int)*$2) ||  !isprint((int)*$2) || *$2== '@@') {
				yyerror("subaddressing-delimiter uses invalid character");
				free($2);
				YYERROR;
			}

			conf->sc_subaddressing_delim = $2;
		}
		| QUEUE COMPRESSION {
			conf->sc_queue_flags |= QUEUE_COMPRESSION;
		}
		| QUEUE ENCRYPTION {
			conf->sc_queue_flags |= QUEUE_ENCRYPTION;
		}
		| QUEUE ENCRYPTION KEY STRING {
			if (strcasecmp($4, "stdin") == 0 || strcasecmp($4, "-") == 0) {
				conf->sc_queue_key = "stdin";
				free($4);
			}
			else
				conf->sc_queue_key = $4;
			conf->sc_queue_flags |= QUEUE_ENCRYPTION;
		}
		| EXPIRE STRING {
			conf->sc_qexpire = delaytonum($2);
			if (conf->sc_qexpire == -1) {
				yyerror("invalid expire delay: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		| MAXMESSAGESIZE size {
			conf->sc_maxsize = $2;
		}
		| MAXMTADEFERRED NUMBER  {
			conf->sc_mta_max_deferred = $2;
		}
		| LIMIT SESSION limits_session
		| LIMIT MDA limits_mda
		| LIMIT MTA FOR DOMAIN STRING {
			struct mta_limits	*d;

			limits = dict_get(conf->sc_limits_dict, $5);
			if (limits == NULL) {
				limits = xcalloc(1, sizeof(*limits), "mta_limits");
				dict_xset(conf->sc_limits_dict, $5, limits);
				d = dict_xget(conf->sc_limits_dict, "default");
				memmove(limits, d, sizeof(*limits));
			}
			free($5);
		} limits_mta
		| LIMIT MTA {
			limits = dict_get(conf->sc_limits_dict, "default");
		} limits_mta
		| LIMIT SCHEDULER limits_scheduler
		| LISTEN {
			memset(&listen_opts, 0, sizeof listen_opts);
			listen_opts.family = AF_UNSPEC;
			listen_opts.flags |= F_EXT_DSN;
		} ON listener_type
		| FILTER STRING STRING {
			if (!strcmp($3, "chain")) {
				free($3);
				if ((filter = create_filter_chain($2)) == NULL) {
					free($2);
					YYERROR;
				}
			}
			else {
				if ((filter = create_filter_proc($2, $3)) == NULL) {
					free($2);
					free($3);
					YYERROR;
				}
			}
		} filter_args
		| PKI STRING	{
			char buf[HOST_NAME_MAX+1];

			/* if not catchall, check that it is a valid domain */
			if (strcmp($2, "*") != 0) {
				if (!res_hnok($2)) {
					yyerror("not a valid domain name: %s", $2);
					free($2);
					YYERROR;
				}
			}
			xlowercase(buf, $2, sizeof(buf));
			free($2);
			pki = dict_get(conf->sc_pki_dict, buf);
			if (pki == NULL) {
				pki = xcalloc(1, sizeof *pki, "parse:pki");
				(void)strlcpy(pki->pki_name, buf, sizeof(pki->pki_name));
				dict_set(conf->sc_pki_dict, pki->pki_name, pki);
			}
		} pki
		| CA STRING	{
			char buf[HOST_NAME_MAX+1];

			/* if not catchall, check that it is a valid domain */
			if (strcmp($2, "*") != 0) {
				if (!res_hnok($2)) {
					yyerror("not a valid domain name: %s", $2);
					free($2);
					YYERROR;
				}
			}
			xlowercase(buf, $2, sizeof(buf));
			free($2);
			sca = dict_get(conf->sc_ca_dict, buf);
			if (sca == NULL) {
				sca = xcalloc(1, sizeof *sca, "parse:ca");
				(void)strlcpy(sca->ca_name, buf, sizeof(sca->ca_name));
				dict_set(conf->sc_ca_dict, sca->ca_name, sca);
			}
		} ca
		| CIPHERS STRING {
			conf->sc_tls_ciphers = $2;
		}
		;

filter_args	:
		| STRING {
			if (!add_filter_arg(filter, $1)) {
				free($1);
				YYERROR;
			}
		} filter_args
		;

table		: TABLE STRING STRING	{
			char *p, *backend, *config;

			p = $3;
			if (*p == '/') {
				backend = "static";
				config = $3;
			}
			else {
				backend = $3;
				config = NULL;
				for (p = $3; *p && *p != ':'; p++)
					;
				if (*p == ':') {
					*p = '\0';
					backend = $3;
					config  = p+1;
				}
			}
			if (config != NULL && *config != '/') {
				yyerror("invalid backend parameter for table: %s",
				    $2);
				free($2);
				free($3);
				YYERROR;
			}
			table = table_create(backend, $2, NULL, config);
			if (!table_config(table)) {
				yyerror("invalid configuration file %s for table %s",
				    config, table->t_name);
				free($2);
				free($3);
				YYERROR;
			}
			free($2);
			free($3);
		}
		| TABLE STRING {
			table = table_create("static", $2, NULL, NULL);
			free($2);
		} '{' tableval_list '}' {
			table = NULL;
		}
		;

assign		: '=' | ARROW;

keyval		: STRING assign STRING		{
			table->t_type = T_HASH;
			table_add(table, $1, $3);
			free($1);
			free($3);
		}
		;

keyval_list	: keyval
		| keyval comma keyval_list
		;

stringel	: STRING			{
			table->t_type = T_LIST;
			table_add(table, $1, NULL);
			free($1);
		}
		;

string_list	: stringel
		| stringel comma string_list
		;

tableval_list	: string_list			{ }
		| keyval_list			{ }
		;

tablenew	: STRING			{
			struct table	*t;

			t = table_create("static", NULL, NULL, NULL);
			t->t_type = T_LIST;
			table_add(t, $1, NULL);
			free($1);
			$$ = t;
		}
		| '{'				{
			table = table_create("static", NULL, NULL, NULL);
		} tableval_list '}'		{
			$$ = table;
		}
		;

tableref       	: '<' STRING '>'       		{
			struct table	*t;

			if ((t = table_find($2, NULL)) == NULL) {
				yyerror("no such table: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
			$$ = t;
		}
		;

tables		: tablenew			{ $$ = $1; }
		| tableref			{ $$ = $1; }
		;

alias		: ALIAS tables			{
			struct table   *t = $2;

			if (!table_check_use(t, T_DYNAMIC|T_HASH, K_ALIAS)) {
				yyerror("invalid use of table \"%s\" as ALIAS parameter",
				    t->t_name);
				YYERROR;
			}

			$$ = t;
		}
		;

virtual		: VIRTUAL tables		{
			struct table   *t = $2;

			if (!table_check_use(t, T_DYNAMIC|T_HASH, K_ALIAS)) {
				yyerror("invalid use of table \"%s\" as VIRTUAL parameter",
				    t->t_name);
				YYERROR;
			}
			$$ = t;
		}
		;

usermapping	: alias		{
			if (rule->r_mapping) {
				yyerror("alias specified multiple times");
				YYERROR;
			}
			rule->r_desttype = DEST_DOM;
			rule->r_mapping = $1;
		}
		| virtual	{
			if (rule->r_mapping) {
				yyerror("virtual specified multiple times");
				YYERROR;
			}
			rule->r_desttype = DEST_VDOM;
			rule->r_mapping = $1;
		}
		;

userbase	: USERBASE tables	{
			struct table   *t = $2;

			if (rule->r_userbase) {
				yyerror("userbase specified multiple times");
				YYERROR;
			}
			if (!table_check_use(t, T_DYNAMIC|T_HASH, K_USERINFO)) {
				yyerror("invalid use of table \"%s\" as USERBASE parameter",
				    t->t_name);
				YYERROR;
			}
			rule->r_userbase = t;
		}
		;

deliver_as	: AS STRING	{
			if (strlcpy(rule->r_delivery_user, $2,
			    sizeof(rule->r_delivery_user))
			    >= sizeof(rule->r_delivery_user))
				fatal("username too long");
			free($2);
		}
		| /* empty */	{}
		;

deliver_action	: DELIVER TO MAILDIR			{
			rule->r_action = A_MAILDIR;
			if (strlcpy(rule->r_value.buffer, "~/Maildir",
			    sizeof(rule->r_value.buffer)) >=
			    sizeof(rule->r_value.buffer))
				fatal("pathname too long");
		}
		| DELIVER TO MAILDIR STRING		{
			rule->r_action = A_MAILDIR;
			if (strlcpy(rule->r_value.buffer, $4,
			    sizeof(rule->r_value.buffer)) >=
			    sizeof(rule->r_value.buffer))
				fatal("pathname too long");
			free($4);
		}
		| DELIVER TO MBOX			{
			rule->r_action = A_MBOX;
			if (strlcpy(rule->r_value.buffer, _PATH_MAILDIR "/%u",
			    sizeof(rule->r_value.buffer))
			    >= sizeof(rule->r_value.buffer))
				fatal("pathname too long");
		}
		| DELIVER TO LMTP STRING deliver_as	{
			rule->r_action = A_LMTP;
			if (strchr($4, ':') || $4[0] == '/') {
				if (strlcpy(rule->r_value.buffer, $4,
					sizeof(rule->r_value.buffer))
					>= sizeof(rule->r_value.buffer))
					fatal("lmtp destination too long");
			} else
				fatal("invalid lmtp destination");
			free($4);
		}
		| DELIVER TO LMTP STRING RCPTTO deliver_as 	{
			rule->r_action = A_LMTP;
			if (strchr($4, ':') || $4[0] == '/') {
				if (strlcpy(rule->r_value.buffer, $4,
					sizeof(rule->r_value.buffer))
					>= sizeof(rule->r_value.buffer))
					fatal("lmtp destination too long");
				if (strlcat(rule->r_value.buffer, " rcpt-to",
					sizeof(rule->r_value.buffer))
					>= sizeof(rule->r_value.buffer))
					fatal("lmtp recipient too long");
			} else
				fatal("invalid lmtp destination");
			free($4);
		}
		| DELIVER TO MDA STRING deliver_as	{
			rule->r_action = A_MDA;
			if (strlcpy(rule->r_value.buffer, $4,
			    sizeof(rule->r_value.buffer))
			    >= sizeof(rule->r_value.buffer))
				fatal("command too long");
			free($4);
		}
		;

relay_action   	: RELAY relay {
			rule->r_action = A_RELAY;
		}
		| RELAY VIA STRING {
			rule->r_action = A_RELAYVIA;
			if (!text_to_relayhost(&rule->r_value.relayhost, $3)) {
				yyerror("error: invalid url: %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		} relay_via {
			/* no worries, F_AUTH cant be set without SSL */
			if (rule->r_value.relayhost.flags & F_AUTH) {
				if (rule->r_value.relayhost.authtable[0] == '\0') {
					yyerror("error: auth without auth table");
					YYERROR;
				}
			}
		}
		;

negation	: '!'		{ $$ = 1; }
		| /* empty */	{ $$ = 0; }
		;

from		: FROM negation SOURCE tables       		{
			struct table   *t = $4;

			if (rule->r_sources) {
				yyerror("from specified multiple times");
				YYERROR;
			}
			if (!table_check_use(t, T_DYNAMIC|T_LIST, K_NETADDR)) {
				yyerror("invalid use of table \"%s\" as FROM parameter",
				    t->t_name);
				YYERROR;
			}
			rule->r_notsources = $2;
			rule->r_sources = t;
		}
		| FROM negation ANY    		{
			if (rule->r_sources) {
				yyerror("from specified multiple times");
				YYERROR;
			}
			rule->r_sources = table_find("<anyhost>", NULL);
			rule->r_notsources = $2;
		}
		| FROM negation LOCAL  		{
			if (rule->r_sources) {
				yyerror("from specified multiple times");
				YYERROR;
			}
			rule->r_sources = table_find("<localhost>", NULL);
			rule->r_notsources = $2;
		}
		;

for		: FOR negation DOMAIN tables {
			struct table   *t = $4;

			if (rule->r_destination) {
				yyerror("for specified multiple times");
				YYERROR;
			}
			if (!table_check_use(t, T_DYNAMIC|T_LIST, K_DOMAIN)) {
				yyerror("invalid use of table \"%s\" as DOMAIN parameter",
				    t->t_name);
				YYERROR;
			}
			rule->r_notdestination = $2;
			rule->r_destination = t;
		}
		| FOR negation ANY    		{
			if (rule->r_destination) {
				yyerror("for specified multiple times");
				YYERROR;
			}
			rule->r_notdestination = $2;
			rule->r_destination = table_find("<anydestination>", NULL);
		}
		| FOR negation LOCAL  		{
			if (rule->r_destination) {
				yyerror("for specified multiple times");
				YYERROR;
			}
			rule->r_notdestination = $2;
			rule->r_destination = table_find("<localnames>", NULL);
		}
		;

sender		: SENDER negation tables			{
			struct table   *t = $3;

			if (rule->r_senders) {
				yyerror("sender specified multiple times");
				YYERROR;
			}

			if (!table_check_use(t, T_DYNAMIC|T_LIST, K_MAILADDR)) {
				yyerror("invalid use of table \"%s\" as SENDER parameter",
				    t->t_name);
				YYERROR;
			}
			rule->r_notsenders = $2;
			rule->r_senders = t;
		}
		;

recipient      	: RECIPIENT negation tables			{
			struct table   *t = $3;

			if (rule->r_recipients) {
				yyerror("recipient specified multiple times");
				YYERROR;
			}

			if (!table_check_use(t, T_DYNAMIC|T_LIST, K_MAILADDR)) {
				yyerror("invalid use of table \"%s\" as RECIPIENT parameter",
				    t->t_name);
				YYERROR;
			}
			rule->r_notrecipients = $2;
			rule->r_recipients = t;
		}
		;

forwardonly	: FORWARDONLY {
			if (rule->r_forwardonly) {
				yyerror("forward-only specified multiple times");
				YYERROR;
			}
			rule->r_forwardonly = 1;
		}
		;

expire		: EXPIRE STRING {
			if (rule->r_qexpire != -1) {
				yyerror("expire specified multiple times");
				YYERROR;
			}
			rule->r_qexpire = delaytonum($2);
			if (rule->r_qexpire == -1) {
				yyerror("invalid expire delay: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

opt_decision	: sender
		| recipient
		| from
		| for
		| tagged
		| authenticated
		;
decision	: opt_decision decision
		|
		;

opt_lookup	: userbase
		| usermapping
		;
lookup		: opt_lookup lookup
		|
		;

action		: deliver_action
		| relay_action
		|
		;

opt_accept	: expire
		| forwardonly
		;

accept_params	: opt_accept accept_params
		|
		;

rule		: ACCEPT {
			rule = xcalloc(1, sizeof(*rule), "parse rule: ACCEPT");
			rule->r_id = ++ruleid;
			rule->r_action = A_NONE;
			rule->r_decision = R_ACCEPT;
			rule->r_desttype = DEST_DOM;
			rule->r_qexpire = -1;
		} decision lookup action accept_params {
			if (!rule->r_sources)
				rule->r_sources = table_find("<localhost>", NULL);
			if (!rule->r_destination)
			 	rule->r_destination = table_find("<localnames>", NULL);
			if (!rule->r_userbase)
				rule->r_userbase = table_find("<getpwnam>", NULL);
			if (rule->r_qexpire == -1)
				rule->r_qexpire = conf->sc_qexpire;
			if (rule->r_action == A_RELAY || rule->r_action == A_RELAYVIA) {
				if (rule->r_userbase != table_find("<getpwnam>", NULL)) {
					yyerror("userbase may not be used with a relay rule");
					YYERROR;
				}
				if (rule->r_mapping) {
					yyerror("aliases/virtual may not be used with a relay rule");
					YYERROR;
				}
			}
			if (rule->r_forwardonly && rule->r_action != A_NONE) {
				yyerror("forward-only may not be used with a default action");
				YYERROR;
			}
			TAILQ_INSERT_TAIL(conf->sc_rules, rule, r_entry);
			rule = NULL;
		}
		| REJECT {
			rule = xcalloc(1, sizeof(*rule), "parse rule: REJECT");
			rule->r_id = ++ruleid;
			rule->r_decision = R_REJECT;
			rule->r_desttype = DEST_DOM;
		} decision {
			if (!rule->r_sources)
				rule->r_sources = table_find("<localhost>", NULL);
			if (!rule->r_destination)
				rule->r_destination = table_find("<localnames>", NULL);
			TAILQ_INSERT_TAIL(conf->sc_rules, rule, r_entry);
			rule = NULL;
		}
		;
%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "accept",		ACCEPT },
		{ "alias",		ALIAS },
		{ "any",		ANY },
		{ "as",			AS },
		{ "auth",		AUTH },
		{ "auth-optional",     	AUTH_OPTIONAL },
		{ "authenticated",     	AUTHENTICATED },
		{ "backup",		BACKUP },
		{ "bounce-warn",	BOUNCEWARN },
		{ "ca",			CA },
		{ "certificate",	CERTIFICATE },
		{ "ciphers",		CIPHERS },
		{ "compression",	COMPRESSION },
		{ "deliver",		DELIVER },
		{ "dhe",		DHE },
		{ "domain",		DOMAIN },
		{ "encryption",		ENCRYPTION },
		{ "expire",		EXPIRE },
		{ "filter",		FILTER },
		{ "for",		FOR },
		{ "forward-only",      	FORWARDONLY },
		{ "from",		FROM },
		{ "hostname",		HOSTNAME },
		{ "hostnames",		HOSTNAMES },
		{ "include",		INCLUDE },
		{ "inet4",		INET4 },
		{ "inet6",		INET6 },
		{ "key",		KEY },
		{ "limit",		LIMIT },
		{ "listen",		LISTEN },
		{ "lmtp",		LMTP },
		{ "local",		LOCAL },
		{ "maildir",		MAILDIR },
		{ "mask-source",	MASK_SOURCE },
		{ "masquerade",		MASQUERADE },
		{ "max-message-size",  	MAXMESSAGESIZE },
		{ "max-mta-deferred",  	MAXMTADEFERRED },
		{ "mbox",		MBOX },
		{ "mda",		MDA },
		{ "mta",		MTA },
		{ "no-dsn",		NODSN },
		{ "on",			ON },
		{ "pki",		PKI },
		{ "port",		PORT },
		{ "queue",		QUEUE },
		{ "rcpt-to",		RCPTTO },
		{ "received-auth",     	RECEIVEDAUTH },
		{ "recipient",		RECIPIENT },
		{ "reject",		REJECT },
		{ "relay",		RELAY },
		{ "scheduler",		SCHEDULER },
		{ "secure",		SECURE },
		{ "sender",    		SENDER },
		{ "senders",   		SENDERS },
		{ "session",   		SESSION },
		{ "smtps",		SMTPS },
		{ "socket",		SOCKET },
		{ "source",		SOURCE },
		{ "subaddressing-delimiter",	SUBADDRESSING_DELIM },
		{ "table",		TABLE },
		{ "tag",		TAG },
		{ "tagged",		TAGGED },
		{ "tls",		TLS },
		{ "tls-require",       	TLS_REQUIRE },
		{ "to",			TO },
		{ "userbase",		USERBASE },
		{ "verify",		VERIFY },
		{ "via",		VIA },
		{ "virtual",		VIRTUAL },
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

unsigned char	*parsebuf;
int		 parseindex;
unsigned char	 pushback_buffer[MAXPUSHBACK];
int		 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;
	pushback_index = 0;

	/* skip to either EOF or the first real EOL */
	while (1) {
		c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	unsigned char	 buf[8096];
	unsigned char	*p, *val;
	int		 quotec, next, c;
	int		 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

	if (c == '=') {
		if ((c = lgetc(0)) != EOF && c == '>')
			return (ARROW);
		lungetc(c);
		c = '=';
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("warn: cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("warn: %s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		log_warnx("warn: %s: group/world readable/writeable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("warn: malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("warn: malloc");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("warn: %s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

int
parse_config(struct smtpd *x_conf, const char *filename, int opts)
{
	struct sym     *sym, *next;
	struct table   *t;
	char		hostname[HOST_NAME_MAX+1];
	char		hostname_copy[HOST_NAME_MAX+1];

	if (getmailname(hostname, sizeof hostname) == -1)
		return (-1);

	conf = x_conf;
	memset(conf, 0, sizeof(*conf));

	(void)strlcpy(conf->sc_hostname, hostname, sizeof(conf->sc_hostname));

	conf->sc_maxsize = DEFAULT_MAX_BODY_SIZE;
	conf->sc_subaddressing_delim = SUBADDRESSING_DELIMITER;

	conf->sc_tables_dict = calloc(1, sizeof(*conf->sc_tables_dict));
	conf->sc_rules = calloc(1, sizeof(*conf->sc_rules));
	conf->sc_listeners = calloc(1, sizeof(*conf->sc_listeners));
	conf->sc_ca_dict = calloc(1, sizeof(*conf->sc_ca_dict));
	conf->sc_pki_dict = calloc(1, sizeof(*conf->sc_pki_dict));
	conf->sc_ssl_dict = calloc(1, sizeof(*conf->sc_ssl_dict));
	conf->sc_limits_dict = calloc(1, sizeof(*conf->sc_limits_dict));

	/* Report mails delayed for more than 4 hours */
	conf->sc_bounce_warn[0] = 3600 * 4;

	if (conf->sc_tables_dict == NULL	||
	    conf->sc_rules == NULL		||
	    conf->sc_listeners == NULL		||
	    conf->sc_ca_dict == NULL		||
	    conf->sc_pki_dict == NULL		||
	    conf->sc_ssl_dict == NULL		||
	    conf->sc_limits_dict == NULL) {
		log_warn("warn: cannot allocate memory");
		free(conf->sc_tables_dict);
		free(conf->sc_rules);
		free(conf->sc_listeners);
		free(conf->sc_ca_dict);
		free(conf->sc_pki_dict);
		free(conf->sc_ssl_dict);
		free(conf->sc_limits_dict);
		return (-1);
	}

	errors = 0;

	table = NULL;
	rule = NULL;

	dict_init(&conf->sc_filters);

	dict_init(conf->sc_ca_dict);
	dict_init(conf->sc_pki_dict);
	dict_init(conf->sc_ssl_dict);
	dict_init(conf->sc_tables_dict);

	dict_init(conf->sc_limits_dict);
	limits = xcalloc(1, sizeof(*limits), "mta_limits");
	limit_mta_set_defaults(limits);
	dict_xset(conf->sc_limits_dict, "default", limits);

	TAILQ_INIT(conf->sc_listeners);
	TAILQ_INIT(conf->sc_rules);

	conf->sc_qexpire = SMTPD_QUEUE_EXPIRY;
	conf->sc_opts = opts;

	conf->sc_mta_max_deferred = 100;
	conf->sc_scheduler_max_inflight = 5000;
	conf->sc_scheduler_max_schedule = 10;
	conf->sc_scheduler_max_evp_batch_size = 256;
	conf->sc_scheduler_max_msg_batch_size = 1024;
	
	conf->sc_session_max_rcpt = 1000;
	conf->sc_session_max_mails = 100;

	conf->sc_mda_max_session = 50;
	conf->sc_mda_max_user_session = 7;
	conf->sc_mda_task_hiwat = 50;
	conf->sc_mda_task_lowat = 30;
	conf->sc_mda_task_release = 10;

	if ((file = pushfile(filename, 0)) == NULL) {
		purge_config(PURGE_EVERYTHING);
		return (-1);
	}
	topfile = file;

	/*
	 * declare special "localhost", "anyhost" and "localnames" tables
	 */
	set_local(hostname);

	t = table_create("static", "<anydestination>", NULL, NULL);
	t->t_type = T_LIST;
	table_add(t, "*", NULL);

	/* can't truncate here */
	(void)strlcpy(hostname_copy, hostname, sizeof hostname_copy);

	hostname_copy[strcspn(hostname_copy, ".")] = '\0';
	if (strcmp(hostname, hostname_copy) != 0)
		table_add(t, hostname_copy, NULL);

	table_create("getpwnam", "<getpwnam>", NULL, NULL);

	/*
	 * parse configuration
	 */
	setservent(1);
	yyparse();
	errors = file->errors;
	popfile();
	endservent();

	/* If the socket listener was not configured, create a default one. */
	if (!conf->sc_sock_listener) {
		memset(&listen_opts, 0, sizeof listen_opts);
		create_sock_listener(&listen_opts);
	}

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if ((conf->sc_opts & SMTPD_OPT_VERBOSE) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	if (TAILQ_EMPTY(conf->sc_rules)) {
		log_warnx("warn: no rules, nothing to do");
		errors++;
	}

	if (errors) {
		purge_config(PURGE_EVERYTHING);
		return (-1);
	}

	return (0);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	(void)strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

static void
create_sock_listener(struct listen_opts *lo)
{
	struct listener *l = xcalloc(1, sizeof(*l), "create_sock_listener");
	lo->tag = "local";
	lo->hostname = conf->sc_hostname;
	l->ss.ss_family = AF_LOCAL;
	l->ss.ss_len = sizeof(struct sockaddr *);
	l->local = 1;
	conf->sc_sock_listener = l;
	config_listener(l, lo);
}

static void
create_if_listener(struct listen_opts *lo)
{
	uint16_t	flags;

	if (lo->port != 0 && lo->ssl == F_SSL)
		errx(1, "invalid listen option: tls/smtps on same port");

	if (lo->auth != 0 && !lo->ssl)
		errx(1, "invalid listen option: auth requires tls/smtps");

	if (lo->pki && !lo->ssl)
		errx(1, "invalid listen option: pki requires tls/smtps");

	flags = lo->flags;

	if (lo->port) {
		lo->flags = lo->ssl|lo->auth|flags;
		lo->port = htons(lo->port);
	}
	else {
		if (lo->ssl & F_SMTPS) {
			lo->port = htons(465);
			lo->flags = F_SMTPS|lo->auth|flags;
		}

		if (!lo->ssl || (lo->ssl & F_STARTTLS)) {
			lo->port = htons(25);
			lo->flags = lo->auth|flags;
			if (lo->ssl & F_STARTTLS)
				lo->flags |= F_STARTTLS;
		}
	}

	if (interface(lo))
		return;
	if (host_v4(lo))
		return;
	if (host_v6(lo))
		return;
	if (host_dns(lo))
		return;

	errx(1, "invalid virtual ip or interface: %s", lo->ifx);
}

static void
config_listener(struct listener *h,  struct listen_opts *lo)
{
	h->fd = -1;
	h->port = lo->port;
	h->flags = lo->flags;

	if (lo->hostname == NULL)
		lo->hostname = conf->sc_hostname;

	if (lo->filtername) {
		if (dict_get(&conf->sc_filters, lo->filtername) == NULL) {
			log_warnx("undefined filter: %s", lo->filtername);
			fatalx(NULL);
		}
		(void)strlcpy(h->filter, lo->filtername, sizeof(h->filter));
	}

	h->pki_name[0] = '\0';

	if (lo->authtable != NULL)
		(void)strlcpy(h->authtable, lo->authtable->t_name, sizeof(h->authtable));
	if (lo->pki != NULL) {
		if (!lowercase(h->pki_name, lo->pki, sizeof(h->pki_name))) {
			log_warnx("pki name too long: %s", lo->pki);
			fatalx(NULL);
		}
		if (dict_get(conf->sc_pki_dict, h->pki_name) == NULL) {
			log_warnx("pki name not found: %s", lo->pki);
			fatalx(NULL);
		}
	}

	if (lo->ca != NULL) {
		if (!lowercase(h->ca_name, lo->ca, sizeof(h->ca_name))) {
			log_warnx("ca name too long: %s", lo->ca);
			fatalx(NULL);
		}
		if (dict_get(conf->sc_ca_dict, h->ca_name) == NULL) {
			log_warnx("ca name not found: %s", lo->ca);
			fatalx(NULL);
		}
	}
	if (lo->tag != NULL)
		(void)strlcpy(h->tag, lo->tag, sizeof(h->tag));

	(void)strlcpy(h->hostname, lo->hostname, sizeof(h->hostname));
	if (lo->hostnametable)
		(void)strlcpy(h->hostnametable, lo->hostnametable->t_name, sizeof(h->hostnametable));
	if (lo->sendertable) {
		(void)strlcpy(h->sendertable, lo->sendertable->t_name, sizeof(h->sendertable));
		if (lo->options & LO_MASQUERADE)
			h->flags |= F_MASQUERADE;
	}

	if (lo->ssl & F_TLS_VERIFY)
		h->flags |= F_TLS_VERIFY;

	if (lo->ssl & F_STARTTLS_REQUIRE)
		h->flags |= F_STARTTLS_REQUIRE;
	
	if (h != conf->sc_sock_listener)
		TAILQ_INSERT_TAIL(conf->sc_listeners, h, entry);
}

static int
host_v4(struct listen_opts *lo)
{
	struct in_addr		 ina;
	struct sockaddr_in	*sain;
	struct listener		*h;

	if (lo->family != AF_UNSPEC && lo->family != AF_INET)
		return (0);

	memset(&ina, 0, sizeof(ina));
	if (inet_pton(AF_INET, lo->ifx, &ina) != 1)
		return (0);

	h = xcalloc(1, sizeof(*h), "host_v4");
	sain = (struct sockaddr_in *)&h->ss;
	sain->sin_len = sizeof(struct sockaddr_in);
	sain->sin_family = AF_INET;
	sain->sin_addr.s_addr = ina.s_addr;
	sain->sin_port = lo->port;

	if (sain->sin_addr.s_addr == htonl(INADDR_LOOPBACK))
		h->local = 1;
	config_listener(h,  lo);

	return (1);
}

static int
host_v6(struct listen_opts *lo)
{
	struct in6_addr		 ina6;
	struct sockaddr_in6	*sin6;
	struct listener		*h;

	if (lo->family != AF_UNSPEC && lo->family != AF_INET6)
		return (0);

	memset(&ina6, 0, sizeof(ina6));
	if (inet_pton(AF_INET6, lo->ifx, &ina6) != 1)
		return (0);

	h = xcalloc(1, sizeof(*h), "host_v6");
	sin6 = (struct sockaddr_in6 *)&h->ss;
	sin6->sin6_len = sizeof(struct sockaddr_in6);
	sin6->sin6_family = AF_INET6;
	sin6->sin6_port = lo->port;
	memcpy(&sin6->sin6_addr, &ina6, sizeof(ina6));

	if (IN6_IS_ADDR_LOOPBACK(&sin6->sin6_addr))
		h->local = 1;
	config_listener(h,  lo);

	return (1);
}

static int
host_dns(struct listen_opts *lo)
{
	struct addrinfo		 hints, *res0, *res;
	int			 error, cnt = 0;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sin6;
	struct listener		*h;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = lo->family;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_ADDRCONFIG;
	error = getaddrinfo(lo->ifx, NULL, &hints, &res0);
	if (error == EAI_AGAIN || error == EAI_NODATA || error == EAI_NONAME)
		return (0);
	if (error) {
		log_warnx("warn: host_dns: could not parse \"%s\": %s", lo->ifx,
		    gai_strerror(error));
		return (-1);
	}

	for (res = res0; res; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		h = xcalloc(1, sizeof(*h), "host_dns");

		h->ss.ss_family = res->ai_family;
		if (res->ai_family == AF_INET) {
			sain = (struct sockaddr_in *)&h->ss;
			sain->sin_len = sizeof(struct sockaddr_in);
			sain->sin_addr.s_addr = ((struct sockaddr_in *)
			    res->ai_addr)->sin_addr.s_addr;
			sain->sin_port = lo->port;
			if (sain->sin_addr.s_addr == htonl(INADDR_LOOPBACK))
				h->local = 1;
		} else {
			sin6 = (struct sockaddr_in6 *)&h->ss;
			sin6->sin6_len = sizeof(struct sockaddr_in6);
			memcpy(&sin6->sin6_addr, &((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_addr, sizeof(struct in6_addr));
			sin6->sin6_port = lo->port;
			if (IN6_IS_ADDR_LOOPBACK(&sin6->sin6_addr))
				h->local = 1;
		}

		config_listener(h, lo);

		cnt++;
	}

	freeaddrinfo(res0);
	return (cnt);
}

static int
interface(struct listen_opts *lo)
{
	struct ifaddrs *ifap, *p;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sin6;
	struct listener		*h;
	int			ret = 0;

	if (getifaddrs(&ifap) == -1)
		fatal("getifaddrs");

	for (p = ifap; p != NULL; p = p->ifa_next) {
		if (p->ifa_addr == NULL)
			continue;
		if (strcmp(p->ifa_name, lo->ifx) != 0 &&
		    !is_if_in_group(p->ifa_name, lo->ifx))
			continue;
		if (lo->family != AF_UNSPEC && lo->family != p->ifa_addr->sa_family)
			continue;

		h = xcalloc(1, sizeof(*h), "interface");

		switch (p->ifa_addr->sa_family) {
		case AF_INET:
			sain = (struct sockaddr_in *)&h->ss;
			*sain = *(struct sockaddr_in *)p->ifa_addr;
			sain->sin_len = sizeof(struct sockaddr_in);
			sain->sin_port = lo->port;
			if (sain->sin_addr.s_addr == htonl(INADDR_LOOPBACK))
				h->local = 1;
			break;

		case AF_INET6:
			sin6 = (struct sockaddr_in6 *)&h->ss;
			*sin6 = *(struct sockaddr_in6 *)p->ifa_addr;
			sin6->sin6_len = sizeof(struct sockaddr_in6);
			sin6->sin6_port = lo->port;
			if (IN6_IS_ADDR_LOOPBACK(&sin6->sin6_addr))
				h->local = 1;
			break;

		default:
			free(h);
			continue;
		}

		config_listener(h, lo);
		ret = 1;
	}

	freeifaddrs(ifap);

	return ret;
}

void
set_local(const char *hostname)
{
	struct table	*t;

	t = table_create("static", "<localnames>", NULL, NULL);
	t->t_type = T_LIST;
	table_add(t, "localhost", NULL);
	table_add(t, hostname, NULL);

	set_localaddrs(t);
}

void
set_localaddrs(struct table *localnames)
{
	struct ifaddrs *ifap, *p;
	struct sockaddr_storage ss;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sin6;
	struct table		*t;
	char buf[NI_MAXHOST + 5];

	t = table_create("static", "<anyhost>", NULL, NULL);
	table_add(t, "local", NULL);
	table_add(t, "0.0.0.0/0", NULL);
	table_add(t, "::/0", NULL);

	if (getifaddrs(&ifap) == -1)
		fatal("getifaddrs");

	t = table_create("static", "<localhost>", NULL, NULL);
	table_add(t, "local", NULL);

	for (p = ifap; p != NULL; p = p->ifa_next) {
		if (p->ifa_addr == NULL)
			continue;
		switch (p->ifa_addr->sa_family) {
		case AF_INET:
			sain = (struct sockaddr_in *)&ss;
			*sain = *(struct sockaddr_in *)p->ifa_addr;
			sain->sin_len = sizeof(struct sockaddr_in);
			table_add(t, ss_to_text(&ss), NULL);
			table_add(localnames, ss_to_text(&ss), NULL);
			(void)snprintf(buf, sizeof buf, "[%s]", ss_to_text(&ss));
			table_add(localnames, buf, NULL);
			break;

		case AF_INET6:
			sin6 = (struct sockaddr_in6 *)&ss;
			*sin6 = *(struct sockaddr_in6 *)p->ifa_addr;
			sin6->sin6_len = sizeof(struct sockaddr_in6);
			table_add(t, ss_to_text(&ss), NULL);
			table_add(localnames, ss_to_text(&ss), NULL);
			(void)snprintf(buf, sizeof buf, "[%s]", ss_to_text(&ss));
			table_add(localnames, buf, NULL);
			(void)snprintf(buf, sizeof buf, "[ipv6:%s]", ss_to_text(&ss));
			table_add(localnames, buf, NULL);
			break;
		}
	}

	freeifaddrs(ifap);
}

int
delaytonum(char *str)
{
	unsigned int     factor;
	size_t           len;
	const char      *errstr = NULL;
	int              delay;

	/* we need at least 1 digit and 1 unit */
	len = strlen(str);
	if (len < 2)
		goto bad;

	switch(str[len - 1]) {

	case 's':
		factor = 1;
		break;

	case 'm':
		factor = 60;
		break;

	case 'h':
		factor = 60 * 60;
		break;

	case 'd':
		factor = 24 * 60 * 60;
		break;

	default:
		goto bad;
	}

	str[len - 1] = '\0';
	delay = strtonum(str, 1, INT_MAX / factor, &errstr);
	if (errstr)
		goto bad;

	return (delay * factor);

bad:
	return (-1);
}

int
is_if_in_group(const char *ifname, const char *groupname)
{
        unsigned int		 len;
        struct ifgroupreq        ifgr;
        struct ifg_req          *ifg;
	int			 s;
	int			 ret = 0;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");

        memset(&ifgr, 0, sizeof(ifgr));
        if (strlcpy(ifgr.ifgr_name, ifname, IFNAMSIZ) >= IFNAMSIZ)
		errx(1, "interface name too large");

        if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1) {
                if (errno == EINVAL || errno == ENOTTY)
			goto end;
		err(1, "SIOCGIFGROUP");
        }

        len = ifgr.ifgr_len;
        ifgr.ifgr_groups = xcalloc(len/sizeof(struct ifg_req),
		sizeof(struct ifg_req), "is_if_in_group");
        if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1)
                err(1, "SIOCGIFGROUP");

        ifg = ifgr.ifgr_groups;
        for (; ifg && len >= sizeof(struct ifg_req); ifg++) {
                len -= sizeof(struct ifg_req);
		if (strcmp(ifg->ifgrq_group, groupname) == 0) {
			ret = 1;
			break;
		}
        }
        free(ifgr.ifgr_groups);

end:
	close(s);
	return ret;
}

static struct filter_conf *
create_filter_proc(char *name, char *prog)
{
	struct filter_conf	*f;
	char			*path;

	if (dict_get(&conf->sc_filters, name)) {
		yyerror("filter \"%s\" already defined", name);
		return (NULL);
	}

	if (asprintf(&path, "%s/filter-%s", PATH_LIBEXEC, prog) == -1) {
		yyerror("filter \"%s\" asprintf failed", name);
		return (0);
	}

	f = xcalloc(1, sizeof(*f), "create_filter");
	f->path = path;
	f->name = name;
	f->argv[f->argc++] = name;

	dict_xset(&conf->sc_filters, name, f);

	return (f);
}

static struct filter_conf *
create_filter_chain(char *name)
{
	struct filter_conf	*f;

	if (dict_get(&conf->sc_filters, name)) {
		yyerror("filter \"%s\" already defined", name);
		return (NULL);
	}

	f = xcalloc(1, sizeof(*f), "create_filter_chain");
	f->chain = 1;
	f->name = name;

	dict_xset(&conf->sc_filters, name, f);

	return (f);
}

static int
add_filter_arg(struct filter_conf *f, char *arg)
{
	int	i;

	if (f->argc == MAX_FILTER_ARGS) {
		yyerror("filter \"%s\" is full", f->name);
		return (0);
	}

	if (f->chain) {
		if (dict_get(&conf->sc_filters, arg) == NULL) {
			yyerror("undefined filter \"%s\"", arg);
			return (0);
		}
		if (dict_get(&conf->sc_filters, arg) == f) {
			yyerror("filter chain cannot contain itself");
			return (0);
		}
		for (i = 0; i < f->argc; ++i)
			if (strcasecmp(f->argv[i], arg) == 0) {
				yyerror("filter chain cannot contain twice the same filter instance");
				return (0);
			}
	}

	f->argv[f->argc++] = arg;

	return (1);
}

static int
config_lo_filter(struct listen_opts *lo, char *filter_name) {
	if (lo->options & LO_FILTER) {
		yyerror("filter already specified");
		return -1;
	}
	lo->options |= LO_FILTER;
	lo->filtername = filter_name;

	return 0;
}

static int
config_lo_mask_source(struct listen_opts *lo) {
	if (lo->options & LO_MASKSOURCE) {
		yyerror("mask-source already specified");
		return -1;
	}
	lo->options |= LO_MASKSOURCE;
	lo->flags |= F_MASK_SOURCE;

	return 0;
}

@


1.194
log
@allow negation of authenticated keyword:
	accept ! authenticated [...]

ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.193 2017/01/05 13:53:09 krw Exp $	*/
d2233 3
@


1.193
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.192 2017/01/05 12:42:19 krw Exp $	*/
d275 1
a275 1
authenticated  	: AUTHENTICATED	{
d277 1
@


1.192
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.191 2016/11/25 09:21:21 gilles Exp $	*/
d2014 1
a2014 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.191
log
@assign an id to each rule in the ruleset, first step towards an MTA layer
and scheduler simplification

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.190 2016/09/12 07:33:00 eric Exp $	*/
d2045 4
a2048 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d2107 1
a2107 1
	TAILQ_FOREACH(sym, &symhead, entry)
d2112 1
@


1.190
log
@listener configuration cleanup:

- have all listener creation functions take listen_opts as param,
  and call config_listener() when done, which adds the listener(s)
  to the current config list of listeners.
- make the fallback chain between interface(), host_v4() host_v6()
  and host_dns() obvious when creating an if_listener.
- fix a bug where the specified family was ignored if the listener
  is given as a hostname.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.189 2016/08/31 15:24:04 gilles Exp $	*/
d96 1
d1413 1
d1446 1
@


1.189
log
@introduce "authenticated" parameter so rules may apply to authenticated
sessions specifically

ok eric@@, sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.188 2016/08/31 10:18:08 gilles Exp $	*/
d141 8
a148 9
static struct listener	*create_sock_listener(struct listen_opts *);
static void		 create_if_listener(struct listenerlist *,  struct listen_opts *);
static void		 config_listener(struct listener *,  struct listen_opts *);

struct listener	*host_v4(const char *, in_port_t);
struct listener	*host_v6(const char *, in_port_t);
int		 host_dns(struct listenerlist *, struct listen_opts *);
int		 host(struct listenerlist *, struct listen_opts *);
int		 interface(struct listenerlist *, struct listen_opts *);
d697 1
a697 1
			conf->sc_sock_listener = create_sock_listener(&listen_opts);
d703 1
a703 1
			create_if_listener(conf->sc_listeners, &listen_opts);
d2007 1
a2007 1
		conf->sc_sock_listener = create_sock_listener(&listen_opts);
d2111 1
a2111 1
static struct listener *
d2120 1
a2121 2

	return (l);
d2125 1
a2125 1
create_if_listener(struct listenerlist *ll,  struct listen_opts *lo)
a2142 3
		if (!interface(ll, lo))
			if (host(ll, lo) <= 0)
				errx(1, "invalid virtual ip or interface: %s", lo->ifx);
a2147 3
			if (!interface(ll, lo))
				if (host(ll, lo) <= 0)
					errx(1, "invalid virtual ip or interface: %s", lo->ifx);
a2154 3
			if (!interface(ll, lo))
				if (host(ll, lo) <= 0)
					errx(1, "invalid virtual ip or interface: %s", lo->ifx);
d2157 11
d2227 3
d2232 2
a2233 2
struct listener *
host_v4(const char *s, in_port_t port)
d2239 3
d2243 2
a2244 2
	if (inet_pton(AF_INET, s, &ina) != 1)
		return (NULL);
d2251 1
a2251 1
	sain->sin_port = port;
d2255 1
d2257 1
a2257 1
	return (h);
d2260 2
a2261 2
struct listener *
host_v6(const char *s, in_port_t port)
d2267 3
d2271 2
a2272 2
	if (inet_pton(AF_INET6, s, &ina6) != 1)
		return (NULL);
d2278 1
a2278 1
	sin6->sin6_port = port;
d2283 1
d2285 1
a2285 1
	return (h);
d2288 2
a2289 2
int
host_dns(struct listenerlist *al, struct listen_opts *lo)
d2298 1
a2298 1
	hints.ai_family = PF_UNSPEC;
a2336 1
		TAILQ_INSERT_HEAD(al, h, entry);
d2344 2
a2345 22
int
host(struct listenerlist *al, struct listen_opts *lo)
{
	struct listener *h;

	h = host_v4(lo->ifx, lo->port);

	/* IPv6 address? */
	if (h == NULL)
		h = host_v6(lo->ifx, lo->port);

	if (h != NULL) {
		config_listener(h, lo);
		TAILQ_INSERT_HEAD(al, h, entry);
		return (1);
	}

	return (host_dns(al, lo));
}

int
interface(struct listenerlist *al, struct listen_opts *lo)
a2392 1
		TAILQ_INSERT_HEAD(al, h, entry);
@


1.188
log
@allow overriding the subaddressing delimiter with subaddressing-delimiter
keyword, the default is still +

ok eric@@, sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.187 2016/08/30 21:33:58 gilles Exp $	*/
d181 1
a181 1
%token	CIPHERS RECEIVEDAUTH MASQUERADE SOCKET SUBADDRESSING_DELIM
d275 5
d1385 1
d1496 1
@


1.187
log
@when configuring the daemon, assign values to the structure being conf-ed,
not the global structure. this worked by accident.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.186 2016/07/01 17:53:23 eric Exp $	*/
d181 1
a181 1
%token	CIPHERS RECEIVEDAUTH MASQUERADE SOCKET
d851 15
d1541 1
d1896 1
@


1.186
log
@flag the local socket listener as local.
clarify check for local listeners.

ok gilles@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.185 2016/06/21 21:35:25 benno Exp $	*/
d961 1
a961 1
			env->sc_tls_ciphers = $2;
@


1.185
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.184 2016/04/21 14:27:41 jsing Exp $	*/
d2096 1
@


1.184
log
@Use automatic DH parameters, instead of fixed ones. Also disable DHE by
default since it is computationally expensive and a potential DoS vector.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.183 2016/02/22 16:19:05 gilles Exp $	*/
d216 8
@


1.183
log
@the default address family for a listener was set too late and would
override the value provided by the user if any. this commit moves the
initialization earlier to avoid this.

issue reported by and fix ok jturner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.182 2016/02/13 20:43:07 gilles Exp $	*/
d179 1
a179 1
%token	ARROW AUTH TLS LOCAL VIRTUAL TAG TAGGED ALIAS FILTER KEY CA DHPARAMS
d400 13
a412 2
		| DHPARAMS STRING {
			pki->pki_dhparams_file = $2;
d1474 1
a1474 1
		{ "dhparams",		DHPARAMS },
@


1.182
log
@handle enqueuer socket as a regular listener that can be configured with
"listen on socket". this simplifies a bit of code, removes some special
cases and will allow attaching filters & masking source just as on lo0.

diff from Peter Bisroev <peter@@int19h.net>
ok gilles@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.181 2016/01/18 09:19:41 jung Exp $	*/
d472 1
a472 1
}
d666 1
a666 1
		| interface_listener
d678 1
a678 4
interface_listener:
		STRING if_listen {
			listen_opts.family = AF_UNSPEC;
			listen_opts.flags |= F_EXT_DSN;
d882 2
@


1.181
log
@remove leftovers of (gone) curve option

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.180 2016/01/12 17:29:43 sunil Exp $	*/
a99 1
struct listener		 l;
d141 3
a143 2
static void	create_listener(struct listenerlist *,  struct listen_opts *);
static void	config_listener(struct listener *,  struct listen_opts *);
d159 3
d181 1
a181 1
%token	CIPHERS RECEIVEDAUTH MASQUERADE ENQUEUER
d409 13
a421 1
opt_listen     	: INET4			{
d469 1
a469 2
			if (listen_opts.options & LO_FILTER) {
				yyerror("filter already specified");
d472 1
a472 3
			listen_opts.options |= LO_FILTER;
			listen_opts.filtername = $2;
		}
d611 1
a611 2
			if (listen_opts.options & LO_MASKSOURCE) {
				yyerror("mask-source already specified");
a613 2
			listen_opts.options |= LO_MASKSOURCE;
			listen_opts.flags |= F_MASK_SOURCE;
d665 27
a691 1
listen		: opt_listen listen
a883 1
			memset(&l, 0, sizeof l);
d885 1
a885 20
			listen_opts.family = AF_UNSPEC;
			listen_opts.flags |= F_EXT_DSN;
		} ON STRING listen {
			listen_opts.ifx = $4;
			create_listener(conf->sc_listeners, &listen_opts);
		}
		| ENQUEUER FILTER STRING {
			if (dict_get(&conf->sc_filters, $3) == NULL) {
				yyerror("undefined filter \"%s\"", $3);
				free($3);
				YYERROR;
			}
			if (strlcpy(conf->sc_enqueue_filter, $3,
				sizeof conf->sc_enqueue_filter)
			    >= sizeof conf->sc_enqueue_filter) {
				free($3);
				YYERROR;
			}
			free($3);
		}
a1466 1
		{ "enqueuer",		ENQUEUER },
d1506 1
d1963 6
d2070 13
d2084 1
a2084 1
create_listener(struct listenerlist *ll,  struct listen_opts *lo)
d2597 25
@


1.180
log
@Let smtpd start on machines without a FQDN as hostname.

Ok millert@@ gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.179 2016/01/04 13:30:20 jung Exp $	*/
d178 1
a178 1
%token	CIPHERS CURVE RECEIVEDAUTH MASQUERADE ENQUEUER
a1447 1
		{ "curve",		CURVE },
@


1.179
log
@switch to /usr/local/libexec when looking for -extras and drop loop iterating
paths

this effectively reverts table.c r1.21 which was mainly introduced for a smooth
transition in -current

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.178 2015/12/28 22:08:30 jung Exp $	*/
d1839 1
a1839 1
	if (!getmailname(hostname, sizeof hostname))
@


1.178
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.177 2015/12/12 20:02:31 gilles Exp $	*/
d2500 1
a2500 1
	if (asprintf(&path, "%s/filter-%s", PATH_LIBEXEC_DEPRECATED, prog) == -1) {
@


1.177
log
@remove CA from pki and no longer allow specifying a CA with 'pki' keyword.
introduce 'ca' keyword to allow specifying a custom CA.
making CA part of pki was a bad idea and several people hit use-cases that
plain couldn't work.

instead of:
    pki foobar.org ca "/etc/mail/CA.pem"

use now:
    ca foobar.org certificate "/etc/mail/CA.pem"


ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.176 2015/12/12 18:52:23 gilles Exp $	*/
d591 1
a591 1
			if (! table_check_use(t, T_DYNAMIC|T_HASH, K_ADDRNAME)) {
d631 1
a631 1
			if (! table_check_use(t, T_DYNAMIC|T_HASH, K_MAILADDRMAP)) {
d647 1
a647 1
			if (! table_check_use(t, T_DYNAMIC|T_HASH, K_MAILADDRMAP)) {
d663 1
a663 1
			if (! text_to_mailaddr(&maddr, $2)) {
d687 1
a687 1
			if (! table_check_use(t, T_DYNAMIC|T_LIST, K_SOURCE)) {
d702 1
a702 1
			if (! table_check_use(t, T_DYNAMIC|T_HASH, K_ADDRNAME)) {
d711 1
a711 1
			if (! lowercase(rule->r_value.relayhost.pki_name, $2,
d726 1
a726 1
			if (! lowercase(rule->r_value.relayhost.ca_name, $2,
d775 1
a775 1
			if (! table_check_use(t, T_DYNAMIC|T_HASH, K_CREDENTIALS)) {
d892 1
a892 1
				if (! res_hnok($2)) {
d912 1
a912 1
				if (! res_hnok($2)) {
d1051 1
a1051 1
			if (! table_check_use(t, T_DYNAMIC|T_HASH, K_ALIAS)) {
d1064 1
a1064 1
			if (! table_check_use(t, T_DYNAMIC|T_HASH, K_ALIAS)) {
d1098 1
a1098 1
			if (! table_check_use(t, T_DYNAMIC|T_HASH, K_USERINFO)) {
d1180 1
a1180 1
			if (! text_to_relayhost(&rule->r_value.relayhost, $3)) {
d1208 1
a1208 1
			if (! table_check_use(t, T_DYNAMIC|T_LIST, K_NETADDR)) {
d1241 1
a1241 1
			if (! table_check_use(t, T_DYNAMIC|T_LIST, K_DOMAIN)) {
d1275 1
a1275 1
			if (! table_check_use(t, T_DYNAMIC|T_LIST, K_MAILADDR)) {
d1293 1
a1293 1
			if (! table_check_use(t, T_DYNAMIC|T_LIST, K_MAILADDR)) {
d1364 1
a1364 1
			if (! rule->r_sources)
d1366 1
a1366 1
			if (! rule->r_destination)
d1368 1
a1368 1
			if (! rule->r_userbase)
d1394 1
a1394 1
			if (! rule->r_sources)
d1396 1
a1396 1
			if (! rule->r_destination)
d1839 1
a1839 1
	if (! getmailname(hostname, sizeof hostname))
d2069 1
a2069 1
		if (! interface(ll, lo))
d2077 1
a2077 1
			if (! interface(ll, lo))
d2082 1
a2082 1
		if (! lo->ssl || (lo->ssl & F_STARTTLS)) {
d2087 1
a2087 1
			if (! interface(ll, lo))
d2117 1
a2117 1
		if (! lowercase(h->pki_name, lo->pki, sizeof(h->pki_name))) {
d2128 1
a2128 1
		if (! lowercase(h->ca_name, lo->ca, sizeof(h->ca_name))) {
d2294 1
a2294 1
		    ! is_if_in_group(p->ifa_name, lo->ifx))
@


1.176
log
@whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.175 2015/12/12 18:49:38 gilles Exp $	*/
a395 3
		}
		| CA STRING {
			pki->pki_ca_file = $2;
@


1.175
log
@when using senders map to restrict email address a user may use in SMTP
dialogue, if `masquerade' is used as a parameter then rewrite the email
address of the DATA From header to the email address in the map.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.174 2015/12/12 17:16:56 gilles Exp $	*/
d929 5
a933 5
		  } ca
		  | CIPHERS STRING {
			  env->sc_tls_ciphers = $2;
		  }
		  ;
@


1.174
log
@allow overriding the default cipher-suite

ok jung@@, sunil@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.173 2015/12/12 14:44:36 gilles Exp $	*/
a640 1
		/*
a656 1
		*/
@


1.173
log
@check in parse.y that pki param is a valid hostname
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.172 2015/12/12 12:38:36 gilles Exp $	*/
d932 3
@


1.172
log
@prepare bits to enable masquerade in parse.y
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.171 2015/12/12 12:34:51 gilles Exp $	*/
d894 9
@


1.171
log
@add missing check for failed allocation
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.170 2015/12/12 12:28:04 gilles Exp $	*/
d119 1
d641 18
d2136 1
a2136 1
	if (lo->sendertable)
d2138 3
@


1.170
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.169 2015/12/12 12:22:25 gilles Exp $	*/
d1839 1
@


1.169
log
@add bits so local enqueuer can run filters when they are enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.168 2015/12/12 11:31:29 sunil Exp $	*/
d704 1
a704 1
			    rule->r_value.relayhost.pki_name) == NULL) {
@


1.168
log
@Implement senders map.

senders table allows to restrict the addresses that an authenticated
user can use in the SMTP dialogue.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.167 2015/12/12 09:00:22 gilles Exp $	*/
d842 14
@


1.167
log
@rename an smtpd specific define
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.166 2015/12/11 08:27:04 gilles Exp $	*/
d117 1
d135 1
d624 16
d2102 2
@


1.166
log
@add keywords that are going to be used in upcoming mini diffs
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.165 2015/12/11 08:19:03 gilles Exp $	*/
d566 1
a566 1
			if (strlen($2) >= MAX_TAG_SIZE) {
@


1.165
log
@in add_filter_arg() do not allow the same filter twice in same chain
unused for now
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.164 2015/12/03 21:11:33 jung Exp $	*/
d174 2
a175 2
%token	AUTH_OPTIONAL TLS_REQUIRE USERBASE SENDER MASK_SOURCE VERIFY FORWARDONLY RECIPIENT
%token	RECEIVEDAUTH
d1388 1
d1390 1
d1395 1
d1413 1
d1432 1
@


1.164
log
@introduce limit session keyword replacing fixed values

original diff from Renaud Allard

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.163 2015/12/02 09:06:36 gilles Exp $	*/
d2468 2
d2484 5
@


1.163
log
@whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.162 2015/12/01 18:22:30 gilles Exp $	*/
d170 1
a170 1
%token	TABLE SECURE SMTPS CERTIFICATE DOMAIN BOUNCEWARN LIMIT INET4 INET6 NODSN
d310 20
d798 1
d1428 1
d1842 3
@


1.162
log
@add received-auth parameter to listener to identify authenticated sessions
in locally appended Received header when enabled

ok millert@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.161 2015/12/01 15:43:01 gilles Exp $	*/
d546 1
a546 1
       			if (strlen($2) >= MAX_TAG_SIZE) {
d2047 1
a2047 1
	}	
@


1.161
log
@update enum values in listen options
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.160 2015/12/01 10:57:24 gilles Exp $	*/
d117 1
d175 1
d586 8
d1400 1
@


1.160
log
@reorder header
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.159 2015/12/01 09:33:17 gilles Exp $	*/
d106 11
a116 11
	LO_FAMILY	= 0x01,
	LO_PORT		= 0x02,
	LO_SSL		= 0x04,
	LO_FILTER      	= 0x08,
	LO_PKI      	= 0x10,
	LO_AUTH      	= 0x20,
	LO_TAG      	= 0x40,
	LO_HOSTNAME   	= 0x80,
	LO_HOSTNAMES   	= 0x100,
	LO_MASKSOURCE  	= 0x200,
	LO_NODSN	= 0x400,
@


1.159
log
@prepare the ground for the CA certificate handling refactor, this commit
adds the parse.y bit + structures & members needed but does not make use
of it yet
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.158 2015/11/30 14:13:03 gilles Exp $	*/
d43 1
a44 1
#include <limits.h>
@


1.158
log
@when looking up tables, start in /usr/local/libexec before /usr/libexec, so
ports/packages can be installed in the proper place

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.157 2015/11/30 12:26:55 sunil Exp $	*/
d47 1
d103 1
d117 1
d127 1
d135 1
a135 1
	uint16_t       	options;
d358 8
d495 8
d663 15
d809 1
a809 1
		} filter_args;
d821 21
a841 1
		;
d1756 1
d1767 1
d1774 1
d1788 1
d2026 11
@


1.157
log
@While delivering to lmtp or mda, accept optional "as user" parameter
whose privileges would be used instead of the default.

Ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.156 2015/11/05 12:35:58 jung Exp $	*/
d2325 1
a2325 1
	if (asprintf(&path, "%s/filter-%s", PATH_LIBEXEC, prog) == -1) {
@


1.156
log
@replace u_char and u_int* with standard stdint.h types to ease portable version
also remove trailing whitespaces while here

no binary change

ok sunil millert gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.155 2015/10/27 21:20:11 jung Exp $	*/
d963 10
d995 1
a995 1
		| DELIVER TO LMTP STRING		{
d1006 1
a1006 1
		| DELIVER TO LMTP STRING RCPTTO 	{
d1021 1
a1021 1
		| DELIVER TO MDA STRING			{
@


1.155
log
@add a rcpt-to parameter to be able to use the original (probably expanded)
RCPT TO within LMTP sessions

ok gilles eric
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.154 2015/09/07 15:36:53 gilles Exp $	*/
d375 1
a375 1
				YYERROR;	
d383 1
a383 1
				YYERROR;	
d393 1
a393 1
				YYERROR;	
d409 1
a409 1
				YYERROR;	
d422 1
a422 1
				YYERROR;	
d430 1
a430 1
				YYERROR;	
d438 1
a438 1
				YYERROR;	
d446 1
a446 1
				YYERROR;	
d454 1
a454 1
				YYERROR;	
d462 1
a462 1
				YYERROR;	
d470 1
a470 1
				YYERROR;	
d478 1
a478 1
				YYERROR;	
d486 1
a486 1
				YYERROR;	
d494 1
a494 1
				YYERROR;	
d502 1
a502 1
				YYERROR;	
d511 1
a511 1
				YYERROR;	
d520 1
a520 1
				YYERROR;	
d534 1
a534 1
				YYERROR;	
d545 1
a545 1
				YYERROR;	
d559 1
a559 1
				YYERROR;	
d567 1
a567 1
				YYERROR;	
d1211 1
a1211 1
				rule->r_sources = table_find("<localhost>", NULL);			
d1357 4
a1360 4
u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;
d1450 4
a1453 4
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;
d1888 1
a1888 1
	
d1891 1
a1891 1
	
d1894 1
a1894 1
	
d2012 1
a2012 1
	
d2222 1
a2222 1
  	
d2227 1
a2227 1
	
d2229 1
a2229 1
		
d2233 1
a2233 1
		
d2237 1
a2237 1
		
d2241 1
a2241 1
		
d2245 1
a2245 1
		
d2249 1
a2249 1
  	
d2254 1
a2254 1
	
d2256 1
a2256 1
  	
d2288 1
a2288 1
	
@


1.154
log
@when bypassing the enqueuer, insert Message-Id header if none was found and
the client has connected from a loopback interface.

ok millert@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.153 2015/08/19 16:14:54 deraadt Exp $	*/
d166 1
a166 1
%token  RELAY BACKUP VIA DELIVER TO LMTP MAILDIR MBOX HOSTNAME HOSTNAMES
d996 15
d1324 1
@


1.153
log
@do not cast result from xcalloc(); it is in scope
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.152 2015/02/08 04:50:32 reyk Exp $	*/
d1970 3
d1994 3
d2035 2
d2043 2
d2106 2
d2115 2
@


1.152
log
@Use AI_ADDRCONFIG when resolv hosts on startup.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.151 2015/01/20 17:37:54 deraadt Exp $	*/
d2254 1
a2254 2
        ifgr.ifgr_groups =
            (struct ifg_req *)xcalloc(len/sizeof(struct ifg_req),
@


1.151
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.150 2015/01/16 06:40:20 deraadt Exp $	*/
d2006 1
@


1.150
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.149 2014/11/20 05:51:21 jsg Exp $	*/
d1659 2
a1660 2
	char		hostname[SMTPD_MAXHOSTNAMELEN];
	char		hostname_copy[SMTPD_MAXHOSTNAMELEN];
@


1.149
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.148 2014/11/16 19:07:50 bluhm Exp $	*/
d44 1
d776 1
a776 1
			char buf[MAXHOSTNAMELEN];
@


1.148
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.147 2014/11/14 03:20:37 doug Exp $	*/
d1497 3
@


1.147
log
@Add gcc printf format attributes to yyerror() in parse.y files.
No yyerror() calls needed to be changed.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.146 2014/07/09 12:44:54 eric Exp $	*/
d1243 1
a1243 1
	char		*nfmt;
d1247 2
a1248 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d1250 2
a1251 1
	free(nfmt);
@


1.146
log
@add a "no-dsn" listener option to disable DSN extension.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.145 2014/07/09 09:53:37 eric Exp $	*/
d78 2
a79 1
    __attribute__ ((format (printf, 1, 2)));
@


1.145
log
@config parser improvements:

- fail if the same option is specified multiple times on a listener
- prompt for queue encryption key after config parsing, not during.
- add ip addresses to localnames table
- prepare for filters
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 1
d163 1
a163 1
%token	TABLE SECURE SMTPS CERTIFICATE DOMAIN BOUNCEWARN LIMIT INET4 INET6
d562 8
d752 1
d1302 1
@


1.144
log
@update filter configuration parsing (not plugged yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.143 2014/04/19 17:23:19 gilles Exp $	*/
d101 13
d119 1
d126 3
a128 1
	uint16_t	flags;	
d139 2
a140 1
void		 set_localaddrs(void);
d369 16
a384 2
opt_listen     	: INET4			{ listen_opts.family = AF_INET; }
		| INET6			{ listen_opts.family = AF_INET6; }
d388 6
d404 6
d416 80
a495 9
		| SMTPS				{ listen_opts.ssl = F_SMTPS; }
		| SMTPS VERIFY 			{ listen_opts.ssl = F_SMTPS|F_TLS_VERIFY; }
		| TLS				{ listen_opts.ssl = F_STARTTLS; }
		| SECURE       			{ listen_opts.ssl = F_SSL; }
		| TLS_REQUIRE			{ listen_opts.ssl = F_STARTTLS|F_STARTTLS_REQUIRE; }
		| TLS_REQUIRE VERIFY   		{ listen_opts.ssl = F_STARTTLS|F_STARTTLS_REQUIRE|F_TLS_VERIFY; }
		| PKI STRING			{ listen_opts.pki = $2; }
		| AUTH				{ listen_opts.auth = F_AUTH|F_AUTH_REQUIRE; }
		| AUTH_OPTIONAL			{ listen_opts.auth = F_AUTH; }
d497 5
d506 5
d515 6
d528 9
a536 1
		| HOSTNAME STRING	{ listen_opts.hostname = $2; }
d539 7
d553 8
a560 1
		| MASK_SOURCE	{ listen_opts.flags |= F_MASK_SOURCE; }
a695 13
			char	*password;

			password = getpass("queue key: ");
			if (password == NULL) {
				yyerror("getpass() error");
				YYERROR;
			}
			conf->sc_queue_key = strdup(password);
			memset(password, 0, strlen(password));
			if (conf->sc_queue_key == NULL) {
				yyerror("memory exhausted");
				YYERROR;
			}
a696 1

d699 3
a701 17
			char   *buf;
			char   *lbuf;
			size_t	len;

			if (strcasecmp($4, "stdin") == 0 ||
			    strcasecmp($4, "-") == 0) {
				lbuf = NULL;
				buf = fgetln(stdin, &len);
				if (buf[len - 1] == '\n') {
					lbuf = calloc(len, 1);
					memcpy(lbuf, buf, len-1);
				}
				else {
					lbuf = calloc(len+1, 1);
					memcpy(lbuf, buf, len);
				}
				conf->sc_queue_key = lbuf;
d966 7
d984 1
a984 8
		| DELIVER TO MBOX			{
			rule->r_action = A_MBOX;
			if (strlcpy(rule->r_value.buffer, _PATH_MAILDIR "/%u",
			    sizeof(rule->r_value.buffer))
			    >= sizeof(rule->r_value.buffer))
				fatal("pathname too long");
		}
		| DELIVER TO MDA STRING	       	{
d1724 1
a1724 6
	set_localaddrs();

	t = table_create("static", "<localnames>", NULL, NULL);
	t->t_type = T_LIST;
	table_add(t, "localhost", NULL);
	table_add(t, hostname, NULL);
d1903 8
d2104 14
a2117 1
set_localaddrs(void)
d2124 1
d2146 3
d2156 5
@


1.143
log
@add missing strlcpy() check in create_filter_chain() that would cause smtpd
to fatal at startup if truncation occured and we had enabled filters

(void) cast a strlcpy() that cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.138 2014/03/25 10:28:58 gilles Exp $	*/
d94 1
a94 1
struct filter		*filter = NULL;
d127 3
a129 3
static struct filter	*create_filter(const char *, const char *);
static struct filter	*create_filter_chain(const char *);
static int		 extend_filter_chain(struct filter *, const char *);
d148 1
a148 1
%token	ARROW AUTH TLS LOCAL VIRTUAL TAG TAGGED ALIAS FILTER FILTERCHAIN KEY CA DHPARAMS
d624 1
a624 2
			if (!create_filter($2, $3)) {
				free($2);
d626 4
a629 1
				YYERROR;
d631 6
a636 7
			free($2);
			free($3);
		}
		| FILTERCHAIN STRING {
			if ((filter = create_filter_chain($2)) == NULL) {
				free($2);
				YYERROR;
d638 1
a638 1
		} filter_list
d652 9
a730 9
filter_list	:
		| STRING {
			if (!extend_filter_chain(filter, $1)) {
				free($1);
				YYERROR;
			}
		} filter_list
		;

a1147 1
		{ "filterchain",	FILTERCHAIN },
d2109 2
a2110 2
struct filter *
create_filter(const char *name, const char *path)
d2112 2
a2113 1
	struct filter	*f;
d2120 5
d2126 3
a2128 10
	if (strlcpy(f->name, name, sizeof(f->name))
	    >= sizeof (f->name)) {
		yyerror("filter name \"%s\" too long", name);
		return (NULL);
	}
	if (strlcpy(f->path, path, sizeof(f->path))
	    >= sizeof (f->path)) {
		yyerror("filter path \"%s\" too long", path);
		return (NULL);
	}
d2135 2
a2136 2
static struct filter *
create_filter_chain(const char *name)
d2138 1
a2138 1
	struct filter	*f;
d2144 1
a2145 5
	if (strlcpy(f->name, name, sizeof(f->name)) >=
	    sizeof(f->name)) {
		yyerror("filter chain name \"%s\" too long", name);
		return (NULL);
	}
d2147 1
d2155 1
a2155 1
extend_filter_chain(struct filter *f, const char *name)
d2157 2
a2158 4
	int	i;

	if (!f->chain) {
		yyerror("filter \"%s\" is not a chain", f->name);
d2162 9
a2170 7
	if (dict_get(&conf->sc_filters, name) == NULL) {
		yyerror("undefined filter \"%s\"", name);
		return (0);
	}
	if (dict_get(&conf->sc_filters, name) == f) {
		yyerror("filter chain cannot contain itself");
		return (0);
d2173 3
a2175 8
	for (i = 0; i < MAX_FILTER_PER_CHAIN; i++) {
		if (f->filters[i][0] == '\0') {
			(void)strlcpy(f->filters[i], name, sizeof(f->filters[i]));
			return (1);
		}
	}
	yyerror("filter chain \"%s\" is full", f->name);
	return (0);
@


1.142
log
@add missing strlcpy() checks in create_filter() that would cause smtpd to
	fatal at startup if truncation occured and we had enabled filters
@
text
@d2146 5
a2150 1
	strlcpy(f->name, name, sizeof(f->name));
d2179 1
a2179 1
			strlcpy(f->filters[i], name, sizeof(f->filters[i]));
@


1.141
log
@add missing strlcpy() check in is_if_in_group() to detect and warn about
the truncation rather than failing the ioctl() call that follows.
@
text
@d2120 10
a2129 2
	strlcpy(f->name, name, sizeof(f->name));
	strlcpy(f->path, path, sizeof(f->path));
@


1.140
log
@add missing strlcpy() check when parsing "backup hostname" in smtpd.conf,
it could lead to smtpd not finding itself in a MX lookup if a hostname is
specified that exceeds the max hostname len.

while at it, add a missing free()
@
text
@d2078 3
a2080 1
        strlcpy(ifgr.ifgr_name, ifname, IFNAMSIZ);
@


1.139
log
@(void) cast strlcpy() calls that cannot truncate
@
text
@d484 8
a491 2
			strlcpy(rule->r_value.relayhost.hostname, $2,
			    sizeof (rule->r_value.relayhost.hostname));
@


1.138
log
@reword error message when a table has an invalid configuration file, it has
confused a few people

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.137 2014/02/04 13:44:41 eric Exp $	*/
d447 1
a447 1
			strlcpy(rule->r_value.relayhost.sourcetable, t->t_name,
d451 1
a451 1
			strlcat(rule->r_value.relayhost.heloname, $2,
d462 1
a462 1
			strlcpy(rule->r_value.relayhost.helotable, t->t_name,
d489 1
a489 1
			strlcpy(rule->r_value.relayhost.hostname,
d514 1
a514 1
			strlcpy(rule->r_value.relayhost.authtable, t->t_name,
d639 1
a639 1
				strlcpy(pki->pki_name, buf, sizeof(pki->pki_name));
d1522 1
a1522 1
	strlcpy(conf->sc_hostname, hostname, sizeof(conf->sc_hostname));
@


1.137
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d673 2
a674 2
				yyerror("invalid backend configuration for table %s",
				    table->t_name);
@


1.136
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.134 2013/12/05 15:04:09 eric Exp $	*/
d99 1
a99 1
static struct ssl	*pki_ssl;
d335 1
a335 1
			pki_ssl->ssl_cert_file = $2;
d338 1
a338 1
			pki_ssl->ssl_key_file = $2;
d341 1
a341 1
			pki_ssl->ssl_ca_file = $2;
d344 1
a344 1
			pki_ssl->ssl_dhparams_file = $2;
d466 2
a467 2
			if (! lowercase(rule->r_value.relayhost.cert, $2,
				sizeof(rule->r_value.relayhost.cert))) {
d472 2
a473 2
			if (dict_get(conf->sc_ssl_dict,
			    rule->r_value.relayhost.cert) == NULL) {
d636 5
a640 5
			pki_ssl = dict_get(conf->sc_ssl_dict, buf);
			if (pki_ssl == NULL) {
				pki_ssl = xcalloc(1, sizeof *pki_ssl, "parse:pki");
				strlcpy(pki_ssl->ssl_name, buf, sizeof(pki_ssl->ssl_name));
				dict_set(conf->sc_ssl_dict, pki_ssl->ssl_name, pki_ssl);
d1455 1
a1455 1
		log_warnx("%s: group writable or world read/writable", fname);
d1529 1
d1539 1
a1539 1
	    conf->sc_ssl_dict == NULL		||
d1545 1
d1558 1
a1737 3
	if (lo->ssl && !lo->pki)
		errx(1, "invalid listen option: tls/smtps requires pki");

d1778 1
a1778 2
	h->ssl = NULL;
	h->ssl_cert_name[0] = '\0';
d1783 1
a1783 2
		if (! lowercase(h->ssl_cert_name, lo->pki,
		    sizeof(h->ssl_cert_name))) {
d1787 1
a1787 1
		if (dict_get(conf->sc_ssl_dict, h->ssl_cert_name) == NULL) {
d1856 1
a1856 1
	hints.ai_socktype = SOCK_DGRAM; /* DUMMY */
@


1.135
log
@bcopy -> memmove
bzero -> memset
@
text
@d1454 2
a1455 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("warn: %s: group/world readable/writeable", fname);
@


1.134
log
@bogus ';'
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d532 1
a532 1
			bzero(conf->sc_bounce_warn, sizeof conf->sc_bounce_warn);
d546 1
a546 1
			bzero(password, strlen(password));
d610 2
a611 2
			bzero(&l, sizeof l);
			bzero(&listen_opts, sizeof listen_opts);
d1520 1
a1520 1
	bzero(conf, sizeof(*conf));
d1812 1
a1812 1
	bzero(&ina, sizeof(ina));
d1833 1
a1833 1
	bzero(&ina6, sizeof(ina6));
d1856 1
a1856 1
	bzero(&hints, sizeof(hints));
@


1.133
log
@do not hardcode scheduler batch size, and reduce default limit to avoid
hammering effects.
@
text
@a631 1
		;
@


1.132
log
@limit the number of envelopes to recall in the hoststat cache.
@
text
@d312 9
d1573 3
@


1.131
log
@use u_char for buffers in yylex, for ctype calls, as done in all other
parse.y in the tree
issue found by millert, ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.130 2013/11/21 08:52:57 eric Exp $	*/
d144 1
a144 1
%token	AS QUEUE COMPRESSION ENCRYPTION MAXMESSAGESIZE LISTEN ON ANY PORT EXPIRE
d580 3
d1150 1
d1562 1
@


1.130
log
@correctly set verify flag on the listener
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1186 1
a1186 1
char	*parsebuf;
d1188 1
a1188 1
char	 pushback_buffer[MAXPUSHBACK];
d1279 2
a1280 2
	char	 buf[8096];
	char	*p, *val;
d1303 1
a1303 1
				*p++ = (char)c;
d1348 1
a1348 1
			*p++ = (char)c;
@


1.129
log
@Rework the mda and scheduler to use the holdq mechanism instead of
tempfail for limiting the number of pending deliveries to the same
user.  This allows to reach optimal delivery time even in case of
burst, while keeping the number of inflight envelopes low.
@
text
@a1723 1

d1784 3
@


1.128
log
@Add a limit on the number of inflight envelopes.  The scheduler suspends
scheduling of mta/mda envelopes until the number of inflight envelopes
falls below that line.
@
text
@d259 29
d580 1
d1559 6
@


1.127
log
@Fix case-folding issue with pki names. They are case-insensitive.
Make sure a pki entry exists when used in a listen or relay rule.
@
text
@d147 1
a147 1
%token	ACCEPT REJECT INCLUDE ERROR MDA FROM FOR SOURCE MTA PKI
d259 1
a259 1
opt_limit	: INET4 {
d267 1
a267 1
				yyerror("invalid limit keyword");
d275 18
a292 1
limits		: opt_limit limits
d562 1
a562 1
		} limits
d565 2
a566 1
		} limits
d1127 1
d1527 2
@


1.126
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d411 12
a422 4
			if (strlcpy(rule->r_value.relayhost.cert, $2,
				sizeof(rule->r_value.relayhost.cert))
			    >= sizeof(rule->r_value.relayhost.cert))
				fatal("certificate path too long");
d574 4
a577 1
			pki_ssl = dict_get(conf->sc_ssl_dict, $2);
d580 1
a580 1
				xlowercase(pki_ssl->ssl_name, $2, sizeof pki_ssl->ssl_name);
a582 1
			free($2);
d1711 11
a1721 2
	if (lo->pki != NULL)
		(void)strlcpy(h->ssl_cert_name, lo->pki, sizeof(h->ssl_cert_name));
@


1.125
log
@Make the filter infrastructure move forward.
This is a work-in-progress and it's not supposed to be useable for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.124 2013/10/25 21:31:23 eric Exp $	*/
d53 2
d56 1
d99 18
d120 3
a122 6
int		 host_dns(const char *, const char *, const char *,
		    struct listenerlist *, int, in_port_t, uint8_t);
int		 host(const char *, const char *, const char *,
    struct listenerlist *, int, in_port_t, const char *, uint8_t, const char *);
int		 interface(const char *, int, const char *, const char *,
    struct listenerlist *, int, in_port_t, const char *, uint8_t, const char *);
d145 5
a149 5
%token	TABLE SSL SMTPS CERTIFICATE DOMAIN BOUNCEWARN LIMIT INET4 INET6
%token  RELAY BACKUP VIA DELIVER TO LMTP MAILDIR MBOX HOSTNAME HELO
%token	ACCEPT REJECT INCLUDE ERROR MDA FROM FOR SOURCE MTA
%token	ARROW AUTH TLS LOCAL VIRTUAL TAG TAGGED ALIAS FILTER FILTERCHAIN KEY
%token	AUTH_OPTIONAL TLS_REQUIRE USERBASE SENDER
d153 3
a155 4
%type	<v.number>	port auth ssl size expire address_family
%type	<v.table>	tables tablenew tableref destination alias virtual usermapping userbase credentials from sender
%type	<v.maddr>	relay_as
%type	<v.string>	certificate tag tagged relay_source listen_helo relay_helo relay_backup
d223 77
a299 1
port		: PORT STRING			{
d309 1
a309 1
			$$ = ntohs(servent->s_port);
d316 14
a329 1
			$$ = $2;
d331 3
a333 2
		| /* empty */			{
			$$ = 0;
d335 3
a337 5
		;

certificate	: CERTIFICATE STRING	{
			if (($$ = strdup($2)) == NULL) {
				yyerror("strdup");
d341 11
a351 1
			free($2);
d353 1
a353 1
		| /* empty */			{ $$ = NULL; }
d356 2
a357 5
ssl		: SMTPS				{ $$ = F_SMTPS; }
		| TLS				{ $$ = F_STARTTLS; }
		| SSL				{ $$ = F_SSL; }
		| TLS_REQUIRE			{ $$ = F_STARTTLS|F_STARTTLS_REQUIRE; }
		| /* Empty */			{ $$ = 0; }
d360 2
a361 16
auth		: AUTH				{
			$$ = F_AUTH|F_AUTH_REQUIRE;
		}
		| AUTH_OPTIONAL			{
			$$ = F_AUTH;
		}
		| AUTH tables  			{
			strlcpy(l.authtable, ($2)->t_name, sizeof l.authtable);
			$$ = F_AUTH|F_AUTH_REQUIRE;
		}
		| AUTH_OPTIONAL tables 		{
			strlcpy(l.authtable, ($2)->t_name, sizeof l.authtable);
			$$ = F_AUTH;
		}
		| /* empty */			{ $$ = 0; }
		;
d363 2
a364 3
tag		: TAG STRING			{
       			if (strlen($2) >= MAX_TAG_SIZE) {
       				yyerror("tag name too long");
d368 1
d370 14
a383 1
			$$ = $2;
d385 5
a389 7
		| /* empty */			{ $$ = NULL; }
		;

tagged		: TAGGED STRING			{
			if (($$ = strdup($2)) == NULL) {
       				yyerror("strdup");
				free($2);
d392 6
d400 5
a404 8
		| /* empty */			{ $$ = NULL; }
		;

expire		: EXPIRE STRING {
			$$ = delaytonum($2);
			if ($$ == -1) {
				yyerror("invalid expire delay: %s", $2);
				free($2);
d407 8
a416 1
		| /* empty */	{ $$ = conf->sc_qexpire; }
d419 16
a434 17
bouncedelay	: STRING {
			time_t	d;
			int	i;

			d = delaytonum($1);
			if (d < 0) {
				yyerror("invalid bounce delay: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			for (i = 0; i < MAX_BOUNCE_WARN; i++) {
				if (conf->sc_bounce_warn[i] != 0)
					continue;
				conf->sc_bounce_warn[i] = d;
				break;
			}
d436 1
d438 3
a440 3
bouncedelays	: bouncedelays ',' bouncedelay
		| bouncedelay
		| /* EMPTY */
d443 1
a443 1
credentials	: AUTH tables	{
d451 2
a452 20

			$$ = t;
		}
		| /* empty */	{ $$ = 0; }
		;

address_family	: INET4			{ $$ = AF_INET; }
		| INET6			{ $$ = AF_INET6; }
		| /* empty */		{ $$ = AF_UNSPEC; }
		;

listen_helo	: HOSTNAME STRING	{ $$ = $2; }
		| /* empty */		{ $$ = NULL; }
		;

opt_limit	: INET4 {
			limits->family = AF_INET;
		}
		| INET6 {
			limits->family = AF_INET6;
d454 3
a456 4
		| STRING NUMBER {
			if (!limit_mta_set(limits, $1, $2)) {
				yyerror("invalid limit keyword");
				free($1);
d459 1
a459 1
			free($1);
d463 2
a464 1
limits		: opt_limit limits
d474 17
d492 20
a512 1
			conf->sc_queue_key = $4;
d543 5
a547 52
		} ON STRING address_family port ssl certificate auth tag listen_helo {
			char	       *ifx  = $4;
			int		family = $5;
			in_port_t	port = $6;
			uint8_t		ssl  = $7;
			char	       *cert = $8;
			uint8_t		auth = $9;
			char	       *tag  = $10;
			char	       *helo = $11;

			if (port != 0 && ssl == F_SSL) {
				yyerror("invalid listen option: tls/smtps on same port");
				YYERROR;
			}

			if (auth != 0 && !ssl) {
				yyerror("invalid listen option: auth requires tls/smtps");
				YYERROR;
			}

			if (port == 0) {
				if (ssl & F_SMTPS) {
					if (! interface(ifx, family, tag, cert, conf->sc_listeners,
						MAX_LISTEN, 465, l.authtable, F_SMTPS|auth, helo)) {
						if (host(ifx, tag, cert, conf->sc_listeners,
							MAX_LISTEN, 465, l.authtable, ssl|auth, helo) <= 0) {
							yyerror("invalid virtual ip or interface: %s", ifx);
							YYERROR;
						}
					}
				}
				if (! ssl || (ssl & ~F_SMTPS)) {
					if (! interface(ifx, family, tag, cert, conf->sc_listeners,
						MAX_LISTEN, 25, l.authtable, (ssl&~F_SMTPS)|auth, helo)) {
						if (host(ifx, tag, cert, conf->sc_listeners,
							MAX_LISTEN, 25, l.authtable, ssl|auth, helo) <= 0) {
							yyerror("invalid virtual ip or interface: %s", ifx);
							YYERROR;
						}
					}
				}
			}
			else {
				if (! interface(ifx, family, tag, cert, conf->sc_listeners,
					MAX_LISTEN, port, l.authtable, ssl|auth, helo)) {
					if (host(ifx, tag, cert, conf->sc_listeners,
						MAX_LISTEN, port, l.authtable, ssl|auth, helo) <= 0) {
						yyerror("invalid virtual ip or interface: %s", ifx);
						YYERROR;
					}
				}
			}
d565 10
a712 1

d718 4
d723 1
a723 1
			$$ = $1;
d726 4
d731 1
a731 5
			$$ = $1;
		}
		| /**/		{
			rule->r_desttype = DEST_DOM;
			$$ = 0;
d738 4
d747 1
a747 76

			$$ = t;
		}
		| /**/	{ $$ = table_find("<getpwnam>", NULL); }
		;

		


destination	: DOMAIN tables			{
			struct table   *t = $2;

			if (! table_check_use(t, T_DYNAMIC|T_LIST, K_DOMAIN)) {
				yyerror("invalid use of table \"%s\" as DOMAIN parameter",
				    t->t_name);
				YYERROR;
			}

			$$ = t;
		}
		| LOCAL		{ $$ = table_find("<localnames>", NULL); }
		| ANY		{ $$ = 0; }
		;

relay_source	: SOURCE tables			{
			struct table	*t = $2;
			if (! table_check_use(t, T_DYNAMIC|T_LIST, K_SOURCE)) {
				yyerror("invalid use of table \"%s\" as "
				    "SOURCE parameter", t->t_name);
				YYERROR;
			}
			$$ = t->t_name;
		}
		| { $$ = NULL; }
		;

relay_helo	: HELO tables			{
			struct table	*t = $2;
			if (! table_check_use(t, T_DYNAMIC|T_HASH, K_ADDRNAME)) {
				yyerror("invalid use of table \"%s\" as "
				    "HELO parameter", t->t_name);
				YYERROR;
			}
			$$ = t->t_name;
		}
		| { $$ = NULL; }
		;

relay_backup	: BACKUP STRING			{ $$ = $2; }
		| BACKUP       			{ $$ = NULL; }
		;

relay_as     	: AS STRING		{
			struct mailaddr maddr, *maddrp;

			if (! text_to_mailaddr(&maddr, $2)) {
				yyerror("invalid parameter to AS: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			if (maddr.user[0] == '\0' && maddr.domain[0] == '\0') {
				yyerror("invalid empty parameter to AS");
				YYERROR;
			}
			else if (maddr.domain[0] == '\0') {
				if (strlcpy(maddr.domain, conf->sc_hostname,
					sizeof (maddr.domain))
				    >= sizeof (maddr.domain)) {
					yyerror("hostname too long for AS parameter: %s",
					    conf->sc_hostname);
					YYERROR;
				}
			}
			$$ = xmemdup(&maddr, sizeof (*maddrp), "parse relay_as: AS");
a748 1
		| /* empty */		{ $$ = NULL; }
d751 1
a751 2
action		: userbase DELIVER TO MAILDIR			{
			rule->r_userbase = $1;
d758 1
a758 2
		| userbase DELIVER TO MAILDIR STRING		{
			rule->r_userbase = $1;
d760 1
a760 1
			if (strlcpy(rule->r_value.buffer, $5,
d764 1
a764 1
			free($5);
d766 1
a766 2
		| userbase DELIVER TO LMTP STRING		{
			rule->r_userbase = $1;
d768 2
a769 2
			if (strchr($5, ':') || $5[0] == '/') {
				if (strlcpy(rule->r_value.buffer, $5,
d775 1
a775 1
			free($5);
d777 1
a777 2
		| userbase DELIVER TO MBOX			{
			rule->r_userbase = $1;
d784 1
a784 2
		| userbase DELIVER TO MDA STRING	       	{
			rule->r_userbase = $1;
d786 1
a786 1
			if (strlcpy(rule->r_value.buffer, $5,
d790 1
a790 1
			free($5);
d792 3
a794 1
		| RELAY relay_as relay_source relay_helo	{
a795 7
			rule->r_as = $2;
			if ($3)
				strlcpy(rule->r_value.relayhost.sourcetable, $3,
				    sizeof rule->r_value.relayhost.sourcetable);
			if ($4)
				strlcpy(rule->r_value.relayhost.helotable, $4,
				    sizeof rule->r_value.relayhost.helotable);
d797 1
a797 24
		| RELAY relay_backup relay_as relay_source relay_helo	{
			rule->r_action = A_RELAY;
			rule->r_as = $3;
			rule->r_value.relayhost.flags |= F_BACKUP;

			if ($2)
				strlcpy(rule->r_value.relayhost.hostname, $2,
				    sizeof (rule->r_value.relayhost.hostname));
			else
				strlcpy(rule->r_value.relayhost.hostname,
				    env->sc_hostname,
				    sizeof (rule->r_value.relayhost.hostname));
			free($2);

			if ($4)
				strlcpy(rule->r_value.relayhost.sourcetable, $4,
				    sizeof rule->r_value.relayhost.sourcetable);
			if ($5)
				strlcpy(rule->r_value.relayhost.helotable, $5,
				    sizeof rule->r_value.relayhost.helotable);
		}
		| RELAY VIA STRING certificate credentials relay_as relay_source relay_helo {
			struct table	*t;

a798 2
			rule->r_as = $6;

a801 2
				free($4);
				free($6);
d805 1
a805 1

d808 1
a808 1
				if (! $5) {
a809 2
					free($4);
					free($6);
a811 3
				t = $5;
				strlcpy(rule->r_value.relayhost.authtable, t->t_name,
				    sizeof(rule->r_value.relayhost.authtable));
d813 2
d816 2
a817 15
			if ($4 != NULL) {
				if (strlcpy(rule->r_value.relayhost.cert, $4,
					sizeof(rule->r_value.relayhost.cert))
				    >= sizeof(rule->r_value.relayhost.cert))
					fatal("certificate path too long");
			}
			free($4);

			if ($7)
				strlcpy(rule->r_value.relayhost.sourcetable, $7,
				    sizeof rule->r_value.relayhost.sourcetable);
			if ($8)
				strlcpy(rule->r_value.relayhost.helotable, $8,
				    sizeof rule->r_value.relayhost.helotable);
		}
d820 2
a821 2
from		: FROM tables			{
			struct table   *t = $2;
d823 4
d832 23
d856 11
a866 1
			$$ = t;
d868 7
a874 2
		| FROM ANY			{
			$$ = table_find("<anyhost>", NULL);
d876 7
a882 2
		| FROM LOCAL			{
			$$ = table_find("<localhost>", NULL);
d884 17
a900 2
		| /* empty */			{
			$$ = table_find("<localhost>", NULL);
d904 7
a910 2
sender		: SENDER tables			{
			struct table   *t = $2;
d913 1
a913 1
				yyerror("invalid use of table \"%s\" as SENDER parameter",
d917 13
d931 12
a942 1
			$$ = t;
d944 30
a973 1
		| /* empty */			{ $$ = NULL; }
d978 1
a978 2
		 } tagged from sender FOR destination usermapping action expire {

d980 14
a993 9
			rule->r_sources = $4;
			rule->r_senders = $5;
			rule->r_destination = $7;
			rule->r_mapping = $8;
			if ($3) {
				if (strlcpy(rule->r_tag, $3, sizeof rule->r_tag)
				    >= sizeof rule->r_tag) {
					yyerror("tag name too long: %s", $3);
					free($3);
d996 2
a997 20
				free($3);
			}
			rule->r_qexpire = $10;

			if (rule->r_mapping && rule->r_desttype == DEST_VDOM) {
				enum table_type type;

				switch (rule->r_action) {
				case A_RELAY:
				case A_RELAYVIA:
					type = T_LIST;
					break;
				default:
					type = T_HASH;
					break;
				}
				if (! table_check_service(rule->r_mapping, K_ALIAS) &&
				    ! table_check_type(rule->r_mapping, type)) {
					yyerror("invalid use of table \"%s\" as VIRTUAL parameter",
					    rule->r_mapping->t_name);
d1001 4
a1004 1

a1005 1

a1009 1
		} tagged from sender FOR destination usermapping {
d1011 6
a1016 13
			rule->r_sources = $4;
			rule->r_senders = $5;
			rule->r_destination = $7;
			rule->r_mapping = $8;
			if ($3) {
				if (strlcpy(rule->r_tag, $3, sizeof rule->r_tag)
				    >= sizeof rule->r_tag) {
					yyerror("tag name too long: %s", $3);
					free($3);
					YYERROR;
				}
				free($3);
			}
d1063 1
d1067 1
d1074 1
a1075 1
		{ "helo",		HELO },
d1077 1
d1087 1
d1093 1
d1096 1
d1099 1
a1102 1
		{ "ssl",		SSL },
d1110 1
d1451 2
d1515 4
a1555 3
	if (strlen(conf->sc_hostname) == 0)
		strlcpy(conf->sc_hostname, hostname, sizeof conf->sc_hostname);

d1638 73
d1754 1
a1754 2
host_dns(const char *s, const char *tag, const char *cert,
    struct listenerlist *al, int max, in_port_t port, uint8_t flags)
d1765 1
a1765 1
	error = getaddrinfo(s, NULL, &hints, &res0);
d1769 1
a1769 1
		log_warnx("warn: host_dns: could not parse \"%s\": %s", s,
d1774 1
a1774 1
	for (res = res0; res && cnt < max; res = res->ai_next) {
a1779 2
		h->port = port;
		h->flags = flags;
a1780 7
		h->ssl = NULL;
		h->ssl_cert_name[0] = '\0';
		if (cert != NULL)
			(void)strlcpy(h->ssl_cert_name, cert, sizeof(h->ssl_cert_name));
		if (tag != NULL)
			(void)strlcpy(h->tag, tag, sizeof(h->tag));

d1786 1
a1786 1
			sain->sin_port = port;
d1792 1
a1792 1
			sin6->sin6_port = port;
d1795 2
d1800 1
a1800 4
	if (cnt == max && res) {
		log_warnx("warn: host_dns: %s resolves to more than %d hosts",
		    s, max);
	}
d1806 1
a1806 3
host(const char *s, const char *tag, const char *cert, struct listenerlist *al,
    int max, in_port_t port, const char *authtable, uint8_t flags,
    const char *helo)
d1810 1
a1810 3
	port = htons(port);

	h = host_v4(s, port);
d1814 1
a1814 1
		h = host_v6(s, port);
d1817 1
a1817 16
		h->port = port;
		h->flags = flags;
		if (h->flags & F_SSL)
			if (cert == NULL)
				cert = s;
		h->ssl = NULL;
		h->ssl_cert_name[0] = '\0';
		if (authtable != NULL)
			(void)strlcpy(h->authtable, authtable, sizeof(h->authtable));
		if (cert != NULL)
			(void)strlcpy(h->ssl_cert_name, cert, sizeof(h->ssl_cert_name));
		if (tag != NULL)
			(void)strlcpy(h->tag, tag, sizeof(h->tag));
		if (helo != NULL)
			(void)strlcpy(h->helo, helo, sizeof(h->helo));

d1822 1
a1822 1
	return (host_dns(s, tag, cert, al, max, port, flags));
d1826 1
a1826 3
interface(const char *s, int family, const char *tag, const char *cert,
    struct listenerlist *al, int max, in_port_t port, const char *authtable, uint8_t flags,
    const char *helo)
d1832 1
a1832 3
	int ret = 0;

	port = htons(port);
d1840 2
a1841 2
		if (strcmp(p->ifa_name, s) != 0 &&
		    ! is_if_in_group(p->ifa_name, s))
d1843 1
a1843 1
		if (family != AF_UNSPEC && family != p->ifa_addr->sa_family)
d1853 1
a1853 1
			sain->sin_port = port;
d1860 1
a1860 1
			sin6->sin6_port = port;
d1868 1
a1868 16
		h->fd = -1;
		h->port = port;
		h->flags = flags;
		if (h->flags & F_SSL)
			if (cert == NULL)
				cert = s;
		h->ssl = NULL;
		h->ssl_cert_name[0] = '\0';
		if (authtable != NULL)
			(void)strlcpy(h->authtable, authtable, sizeof(h->authtable));
		if (cert != NULL)
			(void)strlcpy(h->ssl_cert_name, cert, sizeof(h->ssl_cert_name));
		if (tag != NULL)
			(void)strlcpy(h->tag, tag, sizeof(h->tag));
		if (helo != NULL)
			(void)strlcpy(h->helo, helo, sizeof(h->helo));
a2007 1

@


1.124
log
@local enqueuer improvements:

- parse the whole input before trying to establish the connection
  to the local socket: fixes timeout problems when reading the output
  of a long running program.

- use sendmail(8)-like exit status.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.123 2013/07/19 21:14:52 eric Exp $	*/
d91 1
d109 4
d130 1
a130 1
%token	ARROW AUTH TLS LOCAL VIRTUAL TAG TAGGED ALIAS FILTER KEY
d459 2
a460 8
		| FILTER STRING			{
			struct filter *filter;
			struct filter *tmp;

			filter = xcalloc(1, sizeof *filter, "parse condition: FILTER");
			if (strlcpy(filter->name, $2, sizeof (filter->name))
			    >= sizeof (filter->name)) {
       				yyerror("Filter name too long: %s", filter->name);
d462 1
a462 14
				free(filter);
				YYERROR;
				
			}
			(void)snprintf(filter->path, sizeof filter->path,
			    PATH_FILTERS "/%s", filter->name);

			tmp = dict_get(&conf->sc_filters, filter->name);
			if (tmp == NULL)
				dict_set(&conf->sc_filters, filter->name, filter);
			else {
       				yyerror("ambiguous filter name: %s", filter->name);
				free($2);
				free(filter);
d466 1
d468 2
a469 22
		| FILTER STRING STRING		{
			struct filter *filter;
			struct filter *tmp;

			filter = calloc(1, sizeof (*filter));
			if (filter == NULL ||
			    strlcpy(filter->name, $2, sizeof (filter->name))
			    >= sizeof (filter->name) ||
			    strlcpy(filter->path, $3, sizeof (filter->path))
			    >= sizeof (filter->path)) {
				free(filter);
				free($2);
				free($3);
				free(filter);
				YYERROR;
			}

			tmp = dict_get(&conf->sc_filters, filter->name);
			if (tmp == NULL)
				dict_set(&conf->sc_filters, filter->name, filter);
			else {
       				yyerror("ambiguous filter name: %s", filter->name);
a470 2
				free($3);
				free(filter);
d473 1
a473 3
			free($2);
			free($3);
		}
d546 9
d992 1
d1895 67
@


1.123
log
@Many MTA improvements:

- Better transient error handling logic: failing destinations are
  automatically disabled for a while.  When a destination is active
  again, ask the scheduler to retry previous envelopes immediatly.
- More informative error report when all routes fail for a mail.
- Implement a "smtpctl show hoststats" command to get the latest stat
  message per MX domain.
- Implement a "smtpctl show routes" command to show the state the
  currently known routes to remote MXs.
- Implement a "smtpctl resume route" command to re-enable a route that
  has been disabled.
- Do not hardcode limits
- Minor code improvements
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a106 1
int		 getmailname(char *, size_t);
a1920 69
	return ret;
}

int
getmailname(char *hostname, size_t len)
{
	struct addrinfo	hints, *res = NULL;
	FILE   *fp;
	char   *buf, *lbuf = NULL;
	size_t	buflen;
	int	error;
	int	ret = 0;

	/* First, check if we have "/etc/mailname" */
	if ((fp = fopen("/etc/mailname", "r")) == NULL)
		goto nomailname;

	if ((buf = fgetln(fp, &buflen)) == NULL)
		goto end;

	if (buf[buflen-1] == '\n')
		buf[buflen - 1] = '\0';
	else {
		if ((lbuf = calloc(buflen + 1, 1)) == NULL)
			err(1, "calloc");
		memcpy(lbuf, buf, buflen);
	}

	if (strlcpy(hostname, buf, len) >= len)
		fprintf(stderr, "/etc/mailname entry too long");
	else {
		ret = 1;
		goto end;
	}
	

nomailname:
	if (gethostname(hostname, len) == -1) {
		fprintf(stderr, "invalid hostname: gethostname() failed\n");
		goto end;
	}

	if (strchr(hostname, '.') == NULL) {
		memset(&hints, 0, sizeof hints);
		hints.ai_family = PF_UNSPEC;
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_protocol = IPPROTO_TCP;
		hints.ai_flags = AI_CANONNAME;
		error = getaddrinfo(hostname, NULL, &hints, &res);
		if (error) {
			fprintf(stderr, "invalid hostname: getaddrinfo() failed: %s\n",
			    gai_strerror(error));
			goto end;
		}
		
		if (strlcpy(hostname, res->ai_canonname, len) >= len) {
			fprintf(stderr, "hostname too long");
			goto end;
		}
	}

	ret = 1;

end:
	free(lbuf);
	if (res)
		freeaddrinfo(res);
	if (fp)
		fclose(fp);
@


1.122
log
@Assorted queue improvements:
- cleanup the internal queue backend API and get rid of the QOP_* thing.
- implement a queue_proc backend
- rename queue_fsqueue.c to queue_fs
- enable support for queue encryption
- add an envelope cache
- better logging and error reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.121 2013/07/19 19:53:33 eric Exp $	*/
d94 1
d123 1
a123 1
%token	TABLE SSL SMTPS CERTIFICATE DOMAIN BOUNCEWARN INET4 INET6
d125 1
a125 1
%token	ACCEPT REJECT INCLUDE ERROR MDA FROM FOR SOURCE
d343 20
d385 15
d1029 1
d1037 1
d1400 1
d1408 2
a1409 1
	    conf->sc_ssl_dict == NULL) {
d1415 1
d1428 5
@


1.121
log
@Add a table_proc backend for delegating table lookups to another
process.  Stop building experimental table_sqlite and table_ldap as
they will be provided as external backends.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.120 2013/07/19 19:10:22 eric Exp $	*/
d121 1
a121 1
%token	AS QUEUE COMPRESSION MAXMESSAGESIZE LISTEN ON ANY PORT EXPIRE
d348 4
d982 1
@


1.120
log
@Allow to specify an address family on a listener
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.119 2013/07/19 13:11:18 eric Exp $	*/
d489 1
d597 1
a597 1
			if (! table_check_service(t, K_ALIAS)) {
d755 1
a755 1
		| RELAY relay_as relay_source relay_helo       	{
@


1.119
log
@Improve and document the way the default server name is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.118 2013/06/03 08:48:40 zhuk Exp $	*/
d101 1
a101 1
int		 interface(const char *, const char *, const char *,
d122 1
a122 1
%token	TABLE SSL SMTPS CERTIFICATE DOMAIN BOUNCEWARN
d130 1
a130 1
%type	<v.number>	port auth ssl size expire
d333 5
d340 1
d362 1
a362 1
		} ON STRING port ssl certificate auth tag listen_helo {
d364 7
a370 6
			in_port_t	port = $5;
			uint8_t		ssl  = $6;
			char	       *cert = $7;
			uint8_t		auth = $8;
			char	       *tag  = $9;
			char	       *helo = $10;
d384 1
a384 1
					if (! interface(ifx, tag, cert, conf->sc_listeners,
d394 1
a394 1
					if (! interface(ifx, tag, cert, conf->sc_listeners,
d405 1
a405 1
				if (! interface(ifx, tag, cert, conf->sc_listeners,
d984 2
d1671 1
a1671 1
interface(const char *s, const char *tag, const char *cert,
d1691 2
@


1.118
log
@No need to set backend var here, it's always set before to the same value.

okay gilles@@, eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.117 2013/05/24 17:03:14 eric Exp $	*/
d106 1
d1333 1
d1335 1
a1335 2
	if (gethostname(hostname, sizeof hostname) == -1) {
		fprintf(stderr, "invalid hostname: gethostname() failed\n");
a1336 1
	}
d1395 7
d1433 1
a1433 6
		if (gethostname(conf->sc_hostname,
		    sizeof(conf->sc_hostname)) == -1) {
			log_warn("warn: could not determine host name");
			bzero(conf->sc_hostname, sizeof(conf->sc_hostname));
			errors++;
		}
d1859 69
@


1.117
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.116 2013/03/06 21:42:40 sthen Exp $	*/
a480 1
					backend = $3;
@


1.116
log
@as done in ospf{,6}d/relayd, sync yyerror in various other daemons with
that from bgpd, so that it logs to syslog when daemonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.115 2013/02/17 12:28:30 gilles Exp $	*/
a27 1
#include <sys/param.h>
d110 1
a110 1
		objid_t		 object;
d122 1
a122 1
%token  RELAY BACKUP VIA DELIVER TO MAILDIR MBOX HOSTNAME HELO
d129 2
a130 2
%type	<v.number>	port from auth ssl size expire sender
%type	<v.object>	tables tablenew tableref destination alias virtual usermapping userbase credentials
d249 1
a249 1
			strlcpy(l.authtable, table_find($2)->t_name, sizeof l.authtable);
d253 1
a253 1
			strlcpy(l.authtable, table_find($2)->t_name, sizeof l.authtable);
d319 1
a319 1
			struct table   *t = table_find($2);
d327 1
a327 1
			$$ = t->t_id;
d338 3
d492 2
a493 2
			table = table_create(backend, $2, config);
			if (! table->t_backend->config(table, config)) {
d504 1
a504 1
			table = table_create("static", $2, NULL);
d543 1
a543 1
			t = table_create("static", NULL, NULL);
d547 1
a547 2
			$$ = t->t_id;
			table = table_create("static", NULL, NULL);
d550 1
a550 1
			table = table_create("static", NULL, NULL);
d552 1
a552 1
			$$ = table->t_id;
d559 1
a559 1
			if ((t = table_findbyname($2)) == NULL) {
d565 1
a565 1
			$$ = t->t_id;
d574 1
a574 1
			struct table   *t = table_find($2);
d582 1
a582 1
			$$ = t->t_id;
d587 1
a587 1
			struct table   *t = table_find($2);
d595 1
a595 1
			$$ = t->t_id;
d614 1
a614 1
			struct table   *t = table_find($2);
d622 1
a622 1
			$$ = t->t_id;
d624 1
a624 1
		| /**/	{ $$ = table_findbyname("<getpwnam>")->t_id; }
d631 1
a631 1
			struct table   *t = table_find($2);
d639 1
a639 1
			$$ = t->t_id;
d641 1
a641 1
		| LOCAL		{ $$ = table_findbyname("<localnames>")->t_id; }
d646 1
a646 1
			struct table	*t = table_find($2);
d658 1
a658 1
			struct table	*t = table_find($2);
d702 1
a702 1
			rule->r_userbase = table_find($1);
d710 1
a710 1
			rule->r_userbase = table_find($1);
d718 12
d731 1
a731 1
			rule->r_userbase = table_find($1);
d739 1
a739 1
			rule->r_userbase = table_find($1);
a749 4
			if ($4 != NULL && $3 == NULL) {
				yyerror("HELO can only be used with SOURCE");
				YYERROR;
			}
d766 2
a767 1
				strlcpy(rule->r_value.relayhost.hostname, env->sc_hostname,
a770 4
			if ($5 != NULL && $4 == NULL) {
				yyerror("HELO can only be used with SOURCE");
				YYERROR;
			}
d801 1
a801 1
				t = table_find($5);
d813 1
a813 4
			if ($8 != NULL && $7 == NULL) {
				yyerror("HELO can only be used with SOURCE");
				YYERROR;
			}
d824 1
a824 1
			struct table   *t = table_find($2);
d832 1
a832 1
			$$ = t->t_id;
d835 1
a835 1
			$$ = table_findbyname("<anyhost>")->t_id;
d838 1
a838 1
			$$ = table_findbyname("<localhost>")->t_id;
d841 1
a841 1
			$$ = table_findbyname("<localhost>")->t_id;
d846 1
a846 1
			struct table   *t = table_find($2);
d854 1
a854 1
			$$ = t->t_id;
d856 1
a856 1
		| /* empty */			{ $$ = 0; }
d864 4
a867 4
			rule->r_sources = table_find($4);
			rule->r_senders = table_find($5);
			rule->r_destination = table_find($7);
			rule->r_mapping = table_find($8);
d907 4
a910 4
			rule->r_sources = table_find($4);
			rule->r_sources = table_find($5);
			rule->r_destination = table_find($7);
			rule->r_mapping = table_find($8);
d967 1
d979 1
d1332 1
a1332 1
	char		hostname[MAXHOSTNAMELEN];
a1344 1
	conf->sc_tables_tree = calloc(1, sizeof(*conf->sc_tables_tree));
a1352 1
	    conf->sc_tables_tree == NULL	||
a1357 1
		free(conf->sc_tables_tree);
a1372 1
	tree_init(conf->sc_tables_tree);
d1391 1
a1391 1
	t = table_create("static", "<localnames>", NULL);
d1396 1
a1396 1
	table_create("getpwnam", "<getpwnam>", NULL);
d1739 1
a1739 1
	t = table_create("static", "<anyhost>", NULL);
d1747 1
a1747 1
	t = table_create("static", "<localhost>", NULL);
@


1.115
log
@disable queue compression temporarily, we lack the smtpctl bits
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.114 2013/02/14 12:30:49 gilles Exp $	*/
d50 1
d932 1
d936 3
a938 3
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
d940 1
@


1.114
log
@- smtpctl trace expand, enables tracing of aliases expansion
- replace "users" keyword with "userbase" when providing alternate userbase
- disambiguise expansion nodes when expanding across domains and userbases
- allow use of '=' instead of '=>' when declaring a mapping

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.113 2013/02/05 15:30:59 gilles Exp $	*/
d132 1
a132 1
%type	<v.string>	certificate tag tagged compression relay_source listen_helo relay_helo relay_backup
a331 10
compression	: COMPRESSION		{
			$$ = strdup("gzip");
			if ($$ == NULL) {
				yyerror("strdup");
				YYERROR;
			}
		}
		| COMPRESSION STRING	{ $$ = $2; }
		;

d335 1
a335 11
main		: QUEUE compression {
			conf->sc_queue_compress_algo = strdup($2);
			if (conf->sc_queue_compress_algo == NULL) {
				yyerror("strdup");
				free($2);
				YYERROR;
			}
			conf->sc_queue_flags |= QUEUE_COMPRESS;
			free($2);
		}
		| BOUNCEWARN {
a960 1
		{ "compression",       	COMPRESSION },
@


1.113
log
@add missing free in config parser

ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.112 2013/01/28 15:14:02 gilles Exp $	*/
d125 1
a125 1
%token	AUTH_OPTIONAL TLS_REQUIRE USERS SENDER
d528 3
a530 1
keyval		: STRING ARROW STRING		{
d631 1
a631 1
userbase	: USERS tables	{
d635 1
a635 1
				yyerror("invalid use of table \"%s\" as USERS parameter",
d720 1
a720 1
			rule->r_users = table_find($1);
d728 1
a728 1
			rule->r_users = table_find($1);
d737 1
a737 1
			rule->r_users = table_find($1);
d745 1
a745 1
			rule->r_users = table_find($1);
d1013 1
a1013 1
		{ "users",     		USERS },
@


1.112
log
@allow lookups from backends in "accept for [...] virtual" context
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.111 2013/01/26 09:37:23 gilles Exp $	*/
d433 1
d446 1
d464 1
d475 1
@


1.111
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.110 2012/11/12 14:58:53 eric Exp $	*/
d901 2
a902 1
				if (! table_check_type(rule->r_mapping, type)) {
@


1.110
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.109 2012/10/14 11:58:23 gilles Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d91 1
a91 1
struct map		*map = NULL;
d93 1
a93 1
TAILQ_HEAD(condlist, cond) *conditions = NULL;
d100 1
a100 1
		    struct listenerlist *, int, in_port_t, uint8_t);
d102 1
a102 1
		    struct listenerlist *, int, in_port_t, uint8_t);
a110 2
		struct timeval	 tv;
		struct cond	*cond;
d120 6
a125 7
%token	AS QUEUE COMPRESSION SIZE LISTEN ON ANY PORT EXPIRE
%token	MAP HASH LIST SINGLE SSL SMTPS CERTIFICATE
%token	DB LDAP FILE DOMAIN SOURCE
%token  RELAY BACKUP VIA DELIVER TO MAILDIR MBOX HOSTNAME
%token	ACCEPT REJECT INCLUDE ERROR MDA FROM FOR
%token	ARROW AUTH TLS LOCAL VIRTUAL TAG ALIAS FILTER KEY
%token	AUTH_OPTIONAL TLS_REQUIRE
d128 3
a130 5
%type	<v.map>		map
%type	<v.number>	quantifier port from auth ssl size expire
%type	<v.cond>	condition
%type	<v.tv>		interval
%type	<v.object>	mapref
d132 1
a132 1
%type	<v.string>	certname tag on alias credentials compression
d140 1
a140 1
		| grammar map '\n'
a176 8
optlbracket    	: '{'
		|
		;

optrbracket    	: '}'
		|
		;

a179 16
quantifier      : /* empty */                   { $$ = 1; }  	 
		| 'm'                           { $$ = 60; } 	 
		| 'h'                           { $$ = 3600; } 	 
		| 'd'                           { $$ = 86400; } 	 
		;

interval	: NUMBER quantifier		{
			if ($1 < 0) {
				yyerror("invalid interval: %" PRId64, $1);
				YYERROR;
			}
			$$.tv_usec = 0;
			$$.tv_sec = $1 * $2;
		}
		;

d192 1
a195 1

d205 1
a205 1
				yyerror("port %s is invalid", $2);
a208 1
			$$ = servent->s_port;
d210 1
d217 1
a217 1
			$$ = htons($2);
d224 6
a229 3
certname	: CERTIFICATE STRING	{
			if (($$ = strdup($2)) == NULL)
				fatal(NULL);
d242 14
a255 2
auth		: AUTH  			{ $$ = F_AUTH|F_AUTH_REQUIRE; }
		| AUTH_OPTIONAL			{ $$ = F_AUTH; }
d271 11
d286 1
d294 30
a323 4
credentials	: AUTH STRING	{
			if ((map_findbyname($2)) == NULL) {
				yyerror("no such map: %s", $2);
				free($2);
d326 2
a327 1
			$$ = $2;
d332 6
a337 5
compression	: COMPRESSION STRING {
			$$ = $2;
		}
		| COMPRESSION {
			$$ = "gzip";
d339 1
a339 1
		| /* empty */	{ $$ = NULL; }
d342 3
d346 4
a349 8
			if ($2) {
				conf->sc_queue_flags |= QUEUE_COMPRESS;
				conf->sc_queue_compress_algo = strdup($2);
				log_debug("debug: queue compress using %s",
				    conf->sc_queue_compress_algo);
			}
			if ($2 == NULL) {
				yyerror("invalid queue compress <algo>");
d352 2
d355 3
d362 1
d365 1
d367 2
a368 2
	       	| SIZE size {
       			conf->sc_maxsize = $2;
d370 13
a382 10
		| LISTEN ON STRING port ssl certname auth tag {
			char		*cert;
			char		*tag;
			uint8_t		 flags;

			if ($5 == F_SSL) {
				yyerror("syntax error");
				free($8);
				free($6);
				free($3);
d386 2
a387 5
			if ($5 == 0 && ($6 != NULL || $7)) {
				yyerror("error: must specify tls or smtps");
				free($8);
				free($6);
				free($3);
d391 21
a411 5
			if ($4 == 0) {
				if ($5 == F_SMTPS)
					$4 = htons(465);
				else
					$4 = htons(25);
d413 14
d428 5
a432 8
			cert = ($6 != NULL) ? $6 : $3;
			flags = $5 | $7; /* ssl | auth */

			if ($5 && ssl_load_certfile(cert, F_SCERT) < 0) {
				yyerror("cannot load certificate: %s", cert);
				free($8);
				free($6);
				free($3);
d434 1
d436 2
d439 5
a443 24
			tag = $3;
			if ($8 != NULL)
				tag = $8;

			if (! interface($3, tag, cert, conf->sc_listeners,
				MAX_LISTEN, $4, flags)) {
				if (host($3, tag, cert, conf->sc_listeners,
					MAX_LISTEN, $4, flags) <= 0) {
					yyerror("invalid virtual ip or interface: %s", $3);
					free($8);
					free($6);
					free($3);
					YYERROR;
				}
			}
			free($8);
			free($6);
			free($3);
		}
		| HOSTNAME STRING		{
			if (strlcpy(conf->sc_hostname, $2,
			    sizeof(conf->sc_hostname)) >=
			    sizeof(conf->sc_hostname)) {
				yyerror("hostname truncated");
d448 1
a448 1
		}/*
d465 1
a465 4
			TAILQ_FOREACH(tmp, conf->sc_filters, f_entry) {
				if (strcasecmp(filter->name, tmp->name) == 0)
					break;
			}
d467 1
a467 1
				TAILQ_INSERT_TAIL(conf->sc_filters, filter, f_entry);
a476 1
		*/
d479 2
a480 27
mapsource	: SOURCE FILE STRING			{
			map->m_src = S_FILE;
			if (strlcpy(map->m_config, $3, sizeof(map->m_config))
			    >= sizeof(map->m_config))
				err(1, "pathname too long");
		}
		| STRING {
			map->m_src = S_FILE;
			if (strlcpy(map->m_config, $1, sizeof(map->m_config))
			    >= sizeof(map->m_config))
				err(1, "pathname too long");
		}
		| SOURCE DB STRING			{
			map->m_src = S_DB;
			if (strlcpy(map->m_config, $3, sizeof(map->m_config))
			    >= sizeof(map->m_config))
				err(1, "pathname too long");
		}
/*
		| SOURCE LDAP STRING			{
			map->m_src = S_LDAP;
			if (strlcpy(map->m_config, $3, sizeof(map->m_config))
			    >= sizeof(map->m_config))
				err(1, "pathname too long");
		}
*/
		;
d482 29
a510 10
mapopt		: mapsource		{ }

map		: MAP STRING			{
			map = map_create(S_NONE, $2);
			free($2);
		} optlbracket mapopt optrbracket	{
			if (map->m_src == S_NONE) {
				yyerror("map %s has no source defined", $2);
				free(map);
				map = NULL;
d513 8
a520 1
			map = NULL;
d525 2
a526 1
			map_add(map, $1, $3);
d537 2
a538 1
			map_add(map, $1, NULL);
d547 6
a552 2
mapref		: STRING			{
			struct map	*m;
d554 6
a559 8
			m = map_create(S_NONE, NULL);
			map_add(m, $1, NULL);
			$$ = m->m_id;
		}
		| '('				{
			map = map_create(S_NONE, NULL);
		} string_list ')'		{
			$$ = map->m_id;
d562 3
a564 3
			map = map_create(S_NONE, NULL);
		} keyval_list '}'		{
			$$ = map->m_id;
d566 4
a569 2
		| MAP STRING			{
			struct map	*m;
d571 2
a572 2
			if ((m = map_findbyname($2)) == NULL) {
				yyerror("no such map: %s", $2);
d577 1
a577 1
			$$ = m->m_id;
d581 2
a582 2
alias		: ALIAS STRING			{ $$ = $2; }
		| /* empty */			{ $$ = NULL; }
d585 2
a586 3
condition	: DOMAIN mapref	alias		{
			struct cond	*c;
			struct map	*m;
d588 4
a591 7
			if ($3) {
				if ((m = map_findbyname($3)) == NULL) {
					yyerror("no such map: %s", $3);
					free($3);
					YYERROR;
				}
				rule->r_amap = m->m_id;
d594 1
a594 4
			c = xcalloc(1, sizeof *c, "parse condition: DOMAIN");
			c->c_type = COND_DOM;
			c->c_map = $2;
			$$ = c;
d596 4
a599 3
		| VIRTUAL mapref		{
			struct cond	*c;
			struct map	*m;
d601 3
a603 3
			m = map_find($2);
			if (m->m_src == S_NONE) {
				yyerror("virtual parameter MUST be a map");
d607 1
a607 4
			c = xcalloc(1, sizeof *c, "parse condition: VIRTUAL");
			c->c_type = COND_VDOM;
			c->c_map = $2;
			$$ = c;
d609 1
a609 4
		| LOCAL alias {
			struct cond	*c;
			struct map	*m;
			char		 hostname[MAXHOSTNAMELEN];
d611 20
a630 2
			if (gethostname(hostname, sizeof hostname) == -1) {
				yyerror("gethostname() failed");
d634 7
a640 8
			if ($2) {
				if ((m = map_findbyname($2)) == NULL) {
					yyerror("no such map: %s", $2);
					free($2);
					YYERROR;
				}
				rule->r_amap = m->m_id;
			}
d642 2
a643 3
			m = map_create(S_NONE, NULL);
			map_add(m, "localhost", NULL);
			map_add(m, hostname, NULL);
d645 5
a649 3
			c = xcalloc(1, sizeof *c, "parse condition: LOCAL");
			c->c_type = COND_DOM;
			c->c_map = m->m_id;
d651 1
a651 1
			$$ = c;
d653 3
a655 3
		| ANY alias			{
			struct cond	*c;
			struct map	*m;
d657 6
a662 10
			c = xcalloc(1, sizeof *c, "parse condition: ANY");
			c->c_type = COND_ANY;

			if ($2) {
				if ((m = map_findbyname($2)) == NULL) {
					yyerror("no such map: %s", $2);
					free($2);
					YYERROR;
				}
				rule->r_amap = m->m_id;
d664 1
a664 1
			$$ = c;
d666 1
d669 8
a676 5
condition_list	: condition comma condition_list	{
			TAILQ_INSERT_TAIL(conditions, $1, c_entry);
		}
		| condition	{
			TAILQ_INSERT_TAIL(conditions, $1, c_entry);
d678 1
d681 2
a682 4
conditions	: condition				{
			TAILQ_INSERT_TAIL(conditions, $1, c_entry);
		}
		| '{' condition_list '}'
a686 1
			char *p;
d688 4
a691 36
			bzero(&maddr, sizeof (maddr));

			p = strrchr($2, '@@');
			if (p == NULL) {
				if (strlcpy(maddr.user, $2, sizeof (maddr.user))
				    >= sizeof (maddr.user))
					yyerror("user-part too long");
					free($2);
					YYERROR;
			}
			else {
				if (p == $2) {
					/* domain only */
					p++;
					if (strlcpy(maddr.domain, p, sizeof (maddr.domain))
					    >= sizeof (maddr.domain)) {
						yyerror("user-part too long");
						free($2);
						YYERROR;
					}
				}
				else {
					*p++ = '\0';
					if (strlcpy(maddr.user, $2, sizeof (maddr.user))
					    >= sizeof (maddr.user)) {
						yyerror("user-part too long");
						free($2);
						YYERROR;
					}
					if (strlcpy(maddr.domain, p, sizeof (maddr.domain))
					    >= sizeof (maddr.domain)) {
						yyerror("domain-part too long");
						free($2);
						YYERROR;
					}
				}
d693 1
d696 1
a696 2
				yyerror("invalid 'relay as' value");
				free($2);
d699 1
a699 2

			if (maddr.domain[0] == '\0') {
d703 2
a704 3
					fatalx("domain too long");
					yyerror("domain-part too long");
					free($2);
d708 1
a708 5
			
			maddrp = xmemdup(&maddr, sizeof (*maddrp), "parse relay_as: AS");
			free($2);

			$$ = maddrp;
d713 2
a714 1
action		: DELIVER TO MAILDIR			{
d721 2
a722 1
		| DELIVER TO MAILDIR STRING		{
d724 1
a724 1
			if (strlcpy(rule->r_value.buffer, $4,
d728 1
a728 1
			free($4);
d730 2
a731 1
		| DELIVER TO MBOX			{
d738 2
a739 1
		| DELIVER TO MDA STRING			{
d741 1
a741 1
			if (strlcpy(rule->r_value.buffer, $4,
d745 1
a745 1
			free($4);
d747 1
a747 1
		| RELAY relay_as     			{
d750 10
d761 1
a761 1
		| RELAY BACKUP STRING relay_as     		{
d763 1
a763 1
			rule->r_as = $4;
d765 19
a783 3
			strlcpy(rule->r_value.relayhost.hostname, $3,
			    sizeof (rule->r_value.relayhost.hostname));
			free($3);
d785 3
a787 1
		| RELAY VIA STRING certname credentials relay_as {
a794 1
				free($5);
d802 2
a803 2
				if ($5 == NULL) {
					yyerror("error: auth without authmap");
a804 1
					free($5);
d808 3
a810 2
				strlcpy(rule->r_value.relayhost.authmap, $5,
				    sizeof(rule->r_value.relayhost.authmap));
a811 2
			free($5);

a813 7
				if (ssl_load_certfile($4, F_CCERT) < 0) {
					yyerror("cannot load certificate: %s",
					    $4);
					free($4);
					free($6);
					YYERROR;
				}
d820 10
d833 10
a842 2
from		: FROM mapref			{
			$$ = $2;
d845 1
a845 1
			$$ = map_findbyname("<anyhost>")->m_id;
d848 1
a848 1
			$$ = map_findbyname("<localhost>")->m_id;
d851 1
a851 1
			$$ = map_findbyname("<localhost>")->m_id;
d855 6
a860 4
on		: ON STRING	{
       			if (strlen($2) >= MAX_TAG_SIZE) {
       				yyerror("interface, address or tag name too long");
				free($2);
d864 1
a864 1
			$$ = $2;
d866 1
a866 1
		| /* empty */	{ $$ = NULL; }
d869 3
a871 1
rule		: ACCEPT on from			{
a872 1
			rule = xcalloc(1, sizeof(*rule), "parse rule: ACCEPT");
d874 14
a887 1
			rule->r_sources = map_find($3);
d889 2
a890 2
			conditions = xcalloc(1, sizeof(*conditions),
			    "parse rule: ACCEPT");
d892 12
a903 34
			if ($2)
				(void)strlcpy(rule->r_tag, $2, sizeof(rule->r_tag));
			free($2);

			TAILQ_INIT(conditions);

		} FOR conditions action	tag expire {
			struct rule	*subr;
			struct cond	*cond;

			if ($8)
				(void)strlcpy(rule->r_tag, $8, sizeof(rule->r_tag));
			free($8);

			rule->r_qexpire = $9;

			while ((cond = TAILQ_FIRST(conditions)) != NULL) {

				subr = xmemdup(rule, sizeof(*subr), "parse rule: FOR");

				subr->r_condition = *cond;
				
				TAILQ_REMOVE(conditions, cond, c_entry);
				TAILQ_INSERT_TAIL(conf->sc_rules, subr, r_entry);

				free(cond);
			}

			if (rule->r_amap) {
				if (rule->r_action == A_RELAY ||
				    rule->r_action == A_RELAYVIA) {
					yyerror("aliases set on a relay rule");
					free(conditions);
					free(rule);
d908 2
a909 3
			free(conditions);
			free(rule);
			conditions = NULL;
d912 1
a912 2
		| REJECT on from			{

d914 1
d916 12
a927 25
			rule->r_sources = map_find($3);

			conditions = xcalloc(1, sizeof(*conditions),
			    "parse rule: REJECT");

			if ($2)
				(void)strlcpy(rule->r_tag, $2, sizeof(rule->r_tag));
			free($2);

			TAILQ_INIT(conditions);

		} FOR conditions {
			struct rule	*subr;
			struct cond	*cond;

			while ((cond = TAILQ_FIRST(conditions)) != NULL) {

				subr = xmemdup(rule, sizeof(*subr), "parse rule: FOR");

				subr->r_condition = *cond;
				
				TAILQ_REMOVE(conditions, cond, c_entry);
				TAILQ_INSERT_TAIL(conf->sc_rules, subr, r_entry);

				free(cond);
d929 1
a929 3
			free(conditions);
			free(rule);
			conditions = NULL;
d972 1
a974 1
		{ "db",			DB },
a977 1
		{ "file",		FILE },
d981 1
a981 1
		{ "hash",		HASH },
a984 2
		{ "ldap",		LDAP },
		{ "list",		LIST },
d988 1
a988 1
		{ "map",		MAP },
a991 1
		{ "plain",		FILE },
d996 1
a996 2
		{ "single",		SINGLE },
		{ "size",		SIZE },
d1000 1
d1002 1
d1006 1
d1336 8
a1343 1
	struct sym	*sym, *next;
d1350 2
a1351 1
	conf->sc_maps = calloc(1, sizeof(*conf->sc_maps));
d1354 4
a1357 2
	conf->sc_ssl = calloc(1, sizeof(*conf->sc_ssl));
	conf->sc_filters = calloc(1, sizeof(*conf->sc_filters));
d1359 5
a1363 5
	if (conf->sc_maps == NULL	||
	    conf->sc_rules == NULL	||
	    conf->sc_listeners == NULL	||
	    conf->sc_ssl == NULL	||
	    conf->sc_filters == NULL) {
d1365 2
a1366 1
		free(conf->sc_maps);
d1369 1
a1369 2
		free(conf->sc_ssl);
		free(conf->sc_filters);
d1375 1
a1375 1
	map = NULL;
d1378 6
a1384 1
	TAILQ_INIT(conf->sc_maps);
a1385 3
	TAILQ_INIT(conf->sc_filters);
	SPLAY_INIT(conf->sc_ssl);
	SPLAY_INIT(&conf->sc_sessions);
d1397 1
a1397 1
	 * declare special "localhost" and "anyhost" maps
d1401 7
d1633 2
a1634 1
    int max, in_port_t port, uint8_t flags)
d1638 2
d1649 3
d1654 2
d1660 2
d1672 2
a1673 1
    struct listenerlist *al, int max, in_port_t port, uint8_t flags)
d1681 2
d1718 3
d1723 2
d1729 2
a1730 1

d1747 1
a1747 1
	struct map		*m;
d1749 4
a1752 4
	m = map_create(S_NONE, "<anyhost>");
	map_add(m, "local", NULL);
	map_add(m, "0.0.0.0/0", NULL);
	map_add(m, "::/0", NULL);
d1757 2
a1758 2
	m = map_create(S_NONE, "<localhost>");
	map_add(m, "local", NULL);
d1768 1
a1768 1
			map_add(m, ss_to_text(&ss), NULL);
d1775 1
a1775 1
			map_add(m, ss_to_text(&ss), NULL);
@


1.109
log
@introduce map_file.c which will deprecate map_stdio.c

The idea is to have a file-backed map but to have smtpd(8) cache the maps
so that it cannot be partially read if edited while mail is received. The
file is read and converted to a static map (map_static.c), changes aren't
visible to smtpd until an explicit: smtpctl update map  which reads file,
builds a new static map and invalidates the former.

partial-read issue discussed with beck@@ and halex@@
idea to convert internally to a static map by eric@@

diff ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.108 2012/10/11 21:14:32 gilles Exp $	*/
d122 2
a123 2
%token	AS QUEUE COMPRESSION CIPHER INTERVAL SIZE LISTEN ON ANY PORT EXPIRE
%token	MAP HASH LIST SINGLE SSL SMTPS CERTIFICATE ENCRYPTION
d127 1
a127 1
%token	ARROW AUTH TLS LOCAL VIRTUAL TAG ALIAS FILTER KEY DIGEST
d316 1
a316 4
main		: QUEUE INTERVAL interval	{
			conf->sc_qintval = $3;
		}
		| QUEUE compression {
d320 1
a320 1
				log_debug("queue compress using %s",
a942 1
		{ "cipher",		CIPHER },
a945 1
		{ "digest",		DIGEST },
a946 1
		{ "encryption",		ENCRYPTION },
a954 1
		{ "interval",		INTERVAL },
d1244 1
a1244 1
		log_warn("cannot stat %s", fname);
d1248 1
a1248 1
		log_warnx("%s: owner not root or current user", fname);
d1252 1
a1252 1
		log_warnx("%s: group/world readable/writeable", fname);
d1264 1
a1264 1
		log_warn("malloc");
d1268 1
a1268 1
		log_warn("malloc");
d1273 1
a1273 1
		log_warn("%s", nfile->name);
d1326 1
a1326 1
		log_warn("cannot allocate memory");
a1347 2
	conf->sc_qintval.tv_sec = SMTPD_QUEUE_INTERVAL;
	conf->sc_qintval.tv_usec = 0;
d1385 1
a1385 1
		log_warnx("no rules, nothing to do");
d1392 1
a1392 1
			log_warn("could not determine host name");
d1538 1
a1538 1
		log_warnx("host_dns: could not parse \"%s\": %s", s,
d1577 1
a1577 1
		log_warnx("host_dns: %s resolves to more than %d hosts",
@


1.108
log
@- replace "from all" and "for all" with "from any" and "for any"

ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.107 2012/10/09 20:33:02 gilles Exp $	*/
d124 1
a124 1
%token	DB LDAP PLAIN DOMAIN SOURCE
d443 2
a444 2
mapsource	: SOURCE PLAIN STRING			{
			map->m_src = S_PLAIN;
d450 1
a450 1
			map->m_src = S_PLAIN;
d954 1
d972 1
a972 1
		{ "plain",		PLAIN },
@


1.107
log
@- allow a listen statement to impose tls on its clients;
- make listen statements impose authentication if 'auth' is specified and
	to make it optional if 'auth-optional' is specified;
- sync documentation accordingly

with ideas and input from beck@@ and halex@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.106 2012/10/08 20:35:16 gilles Exp $	*/
d122 1
a122 1
%token	AS QUEUE COMPRESSION CIPHER INTERVAL SIZE LISTEN ON ALL PORT EXPIRE
d556 1
a556 1
			c->c_type = C_DOM;
d571 1
a571 1
			c->c_type = C_VDOM;
d599 1
a599 1
			c->c_type = C_DOM;
d604 1
a604 1
		| ALL alias			{
d608 2
a609 2
			c = xcalloc(1, sizeof *c, "parse condition: ALL");
			c->c_type = C_ALL;
d795 1
a795 1
		| FROM ALL			{
d940 1
a940 1
		{ "all",		ALL },
@


1.106
log
@disk space is cheap but we still want to limit the default size of a body
to a sane default for everyone.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.105 2012/10/04 19:49:53 gilles Exp $	*/
d127 2
a128 1
%token	ARROW ENABLE AUTH TLS LOCAL VIRTUAL TAG ALIAS FILTER KEY DIGEST
d264 2
a265 1
		| /* empty */			{ $$ = 0; }
d268 2
a269 1
auth		: ENABLE AUTH  			{ $$ = 1; }
d370 1
a370 4
			flags = $5;

			if ($7)
				flags |= F_AUTH;
d943 1
a951 1
		{ "enable",		ENABLE },
d983 1
@


1.105
log
@default map source to S_PLAIN, this allows us to simplify smtpd.conf:
	map aliases source plain "/etc/mail/aliases"
can be reduced to:
	map aliases "/etc/mail/aliases"
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.104 2012/09/30 17:25:09 chl Exp $	*/
d1318 1
a1318 1
	conf->sc_maxsize = SIZE_MAX;
@


1.104
log
@use xmalloc(), xcalloc() and xmemdup() helpers

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.103 2012/09/30 14:28:16 gilles Exp $	*/
d443 1
a443 1
mapsource	: PLAIN STRING			{
d445 1
a445 1
			if (strlcpy(map->m_config, $2, sizeof(map->m_config))
d449 7
a455 1
		| DB STRING			{
d457 1
a457 1
			if (strlcpy(map->m_config, $2, sizeof(map->m_config))
d462 1
a462 1
		| LDAP STRING			{
d464 1
a464 1
			if (strlcpy(map->m_config, $2, sizeof(map->m_config))
d471 1
a471 1
mapopt		: SOURCE mapsource		{ }
@


1.103
log
@- add decision to the rule so that we can actually perform a reject match
  ie:

	reject from 192.168.1.0/24 for domain "openbsd.org"
	accept from 192.168.0.0/16 for domain "openbsd.org" deliver to mbox

it was documented but not working.

ok eric@@ & chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.102 2012/09/29 10:32:08 eric Exp $	*/
d549 1
a549 2
			if ((c = calloc(1, sizeof *c)) == NULL)
				fatal("out of memory");
d564 1
a564 2
			if ((c = calloc(1, sizeof *c)) == NULL)
				fatal("out of memory");
d592 1
a592 2
			if ((c = calloc(1, sizeof *c)) == NULL)
				fatal("out of memory");
d602 1
a602 2
			if ((c = calloc(1, sizeof *c)) == NULL)
				fatal("out of memory");
d690 1
a690 4
			maddrp = calloc(1, sizeof (*maddrp));
			if (maddrp == NULL)
				fatal("calloc");
			*maddrp = maddr;
d814 1
a814 2
			if ((rule = calloc(1, sizeof(*rule))) == NULL)
				fatal("out of memory");
d818 2
a819 3

			if ((conditions = calloc(1, sizeof(*conditions))) == NULL)
				fatal("out of memory");
a824 1

d839 1
a839 4
				if ((subr = calloc(1, sizeof(*subr))) == NULL)
					fatal("out of memory");

				*subr = *rule;
d866 1
a866 2
			if ((rule = calloc(1, sizeof(*rule))) == NULL)
				fatal("out of memory");
d870 2
a871 3

			if ((conditions = calloc(1, sizeof(*conditions))) == NULL)
				fatal("out of memory");
a876 1

d885 1
a885 4
				if ((subr = calloc(1, sizeof(*subr))) == NULL)
					fatal("out of memory");

				*subr = *rule;
d1491 1
a1491 2
	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(NULL);
d1512 1
a1512 2
	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(NULL);
d1548 1
a1548 2
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal(NULL);
d1634 1
a1634 2
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal(NULL);
d1786 2
a1787 4
            (struct ifg_req *)calloc(len/sizeof(struct ifg_req),
		sizeof(struct ifg_req));
        if (ifgr.ifgr_groups == NULL)
                err(1, "getifgroups");
@


1.102
log
@Remove support for "as user" for local deliveries.
It's not documented and not implemented.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.101 2012/09/26 09:49:43 halex Exp $	*/
d131 1
a131 1
%type	<v.number>	quantifier decision port from auth ssl size expire
a531 4
decision	: ACCEPT			{ $$ = 1; }
		| REJECT			{ $$ = 0; }
		;

d819 1
a819 1
rule		: decision on from			{
d823 1
d872 41
@


1.101
log
@fix double free() issue in error paths

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.100 2012/09/17 20:19:18 eric Exp $	*/
d136 1
a136 1
%type	<v.string>	certname user tag on alias credentials compression
a638 14
user		: AS STRING		{
			struct passwd *pw;

			pw = getpwnam($2);
			if (pw == NULL) {
				yyerror("user '%s' does not exist.", $2);
				free($2);
				YYERROR;
			}
			$$ = $2;
		}
		| /* empty */		{ $$ = NULL; }
		;

d709 1
a709 2
action		: DELIVER TO MAILDIR user		{
			rule->r_user = $4;
d716 1
a716 2
		| DELIVER TO MAILDIR STRING user	{
			rule->r_user = $5;
d731 1
a731 2
		| DELIVER TO MDA STRING user		{
			rule->r_user = $5;
@


1.100
log
@Add map_create() and map_add() helpers.  Simplify the config parser by a
great deal.

While there, rename the default "localhost" map to "<localhost>" to make
it look more internal, and create a single "<anyhost>" map referenced by
"from all" rules, instead of creating a dynamic one for each of them.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.99 2012/09/15 15:12:11 eric Exp $	*/
a785 1
					free($3);
a800 1
					free($3);
a801 1
					free($5);
@


1.99
log
@When enqueueing from the local socket, the input address is faked as "::1".
This is confusing and even broken, as systems running with ipv6 disabled on
lo0 will not be able to enqueue mails using the local socket.

So instead, use AF_LOCAL and print it as "local" in envelopes/maps.  Add it
to the "localhost" and "all" maps accordingly, and fix the ruleset matching.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.98 2012/09/08 13:58:29 chl Exp $	*/
a90 1
objid_t			 last_map_id = 1;
a93 1
struct mapel_list	*contents = NULL;
d294 1
a294 3
			struct map *m;

			if ((m = map_findbyname($2)) == NULL) {
d468 2
a469 30
			struct map	*m;

			TAILQ_FOREACH(m, conf->sc_maps, m_entry)
				if (strcmp(m->m_name, $2) == 0)
					break;

			if (m != NULL) {
				yyerror("map %s defined twice", $2);
				free($2);
				YYERROR;
			}
			if ((m = calloc(1, sizeof(*m))) == NULL)
				fatal("out of memory");
			if (strlcpy(m->m_name, $2, sizeof(m->m_name)) >=
			    sizeof(m->m_name)) {
				yyerror("map name truncated");
				free(m);
				free($2);
				YYERROR;
			}

			m->m_id = last_map_id++;

			if (m->m_id == INT_MAX) {
				yyerror("too many maps defined");
				free($2);
				free(m);
				YYERROR;
			}
			map = m;
a476 1
			TAILQ_INSERT_TAIL(conf->sc_maps, map, m_entry);
d482 1
a482 18
			struct mapel	*me;

			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");

			if (strlcpy(me->me_key.med_string, $1,
			    sizeof(me->me_key.med_string)) >=
			    sizeof(me->me_key.med_string) ||
			    strlcpy(me->me_val.med_string, $3,
			    sizeof(me->me_val.med_string)) >=
			    sizeof(me->me_val.med_string)) {
				yyerror("map elements too long: %s, %s",
				    $1, $3);
				free(me);
				free($1);
				free($3);
				YYERROR;
			}
a484 2

			TAILQ_INSERT_TAIL(contents, me, me_entry);
d493 1
a493 13
			struct mapel	*me;

			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");

			if (strlcpy(me->me_key.med_string, $1,
				sizeof(me->me_key.med_string)) >=
			    sizeof(me->me_key.med_string)) {
				yyerror("map element too long: %s", $1);
				free(me);
				free($1);
				YYERROR;
			}
a494 1
			TAILQ_INSERT_TAIL(contents, me, me_entry);
a503 29
			struct mapel	*me;

			if ((m = calloc(1, sizeof(*m))) == NULL)
				fatal("out of memory");
			m->m_id = last_map_id++;
			if (m->m_id == INT_MAX) {
				yyerror("too many maps defined");
				free(m);
				YYERROR;
			}
			if (! bsnprintf(m->m_name, sizeof(m->m_name),
				"<dynamic(%u)>", m->m_id))
				fatal("snprintf");
			m->m_src = S_NONE;

			TAILQ_INIT(&m->m_contents);

			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");

			if (strlcpy(me->me_key.med_string, $1,
				sizeof(me->me_key.med_string)) >=
			    sizeof(me->me_key.med_string)) {
				yyerror("map element too long: %s", $1);
				free(me);
				free($1);
				YYERROR;
			}
			free($1);
d505 2
a506 2
			TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);
			TAILQ_INSERT_TAIL(conf->sc_maps, m, m_entry);
d510 1
a510 19
			struct map	*m;

			if ((m = calloc(1, sizeof(*m))) == NULL)
				fatal("out of memory");

			m->m_id = last_map_id++;
			if (m->m_id == INT_MAX) {
				yyerror("too many maps defined");
				free(m);
				YYERROR;
			}
			if (! bsnprintf(m->m_name, sizeof(m->m_name),
				"<dynamic(%u)>", m->m_id))
				fatal("snprintf");

			TAILQ_INIT(&m->m_contents);
			contents = &m->m_contents;
			map = m;

a511 1
			TAILQ_INSERT_TAIL(conf->sc_maps, map, m_entry);
d515 1
a515 19
			struct map	*m;

			if ((m = calloc(1, sizeof(*m))) == NULL)
				fatal("out of memory");

			m->m_id = last_map_id++;
			if (m->m_id == INT_MAX) {
				yyerror("too many maps defined");
				free(m);
				YYERROR;
			}
			if (! bsnprintf(m->m_name, sizeof(m->m_name),
				"<dynamic(%u)>", m->m_id))
				fatal("snprintf");

			TAILQ_INIT(&m->m_contents);
			contents = &m->m_contents;
			map = m;

a516 1
			TAILQ_INSERT_TAIL(conf->sc_maps, map, m_entry);
d578 6
a583 1
			struct mapel	*me;
d594 3
a596 34
			if ((m = calloc(1, sizeof(*m))) == NULL)
				fatal("out of memory");
			m->m_id = last_map_id++;
			if (m->m_id == INT_MAX) {
				yyerror("too many maps defined");
				free(m);
				YYERROR;
			}
			if (! bsnprintf(m->m_name, sizeof(m->m_name),
				"<dynamic(%u)>", m->m_id))
				fatal("snprintf");

			TAILQ_INIT(&m->m_contents);

			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");

			(void)strlcpy(me->me_key.med_string, "localhost",
			    sizeof(me->me_key.med_string));
			TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);

			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");

			if (gethostname(me->me_key.med_string,
				sizeof(me->me_key.med_string)) == -1) {
				yyerror("gethostname() failed");
				free(me);
				free(m);
				YYERROR;
			}
			TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);

			TAILQ_INSERT_TAIL(conf->sc_maps, m, m_entry);
d821 1
a821 37
			struct map	*m;
			struct mapel	*me;

			if ((m = calloc(1, sizeof(*m))) == NULL)
				fatal("out of memory");
			m->m_id = last_map_id++;
			if (m->m_id == INT_MAX) {
				yyerror("too many maps defined");
				free(m);
				YYERROR;
			}
			if (! bsnprintf(m->m_name, sizeof(m->m_name),
				"<dynamic(%u)>", m->m_id))
				fatal("snprintf");

			TAILQ_INIT(&m->m_contents);

			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");
			(void)strlcpy(me->me_key.med_string, "local",
			    sizeof(me->me_key.med_string));
			TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);

			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");
			(void)strlcpy(me->me_key.med_string, "0.0.0.0/0",
			    sizeof(me->me_key.med_string));
			TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);

			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");
			(void)strlcpy(me->me_key.med_string, "::/0",
			    sizeof(me->me_key.med_string));
			TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);

			TAILQ_INSERT_TAIL(conf->sc_maps, m, m_entry);
			$$ = m->m_id;
d824 1
a824 4
			struct map	*m;

			m = map_findbyname("localhost");
			$$ = m->m_id;
d827 1
a827 4
			struct map	*m;

			m = map_findbyname("localhost");
			$$ = m->m_id;
a1308 1
	struct map	*m;
a1319 1
	m = calloc(1, sizeof(*m));
d1325 1
a1325 2
	    conf->sc_filters == NULL	||
	    m == NULL) {
a1331 1
		free(m);
a1335 1
	last_map_id = 1;
a1353 1
		free(m);
d1359 1
a1359 1
	 * declare special "local" map
a1360 6
	m->m_id = last_map_id++;
	if (strlcpy(m->m_name, "localhost", sizeof(m->m_name))
	    >= sizeof(m->m_name))
		fatal("strlcpy");
	TAILQ_INIT(&m->m_contents);
	TAILQ_INSERT_TAIL(conf->sc_maps, m, m_entry);
d1688 5
a1692 1
	struct mapel		*me;
d1697 2
a1698 5
	m = map_findbyname("localhost");

	me = xcalloc(1, sizeof *me, "set_localaddrs");
	strlcpy(me->me_key.med_string, "local", sizeof(me->me_key.med_string));
	TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);
d1708 1
a1708 6
			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");
			(void)strlcpy(me->me_key.med_string,
			    ss_to_text(&ss),
			    sizeof(me->me_key.med_string));
			TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);
d1715 1
a1715 6
			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");
			(void)strlcpy(me->me_key.med_string,
			    ss_to_text(&ss),
			    sizeof(me->me_key.med_string));
			TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);
@


1.98
log
@remove unused header

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.97 2012/09/01 16:09:14 gilles Exp $	*/
d998 6
d1906 4
@


1.97
log
@- remove crypto_backend
- remove support for encrypted queue, it will be reintroduced later after
  pouring more thinking into it

if you had it enabled, flush your queue before updating
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.96 2012/08/30 18:25:44 gilles Exp $	*/
a51 2

#include <openssl/evp.h>
@


1.96
log
@- import latest aldap.[ch] and ber.[ch] from ypldap
- revive map_ldap.c by updating it to the current API

diff by Mathieu Masson who played puzzle with an oooold changeset of mine,
this import is to let us work on it in tree, it won't work as is.

idea ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.95 2012/08/29 18:36:24 naddy Exp $	*/
a140 2
%type	<v.string>	encrypt_cipher encrypt_digest encrypt_key

a318 38
encrypt_cipher 	: CIPHER STRING {
			if (EVP_get_cipherbyname($2) == NULL) {
				yyerror("invalid queue encrypt cipher %s", $2);
				YYERROR;
			}
			$$ = $2;
		}
		| /* empty */ {
			$$ = "aes-128-cbc";
			if (EVP_get_cipherbyname($$) == NULL) {
				yyerror("invalid queue encrypt cipher %s", $$);
				YYERROR;
			}
		}
		;

encrypt_digest 	: DIGEST STRING {
			if (EVP_get_digestbyname($2) == NULL) {
				yyerror("invalid queue digest %s", $2);
				YYERROR;
			}
			$$ = $2;
		}
		| /* empty */ {
			$$ = "sha256";
			if (EVP_get_digestbyname($$) == NULL) {
				yyerror("invalid queue digest %s", $$);
				YYERROR;
			}
		}
		;

encrypt_key	: KEY STRING {
			$$ = $2;
		}
		| /**/ { $$ = NULL; }
		;

a330 15
				YYERROR;
			}
		}
		| QUEUE ENCRYPTION encrypt_key encrypt_cipher encrypt_digest {
			if ($3 == NULL) {
				yyerror("queue encryption: missing key");
				YYERROR;
			}

			conf->sc_queue_flags |= QUEUE_ENCRYPT;
			conf->sc_queue_crypto_key    = strdup($3);
			conf->sc_queue_crypto_cipher = strdup($4);
			conf->sc_queue_crypto_digest = strdup($5);
			if ($3 == NULL || $4 == NULL || $5 == NULL) {
				yyerror("memory exhausted");
@


1.95
log
@switch the default queue encryption to AES-128
I'm committing this on behalf of gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.94 2012/08/29 16:26:17 gilles Exp $	*/
d128 1
a128 1
%token	DB PLAIN DOMAIN SOURCE
d516 8
d1208 1
@


1.94
log
@Introduce the crypto_backend API and provide support for... encrypted queue
using the new API. By default, OpenSMTPD does not provide queue encryption,
but it can be enabled with "queue encryption [args]" and will transparently
encrypt/decrypt envelopes/messages as they hit the queue.

By default, it will use Blowfish in CBC mode with a different random IV for
each envelope and message. User provided key is expanded using sha256 but a
different cipher and digest may be specified in smtpd.conf

Queue encryption is compatible with compression and if both options are set
it will do them in correct order and transparently.

tested by chl@@, a few users and myself
ok chl@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.93 2012/08/26 13:38:43 gilles Exp $	*/
d329 1
a329 1
			$$ = "bf-cbc";
@


1.93
log
@- use the same compression algorithm, gzip, for message file and envelopes
- rename compress_zlib.c to compress_gzip.c

with this commit it is possible to inspect a compressed queue with gzcat :)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.92 2012/08/25 23:35:09 chl Exp $	*/
d53 2
d126 2
a127 2
%token	AS QUEUE COMPRESS INTERVAL SIZE LISTEN ON ALL PORT EXPIRE
%token	MAP HASH LIST SINGLE SSL SMTPS CERTIFICATE
d131 1
a131 1
%token	ARROW ENABLE AUTH TLS LOCAL VIRTUAL TAG ALIAS FILTER
d140 2
a141 1
%type	<v.string>	certname user tag on alias credentials compress
d312 1
a312 1
compress	: COMPRESS STRING {
d315 1
a315 1
		| COMPRESS {
d321 38
d362 1
a362 1
		| QUEUE compress {
d366 2
a367 1
				log_debug("queue compress using %s", conf->sc_queue_compress_algo);
d374 15
d1183 2
a1184 1
		{ "compress",		COMPRESS },
d1187 1
d1190 1
d1199 1
@


1.92
log
@Add compress_backend, allowing compression of messages and envelopes in the queue.
To use it, just add "queue compress" in smtpd.conf. For now, only zlib is used.

lots of feedback from eric@@ and gilles@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.91 2012/08/21 20:19:46 eric Exp $	*/
d313 1
a313 1
			$$ = "zlib";
@


1.91
log
@Allow smtpd to work as a backup MX, relaying only to MXs with higher
priority in the DNS record. For example:

   accept for domain "foo.org" relay backup "mx3.foo.org"

will relay mails for "foo.org" using only hosts with higher priority
(i.e. lower value) than "mx3.foo.org", which is supposed to be the
current server.

If the specified backup MX is not found in the DNS record, relaying
works as normal.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.90 2012/08/19 14:16:58 chl Exp $	*/
d124 1
a124 1
%token	AS QUEUE INTERVAL SIZE LISTEN ON ALL PORT EXPIRE
d138 1
a138 1
%type	<v.string>	certname user tag on alias credentials
d309 9
d321 11
d1126 1
@


1.90
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.89 2012/07/08 15:48:00 gilles Exp $	*/
d127 1
a127 1
%token  RELAY VIA DELIVER TO MAILDIR MBOX HOSTNAME
d890 8
d1104 1
@


1.89
log
@- plug text_to_relayhost() in parse.y to support relay URLs.
- document the new URL syntax in smtpd.conf.5
- replace starttls:// schema with tls://

Beware, "relay via" rules should now be expressed with a relay URL:

	accept [...] relay via "mx1.example.org" smtps port 465
becomes accept [...] relay via "smtps://mx1.example.org"

This will allow using mappings of relays with different protocols and
options.

Make sure to update your smtpd.conf if you relay via !

ok eric, ok chl
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.88 2012/05/13 00:10:49 gilles Exp $	*/
d100 1
a100 1
		    struct listenerlist *, int, in_port_t, u_int8_t);
d102 1
a102 1
		    struct listenerlist *, int, in_port_t, u_int8_t);
d104 1
a104 1
		    struct listenerlist *, int, in_port_t, u_int8_t);
d325 1
a325 1
			u_int8_t	 flags;
d1690 1
a1690 1
    struct listenerlist *al, int max, in_port_t port, u_int8_t flags)
d1754 1
a1754 1
    int max, in_port_t port, u_int8_t flags)
d1783 1
a1783 1
    struct listenerlist *al, int max, in_port_t port, u_int8_t flags)
@


1.88
log
@- cleanup parse.y by removing lots of code that should not have been there,
  but in ruleset.c and util.c instead.

- introduce the new map_compare() map API call to allow iterating over keys
  and comparing them with provided key using provided function. this allows
  checking a partial key in a key set, very useful for comparing an address
  to a set of netmask.

- introduce new map kind K_NETADDR
- implement K_NETADDR for map_db and map_stdio
- teach ruleset checking how to use the map_compare() with K_NETADDR

we can now do the following:

   map "srcaddr" source plain "/etc/mail/srcaddr.txt"

   accept from map srcaddr for domain "openbsd.org" [...]
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.87 2012/05/12 21:49:31 gilles Exp $	*/
d890 1
a890 1
		| RELAY VIA STRING port ssl certname credentials relay_as {
d892 1
a892 1
			rule->r_as = $8;
d894 5
a898 2
			if ($5 == 0 && ($6 != NULL || $7)) {
				yyerror("error: must specify tls, smtps, or ssl");
a899 1
				free($3);
d902 1
d904 11
a914 11
			if (strlcpy(rule->r_value.relayhost.hostname, $3,
			    sizeof(rule->r_value.relayhost.hostname))
			    >= sizeof(rule->r_value.relayhost.hostname))
				fatal("hostname too long");

			rule->r_value.relayhost.port = $4;
			rule->r_value.relayhost.flags |= $5;

			if ($7) {
				rule->r_value.relayhost.flags |= F_AUTH;
				strlcpy(rule->r_value.relayhost.authmap, $7,
a915 1
				free($7);
d917 1
d919 3
a921 2
			if ($6 != NULL) {
				if (ssl_load_certfile($6, F_CCERT) < 0) {
d923 4
a926 1
					    $6);
a927 1
					free($3);
d930 1
a930 1
				if (strlcpy(rule->r_value.relayhost.cert, $6,
d935 1
a935 3

			free($3);
			free($6);
@


1.87
log
@- remove unused sources S_EXT, S_DYN and S_EXT from enum map_src
- continue simplification of parse.y
- remove "for network", if we ever need it we can reimport, probably no
  one knows of that undocumented strange feature ;-)
- change syntax for virtual domains configuration:

	  accept for virtual vmap	[...] <- wrong
	  accept for virtual map vmap	[...] <- right

  the reason for this change is that we will soon implement relay rules
  through maps and that keeping that syntax would make it inconsistent
  with the other rules.

- update man pages for makemap and smtpd.conf to reflect changes

ok eric@@, looks ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.86 2012/05/12 18:41:10 gilles Exp $	*/
a517 3
			int bits;
			struct sockaddr_in ssin;
			struct sockaddr_in6 ssin6;
d522 7
a528 47
			/* Attempt detection of $1 format */
			if (strchr($1, '/') != NULL) {
				/* Dealing with a netmask */
				bzero(&ssin, sizeof(struct sockaddr_in));
				bits = inet_net_pton(AF_INET, $1, &ssin.sin_addr, sizeof(struct in_addr));
				if (bits != -1) {
					ssin.sin_family = AF_INET;
					me->me_key.med_addr.bits = bits;
					memcpy(&me->me_key.med_addr.ss, &ssin, sizeof(ssin));
					me->me_key.med_addr.ss.ss_len = sizeof(struct sockaddr_in);
				}
				else {
					bzero(&ssin6, sizeof(struct sockaddr_in6));
					bits = inet_net_pton(AF_INET6, $1, &ssin6.sin6_addr, sizeof(struct in6_addr));
					if (bits == -1)
						err(1, "inet_net_pton");
					ssin6.sin6_family = AF_INET6;
					me->me_key.med_addr.bits = bits;
					memcpy(&me->me_key.med_addr.ss, &ssin6, sizeof(ssin6));
					me->me_key.med_addr.ss.ss_len = sizeof(struct sockaddr_in6);
				}
			}
			else {
				/* IP address ? */
				if (inet_pton(AF_INET, $1, &ssin.sin_addr) == 1) {
					ssin.sin_family = AF_INET;
					me->me_key.med_addr.bits = 32;
					memcpy(&me->me_key.med_addr.ss, &ssin, sizeof(ssin));
					me->me_key.med_addr.ss.ss_len = sizeof(struct sockaddr_in);
				}
				else if (inet_pton(AF_INET6, $1, &ssin6.sin6_addr) == 1) {
					ssin6.sin6_family = AF_INET6;
					me->me_key.med_addr.bits = 128;
					memcpy(&me->me_key.med_addr.ss, &ssin6, sizeof(ssin6));
					me->me_key.med_addr.ss.ss_len = sizeof(struct sockaddr_in6);
				}
				else {
					/* either a hostname or a value unrelated to network */
					if (strlcpy(me->me_key.med_string, $1,
						sizeof(me->me_key.med_string)) >=
					    sizeof(me->me_key.med_string)) {
						yyerror("map element too long: %s", $1);
						free(me);
						free($1);
						YYERROR;
					}
				}
a541 3
			int bits;
			struct sockaddr_in ssin;
			struct sockaddr_in6 ssin6;
d561 7
a567 48
			/* Attempt detection of $1 format */
			if (strchr($1, '/') != NULL) {
				/* Dealing with a netmask */
				bzero(&ssin, sizeof(struct sockaddr_in));
				bits = inet_net_pton(AF_INET, $1, &ssin.sin_addr, sizeof(struct in_addr));
				if (bits != -1) {
					ssin.sin_family = AF_INET;
					me->me_key.med_addr.bits = bits;
					memcpy(&me->me_key.med_addr.ss, &ssin, sizeof(ssin));
					me->me_key.med_addr.ss.ss_len = sizeof(struct sockaddr_in);
				}
				else {
					bzero(&ssin6, sizeof(struct sockaddr_in6));
					bits = inet_net_pton(AF_INET6, $1, &ssin6.sin6_addr, sizeof(struct in6_addr));
					if (bits == -1)
						err(1, "inet_net_pton");
					ssin6.sin6_family = AF_INET6;
					me->me_key.med_addr.bits = bits;
					memcpy(&me->me_key.med_addr.ss, &ssin6, sizeof(ssin6));
					me->me_key.med_addr.ss.ss_len = sizeof(struct sockaddr_in6);
				}
			}
			else {
				/* IP address ? */
				if (inet_pton(AF_INET, $1, &ssin.sin_addr) == 1) {
					ssin.sin_family = AF_INET;
					me->me_key.med_addr.bits = 32;
					memcpy(&me->me_key.med_addr.ss, &ssin, sizeof(ssin));
					me->me_key.med_addr.ss.ss_len = sizeof(struct sockaddr_in);
				}
				else if (inet_pton(AF_INET6, $1, &ssin6.sin6_addr) == 1) {
					ssin6.sin6_family = AF_INET6;
					me->me_key.med_addr.bits = 128;
					memcpy(&me->me_key.med_addr.ss, &ssin6, sizeof(ssin6));
					me->me_key.med_addr.ss.ss_len = sizeof(struct sockaddr_in6);
				}
				else {
					/* either a hostname or a value unrelated to network */
					if (strlcpy(me->me_key.med_string, $1,
						sizeof(me->me_key.med_string)) >=
					    sizeof(me->me_key.med_string)) {
						yyerror("map element too long: %s", $1);
						free(me);
						free(m);
						free($1);
						YYERROR;
					}
				}
a940 2
			struct sockaddr_in *ssin;
			struct sockaddr_in6 *ssin6;
d958 2
a959 9
			me->me_key.med_addr.bits = 0;
			me->me_key.med_addr.ss.ss_len = sizeof(struct sockaddr_in);
			ssin = (struct sockaddr_in *)&me->me_key.med_addr.ss;
			ssin->sin_family = AF_INET;
			if (inet_pton(AF_INET, "0.0.0.0", &ssin->sin_addr) != 1) {
				free(me);
				free(m);
				YYERROR;
			}
d964 2
a965 9
			me->me_key.med_addr.bits = 0;
			me->me_key.med_addr.ss.ss_len = sizeof(struct sockaddr_in6);
			ssin6 = (struct sockaddr_in6 *)&me->me_key.med_addr.ss;
			ssin6->sin6_family = AF_INET6;
			if (inet_pton(AF_INET6, "::", &ssin6->sin6_addr) != 1) {
				free(me);
				free(m);
				YYERROR;
			}
a1861 1

d1864 3
a1866 2
			me->me_key.med_addr.bits = 32;
			me->me_key.med_addr.ss = *(struct sockaddr_storage *)sain;
a1867 1

a1873 1

d1876 3
a1878 2
			me->me_key.med_addr.bits = 128;
			me->me_key.med_addr.ss = *(struct sockaddr_storage *)sin6;
a1879 1

@


1.86
log
@- simplify a bit maps by removing fields which are still unused years
  after the initial ambitious implementation: byebye map type & map flags

- simplify a bit parse.y by removing assignations to these otherwise unused
  fields

- remove the DNS map source, it may be a good idea, but we can just add it
  when we plan to implement it (if we do)

- make the { } options in map declaration, it's been annoying me for a long
  time now, this allows the following to work:

       map "foobar" source plain "/etc/mail/foobar"

- update smtpd.conf.5 accordingly ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.85 2012/04/16 13:32:16 chl Exp $	*/
d126 1
a126 1
%token	DB PLAIN EXTERNAL DOMAIN SOURCE
d128 1
a128 1
%token	ACCEPT REJECT INCLUDE NETWORK ERROR MDA FROM FOR
a438 1
		| EXTERNAL			{ map->m_src = S_EXT; }
d731 1
a731 10
condition	: NETWORK mapref		{
			struct cond	*c;

			if ((c = calloc(1, sizeof *c)) == NULL)
				fatal("out of memory");
			c->c_type = C_NET;
			c->c_map = $2;
			$$ = c;
		}
		| DOMAIN mapref	alias		{
d750 1
a750 1
		| VIRTUAL STRING		{
d754 3
a756 3
			if ((m = map_findbyname($2)) == NULL) {
				yyerror("no such map: %s", $2);
				free($2);
a758 1
			free($2);
d763 1
a763 1
			c->c_map = m->m_id;
a1200 1
		{ "external",		EXTERNAL },
a1214 1
		{ "network",		NETWORK },
@


1.85
log
@add missing header needed by str* and mem* functions

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.84 2011/12/13 21:44:47 gilles Exp $	*/
d125 2
a126 2
%token	MAP TYPE HASH LIST SINGLE SSL SMTPS CERTIFICATE
%token	DNS DB PLAIN EXTERNAL DOMAIN CONFIG SOURCE
d184 8
d427 1
a427 7
maptype		: SINGLE			{ map->m_type = T_SINGLE; }
		| LIST				{ map->m_type = T_LIST; }
		| HASH				{ map->m_type = T_HASH; }
		;

mapsource	: DNS				{ map->m_src = S_DNS; }
		| PLAIN STRING			{
d442 1
a442 9
mapopt		: TYPE maptype
		| SOURCE mapsource
		| CONFIG STRING			{
		}
		;

mapopts_l	: mapopts_l mapopt nl
		| mapopt optnl
		;
a466 1
			m->m_type = T_SINGLE;
d475 1
a475 1
		} '{' optnl mapopts_l '}'	{
a600 2
			m->m_flags |= F_DYNAMIC|F_USED;
			m->m_type = T_SINGLE;
a677 2
			m->m_flags |= F_DYNAMIC|F_USED;
			m->m_type = T_LIST;
a701 2
			m->m_flags |= F_DYNAMIC|F_USED;
			m->m_type = T_HASH;
a719 1
			m->m_flags |= F_USED;
a769 1
			m->m_flags |= F_USED;
a801 2
			m->m_flags |= F_DYNAMIC|F_USED;
			m->m_type = T_SINGLE;
a1052 2
			m->m_flags |= F_DYNAMIC|F_USED;
			m->m_type = T_SINGLE;
a1206 1
		{ "config",		CONFIG },
a1208 1
		{ "dns",		DNS },
a1241 1
		{ "type",		TYPE },
a1633 1
	m->m_type = T_LIST;
@


1.84
log
@- introduce delivery backend API (delivery.c)
- move each delivery method to it's own delivery backend
- simplify smtpd.c accordingly
- rename A_EXT -> A_MDA since that's what we really do

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.83 2011/12/08 17:04:19 todd Exp $	*/
d49 1
@


1.83
log
@check for NULL ->ifa_addr, found the hard way by yours truly on his phone
ok chl@@ & gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.82 2011/10/27 14:32:57 chl Exp $	*/
d993 1
a993 1
			rule->r_action = A_EXT;
@


1.82
log
@Use PRI{x,d}64 in format strings instead of %llx, %lld or %qd to print {u_,}int64_t or time_t

While there, cast some time_t to int64_t

These will fix build warnings for portable smptd

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.81 2011/10/23 15:36:53 eric Exp $	*/
d1929 2
d1993 2
@


1.81
log
@a few important fixes:

- use correct endianness when dumping/loading port
- use the right flag set when dumping/loading flags
- keep and use the authmap name when needed, rather than an id that
  might change when smtpd is restarted
- dump/load the authmap name with the envelope
- remove the rule struct from rq_batch as only the relay info is useful

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.80 2011/09/01 16:23:33 chl Exp $	*/
d43 1
d194 1
a194 1
				yyerror("invalid interval: %lld", $1);
d204 1
a204 1
				yyerror("invalid size: %lld", $1);
d236 1
a236 1
				yyerror("invalid port: %lld", $2);
@


1.80
log
@add missing header needed by bsearch()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.79 2011/09/01 09:42:15 chl Exp $	*/
d131 1
a131 1
%type	<v.number>	quantifier decision port from auth ssl size expire credentials
d136 1
a136 1
%type	<v.string>	certname user tag on alias
d294 1
a294 2
			free($2);
			$$ = m->m_id;
d1024 3
a1026 1
				rule->r_value.relayhost.secmapid = $7;
@


1.79
log
@- if no filter is setup, do not overwrite the data line with filtmsg buffer
- remove annoying debug lines
- disable back filters at smtpd.conf level

committing on behalf of gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.78 2011/08/31 18:56:30 gilles Exp $	*/
d47 1
@


1.78
log
@add support for per-line DATA callbacks, this allows filters to take their
decisions *while* the message is being received by the client.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.77 2011/08/27 22:32:41 gilles Exp $	*/
d382 1
a382 1
		}
d414 1
@


1.77
log
@initial support for a session-time filtering API

currently only HELO/EHLO, MAIL, RCPT are supported, however ... I have
voluntarily disabled filters at smtpd.conf level so people don't play with
it until the API has stabilized a bit

discussed with several people in private, no one opposed the feature
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.76 2011/06/09 17:41:52 gilles Exp $	*/
d382 1
a382 1
		}/*
a413 1
		 */
@


1.76
log
@'relay as' and 'relay via as' rules allow smtpd to rewrite the user part,
the domain part or the entire address of the sender at the SMTP sesssion
level. this is not masquerade but allows smtpd to communicate with hosts
that do a check of SMTP sender fqdn.

sent to tech@@, a couple 'no regression' feedbacks
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.75 2011/05/22 21:03:14 gilles Exp $	*/
d126 1
a126 1
%token	ARROW ENABLE AUTH TLS LOCAL VIRTUAL TAG ALIAS
d382 31
d414 1
d1230 1
d1597 13
a1609 23
	if ((conf->sc_maps = calloc(1, sizeof(*conf->sc_maps))) == NULL) {
		log_warn("cannot allocate memory");
		return (-1);
	}
	if ((conf->sc_rules = calloc(1, sizeof(*conf->sc_rules))) == NULL) {
		log_warn("cannot allocate memory");
		free(conf->sc_maps);
		return (-1);
	}
	if ((conf->sc_listeners = calloc(1, sizeof(*conf->sc_listeners))) == NULL) {
		log_warn("cannot allocate memory");
		free(conf->sc_maps);
		free(conf->sc_rules);
		return (-1);
	}
	if ((conf->sc_ssl = calloc(1, sizeof(*conf->sc_ssl))) == NULL) {
		log_warn("cannot allocate memory");
		free(conf->sc_maps);
		free(conf->sc_rules);
		free(conf->sc_listeners);
		return (-1);
	}
	if ((m = calloc(1, sizeof(*m))) == NULL) {
d1615 2
d1629 1
@


1.75
log
@teach smtpd how to listen on an interface group so that we can do:
	listen on egress
	listen on wlan

idea unvoluntarily suggested by Mikolaj Kucharski a few weeks ago,
unslacked after theo suggested it again.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.74 2011/05/21 16:58:04 gilles Exp $	*/
d114 1
d121 1
a121 1
%token	QUEUE INTERVAL SIZE LISTEN ON ALL PORT EXPIRE
d126 1
a126 1
%token	ARROW ENABLE AUTH TLS LOCAL VIRTUAL USER TAG ALIAS
d134 1
d850 1
a850 1
user		: USER STRING		{
d864 70
d967 1
a967 1
		| RELAY				{
d969 1
d971 1
a971 1
		| RELAY VIA STRING port ssl certname credentials {
d973 1
d1187 1
a1226 1
		{ "user",		USER },
@


1.74
log
@"for all" does not necessary apply to relay rules, so do not forget to look
for an alias map.

fixes "accept from all for all alias myaliases deliver to mbox" and makes
thib "super happy"

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.73 2011/05/01 12:57:11 eric Exp $	*/
d31 1
d33 1
d104 1
d1826 2
a1827 1
		if (strcmp(s, p->ifa_name) != 0)
d1964 44
@


1.73
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.72 2010/11/28 14:35:58 gilles Exp $	*/
d811 1
a811 1
		| ALL				{
d813 1
d818 9
d1057 10
@


1.72
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.71 2010/11/28 13:56:43 gilles Exp $	*/
d283 1
a283 1
			if ((m = map_findbyname(conf, $2)) == NULL) {
d341 1
a341 1
			if ($5 && ssl_load_certfile(conf, cert, F_SCERT) < 0) {
d688 1
a688 1
			if ((m = map_findbyname(conf, $2)) == NULL) {
d721 1
a721 1
				if ((m = map_findbyname(conf, $3)) == NULL) {
d739 1
a739 1
			if ((m = map_findbyname(conf, $2)) == NULL) {
d759 1
a759 1
				if ((m = map_findbyname(conf, $2)) == NULL) {
d909 1
a909 1
				if (ssl_load_certfile(conf, $6, F_CCERT) < 0) {
d984 1
a984 1
			m = map_findbyname(conf, "localhost");
d990 1
a990 1
			m = map_findbyname(conf, "localhost");
d1011 1
a1011 1
			rule->r_sources = map_find(conf, $3);
d1516 1
a1516 1
		purge_config(conf, PURGE_EVERYTHING);
d1571 1
a1571 1
		purge_config(conf, PURGE_EVERYTHING);
d1861 1
a1861 1
	m = map_findbyname(conf, "localhost");
@


1.71
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.70 2010/10/29 09:16:08 gilles Exp $	*/
d41 1
a41 1
#include <limits.h>
a43 2
#include <netdb.h>
#include <stdarg.h>
a44 3
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
@


1.70
log
@smtpd no longer knows a map called "secrets" which holds credentials for
authenticated relaying. one can create many maps holding credentials and
name them however he/she wants, just like any other map.

teach smtpd how to select a credentials map at the rule-level allowing a
setup to relay through the same MX with different credentials depending
on the source.

smtpd.conf.5 updated to reflect changes with help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.69 2010/10/28 21:15:50 gilles Exp $	*/
d40 1
d54 1
@


1.69
log
@teach smtpd how to handle per-rule delays for message expiry, this allows
some rules to have a longer expiry delay than the default:

	accept for [...] relay expire 8d  # will stay 8 days in queue

I added the man page bits so I don't forget but I need to reword it a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.68 2010/10/18 13:28:00 sthen Exp $	*/
d129 1
a129 1
%type	<v.number>	quantifier decision port from auth ssl size expire
d283 14
d888 1
a888 1
		| RELAY VIA STRING port ssl certname auth {
d906 1
a906 1
			if ($7)
d908 2
@


1.68
log
@Missing semicolons to appease yyextract, ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.67 2010/10/09 22:05:35 gilles Exp $	*/
d129 1
a129 1
%type	<v.number>	quantifier decision port from auth ssl size
d272 11
d1011 1
a1011 1
		} FOR conditions action	tag {
d1018 2
@


1.67
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2010/05/27 15:36:04 gilles Exp $	*/
d254 1
d457 1
d981 1
@


1.66
log
@- fix a regression caused by latest commit (long story made short: do not
  attempt to expand the local delivery buffer when relaying mail, it was
  kind of ok before but no longer is)
- use the same buffer for local deliveries to files and commands

tested by jmc@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.65 2010/09/08 23:32:27 gilles Exp $	*/
d120 1
a120 1
%token	EXPIRE SIZE LISTEN ON ALL PORT
d129 1
a129 1
%type	<v.number>	decision port from auth ssl size
d131 1
d182 17
a198 1
size		: NUMBER			{
d271 6
a276 3
main		: EXPIRE STRING {
      			conf->sc_qexpire = delaytonum($2);
      			if (conf->sc_qexpire == -1) {
d280 2
a281 2
      		}
		| SIZE size {
d1076 1
d1088 1
d1481 3
a1483 1
	conf->sc_qexpire = SMTPD_EXPIRE;
d1870 5
a1874 5
	unsigned int	 factor;
	size_t		 len;
	const char	*errstr = NULL;
	int		 delay;

d1879 1
a1879 1

d1881 1
a1881 1

d1885 1
a1885 1

d1889 1
a1889 1

d1893 1
a1893 1

d1897 1
a1897 1

d1901 1
a1901 1
	
d1906 1
a1906 1

d1908 1
a1908 1

@


1.65
log
@when I fixed the ruleset matching on rules that had more than one condition
by expanding them to several rules, I forgot to copy the tags to the
expanded rules. this commit unbreaks matching rules by tag.

documentation follows shortly ...

spotted and fixed by me a while ago, jacekm@@ timeout
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.64 2010/08/03 18:42:41 henning Exp $	*/
d808 3
a810 3
			if (strlcpy(rule->r_value.path, "~/Maildir",
			    sizeof(rule->r_value.path)) >=
			    sizeof(rule->r_value.path))
d816 3
a818 3
			if (strlcpy(rule->r_value.path, $4,
			    sizeof(rule->r_value.path)) >=
			    sizeof(rule->r_value.path))
d824 3
a826 3
			if (strlcpy(rule->r_value.path, _PATH_MAILDIR "/%u",
			    sizeof(rule->r_value.path))
			    >= sizeof(rule->r_value.path))
d832 3
a834 3
			if (strlcpy(rule->r_value.command, $4,
			    sizeof(rule->r_value.command))
			    >= sizeof(rule->r_value.command))
@


1.64
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.63 2010/06/10 19:34:51 chl Exp $	*/
d980 4
@


1.63
log
@allow configure queue expiry

with help from jacekm@@

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2010/06/01 23:06:23 jacekm Exp $	*/
d1240 2
a1241 1
				else if (next == '\n')
d1243 1
a1243 1
				else
@


1.62
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2010/05/31 23:38:56 jacekm Exp $	*/
d104 1
d120 1
a120 1
%token	SIZE LISTEN ON ALL PORT
d129 1
a129 1
%type	<v.number>	quantifier decision port from auth ssl size
a130 1
%type	<v.tv>		interval
a180 15
quantifier	: /* empty */			{ $$ = 1; }
		| 'm'				{ $$ = 60; }
		| 'h'				{ $$ = 3600; }
		| 'd'				{ $$ = 86400; }
		;

interval	: NUMBER quantifier		{
			if ($1 < 0) {
				yyerror("invalid interval: %lld", $1);
				YYERROR;
			}
			$$.tv_usec = 0;
			$$.tv_sec = $1 * $2;
		}

d254 8
a261 1
main		: SIZE size {
d1045 1
d1454 1
d1836 46
@


1.61
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2010/05/27 15:36:04 gilles Exp $	*/
d119 1
a119 1
%token	QUEUE INTERVAL SIZE LISTEN ON ALL PORT
d269 1
a269 4
main		: QUEUE INTERVAL interval	{
			conf->sc_qintval = $3;
		}
	       	| SIZE size {
a1058 1
		{ "interval",		INTERVAL },
a1069 1
		{ "queue",		QUEUE },
a1460 2
	conf->sc_qintval.tv_sec = SMTPD_QUEUE_INTERVAL;
	conf->sc_qintval.tv_usec = 0;
@


1.60
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d119 1
a119 1
%token	SIZE LISTEN ON ALL PORT
d269 4
a272 1
main		: SIZE size {
d1062 1
d1074 1
d1466 2
@


1.59
log
@when a rule has two conditions (ie: accept for { domain foo, domain bar } )
expand to two rules each having its own condition rather than one rule
with a tail queue of conditions. this simplifies code a bit and removes a
couple hacks.

basic testing by oga and me
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2010/05/27 11:17:29 gilles Exp $	*/
d119 1
a119 1
%token	QUEUE INTERVAL SIZE LISTEN ON ALL PORT
d269 1
a269 4
main		: QUEUE INTERVAL interval	{
			conf->sc_qintval = $3;
		}
	       	| SIZE size {
a1058 1
		{ "interval",		INTERVAL },
a1069 1
		{ "queue",		QUEUE },
a1460 2
	conf->sc_qintval.tv_sec = SMTPD_QUEUE_INTERVAL;
	conf->sc_qintval.tv_usec = 0;
@


1.58
log
@kill struct opt from struct rule, we don't use it, we don't need it
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2010/05/19 20:57:10 gilles Exp $	*/
d92 1
d789 1
a789 1
			TAILQ_INSERT_TAIL(&rule->r_conditions, $1, c_entry);
d792 1
a792 1
			TAILQ_INSERT_TAIL(&rule->r_conditions, $1, c_entry);
d797 1
a797 1
			TAILQ_INSERT_TAIL(&rule->r_conditions, $1, c_entry);
a971 1
			struct rule	*r;
d973 1
a973 1
			if ((r = calloc(1, sizeof(*r))) == NULL)
a974 1
			rule = r;
d977 4
d985 2
a986 1
			TAILQ_INIT(&rule->r_conditions);
d989 22
a1010 1
			TAILQ_INSERT_TAIL(conf->sc_rules, rule, r_entry);
@


1.57
log
@cleanup-only commit, removes unrequired includes, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2010/04/27 10:17:53 gilles Exp $	*/
a982 1
			TAILQ_INIT(&rule->r_options);
@


1.56
log
@this commit enables "plain" as a backend for maps (that means aliases,
virtual AND secrets), adds a description in smtpd.conf.5 and removes a
mention to special map "aliases" which was removed a while ago.

to use plain maps:  map "myaliases" { source plain "/etc/mail/aliases" }

code diff was okayd a while ago by jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2010/04/20 18:55:01 jacekm Exp $	*/
a25 1
#include <sys/time.h>
d46 1
@


1.55
log
@Support "accept from local ..." as documented in the man page.

Reported by Rene Maroufi <info@@maroufi.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2010/04/20 11:03:05 gilles Exp $	*/
d120 1
a120 1
%token	DNS DB TFILE EXTERNAL DOMAIN CONFIG SOURCE
d353 6
a358 1
		| TFILE				{ map->m_src = S_FILE; }
a1032 1
		{ "file",		TFILE },
d1048 1
@


1.54
log
@when a size is declared with a quantifier in smtpd.conf, have parse.y use
scan_scaled(3) to support the quantifiers rather than rolling my own code.

prompted by jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2010/04/19 14:37:33 gilles Exp $	*/
d938 6
@


1.53
log
@two lines were missing from previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2010/04/19 10:12:48 gilles Exp $	*/
d50 1
d202 5
a206 3
		| NUMBER STRING         {
			if ($1 < 0) {
				yyerror("invalid size: %lld", $1);
d209 1
d211 1
a211 11
			if (strcmp("KB", $2) == 0)
				$$ = 1024;
			else if (strcmp("MB", $2) == 0)
				$$ = 1048576;
			else if (strcmp("GB", $2) == 0)
				$$ = 1073741824;
			else {
				yyerror("invalid quantifier: %s", $2);
				YYERROR;
			}
			$$ *= $1;
@


1.52
log
@basic support for SIZE extension, has been sitting in my tree for a month
or so ...

okayd by jacekm@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2010/02/26 15:06:39 gilles Exp $	*/
d276 3
@


1.51
log
@- fix netmask matching for AF_INET, it was broken in many ways, problem
  was reported by nicm@@ which spent a couple hours with me trying to
  understand what was causing the bug, and helping me write and test fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2009/12/10 14:57:51 jacekm Exp $	*/
d117 1
a117 1
%token	QUEUE INTERVAL LISTEN ON ALL PORT
d126 1
a126 1
%type	<v.number>	quantifier decision port from auth ssl
d194 27
d1046 1
d1388 3
@


1.50
log
@Fix few read overruns found by parfait.
Nudge by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2009/12/06 00:27:31 jacekm Exp $	*/
d457 1
a457 1
					me->me_key.med_addr.bits = 0;
d463 1
a463 1
					me->me_key.med_addr.bits = 0;
d541 1
a541 1
					me->me_key.med_addr.bits = 0;
d547 1
a547 1
					me->me_key.med_addr.bits = 0;
d889 1
a889 1
			me->me_key.med_addr.bits = 32;
d902 1
a902 1
			me->me_key.med_addr.bits = 128;
d1764 1
a1764 1
			me->me_key.med_addr.bits = 0;
d1777 1
a1777 1
			me->me_key.med_addr.bits = 0;
@


1.49
log
@fix previous
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2009/12/05 18:42:31 chl Exp $	*/
d439 1
a439 1
					me->me_key.med_addr.ss = *(struct sockaddr_storage *)&ssin;
d449 1
a449 1
					me->me_key.med_addr.ss = *(struct sockaddr_storage *)&ssin6;
d458 1
a458 1
					me->me_key.med_addr.ss = *(struct sockaddr_storage *)&ssin;
d464 1
a464 1
					me->me_key.med_addr.ss = *(struct sockaddr_storage *)&ssin6;
d523 1
a523 1
					me->me_key.med_addr.ss = *(struct sockaddr_storage *)&ssin;
d533 1
a533 1
					me->me_key.med_addr.ss = *(struct sockaddr_storage *)&ssin6;
d542 1
a542 1
					me->me_key.med_addr.ss = *(struct sockaddr_storage *)&ssin;
d548 1
a548 1
					me->me_key.med_addr.ss = *(struct sockaddr_storage *)&ssin6;
@


1.48
log
@fix interface tagging listeners in the ipv6 case

while there factor some common code (from jacekm input)

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2009/11/12 12:35:03 jacekm Exp $	*/
a1706 1

d1714 1
d1716 3
a1718 1
			break;
@


1.47
log
@Fix a memleak in parse_config(). Correct return code in few error paths.
Fix two memleaks in purge_config().

First problem spotted by parfait, the other ones - by myself.

"looks good" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2009/11/05 12:24:13 gilles Exp $	*/
d1698 3
a1702 2
			if ((h = calloc(1, sizeof(*h))) == NULL)
				fatal(NULL);
a1707 15
			h->fd = -1;
			h->port = port;
			h->flags = flags;
			h->ssl = NULL;
			h->ssl_cert_name[0] = '\0';
			if (cert != NULL)
				(void)strlcpy(h->ssl_cert_name, cert, sizeof(h->ssl_cert_name));
			if (tag != NULL)
				(void)strlcpy(h->tag, tag, sizeof(h->tag));
			if (tag != NULL)
				(void)strlcpy(h->tag, tag, sizeof(h->tag));

			ret = 1;
			TAILQ_INSERT_HEAD(al, h, entry);

a1710 2
			if ((h = calloc(1, sizeof(*h))) == NULL)
				fatal(NULL);
d1716 2
a1717 7
			h->fd = -1;
			h->port = port;
			h->flags = flags;
			h->ssl = NULL;
			h->ssl_cert_name[0] = '\0';
			if (cert != NULL)
				(void)strlcpy(h->ssl_cert_name, cert, sizeof(h->ssl_cert_name));
d1719 9
a1727 2
			ret = 1;
			TAILQ_INSERT_HEAD(al, h, entry);
d1729 2
a1730 2
			break;
		}
@


1.46
log
@some structures reference the maps they use by their id, if we allow 0 as a
valid map id, then we have no way to know for these structures if they have
a reference to a map, or if the member was not set. make map id start at 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2009/11/03 22:57:41 gilles Exp $	*/
d1362 1
a1362 1
		return 0;
d1367 1
a1367 1
		return 0;
d1373 1
a1373 1
		return 0;
d1380 1
a1380 1
		return 0;
d1388 1
a1388 1
		return 0;
d1409 1
@


1.45
log
@teach makemap how to build a set, which is a map containing only keys.
smtpd is now capable of looking primary domains at runtime in a set, which
means that the following becomes possible:

	map "primary" { source db "/etc/mail/primary.db" }
	accept for domain map "primary" deliver to mbox

while at it fix a couple bugs in the aliases resolution path which caused
recipients to bounce if a ruleset did not have an "accept for local" rule

"diff reads good" jacekm@@, flush queue & make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2009/11/03 20:55:23 gilles Exp $	*/
d88 1
a88 1
objid_t			 last_map_id = 0;
d1392 1
a1392 1
	last_map_id = 0;
@


1.44
log
@this commit removes the hardcoded special "aliases" map and brings support
for multiple aliases maps that can be attached at the rule level. with it,
you can for example define different aliases maps for different domains or
different aliases maps for the same domain depending on the client source:

map "localiases" { source db "/etc/mail/localiases.db" }
map "netaliases" { source db "/etc/mail/netaliases.db" }

accept from 192.168.0.0/16 for local alias "localiases" deliver to mbox
accept from all for local alias "netaliases" deliver to mbox

idea discussed with jacekm@@ and various other hackers, diff contains some
bug fixes too which were not part of the original diff. man page follows
very shortly ... make clean & flush queue !
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2009/10/19 21:09:55 gilles Exp $	*/
d508 1
@


1.43
log
@change virtual rule so that it reads: accept for virtual "mapname", instead
of: accept for virtual map "mapname" ...

discussed with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2009/10/19 20:48:13 gilles Exp $	*/
d122 1
a122 1
%token	ARROW ENABLE AUTH TLS LOCAL VIRTUAL USER TAG
d130 1
a130 1
%type	<v.string>	certname user tag on
a387 9
			if (strcmp(map->m_name, "aliases") == 0 ||
			    strcmp(map->m_name, "virtual") == 0) {
				if (map->m_src != S_DB) {
					yyerror("map source must be db");
					free(map);
					map = NULL;
					YYERROR;
				}
			}
d639 4
d652 1
a652 1
		| DOMAIN mapref			{
d654 10
a682 1

d689 1
a689 1
		| LOCAL {
d694 9
d986 1
@


1.42
log
@currently, smtpd is capable of having multiple listeners with different
options but they will all share the same ruleset. this means that there
is no way to have a rule apply to a session established on one listener
but not applied on another.

this commit brings initial support for tagging listeners and having the
rules able to match these specific listeners. The following will define
a rule which will only apply to interfaces tagged as "mynet":

listen on lo0			# implicit lo0 tag
listen on fxp0 tag mynet
listen on fxp1 tag mynet

accept on mynet for domain "example.org" deliver to mbox
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2009/10/19 20:00:46 gilles Exp $	*/
d666 1
a666 1
		| VIRTUAL MAP STRING		{
d670 3
a672 3
			if ((m = map_findbyname(conf, $3)) == NULL) {
				yyerror("no such map: %s", $3);
				free($3);
d675 1
a675 1
			free($3);
@


1.41
log
@users within virtual domains do not necessarily map to a real user account,
teach smtpd how to deliver using specific user permissions:

	accept for virtual map "foo" deliver to maildir "/m/%d/%u" user foo

will deliver mail under /m/domain/user as user foo

idea and initial diff discussed with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2009/10/11 17:40:49 gilles Exp $	*/
d95 6
a100 6
int		 host_dns(const char *, const char *, struct listenerlist *,
		    int, in_port_t, u_int8_t);
int		 host(const char *, const char *, struct listenerlist *,
		    int, in_port_t, u_int8_t);
int		 interface(const char *, const char *, struct listenerlist *,
		    int, in_port_t, u_int8_t);
d122 1
a122 1
%token	ARROW ENABLE AUTH TLS LOCAL VIRTUAL USER
d130 1
a130 1
%type	<v.string>	certname user
d235 12
d250 1
a250 1
		| LISTEN ON STRING port ssl certname auth {
d252 1
d257 1
d265 1
d286 1
d292 5
a296 1
			if (! interface($3, cert, conf->sc_listeners,
d298 1
a298 1
				if (host($3, cert, conf->sc_listeners,
d301 1
d307 1
d910 12
a921 1
rule		: decision from			{
d927 6
a932 1
			rule->r_sources = map_find(conf, $2);
d936 1
a936 1
		} FOR conditions action	{
d1007 1
d1573 2
a1574 2
host_dns(const char *s, const char *cert, struct listenerlist *al, int max, in_port_t port,
    u_int8_t flags)
d1608 2
d1637 2
a1638 2
host(const char *s, const char *cert, struct listenerlist *al, int max, in_port_t port,
    u_int8_t flags)
d1655 2
a1656 1

d1662 1
a1662 1
	return (host_dns(s, cert, al, max, port, flags));
d1666 2
a1667 2
interface(const char *s, const char *cert, struct listenerlist *al, int max, in_port_t port,
    u_int8_t flags)
d1698 4
@


1.40
log
@implement proper virtual domains instead of faking them on top of primary
domains. this means that:

- virtual domains no longer deliver to a local user when not told to
- they no longer attempt to resolve aliases when not told to
- they no longer need an explicit rule in smtpd.conf for EACH domain
- the "virtual" map is no longer hardcoded
- smtpd no longer needs a restart to support a new domain

instead we introduce the: accept for virtual map "mapname" [...] syntax
which refers to a map that can be manipulated at runtime.

idea discussed and okayd with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2009/09/16 20:22:18 jacekm Exp $	*/
d122 1
a122 1
%token	ARROW ENABLE AUTH TLS LOCAL VIRTUAL
d130 1
a130 1
%type	<v.string>	certname
d736 16
a751 1
action		: DELIVER TO MAILDIR		{
d758 2
a759 1
		| DELIVER TO MAILDIR STRING	{
d767 1
a767 1
		| DELIVER TO MBOX		{
d774 2
a775 1
		| DELIVER TO MDA STRING		{
d972 1
@


1.39
log
@Do not print "could not load cert" warning at startup if certificate is not
required.  Requested by jmc@@, gilles@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2009/06/05 23:04:51 jacekm Exp $	*/
d122 1
a122 1
%token	ARROW ENABLE AUTH TLS LOCAL
d644 19
d956 1
@


1.38
log
@if path in "deliver to maildir path" is omitted, use ~/Maildir by
default; from gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2009/06/02 22:23:35 gilles Exp $	*/
d269 5
a273 10
			if (ssl_load_certfile(conf, cert, F_SCERT) < 0) {
				log_warnx("warning: could not load cert: %s, "
				    "no SSL/TLS/AUTH support", cert);
				if ($5) {
					yyerror("cannot load certificate: %s",
					    cert);
					free($6);
					free($3);
					YYERROR;
				}
@


1.37
log
@make env->sc_listeners and env->sc_ssl pointers, one step further toward
configuration reloading without killing active sessions; ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2009/05/30 23:53:41 gilles Exp $	*/
d722 8
a729 1
action		: DELIVER TO MAILDIR STRING	{
@


1.36
log
@It is now possible to specify a certificate to use when relaying to another
host which requests client certificates:

	accept [...] relay via [...] ssl certificate "mycert"

diff from Josh Elsasser <josh@@elsasser.org>, tested and okayed by me with
no change but the addition of status 554 to the state machine to deal with
remote host telling us it doesn't like our certificate.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2009/05/27 16:51:26 jacekm Exp $	*/
d281 1
a281 1
			if (! interface($3, cert, &conf->sc_listeners,
d283 1
a283 1
				if (host($3, cert, &conf->sc_listeners,
d1275 13
d1292 2
d1303 1
a1303 1
	TAILQ_INIT(&conf->sc_listeners);
d1306 1
a1307 1
	SPLAY_INIT(&conf->sc_ssl);
@


1.35
log
@temporary fix to a ruleset processing bug that stems from the fact
that the ip address/subnet parsing isn't done in the same way as
in other daemons.

fix by gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2009/05/21 01:27:48 gilles Exp $	*/
d269 1
a269 1
			if (ssl_load_certfile(conf, cert) < 0) {
d748 1
a748 1
		| RELAY VIA STRING port ssl auth {
d751 3
a753 2
			if ($5 == 0 && $6) {
				yyerror("error: auth over insecure channel");
d766 1
a766 1
			if ($6)
d769 14
d784 1
@


1.34
log
@no longer create a dynamic map with 127.0.0.1 and ::1 for every single rule
that has an implicit local source. instead we create static "localhost" map
before the configuration file is parsed, we fill it with every single local
address we can find, and we have rules with implicit local source reference
that special map.

this unbreaks a behavior which I hated and which prevented:

	accept for all relay

from accepting relaying if LOCAL session was initiated on any interface but
lo0.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2009/05/20 14:29:44 gilles Exp $	*/
d432 1
d442 1
d451 1
d457 1
d515 1
d525 1
d534 1
d540 1
d800 1
d813 1
@


1.33
log
@first step towards configuration reload in smtpd, smtpctl reload will parse
the configuration file again and replace current configuration with new one
in all processes. what we don't support yet is graceful restart, clients in
sessions at the moment of the reload will have a temp failure thrown at 'em
which is ok RFC-wise but which we will try to improve anyway.

tested with various setups, "diff reads good" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2009/04/12 16:03:01 gilles Exp $	*/
d101 1
a817 43
			struct mapel	*me;
			struct sockaddr_in *ssin;
			struct sockaddr_in6 *ssin6;

			if ((m = calloc(1, sizeof(*m))) == NULL)
				fatal("out of memory");
			m->m_id = last_map_id++;
			if (m->m_id == INT_MAX) {
				yyerror("too many maps defined");
				free(m);
				YYERROR;
			}
			if (! bsnprintf(m->m_name, sizeof(m->m_name),
				"<dynamic(%u)>", m->m_id))
				fatal("snprintf");
			m->m_flags |= F_DYNAMIC|F_USED;
			m->m_type = T_SINGLE;

			TAILQ_INIT(&m->m_contents);

			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");
			me->me_key.med_addr.bits = 0;
			ssin = (struct sockaddr_in *)&me->me_key.med_addr.ss;
			ssin->sin_family = AF_INET;
			if (inet_pton(AF_INET, "127.0.0.1", &ssin->sin_addr) != 1) {
				free(me);
				free(m);
				YYERROR;
			}
			TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);

			if ((me = calloc(1, sizeof(*me))) == NULL)
				fatal("out of memory");
			me->me_key.med_addr.bits = 0;
			ssin6 = (struct sockaddr_in6 *)&me->me_key.med_addr.ss;
			ssin6->sin6_family = AF_INET6;
			if (inet_pton(AF_INET6, "::1", &ssin6->sin6_addr) != 1) {
				free(me);
				free(m);
				YYERROR;
			}
			TAILQ_INSERT_TAIL(&m->m_contents, me, me_entry);
d819 1
a819 1
			TAILQ_INSERT_TAIL(conf->sc_maps, m, m_entry);
d1236 1
d1249 6
d1279 12
d1607 48
@


1.32
log
@Code assumed the certificate name to always match the interface name, even
when a certificate name was explicitely provided. This would cause imsg to
fatal() because with some configurations, it would look for the wrong name
in the ssl tree and would fail to find the proper cert.

issue spotted by Gregory Edigarov <gregory.edigarov@@gmail.com>, I found the
fix just a few minutes ago when I succeeded to reproduce the issue...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2009/04/09 19:49:34 jacekm Exp $	*/
d1591 1
d1612 1
@


1.31
log
@change syntax of the "listen on" and "relay via" directives:
1) kill the ssmtp keyword in "ssmtp listen on ...";
2) kill the use keyword in "... use certificate foo";
3) tls no longer implicit, user must explicitely use the tls or smtps option.
4) for "relay via", move the tls/smtps options to right after the
port specification; makes it similar to "listen on".

These directives:

  ssmtp listen on fxp0 use ceritifate "foo"
  accept for all relay via tls "mx.bar.com"

now become:

  listen on fxp0 smtps certificate "foo"
  accept for all relay via "mx.bar.com" tls

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2009/03/31 21:03:49 tobias Exp $	*/
d95 1
a95 1
int		 host_dns(const char *, struct listenerlist *,
d97 3
a99 1
int		 host(const char *, struct listenerlist *,
a100 2
int		 interface(const char *, struct listenerlist *, int, in_port_t,
		    u_int8_t);
d280 1
a280 1
			if (! interface($3, &conf->sc_listeners,
d282 1
a282 1
				if (host($3, &conf->sc_listeners,
d1476 1
a1476 1
host_dns(const char *s, struct listenerlist *al, int max, in_port_t port,
d1508 3
a1510 1
		(void)strlcpy(h->ssl_cert_name, s, sizeof(h->ssl_cert_name));
d1538 1
a1538 1
host(const char *s, struct listenerlist *al, int max, in_port_t port,
d1553 4
a1556 1
		(void)strlcpy(h->ssl_cert_name, s, sizeof(h->ssl_cert_name));
d1562 1
a1562 1
	return (host_dns(s, al, max, port, flags));
d1566 1
a1566 1
interface(const char *s, struct listenerlist *al, int max, in_port_t port,
d1594 3
a1596 1
			(void)strlcpy(h->ssl_cert_name, s, sizeof(h->ssl_cert_name));
d1614 3
a1616 1
			(void)strlcpy(h->ssl_cert_name, s, sizeof(h->ssl_cert_name));
@


1.30
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2009/03/19 00:40:34 gilles Exp $	*/
d116 2
a117 2
%token	QUEUE INTERVAL LISTEN ON ALL PORT USE
%token	MAP TYPE HASH LIST SINGLE SSL SSMTP CERTIFICATE
d125 1
a125 1
%type	<v.number>	quantifier decision port ssmtp from auth ssl
d217 2
a218 2
certname	: USE CERTIFICATE STRING	{
			if (($$ = strdup($3)) == NULL)
d220 1
a220 1
			free($3);
d225 1
a225 5
ssmtp		: SSMTP				{ $$ = 1; }
		| /* empty */			{ $$ = 0; }
		;

ssl		: SSMTP				{ $$ = F_SSMTP; }
d237 1
a237 1
		| ssmtp LISTEN ON STRING port certname auth {
d241 17
a257 3
			if ($5 == 0) {
				if ($1)
					$5 = htons(465);
d259 1
a259 1
					$5 = htons(25);
a260 1
			cert = ($6 != NULL) ? $6 : $4;
d262 2
a263 1
			flags = 0;
d271 1
a271 1
				if ($1 || $6 != NULL) {
d275 1
a275 1
					free($4);
a278 6
			else {
				if ($1)
					flags |= F_SSMTP;
				else
					flags |= F_STARTTLS;
			}
d280 5
a284 5
			if (! interface($4, &conf->sc_listeners,
				MAX_LISTEN, $5, flags)) {
				if (host($4, &conf->sc_listeners,
					MAX_LISTEN, $5, flags) <= 0) {
					yyerror("invalid virtual ip or interface: %s", $4);
d286 1
a286 1
					free($4);
d291 1
a291 1
			free($4);
d739 1
a739 1
		| RELAY VIA ssl STRING port auth {
d742 5
a746 2
			if ($3)
				rule->r_value.relayhost.flags = $3;
d748 1
a748 1
			if (strlcpy(rule->r_value.relayhost.hostname, $4,
d753 4
a756 8
			if ($5 == 0)
				rule->r_value.relayhost.port = 0;
			else
				rule->r_value.relayhost.port = $5;

			if ($6) {
				if (! $3)
					fatalx("cannot auth over insecure channel");
a757 1
			}
d759 1
a759 1
			free($4);
d944 1
a946 1
		{ "ssmtp",		SSMTP },
a949 1
		{ "use",		USE },
@


1.29
log
@when listen was declared without a port parameter, it would get it wrong
because of a missing htons()
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2009/03/16 23:26:40 gilles Exp $	*/
d1231 1
a1231 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d1235 5
d1280 5
a1284 2
	if ((conf->sc_maps = calloc(1, sizeof(*conf->sc_maps))) == NULL ||
	    (conf->sc_rules = calloc(1, sizeof(*conf->sc_rules))) == NULL) {
d1286 1
@


1.28
log
@in accept rules, support "for local" as a destination which is an alias to
"localhost" and system hostname. this allows us to ship with a config file
that goes:  accept for local deliver to mbox  , and which will allow us to
have mail working sanely out of the box.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2009/03/09 01:43:19 gilles Exp $	*/
d247 1
a247 1
					$5 = 487;
d249 1
a249 1
					$5 = 25;
@


1.27
log
@add basic support for outgoing authentication (AUTH PLAIN over ssl) which
can be turned on by adding "enable auth" to a "relay via" rule. this made
me rework the mx resolution so that it is done by the mta process and not
the runner process anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2009/03/08 21:50:33 gilles Exp $	*/
d121 1
a121 1
%token	ARROW ENABLE AUTH TLS
d636 49
d930 1
@


1.26
log
@supporting delivery to a mbox that's not in _PATH_MAILDIR is not supported,
if someone comes with good rationale why this is needed, we'll consider it,
meanwhile it's more work than it looks like and it brings a lot of pain.

discussed with jacekm@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2009/02/22 11:44:29 form Exp $	*/
d686 1
a686 1
		| RELAY VIA ssl STRING port {
d701 6
@


1.25
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2009/01/30 10:09:58 form Exp $	*/
d42 1
d668 1
a668 1
		| DELIVER TO MBOX STRING		{
d670 1
a670 1
			if (strlcpy(rule->r_value.path, $4,
a673 1
			free($4);
@


1.24
log
@more const -> sizeof()
no binary changes

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2009/01/28 21:44:15 gilles Exp $	*/
d485 2
a486 1
			if (! bsnprintf(m->m_name, MAX_LINE_SIZE, "<dynamic(%u)>", m->m_id))
d559 2
a560 1
			if (! bsnprintf(m->m_name, MAX_LINE_SIZE, "<dynamic(%u)>", m->m_id))
d585 2
a586 1
			if (! bsnprintf(m->m_name, MAX_LINE_SIZE, "<dynamic(%u)>", m->m_id))
d723 2
a724 1
			if (! bsnprintf(m->m_name, MAX_LINE_SIZE, "<dynamic(%u)>", m->m_id))
d772 2
a773 1
			if (! bsnprintf(m->m_name, MAX_LINE_SIZE, "<dynamic(%u)>", m->m_id))
@


1.23
log
@first steps towards better mta code. currently mta uses struct batch to
store a lot of its session related code, but this is just not right and
this commit starts making mta code aware of struct session. This will
ease the implementation of ssl sessions in mta.

while at it, make mta autodetect port to use if it isn't provided in a
rule but can be derived from a parameter (i.e: "relay via ssmtp ...").
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2009/01/14 23:36:52 gilles Exp $	*/
d309 2
a310 2
			if (strlcpy(map->m_config, $2, MAXPATHLEN)
			    >= MAXPATHLEN)
d658 3
a660 2
			if (strlcpy(rule->r_value.path, $4, MAXPATHLEN)
			    >= MAXPATHLEN)
d666 3
a668 2
			if (strlcpy(rule->r_value.path, $4, MAXPATHLEN)
			    >= MAXPATHLEN)
d674 3
a676 2
			if (strlcpy(rule->r_value.command, $4, MAXPATHLEN)
			    >= MAXPATHLEN)
d689 3
a691 2
			if (strlcpy(rule->r_value.relayhost.hostname, $4, MAXHOSTNAMELEN)
			    >= MAXHOSTNAMELEN)
@


1.22
log
@slightly change "relay via" so that it can differentiate "ssmtp", "tls" and
"ssl" while providing mta with the informations it needs to do its work.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2009/01/04 16:40:58 gilles Exp $	*/
d691 1
a691 1
				rule->r_value.relayhost.port = 25;
@


1.21
log
@- change name of "masked" member in struct netaddr, it was misleading
- allow "from all" so that the ugly "accept from { 0.0.0.0/0, ::/0 }"
construct becomes a nice looking "accept from all"

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2008/12/20 00:18:03 gilles Exp $	*/
d120 1
a120 1
%token	ARROW ENABLE AUTH
d124 1
a124 1
%type	<v.number>	quantifier decision port ssmtp from auth
d228 5
d680 1
a680 1
		| RELAY VIA ssmtp STRING port {
d684 1
a684 1
				rule->r_value.relayhost.flags = F_SSMTP;
d880 1
@


1.20
log
@- import first bricks of SMTP AUTH support. currently only AUTH PLAIN is
	supported, AUTH LOGIN will follow soon. AUTH will only work if a
	listen directive has "enable auth" keywords, AND session is safe
	(ssmtp or starttls).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2008/12/18 22:13:57 gilles Exp $	*/
d419 1
a419 1
					me->me_key.med_addr.masked = bits;
d428 1
a428 1
					me->me_key.med_addr.masked = bits;
d436 1
a436 1
					me->me_key.med_addr.masked = 0;
d441 1
a441 1
					me->me_key.med_addr.masked = 0;
d497 1
a497 1
					me->me_key.med_addr.masked = bits;
d506 1
a506 1
					me->me_key.med_addr.masked = bits;
d514 1
a514 1
					me->me_key.med_addr.masked = 0;
d519 1
a519 1
					me->me_key.med_addr.masked = 0;
d697 48
d768 1
a768 1
			me->me_key.med_addr.masked = 0;
d780 1
a780 1
			me->me_key.med_addr.masked = 0;
@


1.19
log
@- condition lists is wrongly described, unbreak the following syntax:
	"accept for { domain "foo", domain "bar" } ..."
	From Nicholas Mariott <nicholas.marriott@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2008/12/11 23:19:00 gilles Exp $	*/
d120 1
a120 1
%token	ARROW
d124 1
a124 1
%type	<v.number>	quantifier decision port ssmtp from
d228 4
d235 1
a235 1
		| ssmtp LISTEN ON STRING port certname {
d248 4
d254 1
a254 1
				    "no SSL/TLS support", cert);
d265 1
a265 1
					flags = F_SSMTP;
d267 1
a267 1
					flags = F_STARTTLS;
d795 1
d802 1
@


1.18
log
@- last snprintf -> bsnprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2008/12/11 23:06:39 gilles Exp $	*/
d630 3
@


1.17
log
@- snprintf -> bsnprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2008/12/10 23:04:24 jacekm Exp $	*/
d700 1
a700 1
			if (! snprintf(m->m_name, MAX_LINE_SIZE, "<dynamic(%u)>", m->m_id))
@


1.16
log
@That the "aliases" and "virtual" maps satisfy m_src == S_DB is checked
too late, ie. at alias resolution time, and it's only a log_info.

Move the check to parse.y, and make daemon die if m_src != S_DB.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2008/12/06 14:23:47 jacekm Exp $	*/
a462 1
			int spret;
d472 1
a472 2
			spret = snprintf(m->m_name, MAX_LINE_SIZE, "<dynamic(%u)>", m->m_id);
			if (spret == -1 || spret >= MAX_LINE_SIZE)
a534 1
			int spret;
d545 1
a545 2
			spret = snprintf(m->m_name, MAX_LINE_SIZE, "<dynamic(%u)>", m->m_id);
			if (spret == -1 || spret >= MAX_LINE_SIZE)
a559 1
			int spret;
d570 1
a570 2
			spret = snprintf(m->m_name, MAX_LINE_SIZE, "<dynamic(%u)>", m->m_id);
			if (spret == -1 || spret >= MAX_LINE_SIZE)
a690 1
			int spret;
d700 1
a700 2
			spret = snprintf(m->m_name, MAX_LINE_SIZE, "<dynamic(%u)>", m->m_id);
			if (spret == -1 || spret >= MAX_LINE_SIZE)
@


1.15
log
@Unbreak -Werror.

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2008/12/06 02:04:56 gilles Exp $	*/
d351 9
@


1.14
log
@- it is now possible to specify an interface instead of an address or a
	hostname in a listen statement (ie: listen on lo0)
	request by deraadt@@ a while ago, ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2008/12/04 17:24:13 cloder Exp $	*/
d98 2
@


1.13
log
@Declare printf-style functions with __attribute__((format(printf,x,x)))
and fix some of the errors caught by this. Part of a general push to
make yyerror() -Wformat clean throughout the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2008/12/04 00:10:15 ian Exp $	*/
d40 1
d260 9
a268 6
			if (host($4, &conf->sc_listeners,
			    MAX_LISTEN, $5, flags) <= 0) {
				yyerror("invalid virtual ip: %s", $4);
				free($6);
				free($4);
				YYERROR;
d1414 61
@


1.12
log
@obvious 'missing space' typo in message, ok gilles@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2008/11/25 20:26:40 gilles Exp $	*/
a63 1
int		 yyerror(const char *, ...);
d69 2
d182 1
a182 1
				yyerror("invalid interval: %d\n", $1);
d203 1
a203 1
				yyerror("invalid port: %d", $2);
d341 1
a341 1
				yyerror("map %s has no source defined");
d578 1
a578 1
				yyerror("no such map: %s");
@


1.11
log
@- recent change in parse.y caused htons() to be called twice on the port
	provided to "relay via" rules, once in parse.y once in lka.c, fix.
- rename struct address to struct relayhost, introduce struct mxhost which
	not only holds the sockaddr_storage, but also additionnal flags we
	want forwarded to the mta process.
- propagate the change
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2008/11/22 20:26:08 gilles Exp $	*/
d241 1
a241 1
				log_warnx("warning: could not load cert: %s,"
@


1.10
log
@- allow the optionnal ssmtp keywork in "relay via" rules, while at it
	allow port to become optionnal (implicit 25) or provided by value
	or name.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2008/11/13 23:24:19 gilles Exp $	*/
d233 1
a233 1
					$5 = htons(487);
d235 1
a235 1
					$5 = htons(25);
d656 5
a660 1
			if (strlcpy(rule->r_value.host.hostname, $4, MAXHOSTNAMELEN)
d665 1
a665 1
				rule->r_value.host.port = htons(25);
d667 1
a667 1
				rule->r_value.host.port = htons($5);
@


1.9
log
@- rephrase the "cannot load cert" warning that is output at startup when a
	listen directive has no matching certificate. it sounds like a
	critical failure when it just means "no tls support".
- minor log_debug() addition in smtp.c
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2008/11/10 22:35:23 gilles Exp $	*/
d654 1
a654 1
		| RELAY VIA STRING PORT NUMBER {
d656 1
a656 1
			if (strlcpy(rule->r_value.host.hostname, $3, MAXHOSTNAMELEN)
d659 7
a665 6
			if ($5 <= 0 || $5 >= (int)USHRT_MAX) {
				yyerror("invalid port: %d", $5);
				YYERROR;
			}
			rule->r_value.host.port = $5;
			free($3);
@


1.8
log
@- define MAX_LINE_SIZE which is the maximum length of a line we allow from
	a client. it must be set to the highest value we have from all of
	the extensions which are/will be implemented.
- replace all occurences of STRLEN define with MAX_LINE_SIZE, kill STRLEN
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2008/11/10 17:24:24 deraadt Exp $	*/
d241 2
a242 1
				log_warnx("could not load cert: %s", cert);
@


1.7
log
@spaces fixed while reading code
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2008/11/10 02:13:40 gilles Exp $	*/
d456 2
a457 2
			spret = snprintf(m->m_name, STRLEN, "<dynamic(%u)>", m->m_id);
			if (spret == -1 || spret >= STRLEN)
d531 2
a532 2
			spret = snprintf(m->m_name, STRLEN, "<dynamic(%u)>", m->m_id);
			if (spret == -1 || spret >= STRLEN)
d558 2
a559 2
			spret = snprintf(m->m_name, STRLEN, "<dynamic(%u)>", m->m_id);
			if (spret == -1 || spret >= STRLEN)
d685 2
a686 2
			spret = snprintf(m->m_name, STRLEN, "<dynamic(%u)>", m->m_id);
			if (spret == -1 || spret >= STRLEN)
@


1.6
log
@- move '=>' into the lex loop, requested by and with help from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2008/11/10 00:57:35 gilles Exp $	*/
d48 1
a48 1
	
a186 1
		
d188 1
a188 1
port		: PORT STRING 			{
d200 1
a200 1
		| PORT NUMBER 			{
d224 1
a224 1
main		: QUEUE INTERVAL interval 	{
d259 1
a259 1
				yyerror("invalid virtual ip: %s", $4);  
d286 1
a286 1
		| DB STRING    			{
d354 1
a354 1
			
d518 1
a518 1
		| '(' 				{
d545 1
a545 1
		| '{' 				{
d676 1
a676 1
			
@


1.5
log
@- snprintf() can return -1, make sure every call is checked properly
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2008/11/10 00:29:33 gilles Exp $	*/
d116 1
a116 1
%token	KVSEP
d350 1
a350 1
keyval		: STRING KVSEP STRING		{
a768 1
		{ "=>",			KVSEP },
d1022 7
@


1.4
log
@- recognize '=>' as one token instead of trying to match '=' and '>'. this
	prevents:  "foo  =      >  bar" from being valid
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2008/11/05 12:14:45 sobrado Exp $	*/
d447 1
d457 3
a459 1
			snprintf(m->m_name, STRLEN, "<dynamic(%u)>", m->m_id);
d521 1
d532 3
a534 1
			snprintf(m->m_name, STRLEN, "<dynamic(%u)>", m->m_id);
d548 1
d559 3
a561 1
			snprintf(m->m_name, STRLEN, "<dynamic(%u)>", m->m_id);
d676 1
d686 3
a688 1
			snprintf(m->m_name, STRLEN, "<dynamic(%u)>", m->m_id);
@


1.3
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d116 1
d350 1
a350 1
keyval		: STRING '=' '>' STRING		{
d359 1
a359 1
			    strlcpy(me->me_val.med_string, $4,
d363 1
a363 1
				    $1, $4);
d366 1
a366 1
				free($4);
d370 1
a370 1
			free($4);
d757 1
@


1.2
log
@- put back all copyright holders
- add myself as a copyright holder
@
text
@d1 2
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d2 1
d4 4
@

