head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.12
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.10
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	ZBTFreARDSMmzOIV;

1.6
date	2014.07.08.15.45.32;	author eric;	state Exp;
branches;
next	1.5;
commitid	BLF7pkUK3dHr6Hox;

1.5
date	2013.07.19.20.37.07;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.7
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@/*	$OpenBSD: queue_ram.c,v 1.6 2014/07/08 15:45:32 eric Exp $	*/

/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <inttypes.h>
#include <libgen.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

#include "smtpd.h"
#include "log.h"

struct qr_envelope {
	char		*buf;
	size_t		 len;
};

struct qr_message {
	char		*buf;
	size_t		 len;
	struct tree	 envelopes;
};

static struct tree messages;

static struct qr_message *
get_message(uint32_t msgid)
{
	struct qr_message	*msg;

        msg = tree_get(&messages, msgid);
        if (msg == NULL)
                log_warn("warn: queue-ram: message not found");

	return (msg);
}

static int
queue_ram_message_create(uint32_t *msgid)
{
	struct qr_message	*msg;

	msg = calloc(1, sizeof(*msg));
	if (msg == NULL) {
		log_warn("warn: queue-ram: calloc");
		return (0);
	}
	tree_init(&msg->envelopes);

	do {
		*msgid = queue_generate_msgid();
	} while (tree_check(&messages, *msgid));

	tree_xset(&messages, *msgid, msg);

	return (1);
}

static int
queue_ram_message_commit(uint32_t msgid, const char *path)
{
	struct qr_message	*msg;
	struct stat		 sb;
	size_t			 n;
	FILE			*f;
	int			 ret;

	if ((msg = tree_get(&messages, msgid)) == NULL) {
		log_warnx("warn: queue-ram: msgid not found");
		return (0);
	}

	f = fopen(path, "rb");
	if (f == NULL) {
		log_warn("warn: queue-ram: fopen: %s", path);
		return (0);
	}
	if (fstat(fileno(f), &sb) == -1) {
		log_warn("warn: queue-ram: fstat");
		fclose(f);
		return (0);
	}

	msg->len = sb.st_size;
	msg->buf = malloc(msg->len);
	if (msg->buf == NULL) {
		log_warn("warn: queue-ram: malloc");
		fclose(f);
		return (0);
	}

	ret = 0;
	n = fread(msg->buf, 1, msg->len, f);
	if (ferror(f))
		log_warn("warn: queue-ram: fread");
	else if ((off_t)n != sb.st_size)
		log_warnx("warn: queue-ram: bad read");
	else {
		ret = 1;
		stat_increment("queue.ram.message.size", msg->len);
	}
	fclose(f);

	return (ret);
}

static int
queue_ram_message_delete(uint32_t msgid)
{
	struct qr_message	*msg;
	struct qr_envelope	*evp;
	uint64_t		 evpid;

	if ((msg = tree_pop(&messages, msgid)) == NULL) {
		log_warnx("warn: queue-ram: not found");
		return (0);
	}
	while (tree_poproot(&messages, &evpid, (void**)&evp)) {
		stat_decrement("queue.ram.envelope.size", evp->len);
		free(evp->buf);
		free(evp);
	}
	stat_decrement("queue.ram.message.size", msg->len);
	free(msg->buf);
	free(msg);
	return (0);
}

static int
queue_ram_message_fd_r(uint32_t msgid)
{
	struct qr_message	*msg;
	size_t			 n;
	FILE			*f;
	int			 fd, fd2;

	if ((msg = tree_get(&messages, msgid)) == NULL) {
		log_warnx("warn: queue-ram: not found");
		return (-1);
	}

	fd = mktmpfile();
	if (fd == -1) {
		log_warn("warn: queue-ram: mktmpfile");
		return (-1);
	}

	fd2 = dup(fd);
	if (fd2 == -1) {
		log_warn("warn: queue-ram: dup");
		close(fd);
		return (-1);
	}
	f = fdopen(fd2, "w");
	if (f == NULL) {
		log_warn("warn: queue-ram: fdopen");
		close(fd);
		close(fd2);
		return (-1);
	}
	n = fwrite(msg->buf, 1, msg->len, f);
	if (n != msg->len) {
		log_warn("warn: queue-ram: write");
		close(fd);
		fclose(f);
		return (-1);
	}
	fclose(f);
	lseek(fd, 0, SEEK_SET);
	return (fd);
}

static int
queue_ram_message_corrupt(uint32_t msgid)
{
	return (queue_ram_message_delete(msgid));
}

static int
queue_ram_envelope_create(uint32_t msgid, const char *buf, size_t len,
    uint64_t *evpid)
{
	struct qr_envelope	*evp;
	struct qr_message	*msg;

	if ((msg = get_message(msgid)) == NULL)
		return (0);

	do {
		*evpid = queue_generate_evpid(msgid);
	} while (tree_check(&msg->envelopes, *evpid));
	evp = calloc(1, sizeof *evp);
	if (evp == NULL) {
		log_warn("warn: queue-ram: calloc");
		return (0);
	}
	evp->len = len;
	evp->buf = malloc(len);
	if (evp->buf == NULL) {
		log_warn("warn: queue-ram: malloc");
		free(evp);
		return (0);
	}
	memmove(evp->buf, buf, len);
	tree_xset(&msg->envelopes, *evpid, evp);
	stat_increment("queue.ram.envelope.size", len);
	return (1);
}

static int
queue_ram_envelope_delete(uint64_t evpid)
{
	struct qr_envelope	*evp;
	struct qr_message	*msg;

	if ((msg = get_message(evpid_to_msgid(evpid))) == NULL)
		return (0);

	if ((evp = tree_pop(&msg->envelopes, evpid)) == NULL) {
		log_warnx("warn: queue-ram: not found");
		return (0);
	}
	stat_decrement("queue.ram.envelope.size", evp->len);
	free(evp->buf);
	free(evp);
	if (tree_empty(&msg->envelopes)) {
		tree_xpop(&messages, evpid_to_msgid(evpid));
		stat_decrement("queue.ram.message.size", msg->len);
		free(msg->buf);
		free(msg);
	}
	return (1);
}

static int
queue_ram_envelope_update(uint64_t evpid, const char *buf, size_t len)
{
	struct qr_envelope	*evp;
	struct qr_message	*msg;
	void			*tmp;

	if ((msg = get_message(evpid_to_msgid(evpid))) == NULL)
		return (0);

	if ((evp = tree_get(&msg->envelopes, evpid)) == NULL) {
		log_warn("warn: queue-ram: not found");
		return (0);
	}
	tmp = malloc(len);
	if (tmp == NULL) {
		log_warn("warn: queue-ram: malloc");
		return (0);
	}
	memmove(tmp, buf, len);
	free(evp->buf);
	evp->len = len;
	evp->buf = tmp;
	stat_decrement("queue.ram.envelope.size", evp->len);
	stat_increment("queue.ram.envelope.size", len);
	return (1);
}

static int
queue_ram_envelope_load(uint64_t evpid, char *buf, size_t len)
{
	struct qr_envelope	*evp;
	struct qr_message	*msg;

	if ((msg = get_message(evpid_to_msgid(evpid))) == NULL)
		return (0);

	if ((evp = tree_get(&msg->envelopes, evpid)) == NULL) {
		log_warn("warn: queue-ram: not found");
		return (0);
	}
	if (len < evp->len) {
		log_warnx("warn: queue-ram: buffer too small");
		return (0);
	}
	memmove(buf, evp->buf, evp->len);
	return (evp->len);
}

static int
queue_ram_envelope_walk(uint64_t *evpid, char *buf, size_t len)
{
	return (-1);
}

static int
queue_ram_init(struct passwd *pw, int server, const char * conf)
{
	tree_init(&messages);

	queue_api_on_message_create(queue_ram_message_create);
	queue_api_on_message_commit(queue_ram_message_commit);
	queue_api_on_message_delete(queue_ram_message_delete);
	queue_api_on_message_fd_r(queue_ram_message_fd_r);
	queue_api_on_message_corrupt(queue_ram_message_corrupt);
	queue_api_on_envelope_create(queue_ram_envelope_create);
	queue_api_on_envelope_delete(queue_ram_envelope_delete);
	queue_api_on_envelope_update(queue_ram_envelope_update);
	queue_api_on_envelope_load(queue_ram_envelope_load);
	queue_api_on_envelope_walk(queue_ram_envelope_walk);

	return (1);
}

struct queue_backend	queue_backend_ram = {
	queue_ram_init,
};
@


1.6
log
@various queue improvements:

- add a "close" hook to the backend API.
- improve the sync() pattern in queue_fs: only sync at commit
  time and not for every envelope creation
- various fixes to the experimental external queue API.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 1
@


1.5
log
@Assorted queue improvements:
- cleanup the internal queue backend API and get rid of the QOP_* thing.
- implement a queue_proc backend
- rename queue_fsqueue.c to queue_fs
- enable support for queue encryption
- add an envelope cache
- better logging and error reporting
@
text
@d321 1
a321 1
queue_ram_init(struct passwd *pw, int server)
@


1.4
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_ram.c,v 1.3 2013/05/24 17:03:14 eric Exp $	*/
a42 10
static int queue_ram_init(struct passwd *, int);
static int queue_ram_message(enum queue_op, uint32_t *);
static int queue_ram_envelope(enum queue_op , uint64_t *, char *, size_t);

struct queue_backend	queue_backend_ram = {
	queue_ram_init,
	queue_ram_message,
	queue_ram_envelope,
};

a48 1
	int		 hasfile;
d56 12
d69 1
a69 1
queue_ram_init(struct passwd *pw, int server)
d71 14
a84 1
	tree_init(&messages);
d90 1
a90 1
queue_ram_message(enum queue_op qop, uint32_t *msgid)
a91 3
	char			 path[SMTPD_MAXPATHLEN];
	uint64_t		 evpid;
	struct qr_envelope	*evp;
a92 1
	int			 fd, fd2, ret;
d94 1
d96 67
d164 7
d172 5
a176 29
	switch (qop) {
	case QOP_CREATE:
		msg = xcalloc(1, sizeof *msg, "queue_ram_message");
		tree_init(&msg->envelopes);
		do {
			*msgid = queue_generate_msgid();
		} while (tree_check(&messages, *msgid));
		tree_xset(&messages, *msgid, msg);
		return (1);

	case QOP_DELETE:
		if ((msg = tree_pop(&messages, *msgid)) == NULL) {
			log_warnx("warn: queue_ram_message: not found");
			return (0);
		}
		while (tree_poproot(&messages, &evpid, (void**)&evp)) {
			stat_decrement("queue.ram.envelope.size", evp->len);
			free(evp->buf);
			free(evp);
		}
		stat_decrement("queue.ram.message.size", msg->len);
		free(msg->buf);
		if (msg->hasfile) {
			queue_message_incoming_path(*msgid, path, sizeof(path));
			if (unlink(path) == -1)
				log_warn("warn: queue_ram_message: unlink");
		}
		free(msg);
		return (1);
d178 17
a194 29
	case QOP_COMMIT:
		if ((msg = tree_get(&messages, *msgid)) == NULL) {
			log_warnx("warn: queue_ram_message: not found");
			return (0);
		}
		queue_message_incoming_path(*msgid, path, sizeof(path));
		f = fopen(path, "rb");
		if (f == NULL) {
			log_warn("warn: queue_ram: fopen");
			return (0);
		}
		if (fstat(fileno(f), &sb) == -1) {
			log_warn("warn: queue_ram_message: fstat");
			fclose(f);
			return (0);
		}

		msg->len = sb.st_size;
		msg->buf = xmalloc(msg->len, "queue_ram_message");
		ret = 0;
		n = fread(msg->buf, 1, msg->len, f);
		if (ferror(f))
			log_warn("warn: queue_ram_message: fread");
		else if ((off_t)n != sb.st_size)
			log_warnx("warn: queue_ram_message: bad read");
		else {
			ret = 1;
			stat_increment("queue.ram.message.size", msg->len);
		}
d196 12
a207 38
		if (unlink(path) == -1)
			log_warn("warn: queue_ram_message: unlink");
		msg->hasfile = 0;
		return (ret);

	case QOP_FD_R:
		if ((msg = tree_get(&messages, *msgid)) == NULL) {
			log_warnx("warn: queue_ram_message: not found");
			return (-1);
		}
		fd = mktmpfile();
		if (fd == -1) {
			log_warn("warn: queue_ram_message: mktmpfile");
			return (-1);
		}
		fd2 = dup(fd);
		if (fd2 == -1) {
			log_warn("warn: queue_ram_message: dup");
			close(fd);
			return (-1);
		}
		f = fdopen(fd2, "w");
		if (f == NULL) {
			log_warn("warn: queue_ram_message: fdopen");
			close(fd);
			close(fd2);
			return (-1);
		}
		n = fwrite(msg->buf, 1, msg->len, f);
		if (n != msg->len) {
			log_warn("warn: queue_ram_message: write");
			close(fd);
			fclose(f);
			return (-1);
		}
		fclose(f);
		lseek(fd, 0, SEEK_SET);
		return (fd);
d209 6
a214 13
	case QOP_FD_RW:
		if ((msg = tree_get(&messages, *msgid)) == NULL) {
			log_warnx("warn: queue_ram_message: not found");
			return (-1);
		}
		queue_message_incoming_path(*msgid, path, sizeof(path));
		fd = open(path, O_RDWR | O_CREAT | O_EXCL, 0600);
		if (fd == -1) {
			log_warn("warn: queue_ram_message: open");
			return (-1);
		}
		msg->hasfile = 1;
		return (fd);
d216 2
a217 2
	case QOP_CORRUPT:
		return (queue_ram_message(QOP_DELETE, msgid));
d219 7
a225 2
	default:
		fatalx("queue_ram_message: unsupported operation.");
d227 12
d240 23
a262 1
	return (0);
d266 1
a266 1
queue_ram_envelope(enum queue_op qop, uint64_t *evpid, char *buf, size_t len)
d270 1
a270 2
	uint32_t		 msgid;
	char			*tmp;
d272 2
a273 2
	if (qop == QOP_WALK)
		return (-1);
d275 7
a281 4
	msgid = evpid_to_msgid(*evpid);
	msg = tree_get(&messages, msgid);
	if (msg == NULL) {
		log_warn("warn: queue_ram_envelope: message not found");
d284 14
d299 2
a300 67
	switch (qop) {
	case QOP_CREATE:
		do {
			*evpid = queue_generate_evpid(msgid);
		} while (tree_check(&msg->envelopes, *evpid));
		evp = calloc(1, sizeof *evp);
		if (evp == NULL) {
			log_warn("warn: queue_ram_envelope: calloc");
			return (0);
		}
		evp->len = len;
		evp->buf = malloc(len);
		if (evp->buf == NULL) {
			log_warn("warn: queue_ram_envelope: malloc");
			free(evp);
			return (0);
		}
		memmove(evp->buf, buf, len);
		tree_xset(&msg->envelopes, *evpid, evp);
		stat_increment("queue.ram.envelope.size", len);
		return (1);

	case QOP_DELETE:
		if ((evp = tree_pop(&msg->envelopes, *evpid)) == NULL) {
			log_warnx("warn: queue_ram_envelope: not found");
			return (0);
		}
		stat_decrement("queue.ram.envelope.size", evp->len);
		free(evp->buf);
		free(evp);
		if (tree_empty(&msg->envelopes)) {
			tree_xpop(&messages, msgid);
			stat_decrement("queue.ram.message.size", msg->len);
			free(msg->buf);
			free(msg);
		}
		return (1);

	case QOP_LOAD:
		if ((evp = tree_get(&msg->envelopes, *evpid)) == NULL) {
			log_warn("warn: queue_ram_envelope: not found");
			return (0);
		}
		if (len < evp->len) {
			log_warnx("warn: queue_ram_envelope: buffer too small");
			return (0);
		}
		memmove(buf, evp->buf, evp->len);
		return (evp->len);

	case QOP_UPDATE:
		if ((evp = tree_get(&msg->envelopes, *evpid)) == NULL) {
			log_warn("warn: queue_ram_envelope: not found");
			return (0);
		}
		tmp = malloc(len);
		if (tmp == NULL) {
			log_warn("warn: queue_ram_envelope: malloc");
			return (0);
		}
		memmove(tmp, buf, len);
		free(evp->buf);
		evp->len = len;
		evp->buf = tmp;
		stat_decrement("queue.ram.envelope.size", evp->len);
		stat_increment("queue.ram.envelope.size", len);
		return (1);
d302 7
a308 2
	default:
		fatalx("queue_ram_envelope: unsupported operation.");
d310 25
d336 1
a336 1
	return (0);
d338 4
@


1.3
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_ram.c,v 1.2 2013/01/31 18:34:43 eric Exp $	*/
d43 1
a43 1
static int queue_ram_init(int);
d68 1
a68 1
queue_ram_init(int server)
@


1.2
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_ram.c,v 1.1 2013/01/26 09:37:23 gilles Exp $	*/
a21 1
#include <sys/param.h>
d78 1
a78 1
	char			 path[MAXPATHLEN];
@


1.1
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.53 2012/08/30 18:19:50 eric Exp $	*/
d243 1
@

