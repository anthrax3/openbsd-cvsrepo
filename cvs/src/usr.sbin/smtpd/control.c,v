head	1.118;
access;
symbols
	OPENBSD_6_2_BASE:1.118
	OPENBSD_6_1:1.118.0.4
	OPENBSD_6_1_BASE:1.118
	OPENBSD_6_0:1.113.0.4
	OPENBSD_6_0_BASE:1.113
	OPENBSD_5_9:1.111.0.2
	OPENBSD_5_9_BASE:1.111
	OPENBSD_5_8:1.104.0.4
	OPENBSD_5_8_BASE:1.104
	OPENBSD_5_7:1.102.0.2
	OPENBSD_5_7_BASE:1.102
	OPENBSD_5_6:1.101.0.4
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.97.0.2
	OPENBSD_5_5_BASE:1.97
	OPENBSD_5_4:1.89.0.2
	OPENBSD_5_4_BASE:1.89
	OPENBSD_5_3:1.82.0.2
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.65.0.2
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.2
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.56.0.2
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17;
locks; strict;
comment	@ * @;


1.118
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.117;
commitid	jM4eOMW1AJwdfKrr;

1.117
date	2016.09.08.12.06.43;	author eric;	state Exp;
branches;
next	1.116;
commitid	LkfnyKFoItZAAepX;

1.116
date	2016.09.04.16.10.31;	author eric;	state Exp;
branches;
next	1.115;
commitid	I2r1xe6emhZl6xPg;

1.115
date	2016.09.04.09.33.49;	author eric;	state Exp;
branches;
next	1.114;
commitid	k6ATrLH73tETES8n;

1.114
date	2016.09.01.10.54.25;	author eric;	state Exp;
branches;
next	1.113;
commitid	fYsbH2IujjKSME9c;

1.113
date	2016.05.28.21.21.20;	author eric;	state Exp;
branches;
next	1.112;
commitid	KhU4hSodVCiVoZ62;

1.112
date	2016.03.25.15.06.58;	author krw;	state Exp;
branches;
next	1.111;
commitid	0NIU7T9t8yqZHZQl;

1.111
date	2016.02.09.10.38.02;	author gilles;	state Exp;
branches;
next	1.110;
commitid	2amcmXMJq8TOe8lq;

1.110
date	2016.02.02.05.45.27;	author sunil;	state Exp;
branches;
next	1.109;
commitid	6duraeEH9T82qL9j;

1.109
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.108;
commitid	ZxnqOQqX6IeYI9jW;

1.108
date	2015.11.05.09.14.31;	author sunil;	state Exp;
branches;
next	1.107;
commitid	3vo6L6sIqhuEjLcD;

1.107
date	2015.10.29.10.25.36;	author sunil;	state Exp;
branches;
next	1.106;
commitid	TXZugvtal96cI6ec;

1.106
date	2015.10.13.10.59.04;	author gilles;	state Exp;
branches;
next	1.105;
commitid	8Xf6GtAJgvH4KyV4;

1.105
date	2015.10.02.00.26.45;	author gilles;	state Exp;
branches;
next	1.104;
commitid	RGrl4jstTrBPfsdn;

1.104
date	2015.06.11.19.27.16;	author gilles;	state Exp;
branches
	1.104.4.1;
next	1.103;
commitid	GEcjZqjmmeXkyNAX;

1.103
date	2015.05.28.17.09.18;	author florian;	state Exp;
branches;
next	1.102;
commitid	9YhXSwdVl61DPimv;

1.102
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches
	1.102.2.1;
next	1.101;
commitid	ZBTFreARDSMmzOIV;

1.101
date	2014.07.10.15.54.55;	author eric;	state Exp;
branches
	1.101.4.1;
next	1.100;
commitid	Uxz21DeZX3Z1gOVr;

1.100
date	2014.04.19.11.17.14;	author gilles;	state Exp;
branches;
next	1.99;

1.99
date	2014.04.09.18.55.19;	author eric;	state Exp;
branches;
next	1.98;

1.98
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.97;

1.97
date	2014.02.17.13.33.56;	author eric;	state Exp;
branches;
next	1.96;

1.96
date	2014.02.04.15.22.39;	author eric;	state Exp;
branches;
next	1.95;

1.95
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.94;

1.94
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.93;

1.93
date	2013.12.06.14.12.34;	author eric;	state Exp;
branches;
next	1.92;

1.92
date	2013.10.30.21.37.48;	author eric;	state Exp;
branches;
next	1.91;

1.91
date	2013.10.27.07.56.25;	author eric;	state Exp;
branches;
next	1.90;

1.90
date	2013.10.25.18.58.10;	author eric;	state Exp;
branches;
next	1.89;

1.89
date	2013.07.19.21.14.52;	author eric;	state Exp;
branches;
next	1.88;

1.88
date	2013.07.19.15.14.23;	author eric;	state Exp;
branches;
next	1.87;

1.87
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.86;

1.86
date	2013.07.19.07.49.08;	author eric;	state Exp;
branches;
next	1.85;

1.85
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.84;

1.84
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.83;

1.83
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.81;

1.81
date	2012.11.23.12.59.21;	author eric;	state Exp;
branches;
next	1.80;

1.80
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.79;

1.79
date	2012.11.20.09.47.45;	author eric;	state Exp;
branches;
next	1.78;

1.78
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.77;

1.77
date	2012.10.15.18.32.25;	author eric;	state Exp;
branches;
next	1.76;

1.76
date	2012.10.14.11.58.23;	author gilles;	state Exp;
branches;
next	1.75;

1.75
date	2012.09.28.12.00.09;	author eric;	state Exp;
branches;
next	1.74;

1.74
date	2012.09.27.17.47.49;	author chl;	state Exp;
branches;
next	1.73;

1.73
date	2012.09.16.16.43.28;	author chl;	state Exp;
branches;
next	1.72;

1.72
date	2012.08.25.22.03.26;	author gilles;	state Exp;
branches;
next	1.71;

1.71
date	2012.08.25.10.23.11;	author gilles;	state Exp;
branches;
next	1.70;

1.70
date	2012.08.25.08.17.42;	author eric;	state Exp;
branches;
next	1.69;

1.69
date	2012.08.20.18.18.16;	author eric;	state Exp;
branches;
next	1.68;

1.68
date	2012.08.18.18.18.23;	author gilles;	state Exp;
branches;
next	1.67;

1.67
date	2012.08.10.09.16.02;	author eric;	state Exp;
branches;
next	1.66;

1.66
date	2012.08.08.17.33.55;	author eric;	state Exp;
branches;
next	1.65;

1.65
date	2012.07.09.09.57.53;	author gilles;	state Exp;
branches;
next	1.64;

1.64
date	2012.01.12.18.06.18;	author eric;	state Exp;
branches;
next	1.63;

1.63
date	2011.11.14.19.23.41;	author chl;	state Exp;
branches;
next	1.62;

1.62
date	2011.10.26.20.47.31;	author gilles;	state Exp;
branches;
next	1.61;

1.61
date	2011.10.09.18.39.53;	author eric;	state Exp;
branches;
next	1.60;

1.60
date	2011.09.01.19.56.49;	author eric;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.21.23.29.24;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.13.20.53.18;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2010.11.24.23.27.04;	author todd;	state Exp;
branches;
next	1.54;

1.54
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2010.06.02.19.16.53;	author chl;	state Exp;
branches;
next	1.52;

1.52
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.01.19.47.08;	author jacekm;	state Exp;
branches;
next	1.50;

1.50
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.49;

1.49
date	2010.04.21.18.54.43;	author jacekm;	state Exp;
branches;
next	1.48;

1.48
date	2010.04.21.08.29.01;	author jacekm;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.20.15.34.56;	author jacekm;	state Exp;
branches;
next	1.46;

1.46
date	2010.01.10.16.42.35;	author gilles;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.23.17.16.03;	author jacekm;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.13.22.02.55;	author jacekm;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.02.19.10.02;	author mk;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.26.22.21.20;	author chl;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.23.12.03.46;	author jacekm;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.25.19.46.31;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.18.00.04.26;	author jacekm;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.15.16.50.06;	author jacekm;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.03.08.19.13;	author jacekm;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.07.05.56.25;	author eric;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.01.13.20.56;	author jacekm;	state Exp;
branches;
next	1.31;

1.31
date	2009.05.25.11.17.32;	author jacekm;	state Exp;
branches;
next	1.30;

1.30
date	2009.05.24.14.38.56;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2009.05.24.14.22.23;	author jacekm;	state Exp;
branches;
next	1.28;

1.28
date	2009.05.20.16.07.26;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.20.14.29.44;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.19.11.24.24;	author jacekm;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.14.15.05.12;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.09.20.04.36;	author jacekm;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.21.14.37.32;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.16.15.35.06;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2009.03.29.14.18.20;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.18.14.48.27;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.08.20.39.49;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.01.13.05.41;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.25.09.30.58;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.24.12.07.47;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.22.19.07.33;	author chl;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.17.22.49.22;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.15.10.32.23;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.29.21.59.15;	author jacekm;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.27.23.39.41;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.27.22.48.29;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.27.14.32.19;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.04.22.35.09;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.04.19.37.41;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.05.02.51.32;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.17.21.27.03;	author chl;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;

1.101.4.1
date	2015.06.11.19.24.38;	author gilles;	state Exp;
branches;
next	1.101.4.2;
commitid	2MgOc7xM534QdvKb;

1.101.4.2
date	2015.10.02.01.33.33;	author gilles;	state Exp;
branches;
next	;
commitid	2Q56YgF5PzqMcagu;

1.102.2.1
date	2015.06.11.19.25.36;	author gilles;	state Exp;
branches;
next	1.102.2.2;
commitid	LgFG0Lz9wu3aNTWL;

1.102.2.2
date	2015.10.02.01.28.43;	author gilles;	state Exp;
branches;
next	;
commitid	pAamrt3DJscJjb10;

1.104.4.1
date	2015.10.02.00.55.02;	author gilles;	state Exp;
branches;
next	;
commitid	5SntIHNUPMG4dcQ1;


desc
@@


1.118
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@/*	$OpenBSD: control.c,v 1.117 2016/09/08 12:06:43 eric Exp $	*/

/*
 * Copyright (c) 2012 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

#include "smtpd.h"
#include "log.h"

#define CONTROL_BACKLOG 5

struct ctl_conn {
	uint32_t		 id;
	uint8_t			 flags;
#define CTL_CONN_NOTIFY		 0x01
	struct mproc		 mproc;
	uid_t			 euid;
	gid_t			 egid;
};

struct {
	struct event		 ev;
	int			 fd;
} control_state;

static void control_imsg(struct mproc *, struct imsg *);
static void control_shutdown(void);
static void control_listen(void);
static void control_accept(int, short, void *);
static void control_close(struct ctl_conn *);
static void control_dispatch_ext(struct mproc *, struct imsg *);
static void control_digest_update(const char *, size_t, int);
static void control_broadcast_verbose(int, int);

static struct stat_backend *stat_backend = NULL;
extern const char *backend_stat;

static uint64_t			connid = 0;
static struct tree		ctl_conns;
static struct tree		ctl_count;
static struct stat_digest	digest;

#define	CONTROL_FD_RESERVE		5
#define	CONTROL_MAXCONN_PER_CLIENT	32

static void
control_imsg(struct mproc *p, struct imsg *imsg)
{
	struct ctl_conn		*c;
	struct stat_value	 val;
	struct msg		 m;
	const char		*key;
	const void		*data;
	size_t			 sz;

	if (imsg == NULL) {
		if (p->proc != PROC_CLIENT)
			control_shutdown();
		return;
	}

	if (p->proc == PROC_PONY) {
		switch (imsg->hdr.type) {
		case IMSG_CTL_SMTP_SESSION:
			c = tree_get(&ctl_conns, imsg->hdr.peerid);
			if (c == NULL)
				return;
			m_compose(&c->mproc, IMSG_CTL_OK, 0, 0, imsg->fd,
			    NULL, 0);
			return;
		}
	}
	if (p->proc == PROC_SCHEDULER) {
		switch (imsg->hdr.type) {
		case IMSG_CTL_OK:
		case IMSG_CTL_FAIL:
		case IMSG_CTL_LIST_MESSAGES:
			c = tree_get(&ctl_conns, imsg->hdr.peerid);
			if (c == NULL)
				return;
			imsg->hdr.peerid = 0;
			m_forward(&c->mproc, imsg);
			return;
		}
	}
	if (p->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_CTL_LIST_ENVELOPES:
		case IMSG_CTL_DISCOVER_EVPID:
		case IMSG_CTL_DISCOVER_MSGID:
		case IMSG_CTL_UNCORRUPT_MSGID:
			c = tree_get(&ctl_conns, imsg->hdr.peerid);
			if (c == NULL)
				return;
			m_forward(&c->mproc, imsg);
			return;
		}
	}
	if (p->proc == PROC_PONY) {
		switch (imsg->hdr.type) {
		case IMSG_CTL_OK:
		case IMSG_CTL_FAIL:
		case IMSG_CTL_MTA_SHOW_HOSTS:
		case IMSG_CTL_MTA_SHOW_RELAYS:
		case IMSG_CTL_MTA_SHOW_ROUTES:
		case IMSG_CTL_MTA_SHOW_HOSTSTATS:
		case IMSG_CTL_MTA_SHOW_BLOCK:
			c = tree_get(&ctl_conns, imsg->hdr.peerid);
			if (c == NULL)
				return;
			imsg->hdr.peerid = 0;
			m_forward(&c->mproc, imsg);
			return;
		}
	}

	switch (imsg->hdr.type) {
	case IMSG_STAT_INCREMENT:
		m_msg(&m, imsg);
		m_get_string(&m, &key);
		m_get_data(&m, &data, &sz);
		m_end(&m);
		if (sz != sizeof(val))
			fatalx("control: IMSG_STAT_INCREMENT size mismatch");
		memmove(&val, data, sz);
		if (stat_backend)
			stat_backend->increment(key, val.u.counter);
		control_digest_update(key, val.u.counter, 1);
		return;
	case IMSG_STAT_DECREMENT:
		m_msg(&m, imsg);
		m_get_string(&m, &key);
		m_get_data(&m, &data, &sz);
		m_end(&m);
		if (sz != sizeof(val))
			fatalx("control: IMSG_STAT_DECREMENT size mismatch");
		memmove(&val, data, sz);
		if (stat_backend)
			stat_backend->decrement(key, val.u.counter);
		control_digest_update(key, val.u.counter, 0);
		return;
	case IMSG_STAT_SET:
		m_msg(&m, imsg);
		m_get_string(&m, &key);
		m_get_data(&m, &data, &sz);
		m_end(&m);
		if (sz != sizeof(val))
			fatalx("control: IMSG_STAT_SET size mismatch");
		memmove(&val, data, sz);
		if (stat_backend)
			stat_backend->set(key, &val);
		return;
	}

	errx(1, "control_imsg: unexpected %s imsg",
	    imsg_to_str(imsg->hdr.type));
}

int
control_create_socket(void)
{
	struct sockaddr_un	s_un;
	int			fd;
	mode_t			old_umask;

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		fatal("control: socket");

	memset(&s_un, 0, sizeof(s_un));
	s_un.sun_family = AF_UNIX;
	if (strlcpy(s_un.sun_path, SMTPD_SOCKET,
	    sizeof(s_un.sun_path)) >= sizeof(s_un.sun_path))
		fatal("control: socket name too long");

	if (connect(fd, (struct sockaddr *)&s_un, sizeof(s_un)) == 0)
		fatalx("control socket already listening");

	if (unlink(SMTPD_SOCKET) == -1)
		if (errno != ENOENT)
			fatal("control: cannot unlink socket");

	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
	if (bind(fd, (struct sockaddr *)&s_un, sizeof(s_un)) == -1) {
		(void)umask(old_umask);
		fatal("control: bind");
	}
	(void)umask(old_umask);

	if (chmod(SMTPD_SOCKET,
		S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH) == -1) {
		(void)unlink(SMTPD_SOCKET);
		fatal("control: chmod");
	}

	io_set_nonblocking(fd);
	control_state.fd = fd;

	return fd;
}

int
control(void)
{
	struct passwd		*pw;

	purge_config(PURGE_EVERYTHING);

	if ((pw = getpwnam(SMTPD_USER)) == NULL)
		fatalx("unknown user " SMTPD_USER);

	stat_backend = env->sc_stat;
	stat_backend->init();

	if (chroot(PATH_CHROOT) == -1)
		fatal("control: chroot");
	if (chdir("/") == -1)
		fatal("control: chdir(\"/\")");

	config_process(PROC_CONTROL);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("control: cannot drop privileges");

	imsg_callback = control_imsg;
	event_init();

	signal(SIGINT, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	tree_init(&ctl_conns);
	tree_init(&ctl_count);

	memset(&digest, 0, sizeof digest);
	digest.startup = time(NULL);

	config_peer(PROC_SCHEDULER);
	config_peer(PROC_QUEUE);
	config_peer(PROC_PARENT);
	config_peer(PROC_LKA);
	config_peer(PROC_PONY);
	config_peer(PROC_CA);

	control_listen();

	if (pledge("stdio unix recvfd sendfd", NULL) == -1)
		err(1, "pledge");

	event_dispatch();
	fatalx("exited event loop");

	return (0);
}

static void
control_shutdown(void)
{
	log_debug("debug: control agent exiting");
	_exit(0);
}

static void
control_listen(void)
{
	if (listen(control_state.fd, CONTROL_BACKLOG) == -1)
		fatal("control_listen");

	event_set(&control_state.ev, control_state.fd, EV_READ|EV_PERSIST,
	    control_accept, NULL);
	event_add(&control_state.ev, NULL);
}

/* ARGSUSED */
static void
control_accept(int listenfd, short event, void *arg)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 s_un;
	struct ctl_conn		*c;
	size_t			*count;
	uid_t			 euid;
	gid_t			 egid;

	if (getdtablesize() - getdtablecount() < CONTROL_FD_RESERVE)
		goto pause;

	len = sizeof(s_un);
	if ((connfd = accept(listenfd, (struct sockaddr *)&s_un, &len)) == -1) {
		if (errno == ENFILE || errno == EMFILE)
			goto pause;
		if (errno == EINTR || errno == EWOULDBLOCK ||
		    errno == ECONNABORTED)
			return;
		fatal("control_accept: accept");
	}

	io_set_nonblocking(connfd);

	if (getpeereid(connfd, &euid, &egid) == -1)
		fatal("getpeereid");

	count = tree_get(&ctl_count, euid);
	if (count == NULL) {
		count = xcalloc(1, sizeof *count, "control_accept");
		tree_xset(&ctl_count, euid, count);
	}

	if (*count == CONTROL_MAXCONN_PER_CLIENT) {
		close(connfd);
		log_warnx("warn: too many connections to control socket "
		    "from user with uid %lu", (unsigned long int)euid);
		return;
	}
	(*count)++;

	do {
		++connid;
	} while (tree_get(&ctl_conns, connid));

	c = xcalloc(1, sizeof(*c), "control_accept");
	c->euid = euid;
	c->egid = egid;
	c->id = connid;
	c->mproc.proc = PROC_CLIENT;
	c->mproc.handler = control_dispatch_ext;
	c->mproc.data = c;
	mproc_init(&c->mproc, connfd);
	mproc_enable(&c->mproc);
	tree_xset(&ctl_conns, c->id, c);

	stat_backend->increment("control.session", 1);
	return;

pause:
	log_warnx("warn: ctl client limit hit, disabling new connections");
	event_del(&control_state.ev);
}

static void
control_close(struct ctl_conn *c)
{
	size_t	*count;

	count = tree_xget(&ctl_count, c->euid);
	(*count)--;
	if (*count == 0) {
		tree_xpop(&ctl_count, c->euid);
		free(count);
	}
	tree_xpop(&ctl_conns, c->id);
	mproc_clear(&c->mproc);
	free(c);

	stat_backend->decrement("control.session", 1);

	if (getdtablesize() - getdtablecount() < CONTROL_FD_RESERVE)
		return;

	if (!event_pending(&control_state.ev, EV_READ, NULL)) {
		log_warnx("warn: re-enabling ctl connections");
		event_add(&control_state.ev, NULL);
	}
}

static void
control_digest_update(const char *key, size_t value, int incr)
{
	size_t	*p;

	p = NULL;

	if (!strcmp(key, "smtp.session")) {
		if (incr)
			p = &digest.clt_connect;
		else
			digest.clt_disconnect += value;
	}
	else if (!strcmp(key, "scheduler.envelope")) {
		if (incr)
			p = &digest.evp_enqueued;
		else
			digest.evp_dequeued += value;
	}
	else if  (!strcmp(key, "scheduler.envelope.expired"))
		p = &digest.evp_expired;
	else if  (!strcmp(key, "scheduler.envelope.removed"))
		p = &digest.evp_removed;
	else if  (!strcmp(key, "scheduler.delivery.ok"))
		p = &digest.dlv_ok;
	else if  (!strcmp(key, "scheduler.delivery.permfail"))
		p = &digest.dlv_permfail;
	else if  (!strcmp(key, "scheduler.delivery.tempfail"))
		p = &digest.dlv_tempfail;
	else if  (!strcmp(key, "scheduler.delivery.loop"))
		p = &digest.dlv_loop;

	else if  (!strcmp(key, "queue.bounce"))
		p = &digest.evp_bounce;

	if (p) {
		if (incr)
			*p = *p + value;
		else
			*p = *p - value;
	}
}

/* ARGSUSED */
static void
control_dispatch_ext(struct mproc *p, struct imsg *imsg)
{
	struct sockaddr_storage	 ss;
	struct ctl_conn		*c;
	int			 v;
	struct stat_kv		*kvp;
	char			*key;
	struct stat_value	 val;
	size_t			 len;
	uint64_t		 evpid;
	uint32_t		 msgid;

	c = p->data;

	if (imsg == NULL) {
		control_close(c);
		return;
	}

	if (imsg->hdr.peerid != IMSG_VERSION) {
		m_compose(p, IMSG_CTL_FAIL, IMSG_VERSION, 0, -1, NULL, 0);
		return;
	}

	switch (imsg->hdr.type) {
	case IMSG_CTL_SMTP_SESSION:
		if (env->sc_flags & SMTPD_SMTP_PAUSED) {
			m_compose(p, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			return;
		}
		m_compose(p_pony, IMSG_CTL_SMTP_SESSION, c->id, 0, -1,
		    &c->euid, sizeof(c->euid));
		return;

	case IMSG_CTL_GET_DIGEST:
		if (c->euid)
			goto badcred;
		digest.timestamp = time(NULL);
		m_compose(p, IMSG_CTL_GET_DIGEST, 0, 0, -1, &digest, sizeof digest);
		return;

	case IMSG_CTL_GET_STATS:
		if (c->euid)
			goto badcred;
		kvp = imsg->data;
		if (!stat_backend->iter(&kvp->iter, &key, &val))
			kvp->iter = NULL;
		else {
			(void)strlcpy(kvp->key, key, sizeof kvp->key);
			kvp->val = val;
		}
		m_compose(p, IMSG_CTL_GET_STATS, 0, 0, -1, kvp, sizeof *kvp);
		return;

	case IMSG_CTL_VERBOSE:
		if (c->euid)
			goto badcred;

		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(v))
			goto badcred;

		memcpy(&v, imsg->data, sizeof(v));
		log_trace_verbose(v);

		control_broadcast_verbose(IMSG_CTL_VERBOSE, v);

		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_TRACE_ENABLE:
		if (c->euid)
			goto badcred;

		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(v))
			goto badcred;

		memcpy(&v, imsg->data, sizeof(v));
		tracing |= v;
		log_trace_verbose(tracing);

		control_broadcast_verbose(IMSG_CTL_VERBOSE, tracing);

		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_TRACE_DISABLE:
		if (c->euid)
			goto badcred;

		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(v))
			goto badcred;

		memcpy(&v, imsg->data, sizeof(v));
		tracing &= ~v;
		log_trace_verbose(tracing);

		control_broadcast_verbose(IMSG_CTL_VERBOSE, tracing);

		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_PROFILE_ENABLE:
		if (c->euid)
			goto badcred;

		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(v))
			goto badcred;

		memcpy(&v, imsg->data, sizeof(v));
		profiling |= v;

		control_broadcast_verbose(IMSG_CTL_PROFILE, profiling);

		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_PROFILE_DISABLE:
		if (c->euid)
			goto badcred;

		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(v))
			goto badcred;

		memcpy(&v, imsg->data, sizeof(v));
		profiling &= ~v;

		control_broadcast_verbose(IMSG_CTL_PROFILE, profiling);

		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_PAUSE_EVP:
		if (c->euid)
			goto badcred;

		imsg->hdr.peerid = c->id;
		m_forward(p_scheduler, imsg);
		return;

	case IMSG_CTL_PAUSE_MDA:
		if (c->euid)
			goto badcred;

		if (env->sc_flags & SMTPD_MDA_PAUSED) {
			m_compose(p, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			return;
		}
		log_info("info: mda paused");
		env->sc_flags |= SMTPD_MDA_PAUSED;
		m_compose(p_queue, IMSG_CTL_PAUSE_MDA, 0, 0, -1, NULL, 0);
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_PAUSE_MTA:
		if (c->euid)
			goto badcred;

		if (env->sc_flags & SMTPD_MTA_PAUSED) {
			m_compose(p, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			return;
		}
		log_info("info: mta paused");
		env->sc_flags |= SMTPD_MTA_PAUSED;
		m_compose(p_queue, IMSG_CTL_PAUSE_MTA, 0, 0, -1, NULL, 0);
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_PAUSE_SMTP:
		if (c->euid)
			goto badcred;

		if (env->sc_flags & SMTPD_SMTP_PAUSED) {
			m_compose(p, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			return;
		}
		log_info("info: smtp paused");
		env->sc_flags |= SMTPD_SMTP_PAUSED;
		m_compose(p_pony, IMSG_CTL_PAUSE_SMTP, 0, 0, -1, NULL, 0);
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_RESUME_EVP:
		if (c->euid)
			goto badcred;

		imsg->hdr.peerid = c->id;
		m_forward(p_scheduler, imsg);
		return;

	case IMSG_CTL_RESUME_MDA:
		if (c->euid)
			goto badcred;

		if (!(env->sc_flags & SMTPD_MDA_PAUSED)) {
			m_compose(p, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			return;
		}
		log_info("info: mda resumed");
		env->sc_flags &= ~SMTPD_MDA_PAUSED;
		m_compose(p_queue, IMSG_CTL_RESUME_MDA, 0, 0, -1, NULL, 0);
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_RESUME_MTA:
		if (c->euid)
			goto badcred;

		if (!(env->sc_flags & SMTPD_MTA_PAUSED)) {
			m_compose(p, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			return;
		}
		log_info("info: mta resumed");
		env->sc_flags &= ~SMTPD_MTA_PAUSED;
		m_compose(p_queue, IMSG_CTL_RESUME_MTA, 0, 0, -1, NULL, 0);
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_RESUME_SMTP:
		if (c->euid)
			goto badcred;

		if (!(env->sc_flags & SMTPD_SMTP_PAUSED)) {
			m_compose(p, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			return;
		}
		log_info("info: smtp resumed");
		env->sc_flags &= ~SMTPD_SMTP_PAUSED;
		m_forward(p_pony, imsg);
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_RESUME_ROUTE:
		if (c->euid)
			goto badcred;

		m_forward(p_pony, imsg);
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_LIST_MESSAGES:
		if (c->euid)
			goto badcred;
		m_compose(p_scheduler, IMSG_CTL_LIST_MESSAGES, c->id, 0, -1,
		    imsg->data, imsg->hdr.len - sizeof(imsg->hdr));
		return;

	case IMSG_CTL_LIST_ENVELOPES:
		if (c->euid)
			goto badcred;
		m_compose(p_scheduler, IMSG_CTL_LIST_ENVELOPES, c->id, 0, -1,
		    imsg->data, imsg->hdr.len - sizeof(imsg->hdr));
		return;

	case IMSG_CTL_MTA_SHOW_HOSTS:
	case IMSG_CTL_MTA_SHOW_RELAYS:
	case IMSG_CTL_MTA_SHOW_ROUTES:
	case IMSG_CTL_MTA_SHOW_HOSTSTATS:
	case IMSG_CTL_MTA_SHOW_BLOCK:
		if (c->euid)
			goto badcred;

		imsg->hdr.peerid = c->id;
		m_forward(p_pony, imsg);
		return;

	case IMSG_CTL_SHOW_STATUS:
		if (c->euid)
			goto badcred;

		m_compose(p, IMSG_CTL_SHOW_STATUS, 0, 0, -1, &env->sc_flags,
		    sizeof(env->sc_flags));
		return;

	case IMSG_CTL_MTA_BLOCK:
	case IMSG_CTL_MTA_UNBLOCK:
		if (c->euid)
			goto badcred;

		if (imsg->hdr.len - IMSG_HEADER_SIZE <= sizeof(ss))
			goto invalid;
		memmove(&ss, imsg->data, sizeof(ss));
		m_create(p_pony, imsg->hdr.type, c->id, 0, -1);
		m_add_sockaddr(p_pony, (struct sockaddr *)&ss);
		m_add_string(p_pony, (char *)imsg->data + sizeof(ss));
		m_close(p_pony);
		return;

	case IMSG_CTL_SCHEDULE:
		if (c->euid)
			goto badcred;

		imsg->hdr.peerid = c->id;
		m_forward(p_scheduler, imsg);
		return;

	case IMSG_CTL_REMOVE:
		if (c->euid)
			goto badcred;

		imsg->hdr.peerid = c->id;
		m_forward(p_scheduler, imsg);
		return;

	case IMSG_CTL_UPDATE_TABLE:
		if (c->euid)
			goto badcred;

		/* table name too long */
		len = strlen(imsg->data);
		if (len >= LINE_MAX)
			goto invalid;

		m_forward(p_lka, imsg);
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_DISCOVER_EVPID:
		if (c->euid)
			goto badcred;

		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof evpid)
			goto invalid;

		memmove(&evpid, imsg->data, sizeof evpid);
		m_create(p_queue, imsg->hdr.type, c->id, 0, -1);
		m_add_evpid(p_queue, evpid);
		m_close(p_queue);
		return;

	case IMSG_CTL_DISCOVER_MSGID:
	case IMSG_CTL_UNCORRUPT_MSGID:
		if (c->euid)
			goto badcred;

		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof msgid)
			goto invalid;

		memmove(&msgid, imsg->data, sizeof msgid);
		m_create(p_queue, imsg->hdr.type, c->id, 0, -1);
		m_add_msgid(p_queue, msgid);
		m_close(p_queue);
		return;

	default:
		log_debug("debug: control_dispatch_ext: "
		    "error handling %s imsg",
		    imsg_to_str(imsg->hdr.type));
		return;
	}
badcred:
invalid:
	m_compose(p, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
}

static void
control_broadcast_verbose(int msg, int v)
{
	m_create(p_lka, msg, 0, 0, -1);
	m_add_int(p_lka, v);
	m_close(p_lka);

	m_create(p_pony, msg, 0, 0, -1);
	m_add_int(p_pony, v);
	m_close(p_pony);

	m_create(p_queue, msg, 0, 0, -1);
	m_add_int(p_queue, v);
	m_close(p_queue);

	m_create(p_ca, msg, 0, 0, -1);
	m_add_int(p_ca, v);
	m_close(p_ca);

	m_create(p_scheduler, msg, 0, 0, -1);
	m_add_int(p_scheduler, v);
	m_close(p_scheduler);

	m_create(p_parent, msg, 0, 0, -1);
	m_add_int(p_parent, v);
	m_close(p_parent);
}
@


1.117
log
@Streamline the daemon shutdown sequence.

Only the parent process handles SIGTERM and SIGINT.  Upon receiving one
of those, it closes all imsg sockets and waitpid() for the children. It
fatal()s if one of the sockets is closed unexpectedly.  Other processes
exit() "normally" when one of the imsg sockets is closed.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.116 2016/09/04 16:10:31 eric Exp $	*/
d507 1
a507 1
		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(verbose))
d511 1
a511 2
		verbose = v;
		log_verbose(verbose);
d513 1
a513 1
		control_broadcast_verbose(IMSG_CTL_VERBOSE, verbose);
d522 1
a522 1
		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(verbose))
d526 2
a527 2
		verbose |= v;
		log_verbose(verbose);
d529 1
a529 1
		control_broadcast_verbose(IMSG_CTL_VERBOSE, verbose);
d538 1
a538 1
		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(verbose))
d542 2
a543 2
		verbose &= ~v;
		log_verbose(verbose);
d545 1
a545 1
		control_broadcast_verbose(IMSG_CTL_VERBOSE, verbose);
d554 1
a554 1
		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(verbose))
d569 1
a569 1
		if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(verbose))
@


1.116
log
@The smtpd processes are not expected to ever leave their event loop.
So stop pretending that the *_shutdown() functions could ever be called
in this context, and just fatal() if event_dispatch() returns.

ok gilles@@ sunil@@ giovanni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.115 2016/09/04 09:33:49 eric Exp $	*/
a65 1
static void control_sig_handler(int, short, void *);
d91 6
a193 13
static void
control_sig_handler(int sig, short event, void *p)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		control_shutdown();
		break;
	default:
		fatalx("control_sig_handler: unexpected signal");
	}
}

a239 2
	struct event		 ev_sigint;
	struct event		 ev_sigterm;
d264 2
a265 4
	signal_set(&ev_sigint, SIGINT, control_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, control_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
d296 1
a296 1
	log_info("info: control process exiting");
@


1.115
log
@Remove the "smtpctl stop" command.
The daemon is stopped with kill(1).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.114 2016/09/01 10:54:25 eric Exp $	*/
d299 2
a300 3
	if (event_dispatch() < 0)
		fatal("event_dispatch");
	control_shutdown();
@


1.114
log
@remove noop function

ok sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.113 2016/05/28 21:21:20 eric Exp $	*/
d488 1
a488 1
		if (env->sc_flags & (SMTPD_SMTP_PAUSED | SMTPD_EXITING)) {
a513 16
		return;

	case IMSG_CTL_SHUTDOWN:
		/* NEEDS_FIX */
		log_debug("debug: received shutdown request");

		if (c->euid)
			goto badcred;

		if (env->sc_flags & SMTPD_EXITING) {
			m_compose(p, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			return;
		}
		env->sc_flags |= SMTPD_EXITING;
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
		m_compose(p_parent, IMSG_CTL_SHUTDOWN, 0, 0, -1, NULL, 0);
@


1.113
log
@Implement the fork+exec pattern in smtpd.

The parent process forks child processes and re-exec each of them with
an additional "-x <proc>" argument.  During the early setup phase, the
parent process sends ipc socket pairs to interconnect the child
processes as needed, and it passes the queue encryption key to the
queue if necessary. When this is done, all processes have their
environment set as in the fork-only case, and they can start doing
their work as before.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.112 2016/03/25 15:06:58 krw Exp $	*/
a292 1
	config_done();
@


1.112
log
@Nuke session_socket_blockmode() and session_socket_linger(). Use
the identical io_set_blocking() and io_set_linger().

Since both are always called to turn off blocking or lingering,
nuke the parameter and associated enum in favour of "just doing the
right thing".

While passing remove the unneeded last parameter to the remaining
fcntl(F_GETFL).

Finally, rename the functions to io_set_nonblocking() and
io_set_nolinger() for clarity.

No functional change.

Started with a sweep of fcntl() usage inspired by guenther@@.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.111 2016/02/09 10:38:02 gilles Exp $	*/
d244 1
a244 1
pid_t
a246 1
	pid_t			 pid;
a249 10

	switch (pid = fork()) {
	case -1:
		fatal("control: cannot fork");
	case 0:
		post_fork(PROC_CONTROL);
		break;
	default:
		return (pid);
	}
@


1.111
log
@rename variable sun to s_un to ease portability

diff from Freddy DISSAUX, ok gilles@@, jung@@, sunil@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.110 2016/02/02 05:45:27 sunil Exp $	*/
d238 1
a238 1
	session_socket_blockmode(fd, BM_NONBLOCK);
d361 1
a361 1
	session_socket_blockmode(connfd, BM_NONBLOCK);
@


1.110
log
@Check imsg data size before use.

Ok eric@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.109 2015/12/28 22:08:30 jung Exp $	*/
d205 1
a205 1
	struct sockaddr_un	sun;
d212 4
a215 4
	memset(&sun, 0, sizeof(sun));
	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, SMTPD_SOCKET,
	    sizeof(sun.sun_path)) >= sizeof(sun.sun_path))
d218 1
a218 1
	if (connect(fd, (struct sockaddr *)&sun, sizeof(sun)) == 0)
d226 1
a226 1
	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
d342 1
a342 1
	struct sockaddr_un	 sun;
d351 2
a352 2
	len = sizeof(sun);
	if ((connfd = accept(listenfd, (struct sockaddr *)&sun, &len)) == -1) {
@


1.109
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.108 2015/11/05 09:14:31 sunil Exp $	*/
d153 2
d165 2
d177 2
@


1.108
log
@Implement smtpctl uncorrupt <msgid>

"uncorrupt" moves envelopes from corrupt bucket back to the queue
for further discovery by the daemon.

After correcting the corrupt envelopes, admin could now...

# smtpctl uncorrupt msgid
# smtpctl discover msgid

to schedule the messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.107 2015/10/29 10:25:36 sunil Exp $	*/
d513 1
a513 1
		if (! stat_backend->iter(&kvp->iter, &key, &val))
d678 1
a678 1
		if (! (env->sc_flags & SMTPD_MDA_PAUSED)) {
@


1.107
log
@Implement smtpctl discover <evpid|msgid>.

discover subcommand schedules envelopes manually moved to the queue.
It triggers a queue walk searching for envelopes with the given id,
schedules them and informs the user number of envelopes scheduled.
Admins no longer would need to restart the daemon to discover
manually moved messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.106 2015/10/13 10:59:04 gilles Exp $	*/
d121 1
d815 1
@


1.106
log
@pledge() control process

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.105 2015/10/02 00:26:45 gilles Exp $	*/
d119 2
d476 2
d798 26
@


1.105
log
@do not allow connid to wrap and collide with another active connection id.
this allows a local user to trigger a fatal() and exit the daemon.

reported by Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.104 2015/06/11 19:27:16 gilles Exp $	*/
d298 3
@


1.104
log
@local user can cause smtpd to fail by sending invalid imsg to control sock
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.103 2015/05/28 17:09:18 florian Exp $	*/
d74 1
a74 1
static uint32_t			connid = 0;
d368 4
d375 1
a375 1
	c->id = ++connid;
@


1.104.4.1
log
@Errata 004:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.104 2015/06/11 19:27:16 gilles Exp $	*/
d74 1
a74 1
static uint64_t			connid = 0;
a367 4
	do {
		++connid;
	} while (tree_get(&ctl_conns, connid));

d371 1
a371 1
	c->id = connid;
@


1.103
log
@Do not try to unlink the control socket in an unprivileged child
process on shutdown.
Found while working on tame(2).
OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.102 2015/01/20 17:37:54 deraadt Exp $	*/
d76 1
d79 2
a80 1
#define	CONTROL_FD_RESERVE	5
d284 1
d332 3
d351 17
d369 2
a370 2
	if (getpeereid(connfd, &c->euid, &c->egid) == -1)
		fatal("getpeereid");
d390 8
@


1.102
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.101 2014/07/10 15:54:55 eric Exp $	*/
a306 1
	unlink(SMTPD_SOCKET);
@


1.102.2.1
log
@errata 8
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.102 2015/01/20 17:37:54 deraadt Exp $	*/
a75 1
static struct tree		ctl_count;
d78 1
a78 2
#define	CONTROL_FD_RESERVE		5
#define	CONTROL_MAXCONN_PER_CLIENT	32
a281 1
	tree_init(&ctl_count);
a329 3
	size_t			*count;
	uid_t			 euid;
	gid_t			 egid;
d346 2
a347 1
	if (getpeereid(connfd, &euid, &egid) == -1)
a348 18

	count = tree_get(&ctl_count, euid);
	if (count == NULL) {
		count = xcalloc(1, sizeof *count, "control_accept");
		tree_xset(&ctl_count, euid, count);
	}

	if (*count == CONTROL_MAXCONN_PER_CLIENT) {
		close(connfd);
		log_warnx("warn: too many connections to control socket "
		    "from user with uid %lu", (unsigned long int)euid);
		return;
	}
	(*count)++;

	c = xcalloc(1, sizeof(*c), "control_accept");
	c->euid = euid;
	c->egid = egid;
a367 8
	size_t	*count;

	count = tree_xget(&ctl_count, c->euid);
	(*count)--;
	if (*count == 0) {
		tree_xpop(&ctl_count, c->euid);
		free(count);
	}
@


1.102.2.2
log
@Errata 017:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.102.2.1 2015/06/11 19:25:36 gilles Exp $	*/
d74 1
a74 1
static uint64_t			connid = 0;
a368 4
	do {
		++connid;
	} while (tree_get(&ctl_conns, connid));

d372 1
a372 1
	c->id = connid;
@


1.101
log
@make the control process broadcast verbose/profile admin requests directly,
rather than going through the parent process. simplify code in the meantime.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.100 2014/04/19 11:17:14 gilles Exp $	*/
d40 1
d752 1
a752 1
		if (len >= SMTPD_MAXLINESIZE)
@


1.101.4.1
log
@errata 25
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.101 2014/07/10 15:54:55 eric Exp $	*/
a74 1
static struct tree		ctl_count;
d77 1
a77 2
#define	CONTROL_FD_RESERVE		5
#define	CONTROL_MAXCONN_PER_CLIENT	32
a280 1
	tree_init(&ctl_count);
a328 3
	size_t			*count;
	uid_t			 euid;
	gid_t			 egid;
d345 2
a346 1
	if (getpeereid(connfd, &euid, &egid) == -1)
a347 18

	count = tree_get(&ctl_count, euid);
	if (count == NULL) {
		count = xcalloc(1, sizeof *count, "control_accept");
		tree_xset(&ctl_count, euid, count);
	}

	if (*count == CONTROL_MAXCONN_PER_CLIENT) {
		close(connfd);
		log_warnx("warn: too many connections to control socket "
		    "from user with uid %lu", (unsigned long int)euid);
		return;
	}
	(*count)++;

	c = xcalloc(1, sizeof(*c), "control_accept");
	c->euid = euid;
	c->egid = egid;
a366 8
	size_t	*count;

	count = tree_xget(&ctl_count, c->euid);
	(*count)--;
	if (*count == 0) {
		tree_xpop(&ctl_count, c->euid);
		free(count);
	}
@


1.101.4.2
log
@Errata 031:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.101.4.1 2015/06/11 19:24:38 gilles Exp $	*/
d73 1
a73 1
static uint64_t			connid = 0;
a367 4
	do {
		++connid;
	} while (tree_get(&ctl_conns, connid));

d371 1
a371 1
	c->id = connid;
@


1.100
log
@it's ok for strlcpy to fail here though it can't, cast void
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.99 2014/04/09 18:55:19 eric Exp $	*/
d68 1
d290 1
d506 1
a506 3
		m_create(p_parent, IMSG_CTL_VERBOSE, 0, 0, -1);
		m_add_int(p_parent, verbose);
		m_close(p_parent);
d522 1
a522 3
		m_create(p_parent, IMSG_CTL_TRACE_ENABLE, 0, 0, -1);
		m_add_int(p_parent, v);
		m_close(p_parent);
d538 1
a538 3
		m_create(p_parent, IMSG_CTL_TRACE_DISABLE, 0, 0, -1);
		m_add_int(p_parent, v);
		m_close(p_parent);
d553 1
a553 3
		m_create(p_parent, IMSG_CTL_PROFILE_ENABLE, 0, 0, -1);
		m_add_int(p_parent, v);
		m_close(p_parent);
d568 1
a568 3
		m_create(p_parent, IMSG_CTL_PROFILE_DISABLE, 0, 0, -1);
		m_add_int(p_parent, v);
		m_close(p_parent);
d767 28
@


1.99
log
@Zap the mfa process. It is not currently doing anything, and content filtering
will be done at session level anyway.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d471 1
a471 1
			strlcpy(kvp->key, key, sizeof kvp->key);
@


1.98
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@a285 1
	config_peer(PROC_MFA);
@


1.97
log
@new "smtpctl show status" command to show if mta/mda/smtp are currently running or paused.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.96 2014/02/04 15:22:39 eric Exp $	*/
d88 1
a88 1
	if (p->proc == PROC_SMTP) {
d90 1
a90 1
		case IMSG_SMTP_ENQUEUE_FD:
d122 1
a122 1
	if (p->proc == PROC_MTA) {
a285 1
	config_peer(PROC_SMTP);
d289 1
a289 2
	config_peer(PROC_MDA);
	config_peer(PROC_MTA);
d449 1
a449 1
	case IMSG_SMTP_ENQUEUE_FD:
d454 1
a454 1
		m_compose(p_smtp, IMSG_SMTP_ENQUEUE_FD, c->id, 0, -1,
d458 1
a458 7
	case IMSG_STATS:
		if (c->euid)
			goto badcred;
		m_compose(p, IMSG_STATS, 0, 0, -1, NULL, 0);
		return;

	case IMSG_DIGEST:
d462 1
a462 1
		m_compose(p, IMSG_DIGEST, 0, 0, -1, &digest, sizeof digest);
d465 1
a465 1
	case IMSG_STATS_GET:
d475 1
a475 1
		m_compose(p, IMSG_STATS_GET, 0, 0, -1, kvp, sizeof *kvp);
d512 1
a512 1
	case IMSG_CTL_TRACE:
d523 1
a523 1
		m_create(p_parent, IMSG_CTL_TRACE, 0, 0, -1);
d530 1
a530 1
	case IMSG_CTL_UNTRACE:
d541 1
a541 1
		m_create(p_parent, IMSG_CTL_UNTRACE, 0, 0, -1);
d548 1
a548 1
	case IMSG_CTL_PROFILE:
d558 1
a558 1
		m_create(p_parent, IMSG_CTL_PROFILE, 0, 0, -1);
d565 1
a565 1
	case IMSG_CTL_UNPROFILE:
d575 1
a575 1
		m_create(p_parent, IMSG_CTL_UNPROFILE, 0, 0, -1);
d628 1
a628 1
		m_compose(p_smtp, IMSG_CTL_PAUSE_SMTP, 0, 0, -1, NULL, 0);
d678 1
a678 1
		m_forward(p_smtp, imsg);
d686 1
a686 1
		m_forward(p_mta, imsg);
d713 1
a713 1
		m_forward(p_mta, imsg);
d732 4
a735 4
		m_create(p_mta, imsg->hdr.type, c->id, 0, -1);
		m_add_sockaddr(p_mta, (struct sockaddr *)&ss);
		m_add_string(p_mta, (char *)imsg->data + sizeof(ss));
		m_close(p_mta);
d754 1
a754 1
	case IMSG_LKA_UPDATE_TABLE:
@


1.96
log
@Allow the admin to pause relaying to a specific domain:
 - smtpctl pause mta from <source> for <domain>
 - smtpctl resume mta from <source> for <domain>
 - smtpctl show mta paused
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d722 8
@


1.95
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.94 2013/12/26 17:25:32 eric Exp $	*/
d124 2
d130 1
d430 1
d716 1
d722 14
@


1.94
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.93 2013/12/06 14:12:34 eric Exp $	*/
d448 1
a448 2
		if (env->sc_flags & (SMTPD_SMTP_PAUSED |
		    SMTPD_CONFIGURING | SMTPD_EXITING)) {
@


1.93
log
@fix smtpctl resume route
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d196 1
a196 1
	bzero(&sun, sizeof(sun));
d278 1
a278 1
	bzero(&digest, sizeof digest);
@


1.92
log
@add "smtpctl show relays" and "smtpctl show hosts" commands
@
text
@a690 1
		log_info("info: route resumed");
@


1.91
log
@Create the control socket in the parent process to abort early if
another smtpd instance is running.  Close the inherited socket in
every forked process but control.
@
text
@d124 2
d710 2
@


1.90
log
@Improve reporting in smtpctl and a few fixes.

When sending a request to the scheduler, wait for the success/failure
report from the scheduler.  Simplify the code by introducing generic
functions for interruptible iteration over envelopes.  Report the total
number of affected envelopes for schedule, pause, resume and remove
envelope operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.89 2013/07/19 21:14:52 eric Exp $	*/
d184 2
a185 2
pid_t
control(void)
d187 3
a189 21
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask;
	pid_t			 pid;
	struct passwd		*pw;
	struct event		 ev_sigint;
	struct event		 ev_sigterm;

	switch (pid = fork()) {
	case -1:
		fatal("control: cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	purge_config(PURGE_EVERYTHING);

	if ((pw = getpwnam(SMTPD_USER)) == NULL)
		fatalx("unknown user " SMTPD_USER);
d222 26
@


1.89
log
@Many MTA improvements:

- Better transient error handling logic: failing destinations are
  automatically disabled for a while.  When a destination is active
  again, ask the scheduler to retry previous envelopes immediatly.
- More informative error report when all routes fail for a mail.
- Implement a "smtpctl show hoststats" command to get the latest stat
  message per MX domain.
- Implement a "smtpctl show routes" command to show the state the
  currently known routes to remote MXs.
- Implement a "smtpctl resume route" command to re-enable a route that
  has been disabled.
- Do not hardcode limits
- Minor code improvements
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 2
d107 1
a124 5
			c = tree_get(&ctl_conns, imsg->hdr.peerid);
			if (c == NULL)
				return;
			m_forward(&c->mproc, imsg);
			return;
d129 1
d581 1
a582 1
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d631 1
a632 1
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d701 1
a703 3
		m_compose(p_mta, IMSG_CTL_MTA_SHOW_ROUTES, c->id, 0, -1,
		    imsg->data, imsg->hdr.len - sizeof(imsg->hdr));
		return;
d705 2
a706 5
	case IMSG_CTL_MTA_SHOW_HOSTSTATS:
		if (c->euid)
			goto badcred;
		m_compose(p_mta, IMSG_CTL_MTA_SHOW_HOSTSTATS, c->id, 0, -1,
		    imsg->data, imsg->hdr.len - sizeof(imsg->hdr));
d713 1
a714 1
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d721 1
a722 1
		m_compose(p, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
@


1.88
log
@scheduler improvements:
- implement suspend/resume scheduling for individual envelopes or message,
  with the associated smtpctl commands.
- allow the mta to request immediate scheduling of an envelope.
- on temporary failures a penalty can be given to further delay the next try.
@
text
@d119 16
d678 9
d698 14
@


1.87
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.86 2013/07/19 07:49:08 eric Exp $	*/
d562 8
d609 8
@


1.86
log
@Remove useless sc_pid from struct smtpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.85 2013/05/24 17:03:14 eric Exp $	*/
d191 2
a192 1
	pw = env->sc_pw;
d229 1
a229 1
	if (chroot(pw->pw_dir) == -1)
@


1.85
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.83 2013/03/11 17:40:11 deraadt Exp $	*/
a183 1
		env->sc_pid = getpid();
@


1.84
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@a23 1
#include <sys/param.h>
d322 1
d416 5
d485 1
a485 1
		m_create(p_parent, IMSG_CTL_VERBOSE, 0, 0, -1, 9);
d503 1
a503 1
		m_create(p_parent, IMSG_CTL_TRACE, 0, 0, -1, 9);
d521 1
a521 1
		m_create(p_parent, IMSG_CTL_UNTRACE, 0, 0, -1, 9);
d538 1
a538 1
		m_create(p_parent, IMSG_CTL_PROFILE, 0, 0, -1, 9);
d555 1
a555 1
		m_create(p_parent, IMSG_CTL_UNPROFILE, 0, 0, -1, 9);
@


1.83
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.82 2013/01/26 09:37:23 gilles Exp $	*/
d677 1
a677 1
		if (len >= MAX_LINE_SIZE)
@


1.82
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.78 2012/11/12 14:58:53 eric Exp $	*/
d311 2
a312 1
		if (errno == EINTR || errno == ECONNABORTED)
@


1.81
log
@send ack on update map.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.80 2012/11/23 10:55:25 eric Exp $	*/
d4 1
a4 1
 * Copyright (c) 2012 Gilles Chehade <gilles@@openbsd.org>
d48 1
a48 1
	TAILQ_ENTRY(ctl_conn)	 entry;
d51 3
a53 1
	struct imsgev		 iev;
d61 1
a61 1
static void control_imsg(struct imsgev *, struct imsg *);
a64 1
static struct ctl_conn *control_connbyfd(int);
d67 1
a67 2
static void control_dispatch_ext(int, short, void *);

d73 2
a74 2
static TAILQ_HEAD(, ctl_conn)	ctl_conns;

d80 1
a80 1
control_imsg(struct imsgev *iev, struct imsg *imsg)
d82 6
a87 3
	struct ctl_conn	       *c;
	char		       *key;
	struct stat_value	val;
d89 1
a89 1
	if (iev->proc == PROC_SMTP) {
d91 2
a92 2
		case IMSG_SMTP_ENQUEUE:
			c = control_connbyfd(imsg->hdr.peerid);
d95 2
a96 2
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0,
			    imsg->fd, NULL, 0);
d100 1
a100 1
	if (iev->proc == PROC_SCHEDULER) {
d102 2
a103 2
		case IMSG_SCHEDULER_MESSAGES:
			c = control_connbyfd(imsg->hdr.peerid);
d106 1
a106 2
			imsg_compose_event(&c->iev, IMSG_SCHEDULER_MESSAGES, 0,
			    0, -1, imsg->data, imsg->hdr.len-sizeof imsg->hdr);
d110 1
a110 1
	if (iev->proc == PROC_QUEUE) {
d112 2
a113 2
		case IMSG_SCHEDULER_ENVELOPES:
			c = control_connbyfd(imsg->hdr.peerid);
d116 1
a116 2
			imsg_compose_event(&c->iev, IMSG_SCHEDULER_ENVELOPES, 0,
			    0, -1, imsg->data, imsg->hdr.len-sizeof imsg->hdr);
d123 5
a127 2
		memmove(&val, imsg->data, sizeof (val));
		key = (char*)imsg->data + sizeof (val);
d133 5
a137 2
		memmove(&val, imsg->data, sizeof (val));
		key = (char*)imsg->data + sizeof (val);
d143 5
a147 2
		memmove(&val, imsg->data, sizeof (val));
		key = (char*)imsg->data + sizeof (val);
a179 10
	struct peer		 peers [] = {
		{ PROC_SCHEDULER,	imsg_dispatch },
		{ PROC_QUEUE,		imsg_dispatch },
		{ PROC_SMTP,		imsg_dispatch },
		{ PROC_MFA,		imsg_dispatch },
		{ PROC_PARENT,		imsg_dispatch },
		{ PROC_LKA,		imsg_dispatch },
		{ PROC_MDA,		imsg_dispatch },
		{ PROC_MTA,		imsg_dispatch }
	};
d185 1
d235 1
a235 2
	smtpd_process = PROC_CONTROL;
	setproctitle("%s", env->sc_title[smtpd_process]);
d252 1
a252 1
	TAILQ_INIT(&ctl_conns);
d257 10
a266 2
	config_pipes(peers, nitems(peers));
	config_peers(peers, nitems(peers));
d319 8
a326 7
	imsg_init(&c->iev.ibuf, connfd);
	c->iev.handler = control_dispatch_ext;
	c->iev.events = EV_READ;
	event_set(&c->iev.ev, c->iev.ibuf.fd, c->iev.events,
	    c->iev.handler, NULL);
	event_add(&c->iev.ev, NULL);
	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
a335 12
static struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */

	return (c);
}

d339 2
a340 4
	TAILQ_REMOVE(&ctl_conns, c, entry);
	event_del(&c->iev.ev);
	close(c->iev.ibuf.fd);
	imsg_clear(&c->iev.ibuf);
d399 1
a399 1
control_dispatch_ext(int fd, short event, void *arg)
d402 1
a402 5
	struct imsg		 imsg;
	int			 n, verbose;
	uid_t			 euid;
	gid_t			 egid;
	uint64_t		 id;
d408 1
a408 2
	if (getpeereid(fd, &euid, &egid) == -1)
		fatal("getpeereid");
d410 2
a411 2
	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("warn: control_dispatch_ext: fd %d: not found", fd);
d415 147
a561 3
	if (event & EV_READ) {
		if ((n = imsg_read(&c->iev.ibuf)) == -1 || n == 0) {
			control_close(c);
d564 9
a572 1
	}
d574 2
a575 3
	if (event & EV_WRITE) {
		if (msgbuf_write(&c->iev.ibuf.w) < 0) {
			control_close(c);
d578 9
a586 1
	}
d588 2
a589 3
	for (;;) {
		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
			control_close(c);
d592 5
d598 3
a600 2
		if (n == 0)
			break;
d602 9
a610 11
		switch (imsg.hdr.type) {
		case IMSG_SMTP_ENQUEUE:
			if (env->sc_flags & (SMTPD_SMTP_PAUSED |
			    SMTPD_CONFIGURING | SMTPD_EXITING)) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0,
				    -1, NULL, 0);
				break;
			}
			imsg_compose_event(env->sc_ievs[PROC_SMTP],
			    IMSG_SMTP_ENQUEUE, fd, 0, -1, &euid, sizeof(euid));
			break;
d612 3
a614 6
		case IMSG_STATS:
			if (euid)
				goto badcred;
			imsg_compose_event(&c->iev, IMSG_STATS, 0, 0, -1,
			    NULL, 0);
			break;
d616 9
a624 56
		case IMSG_DIGEST:
			if (euid)
				goto badcred;
			digest.timestamp = time(NULL);
			imsg_compose_event(&c->iev, IMSG_DIGEST, 0, 0, -1,
			    &digest, sizeof digest);
			break;

		case IMSG_STATS_GET:
			if (euid)
				goto badcred;
			kvp = imsg.data;
			if (! stat_backend->iter(&kvp->iter, &key, &val))
				kvp->iter = NULL;
			else {
				strlcpy(kvp->key, key, sizeof kvp->key);
				kvp->val = val;
			}
			imsg_compose_event(&c->iev, IMSG_STATS_GET, 0, 0, -1,
			    kvp, sizeof *kvp);
			break;

		case IMSG_CTL_SHUTDOWN:
			/* NEEDS_FIX */
			log_debug("debug: received shutdown request");

			if (euid)
				goto badcred;

			if (env->sc_flags & SMTPD_EXITING) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0,
				    -1, NULL, 0);
				break;
			}
			env->sc_flags |= SMTPD_EXITING;
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			imsg_compose_event(env->sc_ievs[PROC_PARENT],
			    IMSG_CTL_SHUTDOWN, 0, 0, -1, NULL, 0);
			break;

		case IMSG_CTL_VERBOSE:
			if (euid)
				goto badcred;

			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(verbose))
				goto badcred;

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			imsg_compose_event(env->sc_ievs[PROC_PARENT],
			    IMSG_CTL_VERBOSE, 0, 0, -1, &verbose,
			    sizeof(verbose));
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			break;
d626 3
a628 16
		case IMSG_QUEUE_PAUSE_MDA:
			if (euid)
				goto badcred;

			if (env->sc_flags & SMTPD_MDA_PAUSED) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0,
				    -1, NULL, 0);
				break;
			}
			log_info("info: mda paused");
			env->sc_flags |= SMTPD_MDA_PAUSED;
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_QUEUE_PAUSE_MDA, 0, 0, -1, NULL, 0);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			break;
d630 9
a638 16
		case IMSG_QUEUE_PAUSE_MTA:
			if (euid)
				goto badcred;

			if (env->sc_flags & SMTPD_MTA_PAUSED) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0,
				    -1, NULL, 0);
				break;
			}
			log_info("info: mta paused");
			env->sc_flags |= SMTPD_MTA_PAUSED;
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_QUEUE_PAUSE_MTA, 0, 0, -1, NULL, 0);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			break;
d640 6
a645 16
		case IMSG_SMTP_PAUSE:
			if (euid)
				goto badcred;

			if (env->sc_flags & SMTPD_SMTP_PAUSED) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0,
				    -1, NULL, 0);
				break;
			}
			log_info("info: smtp paused");
			env->sc_flags |= SMTPD_SMTP_PAUSED;
			imsg_compose_event(env->sc_ievs[PROC_SMTP],
			    IMSG_SMTP_PAUSE, 0, 0, -1, NULL, 0);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			break;
d647 6
a652 16
		case IMSG_QUEUE_RESUME_MDA:
			if (euid)
				goto badcred;

			if (! (env->sc_flags & SMTPD_MDA_PAUSED)) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0,
				    -1, NULL, 0);
				break;
			}
			log_info("info: mda resumed");
			env->sc_flags &= ~SMTPD_MDA_PAUSED;
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_QUEUE_RESUME_MDA, 0, 0, -1, NULL, 0);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			break;
d654 3
a656 16
		case IMSG_QUEUE_RESUME_MTA:
			if (euid)
				goto badcred;

			if (!(env->sc_flags & SMTPD_MTA_PAUSED)) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0,
				    -1, NULL, 0);
				break;
			}
			log_info("info: mta resumed");
			env->sc_flags &= ~SMTPD_MTA_PAUSED;
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_QUEUE_RESUME_MTA, 0, 0, -1, NULL, 0);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			break;
d658 3
a660 16
		case IMSG_SMTP_RESUME:
			if (euid)
				goto badcred;

			if (!(env->sc_flags & SMTPD_SMTP_PAUSED)) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0,
				    -1,	NULL, 0);
				break;
			}
			log_info("info: smtp resumed");
			env->sc_flags &= ~SMTPD_SMTP_PAUSED;
			imsg_compose_event(env->sc_ievs[PROC_SMTP],
			    IMSG_SMTP_RESUME, 0, 0, -1, NULL, 0);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			break;
d662 3
a664 26
		case IMSG_SCHEDULER_MESSAGES:
			if (euid)
				goto badcred;
			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER],
			    IMSG_SCHEDULER_MESSAGES, fd, 0, -1, imsg.data,
			    imsg.hdr.len - sizeof(imsg.hdr));
			break;

		case IMSG_SCHEDULER_ENVELOPES:
			if (euid)
				goto badcred;
			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER],
			    IMSG_SCHEDULER_ENVELOPES, fd, 0, -1, imsg.data,
			    imsg.hdr.len - sizeof(imsg.hdr));
			break;

		case IMSG_SCHEDULER_SCHEDULE:
			if (euid)
				goto badcred;

			id = *(uint64_t *)imsg.data;
			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER],
			    IMSG_SCHEDULER_SCHEDULE, 0, 0, -1, &id, sizeof id);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			break;
d666 3
a668 10
		case IMSG_SCHEDULER_REMOVE:
			if (euid)
				goto badcred;

			id = *(uint64_t *)imsg.data;
			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER],
			    IMSG_SCHEDULER_REMOVE, 0, 0, -1, &id, sizeof id);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			break;
d670 8
a677 14
		case IMSG_LKA_UPDATE_MAP:
			if (euid)
				goto badcred;

			/* map name too long */
			len = strlen(imsg.data);
			if (len >= MAX_LINE_SIZE)
				goto invalid;

			imsg_compose_event(env->sc_ievs[PROC_LKA],
			    IMSG_LKA_UPDATE_MAP, 0, 0, -1, imsg.data, len + 1);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);
			break;
d679 3
a681 8
		default:
			log_debug("debug: control_dispatch_ext: "
			    "error handling %s imsg",
			    imsg_to_str(imsg.hdr.type));
			break;
		}
		imsg_free(&imsg);
		continue;
d683 6
d691 1
a691 5
		imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
		    NULL, 0);
	}

	imsg_event_add(&c->iev);
@


1.80
log
@knf

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.78 2012/11/12 14:58:53 eric Exp $	*/
d675 2
@


1.79
log
@Allow "smtpctl show queue" to run in "online" mode if the smtpd server
is running.  The scheduler sends the runtime state of each envelope to
the queue process which loads the envelope, fills the runtime bits and
sends the envelope back to the client. Iteration over the envelope set
happens in small chunks to make the request interruptible and to allow
the server to keep doing its job in the meantime.

Adpat "smtpctl schedule-all" to schedule the messages one by one using
the same iteration mechanism.

Document "smtpctl monitor" and "smtpctl show queue".

ok gilles@@
@
text
@d217 2
a218 1
	if (chmod(SMTPD_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH) == -1) {
d414 1
a414 1
	struct stat_value      	 val;
d452 2
a453 2
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
					NULL, 0);
d463 2
a464 1
			imsg_compose_event(&c->iev, IMSG_STATS, 0, 0, -1, NULL, 0);
d517 5
a521 3
			imsg_compose_event(env->sc_ievs[PROC_PARENT], IMSG_CTL_VERBOSE,
			    0, 0, -1, &verbose, sizeof(verbose));
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d529 2
a530 2
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
					NULL, 0);
d537 2
a538 1
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d546 2
a547 2
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
					NULL, 0);
d554 2
a555 1
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d563 2
a564 2
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
					NULL, 0);
d569 4
a572 3
			imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_SMTP_PAUSE,			
			    0, 0, -1, NULL, 0);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d580 2
a581 2
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
					NULL, 0);
d588 2
a589 1
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d597 2
a598 2
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
					NULL, 0);
d605 2
a606 1
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d614 2
a615 2
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
					NULL, 0);
d620 4
a623 3
			imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_SMTP_RESUME,
			    0, 0, -1, NULL, 0);
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d673 2
a674 2
			imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_UPDATE_MAP,
			    0, 0, -1, imsg.data, len + 1);
@


1.78
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.77 2012/10/15 18:32:25 eric Exp $	*/
d97 22
d614 16
@


1.77
log
@implement and document "smtpctl stop"

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.76 2012/10/14 11:58:23 gilles Exp $	*/
d39 1
d68 2
d75 2
d104 1
d111 1
d231 3
d248 1
a248 1
	log_info("control process exiting");
d300 1
a300 1
	log_warnx("ctl client limit hit, disabling new connections");
d331 1
a331 1
		log_warnx("re-enabling ctl connections");
d336 43
d398 1
a398 1
		log_warn("control_dispatch_ext: fd %d: not found", fd);
d443 8
d467 1
a467 1
			log_debug("received shutdown request");
d507 1
a507 1
			log_info("mda paused");
d523 1
a523 1
			log_info("mta paused");
d539 1
a539 1
			log_info("smtp paused");
d555 1
a555 1
			log_info("mda resumed");
d571 1
a571 1
			log_info("mta resumed");
d587 1
a587 1
			log_info("smtp resumed");
d630 1
a630 1
			log_debug("control_dispatch_ext: "
@


1.76
log
@introduce map_file.c which will deprecate map_stdio.c

The idea is to have a file-backed map but to have smtpd(8) cache the maps
so that it cannot be partially read if edited while mail is received. The
file is read and converted to a static map (map_static.c), changes aren't
visible to smtpd until an explicit: smtpctl update map  which reads file,
builds a new static map and invalidates the former.

partial-read issue discussed with beck@@ and halex@@
idea to convert internally to a static map by eric@@

diff ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.75 2012/09/28 12:00:09 eric Exp $	*/
d412 2
a413 2
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
					NULL, 0);
d417 4
a420 1
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
@


1.75
log
@smtpd.h/control.c cleanups:

- move session_socket_* prototypes under util.c
- move struct ctl_conn in control.c
- make static functions static
- remove unused functions
- call unlink() in control_shutdown()
- make control_close() take a ctl_conn * instead of a fd

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.74 2012/09/27 17:47:49 chl Exp $	*/
d339 1
a339 1

d552 13
d575 1
@


1.74
log
@use xmalloc()/xcalloc() helpers

while there unify usage of log_trace() in ramstat_set()

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.73 2012/09/16 16:43:28 chl Exp $	*/
d46 7
a52 1
/* control specific headers */
d58 8
a65 12
void		 control_imsg(struct imsgev *, struct imsg *);
__dead void	 control_shutdown(void);
int		 control_init(void);
void		 control_listen(void);
void		 control_cleanup(void);
void		 control_accept(int, short, void *);
struct ctl_conn	*control_connbyfd(int);
void		 control_close(int);
void		 control_sig_handler(int, short, void *);
void		 control_dispatch_ext(int, short, void *);

struct ctl_connlist	ctl_conns;
d70 2
d74 1
a74 1
void
d118 1
a118 1
void
a130 1

d235 1
a235 1
void
d239 1
d243 1
a243 1
void
a253 6
void
control_cleanup(void)
{
	(void)unlink(SMTPD_SOCKET);
}

d255 1
a255 1
void
d294 1
a294 1
struct ctl_conn *
d306 2
a307 2
void
control_close(int fd)
a308 6
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("control_close: fd %d: not found", fd);
		return;
	}
d311 1
a312 1
	close(fd);
d327 1
a327 1
void
d351 1
a351 1
			control_close(fd);
d358 1
a358 1
			control_close(fd);
d365 1
a365 1
			control_close(fd);
@


1.73
log
@Factorize log_imsg() in imsg_dispatch() instead of in each imsg_callback()'s
and put it out of profiling, so it's not accounted.

While there, for PROC_PARENT:
- set smtpd_process for PROC_PARENT
- use setproctitle() like other processes

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.72 2012/08/25 22:03:26 gilles Exp $	*/
d279 1
a279 2
	if ((c = calloc(1, sizeof(*c))) == NULL)
		fatal(NULL);
@


1.72
log
@- add myself to the copyright in control.c, i've done quite a few changes
there in the last few years ;-)
- get rid of availdesc(): getdtablecount() is so much more reliable
- get rid of env->sc_maxconn, we can be much smarter with getdtablecount()
	and getdtablesize()
- disable accept when we hit the control process fd reserve
- disable accept when we fail
- enable accept when we're back below the limit

this is not the full fd exhaustion diff, i'll merge changes from relayd
tomorrow, this was only required to get rid of the env->sc_maxconn and
availdesc() mess

"reads alright" eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.71 2012/08/25 10:23:11 gilles Exp $	*/
a75 2

	log_imsg(PROC_CONTROL, iev->proc, imsg);
@


1.71
log
@- introduce struct stat_value
- statistics can now have a type (counter, timestamp, timeval, timespec and
  possibly others in the future)
- stat_increment() / stat_decrement() now take an increment/decrement value
  and are at the moment only of type counter
- stat_set() now takes a stat_value
- provide helpers to convert raw values to stat_value

ok eric@@, ok chl@@

while at it fix a rq_queue_dump() call using a bogus timestamp in scheduler
ramqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.70 2012/08/25 08:17:42 eric Exp $	*/
d4 1
d68 1
a68 1
static size_t sessions;
a243 2
	int avail = availdesc();

a245 1
	avail--;
a249 4

	/* guarantee 2 fds to each accepted client */
	if ((env->sc_maxconn = avail / 2) < 1)
		fatalx("control_listen: fd starvation");
d267 3
d272 2
d292 1
d294 3
a296 4
	if (++sessions >= env->sc_maxconn) {
		log_warnx("ctl client limit hit, disabling new connections");
		event_del(&control_state.ev);
	}
d328 4
a331 2
	if (--sessions < env->sc_maxconn &&
	    !event_pending(&control_state.ev, EV_READ, NULL)) {
@


1.70
log
@log pause/resume from the administrator to maillog.
suggested by Jan Stary.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.69 2012/08/20 18:18:16 eric Exp $	*/
d72 3
a74 3
	struct ctl_conn	*c;
	char		*key;
	size_t		 val;
d92 2
a93 1
		key = imsg->data;
d95 1
a95 1
			stat_backend->increment(key);
d98 2
a99 1
		key = imsg->data;
d101 1
a101 1
			stat_backend->decrement(key);
d107 1
a107 1
			stat_backend->set(key, val);
d145 3
a147 1
		{ PROC_LKA,		imsg_dispatch }
d292 1
a292 1
	stat_backend->increment("control.session");
d327 1
a327 1
	stat_backend->decrement("control.session");
d348 1
a348 1
	size_t			 val;
@


1.69
log
@Do not send more bytes than necessary with IMSG_STAT_*.  The INCREMENT
and DECREMENT messages just contain the key with the ending zero.  For
IMSG_STAT_SET, the value is found at the beginning of the message, and
the rest is the key.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.68 2012/08/18 18:18:23 gilles Exp $	*/
d449 1
d465 1
d481 1
d497 1
d513 1
d529 1
@


1.68
log
@- introduce stat_backend, an API for pluggable statistic backends
  > statistics are no longer static structures in shared memory
  > statistics are only set, smtpd never uses them in its logic
  > each statistic is a key/value where key can be any (dynamic) string
- convert all uses of the former API to use the new one
- implement stat_ramstat that keeps non-persistent stats in ram structure

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.67 2012/08/10 09:16:02 eric Exp $	*/
d74 1
a74 1
	struct stat_kv	*stat_kv;
d102 2
a103 1
		stat_kv = (struct stat_kv *)imsg->data;
d105 1
a105 1
			stat_backend->set(stat_kv->key, stat_kv->val);
@


1.67
log
@code cleanup

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.66 2012/08/08 17:33:55 eric Exp $	*/
d64 5
d73 2
d90 18
d137 6
a142 5
		{ PROC_SCHEDULER,	 imsg_dispatch },
		{ PROC_QUEUE,	 imsg_dispatch },
		{ PROC_SMTP,	 imsg_dispatch },
		{ PROC_MFA,	 imsg_dispatch },
		{ PROC_PARENT,	 imsg_dispatch },
d189 3
d287 3
a289 1
	if (stat_increment(STATS_CONTROL_SESSION) >= env->sc_maxconn) {
d322 3
a324 1
	if (stat_decrement(STATS_CONTROL_SESSION) < env->sc_maxconn &&
d341 4
d392 15
a406 2
			imsg_compose_event(&c->iev, IMSG_STATS, 0, 0, -1,
			    env->stats, sizeof(struct stats));
@


1.66
log
@remove useless defines

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.65 2012/07/09 09:57:53 gilles Exp $	*/
d304 1
a304 1
	int			 n;
d307 1
d351 1
d358 1
a373 2
		case IMSG_CTL_VERBOSE: {
			int verbose;
d375 1
d388 1
a388 1
		}
d403 1
d418 1
d433 1
d448 1
d479 1
a479 3
		case IMSG_SCHEDULER_SCHEDULE: {
			u_int64_t ullval;

d483 5
a487 6
			ullval = *(u_int64_t *)imsg.data;

			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER], IMSG_SCHEDULER_SCHEDULE,
			    0, 0, -1, &ullval, sizeof(ullval));

			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
a488 4
		}

		case IMSG_SCHEDULER_REMOVE: {
			u_int64_t ullval;
d490 1
d494 6
a499 1
			ullval = *(u_int64_t *)imsg.data;
a500 6
			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER], IMSG_SCHEDULER_REMOVE,
			    0, 0, -1, &ullval, sizeof(ullval));

			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
			break;
		}
@


1.65
log
@- runner is the terminology we used back when we had runqueues, we no
  longer have them and runner is actually a scheduler so rename.
- introduce scheduler_backend which does the same to scheduler than
  queue_backend does to queue and map_backend does to maps
- remove all occurences of RUNNER and runner, replace them with SCHEDULER
  and scheduler

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.64 2012/01/12 18:06:18 eric Exp $	*/
d377 1
a377 1
			if (IMSG_DATA_SIZE(&imsg) != sizeof(verbose))
@


1.64
log
@Remove dead code for config reloading for now. It is not functionnal
and confusing.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.63 2011/11/14 19:23:41 chl Exp $	*/
d112 1
a112 1
		{ PROC_RUNNER,	 imsg_dispatch },
d473 1
a473 1
		case IMSG_RUNNER_SCHEDULE: {
d481 1
a481 1
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_RUNNER_SCHEDULE,
d488 1
a488 1
		case IMSG_RUNNER_REMOVE: {
d496 1
a496 1
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_RUNNER_REMOVE,
@


1.63
log
@when receiving an unexpected imsg, print its name.

with help and ideas from eric@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.62 2011/10/26 20:47:31 gilles Exp $	*/
a67 1
	struct reload	*reload;
a78 15
			return;
		}
	}

	if (iev->proc == PROC_PARENT) {
		switch (imsg->hdr.type) {
		case IMSG_CONF_RELOAD:
			env->sc_flags &= ~SMTPD_CONFIGURING;
			reload = imsg->data;
			c = control_connbyfd(reload->fd);
			if (c == NULL)
				return;
			imsg_compose_event(&c->iev,
			    reload->ret ? IMSG_CTL_OK : IMSG_CTL_FAIL, 0, 0,
			    -1, NULL, 0);
@


1.62
log
@- fix smtpctl pause/resume so the ramqueue scheduling is done correctly
- rename IMSG and smtpctl pause/resume parameters
- update man page

tested by me, ok chl@@, eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.61 2011/10/09 18:39:53 eric Exp $	*/
d28 1
d99 2
a100 1
	fatalx("control_imsg: unexpected imsg");
d520 2
a521 1
			    "error handling imsg %d", imsg.hdr.type);
@


1.61
log
@show messages sent between processes in debug mode

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.60 2011/09/01 19:56:49 eric Exp $	*/
d401 1
a401 1
		case IMSG_QUEUE_PAUSE_LOCAL:
d412 1
a412 1
			    IMSG_QUEUE_PAUSE_LOCAL, 0, 0, -1, NULL, 0);
d415 1
a415 1
		case IMSG_QUEUE_PAUSE_OUTGOING:
d426 1
a426 1
			    IMSG_QUEUE_PAUSE_OUTGOING, 0, 0, -1, NULL, 0);
d443 1
a443 1
		case IMSG_QUEUE_RESUME_LOCAL:
d454 1
a454 1
			    IMSG_QUEUE_RESUME_LOCAL, 0, 0, -1, NULL, 0);
d457 1
a457 1
		case IMSG_QUEUE_RESUME_OUTGOING:
d468 1
a468 1
			    IMSG_QUEUE_RESUME_OUTGOING, 0, 0, -1, NULL, 0);
@


1.60
log
@Introduce a small set of functions to manage stat counters in a
simpler and hopefully saner way.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.59 2011/07/21 23:29:24 gilles Exp $	*/
d68 2
@


1.59
log
@- update smtpctl.8 to reflect reality
- bring back 'smtpctl schedule' and 'smtpctl remove' to life

Things you should know:

The ramqueue data structure is not finished yet and lacks an envelope tree
for evpid lookups. I wanted to wait until I'm done but too many people are
affected by not being able to reschedule envelopes, this is a quick fix.

So right now there's an O(rrible) complexity as both commands will perform
a (possibly aborted) queue scan leading to O(n). I will make that O(log n)
soon.

Also, smtpctl remove no longer supports removing an entire message, I will
fix that very soon too.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.58 2011/05/01 12:57:11 eric Exp $	*/
d270 1
a270 6
	env->stats->control.sessions++;
	env->stats->control.sessions_active++;
	SET_IF_GREATER(env->stats->control.sessions_active,
		env->stats->control.sessions_maxactive);

	if (env->stats->control.sessions_active >= env->sc_maxconn) {
d303 2
a304 4
	env->stats->control.sessions_active--;

	if (!event_pending(&control_state.ev, EV_READ, NULL) &&
	    env->stats->control.sessions_active < env->sc_maxconn) {
@


1.58
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.57 2011/04/13 20:53:18 gilles Exp $	*/
d124 1
d476 1
d491 30
@


1.57
log
@following an idea from jacekm@@, smtpd now uses a ram-queue instead of doing
a continuous walk on the disk-queue. the implementation differs from what
jacekm@@ commited (and I backed out) a while ago in that it uses a queue and
a host tree required for upcoming features.

code will be improved in tree, it requires changes to be done in queue and
bounce API, I just wanted to commit a working version first ...

tested by todd@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.56 2010/11/28 13:56:43 gilles Exp $	*/
d50 1
a50 1
void		 control_imsg(struct smtpd *, struct imsgev *, struct imsg *);
d53 1
a53 1
void		 control_listen(struct smtpd *);
d57 1
a57 1
void		 control_close(struct smtpd *, int);
d64 1
a64 1
control_imsg(struct smtpd *env, struct imsgev *iev, struct imsg *imsg)
d114 1
a114 1
control(struct smtpd *env)
d139 1
a139 1
	purge_config(env, PURGE_EVERYTHING);
d190 2
a191 2
	signal_set(&ev_sigint, SIGINT, control_sig_handler, env);
	signal_set(&ev_sigterm, SIGTERM, control_sig_handler, env);
d199 3
a201 3
	config_pipes(env, peers, nitems(peers));
	config_peers(env, peers, nitems(peers));
	control_listen(env);
d218 1
a218 1
control_listen(struct smtpd *env)
d227 1
a227 1
	    control_accept, env);
a248 1
	struct smtpd		*env = arg;
a263 1
	c->iev.data = env;
d265 1
a265 1
	    c->iev.handler, env);
d293 1
a293 1
control_close(struct smtpd *env, int fd)
a320 1
	struct smtpd		*env = arg;
d336 1
a336 1
			control_close(env, fd);
d343 1
a343 1
			control_close(env, fd);
d350 1
a350 1
			control_close(env, fd);
@


1.56
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.55 2010/11/24 23:27:04 todd Exp $	*/
a67 2
	struct remove	*rem;
	struct sched	*sched;
a80 24
	if (iev->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_QUEUE_SCHEDULE:
			sched = imsg->data;
			c = control_connbyfd(sched->fd);
			if (c == NULL)
				return;
			imsg_compose_event(&c->iev,
			    sched->ret ? IMSG_CTL_OK : IMSG_CTL_FAIL, 0, 0, -1,
			    NULL, 0);
			return;

		case IMSG_QUEUE_REMOVE:
			rem = imsg->data;
			c = control_connbyfd(rem->fd);
			if (c == NULL)
				return;
			imsg_compose_event(&c->iev,
			    rem->ret ? IMSG_CTL_OK : IMSG_CTL_FAIL, 0, 0,
			    -1, NULL, 0);
			return;
		}
	}

a376 62
		case IMSG_QUEUE_SCHEDULE: {
			struct sched *s = imsg.data;

			if (euid)
				goto badcred;
	
			if (IMSG_DATA_SIZE(&imsg) != sizeof(*s))
				goto badcred;

			s->fd = fd;

			if (! valid_message_id(s->mid) && ! valid_message_uid(s->mid)) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
				break;
			}

			imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_SCHEDULE, 0, 0, -1, s, sizeof(*s));
			break;
		}

		case IMSG_QUEUE_REMOVE: {
			struct remove *s = imsg.data;

			if (euid)
				goto badcred;
	
			if (IMSG_DATA_SIZE(&imsg) != sizeof(*s))
				goto badcred;

			s->fd = fd;

			if (! valid_message_id(s->mid) && ! valid_message_uid(s->mid)) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
				break;
			}

			imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_REMOVE, 0, 0, -1, s, sizeof(*s));
			break;
		}
/*
		case IMSG_CONF_RELOAD: {
			struct reload r;

			log_debug("received reload request");

			if (euid)
				goto badcred;

			if (env->sc_flags & SMTPD_CONFIGURING) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
					NULL, 0);
				break;
			}
			env->sc_flags |= SMTPD_CONFIGURING;

			r.fd = fd;
			imsg_compose_event(env->sc_ievs[PROC_PARENT], IMSG_CONF_RELOAD, 0, 0, -1, &r, sizeof(r));
			break;
		}
*/
@


1.55
log
@add *maxactive stats
"ok and no need to keep them for yourself" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.54 2010/10/09 22:05:35 gilles Exp $	*/
d31 1
d40 1
@


1.54
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.49 2010/04/21 18:54:43 jacekm Exp $	*/
d297 2
@


1.53
log
@check event_dispatch() return value

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.52 2010/06/01 23:06:23 jacekm Exp $	*/
a38 1
#include "queue_backend.h"
d66 2
a67 1
	int		 error;
d84 9
d94 2
a95 1
			c = control_connbyfd(imsg->hdr.peerid);
d98 3
a100 7
			memcpy(&error, imsg->data, sizeof error);
			if (error)
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0,
				    -1, NULL, 0);
			else
				imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0,
				    -1, NULL, 0);
d226 1
d399 28
a426 3
		case IMSG_QUEUE_SCHEDULE:
		case IMSG_QUEUE_REMOVE:
			if (euid || IMSG_DATA_SIZE(&imsg) != sizeof(u_int64_t))
d428 10
a437 3
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    imsg.hdr.type, fd, 0, -1, imsg.data,
			    sizeof(u_int64_t));
d439 1
d506 1
a506 1
		case IMSG_QUEUE_PAUSE_RELAY:
d517 1
a517 1
			    IMSG_QUEUE_PAUSE_RELAY, 0, 0, -1, NULL, 0);
d548 1
a548 1
		case IMSG_QUEUE_RESUME_RELAY:
d559 1
a559 1
			    IMSG_QUEUE_RESUME_RELAY, 0, 0, -1, NULL, 0);
@


1.52
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.50 2010/05/31 23:38:56 jacekm Exp $	*/
d220 2
a221 1
	event_dispatch();
@


1.51
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.49 2010/04/21 18:54:43 jacekm Exp $	*/
d39 1
d67 1
a67 2
	struct remove	*rem;
	struct sched	*sched;
a83 9
			sched = imsg->data;
			c = control_connbyfd(sched->fd);
			if (c == NULL)
				return;
			imsg_compose_event(&c->iev,
			    sched->ret ? IMSG_CTL_OK : IMSG_CTL_FAIL, 0, 0, -1,
			    NULL, 0);
			return;

d85 1
a85 2
			rem = imsg->data;
			c = control_connbyfd(rem->fd);
d88 7
a94 3
			imsg_compose_event(&c->iev,
			    rem->ret ? IMSG_CTL_OK : IMSG_CTL_FAIL, 0, 0,
			    -1, NULL, 0);
d391 3
a393 4
		case IMSG_QUEUE_SCHEDULE: {
			struct sched *s = imsg.data;

			if (euid)
d395 3
a397 13
	
			if (IMSG_DATA_SIZE(&imsg) != sizeof(*s))
				goto badcred;

			s->fd = fd;

			if (! valid_message_id(s->mid) && ! valid_message_uid(s->mid)) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
				break;
			}

			imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_SCHEDULE, 0, 0, -1, s, sizeof(*s));
a398 22
		}

		case IMSG_QUEUE_REMOVE: {
			struct remove *s = imsg.data;

			if (euid)
				goto badcred;
	
			if (IMSG_DATA_SIZE(&imsg) != sizeof(*s))
				goto badcred;

			s->fd = fd;

			if (! valid_message_id(s->mid) && ! valid_message_uid(s->mid)) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
				break;
			}

			imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_REMOVE, 0, 0, -1, s, sizeof(*s));
			break;
		}
d465 1
a465 1
		case IMSG_QUEUE_PAUSE_OUTGOING:
d476 1
a476 1
			    IMSG_QUEUE_PAUSE_OUTGOING, 0, 0, -1, NULL, 0);
d507 1
a507 1
		case IMSG_QUEUE_RESUME_OUTGOING:
d518 1
a518 1
			    IMSG_QUEUE_RESUME_OUTGOING, 0, 0, -1, NULL, 0);
@


1.50
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@a38 1
#include "queue_backend.h"
d66 2
a67 1
	int		 error;
d84 9
d94 2
a95 1
			c = control_connbyfd(imsg->hdr.peerid);
d98 3
a100 7
			memcpy(&error, imsg->data, sizeof error);
			if (error)
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0,
				    -1, NULL, 0);
			else
				imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0,
				    -1, NULL, 0);
d397 28
a424 3
		case IMSG_QUEUE_SCHEDULE:
		case IMSG_QUEUE_REMOVE:
			if (euid || IMSG_DATA_SIZE(&imsg) != sizeof(u_int64_t))
d426 10
a435 3
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    imsg.hdr.type, fd, 0, -1, imsg.data,
			    sizeof(u_int64_t));
d437 1
a493 1
#if 0
a498 1
#endif
d504 1
a504 1
		case IMSG_QUEUE_PAUSE_RELAY:
d515 1
a515 1
			    IMSG_QUEUE_PAUSE_RELAY, 0, 0, -1, NULL, 0);
a535 1
#if 0
a540 1
#endif
d546 1
a546 1
		case IMSG_QUEUE_RESUME_RELAY:
d557 1
a557 1
			    IMSG_QUEUE_RESUME_RELAY, 0, 0, -1, NULL, 0);
@


1.49
log
@Runner process is just a helper for queue, so tear down its imsg
channels to parent, mda, mta, lka, smtp, and control.  This leaves
just the channel to queue, which forwards imsgs on runner's behalf
and redirects any replies back to it.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.48 2010/04/21 08:29:01 jacekm Exp $	*/
d39 1
d67 1
a67 2
	struct remove	*rem;
	struct sched	*sched;
a83 9
			sched = imsg->data;
			c = control_connbyfd(sched->fd);
			if (c == NULL)
				return;
			imsg_compose_event(&c->iev,
			    sched->ret ? IMSG_CTL_OK : IMSG_CTL_FAIL, 0, 0, -1,
			    NULL, 0);
			return;

d85 1
a85 2
			rem = imsg->data;
			c = control_connbyfd(rem->fd);
d88 7
a94 3
			imsg_compose_event(&c->iev,
			    rem->ret ? IMSG_CTL_OK : IMSG_CTL_FAIL, 0, 0,
			    -1, NULL, 0);
d391 3
a393 4
		case IMSG_QUEUE_SCHEDULE: {
			struct sched *s = imsg.data;

			if (euid)
d395 3
a397 13
	
			if (IMSG_DATA_SIZE(&imsg) != sizeof(*s))
				goto badcred;

			s->fd = fd;

			if (! valid_message_id(s->mid) && ! valid_message_uid(s->mid)) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
				break;
			}

			imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_SCHEDULE, 0, 0, -1, s, sizeof(*s));
a398 22
		}

		case IMSG_QUEUE_REMOVE: {
			struct remove *s = imsg.data;

			if (euid)
				goto badcred;
	
			if (IMSG_DATA_SIZE(&imsg) != sizeof(*s))
				goto badcred;

			s->fd = fd;

			if (! valid_message_id(s->mid) && ! valid_message_uid(s->mid)) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
				break;
			}

			imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_REMOVE, 0, 0, -1, s, sizeof(*s));
			break;
		}
d455 1
d461 1
d467 1
a467 1
		case IMSG_QUEUE_PAUSE_OUTGOING:
d478 1
a478 1
			    IMSG_QUEUE_PAUSE_OUTGOING, 0, 0, -1, NULL, 0);
d499 1
d505 1
d511 1
a511 1
		case IMSG_QUEUE_RESUME_OUTGOING:
d522 1
a522 1
			    IMSG_QUEUE_RESUME_OUTGOING, 0, 0, -1, NULL, 0);
@


1.48
log
@Remove unusable ifdef DEBUG code.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.47 2010/04/20 15:34:56 jacekm Exp $	*/
d81 1
a81 1
	if (iev->proc == PROC_RUNNER) {
d83 1
a83 1
		case IMSG_RUNNER_SCHEDULE:
d93 1
a93 1
		case IMSG_RUNNER_REMOVE:
a148 1
		{ PROC_RUNNER,	 imsg_dispatch },
d397 1
a397 1
		case IMSG_RUNNER_SCHEDULE: {
d414 1
a414 1
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_RUNNER_SCHEDULE, 0, 0, -1, s, sizeof(*s));
d418 1
a418 1
		case IMSG_RUNNER_REMOVE: {
d435 1
a435 1
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_RUNNER_REMOVE, 0, 0, -1, s, sizeof(*s));
d490 1
a490 1
		case IMSG_MDA_PAUSE:
d500 2
a501 2
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_MDA_PAUSE,
			    0, 0, -1, NULL, 0);
d504 1
a504 1
		case IMSG_MTA_PAUSE:
d514 2
a515 2
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_MTA_PAUSE,
			    0, 0, -1, NULL, 0);
d532 1
a532 1
		case IMSG_MDA_RESUME:
d542 2
a543 2
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_MDA_RESUME,
			    0, 0, -1, NULL, 0);
d546 1
a546 1
		case IMSG_MTA_RESUME:
d556 2
a557 2
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_MTA_RESUME,
			    0, 0, -1, NULL, 0);
@


1.47
log
@Kill *2400* lines of code by abstracting common bits of the imsg handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.46 2010/01/10 16:42:35 gilles Exp $	*/
a198 1
#ifndef DEBUG
a202 3
#else
#warning disabling privilege revocation and chroot in DEBUG MODE
#endif
a206 1
#ifndef DEBUG
a210 1
#endif
@


1.46
log
@- teach runner how to remove a message from queue given a message id/uid
	and assuming message is not in processing/scheduled state
- teach smtpctl how to request message removal from runner

discussed with todd@@, idea ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.45 2010/01/03 14:37:37 chl Exp $	*/
d48 1
a57 6
void		 control_dispatch_lka(int, short, void *);
void		 control_dispatch_mfa(int, short, void *);
void		 control_dispatch_queue(int, short, void *);
void		 control_dispatch_runner(int, short, void *);
void		 control_dispatch_smtp(int, short, void *);
void		 control_dispatch_parent(int, short, void *);
d62 62
d148 5
a152 5
		{ PROC_QUEUE,	 control_dispatch_queue },
		{ PROC_RUNNER,	 control_dispatch_runner },
		{ PROC_SMTP,	 control_dispatch_smtp },
		{ PROC_MFA,	 control_dispatch_mfa },
		{ PROC_PARENT,	 control_dispatch_parent },
d218 1
a594 340
}

void
control_dispatch_parent(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_PARENT];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("control_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CONF_RELOAD: {
			struct reload *r = imsg.data;
			struct ctl_conn	*c;

			IMSG_SIZE_CHECK(r);

			env->sc_flags &= ~SMTPD_CONFIGURING;
			if ((c = control_connbyfd(r->fd)) == NULL) {
				log_warn("control_dispatch_parent: fd %d not found", r->fd);
				return;
			}

			if (r->ret)
				imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
			else
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			break;
		}
		default:
			log_warnx("control_dispatch_parent: got imsg %d",
			    imsg.hdr.type);
			fatalx("control_dispatch_parent: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
control_dispatch_lka(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_LKA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("control_dispatch_lka: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("control_dispatch_lka: got imsg %d",
			    imsg.hdr.type);
			fatalx("control_dispatch_lka: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
control_dispatch_mfa(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_MFA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("control_dispatch_mfa: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("control_dispatch_mfa: got imsg %d",
			    imsg.hdr.type);
			fatalx("control_dispatch_mfa: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
control_dispatch_queue(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_QUEUE];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("control_dispatch_queue: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("control_dispatch_queue: got imsg %d",
			    imsg.hdr.type);
			fatalx("control_dispatch_queue: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
control_dispatch_runner(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_RUNNER];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("control_dispatch_runner: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_RUNNER_SCHEDULE: {
			struct sched	*s = imsg.data;
			struct ctl_conn	*c;

			IMSG_SIZE_CHECK(s);

			if ((c = control_connbyfd(s->fd)) == NULL) {
				log_warn("control_dispatch_runner: fd %d not found", s->fd);
				imsg_free(&imsg);
				return;
			}

			if (s->ret)
				imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
			else
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			break;
		}
		case IMSG_RUNNER_REMOVE: {
			struct remove	*s = imsg.data;
			struct ctl_conn	*c;

			IMSG_SIZE_CHECK(s);

			if ((c = control_connbyfd(s->fd)) == NULL) {
				log_warn("control_dispatch_runner: fd %d not found", s->fd);
				imsg_free(&imsg);
				return;
			}

			if (s->ret)
				imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
			else
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
			break;
		}
		default:
			log_warnx("control_dispatch_runner: got imsg %d",
			    imsg.hdr.type);
			fatalx("control_dispatch_runner: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
control_dispatch_smtp(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_SMTP];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("control_dispatch_smtp: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_SMTP_ENQUEUE: {
			struct ctl_conn	*c;
			int		client_fd;

			client_fd = imsg.hdr.peerid;

			if ((c = control_connbyfd(client_fd)) == NULL) {
				log_warn("control_dispatch_smtp: fd %d not found", client_fd);
				imsg_free(&imsg);
				return;
			}

			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0,
			    imsg.fd, NULL, 0);
			break;
		}
		default:
			log_warnx("control_dispatch_smtp: got imsg %d",
			    imsg.hdr.type);
			fatalx("control_dispatch_smtp: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
@


1.45
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.44 2009/12/23 17:16:03 jacekm Exp $	*/
d366 21
d774 18
@


1.44
log
@Implementation of RFC 2920 PIPELINING extension, client side only for now.

This restructures the client_* API internals significantly.  The code becomes
pipelining in nature.  All SMTP commands are put on the output queue and
dequeued as quickly as possible.  Once dequeued, they're moved to the receive
queue so that replies can be matched with previous commands.

Dequeuing commands from the output queue halts when the count of commands
currently in-pipeline (``cmdi'') is equal to the command send window (``cmdw'').
There are three cmdw values useful in practice:

0               clear pipeline, ie. inhibit all future sends
1               disable pipelining, ie. use old ``one-request-one-reply`` mode
SIZE_T_MAX      enable pipelining, ie. dequeue as many commands as possible

At the beginning of session cmdw is 1.  When it is found that peer supports
PIPELINING, it grows to SIZE_T_MAX.  After dequeing DATA it is again 1.  After
sending QUIT it is 0.

Each command dequeued from the output queue becomes a buf in a msgbuf.  The act
of combining multiple commands into a single send operation did not need to be
implemented: buf_write() already combines bufs using iovec and sends them at
once using sendmsg(2).

Tested by todd@@ and oga@@

"looks good" to gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.43 2009/12/13 22:02:55 jacekm Exp $	*/
d402 16
@


1.43
log
@Use safe fd limits in smtp, lka, queue, and control.  Removes a
possibility for fd-starvation fatal when under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.42 2009/12/02 19:10:02 mk Exp $	*/
a821 39
}

void
session_socket_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
}

void
session_socket_no_linger(int fd)
{
	struct linger	 lng;

	bzero(&lng, sizeof(lng));
	if (setsockopt(fd, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1)
		fatal("session_socket_no_linger");
}

int
session_socket_error(int fd)
{
	int	 err, len;

	len = sizeof(err);
	if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &len) == -1)
		fatal("session_socket_error: getsockopt");

	return (err);
@


1.42
log
@log_warn() consistency.

`OK' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.41 2009/11/26 22:21:20 chl Exp $	*/
d50 1
a50 1
int		 control_listen(struct smtpd *);
d54 1
a54 1
void		 control_close(int);
d188 1
a188 1
int
d191 5
a195 4
	if (listen(control_state.fd, CONTROL_BACKLOG) == -1) {
		log_warn("control_listen: listen");
		return (-1);
	}
d197 1
a197 1
	event_set(&control_state.ev, control_state.fd, EV_READ | EV_PERSIST,
d201 3
a203 1
	return (0);
d223 4
a226 5
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
		if (errno != EWOULDBLOCK && errno != EINTR)
			log_warn("control_accept: accept");
		return;
d231 2
a232 6
	if ((c = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		close(connfd);
		log_warn("control_accept");
		return;
	}

d240 4
d245 4
a248 1
	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
d264 1
a264 1
control_close(int fd)
a271 2

	msgbuf_clear(&c->iev.ibuf.w);
a272 1

d274 2
a275 1
	close(c->iev.ibuf.fd);
d277 8
d308 1
a308 1
			control_close(fd);
d315 1
a315 1
			control_close(fd);
d322 1
a322 1
			control_close(fd);
@


1.41
log
@fix copy & paste error: IMSG_MTA_RESUME --> IMSG_MDA_RESUME

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.40 2009/11/23 12:03:46 jacekm Exp $	*/
d223 1
a223 1
			log_warn("control_accept");
@


1.40
log
@In "smtpd; smtpd;" the second instance would fatal quickly, but it would
remove the smtpd.sock file, without which /usr/sbin/sendmail will fail
causing mails to be queued in offline.

Initially reported by ian@@, may explain oga@@'s e-mail burst after smtpd
restart.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.39 2009/10/25 19:46:31 gilles Exp $	*/
d443 1
a443 1
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_MTA_RESUME,
@


1.39
log
@smtpctl reload is work in progress, do not expose it and make sure smtpd's
control process does not try to handle it.

spotted and reported by martijn@@bunix.org
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.38 2009/09/18 00:04:26 jacekm Exp $	*/
d114 1
d119 3
@


1.38
log
@Remove useless Received line added at the /usr/sbin/sendmail stage, it
was not correctly formatted anyway.  Recording of sender uid has
been moved to the server process (getpeereid), which means it is not
subject to forgery.
Based on problem report by Michael Lechtermann <michael@@lechtermann.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.37 2009/09/15 16:50:06 jacekm Exp $	*/
d351 1
d371 1
@


1.37
log
@Extend SMTP client_* API to support SSL+AUTH, and use it in the mta
process to relay mails.  ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.36 2009/09/03 08:19:13 jacekm Exp $	*/
d323 1
a323 1
			    IMSG_SMTP_ENQUEUE, 0, 0, -1, &fd, sizeof(fd));
a781 1
			int		*fd = imsg.data;
d785 1
a785 3
			IMSG_SIZE_CHECK(fd);

			client_fd = *fd;
@


1.36
log
@imsg_get sets errno so use fatal instead of fatalx.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.35 2009/06/07 05:56:25 eric Exp $	*/
d825 22
@


1.35
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.34 2009/06/06 04:14:21 pyr Exp $	*/
d515 1
a515 1
			fatalx("control_dispatch_parent: imsg_get error");
d578 1
a578 1
			fatalx("control_dispatch_lka: imsg_get error");
d623 1
a623 1
			fatalx("control_dispatch_mfa: imsg_get error");
d668 1
a668 1
			fatalx("control_dispatch_queue: imsg_get error");
d713 1
a713 1
			fatalx("control_dispatch_runner: imsg_get error");
d776 1
a776 1
			fatalx("control_dispatch_smtp: imsg_get error");
@


1.34
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.33 2009/06/05 20:43:57 pyr Exp $	*/
d797 1
a797 1
			    imsg_get_fd(ibuf), NULL, 0);
@


1.33
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.32 2009/06/01 13:20:56 jacekm Exp $	*/
d231 7
a237 6
	imsg_init(&c->ibuf, connfd, control_dispatch_ext);
	c->ibuf.events = EV_READ;
	c->ibuf.data = env;
	event_set(&c->ibuf.ev, c->ibuf.fd, c->ibuf.events,
	    c->ibuf.handler, env);
	event_add(&c->ibuf.ev, NULL);
d247 1
a247 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.fd != fd;
d264 1
a264 1
	msgbuf_clear(&c->ibuf.w);
d267 2
a268 2
	event_del(&c->ibuf.ev);
	close(c->ibuf.fd);
d292 1
a292 1
		if ((n = imsg_read(&c->ibuf)) == -1 || n == 0) {
d299 1
a299 1
		if (msgbuf_write(&c->ibuf.w) < 0) {
d306 1
a306 1
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1) {
d318 1
a318 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d322 1
a322 1
			imsg_compose_event(env->sc_ibufs[PROC_SMTP],
d328 1
a328 1
			imsg_compose_event(&c->ibuf, IMSG_STATS, 0, 0, -1,
d343 1
a343 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d348 1
a348 1
			imsg_compose_event(env->sc_ibufs[PROC_RUNNER], IMSG_RUNNER_SCHEDULE, 0, 0, -1, s, sizeof(*s));
d360 1
a360 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d367 1
a367 1
			imsg_compose_event(env->sc_ibufs[PROC_PARENT], IMSG_CONF_RELOAD, 0, 0, -1, &r, sizeof(r));
d378 1
a378 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d383 1
a383 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d390 1
a390 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d395 1
a395 1
			imsg_compose_event(env->sc_ibufs[PROC_RUNNER], IMSG_MDA_PAUSE,
d397 1
a397 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d404 1
a404 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d409 1
a409 1
			imsg_compose_event(env->sc_ibufs[PROC_RUNNER], IMSG_MTA_PAUSE,
d411 1
a411 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d418 1
a418 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d423 1
a423 1
			imsg_compose_event(env->sc_ibufs[PROC_SMTP], IMSG_SMTP_PAUSE,			
d425 1
a425 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d432 1
a432 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d437 1
a437 1
			imsg_compose_event(env->sc_ibufs[PROC_RUNNER], IMSG_MTA_RESUME,
d439 1
a439 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d446 1
a446 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d451 1
a451 1
			imsg_compose_event(env->sc_ibufs[PROC_RUNNER], IMSG_MTA_RESUME,
d453 1
a453 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d460 1
a460 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d465 1
a465 1
			imsg_compose_event(env->sc_ibufs[PROC_SMTP], IMSG_SMTP_RESUME,
d467 1
a467 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d478 1
a478 1
		imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d482 1
a482 1
	imsg_event_add(&c->ibuf);
d489 1
d494 2
a495 1
	ibuf = env->sc_ibufs[PROC_PARENT];
d502 1
a502 1
			event_del(&ibuf->ev);
d533 1
a533 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d535 1
a535 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
d545 1
a545 1
	imsg_event_add(ibuf);
d552 1
d557 2
a558 1
	ibuf = env->sc_ibufs[PROC_LKA];
d565 1
a565 1
			event_del(&ibuf->ev);
d590 1
a590 1
	imsg_event_add(ibuf);
d597 1
d602 2
a603 1
	ibuf = env->sc_ibufs[PROC_MFA];
d610 1
a610 1
			event_del(&ibuf->ev);
d635 1
a635 1
	imsg_event_add(ibuf);
d642 1
d647 2
a648 1
	ibuf = env->sc_ibufs[PROC_QUEUE];
d655 1
a655 1
			event_del(&ibuf->ev);
d680 1
a680 1
	imsg_event_add(ibuf);
d687 1
d692 2
a693 1
	ibuf = env->sc_ibufs[PROC_RUNNER];
d700 1
a700 1
			event_del(&ibuf->ev);
d731 1
a731 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d733 1
a733 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
d743 1
a743 1
	imsg_event_add(ibuf);
d750 1
d755 2
a756 1
	ibuf = env->sc_ibufs[PROC_SMTP];
d763 1
a763 1
			event_del(&ibuf->ev);
d796 1
a796 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0,
d807 1
a807 1
	imsg_event_add(ibuf);
@


1.32
log
@Fix EV_READ/EV_WRITE testing inside IMSG handlers. Based on similar change
to the routing daemons by claudio@@; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.31 2009/05/25 11:17:32 jacekm Exp $	*/
d317 1
a317 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d321 1
a321 1
			imsg_compose(env->sc_ibufs[PROC_SMTP],
d327 1
a327 1
			imsg_compose(&c->ibuf, IMSG_STATS, 0, 0, -1,
d342 1
a342 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d347 1
a347 1
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_RUNNER_SCHEDULE, 0, 0, -1, s, sizeof(*s));
d359 1
a359 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d366 1
a366 1
			imsg_compose(env->sc_ibufs[PROC_PARENT], IMSG_CONF_RELOAD, 0, 0, -1, &r, sizeof(r));
d377 1
a377 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d382 1
a382 1
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d389 1
a389 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d394 1
a394 1
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_MDA_PAUSE,
d396 1
a396 1
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d403 1
a403 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d408 1
a408 1
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_MTA_PAUSE,
d410 1
a410 1
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d417 1
a417 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d422 1
a422 1
			imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_SMTP_PAUSE,			
d424 1
a424 1
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d431 1
a431 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d436 1
a436 1
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_MTA_RESUME,
d438 1
a438 1
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d445 1
a445 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d450 1
a450 1
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_MTA_RESUME,
d452 1
a452 1
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d459 1
a459 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d464 1
a464 1
			imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_SMTP_RESUME,
d466 1
a466 1
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d477 1
a477 1
		imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d530 1
a530 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d532 1
a532 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
d720 1
a720 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d722 1
a722 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);
d783 2
a784 2
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
			    imsg_get_fd(ibuf, &imsg), NULL, 0);
@


1.31
log
@Disallow submission using /usr/sbin/sendmail while the server is
paused, configuring, or exiting; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.30 2009/05/24 14:38:56 jacekm Exp $	*/
d290 1
a290 2
	switch (event) {
	case EV_READ:
d295 3
a297 2
		break;
	case EV_WRITE:
a301 4
		imsg_event_add(&c->ibuf);
		return;
	default:
		fatalx("unknown event");
d493 2
a494 2
	switch (event) {
	case EV_READ:
d503 3
a505 2
		break;
	case EV_WRITE:
a507 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d554 2
a555 2
	switch (event) {
	case EV_READ:
d564 3
a566 2
		break;
	case EV_WRITE:
a568 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d597 2
a598 2
	switch (event) {
	case EV_READ:
d607 3
a609 2
		break;
	case EV_WRITE:
a611 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d640 2
a641 2
	switch (event) {
	case EV_READ:
d650 3
a652 2
		break;
	case EV_WRITE:
a654 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d683 2
a684 2
	switch (event) {
	case EV_READ:
d693 3
a695 2
		break;
	case EV_WRITE:
a697 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d744 2
a745 2
	switch (event) {
	case EV_READ:
d754 3
a756 2
		break;
	case EV_WRITE:
a758 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
@


1.30
log
@Parent process forks 3 types of processes, track them all in a single tree
using newly introduced child struct.

Manage process titles centrally in struct smtpd.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.29 2009/05/24 14:22:23 jacekm Exp $	*/
d319 6
@


1.29
log
@Instead of keeping stats private to each process, and querying every
process individually whenever stats need to be fetched, keep stats
in MAP_ANON shared memory allocated by parent.

This means control has direct access to stats and can respond very
quickly without troubling any other daemon processes.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.28 2009/05/20 16:07:26 gilles Exp $	*/
a146 1
	setproctitle("control process");
d148 1
@


1.28
log
@previous commit to add reload support was missing some code, this diffs
contains the missing parts + a memleak plug
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.27 2009/05/20 14:29:44 gilles Exp $	*/
d322 1
a322 3
		case IMSG_STATS: {
			struct stats	s;

d325 2
a326 6

			s.fd = fd;
			imsg_compose(env->sc_ibufs[PROC_PARENT], IMSG_STATS, 0, 0, -1, &s, sizeof(s));
			imsg_compose(env->sc_ibufs[PROC_QUEUE], IMSG_STATS, 0, 0, -1, &s, sizeof(s));
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_STATS, 0, 0, -1, &s, sizeof(s));
			imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_STATS, 0, 0, -1, &s, sizeof(s));
a327 1
		}
a535 16
		case IMSG_STATS: {
			struct stats	*s = imsg.data;
			struct ctl_conn	*c;

			IMSG_SIZE_CHECK(s);

			if ((c = control_connbyfd(s->fd)) == NULL) {
				log_warn("control_dispatch_parent: fd %d not found", s->fd);
				return;
			}

			imsg_compose(&c->ibuf, IMSG_PARENT_STATS, 0, 0, -1,
			    &s->u.parent, sizeof(s->u.parent));

			break;
		}
a673 17
		case IMSG_STATS: {
			struct stats	*s = imsg.data;
			struct ctl_conn	*c;

			IMSG_SIZE_CHECK(s);

			if ((c = control_connbyfd(s->fd)) == NULL) {
				log_warn("control_dispatch_queue: fd %d not found", s->fd);
				imsg_free(&imsg);
				return;
			}

			imsg_compose(&c->ibuf, IMSG_QUEUE_STATS, 0, 0, -1,
			    &s->u.queue, sizeof(s->u.queue));

			break;
		}
a719 17
		case IMSG_STATS: {
			struct stats	*s = imsg.data;
			struct ctl_conn	*c;

			IMSG_SIZE_CHECK(s);

			if ((c = control_connbyfd(s->fd)) == NULL) {
				log_warn("control_dispatch_runner: fd %d not found", s->fd);
				imsg_free(&imsg);
				return;
			}

			imsg_compose(&c->ibuf, IMSG_RUNNER_STATS, 0, 0, -1,
			    &s->u.runner, sizeof(s->u.runner));

			break;
		}
a783 17
		case IMSG_STATS: {
			struct stats	*s = imsg.data;
			struct ctl_conn	*c;

			IMSG_SIZE_CHECK(s);

			if ((c = control_connbyfd(s->fd)) == NULL) {
				log_warn("control_dispatch_queue: fd %d not found", s->fd);
				imsg_free(&imsg);
				return;
			}

			imsg_compose(&c->ibuf, IMSG_SMTP_STATS, 0, 0, -1,
			    &s->u.smtp, sizeof(s->u.smtp));

			break;
		}
@


1.27
log
@first step towards configuration reload in smtpd, smtpctl reload will parse
the configuration file again and replace current configuration with new one
in all processes. what we don't support yet is graceful restart, clients in
sessions at the moment of the reload will have a temp failure thrown at 'em
which is ok RFC-wise but which we will try to improve anyway.

tested with various setups, "diff reads good" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.26 2009/05/19 11:24:24 jacekm Exp $	*/
d355 3
a357 1
		case IMSG_CONF_RELOAD:
d370 2
a371 3
			imsg_compose(env->sc_ibufs[PROC_PARENT], IMSG_CONF_RELOAD, 0, 0, -1, NULL, 0);

			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d373 1
d526 5
d532 9
@


1.26
log
@Verify the amount of IMSG payload is exactly as expected; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.25 2009/05/14 15:05:12 eric Exp $	*/
d355 17
d523 4
@


1.25
log
@use the nitems() macro where appropriate

ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.24 2009/05/09 20:04:36 jacekm Exp $	*/
d336 1
a336 1
			struct sched s;
d340 3
d344 1
a344 2
			s = *(struct sched *)imsg.data;
			s.fd = fd;
d346 1
a346 1
			if (! valid_message_id(s.mid) && ! valid_message_uid(s.mid)) {
d352 1
a352 1
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_RUNNER_SCHEDULE, 0, 0, -1, &s, sizeof(s));
d507 1
a507 1
			struct stats	*s;
d510 2
a511 1
			s = imsg.data;
d661 1
a661 1
			struct stats	*s;
d664 2
a665 1
			s = imsg.data;
d724 1
a724 1
			struct stats	*s;
d727 2
a728 1
			s = imsg.data;
d741 1
a741 1
			struct sched	*s;
d744 2
a745 1
			s = imsg.data;
d805 1
a805 1
			struct stats	*s;
d808 2
a809 1
			s = imsg.data;
d822 1
d826 3
a828 1
			client_fd = *(int *)imsg.data;
@


1.24
log
@fix rare memleak; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.23 2009/04/21 14:37:32 eric Exp $	*/
d168 2
a169 2
	config_pipes(env, peers, 5);
	config_peers(env, peers, 5);
@


1.23
log
@correct some fatal(x) calls and error strings

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.22 2009/04/16 15:35:06 jacekm Exp $	*/
d664 1
d726 1
d742 1
d805 1
d822 1
@


1.22
log
@Total rewrite of the sendmail interface. Adds support for -t, -v,
and -F cmdline args. Also, date and Message-Id headers are added
when missing.

The main trouble with the current enqueue code is that it requires
dealing with problems in the control process that are already solved
in the smtp process, ie. duplicating a lot of code which interacts
with untrusted clients. This diff solves this by making sendmail
obtain a SMTP socket from smtp via smtpd.sock, and using that socket
to deliver the message. For smtpd it looks as if connection was
made from the network, only difference being the F_MESSAGE_ENQUEUED
message flag, handy when differentation between local and remote
deliveries is wanted.

Most of the features come from the femail program, created by henning@@.

Additional testing by Nigel J. Taylor.

ok gilles@@, henning@@ happy with smtpd using femail code
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.21 2009/03/29 14:18:20 jacekm Exp $	*/
d499 1
a499 1
			fatal("control_dispatch_parent: imsg_read error");
d560 1
a560 1
			fatal("control_dispatch_lka: imsg_read error");
d606 1
a606 1
			fatal("control_dispatch_mfa: imsg_read error");
d652 1
a652 1
			fatal("control_dispatch_queue: imsg_read error");
d713 1
a713 1
			fatal("control_dispatch_runner: imsg_read error");
d790 1
a790 1
			fatal("control_dispatch_smtp: imsg_read error");
@


1.21
log
@turn some log_debugs into log_warns or even fatals; "looks ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2009/03/18 14:48:27 gilles Exp $	*/
d318 3
a320 10
		case IMSG_MFA_RCPT: {
			struct message_recipient *mr;

			if (c->state != CS_INIT && c->state != CS_RCPT)
				goto badstate;

			mr = imsg.data;
			imsg_compose(env->sc_ibufs[PROC_MFA], IMSG_MFA_RCPT, 0, 0, -1,
			    mr, sizeof(*mr));
			event_del(&c->ibuf.ev);
a321 40
		}
		case IMSG_QUEUE_CREATE_MESSAGE: {
			struct message *messagep;

			if (c->state != CS_NONE && c->state != CS_DONE)
				goto badstate;

			messagep = imsg.data;
			messagep->session_id = fd;
			imsg_compose(env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_CREATE_MESSAGE, 0, 0, -1,
			    messagep, sizeof(*messagep));
			event_del(&c->ibuf.ev);
			break;
		}
		case IMSG_QUEUE_MESSAGE_FILE: {
			struct message *messagep;

			if (c->state != CS_RCPT)
				goto badstate;

			messagep = imsg.data;
			messagep->session_id = fd;
			imsg_compose(env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_FILE, 0, 0, -1,
			    messagep, sizeof(*messagep));
			event_del(&c->ibuf.ev);
			break;
		}
		case IMSG_QUEUE_COMMIT_MESSAGE: {
			struct message *messagep;

			if (c->state != CS_FD)
				goto badstate;

			messagep = imsg.data;
			messagep->session_id = fd;
			imsg_compose(env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_COMMIT_MESSAGE, 0, 0, -1,
			    messagep, sizeof(*messagep));
			event_del(&c->ibuf.ev);
			break;
		}
a459 1
badstate:
a564 10
		case IMSG_QUEUE_TEMPFAIL: {
			struct submit_status	 *ss;

			log_debug("GOT LFA REPLY");
			ss = imsg.data;
			if (ss->code != 250)
				log_debug("LKA FAILED WITH TEMPORARY ERROR");

			break;
		}
a610 20
		case IMSG_MFA_RCPT: {
			struct submit_status	 *ss;
			struct ctl_conn		*c;

			ss = imsg.data;
			if ((c = control_connbyfd(ss->id)) == NULL) {
				log_warn("control_dispatch_queue: fd %lld: not found", ss->id);
				return;
			}

			event_add(&c->ibuf.ev, NULL);
			if (ss->code == 250) {
				c->state = CS_RCPT;
				break;
			}

			imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1, NULL, 0);

			break;
		}
a656 88
		case IMSG_QUEUE_CREATE_MESSAGE: {
			struct submit_status	 *ss;
			struct ctl_conn		*c;
			
			ss = imsg.data;
			if ((c = control_connbyfd(ss->id)) == NULL) {
				log_warn("control_dispatch_queue: fd %lld: not found", ss->id);
				return;
			}
			event_add(&c->ibuf.ev, NULL);

			if (ss->code != 250) {
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
			}
			else {
				c->state = CS_INIT;
				ss->msg.session_id = ss->id;
				strlcpy(ss->msg.message_id, ss->u.msgid,
				    sizeof(ss->msg.message_id));
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    &ss->msg, sizeof(struct message));
			}

			break;
		}
		case IMSG_QUEUE_COMMIT_ENVELOPES: {
			struct submit_status	 *ss;
			struct ctl_conn		*c;
			
			ss = imsg.data;
			if ((c = control_connbyfd(ss->id)) == NULL) {
				log_warn("control_dispatch_queue: fd %lld: not found", ss->id);
				return;
			}
			event_add(&c->ibuf.ev, NULL);
			c->state = CS_RCPT;
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
			    NULL, 0);

			break;
		}
		case IMSG_QUEUE_MESSAGE_FILE: {
			struct submit_status	 *ss;
			struct ctl_conn *c;
			int fd;

			ss = imsg.data;
			if ((c = control_connbyfd(ss->id)) == NULL) {
				log_warn("control_dispatch_queue: fd %lld: not found",
				    ss->id);
				return;
			}
			event_add(&c->ibuf.ev, NULL);

			fd = imsg_get_fd(ibuf, &imsg);
			if (ss->code == 250) {
				c->state = CS_FD;
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, fd,
				    &ss->msg, sizeof(struct message));
			}
			else
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    &ss->msg, sizeof(struct message));
			break;
		}
		case IMSG_QUEUE_COMMIT_MESSAGE: {
			struct submit_status	 *ss;
			struct ctl_conn *c;

			ss = imsg.data;
			if ((c = control_connbyfd(ss->id)) == NULL) {
				log_warn("control_dispatch_queue: fd %lld: not found",
				    ss->id);
				return;
			}
			event_add(&c->ibuf.ev, NULL);

			if (ss->code == 250) {
				c->state = CS_DONE;
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    &ss->msg, sizeof(struct message));
			}
			else
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    &ss->msg, sizeof(struct message));
			break;
		}
d808 15
@


1.20
log
@previous commit removed "else" condition
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2009/03/08 20:39:49 gilles Exp $	*/
d568 1
a568 1
			log_debug("control_dispatch_parent: unexpected imsg %d",
d570 1
a570 1
			break;
d624 1
a624 1
			log_debug("control_dispatch_lka: unexpected imsg %d",
d626 1
a626 1
			break;
d690 1
a690 1
			log_debug("control_dispatch_mfa: unexpected imsg %d",
d692 1
a692 1
			break;
d839 1
a839 1
			log_debug("control_dispatch_queue: unexpected imsg %d",
d841 1
a841 1
			break;
d916 1
a916 1
			log_debug("control_dispatch_runner: unexpected imsg %d",
d918 1
a918 1
			break;
d977 1
a977 1
			log_debug("control_dispatch_smtp: unexpected imsg %d",
d979 1
a979 1
			break;
@


1.19
log
@when operating in enqueue mode, it was easy to make smtpctl fatal() by
writing a small app that sent out of order imsg's. prevent this by use
of a state machine and read event masking.

issue spotted by jacekm@@, temporary fix by me. there are ideas around
this, but we want to experiment them a bit and they are low priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2009/03/01 13:05:41 jacekm Exp $	*/
d996 1
a996 1

@


1.18
log
@deny regular users to run "smtpctl show stats" and "smtpctl schedule";
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.17 2009/02/25 09:30:58 gilles Exp $	*/
d321 3
d327 1
a327 1

d333 3
d340 1
a340 1

d346 3
d353 1
d359 3
d366 1
a379 1

d506 2
a673 4

			if (ss->code == 250)
				break;

d678 7
a684 1
			
d744 1
d751 1
d770 2
a771 1

d788 1
d791 2
a792 1
			if (ss->code == 250)
d795 1
d811 1
d813 2
a814 1
			if (ss->code == 250)
d817 1
d996 1
a996 1
	else
@


1.17
log
@NULL pointer dereference
	spotted by Matthew Haub <matthew.haub@@alumni.adelaide.edu.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2009/02/24 12:07:47 gilles Exp $	*/
d358 3
d371 3
@


1.16
log
@teach smtpctl's parser how to deal with parameters that are not necessarily
a token so that it is possible to do: smtpctl schedule <message id/uid>

introduce F_MESSAGE_FORCESCHEDULE which lets the runner schedule a message
even if the retry delay has not been expired.

F_MESSAGE_ENQUEUED is a valid flag for a message and should not cause an\
errx() in smtpctl show queue
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2009/02/22 19:07:33 chl Exp $	*/
d258 1
a258 1
	if ((c = control_connbyfd(fd)) == NULL)
d260 2
@


1.15
log
@add missing headers

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2009/02/22 11:44:29 form Exp $	*/
d364 15
d863 16
@


1.14
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2009/02/17 22:49:22 jacekm Exp $	*/
d32 1
@


1.13
log
@imsg_init depends on ibuf being calloc'd. fix few places where malloc
is used instead; ok gilles@@

Problem made visible by malloc.conf = AFGJ, and pointed out by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2009/02/15 10:32:23 jacekm Exp $	*/
d710 2
a711 1
				strlcpy(ss->msg.message_id, ss->u.msgid, MAXPATHLEN);
@


1.12
log
@New config.c that allows for process cloning. Done by pyr@@ for
relayd at n2k9, and adapted to smtpd; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2009/01/29 21:59:15 jacekm Exp $	*/
d224 1
a224 1
	if ((c = malloc(sizeof(struct ctl_conn))) == NULL) {
@


1.11
log
@Implement "smtpctl show stats"; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2009/01/27 23:39:41 gilles Exp $	*/
d167 1
@


1.10
log
@instead of relying on socket permissions to allow or disallow imsg's that
come from the external process (smtpctl/send-mail/etc...), make the socket
world-writeable and request credentials with getpeereid().

discussed with pyr@@ who was happy to hand me over UNP opened at the
"passing credentials through a unix socket" page, but hopefully saved by
dlg@@ who knew about getpeereid() :-)
cvs: ----------------------------------------------------------------------
cvs: eNTER lOG.  lINES BEGINNING WITH `cvs:' ARE REMOVED AUTOMATICALLY
cvs:
cvs: cOMMITTING IN .
cvs:
cvs: mODIFIED fILES:
cvs: 	CONTROL.C PARSE.Y SMTP.C SMTPD.C SMTPD.H STORE.C
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2009/01/27 22:48:29 gilles Exp $	*/
d61 1
d94 1
d167 1
a167 1
	config_peers(env, peers, 4);
d351 11
d477 61
d771 15
d832 15
d893 15
@


1.9
log
@first bricks of enqueue code which allows smtpctl to submit mail to queue
without "talking" smtp to listeners. currently, a big part of the server
side code is done (and requires a cleanup), next step is to get it usable
properly from a mail user agent.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2009/01/04 22:35:09 gilles Exp $	*/
d127 1
a127 1
	if (chmod(SMTPD_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
d273 5
d352 4
d365 3
d379 3
d393 3
d407 3
d421 3
d435 3
d454 4
@


1.8
log
@the data member of ibuf was not set to the environment in control_accept()
which caused th ev_arg member of struct event to be reset after the first
call to control_dispatch_ext (causing a null deref at second call). this
has been driving me nuts for at least an hour ...
@
text
@d92 1
d165 1
a165 1
	config_peers(env, peers, 3);
d307 37
d468 10
d524 18
d588 78
@


1.7
log
@- smtp can now pause/resume the accepting of incoming messages
- smtpctl recognizes "pause incoming" and "resume incoming"
- setup imsg communication between control process and smtp process
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2009/01/04 19:37:41 gilles Exp $	*/
d228 1
@


1.6
log
@- runner is now capable of pausing/resuming the scheduling of deliveries
for both mda and mta batches.
- smtpctl can be used to disable/enable deliveries at runtime using the
pause/resume commands.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2009/01/01 16:15:47 jacekm Exp $	*/
d60 1
d91 1
d164 1
a164 1
	config_peers(env, peers, 2);
d316 1
a316 1
		case IMSG_RUNNER_PAUSE_MDA:
d323 1
a323 1
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_RUNNER_PAUSE_MDA,
d327 1
a327 1
		case IMSG_RUNNER_PAUSE_MTA:
d334 1
a334 1
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_RUNNER_PAUSE_MTA,
d338 12
a349 1
		case IMSG_RUNNER_RESUME_MDA:
d356 1
a356 1
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_RUNNER_RESUME_MDA,
d360 1
a360 1
		case IMSG_RUNNER_RESUME_MTA:
d367 12
a378 1
			imsg_compose(env->sc_ibufs[PROC_RUNNER], IMSG_RUNNER_RESUME_MTA,
a381 1

d569 46
@


1.5
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2008/12/05 02:51:32 gilles Exp $	*/
d314 45
@


1.4
log
@- last part of the new queue code: the runner process (unprivileged and
	chrooted) is now in charge of doing the scheduling of deliveries,
	and the dispatching of messages to MDA and MTA. queue process only
	does inserts/updates/removals from the queue and can no longer be
	so busy that it delays answers to imsg from smtp server.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2008/11/17 21:27:03 chl Exp $	*/
a31 1
#include <signal.h>
@


1.3
log
@add missing header needed by signal().
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d60 1
d90 1
d163 1
a163 1
	config_peers(env, peers, 1);
d456 46
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

