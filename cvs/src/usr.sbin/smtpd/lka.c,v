head	1.199;
access;
symbols
	OPENBSD_6_2_BASE:1.199
	OPENBSD_6_1:1.198.0.4
	OPENBSD_6_1_BASE:1.198
	OPENBSD_6_0:1.193.0.4
	OPENBSD_6_0_BASE:1.193
	OPENBSD_5_9:1.192.0.2
	OPENBSD_5_9_BASE:1.192
	OPENBSD_5_8:1.175.0.6
	OPENBSD_5_8_BASE:1.175
	OPENBSD_5_7:1.175.0.2
	OPENBSD_5_7_BASE:1.175
	OPENBSD_5_6:1.172.0.4
	OPENBSD_5_6_BASE:1.172
	OPENBSD_5_5:1.164.0.2
	OPENBSD_5_5_BASE:1.164
	OPENBSD_5_4:1.154.0.2
	OPENBSD_5_4_BASE:1.154
	OPENBSD_5_3:1.150.0.2
	OPENBSD_5_3_BASE:1.150
	OPENBSD_5_2:1.133.0.2
	OPENBSD_5_2_BASE:1.133
	OPENBSD_5_1_BASE:1.131
	OPENBSD_5_1:1.131.0.2
	OPENBSD_5_0:1.127.0.2
	OPENBSD_5_0_BASE:1.127
	OPENBSD_4_9:1.123.0.2
	OPENBSD_4_9_BASE:1.123
	OPENBSD_4_8:1.115.0.2
	OPENBSD_4_8_BASE:1.115
	OPENBSD_4_7:1.101.0.2
	OPENBSD_4_7_BASE:1.101
	OPENBSD_4_6:1.60.0.4
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28;
locks; strict;
comment	@ * @;


1.199
date	2017.05.17.14.00.06;	author deraadt;	state Exp;
branches;
next	1.198;
commitid	CQ2bJKe5Leh53ur4;

1.198
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.197;
commitid	jM4eOMW1AJwdfKrr;

1.197
date	2016.09.08.12.06.43;	author eric;	state Exp;
branches;
next	1.196;
commitid	LkfnyKFoItZAAepX;

1.196
date	2016.09.04.16.10.31;	author eric;	state Exp;
branches;
next	1.195;
commitid	I2r1xe6emhZl6xPg;

1.195
date	2016.09.03.15.54.14;	author gilles;	state Exp;
branches;
next	1.194;
commitid	S6WMTiQw5o2Jj9t3;

1.194
date	2016.09.01.10.54.25;	author eric;	state Exp;
branches;
next	1.193;
commitid	fYsbH2IujjKSME9c;

1.193
date	2016.05.28.21.21.20;	author eric;	state Exp;
branches;
next	1.192;
commitid	KhU4hSodVCiVoZ62;

1.192
date	2016.01.22.13.10.41;	author gilles;	state Exp;
branches;
next	1.191;
commitid	XdOxOGOlLbABl8OF;

1.191
date	2016.01.04.13.36.32;	author jung;	state Exp;
branches;
next	1.190;
commitid	R6th7P9mybtMxng6;

1.190
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.189;
commitid	ZxnqOQqX6IeYI9jW;

1.189
date	2015.12.14.10.22.12;	author jung;	state Exp;
branches;
next	1.188;
commitid	HRAnniyhGW9Sadln;

1.188
date	2015.12.12.20.02.31;	author gilles;	state Exp;
branches;
next	1.187;
commitid	eO2zB2XyKCWqQLmz;

1.187
date	2015.12.12.14.06.08;	author gilles;	state Exp;
branches;
next	1.186;
commitid	5Xmwlm1h3eZm2Id3;

1.186
date	2015.12.12.13.56.41;	author gilles;	state Exp;
branches;
next	1.185;
commitid	m21UEgYM6aonspKr;

1.185
date	2015.12.12.13.48.50;	author gilles;	state Exp;
branches;
next	1.184;
commitid	gfnbM2kl8fluIiJs;

1.184
date	2015.12.12.13.25.18;	author gilles;	state Exp;
branches;
next	1.183;
commitid	jvY5h8O8UREVmBRK;

1.183
date	2015.12.12.11.31.28;	author sunil;	state Exp;
branches;
next	1.182;
commitid	xbftp8DyefrEq9pW;

1.182
date	2015.12.12.10.55.21;	author gilles;	state Exp;
branches;
next	1.181;
commitid	9OMAfC2z8655PLWE;

1.181
date	2015.12.11.21.44.00;	author gilles;	state Exp;
branches;
next	1.180;
commitid	4sl0Vm3vIoWoEZs0;

1.180
date	2015.11.30.14.05.34;	author gilles;	state Exp;
branches;
next	1.179;
commitid	YDf0yhQQLmOYnyu6;

1.179
date	2015.11.30.12.49.35;	author gilles;	state Exp;
branches;
next	1.178;
commitid	ZyOzw2IPUjoaWKi5;

1.178
date	2015.10.14.22.01.43;	author gilles;	state Exp;
branches;
next	1.177;
commitid	XSq2zfqNj1sXRZRl;

1.177
date	2015.10.14.19.39.16;	author gilles;	state Exp;
branches;
next	1.176;
commitid	0HLvBm9mHjIhBrVK;

1.176
date	2015.10.02.00.28.30;	author gilles;	state Exp;
branches;
next	1.175;
commitid	OYhjSBMoyxcwh1id;

1.175
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches
	1.175.2.1
	1.175.6.1;
next	1.174;
commitid	ZBTFreARDSMmzOIV;

1.174
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.173;
commitid	Uu5nFG3wCl0LACBb;

1.173
date	2014.09.03.07.42.47;	author giovanni;	state Exp;
branches;
next	1.172;
commitid	Zahn3QYlUKxm44VN;

1.172
date	2014.07.10.15.54.55;	author eric;	state Exp;
branches
	1.172.4.1;
next	1.171;
commitid	Uxz21DeZX3Z1gOVr;

1.171
date	2014.07.08.13.49.09;	author eric;	state Exp;
branches;
next	1.170;
commitid	pEybL9fsrDOC6PJj;

1.170
date	2014.05.22.20.31.03;	author gilles;	state Exp;
branches;
next	1.169;

1.169
date	2014.05.01.15.50.20;	author reyk;	state Exp;
branches;
next	1.168;

1.168
date	2014.04.29.19.13.13;	author reyk;	state Exp;
branches;
next	1.167;

1.167
date	2014.04.15.08.32.45;	author eric;	state Exp;
branches;
next	1.166;

1.166
date	2014.04.09.15.23.49;	author eric;	state Exp;
branches;
next	1.165;

1.165
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.164;

1.164
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.163;

1.163
date	2014.02.04.09.50.31;	author eric;	state Exp;
branches;
next	1.162;

1.162
date	2014.02.04.09.05.06;	author eric;	state Exp;
branches;
next	1.161;

1.161
date	2013.11.20.09.22.42;	author eric;	state Exp;
branches;
next	1.160;

1.160
date	2013.11.18.12.24.26;	author eric;	state Exp;
branches;
next	1.159;

1.159
date	2013.11.13.08.39.33;	author eric;	state Exp;
branches;
next	1.158;

1.158
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.157;

1.157
date	2013.10.28.17.02.08;	author eric;	state Exp;
branches;
next	1.156;

1.156
date	2013.10.27.19.12.12;	author eric;	state Exp;
branches;
next	1.155;

1.155
date	2013.10.27.07.56.25;	author eric;	state Exp;
branches;
next	1.154;

1.154
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.153;

1.153
date	2013.07.19.07.49.08;	author eric;	state Exp;
branches;
next	1.152;

1.152
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.151;

1.151
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.150;

1.150
date	2013.02.14.12.30.49;	author gilles;	state Exp;
branches;
next	1.149;

1.149
date	2013.02.05.11.45.18;	author gilles;	state Exp;
branches;
next	1.148;

1.148
date	2013.01.28.11.09.53;	author gilles;	state Exp;
branches;
next	1.147;

1.147
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.146;

1.146
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.145;

1.145
date	2012.10.14.11.58.23;	author gilles;	state Exp;
branches;
next	1.144;

1.144
date	2012.10.13.08.01.47;	author eric;	state Exp;
branches;
next	1.143;

1.143
date	2012.09.30.14.28.15;	author gilles;	state Exp;
branches;
next	1.142;

1.142
date	2012.09.29.10.35.00;	author eric;	state Exp;
branches;
next	1.141;

1.141
date	2012.09.28.14.03.00;	author chl;	state Exp;
branches;
next	1.140;

1.140
date	2012.09.21.10.22.29;	author eric;	state Exp;
branches;
next	1.139;

1.139
date	2012.09.19.19.40.36;	author eric;	state Exp;
branches;
next	1.138;

1.138
date	2012.09.19.11.57.35;	author eric;	state Exp;
branches;
next	1.137;

1.137
date	2012.09.18.13.42.39;	author eric;	state Exp;
branches;
next	1.136;

1.136
date	2012.09.16.16.43.28;	author chl;	state Exp;
branches;
next	1.135;

1.135
date	2012.08.25.22.52.19;	author eric;	state Exp;
branches;
next	1.134;

1.134
date	2012.08.18.18.18.23;	author gilles;	state Exp;
branches;
next	1.133;

1.133
date	2012.05.12.15.31.43;	author gilles;	state Exp;
branches;
next	1.132;

1.132
date	2012.05.12.15.29.16;	author gilles;	state Exp;
branches;
next	1.131;

1.131
date	2011.11.14.19.23.41;	author chl;	state Exp;
branches;
next	1.130;

1.130
date	2011.10.23.15.36.53;	author eric;	state Exp;
branches;
next	1.129;

1.129
date	2011.10.23.09.30.06;	author gilles;	state Exp;
branches;
next	1.128;

1.128
date	2011.10.09.18.39.53;	author eric;	state Exp;
branches;
next	1.127;

1.127
date	2011.05.16.21.05.51;	author gilles;	state Exp;
branches;
next	1.126;

1.126
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.125;

1.125
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.124;

1.124
date	2011.04.17.11.39.22;	author gilles;	state Exp;
branches;
next	1.123;

1.123
date	2010.11.29.15.25.55;	author gilles;	state Exp;
branches;
next	1.122;

1.122
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.121;

1.121
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.120;

1.120
date	2010.10.29.09.16.07;	author gilles;	state Exp;
branches;
next	1.119;

1.119
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.118;

1.118
date	2010.09.20.09.01.09;	author gilles;	state Exp;
branches;
next	1.117;

1.117
date	2010.09.12.22.38.31;	author gilles;	state Exp;
branches;
next	1.116;

1.116
date	2010.09.08.13.46.18;	author gilles;	state Exp;
branches;
next	1.115;

1.115
date	2010.06.04.11.15.25;	author jacekm;	state Exp;
branches;
next	1.114;

1.114
date	2010.06.02.19.16.53;	author chl;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.112;

1.112
date	2010.06.01.19.47.08;	author jacekm;	state Exp;
branches;
next	1.111;

1.111
date	2010.06.01.02.19.56;	author jacekm;	state Exp;
branches;
next	1.110;

1.110
date	2010.06.01.02.08.56;	author jacekm;	state Exp;
branches;
next	1.109;

1.109
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.108;

1.108
date	2010.05.27.15.36.04;	author gilles;	state Exp;
branches;
next	1.107;

1.107
date	2010.04.27.09.49.23;	author gilles;	state Exp;
branches;
next	1.106;

1.106
date	2010.04.21.21.47.38;	author gilles;	state Exp;
branches;
next	1.105;

1.105
date	2010.04.21.19.53.15;	author gilles;	state Exp;
branches;
next	1.104;

1.104
date	2010.04.21.18.54.43;	author jacekm;	state Exp;
branches;
next	1.103;

1.103
date	2010.04.21.08.29.01;	author jacekm;	state Exp;
branches;
next	1.102;

1.102
date	2010.04.20.15.34.56;	author jacekm;	state Exp;
branches;
next	1.101;

1.101
date	2010.02.17.17.27.47;	author gilles;	state Exp;
branches;
next	1.100;

1.100
date	2010.02.17.13.47.31;	author gilles;	state Exp;
branches;
next	1.99;

1.99
date	2010.02.17.08.40.24;	author gilles;	state Exp;
branches;
next	1.98;

1.98
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.97;

1.97
date	2009.12.15.00.23.38;	author jacekm;	state Exp;
branches;
next	1.96;

1.96
date	2009.12.14.19.56.55;	author jacekm;	state Exp;
branches;
next	1.95;

1.95
date	2009.12.13.22.02.55;	author jacekm;	state Exp;
branches;
next	1.94;

1.94
date	2009.11.13.11.27.51;	author jacekm;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.10.14.46.18;	author jacekm;	state Exp;
branches;
next	1.92;

1.92
date	2009.11.10.10.25.11;	author jacekm;	state Exp;
branches;
next	1.91;

1.91
date	2009.11.10.09.53.40;	author jacekm;	state Exp;
branches;
next	1.90;

1.90
date	2009.11.10.01.09.24;	author gilles;	state Exp;
branches;
next	1.89;

1.89
date	2009.11.10.00.42.55;	author gilles;	state Exp;
branches;
next	1.88;

1.88
date	2009.11.10.00.36.29;	author gilles;	state Exp;
branches;
next	1.87;

1.87
date	2009.11.10.00.21.46;	author gilles;	state Exp;
branches;
next	1.86;

1.86
date	2009.11.10.00.13.33;	author gilles;	state Exp;
branches;
next	1.85;

1.85
date	2009.11.09.23.49.34;	author gilles;	state Exp;
branches;
next	1.84;

1.84
date	2009.11.09.22.28.08;	author gilles;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.08.23.08.56;	author gilles;	state Exp;
branches;
next	1.82;

1.82
date	2009.11.08.21.40.05;	author gilles;	state Exp;
branches;
next	1.81;

1.81
date	2009.11.08.19.38.26;	author gilles;	state Exp;
branches;
next	1.80;

1.80
date	2009.11.05.12.26.19;	author gilles;	state Exp;
branches;
next	1.79;

1.79
date	2009.11.05.12.06.41;	author gilles;	state Exp;
branches;
next	1.78;

1.78
date	2009.11.05.12.02.22;	author gilles;	state Exp;
branches;
next	1.77;

1.77
date	2009.11.05.10.27.24;	author gilles;	state Exp;
branches;
next	1.76;

1.76
date	2009.11.03.22.57.41;	author gilles;	state Exp;
branches;
next	1.75;

1.75
date	2009.11.03.20.55.23;	author gilles;	state Exp;
branches;
next	1.74;

1.74
date	2009.11.03.19.13.34;	author gilles;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.03.10.56.51;	author nicm;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.25.21.50.46;	author gilles;	state Exp;
branches;
next	1.71;

1.71
date	2009.10.19.20.48.13;	author gilles;	state Exp;
branches;
next	1.70;

1.70
date	2009.10.18.21.45.47;	author gilles;	state Exp;
branches;
next	1.69;

1.69
date	2009.10.18.19.53.49;	author gilles;	state Exp;
branches;
next	1.68;

1.68
date	2009.10.16.22.26.27;	author gilles;	state Exp;
branches;
next	1.67;

1.67
date	2009.10.12.22.34.37;	author gilles;	state Exp;
branches;
next	1.66;

1.66
date	2009.10.11.17.40.49;	author gilles;	state Exp;
branches;
next	1.65;

1.65
date	2009.10.07.18.09.12;	author gilles;	state Exp;
branches;
next	1.64;

1.64
date	2009.10.07.17.30.41;	author gilles;	state Exp;
branches;
next	1.63;

1.63
date	2009.09.03.08.19.13;	author jacekm;	state Exp;
branches;
next	1.62;

1.62
date	2009.08.08.00.02.22;	author gilles;	state Exp;
branches;
next	1.61;

1.61
date	2009.08.07.20.21.48;	author gilles;	state Exp;
branches;
next	1.60;

1.60
date	2009.06.07.05.56.25;	author eric;	state Exp;
branches;
next	1.59;

1.59
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.03.16.31.55;	author jacekm;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.01.23.15.48;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.01.22.51.47;	author gilles;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.01.21.19.15;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.01.18.24.01;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2009.06.01.13.20.56;	author jacekm;	state Exp;
branches;
next	1.51;

1.51
date	2009.05.24.14.38.56;	author jacekm;	state Exp;
branches;
next	1.50;

1.50
date	2009.05.20.16.07.26;	author gilles;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.20.14.36.55;	author gilles;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.20.14.29.44;	author gilles;	state Exp;
branches;
next	1.47;

1.47
date	2009.05.19.11.24.24;	author jacekm;	state Exp;
branches;
next	1.46;

1.46
date	2009.05.14.15.05.12;	author eric;	state Exp;
branches;
next	1.45;

1.45
date	2009.05.09.17.04.55;	author jacekm;	state Exp;
branches;
next	1.44;

1.44
date	2009.05.01.21.44.19;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2009.04.28.23.11.25;	author gilles;	state Exp;
branches;
next	1.42;

1.42
date	2009.04.28.22.38.22;	author jacekm;	state Exp;
branches;
next	1.41;

1.41
date	2009.04.21.14.37.32;	author eric;	state Exp;
branches;
next	1.40;

1.40
date	2009.04.09.19.49.34;	author jacekm;	state Exp;
branches;
next	1.39;

1.39
date	2009.04.05.16.33.12;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.29.14.18.20;	author jacekm;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.22.22.53.47;	author gilles;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.20.09.34.34;	author gilles;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.11.11.11.08;	author pea;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.09.16.31.09;	author jacekm;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.09.01.43.19;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.08.17.54.20;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.04.00.00.40;	author gilles;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.03.23.33.52;	author gilles;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.03.23.23.52;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.24.21.40.51;	author jacekm;	state Exp;
branches;
next	1.27;

1.27
date	2009.02.22.23.21.40;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2009.02.22.19.07.33;	author chl;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.18.12.06.01;	author jacekm;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.17.22.15.01;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.15.13.12.19;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.15.10.32.23;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.13.23.54.37;	author jacekm;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.28.17.43.45;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.08.19.17.31;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.07.00.26.30;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.06.23.12.28;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.04.17.45.58;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.04.14.46.14;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.04.00.58.59;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.22.13.35.58;	author jacekm;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.22.13.14.30;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.22.12.59.15;	author jacekm;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.20.00.18.03;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.13.23.19.33;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.05.19.09.59;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.05.02.51.32;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.25.20.26.40;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.10.21.29.18;	author chl;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;

1.172.4.1
date	2015.10.02.01.33.33;	author gilles;	state Exp;
branches;
next	;
commitid	2Q56YgF5PzqMcagu;

1.175.2.1
date	2015.10.02.01.28.43;	author gilles;	state Exp;
branches;
next	;
commitid	pAamrt3DJscJjb10;

1.175.6.1
date	2015.10.02.00.55.02;	author gilles;	state Exp;
branches;
next	;
commitid	5SntIHNUPMG4dcQ1;


desc
@@


1.199
log
@Introduce more use of freezero().  Also, remove ptr conditionals before
many functions which are free(NULL)-compat
ok gilles
@
text
@/*	$OpenBSD: lka.c,v 1.198 2017/01/09 09:53:23 reyk Exp $	*/

/*
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2012 Eric Faurot <eric@@faurot.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/uio.h>

#include <netinet/in.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
#include <pwd.h>
#include <resolv.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"
#include "ssl.h"

static void lka_imsg(struct mproc *, struct imsg *);
static void lka_shutdown(void);
static void lka_sig_handler(int, short, void *);
static int lka_authenticate(const char *, const char *, const char *);
static int lka_credentials(const char *, const char *, char *, size_t);
static int lka_userinfo(const char *, const char *, struct userinfo *);
static int lka_addrname(const char *, const struct sockaddr *,
    struct addrname *);
static int lka_mailaddrmap(const char *, const char *, const struct mailaddr *);
static int lka_X509_verify(struct ca_vrfy_req_msg *, const char *, const char *);
static void lka_certificate_verify(enum imsg_type, struct ca_vrfy_req_msg *);
static void lka_certificate_verify_resume(enum imsg_type, struct ca_vrfy_req_msg *);

static void
lka_imsg(struct mproc *p, struct imsg *imsg)
{
	struct table		*table;
	int			 ret;
	struct pki		*pki;
	struct iovec		iov[2];
	static struct ca_vrfy_req_msg	*req_ca_vrfy = NULL;
	struct ca_vrfy_req_msg		*req_ca_vrfy_chain;
	struct ca_cert_req_msg		*req_ca_cert;
	struct ca_cert_resp_msg		 resp_ca_cert;
	struct sockaddr_storage	 ss;
	struct userinfo		 userinfo;
	struct addrname		 addrname;
	struct envelope		 evp;
	struct mailaddr		 maddr;
	struct msg		 m;
	union lookup		 lk;
	char			 buf[LINE_MAX];
	const char		*tablename, *username, *password, *label;
	uint64_t		 reqid;
	int			 v;

	if (imsg == NULL)
		lka_shutdown();

	if (imsg->hdr.type == IMSG_MTA_DNS_HOST ||
	    imsg->hdr.type == IMSG_MTA_DNS_PTR ||
	    imsg->hdr.type == IMSG_SMTP_DNS_PTR ||
	    imsg->hdr.type == IMSG_MTA_DNS_MX ||
	    imsg->hdr.type == IMSG_MTA_DNS_MX_PREFERENCE) {
		dns_imsg(p, imsg);
		return;
	}

	if (p->proc == PROC_PONY) {
		switch (imsg->hdr.type) {
		case IMSG_SMTP_CHECK_SENDER:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &tablename);
			m_get_string(&m, &username);
			m_get_mailaddr(&m, &maddr);
			m_end(&m);

			ret = lka_mailaddrmap(tablename, username, &maddr);

			m_create(p, IMSG_SMTP_CHECK_SENDER, 0, 0, -1);
			m_add_id(p, reqid);
			m_add_int(p, ret);
			m_close(p);
			return;

		case IMSG_SMTP_EXPAND_RCPT:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_envelope(&m, &evp);
			m_end(&m);
			lka_session(reqid, &evp);
			return;

		case IMSG_SMTP_LOOKUP_HELO:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &tablename);
			m_get_sockaddr(&m, (struct sockaddr *)&ss);
			m_end(&m);

			ret = lka_addrname(tablename, (struct sockaddr*)&ss,
			    &addrname);

			m_create(p, IMSG_SMTP_LOOKUP_HELO, 0, 0, -1);
			m_add_id(p, reqid);
			m_add_int(p, ret);
			if (ret == LKA_OK)
				m_add_string(p, addrname.name);
			m_close(p);
			return;

		case IMSG_SMTP_TLS_INIT:
		case IMSG_MTA_TLS_INIT:
			req_ca_cert = imsg->data;
			resp_ca_cert.reqid = req_ca_cert->reqid;

			xlowercase(buf, req_ca_cert->name, sizeof(buf));
			log_debug("debug: lka: looking up pki \"%s\"", buf);
			pki = dict_get(env->sc_pki_dict, buf);
			if (pki == NULL)
				if (req_ca_cert->fallback)
					pki = dict_get(env->sc_pki_dict, "*");
			if (pki == NULL) {
				resp_ca_cert.status = CA_FAIL;
				m_compose(p, imsg->hdr.type, 0, 0, -1, &resp_ca_cert,
				    sizeof(resp_ca_cert));
				return;
			}
			resp_ca_cert.status = CA_OK;
			resp_ca_cert.cert_len = pki->pki_cert_len;
			(void)strlcpy(resp_ca_cert.name, pki->pki_name, sizeof resp_ca_cert.name);
			iov[0].iov_base = &resp_ca_cert;
			iov[0].iov_len = sizeof(resp_ca_cert);
			iov[1].iov_base = pki->pki_cert;
			iov[1].iov_len = pki->pki_cert_len;
			m_composev(p, imsg->hdr.type, 0, 0, -1, iov, nitems(iov));
			return;

		case IMSG_SMTP_TLS_VERIFY_CERT:
		case IMSG_MTA_TLS_VERIFY_CERT:
			req_ca_vrfy = xmemdup(imsg->data, sizeof *req_ca_vrfy, "lka:ca_vrfy");
			req_ca_vrfy->cert = xmemdup((char *)imsg->data +
			    sizeof *req_ca_vrfy, req_ca_vrfy->cert_len, "lka:ca_vrfy");
			req_ca_vrfy->chain_cert = xcalloc(req_ca_vrfy->n_chain,
			    sizeof (unsigned char *), "lka:ca_vrfy");
			req_ca_vrfy->chain_cert_len = xcalloc(req_ca_vrfy->n_chain,
			    sizeof (off_t), "lka:ca_vrfy");
			return;

		case IMSG_SMTP_TLS_VERIFY_CHAIN:
		case IMSG_MTA_TLS_VERIFY_CHAIN:
			if (req_ca_vrfy == NULL)
				fatalx("lka:ca_vrfy: chain without a certificate");
			req_ca_vrfy_chain = imsg->data;
			req_ca_vrfy->chain_cert[req_ca_vrfy->chain_offset] = xmemdup((char *)imsg->data +
			    sizeof *req_ca_vrfy_chain, req_ca_vrfy_chain->cert_len, "lka:ca_vrfy");
			req_ca_vrfy->chain_cert_len[req_ca_vrfy->chain_offset] = req_ca_vrfy_chain->cert_len;
			req_ca_vrfy->chain_offset++;
			return;

		case IMSG_SMTP_TLS_VERIFY:
		case IMSG_MTA_TLS_VERIFY:
			if (req_ca_vrfy == NULL)
				fatalx("lka:ca_vrfy: verify without a certificate");
			lka_certificate_verify(imsg->hdr.type, req_ca_vrfy);
			req_ca_vrfy = NULL;
			return;

		case IMSG_SMTP_AUTHENTICATE:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &tablename);
			m_get_string(&m, &username);
			m_get_string(&m, &password);
			m_end(&m);

			if (!tablename[0]) {
				m_create(p_parent, IMSG_LKA_AUTHENTICATE,
				    0, 0, -1);
				m_add_id(p_parent, reqid);
				m_add_string(p_parent, username);
				m_add_string(p_parent, password);
				m_close(p_parent);
				return;
			}

			ret = lka_authenticate(tablename, username, password);

			m_create(p, IMSG_SMTP_AUTHENTICATE, 0, 0, -1);
			m_add_id(p, reqid);
			m_add_int(p, ret);
			m_close(p);
			return;
		}
	}

	if (p->proc == PROC_PONY) {
		switch (imsg->hdr.type) {
		case IMSG_MDA_LOOKUP_USERINFO:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &tablename);
			m_get_string(&m, &username);
			m_end(&m);

			ret = lka_userinfo(tablename, username, &userinfo);

			m_create(p, IMSG_MDA_LOOKUP_USERINFO, 0, 0, -1);
			m_add_id(p, reqid);
			m_add_int(p, ret);
			if (ret == LKA_OK)
				m_add_data(p, &userinfo, sizeof(userinfo));
			m_close(p);
			return;
		}
	}

	if (p->proc == PROC_PONY) {
		switch (imsg->hdr.type) {

		case IMSG_MTA_LOOKUP_CREDENTIALS:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &tablename);
			m_get_string(&m, &label);
			m_end(&m);

			lka_credentials(tablename, label, buf, sizeof(buf));

			m_create(p, IMSG_MTA_LOOKUP_CREDENTIALS, 0, 0, -1);
			m_add_id(p, reqid);
			m_add_string(p, buf);
			m_close(p);
			return;

		case IMSG_MTA_LOOKUP_SOURCE:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &tablename);
			m_end(&m);

			table = table_find(tablename, NULL);

			m_create(p, IMSG_MTA_LOOKUP_SOURCE, 0, 0, -1);
			m_add_id(p, reqid);

			if (table == NULL) {
				log_warn("warn: source address table %s missing",
				    tablename);
				m_add_int(p, LKA_TEMPFAIL);
			}
			else {
				ret = table_fetch(table, NULL, K_SOURCE, &lk);
				if (ret == -1)
					m_add_int(p, LKA_TEMPFAIL);
				else if (ret == 0)
					m_add_int(p, LKA_PERMFAIL);
				else {
					m_add_int(p, LKA_OK);
					m_add_sockaddr(p,
					    (struct sockaddr *)&lk.source.addr);
				}
			}
			m_close(p);
			return;

		case IMSG_MTA_LOOKUP_HELO:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &tablename);
			m_get_sockaddr(&m, (struct sockaddr *)&ss);
			m_end(&m);

			ret = lka_addrname(tablename, (struct sockaddr*)&ss,
			    &addrname);

			m_create(p, IMSG_MTA_LOOKUP_HELO, 0, 0, -1);
			m_add_id(p, reqid);
			m_add_int(p, ret);
			if (ret == LKA_OK)
				m_add_string(p, addrname.name);
			m_close(p);
			return;

		}
	}

	if (p->proc == PROC_PARENT) {
		switch (imsg->hdr.type) {
		case IMSG_CONF_START:
			return;

		case IMSG_CONF_END:
			if (tracing & TRACE_TABLES)
				table_dump_all();

			/* fork & exec tables that need it */
			table_open_all();

			/* revoke proc & exec */
			if (pledge("stdio rpath inet dns getpw recvfd",
				NULL) == -1)
				err(1, "pledge");

			/* Start fulfilling requests */
			mproc_enable(p_pony);
			return;

		case IMSG_LKA_OPEN_FORWARD:
			lka_session_forward_reply(imsg->data, imsg->fd);
			return;

		case IMSG_LKA_AUTHENTICATE:
			imsg->hdr.type = IMSG_SMTP_AUTHENTICATE;
			m_forward(p_pony, imsg);
			return;
		}
	}

	if (p->proc == PROC_CONTROL) {
		switch (imsg->hdr.type) {

		case IMSG_CTL_VERBOSE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			log_trace_verbose(v);
			return;

		case IMSG_CTL_PROFILE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			profiling = v;
			return;

		case IMSG_CTL_UPDATE_TABLE:
			table = table_find(imsg->data, NULL);
			if (table == NULL) {
				log_warnx("warn: Lookup table not found: "
				    "\"%s\"", (char *)imsg->data);
				return;
			}
			table_update(table);
			return;
		}
	}

	errx(1, "lka_imsg: unexpected %s imsg", imsg_to_str(imsg->hdr.type));
}

static void
lka_sig_handler(int sig, short event, void *p)
{
	int status;
	pid_t pid;

	switch (sig) {
	case SIGCHLD:
		do {
			pid = waitpid(-1, &status, WNOHANG);
		} while (pid > 0 || (pid == -1 && errno == EINTR));
		break;
	default:
		fatalx("lka_sig_handler: unexpected signal");
	}
}

void
lka_shutdown(void)
{
	log_debug("debug: lookup agent exiting");
	_exit(0);
}

int
lka(void)
{
	struct passwd	*pw;
	struct event	 ev_sigchld;

	purge_config(PURGE_LISTENERS);

	if ((pw = getpwnam(SMTPD_USER)) == NULL)
		fatalx("unknown user " SMTPD_USER);

	config_process(PROC_LKA);

	if (initgroups(pw->pw_name, pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("lka: cannot drop privileges");

	imsg_callback = lka_imsg;
	event_init();

	signal_set(&ev_sigchld, SIGCHLD, lka_sig_handler, NULL);
	signal_add(&ev_sigchld, NULL);
	signal(SIGINT, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	config_peer(PROC_PARENT);
	config_peer(PROC_QUEUE);
	config_peer(PROC_CONTROL);
	config_peer(PROC_PONY);

	/* Ignore them until we get our config */
	mproc_disable(p_pony);

	/* proc & exec will be revoked before serving requests */
	if (pledge("stdio rpath inet dns getpw recvfd proc exec", NULL) == -1)
		err(1, "pledge");

	event_dispatch();
	fatalx("exited event loop");

	return (0);
}

static int
lka_authenticate(const char *tablename, const char *user, const char *password)
{
	struct table		*table;
	char			*cpass;
	union lookup		 lk;

	log_debug("debug: lka: authenticating for %s:%s", tablename, user);
	table = table_find(tablename, NULL);
	if (table == NULL) {
		log_warnx("warn: could not find table %s needed for authentication",
		    tablename);
		return (LKA_TEMPFAIL);
	}

	switch (table_lookup(table, NULL, user, K_CREDENTIALS, &lk)) {
	case -1:
		log_warnx("warn: user credentials lookup fail for %s:%s",
		    tablename, user);
		return (LKA_TEMPFAIL);
	case 0:
		return (LKA_PERMFAIL);
	default:
		cpass = crypt(password, lk.creds.password);
		if (cpass == NULL)
			return (LKA_PERMFAIL);
		if (!strcmp(lk.creds.password, cpass))
			return (LKA_OK);
		return (LKA_PERMFAIL);
	}
}

static int
lka_credentials(const char *tablename, const char *label, char *dst, size_t sz)
{
	struct table		*table;
	union lookup		 lk;
	char			*buf;
	int			 buflen, r;

	table = table_find(tablename, NULL);
	if (table == NULL) {
		log_warnx("warn: credentials table %s missing", tablename);
		return (LKA_TEMPFAIL);
	}

	dst[0] = '\0';

	switch(table_lookup(table, NULL, label, K_CREDENTIALS, &lk)) {
	case -1:
		log_warnx("warn: credentials lookup fail for %s:%s",
		    tablename, label);
		return (LKA_TEMPFAIL);
	case 0:
		log_warnx("warn: credentials not found for %s:%s",
		    tablename, label);
		return (LKA_PERMFAIL);
	default:
		if ((buflen = asprintf(&buf, "%c%s%c%s", '\0',
		    lk.creds.username, '\0', lk.creds.password)) == -1) {
			log_warn("warn");
			return (LKA_TEMPFAIL);
		}

		r = base64_encode((unsigned char *)buf, buflen, dst, sz);
		free(buf);

		if (r == -1) {
			log_warnx("warn: credentials parse error for %s:%s",
			    tablename, label);
			return (LKA_TEMPFAIL);
		}
		return (LKA_OK);
	}
}

static int
lka_userinfo(const char *tablename, const char *username, struct userinfo *res)
{
	struct table	*table;
	union lookup	 lk;

	log_debug("debug: lka: userinfo %s:%s", tablename, username);
	table = table_find(tablename, NULL);
	if (table == NULL) {
		log_warnx("warn: cannot find user table %s", tablename);
		return (LKA_TEMPFAIL);
	}

	switch (table_lookup(table, NULL, username, K_USERINFO, &lk)) {
	case -1:
		log_warnx("warn: failure during userinfo lookup %s:%s",
		    tablename, username);
		return (LKA_TEMPFAIL);
	case 0:
		return (LKA_PERMFAIL);
	default:
		*res = lk.userinfo;
		return (LKA_OK);
	}
}

static int
lka_addrname(const char *tablename, const struct sockaddr *sa,
    struct addrname *res)
{
	struct table	*table;
	union lookup	 lk;
	const char	*source;

	source = sa_to_text(sa);

	log_debug("debug: lka: helo %s:%s", tablename, source);
	table = table_find(tablename, NULL);
	if (table == NULL) {
		log_warnx("warn: cannot find helo table %s", tablename);
		return (LKA_TEMPFAIL);
	}

	switch (table_lookup(table, NULL, source, K_ADDRNAME, &lk)) {
	case -1:
		log_warnx("warn: failure during helo lookup %s:%s",
		    tablename, source);
		return (LKA_TEMPFAIL);
	case 0:
		return (LKA_PERMFAIL);
	default:
		*res = lk.addrname;
		return (LKA_OK);
	}
}

static int
lka_mailaddrmap(const char *tablename, const char *username, const struct mailaddr *maddr)
{
	struct table	       *table;
	struct maddrnode       *mn;
	union lookup		lk;
	int			found;

	log_debug("debug: lka: mailaddrmap %s:%s", tablename, username);
	table = table_find(tablename, NULL);
	if (table == NULL) {
		log_warnx("warn: cannot find mailaddrmap table %s", tablename);
		return (LKA_TEMPFAIL);
	}

	switch (table_lookup(table, NULL, username, K_MAILADDRMAP, &lk)) {
	case -1:
		log_warnx("warn: failure during mailaddrmap lookup %s:%s",
		    tablename, username);
		return (LKA_TEMPFAIL);
	case 0:
		return (LKA_PERMFAIL);
	default:
		found = 0;
		TAILQ_FOREACH(mn, &lk.maddrmap->queue, entries) {
			if (!mailaddr_match(maddr, &mn->mailaddr))
				continue;
			found = 1;
			break;
		}
		maddrmap_free(lk.maddrmap);
		if (found)
			return (LKA_OK);
		return (LKA_PERMFAIL);
	}
	return (LKA_OK);
}

static int
lka_X509_verify(struct ca_vrfy_req_msg *vrfy,
    const char *CAfile, const char *CRLfile)
{
	X509			*x509;
	X509			*x509_tmp;
	STACK_OF(X509)		*x509_chain;
	const unsigned char    	*d2i;
	size_t			i;
	int			ret = 0;
	const char		*errstr;

	x509 = NULL;
	x509_tmp = NULL;
	x509_chain = NULL;

	d2i = vrfy->cert;
	if (d2i_X509(&x509, &d2i, vrfy->cert_len) == NULL) {
		x509 = NULL;
		goto end;
	}

	if (vrfy->n_chain) {
		x509_chain = sk_X509_new_null();
		for (i = 0; i < vrfy->n_chain; ++i) {
			d2i = vrfy->chain_cert[i];
			if (d2i_X509(&x509_tmp, &d2i, vrfy->chain_cert_len[i]) == NULL)
				goto end;
			sk_X509_insert(x509_chain, x509_tmp, i);
			x509_tmp = NULL;
		}
	}
	if (!ca_X509_verify(x509, x509_chain, CAfile, NULL, &errstr))
		log_debug("debug: lka: X509 verify: %s", errstr);
	else
		ret = 1;

end:
	X509_free(x509);
	X509_free(x509_tmp);
	if (x509_chain)
		sk_X509_pop_free(x509_chain, X509_free);

	return ret;
}

static void
lka_certificate_verify(enum imsg_type type, struct ca_vrfy_req_msg *req)
{
	lka_certificate_verify_resume(type, req);
}

static void
lka_certificate_verify_resume(enum imsg_type type, struct ca_vrfy_req_msg *req)
{
	struct ca_vrfy_resp_msg		resp;
	struct ca		       *sca;
	const char		       *cafile;
	size_t				i;

	resp.reqid = req->reqid;
	sca = dict_get(env->sc_ca_dict, req->name);
	if (sca == NULL)
		if (req->fallback)
			sca = dict_get(env->sc_ca_dict, "*");
	cafile = sca ? sca->ca_cert_file : CA_FILE;

	if (sca == NULL && !req->fallback)
		resp.status = CA_FAIL;
	else if (!lka_X509_verify(req, cafile, NULL))
		resp.status = CA_FAIL;
	else
		resp.status = CA_OK;

	m_compose(p_pony, type, 0, 0, -1, &resp,
	    sizeof resp);

	for (i = 0; i < req->n_chain; ++i)
		free(req->chain_cert[i]);
	free(req->chain_cert);
	free(req->chain_cert_len);
	free(req->cert);
	free(req);
}
@


1.198
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.197 2016/09/08 12:06:43 eric Exp $	*/
d660 2
a661 4
	if (x509)
		X509_free(x509);
	if (x509_tmp)
		X509_free(x509_tmp);
@


1.197
log
@Streamline the daemon shutdown sequence.

Only the parent process handles SIGTERM and SIGINT.  Upon receiving one
of those, it closes all imsg sockets and waitpid() for the children. It
fatal()s if one of the sockets is closed unexpectedly.  Other processes
exit() "normally" when one of the imsg sockets is closed.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.196 2016/09/04 16:10:31 eric Exp $	*/
d324 1
a324 1
			if (verbose & TRACE_TABLES)
d357 1
a357 1
			log_verbose(v);
@


1.196
log
@The smtpd processes are not expected to ever leave their event loop.
So stop pretending that the *_shutdown() functions could ever be called
in this context, and just fatal() if event_dispatch() returns.

ok gilles@@ sunil@@ giovanni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.195 2016/09/03 15:54:14 gilles Exp $	*/
d86 3
a388 4
	case SIGINT:
	case SIGTERM:
		lka_shutdown();
		break;
d402 1
a402 1
	log_info("info: lookup agent exiting");
a409 2
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
a426 2
	signal_set(&ev_sigint, SIGINT, lka_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, lka_sig_handler, NULL);
a427 2
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
d429 2
@


1.195
log
@in lka specifically, use initgroups() so that users may share files between
smtpd and another daemon by adding supplementary groups

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.194 2016/09/01 10:54:25 eric Exp $	*/
d451 2
a452 3
	if (event_dispatch() < 0)
		fatal("event_dispatch");
	lka_shutdown();
@


1.194
log
@remove noop function

ok sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.193 2016/05/28 21:21:20 eric Exp $	*/
d422 1
a422 1
	if (setgroups(1, &pw->pw_gid) ||
@


1.193
log
@Implement the fork+exec pattern in smtpd.

The parent process forks child processes and re-exec each of them with
an additional "-x <proc>" argument.  During the early setup phase, the
parent process sends ipc socket pairs to interconnect the child
processes as needed, and it passes the queue encryption key to the
queue if necessary. When this is done, all processes have their
environment set as in the fork-only case, and they can start doing
their work as before.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.192 2016/01/22 13:10:41 gilles Exp $	*/
a442 1
	config_done();
@


1.192
log
@in lka process, revoke proc/exec pledges after privsep-ed table backends
are forked at startup

i thought i had committed this already, diff has been okayed several weeks
ago...

ok jung@@, ok millert@@, ok sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.191 2016/01/04 13:36:32 jung Exp $	*/
d407 1
a407 1
pid_t
a409 1
	pid_t		 pid;
a413 10

	switch (pid = fork()) {
	case -1:
		fatal("lka: cannot fork");
	case 0:
		post_fork(PROC_LKA);
		break;
	default:
		return (pid);
	}
@


1.191
log
@add proc and exec to pledge in lka, required to run external add-ons outside of
the daemon memory space, makes -extras tables work again

reported by Tim van der Molen on misc@@opensmtpd.org

verified together with sunil

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.190 2015/12/28 22:08:30 jung Exp $	*/
d323 2
d327 5
d459 1
@


1.190
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.189 2015/12/14 10:22:12 jung Exp $	*/
d452 1
a452 1
	if (pledge("stdio rpath inet dns getpw recvfd", NULL) == -1)
@


1.189
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.188 2015/12/12 20:02:31 gilles Exp $	*/
d619 1
a619 1
			if (! mailaddr_match(maddr, &mn->mailaddr))
d664 1
a664 1
	if (! ca_X509_verify(x509, x509_chain, CAfile, NULL, &errstr))
d703 1
a703 1
	else if (! lka_X509_verify(req, cafile, NULL))
@


1.188
log
@remove CA from pki and no longer allow specifying a CA with 'pki' keyword.
introduce 'ca' keyword to allow specifying a custom CA.
making CA part of pki was a bad idea and several people hit use-cases that
plain couldn't work.

instead of:
    pki foobar.org ca "/etc/mail/CA.pem"

use now:
    ca foobar.org certificate "/etc/mail/CA.pem"


ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.187 2015/12/12 14:06:08 gilles Exp $	*/
d528 1
a528 1
		
d669 1
a669 1
end:	
@


1.187
log
@if no certificate matches name AND fallback hint was given, search for a
global certificate
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.186 2015/12/12 13:56:41 gilles Exp $	*/
d158 1
d690 1
a690 1
	struct pki		       *pki;
d695 9
a703 5
	pki = dict_get(env->sc_pki_dict, req->name);
	cafile = CA_FILE;
	if (pki && pki->pki_ca_file)
		cafile = pki->pki_ca_file;
	if (! lka_X509_verify(req, cafile, NULL))
@


1.186
log
@remove empty line
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.185 2015/12/12 13:48:50 gilles Exp $	*/
d147 3
@


1.185
log
@move the cert verify code to its own function outside the imsg handling
code, no functional change but this makes code easier to read, and will
ease implementing DANE later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.184 2015/12/12 13:25:18 gilles Exp $	*/
a242 1

@


1.184
log
@smtp / mta have been factored in the same process months ago, factor the
code that handles the same imsg's too

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.183 2015/12/12 11:31:28 sunil Exp $	*/
a71 1
	struct ca_vrfy_resp_msg		resp_ca_vrfy;
a83 1
	size_t			 i;
a84 1
	const char	        *cafile = NULL;
d188 1
a188 20

			resp_ca_vrfy.reqid = req_ca_vrfy->reqid;
			pki = dict_get(env->sc_pki_dict, req_ca_vrfy->name);
			cafile = CA_FILE;
			if (pki && pki->pki_ca_file)
				cafile = pki->pki_ca_file;
			if (! lka_X509_verify(req_ca_vrfy, cafile, NULL))
				resp_ca_vrfy.status = CA_FAIL;
			else
				resp_ca_vrfy.status = CA_OK;

			m_compose(p, imsg->hdr.type, 0, 0, -1, &resp_ca_vrfy,
			    sizeof resp_ca_vrfy);

			for (i = 0; i < req_ca_vrfy->n_chain; ++i)
				free(req_ca_vrfy->chain_cert[i]);
			free(req_ca_vrfy->chain_cert);
			free(req_ca_vrfy->chain_cert_len);
			free(req_ca_vrfy->cert);
			free(req_ca_vrfy);
d680 1
d686 24
@


1.183
log
@Implement senders map.

senders table allows to restrict the addresses that an authenticated
user can use in the SMTP dialogue.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.182 2015/12/12 10:55:21 gilles Exp $	*/
d70 1
a70 2
	static struct ca_vrfy_req_msg	*req_ca_vrfy_smtp = NULL;
	static struct ca_vrfy_req_msg	*req_ca_vrfy_mta = NULL;
d143 1
d152 1
a152 1
				m_compose(p, IMSG_SMTP_TLS_INIT, 0, 0, -1, &resp_ca_cert,
d162 1
a162 1
			m_composev(p, IMSG_SMTP_TLS_INIT, 0, 0, -1, iov, nitems(iov));
d166 5
a170 4
			req_ca_vrfy_smtp = xmemdup(imsg->data, sizeof *req_ca_vrfy_smtp, "lka:ca_vrfy");
			req_ca_vrfy_smtp->cert = xmemdup((char *)imsg->data +
			    sizeof *req_ca_vrfy_smtp, req_ca_vrfy_smtp->cert_len, "lka:ca_vrfy");
			req_ca_vrfy_smtp->chain_cert = xcalloc(req_ca_vrfy_smtp->n_chain,
d172 1
a172 1
			req_ca_vrfy_smtp->chain_cert_len = xcalloc(req_ca_vrfy_smtp->n_chain,
d177 2
a178 1
			if (req_ca_vrfy_smtp == NULL)
d181 1
a181 1
			req_ca_vrfy_smtp->chain_cert[req_ca_vrfy_smtp->chain_offset] = xmemdup((char *)imsg->data +
d183 2
a184 2
			req_ca_vrfy_smtp->chain_cert_len[req_ca_vrfy_smtp->chain_offset] = req_ca_vrfy_chain->cert_len;
			req_ca_vrfy_smtp->chain_offset++;
d188 2
a189 1
			if (req_ca_vrfy_smtp == NULL)
d192 2
a193 2
			resp_ca_vrfy.reqid = req_ca_vrfy_smtp->reqid;
			pki = dict_xget(env->sc_pki_dict, req_ca_vrfy_smtp->name);
d195 1
a195 1
			if (pki->pki_ca_file)
d197 1
a197 1
			if (! lka_X509_verify(req_ca_vrfy_smtp, cafile, NULL))
d202 1
a202 1
			m_compose(p, IMSG_SMTP_TLS_VERIFY, 0, 0, -1, &resp_ca_vrfy,
d205 7
a211 7
			for (i = 0; i < req_ca_vrfy_smtp->n_chain; ++i)
				free(req_ca_vrfy_smtp->chain_cert[i]);
			free(req_ca_vrfy_smtp->chain_cert);
			free(req_ca_vrfy_smtp->chain_cert_len);
			free(req_ca_vrfy_smtp->cert);
			free(req_ca_vrfy_smtp);
			req_ca_vrfy_smtp = NULL;
a265 69
		case IMSG_MTA_TLS_INIT:
			req_ca_cert = imsg->data;
			resp_ca_cert.reqid = req_ca_cert->reqid;

			xlowercase(buf, req_ca_cert->name, sizeof(buf));
			log_debug("debug: lka: looking up pki \"%s\"", buf);
			pki = dict_get(env->sc_pki_dict, buf);
			if (pki == NULL) {
				resp_ca_cert.status = CA_FAIL;
				m_compose(p, IMSG_MTA_TLS_INIT, 0, 0, -1, &resp_ca_cert,
				    sizeof(resp_ca_cert));
				return;
			}
			resp_ca_cert.status = CA_OK;
			resp_ca_cert.cert_len = pki->pki_cert_len;
			iov[0].iov_base = &resp_ca_cert;
			iov[0].iov_len = sizeof(resp_ca_cert);
			iov[1].iov_base = pki->pki_cert;
			iov[1].iov_len = pki->pki_cert_len;
			m_composev(p, IMSG_MTA_TLS_INIT, 0, 0, -1, iov, nitems(iov));
			return;

		case IMSG_MTA_TLS_VERIFY_CERT:
			req_ca_vrfy_mta = xmemdup(imsg->data, sizeof *req_ca_vrfy_mta, "lka:ca_vrfy");
			req_ca_vrfy_mta->cert = xmemdup((char *)imsg->data +
			    sizeof *req_ca_vrfy_mta, req_ca_vrfy_mta->cert_len, "lka:ca_vrfy");
			req_ca_vrfy_mta->chain_cert = xcalloc(req_ca_vrfy_mta->n_chain,
			    sizeof (unsigned char *), "lka:ca_vrfy");
			req_ca_vrfy_mta->chain_cert_len = xcalloc(req_ca_vrfy_mta->n_chain,
			    sizeof (off_t), "lka:ca_vrfy");
			return;

		case IMSG_MTA_TLS_VERIFY_CHAIN:
			if (req_ca_vrfy_mta == NULL)
				fatalx("lka:ca_vrfy: verify without a certificate");

			req_ca_vrfy_chain = imsg->data;
			req_ca_vrfy_mta->chain_cert[req_ca_vrfy_mta->chain_offset] = xmemdup((char *)imsg->data +
			    sizeof *req_ca_vrfy_chain, req_ca_vrfy_chain->cert_len, "lka:ca_vrfy");
			req_ca_vrfy_mta->chain_cert_len[req_ca_vrfy_mta->chain_offset] = req_ca_vrfy_chain->cert_len;
			req_ca_vrfy_mta->chain_offset++;
			return;

		case IMSG_MTA_TLS_VERIFY:
			if (req_ca_vrfy_mta == NULL)
				fatalx("lka:ca_vrfy: verify without a certificate");

			resp_ca_vrfy.reqid = req_ca_vrfy_mta->reqid;
			pki = dict_get(env->sc_pki_dict, req_ca_vrfy_mta->name);

			cafile = CA_FILE;
			if (pki && pki->pki_ca_file)
				cafile = pki->pki_ca_file;
			if (! lka_X509_verify(req_ca_vrfy_mta, cafile, NULL))
				resp_ca_vrfy.status = CA_FAIL;
			else
				resp_ca_vrfy.status = CA_OK;

			m_compose(p, IMSG_MTA_TLS_VERIFY, 0, 0, -1, &resp_ca_vrfy,
			    sizeof resp_ca_vrfy);

			for (i = 0; i < req_ca_vrfy_mta->n_chain; ++i)
				free(req_ca_vrfy_mta->chain_cert[i]);
			free(req_ca_vrfy_mta->chain_cert);
			free(req_ca_vrfy_mta->chain_cert_len);
			free(req_ca_vrfy_mta->cert);
			free(req_ca_vrfy_mta);
			req_ca_vrfy_mta = NULL;
			return;
@


1.182
log
@prepare for asynchronous certificate verify, needed for a mechanical
cleanup and later on for DANE support
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.181 2015/12/11 21:44:00 gilles Exp $	*/
d80 1
d101 16
@


1.181
log
@rename field member + whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.180 2015/11/30 14:05:34 gilles Exp $	*/
d60 2
d746 10
@


1.180
log
@bring lka_mailaddrmap(), currently unused, required by sendermap/masquerade

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.179 2015/11/30 12:49:35 gilles Exp $	*/
d171 1
a171 1
			pki = dict_xget(env->sc_pki_dict, req_ca_vrfy_smtp->pkiname);
d292 1
a292 1
			pki = dict_get(env->sc_pki_dict, req_ca_vrfy_mta->pkiname);
@


1.179
log
@mechanical rename of some IMSG constants

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.178 2015/10/14 22:01:43 gilles Exp $	*/
d58 1
d658 38
@


1.178
log
@whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.177 2015/10/14 19:39:16 gilles Exp $	*/
d123 1
a123 1
		case IMSG_SMTP_SSL_INIT:
d132 1
a132 1
				m_compose(p, IMSG_SMTP_SSL_INIT, 0, 0, -1, &resp_ca_cert,
d142 1
a142 1
			m_composev(p, IMSG_SMTP_SSL_INIT, 0, 0, -1, iov, nitems(iov));
d145 1
a145 1
		case IMSG_SMTP_SSL_VERIFY_CERT:
d155 1
a155 1
		case IMSG_SMTP_SSL_VERIFY_CHAIN:
d165 1
a165 1
		case IMSG_SMTP_SSL_VERIFY:
d179 1
a179 1
			m_compose(p, IMSG_SMTP_SSL_VERIFY, 0, 0, -1, &resp_ca_vrfy,
d243 1
a243 1
		case IMSG_MTA_SSL_INIT:
d252 1
a252 1
				m_compose(p, IMSG_MTA_SSL_INIT, 0, 0, -1, &resp_ca_cert,
d262 1
a262 1
			m_composev(p, IMSG_MTA_SSL_INIT, 0, 0, -1, iov, nitems(iov));
d265 1
a265 1
		case IMSG_MTA_SSL_VERIFY_CERT:
d275 1
a275 1
		case IMSG_MTA_SSL_VERIFY_CHAIN:
d286 1
a286 1
		case IMSG_MTA_SSL_VERIFY:
d301 1
a301 1
			m_compose(p, IMSG_MTA_SSL_VERIFY, 0, 0, -1, &resp_ca_vrfy,
@


1.177
log
@pledge() pony and lookup

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.176 2015/10/02 00:28:30 gilles Exp $	*/
d657 1
a657 1
}      
@


1.176
log
@reset static pointer to NULL after we free it, just in case another bug
leads us to reuse it.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.175 2015/01/20 17:37:54 deraadt Exp $	*/
d516 3
@


1.175
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.174 2015/01/16 06:40:20 deraadt Exp $	*/
d188 1
d310 1
@


1.175.2.1
log
@Errata 017:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.175 2015/01/20 17:37:54 deraadt Exp $	*/
a187 1
			req_ca_vrfy_smtp = NULL;
a308 1
			req_ca_vrfy_mta = NULL;
@


1.175.6.1
log
@Errata 004:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.175 2015/01/20 17:37:54 deraadt Exp $	*/
a187 1
			req_ca_vrfy_smtp = NULL;
a308 1
			req_ca_vrfy_mta = NULL;
@


1.174
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.173 2014/09/03 07:42:47 giovanni Exp $	*/
d79 1
a79 1
	char			 buf[SMTPD_MAXLINESIZE];
@


1.173
log
@
if crypt(3) fails return an authentication error
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.172 2014/07/10 15:54:55 eric Exp $	*/
d39 1
@


1.172
log
@make the control process broadcast verbose/profile admin requests directly,
rather than going through the parent process. simplify code in the meantime.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d525 1
d544 4
a547 1
		if (!strcmp(lk.creds.password, crypt(password, lk.creds.password)))
@


1.172.4.1
log
@Errata 031:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.172 2014/07/10 15:54:55 eric Exp $	*/
a186 1
			req_ca_vrfy_smtp = NULL;
a307 1
			req_ca_vrfy_mta = NULL;
@


1.171
log
@Update the table API: lookup functions can take an optional parameters
dictionnary (currently not set). While there, add a helper for forking
external backends, and remove unused table functions.

ok gilles@@
@
text
@d391 14
a418 13
		case IMSG_LKA_OPEN_FORWARD:
			lka_session_forward_reply(imsg->data, imsg->fd);
			return;

		case IMSG_LKA_AUTHENTICATE:
			imsg->hdr.type = IMSG_SMTP_AUTHENTICATE;
			m_forward(p_pony, imsg);
			return;
		}
	}

	if (p->proc == PROC_CONTROL) {
		switch (imsg->hdr.type) {
@


1.170
log
@when we reduced the number of iovec's we passed through an imsg, the iovec
declaration was not bumped down causing us to pass extra junk leading to a
crash in the pki lookup code. i'm amazed no one else crashed on that :-/

reported by Olivier Antoine who kindly provided access to his box
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.169 2014/05/01 15:50:20 reyk Exp $	*/
d342 1
a342 1
				ret = table_fetch(table, K_SOURCE, &lk);
d534 1
a534 1
	switch (table_lookup(table, user, K_CREDENTIALS, &lk)) {
d564 1
a564 1
	switch(table_lookup(table, label, K_CREDENTIALS, &lk)) {
d605 1
a605 1
	switch (table_lookup(table, username, K_USERINFO, &lk)) {
d635 1
a635 1
	switch (table_lookup(table, source, K_ADDRNAME, &lk)) {
@


1.169
log
@Move RSA keys from "lka" to a new dedicated "ca" process because lka
is handling some async requests and shouldn't be busy with sync RSA.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.168 2014/04/29 19:13:13 reyk Exp $	*/
d65 1
a65 1
	struct iovec		iov[3];
@


1.168
log
@Implement RSA privilege separation for OpenSMTPD, based on my previous
implementation for relayd(8).  The smtpd(8) pony processes (mta
client, smtp server) don't keep the private keys in memory but send
their private key operations as imsgs to the "lookup"/mta process.
It's worth mentioning that this prevents acidental private key leakage
as it could have been caused by "Heartbleed".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.167 2014/04/15 08:32:45 eric Exp $	*/
a93 6
	if (imsg->hdr.type == IMSG_CA_PRIVENC ||
	    imsg->hdr.type == IMSG_CA_PRIVDEC) {
		ca_imsg(p, imsg);
		return;
	}

a385 1
			ca_init();
@


1.167
log
@reply with correct imsg when using non-system auth.

reported by Stefan Sieg

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.166 2014/04/09 15:23:49 eric Exp $	*/
d94 6
a142 1
			resp_ca_cert.key_len = pki->pki_key_len;
a146 2
			iov[2].iov_base = pki->pki_key;
			iov[2].iov_len = pki->pki_key_len;
a261 1
			resp_ca_cert.key_len = pki->pki_key_len;
a265 2
			iov[2].iov_base = pki->pki_key;
			iov[2].iov_len = pki->pki_key_len;
d392 1
@


1.166
log
@need to change imsg type before forwarding.

reported by jturner@@
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.165 2014/04/04 16:10:42 eric Exp $	*/
d212 1
a212 1
			m_create(p, IMSG_LKA_AUTHENTICATE, 0, 0, -1);
@


1.165
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d416 1
@


1.164
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d85 5
a89 4
	if (imsg->hdr.type == IMSG_DNS_HOST ||
	    imsg->hdr.type == IMSG_DNS_PTR ||
	    imsg->hdr.type == IMSG_DNS_MX ||
	    imsg->hdr.type == IMSG_DNS_MX_PREFERENCE) {
d94 1
a94 1
	if (p->proc == PROC_SMTP) {
d96 1
a96 1
		case IMSG_LKA_EXPAND_RCPT:
d104 1
a104 1
		case IMSG_LKA_HELO:
d114 1
a114 1
			m_create(p, IMSG_LKA_HELO, 0, 0, -1);
d122 1
a122 1
		case IMSG_LKA_SSL_INIT:
d131 1
a131 1
				m_compose(p, IMSG_LKA_SSL_INIT, 0, 0, -1, &resp_ca_cert,
d144 1
a144 1
			m_composev(p, IMSG_LKA_SSL_INIT, 0, 0, -1, iov, nitems(iov));
d147 1
a147 1
		case IMSG_LKA_SSL_VERIFY_CERT:
d157 1
a157 1
		case IMSG_LKA_SSL_VERIFY_CHAIN:
d167 1
a167 1
		case IMSG_LKA_SSL_VERIFY:
d181 1
a181 1
			m_compose(p, IMSG_LKA_SSL_VERIFY, 0, 0, -1, &resp_ca_vrfy,
d192 1
a192 1
		case IMSG_LKA_AUTHENTICATE:
d220 1
a220 1
	if (p->proc == PROC_MDA) {
d222 1
a222 1
		case IMSG_LKA_USERINFO:
d231 1
a231 1
			m_create(p, IMSG_LKA_USERINFO, 0, 0, -1);
d241 1
a241 1
	if (p->proc == PROC_MTA) {
d244 1
a244 1
		case IMSG_LKA_SSL_INIT:
d253 1
a253 1
				m_compose(p, IMSG_LKA_SSL_INIT, 0, 0, -1, &resp_ca_cert,
d266 1
a266 1
			m_composev(p, IMSG_LKA_SSL_INIT, 0, 0, -1, iov, nitems(iov));
d269 1
a269 1
		case IMSG_LKA_SSL_VERIFY_CERT:
d279 1
a279 1
		case IMSG_LKA_SSL_VERIFY_CHAIN:
d290 1
a290 1
		case IMSG_LKA_SSL_VERIFY:
d305 1
a305 1
			m_compose(p, IMSG_LKA_SSL_VERIFY, 0, 0, -1, &resp_ca_vrfy,
d316 1
a316 1
		case IMSG_LKA_SECRET:
d325 1
a325 1
			m_create(p, IMSG_LKA_SECRET, 0, 0, -1);
d331 1
a331 1
		case IMSG_LKA_SOURCE:
d339 1
a339 1
			m_create(p, IMSG_LKA_SOURCE, 0, 0, -1);
d362 1
a362 1
		case IMSG_LKA_HELO:
d372 1
a372 1
			m_create(p, IMSG_LKA_HELO, 0, 0, -1);
d394 1
a394 3
			mproc_enable(p_mda);
			mproc_enable(p_mta);
			mproc_enable(p_smtp);
d411 1
a411 1
		case IMSG_PARENT_FORWARD_OPEN:
d416 1
a416 1
			m_forward(p_smtp, imsg);
d423 1
a423 1
		case IMSG_LKA_UPDATE_TABLE:
a510 3
	config_peer(PROC_SMTP);
	config_peer(PROC_MDA);
	config_peer(PROC_MTA);
d512 1
d516 1
a516 3
	mproc_disable(p_mda);
	mproc_disable(p_mta);
	mproc_disable(p_smtp);
@


1.163
log
@add base64_encode/base64_decode helpers
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.162 2014/02/04 09:05:06 eric Exp $	*/
a61 1
	struct rule		*rule;
a62 1
	void			*tmp;
d64 1
a64 2
	const char		*key, *val;
	struct ssl		*ssl;
a65 3
	static struct dict	*ssl_dict;
	static struct dict	*tables_dict;
	static struct table	*table_last;
d127 2
a128 2
			ssl = dict_get(env->sc_ssl_dict, buf);
			if (ssl == NULL) {
d135 2
a136 2
			resp_ca_cert.cert_len = ssl->ssl_cert_len;
			resp_ca_cert.key_len = ssl->ssl_key_len;
d139 4
a142 4
			iov[1].iov_base = ssl->ssl_cert;
			iov[1].iov_len = ssl->ssl_cert_len;
			iov[2].iov_base = ssl->ssl_key;
			iov[2].iov_len = ssl->ssl_key_len;
a147 2
			if (req_ca_vrfy_smtp == NULL)
				fatal(NULL);
d171 1
a171 1
			ssl = dict_xget(env->sc_ssl_dict, req_ca_vrfy_smtp->pkiname);
d173 2
a174 2
			if (ssl->ssl_ca_file)
				cafile = ssl->ssl_ca_file;
d249 2
a250 2
			ssl = dict_get(env->sc_ssl_dict, buf);
			if (ssl == NULL) {
d257 2
a258 2
			resp_ca_cert.cert_len = ssl->ssl_cert_len;
			resp_ca_cert.key_len = ssl->ssl_key_len;
d261 4
a264 4
			iov[1].iov_base = ssl->ssl_cert;
			iov[1].iov_len = ssl->ssl_cert_len;
			iov[2].iov_base = ssl->ssl_key;
			iov[2].iov_len = ssl->ssl_key_len;
a269 2
			if (req_ca_vrfy_mta == NULL)
				fatal(NULL);
d294 1
a294 1
			ssl = dict_get(env->sc_ssl_dict, req_ca_vrfy_mta->pkiname);
d297 2
a298 2
			if (ssl && ssl->ssl_ca_file)
				cafile = ssl->ssl_ca_file;
a384 122
			env->sc_rules_reload = xcalloc(1,
			    sizeof *env->sc_rules, "lka:sc_rules_reload");
			tables_dict = xcalloc(1,
			    sizeof *tables_dict, "lka:tables_dict");

			ssl_dict = calloc(1, sizeof *ssl_dict);
			if (ssl_dict == NULL)
				fatal(NULL);
			dict_init(ssl_dict);
			dict_init(tables_dict);
			TAILQ_INIT(env->sc_rules_reload);

			return;

		case IMSG_CONF_SSL:
			ssl = calloc(1, sizeof *ssl);
			if (ssl == NULL)
				fatal(NULL);
			*ssl = *(struct ssl *)imsg->data;
			ssl->ssl_cert = xstrdup((char *)imsg->data +
			    sizeof *ssl, "smtp:ssl_cert");
			ssl->ssl_key = xstrdup((char *)imsg->data +
			    sizeof *ssl + ssl->ssl_cert_len, "smtp:ssl_key");
			if (ssl->ssl_dhparams_len) {
				ssl->ssl_dhparams = xstrdup((char *)imsg->data
				    + sizeof *ssl + ssl->ssl_cert_len +
				    ssl->ssl_key_len, "smtp:ssl_dhparams");
			}
			if (ssl->ssl_ca_len) {
				ssl->ssl_ca = xstrdup((char *)imsg->data
				    + sizeof *ssl + ssl->ssl_cert_len +
				    ssl->ssl_key_len + ssl->ssl_dhparams_len,
				    "smtp:ssl_ca");
			}
			dict_set(ssl_dict, ssl->ssl_name, ssl);
			return;

		case IMSG_CONF_RULE:
			rule = xmemdup(imsg->data, sizeof *rule, "lka:rule");
			TAILQ_INSERT_TAIL(env->sc_rules_reload, rule, r_entry);
			return;

		case IMSG_CONF_TABLE:
			table_last = table = xmemdup(imsg->data, sizeof *table,
			    "lka:table");
			dict_init(&table->t_dict);
			dict_set(tables_dict, table->t_name, table);
			return;

		case IMSG_CONF_RULE_SOURCE:
			rule = TAILQ_LAST(env->sc_rules_reload, rulelist);
			tmp = env->sc_tables_dict;
			env->sc_tables_dict = tables_dict;
			rule->r_sources = table_find(imsg->data, NULL);
			if (rule->r_sources == NULL)
				fatalx("lka: tables inconsistency");
			env->sc_tables_dict = tmp;
			return;

		case IMSG_CONF_RULE_SENDER:
			rule = TAILQ_LAST(env->sc_rules_reload, rulelist);
			tmp = env->sc_tables_dict;
			env->sc_tables_dict = tables_dict;
			rule->r_senders = table_find(imsg->data, NULL);
			if (rule->r_senders == NULL)
				fatalx("lka: tables inconsistency");
			env->sc_tables_dict = tmp;
			return;

		case IMSG_CONF_RULE_RECIPIENT:
			rule = TAILQ_LAST(env->sc_rules_reload, rulelist);
			tmp = env->sc_tables_dict;
			env->sc_tables_dict = tables_dict;
			rule->r_recipients = table_find(imsg->data, NULL);
			if (rule->r_recipients == NULL)
				fatalx("lka: tables inconsistency");
			env->sc_tables_dict = tmp;
			return;

		case IMSG_CONF_RULE_DESTINATION:
			rule = TAILQ_LAST(env->sc_rules_reload, rulelist);
			tmp = env->sc_tables_dict;
			env->sc_tables_dict = tables_dict;
			rule->r_destination = table_find(imsg->data, NULL);
			if (rule->r_destination == NULL)
				fatalx("lka: tables inconsistency");
			env->sc_tables_dict = tmp;
			return;

		case IMSG_CONF_RULE_MAPPING:
			rule = TAILQ_LAST(env->sc_rules_reload, rulelist);
			tmp = env->sc_tables_dict;
			env->sc_tables_dict = tables_dict;
			rule->r_mapping = table_find(imsg->data, NULL);
			if (rule->r_mapping == NULL)
				fatalx("lka: tables inconsistency");
			env->sc_tables_dict = tmp;
			return;

		case IMSG_CONF_RULE_USERS:
			rule = TAILQ_LAST(env->sc_rules_reload, rulelist);
			tmp = env->sc_tables_dict;
			env->sc_tables_dict = tables_dict;
			rule->r_userbase = table_find(imsg->data, NULL);
			if (rule->r_userbase == NULL)
				fatalx("lka: tables inconsistency");
			env->sc_tables_dict = tmp;
			return;

		case IMSG_CONF_TABLE_CONTENT:
			table = table_last;
			if (table == NULL)
				fatalx("lka: tables inconsistency");

			key = imsg->data;
			if (table->t_type == T_HASH)
				val = key + strlen(key) + 1;
			else
				val = NULL;

			dict_set(&table->t_dict, key,
			    val ? xstrdup(val, "lka:dict_set") : NULL);
a387 10

			if (env->sc_rules)
				purge_config(PURGE_RULES);
			if (env->sc_tables_dict) {
				table_close_all();
				purge_config(PURGE_TABLES);
			}
			env->sc_rules = env->sc_rules_reload;
			env->sc_ssl_dict = ssl_dict;
			env->sc_tables_dict = tables_dict;
a391 4
			ssl_dict = NULL;
			table_last = NULL;
			tables_dict = NULL;

d486 1
a486 1
	purge_config(PURGE_EVERYTHING);
@


1.162
log
@get rid of fdlimit()
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.161 2013/11/20 09:22:42 eric Exp $	*/
d736 1
a736 1
		r = __b64_ntop((unsigned char *)buf, buflen, dst, sz);
@


1.161
log
@Rework the mda and scheduler to use the holdq mechanism instead of
tempfail for limiting the number of pending deliveries to the same
user.  This allows to reach optimal delivery time even in case of
burst, while keeping the number of inflight envelopes low.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a654 6

	/*
	 * lka opens all kinds of files and sockets, so bump the limit to max.
	 * XXX: need to analyse the exact hard limit.
	 */
	fdlimit(1.0);
@


1.160
log
@Allow overriding the local ca
@
text
@d231 1
d239 1
a239 2
			m_add_string(p, tablename);
			m_add_string(p, username);
@


1.159
log
@Fix case-folding issue with pki names. They are case-insensitive.
Make sure a pki entry exists when used in a listen or relay rule.
@
text
@d89 1
d179 5
a183 2

			if (! lka_X509_verify(req_ca_vrfy_smtp, CA_FILE, NULL))
d304 1
d306 4
a309 1
			if (! lka_X509_verify(req_ca_vrfy_mta, CA_FILE, NULL))
@


1.158
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d130 3
a132 1
			ssl = dict_get(env->sc_ssl_dict, req_ca_cert->name);
d251 3
a253 1
			ssl = dict_get(env->sc_ssl_dict, req_ca_cert->name);
@


1.157
log
@Report the ssl certificate verification status in the mail header.
Log ssl certificate validation errors.
Fix several ssl-related leaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.156 2013/10/27 19:12:12 eric Exp $	*/
d108 18
d448 10
@


1.156
log
@missing m_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.155 2013/10/27 07:56:25 eric Exp $	*/
a775 1
	X509			*x509_tmp2;
d796 1
a796 2
			if (d2i_X509(&x509_tmp, &d2i, vrfy->chain_cert_len[i]) == NULL) {
				x509_tmp = NULL;
d798 2
a799 6
			}

			if ((x509_tmp2 = X509_dup(x509_tmp)) == NULL)
				goto end;
			sk_X509_insert(x509_chain, x509_tmp2, i);
			x509_tmp = x509_tmp2 = NULL;
@


1.155
log
@Create the control socket in the parent process to abort early if
another smtpd instance is running.  Close the inherited socket in
every forked process but control.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.154 2013/07/19 11:14:08 eric Exp $	*/
d314 1
@


1.154
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.153 2013/07/19 07:49:08 eric Exp $	*/
d585 1
@


1.153
log
@Remove useless sc_pid from struct smtpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.152 2013/05/24 17:03:14 eric Exp $	*/
d592 2
a593 1
	pw = env->sc_pw;
@


1.152
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.150 2013/02/14 12:30:49 gilles Exp $	*/
a584 1
		env->sc_pid = getpid();
@


1.151
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@a23 1
#include <sys/param.h>
a66 1
	char			*src;
a70 1
	static struct tree	*tables_tree;
a78 1
	struct addrinfo		 hints, *ai;
d83 1
d87 1
a87 1
	size_t			 i, len;
d159 1
a159 1
			if (! lka_X509_verify(req_ca_vrfy_smtp, "/etc/ssl/cert.pem", NULL))
d185 1
a185 1
				    0, 0, -1, 128);
d195 1
a195 1
			m_create(p, IMSG_LKA_AUTHENTICATE, 0, 0, -1, 128);
d213 1
a213 4
			len = 32 + strlen(tablename) + strlen(username);
			if (ret == LKA_OK)
				len += sizeof(userinfo);
			m_create(p, IMSG_LKA_USERINFO, 0, 0, -1, len);
d279 1
a279 1
			if (! lka_X509_verify(req_ca_vrfy_mta, "/etc/ssl/cert.pem", NULL))
d304 1
a304 1
			m_create(p, IMSG_LKA_SECRET, 0, 0, -1, 128);
d315 1
a315 1
			table = table_findbyname(tablename);
d317 1
a317 1
			m_create(p, IMSG_LKA_SOURCE, 0, 0, -1, 64);
d324 1
a324 1
			} 
d326 1
a326 1
				ret = table_fetch(table, K_SOURCE, &src);
d332 3
a334 11
					/* XXX find a nicer way? */
					bzero(&hints, sizeof hints);
					hints.ai_flags = AI_NUMERICHOST;
					if (getaddrinfo(src, NULL, &hints, &ai) != 0)
						m_add_int(p, LKA_TEMPFAIL);
					else {
						m_add_int(p, LKA_OK);
						m_add_sockaddr(p, ai->ai_addr);
						freeaddrinfo(ai);
					}
					free(src);
d350 1
a350 1
			m_create(p, IMSG_LKA_HELO, 0, 0, -1, 1024);
a367 2
			tables_tree = xcalloc(1,
			    sizeof *tables_tree, "lka:tables_tree");
a373 1
			tree_init(tables_tree);
a410 1
			tree_set(tables_tree, table->t_id, table);
d417 1
a417 1
			rule->r_sources = table_findbyname(imsg->data);
d427 1
a427 1
			rule->r_senders = table_findbyname(imsg->data);
d437 1
a437 1
			rule->r_destination = table_findbyname(imsg->data);
d447 1
a447 1
			rule->r_mapping = table_findbyname(imsg->data);
d457 1
a457 1
			rule->r_userbase = table_findbyname(imsg->data);
d482 1
a482 1
			if (env->sc_tables_tree) {
d489 2
a490 1
			env->sc_tables_tree = tables_tree;
a495 1
			tables_tree = NULL;
d530 1
a530 1
			table = table_findbyname(imsg->data);
d644 1
a644 2
	struct credentials	*creds;
	int			 r;
d646 2
a647 2
	log_trace(TRACE_LOOKUP, "lookup: authenticating for %s:%s", tablename, user);
	table = table_findbyname(tablename);
d654 1
a654 1
	switch (table_lookup(table, user, K_CREDENTIALS, (void **)&creds)) {
d662 1
a662 3
		r = !strcmp(creds->password, crypt(password, creds->password));
		free(creds);
		if (r)
d672 1
a672 1
	struct credentials	*creds;
d676 1
a676 1
	table = table_findbyname(tablename);
d684 1
a684 1
	switch(table_lookup(table, label, K_CREDENTIALS, (void **)&creds)) {
d695 1
a695 2
		    creds->username, '\0', creds->password)) == -1) {
			free(creds);
a698 1
		free(creds);
a714 1
	struct userinfo *info;
d716 1
d718 2
a719 2
	log_trace(TRACE_LOOKUP, "lookup: userinfo %s:%s", tablename, username);
	table = table_findbyname(tablename);
d725 1
a725 1
	switch (table_lookup(table, username, K_USERINFO, (void **)&info)) {
d733 1
a733 2
		*res = *info;
		free(info);
a741 1
	struct addrname *addrname;
d743 1
d748 2
a749 2
	log_trace(TRACE_LOOKUP, "lookup: helo %s:%s", tablename, source);
	table = table_findbyname(tablename);
d755 1
a755 1
	switch (table_lookup(table, source, K_ADDRNAME, (void **)&addrname)) {
d763 1
a763 2
		*res = *addrname;
		free(addrname);
d807 1
a807 1
		log_trace(TRACE_LOOKUP, "lookup: X509 verify: %s", errstr);
@


1.150
log
@- smtpctl trace expand, enables tracing of aliases expansion
- replace "users" keyword with "userbase" when providing alternate userbase
- disambiguise expansion nodes when expanding across domains and userbases
- allow use of '=' instead of '=>' when declaring a mapping

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.149 2013/02/05 11:45:18 gilles Exp $	*/
d87 1
a87 1
	char			 buf[MAX_LINE_SIZE];
@


1.149
log
@- handle getaddrinfo() error as LKA_TEMPFAIL
- handle getsockname() error in smtp_connected()
- accept '/' as part of user-part, expand to ':' as done by qmail
- fix wrong check in mda leading to bogus Return-Path header
- fix aliases parsing when there's a white space between key and separator
- some cosmethic cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.148 2013/01/28 11:09:53 gilles Exp $	*/
d475 2
a476 2
			rule->r_users = table_findbyname(imsg->data);
			if (rule->r_users == NULL)
@


1.148
log
@- introduce 'smtpctl trace lookup' to trace lookup process
- improve logging of the transfer process

trace by me, logging by eric
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.147 2013/01/26 09:37:23 gilles Exp $	*/
a337 2
					m_add_int(p, LKA_OK);

d341 7
a347 1
					getaddrinfo(src, NULL, &hints, &ai);
a348 3

					m_add_sockaddr(p, ai->ai_addr);
					freeaddrinfo(ai);
@


1.147
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.146 2012/11/12 14:58:53 eric Exp $	*/
d664 1
a664 2
	log_debug("debug: lka: authenticating for %s:%s", tablename, user);

d740 1
a740 2
	log_debug("debug: looking up userinfo %s:%s", tablename, username);

d771 1
a771 2
	log_debug("debug: looking up helo %s:%s", tablename, source);

d830 2
a831 3
	if (! ca_X509_verify(x509, x509_chain, CAfile, NULL, &errstr)) {
		log_debug("debug: lka_X509_verify: failure: %s", errstr);
	}
@


1.146
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.145 2012/10/14 11:58:23 gilles Exp $	*/
d5 2
a6 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d27 1
d36 2
d48 1
d50 1
a50 1
static void lka_imsg(struct imsgev *, struct imsg *);
d53 6
a58 3
static int lka_verify_mail(struct mailaddr *);
static int lka_encode_credentials(char *, size_t, struct map_credentials *);

d61 1
a61 1
lka_imsg(struct imsgev *iev, struct imsg *imsg)
a62 3
	struct submit_status	*ss;
	struct secret		*secret;
	struct mapel		*mapel;
d64 1
a64 2
	struct map		*map;
	struct map		*mp;
d66 32
a97 4

	if (imsg->hdr.type == IMSG_DNS_HOST || imsg->hdr.type == IMSG_DNS_MX ||
	    imsg->hdr.type == IMSG_DNS_PTR) {
		dns_async(iev, imsg->hdr.type, imsg->data);
d101 1
a101 1
	if (iev->proc == PROC_MFA) {
d103 61
a163 6
		case IMSG_LKA_MAIL:
			ss = imsg->data;
			ss->code = 530;
			if (ss->u.maddr.user[0] == '\0' &&
			    ss->u.maddr.domain[0] == '\0')
				ss->code = 250;
d165 32
a196 5
				if (lka_verify_mail(&ss->u.maddr))
					ss->code = 250;
			imsg_compose_event(iev, IMSG_LKA_MAIL, 0, 0, -1, ss,
			    sizeof *ss);
			return;
d198 4
a201 10
		case IMSG_LKA_RULEMATCH:
			ss = imsg->data;
			rule = ruleset_match(&ss->envelope);
			if (rule == NULL)
				ss->code = (errno == EAGAIN) ? 451 : 530;
			else
				ss->code = (rule->r_decision == R_ACCEPT) ?
				    250 : 530;
			imsg_compose_event(iev, IMSG_LKA_RULEMATCH, 0, 0, -1,
			    ss, sizeof *ss);
d203 2
d206 20
a225 2
		case IMSG_LKA_RCPT:
			lka_session(imsg->data);
d230 1
a230 1
	if (iev->proc == PROC_MTA) {
a231 2
		case IMSG_LKA_SECRET: {
			struct map_credentials *map_credentials;
d233 9
a241 7
			secret = imsg->data;
			map = map_findbyname(secret->mapname);
			if (map == NULL) {
				log_warn("warn: lka: credentials map %s is missing",
				    secret->mapname);
				imsg_compose_event(iev, IMSG_LKA_SECRET, 0, 0,
				    -1, secret, sizeof *secret);
d244 107
a350 15
			map_credentials = map_lookup(map->m_id, secret->host,
			    K_CREDENTIALS);
			log_debug("debug: lka: %s credentials lookup (%d)", secret->host,
			    map_credentials != NULL);
			secret->secret[0] = '\0';
			if (map_credentials == NULL)
				log_warnx("warn: %s credentials not found",
				    secret->host);
			else if (lka_encode_credentials(secret->secret,
				     sizeof secret->secret, map_credentials) == 0)
				log_warnx("warn: %s credentials parse fail",
				    secret->host);
			imsg_compose_event(iev, IMSG_LKA_SECRET, 0, 0, -1, secret,
			    sizeof *secret);
			free(map_credentials);
d352 19
a370 1
		}
d374 1
a374 1
	if (iev->proc == PROC_PARENT) {
d377 13
a389 4
			env->sc_rules_reload = xcalloc(1, sizeof *env->sc_rules,
			    "lka:sc_rules_reload");
			env->sc_maps_reload = xcalloc(1, sizeof *env->sc_maps,
			    "lka:sc_maps_reload");
d391 24
a414 1
			TAILQ_INIT(env->sc_maps_reload);
d422 6
a427 14
		case IMSG_CONF_MAP:
			map = xmemdup(imsg->data, sizeof *map, "lka:map");
			TAILQ_INIT(&map->m_contents);
			TAILQ_INSERT_TAIL(env->sc_maps_reload, map, m_entry);

			tmp = env->sc_maps;
			env->sc_maps = env->sc_maps_reload;

			mp = map_open(map);
			if (mp == NULL)
				errx(1, "lka: could not open map \"%s\"", map->m_name);
			map_close(map, mp);

			env->sc_maps = tmp;
d432 3
a434 3
			tmp = env->sc_maps;
			env->sc_maps = env->sc_maps_reload;
			rule->r_sources = map_findbyname(imsg->data);
d436 2
a437 2
				fatalx("lka: maps inconsistency");
			env->sc_maps = tmp;
d440 53
a492 4
		case IMSG_CONF_MAP_CONTENT:
			map = TAILQ_LAST(env->sc_maps_reload, maplist);
			mapel = xmemdup(imsg->data, sizeof *mapel, "lka:mapel");
			TAILQ_INSERT_TAIL(&map->m_contents, mapel, me_entry);
d496 1
d499 4
a502 2
			if (env->sc_maps)
				purge_config(PURGE_MAPS);
d504 15
a518 1
			env->sc_maps = env->sc_maps_reload;
d520 5
a524 4
			/* start fulfilling requests */
			event_add(&env->sc_ievs[PROC_MTA]->ev, NULL);
			event_add(&env->sc_ievs[PROC_MFA]->ev, NULL);
			event_add(&env->sc_ievs[PROC_SMTP]->ev, NULL);
d527 5
a531 2
		case IMSG_CTL_VERBOSE:
			log_verbose(*(int *)imsg->data);
d538 3
d544 1
a544 1
	if (iev->proc == PROC_CONTROL) {
d546 5
a550 5
		case IMSG_LKA_UPDATE_MAP:
			map = map_findbyname(imsg->data);
			if (map == NULL) {
				log_warnx("warn: lka: no such map \"%s\"",
				    (char *)imsg->data);
d553 1
a553 1
			map_update(map);
a593 1

a597 9
	struct peer peers[] = {
		{ PROC_PARENT,	imsg_dispatch },
		{ PROC_MFA,	imsg_dispatch },
		{ PROC_QUEUE,	imsg_dispatch },
		{ PROC_SMTP,	imsg_dispatch },
		{ PROC_MTA,	imsg_dispatch },
		{ PROC_CONTROL,	imsg_dispatch }
	};

d602 1
d612 1
a612 2
	smtpd_process = PROC_LKA;
	setproctitle("%s", env->sc_title[smtpd_process]);
a620 1
	SPLAY_INIT(&env->lka_sessions);
d637 12
a648 7
	config_pipes(peers, nitems(peers));
	config_peers(peers, nitems(peers));

	/* ignore them until we get our config */
	event_del(&env->sc_ievs[PROC_MTA]->ev);
	event_del(&env->sc_ievs[PROC_MFA]->ev);
	event_del(&env->sc_ievs[PROC_SMTP]->ev);
d658 1
a658 1
lka_verify_mail(struct mailaddr *maddr)
d660 27
a686 1
	return 1;
d690 1
a690 2
lka_encode_credentials(char *dst, size_t size,
    struct map_credentials *map_credentials)
d692 10
a701 2
	char	*buf;
	int	 buflen;
d703 1
a703 3
	if ((buflen = asprintf(&buf, "%c%s%c%s", '\0', map_credentials->username,
		    '\0', map_credentials->password)) == -1)
		fatal(NULL);
d705 19
a723 1
	if (__b64_ntop((unsigned char *)buf, buflen, dst, size) == -1) {
d725 22
a746 1
		return 0;
d749 99
a847 2
	free(buf);
	return 1;
@


1.145
log
@introduce map_file.c which will deprecate map_stdio.c

The idea is to have a file-backed map but to have smtpd(8) cache the maps
so that it cannot be partially read if edited while mail is received. The
file is read and converted to a static map (map_static.c), changes aren't
visible to smtpd until an explicit: smtpctl update map  which reads file,
builds a new static map and invalidates the former.

partial-read issue discussed with beck@@ and halex@@
idea to convert internally to a static map by eric@@

diff ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.144 2012/10/13 08:01:47 eric Exp $	*/
d110 1
a110 1
				log_warn("lka: credentials map %s is missing",
d118 1
a118 1
			log_debug("lka: %s credentials lookup (%d)", secret->host,
d122 1
a122 1
				log_warnx("%s credentials not found",
d126 1
a126 1
				log_warnx("%s credentials parse fail",
d214 1
a214 1
				log_warnx("lka: no such map \"%s\"",
d250 1
a250 1
	log_info("lookup agent exiting");
@


1.144
log
@Make map_lookup() and make_compare() set errno on failure to distinguish
between "no match" and "internal error" (e.g. missing or broken db file).
Adapt alias expansion and ruleset matching code to check for such errors,
in which case the current processing is aborted, and a temporary failure
is reported to the smtp session.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.143 2012/09/30 14:28:15 gilles Exp $	*/
d60 1
d156 10
d206 14
@


1.143
log
@- add decision to the rule so that we can actually perform a reject match
  ie:

	reject from 192.168.1.0/24 for domain "openbsd.org"
	accept from 192.168.0.0/16 for domain "openbsd.org" deliver to mbox

it was documented but not working.

ok eric@@ & chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.142 2012/09/29 10:35:00 eric Exp $	*/
a84 1
			ss->code = 530;
d86 5
a90 2
			if (rule && rule->r_decision == R_ACCEPT)
				ss->code = 250;
@


1.142
log
@finally remove rule member from struct envelope.

"wow!" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.141 2012/09/28 14:03:00 chl Exp $	*/
d87 1
a87 1
			if (rule)
@


1.141
log
@use xmemdup() and xcalloc() helpers

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.140 2012/09/21 10:22:29 eric Exp $	*/
d87 1
a87 1
			if (rule) {
a88 8
				ss->envelope.rule = *rule;
				ss->envelope.expire = rule->r_qexpire;
				if (rule->r_action == A_RELAY ||
				    rule->r_action == A_RELAYVIA)
					ss->envelope.type = D_MTA;
				else
					ss->envelope.type = D_MDA;
			}
@


1.140
log
@Move ruleset_match() prototype to smtpd.h and make the envelope const.
Adapt a lot of functions in chain to use const args where required.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.139 2012/09/19 19:40:36 eric Exp $	*/
d144 4
a147 6
			env->sc_rules_reload = calloc(1, sizeof *env->sc_rules);
			if (env->sc_rules_reload == NULL)
				fatal(NULL);
			env->sc_maps_reload = calloc(1, sizeof *env->sc_maps);
			if (env->sc_maps_reload == NULL)
				fatal(NULL);
d153 1
a153 4
			rule = calloc(1, sizeof *rule);
			if (rule == NULL)
				fatal(NULL);
			*rule = *(struct rule *)imsg->data;
d158 1
a158 4
			map = calloc(1, sizeof *map);
			if (map == NULL)
				fatal(NULL);
			*map = *(struct map *)imsg->data;
d175 1
a175 4
			mapel = calloc(1, sizeof *mapel);
			if (mapel == NULL)
				fatal(NULL);
			*mapel = *(struct mapel *)imsg->data;
@


1.139
log
@Set envelope expirancy in lka before sending the envelope to mfa.
The goal is to eventually have only the lka see the rules.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.138 2012/09/19 11:57:35 eric Exp $	*/
a44 1
struct rule *ruleset_match(struct envelope *);
@


1.138
log
@remove IS_RELAY and IS_MAILBOX macros.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.137 2012/09/18 13:42:39 eric Exp $	*/
d91 1
@


1.137
log
@simple lka cleanups:

- fix lka* function prototypes in smtpd.h
- make static functions static
- merge lka_session_init() into lka_session()
- make lka_session.c use tree.c to store sessions

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.136 2012/09/16 16:43:28 chl Exp $	*/
d91 2
a92 1
				if (IS_RELAY(*rule))
@


1.136
log
@Factorize log_imsg() in imsg_dispatch() instead of in each imsg_callback()'s
and put it out of profiling, so it's not accounted.

While there, for PROC_PARENT:
- set smtpd_process for PROC_PARENT
- use setproctitle() like other processes

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.135 2012/08/25 22:52:19 eric Exp $	*/
a51 2
void lka_session(struct submit_status *);
void lka_session_forward_reply(struct forward_req *, int);
d319 1
a319 1
int
@


1.135
log
@lka must not start servicing requests until it has received its full config
from parent.  Disable imsg from other processes until then.  Fix some races
when the mta tries to lookup an auth map too early, for example.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.134 2012/08/18 18:18:23 gilles Exp $	*/
a63 2

	log_imsg(PROC_LKA, iev->proc, imsg);
@


1.134
log
@- introduce stat_backend, an API for pluggable statistic backends
  > statistics are no longer static structures in shared memory
  > statistics are only set, smtpd never uses them in its logic
  > each statistic is a key/value where key can be any (dynamic) string
- convert all uses of the former API to use the new one
- implement stat_ramstat that keeps non-persistent stats in ram structure

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.133 2012/05/12 15:31:43 gilles Exp $	*/
d200 5
d310 5
@


1.133
log
@- 'secret' -> 'credentials' in some logs
- log_warn() admin that a map that's needed by an envelope is no longer in
  the configuration file
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.132 2012/05/12 15:29:16 gilles Exp $	*/
d259 2
a260 1
		{ PROC_MTA,	imsg_dispatch }
@


1.132
log
@- rename all occurences of K_SECRET to K_CREDENTIALS
- rename all occurences of struct map_secret to map_credentials
- do not fatal if the credentials map has disappeared, instead make the
  auth fail with a lookup failure. the mail will be temporary failed so
  it stays in queue until admin fixes smtpd.conf, removes mail, or lets
  it expires
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.131 2011/11/14 19:23:41 chl Exp $	*/
d118 2
d126 1
a126 1
			log_debug("lka: %s secret lookup (%d)", secret->host,
d130 2
a131 1
				log_warnx("%s secret not found", secret->host);
d134 2
a135 1
				log_warnx("%s secret parse fail", secret->host);
@


1.131
log
@when receiving an unexpected imsg, print its name.

with help and ideas from eric@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.130 2011/10/23 15:36:53 eric Exp $	*/
d50 1
a50 1
static int lka_encode_credentials(char *, size_t, struct map_secret *);
d113 1
a113 1
			struct map_secret *map_secret;
d117 7
a123 3
			if (map == NULL)
				fatalx("lka: secrets map not found");
			map_secret = map_lookup(map->m_id, secret->host, K_SECRET);
d125 1
a125 1
			    map_secret != NULL);
d127 1
a127 1
			if (map_secret == NULL)
d130 1
a130 1
				     sizeof secret->secret, map_secret) == 0)
d134 1
a134 1
			free(map_secret);
d315 2
a316 1
lka_encode_credentials(char *dst, size_t size, struct map_secret *map_secret)
d321 2
a322 2
	if ((buflen = asprintf(&buf, "%c%s%c%s", '\0', map_secret->username,
		    '\0', map_secret->password)) == -1)
@


1.130
log
@a few important fixes:

- use correct endianness when dumping/loading port
- use the right flag set when dumping/loading flags
- keep and use the authmap name when needed, rather than an id that
  might change when smtpd is restarted
- dump/load the authmap name with the envelope
- remove the rule struct from rq_batch as only the relay info is useful

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.129 2011/10/23 09:30:06 gilles Exp $	*/
d30 1
d205 1
a205 1
	fatalx("lka_imsg: unexpected imsg");
@


1.129
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.128 2011/10/09 18:39:53 eric Exp $	*/
d115 1
a115 1
			map = map_find(secret->secmapid);
@


1.128
log
@show messages sent between processes in debug mode

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.127 2011/05/16 21:05:51 gilles Exp $	*/
d95 1
a95 1
					ss->envelope.delivery.type = D_MTA;
d97 1
a97 1
					ss->envelope.delivery.type = D_MDA;
@


1.127
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.126 2011/05/01 12:57:11 eric Exp $	*/
d63 2
@


1.126
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.125 2011/04/17 13:36:07 gilles Exp $	*/
d44 1
a44 1
struct rule *ruleset_match(char *, struct path *, struct sockaddr_storage *);
d48 1
a48 9
static void lka_expand_pickup(struct lkasession *);
static int lka_expand_resume(struct lkasession *);
static int lka_resolve_node(char *, struct path *, struct expandnode *);
static int lka_verify_mail(struct path *);
static int lka_resolve_path(struct lkasession *, struct path *);
static struct lkasession *lka_session_init(struct submit_status *);
static void lka_request_forwardfile(struct lkasession *, char *);
static void lka_clear_expandtree(struct expandtree *);
static void lka_clear_deliverylist(struct deliverylist *);
d50 3
a52 5
static size_t lka_expand(char *, size_t, struct path *, struct path *);
static void lka_rcpt_action(char *, struct path *);
static void lka_session_destroy(struct lkasession *);
static void lka_expansion_done(struct lkasession *);
static void lka_session_fail(struct lkasession *, struct submit_status *);
a56 1
	struct lkasession	 skey;
a57 2
	struct forward_req	*fwreq;
	struct lkasession	*s;
a60 1
	struct path		*path;
d75 2
a76 2
			if (ss->u.path.user[0] == '\0' &&
			    ss->u.path.domain[0] == '\0')
d79 1
a79 1
				if (lka_verify_mail(&ss->u.path))
d88 1
a88 1
			rule = ruleset_match(ss->msg.tag, &ss->u.path, &ss->ss);
d91 5
a95 1
				ss->u.path.rule = *rule;
d102 1
a102 8
			ss = imsg->data;
			ss->code = 250;
			path = &ss->u.path;
			s = lka_session_init(ss);
			if (! lka_resolve_path(s, path))
				lka_session_fail(s, ss);
			else
				lka_expand_pickup(s);
d191 4
d196 1
a196 34
			fwreq = imsg->data;
			skey.id = fwreq->id;
			s = SPLAY_FIND(lkatree, &env->lka_sessions, &skey);
			if (s == NULL)
				fatalx("lka: session missing");
			s->pending--;
			strlcpy(s->path.pw_name, fwreq->pw_name,
			    sizeof s->path.pw_name);
			s->path.flags |= F_PATH_FORWARDED;

			if (imsg->fd != -1) {
				/* opened .forward okay */
				if (! forwards_get(imsg->fd, &s->expandtree)) {
					s->ss.code = 530;
					s->flags |= F_ERROR;					
				}
				close(imsg->fd);
				s->path.flags |= F_PATH_FORWARDED;
				lka_expand_pickup(s);
			} else {
				if (fwreq->status) {
					/* .forward not present */
					path = path_dup(&s->path);
					strlcpy(path->pw_name, fwreq->pw_name,
					    sizeof path->pw_name);
					TAILQ_INSERT_TAIL(&s->deliverylist, path, entry);
					lka_expand_pickup(s);
				} else {
					/* opening .forward failed */
					s->ss.code = 530;
					s->flags |= F_ERROR;
					lka_expand_pickup(s);
				}
			}
a198 3
		case IMSG_CTL_VERBOSE:
			log_verbose(*(int *)imsg->data);
			return;
d302 1
a302 219
lka_verify_mail(struct path *path)
{
	return 1;
}

size_t
lka_expand(char *buf, size_t len, struct path *path, struct path *sender)
{
	char *p, *pbuf;
	struct rule r;
	size_t ret, lret = 0;
	struct passwd *pw;
	
	bzero(r.r_value.buffer, MAX_RULEBUFFER_LEN);
	pbuf = r.r_value.buffer;
	
	ret = 0;
	for (p = path->rule.r_value.buffer; *p != '\0';
	     ++p, len -= lret, pbuf += lret, ret += lret) {
		if (p == path->rule.r_value.buffer && *p == '~') {
			if (*(p + 1) == '/' || *(p + 1) == '\0') {
				pw = getpwnam(path->pw_name);
				if (pw == NULL)
					return 0;
				
				lret = strlcat(pbuf, pw->pw_dir, len);
				if (lret >= len)
					return 0;
				continue;
			}
			
			if (*(p + 1) != '/') {
				char username[MAXLOGNAME];
				char *delim;
				
				lret = strlcpy(username, p + 1,
				    sizeof(username));
				if (lret >= sizeof(username))
					return 0;

				delim = strchr(username, '/');
				if (delim == NULL)
					goto copy;
				*delim = '\0';

				pw = getpwnam(username);
				if (pw == NULL)
					return 0;

				lret = strlcat(pbuf, pw->pw_dir, len);
				if (lret >= len)
					return 0;
				p += strlen(username);
				continue;
			}
		}
		if (*p == '%') {
			char	*string, *tmp = p + 1;
			int	 digit = 0;

			if (isdigit((int)*tmp)) {
			    digit = 1;
			    tmp++;
			}
			switch (*tmp) {
			case 'U':
				string = sender->user;
				break;
			case 'D':
				string = sender->domain;
				break;
			case 'a':
				string = path->user;
				break;
			case 'u':
				string = path->pw_name;
				break;
			case 'd':
				string = path->domain;
				break;
			default:
				goto copy;
			}

			if (digit == 1) {
				size_t idx = *(tmp - 1) - '0';

				lret = 1;
				if (idx < strlen(string))
					*pbuf++ = string[idx];
				else { /* fail */
					return 0;
				}

				p += 2; /* loop only does ++ */
				continue;
			}
			lret = strlcat(pbuf, string, len);
			if (lret >= len)
				return 0;
			p++;
			continue;
		}
copy:
		lret = 1;
		*pbuf = *p;
	}
	
	/* + 1 to include the NUL byte. */
	memcpy(path->rule.r_value.buffer, r.r_value.buffer, ret + 1);
	
	return ret;
}

int
lka_resolve_node(char *tag, struct path *path, struct expandnode *expnode)
{
	struct path psave = *path;

	bzero(path, sizeof(struct path));

	switch (expnode->type) {
	case EXPAND_USERNAME:
		log_debug("lka_resolve_node: node is local username: %s",
		    expnode->u.username);
		if (strlcpy(path->pw_name, expnode->u.username,
			sizeof(path->pw_name)) >= sizeof(path->pw_name))
			return 0;

		if (strlcpy(path->user, expnode->u.username,
			sizeof(path->user)) >= sizeof(path->user))
			return 0;

		if (1 || psave.domain[0] == '\0') {
			if (strlcpy(path->domain, env->sc_hostname,
				sizeof(path->domain)) >= sizeof(path->domain))
				return 0;
		}
		else {
			strlcpy(path->domain, psave.domain,
			    sizeof(psave.domain));
		}

		log_debug("lka_resolve_node: resolved to address: %s@@%s",
		    path->user, path->domain);
		lka_rcpt_action(tag, path);
		break;

	case EXPAND_FILENAME:
		log_debug("lka_resolve_node: node is filename: %s",
		    expnode->u.filename);
		path->rule.r_action = A_FILENAME;
		strlcpy(path->u.filename, expnode->u.filename,
		    sizeof(path->u.filename));
		break;

	case EXPAND_FILTER:
		log_debug("lka_resolve_node: node is filter: %s",
		    expnode->u.filter);
		path->rule.r_action = A_EXT;
		strlcpy(path->rule.r_value.buffer, expnode->u.filter + 2,
		    sizeof(path->rule.r_value.buffer));
		path->rule.r_value.buffer[strlen(path->rule.r_value.buffer) - 1] = '\0';
		break;

	case EXPAND_ADDRESS:
		log_debug("lka_resolve_node: node is address: %s@@%s",
		    expnode->u.mailaddr.user, expnode->u.mailaddr.domain);

		if (strlcpy(path->user, expnode->u.mailaddr.user,
			sizeof(path->user)) >= sizeof(path->user))
			return 0;

		if (strlcpy(path->domain, expnode->u.mailaddr.domain,
			sizeof(path->domain)) >= sizeof(path->domain))
			return 0;

		lka_rcpt_action(tag, path);
		break;
	case EXPAND_INVALID:
	case EXPAND_INCLUDE:
		fatalx("lka_resolve_node: unexpected type");
		break;
	}

	return 1;
}

void
lka_expand_pickup(struct lkasession *lkasession)
{
	int	ret;

	/* we want to do five iterations of lka_expand_resume() but
	 * we need to be interruptible in case lka_expand_resume()
	 * has sent an imsg and expects an answer.
	 */
	ret = 0;
	while (! (lkasession->flags & F_ERROR) &&
	    ! lkasession->pending && lkasession->iterations < 5) {
		++lkasession->iterations;
		ret = lka_expand_resume(lkasession);
		if (ret == -1) {
			lkasession->ss.code = 530;
			lkasession->flags |= F_ERROR;
		}

		if (lkasession->pending || ret <= 0)
			break;
	}

	if (lkasession->pending)
		return;

	lka_expansion_done(lkasession);
}

int
lka_expand_resume(struct lkasession *lkasession)
a303 39
	u_int8_t done = 1;
	struct expandnode *expnode = NULL;
	struct path *lkasessionpath = NULL;
	struct path path, *pathp = NULL;

	lkasessionpath = &lkasession->path;
	RB_FOREACH(expnode, expandtree, &lkasession->expandtree) {

		/* this node has already been expanded, skip*/
		if (expnode->flags & F_EXPAND_DONE)
			continue;
		done = 0;

		/* convert node to path, then inherit flags from lkasession */
		if (! lka_resolve_node(lkasession->message.tag, &path, expnode))
			return -1;
		path.flags = lkasessionpath->flags;

		/* resolve path, eventually populating expandtree.
		 * we need to dup because path may be added to the deliverylist.
		 */
		pathp = path_dup(&path);
		if (! lka_resolve_path(lkasession, pathp))
			return -1;

		/* decrement refcount on this node and flag it as processed */
		expandtree_decrement_node(&lkasession->expandtree, expnode);
		expnode->flags |= F_EXPAND_DONE;
	}

	/* still not done after 5 iterations ? loop detected ... reject */
	if (!done && lkasession->iterations == 5) {
		return -1;
	}

	/* we're done expanding, no need for another iteration */
	if (RB_ROOT(&lkasession->expandtree) == NULL || done)
		return 0;

a306 155
void
lka_expansion_done(struct lkasession *lkasession)
{
	struct envelope message;
	struct path *path;

	/* delivery list is empty OR expansion led to an error, reject */
	if (TAILQ_FIRST(&lkasession->deliverylist) == NULL ||
	    lkasession->flags & F_ERROR) {
		imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT, 0, 0,
		    -1, &lkasession->ss, sizeof(struct submit_status));
		goto done;
	}

	/* process the delivery list and submit envelopes to queue */
	message = lkasession->message;
	while ((path = TAILQ_FIRST(&lkasession->deliverylist)) != NULL) {
		lka_expand(path->rule.r_value.buffer,
		    sizeof(path->rule.r_value.buffer), path, &message.sender);
		message.recipient = *path;
		queue_submit_envelope(&message);
		
		TAILQ_REMOVE(&lkasession->deliverylist, path, entry);
		free(path);
	}
	queue_commit_envelopes(&message);

done:
	lka_clear_expandtree(&lkasession->expandtree);
	lka_clear_deliverylist(&lkasession->deliverylist);
	lka_session_destroy(lkasession);
}

int
lka_resolve_path(struct lkasession *lkasession, struct path *path)
{
	if (IS_RELAY(*path)) {
		path = path_dup(path);
		path->flags |= F_PATH_RELAY;
		TAILQ_INSERT_TAIL(&lkasession->deliverylist, path, entry);
		return 1;
	}

	switch (path->rule.r_condition.c_type) {
	case C_ALL:
	case C_NET:
	case C_DOM: {
		char username[MAX_LOCALPART_SIZE];
		char *sep;
		struct passwd *pw;

		lowercase(username, path->user, sizeof(username));

		sep = strchr(username, '+');
		if (sep != NULL)
			*sep = '\0';

		if (aliases_exist(path->rule.r_amap, username)) {
			path->flags |= F_PATH_ALIAS;
			if (! aliases_get(path->rule.r_amap,
				&lkasession->expandtree, path->user))
				return 0;
			return 1;
		}

		if (strlen(username) >= MAXLOGNAME)
			return 0;

		path->flags |= F_PATH_ACCOUNT;
		pw = getpwnam(username);
		if (pw == NULL)
			return 0;

		(void)strlcpy(path->pw_name, pw->pw_name,
		    sizeof(path->pw_name));

		if (path->flags & F_PATH_FORWARDED)
			TAILQ_INSERT_TAIL(&lkasession->deliverylist, path, entry);
		else
			lka_request_forwardfile(lkasession, path->pw_name);

		return 1;
	}
	case C_VDOM: {
		if (aliases_virtual_exist(path->rule.r_condition.c_map, path)) {
			path->flags |= F_PATH_VIRTUAL;
			if (! aliases_virtual_get(path->rule.r_condition.c_map,
				&lkasession->expandtree, path))
				return 0;
			return 1;
		}
		break;
	}
	default:
		fatalx("lka_resolve_path: unexpected type");
	}

	return 0;
}

static void
lka_rcpt_action(char *tag, struct path *path)
{
	struct rule *r;

	if (path->domain[0] == '\0')
		(void)strlcpy(path->domain, env->sc_hostname,
		    sizeof (path->domain));

	r = ruleset_match(tag, path, NULL);
	if (r == NULL) {
		path->rule.r_action = A_RELAY;
		return;
	}

	path->rule = *r;
}

int
lkasession_cmp(struct lkasession *s1, struct lkasession *s2)
{
	/*
	 * do not return u_int64_t's
	 */
	if (s1->id < s2->id)
		return (-1);

	if (s1->id > s2->id)
		return (1);

	return (0);
}

static void
lka_clear_expandtree(struct expandtree *expandtree)
{
	struct expandnode *expnode;

	while ((expnode = RB_ROOT(expandtree)) != NULL) {
		expandtree_remove_node(expandtree, expnode);
		free(expnode);
	}
}

static void
lka_clear_deliverylist(struct deliverylist *deliverylist)
{
	struct path *path;

	while ((path = TAILQ_FIRST(deliverylist)) != NULL) {
		TAILQ_REMOVE(deliverylist, path, entry);
		free(path);
	}
}

a324 51

static struct lkasession *
lka_session_init(struct submit_status *ss)
{
	struct lkasession *lkasession;

	lkasession = calloc(1, sizeof(struct lkasession));
	if (lkasession == NULL)
		fatal("lka_session_init: calloc");

	lkasession->id = generate_uid();
	lkasession->path = ss->u.path;
	lkasession->message = ss->msg;
	lkasession->ss = *ss;
	
	RB_INIT(&lkasession->expandtree);
	TAILQ_INIT(&lkasession->deliverylist);
	SPLAY_INSERT(lkatree, &env->lka_sessions, lkasession);

	return lkasession;
}

static void
lka_session_fail(struct lkasession *lkasession, struct submit_status *ss)
{
	ss->code = 530;
	imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT, 0, 0, -1,
	    ss, sizeof(*ss));
	lka_session_destroy(lkasession);
}

static void
lka_session_destroy(struct lkasession *lkasession)
{
	SPLAY_REMOVE(lkatree, &env->lka_sessions, lkasession);
	free(lkasession);
}

static void
lka_request_forwardfile(struct lkasession *lkasession, char *username)
{
	struct forward_req	 fwreq;

	fwreq.id = lkasession->id;
	(void)strlcpy(fwreq.pw_name, username, sizeof(fwreq.pw_name));
	imsg_compose_event(env->sc_ievs[PROC_PARENT], IMSG_PARENT_FORWARD_OPEN, 0, 0, -1,
	    &fwreq, sizeof(fwreq));
	++lkasession->pending;
}

SPLAY_GENERATE(lkatree, lkasession, nodes, lkasession_cmp);
@


1.125
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.124 2011/04/17 11:39:22 gilles Exp $	*/
d44 2
a45 2
struct rule *ruleset_match(struct smtpd *, char *, struct path *, struct sockaddr_storage *);
static void lka_imsg(struct smtpd *, struct imsgev *, struct imsg *);
d48 7
a54 7
static void lka_expand_pickup(struct smtpd *, struct lkasession *);
static int lka_expand_resume(struct smtpd *, struct lkasession *);
static int lka_resolve_node(struct smtpd *, char *, struct path *, struct expandnode *);
static int lka_verify_mail(struct smtpd *, struct path *);
static int lka_resolve_path(struct smtpd *, struct lkasession *, struct path *);
static struct lkasession *lka_session_init(struct smtpd *, struct submit_status *);
static void lka_request_forwardfile(struct smtpd *, struct lkasession *, char *);
d59 4
a62 4
static void lka_rcpt_action(struct smtpd *, char *, struct path *);
static void lka_session_destroy(struct smtpd *, struct lkasession *);
static void lka_expansion_done(struct smtpd *, struct lkasession *);
static void lka_session_fail(struct smtpd *, struct lkasession *, struct submit_status *);
d65 1
a65 1
lka_imsg(struct smtpd *env, struct imsgev *iev, struct imsg *imsg)
d80 1
a80 1
		dns_async(env, iev, imsg->hdr.type, imsg->data);
d93 1
a93 1
				if (lka_verify_mail(env, &ss->u.path))
d102 1
a102 2
			rule = ruleset_match(env, ss->msg.tag, &ss->u.path,
			    &ss->ss);
d115 3
a117 3
			s = lka_session_init(env, ss);
			if (! lka_resolve_path(env, s, path))
				lka_session_fail(env, s, ss);
d119 1
a119 1
				lka_expand_pickup(env, s);
d130 1
a130 1
			map = map_find(env, secret->secmapid);
d133 1
a133 1
			map_secret = map_lookup(env, map->m_id, secret->host, K_SECRET);
d184 1
a184 1
			rule->r_sources = map_findbyname(env, imsg->data);
d201 1
a201 1
				purge_config(env, PURGE_RULES);
d203 1
a203 1
				purge_config(env, PURGE_MAPS);
d227 1
a227 1
				lka_expand_pickup(env, s);
d235 1
a235 1
					lka_expand_pickup(env, s);
d240 1
a240 1
					lka_expand_pickup(env, s);
d283 1
a283 1
lka(struct smtpd *env)
d309 1
a309 1
	purge_config(env, PURGE_EVERYTHING);
d325 3
a327 3
	signal_set(&ev_sigint, SIGINT, lka_sig_handler, env);
	signal_set(&ev_sigterm, SIGTERM, lka_sig_handler, env);
	signal_set(&ev_sigchld, SIGCHLD, lka_sig_handler, env);
d340 2
a341 2
	config_pipes(env, peers, nitems(peers));
	config_peers(env, peers, nitems(peers));
d351 1
a351 1
lka_verify_mail(struct smtpd *env, struct path *path)
d466 1
a466 1
lka_resolve_node(struct smtpd *env, char *tag, struct path *path, struct expandnode *expnode)
d496 1
a496 1
		lka_rcpt_action(env, tag, path);
d528 1
a528 1
		lka_rcpt_action(env, tag, path);
d540 1
a540 1
lka_expand_pickup(struct smtpd *env, struct lkasession *lkasession)
d552 1
a552 1
		ret = lka_expand_resume(env, lkasession);
d565 1
a565 1
	lka_expansion_done(env, lkasession);
d569 1
a569 1
lka_expand_resume(struct smtpd *env, struct lkasession *lkasession)
d585 1
a585 1
		if (! lka_resolve_node(env, lkasession->message.tag, &path, expnode))
d593 1
a593 1
		if (! lka_resolve_path(env, lkasession, pathp))
d614 1
a614 1
lka_expansion_done(struct smtpd *env, struct lkasession *lkasession)
d633 1
a633 1
		queue_submit_envelope(env, &message);
d638 1
a638 1
	queue_commit_envelopes(env, &message);
d643 1
a643 1
	lka_session_destroy(env, lkasession);
d647 1
a647 1
lka_resolve_path(struct smtpd *env, struct lkasession *lkasession, struct path *path)
d670 1
a670 1
		if (aliases_exist(env, path->rule.r_amap, username)) {
d672 1
a672 1
			if (! aliases_get(env, path->rule.r_amap,
d692 1
a692 1
			lka_request_forwardfile(env, lkasession, path->pw_name);
d697 1
a697 1
		if (aliases_virtual_exist(env, path->rule.r_condition.c_map, path)) {
d699 1
a699 1
			if (! aliases_virtual_get(env, path->rule.r_condition.c_map,
d714 1
a714 1
lka_rcpt_action(struct smtpd *env, char *tag, struct path *path)
d722 1
a722 1
	r = ruleset_match(env, tag, path, NULL);
d788 1
a788 1
lka_session_init(struct smtpd *env, struct submit_status *ss)
d809 1
a809 1
lka_session_fail(struct smtpd *env, struct lkasession *lkasession, struct submit_status *ss)
d814 1
a814 1
	lka_session_destroy(env, lkasession);
d818 1
a818 1
lka_session_destroy(struct smtpd *env, struct lkasession *lkasession)
d825 1
a825 1
lka_request_forwardfile(struct smtpd *env, struct lkasession *lkasession, char *username)
@


1.124
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.123 2010/11/29 15:25:55 gilles Exp $	*/
d44 19
a62 19
void		lka_imsg(struct smtpd *, struct imsgev *, struct imsg *);
__dead void	lka_shutdown(void);
void		lka_sig_handler(int, short, void *);
void		lka_expand_pickup(struct smtpd *, struct lkasession *);
int		lka_expand_resume(struct smtpd *, struct lkasession *);
int		lka_resolve_node(struct smtpd *, char *tag, struct path *, struct expandnode *);
int		lka_verify_mail(struct smtpd *, struct path *);
struct rule    *ruleset_match(struct smtpd *, char *, struct path *, struct sockaddr_storage *);
int		lka_resolve_path(struct smtpd *, struct lkasession *, struct path *);
struct lkasession *lka_session_init(struct smtpd *, struct submit_status *);
void		lka_request_forwardfile(struct smtpd *, struct lkasession *, char *);
void		lka_clear_expandtree(struct expandtree *);
void		lka_clear_deliverylist(struct deliverylist *);
int		lka_encode_credentials(char *, size_t, struct map_secret *);
size_t		lka_expand(char *, size_t, struct path *, struct path *);
void		lka_rcpt_action(struct smtpd *, char *, struct path *);
void		lka_session_destroy(struct smtpd *, struct lkasession *);
void		lka_expansion_done(struct smtpd *, struct lkasession *);
void		lka_session_fail(struct smtpd *, struct lkasession *, struct submit_status *);
d64 1
a64 1
void
d255 1
a255 1
void
d714 1
a714 1
void
d747 1
a747 1
void
d758 1
a758 1
void
d769 1
a769 1
int
d788 1
a788 1
struct lkasession *
d809 1
a809 1
void
d818 1
a818 1
void
d825 1
a825 1
void
@


1.123
log
@replace the fork-based-non-blocking-resolver-hack by shiny async resolver
written by eric@@. it is still experimental but still better than what we
had earlier so ... we'll improve in tree :)

diff by me with *lots* of help from eric@@, tested by todd and I (and a
few people out there)
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.122 2010/11/28 14:35:58 gilles Exp $	*/
d617 1
a617 1
	struct message message;
@


1.122
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.121 2010/11/28 13:56:43 gilles Exp $	*/
d78 1
a78 1
	if (imsg->hdr.type == IMSG_DNS_A || imsg->hdr.type == IMSG_DNS_MX ||
@


1.121
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.120 2010/10/29 09:16:07 gilles Exp $	*/
a27 1
#include <arpa/inet.h>
a32 1
#include <netdb.h>
@


1.120
log
@smtpd no longer knows a map called "secrets" which holds credentials for
authenticated relaying. one can create many maps holding credentials and
name them however he/she wants, just like any other map.

teach smtpd how to select a credentials map at the rule-level allowing a
setup to relay through the same MX with different credentials depending
on the source.

smtpd.conf.5 updated to reflect changes with help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.119 2010/10/09 22:05:35 gilles Exp $	*/
d33 1
d44 1
a48 2
void		lka_setup_events(struct smtpd *);
void		lka_disable_events(struct smtpd *);
a284 10
void
lka_setup_events(struct smtpd *env)
{
}

void
lka_disable_events(struct smtpd *env)
{
}

a345 1
	lka_setup_events(env);
@


1.119
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.108 2010/05/27 15:36:04 gilles Exp $	*/
d131 1
d133 1
a133 1
			map = map_findbyname(env, "secrets");
@


1.118
log
@- fix a regression caused by latest commit (long story made short: do not
  attempt to expand the local delivery buffer when relaying mail, it was
  kind of ok before but no longer is)
- use the same buffer for local deliveries to files and commands

tested by jmc@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.117 2010/09/12 22:38:31 gilles Exp $	*/
d55 2
a56 2
struct lkasession *lka_session_init(struct smtpd *, struct message *);
void		lka_request_forwardfile(struct smtpd *, struct lkasession *, struct path *);
d59 2
a60 2
char           *lka_encode_secret(struct map_secret *);
size_t		lka_expand(char *, size_t, struct path *,struct path *);
d64 1
a64 4
void		lka_session_fail(struct smtpd *, struct lkasession *);
int		lka_queue_append(struct smtpd *, struct lkasession *, int);

u_int32_t lka_id;
d70 1
d73 1
a73 1
	struct message		*m;
a77 2
	struct map_secret	*map_secret;
	char			*secret;
a78 1
	int			 status;
d89 23
a111 7
			m = imsg->data;
			status = 0;
			if (m->sender.user[0] || m->sender.domain[0])
				if (! lka_verify_mail(env, &m->sender))
					status = S_MESSAGE_PERMFAILURE;
			imsg_compose_event(iev, IMSG_LKA_MAIL,
			    m->id, 0, -1, &status, sizeof status);
d115 6
a120 13
			m = imsg->data;
			rule = ruleset_match(env, m->tag, &m->recipient, &m->session_ss);
			if (rule == NULL) {
				log_debug("lka: rule not found");
				status = S_MESSAGE_PERMFAILURE;
				imsg_compose_event(iev, IMSG_LKA_RCPT, m->id, 0, -1,
				    &status, sizeof status);
				return;
			}
			m->recipient.rule = *rule;
			s = lka_session_init(env, m);
			if (! lka_resolve_path(env, s, &m->recipient))
				lka_session_fail(env, s);
a126 13
	if (iev->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_QUEUE_APPEND:
			skey.id = imsg->hdr.peerid;
			s = SPLAY_FIND(lkatree, &env->lka_sessions, &skey);
			if (s == NULL)
				fatalx("lka: session missing");
			memcpy(&status, imsg->data, sizeof status);
			lka_queue_append(env, s, status);
			return;
		}
	}

d129 3
a131 1
		case IMSG_LKA_SECRET:
d135 11
a145 10
			map_secret = map_lookup(env, map->m_id, imsg->data, K_SECRET);
			if (map_secret)
				secret = lka_encode_secret(map_secret);
			else
				secret = "";
			if (*secret == '\0')
				log_warnx("%s secret not found", (char *)imsg->data);
			imsg_compose_event(iev, IMSG_LKA_SECRET,
			    imsg->hdr.peerid, 0, -1, secret,
			    strlen(secret) + 1);
d149 1
d376 1
a376 1

d379 1
a379 1

d382 1
a382 1
	    ++p, len -= lret, pbuf += lret, ret += lret) {
d388 1
a388 1

d394 1
a394 1

d398 1
a398 1

d471 1
a471 1

d474 1
a474 1

d553 1
a553 1
lka_expand_pickup(struct smtpd *env, struct lkasession *s)
a556 8
	if (s->pending)
		return;

	if (s->flags & F_ERROR) {
		lka_expansion_done(env, s);
		return;
	}

d561 11
a571 8
	while (s->iterations < 5) {
		s->iterations++;
		ret = lka_expand_resume(env, s);
		if (ret == -1)
			s->flags |= F_ERROR;
		if (s->pending)
			return;
		if (ret == 0)
d575 4
a578 1
	lka_expansion_done(env, s);
d627 1
a627 1
lka_expansion_done(struct smtpd *env, struct lkasession *s)
d629 2
a630 1
	int status;
d633 5
a637 38
	if (TAILQ_EMPTY(&s->deliverylist) || s->flags & F_ERROR) {
		if (TAILQ_EMPTY(&s->deliverylist))
			log_debug("lka_expansion_done: list empty");
		else
			log_debug("lka_expansion_done: session error");
		goto error;
	} else if (! lka_queue_append(env, s, 0))
		goto error;
	return;

error:
	status = S_MESSAGE_PERMFAILURE;
	imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT,
	    s->message.id, 0, -1, &status, sizeof status);
	lka_clear_expandtree(&s->expandtree);
	lka_clear_deliverylist(&s->deliverylist);
	lka_session_destroy(env, s);
}

int
lka_queue_append(struct smtpd *env, struct lkasession *s, int status)
{
	struct path *path;
	struct message message;
	struct passwd *pw;
	const char *errstr;
	char *sep;
	uid_t uid;
	int ret;

	path = TAILQ_FIRST(&s->deliverylist);
	if (path == NULL || status) {
		imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT,
		    s->message.id, 0, -1, &status, sizeof status);
		lka_clear_expandtree(&s->expandtree);
		lka_clear_deliverylist(&s->deliverylist);
		lka_session_destroy(env, s);
		return 0;
d640 4
a643 6
	/* send next item to queue */
	message = s->message;
	if (path->rule.r_action != A_RELAY &&
	    path->rule.r_action != A_RELAYVIA) {
		log_debug("lka_expand: before: [%s]", path->rule.r_value.buffer);
		ret = lka_expand(path->rule.r_value.buffer,
d645 5
a649 5
		log_debug("lka_expand: after:  [%s]", path->rule.r_value.buffer);
		if (! ret) {
			log_debug("lka_expand: returned failure.");
			return 0;
		}
d651 1
d653 4
a656 17
	message.recipient = *path;
	sep = strchr(message.session_hostname, '@@');
	if (sep) {
		*sep = '\0';
		uid = strtonum(message.session_hostname, 0, UID_MAX, &errstr);
		if (errstr)
			fatalx("lka: invalid uid");
		pw = getpwuid(uid);
		if (pw == NULL)
			fatalx("lka: non-existent uid"); /* XXX */
		strlcpy(message.sender.pw_name, pw->pw_name, sizeof message.sender.pw_name);
	}
	imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_APPEND,
	    s->id, 0, -1, &message, sizeof message);
	TAILQ_REMOVE(&s->deliverylist, path, entry);
	free(path);
	return 1;
d660 1
a660 1
lka_resolve_path(struct smtpd *env, struct lkasession *s, struct path *path)
d665 1
a665 1
		TAILQ_INSERT_TAIL(&s->deliverylist, path, entry);
d685 4
a688 2
			return aliases_get(env, path->rule.r_amap,
			    &s->expandtree, username);
d691 3
d699 2
a700 1
		strlcpy(path->pw_name, pw->pw_name, sizeof path->pw_name);
d703 1
a703 1
			TAILQ_INSERT_TAIL(&s->deliverylist, path, entry);
d705 2
a706 1
			lka_request_forwardfile(env, s, path);
d712 4
a715 1
                        return aliases_virtual_get(env, path->rule.r_condition.c_map, &s->expandtree, path);
d781 2
a782 2
char *
lka_encode_secret(struct map_secret *map_secret)
d784 5
a788 7
	static char	 dst[1024];
	char		*src;
	int		 src_sz;

	src_sz = asprintf(&src, "%c%s%c%s", '\0', map_secret->username, '\0',
	    map_secret->password);
	if (src_sz == -1)
d790 4
a793 3
	if (__b64_ntop(src, src_sz, dst, sizeof dst) == -1) {
		free(src);
		return NULL;
a794 2
	free(src);
	dst[sizeof(dst) - 1] = '\0';
d796 2
a797 1
	return dst;
d801 1
a801 1
lka_session_init(struct smtpd *env, struct message *m)
d803 1
a803 1
	struct lkasession *s;
d805 3
a807 7
	s = calloc(1, sizeof *s);
	if (s == NULL)
		fatal(NULL);

	s->id = lka_id++;
	s->path = m->recipient;
	s->message = *m;
d809 8
a816 3
	RB_INIT(&s->expandtree);
	TAILQ_INIT(&s->deliverylist);
	SPLAY_INSERT(lkatree, &env->lka_sessions, s);
d818 1
a818 1
	return s;
d822 1
a822 1
lka_session_fail(struct smtpd *env, struct lkasession *s)
d824 4
a827 7
	int status;

	log_debug("lka: initina lka_resolve_path failed");
	status = S_MESSAGE_PERMFAILURE;
	imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT,
	    s->message.id, 0, -1, &status, sizeof status);
	lka_session_destroy(env, s);
d831 1
a831 1
lka_session_destroy(struct smtpd *env, struct lkasession *s)
d833 2
a834 2
	SPLAY_REMOVE(lkatree, &env->lka_sessions, s);
	free(s);
d838 1
a838 1
lka_request_forwardfile(struct smtpd *env, struct lkasession *s, struct path *path)
d842 2
a843 2
	fwreq.id = s->id;
	strlcpy(fwreq.pw_name, path->pw_name, sizeof fwreq.pw_name);
d845 2
a846 2
	    &fwreq, sizeof fwreq);
	s->pending++;
@


1.117
log
@oga@@ spotted a bug in lka_expand() which caused it to miscalculate the
length of its expand buffer. this commit introduces a new lka_expand()
that has been simplified, that fixes the bug and that is more robust.
callers of lka_expand() can now determine that it has failed and throw
the recipient at session time.

lka_expand() rewrite by oga@@, changes around it by me, tested on a few
different setups but no feedback from tech@@ so ... let me know if it's
breaking something for you
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.116 2010/09/08 13:46:18 gilles Exp $	*/
d382 2
a383 2
	bzero(r.r_value.path, MAXPATHLEN);
	pbuf = r.r_value.path;
d386 1
a386 1
	for (p = path->rule.r_value.path; *p != '\0';
d388 1
a388 1
		if (p == path->rule.r_value.path && *p == '~') {
d478 1
a478 1
	memcpy(path->rule.r_value.path, r.r_value.path, ret + 1);
d529 3
a531 3
		strlcpy(path->rule.r_value.command, expnode->u.filter + 2,
		    sizeof(path->rule.r_value.command));
		path->rule.r_value.command[strlen(path->rule.r_value.command) - 1] = '\0';
d681 10
a690 6
	log_debug("lka_expand: before: [%s]", path->rule.r_value.path);
	ret = lka_expand(path->rule.r_value.path, sizeof(path->rule.r_value.path), path, &message.sender);
	log_debug("lka_expand: after:  [%s]", path->rule.r_value.path);
	if (! ret) {
		log_debug("lka_expand: returned failure.");
		return 0;
@


1.116
log
@add support for sender expansion in smtpd.conf:

	%U for sender localpart
	%D for sender domainpart

diff sent to tech@@ by Gregory Edigarov <greg@@bestnet.kharkov.ua>, timeout
by jacekm@@, ok by me
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.115 2010/06/04 11:15:25 jacekm Exp $	*/
d65 1
a65 1
void		lka_queue_append(struct smtpd *, struct lkasession *, int);
d379 1
a379 1
	size_t ret;
d386 2
a387 1
	for (p = path->rule.r_value.path; *p != '\0'; ++p) {
d392 1
a392 1
					continue;
d394 3
a396 4
				ret += strlcat(pbuf, pw->pw_dir, len);
				if (ret >= len)
					return ret;
				pbuf += strlen(pw->pw_dir);
d404 1
a404 1
				ret = strlcpy(username, p + 1,
d406 3
d410 3
a412 7
				if (delim == NULL && ret >= sizeof(username)) {
					continue;
				}

				if (delim != NULL) {
					*delim = '\0';
				}
d416 1
a416 1
					continue;
d418 3
a420 4
				ret += strlcat(pbuf, pw->pw_dir, len);
				if (ret >= len)
					return ret;
				pbuf += strlen(pw->pw_dir);
d425 27
a451 42
		if (strncmp(p, "%U", 2) == 0) {
			ret += strlcat(pbuf, sender->user, len);
			if (ret >= len)
				return ret;
			pbuf += strlen (sender->user);
			++p;
			continue;
		}
		if (strncmp(p,"%D",2) == 0) {
			ret += strlcat(pbuf, sender->domain, len);
			if (ret >= len)
				return ret;
			pbuf += strlen(sender->domain);
			++p;
			continue;
		}
		if (strncmp(p, "%a", 2) == 0) {
			ret += strlcat(pbuf, path->user, len);
			if (ret >= len)
				return ret;
			pbuf += strlen(path->user);
			++p;
			continue;
		}
		if (strncmp(p, "%u", 2) == 0) {
			ret += strlcat(pbuf, path->pw_name, len);
			if (ret >= len)
				return ret;
			pbuf += strlen(path->pw_name);
			++p;
			continue;
		}
		if (strncmp(p, "%d", 2) == 0) {
			ret += strlcat(pbuf, path->domain, len);
			if (ret >= len)
				return ret;
			pbuf += strlen(path->domain);
			++p;
			continue;
		}
		if (*p == '%' && isdigit((int)*(p+1)) && *(p+2) == 'a') {
			size_t idx;
d453 2
a454 9
			idx = *(p+1) - '0';
			if (idx < strlen(path->user))
				*pbuf++ = path->user[idx];
			p+=2;
			++ret;
			continue;
		}
		if (*p == '%' && isdigit((int)*(p+1)) && *(p+2) == 'u') {
			size_t idx;
d456 6
a461 9
			idx = *(p+1) - '0';
			if (idx < strlen(path->pw_name))
				*pbuf++ = path->pw_name[idx];
			p+=2;
			++ret;
			continue;
		}
		if (*p == '%' && isdigit((int)*(p+1)) && *(p+2) == 'd') {
			size_t idx;
d463 7
a469 5
			idx = *(p+1) - '0';
			if (idx < strlen(path->domain))
				*pbuf++ = path->domain[idx];
			p+=2;
			++ret;
d472 3
a474 3

		*pbuf++ = *p;
		++ret;
d477 2
a478 1
	memcpy(path->rule.r_value.path, r.r_value.path, ret);
d644 12
a655 8
		status = S_MESSAGE_PERMFAILURE;
		imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT,
		    s->message.id, 0, -1, &status, sizeof status);
		lka_clear_expandtree(&s->expandtree);
		lka_clear_deliverylist(&s->deliverylist);
		lka_session_destroy(env, s);
	} else
		lka_queue_append(env, s, 0);
d658 1
a658 1
void
d667 1
a669 1

d676 1
a676 1
		return;
d681 8
a688 1
	lka_expand(path->rule.r_value.path, sizeof(path->rule.r_value.path), path, &message.sender);
d705 1
@


1.115
log
@Use correct imsg type in error reply.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.114 2010/06/02 19:16:53 chl Exp $	*/
d60 1
a60 1
size_t		lka_expand(char *, size_t, struct path *);
d375 1
a375 1
lka_expand(char *buf, size_t len, struct path *path)
d427 16
d701 1
a701 1
	lka_expand(path->rule.r_value.path, sizeof(path->rule.r_value.path), path);
@


1.114
log
@check event_dispatch() return value

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.113 2010/06/01 23:06:23 jacekm Exp $	*/
d109 1
a109 1
				imsg_compose_event(iev, IMSG_LKA_RULEMATCH, m->id, 0, -1,
@


1.113
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.111 2010/06/01 02:19:56 jacekm Exp $	*/
d361 2
a362 1
	event_dispatch();
@


1.112
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.108 2010/05/27 15:36:04 gilles Exp $	*/
d55 2
a56 2
struct lkasession *lka_session_init(struct smtpd *, struct submit_status *);
void		lka_request_forwardfile(struct smtpd *, struct lkasession *, char *);
d59 1
a59 1
int		lka_encode_credentials(char *, size_t, struct map_secret *);
d64 4
a67 1
void		lka_session_fail(struct smtpd *, struct lkasession *, struct submit_status *);
a72 1
	struct submit_status	*ss;
d75 1
a75 1
	struct secret		*secret;
d80 2
d83 1
d94 7
a100 10
			ss = imsg->data;
			ss->code = 530;
			if (ss->u.path.user[0] == '\0' &&
			    ss->u.path.domain[0] == '\0')
				ss->code = 250;
			else
				if (lka_verify_mail(env, &ss->u.path))
					ss->code = 250;
			imsg_compose_event(iev, IMSG_LKA_MAIL, 0, 0, -1, ss,
			    sizeof *ss);
d103 9
a111 8
		case IMSG_LKA_RULEMATCH:
			ss = imsg->data;
			ss->code = 530;
			rule = ruleset_match(env, ss->msg.tag, &ss->u.path,
			    &ss->ss);
			if (rule) {
				ss->code = 250;
				ss->u.path.rule = *rule;
d113 6
a118 2
			imsg_compose_event(iev, IMSG_LKA_RULEMATCH, 0, 0, -1,
			    ss, sizeof *ss);
d120 2
d123 9
a131 9
		case IMSG_LKA_RCPT:
			ss = imsg->data;
			ss->code = 250;
			path = &ss->u.path;
			s = lka_session_init(env, ss);
			if (! lka_resolve_path(env, s, path))
				lka_session_fail(env, s, ss);
			else
				lka_expand_pickup(env, s);
d138 1
a138 3
		case IMSG_LKA_SECRET: {
			struct map_secret *map_secret;
			secret = imsg->data;
d142 10
a151 11
			map_secret = map_lookup(env, map->m_id, secret->host, K_SECRET);
			log_debug("lka: %s secret lookup (%d)", secret->host,
			    map_secret != NULL);
			secret->secret[0] = '\0';
			if (map_secret == NULL)
				log_warnx("%s secret not found", secret->host);
			else if (lka_encode_credentials(secret->secret,
				     sizeof secret->secret, map_secret) == 0)
				log_warnx("%s secret parse fail", secret->host);
			imsg_compose_event(iev, IMSG_LKA_SECRET, 0, 0, -1, secret,
			    sizeof *secret);
a154 1
		}
d509 1
a509 1
		if (psave.domain[0] == '\0') {
d565 1
a565 1
lka_expand_pickup(struct smtpd *env, struct lkasession *lkasession)
d569 8
d581 8
a588 11
	ret = 0;
	while (! (lkasession->flags & F_ERROR) &&
	    ! lkasession->pending && lkasession->iterations < 5) {
		++lkasession->iterations;
		ret = lka_expand_resume(env, lkasession);
		if (ret == -1) {
			lkasession->ss.code = 530;
			lkasession->flags |= F_ERROR;
		}

		if (lkasession->pending || ret <= 0)
d592 1
a592 4
	if (lkasession->pending)
		return;

	lka_expansion_done(env, lkasession);
d641 1
a641 1
lka_expansion_done(struct smtpd *env, struct lkasession *lkasession)
d643 1
a643 2
	struct message message;
	struct path *path;
d646 34
a679 17
	if (TAILQ_FIRST(&lkasession->deliverylist) == NULL ||
	    lkasession->flags & F_ERROR) {
		imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT, 0, 0,
		    -1, &lkasession->ss, sizeof(struct submit_status));
		goto done;
	}

	/* process the delivery list and submit envelopes to queue */
	message = lkasession->message;
	while ((path = TAILQ_FIRST(&lkasession->deliverylist)) != NULL) {
		lka_expand(path->rule.r_value.path,
			sizeof(path->rule.r_value.path), path);
		message.recipient = *path;
		queue_submit_envelope(env, &message);
		
		TAILQ_REMOVE(&lkasession->deliverylist, path, entry);
		free(path);
a680 1
	queue_commit_envelopes(env, &message);
d682 19
a700 4
done:
	lka_clear_expandtree(&lkasession->expandtree);
	lka_clear_deliverylist(&lkasession->deliverylist);
	lka_session_destroy(env, lkasession);
d704 1
a704 1
lka_resolve_path(struct smtpd *env, struct lkasession *lkasession, struct path *path)
d709 1
a709 1
		TAILQ_INSERT_TAIL(&lkasession->deliverylist, path, entry);
d729 2
a730 4
			if (! aliases_get(env, path->rule.r_amap,
				&lkasession->expandtree, path->user))
				return 0;
			return 1;
a732 3
		if (strlen(username) >= MAXLOGNAME)
			return 0;

d738 1
a738 2
		(void)strlcpy(path->pw_name, pw->pw_name,
		    sizeof(path->pw_name));
d741 1
a741 1
			TAILQ_INSERT_TAIL(&lkasession->deliverylist, path, entry);
d743 1
a743 2
			lka_request_forwardfile(env, lkasession, path->pw_name);

d749 1
a749 4
			if (! aliases_virtual_get(env, path->rule.r_condition.c_map,
				&lkasession->expandtree, path))
				return 0;
			return 1;
d815 2
a816 2
int
lka_encode_credentials(char *dst, size_t size, struct map_secret *map_secret)
d818 7
a824 5
	char	*buf;
	int	 buflen;

	if ((buflen = asprintf(&buf, "%c%s%c%s", '\0', map_secret->username,
		    '\0', map_secret->password)) == -1)
d826 3
a828 4

	if (__b64_ntop((unsigned char *)buf, buflen, dst, size) == -1) {
		free(buf);
		return 0;
d830 2
d833 1
a833 2
	free(buf);
	return 1;
d837 1
a837 1
lka_session_init(struct smtpd *env, struct submit_status *ss)
d839 1
a839 1
	struct lkasession *lkasession;
d841 3
a843 3
	lkasession = calloc(1, sizeof(struct lkasession));
	if (lkasession == NULL)
		fatal("lka_session_init: calloc");
d845 3
a847 8
	lkasession->id = generate_uid();
	lkasession->path = ss->u.path;
	lkasession->message = ss->msg;
	lkasession->ss = *ss;
	
	RB_INIT(&lkasession->expandtree);
	TAILQ_INIT(&lkasession->deliverylist);
	SPLAY_INSERT(lkatree, &env->lka_sessions, lkasession);
d849 5
a853 1
	return lkasession;
d857 1
a857 1
lka_session_fail(struct smtpd *env, struct lkasession *lkasession, struct submit_status *ss)
d859 7
a865 4
	ss->code = 530;
	imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT, 0, 0, -1,
	    ss, sizeof(*ss));
	lka_session_destroy(env, lkasession);
d869 1
a869 1
lka_session_destroy(struct smtpd *env, struct lkasession *lkasession)
d871 2
a872 2
	SPLAY_REMOVE(lkatree, &env->lka_sessions, lkasession);
	free(lkasession);
d876 1
a876 1
lka_request_forwardfile(struct smtpd *env, struct lkasession *lkasession, char *username)
d880 2
a881 2
	fwreq.id = lkasession->id;
	(void)strlcpy(fwreq.pw_name, username, sizeof(fwreq.pw_name));
d883 2
a884 2
	    &fwreq, sizeof(fwreq));
	++lkasession->pending;
@


1.111
log
@Don't interpret garbage on stack; problem seemingly exposed by my
queue rewrite.  Proper fix after gilles wakes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.110 2010/06/01 02:08:56 jacekm Exp $	*/
d55 2
a56 2
struct lkasession *lka_session_init(struct smtpd *, struct message *);
void		lka_request_forwardfile(struct smtpd *, struct lkasession *, struct path *);
d59 1
a59 1
char           *lka_encode_secret(struct map_secret *);
d64 1
a64 4
void		lka_session_fail(struct smtpd *, struct lkasession *);
void		lka_queue_append(struct smtpd *, struct lkasession *, int);

u_int32_t lka_id;
d70 1
d73 1
a73 1
	struct message		*m;
a77 2
	struct map_secret	*map_secret;
	char			*secret;
a78 1
	int			 status;
d89 23
a111 7
			m = imsg->data;
			status = 0;
			if (m->sender.user[0] || m->sender.domain[0])
				if (! lka_verify_mail(env, &m->sender))
					status = S_MESSAGE_PERMFAILURE;
			imsg_compose_event(iev, IMSG_LKA_MAIL,
			    m->id, 0, -1, &status, sizeof status);
d115 6
a120 13
			m = imsg->data;
			rule = ruleset_match(env, m->tag, &m->recipient, &m->session_ss);
			if (rule == NULL) {
				log_debug("lka: rule not found");
				status = S_MESSAGE_PERMFAILURE;
				imsg_compose_event(iev, IMSG_LKA_RULEMATCH, m->id, 0, -1,
				    &status, sizeof status);
				return;
			}
			m->recipient.rule = *rule;
			s = lka_session_init(env, m);
			if (! lka_resolve_path(env, s, &m->recipient))
				lka_session_fail(env, s);
a126 13
	if (iev->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_QUEUE_APPEND:
			skey.id = imsg->hdr.peerid;
			s = SPLAY_FIND(lkatree, &env->lka_sessions, &skey);
			if (s == NULL)
				fatalx("lka: session missing");
			memcpy(&status, imsg->data, sizeof status);
			lka_queue_append(env, s, status);
			return;
		}
	}

d129 3
a131 1
		case IMSG_LKA_SECRET:
d135 11
a145 10
			map_secret = map_lookup(env, map->m_id, imsg->data, K_SECRET);
			if (map_secret)
				secret = lka_encode_secret(map_secret);
			else
				secret = "";
			if (*secret == '\0')
				log_warnx("%s secret not found", (char *)imsg->data);
			imsg_compose_event(iev, IMSG_LKA_SECRET,
			    imsg->hdr.peerid, 0, -1, secret,
			    strlen(secret) + 1);
d149 1
d504 1
a504 1
		if (1 || psave.domain[0] == '\0') {
d560 1
a560 1
lka_expand_pickup(struct smtpd *env, struct lkasession *s)
a563 8
	if (s->pending)
		return;

	if (s->flags & F_ERROR) {
		lka_expansion_done(env, s);
		return;
	}

d568 11
a578 8
	while (s->iterations < 5) {
		s->iterations++;
		ret = lka_expand_resume(env, s);
		if (ret == -1)
			s->flags |= F_ERROR;
		if (s->pending)
			return;
		if (ret == 0)
d582 4
a585 1
	lka_expansion_done(env, s);
d634 1
a634 1
lka_expansion_done(struct smtpd *env, struct lkasession *s)
d636 2
a637 1
	int status;
d640 17
a656 34
	if (TAILQ_EMPTY(&s->deliverylist) || s->flags & F_ERROR) {
		if (TAILQ_EMPTY(&s->deliverylist))
			log_debug("lka_expansion_done: list empty");
		else
			log_debug("lka_expansion_done: session error");
		status = S_MESSAGE_PERMFAILURE;
		imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT,
		    s->message.id, 0, -1, &status, sizeof status);
		lka_clear_expandtree(&s->expandtree);
		lka_clear_deliverylist(&s->deliverylist);
		lka_session_destroy(env, s);
	} else
		lka_queue_append(env, s, 0);
}

void
lka_queue_append(struct smtpd *env, struct lkasession *s, int status)
{
	struct path *path;
	struct message message;
	struct passwd *pw;
	const char *errstr;
	char *sep;
	uid_t uid;

	path = TAILQ_FIRST(&s->deliverylist);

	if (path == NULL || status) {
		imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT,
		    s->message.id, 0, -1, &status, sizeof status);
		lka_clear_expandtree(&s->expandtree);
		lka_clear_deliverylist(&s->deliverylist);
		lka_session_destroy(env, s);
		return;
d658 1
d660 4
a663 19
	/* send next item to queue */
	message = s->message;
	lka_expand(path->rule.r_value.path, sizeof(path->rule.r_value.path), path);
	message.recipient = *path;
	sep = strchr(message.session_hostname, '@@');
	if (sep) {
		*sep = '\0';
		uid = strtonum(message.session_hostname, 0, UID_MAX, &errstr);
		if (errstr)
			fatalx("lka: invalid uid");
		pw = getpwuid(uid);
		if (pw == NULL)
			fatalx("lka: non-existent uid"); /* XXX */
		strlcpy(message.sender.pw_name, pw->pw_name, sizeof message.sender.pw_name);
	}
	imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_APPEND,
	    s->id, 0, -1, &message, sizeof message);
	TAILQ_REMOVE(&s->deliverylist, path, entry);
	free(path);
d667 1
a667 1
lka_resolve_path(struct smtpd *env, struct lkasession *s, struct path *path)
d672 1
a672 1
		TAILQ_INSERT_TAIL(&s->deliverylist, path, entry);
d692 4
a695 2
			return aliases_get(env, path->rule.r_amap,
			    &s->expandtree, username);
d698 3
d706 2
a707 1
		strlcpy(path->pw_name, pw->pw_name, sizeof path->pw_name);
d710 1
a710 1
			TAILQ_INSERT_TAIL(&s->deliverylist, path, entry);
d712 2
a713 1
			lka_request_forwardfile(env, s, path);
d719 4
a722 1
                        return aliases_virtual_get(env, path->rule.r_condition.c_map, &s->expandtree, path);
d788 2
a789 2
char *
lka_encode_secret(struct map_secret *map_secret)
d791 5
a795 7
	static char	 dst[1024];
	char		*src;
	int		 src_sz;

	src_sz = asprintf(&src, "%c%s%c%s", '\0', map_secret->username, '\0',
	    map_secret->password);
	if (src_sz == -1)
d797 4
a800 3
	if (__b64_ntop(src, src_sz, dst, sizeof dst) == -1) {
		free(src);
		return NULL;
a801 1
	dst[sizeof(dst) - 1] = '\0';
d803 2
a804 1
	return dst;
d808 1
a808 1
lka_session_init(struct smtpd *env, struct message *m)
d810 1
a810 1
	struct lkasession *s;
d812 3
a814 3
	s = calloc(1, sizeof *s);
	if (s == NULL)
		fatal(NULL);
d816 8
a823 3
	s->id = lka_id++;
	s->path = m->recipient;
	s->message = *m;
d825 1
a825 5
	RB_INIT(&s->expandtree);
	TAILQ_INIT(&s->deliverylist);
	SPLAY_INSERT(lkatree, &env->lka_sessions, s);

	return s;
d829 1
a829 1
lka_session_fail(struct smtpd *env, struct lkasession *s)
d831 4
a834 7
	int status;

	log_debug("lka: initina lka_resolve_path failed");
	status = S_MESSAGE_PERMFAILURE;
	imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT,
	    s->message.id, 0, -1, &status, sizeof status);
	lka_session_destroy(env, s);
d838 1
a838 1
lka_session_destroy(struct smtpd *env, struct lkasession *s)
d840 2
a841 2
	SPLAY_REMOVE(lkatree, &env->lka_sessions, s);
	free(s);
d845 1
a845 1
lka_request_forwardfile(struct smtpd *env, struct lkasession *s, struct path *path)
d849 2
a850 2
	fwreq.id = s->id;
	strlcpy(fwreq.pw_name, path->pw_name, sizeof fwreq.pw_name);
d852 2
a853 2
	    &fwreq, sizeof fwreq);
	s->pending++;
@


1.110
log
@Fix one case of not sending smtp session id on error.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.109 2010/05/31 23:38:56 jacekm Exp $	*/
d509 1
a509 1
		if (psave.domain[0] == '\0') {
@


1.109
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.108 2010/05/27 15:36:04 gilles Exp $	*/
d862 2
a863 2
	imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT, 0, 0, -1,
	    &status, sizeof status);
@


1.108
log
@when a rule has two conditions (ie: accept for { domain foo, domain bar } )
expand to two rules each having its own condition rather than one rule
with a tail queue of conditions. this simplifies code a bit and removes a
couple hacks.

basic testing by oga and me
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.107 2010/04/27 09:49:23 gilles Exp $	*/
d55 2
a56 2
struct lkasession *lka_session_init(struct smtpd *, struct submit_status *);
void		lka_request_forwardfile(struct smtpd *, struct lkasession *, char *);
d59 1
a59 1
int		lka_encode_credentials(char *, size_t, struct map_secret *);
d64 4
a67 1
void		lka_session_fail(struct smtpd *, struct lkasession *, struct submit_status *);
a72 1
	struct submit_status	*ss;
d75 1
a75 1
	struct secret		*secret;
d80 2
d83 1
d94 7
a100 10
			ss = imsg->data;
			ss->code = 530;
			if (ss->u.path.user[0] == '\0' &&
			    ss->u.path.domain[0] == '\0')
				ss->code = 250;
			else
				if (lka_verify_mail(env, &ss->u.path))
					ss->code = 250;
			imsg_compose_event(iev, IMSG_LKA_MAIL, 0, 0, -1, ss,
			    sizeof *ss);
d103 9
a111 8
		case IMSG_LKA_RULEMATCH:
			ss = imsg->data;
			ss->code = 530;
			rule = ruleset_match(env, ss->msg.tag, &ss->u.path,
			    &ss->ss);
			if (rule) {
				ss->code = 250;
				ss->u.path.rule = *rule;
d113 6
a118 2
			imsg_compose_event(iev, IMSG_LKA_RULEMATCH, 0, 0, -1,
			    ss, sizeof *ss);
d120 2
d123 9
a131 9
		case IMSG_LKA_RCPT:
			ss = imsg->data;
			ss->code = 250;
			path = &ss->u.path;
			s = lka_session_init(env, ss);
			if (! lka_resolve_path(env, s, path))
				lka_session_fail(env, s, ss);
			else
				lka_expand_pickup(env, s);
d138 1
a138 3
		case IMSG_LKA_SECRET: {
			struct map_secret *map_secret;
			secret = imsg->data;
d142 10
a151 11
			map_secret = map_lookup(env, map->m_id, secret->host, K_SECRET);
			log_debug("lka: %s secret lookup (%d)", secret->host,
			    map_secret != NULL);
			secret->secret[0] = '\0';
			if (map_secret == NULL)
				log_warnx("%s secret not found", secret->host);
			else if (lka_encode_credentials(secret->secret,
				     sizeof secret->secret, map_secret) == 0)
				log_warnx("%s secret parse fail", secret->host);
			imsg_compose_event(iev, IMSG_LKA_SECRET, 0, 0, -1, secret,
			    sizeof *secret);
a154 1
		}
d565 1
a565 1
lka_expand_pickup(struct smtpd *env, struct lkasession *lkasession)
d569 8
d581 8
a588 11
	ret = 0;
	while (! (lkasession->flags & F_ERROR) &&
	    ! lkasession->pending && lkasession->iterations < 5) {
		++lkasession->iterations;
		ret = lka_expand_resume(env, lkasession);
		if (ret == -1) {
			lkasession->ss.code = 530;
			lkasession->flags |= F_ERROR;
		}

		if (lkasession->pending || ret <= 0)
d592 1
a592 4
	if (lkasession->pending)
		return;

	lka_expansion_done(env, lkasession);
d641 1
a641 1
lka_expansion_done(struct smtpd *env, struct lkasession *lkasession)
d643 1
a643 2
	struct message message;
	struct path *path;
d646 34
a679 17
	if (TAILQ_FIRST(&lkasession->deliverylist) == NULL ||
	    lkasession->flags & F_ERROR) {
		imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT, 0, 0,
		    -1, &lkasession->ss, sizeof(struct submit_status));
		goto done;
	}

	/* process the delivery list and submit envelopes to queue */
	message = lkasession->message;
	while ((path = TAILQ_FIRST(&lkasession->deliverylist)) != NULL) {
		lka_expand(path->rule.r_value.path,
			sizeof(path->rule.r_value.path), path);
		message.recipient = *path;
		queue_submit_envelope(env, &message);
		
		TAILQ_REMOVE(&lkasession->deliverylist, path, entry);
		free(path);
a680 1
	queue_commit_envelopes(env, &message);
d682 19
a700 4
done:
	lka_clear_expandtree(&lkasession->expandtree);
	lka_clear_deliverylist(&lkasession->deliverylist);
	lka_session_destroy(env, lkasession);
d704 1
a704 1
lka_resolve_path(struct smtpd *env, struct lkasession *lkasession, struct path *path)
d709 1
a709 1
		TAILQ_INSERT_TAIL(&lkasession->deliverylist, path, entry);
d729 2
a730 4
			if (! aliases_get(env, path->rule.r_amap,
				&lkasession->expandtree, path->user))
				return 0;
			return 1;
a732 3
		if (strlen(username) >= MAXLOGNAME)
			return 0;

d738 1
a738 2
		(void)strlcpy(path->pw_name, pw->pw_name,
		    sizeof(path->pw_name));
d741 1
a741 1
			TAILQ_INSERT_TAIL(&lkasession->deliverylist, path, entry);
d743 1
a743 2
			lka_request_forwardfile(env, lkasession, path->pw_name);

d749 1
a749 4
			if (! aliases_virtual_get(env, path->rule.r_condition.c_map,
				&lkasession->expandtree, path))
				return 0;
			return 1;
d815 2
a816 2
int
lka_encode_credentials(char *dst, size_t size, struct map_secret *map_secret)
d818 7
a824 5
	char	*buf;
	int	 buflen;

	if ((buflen = asprintf(&buf, "%c%s%c%s", '\0', map_secret->username,
		    '\0', map_secret->password)) == -1)
d826 3
a828 4

	if (__b64_ntop((unsigned char *)buf, buflen, dst, size) == -1) {
		free(buf);
		return 0;
d830 1
d832 1
a832 2
	free(buf);
	return 1;
d836 1
a836 1
lka_session_init(struct smtpd *env, struct submit_status *ss)
d838 1
a838 1
	struct lkasession *lkasession;
d840 3
a842 3
	lkasession = calloc(1, sizeof(struct lkasession));
	if (lkasession == NULL)
		fatal("lka_session_init: calloc");
d844 3
a846 8
	lkasession->id = generate_uid();
	lkasession->path = ss->u.path;
	lkasession->message = ss->msg;
	lkasession->ss = *ss;
	
	RB_INIT(&lkasession->expandtree);
	TAILQ_INIT(&lkasession->deliverylist);
	SPLAY_INSERT(lkatree, &env->lka_sessions, lkasession);
d848 5
a852 1
	return lkasession;
d856 1
a856 1
lka_session_fail(struct smtpd *env, struct lkasession *lkasession, struct submit_status *ss)
d858 4
a861 1
	ss->code = 530;
d863 2
a864 2
	    ss, sizeof(*ss));
	lka_session_destroy(env, lkasession);
d868 1
a868 1
lka_session_destroy(struct smtpd *env, struct lkasession *lkasession)
d870 2
a871 2
	SPLAY_REMOVE(lkatree, &env->lka_sessions, lkasession);
	free(lkasession);
d875 1
a875 1
lka_request_forwardfile(struct smtpd *env, struct lkasession *lkasession, char *username)
d879 2
a880 2
	fwreq.id = lkasession->id;
	(void)strlcpy(fwreq.pw_name, username, sizeof(fwreq.pw_name));
d882 2
a883 2
	    &fwreq, sizeof(fwreq));
	++lkasession->pending;
@


1.107
log
@initial work at fixing aliases support:
- kill struct alias, struct expandnode is used instead
- introduce map_parse_alias() and map_parse_virtual()
- aliases and virtual code no longer assume db(3) but use the map API which
  lets them become backend agnostic AND value-checked. this actually makes
  the code simpler by removing all values parsing from aliases.c
- rename K_SECRETS -> K_SECRET, K_ALIASES -> K_ALIAS for consistency the
  enum has singular names.
- aliases, virtual and forward now work with an expandtree and deal with
  multiple levels of resolving by merging expandtree's

more coming soon ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.106 2010/04/21 21:47:38 gilles Exp $	*/
a74 1
	struct cond		*cond;
a169 1
			TAILQ_INIT(&rule->r_conditions);
a172 9
		case IMSG_CONF_CONDITION:
			rule = TAILQ_LAST(env->sc_rules_reload, rulelist);
			cond = calloc(1, sizeof *cond);
			if (cond == NULL)
				fatal(NULL);
			*cond = *(struct cond *)imsg->data;
			TAILQ_INSERT_TAIL(&rule->r_conditions, cond, c_entry);
			return;

d669 1
a669 1
	if (IS_RELAY(*path) || path->cond == NULL) {
d676 1
a676 1
	switch (path->cond->c_type) {
d717 1
a717 1
		if (aliases_virtual_exist(env, path->cond->c_map, path)) {
d719 1
a719 1
			if (! aliases_virtual_get(env, path->cond->c_map,
@


1.106
log
@introduce first map parser for maps of kind K_SECRETS !

map_parse_secret() converts a map value into a struct map_secret. lka no
longer needs to do any parsing, it simply calls map_lookup() with kind
K_SECRETS, checks if it returned a !NULL value, and call lka_encode_secret
to safely do the base64 encoding.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.105 2010/04/21 19:53:15 gilles Exp $	*/
d51 1
a51 1
int		lka_resolve_node(struct smtpd *, char *tag, struct path *, struct expand_node *);
d136 1
a136 1
			map_secret = map_lookup(env, map->m_id, secret->host, K_SECRETS);
d497 1
a497 1
lka_resolve_node(struct smtpd *env, char *tag, struct path *path, struct expand_node *expnode)
d603 1
a603 1
	struct expand_node *expnode = NULL;
d780 1
a780 1
	struct expand_node *expnode;
@


1.105
log
@map_lookup() takes an additionnal parameter of type enum map_kind which
will be used to select the appropriate map parser. make sure every call
to map_lookup() is updated. map_lookup() currently ignores the value.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.104 2010/04/21 18:54:43 jacekm Exp $	*/
d59 1
a59 1
int		lka_encode_credentials(char *, size_t, char *);
d130 2
a131 1
		case IMSG_LKA_SECRET:
d136 1
a136 1
			tmp = map_lookup(env, map->m_id, secret->host, K_SECRETS);
d138 1
a138 1
			    tmp != NULL);
d140 1
a140 1
			if (tmp == NULL)
d143 1
a143 1
				     sizeof secret->secret, tmp) == 0)
d147 1
a147 1
			free(tmp);
d150 1
d800 1
a800 1
lka_encode_credentials(char *dst, size_t size, char *user)
d802 1
a802 1
	char	*pass, *buf;
d805 2
a806 5
	if ((pass = strchr(user, ':')) == NULL)
		return 0;
	*pass++ = '\0';

	if ((buflen = asprintf(&buf, "%c%s%c%s", '\0', user, '\0', pass)) == -1)
@


1.104
log
@Runner process is just a helper for queue, so tear down its imsg
channels to parent, mda, mta, lka, smtp, and control.  This leaves
just the channel to queue, which forwards imsgs on runner's behalf
and redirects any replies back to it.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.103 2010/04/21 08:29:01 jacekm Exp $	*/
d135 1
a135 1
			tmp = map_lookup(env, map->m_id, secret->host);
@


1.103
log
@Remove unusable ifdef DEBUG code.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.102 2010/04/20 15:34:56 jacekm Exp $	*/
a317 1
		{ PROC_RUNNER,	imsg_dispatch },
@


1.102
log
@Kill *2400* lines of code by abstracting common bits of the imsg handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.101 2010/02/17 17:27:47 gilles Exp $	*/
a337 1
#ifndef DEBUG
a341 1
#endif
@


1.101
log
@erf, previous fix to lka crash was still using the wrong define ...
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.100 2010/02/17 13:47:31 gilles Exp $	*/
d44 1
a46 6
void		lka_dispatch_parent(int, short, void *);
void		lka_dispatch_mfa(int, short, void *);
void		lka_dispatch_smtp(int, short, void *);
void		lka_dispatch_queue(int, short, void *);
void		lka_dispatch_runner(int, short, void *);
void		lka_dispatch_mta(int, short, void *);
d67 1
a67 1
lka_sig_handler(int sig, short event, void *p)
d69 32
a100 2
	int status;
	pid_t pid;
d102 12
a113 14
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		lka_shutdown();
		break;
	case SIGCHLD:
		do {
			pid = waitpid(-1, &status, WNOHANG);
		} while (pid > 0 || (pid == -1 && errno == EINTR));
		break;
	default:
		fatalx("lka_sig_handler: unexpected signal");
	}
}
d115 9
a123 19
void
lka_dispatch_parent(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_PARENT];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d128 21
a148 3
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
d151 2
a152 7
	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("lka_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
d154 6
a159 4
			if ((env->sc_rules_reload = calloc(1, sizeof(*env->sc_rules))) == NULL)
				fatal("mfa_dispatch_parent: calloc");
			if ((env->sc_maps_reload = calloc(1, sizeof(*env->sc_maps))) == NULL)
				fatal("mfa_dispatch_parent: calloc");
d162 1
a162 3
			break;
		case IMSG_CONF_RULE: {
			struct rule *rule = imsg.data;
d164 2
a165 3
			IMSG_SIZE_CHECK(rule);

			rule = calloc(1, sizeof(*rule));
d167 2
a168 3
				fatal("mfa_dispatch_parent: calloc");
			*rule = *(struct rule *)imsg.data;

d171 1
a171 7
			break;
		}
		case IMSG_CONF_CONDITION: {
			struct rule *r = TAILQ_LAST(env->sc_rules_reload, rulelist);
			struct cond *cond = imsg.data;

			IMSG_SIZE_CHECK(cond);
d173 3
a175 1
			cond = calloc(1, sizeof(*cond));
d177 4
a180 2
				fatal("mfa_dispatch_parent: calloc");
			*cond = *(struct cond *)imsg.data;
d182 8
a189 7
			TAILQ_INSERT_TAIL(&r->r_conditions, cond, c_entry);
			break;
		}
		case IMSG_CONF_MAP: {
			struct map *m = imsg.data;

			IMSG_SIZE_CHECK(m);
d191 3
a193 15
			m = calloc(1, sizeof(*m));
			if (m == NULL)
				fatal("mfa_dispatch_parent: calloc");
			*m = *(struct map *)imsg.data;

			TAILQ_INIT(&m->m_contents);
			TAILQ_INSERT_TAIL(env->sc_maps_reload, m, m_entry);
			break;
		}
		case IMSG_CONF_RULE_SOURCE: {
			struct rule *rule = TAILQ_LAST(env->sc_rules_reload, rulelist);
			char *sourcemap = imsg.data;
			void *temp = env->sc_maps;

			/* map lookup must be done in the reloaded conf */
d195 1
a195 1
			rule->r_sources = map_findbyname(env, sourcemap);
d197 7
a203 11
				fatalx("maps inconsistency");
			env->sc_maps = temp;
			break;
		}
		case IMSG_CONF_MAP_CONTENT: {
			struct map *m = TAILQ_LAST(env->sc_maps_reload, maplist);
			struct mapel *mapel = imsg.data;
			
			IMSG_SIZE_CHECK(mapel);
			
			mapel = calloc(1, sizeof(*mapel));
d205 4
a208 2
				fatal("mfa_dispatch_parent: calloc");
			*mapel = *(struct mapel *)imsg.data;
d210 1
a210 5
			TAILQ_INSERT_TAIL(&m->m_contents, mapel, me_entry);
			break;
		}
		case IMSG_CONF_END: {			
			/* switch and destroy old ruleset */
a216 87
			break;
		}
		case IMSG_PARENT_FORWARD_OPEN: {
			int fd;
			struct forward_req	*fwreq = imsg.data;
			struct lkasession	key;
			struct lkasession	*lkasession;
			struct path *path;

			IMSG_SIZE_CHECK(fwreq);

			key.id = fwreq->id;
			lkasession = SPLAY_FIND(lkatree, &env->lka_sessions, &key);
			if (lkasession == NULL)
				fatal("lka_dispatch_parent: lka session is gone");
			fd = imsg.fd;
			--lkasession->pending;

			strlcpy(lkasession->path.pw_name, fwreq->pw_name,
			    sizeof(lkasession->path.pw_name));
			lkasession->path.flags |= F_PATH_FORWARDED;

			/* received a descriptor, we have a forward file ... */
			if (fd != -1) {
				if (! forwards_get(fd, &lkasession->expandtree)) {
					lkasession->ss.code = 530;
					lkasession->flags |= F_ERROR;					
				}
				close(fd);
				lkasession->path.flags |= F_PATH_FORWARDED;
				lka_expand_pickup(env, lkasession);
				break;
			}

			/* did not receive a descriptor but expected one ... */
			if (! fwreq->status) {
				lkasession->ss.code = 530;
				lkasession->flags |= F_ERROR;
				lka_expand_pickup(env, lkasession);
				break;
			}

			/* no forward file, convert pw_name to a struct path ... */
			path = path_dup(&lkasession->path);
			strlcpy(path->pw_name, fwreq->pw_name, sizeof(path->pw_name));
			TAILQ_INSERT_TAIL(&lkasession->deliverylist, path, entry);			
			lka_expand_pickup(env, lkasession);
			break;
		}
		case IMSG_CTL_VERBOSE: {
			int verbose;

			IMSG_SIZE_CHECK(&verbose);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		}
		default:
			log_warnx("lka_dispatch_parent: got imsg %d",
			    imsg.hdr.type);
			fatalx("lka_dispatch_parent: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
lka_dispatch_mfa(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_MFA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
a217 2
		}
	}
d219 34
a252 139
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("lka_dispatch_mfa: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_LKA_MAIL: {
			struct submit_status	 *ss = imsg.data;

			IMSG_SIZE_CHECK(ss);

			ss->code = 530;

			if (ss->u.path.user[0] == '\0' && ss->u.path.domain[0] == '\0')
				ss->code = 250;
			else
				if (lka_verify_mail(env, &ss->u.path))
					ss->code = 250;

			imsg_compose_event(iev, IMSG_LKA_MAIL, 0, 0, -1,
				ss, sizeof(*ss));

			break;
		}
		case IMSG_LKA_RULEMATCH: {
			struct submit_status	*ss = imsg.data;
			struct rule *r;

			IMSG_SIZE_CHECK(ss);

			ss->code = 530;

			r = ruleset_match(env, ss->msg.tag, &ss->u.path, &ss->ss);
			if (r != NULL) {
				ss->code = 250;
				ss->u.path.rule = *r;
			}

			imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RULEMATCH, 0, 0, -1,
			    ss, sizeof(*ss));

			break;
		}
		case IMSG_LKA_RCPT: {
			struct submit_status	*ss = imsg.data;
			struct lkasession	*lkasession;
			struct path		*path;

			IMSG_SIZE_CHECK(ss);

			ss->code = 250;
			path = &ss->u.path;

			lkasession = lka_session_init(env, ss);

			if (! lka_resolve_path(env, lkasession, path))
				lka_session_fail(env, lkasession, ss);
			else
				lka_expand_pickup(env, lkasession);

			break;
		}
		default:
			log_warnx("lka_dispatch_mfa: got imsg %d",
			    imsg.hdr.type);
			fatalx("lka_dispatch_mfa: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
lka_dispatch_mta(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_MTA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("lka_dispatch_mta: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_LKA_SECRET: {
			struct secret	*query = imsg.data;
			char		*secret = NULL;
			struct map	*map = NULL;
			char		*mapname = "secrets";

			IMSG_SIZE_CHECK(query);

			/* should not happen */
			map = map_findbyname(env, mapname);
			if (map == NULL)
				fatalx("secrets map has  disappeared");
			secret = map_lookup(env, map->m_id, query->host);

			log_debug("secret for %s %s", query->host,
			    secret ? "found" : "not found");
			
			query->secret[0] = '\0';

			if (secret == NULL) {
				log_warnx("failed to lookup %s in the %s map",
				    query->host, mapname);
			} else if (! lka_encode_credentials(query->secret,
			    sizeof(query->secret), secret)) {
				log_warnx("parse error for %s in the %s map",
				    query->host, mapname);
a253 45

			imsg_compose_event(iev, IMSG_LKA_SECRET, 0, 0, -1, query,
			    sizeof(*query));
			free(secret);
			break;
		}

		case IMSG_DNS_MX:
		case IMSG_DNS_PTR: {
			struct dns	*query = imsg.data;

			IMSG_SIZE_CHECK(query);
			dns_async(env, iev, imsg.hdr.type, query);
			break;
		}

		default:
			log_warnx("lka_dispatch_mta: got imsg %d",
			    imsg.hdr.type);
			fatalx("lka_dispatch_mta: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
lka_dispatch_smtp(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_SMTP];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
a254 2
		}
	}
d256 2
a257 48
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("lka_dispatch_smtp: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_DNS_PTR: {
			struct dns	*query = imsg.data;

			IMSG_SIZE_CHECK(query);
			dns_async(env, iev, IMSG_DNS_PTR, query);
			break;
		}
		default:
			log_warnx("lka_dispatch_smtp: got imsg %d",
			    imsg.hdr.type);
			fatalx("lka_dispatch_smtp: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
lka_dispatch_queue(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_QUEUE];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d262 1
a262 20
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("lka_dispatch_queue: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("lka_dispatch_queue: got imsg %d",
			   imsg.hdr.type);
			fatalx("lka_dispatch_queue: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d266 1
a266 1
lka_dispatch_runner(int sig, short event, void *p)
d268 2
a269 19
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_RUNNER];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}
d271 12
a282 18
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("lka_dispatch_runner: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("lka_dispatch_runner: got imsg %d",
			    imsg.hdr.type);
			fatalx("lka_dispatch_runner: unexpected imsg");
		}
		imsg_free(&imsg);
a283 1
	imsg_event_add(iev);
d314 6
a319 6
		{ PROC_PARENT,	lka_dispatch_parent },
		{ PROC_MFA,	lka_dispatch_mfa },
		{ PROC_QUEUE,	lka_dispatch_queue },
		{ PROC_SMTP,	lka_dispatch_smtp },
		{ PROC_RUNNER,	lka_dispatch_runner },
		{ PROC_MTA,	lka_dispatch_mta }
d345 1
@


1.100
log
@the map api becomes backend-agnostic with initial support for db(3) and
stdio(3) backends, though for now we only enable db(3). this is the first
commit of a serie to improve maps and everything related.

idea discussed with and diff okay jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.99 2010/02/17 08:40:24 gilles Exp $	*/
d1034 1
a1034 1
		if (strlen(username) >= MAX_LOCALPART_SIZE)
@


1.99
log
@localpart of a struct path may legally exceed MAXLOGNAME, causing lka to
fatalx() on a lowercase() call in some cases. make sure lka uses a buffer
capable of holding a localpart, and do not attempt getpwnam() if we know
it's going to fail anyway...

issue reported by Ben Lindstrom <mouring@@eviladmin.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.98 2010/01/03 14:37:37 chl Exp $	*/
d419 2
a420 1
			char		*map = "secrets";
d424 5
a428 1
			secret = map_dblookupbyname(env, map, query->host);
d437 1
a437 1
				    query->host, map);
d441 1
a441 1
				    query->host, map);
@


1.98
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.97 2009/12/15 00:23:38 jacekm Exp $	*/
d1011 1
a1011 1
		char username[MAXLOGNAME];
d1029 3
d1035 1
a1035 1
			break;
@


1.97
log
@Must aim better.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.96 2009/12/14 19:56:55 jacekm Exp $	*/
d259 9
@


1.96
log
@Tweak the logic behind setting the fd limits so that smtpd is less likely
to get upset by custom soft/hard ulimit settings.

Suggested by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.95 2009/12/13 22:02:55 jacekm Exp $	*/
d1040 1
a1040 1
				return 9;
@


1.95
log
@Use safe fd limits in smtp, lka, queue, and control.  Removes a
possibility for fd-starvation fatal when under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.94 2009/11/13 11:27:51 jacekm Exp $	*/
d669 1
a669 1
	 * lka opens all kinds of files and sockets, so bump the limit further.
d672 1
a672 1
	fdlimit(getdtablesize() * 2);
@


1.94
log
@Log FQDN and IP of the server we handed mail to.  As a bonus, don't delay
logging of successful deliveries until all MXs were tried, plus add logging
of 5yz replies.

tested by todd@@, "reads ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.93 2009/11/10 14:46:18 jacekm Exp $	*/
d667 6
@


1.93
log
@In relay case, avoid freeing garbage pointer by copying the required struct
from the temporary imsg buffer.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.92 2009/11/10 10:25:11 jacekm Exp $	*/
d436 2
a437 2
		case IMSG_DNS_A:
		case IMSG_DNS_MX: {
@


1.92
log
@move format expansion to the right place, from gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.91 2009/11/10 09:53:40 jacekm Exp $	*/
d986 1
@


1.91
log
@sync code with comment, from gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.90 2009/11/10 01:09:24 gilles Exp $	*/
a871 6
	if (lka_expand(path->rule.r_value.path, sizeof(struct path), path) >=
		sizeof(struct path)) {
		log_debug("expansion failed...");
		return 0;
	}

d966 2
a1019 4
		if (lka_expand(path->rule.r_value.path,
			sizeof(path->rule.r_value.path), path) >=
		    sizeof(path->rule.r_value.path))
			break;
@


1.90
log
@- add comments to explain the logic in the aliases expansion loop
- more cosmethic changes to help readability
- fix memory leaks
- if deliverylist is empty, it means something went bad during expansion,
  reject recipient
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.89 2009/11/10 00:42:55 gilles Exp $	*/
d962 1
a962 1
	if (TAILQ_FIRST(&lkasession->deliverylist) ||
@


1.89
log
@pfff remove a comment i pasted to help me refactor code ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.85 2009/11/09 23:49:34 gilles Exp $	*/
d886 4
d914 1
a914 1
	struct expand_node *expnode, *rmnode = NULL;
d916 1
a916 1
	struct path *respath = NULL;
a918 3
	rmnode = NULL;

	log_debug("expand iteration: %d", lkasession->iterations);
a919 4
		struct path path;

		if (rmnode)
			expandtree_decrement_node(&lkasession->expandtree, rmnode);
d921 1
d926 1
a926 2
		rmnode = expnode;

d931 5
a935 3
		respath = path_dup(&path);

		if (! lka_resolve_path(env, lkasession, respath))
d938 2
d943 1
a943 3
	if (rmnode)
		expandtree_decrement_node(&lkasession->expandtree, rmnode);

d948 1
d955 31
a1176 31
}

void
lka_expansion_done(struct smtpd *env, struct lkasession *lkasession)
{
	struct message message;
	struct path *path;

	if (lkasession->flags & F_ERROR) {
		lka_clear_expandtree(&lkasession->expandtree);
		lka_clear_deliverylist(&lkasession->deliverylist);
		imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT, 0, 0,
		    -1, &lkasession->ss, sizeof(struct submit_status));
	}
	else if (TAILQ_FIRST(&lkasession->deliverylist) == NULL) {
		queue_commit_envelopes(env, &lkasession->message);
	}
	else {
		message = lkasession->message;

		while ((path = TAILQ_FIRST(&lkasession->deliverylist)) != NULL) {
			message.recipient = *path;
			queue_submit_envelope(env, &message);

			TAILQ_REMOVE(&lkasession->deliverylist, path, entry);
			free(path);
		}
		queue_commit_envelopes(env, &message);
	}

	lka_session_destroy(env, lkasession);
@


1.88
log
@more cleanup, let lka_resolve_path() request forward files and populate
expandtree, this makes a lot of code clearer and removes quite a bit of
complexity from various places.
@
text
@a963 9
	/*
			else if (path->flags & F_PATH_VIRTUAL) {
				if (! aliases_virtual_get(env, ss->u.path.cond->c_map,
					&lkasession->expandtree, &ss->u.path))
					err = 1;
			}
	 */


@


1.87
log
@cosmethic changes, code reordering, no functionnal change
@
text
@a346 1
			int			 err = 0;
a353 12
			if (! lka_resolve_path(env, lkasession, path)) {
				err = 1;
			}

			else if (path->flags & F_PATH_ACCOUNT) {
				lka_request_forwardfile(env, lkasession, path->pw_name);
			}

			else if (path->flags & F_PATH_RELAY) {
				path = path_dup(&ss->u.path);
				TAILQ_INSERT_TAIL(&lkasession->deliverylist, path, entry);
			}
d355 1
a355 13
			else if (path->flags & F_PATH_ALIAS) {
				if (! aliases_get(env, ss->u.path.rule.r_amap,
					&lkasession->expandtree, ss->u.path.user))
					err = 1;
			}

			else if (path->flags & F_PATH_VIRTUAL) {
				if (! aliases_virtual_get(env, ss->u.path.cond->c_map,
					&lkasession->expandtree, &ss->u.path))
					err = 1;
			}

			if (err) {
d357 2
a358 2
				break;
			}
a359 1
			lka_expand_pickup(env, lkasession);
d935 1
d939 1
a939 20
		if (respath->flags & F_PATH_ACCOUNT) {
			if (respath->flags & F_PATH_FORWARDED)
				TAILQ_INSERT_TAIL(&lkasession->deliverylist, respath, entry);
			else
				lka_request_forwardfile(env, lkasession, respath->pw_name);
			expnode->flags |= F_EXPAND_DONE;
		}

		else if (respath->flags & F_PATH_ALIAS) {
			aliases_get(env, lkasessionpath->rule.r_amap,
			    &lkasession->expandtree, respath->user);
			expnode->flags |= F_EXPAND_DONE;
		}

		else if (respath->flags & F_PATH_VIRTUAL) {
			aliases_virtual_get(env, lkasessionpath->cond->c_map,
			    &lkasession->expandtree, respath);
			expnode->flags |= F_EXPAND_DONE;
		}

d960 1
d964 9
d989 3
d1007 5
d1017 3
@


1.86
log
@introduce lka_session_fail() which factors a small piece of code used in
three places: set code to 530, send imsg to notify rejection, kill
lkasession
@
text
@d347 1
d356 1
a356 2
				lka_session_fail(env, lkasession, ss);
				break;
d359 1
a359 1
			if (path->flags & F_PATH_ACCOUNT) {
a360 1
				break;
d363 1
a363 1
			if (path->flags & F_PATH_RELAY) {
d368 1
a368 1
			if (path->flags & F_PATH_ALIAS) {
d370 2
a371 4
					&lkasession->expandtree, ss->u.path.user)) {
					lka_session_fail(env, lkasession, ss);
					break;
				}
d374 1
a374 1
			if (path->flags & F_PATH_VIRTUAL) {
d376 7
a382 4
					&lkasession->expandtree, &ss->u.path)) {
					lka_session_fail(env, lkasession, ss);
					break;
				}
@


1.85
log
@- add a reference count and flags to struct expand_node
- during expansion, no longer create a new node for each result but try to
  lookup for an existing equivalent node and increment its reference count
  so that: a) we save on memory, b) we don't need to expand the same users
  again and again just because they keep appearing in expansion results.
- while expanding, flag nodes as F_EXPAND_DONE so that we know which nodes
  we already processed
- be smarter when expanding, if we have a clue that an iteration has not
  brought any new result (because no new nodes were added and all existing
  nodes have F_EXPAND_DONE), end expansion and proceed to delivery.
- various small cleanups

discussed with jacekm@@ yesterday, rebuild aliases db, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.84 2009/11/09 22:28:08 gilles Exp $	*/
d69 1
d355 1
a355 4
				ss->code = 530;
				imsg_compose_event(iev, IMSG_LKA_RCPT, 0, 0, -1,
				    ss, sizeof(*ss));
				lka_session_destroy(env, lkasession);
d372 1
a372 4
					ss->code = 530;
					imsg_compose_event(iev, IMSG_LKA_RCPT, 0, 0, -1,
					    ss, sizeof(*ss));
					lka_session_destroy(env, lkasession);
d380 1
a380 4
					ss->code = 530;
					imsg_compose_event(iev, IMSG_LKA_RCPT, 0, 0, -1,
					    ss, sizeof(*ss));
					lka_session_destroy(env, lkasession);
d1150 9
@


1.84
log
@support the userpart+foobar@@domainpart syntax which got wiped when i wrote
the virtual domains support as it was in my way. this time, make it work as
it should: userpart+foobar@@domainpart becomes:

path->user = userpart+foobar
path->domain = domainpart
path->pw_name = userpart

discussed quickly with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.83 2009/11/08 23:08:56 gilles Exp $	*/
d900 1
d950 2
a951 1
	
d955 7
a961 5
		if (rmnode) {
			expandtree_remove(&lkasession->expandtree, rmnode);
			free(rmnode);
			rmnode = NULL;
		}
d977 1
d981 3
a983 3
			if (aliases_get(env, lkasessionpath->rule.r_amap,
				&lkasession->expandtree, respath->user))
				done = 0;
d987 3
a989 3
			if (aliases_virtual_get(env, lkasessionpath->cond->c_map,
				&lkasession->expandtree, respath))
				done = 0;
d994 2
a995 4
	if (rmnode) {
		expandtree_remove(&lkasession->expandtree, rmnode);
		free(rmnode);
	}
d1001 1
a1001 1
	if (RB_ROOT(&lkasession->expandtree) == NULL)
d1010 1
a1010 1
	if (IS_RELAY(*path)) {
d1101 1
a1101 1
		expandtree_remove(expandtree, expnode);
@


1.83
log
@rework a bit expansion and data structures involved in the expansion so we
no longer have a direct mapping between structures saved in aliases/virtual
db and structures used at runtime during expansion.

side effects ? struct alias is smaller, databases are smaller and it is no
longer necessary to rebuild aliases/virtual databases each time jacekm@@ or
I make changes to some obscure structure used indirectely during expansion

rebuild databases, flush queues, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.82 2009/11/08 21:40:05 gilles Exp $	*/
d1017 1
d1021 4
@


1.82
log
@- make aliases expansion use a rb tree instead of a tail queue, the code
  doesn't take advantage of the new structure yet, but this was a needed
  change for upcoming improvements.
- introduce aliasestree_{lookup,insert,remove} to the aliases api
- rename queue_generate_id() to generate_uid() and move it to utils.c as
  it is used all over the place and not only in queue

tree idea discussed with jacekm@@, if you update rebuild aliases db, make
clean and flush queue
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.81 2009/11/08 19:38:26 gilles Exp $	*/
d56 1
a56 1
int		lka_resolve_alias(struct smtpd *, char *tag, struct path *, struct alias *);
d62 1
a62 1
void		lka_clear_aliasestree(struct aliasestree *);
d235 1
a235 1
				if (! forwards_get(fd, &lkasession->aliasestree)) {
d373 1
a373 1
					&lkasession->aliasestree, ss->u.path.user)) {
d384 1
a384 1
					&lkasession->aliasestree, &ss->u.path)) {
d836 1
a836 1
lka_resolve_alias(struct smtpd *env, char *tag, struct path *path, struct alias *alias)
d842 5
a846 5
	switch (alias->type) {
	case ALIAS_USERNAME:
		log_debug("lka_resolve_alias: alias is local username: %s",
		    alias->u.username);
		if (strlcpy(path->pw_name, alias->u.username,
d850 1
a850 1
		if (strlcpy(path->user, alias->u.username,
d864 1
a864 1
		log_debug("lka_resolve_alias: resolved to address: %s@@%s",
d869 3
a871 3
	case ALIAS_FILENAME:
		log_debug("lka_resolve_alias: alias is filename: %s",
		    alias->u.filename);
d873 1
a873 1
		strlcpy(path->u.filename, alias->u.filename,
d877 3
a879 3
	case ALIAS_FILTER:
		log_debug("lka_resolve_alias: alias is filter: %s",
		    alias->u.filter);
d881 1
a881 1
		strlcpy(path->rule.r_value.command, alias->u.filter + 2,
d886 11
a896 3
	case ALIAS_ADDRESS:
		log_debug("lka_resolve_alias: alias is address: %s@@%s",
		    alias->u.path.user, alias->u.path.domain);
a897 1
		*path = alias->u.path;
d900 2
a901 2
	case ALIAS_INCLUDE:
		fatalx("lka_resolve_alias: unexpected type");
d943 1
a943 2
	struct alias *rmalias = NULL;
	struct alias *alias;
d948 3
a950 2
	rmalias = NULL;
	RB_FOREACH(alias, aliasestree, &lkasession->aliasestree) {
d953 4
a956 4
		if (rmalias) {
			aliasestree_remove(&lkasession->aliasestree, rmalias);
			free(rmalias);
			rmalias = NULL;
d958 1
a958 1
		rmalias = alias;
d960 1
a960 1
		if (! lka_resolve_alias(env, lkasession->message.tag, &path, alias))
d977 1
a977 1
				&lkasession->aliasestree, respath->user))
d983 1
a983 1
				&lkasession->aliasestree, respath))
d989 3
a991 3
	if (rmalias) {
		aliasestree_remove(&lkasession->aliasestree, rmalias);
		free(rmalias);
d998 1
a998 1
	if (RB_ROOT(&lkasession->aliasestree) == NULL)
d1088 1
a1088 1
lka_clear_aliasestree(struct aliasestree *aliasestree)
d1090 1
a1090 1
	struct alias *alias;
d1092 3
a1094 3
	while ((alias = RB_ROOT(aliasestree)) != NULL) {
		aliasestree_remove(aliasestree, alias);
		free(alias);
d1145 1
a1145 1
	RB_INIT(&lkasession->aliasestree);
d1178 1
a1178 1
		lka_clear_aliasestree(&lkasession->aliasestree);
@


1.81
log
@first commit of a serie to cleanup, simplify and improve aliases resolution
which is probably the most complex code in smtpd right now. no longer use a
single list to hold aliases to be resolved and resolved aliases, and do not
use struct alias to hold resolved aliases. instead use a delivery list that
is a list of struct path, and populate it with resolved aliases.

idea discussed with jacekm@@, this needs some testing to make sure it does
not introduce a regression with aliases. flush your queue and make clean.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.80 2009/11/05 12:26:19 gilles Exp $	*/
d62 1
a62 1
void		lka_clear_aliaseslist(struct aliaseslist *);
d235 1
a235 1
				if (! forwards_get(fd, &lkasession->aliaseslist)) {
d373 1
a373 1
					&lkasession->aliaseslist, ss->u.path.user)) {
d384 1
a384 1
					&lkasession->aliaseslist, &ss->u.path)) {
d943 1
a943 1
	TAILQ_FOREACH(alias, &lkasession->aliaseslist, entry) {
d947 1
a947 1
			TAILQ_REMOVE(&lkasession->aliaseslist, rmalias, entry);
d970 1
a970 1
				&lkasession->aliaseslist, respath->user))
d976 1
a976 1
				&lkasession->aliaseslist, respath))
d983 1
a983 1
		TAILQ_REMOVE(&lkasession->aliaseslist, rmalias, entry);
d991 1
a991 1
	if (TAILQ_FIRST(&lkasession->aliaseslist) == NULL)
d1081 1
a1081 1
lka_clear_aliaseslist(struct aliaseslist *aliaseslist)
d1085 2
a1086 2
	while ((alias = TAILQ_FIRST(aliaseslist)) != NULL) {
		TAILQ_REMOVE(aliaseslist, alias, entry);
d1133 1
a1133 1
	lkasession->id = queue_generate_id();
d1138 1
a1138 1
	TAILQ_INIT(&lkasession->aliaseslist);
d1171 1
a1171 1
		lka_clear_aliaseslist(&lkasession->aliaseslist);
a1193 1

@


1.80
log
@another log_debug() cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.79 2009/11/05 12:06:41 gilles Exp $	*/
d54 2
a55 1
void		lka_expand_rcpt(struct smtpd *, struct aliaseslist *, struct lkasession *);
d59 1
a59 1
int		lka_resolve_path(struct smtpd *, struct path *);
d63 1
a66 1
int		lka_expand_rcpt_iteration(struct smtpd *, struct aliaseslist *, struct lkasession *);
d68 1
d218 1
a218 1
			struct alias		 alias;
d229 4
d237 1
a237 1
					lkasession->flags |= F_ERROR;
d240 2
a241 1
				lka_expand_rcpt(env, &lkasession->aliaseslist, lkasession);
d249 1
a249 1
				lka_expand_rcpt(env, &lkasession->aliaseslist, lkasession);
d253 5
a257 7
			/* no forward file, convert pw_name to a struct alias ... */
			alias_parse(&alias, fwreq->pw_name);

			/* then resolve alias and get back to expanding the aliases list */
			lka_resolve_alias(env, lkasession->message.tag, &lkasession->message.recipient, &alias);
			queue_submit_envelope(env, &lkasession->message);
			lka_expand_rcpt(env, &lkasession->aliaseslist, lkasession);
d345 1
a345 1
			int ret = 0;
d349 2
a350 6
			if (IS_RELAY(ss->u.path)) {
				ss->code = 250;
				queue_submit_envelope(env, &ss->msg);
				queue_commit_envelopes(env, &ss->msg);
				break;
			}
d352 2
a353 1
			if (! lka_resolve_path(env, &ss->u.path)) {
d357 1
d361 2
a362 5
			ss->code = 250;
			lkasession = lka_session_init(env, ss);
			if (lkasession->path.flags & F_PATH_ACCOUNT) {
				log_debug("lka_dispatch_mfa: path is not expandable");
				lka_request_forwardfile(env, lkasession, lkasession->path.user);
d365 4
a368 6
			else if (lkasession->path.flags & F_PATH_ALIAS) {
				log_debug("lka_dispatch_mfa: path is aliases-expandable");
				ret = aliases_get(env,
				    lkasession->path.rule.r_amap,
				    &lkasession->aliaseslist,
				    lkasession->path.user);
d370 10
a379 4
			else if (lkasession->path.flags & F_PATH_VIRTUAL) {
				log_debug("lka_dispatch_mfa: path is virtual-expandable");
				ret = aliases_virtual_get(env, lkasession->path.cond->c_map,
				    &lkasession->aliaseslist, &lkasession->path);
a380 2
			else
				fatal("lka_dispatch_mfa: path with illegal flag");
d382 9
a390 9
			log_debug("lka_dispatch_mfa: expanded to %d envelopes", ret);

			if (ret == 0) {
				/* No aliases ... */
				ss->code = 530;
				imsg_compose_event(iev, IMSG_LKA_RCPT, 0, 0,
				    -1, ss, sizeof(*ss));
				lka_session_destroy(env, lkasession);
				break;
d393 1
a393 2
			lka_expand_rcpt(env, &lkasession->aliaseslist, lkasession);

d908 1
a908 1
lka_expand_rcpt(struct smtpd *env, struct aliaseslist *aliases, struct lkasession *lkasession)
a910 2
	struct alias	*alias;
	struct message	message;
d916 1
a916 1
		ret = lka_expand_rcpt_iteration(env, &lkasession->aliaseslist, lkasession);
d929 1
a929 22
	if (lkasession->flags & F_ERROR) {
		lka_clear_aliaseslist(&lkasession->aliaseslist);
		imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT, 0, 0,
		    -1, &lkasession->ss, sizeof(struct submit_status));
	}
	else if (TAILQ_FIRST(&lkasession->aliaseslist) == NULL) {
		queue_commit_envelopes(env, &lkasession->message);
	}
	else {
		message = lkasession->message;

		while ((alias = TAILQ_FIRST(&lkasession->aliaseslist)) != NULL) {
			lka_resolve_alias(env, message.tag, &message.recipient, alias);
			queue_submit_envelope(env, &message);

			TAILQ_REMOVE(&lkasession->aliaseslist, alias, entry);
			free(alias);
		}
		queue_commit_envelopes(env, &message);
	}

	lka_session_destroy(env, lkasession);
d933 1
a933 1
lka_expand_rcpt_iteration(struct smtpd *env, struct aliaseslist *aliases, struct lkasession *lkasession)
d943 3
a945 1
	TAILQ_FOREACH(alias, aliases, entry) {
d947 1
a947 1
			TAILQ_REMOVE(aliases, rmalias, entry);
d951 1
a951 14
		
		if (alias->type == ALIAS_ADDRESS) {
			respath = &alias->u.path;
			lka_rcpt_action(env, lkasession->message.tag, respath);
			lka_resolve_path(env, respath);

			if (alias->u.path.flags & F_PATH_VIRTUAL) {
				if (aliases_virtual_get(env,
					respath->cond->c_map,
					aliases, respath)) {
					rmalias = alias;
					done = 0;
				}
			}
d953 13
a965 7
			if (alias->u.path.flags & F_PATH_ALIAS) {
				if (aliases_get(env, lkasessionpath->rule.r_amap,
					aliases, alias->u.username)) {
					done = 0;
					rmalias = alias;
				}
			}
d967 2
a968 2
		
		else if (alias->type == ALIAS_USERNAME) {
d970 1
a970 1
				aliases, alias->u.username)) {
d972 5
a976 5
				rmalias = alias;
			}
			else {
				lka_request_forwardfile(env, lkasession,
				    alias->u.username);
a977 2
				rmalias = alias;
			}
d979 1
d981 1
d983 1
a983 1
		TAILQ_REMOVE(aliases, rmalias, entry);
a984 1
		rmalias = NULL;
d987 1
a987 1
	if (!done && lkasession->iterations == 5)
d989 1
d991 1
a991 1
	if (TAILQ_FIRST(aliases) == NULL)
d998 4
a1001 3
lka_resolve_path(struct smtpd *env, struct path *path){

	if (path->cond == NULL)
d1003 1
d1012 1
a1012 3
		/* recipient is to be relayed, no need for more processing */
		if (IS_RELAY(*path))
			return 1;
a1013 1
		lowercase(username, path->user, sizeof(username));
d1091 11
d1139 1
d1163 32
@


1.79
log
@cleanup a bit the log_debug output
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.78 2009/11/05 12:02:22 gilles Exp $	*/
d863 2
a864 1
		log_debug("RESOLVED TO %s@@%s", path->user, path->domain);
@


1.78
log
@- introduce lka_session_destroy() which replaces the splay tree removal and
  free(lkasession) in lka_expand_rcpt()
- while at it, plug a very very unlikely memory leak which i spotted while
  reviewing the logic
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.77 2009/11/05 10:27:24 gilles Exp $	*/
d361 1
a361 1
				log_debug("F_PATH_ACCOUNT");
d366 1
a366 1
				log_debug("F_PATH_ALIAS");
a370 1
				log_debug("\tALIASES RESOLVED: %d", ret);
d373 1
a373 1
				log_debug("F_PATH_VIRTUAL");
a375 1
				log_debug("\tVIRTUAL RESOLVED: %d", ret);
d380 2
d843 2
a844 1
		log_debug("USERNAME: %s", alias->u.username);
d868 2
a869 1
		log_debug("FILENAME: %s", alias->u.filename);
d876 2
a877 1
		log_debug("FILTER: %s", alias->u.filter);
d885 2
a886 1
		log_debug("ADDRESS: %s@@%s", alias->u.path.user, alias->u.path.domain);
@


1.77
log
@- move a couple prototypes in smtpd.h
- remove prototypes from deprecated functions
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.76 2009/11/03 22:57:41 gilles Exp $	*/
d66 1
d387 1
d945 2
a946 2
	SPLAY_REMOVE(lkatree, &env->lka_sessions, lkasession);
	free(lkasession);
d1154 7
@


1.76
log
@teach makemap how to build a set, which is a map containing only keys.
smtpd is now capable of looking primary domains at runtime in a set, which
means that the following becomes possible:

	map "primary" { source db "/etc/mail/primary.db" }
	accept for domain map "primary" deliver to mbox

while at it fix a couple bugs in the aliases resolution path which caused
recipients to bounce if a ruleset did not have an "accept for local" rule

"diff reads good" jacekm@@, flush queue & make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.75 2009/11/03 20:55:23 gilles Exp $	*/
d54 2
d57 1
a57 6
int		lka_forward_file(struct passwd *);
size_t		lka_expand(char *, size_t, struct path *);
int		lka_resolve_alias(struct smtpd *, char *tag, struct path *, struct alias *);
int		lka_parse_include(char *);
int		lka_check_source(struct smtpd *, struct map *, struct sockaddr_storage *);
int		lka_match_mask(struct sockaddr_storage *, struct netaddr *);
d59 2
a60 3
void		lka_expand_rcpt(struct smtpd *, struct aliaseslist *, struct lkasession *);
int		lka_expand_rcpt_iteration(struct smtpd *, struct aliaseslist *, struct lkasession *);
void		lka_rcpt_action(struct smtpd *, char *, struct path *);
d63 3
a65 5
struct lkasession *lka_session_init(struct smtpd *, struct submit_status *);
void		lka_request_forwardfile(struct smtpd *, struct lkasession *, char *);
struct rule    *ruleset_match(struct smtpd *, char *, struct path *, struct sockaddr_storage *);
void		 queue_submit_envelope(struct smtpd *, struct message *);
void		 queue_commit_envelopes(struct smtpd *, struct message*);
@


1.75
log
@this commit removes the hardcoded special "aliases" map and brings support
for multiple aliases maps that can be attached at the rule level. with it,
you can for example define different aliases maps for different domains or
different aliases maps for the same domain depending on the client source:

map "localiases" { source db "/etc/mail/localiases.db" }
map "netaliases" { source db "/etc/mail/netaliases.db" }

accept from 192.168.0.0/16 for local alias "localiases" deliver to mbox
accept from all for local alias "netaliases" deliver to mbox

idea discussed with jacekm@@ and various other hackers, diff contains some
bug fixes too which were not part of the original diff. man page follows
very shortly ... make clean & flush queue !
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.74 2009/11/03 19:13:34 gilles Exp $	*/
d451 1
a451 1
			secret = map_dblookup(env, map, query->host);
d841 2
d851 6
a856 6
		if (path->user[0] == '\0') {
			if (strlcpy(path->user, alias->u.username,
				sizeof(path->user)) >= sizeof(path->user))
				return 0;
		}
		if (path->domain[0] == '\0') {
d861 5
d1025 4
@


1.74
log
@- remove a useless member of struct cond
- have virtual related functions take a map id instead of a map
- shrink a tiny bit ruleset matching
- add missing lka_resolve_path() call in aliases resolution leading to
  issues spotted by nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.73 2009/11/03 10:56:51 nicm Exp $	*/
d372 4
a375 1
				ret = aliases_get(env, &lkasession->aliaseslist, lkasession->path.user);
d952 2
a953 1
	struct path *lkasessionpath;
d965 19
a983 5
			lka_rcpt_action(env, lkasession->message.tag, &alias->u.path);
			lka_resolve_path(env, &alias->u.path);
			if (aliases_virtual_get(env, alias->u.path.cond->c_map, aliases, &alias->u.path)) {
				rmalias = alias;
				done = 0;
d988 2
a989 1
			if (aliases_get(env, aliases, alias->u.username)) {
d994 2
a995 1
				lka_request_forwardfile(env, lkasession, alias->u.username);
d1030 1
a1030 1
		if (aliases_exist(env, username)) {
@


1.73
log
@Don't need regex.h and remove two declarations that are now in smtpd.h.

ok jacekm
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.72 2009/10/25 21:50:46 gilles Exp $	*/
d377 1
a377 1
				ret = aliases_virtual_get(env, lkasession->path.cond->c_match,
d962 2
a963 1
			if (aliases_virtual_get(env, alias->u.path.cond->c_match, aliases, &alias->u.path)) {
d1030 1
a1030 1
		if (aliases_virtual_exist(env, path->cond->c_match, path)) {
@


1.72
log
@fix the aliases resolution path so that smtpd does not accidentally skip
recipients when an alias resolves to more than one.

issue spotted by martijn@@bunix.org
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.71 2009/10/19 20:48:13 gilles Exp $	*/
a34 1
#include <regex.h>
a56 2
int		aliases_exist(struct smtpd *, char *);
int		aliases_get(struct smtpd *, struct aliaseslist *, char *);
@


1.71
log
@currently, smtpd is capable of having multiple listeners with different
options but they will all share the same ruleset. this means that there
is no way to have a rule apply to a session established on one listener
but not applied on another.

this commit brings initial support for tagging listeners and having the
rules able to match these specific listeners. The following will define
a rule which will only apply to interfaces tagged as "mynet":

listen on lo0			# implicit lo0 tag
listen on fxp0 tag mynet
listen on fxp1 tag mynet

accept on mynet for domain "example.org" deliver to mbox
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.70 2009/10/18 21:45:47 gilles Exp $	*/
d259 1
d376 1
d382 1
a927 1
		queue_submit_envelope(env, &lkasession->message);
@


1.70
log
@actually, we want to resolve C_ALL and C_NET, we just don't want to do it
when their action is to be relayed.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.69 2009/10/18 19:53:49 gilles Exp $	*/
d60 1
a60 1
int		lka_resolve_alias(struct smtpd *, struct path *, struct alias *);
d67 1
a67 1
void		lka_rcpt_action(struct smtpd *, struct path *);
d72 1
a72 1
struct rule    *ruleset_match(struct smtpd *, struct path *, struct sockaddr_storage *);
d258 1
a258 1
			lka_resolve_alias(env, &lkasession->message.recipient, &alias);
d333 1
a333 1
			r = ruleset_match(env, &ss->u.path, &ss->ss);
d836 1
a836 1
lka_resolve_alias(struct smtpd *env, struct path *path, struct alias *alias)
d857 1
a857 1
		lka_rcpt_action(env, path);
d879 1
a879 1
		lka_rcpt_action(env, path);
d932 1
a932 1
			lka_resolve_alias(env, &message.recipient, alias);
d962 1
a962 1
			lka_rcpt_action(env, &alias->u.path);
d1044 1
a1044 1
lka_rcpt_action(struct smtpd *env, struct path *path)
d1052 1
a1052 1
	r = ruleset_match(env, path, NULL);
@


1.69
log
@do not attempt to resolve aliases for C_ALL and C_NET destinations
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.68 2009/10/16 22:26:27 gilles Exp $	*/
d999 2
d1005 4
a1035 3
	case C_ALL:
	case C_NET:
		return 1;
@


1.68
log
@as of now, "accept for all deliver to mbox" is a valid syntax, sadly lka is
not aware of this and will fatal() when it attempts to resolve a recipient
for a destination that's not C_DOM or C_VDOM.

issue reported by Dorian Buettner <dorian.buettner@@gmx.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.67 2009/10/12 22:34:37 gilles Exp $	*/
a998 2
	case C_ALL:
	case C_NET:
d1030 3
@


1.67
log
@- fix a null deref which could happen after a couple iterations of the
  aliases/virtual domains resolution code.

- fix a logic bug which caused virtual domains not to be correctly
  handled after one iteration of the aliases resolution code.

- introduce a few helper functions to help clean up and simplify the
  lka code.

- simplify the IS_EXT/IS_MAILBOX/IS_RELAY macros so they manipulate a
  struct path * instead of the mess of dereferences we were passing them.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.66 2009/10/11 17:40:49 gilles Exp $	*/
d999 2
@


1.66
log
@implement proper virtual domains instead of faking them on top of primary
domains. this means that:

- virtual domains no longer deliver to a local user when not told to
- they no longer attempt to resolve aliases when not told to
- they no longer need an explicit rule in smtpd.conf for EACH domain
- the "virtual" map is no longer hardcoded
- smtpd no longer needs a restart to support a new domain

instead we introduce the: accept for virtual map "mapname" [...] syntax
which refers to a map that can be manipulated at runtime.

idea discussed and okayd with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.65 2009/10/07 18:09:12 gilles Exp $	*/
d70 2
d73 2
d224 1
d235 2
a236 43
			if (fd == -1) {
				if (! fwreq->status) {
					lkasession->ss.code = 530;
					lkasession->flags |= F_ERROR;
				}
				else {
					struct alias *alias;
					struct message message;

					alias = calloc(1, sizeof(struct alias));
					if (alias == NULL)
						fatal("lka_dispatch_parent: calloc");

					alias_parse(alias, fwreq->pw_name);

					message = lkasession->message;

					bzero(&message.recipient, sizeof(struct path));
					strlcpy(message.recipient.domain, lkasession->path.domain,
					    sizeof(message.recipient.domain));

					lka_resolve_alias(env, &message.recipient, alias);
					lka_rcpt_action(env, &message.recipient);

					if (lka_expand(message.recipient.rule.r_value.path,
						sizeof(message.recipient.rule.r_value.path),
						&message.recipient) >=
					    sizeof(message.recipient.rule.r_value.path)) {
						log_debug("expansion failed...");
					}

					imsg_compose_event(env->sc_ievs[PROC_QUEUE],
					    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
					    &message, sizeof(struct message));

					if (! lkasession->pending)
						imsg_compose_event(env->sc_ievs[PROC_QUEUE],
						    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1,
						    &message, sizeof(struct message));
					break;
				}
			}
			else {
d242 2
d245 14
a345 1
			struct message		message;
d347 1
a347 2
			struct forward_req	 fwreq;
			int ret;
d351 1
a351 3
			ss->code = 530;
			
			if (IS_RELAY(ss->u.path.rule.r_action)) {
d353 2
a354 8
				message = ss->msg;
				message.recipient = ss->u.path;
				imsg_compose_event(env->sc_ievs[PROC_QUEUE],
				    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
				    &message, sizeof(struct message));
				imsg_compose_event(env->sc_ievs[PROC_QUEUE],
				    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1,
				    &message, sizeof(struct message));
d359 1
d366 1
a366 14

			lkasession = calloc(1, sizeof(struct lkasession));
			if (lkasession == NULL)
				fatal("lka_dispatch_mfa: calloc");
			lkasession->id = queue_generate_id();
			lkasession->path = ss->u.path;
			lkasession->message = ss->msg;
			lkasession->ss = *ss;

			TAILQ_INIT(&lkasession->aliaseslist);

			SPLAY_INSERT(lkatree, &env->lka_sessions, lkasession);

			ret = 0;
d368 2
a369 5
				fwreq.id = lkasession->id;
				(void)strlcpy(fwreq.pw_name, ss->u.path.pw_name, sizeof(fwreq.pw_name));
				imsg_compose_event(env->sc_ievs[PROC_PARENT], IMSG_PARENT_FORWARD_OPEN, 0, 0, -1,
				    &fwreq, sizeof(fwreq));
				++lkasession->pending;
d373 1
d377 1
d838 2
d856 2
d877 1
d879 1
d885 7
d925 2
a926 8
		message = lkasession->message;
		message.recipient = lkasession->path;
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
		    &message, sizeof(struct message));
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1,
		    &message, sizeof(struct message));
a928 1
		log_debug("a list of aliases is available");
d930 1
a931 2
			bzero(&message.recipient, sizeof(struct path));
			
d933 2
a934 6
			lka_rcpt_action(env, &message.recipient);
			
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
			    &message, sizeof(struct message));
			
d938 1
a938 3
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1, &message,
		    sizeof(struct message));
a949 1
	struct forward_req fwreq;
d962 2
a963 1
			if (aliases_virtual_get(env, lkasessionpath->cond->c_match, aliases, &alias->u.path)) {
d975 1
a976 5
				fwreq.id = lkasession->id;
				(void)strlcpy(fwreq.pw_name, alias->u.username, sizeof(fwreq.pw_name));
				imsg_compose_event(env->sc_ievs[PROC_PARENT], IMSG_PARENT_FORWARD_OPEN, 0, 0, -1,
				    &fwreq, sizeof(fwreq));
				++lkasession->pending;
d997 1
a997 2
lka_resolve_path(struct smtpd *env, struct path *path)
{
a1023 1

d1101 32
@


1.65
log
@currently both mfa and lka perform ruleset matching for their own purposes.
make lka the only caller of ruleset_match(), mfa request match through imsg
which will shrink its code and help me implement virtual domains properly.

idea discussed with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.64 2009/10/07 17:30:41 gilles Exp $	*/
a63 2
int		aliases_virtual_get(struct smtpd *, struct aliaseslist *, struct path *);
int		aliases_virtual_exist(struct smtpd *, struct path *);
d421 2
a422 1
				ret = aliases_virtual_get(env, &lkasession->aliaseslist, &lkasession->path);
d995 1
d997 1
d1007 1
a1007 1
			if (aliases_virtual_get(env, aliases, &alias->u.path)) {
d1047 10
a1056 5
	char username[MAXLOGNAME];
	struct passwd *pw;
	char *p;

	(void)strlcpy(username, path->user, sizeof(username));
a1057 9
	for (p = &username[0]; *p != '\0' && *p != '+'; ++p)
		*p = tolower((int)*p);
	*p = '\0';

	if (aliases_virtual_exist(env, path))
		path->flags |= F_PATH_VIRTUAL;
	else if (aliases_exist(env, username))
		path->flags |= F_PATH_ALIAS;
	else {
d1061 2
a1062 1
			return 0;
d1066 1
a1066 1
		    sizeof(path->rule.r_value.path), path) >=
d1068 14
a1081 1
			return 0;
d1084 1
a1084 1
	return 1;
@


1.64
log
@since the bounce code rewrite, we no longer need to perform ruleset match
and aliases resolution on the sender before envelope is written in queue:

- mfa_test_mail() no longer calls ruleset_match()
- lka_verify_mail() no longer resolves sender and set rule action
- lka_resolve_mail() becomes dead code so just kill it

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.63 2009/09/03 08:19:13 jacekm Exp $	*/
d344 19
@


1.63
log
@imsg_get sets errno so use fatal instead of fatalx.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.62 2009/08/08 00:02:22 gilles Exp $	*/
a55 1
int		lka_resolve_mail(struct smtpd *, struct rule *, struct path *);
a739 48
	struct rule *r;

	r = ruleset_match(env, path, NULL);
	if (r == NULL) {
		path->rule.r_action = A_RELAY;
		return 1;
	}

	path->rule = *r;
	if (r->r_action == A_MBOX ||
	    r->r_action == A_MAILDIR ||
	    r->r_action == A_EXT) {
		lka_resolve_mail(env, r, path);
		return 1;
	}

	return 1;
}

int
lka_resolve_mail(struct smtpd *env, struct rule *rule, struct path *path)
{
	char username[MAXLOGNAME];
	struct passwd *pw;
	char *p;

	(void)strlcpy(username, path->user, sizeof(username));

	for (p = &username[0]; *p != '\0' && *p != '+'; ++p)
		*p = tolower((int)*p);
	*p = '\0';

	if (aliases_virtual_exist(env, path))
		path->flags |= F_PATH_VIRTUAL;
	else if (aliases_exist(env, username))
		path->flags |= F_PATH_ALIAS;
	else {
		pw = getpwnam(username);
		if (pw == NULL)
			return 0;
		(void)strlcpy(path->pw_name, pw->pw_name,
		    sizeof(path->pw_name));
		if (lka_expand(path->rule.r_value.path,
		    sizeof(path->rule.r_value.path), path) >=
		    sizeof(path->rule.r_value.path))
			return 0;
	}

@


1.62
log
@import some changes from portable smtpd to reduce the delta between both.
this commit contains mostly missing casts and cosmethic changes, do not
expect to build this anywhere but on OpenBSD, it does not contain any of
the portable glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.61 2009/08/07 20:21:48 gilles Exp $	*/
d126 1
a126 1
			fatalx("lka_dispatch_parent: imsg_get error");
d325 1
a325 1
			fatalx("lka_dispatch_mfa: imsg_get error");
d462 1
a462 1
			fatalx("lka_dispatch_mta: imsg_get error");
d545 1
a545 1
			fatalx("lka_dispatch_smtp: imsg_get error");
d597 1
a597 1
			fatalx("lka_dispatch_queue: imsg_get error");
d642 1
a642 1
			fatalx("lka_dispatch_runner: imsg_get error");
@


1.61
log
@we were linking to libkeynote to use kn_base64_encode/decode, but honestly
this was a ugly hack, and i'd rather include resolv.h and use __b64_encode
and __b64_decode as openssh does. this commit kills all references to
libkeynote in smtpd, should help a bit with porting ... no functionnal
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.60 2009/06/07 05:56:25 eric Exp $	*/
d1163 1
a1163 1
	if (__b64_ntop(buf, buflen, dst, size) == -1) {
@


1.60
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.59 2009/06/06 04:14:21 pyr Exp $	*/
d36 1
a42 2
#include <keynote.h>

d1163 1
a1163 1
	if (kn_encode_base64(buf, buflen, dst, size) == -1) {
@


1.59
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.58 2009/06/05 20:43:57 pyr Exp $	*/
d231 1
a231 1
			fd = imsg_get_fd(ibuf);
@


1.58
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.57 2009/06/03 16:31:55 jacekm Exp $	*/
d101 1
d106 2
a107 1
	ibuf = env->sc_ibufs[PROC_PARENT];
d114 1
a114 1
			event_del(&ibuf->ev);
d265 1
a265 1
					imsg_compose_event(env->sc_ibufs[PROC_QUEUE],
d270 1
a270 1
						imsg_compose_event(env->sc_ibufs[PROC_QUEUE],
d293 1
a293 1
	imsg_event_add(ibuf);
d300 1
d305 2
a306 1
	ibuf = env->sc_ibufs[PROC_MFA];
d313 1
a313 1
			event_del(&ibuf->ev);
d344 1
a344 1
			imsg_compose_event(ibuf, IMSG_LKA_MAIL, 0, 0, -1,
d364 1
a364 1
				imsg_compose_event(env->sc_ibufs[PROC_QUEUE],
d367 1
a367 1
				imsg_compose_event(env->sc_ibufs[PROC_QUEUE],
d374 1
a374 1
				imsg_compose_event(ibuf, IMSG_LKA_RCPT, 0, 0, -1,
d397 1
a397 1
				imsg_compose_event(env->sc_ibufs[PROC_PARENT], IMSG_PARENT_FORWARD_OPEN, 0, 0, -1,
d414 1
a414 1
				imsg_compose_event(ibuf, IMSG_LKA_RCPT, 0, 0,
d430 1
a430 1
	imsg_event_add(ibuf);
d437 1
d442 2
a443 1
	ibuf = env->sc_ibufs[PROC_MTA];
d450 1
a450 1
			event_del(&ibuf->ev);
d491 1
a491 1
			imsg_compose_event(ibuf, IMSG_LKA_SECRET, 0, 0, -1, query,
d502 1
a502 1
			dns_async(env, ibuf, imsg.hdr.type, query);
d513 1
a513 1
	imsg_event_add(ibuf);
d520 1
d525 2
a526 1
	ibuf = env->sc_ibufs[PROC_SMTP];
d533 1
a533 1
			event_del(&ibuf->ev);
d555 1
a555 1
			dns_async(env, ibuf, IMSG_DNS_PTR, query);
d565 1
a565 1
	imsg_event_add(ibuf);
d572 1
d577 2
a578 1
	ibuf = env->sc_ibufs[PROC_QUEUE];
d585 1
a585 1
			event_del(&ibuf->ev);
d610 1
a610 1
	imsg_event_add(ibuf);
d617 1
d622 2
a623 1
	ibuf = env->sc_ibufs[PROC_RUNNER];
d630 1
a630 1
			event_del(&ibuf->ev);
d655 1
a655 1
	imsg_event_add(ibuf);
d983 1
a983 1
		imsg_compose_event(env->sc_ibufs[PROC_MFA], IMSG_LKA_RCPT, 0, 0,
d989 1
a989 1
		imsg_compose_event(env->sc_ibufs[PROC_QUEUE],
d992 1
a992 1
		imsg_compose_event(env->sc_ibufs[PROC_QUEUE],
d1005 1
a1005 1
			imsg_compose_event(env->sc_ibufs[PROC_QUEUE],
d1012 1
a1012 1
		imsg_compose_event(env->sc_ibufs[PROC_QUEUE],
d1052 1
a1052 1
				imsg_compose_event(env->sc_ibufs[PROC_PARENT], IMSG_PARENT_FORWARD_OPEN, 0, 0, -1,
@


1.57
log
@Improve error checking for the secrets encoding function; ok gilles@@
Pointed out by giovanni <qgiovanni@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.56 2009/06/01 23:15:48 gilles Exp $	*/
d229 1
a229 1
			fd = imsg_get_fd(ibuf, &imsg);
d263 1
a263 1
					imsg_compose(env->sc_ibufs[PROC_QUEUE],
d268 1
a268 1
						imsg_compose(env->sc_ibufs[PROC_QUEUE],
d340 1
a340 1
			imsg_compose(ibuf, IMSG_LKA_MAIL, 0, 0, -1,
d360 1
a360 1
				imsg_compose(env->sc_ibufs[PROC_QUEUE],
d363 1
a363 1
				imsg_compose(env->sc_ibufs[PROC_QUEUE],
d370 1
a370 1
				imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0, -1,
d393 1
a393 1
				imsg_compose(env->sc_ibufs[PROC_PARENT], IMSG_PARENT_FORWARD_OPEN, 0, 0, -1,
d410 1
a410 1
				imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0,
d485 1
a485 1
			imsg_compose(ibuf, IMSG_LKA_SECRET, 0, 0, -1, query,
d971 1
a971 1
		imsg_compose(env->sc_ibufs[PROC_MFA], IMSG_LKA_RCPT, 0, 0,
d977 1
a977 1
		imsg_compose(env->sc_ibufs[PROC_QUEUE],
d980 1
a980 1
		imsg_compose(env->sc_ibufs[PROC_QUEUE],
d993 1
a993 1
			imsg_compose(env->sc_ibufs[PROC_QUEUE],
d1000 1
a1000 1
		imsg_compose(env->sc_ibufs[PROC_QUEUE],
d1040 1
a1040 1
				imsg_compose(env->sc_ibufs[PROC_PARENT], IMSG_PARENT_FORWARD_OPEN, 0, 0, -1,
@


1.56
log
@yet another cleanup in mfa/lka, don't roll their own loops to release maps
and rules when config.c provides us with purge_config(), PURGE_MAPS and
PURGE_RULES. kills lots of lines with no functionnal change. ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.55 2009/06/01 22:51:47 gilles Exp $	*/
d73 1
a73 1
int		lka_encode_credentials(char *, char *);
d465 1
d469 1
a469 1
			secret = map_dblookup(env, "secrets", query->host);
d473 2
d476 8
a483 4
			if (secret)
				lka_encode_credentials(query->secret, secret);
			else
				query->secret[0] = '\0';
d1140 1
a1140 1
lka_encode_credentials(char *dest, char *src)
d1142 2
a1143 3
	size_t len;
	char buffer[MAX_LINE_SIZE];
	size_t i;
d1145 1
a1145 2
	len = strlen(src) + 1;
	if (len < 1)
d1147 1
d1149 5
a1153 3
	bzero(buffer, sizeof (buffer));
	if (strlcpy(buffer + 1, src, sizeof(buffer) - 1) >=
	    sizeof (buffer) - 1)
d1155 1
d1157 1
a1157 8
	for (i = 0; i < len; ++i) {
		if (buffer[i] == ':') {
			buffer[i] = '\0';
			break;
		}
	}
	if (kn_encode_base64(buffer, len, dest, MAX_LINE_SIZE - 1) == -1)
		return 0;
@


1.55
log
@add new file ruleset.c with code related to the ruleset matching, and kill
the two or three "almost" identical versions of ruleset matching loops from
lka and mfa by having one unified function in ruleset.c; ok jacekm@@

while at it, bring maildir support back to life; trivial one-liner by me
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.53 2009/06/01 18:24:01 deraadt Exp $	*/
d207 1
a207 7
		case IMSG_CONF_END: {
			void *temp;
			struct rule *r;
			struct cond *cond;
			struct map *m;
			struct mapel *mapel;
			
d209 4
a212 1
			temp = env->sc_rules;
a213 3
			env->sc_rules_reload = temp;

			temp = env->sc_maps;
a214 28
			env->sc_maps_reload = temp;
			
			if (env->sc_rules_reload) {
				while ((r = TAILQ_FIRST(env->sc_rules_reload))) {
					TAILQ_REMOVE(env->sc_rules_reload, r, r_entry);
					while ((cond = TAILQ_FIRST(&r->r_conditions))) {
						TAILQ_REMOVE(&r->r_conditions, cond, c_entry);
						free(cond);
					}
					free(r);
				}
				free(env->sc_rules_reload);
				env->sc_rules_reload = NULL;
			}

			if (env->sc_maps_reload) {
				while ((m = TAILQ_FIRST(env->sc_maps_reload))) {
					TAILQ_REMOVE(env->sc_maps_reload, m, m_entry);
					while ((mapel = TAILQ_FIRST(&m->m_contents))) {
						TAILQ_REMOVE(&m->m_contents, mapel, me_entry);
						free(mapel);
					}
					free(m);
				}
				free(env->sc_maps_reload);
				env->sc_maps_reload = NULL;
			}

@


1.54
log
@propagate the recipient domain through aliases expansion, this fixes a bug
that would trigger when smtpd.conf does not have an "accept for local" rule
and we attempt to deliver to a domain for which we are a destination.

spotted by jacekm@@, fix by me and ok jacekm@@
@
text
@d74 1
d282 1
d286 1
d290 7
a757 14
	struct cond *cond;
	struct map *map;
	struct mapel *me;

	TAILQ_FOREACH(r, env->sc_rules, r_entry) {
		TAILQ_FOREACH(cond, &r->r_conditions, c_entry) {
			if (cond->c_type == C_ALL) {
				path->rule = *r;
				if (r->r_action == A_MBOX ||
				    r->r_action == A_MAILDIR) {
					return lka_resolve_mail(env, r, path);
				}
				return 1;
			}
d759 12
a770 19
			if (cond->c_type == C_DOM) {
				cond->c_match = map_find(env, cond->c_map);
				if (cond->c_match == NULL)
					fatal("lka failed to lookup map.");

				map = cond->c_match;
				TAILQ_FOREACH(me, &map->m_contents, me_entry) {
					if (hostname_match(path->domain, me->me_key.med_string)) {
						path->rule = *r;
						if (r->r_action == A_MBOX ||
						    r->r_action == A_MAILDIR ||
						    r->r_action == A_EXT) {
							return lka_resolve_mail(env, r, path);
						}
						return 1;
					}
				}
			}
		}
d772 1
a772 1
	path->rule.r_action = A_RELAY;
a1125 3
	struct cond *cond;
	struct map *map;
	struct mapel *me;
d1128 2
a1129 1
		(void)strlcpy(path->domain, "localhost", sizeof (path->domain));
d1131 5
a1135 7
	TAILQ_FOREACH(r, env->sc_rules, r_entry) {

		TAILQ_FOREACH(cond, &r->r_conditions, c_entry) {
			if (cond->c_type == C_ALL) {
				path->rule = *r;
				return;
			}
d1137 1
a1137 19
			if (cond->c_type == C_DOM) {
				cond->c_match = map_find(env, cond->c_map);
				if (cond->c_match == NULL)
					fatal("mfa failed to lookup map.");

				map = cond->c_match;
				TAILQ_FOREACH(me, &map->m_contents, me_entry) {
					log_debug("trying to match [%s] with [%s]",
					    path->domain, me->me_key.med_string);
					if (hostname_match(path->domain, me->me_key.med_string)) {
						path->rule = *r;
						return;
					}
				}
			}
		}
	}
	path->rule.r_action = A_RELAY;
	return;
@


1.53
log
@No need for save_getpwuid and such functions which call endpwent.
endpwent is not needed unless setpwent (with stayopen = 1) or getpwent
was used.  getpwuid/getpwnam do not use getpwent; i think people must
be assuming this.  we are going to improve the man pages for this.
ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.52 2009/06/01 13:20:56 jacekm Exp $	*/
d281 3
a283 1
					bzero(&message.recipient, sizeof(struct path));			
@


1.52
log
@Fix EV_READ/EV_WRITE testing inside IMSG handlers. Based on similar change
to the routing daemons by claudio@@; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.51 2009/05/24 14:38:56 jacekm Exp $	*/
d803 1
a803 1
		pw = safe_getpwnam(username);
d832 1
a832 1
				pw = safe_getpwnam(path->pw_name);
d858 1
a858 1
				pw = safe_getpwnam(username);
d1117 1
a1117 1
		pw = safe_getpwnam(username);
@


1.51
log
@Parent process forks 3 types of processes, track them all in a single tree
using newly introduced child struct.

Manage process titles centrally in struct smtpd.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.50 2009/05/20 16:07:26 gilles Exp $	*/
d105 2
a106 2
	switch (event) {
	case EV_READ:
d115 3
a117 2
		break;
	case EV_WRITE:
a119 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d325 2
a326 2
	switch (event) {
	case EV_READ:
d335 3
a337 2
		break;
	case EV_WRITE:
a339 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d460 2
a461 2
	switch (event) {
	case EV_READ:
d470 3
a472 2
		break;
	case EV_WRITE:
a474 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d534 2
a535 2
	switch (event) {
	case EV_READ:
d544 3
a546 2
		break;
	case EV_WRITE:
a548 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d584 2
a585 2
	switch (event) {
	case EV_READ:
d594 3
a596 2
		break;
	case EV_WRITE:
a598 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d627 2
a628 2
	switch (event) {
	case EV_READ:
d637 3
a639 2
		break;
	case EV_WRITE:
a641 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
@


1.50
log
@previous commit to add reload support was missing some code, this diffs
contains the missing parts + a memleak plug
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.49 2009/05/20 14:36:55 gilles Exp $	*/
a727 1
	setproctitle("lookup agent");
d729 1
@


1.49
log
@replace a TAILQ_FOREACH loop with a TAILQ_FIRST loop when releasing entries
of the tailq, this is how it must be done.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.48 2009/05/20 14:29:44 gilles Exp $	*/
d150 1
d178 1
d182 27
d212 1
d214 1
d228 4
d241 4
@


1.48
log
@first step towards configuration reload in smtpd, smtpctl reload will parse
the configuration file again and replace current configuration with new one
in all processes. what we don't support yet is graceful restart, clients in
sessions at the moment of the reload will have a temp failure thrown at 'em
which is ok RFC-wise but which we will try to improve anyway.

tested with various setups, "diff reads good" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.47 2009/05/19 11:24:24 jacekm Exp $	*/
d193 1
a193 1

d195 2
a196 1
				TAILQ_FOREACH(r, env->sc_rules_reload, r_entry) {
d204 2
a205 1
				TAILQ_FOREACH(m, env->sc_maps_reload, m_entry) {
@


1.47
log
@Verify the amount of IMSG payload is exactly as expected; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.46 2009/05/14 15:05:12 eric Exp $	*/
d132 80
d683 1
a683 1
//	purge_config(env, PURGE_EVERYTHING);
@


1.46
log
@use the nitems() macro where appropriate

ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.45 2009/05/09 17:04:55 jacekm Exp $	*/
d134 1
a134 1
			struct forward_req	*fwreq;
d138 1
a138 1
			fwreq = imsg.data;
d235 3
a237 1
			struct submit_status	 *ss;
a238 1
			ss = imsg.data;
d253 1
a253 1
			struct submit_status	*ss;
d259 2
a260 1
			ss = imsg.data;
d376 2
d395 5
a399 2
		case IMSG_DNS_MX:
			dns_async(env, ibuf, imsg.hdr.type, imsg.data);
d401 1
d449 5
a453 2
		case IMSG_DNS_PTR:
			dns_async(env, ibuf, IMSG_DNS_PTR, imsg.data);
d455 1
@


1.45
log
@- New API to handle all DNS query types (A, MX, PTR) asynchronously.

- Improve RFC compliance: CNAMEs are resolved, equal preference MXs
are randomized, relaying via MX that has equal/lower preference
than local server is prevented, decision on when to treat domain
name as implicit MX is better.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.44 2009/05/01 21:44:19 gilles Exp $	*/
d617 2
a618 2
	config_pipes(env, peers, 6);
	config_peers(env, peers, 6);
@


1.44
log
@initialize secret to NULL otherwise we may try to free a junk pointer when
F_AUTH is not set. i was going to look into the issue, but i have received
a diff from Simon Betrang <janus@@errornet.de>, thanks !
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.43 2009/04/28 23:11:25 gilles Exp $	*/
d25 1
d31 1
a73 1
void		lka_dns_reverse(struct session *s);
d78 3
d86 5
d370 3
a372 37
		case IMSG_LKA_MX: {
			struct mxreq *mxreq;
			struct mxrep mxrep;
			struct addrinfo hints, *res, *resp;
			char **mx = NULL;
			char *lmx[1];
			int len, i;
			int mxcnt;
			int error;
			struct mxhost mxhost;
			char *secret = NULL;

			mxreq = imsg.data;
			mxrep.id = mxreq->id;
			mxrep.getaddrinfo_error = 0;

			if (mxreq->rule.r_action == A_RELAY) {
				log_debug("attempting to resolve %s", mxreq->hostname);
				len = getmxbyname(mxreq->hostname, &mx);
				if (len < 0) {
					mxrep.getaddrinfo_error = len;
					imsg_compose(ibuf, IMSG_LKA_MX_END, 0, 0, -1,
					    &mxrep, sizeof(struct mxrep));
					break;
				}
				if (len == 0) {
					lmx[0] = mxreq->hostname;
					mx = lmx;
					len = 1;
				}
			}
			else if (mxreq->rule.r_action == A_RELAYVIA) {
				lmx[0] = mxreq->rule.r_value.relayhost.hostname;
				log_debug("attempting to resolve %s:%d (forced)", lmx[0],
				    ntohs(mxreq->rule.r_value.relayhost.port));
				mx = lmx;
				len = 1;
d374 1
a374 13
			}
			memset(&hints, 0, sizeof(hints));
			hints.ai_family = PF_UNSPEC;
			hints.ai_protocol = IPPROTO_TCP;

			for (i = 0; i < len; ++i) {

				error = getaddrinfo(mx[i], NULL, &hints, &res);
				if (error) {
					mxrep.getaddrinfo_error = error;
					imsg_compose(ibuf, IMSG_LKA_MX_END, 0, 0, -1,
					    &mxrep, sizeof(struct mxrep));
				}
d376 2
a377 2
				if (mxreq->rule.r_action == A_RELAYVIA)
					mxhost.flags = mxreq->rule.r_value.relayhost.flags;
d379 4
a382 10
				if (mxhost.flags & F_AUTH) {
					secret = map_dblookup(env, "secrets", mx[i]);
					if (secret == NULL) {
						log_warnx("no credentials for relay through \"%s\"", mx[i]);
						freeaddrinfo(res);
						continue;
					}
				}
				if (secret)
					lka_encode_credentials(mxhost.credentials, secret);
d384 5
a388 97
				for (resp = res; resp != NULL && mxcnt < MAX_MX_COUNT; resp = resp->ai_next) {

					if (resp->ai_family == PF_INET) {
						struct sockaddr_in *ssin;
						
						mxhost.ss = *(struct sockaddr_storage *)resp->ai_addr;
						
						ssin = (struct sockaddr_in *)&mxhost.ss;
						if (mxreq->rule.r_value.relayhost.port != 0) {
							ssin->sin_port = mxreq->rule.r_value.relayhost.port;
							mxrep.mxhost = mxhost;
							imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, &mxrep,
							    sizeof(struct mxrep));
							continue;
						}

						switch (mxhost.flags & F_SSL) {
						case F_SMTPS:
							ssin->sin_port = htons(465);
							mxrep.mxhost = mxhost;
							imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, &mxrep,
							    sizeof(struct mxrep));
							break;
						case F_SSL:
							ssin->sin_port = htons(465);
							mxrep.mxhost = mxhost;
							mxrep.mxhost.flags &= ~F_STARTTLS;
							imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, &mxrep,
							    sizeof(struct mxrep));
						case F_STARTTLS:
							ssin->sin_port = htons(25);
							mxrep.mxhost = mxhost;
							mxrep.mxhost.flags &= ~F_SMTPS;
							imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, &mxrep,
							    sizeof(struct mxrep));
							break;
						default:
							ssin->sin_port = htons(25);
							mxrep.mxhost = mxhost;
							imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, &mxrep,
							    sizeof(struct mxrep));
						}
					}
					
					if (resp->ai_family == PF_INET6) {
						struct sockaddr_in6 *ssin6;
						
						mxhost.ss = *(struct sockaddr_storage *)resp->ai_addr;
						ssin6 = (struct sockaddr_in6 *)&mxhost.ss;
						if (mxreq->rule.r_value.relayhost.port != 0) {
							ssin6->sin6_port = mxreq->rule.r_value.relayhost.port;
							mxrep.mxhost = mxhost;
							imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, &mxrep,
							    sizeof(struct mxrep));
							continue;
						}
						
						switch (mxhost.flags & F_SSL) {
						case F_SMTPS:
							ssin6->sin6_port = htons(465);
							mxrep.mxhost = mxhost;
							imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, &mxrep,
							    sizeof(struct mxrep));
							break;
						case F_SSL:
							ssin6->sin6_port = htons(465);
							mxrep.mxhost = mxhost;
							mxrep.mxhost.flags &= ~F_STARTTLS;
							imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, &mxrep,
							    sizeof(struct mxrep));
						case F_STARTTLS:
							ssin6->sin6_port = htons(25);
							mxrep.mxhost = mxhost;
							mxrep.mxhost.flags &= ~F_SMTPS;
							imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, &mxrep,
							    sizeof(struct mxrep));
							break;
						default:
							ssin6->sin6_port = htons(25);
							mxrep.mxhost = mxhost;
							imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, &mxrep,
							    sizeof(struct mxrep));
						}
					}
				}
				freeaddrinfo(res);
				free(secret);
				bzero(&mxhost.credentials, MAX_LINE_SIZE);
			}

			mxrep.getaddrinfo_error = error;

			imsg_compose(ibuf, IMSG_LKA_MX_END, 0, 0, -1,
			    &mxrep, sizeof(struct mxrep));

			if (mx != lmx)
				free(mx);
d390 3
a393 1
		}
d441 2
a442 4
		case IMSG_LKA_HOST:
			lka_dns_reverse(imsg.data);
			imsg_compose(ibuf, IMSG_LKA_HOST, 0, 0, -1, imsg.data,
			    sizeof(struct session));
d571 1
d610 1
d613 1
a1106 26
}

void
lka_dns_reverse(struct session *s)
{
	char		 addr[NI_MAXHOST];
	struct addrinfo	 hints, *res;
	struct sockaddr	*sa;

	strlcpy(s->s_hostname, "<unknown>", sizeof(s->s_hostname));

	sa = (struct sockaddr *)&s->s_ss;
	if (getnameinfo(sa, sa->sa_len, addr, sizeof(addr),
	    NULL, 0, NI_NAMEREQD))
		return;

	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_flags = AI_NUMERICHOST;

	if (getaddrinfo(addr, NULL, &hints, &res))
		return; /* malicious PTR record. */

	freeaddrinfo(res);

	strlcpy(s->s_hostname, addr, sizeof(s->s_hostname));
@


1.43
log
@smtp auth happened to work by luck because delivery to mbox action was the
first action of an enum and we allocated a struct using calloc, but we did
not properly initialize the action for authenticated users.

while at it, change the name of path action flags so that we know at first
sight that they are path related.

this diff fixes the immediate issue but still needs work.
ok jacekm@@, "we'll work out a long term solution"
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.42 2009/04/28 22:38:22 jacekm Exp $	*/
d371 1
a371 1
			char *secret;
@


1.42
log
@fix a bug where client with unresolvable revdns is never greeted; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.41 2009/04/21 14:37:32 eric Exp $	*/
d286 1
a286 1
			if (lkasession->path.flags & F_ACCOUNT) {
d294 1
a294 1
			else if (lkasession->path.flags & F_ALIAS) {
d297 1
a297 1
			else if (lkasession->path.flags & F_VIRTUAL) {
d816 1
a816 1
		path->flags |= F_VIRTUAL;
d818 1
a818 1
		path->flags |= F_ALIAS;
d1129 1
a1129 1
		path->flags |= F_VIRTUAL;
d1131 1
a1131 1
		path->flags |= F_ALIAS;
d1133 1
a1133 1
		path->flags |= F_ACCOUNT;
@


1.41
log
@correct some fatal(x) calls and error strings

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.40 2009/04/09 19:49:34 jacekm Exp $	*/
d72 1
d574 3
a576 23
		case IMSG_LKA_HOST: {
			struct sockaddr *sa;
			char addr[NI_MAXHOST];
			struct addrinfo hints, *res;
			struct session *s;

			s = imsg.data;
			sa = (struct sockaddr *)&s->s_ss;
			if (getnameinfo(sa, sa->sa_len, addr, sizeof(addr),
			    NULL, 0, NI_NAMEREQD))
				break;

			memset(&hints, 0, sizeof(hints));
			hints.ai_socktype = SOCK_DGRAM;
			hints.ai_flags = AI_NUMERICHOST;
			if (getaddrinfo(addr, NULL, &hints, &res) == 0) {
				/* Malicious PTR record. */
				freeaddrinfo(res);
				break;
			}

			strlcpy(s->s_hostname, addr, sizeof(s->s_hostname));
			imsg_compose(ibuf, IMSG_LKA_HOST, 0, 0, -1, s,
a578 1
		}
d1239 26
@


1.40
log
@change syntax of the "listen on" and "relay via" directives:
1) kill the ssmtp keyword in "ssmtp listen on ...";
2) kill the use keyword in "... use certificate foo";
3) tls no longer implicit, user must explicitely use the tls or smtps option.
4) for "relay via", move the tls/smtps options to right after the
port specification; makes it similar to "listen on".

These directives:

  ssmtp listen on fxp0 use ceritifate "foo"
  accept for all relay via tls "mx.bar.com"

now become:

  listen on fxp0 smtps certificate "foo"
  accept for all relay via "mx.bar.com" tls

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.39 2009/04/05 16:33:12 gilles Exp $	*/
d117 1
a117 1
			fatal("parent_dispatch_lka: imsg_read error");
d219 1
a219 1
			fatal("lka_dispatch_mfa: imsg_read error");
d355 1
a355 1
			fatal("lka_dispatch_mta: imsg_read error");
d568 1
a568 1
			fatal("lka_dispatch_mfa: imsg_read error");
d640 1
a640 1
			fatal("lka_dispatch_queue: imsg_read error");
d686 1
a686 1
			fatal("lka_dispatch_runner: imsg_read error");
@


1.39
log
@log_warn -> log_warnx
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.38 2009/03/29 14:18:20 jacekm Exp $	*/
d443 1
a443 1
						case F_SSMTP:
d458 1
a458 1
							mxrep.mxhost.flags &= ~F_SSMTP;
d484 1
a484 1
						case F_SSMTP:
d499 1
a499 1
							mxrep.mxhost.flags &= ~F_SSMTP;
@


1.38
log
@turn some log_debugs into log_warns or even fatals; "looks ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.37 2009/03/22 22:53:47 gilles Exp $	*/
d418 1
a418 1
						log_warn("no credentials for relay through \"%s\"", mx[i]);
@


1.37
log
@fix a bug in the resolution of forward files which would cause usernames
not to be taken into account if they had no ~/.forward file AND were the
result of an alias expansion that expanded to more than one username.

while at it, I spotted another bug where I would check T_MDA_MESSAGE on
the flags field instead of the type field. the bug could cause two MDA
message to end up in the same batch which is no longer valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.36 2009/03/20 09:34:34 gilles Exp $	*/
d179 1
a179 1
			log_debug("parent_dispatch_lka: unexpected imsg %d",
d181 1
a181 1
			break;
d315 1
a315 1
			log_debug("lka_dispatch_mfa: unexpected imsg %d",
d317 1
a317 1
			break;
d528 1
a528 1
			log_debug("lka_dispatch_mta: unexpected imsg %d",
d530 1
a530 1
			break;
d600 1
a600 1
			log_debug("lka_dispatch_mfa: unexpected imsg %d",
d602 1
a602 1
			break;
d646 3
a648 3
			log_debug("lka_dispatch_queue: unexpected imsg %d",
			    imsg.hdr.type);
			break;
d692 1
a692 1
			log_debug("lka_dispatch_runner: unexpected imsg %d",
d694 1
a694 1
			break;
@


1.36
log
@initialize variable before using it as a counter in a loop

spotted and fix by Matthew Haub <matthew.haub@@alumni.adelaide.edu.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.35 2009/03/11 11:11:08 pea Exp $	*/
d60 1
a60 1
int		lka_resolve_alias(struct path *, struct alias *);
d138 1
a138 1
				if (fwreq->pw_name[0] != '\0') {
d142 25
a303 1
				log_debug("expansion resulted in empty list");
d972 1
a972 1
lka_resolve_alias(struct path *path, struct alias *alias)
d980 10
d1034 1
a1034 1
		
d1038 1
a1038 1
	
d1041 1
a1041 1
	
d1047 1
a1047 2
	else if (ret == 0) {
		log_debug("expansion resulted in empty list");
d1063 1
a1063 1
			lka_resolve_alias(&message.recipient, alias);
d1126 1
a1126 2
	if (!done && lkasession->iterations == 5) {
		log_debug("loop detected");
a1127 1
	}
@


1.35
log
@getmxbyname() returning a value != 0 does not necessarily means it failed

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.34 2009/03/09 16:31:09 jacekm Exp $	*/
d1219 1
a1219 1
	while (i++ < len) {
@


1.34
log
@Drop ALIAS_TEXT, plain maps got implemented in a different way; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.33 2009/03/09 01:43:19 gilles Exp $	*/
d355 1
a355 1
				if (len != 0) {
@


1.33
log
@add basic support for outgoing authentication (AUTH PLAIN over ssl) which
can be turned on by adding "enable auth" to a "relay via" rule. this made
me rework the mx resolution so that it is done by the mta process and not
the runner process anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.32 2009/03/08 17:54:20 gilles Exp $	*/
a976 1
	case ALIAS_TEXT:
@


1.32
log
@~/.forward files handling was fixed recently so that it is the privileged
process that does the opening, this commit does some cleanup, and fixes a
bug I experienced today which was caused by a use-after-free.

I did some testing to make sure a user cannot cause smtpd to deadlock, or
loop, with broken setups (self-referencing forwards/aliases, empty files,
broken files...), but if you are playing with aliases/forwards PLEASE let
me know of any bug you run into.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.31 2009/03/04 00:00:40 gilles Exp $	*/
d33 1
d40 2
d51 1
d71 1
d301 213
a666 87
		case IMSG_LKA_MX: {
			struct batch *batchp;
			struct addrinfo hints, *res, *resp;
			char **mx = NULL;
			char *lmx[1];
			int len, i, j;
			int error;
			u_int16_t port = htons(25);

			batchp = imsg.data;

			if (! IS_RELAY(batchp->rule.r_action))
				fatalx("lka_dispatch_queue: inconsistent internal state");

			if (batchp->rule.r_action == A_RELAY) {
				log_debug("attempting to resolve %s", batchp->hostname);
				len = getmxbyname(batchp->hostname, &mx);
				if (len < 0) {
					batchp->getaddrinfo_error = len;
					imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1,
					    batchp, sizeof(*batchp));
					break;
				}
				if (len == 0) {
					lmx[0] = batchp->hostname;
					mx = lmx;
					len = 1;
				}
			}
			else if (batchp->rule.r_action == A_RELAYVIA) {

				lmx[0] = batchp->rule.r_value.relayhost.hostname;
				port = batchp->rule.r_value.relayhost.port;
				log_debug("attempting to resolve %s:%d (forced)", lmx[0], ntohs(port));
				mx = lmx;
				len = 1;

			}

			memset(&hints, 0, sizeof(hints));
			hints.ai_family = PF_UNSPEC;
			hints.ai_protocol = IPPROTO_TCP;
			for (i = j = 0; i < len && (j < MXARRAYSIZE * 2); ++i) {
				error = getaddrinfo(mx[i], NULL, &hints, &res);
				if (error)
					continue;

				log_debug("resolving MX: %s", mx[i]);

				for (resp = res; resp != NULL && (j < MXARRAYSIZE * 2); resp = resp->ai_next) {

					if (batchp->rule.r_action == A_RELAYVIA)
						batchp->mxarray[j].flags = batchp->rule.r_value.relayhost.flags;

					if (resp->ai_family == PF_INET) {
						struct sockaddr_in *ssin;

						batchp->mxarray[j].ss = *(struct sockaddr_storage *)resp->ai_addr;
						ssin = (struct sockaddr_in *)&batchp->mxarray[j].ss;
						ssin->sin_port = port;
						++j;
					}
					if (resp->ai_family == PF_INET6) {
						struct sockaddr_in6 *ssin6;

						batchp->mxarray[j].ss = *(struct sockaddr_storage *)resp->ai_addr;
						ssin6 = (struct sockaddr_in6 *)&batchp->mxarray[j].ss;
						ssin6->sin6_port = port;
						++j;
					}
				}
				freeaddrinfo(res);
			}

			batchp->mx_cnt = j;
			batchp->getaddrinfo_error = 0;
			if (j == 0)
				batchp->getaddrinfo_error = error;
			imsg_compose(ibuf, IMSG_LKA_MX, 0, 0, -1, batchp,
			    sizeof(*batchp));

			if (mx != lmx)
				free(mx);

			break;
		}

d709 1
d745 2
a746 2
	config_pipes(env, peers, 5);
	config_peers(env, peers, 5);
d1202 27
@


1.31
log
@plug a memory leak, remove lka session from the the lka session tree when
we are done expanding aliases/forwards, and cleanup a bit the expansion
code so that I can soon remove some of the duplication.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.29 2009/03/03 23:23:52 gilles Exp $	*/
d63 2
a64 1
int		lka_expand_aliases(struct smtpd *, struct aliaseslist *, struct lkasession *);
a118 1
			int ret;
a121 2
			struct alias		*alias;
			struct message		message;
d134 1
a134 1
					lkasession->ss->code = 530;
d140 1
a140 1
					lkasession->ss->code = 530;
d145 1
a145 56

			ret = 0;
			while (! (lkasession->flags & F_ERROR) &&
			    ! lkasession->pending && lkasession->iterations < 5) {
				++lkasession->iterations;
				ret = lka_expand_aliases(env, &lkasession->aliaseslist, lkasession);
				if (ret == -1) {
					lkasession->ss->code = 530;
					lkasession->flags |= F_ERROR;
				}

				if (lkasession->pending || ret <= 0)
					break;
			}

			if (lkasession->pending)
				break;

			if (lkasession->flags & F_ERROR) {
				lka_clear_aliaseslist(&lkasession->aliaseslist);
				imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0,
				    -1, lkasession->ss, sizeof(*lkasession->ss));
			}
			else if (ret == 0) {
				log_debug("expansion resulted in empty list");
				message = lkasession->message;
				message.recipient = lkasession->path;
				imsg_compose(env->sc_ibufs[PROC_QUEUE],
				    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
				    &message, sizeof(struct message));
				imsg_compose(env->sc_ibufs[PROC_QUEUE],
				    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1,
				    &message, sizeof(struct message));
			}
			else {
				log_debug("a list of aliases is available");
				message = lkasession->message;
				while ((alias = TAILQ_FIRST(&lkasession->aliaseslist)) != NULL) {
					bzero(&message.recipient, sizeof(struct path));
					
					lka_resolve_alias(&message.recipient, alias);
					lka_rcpt_action(env, &message.recipient);
					
					imsg_compose(env->sc_ibufs[PROC_QUEUE],
					    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
					    &message, sizeof(struct message));
					
					TAILQ_REMOVE(&lkasession->aliaseslist, alias, entry);
					free(alias);
				}
				imsg_compose(env->sc_ibufs[PROC_QUEUE],
				    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1, &message,
				    sizeof(struct message));
			}
			SPLAY_REMOVE(lkatree, &env->lka_sessions, lkasession);
			free(lkasession);
d213 1
a213 1
			struct message		 message;
a214 1
			struct alias		*alias;
d248 2
a249 1
			lkasession->ss = ss;
a252 1
			log_debug("LKA SESSION !");
d281 1
a281 15
			ret = 0;
			while (! lkasession->pending && lkasession->iterations < 5) {
				++lkasession->iterations;
				ret = lka_expand_aliases(env, &lkasession->aliaseslist, lkasession);
				if (ret == -1) {
					lkasession->ss->code = 530;
					lkasession->flags |= F_ERROR;
				}

				if (lkasession->pending || ret <= 0)
					break;
			}

			if (lkasession->pending)
				break;
a282 38
			if (lkasession->flags & F_ERROR) {
				lka_clear_aliaseslist(&lkasession->aliaseslist);
				imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0,
				    -1, lkasession->ss, sizeof(*lkasession->ss));
			}
			else if (ret == 0) {
				log_debug("expansion resulted in empty list");
				message = ss->msg;
				message.recipient = ss->u.path;
				imsg_compose(env->sc_ibufs[PROC_QUEUE],
				    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
				    &message, sizeof(struct message));
				imsg_compose(env->sc_ibufs[PROC_QUEUE],
				    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1,
				    &message, sizeof(struct message));
			}
			else {
				log_debug("a list of aliases is available");
				message = ss->msg;
				while ((alias = TAILQ_FIRST(&lkasession->aliaseslist)) != NULL) {
					bzero(&message.recipient, sizeof(struct path));
					
					lka_resolve_alias(&message.recipient, alias);
					lka_rcpt_action(env, &message.recipient);
					
					imsg_compose(env->sc_ibufs[PROC_QUEUE],
					    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
					    &message, sizeof(struct message));
					
					TAILQ_REMOVE(&lkasession->aliaseslist, alias, entry);
					free(alias);
				}
				imsg_compose(env->sc_ibufs[PROC_QUEUE],
				    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1, &message,
				    sizeof(struct message));
			}
			SPLAY_REMOVE(lkatree, &env->lka_sessions, lkasession);
			free(lkasession);
d853 64
d918 1
a918 1
lka_expand_aliases(struct smtpd *env, struct aliaseslist *aliases, struct lkasession *lkasession)
d962 2
a963 1
	if (!done && lkasession->iterations == 5)
d965 1
@


1.30
log
@when forwards/aliases expansion fails in an lka session, make sure that mfa
is notified so that the session does not hang
@
text
@d65 1
a133 8
			if (! lkasession->pending && lkasession->flags & F_ERROR) {
				log_debug("error in lka session");
				/* we detected an error and this is last imsg */
				imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0,
				    -1, lkasession->ss, sizeof(*lkasession->ss));
				break;
			}

d136 2
a137 6
					/* error id local, return a temporary fail */
					log_debug("error in forward open");
					lkasession->ss->code = 421;
					imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0,
					    -1, lkasession->ss, sizeof(*lkasession->ss));
					break;
d140 6
a145 3
			else if (! forwards_get(fd, &lkasession->aliaseslist)) {
				lkasession->ss->code = 530;
				lkasession->flags |= F_ERROR;
d149 2
a150 1
			while (! lkasession->pending && lkasession->iterations < 5) {
d153 3
a155 6
				if (lkasession->pending) {
					if (ret == -1) {
						lkasession->ss->code = 530;
						lkasession->flags |= F_ERROR;
					}
					break;
d158 1
a158 1
				if (ret <= 0)
d165 2
a166 6
			if (ret < 0) {
				log_debug("loop detected");
				while ((alias = TAILQ_FIRST(&lkasession->aliaseslist)) != NULL) {
					TAILQ_REMOVE(&lkasession->aliaseslist, alias, entry);
					free(alias);
				}
a168 1
				break;
d170 1
a170 2

			if (ret == 0) {
d201 2
d343 3
a345 6
				if (lkasession->pending) {
					if (ret == -1) {
						lkasession->ss->code = 530;
						lkasession->flags |= F_ERROR;
					}
					break;
d348 1
a348 1
				if (ret <= 0)
d355 2
a356 7
			if (ret < 0) {
				log_debug("detected a loop");
				while ((alias = TAILQ_FIRST(&lkasession->aliaseslist)) != NULL) {
					TAILQ_REMOVE(&lkasession->aliaseslist, alias, entry);
					free(alias);
				}
				ss->code = 530;
d358 1
a358 2
				    -1, ss, sizeof(*ss));
				break;
d360 1
a360 2

			if (ret == 0) {
a361 6
				if (! (ss->u.path.flags & F_ACCOUNT)) {
					ss->code = 530;
					imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0,
					    -1, ss, sizeof(*ss));
					break;
				}
d391 2
d1103 11
@


1.29
log
@Fix a long standing issue where ~/.forward files were opened by user _smtpd
causing them not to be handled when a user's homedir is set to mode 0700. I
still need to do some cleanup and make sure it works as it should, but this
diff provides better behavior than what we had.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.28 2009/02/24 21:40:51 jacekm Exp $	*/
d136 2
a137 1
				//XXXXX clear aliaseslist and return temp fail
d143 1
d145 3
a147 1
					/* error id local, return a temporary fail */
d152 1
d161 2
a162 1
					if (ret == -1)
d164 1
d181 2
d320 1
d358 2
a359 1
					if (ret == -1)
d361 1
d378 3
@


1.28
log
@fix tilde expansion (eg. ~/Mail); ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.27 2009/02/22 23:21:40 jacekm Exp $	*/
a57 1
int		forwards_get(struct aliaseslist *, char *);
d63 1
a63 1
int		lka_expand_aliases(struct smtpd *, struct aliaseslist *, struct path *);
d115 95
d275 2
d278 2
a279 3
			struct aliaseslist	 aliases;
			struct message		 message;
			int expret;
d305 32
a336 5
			TAILQ_INIT(&aliases);
				
			expret = lka_expand_aliases(env, &aliases, &ss->u.path);
			if (expret < 0) {
				log_debug("loop detected, rejecting recipient");
d338 28
a365 2
				imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0, -1,
				    ss, sizeof(*ss));
d369 1
a369 1
			if (expret == 0) {
a384 1
				break;
d386 16
a401 9

			log_debug("a list of aliases is available");
			message = ss->msg;
			while ((alias = TAILQ_FIRST(&aliases)) != NULL) {
				bzero(&message.recipient, sizeof(struct path));

				lka_resolve_alias(&message.recipient, alias);
				lka_rcpt_action(env, &message.recipient);

d403 2
a404 5
				    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
				    &message, sizeof(struct message));

				TAILQ_REMOVE(&aliases, alias, entry);
				free(alias);
a405 3
			imsg_compose(env->sc_ibufs[PROC_QUEUE],
			    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1, &message,
			    sizeof(struct message));
d727 1
d977 1
a977 1
lka_expand_aliases(struct smtpd *env, struct aliaseslist *aliases, struct path *path)
d979 1
a979 2
	u_int8_t done = 0;
	size_t iterations = 5;
a980 1
	int ret;
d982 1
a982 26
	
	log_debug("RESOLVE ALIASES/.FORWARD FILES");
	log_debug("path->user: %s", path->user);
	log_debug("path->domain: %s", path->domain);

	if (path->flags & F_ACCOUNT)
		ret = forwards_get(aliases, path->pw_name);
	else if (path->flags & F_ALIAS)
		ret = aliases_get(env, aliases, path->user);
	else if (path->flags & F_VIRTUAL)
		ret = aliases_virtual_get(env, aliases, path);
	else
		fatalx("lka_expand_aliases: invalid path type");

	if (! ret)
		return 0;

	while (!done && iterations--) {
		done = 1;
		rmalias = NULL;
		TAILQ_FOREACH(alias, aliases, entry) {
			if (rmalias) {
				TAILQ_REMOVE(aliases, rmalias, entry);
				free(rmalias);
				rmalias = NULL;
			}
d984 2
a985 15
			if (alias->type == ALIAS_ADDRESS) {
				if (aliases_virtual_get(env, aliases, &alias->u.path)) {
					done = 0;
					rmalias = alias;
				}
			}
			
			else if (alias->type == ALIAS_USERNAME) {
				if (aliases_get(env, aliases, alias->u.username) ||
				    forwards_get(aliases, alias->u.username)) {
					rmalias = alias;
					done = 0;
				}
			}
		}
d991 28
d1021 1
a1021 6
	/* Loop detected, empty list */
	if (!done) {
		while ((alias = TAILQ_FIRST(aliases)) != NULL) {
			TAILQ_REMOVE(aliases, alias, entry);
			free(alias);
		}
a1022 1
	}
d1102 17
@


1.27
log
@reorganize code so that couple of indentation levels can be removed;
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.26 2009/02/22 19:07:33 chl Exp $	*/
a694 1
				++p;
@


1.26
log
@add missing headers

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.25 2009/02/22 11:44:29 form Exp $	*/
d194 2
a195 2
				    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1, &message,
				    sizeof (struct message));
d197 3
a199 2
				    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1, &message,
				    sizeof (struct message));
d201 2
a202 1
			else if (! lka_resolve_path(env, &ss->u.path)) {
d205 1
a206 2
			else {
				ss->code = 250;
d208 3
a210 1
				TAILQ_INIT(&aliases);
d212 12
a223 3
				expret = lka_expand_aliases(env, &aliases, &ss->u.path);
				if (expret < 0) {
					log_debug("loop detected, rejecting recipient");
d225 3
a227 40
					imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0, -1,
					    ss, sizeof(*ss));
				}
				else if (expret == 0) {
					log_debug("expansion resulted in empty list");
					if (! (ss->u.path.flags & F_ACCOUNT)) {
						ss->code = 530;
						imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0, -1,
						    ss, sizeof(*ss));
					}
					else {
						message = ss->msg;
						message.recipient = ss->u.path;
						imsg_compose(env->sc_ibufs[PROC_QUEUE],
						    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1, &message,
						    sizeof (struct message));
						imsg_compose(env->sc_ibufs[PROC_QUEUE],
						    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1, &message,
						    sizeof (struct message));
					}
				}
				else {
					log_debug("a list of aliases is available");
					message = ss->msg;
					while ((alias = TAILQ_FIRST(&aliases)) != NULL) {
						bzero(&message.recipient, sizeof (struct path));

						lka_resolve_alias(&message.recipient, alias);
						lka_rcpt_action(env, &message.recipient);

						imsg_compose(env->sc_ibufs[PROC_QUEUE],
						    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1, &message,
						    sizeof (struct message));

						TAILQ_REMOVE(&aliases, alias, entry);
						free(alias);
					}
					imsg_compose(env->sc_ibufs[PROC_QUEUE],
					    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1, &message,
					    sizeof (struct message));
d229 25
d255 3
@


1.25
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.24 2009/02/18 12:06:01 jacekm Exp $	*/
d33 1
@


1.24
log
@fix compiler warning; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.23 2009/02/17 22:15:01 jacekm Exp $	*/
d52 1
a52 1
int		lka_expand(char *, size_t, struct path *);
d323 1
a323 1
			strlcpy(s->s_hostname, addr, MAXHOSTNAMELEN);
d643 1
a643 1
	(void)strlcpy(username, path->user, MAXLOGNAME);
d657 5
a661 3
		(void)strlcpy(path->pw_name, pw->pw_name, MAXLOGNAME);
		if (lka_expand(path->rule.r_value.path, MAXPATHLEN, path) >=
		    MAXPATHLEN)
d668 1
a668 1
int
d699 2
a700 1
				ret = strlcpy(username, p + 1, MAXLOGNAME);
d702 1
a702 1
				if (delim == NULL && ret >= MAXLOGNAME) {
d800 2
a801 1
		strlcpy(path->u.filename, alias->u.filename, MAXPATHLEN);
d807 2
a808 1
		strlcpy(path->rule.r_value.command, alias->u.filter + 2, MAXPATHLEN);
d903 1
a903 1
	(void)strlcpy(username, path->user, MAXLOGNAME);
d918 5
a922 3
		(void)strlcpy(path->pw_name, pw->pw_name, MAXLOGNAME);
		if (lka_expand(path->rule.r_value.path, MAXPATHLEN, path) >=
		    MAXPATHLEN)
@


1.23
log
@kill unused func lka_resolve_rcpt()
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.22 2009/02/15 13:12:19 jacekm Exp $	*/
d811 1
@


1.22
log
@If MX query fails due to DNS error, do not attempt more queries; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.21 2009/02/15 10:32:23 jacekm Exp $	*/
a50 1
int		lka_resolve_rcpt(struct smtpd *, struct rule *, struct path *);
a660 33
	}

	return 1;
}

int
lka_resolve_rcpt(struct smtpd *env, struct rule *rule, struct path *path)
{
	char username[MAXLOGNAME];
	struct passwd *pw;
	char *p;

	(void)strlcpy(username, path->user, MAXLOGNAME);

	for (p = &username[0]; *p != '\0' && *p != '+'; ++p)
		*p = tolower((int)*p);
	*p = '\0';

	if ((path->flags & F_EXPANDED) == 0 && aliases_virtual_exist(env, path))
		path->flags |= F_VIRTUAL;
	else if ((path->flags & F_EXPANDED) == 0 && aliases_exist(env, username))
		path->flags |= F_ALIAS;
	else {
		pw = safe_getpwnam(path->pw_name);
		if (pw == NULL)
			pw = safe_getpwnam(username);
		if (pw == NULL)
			return 0;
		(void)strlcpy(path->pw_name, pw->pw_name, MAXLOGNAME);
		if (lka_expand(path->rule.r_value.path, MAXPATHLEN, path) >=
		    MAXPATHLEN) {
			return 0;
		}
@


1.21
log
@New config.c that allows for process cloning. Done by pyr@@ for
relayd at n2k9, and adapted to smtpd; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.20 2009/02/13 23:54:37 jacekm Exp $	*/
a52 1
size_t		getmxbyname(char *, char ***);
d426 1
a426 1
			size_t len, i, j;
d438 6
@


1.20
log
@Fix a crash in lka caused by wrong assumption that we would never
exceed MXARRAYSIZE * 2 addresses.

Commited on behalf of gilles@@ who hasn't got access to a safe box
at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.19 2009/01/28 17:43:45 gilles Exp $	*/
d579 1
@


1.19
log
@relayhost flags were not properly copied to the relayhost array of the
batch we're handing over to mta. this prevented mta from knowing if a
session has to be established over ssl or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.18 2009/01/08 19:17:31 jacekm Exp $	*/
d458 1
a458 1
			for (i = j = 0; i < len; ++i) {
d465 1
a465 1
				for (resp = res; resp != NULL; resp = resp->ai_next) {
d480 1
a486 1

@


1.18
log
@ensure getpwnam is always followed by endpwent; ok gilles@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.17 2009/01/07 00:26:30 gilles Exp $	*/
d466 4
@


1.17
log
@- when performing aliases expansion, do not forget to set an action to each
expanded envelope, orelse they will use the default action and be passed to
MTA no matter if recipient is local or not.
	bug reported by Nicholas Marriott <nicholas.marriott@@gmail.com>,
	fixed by me and okayd by jacekm@@, collaborative work ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.16 2009/01/06 23:12:28 gilles Exp $	*/
d645 1
a645 1
		pw = getpwnam(username);
d675 1
a675 1
		pw = getpwnam(path->pw_name);
d677 1
a677 1
			pw = getpwnam(username);
d705 1
a705 1
				pw = getpwnam(path->pw_name);
d731 1
a731 1
				pw = getpwnam(username);
d933 1
a933 1
		pw = getpwnam(username);
@


1.16
log
@- do not perform a local user lookup, that includes alias expansion, when a
recipient is ... not a local recipient (bug introduced very recently).
	Fix by Nicholas Marriott <nicholas.marriott@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.15 2009/01/04 17:45:58 gilles Exp $	*/
d66 1
d240 1
d242 2
d887 1
a888 1
					rmalias = alias;
d943 40
@


1.15
log
@When matching a recipient domain to a rule, do not use strcasecmp, but use
new hostname_match() function which recognizes * as a wildcard. We can now
do: accept for domain "*.example.org" to match all subdomains.

idea from Nicholas Marriott <nicholas.marriott@@gmail.com>, hostname_match()
from me in place of his fnmatch() calls.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.14 2009/01/04 14:46:14 jacekm Exp $	*/
d188 13
a200 2

			if (! lka_resolve_path(env, &ss->u.path)) {
@


1.14
log
@cleanup; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.13 2009/01/04 00:58:59 gilles Exp $	*/
d595 1
a595 2
					if (strcasecmp(me->me_key.med_string,
						path->domain) == 0) {
@


1.13
log
@aliases/forwards expansion was not done correctly and a race could
cause delivery to happen before expansion is over, causing some of
the recipients to never receive the mail. change how the mfa, lka,
queue and smtp processes communicate to ensure smtp never receives
an acknowledgment before ALL expanded envelopes are on disk. While
at it, lka was doing work which belongs in mfa, fix that also.

this is based on an idea from a talk with jacekm@@, change not over
but already better than what we had.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.12 2009/01/01 16:15:47 jacekm Exp $	*/
d57 1
a57 1
int		lka_resolve_alias(struct smtpd *, struct path *, struct alias *);
d228 1
a228 1
						lka_resolve_alias(env, &message.recipient, alias);
d794 1
a794 1
lka_resolve_alias(struct smtpd *env, struct path *path, struct alias *alias)
d821 2
a822 2
	default:
		/* ALIAS_INCLUDE cannot happen here, make gcc shut up */
d847 2
a851 1
	
@


1.12
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.11 2008/12/22 13:35:58 jacekm Exp $	*/
a49 1
int		lka_verify_rcpt(struct smtpd *, struct path *, struct sockaddr_storage *);
d57 1
a57 1
int		lka_resolve_alias(struct smtpd *, struct imsgbuf *, struct message *, struct alias *);
d64 2
d180 5
a184 1
			struct submit_status	 *ss;
d189 5
a193 4
			if (lka_verify_rcpt(env, &ss->u.path, &ss->ss))
				ss->code = 250;
			else if (ss->flags & F_MESSAGE_AUTHENTICATED) {
				log_debug("accepting for authenticated user");
a194 1
			}
d196 36
a231 2
			imsg_compose(ibuf, IMSG_LKA_RCPT, 0, 0, -1,
			    ss, sizeof(*ss));
d233 8
a360 147

		case IMSG_LKA_ALIAS: {
			struct message *messagep;
			struct alias *alias;
			struct alias *remalias;
			struct path *path;
			struct aliaseslist aliases;
			u_int8_t done = 0;
			size_t nbiterations = 5;
			int ret;

			messagep = imsg.data;
			path = &messagep->recipient;

			if (path->flags & F_EXPANDED)
				break;

			TAILQ_INIT(&aliases);

			if (path->flags & F_ALIAS) {
				ret = aliases_get(env, &aliases, path->user);
			}

			if (path->flags & F_VIRTUAL) {
				ret = aliases_virtual_get(env, &aliases, path);
			}

			if (! ret) {
				/*
				 * Aliases could not be retrieved, this happens
				 * if the aliases database is regenerated while
				 * the message is being processed. It is not an
				 * error necessarily so just ignore this and it
				 * will be handled by the queue process.
				 */
				imsg_compose(ibuf, IMSG_QUEUE_REMOVE_SUBMISSION, 0, 0, -1, messagep,
				    sizeof(struct message));
				break;
			}

			/* First pass, figure out if some of the usernames that
			 * are in the list are actually aliases and expand them
			 * if they are. The resolution will be tried five times
			 * at most with an early exit if list did not change in
			 * a pass.
			 */
			while (!done && nbiterations--) {
				done = 1;
				remalias = NULL;
				TAILQ_FOREACH(alias, &aliases, entry) {
					if (remalias) {
						TAILQ_REMOVE(&aliases, remalias, entry);
						free(remalias);
						remalias = NULL;
					}

					if (alias->type == ALIAS_ADDRESS) {
						if (aliases_virtual_get(env, &aliases, &alias->u.path)) {
							done = 0;
							remalias = alias;
						}
					}

					else if (alias->type == ALIAS_USERNAME) {
						if (aliases_get(env, &aliases, alias->u.username)) {
							done = 0;
							remalias = alias;
						}
					}
				}
				if (remalias) {
					TAILQ_REMOVE(&aliases, remalias, entry);
					free(remalias);
					remalias = NULL;
				}
			}

			/* Second pass, the list no longer contains aliases and
			 * the message can be sent back to queue process with a
			 * modified path.
			 */
			TAILQ_FOREACH(alias, &aliases, entry) {
				struct message message = *messagep;
				lka_resolve_alias(env, ibuf, &message, alias);
				imsg_compose(ibuf, IMSG_LKA_ALIAS, 0, 0, -1,
				    &message, sizeof(struct message));
			}

			imsg_compose(ibuf, IMSG_QUEUE_REMOVE_SUBMISSION, 0, 0, -1,
			    messagep, sizeof(struct message));

			while ((alias = TAILQ_FIRST(&aliases))) {
				TAILQ_REMOVE(&aliases, alias, entry);
				free(alias);
			}
			break;
		}

		case IMSG_LKA_FORWARD: {
			struct message *messagep;
			struct aliaseslist aliases;
			struct alias *alias;

			messagep = imsg.data;

			/* this is the tenth time the message has been forwarded
			 * internally, break out of the loop.
			 */
			if (messagep->recipient.forwardcnt == 10) {
				imsg_compose(ibuf, IMSG_QUEUE_REMOVE_SUBMISSION, 0, 0, -1, messagep,
				    sizeof(struct message));
				break;
			}
			messagep->recipient.forwardcnt++;

			TAILQ_INIT(&aliases);
			if (! forwards_get(&aliases, messagep->recipient.pw_name)) {
				messagep->recipient.flags |= F_NOFORWARD;
				imsg_compose(ibuf, IMSG_LKA_FORWARD, 0, 0, -1,
				    messagep, sizeof(struct message));
				imsg_compose(ibuf, IMSG_QUEUE_REMOVE_SUBMISSION,
				    0, 0, -1, messagep, sizeof(struct message));
				break;
			}

			TAILQ_FOREACH(alias, &aliases, entry) {
				struct message message = *messagep;
				lka_resolve_alias(env, ibuf, &message, alias);
				if (strcmp(messagep->recipient.pw_name, alias->u.username) == 0) {

					message.recipient.flags |= F_FORWARDED;
				}
				imsg_compose(ibuf, IMSG_LKA_FORWARD, 0, 0, -1,
				    &message, sizeof(struct message));
			}

			imsg_compose(ibuf, IMSG_QUEUE_REMOVE_SUBMISSION, 0, 0,
			    -1, messagep, sizeof(struct message));

			while ((alias = TAILQ_FIRST(&aliases))) {
				TAILQ_REMOVE(&aliases, alias, entry);
				free(alias);
			}

			break;
		}

a613 52
lka_verify_rcpt(struct smtpd *env, struct path *path, struct sockaddr_storage *ss)
{
	struct rule *r;
	struct cond *cond;
	struct map *map;
	struct mapel *me;

	TAILQ_FOREACH(r, env->sc_rules, r_entry) {

		TAILQ_FOREACH(cond, &r->r_conditions, c_entry) {

			if (cond->c_type == C_ALL) {
				path->rule = *r;

				if (! lka_check_source(env, r->r_sources, ss))
					return 0;

				if (r->r_action == A_MBOX ||
				    r->r_action == A_MAILDIR) {
					return lka_resolve_rcpt(env, r, path);
				}
				return 1;
			}

			if (cond->c_type == C_DOM) {

				cond->c_match = map_find(env, cond->c_map);
				if (cond->c_match == NULL)
					fatal("lka failed to lookup map.");

				map = cond->c_match;
				TAILQ_FOREACH(me, &map->m_contents, me_entry) {
					if (strcasecmp(me->me_key.med_string,
						path->domain) == 0) {
						path->rule = *r;
						if (! lka_check_source(env, r->r_sources, ss))
							return 0;

						if (IS_MAILBOX(r->r_action) ||
						    IS_EXT(r->r_action)) {
							return lka_resolve_rcpt(env, r, path);
						}
						return 1;
					}
				}
			}
		}
	}
	return 0;
}

int
d794 1
a794 1
lka_resolve_alias(struct smtpd *env, struct imsgbuf *ibuf, struct message *messagep, struct alias *alias)
a795 5
	struct path *rpath = &messagep->recipient;

	rpath->flags &= ~F_ALIAS;
	rpath->flags |= F_EXPANDED;

d798 3
a800 2
		if (strlcpy(rpath->pw_name, alias->u.username,
			sizeof(rpath->pw_name)) >= sizeof(rpath->pw_name))
a801 1
		lka_verify_rcpt(env, rpath, NULL);
d805 3
a807 2
		rpath->rule.r_action = A_FILENAME;
		strlcpy(rpath->u.filename, alias->u.filename, MAXPATHLEN);
d811 4
a814 3
		rpath->rule.r_action = A_EXT;
		strlcpy(rpath->rule.r_value.command, alias->u.filter + 2, MAXPATHLEN);
		rpath->rule.r_value.command[strlen(rpath->rule.r_value.command) - 1] = '\0';
d818 2
a819 8
		*rpath = alias->u.path;
		lka_verify_rcpt(env, rpath, NULL);
		if (IS_MAILBOX(rpath->rule.r_action) ||
		    IS_EXT(rpath->rule.r_action))
			messagep->type = T_MDA_MESSAGE;
		else
			messagep->type = T_MTA_MESSAGE;

d829 1
a829 1
lka_check_source(struct smtpd *env, struct map *map, struct sockaddr_storage *ss)
d831 16
a846 1
	struct mapel *me;
d848 3
a850 6
	if (ss == NULL) {
		/* This happens when caller is part of an internal
		 * lookup (ie: alias resolved to a remote address)
		 */
		return 1;
	}
d852 9
a860 1
	TAILQ_FOREACH(me, &map->m_contents, me_entry) {
d862 21
a882 2
		if (ss->ss_family != me->me_key.med_addr.ss.ss_family)
			continue;
d884 8
a891 2
		if (ss->ss_len == me->me_key.med_addr.ss.ss_len)
			continue;
d893 2
a894 2
		if (lka_match_mask(ss, &me->me_key.med_addr))
			return 1;
d896 1
a896 2
	}
	return 0;
d900 1
a900 1
lka_match_mask(struct sockaddr_storage *ss, struct netaddr *ssmask)
d902 9
a910 9
	if (ss->ss_family == AF_INET) {
		struct sockaddr_in *ssin = (struct sockaddr_in *)ss;
		struct sockaddr_in *ssinmask = (struct sockaddr_in *)&ssmask->ss;

		if ((ssin->sin_addr.s_addr & ssinmask->sin_addr.s_addr) ==
		    ssinmask->sin_addr.s_addr)
			return (1);
		return (0);
	}
d912 13
a924 22
	if (ss->ss_family == AF_INET6) {
		struct in6_addr	*in;
		struct in6_addr	*inmask;
		struct in6_addr	 mask;
		int		 i;

		bzero(&mask, sizeof(mask));
		for (i = 0; i < (128 - ssmask->masked) / 8; i++)
			mask.s6_addr[i] = 0xff;
		i = ssmask->masked % 8;
		if (i)
			mask.s6_addr[ssmask->masked / 8] = 0xff00 >> i;

		in = &((struct sockaddr_in6 *)ss)->sin6_addr;
		inmask = &((struct sockaddr_in6 *)&ssmask->ss)->sin6_addr;

		for (i = 0; i < 16; i++) {
			if ((in->s6_addr[i] & mask.s6_addr[i]) !=
			    inmask->s6_addr[i])
				return (0);
		}
		return (1);
d927 1
a927 1
	return (0);
@


1.11
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.10 2008/12/22 13:14:30 jacekm Exp $	*/
a24 1
#include <sys/time.h>
a29 1
#include <db.h>
d31 1
a31 1
#include <fcntl.h>
a32 2
#include <netdb.h>
#include <signal.h>
a36 1
#include <util.h>
@


1.10
log
@Reduce IMSG_LKA_HOST to only make NI_NAMEREQD getnameinfo call. We
don't need it to return NI_NUMERICHOST conversion because there's
no reason not to do it in smtp; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.9 2008/12/22 12:59:15 jacekm Exp $	*/
d256 1
a256 1
			    NULL, 0, NI_NAMEREQD));
@


1.9
log
@delinting: salen may be used with no prior init; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.8 2008/12/20 00:18:03 gilles Exp $	*/
d248 1
a248 2

			struct sockaddr *sa = NULL;
d251 1
a251 2
			int error;
			struct session *s = imsg.data;
d253 13
a265 7
			if (s->s_ss.ss_family == PF_INET) {
				struct sockaddr_in *ssin = (struct sockaddr_in *)&s->s_ss;
				sa = (struct sockaddr *)ssin;
			}
			if (s->s_ss.ss_family == PF_INET6) {
				struct sockaddr_in6 *ssin6 = (struct sockaddr_in6 *)&s->s_ss;
				sa = (struct sockaddr *)ssin6;
a267 18
			error = getnameinfo(sa, sa->sa_len, addr, sizeof(addr),
			    NULL, 0, NI_NAMEREQD);
			if (error == 0) {
				memset(&hints, 0, sizeof(hints));
				hints.ai_socktype = SOCK_DGRAM;
				hints.ai_flags = AI_NUMERICHOST;
				if (getaddrinfo(addr, "0", &hints, &res) == 0) {
					freeaddrinfo(res);
					strlcpy(s->s_hostname, "<bogus>",
					    MAXHOSTNAMELEN);
					imsg_compose(ibuf, IMSG_LKA_HOST, 0, 0,
					    -1, s, sizeof(struct session));
					break;
				}
			} else {
				error = getnameinfo(sa, sa->sa_len, addr, sizeof(addr),
				    NULL, 0, NI_NUMERICHOST);
			}
d269 2
a270 2
			imsg_compose(ibuf, IMSG_LKA_HOST, 0, 0, -1,
			    s, sizeof(struct session));
@


1.8
log
@- import first bricks of SMTP AUTH support. currently only AUTH PLAIN is
	supported, AUTH LOGIN will follow soon. AUTH will only work if a
	listen directive has "enable auth" keywords, AND session is safe
	(ssmtp or starttls).
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.7 2008/12/13 23:19:33 jacekm Exp $	*/
a249 1
			socklen_t salen;
d279 1
a279 1
				error = getnameinfo(sa, salen, addr, sizeof(addr),
@


1.7
log
@IMSG_* namespace cleanup.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.6 2008/12/05 19:09:59 gilles Exp $	*/
d191 4
@


1.6
log
@- more err/errx -> fatal/fatalx, warn/warnx -> log_warn/log_warnx
	contains bits based on an old diff from Jacek Masiulaniec and
	other bits from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.5 2008/12/05 02:51:32 gilles Exp $	*/
d166 1
a166 1
		case IMSG_LKA_LOOKUP_MAIL: {
d178 1
a178 1
			imsg_compose(ibuf, IMSG_MFA_LOOKUP_MAIL, 0, 0, -1,
d183 1
a183 1
		case IMSG_LKA_LOOKUP_RCPT: {
d192 1
a192 1
			imsg_compose(ibuf, IMSG_MFA_LOOKUP_RCPT, 0, 0, -1,
d243 1
a243 1
		case IMSG_LKA_HOSTNAME_LOOKUP: {
d269 4
a272 3
					strlcpy(s->s_hostname, "<bogus>", MAXHOSTNAMELEN);
					imsg_compose(ibuf, IMSG_SMTP_HOSTNAME_ANSWER, 0, 0, -1,
					    s, sizeof(struct session));
d280 1
a280 1
			imsg_compose(ibuf, IMSG_SMTP_HOSTNAME_ANSWER, 0, 0, -1,
d331 1
a331 1
		case IMSG_LKA_ALIAS_LOOKUP: {
d414 1
a414 1
				imsg_compose(ibuf, IMSG_LKA_ALIAS_RESULT, 0, 0, -1,
d428 1
a428 1
		case IMSG_LKA_FORWARD_LOOKUP: {
d448 4
a451 3
				imsg_compose(ibuf, IMSG_LKA_FORWARD_LOOKUP, 0, 0, -1, messagep, sizeof(struct message));
				imsg_compose(ibuf, IMSG_QUEUE_REMOVE_SUBMISSION, 0, 0, -1, messagep,
				    sizeof(struct message));
d462 2
a463 1
				imsg_compose(ibuf, IMSG_LKA_FORWARD_LOOKUP, 0, 0, -1, &message, sizeof(struct message));
d466 2
a467 1
			imsg_compose(ibuf, IMSG_QUEUE_REMOVE_SUBMISSION, 0, 0, -1, messagep, sizeof(struct message));
d523 1
a523 1
		case IMSG_LKA_MX_LOOKUP: {
d591 2
a592 1
			imsg_compose(ibuf, IMSG_LKA_MX_LOOKUP, 0, 0, -1, batchp, sizeof(*batchp));
@


1.5
log
@- last part of the new queue code: the runner process (unprivileged and
	chrooted) is now in charge of doing the scheduling of deliveries,
	and the dispatching of messages to MDA and MTA. queue process only
	does inserts/updates/removals from the queue and can no longer be
	so busy that it delays answers to imsg from smtp server.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.4 2008/11/25 20:26:40 gilles Exp $	*/
a31 1
#include <err.h>
d531 1
a531 1
				err(1, "lka_dispatch_queue: inconsistent internal state");
@


1.4
log
@- recent change in parse.y caused htons() to be called twice on the port
	provided to "relay via" rules, once in parse.y once in lka.c, fix.
- rename struct address to struct relayhost, introduce struct mxhost which
	not only holds the sockaddr_storage, but also additionnal flags we
	want forwarded to the mta process.
- propagate the change
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.3 2008/11/10 21:29:18 chl Exp $	*/
d52 1
d474 46
d595 1
d597 1
a597 1
			log_debug("lka_dispatch_queue: unexpected imsg %d",
d637 1
d672 1
a672 1
	config_peers(env, peers, 4);
@


1.3
log
@rename h_errno field into getaddrinfo_error, to avoid confusion with errno.

h_errno has been obsoleted since the gethostbyname() --> getaddrinfo() replacement.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d480 1
a480 1
			u_int16_t port = 25;
d497 4
a500 3
				lmx[0] = batchp->rule.r_value.host.hostname;
				port = batchp->rule.r_value.host.port;
				log_debug("attempting to resolve %s:%d (forced)", lmx[0], port);
d503 1
d520 3
a522 3
						batchp->ss[j] = *(struct sockaddr_storage *)resp->ai_addr;
						ssin = (struct sockaddr_in *)&batchp->ss[j];
						ssin->sin_port = htons(port);
d527 3
a529 3
						batchp->ss[j] = *(struct sockaddr_storage *)resp->ai_addr;
						ssin6 = (struct sockaddr_in6 *)&batchp->ss[j];
						ssin6->sin6_port = htons(port);
d537 1
a537 1
			batchp->ss_cnt = j;
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d536 1
a536 1
			batchp->h_errno = 0;
d538 1
a538 1
				batchp->h_errno = error;
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

