head	1.155;
access;
symbols
	OPENBSD_6_1:1.155.0.6
	OPENBSD_6_1_BASE:1.155
	OPENBSD_6_0:1.155.0.4
	OPENBSD_6_0_BASE:1.155
	OPENBSD_5_9:1.154.0.2
	OPENBSD_5_9_BASE:1.154
	OPENBSD_5_8:1.143.0.6
	OPENBSD_5_8_BASE:1.143
	OPENBSD_5_7:1.143.0.2
	OPENBSD_5_7_BASE:1.143
	OPENBSD_5_6:1.139.0.4
	OPENBSD_5_6_BASE:1.139
	OPENBSD_5_5:1.133.0.2
	OPENBSD_5_5_BASE:1.133
	OPENBSD_5_4:1.127.0.2
	OPENBSD_5_4_BASE:1.127
	OPENBSD_5_3:1.123.0.2
	OPENBSD_5_3_BASE:1.123
	OPENBSD_5_2:1.102.0.2
	OPENBSD_5_2_BASE:1.102
	OPENBSD_5_1_BASE:1.101
	OPENBSD_5_1:1.101.0.2
	OPENBSD_5_0:1.86.0.2
	OPENBSD_5_0_BASE:1.86
	OPENBSD_4_9:1.79.0.2
	OPENBSD_4_9_BASE:1.79
	OPENBSD_4_8:1.75.0.2
	OPENBSD_4_8_BASE:1.75
	OPENBSD_4_7:1.67.0.2
	OPENBSD_4_7_BASE:1.67
	OPENBSD_4_6:1.58.0.4
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29;
locks; strict;
comment	@ * @;


1.155
date	2016.03.25.15.06.58;	author krw;	state Exp;
branches;
next	1.154;
commitid	0NIU7T9t8yqZHZQl;

1.154
date	2016.02.13.20.43.07;	author gilles;	state Exp;
branches;
next	1.153;
commitid	qHtqvYWG27YyW9EZ;

1.153
date	2016.02.13.09.28.13;	author gilles;	state Exp;
branches;
next	1.152;
commitid	IR1k7suFsvIkMSDB;

1.152
date	2016.01.08.21.31.06;	author jung;	state Exp;
branches;
next	1.151;
commitid	3xiCOUnr79uq4a4a;

1.151
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.150;
commitid	ZxnqOQqX6IeYI9jW;

1.150
date	2015.12.13.09.52.44;	author gilles;	state Exp;
branches;
next	1.149;
commitid	OUT78jWdQV3PCjhK;

1.149
date	2015.12.12.17.16.56;	author gilles;	state Exp;
branches;
next	1.148;
commitid	O1qQ3TEBrjXRGaeN;

1.148
date	2015.12.12.12.22.25;	author gilles;	state Exp;
branches;
next	1.147;
commitid	w98xM5rwyFdbQWM5;

1.147
date	2015.12.12.11.31.29;	author sunil;	state Exp;
branches;
next	1.146;
commitid	xbftp8DyefrEq9pW;

1.146
date	2015.12.12.09.54.48;	author gilles;	state Exp;
branches;
next	1.145;
commitid	OYDVGIIHmjvj9jh7;

1.145
date	2015.12.11.20.14.14;	author gilles;	state Exp;
branches;
next	1.144;
commitid	rkAlCw76UcetukRW;

1.144
date	2015.11.30.12.49.35;	author gilles;	state Exp;
branches;
next	1.143;
commitid	ZyOzw2IPUjoaWKi5;

1.143
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.142;
commitid	ZBTFreARDSMmzOIV;

1.142
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.141;
commitid	Uu5nFG3wCl0LACBb;

1.141
date	2014.11.05.19.38.09;	author gilles;	state Exp;
branches;
next	1.140;
commitid	XnNCq9gFgDdXLAGZ;

1.140
date	2014.10.12.11.49.38;	author gilles;	state Exp;
branches;
next	1.139;
commitid	dXqhRqPaFDOmCpNv;

1.139
date	2014.07.08.14.38.17;	author eric;	state Exp;
branches;
next	1.138;
commitid	r5wkdyPuX2zITub9;

1.138
date	2014.07.08.07.59.31;	author sobrado;	state Exp;
branches;
next	1.137;
commitid	QejPnWBk7nSpcYUN;

1.137
date	2014.04.29.19.13.13;	author reyk;	state Exp;
branches;
next	1.136;

1.136
date	2014.04.19.13.52.49;	author gilles;	state Exp;
branches;
next	1.135;

1.135
date	2014.04.09.18.55.19;	author eric;	state Exp;
branches;
next	1.134;

1.134
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.133;

1.133
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.132;

1.132
date	2014.02.04.09.05.06;	author eric;	state Exp;
branches;
next	1.131;

1.131
date	2013.12.05.15.05.53;	author eric;	state Exp;
branches;
next	1.130;

1.130
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.129;

1.129
date	2013.10.27.11.01.47;	author eric;	state Exp;
branches;
next	1.128;

1.128
date	2013.10.27.07.56.25;	author eric;	state Exp;
branches;
next	1.127;

1.127
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.126;

1.126
date	2013.07.19.07.49.08;	author eric;	state Exp;
branches;
next	1.125;

1.125
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.124;

1.124
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.122;

1.122
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.121;

1.121
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.120;

1.120
date	2012.10.07.15.46.38;	author chl;	state Exp;
branches;
next	1.119;

1.119
date	2012.10.03.16.43.19;	author chl;	state Exp;
branches;
next	1.118;

1.118
date	2012.10.02.12.37.38;	author chl;	state Exp;
branches;
next	1.117;

1.117
date	2012.09.29.22.16.46;	author chl;	state Exp;
branches;
next	1.116;

1.116
date	2012.09.19.18.20.36;	author eric;	state Exp;
branches;
next	1.115;

1.115
date	2012.09.17.18.36.14;	author eric;	state Exp;
branches;
next	1.114;

1.114
date	2012.09.17.08.32.00;	author eric;	state Exp;
branches;
next	1.113;

1.113
date	2012.09.16.19.16.23;	author gilles;	state Exp;
branches;
next	1.112;

1.112
date	2012.09.16.16.43.29;	author chl;	state Exp;
branches;
next	1.111;

1.111
date	2012.09.15.15.12.11;	author eric;	state Exp;
branches;
next	1.110;

1.110
date	2012.09.14.16.38.53;	author eric;	state Exp;
branches;
next	1.109;

1.109
date	2012.08.29.16.26.17;	author gilles;	state Exp;
branches;
next	1.108;

1.108
date	2012.08.25.22.03.26;	author gilles;	state Exp;
branches;
next	1.107;

1.107
date	2012.08.25.21.33.33;	author gilles;	state Exp;
branches;
next	1.106;

1.106
date	2012.08.25.10.23.12;	author gilles;	state Exp;
branches;
next	1.105;

1.105
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.104;

1.104
date	2012.08.18.18.18.23;	author gilles;	state Exp;
branches;
next	1.103;

1.103
date	2012.08.09.09.48.02;	author eric;	state Exp;
branches;
next	1.102;

1.102
date	2012.06.01.14.55.09;	author eric;	state Exp;
branches;
next	1.101;

1.101
date	2012.01.31.21.05.26;	author gilles;	state Exp;
branches;
next	1.100;

1.100
date	2012.01.29.11.37.32;	author eric;	state Exp;
branches;
next	1.99;

1.99
date	2012.01.18.13.41.54;	author chl;	state Exp;
branches;
next	1.98;

1.98
date	2012.01.13.14.27.55;	author eric;	state Exp;
branches;
next	1.97;

1.97
date	2012.01.12.18.06.18;	author eric;	state Exp;
branches;
next	1.96;

1.96
date	2011.12.13.23.55.00;	author gilles;	state Exp;
branches;
next	1.95;

1.95
date	2011.12.12.17.17.55;	author eric;	state Exp;
branches;
next	1.94;

1.94
date	2011.11.14.19.23.41;	author chl;	state Exp;
branches;
next	1.93;

1.93
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.92;

1.92
date	2011.10.09.18.39.54;	author eric;	state Exp;
branches;
next	1.91;

1.91
date	2011.09.01.20.17.47;	author gilles;	state Exp;
branches;
next	1.90;

1.90
date	2011.09.01.19.56.49;	author eric;	state Exp;
branches;
next	1.89;

1.89
date	2011.08.31.18.56.30;	author gilles;	state Exp;
branches;
next	1.88;

1.88
date	2011.08.29.18.49.29;	author chl;	state Exp;
branches;
next	1.87;

1.87
date	2011.08.27.22.32.41;	author gilles;	state Exp;
branches;
next	1.86;

1.86
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.85;

1.85
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.84;

1.84
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.83;

1.83
date	2011.04.17.11.39.23;	author gilles;	state Exp;
branches;
next	1.82;

1.82
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.81;

1.81
date	2011.03.15.19.24.55;	author gilles;	state Exp;
branches;
next	1.80;

1.80
date	2011.03.09.20.59.22;	author gilles;	state Exp;
branches;
next	1.79;

1.79
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.78;

1.78
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.77;

1.77
date	2010.11.24.23.27.04;	author todd;	state Exp;
branches;
next	1.76;

1.76
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.75;

1.75
date	2010.06.02.19.16.53;	author chl;	state Exp;
branches;
next	1.74;

1.74
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.73;

1.73
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.72;

1.72
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.19.20.57.10;	author gilles;	state Exp;
branches;
next	1.70;

1.70
date	2010.04.21.18.54.43;	author jacekm;	state Exp;
branches;
next	1.69;

1.69
date	2010.04.21.08.29.01;	author jacekm;	state Exp;
branches;
next	1.68;

1.68
date	2010.04.20.15.34.56;	author jacekm;	state Exp;
branches;
next	1.67;

1.67
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.66;

1.66
date	2009.12.14.19.49.22;	author jacekm;	state Exp;
branches;
next	1.65;

1.65
date	2009.12.13.22.02.55;	author jacekm;	state Exp;
branches;
next	1.64;

1.64
date	2009.11.08.21.40.05;	author gilles;	state Exp;
branches;
next	1.63;

1.63
date	2009.10.25.21.06.06;	author gilles;	state Exp;
branches;
next	1.62;

1.62
date	2009.09.18.00.04.26;	author jacekm;	state Exp;
branches;
next	1.61;

1.61
date	2009.09.03.08.19.13;	author jacekm;	state Exp;
branches;
next	1.60;

1.60
date	2009.08.06.16.46.57;	author gilles;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.06.13.40.45;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.07.05.56.25;	author eric;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.02.22.23.36;	author gilles;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.01.14.38.45;	author jacekm;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.01.13.20.56;	author jacekm;	state Exp;
branches;
next	1.52;

1.52
date	2009.05.25.14.00.36;	author jacekm;	state Exp;
branches;
next	1.51;

1.51
date	2009.05.24.15.47.31;	author jacekm;	state Exp;
branches;
next	1.50;

1.50
date	2009.05.24.14.38.56;	author jacekm;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.24.14.22.23;	author jacekm;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.20.14.29.44;	author gilles;	state Exp;
branches;
next	1.47;

1.47
date	2009.05.19.11.24.24;	author jacekm;	state Exp;
branches;
next	1.46;

1.46
date	2009.05.18.20.23.35;	author jacekm;	state Exp;
branches;
next	1.45;

1.45
date	2009.05.14.15.05.12;	author eric;	state Exp;
branches;
next	1.44;

1.44
date	2009.05.10.11.29.40;	author jacekm;	state Exp;
branches;
next	1.43;

1.43
date	2009.05.09.18.59.09;	author jacekm;	state Exp;
branches;
next	1.42;

1.42
date	2009.05.09.17.04.55;	author jacekm;	state Exp;
branches;
next	1.41;

1.41
date	2009.04.28.22.38.22;	author jacekm;	state Exp;
branches;
next	1.40;

1.40
date	2009.04.28.21.55.16;	author jacekm;	state Exp;
branches;
next	1.39;

1.39
date	2009.04.27.16.22.17;	author jacekm;	state Exp;
branches;
next	1.38;

1.38
date	2009.04.24.09.38.11;	author jacekm;	state Exp;
branches;
next	1.37;

1.37
date	2009.04.24.08.35.48;	author jacekm;	state Exp;
branches;
next	1.36;

1.36
date	2009.04.21.14.37.32;	author eric;	state Exp;
branches;
next	1.35;

1.35
date	2009.04.20.17.07.01;	author jacekm;	state Exp;
branches;
next	1.34;

1.34
date	2009.04.16.15.35.06;	author jacekm;	state Exp;
branches;
next	1.33;

1.33
date	2009.04.09.19.49.34;	author jacekm;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.29.14.18.20;	author jacekm;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.15.19.32.10;	author gilles;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.15.18.12.15;	author gilles;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.23.00.51.32;	author chl;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.22.19.07.33;	author chl;	state Exp;
branches;
next	1.27;

1.27
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.26;

1.26
date	2009.02.18.00.29.52;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.18.00.17.39;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.17.21.53.55;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.15.10.32.23;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.30.21.40.21;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.30.21.22.33;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.30.17.34.58;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.30.16.37.52;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.29.21.59.15;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.28.19.38.46;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.04.22.35.09;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.04.00.58.59;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.26.10.28.31;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.22.13.18.58;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.21.18.51.08;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.21.02.18.46;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.13.23.19.34;	author jacekm;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.03.17.58.00;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.24.22.30.19;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.17.21.56.18;	author chl;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.13.23.24.19;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.11.02.14.58;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.11.01.08.08;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.155
log
@Nuke session_socket_blockmode() and session_socket_linger(). Use
the identical io_set_blocking() and io_set_linger().

Since both are always called to turn off blocking or lingering,
nuke the parameter and associated enum in favour of "just doing the
right thing".

While passing remove the unneeded last parameter to the remaining
fcntl(F_GETFL).

Finally, rename the functions to io_set_nonblocking() and
io_set_nolinger() for clarity.

No functional change.

Started with a sweep of fcntl() usage inspired by guenther@@.

ok gilles@@
@
text
@/*	$OpenBSD: smtp.c,v 1.154 2016/02/13 20:43:07 gilles Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>

#include <err.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <netdb.h>
#include <pwd.h>
#include <signal.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <openssl/ssl.h>

#include "smtpd.h"
#include "log.h"
#include "ssl.h"

static void smtp_setup_events(void);
static void smtp_pause(void);
static void smtp_resume(void);
static void smtp_accept(int, short, void *);
static int smtp_enqueue(void);
static int smtp_can_accept(void);
static void smtp_setup_listeners(void);
static int smtp_sni_callback(SSL *, int *, void *);

#define	SMTP_FD_RESERVE	5
static size_t	sessions;
static size_t	maxsessions;

void
smtp_imsg(struct mproc *p, struct imsg *imsg)
{
	if (p->proc == PROC_LKA) {
		switch (imsg->hdr.type) {
		case IMSG_SMTP_DNS_PTR:
		case IMSG_SMTP_CHECK_SENDER:
		case IMSG_SMTP_EXPAND_RCPT:
		case IMSG_SMTP_LOOKUP_HELO:
		case IMSG_SMTP_AUTHENTICATE:
		case IMSG_SMTP_TLS_INIT:
		case IMSG_SMTP_TLS_VERIFY:
			smtp_session_imsg(p, imsg);
			return;
		}
	}

	if (p->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_SMTP_MESSAGE_COMMIT:
		case IMSG_SMTP_MESSAGE_CREATE:
		case IMSG_SMTP_MESSAGE_OPEN:
		case IMSG_QUEUE_ENVELOPE_SUBMIT:
		case IMSG_QUEUE_ENVELOPE_COMMIT:
			smtp_session_imsg(p, imsg);
			return;

		case IMSG_QUEUE_SMTP_SESSION:
			m_compose(p, IMSG_QUEUE_SMTP_SESSION, 0, 0,
			    smtp_enqueue(), imsg->data,
			    imsg->hdr.len - sizeof imsg->hdr);
			return;
		}
	}

	if (p->proc == PROC_CONTROL) {
		switch (imsg->hdr.type) {
		case IMSG_CTL_SMTP_SESSION:
			m_compose(p, IMSG_CTL_SMTP_SESSION, imsg->hdr.peerid, 0,
			    smtp_enqueue(), NULL, 0);
			return;

		case IMSG_CTL_PAUSE_SMTP:
			log_debug("debug: smtp: pausing listening sockets");
			smtp_pause();
			env->sc_flags |= SMTPD_SMTP_PAUSED;
			return;

		case IMSG_CTL_RESUME_SMTP:
			log_debug("debug: smtp: resuming listening sockets");
			env->sc_flags &= ~SMTPD_SMTP_PAUSED;
			smtp_resume();
			return;
		}
	}

	errx(1, "smtp_imsg: unexpected %s imsg", imsg_to_str(imsg->hdr.type));
}

void
smtp_postfork(void)
{
	smtp_setup_listeners();
}

void
smtp_postprivdrop(void)
{
}

void
smtp_configure(void)
{
	smtp_setup_events();
}

static void
smtp_setup_listeners(void)
{
	struct listener	       *l;
	int			opt;

	TAILQ_FOREACH(l, env->sc_listeners, entry) {
		if ((l->fd = socket(l->ss.ss_family, SOCK_STREAM, 0)) == -1) {
			if (errno == EAFNOSUPPORT) {
				log_warn("smtpd: socket");
				continue;
			}
			fatal("smtpd: socket");
		}
		opt = 1;
		if (setsockopt(l->fd, SOL_SOCKET, SO_REUSEADDR, &opt,
			sizeof(opt)) < 0)
			fatal("smtpd: setsockopt");
		if (bind(l->fd, (struct sockaddr *)&l->ss, l->ss.ss_len) == -1)
			fatal("smtpd: bind");
	}
}

static void
smtp_setup_events(void)
{
	struct listener *l;
	struct pki	*pki;
	SSL_CTX		*ssl_ctx;
	void		*iter;
	const char	*k;

	TAILQ_FOREACH(l, env->sc_listeners, entry) {
		log_debug("debug: smtp: listen on %s port %d flags 0x%01x"
		    " pki \"%s\""
		    " ca \"%s\"", ss_to_text(&l->ss), ntohs(l->port),
		    l->flags, l->pki_name, l->ca_name);

		io_set_nonblocking(l->fd);
		if (listen(l->fd, SMTPD_BACKLOG) == -1)
			fatal("listen");
		event_set(&l->ev, l->fd, EV_READ|EV_PERSIST, smtp_accept, l);

		if (!(env->sc_flags & SMTPD_SMTP_PAUSED))
			event_add(&l->ev, NULL);
	}

	iter = NULL;
	while (dict_iter(env->sc_pki_dict, &iter, &k, (void **)&pki)) {
		if (!ssl_setup((SSL_CTX **)&ssl_ctx, pki, smtp_sni_callback,
			env->sc_tls_ciphers))
			fatal("smtp_setup_events: ssl_setup failure");
		dict_xset(env->sc_ssl_dict, k, ssl_ctx);
	}

	purge_config(PURGE_PKI_KEYS);

	maxsessions = (getdtablesize() - getdtablecount()) / 2 - SMTP_FD_RESERVE;
	log_debug("debug: smtp: will accept at most %zu clients", maxsessions);
}

static void
smtp_pause(void)
{
	struct listener *l;

	if (env->sc_flags & (SMTPD_SMTP_DISABLED|SMTPD_SMTP_PAUSED))
		return;

	TAILQ_FOREACH(l, env->sc_listeners, entry)
		event_del(&l->ev);
}

static void
smtp_resume(void)
{
	struct listener *l;

	if (env->sc_flags & (SMTPD_SMTP_DISABLED|SMTPD_SMTP_PAUSED))
		return;

	TAILQ_FOREACH(l, env->sc_listeners, entry)
		event_add(&l->ev, NULL);
}

static int
smtp_enqueue(void)
{
	struct listener	*listener = env->sc_sock_listener;
	int		 fd[2];

	/*
	 * Some enqueue requests buffered in IMSG may still arrive even after
	 * call to smtp_pause() because enqueue listener is not a real socket
	 * and thus cannot be paused properly.
	 */
	if (env->sc_flags & SMTPD_SMTP_PAUSED)
		return (-1);

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, fd))
		return (-1);

	if ((smtp_session(listener, fd[0], &listener->ss, env->sc_hostname)) == -1) {
		close(fd[0]);
		close(fd[1]);
		return (-1);
	}

	sessions++;
	stat_increment("smtp.session", 1);
	stat_increment("smtp.session.local", 1);

	return (fd[1]);
}

static void
smtp_accept(int fd, short event, void *p)
{
	struct listener		*listener = p;
	struct sockaddr_storage	 ss;
	socklen_t		 len;
	int			 sock;

	if (env->sc_flags & SMTPD_SMTP_PAUSED)
		fatalx("smtp_session: unexpected client");

	if (!smtp_can_accept()) {
		log_warnx("warn: Disabling incoming SMTP connections: "
		    "Client limit reached");
		goto pause;
	}

	len = sizeof(ss);
	if ((sock = accept(fd, (struct sockaddr *)&ss, &len)) == -1) {
		if (errno == ENFILE || errno == EMFILE) {
			log_warn("warn: Disabling incoming SMTP connections");
			goto pause;
		}
		if (errno == EINTR || errno == EWOULDBLOCK ||
		    errno == ECONNABORTED)
			return;
		fatal("smtp_accept");
	}

	if (smtp_session(listener, sock, &ss, NULL) == -1) {
		log_warn("warn: Failed to create SMTP session");
		close(sock);
		return;
	}
	io_set_nonblocking(sock);

	sessions++;
	stat_increment("smtp.session", 1);
	if (listener->ss.ss_family == AF_LOCAL)
		stat_increment("smtp.session.local", 1);
	if (listener->ss.ss_family == AF_INET)
		stat_increment("smtp.session.inet4", 1);
	if (listener->ss.ss_family == AF_INET6)
		stat_increment("smtp.session.inet6", 1);
	return;

pause:
	smtp_pause();
	env->sc_flags |= SMTPD_SMTP_DISABLED;
	return;
}

static int
smtp_can_accept(void)
{
	if (sessions + 1 == maxsessions)
		return 0;
	return (getdtablesize() - getdtablecount() - SMTP_FD_RESERVE >= 2);
}

void
smtp_collect(void)
{
	sessions--;
	stat_decrement("smtp.session", 1);

	if (!smtp_can_accept())
		return;

	if (env->sc_flags & SMTPD_SMTP_DISABLED) {
		log_warnx("warn: smtp: "
		    "fd exhaustion over, re-enabling incoming connections");
		env->sc_flags &= ~SMTPD_SMTP_DISABLED;
		smtp_resume();
	}
}

static int
smtp_sni_callback(SSL *ssl, int *ad, void *arg)
{
	const char		*sn;
	void			*ssl_ctx;

	sn = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
	if (sn == NULL)
		return SSL_TLSEXT_ERR_NOACK;
	ssl_ctx = dict_get(env->sc_ssl_dict, sn);
	if (ssl_ctx == NULL)
		return SSL_TLSEXT_ERR_NOACK;
	SSL_set_SSL_CTX(ssl, ssl_ctx);
	return SSL_TLSEXT_ERR_OK;
}
@


1.154
log
@handle enqueuer socket as a regular listener that can be configured with
"listen on socket". this simplifies a bit of code, removes some special
cases and will allow attaching filters & masking source just as on lo0.

diff from Peter Bisroev <peter@@int19h.net>
ok gilles@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.153 2016/02/13 09:28:13 gilles Exp $	*/
d172 1
a172 1
		session_socket_blockmode(l->fd, BM_NONBLOCK);
d283 1
a283 1
	io_set_blocking(sock, 0);
@


1.153
log
@remove some noop leftover code from an earlier cleanup

diff from Peter Bisroev <peter@@int19h.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.152 2016/01/08 21:31:06 jung Exp $	*/
d222 2
a223 13
	static struct listener	 local, *listener = NULL;
	int			 fd[2];

	if (listener == NULL) {
		listener = &local;
		(void)strlcpy(listener->tag, "local", sizeof(listener->tag));
		listener->ss.ss_family = AF_LOCAL;
		listener->ss.ss_len = sizeof(struct sockaddr *);
		(void)strlcpy(listener->hostname, env->sc_hostname,
		    sizeof(listener->hostname));
		(void)strlcpy(listener->filter, env->sc_enqueue_filter,
		    sizeof listener->filter);
	}
@


1.152
log
@adjust a debug message to use decimal instead of hex

ok gilles millert
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.151 2015/12/28 22:08:30 jung Exp $	*/
d49 1
a49 1
static int smtp_enqueue(uid_t *);
d87 1
a87 1
			    smtp_enqueue(NULL), imsg->data,
d97 1
a97 1
			    smtp_enqueue(imsg->data), NULL, 0);
d220 1
a220 1
smtp_enqueue(uid_t *euid)
a222 1
	char			 buf[HOST_NAME_MAX+1], *hostname;
d247 1
a247 7
	hostname = env->sc_hostname;
	if (euid) {
		(void)snprintf(buf, sizeof(buf), "%s", hostname);
		hostname = buf;
	}

	if ((smtp_session(listener, fd[0], &listener->ss, hostname)) == -1) {
@


1.151
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.150 2015/12/13 09:52:44 gilles Exp $	*/
d192 1
a192 1
	log_debug("debug: smtp: will accept at most %zx clients", maxsessions);
@


1.150
log
@refactor a bit to move the SNI handling away from smtp_session into smtp

ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.149 2015/12/12 17:16:56 gilles Exp $	*/
d183 1
a183 1
		if (! ssl_setup((SSL_CTX **)&ssl_ctx, pki, smtp_sni_callback,
d278 1
a278 1
	if (! smtp_can_accept()) {
@


1.149
log
@allow overriding the default cipher-suite

ok jung@@, sunil@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.148 2015/12/12 12:22:25 gilles Exp $	*/
d52 1
d183 2
a184 1
		if (! ssl_setup((SSL_CTX **)&ssl_ctx, pki, env->sc_tls_ciphers))
d342 16
@


1.148
log
@add bits so local enqueuer can run filters when they are enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.147 2015/12/12 11:31:29 sunil Exp $	*/
d182 1
a182 1
		if (! ssl_setup((SSL_CTX **)&ssl_ctx, pki))
@


1.147
log
@Implement senders map.

senders table allows to restrict the addresses that an authenticated
user can use in the SMTP dialogue.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.146 2015/12/12 09:54:48 gilles Exp $	*/
d231 2
@


1.146
log
@display CA name in log debug
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.145 2015/12/11 20:14:14 gilles Exp $	*/
d63 1
@


1.145
log
@fix a logic error in smtp_can_accept() which caused smtpd to accept less
concurrent sessions than it really could.

ok millert@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.144 2015/11/30 12:49:35 gilles Exp $	*/
d166 3
a168 2
		    " pki \"%s\"", ss_to_text(&l->ss), ntohs(l->port),
		    l->flags, l->pki_name);
@


1.144
log
@mechanical rename of some IMSG constants

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.143 2015/01/20 17:37:54 deraadt Exp $	*/
d55 1
d187 2
a188 2
	log_debug("debug: smtp: will accept at most %d clients",
	    (getdtablesize() - getdtablecount())/2 - SMTP_FD_RESERVE);
a238 1
	/* XXX dont' fatal here */
d240 1
a240 1
		fatal("socketpair");
d316 3
a318 5
	size_t max;

	max = (getdtablesize() - getdtablecount()) / 2 - SMTP_FD_RESERVE;

	return (sessions < max);
@


1.143
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.142 2015/01/16 06:40:21 deraadt Exp $	*/
d65 2
a66 2
		case IMSG_SMTP_SSL_INIT:
		case IMSG_SMTP_SSL_VERIFY:
@


1.142
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.141 2014/11/05 19:38:09 gilles Exp $	*/
d218 1
a218 1
	char			 buf[SMTPD_MAXHOSTNAMELEN], *hostname;
@


1.141
log
@stop prepending the user id in local enqueuing Received line
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.140 2014/10/12 11:49:38 gilles Exp $	*/
d33 1
@


1.140
log
@local host is not "localhost", local host is env->sc_hostname
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.139 2014/07/08 14:38:17 eric Exp $	*/
d243 1
a243 1
		(void)snprintf(buf, sizeof(buf), "%d@@%s", *euid, hostname);
@


1.139
log
@remove dead code. these imsgs are handled in pony.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.138 2014/07/08 07:59:31 sobrado Exp $	*/
d225 1
a225 1
		(void)strlcpy(listener->hostname, "localhost",
d241 1
a241 1
	hostname = "localhost";
d243 1
a243 1
		(void)snprintf(buf, sizeof(buf), "%d@@localhost", *euid);
@


1.138
log
@fix typos.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.137 2014/04/29 19:13:13 reyk Exp $	*/
a57 3
	struct msg	 m;
	int		 v;

a84 26
			return;
		}
	}

	if (p->proc == PROC_PARENT) {
		switch (imsg->hdr.type) {

		case IMSG_CONF_START:
			return;

		case IMSG_CONF_END:
			smtp_setup_events();
			return;

		case IMSG_CTL_VERBOSE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			log_verbose(v);
			return;

		case IMSG_CTL_PROFILE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			profiling = v;
@


1.137
log
@Implement RSA privilege separation for OpenSMTPD, based on my previous
implementation for relayd(8).  The smtpd(8) pony processes (mta
client, smtp server) don't keep the private keys in memory but send
their private key operations as imsgs to the "lookup"/mta process.
It's worth mentioning that this prevents acidental private key leakage
as it could have been caused by "Heartbleed".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.136 2014/04/19 13:52:49 gilles Exp $	*/
d362 1
a362 1
		    "fd exaustion over, re-enabling incoming connections");
@


1.136
log
@(cast) void two strlcpy() and a snprintf() that cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.135 2014/04/09 18:55:19 eric Exp $	*/
d212 1
a212 1
	purge_config(PURGE_PKI);
@


1.135
log
@Zap the mfa process. It is not currently doing anything, and content filtering
will be done at session level anyway.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d251 1
a251 1
		strlcpy(listener->tag, "local", sizeof(listener->tag));
d254 1
a254 1
		strlcpy(listener->hostname, "localhost",
d272 1
a272 1
		snprintf(buf, sizeof(buf), "%d@@localhost", *euid);
@


1.134
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@a73 8
	if (p->proc == PROC_MFA) {
		switch (imsg->hdr.type) {
		case IMSG_MFA_SMTP_RESPONSE:
			smtp_session_imsg(p, imsg);
			return;
		}
	}

@


1.133
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@a43 3
static void smtp_imsg(struct mproc *, struct imsg *);
static void smtp_shutdown(void);
static void smtp_sig_handler(int, short, void *);
d55 1
a55 1
static void
d63 6
a68 6
		case IMSG_DNS_PTR:
		case IMSG_LKA_EXPAND_RCPT:
		case IMSG_LKA_HELO:
		case IMSG_LKA_AUTHENTICATE:
		case IMSG_LKA_SSL_INIT:
		case IMSG_LKA_SSL_VERIFY:
d84 5
a88 5
		case IMSG_QUEUE_CREATE_MESSAGE:
		case IMSG_QUEUE_MESSAGE_FILE:
		case IMSG_QUEUE_SUBMIT_ENVELOPE:
		case IMSG_QUEUE_COMMIT_ENVELOPES:
		case IMSG_QUEUE_COMMIT_MESSAGE:
d92 2
a93 2
		case IMSG_SMTP_ENQUEUE_FD:
			m_compose(p, IMSG_SMTP_ENQUEUE_FD, 0, 0,
d128 2
a129 2
		case IMSG_SMTP_ENQUEUE_FD:
			m_compose(p, IMSG_SMTP_ENQUEUE_FD, imsg->hdr.peerid, 0,
d150 2
a151 2
static void
smtp_sig_handler(int sig, short event, void *p)
d153 1
a153 8
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		smtp_shutdown();
		break;
	default:
		fatalx("smtp_sig_handler: unexpected signal");
	}
d156 2
a157 2
static void
smtp_shutdown(void)
a158 2
	log_info("info: smtp server exiting");
	_exit(0);
d161 2
a162 2
pid_t
smtp(void)
d164 1
a164 57
	pid_t		 pid;
	struct passwd	*pw;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;

	switch (pid = fork()) {
	case -1:
		fatal("smtp: cannot fork");
	case 0:
		post_fork(PROC_SMTP);
		break;
	default:
		return (pid);
	}

	smtp_setup_listeners();

	/* SSL will be purged later */
	purge_config(PURGE_TABLES|PURGE_RULES);

	if ((pw = getpwnam(SMTPD_USER)) == NULL)
		fatalx("unknown user " SMTPD_USER);

	if (chroot(PATH_CHROOT) == -1)
		fatal("smtp: chroot");
	if (chdir("/") == -1)
		fatal("smtp: chdir(\"/\")");

	config_process(PROC_SMTP);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("smtp: cannot drop privileges");

	imsg_callback = smtp_imsg;
	event_init();

	signal_set(&ev_sigint, SIGINT, smtp_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, smtp_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	config_peer(PROC_CONTROL);
	config_peer(PROC_PARENT);
	config_peer(PROC_LKA);
	config_peer(PROC_MFA);
	config_peer(PROC_QUEUE);
	config_done();

	if (event_dispatch() < 0)
		fatal("event_dispatch");
	smtp_shutdown();

	return (0);
@


1.132
log
@get rid of fdlimit()
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.131 2013/12/05 15:05:53 eric Exp $	*/
d53 1
a60 2
	struct listener	*l;
	struct ssl	*ssl;
a106 55
			if (env->sc_flags & SMTPD_CONFIGURING)
				return;
			env->sc_flags |= SMTPD_CONFIGURING;
			env->sc_listeners = calloc(1,
			    sizeof *env->sc_listeners);
			if (env->sc_listeners == NULL)
				fatal(NULL);
			env->sc_ssl_dict = calloc(1, sizeof *env->sc_ssl_dict);
			if (env->sc_ssl_dict == NULL)
				fatal(NULL);
			dict_init(env->sc_ssl_dict);
			TAILQ_INIT(env->sc_listeners);
			return;

		case IMSG_CONF_SSL:
			if (!(env->sc_flags & SMTPD_CONFIGURING))
				return;
			ssl = calloc(1, sizeof *ssl);
			if (ssl == NULL)
				fatal(NULL);
			*ssl = *(struct ssl *)imsg->data;
			ssl->ssl_cert = xstrdup((char *)imsg->data +
			    sizeof *ssl, "smtp:ssl_cert");
			ssl->ssl_key = xstrdup((char *)imsg->data +
			    sizeof *ssl + ssl->ssl_cert_len, "smtp:ssl_key");
			if (ssl->ssl_dhparams_len) {
				ssl->ssl_dhparams = xstrdup((char *)imsg->data
				    + sizeof *ssl + ssl->ssl_cert_len +
				    ssl->ssl_key_len, "smtp:ssl_dhparams");
			}
			if (ssl->ssl_ca_len) {
				ssl->ssl_ca = xstrdup((char *)imsg->data
				    + sizeof *ssl + ssl->ssl_cert_len +
				    ssl->ssl_key_len + ssl->ssl_dhparams_len,
				    "smtp:ssl_ca");
			}
			dict_set(env->sc_ssl_dict, ssl->ssl_name, ssl);
			return;

		case IMSG_CONF_LISTENER:
			if (!(env->sc_flags & SMTPD_CONFIGURING))
				return;
			l = calloc(1, sizeof *l);
			if (l == NULL)
				fatal(NULL);
			*l = *(struct listener *)imsg->data;
			l->fd = imsg->fd;
			if (l->fd < 0)
				fatalx("smtp: listener pass failed");
                        if (l->flags & F_SSL) {
				l->ssl = dict_get(env->sc_ssl_dict, l->ssl_cert_name);
                                if (l->ssl == NULL)
                                        fatalx("smtp: ssltree out of sync");
                        }
			TAILQ_INSERT_TAIL(env->sc_listeners, l, entry);
a109 2
			if (!(env->sc_flags & SMTPD_CONFIGURING))
				return;
a110 1
			env->sc_flags &= ~SMTPD_CONFIGURING;
d191 4
a194 1
	purge_config(PURGE_EVERYTHING);
d236 23
d262 4
a265 1
	struct ssl	*ssl, key;
d270 1
a270 1
		    l->flags, l->ssl_cert_name);
d279 1
d281 3
a283 9
		if (!(l->flags & F_SSL))
			continue;

		if (strlcpy(key.ssl_name, l->ssl_cert_name, sizeof(key.ssl_name))
		    >= sizeof(key.ssl_name))
			fatal("smtp_setup_events: certificate name truncated");
		if ((ssl = dict_get(env->sc_ssl_dict, l->ssl_cert_name)) == NULL)
			fatal("smtp_setup_events: certificate tree corrupted");
		if (! ssl_setup((SSL_CTX **)&l->ssl_ctx, ssl))
d285 1
d288 1
a288 1
	purge_config(PURGE_SSL);
@


1.131
log
@missing init
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a275 2

	fdlimit(1.0);
@


1.130
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d118 1
@


1.129
log
@Make the filter infrastructure move forward.
This is a work-in-progress and it's not supposed to be useable for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.128 2013/10/27 07:56:25 eric Exp $	*/
d69 1
d300 1
a300 1
		    " cert \"%s\"", ss_to_text(&l->ss), ntohs(l->port),
d365 2
@


1.128
log
@Create the control socket in the parent process to abort early if
another smtpd instance is running.  Close the inherited socket in
every forked process but control.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.127 2013/07/19 11:14:08 eric Exp $	*/
a78 1
		case IMSG_MFA_SMTP_DATA:
@


1.127
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.126 2013/07/19 07:49:08 eric Exp $	*/
d243 1
@


1.126
log
@Remove useless sc_pid from struct smtpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.125 2013/05/24 17:03:14 eric Exp $	*/
d250 2
a251 1
	pw = env->sc_pw;
d253 1
a253 1
	if (chroot(pw->pw_dir) == -1)
@


1.125
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.124 2013/03/11 17:40:11 deraadt Exp $	*/
a242 1
		env->sc_pid = getpid();
@


1.124
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.123 2013/01/26 09:37:23 gilles Exp $	*/
a23 1
#include <sys/param.h>
d356 1
a356 1
	char			 buf[MAXHOSTNAMELEN], *hostname;
d431 1
@


1.123
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.121 2012/11/12 14:58:53 eric Exp $	*/
d421 2
a422 1
		if (errno == EINTR || errno == ECONNABORTED)
@


1.122
log
@knf

ok gilles@@
@
text
@d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d39 2
d43 1
d45 1
a45 1
static void smtp_imsg(struct imsgev *, struct imsg *);
d50 2
a52 3
static void smtp_accept(int, short, void *);
static struct session *smtp_new(struct listener *);
static struct session *session_lookup(uint64_t);
d56 1
a56 1
static uint32_t	sessions;
d59 1
a59 1
smtp_imsg(struct imsgev *iev, struct imsg *imsg)
d61 4
a64 7
	struct session		 skey;
	struct submit_status	*ss;
	struct listener		*l;
	struct session		*s;
	struct auth		*auth;
	struct ssl		*ssl;
	struct dns		*dns;
d66 1
a66 1
	if (iev->proc == PROC_LKA) {
d69 5
a73 10
			dns = imsg->data;
			s = session_lookup(dns->id);
			if (s == NULL)
				fatalx("smtp: impossible quit");
			strlcpy(s->s_hostname,
			    dns->error ? "<unknown>" : dns->host,
			    sizeof s->s_hostname);
			strlcpy(s->s_msg.hostname, s->s_hostname,
			    sizeof s->s_msg.hostname);
			session_pickup(s, NULL);
d78 1
a78 1
	if (iev->proc == PROC_MFA) {
d80 3
a82 14
		case IMSG_MFA_CONNECT:
		case IMSG_MFA_HELO:
		case IMSG_MFA_MAIL:
		case IMSG_MFA_RCPT:
		case IMSG_MFA_DATALINE:
		case IMSG_MFA_QUIT:
		case IMSG_MFA_RSET:
			ss = imsg->data;
			s = session_lookup(ss->id);
			if (s == NULL)
				return;
			session_pickup(s, ss);
			return;
		case IMSG_MFA_CLOSE:
d87 1
a87 3
	if (iev->proc == PROC_QUEUE) {
		ss = imsg->data;

a89 7
			s = session_lookup(ss->id);
			if (s == NULL)
				return;
			s->s_msg.id = ((uint64_t)ss->u.msgid) << 32;
			session_pickup(s, ss);
			return;

d91 1
a91 26
			s = session_lookup(ss->id);
			if (s == NULL) {
				close(imsg->fd);
				return;
			}
			s->datafp = fdopen(imsg->fd, "w");
			if (s->datafp == NULL) {
				/* queue may have experienced tempfail. */
				if (ss->code != 421)
					fatalx("smtp: fdopen");
				close(imsg->fd);
			}
			session_pickup(s, ss);
			return;

		case IMSG_QUEUE_TEMPFAIL:
			skey.s_id = ss->id;
			/* do not use lookup since this is not a expected imsg
			 * -- eric@@
			 */
			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &skey);
			if (s == NULL)
				fatalx("smtp: session is gone");
			s->s_dstatus |= DS_TEMPFAILURE;
			return;

a92 6
			s = session_lookup(ss->id);
			if (s == NULL)
				return;
			session_pickup(s, ss);
			return;

d94 1
a94 4
			s = session_lookup(ss->id);
			if (s == NULL)
				return;
			session_pickup(s, ss);
d97 2
a98 2
		case IMSG_SMTP_ENQUEUE:
			imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, 0, 0,
d105 1
a105 1
	if (iev->proc == PROC_PARENT) {
d114 4
a117 2
			env->sc_ssl = calloc(1, sizeof *env->sc_ssl);
			if (env->sc_listeners == NULL || env->sc_ssl == NULL)
d144 1
a144 2

			SPLAY_INSERT(ssltree, env->sc_ssl, ssl);
d157 5
a161 9
			if (l->flags & F_SSL) {
				struct ssl key;

				strlcpy(key.ssl_name, l->ssl_cert_name,
				    sizeof key.ssl_name);
				l->ssl = SPLAY_FIND(ssltree, env->sc_ssl, &key);
				if (l->ssl == NULL)
					fatalx("smtp: ssltree out of sync");
			}
d172 5
a176 13
		case IMSG_PARENT_AUTHENTICATE:
			auth = imsg->data;
			s = session_lookup(auth->id);
			if (s == NULL)
				return;
			if (auth->success) {
				s->s_flags |= F_AUTHENTICATED;
				s->s_msg.flags |= DF_AUTHENTICATED;
			} else {
				s->s_flags &= ~F_AUTHENTICATED;
				s->s_msg.flags &= ~DF_AUTHENTICATED;
			}
			session_pickup(s, NULL);
d179 5
a183 2
		case IMSG_CTL_VERBOSE:
			log_verbose(*(int *)imsg->data);
d188 1
a188 1
	if (iev->proc == PROC_CONTROL) {
d190 3
a192 4
		case IMSG_SMTP_ENQUEUE:
			imsg_compose_event(iev, IMSG_SMTP_ENQUEUE,
			    imsg->hdr.peerid, 0, smtp_enqueue(imsg->data),
			    NULL, 0);
d195 1
a195 1
		case IMSG_SMTP_PAUSE:
d201 1
a201 1
		case IMSG_SMTP_RESUME:
a236 1

a239 8
	struct peer peers[] = {
		{ PROC_PARENT,	imsg_dispatch },
		{ PROC_MFA,	imsg_dispatch },
		{ PROC_QUEUE,	imsg_dispatch },
		{ PROC_LKA,	imsg_dispatch },
		{ PROC_CONTROL,	imsg_dispatch }
	};

d244 1
d259 1
a259 2
	smtpd_process = PROC_SMTP;
	setproctitle("%s", env->sc_title[smtpd_process]);
d278 6
a283 2
	config_pipes(peers, nitems(peers));
	config_peers(peers, nitems(peers));
d296 1
d311 10
a320 1
		ssl_setup(l);
d323 2
d341 1
a341 1
void
d356 9
a364 8
	static struct listener		 local, *l = NULL;
	struct session			*s;
	int				 fd[2];

	if (l == NULL) {
		l = &local;
		strlcpy(l->tag, "local", sizeof(l->tag));
		l->ss.ss_family = AF_LOCAL;
d375 1
a375 3
	if ((s = smtp_new(l)) == NULL)
		return (-1);

d379 5
a383 2
	s->s_io.sock = fd[0];
	s->s_ss = l->ss;
d385 4
a388 6
	if (euid)
		bsnprintf(s->s_hostname, sizeof(s->s_hostname), "%d@@localhost",
		    *euid);
	else {
		strlcpy(s->s_hostname, "localhost", sizeof(s->s_hostname));
		s->s_msg.flags |= DF_BOUNCE;
d391 3
a393 4
	strlcpy(s->s_msg.hostname, s->s_hostname,
	    sizeof(s->s_msg.hostname));

	session_pickup(s, NULL);
d401 2
a402 2
	struct listener		*l = p;
	struct session		*s;
d404 1
d406 6
a411 3
	if ((s = smtp_new(l)) == NULL) {
		log_warnx("warn: smtp: "
		    "client limit hit, disabling incoming connections");
d415 2
a416 3
	len = sizeof(s->s_ss);
	if ((s->s_io.sock = accept(fd, (struct sockaddr *)&s->s_ss, &len))
	    == -1) {
d418 1
a418 2
			log_warnx("warn: smtp: "
			    "fd exhaustion, disabling incoming connections");
d426 14
a439 3
	io_set_timeout(&s->s_io, SMTPD_SESSION_TIMEOUT * 1000);
	io_set_write(&s->s_io);
	dns_query_ptr(&s->s_ss, s->s_id);
d448 2
a449 3

static struct session *
smtp_new(struct listener *l)
d451 1
a451 6
	struct session	*s;

	log_debug("debug: smtp: new client on listener: %p", l);

	if (env->sc_flags & SMTPD_SMTP_PAUSED)
		fatalx("smtp_new: unexpected client");
d453 1
a453 2
	if (! smtp_can_accept())
		return (NULL);
d455 1
a455 23
	s = xcalloc(1, sizeof(*s), "smtp_new");
	s->s_id = generate_uid();
	s->s_l = l;
	strlcpy(s->s_msg.tag, l->tag, sizeof(s->s_msg.tag));

	iobuf_xinit(&s->s_iobuf, MAX_LINE_SIZE, MAX_LINE_SIZE, "smtp_new");
	io_init(&s->s_io, -1, s, session_io, &s->s_iobuf);
	s->s_state = S_CONNECTED;

	sessions++;

	SPLAY_INSERT(sessiontree, &env->sc_sessions, s);

	stat_increment("smtp.session", 1);

	if (s->s_l->ss.ss_family == AF_LOCAL)
		stat_increment("smtp.session.local", 1);
	if (s->s_l->ss.ss_family == AF_INET)
		stat_increment("smtp.session.inet4", 1);
	if (s->s_l->ss.ss_family == AF_INET6)
		stat_increment("smtp.session.inet6", 1);

	return (s);
d459 1
a459 1
smtp_destroy(struct session *session)
d462 1
d464 1
a464 1
	if (! smtp_can_accept())
a473 34

static int
smtp_can_accept(void)
{
	uint32_t max;

	max = (getdtablesize() - getdtablecount())/2 - SMTP_FD_RESERVE;
	if (sessions < max)
		return 1;
	return 0;
}

/*
 * Helper function for handling IMSG replies.
 */
static struct session *
session_lookup(uint64_t id)
{
	struct session	 key;
	struct session	*s;

	key.s_id = id;
	s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
	if (s == NULL)
		fatalx("session_lookup: session is gone");

	if (s->s_flags & F_ZOMBIE) {
		session_destroy(s, "(finalizing)");
		s = NULL;
	}

	return (s);
}

@


1.121
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.120 2012/10/07 15:46:38 chl Exp $	*/
d134 3
a136 1
			/* do not use lookup since this is not a expected imsg -- eric@@ */
d172 2
a173 1
			env->sc_listeners = calloc(1, sizeof *env->sc_listeners);
d189 2
a190 2
			ssl->ssl_key = xstrdup((char *)imsg->data + sizeof *ssl +
			    ssl->ssl_cert_len, "smtp:ssl_key");
d469 2
a470 1
		log_warnx("warn: smtp: client limit hit, disabling incoming connections");
d475 2
a476 1
	if ((s->s_io.sock = accept(fd, (struct sockaddr *)&s->s_ss, &len)) == -1) {
d478 2
a479 1
			log_warnx("warn: smtp: fd exhaustion, disabling incoming connections");
d486 1
a486 1
	
d546 2
a547 1
		log_warnx("warn: smtp: fd exaustion over, re-enabling incoming connections");
@


1.120
log
@convert iobuf_queue()'s to iobuf_fqueue(). (idea from gilles@@)
introduce iobuf_xinit() and iobuf_xfqueue(). (idea from eric@@)

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.119 2012/10/03 16:43:19 chl Exp $	*/
d262 1
a262 1
			log_debug("smtp: pausing listening sockets");
d268 1
a268 1
			log_debug("smtp: resuming listening sockets");
d294 1
a294 1
	log_info("smtp server exiting");
d369 1
a369 1
		log_debug("smtp: listen on %s port %d flags 0x%01x"
d384 1
a384 1
	log_debug("smtp: will accept at most %d clients",
d466 1
a466 1
		log_warnx("smtp: client limit hit, disabling incoming connections");
d473 1
a473 1
			log_warnx("smtp: fd exhaustion, disabling incoming connections");
d498 1
a498 1
	log_debug("smtp: new client on listener: %p", l);
d540 1
a540 1
		log_warnx("smtp: fd exaustion over, re-enabling incoming connections");
@


1.119
log
@don't try to cope with iobuf_init() failure, make it fatal() instead.

from eric@@ input

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.118 2012/10/02 12:37:38 chl Exp $	*/
d511 1
a511 2
	if (iobuf_init(&s->s_iobuf, MAX_LINE_SIZE, MAX_LINE_SIZE) == -1)
		fatal("iobuf_init");
@


1.118
log
@check iobuf_init() return value.

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.117 2012/09/29 22:16:46 chl Exp $	*/
d511 2
a512 4
	if (iobuf_init(&s->s_iobuf, MAX_LINE_SIZE, MAX_LINE_SIZE) == -1) {
		free(s);
		return (NULL);
	}
@


1.117
log
@use xstrdup() helper

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.116 2012/09/19 18:20:36 eric Exp $	*/
a504 1
	sessions++;
d510 10
a529 4

	iobuf_init(&s->s_iobuf, MAX_LINE_SIZE, MAX_LINE_SIZE);
	io_init(&s->s_io, -1, s, session_io, &s->s_iobuf);
	s->s_state = S_CONNECTED;
@


1.116
log
@Remove DF_ENQUEUE flag. It is mostly unused and logically broken.
Ignore it in existing envelopes until it gets completely dropped.
Change "smtpctl show queue" to display the address family of the
envelope source instead of the ENQUEUE flag.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.115 2012/09/17 18:36:14 eric Exp $	*/
d184 4
a187 8
			ssl->ssl_cert = strdup((char *)imsg->data +
			    sizeof *ssl);
			if (ssl->ssl_cert == NULL)
				fatal(NULL);
			ssl->ssl_key = strdup((char *)imsg->data + sizeof *ssl +
			    ssl->ssl_cert_len);
			if (ssl->ssl_key == NULL)
				fatal(NULL);
d189 1
a189 1
				ssl->ssl_dhparams = strdup((char *)imsg->data
d191 1
a191 3
				    ssl->ssl_key_len);
				if (ssl->ssl_dhparams == NULL)
					fatal(NULL);
d194 1
a194 1
				ssl->ssl_ca = strdup((char *)imsg->data
d196 2
a197 3
				    ssl->ssl_key_len + ssl->ssl_dhparams_len);
				if (ssl->ssl_ca == NULL)
					fatal(NULL);
@


1.115
log
@increment the session counter when a session is created.
fix a bug where local sessions were not accounted for.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.114 2012/09/17 08:32:00 eric Exp $	*/
a447 1
	s->s_msg.flags |= DF_ENQUEUED;
@


1.114
log
@fix pasto

prompted by gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.113 2012/09/16 19:16:23 gilles Exp $	*/
a487 1
	sessions++;
d513 1
@


1.113
log
@we need to ensure we have at least two descriptors per-client accepted, or
we will hit an imsg_read() fatal (EAGAIN) when a client sends DATA, and we
don't have a descriptor for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.112 2012/09/16 16:43:29 chl Exp $	*/
a495 2
	if (s == NULL)

@


1.112
log
@Factorize log_imsg() in imsg_dispatch() instead of in each imsg_callback()'s
and put it out of profiling, so it's not accounted.

While there, for PROC_PARENT:
- set smtpd_process for PROC_PARENT
- use setproctitle() like other processes

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.111 2012/09/15 15:12:11 eric Exp $	*/
d51 1
d54 1
d392 1
a392 1
	    getdtablesize() - getdtablecount() - SMTP_FD_RESERVE + 1);
d488 2
a489 1

d496 2
d514 1
a514 1
	if (getdtablesize() - getdtablecount() < SMTP_FD_RESERVE)
d542 3
a544 1
	if (getdtablesize() - getdtablecount() < SMTP_FD_RESERVE)
d554 10
d586 1
@


1.111
log
@When enqueueing from the local socket, the input address is faked as "::1".
This is confusing and even broken, as systems running with ipv6 disabled on
lo0 will not be able to enqueue mails using the local socket.

So instead, use AF_LOCAL and print it as "local" in envelopes/maps.  Add it
to the "localhost" and "all" maps accordingly, and fix the ruleset matching.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.110 2012/09/14 16:38:53 eric Exp $	*/
a63 2

	log_imsg(PROC_SMTP, iev->proc, imsg);
@


1.110
log
@Check limits before allocating the session.
While there, move smtp_resume() in the if block; it makes more sense.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.109 2012/08/29 16:26:17 gilles Exp $	*/
d422 1
a422 2
	static struct listener		 local, *l;
	static struct sockaddr_storage	 sa;
a426 2
		struct addrinfo hints, *res;

d429 1
a429 9

		bzero(&hints, sizeof(hints));
		hints.ai_family = PF_UNSPEC;
		hints.ai_flags = AI_NUMERICHOST;

		if (getaddrinfo("::1", NULL, &hints, &res))
			fatal("getaddrinfo");
		memcpy(&sa, res->ai_addr, res->ai_addrlen);
		freeaddrinfo(res);
d447 1
a447 1
	s->s_ss = sa;
d522 2
@


1.109
log
@Introduce the crypto_backend API and provide support for... encrypted queue
using the new API. By default, OpenSMTPD does not provide queue encryption,
but it can be enabled with "queue encryption [args]" and will transparently
encrypt/decrypt envelopes/messages as they hit the queue.

By default, it will use Blowfish in CBC mode with a different random IV for
each envelope and message. User provided key is expanded using sha256 but a
different cipher and digest may be specified in smtpd.conf

Queue encryption is compatible with compression and if both options are set
it will do them in correct order and transparently.

tested by chl@@, a few users and myself
ok chl@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.108 2012/08/25 22:03:26 gilles Exp $	*/
d522 4
a525 2
	if ((s = calloc(1, sizeof(*s))) == NULL)
		fatal(NULL);
a531 4
	
	if (getdtablesize() - getdtablecount() < SMTP_FD_RESERVE) {
		return NULL;
	}
d554 1
a555 1
	smtp_resume();
@


1.108
log
@- add myself to the copyright in control.c, i've done quite a few changes
there in the last few years ;-)
- get rid of availdesc(): getdtablecount() is so much more reliable
- get rid of env->sc_maxconn, we can be much smarter with getdtablecount()
	and getdtablesize()
- disable accept when we hit the control process fd reserve
- disable accept when we fail
- enable accept when we're back below the limit

this is not the full fd exhaustion diff, i'll merge changes from relayd
tomorrow, this was only required to get rid of the env->sc_maxconn and
availdesc() mess

"reads alright" eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.107 2012/08/25 21:33:33 gilles Exp $	*/
a330 1
	ssl_init();
@


1.107
log
@- stop accepting clients if we hit our fd reserve limit (or if we fail)
- resume if we go below the fd reserve

with feedback and ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.106 2012/08/25 10:23:12 gilles Exp $	*/
d359 1
a359 3
	/* Initial limit for use by IMSG_SMTP_ENQUEUE, will be tuned later once
	 * the listening sockets arrive. */
	env->sc_maxconn = availdesc() / 2;
a374 1
	int avail = availdesc();
a389 1
		avail--;
@


1.106
log
@- introduce struct stat_value
- statistics can now have a type (counter, timestamp, timeval, timespec and
  possibly others in the future)
- stat_increment() / stat_decrement() now take an increment/decrement value
  and are at the moment only of type counter
- stat_set() now takes a stat_value
- provide helpers to convert raw values to stat_value

ok eric@@, ok chl@@

while at it fix a rq_queue_dump() call using a bogus timestamp in scheduler
ramqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.105 2012/08/19 14:16:58 chl Exp $	*/
d52 1
a52 1
static size_t sessions;
a235 2
			if (env->sc_flags & SMTPD_SMTP_PAUSED)
				smtp_pause();
d269 1
d271 1
d275 2
d388 4
a391 1
		event_add(&l->ev, NULL);
d396 2
a397 5
	/* guarantee 2 fds to each accepted client */
	if ((env->sc_maxconn = avail / 2) < 1)
		fatalx("smtp_setup_events: fd starvation");

	log_debug("smtp: will accept at most %d clients", env->sc_maxconn);
d405 2
a406 2
	log_debug("smtp: pausing listening sockets");
	env->sc_flags |= SMTPD_SMTP_PAUSED;
d417 2
a418 2
	log_debug("smtp: resuming listening sockets");
	env->sc_flags &= ~SMTPD_SMTP_PAUSED;
d489 4
a492 2
	if ((s = smtp_new(l)) == NULL)
		return;
d496 4
d508 6
d535 3
a537 4

	if (++sessions >= env->sc_maxconn) {
		log_warnx("client limit hit, disabling incoming connections");
		smtp_pause();
d555 2
a556 3
	size_t	resume;

	resume = env->sc_maxconn * 95 / 100;
d558 3
a560 3
	if (--sessions == resume) {
		log_warnx("re-enabling incoming connections");
		smtp_resume();
d562 1
@


1.105
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.104 2012/08/18 18:18:23 gilles Exp $	*/
d520 1
a520 1
	stat_increment("smtp.session");
d528 1
a528 1
		stat_increment("smtp.session.inet4");
d530 1
a530 1
		stat_increment("smtp.session.inet6");
@


1.104
log
@- introduce stat_backend, an API for pluggable statistic backends
  > statistics are no longer static structures in shared memory
  > statistics are only set, smtpd never uses them in its logic
  > each statistic is a key/value where key can be any (dynamic) string
- convert all uses of the former API to use the new one
- implement stat_ramstat that keeps non-persistent stats in ram structure

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.103 2012/08/09 09:48:02 eric Exp $	*/
d50 1
a50 1
static struct session *session_lookup(u_int64_t);
d112 1
a112 1
			s->s_msg.id = ((u_int64_t)ss->u.msgid) << 32;
d557 1
a557 1
session_lookup(u_int64_t id)
@


1.103
log
@Improve the message flows to completely isolate operations on the
queue backend within the queue process.

The scheduler sends envelope ids to the queue process which loads
the envelope and forward the request to the agent responsible for
the delivery.  The result is sent by the agent to the queue which
updates the storage before notifying the scheduler.

Bounces are created and enqueued (from the client side) by the
queue process, rather than the scheduler.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.102 2012/06/01 14:55:09 eric Exp $	*/
d52 1
d520 3
a522 1
	if (stat_increment(STATS_SMTP_SESSION) >= env->sc_maxconn) {
d528 1
a528 1
		stat_increment(STATS_SMTP_SESSION_INET4);
d530 1
a530 1
		stat_increment(STATS_SMTP_SESSION_INET6);
d538 14
@


1.102
log
@allow to pause some subsystems at startup.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.101 2012/01/31 21:05:26 gilles Exp $	*/
d157 1
a157 1
			    sizeof(struct envelope));
@


1.101
log
@fix an issue observed this week-end while flooding ajacoutot@@ :

we keep track of available fd's to prevent scheduling of messages if we
know that we are going to fail. however, since the envelope is not
removed from the scheduler, it will be rescheduled right away leading to
a busy loop in the scheduler. we know flag the mda/mta processes as BUSY
and do not schedule envelopes that target a BUSY process.

also, fix a potential bug that could lead to a use after free when doing
a batch/message/host traversal of schedulable envelopes.

while at it fix misuse of env->sc_opts as env->sc_flags, was not really
causing any issue as the misuse was constant ...
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.100 2012/01/29 11:37:32 eric Exp $	*/
d235 2
@


1.100
log
@Rewrite io code in smtp and mta using the iobuf/ioev interface to have
a better separation between io and protocol logic.  As a side-effect,
it fixes a couple of long-standing issues in the io path, and
hopefully add fresh ones instead.  Kill client.c in the process.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.99 2012/01/18 13:41:54 chl Exp $	*/
d401 1
a401 1
	env->sc_opts |= SMTPD_SMTP_PAUSED;
d413 1
a413 1
	env->sc_opts &= ~SMTPD_SMTP_PAUSED;
d448 1
a448 1
	if (env->sc_opts & SMTPD_SMTP_PAUSED)
d507 1
a507 1
	if (env->sc_opts & SMTPD_SMTP_PAUSED)
@


1.99
log
@Add new filters callbacks for:
- network events (CONNECT/CLOSE)
- commands (QUIT/RSET)

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.98 2012/01/13 14:27:55 eric Exp $	*/
d78 1
a78 1
			session_init(s->s_l, s);
d133 1
d137 1
a137 5
			if (s->s_flags & F_WRITEONLY)
				/* session is write-only, must not destroy it. */
				s->s_dstatus |= DS_TEMPFAILURE;
			else
				fatalx("smtp: corrupt session");
d457 1
a457 1
	s->s_fd = fd[0];
d472 1
a472 1
	session_init(l, s);
d488 1
a488 1
	if ((s->s_fd = accept(fd, (struct sockaddr *)&s->s_ss, &len)) == -1) {
d494 2
a495 2
	
	s->s_flags |= F_WRITEONLY;
d527 4
d548 2
a549 6
	if (!(s->s_flags & F_WRITEONLY))
		fatalx("session_lookup: corrupt session");
	s->s_flags &= ~F_WRITEONLY;

	if (s->s_flags & F_QUIT) {
		session_destroy(s);
@


1.98
log
@remove the status field from struct envelope, move it to the smtp
session, and cleanup the DS_* flags.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.97 2012/01/12 18:06:18 eric Exp $	*/
d85 1
d90 2
d97 2
@


1.97
log
@Remove dead code for config reloading for now. It is not functionnal
and confusing.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.96 2011/12/13 23:55:00 gilles Exp $	*/
d133 1
a133 1
				s->s_msg.status |= DS_TEMPFAILURE;
@


1.96
log
@*finally* make use of certificate authority file if available !

bits from relayd, ok chl@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.95 2011/12/12 17:17:55 eric Exp $	*/
a45 1
static void smtp_disable_events(void);
a161 15
		case IMSG_CONF_RELOAD:
			/*
			 * Reloading may invalidate various pointers our
			 * sessions rely upon, we better tell clients we
			 * want them to retry.
			 */
			SPLAY_FOREACH(s, sessiontree, &env->sc_sessions) {
				s->s_l = NULL;
				s->s_msg.status |= DS_TEMPFAILURE;
			}
			if (env->sc_listeners)
				smtp_disable_events();
			imsg_compose_event(iev, IMSG_PARENT_SEND_CONFIG, 0, 0, -1,
			    NULL, 0);
			return;
a390 17
}

static void
smtp_disable_events(void)
{
	struct listener	*l;

	log_debug("smtp: closing listening sockets");
	while ((l = TAILQ_FIRST(env->sc_listeners)) != NULL) {
		TAILQ_REMOVE(env->sc_listeners, l, entry);
		event_del(&l->ev);
		close(l->fd);
		free(l);
	}
	free(env->sc_listeners);
	env->sc_listeners = NULL;
	env->sc_maxconn = 0;
@


1.95
log
@display proc name rather than function name in debug message

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.94 2011/11/14 19:23:41 chl Exp $	*/
d212 8
@


1.94
log
@when receiving an unexpected imsg, print its name.

with help and ideas from eric@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.93 2011/10/23 09:30:07 gilles Exp $	*/
d381 1
a381 1
		log_debug("smtp_setup_events: listen on %s port %d flags 0x%01x"
d406 1
a406 1
	log_debug("smtp_disable_events: closing listening sockets");
d423 1
a423 1
	log_debug("smtp_pause: pausing listening sockets");
d435 1
a435 1
	log_debug("smtp_resume: resuming listening sockets");
d528 1
a528 1
	log_debug("smtp_new: incoming client on listener: %p", l);
@


1.93
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.92 2011/10/09 18:39:54 eric Exp $	*/
d27 1
d283 1
a283 1
	fatalx("smtp_imsg: unexpected imsg");
@


1.92
log
@show messages sent between processes in debug mode

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.91 2011/09/01 20:17:47 gilles Exp $	*/
d76 2
a77 2
			strlcpy(s->s_msg.delivery.hostname, s->s_hostname,
			    sizeof s->s_msg.delivery.hostname);
d106 1
a106 1
			s->s_msg.delivery.id = (u_int64_t)ss->u.msgid << 32;
d133 1
a133 1
				s->s_msg.delivery.status |= DS_TEMPFAILURE;
d170 1
a170 1
				s->s_msg.delivery.status |= DS_TEMPFAILURE;
d250 1
a250 1
				s->s_msg.delivery.flags |= DF_AUTHENTICATED;
d253 1
a253 1
				s->s_msg.delivery.flags &= ~DF_AUTHENTICATED;
d481 1
a481 1
	s->s_msg.delivery.flags |= DF_ENQUEUED;
d488 1
a488 1
		s->s_msg.delivery.flags |= DF_BOUNCE;
d491 2
a492 2
	strlcpy(s->s_msg.delivery.hostname, s->s_hostname,
	    sizeof(s->s_msg.delivery.hostname));
@


1.91
log
@move a log_debug() call to a less annoying spot so that it does not get
called for each single line of DATA exchanged between smtp and mfa
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.90 2011/09/01 19:56:49 eric Exp $	*/
d64 2
a87 1
			log_debug("smtp: got imsg_mfa_helo/mail/rcpt");
a102 1
			log_debug("smtp: imsg_queue_create_message returned");
a110 1
			log_debug("smtp: imsg_queue_message_file returned");
a126 1
			log_debug("smtp: got imsg_queue_tempfail");
a138 1
			log_debug("smtp: got imsg_queue_commit_envelopes");
a145 1
			log_debug("smtp: got imsg_queue_commit_message");
@


1.90
log
@Introduce a small set of functions to manage stat counters in a
simpler and hopefully saner way.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.89 2011/08/31 18:56:30 gilles Exp $	*/
d86 1
a87 1
			log_debug("smtp: got imsg_mfa_helo/mail/rcpt/quit");
@


1.89
log
@add support for per-line DATA callbacks, this allows filters to take their
decisions *while* the message is being received by the client.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.88 2011/08/29 18:49:29 chl Exp $	*/
a535 6
	if (env->stats->smtp.sessions_active >= env->sc_maxconn) {
		log_warnx("client limit hit, disabling incoming connections");
		smtp_pause();
		return (NULL);
	}
	
d543 4
a546 2
	env->stats->smtp.sessions++;
	env->stats->smtp.sessions_active++;
d549 1
a549 1
		env->stats->smtp.sessions_inet4++;
d551 1
a551 5
		env->stats->smtp.sessions_inet6++;

	SET_IF_GREATER(env->stats->smtp.sessions_active,
		env->stats->smtp.sessions_maxactive);

@


1.88
log
@add missing header needed by signal()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.87 2011/08/27 22:32:41 gilles Exp $	*/
d86 1
@


1.87
log
@initial support for a session-time filtering API

currently only HELO/EHLO, MAIL, RCPT are supported, however ... I have
voluntarily disabled filters at smtpd.conf level so people don't play with
it until the API has stabilized a bit

discussed with several people in private, no one opposed the feature
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.86 2011/05/16 21:05:52 gilles Exp $	*/
d32 1
@


1.86
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.85 2011/05/01 12:57:11 eric Exp $	*/
d82 2
d85 1
a85 2
		case IMSG_MFA_MAIL:
			log_debug("smtp: got imsg_mfa_mail/rcpt");
@


1.85
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.84 2011/04/17 13:36:07 gilles Exp $	*/
d73 2
a74 2
			strlcpy(s->s_msg.session_hostname, s->s_hostname,
			    sizeof s->s_msg.session_hostname);
d103 1
a103 1
			s->s_msg.evpid = (u_int64_t)ss->u.msgid << 32;
d132 1
a132 1
				s->s_msg.status |= S_MESSAGE_TEMPFAILURE;
d171 1
a171 1
				s->s_msg.status |= S_MESSAGE_TEMPFAILURE;
d251 1
a251 1
				s->s_msg.flags |= F_MESSAGE_AUTHENTICATED;
d254 1
a254 1
				s->s_msg.flags &= ~F_MESSAGE_AUTHENTICATED;
d482 1
a482 1
	s->s_msg.flags |= F_MESSAGE_ENQUEUED;
d489 1
a489 1
		s->s_msg.flags |= F_MESSAGE_BOUNCE;
d492 2
a493 2
	strlcpy(s->s_msg.session_hostname, s->s_hostname,
	    sizeof(s->s_msg.session_hostname));
@


1.84
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.83 2011/04/17 11:39:23 gilles Exp $	*/
d40 1
a40 1
static void smtp_imsg(struct smtpd *, struct imsgev *, struct imsg *);
d43 4
a46 4
static void smtp_setup_events(struct smtpd *);
static void smtp_disable_events(struct smtpd *);
static void smtp_pause(struct smtpd *);
static int smtp_enqueue(struct smtpd *, uid_t *);
d49 1
a49 1
static struct session *session_lookup(struct smtpd *, u_int64_t);
d53 1
a53 1
smtp_imsg(struct smtpd *env, struct imsgev *iev, struct imsg *imsg)
d67 1
a67 1
			s = session_lookup(env, dns->id);
d86 1
a86 1
			s = session_lookup(env, ss->id);
d100 1
a100 1
			s = session_lookup(env, ss->id);
d109 1
a109 1
			s = session_lookup(env, ss->id);
d139 1
a139 1
			s = session_lookup(env, ss->id);
d147 1
a147 1
			s = session_lookup(env, ss->id);
d155 1
a155 1
			    smtp_enqueue(env, NULL), imsg->data,
d174 1
a174 1
				smtp_disable_events(env);
d240 1
a240 1
			smtp_setup_events(env);
d246 1
a246 1
			s = session_lookup(env, auth->id);
d269 1
a269 1
			    imsg->hdr.peerid, 0, smtp_enqueue(env, imsg->data),
d274 1
a274 1
			smtp_pause(env);
d278 1
a278 1
			smtp_resume(env);
d307 1
a307 1
smtp(struct smtpd *env)
d333 1
a333 1
	purge_config(env, PURGE_EVERYTHING);
d353 2
a354 2
	signal_set(&ev_sigint, SIGINT, smtp_sig_handler, env);
	signal_set(&ev_sigterm, SIGTERM, smtp_sig_handler, env);
d364 2
a365 2
	config_pipes(env, peers, nitems(peers));
	config_peers(env, peers, nitems(peers));
d375 1
a375 1
smtp_setup_events(struct smtpd *env)
a387 1
		l->env = env;
d390 1
a390 1
		ssl_setup(env, l);
d402 1
a402 1
smtp_disable_events(struct smtpd *env)
d419 1
a419 1
smtp_pause(struct smtpd *env)
d431 1
a431 1
smtp_resume(struct smtpd *env)
d443 1
a443 1
smtp_enqueue(struct smtpd *env, uid_t *euid)
a464 1
	l->env = env;
d519 1
a519 1
	dns_query_ptr(l->env, &s->s_ss, s->s_id);
a525 1
	struct smtpd	*env = l->env;
d535 1
a535 1
		smtp_pause(env);
a541 1
	s->s_env = env;
d565 1
a565 1
session_lookup(struct smtpd *env, u_int64_t id)
@


1.83
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.82 2011/04/15 17:01:05 gilles Exp $	*/
d40 10
a49 10
void		smtp_imsg(struct smtpd *, struct imsgev *, struct imsg *);
__dead void	smtp_shutdown(void);
void		smtp_sig_handler(int, short, void *);
void		smtp_setup_events(struct smtpd *);
void		smtp_disable_events(struct smtpd *);
void		smtp_pause(struct smtpd *);
int		smtp_enqueue(struct smtpd *, uid_t *);
void		smtp_accept(int, short, void *);
struct session *smtp_new(struct listener *);
struct session *session_lookup(struct smtpd *, u_int64_t);
d51 2
a52 1
void
d286 1
a286 1
void
d299 1
a299 1
void
d374 1
a374 1
void
d402 1
a402 1
void
d419 1
a419 1
void
d443 1
a443 1
int
d502 1
a502 1
void
d525 1
a525 1
struct session *
d568 1
a568 1
struct session *
@


1.82
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.81 2011/03/15 19:24:55 gilles Exp $	*/
d155 1
a155 1
			    sizeof(struct message));
@


1.81
log
@let smtpd use user-provided Diffie-Hellman parameters for ephemeral key
exchange. if no DH parameters are found, fallback to builtin parameters
as was done until now.

since we now accept user-provided DH parameters, make smtpd more strict
and fatal() if the parameters are bogus.

bump the key size of the DH parameters from 512bits to 1024bits, it might
be bumped further after some more research.

thanks to mikeb@@ for his suggestions

diff ok mikeb@@ , man ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.80 2011/03/09 20:59:22 gilles Exp $	*/
d102 1
a102 2
			strlcpy(s->s_msg.message_id, ss->u.msgid,
			    sizeof s->s_msg.message_id);
@


1.80
log
@smtpctl show stats displays inet4/inet6 repartition for incoming sessions
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.79 2010/11/28 14:35:58 gilles Exp $	*/
d205 7
@


1.79
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.78 2010/11/28 13:56:43 gilles Exp $	*/
d512 1
d545 6
@


1.78
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.77 2010/11/24 23:27:04 todd Exp $	*/
a26 4
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
a31 1
#include <signal.h>
a34 1
#include <time.h>
@


1.77
log
@add *maxactive stats
"ok and no need to keep them for yourself" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.76 2010/10/09 22:05:35 gilles Exp $	*/
d33 1
d44 1
@


1.76
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.71 2010/05/19 20:57:10 gilles Exp $	*/
d548 3
@


1.75
log
@check event_dispatch() return value

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.74 2010/06/01 23:06:23 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009-2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
a42 1
#include "queue_backend.h"
d50 1
a50 1
int		smtp_enqueue(struct smtpd *, uid_t);
d53 1
a53 3
struct session *session_lookup(struct smtpd *, u_int32_t);

u_int32_t smtp_id;
d58 2
a64 1
	int			 status, fd;
d85 1
d87 3
a89 2
		case IMSG_MFA_RCPT:
			s = session_lookup(env, imsg->hdr.peerid);
d92 1
a92 3
			memcpy(&status, imsg->data, sizeof status);
			s->s_msg.status |= status;
			session_pickup(s);
d98 2
d101 3
a103 2
		case IMSG_QUEUE_CREATE:
			s = session_lookup(env, imsg->hdr.peerid);
d106 3
a108 6
			memcpy(&s->content_id, imsg->data, sizeof s->content_id);
			memcpy(&s->queue_id, (u_int64_t *)imsg->data + 1,
			    sizeof s->queue_id);
			if (s->content_id == INVALID_ID)
				s->s_msg.status |= S_MESSAGE_TEMPFAILURE;
			session_pickup(s);
d111 3
a113 2
		case IMSG_QUEUE_OPEN:
			s = session_lookup(env, imsg->hdr.peerid);
d118 8
a125 4
			s->datafp = fdopen(imsg->fd, "a");
			if (s->datafp == NULL)
				fatal("smtp: fdopen");
			session_pickup(s);
d128 24
a151 2
		case IMSG_QUEUE_CLOSE:
			s = session_lookup(env, imsg->hdr.peerid);
d154 1
a154 3
			memcpy(&status, imsg->data, sizeof status);
			s->s_msg.status |= status;
			session_pickup(s);
d158 3
a160 2
			fd = smtp_enqueue(env, getuid());
			imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, imsg->hdr.peerid, 0, fd, NULL, 0);
d253 1
a253 1
			session_pickup(s);
a264 1
			fd = smtp_enqueue(env, *(uid_t *)imsg->data);
d266 2
a267 1
			    imsg->hdr.peerid, 0, fd, NULL, 0);
d441 1
a441 1
smtp_enqueue(struct smtpd *env, uid_t uid)
d481 9
a490 1
	bsnprintf(s->s_hostname, sizeof(s->s_hostname), "%d@@localhost", uid);
d520 1
d540 1
a540 1
	s->s_id = smtp_id++;
d556 1
a556 1
session_lookup(struct smtpd *env, u_int32_t id)
@


1.74
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.72 2010/05/31 23:38:56 jacekm Exp $	*/
d340 2
a341 1
	event_dispatch();
@


1.73
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.71 2010/05/19 20:57:10 gilles Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d27 1
d43 1
d51 1
a51 1
int		smtp_enqueue(struct smtpd *, uid_t *);
d54 3
a56 1
struct session *session_lookup(struct smtpd *, u_int64_t);
a60 2
	struct session		 skey;
	struct submit_status	*ss;
d66 1
d87 1
d89 1
a89 4
		case IMSG_MFA_MAIL:
			log_debug("smtp: got imsg_mfa_mail/rcpt");
			ss = imsg->data;
			s = session_lookup(env, ss->id);
d92 3
a94 1
			session_pickup(s, ss);
a99 2
		ss = imsg->data;

d101 2
a102 3
		case IMSG_QUEUE_CREATE_MESSAGE:
			log_debug("smtp: imsg_queue_create_message returned");
			s = session_lookup(env, ss->id);
d105 6
a110 3
			strlcpy(s->s_msg.message_id, ss->u.msgid,
			    sizeof s->s_msg.message_id);
			session_pickup(s, ss);
d113 2
a114 3
		case IMSG_QUEUE_MESSAGE_FILE:
			log_debug("smtp: imsg_queue_message_file returned");
			s = session_lookup(env, ss->id);
d119 4
a122 8
			s->datafp = fdopen(imsg->fd, "w");
			if (s->datafp == NULL) {
				/* queue may have experienced tempfail. */
				if (ss->code != 421)
					fatalx("smtp: fdopen");
				close(imsg->fd);
			}
			session_pickup(s, ss);
d125 2
a126 24
		case IMSG_QUEUE_TEMPFAIL:
			log_debug("smtp: got imsg_queue_tempfail");
			skey.s_id = ss->id;
			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &skey);
			if (s == NULL)
				fatalx("smtp: session is gone");
			if (s->s_flags & F_WRITEONLY)
				/* session is write-only, must not destroy it. */
				s->s_msg.status |= S_MESSAGE_TEMPFAILURE;
			else
				fatalx("smtp: corrupt session");
			return;

		case IMSG_QUEUE_COMMIT_ENVELOPES:
			log_debug("smtp: got imsg_queue_commit_envelopes");
			s = session_lookup(env, ss->id);
			if (s == NULL)
				return;
			session_pickup(s, ss);
			return;

		case IMSG_QUEUE_COMMIT_MESSAGE:
			log_debug("smtp: got imsg_queue_commit_message");
			s = session_lookup(env, ss->id);
d129 3
a131 1
			session_pickup(s, ss);
d135 2
a136 3
			imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, 0, 0,
			    smtp_enqueue(env, NULL), imsg->data,
			    sizeof(struct message));
d229 1
a229 1
			session_pickup(s, NULL);
d241 1
d243 1
a243 2
			    imsg->hdr.peerid, 0, smtp_enqueue(env, imsg->data),
			    NULL, 0);
d416 1
a416 1
smtp_enqueue(struct smtpd *env, uid_t *euid)
a455 9
	s->s_msg.flags |= F_MESSAGE_ENQUEUED;

	if (euid)
		bsnprintf(s->s_hostname, sizeof(s->s_hostname), "%d@@localhost",
		    *euid);
	else {
		strlcpy(s->s_hostname, "localhost", sizeof(s->s_hostname));
		s->s_msg.flags |= F_MESSAGE_BOUNCE;
	}
d457 1
a486 1

d506 1
a506 1
	s->s_id = generate_uid();
d522 1
a522 1
session_lookup(struct smtpd *env, u_int64_t id)
@


1.72
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d6 1
a6 1
 * Copyright (c) 2009-2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
a41 1
#include "queue_backend.h"
d49 1
a49 1
int		smtp_enqueue(struct smtpd *, uid_t);
d52 1
a52 3
struct session *session_lookup(struct smtpd *, u_int32_t);

u_int32_t smtp_id;
d57 2
a63 1
	int			 status, fd;
d84 1
d86 3
a88 2
		case IMSG_MFA_RCPT:
			s = session_lookup(env, imsg->hdr.peerid);
d91 1
a91 3
			memcpy(&status, imsg->data, sizeof status);
			s->s_msg.status |= status;
			session_pickup(s);
d97 2
d100 3
a102 2
		case IMSG_QUEUE_CREATE:
			s = session_lookup(env, imsg->hdr.peerid);
d105 3
a107 6
			memcpy(&s->content_id, imsg->data, sizeof s->content_id);
			memcpy(&s->queue_id, (u_int64_t *)imsg->data + 1,
			    sizeof s->queue_id);
			if (s->content_id == INVALID_ID)
				s->s_msg.status |= S_MESSAGE_TEMPFAILURE;
			session_pickup(s);
d110 3
a112 2
		case IMSG_QUEUE_OPEN:
			s = session_lookup(env, imsg->hdr.peerid);
d117 8
a124 4
			s->datafp = fdopen(imsg->fd, "a");
			if (s->datafp == NULL)
				fatal("smtp: fdopen");
			session_pickup(s);
d127 24
a150 2
		case IMSG_QUEUE_CLOSE:
			s = session_lookup(env, imsg->hdr.peerid);
d153 1
a153 3
			memcpy(&status, imsg->data, sizeof status);
			s->s_msg.status |= status;
			session_pickup(s);
d157 3
a159 2
			fd = smtp_enqueue(env, getuid());
			imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, imsg->hdr.peerid, 0, fd, NULL, 0);
d252 1
a252 1
			session_pickup(s);
a263 1
			fd = smtp_enqueue(env, *(uid_t *)imsg->data);
d265 2
a266 1
			    imsg->hdr.peerid, 0, fd, NULL, 0);
d439 1
a439 1
smtp_enqueue(struct smtpd *env, uid_t uid)
d479 9
a488 1
	bsnprintf(s->s_hostname, sizeof(s->s_hostname), "%d@@localhost", uid);
d518 1
d538 1
a538 1
	s->s_id = smtp_id++;
d554 1
a554 1
session_lookup(struct smtpd *env, u_int32_t id)
@


1.71
log
@cleanup-only commit, removes unrequired includes, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.70 2010/04/21 18:54:43 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d42 1
d50 1
a50 1
int		smtp_enqueue(struct smtpd *, uid_t *);
d53 3
a55 1
struct session *session_lookup(struct smtpd *, u_int64_t);
a59 2
	struct session		 skey;
	struct submit_status	*ss;
d65 1
d86 1
d88 1
a88 4
		case IMSG_MFA_MAIL:
			log_debug("smtp: got imsg_mfa_mail/rcpt");
			ss = imsg->data;
			s = session_lookup(env, ss->id);
d91 3
a93 1
			session_pickup(s, ss);
a98 2
		ss = imsg->data;

d100 2
a101 3
		case IMSG_QUEUE_CREATE_MESSAGE:
			log_debug("smtp: imsg_queue_create_message returned");
			s = session_lookup(env, ss->id);
d104 6
a109 3
			strlcpy(s->s_msg.message_id, ss->u.msgid,
			    sizeof s->s_msg.message_id);
			session_pickup(s, ss);
d112 2
a113 3
		case IMSG_QUEUE_MESSAGE_FILE:
			log_debug("smtp: imsg_queue_message_file returned");
			s = session_lookup(env, ss->id);
d118 4
a121 8
			s->datafp = fdopen(imsg->fd, "w");
			if (s->datafp == NULL) {
				/* queue may have experienced tempfail. */
				if (ss->code != 421)
					fatalx("smtp: fdopen");
				close(imsg->fd);
			}
			session_pickup(s, ss);
d124 2
a125 24
		case IMSG_QUEUE_TEMPFAIL:
			log_debug("smtp: got imsg_queue_tempfail");
			skey.s_id = ss->id;
			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &skey);
			if (s == NULL)
				fatalx("smtp: session is gone");
			if (s->s_flags & F_WRITEONLY)
				/* session is write-only, must not destroy it. */
				s->s_msg.status |= S_MESSAGE_TEMPFAILURE;
			else
				fatalx("smtp: corrupt session");
			return;

		case IMSG_QUEUE_COMMIT_ENVELOPES:
			log_debug("smtp: got imsg_queue_commit_envelopes");
			s = session_lookup(env, ss->id);
			if (s == NULL)
				return;
			session_pickup(s, ss);
			return;

		case IMSG_QUEUE_COMMIT_MESSAGE:
			log_debug("smtp: got imsg_queue_commit_message");
			s = session_lookup(env, ss->id);
d128 3
a130 1
			session_pickup(s, ss);
d134 2
a135 3
			imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, 0, 0,
			    smtp_enqueue(env, NULL), imsg->data,
			    sizeof(struct message));
d228 1
a228 1
			session_pickup(s, NULL);
d240 1
d242 1
a242 2
			    imsg->hdr.peerid, 0, smtp_enqueue(env, imsg->data),
			    NULL, 0);
d415 1
a415 1
smtp_enqueue(struct smtpd *env, uid_t *euid)
a454 9
	s->s_msg.flags |= F_MESSAGE_ENQUEUED;

	if (euid)
		bsnprintf(s->s_hostname, sizeof(s->s_hostname), "%d@@localhost",
		    *euid);
	else {
		strlcpy(s->s_hostname, "localhost", sizeof(s->s_hostname));
		s->s_msg.flags |= F_MESSAGE_BOUNCE;
	}
d456 1
a485 1

d505 1
a505 1
	s->s_id = generate_uid();
d521 1
a521 1
session_lookup(struct smtpd *env, u_int64_t id)
@


1.70
log
@Runner process is just a helper for queue, so tear down its imsg
channels to parent, mda, mta, lka, smtp, and control.  This leaves
just the channel to queue, which forwards imsgs on runner's behalf
and redirects any replies back to it.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.69 2010/04/21 08:29:01 jacekm Exp $	*/
d26 2
@


1.69
log
@Remove unusable ifdef DEBUG code.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.68 2010/04/20 15:34:56 jacekm Exp $	*/
d153 6
a276 10
	if (iev->proc == PROC_RUNNER) {
		switch (imsg->hdr.type) {
		case IMSG_SMTP_ENQUEUE:
			imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, 0, 0,
			    smtp_enqueue(env, NULL), imsg->data,
			    sizeof(struct message));
			return;
		}
	}

d314 1
a314 2
		{ PROC_CONTROL,	imsg_dispatch },
		{ PROC_RUNNER,	imsg_dispatch }
@


1.68
log
@Kill *2400* lines of code by abstracting common bits of the imsg handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.67 2010/01/03 14:37:37 chl Exp $	*/
a335 1
#ifndef DEBUG
a339 3
#else
#warning disabling privilege revocation and chroot in DEBUG MODE
#endif
a343 1
#ifndef DEBUG
a347 1
#endif
@


1.67
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.66 2009/12/14 19:49:22 jacekm Exp $	*/
d41 1
a43 6
void		smtp_dispatch_parent(int, short, void *);
void		smtp_dispatch_mfa(int, short, void *);
void		smtp_dispatch_lka(int, short, void *);
void		smtp_dispatch_queue(int, short, void *);
void		smtp_dispatch_control(int, short, void *);
void		smtp_dispatch_runner(int, short, void *);
d53 1
a53 1
smtp_sig_handler(int sig, short event, void *p)
d55 23
a77 7
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		smtp_shutdown();
		break;
	default:
		fatalx("smtp_sig_handler: unexpected signal");
a78 1
}
d80 10
a89 20
void
smtp_dispatch_parent(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_PARENT];
	ibuf = &iev->ibuf;


	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d94 13
a106 14
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("smtp_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CONF_RELOAD: {
			struct session *s;
d108 53
a160 1
			/* reloading may invalidate various pointers our
d172 2
a173 2
			break;
		}
d176 1
a176 1
				break;
d178 4
a181 5

			if ((env->sc_listeners = calloc(1, sizeof(*env->sc_listeners))) == NULL)
				fatal("smtp_dispatch_parent: calloc");
			if ((env->sc_ssl = calloc(1, sizeof(*env->sc_ssl))) == NULL)
				fatal("smtp_dispatch_parent: calloc");
d183 1
a183 4
			break;
		case IMSG_CONF_SSL: {
			struct ssl	*s;
			struct ssl	*x_ssl;
d185 1
d187 3
a189 3
				break;

			if ((s = calloc(1, sizeof(*s))) == NULL)
d191 4
a194 6
			x_ssl = imsg.data;
			(void)strlcpy(s->ssl_name, x_ssl->ssl_name,
			    sizeof(s->ssl_name));
			s->ssl_cert_len = x_ssl->ssl_cert_len;
			if ((s->ssl_cert =
			    strdup((char *)imsg.data + sizeof(*s))) == NULL)
d196 3
a198 3
			s->ssl_key_len = x_ssl->ssl_key_len;
			if ((s->ssl_key = strdup((char *)imsg.data +
			    (sizeof(*s) + s->ssl_cert_len))) == NULL)
d200 2
d203 1
a203 7
			SPLAY_INSERT(ssltree, env->sc_ssl, s);
			break;
		}
		case IMSG_CONF_LISTENER: {
			struct listener	*l;
			struct ssl	 key;

d205 3
a207 3
				break;

			if ((l = calloc(1, sizeof(*l))) == NULL)
d209 15
a223 12
			memcpy(l, imsg.data, sizeof(*l));

			if ((l->fd = imsg.fd) == -1)
				fatal("cannot get fd");

			(void)strlcpy(key.ssl_name, l->ssl_cert_name,
			    sizeof(key.ssl_name));

			if (l->flags & F_SSL)
				if ((l->ssl = SPLAY_FIND(ssltree,
				    env->sc_ssl, &key)) == NULL)
					fatal("parent and smtp desynchronized");
a224 3
			TAILQ_INSERT_TAIL(env->sc_listeners, l, entry);
			break;
		}
d227 1
a227 1
				break;
d230 1
a230 4
			break;
		case IMSG_PARENT_AUTHENTICATE: {
			struct auth	*reply = imsg.data;
			struct session	*s;
d232 6
a237 8
			log_debug("smtp_dispatch_parent: got auth reply");

			IMSG_SIZE_CHECK(reply);

			if ((s = session_lookup(env, reply->id)) == NULL)
				break;

			if (reply->success) {
a243 1

a244 100
			break;
		}
		case IMSG_CTL_VERBOSE: {
			int verbose;

			IMSG_SIZE_CHECK(&verbose);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		}
		default:
			log_warnx("smtp_dispatch_parent: got imsg %d",
			    imsg.hdr.type);
			fatalx("smtp_dispatch_parent: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
smtp_dispatch_mfa(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_MFA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("smtp_dispatch_mfa: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_MFA_MAIL:
		case IMSG_MFA_RCPT: {
			struct submit_status	*ss = imsg.data;
			struct session		*s;

			log_debug("smtp_dispatch_mfa: mfa handled return path");

			IMSG_SIZE_CHECK(ss);

			if ((s = session_lookup(env, ss->id)) == NULL)
				break;

			session_pickup(s, ss);
			break;
		}
		default:
			log_warnx("smtp_dispatch_mfa: got imsg %d",
			    imsg.hdr.type);
			fatalx("smtp_dispatch_mfa: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
smtp_dispatch_lka(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_LKA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
a245 31
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("smtp_dispatch_lka: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_DNS_PTR: {
			struct dns		*reply = imsg.data;
			struct session		*s;
			struct session		 key;

			IMSG_SIZE_CHECK(reply);

			key.s_id = reply->id;

			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatal("smtp_dispatch_lka: session is gone");

			strlcpy(s->s_hostname,
			    reply->error ? "<unknown>" : reply->host,
			    sizeof(s->s_hostname));
d247 2
a248 36
			strlcpy(s->s_msg.session_hostname, s->s_hostname,
			    sizeof(s->s_msg.session_hostname));

			session_init(s->s_l, s);

			break;
		}
		default:
			log_warnx("smtp_dispatch_lka: got imsg %d",
			    imsg.hdr.type);
			fatalx("smtp_dispatch_lka: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
smtp_dispatch_queue(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_QUEUE];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d253 2
a254 138
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("smtp_dispatch_queue: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_QUEUE_CREATE_MESSAGE: {
			struct submit_status	*ss = imsg.data;
			struct session		*s;

			log_debug("smtp_dispatch_queue: queue handled message creation");

			IMSG_SIZE_CHECK(ss);

			if ((s = session_lookup(env, ss->id)) == NULL)
				break;

			(void)strlcpy(s->s_msg.message_id, ss->u.msgid,
			    sizeof(s->s_msg.message_id));
			session_pickup(s, ss);
			break;
		}
		case IMSG_QUEUE_MESSAGE_FILE: {
			struct submit_status	*ss = imsg.data;
			struct session		*s;
			int			 fd;

			log_debug("smtp_dispatch_queue: queue handled message creation");

			IMSG_SIZE_CHECK(ss);

			fd = imsg.fd;

			if ((s = session_lookup(env, ss->id)) == NULL) {
				close(fd);
				break;
			}

			if ((s->datafp = fdopen(fd, "w")) == NULL) {
				/* queue may have experienced tempfail. */
				if (ss->code != 421)
					fatal("smtp_dispatch_queue: fdopen");
				close(fd);
			}

			session_pickup(s, ss);
			break;
		}
		case IMSG_QUEUE_TEMPFAIL: {
			struct submit_status	*ss = imsg.data;
			struct session		*s;
			struct session		 key;

			log_debug("smtp_dispatch_queue: tempfail in queue");

			IMSG_SIZE_CHECK(ss);

			key.s_id = ss->id;
			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatalx("smtp_dispatch_queue: session is gone");

			if (s->s_flags & F_WRITEONLY) {
				/*
				 * Session is write-only, can't destroy it.
				 */
				s->s_msg.status |= S_MESSAGE_TEMPFAILURE;
			} else
				fatalx("smtp_dispatch_queue: corrupt session");
			break;
		}

		case IMSG_QUEUE_COMMIT_ENVELOPES:
		case IMSG_QUEUE_COMMIT_MESSAGE: {
			struct submit_status	*ss = imsg.data;
			struct session		*s;

			log_debug("smtp_dispatch_queue: queue acknowledged message submission");

			IMSG_SIZE_CHECK(ss);

			if ((s = session_lookup(env, ss->id)) == NULL)
				break;

			session_pickup(s, ss);
			break;
		}
		default:
			log_warnx("smtp_dispatch_queue: got imsg %d",
			    imsg.hdr.type);
			fatalx("smtp_dispatch_queue: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
smtp_dispatch_control(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_CONTROL];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("smtp_dispatch_control: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
d257 1
a257 1
			    imsg.hdr.peerid, 0, smtp_enqueue(env, imsg.data),
d259 2
a260 1
			break;
d263 2
a264 1
			break;
d267 1
a267 5
			break;
		default:
			log_warnx("smtp_dispatch_control: got imsg %d",
			    imsg.hdr.type);
			fatalx("smtp_dispatch_control: unexpected imsg");
a268 1
		imsg_free(&imsg);
a269 2
	imsg_event_add(iev);
}
d271 6
a276 19
void
smtp_dispatch_runner(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_RUNNER];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d281 2
a282 4
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}
d284 10
a293 18
	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("smtp_dispatch_runner: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_SMTP_ENQUEUE:
			imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, 0, 0,
			    smtp_enqueue(env, NULL), imsg.data,
			    sizeof(struct message));
			break;
		default:
			log_warnx("smtp_dispatch_runner: got imsg %d",
			    imsg.hdr.type);
			fatalx("smtp_dispatch_runner: unexpected imsg");
		}
		imsg_free(&imsg);
a294 1
	imsg_event_add(iev);
d314 6
a319 6
		{ PROC_PARENT,	smtp_dispatch_parent },
		{ PROC_MFA,	smtp_dispatch_mfa },
		{ PROC_QUEUE,	smtp_dispatch_queue },
		{ PROC_LKA,	smtp_dispatch_lka },
		{ PROC_CONTROL,	smtp_dispatch_control },
		{ PROC_RUNNER,	smtp_dispatch_runner }
d355 1
d523 1
@


1.66
log
@Set initial session limit so that IMSG_SMTP_ENQUEUE can be satisfied even
in absence of all other real listening sockets.

Spotted by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.65 2009/12/13 22:02:55 jacekm Exp $	*/
d209 9
@


1.65
log
@Use safe fd limits in smtp, lka, queue, and control.  Removes a
possibility for fd-starvation fatal when under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.64 2009/11/08 21:40:05 gilles Exp $	*/
d648 4
@


1.64
log
@- make aliases expansion use a rb tree instead of a tail queue, the code
  doesn't take advantage of the new structure yet, but this was a needed
  change for upcoming improvements.
- introduce aliasestree_{lookup,insert,remove} to the aliases api
- rename queue_generate_id() to generate_uid() and move it to utils.c as
  it is used all over the place and not only in queue

tree idea discussed with jacekm@@, if you update rebuild aliases db, make
clean and flush queue
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.63 2009/10/25 21:06:06 gilles Exp $	*/
d28 1
d52 1
a52 1
void		smtp_resume(struct smtpd *);
d54 1
a54 1
void		session_auth_pickup(struct session *, char *, size_t);
d511 1
a511 56
		case IMSG_SMTP_ENQUEUE: {
			static struct listener	 l;
			struct addrinfo		 hints, *res;
			struct session		*s;
			uid_t			 euid;
			int			 fd[2];

			bzero(&l, sizeof(l));
			l.env = env;

			memcpy(&euid, imsg.data, sizeof(euid));

			if (env->stats->smtp.sessions_active >=
			    env->sc_maxconn) {
				log_warnx("denying local connection, too many"
				    " sessions active");
				imsg_compose_event(iev, IMSG_SMTP_ENQUEUE,
				    imsg.hdr.peerid, 0, -1, NULL, 0);
				break;
			}

			if (socketpair(
			    AF_UNIX, SOCK_STREAM, PF_UNSPEC, fd) == -1)
				fatal("socketpair");

			if ((s = calloc(1, sizeof(*s))) == NULL)
				fatal(NULL);

			s->s_id = generate_uid();
			s->s_fd = fd[0];
			s->s_env = env;
			s->s_l = &l;
			s->s_msg.flags |= F_MESSAGE_ENQUEUED;
			(void)strlcpy(s->s_msg.tag, s->s_l->tag, sizeof(s->s_msg.tag));

			bzero(&hints, sizeof(hints));
			hints.ai_family = PF_UNSPEC;
			hints.ai_flags = AI_NUMERICHOST;

			if (getaddrinfo("::1", NULL, &hints, &res) != 0)
				fatal("getaddrinfo");

			memcpy(&s->s_ss, res->ai_addr, res->ai_addrlen);

			env->stats->smtp.sessions++;
			env->stats->smtp.sessions_active++;

			bsnprintf(s->s_hostname, sizeof(s->s_hostname),
			    "%d@@localhost", euid);
			strlcpy(s->s_msg.session_hostname, s->s_hostname,
			    sizeof(s->s_msg.session_hostname));

			SPLAY_INSERT(sessiontree, &s->s_env->sc_sessions, s);

			session_init(s->s_l, s);

d513 2
a514 1
			    imsg.hdr.peerid, 0, fd[1], NULL, 0);
a515 1
		}
d567 4
a570 54
		case IMSG_SMTP_ENQUEUE: {
			static struct listener	 l;
			struct addrinfo		 hints, *res;
			struct session		*s;
			int			 fd[2];

			bzero(&l, sizeof(l));
			l.env = env;

			if (env->stats->smtp.sessions_active >=
			    env->sc_maxconn) {
				log_warnx("denying internal connection, too many"
				    " sessions active");
				imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, 0, 0, -1,
				    imsg.data, sizeof(struct message));
				break;
			}

			if (socketpair(
			    AF_UNIX, SOCK_STREAM, PF_UNSPEC, fd) == -1)
				fatal("socketpair");

			if ((s = calloc(1, sizeof(*s))) == NULL)
				fatal(NULL);

			s->s_id = generate_uid();
			s->s_fd = fd[0];
			s->s_env = env;
			s->s_l = &l;
			s->s_msg.flags |= F_MESSAGE_ENQUEUED|F_MESSAGE_BOUNCE;

			bzero(&hints, sizeof(hints));
			hints.ai_family = PF_UNSPEC;
			hints.ai_flags = AI_NUMERICHOST;

			if (getaddrinfo("::1", NULL, &hints, &res) != 0)
				fatal("getaddrinfo");

			memcpy(&s->s_ss, res->ai_addr, res->ai_addrlen);

			env->stats->smtp.sessions++;
			env->stats->smtp.sessions_active++;

			strlcpy(s->s_hostname, "localhost",
			    sizeof(s->s_hostname));
			strlcpy(s->s_msg.session_hostname, s->s_hostname,
			    sizeof(s->s_msg.session_hostname));

			SPLAY_INSERT(sessiontree, &s->s_env->sc_sessions, s);

			session_init(s->s_l, s);

			imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, 0, 0, fd[1],
			    imsg.data, sizeof(struct message));
a571 1
		}
d662 1
d673 1
a673 1
		event_set(&l->ev, l->fd, EV_READ, smtp_accept, l);
d676 1
d678 6
d700 1
d727 59
a788 2
	int			 s_fd;
	struct sockaddr_storage	 ss;
d793 1
a793 4
	log_debug("smtp_accept: incoming client on listener: %p", l);
	len = sizeof(struct sockaddr_storage);
	if ((s_fd = accept(l->fd, (struct sockaddr *)&ss, &len)) == -1) {
		event_del(&l->ev);
d795 6
d803 2
a804 4
	log_debug("smtp_accept: accepted client on listener: %p", l);
	if ((s = calloc(1, sizeof(*s))) == NULL)
		fatal(NULL);
	len = sizeof(s->s_ss);
a805 4
	s->s_id = generate_uid();
	s->s_fd = s_fd;
	s->s_env = l->env;
	s->s_l = l;
d807 5
a811 1
	(void)memcpy(&s->s_ss, &ss, sizeof(s->s_ss));
d813 1
a813 1
	event_add(&l->ev, NULL);
d815 2
a816 2
	s->s_env->stats->smtp.sessions++;
	s->s_env->stats->smtp.sessions_active++;
d818 13
a830 2
	if (s->s_env->stats->smtp.sessions_active == s->s_env->sc_maxconn)
		event_del(&l->ev);
d832 2
a833 1
	dns_query_ptr(l->env, &s->s_ss, s->s_id);
d835 1
a835 1
	SPLAY_INSERT(sessiontree, &s->s_env->sc_sessions, s);
@


1.63
log
@tag should also be copied from listener to message when the message is
enqueued through smtpctl
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.62 2009/09/18 00:04:26 jacekm Exp $	*/
d538 1
a538 1
			s->s_id = queue_generate_id();
d646 1
a646 1
			s->s_id = queue_generate_id();
d844 1
a844 1
	s->s_id = queue_generate_id();
@


1.62
log
@Remove useless Received line added at the /usr/sbin/sendmail stage, it
was not correctly formatted anyway.  Recording of sender uid has
been moved to the server process (getpeereid), which means it is not
subject to forgery.
Based on problem report by Michael Lechtermann <michael@@lechtermann.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.61 2009/09/03 08:19:13 jacekm Exp $	*/
d543 1
@


1.61
log
@imsg_get sets errno so use fatal instead of fatalx.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.60 2009/08/06 16:46:57 gilles Exp $	*/
d514 1
d520 2
d526 2
a527 2
				imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, 0, 0, -1,
				    imsg.data, sizeof(int));
d556 2
a557 2
			strlcpy(s->s_hostname, "localhost",
			    sizeof(s->s_hostname));
d565 2
a566 2
			imsg_compose_event(iev, IMSG_SMTP_ENQUEUE, 0, 0, fd[1],
			    imsg.data, sizeof(int));
@


1.60
log
@- change all occurences of T_DAEMON_BATCH,MESSAGE to T_BOUNCE_BATCH/MESSAGE
- make sure T_BOUNCE_MESSAGE is no longer OR-ed to T_MDA/MTA_MESSAGE
- define F_MESSAGE_BOUNCE flag and make sure bounce sessions set it
- teach smtpctl show queue how to recognize a bounce message
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.59 2009/08/06 13:40:45 gilles Exp $	*/
d100 1
a100 1
			fatalx("smtp_dispatch_parent: imsg_get error");
d250 1
a250 1
			fatalx("smtp_dispatch_mfa: imsg_get error");
d310 1
a310 1
			fatalx("smtp_dispatch_lka: imsg_get error");
d379 1
a379 1
			fatalx("smtp_dispatch_queue: imsg_get error");
d505 1
a505 1
			fatalx("smtp_dispatch_control: imsg_get error");
d612 1
a612 1
			fatalx("smtp_dispatch_runner: imsg_get error");
@


1.59
log
@This commit reworks the entire mailer daemon support to actually make it
work for real. As an added bonus, it simplifies it, makes it follow the
same code path as regular messages and kills quite some code from mta,
mda and store. There's still some work needed but the most painful part
is behind us now ;)

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.58 2009/06/07 05:56:25 eric Exp $	*/
d646 1
a646 1
			s->s_msg.flags |= F_MESSAGE_ENQUEUED;
@


1.58
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.57 2009/06/06 04:14:21 pyr Exp $	*/
d47 1
d583 101
d704 2
a705 1
		{ PROC_CONTROL,	smtp_dispatch_control }
@


1.57
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.56 2009/06/05 20:43:57 pyr Exp $	*/
d167 1
a167 1
			if ((l->fd = imsg_get_fd(ibuf)) == -1)
d408 1
a408 1
			fd = imsg_get_fd(ibuf);
@


1.56
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.55 2009/06/02 22:23:36 gilles Exp $	*/
d72 1
d77 3
a79 1
	ibuf = env->sc_ibufs[PROC_PARENT];
d86 1
a86 1
			event_del(&ibuf->ev);
d117 1
a117 1
			imsg_compose_event(ibuf, IMSG_PARENT_SEND_CONFIG, 0, 0, -1,
d216 1
a216 1
	imsg_event_add(ibuf);
d223 1
d228 2
a229 1
	ibuf = env->sc_ibufs[PROC_MFA];
d236 1
a236 1
			event_del(&ibuf->ev);
d276 1
a276 1
	imsg_event_add(ibuf);
d283 1
d288 2
a289 1
	ibuf = env->sc_ibufs[PROC_LKA];
d296 1
a296 1
			event_del(&ibuf->ev);
d345 1
a345 1
	imsg_event_add(ibuf);
d352 1
d357 2
a358 1
	ibuf = env->sc_ibufs[PROC_QUEUE];
d365 1
a365 1
			event_del(&ibuf->ev);
d471 1
a471 1
	imsg_event_add(ibuf);
d478 1
d483 2
a484 1
	ibuf = env->sc_ibufs[PROC_CONTROL];
d491 1
a491 1
			event_del(&ibuf->ev);
d522 1
a522 1
				imsg_compose_event(ibuf, IMSG_SMTP_ENQUEUE, 0, 0, -1,
d561 1
a561 1
			imsg_compose_event(ibuf, IMSG_SMTP_ENQUEUE, 0, 0, fd[1],
d578 1
a578 1
	imsg_event_add(ibuf);
@


1.55
log
@make env->sc_listeners and env->sc_ssl pointers, one step further toward
configuration reloading without killing active sessions; ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.54 2009/06/01 14:38:45 jacekm Exp $	*/
d114 1
a114 1
			imsg_compose(ibuf, IMSG_PARENT_SEND_CONFIG, 0, 0, -1,
d164 1
a164 1
			if ((l->fd = imsg_get_fd(ibuf, &imsg)) == -1)
d399 1
a399 1
			fd = imsg_get_fd(ibuf, &imsg);
d511 1
a511 1
				imsg_compose(ibuf, IMSG_SMTP_ENQUEUE, 0, 0, -1,
d550 1
a550 1
			imsg_compose(ibuf, IMSG_SMTP_ENQUEUE, 0, 0, fd[1],
@


1.54
log
@Don't destroy listening socket when pause/resume request is received,
use event_del/event_add instead; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.53 2009/06/01 13:20:56 jacekm Exp $	*/
d112 2
a113 2

			smtp_disable_events(env);
d122 6
d150 1
a150 1
			SPLAY_INSERT(ssltree, &env->sc_ssl, s);
d172 1
a172 1
				    &env->sc_ssl, &key)) == NULL)
d175 1
a175 1
			TAILQ_INSERT_TAIL(&env->sc_listeners, l, entry);
a638 1
	smtp_setup_events(env);
d650 1
a650 1
	TAILQ_FOREACH(l, &env->sc_listeners, entry) {
d671 2
a672 2
	while ((l = TAILQ_FIRST(&env->sc_listeners)) != NULL) {
		TAILQ_REMOVE(&env->sc_listeners, l, entry);
d677 2
a678 1
	TAILQ_INIT(&env->sc_listeners);
d689 1
a689 1
	TAILQ_FOREACH(l, &env->sc_listeners, entry)
d701 1
a701 1
	TAILQ_FOREACH(l, &env->sc_listeners, entry)
@


1.53
log
@Fix EV_READ/EV_WRITE testing inside IMSG handlers. Based on similar change
to the routing daemons by claudio@@; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.52 2009/05/25 14:00:36 jacekm Exp $	*/
d678 2
a680 1
	smtp_disable_events(env);
d682 3
d690 2
a692 2
	imsg_compose(env->sc_ibufs[PROC_PARENT], IMSG_PARENT_SEND_CONFIG,
	    0, 0, -1, NULL, 0);
d694 3
@


1.52
log
@merge smtp_listener_setup into its only caller; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.51 2009/05/24 15:47:31 jacekm Exp $	*/
d77 2
a78 2
	switch (event) {
	case EV_READ:
d87 3
a89 2
		break;
	case EV_WRITE:
a91 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d219 2
a220 2
	switch (event) {
	case EV_READ:
d229 3
a231 2
		break;
	case EV_WRITE:
a233 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d277 2
a278 2
	switch (event) {
	case EV_READ:
d287 3
a289 2
		break;
	case EV_WRITE:
a291 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d344 2
a345 2
	switch (event) {
	case EV_READ:
d354 3
a356 2
		break;
	case EV_WRITE:
a358 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d468 2
a469 2
	switch (event) {
	case EV_READ:
d478 3
a480 2
		break;
	case EV_WRITE:
a482 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
@


1.51
log
@Parent process shouldn't be base64-decoding untrusted strings, move
this code to privsep smtp process; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.50 2009/05/24 14:38:56 jacekm Exp $	*/
a745 15
}

void
smtp_listener_setup(struct smtpd *env, struct listener *l)
{
	int opt;

	if ((l->fd = socket(l->ss.ss_family, SOCK_STREAM, 0)) == -1)
		fatal("socket");

	opt = 1;
	setsockopt(l->fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

	if (bind(l->fd, (struct sockaddr *)&l->ss, l->ss.ss_len) == -1)
		fatal("bind");
@


1.50
log
@Parent process forks 3 types of processes, track them all in a single tree
using newly introduced child struct.

Manage process titles centrally in struct smtpd.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.49 2009/05/24 14:22:23 jacekm Exp $	*/
d182 2
a183 2
			struct session			*s;
			struct session_auth_reply	*reply = imsg.data;
d185 1
a185 1
			log_debug("smtp_dispatch_parent: parent handled authentication");
d189 1
a189 1
			if ((s = session_lookup(env, reply->session_id)) == NULL)
d192 1
a192 1
			if (reply->value)
d194 5
d200 1
a200 2
			session_auth_pickup(s, NULL, 0);

@


1.49
log
@Instead of keeping stats private to each process, and querying every
process individually whenever stats need to be fetched, keep stats
in MAP_ANON shared memory allocated by parent.

This means control has direct access to stats and can respond very
quickly without troubling any other daemon processes.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.48 2009/05/20 14:29:44 gilles Exp $	*/
a621 1
	setproctitle("smtp server");
d623 1
@


1.48
log
@first step towards configuration reload in smtpd, smtpctl reload will parse
the configuration file again and replace current configuration with new one
in all processes. what we don't support yet is graceful restart, clients in
sessions at the moment of the reload will have a temp failure thrown at 'em
which is ok RFC-wise but which we will try to improve anyway.

tested with various setups, "diff reads good" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.47 2009/05/19 11:24:24 jacekm Exp $	*/
a54 2
struct s_session	s_smtp;

d512 2
a513 1
			if (s_smtp.sessions_active >= env->sc_maxconn) {
d543 2
a544 2
			s_smtp.sessions++;
			s_smtp.sessions_active++;
a564 9
		case IMSG_STATS: {
			struct stats *s;

			s = imsg.data;
			IMSG_SIZE_CHECK(s);
			s->u.smtp = s_smtp;
			imsg_compose(ibuf, IMSG_STATS, 0, 0, -1, s, sizeof(*s));
			break;
		}
d733 2
a734 2
	s_smtp.sessions++;
	s_smtp.sessions_active++;
d736 1
a736 1
	if (s_smtp.sessions_active == s->s_env->sc_maxconn)
@


1.47
log
@Verify the amount of IMSG payload is exactly as expected; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.46 2009/05/18 20:23:35 jacekm Exp $	*/
d106 17
a126 1
			smtp_disable_events(env);
d162 1
@


1.46
log
@Complete rework of bufferevent event masking allowing for  more
strictness:
- Drop clients attempting command pipelining; protects the daemon
from all kinds of abuse.
- Replace F_EVLOCKED flag with F_WRITEONLY which has cleaner sematics:
when up, session must not be destroyed nor read from, but may be
written to.
- Write callback becomes a central place for enabling EV_READ.
- Delay bufferevent creation until after ssl handshake is completed.

A bunch of session error stats were added to smtpctl's "show stats".
These could help spotting event masking errors in the future.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.45 2009/05/14 15:05:12 eric Exp $	*/
d172 2
d237 2
d296 2
d367 2
d384 2
d410 2
d434 2
d553 1
@


1.45
log
@use the nitems() macro where appropriate

ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.44 2009/05/10 11:29:40 jacekm Exp $	*/
a399 10
			/*
			 * IMSG_QUEUE_TEMPFAIL is not the final reply to
			 * IMSG_MFA_RCPT - IMSG_QUEUE_COMMIT_ENVELOPES is.
			 * Therefore, nothing more but updating the flags
			 * is allowed here. If session_lookup were to be
			 * called, then subsequent session_lookup in the
			 * IMSG_QUEUE_COMMIT_ENVELOPES handler would fatal for
			 * either of two reasons: missing session, or missing
			 * EVLOCKED flag.
			 */
d405 7
a411 1
			s->s_msg.status |= S_MESSAGE_TEMPFAILURE;
d751 1
a751 1
	if (!(s->s_flags & F_EVLOCKED))
d753 1
a753 1
	s->s_flags &= ~F_EVLOCKED;
@


1.44
log
@assert copyright; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.43 2009/05/09 18:59:09 jacekm Exp $	*/
d623 2
a624 2
	config_pipes(env, peers, 5);
	config_peers(env, peers, 5);
@


1.43
log
@fix function names in log_debug
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.42 2009/05/09 17:04:55 jacekm Exp $	*/
d6 1
@


1.42
log
@- New API to handle all DNS query types (A, MX, PTR) asynchronously.

- Improve RFC compliance: CNAMEs are resolved, equal preference MXs
are randomized, relaying via MX that has equal/lower preference
than local server is prevented, decision on when to treat domain
name as implicit MX is better.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.41 2009/04/28 22:38:22 jacekm Exp $	*/
d670 1
a670 1
	log_debug("smtp_pause_listeners: pausing listening sockets");
d678 1
a678 1
	log_debug("smtp_pause_listeners: resuming listening sockets");
@


1.41
log
@fix a bug where client with unresolvable revdns is never greeted; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.40 2009/04/28 21:55:16 jacekm Exp $	*/
d286 3
a288 1
		case IMSG_LKA_HOST: {
a289 2
			struct session		*s;
			struct session		*ss;
d291 1
a291 2
			ss = imsg.data;
			key.s_id = ss->s_id;
d297 2
a298 1
			strlcpy(s->s_hostname, ss->s_hostname,
d300 2
a301 1
			strlcpy(s->s_msg.session_hostname, ss->s_hostname,
d720 1
a720 2
	imsg_compose(s->s_env->sc_ibufs[PROC_LKA], IMSG_LKA_HOST, 0, 0, -1, s,
	    sizeof(struct session));
@


1.40
log
@make S_DATAREQUEST state similar to S_{MAIL,RCPT}REQUEST; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.39 2009/04/27 16:22:17 jacekm Exp $	*/
a718 3
	strlcpy(s->s_hostname, "<unknown>", sizeof(s->s_hostname));
	strlcpy(s->s_msg.session_hostname, s->s_hostname,
	    sizeof(s->s_msg.session_hostname));
@


1.39
log
@fix unlikely fd leak; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.38 2009/04/24 09:38:11 jacekm Exp $	*/
d381 5
a385 8
			if (fd != -1) {
				s->datafp = fdopen(fd, "w");
				if (s->datafp == NULL) {
					/* no need to handle error, it will be
					 * caught in session_pickup()
					 */
					close(fd);
				}
d387 1
a388 1

@


1.38
log
@Enclose common imsg handling code in a function, which additionally
does some sanity checking. Fix a bug that could lead to fatal under
rare circumstances, exposed by this newly added check; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.37 2009/04/24 08:35:48 jacekm Exp $	*/
d376 2
a377 1
			if ((s = session_lookup(env, ss->id)) == NULL)
d379 1
@


1.37
log
@use same timeout at each session state, and make use of
bufferevent_settimeout instead of rolling our own; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.36 2009/04/21 14:37:32 eric Exp $	*/
d52 1
d166 2
a167 3
			struct session		*s;
			struct session		 key;
			struct session_auth_reply *reply;
a169 3
			reply = imsg.data;
			key.s_id = reply->session_id;
			key.s_msg.id = reply->session_id;
d171 1
a171 6
			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatal("smtp_dispatch_parent: session is gone");

			if (s->s_flags & F_QUIT) {
				session_destroy(s);
a172 2
			}
			s->s_flags &= ~F_EVLOCKED;
d229 1
a229 1
			struct submit_status	*ss;
a230 1
			struct session		 key;
a232 7
			ss = imsg.data;
			key.s_id = ss->id;
			key.s_msg.id = ss->id;

			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatal("smtp_dispatch_mfa: session is gone");
d234 1
a234 2
			if (s->s_flags & F_QUIT) {
				session_destroy(s);
a235 2
			}
			s->s_flags &= ~F_EVLOCKED;
d354 1
a354 1
			struct submit_status	*ss;
a355 1
			struct session		 key;
a357 7
			ss = imsg.data;

			key.s_id = ss->id;

			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatal("smtp_dispatch_queue: session is gone");
d359 1
a359 2
			if (s->s_flags & F_QUIT) {
				session_destroy(s);
a360 2
			}
			s->s_flags &= ~F_EVLOCKED;
d368 1
a368 1
			struct submit_status	*ss;
a369 1
			struct session		 key;
a372 7
			ss = imsg.data;

			key.s_id = ss->id;

			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatal("smtp_dispatch_queue: session is gone");
d376 1
a376 2
			if (s->s_flags & F_QUIT) {
				session_destroy(s);
a377 2
			}
			s->s_flags &= ~F_EVLOCKED;
d393 1
a393 1
			struct submit_status	*ss;
d397 12
a408 2
			log_debug("smtp_dispatch_queue: queue acknownedged a temporary failure");
			ss = imsg.data;
a409 2
			key.s_msg.id = ss->id;

d412 1
a412 1
				fatal("smtp_dispatch_queue: session is gone");
a413 5
			if (s->s_flags & F_QUIT) {
				session_destroy(s);
				break;
			}
			s->s_flags &= ~F_EVLOCKED;
d420 1
a420 1
			struct submit_status	*ss;
a421 1
			struct session		 key;
a423 7
			ss = imsg.data;
			key.s_id = ss->id;
			key.s_msg.id = ss->id;

			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatal("smtp_dispatch_queue: session is gone");
d425 1
a425 6
			if (s->s_flags & F_QUIT) {
				if (imsg.hdr.type == IMSG_QUEUE_COMMIT_MESSAGE) {
					s->s_msg.message_id[0] = '\0';
					s->s_msg.message_uid[0] = '\0';
				}
				session_destroy(s);
a426 2
			}
			s->s_flags &= ~F_EVLOCKED;
d742 26
@


1.36
log
@correct some fatal(x) calls and error strings

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.35 2009/04/20 17:07:01 jacekm Exp $	*/
a50 1
void		session_timeout(int, short, void *);
@


1.35
log
@Rewrite smtp session timeouts; use evtimer_* from event(3) instead
of regularly walking session tree in search of idle clients. Gives
the smtp process a chance to become idle.

As a bonus, add smtp.sessions.timeout counter to "smtpctl show stats".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.34 2009/04/16 15:35:06 jacekm Exp $	*/
d100 1
a100 1
			fatal("parent_dispatch_smtp: imsg_read error");
d233 1
a233 1
			fatal("smtp_dispatch_mfa: imsg_read error");
d303 1
a303 1
			fatal("smtp_dispatch_lka: imsg_read error");
d370 1
a370 1
			fatal("smtp_dispatch_queue: imsg_read error");
d528 1
a528 1
			fatal("smtp_dispatch_control: imsg_read error");
@


1.34
log
@Total rewrite of the sendmail interface. Adds support for -t, -v,
and -F cmdline args. Also, date and Message-Id headers are added
when missing.

The main trouble with the current enqueue code is that it requires
dealing with problems in the control process that are already solved
in the smtp process, ie. duplicating a lot of code which interacts
with untrusted clients. This diff solves this by making sendmail
obtain a SMTP socket from smtp via smtpd.sock, and using that socket
to deliver the message. For smtpd it looks as if connection was
made from the network, only difference being the F_MESSAGE_ENQUEUED
message flag, handy when differentation between local and remote
deliveries is wanted.

Most of the features come from the femail program, created by henning@@.

Additional testing by Nigel J. Taylor.

ok gilles@@, henning@@ happy with smtpd using femail code
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.33 2009/04/09 19:49:34 jacekm Exp $	*/
a558 1
			s->s_tm = time(NULL);
a691 1
	struct timeval	 tv;
a705 5

	evtimer_set(&env->sc_ev, session_timeout, env);
	tv.tv_sec = 1;
	tv.tv_usec = 0;
	evtimer_add(&env->sc_ev, &tv);
a762 1
	s->s_tm = time(NULL);
@


1.33
log
@change syntax of the "listen on" and "relay via" directives:
1) kill the ssmtp keyword in "ssmtp listen on ...";
2) kill the use keyword in "... use certificate foo";
3) tls no longer implicit, user must explicitely use the tls or smtps option.
4) for "relay via", move the tls/smtps options to right after the
port specification; makes it similar to "listen on".

These directives:

  ssmtp listen on fxp0 use ceritifate "foo"
  accept for all relay via tls "mx.bar.com"

now become:

  listen on fxp0 smtps certificate "foo"
  accept for all relay via "mx.bar.com" tls

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.32 2009/03/29 14:18:20 jacekm Exp $	*/
d28 1
d533 56
@


1.32
log
@turn some log_debugs into log_warns or even fatals; "looks ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.31 2009/03/15 19:32:10 gilles Exp $	*/
a146 3
			log_debug("smtp_dispatch_parent: "
			    "got fd %d for listener: %p", l->fd, l);

d639 3
a641 2
		log_debug("smtp_setup_events: configuring listener: %p%s.",
		    l, (l->flags & F_SSL)?" (with ssl)":"");
@


1.31
log
@since we are going to share code in smtp sessions and mta sessions, we need
to also share the statistics structure, still being worked on
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.30 2009/03/15 18:12:15 gilles Exp $	*/
d195 1
a195 1
			log_debug("parent_dispatch_smtp: unexpected imsg %d",
d197 1
a197 1
			break;
d265 1
a265 1
			log_debug("smtp_dispatch_mfa: unexpected imsg %d",
d267 1
a267 1
			break;
d332 1
a332 1
			log_debug("smtp_dispatch_lka: unexpected imsg %d",
d334 1
a334 1
			break;
d490 1
a490 1
			log_debug("smtp_dispatch_queue: unexpected imsg %d",
d492 1
a492 1
			break;
d550 1
a550 1
			log_debug("smtp_dispatch_control: unexpected imsg %d",
d552 1
a552 1
			break;
@


1.30
log
@save 4 bytes per message by moving the datafp field of struct message to
struct session where it really belongs.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.29 2009/02/23 00:51:32 chl Exp $	*/
d53 1
a53 1
struct s_smtp	s_smtp;
@


1.29
log
@add missing headers needed by time()

ok jacekm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.28 2009/02/22 19:07:33 chl Exp $	*/
d426 2
a427 2
				s->s_msg.datafp = fdopen(fd, "w");
				if (s->s_msg.datafp == NULL) {
@


1.28
log
@add missing headers

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.27 2009/02/22 11:44:29 form Exp $	*/
d33 1
@


1.27
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.26 2009/02/18 00:29:52 gilles Exp $	*/
d29 1
@


1.26
log
@previous commit was incomplete, this fixes ssmtp
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.25 2009/02/18 00:17:39 gilles Exp $	*/
d320 2
a321 1
			strlcpy(s->s_hostname, ss->s_hostname, MAXHOSTNAMELEN);
d323 1
a323 1
			    MAXHOSTNAMELEN);
d727 3
a729 2
	strlcpy(s->s_hostname, "<unknown>", MAXHOSTNAMELEN);
	strlcpy(s->s_msg.session_hostname, s->s_hostname, MAXHOSTNAMELEN);
@


1.25
log
@smtp_accept() now requests from lka that it performs the hostname lookup
and inserts the session into the session tree. session_init() is called
only when we receive the resolution answer.

this fixes a race condition that would sometimes cause the hostname to
appear as "<unknown>" in headers just because dns was lagging, and it
unbreaks ssmtp support which suffered from th very same race condition.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.24 2009/02/17 21:53:55 gilles Exp $	*/
a324 1
			session_pickup(s, NULL);
@


1.24
log
@after a message has been commited to queue, do not incondtionnally clear
the message id and uid immediately. only do it if session has been flagged
with F_QUIT, otherwise session_pickup() will do it when in state S_DONE.

this fixes a bug reported by pea@@ where the message id was not displayed
in the "message accepted for delivery" line.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.23 2009/02/15 10:32:23 jacekm Exp $	*/
d313 2
a314 2
			s = imsg.data;
			key.s_id = s->s_id;
d316 2
a317 2
			ss = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (ss == NULL)
d320 2
a321 8
			if (ss->s_flags & F_QUIT) {
				session_destroy(s);
				break;
			}
			ss->s_flags &= ~F_EVLOCKED;

			strlcpy(ss->s_hostname, s->s_hostname, MAXHOSTNAMELEN);
			strlcpy(ss->s_msg.session_hostname, s->s_hostname,
d324 1
d711 1
a718 1
	session_init(l, s);
d726 7
@


1.23
log
@New config.c that allows for process cloning. Done by pyr@@ for
relayd at n2k9, and adapted to smtpd; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.22 2009/01/30 21:40:21 gilles Exp $	*/
a478 5
			if (imsg.hdr.type == IMSG_QUEUE_COMMIT_MESSAGE) {
				s->s_msg.message_id[0] = '\0';
				s->s_msg.message_uid[0] = '\0';
			}

d480 4
@


1.22
log
@improve statistics for smtp process. not only collect the current sessions
count, but also the total sessions count, ssmtp sessions (both current and
total) and starttls sessions (both current and total)

# ./smtpctl/smtpctl show stats|grep smtp.sessions
smtp.sessions = 0
smtp.sessions.active = 0
smtp.sessions.ssmtp = 0
smtp.sessions.ssmtp.active = 0
smtp.sessions.starttls = 0
smtp.sessions.starttls.active = 0
#
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.21 2009/01/30 21:22:33 gilles Exp $	*/
d629 1
@


1.21
log
@clear the F_EVLOCK flag earlier to prevent the error event handler from
being called again with F_EVLOCK set. this fixes a bug where disconnect
after smtpd sends greeting and before entering any command failed to go
into session_destroy().

while at it, rename the "smtp.clients" statistic to "smtp.sessions" and
add counters to struct s_smtp so that I can add ssmtp and starttls with
my next commit ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.20 2009/01/30 17:34:58 gilles Exp $	*/
d727 1
d729 1
a729 1
	if (s_smtp.sessions == s->s_env->sc_maxconn)
@


1.20
log
@bump descriptors limit to the max and set the maximum connections count to
three quarters of that limit (a session typically has 3 descriptors). when
we hit that limit, we stop accepting connections, and when client closes a
session, we start accepting connections again. this prevents us from going
into a session that is likely to fail because of scarce resources.

idea discussed with jacekm@@, code mostly ripped from relayd
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.19 2009/01/30 16:37:52 gilles Exp $	*/
d183 1
d257 1
d324 1
d398 1
d426 1
d459 1
a459 1

d488 1
d726 1
a726 1
	s_smtp.clients++;
d728 1
a728 1
	if (s_smtp.clients == s->s_env->sc_maxconn)
@


1.19
log
@fix a very annoying events masking issue which would cause a fatal() to be
hit under certain conditions; while tracking the bug I ran into other bugs
which were kind of related and could cause us to hit a fatal() too.

fix by me, but with lots of testing and investigation with jacekm@@,
ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.18 2009/01/29 21:59:15 jacekm Exp $	*/
d701 1
a701 1
		event_add(&l->ev, NULL);
d712 3
d719 5
@


1.18
log
@Implement "smtpctl show stats"; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.17 2009/01/28 19:38:46 gilles Exp $	*/
d176 5
a180 2
			if (s == NULL) {
				/* Session was removed while we were waiting for the message */
d249 5
a253 2
			if (s == NULL) {
				/* Session was removed while we were waiting for the message */
d315 5
a319 3
			if (ss == NULL) {
				/* Session was removed while we were waiting
				 * for the message */
d326 3
d388 5
a392 2
			if (s == NULL) {
				/* Session was removed while we were waiting for the message */
d413 7
a419 2
			if (s == NULL) {
				/* Session was removed while we were waiting for the message */
a422 1
			fd = imsg_get_fd(ibuf, &imsg);
d447 5
a451 2
			if (s == NULL) {
				/* Session was removed while we were waiting for the message */
d454 1
d471 10
a480 2
			if (s == NULL) {
				/* Session was removed while we were waiting for the message */
a484 1

@


1.17
log
@when pausing listeners, do not simply disable their events as new
clients would still be able to connect. instead, at pause time we
close and remove the listeners, and at resume time we request the
parent to reconfigure all listeners.

discussed with pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.16 2009/01/04 22:35:09 gilles Exp $	*/
d51 2
d510 8
@


1.16
log
@- smtp can now pause/resume the accepting of incoming messages
- smtpctl recognizes "pause incoming" and "resume incoming"
- setup imsg communication between control process and smtp process
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.15 2009/01/04 00:58:59 gilles Exp $	*/
a635 2
	struct listener	*l;

d637 1
a637 3
	TAILQ_FOREACH(l, &env->sc_listeners, entry) {
		event_del(&l->ev);
	}
a643 2
	struct listener	*l;

d645 2
a646 3
	TAILQ_FOREACH(l, &env->sc_listeners, entry) {
		event_add(&l->ev, NULL);
	}
@


1.15
log
@aliases/forwards expansion was not done correctly and a race could
cause delivery to happen before expansion is over, causing some of
the recipients to never receive the mail. change how the mfa, lka,
queue and smtp processes communicate to ensure smtp never receives
an acknowledgment before ALL expanded envelopes are on disk. While
at it, lka was doing work which belongs in mfa, fix that also.

this is based on an idea from a talk with jacekm@@, change not over
but already better than what we had.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.14 2009/01/01 16:15:47 jacekm Exp $	*/
d42 1
d45 2
d467 52
d538 2
a539 1
		{ PROC_LKA,	smtp_dispatch_lka }
d584 1
a584 1
	config_peers(env, peers, 4);
d631 24
@


1.14
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.13 2008/12/26 10:28:31 jacekm Exp $	*/
d413 20
a432 1
		case IMSG_QUEUE_SUBMIT_ENVELOPE:
@


1.13
log
@parse.y doesn't allow listen backlog configuration, so "bzero default" is used.
Hardcode it instead: 5 is a popular choice across the tree; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.12 2008/12/22 13:18:58 jacekm Exp $	*/
a27 1
#include <fcntl.h>
a28 1
#include <signal.h>
a31 1
#include <time.h>
@


1.12
log
@s->s_msg.session_hostname must hold resolved hostname as well; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.11 2008/12/21 18:51:08 gilles Exp $	*/
d532 1
a532 1
		if (listen(l->fd, l->backlog) == -1)
@


1.11
log
@- missing prototype + smtp.c was misusing session_auth_pickup()
- unlike starttls, ssmtp sets the F_SECURE flag on session before helo/ehlo
	handlers are called. this means that if we clear all flags in helo/
	helo handlers, we prevent smtpd from advertising AUTH as it will do
	so only for F_SECURE sessions. This commits unbreaks SMTP AUTH with
	smtp sessions. Problem spotted by James Turner <james@@bsdgroup.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.10 2008/12/21 02:18:46 gilles Exp $	*/
d308 2
a309 1
				/* Session was removed while we were waiting for the message */
d314 2
a315 1

@


1.10
log
@- AUTH PLAIN may receive credentials as a parameter to AUTH or on a
	following line, this commit brings support for the latter which was
	not supported yet.
- AUTH LOGIN is now supported, allowing smtp auth support on clients that
	do not support AUTH PLAIN (ie: my mobile phone for instance ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.9 2008/12/13 23:19:34 jacekm Exp $	*/
d49 1
d182 1
a182 1
			session_auth_pickup(s, NULL);
@


1.9
log
@IMSG_* namespace cleanup.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.8 2008/12/03 17:58:00 gilles Exp $	*/
d181 1
a181 1
			session_pickup(s, NULL);
@


1.8
log
@- fix event masking issues in smtp process which could lead to a fatal() if
	queue process did not answer fast enough to an imsg. spotted by
	Jacek Masiulaniec <jacekm@@dobremiasto.net>
- queue layout was mostly to bootstrap the project, it does not behave good
	under load, it does complex things to stay in a recoverable state
	and it probably didnt do it too well. New queue code is simpler,
	smaller and allows for atomic submissions (a mail can never be in a
	state where it needs to be recovered). It still needs some work but
	works better than previous code, no regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.7 2008/11/24 22:30:19 gilles Exp $	*/
d231 2
a232 2
		case IMSG_MFA_RCPT_SUBMIT:
		case IMSG_MFA_RPATH_SUBMIT: {
d297 1
a297 1
		case IMSG_SMTP_HOSTNAME_ANSWER: {
d361 1
a361 1
		case IMSG_SMTP_MESSAGE_ID: {
d382 1
a382 1
		case IMSG_SMTP_MESSAGE_FILE: {
d413 2
a414 1
		case IMSG_SMTP_SUBMIT_ACK: {
@


1.7
log
@- not really a bug since we don't use other descriptor flags, but in
	smtp_setup_events() and mta_connect(), our fcntl() use clears
	flags. use session_socket_blockmode() instead, it makes more
	sense anyway. From Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.6 2008/11/17 21:56:18 chl Exp $	*/
d361 1
a361 1
		case IMSG_SMTP_MESSAGE_FILE: {
a364 1
			int			 fd;
d379 19
@


1.6
log
@add missing header needed by time(), ctime_r() and tzset().

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.5 2008/11/13 23:24:19 gilles Exp $	*/
d509 1
a509 2
		if (fcntl(l->fd, F_SETFL, O_NONBLOCK) == -1)
			fatal("fcntl");
@


1.5
log
@- rephrase the "cannot load cert" warning that is output at startup when a
	listen directive has no matching certificate. it sounds like a
	critical failure when it just means "no tls support".
- minor log_debug() addition in smtp.c
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.4 2008/11/11 02:14:58 tedu Exp $	*/
d34 1
@


1.4
log
@some small improvements.  ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.3 2008/11/11 01:08:08 gilles Exp $	*/
d555 1
@


1.3
log
@- queue process no longer schedules messages which do not have flag
	F_MESSAGE_COMPLETE
- submit recipients to the queue as we read them from RCPT instead of
	submiting them all at once when DATA is over. this prevents us
	from having to keep a potentially large number of recipients in
	memory during the whole session.
- remove all code that dealt with the recipients queue of a message as
	it is no longer used.
- several small changes to make sure the server is always in a recoverable
	state in case of an unexpected shutdown.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d117 2
a118 1
			if ((s->ssl_cert = malloc(s->ssl_cert_len + 1)) == NULL)
a119 4
			(void)strlcpy(s->ssl_cert,
			    (char *)imsg.data + sizeof(*s),
			    s->ssl_cert_len);

d121 2
a122 1
			if ((s->ssl_key = malloc(s->ssl_key_len + 1)) == NULL)
a123 3
			(void)strlcpy(s->ssl_key,
			    (char *)imsg.data + (sizeof(*s) + s->ssl_cert_len),
			    s->ssl_key_len);
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a413 3

			(void)strlcpy(s->s_msg.message_id, ss->u.msgid,
			    sizeof(s->s_msg.message_id));
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

