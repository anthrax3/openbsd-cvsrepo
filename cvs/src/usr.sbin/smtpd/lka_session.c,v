head	1.81;
access;
symbols
	OPENBSD_6_2_BASE:1.81
	OPENBSD_6_1:1.80.0.4
	OPENBSD_6_1_BASE:1.80
	OPENBSD_6_0:1.79.0.6
	OPENBSD_6_0_BASE:1.79
	OPENBSD_5_9:1.79.0.2
	OPENBSD_5_9_BASE:1.79
	OPENBSD_5_8:1.69.0.6
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.64.0.2
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.55.0.2
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.81
date	2017.05.26.21.30.00;	author gilles;	state Exp;
branches;
next	1.80;
commitid	495Pvi1mlO0oeSMF;

1.80
date	2016.08.31.10.18.08;	author gilles;	state Exp;
branches;
next	1.79;
commitid	jWkTljYAPNXFatSw;

1.79
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.78;
commitid	ZxnqOQqX6IeYI9jW;

1.78
date	2015.12.14.10.22.12;	author jung;	state Exp;
branches;
next	1.77;
commitid	HRAnniyhGW9Sadln;

1.77
date	2015.11.30.12.57.05;	author gilles;	state Exp;
branches;
next	1.76;
commitid	lU6CrhfYjdMExKBz;

1.76
date	2015.11.30.12.26.55;	author sunil;	state Exp;
branches;
next	1.75;
commitid	aGcPak9vEg5kOQ24;

1.75
date	2015.11.30.11.14.01;	author gilles;	state Exp;
branches;
next	1.74;
commitid	85YRUVYRe272uqdd;

1.74
date	2015.11.30.10.56.25;	author gilles;	state Exp;
branches;
next	1.73;
commitid	MkpLGQe6JAKLzC4o;

1.73
date	2015.10.28.07.43.44;	author gilles;	state Exp;
branches;
next	1.72;
commitid	CbzPUQ4z2ww0k1aB;

1.72
date	2015.10.28.07.25.30;	author gilles;	state Exp;
branches;
next	1.71;
commitid	t4n4PUOhsPwX6dRm;

1.71
date	2015.10.06.06.44.47;	author gilles;	state Exp;
branches;
next	1.70;
commitid	JVrqiqqdaDlJ5fLn;

1.70
date	2015.10.02.00.29.51;	author gilles;	state Exp;
branches;
next	1.69;
commitid	huRN7gZEbHqP7L9s;

1.69
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches
	1.69.2.1
	1.69.6.1;
next	1.68;
commitid	ZBTFreARDSMmzOIV;

1.68
date	2014.07.08.13.49.09;	author eric;	state Exp;
branches
	1.68.4.1;
next	1.67;
commitid	pEybL9fsrDOC6PJj;

1.67
date	2014.04.30.09.17.29;	author gilles;	state Exp;
branches;
next	1.66;

1.66
date	2014.04.19.12.55.23;	author gilles;	state Exp;
branches;
next	1.65;

1.65
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.64;

1.64
date	2014.02.28.16.00.11;	author eric;	state Exp;
branches;
next	1.63;

1.63
date	2014.02.04.10.38.06;	author eric;	state Exp;
branches;
next	1.62;

1.62
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.61;

1.61
date	2013.11.19.10.22.42;	author eric;	state Exp;
branches;
next	1.60;

1.60
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.59;

1.59
date	2013.10.28.09.14.58;	author eric;	state Exp;
branches;
next	1.58;

1.58
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.57;

1.57
date	2013.07.19.08.12.19;	author eric;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.55;

1.55
date	2013.02.14.12.30.49;	author gilles;	state Exp;
branches;
next	1.54;

1.54
date	2013.02.05.11.45.18;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.52;

1.52
date	2013.01.28.11.09.53;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.50;

1.50
date	2012.11.27.09.39.44;	author eric;	state Exp;
branches;
next	1.49;

1.49
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.48;

1.48
date	2012.10.16.11.10.38;	author eric;	state Exp;
branches;
next	1.47;

1.47
date	2012.10.14.13.31.46;	author chl;	state Exp;
branches;
next	1.46;

1.46
date	2012.10.13.21.38.27;	author gilles;	state Exp;
branches;
next	1.45;

1.45
date	2012.10.13.21.33.33;	author gilles;	state Exp;
branches;
next	1.44;

1.44
date	2012.10.13.08.01.47;	author eric;	state Exp;
branches;
next	1.43;

1.43
date	2012.10.11.21.14.32;	author gilles;	state Exp;
branches;
next	1.42;

1.42
date	2012.10.10.18.02.37;	author eric;	state Exp;
branches;
next	1.41;

1.41
date	2012.10.09.21.33.38;	author eric;	state Exp;
branches;
next	1.40;

1.40
date	2012.10.03.19.42.16;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2012.10.03.18.09.18;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2012.09.30.14.28.16;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2012.09.29.10.35.01;	author eric;	state Exp;
branches;
next	1.36;

1.36
date	2012.09.27.18.57.25;	author eric;	state Exp;
branches;
next	1.35;

1.35
date	2012.09.26.19.52.20;	author eric;	state Exp;
branches;
next	1.34;

1.34
date	2012.09.24.08.56.12;	author eric;	state Exp;
branches;
next	1.33;

1.33
date	2012.09.21.19.37.08;	author eric;	state Exp;
branches;
next	1.32;

1.32
date	2012.09.21.16.40.20;	author eric;	state Exp;
branches;
next	1.31;

1.31
date	2012.09.21.13.23.07;	author eric;	state Exp;
branches;
next	1.30;

1.30
date	2012.09.21.10.22.29;	author eric;	state Exp;
branches;
next	1.29;

1.29
date	2012.09.19.10.10.30;	author eric;	state Exp;
branches;
next	1.28;

1.28
date	2012.09.19.09.06.35;	author eric;	state Exp;
branches;
next	1.27;

1.27
date	2012.09.18.15.35.13;	author eric;	state Exp;
branches;
next	1.26;

1.26
date	2012.09.18.14.23.01;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2012.09.18.13.42.39;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2012.09.18.12.13.22;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.17.18.44.57;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2012.08.21.20.19.46;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.20;

1.20
date	2012.08.09.09.48.02;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2012.07.29.17.21.43;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2012.07.29.16.33.01;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2012.07.12.08.51.43;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2011.12.13.22.04.35;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2011.12.13.21.44.47;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2011.12.12.16.45.16;	author chl;	state Exp;
branches;
next	1.13;

1.13
date	2011.12.08.17.00.28;	author todd;	state Exp;
branches;
next	1.12;

1.12
date	2011.10.25.10.25.51;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2011.10.22.18.03.27;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2011.08.27.22.32.41;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.04.19.44.31;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.09.17.41.52;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.21.18.11.40;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.21.18.04.51;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.17.18.54.32;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.16.21.52.53;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.16.21.42.03;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.16.21.05.51;	author gilles;	state Exp;
branches;
next	;

1.68.4.1
date	2015.10.02.01.33.33;	author gilles;	state Exp;
branches;
next	;
commitid	2Q56YgF5PzqMcagu;

1.69.2.1
date	2015.10.02.01.28.43;	author gilles;	state Exp;
branches;
next	;
commitid	pAamrt3DJscJjb10;

1.69.6.1
date	2015.10.02.00.55.02;	author gilles;	state Exp;
branches;
next	;
commitid	5SntIHNUPMG4dcQ1;


desc
@@


1.81
log
@move variables expansion out of lka_session into their own file, this is a
mechanical diff to simplify a bit the lka code and prepare for moving
variables outside of the lookup process into the chrooted mda process.
no functional change for now.

ok eric@@
@
text
@/*	$OpenBSD: lka_session.c,v 1.80 2016/08/31 10:18:08 gilles Exp $	*/

/*
 * Copyright (c) 2011 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <resolv.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "smtpd.h"
#include "log.h"

#define	EXPAND_DEPTH	10

#define	F_WAITING	0x01

struct lka_session {
	uint64_t		 id; /* given by smtp */

	TAILQ_HEAD(, envelope)	 deliverylist;
	struct expand		 expand;

	int			 flags;
	int			 error;
	const char		*errormsg;
	struct envelope		 envelope;
	struct xnodes		 nodes;
	/* waiting for fwdrq */
	struct rule		*rule;
	struct expandnode	*node;
};

static void lka_expand(struct lka_session *, struct rule *,
    struct expandnode *);
static void lka_submit(struct lka_session *, struct rule *,
    struct expandnode *);
static void lka_resume(struct lka_session *);

static int		init;
static struct tree	sessions;

void
lka_session(uint64_t id, struct envelope *envelope)
{
	struct lka_session	*lks;
	struct expandnode	 xn;

	if (init == 0) {
		init = 1;
		tree_init(&sessions);
	}

	lks = xcalloc(1, sizeof(*lks), "lka_session");
	lks->id = id;
	RB_INIT(&lks->expand.tree);
	TAILQ_INIT(&lks->deliverylist);
	tree_xset(&sessions, lks->id, lks);

	lks->envelope = *envelope;

	TAILQ_INIT(&lks->nodes);
	memset(&xn, 0, sizeof xn);
	xn.type = EXPAND_ADDRESS;
	xn.u.mailaddr = lks->envelope.rcpt;
	lks->expand.rule = NULL;
	lks->expand.queue = &lks->nodes;
	expand_insert(&lks->expand, &xn);
	lka_resume(lks);
}

void
lka_session_forward_reply(struct forward_req *fwreq, int fd)
{
	struct lka_session     *lks;
	struct rule	       *rule;
	struct expandnode      *xn;
	int			ret;

	lks = tree_xget(&sessions, fwreq->id);
	xn = lks->node;
	rule = lks->rule;

	lks->flags &= ~F_WAITING;

	switch (fwreq->status) {
	case 0:
		/* permanent failure while lookup ~/.forward */
		log_trace(TRACE_EXPAND, "expand: ~/.forward failed for user %s",
		    fwreq->user);
		lks->error = LKA_PERMFAIL;
		break;
	case 1:
		if (fd == -1) {
			if (lks->expand.rule->r_forwardonly) {
				log_trace(TRACE_EXPAND, "expand: no .forward "
				    "for user %s on forward-only rule", fwreq->user);
				lks->error = LKA_TEMPFAIL;
			}
			else if (lks->expand.rule->r_action == A_NONE) {
				log_trace(TRACE_EXPAND, "expand: no .forward "
				    "for user %s and no default action on rule", fwreq->user);
				lks->error = LKA_PERMFAIL;
			}
			else {
				log_trace(TRACE_EXPAND, "expand: no .forward for "
				    "user %s, just deliver", fwreq->user);
				lka_submit(lks, rule, xn);
			}
		}
		else {
			/* expand for the current user and rule */
			lks->expand.rule = rule;
			lks->expand.parent = xn;
			lks->expand.alias = 0;
			xn->mapping = rule->r_mapping;
			xn->userbase = rule->r_userbase;
			/* forwards_get() will close the descriptor no matter what */
			ret = forwards_get(fd, &lks->expand);
			if (ret == -1) {
				log_trace(TRACE_EXPAND, "expand: temporary "
				    "forward error for user %s", fwreq->user);
				lks->error = LKA_TEMPFAIL;
			}
			else if (ret == 0) {
				if (lks->expand.rule->r_forwardonly) {
					log_trace(TRACE_EXPAND, "expand: empty .forward "
					    "for user %s on forward-only rule", fwreq->user);
					lks->error = LKA_TEMPFAIL;
				}
				else if (lks->expand.rule->r_action == A_NONE) {
					log_trace(TRACE_EXPAND, "expand: empty .forward "
					    "for user %s and no default action on rule", fwreq->user);
					lks->error = LKA_PERMFAIL;
				}
				else {
					log_trace(TRACE_EXPAND, "expand: empty .forward "
					    "for user %s, just deliver", fwreq->user);
					lka_submit(lks, rule, xn);
				}
			}
		}
		break;
	default:
		/* temporary failure while looking up ~/.forward */
		lks->error = LKA_TEMPFAIL;
	}

	lka_resume(lks);
}

static void
lka_resume(struct lka_session *lks)
{
	struct envelope		*ep;
	struct expandnode	*xn;

	if (lks->error)
		goto error;

	/* pop next node and expand it */
	while ((xn = TAILQ_FIRST(&lks->nodes))) {
		TAILQ_REMOVE(&lks->nodes, xn, tq_entry);
		lka_expand(lks, xn->rule, xn);
		if (lks->flags & F_WAITING)
			return;
		if (lks->error)
			goto error;
	}

	/* delivery list is empty, reject */
	if (TAILQ_FIRST(&lks->deliverylist) == NULL) {
		log_trace(TRACE_EXPAND, "expand: lka_done: expanded to empty "
		    "delivery list");
		lks->error = LKA_PERMFAIL;
	}
    error:
	if (lks->error) {
		m_create(p_pony, IMSG_SMTP_EXPAND_RCPT, 0, 0, -1);
		m_add_id(p_pony, lks->id);
		m_add_int(p_pony, lks->error);

		if (lks->errormsg)
			m_add_string(p_pony, lks->errormsg);
		else {
			if (lks->error == LKA_PERMFAIL)
				m_add_string(p_pony, "550 Invalid recipient");
			else if (lks->error == LKA_TEMPFAIL)
				m_add_string(p_pony, "451 Temporary failure");
		}

		m_close(p_pony);
		while ((ep = TAILQ_FIRST(&lks->deliverylist)) != NULL) {
			TAILQ_REMOVE(&lks->deliverylist, ep, entry);
			free(ep);
		}
	}
	else {
		/* Process the delivery list and submit envelopes to queue */
		while ((ep = TAILQ_FIRST(&lks->deliverylist)) != NULL) {
			TAILQ_REMOVE(&lks->deliverylist, ep, entry);
			m_create(p_queue, IMSG_LKA_ENVELOPE_SUBMIT, 0, 0, -1);
			m_add_id(p_queue, lks->id);
			m_add_envelope(p_queue, ep);
			m_close(p_queue);
			free(ep);
		}

		m_create(p_queue, IMSG_LKA_ENVELOPE_COMMIT, 0, 0, -1);
		m_add_id(p_queue, lks->id);
		m_close(p_queue);
	}

	expand_clear(&lks->expand);
	tree_xpop(&sessions, lks->id);
	free(lks);
}

static void
lka_expand(struct lka_session *lks, struct rule *rule, struct expandnode *xn)
{
	struct forward_req	fwreq;
	struct envelope		ep;
	struct expandnode	node;
	struct mailaddr		maddr;
	int			r;
	union lookup		lk;
	char		       *tag;
	
	if (xn->depth >= EXPAND_DEPTH) {
		log_trace(TRACE_EXPAND, "expand: lka_expand: node too deep.");
		lks->error = LKA_PERMFAIL;
		return;
	}

	switch (xn->type) {
	case EXPAND_INVALID:
	case EXPAND_INCLUDE:
		fatalx("lka_expand: unexpected type");
		break;

	case EXPAND_ADDRESS:

		log_trace(TRACE_EXPAND, "expand: lka_expand: address: %s@@%s "
		    "[depth=%d]",
		    xn->u.mailaddr.user, xn->u.mailaddr.domain, xn->depth);

		/* Pass the node through the ruleset */
		ep = lks->envelope;
		ep.dest = xn->u.mailaddr;
		if (xn->parent) /* nodes with parent are forward addresses */
			ep.flags |= EF_INTERNAL;
		rule = ruleset_match(&ep);
		if (rule == NULL || rule->r_decision == R_REJECT) {
			lks->error = (errno == EAGAIN) ?
			    LKA_TEMPFAIL : LKA_PERMFAIL;
			break;
		}

		xn->mapping = rule->r_mapping;
		xn->userbase = rule->r_userbase;

		if (rule->r_action == A_RELAY || rule->r_action == A_RELAYVIA) {
			lka_submit(lks, rule, xn);
		}
		else if (rule->r_desttype == DEST_VDOM) {
			/* expand */
			lks->expand.rule = rule;
			lks->expand.parent = xn;
			lks->expand.alias = 1;

			/* temporary replace the mailaddr with a copy where
			 * we eventually strip the '+'-part before lookup.
			 */
			maddr = xn->u.mailaddr;
			xlowercase(maddr.user, xn->u.mailaddr.user,
			    sizeof maddr.user);
			r = aliases_virtual_get(&lks->expand, &maddr);
			if (r == -1) {
				lks->error = LKA_TEMPFAIL;
				log_trace(TRACE_EXPAND, "expand: lka_expand: "
				    "error in virtual alias lookup");
			}
			else if (r == 0) {
				lks->error = LKA_PERMFAIL;
				log_trace(TRACE_EXPAND, "expand: lka_expand: "
				    "no aliases for virtual");
			}
		}
		else {
			lks->expand.rule = rule;
			lks->expand.parent = xn;
			lks->expand.alias = 1;
			memset(&node, 0, sizeof node);
			node.type = EXPAND_USERNAME;
			xlowercase(node.u.user, xn->u.mailaddr.user,
			    sizeof node.u.user);
			node.mapping = rule->r_mapping;
			node.userbase = rule->r_userbase;
			expand_insert(&lks->expand, &node);
		}
		break;

	case EXPAND_USERNAME:
		log_trace(TRACE_EXPAND, "expand: lka_expand: username: %s "
		    "[depth=%d]", xn->u.user, xn->depth);

		if (xn->sameuser) {
			log_trace(TRACE_EXPAND, "expand: lka_expand: same "
			    "user, submitting");
			lka_submit(lks, rule, xn);
			break;
		}

		/* expand aliases with the given rule */
		lks->expand.rule = rule;
		lks->expand.parent = xn;
		lks->expand.alias = 1;
		xn->mapping = rule->r_mapping;
		xn->userbase = rule->r_userbase;
		if (rule->r_mapping) {
			r = aliases_get(&lks->expand, xn->u.user);
			if (r == -1) {
				log_trace(TRACE_EXPAND, "expand: lka_expand: "
				    "error in alias lookup");
				lks->error = LKA_TEMPFAIL;
			}
			if (r)
				break;
		}

		/* gilles+hackers@@ -> gilles@@ */
		if ((tag = strchr(xn->u.user, *env->sc_subaddressing_delim)) != NULL)
			*tag++ = '\0';

		r = table_lookup(rule->r_userbase, NULL, xn->u.user, K_USERINFO, &lk);
		if (r == -1) {
			log_trace(TRACE_EXPAND, "expand: lka_expand: "
			    "backend error while searching user");
			lks->error = LKA_TEMPFAIL;
			break;
		}
		if (r == 0) {
			log_trace(TRACE_EXPAND, "expand: lka_expand: "
			    "user-part does not match system user");
			lks->error = LKA_PERMFAIL;
			break;
		}

		/* no aliases found, query forward file */
		lks->rule = rule;
		lks->node = xn;

		memset(&fwreq, 0, sizeof(fwreq));
		fwreq.id = lks->id;
		(void)strlcpy(fwreq.user, lk.userinfo.username, sizeof(fwreq.user));
		(void)strlcpy(fwreq.directory, lk.userinfo.directory, sizeof(fwreq.directory));
		fwreq.uid = lk.userinfo.uid;
		fwreq.gid = lk.userinfo.gid;

		m_compose(p_parent, IMSG_LKA_OPEN_FORWARD, 0, 0, -1,
		    &fwreq, sizeof(fwreq));
		lks->flags |= F_WAITING;
		break;

	case EXPAND_FILENAME:
		if (rule->r_forwardonly) {
			log_trace(TRACE_EXPAND, "expand: filename matched on forward-only rule");
			lks->error = LKA_TEMPFAIL;
			break;
		}
		log_trace(TRACE_EXPAND, "expand: lka_expand: filename: %s "
		    "[depth=%d]", xn->u.buffer, xn->depth);
		lka_submit(lks, rule, xn);
		break;

	case EXPAND_ERROR:
		if (rule->r_forwardonly) {
			log_trace(TRACE_EXPAND, "expand: error matched on forward-only rule");
			lks->error = LKA_TEMPFAIL;
			break;
		}
		log_trace(TRACE_EXPAND, "expand: lka_expand: error: %s "
		    "[depth=%d]", xn->u.buffer, xn->depth);
		if (xn->u.buffer[0] == '4')
			lks->error = LKA_TEMPFAIL;
		else if (xn->u.buffer[0] == '5')
			lks->error = LKA_PERMFAIL;
		lks->errormsg = xn->u.buffer;
		break;

	case EXPAND_FILTER:
		if (rule->r_forwardonly) {
			log_trace(TRACE_EXPAND, "expand: filter matched on forward-only rule");
			lks->error = LKA_TEMPFAIL;
			break;
		}
		log_trace(TRACE_EXPAND, "expand: lka_expand: filter: %s "
		    "[depth=%d]", xn->u.buffer, xn->depth);
		lka_submit(lks, rule, xn);
		break;

	case EXPAND_MAILDIR:
		log_trace(TRACE_EXPAND, "expand: lka_expand: maildir: %s "
		    "[depth=%d]", xn->u.buffer, xn->depth);
		r = table_lookup(rule->r_userbase, NULL,
		    xn->parent->u.user, K_USERINFO, &lk);
		if (r == -1) {
			log_trace(TRACE_EXPAND, "expand: lka_expand: maildir: "
			    "backend error while searching user");
			lks->error = LKA_TEMPFAIL;
			break;
		}
		if (r == 0) {
			log_trace(TRACE_EXPAND, "expand: lka_expand: maildir: "
			    "user-part does not match system user");
			lks->error = LKA_PERMFAIL;
			break;
		}

		lka_submit(lks, rule, xn);
		break;
	}
}

static struct expandnode *
lka_find_ancestor(struct expandnode *xn, enum expand_type type)
{
	while (xn && (xn->type != type))
		xn = xn->parent;
	if (xn == NULL) {
		log_warnx("warn: lka_find_ancestor: no ancestors of type %d",
		    type);
		fatalx(NULL);
	}
	return (xn);
}

static void
lka_submit(struct lka_session *lks, struct rule *rule, struct expandnode *xn)
{
	union lookup		 lk;
	struct envelope		*ep;
	struct expandnode	*xn2;
	int			 r;

	ep = xmemdup(&lks->envelope, sizeof *ep, "lka_submit");
	ep->expire = rule->r_qexpire;

	switch (rule->r_action) {
	case A_RELAY:
	case A_RELAYVIA:
		if (xn->type != EXPAND_ADDRESS)
			fatalx("lka_deliver: expect address");
		ep->type = D_MTA;
		ep->dest = xn->u.mailaddr;
		ep->agent.mta.relay = rule->r_value.relayhost;

		/* only rewrite if not a bounce */
		if (ep->sender.user[0] && rule->r_as && rule->r_as->user[0])
			(void)strlcpy(ep->sender.user, rule->r_as->user,
			    sizeof ep->sender.user);
		if (ep->sender.user[0] && rule->r_as && rule->r_as->domain[0])
			(void)strlcpy(ep->sender.domain, rule->r_as->domain,
			    sizeof ep->sender.domain);
		break;
	case A_NONE:
	case A_MBOX:
	case A_MAILDIR:
	case A_FILENAME:
	case A_MDA:
	case A_LMTP:
		ep->type = D_MDA;
		ep->dest = lka_find_ancestor(xn, EXPAND_ADDRESS)->u.mailaddr;

		/* set username */
		if ((xn->type == EXPAND_FILTER || xn->type == EXPAND_FILENAME)
		    && xn->alias) {
			(void)strlcpy(ep->agent.mda.username, SMTPD_USER,
			    sizeof(ep->agent.mda.username));
		}
		else {
			xn2 = lka_find_ancestor(xn, EXPAND_USERNAME);
			(void)strlcpy(ep->agent.mda.username, xn2->u.user,
			    sizeof(ep->agent.mda.username));
		}

		r = table_lookup(rule->r_userbase, NULL, ep->agent.mda.username,
		    K_USERINFO, &lk);
		if (r <= 0) {
			lks->error = (r == -1) ? LKA_TEMPFAIL : LKA_PERMFAIL;
			free(ep);
			return;
		}
		(void)strlcpy(ep->agent.mda.usertable, rule->r_userbase->t_name,
		    sizeof ep->agent.mda.usertable);
		(void)strlcpy(ep->agent.mda.username, lk.userinfo.username,
		    sizeof ep->agent.mda.username);
		strlcpy(ep->agent.mda.delivery_user, rule->r_delivery_user,
		    sizeof ep->agent.mda.delivery_user);

		if (xn->type == EXPAND_FILENAME) {
			ep->agent.mda.method = A_FILENAME;
			(void)strlcpy(ep->agent.mda.buffer, xn->u.buffer,
			    sizeof ep->agent.mda.buffer);
		}
		else if (xn->type == EXPAND_FILTER) {
			ep->agent.mda.method = A_MDA;
			(void)strlcpy(ep->agent.mda.buffer, xn->u.buffer,
			    sizeof ep->agent.mda.buffer);
		}
		else if (xn->type == EXPAND_USERNAME) {
			ep->agent.mda.method = rule->r_action;
			(void)strlcpy(ep->agent.mda.buffer, rule->r_value.buffer,
			    sizeof ep->agent.mda.buffer);
		}
		else if (xn->type == EXPAND_MAILDIR) {
			ep->agent.mda.method = A_MAILDIR;
			(void)strlcpy(ep->agent.mda.buffer, xn->u.buffer,
			    sizeof ep->agent.mda.buffer);
		}
		else
			fatalx("lka_deliver: bad node type");

		r = mda_expand_format(ep->agent.mda.buffer,
		    sizeof(ep->agent.mda.buffer), ep, &lk.userinfo);
		if (!r) {
			lks->error = LKA_TEMPFAIL;
			log_warnx("warn: format string error while"
			    " expanding for user %s", ep->agent.mda.username);
			free(ep);
			return;
		}
		break;
	default:
		fatalx("lka_submit: bad rule action");
	}

	TAILQ_INSERT_TAIL(&lks->deliverylist, ep, entry);
}
@


1.80
log
@allow overriding the subaddressing delimiter with subaddressing-delimiter
keyword, the default is still +

ok eric@@, sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.79 2015/12/28 22:08:30 jung Exp $	*/
a68 16
static size_t lka_expand_format(char *, size_t, const struct envelope *,
    const struct userinfo *);

static int mod_lowercase(char *, size_t);
static int mod_uppercase(char *, size_t);
static int mod_strip(char *, size_t);

struct modifiers {
	char	*name;
	int	(*f)(char *buf, size_t len);
} token_modifiers[] = {
	{ "lowercase",	mod_lowercase },
	{ "uppercase",	mod_uppercase },
	{ "strip",	mod_strip },
	{ "raw",	NULL },		/* special case, must stay last */
};
a72 2
#define	MAXTOKENLEN	128

d555 1
a555 1
		r = lka_expand_format(ep->agent.mda.buffer,
a569 298
}


static size_t
lka_expand_token(char *dest, size_t len, const char *token,
    const struct envelope *ep, const struct userinfo *ui)
{
	char		rtoken[MAXTOKENLEN];
	char		tmp[EXPAND_BUFFER];
	const char     *string;
	char	       *lbracket, *rbracket, *content, *sep, *mods;
	ssize_t		i;
	ssize_t		begoff, endoff;
	const char     *errstr = NULL;
	int		replace = 1;
	int		raw = 0;

	begoff = 0;
	endoff = EXPAND_BUFFER;
	mods = NULL;

	if (strlcpy(rtoken, token, sizeof rtoken) >= sizeof rtoken)
		return 0;

	/* token[x[:y]] -> extracts optional x and y, converts into offsets */
	if ((lbracket = strchr(rtoken, '[')) &&
	    (rbracket = strchr(rtoken, ']'))) {
		/* ] before [ ... or empty */
		if (rbracket < lbracket || rbracket - lbracket <= 1)
			return 0;

		*lbracket = *rbracket = '\0';
		 content  = lbracket + 1;

		 if ((sep = strchr(content, ':')) == NULL)
			 endoff = begoff = strtonum(content, -EXPAND_BUFFER,
			     EXPAND_BUFFER, &errstr);
		 else {
			 *sep = '\0';
			 if (content != sep)
				 begoff = strtonum(content, -EXPAND_BUFFER,
				     EXPAND_BUFFER, &errstr);
			 if (*(++sep)) {
				 if (errstr == NULL)
					 endoff = strtonum(sep, -EXPAND_BUFFER,
					     EXPAND_BUFFER, &errstr);
			 }
		 }
		 if (errstr)
			 return 0;

		 /* token:mod_1,mod_2,mod_n -> extract modifiers */
		 mods = strchr(rbracket + 1, ':');
	} else {
		if ((mods = strchr(rtoken, ':')) != NULL)
			*mods++ = '\0';
	}

	/* token -> expanded token */
	if (!strcasecmp("sender", rtoken)) {
		if (snprintf(tmp, sizeof tmp, "%s@@%s",
			ep->sender.user, ep->sender.domain) >= (int)sizeof tmp)
			return 0;
		string = tmp;
	}
	else if (!strcasecmp("dest", rtoken)) {
		if (snprintf(tmp, sizeof tmp, "%s@@%s",
			ep->dest.user, ep->dest.domain) >= (int)sizeof tmp)
			return 0;
		string = tmp;
	}
	else if (!strcasecmp("rcpt", rtoken)) {
		if (snprintf(tmp, sizeof tmp, "%s@@%s",
			ep->rcpt.user, ep->rcpt.domain) >= (int)sizeof tmp)
			return 0;
		string = tmp;
	}
	else if (!strcasecmp("sender.user", rtoken))
		string = ep->sender.user;
	else if (!strcasecmp("sender.domain", rtoken))
		string = ep->sender.domain;
	else if (!strcasecmp("user.username", rtoken))
		string = ui->username;
	else if (!strcasecmp("user.directory", rtoken)) {
		string = ui->directory;
		replace = 0;
	}
	else if (!strcasecmp("dest.user", rtoken))
		string = ep->dest.user;
	else if (!strcasecmp("dest.domain", rtoken))
		string = ep->dest.domain;
	else if (!strcasecmp("rcpt.user", rtoken))
		string = ep->rcpt.user;
	else if (!strcasecmp("rcpt.domain", rtoken))
		string = ep->rcpt.domain;
	else
		return 0;

	if (string != tmp) {
		if (strlcpy(tmp, string, sizeof tmp) >= sizeof tmp)
			return 0;
		string = tmp;
	}

	/*  apply modifiers */
	if (mods != NULL) {
		do {
			if ((sep = strchr(mods, '|')) != NULL)
				*sep++ = '\0';
			for (i = 0; (size_t)i < nitems(token_modifiers); ++i) {
				if (!strcasecmp(token_modifiers[i].name, mods)) {
					if (token_modifiers[i].f == NULL) {
						raw = 1;
						break;
					}
					if (!token_modifiers[i].f(tmp, sizeof tmp))
						return 0; /* modifier error */
					break;
				}
			}
			if ((size_t)i == nitems(token_modifiers))
				return 0; /* modifier not found */
		} while ((mods = sep) != NULL);
	}

	if (!raw && replace)
		for (i = 0; (size_t)i < strlen(tmp); ++i)
			if (strchr(MAILADDR_ESCAPE, tmp[i]))
				tmp[i] = ':';

	/* expanded string is empty */
	i = strlen(string);
	if (i == 0)
		return 0;

	/* begin offset beyond end of string */
	if (begoff >= i)
		return 0;

	/* end offset beyond end of string, make it end of string */
	if (endoff >= i)
		endoff = i - 1;

	/* negative begin offset, make it relative to end of string */
	if (begoff < 0)
		begoff += i;
	/* negative end offset, make it relative to end of string,
	 * note that end offset is inclusive.
	 */
	if (endoff < 0)
		endoff += i - 1;

	/* check that final offsets are valid */
	if (begoff < 0 || endoff < 0 || endoff < begoff)
		return 0;
	endoff += 1; /* end offset is inclusive */

	/* check that substring does not exceed destination buffer length */
	i = endoff - begoff;
	if ((size_t)i + 1 >= len)
		return 0;

	string += begoff;
	for (; i; i--) {
		*dest = (replace && *string == '/') ? ':' : *string;
		dest++;
		string++;
	}

	return endoff - begoff;
}


static size_t
lka_expand_format(char *buf, size_t len, const struct envelope *ep,
    const struct userinfo *ui)
{
	char		tmpbuf[EXPAND_BUFFER], *ptmp, *pbuf, *ebuf;
	char		exptok[EXPAND_BUFFER];
	size_t		exptoklen;
	char		token[MAXTOKENLEN];
	size_t		ret, tmpret;

	if (len < sizeof tmpbuf) {
		log_warnx("lka_expand_format: tmp buffer < rule buffer");
		return 0;
	}

	memset(tmpbuf, 0, sizeof tmpbuf);
	pbuf = buf;
	ptmp = tmpbuf;
	ret = tmpret = 0;

	/* special case: ~/ only allowed expanded at the beginning */
	if (strncmp(pbuf, "~/", 2) == 0) {
		tmpret = snprintf(ptmp, sizeof tmpbuf, "%s/", ui->directory);
		if (tmpret >= sizeof tmpbuf) {
			log_warnx("warn: user directory for %s too large",
			    ui->directory);
			return 0;
		}
		ret  += tmpret;
		ptmp += tmpret;
		pbuf += 2;
	}


	/* expansion loop */
	for (; *pbuf && ret < sizeof tmpbuf; ret += tmpret) {
		if (*pbuf == '%' && *(pbuf + 1) == '%') {
			*ptmp++ = *pbuf++;
			pbuf  += 1;
			tmpret = 1;
			continue;
		}

		if (*pbuf != '%' || *(pbuf + 1) != '{') {
			*ptmp++ = *pbuf++;
			tmpret = 1;
			continue;
		}

		/* %{...} otherwise fail */
		if (*(pbuf+1) != '{' || (ebuf = strchr(pbuf+1, '}')) == NULL)
			return 0;

		/* extract token from %{token} */
		if ((size_t)(ebuf - pbuf) - 1 >= sizeof token)
			return 0;

		memcpy(token, pbuf+2, ebuf-pbuf-1);
		if (strchr(token, '}') == NULL)
			return 0;
		*strchr(token, '}') = '\0';

		exptoklen = lka_expand_token(exptok, sizeof exptok, token, ep,
		    ui);
		if (exptoklen == 0)
			return 0;

		/* writing expanded token at ptmp will overflow tmpbuf */
		if (sizeof (tmpbuf) - (ptmp - tmpbuf) <= exptoklen)
			return 0;

		memcpy(ptmp, exptok, exptoklen);
		pbuf   = ebuf + 1;
		ptmp  += exptoklen;
		tmpret = exptoklen;
	}
	if (ret >= sizeof tmpbuf)
		return 0;

	if ((ret = strlcpy(buf, tmpbuf, len)) >= len)
		return 0;

	return ret;
}

static int
mod_lowercase(char *buf, size_t len)
{
	char tmp[EXPAND_BUFFER];

	if (!lowercase(tmp, buf, sizeof tmp))
		return 0;
	if (strlcpy(buf, tmp, len) >= len)
		return 0;
	return 1;
}

static int
mod_uppercase(char *buf, size_t len)
{
	char tmp[EXPAND_BUFFER];

	if (!uppercase(tmp, buf, sizeof tmp))
		return 0;
	if (strlcpy(buf, tmp, len) >= len)
		return 0;
	return 1;
}

static int
mod_strip(char *buf, size_t len)
{
	char *tag, *at;
	unsigned int i;

	/* gilles+hackers -> gilles */
	if ((tag = strchr(buf, *env->sc_subaddressing_delim)) != NULL) {
		/* gilles+hackers@@poolp.org -> gilles@@poolp.org */
		if ((at = strchr(tag, '@@')) != NULL) {
			for (i = 0; i <= strlen(at); ++i)
				tag[i] = at[i];
		} else
			*tag = '\0';
	}
	return 1;
@


1.79
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.78 2015/12/14 10:22:12 jung Exp $	*/
d277 1
a277 1

d381 1
a381 1
		if ((tag = strchr(xn->u.user, TAG_CHAR)) != NULL)
d877 1
a877 1
	if ((tag = strchr(buf, TAG_CHAR)) != NULL) {
@


1.78
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.77 2015/11/30 12:57:05 gilles Exp $	*/
d647 1
a647 1
	if (! strcasecmp("sender", rtoken)) {
d653 1
a653 1
	else if (! strcasecmp("dest", rtoken)) {
d659 1
a659 1
	else if (! strcasecmp("rcpt", rtoken)) {
d665 1
a665 1
	else if (! strcasecmp("sender.user", rtoken))
d667 1
a667 1
	else if (! strcasecmp("sender.domain", rtoken))
d669 1
a669 1
	else if (! strcasecmp("user.username", rtoken))
d671 1
a671 1
	else if (! strcasecmp("user.directory", rtoken)) {
d675 1
a675 1
	else if (! strcasecmp("dest.user", rtoken))
d677 1
a677 1
	else if (! strcasecmp("dest.domain", rtoken))
d679 1
a679 1
	else if (! strcasecmp("rcpt.user", rtoken))
d681 1
a681 1
	else if (! strcasecmp("rcpt.domain", rtoken))
d698 1
a698 1
				if (! strcasecmp(token_modifiers[i].name, mods)) {
d703 1
a703 1
					if (! token_modifiers[i].f(tmp, sizeof tmp))
d713 1
a713 1
	if (! raw && replace)
d851 1
a851 1
	if (! lowercase(tmp, buf, sizeof tmp))
d863 1
a863 1
	if (! uppercase(tmp, buf, sizeof tmp))
@


1.77
log
@replace a fatalx() with a graceful failure
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.76 2015/11/30 12:26:55 sunil Exp $	*/
d712 1
a712 1
	
d846 1
a846 1
static int 
d858 1
a858 1
static int 
@


1.76
log
@While delivering to lmtp or mda, accept optional "as user" parameter
whose privileges would be used instead of the default.

Ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.75 2015/11/30 11:14:01 gilles Exp $	*/
d771 4
a774 2
	if (len < sizeof tmpbuf)
		fatalx("lka_expand_format: tmp buffer < rule buffer");
@


1.75
log
@remove mailaddr_to_username(), no longer needed

suggested by jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.74 2015/11/30 10:56:25 gilles Exp $	*/
d547 2
@


1.74
log
@teach aliases expansion how to deal with user+tag

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.73 2015/10/28 07:43:44 gilles Exp $	*/
a70 1
static void mailaddr_to_username(const struct mailaddr *, char *, size_t);
d324 1
a324 1
			mailaddr_to_username(&xn->u.mailaddr, maddr.user,
a325 1

d344 2
a345 2
			mailaddr_to_username(&xn->u.mailaddr, node.u.user,
				sizeof node.u.user);
a839 6
}

static void
mailaddr_to_username(const struct mailaddr *maddr, char *dst, size_t len)
{
	xlowercase(dst, maddr->user, len);
@


1.73
log
@remove old check on username length that simply makes no sense nowadays

ok millert@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.72 2015/10/28 07:25:30 gilles Exp $	*/
d277 1
d382 4
a846 2
	char	*tag;

a847 4

	/* gilles+hackers@@ -> gilles@@ */
	if ((tag = strchr(dst, TAG_CHAR)) != NULL)
		*tag++ = '\0';
@


1.72
log
@aliases support resolving to maildir:/path

ok sunil@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.71 2015/10/06 06:44:47 gilles Exp $	*/
a378 8
		}

		/* A username should not exceed the size of a system user */
		if (strlen(xn->u.user) >= sizeof fwreq.user) {
			log_trace(TRACE_EXPAND, "expand: lka_expand: "
			    "user-part too long to be a system user");
			lks->error = LKA_PERMFAIL;
			break;
@


1.71
log
@fix snprintf() error checking in token expansion code, these can't possibly
fail but it's no excuse for getting the checks wrong.

spotted by qualys
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.70 2015/10/02 00:29:51 gilles Exp $	*/
d455 21
d566 5
@


1.70
log
@fix a stack-based buffer overflow in the token expansion code of the lookup
process (unprivileged), allowing a local user to crash the server or
potentially execute arbitrary code.

reported by Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.69 2015/01/20 17:37:54 deraadt Exp $	*/
d626 1
a626 1
			ep->sender.user, ep->sender.domain) <= 0)
d632 1
a632 1
			ep->dest.user, ep->dest.domain) <= 0)
d638 1
a638 1
			ep->rcpt.user, ep->rcpt.domain) <= 0)
@


1.69
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.68 2014/07/08 13:49:09 eric Exp $	*/
d801 4
@


1.69.2.1
log
@Errata 017:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.69 2015/01/20 17:37:54 deraadt Exp $	*/
a800 4
			return 0;

		/* writing expanded token at ptmp will overflow tmpbuf */
		if (sizeof (tmpbuf) - (ptmp - tmpbuf) <= exptoklen)
@


1.69.6.1
log
@Errata 004:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.69 2015/01/20 17:37:54 deraadt Exp $	*/
a800 4
			return 0;

		/* writing expanded token at ptmp will overflow tmpbuf */
		if (sizeof (tmpbuf) - (ptmp - tmpbuf) <= exptoklen)
@


1.68
log
@Update the table API: lookup functions can take an optional parameters
dictionnary (currently not set). While there, add a helper for forking
external backends, and remove unused table functions.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.66 2014/04/19 12:55:23 gilles Exp $	*/
d39 1
@


1.68.4.1
log
@Errata 031:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.68 2014/07/08 13:49:09 eric Exp $	*/
a799 4
			return 0;

		/* writing expanded token at ptmp will overflow tmpbuf */
		if (sizeof (tmpbuf) - (ptmp - tmpbuf) <= exptoklen)
@


1.67
log
@when using maildir, do not create automatically create folders to match tag
in email address (ie: gilles+tag => ~/Maildir/.tag), instead use the folder
if it already exists and deliver to the mail Maildir otherwise.

ok eric@@ and chl@@
@
text
@d388 1
a388 1
		r = table_lookup(rule->r_userbase, xn->u.user, K_USERINFO, &lk);
d519 1
a519 1
		r = table_lookup(rule->r_userbase, ep->agent.mda.username,
@


1.66
log
@when receiving mail for user+tag@@ and maildir is setup, we create a .tag
subdirectory in the maildir, add missing check to strlcat() so that if path
with .tag exceeds SMTPD_MAXPATHLEN we fail instead of creating a .tag dir
that's truncated.

(void) cast strlcpy()/strlcat() that cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.65 2014/04/04 16:10:42 eric Exp $	*/
a42 2
#define TAG_CHAR	'+'	/* gilles+tag@@ */

a70 1
static int mailaddr_tag(const struct mailaddr *, char *, size_t);
a84 2
static const char	*unsafe = MAILADDR_ESCAPE;

a476 1
	char			 tag[EXPAND_BUFFER];
a544 18

			memset(tag, 0, sizeof tag);
			if (! mailaddr_tag(&ep->dest, tag, sizeof tag)) {
				lks->error = LKA_PERMFAIL;
				free(ep);
				return;
			}
			if (rule->r_action == A_MAILDIR && tag[0]) {
				(void)strlcat(ep->agent.mda.buffer, "/.",
				    sizeof(ep->agent.mda.buffer));
				if (strlcat(ep->agent.mda.buffer, tag,
					sizeof(ep->agent.mda.buffer))
				    >= sizeof(ep->agent.mda.buffer)) {
					lks->error = LKA_TEMPFAIL;
					free(ep);
					return;
				}
			}
d691 1
a691 1
			if (strchr(unsafe, tmp[i]))
a825 22
}

static int
mailaddr_tag(const struct mailaddr *maddr, char *dest, size_t len)
{
	char		*tag;
	char		*sanitized;

	if ((tag = strchr(maddr->user, TAG_CHAR))) {
		tag++;
		while (*tag == '.')
			tag++;
	}
	if (tag == NULL)
		return 1;

	if (strlcpy(dest, tag, len) >= len)
		return 0;
	for (sanitized = dest; *sanitized; sanitized++)
		if (strchr(unsafe, *sanitized))
			*sanitized = ':';
	return 1;
@


1.65
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d498 1
a498 1
			strlcpy(ep->sender.user, rule->r_as->user,
d501 1
a501 1
			strlcpy(ep->sender.domain, rule->r_as->domain,
d516 1
a516 1
			strlcpy(ep->agent.mda.username, SMTPD_USER,
d521 1
a521 1
			strlcpy(ep->agent.mda.username, xn2->u.user,
d532 1
a532 1
		strlcpy(ep->agent.mda.usertable, rule->r_userbase->t_name,
d534 1
a534 1
		strlcpy(ep->agent.mda.username, lk.userinfo.username,
d539 1
a539 1
			strlcpy(ep->agent.mda.buffer, xn->u.buffer,
d544 1
a544 1
			strlcpy(ep->agent.mda.buffer, xn->u.buffer,
d549 1
a549 1
			strlcpy(ep->agent.mda.buffer, rule->r_value.buffer,
d559 1
a559 3
				strlcat(ep->agent.mda.buffer, "/.",
				    sizeof(ep->agent.mda.buffer));
				strlcat(ep->agent.mda.buffer, tag,
d561 7
@


1.64
log
@The user.directory expansion is not supposed to be escaped.

ok gilles@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.63 2014/02/04 10:38:06 eric Exp $	*/
d232 3
a234 3
		m_create(p_smtp, IMSG_LKA_EXPAND_RCPT, 0, 0, -1);
		m_add_id(p_smtp, lks->id);
		m_add_int(p_smtp, lks->error);
d237 1
a237 1
			m_add_string(p_smtp, lks->errormsg);
d240 1
a240 1
				m_add_string(p_smtp, "550 Invalid recipient");
d242 1
a242 1
				m_add_string(p_smtp, "451 Temporary failure");
d245 1
a245 1
		m_close(p_smtp);
d255 1
a255 1
			m_create(p_queue, IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1);
d262 1
a262 1
		m_create(p_queue, IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1);
d418 1
a418 1
		m_compose(p_parent, IMSG_PARENT_FORWARD_OPEN, 0, 0, -1,
@


1.63
log
@extend allowed charset for email address, escape all potentially dangerous ones.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d708 1
a708 1
	if (! raw)
@


1.62
log
@bcopy -> memmove
bzero -> memset
@
text
@d88 1
a88 1
static const char	*unsafe = "*?";
@


1.61
log
@Allow '*' in the user part of mailaddresses.  By default, potentially dangerous
characters are replaced when expanding for local deliveries, unless the "raw"
modifier is specified.
@
text
@d116 1
a116 1
	bzero(&xn, sizeof xn);
d347 1
a347 1
			bzero(&node, sizeof node);
d411 1
a411 1
		bzero(&fwreq, sizeof(fwreq));
d552 1
a552 1
			bzero(tag, sizeof tag);
d769 1
a769 1
	bzero(tmpbuf, sizeof tmpbuf);
@


1.60
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d73 1
a73 1
static const char * mailaddr_tag(const struct mailaddr *);
d86 1
d88 2
d481 2
a482 2
	const char		*tag;
	int			r;
d551 8
a558 2
			tag = mailaddr_tag(&ep->dest);
			if (rule->r_action == A_MAILDIR && tag && tag[0]) {
d598 1
d681 6
a688 7
		/* make sure we are working on tmp */
		if (string != tmp) {
			if (strlcpy(tmp, string, sizeof tmp) >= sizeof tmp)
				return 0;
			string = tmp;
		}

d693 5
a697 1
				if (! strcmp(token_modifiers[i].name, mods)) {
d707 6
a712 1
		
d847 2
a848 2
static const char *
mailaddr_tag(const struct mailaddr *maddr)
d850 2
a851 1
	const char *tag;
d858 2
d861 6
a866 1
	return (tag);
@


1.59
log
@bzero() some structs before using them, to be safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.58 2013/10/26 12:27:59 eric Exp $	*/
d145 15
a159 3
			log_trace(TRACE_EXPAND, "expand: no .forward for "
			    "user %s, just deliver", fwreq->user);
			lka_submit(lks, rule, xn);
d176 15
a190 3
				log_trace(TRACE_EXPAND, "expand: empty .forward "
				    "for user %s, just deliver", fwreq->user);
				lka_submit(lks, rule, xn);
d421 5
d432 5
d447 5
d501 1
@


1.58
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.57 2013/07/19 08:12:19 eric Exp $	*/
d383 2
d390 1
@


1.57
log
@Introduce expand string modifiers
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d423 1
a423 1
		log_warnx("warn: lka_find_ancestor: no ancestors of type %i",
@


1.56
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.55 2013/02/14 12:30:49 gilles Exp $	*/
d43 2
d75 13
d541 1
a541 1
	char	       *lbracket, *rbracket, *content, *sep;
d549 1
d580 6
d628 24
a759 3
		if (! lowercase(exptok, exptok, sizeof exptok))
			return 0;

d782 1
a782 1
	if ((tag = strchr(dst, '+')) != NULL)
d791 1
a791 1
	if ((tag = strchr(maddr->user, '+'))) {
d798 42
@


1.55
log
@- smtpctl trace expand, enables tracing of aliases expansion
- replace "users" keyword with "userbase" when providing alternate userbase
- disambiguise expansion nodes when expanding across domains and userbases
- allow use of '=' instead of '=>' when declaring a mapping

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.54 2013/02/05 11:45:18 gilles Exp $	*/
a22 1
#include <sys/param.h>
d55 1
d73 2
a74 1
static struct tree	sessions = SPLAY_INITIALIZER(&sessions);
d84 5
d113 1
d142 2
a143 1
			if (! forwards_get(fd, &lks->expand)) {
d148 5
d190 1
a190 1
		m_create(p_smtp, IMSG_LKA_EXPAND_RCPT, 0, 0, -1, 24);
d193 10
d213 1
a213 2
			m_create(p_queue, IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
			    MSZ_EVP);
d220 1
a220 1
		m_create(p_queue, IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1, 9);
d236 1
d238 1
a238 1
	struct userinfo	       *tu = NULL;
d281 9
a289 1
			r = aliases_virtual_get(&lks->expand, &xn->u.mailaddr);
d351 1
a351 1
		r = table_lookup(rule->r_userbase, xn->u.user, K_USERINFO, (void **)&tu);
d369 4
a372 4
		(void)strlcpy(fwreq.user, tu->username, sizeof(fwreq.user));
		(void)strlcpy(fwreq.directory, tu->directory, sizeof(fwreq.directory));
		fwreq.uid = tu->uid;
		fwreq.gid = tu->gid;
a375 1
		free(tu);
d384 10
d418 1
a418 1
	struct userinfo		*tu;
d435 3
a437 1
		if (rule->r_as && rule->r_as->user[0])
d440 1
a440 1
		if (rule->r_as && rule->r_as->domain[0])
d448 1
d464 2
a465 2
		r = table_lookup(rule->r_userbase, ep->agent.mda.username, K_USERINFO,
		    (void **)&tu);
d473 1
a473 1
		strlcpy(ep->agent.mda.username, tu->username,
d502 1
a502 2
		    sizeof(ep->agent.mda.buffer), ep, tu);
		free(tu);
d530 1
d591 1
a591 1
	else if (! strcasecmp("user.directory", rtoken))
d593 2
d640 1
a640 1
		*dest = (*string == '/') ? ':' : *string;
@


1.54
log
@- handle getaddrinfo() error as LKA_TEMPFAIL
- handle getsockname() error in smtp_connected()
- accept '/' as part of user-part, expand to ':' as done by qmail
- fix wrong check in mda leading to bogus Return-Path header
- fix aliases parsing when there's a white space between key and separator
- some cosmethic cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.53 2013/01/31 18:34:43 eric Exp $	*/
d117 1
a117 1
		log_trace(TRACE_LOOKUP, "lookup: ~/.forward failed for user %s",
d123 1
a123 1
			log_trace(TRACE_LOOKUP, "lookup: no .forward for "
d132 2
a133 1

d136 1
a136 1
				log_trace(TRACE_LOOKUP, "lookup: temporary "
d171 1
a171 1
		log_trace(TRACE_LOOKUP, "lookup: lka_done: expanded to empty "
d218 1
a218 1
		log_trace(TRACE_LOOKUP, "lookup: lka_expand: node too deep.");
d231 1
a231 1
		log_trace(TRACE_LOOKUP, "lookup: lka_expand: address: %s@@%s "
d247 3
d258 1
a258 2
			r = aliases_virtual_get(rule->r_mapping,
			    &lks->expand, &xn->u.mailaddr);
d261 1
a261 1
				log_trace(TRACE_LOOKUP, "lookup: lka_expand: "
d266 1
a266 1
				log_trace(TRACE_LOOKUP, "lookup: lka_expand: "
d278 2
d285 1
a285 1
		log_trace(TRACE_LOOKUP, "lookup: lka_expand: username: %s "
d289 1
a289 1
			log_trace(TRACE_LOOKUP, "lookup: lka_expand: same "
d299 2
d302 1
a302 2
			r = aliases_get(rule->r_mapping, &lks->expand,
			    xn->u.user);
d304 1
a304 1
				log_trace(TRACE_LOOKUP, "lookup: lka_expand: "
d314 1
a314 1
			log_trace(TRACE_LOOKUP, "lookup: lka_expand: "
d320 1
a320 1
		r = table_lookup(rule->r_users, xn->u.user, K_USERINFO, (void **)&tu);
d322 1
a322 1
			log_trace(TRACE_LOOKUP, "lookup: lka_expand: "
d328 1
a328 1
			log_trace(TRACE_LOOKUP, "lookup: lka_expand: "
d349 1
a349 1
		log_trace(TRACE_LOOKUP, "lookup: lka_expand: filename: %s "
d355 1
a355 1
		log_trace(TRACE_LOOKUP, "lookup: lka_expand: filter: %s "
d421 1
a421 1
		r = table_lookup(rule->r_users, ep->agent.mda.username, K_USERINFO,
d428 1
a428 1
		strlcpy(ep->agent.mda.usertable, rule->r_users->t_name,
@


1.53
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.51 2013/01/26 09:37:23 gilles Exp $	*/
d587 6
a592 1
	memcpy(dest, string + begoff, i);
d594 1
a594 1
	return i;
@


1.52
log
@- introduce 'smtpctl trace lookup' to trace lookup process
- improve logging of the transfer process

trace by me, logging by eric
@
text
@d202 1
a202 1
	expand_free(&lks->expand);
d647 5
a651 1
		*strchr(memcpy(token, pbuf+2, ebuf-pbuf-1), '}') = '\0';
@


1.51
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.49 2012/11/12 14:58:53 eric Exp $	*/
d117 1
a117 1
		log_debug("debug: lka: opening .forward failed for user %s",
d123 2
a124 2
			log_debug("debug: lka: no .forward for user %s, just deliver",
			    fwreq->user);
d135 2
a136 2
				log_debug("debug: lka: temporary forward error for user %s",
				    fwreq->user);
d170 2
a171 1
		log_debug("debug: lka_done: expanded to empty delivery list");
d217 1
a217 1
		log_debug("debug: lka_expand: node too deep.");
d229 3
a231 1
		log_debug("debug: lka_expand: address: %s@@%s [depth=%d]",
d258 1
a258 1
				log_debug("debug: lka_expand: "
d263 1
a263 1
				log_debug("debug: lka_expand: "
d280 2
a281 2
		log_debug("debug: lka_expand: username: %s [depth=%d]",
		    xn->u.user, xn->depth);
d284 2
a285 1
			log_debug("debug: lka_expand: same user, submitting");
d298 1
a298 1
				log_debug("debug: lka_expand: "
d308 1
a308 1
			log_debug("debug: lka_expand: "
d316 1
a316 1
			log_debug("debug: lka_expand: "
d322 1
a322 1
			log_debug("debug: lka_expand: "
d343 2
a344 2
		log_debug("debug: lka_expand: filename: %s [depth=%d]",
		    xn->u.buffer, xn->depth);
d349 2
a350 2
		log_debug("debug: lka_expand: filter: %s [depth=%d]",
		    xn->u.buffer, xn->depth);
@


1.50
log
@missing initialization.

ok gilles@@
@
text
@d4 1
a4 1
 * Copyright (c) 2011 Gilles Chehade <gilles@@openbsd.org>
d46 1
a46 2
#define	F_ERROR		0x01
#define	F_WAITING	0x02
d49 1
a49 1
	uint64_t		 id;
d55 1
a55 2
	struct submit_status	 ss;

a56 1

d63 4
a66 2
static void lka_expand(struct lka_session *, struct rule *, struct expandnode *);
static void lka_submit(struct lka_session *, struct rule *, struct expandnode *);
d68 2
a69 1
static size_t lka_expand_format(char *, size_t, const struct envelope *);
d75 2
d78 1
a78 1
lka_session(struct submit_status *ss)
d84 1
a84 3
	lks->id = generate_uid();
	lks->ss = *ss;
	lks->ss.code = 250;
d89 1
a89 1
	lks->envelope = ss->envelope;
d94 1
a94 1
	xn.u.mailaddr = lks->envelope.dest; /* XXX we should only have rcpt */
d104 3
a106 3
	struct lka_session	*lks;
	struct rule		*rule;
	struct expandnode	*xn;
d114 3
a116 7
	if (fd == -1 && fwreq->status) {
		/* no .forward, just deliver to local user */
		log_debug("debug: lka: no .forward for user %s, just deliver",
		    fwreq->as_user);
		lka_submit(lks, rule, xn);
	}
	else if (fd == -1) {
d118 21
a138 13
		    fwreq->as_user);
		lks->ss.code = 530;
		lks->flags |= F_ERROR;
	}
	else {
		/* expand for the current user and rule */
		lks->expand.rule = rule;
		lks->expand.parent = xn;
		lks->expand.alias = 0;
		if (forwards_get(fd, &lks->expand) == 0) {
			/* no aliases */
			lks->ss.code = 530;
			lks->flags |= F_ERROR;
d140 4
a143 1
		close(fd);
d145 1
d155 1
a155 1
	if (lks->flags & F_ERROR)
d159 1
a159 1
	while((xn = TAILQ_FIRST(&lks->nodes))) {
d164 1
a164 1
		if (lks->flags & F_ERROR)
d170 2
a171 2
		log_debug("debug: lka_done: expansion led to empty delivery list");
		lks->flags |= F_ERROR;
d174 5
a178 3
	if (lks->flags & F_ERROR) {
		imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT, 0, 0,
		    -1, &lks->ss, sizeof(struct submit_status));
d185 1
a185 1
		/* process the delivery list and submit envelopes to queue */
d188 5
a192 3
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1,
			    ep, sizeof *ep);
d195 4
a198 3
		ep = &lks->ss.envelope;
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1, ep, sizeof *ep);
a211 1
	struct passwd	       *pw;
d213 1
d217 1
a217 2
		lks->flags |= F_ERROR;
		lks->ss.code = 530;
d228 1
a228 1
		log_debug("debug: lka_expand: expanding address: %s@@%s [depth=%d]",
d235 1
a235 1
			ep.flags |= DF_INTERNAL;
d238 3
a240 3
			lks->flags |= F_ERROR;
			lks->ss.code = (errno == EAGAIN ? 451 : 530);
			break; /* no rule for address or REJECT match */
d242 1
d246 1
a246 1
		else if (rule->r_condition.c_type == COND_VDOM) {
d251 1
a251 1
			r = aliases_virtual_get(rule->r_condition.c_map,
d254 3
a256 4
				lks->flags |= F_ERROR;
				lks->ss.code = 451;
				log_debug(
				    "lka_expand: error in virtual alias lookup");
d259 3
a261 3
				lks->flags |= F_ERROR;
				lks->ss.code = 530;
				log_debug("debug: lka_expand: no aliases for virtual");
d268 1
a268 1
			bzero(&node, sizeof(node));
d277 2
a278 1
		log_debug("debug: lka_expand: expanding username: %s [depth=%d]", xn->u.user, xn->depth);
d290 3
a292 2
		if (rule->r_amap) {
			r = aliases_get(rule->r_amap, &lks->expand, xn->u.user);
d294 3
a296 3
				log_debug("debug: lka_expand: error in alias lookup");
				lks->flags |= F_ERROR;
				lks->ss.code = 451;
d302 5
a306 5
		/* a username should not exceed the size of a system user */
		if (strlen(xn->u.user) >= sizeof fwreq.as_user) {
			log_debug("debug: lka_expand: user-part too long to be a system user");
			lks->flags |= F_ERROR;
			lks->ss.code = 530;
d310 11
a320 5
		pw = getpwnam(xn->u.user);
		if (pw == NULL) {
			log_debug("debug: lka_expand: user-part does not match system user");
			lks->flags |= F_ERROR;
			lks->ss.code = 530;
d328 6
a333 3
		(void)strlcpy(fwreq.as_user, xn->u.user, sizeof(fwreq.as_user));
		imsg_compose_event(env->sc_ievs[PROC_PARENT],
		    IMSG_PARENT_FORWARD_OPEN, 0, 0, -1, &fwreq, sizeof(fwreq));
d335 1
d339 2
a340 1
		log_debug("debug: lka_expand: expanding filename: %s [depth=%d]", xn->u.buffer, xn->depth);
d345 2
a346 1
		log_debug("debug: lka_expand: expanding filter: %s [depth=%d]", xn->u.buffer, xn->depth);
d355 1
a355 1
	while(xn && (xn->type != type))
d358 2
a359 1
		log_warnx("warn: lka_find_ancestor: no ancestors of type %i", type);
d368 1
d372 1
d402 2
a403 2
			strlcpy(ep->agent.mda.user, SMTPD_USER,
			    sizeof (ep->agent.mda.user));
d407 10
a416 2
			strlcpy(ep->agent.mda.user, xn2->u.user,
			    sizeof (ep->agent.mda.user));
d418 4
d440 1
a440 1
				    sizeof (ep->agent.mda.buffer));
d442 1
a442 1
				    sizeof (ep->agent.mda.buffer));
d448 7
a454 6
		if (! lka_expand_format(ep->agent.mda.buffer,
					sizeof(ep->agent.mda.buffer), ep)) {
			lks->flags |= F_ERROR;
			lks->ss.code = 451;
			log_warnx("warn: format string result too long while "
			    " expanding for user %s", ep->agent.mda.user);
d466 1
d468 2
a469 1
lka_expand_format(char *buf, size_t len, const struct envelope *ep)
d471 7
a477 6
	char *p, *pbuf;
	size_t ret, lret = 0;
	struct user_backend *ub;
	struct mta_user u;
	char lbuffer[MAX_RULEBUFFER_LEN];
	char tmpbuf[MAX_RULEBUFFER_LEN];
d479 75
a553 1
	if (len < sizeof lbuffer)
d556 64
a619 2
	bzero(lbuffer, sizeof (lbuffer));
	pbuf = lbuffer;
d621 7
a627 42
	ret = 0;
	for (p = buf; *p != '\0' && ret < sizeof (lbuffer);
	     ++p, len -= lret, pbuf += lret, ret += lret) {
		if (p == buf && *p == '~') {
			if (*(p + 1) == '/' || *(p + 1) == '\0') {

				bzero(&u, sizeof (u));
				ub = user_backend_lookup(USER_PWD);
				if (! ub->getbyname(&u, ep->agent.mda.user))
					return 0;
				
				lret = strlcat(pbuf, u.directory, len);
				if (lret >= len)
					return 0;
				continue;
			}
			
			if (*(p + 1) != '/') {
				char username[MAXLOGNAME];
				char *delim;
				
				lret = strlcpy(username, p + 1,
				    sizeof(username));
				if (lret >= sizeof(username))
					return 0;

				delim = strchr(username, '/');
				if (delim == NULL)
					goto copy;
				*delim = '\0';

				bzero(&u, sizeof (u));
				ub = user_backend_lookup(USER_PWD);
				if (! ub->getbyname(&u, username))
					return 0;

				lret = strlcat(pbuf, u.directory, len);
				if (lret >= len)
					return 0;
				p += strlen(username);
				continue;
			}
a628 27
		if (*p == '%') {
			const char	*string, *tmp = p + 1;
			int	 digit = 0;

			if (isdigit((int)*tmp)) {
			    digit = 1;
			    tmp++;
			}
			switch (*tmp) {
			case 'A':
				string = ep->sender.user;
				break;
			case 'D':
				string = ep->sender.domain;
				break;
			case 'u':
				string = ep->agent.mda.user;
				break;
			case 'a':
				string = ep->dest.user;
				break;
			case 'd':
				string = ep->dest.domain;
				break;
			default:
				goto copy;
			}
d630 3
a632 21
			if (! lowercase(tmpbuf, string, sizeof tmpbuf))
				return 0;
			string = tmpbuf;
			
			if (digit == 1) {
				size_t idx = *(tmp - 1) - '0';

				lret = 1;
				if (idx < strlen(string))
					*pbuf++ = string[idx];
				else { /* fail */
					return 0;
				}

				p += 2; /* loop only does ++ */
				continue;
			}
			lret = strlcat(pbuf, string, len);
			if (lret >= len)
				return 0;
			p++;
d635 22
a656 3
copy:
		lret = 1;
		*pbuf = *p;
d658 1
a658 3

	/* we aborted loop because we reached max buffer size, fail. */
	if (ret == sizeof (lbuffer))
d661 1
a661 2
	/* shouldn't happen but better be safe ... */
	if (strlcpy(buf, lbuffer, len) >= len)
@


1.49
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.48 2012/10/16 11:10:38 eric Exp $	*/
d256 1
@


1.48
log
@Prevent a possible buffer overflow in lka_expand_format() that can lead
to a server crash, and let the smtp session fail if that happens.

spotted by todd@@, discussed with eric@@ and chl@@

commited for gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.47 2012/10/14 13:31:46 chl Exp $	*/
d116 1
a116 1
		log_debug("lka: no .forward for user %s, just deliver",
d121 1
a121 1
		log_debug("lka: opening .forward failed for user %s",
d162 1
a162 1
		log_info("lka_done: expansion led to empty delivery list");
d203 1
a203 1
		log_debug("lka_expand: node too deep.");
d216 1
a216 1
		log_debug("lka_expand: expanding address: %s@@%s [depth=%d]",
d249 1
a249 1
				log_debug("lka_expand: no aliases for virtual");
d264 1
a264 1
		log_debug("lka_expand: expanding username: %s [depth=%d]", xn->u.user, xn->depth);
d267 1
a267 1
			log_debug("lka_expand: same user, submitting");
d279 1
a279 1
				log_debug("lka_expand: error in alias lookup");
d289 1
a289 1
			log_debug("lka_expand: user-part too long to be a system user");
d297 1
a297 1
			log_debug("lka_expand: user-part does not match system user");
d314 1
a314 1
		log_debug("lka_expand: expanding filename: %s [depth=%d]", xn->u.buffer, xn->depth);
d319 1
a319 1
		log_debug("lka_expand: expanding filter: %s [depth=%d]", xn->u.buffer, xn->depth);
d331 1
a331 1
		log_warnx("lka_find_ancestor: no ancestors of type %i", type);
d410 1
a410 1
			log_warnx("format string result too long while "
@


1.47
log
@substitute wrong comas into semicolons

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.46 2012/10/13 21:38:27 gilles Exp $	*/
d406 9
a414 2
		lka_expand_format(ep->agent.mda.buffer,
		    sizeof(ep->agent.mda.buffer), ep);
d432 4
a435 1
	
d440 1
a440 1
	for (p = buf; *p != '\0';
d537 8
a544 3
	
	/* + 1 to include the NUL byte. */
	memcpy(buf, lbuffer, ret + 1);
@


1.46
log
@missing header
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.45 2012/10/13 21:33:33 gilles Exp $	*/
d117 1
a117 1
		    fwreq->as_user),
d122 1
a122 1
		    fwreq->as_user),
@


1.45
log
@in aliases expansion, we can avoid requesting parent for ~user/.forward, if
we check that user is a system user first before sending the imsg
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.44 2012/10/13 08:01:47 eric Exp $	*/
d34 1
@


1.44
log
@Make map_lookup() and make_compare() set errno on failure to distinguish
between "no match" and "internal error" (e.g. missing or broken db file).
Adapt alias expansion and ruleset matching code to check for such errors,
in which case the current processing is aborted, and a temporary failure
is reported to the smtp session.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.43 2012/10/11 21:14:32 gilles Exp $	*/
d198 1
d289 8
@


1.43
log
@- replace "from all" and "for all" with "from any" and "for any"

ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.42 2012/10/10 18:02:37 eric Exp $	*/
a165 1
		lks->ss.code = 530;
d198 1
d225 1
a225 1
			lks->ss.code = 530;
d236 9
a244 3
			if (aliases_virtual_get(rule->r_condition.c_map,
			    &lks->expand, &xn->u.mailaddr) == 0) {
				log_debug("lka_expand: no aliases for virtual");
d247 1
d274 10
a283 3
		if (rule->r_amap &&
		    aliases_get(rule->r_amap, &lks->expand, xn->u.user))
			break;
@


1.42
log
@For each alias node, mark if it has been expanded from an alias map or
from a .forward file.  Local deliveries for files and filters expanded
from an alias map are run as user _smtpd.

issue reported by tood@@

ok gilles@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.41 2012/10/09 21:33:38 eric Exp $	*/
d231 1
a231 1
		else if (rule->r_condition.c_type == C_VDOM) {
@


1.41
log
@make "relay ... as ..." work again.  It's been zapped by mistake.

spotted by todd@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.40 2012/10/03 19:42:16 gilles Exp $	*/
d129 1
d235 1
d246 1
d266 1
d301 12
a325 2
		ep->type = D_MTA;
		ep->agent.mta.relay = rule->r_value.relayhost;
d328 1
d330 1
d343 1
d346 10
a355 15
		xn2 = xn;
		while(xn2 && (xn2->type != EXPAND_USERNAME))
			xn2 = xn2->parent;
		if (xn2 == NULL)
			fatalx("no user in node ancestry");
		(void)strlcpy(ep->agent.mda.user, xn2->u.user,
		    sizeof (ep->agent.mda.user));

		/* set dest */
		xn2 = xn;
		while(xn2 && (xn2->type != EXPAND_ADDRESS))
			xn2 = xn2->parent;
		if (xn2 == NULL)
			fatalx("no address in node ancestry");
		ep->dest = xn2->u.mailaddr;
d378 2
a379 1
		} else
@


1.40
log
@we reintroduced a bug that was fixed 2 years ago with the aliases rewrite:

During the entire expansion process, a username may be larger than
MAXLOGNAME because it may be an alias going through another expansion.
We should use a buffer that's large enough to fit a mailaddr user-part so
we avoid hitting a truncation check leading to a fatal().

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.39 2012/10/03 18:09:18 gilles Exp $	*/
d315 6
@


1.39
log
@- add a EXPAND_DEPTH define for ... expansion depth
- bump the expansion depth from 5 to 10
- add the current node depth to log_debug()

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.38 2012/09/30 14:28:16 gilles Exp $	*/
a260 1

d266 8
@


1.38
log
@- add decision to the rule so that we can actually perform a reject match
  ie:

	reject from 192.168.1.0/24 for domain "openbsd.org"
	accept from 192.168.0.0/16 for domain "openbsd.org" deliver to mbox

it was documented but not working.

ok eric@@ & chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.37 2012/09/29 10:35:01 eric Exp $	*/
d43 2
d199 1
a199 1
	if (xn->depth >= 5) {
d213 2
a214 2
		log_debug("lka_expand: expanding address: %s@@%s",
		    xn->u.mailaddr.user, xn->u.mailaddr.domain);
d252 1
a252 1
		log_debug("lka_expand: expanding username: %s", xn->u.user);
d279 1
a279 1
		log_debug("lka_expand: expanding filename: %s", xn->u.buffer);
d284 1
a284 1
		log_debug("lka_expand: expanding filter: %s", xn->u.buffer);
@


1.37
log
@finally remove rule member from struct envelope.

"wow!" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.36 2012/09/27 18:57:25 eric Exp $	*/
d220 1
a220 1
		if (rule == NULL) {
d223 1
a223 1
			break; /* no rule for address */
@


1.36
log
@clarify the alias expansion code.

The session manages a list of nodes to process. A node has a link to the
parent node from which it has been expanded, and a link to the rule that
led to its creation. Depending on its type and the associated rule, each
node is either "expanded" to create new nodes or "submitted" to create a
final envelope.  Nodes which have already been seen, either processed or
not, are discarded to avoid loops.

The expansion process is bootstrapped by creating an EXPAND_ADDRESS node
from the original dest, with no rule and no parent.  It is done when all
nodes have been expanded or if an error occurs before.  The expand depth
is limited 5 levels.  The whole expansion fails if the limit is reached.

While there, make sure that only one .forward file is queried at a time,
and only append the subfolder tag in the maildir case.

Fixe issues with some virtual map setups where the dest would get mixed
up, and make the whole expansion process generally easier to follow.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.35 2012/09/26 19:52:20 eric Exp $	*/
d296 1
@


1.35
log
@Stop using the delivery_data union (field "to") in delivery_mda.
It's confusing and not necessary as it's only used for "buffer".
Instead, just add a "buffer" member in the structure and rename
"as_user" to "user".

The delivery_data union becomes an anonymous union in expandnode,
which is the only other place where it's used.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.34 2012/09/24 08:56:12 eric Exp $	*/
d5 1
d43 2
a44 3
enum lka_session_flags {
	F_ERROR		= 0x1
};
d47 7
a53 2
	SPLAY_ENTRY(lka_session)	 nodes;
	uint64_t			 id;
d55 1
a55 2
	TAILQ_HEAD(, envelope)		 deliverylist;
	struct expand			 expand;
d57 4
a60 4
	uint8_t				 iterations;
	uint32_t			 pending;
	enum lka_session_flags		 flags;
	struct submit_status		 ss;
d63 6
a68 12
static void lka_session_fail(struct lka_session *);
static void lka_session_destroy(struct lka_session *);
static void lka_session_pickup(struct lka_session *, struct envelope *);
static int lka_session_envelope_expand(struct lka_session *, struct envelope *);
static int lka_session_resume(struct lka_session *, struct envelope *);
static void lka_session_done(struct lka_session *);
static size_t lka_session_expand_format(char *, size_t, struct envelope *);
static void lka_session_request_forwardfile(struct lka_session *,
    struct envelope *, char *);
static void lka_session_deliver(struct lka_session *, struct envelope *);
static int lka_session_resolve_node(struct envelope *, struct expandnode *);
static int lka_session_rcpt_action(struct envelope *);
d75 2
a76 1
	struct lka_session *lks;
d86 1
a86 87
	if (! lka_session_envelope_expand(lks, &ss->envelope))
		lka_session_fail(lks);
	else
		lka_session_pickup(lks, &ss->envelope);
}

static int
lka_session_envelope_expand(struct lka_session *lks, struct envelope *ep)
{
	char *user;
	char *tag;
	struct user_backend *ub;
	struct mta_user u;
	char username[MAX_LOCALPART_SIZE];

	/* remote delivery, no need to process further */
	if (ep->type == D_MTA) {
		lka_session_deliver(lks, ep);
		return 1;
	}

	switch (ep->rule.r_condition.c_type) {
	case C_ALL:
	case C_DOM:
		if (ep->agent.mda.user[0] == '\0')
			user = ep->dest.user;
		else
			user = ep->agent.mda.user;
		xlowercase(username, user, sizeof(username));

		/* gilles+hackers@@ -> gilles@@ */
		if ((tag = strchr(username, '+')) != NULL) {
			*tag++ = '\0';

			/* skip dots after the '+' */
			while (*tag == '.')
				tag++;
		}

		if (aliases_get(ep->rule.r_amap, &lks->expand, username))
			return 1;

		bzero(&u, sizeof (u));
		ub = user_backend_lookup(USER_PWD);
		if (! ub->getbyname(&u, username))
			return 0;

		(void)strlcpy(ep->agent.mda.user, u.username,
		    sizeof (ep->agent.mda.user));

		ep->type = D_MDA;
		switch (ep->rule.r_action) {
		case A_MBOX:
			ep->agent.mda.method = A_MBOX;
			(void)strlcpy(ep->agent.mda.user,
			    u.username,
			    sizeof (ep->agent.mda.user));
			break;
		case A_MAILDIR:
		case A_FILENAME:
		case A_MDA:
			ep->agent.mda.method = ep->rule.r_action;
			(void)strlcpy(ep->agent.mda.buffer,
			    ep->rule.r_value.buffer,
			    sizeof (ep->agent.mda.buffer));
			
			if (tag && *tag) {
				(void)strlcat(ep->agent.mda.buffer, "/.",
				    sizeof (ep->agent.mda.buffer));
				(void)strlcat(ep->agent.mda.buffer, tag,
				    sizeof (ep->agent.mda.buffer));
			}
			break;
		default:
			fatalx("lka_session_envelope_expand: unexpected rule action");
			return 0;
		}

		lka_session_request_forwardfile(lks, ep, u.username);
		return 1;

	case C_VDOM:
		if (aliases_virtual_get(ep->rule.r_condition.c_map,
		    &lks->expand, &ep->dest))
			return 1;

		return 0;
d88 8
a95 6
	default:
		fatalx("lka_session_envelope_expand: unexpected type");
		return 0;
	}

	return 0;
d101 3
a103 2
	struct lka_session *lks;
	struct envelope *ep;
d106 4
a109 3
	lks->pending--;
	
	ep = &fwreq->envelope;
d111 18
a128 5
	if (fd != -1) {
		/* opened .forward okay */
		strlcpy(lks->expand.user, fwreq->as_user,
		    sizeof lks->expand.user);
		if (! forwards_get(fd, &lks->expand)) {
a132 2
		lka_session_pickup(lks, ep);
		return;
d134 1
a134 12

	if (fwreq->status) {
		/* .forward not present */
		lka_session_deliver(lks, ep);
		lka_session_pickup(lks, ep);
		return;
	}

	/* opening .forward failed */
	lks->ss.code = 530;
	lks->flags |= F_ERROR;
	lka_session_pickup(lks, ep);
d138 1
a138 1
lka_session_pickup(struct lka_session *lks, struct envelope *ep)
d140 2
a141 1
	int ret;
d143 2
a144 12
	/* we want to do five iterations of lka_session_resume() but
	 * we need to be interruptible in case lka_session_resume()
	 * has sent an imsg and expects an answer.
	 */
	while (! (lks->flags & F_ERROR) &&
	    ! lks->pending && lks->iterations < 5) {
		++lks->iterations;
		ret = lka_session_resume(lks, ep);
		if (ret == -1) {
			lks->ss.code = 530;
			lks->flags |= F_ERROR;
		}
d146 8
a153 2
		if (lks->pending || ret <= 0)
			break;
d156 1
a156 51
	if (lks->pending)
		return;

	lka_session_done(lks);
}

static int
lka_session_resume(struct lka_session *lks, struct envelope *ep)
{
	struct expandnode *xn;
	uint8_t done = 1;

	RB_FOREACH(xn, expandtree, &lks->expand.tree) {

		/* this node has already been expanded, skip */
		if (xn->done)
			continue;
		done = 0;

		switch (lka_session_resolve_node(ep, xn)) {
		case 0:
			if (! lka_session_envelope_expand(lks, ep))
				return -1;
			break;
		case 1:
			lka_session_deliver(lks, ep);
			break;
		default:
			return -1;
		}

		xn->done = 1;
	}

	/* still not done after 5 iterations ? loop detected ... reject */
	if (!done && lks->iterations == 5)
		return -1;

	/* we're done expanding, no need for another iteration */
	if (RB_ROOT(&lks->expand.tree) == NULL || done)
		return 0;

	return 1;
}

static void
lka_session_done(struct lka_session *lks)
{
	struct envelope *ep;

	/* delivery list is empty OR expansion led to an error, reject */
d158 1
a158 1
		log_info("lka_session_done: expansion led to empty delivery list");
d161 1
a161 15
	if (lks->flags & F_ERROR)
		goto done;

	/* process the delivery list and submit envelopes to queue */
	while ((ep = TAILQ_FIRST(&lks->deliverylist)) != NULL) {
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1, ep, sizeof *ep);
		TAILQ_REMOVE(&lks->deliverylist, ep, entry);
		free(ep);
	}
	ep = &lks->ss.envelope;
	imsg_compose_event(env->sc_ievs[PROC_QUEUE],
	    IMSG_QUEUE_COMMIT_ENVELOPES, 0, 0, -1, ep, sizeof *ep);

done:
d166 4
d171 12
a182 20
	lka_session_destroy(lks);
}

static void
lka_session_fail(struct lka_session *lks)
{
	lks->ss.code = 530;
	imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_LKA_RCPT, 0, 0, -1,
	    &lks->ss, sizeof(lks->ss));
	lka_session_destroy(lks);
}

static void
lka_session_destroy(struct lka_session *lks)
{
	struct envelope *ep;

	while ((ep = TAILQ_FIRST(&lks->deliverylist)) != NULL) {
		TAILQ_REMOVE(&lks->deliverylist, ep, entry);
		free(ep);
d191 1
a191 1
lka_session_deliver(struct lka_session *lks, struct envelope *ep)
d193 3
a195 1
	struct envelope *new_ep;
d197 5
a201 28
	new_ep = xmemdup(ep, sizeof *ep, "lka_session_deliver");
	if (new_ep->type == D_MDA) {
		switch (new_ep->agent.mda.method) {
		case A_MAILDIR:
		case A_FILENAME:
		case A_MDA:
			if (! lka_session_expand_format(
			    new_ep->agent.mda.buffer,
			    sizeof(new_ep->agent.mda.buffer), new_ep))
				lks->flags |= F_ERROR;
		default:
			break;
		}
	}
	else if (new_ep->type == D_MTA) {
		new_ep->agent.mta.relay = ep->rule.r_value.relayhost;
		if (ep->rule.r_as) {
			if (ep->rule.r_as->user[0]) {
				strlcpy(new_ep->sender.user,
				    ep->rule.r_as->user,
				    sizeof new_ep->sender.user);
			}
			if (ep->rule.r_as->domain[0]) {
				strlcpy(new_ep->sender.domain,
				    ep->rule.r_as->domain,
				    sizeof new_ep->sender.domain);
			}
		}
a202 10
	TAILQ_INSERT_TAIL(&lks->deliverylist, new_ep, entry);
}

static int
lka_session_resolve_node(struct envelope *ep, struct expandnode *xn)
{
	struct envelope	oldep;

	memcpy(&oldep, ep, sizeof (*ep));
	bzero(&ep->agent, sizeof (ep->agent));
d207 1
a207 1
		fatalx("lka_session_resolve_node: unexpected type");
d211 1
a211 1
		log_debug("lka_resolve_node: node is address: %s@@%s",
a212 1
		ep->dest = xn->u.mailaddr;
d214 34
a247 8
		/* evaluation of ruleset assumes local source
		 * since we're expanding on already accepted
		 * source.
		 */
		ep->flags |= DF_INTERNAL;
		if (! lka_session_rcpt_action(ep))
			return -1;
		return 0;
d250 5
a254 19
		log_debug("lka_resolve_node: node is local username: %s",
		    xn->u.user);
		ep->type  = D_MDA;
		strlcpy(ep->agent.mda.user, xn->u.user,
		    sizeof ep->agent.mda.user);

		/* overwrite the initial condition before we expand the
		 * envelope again. if we came from a C_VDOM, not doing
		 * so would lead to a VDOM loop causing recipient to be
		 * rejected.
		 *
		 * i'll find a more elegant solution later, for now it
		 * fixes an annoying bug.
		 */
		ep->rule.r_condition.c_type = C_DOM;

		/* if expansion of a user results in same user ... deliver */
		if (strcmp(xn->u.user, xn->as_user) == 0) {
			ep->agent.mda.method = oldep.agent.mda.method;
d258 17
a274 4
		/* otherwise rewrite delivery user with expansion result */
		(void)strlcpy(ep->agent.mda.user, xn->u.user,
		    sizeof (ep->agent.mda.user));
		return 0;
d277 2
a278 8
		log_debug("lka_resolve_node: node is filename: %s",
		    xn->u.buffer);
		ep->type  = D_MDA;
		ep->agent.mda.method = A_FILENAME;
		(void)strlcpy(ep->agent.mda.buffer, xn->u.buffer,
		    sizeof (ep->agent.mda.buffer));
		(void)strlcpy(ep->agent.mda.user, xn->as_user,
		    sizeof (ep->agent.mda.user));
d282 37
a318 7
		log_debug("lka_resolve_node: node is filter: %s",
		    xn->u.buffer);
		ep->type  = D_MDA;
		ep->agent.mda.method = A_MDA;
		(void)strlcpy(ep->agent.mda.buffer, xn->u.buffer,
		    sizeof (ep->agent.mda.buffer));
		(void)strlcpy(ep->agent.mda.user, xn->as_user,
d320 35
d356 2
d360 1
a360 1
	return 1;
d364 1
a364 1
lka_session_expand_format(char *buf, size_t len, struct envelope *ep)
d420 1
a420 1
			char	*string, *tmp = p + 1;
d481 2
a482 2
static int
lka_session_rcpt_action(struct envelope *ep)
d484 1
a484 1
	struct rule *r;
d486 1
a486 5
	r = ruleset_match(ep);
	if (r == NULL) {
		ep->type = D_MTA;
		return 0;
	}
d488 3
a490 13
	ep->rule = *r;
	switch (ep->rule.r_action) {
	case A_MBOX:
	case A_MAILDIR:
	case A_FILENAME:
	case A_MDA:
		ep->type = D_MDA;
		break;
	default:
		ep->type = D_MTA;
	}

	return 1;
d493 2
a494 3
static void
lka_session_request_forwardfile(struct lka_session *lks,
    struct envelope *ep, char *as_user)
d496 7
a502 1
	struct forward_req fwreq;
d504 1
a504 6
	fwreq.id = lks->id;
	fwreq.envelope = *ep;
	(void)strlcpy(fwreq.as_user, as_user, sizeof(fwreq.as_user));
	imsg_compose_event(env->sc_ievs[PROC_PARENT],
	    IMSG_PARENT_FORWARD_OPEN, 0, 0, -1, &fwreq, sizeof(fwreq));
	++lks->pending;
@


1.34
log
@spaces -> tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.33 2012/09/21 19:37:08 eric Exp $	*/
d111 1
a111 1
		if (ep->agent.mda.to.user[0] == '\0')
d114 1
a114 1
			user = ep->agent.mda.to.user;
d134 2
a135 2
		(void)strlcpy(ep->agent.mda.as_user, u.username,
		    sizeof (ep->agent.mda.as_user));
d141 1
a141 1
			(void)strlcpy(ep->agent.mda.to.user,
d143 1
a143 1
			    sizeof (ep->agent.mda.to.user));
d149 1
a149 1
			(void)strlcpy(ep->agent.mda.to.buffer,
d151 1
a151 1
			    sizeof (ep->agent.mda.to.buffer));
d154 4
a157 4
				(void)strlcat(ep->agent.mda.to.buffer, "/.",
				    sizeof (ep->agent.mda.to.buffer));
				(void)strlcat(ep->agent.mda.to.buffer, tag,
				    sizeof (ep->agent.mda.to.buffer));
d356 2
a357 2
			    new_ep->agent.mda.to.buffer,
			    sizeof(new_ep->agent.mda.to.buffer), new_ep))
d413 2
a414 1
		ep->agent.mda.to = xn->u;
d433 2
a434 4
		(void)strlcpy(ep->agent.mda.to.user, xn->u.user,
		    sizeof (ep->agent.mda.to.user));
		(void)strlcpy(ep->agent.mda.as_user, xn->u.user,
		    sizeof (ep->agent.mda.as_user));
a440 1
		ep->agent.mda.to = xn->u;
d442 4
a445 2
		(void)strlcpy(ep->agent.mda.as_user, xn->as_user,
		    sizeof (ep->agent.mda.as_user));
a451 1
		ep->agent.mda.to = xn->u;
d453 4
a456 2
		(void)strlcpy(ep->agent.mda.as_user, xn->as_user,
		    sizeof (ep->agent.mda.as_user));
d484 1
a484 1
				if (! ub->getbyname(&u, ep->agent.mda.as_user))
d535 1
a535 1
				string = ep->agent.mda.as_user;
@


1.33
log
@Do not pass the username to forwards_get() which does not have to care about
this.  Instead, set the username on the expand context, and copy it on the
expand nodes as they are inserted.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.32 2012/09/21 16:40:20 eric Exp $	*/
d226 3
a228 3
         * we need to be interruptible in case lka_session_resume()
         * has sent an imsg and expects an answer.
         */
d252 1
a252 1
        uint8_t done = 1;
d257 3
a259 3
                if (xn->done)
                        continue;
                done = 0;
d276 3
a278 3
        /* still not done after 5 iterations ? loop detected ... reject */
        if (!done && lks->iterations == 5)
                return -1;
d280 1
a280 1
        /* we're done expanding, no need for another iteration */
d325 2
a326 2
            &lks->ss, sizeof(lks->ss));
        lka_session_destroy(lks);
d387 1
a387 1
        bzero(&ep->agent, sizeof (ep->agent));
d390 4
a393 4
        case EXPAND_INVALID:
        case EXPAND_INCLUDE:
                fatalx("lka_session_resolve_node: unexpected type");
                break;
d395 2
a396 2
        case EXPAND_ADDRESS:
                log_debug("lka_resolve_node: node is address: %s@@%s",
d405 1
a405 1
                if (! lka_session_rcpt_action(ep))
d409 2
a410 2
        case EXPAND_USERNAME:
                log_debug("lka_resolve_node: node is local username: %s",
d438 2
a439 2
        case EXPAND_FILENAME:
                log_debug("lka_resolve_node: node is filename: %s",
d446 1
a446 1
                break;
d448 2
a449 2
        case EXPAND_FILTER:
                log_debug("lka_resolve_node: node is filter: %s",
d456 1
a456 1
                break;
d583 1
a583 1
        struct rule *r;
d591 1
a591 1
        ep->rule = *r;
@


1.32
log
@wrap expandtree into a "struct expand".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.31 2012/09/21 13:23:07 eric Exp $	*/
d196 3
a198 1
		if (! forwards_get(fd, &lks->expand, fwreq->as_user)) {
@


1.31
log
@move struct lka_session definition in lka_session.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.30 2012/09/21 10:22:29 eric Exp $	*/
d51 1
a51 1
	struct expandtree		 expandtree;
d83 1
a83 1
	RB_INIT(&lks->expandtree);
d126 1
a126 1
		if (aliases_get(ep->rule.r_amap, &lks->expandtree, username))
d170 1
a170 1
		    &lks->expandtree, &ep->dest))
d196 1
a196 1
		if (! forwards_get(fd, &lks->expandtree, fwreq->as_user)) {
d252 1
a252 1
	RB_FOREACH(xn, expandtree, &lks->expandtree) {
d279 1
a279 1
	if (RB_ROOT(&lks->expandtree) == NULL || done)
d337 1
a337 1
	expand_free(&lks->expandtree);
@


1.30
log
@Move ruleset_match() prototype to smtpd.h and make the envelope const.
Adapt a lot of functions in chain to use const args where required.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.29 2012/09/19 10:10:30 eric Exp $	*/
d41 17
@


1.29
log
@Remove aliases_exists() and aliases_virtual_exists(). The corresponding
*_get() functions can be called directly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.28 2012/09/19 09:06:35 eric Exp $	*/
a53 1
struct rule *ruleset_match(struct envelope *);
@


1.28
log
@start cleaning the expansion code:

- change expandtree_* prefix to expand_ for better readability and
  because the structure might change at some point
- rename <>_free_nodes() to <>_free()
- remove unused <>_remove_node()
- refcounting has no purpose at all; just remove it as well as the
  decrement/increment functions, and replace the latter with <>_insert
- expandnode flags is only used to know if it's been processed or not,
  don't make it a flag but a simple field with clear name.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.27 2012/09/18 15:35:13 eric Exp $	*/
d110 1
a110 5
		if (aliases_exist(ep->rule.r_amap, username)) {
			if (! aliases_get(ep->rule.r_amap,
				&lks->expandtree, username)) {
				return 0;
			}
a111 1
		}
d153 2
a154 4
		if (aliases_virtual_exist(ep->rule.r_condition.c_map, &ep->dest)) {
			if (! aliases_virtual_get(ep->rule.r_condition.c_map,
				&lks->expandtree, &ep->dest))
				return 0;
d156 1
a156 1
		}
@


1.27
log
@make use of expandtree_free_nodes() in lka_session_destroy().
change to a simpler implementation for it while there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.26 2012/09/18 14:23:01 eric Exp $	*/
d246 1
a246 1
                if (xn->flags & F_EXPAND_DONE)
d262 1
a262 3
                /* decrement refcount on this node and flag it as processed */
                expandtree_decrement_node(&lks->expandtree, xn);
                xn->flags |= F_EXPAND_DONE;
d328 1
a328 1
	expandtree_free_nodes(&lks->expandtree);
@


1.26
log
@- add xmemdup() helper.
- remove useless block in switch.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.25 2012/09/18 13:42:39 eric Exp $	*/
a323 1
	struct expandnode *xn;
d330 1
a330 5
	while ((xn = RB_ROOT(&lks->expandtree)) != NULL) {
		RB_REMOVE(expandtree, &lks->expandtree, xn);
		free(xn);
	}

@


1.25
log
@simple lka cleanups:

- fix lka* function prototypes in smtpd.h
- make static functions static
- merge lka_session_init() into lka_session()
- make lka_session.c use tree.c to store sessions

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.24 2012/09/18 12:13:22 eric Exp $	*/
d94 1
a94 1
	case C_DOM: {
a155 1
	}
d157 1
a157 1
	case C_VDOM: {
a164 1
	}
d345 1
a345 4
	new_ep = calloc(1, sizeof (*ep));
	if (new_ep == NULL)
		fatal("lka_session_deliver: calloc");
	*new_ep = *ep;
@


1.24
log
@remove C_NET. it's not used and there is no plan for it at the moment.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.23 2012/09/17 18:44:57 gilles Exp $	*/
d42 8
a49 14
void lka_session(struct submit_status *);
void lka_session_forward_reply(struct forward_req *, int);

struct lka_session *lka_session_init(struct submit_status *);
struct lka_session *lka_session_find(uint64_t);
struct lka_session *lka_session_xfind(uint64_t);
void lka_session_fail(struct lka_session *);
void lka_session_destroy(struct lka_session *);
void lka_session_pickup(struct lka_session *, struct envelope *);
int lka_session_envelope_expand(struct lka_session *, struct envelope *);
int lka_session_resume(struct lka_session *, struct envelope *);
void lka_session_done(struct lka_session *);
size_t lka_session_expand_format(char *, size_t, struct envelope *);
void lka_session_request_forwardfile(struct lka_session *,
d51 3
a53 3
void lka_session_deliver(struct lka_session *, struct envelope *);
int lka_session_resolve_node(struct envelope *, struct expandnode *);
int lka_session_rcpt_action(struct envelope *);
d56 2
d63 8
a70 1
	lks = lka_session_init(ss);
d77 1
a77 1
int
d182 1
a182 1
	lks = lka_session_xfind(fwreq->id);
d211 1
a211 21
struct lka_session *
lka_session_init(struct submit_status *ss)
{
	struct lka_session *lks;

	lks = calloc(1, sizeof(*lks));
	if (lks == NULL)
		fatal("lka_session_init: calloc");

	lks->id = generate_uid();
	lks->ss = *ss;
	lks->ss.code = 250;

	RB_INIT(&lks->expandtree);
	TAILQ_INIT(&lks->deliverylist);
	SPLAY_INSERT(lkatree, &env->lka_sessions, lks);

	return lks;
}

void
d239 1
a239 1
int
d280 1
a280 1
void
d313 1
a313 22
struct lka_session *
lka_session_find(uint64_t id)
{
	struct lka_session key;

	key.id = id;
	return SPLAY_FIND(lkatree, &env->lka_sessions, &key);
}

struct lka_session *
lka_session_xfind(uint64_t id)
{
	struct lka_session *lks;

	lks = lka_session_find(id);
	if (lks == NULL)
		fatalx("lka_session_xfind: lka session missing");

	return lks;
}

void
d322 1
a322 1
void
d338 1
a338 1
	SPLAY_REMOVE(lkatree, &env->lka_sessions, lks);
d342 1
a342 1
void
d382 1
a382 1
int
d463 1
a463 1
size_t
d581 1
a581 1
int
d607 1
a607 1
void
a619 17

int
lka_session_cmp(struct lka_session *s1, struct lka_session *s2)
{
	/*
	 * do not return uint64_t's
	 */
	if (s1->id < s2->id)
		return -1;

	if (s1->id > s2->id)
		return 1;

	return 0;
}

SPLAY_GENERATE(lkatree, lka_session, nodes, lka_session_cmp);
@


1.23
log
@Fix format expansion in smtpd.conf, it has confused a lot of people and it
turns out documentation got it wrong. This commit changes formats and doc,
it makes situation saner:

   %A = user part of sender address
   %D = domain part of sender address

   %a = user part of recipient address
   %d = domain part of recipient address
   %u = unix account of recipient

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.22 2012/08/21 20:19:46 eric Exp $	*/
a90 1
	case C_NET:
@


1.22
log
@Allow smtpd to work as a backup MX, relaying only to MXs with higher
priority in the DNS record. For example:

   accept for domain "foo.org" relay backup "mx3.foo.org"

will relay mails for "foo.org" using only hosts with higher priority
(i.e. lower value) than "mx3.foo.org", which is supposed to be the
current server.

If the specified backup MX is not found in the DNS record, relaying
works as normal.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.21 2012/08/19 14:16:58 chl Exp $	*/
d567 1
a567 1
			case 'U':
d573 1
a573 1
			case 'a':
d576 1
a576 1
			case 'u':
@


1.21
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.20 2012/08/09 09:48:02 eric Exp $	*/
d404 1
a404 2
		if (ep->rule.r_action == A_RELAYVIA)
			new_ep->agent.mta.relay = ep->rule.r_value.relayhost;
@


1.20
log
@Improve the message flows to completely isolate operations on the
queue backend within the queue process.

The scheduler sends envelope ids to the queue process which loads
the envelope and forward the request to the agent responsible for
the delivery.  The result is sent by the agent to the queue which
updates the storage before notifying the scheduler.

Bounces are created and enqueued (from the client side) by the
queue process, rather than the scheduler.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.19 2012/07/29 17:21:43 gilles Exp $	*/
d46 2
a47 2
struct lka_session *lka_session_find(u_int64_t);
struct lka_session *lka_session_xfind(u_int64_t);
d261 1
a261 1
        u_int8_t done = 1;
d332 1
a332 1
lka_session_find(u_int64_t id)
d341 1
a341 1
lka_session_xfind(u_int64_t id)
d665 1
a665 1
	 * do not return u_int64_t's
@


1.19
log
@- introduce xlowercase() and allow lowercase() to fail gracefully
- replace all calls to lowercase() with calls to xlowercase()
- in the format string expansion, lowercase() all formats

we will have to reassess all calls to xlowercase() even though it has never
triggered as far as I know, we can probably gracefully fail some of them.
right now we're just keeping former behaviour.

this commit fixes issue reported by Hugo Osvaldo Barrera where a %u format
could lead to a delivery failure (ie: GILLES@@openbsd.org should be expanded
to gilles, not GILLES ... only for local deliveries).

ok chl@@ on the idea, ok eric@@ on the diff
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.18 2012/07/29 16:33:01 eric Exp $	*/
d313 2
a314 1
		queue_submit_envelope(ep);
d318 3
a320 1
	queue_commit_envelopes(&lks->ss.envelope);
@


1.18
log
@get rid of A_INVALID.
little code cleanup while here.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.17 2012/07/12 08:51:43 chl Exp $	*/
d97 1
a97 1
		lowercase(username, user, sizeof(username));
d508 1
d584 4
@


1.17
log
@add support for maildir tagging/folders.

ok gilles@@
ok eric@@ on previous versions of this patch
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.16 2011/12/13 22:04:35 eric Exp $	*/
a381 1
	struct delivery_mda *d_mda;
d388 1
a388 5
		d_mda = &new_ep->agent.mda;
		if (d_mda->method == A_INVALID)
			fatalx("lka_session_deliver: mda method == A_INVALID");

		switch (d_mda->method) {
d391 4
a394 4
		case A_MDA: {
			char *buf = d_mda->to.buffer;
			size_t bufsz = sizeof(d_mda->to.buffer);
			if (! lka_session_expand_format(buf, bufsz, new_ep))
a395 2
			break;
		}
@


1.16
log
@split user_backend.c into user.c and user_pwd.c to be consistent with the
backend scheme. Also rename USER_GETPWNAM to USER_PWD.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.15 2011/12/13 21:44:47 gilles Exp $	*/
d78 1
a78 1
	char *sep;
d100 7
a106 2
		if ((sep = strchr(username, '+')) != NULL)
			*sep = '\0';
d139 7
@


1.15
log
@- introduce delivery backend API (delivery.c)
- move each delivery method to it's own delivery backend
- simplify smtpd.c accordingly
- rename A_EXT -> A_MDA since that's what we really do

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.14 2011/12/12 16:45:16 chl Exp $	*/
d112 1
a112 1
		ub = user_backend_lookup(USER_GETPWNAM);
d514 1
a514 1
				ub = user_backend_lookup(USER_GETPWNAM);
d539 1
a539 1
				ub = user_backend_lookup(USER_GETPWNAM);
@


1.14
log
@remove comments about dead "struct delivery"

"obvious ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.13 2011/12/08 17:00:28 todd Exp $	*/
d129 1
a129 1
		case A_EXT:
d384 1
a384 1
		case A_EXT: {
d486 1
a486 1
		ep->agent.mda.method = A_EXT;
d624 1
a624 1
	case A_EXT:
@


1.13
log
@rename struct user to struct mta_user to avoid namespace conflict elsewhere
ok chl@@ & gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.12 2011/10/25 10:25:51 eric Exp $	*/
a416 2
//	struct delivery *dlv;
//	struct delivery olddlv;
a502 1
//	struct delivery *dlv = &ep->delivery;
@


1.12
log
@rewrite the sender user/domain as specified in the manpage when matching
a "relay... as" rule.

mikeb can now send mails.

ok gilles@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.11 2011/10/23 09:30:07 gilles Exp $	*/
d80 1
a80 1
	struct user u;
d503 1
a503 1
	struct user u;
@


1.11
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.10 2011/10/22 18:03:27 eric Exp $	*/
d398 12
a409 2
		if (ep->rule.r_as)
			new_ep->sender = *ep->rule.r_as;
@


1.10
log
@correctly set relay when expanding envelopes

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.9 2011/08/27 22:32:41 gilles Exp $	*/
d84 1
a84 1
	if (ep->delivery.type == D_MTA) {
d93 2
a94 2
		if (ep->delivery.agent.mda.to.user[0] == '\0')
			user = ep->delivery.rcpt.user;
d96 1
a96 1
			user = ep->delivery.agent.mda.to.user;
d116 2
a117 2
		(void)strlcpy(ep->delivery.agent.mda.as_user, u.username,
		    sizeof (ep->delivery.agent.mda.as_user));
d119 1
a119 1
		ep->delivery.type = D_MDA;
d122 2
a123 2
			ep->delivery.agent.mda.method = A_MBOX;
			(void)strlcpy(ep->delivery.agent.mda.to.user,
d125 1
a125 1
			    sizeof (ep->delivery.agent.mda.to.user));
d130 2
a131 2
			ep->delivery.agent.mda.method = ep->rule.r_action;
			(void)strlcpy(ep->delivery.agent.mda.to.buffer,
d133 1
a133 1
			    sizeof (ep->delivery.agent.mda.to.buffer));
d145 1
a145 1
		if (aliases_virtual_exist(ep->rule.r_condition.c_map, &ep->delivery.rcpt)) {
d147 1
a147 1
				&lks->expandtree, &ep->delivery.rcpt))
d376 2
a377 2
	if (new_ep->delivery.type == D_MDA) {
		d_mda = &new_ep->delivery.agent.mda;
d394 2
a395 1
	} else if (new_ep->delivery.type == D_MTA) {
d397 1
a397 1
			new_ep->delivery.agent.mta.relay = ep->rule.r_value.relayhost;
d399 1
a399 1
			new_ep->delivery.from = *ep->rule.r_as;
d407 3
a409 2
	struct delivery *dlv;
	struct delivery olddlv;
d411 2
a412 3
	dlv = &ep->delivery;
	memcpy(&olddlv, dlv, sizeof (*dlv));
        bzero(&dlv->agent, sizeof (dlv->agent));
d423 1
a423 1
		dlv->rcpt = xn->u.mailaddr;
d429 1
a429 1
		dlv->flags |= DF_INTERNAL;
d437 2
a438 2
		dlv->type  = D_MDA;
		dlv->agent.mda.to = xn->u;
d452 1
a452 1
			ep->delivery.agent.mda.method = olddlv.agent.mda.method;
d457 4
a460 4
		(void)strlcpy(dlv->agent.mda.to.user, xn->u.user,
		    sizeof (dlv->agent.mda.to.user));
		(void)strlcpy(dlv->agent.mda.as_user, xn->u.user,
		    sizeof (dlv->agent.mda.as_user));
d466 5
a470 5
		dlv->type  = D_MDA;
		dlv->agent.mda.to = xn->u;
		dlv->agent.mda.method = A_FILENAME;
		(void)strlcpy(dlv->agent.mda.as_user, xn->as_user,
		    sizeof (dlv->agent.mda.as_user));
d476 5
a480 5
		dlv->type  = D_MDA;
		dlv->agent.mda.to = xn->u;
		dlv->agent.mda.method = A_EXT;
		(void)strlcpy(dlv->agent.mda.as_user, xn->as_user,
		    sizeof (dlv->agent.mda.as_user));
d495 1
a495 1
	struct delivery *dlv = &ep->delivery;
d508 1
a508 1
				if (! ub->getbyname(&u, dlv->agent.mda.as_user))
d553 1
a553 1
				string = dlv->from.user;
d556 1
a556 1
				string = dlv->from.domain;
d559 1
a559 1
				string = dlv->agent.mda.as_user;
d562 1
a562 1
				string = dlv->rcpt.user;
d565 1
a565 1
				string = dlv->rcpt.domain;
d608 1
a608 1
		ep->delivery.type = D_MTA;
d618 1
a618 1
		ep->delivery.type = D_MDA;
d621 1
a621 1
		ep->delivery.type = D_MTA;
@


1.9
log
@initial support for a session-time filtering API

currently only HELO/EHLO, MAIL, RCPT are supported, however ... I have
voluntarily disabled filters at smtpd.conf level so people don't play with
it until the API has stabilized a bit

discussed with several people in private, no one opposed the feature
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.8 2011/07/04 19:44:31 gilles Exp $	*/
d394 3
a396 2
	}
	else if (new_ep->delivery.type == D_MTA) {
@


1.8
log
@%u in format string is rcpt.user not rcpt.domain

From Tim van der Molen <tbvdm@@xs4all.nl>
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.7 2011/06/09 17:41:52 gilles Exp $	*/
a652 1

@


1.7
log
@'relay as' and 'relay via as' rules allow smtpd to rewrite the user part,
the domain part or the entire address of the sender at the SMTP sesssion
level. this is not masquerade but allows smtpd to communicate with hosts
that do a check of SMTP sender fqdn.

sent to tech@@, a couple 'no regression' feedbacks
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.6 2011/05/21 18:11:40 gilles Exp $	*/
d560 1
a560 1
				string = dlv->rcpt.domain;
@


1.6
log
@these log_debug()s should not have been committed :)
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.4 2011/05/17 18:54:32 gilles Exp $	*/
d394 4
@


1.5
log
@when a user add himself to his own ~/.forward, the delivery method was not
reset by ruleset matching and since it was cleared upon entering
lka_session_resolve_node(), it would trigger a fatal().
@
text
@a118 2
		log_debug("###1");

a121 1
			log_debug("###1.1");
a129 1
			log_debug("###1.2");
a139 1
		log_debug("###2");
d241 1
a241 1
	log_debug("#2plop: %d", ep->delivery.agent.mda.method);
a249 2

	log_debug("#1plop: %d", ep->delivery.agent.mda.method);
@


1.4
log
@introduce new user_backend API for smtpd to lookup the users it wants to
deliver mail to. the only backend supported for now is USER_GETPWNAM and
it is not yet possible to switch to an alternate backend.

yes this means that we're very close from smtpd being able to handle fully
virtual accounts for both incoming and outgoing messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.3 2011/05/16 21:52:53 gilles Exp $	*/
d119 2
d124 1
d133 1
d143 2
d177 1
d246 1
a246 1

d256 2
d409 1
d412 1
d452 2
a453 1
		if (strcmp(xn->u.user, xn->as_user) == 0)
d455 1
@


1.3
log
@remove useless assignation
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.2 2011/05/16 21:42:03 gilles Exp $	*/
a31 1
#include <pwd.h>
a76 1
	struct passwd *pw;
d79 2
d111 3
a113 1
		if ((pw = getpwnam(username)) == NULL)
d116 1
a116 1
		(void)strlcpy(ep->delivery.agent.mda.as_user, pw->pw_name,
d123 2
a124 1
			(void)strlcpy(ep->delivery.agent.mda.to.user, pw->pw_name,
d139 1
a139 1
		lka_session_request_forwardfile(lks, ep, pw->pw_name);
d480 2
a481 1
	struct passwd *pw;
d493 4
a496 2
				pw = getpwnam(dlv->agent.mda.as_user);
				if (pw == NULL)
d499 1
a499 1
				lret = strlcat(pbuf, pw->pw_dir, len);
d518 4
a521 3
				
				pw = getpwnam(username);
				if (pw == NULL)
d524 1
a524 1
				lret = strlcat(pbuf, pw->pw_dir, len);
@


1.2
log
@when a C_VDOM recipient expands to a local user, envelope expansion will
reprocess the envelope. since the original condition we matched is still
C_VDOM, it triggers an expansion loop causing recipient to be rejected.

this *should* fix the issue experienced by armani@@, it does on my laptop.
@
text
@d1 1
a1 1
/*	$OpenBSD: lka_session.c,v 1.1 2011/05/16 21:05:51 gilles Exp $	*/
a220 1
	ret = 0;
@


1.1
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d427 10
@

