head	1.20;
access;
symbols
	OPENBSD_6_0:1.17.0.6
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.20
date	2017.03.21.12.06.56;	author bluhm;	state Exp;
branches;
next	1.19;
commitid	6uuBMurt3Uh42fgX;

1.19
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.18;
commitid	eA8b246voAapPTkX;

1.18
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.17;
commitid	jM4eOMW1AJwdfKrr;

1.17
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.16;
commitid	ZxnqOQqX6IeYI9jW;

1.16
date	2014.07.08.10.30.52;	author eric;	state Exp;
branches;
next	1.15;
commitid	GDt5TYwvHfHsoUc2;

1.15
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2011.10.22.00.16.33;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2011.09.11.21.45.16;	author chl;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.19.20.57.10;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.04.17.24.13;	author cloder;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.17.21.56.18;	author chl;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.20
log
@From a syslog perspective it does not make sense to log fatal and
warn with the same severity.  Switch log_warn() to LOG_ERR and keep
fatal() at LOG_CRIT.
OK reyk@@ florian@@
@
text
@/*	$OpenBSD: log.c,v 1.19 2017/01/09 14:49:22 reyk Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <syslog.h>
#include <errno.h>
#include <time.h>

static int	 debug;
static int	 verbose;
const char	*log_procname;

void	log_init(int, int);
void	log_procinit(const char *);
void	log_setverbose(int);
int	log_getverbose(void);
void	log_warn(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list)
	    __attribute__((__format__ (printf, 2, 0)));
__dead void fatal(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));

void
log_init(int n_debug, int facility)
{
	extern char	*__progname;

	debug = n_debug;
	verbose = n_debug;
	log_procinit(__progname);

	if (!debug)
		openlog(__progname, LOG_PID | LOG_NDELAY, facility);

	tzset();
}

void
log_procinit(const char *procname)
{
	if (procname != NULL)
		log_procname = procname;
}

void
log_setverbose(int v)
{
	verbose = v;
}

int
log_getverbose(void)
{
	return (verbose);
}

void
logit(int pri, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vlog(pri, fmt, ap);
	va_end(ap);
}

void
vlog(int pri, const char *fmt, va_list ap)
{
	char	*nfmt;
	int	 saved_errno = errno;

	if (debug) {
		/* best effort in out of mem situations */
		if (asprintf(&nfmt, "%s\n", fmt) == -1) {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		} else {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
		}
		fflush(stderr);
	} else
		vsyslog(pri, fmt, ap);

	errno = saved_errno;
}

void
log_warn(const char *emsg, ...)
{
	char		*nfmt;
	va_list		 ap;
	int		 saved_errno = errno;

	/* best effort to even work in out of memory situations */
	if (emsg == NULL)
		logit(LOG_ERR, "%s", strerror(saved_errno));
	else {
		va_start(ap, emsg);

		if (asprintf(&nfmt, "%s: %s", emsg,
		    strerror(saved_errno)) == -1) {
			/* we tried it... */
			vlog(LOG_ERR, emsg, ap);
			logit(LOG_ERR, "%s", strerror(saved_errno));
		} else {
			vlog(LOG_ERR, nfmt, ap);
			free(nfmt);
		}
		va_end(ap);
	}

	errno = saved_errno;
}

void
log_warnx(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_ERR, emsg, ap);
	va_end(ap);
}

void
log_info(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_INFO, emsg, ap);
	va_end(ap);
}

void
log_debug(const char *emsg, ...)
{
	va_list	 ap;

	if (verbose > 1) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

static void
vfatalc(int code, const char *emsg, va_list ap)
{
	static char	s[BUFSIZ];
	const char	*sep;

	if (emsg != NULL) {
		(void)vsnprintf(s, sizeof(s), emsg, ap);
		sep = ": ";
	} else {
		s[0] = '\0';
		sep = "";
	}
	if (code)
		logit(LOG_CRIT, "%s: %s%s%s",
		    log_procname, s, sep, strerror(code));
	else
		logit(LOG_CRIT, "%s%s%s", log_procname, sep, s);
}

void
fatal(const char *emsg, ...)
{
	va_list	ap;

	va_start(ap, emsg);
	vfatalc(errno, emsg, ap);
	va_end(ap);
	exit(1);
}

void
fatalx(const char *emsg, ...)
{
	va_list	ap;

	va_start(ap, emsg);
	vfatalc(0, emsg, ap);
	va_end(ap);
	exit(1);
}
@


1.19
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.33 2017/01/08 20:31:03 reyk Exp $	*/
d127 1
a127 1
		logit(LOG_CRIT, "%s", strerror(saved_errno));
d134 2
a135 2
			vlog(LOG_CRIT, emsg, ap);
			logit(LOG_CRIT, "%s", strerror(saved_errno));
d137 1
a137 1
			vlog(LOG_CRIT, nfmt, ap);
d152 1
a152 1
	vlog(LOG_CRIT, emsg, ap);
@


1.18
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2016/11/24 21:39:45 reyk Exp $	*/
d27 2
a28 2
int		 debug;
int		 verbose;
d33 2
a34 1
void	log_verbose(int);
d75 1
a75 1
log_verbose(int v)
d78 6
@


1.17
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.16 2014/07/08 10:30:52 eric Exp $	*/
d14 3
a16 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
a18 8
#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>

#include <errno.h>
#include <pwd.h>
#include <stdarg.h>
d21 1
d24 1
d27 23
a49 1
#include "log.h"
d51 4
a54 1
#define	TRACE_DEBUG	0x1
d56 3
a58 2
static int	 foreground;
static int	 verbose;
d60 2
a61 3
void	 vlog(int, const char *, va_list);
void	 logit(int, const char *, ...)
    __attribute__((format (printf, 2, 3)));
d63 2
d67 1
a67 1
log_init(int n_foreground)
d69 2
a70 7
	extern char	*__progname;

	foreground = n_foreground;
	if (!foreground)
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_MAIL);

	tzset();
d93 1
d95 1
a95 1
	if (foreground) {
d107 2
a110 1

d114 3
a116 2
	char	*nfmt;
	va_list	 ap;
d120 1
a120 1
		logit(LOG_CRIT, "%s", strerror(errno));
d124 2
a125 1
		if (asprintf(&nfmt, "%s: %s", emsg, strerror(errno)) == -1) {
d128 1
a128 1
			logit(LOG_CRIT, "%s", strerror(errno));
d135 2
d164 1
a164 13
	if (verbose & TRACE_DEBUG) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

void
log_trace(int mask, const char *emsg, ...)
{
	va_list	 ap;

	if (verbose & mask) {
d172 1
a172 1
fatal_arg(const char *emsg, va_list ap)
d174 2
a175 2
#define	FATALBUFSIZE	1024
	static char	ebuffer[FATALBUFSIZE];
d177 6
a182 10
	if (emsg == NULL)
		(void)strlcpy(ebuffer, strerror(errno), sizeof ebuffer);
	else {
		if (errno) {
			(void)vsnprintf(ebuffer, sizeof ebuffer, emsg, ap);
			(void)strlcat(ebuffer, ": ", sizeof ebuffer);
			(void)strlcat(ebuffer, strerror(errno), sizeof ebuffer);
		}
		else
			(void)vsnprintf(ebuffer, sizeof ebuffer, emsg, ap);
d184 5
a188 1
	logit(LOG_CRIT, "fatal: %s", ebuffer);
d197 1
a197 1
	fatal_arg(emsg, ap);
a206 1
	errno = 0;
d208 1
a208 1
	fatal_arg(emsg, ap);
@


1.16
log
@Change fatal/fatalx to use a format string.  Expand in a static buffer
to cope with low-memory situations.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
a51 1
	if (! foreground)
@


1.15
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.14 2013/01/26 09:37:23 gilles Exp $	*/
d161 2
a162 2
void
fatal(const char *emsg)
d164 3
d168 7
a174 5
		logit(LOG_CRIT, "fatal: %s", strerror(errno));
	else
		if (errno)
			logit(LOG_CRIT, "fatal: %s: %s",
			    emsg, strerror(errno));
d176 4
a179 1
			logit(LOG_CRIT, "fatal: %s", emsg);
d181 8
d193 1
a193 1
fatalx(const char *emsg)
d195 2
d198 4
a201 1
	fatal(emsg);
@


1.14
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.12 2011/10/22 00:16:33 eric Exp $	*/
a21 1
#include <sys/param.h>
d35 3
a37 1
static int	 debug;
d46 1
a46 1
log_init(int n_debug)
d50 2
a51 4
	debug = n_debug;
	verbose = n_debug;

	if (!debug)
d78 1
a78 1
	if (debug) {
d142 1
a142 1
	if (verbose) {
@


1.13
log
@knf

ok gilles@@
@
text
@d36 2
a37 2
int	 debug;
int	 verbose;
@


1.12
log
@Add a log_trace() call to toggle logging of specific debugging info in
verbose mode, and an associated -T command line option.  Use it for
the imsg traces.

Requested by gilles@@ who doesn't like verbose to be too verbose.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.11 2011/09/11 21:45:16 chl Exp $	*/
d41 1
a41 1
    __attribute__ ((format (printf, 2, 3)));
@


1.11
log
@remove unused header

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.10 2010/11/28 13:56:43 gilles Exp $	*/
d144 12
@


1.10
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.9 2010/10/09 22:05:35 gilles Exp $	*/
a25 1
#include <event.h>
@


1.9
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2010/05/19 20:57:10 gilles Exp $	*/
d35 1
a35 1
#include "smtpd.h"
@


1.8
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2010/05/31 23:38:56 jacekm Exp $	*/
d54 1
a54 1
		openlog(__progname, LOG_NDELAY, LOG_MAIL);
@


1.7
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2010/05/19 20:57:10 gilles Exp $	*/
d54 1
a54 1
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_MAIL);
@


1.6
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d54 1
a54 1
		openlog(__progname, LOG_NDELAY, LOG_MAIL);
@


1.5
log
@cleanup-only commit, removes unrequired includes, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.4 2010/01/03 14:37:37 chl Exp $	*/
d54 1
a54 1
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_MAIL);
@


1.4
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2008/12/04 17:24:13 cloder Exp $	*/
a23 1
#include <sys/time.h>
@


1.3
log
@Declare printf-style functions with __attribute__((format(printf,x,x)))
and fix some of the errors caught by this. Part of a general push to
make yyerror() -Wformat clean throughout the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2008/11/17 21:56:18 chl Exp $	*/
d39 1
d52 1
d61 6
d145 1
a145 1
	if (debug > 1) {
@


1.2
log
@add missing header needed by time(), ctime_r() and tzset().

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.1 2008/11/01 21:35:28 gilles Exp $	*/
d41 3
a43 1
void	 logit(int, const char *, ...);
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.11 2007/12/07 17:17:00 reyk Exp $	*/
d34 1
@

