head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.2
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2;
locks; strict;
comment	@ * @;


1.25
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.24;
commitid	jM4eOMW1AJwdfKrr;

1.24
date	2016.11.30.11.52.48;	author eric;	state Exp;
branches;
next	1.23;
commitid	HLHuvF4EZizEJJ0M;

1.23
date	2016.11.22.07.28.42;	author eric;	state Exp;
branches;
next	1.22;
commitid	8fz9wejpFY08v5WO;

1.22
date	2016.11.21.13.00.43;	author eric;	state Exp;
branches;
next	1.21;
commitid	pP1uMFU0IrsBTn27;

1.21
date	2016.11.20.08.43.36;	author eric;	state Exp;
branches;
next	1.20;
commitid	WsInk7NbLdaIQWny;

1.20
date	2016.11.16.21.30.37;	author eric;	state Exp;
branches;
next	1.19;
commitid	3uoi1oHbQkJMXEjt;

1.19
date	2016.06.29.06.46.06;	author eric;	state Exp;
branches;
next	1.18;
commitid	Zr1tUk1x7OqbFhmN;

1.18
date	2016.05.16.19.25.05;	author gilles;	state Exp;
branches;
next	1.17;
commitid	MArJCIQmAKtpqVOA;

1.17
date	2016.03.25.15.06.58;	author krw;	state Exp;
branches;
next	1.16;
commitid	0NIU7T9t8yqZHZQl;

1.16
date	2016.02.03.11.14.08;	author eric;	state Exp;
branches
	1.16.2.1;
next	1.15;
commitid	5AxfQdZpyZZNLpJF;

1.15
date	2016.01.29.12.43.38;	author eric;	state Exp;
branches;
next	1.14;
commitid	5wYXo3fJgf4r2S5c;

1.14
date	2016.01.29.10.49.53;	author eric;	state Exp;
branches;
next	1.13;
commitid	Uz9fGyDEacha22Ut;

1.13
date	2016.01.29.08.06.27;	author eric;	state Exp;
branches;
next	1.12;
commitid	RyzzwNlVCKMXjWCE;

1.12
date	2016.01.28.09.03.35;	author eric;	state Exp;
branches;
next	1.11;
commitid	0E67gLSTKRPwkArm;

1.11
date	2016.01.27.08.36.35;	author eric;	state Exp;
branches;
next	1.10;
commitid	v0j7ZSWBAAVVIFMb;

1.10
date	2015.12.14.10.28.50;	author sunil;	state Exp;
branches;
next	1.9;
commitid	xF1z2AmNWgJkTGKB;

1.9
date	2015.11.24.08.40.10;	author gilles;	state Exp;
branches;
next	1.8;
commitid	LToabJzbFOzI6zYA;

1.8
date	2012.06.16.16.16.09;	author chl;	state dead;
branches;
next	1.7;

1.7
date	2012.06.14.21.56.13;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2012.01.18.13.41.54;	author chl;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.28.22.13.27;	author chl;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.16.10.24.41;	author chl;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.15.23.22.47;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2011.08.31.18.56.30;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2011.08.27.22.32.41;	author gilles;	state Exp;
branches;
next	;

1.16.2.1
date	2016.05.16.19.29.13;	author gilles;	state Exp;
branches;
next	;
commitid	EksDywL8AfqDY78p;


desc
@@


1.25
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@/*	$OpenBSD: filter.c,v 1.24 2016/11/30 11:52:48 eric Exp $	*/

/*
 * Copyright (c) 2011 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <inttypes.h>
#include <limits.h>
#include <resolv.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

enum {
	QUERY_READY,
	QUERY_RUNNING,
	QUERY_DONE
};


struct filter_proc {
	TAILQ_ENTRY(filter_proc)	 entry;
	struct mproc			 mproc;
	int				 hooks;
	int				 flags;
	int				 ready;
};

struct filter {
	TAILQ_ENTRY(filter)		 entry;
	struct filter_proc		*proc;
};
TAILQ_HEAD(filter_lst, filter);

TAILQ_HEAD(filter_query_lst, filter_query);
struct filter_session {
	uint64_t		 id;
	int			 terminate;
	struct filter_lst	*filters;
	struct filter		*fcurr;

	int			 error;
	struct io		*iev;
	size_t			 idatalen;
	FILE			*ofile;

	struct filter_query	*eom;
};

struct filter_query {
	uint64_t			 qid;
	int				 type;
	struct filter_session		*session;

	int				 state;
	struct filter			*current;

	/* current data */
	union {
		struct {
			struct sockaddr_storage	 local;
			struct sockaddr_storage	 remote;
			char			 hostname[HOST_NAME_MAX+1];
		} connect;
		char			line[LINE_MAX];
		struct mailaddr		maddr;
		size_t			datalen;
	} u;

	/* current response */
	struct {
		int	 status;
		int	 code;
		char	*response;
	} smtp;
};

static void filter_imsg(struct mproc *, struct imsg *);
static void filter_post_event(uint64_t, int, struct filter *, struct filter *);
static struct filter_query *filter_query(struct filter_session *, int);
static void filter_drain_query(struct filter_query *);
static void filter_run_query(struct filter *, struct filter_query *);
static void filter_end_query(struct filter_query *);
static void filter_set_sink(struct filter_session *, int);
static int filter_tx(struct filter_session *, int);
static void filter_tx_io(struct io *, int, void *);

static TAILQ_HEAD(, filter_proc)	procs;
struct dict				chains;

static const char * filter_session_to_text(struct filter_session *);
static const char * filter_query_to_text(struct filter_query *);
static const char * filter_to_text(struct filter *);
static const char * filter_proc_to_text(struct filter_proc *);
static const char * query_to_str(int);
static const char * event_to_str(int);
static const char * status_to_str(int);
static const char * filterimsg_to_str(int);

struct tree	sessions;
struct tree	queries;

static void
filter_add_arg(struct filter_conf *filter, char *arg)
{
	if (filter->argc == MAX_FILTER_ARGS) {
		log_warnx("warn: filter \"%s\" is full", filter->name);
		fatalx("exiting");
	}
	filter->argv[filter->argc++] = arg;
}

static void
filter_extend_chain(struct filter_lst *chain, const char *name)
{
	struct filter		*n;
	struct filter_lst	*fchain;
	struct filter_conf	*fconf;
	int			 i;

	fconf = dict_xget(&env->sc_filters, name);
	if (fconf->chain) {
		log_debug("filter: extending with \"%s\"", name);
		for (i = 0; i < fconf->argc; i++)
			filter_extend_chain(chain, fconf->argv[i]);
	}
	else {
		log_debug("filter: adding filter \"%s\"", name);
		n = xcalloc(1, sizeof(*n), "filter_extend_chain");
		fchain = dict_get(&chains, name);
		n->proc = TAILQ_FIRST(fchain)->proc;
		TAILQ_INSERT_TAIL(chain, n, entry);
	}
}

void
filter_postfork(void)
{
	static int		 prepare = 0;
	struct filter_conf	*filter;
	void			*iter;
	struct filter_proc	*proc;
	struct filter_lst	*fchain;
	struct filter		*f;
	struct mproc		*p;
	int			 done, i;

	if (prepare)
		return;
	prepare = 1;

	TAILQ_INIT(&procs);
	dict_init(&chains);

	log_debug("filter: building simple chains...");

	/* create all filter proc and associated chains */
	iter = NULL;
	while (dict_iter(&env->sc_filters, &iter, NULL, (void **)&filter)) {
		if (filter->chain)
			continue;

		log_debug("filter: building simple chain \"%s\"", filter->name);
		proc = xcalloc(1, sizeof(*proc), "filter_postfork");
		p = &proc->mproc;
		p->handler = filter_imsg;
		p->proc = PROC_FILTER;
		p->name = xstrdup(filter->name, "filter_postfork");
		p->data = proc;
		if (tracing & TRACE_DEBUG)
			filter_add_arg(filter, "-v");
		if (foreground_log)
			filter_add_arg(filter, "-d");
		if (mproc_fork(p, filter->path, filter->argv) < 0)
			fatalx("filter_postfork");

		log_debug("filter: registering proc \"%s\"", filter->name);
		f = xcalloc(1, sizeof(*f), "filter_postfork");
		f->proc = proc;

		TAILQ_INSERT_TAIL(&procs, proc, entry);
		fchain = xcalloc(1, sizeof(*fchain), "filter_postfork");
		TAILQ_INIT(fchain);
		TAILQ_INSERT_TAIL(fchain, f, entry);
		dict_xset(&chains, filter->name, fchain);
		filter->done = 1;
	}

	log_debug("filter: building complex chains...");

	/* resolve all chains */
	done = 0;
	while (!done) {
		done = 1;
		iter = NULL;
		while (dict_iter(&env->sc_filters, &iter, NULL,
		    (void **)&filter)) {
			if (filter->done)
				continue;
			done = 0;
			filter->done = 1;
			for (i = 0; i < filter->argc; i++) {
				if (!dict_get(&chains, filter->argv[i])) {
					filter->done = 0;
					break;
				}
			}
			if (filter->done == 0)
				continue;
			fchain = xcalloc(1, sizeof(*fchain), "filter_postfork");
			TAILQ_INIT(fchain);
			log_debug("filter: building chain \"%s\"...",
			    filter->name);
			for (i = 0; i < filter->argc; i++)
				filter_extend_chain(fchain, filter->argv[i]);
			log_debug("filter: done building chain \"%s\"",
			    filter->name);
			dict_xset(&chains, filter->name, fchain);
		}
	}
	log_debug("filter: done building complex chains");

	fchain = xcalloc(1, sizeof(*fchain), "filter_postfork");
	TAILQ_INIT(fchain);
	dict_xset(&chains, "<no-filter>", fchain);
}

void
filter_configure(void)
{
	static int		 init = 0;
	struct filter_proc	*p;

	if (init)
		return;
	init = 1;

	tree_init(&sessions);
	tree_init(&queries);

	TAILQ_FOREACH(p, &procs, entry) {
		m_create(&p->mproc, IMSG_FILTER_REGISTER, 0, 0, -1);
		m_add_u32(&p->mproc, FILTER_API_VERSION);
		m_add_string(&p->mproc, p->mproc.name);
		m_close(&p->mproc);
		mproc_enable(&p->mproc);
	}

	if (TAILQ_FIRST(&procs) == NULL)
		smtp_configure();
}

void
filter_event(uint64_t id, int event)
{
	struct filter_session	*s;

	if (event == EVENT_DISCONNECT)
		/* On disconnect, the session is virtualy dead */
		s = tree_xpop(&sessions, id);
	else
		s = tree_xget(&sessions, id);

	filter_post_event(id, event, TAILQ_FIRST(s->filters), NULL);

	if (event == EVENT_DISCONNECT) {
		if (s->iev)
			io_free(s->iev);
		if (s->ofile)
			fclose(s->ofile);
		free(s);
	}
}

void
filter_connect(uint64_t id, const struct sockaddr *local,
    const struct sockaddr *remote, const char *host, const char *filter)
{
	struct filter_session	*s;
	struct filter_query	*q;

	s = xcalloc(1, sizeof(*s), "filter_event");
	s->id = id;
	if (filter == NULL)
		filter = "<no-filter>";
	s->filters = dict_xget(&chains, filter);
	tree_xset(&sessions, s->id, s);

	filter_event(id, EVENT_CONNECT);
	q = filter_query(s, QUERY_CONNECT);

	memmove(&q->u.connect.local, local, local->sa_len);
	memmove(&q->u.connect.remote, remote, remote->sa_len);
	strlcpy(q->u.connect.hostname, host, sizeof(q->u.connect.hostname));

	q->smtp.status = FILTER_OK;
	q->smtp.code = 0;
	q->smtp.response = NULL;

	filter_drain_query(q);
}

void
filter_mailaddr(uint64_t id, int type, const struct mailaddr *maddr)
{
	struct filter_session	*s;
	struct filter_query	*q;

	s = tree_xget(&sessions, id);
	q = filter_query(s, type);

	strlcpy(q->u.maddr.user, maddr->user, sizeof(q->u.maddr.user));
	strlcpy(q->u.maddr.domain, maddr->domain, sizeof(q->u.maddr.domain));

	filter_drain_query(q);
}

void
filter_line(uint64_t id, int type, const char *line)
{
	struct filter_session	*s;
	struct filter_query	*q;

	s = tree_xget(&sessions, id);
	q = filter_query(s, type);

	if (line)
		strlcpy(q->u.line, line, sizeof(q->u.line));

	filter_drain_query(q);
}

void
filter_eom(uint64_t id, int type, size_t datalen)
{
	struct filter_session	*s;
	struct filter_query	*q;

	s = tree_xget(&sessions, id);
	q = filter_query(s, type);
	q->u.datalen = datalen;

	filter_drain_query(q);
}

static void
filter_set_sink(struct filter_session *s, int sink)
{
	struct mproc	*p;

	while (s->fcurr) {
		if (s->fcurr->proc->hooks & HOOK_DATALINE) {
			log_trace(TRACE_FILTERS, "filter: sending fd %d to %s",
			    sink, filter_to_text(s->fcurr));
			p = &s->fcurr->proc->mproc;
			m_create(p, IMSG_FILTER_PIPE, 0, 0, sink);
			m_add_id(p, s->id);
			m_close(p);
			return;
		}
		s->fcurr = TAILQ_PREV(s->fcurr, filter_lst, entry);
	}

	log_trace(TRACE_FILTERS, "filter: chain input is %d", sink);
	smtp_filter_fd(s->id, sink);
}

void
filter_build_fd_chain(uint64_t id, int sink)
{
	struct filter_session	*s;
	int			 fd;

	s = tree_xget(&sessions, id);
	s->fcurr = TAILQ_LAST(s->filters, filter_lst);

	fd = filter_tx(s, sink);
	filter_set_sink(s, fd);
}

void
filter_post_event(uint64_t id, int event, struct filter *f, struct filter *end)
{
	for(; f && f != end; f = TAILQ_NEXT(f, entry)) {
		log_trace(TRACE_FILTERS, "filter: post-event event=%s filter=%s",
		    event_to_str(event), f->proc->mproc.name);

		m_create(&f->proc->mproc, IMSG_FILTER_EVENT, 0, 0, -1);
		m_add_id(&f->proc->mproc, id);
		m_add_int(&f->proc->mproc, event);
		m_close(&f->proc->mproc);
	}
}

static struct filter_query *
filter_query(struct filter_session *s, int type)
{
	struct filter_query	*q;

	q = xcalloc(1, sizeof(*q), "filter_query");
	q->qid = generate_uid();
	q->session = s;
	q->type = type;

	q->state = QUERY_READY;
	q->current = TAILQ_FIRST(s->filters);

	log_trace(TRACE_FILTERS, "filter: new query %s", query_to_str(type));

	return (q);
}

static void
filter_drain_query(struct filter_query *q)
{
	log_trace(TRACE_FILTERS, "filter: filter_drain_query %s",
	    filter_query_to_text(q));

	/*
	 * The query must be passed through all filters that registered
	 * a hook, until one rejects it.
	 */
	while (q->state != QUERY_DONE) {
		/* Walk over all filters */
		while (q->current) {
			filter_run_query(q->current, q);
			if (q->state == QUERY_RUNNING) {
				log_trace(TRACE_FILTERS,
				    "filter: waiting for running query %s",
				    filter_query_to_text(q));
				return;
			}
		}
		q->state = QUERY_DONE;
	}

	/* Defer the response if the file is not closed yet. */
	if (q->type == QUERY_EOM && q->session->ofile && q->smtp.status == FILTER_OK) {
		log_debug("filter: deferring eom query...");
		q->session->eom = q;
		return;
	}

	filter_end_query(q);
}

static void
filter_run_query(struct filter *f, struct filter_query *q)
{
	log_trace(TRACE_FILTERS,
	    "filter: running filter %s for query %s",
	    filter_to_text(f), filter_query_to_text(q));

	m_create(&f->proc->mproc, IMSG_FILTER_QUERY, 0, 0, -1);
	m_add_id(&f->proc->mproc, q->session->id);
	m_add_id(&f->proc->mproc, q->qid);
	m_add_int(&f->proc->mproc, q->type);

	switch (q->type) {
	case QUERY_CONNECT:
		m_add_sockaddr(&f->proc->mproc,
		    (struct sockaddr *)&q->u.connect.local);
		m_add_sockaddr(&f->proc->mproc,
		    (struct sockaddr *)&q->u.connect.remote);
		m_add_string(&f->proc->mproc, q->u.connect.hostname);
		break;
	case QUERY_HELO:
		m_add_string(&f->proc->mproc, q->u.line);
		break;
	case QUERY_MAIL:
	case QUERY_RCPT:
		m_add_mailaddr(&f->proc->mproc, &q->u.maddr);
		break;
	case QUERY_EOM:
		m_add_u32(&f->proc->mproc, q->u.datalen);
		break;
	default:
		break;
	}
	m_close(&f->proc->mproc);

	tree_xset(&queries, q->qid, q);
	q->state = QUERY_RUNNING;
}

static void
filter_end_query(struct filter_query *q)
{
	struct filter_session *s = q->session;
	const char *response = q->smtp.response;

	log_trace(TRACE_FILTERS, "filter: filter_end_query %s",
	    filter_query_to_text(q));

	if (q->type == QUERY_EOM && q->smtp.status == FILTER_OK) {
		if (s->error || q->u.datalen != s->idatalen) {
			response = "Internal error";
			q->smtp.code = 451;
			q->smtp.status = FILTER_FAIL;
			if (!s->error)
				log_warnx("filter: datalen mismatch on session %" PRIx64
				    ": %zu/%zu", s->id, s->idatalen, q->u.datalen);
		}
	}

	log_trace(TRACE_FILTERS,
	    "filter: query %016"PRIx64" done: "
	    "status=%s code=%d response=\"%s\"",
	    q->qid,
	    status_to_str(q->smtp.status),
	    q->smtp.code,
	    response);

	smtp_filter_response(s->id, q->type, q->smtp.status, q->smtp.code,
	    response);
	free(q->smtp.response);
	free(q);
}

static void
filter_imsg(struct mproc *p, struct imsg *imsg)
{
	struct filter_proc	*proc = p->data;
	struct filter_session	*s;
	struct filter_query	*q;
	struct msg		 m;
	const char		*line;
	uint64_t		 qid;
	uint32_t		 datalen;
	int			 type, status, code;

	if (imsg == NULL) {
		log_warnx("warn: filter \"%s\" closed unexpectedly", p->name);
		fatalx("exiting");
	}

	log_trace(TRACE_FILTERS, "filter: imsg %s from procfilter %s",
	    filterimsg_to_str(imsg->hdr.type),
	    filter_proc_to_text(proc));

	switch (imsg->hdr.type) {

	case IMSG_FILTER_REGISTER:
		if (proc->ready) {
			log_warnx("warn: filter \"%s\" already registered",
			    proc->mproc.name);
			exit(1);
		}

		m_msg(&m, imsg);
		m_get_int(&m, &proc->hooks);
		m_get_int(&m, &proc->flags);
		m_end(&m);
		proc->ready = 1;

		log_debug("debug: filter \"%s\": hooks 0x%08x flags 0x%04x",
		    proc->mproc.name, proc->hooks, proc->flags);

		TAILQ_FOREACH(proc, &procs, entry)
			if (!proc->ready)
				return;

		smtp_configure();
		break;

	case IMSG_FILTER_RESPONSE:
		m_msg(&m, imsg);
		m_get_id(&m, &qid);
		m_get_int(&m, &type);
		if (type == QUERY_EOM)
			m_get_u32(&m, &datalen);
		m_get_int(&m, &status);
		m_get_int(&m, &code);
		if (m_is_eom(&m))
			line = NULL;
		else
			m_get_string(&m, &line);
		m_end(&m);

		q = tree_xpop(&queries, qid);
		if (q->type != type) {
			log_warnx("warn: filter: type mismatch %d != %d",
			    q->type, type);
			fatalx("exiting");
		}
		q->smtp.status = status;
		if (code)
			q->smtp.code = code;
		if (line) {
			free(q->smtp.response);
			q->smtp.response = xstrdup(line, "filter_imsg");
		}
		q->state = (status == FILTER_OK) ? QUERY_READY : QUERY_DONE;
		if (type == QUERY_EOM)
			q->u.datalen = datalen;

		q->current = TAILQ_NEXT(q->current, entry);
		filter_drain_query(q);
		break;

	case IMSG_FILTER_PIPE:
		m_msg(&m, imsg);
		m_get_id(&m, &qid);
		m_end(&m);

		s = tree_xget(&sessions, qid);
		s->fcurr = TAILQ_PREV(s->fcurr, filter_lst, entry);
		filter_set_sink(s, imsg->fd);
		break;

	default:
		log_warnx("warn: bad imsg from filter %s", p->name);
		exit(1);
	}
}

static int
filter_tx(struct filter_session *s, int sink)
{
	int	sp[2];

	s->idatalen = 0;
	s->eom = NULL;
	s->error = 0;

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, sp) == -1) {
		log_warn("warn: filter: socketpair");
		return (-1);
	}

	if ((s->ofile = fdopen(sink, "w")) == NULL) {
		log_warn("warn: filter: fdopen");
		close(sp[0]);
		close(sp[1]);
		return (-1);
	}

	io_set_nonblocking(sp[0]);
	io_set_nonblocking(sp[1]);

	s->iev = io_new();
	io_set_callback(s->iev, filter_tx_io, s);
	io_set_fd(s->iev, sp[0]);
	io_set_read(s->iev);

	return (sp[1]);
}

static void
filter_tx_io(struct io *io, int evt, void *arg)
{
	struct filter_session	*s = arg;
	size_t			 len, n;
	char			*data;

	log_trace(TRACE_FILTERS, "filter: filter_tx_io(%p, %s)",
	    s, io_strevent(evt));

	switch (evt) {
	case IO_DATAIN:
		data = io_data(s->iev);
		len = io_datalen(s->iev);

		log_trace(TRACE_FILTERS,
		    "filter: filter_tx_io: datain (%zu) for req %016"PRIx64"",
		    len, s->id);

		n = fwrite(data, 1, len, s->ofile);
		if (n != len) {
			log_warnx("warn: filter_tx_io: fwrite %zu/%zu", n, len);
			s->error = 1;
			break;
		}
		s->idatalen += n;
		io_drop(s->iev, n);
		return;

	case IO_DISCONNECTED:
		log_trace(TRACE_FILTERS,
		    "debug: filter: tx done (%zu) for req %016"PRIx64,
		    s->idatalen, s->id);
		break;

	default:
		log_warn("warn: filter_tx_io: bad evt (%d) for req %016"PRIx64,
		    evt, s->id);
		s->error = 1;
		break;
	}

	io_free(s->iev);
	s->iev = NULL;
	fclose(s->ofile);
	s->ofile = NULL;

	/* deferred eom request */
	if (s->eom) {
		log_debug("filter: running eom query...");
		filter_end_query(s->eom);
	} else {
		log_debug("filter: eom not received yet");
	}
}

static const char *
filter_query_to_text(struct filter_query *q)
{
	static char buf[1024];
	char tmp[1024];

	tmp[0] = '\0';

	switch (q->type) {
	case QUERY_CONNECT:
		strlcat(tmp, "=", sizeof tmp);
		strlcat(tmp, ss_to_text(&q->u.connect.local),
		    sizeof tmp);
		strlcat(tmp, " <-> ", sizeof tmp);
		strlcat(tmp, ss_to_text(&q->u.connect.remote),
		    sizeof tmp);
		strlcat(tmp, "(", sizeof tmp);
		strlcat(tmp, q->u.connect.hostname, sizeof tmp);
		strlcat(tmp, ")", sizeof tmp);
		break;
	case QUERY_MAIL:
	case QUERY_RCPT:
		snprintf(tmp, sizeof tmp, "=%s@@%s",
		    q->u.maddr.user, q->u.maddr.domain);
		break;
	case QUERY_HELO:
		snprintf(tmp, sizeof tmp, "=%s", q->u.line);
		break;
	default:
		break;
	}
	snprintf(buf, sizeof buf, "%016"PRIx64"[%s%s,%s]",
	    q->qid, query_to_str(q->type), tmp,
	    filter_session_to_text(q->session));

	return (buf);
}

static const char *
filter_session_to_text(struct filter_session *s)
{
	static char buf[1024];

	if (s == NULL)
		return "filter_session@@NULL";

	snprintf(buf, sizeof(buf),
	    "filter_session@@%p[datalen=%zu,eom=%p,ofile=%p]",
	    s, s->idatalen, s->eom, s->ofile);

	return buf;
}

static const char *
filter_to_text(struct filter *f)
{
	static char buf[1024];

	snprintf(buf, sizeof buf, "filter:%s", filter_proc_to_text(f->proc));

	return (buf);
}

static const char *
filter_proc_to_text(struct filter_proc *proc)
{
	static char buf[1024];

	snprintf(buf, sizeof buf, "%s[hooks=0x%08x,flags=0x%04x]",
	    proc->mproc.name, proc->hooks, proc->flags);

	return (buf);
}

#define CASE(x) case x : return #x

static const char *
filterimsg_to_str(int imsg)
{
	switch (imsg) {
	CASE(IMSG_FILTER_REGISTER);
	CASE(IMSG_FILTER_EVENT);
	CASE(IMSG_FILTER_QUERY);
	CASE(IMSG_FILTER_PIPE);
	CASE(IMSG_FILTER_RESPONSE);
	default:
		return "IMSG_FILTER_???";
	}
}

static const char *
query_to_str(int query)
{
	switch (query) {
	CASE(QUERY_CONNECT);
	CASE(QUERY_HELO);
	CASE(QUERY_MAIL);
	CASE(QUERY_RCPT);
	CASE(QUERY_DATA);
	CASE(QUERY_EOM);
	CASE(QUERY_DATALINE);
	default:
		return "QUERY_???";
	}
}

static const char *
event_to_str(int event)
{
	switch (event) {
	CASE(EVENT_CONNECT);
	CASE(EVENT_RESET);
	CASE(EVENT_DISCONNECT);
	CASE(EVENT_TX_BEGIN);
	CASE(EVENT_TX_COMMIT);
	CASE(EVENT_TX_ROLLBACK);
	default:
		return "EVENT_???";
	}
}

static const char *
status_to_str(int status)
{
	switch (status) {
	CASE(FILTER_OK);
	CASE(FILTER_FAIL);
	CASE(FILTER_CLOSE);
	default:
		return "FILTER_???";
	}
}
@


1.24
log
@make struct io opaque:

- move struct io definition to ioev.c
- replace io_init/io_clear with io_new/io_free
- allocate an iobuf for each new io internally
- use struct io pointer in the rest of the code
- remove remaining uses of iobuf_*

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.23 2016/11/22 07:28:42 eric Exp $	*/
d200 1
a200 1
		if (verbose & TRACE_DEBUG)
@


1.23
log
@Normalize the io input buffer internally when reinstalling the io event, so
the caller doesn't have to bother with this.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.22 2016/11/21 13:00:43 eric Exp $	*/
d73 1
a73 2
	struct io		 iev;
	struct iobuf		 ibuf;
d297 2
a298 2
		io_clear(&s->iev);
		iobuf_clear(&s->ibuf);
a316 1
	io_init(&s->iev, NULL);
d671 4
a674 5
	iobuf_init(&s->ibuf, 0, 0);
	io_init(&s->iev, &s->ibuf);
	io_set_callback(&s->iev, filter_tx_io, s);
	io_set_fd(&s->iev, sp[0]);
	io_set_read(&s->iev);
d691 2
a692 2
		data = io_data(&s->iev);
		len = io_datalen(&s->iev);
d705 1
a705 1
		io_drop(&s->iev, n);
d721 2
a722 2
	io_clear(&s->iev);
	iobuf_clear(&s->ibuf);
@


1.22
log
@replace calls to iobuf_*() functions with the corresponding io_*() wrappers.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.21 2016/11/20 08:43:36 eric Exp $	*/
a708 1
		iobuf_normalize(&s->ibuf);
@


1.21
log
@add dedicated functions to set fd and callback on a struct io.
simplify io_init() prototype.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.20 2016/11/16 21:30:37 eric Exp $	*/
d694 2
a695 2
		data = iobuf_data(&s->ibuf);
		len = iobuf_len(&s->ibuf);
d708 1
a708 1
		iobuf_drop(&s->ibuf, n);
@


1.20
log
@pass the user pointer as parameter to the io callback instead of having
the user dereference the io structure.

ok millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.19 2016/06/29 06:46:06 eric Exp $	*/
d318 1
a318 1
	s->iev.sock = -1;
d674 3
a676 1
	io_init(&s->iev, sp[0], s, filter_tx_io, &s->ibuf);
@


1.19
log
@Explicitely enclose SMTP transactions between BEGIN and COMMIT/ROLLBACK
filter events. Bump filter API version.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.18 2016/05/16 19:25:05 gilles Exp $	*/
d117 1
a117 1
static void filter_tx_io(struct io *, int);
d681 1
a681 1
filter_tx_io(struct io *io, int evt)
d683 1
a683 1
	struct filter_session	*s = io->arg;
@


1.18
log
@fix logic in error code path of smtp state machine that can lead to an
invalid state ending in fatal(), while at it plug a file pointer leak.

ok eric@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.17 2016/03/25 15:06:58 krw Exp $	*/
d850 3
a852 2
	CASE(EVENT_COMMIT);
	CASE(EVENT_ROLLBACK);
@


1.17
log
@Nuke session_socket_blockmode() and session_socket_linger(). Use
the identical io_set_blocking() and io_set_linger().

Since both are always called to turn off blocking or lingering,
nuke the parameter and associated enum in favour of "just doing the
right thing".

While passing remove the unneeded last parameter to the remaining
fcntl(F_GETFL).

Finally, rename the functions to io_set_nonblocking() and
io_set_nolinger() for clarity.

No functional change.

Started with a sweep of fcntl() usage inspired by guenther@@.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.16 2016/02/03 11:14:08 eric Exp $	*/
d300 2
@


1.16
log
@When a filter rejects a message content, report immediatly to the
smtp session. Simplify code while here.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.15 2016/01/29 12:43:38 eric Exp $	*/
d668 2
a669 2
	io_set_blocking(sp[0], 0);
	io_set_blocking(sp[1], 0);
@


1.16.2.1
log
@fix logic in error code path of smtp state machine that can lead to invalid
state and result in fatal(), while at it plug file pointer leak.

errata 006

ok eric@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.16 2016/02/03 11:14:08 eric Exp $	*/
a299 2
		if (s->ofile)
			fclose(s->ofile);
@


1.15
log
@remove unused field
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.14 2016/01/29 10:49:53 eric Exp $	*/
d468 1
a468 1
	if (q->type == QUERY_EOM && q->session->ofile) {
d520 1
d525 8
a532 19
	if (q->type == QUERY_EOM) {

		log_trace(TRACE_FILTERS,
		    "filter: filter_end_query(%d, %zu, %zu)", s->iev.sock,
		    s->idatalen, q->u.datalen);

		if (s->error) {
			smtp_filter_response(s->id, QUERY_EOM, FILTER_FAIL,
			    0, NULL);
			free(q->smtp.response);
			goto done;
		}
		else if (q->u.datalen != s->idatalen) {
			log_warnx("filter: datalen mismatch on session %" PRIx64
			    ": %zu/%zu", s->id, s->idatalen, q->u.datalen);
			smtp_filter_response(s->id, QUERY_EOM, FILTER_FAIL,
			    0, NULL);
			free(q->smtp.response);
			goto done;
d542 2
a543 1
	    q->smtp.response);
d545 1
a545 1
	    q->smtp.response);
a546 2

    done:
@


1.14
log
@Simplify code: hasrun is confusing and useless.  There is no way
filter_drain_query() can be called when the ->current filter is
still running the query. Just make sure we move forward after
having received the response from the current filter.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.13 2016/01/29 08:06:27 eric Exp $	*/
a71 2
	struct filter_query_lst	 queries;

a316 1
	TAILQ_INIT(&s->queries);
@


1.13
log
@Remove the query queueing mechanism. It's useless since pipelining is
not supported anyway.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.12 2016/01/28 09:03:35 eric Exp $	*/
a88 1
	int				 hasrun;
a439 1
	q->hasrun = 0;
d459 1
a459 5
			/* Trigger the current filter if not done yet. */
			if (!q->hasrun) {
				filter_run_query(q->current, q);
				q->hasrun = 1;
			}
a465 3

			q->current = TAILQ_NEXT(q->current, entry);
			q->hasrun = 0;
d641 1
@


1.12
log
@Simplify the query-chain code now that events are sent through a dedicated loop.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.11 2016/01/27 08:36:35 eric Exp $	*/
a45 1
	QUERY_WAITING,
a86 1
	TAILQ_ENTRY(filter_query)	 entry;
a437 1
	TAILQ_INSERT_TAIL(&s->queries, q, entry);
a450 2
	struct filter_query	*prev;

a472 13
			/*
			 * Do not move forward if the query ahead of us is
			 * waiting on this filter.
			 */
			prev = TAILQ_PREV(q, filter_query_lst, entry);
			if (prev && prev->current == q->current) {
				q->state = QUERY_WAITING;
				log_trace(TRACE_FILTERS,
				    "filter: query blocked by previous query"
				    "%s", filter_query_to_text(prev));
				return;
			}

a569 1
	TAILQ_REMOVE(&s->queries, q, entry);
d578 1
a578 1
	struct filter_query	*q, *next;
a649 1
		next = TAILQ_NEXT(q, entry);
a650 7

		/*
		 * If there is another query after this one which is waiting,
		 * make it move forward.
		 */
		if (next && next->state == QUERY_WAITING)
			filter_drain_query(next);
@


1.11
log
@send events to filters in a simple loop, rather than using the
query-chaining machinery.

ok jung@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.10 2015/12/14 10:28:50 sunil Exp $	*/
a44 5
	QK_QUERY,
	QK_EVENT,
};

enum {
a85 1
	int				 kind;
d116 1
a116 1
static struct filter_query *filter_query(struct filter_session *, int, int);
a130 1
static const char * kind_to_str(int);
d326 1
a326 1
	q = filter_query(s, QK_QUERY, QUERY_CONNECT);
d346 1
a346 1
	q = filter_query(s, QK_QUERY, type);
d361 1
a361 1
	q = filter_query(s, QK_QUERY, type);
d376 1
a376 1
	q = filter_query(s, QK_QUERY, type);
d432 1
a432 1
filter_query(struct filter_session *s, int kind, int type)
a438 1
	q->kind = kind;
d446 1
a446 6
	if (kind == QK_QUERY)
		log_trace(TRACE_FILTERS, "filter: new query %s %s",
		    kind_to_str(kind), query_to_str(type));
	else
		log_trace(TRACE_FILTERS, "filter: new query %s %s",
		    kind_to_str(kind), event_to_str(type));
d498 1
a498 1
	if (q->kind == QK_QUERY && q->type == QUERY_EOM && q->session->ofile) {
d510 3
a512 1
	if (q->kind == QK_QUERY) {
d514 25
a538 34
		log_trace(TRACE_FILTERS,
		    "filter: running filter %s for query %s",
		    filter_to_text(f), filter_query_to_text(q));

		m_create(&f->proc->mproc, IMSG_FILTER_QUERY, 0, 0, -1);
		m_add_id(&f->proc->mproc, q->session->id);
		m_add_id(&f->proc->mproc, q->qid);
		m_add_int(&f->proc->mproc, q->type);

		switch (q->type) {
		case QUERY_CONNECT:
			m_add_sockaddr(&f->proc->mproc,
			    (struct sockaddr *)&q->u.connect.local);
			m_add_sockaddr(&f->proc->mproc,
			    (struct sockaddr *)&q->u.connect.remote);
			m_add_string(&f->proc->mproc, q->u.connect.hostname);
			break;
		case QUERY_HELO:
			m_add_string(&f->proc->mproc, q->u.line);
			break;
		case QUERY_MAIL:
		case QUERY_RCPT:
			m_add_mailaddr(&f->proc->mproc, &q->u.maddr);
			break;
		case QUERY_EOM:
			m_add_u32(&f->proc->mproc, q->u.datalen);
			break;
		default:
			break;
		}
		m_close(&f->proc->mproc);

		tree_xset(&queries, q->qid, q);
		q->state = QUERY_RUNNING;
d540 1
a540 4
	else {
		log_trace(TRACE_FILTERS,
		    "filter: running filter %s for query %s",
		    filter_to_text(f), filter_query_to_text(q));
d542 2
a543 5
		m_create(&f->proc->mproc, IMSG_FILTER_EVENT, 0, 0, -1);
		m_add_id(&f->proc->mproc, q->session->id);
		m_add_int(&f->proc->mproc, q->type);
		m_close(&f->proc->mproc);
	}
a553 3
	if (q->kind == QK_EVENT)
		goto done;

a588 5
	if (q->kind == QK_EVENT && q->type == EVENT_DISCONNECT) {
		io_clear(&s->iev);
		iobuf_clear(&s->ibuf);
		free(s);
	}
d792 22
a813 32
	if (q->kind == QK_QUERY) {
		switch (q->type) {
		case QUERY_CONNECT:
			strlcat(tmp, "=", sizeof tmp);
			strlcat(tmp, ss_to_text(&q->u.connect.local),
			    sizeof tmp);
			strlcat(tmp, " <-> ", sizeof tmp);
			strlcat(tmp, ss_to_text(&q->u.connect.remote),
			    sizeof tmp);
			strlcat(tmp, "(", sizeof tmp);
			strlcat(tmp, q->u.connect.hostname, sizeof tmp);
			strlcat(tmp, ")", sizeof tmp);
			break;
		case QUERY_MAIL:
		case QUERY_RCPT:
			snprintf(tmp, sizeof tmp, "=%s@@%s",
			    q->u.maddr.user, q->u.maddr.domain);
			break;
		case QUERY_HELO:
			snprintf(tmp, sizeof tmp, "=%s", q->u.line);
			break;
		default:
			break;
		}
		snprintf(buf, sizeof buf, "%016"PRIx64"[%s,%s%s,%s]",
		    q->qid, kind_to_str(q->kind), query_to_str(q->type), tmp,
		    filter_session_to_text(q->session));
	}
	else {
		snprintf(buf, sizeof buf, "%016"PRIx64"[%s,%s%s,%s]",
		    q->qid, kind_to_str(q->kind), event_to_str(q->type), tmp,
		    filter_session_to_text(q->session));
d815 3
a900 11
	}
}

static const char *
kind_to_str(int type)
{
	switch (type) {
	CASE(QK_QUERY);
	CASE(QK_EVENT);
	default:
		return "QK_???";
@


1.10
log
@Wrap long lines and whitespace fixes.

Ok jung@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.9 2015/11/24 08:40:10 gilles Exp $	*/
d121 1
a299 1
	struct filter_query	*q;
d307 7
a313 2
	q = filter_query(s, QK_EVENT, event);
	filter_drain_query(q);
d422 14
@


1.9
log
@add filter.c plumbing, not linked to the build, not used yet

ok sunil@@, ok jung@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d165 1
a165 1
		log_debug("filter:     extending with \"%s\"", name);
d170 1
a170 1
		log_debug("filter:     adding filter \"%s\"", name);
a205 1

a219 1

d238 2
a239 1
		while (dict_iter(&env->sc_filters, &iter, NULL, (void **)&filter)) {
d254 2
a255 1
			log_debug("filter: building chain \"%s\"...", filter->name);
d258 2
a259 1
			log_debug("filter: done building chain \"%s\"", filter->name);
a307 1

a327 1

d389 1
a389 1
	while(s->fcurr) {
d391 2
a392 1
			log_trace(TRACE_FILTERS, "filter: sending fd %d to %s", sink, filter_to_text(s->fcurr));
a402 1

d436 2
a437 2
		log_trace(TRACE_FILTERS, "filter: new query %s %s", kind_to_str(kind),
		    query_to_str(type));
d439 2
a440 2
		log_trace(TRACE_FILTERS, "filter: new query %s %s", kind_to_str(kind),
		    event_to_str(type));
d450 2
a451 1
	log_trace(TRACE_FILTERS, "filter: filter_drain_query %s", filter_query_to_text(q));
a457 1

a459 1

d480 2
a481 2
				    "filter: query blocked by previous query %s",
				    filter_query_to_text(prev));
d506 2
a507 1
		log_trace(TRACE_FILTERS, "filter: running filter %s for query %s",
d542 2
a543 1
		log_trace(TRACE_FILTERS, "filter: running filter %s for query %s",
d550 1
a550 1
 	}
d558 2
a559 1
	log_trace(TRACE_FILTERS, "filter: filter_end_query %s", filter_query_to_text(q));
d566 2
a567 1
		log_trace(TRACE_FILTERS, "filter: filter_end_query(%d, %zu, %zu)", s->iev.sock,
d571 2
a572 1
			smtp_filter_response(s->id, QUERY_EOM, FILTER_FAIL, 0, NULL);
d579 2
a580 1
			smtp_filter_response(s->id, QUERY_EOM, FILTER_FAIL, 0, NULL);
d669 2
a670 1
			log_warnx("warn: filter: type mismatch %d != %d", q->type, type);
d749 2
a750 1
	log_trace(TRACE_FILTERS, "filter: filter_tx_io(%p, %s)", s, io_strevent(evt));
d757 2
a758 1
		log_trace(TRACE_FILTERS, "filter: filter_tx_io: datain (%zu) for req %016"PRIx64"",
d773 3
a775 1
		log_trace(TRACE_FILTERS, "debug: filter: tx done (%zu) for req %016"PRIx64, s->idatalen, s->id);
d779 2
a780 1
		log_warn("warn: filter_tx_io: bad evt (%d) for req %016"PRIx64, evt, s->id);
d808 1
a808 1
		switch(q->type) {
d811 2
a812 1
			strlcat(tmp, ss_to_text(&q->u.connect.local), sizeof tmp);
d814 2
a815 1
			strlcat(tmp, ss_to_text(&q->u.connect.remote), sizeof tmp);
d852 2
a853 1
	snprintf(buf, sizeof(buf), "filter_session@@%p[datalen=%zu,eom=%p,ofile=%p]",
@


1.8
log
@rename filter.c --> filter_api.c (to be consistent with upcoming changes)

prompted by and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.7 2012/06/14 21:56:13 gilles Exp $	*/
d4 2
a5 1
 * Copyright (c) 2011 Gilles Chehade <gilles@@openbsd.org>
d22 3
a24 1
#include <sys/uio.h>
d26 4
a29 1
#include <err.h>
a30 1
#include <fcntl.h>
d32 4
d41 2
a42 1
#include "filter_api.h"
d44 97
a140 3
static struct filter_internals {
	struct event	ev;
	struct imsgbuf	ibuf;
d142 2
a143 2
	enum filter_status (*connect_cb)(u_int64_t, struct filter_connect *, void *);
	void *connect_cb_arg;
d145 9
a153 2
	enum filter_status (*helo_cb)(u_int64_t, struct filter_helo *, void *);
	void *helo_cb_arg;
d155 22
a176 2
	enum filter_status (*ehlo_cb)(u_int64_t, struct filter_helo *, void *);
	void *ehlo_cb_arg;
d178 56
a233 2
	enum filter_status (*mail_cb)(u_int64_t, struct filter_mail *, void *);
	void *mail_cb_arg;
d235 28
a262 2
	enum filter_status (*rcpt_cb)(u_int64_t, struct filter_rcpt *, void *);
	void *rcpt_cb_arg;
d264 4
a267 2
	enum filter_status (*dataline_cb)(u_int64_t, struct filter_dataline *, void *);
	void *dataline_cb_arg;
d269 5
a273 2
	enum filter_status (*quit_cb)(u_int64_t, void *);
	void *quit_cb_arg;
d275 3
a277 2
	enum filter_status (*close_cb)(u_int64_t, void *);
	void *close_cb_arg;
d279 2
a280 2
	enum filter_status (*rset_cb)(u_int64_t, void *);
	void *rset_cb_arg;
d282 7
a288 1
} fi;
d290 3
a292 2
static void filter_handler(int, short, void *);
static void filter_register_callback(enum filter_type, void *, void *);
d295 1
a295 1
filter_init(void)
d297 2
a298 1
	bzero(&fi, sizeof (fi));
d300 5
a304 1
	imsg_init(&fi.ibuf, 0);
d306 3
a308 3
	event_init();
	event_set(&fi.ev, 0, EV_READ, filter_handler, (void *)&fi);
	event_add(&fi.ev, NULL);
d312 2
a313 1
filter_loop(void)
d315 25
a339 2
	if (event_dispatch() < 0)
		errx(1, "event_dispatch");
d343 1
a343 1
filter_register_connect_callback(enum filter_status (*cb)(u_int64_t, struct filter_connect *, void *), void *cb_arg)
d345 10
a354 1
	filter_register_callback(FILTER_CONNECT, cb, cb_arg);
d358 1
a358 1
filter_register_helo_callback(enum filter_status (*cb)(u_int64_t, struct filter_helo *, void *), void *cb_arg)
d360 10
a369 1
	filter_register_callback(FILTER_HELO, cb, cb_arg);
d373 1
a373 1
filter_register_ehlo_callback(enum filter_status (*cb)(u_int64_t, struct filter_helo *, void *), void *cb_arg)
d375 8
a382 1
	filter_register_callback(FILTER_EHLO, cb, cb_arg);
d385 2
a386 2
void
filter_register_mail_callback(enum filter_status (*cb)(u_int64_t, struct filter_mail *, void *), void *cb_arg)
d388 17
a404 1
	filter_register_callback(FILTER_MAIL, cb, cb_arg);
d408 1
a408 1
filter_register_rcpt_callback(enum filter_status (*cb)(u_int64_t, struct filter_rcpt *, void *), void *cb_arg)
d410 8
a417 1
	filter_register_callback(FILTER_RCPT, cb, cb_arg);
d420 2
a421 2
void
filter_register_dataline_callback(enum filter_status (*cb)(u_int64_t, struct filter_dataline *, void *), void *cb_arg)
d423 21
a443 1
	filter_register_callback(FILTER_DATALINE, cb, cb_arg);
d446 2
a447 2
void
filter_register_quit_callback(enum filter_status (*cb)(u_int64_t, void *), void *cb_arg)
d449 52
a500 1
	filter_register_callback(FILTER_QUIT, cb, cb_arg);
d503 2
a504 2
void
filter_register_close_callback(enum filter_status (*cb)(u_int64_t, void *), void *cb_arg)
d506 45
a550 1
	filter_register_callback(FILTER_CLOSE, cb, cb_arg);
d553 2
a554 2
void
filter_register_rset_callback(enum filter_status (*cb)(u_int64_t, void *), void *cb_arg)
d556 45
a600 1
	filter_register_callback(FILTER_RSET, cb, cb_arg);
d604 1
a604 1
filter_register_callback(enum filter_type type, void *cb, void *cb_arg)
d606 13
a618 5
	switch (type) {
	case FILTER_CONNECT:
		fi.connect_cb = cb;
		fi.connect_cb_arg = cb_arg;
		break;
d620 12
a631 4
	case FILTER_HELO:
		fi.helo_cb = cb;
		fi.helo_cb_arg = cb_arg;
		break;
d633 12
a644 4
	case FILTER_EHLO:
		fi.ehlo_cb = cb;
		fi.ehlo_cb_arg = cb_arg;
		break;
d646 1
a646 3
	case FILTER_MAIL:
		fi.mail_cb = cb;
		fi.mail_cb_arg = cb_arg;
d649 39
a687 3
	case FILTER_RCPT:
		fi.rcpt_cb = cb;
		fi.rcpt_cb_arg = cb_arg;
d690 8
a697 3
	case FILTER_DATALINE:
		fi.dataline_cb = cb;
		fi.dataline_cb_arg = cb_arg;
d700 5
a704 4
	case FILTER_QUIT:
		fi.quit_cb = cb;
		fi.quit_cb_arg = cb_arg;
		break;
d706 4
a709 4
	case FILTER_CLOSE:
		fi.close_cb = cb;
		fi.close_cb_arg = cb_arg;
		break;
d711 8
a718 4
	case FILTER_RSET:
		fi.rset_cb = cb;
		fi.rset_cb_arg = cb_arg;
		break;
d720 5
a724 2
	default:
		errx(1, "filter_register_callback: unknown filter type");
d726 9
d738 1
a738 1
filter_handler(int fd, short event, void *p)
d740 19
a758 14
	struct imsg		imsg;
	ssize_t			n;
	short			evflags = EV_READ;
	enum filter_status	ret;
	struct filter_msg	fm;

	if (event & EV_READ) {
		n = imsg_read(&fi.ibuf);
		if (n == -1)
			err(1, "imsg_read");
		if (n == 0) {
			event_del(&fi.ev);
			event_loopexit(NULL);
			return;
d760 13
d775 11
a785 5
	if (event & EV_WRITE) {
		if (msgbuf_write(&fi.ibuf.w) == -1)
			err(1, "msgbuf_write");
		if (fi.ibuf.w.queued)
			evflags |= EV_WRITE;
d787 7
d795 1
a795 6
	for (;;) {
		n = imsg_get(&fi.ibuf, &imsg);
		if (n == -1)
			errx(1, "imsg_get");
		if (n == 0)
			break;
d797 15
a811 14
		if ((imsg.hdr.len - IMSG_HEADER_SIZE)
		    != sizeof(fm))
			errx(1, "corrupted imsg");

		memcpy(&fm, imsg.data, sizeof (fm));
		if (fm.version != FILTER_API_VERSION)
			errx(1, "API version mismatch");

		switch (imsg.hdr.type) {
		case FILTER_CONNECT:
			if (fi.connect_cb == NULL)
				goto ignore;
			ret = fi.connect_cb(fm.cl_id, &fm.u.connect,
			    fi.connect_cb_arg);
d813 2
a814 5
		case FILTER_HELO:
			if (fi.helo_cb == NULL)
				goto ignore;
			ret = fi.helo_cb(fm.cl_id, &fm.u.helo,
			    fi.helo_cb_arg);
d816 1
a816 5
		case FILTER_EHLO:
			if (fi.ehlo_cb == NULL)
				goto ignore;
			ret = fi.ehlo_cb(fm.cl_id, &fm.u.helo,
			    fi.ehlo_cb_arg);
d818 64
a881 33
		case FILTER_MAIL:
			if (fi.mail_cb == NULL)
				goto ignore;
			ret = fi.mail_cb(fm.cl_id, &fm.u.mail,
			    fi.mail_cb_arg);
			break;
		case FILTER_RCPT:
			if (fi.rcpt_cb == NULL)
				goto ignore;
			ret = fi.rcpt_cb(fm.cl_id, &fm.u.rcpt,
			    fi.rcpt_cb_arg);
			break;
		case FILTER_DATALINE:
			if (fi.dataline_cb == NULL)
				goto ignore;
			ret = fi.dataline_cb(fm.cl_id, &fm.u.dataline,
			    fi.dataline_cb_arg);
			break;
		case FILTER_QUIT:
			if (fi.quit_cb == NULL)
				goto ignore;
			ret = fi.quit_cb(fm.cl_id, fi.quit_cb_arg);
			break;
		case FILTER_CLOSE:
			if (fi.close_cb == NULL)
				goto ignore;
			ret = fi.close_cb(fm.cl_id, fi.close_cb_arg);
			break;
		case FILTER_RSET:
			if (fi.rset_cb == NULL)
				goto ignore;
			ret = fi.rset_cb(fm.cl_id, fi.rset_cb_arg);
 			break;
d883 15
a897 3
		default:
			errx(1, "unsupported imsg");
		}
d899 13
a911 12
		switch (ret) {
		case STATUS_ACCEPT:
		case STATUS_REJECT:
			fm.code = ret;
			imsg_compose(&fi.ibuf, imsg.hdr.type, 0, 0, -1, &fm,
			    sizeof fm);
			evflags |= EV_WRITE;
			break;
		case STATUS_WAITING:
			/* waiting for asynchronous call ... */
			break;
		}
d913 8
a920 1
		imsg_free(&imsg);
d922 1
d924 10
a933 11
	event_set(&fi.ev, 0, evflags, filter_handler, &fi);
	event_add(&fi.ev, NULL);
	return;

ignore:
	imsg_free(&imsg);
	fm.code = STATUS_IGNORE;
	imsg_compose(&fi.ibuf, imsg.hdr.type, 0, 0, -1, &fm, sizeof fm);
	evflags |= EV_WRITE;
	event_set(&fi.ev, 0, evflags, filter_handler, &fi);
	event_add(&fi.ev, NULL);
@


1.7
log
@- rename filter.h -> filter_api.h to be consistent with upcoming changes
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.6 2012/01/18 13:41:54 chl Exp $	*/
@


1.6
log
@Add new filters callbacks for:
- network events (CONNECT/CLOSE)
- commands (QUIT/RSET)

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.5 2011/11/28 22:13:27 chl Exp $	*/
d32 1
a32 1
#include "filter.h"
@


1.5
log
@use STATUS_* filter codes, instead of -1/0/1 hard coded values

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.4 2011/11/16 10:24:41 chl Exp $	*/
d38 3
d55 10
d90 6
d125 18
d147 5
d176 18
d240 6
d276 16
@


1.4
log
@fix obvious variable substitution mistake
change code type back to int8_t

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.3 2011/11/15 23:22:47 gilles Exp $	*/
a217 2
			if (ret == STATUS_REJECT)
				fm.code = -1;
d236 1
a236 1
	fm.code = 0;
@


1.3
log
@- change callback prototypes in filter.c to allow stricter checks
- introduce STATUS_WAITING, filters will reroute async DNS queries through
  LKA in a near future
- filter_api.c will contain our filter API (empty for now)
- Makefile to build libsmtpdfilter (not linked to the build,dev stuff only)
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.2 2011/08/31 18:56:30 gilles Exp $	*/
d214 1
a214 1
		switch (fm.code) {
@


1.2
log
@add support for per-line DATA callbacks, this allows filters to take their
decisions *while* the message is being received by the client.
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.1 2011/08/27 22:32:41 gilles Exp $	*/
d38 1
a38 1
	int (*helo_cb)(u_int64_t, struct filter_helo *, void *);
d41 1
a41 1
	int (*ehlo_cb)(u_int64_t, struct filter_helo *, void *);
d44 1
a44 1
	int (*mail_cb)(u_int64_t, struct filter_mail *, void *);
d47 1
a47 1
	int (*rcpt_cb)(u_int64_t, struct filter_rcpt *, void *);
d50 1
a50 1
	int (*dataline_cb)(u_int64_t, struct filter_dataline *, void *);
d77 1
a77 1
filter_register_helo_callback(int (*cb)(u_int64_t, struct filter_helo *, void *), void *cb_arg)
d83 1
a83 1
filter_register_ehlo_callback(int (*cb)(u_int64_t, struct filter_helo *, void *), void *cb_arg)
d89 1
a89 1
filter_register_mail_callback(int (*cb)(u_int64_t, struct filter_mail *, void *), void *cb_arg)
d95 1
a95 1
filter_register_rcpt_callback(int (*cb)(u_int64_t, struct filter_rcpt *, void *), void *cb_arg)
d101 1
a101 1
filter_register_dataline_callback(int (*cb)(u_int64_t, struct filter_dataline *, void *), void *cb_arg)
d143 1
d183 1
a183 1
			fm.code = fi.helo_cb(fm.cl_id, &fm.u.helo,
d189 1
a189 1
			fm.code = fi.ehlo_cb(fm.cl_id, &fm.u.helo,
d195 1
a195 1
			fm.code = fi.mail_cb(fm.cl_id, &fm.u.mail,
d201 1
a201 1
			fm.code = fi.rcpt_cb(fm.cl_id, &fm.u.rcpt,
d207 1
a207 1
			fm.code = fi.dataline_cb(fm.cl_id, &fm.u.dataline,
d214 15
a228 5
		if (! fm.code)
			fm.code = -1;
			
		imsg_compose(&fi.ibuf, imsg.hdr.type, 0, 0, -1, &fm, sizeof fm);
		evflags |= EV_WRITE;
@


1.1
log
@initial support for a session-time filtering API

currently only HELO/EHLO, MAIL, RCPT are supported, however ... I have
voluntarily disabled filters at smtpd.conf level so people don't play with
it until the API has stabilized a bit

discussed with several people in private, no one opposed the feature
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 2
a51 5
	int (*data_cb)(u_int64_t, struct filter_data *, void *);
	void *data_cb_arg;

	int (*quit_cb)(u_int64_t, struct filter_quit *, void *);
	void *quit_cb_arg;
d101 1
a101 7
filter_register_data_callback(int (*cb)(u_int64_t, struct filter_data *, void *), void *cb_arg)
{
	filter_register_callback(FILTER_DATA, cb, cb_arg);
}

void
filter_register_quit_callback(int (*cb)(u_int64_t, struct filter_quit *, void *), void *cb_arg)
d103 1
a103 1
	filter_register_callback(FILTER_QUIT, cb, cb_arg);
d130 3
a132 8
	case FILTER_DATA:
		fi.data_cb = cb;
		fi.data_cb_arg = cb_arg;
		break;

	case FILTER_QUIT:
		fi.quit_cb = cb;
		fi.quit_cb_arg = cb_arg;
d203 2
a204 8
		case FILTER_DATA:
			if (fi.data_cb == NULL)
				goto ignore;
			fm.code = fi.data_cb(fm.cl_id, &fm.u.data,
			    fi.data_cb_arg);
			break;
		case FILTER_QUIT:
			if (fi.quit_cb == NULL)
d206 2
a207 2
			fm.code = fi.quit_cb(fm.cl_id, &fm.u.quit,
			    fi.quit_cb_arg);
@

