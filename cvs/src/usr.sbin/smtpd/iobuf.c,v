head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.2
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.5.0.12
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.8
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2;
locks; strict;
comment	@ * @;


1.10
date	2017.03.17.20.56.04;	author eric;	state Exp;
branches;
next	1.9;
commitid	fnjjcowXjmqh9Pql;

1.9
date	2015.12.14.10.22.12;	author jung;	state Exp;
branches;
next	1.8;
commitid	HRAnniyhGW9Sadln;

1.8
date	2015.12.05.21.27.42;	author mmcc;	state Exp;
branches;
next	1.7;
commitid	u7cKDttUUhTVcGIY;

1.7
date	2015.10.15.08.29.41;	author gilles;	state Exp;
branches;
next	1.6;
commitid	wvymujIudNNFQ5NM;

1.6
date	2015.09.03.06.26.17;	author jsg;	state Exp;
branches;
next	1.5;
commitid	eB6LV98AvuaRF60q;

1.5
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.02.01.17.25.29;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.01.29.00.32.51;	author eric;	state Exp;
branches;
next	;


desc
@@


1.10
log
@realloc() -> recallocarray().
use calloc() for initial allocation.

prodded by deraadt@@ ok gilles@@
@
text
@/*	$OpenBSD: iobuf.c,v 1.9 2015/12/14 10:22:12 jung Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#ifdef IO_SSL
#include <openssl/err.h>
#include <openssl/ssl.h>
#endif

#include "iobuf.h"

#define IOBUF_MAX	65536
#define IOBUFQ_MIN	4096

struct ioqbuf	*ioqbuf_alloc(struct iobuf *, size_t);
void		 iobuf_drain(struct iobuf *, size_t);

int
iobuf_init(struct iobuf *io, size_t size, size_t max)
{
	memset(io, 0, sizeof *io);

	if (max == 0)
		max = IOBUF_MAX;

	if (size == 0)
		size = max;

	if (size > max)
		return (-1);

	if ((io->buf = calloc(size, 1)) == NULL)
		return (-1);

	io->size = size;
	io->max = max;

	return (0);
}

void
iobuf_clear(struct iobuf *io)
{
	struct ioqbuf	*q;

	free(io->buf);

	while ((q = io->outq)) {
		io->outq = q->next;
		free(q);
	}

	memset(io, 0, sizeof (*io));
}

void
iobuf_drain(struct iobuf *io, size_t n)
{
	struct	ioqbuf	*q;
	size_t		 left = n;

	while ((q = io->outq) && left) {
		if ((q->wpos - q->rpos) > left) {
			q->rpos += left;
			left = 0;
		} else {
			left -= q->wpos - q->rpos;
			io->outq = q->next;
			free(q);
		}
	}

	io->queued -= (n - left);
	if (io->outq == NULL)
		io->outqlast = NULL;
}

int
iobuf_extend(struct iobuf *io, size_t n)
{
	char	*t;

	if (n > io->max)
		return (-1);

	if (io->max - io->size < n)
		return (-1);

	t = recallocarray(io->buf, io->size, io->size + n, 1);
	if (t == NULL)
		return (-1);

	io->size += n;
	io->buf = t;

	return (0);
}

size_t
iobuf_left(struct iobuf *io)
{
	return io->size - io->wpos;
}

size_t
iobuf_space(struct iobuf *io)
{
	return io->size - (io->wpos - io->rpos);
}

size_t
iobuf_len(struct iobuf *io)
{
	return io->wpos - io->rpos;
}

char *
iobuf_data(struct iobuf *io)
{
	return io->buf + io->rpos;
}

void
iobuf_drop(struct iobuf *io, size_t n)
{
	if (n >= iobuf_len(io)) {
		io->rpos = io->wpos = 0;
		return;
	}

	io->rpos += n;
}

char *
iobuf_getline(struct iobuf *iobuf, size_t *rlen)
{
	char	*buf;
	size_t	 len, i;

	buf = iobuf_data(iobuf);
	len = iobuf_len(iobuf);

	for (i = 0; i + 1 <= len; i++)
		if (buf[i] == '\n') {
			/* Note: the returned address points into the iobuf
			 * buffer.  We NUL-end it for convenience, and discard
			 * the data from the iobuf, so that the caller doesn't
			 * have to do it.  The data remains "valid" as long
			 * as the iobuf does not overwrite it, that is until
			 * the next call to iobuf_normalize() or iobuf_extend().
			 */
			iobuf_drop(iobuf, i + 1);
			len = (i && buf[i - 1] == '\r') ? i - 1 : i;
			buf[len] = '\0';
			if (rlen)
				*rlen = len;
			return (buf);
		}

	return (NULL);
}

void
iobuf_normalize(struct iobuf *io)
{
	if (io->rpos == 0)
		return;

	if (io->rpos == io->wpos) {
		io->rpos = io->wpos = 0;
		return;
	}

	memmove(io->buf, io->buf + io->rpos, io->wpos - io->rpos);
	io->wpos -= io->rpos;
	io->rpos = 0;
}

ssize_t
iobuf_read(struct iobuf *io, int fd)
{
	ssize_t	n;

	n = read(fd, io->buf + io->wpos, iobuf_left(io));
	if (n == -1) {
		/* XXX is this really what we want? */
		if (errno == EAGAIN || errno == EINTR)
			return (IOBUF_WANT_READ);
		return (IOBUF_ERROR);
	}
	if (n == 0)
		return (IOBUF_CLOSED);

	io->wpos += n;

	return (n);
}

struct ioqbuf *
ioqbuf_alloc(struct iobuf *io, size_t len)
{
	struct ioqbuf   *q;

	if (len < IOBUFQ_MIN)
		len = IOBUFQ_MIN;

	if ((q = malloc(sizeof(*q) + len)) == NULL)
		return (NULL);

	q->rpos = 0;
	q->wpos = 0;
	q->size = len;
	q->next = NULL;
	q->buf = (char *)(q) + sizeof(*q);

	if (io->outqlast == NULL)
		io->outq = q;
	else
		io->outqlast->next = q;
	io->outqlast = q;

	return (q);
}

size_t
iobuf_queued(struct iobuf *io)
{
	return io->queued;
}

void *
iobuf_reserve(struct iobuf *io, size_t len)
{
	struct ioqbuf	*q;
	void		*r;

	if (len == 0)
		return (NULL);

	if (((q = io->outqlast) == NULL) || q->size - q->wpos <= len) {
		if ((q = ioqbuf_alloc(io, len)) == NULL)
			return (NULL);
	}

	r = q->buf + q->wpos;
	q->wpos += len;
	io->queued += len;

	return (r);
}

int
iobuf_queue(struct iobuf *io, const void *data, size_t len)
{
	void	*buf;

	if (len == 0)
		return (0);

	if ((buf = iobuf_reserve(io, len)) == NULL)
		return (-1);

	memmove(buf, data, len);

	return (len);
}

int
iobuf_queuev(struct iobuf *io, const struct iovec *iov, int iovcnt)
{
	int	 i;
	size_t	 len = 0;
	char	*buf;

	for (i = 0; i < iovcnt; i++)
		len += iov[i].iov_len;

	if ((buf = iobuf_reserve(io, len)) == NULL)
		return (-1);

	for (i = 0; i < iovcnt; i++) {
		if (iov[i].iov_len == 0)
			continue;
		memmove(buf, iov[i].iov_base, iov[i].iov_len);
		buf += iov[i].iov_len;
	}

	return (0);

}

int
iobuf_fqueue(struct iobuf *io, const char *fmt, ...)
{
	va_list	ap;
	int	len;

	va_start(ap, fmt);
	len = iobuf_vfqueue(io, fmt, ap);
	va_end(ap);

	return (len);
}

int
iobuf_vfqueue(struct iobuf *io, const char *fmt, va_list ap)
{
	char	*buf;
	int	 len;

	len = vasprintf(&buf, fmt, ap);

	if (len == -1)
		return (-1);

	len = iobuf_queue(io, buf, len);
	free(buf);

	return (len);
}

ssize_t
iobuf_write(struct iobuf *io, int fd)
{
	struct iovec	 iov[IOV_MAX];
	struct ioqbuf	*q;
	int		 i;
	ssize_t		 n;

	i = 0;
	for (q = io->outq; q ; q = q->next) {
		if (i >= IOV_MAX)
			break;
		iov[i].iov_base = q->buf + q->rpos;
		iov[i].iov_len = q->wpos - q->rpos;
		i++;
	}

	n = writev(fd, iov, i);
	if (n == -1) {
		if (errno == EAGAIN || errno == EINTR)
			return (IOBUF_WANT_WRITE);
		if (errno == EPIPE)
			return (IOBUF_CLOSED);
		return (IOBUF_ERROR);
	}

	iobuf_drain(io, n);

	return (n);
}

int
iobuf_flush(struct iobuf *io, int fd)
{
	ssize_t	s;

	while (io->queued)
		if ((s = iobuf_write(io, fd)) < 0)
			return (s);

	return (0);
}

#ifdef IO_SSL

int
iobuf_flush_ssl(struct iobuf *io, void *ssl)
{
	ssize_t	s;

	while (io->queued)
		if ((s = iobuf_write_ssl(io, ssl)) < 0)
			return (s);

	return (0);
}

ssize_t
iobuf_write_ssl(struct iobuf *io, void *ssl)
{
	struct ioqbuf	*q;
	int		 r;
	ssize_t		 n;

	q = io->outq;
	n = SSL_write(ssl, q->buf + q->rpos, q->wpos - q->rpos);
	if (n <= 0) {
		switch ((r = SSL_get_error(ssl, n))) {
		case SSL_ERROR_WANT_READ:
			return (IOBUF_WANT_READ);
		case SSL_ERROR_WANT_WRITE:
			return (IOBUF_WANT_WRITE);
		case SSL_ERROR_ZERO_RETURN: /* connection closed */
			return (IOBUF_CLOSED);
		case SSL_ERROR_SYSCALL:
			if (ERR_peek_last_error())
				return (IOBUF_SSLERROR);
			if (r == 0)
				errno = EPIPE;
			return (IOBUF_ERROR);
		default:
			return (IOBUF_SSLERROR);
		}
	}
	iobuf_drain(io, n);

	return (n);
}

ssize_t
iobuf_read_ssl(struct iobuf *io, void *ssl)
{
	ssize_t	n;
	int	r;

	n = SSL_read(ssl, io->buf + io->wpos, iobuf_left(io));
	if (n < 0) {
		switch ((r = SSL_get_error(ssl, n))) {
		case SSL_ERROR_WANT_READ:
			return (IOBUF_WANT_READ);
		case SSL_ERROR_WANT_WRITE:
			return (IOBUF_WANT_WRITE);
		case SSL_ERROR_SYSCALL:
			if (ERR_peek_last_error())
				return (IOBUF_SSLERROR);
			if (r == 0)
				errno = EPIPE;
			return (IOBUF_ERROR);
		default:
			return (IOBUF_SSLERROR);
		}
	} else if (n == 0)
		return (IOBUF_CLOSED);

	io->wpos += n;

	return (n);
}

#endif /* IO_SSL */
@


1.9
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: iobuf.c,v 1.8 2015/12/05 21:27:42 mmcc Exp $	*/
d56 1
a56 1
	if ((io->buf = malloc(size)) == NULL)
d113 1
a113 1
	t = realloc(io->buf, io->size + n);
@


1.8
log
@Remove a few NULL-checks before free().
@
text
@d1 2
a2 2
/*	$OpenBSD: iobuf.c,v 1.7 2015/10/15 08:29:41 gilles Exp $	*/
/*      
@


1.7
log
@iobuf_queue() should return the number of bytes it queued on success, not 0

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iobuf.c,v 1.6 2015/09/03 06:26:17 jsg Exp $	*/
d70 1
a70 2
	if (io->buf)
		free(io->buf);
@


1.6
log
@move paren to correctly return a negative error value instead of the
result of the < 0 test which would be 1.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iobuf.c,v 1.5 2013/05/24 17:03:14 eric Exp $	*/
d290 1
a290 1
	return (0);
@


1.5
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iobuf.c,v 1.4 2013/01/26 09:37:23 gilles Exp $	*/
d398 1
a398 1
		if ((s = iobuf_write_ssl(io, ssl) < 0))
@


1.4
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iobuf.c,v 1.2 2012/02/01 17:25:29 eric Exp $	*/
d18 1
a18 1
#include <sys/param.h>
d23 1
@


1.3
log
@knf

ok gilles@@
@
text
@d29 1
d418 1
a418 2
		case SSL_ERROR_ZERO_RETURN:
			/* connection closed */
d420 6
d427 1
a427 1
			return (IOBUF_ERROR);
d448 6
d455 1
a455 1
			return (IOBUF_ERROR);
@


1.2
log
@fix stupid mistake in buffer code

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iobuf.c,v 1.1 2012/01/29 00:32:51 eric Exp $	*/
d50 1
a50 1
	
d71 1
a71 1
	while((q = io->outq)) {
d85 1
a85 1
	while((q = io->outq) && left) {
d183 1
a183 1
        return (NULL);
d234 3
a236 3
        q->wpos = 0;
        q->size = len;
        q->next = NULL;
d298 1
a298 1
	for(i = 0; i < iovcnt; i++)
d304 1
a304 1
	for(i = 0; i < iovcnt; i++) {
d354 1
a354 1
	for(q = io->outq; q ; q = q->next) {
@


1.1
log
@Import generic network IO code.  The plan is to hide the boring
details of IO operations such as buffering or SSL, and provide a
slightly nicer interface to the protocol writer.

Not plugged to the rest of the code yet.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.5 2011/07/13 14:52:21 eric Exp $	*/
d87 1
a88 1
			q->rpos += left;
@

