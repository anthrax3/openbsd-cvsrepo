head	1.38;
access;
symbols
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.37.0.4
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.35.0.4
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.24.0.2
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.38
date	2017.05.17.14.00.06;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	CQ2bJKe5Leh53ur4;

1.37
date	2016.09.01.10.54.25;	author eric;	state Exp;
branches;
next	1.36;
commitid	fYsbH2IujjKSME9c;

1.36
date	2016.09.01.10.07.20;	author eric;	state Exp;
branches;
next	1.35;
commitid	Ch0RMqdovbewwGAQ;

1.35
date	2016.05.28.21.21.20;	author eric;	state Exp;
branches;
next	1.34;
commitid	KhU4hSodVCiVoZ62;

1.34
date	2016.03.25.15.06.58;	author krw;	state Exp;
branches;
next	1.33;
commitid	0NIU7T9t8yqZHZQl;

1.33
date	2015.10.14.20.45.30;	author gilles;	state Exp;
branches;
next	1.32;
commitid	5IhYkLo8PbS2aNF7;

1.32
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	Uu5nFG3wCl0LACBb;

1.31
date	2014.05.01.15.50.20;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.29.19.13.13;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.29.10.18.06;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.19.17.29.56;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.09.18.55.19;	author eric;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.04.16.10.41;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.22.09.41.28;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2014.02.04.09.05.06;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2013.11.18.11.47.16;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.23.13.54.12;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2012.09.27.17.47.49;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2012.08.19.14.16.57;	author chl;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.27.15.36.04;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.27.11.17.29;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.20.15.34.56;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.12.12.35.03;	author jacekm;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.02.22.23.35;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.24.14.38.56;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2009.02.16.12.10.25;	author jacekm;	state Exp;
branches;
next	1.4;

1.4
date	2009.02.15.10.32.23;	author jacekm;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Introduce more use of freezero().  Also, remove ptr conditionals before
many functions which are free(NULL)-compat
ok gilles
@
text
@/*	$OpenBSD: config.c,v 1.37 2016/09/01 10:54:25 eric Exp $	*/

/*
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/resource.h>

#include <event.h>
#include <imsg.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>

#include <openssl/ssl.h>

#include "smtpd.h"
#include "log.h"
#include "ssl.h"

void
purge_config(uint8_t what)
{
	struct listener	*l;
	struct table	*t;
	struct rule	*r;
	struct pki	*p;
	const char	*k;
	void		*iter_dict;

	if (what & PURGE_LISTENERS) {
		while ((l = TAILQ_FIRST(env->sc_listeners)) != NULL) {
			TAILQ_REMOVE(env->sc_listeners, l, entry);
			free(l);
		}
		free(env->sc_listeners);
		env->sc_listeners = NULL;
	}
	if (what & PURGE_TABLES) {
		while (dict_root(env->sc_tables_dict, NULL, (void **)&t))
			table_destroy(t);
		free(env->sc_tables_dict);
		env->sc_tables_dict = NULL;
	}
	if (what & PURGE_RULES) {
		while ((r = TAILQ_FIRST(env->sc_rules)) != NULL) {
			TAILQ_REMOVE(env->sc_rules, r, r_entry);
			free(r);
		}
		free(env->sc_rules);
		env->sc_rules = NULL;
	}
	if (what & PURGE_PKI) {
		while (dict_poproot(env->sc_pki_dict, (void **)&p)) {
			freezero(p->pki_cert, p->pki_cert_len);
			freezero(p->pki_key, p->pki_key_len);
			EVP_PKEY_free(p->pki_pkey);
			free(p);
		}
		free(env->sc_pki_dict);
		env->sc_pki_dict = NULL;
	} else if (what & PURGE_PKI_KEYS) {
		iter_dict = NULL;
		while (dict_iter(env->sc_pki_dict, &iter_dict, &k,
		    (void **)&p)) {
			freezero(p->pki_cert, p->pki_cert_len);
			p->pki_cert = NULL;
			freezero(p->pki_key, p->pki_key_len);
			p->pki_key = NULL;
			EVP_PKEY_free(p->pki_pkey);
			p->pki_pkey = NULL;
		}
	}
}

void
config_process(enum smtp_proc_type proc)
{
	struct rlimit rl;

	smtpd_process = proc;
	setproctitle("%s", proc_title(proc));

	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("fdlimit: getrlimit");
	rl.rlim_cur = rl.rlim_max;
	if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("fdlimit: setrlimit");
}

void
config_peer(enum smtp_proc_type proc)
{
	struct mproc	*p;

	if (proc == smtpd_process)
		fatal("config_peers: cannot peer with oneself");

	if (proc == PROC_CONTROL)
		p = p_control;
	else if (proc == PROC_LKA)
		p = p_lka;
	else if (proc == PROC_PARENT)
		p = p_parent;
	else if (proc == PROC_QUEUE)
		p = p_queue;
	else if (proc == PROC_SCHEDULER)
		p = p_scheduler;
	else if (proc == PROC_PONY)
		p = p_pony;
	else if (proc == PROC_CA)
		p = p_ca;
	else
		fatalx("bad peer");

	mproc_enable(p);
}
@


1.37
log
@remove noop function

ok sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.36 2016/09/01 10:07:20 eric Exp $	*/
d73 3
a75 8
			explicit_bzero(p->pki_cert, p->pki_cert_len);
			free(p->pki_cert);
			if (p->pki_key) {
				explicit_bzero(p->pki_key, p->pki_key_len);
				free(p->pki_key);
			}
			if (p->pki_pkey)
				EVP_PKEY_free(p->pki_pkey);
d84 1
a84 2
			explicit_bzero(p->pki_cert, p->pki_cert_len);
			free(p->pki_cert);
d86 3
a88 7
			if (p->pki_key) {
				explicit_bzero(p->pki_key, p->pki_key_len);
				free(p->pki_key);
				p->pki_key = NULL;
			}
			if (p->pki_pkey)
				EVP_PKEY_free(p->pki_pkey);
@


1.36
log
@get rid of the imsg buffer usage profiling code.

ok gilles@@ jung@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.35 2016/05/28 21:21:20 eric Exp $	*/
a144 5
}

void
config_done(void)
{
@


1.35
log
@Implement the fork+exec pattern in smtpd.

The parent process forks child processes and re-exec each of them with
an additional "-x <proc>" argument.  During the early setup phase, the
parent process sends ipc socket pairs to interconnect the child
processes as needed, and it passes the queue encryption key to the
queue if necessary. When this is done, all processes have their
environment set as in the fork-only case, and they can start doing
their work as before.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.34 2016/03/25 15:06:58 krw Exp $	*/
a38 2
extern int profiling;

a146 2
static void process_stat_event(int, short, void *);

a149 50
	static struct event	ev;
	struct timeval		tv;

	if (smtpd_process == PROC_CONTROL)
		return;

	if (!(profiling & PROFILE_BUFFERS))
		return;

	evtimer_set(&ev, process_stat_event, &ev);
	tv.tv_sec = 0;
	tv.tv_usec = 0;
	evtimer_add(&ev, &tv);
}

static void
process_stat(struct mproc *p)
{
	char			buf[1024];
	struct stat_value	value;

	if (p == NULL)
		return;

	value.type = STAT_COUNTER;
	(void)snprintf(buf, sizeof buf, "buffer.%s.%s",
	    proc_name(smtpd_process),
	    proc_name(p->proc));
	value.u.counter = p->bytes_queued_max;
	p->bytes_queued_max = p->bytes_queued;
	stat_set(buf, &value);
}

static void
process_stat_event(int fd, short ev, void *arg)
{
	struct event	*e = arg;
	struct timeval	 tv;

	process_stat(p_control);
	process_stat(p_lka);
	process_stat(p_parent);
	process_stat(p_queue);
	process_stat(p_scheduler);
	process_stat(p_pony);
	process_stat(p_ca);

	tv.tv_sec = 1;
	tv.tv_usec = 0;
	evtimer_add(e, &tv);
@


1.34
log
@Nuke session_socket_blockmode() and session_socket_linger(). Use
the identical io_set_blocking() and io_set_linger().

Since both are always called to turn off blocking or lingering,
nuke the parameter and associated enum in favour of "just doing the
right thing".

While passing remove the unneeded last parameter to the remaining
fcntl(F_GETFL).

Finally, rename the functions to io_set_nonblocking() and
io_set_nolinger() for clarity.

No functional change.

Started with a sweep of fcntl() usage inspired by guenther@@.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.33 2015/10/14 20:45:30 gilles Exp $	*/
a40 2
static int pipes[PROC_COUNT][PROC_COUNT];

a106 17
init_pipes(void)
{
	int	 i, j, sockpair[2];

	for (i = 0; i < PROC_COUNT; i++)
		for (j = i + 1; j < PROC_COUNT; j++) {
			if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
				sockpair) == -1)
				fatal("socketpair");
			pipes[i][j] = sockpair[0];
			pipes[j][i] = sockpair[1];
			io_set_nonblocking(pipes[i][j]);
			io_set_nonblocking(pipes[j][i]);
		}
}

void
a128 9
	p = xcalloc(1, sizeof *p, "config_peer");
	p->proc = proc;
	p->name = xstrdup(proc_name(proc), "config_peer");
	p->handler = imsg_dispatch;

	mproc_init(p, pipes[smtpd_process][proc]);
	mproc_enable(p);
	pipes[smtpd_process][proc] = -1;

d130 1
a130 1
		p_control = p;
d132 1
a132 1
		p_lka = p;
d134 1
a134 1
		p_parent = p;
d136 1
a136 1
		p_queue = p;
d138 1
a138 1
		p_scheduler = p;
d140 1
a140 1
		p_pony = p;
d142 1
a142 1
		p_ca = p;
d145 2
a155 10
	unsigned int		i, j;

	for (i = 0; i < PROC_COUNT; i++) {
		for (j = 0; j < PROC_COUNT; j++) {
			if (i == j || pipes[i][j] == -1)
				continue;
			close(pipes[i][j]);
			pipes[i][j] = -1;
		}
	}
@


1.33
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.32 2015/01/16 06:40:20 deraadt Exp $	*/
d120 2
a121 2
			session_socket_blockmode(pipes[i][j], BM_NONBLOCK);
			session_socket_blockmode(pipes[j][i], BM_NONBLOCK);
@


1.32
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.31 2014/05/01 15:50:20 reyk Exp $	*/
d116 1
a116 1
			    sockpair) == -1)
@


1.31
log
@Move RSA keys from "lka" to a new dedicated "ca" process because lka
is handling some async requests and shouldn't be busy with sync RSA.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.30 2014/04/29 19:13:13 reyk Exp $	*/
d29 1
@


1.30
log
@Implement RSA privilege separation for OpenSMTPD, based on my previous
implementation for relayd(8).  The smtpd(8) pony processes (mta
client, smtp server) don't keep the private keys in memory but send
their private key operations as imsgs to the "lookup"/mta process.
It's worth mentioning that this prevents acidental private key leakage
as it could have been caused by "Heartbleed".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.29 2014/04/29 10:18:06 reyk Exp $	*/
d168 2
d234 1
@


1.29
log
@use explicit_bzero() instead of memset() to clear out sensitive data.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.28 2014/04/19 17:29:56 gilles Exp $	*/
d49 2
a76 1
			explicit_bzero(p->pki_key, p->pki_key_len);
d78 6
a83 1
			free(p->pki_key);
d88 16
@


1.28
log
@(void) cast snprintf call that cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.27 2014/04/09 18:55:19 eric Exp $	*/
d74 2
a75 2
			memset(p->pki_cert, 0, p->pki_cert_len);
			memset(p->pki_key, 0, p->pki_key_len);
@


1.27
log
@Zap the mfa process. It is not currently doing anything, and content filtering
will be done at session level anyway.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d190 1
a190 1
	snprintf(buf, sizeof buf, "buffer.%s.%s",
@


1.26
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@a137 2
	else if (proc == PROC_MFA)
		p_mfa = p;
a205 1
	process_stat(p_mfa);
@


1.25
log
@disable the imsg buffers profiling code unless requested, this will prevent
all processes from waking up every second
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.24 2014/02/04 13:44:41 eric Exp $	*/
a137 2
	else if (proc == PROC_MDA)
		p_mda = p;
a139 2
	else if (proc == PROC_MTA)
		p_mta = p;
d146 2
a147 2
	else if (proc == PROC_SMTP)
		p_smtp = p;
a207 1
	process_stat(p_mda);
a208 1
	process_stat(p_mda);
d212 1
a212 1
	process_stat(p_smtp);
@


1.24
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 2
d175 3
@


1.23
log
@get rid of fdlimit()
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.22 2013/12/26 17:25:32 eric Exp $	*/
d46 1
a46 1
	struct ssl	*s;
d70 7
a76 7
	if (what & PURGE_SSL) {
		while (dict_poproot(env->sc_ssl_dict, (void **)&s)) {
			memset(s->ssl_cert, 0, s->ssl_cert_len);
			memset(s->ssl_key, 0, s->ssl_key_len);
			free(s->ssl_cert);
			free(s->ssl_key);
			free(s);
d78 2
a79 2
		free(env->sc_ssl_dict);
		env->sc_ssl_dict = NULL;
@


1.22
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.21 2013/11/18 11:47:16 eric Exp $	*/
d23 1
d103 2
d107 6
@


1.21
log
@change dict_poproot() prototype: do not take key placeholder parameter as
it can't work that way.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.20 2013/05/24 17:03:14 eric Exp $	*/
d71 2
a72 2
			bzero(s->ssl_cert, s->ssl_cert_len);
			bzero(s->ssl_key, s->ssl_key_len);
@


1.20
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.19 2013/01/26 09:37:23 gilles Exp $	*/
d70 1
a70 1
		while (dict_poproot(env->sc_ssl_dict, NULL, (void **)&s)) {
@


1.19
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.17 2012/09/27 17:47:49 chl Exp $	*/
a21 1
#include <sys/param.h>
d56 1
a56 1
		while (tree_root(env->sc_tables_tree, NULL, (void **)&t))
a58 1
		free(env->sc_tables_tree);
a59 1
		env->sc_tables_tree = NULL;
@


1.18
log
@knf
@
text
@d29 1
d32 2
d36 1
d38 1
a38 22
static int is_peer(struct peer *, enum smtp_proc_type, uint);

static int
is_peer(struct peer *p, enum smtp_proc_type peer, uint peercount)
{
	uint	i;

	for (i = 0; i < peercount; i++)
		if (p[i].id == peer)
			return (1);
	return (0);
}

void
unconfigure(void)
{
}

void
configure(void)
{
}
d44 1
a44 1
	struct map	*m;
a46 1
	struct mapel	*me;
d56 7
a62 11
	if (what & PURGE_MAPS) {
		while ((m = TAILQ_FIRST(env->sc_maps)) != NULL) {
			TAILQ_REMOVE(env->sc_maps, m, m_entry);
			while ((me = TAILQ_FIRST(&m->m_contents))) {
				TAILQ_REMOVE(&m->m_contents, me, me_entry);
				free(me);
			}
			free(m);
		}
		free(env->sc_maps);
		env->sc_maps = NULL;
d73 3
a75 2
		while ((s = SPLAY_ROOT(env->sc_ssl)) != NULL) {
			SPLAY_REMOVE(ssltree, env->sc_ssl, s);
d80 2
a81 2
		free(env->sc_ssl);
		env->sc_ssl = NULL;
d88 1
a88 4
	int	 i;
	int	 j;
	int	 count;
	int	 sockpair[2];
d91 34
a124 7
		for (j = 0; j < PROC_COUNT; j++) {
			/*
			 * find out how many instances of this peer there are.
			 */
			if (i >= j || env->sc_instances[i] == 0 ||
			    env->sc_instances[j] == 0)
				continue;
d126 20
a145 25
			if (env->sc_instances[i] > 1 &&
			    env->sc_instances[j] > 1)
				fatalx("N:N peering not supported");

			count = env->sc_instances[i] * env->sc_instances[j];

			env->sc_pipes[i][j] = xcalloc(count, sizeof(int),
			    "init_pipes");
			env->sc_pipes[j][i] = xcalloc(count, sizeof(int),
			    "init_pipes");

			while (--count >= 0) {
				if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
				    sockpair) == -1)
					fatal("socketpair");
				env->sc_pipes[i][j][count] = sockpair[0];
				env->sc_pipes[j][i][count] = sockpair[1];
				session_socket_blockmode(
				    env->sc_pipes[i][j][count],
				    BM_NONBLOCK);
				session_socket_blockmode(
				    env->sc_pipes[j][i][count],
				    BM_NONBLOCK);
			}
		}
d148 2
d151 1
a151 1
config_pipes(struct peer *p, uint peercount)
d153 4
a156 7
	uint	i;
	uint	j;
	int	count;

	/*
	 * close pipes
	 */
d159 1
a159 3
			if (i == j ||
			    env->sc_instances[i] == 0 ||
			    env->sc_instances[j] == 0)
d161 2
a162 15

			for (count = 0;
			    count < env->sc_instances[i]*env->sc_instances[j];
			    count++) {
				if (i == smtpd_process &&
				    is_peer(p, j, peercount) &&
				    count == env->sc_instance)
					continue;
				if (i == smtpd_process &&
				    is_peer(p, j, peercount) &&
				    env->sc_instances[i] == 1)
					continue;
				close(env->sc_pipes[i][j][count]);
				env->sc_pipes[i][j][count] = -1;
			}
d165 26
d193 2
a194 2
void
config_peers(struct peer *p, uint peercount)
d196 16
a211 34
	int	n;
	uint	src;
	uint	dst;
	uint	i;
	/*
	 * listen on appropriate pipes
	 */
	for (i = 0; i < peercount; i++) {

		src = smtpd_process;
		dst = p[i].id;

		if (dst == smtpd_process)
			fatal("config_peers: cannot peer with oneself");

		env->sc_ievs[dst] = xcalloc(env->sc_instances[dst],
		    sizeof(struct imsgev), "config_peers");

		for (n = 0; n < env->sc_instances[dst]; n++) {
			imsg_init(&(env->sc_ievs[dst][n].ibuf),
			    env->sc_pipes[src][dst][n]);
			env->sc_ievs[dst][n].handler =  p[i].cb;
			env->sc_ievs[dst][n].events = EV_READ;
			env->sc_ievs[dst][n].proc = dst;
			env->sc_ievs[dst][n].data = &env->sc_ievs[dst][n];

			event_set(&(env->sc_ievs[dst][n].ev),
			    env->sc_ievs[dst][n].ibuf.fd,
			    env->sc_ievs[dst][n].events,
			    env->sc_ievs[dst][n].handler,
			    env->sc_ievs[dst][n].data);
			event_add(&(env->sc_ievs[dst][n].ev), NULL);
		}
	}
@


1.17
log
@use xmalloc()/xcalloc() helpers

while there unify usage of log_trace() in ramstat_set()

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.16 2012/08/19 14:16:57 chl Exp $	*/
d119 2
a120 2
			if (i >= j || env->sc_instances[i] == 0||
			   env->sc_instances[j] == 0)
d188 1
a188 1
	int	count;
d202 1
a202 1
		
d206 14
a219 14
		for (count = 0; count < env->sc_instances[dst]; count++) {
			imsg_init(&(env->sc_ievs[dst][count].ibuf),
			    env->sc_pipes[src][dst][count]);
			env->sc_ievs[dst][count].handler =  p[i].cb;
			env->sc_ievs[dst][count].events = EV_READ;
			env->sc_ievs[dst][count].proc = dst;
			env->sc_ievs[dst][count].data = &env->sc_ievs[dst][count];

			event_set(&(env->sc_ievs[dst][count].ev),
			    env->sc_ievs[dst][count].ibuf.fd,
			    env->sc_ievs[dst][count].events,
			    env->sc_ievs[dst][count].handler,
			    env->sc_ievs[dst][count].data);
			event_add(&(env->sc_ievs[dst][count].ev), NULL);
@


1.16
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.15 2011/05/01 12:57:11 eric Exp $	*/
d129 4
a132 5
			if ((env->sc_pipes[i][j] =
			    calloc(count, sizeof(int))) == NULL ||
			    (env->sc_pipes[j][i] =
			    calloc(count, sizeof(int))) == NULL)
				fatal(NULL);
d203 2
a204 3
		if ((env->sc_ievs[dst] = calloc(env->sc_instances[dst],
		    sizeof(struct imsgev))) == NULL)
			fatal("config_peers");
@


1.15
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.14 2011/04/17 13:36:07 gilles Exp $	*/
d34 1
a34 1
static int is_peer(struct peer *, enum smtp_proc_type, u_int);
d37 1
a37 1
is_peer(struct peer *p, enum smtp_proc_type peer, u_int peercount)
d39 1
a39 1
	u_int	i;
d58 1
a58 1
purge_config(u_int8_t what)
d152 1
a152 1
config_pipes(struct peer *p, u_int peercount)
d154 2
a155 2
	u_int	i;
	u_int	j;
d187 1
a187 1
config_peers(struct peer *p, u_int peercount)
d190 3
a192 3
	u_int	src;
	u_int	dst;
	u_int	i;
@


1.14
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.13 2010/11/28 13:56:43 gilles Exp $	*/
d48 1
a48 1
unconfigure(struct smtpd *env)
d53 1
a53 1
configure(struct smtpd *env)
d58 1
a58 1
purge_config(struct smtpd *env, u_int8_t what)
d107 1
a107 1
init_pipes(struct smtpd *env)
d152 1
a152 1
config_pipes(struct smtpd *env, struct peer *p, u_int peercount)
d187 1
a187 1
config_peers(struct smtpd *env, struct peer *p, u_int peercount)
a214 1
			env->sc_ievs[dst][count].env = env;
@


1.13
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.12 2010/05/27 15:36:04 gilles Exp $	*/
d34 1
a34 1
int	is_peer(struct peer *, enum smtp_proc_type, u_int);
d36 1
a36 1
int
@


1.12
log
@when a rule has two conditions (ie: accept for { domain foo, domain bar } )
expand to two rules each having its own condition rather than one rule
with a tail queue of conditions. this simplifies code a bit and removes a
couple hacks.

basic testing by oga and me
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.11 2010/05/27 11:17:29 gilles Exp $	*/
d26 1
d32 1
@


1.11
log
@kill struct opt from struct rule, we don't use it, we don't need it
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.10 2010/04/20 15:34:56 jacekm Exp $	*/
a60 1
	struct cond	*c;
a86 4
			while ((c = TAILQ_FIRST(&r->r_conditions)) != NULL) {
				TAILQ_REMOVE(&r->r_conditions, c, c_entry);
				free(c);
			}
@


1.10
log
@Kill *2400* lines of code by abstracting common bits of the imsg handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.9 2009/11/12 12:35:03 jacekm Exp $	*/
a61 1
	struct opt	*o;
a90 4
			}
			while ((o = TAILQ_FIRST(&r->r_options)) != NULL) {
				TAILQ_REMOVE(&r->r_options, o, o_entry);
				free(o);
@


1.9
log
@Fix a memleak in parse_config(). Correct return code in few error paths.
Fix two memleaks in purge_config().

First problem spotted by parfait, the other ones - by myself.

"looks good" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.8 2009/06/06 04:14:21 pyr Exp $	*/
d221 3
a223 1
			env->sc_ievs[dst][count].data = env;
@


1.8
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.7 2009/06/02 22:23:35 gilles Exp $	*/
d64 1
d77 4
d99 1
@


1.7
log
@make env->sc_listeners and env->sc_ssl pointers, one step further toward
configuration reloading without killing active sessions; ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.6 2009/05/24 14:38:56 jacekm Exp $	*/
d206 2
a207 2
		if ((env->sc_ibufs[dst] = calloc(env->sc_instances[dst],
		    sizeof(struct imsgbuf))) == NULL)
d211 12
a222 12
			imsg_init(&(env->sc_ibufs[dst][count]),
			    env->sc_pipes[src][dst][count], p[i].cb);

			env->sc_ibufs[dst][count].events = EV_READ;
			env->sc_ibufs[dst][count].data = env;

			event_set(&(env->sc_ibufs[dst][count].ev),
			    env->sc_ibufs[dst][count].fd,
			    env->sc_ibufs[dst][count].events,
			    env->sc_ibufs[dst][count].handler,
			    env->sc_ibufs[dst][count].data);
			event_add(&(env->sc_ibufs[dst][count].ev), NULL);
@


1.6
log
@Parent process forks 3 types of processes, track them all in a single tree
using newly introduced child struct.

Manage process titles centrally in struct smtpd.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.5 2009/02/16 12:10:25 jacekm Exp $	*/
d66 2
a67 2
		while ((l = TAILQ_FIRST(&env->sc_listeners)) != NULL) {
			TAILQ_REMOVE(&env->sc_listeners, l, entry);
d70 2
a71 1
		TAILQ_INIT(&env->sc_listeners);
d97 2
a98 2
		while ((s = SPLAY_ROOT(&env->sc_ssl)) != NULL) {
			SPLAY_REMOVE(ssltree, &env->sc_ssl, s);
d103 2
a104 1
		SPLAY_INIT(&env->sc_ssl);
@


1.5
log
@Process which connects with a pool of cloned processes needs to
keep open all pipes going in their direction; ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.4 2009/02/15 10:32:23 jacekm Exp $	*/
d107 1
a107 1
init_peers(struct smtpd *env)
@


1.4
log
@New config.c that allows for process cloning. Done by pyr@@ for
relayd at n2k9, and adapted to smtpd; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.3 2009/01/01 16:15:47 jacekm Exp $	*/
d174 4
@


1.3
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d109 4
a112 2
	int	i;
	int	j;
d116 5
a120 1
			if (i >= j)
d122 26
a147 7
			if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
			    env->sc_pipes[i][j]) == -1)
				fatal("socketpair");
			session_socket_blockmode(env->sc_pipes[i][j][0],
			    BM_NONBLOCK);
			session_socket_blockmode(env->sc_pipes[i][j][1],
			    BM_NONBLOCK);
d152 1
a152 1
config_peers(struct smtpd *env, struct peer *p, u_int peercount)
d156 1
a156 3
	u_int	src;
	u_int	dst;
	u_int	idx;
d163 3
a165 1
			if (i >= j)
d168 9
a176 7
			if ((i == smtpd_process && is_peer(p, j, peercount)) ||
			    (j == smtpd_process && is_peer(p, i, peercount))) {
				idx = (i == smtpd_process)?1:0;
				close(env->sc_pipes[i][j][idx]);
			} else {
				close(env->sc_pipes[i][j][0]);
				close(env->sc_pipes[i][j][1]);
d180 1
d182 7
d194 4
a197 1
		if (p[i].id == smtpd_process)
d199 3
a201 6

		src = (smtpd_process < p[i].id)?smtpd_process:p[i].id;
		dst = (src == p[i].id)?smtpd_process:p[i].id;

		if ((env->sc_ibufs[p[i].id] =
		     calloc(1, sizeof(struct imsgbuf))) == NULL)
d204 14
a217 11
		idx = (src == smtpd_process)?0:1;
		imsg_init(env->sc_ibufs[p[i].id],
		    env->sc_pipes[src][dst][idx], p[i].cb);
		env->sc_ibufs[p[i].id]->events = EV_READ;
		env->sc_ibufs[p[i].id]->data = env;
		event_set(&env->sc_ibufs[p[i].id]->ev,
		    env->sc_ibufs[p[i].id]->fd,
		    env->sc_ibufs[p[i].id]->events,
		    env->sc_ibufs[p[i].id]->handler,
		    env->sc_ibufs[p[i].id]->data);
		event_add(&env->sc_ibufs[p[i].id]->ev, NULL);
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a23 1
#include <sys/time.h>
a25 1
#include <pwd.h>
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

