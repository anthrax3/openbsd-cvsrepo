head	1.41;
access;
symbols
	OPENBSD_6_2:1.41.0.2
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.40.0.12
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.10
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.4
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.2
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7;
locks; strict;
comment	@ * @;


1.41
date	2017.07.31.16.38.33;	author gilles;	state Exp;
branches;
next	1.40;
commitid	yPm5iUmoZkoHEYvk;

1.40
date	2015.01.09.08.28.02;	author gilles;	state Exp;
branches;
next	1.39;
commitid	rKINVuZWNJuke7v3;

1.39
date	2014.02.04.15.22.39;	author eric;	state Exp;
branches;
next	1.38;

1.38
date	2013.12.06.14.12.34;	author eric;	state Exp;
branches;
next	1.37;

1.37
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.36;

1.36
date	2013.10.25.18.58.10;	author eric;	state Exp;
branches;
next	1.35;

1.35
date	2013.07.19.13.41.23;	author eric;	state Exp;
branches;
next	1.34;

1.34
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.33;

1.33
date	2013.02.14.12.30.49;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.28.11.09.53;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.30;

1.30
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.29;

1.29
date	2012.10.14.11.58.23;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2012.10.10.19.39.11;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2012.08.30.22.06.00;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.25;

1.25
date	2012.05.13.09.18.52;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.12.18.06.18;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2011.10.26.20.47.31;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2011.10.23.17.12.41;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2011.08.16.19.12.40;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.21.23.29.24;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.13.20.53.18;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.04.21.31.04;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.10.16.42.35;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.25.19.46.31;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.08.00.16.49;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.24.12.07.47;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.29.21.59.15;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.04.22.35.09;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.04.19.37.41;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.27.16.45.01;	author jacekm;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.06.02.44.08;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.05.03.28.37;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.41
log
@cmd_dump() is unused

spotted by deraadt
@
text
@/*	$OpenBSD: parser.c,v 1.40 2015/01/09 08:28:02 gilles Exp $	*/

/*
 * Copyright (c) 2013 Eric Faurot	<eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <net/if.h>
#include <arpa/inet.h>

#include <err.h>
#include <inttypes.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "parser.h"

uint64_t text_to_evpid(const char *);
uint32_t text_to_msgid(const char *);

struct node {
	int			 type;
	const char		*token;
	struct node		*parent;
	TAILQ_ENTRY(node)	 entry;
	TAILQ_HEAD(, node)	 children;
	int			(*cmd)(int, struct parameter*);
};

static struct node	*root;

static int text_to_sockaddr(struct sockaddr *, int, const char *);

#define ARGVMAX	64

int
cmd_install(const char *pattern, int (*cmd)(int, struct parameter*))
{
	struct node	*node, *tmp;
	char		*s, *str, *argv[ARGVMAX], **ap;
	int		 i, n;

	/* Tokenize */
	str = s = strdup(pattern);
	if (str == NULL)
		err(1, "strdup");
	n = 0;
	for (ap = argv; n < ARGVMAX && (*ap = strsep(&str, " \t")) != NULL;) {
		if (**ap != '\0') {
			ap++;
			n++;
		}
	}
	*ap = NULL;

	if (root == NULL) {
		root = calloc(1, sizeof (*root));
		TAILQ_INIT(&root->children);
	}
	node = root;

	for (i = 0; i < n; i++) {
		TAILQ_FOREACH(tmp, &node->children, entry) {
			if (!strcmp(tmp->token, argv[i])) {
				node = tmp;
				break;
			}
		}
		if (tmp == NULL) {
			tmp = calloc(1, sizeof (*tmp));
			TAILQ_INIT(&tmp->children);
			if (!strcmp(argv[i], "<str>"))
				tmp->type = P_STR;
			else if (!strcmp(argv[i], "<int>"))
				tmp->type = P_INT;
			else if (!strcmp(argv[i], "<msgid>"))
				tmp->type = P_MSGID;
			else if (!strcmp(argv[i], "<evpid>"))
				tmp->type = P_EVPID;
			else if (!strcmp(argv[i], "<routeid>"))
				tmp->type = P_ROUTEID;
			else if (!strcmp(argv[i], "<addr>"))
				tmp->type = P_ADDR;
			else
				tmp->type = P_TOKEN;
			tmp->token = strdup(argv[i]);
			tmp->parent = node;
			TAILQ_INSERT_TAIL(&node->children, tmp, entry);
			node = tmp;
		}
	}

	if (node->cmd)
		errx(1, "duplicate pattern: %s", pattern);
	node->cmd = cmd;

	free(s);
	return (n);
}

static int
cmd_check(const char *str, struct node *node, struct parameter *res)
{
	const char *e;

	switch (node->type) {
	case P_TOKEN:
		if (!strcmp(str, node->token))
			return (1);
		return (0);

	case P_STR:
		res->u.u_str = str;
		return (1);

	case P_INT:
		res->u.u_int = strtonum(str, INT_MIN, INT_MAX, &e);
		if (e)
			return (0);
		return (1);

	case P_MSGID:
		if (strlen(str) != 8)
			return (0);
		res->u.u_msgid = text_to_msgid(str);
		if (res->u.u_msgid == 0)
			return (0);
		return (1);

	case P_EVPID:
		if (strlen(str) != 16)
			return (0);
		res->u.u_evpid = text_to_evpid(str);
		if (res->u.u_evpid == 0)
			return (0);
		return (1);

	case P_ROUTEID:
		res->u.u_routeid = strtonum(str, 1, LLONG_MAX, &e);
		if (e)
			return (0);
		return (1);

	case P_ADDR:
		if (text_to_sockaddr((struct sockaddr *)&res->u.u_ss, PF_UNSPEC, str) == 0)
			return (1);
		return (0);

	default:
		errx(1, "bad token type: %d", node->type);
		return (0);
	}
}

int
cmd_run(int argc, char **argv)
{
	struct parameter param[ARGVMAX];
	struct node	*node, *tmp, *stack[ARGVMAX], *best;
	int		 i, j, np;

	node = root;
	np = 0;

	for (i = 0; i < argc; i++) {
		TAILQ_FOREACH(tmp, &node->children, entry) {
			if (cmd_check(argv[i], tmp, &param[np])) {
				stack[i] = tmp;
				node = tmp;
				param[np].type = node->type;
				if (node->type != P_TOKEN)
					np++;
				break;
			}
		}
		if (tmp == NULL) {
			best = NULL;
			TAILQ_FOREACH(tmp, &node->children, entry) {
				if (tmp->type != P_TOKEN)
					continue;
				if (strstr(tmp->token, argv[i]) != tmp->token)
					continue;
				if (best)
					goto fail;
				best = tmp;
			}
			if (best == NULL)
				goto fail;
			stack[i] = best;
			node = best;
			param[np].type = node->type;
			if (node->type != P_TOKEN)
				np++;
		}
	}

	if (node->cmd == NULL)
		goto fail;

	return (node->cmd(np, np ? param : NULL));

fail:
	fprintf(stderr, "possibilities are:\n");
	TAILQ_FOREACH(tmp, &node->children, entry) {
		for (j = 0; j < i; j++)
			fprintf(stderr, "%s%s", j?" ":"", stack[j]->token);
		fprintf(stderr, "%s%s\n", i?" ":"", tmp->token);
	}

	return (-1);
}

int
cmd_show_params(int argc, struct parameter *argv)
{
	int	i;

	for (i = 0; i < argc; i++) {
		switch(argv[i].type) {
		case P_STR:
			printf(" str:\"%s\"", argv[i].u.u_str);
			break;
		case P_INT:
			printf(" int:%d", argv[i].u.u_int);
			break;
		case P_MSGID:
			printf(" msgid:%08"PRIx32, argv[i].u.u_msgid);
			break;
		case P_EVPID:
			printf(" evpid:%016"PRIx64, argv[i].u.u_evpid);
			break;
		case P_ROUTEID:
			printf(" routeid:%016"PRIx64, argv[i].u.u_routeid);
			break;
		default:
			printf(" ???:%d", argv[i].type);
		}
	}
	printf ("\n");
	return (1);
}

static int
text_to_sockaddr(struct sockaddr *sa, int family, const char *str)
{
	struct in_addr		 ina;
	struct in6_addr		 in6a;
	struct sockaddr_in	*in;
	struct sockaddr_in6	*in6;
	char			*cp, *str2;
	const char		*errstr;

	switch (family) {
	case PF_UNSPEC:
		if (text_to_sockaddr(sa, PF_INET, str) == 0)
			return (0);
		return text_to_sockaddr(sa, PF_INET6, str);

	case PF_INET:
		if (inet_pton(PF_INET, str, &ina) != 1)
			return (-1);

		in = (struct sockaddr_in *)sa;
		memset(in, 0, sizeof *in);
		in->sin_len = sizeof(struct sockaddr_in);
		in->sin_family = PF_INET;
		in->sin_addr.s_addr = ina.s_addr;
		return (0);

	case PF_INET6:
		cp = strchr(str, SCOPE_DELIMITER);
		if (cp) {
			str2 = strdup(str);
			if (str2 == NULL)
				return (-1);
			str2[cp - str] = '\0';
			if (inet_pton(PF_INET6, str2, &in6a) != 1) {
				free(str2);
				return (-1);
			}
			cp++;
			free(str2);
		} else if (inet_pton(PF_INET6, str, &in6a) != 1)
			return (-1);

		in6 = (struct sockaddr_in6 *)sa;
		memset(in6, 0, sizeof *in6);
		in6->sin6_len = sizeof(struct sockaddr_in6);
		in6->sin6_family = PF_INET6;
		in6->sin6_addr = in6a;

		if (cp == NULL)
			return (0);

		if (IN6_IS_ADDR_LINKLOCAL(&in6a) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&in6a) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(&in6a))
			if ((in6->sin6_scope_id = if_nametoindex(cp)))
				return (0);

		in6->sin6_scope_id = strtonum(cp, 0, UINT32_MAX, &errstr);
		if (errstr)
			return (-1);
		return (0);

	default:
		break;
	}

	return (-1);
}
@


1.40
log
@rename a variable to avoid a warning

spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.39 2014/02/04 15:22:39 eric Exp $	*/
a117 14
}

static void
cmd_dump(struct node *node, int depth)
{
	struct node	*n;
	int		 i;

	for(i = 0; i < depth; i++)
		printf("  ");
	printf("%s\n", node->token ? node->token : "");

	TAILQ_FOREACH(n, &node->children, entry)
		cmd_dump(n, depth + 1);
@


1.39
log
@Allow the admin to pause relaying to a specific domain:
 - smtpctl pause mta from <source> for <domain>
 - smtpctl resume mta from <source> for <domain>
 - smtpctl show mta paused
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d281 2
a282 2
	struct sockaddr_in	*sin;
	struct sockaddr_in6	*sin6;
d296 5
a300 5
		sin = (struct sockaddr_in *)sa;
		memset(sin, 0, sizeof *sin);
		sin->sin_len = sizeof(struct sockaddr_in);
		sin->sin_family = PF_INET;
		sin->sin_addr.s_addr = ina.s_addr;
d319 5
a323 5
		sin6 = (struct sockaddr_in6 *)sa;
		memset(sin6, 0, sizeof *sin6);
		sin6->sin6_len = sizeof(struct sockaddr_in6);
		sin6->sin6_family = PF_INET6;
		sin6->sin6_addr = in6a;
d331 1
a331 1
			if ((sin6->sin6_scope_id = if_nametoindex(cp)))
d334 1
a334 1
		sin6->sin6_scope_id = strtonum(cp, 0, UINT32_MAX, &errstr);
@


1.38
log
@fix smtpctl resume route
@
text
@d21 5
d30 1
d51 2
d101 2
d177 5
d274 70
@


1.37
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.36 2013/10/25 18:58:10 eric Exp $	*/
d162 1
a162 1
		res->u.u_int = strtonum(str, 1, LLONG_MAX, &e);
@


1.36
log
@Improve reporting in smtpctl and a few fixes.

When sending a request to the scheduler, wait for the success/failure
report from the scheduler.  Simplify the code by introducing generic
functions for interruptible iteration over envelopes.  Report the total
number of affected envelopes for schedule, pause, resume and remove
envelope operations.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d168 1
a168 1
		errx(1, "bad token type: %i", node->type);
d242 1
a242 1
			printf(" int:%i", argv[i].u.u_int);
d254 1
a254 1
			printf(" ???:%i", argv[i].type);
@


1.35
log
@New implementation for smtpctl and the command line parser.  Allows
richer syntax, and makes the code way simpler to follow and extend
with new commands.
@
text
@d218 1
a218 1
	return (node->cmd(np, param));
@


1.34
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.33 2013/02/14 12:30:49 gilles Exp $	*/
d4 1
a4 3
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
a19 1
#include <sys/socket.h>
a20 1
#include <sys/tree.h>
d22 6
a27 6
#include <event.h>
#include <imsg.h>

#include <openssl/ssl.h>

#include "smtpd.h"
d31 2
a32 6
enum token_type {
	NOTOKEN,
	ENDTOKEN,
	KEYWORD,
	VARIABLE
};
d34 7
a40 5
struct token {
	enum token_type		 type;
	const char		*keyword;
	int			 value;
	const struct token	*next;
d43 1
a43 32
static const struct token t_log[];
static const struct token t_main[];
static const struct token t_pause[];
static const struct token t_remove[];
static const struct token t_resume[];
static const struct token t_schedule[];
static const struct token t_show[];
static const struct token t_show_envelope[];
static const struct token t_show_message[];
static const struct token t_update[];
static const struct token t_update_table[];
static const struct token t_trace[];
static const struct token t_untrace[];
static const struct token t_profile[];
static const struct token t_unprofile[];

static const struct token t_main[] = {
	{KEYWORD,	"schedule",	NONE,		t_schedule},
	{KEYWORD,	"show",		NONE,		t_show},
	{KEYWORD,	"monitor",	MONITOR,	NULL},
	{KEYWORD,	"pause",	NONE,		t_pause},
	{KEYWORD,	"remove",	NONE,		t_remove},
	{KEYWORD,	"resume",	NONE,		t_resume},
	{KEYWORD,	"stop",		SHUTDOWN,	NULL},
	{KEYWORD,	"log",		NONE,		t_log},
	{KEYWORD,	"profile",	NONE,		t_profile},
	{KEYWORD,	"trace",	NONE,		t_trace},
	{KEYWORD,	"unprofile",	NONE,		t_unprofile},
	{KEYWORD,	"untrace",	NONE,		t_untrace},
	{KEYWORD,	"update",	NONE,		t_update},
	{ENDTOKEN,	"",		NONE,		NULL}
};
d45 1
a45 4
static const struct token t_remove[] = {
	{VARIABLE,	"evpid",	REMOVE,		NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};
d47 19
a65 4
static const struct token t_schedule[] = {
	{VARIABLE,	"msgid/evpid/all",	SCHEDULE,	NULL},
	{ENDTOKEN,	"",			NONE,		NULL}
};
d67 5
a71 7
static const struct token t_show[] = {
	{KEYWORD,	"queue",	SHOW_QUEUE,	NULL},
	{KEYWORD,	"stats",	SHOW_STATS,	NULL},
	{KEYWORD,	"envelope",	NONE,		t_show_envelope},
	{KEYWORD,	"message",	SHOW_MESSAGE,	t_show_message},
	{ENDTOKEN,	"",		NONE,		NULL}
};
d73 28
a100 4
static const struct token t_show_envelope[] = {
	{VARIABLE,	"evpid",	SHOW_ENVELOPE,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};
d102 3
a104 4
static const struct token t_show_message[] = {
	{VARIABLE,	"evpid",	SHOW_MESSAGE,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};
d106 3
a108 6
static const struct token t_pause[] = {
	{KEYWORD,	"mda",			PAUSE_MDA,	NULL},
	{KEYWORD,	"mta",		        PAUSE_MTA,	NULL},
	{KEYWORD,	"smtp",		        PAUSE_SMTP,	NULL},
	{ENDTOKEN,	"",			NONE,		NULL}
};
d110 5
a114 6
static const struct token t_resume[] = {
	{KEYWORD,	"mda",			RESUME_MDA,	NULL},
	{KEYWORD,	"mta",		        RESUME_MTA,	NULL},
	{KEYWORD,	"smtp",		        RESUME_SMTP,	NULL},
	{ENDTOKEN,	"",			NONE,		NULL}
};
d116 3
a118 5
static const struct token t_log[] = {
	{KEYWORD,	"verbose",		LOG_VERBOSE,	NULL},
	{KEYWORD,	"brief",		LOG_BRIEF,	NULL},
	{ENDTOKEN,	"",			NONE,		NULL}
};
d120 3
a122 55
static const struct token t_update[] = {
	{KEYWORD,	"table",		NONE,		t_update_table},
	{ENDTOKEN,	"",			NONE,		NULL}
};

static const struct token t_update_table[] = {
	{VARIABLE,	"name",			UPDATE_TABLE,	NULL},
	{ENDTOKEN,	"",			NONE,		NULL}
};

static const struct token t_trace[] = {
	{KEYWORD,	"imsg",			LOG_TRACE_IMSG,		NULL},
	{KEYWORD,	"io",			LOG_TRACE_IO,		NULL},
	{KEYWORD,	"smtp",			LOG_TRACE_SMTP,		NULL},
	{KEYWORD,	"filter",      		LOG_TRACE_MFA,		NULL},
	{KEYWORD,	"transfer",    		LOG_TRACE_MTA,		NULL},
	{KEYWORD,	"bounce",    		LOG_TRACE_BOUNCE,	NULL},
	{KEYWORD,	"scheduler",   		LOG_TRACE_SCHEDULER,  	NULL},
	{KEYWORD,	"lookup",   		LOG_TRACE_LOOKUP,  	NULL},
	{KEYWORD,	"stat",   		LOG_TRACE_STAT,	  	NULL},
	{KEYWORD,	"rules",   		LOG_TRACE_RULES,  	NULL},
	{KEYWORD,	"mproc",   		LOG_TRACE_MPROC,	NULL},
	{KEYWORD,	"expand",   		LOG_TRACE_EXPAND,	NULL},
	{KEYWORD,	"all",   		LOG_TRACE_ALL,		NULL},
	{ENDTOKEN,	"",			NONE,			NULL}
};

static const struct token t_untrace[] = {
	{KEYWORD,	"imsg",			LOG_UNTRACE_IMSG,	NULL},
	{KEYWORD,	"io",			LOG_UNTRACE_IO,		NULL},
	{KEYWORD,	"smtp",			LOG_UNTRACE_SMTP,	NULL},
	{KEYWORD,	"filter",      		LOG_UNTRACE_MFA,	NULL},
	{KEYWORD,	"transfer",    		LOG_UNTRACE_MTA,	NULL},
	{KEYWORD,	"bounce",    		LOG_UNTRACE_BOUNCE,	NULL},
	{KEYWORD,	"scheduler",   		LOG_UNTRACE_SCHEDULER, 	NULL},
	{KEYWORD,	"lookup",   		LOG_UNTRACE_LOOKUP, 	NULL},
	{KEYWORD,	"stat",   		LOG_UNTRACE_STAT,  	NULL},
	{KEYWORD,	"rules",   		LOG_UNTRACE_RULES,  	NULL},
	{KEYWORD,	"mproc",   		LOG_UNTRACE_MPROC,	NULL},
	{KEYWORD,	"expand",   		LOG_UNTRACE_EXPAND,	NULL},
	{KEYWORD,	"all",   		LOG_UNTRACE_ALL,	NULL},
	{ENDTOKEN,	"",			NONE,			NULL}
};

static const struct token t_profile[] = {
	{KEYWORD,	"imsg",			LOG_PROFILE_IMSG,	NULL},
	{KEYWORD,	"queue",       		LOG_PROFILE_QUEUE,     	NULL},
	{ENDTOKEN,	"",			NONE,			NULL}
};

static const struct token t_unprofile[] = {
	{KEYWORD,	"imsg",			LOG_UNPROFILE_IMSG,    	NULL},
	{KEYWORD,	"queue",       		LOG_UNPROFILE_QUEUE,	NULL},
	{ENDTOKEN,	"",			NONE,			NULL}
};
d124 2
a125 7

static const struct token *match_token(const char *, const struct token [],
    struct parse_result *);
static void show_valid_args(const struct token []);

struct parse_result *
parse(int argc, char *argv[])
d127 1
a127 21
	static struct parse_result	res;
	const struct token	*table = t_main;
	const struct token	*match;

	bzero(&res, sizeof(res));

	while (argc >= 0) {
		if ((match = match_token(argv[0], table, &res)) == NULL) {
			fprintf(stderr, "valid commands/args:\n");
			show_valid_args(table);
			return (NULL);
		}

		argc--;
		argv++;

		if (match->type == NOTOKEN || match->next == NULL)
			break;

		table = match->next;
	}
d129 41
a169 3
	if (argc > 0) {
		fprintf(stderr, "superfluous argument: %s\n", argv[0]);
		return (NULL);
a170 2

	return (&res);
d173 2
a174 3
const struct token *
match_token(const char *word, const struct token table[],
    struct parse_result *res)
d176 16
a191 11
	uint			 i, match;
	const struct token	*t = NULL;

	match = 0;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			if (word == NULL || strlen(word) == 0) {
				match++;
				t = &table[i];
d193 11
a203 18
			break;
		case KEYWORD:
			if (word != NULL && strncmp(word, table[i].keyword,
			    strlen(word)) == 0) {
				match++;
				t = &table[i];
				if (t->value)
					res->action = t->value;
			}
			break;
		case VARIABLE:
			if (word != NULL && strlen(word) != 0) {
				match++;
				t = &table[i];
				if (t->value) {
					res->action = t->value;
					res->data = word;
				}
d205 7
a211 3
			break;
		case ENDTOKEN:
			break;
d215 11
a225 8
	if (match != 1) {
		if (word == NULL)
			fprintf(stderr, "missing argument:\n");
		else if (match > 1)
			fprintf(stderr, "ambiguous argument: %s\n", word);
		else if (match < 1)
			fprintf(stderr, "unknown argument: %s\n", word);
		return (NULL);
d228 1
a228 1
	return (t);
d231 2
a232 2
static void
show_valid_args(const struct token table[])
d236 7
a242 4
	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			fprintf(stderr, "  <cr>\n");
d244 2
a245 2
		case KEYWORD:
			fprintf(stderr, "  %s\n", table[i].keyword);
d247 2
a248 2
		case VARIABLE:
			fprintf(stderr, "  %s\n", table[i].keyword);
d250 2
a251 1
		case ENDTOKEN:
d253 2
d257 2
@


1.33
log
@- smtpctl trace expand, enables tracing of aliases expansion
- replace "users" keyword with "userbase" when providing alternate userbase
- disambiguise expansion nodes when expanding across domains and userbases
- allow use of '=' instead of '=>' when declaring a mapping

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.32 2013/01/28 11:09:53 gilles Exp $	*/
a24 1
#include <sys/param.h>
d151 1
a151 1
	{KEYWORD,	"msg-size",   		LOG_TRACE_IMSG_SIZE,	NULL},
d168 1
a168 1
	{KEYWORD,	"msg-size",   		LOG_UNTRACE_IMSG_SIZE,	NULL},
@


1.32
log
@- introduce 'smtpctl trace lookup' to trace lookup process
- improve logging of the transfer process

trace by me, logging by eric
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.31 2013/01/26 09:37:23 gilles Exp $	*/
d153 1
d170 1
@


1.31
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.29 2012/10/14 11:58:23 gilles Exp $	*/
d149 1
d165 1
@


1.30
log
@knf

ok gilles@@
@
text
@d55 1
a55 1
static const struct token t_schedule_id[];
d60 5
a64 1
static const struct token t_update_map[];
d67 1
a67 2
	{KEYWORD,	"schedule-id",	NONE,		t_schedule_id},
	{KEYWORD,	"schedule-all",	SCHEDULE_ALL,	NULL},
d75 4
d88 3
a90 3
static const struct token t_schedule_id[] = {
	{VARIABLE,	"msgid/evpid",	SCHEDULE,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
d132 1
a132 1
	{KEYWORD,	"map",			NONE,		t_update_map},
d136 2
a137 2
static const struct token t_update_map[] = {
	{VARIABLE,	"name",			UPDATE_MAP,	NULL},
d141 41
@


1.29
log
@introduce map_file.c which will deprecate map_stdio.c

The idea is to have a file-backed map but to have smtpd(8) cache the maps
so that it cannot be partially read if edited while mail is received. The
file is read and converted to a static map (map_static.c), changes aren't
visible to smtpd until an explicit: smtpctl update map  which reads file,
builds a new static map and invalidates the former.

partial-read issue discussed with beck@@ and halex@@
idea to convert internally to a static map by eric@@

diff ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.28 2012/10/10 19:39:11 gilles Exp $	*/
d63 3
a65 3
	{KEYWORD,	"schedule-id",  	NONE,		t_schedule_id},
	{KEYWORD,	"schedule-all",   	SCHEDULE_ALL,  	NULL},
	{KEYWORD,	"show",	       	NONE,		t_show},
d67 6
a72 6
	{KEYWORD,	"pause",	NONE,      	t_pause},
	{KEYWORD,	"remove",	NONE,      	t_remove},
	{KEYWORD,	"resume",	NONE,      	t_resume},
	{KEYWORD,	"stop",		SHUTDOWN,      	NULL},
	{KEYWORD,	"log",    	NONE,      	t_log},
	{KEYWORD,	"update",    	NONE,      	t_update},
d108 1
a108 1
	{ENDTOKEN,	"",			NONE,      	NULL}
d115 1
a115 1
	{ENDTOKEN,	"",			NONE,      	NULL}
d119 3
a121 3
	{KEYWORD,	"verbose",      	LOG_VERBOSE,	NULL},
	{KEYWORD,	"brief",	      	LOG_BRIEF,	NULL},
	{ENDTOKEN,	"",			NONE,      	NULL}
d125 2
a126 2
	{KEYWORD,	"map",		     	NONE,		t_update_map},
	{ENDTOKEN,	"",			NONE,      	NULL}
d130 2
a131 2
	{VARIABLE,	"name",		      	UPDATE_MAP,	NULL},
	{ENDTOKEN,	"",			NONE,      	NULL}
@


1.28
log
@teach smtpctl how to display envelopes and messages using their id.
this allows an admin to inspect the queue without having to manually
extract bucket and find the path to an envelope or message.

diff by Sunil Nimmagadda <sunil@@poolp.org>

ok eric@@, chl@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.27 2012/08/30 22:06:00 gilles Exp $	*/
d50 1
a51 2
static const struct token t_schedule_id[];
static const struct token t_show[];
d55 2
a56 1
static const struct token t_log[];
d59 2
d72 1
d123 12
@


1.27
log
@- rename show_envelope() to show_queue_envelope()
- remove SHOW_RUNQUEUE it was a noop since runqueues have been removed
  years ago from smtpd
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.26 2012/08/19 14:16:58 chl Exp $	*/
d57 2
d86 12
@


1.26
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.25 2012/05/13 09:18:52 nicm Exp $	*/
a82 1
	{KEYWORD,	"runqueue",	SHOW_RUNQUEUE,	NULL},
@


1.25
log
@Remove sizes entry so it doesn't appear as a valid command in the
"smtpctl show" output, and use errx rather than err for the unknown
message error.

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.24 2012/01/12 18:06:18 eric Exp $	*/
d149 1
a149 1
	u_int			 i, match;
@


1.24
log
@Remove dead code for config reloading for now. It is not functionnal
and confusing.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.23 2011/10/26 20:47:31 gilles Exp $	*/
a84 1
	{KEYWORD,	"sizes",	SHOW_SIZES,	NULL},
@


1.23
log
@- fix smtpctl pause/resume so the ramqueue scheduling is done correctly
- rename IMSG and smtpctl pause/resume parameters
- update man page

tested by me, ok chl@@, eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.22 2011/10/23 17:12:41 gilles Exp $	*/
a63 1
/*	{KEYWORD,	"reload",	RELOAD,		NULL},*/
@


1.22
log
@- smtpctl schedule no longer works, instead, use 'smtpctl schedule-id <id>'
- introduce 'smtpctl schedule-all'

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.21 2011/08/16 19:12:40 gilles Exp $	*/
d91 3
a93 3
	{KEYWORD,	"local",		PAUSE_MDA,	NULL},
	{KEYWORD,	"outgoing",	        PAUSE_MTA,	NULL},
	{KEYWORD,	"incoming",	        PAUSE_SMTP,	NULL},
d98 3
a100 3
	{KEYWORD,	"local",		RESUME_MDA,	NULL},
	{KEYWORD,	"outgoing",	        RESUME_MTA,	NULL},
	{KEYWORD,	"incoming",	        RESUME_SMTP,	NULL},
@


1.21
log
@smtpctl show sizes, displays the size of queue-related structures, useful
for developers to see the impact of structure changes on memory and disk
usage, and useful for users to better understand 'smtpctl show stats'
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.20 2011/07/21 23:29:24 gilles Exp $	*/
d51 1
a51 1
static const struct token t_schedule[];
d59 3
a61 2
	{KEYWORD,	"schedule",    	NONE,		t_schedule},
	{KEYWORD,	"show",		NONE,		t_show},
d77 1
a77 1
static const struct token t_schedule[] = {
@


1.20
log
@- update smtpctl.8 to reflect reality
- bring back 'smtpctl schedule' and 'smtpctl remove' to life

Things you should know:

The ramqueue data structure is not finished yet and lacks an envelope tree
for evpid lookups. I wanted to wait until I'm done but too many people are
affected by not being able to reschedule envelopes, this is a quick fix.

So right now there's an O(rrible) complexity as both commands will perform
a (possibly aborted) queue scan leading to O(n). I will make that O(log n)
soon.

Also, smtpctl remove no longer supports removing an entire message, I will
fix that very soon too.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.19 2011/04/13 20:53:18 gilles Exp $	*/
d85 1
@


1.19
log
@following an idea from jacekm@@, smtpd now uses a ram-queue instead of doing
a continuous walk on the disk-queue. the implementation differs from what
jacekm@@ commited (and I backed out) a while ago in that it uses a queue and
a host tree required for upcoming features.

code will be improved in tree, it requires changes to be done in queue and
bounce API, I just wanted to commit a working version first ...

tested by todd@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.18 2010/11/28 14:35:58 gilles Exp $	*/
d51 1
d54 1
d59 1
d64 1
d68 10
@


1.18
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.17 2010/11/28 13:56:43 gilles Exp $	*/
a53 2
static const struct token t_schedule[];
static const struct token t_remove[];
a62 2
	{KEYWORD,	"schedule",    	SCHEDULE,      	t_schedule},
	{KEYWORD,	"remove",    	REMOVE,      	t_remove},
a84 10
	{ENDTOKEN,	"",			NONE,      	NULL}
};

static const struct token t_schedule[] = {
	{VARIABLE,	"message id/uid",      	SCHEDULE,	NULL},
	{ENDTOKEN,	"",			NONE,      	NULL}
};

static const struct token t_remove[] = {
	{VARIABLE,	"message id/uid",      	REMOVE,		NULL},
@


1.17
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.16 2010/10/09 22:05:35 gilles Exp $	*/
d27 1
a27 6
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
a28 5
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <event.h>
@


1.16
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.11 2010/01/10 16:42:35 gilles Exp $	*/
d33 1
@


1.15
log
@move some things around to make intentions clear.  not really a functional
change.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.14 2010/06/01 23:06:23 jacekm Exp $	*/
a60 1
static const struct token t_show_queue[];
d81 1
a81 1
	{KEYWORD,	"queue",	SHOW_QUEUE,	t_show_queue},
a86 6
static const struct token t_show_queue[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"raw",		SHOW_QUEUE_RAW,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

d102 1
a102 1
	{VARIABLE,	"message",      	SCHEDULE,	NULL},
d107 1
a107 1
	{VARIABLE,	"message",      	REMOVE,		NULL},
d118 1
a118 1
    struct parse_result *res);
d154 1
a154 1
static const struct token *
@


1.14
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.12 2010/05/31 23:38:56 jacekm Exp $	*/
d124 3
a126 1
static struct parse_result	res;
d131 1
d138 1
a138 1
		if ((match = match_token(argv[0], table)) == NULL) {
d161 3
a163 2
const struct token *
match_token(const char *word, const struct token table[])
d184 1
a184 1
					res.action = t->value;
d192 2
a193 2
					res.action = t->value;
					res.data = word;
d215 1
a215 1
void
@


1.13
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.11 2010/01/10 16:42:35 gilles Exp $	*/
d61 1
d82 1
a82 1
	{KEYWORD,	"queue",	SHOW_QUEUE,	NULL},
d88 6
d109 1
a109 1
	{VARIABLE,	"message id/uid",      	SCHEDULE,	NULL},
d114 1
a114 1
	{VARIABLE,	"message id/uid",      	REMOVE,		NULL},
@


1.12
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@a60 1
static const struct token t_show_queue[];
d81 1
a81 1
	{KEYWORD,	"queue",	SHOW_QUEUE,	t_show_queue},
a86 6
static const struct token t_show_queue[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"raw",		SHOW_QUEUE_RAW,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

d102 1
a102 1
	{VARIABLE,	"message",      	SCHEDULE,	NULL},
d107 1
a107 1
	{VARIABLE,	"message",      	REMOVE,		NULL},
@


1.11
log
@- teach runner how to remove a message from queue given a message id/uid
	and assuming message is not in processing/scheduled state
- teach smtpctl how to request message removal from runner

discussed with todd@@, idea ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.10 2010/01/03 14:37:37 chl Exp $	*/
d61 1
d82 1
a82 1
	{KEYWORD,	"queue",	SHOW_QUEUE,	NULL},
d88 6
d109 1
a109 1
	{VARIABLE,	"message id/uid",      	SCHEDULE,	NULL},
d114 1
a114 1
	{VARIABLE,	"message id/uid",      	REMOVE,		NULL},
@


1.10
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.9 2009/10/25 19:46:31 gilles Exp $	*/
d64 1
d75 1
d103 5
@


1.9
log
@smtpctl reload is work in progress, do not expose it and make sure smtpd's
control process does not try to handle it.

spotted and reported by martijn@@bunix.org
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.8 2009/08/08 00:16:49 gilles Exp $	*/
d64 1
d74 1
d101 6
@


1.8
log
@missing header
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.7 2009/02/24 12:07:47 gilles Exp $	*/
d69 1
a69 1
	{KEYWORD,	"reload",	RELOAD,		NULL},
@


1.7
log
@teach smtpctl's parser how to deal with parameters that are not necessarily
a token so that it is possible to do: smtpctl schedule <message id/uid>

introduce F_MESSAGE_FORCESCHEDULE which lets the runner schedule a message
even if the retry delay has not been expired.

F_MESSAGE_ENQUEUED is a valid flag for a message and should not cause an\
errx() in smtpctl show queue
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.6 2009/01/29 21:59:15 jacekm Exp $	*/
d25 1
@


1.6
log
@Implement "smtpctl show stats"; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.5 2009/01/04 22:35:09 gilles Exp $	*/
d47 2
a48 1
	KEYWORD
d62 1
d71 1
d96 5
d160 10
d199 3
@


1.5
log
@- smtp can now pause/resume the accepting of incoming messages
- smtpctl recognizes "pause incoming" and "resume incoming"
- setup imsg communication between control process and smtp process
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.4 2009/01/04 19:37:41 gilles Exp $	*/
d75 1
@


1.4
log
@- runner is now capable of pausing/resuming the scheduling of deliveries
for both mda and mta batches.
- smtpctl can be used to disable/enable deliveries at runtime using the
pause/resume commands.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.3 2008/12/27 16:45:01 jacekm Exp $	*/
d81 1
d88 1
@


1.3
log
@Break showqueue and showrunqueue into 2 words; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.2 2008/12/06 02:44:08 gilles Exp $	*/
d59 2
d65 1
d67 2
a68 1
	{KEYWORD,	"stop",		SHUTDOWN,	NULL},
d76 12
@


1.2
log
@- teach smtpctl how to inspect queue and runqueue, it supports two commands
	`showqueue' which displays the content of the queue (all envelopes)
	`showrunqueue` which displays envelopes scheduled for delivery. The
	utility will be improved and extended, but for now we need at least
	this basic support to help debug queue-related issues.

	Output format is spamdb-alike:
	type|envelope uid|sender|recipient|last delivery date|retry count

	ok jacek@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.1 2008/12/05 03:28:37 gilles Exp $	*/
a58 6
static const struct token t_rdr[];
static const struct token t_table[];
static const struct token t_host[];
static const struct token t_rdr_id[];
static const struct token t_table_id[];
static const struct token t_host_id[];
d61 1
a61 2
	{KEYWORD,	"showqueue",	SHOWQUEUE,	NULL},
	{KEYWORD,	"showrunqueue",	SHOWRUNQUEUE,	NULL},
d65 6
@


1.1
log
@- smtpctl utility to control the smtpd, don't expect too much yet as it is
	just an empty clone of relayctl with the glue needed to have it
	exchange imsg with smtpd correctly. code mostly by pyr@@, reviewed
	by chl@@ and I a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.20 2007/12/20 20:15:43 reyk Exp $	*/
d67 2
@

