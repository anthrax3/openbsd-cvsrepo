head	1.88;
access;
symbols
	OPENBSD_6_1:1.88.0.2
	OPENBSD_6_1_BASE:1.88
	OPENBSD_6_0:1.86.0.4
	OPENBSD_6_0_BASE:1.86
	OPENBSD_5_9:1.85.0.2
	OPENBSD_5_9_BASE:1.85
	OPENBSD_5_8:1.76.0.4
	OPENBSD_5_8_BASE:1.76
	OPENBSD_5_7:1.75.0.2
	OPENBSD_5_7_BASE:1.75
	OPENBSD_5_6:1.69.0.4
	OPENBSD_5_6_BASE:1.69
	OPENBSD_5_5:1.60.0.2
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.52.0.2
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.45.0.4
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.2
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10;
locks; strict;
comment	@ * @;


1.88
date	2017.03.30.15.41.04;	author jsing;	state Exp;
branches;
next	1.87;
commitid	EOIJMPIMZICUBfvO;

1.87
date	2016.09.02.09.43.54;	author gilles;	state Exp;
branches;
next	1.86;
commitid	N5b2Umd52gjGPgqL;

1.86
date	2016.04.21.14.27.41;	author jsing;	state Exp;
branches;
next	1.85;
commitid	y261bjeJ4UOVSbjW;

1.85
date	2015.12.13.09.52.44;	author gilles;	state Exp;
branches;
next	1.84;
commitid	OUT78jWdQV3PCjhK;

1.84
date	2015.12.12.20.02.31;	author gilles;	state Exp;
branches;
next	1.83;
commitid	eO2zB2XyKCWqQLmz;

1.83
date	2015.12.12.18.30.39;	author gilles;	state Exp;
branches;
next	1.82;
commitid	wQFhWPpeDYKzQUZq;

1.82
date	2015.12.12.17.16.56;	author gilles;	state Exp;
branches;
next	1.81;
commitid	O1qQ3TEBrjXRGaeN;

1.81
date	2015.12.12.17.14.40;	author gilles;	state Exp;
branches;
next	1.80;
commitid	TNPSXnDBvpPd8thy;

1.80
date	2015.12.05.21.27.42;	author mmcc;	state Exp;
branches;
next	1.79;
commitid	u7cKDttUUhTVcGIY;

1.79
date	2015.11.05.12.35.58;	author jung;	state Exp;
branches;
next	1.78;
commitid	jasZAz9nQhjiEdTD;

1.78
date	2015.10.21.16.45.13;	author jsing;	state Exp;
branches;
next	1.77;
commitid	3rkrfAouOz2CB9Jg;

1.77
date	2015.10.16.21.13.33;	author sthen;	state Exp;
branches;
next	1.76;
commitid	OZlZin0TY3Yru2bR;

1.76
date	2015.03.13.13.42.54;	author giovanni;	state Exp;
branches;
next	1.75;
commitid	GNg6CFi2WUho98HT;

1.75
date	2015.02.06.01.37.11;	author reyk;	state Exp;
branches;
next	1.74;
commitid	Lv0p59uUkApDv6rT;

1.74
date	2015.01.16.15.08.52;	author reyk;	state Exp;
branches;
next	1.73;
commitid	cBAkhi7b4UQjJ650;

1.73
date	2015.01.16.14.34.51;	author reyk;	state Exp;
branches;
next	1.72;
commitid	vhVTw19iFGP02KBT;

1.72
date	2014.10.16.09.40.46;	author gilles;	state Exp;
branches;
next	1.71;
commitid	5P0BKt43rMHaHjhC;

1.71
date	2014.10.02.18.30.21;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	dROFfzwey8u9q5yX;

1.70
date	2014.08.25.07.50.26;	author doug;	state Exp;
branches;
next	1.69;
commitid	vcwz0sp1JH7QzUmA;

1.69
date	2014.07.10.20.16.48;	author jsg;	state Exp;
branches;
next	1.68;
commitid	mobxEvguwOilXuOk;

1.68
date	2014.07.08.14.22.38;	author eric;	state Exp;
branches;
next	1.67;
commitid	6MJxPRdfGlrWYcUf;

1.67
date	2014.05.20.17.33.36;	author reyk;	state Exp;
branches;
next	1.66;

1.66
date	2014.05.20.14.21.45;	author reyk;	state Exp;
branches;
next	1.65;

1.65
date	2014.05.10.21.34.07;	author reyk;	state Exp;
branches;
next	1.64;

1.64
date	2014.05.06.11.03.03;	author reyk;	state Exp;
branches;
next	1.63;

1.63
date	2014.04.29.19.13.14;	author reyk;	state Exp;
branches;
next	1.62;

1.62
date	2014.04.29.10.08.55;	author reyk;	state Exp;
branches;
next	1.61;

1.61
date	2014.04.19.14.09.19;	author gilles;	state Exp;
branches;
next	1.60;

1.60
date	2014.02.17.19.50.09;	author eric;	state Exp;
branches;
next	1.59;

1.59
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.58;

1.58
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.57;

1.57
date	2013.11.28.12.50.40;	author eric;	state Exp;
branches;
next	1.56;

1.56
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.55;

1.55
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.54;

1.54
date	2013.07.19.09.04.06;	author eric;	state Exp;
branches;
next	1.53;

1.53
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.52;

1.52
date	2013.01.26.09.37.24;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.50;

1.50
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.49;

1.49
date	2012.10.14.14.26.31;	author halex;	state Exp;
branches;
next	1.48;

1.48
date	2012.10.09.20.32.25;	author eric;	state Exp;
branches;
next	1.47;

1.47
date	2012.09.14.19.22.04;	author eric;	state Exp;
branches;
next	1.46;

1.46
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.45;

1.45
date	2012.01.29.11.37.32;	author eric;	state Exp;
branches;
next	1.44;

1.44
date	2012.01.11.20.00.37;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2011.12.21.21.10.15;	author chl;	state Exp;
branches;
next	1.42;

1.42
date	2011.12.14.17.51.38;	author eric;	state Exp;
branches;
next	1.41;

1.41
date	2011.12.13.23.55.00;	author gilles;	state Exp;
branches;
next	1.40;

1.40
date	2011.10.27.04.23.19;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2011.10.23.10.44.20;	author chl;	state Exp;
branches;
next	1.38;

1.38
date	2011.10.13.10.54.40;	author eric;	state Exp;
branches;
next	1.37;

1.37
date	2011.09.01.19.56.49;	author eric;	state Exp;
branches;
next	1.36;

1.36
date	2011.05.21.17.01.58;	author gilles;	state Exp;
branches;
next	1.35;

1.35
date	2011.05.17.16.32.58;	author gilles;	state Exp;
branches;
next	1.34;

1.34
date	2011.05.14.11.08.23;	author gilles;	state Exp;
branches;
next	1.33;

1.33
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.32;

1.32
date	2011.03.15.19.24.55;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.30;

1.30
date	2010.11.24.23.27.04;	author todd;	state Exp;
branches;
next	1.29;

1.29
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.01.23.06.25;	author jacekm;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.19.20.57.10;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.11.15.36.10;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.03.07.59.55;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.22.08.23.09;	author jj;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.15.16.50.06;	author jacekm;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.02.22.23.36;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.01.18.02.41;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.30.23.53.41;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.24.14.22.24;	author jacekm;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.19.22.41.35;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.18.20.23.35;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.15.20.34.59;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.04.09.19.49.34;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.15.19.32.11;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.05.21.25.19;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.30.21.52.55;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.30.21.40.21;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.29.14.25.55;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.29.13.00.12;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.11.23.01.16;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.10.00.57.35;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.88
log
@Disable client-initiated renegotiation.

ok gilles@@ eric@@ deraadt@@
@
text
@/*	$OpenBSD: ssl.c,v 1.87 2016/09/02 09:43:54 gilles Exp $	*/

/*
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2008 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2012 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <ctype.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <limits.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <openssl/ssl.h>
#include <openssl/engine.h>
#include <openssl/err.h>
#include <openssl/rsa.h>
#include <openssl/dh.h>
#include <openssl/bn.h>

#include "log.h"
#include "ssl.h"

void
ssl_init(void)
{
	static int	inited = 0;

	if (inited)
		return;

	SSL_library_init();
	SSL_load_error_strings();

	OpenSSL_add_all_algorithms();

	/* Init hardware crypto engines. */
	ENGINE_load_builtin_engines();
	ENGINE_register_all_complete();
	inited = 1;
}

int
ssl_setup(SSL_CTX **ctxp, struct pki *pki,
    int (*sni_cb)(SSL *,int *,void *), const char *ciphers)
{
	SSL_CTX	*ctx;
	uint8_t sid[SSL_MAX_SID_CTX_LENGTH];

	ctx = ssl_ctx_create(pki->pki_name, pki->pki_cert, pki->pki_cert_len, ciphers);

	/*
	 * Set session ID context to a random value.  We don't support
	 * persistent caching of sessions so it is OK to set a temporary
	 * session ID context that is valid during run time.
	 */
	arc4random_buf(sid, sizeof(sid));
	if (!SSL_CTX_set_session_id_context(ctx, sid, sizeof(sid)))
		goto err;

	if (sni_cb)
		SSL_CTX_set_tlsext_servername_callback(ctx, sni_cb);

	SSL_CTX_set_dh_auto(ctx, pki->pki_dhe);

	SSL_CTX_set_ecdh_auto(ctx, 1);

	*ctxp = ctx;
	return 1;

err:
	SSL_CTX_free(ctx);
	ssl_error("ssl_setup");
	return 0;
}

char *
ssl_load_file(const char *name, off_t *len, mode_t perm)
{
	struct stat	 st;
	off_t		 size;
	char		*buf = NULL;
	int		 fd, saved_errno;
	char		 mode[12];

	if ((fd = open(name, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) != 0)
		goto fail;
	if (st.st_uid != 0) {
		log_warnx("warn:  %s: not owned by uid 0", name);
		errno = EACCES;
		goto fail;
	}
	if (st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO) & ~perm) {
		strmode(perm, mode);
		log_warnx("warn:  %s: insecure permissions: must be at most %s",
		    name, &mode[1]);
		errno = EACCES;
		goto fail;
	}
	size = st.st_size;
	if ((buf = calloc(1, size + 1)) == NULL)
		goto fail;
	if (read(fd, buf, size) != size)
		goto fail;
	close(fd);

	*len = size + 1;
	return (buf);

fail:
	free(buf);
	saved_errno = errno;
	close(fd);
	errno = saved_errno;
	return (NULL);
}

#if 0
static int
ssl_password_cb(char *buf, int size, int rwflag, void *u)
{
	size_t	len;
	if (u == NULL) {
		explicit_bzero(buf, size);
		return (0);
	}
	if ((len = strlcpy(buf, u, size)) >= (size_t)size)
		return (0);
	return (len);
}
#endif

static int
ssl_password_cb(char *buf, int size, int rwflag, void *u)
{
	int	ret = 0;
	size_t	len;
	char	*pass;

	pass = getpass((const char *)u);
	if (pass == NULL)
		return 0;
	len = strlen(pass);
	if (strlcpy(buf, pass, size) >= (size_t)size)
		goto end;
	ret = len;
end:
	if (len)
		explicit_bzero(pass, len);
	return ret;
}

char *
ssl_load_key(const char *name, off_t *len, char *pass, mode_t perm, const char *pkiname)
{
	FILE		*fp = NULL;
	EVP_PKEY	*key = NULL;
	BIO		*bio = NULL;
	long		 size;
	char		*data, *buf = NULL;
	struct stat	 st;
	char		 mode[12];
	char		 prompt[2048];

	/* Initialize SSL library once */
	ssl_init();

	/*
	 * Read (possibly) encrypted key from file
	 */
	if ((fp = fopen(name, "r")) == NULL)
		return (NULL);

	if (fstat(fileno(fp), &st) != 0)
		goto fail;
	if (st.st_uid != 0) {
		log_warnx("warn:  %s: not owned by uid 0", name);
		errno = EACCES;
		goto fail;
	}
	if (st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO) & ~perm) {
		strmode(perm, mode);
		log_warnx("warn:  %s: insecure permissions: must be at most %s",
		    name, &mode[1]);
		errno = EACCES;
		goto fail;
	}

	(void)snprintf(prompt, sizeof prompt, "passphrase for %s: ", pkiname);
	key = PEM_read_PrivateKey(fp, NULL, ssl_password_cb, prompt);
	fclose(fp);
	fp = NULL;
	if (key == NULL)
		goto fail;
	/*
	 * Write unencrypted key to memory buffer
	 */
	if ((bio = BIO_new(BIO_s_mem())) == NULL)
		goto fail;
	if (!PEM_write_bio_PrivateKey(bio, key, NULL, NULL, 0, NULL, NULL))
		goto fail;
	if ((size = BIO_get_mem_data(bio, &data)) <= 0)
		goto fail;
	if ((buf = calloc(1, size + 1)) == NULL)
		goto fail;
	memcpy(buf, data, size);

	BIO_free_all(bio);
	EVP_PKEY_free(key);

	*len = (off_t)size + 1;
	return (buf);

fail:
	ssl_error("ssl_load_key");
	free(buf);
	if (bio != NULL)
		BIO_free_all(bio);
	if (key != NULL)
		EVP_PKEY_free(key);
	if (fp)
		fclose(fp);
	return (NULL);
}

SSL_CTX *
ssl_ctx_create(const char *pkiname, char *cert, off_t cert_len, const char *ciphers)
{
	SSL_CTX	*ctx;
	size_t	 pkinamelen = 0;

	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL) {
		ssl_error("ssl_ctx_create");
		fatal("ssl_ctx_create: could not create SSL context");
	}

	SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);
	SSL_CTX_set_timeout(ctx, SSL_SESSION_TIMEOUT);
	SSL_CTX_set_options(ctx,
	    SSL_OP_ALL | SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TICKET);
	SSL_CTX_set_options(ctx,
	    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
	SSL_CTX_set_options(ctx, SSL_OP_NO_CLIENT_RENEGOTIATION);
	SSL_CTX_set_options(ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);

	if (ciphers == NULL)
		ciphers = SSL_CIPHERS;
	if (!SSL_CTX_set_cipher_list(ctx, ciphers)) {
		ssl_error("ssl_ctx_create");
		fatal("ssl_ctx_create: could not set cipher list");
	}

	if (cert != NULL) {
		if (pkiname != NULL)
			pkinamelen = strlen(pkiname) + 1;
		if (!SSL_CTX_use_certificate_chain_mem(ctx, cert, cert_len)) {
			ssl_error("ssl_ctx_create");
			fatal("ssl_ctx_create: invalid certificate chain");
		} else if (!ssl_ctx_fake_private_key(ctx,
		    pkiname, pkinamelen, cert, cert_len, NULL, NULL)) {
			ssl_error("ssl_ctx_create");
			fatal("ssl_ctx_create: could not fake private key");
		} else if (!SSL_CTX_check_private_key(ctx)) {
			ssl_error("ssl_ctx_create");
			fatal("ssl_ctx_create: invalid private key");
		}
	}

	return (ctx);
}

int
ssl_load_certificate(struct pki *p, const char *pathname)
{
	p->pki_cert = ssl_load_file(pathname, &p->pki_cert_len, 0755);
	if (p->pki_cert == NULL)
		return 0;
	return 1;
}

int
ssl_load_keyfile(struct pki *p, const char *pathname, const char *pkiname)
{
	char	pass[1024];

	p->pki_key = ssl_load_key(pathname, &p->pki_key_len, pass, 0740, pkiname);
	if (p->pki_key == NULL)
		return 0;
	return 1;
}

int
ssl_load_cafile(struct ca *c, const char *pathname)
{
	c->ca_cert = ssl_load_file(pathname, &c->ca_cert_len, 0755);
	if (c->ca_cert == NULL)
		return 0;
	return 1;
}

const char *
ssl_to_text(const SSL *ssl)
{
	static char buf[256];

	(void)snprintf(buf, sizeof buf, "version=%s, cipher=%s, bits=%d",
	    SSL_get_version(ssl),
	    SSL_get_cipher_name(ssl),
	    SSL_get_cipher_bits(ssl, NULL));

	return (buf);
}

void
ssl_error(const char *where)
{
	unsigned long	code;
	char		errbuf[128];

	for (; (code = ERR_get_error()) != 0 ;) {
		ERR_error_string_n(code, errbuf, sizeof(errbuf));
		log_debug("debug: SSL library error: %s: %s", where, errbuf);
	}
}

int
ssl_load_pkey(const void *data, size_t datalen, char *buf, off_t len,
    X509 **x509ptr, EVP_PKEY **pkeyptr)
{
	BIO		*in;
	X509		*x509 = NULL;
	EVP_PKEY	*pkey = NULL;
	RSA		*rsa = NULL;
	void		*exdata = NULL;

	if ((in = BIO_new_mem_buf(buf, len)) == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_BUF_LIB);
		return (0);
	}

	if ((x509 = PEM_read_bio_X509(in, NULL,
	    ssl_password_cb, NULL)) == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_PEM_LIB);
		goto fail;
	}

	if ((pkey = X509_get_pubkey(x509)) == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_X509_LIB);
		goto fail;
	}

	BIO_free(in);
	in = NULL;

	if (data != NULL && datalen) {
		if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL ||
		    (exdata = malloc(datalen)) == NULL) {
			SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_EVP_LIB);
			goto fail;
		}

		memcpy(exdata, data, datalen);
		RSA_set_ex_data(rsa, 0, exdata);
		RSA_free(rsa); /* dereference, will be cleaned up with pkey */
	}

	*x509ptr = x509;
	*pkeyptr = pkey;

	return (1);

 fail:
	if (rsa != NULL)
		RSA_free(rsa);
	if (in != NULL)
		BIO_free(in);
	if (pkey != NULL)
		EVP_PKEY_free(pkey);
	if (x509 != NULL)
		X509_free(x509);
	free(exdata);

	return (0);
}

int
ssl_ctx_fake_private_key(SSL_CTX *ctx, const void *data, size_t datalen,
    char *buf, off_t len, X509 **x509ptr, EVP_PKEY **pkeyptr)
{
	int		 ret = 0;
	EVP_PKEY	*pkey = NULL;
	X509		*x509 = NULL;

	if (!ssl_load_pkey(data, datalen, buf, len, &x509, &pkey))
		return (0);

	/*
	 * Use the public key as the "private" key - the secret key
	 * parameters are hidden in an extra process that will be
	 * contacted by the RSA engine.  The SSL/TLS library needs at
	 * least the public key parameters in the current process.
	 */
	ret = SSL_CTX_use_PrivateKey(ctx, pkey);
	if (!ret)
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_SSL_LIB);

	if (pkeyptr != NULL)
		*pkeyptr = pkey;
	else if (pkey != NULL)
		EVP_PKEY_free(pkey);

	if (x509ptr != NULL)
		*x509ptr = x509;
	else if (x509 != NULL)
		X509_free(x509);

	return (ret);
}
@


1.87
log
@turn server preference for ciphers on by default

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.86 2016/04/21 14:27:41 jsing Exp $	*/
d270 1
@


1.86
log
@Use automatic DH parameters, instead of fixed ones. Also disable DHE by
default since it is computationally expensive and a potential DoS vector.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.85 2015/12/13 09:52:44 gilles Exp $	*/
d270 1
@


1.85
log
@refactor a bit to move the SNI handling away from smtp_session into smtp

ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.84 2015/12/12 20:02:31 gilles Exp $	*/
a47 3
static DH	       *get_dh2048(void);
static DH	       *get_dh_from_memory(char *, size_t);

a70 1
	DH	*dh;
d88 1
a88 7
	if (pki->pki_dhparams_len == 0)
		dh = get_dh2048();
	else
		dh = get_dh_from_memory(pki->pki_dhparams,
		    pki->pki_dhparams_len);
	ssl_set_ephemeral_key_exchange(ctx, dh);
	DH_free(dh);
a325 13
int
ssl_load_dhparams(struct pki *p, const char *pathname)
{
	p->pki_dhparams = ssl_load_file(pathname, &p->pki_dhparams_len, 0755);
	if (p->pki_dhparams == NULL) {
		if (errno == EACCES)
			return 0;
		log_info("info: No DH parameters found in %s: "
		    "using built-in parameters", pathname);
	}
	return 1;
}

a347 87
	}
}

/* From OpenSSL's documentation:
 *
 * If "strong" primes were used to generate the DH parameters, it is
 * not strictly necessary to generate a new key for each handshake
 * but it does improve forward secrecy.
 *
 * -- gilles@@
 */
static DH *
get_dh2048(void)
{
	DH *dh;
	unsigned char dh2048_p[] = {
		0xB2,0xE2,0x07,0x34,0x16,0xEB,0x18,0xB5,0xED,0x0F,0xD4,0xC3,
		0xB6,0x6B,0x79,0xDF,0xA1,0x98,0x1C,0x8D,0x68,0x97,0x6C,0xDF,
		0xFF,0x38,0x60,0xEC,0x93,0x40,0xEF,0x26,0x12,0xB8,0x1B,0x79,
		0x68,0x72,0x47,0x8F,0x53,0x4C,0xBF,0x90,0xFF,0xE0,0x3E,0xE7,
		0x43,0x95,0x0B,0x97,0x43,0xDA,0xB4,0xE1,0x85,0x69,0xA5,0x67,
		0xFB,0x10,0x97,0x5A,0x0D,0x11,0xEB,0xED,0x78,0x82,0xCC,0xF5,
		0x7A,0xCC,0x27,0x27,0x5E,0xE5,0x3D,0xBA,0x47,0x38,0xBE,0x18,
		0xCA,0xC7,0x16,0xC7,0x7B,0x9E,0xA7,0xB0,0x80,0xAC,0x92,0x25,
		0x36,0x16,0x8F,0x29,0xA5,0x32,0x01,0x60,0x33,0x7C,0x2C,0x2F,
		0x49,0x7C,0x1D,0x4B,0xDA,0xBD,0xE4,0xF9,0x82,0x2B,0x71,0xCB,
		0x07,0xE3,0xCC,0x65,0x8A,0x1A,0xAB,0x81,0x0F,0xA9,0x96,0x35,
		0x4C,0xFD,0x42,0xFC,0xD6,0xE3,0xE8,0x2E,0x0E,0xAA,0x4D,0x75,
		0x54,0x02,0x49,0xDD,0xC5,0x5F,0x38,0x93,0xFA,0xEF,0x7D,0xBA,
		0x0C,0x75,0x93,0x09,0x8C,0x24,0x65,0xC6,0xF4,0xBF,0x59,0xF0,
		0x5D,0x0A,0xA4,0x26,0x7F,0xDA,0x0F,0x41,0x3A,0x43,0x61,0xDF,
		0x09,0x26,0xA1,0xB0,0xFE,0x8D,0xA6,0x21,0xC1,0xFD,0x41,0x65,
		0x30,0xE7,0xE4,0xD0,0x8E,0x78,0x93,0x3C,0x3E,0x3E,0xCA,0x30,
		0xA7,0x25,0x35,0x24,0x26,0x29,0xAC,0xCE,0x21,0x78,0x3B,0x9D,
		0xDD,0x0B,0x44,0xD0,0x7C,0xEB,0x2F,0xDD,0xE7,0x64,0xBC,0xF7,
		0x40,0x12,0xC8,0x35,0xFA,0x81,0xD6,0x80,0x39,0x1C,0x77,0x72,
		0x86,0x5B,0x19,0xDC,0xCB,0xDC,0xCB,0xF6,0x54,0x6F,0xB1,0xCB,
		0xE4,0xC3,0x05,0xD3
	};
	unsigned char dh2048_g[] = {
		0x02
	};

	if ((dh = DH_new()) == NULL)
		return NULL;

	dh->p = BN_bin2bn(dh2048_p, sizeof(dh2048_p), NULL);
	dh->g = BN_bin2bn(dh2048_g, sizeof(dh2048_g), NULL);
	if (dh->p == NULL || dh->g == NULL) {
		DH_free(dh);
		return NULL;
	}

	return dh;
}

static DH *
get_dh_from_memory(char *params, size_t len)
{
	BIO *mem;
	DH *dh;

	mem = BIO_new_mem_buf(params, len);
	if (mem == NULL)
		return NULL;
	dh = PEM_read_bio_DHparams(mem, NULL, NULL, NULL);
	if (dh == NULL)
		goto err;
	if (dh->p == NULL || dh->g == NULL)
		goto err;
	return dh;

err:
	if (mem != NULL)
		BIO_free(mem);
	if (dh != NULL)
		DH_free(dh);
	return NULL;
}


void
ssl_set_ephemeral_key_exchange(SSL_CTX *ctx, DH *dh)
{
	if (dh == NULL || !SSL_CTX_set_tmp_dh(ctx, dh)) {
		ssl_error("ssl_set_ephemeral_key_exchange");
		fatal("ssl_set_ephemeral_key_exchange: cannot set tmp dh");
@


1.84
log
@remove CA from pki and no longer allow specifying a CA with 'pki' keyword.
introduce 'ca' keyword to allow specifying a custom CA.
making CA part of pki was a bad idea and several people hit use-cases that
plain couldn't work.

instead of:
    pki foobar.org ca "/etc/mail/CA.pem"

use now:
    ca foobar.org certificate "/etc/mail/CA.pem"


ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.83 2015/12/12 18:30:39 gilles Exp $	*/
d71 2
a72 1
ssl_setup(SSL_CTX **ctxp, struct pki *pki, const char *ciphers)
d88 3
@


1.83
log
@do not prevent group from reading key, it prevents a certificate from
being shared between smtpd and another daemon
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.82 2015/12/12 17:16:56 gilles Exp $	*/
d324 1
a324 1
ssl_load_cafile(struct pki *p, const char *pathname)
d326 2
a327 2
	p->pki_ca = ssl_load_file(pathname, &p->pki_ca_len, 0755);
	if (p->pki_ca == NULL)
@


1.82
log
@allow overriding the default cipher-suite

ok jung@@, sunil@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.81 2015/12/12 17:14:40 gilles Exp $	*/
d317 1
a317 1
	p->pki_key = ssl_load_key(pathname, &p->pki_key_len, pass, 0700, pkiname);
@


1.81
log
@bump DH params to 2048, it's been part of smtpd releases for a long time
and I've been running with it since June with no side-effect

ok sunil@@, jung@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.80 2015/12/05 21:27:42 mmcc Exp $	*/
d71 1
a71 1
ssl_setup(SSL_CTX **ctxp, struct pki *pki)
d77 1
a77 1
	ctx = ssl_ctx_create(pki->pki_name, pki->pki_cert, pki->pki_cert_len);
d259 1
a259 1
ssl_ctx_create(const char *pkiname, char *cert, off_t cert_len)
d277 3
a279 1
	if (!SSL_CTX_set_cipher_list(ctx, SSL_CIPHERS)) {
@


1.80
log
@Remove a few NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.79 2015/11/05 12:35:58 jung Exp $	*/
d48 3
d89 1
a89 1
		dh = get_dh1024();
d376 2
a377 2
DH *
get_dh1024(void)
d380 23
a402 17
	unsigned char dh1024_p[] = {
		0xAD,0x37,0xBB,0x26,0x75,0x01,0x27,0x75,
		0x06,0xB5,0xE7,0x1E,0x1F,0x2B,0xBC,0x51,
		0xC0,0xF4,0xEB,0x42,0x7A,0x2A,0x83,0x1E,
		0xE8,0xD1,0xD8,0xCC,0x9E,0xE6,0x15,0x1D,
		0x06,0x46,0x50,0x94,0xB9,0xEE,0xB6,0x89,
		0xB7,0x3C,0xAC,0x07,0x5E,0x29,0x37,0xCC,
		0x8F,0xDF,0x48,0x56,0x85,0x83,0x26,0x02,
		0xB8,0xB6,0x63,0xAF,0x2D,0x4A,0x57,0x93,
		0x6B,0x54,0xE1,0x8F,0x28,0x76,0x9C,0x5D,
		0x90,0x65,0xD1,0x07,0xFE,0x5B,0x05,0x65,
		0xDA,0xD2,0xE2,0xAF,0x23,0xCA,0x2F,0xD6,
		0x4B,0xD2,0x04,0xFE,0xDF,0x21,0x2A,0xE1,
		0xCD,0x1B,0x70,0x76,0xB3,0x51,0xA4,0xC9,
		0x2B,0x68,0xE3,0xDD,0xCB,0x97,0xDA,0x59,
		0x50,0x93,0xEE,0xDB,0xBF,0xC7,0xFA,0xA7,
		0x47,0xC4,0x4D,0xF0,0xC6,0x09,0x4A,0x4B
d404 1
a404 1
	unsigned char dh1024_g[] = {
d411 2
a412 2
	dh->p = BN_bin2bn(dh1024_p, sizeof(dh1024_p), NULL);
	dh->g = BN_bin2bn(dh1024_g, sizeof(dh1024_g), NULL);
d421 1
a421 1
DH *
@


1.79
log
@replace u_char and u_int* with standard stdint.h types to ease portable version
also remove trailing whitespaces while here

no binary change

ok sunil millert gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.78 2015/10/21 16:45:13 jsing Exp $	*/
d140 1
a140 2
	if (buf != NULL)
		free(buf);
@


1.78
log
@Use SSL_CTX_set_ecdh_auto() instead of rolling our own version.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.77 2015/10/16 21:13:33 sthen Exp $	*/
d58 1
a58 1
	
d60 1
a60 1
	
d72 1
a72 1
	u_int8_t sid[SSL_MAX_SID_CTX_LENGTH];
@


1.77
log
@Use SSL_get_version() not SSL_get_cipher_version(); the former gives the TLS
version used for the connection, the latter gives "the SSL/TLS protocol version
that first defined the cipher". Fixes "TLS version=TLSv1/SSLv3" in received/log
lines.

ok millert@@ "I was going to commit this today, so yes definitely" ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.76 2015/03/13 13:42:54 giovanni Exp $	*/
d93 1
a93 1
	ssl_set_ecdh_curve(ctx, SSL_ECDH_CURVE);
a444 25
}

void
ssl_set_ecdh_curve(SSL_CTX *ctx, const char *curve)
{
	int	nid;
	EC_KEY *ecdh;

	if (curve == NULL)
		curve = SSL_ECDH_CURVE;
	if ((nid = OBJ_sn2nid(curve)) == 0) {
		ssl_error("ssl_set_ecdh_curve");
		fatal("ssl_set_ecdh_curve: unknown curve name "
		    SSL_ECDH_CURVE);
	}

	if ((ecdh = EC_KEY_new_by_curve_name(nid)) == NULL) {
		ssl_error("ssl_set_ecdh_curve");
		fatal("ssl_set_ecdh_curve: unable to create curve "
		    SSL_ECDH_CURVE);
	}

	SSL_CTX_set_tmp_ecdh(ctx, ecdh);
	SSL_CTX_set_options(ctx, SSL_OP_SINGLE_ECDH_USE);
	EC_KEY_free(ecdh);
@


1.76
log
@Missing free(3) in error path
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.75 2015/02/06 01:37:11 reyk Exp $	*/
d347 1
a347 1
	    SSL_get_cipher_version(ssl),
@


1.75
log
@Rename SSL_CTX_use_certificate_chain() to SSL_CTX_use_certificate_chain_mem().

As discussed with beck@@ jsing@@ and others
OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.74 2015/01/16 15:08:52 reyk Exp $	*/
d527 1
@


1.74
log
@SSL_CTX_use_certificate_chain() has been added to LibreSSL and there
is no need to keep a local copy in ssl_privsep.c.  This adds a little
burden on OpenSMTPD-portable because it will have to put it in
openbsd-compat for compatibility with legacy OpenSSL.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.73 2015/01/16 14:34:51 reyk Exp $	*/
d283 1
a283 1
		if (!SSL_CTX_use_certificate_chain(ctx, cert, cert_len)) {
@


1.73
log
@The SSL/TLS session Id context is limited to 32 bytes.  Instead of
using the name of relayd relay or smtpd pki, use a 32 byte arc4random
buffer that should be unique for the context.  This fixes an issue in
OpenSMTPD when a long pki name could break the configuration.

OK gilles@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.72 2014/10/16 09:40:46 gilles Exp $	*/
d283 1
a283 1
		if (!ssl_ctx_use_certificate_chain(ctx, cert, cert_len)) {
@


1.72
log
@disable SSLv3

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.71 2014/10/02 18:30:21 deraadt Exp $	*/
d72 1
d76 7
a82 3
	if (!SSL_CTX_set_session_id_context(ctx,
		(const unsigned char *)pki->pki_name,
		strlen(pki->pki_name) + 1))
@


1.71
log
@avoid a double free
ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.70 2014/08/25 07:50:26 doug Exp $	*/
d266 1
a266 1
	    SSL_OP_ALL | SSL_OP_NO_SSLv2 | SSL_OP_NO_TICKET);
@


1.70
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.69 2014/07/10 20:16:48 jsg Exp $	*/
d494 1
@


1.69
log
@add additional includes required to build with -DOPENSSL_NO_DEPRECATED
ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.68 2014/07/08 14:22:38 eric Exp $	*/
d149 1
a149 1
		memset(buf, 0, size);
d174 1
a174 1
		memset(pass, 0, len);
@


1.68
log
@zap trailing tab
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.67 2014/05/20 17:33:36 reyk Exp $	*/
d41 3
@


1.67
log
@Unify the SSL privsep key loading functions.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.66 2014/05/20 14:21:45 reyk Exp $	*/
d274 1
a274 1
			pkinamelen = strlen(pkiname) + 1;	
@


1.66
log
@Deep down inside OpenSSL, err... LibreSSL, RSA_set_ex_data attempts to
free() the external data when releasing the RSA object.  The
RSA_GET_EX_NEW_INDEX(3) manual page doesn't mention that this is the
default behaviour - it just describes the possible free_func()
callback - and the code path in libcrypto is hiding the fact behind
layers of abstraction.

Fix possible double free by allocating and copying the external data
reference that is used for RSA privsep (pkiname in smtpd's case).

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.65 2014/05/10 21:34:07 reyk Exp $	*/
d156 1
a156 1
ssl_getpass_cb(char *buf, int size, int rwflag, void *u)
d212 1
a212 1
	key = PEM_read_PrivateKey(fp, NULL, ssl_getpass_cb, prompt);
d279 1
a279 1
		    pkiname, pkinamelen, cert, cert_len)) {
d465 1
a465 1
ssl_ctx_load_pkey(SSL_CTX *ctx, char *buf, off_t len,
d471 2
d480 1
a480 1
	    ssl_getpass_cb, NULL)) == NULL) {
d492 12
d510 2
a511 2
	ssl_error("ssl_ctx_load_pkey");

d524 1
a524 1
    char *buf, off_t len)
a528 2
	RSA		*rsa = NULL;
	void		*exdata = NULL;
d530 1
a530 1
	if (!ssl_ctx_load_pkey(ctx, buf, len, &x509, &pkey))
a532 11
	if (data != NULL && datalen) {
		if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL ||
		    (exdata = malloc(datalen)) == NULL) {
			SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_EVP_LIB);
			goto done;
		}

		memcpy(exdata, data, datalen);
		RSA_set_ex_data(rsa, 0, exdata);
	}

d540 1
a540 1
	if (!ret) {
a541 2
		ssl_error("ssl_ctx_fake_private_key");
	}
d543 3
a545 4
 done:
	if (rsa != NULL)
		RSA_free(rsa);
	if (pkey != NULL)
d547 4
a550 1
	if (x509 != NULL)
@


1.65
log
@Fix SSL breakage that I accidentally introduced with my previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.64 2014/05/06 11:03:03 reyk Exp $	*/
d249 1
a249 1
ssl_ctx_create(void *pkiname, char *cert, off_t cert_len)
d252 1
d273 2
d279 1
a279 1
		    pkiname, cert, cert_len)) {
d465 1
a465 1
ssl_ctx_load_pkey(SSL_CTX *ctx, void *data, char *buf, off_t len,
a467 1
	int		 ret = 1;
a470 1
	RSA		*rsa = NULL;
d488 2
d493 1
a493 11
	if (data == NULL)
		goto done;

	if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_EVP_LIB);
		goto fail;
	}

	RSA_set_ex_data(rsa, 0, data);
	RSA_free(rsa); /* dereference, will be cleaned up with pkey */
	goto done;
d498 2
a503 1
	ret = 0;
d505 1
a505 5
 done:
	if (in != NULL)
		BIO_free(in);

	return ret;
d509 2
a510 1
ssl_ctx_fake_private_key(SSL_CTX *ctx, void *data, char *buf, off_t len)
d515 2
d518 1
a518 1
	if (!ssl_ctx_load_pkey(ctx, data, buf, len, &x509, &pkey))
d521 11
d544 3
@


1.64
log
@Fix two memory leaks: EVP_PKEY_get1_RSA() returns a referenced key
that requires to call RSA_free() to dereference it after use.  Also
free a temporary key that was read by PEM_read_PrivateKey() and
immediately written into a bio.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.63 2014/04/29 19:13:14 reyk Exp $	*/
d500 1
@


1.63
log
@Implement RSA privilege separation for OpenSMTPD, based on my previous
implementation for relayd(8).  The smtpd(8) pony processes (mta
client, smtp server) don't keep the private keys in memory but send
their private key operations as imsgs to the "lookup"/mta process.
It's worth mentioning that this prevents acidental private key leakage
as it could have been caused by "Heartbleed".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.62 2014/04/29 10:08:55 reyk Exp $	*/
d231 2
d241 2
d465 1
a465 1
	int		 ret = 0;
d487 6
d498 2
a499 8
	if (data)
		RSA_set_ex_data(rsa, 0, data);

	*x509ptr = x509;
	*pkeyptr = pkey;
	ret = 1;

	goto done;
d508 1
@


1.62
log
@It is only required to load the keys and certs into the same SSL
context once.  Simplify the code path by moving the loading from three
different places into ssl_ctx_create():

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.61 2014/04/19 14:09:19 gilles Exp $	*/
d70 1
a70 2
	ctx = ssl_ctx_create(pki->pki_cert, pki->pki_cert_len,
	    pki->pki_key, pki->pki_key_len);
d245 1
a245 1
ssl_ctx_create(char *cert, off_t cert_len, char *key, off_t key_len)
d267 1
a267 1
	if (cert != NULL && key != NULL) {
d271 2
a272 1
		} else if (!ssl_ctx_use_private_key(ctx, key, key_len)) {
d274 1
a274 1
			fatal("ssl_ctx_create: could not use private key");
d455 85
@


1.61
log
@(void) cast a snprintf() call that can't possibly truncate unless we
	suddenly supported a cipher with a name that's > 200 bytes long ...
	... in which case harmless truncation would occur and we'd have to
	readjust our buffer
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.60 2014/02/17 19:50:09 eric Exp $	*/
a68 2
	
	ctx = ssl_ctx_create();
d70 2
a71 6
	if (!ssl_ctx_use_certificate_chain(ctx,
		pki->pki_cert, pki->pki_cert_len))
		goto err;
	if (!ssl_ctx_use_private_key(ctx,
		pki->pki_key, pki->pki_key_len))
		goto err;
a72 2
	if (!SSL_CTX_check_private_key(ctx))
		goto err;
d246 1
a246 1
ssl_ctx_create()
d266 13
@


1.60
log
@fix possible NULL-deref in error code path
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.59 2014/02/04 13:44:41 eric Exp $	*/
d326 1
a326 1
	snprintf(buf, sizeof buf, "version=%s, cipher=%s, bits=%d",
@


1.59
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d248 2
a249 1
	fclose(fp);
@


1.58
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.57 2013/11/28 12:50:40 eric Exp $	*/
d65 1
a65 1
ssl_setup(SSL_CTX **ctxp, struct ssl *ssl)
d73 1
a73 1
		ssl->ssl_cert, ssl->ssl_cert_len))
d76 1
a76 1
		ssl->ssl_key, ssl->ssl_key_len))
d82 2
a83 2
		(const unsigned char *)ssl->ssl_name,
		strlen(ssl->ssl_name) + 1))
d86 1
a86 1
	if (ssl->ssl_dhparams_len == 0)
d89 2
a90 2
		dh = get_dh_from_memory(ssl->ssl_dhparams,
		    ssl->ssl_dhparams_len);
d94 1
a94 1
	ssl_set_ecdh_curve(ctx);
d187 1
a187 1
	FILE		*fp;
d223 1
d248 1
d253 1
a253 1
ssl_ctx_create(void)
d279 1
a279 1
ssl_load_certificate(struct ssl *s, const char *pathname)
d281 2
a282 2
	s->ssl_cert = ssl_load_file(pathname, &s->ssl_cert_len, 0755);
	if (s->ssl_cert == NULL)
d288 1
a288 1
ssl_load_keyfile(struct ssl *s, const char *pathname, const char *pkiname)
d292 2
a293 2
	s->ssl_key = ssl_load_key(pathname, &s->ssl_key_len, pass, 0700, pkiname);
	if (s->ssl_key == NULL)
d299 1
a299 1
ssl_load_cafile(struct ssl *s, const char *pathname)
d301 2
a302 2
	s->ssl_ca = ssl_load_file(pathname, &s->ssl_ca_len, 0755);
	if (s->ssl_ca == NULL)
d308 1
a308 1
ssl_load_dhparams(struct ssl *s, const char *pathname)
d310 2
a311 2
	s->ssl_dhparams = ssl_load_file(pathname, &s->ssl_dhparams_len, 0755);
	if (s->ssl_dhparams == NULL) {
d427 1
a427 1
ssl_set_ecdh_curve(SSL_CTX *ctx)
d432 3
a434 1
	if ((nid = OBJ_sn2nid(SSL_ECDH_CURVE)) == 0) {
@


1.57
log
@fix loading of passphrase-protected keys.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d155 1
a155 1
		bzero(buf, size);
d180 1
a180 1
		bzero(pass, len);
@


1.56
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d149 1
d162 21
d185 1
a185 1
ssl_load_key(const char *name, off_t *len, char *pass)
d192 3
d205 17
a221 1
	key = PEM_read_PrivateKey(fp, NULL, ssl_password_cb, pass);
a224 1

d234 1
a234 1
	if ((buf = calloc(1, size)) == NULL)
d239 1
a239 1
	*len = (off_t)size;
a243 1

d286 1
a286 1
ssl_load_keyfile(struct ssl *s, const char *pathname)
d288 3
a290 1
	s->ssl_key = ssl_load_file(pathname, &s->ssl_key_len, 0700);
@


1.55
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.54 2013/07/19 09:04:06 eric Exp $	*/
d238 1
a238 1
ssl_load_certfile(struct ssl **sp, const char *path, const char *name, uint8_t flags)
a239 14
	struct ssl     *s;
	char		pathname[PATH_MAX];
	int		ret;

	if ((s = calloc(1, sizeof(*s))) == NULL)
		fatal(NULL);

	s->flags = flags;
	(void)strlcpy(s->ssl_name, name, sizeof(s->ssl_name));

	ret =  snprintf(pathname, sizeof(pathname), "%s/%s.crt",
	    path ? path : "/etc/ssl", name);
	if (ret == -1 || (size_t)ret >= sizeof pathname)
		goto err;
d242 3
a244 1
		goto err;
d246 3
a248 4
	ret = snprintf(pathname, sizeof(pathname), "%s/%s.key",
	    path ? path : "/etc/ssl/private", name);
	if (ret == -1 || (size_t)ret >= sizeof pathname)
		goto err;
d251 3
a253 1
		goto err;
d255 3
a257 4
	ret = snprintf(pathname, sizeof(pathname), "%s/%s.ca",
	    path ? path : "/etc/ssl", name);
	if (ret == -1 || (size_t)ret >= sizeof pathname)
		goto err;
d259 4
a262 5
	if (s->ssl_ca == NULL) {
		if (errno == EACCES)
			goto err;
		log_info("info: No CA found in %s", pathname);
	}
d264 3
a266 4
	ret = snprintf(pathname, sizeof(pathname), "%s/%s.dh",
	    path ? path : "/etc/ssl", name);
	if (ret == -1 || (size_t)ret >= sizeof pathname)
		goto err;
d270 1
a270 1
			goto err;
d274 1
a274 16

	*sp = s;
	return (1);

err:
	if (s->ssl_cert != NULL)
		free(s->ssl_cert);
	if (s->ssl_key != NULL)
		free(s->ssl_key);
	if (s->ssl_ca != NULL)
		free(s->ssl_ca);
	if (s->ssl_dhparams != NULL)
		free(s->ssl_dhparams);
	if (s != NULL)
		free(s);
	return (0);
a275 1

@


1.54
log
@tls perfect forward secrecy with ecdhe

suggested by djm@@ on hackers@@, diff ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.53 2013/05/24 17:03:14 eric Exp $	*/
d312 1
a312 1
	snprintf(buf, sizeof buf, "version=%s, cipher=%s, bits=%i",
@


1.53
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.52 2013/01/26 09:37:24 gilles Exp $	*/
d94 2
d411 23
@


1.52
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.50 2012/11/12 14:58:53 eric Exp $	*/
a23 1
#include <sys/param.h>
d31 1
a322 1
	extern int	debug;
a324 2
		if (!debug)
			continue;
@


1.51
log
@knf

ok gilles@@
@
text
@d6 1
a41 1
#include "smtpd.h"
d43 1
d45 4
a48 1
#define SSL_CIPHERS	"HIGH"
d50 2
a51 3
void	 ssl_error(const char *);
char	*ssl_load_file(const char *, off_t *, mode_t);
SSL_CTX	*ssl_ctx_create(void);
d53 10
a62 1
SSL	*ssl_client_init(int, char *, size_t, char *, size_t);
d64 7
a70 3
DH	*get_dh1024(void);
DH	*get_dh_from_memory(char *, size_t);
void	 ssl_set_ephemeral_key_exchange(SSL_CTX *, DH *);
d72 6
a77 1
extern int ssl_ctx_load_verify_memory(SSL_CTX *, char *, off_t);
d79 22
a100 4
int
ssl_cmp(struct ssl *s1, struct ssl *s2)
{
	return (strcmp(s1->ssl_name, s2->ssl_name));
a102 2
SPLAY_GENERATE(ssltree, ssl, ssl_nodes, ssl_cmp);

d147 62
d221 1
a221 1
	SSL_CTX_set_timeout(ctx, SMTPD_SESSION_TIMEOUT);
d236 1
a236 1
ssl_load_certfile(const char *name, uint8_t flags)
d238 3
a240 16
	struct ssl	*s;
	struct ssl	 key;
	char		 certfile[PATH_MAX];

	if (strlcpy(key.ssl_name, name, sizeof(key.ssl_name))
	    >= sizeof(key.ssl_name)) {
		log_warnx("warn: ssl_load_certfile: "
		    "certificate name truncated");
		return -1;
	}

	s = SPLAY_FIND(ssltree, env->sc_ssl, &key);
	if (s != NULL) {
		s->flags |= flags;
		return 0;
	}
d246 1
a246 1
	(void)strlcpy(s->ssl_name, key.ssl_name, sizeof(s->ssl_name));
d248 3
a250 2
	if (! bsnprintf(certfile, sizeof(certfile),
		"/etc/mail/certs/%s.crt", name))
d252 1
a252 2

	s->ssl_cert = ssl_load_file(certfile, &s->ssl_cert_len, 0755);
d256 3
a258 2
	if (! bsnprintf(certfile, sizeof(certfile),
		"/etc/mail/certs/%s.key", name))
d260 1
a260 2

	s->ssl_key = ssl_load_file(certfile, &s->ssl_key_len, 0700);
d264 3
a266 2
	if (! bsnprintf(certfile, sizeof(certfile),
		"/etc/mail/certs/%s.ca", name))
d268 1
a268 2

	s->ssl_ca = ssl_load_file(certfile, &s->ssl_ca_len, 0755);
d272 1
a272 1
		log_warnx("warn:  no CA found in %s", certfile);
d275 3
a277 2
	if (! bsnprintf(certfile, sizeof(certfile),
		"/etc/mail/certs/%s.dh", name))
d279 1
a279 2

	s->ssl_dhparams = ssl_load_file(certfile, &s->ssl_dhparams_len, 0755);
d284 1
a284 1
		    "using built-in parameters", certfile);
d287 2
a288 1
	SPLAY_INSERT(ssltree, env->sc_ssl, s);
a289 1
	return (0);
d295 2
d301 1
a301 14
	return (-1);
}

void
ssl_init(void)
{
	SSL_library_init();
	SSL_load_error_strings();

	OpenSSL_add_all_algorithms();

	/* Init hardware crypto engines. */
	ENGINE_load_builtin_engines();
	ENGINE_register_all_complete();
a303 56
void
ssl_setup(struct listener *l)
{
	struct ssl	key;
	DH *dh;

	if (!(l->flags & F_SSL))
		return;

	if (strlcpy(key.ssl_name, l->ssl_cert_name, sizeof(key.ssl_name))
	    >= sizeof(key.ssl_name))
		fatal("ssl_setup: certificate name truncated");

	if ((l->ssl = SPLAY_FIND(ssltree, env->sc_ssl, &key)) == NULL)
		fatal("ssl_setup: certificate tree corrupted");

	l->ssl_ctx = ssl_ctx_create();

	if (l->ssl->ssl_ca != NULL) {
		if (! ssl_ctx_load_verify_memory(l->ssl_ctx,
			l->ssl->ssl_ca, l->ssl->ssl_ca_len))
			goto err;
	}

	if (!ssl_ctx_use_certificate_chain(l->ssl_ctx,
	    l->ssl->ssl_cert, l->ssl->ssl_cert_len))
		goto err;
	if (!ssl_ctx_use_private_key(l->ssl_ctx,
	    l->ssl->ssl_key, l->ssl->ssl_key_len))
		goto err;

	if (!SSL_CTX_check_private_key(l->ssl_ctx))
		goto err;
	if (!SSL_CTX_set_session_id_context(l->ssl_ctx,
		(const unsigned char *)l->ssl_cert_name,
		strlen(l->ssl_cert_name) + 1))
		goto err;

	if (l->ssl->ssl_dhparams_len == 0)
		dh = get_dh1024();
	else
		dh = get_dh_from_memory(l->ssl->ssl_dhparams,
		    l->ssl->ssl_dhparams_len);
	ssl_set_ephemeral_key_exchange(l->ssl_ctx, dh);
	DH_free(dh);

	log_debug("debug: ssl_setup: ssl setup finished for listener: %p", l);
	return;

err:
	if (l->ssl_ctx != NULL)
		SSL_CTX_free(l->ssl_ctx);
	ssl_error("ssl_setup");
	fatal("ssl_setup: cannot set SSL up");
	return;
}
d306 2
a307 1
ssl_to_text(void *ssl) {
a324 2
	if (!debug)
		return;
d326 2
a331 101

SSL *
ssl_client_init(int fd, char *cert, size_t certsz, char *key, size_t keysz)
{
	SSL_CTX		*ctx;
	SSL		*ssl = NULL;
	int		 rv = -1;

	ctx = ssl_ctx_create();

	if (cert && key) {
		if (!ssl_ctx_use_certificate_chain(ctx, cert, certsz))
			goto done;
		else if (!ssl_ctx_use_private_key(ctx, key, keysz))
			goto done;
		else if (!SSL_CTX_check_private_key(ctx))
			goto done;
	}

	if ((ssl = SSL_new(ctx)) == NULL)
		goto done;
	SSL_CTX_free(ctx);

	if (!SSL_set_ssl_method(ssl, SSLv23_client_method()))
		goto done;
	if (!SSL_set_fd(ssl, fd))
		goto done;
	SSL_set_connect_state(ssl);

	rv = 0;
done:
	if (rv) {
		if (ssl)
			SSL_free(ssl);
		else if (ctx)
			SSL_CTX_free(ctx);
		ssl = NULL;
	}
	return (ssl);
}

void *
ssl_mta_init(struct ssl *s)
{
	SSL_CTX		*ctx;
	SSL		*ssl = NULL;
	int		 rv = -1;

	ctx = ssl_ctx_create();

	if (s && s->ssl_cert && s->ssl_key) {
		if (!ssl_ctx_use_certificate_chain(ctx,
		    s->ssl_cert, s->ssl_cert_len))
			goto done;
		else if (!ssl_ctx_use_private_key(ctx,
		    s->ssl_key, s->ssl_key_len))
			goto done;
		else if (!SSL_CTX_check_private_key(ctx))
			goto done;
	}

	if ((ssl = SSL_new(ctx)) == NULL)
		goto done;
	SSL_CTX_free(ctx);

	if (!SSL_set_ssl_method(ssl, SSLv23_client_method()))
		goto done;

	rv = 0;
done:
	if (rv) {
		if (ssl)
			SSL_free(ssl);
		else if (ctx)
			SSL_CTX_free(ctx);
		ssl = NULL;
	}
	return (void*)(ssl);
}

void *
ssl_smtp_init(void *ssl_ctx)
{
	SSL *ssl;

	log_debug("debug: session_start_ssl: switching to SSL");

	if ((ssl = SSL_new(ssl_ctx)) == NULL)
		goto err;
	if (!SSL_set_ssl_method(ssl, SSLv23_server_method()))
		goto err;

	return (void*)(ssl);

    err:
	if (ssl != NULL)
		SSL_free(ssl);
	ssl_error("ssl_session_init");
	return (NULL);
}

@


1.50
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.49 2012/10/14 14:26:31 halex Exp $	*/
d145 2
a146 1
		log_warnx("warn:  ssl_load_certfile: certificate name truncated");
d400 3
a402 3
                goto err;
        if (!SSL_set_ssl_method(ssl, SSLv23_server_method()))
                goto err;
d404 1
a404 1
        return (void*)(ssl);
d448 1
a448 1
        if ((dh = DH_new()) == NULL)
d451 3
a453 3
        dh->p = BN_bin2bn(dh1024_p, sizeof(dh1024_p), NULL);
        dh->g = BN_bin2bn(dh1024_g, sizeof(dh1024_g), NULL);
        if (dh->p == NULL || dh->g == NULL) {
d458 1
a458 1
        return dh;
d465 1
a465 1
        DH *dh;
d473 1
a473 1
        if (dh->p == NULL || dh->g == NULL)
@


1.49
log
@enforce different permissions on different files in ssl_load_file()

with gilles and eric, tested by me and gilles

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.48 2012/10/09 20:32:25 eric Exp $	*/
d80 1
a80 1
		log_info("%s: not owned by uid 0", name);
d86 1
a86 1
		log_info("%s: insecure permissions: must be at most %s",
d145 1
a145 1
		log_warn("ssl_load_certfile: certificate name truncated");
d185 1
a185 1
		log_info("no CA found in %s", certfile);
d196 2
a197 2
		log_info("no DH parameters found in %s", certfile);
		log_info("using built-in DH parameters");
d274 1
a274 1
	log_debug("ssl_setup: ssl setup finished for listener: %p", l);
d285 12
d308 1
a308 1
		log_debug("SSL library error: %s: %s", where, errbuf);
d396 1
a396 1
	log_debug("session_start_ssl: switching to SSL");
@


1.48
log
@Reject ssl key/certs/CA/DH files if their ownership/permissions are not
correct (uid 0, no rights for g/o).

Initial diff by Sunil Nimmagadda.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.47 2012/09/14 19:22:04 eric Exp $	*/
d47 1
a47 1
char	*ssl_load_file(const char *, off_t *);
d67 1
a67 1
ssl_load_file(const char *name, off_t *len)
d73 1
d84 4
a87 3
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_info("%s: incorrect group/world permissions: must be 0",
		    name);
d165 2
a166 1
	if ((s->ssl_cert = ssl_load_file(certfile, &s->ssl_cert_len)) == NULL)
d173 2
a174 1
	if ((s->ssl_key = ssl_load_file(certfile, &s->ssl_key_len)) == NULL)
d181 2
a182 1
	if ((s->ssl_ca = ssl_load_file(certfile, &s->ssl_ca_len)) == NULL) {
d192 2
a193 2
	if ((s->ssl_dhparams = ssl_load_file(certfile, &s->ssl_dhparams_len))
	    == NULL) {
@


1.47
log
@Remove s_ssl from the smtp session since it is duplicated in the io struct.
Change ssl_session_init to ssl_smtp_init and make it simpler:  only create
an SSL* from the SSL_CTX* passed as parameter, so it does not have to know
about the struct session itself.  Kill some dead prototypes while there.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.46 2012/08/19 14:16:58 chl Exp $	*/
d72 1
a72 1
	int		 fd;
d78 11
d102 1
d104 1
d177 3
a179 2
	if ((s->ssl_ca = ssl_load_file(certfile,
		    &s->ssl_ca_len)) == NULL) {
d187 4
a190 2
	if ((s->ssl_dhparams = ssl_load_file(certfile,
		    &s->ssl_dhparams_len)) == NULL) {
@


1.46
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.45 2012/01/29 11:37:32 eric Exp $	*/
d358 2
a359 2
void
ssl_session_init(struct session *s)
d361 1
a361 4
	struct listener	*l;
	SSL            	*ssl;

	l = s->s_l;
d363 1
a363 1
        log_debug("session_start_ssl: switching to SSL");
d365 1
a365 2
        ssl = SSL_new(l->ssl_ctx);
        if (ssl == NULL)
a366 1

d370 1
a370 2
        s->s_ssl = ssl;
        return;
d376 1
@


1.45
log
@Rewrite io code in smtp and mta using the iobuf/ioev interface to have
a better separation between io and protocol logic.  As a side-effect,
it fixes a couple of long-standing issues in the io path, and
hopefully add fresh ones instead.  Kill client.c in the process.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.44 2012/01/11 20:00:37 gilles Exp $	*/
d122 1
a122 1
ssl_load_certfile(const char *name, u_int8_t flags)
@


1.44
log
@enable back CA support, just don't verify client ...

tested @@ home
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.43 2011/12/21 21:10:15 chl Exp $	*/
a48 5
void	 ssl_session_accept(int, short, void *);
void	 ssl_read(int, short, void *);
void	 ssl_write(int, short, void *);
int	 ssl_bufferevent_add(struct event *, int);
void	 ssl_connect(int, short, void *);
a51 3
int	 ssl_buf_read(SSL *, struct ibuf_read *);
int	 ssl_buf_write(SSL *, struct msgbuf *);

a57 224
extern void	bufferevent_read_pressure_cb(struct evbuffer *, size_t,
		    size_t, void *);

void
ssl_connect(int fd, short event, void *p)
{
	struct session	*s = p;
	int		 ret;
	int		 retry_flag;
	int		 ssl_err;

	if (event == EV_TIMEOUT) {
		log_debug("ssl_connect: session timed out");
		session_destroy(s);
		return;
	}

	ret = SSL_connect(s->s_ssl);
	if (ret <= 0) {
		ssl_err = SSL_get_error(s->s_ssl, ret);

		switch (ssl_err) {
		case SSL_ERROR_WANT_READ:
			retry_flag = EV_READ;
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			retry_flag = EV_WRITE;
			goto retry;
		case SSL_ERROR_ZERO_RETURN:
		case SSL_ERROR_SYSCALL:
			if (ret == 0) {
				log_debug("session destroy in MTA #1");
				session_destroy(s);
				return;
			}
			/* FALLTHROUGH */
		default:
			ssl_error("ssl_session_connect");
			session_destroy(s);
			return;
		}
	}

	event_set(&s->s_bev->ev_read, s->s_fd, EV_READ, ssl_read, s->s_bev);
	event_set(&s->s_bev->ev_write, s->s_fd, EV_WRITE, ssl_write, s->s_bev);

	log_info("ssl_connect: connected to remote ssl server");
	bufferevent_enable(s->s_bev, EV_READ|EV_WRITE);
	s->s_flags |= F_SECURE;

	if (s->s_flags & F_PEERHASTLS) {
		session_respond(s, "EHLO %s", env->sc_hostname);
	}

	return;
retry:
	event_set(&s->s_ev, s->s_fd, EV_TIMEOUT|retry_flag, ssl_connect, s);
	event_add(&s->s_ev, &s->s_tv);
}

void
ssl_read(int fd, short event, void *p)
{
	struct bufferevent	*bufev = p;
	struct session		*s = bufev->cbarg;
	int			 ret;
	int			 ssl_err;
	short			 what;
	size_t			 len;
	char			 rbuf[IBUF_READ_SIZE];
	int			 howmuch = IBUF_READ_SIZE;

	what = EVBUFFER_READ;
	ret = ssl_err = 0;

	if (event == EV_TIMEOUT) {
		what |= EVBUFFER_TIMEOUT;
		goto err;
	}

	if (bufev->wm_read.high != 0)
		howmuch = MIN(sizeof(rbuf), bufev->wm_read.high);

	ret = SSL_read(s->s_ssl, rbuf, howmuch);
	if (ret <= 0) {
		ssl_err = SSL_get_error(s->s_ssl, ret);

		switch (ssl_err) {
		case SSL_ERROR_WANT_READ:
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			goto retry;
		default:
			if (ret == 0)
				what |= EVBUFFER_EOF;
			else {
				ssl_error("ssl_read");
				what |= EVBUFFER_ERROR;
			}
			goto err;
		}
	}

	if (evbuffer_add(bufev->input, rbuf, ret) == -1) {
		what |= EVBUFFER_ERROR;
		goto err;
	}

	ssl_bufferevent_add(&bufev->ev_read, bufev->timeout_read);

	len = EVBUFFER_LENGTH(bufev->input);
	if (bufev->wm_read.low != 0 && len < bufev->wm_read.low)
		return;
	if (bufev->wm_read.high != 0 && len > bufev->wm_read.high) {
		struct evbuffer *buf = bufev->input;
		event_del(&bufev->ev_read);
		evbuffer_setcb(buf, bufferevent_read_pressure_cb, bufev);
		return;
	}

	if (bufev->readcb != NULL)
		(*bufev->readcb)(bufev, bufev->cbarg);
	return;

retry:
	ssl_bufferevent_add(&bufev->ev_read, bufev->timeout_read);
	return;

err:
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}


void
ssl_write(int fd, short event, void *p)
{
	struct bufferevent	*bufev = p;
	struct session		*s = bufev->cbarg;
	int			 ret;
	int			 ssl_err;
	short			 what;

	ret = 0;
	what = EVBUFFER_WRITE;

	if (event == EV_TIMEOUT) {
		what |= EV_TIMEOUT;
		goto err;
	}

	if (EVBUFFER_LENGTH(bufev->output)) {
		if (s->s_buf == NULL) {
			s->s_buflen = EVBUFFER_LENGTH(bufev->output);
			if ((s->s_buf = malloc(s->s_buflen)) == NULL) {
				what |= EVBUFFER_ERROR;
				goto err;
			}
			memcpy(s->s_buf, EVBUFFER_DATA(bufev->output),
			    s->s_buflen);
		}

		ret = SSL_write(s->s_ssl, s->s_buf, s->s_buflen);
		if (ret <= 0) {
			ssl_err = SSL_get_error(s->s_ssl, ret);

			switch (ssl_err) {
			case SSL_ERROR_WANT_READ:
				goto retry;
			case SSL_ERROR_WANT_WRITE:
				goto retry;
			default:
				if (ret == 0)
					what |= EVBUFFER_EOF;
				else {
					ssl_error("ssl_write");
					what |= EVBUFFER_ERROR;
				}
				goto err;
			}
		}
		evbuffer_drain(bufev->output, ret);
	}
	if (s->s_buf != NULL) {
		free(s->s_buf);
		s->s_buf = NULL;
		s->s_buflen = 0;
	}
	if (EVBUFFER_LENGTH(bufev->output) != 0)
		ssl_bufferevent_add(&bufev->ev_write, bufev->timeout_write);

	if (bufev->writecb != NULL &&
	    EVBUFFER_LENGTH(bufev->output) <= bufev->wm_write.low)
		(*bufev->writecb)(bufev, bufev->cbarg);
	return;

retry:
	if (s->s_buflen != 0)
		ssl_bufferevent_add(&bufev->ev_write, bufev->timeout_write);
	return;

err:
	if (s->s_buf != NULL) {
		free(s->s_buf);
		s->s_buf = NULL;
		s->s_buflen = 0;
	}
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}

int
ssl_bufferevent_add(struct event *ev, int timeout)
{
	struct timeval	 tv;
	struct timeval	*ptv = NULL;

	if (timeout) {
		timerclear(&tv);
		tv.tv_sec = timeout;
		ptv = &tv;
	}

	return (event_add(ev, ptv));
}

a278 98
void
ssl_session_accept(int fd, short event, void *p)
{
	struct session	*s = p;
	int		 ret;
	int		 retry_flag;
	int		 ssl_err;

	if (event == EV_TIMEOUT) {
		log_debug("ssl_session_accept: session timed out");
		session_destroy(s);
		return;
	}

	retry_flag = ssl_err = 0;

	log_debug("ssl_session_accept: accepting client");
	ret = SSL_accept(s->s_ssl);
	if (ret <= 0) {
		ssl_err = SSL_get_error(s->s_ssl, ret);

		switch (ssl_err) {
		case SSL_ERROR_WANT_READ:
			retry_flag = EV_READ;
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			retry_flag = EV_WRITE;
			goto retry;
		case SSL_ERROR_ZERO_RETURN:
		case SSL_ERROR_SYSCALL:
			if (ret == 0) {
				session_destroy(s);
				return;
			}
			/* FALLTHROUGH */
		default:
			ssl_error("ssl_session_accept");
			session_destroy(s);
			return;
		}
	}


	log_info("ssl_session_accept: accepted ssl client");
	s->s_flags |= F_SECURE;

	if (s->s_l->flags & F_SMTPS)
		stat_increment(STATS_SMTP_SMTPS);

	if (s->s_l->flags & F_STARTTLS)
		stat_increment(STATS_SMTP_STARTTLS);

	session_bufferevent_new(s);
	event_set(&s->s_bev->ev_read, s->s_fd, EV_READ, ssl_read, s->s_bev);
	event_set(&s->s_bev->ev_write, s->s_fd, EV_WRITE, ssl_write, s->s_bev);
	session_pickup(s, NULL);

	return;
retry:
	event_add(&s->s_ev, &s->s_tv);
}

void
ssl_session_init(struct session *s)
{
	struct listener	*l;
	SSL             *ssl;

	l = s->s_l;

	if (!(l->flags & F_SSL))
		return;

	log_debug("ssl_session_init: switching to SSL");
	ssl = SSL_new(l->ssl_ctx);
	if (ssl == NULL)
		goto err;

	if (!SSL_set_ssl_method(ssl, SSLv23_server_method()))
		goto err;
	if (!SSL_set_fd(ssl, s->s_fd))
		goto err;
	SSL_set_accept_state(ssl);

	s->s_ssl = ssl;

	s->s_tv.tv_sec = SMTPD_SESSION_TIMEOUT;
	s->s_tv.tv_usec = 0;
	event_set(&s->s_ev, s->s_fd, EV_READ|EV_TIMEOUT, ssl_session_accept, s);
	event_add(&s->s_ev, &s->s_tv);
	return;

 err:
	if (ssl != NULL)
		SSL_free(ssl);
	ssl_error("ssl_session_init");
}

d319 2
a320 2
void
ssl_session_destroy(struct session *s)
d322 5
a326 1
	SSL_free(s->s_ssl);
d328 9
a336 3
	if (s->s_l == NULL) {
		/* called from mta */
		return;
d339 17
a355 7
	if (s->s_l->flags & F_SMTPS)
		if (s->s_flags & F_SECURE)
			stat_decrement(STATS_SMTP_SMTPS);

	if (s->s_l->flags & F_STARTTLS)
		if (s->s_flags & F_SECURE)
			stat_decrement(STATS_SMTP_STARTTLS);
d358 2
a359 2
int
ssl_buf_read(SSL *s, struct ibuf_read *r)
d361 2
a362 3
	u_char	*buf = r->buf + r->wpos;
	ssize_t	 bufsz = sizeof(r->buf) - r->wpos;
	int	 ret;
d364 1
a364 4
	if (bufsz == 0) {
		errno = EMSGSIZE;
		return (SSL_ERROR_SYSCALL);
	}
d366 1
a366 2
	if ((ret = SSL_read(s, buf, bufsz)) > 0)
		r->wpos += ret;
d368 3
a370 2
	return SSL_get_error(s, ret);
}
d372 2
a373 9
int
ssl_buf_write(SSL *s, struct msgbuf *msgbuf)
{
	struct ibuf	*buf;
	int		 ret;
	
	buf = TAILQ_FIRST(&msgbuf->bufs);
	if (buf == NULL)
		return (SSL_ERROR_NONE);
d375 2
a376 1
	ret = SSL_write(s, buf->buf + buf->rpos, buf->wpos - buf->rpos);
d378 5
a382 2
	if (ret > 0)
		msgbuf_drain(msgbuf, ret);
a383 2
	return SSL_get_error(s, ret);
}
@


1.43
log
@disable temporarily CA support, it prevents some remote hosts from
establishing a ssl session. will be investigated and reenabled soon

asked and commited on behalf of gilles@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.42 2011/12/14 17:51:38 eric Exp $	*/
a456 1
/*
a460 1
		SSL_CTX_set_verify(l->ssl_ctx, SSL_VERIFY_PEER, NULL);
a461 1
*/
@


1.42
log
@add missing prototype

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.41 2011/12/13 23:55:00 gilles Exp $	*/
d457 1
d464 1
@


1.41
log
@*finally* make use of certificate authority file if available !

bits from relayd, ok chl@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.40 2011/10/27 04:23:19 guenther Exp $	*/
d63 2
@


1.40
log
@Don't offer or negotiate SSLv2 and, since we don't do SSL session
caching, don't try to negotiate an RFC 4507-style session ticket,
as it would be useless and some (broken and non-compliant) servers
choke on TLS extension negotiation.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.39 2011/10/23 10:44:20 chl Exp $	*/
d347 1
d391 9
d455 7
a474 2


@


1.39
log
@add a missing DH_free() after ssl_set_ephemeral_key_exchange().

tested by gilles@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.38 2011/10/13 10:54:40 eric Exp $	*/
d338 2
a339 1
	SSL_CTX_set_options(ctx, SSL_OP_ALL);
@


1.38
log
@Drop a reference to the client SSL_CTX after SSL_new(), so that it is
correctly freed by SSL_free() at the end of the session.

Plug a leak in the mta.

ok! gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.37 2011/09/01 19:56:49 eric Exp $	*/
d466 1
@


1.37
log
@Introduce a small set of functions to manage stat counters in a
simpler and hopefully saner way.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.36 2011/05/21 17:01:58 gilles Exp $	*/
d611 1
@


1.36
log
@make the "no DH parameters" warning a log_info()
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.35 2011/05/17 16:32:58 gilles Exp $	*/
d539 5
a543 12
	if (s->s_l->flags & F_SMTPS) {
		env->stats->smtp.smtps++;
		env->stats->smtp.smtps_active++;
		SET_IF_GREATER(env->stats->smtp.smtps_active,
			env->stats->smtp.smtps_maxactive);
	}
	if (s->s_l->flags & F_STARTTLS) {
		env->stats->smtp.starttls++;
		env->stats->smtp.starttls_active++;
		SET_IF_GREATER(env->stats->smtp.starttls_active,
			env->stats->smtp.starttls_maxactive);
	}
d640 1
a640 1
	if (s->s_l->flags & F_SMTPS) {
d642 3
a644 3
			env->stats->smtp.smtps_active--;
	}
	if (s->s_l->flags & F_STARTTLS) {
d646 1
a646 2
			env->stats->smtp.starttls_active--;
	}
@


1.35
log
@somehow a previous sync with relayd missed one line...
if a ssl_connect() call needs to retry because of SSL_WANT_READ or
SSL_WANT_WRITE, set the proper event flag instead of keeping the default
one which is both read and write.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.34 2011/05/14 11:08:23 gilles Exp $	*/
d394 2
a395 2
		log_warnx("no DH parameters found in %s", certfile);
		log_warnx("using built-in DH parameters");
@


1.34
log
@more clang warnings fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.33 2011/05/01 12:57:11 eric Exp $	*/
d120 1
@


1.33
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.32 2011/03/15 19:24:55 gilles Exp $	*/
d61 1
a61 1
DH	*get_dh_from_memory(u_int8_t *, size_t);
d659 1
a659 1
	char	*buf = r->buf + r->wpos;
d740 1
a740 1
get_dh_from_memory(u_int8_t *params, size_t len)
@


1.32
log
@let smtpd use user-provided Diffie-Hellman parameters for ephemeral key
exchange. if no DH parameters are found, fallback to builtin parameters
as was done until now.

since we now accept user-provided DH parameters, make smtpd more strict
and fatal() if the parameters are bogus.

bump the key size of the DH parameters from 512bits to 1024bits, it might
be bumped further after some more research.

thanks to mikeb@@ for his suggestions

diff ok mikeb@@ , man ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.31 2010/11/28 13:56:43 gilles Exp $	*/
d115 1
a115 1
		session_respond(s, "EHLO %s", s->s_env->sc_hostname);
d349 1
a349 1
ssl_load_certfile(struct smtpd *env, const char *name, u_int8_t flags)
d426 1
a426 1
ssl_setup(struct smtpd *env, struct listener *l)
d539 4
a542 4
		s->s_env->stats->smtp.smtps++;
		s->s_env->stats->smtp.smtps_active++;
		SET_IF_GREATER(s->s_env->stats->smtp.smtps_active,
			s->s_env->stats->smtp.smtps_maxactive);
d545 4
a548 4
		s->s_env->stats->smtp.starttls++;
		s->s_env->stats->smtp.starttls_active++;
		SET_IF_GREATER(s->s_env->stats->smtp.starttls_active,
			s->s_env->stats->smtp.starttls_maxactive);
d648 1
a648 1
			s->s_env->stats->smtp.smtps_active--;
d652 1
a652 1
			s->s_env->stats->smtp.starttls_active--;
@


1.31
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.30 2010/11/24 23:27:04 todd Exp $	*/
d60 3
a62 2
DH	*get_dh512(void);
void	 ssl_set_ephemeral_key_exchange(SSL_CTX *);
a66 25
/* From OpenSSL's documentation:
 *
 * If "strong" primes were used to generate the DH parameters, it is
 * not strictly necessary to generate a new key for each handshake
 * but it does improve forward secrecy.
 *
 * These are the parameters used by both sendmail and openssl's
 * s_server.
 *
 * -- gilles@@
 */

unsigned char dh512_p[] = {
        0xDA,0x58,0x3C,0x16,0xD9,0x85,0x22,0x89,0xD0,0xE4,0xAF,0x75,
        0x6F,0x4C,0xCA,0x92,0xDD,0x4B,0xE5,0x33,0xB8,0x04,0xFB,0x0F,
        0xED,0x94,0xEF,0x9C,0x8A,0x44,0x03,0xED,0x57,0x46,0x50,0xD3,
        0x69,0x99,0xDB,0x29,0xD7,0x76,0x27,0x6B,0xA2,0xD3,0xD4,0x12,
        0xE2,0x18,0xF4,0xDD,0x1E,0x08,0x4C,0xF6,0xD8,0x00,0x3E,0x7C,
        0x47,0x74,0xE8,0x33,    
};

unsigned char dh512_g[] = {
        0x02,
};

d374 9
a382 4
		"/etc/mail/certs/%s.crt", name)) {
		free(s);
		return (-1);
	}
d384 2
a385 4
	if ((s->ssl_cert = ssl_load_file(certfile, &s->ssl_cert_len)) == NULL) {
		free(s);
		return (-1);
	}
d388 2
a389 5
		"/etc/mail/certs/%s.key", name)) {
		free(s->ssl_cert);
		free(s);
		return -1;
	}
d391 4
a394 4
	if ((s->ssl_key = ssl_load_file(certfile, &s->ssl_key_len)) == NULL) {
		free(s->ssl_cert);
		free(s);
		return (-1);
d400 10
d429 1
d453 2
a454 1
		(const unsigned char *)l->ssl_cert_name, strlen(l->ssl_cert_name) + 1))
d457 8
a464 1
	ssl_set_ephemeral_key_exchange(l->ssl_ctx);
d692 8
d701 1
a701 1
get_dh512(void)
d703 23
a725 2
        DH *dh;
	
d729 22
a750 2
        dh->p = BN_bin2bn(dh512_p, sizeof(dh512_p), NULL);
        dh->g = BN_bin2bn(dh512_g, sizeof(dh512_g), NULL);
d752 2
a753 1
                return NULL;
d755 6
a760 1
        return dh;
d765 1
a765 1
ssl_set_ephemeral_key_exchange(SSL_CTX *ctx)
d767 4
a770 5
	DH *dh;

	dh = get_dh512();
	if (dh != NULL)
		SSL_CTX_set_tmp_dh(ctx, dh);
@


1.30
log
@add *maxactive stats
"ok and no need to keep them for yourself" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.29 2010/10/09 22:05:35 gilles Exp $	*/
d30 1
d42 1
@


1.29
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.25 2010/05/26 13:56:08 nicm Exp $	*/
d544 2
d550 2
@


1.28
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.26 2010/05/31 23:38:56 jacekm Exp $	*/
d553 1
a553 1
	session_pickup(s);
@


1.27
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.25 2010/05/26 13:56:08 nicm Exp $	*/
d553 1
a553 1
	session_pickup(s, NULL);
@


1.26
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d553 1
a553 1
	session_pickup(s);
@


1.25
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.24 2010/05/19 20:57:10 gilles Exp $	*/
d553 1
a553 1
	session_pickup(s, NULL);
@


1.24
log
@cleanup-only commit, removes unrequired includes, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.23 2009/11/11 15:36:10 jacekm Exp $	*/
d55 1
a55 1
int	 ssl_buf_read(SSL *, struct buf_read *);
d154 2
a155 2
	char			 rbuf[READ_BUF_SIZE];
	int			 howmuch = READ_BUF_SIZE;
d656 1
a656 1
ssl_buf_read(SSL *s, struct buf_read *r)
d676 1
a676 1
	struct buf	*buf;
@


1.23
log
@Check if the receive buffer has any unused space before reading from socket in
buf_read (and in ssl_buf_read).
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.22 2009/10/03 07:59:55 jacekm Exp $	*/
a25 1
#include <sys/time.h>
@


1.22
log
@dont dereference garbage pointer, from martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.21 2009/09/22 08:23:09 jj Exp $	*/
d659 2
d663 4
a666 1
	ret = SSL_read(s, r->buf + r->wpos, sizeof(r->buf) - r->wpos);
d668 1
a668 1
	if (ret > 0)
@


1.21
log
@fix handling of certificates to unbreak DSA; allows starttls(8) instructions to work with smtpd; ok jacekm@@, on behalf of gilles@@ who doesnt have access to a safe machine
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.20 2009/09/15 16:50:06 jacekm Exp $	*/
d601 1
a601 1
	SSL		*ssl;
@


1.20
log
@Extend SMTP client_* API to support SSL+AUTH, and use it in the mta
process to relay mails.  ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.19 2009/06/02 22:23:36 gilles Exp $	*/
d43 1
a43 1
#define SSL_CIPHERS	"HIGH:!ADH"
d59 3
d65 25
d468 2
d685 27
@


1.19
log
@make env->sc_listeners and env->sc_ssl pointers, one step further toward
configuration reloading without killing active sessions; ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.18 2009/06/01 18:02:41 jacekm Exp $	*/
d53 5
a57 1
void	 ssl_client_init(struct session *);
d567 2
a568 2
void
ssl_client_init(struct session *s)
d571 2
a572 2
	struct ssl	 key;
	struct ssl	*ssl;
a573 1
	log_debug("ssl_client_init: preparing SSL");
d576 5
a580 16
	if (s->batch->rule.r_value.relayhost.cert[0] != '\0') {
		if (strlcpy(key.ssl_name,
			s->batch->rule.r_value.relayhost.cert,
			sizeof(key.ssl_name)) >= sizeof(key.ssl_name))
			log_warnx("warning: certificate name too long: %s",
			    s->batch->rule.r_value.relayhost.cert);
		else if ((ssl = SPLAY_FIND(ssltree, s->s_env->sc_ssl,
			    &key)) == NULL)
			log_warnx("warning: failed to find client "
			    "certificate: %s", key.ssl_name);
		else if (!ssl_ctx_use_certificate_chain(ctx, ssl->ssl_cert,
			ssl->ssl_cert_len))
			ssl_error("ssl_client_init");
		else if (!ssl_ctx_use_private_key(ctx, ssl->ssl_key,
			ssl->ssl_key_len))
			ssl_error("ssl_client_init");
d582 1
a582 1
			ssl_error("ssl_client_init");
d585 2
a586 3
	s->s_ssl = SSL_new(ctx);
	if (s->s_ssl == NULL)
		goto err;
d588 16
a603 17
	if (!SSL_set_ssl_method(s->s_ssl, SSLv23_client_method()))
		goto err;
	if (!SSL_set_fd(s->s_ssl, s->s_fd))
		goto err;
	SSL_set_connect_state(s->s_ssl);

	s->s_tv.tv_sec = SMTPD_SESSION_TIMEOUT;
	s->s_tv.tv_usec = 0;

	event_set(&s->s_ev, s->s_fd, EV_WRITE|EV_TIMEOUT, ssl_connect, s);
	event_add(&s->s_ev, &s->s_tv);
	return;

 err:
	if (s->s_ssl != NULL)
		SSL_free(s->s_ssl);
	ssl_error("ssl_client_init");
d624 31
@


1.18
log
@fix function name in log_debug
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.17 2009/05/30 23:53:41 gilles Exp $	*/
d352 1
a352 1
	s = SPLAY_FIND(ssltree, &env->sc_ssl, &key);
d388 1
a388 1
	SPLAY_INSERT(ssltree, &env->sc_ssl, s);
d418 1
a418 1
	if ((l->ssl = SPLAY_FIND(ssltree, &env->sc_ssl, &key)) == NULL)
d579 1
a579 1
		else if ((ssl = SPLAY_FIND(ssltree, &s->s_env->sc_ssl,
@


1.17
log
@It is now possible to specify a certificate to use when relaying to another
host which requests client certificates:

	accept [...] relay via [...] ssl certificate "mycert"

diff from Josh Elsasser <josh@@elsasser.org>, tested and okayed by me with
no change but the addition of status 554 to the state machine to deal with
remote host telling us it doesn't like our certificate.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.16 2009/05/24 14:22:24 jacekm Exp $	*/
d67 1
a67 1
		log_debug("ssl_session_accept: session timed out");
@


1.16
log
@Instead of keeping stats private to each process, and querying every
process individually whenever stats need to be fetched, keep stats
in MAP_ANON shared memory allocated by parent.

This means control has direct access to stats and can respond very
quickly without troubling any other daemon processes.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.15 2009/05/19 22:41:35 gilles Exp $	*/
d340 1
a340 1
ssl_load_certfile(struct smtpd *env, const char *name)
d353 2
a354 1
	if (s != NULL)
d356 1
d361 1
d567 2
d572 20
@


1.15
log
@remove useless check on NULL ssl cert and key, the check cannot be reached
as we would exit earlier if either one is NULL.

diff by giovanni <qgiovanni@@gmail.com>, had been sitting in my mbox for a
while, okayed by jacek and I
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.14 2009/05/18 20:23:35 jacekm Exp $	*/
a57 2
extern struct s_session	s_smtp;

d506 2
a507 2
		s_smtp.smtps++;
		s_smtp.smtps_active++;
d510 2
a511 2
		s_smtp.starttls++;
		s_smtp.starttls_active++;
d603 1
a603 1
			s_smtp.smtps_active--;
d607 1
a607 1
			s_smtp.starttls_active--;
@


1.14
log
@Complete rework of bufferevent event masking allowing for  more
strictness:
- Drop clients attempting command pipelining; protects the daemon
from all kinds of abuse.
- Replace F_EVLOCKED flag with F_WRITEONLY which has cleaner sematics:
when up, session must not be destroyed nor read from, but may be
written to.
- Write callback becomes a central place for enabling EV_READ.
- Delay bufferevent creation until after ssl handshake is completed.

A bunch of session error stats were added to smtpctl's "show stats".
These could help spotting event masking errors in the future.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.13 2009/04/15 20:34:59 jacekm Exp $	*/
a385 3

	if (s->ssl_cert == NULL || s->ssl_key == NULL)
		fatal("invalid certificates");
@


1.13
log
@s/ssmtp/smtps/; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.12 2009/04/09 19:49:34 jacekm Exp $	*/
a505 2
	event_set(&s->s_bev->ev_read, s->s_fd, EV_READ, ssl_read, s->s_bev);
	event_set(&s->s_bev->ev_write, s->s_fd, EV_WRITE, ssl_write, s->s_bev);
d519 3
d523 1
@


1.12
log
@change syntax of the "listen on" and "relay via" directives:
1) kill the ssmtp keyword in "ssmtp listen on ...";
2) kill the use keyword in "... use certificate foo";
3) tls no longer implicit, user must explicitely use the tls or smtps option.
4) for "relay via", move the tls/smtps options to right after the
port specification; makes it similar to "listen on".

These directives:

  ssmtp listen on fxp0 use ceritifate "foo"
  accept for all relay via tls "mx.bar.com"

now become:

  listen on fxp0 smtps certificate "foo"
  accept for all relay via "mx.bar.com" tls

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.11 2009/03/15 19:32:11 gilles Exp $	*/
d513 2
a514 2
		s_smtp.ssmtp++;
		s_smtp.ssmtp_active++;
d606 1
a606 1
			s_smtp.ssmtp_active--;
@


1.11
log
@since we are going to share code in smtp sessions and mta sessions, we need
to also share the statistics structure, still being worked on
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.10 2009/02/05 21:25:19 gilles Exp $	*/
d512 1
a512 1
	if (s->s_l->flags & F_SSMTP) {
d604 1
a604 1
	if (s->s_l->flags & F_SSMTP) {
@


1.10
log
@when calling ssl_session_destroy() from mta, our session will have a NULL
s->s_l field. this commit fixes a crash in mta caused by a NULL deref.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.9 2009/01/30 21:52:55 gilles Exp $	*/
d58 1
a58 1
extern struct s_smtp	s_smtp;
@


1.9
log
@when decreasing ssl related counters, make sure the session was flagged as
F_SECURE. while at it, add "smtp.sessions.aborted" which keeps track of
sessions which were interrupted before completion.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.8 2009/01/30 21:40:21 gilles Exp $	*/
d597 7
a611 1
	SSL_free(s->s_ssl);
@


1.8
log
@improve statistics for smtp process. not only collect the current sessions
count, but also the total sessions count, ssmtp sessions (both current and
total) and starttls sessions (both current and total)

# ./smtpctl/smtpctl show stats|grep smtp.sessions
smtp.sessions = 0
smtp.sessions.active = 0
smtp.sessions.ssmtp = 0
smtp.sessions.ssmtp.active = 0
smtp.sessions.starttls = 0
smtp.sessions.starttls.active = 0
#
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.7 2009/01/29 14:25:55 gilles Exp $	*/
d598 2
a599 1
		s_smtp.ssmtp_active--;
d602 2
a603 1
		s_smtp.starttls_active--;
@


1.7
log
@initial starttls support in mta, this allows:

	accept for domain "openbsd.org" relay via tls "mx.example.org"

to ensure the relaying of mail for whoever@@openbsd.org will happen through
a secure tls (STARTTLS) session. failure to establish a tls session will be
considered as a permanent failure. As a side effect:

	accept for domain "openbsd.org" relay via ssl "mx.example.org"

can now work as well and ensure that the relaying happens through ssmtp OR
tls, but never through an unsafe channel. no need to specify a port, they
are automatically detected if not specified.

still a work in progress, don't expect that it will work flawlessly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.6 2009/01/29 13:00:12 gilles Exp $	*/
d58 2
d511 10
d597 6
@


1.6
log
@bring initial support for SSL in the mta part of smtpd, allowing for:

	accept for domain "openbsd.org" relay via ssmtp "mx1.example.org"

to ensure that deliveries for whatever@@openbsd.org goes through an SSL session
to mx1.example.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.5 2009/01/01 16:15:47 jacekm Exp $	*/
d102 1
a102 1
	bufferevent_enable(s->s_bev, EV_READ);
d104 5
@


1.5
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.4 2008/12/11 23:01:16 gilles Exp $	*/
d52 2
d59 51
d544 31
@


1.4
log
@- snprintf -> bsnprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.3 2008/11/10 00:57:35 gilles Exp $	*/
a31 1
#include <signal.h>
@


1.3
log
@- snprintf() can return -1, make sure every call is checked properly
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
a287 1
	int spret;
d304 2
a305 3
	spret = snprintf(certfile, sizeof(certfile),
	    "/etc/mail/certs/%s.crt", name);
	if (spret == -1 || spret >= (int)sizeof(certfile)) {
d315 2
a316 3
	spret = snprintf(certfile, sizeof(certfile),
	    "/etc/mail/certs/%s.key", name);
	if (spret == -1 || spret >= (int)sizeof(certfile)) {
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d288 1
d305 3
a307 2
	if (snprintf(certfile, sizeof(certfile),
	    "/etc/mail/certs/%s.crt", name) == -1) {
d317 3
a319 2
	if (snprintf(certfile, sizeof(certfile),
	    "/etc/mail/certs/%s.key", name) == -1) {
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

