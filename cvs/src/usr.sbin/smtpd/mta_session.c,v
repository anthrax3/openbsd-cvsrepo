head	1.98;
access;
symbols
	OPENBSD_6_2:1.98.0.2
	OPENBSD_6_2_BASE:1.98
	OPENBSD_6_1:1.96.0.4
	OPENBSD_6_1_BASE:1.96
	OPENBSD_6_0:1.83.0.4
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.82.0.2
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.71.0.6
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.57.0.2
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.98
date	2017.05.24.21.27.32;	author gilles;	state Exp;
branches;
next	1.97;
commitid	scexdPny8vd1lHwG;

1.97
date	2017.05.17.14.00.06;	author deraadt;	state Exp;
branches;
next	1.96;
commitid	CQ2bJKe5Leh53ur4;

1.96
date	2016.11.30.17.43.32;	author eric;	state Exp;
branches;
next	1.95;
commitid	12DZR8Z2gR4qMwKF;

1.95
date	2016.11.30.11.52.48;	author eric;	state Exp;
branches;
next	1.94;
commitid	HLHuvF4EZizEJJ0M;

1.94
date	2016.11.25.11.43.55;	author eric;	state Exp;
branches;
next	1.93;
commitid	HocCPBFZyEvojduO;

1.93
date	2016.11.24.20.52.13;	author eric;	state Exp;
branches;
next	1.92;
commitid	UvPJmlWnlqtYXKpn;

1.92
date	2016.11.24.20.44.04;	author eric;	state Exp;
branches;
next	1.91;
commitid	NUNgQusDh5a3bpBi;

1.91
date	2016.11.24.12.58.27;	author eric;	state Exp;
branches;
next	1.90;
commitid	5gZmKKc6mC73nyDO;

1.90
date	2016.11.24.07.57.48;	author eric;	state Exp;
branches;
next	1.89;
commitid	PtnknknQfwIKwJ99;

1.89
date	2016.11.22.07.28.42;	author eric;	state Exp;
branches;
next	1.88;
commitid	8fz9wejpFY08v5WO;

1.88
date	2016.11.21.13.00.43;	author eric;	state Exp;
branches;
next	1.87;
commitid	pP1uMFU0IrsBTn27;

1.87
date	2016.11.20.08.43.36;	author eric;	state Exp;
branches;
next	1.86;
commitid	WsInk7NbLdaIQWny;

1.86
date	2016.11.18.09.35.27;	author eric;	state Exp;
branches;
next	1.85;
commitid	X2dTPBb8osr05H74;

1.85
date	2016.11.17.07.33.06;	author eric;	state Exp;
branches;
next	1.84;
commitid	6eHngXNIBgMGOO6G;

1.84
date	2016.11.16.21.30.37;	author eric;	state Exp;
branches;
next	1.83;
commitid	3uoi1oHbQkJMXEjt;

1.83
date	2016.05.22.16.31.21;	author gilles;	state Exp;
branches;
next	1.82;
commitid	JDbBqpKvf906qrdL;

1.82
date	2015.12.12.20.02.31;	author gilles;	state Exp;
branches;
next	1.81;
commitid	eO2zB2XyKCWqQLmz;

1.81
date	2015.12.12.17.16.56;	author gilles;	state Exp;
branches;
next	1.80;
commitid	O1qQ3TEBrjXRGaeN;

1.80
date	2015.12.12.08.43.42;	author gilles;	state Exp;
branches;
next	1.79;
commitid	vEOelDzWVrCtDw7l;

1.79
date	2015.12.12.08.40.40;	author gilles;	state Exp;
branches;
next	1.78;
commitid	J6tB3iI3lG6lq7WK;

1.78
date	2015.12.11.21.44.01;	author gilles;	state Exp;
branches;
next	1.77;
commitid	4sl0Vm3vIoWoEZs0;

1.77
date	2015.12.05.21.27.42;	author mmcc;	state Exp;
branches;
next	1.76;
commitid	u7cKDttUUhTVcGIY;

1.76
date	2015.12.01.15.30.42;	author gilles;	state Exp;
branches;
next	1.75;
commitid	EIjpdRI21FrFfOcY;

1.75
date	2015.11.30.12.49.35;	author gilles;	state Exp;
branches;
next	1.74;
commitid	ZyOzw2IPUjoaWKi5;

1.74
date	2015.10.14.22.01.43;	author gilles;	state Exp;
branches;
next	1.73;
commitid	XSq2zfqNj1sXRZRl;

1.73
date	2015.10.09.16.47.14;	author sunil;	state Exp;
branches;
next	1.72;
commitid	ZXRvzAX5RQdBpFRL;

1.72
date	2015.10.02.00.44.30;	author gilles;	state Exp;
branches;
next	1.71;
commitid	ycD3KILo1e7vHFre;

1.71
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches
	1.71.2.1
	1.71.6.1;
next	1.70;
commitid	ZBTFreARDSMmzOIV;

1.70
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	Uu5nFG3wCl0LACBb;

1.69
date	2014.12.24.13.51.31;	author eric;	state Exp;
branches;
next	1.68;
commitid	hxnMsgzQw5aKfNFY;

1.68
date	2014.07.04.15.24.46;	author eric;	state Exp;
branches
	1.68.4.1;
next	1.67;
commitid	yoEZ5EbIFWOyYrCf;

1.67
date	2014.07.04.13.25.00;	author eric;	state Exp;
branches;
next	1.66;
commitid	cwTVd4xPwzo710sw;

1.66
date	2014.05.20.18.47.01;	author eric;	state Exp;
branches;
next	1.65;

1.65
date	2014.05.12.14.37.32;	author eric;	state Exp;
branches;
next	1.64;

1.64
date	2014.04.30.12.49.54;	author gilles;	state Exp;
branches;
next	1.63;

1.63
date	2014.04.29.19.13.13;	author reyk;	state Exp;
branches;
next	1.62;

1.62
date	2014.04.29.17.32.42;	author gilles;	state Exp;
branches;
next	1.61;

1.61
date	2014.04.29.10.18.06;	author reyk;	state Exp;
branches;
next	1.60;

1.60
date	2014.04.19.13.35.51;	author gilles;	state Exp;
branches;
next	1.59;

1.59
date	2014.04.08.12.44.57;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.57;

1.57
date	2014.03.02.21.19.36;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2014.02.25.15.58.45;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2014.02.24.18.06.12;	author eric;	state Exp;
branches;
next	1.54;

1.54
date	2014.02.04.15.44.05;	author eric;	state Exp;
branches;
next	1.53;

1.53
date	2014.02.04.14.56.03;	author eric;	state Exp;
branches;
next	1.52;

1.52
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.51;

1.51
date	2014.02.04.09.50.31;	author eric;	state Exp;
branches;
next	1.50;

1.50
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.49;

1.49
date	2013.12.03.09.06.26;	author eric;	state Exp;
branches;
next	1.48;

1.48
date	2013.11.28.10.43.37;	author eric;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.18.12.24.26;	author eric;	state Exp;
branches;
next	1.46;

1.46
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.45;

1.45
date	2013.10.29.17.04.45;	author eric;	state Exp;
branches;
next	1.44;

1.44
date	2013.10.28.17.02.08;	author eric;	state Exp;
branches;
next	1.43;

1.43
date	2013.10.27.20.39.44;	author eric;	state Exp;
branches;
next	1.42;

1.42
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.41;

1.41
date	2013.10.25.14.21.06;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2013.07.22.13.11.11;	author eric;	state Exp;
branches;
next	1.39;

1.39
date	2013.07.19.21.14.52;	author eric;	state Exp;
branches;
next	1.38;

1.38
date	2013.07.19.07.37.29;	author eric;	state Exp;
branches;
next	1.37;

1.37
date	2013.06.03.16.04.03;	author eric;	state Exp;
branches;
next	1.36;

1.36
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.35;

1.35
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.34;

1.34
date	2013.02.21.16.25.21;	author eric;	state Exp;
branches;
next	1.33;

1.33
date	2013.02.15.22.43.21;	author eric;	state Exp;
branches;
next	1.32;

1.32
date	2013.02.05.10.53.57;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.30;

1.30
date	2013.01.28.16.40.22;	author eric;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.28.11.58.57;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.28.11.09.53;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2012.11.06.09.25.37;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.11.21.24.51;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2012.10.10.19.38.04;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2012.10.07.15.46.38;	author chl;	state Exp;
branches;
next	1.21;

1.21
date	2012.10.03.16.43.19;	author chl;	state Exp;
branches;
next	1.20;

1.20
date	2012.10.02.12.37.38;	author chl;	state Exp;
branches;
next	1.19;

1.19
date	2012.09.30.17.25.09;	author chl;	state Exp;
branches;
next	1.18;

1.18
date	2012.09.27.19.43.29;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2012.09.21.12.33.32;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2012.09.11.16.24.28;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2012.09.11.15.05.49;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2012.08.30.18.16.25;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2012.08.21.20.19.46;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2012.08.21.20.07.07;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2012.08.21.13.13.17;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2012.08.18.20.52.36;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.18.15.45.12;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.10.11.05.55;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.09.09.48.02;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.07.29.20.16.02;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.29.13.56.24;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.15.17.36.42;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.01.10.46.32;	author chl;	state Exp;
branches;
next	1.2;

1.2
date	2012.05.12.17.41.27;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.05.11.12.12.02;	author eric;	state Exp;
branches;
next	;

1.68.4.1
date	2015.10.02.01.33.33;	author gilles;	state Exp;
branches;
next	;
commitid	2Q56YgF5PzqMcagu;

1.71.2.1
date	2015.10.02.01.28.43;	author gilles;	state Exp;
branches;
next	;
commitid	pAamrt3DJscJjb10;

1.71.6.1
date	2015.10.02.00.55.02;	author gilles;	state Exp;
branches;
next	;
commitid	5SntIHNUPMG4dcQ1;


desc
@@


1.98
log
@Fix a possible fatal() when smtpd is configured to *force* relaying over
SMTPS, that the connection succeeds, but that something causes a failure
in the TLS code path afterwards. Session gets downgraded so it can use a
plaintext connector but since it's not allowed to do so, it fatal()-s.
This didn't impact STARTTLS, only SMTPS.

Issue experienced a few times by stsp@@ triggered by a suspend.
ok eric@@
@
text
@/*	$OpenBSD: mta_session.c,v 1.97 2017/05/17 14:00:06 deraadt Exp $	*/

/*
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <inttypes.h>
#include <netdb.h>
#include <openssl/ssl.h>
#include <pwd.h>
#include <resolv.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"
#include "ssl.h"

#define MAX_TRYBEFOREDISABLE	10

#define MTA_HIWAT		65535

enum mta_state {
	MTA_INIT,
	MTA_BANNER,
	MTA_EHLO,
	MTA_HELO,
	MTA_LHLO,
	MTA_STARTTLS,
	MTA_AUTH,
	MTA_AUTH_PLAIN,
	MTA_AUTH_LOGIN,
	MTA_AUTH_LOGIN_USER,
	MTA_AUTH_LOGIN_PASS,
	MTA_READY,
	MTA_MAIL,
	MTA_RCPT,
	MTA_DATA,
	MTA_BODY,
	MTA_EOM,
	MTA_LMTP_EOM,
	MTA_RSET,
	MTA_QUIT,
};

#define MTA_FORCE_ANYSSL	0x0001
#define MTA_FORCE_SMTPS		0x0002
#define MTA_FORCE_TLS     	0x0004
#define MTA_FORCE_PLAIN		0x0008
#define MTA_WANT_SECURE		0x0010
#define MTA_USE_AUTH		0x0020
#define MTA_USE_CERT		0x0040
#define MTA_DOWNGRADE_PLAIN    	0x0080

#define MTA_TLS_TRIED		0x0080

#define MTA_TLS			0x0100
#define MTA_VERIFIED   		0x0200

#define MTA_FREE		0x0400
#define MTA_LMTP		0x0800
#define MTA_WAIT		0x1000
#define MTA_HANGON		0x2000
#define MTA_RECONN		0x4000

#define MTA_EXT_STARTTLS	0x01
#define MTA_EXT_PIPELINING	0x02
#define MTA_EXT_AUTH		0x04
#define MTA_EXT_AUTH_PLAIN     	0x08
#define MTA_EXT_AUTH_LOGIN     	0x10

struct mta_session {
	uint64_t		 id;
	struct mta_relay	*relay;
	struct mta_route	*route;
	char			*helo;

	int			 flags;

	int			 attempt;
	int			 use_smtps;
	int			 use_starttls;
	int			 use_smtp_tls;
	int			 ready;

	struct event		 ev;
	struct io		*io;
	int			 ext;

	size_t			 msgtried;
	size_t			 msgcount;
	size_t			 rcptcount;
	int			 hangon;

	enum mta_state		 state;
	struct mta_task		*task;
	struct mta_envelope	*currevp;
	FILE			*datafp;

	size_t			 failures;

	char			 replybuf[2048];
};

static void mta_session_init(void);
static void mta_start(int fd, short ev, void *arg);
static void mta_io(struct io *, int, void *);
static void mta_free(struct mta_session *);
static void mta_on_ptr(void *, void *, void *);
static void mta_on_timeout(struct runq *, void *);
static void mta_connect(struct mta_session *);
static void mta_enter_state(struct mta_session *, int);
static void mta_flush_task(struct mta_session *, int, const char *, size_t, int);
static void mta_error(struct mta_session *, const char *, ...);
static void mta_send(struct mta_session *, char *, ...);
static ssize_t mta_queue_data(struct mta_session *);
static void mta_response(struct mta_session *, char *);
static const char * mta_strstate(int);
static void mta_start_tls(struct mta_session *);
static int mta_verify_certificate(struct mta_session *);
static void mta_tls_verified(struct mta_session *);
static struct mta_session *mta_tree_pop(struct tree *, uint64_t);
static const char * dsn_strret(enum dsn_ret);
static const char * dsn_strnotify(uint8_t);

void mta_hoststat_update(const char *, const char *);
void mta_hoststat_reschedule(const char *);
void mta_hoststat_cache(const char *, uint64_t);
void mta_hoststat_uncache(const char *, uint64_t);

static struct tree wait_helo;
static struct tree wait_ptr;
static struct tree wait_fd;
static struct tree wait_ssl_init;
static struct tree wait_ssl_verify;

static struct runq *hangon;

static void
mta_session_init(void)
{
	static int init = 0;

	if (!init) {
		tree_init(&wait_helo);
		tree_init(&wait_ptr);
		tree_init(&wait_fd);
		tree_init(&wait_ssl_init);
		tree_init(&wait_ssl_verify);
		runq_init(&hangon, mta_on_timeout);
		init = 1;
	}
}

void
mta_session(struct mta_relay *relay, struct mta_route *route)
{
	struct mta_session	*s;
	struct timeval		 tv;

	mta_session_init();

	s = xcalloc(1, sizeof *s, "mta_session");
	s->id = generate_uid();
	s->relay = relay;
	s->route = route;

	if (relay->flags & RELAY_SSL && relay->flags & RELAY_AUTH)
		s->flags |= MTA_USE_AUTH;
	if (relay->pki_name)
		s->flags |= MTA_USE_CERT;
	if (relay->flags & RELAY_LMTP)
		s->flags |= MTA_LMTP;
	switch (relay->flags & (RELAY_SSL|RELAY_TLS_OPTIONAL)) {
		case RELAY_SSL:
			s->flags |= MTA_FORCE_ANYSSL;
			s->flags |= MTA_WANT_SECURE;
			break;
		case RELAY_SMTPS:
			s->flags |= MTA_FORCE_SMTPS;
			s->flags |= MTA_WANT_SECURE;
			break;
		case RELAY_STARTTLS:
			s->flags |= MTA_FORCE_TLS;
			s->flags |= MTA_WANT_SECURE;
			break;
		case RELAY_TLS_OPTIONAL:
			/* do not force anything, try tls then smtp */
			break;
		default:
			s->flags |= MTA_FORCE_PLAIN;
	}

	if (relay->flags & RELAY_BACKUP)
		s->flags &= ~MTA_FORCE_PLAIN;

	log_debug("debug: mta: %p: spawned for relay %s", s,
	    mta_relay_to_text(relay));
	stat_increment("mta.session", 1);

	if (route->dst->ptrname || route->dst->lastptrquery) {
		/* We want to delay the connection since to always notify
		 * the relay asynchronously.
		 */
		tv.tv_sec = 0;
		tv.tv_usec = 0;
		evtimer_set(&s->ev, mta_start, s);
		evtimer_add(&s->ev, &tv);
	} else if (waitq_wait(&route->dst->ptrname, mta_on_ptr, s)) {
		m_create(p_lka,  IMSG_MTA_DNS_PTR, 0, 0, -1);
		m_add_id(p_lka, s->id);
		m_add_sockaddr(p_lka, s->route->dst->sa);
		m_close(p_lka);
		tree_xset(&wait_ptr, s->id, s);
		s->flags |= MTA_WAIT;
	}
}

void
mta_session_imsg(struct mproc *p, struct imsg *imsg)
{
	struct ca_vrfy_resp_msg	*resp_ca_vrfy;
	struct ca_cert_resp_msg	*resp_ca_cert;
	struct mta_session	*s;
	struct mta_host		*h;
	struct msg		 m;
	uint64_t		 reqid;
	const char		*name;
	void			*ssl;
	int			 dnserror, status;

	switch (imsg->hdr.type) {

	case IMSG_MTA_OPEN_MESSAGE:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_end(&m);

		s = mta_tree_pop(&wait_fd, reqid);
		if (s == NULL) {
			if (imsg->fd != -1)
				close(imsg->fd);
			return;
		}

		if (imsg->fd == -1) {
			log_debug("debug: mta: failed to obtain msg fd");
			mta_flush_task(s, IMSG_MTA_DELIVERY_TEMPFAIL,
			    "Could not get message fd", 0, 0);
			mta_enter_state(s, MTA_READY);
			return;
		}

		s->datafp = fdopen(imsg->fd, "r");
		if (s->datafp == NULL)
			fatal("mta: fdopen");

		mta_enter_state(s, MTA_MAIL);
		return;

	case IMSG_MTA_DNS_PTR:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &dnserror);
		if (dnserror)
			name = NULL;
		else
			m_get_string(&m, &name);
		m_end(&m);
		s = mta_tree_pop(&wait_ptr, reqid);
		if (s == NULL)
			return;

		h = s->route->dst;
		h->lastptrquery = time(NULL);
		if (name)
			h->ptrname = xstrdup(name, "mta: ptr");
		waitq_run(&h->ptrname, h->ptrname);
		return;

	case IMSG_MTA_TLS_INIT:
		resp_ca_cert = imsg->data;
		s = mta_tree_pop(&wait_ssl_init, resp_ca_cert->reqid);
		if (s == NULL)
			return;

		if (resp_ca_cert->status == CA_FAIL) {
			if (s->relay->pki_name) {
				log_info("%016"PRIx64" mta "
				    "event=closing reason=ca-failure",
				    s->id);
				mta_free(s);
				return;
			}
			else {
				ssl = ssl_mta_init(NULL, NULL, 0, env->sc_tls_ciphers);
				if (ssl == NULL)
					fatal("mta: ssl_mta_init");
				io_start_tls(s->io, ssl);
				return;
			}
		}

		resp_ca_cert = xmemdup(imsg->data, sizeof *resp_ca_cert, "mta:ca_cert");
		resp_ca_cert->cert = xstrdup((char *)imsg->data +
		    sizeof *resp_ca_cert, "mta:ca_cert");
		ssl = ssl_mta_init(resp_ca_cert->name,
		    resp_ca_cert->cert, resp_ca_cert->cert_len, env->sc_tls_ciphers);
		if (ssl == NULL)
			fatal("mta: ssl_mta_init");
		io_start_tls(s->io, ssl);

		freezero(resp_ca_cert->cert, resp_ca_cert->cert_len);
		free(resp_ca_cert);
		return;

	case IMSG_MTA_TLS_VERIFY:
		resp_ca_vrfy = imsg->data;
		s = mta_tree_pop(&wait_ssl_verify, resp_ca_vrfy->reqid);
		if (s == NULL)
			return;

		if (resp_ca_vrfy->status == CA_OK)
			s->flags |= MTA_VERIFIED;
		else if (s->relay->flags & F_TLS_VERIFY) {
			errno = 0;
			mta_error(s, "SSL certificate check failed");
			mta_free(s);
			return;
		}

		mta_tls_verified(s);
		io_resume(s->io, IO_IN);
		return;

	case IMSG_MTA_LOOKUP_HELO:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &status);
		if (status == LKA_OK)
			m_get_string(&m, &name);
		m_end(&m);

		s = mta_tree_pop(&wait_helo, reqid);
		if (s == NULL)
			return;

		if (status == LKA_OK) {
			s->helo = xstrdup(name, "mta_session_imsg");
			mta_connect(s);
		} else {
			mta_source_error(s->relay, s->route,
			    "Failed to retrieve helo string");
			mta_free(s);
		}
		return;

	default:
		errx(1, "mta_session_imsg: unexpected %s imsg",
		    imsg_to_str(imsg->hdr.type));
	}
}

static struct mta_session *
mta_tree_pop(struct tree *wait, uint64_t reqid)
{
	struct mta_session *s;

	s = tree_xpop(wait, reqid);
	if (s->flags & MTA_FREE) {
		log_debug("debug: mta: %p: zombie session", s);
		mta_free(s);
		return (NULL);
	}
	s->flags &= ~MTA_WAIT;

	return (s);
}

static void
mta_free(struct mta_session *s)
{
	struct mta_relay *relay;
	struct mta_route *route;

	log_debug("debug: mta: %p: session done", s);

	if (s->ready)
		s->relay->nconn_ready -= 1;

	if (s->flags & MTA_HANGON) {
		log_debug("debug: mta: %p: cancelling hangon timer", s);
		runq_cancel(hangon, NULL, s);
	}

	if (s->io)
		io_free(s->io);

	if (s->task)
		fatalx("current task should have been deleted already");
	if (s->datafp)
		fclose(s->datafp);
	free(s->helo);

	relay = s->relay;
	route = s->route;
	free(s);
	stat_decrement("mta.session", 1);
	mta_route_collect(relay, route);
}

static void
mta_on_timeout(struct runq *runq, void *arg)
{
	struct mta_session *s = arg;

	log_debug("mta: timeout for session hangon");

	s->flags &= ~MTA_HANGON;
	s->hangon++;

	mta_enter_state(s, MTA_READY);
}

static void
mta_on_ptr(void *tag, void *arg, void *data)
{
	struct mta_session *s = arg;

	mta_connect(s);
}

static void
mta_start(int fd, short ev, void *arg)
{
	struct mta_session *s = arg;

	mta_connect(s);
}

static void
mta_connect(struct mta_session *s)
{
	struct sockaddr_storage	 ss;
	struct sockaddr		*sa;
	int			 portno;
	const char		*schema = "smtp+tls://";

	if (s->helo == NULL) {
		if (s->relay->helotable && s->route->src->sa) {
			m_create(p_lka, IMSG_MTA_LOOKUP_HELO, 0, 0, -1);
			m_add_id(p_lka, s->id);
			m_add_string(p_lka, s->relay->helotable);
			m_add_sockaddr(p_lka, s->route->src->sa);
			m_close(p_lka);
			tree_xset(&wait_helo, s->id, s);
			s->flags |= MTA_WAIT;
			return;
		}
		else if (s->relay->heloname)
			s->helo = xstrdup(s->relay->heloname, "mta_connect");
		else
			s->helo = xstrdup(env->sc_hostname, "mta_connect");
	}

	if (s->io) {
		io_free(s->io);
		s->io = NULL;
	}

	s->use_smtps = s->use_starttls = s->use_smtp_tls = 0;

	switch (s->attempt) {
	case 0:
		if (s->flags & MTA_FORCE_SMTPS)
			s->use_smtps = 1;	/* smtps */
		else if (s->flags & (MTA_FORCE_TLS|MTA_FORCE_ANYSSL))
			s->use_starttls = 1;	/* tls, tls+smtps */
		else if (!(s->flags & MTA_FORCE_PLAIN))
			s->use_smtp_tls = 1;
		break;
	case 1:
		if (s->flags & MTA_FORCE_ANYSSL) {
			s->use_smtps = 1;	/* tls+smtps */
			break;
		}
		else if (s->flags & MTA_DOWNGRADE_PLAIN) {
			/* smtp+tls, with tls failure */
			break;
		}
	default:
		mta_free(s);
		return;
	}
	portno = s->use_smtps ? 465 : 25;

	/* Override with relay-specified port */
	if (s->relay->port)
		portno = s->relay->port;

	memmove(&ss, s->route->dst->sa, s->route->dst->sa->sa_len);
	sa = (struct sockaddr *)&ss;

	if (sa->sa_family == AF_INET)
		((struct sockaddr_in *)sa)->sin_port = htons(portno);
	else if (sa->sa_family == AF_INET6)
		((struct sockaddr_in6 *)sa)->sin6_port = htons(portno);

	s->attempt += 1;
	if (s->use_smtp_tls)
		schema = "smtp+tls://";
	else if (s->use_starttls)
		schema = "tls://";
	else if (s->use_smtps)
		schema = "smtps://";
	else if (s->flags & MTA_LMTP)
		schema = "lmtp://";
	else
		schema = "smtp://";

	log_info("%016"PRIx64" mta "
	    "event=connecting address=%s%s:%d host=%s",
	    s->id, schema, sa_to_text(s->route->dst->sa),
	    portno, s->route->dst->ptrname);

	mta_enter_state(s, MTA_INIT);
	s->io = io_new();
	io_set_callback(s->io, mta_io, s);
	io_set_timeout(s->io, 300000);
	if (io_connect(s->io, sa, s->route->src->sa) == -1) {
		/*
		 * This error is most likely a "no route",
		 * so there is no need to try again.
		 */
		log_debug("debug: mta: io_connect failed: %s", io_error(s->io));
		if (errno == EADDRNOTAVAIL)
			mta_source_error(s->relay, s->route, io_error(s->io));
		else
			mta_error(s, "Connection failed: %s", io_error(s->io));
		mta_free(s);
	}
}

static void
mta_enter_state(struct mta_session *s, int newstate)
{
	struct mta_envelope	 *e;
	size_t			 envid_sz;
	int			 oldstate;
	ssize_t			 q;
	char			 ibuf[LINE_MAX];
	char			 obuf[LINE_MAX];
	int			 offset;

    again:
	oldstate = s->state;

	log_trace(TRACE_MTA, "mta: %p: %s -> %s", s,
	    mta_strstate(oldstate),
	    mta_strstate(newstate));

	s->state = newstate;

	memset(s->replybuf, 0, sizeof s->replybuf);

	/* don't try this at home! */
#define mta_enter_state(_s, _st) do { newstate = _st; goto again; } while (0)

	switch (s->state) {
	case MTA_INIT:
	case MTA_BANNER:
		break;

	case MTA_EHLO:
		s->ext = 0;
		mta_send(s, "EHLO %s", s->helo);
		break;

	case MTA_HELO:
		s->ext = 0;
		mta_send(s, "HELO %s", s->helo);
		break;

	case MTA_LHLO:
		s->ext = 0;
		mta_send(s, "LHLO %s", s->helo);
		break;

	case MTA_STARTTLS:
		if (s->flags & MTA_DOWNGRADE_PLAIN)
			mta_enter_state(s, MTA_AUTH);
		if (s->flags & MTA_TLS) /* already started */
			mta_enter_state(s, MTA_AUTH);
		else if ((s->ext & MTA_EXT_STARTTLS) == 0) {
			if (s->flags & MTA_FORCE_TLS || s->flags & MTA_WANT_SECURE) {
				mta_error(s, "TLS required but not supported by remote host");
				s->flags |= MTA_RECONN;
			}
			else
				/* server doesn't support starttls, do not use it */
				mta_enter_state(s, MTA_AUTH);
		}
		else
			mta_send(s, "STARTTLS");
		break;

	case MTA_AUTH:
		if (s->relay->secret && s->flags & MTA_TLS) {
			if (s->ext & MTA_EXT_AUTH) {
				if (s->ext & MTA_EXT_AUTH_PLAIN) {
					mta_enter_state(s, MTA_AUTH_PLAIN);
					break;
				}
				if (s->ext & MTA_EXT_AUTH_LOGIN) {
					mta_enter_state(s, MTA_AUTH_LOGIN);
					break;
				}
				log_debug("debug: mta: %p: no supported AUTH method on session", s);
				mta_error(s, "no supported AUTH method");
			}
			else {
				log_debug("debug: mta: %p: AUTH not advertised on session", s);
				mta_error(s, "AUTH not advertised");
			}
		}
		else if (s->relay->secret) {
			log_debug("debug: mta: %p: not using AUTH on non-TLS "
			    "session", s);
			mta_error(s, "Refuse to AUTH over unsecure channel");
			mta_connect(s);
		} else {
			mta_enter_state(s, MTA_READY);
		}
		break;

	case MTA_AUTH_PLAIN:
		mta_send(s, "AUTH PLAIN %s", s->relay->secret);
		break;

	case MTA_AUTH_LOGIN:
		mta_send(s, "AUTH LOGIN");
		break;

	case MTA_AUTH_LOGIN_USER:
		memset(ibuf, 0, sizeof ibuf);
		if (base64_decode(s->relay->secret, (unsigned char *)ibuf,
				  sizeof(ibuf)-1) == -1) {
			log_debug("debug: mta: %p: credentials too large on session", s);
			mta_error(s, "Credentials too large");
			break;
		}

		memset(obuf, 0, sizeof obuf);
		base64_encode((unsigned char *)ibuf + 1, strlen(ibuf + 1), obuf, sizeof obuf);
		mta_send(s, "%s", obuf);

		memset(ibuf, 0, sizeof ibuf);
		memset(obuf, 0, sizeof obuf);
		break;

	case MTA_AUTH_LOGIN_PASS:
		memset(ibuf, 0, sizeof ibuf);
		if (base64_decode(s->relay->secret, (unsigned char *)ibuf,
				  sizeof(ibuf)-1) == -1) {
			log_debug("debug: mta: %p: credentials too large on session", s);
			mta_error(s, "Credentials too large");
			break;
		}

		offset = strlen(ibuf+1)+2;
		memset(obuf, 0, sizeof obuf);
		base64_encode((unsigned char *)ibuf + offset, strlen(ibuf + offset), obuf, sizeof obuf);
		mta_send(s, "%s", obuf);

		memset(ibuf, 0, sizeof ibuf);
		memset(obuf, 0, sizeof obuf);
		break;

	case MTA_READY:
		/* Ready to send a new mail */
		if (s->ready == 0) {
			s->ready = 1;
			s->relay->nconn_ready += 1;
			mta_route_ok(s->relay, s->route);
		}

		if (s->msgtried >= MAX_TRYBEFOREDISABLE) {
			log_info("%016"PRIx64" mta event=host-rejects-all-mails",
			    s->id);
			mta_route_down(s->relay, s->route);
			mta_enter_state(s, MTA_QUIT);
			break;
		}

		if (s->msgcount >= s->relay->limits->max_mail_per_session) {
			log_debug("debug: mta: "
			    "%p: cannot send more message to relay %s", s,
			    mta_relay_to_text(s->relay));
			mta_enter_state(s, MTA_QUIT);
			break;
		}

		/*
		 * When downgrading from opportunistic TLS, clear flag and
		 * possibly reuse the same task (forbidden in other cases).
		 */
		if (s->flags & MTA_DOWNGRADE_PLAIN)
			s->flags &= ~MTA_DOWNGRADE_PLAIN;
		else if (s->task)
			fatalx("task should be NULL at this point");

		if (s->task == NULL)
			s->task = mta_route_next_task(s->relay, s->route);
		if (s->task == NULL) {
			log_debug("debug: mta: %p: no task for relay %s",
			    s, mta_relay_to_text(s->relay));

			if (s->relay->nconn > 1 ||
			    s->hangon >= s->relay->limits->sessdelay_keepalive) {
				mta_enter_state(s, MTA_QUIT);
				break;
			}

			log_debug("mta: debug: last connection: hanging on for %llds",
			    (long long)(s->relay->limits->sessdelay_keepalive -
			    s->hangon));
			s->flags |= MTA_HANGON;
			runq_schedule(hangon, time(NULL) + 1, NULL, s);
			break;
		}

		log_debug("debug: mta: %p: handling next task for relay %s", s,
			    mta_relay_to_text(s->relay));

		stat_increment("mta.task.running", 1);

		m_create(p_queue, IMSG_MTA_OPEN_MESSAGE, 0, 0, -1);
		m_add_id(p_queue, s->id);
		m_add_msgid(p_queue, s->task->msgid);
		m_close(p_queue);

		tree_xset(&wait_fd, s->id, s);
		s->flags |= MTA_WAIT;
		break;

	case MTA_MAIL:
		s->currevp = TAILQ_FIRST(&s->task->envelopes);

		e = s->currevp;
		s->hangon = 0;
		s->msgtried++;
		envid_sz = strlen(e->dsn_envid);
		if (s->ext & MTA_EXT_DSN) {
			mta_send(s, "MAIL FROM:<%s>%s%s%s%s",
			    s->task->sender,
			    e->dsn_ret ? " RET=" : "",
			    e->dsn_ret ? dsn_strret(e->dsn_ret) : "",
			    envid_sz ? " ENVID=" : "",
			    envid_sz ? e->dsn_envid : "");
		} else
			mta_send(s, "MAIL FROM:<%s>", s->task->sender);
		break;

	case MTA_RCPT:
		if (s->currevp == NULL)
			s->currevp = TAILQ_FIRST(&s->task->envelopes);

		e = s->currevp;
		if (s->ext & MTA_EXT_DSN) {
			mta_send(s, "RCPT TO:<%s>%s%s%s%s",
			    e->dest,
			    e->dsn_notify ? " NOTIFY=" : "",
			    e->dsn_notify ? dsn_strnotify(e->dsn_notify) : "",
			    e->dsn_orcpt ? " ORCPT=" : "",
			    e->dsn_orcpt ? e->dsn_orcpt : "");
		} else
			mta_send(s, "RCPT TO:<%s>", e->dest);

		s->rcptcount++;
		break;

	case MTA_DATA:
		fseek(s->datafp, 0, SEEK_SET);
		mta_send(s, "DATA");
		break;

	case MTA_BODY:
		if (s->datafp == NULL) {
			log_trace(TRACE_MTA, "mta: %p: end-of-file", s);
			mta_enter_state(s, MTA_EOM);
			break;
		}

		if ((q = mta_queue_data(s)) == -1) {
			s->flags |= MTA_FREE;
			break;
		}
		if (q == 0) {
			mta_enter_state(s, MTA_BODY);
			break;
		}

		log_trace(TRACE_MTA, "mta: %p: >>> [...%zd bytes...]", s, q);
		break;

	case MTA_EOM:
		mta_send(s, ".");
		break;

	case MTA_LMTP_EOM:
		/* LMTP reports status of each delivery, so enable read */
		io_set_read(s->io);
		break;

	case MTA_RSET:
		if (s->datafp) {
			fclose(s->datafp);
			s->datafp = NULL;
		}
		mta_send(s, "RSET");
		break;

	case MTA_QUIT:
		mta_send(s, "QUIT");
		break;

	default:
		fatalx("mta_enter_state: unknown state");
	}
#undef mta_enter_state
}

/*
 * Handle a response to an SMTP command
 */
static void
mta_response(struct mta_session *s, char *line)
{
	struct mta_envelope	*e;
	struct sockaddr_storage	 ss;
	struct sockaddr		*sa;
	const char		*domain;
	socklen_t		 sa_len;
	char			 buf[LINE_MAX];
	int			 delivery;

	switch (s->state) {

	case MTA_BANNER:
		if (line[0] != '2') {
			mta_error(s, "BANNER rejected: %s", line);
			s->flags |= MTA_FREE;
			return;
		}
		if (s->flags & MTA_LMTP)
			mta_enter_state(s, MTA_LHLO);
		else
			mta_enter_state(s, MTA_EHLO);
		break;

	case MTA_EHLO:
		if (line[0] != '2') {
			/* rejected at ehlo state */
			if ((s->flags & MTA_USE_AUTH) ||
			    (s->flags & MTA_WANT_SECURE)) {
				mta_error(s, "EHLO rejected: %s", line);
				s->flags |= MTA_FREE;
				return;
			}
			mta_enter_state(s, MTA_HELO);
			return;
		}
		if (!(s->flags & MTA_FORCE_PLAIN))
			mta_enter_state(s, MTA_STARTTLS);
		else
			mta_enter_state(s, MTA_READY);
		break;

	case MTA_HELO:
		if (line[0] != '2') {
			mta_error(s, "HELO rejected: %s", line);
			s->flags |= MTA_FREE;
			return;
		}
		mta_enter_state(s, MTA_READY);
		break;

	case MTA_LHLO:
		if (line[0] != '2') {
			mta_error(s, "LHLO rejected: %s", line);
			s->flags |= MTA_FREE;
			return;
		}
		mta_enter_state(s, MTA_READY);
		break;

	case MTA_STARTTLS:
		if (line[0] != '2') {
			if (!(s->flags & MTA_WANT_SECURE)) {
				mta_enter_state(s, MTA_AUTH);
				return;
			}
			/* XXX mark that the MX doesn't support STARTTLS */
			mta_error(s, "STARTTLS rejected: %s", line);
			s->flags |= MTA_FREE;
			return;
		}

		mta_start_tls(s);
		break;

	case MTA_AUTH_PLAIN:
		if (line[0] != '2') {
			mta_error(s, "AUTH rejected: %s", line);
			s->flags |= MTA_FREE;
			return;
		}
		mta_enter_state(s, MTA_READY);
		break;

	case MTA_AUTH_LOGIN:
		if (strncmp(line, "334 ", 4) != 0) {
			mta_error(s, "AUTH rejected: %s", line);
			s->flags |= MTA_FREE;
			return;
		}
		mta_enter_state(s, MTA_AUTH_LOGIN_USER);
		break;

	case MTA_AUTH_LOGIN_USER:
		if (strncmp(line, "334 ", 4) != 0) {
			mta_error(s, "AUTH rejected: %s", line);
			s->flags |= MTA_FREE;
			return;
		}
		mta_enter_state(s, MTA_AUTH_LOGIN_PASS);
		break;

	case MTA_AUTH_LOGIN_PASS:
		if (line[0] != '2') {
			mta_error(s, "AUTH rejected: %s", line);
			s->flags |= MTA_FREE;
			return;
		}
		mta_enter_state(s, MTA_READY);
		break;

	case MTA_MAIL:
		if (line[0] != '2') {
			if (line[0] == '5')
				delivery = IMSG_MTA_DELIVERY_PERMFAIL;
			else
				delivery = IMSG_MTA_DELIVERY_TEMPFAIL;
			mta_flush_task(s, delivery, line, 0, 0);
			mta_enter_state(s, MTA_RSET);
			return;
		}
		mta_enter_state(s, MTA_RCPT);
		break;

	case MTA_RCPT:
		e = s->currevp;

		/* remove envelope from hosttat cache if there */
		if ((domain = strchr(e->dest, '@@')) != NULL) {
			domain++;
			mta_hoststat_uncache(domain, e->id);
		}

		s->currevp = TAILQ_NEXT(s->currevp, entry);
		if (line[0] == '2') {
			s->failures = 0;
			/*
			 * this host is up, reschedule envelopes that
			 * were cached for reschedule.
			 */
			if (domain)
				mta_hoststat_reschedule(domain);
		}
		else {
			if (line[0] == '5')
				delivery = IMSG_MTA_DELIVERY_PERMFAIL;
			else
				delivery = IMSG_MTA_DELIVERY_TEMPFAIL;
			s->failures++;

			/* remove failed envelope from task list */
			TAILQ_REMOVE(&s->task->envelopes, e, entry);
			stat_decrement("mta.envelope", 1);

			/* log right away */
			(void)snprintf(buf, sizeof(buf), "%s",
			    mta_host_to_text(s->route->dst));

			e->session = s->id;
			/* XXX */
			/*
			 * getsockname() can only fail with ENOBUFS here
			 * best effort, don't log source ...
			 */
			sa_len = sizeof(ss);
			sa = (struct sockaddr *)&ss;
			if (getsockname(io_fileno(s->io), sa, &sa_len) < 0)
				mta_delivery_log(e, NULL, buf, delivery, line);
			else
				mta_delivery_log(e, sa_to_text(sa),
				    buf, delivery, line);

			if (domain)
				mta_hoststat_update(domain, e->status);
			mta_delivery_notify(e);

			if (s->relay->limits->max_failures_per_session &&
			    s->failures == s->relay->limits->max_failures_per_session) {
					mta_flush_task(s, IMSG_MTA_DELIVERY_TEMPFAIL,
					    "Too many consecutive errors, closing connection", 0, 1);
					mta_enter_state(s, MTA_QUIT);
					break;
				}

			/*
			 * if no more envelopes, flush failed queue
			 */
			if (TAILQ_EMPTY(&s->task->envelopes)) {
				mta_flush_task(s, IMSG_MTA_DELIVERY_OK,
				    "No envelope", 0, 0);
				mta_enter_state(s, MTA_RSET);
				break;
			}
		}

		if (s->currevp == NULL)
			mta_enter_state(s, MTA_DATA);
		else
			mta_enter_state(s, MTA_RCPT);
		break;

	case MTA_DATA:
		if (line[0] == '2' || line[0] == '3') {
			mta_enter_state(s, MTA_BODY);
			break;
		}
		if (line[0] == '5')
			delivery = IMSG_MTA_DELIVERY_PERMFAIL;
		else
			delivery = IMSG_MTA_DELIVERY_TEMPFAIL;
		mta_flush_task(s, delivery, line, 0, 0);
		mta_enter_state(s, MTA_RSET);
		break;

	case MTA_LMTP_EOM:
	case MTA_EOM:
		if (line[0] == '2') {
			delivery = IMSG_MTA_DELIVERY_OK;
			s->msgtried = 0;
			s->msgcount++;
		}
		else if (line[0] == '5')
			delivery = IMSG_MTA_DELIVERY_PERMFAIL;
		else
			delivery = IMSG_MTA_DELIVERY_TEMPFAIL;
		mta_flush_task(s, delivery, line, (s->flags & MTA_LMTP) ? 1 : 0, 0);
		if (s->task) {
			s->rcptcount--;
			mta_enter_state(s, MTA_LMTP_EOM);
		} else {
			s->rcptcount = 0;
			if (s->relay->limits->sessdelay_transaction) {
				log_debug("debug: mta: waiting for %llds before next transaction",
				    (long long int)s->relay->limits->sessdelay_transaction);
				s->hangon = s->relay->limits->sessdelay_transaction -1;
				s->flags |= MTA_HANGON;
				runq_schedule(hangon, time(NULL)
				    + s->relay->limits->sessdelay_transaction,
				    NULL, s);
			}
			else
				mta_enter_state(s, MTA_READY);
		}
		break;

	case MTA_RSET:
		s->rcptcount = 0;
		if (s->relay->limits->sessdelay_transaction) {
			log_debug("debug: mta: waiting for %llds after reset",
			    (long long int)s->relay->limits->sessdelay_transaction);
			s->hangon = s->relay->limits->sessdelay_transaction -1;
			s->flags |= MTA_HANGON;
			runq_schedule(hangon, time(NULL)
			    + s->relay->limits->sessdelay_transaction,
			    NULL, s);
		}
		else
			mta_enter_state(s, MTA_READY);
		break;

	default:
		fatalx("mta_response() bad state");
	}
}

static void
mta_io(struct io *io, int evt, void *arg)
{
	struct mta_session	*s = arg;
	char			*line, *msg, *p;
	size_t			 len;
	const char		*error;
	int			 cont;

	log_trace(TRACE_IO, "mta: %p: %s %s", s, io_strevent(evt),
	    io_strio(io));

	switch (evt) {

	case IO_CONNECTED:
		log_info("%016"PRIx64" mta event=connected", s->id);

		if (s->use_smtps) {
			io_set_write(io);
			mta_start_tls(s);
		}
		else {
			mta_enter_state(s, MTA_BANNER);
			io_set_read(io);
		}
		break;

	case IO_TLSREADY:
		log_info("%016"PRIx64" mta event=starttls ciphers=%s",
		    s->id, ssl_to_text(io_ssl(s->io)));
		s->flags |= MTA_TLS;

		if (mta_verify_certificate(s)) {
			io_pause(s->io, IO_IN);
			break;
		}

		mta_tls_verified(s);
		break;

	case IO_DATAIN:
	    nextline:
		line = io_getline(s->io, &len);
		if (line == NULL) {
			if (io_datalen(s->io) >= LINE_MAX) {
				mta_error(s, "Input too long");
				mta_free(s);
			}
			return;
		}

		log_trace(TRACE_MTA, "mta: %p: <<< %s", s, line);

		if ((error = parse_smtp_response(line, len, &msg, &cont))) {
			mta_error(s, "Bad response: %s", error);
			mta_free(s);
			return;
		}

		/* read extensions */
		if (s->state == MTA_EHLO) {
			if (strcmp(msg, "STARTTLS") == 0)
				s->ext |= MTA_EXT_STARTTLS;
			else if (strncmp(msg, "AUTH ", 5) == 0) {
                                s->ext |= MTA_EXT_AUTH;
                                if ((p = strstr(msg, " PLAIN")) &&
				    (*(p+6) == '\0' || *(p+6) == ' '))
                                        s->ext |= MTA_EXT_AUTH_PLAIN;
                                if ((p = strstr(msg, " LOGIN")) &&
				    (*(p+6) == '\0' || *(p+6) == ' '))
                                        s->ext |= MTA_EXT_AUTH_LOGIN;
			}
			else if (strcmp(msg, "PIPELINING") == 0)
				s->ext |= MTA_EXT_PIPELINING;
			else if (strcmp(msg, "DSN") == 0)
				s->ext |= MTA_EXT_DSN;
		}

		/* continuation reply, we parse out the repeating statuses and ESC */
		if (cont) {
			if (s->replybuf[0] == '\0')
				(void)strlcat(s->replybuf, line, sizeof s->replybuf);
			else {
				line = line + 4;
				if (isdigit((int)*line) && *(line + 1) == '.' &&
				    isdigit((int)*line+2) && *(line + 3) == '.' &&
				    isdigit((int)*line+4) && isspace((int)*(line + 5)))
					(void)strlcat(s->replybuf, line+5, sizeof s->replybuf);
				else
					(void)strlcat(s->replybuf, line, sizeof s->replybuf);
			}
			goto nextline;
		}

		/* last line of a reply, check if we're on a continuation to parse out status and ESC.
		 * if we overflow reply buffer or are not on continuation, log entire last line.
		 */
		if (s->replybuf[0] != '\0') {
			p = line + 4;
			if (isdigit((int)*p) && *(p + 1) == '.' &&
			    isdigit((int)*p+2) && *(p + 3) == '.' &&
			    isdigit((int)*p+4) && isspace((int)*(p + 5)))
				p += 5;
			if (strlcat(s->replybuf, p, sizeof s->replybuf) >= sizeof s->replybuf)
				(void)strlcpy(s->replybuf, line, sizeof s->replybuf);
		}
		else
			(void)strlcpy(s->replybuf, line, sizeof s->replybuf);

		if (s->state == MTA_QUIT) {
			log_info("%016"PRIx64" mta event=closed reason=quit messages=%zu",
			    s->id, s->msgcount);
			mta_free(s);
			return;
		}
		io_set_write(io);
		mta_response(s, s->replybuf);
		if (s->flags & MTA_FREE) {
			mta_free(s);
			return;
		}
		if (s->flags & MTA_RECONN) {
			s->flags &= ~MTA_RECONN;
			mta_connect(s);
			return;
		}

		if (io_datalen(s->io)) {
			log_debug("debug: mta: remaining data in input buffer");
			mta_error(s, "Remote host sent too much data");
			if (s->flags & MTA_WAIT)
				s->flags |= MTA_FREE;
			else
				mta_free(s);
		}
		break;

	case IO_LOWAT:
		if (s->state == MTA_BODY) {
			mta_enter_state(s, MTA_BODY);
			if (s->flags & MTA_FREE) {
				mta_free(s);
				return;
			}
		}

		if (io_queued(s->io) == 0)
			io_set_read(io);
		break;

	case IO_TIMEOUT:
		log_debug("debug: mta: %p: connection timeout", s);
		mta_error(s, "Connection timeout");
		if (!s->ready)
			mta_connect(s);
		else
			mta_free(s);
		break;

	case IO_ERROR:
		log_debug("debug: mta: %p: IO error: %s", s, io_error(io));
		if (!s->ready) {
			mta_error(s, "IO Error: %s", io_error(io));
			mta_connect(s);
			break;
		}
		else if (!(s->flags & (MTA_FORCE_TLS|MTA_FORCE_SMTPS|MTA_FORCE_ANYSSL))) {
			/* error in non-strict SSL negotiation, downgrade to plain */
			if (s->flags & MTA_TLS) {
				log_info("smtp-out: Error on session %016"PRIx64
				    ": opportunistic TLS failed, "
				    "downgrading to plain", s->id);
				s->flags &= ~MTA_TLS;
				s->flags |= MTA_DOWNGRADE_PLAIN;
				mta_connect(s);
				break;
			}
		}
		mta_error(s, "IO Error: %s", io_error(io));
		mta_free(s);
		break;

	case IO_TLSERROR:
		log_debug("debug: mta: %p: TLS IO error: %s", s, io_error(io));
		if (!(s->flags & (MTA_FORCE_TLS|MTA_FORCE_SMTPS|MTA_FORCE_ANYSSL))) {
			/* error in non-strict SSL negotiation, downgrade to plain */
			log_info("smtp-out: TLS Error on session %016"PRIx64
			    ": TLS failed, "
			    "downgrading to plain", s->id);
			s->flags &= ~MTA_TLS;
			s->flags |= MTA_DOWNGRADE_PLAIN;
			mta_connect(s);
			break;
		}
		mta_error(s, "IO Error: %s", io_error(io));
		mta_free(s);
		break;

	case IO_DISCONNECTED:
		log_debug("debug: mta: %p: disconnected in state %s",
		    s, mta_strstate(s->state));
		mta_error(s, "Connection closed unexpectedly");
		if (!s->ready)
			mta_connect(s);
		else
			mta_free(s);
		break;

	default:
		fatalx("mta_io() bad event");
	}
}

static void
mta_send(struct mta_session *s, char *fmt, ...)
{
	va_list  ap;
	char	*p;
	int	 len;

	va_start(ap, fmt);
	if ((len = vasprintf(&p, fmt, ap)) == -1)
		fatal("mta: vasprintf");
	va_end(ap);

	log_trace(TRACE_MTA, "mta: %p: >>> %s", s, p);

	io_xprintf(s->io, "%s\r\n", p);

	free(p);
}

/*
 * Queue some data into the input buffer
 */
static ssize_t
mta_queue_data(struct mta_session *s)
{
	char	*ln = NULL;
	size_t	 sz = 0, q;
	ssize_t	 len;

	q = io_queued(s->io);

	while (io_queued(s->io) < MTA_HIWAT) {
		if ((len = getline(&ln, &sz, s->datafp)) == -1)
			break;
		if (ln[len - 1] == '\n')
			ln[len - 1] = '\0';
		io_xprintf(s->io, "%s%s\r\n", *ln == '.' ? "." : "", ln);
	}

	free(ln);
	if (ferror(s->datafp)) {
		mta_flush_task(s, IMSG_MTA_DELIVERY_TEMPFAIL,
		    "Error reading content file", 0, 0);
		return (-1);
	}

	if (feof(s->datafp)) {
		fclose(s->datafp);
		s->datafp = NULL;
	}

	return (io_queued(s->io) - q);
}

static void
mta_flush_task(struct mta_session *s, int delivery, const char *error, size_t count,
	int cache)
{
	struct mta_envelope	*e;
	char			 relay[LINE_MAX];
	size_t			 n;
	struct sockaddr_storage	 ss;
	struct sockaddr		*sa;
	socklen_t		 sa_len;
	const char		*domain;

	(void)snprintf(relay, sizeof relay, "%s", mta_host_to_text(s->route->dst));
	n = 0;
	while ((e = TAILQ_FIRST(&s->task->envelopes))) {

		if (count && n == count) {
			stat_decrement("mta.envelope", n);
			return;
		}

		TAILQ_REMOVE(&s->task->envelopes, e, entry);

		/* we're about to log, associate session to envelope */
		e->session = s->id;
		e->ext = s->ext;

		/* XXX */
		/*
		 * getsockname() can only fail with ENOBUFS here
		 * best effort, don't log source ...
		 */
		sa = (struct sockaddr *)&ss;
		sa_len = sizeof(ss);
		if (getsockname(io_fileno(s->io), sa, &sa_len) < 0)
			mta_delivery_log(e, NULL, relay, delivery, error);
		else
			mta_delivery_log(e, sa_to_text(sa),
			    relay, delivery, error);

		mta_delivery_notify(e);

		domain = strchr(e->dest, '@@');
		if (domain) {
			domain++;
			mta_hoststat_update(domain, error);
			if (cache)
				mta_hoststat_cache(domain, e->id);
		}

		n++;
	}

	free(s->task->sender);
	free(s->task);
	s->task = NULL;

	if (s->datafp) {
		fclose(s->datafp);
		s->datafp = NULL;
	}

	stat_decrement("mta.envelope", n);
	stat_decrement("mta.task.running", 1);
	stat_decrement("mta.task", 1);
}

static void
mta_error(struct mta_session *s, const char *fmt, ...)
{
	va_list  ap;
	char	*error;
	int	 len;

	va_start(ap, fmt);
	if ((len = vasprintf(&error, fmt, ap)) == -1)
		fatal("mta: vasprintf");
	va_end(ap);

	if (s->msgcount)
		log_info("smtp-out: Error on session %016"PRIx64
		    " after %zu message%s sent: %s", s->id, s->msgcount,
		    (s->msgcount > 1) ? "s" : "", error);
	else
		log_info("%016"PRIx64" mta event=error reason=%s",
		    s->id, error);

	/*
	 * If not connected yet, and the error is not local, just ignore it
	 * and try to reconnect.
	 */
	if (s->state == MTA_INIT &&
	    (errno == ETIMEDOUT || errno == ECONNREFUSED)) {
		log_debug("debug: mta: not reporting route error yet");
		free(error);
		return;
	}

	mta_route_error(s->relay, s->route);

	if (s->task)
		mta_flush_task(s, IMSG_MTA_DELIVERY_TEMPFAIL, error, 0, 0);

	free(error);
}

static void
mta_start_tls(struct mta_session *s)
{
	struct ca_cert_req_msg	req_ca_cert;
	const char	       *certname;

	if (s->relay->pki_name) {
		certname = s->relay->pki_name;
		req_ca_cert.fallback = 0;
	}
	else {
		certname = s->helo;
		req_ca_cert.fallback = 1;
	}

	req_ca_cert.reqid = s->id;
	(void)strlcpy(req_ca_cert.name, certname, sizeof req_ca_cert.name);
	m_compose(p_lka, IMSG_MTA_TLS_INIT, 0, 0, -1,
	    &req_ca_cert, sizeof(req_ca_cert));
	tree_xset(&wait_ssl_init, s->id, s);
	s->flags |= MTA_WAIT;
	return;
}

static int
mta_verify_certificate(struct mta_session *s)
{
#define MAX_CERTS	16
#define MAX_CERT_LEN	(MAX_IMSGSIZE - (IMSG_HEADER_SIZE + sizeof(req_ca_vrfy)))
	struct ca_vrfy_req_msg	req_ca_vrfy;
	struct iovec		iov[2];
	X509		       *x;
	STACK_OF(X509)	       *xchain;
	const char	       *name;
	unsigned char	       *cert_der[MAX_CERTS];
	int			cert_len[MAX_CERTS];
	int			i, cert_count, res;

	res = 0;
	memset(cert_der, 0, sizeof(cert_der));
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);

	/* Send the client certificate */
	if (s->relay->ca_name) {
		name = s->relay->ca_name;
		req_ca_vrfy.fallback = 0;
	}
	else {
		name = s->helo;
		req_ca_vrfy.fallback = 1;
	}
	if (strlcpy(req_ca_vrfy.name, name, sizeof req_ca_vrfy.name)
	    >= sizeof req_ca_vrfy.name)
		return 0;

	x = SSL_get_peer_certificate(io_ssl(s->io));
	if (x == NULL)
		return 0;
	xchain = SSL_get_peer_cert_chain(io_ssl(s->io));

	/*
	 * Client provided a certificate and possibly a certificate chain.
	 * SMTP can't verify because it does not have the information that
	 * it needs, instead it will pass the certificate and chain to the
	 * lookup process and wait for a reply.
	 *
	 */

	cert_len[0] = i2d_X509(x, &cert_der[0]);
	X509_free(x);

	if (cert_len[0] < 0) {
		log_warnx("warn: failed to encode certificate");
		goto end;
	}
	log_debug("debug: certificate 0: len=%d", cert_len[0]);
	if (cert_len[0] > (int)MAX_CERT_LEN) {
		log_warnx("warn: certificate too long");
		goto end;
	}

	if (xchain) {
		cert_count = sk_X509_num(xchain);
		log_debug("debug: certificate chain len: %d", cert_count);
		if (cert_count >= MAX_CERTS) {
			log_warnx("warn: certificate chain too long");
			goto end;
		}
	}
	else
		cert_count = 0;

	for (i = 0; i < cert_count; ++i) {
		x = sk_X509_value(xchain, i);
		cert_len[i+1] = i2d_X509(x, &cert_der[i+1]);
		if (cert_len[i+1] < 0) {
			log_warnx("warn: failed to encode certificate");
			goto end;
		}
		log_debug("debug: certificate %i: len=%d", i+1, cert_len[i+1]);
		if (cert_len[i+1] > (int)MAX_CERT_LEN) {
			log_warnx("warn: certificate too long");
			goto end;
		}
	}

	tree_xset(&wait_ssl_verify, s->id, s);
	s->flags |= MTA_WAIT;

	/* Send the client certificate */
	req_ca_vrfy.reqid = s->id;
	req_ca_vrfy.cert_len = cert_len[0];
	req_ca_vrfy.n_chain = cert_count;
	iov[0].iov_base = &req_ca_vrfy;
	iov[0].iov_len = sizeof(req_ca_vrfy);
	iov[1].iov_base = cert_der[0];
	iov[1].iov_len = cert_len[0];
	m_composev(p_lka, IMSG_MTA_TLS_VERIFY_CERT, 0, 0, -1,
	    iov, nitems(iov));

	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	req_ca_vrfy.reqid = s->id;

	/* Send the chain, one cert at a time */
	for (i = 0; i < cert_count; ++i) {
		req_ca_vrfy.cert_len = cert_len[i+1];
		iov[1].iov_base = cert_der[i+1];
		iov[1].iov_len  = cert_len[i+1];
		m_composev(p_lka, IMSG_MTA_TLS_VERIFY_CHAIN, 0, 0, -1,
		    iov, nitems(iov));
	}

	/* Tell lookup process that it can start verifying, we're done */
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	req_ca_vrfy.reqid = s->id;
	m_compose(p_lka, IMSG_MTA_TLS_VERIFY, 0, 0, -1,
	    &req_ca_vrfy, sizeof req_ca_vrfy);

	res = 1;

    end:
	for (i = 0; i < MAX_CERTS; ++i)
		free(cert_der[i]);

	return res;
}

static void
mta_tls_verified(struct mta_session *s)
{
	X509 *x;

	x = SSL_get_peer_certificate(io_ssl(s->io));
	if (x) {
		log_info("smtp-out: Server certificate verification %s "
		    "on session %016"PRIx64,
		    (s->flags & MTA_VERIFIED) ? "succeeded" : "failed",
		    s->id);
		X509_free(x);
	}

	if (s->use_smtps) {
		mta_enter_state(s, MTA_BANNER);
		io_set_read(s->io);
	}
	else
		mta_enter_state(s, MTA_EHLO);
}

static const char *
dsn_strret(enum dsn_ret ret)
{
	if (ret == DSN_RETHDRS)
		return "HDRS";
	else if (ret == DSN_RETFULL)
		return "FULL";
	else {
		log_debug("mta: invalid ret %d", ret);
		return "???";
	}
}

static const char *
dsn_strnotify(uint8_t arg)
{
	static char	buf[32];
	size_t		sz;

	buf[0] = '\0';
	if (arg & DSN_SUCCESS)
		(void)strlcat(buf, "SUCCESS,", sizeof(buf));

	if (arg & DSN_FAILURE)
		(void)strlcat(buf, "FAILURE,", sizeof(buf));

	if (arg & DSN_DELAY)
		(void)strlcat(buf, "DELAY,", sizeof(buf));

	if (arg & DSN_NEVER)
		(void)strlcat(buf, "NEVER,", sizeof(buf));

	/* trim trailing comma */
	sz = strlen(buf);
	if (sz)
		buf[sz - 1] = '\0';

	return (buf);
}

#define CASE(x) case x : return #x

static const char *
mta_strstate(int state)
{
	switch (state) {
	CASE(MTA_INIT);
	CASE(MTA_BANNER);
	CASE(MTA_EHLO);
	CASE(MTA_HELO);
	CASE(MTA_STARTTLS);
	CASE(MTA_AUTH);
	CASE(MTA_AUTH_PLAIN);
	CASE(MTA_AUTH_LOGIN);
	CASE(MTA_AUTH_LOGIN_USER);
	CASE(MTA_AUTH_LOGIN_PASS);
	CASE(MTA_READY);
	CASE(MTA_MAIL);
	CASE(MTA_RCPT);
	CASE(MTA_DATA);
	CASE(MTA_BODY);
	CASE(MTA_EOM);
	CASE(MTA_LMTP_EOM);
	CASE(MTA_RSET);
	CASE(MTA_QUIT);
	default:
		return "MTA_???";
	}
}
@


1.97
log
@Introduce more use of freezero().  Also, remove ptr conditionals before
many functions which are free(NULL)-compat
ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.96 2016/11/30 17:43:32 eric Exp $	*/
d1299 1
a1299 1
		else if (!(s->flags & (MTA_FORCE_TLS|MTA_FORCE_ANYSSL))) {
d1317 1
a1317 1
		if (!(s->flags & (MTA_FORCE_TLS|MTA_FORCE_ANYSSL))) {
@


1.96
log
@hide internal io flags and rename IO_PAUSE_{IN,OUT} to IO_{IN,OUT}

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.95 2016/11/30 11:52:48 eric Exp $	*/
d344 1
a344 2
		explicit_bzero(resp_ca_cert->cert, resp_ca_cert->cert_len);
		free(resp_ca_cert->cert);
@


1.95
log
@make struct io opaque:

- move struct io definition to ioev.c
- replace io_init/io_clear with io_new/io_free
- allocate an iobuf for each new io internally
- use struct io pointer in the rest of the code
- remove remaining uses of iobuf_*

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.94 2016/11/25 11:43:55 eric Exp $	*/
d365 1
a365 1
		io_resume(s->io, IO_PAUSE_IN);
d1167 1
a1167 1
			io_pause(s->io, IO_PAUSE_IN);
@


1.94
log
@use a specific event to defer the mta connection instead of abusing
the io internal event.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.93 2016/11/24 20:52:13 eric Exp $	*/
d118 1
a118 2
	struct iobuf		 iobuf;
	struct io		 io;
a197 1
	io_init(&s->io, NULL);
d330 1
a330 1
				io_start_tls(&s->io, ssl);
d342 1
a342 1
		io_start_tls(&s->io, ssl);
d365 1
a365 1
		io_resume(&s->io, IO_PAUSE_IN);
d428 2
a429 2
	io_clear(&s->io);
	iobuf_clear(&s->iobuf);
d498 4
a501 2
	io_clear(&s->io);
	iobuf_clear(&s->iobuf);
d559 4
a562 5
	iobuf_xinit(&s->iobuf, 0, 0, "mta_connect");
	io_init(&s->io, &s->iobuf);
	io_set_callback(&s->io, mta_io, s);
	io_set_timeout(&s->io, 300000);
	if (io_connect(&s->io, sa, s->route->src->sa) == -1) {
d567 1
a567 1
		log_debug("debug: mta: io_connect failed: %s", io_error(&s->io));
d569 1
a569 1
			mta_source_error(s->relay, s->route, io_error(&s->io));
d571 1
a571 1
			mta_error(s, "Connection failed: %s", io_error(&s->io));
d844 1
a844 1
		io_set_read(&s->io);
d1035 1
a1035 1
			if (getsockname(io_fileno(&s->io), sa, &sa_len) < 0)
d1163 1
a1163 1
		    s->id, ssl_to_text(io_ssl(&s->io)));
d1167 1
a1167 1
			io_pause(&s->io, IO_PAUSE_IN);
d1176 1
a1176 1
		line = io_getline(&s->io, &len);
d1178 1
a1178 1
			if (io_datalen(&s->io) >= LINE_MAX) {
d1261 1
a1261 1
		if (io_datalen(&s->io)) {
d1280 1
a1280 1
		if (io_queued(&s->io) == 0)
d1361 1
a1361 1
	io_xprintf(&s->io, "%s\r\n", p);
d1376 1
a1376 1
	q = io_queued(&s->io);
d1378 1
a1378 1
	while (io_queued(&s->io) < MTA_HIWAT) {
d1383 1
a1383 1
		io_xprintf(&s->io, "%s%s\r\n", *ln == '.' ? "." : "", ln);
d1398 1
a1398 1
	return (io_queued(&s->io) - q);
d1435 1
a1435 1
		if (getsockname(io_fileno(&s->io), sa, &sa_len) < 0)
d1562 1
a1562 1
	x = SSL_get_peer_certificate(io_ssl(&s->io));
d1565 1
a1565 1
	xchain = SSL_get_peer_cert_chain(io_ssl(&s->io));
d1659 1
a1659 1
	x = SSL_get_peer_certificate(io_ssl(&s->io));
d1670 1
a1670 1
		io_set_read(&s->io);
@


1.93
log
@add an io_fileno() accessor

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.92 2016/11/24 20:44:04 eric Exp $	*/
d117 1
d240 2
a241 2
		evtimer_set(&s->io.ev, mta_start, s);
		evtimer_add(&s->io.ev, &tv);
@


1.92
log
@add an io_ssl() accessor

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.91 2016/11/24 12:58:27 eric Exp $	*/
d1035 1
a1035 1
			if (getsockname(s->io.sock, sa, &sa_len) < 0)
d1435 1
a1435 1
		if (getsockname(s->io.sock, sa, &sa_len) < 0)
@


1.91
log
@add an io_error() accessor to avoid dereferencing the io struct directly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.90 2016/11/24 07:57:48 eric Exp $	*/
d1163 1
a1163 1
		    s->id, ssl_to_text(s->io.ssl));
d1562 1
a1562 1
	x = SSL_get_peer_certificate(s->io.ssl);
d1565 1
a1565 1
	xchain = SSL_get_peer_cert_chain(s->io.ssl);
d1659 1
a1659 1
	x = SSL_get_peer_certificate(s->io.ssl);
@


1.90
log
@reset the io event when data is queued.
remove all calls to io_reload() which are now unnecessary.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.89 2016/11/22 07:28:42 eric Exp $	*/
d567 1
a567 1
		log_debug("debug: mta: io_connect failed: %s", s->io.error);
d569 1
a569 1
			mta_source_error(s->relay, s->route, s->io.error);
d571 1
a571 1
			mta_error(s, "Connection failed: %s", s->io.error);
d1294 1
a1294 1
		log_debug("debug: mta: %p: IO error: %s", s, io->error);
d1296 1
a1296 1
			mta_error(s, "IO Error: %s", io->error);
d1312 1
a1312 1
		mta_error(s, "IO Error: %s", io->error);
d1317 1
a1317 1
		log_debug("debug: mta: %p: TLS IO error: %s", s, io->error);
d1328 1
a1328 1
		mta_error(s, "IO Error: %s", io->error);
@


1.89
log
@Normalize the io input buffer internally when reinstalling the io event, so
the caller doesn't have to bother with this.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.88 2016/11/21 13:00:43 eric Exp $	*/
a282 1
			io_reload(&s->io);
a290 1
		io_reload(&s->io);
a366 1
		io_reload(&s->io);
a455 1
	io_reload(&s->io);
@


1.88
log
@replace calls to iobuf_*() functions with the corresponding io_*() wrappers.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.87 2016/11/20 08:43:36 eric Exp $	*/
a1184 1
				return;
d1186 1
a1186 2
			iobuf_normalize(&s->iobuf);
			break;
a1263 2

		iobuf_normalize(&s->iobuf);
@


1.87
log
@add dedicated functions to set fd and callback on a struct io.
simplify io_init() prototype.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.86 2016/11/18 09:35:27 eric Exp $	*/
d1180 1
a1180 1
		line = iobuf_getline(&s->iobuf, &len);
d1182 1
a1182 1
			if (iobuf_len(&s->iobuf) >= LINE_MAX) {
d1269 1
a1269 1
		if (iobuf_len(&s->iobuf)) {
d1288 1
a1288 1
		if (iobuf_queued(&s->iobuf) == 0)
d1369 1
a1369 1
	iobuf_xfqueue(&s->iobuf, "mta_send", "%s\r\n", p);
d1384 1
a1384 1
	q = iobuf_queued(&s->iobuf);
d1386 1
a1386 1
	while (iobuf_queued(&s->iobuf) < MTA_HIWAT) {
d1391 1
a1391 2
		iobuf_xfqueue(&s->iobuf, "mta_queue_data", "%s%s\r\n",
		    *ln == '.' ? "." : "", ln);
d1406 1
a1406 1
	return (iobuf_queued(&s->iobuf) - q);
@


1.86
log
@fix regression introduced in previous commit

spotted by Heiko Zimmermann

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.85 2016/11/17 07:33:06 eric Exp $	*/
d198 1
a198 1
	s->io.sock = -1;
d563 2
a564 1
	io_init(&s->io, -1, s, mta_io, &s->iobuf);
@


1.85
log
@remove IO_TLSVERIFIED which is not a io event, and inline necessary code
where the callback functions are called for this event.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.84 2016/11/16 21:30:37 eric Exp $	*/
d152 1
a262 1
	X509			*x;
d367 1
a367 16
		x = SSL_get_peer_certificate(s->io.ssl);
		if (x) {
			log_info("smtp-out: Server certificate verification %s "
			    "on session %016"PRIx64,
			    (s->flags & MTA_VERIFIED) ? "succeeded" : "failed",
			    s->id);
			X509_free(x);
		}

		if (s->use_smtps) {
			mta_enter_state(s, MTA_BANNER);
			io_set_read(&s->io);
		}
		else
			mta_enter_state(s, MTA_EHLO);

d1174 3
d1660 22
@


1.84
log
@pass the user pointer as parameter to the io callback instead of having
the user dereference the io structure.

ok millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.83 2016/05/22 16:31:21 gilles Exp $	*/
d262 1
d367 16
a382 1
		mta_io(&s->io, IO_TLSVERIFIED, s->io.arg);
a1159 1
	X509			*x;
a1187 18

	case IO_TLSVERIFIED:
		x = SSL_get_peer_certificate(s->io.ssl);
		if (x) {
			log_info("smtp-out: Server certificate verification %s "
			    "on session %016"PRIx64,
			    (s->flags & MTA_VERIFIED) ? "succeeded" : "failed",
			    s->id);
			X509_free(x);
		}

		if (s->use_smtps) {
			mta_enter_state(s, MTA_BANNER);
			io_set_read(io);
		}
		else
			mta_enter_state(s, MTA_EHLO);
		break;
@


1.83
log
@start work on improving the log format, this is work in progress but it'll
be better worked in tree

ok eric@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.82 2015/12/12 20:02:31 gilles Exp $	*/
d138 1
a138 1
static void mta_io(struct io *, int);
d366 1
a366 1
		mta_io(&s->io, IO_TLSVERIFIED);
d1137 1
a1137 1
mta_io(struct io *io, int evt)
d1139 1
a1139 1
	struct mta_session	*s = io->arg;
@


1.82
log
@remove CA from pki and no longer allow specifying a CA with 'pki' keyword.
introduce 'ca' keyword to allow specifying a custom CA.
making CA part of pki was a bad idea and several people hit use-cases that
plain couldn't work.

instead of:
    pki foobar.org ca "/etc/mail/CA.pem"

use now:
    ca foobar.org certificate "/etc/mail/CA.pem"


ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.81 2015/12/12 17:16:56 gilles Exp $	*/
d322 3
a324 2
				log_info("smtp-out: Disconnecting session %016"PRIx64
				    ": CA failure", s->id);
d555 4
a558 3
	log_info("smtp-out: Connecting to %s%s:%d (%s) on session"
	    " %016"PRIx64"...", schema, sa_to_text(s->route->dst->sa),
	    portno, s->route->dst->ptrname, s->id);
d722 1
a722 1
			log_info("smtp-out: Remote host seems to reject all mails on session %016"PRIx64,
d1152 1
a1152 1
		log_info("smtp-out: Connected on session %016"PRIx64, s->id);
d1165 1
a1165 1
		log_info("smtp-out: Started TLS on session %016"PRIx64": %s",
d1264 2
a1265 3
			log_info("smtp-out: Closing session %016"PRIx64
			    ": %zu message%s sent.", s->id, s->msgcount,
			    (s->msgcount > 1) ? "s" : "");
d1508 1
a1508 1
		log_info("smtp-out: Error on session %016"PRIx64 ": %s",
d1510 1
@


1.81
log
@allow overriding the default cipher-suite

ok jung@@, sunil@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.80 2015/12/12 08:43:42 gilles Exp $	*/
a261 1
	char			*pkiname;
d339 1
a339 5
		if (s->relay->pki_name)
			pkiname = s->relay->pki_name;
		else
			pkiname = s->helo;
		ssl = ssl_mta_init(pkiname,
d1570 3
a1572 2
	if (s->relay->pki_name) {
		name = s->relay->pki_name;
@


1.80
log
@change variable name
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.79 2015/12/12 08:40:40 gilles Exp $	*/
d329 1
a329 1
				ssl = ssl_mta_init(NULL, NULL, 0);
d345 1
a345 1
		    resp_ca_cert->cert, resp_ca_cert->cert_len);
@


1.79
log
@when a specific CA was not requested, pass hint to lka that fallback to a
wildcard CA is possible (lka does not use the hint yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.78 2015/12/11 21:44:01 gilles Exp $	*/
d1566 1
a1566 1
	const char	       *pkiname;
d1576 1
a1576 1
		pkiname = s->relay->pki_name;
d1580 1
a1580 1
		pkiname = s->helo;
d1583 1
a1583 1
	if (strlcpy(req_ca_vrfy.name, pkiname, sizeof req_ca_vrfy.name)
@


1.78
log
@rename field member + whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.77 2015/12/05 21:27:42 mmcc Exp $	*/
d1539 1
a1539 1
	if (s->relay->pki_name)
d1541 3
a1543 1
	else
d1545 2
d1575 1
a1575 1
	if (s->relay->pki_name)
d1577 3
a1579 1
	else
d1581 2
@


1.77
log
@Remove a few NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.76 2015/12/01 15:30:42 gilles Exp $	*/
d1575 2
a1576 2
	if (strlcpy(req_ca_vrfy.pkiname, pkiname, sizeof req_ca_vrfy.pkiname)
	    >= sizeof req_ca_vrfy.pkiname)
@


1.76
log
@when peer outputs a multi-line response, concat response into a single log

ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.75 2015/11/30 12:49:35 gilles Exp $	*/
d442 1
a442 2
	if (s->helo)
		free(s->helo);
@


1.75
log
@mechanical rename of some IMSG constants

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.74 2015/10/14 22:01:43 gilles Exp $	*/
d132 2
d602 2
d1236 13
a1248 1
		if (cont)
d1250 16
d1275 1
a1275 1
		mta_response(s, line);
d1597 1
a1597 1
		log_warnx("warn: failed to encode certificate");	
d1602 1
a1602 1
		log_warnx("warn: certificate too long");	
d1621 1
a1621 1
			log_warnx("warn: failed to encode certificate");	
d1626 1
a1626 1
			log_warnx("warn: certificate too long");	
@


1.74
log
@whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.73 2015/10/09 16:47:14 sunil Exp $	*/
d313 1
a313 1
	case IMSG_MTA_SSL_INIT:
d353 1
a353 1
	case IMSG_MTA_SSL_VERIFY:
d1515 1
a1515 1
	m_compose(p_lka, IMSG_MTA_SSL_INIT, 0, 0, -1,
d1610 1
a1610 1
	m_composev(p_lka, IMSG_MTA_SSL_VERIFY_CERT, 0, 0, -1,
d1621 1
a1621 1
		m_composev(p_lka, IMSG_MTA_SSL_VERIFY_CHAIN, 0, 0, -1,
d1628 1
a1628 1
	m_compose(p_lka, IMSG_MTA_SSL_VERIFY, 0, 0, -1,
@


1.73
log
@Convert fgetln(3) to getline(3).

Ok eric@@ todd@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.72 2015/10/02 00:44:30 gilles Exp $	*/
d1487 1
a1487 1
	if (s->state == MTA_INIT && 
@


1.72
log
@detect that a certificate chain will not fit in imsg calls before passing
part of it and failing others, this may leave the lookup process in a weird
state and cause use-after-free and out-of-bounds memory reads, leading to
crashes or potential arbitrary code execution in unprivileged process.

reported by Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.71 2015/01/20 17:37:54 deraadt Exp $	*/
d1367 3
a1369 2
	char	*ln;
	size_t	 len, q;
d1374 1
a1374 1
		if ((ln = fgetln(s->datafp, &len)) == NULL)
d1382 1
@


1.71
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.70 2015/01/16 06:40:20 deraadt Exp $	*/
d1523 2
a1528 1
	int			i;
d1530 15
d1559 38
a1600 9
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	if (s->relay->pki_name)
		pkiname = s->relay->pki_name;
	else
		pkiname = s->helo;
	if (strlcpy(req_ca_vrfy.pkiname, pkiname, sizeof req_ca_vrfy.pkiname)
	    >= sizeof req_ca_vrfy.pkiname)
		return 0;

d1602 2
a1603 3
	req_ca_vrfy.cert_len = i2d_X509(x, &req_ca_vrfy.cert);
	if (xchain)
		req_ca_vrfy.n_chain = sk_X509_num(xchain);
d1606 2
a1607 2
	iov[1].iov_base = req_ca_vrfy.cert;
	iov[1].iov_len = req_ca_vrfy.cert_len;
a1609 2
	free(req_ca_vrfy.cert);
	X509_free(x);
d1611 10
a1620 15
	if (xchain) {		
		/* Send the chain, one cert at a time */
		for (i = 0; i < sk_X509_num(xchain); ++i) {
			memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
			req_ca_vrfy.reqid = s->id;
			x = sk_X509_value(xchain, i);
			req_ca_vrfy.cert_len = i2d_X509(x, &req_ca_vrfy.cert);
			iov[0].iov_base = &req_ca_vrfy;
			iov[0].iov_len  = sizeof(req_ca_vrfy);
			iov[1].iov_base = req_ca_vrfy.cert;
			iov[1].iov_len  = req_ca_vrfy.cert_len;
			m_composev(p_lka, IMSG_MTA_SSL_VERIFY_CHAIN, 0, 0, -1,
			    iov, nitems(iov));
			free(req_ca_vrfy.cert);
		}
d1629 7
a1635 1
	return 1;
@


1.71.2.1
log
@Errata 017:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.71 2015/01/20 17:37:54 deraadt Exp $	*/
a1522 2
#define MAX_CERTS	16
#define MAX_CERT_LEN	(MAX_IMSGSIZE - (IMSG_HEADER_SIZE + sizeof(req_ca_vrfy)))
d1527 1
a1528 15
	unsigned char	       *cert_der[MAX_CERTS];
	int			cert_len[MAX_CERTS];
	int			i, cert_count, res;

	res = 0;
	memset(cert_der, 0, sizeof(cert_der));
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);

	if (s->relay->pki_name)
		pkiname = s->relay->pki_name;
	else
		pkiname = s->helo;
	if (strlcpy(req_ca_vrfy.pkiname, pkiname, sizeof req_ca_vrfy.pkiname)
	    >= sizeof req_ca_vrfy.pkiname)
		return 0;
a1542 38
	cert_len[0] = i2d_X509(x, &cert_der[0]);
	X509_free(x);

	if (cert_len[0] < 0) {
		log_warnx("warn: failed to encode certificate");	
		goto end;
	}
	log_debug("debug: certificate 0: len=%d", cert_len[0]);
	if (cert_len[0] > (int)MAX_CERT_LEN) {
		log_warnx("warn: certificate too long");	
		goto end;
	}

	if (xchain) {
		cert_count = sk_X509_num(xchain);
		log_debug("debug: certificate chain len: %d", cert_count);
		if (cert_count >= MAX_CERTS) {
			log_warnx("warn: certificate chain too long");
			goto end;
		}
	}
	else
		cert_count = 0;

	for (i = 0; i < cert_count; ++i) {
		x = sk_X509_value(xchain, i);
		cert_len[i+1] = i2d_X509(x, &cert_der[i+1]);
		if (cert_len[i+1] < 0) {
			log_warnx("warn: failed to encode certificate");	
			goto end;
		}
		log_debug("debug: certificate %i: len=%d", i+1, cert_len[i+1]);
		if (cert_len[i+1] > (int)MAX_CERT_LEN) {
			log_warnx("warn: certificate too long");	
			goto end;
		}
	}

d1547 9
d1557 3
a1559 2
	req_ca_vrfy.cert_len = cert_len[0];
	req_ca_vrfy.n_chain = cert_count;
d1562 2
a1563 2
	iov[1].iov_base = cert_der[0];
	iov[1].iov_len = cert_len[0];
d1566 2
d1569 15
a1583 10
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	req_ca_vrfy.reqid = s->id;

	/* Send the chain, one cert at a time */
	for (i = 0; i < cert_count; ++i) {
		req_ca_vrfy.cert_len = cert_len[i+1];
		iov[1].iov_base = cert_der[i+1];
		iov[1].iov_len  = cert_len[i+1];
		m_composev(p_lka, IMSG_MTA_SSL_VERIFY_CHAIN, 0, 0, -1,
		    iov, nitems(iov));
d1592 1
a1592 7
	res = 1;

    end:
	for (i = 0; i < MAX_CERTS; ++i)
		free(cert_der[i]);

	return res;
@


1.71.6.1
log
@Errata 004:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.71 2015/01/20 17:37:54 deraadt Exp $	*/
a1522 2
#define MAX_CERTS	16
#define MAX_CERT_LEN	(MAX_IMSGSIZE - (IMSG_HEADER_SIZE + sizeof(req_ca_vrfy)))
d1527 1
a1528 15
	unsigned char	       *cert_der[MAX_CERTS];
	int			cert_len[MAX_CERTS];
	int			i, cert_count, res;

	res = 0;
	memset(cert_der, 0, sizeof(cert_der));
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);

	if (s->relay->pki_name)
		pkiname = s->relay->pki_name;
	else
		pkiname = s->helo;
	if (strlcpy(req_ca_vrfy.pkiname, pkiname, sizeof req_ca_vrfy.pkiname)
	    >= sizeof req_ca_vrfy.pkiname)
		return 0;
a1542 38
	cert_len[0] = i2d_X509(x, &cert_der[0]);
	X509_free(x);

	if (cert_len[0] < 0) {
		log_warnx("warn: failed to encode certificate");	
		goto end;
	}
	log_debug("debug: certificate 0: len=%d", cert_len[0]);
	if (cert_len[0] > (int)MAX_CERT_LEN) {
		log_warnx("warn: certificate too long");	
		goto end;
	}

	if (xchain) {
		cert_count = sk_X509_num(xchain);
		log_debug("debug: certificate chain len: %d", cert_count);
		if (cert_count >= MAX_CERTS) {
			log_warnx("warn: certificate chain too long");
			goto end;
		}
	}
	else
		cert_count = 0;

	for (i = 0; i < cert_count; ++i) {
		x = sk_X509_value(xchain, i);
		cert_len[i+1] = i2d_X509(x, &cert_der[i+1]);
		if (cert_len[i+1] < 0) {
			log_warnx("warn: failed to encode certificate");	
			goto end;
		}
		log_debug("debug: certificate %i: len=%d", i+1, cert_len[i+1]);
		if (cert_len[i+1] > (int)MAX_CERT_LEN) {
			log_warnx("warn: certificate too long");	
			goto end;
		}
	}

d1547 9
d1557 3
a1559 2
	req_ca_vrfy.cert_len = cert_len[0];
	req_ca_vrfy.n_chain = cert_count;
d1562 2
a1563 2
	iov[1].iov_base = cert_der[0];
	iov[1].iov_len = cert_len[0];
d1566 2
d1569 15
a1583 10
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	req_ca_vrfy.reqid = s->id;

	/* Send the chain, one cert at a time */
	for (i = 0; i < cert_count; ++i) {
		req_ca_vrfy.cert_len = cert_len[i+1];
		iov[1].iov_base = cert_der[i+1];
		iov[1].iov_len  = cert_len[i+1];
		m_composev(p_lka, IMSG_MTA_SSL_VERIFY_CHAIN, 0, 0, -1,
		    iov, nitems(iov));
d1592 1
a1592 7
	res = 1;

    end:
	for (i = 0; i < MAX_CERTS; ++i)
		free(cert_der[i]);

	return res;
@


1.70
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.69 2014/12/24 13:51:31 eric Exp $	*/
d587 2
a588 2
	char			 ibuf[SMTPD_MAXLINESIZE];
	char			 obuf[SMTPD_MAXLINESIZE];
d878 1
a878 1
	char			 buf[SMTPD_MAXLINESIZE];
d1196 1
a1196 1
			if (iobuf_len(&s->iobuf) >= SMTPD_MAXLINESIZE) {
d1400 1
a1400 1
	char			 relay[SMTPD_MAXLINESIZE];
@


1.69
log
@Correctly fallback to PLAIN if opportunistics TLS fails during TLS handshake.

fix by Stefan Sieg

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.68 2014/07/04 15:24:46 eric Exp $	*/
d38 1
@


1.68
log
@It makes much more sense to do the loop checking on incoming mails rather
than on outgoing mails...

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1305 16
@


1.68.4.1
log
@Errata 031:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.68 2014/07/04 15:24:46 eric Exp $	*/
a1505 2
#define MAX_CERTS	16
#define MAX_CERT_LEN	(MAX_IMSGSIZE - (IMSG_HEADER_SIZE + sizeof(req_ca_vrfy)))
d1510 1
a1511 15
	unsigned char	       *cert_der[MAX_CERTS];
	int			cert_len[MAX_CERTS];
	int			i, cert_count, res;

	res = 0;
	memset(cert_der, 0, sizeof(cert_der));
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);

	if (s->relay->pki_name)
		pkiname = s->relay->pki_name;
	else
		pkiname = s->helo;
	if (strlcpy(req_ca_vrfy.pkiname, pkiname, sizeof req_ca_vrfy.pkiname)
	    >= sizeof req_ca_vrfy.pkiname)
		return 0;
a1525 38
	cert_len[0] = i2d_X509(x, &cert_der[0]);
	X509_free(x);

	if (cert_len[0] < 0) {
		log_warnx("warn: failed to encode certificate");	
		goto end;
	}
	log_debug("debug: certificate 0: len=%d", cert_len[0]);
	if (cert_len[0] > (int)MAX_CERT_LEN) {
		log_warnx("warn: certificate too long");	
		goto end;
	}

	if (xchain) {
		cert_count = sk_X509_num(xchain);
		log_debug("debug: certificate chain len: %d", cert_count);
		if (cert_count >= MAX_CERTS) {
			log_warnx("warn: certificate chain too long");
			goto end;
		}
	}
	else
		cert_count = 0;

	for (i = 0; i < cert_count; ++i) {
		x = sk_X509_value(xchain, i);
		cert_len[i+1] = i2d_X509(x, &cert_der[i+1]);
		if (cert_len[i+1] < 0) {
			log_warnx("warn: failed to encode certificate");	
			goto end;
		}
		log_debug("debug: certificate %i: len=%d", i+1, cert_len[i+1]);
		if (cert_len[i+1] > (int)MAX_CERT_LEN) {
			log_warnx("warn: certificate too long");	
			goto end;
		}
	}

d1530 9
d1540 3
a1542 2
	req_ca_vrfy.cert_len = cert_len[0];
	req_ca_vrfy.n_chain = cert_count;
d1545 2
a1546 2
	iov[1].iov_base = cert_der[0];
	iov[1].iov_len = cert_len[0];
d1549 2
d1552 15
a1566 10
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	req_ca_vrfy.reqid = s->id;

	/* Send the chain, one cert at a time */
	for (i = 0; i < cert_count; ++i) {
		req_ca_vrfy.cert_len = cert_len[i+1];
		iov[1].iov_base = cert_der[i+1];
		iov[1].iov_len  = cert_len[i+1];
		m_composev(p_lka, IMSG_MTA_SSL_VERIFY_CHAIN, 0, 0, -1,
		    iov, nitems(iov));
d1575 1
a1575 7
	res = 1;

    end:
	for (i = 0; i < MAX_CERTS; ++i)
		free(cert_der[i]);

	return res;
@


1.67
log
@always attempt to use tls for relaying to the primary server when
acting as a backup mx.  reported by otto@@.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.66 2014/05/20 18:47:01 eric Exp $	*/
a146 1
static int mta_check_loop(FILE *);
d288 1
a288 10
		if (mta_check_loop(s->datafp)) {
			log_debug("debug: mta: loop detected");
			fclose(s->datafp);
			s->datafp = NULL;
			mta_flush_task(s, IMSG_MTA_DELIVERY_LOOP,
			    "Loop detected", 0, 0);
			mta_enter_state(s, MTA_READY);
		} else {
			mta_enter_state(s, MTA_MAIL);
		}
a1480 42
}

static int
mta_check_loop(FILE *fp)
{
	char	*buf, *lbuf;
	size_t	 len;
	uint32_t rcvcount = 0;
	int	 ret = 0;

	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			/* EOF without EOL, copy and add the NUL */
			lbuf = xmalloc(len + 1, "mta_check_loop");
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}

		if (strchr(buf, ':') == NULL && !isspace((unsigned char)*buf))
			break;

		if (strncasecmp("Received: ", buf, 10) == 0) {
			rcvcount++;
			if (rcvcount == MAX_HOPS_COUNT) {
				ret = 1;
				break;
			}
		}
		if (lbuf) {
			free(lbuf);
			lbuf  = NULL;
		}
	}
	if (lbuf)
		free(lbuf);

	fseek(fp, SEEK_SET, 0);
	return ret;
@


1.66
log
@format string cleanup: change "%i" to "%d" and fix a few typos
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.65 2014/05/12 14:37:32 eric Exp $	*/
d222 3
@


1.65
log
@fix a possible double free when tls is required but not advertised by
the server.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.64 2014/04/30 12:49:54 gilles Exp $	*/
d843 1
a843 1
		log_trace(TRACE_MTA, "mta: %p: >>> [...%zi bytes...]", s, q);
@


1.64
log
@when doing opportunistic TLS, do not only downgrade during negotiation, but
also downgrade if a TLS error happens during the session.

ok eric@@ who helped me with this
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.63 2014/04/29 19:13:13 reyk Exp $	*/
d94 1
d637 1
a637 1
				mta_connect(s);
d1252 5
@


1.63
log
@Implement RSA privilege separation for OpenSMTPD, based on my previous
implementation for relayd(8).  The smtpd(8) pony processes (mta
client, smtp server) don't keep the private keys in memory but send
their private key operations as imsgs to the "lookup"/mta process.
It's worth mentioning that this prevents acidental private key leakage
as it could have been caused by "Heartbleed".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.62 2014/04/29 17:32:42 gilles Exp $	*/
d629 2
d742 11
a752 1
		s->task = mta_route_next_task(s->relay, s->route);
d1290 2
a1291 2
		mta_error(s, "IO Error: %s", io->error);
		if (!s->ready)
d1293 2
d1297 5
d1304 2
d1307 2
a1308 2
		else
			mta_free(s);
@


1.62
log
@when a session fails due to a TLS error in a smtp+tls:// connection, try
plain before giving up

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.60 2014/04/19 13:35:51 gilles Exp $	*/
d256 1
d332 1
a332 1
				ssl = ssl_mta_init(NULL, 0, NULL, 0);
d343 6
a348 5
		resp_ca_cert->key = xstrdup((char *)imsg->data +
		    sizeof *resp_ca_cert + resp_ca_cert->cert_len,
		    "mta:ca_key");
		ssl = ssl_mta_init(resp_ca_cert->cert, resp_ca_cert->cert_len,
		    resp_ca_cert->key, resp_ca_cert->key_len);
a353 1
		explicit_bzero(resp_ca_cert->key, resp_ca_cert->key_len);
a354 1
		free(resp_ca_cert->key);
@


1.61
log
@use explicit_bzero() instead of memset() to clear out sensitive data.

ok gilles@@
@
text
@d83 1
d529 4
a551 1

d877 5
d1281 5
@


1.60
log
@(void) cast snprintf() and strlcat() calls that cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.59 2014/04/08 12:44:57 gilles Exp $	*/
d350 2
a351 2
		memset(resp_ca_cert->cert, 0, resp_ca_cert->cert_len);
		memset(resp_ca_cert->key, 0, resp_ca_cert->key_len);
@


1.59
log
@zero-fill static buffer before use in DSN code

diff from Sunil Nimmagadda, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.58 2014/04/04 16:10:42 eric Exp $	*/
d1010 1
a1010 1
			snprintf(buf, sizeof(buf), "%s",
d1356 1
a1356 1
	snprintf(relay, sizeof relay, "%s", mta_host_to_text(s->route->dst));
d1503 1
a1503 1
	strlcpy(req_ca_cert.name, certname, sizeof req_ca_cert.name);
d1607 1
a1607 1
		strlcat(buf, "SUCCESS,", sizeof(buf));
d1610 1
a1610 1
		strlcat(buf, "FAILURE,", sizeof(buf));
d1613 1
a1613 1
		strlcat(buf, "DELAY,", sizeof(buf));
d1616 1
a1616 1
		strlcat(buf, "NEVER,", sizeof(buf));
@


1.58
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1605 1
@


1.57
log
@if peer advertises DSN and we don't want to use it, make sure we don't send
trailing spaces, not every MTA can cope with that

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.56 2014/02/25 15:58:45 gilles Exp $	*/
d234 4
a237 1
		dns_query_ptr(s->id, s->route->dst->sa);
d258 1
a258 1
	case IMSG_QUEUE_MESSAGE_FD:
d272 1
a272 1
			mta_flush_task(s, IMSG_DELIVERY_TEMPFAIL,
d287 1
a287 1
			mta_flush_task(s, IMSG_DELIVERY_LOOP,
d296 1
a296 1
	case IMSG_DNS_PTR:
d316 1
a316 1
	case IMSG_LKA_SSL_INIT:
d357 1
a357 1
	case IMSG_LKA_SSL_VERIFY:
d377 1
a377 1
	case IMSG_LKA_HELO:
d494 1
a494 1
			m_create(p_lka, IMSG_LKA_HELO, 0, 0, -1);
d760 1
a760 1
		m_create(p_queue, IMSG_QUEUE_MESSAGE_FD, 0, 0, -1);
d969 1
a969 1
				delivery = IMSG_DELIVERY_PERMFAIL;
d971 1
a971 1
				delivery = IMSG_DELIVERY_TEMPFAIL;
d1000 1
a1000 1
				delivery = IMSG_DELIVERY_PERMFAIL;
d1002 1
a1002 1
				delivery = IMSG_DELIVERY_TEMPFAIL;
d1033 1
a1033 1
					mta_flush_task(s, IMSG_DELIVERY_TEMPFAIL,
d1043 1
a1043 1
				mta_flush_task(s, IMSG_DELIVERY_OK,
d1062 1
a1062 1
			delivery = IMSG_DELIVERY_PERMFAIL;
d1064 1
a1064 1
			delivery = IMSG_DELIVERY_TEMPFAIL;
d1072 1
a1072 1
			delivery = IMSG_DELIVERY_OK;
d1077 1
a1077 1
			delivery = IMSG_DELIVERY_PERMFAIL;
d1079 1
a1079 1
			delivery = IMSG_DELIVERY_TEMPFAIL;
d1331 1
a1331 1
		mta_flush_task(s, IMSG_DELIVERY_TEMPFAIL,
d1444 1
a1444 1
		mta_flush_task(s, IMSG_DELIVERY_TEMPFAIL, error, 0, 0);
d1504 1
a1504 1
	m_compose(p_lka, IMSG_LKA_SSL_INIT, 0, 0, -1,
d1555 1
a1555 1
	m_composev(p_lka, IMSG_LKA_SSL_VERIFY_CERT, 0, 0, -1,
d1571 1
a1571 1
			m_composev(p_lka, IMSG_LKA_SSL_VERIFY_CHAIN, 0, 0, -1,
d1580 1
a1580 1
	m_compose(p_lka, IMSG_LKA_SSL_VERIFY, 0, 0, -1,
@


1.56
log
@if a specific pattern of failures/success happen, we can end up not
reinitializing curevp correctly for next transaction leading to a
possible crash.

diff by eric@@, ok by me
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.55 2014/02/24 18:06:12 eric Exp $	*/
d774 1
a774 1
			mta_send(s, "MAIL FROM:<%s> %s%s %s%s",
d776 1
a776 1
			    e->dsn_ret ? "RET=" : "",
d778 1
a778 1
			    envid_sz ? "ENVID=" : "",
d790 1
a790 1
			mta_send(s, "RCPT TO:<%s> %s%s %s%s",
d792 1
a792 1
			    e->dsn_notify ? "NOTIFY=" : "",
d794 1
a794 1
			    e->dsn_orcpt ? "ORCPT=" : "",
@


1.55
log
@fix off by one leading to invalid host stats tree
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d767 1
a767 2
		if (s->currevp == NULL)
			s->currevp = TAILQ_FIRST(&s->task->envelopes);
@


1.54
log
@Add support for DSN and Enhanced Status Code
@
text
@d1026 1
a1026 1
				mta_hoststat_update(domain + 1, e->status);
d1386 2
a1387 1
			mta_hoststat_update(domain + 1, error);
d1389 1
a1389 1
				mta_hoststat_cache(domain + 1, e->id);
@


1.53
log
@internal improvements and cleanups

- get rid of the whole penalty thing for failed envelopes in the mta and scheduler.
- do not disable routes on smtp errors
- try to schedule all types of envelopes on each scheduler frame.
@
text
@d149 2
d581 2
d767 4
d773 10
a782 1
		mta_send(s, "MAIL FROM:<%s>", s->task->sender);
d788 12
a799 1
		mta_send(s, "RCPT TO:<%s>", s->currevp->dest);
d1210 2
d1367 1
d1581 39
@


1.52
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.51 2014/02/04 09:50:31 eric Exp $	*/
a99 1

d128 1
a128 3
#define	MAX_FAILED_ENVELOPES	15
	struct mta_envelope	*failed[MAX_FAILED_ENVELOPES];
	int			 failedcount;
d149 1
a149 1
static void mta_flush_failedqueue(struct mta_session *);
d333 1
a333 4
		resp_ca_cert = xmemdup(imsg->data, sizeof *resp_ca_cert,
		    "mta:ca_cert");
		if (resp_ca_cert == NULL)
			fatal(NULL);
a431 2
	mta_flush_failedqueue(s);

d960 1
a960 1
			mta_flush_failedqueue(s);
d973 1
d997 3
a999 3
			/* push failed envelope to the session fail queue */
			s->failed[s->failedcount] = e;
			s->failedcount++;
d1001 7
a1007 14
			/*
			 * if session fail queue is full:
			 * - flush failed queue (failure w/ penalty)
			 * - flush remaining tasks with TempFail
			 * - mark route down
			 */
			if (s->failedcount == MAX_FAILED_ENVELOPES) {
				mta_flush_failedqueue(s);
				mta_flush_task(s, IMSG_DELIVERY_TEMPFAIL,
				    "Host temporarily disabled", 0, 1);
				mta_route_down(s->relay, s->route);
				mta_enter_state(s, MTA_QUIT);
				break;
			}
a1026 1
		mta_flush_failedqueue(s);
a1070 1
		mta_flush_failedqueue(s);
d1351 1
a1351 1
		mta_delivery_notify(e, 0);
a1377 22
mta_flush_failedqueue(struct mta_session *s)
{
	int			 i;
	struct mta_envelope	*e;
	const char		*domain;
	uint32_t		 penalty;

	penalty = s->failedcount == MAX_FAILED_ENVELOPES ? 1 : 0;
	for (i = 0; i < s->failedcount; ++i) {
		e = s->failed[i];

		domain = strchr(e->dest, '@@');
		if (domain)
			mta_hoststat_update(domain + 1, e->status);

		mta_delivery_notify(e, penalty);
	}

	s->failedcount = 0;
}

static void
a1550 1

@


1.51
log
@add base64_encode/base64_decode helpers
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.50 2013/12/26 17:25:32 eric Exp $	*/
d198 1
a198 1
	if (relay->cert)
d321 1
a321 1
			if (s->relay->cert) {
d1501 2
a1502 2
	if (s->relay->cert)
		certname = s->relay->cert;
d1543 2
a1544 2
	if (s->relay->cert)
		pkiname = s->relay->cert;
@


1.50
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.49 2013/12/03 09:06:26 eric Exp $	*/
d680 2
a681 1
		if (__b64_pton(s->relay->secret, (unsigned char *)ibuf, sizeof(ibuf)-1) == -1) {
d688 1
a688 1
		__b64_ntop((unsigned char *)ibuf + 1, strlen(ibuf + 1), obuf, sizeof obuf);
d697 2
a698 1
		if (__b64_pton(s->relay->secret, (unsigned char *)ibuf, sizeof(ibuf)-1) == -1) {
d706 1
a706 1
		__b64_ntop((unsigned char *)ibuf + offset, strlen(ibuf + offset), obuf, sizeof obuf);
@


1.49
log
@Rework the envelope flushing loops in mta to avoid sending all delivery
notifications in one go to the queue. Simplify code in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d351 2
a352 2
		bzero(resp_ca_cert->cert, resp_ca_cert->cert_len);
		bzero(resp_ca_cert->key, resp_ca_cert->key_len);
d679 1
a679 1
		bzero(ibuf, sizeof ibuf);
d686 1
a686 1
		bzero(obuf, sizeof obuf);
d690 2
a691 2
		bzero(ibuf, sizeof ibuf);
		bzero(obuf, sizeof obuf);
d695 1
a695 1
		bzero(ibuf, sizeof ibuf);
d703 1
a703 1
		bzero(obuf, sizeof obuf);
d707 2
a708 2
		bzero(ibuf, sizeof ibuf);
		bzero(obuf, sizeof obuf);
d1540 1
a1540 1
	bzero(&req_ca_vrfy, sizeof req_ca_vrfy);
d1565 1
a1565 1
			bzero(&req_ca_vrfy, sizeof req_ca_vrfy);
d1580 1
a1580 1
	bzero(&req_ca_vrfy, sizeof req_ca_vrfy);
@


1.48
log
@unsigned char casts for ctype
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.47 2013/11/18 12:24:26 eric Exp $	*/
a100 6
struct failed_evp {
	int			 delivery;
	char			 error[SMTPD_MAXLINESIZE];
	struct mta_envelope     *evp;
};

d130 1
a130 1
	struct failed_evp	 failed[MAX_FAILED_ENVELOPES];
a838 1
	struct failed_evp	*fevp;
d1003 1
a1003 5
			e->delivery = delivery;
			fevp = &s->failed[s->failedcount];
			fevp->delivery = delivery;
			fevp->evp = e;
			strlcpy(fevp->error, line, sizeof fevp->error);
d1360 1
a1360 1
			mta_delivery(e, NULL, relay, delivery, error, 0);
d1362 4
a1365 2
			mta_delivery(e, sa_to_text(sa),
			    relay, delivery, error, 0);
a1373 3
		free(e->dest);
		free(e->rcpt);
		free(e);
a1394 1
	struct failed_evp	*fevp;
d1401 1
a1401 3
		fevp = &s->failed[i];
		e = fevp->evp;
		mta_delivery_notify(e, fevp->delivery, fevp->error, penalty);
d1405 1
a1405 1
			mta_hoststat_update(domain + 1, fevp->error);
d1407 1
a1407 3
		free(e->dest);
		free(e->rcpt);
		free(e);
d1409 1
@


1.47
log
@Allow overriding the local ca
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1487 1
a1487 1
		if (strchr(buf, ':') == NULL && !isspace((int)*buf))
@


1.46
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d1537 1
d1557 8
@


1.45
log
@add missing heloname field for relayhost.
differenciate relays with different helotable/heloname.
improve code a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.44 2013/10/28 17:02:08 eric Exp $	*/
d327 13
a339 4
			log_info("smtp-out: Disconnecting session %016"PRIx64
			    ": CA failure", s->id);
			mta_free(s);
			return;
d372 6
d1513 6
a1518 1
	void		       *ssl;
d1520 7
a1526 14
	if (s->relay->cert) {
		req_ca_cert.reqid = s->id;
		strlcpy(req_ca_cert.name, s->relay->cert,
		    sizeof req_ca_cert.name);
		m_compose(p_lka, IMSG_LKA_SSL_INIT, 0, 0, -1,
		    &req_ca_cert, sizeof(req_ca_cert));
		tree_xset(&wait_ssl_init, s->id, s);
		s->flags |= MTA_WAIT;
		return;
	}
	ssl = ssl_mta_init(NULL, 0, NULL, 0);
	if (ssl == NULL)
		fatal("mta: ssl_mta_init");
	io_start_tls(&s->io, ssl);
@


1.44
log
@Report the ssl certificate verification status in the mail header.
Log ssl certificate validation errors.
Fix several ssl-related leaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.43 2013/10/27 20:39:44 eric Exp $	*/
d497 1
a497 1
		if (s->relay->heloname)
@


1.43
log
@Add support for AUTH LOGIN in mta.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.42 2013/10/26 12:27:59 eric Exp $	*/
d333 2
a334 1
		resp_ca_cert = xmemdup(imsg->data, sizeof *resp_ca_cert, "mta:ca_cert");
a338 1

a341 1

a352 1

d1108 1
d1139 2
a1140 1
		if (SSL_get_peer_certificate(s->io.ssl))
d1145 2
d1554 1
@


1.42
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.41 2013/10/25 14:21:06 deraadt Exp $	*/
d37 1
d61 4
d95 5
a99 2
#define MTA_EXT_AUTH		0x02
#define MTA_EXT_PIPELINING	0x04
d582 3
d635 18
a652 2
		if (s->relay->secret && s->flags & MTA_TLS)
			mta_send(s, "AUTH PLAIN %s", s->relay->secret);
d663 41
d900 28
a927 1
	case MTA_AUTH:
d1106 1
a1106 1
	char			*line, *msg;
d1179 9
a1187 2
			else if (strncmp(msg, "AUTH", 4) == 0)
				s->ext |= MTA_EXT_AUTH;
d1592 4
@


1.41
log
@obvious time_t mishandling.  Sigh.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.40 2013/07/22 13:11:11 eric Exp $	*/
d547 1
a547 1
	log_info("smtp-out: Connecting to %s%s:%i (%s) on session"
d973 1
a973 1
				log_debug("debug: mta: waiting for %llis before next transaction",
d990 1
a990 1
			log_debug("debug: mta: waiting for %llis after reset",
@


1.40
log
@fix sockaddr overflow with IPv6
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d671 3
a673 2
			log_debug("mta: debug: last connection: hanging on for %is",
			    s->relay->limits->sessdelay_keepalive - s->hangon);
@


1.39
log
@Many MTA improvements:

- Better transient error handling logic: failing destinations are
  automatically disabled for a while.  When a destination is active
  again, ask the scheduler to retry previous envelopes immediatly.
- More informative error report when all routes fail for a mail.
- Implement a "smtpctl show hoststats" command to get the latest stat
  message per MX domain.
- Implement a "smtpctl show routes" command to show the state the
  currently known routes to remote MXs.
- Implement a "smtpctl resume route" command to re-enable a route that
  has been disabled.
- Do not hardcode limits
- Minor code improvements
@
text
@d764 2
a765 1
	struct sockaddr		 sa;
d892 3
a894 2
			sa_len = sizeof sa;
			if (getsockname(s->io.sock, &sa, &sa_len) < 0)
d897 1
a897 1
				mta_delivery_log(e, sa_to_text(&sa),
d1224 2
a1225 1
	struct sockaddr		 sa;
d1248 3
a1250 2
		sa_len = sizeof sa;
		if (getsockname(s->io.sock, &sa, &sa_len) < 0)
d1253 1
a1253 1
			mta_delivery(e, sa_to_text(&sa),
@


1.38
log
@get rid of sa_set_port() and its awfully contorted implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.37 2013/06/03 16:04:03 eric Exp $	*/
d48 1
a48 1
#define MAX_MAIL	100
d50 1
a50 1
#define MTA_HIWAT	65535
d87 1
d93 5
d117 4
a120 2
	int			 msgcount;
	int			 rcptcount;
d126 4
d137 1
d140 1
a140 1
static void mta_flush_task(struct mta_session *, int, const char *, size_t);
d150 5
d162 2
d175 1
d269 1
a269 1
			    "Could not get message fd", 0);
d284 1
a284 1
			    "Loop detected", 0);
d319 1
a319 1
			log_info("smtp-out: Disconnecting session %016" PRIx64
d415 10
d443 14
d517 2
a518 1
		goto fail;
a566 6
	return;

fail:
	mta_error(s, "Could not connect");
	mta_free(s);
	return;
d640 1
d644 9
a652 1
		if (s->msgcount >= MAX_MAIL) {
d664 11
a674 1
			mta_enter_state(s, MTA_QUIT);
d693 2
d763 4
a768 2
	struct sockaddr		 sa;
	socklen_t		 sa_len;
d845 1
a845 1
			mta_flush_task(s, delivery, line, 0);
d854 7
d862 10
a871 1
		if (line[0] != '2') {
d877 1
d879 3
a884 1
			/* we're about to log, associate session to envelope */
a885 1

d893 1
a893 1
				mta_delivery(e, NULL, buf, delivery, line);
d895 1
a895 1
				mta_delivery(e, sa_to_text(&sa),
a896 4
			free(e->dest);
			free(e->rcpt);
			free(e);
			stat_decrement("mta.envelope", 1);
d898 26
d926 1
a926 1
				    "No envelope", 0);
d931 1
d939 1
d948 1
a948 1
		mta_flush_task(s, delivery, line, 0);
d956 1
d963 1
a963 1
		mta_flush_task(s, delivery, line, (s->flags & MTA_LMTP) ? 1 : 0 );
d969 11
a979 1
			mta_enter_state(s, MTA_READY);
d984 13
a996 1
		mta_enter_state(s, MTA_READY);
d1092 1
a1092 1
			    ": %i message%s sent.", s->id, s->msgcount,
d1203 1
a1203 1
		    "Error reading content file", 0);
d1216 2
a1217 1
mta_flush_task(struct mta_session *s, int delivery, const char *error, size_t count)
d1224 1
a1226 1

d1247 1
a1247 1
			mta_delivery(e, NULL, relay, delivery, error);
d1250 8
a1257 1
			    relay, delivery, error);
d1280 26
d1319 1
a1319 1
		    " after %i message%s sent: %s", s->id, s->msgcount,
d1338 1
a1338 1
		mta_flush_task(s, IMSG_DELIVERY_TEMPFAIL, error, 0);
d1471 1
@


1.37
log
@plug a couple of memleaks
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d482 5
a486 1
	sa_set_port(sa, portno);
@


1.36
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.34 2013/02/21 16:25:21 eric Exp $	*/
d322 2
@


1.35
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@a24 1
#include <sys/param.h>
a236 2
		if (imsg->fd == -1)
			fatalx("mta: cannot obtain msgfd");
d240 11
a250 1
			close(imsg->fd);
d435 1
a435 1
			m_create(p_lka, IMSG_LKA_HELO, 0, 0, -1, 64);
d618 1
a618 1
		m_create(p_queue, IMSG_QUEUE_MESSAGE_FD, 0, 0, -1, 18);
d654 4
d698 2
d795 15
a809 1
			mta_delivery(e, buf, delivery, line);
a877 1
	const char		*schema;
a884 9
		if (s->use_smtp_tls)
			schema = "smtp+tls://";
		else if (s->use_starttls)
			schema = "tls://";
		else if (s->use_smtps)
			schema = "smtps://";
		else
			schema = "smtp://";

d1087 2
d1101 16
a1116 1
		mta_delivery(e, relay, delivery, error);
@


1.34
log
@Fix a potential crash when connecting to a misbehaving smtp server.
If a smtp session got bogus data from a remote server and has just
issued an internal query, then defer the deletion of that session
until it gets the reply.

ok gilles@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.33 2013/02/15 22:43:21 eric Exp $	*/
d685 1
a685 1
	char			 buf[MAX_LINE_SIZE];
d909 1
a909 1
			if (iobuf_len(&s->iobuf) >= SMTP_LINE_MAX) {
d1068 1
a1068 1
	char			 relay[MAX_LINE_SIZE];
@


1.33
log
@add missing bits for lmtp support (from Ashish SHUKLA).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.32 2013/02/05 10:53:57 nicm Exp $	*/
a85 1

d87 1
d137 1
d215 1
d241 6
a246 1
		s = tree_xpop(&wait_fd, reqid);
d273 4
a276 1
		s = tree_xpop(&wait_ptr, reqid);
d286 3
a288 1
		s = tree_xpop(&wait_ssl_init, resp_ca_cert->reqid);
d321 3
a323 1
		s = tree_xpop(&wait_ssl_verify, resp_ca_vrfy->reqid);
d341 3
a343 1
		s = tree_xpop(&wait_helo, reqid);
d361 16
d434 1
d617 1
d958 4
a961 1
			mta_free(s);
d1196 1
d1228 1
@


1.32
log
@Spelling fixes: retreive -> retrieve. ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.31 2013/01/31 18:34:43 eric Exp $	*/
d58 1
d67 1
d87 1
d113 1
d128 1
a128 1
static void mta_flush_task(struct mta_session *, int, const char *);
d177 2
d249 1
a249 1
			    "Loop detected");
d450 2
d516 5
d587 1
a587 1
		mta_send(s, "MAIL FROM: <%s>", s->task->sender);
d593 2
a594 1
		mta_send(s, "RCPT TO: <%s>", s->currevp->dest);
d621 5
d657 4
a660 1
		mta_enter_state(s, MTA_EHLO);
d690 9
d729 1
a729 1
			mta_flush_task(s, delivery, line);
d756 1
a756 1
				    "No envelope");
d776 1
a776 1
		mta_flush_task(s, delivery, line);
d780 1
d790 8
a797 2
		mta_flush_task(s, delivery, line);
		mta_enter_state(s, MTA_READY);
a911 1

d1015 1
a1015 1
		    "Error reading content file");
d1028 1
a1028 1
mta_flush_task(struct mta_session *s, int delivery, const char *error)
d1038 6
d1099 1
a1099 1
		mta_flush_task(s, IMSG_DELIVERY_TEMPFAIL, error);
d1249 1
@


1.31
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.27 2013/01/26 09:37:23 gilles Exp $	*/
d328 1
a328 1
			    "Failed to retreive helo string");
@


1.30
log
@use a stripped-down mta_envelope structure in the mta process.
reduces memory footprint by a great deal when relaying lots of messages.

ok gilles@@
@
text
@a1029 8
	/*
	 * If not connected yet, and the error is not local, just ignore it
	 * and try to reconnect.
	 */
	if (s->state == MTA_INIT && 
	    (errno == ETIMEDOUT || errno == ECONNREFUSED))
		return;

d1042 10
@


1.29
log
@fix possible descriptor leak in mta_session when reusing session for many
messages
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.28 2013/01/28 11:09:53 gilles Exp $	*/
d113 1
a113 1
	struct envelope		*currevp;
d574 1
a574 5
		if (s->task->sender.user[0] && s->task->sender.domain[0])
			mta_send(s, "MAIL FROM: <%s@@%s>",
			    s->task->sender.user, s->task->sender.domain);
		else
			mta_send(s, "MAIL FROM: <>");
d580 1
a580 3
		mta_send(s, "RCPT TO: <%s@@%s>",
		    s->currevp->dest.user,
		    s->currevp->dest.domain);
d631 3
a633 3
	struct envelope	*evp;
	char		 buf[MAX_LINE_SIZE];
	int		 delivery;
d706 1
a706 1
		evp = s->currevp;
d714 1
a714 1
			TAILQ_REMOVE(&s->task->envelopes, evp, entry);
d717 4
a720 2
			mta_delivery(evp, buf, delivery, line);
			free(evp);
d993 3
a995 3
	struct envelope	*e;
	char		 relay[MAX_LINE_SIZE];
	size_t		 n;
d1003 2
d1009 1
@


1.28
log
@- introduce 'smtpctl trace lookup' to trace lookup process
- improve logging of the transfer process

trace by me, logging by eric
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.27 2013/01/26 09:37:23 gilles Exp $	*/
d1013 5
@


1.27
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.26 2012/11/12 14:58:53 eric Exp $	*/
d446 4
a449 2
	log_debug("debug: mta: %p: connecting to %s%s:%i (%s)",
	    s, schema, sa_to_text(sa), portno, s->route->dst->ptrname);
d799 2
a800 2
		log_debug("debug: mta: %p: connected to %s%s (%s)",
		    s, schema, sa_to_text(s->route->dst->sa), s->route->dst->ptrname);
d872 3
d1039 9
a1047 1
	mta_route_error(s->relay, s->route, error);
@


1.26
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.24 2012/10/11 21:24:51 gilles Exp $	*/
d5 1
a5 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d27 1
d36 1
d47 3
d55 8
a62 1
	MTA_SECRET,
d64 4
a67 16
	MTA_MX,
	MTA_CONNECT,
	MTA_DONE,
	MTA_SMTP_READY,
	MTA_SMTP_BANNER,
	MTA_SMTP_EHLO,
	MTA_SMTP_HELO,
	MTA_SMTP_STARTTLS,
	MTA_SMTP_AUTH,
	MTA_SMTP_MAIL,
	MTA_SMTP_RCPT,
	MTA_SMTP_DATA,
	MTA_SMTP_QUIT,
	MTA_SMTP_BODY,
	MTA_SMTP_DONE,
	MTA_SMTP_RSET,
d70 15
a84 7
#define MTA_FORCE_ANYSSL	0x01
#define MTA_FORCE_SMTPS		0x02
#define MTA_ALLOW_PLAIN		0x04
#define MTA_USE_AUTH		0x08
#define MTA_FORCE_MX		0x10
#define MTA_USE_CERT		0x20
#define MTA_TLS			0x40
a89 6
struct mta_host {
	TAILQ_ENTRY(mta_host)	 entry;
	struct sockaddr_storage	 sa;
	char			 fqdn[MAXHOSTNAMELEN];
	int			 used;
};
d93 1
d95 1
a96 1
	char			*secret;
d98 5
d105 4
d110 1
a111 1
	TAILQ_HEAD(, mta_host)	 hosts;
d113 1
a114 5
	struct envelope		*currevp;
	struct iobuf		 iobuf;
	struct io		 io;
	int			 ext;
	struct ssl		*ssl;
d117 2
d120 3
d124 2
a125 2
static void mta_status(struct mta_session *, int, const char *, ...);
static void mta_envelope_done(struct mta_task *, struct envelope *, const char *);
d131 13
d145 9
a153 1
static struct tree sessions = SPLAY_INITIALIZER(&sessions);
d156 1
a156 1
mta_session(struct mta_route *route)
d158 2
a159 1
	struct mta_session	*session;
d161 20
a180 17
	session = xcalloc(1, sizeof *session, "mta_session");
	session->id = generate_uid();
	session->route = route;
	session->state = MTA_INIT;
	session->io.sock = -1;
	tree_xset(&sessions, session->id, session);
	TAILQ_INIT(&session->hosts);

	if (route->flags & ROUTE_MX)
		session->flags |= MTA_FORCE_MX;
	if (route->flags & ROUTE_SSL && route->flags & ROUTE_AUTH)
		session->flags |= MTA_USE_AUTH;
	if (route->cert)
		session->flags |= MTA_USE_CERT;
	switch (route->flags & ROUTE_SSL) {
		case ROUTE_SSL:
			session->flags |= MTA_FORCE_ANYSSL;
d182 3
a184 2
		case ROUTE_SMTPS:
			session->flags |= MTA_FORCE_SMTPS;
d186 2
a187 2
		case ROUTE_STARTTLS:
			/* STARTTLS is tried by default */
d190 1
a190 1
			session->flags |= MTA_ALLOW_PLAIN;
d193 2
a194 1
	log_debug("debug: mta: %p: spawned for %s", session, mta_route_to_text(route));
d196 13
a208 1
	mta_enter_state(session, MTA_INIT);
d212 1
a212 1
mta_session_imsg(struct imsgev *iev, struct imsg *imsg)
d214 2
a215 1
	uint64_t		 id;
d217 6
a222 5
	struct mta_host		*host;
	struct secret		*secret;
	struct dns		*dns;
	const char		*error;
	void			*ptr;
d224 1
a224 1
	switch(imsg->hdr.type) {
d227 3
a229 1
		id = *(uint64_t*)(imsg->data);
d232 2
a233 1
		s = tree_xget(&sessions, id);
d242 3
a244 2
			mta_status(s, 0, "646 Loop detected");
			mta_enter_state(s, MTA_SMTP_READY);
d246 1
a246 1
			mta_enter_state(s, MTA_SMTP_MAIL);
d251 15
a265 10
	case IMSG_LKA_SECRET:
		/* LKA responded to AUTH lookup. */
		secret = imsg->data;
		s = tree_xget(&sessions, secret->id);
		s->secret = xstrdup(secret->secret, "mta: secret");
		if (s->secret[0] == '\0') {
			mta_route_error(s->route, "secrets lookup failed");
			mta_enter_state(s, MTA_DONE);
		} else
			mta_enter_state(s, MTA_MX);
d268 31
a298 6
	case IMSG_DNS_HOST:
		dns = imsg->data;
		s = tree_xget(&sessions, dns->id);
		host = xcalloc(1, sizeof *host, "mta: host");
		host->sa = dns->ss;
		TAILQ_INSERT_TAIL(&s->hosts, host, entry);
d301 10
a310 20
	case IMSG_DNS_HOST_END:
		/* LKA responded to DNS lookup. */
		dns = imsg->data;
		s = tree_xget(&sessions, dns->id);
		if (!dns->error) {
			mta_enter_state(s, MTA_CONNECT);
			return;
		}
		if (dns->error == DNS_RETRY)
			error = "100 MX lookup failed temporarily";
		else if (dns->error == DNS_EINVAL)
			error = "600 Invalid domain name";
		else if (dns->error == DNS_ENONAME)
			error = "600 Domain does not exist";
		else if (dns->error == DNS_ENOTFOUND)
			error = "600 No MX address found for domain";
		else
			error = "100 Weird error";
		mta_route_error(s->route, error);
		mta_enter_state(s, MTA_CONNECT);
d313 13
a325 17
	case IMSG_DNS_PTR:
		dns = imsg->data;
		s = tree_xget(&sessions, dns->id);
		host = TAILQ_FIRST(&s->hosts);
		if (dns->error)
			strlcpy(host->fqdn, "<unknown>", sizeof host->fqdn);
		else
			strlcpy(host->fqdn, dns->host, sizeof host->fqdn);
		log_debug("debug: mta: %p: connected to %s", s, host->fqdn);

		/* check if we need to start tls now... */
		if (((s->flags & MTA_FORCE_ANYSSL) && host->used == 1) ||
		    (s->flags & MTA_FORCE_SMTPS)) {
			log_debug("debug: mta: %p: trying smtps (ssl=%p)...", s, s->ssl);
			if ((ptr = ssl_mta_init(s->ssl)) == NULL)
				fatalx("mta: ssl_mta_init");
			io_start_tls(&s->io, ptr);
d327 3
a329 1
			mta_enter_state(s, MTA_SMTP_BANNER);
d331 2
a332 1
		break;
d340 134
a476 5
	struct secret		 secret;
	struct mta_route	*route;
	struct mta_host		*host;
	struct sockaddr		*sa;
	int			 max_reuse;
d489 1
a489 1
#define mta_enter_state(_s, _st) do { newstate = _st; goto again; } while(0)
d493 1
a493 4
		if (s->route->auth)
			mta_enter_state(s, MTA_SECRET);
		else
			mta_enter_state(s, MTA_MX);
d496 3
a498 7
	case MTA_DATA:
		/*
		 * Obtain message body fd.
		 */
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_MESSAGE_FD, s->task->msgid, 0, -1,
		    &s->id, sizeof(s->id));
d501 3
a503 10
	case MTA_SECRET:
		/*
		 * Lookup AUTH secret.
		 */
		bzero(&secret, sizeof(secret));
		secret.id = s->id;
		strlcpy(secret.mapname, s->route->auth, sizeof(secret.mapname));
		strlcpy(secret.host, s->route->hostname, sizeof(secret.host));
		imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_SECRET,
		    0, 0, -1, &secret, sizeof(secret));  
d506 7
a512 30
	case MTA_MX:
		/*
		 * Lookup MX record.
		 */
		if (s->flags & MTA_FORCE_MX) /* XXX */
			dns_query_host(s->route->hostname, s->route->port, s->id);
		else
			dns_query_mx(s->route->hostname, s->route->backupname, 0, s->id);
		break;

	case MTA_CONNECT:
		/*
		 * Connect to the MX.
		 */
	
		/* cleanup previous connection if any */
		iobuf_clear(&s->iobuf);
		io_clear(&s->io);

		if (s->flags & MTA_FORCE_ANYSSL)
			max_reuse = 2;
		else
			max_reuse = 1;

		/* pick next mx */
		while ((host = TAILQ_FIRST(&s->hosts))) {
			if (host->used == max_reuse) {
				TAILQ_REMOVE(&s->hosts, host, entry);
				free(host);
				continue;
a513 12
			host->used++;

			log_debug("debug: mta: %p: connecting to %s...", s,
				ss_to_text(&host->sa));
			sa = (struct sockaddr *)&host->sa;

			if (s->route->port)
				sa_set_port(sa, s->route->port);
			else if ((s->flags & MTA_FORCE_ANYSSL) && host->used == 1)
				sa_set_port(sa, 465);
			else if (s->flags & MTA_FORCE_SMTPS)
				sa_set_port(sa, 465);
d515 2
a516 19
				sa_set_port(sa, 25);

			iobuf_xinit(&s->iobuf, 0, 0, "mta_enter_state");
			io_init(&s->io, -1, s, mta_io, &s->iobuf);
			io_set_timeout(&s->io, 10000);
			if (io_connect(&s->io, sa, NULL) == -1) {
				log_debug("debug: mta: %p: connection failed: %s", s,
				    strerror(errno));
				iobuf_clear(&s->iobuf);
				/*
				 * This error is most likely a "no route",
				 * so there is no need to try the same
				 * relay again.
				 */
				TAILQ_REMOVE(&s->hosts, host, entry);
				free(host);
				continue;
			}
			return;
a517 49
		/* tried them all? */
		mta_route_error(s->route, "150 Can not connect to MX");
		mta_enter_state(s, MTA_DONE);
		break;

	case MTA_DONE:
		/*
		 * Kill the mta session.
		 */
		log_debug("debug: mta: %p: session done", s);
		io_clear(&s->io);
		iobuf_clear(&s->iobuf);
		if (s->task)
			fatalx("current task should have been deleted already");
		if (s->datafp)
			fclose(s->datafp);
		s->datafp = NULL;
		while ((host = TAILQ_FIRST(&s->hosts))) {
			TAILQ_REMOVE(&s->hosts, host, entry);
			free(host);
		}
		route = s->route;
		tree_xpop(&sessions, s->id);
		free(s);
		stat_decrement("mta.session", 1);
		mta_route_collect(route);
		break;

	case MTA_SMTP_BANNER:
		/* just wait for banner */
		io_set_read(&s->io);
		break;

	case MTA_SMTP_EHLO:
		s->ext = 0;
		mta_send(s, "EHLO %s", env->sc_hostname);
		break;

	case MTA_SMTP_HELO:
		s->ext = 0;
		mta_send(s, "HELO %s", env->sc_hostname);
		break;

	case MTA_SMTP_STARTTLS:
		if (s->flags & MTA_TLS) /* already started */
			mta_enter_state(s, MTA_SMTP_AUTH);
		else if ((s->ext & MTA_EXT_STARTTLS) == 0)
			/* server doesn't support starttls, do not use it */
			mta_enter_state(s, MTA_SMTP_AUTH);
d522 8
a529 7
	case MTA_SMTP_AUTH:
		if (s->secret && s->flags & MTA_TLS)
			mta_send(s, "AUTH PLAIN %s", s->secret);
		else if (s->secret) {
			log_debug("debug: mta: %p: not using AUTH on non-TLS session",
			    s);
			mta_enter_state(s, MTA_CONNECT);
d531 1
a531 1
			mta_enter_state(s, MTA_SMTP_READY);
d535 2
a536 2
	case MTA_SMTP_READY:
		/* ready to send a new mail */
d539 9
a547 1
			mta_route_ok(s->route);
d549 7
a555 18
		if (s->msgcount >= s->route->maxmail) {
			log_debug("debug: mta: %p: cannot send more message to %s", s,
			    mta_route_to_text(s->route));
			mta_enter_state(s, MTA_SMTP_QUIT);
		} else if ((s->task = TAILQ_FIRST(&s->route->tasks))) {
			log_debug("debug: mta: %p: handling next task for %s", s,
			    mta_route_to_text(s->route));
			TAILQ_REMOVE(&s->route->tasks, s->task, entry);
			s->route->ntask -= 1;
			s->task->session = s;
			stat_decrement("mta.task", 1);
			stat_increment("mta.task.running", 1);
			mta_enter_state(s, MTA_DATA);
		} else {
			log_debug("debug: mta: %p: no pending task for %s", s,
			    mta_route_to_text(s->route));
			/* XXX stay open for a while? */
			mta_enter_state(s, MTA_SMTP_QUIT);
d557 12
d571 1
a571 1
	case MTA_SMTP_MAIL:
d579 1
a579 1
	case MTA_SMTP_RCPT:
d587 1
a587 1
	case MTA_SMTP_DATA:
d592 1
a592 1
	case MTA_SMTP_BODY:
d595 1
a595 1
			mta_enter_state(s, MTA_SMTP_DONE);
d600 1
a600 1
			mta_enter_state(s, MTA_DONE);
d607 1
a607 1
	case MTA_SMTP_DONE:
d611 6
a616 2
	case MTA_SMTP_QUIT:
		mta_send(s, "QUIT");
d619 2
a620 2
	case MTA_SMTP_RSET:
		mta_send(s, "RSET");
a634 1
	void		*ssl;
d636 2
d641 2
a642 2
	case MTA_SMTP_BANNER:
		mta_enter_state(s, MTA_SMTP_EHLO);
d645 1
a645 1
	case MTA_SMTP_EHLO:
d647 1
d649 3
a651 3
			    !(s->flags & MTA_ALLOW_PLAIN)) {
				mta_route_error(s->route, line);
				mta_enter_state(s, MTA_DONE);
d654 1
a654 1
			mta_enter_state(s, MTA_SMTP_HELO);
d657 4
a660 1
		mta_enter_state(s, MTA_SMTP_STARTTLS);
d663 1
a663 1
	case MTA_SMTP_HELO:
d665 2
a666 2
			mta_route_error(s->route, line);
			mta_enter_state(s, MTA_DONE);
d669 1
a669 1
		mta_enter_state(s, MTA_SMTP_READY);
d672 1
a672 1
	case MTA_SMTP_STARTTLS:
d674 2
a675 2
			if (s->flags & MTA_ALLOW_PLAIN) {
				mta_enter_state(s, MTA_SMTP_AUTH);
d678 3
a680 3
			/* stop here if ssl can't be used */
			mta_route_error(s->route, line);
			mta_enter_state(s, MTA_DONE);
d683 2
a684 4
		ssl = ssl_mta_init(s->ssl);
		if (ssl == NULL)
			fatal("mta: ssl_mta_init");
		io_start_tls(&s->io, ssl);
d687 1
a687 1
	case MTA_SMTP_AUTH:
d689 2
a690 2
			mta_route_error(s->route, line);
			mta_enter_state(s, MTA_DONE);
d693 1
a693 1
		mta_enter_state(s, MTA_SMTP_READY);
d696 1
a696 1
	case MTA_SMTP_MAIL:
d698 6
a703 2
			mta_status(s, 0, line);
			mta_enter_state(s, MTA_SMTP_RSET);
d706 1
a706 1
		mta_enter_state(s, MTA_SMTP_RCPT);
d709 1
a709 1
	case MTA_SMTP_RCPT:
d713 12
a724 1
			mta_envelope_done(s->task, evp, line);
d726 3
a728 4
				free(s->task);
				s->task = NULL;
				stat_decrement("mta.task.running", 1);
				mta_enter_state(s, MTA_SMTP_RSET);
d733 1
a733 1
			mta_enter_state(s, MTA_SMTP_DATA);
d735 1
a735 1
			mta_enter_state(s, MTA_SMTP_RCPT);
d738 4
a741 5
	case MTA_SMTP_DATA:
		if (line[0] != '2' && line[0] != '3') {
			mta_status(s, 0, line);
			mta_enter_state(s, MTA_SMTP_RSET);
			return;
d743 6
a748 1
		mta_enter_state(s, MTA_SMTP_BODY);
d751 3
a753 3
	case MTA_SMTP_DONE:
		mta_status(s, 0, line);
		if (line[0] == '2')
d755 7
a761 1
		mta_enter_state(s, MTA_SMTP_READY);
d764 2
a765 2
	case MTA_SMTP_RSET:
		mta_enter_state(s, MTA_SMTP_READY);
a778 1
	struct mta_host		*host;
d781 1
d783 2
a784 1
	log_trace(TRACE_IO, "mta: %p: %s %s", s, io_strevent(evt), io_strio(io));
d789 19
a807 4
		io_set_timeout(io, 300000);
		io_set_write(io);
		host = TAILQ_FIRST(&s->hosts);
		dns_query_ptr(&host->sa, s->id);
d811 2
d814 17
a830 2
		if (s->state == MTA_CONNECT) /* smtps */
			mta_enter_state(s, MTA_SMTP_BANNER);
d832 1
a832 1
			mta_enter_state(s, MTA_SMTP_EHLO);
d840 2
a841 2
				mta_status(s, 1, "150 Input too long");
				mta_enter_state(s, MTA_DONE);
d851 2
a852 2
			mta_status(s, 1, "150 Bad response: %s", error);
			mta_enter_state(s, MTA_DONE);
d857 1
a857 1
		if (s->state == MTA_SMTP_EHLO) {
d869 2
a870 2
		if (s->state == MTA_SMTP_QUIT) {
			mta_enter_state(s, MTA_DONE);
d876 6
a881 1
    		iobuf_normalize(&s->iobuf);
d885 2
a886 2
			mta_status(s, 1, "150 Remote sent too much data");
			mta_enter_state(s, MTA_DONE);
d891 7
a897 2
		if (s->state == MTA_SMTP_BODY)
			mta_enter_state(s, MTA_SMTP_BODY);
d905 5
a909 6
		if (!s->ready) {
			mta_enter_state(s, MTA_CONNECT);
			break;
		}
		mta_status(s, 1, "150 connection timeout");
		mta_enter_state(s, MTA_DONE);
d913 6
a918 7
		log_debug("debug: mta: %p: IO error: %s", s, strerror(errno));
		if (!s->ready) {
			mta_enter_state(s, MTA_CONNECT);
			break;
		}
		mta_status(s, 1, "150 IO error");
		mta_enter_state(s, MTA_DONE);
d922 7
a928 7
		log_debug("debug: mta: %p: disconnected in state %s", s, mta_strstate(s->state));
		if (!s->ready) {
			mta_enter_state(s, MTA_CONNECT);
			break;
		}
		mta_status(s, 1, "150 connection closed unexpectedly");
		mta_enter_state(s, MTA_DONE);
d976 2
a977 1
		mta_status(s, 1, "460 Error reading content file");
d990 1
a990 1
mta_status(struct mta_session *s, int connerr, const char *fmt, ...)
d992 12
a1003 15
	struct envelope		*e;
	char			*status;
	va_list			 ap;

	va_start(ap, fmt);
	if (vasprintf(&status, fmt, ap) == -1)
		fatal("vasprintf");
	va_end(ap);

	if (s->task) {
		while((e = TAILQ_FIRST(&s->task->envelopes)))
			mta_envelope_done(s->task, e, status);
		free(s->task);
		s->task = NULL;
		stat_decrement("mta.task.running", 1);
d1006 2
a1007 2
	if (connerr)
		mta_route_error(s->route, status);
d1009 3
a1011 1
	free(status);
d1015 1
a1015 1
mta_envelope_done(struct mta_task *task, struct envelope *e, const char *status)
d1017 3
a1019 2
	struct	mta_host *host = TAILQ_FIRST(&task->session->hosts);
	char		  relay[MAX_LINE_SIZE], stat[MAX_LINE_SIZE];
d1021 7
a1027 1
	envelope_set_errormsg(e, "%s", status);
d1029 4
a1032 7
	snprintf(relay, sizeof relay, "relay=%s [%s], ",
	    host->fqdn, ss_to_text(&host->sa));
	snprintf(stat, sizeof stat, "%s (%s)",
	    mta_response_status(e->errorline),
	    mta_response_text(e->errorline));

	log_envelope(e, relay, mta_response_prefix(e->errorline), stat);
d1034 1
a1034 2
	imsg_compose_event(env->sc_ievs[PROC_QUEUE],
	    mta_response_delivery(e->errorline), 0, 0, -1, e, sizeof(*e));
d1036 2
a1037 4
	TAILQ_REMOVE(&task->envelopes, e, entry);
	free(e);
	stat_decrement("mta.envelope", 1);
}
d1039 1
a1039 28
#define CASE(x) case x : return #x

static const char *
mta_strstate(int state)
{
	switch (state) {
	CASE(MTA_INIT);
	CASE(MTA_SECRET);
	CASE(MTA_DATA);
	CASE(MTA_MX);
	CASE(MTA_CONNECT);
	CASE(MTA_DONE);
	CASE(MTA_SMTP_READY);
	CASE(MTA_SMTP_BANNER);  
	CASE(MTA_SMTP_EHLO);
	CASE(MTA_SMTP_HELO);
	CASE(MTA_SMTP_STARTTLS);
	CASE(MTA_SMTP_AUTH);
	CASE(MTA_SMTP_MAIL);
	CASE(MTA_SMTP_RCPT);
	CASE(MTA_SMTP_DATA);
	CASE(MTA_SMTP_QUIT);
	CASE(MTA_SMTP_BODY);
	CASE(MTA_SMTP_DONE);
	CASE(MTA_SMTP_RSET);
	default:
		return "MTA_???";
	}
d1082 110
@


1.25
log
@Remove the "is_reading" hack and simplify the read/write logic:
set to write as soon as a response is read.

ok gilles@@
@
text
@d154 1
a154 1
	log_debug("mta: %p: spawned for %s", session, mta_route_to_text(route));
d182 1
a182 1
			log_debug("mta: loop detected");
d243 1
a243 1
		log_debug("mta: %p: connected to %s", s, host->fqdn);
d248 1
a248 1
			log_debug("mta: %p: trying smtps (ssl=%p)...", s, s->ssl);
d347 1
a347 1
			log_debug("mta: %p: connecting to %s...", s,
d364 1
a364 1
				log_debug("mta: %p: connection failed: %s", s,
d387 1
a387 1
		log_debug("mta: %p: session done", s);
d435 1
a435 1
			log_debug("mta: %p: not using AUTH on non-TLS session",
d450 1
a450 1
			log_debug("mta: %p: cannot send more message to %s", s,
d454 1
a454 1
			log_debug("mta: %p: handling next task for %s", s,
d463 1
a463 1
			log_debug("mta: %p: no pending task for %s", s,
d714 1
a714 1
			log_debug("mta: remaining data in input buffer");
d729 1
a729 1
		log_debug("mta: %p: connection timeout", s);
d739 1
a739 1
		log_debug("mta: %p: IO error: %s", s, strerror(errno));
d749 1
a749 1
		log_debug("mta: %p: disconnected in state %s", s, mta_strstate(s->state));
d854 2
a855 1
	log_envelope(e, relay, stat);
@


1.24
log
@- ssize_t -> size_t

spotted with clang, ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.23 2012/10/10 19:38:04 eric Exp $	*/
a104 1
	int			 is_reading; /* XXX remove this later */
d190 1
a407 1
		s->is_reading = 1;
a575 2
		s->is_reading = 0;
		io_set_write(&s->io);
a655 1
		s->is_reading = 0;
d709 1
d711 1
d713 5
a717 1
		iobuf_normalize(&s->iobuf);
d724 1
a724 2
		if (iobuf_queued(&s->iobuf) == 0) {
			s->is_reading = 1;
a725 1
		}
a779 5

	if (s->is_reading) {
		s->is_reading = 0;
		io_set_write(&s->io);
	}
a809 5
	}

	if (s->is_reading) {
		s->is_reading = 0;
		io_set_write(&s->io);
@


1.23
log
@io_connect() can take an optional address to bind() before connecting.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.22 2012/10/07 15:46:38 chl Exp $	*/
d649 1
a649 1
	ssize_t			 len;
@


1.22
log
@convert iobuf_queue()'s to iobuf_fqueue(). (idea from gilles@@)
introduce iobuf_xinit() and iobuf_xfqueue(). (idea from eric@@)

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.21 2012/10/03 16:43:19 chl Exp $	*/
d363 1
a363 1
			if (io_connect(&s->io, sa) == -1) {
@


1.21
log
@don't try to cope with iobuf_init() failure, make it fatal() instead.

from eric@@ input

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.20 2012/10/02 12:37:38 chl Exp $	*/
d360 1
a360 2
			if (iobuf_init(&s->iobuf, 0, 0) == -1)
				fatal("iobuf_init");
d777 1
a777 1
	iobuf_fqueue(&s->iobuf, "%s\r\n", p);
d802 3
a804 5
			len--;
		if (*ln == '.')
			iobuf_queue(&s->iobuf, ".", 1);
		iobuf_queue(&s->iobuf, ln, len);
		iobuf_queue(&s->iobuf, "\r\n", 2);
@


1.20
log
@check iobuf_init() return value.

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.19 2012/09/30 17:25:09 chl Exp $	*/
d360 2
a361 6
			if (iobuf_init(&s->iobuf, 0, 0) == -1) {
				log_debug("mta: %p: iobuf_init()", s);
				TAILQ_REMOVE(&s->hosts, host, entry);
				free(host);
				continue;
			}
@


1.19
log
@use xmalloc(), xcalloc() and xmemdup() helpers

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.18 2012/09/27 19:43:29 eric Exp $	*/
d360 6
a365 1
			iobuf_init(&s->iobuf, 0, 0);
@


1.18
log
@fatal -> fatalx
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.17 2012/09/21 12:33:32 eric Exp $	*/
d920 1
a920 2
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
@


1.17
log
@Add a log_envelope() function that log envelope status in a uniform way.
It automagically adds an rcpt=<user@@domain> field if "dest" differs from
the original "rcpt". The function takes an "extra" parameter that allows
to add some specific info depending on the context.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.16 2012/09/11 16:24:28 eric Exp $	*/
d520 1
a520 1
		fatal("mta_enter_state: unknown state");
d640 1
a640 1
		fatal("mta_response() bad state");
d759 1
a759 1
		fatal("mta_io()");
@


1.16
log
@Initialize fd correctly.  This fixes a lot of problems.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.15 2012/09/11 15:05:49 eric Exp $	*/
d856 2
a857 1
	struct	mta_host	*host = TAILQ_FIRST(&task->session->hosts);
d861 3
a863 6
	log_info("%016" PRIx64 ": to=<%s@@%s>, delay=%s, relay=%s [%s], stat=%s (%s)",
	    e->id, e->dest.user,
	    e->dest.domain,
	    duration_to_text(time(NULL) - e->creation),
	    host->fqdn,
	    ss_to_text(&host->sa),
d866 1
@


1.15
log
@remove the session entry from the search tree when it's dead.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.14 2012/08/30 18:16:25 eric Exp $	*/
d131 1
@


1.14
log
@- correctly free the task if all rcpt where rejected
- fix refcounting
- add some stat counters

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.13 2012/08/21 20:19:46 eric Exp $	*/
d399 1
@


1.13
log
@Allow smtpd to work as a backup MX, relaying only to MXs with higher
priority in the DNS record. For example:

   accept for domain "foo.org" relay backup "mx3.foo.org"

will relay mails for "foo.org" using only hosts with higher priority
(i.e. lower value) than "mx3.foo.org", which is supposed to be the
current server.

If the specified backup MX is not found in the DNS record, relaying
works as normal.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.12 2012/08/21 20:07:07 eric Exp $	*/
d155 1
a155 1

d400 1
d458 2
d604 3
d842 1
a870 1

d872 1
@


1.12
log
@Try to connect to the next host if an IO error occurs before the mta
is ready to send a mail.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.11 2012/08/21 13:13:17 eric Exp $	*/
d320 1
a320 1
			dns_query_mx(s->route->hostname, 0, s->id);
@


1.11
log
@Re-enable loop detection, but in mta and mda this time.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.10 2012/08/18 20:52:36 eric Exp $	*/
a93 1

d95 1
d327 4
a330 5
		if (oldstate == MTA_CONNECT) {
			/* previous connection failed. clean it up */
			iobuf_clear(&s->iobuf);
			io_clear(&s->io);
		}
a436 1
			mta_route_ok(s->route);
d443 4
a554 1
		mta_route_ok(s->route);
a582 1
		mta_route_ok(s->route);
d722 1
a722 2
		if (s->state == MTA_CONNECT) {
			/* try the next MX */
d732 1
a732 1
		if (s->state == MTA_CONNECT) {
d742 1
a742 1
		if (s->state == MTA_CONNECT) {
@


1.10
log
@zap struct mta_batch. Only pass ids where needed.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.9 2012/08/18 15:45:12 eric Exp $	*/
d105 1
d118 1
d162 1
a162 1
	uint64_t		 batch_id;
d173 1
a173 1
		batch_id = *(uint64_t*)(imsg->data);
d176 1
a176 1
		s = tree_xget(&sessions, batch_id);
d180 10
a189 1
		mta_enter_state(s, MTA_SMTP_MAIL);
d406 1
a469 1
		io_set_write(&s->io);
d571 1
d651 1
a707 2
		if (iobuf_queued(&s->iobuf))
			io_set_write(io);
d714 2
a715 1
		if (iobuf_queued(&s->iobuf) == 0)
d717 1
d773 5
d812 5
d897 43
@


1.9
log
@Major update of the mta internals.

Add a mta_route structure which describes a route through which
outgoing mails are to be sent.  This structure holds connection
parameters and limits.  When an envelope is received in a batch,
the route for it is looked up, and the envelope is added to the
a list of envelope to be sent for this message on that route: a
task.  When the batch is closed, each task is added to the list
of tasks for their respective route.

The routes are drained when new work can happen. The route will
create new mta sessions if necessary.  When a session is up and
ready, it picks the first pending task on the route if any.  In
the other case, it just closes the connection.

Errors on the connection are reported to the route, so that the
route could be flagged as broken.  Currently, three errors on a
an attempt to open a route is reported as a failure for all pen-
ding tasks.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.8 2012/08/10 11:05:55 eric Exp $	*/
d160 1
a160 1
	struct mta_batch	*batch;
d171 1
a171 1
		batch = imsg->data;
d174 1
a174 1
		s = tree_xget(&sessions, batch->id);
a259 1
	struct mta_batch	 batch;
a284 2
		batch.id = s->id;
		batch.msgid = s->task->msgid;
d286 2
a287 1
		    IMSG_QUEUE_MESSAGE_FD, 0, 0, -1, &batch, sizeof(batch));
@


1.8
log
@Move mta and smtp specific defines into their own files.
Some formatting cleanups while there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.7 2012/08/09 09:48:02 eric Exp $	*/
d82 2
a83 2
struct mta_relay {
	TAILQ_ENTRY(mta_relay)	 entry;
d90 3
a92 8
	SPLAY_ENTRY(mta_session) entry;
	u_int64_t		 id;
	enum mta_state		 state;
	char			*host;
	int			 port;
	int			 flags;
	TAILQ_HEAD(,mta_relay)	 relays;
	char			*authmap;
a93 1
	FILE			*datafp;
d95 1
a95 1
	TAILQ_HEAD(,mta_task)	 tasks;
d97 5
d105 1
a105 1
	int			 ext; /* extension */
a108 14
struct mta_task {
	SPLAY_ENTRY(mta_task)	 entry;
	uint64_t		 id;

	struct mta_session	*session;
	TAILQ_ENTRY(mta_task)	 list;

	struct mailaddr		 sender;
	TAILQ_HEAD(,envelope)	 envelopes;
};

SPLAY_HEAD(mta_session_tree, mta_session);
SPLAY_HEAD(mta_task_tree, mta_task);

a109 1
static struct mta_session *mta_session_lookup(u_int64_t);
d112 1
a112 2
static int mta_envelope_done(struct mta_task *, struct envelope *,
    const char *);
a115 10
static int mta_session_cmp(struct mta_session *, struct mta_session *);

static int mta_task_cmp(struct mta_task *, struct mta_task *);
static struct mta_task * mta_task_lookup(uint64_t, int);
static struct mta_task * mta_task_create(uint64_t, struct mta_session *);
static void mta_task_free(struct mta_task *);

SPLAY_PROTOTYPE(mta_session_tree, mta_session, entry, mta_session_cmp);
SPLAY_PROTOTYPE(mta_task_tree, mta_task, entry, mta_task_cmp);

d118 1
a118 2
static struct mta_session_tree mta_sessions = SPLAY_INITIALIZER(&mta_sessions);
static struct mta_task_tree mta_tasks = SPLAY_INITIALIZER(&mta_tasks);
d121 1
a121 1
mta_session_imsg(struct imsgev *iev, struct imsg *imsg)
d123 1
a123 10
	struct mta_batch	*mta_batch;
	struct mta_task		*task;
	struct mta_session	*s;
	struct mta_relay	*relay;
	struct envelope		*e;
	struct secret		*secret;
	struct dns		*dns;
	struct ssl		 key;
	char			*cert;
	void			*ptr;
d125 16
a140 32
	switch (imsg->hdr.type) {
	case IMSG_BATCH_CREATE:
		mta_batch = imsg->data;

		s = calloc(1, sizeof *s);
		if (s == NULL)
			fatal(NULL);
		s->id = mta_batch->id;
		s->state = MTA_INIT;

		/* establish host name */
		if (mta_batch->relay.hostname[0]) {
			s->host = strdup(mta_batch->relay.hostname);
			s->flags |= MTA_FORCE_MX;
		}

		/* establish port */
		s->port = mta_batch->relay.port;

		/* use auth? */
		if ((mta_batch->relay.flags & F_SSL) &&
		    (mta_batch->relay.flags & F_AUTH)) {
			s->flags |= MTA_USE_AUTH;
			s->authmap = strdup(mta_batch->relay.authmap);
			if (s->authmap == NULL)
				fatalx("mta: strdup authmap");
		}

		/* force a particular SSL mode? */
		switch (mta_batch->relay.flags & F_SSL) {
		case F_SSL:
			s->flags |= MTA_FORCE_ANYSSL;
d142 2
a143 2
		case F_SMTPS:
			s->flags |= MTA_FORCE_SMTPS;
d145 1
a145 1
		case F_STARTTLS:
d149 2
a150 2
			s->flags |= MTA_ALLOW_PLAIN;
		}
d152 1
a152 7
		/* have cert? */
		cert = mta_batch->relay.cert;
		if (cert[0] != '\0') {
			s->flags |= MTA_USE_CERT;
			strlcpy(key.ssl_name, cert, sizeof(key.ssl_name));
			s->ssl = SPLAY_FIND(ssltree, env->sc_ssl, &key);
		}
d154 2
a155 3
		TAILQ_INIT(&s->relays);
		TAILQ_INIT(&s->tasks);
		SPLAY_INSERT(mta_session_tree, &mta_sessions, s);
d157 10
a166 4
		if (mta_task_create(s->id, s) == NULL)
			fatalx("mta_session_imsg: mta_task_create");

		log_debug("mta: %p: new session for batch %" PRIu64, s, s->id);
d168 1
a168 32
		return;

	case IMSG_BATCH_APPEND:
		e = imsg->data;
		task = mta_task_lookup(e->batch_id, 1);
		e = malloc(sizeof *e);
		if (e == NULL)
			fatal(NULL);
		*e = *(struct envelope *)imsg->data;
		s = task->session;
		if (s->host == NULL) {
			s->host = strdup(e->dest.domain);
			if (s->host == NULL)
				fatal("strdup");
		}
		if (TAILQ_FIRST(&task->envelopes) == NULL)
			task->sender = e->sender;
		log_debug("mta: %p: adding <%s@@%s> from envelope %016" PRIx64,
		    s, e->dest.user, e->dest.domain, e->id);
		TAILQ_INSERT_TAIL(&task->envelopes, e, entry);
		return;

	case IMSG_BATCH_CLOSE:
		mta_batch = imsg->data;
		task = mta_task_lookup(mta_batch->id, 1);
		s = task->session;
		if (s->flags & MTA_USE_CERT && s->ssl == NULL) {
			mta_status(s, 1, "190 certificate not found");
			mta_enter_state(s, MTA_DONE);
		} else
			mta_enter_state(s, MTA_INIT);
		return;
d171 1
a171 1
		mta_batch = imsg->data;
d174 1
a174 1
		s = mta_session_lookup(mta_batch->id);
d178 1
a178 1
		mta_enter_state(s, MTA_CONNECT);
d184 4
a187 6
		s = mta_session_lookup(secret->id);
		s->secret = strdup(secret->secret);
		if (s->secret == NULL)
			fatal(NULL);
		else if (s->secret[0] == '\0') {
			mta_status(s, 1, "190 secrets lookup failed");
d195 4
a198 6
		s = mta_session_lookup(dns->id);
		relay = calloc(1, sizeof *relay);
		if (relay == NULL)
			fatal(NULL);
		relay->sa = dns->ss;
 		TAILQ_INSERT_TAIL(&s->relays, relay, entry);
d204 17
a220 13
		s = mta_session_lookup(dns->id);
		if (dns->error) {
			if (dns->error == DNS_RETRY)
				mta_status(s, 1, "100 MX lookup failed temporarily");
			else if (dns->error == DNS_EINVAL)
				mta_status(s, 1, "600 Invalid domain name");
			else if (dns->error == DNS_ENONAME)
				mta_status(s, 1, "600 Domain does not exist");
			else if (dns->error == DNS_ENOTFOUND)
				mta_status(s, 1, "600 No MX address found for domain");
			mta_enter_state(s, MTA_DONE);
		} else
			mta_enter_state(s, MTA_DATA);
d225 2
a226 2
		s = mta_session_lookup(dns->id);
		relay = TAILQ_FIRST(&s->relays);
d228 1
a228 1
			strlcpy(relay->fqdn, "<unknown>", sizeof relay->fqdn);
d230 2
a231 2
			strlcpy(relay->fqdn, dns->host, sizeof relay->fqdn);
		log_debug("mta: %p: connected to %s", s, relay->fqdn);
d234 1
a234 1
		if (((s->flags & MTA_FORCE_ANYSSL) && relay->used == 1) ||
d237 1
a237 2
			ptr = ssl_mta_init(s->ssl);
			if (ptr == NULL)
a238 1

d255 2
a256 2
	struct mta_relay	*relay;
	struct mta_task		*task;
a257 1
	struct envelope		*e;
a262 1
	task = TAILQ_FIRST(&s->tasks);
d276 1
a276 1
		if (s->flags & MTA_USE_AUTH)
a285 1
		e = TAILQ_FIRST(&task->envelopes);
d287 1
a287 1
		batch.msgid = evpid_to_msgid(e->id);
d298 2
a299 2
		strlcpy(secret.mapname, s->authmap, sizeof(secret.mapname));
		strlcpy(secret.host, s->host, sizeof(secret.host));
d308 2
a309 2
		if (s->flags & MTA_FORCE_MX)
			dns_query_host(s->host, s->port, s->id);
d311 1
a311 1
			dns_query_mx(s->host, 0, s->id);
d330 4
a333 4
		while ((relay = TAILQ_FIRST(&s->relays))) {
			if (relay->used == max_reuse) {
				TAILQ_REMOVE(&s->relays, relay, entry);
				free(relay);
d336 1
a336 1
			relay->used++;
d339 2
a340 2
				ss_to_text(&relay->sa));
			sa = (struct sockaddr *)&relay->sa;
d342 3
a344 3
			if (s->port)
				sa_set_port(sa, s->port);
			else if ((s->flags & MTA_FORCE_ANYSSL) && relay->used == 1)
d363 2
a364 2
				TAILQ_REMOVE(&s->relays, relay, entry);
				free(relay);
d370 1
a370 1
		mta_status(s, 1, "150 Can not connect to MX");
d378 1
a378 2

		log_debug("mta: %p: deleting session...", s);
d381 2
a382 11

		if (TAILQ_FIRST(&s->tasks))
			fatalx("all tasks should have been deleted already");

		/* deallocate resources */
		SPLAY_REMOVE(mta_session_tree, &mta_sessions, s);
		while ((relay = TAILQ_FIRST(&s->relays))) {
			TAILQ_REMOVE(&s->relays, relay, entry);
			free(relay);
		}

d385 6
a390 4

		free(s->authmap);
		free(s->secret);
		free(s->host);
d392 1
d427 2
a428 1
		} else
d430 1
d435 15
a449 3
		if (task)
			mta_enter_state(s, MTA_SMTP_MAIL);
		else
d451 1
d455 1
a455 2
		if (task->sender.user[0] &&
		    task->sender.domain[0])
d457 1
a457 2
			    task->sender.user,
			    task->sender.domain);
d460 1
d465 1
a465 1
			s->currevp = TAILQ_FIRST(&task->envelopes);
d478 1
a478 1
			log_debug("mta: %p: end-of-file", s);
d500 1
a500 4
		if (task == NULL)
			mta_enter_state(s, MTA_SMTP_QUIT);
		else
			mta_send(s, "RSET");
a516 1
	struct mta_task	*task = TAILQ_FIRST(&s->tasks);
d528 1
a528 1
				mta_status(s, 1, line);
d540 1
a540 1
			mta_status(s, 1, line);
d544 1
d555 1
a555 1
			mta_status(s, 1, line);
d568 1
a568 1
			mta_status(s, 1, line);
d572 1
d588 3
a590 1
		if (line[0] != '2' && mta_envelope_done(task, evp, line)) {
d593 1
d612 2
d632 1
a632 1
	struct mta_relay	*relay;
d643 2
a644 2
		relay = TAILQ_FIRST(&s->relays);
		dns_query_ptr(&relay->sa, s->id);
a656 1

d800 1
a800 1
mta_status(struct mta_session *s, int alltasks, const char *fmt, ...)
d802 1
a803 2
	struct envelope		*e;
	struct mta_task		*task;
d811 5
a815 8
	log_debug("mta: %p: new status for %s: %s", s,
	    alltasks ? "all tasks" : "current task", status);
	while ((task = TAILQ_FIRST(&s->tasks))) {
		while((e = TAILQ_FIRST(&task->envelopes)))
			if (mta_envelope_done(task, e, status))
				break;
		if (!alltasks)
			break;
d818 3
d824 1
a824 1
static int
d827 1
a827 3
	struct mta_session	*s = task->session;
	struct mta_relay	*relay = TAILQ_FIRST(&s->relays);
	u_int16_t		msg;
d831 1
a831 1
	log_info("%016" PRIx64 ": to=<%s@@%s>, delay=%" PRId64 ", relay=%s [%s], stat=%s (%s)",
d834 5
a838 24
	    (int64_t) (time(NULL) - e->creation),
	    relay ? relay->fqdn : "(none)",
	    relay ? ss_to_text(&relay->sa) : "",
	    *status == '2' ? "Sent" :
	    *status == '5' ? "RemoteError" :
	    *status == '4' ? "RemoteError" : "LocalError",
	    status + 4);

	switch (e->errorline[0]) {
	case '2':
		msg = IMSG_QUEUE_DELIVERY_OK;
		break;
	case '5':
	case '6':
		msg = IMSG_QUEUE_DELIVERY_PERMFAIL;
		break;
	default:
		msg = IMSG_QUEUE_DELIVERY_TEMPFAIL;
		break;
	}
	imsg_compose_event(env->sc_ievs[PROC_QUEUE], msg,
	    0, 0, -1, e, sizeof(*e));
	TAILQ_REMOVE(&task->envelopes, e, entry);
	free(e);
d840 2
a841 2
	if (TAILQ_FIRST(&task->envelopes))
		return (0);
d843 1
a843 2
	mta_task_free(task);
	return (1);
d845 1
a846 77

static int
mta_session_cmp(struct mta_session *a, struct mta_session *b)
{
	return (a->id < b->id ? -1 : a->id > b->id);
}

static struct mta_session *
mta_session_lookup(u_int64_t id)
{
	struct mta_session	 key, *res;

	key.id = id;
	if ((res = SPLAY_FIND(mta_session_tree, &mta_sessions, &key)) == NULL)
		fatalx("mta_session_lookup: session not found");
	return (res);
}

SPLAY_GENERATE(mta_session_tree, mta_session, entry, mta_session_cmp);

static struct mta_task *
mta_task_create(u_int64_t id, struct mta_session *s)
{
	struct mta_task	 *t;

	if ((t = mta_task_lookup(id, 0)))
		fatalx("mta_task_create: duplicate task id");
	if ((t = calloc(1, sizeof(*t))) == NULL)
		return (NULL);

	t->id = id;
	t->session = s;
	SPLAY_INSERT(mta_task_tree, &mta_tasks, t);
	TAILQ_INIT(&t->envelopes);
	if (s)
		TAILQ_INSERT_TAIL(&s->tasks, t, list);

	return (t);
}

static int
mta_task_cmp(struct mta_task *a, struct mta_task *b)
{
	return (a->id < b->id ? -1 : a->id > b->id);
}

static struct mta_task *
mta_task_lookup(u_int64_t id, int strict)
{
	struct mta_task	 key, *res;

	key.id = id;
	res = SPLAY_FIND(mta_task_tree, &mta_tasks, &key);
	if (res == NULL && strict)
		fatalx("mta_task_lookup: task not found");
	return (res);
}

static void
mta_task_free(struct mta_task *t)
{
	struct envelope	*e;

	if (t->session)
		TAILQ_REMOVE(&t->session->tasks, t, list);

	SPLAY_REMOVE(mta_task_tree, &mta_tasks, t);

	while ((e = TAILQ_FIRST(&t->envelopes))) {
		TAILQ_REMOVE(&t->envelopes, e, entry);
		free(e);
	}

	free(t);
}

SPLAY_GENERATE(mta_task_tree, mta_task, entry, mta_task_cmp);
@


1.7
log
@Improve the message flows to completely isolate operations on the
queue backend within the queue process.

The scheduler sends envelope ids to the queue process which loads
the envelope and forward the request to the agent responsible for
the delivery.  The result is sent by the agent to the queue which
updates the storage before notifying the scheduler.

Bounces are created and enqueued (from the client side) by the
queue process, rather than the scheduler.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.6 2012/07/29 20:16:02 eric Exp $	*/
d46 36
a144 2
#define MTA_HIWAT	65535

d829 8
a836 8
        va_list  ap;
        char    *p;
        int      len;

        va_start(ap, fmt);
        if ((len = vasprintf(&p, fmt, ap)) == -1)
                fatal("mta: vasprintf");
        va_end(ap);
d842 1
a842 1
        free(p);
d852 1
a852 1
        size_t	 len, q;
d857 4
a860 4
                if ((ln = fgetln(s->datafp, &len)) == NULL)
                        break;
                if (ln[len - 1] == '\n')
                        len--;
d867 1
a867 1
        if (ferror(s->datafp)) {
d872 1
a872 1
        if (feof(s->datafp)) {
d1045 1
a1045 1
	CASE(MTA_SMTP_AUTH);                             
@


1.6
log
@reset the session if no RCPT was accepted for the batch.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.5 2012/07/29 13:56:24 eric Exp $	*/
a440 3

		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_BATCH_DONE, 0, 0, -1, NULL, 0);
@


1.5
log
@remove the session tree from the global env and move it to mta_session.c,
along with mta_relay and mta_session definition.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.4 2012/07/15 17:36:42 gilles Exp $	*/
d642 4
a645 2
		if (line[0] != '2')
			mta_envelope_done(task, evp, line);
@


1.4
log
@when specifying a relay port that's not standart, do not ntohs() the relay
port as it will be done internally by sa_set_port()

issue reported by Markus Bergkvist <markus@@familjenbergkvist.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.3 2012/06/01 10:46:32 chl Exp $	*/
d46 28
d85 1
d104 1
a104 1
SPLAY_PROTOTYPE(mtatree, mta_session, entry, mta_session_cmp);
d111 1
d181 1
a181 1
		SPLAY_INSERT(mtatree, &env->mta_sessions, s);
d446 1
a446 1
		SPLAY_REMOVE(mtatree, &env->mta_sessions, s);
d930 1
a930 1
	if ((res = SPLAY_FIND(mtatree, &env->mta_sessions, &key)) == NULL)
d935 1
a935 1
SPLAY_GENERATE(mtatree, mta_session, entry, mta_session_cmp);
@


1.3
log
@use PRIu64 instead of llu in format string.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.2 2012/05/12 17:41:27 eric Exp $	*/
d115 1
a115 1
		s->port = ntohs(mta_batch->relay.port); /* XXX */
@


1.2
log
@Update the internal mta implementation so that a session now has a
list of messages to send to the remote smtp server over the same
connection. It's not currently used as the scheduler/runner is not
aware of this yet, and the imsg protocol would need to be updated.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta_session.c,v 1.1 2012/05/11 12:12:02 eric Exp $	*/
d156 1
a156 1
		log_debug("mta: %p: new session for batch %llu", s, s->id);
@


1.1
log
@split the session logic off mta.c into mta_session.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.131 2012/05/11 08:15:30 eric Exp $	*/
d46 13
d62 2
a63 2
static void mta_status(struct mta_session *, const char *, ...);
static void mta_envelope_done(struct mta_session *, struct envelope *,
d70 5
d76 1
d82 2
d88 1
a148 1
		TAILQ_INIT(&s->recipients);
d150 1
d153 3
d162 1
a162 1
		s = mta_session_lookup(e->batch_id);
d167 1
a167 2
		envelope_set_errormsg(e, "000 init");

d173 2
d177 1
a177 1
		TAILQ_INSERT_TAIL(&s->recipients, e, entry);
d182 2
a183 1
		s = mta_session_lookup(mta_batch->id);
d185 1
a185 1
			mta_status(s, "190 certificate not found");
d210 1
a210 1
			mta_status(s, "190 secrets lookup failed");
d232 1
a232 1
				mta_status(s, "100 MX lookup failed temporarily");
d234 1
a234 1
				mta_status(s, "600 Invalid domain name");
d236 1
a236 1
				mta_status(s, "600 Domain does not exist");
d238 1
a238 1
				mta_status(s, "600 No MX address found for domain");
d279 1
d287 1
a287 1

d311 1
a311 1
		e = TAILQ_FIRST(&s->recipients);
d396 1
a396 1
		mta_status(s, "150 Can not connect to MX");
d409 2
a410 2
		if ((e = TAILQ_FIRST(&s->recipients)))
			fatalx("all envelopes should have been sent already");
d469 4
a472 1
		mta_enter_state(s, MTA_SMTP_MAIL);
d476 2
a477 3
		s->currevp = TAILQ_FIRST(&s->recipients);
		if (s->currevp->sender.user[0] &&
		    s->currevp->sender.domain[0])
d479 2
a480 2
			    s->currevp->sender.user,
			    s->currevp->sender.domain);
d486 2
d521 7
d542 1
d554 1
a554 1
				mta_status(s, line);
d566 1
a566 1
			mta_status(s, line);
d580 1
a580 1
			mta_status(s, line);
d593 1
a593 1
			mta_status(s, line);
d602 2
a603 2
			mta_status(s, line);
			mta_enter_state(s, MTA_DONE);
d613 1
a613 1
			mta_envelope_done(s, evp, line);
d622 2
a623 2
			mta_status(s, line);
			mta_enter_state(s, MTA_DONE);
d630 6
a635 5
		mta_status(s, line);
		if (line[0] != '2')
			mta_enter_state(s, MTA_DONE);
		else
			mta_enter_state(s, MTA_SMTP_QUIT);
d678 1
a678 1
				mta_status(s, "150 Input too long");
d689 1
a689 1
			mta_status(s, "150 Bad response: %s", error);
d734 1
a734 1
		mta_status(s, "150 connection timeout");
d744 1
a744 1
		mta_status(s, "150 IO error");
d754 1
a754 1
		mta_status(s, "150 connection closed unexpectedly");
d805 1
a805 1
		mta_status(s, "460 Error reading content file");
d818 1
a818 1
mta_status(struct mta_session *s, const char *fmt, ...)
d822 1
d830 9
a838 4
	log_debug("mta: %p: new status for remaining envelopes: %s", s, status);

	while ((e = TAILQ_FIRST(&s->recipients)))
		mta_envelope_done(s, e, status);
d843 2
a844 2
static void
mta_envelope_done(struct mta_session *s, struct envelope *e, const char *status)
d846 1
d877 1
a877 1
	TAILQ_REMOVE(&s->recipients, e, entry);
d879 7
d907 58
d989 1
@

