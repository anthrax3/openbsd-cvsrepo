head	1.132;
access;
symbols
	OPENBSD_6_1:1.132.0.4
	OPENBSD_6_1_BASE:1.132
	OPENBSD_6_0:1.127.0.4
	OPENBSD_6_0_BASE:1.127
	OPENBSD_5_9:1.125.0.2
	OPENBSD_5_9_BASE:1.125
	OPENBSD_5_8:1.113.0.4
	OPENBSD_5_8_BASE:1.113
	OPENBSD_5_7:1.112.0.2
	OPENBSD_5_7_BASE:1.112
	OPENBSD_5_6:1.110.0.4
	OPENBSD_5_6_BASE:1.110
	OPENBSD_5_5:1.108.0.2
	OPENBSD_5_5_BASE:1.108
	OPENBSD_5_4:1.97.0.2
	OPENBSD_5_4_BASE:1.97
	OPENBSD_5_3:1.92.0.2
	OPENBSD_5_3_BASE:1.92
	OPENBSD_5_2:1.66.0.2
	OPENBSD_5_2_BASE:1.66
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.2
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15;
locks; strict;
comment	@ * @;


1.132
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.131;
commitid	eA8b246voAapPTkX;

1.131
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.130;
commitid	jM4eOMW1AJwdfKrr;

1.130
date	2016.11.30.18.38.32;	author eric;	state Exp;
branches;
next	1.129;
commitid	FwxH1kwyHJkP7A4S;

1.129
date	2016.11.17.17.34.55;	author eric;	state Exp;
branches;
next	1.128;
commitid	8UKnvWDg7NJwNwWd;

1.128
date	2016.08.31.10.18.08;	author gilles;	state Exp;
branches;
next	1.127;
commitid	jWkTljYAPNXFatSw;

1.127
date	2016.05.16.17.43.18;	author gilles;	state Exp;
branches;
next	1.126;
commitid	nDyVV4lxVaD3uu48;

1.126
date	2016.03.25.15.06.58;	author krw;	state Exp;
branches;
next	1.125;
commitid	0NIU7T9t8yqZHZQl;

1.125
date	2016.01.12.17.29.43;	author sunil;	state Exp;
branches;
next	1.124;
commitid	bHpUcFTAHFMpObZb;

1.124
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.123;
commitid	ZxnqOQqX6IeYI9jW;

1.123
date	2015.12.14.10.22.12;	author jung;	state Exp;
branches;
next	1.122;
commitid	HRAnniyhGW9Sadln;

1.122
date	2015.10.17.22.24.36;	author gilles;	state Exp;
branches;
next	1.121;
commitid	Xkf5erzxtvmccNIE;

1.121
date	2015.10.17.12.59.52;	author gilles;	state Exp;
branches;
next	1.120;
commitid	WctEzex1GcIAGeJs;

1.120
date	2015.10.12.07.58.19;	author deraadt;	state Exp;
branches;
next	1.119;
commitid	SD2NAm0X1clljRst;

1.119
date	2015.10.10.11.42.49;	author jung;	state Exp;
branches;
next	1.118;
commitid	6SQmKxFFyKAzB7di;

1.118
date	2015.10.06.06.04.46;	author gilles;	state Exp;
branches;
next	1.117;
commitid	kHsLvobU8ObZj5n9;

1.117
date	2015.10.06.05.48.34;	author gilles;	state Exp;
branches;
next	1.116;
commitid	LfGrhzZIeOm2z9BP;

1.116
date	2015.10.05.22.08.14;	author stsp;	state Exp;
branches;
next	1.115;
commitid	qF2ZpmbsrtAQfWkV;

1.115
date	2015.10.02.00.41.25;	author gilles;	state Exp;
branches;
next	1.114;
commitid	JFxTZsrGk6NZK17G;

1.114
date	2015.08.16.20.53.19;	author gilles;	state Exp;
branches;
next	1.113;
commitid	9n4jpkMTCruPY87M;

1.113
date	2015.05.06.08.37.47;	author gilles;	state Exp;
branches
	1.113.4.1;
next	1.112;
commitid	xHhRtNpnYgehrhPX;

1.112
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches
	1.112.2.1;
next	1.111;
commitid	ZBTFreARDSMmzOIV;

1.111
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.110;
commitid	Uu5nFG3wCl0LACBb;

1.110
date	2014.05.25.10.55.36;	author espie;	state Exp;
branches
	1.110.4.1;
next	1.109;

1.109
date	2014.04.19.14.32.03;	author gilles;	state Exp;
branches;
next	1.108;

1.108
date	2014.02.04.10.38.06;	author eric;	state Exp;
branches;
next	1.107;

1.107
date	2014.02.04.09.50.31;	author eric;	state Exp;
branches;
next	1.106;

1.106
date	2014.02.04.09.05.06;	author eric;	state Exp;
branches;
next	1.105;

1.105
date	2014.01.08.15.30.49;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.103;

1.103
date	2013.11.28.10.43.37;	author eric;	state Exp;
branches;
next	1.102;

1.102
date	2013.11.19.10.22.42;	author eric;	state Exp;
branches;
next	1.101;

1.101
date	2013.10.29.14.30.05;	author eric;	state Exp;
branches;
next	1.100;

1.100
date	2013.10.29.13.22.54;	author eric;	state Exp;
branches;
next	1.99;

1.99
date	2013.10.27.18.50.59;	author eric;	state Exp;
branches;
next	1.98;

1.98
date	2013.10.25.21.31.23;	author eric;	state Exp;
branches;
next	1.97;

1.97
date	2013.07.19.08.28.43;	author eric;	state Exp;
branches;
next	1.96;

1.96
date	2013.07.19.08.12.19;	author eric;	state Exp;
branches;
next	1.95;

1.95
date	2013.07.19.07.37.29;	author eric;	state Exp;
branches;
next	1.94;

1.94
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.93;

1.93
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.92;

1.92
date	2013.02.05.11.45.18;	author gilles;	state Exp;
branches;
next	1.91;

1.91
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.90;

1.90
date	2013.01.26.09.37.24;	author gilles;	state Exp;
branches;
next	1.89;

1.89
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.88;

1.88
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.87;

1.87
date	2012.10.10.19.39.11;	author gilles;	state Exp;
branches;
next	1.86;

1.86
date	2012.10.07.15.46.38;	author chl;	state Exp;
branches;
next	1.85;

1.85
date	2012.10.04.12.17.09;	author todd;	state Exp;
branches;
next	1.84;

1.84
date	2012.09.26.19.52.20;	author eric;	state Exp;
branches;
next	1.83;

1.83
date	2012.09.26.09.43.42;	author eric;	state Exp;
branches;
next	1.82;

1.82
date	2012.09.25.15.36.29;	author eric;	state Exp;
branches;
next	1.81;

1.81
date	2012.09.21.12.33.32;	author eric;	state Exp;
branches;
next	1.80;

1.80
date	2012.09.21.10.22.29;	author eric;	state Exp;
branches;
next	1.79;

1.79
date	2012.09.20.14.28.57;	author eric;	state Exp;
branches;
next	1.78;

1.78
date	2012.09.18.14.23.01;	author eric;	state Exp;
branches;
next	1.77;

1.77
date	2012.09.16.11.53.57;	author gilles;	state Exp;
branches;
next	1.76;

1.76
date	2012.09.15.15.12.11;	author eric;	state Exp;
branches;
next	1.75;

1.75
date	2012.08.27.11.59.38;	author chl;	state Exp;
branches;
next	1.74;

1.74
date	2012.08.26.11.52.48;	author gilles;	state Exp;
branches;
next	1.73;

1.73
date	2012.08.25.23.35.09;	author chl;	state Exp;
branches;
next	1.72;

1.72
date	2012.08.25.22.03.26;	author gilles;	state Exp;
branches;
next	1.71;

1.71
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.70;

1.70
date	2012.08.11.12.43.11;	author eric;	state Exp;
branches;
next	1.69;

1.69
date	2012.08.08.08.50.42;	author eric;	state Exp;
branches;
next	1.68;

1.68
date	2012.08.07.21.47.58;	author eric;	state Exp;
branches;
next	1.67;

1.67
date	2012.07.29.17.21.43;	author gilles;	state Exp;
branches;
next	1.66;

1.66
date	2012.07.12.08.51.43;	author chl;	state Exp;
branches;
next	1.65;

1.65
date	2012.07.11.22.16.45;	author chl;	state Exp;
branches;
next	1.64;

1.64
date	2012.07.11.17.20.00;	author chl;	state Exp;
branches;
next	1.63;

1.63
date	2012.07.10.16.11.43;	author chl;	state Exp;
branches;
next	1.62;

1.62
date	2012.07.08.15.48.00;	author gilles;	state Exp;
branches;
next	1.61;

1.61
date	2012.07.02.10.32.28;	author eric;	state Exp;
branches;
next	1.60;

1.60
date	2012.05.29.19.29.44;	author gilles;	state Exp;
branches;
next	1.59;

1.59
date	2012.05.23.22.46.58;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2012.05.13.00.10.49;	author gilles;	state Exp;
branches;
next	1.57;

1.57
date	2012.01.28.16.54.10;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2012.01.12.15.01.33;	author eric;	state Exp;
branches;
next	1.55;

1.55
date	2012.01.11.17.46.37;	author eric;	state Exp;
branches;
next	1.54;

1.54
date	2011.12.18.22.51.29;	author chl;	state Exp;
branches;
next	1.53;

1.53
date	2011.12.18.18.43.30;	author eric;	state Exp;
branches;
next	1.52;

1.52
date	2011.12.11.19.58.09;	author eric;	state Exp;
branches;
next	1.51;

1.51
date	2011.11.16.19.38.56;	author eric;	state Exp;
branches;
next	1.50;

1.50
date	2011.11.14.11.53.10;	author eric;	state Exp;
branches;
next	1.49;

1.49
date	2011.10.27.14.32.57;	author chl;	state Exp;
branches;
next	1.48;

1.48
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.47;

1.47
date	2011.05.17.18.54.32;	author gilles;	state Exp;
branches;
next	1.46;

1.46
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.45;

1.45
date	2011.05.14.11.04.42;	author gilles;	state Exp;
branches;
next	1.44;

1.44
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.17.11.39.23;	author gilles;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.15.17.21.24;	author gilles;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.40;

1.40
date	2011.03.29.20.43.51;	author eric;	state Exp;
branches;
next	1.39;

1.39
date	2011.03.03.08.09.14;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.29.15.25.56;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.36;

1.36
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.01.23.06.25;	author jacekm;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.23.17.16.03;	author jacekm;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.14.19.56.55;	author jacekm;	state Exp;
branches;
next	1.30;

1.30
date	2009.12.13.22.02.55;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.08.21.40.05;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.08.19.38.26;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.15.16.50.06;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.27.09.21.28;	author jacekm;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.08.00.18.38;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.08.00.02.22;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.06.14.12.48;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.01.18.24.01;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.05.10.11.29.40;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.24.10.02.35;	author jacekm;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.12.11.08.26;	author pea;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.10.01.25.42;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.09.23.35.04;	author jacekm;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.01.21.58.53;	author jacekm;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.24.12.07.47;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.23.22.59.40;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.22.11.59.12;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.18.22.39.12;	author jacekm;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.28.12.56.46;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.27.22.48.29;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.27.15.57.01;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.27.15.50.15;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.08.19.17.31;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.04.17.45.58;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.19.12.09.00;	author jacekm;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.18.23.57.17;	author jacekm;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.11.22.17.12;	author gilles;	state Exp;
branches;
next	;

1.110.4.1
date	2015.10.02.01.33.33;	author gilles;	state Exp;
branches;
next	;
commitid	2Q56YgF5PzqMcagu;

1.112.2.1
date	2015.10.02.01.28.43;	author gilles;	state Exp;
branches;
next	;
commitid	pAamrt3DJscJjb10;

1.113.4.1
date	2015.10.02.00.55.02;	author gilles;	state Exp;
branches;
next	;
commitid	5SntIHNUPMG4dcQ1;


desc
@@


1.132
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@/*	$OpenBSD: util.c,v 1.131 2017/01/09 09:53:23 reyk Exp $	*/

/*
 * Copyright (c) 2000,2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/resource.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <fts.h>
#include <imsg.h>
#include <inttypes.h>
#include <libgen.h>
#include <netdb.h>
#include <pwd.h>
#include <limits.h>
#include <resolv.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

const char *log_in6addr(const struct in6_addr *);
const char *log_sockaddr(struct sockaddr *);
static int  parse_mailname_file(char *, size_t);

int	tracing = 0;
int	foreground_log = 0;

void *
xmalloc(size_t size, const char *where)
{
	void	*r;

	if ((r = malloc(size)) == NULL) {
		log_warnx("%s: malloc(%zu)", where, size);
		fatalx("exiting");
	}

	return (r);
}

void *
xcalloc(size_t nmemb, size_t size, const char *where)
{
	void	*r;

	if ((r = calloc(nmemb, size)) == NULL) {
		log_warnx("%s: calloc(%zu, %zu)", where, nmemb, size);
		fatalx("exiting");
	}

	return (r);
}

char *
xstrdup(const char *str, const char *where)
{
	char	*r;

	if ((r = strdup(str)) == NULL) {
		log_warnx("%s: strdup(%p)", where, str);
		fatalx("exiting");
	}

	return (r);
}

void *
xmemdup(const void *ptr, size_t size, const char *where)
{
	void	*r;

	if ((r = malloc(size)) == NULL) {
		log_warnx("%s: malloc(%zu)", where, size);
		fatalx("exiting");
	}
	memmove(r, ptr, size);

	return (r);
}

#if !defined(NO_IO)
int
io_xprintf(struct io *io, const char *fmt, ...)
{
	va_list	ap;
	int len;

	va_start(ap, fmt);
	len = io_vprintf(io, fmt, ap);
	va_end(ap);
	if (len == -1)
		fatal("io_xprintf(%p, %s, ...)", io, fmt);

	return len;
}

int
io_xprint(struct io *io, const char *str)
{
	int len;

	len = io_print(io, str);
	if (len == -1)
		fatal("io_xprint(%p, %s, ...)", io, str);

	return len;
}
#endif

char *
strip(char *s)
{
	size_t	 l;

	while (isspace((unsigned char)*s))
		s++;

	for (l = strlen(s); l; l--) {
		if (!isspace((unsigned char)s[l-1]))
			break;
		s[l-1] = '\0';
	}

	return (s);
}

int
bsnprintf(char *str, size_t size, const char *format, ...)
{
	int ret;
	va_list ap;

	va_start(ap, format);
	ret = vsnprintf(str, size, format, ap);
	va_end(ap);
	if (ret == -1 || ret >= (int)size)
		return 0;

	return 1;
}


static int
mkdirs_component(char *path, mode_t mode)
{
	struct stat	sb;

	if (stat(path, &sb) == -1) {
		if (errno != ENOENT)
			return 0;
		if (mkdir(path, mode | S_IWUSR | S_IXUSR) == -1)
			return 0;
	}
	else if (!S_ISDIR(sb.st_mode))
		return 0;

	return 1;
}

int
mkdirs(char *path, mode_t mode)
{
	char	 buf[PATH_MAX];
	int	 i = 0;
	int	 done = 0;
	char	*p;

	/* absolute path required */
	if (*path != '/')
		return 0;

	/* make sure we don't exceed PATH_MAX */
	if (strlen(path) >= sizeof buf)
		return 0;

	memset(buf, 0, sizeof buf);
	for (p = path; *p; p++) {
		if (*p == '/') {
			if (buf[0] != '\0')
				if (!mkdirs_component(buf, mode))
					return 0;
			while (*p == '/')
				p++;
			buf[i++] = '/';
			buf[i++] = *p;
			if (*p == '\0' && ++done)
				break;
			continue;
		}
		buf[i++] = *p;
	}
	if (!done)
		if (!mkdirs_component(buf, mode))
			return 0;

	if (chmod(path, mode) == -1)
		return 0;

	return 1;
}

int
ckdir(const char *path, mode_t mode, uid_t owner, gid_t group, int create)
{
	char		mode_str[12];
	int		ret;
	struct stat	sb;

	if (stat(path, &sb) == -1) {
		if (errno != ENOENT || create == 0) {
			log_warn("stat: %s", path);
			return (0);
		}

		/* chmod is deferred to avoid umask effect */
		if (mkdir(path, 0) == -1) {
			log_warn("mkdir: %s", path);
			return (0);
		}

		if (chown(path, owner, group) == -1) {
			log_warn("chown: %s", path);
			return (0);
		}

		if (chmod(path, mode) == -1) {
			log_warn("chmod: %s", path);
			return (0);
		}

		if (stat(path, &sb) == -1) {
			log_warn("stat: %s", path);
			return (0);
		}
	}

	ret = 1;

	/* check if it's a directory */
	if (!S_ISDIR(sb.st_mode)) {
		ret = 0;
		log_warnx("%s is not a directory", path);
	}

	/* check that it is owned by owner/group */
	if (sb.st_uid != owner) {
		ret = 0;
		log_warnx("%s is not owned by uid %d", path, owner);
	}
	if (sb.st_gid != group) {
		ret = 0;
		log_warnx("%s is not owned by gid %d", path, group);
	}

	/* check permission */
	if ((sb.st_mode & 07777) != mode) {
		ret = 0;
		strmode(mode, mode_str);
		mode_str[10] = '\0';
		log_warnx("%s must be %s (%o)", path, mode_str + 1, mode);
	}

	return ret;
}

int
rmtree(char *path, int keepdir)
{
	char		*path_argv[2];
	FTS		*fts;
	FTSENT		*e;
	int		 ret, depth;

	path_argv[0] = path;
	path_argv[1] = NULL;
	ret = 0;
	depth = 0;

	fts = fts_open(path_argv, FTS_PHYSICAL | FTS_NOCHDIR, NULL);
	if (fts == NULL) {
		log_warn("fts_open: %s", path);
		return (-1);
	}

	while ((e = fts_read(fts)) != NULL) {
		switch (e->fts_info) {
		case FTS_D:
			depth++;
			break;
		case FTS_DP:
		case FTS_DNR:
			depth--;
			if (keepdir && depth == 0)
				continue;
			if (rmdir(e->fts_path) == -1) {
				log_warn("rmdir: %s", e->fts_path);
				ret = -1;
			}
			break;

		case FTS_F:
			if (unlink(e->fts_path) == -1) {
				log_warn("unlink: %s", e->fts_path);
				ret = -1;
			}
		}
	}

	fts_close(fts);

	return (ret);
}

int
mvpurge(char *from, char *to)
{
	size_t		 n;
	int		 retry;
	const char	*sep;
	char		 buf[PATH_MAX];

	if ((n = strlen(to)) == 0)
		fatalx("to is empty");

	sep = (to[n - 1] == '/') ? "" : "/";
	retry = 0;

again:
	(void)snprintf(buf, sizeof buf, "%s%s%u", to, sep, arc4random());
	if (rename(from, buf) == -1) {
		/* ENOTDIR has actually 2 meanings, and incorrect input
		 * could lead to an infinite loop. Consider that after
		 * 20 tries something is hopelessly wrong.
		 */
		if (errno == ENOTEMPTY || errno == EISDIR || errno == ENOTDIR) {
			if ((retry++) >= 20)
				return (-1);
			goto again;
		}
		return -1;
	}

	return 0;
}


int
mktmpfile(void)
{
	char		path[PATH_MAX];
	int		fd;

	if (!bsnprintf(path, sizeof(path), "%s/smtpd.XXXXXXXXXX",
		PATH_TEMPORARY)) {
		log_warn("snprintf");
		fatal("exiting");
	}

	if ((fd = mkstemp(path)) == -1) {
		log_warn("cannot create temporary file %s", path);
		fatal("exiting");
	}
	unlink(path);
	return (fd);
}


/* Close file, signifying temporary error condition (if any) to the caller. */
int
safe_fclose(FILE *fp)
{
	if (ferror(fp)) {
		fclose(fp);
		return 0;
	}
	if (fflush(fp)) {
		fclose(fp);
		if (errno == ENOSPC)
			return 0;
		fatal("safe_fclose: fflush");
	}
	if (fsync(fileno(fp)))
		fatal("safe_fclose: fsync");
	if (fclose(fp))
		fatal("safe_fclose: fclose");

	return 1;
}

int
hostname_match(const char *hostname, const char *pattern)
{
	while (*pattern != '\0' && *hostname != '\0') {
		if (*pattern == '*') {
			while (*pattern == '*')
				pattern++;
			while (*hostname != '\0' &&
			    tolower((unsigned char)*hostname) !=
			    tolower((unsigned char)*pattern))
				hostname++;
			continue;
		}

		if (tolower((unsigned char)*pattern) !=
		    tolower((unsigned char)*hostname))
			return 0;
		pattern++;
		hostname++;
	}

	return (*hostname == '\0' && *pattern == '\0');
}

int
mailaddr_match(const struct mailaddr *maddr1, const struct mailaddr *maddr2)
{
	struct mailaddr m1 = *maddr1;
	struct mailaddr m2 = *maddr2;
	char	       *p;

	/* catchall */
	if (m2.user[0] == '\0' && m2.domain[0] == '\0')
		return 1;

	if (!hostname_match(m1.domain, m2.domain))
		return 0;

	if (m2.user[0]) {
		/* if address from table has a tag, we must respect it */
		if (strchr(m2.user, *env->sc_subaddressing_delim) == NULL) {
			/* otherwise, strip tag from session address if any */
			p = strchr(m1.user, *env->sc_subaddressing_delim);
			if (p)
				*p = '\0';
		}
		if (strcasecmp(m1.user, m2.user))
			return 0;
	}
	return 1;
}

int
valid_localpart(const char *s)
{
#define IS_ATEXT(c) (isalnum((unsigned char)(c)) || strchr(MAILADDR_ALLOWED, (c)))
nextatom:
	if (!IS_ATEXT(*s) || *s == '\0')
		return 0;
	while (*(++s) != '\0') {
		if (*s == '.')
			break;
		if (IS_ATEXT(*s))
			continue;
		return 0;
	}
	if (*s == '.') {
		s++;
		goto nextatom;
	}
	return 1;
}

int
valid_domainpart(const char *s)
{
	struct in_addr	 ina;
	struct in6_addr	 ina6;
	char		*c, domain[SMTPD_MAXDOMAINPARTSIZE];
	const char	*p;

	if (*s == '[') {
		if (strncasecmp("[IPv6:", s, 6) == 0)
			p = s + 6;
		else
			p = s + 1;

		if (strlcpy(domain, p, sizeof domain) >= sizeof domain)
			return 0;

		c = strchr(domain, (int)']');
		if (!c || c[1] != '\0')
			return 0;

		*c = '\0';

		if (inet_pton(AF_INET6, domain, &ina6) == 1)
			return 1;
		if (inet_pton(AF_INET, domain, &ina) == 1)
			return 1;

		return 0;
	}

	if (*s == '\0')
		return 0;

	return res_hnok(s);
}

int
secure_file(int fd, char *path, char *userdir, uid_t uid, int mayread)
{
	char		 buf[PATH_MAX];
	char		 homedir[PATH_MAX];
	struct stat	 st;
	char		*cp;

	if (realpath(path, buf) == NULL)
		return 0;

	if (realpath(userdir, homedir) == NULL)
		homedir[0] = '\0';

	/* Check the open file to avoid races. */
	if (fstat(fd, &st) < 0 ||
	    !S_ISREG(st.st_mode) ||
	    st.st_uid != uid ||
	    (st.st_mode & (mayread ? 022 : 066)) != 0)
		return 0;

	/* For each component of the canonical path, walking upwards. */
	for (;;) {
		if ((cp = dirname(buf)) == NULL)
			return 0;
		(void)strlcpy(buf, cp, sizeof(buf));

		if (stat(buf, &st) < 0 ||
		    (st.st_uid != 0 && st.st_uid != uid) ||
		    (st.st_mode & 022) != 0)
			return 0;

		/* We can stop checking after reaching homedir level. */
		if (strcmp(homedir, buf) == 0)
			break;

		/*
		 * dirname should always complete with a "/" path,
		 * but we can be paranoid and check for "." too
		 */
		if ((strcmp("/", buf) == 0) || (strcmp(".", buf) == 0))
			break;
	}

	return 1;
}

void
addargs(arglist *args, char *fmt, ...)
{
	va_list ap;
	char *cp;
	uint nalloc;
	int r;
	char	**tmp;

	va_start(ap, fmt);
	r = vasprintf(&cp, fmt, ap);
	va_end(ap);
	if (r == -1)
		fatal("addargs: argument too long");

	nalloc = args->nalloc;
	if (args->list == NULL) {
		nalloc = 32;
		args->num = 0;
	} else if (args->num+2 >= nalloc)
		nalloc *= 2;

	tmp = reallocarray(args->list, nalloc, sizeof(char *));
	if (tmp == NULL)
		fatal("addargs: reallocarray");
	args->list = tmp;
	args->nalloc = nalloc;
	args->list[args->num++] = cp;
	args->list[args->num] = NULL;
}

int
lowercase(char *buf, const char *s, size_t len)
{
	if (len == 0)
		return 0;

	if (strlcpy(buf, s, len) >= len)
		return 0;

	while (*buf != '\0') {
		*buf = tolower((unsigned char)*buf);
		buf++;
	}

	return 1;
}

int
uppercase(char *buf, const char *s, size_t len)
{
	if (len == 0)
		return 0;

	if (strlcpy(buf, s, len) >= len)
		return 0;

	while (*buf != '\0') {
		*buf = toupper((unsigned char)*buf);
		buf++;
	}

	return 1;
}

void
xlowercase(char *buf, const char *s, size_t len)
{
	if (len == 0)
		fatalx("lowercase: len == 0");

	if (!lowercase(buf, s, len))
		fatalx("lowercase: truncation");
}

uint64_t
generate_uid(void)
{
	static uint32_t id;
	static uint8_t	inited;
	uint64_t	uid;

	if (!inited) {
		id = arc4random();
		inited = 1;
	}
	while ((uid = ((uint64_t)(id++) << 32 | arc4random())) == 0)
		;

	return (uid);
}

int
session_socket_error(int fd)
{
	int		error;
	socklen_t	len;

	len = sizeof(error);
	if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &error, &len) == -1)
		fatal("session_socket_error: getsockopt");

	return (error);
}

const char *
parse_smtp_response(char *line, size_t len, char **msg, int *cont)
{
	size_t	 i;

	if (len >= LINE_MAX)
		return "line too long";

	if (len > 3) {
		if (msg)
			*msg = line + 4;
		if (cont)
			*cont = (line[3] == '-');
	} else if (len == 3) {
		if (msg)
			*msg = line + 3;
		if (cont)
			*cont = 0;
	} else
		return "line too short";

	/* validate reply code */
	if (line[0] < '2' || line[0] > '5' || !isdigit((unsigned char)line[1]) ||
	    !isdigit((unsigned char)line[2]))
		return "reply code out of range";

	/* validate reply message */
	for (i = 0; i < len; i++)
		if (!isprint((unsigned char)line[i]))
			return "non-printable character in reply";

	return NULL;
}

static int
parse_mailname_file(char *hostname, size_t len)
{
	FILE	*fp;
	char	*buf = NULL;
	size_t	 bufsz = 0;
	ssize_t	 buflen;

	if ((fp = fopen(MAILNAME_FILE, "r")) == NULL)
		return 1;

	if ((buflen = getline(&buf, &bufsz, fp)) == -1)
		goto error;

	if (buf[buflen - 1] == '\n')
		buf[buflen - 1] = '\0';

	if (strlcpy(hostname, buf, len) >= len) {
		fprintf(stderr, MAILNAME_FILE " entry too long");
		goto error;
	}

	return 0;
error:
	fclose(fp);
	free(buf);
	return 1;
}

int
getmailname(char *hostname, size_t len)
{
	struct addrinfo	 hints, *res = NULL;
	int		 error;

	/* Try MAILNAME_FILE first */
	if (parse_mailname_file(hostname, len) == 0)
		return 0;

	/* Next, gethostname(3) */
	if (gethostname(hostname, len) == -1) {
		fprintf(stderr, "getmailname: gethostname() failed\n");
		return -1;
	}

	if (strchr(hostname, '.') != NULL)
		return 0;

	/* Canonicalize if domain part is missing */
	memset(&hints, 0, sizeof hints);
	hints.ai_family = PF_UNSPEC;
	hints.ai_flags = AI_CANONNAME;
	error = getaddrinfo(hostname, NULL, &hints, &res);
	if (error)
		return 0; /* Continue with non-canon hostname */

	if (strlcpy(hostname, res->ai_canonname, len) >= len) {
		fprintf(stderr, "hostname too long");
		return -1;
	}

	freeaddrinfo(res);
	return 0;
}

int
base64_encode(unsigned char const *src, size_t srclen,
	      char *dest, size_t destsize)
{
	return __b64_ntop(src, srclen, dest, destsize);
}

int
base64_decode(char const *src, unsigned char *dest, size_t destsize)
{
	return __b64_pton(src, dest, destsize);
}

void
log_trace(int mask, const char *emsg, ...)
{
	va_list	 ap;

	if (tracing & mask) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

void
log_trace_verbose(int v)
{
	tracing = v;

	/* Set debug logging in log.c */
	log_setverbose(v & TRACE_DEBUG ? 2 : foreground_log);
}
@


1.131
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.130 2016/11/30 18:38:32 eric Exp $	*/
d815 1
a815 1
	log_verbose(v & TRACE_DEBUG ? 2 : foreground_log);
@


1.130
log
@remove unused iobuf helpers
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.129 2016/11/17 17:34:55 eric Exp $	*/
d58 3
d795 21
@


1.129
log
@Add io api functions for dealing with buffered data, as wrapper around
their iobuf counterparts.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.128 2016/08/31 10:18:08 gilles Exp $	*/
a111 25
void
iobuf_xinit(struct iobuf *io, size_t size, size_t max, const char *where)
{
	if (iobuf_init(io, size, max) == -1) {
		log_warnx("%s: iobuf_init(%p, %zu, %zu)", where, io, size, max);
		fatalx("exiting");
	}
}

void
iobuf_xfqueue(struct iobuf *io, const char *where, const char *fmt, ...)
{
	va_list	ap;
	int	len;

	va_start(ap, fmt);
	len = iobuf_vfqueue(io, fmt, ap);
	va_end(ap);

	if (len == -1) {
		log_warnx("%s: iobuf_xfqueue(%p, %s, ...)", where, io, fmt);
		fatalx("exiting");
	}
}

@


1.128
log
@allow overriding the subaddressing delimiter with subaddressing-delimiter
keyword, the default is still +

ok eric@@, sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.127 2016/05/16 17:43:18 gilles Exp $	*/
d135 27
@


1.127
log
@replace hardcoded + with TAG_CHAR
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.126 2016/03/25 15:06:58 krw Exp $	*/
d458 1
a458 1
		if (strchr(m2.user, TAG_CHAR) == NULL) {
d460 1
a460 1
			p = strchr(m1.user, TAG_CHAR);
@


1.126
log
@Nuke session_socket_blockmode() and session_socket_linger(). Use
the identical io_set_blocking() and io_set_linger().

Since both are always called to turn off blocking or lingering,
nuke the parameter and associated enum in favour of "just doing the
right thing".

While passing remove the unneeded last parameter to the remaining
fcntl(F_GETFL).

Finally, rename the functions to io_set_nonblocking() and
io_set_nolinger() for clarity.

No functional change.

Started with a sweep of fcntl() usage inspired by guenther@@.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.125 2016/01/12 17:29:43 sunil Exp $	*/
d458 1
a458 1
		if (strchr(m2.user, '+') == NULL) {
d460 1
a460 1
			p = strchr(m1.user, '+');
@


1.125
log
@Let smtpd start on machines without a FQDN as hostname.

Ok millert@@ gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.124 2015/12/28 22:08:30 jung Exp $	*/
a664 27
}

void
session_socket_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
}

void
session_socket_no_linger(int fd)
{
	struct linger	 lng;

	memset(&lng, 0, sizeof(lng));
	if (setsockopt(fd, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1)
		fatal("session_socket_no_linger");
@


1.124
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.123 2015/12/14 10:22:12 jung Exp $	*/
d56 1
d741 2
a742 2
int
getmailname(char *hostname, size_t len)
a743 1
	struct addrinfo	hints, *res = NULL;
a747 1
	int	 error, ret = 0;
a748 1
	/* First, check if we have MAILNAME_FILE */
d750 1
a750 1
		goto nomailname;
d753 1
a753 1
		goto end;
d758 1
a758 1
	if (strlcpy(hostname, buf, len) >= len)
d760 1
a760 3
	else {
		ret = 1;
		goto end;
d763 18
a780 1
nomailname:
d782 2
a783 2
		fprintf(stderr, "invalid hostname: gethostname() failed\n");
		goto end;
d786 10
a795 12
	if (strchr(hostname, '.') == NULL) {
		memset(&hints, 0, sizeof hints);
		hints.ai_family = PF_UNSPEC;
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_protocol = IPPROTO_TCP;
		hints.ai_flags = AI_CANONNAME;
		error = getaddrinfo(hostname, NULL, &hints, &res);
		if (error) {
			fprintf(stderr, "invalid hostname: getaddrinfo() failed: %s\n",
			    gai_strerror(error));
			goto end;
		}
d797 3
a799 4
		if (strlcpy(hostname, res->ai_canonname, len) >= len) {
			fprintf(stderr, "hostname too long");
			goto end;
		}
d802 2
a803 9
	ret = 1;

end:
	free(buf);
	if (res)
		freeaddrinfo(res);
	if (fp)
		fclose(fp);
	return ret;
@


1.123
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.122 2015/10/17 22:24:36 gilles Exp $	*/
d181 1
a181 1
	else if (! S_ISDIR(sb.st_mode))
d207 1
a207 1
				if (! mkdirs_component(buf, mode))
d219 2
a220 2
	if (! done)
		if (! mkdirs_component(buf, mode))
d380 1
a380 1
	if (! bsnprintf(path, sizeof(path), "%s/smtpd.XXXXXXXXXX",
d452 1
a452 1
	if (! hostname_match(m1.domain, m2.domain))
d474 1
a474 1
	if (! IS_ATEXT(*s) || *s == '\0')
d645 1
a645 1
	if (! lowercase(buf, s, len))
@


1.122
log
@mailaddr_match() allows comparing two struct mailaddr taking into account
catchall and +-tags

ok millert@@ and jung@@ for util.c
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.121 2015/10/17 12:59:52 gilles Exp $	*/
d503 1
a503 1
	
d510 1
a510 1
		
d512 1
a512 1
		
d517 1
a517 1
		
@


1.121
log
@our strip() function should use isspace()

ok jung@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.120 2015/10/12 07:58:19 deraadt Exp $	*/
a228 1

d439 28
@


1.120
log
@do not umask() [with the wrong umask] around mkstemp() calls, no matter
how broken other systems are.
ok guenther gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.119 2015/10/10 11:42:49 jung Exp $	*/
d142 1
a142 1
	while (*s == ' ' || *s == '\t')
d146 1
a146 1
		if (s[l-1] != ' ' && s[l-1] != '\t')
d199 1
a199 1
	/* make sure we don't exceed SMTPD_MAXPATHLEN */
@


1.119
log
@three conversions of fgetln() to getline()

ok eric sunil
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.118 2015/10/06 06:04:46 gilles Exp $	*/
a379 1
	mode_t		omode;
a386 1
	omode = umask(07077);
a390 1
	umask(omode);
@


1.118
log
@fix values passed to umask(), they should be octal.
the permissions are even more restrictive than they should.

misc bug reported by qualys
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.117 2015/10/06 05:48:34 gilles Exp $	*/
d721 3
a723 2
	char	*buf, *lbuf = NULL;
	size_t	 buflen;
d730 1
a730 1
	if ((buf = fgetln(fp, &buflen)) == NULL)
d733 1
a733 1
	if (buf[buflen-1] == '\n')
a734 8
	else {
		if ((lbuf = calloc(buflen + 1, 1)) == NULL) {
			log_warn("calloc");
			fatal("exiting");
		}
		memcpy(lbuf, buf, buflen);
		buf = lbuf;
	}
d771 1
a771 1
	free(lbuf);
@


1.117
log
@fix reallocarray() constructs to always use temporary variable
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.116 2015/10/05 22:08:14 stsp Exp $	*/
d388 1
a388 1
	omode = umask(7077);
@


1.116
log
@actually use lbuf in getmailname()
ok millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.115 2015/10/02 00:41:25 gilles Exp $	*/
d557 1
d572 2
a573 2
	args->list = reallocarray(args->list, nalloc, sizeof(char *));
	if (args->list == NULL)
d575 1
@


1.115
log
@in secure_file(), make uid checking on .forward files more strict to avoid
users creating hardlink to root-owned files and leaking first line.

reported by Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.114 2015/08/16 20:53:19 gilles Exp $	*/
d738 1
@


1.114
log
@when we switch valid_domainpart() from our own logic to using res_hnok() we
missed the fact that res_hnok() will consider an empty string as valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.113 2015/05/06 08:37:47 gilles Exp $	*/
a502 3
/*
 * Check file for security. Based on usr.bin/ssh/auth.c.
 */
d520 1
a520 1
	    (st.st_uid != 0 && st.st_uid != uid) ||
@


1.113
log
@use res_hnok() to valid domain part in valid_domain()

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.112 2015/01/20 17:37:54 deraadt Exp $	*/
d496 3
@


1.113.4.1
log
@Errata 004:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.113 2015/05/06 08:37:47 gilles Exp $	*/
d500 3
d520 1
a520 1
	    st.st_uid != uid ||
@


1.112
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.111 2015/01/16 06:40:21 deraadt Exp $	*/
d496 2
a497 18
	
nextsub:
	if (!isalnum((unsigned char)*s))
		return 0;
	while (*(++s) != '\0') {
		if (*s == '.')
			break;
		if (isalnum((unsigned char)*s) || *s == '-')
			continue;
		return 0;
	}
	if (s[-1] == '-')
		return 0;
	if (*s == '.') {
		s++;
		goto nextsub;
	}
	return 1;
@


1.112.2.1
log
@Errata 017:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.112 2015/01/20 17:37:54 deraadt Exp $	*/
d516 3
d536 1
a536 1
	    st.st_uid != uid ||
@


1.111
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.110 2014/05/25 10:55:36 espie Exp $	*/
d190 1
a190 1
	char	 buf[SMTPD_MAXPATHLEN];
d348 1
a348 1
	char		 buf[SMTPD_MAXPATHLEN];
d378 1
a378 1
	char		path[SMTPD_MAXPATHLEN];
d701 1
a701 1
	if (len >= SMTPD_MAXLINESIZE)
@


1.110
log
@use reallocarray.
okay gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.109 2014/04/19 14:32:03 gilles Exp $	*/
d42 1
@


1.110.4.1
log
@Errata 031:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.110 2014/05/25 10:55:36 espie Exp $	*/
d515 3
d535 1
a535 1
	    st.st_uid != uid ||
@


1.109
log
@(void) cast a strlcpy that cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.108 2014/02/04 10:38:06 eric Exp $	*/
d586 1
a586 3
	if (SIZE_T_MAX / nalloc < sizeof(char *))
		fatalx("addargs: nalloc * size > SIZE_T_MAX");
	args->list = realloc(args->list, nalloc * sizeof(char *));
d588 1
a588 1
		fatal("addargs: realloc");
@


1.108
log
@extend allowed charset for email address, escape all potentially dangerous ones.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d356 1
a356 1
	snprintf(buf, sizeof buf, "%s%s%u", to, sep, arc4random());
d543 1
a543 1
		strlcpy(buf, cp, sizeof(buf));
@


1.107
log
@add base64_encode/base64_decode helpers
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.106 2014/02/04 09:05:06 eric Exp $	*/
d447 1
a447 5
/*
 * RFC 5322 defines theses characters as valid: !#$%&'*+-/=?^_`{|}~
 * some of them are potentially dangerous, and not so used after all.
 */
#define IS_ATEXT(c) (isalnum((unsigned char)(c)) || strchr("*!%+-/=_", (c)))
@


1.106
log
@get rid of fdlimit()
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.105 2014/01/08 15:30:49 deraadt Exp $	*/
d42 1
d802 13
@


1.105
log
@ctype cleanup; ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.104 2013/12/26 17:25:32 eric Exp $	*/
a657 14
}

void
fdlimit(double percent)
{
	struct rlimit rl;

	if (percent < 0 || percent > 1)
		fatalx("fdlimit: parameter out of range");
	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("fdlimit: getrlimit");
	rl.rlim_cur = percent * rl.rlim_max;
	if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("fdlimit: setrlimit");
@


1.104
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.103 2013/11/28 10:43:37 eric Exp $	*/
d736 2
a737 2
	if (line[0] < '2' || line[0] > '5' || !isdigit(line[1]) ||
	    !isdigit(line[2]))
@


1.103
log
@unsigned char casts for ctype
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.102 2013/11/19 10:22:42 eric Exp $	*/
d201 1
a201 1
	bzero(buf, sizeof buf);
d696 1
a696 1
	bzero(&lng, sizeof(lng));
@


1.102
log
@Allow '*' in the user part of mailaddresses.  By default, potentially dangerous
characters are replaced when expanding for local deliveries, unless the "raw"
modifier is specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.101 2013/10/29 14:30:05 eric Exp $	*/
d427 2
a428 1
			    tolower((int)*hostname) != tolower((int)*pattern))
d433 2
a434 1
		if (tolower((int)*pattern) != tolower((int)*hostname))
d450 1
a450 1
#define IS_ATEXT(c)     (isalnum((int)(c)) || strchr("*!%+-/=_", (c)))
d500 1
a500 1
	if (!isalnum((int)*s))
d505 1
a505 1
		if (isalnum((int)*s) || *s == '-')
d609 1
a609 1
		*buf = tolower((int)*buf);
d626 1
a626 1
		*buf = toupper((int)*buf);
d742 1
a742 1
		if (!isprint(line[i]))
@


1.101
log
@use "/etc/mail/mailname" instead of "/etc/mailname" and make it a define.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d448 1
a448 1
#define IS_ATEXT(c)     (isalnum((int)(c)) || strchr("!%+-/=_", (c)))
@


1.100
log
@randomize counter part of generated uids
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.99 2013/10/27 18:50:59 eric Exp $	*/
d755 2
a756 2
	/* First, check if we have "/etc/mailname" */
	if ((fp = fopen("/etc/mailname", "r")) == NULL)
d773 1
a773 1
		fprintf(stderr, "/etc/mailname entry too long");
@


1.99
log
@use log_* functions instead of err*/warn*
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d645 1
d648 4
@


1.98
log
@local enqueuer improvements:

- parse the whole input before trying to establish the connection
  to the local socket: fixes timeout problems when reading the output
  of a long running program.

- use sendmail(8)-like exit status.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.97 2013/07/19 08:28:43 eric Exp $	*/
a32 1
#include <err.h>
d60 4
a63 2
	if ((r = malloc(size)) == NULL)
		errx(1, "%s: malloc(%zu)", where, size);
d73 4
a76 2
	if ((r = calloc(nmemb, size)) == NULL)
		errx(1, "%s: calloc(%zu, %zu)", where, nmemb, size);
d86 4
a89 2
	if ((r = strdup(str)) == NULL)
		errx(1, "%s: strdup(%p)", where, str);
d99 4
a102 2
	if ((r = malloc(size)) == NULL)
		errx(1, "%s: malloc(%zu)", where, size);
d112 4
a115 2
	if (iobuf_init(io, size, max) == -1)
		errx(1, "%s: iobuf_init(%p, %zu, %zu)", where, io, size, max);
d128 4
a131 2
	if (len == -1)
		errx(1, "%s: iobuf_xfqueue(%p, %s, ...)", where, io, fmt);
d237 1
a237 1
			warn("stat: %s", path);
d243 1
a243 1
			warn("mkdir: %s", path);
d248 1
a248 1
			warn("chown: %s", path);
d253 1
a253 1
			warn("chmod: %s", path);
d258 1
a258 1
			warn("stat: %s", path);
d268 1
a268 1
		warnx("%s is not a directory", path);
d274 1
a274 1
		warnx("%s is not owned by uid %d", path, owner);
d278 1
a278 1
		warnx("%s is not owned by gid %d", path, group);
d286 1
a286 1
		warnx("%s must be %s (%o)", path, mode_str + 1, mode);
d307 1
a307 1
		warn("fts_open: %s", path);
d322 1
a322 1
				warn("rmdir: %s", e->fts_path);
d329 1
a329 1
				warn("unlink: %s", e->fts_path);
d381 4
a384 2
		PATH_TEMPORARY))
		err(1, "snprintf");
d387 4
a390 2
	if ((fd = mkstemp(path)) == -1)
		err(1, "cannot create temporary file %s", path);
@


1.97
log
@add '!' in email addresses supported charset
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.96 2013/07/19 08:12:19 eric Exp $	*/
d724 69
@


1.96
log
@Introduce expand string modifiers
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.95 2013/07/19 07:37:29 eric Exp $	*/
d433 1
a433 1
#define IS_ATEXT(c)     (isalnum((int)(c)) || strchr("%+-/=_", (c)))
@


1.95
log
@get rid of sa_set_port() and its awfully contorted implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.94 2013/05/24 17:03:14 eric Exp $	*/
d593 17
@


1.94
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.92 2013/02/05 11:45:18 gilles Exp $	*/
a606 27
}

void
sa_set_port(struct sockaddr *sa, int port)
{
	char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
	struct addrinfo hints, *res;
	int error;

	error = getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf), NULL, 0,
	    NI_NUMERICHOST);
	if (error)
		fatalx("sa_set_port: getnameinfo failed");

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;

	snprintf(sbuf, sizeof(sbuf), "%d", port);

	error = getaddrinfo(hbuf, sbuf, &hints, &res);
	if (error)
		fatalx("sa_set_port: getaddrinfo failed");

	memcpy(sa, res->ai_addr, res->ai_addrlen);
	freeaddrinfo(res);
@


1.93
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@a22 1
#include <sys/param.h>
d177 1
a177 1
	char	 buf[MAXPATHLEN];
d186 1
a186 1
	/* make sure we don't exceed MAXPATHLEN */
d335 1
a335 1
	char		 buf[MAXPATHLEN];
d343 1
a343 1
    again:
d365 1
a365 1
	char		path[MAXPATHLEN];
d370 1
a370 1
	    PATH_TEMPORARY))
d456 2
a457 1
	char		*c, domain[MAX_DOMAINPART_SIZE];
d460 7
a466 1
		strlcpy(domain, s + 1, sizeof domain);
d471 1
a471 1

d473 1
a473 1

d478 1
a478 1

d481 1
a481 1

a500 1

d507 2
a508 2
	char		 buf[MAXPATHLEN];
	char		 homedir[MAXPATHLEN];
@


1.92
log
@- handle getaddrinfo() error as LKA_TEMPFAIL
- handle getsockname() error in smtp_connected()
- accept '/' as part of user-part, expand to ':' as done by qmail
- fix wrong check in mda leading to bogus Return-Path header
- fix aliases parsing when there's a white space between key and separator
- some cosmethic cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.91 2013/01/31 18:34:43 eric Exp $	*/
d702 1
a702 1
	if (len >= SMTP_LINE_MAX)
@


1.91
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.90 2013/01/26 09:37:24 gilles Exp $	*/
d434 1
a434 1
#define IS_ATEXT(c)     (isalnum((int)(c)) || strchr("%+-=_", (c)))
@


1.90
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.88 2012/11/12 14:58:53 eric Exp $	*/
d368 1
d374 1
d377 1
a377 1

@


1.89
log
@knf

ok gilles@@
@
text
@d5 1
a5 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
a56 2
static int temp_inet_net_pton_ipv6(const char *, void *, size_t);

d125 17
d293 1
a293 1
	depth = 1;
d295 2
a296 1
	if ((fts = fts_open(path_argv, FTS_PHYSICAL, NULL)) == NULL) {
d302 6
a307 1
		if (e->fts_number) {
d309 1
a309 1
			if (keepdir && e->fts_number == 1)
d315 1
a315 2
			continue;
		}
d317 5
a321 8
		if (S_ISDIR(e->fts_statp->st_mode)) {
			e->fts_number = depth++;
			continue;
		}

		if (unlink(e->fts_path) == -1) {
			warn("unlink: %s", e->fts_path);
			ret = -1;
a492 267
int
email_to_mailaddr(struct mailaddr *maddr, char *email)
{
	char *username;
	char *hostname;

	username = email;
	hostname = strrchr(username, '@@');

	if (username[0] == '\0') {
		*maddr->user = '\0';
		*maddr->domain = '\0';
		return 1;
	}

	if (hostname == NULL) {
		if (strcasecmp(username, "postmaster") != 0)
			return 0;
		hostname = "localhost";
	} else {
		*hostname++ = '\0';
	}

	if (strlcpy(maddr->user, username, sizeof(maddr->user))
	    >= sizeof(maddr->user))
		return 0;

	if (strlcpy(maddr->domain, hostname, sizeof(maddr->domain))
	    >= sizeof(maddr->domain))
		return 0;

	return 1;
}

char *
ss_to_text(const struct sockaddr_storage *ss)
{
	static char	 buf[NI_MAXHOST + 5];
	char		*p;

	buf[0] = '\0';
	p = buf;

	if (ss->ss_family == AF_LOCAL)
		strlcpy(buf, "local", sizeof buf);
	else if (ss->ss_family == AF_INET) {
		in_addr_t addr;

		addr = ((const struct sockaddr_in *)ss)->sin_addr.s_addr;
		addr = ntohl(addr);
		bsnprintf(p, NI_MAXHOST, "%d.%d.%d.%d",
		    (addr >> 24) & 0xff, (addr >> 16) & 0xff,
		    (addr >> 8) & 0xff, addr & 0xff);
	}
	else if (ss->ss_family == AF_INET6) {
		const struct sockaddr_in6 *in6;
		const struct in6_addr	*in6_addr;

		in6 = (const struct sockaddr_in6 *)ss;
		strlcpy(buf, "IPv6:", sizeof(buf));
		p = buf + 5;
		in6_addr = &in6->sin6_addr;
		bsnprintf(p, NI_MAXHOST, "%s", log_in6addr(in6_addr));
	}

	return (buf);
}

char *
time_to_text(time_t when)
{
	struct tm *lt;
	static char buf[40];
	char *day[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	char *month[] = {"Jan","Feb","Mar","Apr","May","Jun",
			 "Jul","Aug","Sep","Oct","Nov","Dec"};

	lt = localtime(&when);
	if (lt == NULL || when == 0)
		fatalx("time_to_text: localtime");

	/* We do not use strftime because it is subject to locale substitution*/
	if (! bsnprintf(buf, sizeof(buf),
	    "%s, %d %s %d %02d:%02d:%02d %c%02d%02d (%s)",
	    day[lt->tm_wday], lt->tm_mday, month[lt->tm_mon],
	    lt->tm_year + 1900,
	    lt->tm_hour, lt->tm_min, lt->tm_sec,
	    lt->tm_gmtoff >= 0 ? '+' : '-',
	    abs((int)lt->tm_gmtoff / 3600),
	    abs((int)lt->tm_gmtoff % 3600) / 60,
	    lt->tm_zone))
		fatalx("time_to_text: bsnprintf");

	return buf;
}

char *
duration_to_text(time_t t)
{
	static char	dst[64];
	char		buf[64];
	int		d, h, m, s;

	if (t == 0) {
		strlcpy(dst, "0s", sizeof dst);
		return (dst);
	}

	dst[0] = '\0';
	if (t < 0) {
		strlcpy(dst, "-", sizeof dst);
		t = -t;
	}

	s = t % 60;
	t /= 60;
	m = t % 60;
	t /= 60;
	h = t % 24;
	d = t / 24;

	if (d) {
		snprintf(buf, sizeof buf, "%id", d);
		strlcat(dst, buf, sizeof dst);
	}
	if (h) {
		snprintf(buf, sizeof buf, "%ih", h);
		strlcat(dst, buf, sizeof dst);
	}
	if (m) {
		snprintf(buf, sizeof buf, "%im", m);
		strlcat(dst, buf, sizeof dst);
	}
	if (s) {
		snprintf(buf, sizeof buf, "%is", s);
		strlcat(dst, buf, sizeof dst);
	}

	return (dst);
}

int
text_to_netaddr(struct netaddr *netaddr, const char *s)
{
	struct sockaddr_storage	ss;
	struct sockaddr_in	ssin;
	struct sockaddr_in6	ssin6;
	int			bits;

	if (strncmp("IPv6:", s, 5) == 0)
		s += 5;

	if (strchr(s, '/') != NULL) {
		/* dealing with netmask */

		bzero(&ssin, sizeof(struct sockaddr_in));
		bits = inet_net_pton(AF_INET, s, &ssin.sin_addr,
		    sizeof(struct in_addr));

		if (bits != -1) {
			ssin.sin_family = AF_INET;
			memcpy(&ss, &ssin, sizeof(ssin));
			ss.ss_len = sizeof(struct sockaddr_in);
		}
		else {
			bzero(&ssin6, sizeof(struct sockaddr_in6));
			bits = inet_net_pton(AF_INET6, s, &ssin6.sin6_addr,
			    sizeof(struct in6_addr));
			if (bits == -1) {

				/* XXX - until AF_INET6 support gets in base */
				if (errno != EAFNOSUPPORT) {
					log_warn("warn: inet_net_pton");
					return 0;
				}
				bits = temp_inet_net_pton_ipv6(s,
				    &ssin6.sin6_addr,
				    sizeof(struct in6_addr));
			}
			if (bits == -1) {
				log_warn("warn: inet_net_pton");
				return 0;
			}
			ssin6.sin6_family = AF_INET6;
			memcpy(&ss, &ssin6, sizeof(ssin6));
			ss.ss_len = sizeof(struct sockaddr_in6);
		}
	}
	else {
		/* IP address ? */
		if (inet_pton(AF_INET, s, &ssin.sin_addr) == 1) {
			ssin.sin_family = AF_INET;
			bits = 32;
			memcpy(&ss, &ssin, sizeof(ssin));
			ss.ss_len = sizeof(struct sockaddr_in);
		}
		else if (inet_pton(AF_INET6, s, &ssin6.sin6_addr) == 1) {
			ssin6.sin6_family = AF_INET6;
			bits = 128;
			memcpy(&ss, &ssin6, sizeof(ssin6));
			ss.ss_len = sizeof(struct sockaddr_in6);
		}
		else return 0;
	}

	netaddr->ss   = ss;
	netaddr->bits = bits;
	return 1;
}

int
text_to_relayhost(struct relayhost *relay, const char *s)
{
	static const struct schema {
		const char	*name;
		uint8_t		 flags;
	} schemas [] = {
		{ "smtp://",		0				},
		{ "smtps://",		F_SMTPS				},
		{ "tls://",		F_STARTTLS			},
		{ "smtps+auth://",	F_SMTPS|F_AUTH			},
		{ "tls+auth://",	F_STARTTLS|F_AUTH		},
		{ "ssl://",		F_SMTPS|F_STARTTLS		},
		{ "ssl+auth://",	F_SMTPS|F_STARTTLS|F_AUTH	}
	};
	const char	*errstr = NULL;
	const char	*p;
	char		*sep;
	size_t		 i;
	int		 len;

	for (i = 0; i < nitems(schemas); ++i)
		if (strncasecmp(schemas[i].name, s,
		    strlen(schemas[i].name)) == 0)
			break;

	if (i == nitems(schemas)) {
		/* there is a schema, but it's not recognized */
		if (strstr(s, "://"))
			return 0;

		/* no schema, default to smtp:// */
		i = 0;
		p = s;
	}
	else
		p = s + strlen(schemas[i].name);

	relay->flags = schemas[i].flags;

	if ((sep = strrchr(p, ':')) != NULL) {
		relay->port = strtonum(sep+1, 1, 0xffff, &errstr);
		if (errstr)
			return 0;
		len = sep - p;
	}
	else
		len = strlen(p);

	if (strlcpy(relay->hostname, p, sizeof (relay->hostname))
	    >= sizeof (relay->hostname))
		return 0;

	relay->hostname[len] = 0;

	return 1;
}
a695 47
log_in6addr(const struct in6_addr *addr)
{
	struct sockaddr_in6	sa_in6;
	uint16_t		tmp16;

	bzero(&sa_in6, sizeof(sa_in6));
	sa_in6.sin6_len = sizeof(sa_in6);
	sa_in6.sin6_family = AF_INET6;
	memcpy(&sa_in6.sin6_addr, addr, sizeof(sa_in6.sin6_addr));

	/* XXX thanks, KAME, for this ugliness... adopted from route/show.c */
	if (IN6_IS_ADDR_LINKLOCAL(&sa_in6.sin6_addr) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&sa_in6.sin6_addr)) {
		memcpy(&tmp16, &sa_in6.sin6_addr.s6_addr[2], sizeof(tmp16));
		sa_in6.sin6_scope_id = ntohs(tmp16);
		sa_in6.sin6_addr.s6_addr[2] = 0;
		sa_in6.sin6_addr.s6_addr[3] = 0;
	}

	return (log_sockaddr((struct sockaddr *)&sa_in6));
}

const char *
log_sockaddr(struct sockaddr *sa)
{
	static char	buf[NI_MAXHOST];

	if (getnameinfo(sa, sa->sa_len, buf, sizeof(buf), NULL, 0,
	    NI_NUMERICHOST))
		return ("(unknown)");
	else
		return (buf);
}

uint32_t
evpid_to_msgid(uint64_t evpid)
{
	return (evpid >> 32);
}

uint64_t
msgid_to_evpid(uint32_t msgid)
{
	return ((uint64_t)msgid << 32);
}

const char *
a726 95
}

static int
temp_inet_net_pton_ipv6(const char *src, void *dst, size_t size)
{
	int	ret;
	int	bits;
	char	buf[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255:255:255:255/128")];
	char		*sep;
	const char	*errstr;

	if (strlcpy(buf, src, sizeof buf) >= sizeof buf) {
		errno = EMSGSIZE;
		return (-1);
	}

	sep = strchr(buf, '/');
	if (sep != NULL)
		*sep++ = '\0';

	ret = inet_pton(AF_INET6, buf, dst);
	if (ret != 1)
		return (-1);

	if (sep == NULL)
		return 128;

	bits = strtonum(sep, 0, 128, &errstr);
	if (errstr)
		return (-1);

	return bits;
}

void
log_envelope(const struct envelope *evp, const char *extra, const char *prefix,
    const char *status)
{
	char rcpt[MAX_LINE_SIZE];
	char tmp[MAX_LINE_SIZE];
	const char *method;

	tmp[0] = '\0';
	rcpt[0] = '\0';
	if (strcmp(evp->rcpt.user, evp->dest.user) ||
	    strcmp(evp->rcpt.domain, evp->dest.domain))
		snprintf(rcpt, sizeof rcpt, "rcpt=<%s@@%s>, ",
		    evp->rcpt.user, evp->rcpt.domain);

	if (evp->type == D_MDA) {
		if (evp->agent.mda.method == A_MAILDIR)
			method = "maildir";
		else if (evp->agent.mda.method == A_MBOX)
			method = "mbox";
		else if (evp->agent.mda.method == A_FILENAME)
			method = "file";
		else if (evp->agent.mda.method == A_MDA)
			method = "mda";
		else
			fatalx("log_envelope: bad method");
		snprintf(tmp, sizeof tmp, "user=%s, method=%s, ",
		    evp->agent.mda.user, method);
	}

	if (extra == NULL)
		extra = "";

	log_info("%s: %s for %016" PRIx64 ": from=<%s@@%s>, to=<%s@@%s>, "
	    "%s%sdelay=%s, %sstat=%s",
	    evp->type == D_MDA ? "delivery" : "relay",
	    prefix,
	    evp->id, evp->sender.user, evp->sender.domain,
	    evp->dest.user, evp->dest.domain,
	    rcpt,
	    tmp,
	    duration_to_text(time(NULL) - evp->creation),
	    extra,
	    status);
}

uint64_t
strtoevpid(const char *s)
{
	uint64_t ulval;
	char	 *ep;

	errno = 0;
	ulval = strtoull(s, &ep, 16);
	if (s[0] == '\0' || *ep != '\0')
		errx(1, "invalid msgid/evpid");
	if (errno == ERANGE && ulval == ULLONG_MAX)
		errx(1, "invalid msgid/evpid");
	if (ulval == 0)
		errx(1, "invalid msgid/evpid");
	return (ulval);
@


1.88
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.87 2012/10/10 19:39:11 gilles Exp $	*/
d352 2
a353 1
	if (! bsnprintf(path, sizeof(path), "%s/smtpd.XXXXXXXXXX", PATH_TEMPORARY))
d417 14
a430 14
        if (! IS_ATEXT(*s) || *s == '\0')
                return 0;
        while (*(++s) != '\0') {
                if (*s == '.')
                        break;
                if (IS_ATEXT(*s))
                        continue;
                return 0;
        }
        if (*s == '.') {
                s++;
                goto nextatom;
        }
        return 1;
d458 12
a469 12
        if (!isalnum((int)*s))
                return 0;
        while (*(++s) != '\0') {
                if (*s == '.')
                        break;
                if (isalnum((int)*s) || *s == '-')
                        continue;
                return 0;
        }
        if (s[-1] == '-')
                return 0;
        if (*s == '.') {
d471 1
a471 1
                goto nextsub;
d473 1
a473 1
        return 1;
d519 1
a519 1
	if (ss->ss_family == AF_LOCAL) {
a520 1
	}
d523 1
a523 1
		
d525 4
a528 7
                addr = ntohl(addr);
                bsnprintf(p, NI_MAXHOST,
                    "%d.%d.%d.%d",
                    (addr >> 24) & 0xff,
                    (addr >> 16) & 0xff,
                    (addr >> 8) & 0xff,
                    addr & 0xff);
d531 1
a531 1
		const struct sockaddr_in6 *in6 = (const struct sockaddr_in6 *)ss;
d534 1
d548 1
a548 1
	static char buf[40]; 
d551 1
a551 1
		       "Jul","Aug","Sep","Oct","Nov","Dec"};
d554 1
a554 1
	if (lt == NULL || when == 0) 
d558 9
a566 8
	if (! bsnprintf(buf, sizeof(buf), "%s, %d %s %d %02d:%02d:%02d %c%02d%02d (%s)",
		day[lt->tm_wday], lt->tm_mday, month[lt->tm_mon],
		lt->tm_year + 1900,
		lt->tm_hour, lt->tm_min, lt->tm_sec,
		lt->tm_gmtoff >= 0 ? '+' : '-',
		abs((int)lt->tm_gmtoff / 3600),
		abs((int)lt->tm_gmtoff % 3600) / 60,
		lt->tm_zone))
d568 1
a568 1
	
d696 1
a696 1
		{ "smtps+auth://",     	F_SMTPS|F_AUTH			},
d708 2
a709 1
		if (strncasecmp(schemas[i].name, s, strlen(schemas[i].name)) == 0)
d732 1
a732 1
	else 
d859 2
a860 1
	error = getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
d1091 2
a1092 1
	log_info("%s: %s for %016" PRIx64 ": from=<%s@@%s>, to=<%s@@%s>, %s%sdelay=%s, %sstat=%s",
@


1.87
log
@teach smtpctl how to display envelopes and messages using their id.
this allows an admin to inspect the queue without having to manually
extract bucket and find the path to an envelope or message.

diff by Sunil Nimmagadda <sunil@@poolp.org>

ok eric@@, chl@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.86 2012/10/07 15:46:38 chl Exp $	*/
d649 1
a649 1
					log_warn("inet_net_pton");
d657 1
a657 1
				log_warn("inet_net_pton");
d1058 2
a1059 1
log_envelope(const struct envelope *evp, const char *extra, const char *status)
d1090 3
a1092 1
	log_info("%016" PRIx64 ": from=<%s@@%s>, to=<%s@@%s>, %s%sdelay=%s, %sstat=%s",
@


1.86
log
@convert iobuf_queue()'s to iobuf_fqueue(). (idea from gilles@@)
introduce iobuf_xinit() and iobuf_xfqueue(). (idea from eric@@)

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.85 2012/10/04 12:17:09 todd Exp $	*/
d1097 17
@


1.85
log
@change to from=<...>, to=<...> instead of to=<...> for logging
from gilles@@ ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.84 2012/09/26 19:52:20 eric Exp $	*/
d103 23
@


1.84
log
@Stop using the delivery_data union (field "to") in delivery_mda.
It's confusing and not necessary as it's only used for "buffer".
Instead, just add a "buffer" member in the structure and rename
"as_user" to "user".

The delivery_data union becomes an anonymous union in expandnode,
which is the only other place where it's used.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.83 2012/09/26 09:43:42 eric Exp $	*/
d1066 3
a1068 2
	log_info("%016" PRIx64 ": to=<%s@@%s>, %s%sdelay=%s, %sstat=%s",
	    evp->id, evp->dest.user, evp->dest.domain,
@


1.83
log
@log final user and method used for local deliveries.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.82 2012/09/25 15:36:29 eric Exp $	*/
d1060 1
a1060 1
		    evp->agent.mda.as_user, method);
@


1.82
log
@need inttypes.h

from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.81 2012/09/21 12:33:32 eric Exp $	*/
d1038 2
d1041 1
d1048 15
d1066 1
a1066 1
	log_info("%016" PRIx64 ": to=<%s@@%s>, %sdelay=%s, %sstat=%s",
d1069 1
@


1.81
log
@Add a log_envelope() function that log envelope status in a uniform way.
It automagically adds an rcpt=<user@@domain> field if "dest" differs from
the original "rcpt". The function takes an "extra" parameter that allows
to add some specific info depending on the context.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.80 2012/09/21 10:22:29 eric Exp $	*/
d40 1
@


1.80
log
@Move ruleset_match() prototype to smtpd.h and make the envelope const.
Adapt a lot of functions in chain to use const args where required.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.79 2012/09/20 14:28:57 eric Exp $	*/
d1031 22
@


1.79
log
@constify parameters that are supposed to be const.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.78 2012/09/18 14:23:01 eric Exp $	*/
d362 1
a362 1
hostname_match(char *hostname, char *pattern)
d486 1
a486 1
ss_to_text(struct sockaddr_storage *ss)
d500 1
a500 1
		addr = ((struct sockaddr_in *)ss)->sin_addr.s_addr;
d510 2
a511 2
		struct sockaddr_in6 *in6 = (struct sockaddr_in6 *)ss;
		struct in6_addr	*in6_addr;
d595 1
a595 1
text_to_netaddr(struct netaddr *netaddr, char *s)
d664 1
a664 1
text_to_relayhost(struct relayhost *relay, char *s)
d666 2
a667 3
	uint32_t		 i;
	struct schema {
		char		*name;
d679 4
a682 3
	char	*p;
	char	*sep;
	int	 len;
@


1.78
log
@- add xmemdup() helper.
- remove useless block in switch.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.77 2012/09/16 11:53:57 gilles Exp $	*/
d802 1
a802 1
lowercase(char *buf, char *s, size_t len)
d819 1
a819 1
xlowercase(char *buf, char *s, size_t len)
@


1.77
log
@replace BSD-licensed mkdir_p() with ISC-licensed mkdirs(), this allows us
to avoid a dual-licensed util.c for no reason

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.76 2012/09/15 15:12:11 eric Exp $	*/
d87 12
@


1.76
log
@When enqueueing from the local socket, the input address is faked as "::1".
This is confusing and even broken, as systems running with ipv6 disabled on
lo0 will not be able to enqueue mails using the local socket.

So instead, use AF_LOCAL and print it as "local" in envelopes/maps.  Add it
to the "localhost" and "all" maps accordingly, and fix the ruleset matching.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.75 2012/08/27 11:59:38 chl Exp $	*/
a21 31
/* the mkdir_p() function is based on bin/mkdir/mkdir.c that is covered
 * by the following license: */
/*
 * Copyright (c) 1983, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

d106 3
a108 5
/*
 * mkdir -p. Based on bin/mkdir/mkdir.c:mkpath()
 */
int
mkdir_p(char *path, mode_t mode)
d110 10
a119 4
	struct stat	 sb;
	char		*slash;
	int		 done, exists;
	mode_t		 dir_mode;
d121 2
a122 1
	dir_mode = mode | S_IWUSR | S_IXUSR;
d124 7
a130 1
	slash = path;
d132 3
a134 3
	for (;;) {
		slash += strspn(slash, "/");
		slash += strcspn(slash, "/");
d136 3
a138 2
		done = (*slash == '\0');
		*slash = '\0';
d140 12
a151 4
		/* skip existing path components */
		exists = !stat(path, &sb);
		if (!done && exists && S_ISDIR(sb.st_mode)) {
			*slash = '/';
d154 5
d160 2
a161 14
		if (mkdir(path, done ? mode : dir_mode) == 0) {
			if (mode > 0777 && chmod(path, mode) < 0)
				return (-1);
		} else {
			if (!exists) {
				/* Not there */
				return (-1);
			}
			if (!S_ISDIR(sb.st_mode)) {
				/* Is there, but isn't a directory */
				errno = ENOTDIR;
				return (-1);
			}
		}
d163 2
a164 2
		if (done)
			break;
a165 5
		*slash = '/';
	}

	return (0);
}
@


1.75
log
@don't call ckdir() on each mktmpfile() call.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.74 2012/08/26 11:52:48 gilles Exp $	*/
d505 4
a508 1
	if (ss->ss_family == PF_INET) {
d520 1
a520 2

	if (ss->ss_family == PF_INET6) {
@


1.74
log
@- define ZLIB_BUFFER_SIZE instead of hardcoding 8192
- check gzdopen() failure
- call gzclose() whenever a failure occurs after gzdopen()
- simplify slightly some checks in compress/uncompress
- create PATH_TEMPORARY in /var/spool/smtpd, chmod 700, owned by _smtpd
- compress_zlib should use PATH_TEMPORARY instread of /tmp as we're
	chrooted and this will otherwise lead to a fatal()

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.73 2012/08/25 23:35:09 chl Exp $	*/
a337 3

	if (ckdir(PATH_TEMPORARY, 0700, env->sc_pw->pw_uid, 0, 0) == 0)
		errx(1, "error in %s directory setup", PATH_TEMPORARY);
@


1.73
log
@Add compress_backend, allowing compression of messages and envelopes in the queue.
To use it, just add "queue compress" in smtpd.conf. For now, only zlib is used.

lots of feedback from eric@@ and gilles@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.72 2012/08/25 22:03:26 gilles Exp $	*/
d339 2
a340 1
#define PATH_TMP	"/tmp"
d342 1
a342 4
	if (ckdir(PATH_TMP, 0700, env->sc_pw->pw_uid, 0, 0) == 0)
		errx(1, "error in /tmp directory setup");

	if (! bsnprintf(path, sizeof(path), "%s/zlib.XXXXXXXXXX", PATH_TMP))
@


1.72
log
@- add myself to the copyright in control.c, i've done quite a few changes
there in the last few years ;-)
- get rid of availdesc(): getdtablecount() is so much more reliable
- get rid of env->sc_maxconn, we can be much smarter with getdtablecount()
	and getdtablesize()
- disable accept when we hit the control process fd reserve
- disable accept when we fail
- enable accept when we're back below the limit

this is not the full fd exhaustion diff, i'll merge changes from relayd
tomorrow, this was only required to get rid of the env->sc_maxconn and
availdesc() mess

"reads alright" eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.71 2012/08/19 14:16:58 chl Exp $	*/
d330 22
@


1.71
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.70 2012/08/11 12:43:11 eric Exp $	*/
a869 13
}

int
availdesc(void)
{
	int avail;

	avail = getdtablesize();
	avail -= 3;		/* stdin, stdout, stderr */
	avail -= PROC_COUNT;	/* imsg channels */
	avail -= 5;		/* safety buffer */

	return (avail);
@


1.70
log
@make sure generated id is never 0.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.69 2012/08/08 08:50:42 eric Exp $	*/
d658 1
a658 1
	u_int32_t		 i;
d661 1
a661 1
		u_int8_t	 flags;
d767 1
a767 1
	u_int nalloc;
d846 1
a846 1
u_int64_t
d929 1
a929 1
	u_int16_t		tmp16;
d960 2
a961 2
u_int32_t
evpid_to_msgid(u_int64_t evpid)
d966 2
a967 2
u_int64_t
msgid_to_evpid(u_int32_t msgid)
d969 1
a969 1
	return ((u_int64_t)msgid << 32);
@


1.69
log
@Improve the scheduler backend API.

New envelopes are pushed into the scheduler through the insert()
commit() rollback() transactional interface functions.

Worklists are pulled from the scheduler through a single batch()
interface function, which returns a list of envelope ids and the
type of processing. Envelopes returned in this batch are said to
be "in-flight", as opposed to "pending". They are supposed to be
processed in some way, and either updated() or deleted() at some
point.

The schedule()/remove() functions are used to alter the internal
state of "pending" envelopes to make them schedulable.  The enve-
lopes will be part of a worklist on the next call to batch().

Rewrite the scheduler_ramqueue backend.

The initial queue loading in now done by the queue.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.68 2012/08/07 21:47:58 eric Exp $	*/
d849 2
a850 1
	static u_int32_t id = 0;
d852 4
a855 1
	return ((uint64_t)(id++) << 32 | arc4random());
@


1.68
log
@Implement a set of tree_* functions for storing arbitrary pointers in splay
trees with uint64_t keys. Also add x{m,c}alloc and xstrdup helpers.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.67 2012/07/29 17:21:43 gilles Exp $	*/
d539 45
@


1.67
log
@- introduce xlowercase() and allow lowercase() to fail gracefully
- replace all calls to lowercase() with calls to xlowercase()
- in the format string expansion, lowercase() all formats

we will have to reassess all calls to xlowercase() even though it has never
triggered as far as I know, we can probably gracefully fail some of them.
right now we're just keeping former behaviour.

this commit fixes issue reported by Hugo Osvaldo Barrera where a %u format
could lead to a delivery failure (ie: GILLES@@openbsd.org should be expanded
to gilles, not GILLES ... only for local deliveries).

ok chl@@ on the idea, ok eric@@ on the diff
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.66 2012/07/12 08:51:43 chl Exp $	*/
d7 1
d88 33
@


1.66
log
@add support for maildir tagging/folders.

ok gilles@@
ok eric@@ on previous versions of this patch
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.65 2012/07/11 22:16:45 chl Exp $	*/
d714 1
a714 1
void
d718 1
a718 1
		fatalx("lowercase: len == 0");
d721 1
a721 1
		fatalx("lowercase: truncation");
d727 12
@


1.65
log
@enable back = char in address localpart, that is sometimes used by mailing lists.

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.64 2012/07/11 17:20:00 chl Exp $	*/
d21 31
d101 53
@


1.64
log
@Don't respect RFC 5322, that allows some crazy characters in email
localpart, like !#$&'*/=?^`{|}~ ... and all the other ones that
can be double quoted, just refuse them.

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.63 2012/07/10 16:11:43 chl Exp $	*/
d266 1
a266 1
#define IS_ATEXT(c)     (isalnum((int)(c)) || strchr("%+-_", (c)))
@


1.63
log
@accept address literal for the recipient domain.
while there, change valid_{local,domain}part() prototypes to use const char *.

with input from gilles@@ and eric@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.62 2012/07/08 15:48:00 gilles Exp $	*/
d262 5
a266 1
#define IS_ATEXT(c)     (isalnum((int)(c)) || strchr("!#$%&'*+-/=?^_`{|}~", (c)))
@


1.62
log
@- plug text_to_relayhost() in parse.y to support relay URLs.
- document the new URL syntax in smtpd.conf.5
- replace starttls:// schema with tls://

Beware, "relay via" rules should now be expressed with a relay URL:

	accept [...] relay via "mx1.example.org" smtps port 465
becomes accept [...] relay via "smtps://mx1.example.org"

This will allow using mappings of relays with different protocols and
options.

Make sure to update your smtpd.conf if you relay via !

ok eric, ok chl
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.61 2012/07/02 10:32:28 eric Exp $	*/
d260 1
a260 1
valid_localpart(char *s)
d281 1
a281 1
valid_domainpart(char *s)
d283 21
@


1.61
log
@Sleeping here is definitely not what we want to do. Use a cycling
counter with some randomness to generate short-lived unique ids.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.60 2012/05/29 19:29:44 gilles Exp $	*/
d477 1
a477 1
		{ "starttls://",	F_STARTTLS			},
d479 1
a479 1
		{ "starttls+auth://",	F_STARTTLS|F_AUTH		},
@


1.60
log
@- introduce text_to_relayhost() which converts an url into a relayhost.
  urls are of the form: [schema://]host[:ip]

not used, yet other commits are following ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.59 2012/05/23 22:46:58 gilles Exp $	*/
d649 1
a649 2
	u_int64_t	id;
	struct timeval	tp;
d651 1
a651 9
	if (gettimeofday(&tp, NULL) == -1)
		fatal("generate_uid: time");

	id = (u_int32_t)tp.tv_sec;
	id <<= 32;
	id |= (u_int32_t)tp.tv_usec;
	usleep(1);

	return (id);
@


1.59
log
@- introduce temp_inet_net_pton_ipv6() temporarily until we have AF_INET6
  support in inet_net_pton().

- in text_to_netaddr(), if we are handling an inet6 netmask AND we have
  inet_net_pton() that failed with EAFNOSUPPORT, THEN we fallback to
  this.

quick fix to unbreak setups that use inet6, a diff is floating to have
it supported at the right place.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.58 2012/05/13 00:10:49 gilles Exp $	*/
d464 57
@


1.58
log
@- cleanup parse.y by removing lots of code that should not have been there,
  but in ruleset.c and util.c instead.

- introduce the new map_compare() map API call to allow iterating over keys
  and comparing them with provided key using provided function. this allows
  checking a partial key in a key set, very useful for comparing an address
  to a set of netmask.

- introduce new map kind K_NETADDR
- implement K_NETADDR for map_db and map_stdio
- teach ruleset checking how to use the map_compare() with K_NETADDR

we can now do the following:

   map "srcaddr" source plain "/etc/mail/srcaddr.txt"

   accept from map srcaddr for domain "openbsd.org" [...]
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.57 2012/01/28 16:54:10 gilles Exp $	*/
d55 2
d426 11
d752 32
@


1.57
log
@remove even more annoying debug logs

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.56 2012/01/12 15:01:33 eric Exp $	*/
d30 1
d394 58
@


1.56
log
@remove envelope_get_errormsg() and move envelope_set_errormsg()
to envelope.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.55 2012/01/11 17:46:37 eric Exp $	*/
a155 1
			log_debug("rmdir %s", e->fts_path);
a167 1
		log_debug("unlink %s", e->fts_path);
a194 1
	log_debug("rename %s -> %s", from, buf);
@


1.55
log
@Simplify runner/queue by getting rid of Q_PURGE.  Instead, let smtpd
periodically clear the purge/ directory.  At init time, the fsqueue
backend simply moves the existing incoming/ dir in purge/ to discard
aborted sessions.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.54 2011/12/18 22:51:29 chl Exp $	*/
a491 24
}

void
envelope_set_errormsg(struct envelope *e, char *fmt, ...)
{
	int ret;
	va_list ap;

	va_start(ap, fmt);
	ret = vsnprintf(e->errorline, sizeof(e->errorline), fmt, ap);
	va_end(ap);

	/* this should not happen */
	if (ret == -1)
		err(1, "vsnprintf");

	if ((size_t)ret >= sizeof(e->errorline))
		strlcpy(e->errorline + (sizeof(e->errorline) - 4), "...", 4);
}

char *
envelope_get_errormsg(struct envelope *e)
{
	return e->errorline;
@


1.54
log
@remove unused header

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.53 2011/12/18 18:43:30 eric Exp $	*/
d36 1
d131 81
@


1.53
log
@- use envelope_set_errormsg() where possible.
- make it use sizeof() rather than a hardcoded limit.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.52 2011/12/11 19:58:09 eric Exp $	*/
a36 1
#include <inttypes.h>
@


1.52
log
@utility function for parsing and validating SMTP response lines

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.51 2011/11/16 19:38:56 eric Exp $	*/
d420 2
a421 4

	ret = vsnprintf(e->errorline, MAX_LINE_SIZE, fmt, ap);
	if (ret >= MAX_LINE_SIZE)
		strlcpy(e->errorline + (MAX_LINE_SIZE - 4), "...", 4);
d427 2
a428 1
	va_end(ap);
@


1.51
log
@remove unused functions

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.50 2011/11/14 11:53:10 eric Exp $	*/
d593 34
@


1.50
log
@The spool and offline directories are backend-independent, so they
must be created early by smtpd, rather than in fsqueue.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.49 2011/10/27 14:32:57 chl Exp $	*/
a580 64
}

u_int32_t
filename_to_msgid(char *filename)
{
	u_int32_t ulval;
	char *ep;

	errno = 0;
	ulval = strtoul(filename, &ep, 16);
	if (filename[0] == '\0' || *ep != '\0')
		return 0;
	if (errno == ERANGE && ulval == 0xffffffff)
		return 0;

	return ulval;
}

u_int64_t
filename_to_evpid(char *filename)
{
	u_int64_t ullval;
	char *ep;

	errno = 0;
	ullval = strtoull(filename, &ep, 16);
	if (filename[0] == '\0' || *ep != '\0')
		return 0;
	if (errno == ERANGE && ullval == ULLONG_MAX)
		return 0;

	return ullval;
}

u_int32_t
msgid_generate(void)
{
	u_int32_t ret;

	do {
		ret = arc4random();
	} while (ret == 0);

	log_debug("msgid_generate: %08x", ret);

	return ret;
}

u_int64_t
evpid_generate(u_int32_t msgid)
{
	u_int64_t ret;

	ret = msgid;
	log_debug("evpid_generate: %016" PRIx64, ret);
	ret <<= 32;
	log_debug("evpid_generate: %016" PRIx64, ret);
	do {
		ret |= arc4random();
	} while ((ret & 0xffffffff) == 0);

	log_debug("evpid_generate: %016" PRIx64, ret);

	return ret;
@


1.49
log
@Use PRI{x,d}64 in format strings instead of %llx, %lld or %qd to print {u_,}int64_t or time_t

While there, cast some time_t to int64_t

These will fix build warnings for portable smptd

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.48 2011/10/23 09:30:07 gilles Exp $	*/
d68 65
@


1.48
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.47 2011/05/17 18:54:32 gilles Exp $	*/
d37 1
d570 1
a570 1
	log_debug("evpid_generate: %016llx", ret);
d572 1
a572 1
	log_debug("evpid_generate: %016llx", ret);
d577 1
a577 1
	log_debug("evpid_generate: %016llx", ret);
@


1.47
log
@introduce new user_backend API for smtpd to lookup the users it wants to
deliver mail to. the only backend supported for now is USER_GETPWNAM and
it is not yet possible to switch to an alternate backend.

yes this means that we're very close from smtpd being able to handle fully
virtual accounts for both incoming and outgoing messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.46 2011/05/16 21:05:52 gilles Exp $	*/
d355 1
a355 1
	ret = vsnprintf(e->delivery.errorline, MAX_LINE_SIZE, fmt, ap);
d357 1
a357 1
		strlcpy(e->delivery.errorline + (MAX_LINE_SIZE - 4), "...", 4);
d369 1
a369 1
	return e->delivery.errorline;
d547 32
@


1.46
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.45 2011/05/14 11:04:42 gilles Exp $	*/
d255 1
a255 1
secure_file(int fd, char *path, struct passwd *pw, int mayread)
d265 1
a265 1
	if (realpath(pw->pw_dir, homedir) == NULL)
d271 1
a271 1
	    (st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
d282 1
a282 1
		    (st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
@


1.45
log
@int * -> socklen_t * in getsockopt() call
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.44 2011/04/17 13:36:07 gilles Exp $	*/
a112 34
recipient_to_path(struct path *path, char *recipient)
{
	char *username;
	char *hostname;

	username = recipient;
	hostname = strrchr(username, '@@');

	if (username[0] == '\0') {
		*path->user = '\0';
		*path->domain = '\0';
		return 1;
	}

	if (hostname == NULL) {
		if (strcasecmp(username, "postmaster") != 0)
			return 0;
		hostname = "localhost";
	} else {
		*hostname++ = '\0';
	}

	if (strlcpy(path->user, username, sizeof(path->user))
	    >= sizeof(path->user))
		return 0;

	if (strlcpy(path->domain, hostname, sizeof(path->domain))
	    >= sizeof(path->domain))
		return 0;

	return 1;
}

int
d155 34
d348 1
a348 1
message_set_errormsg(struct envelope *m, char *fmt, ...)
d355 1
a355 1
	ret = vsnprintf(m->session_errorline, MAX_LINE_SIZE, fmt, ap);
d357 1
a357 1
		strlcpy(m->session_errorline + (MAX_LINE_SIZE - 4), "...", 4);
d367 1
a367 1
message_get_errormsg(struct envelope *m)
d369 1
a369 1
	return m->session_errorline;
a395 14
}

struct path *
path_dup(struct path *path)
{
	struct path *pathp;

	pathp = calloc(sizeof(struct path), 1);
	if (pathp == NULL)
		fatal("calloc");

	*pathp = *path;

	return pathp;
@


1.44
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.43 2011/04/17 11:39:23 gilles Exp $	*/
d486 2
a487 1
	int	 error, len;
@


1.43
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.42 2011/04/15 17:21:24 gilles Exp $	*/
a51 6

u_int32_t	filename_to_msgid(char *);
u_int64_t	filename_to_evpid(char *);

u_int32_t	evpid_to_msgid(u_int64_t);
u_int64_t	msgid_to_evpid(u_int32_t);
@


1.42
log
@valid_message_id() and valid_message_uid() are no longer needed
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.41 2011/04/15 17:01:05 gilles Exp $	*/
d354 1
a354 1
message_set_errormsg(struct message *messagep, char *fmt, ...)
d361 1
a361 1
	ret = vsnprintf(messagep->session_errorline, MAX_LINE_SIZE, fmt, ap);
d363 1
a363 1
		strlcpy(messagep->session_errorline + (MAX_LINE_SIZE - 4), "...", 4);
d373 1
a373 1
message_get_errormsg(struct message *messagep)
d375 1
a375 1
	return messagep->session_errorline;
@


1.41
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.40 2011/03/29 20:43:51 eric Exp $	*/
a227 47
}

int
valid_message_id(char *mid)
{
	u_int8_t cnt;

	/* [0-9]{10}\.[a-zA-Z0-9]{16} */
	for (cnt = 0; cnt < 10; ++cnt, ++mid)
		if (! isdigit((int)*mid))
			return 0;

	if (*mid++ != '.')
		return 0;

	for (cnt = 0; cnt < 16; ++cnt, ++mid)
		if (! isalnum((int)*mid))
			return 0;

	return (*mid == '\0');
}

int
valid_message_uid(char *muid)
{
	u_int8_t cnt;

	/* [0-9]{10}\.[a-zA-Z0-9]{16}\.[0-9]{0,} */
	for (cnt = 0; cnt < 10; ++cnt, ++muid)
		if (! isdigit((int)*muid))
			return 0;

	if (*muid++ != '.')
		return 0;

	for (cnt = 0; cnt < 16; ++cnt, ++muid)
		if (! isalnum((int)*muid))
			return 0;

	if (*muid++ != '.')
		return 0;

	for (cnt = 0; *muid != '\0'; ++cnt, ++muid)
		if (! isdigit((int)*muid))
			return 0;

	return (cnt != 0);
@


1.40
log
@remove unused code now that reverse lookups are done through asr.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.39 2011/03/03 08:09:14 gilles Exp $	*/
d53 6
d581 44
@


1.39
log
@fix ss_to_text() and ss_to_ptr() so IP addresses are logged correctly
on big-endian machines ...

spotted and tested by landry@@ (and I)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.38 2010/11/29 15:25:56 gilles Exp $	*/
a221 70
}

char *
ss_to_ptr(struct sockaddr_storage *ss)
{
	static char buffer[1024];

	/* we need to construct a PTR query */
	switch (ss->ss_family) {
	case AF_INET: {
		in_addr_t addr;
		
		addr = ((struct sockaddr_in *)ss)->sin_addr.s_addr;
                addr = ntohl(addr);
                bsnprintf(buffer, sizeof (buffer),
                    "%d.%d.%d.%d.in-addr.arpa",
                    addr & 0xff,
                    (addr >> 8) & 0xff,
                    (addr >> 16) & 0xff,
                    (addr >> 24) & 0xff);
		break;
	}
	case AF_INET6: {
		struct sockaddr_in6 *in6 = (struct sockaddr_in6 *)ss;
		struct in6_addr	*in6_addr;

		in6_addr = &in6->sin6_addr;
		bsnprintf(buffer, sizeof (buffer),
		    "%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d."
		    "%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d."
		    "ip6.arpa",
		    in6_addr->s6_addr[15] & 0xf,
		    (in6_addr->s6_addr[15] >> 4) & 0xf,
		    in6_addr->s6_addr[14] & 0xf,
		    (in6_addr->s6_addr[14] >> 4) & 0xf,
		    in6_addr->s6_addr[13] & 0xf,
		    (in6_addr->s6_addr[13] >> 4) & 0xf,
		    in6_addr->s6_addr[12] & 0xf,
		    (in6_addr->s6_addr[12] >> 4) & 0xf,
		    in6_addr->s6_addr[11] & 0xf,
		    (in6_addr->s6_addr[11] >> 4) & 0xf,
		    in6_addr->s6_addr[10] & 0xf,
		    (in6_addr->s6_addr[10] >> 4) & 0xf,
		    in6_addr->s6_addr[9] & 0xf,
		    (in6_addr->s6_addr[9] >> 4) & 0xf,
		    in6_addr->s6_addr[8] & 0xf,
		    (in6_addr->s6_addr[8] >> 4) & 0xf,
		    in6_addr->s6_addr[7] & 0xf,
		    (in6_addr->s6_addr[7] >> 4) & 0xf,
		    in6_addr->s6_addr[6] & 0xf,
		    (in6_addr->s6_addr[6] >> 4) & 0xf,
		    in6_addr->s6_addr[5] & 0xf,
		    (in6_addr->s6_addr[5] >> 4) & 0xf,
		    in6_addr->s6_addr[4] & 0xf,
		    (in6_addr->s6_addr[4] >> 4) & 0xf,
		    in6_addr->s6_addr[3] & 0xf,
		    (in6_addr->s6_addr[3] >> 4) & 0xf,
		    in6_addr->s6_addr[2] & 0xf,
		    (in6_addr->s6_addr[2] >> 4) & 0xf,
		    in6_addr->s6_addr[1] & 0xf,
		    (in6_addr->s6_addr[1] >> 4) & 0xf,
		    in6_addr->s6_addr[0] & 0xf,
		    (in6_addr->s6_addr[0] >> 4) & 0xf);
		break;
	}
	default:
		fatalx("dns_query_ptr");
	}

	return buffer;
@


1.38
log
@replace the fork-based-non-blocking-resolver-hack by shiny async resolver
written by eric@@. it is still experimental but still better than what we
had earlier so ... we'll improve in tree :)

diff by me with *lots* of help from eric@@, tested by todd and I (and a
few people out there)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.37 2010/11/28 13:56:43 gilles Exp $	*/
d202 7
a208 6
		bsnprintf(p, NI_MAXHOST,
		    "%d.%d.%d.%d",
		    addr & 0xff,
		    (addr >> 8) & 0xff,
		    (addr >> 16) & 0xff,
		    (addr >> 24) & 0xff);
d235 7
a241 7

		bsnprintf(buffer, sizeof (buffer),
		    "%d.%d.%d.%d.in-addr.arpa",
		    (addr >> 24) & 0xff,
		    (addr >> 16) & 0xff,
		    (addr >> 8) & 0xff,
		    addr & 0xff);
@


1.37
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.36 2010/10/09 22:05:35 gilles Exp $	*/
d29 2
d50 3
d198 12
d211 3
d216 2
d220 69
a288 3
	if (getnameinfo((struct sockaddr *)ss, ss->ss_len, p,
	    NI_MAXHOST, NULL, 0, NI_NUMERICHOST))
		fatalx("ss_to_text: getnameinfo");
d290 1
a290 1
	return (buf);
d609 35
@


1.36
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.32 2009/12/23 17:16:03 jacekm Exp $	*/
d34 1
d46 1
@


1.35
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.33 2010/05/31 23:38:56 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009-2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d61 22
d203 47
d374 1
a374 1
sa_set_port(struct sockaddr *sa, char *port)
d376 26
a401 1
	char hbuf[NI_MAXHOST];
d405 1
a405 1
	error = getnameinfo(sa, sa->sa_len, hbuf, sizeof hbuf, NULL, 0, NI_NUMERICHOST);
d412 1
a412 1
	hints.ai_flags = AI_NUMERICHOST;
d414 3
a416 1
	error = getaddrinfo(hbuf, port, &hints, &res);
d429 1
a429 1
	pathp = calloc(1, sizeof(struct path));
d512 1
a512 2
	socklen_t len;
	int error;
a518 101
}

/*
 * Find unused slot in a pointer table.
 */
int
table_alloc(void ***p, int *szp)
{
	void	**array;
	int	  array_sz, i, new;

	array = *p;
	array_sz = *szp;

	for (i = 0; i < array_sz; i++)
		if (array[i] == NULL)
			break;

	/* array full? */
	if (i == array_sz) {
		if (array_sz * 2 < array_sz)
			fatalx("table_alloc: overflow");
		array_sz *= 2;
		array = realloc(array, ++array_sz * sizeof *array);
		if (array == NULL)
			fatal("array_alloc");
		for (new = i; new < array_sz; new++)
			array[new] = NULL;
		*p = array;
		*szp = array_sz;
	}

	return i;
}

/*
 * Retrieve table entry residing at given index.
 */
void *
table_lookup(void **p, int sz, int i)
{
	if (i < 0 || i >= sz)
		return (NULL);
	return p[i];
}

void
auxsplit(struct aux *a, char *aux)
{
	int col;
	char *val;

	bzero(a, sizeof *a);
	col = 0;
	for (;;) {
		val = strsep(&aux, "|");
		if (val == NULL)
			break;
		col++;
		if (col == 1)
			a->mode = val;
		else if (col == 2)
			a->mail_from = val;
		else if (col == 3)
			a->rcpt_to = val;
		else if (col == 4)
			a->user_from = val;
		else if (a->mode[0] == 'R') {
			if (col == 5)
				a->rcpt = val;
			else if (col == 6)
				a->relay_via = val;
			else if (col == 7)
				a->port = val;
			else if (col == 8)
				a->ssl = val;
			else if (col == 9)
				a->cert = val;
			else if (col == 10)
				a->auth = val;
		} else if (col == 5)
			a->user_to = val;
		else if (col == 6)
			a->path = val;
	}
}

char *
rcpt_pretty(struct aux *aux)
{
	switch (aux->mode[0]) {
	case 'M':
	case 'D':
	case 'P':
		return aux->user_to;
	case 'F':
		return aux->path;
	case 'R':
		return aux->rcpt;
	}
	return NULL;
@


1.34
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.32 2009/12/23 17:16:03 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
a60 22
/* Close file, signifying temporary error condition (if any) to the caller. */
int
safe_fclose(FILE *fp)
{
	if (ferror(fp)) {
		fclose(fp);
		return 0;
	}
	if (fflush(fp)) {
		fclose(fp);
		if (errno == ENOSPC)
			return 0;
		fatal("safe_fclose: fflush");
	}
	if (fsync(fileno(fp)))
		fatal("safe_fclose: fsync");
	if (fclose(fp))
		fatal("safe_fclose: fclose");

	return 1;
}

a180 47
int
valid_message_id(char *mid)
{
	u_int8_t cnt;

	/* [0-9]{10}\.[a-zA-Z0-9]{16} */
	for (cnt = 0; cnt < 10; ++cnt, ++mid)
		if (! isdigit((int)*mid))
			return 0;

	if (*mid++ != '.')
		return 0;

	for (cnt = 0; cnt < 16; ++cnt, ++mid)
		if (! isalnum((int)*mid))
			return 0;

	return (*mid == '\0');
}

int
valid_message_uid(char *muid)
{
	u_int8_t cnt;

	/* [0-9]{10}\.[a-zA-Z0-9]{16}\.[0-9]{0,} */
	for (cnt = 0; cnt < 10; ++cnt, ++muid)
		if (! isdigit((int)*muid))
			return 0;

	if (*muid++ != '.')
		return 0;

	for (cnt = 0; cnt < 16; ++cnt, ++muid)
		if (! isalnum((int)*muid))
			return 0;

	if (*muid++ != '.')
		return 0;

	for (cnt = 0; *muid != '\0'; ++cnt, ++muid)
		if (! isdigit((int)*muid))
			return 0;

	return (cnt != 0);
}

d305 1
a305 1
message_set_errormsg(struct message *messagep, char *fmt, ...)
d307 1
a307 26
	int ret;
	va_list ap;

	va_start(ap, fmt);

	ret = vsnprintf(messagep->session_errorline, MAX_LINE_SIZE, fmt, ap);
	if (ret >= MAX_LINE_SIZE)
		strlcpy(messagep->session_errorline + (MAX_LINE_SIZE - 4), "...", 4);

	/* this should not happen */
	if (ret == -1)
		err(1, "vsnprintf");

	va_end(ap);
}

char *
message_get_errormsg(struct message *messagep)
{
	return messagep->session_errorline;
}

void
sa_set_port(struct sockaddr *sa, int port)
{
	char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
d311 1
a311 1
	error = getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
d318 1
a318 1
	hints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;
d320 1
a320 3
	snprintf(sbuf, sizeof(sbuf), "%d", port);

	error = getaddrinfo(hbuf, sbuf, &hints, &res);
d333 1
a333 1
	pathp = calloc(sizeof(struct path), 1);
d416 2
a417 1
	int	 error, len;
d424 101
@


1.33
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d6 1
a6 1
 * Copyright (c) 2009-2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d61 22
d203 47
d374 1
a374 1
sa_set_port(struct sockaddr *sa, char *port)
d376 26
a401 1
	char hbuf[NI_MAXHOST];
d405 1
a405 1
	error = getnameinfo(sa, sa->sa_len, hbuf, sizeof hbuf, NULL, 0, NI_NUMERICHOST);
d412 1
a412 1
	hints.ai_flags = AI_NUMERICHOST;
d414 3
a416 1
	error = getaddrinfo(hbuf, port, &hints, &res);
d429 1
a429 1
	pathp = calloc(1, sizeof(struct path));
d512 1
a512 2
	socklen_t len;
	int error;
a518 101
}

/*
 * Find unused slot in a pointer table.
 */
int
table_alloc(void ***p, int *szp)
{
	void	**array;
	int	  array_sz, i, new;

	array = *p;
	array_sz = *szp;

	for (i = 0; i < array_sz; i++)
		if (array[i] == NULL)
			break;

	/* array full? */
	if (i == array_sz) {
		if (array_sz * 2 < array_sz)
			fatalx("table_alloc: overflow");
		array_sz *= 2;
		array = realloc(array, ++array_sz * sizeof *array);
		if (array == NULL)
			fatal("array_alloc");
		for (new = i; new < array_sz; new++)
			array[new] = NULL;
		*p = array;
		*szp = array_sz;
	}

	return i;
}

/*
 * Retrieve table entry residing at given index.
 */
void *
table_lookup(void **p, int sz, int i)
{
	if (i < 0 || i >= sz)
		return (NULL);
	return p[i];
}

void
auxsplit(struct aux *a, char *aux)
{
	int col;
	char *val;

	bzero(a, sizeof *a);
	col = 0;
	for (;;) {
		val = strsep(&aux, "|");
		if (val == NULL)
			break;
		col++;
		if (col == 1)
			a->mode = val;
		else if (col == 2)
			a->mail_from = val;
		else if (col == 3)
			a->rcpt_to = val;
		else if (col == 4)
			a->user_from = val;
		else if (a->mode[0] == 'R') {
			if (col == 5)
				a->rcpt = val;
			else if (col == 6)
				a->relay_via = val;
			else if (col == 7)
				a->port = val;
			else if (col == 8)
				a->ssl = val;
			else if (col == 9)
				a->cert = val;
			else if (col == 10)
				a->auth = val;
		} else if (col == 5)
			a->user_to = val;
		else if (col == 6)
			a->path = val;
	}
}

char *
rcpt_pretty(struct aux *aux)
{
	switch (aux->mode[0]) {
	case 'M':
	case 'D':
	case 'P':
		return aux->user_to;
	case 'F':
		return aux->path;
	case 'R':
		return aux->rcpt;
	}
	return NULL;
@


1.32
log
@Implementation of RFC 2920 PIPELINING extension, client side only for now.

This restructures the client_* API internals significantly.  The code becomes
pipelining in nature.  All SMTP commands are put on the output queue and
dequeued as quickly as possible.  Once dequeued, they're moved to the receive
queue so that replies can be matched with previous commands.

Dequeuing commands from the output queue halts when the count of commands
currently in-pipeline (``cmdi'') is equal to the command send window (``cmdw'').
There are three cmdw values useful in practice:

0               clear pipeline, ie. inhibit all future sends
1               disable pipelining, ie. use old ``one-request-one-reply`` mode
SIZE_T_MAX      enable pipelining, ie. dequeue as many commands as possible

At the beginning of session cmdw is 1.  When it is found that peer supports
PIPELINING, it grows to SIZE_T_MAX.  After dequeing DATA it is again 1.  After
sending QUIT it is 0.

Each command dequeued from the output queue becomes a buf in a msgbuf.  The act
of combining multiple commands into a single send operation did not need to be
implemented: buf_write() already combines bufs using iovec and sends them at
once using sendmsg(2).

Tested by todd@@ and oga@@

"looks good" to gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.31 2009/12/14 19:56:55 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
a60 22
/* Close file, signifying temporary error condition (if any) to the caller. */
int
safe_fclose(FILE *fp)
{
	if (ferror(fp)) {
		fclose(fp);
		return 0;
	}
	if (fflush(fp)) {
		fclose(fp);
		if (errno == ENOSPC)
			return 0;
		fatal("safe_fclose: fflush");
	}
	if (fsync(fileno(fp)))
		fatal("safe_fclose: fsync");
	if (fclose(fp))
		fatal("safe_fclose: fclose");

	return 1;
}

a180 47
int
valid_message_id(char *mid)
{
	u_int8_t cnt;

	/* [0-9]{10}\.[a-zA-Z0-9]{16} */
	for (cnt = 0; cnt < 10; ++cnt, ++mid)
		if (! isdigit((int)*mid))
			return 0;

	if (*mid++ != '.')
		return 0;

	for (cnt = 0; cnt < 16; ++cnt, ++mid)
		if (! isalnum((int)*mid))
			return 0;

	return (*mid == '\0');
}

int
valid_message_uid(char *muid)
{
	u_int8_t cnt;

	/* [0-9]{10}\.[a-zA-Z0-9]{16}\.[0-9]{0,} */
	for (cnt = 0; cnt < 10; ++cnt, ++muid)
		if (! isdigit((int)*muid))
			return 0;

	if (*muid++ != '.')
		return 0;

	for (cnt = 0; cnt < 16; ++cnt, ++muid)
		if (! isalnum((int)*muid))
			return 0;

	if (*muid++ != '.')
		return 0;

	for (cnt = 0; *muid != '\0'; ++cnt, ++muid)
		if (! isdigit((int)*muid))
			return 0;

	return (cnt != 0);
}

d305 1
a305 1
message_set_errormsg(struct message *messagep, char *fmt, ...)
d307 1
a307 26
	int ret;
	va_list ap;

	va_start(ap, fmt);

	ret = vsnprintf(messagep->session_errorline, MAX_LINE_SIZE, fmt, ap);
	if (ret >= MAX_LINE_SIZE)
		strlcpy(messagep->session_errorline + (MAX_LINE_SIZE - 4), "...", 4);

	/* this should not happen */
	if (ret == -1)
		err(1, "vsnprintf");

	va_end(ap);
}

char *
message_get_errormsg(struct message *messagep)
{
	return messagep->session_errorline;
}

void
sa_set_port(struct sockaddr *sa, int port)
{
	char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
d311 1
a311 1
	error = getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
d318 1
a318 1
	hints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;
d320 1
a320 3
	snprintf(sbuf, sizeof(sbuf), "%d", port);

	error = getaddrinfo(hbuf, sbuf, &hints, &res);
d333 1
a333 1
	pathp = calloc(sizeof(struct path), 1);
d416 2
a417 1
	int	 error, len;
d424 101
@


1.31
log
@Tweak the logic behind setting the fd limits so that smtpd is less likely
to get upset by custom soft/hard ulimit settings.

Suggested by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.30 2009/12/13 22:02:55 jacekm Exp $	*/
d29 1
a30 1
#include <ctype.h>
d33 1
d480 39
@


1.30
log
@Use safe fd limits in smtp, lka, queue, and control.  Removes a
possibility for fd-starvation fatal when under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.29 2009/11/08 21:40:05 gilles Exp $	*/
d455 1
a455 1
fdlimit(int n)
d459 2
d463 1
a463 5
	if ((u_int)n > rl.rlim_max) {
		log_warnx("fdlimit: need %d, limit %llu", n, rl.rlim_max);
		fatalx("fdlimit: hard limit reached");
	}
	rl.rlim_cur = n;
d465 1
a465 1
		fatal("fdlimit: getrlimit");
@


1.29
log
@- make aliases expansion use a rb tree instead of a tail queue, the code
  doesn't take advantage of the new structure yet, but this was a needed
  change for upcoming improvements.
- introduce aliasestree_{lookup,insert,remove} to the aliases api
- rename queue_generate_id() to generate_uid() and move it to utils.c as
  it is used all over the place and not only in queue

tree idea discussed with jacekm@@, if you update rebuild aliases db, make
clean and flush queue
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.28 2009/11/08 19:38:26 gilles Exp $	*/
d27 1
d452 29
@


1.28
log
@first commit of a serie to cleanup, simplify and improve aliases resolution
which is probably the most complex code in smtpd right now. no longer use a
single list to hold aliases to be resolved and resolved aliases, and do not
use struct alias to hold resolved aliases. instead use a delivery list that
is a list of struct path, and populate it with resolved aliases.

idea discussed with jacekm@@, this needs some testing to make sure it does
not introduce a regression with aliases. flush your queue and make clean.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.27 2009/09/15 16:50:06 jacekm Exp $	*/
d434 17
@


1.27
log
@Extend SMTP client_* API to support SSL+AUTH, and use it in the mta
process to relay mails.  ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.26 2009/08/27 09:21:28 jacekm Exp $	*/
d420 14
@


1.26
log
@getpwnam failure that results in setting errno could confuse the
check for non-existent ~/.forward, so make the check more robust;
fix a fd leak under rare circumstances; use secure_file for
testing .forward file security.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2009/08/08 00:18:38 gilles Exp $	*/
d394 26
@


1.25
log
@missing cast
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.24 2009/08/08 00:02:22 gilles Exp $	*/
d279 1
a279 1
secure_file(int fd, char *path, struct passwd *pw)
d296 1
a296 1
	    (st.st_mode & 066) != 0)
@


1.24
log
@import some changes from portable smtpd to reduce the delta between both.
this commit contains mostly missing casts and cosmethic changes, do not
expect to build this anywhere but on OpenBSD, it does not contain any of
the portable glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2009/08/06 14:12:48 gilles Exp $	*/
d242 1
a242 1
		if (! isdigit(*muid))
@


1.23
log
@- introduce message_set_errormsg() to set the error description that will
  appear in a bounce message, and message_get_errormsg() to retrieve that
  message.
- when loop is detected, call message_set_errormsg()
- in mta, call message_set_errormsg() for each recipient failure
- in mta, call message_set_errormsg() to copy batch errors to recipients if
  we failed to deliver for a session related error
- when bouncing, add the recipient and error reason to the bounce message
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2009/06/01 18:24:01 deraadt Exp $	*/
d89 1
a89 1
			    tolower(*hostname) != tolower(*pattern))
d94 1
a94 1
		if (tolower(*pattern) != tolower(*hostname))
d140 1
a140 1
#define IS_ATEXT(c)     (isalnum(c) || strchr("!#$%&'*+-/=?^_`{|}~", (c)))
d162 1
a162 1
        if (!isalnum(*s))
d167 1
a167 1
                if (isalnum(*s) || *s == '-')
d366 1
a366 1
		*buf = tolower(*buf);
@


1.22
log
@No need for save_getpwuid and such functions which call endpwent.
endpwent is not needed unless setpwent (with stayopen = 1) or getpwent
was used.  getpwuid/getpwnam do not use getpwent; i think people must
be assuming this.  we are going to improve the man pages for this.
ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2009/05/10 11:29:40 jacekm Exp $	*/
d28 1
d35 1
d369 25
@


1.21
log
@assert copyright; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2009/04/24 10:02:35 jacekm Exp $	*/
a76 22
}

struct passwd *
safe_getpwnam(const char *name)
{
	struct passwd *ret;

	ret = getpwnam(name);
	endpwent();

	return ret;
}

struct passwd *
safe_getpwuid(uid_t uid)
{
	struct passwd *ret;

	ret = getpwuid(uid);
	endpwent();

	return ret;
@


1.20
log
@Make aliases case-insensitive, issue reported by Daniel Ouelett; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2009/03/12 11:08:26 pea Exp $	*/
d4 1
d6 1
a6 1
 * Copyright (c) 2000,2001 Markus Friedl.  All rights reserved.
@


1.19
log
@Add new function time_to_text to correctly display the date.
Use it to display the date in received from header and when we
store headers.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2009/03/10 01:25:42 jacekm Exp $	*/
d373 15
@


1.18
log
@ascribe copyright to code taken from OpenSSH, pointed out by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2009/03/09 23:35:04 jacekm Exp $	*/
d36 1
d265 27
@


1.17
log
@run external mda directly, not via sh -c; this steals addargs() API
from OpenSSH; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2009/03/01 21:58:53 jacekm Exp $	*/
d5 1
@


1.16
log
@- Refuse delivery to mbox that is a symlink, pipe, chardev, etc. etc.
- Introduce secure_file, based on secure_filename from OpenSSH, it
checks that mbox has right perms, and that path components are
trustworthy, too.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2009/02/24 12:07:47 gilles Exp $	*/
d313 31
@


1.15
log
@teach smtpctl's parser how to deal with parameters that are not necessarily
a token so that it is possible to do: smtpctl schedule <message id/uid>

introduce F_MESSAGE_FORCESCHEDULE which lets the runner schedule a message
even if the retry delay has not been expired.

F_MESSAGE_ENQUEUED is a valid flag for a message and should not cause an\
errx() in smtpctl show queue
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.13 2009/02/22 11:59:12 jacekm Exp $	*/
d24 1
d29 1
d33 1
d263 50
@


1.14
log
@add valid_message_id() and valid_message_uid() which test that a message id
and uid do not look wrong. this was not needed earlier because we only deal
with message id's coming from trusted sources, but smtpctl will soon have a
new feature which requires us to deal with user provided message id's.
@
text
@@


1.13
log
@put repeated inet_ntop calls into new func ss_to_text, which uses
getnameinfo internally; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2009/02/22 11:44:29 form Exp $	*/
d213 47
@


1.12
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2009/02/18 22:39:12 jacekm Exp $	*/
d28 1
d192 21
@


1.11
log
@- add basic syntax checking to mfa
- decline source routing at MAIL FROM, strip at RCPT TO

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 2009/01/28 12:56:46 jacekm Exp $	*/
d140 1
a140 1
	    >= MAX_LOCALPART_SIZE)
d144 1
a144 1
	    >= MAX_DOMAINPART_SIZE)
@


1.10
log
@in safe_fclose, ensure file is closed upon return, and additionally
signify temp failure to the caller if ferror is true; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 2009/01/27 22:48:29 gilles Exp $	*/
d123 1
a123 1
	hostname = strchr(username, '@@');
d148 43
@


1.9
log
@first bricks of enqueue code which allows smtpctl to submit mail to queue
without "talking" smtp to listeners. currently, a big part of the server
side code is done (and requires a cleanup), next step is to get it usable
properly from a mail user agent.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.8 2009/01/27 15:57:01 gilles Exp $	*/
d54 4
a57 1

d59 1
a63 1

a65 1

@


1.8
log
@err, actually session_set_path was moved to utils.c because it was used by
the enqueue code i'm working on, but this is no longer necessary since the
enqueue code uses recipient_to_path. revert part of previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 2009/01/27 15:50:15 gilles Exp $	*/
a116 1
	size_t len;
@


1.7
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 2009/01/08 19:17:31 jacekm Exp $	*/
a146 15
}

int
session_set_path(struct path *path, char *line)
{
	size_t len;
	char *username;
	char *hostname;

	len = strlen(line);
	if (*line != '<' || line[len - 1] != '>')
		return 0;
	line[len - 1] = '\0';

	return recipient_to_path(path, line+1);
@


1.6
log
@ensure getpwnam is always followed by endpwent; ok gilles@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 2009/01/04 17:45:58 gilles Exp $	*/
d81 11
d112 50
@


1.5
log
@When matching a recipient domain to a rule, do not use strcasecmp, but use
new hostname_match() function which recognizes * as a wildcard. We can now
do: accept for domain "*.example.org" to match all subdomains.

idea from Nicholas Marriott <nicholas.marriott@@gmail.com>, hostname_match()
from me in place of his fnmatch() calls.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 2009/01/01 16:15:47 jacekm Exp $	*/
d28 1
d68 11
@


1.4
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.3 2008/12/19 12:09:00 jacekm Exp $	*/
d25 1
d67 22
@


1.3
log
@fix indentation, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.2 2008/12/18 23:57:17 jacekm Exp $	*/
a19 1
#include <sys/stat.h>
a22 1
#include <sys/ioctl.h>
a24 4
#include <netinet/in.h>
#include <arpa/inet.h>

#include <dirent.h>
a26 4
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
a27 1
#include <stdlib.h>
a28 3
#include <sysexits.h>
#include <time.h>
#include <util.h>
@


1.2
log
@Introduce safe_fclose, which tries to push file to the disk as
quickly as possible; it fails under temporary error conditions,
letting caller react appropriately.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.1 2008/12/11 22:17:12 gilles Exp $	*/
d69 1
a69 1
		return 0;
@


1.1
log
@- bsnprintf() is a wrapper to snprintf() that can be used when we handle an
	encoding error or a truncation the same way. This will turn many of
	our snprintf() checks into boolean checks.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 20
@

