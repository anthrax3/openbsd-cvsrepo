head	1.71;
access;
symbols
	OPENBSD_6_0:1.70.0.4
	OPENBSD_6_0_BASE:1.70
	OPENBSD_5_9:1.69.0.2
	OPENBSD_5_9_BASE:1.69
	OPENBSD_5_8:1.66.0.6
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.66.0.2
	OPENBSD_5_7_BASE:1.66
	OPENBSD_5_6:1.65.0.4
	OPENBSD_5_6_BASE:1.65
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.64.0.2
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.61.0.2
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.47.0.2
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.2
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.36.0.2
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16;
locks; strict;
comment	@ * @;


1.71
date	2016.08.31.10.18.08;	author gilles;	state Exp;
branches;
next	1.70;
commitid	jWkTljYAPNXFatSw;

1.70
date	2016.05.21.19.28.19;	author gilles;	state Exp;
branches;
next	1.69;
commitid	t4iw0Qd9VAUC7sFB;

1.69
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.68;
commitid	ZxnqOQqX6IeYI9jW;

1.68
date	2015.11.30.10.56.25;	author gilles;	state Exp;
branches;
next	1.67;
commitid	MkpLGQe6JAKLzC4o;

1.67
date	2015.10.27.20.14.19;	author gilles;	state Exp;
branches;
next	1.66;
commitid	GOsX5yaydgUh46mb;

1.66
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	ZBTFreARDSMmzOIV;

1.65
date	2014.07.08.13.49.09;	author eric;	state Exp;
branches;
next	1.64;
commitid	pEybL9fsrDOC6PJj;

1.64
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.63;

1.63
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.62;

1.62
date	2013.04.01.16.11.32;	author tobias;	state Exp;
branches;
next	1.61;

1.61
date	2013.02.14.12.30.49;	author gilles;	state Exp;
branches;
next	1.60;

1.60
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.59;

1.59
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.57;

1.57
date	2012.10.13.08.01.47;	author eric;	state Exp;
branches;
next	1.56;

1.56
date	2012.09.21.19.37.08;	author eric;	state Exp;
branches;
next	1.55;

1.55
date	2012.09.21.16.40.20;	author eric;	state Exp;
branches;
next	1.54;

1.54
date	2012.09.20.14.28.57;	author eric;	state Exp;
branches;
next	1.53;

1.53
date	2012.09.19.12.59.59;	author eric;	state Exp;
branches;
next	1.52;

1.52
date	2012.09.19.12.45.04;	author eric;	state Exp;
branches;
next	1.51;

1.51
date	2012.09.19.10.10.30;	author eric;	state Exp;
branches;
next	1.50;

1.50
date	2012.09.19.09.06.35;	author eric;	state Exp;
branches;
next	1.49;

1.49
date	2012.09.18.12.54.56;	author eric;	state Exp;
branches;
next	1.48;

1.48
date	2012.07.29.17.21.43;	author gilles;	state Exp;
branches;
next	1.47;

1.47
date	2012.04.21.12.45.05;	author gilles;	state Exp;
branches;
next	1.46;

1.46
date	2012.04.15.13.11.13;	author gilles;	state Exp;
branches;
next	1.45;

1.45
date	2012.03.07.23.22.53;	author gilles;	state Exp;
branches;
next	1.44;

1.44
date	2011.10.11.17.57.10;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2011.05.16.21.05.51;	author gilles;	state Exp;
branches;
next	1.42;

1.42
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.40;

1.40
date	2010.11.28.14.02.46;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.24.11.09.43;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.01.19.47.08;	author jacekm;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.19.20.57.10;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.27.09.49.23;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.09.23.54.08;	author gilles;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.09.23.49.34;	author gilles;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.08.23.20.07;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.08.23.15.03;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.08.23.08.56;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.08.21.40.05;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.03.20.55.23;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.03.19.13.34;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.03.11.10.43;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.12.23.57.44;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.12.22.34.37;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.11.17.40.49;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.08.00.02.22;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.13.21.20.55;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.24.10.02.35;	author jacekm;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.30.06.19.13;	author form;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.28.11.27.57;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.07.00.26.30;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.13.13.15.38;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.11.23.04.45;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.10.23.04.24;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.05.19.09.59;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.05.17.31.54;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.25.23.01.00;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.17.20.16.48;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.10.22.35.23;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.10.03.55.36;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.10.00.57.35;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.71
log
@allow overriding the subaddressing delimiter with subaddressing-delimiter
keyword, the default is still +

ok eric@@, sunil@@
@
text
@/*	$OpenBSD: aliases.c,v 1.70 2016/05/21 19:28:19 gilles Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>

#include <ctype.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <util.h>

#include "smtpd.h"
#include "log.h"

static int aliases_expand_include(struct expand *, const char *);

int
aliases_get(struct expand *expand, const char *username)
{
	struct expandnode      *xn;
	char			buf[SMTPD_MAXLOCALPARTSIZE];
	size_t			nbaliases;
	int			ret;
	union lookup		lk;
	struct table	       *mapping = NULL;
	struct table	       *userbase = NULL;
	char		       *pbuf;

	mapping = expand->rule->r_mapping;
	userbase = expand->rule->r_userbase;

	xlowercase(buf, username, sizeof(buf));

	/* first, check if entry has a user-part tag */
	pbuf = strchr(buf, *env->sc_subaddressing_delim);
	if (pbuf) {
		ret = table_lookup(mapping, NULL, buf, K_ALIAS, &lk);
		if (ret < 0)
			return (-1);
		if (ret)
			goto expand;
		*pbuf = '\0';
	}

	/* no user-part tag, try looking up user */
	ret = table_lookup(mapping, NULL, buf, K_ALIAS, &lk);
	if (ret <= 0)
		return ret;

expand:
	/* foreach node in table_alias expandtree, we merge */
	nbaliases = 0;
	RB_FOREACH(xn, expandtree, &lk.expand->tree) {
		if (xn->type == EXPAND_INCLUDE)
			nbaliases += aliases_expand_include(expand,
			    xn->u.buffer);
		else {
			xn->mapping = mapping;
			xn->userbase = userbase;
			expand_insert(expand, xn);
			nbaliases++;
		}
	}

	expand_free(lk.expand);

	log_debug("debug: aliases_get: returned %zd aliases", nbaliases);
	return nbaliases;
}

int
aliases_virtual_get(struct expand *expand, const struct mailaddr *maddr)
{
	struct expandnode      *xn;
	union lookup		lk;
	char			buf[LINE_MAX];
	char			user[LINE_MAX];
	char			tag[LINE_MAX];
	char			domain[LINE_MAX];
	char		       *pbuf;
	int			nbaliases;
	int			ret;
	struct table	       *mapping = NULL;
	struct table	       *userbase = NULL;

	mapping = expand->rule->r_mapping;
	userbase = expand->rule->r_userbase;

	if (!bsnprintf(user, sizeof(user), "%s", maddr->user))
		return 0;
	if (!bsnprintf(domain, sizeof(domain), "%s", maddr->domain))
		return 0;
	xlowercase(user, user, sizeof(user));
	xlowercase(domain, domain, sizeof(domain));

	memset(tag, '\0', sizeof tag);
	pbuf = strchr(user, *env->sc_subaddressing_delim);
	if (pbuf) {
		if (!bsnprintf(tag, sizeof(tag), "%s", pbuf + 1))
			return 0;
		xlowercase(tag, tag, sizeof(tag));
		*pbuf = '\0';
	}

	/* first, check if entry has a user-part tag */
	if (tag[0]) {
		if (!bsnprintf(buf, sizeof(buf), "%s%c%s@@%s",
			user, *env->sc_subaddressing_delim, tag, domain))
			return 0;
		ret = table_lookup(mapping, NULL, buf, K_ALIAS, &lk);
		if (ret < 0)
			return (-1);
		if (ret)
			goto expand;
	}

	/* then, check if entry exists without user-part tag */
	if (!bsnprintf(buf, sizeof(buf), "%s@@%s", user, domain))
		return 0;
	ret = table_lookup(mapping, NULL, buf, K_ALIAS, &lk);
	if (ret < 0)
		return (-1);
	if (ret)
		goto expand;

	if (tag[0]) {
		/* Failed ? We lookup for username + user-part tag */
		if (!bsnprintf(buf, sizeof(buf), "%s%c%s",
			user, *env->sc_subaddressing_delim, tag))
			return 0;
		ret = table_lookup(mapping, NULL, buf, K_ALIAS, &lk);
		if (ret < 0)
			return (-1);
		if (ret)
			goto expand;
	}

	/* Failed ? We lookup for username only */
	if (!bsnprintf(buf, sizeof(buf), "%s", user))
		return 0;
	ret = table_lookup(mapping, NULL, buf, K_ALIAS, &lk);
	if (ret < 0)
		return (-1);
	if (ret)
		goto expand;

	if (!bsnprintf(buf, sizeof(buf), "@@%s", domain))
		return 0;
	/* Failed ? We lookup for catch all for virtual domain */
	ret = table_lookup(mapping, NULL, buf, K_ALIAS, &lk);
	if (ret < 0)
		return (-1);
	if (ret)
		goto expand;

	/* Failed ? We lookup for a *global* catch all */
	ret = table_lookup(mapping, NULL, "@@", K_ALIAS, &lk);
	if (ret <= 0)
		return (ret);

expand:
	/* foreach node in table_virtual expand, we merge */
	nbaliases = 0;
	RB_FOREACH(xn, expandtree, &lk.expand->tree) {
		if (xn->type == EXPAND_INCLUDE)
			nbaliases += aliases_expand_include(expand,
			    xn->u.buffer);
		else {
			xn->mapping = mapping;
			xn->userbase = userbase;
			expand_insert(expand, xn);
			nbaliases++;
		}
	}

	expand_free(lk.expand);

	log_debug("debug: aliases_virtual_get: '%s' resolved to %d nodes",
	    buf, nbaliases);

	return nbaliases;
}

static int
aliases_expand_include(struct expand *expand, const char *filename)
{
	FILE *fp;
	char *line;
	size_t len, lineno = 0;
	char delim[3] = { '\\', '#', '\0' };

	fp = fopen(filename, "r");
	if (fp == NULL) {
		log_warn("warn: failed to open include file \"%s\".", filename);
		return 0;
	}

	while ((line = fparseln(fp, &len, &lineno, delim, 0)) != NULL) {
		expand_line(expand, line, 0);
		free(line);
	}

	fclose(fp);
	return 1;
}
@


1.70
log
@replace hardcoded '+' with TAG_CHAR define

diff from obadz <github@@obadz.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.69 2015/12/28 22:08:30 jung Exp $	*/
d57 1
a57 1
	pbuf = strchr(buf, TAG_CHAR);
d119 1
a119 1
	pbuf = strchr(user, TAG_CHAR);
d130 1
a130 1
			user, TAG_CHAR, tag, domain))
d150 2
a151 1
		if (!bsnprintf(buf, sizeof(buf), "%s%c%s", user, TAG_CHAR, tag))
@


1.69
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.68 2015/11/30 10:56:25 gilles Exp $	*/
d129 2
a130 2
		if (!bsnprintf(buf, sizeof(buf), "%s+%s@@%s",
			user, tag, domain))
d150 1
a150 1
		if (!bsnprintf(buf, sizeof(buf), "%s+%s", user, tag))
@


1.68
log
@teach aliases expansion how to deal with user+tag

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 1
a111 1
	if (! bsnprintf(user, sizeof(user), "%s", maddr->user))
d113 1
a113 1
	if (! bsnprintf(domain, sizeof(domain), "%s", maddr->domain))
d121 1
a121 1
		if (! bsnprintf(tag, sizeof(tag), "%s", pbuf + 1))
d129 1
a129 1
		if (! bsnprintf(buf, sizeof(buf), "%s+%s@@%s",
d140 1
a140 1
	if (! bsnprintf(buf, sizeof(buf), "%s@@%s", user, domain))
d150 1
a150 1
		if (! bsnprintf(buf, sizeof(buf), "%s+%s", user, tag))
d160 1
a160 1
	if (! bsnprintf(buf, sizeof(buf), "%s", user))
d168 1
a168 1
	if (! bsnprintf(buf, sizeof(buf), "@@%s", domain))
@


1.67
log
@aliases_virtual_check() has been unneeded for a while

ok jung@@, ok sunil@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.66 2015/01/20 17:37:54 deraadt Exp $	*/
d49 1
d55 13
d72 1
d99 3
d111 27
a137 4
	if (! bsnprintf(buf, sizeof(buf), "%s@@%s", maddr->user,
		maddr->domain))
		return 0;	
	xlowercase(buf, buf, sizeof(buf));
d139 3
a141 1
	/* First, we lookup for full entry: user@@domain */
d148 11
d160 2
a161 2
	pbuf = strchr(buf, '@@');
	*pbuf = '\0';
d168 2
a169 1
	*pbuf = '@@';
d171 1
a171 1
	ret = table_lookup(mapping, NULL, pbuf, K_ALIAS, &lk);
@


1.66
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.65 2014/07/08 13:49:09 eric Exp $	*/
d52 1
a52 1
	
a75 44
}

int
aliases_virtual_check(struct table *table, const struct mailaddr *maddr)
{
	char			buf[LINE_MAX];
	char		       *pbuf;
	int			ret;

	if (! bsnprintf(buf, sizeof(buf), "%s@@%s", maddr->user,
		maddr->domain))
		return 0;	
	xlowercase(buf, buf, sizeof(buf));

	/* First, we lookup for full entry: user@@domain */
	ret = table_lookup(table, NULL, buf, K_ALIAS, NULL);
	if (ret < 0)
		return (-1);
	if (ret)
		return 1;

	/* Failed ? We lookup for username only */
	pbuf = strchr(buf, '@@');
	*pbuf = '\0';
	ret = table_lookup(table, NULL, buf, K_ALIAS, NULL);
	if (ret < 0)
		return (-1);
	if (ret)
		return 1;

	*pbuf = '@@';
	/* Failed ? We lookup for catch all for virtual domain */
	ret = table_lookup(table, NULL, pbuf, K_ALIAS, NULL);
	if (ret < 0)
		return (-1);
	if (ret)
		return 1;

	/* Failed ? We lookup for a *global* catch all */
	ret = table_lookup(table, NULL, "@@", K_ALIAS, NULL);
	if (ret <= 0)
		return (ret);

	return 1;
@


1.65
log
@Update the table API: lookup functions can take an optional parameters
dictionnary (currently not set). While there, add a helper for forking
external backends, and remove unused table functions.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
d81 1
a81 1
	char			buf[SMTPD_MAXLINESIZE];
d127 1
a127 1
	char			buf[SMTPD_MAXLINESIZE];
@


1.64
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.61 2013/02/14 12:30:49 gilles Exp $	*/
d53 1
a53 1
	ret = table_lookup(mapping, buf, K_ALIAS, &lk);
d90 1
a90 1
	ret = table_lookup(table, buf, K_ALIAS, NULL);
d99 1
a99 1
	ret = table_lookup(table, buf, K_ALIAS, NULL);
d107 1
a107 1
	ret = table_lookup(table, pbuf, K_ALIAS, NULL);
d114 1
a114 1
	ret = table_lookup(table, "@@", K_ALIAS, NULL);
d142 1
a142 1
	ret = table_lookup(mapping, buf, K_ALIAS, &lk);
d151 1
a151 1
	ret = table_lookup(mapping, buf, K_ALIAS, &lk);
d159 1
a159 1
	ret = table_lookup(mapping, pbuf, K_ALIAS, &lk);
d166 1
a166 1
	ret = table_lookup(mapping, "@@", K_ALIAS, &lk);
@


1.63
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.62 2013/04/01 16:11:32 tobias Exp $	*/
a21 1
#include <sys/param.h>
d42 1
a42 1
	char			buf[MAX_LOCALPART_SIZE];
d45 1
a45 1
	struct expand	       *xp = NULL;
d53 1
a53 1
	ret = table_lookup(mapping, buf, K_ALIAS, (void **)&xp);
d59 1
a59 1
	RB_FOREACH(xn, expandtree, &xp->tree) {
d71 1
a71 1
	expand_free(xp);
d125 1
a125 1
	struct expand	       *xp;
d142 1
a142 1
	ret = table_lookup(mapping, buf, K_ALIAS, (void **)&xp);
d151 1
a151 1
	ret = table_lookup(mapping, buf, K_ALIAS, (void **)&xp);
d159 1
a159 1
	ret = table_lookup(mapping, pbuf, K_ALIAS, (void **)&xp);
d166 1
a166 1
	ret = table_lookup(mapping, "@@", K_ALIAS, (void **)&xp);
d173 1
a173 1
	RB_FOREACH(xn, expandtree, &xp->tree) {
d185 1
a185 1
	expand_free(xp);
d199 1
a199 1
	char delim[3] = { '\\', '\0', '#' };
@


1.62
log
@'#' starts a comment, not a line continuation.

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.61 2013/02/14 12:30:49 gilles Exp $	*/
d81 1
a81 1
	char			buf[MAX_LINE_SIZE];
d127 1
a127 1
	char			buf[MAX_LINE_SIZE];
@


1.61
log
@- smtpctl trace expand, enables tracing of aliases expansion
- replace "users" keyword with "userbase" when providing alternate userbase
- disambiguise expansion nodes when expanding across domains and userbases
- allow use of '=' instead of '=>' when declaring a mapping

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.60 2013/01/31 18:34:43 eric Exp $	*/
d200 1
a200 1
	char delim[3] = { '\\', '#', '\0' };
@


1.60
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.59 2013/01/26 09:37:23 gilles Exp $	*/
d40 1
a40 1
aliases_get(struct table *table, struct expand *expand, const char *username)
d47 2
d50 2
d54 1
a54 1
	ret = table_lookup(table, buf, K_ALIAS, (void **)&xp);
d65 2
d123 1
a123 2
aliases_virtual_get(struct table *table, struct expand *expand,
    const struct mailaddr *maddr)
d131 5
d143 1
a143 1
	ret = table_lookup(table, buf, K_ALIAS, (void **)&xp);
d152 1
a152 1
	ret = table_lookup(table, buf, K_ALIAS, (void **)&xp);
d160 1
a160 1
	ret = table_lookup(table, pbuf, K_ALIAS, (void **)&xp);
d167 1
a167 1
	ret = table_lookup(table, "@@", K_ALIAS, (void **)&xp);
d179 2
@


1.59
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.58 2012/11/12 14:58:53 eric Exp $	*/
d188 1
a188 1
	char delim[] = { '\\', '#' };
@


1.58
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.57 2012/10/13 08:01:47 eric Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
a37 5
static int alias_is_filter(struct expandnode *, const char *, size_t);
static int alias_is_username(struct expandnode *, const char *, size_t);
static int alias_is_address(struct expandnode *, const char *, size_t);
static int alias_is_filename(struct expandnode *, const char *, size_t);
static int alias_is_include(struct expandnode *, const char *, size_t);
d40 1
a40 1
aliases_get(objid_t mapid, struct expand *expand, const char *username)
d42 5
a46 4
	struct map_alias *map_alias;
	struct expandnode *xn;
	char buf[MAX_LOCALPART_SIZE];
	size_t nbaliases;
d48 1
d50 3
a52 3
	map_alias = map_lookup(mapid, buf, K_ALIAS);
	if (map_alias == NULL)
		return (errno ? -1 : 0);
d54 1
a54 1
	/* foreach node in map_alias expandtree, we merge */
d56 1
a56 1
	RB_FOREACH(xn, expandtree, &map_alias->expand.tree) {
d58 2
a59 1
			nbaliases += aliases_expand_include(expand, xn->u.buffer);
d66 1
a66 2
	expand_free(&map_alias->expand);
	free(map_alias);
d73 45
a117 1
aliases_virtual_get(objid_t mapid, struct expand *expand,
d120 6
a125 5
	struct map_virtual *map_virtual;
	struct expandnode *xn;
	char buf[MAX_LINE_SIZE];
	char *pbuf = buf;
	int nbaliases;
d129 1
a129 1
		return 0;
d132 28
a159 9
	map_virtual = map_lookup(mapid, buf, K_VIRTUAL);
	if (map_virtual == NULL) {
		if (errno)
			return (-1);
		pbuf = strchr(buf, '@@');
		map_virtual = map_lookup(mapid, pbuf, K_VIRTUAL);
	}
	if (map_virtual == NULL)
		return (errno ? -1 : 0);
d161 2
a162 1
	/* foreach node in map_virtual expand, we merge */
d164 1
a164 1
	RB_FOREACH(xn, expandtree, &map_virtual->expand.tree) {
d166 2
a167 1
			nbaliases += aliases_expand_include(expand, xn->u.buffer);
d174 4
a177 3
	expand_free(&map_virtual->expand);
	free(map_virtual);
	log_debug("debug: aliases_virtual_get: '%s' resolved to %d nodes", pbuf, nbaliases);
a181 19
int
aliases_vdomain_exists(objid_t mapid, const char *hostname)
{
	struct map_virtual *map_virtual;
	char buf[MAXHOSTNAMELEN];

	xlowercase(buf, hostname, sizeof(buf));
	map_virtual = map_lookup(mapid, buf, K_VIRTUAL);
	if (map_virtual == NULL)
		return (errno ? -1 : 0);

	/* XXX - for now the map API always allocate */
	log_debug("debug: aliases_vdomain_exist: '%s' exists", hostname);
	expand_free(&map_virtual->expand);
	free(map_virtual);

	return 1;
}

d187 1
a187 2
	size_t len;
	size_t lineno = 0;
a188 1
	struct expandnode xn;
d197 1
a197 14
		if (len == 0) {
			free(line);
			continue;
		}

		if (! alias_parse(&xn, line)) {
			log_warnx("warn: could not parse include entry \"%s\".", line);
		}

		if (xn.type == EXPAND_INCLUDE)
			log_warnx("warn: nested inclusion is not supported.");
		else
			expand_insert(expand, &xn);

a201 138
	return 1;
}

int
alias_parse(struct expandnode *alias, char *line)
{
	size_t l;
	char *wsp;

	/* remove ending whitespaces */
	wsp = line + strlen(line);
	while (wsp != line) {
		if (*wsp != '\0' && !isspace((int)*wsp))
			break;
		*wsp-- = '\0';
	}

	l = strlen(line);
	if (alias_is_include(alias, line, l) ||
	    alias_is_filter(alias, line, l) ||
	    alias_is_filename(alias, line, l) ||
	    alias_is_address(alias, line, l) ||
	    alias_is_username(alias, line, l))
		return (1);

	return (0);
}


static int
alias_is_filter(struct expandnode *alias, const char *line, size_t len)
{
	if (*line == '|') {
		if (strlcpy(alias->u.buffer, line + 1,
			sizeof(alias->u.buffer)) >= sizeof(alias->u.buffer))
			return 0;
		alias->type = EXPAND_FILTER;
		return 1;
	}
	return 0;
}

static int
alias_is_username(struct expandnode *alias, const char *line, size_t len)
{
	bzero(alias, sizeof *alias);

	if (strlcpy(alias->u.user, line,
	    sizeof(alias->u.user)) >= sizeof(alias->u.user))
		return 0;

	while (*line) {
		if (!isalnum((int)*line) &&
		    *line != '_' && *line != '.' && *line != '-')
			return 0;
		++line;
	}

	alias->type = EXPAND_USERNAME;
	return 1;
}

static int
alias_is_address(struct expandnode *alias, const char *line, size_t len)
{
	char *domain;

	bzero(alias, sizeof *alias);

	if (len < 3)	/* x@@y */
		return 0;

	domain = strchr(line, '@@');
	if (domain == NULL)
		return 0;

	/* @@ cannot start or end an address */
	if (domain == line || domain == line + len - 1)
		return 0;

	/* scan pre @@ for disallowed chars */
	*domain++ = '\0';
	strlcpy(alias->u.mailaddr.user, line, sizeof(alias->u.mailaddr.user));
	strlcpy(alias->u.mailaddr.domain, domain, sizeof(alias->u.mailaddr.domain));

	while (*line) {
		char allowedset[] = "!#$%*/?|^{}`~&'+-=_.";
		if (!isalnum((int)*line) &&
		    strchr(allowedset, *line) == NULL)
			return 0;
		++line;
	}

	while (*domain) {
		char allowedset[] = "-.";
		if (!isalnum((int)*domain) &&
		    strchr(allowedset, *domain) == NULL)
			return 0;
		++domain;
	}

	alias->type = EXPAND_ADDRESS;
	return 1;
}

static int
alias_is_filename(struct expandnode *alias, const char *line, size_t len)
{
	bzero(alias, sizeof *alias);

	if (*line != '/')
		return 0;

	if (strlcpy(alias->u.buffer, line,
	    sizeof(alias->u.buffer)) >= sizeof(alias->u.buffer))
		return 0;
	alias->type = EXPAND_FILENAME;
	return 1;
}

static int
alias_is_include(struct expandnode *alias, const char *line, size_t len)
{
	size_t skip;

	bzero(alias, sizeof *alias);

	if (strncasecmp(":include:", line, 9) == 0)
		skip = 9;
	else if (strncasecmp("include:", line, 8) == 0)
		skip = 8;
	else
		return 0;

	if (! alias_is_filename(alias, line + skip, len - skip))
		return 0;

	alias->type = EXPAND_INCLUDE;
@


1.57
log
@Make map_lookup() and make_compare() set errno on failure to distinguish
between "no match" and "internal error" (e.g. missing or broken db file).
Adapt alias expansion and ruleset matching code to check for such errors,
in which case the current processing is aborted, and a temporary failure
is reported to the smtp session.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.56 2012/09/21 19:37:08 eric Exp $	*/
d71 1
a71 1
	log_debug("aliases_get: returned %zd aliases", nbaliases);
d113 1
a113 1
	log_debug("aliases_virtual_get: '%s' resolved to %d nodes", pbuf, nbaliases);
d130 1
a130 1
	log_debug("aliases_vdomain_exist: '%s' exists", hostname);
d149 1
a149 1
		log_warn("failed to open include file \"%s\".", filename);
d160 1
a160 1
			log_warnx("could not parse include entry \"%s\".", line);
d164 1
a164 1
			log_warnx("nested inclusion is not supported.");
@


1.56
log
@Do not pass the username to forwards_get() which does not have to care about
this.  Instead, set the username on the expand context, and copy it on the
expand nodes as they are inserted.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.55 2012/09/21 16:40:20 eric Exp $	*/
d26 1
d55 1
a55 1
		return 0;
d92 2
d98 1
a98 1
		return 0;
d127 1
a127 1
		return 0;
@


1.55
log
@wrap expandtree into a "struct expand".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.54 2012/09/20 14:28:57 eric Exp $	*/
a58 1
		strlcpy(xn->as_user, SMTPD_USER, sizeof (xn->as_user));
a99 1
		strlcpy(xn->as_user, SMTPD_USER, sizeof (xn->as_user));
@


1.54
log
@constify parameters that are supposed to be const.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.53 2012/09/19 12:59:59 eric Exp $	*/
d36 1
a36 1
static int aliases_expand_include(struct expandtree *, const char *);
d44 1
a44 1
aliases_get(objid_t mapid, struct expandtree *expandtree, const char *username)
d58 1
a58 1
	RB_FOREACH(xn, expandtree, &map_alias->expandtree) {
d61 1
a61 1
			nbaliases += aliases_expand_include(expandtree, xn->u.buffer);
d63 1
a63 1
			expand_insert(expandtree, xn);
d68 1
a68 1
	expand_free(&map_alias->expandtree);
d76 1
a76 1
aliases_virtual_get(objid_t mapid, struct expandtree *expandtree,
d98 1
a98 1
	/* foreach node in map_virtual expandtree, we merge */
d100 1
a100 1
	RB_FOREACH(xn, expandtree, &map_virtual->expandtree) {
d103 1
a103 1
			nbaliases += aliases_expand_include(expandtree, xn->u.buffer);
d105 1
a105 1
			expand_insert(expandtree, xn);
d110 1
a110 1
	expand_free(&map_virtual->expandtree);
d130 1
a130 1
	expand_free(&map_virtual->expandtree);
d137 1
a137 1
aliases_expand_include(struct expandtree *expandtree, const char *filename)
d165 1
a165 1
			expand_insert(expandtree, &xn);
@


1.53
log
@expandnodes must be bzero()'d before parsing to be sure there is no bogus
data left on return, since the RB compare functions uses memcmp().  While
there, remove all calls to bzero() before alias_parse().

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.52 2012/09/19 12:45:04 eric Exp $	*/
d44 1
a44 1
aliases_get(objid_t mapid, struct expandtree *expandtree, char *username)
d77 1
a77 1
    struct mailaddr *maddr)
d118 1
a118 1
aliases_vdomain_exists(objid_t mapid, char *hostname)
@


1.52
log
@rename variables for consistency

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.51 2012/09/19 10:10:30 eric Exp $	*/
a157 1
		bzero(&xn, sizeof (struct expandnode));
d216 2
d238 2
d279 2
d295 3
a297 1
	
@


1.51
log
@Remove aliases_exists() and aliases_virtual_exists(). The corresponding
*_get() functions can be called directly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.50 2012/09/19 09:06:35 eric Exp $	*/
d47 1
a47 1
	struct expandnode *expnode;
d58 4
a61 4
	RB_FOREACH(expnode, expandtree, &map_alias->expandtree) {
		strlcpy(expnode->as_user, SMTPD_USER, sizeof (expnode->as_user));
		if (expnode->type == EXPAND_INCLUDE)
			nbaliases += aliases_expand_include(expandtree, expnode->u.buffer);
d63 1
a63 1
			expand_insert(expandtree, expnode);
d80 1
a80 1
	struct expandnode *expnode;
d100 4
a103 4
	RB_FOREACH(expnode, expandtree, &map_virtual->expandtree) {
		strlcpy(expnode->as_user, SMTPD_USER, sizeof (expnode->as_user));
		if (expnode->type == EXPAND_INCLUDE)
			nbaliases += aliases_expand_include(expandtree, expnode->u.buffer);
d105 1
a105 1
			expand_insert(expandtree, expnode);
d144 1
a144 1
	struct expandnode expnode;
d158 2
a159 2
		bzero(&expnode, sizeof(struct expandnode));
		if (! alias_parse(&expnode, line)) {
d163 1
a163 1
		if (expnode.type == EXPAND_INCLUDE)
d166 1
a166 1
			expand_insert(expandtree, &expnode);
@


1.50
log
@start cleaning the expansion code:

- change expandtree_* prefix to expand_ for better readability and
  because the structure might change at some point
- rename <>_free_nodes() to <>_free()
- remove unused <>_remove_node()
- refcounting has no purpose at all; just remove it as well as the
  decrement/increment functions, and replace the latter with <>_insert
- expandnode flags is only used to know if it's been processed or not,
  don't make it a flag but a simple field with clear name.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.49 2012/09/18 12:54:56 eric Exp $	*/
a43 21
aliases_exist(objid_t mapid, char *username)
{
	struct map_alias *map_alias;
	char buf[MAX_LOCALPART_SIZE];

	xlowercase(buf, username, sizeof(buf));
	map_alias = map_lookup(mapid, buf, K_ALIAS);
	if (map_alias == NULL)
		return 0;

	/* XXX - for now the map API always allocate */
	log_debug("aliases_exist: '%s' exists with %zd expansion nodes",
	    username, map_alias->nbnodes);

	expand_free(&map_alias->expandtree);
	free(map_alias);

	return 1;
}

int
a75 46
aliases_vdomain_exists(objid_t mapid, char *hostname)
{
	struct map_virtual *map_virtual;
	char buf[MAXHOSTNAMELEN];

	xlowercase(buf, hostname, sizeof(buf));
	map_virtual = map_lookup(mapid, buf, K_VIRTUAL);
	if (map_virtual == NULL)
		return 0;

	/* XXX - for now the map API always allocate */
	log_debug("aliases_vdomain_exist: '%s' exists", hostname);
	expand_free(&map_virtual->expandtree);
	free(map_virtual);

	return 1;
}

int
aliases_virtual_exist(objid_t mapid, struct mailaddr *maddr)
{
	struct map_virtual *map_virtual;
	char buf[MAX_LINE_SIZE];
	char *pbuf = buf;

	if (! bsnprintf(buf, sizeof(buf), "%s@@%s", maddr->user,
		maddr->domain))
		return 0;
	xlowercase(buf, buf, sizeof(buf));

	map_virtual = map_lookup(mapid, buf, K_VIRTUAL);
	if (map_virtual == NULL) {
		pbuf = strchr(buf, '@@');
		map_virtual = map_lookup(mapid, pbuf, K_VIRTUAL);
	}
	if (map_virtual == NULL)
		return 0;

	log_debug("aliases_virtual_exist: '%s' exists", pbuf);
	expand_free(&map_virtual->expandtree);
	free(map_virtual);

	return 1;
}

int
d115 19
@


1.49
log
@a few cleanups:
- make static functions static
- pass const char * rather than char * when we mean that
- make parse_alias() more straightforward

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.48 2012/07/29 17:21:43 gilles Exp $	*/
d58 1
a58 1
	expandtree_free_nodes(&map_alias->expandtree);
d84 1
a84 1
			expandtree_increment_node(expandtree, expnode);
d89 1
a89 1
	expandtree_free_nodes(&map_alias->expandtree);
d109 1
a109 1
	expandtree_free_nodes(&map_virtual->expandtree);
d136 1
a136 1
	expandtree_free_nodes(&map_virtual->expandtree);
d172 1
a172 1
			expandtree_increment_node(expandtree, expnode);
d177 1
a177 1
	expandtree_free_nodes(&map_virtual->expandtree);
d214 1
a214 1
			expandtree_increment_node(expandtree, &expnode);
@


1.48
log
@- introduce xlowercase() and allow lowercase() to fail gracefully
- replace all calls to lowercase() with calls to xlowercase()
- in the format string expansion, lowercase() all formats

we will have to reassess all calls to xlowercase() even though it has never
triggered as far as I know, we can probably gracefully fail some of them.
right now we're just keeping former behaviour.

this commit fixes issue reported by Hugo Osvaldo Barrera where a %u format
could lead to a delivery failure (ie: GILLES@@openbsd.org should be expanded
to gilles, not GILLES ... only for local deliveries).

ok chl@@ on the idea, ok eric@@ on the diff
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.47 2012/04/21 12:45:05 gilles Exp $	*/
d36 6
a41 6
static int aliases_expand_include(struct expandtree *, char *);
static int alias_is_filter(struct expandnode *, char *, size_t);
static int alias_is_username(struct expandnode *, char *, size_t);
static int alias_is_address(struct expandnode *, char *, size_t);
static int alias_is_filename(struct expandnode *, char *, size_t);
static int alias_is_include(struct expandnode *, char *, size_t);
d184 2
a185 2
int
aliases_expand_include(struct expandtree *expandtree, char *filename)
d226 1
a226 8
	size_t i;
	int (*f[])(struct expandnode *, char *, size_t) = {
		alias_is_include,
		alias_is_filter,
		alias_is_filename,
		alias_is_address,
		alias_is_username
	};
d237 7
a243 7
	for (i = 0; i < sizeof(f) / sizeof(void *); ++i) {
		bzero(alias, sizeof(struct expandnode));
		if (f[i](alias, line, strlen(line)))
			break;
	}
	if (i == sizeof(f) / sizeof(void *))
		return 0;
d245 1
a245 1
	return 1;
d249 2
a250 2
int
alias_is_filter(struct expandnode *alias, char *line, size_t len)
d262 2
a263 2
int
alias_is_username(struct expandnode *alias, char *line, size_t len)
d280 2
a281 2
int
alias_is_address(struct expandnode *alias, char *line, size_t len)
d321 2
a322 2
int
alias_is_filename(struct expandnode *alias, char *line, size_t len)
d334 2
a335 2
int
alias_is_include(struct expandnode *alias, char *line, size_t len)
@


1.47
log
@i got the previous fix wrong, /etc/mail/aliases should use SMTPD_USER
privileges. while at it, also apply the same to virtual domains.
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.46 2012/04/15 13:11:13 gilles Exp $	*/
d49 1
a49 1
	lowercase(buf, username, sizeof(buf));
d72 1
a72 1
	lowercase(buf, username, sizeof(buf));
d102 1
a102 1
	lowercase(buf, hostname, sizeof(buf));
d125 1
a125 1
	lowercase(buf, buf, sizeof(buf));
d155 1
a155 1
	lowercase(buf, buf, sizeof(buf));
@


1.46
log
@when using aliases, the *real* delivery user is not set on expand nodes
which prevents filters / filenames from working from /etc/mail/aliases.
in aliases_get() during the rb tree iteration, copy the username to the
expand node.

diff from Christopher Zimmermann, thankkkks and sorry for the delay
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.45 2012/03/07 23:22:53 gilles Exp $	*/
d80 1
a80 1
		strlcpy(expnode->as_user, username, sizeof (expnode->as_user));
d168 1
@


1.45
log
@- remove some map_find() calls that are no longer needed, they are followed
  by a map_lookup() call that does the map_find() internally

spotted and diff by Mathieu <ptr.jetable@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.44 2011/10/11 17:57:10 gilles Exp $	*/
d80 1
@


1.44
log
@fix parsing of :include: aliases
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.43 2011/05/16 21:05:51 gilles Exp $	*/
a45 1
	struct map *map;
a48 4
	map = map_find(mapid);
	if (map == NULL)
		return 0;

a66 1
	struct map *map;
a71 4
	map = map_find(mapid);
	if (map == NULL)
		return 0;

a97 1
	struct map *map;
a100 4
	map = map_find(mapid);
	if (map == NULL)
		return 0;

a110 1

a116 1
	struct map *map;
a120 4
	map = map_find(mapid);
	if (map == NULL)
		return 0;

a144 1
	struct map *map;
a149 4

	map = map_find(mapid);
	if (map == NULL)
		return 0;
@


1.43
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.42 2011/05/01 12:57:11 eric Exp $	*/
d368 7
a374 1
	if (strncasecmp(":include:", line, 9) != 0)
d377 1
a377 1
	if (! alias_is_filename(alias, line + 9, len - 9))
@


1.42
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.41 2011/04/17 13:36:07 gilles Exp $	*/
d91 1
a91 1
			nbaliases += aliases_expand_include(expandtree, expnode->u.filename);
d131 1
a131 1
aliases_virtual_exist(objid_t mapid, struct path *path)
d142 2
a143 2
	if (! bsnprintf(buf, sizeof(buf), "%s@@%s", path->user,
		path->domain))
d164 1
a164 1
    struct path *path)
d177 2
a178 2
	if (! bsnprintf(buf, sizeof(buf), "%s@@%s", path->user,
		path->domain))
d194 1
a194 1
			nbaliases += aliases_expand_include(expandtree, expnode->u.filename);
d283 3
a285 4
	if (strncmp(line, "\"|", 2) == 0 &&
	    line[len - 1] == '"') {
		if (strlcpy(alias->u.filter, line, sizeof(alias->u.filter)) >=
		    sizeof(alias->u.filter))
d296 2
a297 2
	if (strlcpy(alias->u.username, line,
	    sizeof(alias->u.username)) >= sizeof(alias->u.username))
d358 2
a359 2
	if (strlcpy(alias->u.filename, line,
	    sizeof(alias->u.filename)) >= sizeof(alias->u.filename))
@


1.41
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.40 2010/11/28 14:02:46 gilles Exp $	*/
d44 1
a44 1
aliases_exist(struct smtpd *env, objid_t mapid, char *username)
d50 1
a50 1
	map = map_find(env, mapid);
d55 1
a55 1
	map_alias = map_lookup(env, mapid, buf, K_ALIAS);
d70 1
a70 1
aliases_get(struct smtpd *env, objid_t mapid, struct expandtree *expandtree, char *username)
d78 1
a78 1
	map = map_find(env, mapid);
d83 1
a83 1
	map_alias = map_lookup(env, mapid, buf, K_ALIAS);
d106 1
a106 1
aliases_vdomain_exists(struct smtpd *env, objid_t mapid, char *hostname)
d112 1
a112 1
	map = map_find(env, mapid);
d117 1
a117 1
	map_virtual = map_lookup(env, mapid, buf, K_VIRTUAL);
d131 1
a131 1
aliases_virtual_exist(struct smtpd *env, objid_t mapid, struct path *path)
d138 1
a138 1
	map = map_find(env, mapid);
d147 1
a147 1
	map_virtual = map_lookup(env, mapid, buf, K_VIRTUAL);
d150 1
a150 1
		map_virtual = map_lookup(env, mapid, pbuf, K_VIRTUAL);
d163 2
a164 2
aliases_virtual_get(struct smtpd *env, objid_t mapid,
    struct expandtree *expandtree, struct path *path)
d173 1
a173 1
	map = map_find(env, mapid);
d182 1
a182 1
	map_virtual = map_lookup(env, mapid, buf, K_VIRTUAL);
d185 1
a185 1
		map_virtual = map_lookup(env, mapid, pbuf, K_VIRTUAL);
@


1.40
log
@remove unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.39 2010/11/28 13:56:43 gilles Exp $	*/
d36 6
a41 6
int aliases_expand_include(struct expandtree *, char *);
int alias_is_filter(struct expandnode *, char *, size_t);
int alias_is_username(struct expandnode *, char *, size_t);
int alias_is_address(struct expandnode *, char *, size_t);
int alias_is_filename(struct expandnode *, char *, size_t);
int alias_is_include(struct expandnode *, char *, size_t);
@


1.39
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.38 2010/11/24 11:09:43 gilles Exp $	*/
a25 1
#include <errno.h>
a26 1
#include <fcntl.h>
@


1.38
log
@we can't accept up to MAX_LOCALPART_SIZE (128 bytes) for the user part
of an email address at session time, then fatal() when we can't fit it
in a LOGIN_NAME_MAX (32 bytes) buffer in the aliases expansion code.

fix aliases functions to use a buffer that's appropriate, preventing a
fatal() from being triggered in aliases_exist(). bug experienced by
and reported by Jason Houx, if you're testing smtpd you want to update.
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.37 2010/10/09 22:05:35 gilles Exp $	*/
d29 1
d36 1
@


1.37
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.33 2010/05/19 20:57:10 gilles Exp $	*/
d48 1
a48 1
	char buf[MAXLOGNAME];
d75 1
a75 1
	char buf[MAXLOGNAME];
@


1.36
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.34 2010/05/31 23:38:56 jacekm Exp $	*/
d70 1
a70 1
aliases_get(struct smtpd *env, objid_t mapid, struct expandtree *tree, char *username)
d72 1
d75 1
d78 6
a83 1
	map_alias = map_lookup(env, mapid, username, K_ALIAS);
d91 1
a91 1
			nbaliases += aliases_expand_include(tree, expnode->u.filename);
d93 1
a93 1
			expandtree_increment_node(tree, expnode);
@


1.35
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.33 2010/05/19 20:57:10 gilles Exp $	*/
d70 1
a70 1
aliases_get(struct smtpd *env, objid_t mapid, struct expandtree *expandtree, char *username)
a71 1
	struct map *map;
a73 1
	char buf[MAXLOGNAME];
d76 1
a76 6
	map = map_find(env, mapid);
	if (map == NULL)
		return 0;

	lowercase(buf, username, sizeof(buf));
	map_alias = map_lookup(env, mapid, buf, K_ALIAS);
d84 1
a84 1
			nbaliases += aliases_expand_include(expandtree, expnode->u.filename);
d86 1
a86 1
			expandtree_increment_node(expandtree, expnode);
@


1.34
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d70 1
a70 1
aliases_get(struct smtpd *env, objid_t mapid, struct expandtree *tree, char *username)
d72 1
d75 1
d78 6
a83 1
	map_alias = map_lookup(env, mapid, username, K_ALIAS);
d91 1
a91 1
			nbaliases += aliases_expand_include(tree, expnode->u.filename);
d93 1
a93 1
			expandtree_increment_node(tree, expnode);
@


1.33
log
@cleanup-only commit, removes unrequired includes, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.32 2010/04/27 09:49:23 gilles Exp $	*/
d70 1
a70 1
aliases_get(struct smtpd *env, objid_t mapid, struct expandtree *expandtree, char *username)
a71 1
	struct map *map;
a73 1
	char buf[MAXLOGNAME];
d76 1
a76 6
	map = map_find(env, mapid);
	if (map == NULL)
		return 0;

	lowercase(buf, username, sizeof(buf));
	map_alias = map_lookup(env, mapid, buf, K_ALIAS);
d84 1
a84 1
			nbaliases += aliases_expand_include(expandtree, expnode->u.filename);
d86 1
a86 1
			expandtree_increment_node(expandtree, expnode);
@


1.32
log
@initial work at fixing aliases support:
- kill struct alias, struct expandnode is used instead
- introduce map_parse_alias() and map_parse_virtual()
- aliases and virtual code no longer assume db(3) but use the map API which
  lets them become backend agnostic AND value-checked. this actually makes
  the code simpler by removing all values parsing from aliases.c
- rename K_SECRETS -> K_SECRET, K_ALIASES -> K_ALIAS for consistency the
  enum has singular names.
- aliases, virtual and forward now work with an expandtree and deal with
  multiple levels of resolving by merging expandtree's

more coming soon ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.31 2009/11/09 23:54:08 gilles Exp $	*/
a25 1
#include <db.h>
@


1.31
log
@now that we don't keep an expand_node in memory for each expansion result,
we don't need to calloc them as they won't be saved in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.30 2009/11/09 23:49:34 gilles Exp $	*/
d38 5
a42 5
int alias_is_filter(struct alias *, char *, size_t);
int alias_is_username(struct alias *, char *, size_t);
int alias_is_address(struct alias *, char *, size_t);
int alias_is_filename(struct alias *, char *, size_t);
int alias_is_include(struct alias *, char *, size_t);
d47 2
a49 5
	int ret;
	DBT key;
	DBT val;
	DB *aliasesdb;
	struct map *map;
d55 3
a57 3
	aliasesdb = dbopen(map->m_config, O_RDONLY, 0600, DB_HASH, NULL);
	if (aliasesdb == NULL) {
		log_warn("aliases_exist: dbopen: %s", map->m_config);
a58 1
	}
d60 3
a62 1
	lowercase(buf, username, sizeof(buf));
d64 2
a65 2
	key.data = buf;
	key.size = strlen(key.data) + 1;
d67 1
a67 6
	ret = aliasesdb->get(aliasesdb, &key, &val, 0);
	if (ret == -1)
		log_warn("aliases_exist");
	aliasesdb->close(aliasesdb);

	return (ret == 0);
d73 3
d77 1
a77 9
	int ret;
	DBT key;
	DBT val;
	DB *aliasesdb;
	size_t nbaliases, nbsave;
	struct alias alias;
	struct alias *nextalias;
	struct map *map;
	struct expand_node expnode;
d83 3
a85 3
	aliasesdb = dbopen(map->m_config, O_RDONLY, 0600, DB_HASH, NULL);
	if (aliasesdb == NULL) {
		log_warn("aliases_get: dbopen: %s", map->m_config);
a86 1
	}
d88 9
a96 10
	lowercase(buf, username, sizeof(buf));

	key.data = buf;
	key.size = strlen(key.data) + 1;

	if ((ret = aliasesdb->get(aliasesdb, &key, &val, 0)) != 0) {
		if (ret == -1)
			log_warn("aliases_get");
		aliasesdb->close(aliasesdb);
		return 0;
d99 2
a100 5
	nbsave = nbaliases = val.size / sizeof(struct alias);
	if (nbaliases == 0) {
		aliasesdb->close(aliasesdb);
		return 0;
	}
d102 2
a103 15
	nextalias = (struct alias *)val.data;
	do {
		alias = *nextalias;
		++nextalias;
		if (alias.type == EXPAND_INCLUDE) {
			aliases_expand_include(expandtree, alias.u.filename);
		}
		else {
			bzero(&expnode, sizeof(struct expand_node));
			alias_to_expand_node(&expnode, &alias);
			expandtree_increment_node(expandtree, &expnode);
		}
	} while (--nbaliases);
	aliasesdb->close(aliasesdb);
	return nbsave;
a108 4
	int	ret;
	DBT	key;
	DBT	val;
	DB     *vtable;
d110 2
a111 1
	char	strkey[MAX_LINE_SIZE];
d117 3
a119 3
	vtable = dbopen(map->m_config, O_RDONLY, 0600, DB_HASH, NULL);
	if (vtable == NULL) {
		log_warn("aliases_vdomain_exists: dbopen: %s", map->m_config);
a120 1
	}
d122 4
a125 5
	if (! bsnprintf(strkey, sizeof(strkey), "%s", hostname)) {
		vtable->close(vtable);
		return 0;
	}
	lowercase(strkey, strkey, sizeof(strkey));
a126 2
	key.data = strkey;
	key.size = strlen(key.data) + 1;
d128 1
a128 7
	ret = vtable->get(vtable, &key, &val, 0);
	if (ret == -1)
		log_warn("aliases_vdomain_exists");

	vtable->close(vtable);

	return (ret == 0);
a133 4
	int ret;
	DBT key;
	DBT val;
	DB *aliasesdb;
d135 3
a137 1
	char	strkey[MAX_LINE_SIZE];
d143 2
a144 3
	aliasesdb = dbopen(map->m_config, O_RDONLY, 0600, DB_HASH, NULL);
	if (aliasesdb == NULL) {
		log_warn("aliases_virtual_exist: dbopen: %s", map->m_config);
d146 6
d153 1
a153 4

	if (! bsnprintf(strkey, sizeof(strkey), "%s@@%s", path->user,
		path->domain)) {
		aliasesdb->close(aliasesdb);
a154 1
	}
d156 3
a158 1
	lowercase(strkey, strkey, sizeof(strkey));
d160 1
a160 24
	key.data = strkey;
	key.size = strlen(key.data) + 1;

	if ((ret = aliasesdb->get(aliasesdb, &key, &val, 0)) != 0) {
		if (ret == -1)
			log_warn("aliases_virtual_exist");

		if (! bsnprintf(strkey, sizeof(strkey), "@@%s", path->domain)) {
			aliasesdb->close(aliasesdb);
			return 0;
		}

		lowercase(strkey, strkey, sizeof(strkey));

		key.data = strkey;
		key.size = strlen(key.data) + 1;

		ret = aliasesdb->get(aliasesdb, &key, &val, 0);
	}
	if (ret == -1)
		log_warn("aliases_virtual_exist");
	aliasesdb->close(aliasesdb);

	return (ret == 0);
a166 7
	int ret;
	DBT key;
	DBT val;
	DB *aliasesdb;
	size_t nbaliases, nbsave;
	struct alias alias;
	struct alias *nextalias;
d168 5
a172 2
	char	strkey[MAX_LINE_SIZE];
	struct expand_node expnode;
d178 2
a179 3
	aliasesdb = dbopen(map->m_config, O_RDONLY, 0600, DB_HASH, NULL);
	if (aliasesdb == NULL) {
		log_warn("aliases_virtual_get: dbopen: %s", map->m_config);
d181 6
d188 1
a188 4

	if (! bsnprintf(strkey, sizeof(strkey), "%s@@%s", path->user,
		path->domain)) {
		aliasesdb->close(aliasesdb);
a189 1
	}
d191 8
a198 24
	lowercase(strkey, strkey, sizeof(strkey));

	key.data = strkey;
	key.size = strlen(key.data) + 1;

	if ((ret = aliasesdb->get(aliasesdb, &key, &val, 0)) != 0) {
		if (ret == -1)
			log_warn("aliases_virtual_get");

		if (! bsnprintf(strkey, sizeof(strkey), "@@%s", path->domain)) {
			aliasesdb->close(aliasesdb);
			return 0;
		}

		lowercase(strkey, strkey, sizeof(strkey));

		key.data = strkey;
		key.size = strlen(key.data) + 1;

		if ((ret = aliasesdb->get(aliasesdb, &key, &val, 0)) != 0) {
			if (ret == -1)
				log_warn("aliases_virtual_get");
			aliasesdb->close(aliasesdb);
			return 0;
d202 3
a204 5
	nbsave = nbaliases = val.size / sizeof(struct alias);
	if (nbaliases == 0) {
		aliasesdb->close(aliasesdb);
		return 0;
	}
d206 1
a206 15
	nextalias = (struct alias *)val.data;
	do {
		alias = *nextalias;
		++nextalias;
		if (alias.type == EXPAND_INCLUDE) {
			aliases_expand_include(expandtree, alias.u.filename);
		}
		else {
			bzero(&expnode, sizeof(struct expand_node));
			alias_to_expand_node(&expnode, &alias);
			expandtree_increment_node(expandtree, &expnode);
		}
	} while (--nbaliases);
	aliasesdb->close(aliasesdb);
	return nbsave;
d217 1
a217 2
	struct alias alias;
	struct expand_node expnode;
d230 3
a232 1
		if (! alias_parse(&alias, line)) {
d236 1
a236 1
		if (alias.type == EXPAND_INCLUDE) {
d238 1
a238 4
		}
		else {
			bzero(&expnode, sizeof(struct expand_node));
			alias_to_expand_node(&expnode, &alias);
a239 1
		}
d249 1
a249 1
alias_parse(struct alias *alias, char *line)
d252 1
a252 1
	int (*f[])(struct alias *, char *, size_t) = {
d270 1
a270 1
		bzero(alias, sizeof(struct alias));
d282 1
a282 1
alias_is_filter(struct alias *alias, char *line, size_t len)
d296 1
a296 1
alias_is_username(struct alias *alias, char *line, size_t len)
d314 1
a314 1
alias_is_address(struct alias *alias, char *line, size_t len)
d355 1
a355 1
alias_is_filename(struct alias *alias, char *line, size_t len)
d368 1
a368 1
alias_is_include(struct alias *alias, char *line, size_t len)
a377 7
}

void
alias_to_expand_node(struct expand_node *expnode, struct alias *alias)
{
	expnode->type = alias->type;
	expnode->u = alias->u;
@


1.30
log
@- add a reference count and flags to struct expand_node
- during expansion, no longer create a new node for each result but try to
  lookup for an existing equivalent node and increment its reference count
  so that: a) we save on memory, b) we don't need to expand the same users
  again and again just because they keep appearing in expansion results.
- while expanding, flag nodes as F_EXPAND_DONE so that we know which nodes
  we already processed
- be smarter when expanding, if we have a clue that an iteration has not
  brought any new result (because no new nodes were added and all existing
  nodes have F_EXPAND_DONE), end expansion and proceed to delivery.
- various small cleanups

discussed with jacekm@@ yesterday, rebuild aliases db, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.29 2009/11/08 23:20:07 gilles Exp $	*/
d89 1
a89 1
	struct expand_node *expnode;
d127 3
a129 5
			expnode = calloc(sizeof(struct expand_node), 1);
			if (expnode == NULL)
				fatal("aliases_get: calloc");
			alias_to_expand_node(expnode, &alias);
			expandtree_increment_node(expandtree, expnode);
d241 1
a241 1
	struct expand_node *expnode;
d300 3
a302 5
			expnode = calloc(sizeof(struct expand_node), 1);
			if (expnode== NULL)
				fatal("aliases_virtual_get: calloc");
			alias_to_expand_node(expnode, &alias);
			expandtree_increment_node(expandtree, expnode);
d318 1
a318 1
	struct expand_node *expnode;
d339 3
a341 5
			expnode = calloc(sizeof(struct expand_node), 1);
			if (expnode== NULL)
				fatal("aliases_virtual_get: calloc");
			alias_to_expand_node(expnode, &alias);
			expandtree_increment_node(expandtree, expnode);
@


1.29
log
@add an alias_to_expand_node() function and use it in aliases.c
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.28 2009/11/08 23:15:03 gilles Exp $	*/
d131 1
a131 1
			expandtree_insert(expandtree, expnode);
d306 1
a306 1
			expandtree_insert(expandtree, expnode);
d347 1
a347 1
			expandtree_insert(expandtree, expnode);
@


1.28
log
@move expansion code to new expand.c to clearly separate it from aliases
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.27 2009/11/08 23:08:56 gilles Exp $	*/
d130 1
a130 2
			expnode->type = alias.type;
			expnode->u = alias.u;
d305 1
a305 2
			expnode->type = alias.type;
			expnode->u = alias.u;
d346 1
a346 2
			expnode->type = alias.type;
			expnode->u = alias.u;
d487 7
@


1.27
log
@rework a bit expansion and data structures involved in the expansion so we
no longer have a direct mapping between structures saved in aliases/virtual
db and structures used at runtime during expansion.

side effects ? struct alias is smaller, databases are smaller and it is no
longer necessary to rebuild aliases/virtual databases each time jacekm@@ or
I make changes to some obscure structure used indirectely during expansion

rebuild databases, flush queues, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.26 2009/11/08 21:40:05 gilles Exp $	*/
a490 41

struct expand_node *
expandtree_lookup(struct expandtree *expandtree, struct expand_node *node)
{
	struct expand_node key;

	key = *node;
	return RB_FIND(expandtree, expandtree, &key);
}

void
expandtree_insert(struct expandtree *expandtree, struct expand_node *node)
{
	node->id = generate_uid();
	RB_INSERT(expandtree, expandtree, node);
}

void
expandtree_remove(struct expandtree *expandtree, struct expand_node *node)
{
	struct expand_node *p;

	p = expandtree_lookup(expandtree, node);
	if (p == NULL)
		fatalx("expandtree_remove: node doesn't exist.");
	RB_REMOVE(expandtree, expandtree, node);
}

int
expand_cmp(struct expand_node *e1, struct expand_node *e2)
{
	if (e1->id < e2->id)
		return -1;

	if (e1->id > e2->id)
		return 1;

	return 0;
}

RB_GENERATE(expandtree, expand_node, entry, expand_cmp);
@


1.26
log
@- make aliases expansion use a rb tree instead of a tail queue, the code
  doesn't take advantage of the new structure yet, but this was a needed
  change for upcoming improvements.
- introduce aliasestree_{lookup,insert,remove} to the aliases api
- rename queue_generate_id() to generate_uid() and move it to utils.c as
  it is used all over the place and not only in queue

tree idea discussed with jacekm@@, if you update rebuild aliases db, make
clean and flush queue
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.25 2009/11/03 20:55:23 gilles Exp $	*/
d37 1
a37 1
int aliases_expand_include(struct aliasestree *, char *);
d78 1
a78 1
aliases_get(struct smtpd *env, objid_t mapid, struct aliasestree *aliases, char *username)
a86 1
	struct alias *aliasp;
d89 1
d123 2
a124 2
		if (alias.type == ALIAS_INCLUDE) {
			aliases_expand_include(aliases, alias.u.filename);
d127 2
a128 2
			aliasp = calloc(1, sizeof(struct alias));
			if (aliasp == NULL)
d130 3
a132 2
			*aliasp = alias;
			aliasestree_insert(aliases, aliasp);
d233 1
a233 1
    struct aliasestree *aliases, struct path *path)
a240 1
	struct alias *aliasp;
d244 1
d299 2
a300 2
		if (alias.type == ALIAS_INCLUDE) {
			aliases_expand_include(aliases, alias.u.filename);
d303 2
a304 2
			aliasp = calloc(1, sizeof(struct alias));
			if (aliasp == NULL)
d306 3
a308 2
			*aliasp = alias;
			aliasestree_insert(aliases, aliasp);
d316 1
a316 1
aliases_expand_include(struct aliasestree *aliases, char *filename)
d324 1
a324 1
	struct alias *aliasp;
d341 1
a341 1
		if (alias.type == ALIAS_INCLUDE) {
d345 6
a350 5
			aliasp = calloc(1, sizeof(struct alias));
			if (aliasp == NULL)
				fatal("aliases_expand_include: calloc");
			*aliasp = alias;
			aliasestree_insert(aliases, aliasp);
d401 1
a401 1
		alias->type = ALIAS_FILTER;
d421 1
a421 1
	alias->type = ALIAS_USERNAME;
d443 2
a444 2
	strlcpy(alias->u.path.user, line, sizeof(alias->u.path.user));
	strlcpy(alias->u.path.domain, domain, sizeof(alias->u.path.domain));
d462 1
a462 1
	alias->type = ALIAS_ADDRESS;
d475 1
a475 1
	alias->type = ALIAS_FILENAME;
d488 1
a488 1
	alias->type = ALIAS_INCLUDE;
d492 2
a493 2
int
alias_cmp(struct alias *a1, struct alias *a2)
d495 1
a495 8
	/*
	 * do not return u_int64_t's
	 */
	if (a1->id < a2->id)
		return (-1);

	if (a1->id > a2->id)
		return (1);
d497 2
a498 1
	return (0);
d501 2
a502 2
struct alias *
aliasestree_lookup(struct aliasestree *aliasestree, struct alias *alias)
d504 2
a505 4
	struct alias key;

	key = *alias;
	return RB_FIND(aliasestree, aliasestree, &key);
d509 1
a509 1
aliasestree_insert(struct aliasestree *aliasestree, struct alias *alias)
d511 6
a516 2
	alias->id = generate_uid();
	RB_INSERT(aliasestree, aliasestree, alias);
d519 2
a520 2
void
aliasestree_remove(struct aliasestree *aliasestree, struct alias *alias)
d522 2
a523 1
	struct alias *node;
d525 4
a528 4
	node = aliasestree_lookup(aliasestree, alias);
	if (node == NULL)
		fatalx("aliasestree_remove: node doesn't exist.");
	RB_REMOVE(aliasestree, aliasestree, alias);
d531 1
a531 1
RB_GENERATE(aliasestree, alias, entry, alias_cmp);
@


1.25
log
@this commit removes the hardcoded special "aliases" map and brings support
for multiple aliases maps that can be attached at the rule level. with it,
you can for example define different aliases maps for different domains or
different aliases maps for the same domain depending on the client source:

map "localiases" { source db "/etc/mail/localiases.db" }
map "netaliases" { source db "/etc/mail/netaliases.db" }

accept from 192.168.0.0/16 for local alias "localiases" deliver to mbox
accept from all for local alias "netaliases" deliver to mbox

idea discussed with jacekm@@ and various other hackers, diff contains some
bug fixes too which were not part of the original diff. man page follows
very shortly ... make clean & flush queue !
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.24 2009/11/03 19:13:34 gilles Exp $	*/
d37 1
a37 1
int aliases_expand_include(struct aliaseslist *, char *);
d78 1
a78 1
aliases_get(struct smtpd *env, objid_t mapid, struct aliaseslist *aliases, char *username)
d131 1
a131 1
			TAILQ_INSERT_HEAD(aliases, aliasp, entry);
d232 1
a232 1
    struct aliaseslist *aliases, struct path *path)
d306 1
a306 1
			TAILQ_INSERT_HEAD(aliases, aliasp, entry);
d314 1
a314 1
aliases_expand_include(struct aliaseslist *aliases, char *filename)
d347 1
a347 1
			TAILQ_INSERT_TAIL(aliases, aliasp, entry);
d488 44
@


1.24
log
@- remove a useless member of struct cond
- have virtual related functions take a map id instead of a map
- shrink a tiny bit ruleset matching
- add missing lka_resolve_path() call in aliases resolution leading to
  issues spotted by nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.23 2009/11/03 11:10:43 jacekm Exp $	*/
d45 1
a45 1
aliases_exist(struct smtpd *env, char *username)
d54 1
a54 1
	map = map_findbyname(env, "aliases");
d78 1
a78 1
aliases_get(struct smtpd *env, struct aliaseslist *aliases, char *username)
d91 1
a91 1
	map = map_findbyname(env, "aliases");
@


1.23
log
@Improve error logging.
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.22 2009/10/12 23:57:44 gilles Exp $	*/
d139 1
a139 1
aliases_vdomain_exists(struct smtpd *env, struct map *map, char *hostname)
d145 1
d148 1
d177 1
a177 1
aliases_virtual_exist(struct smtpd *env, struct map *map, struct path *path)
d183 1
d186 1
d231 1
a231 1
aliases_virtual_get(struct smtpd *env, struct map *map,
d242 1
d245 1
@


1.22
log
@trim ending whitespaces in aliases files otherwhise makemap will fail to
parse values correctly when ran in aliases mode, and smtpd will fail to
parse values correctly when reading an include file
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.21 2009/10/12 22:34:37 gilles Exp $	*/
d60 1
a60 1
		log_warn("aliases_exist: dbopen");
d97 1
a97 1
		log_warn("aliases_get: dbopen");
d152 1
a152 1
		log_warn("aliases_vdomain_exists: dbopen");
d188 1
a188 1
		log_warn("aliases_virtual_exist: dbopen");
d245 1
a245 1
		log_warn("aliases_virtual_get: dbopen");
@


1.21
log
@- fix a null deref which could happen after a couple iterations of the
  aliases/virtual domains resolution code.

- fix a logic bug which caused virtual domains not to be correctly
  handled after one iteration of the aliases resolution code.

- introduce a few helper functions to help clean up and simplify the
  lka code.

- simplify the IS_EXT/IS_MAILBOX/IS_RELAY macros so they manipulate a
  struct path * instead of the mess of dereferences we were passing them.
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.20 2009/10/11 17:40:49 gilles Exp $	*/
d362 9
@


1.20
log
@implement proper virtual domains instead of faking them on top of primary
domains. this means that:

- virtual domains no longer deliver to a local user when not told to
- they no longer attempt to resolve aliases when not told to
- they no longer need an explicit rule in smtpd.conf for EACH domain
- the "virtual" map is no longer hardcoded
- smtpd no longer needs a restart to support a new domain

instead we introduce the: accept for virtual map "mapname" [...] syntax
which refers to a map that can be manipulated at runtime.

idea discussed and okayd with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.19 2009/08/08 00:02:22 gilles Exp $	*/
d147 3
d183 3
d239 3
@


1.19
log
@import some changes from portable smtpd to reduce the delta between both.
this commit contains mostly missing casts and cosmethic changes, do not
expect to build this anywhere but on OpenBSD, it does not contain any of
the portable glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.18 2009/05/13 21:20:55 jacekm Exp $	*/
d139 34
a172 1
aliases_virtual_exist(struct smtpd *env, struct path *path)
a177 1
	struct map *map;
a179 4
	map = map_findbyname(env, "virtual");
	if (map == NULL)
		return 0;

d221 2
a222 2
aliases_virtual_get(struct smtpd *env, struct aliaseslist *aliases,
	struct path *path)
a231 1
	struct map *map;
a232 4

	map = map_findbyname(env, "virtual");
	if (map == NULL)
		return 0;
@


1.18
log
@log dbopen and db->get errors; based on diff from Daniel Ouellet.
looks ok to gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.17 2009/04/24 10:02:35 jacekm Exp $	*/
d365 1
a365 1
		if (!isalnum(*line) &&
d398 1
a398 1
		if (!isalnum(*line) &&
d406 1
a406 1
		if (!isalnum(*domain) &&
@


1.17
log
@Make aliases case-insensitive, issue reported by Daniel Ouelett; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.16 2009/01/30 06:19:13 form Exp $	*/
d59 2
a60 1
	if (aliasesdb == NULL)
d62 1
d69 3
a71 4
	if ((ret = aliasesdb->get(aliasesdb, &key, &val, 0)) == -1) {
		aliasesdb->close(aliasesdb);
		return 0;
	}
d74 1
a74 1
	return ret == 0 ? 1 : 0;
d96 2
a97 1
	if (aliasesdb == NULL)
d99 1
d107 2
d153 2
a154 1
	if (aliasesdb == NULL)
d156 1
d170 2
d183 1
a183 4
		if ((ret = aliasesdb->get(aliasesdb, &key, &val, 0)) != 0) {
			aliasesdb->close(aliasesdb);
			return 0;
		}
d185 2
d189 1
a189 1
	return ret == 0 ? 1 : 0;
d212 2
a213 1
	if (aliasesdb == NULL)
d215 1
d229 2
d243 2
d288 1
a288 1
		log_warnx("failed to open include file \"%s\".", filename);
@


1.16
log
@o remove useless `if's
o replace constants by sizeof where possible

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.15 2009/01/28 11:27:57 gilles Exp $	*/
d47 1
d62 3
a64 1
	key.data = username;
d79 1
d98 3
a100 1
	key.data = username;
d157 2
d169 2
d213 2
d224 2
@


1.15
log
@add a struct path to struct message so that we can keep track of the RCPT
provided recipient even after aliases/forwards expansion, we'll need this
for loop detection.

message id and uid being MAXPATHLEN long is a waste, define MAX_ID_SIZE
which is currently set to 64 (but can probably be further reduced) and
make sure that structures and the few strlcpy's use the right define.

original idea by jacekm@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.14 2009/01/07 00:26:30 gilles Exp $	*/
d145 1
a145 1
	if (! bsnprintf(strkey, MAX_LINE_SIZE, "%s@@%s", path->user,
d156 1
a156 1
		if (! bsnprintf(strkey, MAX_LINE_SIZE, "@@%s", path->domain)) {
d197 1
a197 1
	if (! bsnprintf(strkey, MAX_LINE_SIZE, "%s@@%s", path->user,
d208 1
a208 1
		if (! bsnprintf(strkey, MAX_LINE_SIZE, "@@%s", path->domain)) {
d320 2
a321 2
		if (strlcpy(alias->u.filter, line, MAXPATHLEN) >=
		    MAXPATHLEN)
d332 2
a333 4
	if (len >= MAXLOGNAME)
		return 0;

	if (strlcpy(alias->u.username, line, MAXLOGNAME) >= MAXLOGNAME)
d365 2
a366 2
	strlcpy(alias->u.path.user, line, MAX_LOCALPART_SIZE);
	strlcpy(alias->u.path.domain, domain, MAX_DOMAINPART_SIZE);
d391 1
a391 1
	if (len >= MAXPATHLEN)
d394 2
a395 1
	if (*line != '/')
a396 2

	strlcpy(alias->u.filename, line, MAXPATHLEN);
@


1.14
log
@- when performing aliases expansion, do not forget to set an action to each
expanded envelope, orelse they will use the default action and be passed to
MTA no matter if recipient is local or not.
	bug reported by Nicholas Marriott <nicholas.marriott@@gmail.com>,
	fixed by me and okayd by jacekm@@, collaborative work ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.13 2009/01/01 16:15:47 jacekm Exp $	*/
d367 2
a368 2
	strlcpy(alias->u.path.user, line, MAXPATHLEN);
	strlcpy(alias->u.path.domain, domain, MAXPATHLEN);
@


1.13
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.12 2008/12/13 13:15:38 jacekm Exp $	*/
d80 1
a80 1
	size_t nbaliases;
d102 1
a102 1
	nbaliases = val.size / sizeof(struct alias);
d124 1
a124 1
	return 1;
d182 1
a182 1
	size_t nbaliases;
d222 1
a222 1
	nbaliases = val.size / sizeof(struct alias);
d244 1
a244 1
	return 1;
@


1.12
log
@Declare alias_parse in smtpd.h, and fix callers that pass it wrong
number of arguments.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.11 2008/12/11 23:04:45 gilles Exp $	*/
a29 4
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
a32 1
#include <unistd.h>
@


1.11
log
@- snprintf -> bsnprintf
- makemap and newaliases need util.c now
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.10 2008/12/10 23:04:24 jacekm Exp $	*/
a42 1
int alias_parse(struct alias *, char *);
@


1.10
log
@That the "aliases" and "virtual" maps satisfy m_src == S_DB is checked
too late, ie. at alias resolution time, and it's only a log_info.

Move the check to parse.y, and make daemon die if m_src != S_DB.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.9 2008/12/05 19:09:59 gilles Exp $	*/
a141 1
	int spret;
d151 2
a152 2
	spret = snprintf(strkey, MAX_LINE_SIZE, "%s@@%s", path->user, path->domain);
	if (spret == -1 || spret >= MAX_LINE_SIZE) {
d162 1
a162 2
		spret = snprintf(strkey, MAX_LINE_SIZE, "@@%s", path->domain);
		if (spret == -1 || spret >= MAX_LINE_SIZE) {
a193 1
	int spret;
d203 2
a204 2
	spret = snprintf(strkey, MAX_LINE_SIZE, "%s@@%s", path->user, path->domain);
	if (spret == -1 || spret >= MAX_LINE_SIZE) {
d214 1
a214 2
		spret = snprintf(strkey, MAX_LINE_SIZE, "@@%s", path->domain);
		if (spret == -1 || spret >= MAX_LINE_SIZE) {
@


1.9
log
@- more err/errx -> fatal/fatalx, warn/warnx -> log_warn/log_warnx
	contains bits based on an old diff from Jacek Masiulaniec and
	other bits from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.8 2008/12/05 17:31:54 gilles Exp $	*/
a62 5
	if (map->m_src != S_DB) {
		log_info("map source for \"aliases\" must be \"db\".");
		return 0;
	}

a95 5
	if (map->m_src != S_DB) {
		log_info("map source for \"aliases\" must be \"db\".");
		return 0;
	}

a147 5
	if (map->m_src != S_DB) {
		log_info("map source for \"virtual\" must be \"db\".");
		return 0;
	}

a200 5

	if (map->m_src != S_DB) {
		log_info("map source for \"virtual\" must be \"db\".");
		return 0;
	}
@


1.8
log
@- err -> fatal(), old diff from Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.7 2008/11/25 23:01:00 gilles Exp $	*/
d290 1
a290 1
		warnx("failed to open include file \"%s\".", filename);
d300 1
a300 1
			warnx("could not parse include entry \"%s\".", line);
d304 1
a304 1
			warnx("nested inclusion is not supported.");
@


1.7
log
@- move prototypes to smtpd.h
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.6 2008/11/17 20:16:48 gilles Exp $	*/
a26 1
#include <err.h>
d134 1
a134 1
				err(1, "calloc");
d268 1
a268 1
				err(1, "calloc");
d309 1
a309 1
				err(1, "calloc");
@


1.6
log
@- fix error message in aliases_virtual_exist()

By Alexander Hall <alexander@@beard.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.5 2008/11/10 22:35:23 gilles Exp $	*/
a42 4
int aliases_exist(struct smtpd *, char *);
int aliases_get(struct smtpd *, struct aliaseslist *, char *);
int aliases_virtual_exist(struct smtpd *, struct path *);
int aliases_virtual_get(struct smtpd *, struct aliaseslist *, struct path *);
a43 1

@


1.5
log
@- define MAX_LINE_SIZE which is the maximum length of a line we allow from
	a client. it must be set to the highest value we have from all of
	the extensions which are/will be implemented.
- replace all occurences of STRLEN define with MAX_LINE_SIZE, kill STRLEN
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.4 2008/11/10 03:55:36 tedu Exp $	*/
d165 1
a165 1
		log_info("map source for \"aliases\" must be \"db\".");
@


1.4
log
@last character in line is at len - 1. ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.3 2008/11/10 00:57:35 gilles Exp $	*/
d157 1
a157 1
	char	strkey[STRLEN];
d173 2
a174 2
	spret = snprintf(strkey, STRLEN, "%s@@%s", path->user, path->domain);
	if (spret == -1 || spret >= STRLEN) {
d184 2
a185 2
		spret = snprintf(strkey, STRLEN, "@@%s", path->domain);
		if (spret == -1 || spret >= STRLEN) {
d216 1
a216 1
	char	strkey[STRLEN];
d232 2
a233 2
	spret = snprintf(strkey, STRLEN, "%s@@%s", path->user, path->domain);
	if (spret == -1 || spret >= STRLEN) {
d243 2
a244 2
		spret = snprintf(strkey, STRLEN, "@@%s", path->domain);
		if (spret == -1 || spret >= STRLEN) {
@


1.3
log
@- snprintf() can return -1, make sure every call is checked properly
@
text
@d1 1
a1 1
/*	$OpenBSD: aliases.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d398 1
a398 1
	if (domain == line || domain == line + len)
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 1
d173 2
a174 2
	if (snprintf(strkey, STRLEN, "%s@@%s", path->user, path->domain)
	    >= STRLEN) {
d184 2
a185 2
		if (snprintf(strkey, STRLEN, "@@%s", path->domain)
		    >= STRLEN) {
d217 1
d232 2
a233 2
	if (snprintf(strkey, STRLEN, "%s@@%s", path->user, path->domain)
	    >= STRLEN) {
d243 2
a244 2
		if (snprintf(strkey, STRLEN, "@@%s", path->domain)
		    >= STRLEN) {
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

