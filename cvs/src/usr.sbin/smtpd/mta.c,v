head	1.205;
access;
symbols
	OPENBSD_6_2_BASE:1.205
	OPENBSD_6_1:1.203.0.4
	OPENBSD_6_1_BASE:1.203
	OPENBSD_6_0:1.201.0.4
	OPENBSD_6_0_BASE:1.201
	OPENBSD_5_9:1.200.0.2
	OPENBSD_5_9_BASE:1.200
	OPENBSD_5_8:1.191.0.6
	OPENBSD_5_8_BASE:1.191
	OPENBSD_5_7:1.191.0.2
	OPENBSD_5_7_BASE:1.191
	OPENBSD_5_6:1.189.0.4
	OPENBSD_5_6_BASE:1.189
	OPENBSD_5_5:1.183.0.2
	OPENBSD_5_5_BASE:1.183
	OPENBSD_5_4:1.163.0.2
	OPENBSD_5_4_BASE:1.163
	OPENBSD_5_3:1.155.0.2
	OPENBSD_5_3_BASE:1.155
	OPENBSD_5_2:1.132.0.2
	OPENBSD_5_2_BASE:1.132
	OPENBSD_5_1_BASE:1.127
	OPENBSD_5_1:1.127.0.2
	OPENBSD_5_0:1.110.0.2
	OPENBSD_5_0_BASE:1.110
	OPENBSD_4_9:1.97.0.2
	OPENBSD_4_9_BASE:1.97
	OPENBSD_4_8:1.92.0.2
	OPENBSD_4_8_BASE:1.92
	OPENBSD_4_7:1.84.0.2
	OPENBSD_4_7_BASE:1.84
	OPENBSD_4_6:1.61.0.4
	OPENBSD_4_6_BASE:1.61
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31;
locks; strict;
comment	@ * @;


1.205
date	2017.09.15.11.50.39;	author eric;	state Exp;
branches;
next	1.204;
commitid	BnRVMRfcGObhquMr;

1.204
date	2017.09.11.17.09.09;	author eric;	state Exp;
branches;
next	1.203;
commitid	6x9hO6s4L47eNtSS;

1.203
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.202;
commitid	jM4eOMW1AJwdfKrr;

1.202
date	2016.09.03.22.59.06;	author giovanni;	state Exp;
branches;
next	1.201;
commitid	s881VySc776wR5bJ;

1.201
date	2016.05.22.16.31.21;	author gilles;	state Exp;
branches;
next	1.200;
commitid	JDbBqpKvf906qrdL;

1.200
date	2016.01.14.18.56.55;	author mmcc;	state Exp;
branches;
next	1.199;
commitid	Sb9tWbrr36GklQjW;

1.199
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.198;
commitid	ZxnqOQqX6IeYI9jW;

1.198
date	2015.12.14.10.22.12;	author jung;	state Exp;
branches;
next	1.197;
commitid	HRAnniyhGW9Sadln;

1.197
date	2015.12.12.20.02.31;	author gilles;	state Exp;
branches;
next	1.196;
commitid	eO2zB2XyKCWqQLmz;

1.196
date	2015.12.01.10.48.21;	author gilles;	state Exp;
branches;
next	1.195;
commitid	cb5ESr7WeLBKj0Dd;

1.195
date	2015.12.01.10.41.35;	author gilles;	state Exp;
branches;
next	1.194;
commitid	LkbxAqNnRUX5fRyA;

1.194
date	2015.11.30.12.49.35;	author gilles;	state Exp;
branches;
next	1.193;
commitid	ZyOzw2IPUjoaWKi5;

1.193
date	2015.11.26.08.51.22;	author tim;	state Exp;
branches;
next	1.192;
commitid	bNJ4uSE6mjjCRr9j;

1.192
date	2015.10.14.22.01.43;	author gilles;	state Exp;
branches;
next	1.191;
commitid	XSq2zfqNj1sXRZRl;

1.191
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.190;
commitid	ZBTFreARDSMmzOIV;

1.190
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.189;
commitid	Uu5nFG3wCl0LACBb;

1.189
date	2014.07.08.13.02.42;	author eric;	state Exp;
branches;
next	1.188;
commitid	PxJ2XYrjWjOntaXV;

1.188
date	2014.07.08.07.59.31;	author sobrado;	state Exp;
branches;
next	1.187;
commitid	QejPnWBk7nSpcYUN;

1.187
date	2014.05.20.18.47.01;	author eric;	state Exp;
branches;
next	1.186;

1.186
date	2014.04.19.13.32.07;	author gilles;	state Exp;
branches;
next	1.185;

1.185
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.184;

1.184
date	2014.03.08.15.47.52;	author eric;	state Exp;
branches;
next	1.183;

1.183
date	2014.02.20.17.42.29;	author eric;	state Exp;
branches;
next	1.182;

1.182
date	2014.02.04.15.44.05;	author eric;	state Exp;
branches;
next	1.181;

1.181
date	2014.02.04.15.22.39;	author eric;	state Exp;
branches;
next	1.180;

1.180
date	2014.02.04.14.56.03;	author eric;	state Exp;
branches;
next	1.179;

1.179
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.178;

1.178
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.177;

1.177
date	2013.12.06.14.12.34;	author eric;	state Exp;
branches;
next	1.176;

1.176
date	2013.12.05.09.26.47;	author eric;	state Exp;
branches;
next	1.175;

1.175
date	2013.12.03.09.06.26;	author eric;	state Exp;
branches;
next	1.174;

1.174
date	2013.11.30.10.21.16;	author eric;	state Exp;
branches;
next	1.173;

1.173
date	2013.11.29.00.47.04;	author tedu;	state Exp;
branches;
next	1.172;

1.172
date	2013.11.28.13.13.56;	author eric;	state Exp;
branches;
next	1.171;

1.171
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.170;

1.170
date	2013.10.30.21.37.48;	author eric;	state Exp;
branches;
next	1.169;

1.169
date	2013.10.29.17.04.45;	author eric;	state Exp;
branches;
next	1.168;

1.168
date	2013.10.29.11.23.58;	author eric;	state Exp;
branches;
next	1.167;

1.167
date	2013.10.28.09.40.07;	author eric;	state Exp;
branches;
next	1.166;

1.166
date	2013.10.27.17.47.53;	author eric;	state Exp;
branches;
next	1.165;

1.165
date	2013.10.27.07.56.25;	author eric;	state Exp;
branches;
next	1.164;

1.164
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.163;

1.163
date	2013.07.19.21.14.52;	author eric;	state Exp;
branches;
next	1.162;

1.162
date	2013.07.19.15.14.23;	author eric;	state Exp;
branches;
next	1.161;

1.161
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.160;

1.160
date	2013.07.19.07.49.08;	author eric;	state Exp;
branches;
next	1.159;

1.159
date	2013.06.04.08.16.10;	author eric;	state Exp;
branches;
next	1.158;

1.158
date	2013.06.03.16.04.03;	author eric;	state Exp;
branches;
next	1.157;

1.157
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.156;

1.156
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.155;

1.155
date	2013.02.18.13.37.14;	author eric;	state Exp;
branches;
next	1.154;

1.154
date	2013.02.08.13.29.09;	author eric;	state Exp;
branches;
next	1.153;

1.153
date	2013.02.05.11.45.18;	author gilles;	state Exp;
branches;
next	1.152;

1.152
date	2013.02.05.10.53.57;	author nicm;	state Exp;
branches;
next	1.151;

1.151
date	2013.01.28.16.40.22;	author eric;	state Exp;
branches;
next	1.150;

1.150
date	2013.01.28.11.09.53;	author gilles;	state Exp;
branches;
next	1.149;

1.149
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.148;

1.148
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.147;

1.147
date	2012.10.11.21.52.59;	author gilles;	state Exp;
branches;
next	1.146;

1.146
date	2012.10.10.17.57.05;	author eric;	state Exp;
branches;
next	1.145;

1.145
date	2012.10.07.14.55.48;	author gilles;	state Exp;
branches;
next	1.144;

1.144
date	2012.09.28.14.03.00;	author chl;	state Exp;
branches;
next	1.143;

1.143
date	2012.09.21.12.33.32;	author eric;	state Exp;
branches;
next	1.142;

1.142
date	2012.09.18.14.23.01;	author eric;	state Exp;
branches;
next	1.141;

1.141
date	2012.09.16.16.43.28;	author chl;	state Exp;
branches;
next	1.140;

1.140
date	2012.08.30.18.16.25;	author eric;	state Exp;
branches;
next	1.139;

1.139
date	2012.08.29.16.26.17;	author gilles;	state Exp;
branches;
next	1.138;

1.138
date	2012.08.25.10.23.12;	author gilles;	state Exp;
branches;
next	1.137;

1.137
date	2012.08.22.11.44.34;	author eric;	state Exp;
branches;
next	1.136;

1.136
date	2012.08.21.20.19.46;	author eric;	state Exp;
branches;
next	1.135;

1.135
date	2012.08.21.13.13.17;	author eric;	state Exp;
branches;
next	1.134;

1.134
date	2012.08.18.15.45.12;	author eric;	state Exp;
branches;
next	1.133;

1.133
date	2012.07.29.13.56.24;	author eric;	state Exp;
branches;
next	1.132;

1.132
date	2012.05.11.12.12.02;	author eric;	state Exp;
branches;
next	1.131;

1.131
date	2012.05.11.08.15.30;	author eric;	state Exp;
branches;
next	1.130;

1.130
date	2012.03.30.16.48.30;	author chl;	state Exp;
branches;
next	1.129;

1.129
date	2012.03.27.12.53.33;	author eric;	state Exp;
branches;
next	1.128;

1.128
date	2012.03.25.08.44.24;	author eric;	state Exp;
branches;
next	1.127;

1.127
date	2012.02.01.20.30.40;	author eric;	state Exp;
branches;
next	1.126;

1.126
date	2012.01.29.11.37.32;	author eric;	state Exp;
branches;
next	1.125;

1.125
date	2012.01.28.11.33.06;	author gilles;	state Exp;
branches;
next	1.124;

1.124
date	2012.01.26.12.31.53;	author eric;	state Exp;
branches;
next	1.123;

1.123
date	2012.01.13.14.01.57;	author eric;	state Exp;
branches;
next	1.122;

1.122
date	2012.01.11.22.12.07;	author eric;	state Exp;
branches;
next	1.121;

1.121
date	2011.12.18.18.43.30;	author eric;	state Exp;
branches;
next	1.120;

1.120
date	2011.12.11.17.02.10;	author eric;	state Exp;
branches;
next	1.119;

1.119
date	2011.11.14.19.23.41;	author chl;	state Exp;
branches;
next	1.118;

1.118
date	2011.10.27.14.32.57;	author chl;	state Exp;
branches;
next	1.117;

1.117
date	2011.10.23.17.09.56;	author eric;	state Exp;
branches;
next	1.116;

1.116
date	2011.10.23.15.36.53;	author eric;	state Exp;
branches;
next	1.115;

1.115
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.114;

1.114
date	2011.10.09.18.39.53;	author eric;	state Exp;
branches;
next	1.113;

1.113
date	2011.08.29.21.43.09;	author chl;	state Exp;
branches;
next	1.112;

1.112
date	2011.08.29.18.49.29;	author chl;	state Exp;
branches;
next	1.111;

1.111
date	2011.08.26.14.39.47;	author chl;	state Exp;
branches;
next	1.110;

1.110
date	2011.07.20.10.22.54;	author eric;	state Exp;
branches;
next	1.109;

1.109
date	2011.07.19.13.15.54;	author eric;	state Exp;
branches;
next	1.108;

1.108
date	2011.07.06.20.56.16;	author gilles;	state Exp;
branches;
next	1.107;

1.107
date	2011.05.21.18.39.03;	author gilles;	state Exp;
branches;
next	1.106;

1.106
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.105;

1.105
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.104;

1.104
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.103;

1.103
date	2011.04.17.11.39.22;	author gilles;	state Exp;
branches;
next	1.102;

1.102
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.101;

1.101
date	2011.04.13.20.53.18;	author gilles;	state Exp;
branches;
next	1.100;

1.100
date	2011.03.26.17.43.01;	author gilles;	state Exp;
branches;
next	1.99;

1.99
date	2011.03.26.10.59.59;	author gilles;	state Exp;
branches;
next	1.98;

1.98
date	2011.03.21.13.02.52;	author gilles;	state Exp;
branches;
next	1.97;

1.97
date	2010.11.29.15.25.55;	author gilles;	state Exp;
branches;
next	1.96;

1.96
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.95;

1.95
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.94;

1.94
date	2010.10.29.09.16.07;	author gilles;	state Exp;
branches;
next	1.93;

1.93
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.92;

1.92
date	2010.06.02.19.16.53;	author chl;	state Exp;
branches;
next	1.91;

1.91
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.90;

1.90
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.89;

1.89
date	2010.06.01.11.05.12;	author jacekm;	state Exp;
branches;
next	1.88;

1.88
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.87;

1.87
date	2010.04.21.18.54.43;	author jacekm;	state Exp;
branches;
next	1.86;

1.86
date	2010.04.21.08.29.01;	author jacekm;	state Exp;
branches;
next	1.85;

1.85
date	2010.04.20.15.34.56;	author jacekm;	state Exp;
branches;
next	1.84;

1.84
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.83;

1.83
date	2009.12.23.17.16.03;	author jacekm;	state Exp;
branches;
next	1.82;

1.82
date	2009.12.14.16.44.14;	author jacekm;	state Exp;
branches;
next	1.81;

1.81
date	2009.12.12.14.03.59;	author jacekm;	state Exp;
branches;
next	1.80;

1.80
date	2009.12.12.10.33.11;	author jacekm;	state Exp;
branches;
next	1.79;

1.79
date	2009.12.10.15.02.30;	author jacekm;	state Exp;
branches;
next	1.78;

1.78
date	2009.12.07.15.33.42;	author jsing;	state Exp;
branches;
next	1.77;

1.77
date	2009.11.16.09.40.43;	author jacekm;	state Exp;
branches;
next	1.76;

1.76
date	2009.11.13.11.27.52;	author jacekm;	state Exp;
branches;
next	1.75;

1.75
date	2009.11.11.10.04.05;	author chl;	state Exp;
branches;
next	1.74;

1.74
date	2009.11.05.12.11.53;	author jsing;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.05.12.05.47;	author jsing;	state Exp;
branches;
next	1.72;

1.72
date	2009.09.15.16.50.06;	author jacekm;	state Exp;
branches;
next	1.71;

1.71
date	2009.09.08.09.50.51;	author landry;	state Exp;
branches;
next	1.70;

1.70
date	2009.09.03.08.19.13;	author jacekm;	state Exp;
branches;
next	1.69;

1.69
date	2009.08.26.16.40.19;	author jacekm;	state Exp;
branches;
next	1.68;

1.68
date	2009.08.26.09.12.41;	author jacekm;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.08.23.02.43;	author gilles;	state Exp;
branches;
next	1.66;

1.66
date	2009.08.07.21.47.07;	author gilles;	state Exp;
branches;
next	1.65;

1.65
date	2009.08.06.19.05.30;	author gilles;	state Exp;
branches;
next	1.64;

1.64
date	2009.08.06.16.29.35;	author gilles;	state Exp;
branches;
next	1.63;

1.63
date	2009.08.06.14.12.48;	author gilles;	state Exp;
branches;
next	1.62;

1.62
date	2009.08.06.13.40.45;	author gilles;	state Exp;
branches;
next	1.61;

1.61
date	2009.06.20.07.46.13;	author jacekm;	state Exp;
branches;
next	1.60;

1.60
date	2009.06.07.05.56.25;	author eric;	state Exp;
branches;
next	1.59;

1.59
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.03.22.04.15;	author jacekm;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.02.22.23.35;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.01.13.20.56;	author jacekm;	state Exp;
branches;
next	1.54;

1.54
date	2009.05.31.18.34.48;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2009.05.30.23.53.41;	author gilles;	state Exp;
branches;
next	1.52;

1.52
date	2009.05.30.16.32.59;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2009.05.30.16.30.33;	author gilles;	state Exp;
branches;
next	1.50;

1.50
date	2009.05.27.13.14.18;	author jacekm;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.24.14.38.56;	author jacekm;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.19.11.24.24;	author jacekm;	state Exp;
branches;
next	1.47;

1.47
date	2009.05.14.15.05.12;	author eric;	state Exp;
branches;
next	1.46;

1.46
date	2009.05.13.21.29.16;	author jacekm;	state Exp;
branches;
next	1.45;

1.45
date	2009.05.09.17.04.55;	author jacekm;	state Exp;
branches;
next	1.44;

1.44
date	2009.04.28.21.56.36;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2009.04.28.21.27.25;	author jacekm;	state Exp;
branches;
next	1.42;

1.42
date	2009.04.21.14.37.32;	author eric;	state Exp;
branches;
next	1.41;

1.41
date	2009.04.15.20.02.12;	author jacekm;	state Exp;
branches;
next	1.40;

1.40
date	2009.04.09.19.49.34;	author jacekm;	state Exp;
branches;
next	1.39;

1.39
date	2009.03.29.14.18.20;	author jacekm;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.19.00.12.32;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.18.23.51.34;	author gilles;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.18.00.07.41;	author gilles;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.15.19.15.25;	author gilles;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.12.11.08.26;	author pea;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.10.22.33.26;	author jacekm;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.09.01.43.19;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2009.02.22.19.07.33;	author chl;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.22.11.59.12;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.20.15.27.01;	author pea;	state Exp;
branches;
next	1.27;

1.27
date	2009.02.15.10.32.23;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2009.01.29.15.40.34;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.29.15.20.34;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.29.14.50.27;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.29.14.25.55;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.29.13.00.12;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.28.23.46.03;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.28.23.38.49;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.28.23.13.42;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.28.22.54.10;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.28.22.27.56;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.28.21.44.15;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.28.13.29.40;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.28.11.27.57;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.12.19.56.27;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.13.23.19.34;	author jacekm;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.06.02.43.58;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.05.19.09.59;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.05.02.51.32;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.25.20.26.40;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.24.22.30.19;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.11.02.14.58;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.10.22.35.23;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.10.02.34.50;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.205
log
@move the envelope handling code to its own function to clarify the
imsg dispatch function.

ok gilles@@
@
text
@/*	$OpenBSD: mta.c,v 1.204 2017/09/11 17:09:09 eric Exp $	*/

/*
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <inttypes.h>
#include <netdb.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

#define MAXERROR_PER_ROUTE	4

#define DELAY_CHECK_SOURCE	1
#define DELAY_CHECK_SOURCE_SLOW	10
#define DELAY_CHECK_SOURCE_FAST 0
#define DELAY_CHECK_LIMIT	5

#define	DELAY_QUADRATIC		1
#define DELAY_ROUTE_BASE	15
#define DELAY_ROUTE_MAX		3600

#define RELAY_ONHOLD		0x01
#define RELAY_HOLDQ		0x02

static void mta_handle_envelope(struct envelope *);
static void mta_query_mx(struct mta_relay *);
static void mta_query_secret(struct mta_relay *);
static void mta_query_preference(struct mta_relay *);
static void mta_query_source(struct mta_relay *);
static void mta_on_mx(void *, void *, void *);
static void mta_on_secret(struct mta_relay *, const char *);
static void mta_on_preference(struct mta_relay *, int);
static void mta_on_source(struct mta_relay *, struct mta_source *);
static void mta_on_timeout(struct runq *, void *);
static void mta_connect(struct mta_connector *);
static void mta_route_enable(struct mta_route *);
static void mta_route_disable(struct mta_route *, int, int);
static void mta_drain(struct mta_relay *);
static void mta_delivery_flush_event(int, short, void *);
static void mta_flush(struct mta_relay *, int, const char *);
static struct mta_route *mta_find_route(struct mta_connector *, time_t, int*,
    time_t*);
static void mta_log(const struct mta_envelope *, const char *, const char *,
    const char *, const char *);

SPLAY_HEAD(mta_relay_tree, mta_relay);
static struct mta_relay *mta_relay(struct envelope *);
static void mta_relay_ref(struct mta_relay *);
static void mta_relay_unref(struct mta_relay *);
static void mta_relay_show(struct mta_relay *, struct mproc *, uint32_t, time_t);
static int mta_relay_cmp(const struct mta_relay *, const struct mta_relay *);
SPLAY_PROTOTYPE(mta_relay_tree, mta_relay, entry, mta_relay_cmp);

SPLAY_HEAD(mta_host_tree, mta_host);
static struct mta_host *mta_host(const struct sockaddr *);
static void mta_host_ref(struct mta_host *);
static void mta_host_unref(struct mta_host *);
static int mta_host_cmp(const struct mta_host *, const struct mta_host *);
SPLAY_PROTOTYPE(mta_host_tree, mta_host, entry, mta_host_cmp);

SPLAY_HEAD(mta_domain_tree, mta_domain);
static struct mta_domain *mta_domain(char *, int);
#if 0
static void mta_domain_ref(struct mta_domain *);
#endif
static void mta_domain_unref(struct mta_domain *);
static int mta_domain_cmp(const struct mta_domain *, const struct mta_domain *);
SPLAY_PROTOTYPE(mta_domain_tree, mta_domain, entry, mta_domain_cmp);

SPLAY_HEAD(mta_source_tree, mta_source);
static struct mta_source *mta_source(const struct sockaddr *);
static void mta_source_ref(struct mta_source *);
static void mta_source_unref(struct mta_source *);
static const char *mta_source_to_text(struct mta_source *);
static int mta_source_cmp(const struct mta_source *, const struct mta_source *);
SPLAY_PROTOTYPE(mta_source_tree, mta_source, entry, mta_source_cmp);

static struct mta_connector *mta_connector(struct mta_relay *,
    struct mta_source *);
static void mta_connector_free(struct mta_connector *);
static const char *mta_connector_to_text(struct mta_connector *);

SPLAY_HEAD(mta_route_tree, mta_route);
static struct mta_route *mta_route(struct mta_source *, struct mta_host *);
static void mta_route_ref(struct mta_route *);
static void mta_route_unref(struct mta_route *);
static const char *mta_route_to_text(struct mta_route *);
static int mta_route_cmp(const struct mta_route *, const struct mta_route *);
SPLAY_PROTOTYPE(mta_route_tree, mta_route, entry, mta_route_cmp);

struct mta_block {
	SPLAY_ENTRY(mta_block)	 entry;
	struct mta_source	*source;
	char			*domain;
};

SPLAY_HEAD(mta_block_tree, mta_block);
void mta_block(struct mta_source *, char *);
void mta_unblock(struct mta_source *, char *);
int mta_is_blocked(struct mta_source *, char *);
static int mta_block_cmp(const struct mta_block *, const struct mta_block *);
SPLAY_PROTOTYPE(mta_block_tree, mta_block, entry, mta_block_cmp);

static struct mta_relay_tree		relays;
static struct mta_domain_tree		domains;
static struct mta_host_tree		hosts;
static struct mta_source_tree		sources;
static struct mta_route_tree		routes;
static struct mta_block_tree		blocks;

static struct tree wait_mx;
static struct tree wait_preference;
static struct tree wait_secret;
static struct tree wait_source;
static struct tree flush_evp;
static struct event ev_flush_evp;

static struct runq *runq_relay;
static struct runq *runq_connector;
static struct runq *runq_route;
static struct runq *runq_hoststat;

static time_t	max_seen_conndelay_route;
static time_t	max_seen_discdelay_route;

#define	HOSTSTAT_EXPIRE_DELAY	(4 * 3600)
struct hoststat {
	char			 name[HOST_NAME_MAX+1];
	time_t			 tm;
	char			 error[LINE_MAX];
	struct tree		 deferred;
};
static struct dict hoststat;

void mta_hoststat_update(const char *, const char *);
void mta_hoststat_cache(const char *, uint64_t);
void mta_hoststat_uncache(const char *, uint64_t);
void mta_hoststat_reschedule(const char *);
static void mta_hoststat_remove_entry(struct hoststat *);


void
mta_imsg(struct mproc *p, struct imsg *imsg)
{
	struct mta_relay	*relay;
	struct mta_domain	*domain;
	struct mta_host		*host;
	struct mta_route	*route;
	struct mta_block	*block;
	struct mta_mx		*mx, *imx;
	struct mta_source	*source;
	struct hoststat		*hs;
	struct sockaddr_storage	 ss;
	struct envelope		 evp;
	struct msg		 m;
	const char		*secret;
	const char		*hostname;
	const char		*dom;
	uint64_t		 reqid;
	time_t			 t;
	char			 buf[LINE_MAX];
	int			 dnserror, preference, v, status;
	void			*iter;
	uint64_t		 u64;

	if (p->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {

		case IMSG_QUEUE_TRANSFER:
			m_msg(&m, imsg);
			m_get_envelope(&m, &evp);
			m_end(&m);
			mta_handle_envelope(&evp);
			return;

		case IMSG_MTA_OPEN_MESSAGE:
			mta_session_imsg(p, imsg);
			return;
		}
	}

	if (p->proc == PROC_LKA) {
		switch (imsg->hdr.type) {

		case IMSG_MTA_LOOKUP_CREDENTIALS:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &secret);
			m_end(&m);
			relay = tree_xpop(&wait_secret, reqid);
			mta_on_secret(relay, secret[0] ? secret : NULL);
			return;

		case IMSG_MTA_LOOKUP_SOURCE:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_int(&m, &status);
			if (status == LKA_OK)
				m_get_sockaddr(&m, (struct sockaddr*)&ss);
			m_end(&m);

			relay = tree_xpop(&wait_source, reqid);
			mta_on_source(relay, (status == LKA_OK) ?
			    mta_source((struct sockaddr *)&ss) : NULL);
			return;

		case IMSG_MTA_LOOKUP_HELO:
			mta_session_imsg(p, imsg);
			return;

		case IMSG_MTA_DNS_HOST:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_sockaddr(&m, (struct sockaddr*)&ss);
			m_get_int(&m, &preference);
			m_end(&m);
			domain = tree_xget(&wait_mx, reqid);
			mx = xcalloc(1, sizeof *mx, "mta: mx");
			mx->host = mta_host((struct sockaddr*)&ss);
			mx->preference = preference;
			TAILQ_FOREACH(imx, &domain->mxs, entry) {
				if (imx->preference > mx->preference) {
					TAILQ_INSERT_BEFORE(imx, mx, entry);
					return;
				}
			}
			TAILQ_INSERT_TAIL(&domain->mxs, mx, entry);
			return;

		case IMSG_MTA_DNS_HOST_END:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_int(&m, &dnserror);
			m_end(&m);
			domain = tree_xpop(&wait_mx, reqid);
			domain->mxstatus = dnserror;
			if (domain->mxstatus == DNS_OK) {
				log_debug("debug: MXs for domain %s:",
				    domain->name);
				TAILQ_FOREACH(mx, &domain->mxs, entry)
					log_debug("	%s preference %d",
					    sa_to_text(mx->host->sa),
					    mx->preference);
			}
			else {
				log_debug("debug: Failed MX query for %s:",
				    domain->name);
			}
			domain->lastmxquery = time(NULL);
			waitq_run(&domain->mxs, domain);
			return;

		case IMSG_MTA_DNS_MX_PREFERENCE:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_int(&m, &dnserror);
			if (dnserror == 0)
				m_get_int(&m, &preference);
			m_end(&m);

			relay = tree_xpop(&wait_preference, reqid);
			if (dnserror) {
				log_warnx("warn: Couldn't find backup "
				    "preference for %s: error %d",
				    mta_relay_to_text(relay), dnserror);
				preference = INT_MAX;
			}
			mta_on_preference(relay, preference);
			return;

		case IMSG_MTA_DNS_PTR:
			mta_session_imsg(p, imsg);
			return;

		case IMSG_MTA_TLS_INIT:
			mta_session_imsg(p, imsg);
			return;

		case IMSG_MTA_TLS_VERIFY:
			mta_session_imsg(p, imsg);
			return;
		}
	}

	if (p->proc == PROC_CONTROL) {
		switch (imsg->hdr.type) {

		case IMSG_CTL_RESUME_ROUTE:
			u64 = *((uint64_t *)imsg->data);
			if (u64)
				log_debug("resuming route: %llu",
				    (unsigned long long)u64);
			else
				log_debug("resuming all routes");
			SPLAY_FOREACH(route, mta_route_tree, &routes) {
				if (u64 && route->id != u64)
					continue;

				if (route->flags & ROUTE_DISABLED) {
					log_info("smtp-out: Enabling route %s per admin request",
					    mta_route_to_text(route));
					if (!runq_cancel(runq_route, NULL, route)) {
						log_warnx("warn: route not on runq");
						fatalx("exiting");
					}
					route->flags &= ~ROUTE_DISABLED;
					route->flags |= ROUTE_NEW;
					route->nerror = 0;
					route->penalty = 0;
					mta_route_unref(route); /* from mta_route_disable */
				}

				if (u64)
					break;
			}
			return;

		case IMSG_CTL_MTA_SHOW_HOSTS:
			t = time(NULL);
			SPLAY_FOREACH(host, mta_host_tree, &hosts) {
				(void)snprintf(buf, sizeof(buf),
				    "%s %s refcount=%d nconn=%zu lastconn=%s",
				    sockaddr_to_text(host->sa),
				    host->ptrname,
				    host->refcount,
				    host->nconn,
				    host->lastconn ? duration_to_text(t - host->lastconn) : "-");
				m_compose(p, IMSG_CTL_MTA_SHOW_HOSTS,
				    imsg->hdr.peerid, 0, -1,
				    buf, strlen(buf) + 1);
			}
			m_compose(p, IMSG_CTL_MTA_SHOW_HOSTS, imsg->hdr.peerid,
			    0, -1, NULL, 0);
			return;

		case IMSG_CTL_MTA_SHOW_RELAYS:
			t = time(NULL);
			SPLAY_FOREACH(relay, mta_relay_tree, &relays)
				mta_relay_show(relay, p, imsg->hdr.peerid, t);
			m_compose(p, IMSG_CTL_MTA_SHOW_RELAYS, imsg->hdr.peerid,
			    0, -1, NULL, 0);
			return;

		case IMSG_CTL_MTA_SHOW_ROUTES:
			SPLAY_FOREACH(route, mta_route_tree, &routes) {
				v = runq_pending(runq_route, NULL, route, &t);
				(void)snprintf(buf, sizeof(buf),
				    "%llu. %s %c%c%c%c nconn=%zu nerror=%d penalty=%d timeout=%s",
				    (unsigned long long)route->id,
				    mta_route_to_text(route),
				    route->flags & ROUTE_NEW ? 'N' : '-',
				    route->flags & ROUTE_DISABLED ? 'D' : '-',
				    route->flags & ROUTE_RUNQ ? 'Q' : '-',
				    route->flags & ROUTE_KEEPALIVE ? 'K' : '-',
				    route->nconn,
				    route->nerror,
				    route->penalty,
				    v ? duration_to_text(t - time(NULL)) : "-");
				m_compose(p, IMSG_CTL_MTA_SHOW_ROUTES,
				    imsg->hdr.peerid, 0, -1,
				    buf, strlen(buf) + 1);
			}
			m_compose(p, IMSG_CTL_MTA_SHOW_ROUTES, imsg->hdr.peerid,
			    0, -1, NULL, 0);
			return;

		case IMSG_CTL_MTA_SHOW_HOSTSTATS:
			iter = NULL;
			while (dict_iter(&hoststat, &iter, &hostname,
				(void **)&hs)) {
				(void)snprintf(buf, sizeof(buf),
				    "%s|%llu|%s",
				    hostname, (unsigned long long) hs->tm,
				    hs->error);
				m_compose(p, IMSG_CTL_MTA_SHOW_HOSTSTATS,
				    imsg->hdr.peerid, 0, -1,
				    buf, strlen(buf) + 1);
			}
			m_compose(p, IMSG_CTL_MTA_SHOW_HOSTSTATS,
			    imsg->hdr.peerid,
			    0, -1, NULL, 0);
			return;

		case IMSG_CTL_MTA_BLOCK:
			m_msg(&m, imsg);
			m_get_sockaddr(&m, (struct sockaddr*)&ss);
			m_get_string(&m, &dom);
			m_end(&m);
			source = mta_source((struct sockaddr*)&ss);
			if (*dom != '\0') {
				if (!(strlcpy(buf, dom, sizeof(buf))
					>= sizeof(buf)))
					mta_block(source, buf);
			}
			else
				mta_block(source, NULL);
			mta_source_unref(source);
			m_compose(p, IMSG_CTL_OK, imsg->hdr.peerid, 0, -1, NULL, 0);
			return;

		case IMSG_CTL_MTA_UNBLOCK:
			m_msg(&m, imsg);
			m_get_sockaddr(&m, (struct sockaddr*)&ss);
			m_get_string(&m, &dom);
			m_end(&m);
			source = mta_source((struct sockaddr*)&ss);
			if (*dom != '\0') {
				if (!(strlcpy(buf, dom, sizeof(buf))
					>= sizeof(buf)))
					mta_unblock(source, buf);
			}
			else
				mta_unblock(source, NULL);
			mta_source_unref(source);
			m_compose(p, IMSG_CTL_OK, imsg->hdr.peerid, 0, -1, NULL, 0);
			return;

		case IMSG_CTL_MTA_SHOW_BLOCK:
			SPLAY_FOREACH(block, mta_block_tree, &blocks) {
				(void)snprintf(buf, sizeof(buf), "%s -> %s",
				    mta_source_to_text(block->source),
				    block->domain ? block->domain : "*");
				m_compose(p, IMSG_CTL_MTA_SHOW_BLOCK,
				    imsg->hdr.peerid, 0, -1, buf, strlen(buf) + 1);
			}
			m_compose(p, IMSG_CTL_MTA_SHOW_BLOCK, imsg->hdr.peerid,
			    0, -1, NULL, 0);
			return;
		}
	}

	errx(1, "mta_imsg: unexpected %s imsg", imsg_to_str(imsg->hdr.type));
}

void
mta_postfork(void)
{
}

void
mta_postprivdrop(void)
{
	SPLAY_INIT(&relays);
	SPLAY_INIT(&domains);
	SPLAY_INIT(&hosts);
	SPLAY_INIT(&sources);
	SPLAY_INIT(&routes);
	SPLAY_INIT(&blocks);

	tree_init(&wait_secret);
	tree_init(&wait_mx);
	tree_init(&wait_preference);
	tree_init(&wait_source);
	tree_init(&flush_evp);
	dict_init(&hoststat);

	evtimer_set(&ev_flush_evp, mta_delivery_flush_event, NULL);

	runq_init(&runq_relay, mta_on_timeout);
	runq_init(&runq_connector, mta_on_timeout);
	runq_init(&runq_route, mta_on_timeout);
	runq_init(&runq_hoststat, mta_on_timeout);
}


/*
 * Local error on the given source.
 */
void
mta_source_error(struct mta_relay *relay, struct mta_route *route, const char *e)
{
	struct mta_connector	*c;

	/*
	 * Remember the source as broken for this connector.
	 */
	c = mta_connector(relay, route->src);
	if (!(c->flags & CONNECTOR_ERROR_SOURCE))
		log_info("smtp-out: Error on %s: %s",
		    mta_route_to_text(route), e);
	c->flags |= CONNECTOR_ERROR_SOURCE;
}

void
mta_route_error(struct mta_relay *relay, struct mta_route *route)
{
#if 0
	route->nerror += 1;

	if (route->nerror > MAXERROR_PER_ROUTE) {
		log_info("smtp-out: Too many errors on %s: "
		    "disabling for a while", mta_route_to_text(route));
		mta_route_disable(route, 2, ROUTE_DISABLED_SMTP);
	}
#endif
}

void
mta_route_ok(struct mta_relay *relay, struct mta_route *route)
{
	struct mta_connector	*c;

	if (!(route->flags & ROUTE_NEW))
		return;

	log_debug("debug: mta-routing: route %s is now valid.",
	    mta_route_to_text(route));

	route->nerror = 0;
	route->flags &= ~ROUTE_NEW;

	c = mta_connector(relay, route->src);
	mta_connect(c);
}

void
mta_route_down(struct mta_relay *relay, struct mta_route *route)
{
#if 0
	mta_route_disable(route, 2, ROUTE_DISABLED_SMTP);
#endif
}

void
mta_route_collect(struct mta_relay *relay, struct mta_route *route)
{
	struct mta_connector	*c;

	log_debug("debug: mta_route_collect(%s)",
	    mta_route_to_text(route));

	relay->nconn -= 1;
	relay->domain->nconn -= 1;
	route->nconn -= 1;
	route->src->nconn -= 1;
	route->dst->nconn -= 1;
	route->lastdisc = time(NULL);

	/* First connection failed */
	if (route->flags & ROUTE_NEW)
		mta_route_disable(route, 1, ROUTE_DISABLED_NET);

	c = mta_connector(relay, route->src);
	c->nconn -= 1;
	mta_connect(c);
	mta_route_unref(route); /* from mta_find_route() */
	mta_relay_unref(relay); /* from mta_connect() */
}

struct mta_task *
mta_route_next_task(struct mta_relay *relay, struct mta_route *route)
{
	struct mta_task	*task;

	if ((task = TAILQ_FIRST(&relay->tasks))) {
		TAILQ_REMOVE(&relay->tasks, task, entry);
		relay->ntask -= 1;
		task->relay = NULL;

		/* When the number of tasks is down to lowat, query some evp */
		if (relay->ntask == (size_t)relay->limits->task_lowat) {
			if (relay->state & RELAY_ONHOLD) {
				log_info("smtp-out: back to lowat on %s: releasing",
				    mta_relay_to_text(relay));
				relay->state &= ~RELAY_ONHOLD;
			}
			if (relay->state & RELAY_HOLDQ) {
				m_create(p_queue, IMSG_MTA_HOLDQ_RELEASE, 0, 0, -1);
				m_add_id(p_queue, relay->id);
				m_add_int(p_queue, relay->limits->task_release);
				m_close(p_queue);
			}
		}
		else if (relay->ntask == 0 && relay->state & RELAY_HOLDQ) {
			m_create(p_queue, IMSG_MTA_HOLDQ_RELEASE, 0, 0, -1);
			m_add_id(p_queue, relay->id);
			m_add_int(p_queue, 0);
			m_close(p_queue);
		}
	}

	return (task);
}

static void
mta_handle_envelope(struct envelope *evp)
{
	struct mta_relay	*relay;
	struct mta_task		*task;
	struct mta_envelope	*e;
	char			 buf[LINE_MAX];

	relay = mta_relay(evp);
	/* ignore if we don't know the limits yet */
	if (relay->limits &&
	    relay->ntask >= (size_t)relay->limits->task_hiwat) {
		if (!(relay->state & RELAY_ONHOLD)) {
			log_info("smtp-out: hiwat reached on %s: holding envelopes",
			    mta_relay_to_text(relay));
			relay->state |= RELAY_ONHOLD;
		}
	}

	/*
	 * If the relay has too many pending tasks, tell the
	 * scheduler to hold it until further notice
	 */
	if (relay->state & RELAY_ONHOLD) {
		relay->state |= RELAY_HOLDQ;
		m_create(p_queue, IMSG_MTA_DELIVERY_HOLD, 0, 0, -1);
		m_add_evpid(p_queue, evp->id);
		m_add_id(p_queue, relay->id);
		m_close(p_queue);
		mta_relay_unref(relay); /* from here */
		return;
	}

	task = NULL;
	TAILQ_FOREACH(task, &relay->tasks, entry)
		if (task->msgid == evpid_to_msgid(evp->id))
			break;

	if (task == NULL) {
		task = xmalloc(sizeof *task, "mta_task");
		TAILQ_INIT(&task->envelopes);
		task->relay = relay;
		relay->ntask += 1;
		TAILQ_INSERT_TAIL(&relay->tasks, task, entry);
		task->msgid = evpid_to_msgid(evp->id);
		if (evp->sender.user[0] || evp->sender.domain[0])
			(void)snprintf(buf, sizeof buf, "%s@@%s",
			    evp->sender.user, evp->sender.domain);
		else
			buf[0] = '\0';
		task->sender = xstrdup(buf, "mta_task:sender");
		stat_increment("mta.task", 1);
	}

	e = xcalloc(1, sizeof *e, "mta_envelope");
	e->id = evp->id;
	e->creation = evp->creation;
	(void)snprintf(buf, sizeof buf, "%s@@%s",
	    evp->dest.user, evp->dest.domain);
	e->dest = xstrdup(buf, "mta_envelope:dest");
	(void)snprintf(buf, sizeof buf, "%s@@%s",
	    evp->rcpt.user, evp->rcpt.domain);
	if (strcmp(buf, e->dest))
		e->rcpt = xstrdup(buf, "mta_envelope:rcpt");
	e->task = task;
	if (evp->dsn_orcpt.user[0] && evp->dsn_orcpt.domain[0]) {
		(void)snprintf(buf, sizeof buf, "%s@@%s",
	    	    evp->dsn_orcpt.user, evp->dsn_orcpt.domain);
		e->dsn_orcpt = xstrdup(buf,
		    "mta_envelope:dsn_orcpt");
	}
	(void)strlcpy(e->dsn_envid, evp->dsn_envid,
	    sizeof e->dsn_envid);
	e->dsn_notify = evp->dsn_notify;
	e->dsn_ret = evp->dsn_ret;

	TAILQ_INSERT_TAIL(&task->envelopes, e, entry);
	log_debug("debug: mta: received evp:%016" PRIx64
	    " for <%s>", e->id, e->dest);

	stat_increment("mta.envelope", 1);

	mta_drain(relay);
	mta_relay_unref(relay); /* from here */
}

static void
mta_delivery_flush_event(int fd, short event, void *arg)
{
	struct mta_envelope	*e;
	struct timeval		 tv;

	if (tree_poproot(&flush_evp, NULL, (void**)(&e))) {

		if (e->delivery == IMSG_MTA_DELIVERY_OK) {
			m_create(p_queue, IMSG_MTA_DELIVERY_OK, 0, 0, -1);
			m_add_evpid(p_queue, e->id);
			m_add_int(p_queue, e->ext);
			m_close(p_queue);
		} else if (e->delivery == IMSG_MTA_DELIVERY_TEMPFAIL) {
			m_create(p_queue, IMSG_MTA_DELIVERY_TEMPFAIL, 0, 0, -1);
			m_add_evpid(p_queue, e->id);
			m_add_string(p_queue, e->status);
			m_add_int(p_queue, ESC_OTHER_STATUS);
			m_close(p_queue);
		}
		else if (e->delivery == IMSG_MTA_DELIVERY_PERMFAIL) {
			m_create(p_queue, IMSG_MTA_DELIVERY_PERMFAIL, 0, 0, -1);
			m_add_evpid(p_queue, e->id);
			m_add_string(p_queue, e->status);
			m_add_int(p_queue, ESC_OTHER_STATUS);
			m_close(p_queue);
		}
		else if (e->delivery == IMSG_MTA_DELIVERY_LOOP) {
			m_create(p_queue, IMSG_MTA_DELIVERY_LOOP, 0, 0, -1);
			m_add_evpid(p_queue, e->id);
			m_close(p_queue);
		}
		else {
			log_warnx("warn: bad delivery type %d for %016" PRIx64,
			    e->delivery, e->id);
			fatalx("aborting");
		}

		log_debug("debug: mta: flush for %016"PRIx64" (-> %s)", e->id, e->dest);

		free(e->dest);
		free(e->rcpt);
		free(e->dsn_orcpt);
		free(e);

		tv.tv_sec = 0;
		tv.tv_usec = 0;
		evtimer_add(&ev_flush_evp, &tv);
	}
}

void
mta_delivery_log(struct mta_envelope *e, const char *source, const char *relay,
    int delivery, const char *status)
{
	if (delivery == IMSG_MTA_DELIVERY_OK)
		mta_log(e, "Ok", source, relay, status);
	else if (delivery == IMSG_MTA_DELIVERY_TEMPFAIL)
		mta_log(e, "TempFail", source, relay, status);
	else if (delivery == IMSG_MTA_DELIVERY_PERMFAIL)
		mta_log(e, "PermFail", source, relay, status);
	else if (delivery == IMSG_MTA_DELIVERY_LOOP)
		mta_log(e, "PermFail", source, relay, "Loop detected");
	else {
		log_warnx("warn: bad delivery type %d for %016" PRIx64,
		    delivery, e->id);
		fatalx("aborting");
	}

	e->delivery = delivery;
	if (status)
		(void)strlcpy(e->status, status, sizeof(e->status));
}

void
mta_delivery_notify(struct mta_envelope *e)
{
	struct timeval	tv;

	tree_xset(&flush_evp, e->id, e);
	if (tree_count(&flush_evp) == 1) {
		tv.tv_sec = 0;
		tv.tv_usec = 0;
		evtimer_add(&ev_flush_evp, &tv);
	}
}

static void
mta_query_mx(struct mta_relay *relay)
{
	uint64_t	id;

	if (relay->status & RELAY_WAIT_MX)
		return;

	log_debug("debug: mta: querying MX for %s...",
	    mta_relay_to_text(relay));

	if (waitq_wait(&relay->domain->mxs, mta_on_mx, relay)) {
		id = generate_uid();
		tree_xset(&wait_mx, id, relay->domain);
		if (relay->domain->flags)
			m_create(p_lka,  IMSG_MTA_DNS_HOST, 0, 0, -1);
		else
			m_create(p_lka,  IMSG_MTA_DNS_MX, 0, 0, -1);
		m_add_id(p_lka, id);
		m_add_string(p_lka, relay->domain->name);
		m_close(p_lka);
	}
	relay->status |= RELAY_WAIT_MX;
	mta_relay_ref(relay);
}

static void
mta_query_limits(struct mta_relay *relay)
{
	if (relay->status & RELAY_WAIT_LIMITS)
		return;

	relay->limits = dict_get(env->sc_limits_dict, relay->domain->name);
	if (relay->limits == NULL)
		relay->limits = dict_get(env->sc_limits_dict, "default");

	if (max_seen_conndelay_route < relay->limits->conndelay_route)
		max_seen_conndelay_route = relay->limits->conndelay_route;
	if (max_seen_discdelay_route < relay->limits->discdelay_route)
		max_seen_discdelay_route = relay->limits->discdelay_route;
}

static void
mta_query_secret(struct mta_relay *relay)
{
	if (relay->status & RELAY_WAIT_SECRET)
		return;

	log_debug("debug: mta: querying secret for %s...",
	    mta_relay_to_text(relay));

	tree_xset(&wait_secret, relay->id, relay);
	relay->status |= RELAY_WAIT_SECRET;

	m_create(p_lka, IMSG_MTA_LOOKUP_CREDENTIALS, 0, 0, -1);
	m_add_id(p_lka, relay->id);
	m_add_string(p_lka, relay->authtable);
	m_add_string(p_lka, relay->authlabel);
	m_close(p_lka);

	mta_relay_ref(relay);
}

static void
mta_query_preference(struct mta_relay *relay)
{
	if (relay->status & RELAY_WAIT_PREFERENCE)
		return;

	log_debug("debug: mta: querying preference for %s...",
	    mta_relay_to_text(relay));

	tree_xset(&wait_preference, relay->id, relay);
	relay->status |= RELAY_WAIT_PREFERENCE;

	m_create(p_lka,  IMSG_MTA_DNS_MX_PREFERENCE, 0, 0, -1);
	m_add_id(p_lka, relay->id);
	m_add_string(p_lka, relay->domain->name);
	m_add_string(p_lka, relay->backupname);
	m_close(p_lka);

	mta_relay_ref(relay);
}

static void
mta_query_source(struct mta_relay *relay)
{
	log_debug("debug: mta: querying source for %s...",
	    mta_relay_to_text(relay));

	relay->sourceloop += 1;

	if (relay->sourcetable == NULL) {
		/*
		 * This is a recursive call, but it only happens once, since
		 * another source will not be queried immediately.
		 */
		mta_relay_ref(relay);
		mta_on_source(relay, mta_source(NULL));
		return;
	}

	m_create(p_lka, IMSG_MTA_LOOKUP_SOURCE, 0, 0, -1);
	m_add_id(p_lka, relay->id);
	m_add_string(p_lka, relay->sourcetable);
	m_close(p_lka);

	tree_xset(&wait_source, relay->id, relay);
	relay->status |= RELAY_WAIT_SOURCE;
	mta_relay_ref(relay);
}

static void
mta_on_mx(void *tag, void *arg, void *data)
{
	struct mta_domain	*domain = data;
	struct mta_relay	*relay = arg;

	log_debug("debug: mta: ... got mx (%p, %s, %s)",
	    tag, domain->name, mta_relay_to_text(relay));

	switch (domain->mxstatus) {
	case DNS_OK:
		break;
	case DNS_RETRY:
		relay->fail = IMSG_MTA_DELIVERY_TEMPFAIL;
		relay->failstr = "Temporary failure in MX lookup";
		break;
	case DNS_EINVAL:
		relay->fail = IMSG_MTA_DELIVERY_PERMFAIL;
		relay->failstr = "Invalid domain name";
		break;
	case DNS_ENONAME:
		relay->fail = IMSG_MTA_DELIVERY_PERMFAIL;
		relay->failstr = "Domain does not exist";
		break;
	case DNS_ENOTFOUND:
		relay->fail = IMSG_MTA_DELIVERY_TEMPFAIL;
		relay->failstr = "No MX found for domain";
		break;
	default:
		fatalx("bad DNS lookup error code");
		break;
	}

	if (domain->mxstatus)
		log_info("smtp-out: Failed to resolve MX for %s: %s",
		    mta_relay_to_text(relay), relay->failstr);

	relay->status &= ~RELAY_WAIT_MX;
	mta_drain(relay);
	mta_relay_unref(relay); /* from mta_drain() */
}

static void
mta_on_secret(struct mta_relay *relay, const char *secret)
{
	log_debug("debug: mta: ... got secret for %s: %s",
	    mta_relay_to_text(relay), secret);

	if (secret)
		relay->secret = strdup(secret);

	if (relay->secret == NULL) {
		log_warnx("warn: Failed to retrieve secret "
			    "for %s", mta_relay_to_text(relay));
		relay->fail = IMSG_MTA_DELIVERY_TEMPFAIL;
		relay->failstr = "Could not retrieve credentials";
	}

	relay->status &= ~RELAY_WAIT_SECRET;
	mta_drain(relay);
	mta_relay_unref(relay); /* from mta_query_secret() */
}

static void
mta_on_preference(struct mta_relay *relay, int preference)
{
	log_debug("debug: mta: ... got preference for %s: %d",
	    mta_relay_to_text(relay), preference);

	relay->backuppref = preference;

	relay->status &= ~RELAY_WAIT_PREFERENCE;
	mta_drain(relay);
	mta_relay_unref(relay); /* from mta_query_preference() */
}

static void
mta_on_source(struct mta_relay *relay, struct mta_source *source)
{
	struct mta_connector	*c;
	void			*iter;
	int			 delay, errmask;

	log_debug("debug: mta: ... got source for %s: %s",
	    mta_relay_to_text(relay), source ? mta_source_to_text(source) : "NULL");

	relay->lastsource = time(NULL);
	delay = DELAY_CHECK_SOURCE_SLOW;

	if (source) {
		c = mta_connector(relay, source);
		if (c->flags & CONNECTOR_NEW) {
			c->flags &= ~CONNECTOR_NEW;
			delay = DELAY_CHECK_SOURCE;
		}
		mta_connect(c);
		if ((c->flags & CONNECTOR_ERROR) == 0)
			relay->sourceloop = 0;
		else
			delay = DELAY_CHECK_SOURCE_FAST;
		mta_source_unref(source); /* from constructor */
	}
	else {
		log_warnx("warn: Failed to get source address for %s",
		    mta_relay_to_text(relay));
	}

	if (tree_count(&relay->connectors) == 0) {
		relay->fail = IMSG_MTA_DELIVERY_TEMPFAIL;
		relay->failstr = "Could not retrieve source address";
	}
	if (tree_count(&relay->connectors) < relay->sourceloop) {
		relay->fail = IMSG_MTA_DELIVERY_TEMPFAIL;
		relay->failstr = "No valid route to remote MX";

		errmask = 0;
		iter = NULL;
		while (tree_iter(&relay->connectors, &iter, NULL, (void **)&c))
			errmask |= c->flags;

		if (errmask & CONNECTOR_ERROR_ROUTE_SMTP)
			relay->failstr = "Destination seem to reject all mails";
		else if (errmask & CONNECTOR_ERROR_ROUTE_NET)
			relay->failstr = "Network error on destination MXs";
		else if (errmask & CONNECTOR_ERROR_MX)
			relay->failstr = "No MX found for destination";
		else if (errmask & CONNECTOR_ERROR_FAMILY)
			relay->failstr = "Address family mismatch on destination MXs";
		else if (errmask & CONNECTOR_ERROR_BLOCKED)
			relay->failstr = "All routes to destination blocked";
		else
			relay->failstr = "No valid route to destination";
	}

	relay->nextsource = relay->lastsource + delay;
	relay->status &= ~RELAY_WAIT_SOURCE;
	mta_drain(relay);
	mta_relay_unref(relay); /* from mta_query_source() */
}

static void
mta_connect(struct mta_connector *c)
{
	struct mta_route	*route;
	struct mta_limits	*l = c->relay->limits;
	int			 limits;
	time_t			 nextconn, now;

	/* toggle the block flag */
	if (mta_is_blocked(c->source, c->relay->domain->name))
		c->flags |= CONNECTOR_ERROR_BLOCKED;
	else
		c->flags &= ~CONNECTOR_ERROR_BLOCKED;

    again:

	log_debug("debug: mta: connecting with %s", mta_connector_to_text(c));

	/* Do not connect if this connector has an error. */
	if (c->flags & CONNECTOR_ERROR) {
		log_debug("debug: mta: connector error");
		return;
	}

	if (c->flags & CONNECTOR_WAIT) {
		log_debug("debug: mta: cancelling connector timeout");
		runq_cancel(runq_connector, NULL, c);
		c->flags &= ~CONNECTOR_WAIT;
	}

	/* No job. */
	if (c->relay->ntask == 0) {
		log_debug("debug: mta: no task for connector");
		return;
	}

	/* Do not create more connections than necessary */
	if ((c->relay->nconn_ready >= c->relay->ntask) ||
	    (c->relay->nconn > 2 && c->relay->nconn >= c->relay->ntask / 2)) {
		log_debug("debug: mta: enough connections already");
		return;
	}

	limits = 0;
	nextconn = now = time(NULL);

	if (c->relay->domain->lastconn + l->conndelay_domain > nextconn) {
		log_debug("debug: mta: cannot use domain %s before %llus",
		    c->relay->domain->name,
		    (unsigned long long) c->relay->domain->lastconn + l->conndelay_domain - now);
		nextconn = c->relay->domain->lastconn + l->conndelay_domain;
	}
	if (c->relay->domain->nconn >= l->maxconn_per_domain) {
		log_debug("debug: mta: hit domain limit");
		limits |= CONNECTOR_LIMIT_DOMAIN;
	}

	if (c->source->lastconn + l->conndelay_source > nextconn) {
		log_debug("debug: mta: cannot use source %s before %llus",
		    mta_source_to_text(c->source),
		    (unsigned long long) c->source->lastconn + l->conndelay_source - now);
		nextconn = c->source->lastconn + l->conndelay_source;
	}
	if (c->source->nconn >= l->maxconn_per_source) {
		log_debug("debug: mta: hit source limit");
		limits |= CONNECTOR_LIMIT_SOURCE;
	}

	if (c->lastconn + l->conndelay_connector > nextconn) {
		log_debug("debug: mta: cannot use %s before %llus",
		    mta_connector_to_text(c),
		    (unsigned long long) c->lastconn + l->conndelay_connector - now);
		nextconn = c->lastconn + l->conndelay_connector;
	}
	if (c->nconn >= l->maxconn_per_connector) {
		log_debug("debug: mta: hit connector limit");
		limits |= CONNECTOR_LIMIT_CONN;
	}

	if (c->relay->lastconn + l->conndelay_relay > nextconn) {
		log_debug("debug: mta: cannot use %s before %llus",
		    mta_relay_to_text(c->relay),
		    (unsigned long long) c->relay->lastconn + l->conndelay_relay - now);
		nextconn = c->relay->lastconn + l->conndelay_relay;
	}
	if (c->relay->nconn >= l->maxconn_per_relay) {
		log_debug("debug: mta: hit relay limit");
		limits |= CONNECTOR_LIMIT_RELAY;
	}

	/* We can connect now, find a route */
	if (!limits && nextconn <= now)
		route = mta_find_route(c, now, &limits, &nextconn);
	else
		route = NULL;

	/* No route */
	if (route == NULL) {

		if (c->flags & CONNECTOR_ERROR) {
			/* XXX we might want to clear this flag later */
			log_debug("debug: mta-routing: no route available for %s: errors on connector",
			    mta_connector_to_text(c));
			return;
		}
		else if (limits) {
			log_debug("debug: mta-routing: no route available for %s: limits reached",
			    mta_connector_to_text(c));
			nextconn = now + DELAY_CHECK_LIMIT;
		}
		else {
			log_debug("debug: mta-routing: no route available for %s: must wait a bit",
			    mta_connector_to_text(c));
		}
		log_debug("debug: mta: retrying to connect on %s in %llus...",
		    mta_connector_to_text(c),
		    (unsigned long long) nextconn - time(NULL));
		c->flags |= CONNECTOR_WAIT;
		runq_schedule(runq_connector, nextconn, NULL, c);
		return;
	}

	log_debug("debug: mta-routing: spawning new connection on %s",
		    mta_route_to_text(route));

	c->nconn += 1;
	c->lastconn = time(NULL);

	c->relay->nconn += 1;
	c->relay->lastconn = c->lastconn;
	c->relay->domain->nconn += 1;
	c->relay->domain->lastconn = c->lastconn;
	route->nconn += 1;
	route->lastconn = c->lastconn;
	route->src->nconn += 1;
	route->src->lastconn = c->lastconn;
	route->dst->nconn += 1;
	route->dst->lastconn = c->lastconn;

	mta_session(c->relay, route);	/* this never fails synchronously */
	mta_relay_ref(c->relay);

    goto again;
}

static void
mta_on_timeout(struct runq *runq, void *arg)
{
	struct mta_connector	*connector = arg;
	struct mta_relay	*relay = arg;
	struct mta_route	*route = arg;
	struct hoststat		*hs = arg;

	if (runq == runq_relay) {
		log_debug("debug: mta: ... timeout for %s",
		    mta_relay_to_text(relay));
		relay->status &= ~RELAY_WAIT_CONNECTOR;
		mta_drain(relay);
		mta_relay_unref(relay); /* from mta_drain() */
	}
	else if (runq == runq_connector) {
		log_debug("debug: mta: ... timeout for %s",
		    mta_connector_to_text(connector));
		connector->flags &= ~CONNECTOR_WAIT;
		mta_connect(connector);
	}
	else if (runq == runq_route) {
		route->flags &= ~ROUTE_RUNQ;
		mta_route_enable(route);
		mta_route_unref(route);
	}
	else if (runq == runq_hoststat) {
		log_debug("debug: mta: ... timeout for hoststat %s",
			hs->name);
		mta_hoststat_remove_entry(hs);
		free(hs);
	}
}

static void
mta_route_disable(struct mta_route *route, int penalty, int reason)
{
	unsigned long long	delay;

	route->penalty += penalty;
	route->lastpenalty = time(NULL);
	delay = (unsigned long long)DELAY_ROUTE_BASE * route->penalty * route->penalty;
	if (delay > DELAY_ROUTE_MAX)
		delay = DELAY_ROUTE_MAX;
#if 0
	delay = 60;
#endif

	log_info("smtp-out: Disabling route %s for %llus",
	    mta_route_to_text(route), delay);

	if (route->flags & ROUTE_DISABLED)
		runq_cancel(runq_route, NULL, route);
	else
		mta_route_ref(route);

	route->flags |= reason & ROUTE_DISABLED;
	runq_schedule(runq_route, time(NULL) + delay, NULL, route);
}

static void
mta_route_enable(struct mta_route *route)
{
	if (route->flags & ROUTE_DISABLED) {
		log_info("smtp-out: Enabling route %s",
		    mta_route_to_text(route));
		route->flags &= ~ROUTE_DISABLED;
		route->flags |= ROUTE_NEW;
		route->nerror = 0;
	}

	if (route->penalty) {
#if DELAY_QUADRATIC
		route->penalty -= 1;
		route->lastpenalty = time(NULL);
#else
		route->penalty = 0;
#endif
	}
}

static void
mta_drain(struct mta_relay *r)
{
	char			 buf[64];

	log_debug("debug: mta: draining %s "
	    "refcount=%d, ntask=%zu, nconnector=%zu, nconn=%zu",
	    mta_relay_to_text(r),
	    r->refcount, r->ntask, tree_count(&r->connectors), r->nconn);

	/*
	 * All done.
	 */
	if (r->ntask == 0) {
		log_debug("debug: mta: all done for %s", mta_relay_to_text(r));
		return;
	}

	/*
	 * If we know that this relay is failing flush the tasks.
	 */
	if (r->fail) {
		mta_flush(r, r->fail, r->failstr);
		return;
	}

	/* Query secret if needed. */
	if (r->flags & RELAY_AUTH && r->secret == NULL)
		mta_query_secret(r);

	/* Query our preference if needed. */
	if (r->backupname && r->backuppref == -1)
		mta_query_preference(r);

	/* Query the domain MXs if needed. */
	if (r->domain->lastmxquery == 0)
		mta_query_mx(r);

	/* Query the limits if needed. */
	if (r->limits == NULL)
		mta_query_limits(r);

	/* Wait until we are ready to proceed. */
	if (r->status & RELAY_WAITMASK) {
		buf[0] = '\0';
		if (r->status & RELAY_WAIT_MX)
			(void)strlcat(buf, " MX", sizeof buf);
		if (r->status & RELAY_WAIT_PREFERENCE)
			(void)strlcat(buf, " preference", sizeof buf);
		if (r->status & RELAY_WAIT_SECRET)
			(void)strlcat(buf, " secret", sizeof buf);
		if (r->status & RELAY_WAIT_SOURCE)
			(void)strlcat(buf, " source", sizeof buf);
		if (r->status & RELAY_WAIT_CONNECTOR)
			(void)strlcat(buf, " connector", sizeof buf);
		log_debug("debug: mta: %s waiting for%s",
		    mta_relay_to_text(r), buf);
		return;
	}

	/*
	 * We have pending task, and it's maybe time too try a new source.
	 */
	if (r->nextsource <= time(NULL))
		mta_query_source(r);
	else {
		log_debug("debug: mta: scheduling relay %s in %llus...",
		    mta_relay_to_text(r),
		    (unsigned long long) r->nextsource - time(NULL));
		runq_schedule(runq_relay, r->nextsource, NULL, r);
		r->status |= RELAY_WAIT_CONNECTOR;
		mta_relay_ref(r);
	}
}

static void
mta_flush(struct mta_relay *relay, int fail, const char *error)
{
	struct mta_envelope	*e;
	struct mta_task		*task;
	const char     		*domain;
	void			*iter;
	struct mta_connector	*c;
	size_t			 n, r;

	log_debug("debug: mta_flush(%s, %d, \"%s\")",
	    mta_relay_to_text(relay), fail, error);

	if (fail != IMSG_MTA_DELIVERY_TEMPFAIL && fail != IMSG_MTA_DELIVERY_PERMFAIL)
		errx(1, "unexpected delivery status %d", fail);

	n = 0;
	while ((task = TAILQ_FIRST(&relay->tasks))) {
		TAILQ_REMOVE(&relay->tasks, task, entry);
		while ((e = TAILQ_FIRST(&task->envelopes))) {
			TAILQ_REMOVE(&task->envelopes, e, entry);

			/*
			 * host was suspended, cache envelope id in hoststat tree
			 * so that it can be retried when a delivery succeeds for
			 * that domain.
			 */
			domain = strchr(e->dest, '@@');
			if (fail == IMSG_MTA_DELIVERY_TEMPFAIL && domain) {
				r = 0;
				iter = NULL;
				while (tree_iter(&relay->connectors, &iter,
					NULL, (void **)&c)) {
					if (c->flags & CONNECTOR_ERROR_ROUTE)
						r++;
				}
				if (tree_count(&relay->connectors) == r)
					mta_hoststat_cache(domain+1, e->id);
			}

			mta_delivery_log(e, NULL, relay->domain->name, fail, error);
			mta_delivery_notify(e);

			n++;
		}
		free(task->sender);
		free(task);
	}

	stat_decrement("mta.task", relay->ntask);
	stat_decrement("mta.envelope", n);
	relay->ntask = 0;

	/* release all waiting envelopes for the relay */
	if (relay->state & RELAY_HOLDQ) {
		m_create(p_queue, IMSG_MTA_HOLDQ_RELEASE, 0, 0, -1);
		m_add_id(p_queue, relay->id);
		m_add_int(p_queue, -1);
		m_close(p_queue);
	}
}

/*
 * Find a route to use for this connector
 */
static struct mta_route *
mta_find_route(struct mta_connector *c, time_t now, int *limits,
    time_t *nextconn)
{
	struct mta_route	*route, *best;
	struct mta_limits	*l = c->relay->limits;
	struct mta_mx		*mx;
	int			 level, limit_host, limit_route;
	int			 family_mismatch, seen, suspended_route;
	time_t			 tm;

	log_debug("debug: mta-routing: searching new route for %s...",
	    mta_connector_to_text(c));

	tm = 0;
	limit_host = 0;
	limit_route = 0;
	suspended_route = 0;
	family_mismatch = 0;
	level = -1;
	best = NULL;
	seen = 0;

	TAILQ_FOREACH(mx, &c->relay->domain->mxs, entry) {
		/*
		 * New preference level
		 */
		if (mx->preference > level) {
#ifndef IGNORE_MX_PREFERENCE
			/*
			 * Use the current best MX if found.
			 */
			if (best)
				break;

			/*
			 * No candidate found.  There are valid MXs at this
			 * preference level but they reached their limit, or
			 * we can't connect yet.
			 */
			if (limit_host || limit_route || tm)
				break;

			/*
			 *  If we are a backup MX, do not relay to MXs with
			 *  a greater preference value.
			 */
			if (c->relay->backuppref >= 0 &&
			    mx->preference >= c->relay->backuppref)
				break;

			/*
			 * Start looking at MXs on this preference level.
			 */
#endif
			level = mx->preference;
		}

		if (mx->host->flags & HOST_IGNORE)
			continue;

		/* Found a possibly valid mx */
		seen++;

		if ((c->source->sa &&
		     c->source->sa->sa_family != mx->host->sa->sa_family) ||
		    (l->family && l->family != mx->host->sa->sa_family)) {
			log_debug("debug: mta-routing: skipping host %s: AF mismatch",
			    mta_host_to_text(mx->host));
			family_mismatch = 1;
			continue;
		}

		if (mx->host->nconn >= l->maxconn_per_host) {
			log_debug("debug: mta-routing: skipping host %s: too many connections",
			    mta_host_to_text(mx->host));
			limit_host = 1;
			continue;
		}

		if (mx->host->lastconn + l->conndelay_host > now) {
			log_debug("debug: mta-routing: skipping host %s: cannot use before %llus",
			    mta_host_to_text(mx->host),
			    (unsigned long long) mx->host->lastconn + l->conndelay_host - now);
			if (tm == 0 || mx->host->lastconn + l->conndelay_host < tm)
				tm = mx->host->lastconn + l->conndelay_host;
			continue;
		}

		route = mta_route(c->source, mx->host);

		if (route->flags & ROUTE_DISABLED) {
			log_debug("debug: mta-routing: skipping route %s: suspend",
			    mta_route_to_text(route));
			suspended_route |= route->flags & ROUTE_DISABLED;
			mta_route_unref(route); /* from here */
			continue;
		}

		if (route->nconn && (route->flags & ROUTE_NEW)) {
			log_debug("debug: mta-routing: skipping route %s: not validated yet",
			    mta_route_to_text(route));
			limit_route = 1;
			mta_route_unref(route); /* from here */
			continue;
		}

		if (route->nconn >= l->maxconn_per_route) {
			log_debug("debug: mta-routing: skipping route %s: too many connections",
			    mta_route_to_text(route));
			limit_route = 1;
			mta_route_unref(route); /* from here */
			continue;
		}

		if (route->lastconn + l->conndelay_route > now) {
			log_debug("debug: mta-routing: skipping route %s: cannot use before %llus (delay after connect)",
			    mta_route_to_text(route),
			    (unsigned long long) route->lastconn + l->conndelay_route - now);
			if (tm == 0 || route->lastconn + l->conndelay_route < tm)
				tm = route->lastconn + l->conndelay_route;
			mta_route_unref(route); /* from here */
			continue;
		}

		if (route->lastdisc + l->discdelay_route > now) {
			log_debug("debug: mta-routing: skipping route %s: cannot use before %llus (delay after disconnect)",
			    mta_route_to_text(route),
			    (unsigned long long) route->lastdisc + l->discdelay_route - now);
			if (tm == 0 || route->lastdisc + l->discdelay_route < tm)
				tm = route->lastdisc + l->discdelay_route;
			mta_route_unref(route); /* from here */
			continue;
		}

		/* Use the route with the lowest number of connections. */
		if (best && route->nconn >= best->nconn) {
			log_debug("debug: mta-routing: skipping route %s: current one is better",
			    mta_route_to_text(route));
			mta_route_unref(route); /* from here */
			continue;
		}

		if (best)
			mta_route_unref(best); /* from here */
		best = route;
		log_debug("debug: mta-routing: selecting candidate route %s",
		    mta_route_to_text(route));
	}

	if (best)
		return (best);

	/* Order is important */
	if (seen == 0) {
		log_info("smtp-out: No MX found for %s",
		    mta_connector_to_text(c));
		c->flags |= CONNECTOR_ERROR_MX;
	}
	else if (limit_route) {
		log_debug("debug: mta: hit route limit");
		*limits |= CONNECTOR_LIMIT_ROUTE;
	}
	else if (limit_host) {
		log_debug("debug: mta: hit host limit");
		*limits |= CONNECTOR_LIMIT_HOST;
	}
	else if (tm) {
		if (tm > *nextconn)
			*nextconn = tm;
	}
	else if (family_mismatch) {
		log_info("smtp-out: Address family mismatch on %s",
		    mta_connector_to_text(c));
		c->flags |= CONNECTOR_ERROR_FAMILY;
	}
	else if (suspended_route) {
		log_info("smtp-out: No valid route for %s",
		    mta_connector_to_text(c));
		if (suspended_route & ROUTE_DISABLED_NET)
			c->flags |= CONNECTOR_ERROR_ROUTE_NET;
		if (suspended_route & ROUTE_DISABLED_SMTP)
			c->flags |= CONNECTOR_ERROR_ROUTE_SMTP;
	}

	return (NULL);
}

static void
mta_log(const struct mta_envelope *evp, const char *prefix, const char *source,
    const char *relay, const char *status)
{
	log_info("%016"PRIx64" mta event=delivery evpid=%016"PRIx64" "
	    "from=<%s> to=<%s> rcpt=<%s> source=\"%s\" "
	    "relay=\"%s\" delay=%s result=\"%s\" stat=\"%s\"",
	    evp->session,
	    evp->id,
	    evp->task->sender,
	    evp->dest,
	    evp->rcpt ? evp->rcpt : "-",
	    source ? source : "-",
	    relay,
	    duration_to_text(time(NULL) - evp->creation),
	    prefix,
	    status);
}

static struct mta_relay *
mta_relay(struct envelope *e)
{
	struct mta_relay	 key, *r;

	memset(&key, 0, sizeof key);

	if (e->agent.mta.relay.flags & RELAY_BACKUP) {
		key.domain = mta_domain(e->dest.domain, 0);
		key.backupname = e->agent.mta.relay.hostname;
	} else if (e->agent.mta.relay.hostname[0]) {
		key.domain = mta_domain(e->agent.mta.relay.hostname, 1);
		key.flags |= RELAY_MX;
	} else {
		key.domain = mta_domain(e->dest.domain, 0);
		if (!(e->agent.mta.relay.flags & RELAY_STARTTLS))
			key.flags |= RELAY_TLS_OPTIONAL;
	}

	key.flags |= e->agent.mta.relay.flags;
	key.port = e->agent.mta.relay.port;
	key.pki_name = e->agent.mta.relay.pki_name;
	if (!key.pki_name[0])
		key.pki_name = NULL;
	key.ca_name = e->agent.mta.relay.ca_name;
	if (!key.ca_name[0])
		key.ca_name = NULL;
	key.authtable = e->agent.mta.relay.authtable;
	if (!key.authtable[0])
		key.authtable = NULL;
	key.authlabel = e->agent.mta.relay.authlabel;
	if (!key.authlabel[0])
		key.authlabel = NULL;
	key.sourcetable = e->agent.mta.relay.sourcetable;
	if (!key.sourcetable[0])
		key.sourcetable = NULL;
	key.helotable = e->agent.mta.relay.helotable;
	if (!key.helotable[0])
		key.helotable = NULL;
	key.heloname = e->agent.mta.relay.heloname;
	if (!key.heloname[0])
		key.heloname = NULL;

	if ((r = SPLAY_FIND(mta_relay_tree, &relays, &key)) == NULL) {
		r = xcalloc(1, sizeof *r, "mta_relay");
		TAILQ_INIT(&r->tasks);
		r->id = generate_uid();
		r->flags = key.flags;
		r->domain = key.domain;
		r->backupname = key.backupname ?
		    xstrdup(key.backupname, "mta: backupname") : NULL;
		r->backuppref = -1;
		r->port = key.port;
		r->pki_name = key.pki_name ? xstrdup(key.pki_name, "mta: pki_name") : NULL;
		r->ca_name = key.ca_name ? xstrdup(key.ca_name, "mta: ca_name") : NULL;
		if (key.authtable)
			r->authtable = xstrdup(key.authtable, "mta: authtable");
		if (key.authlabel)
			r->authlabel = xstrdup(key.authlabel, "mta: authlabel");
		if (key.sourcetable)
			r->sourcetable = xstrdup(key.sourcetable,
			    "mta: sourcetable");
		if (key.helotable)
			r->helotable = xstrdup(key.helotable,
			    "mta: helotable");
		if (key.heloname)
			r->heloname = xstrdup(key.heloname,
			    "mta: heloname");
		SPLAY_INSERT(mta_relay_tree, &relays, r);
		stat_increment("mta.relay", 1);
	} else {
		mta_domain_unref(key.domain); /* from here */
	}

	r->refcount++;
	return (r);
}

static void
mta_relay_ref(struct mta_relay *r)
{
	r->refcount++;
}

static void
mta_relay_unref(struct mta_relay *relay)
{
	struct mta_connector	*c;

	if (--relay->refcount)
		return;

	/* Make sure they are no envelopes held for this relay */
	if (relay->state & RELAY_HOLDQ) {
		m_create(p_queue, IMSG_MTA_HOLDQ_RELEASE, 0, 0, -1);
		m_add_id(p_queue, relay->id);
		m_add_int(p_queue, 0);
		m_close(p_queue);
	}

	log_debug("debug: mta: freeing %s", mta_relay_to_text(relay));
	SPLAY_REMOVE(mta_relay_tree, &relays, relay);

	while ((tree_poproot(&relay->connectors, NULL, (void**)&c)))
		mta_connector_free(c);

	free(relay->authlabel);
	free(relay->authtable);
	free(relay->backupname);
	free(relay->pki_name);
	free(relay->ca_name);
	free(relay->helotable);
	free(relay->heloname);
	free(relay->secret);
	free(relay->sourcetable);

	mta_domain_unref(relay->domain); /* from constructor */
	free(relay);
	stat_decrement("mta.relay", 1);
}

const char *
mta_relay_to_text(struct mta_relay *relay)
{
	static char	 buf[1024];
	char		 tmp[32];
	const char	*sep = ",";

	(void)snprintf(buf, sizeof buf, "[relay:%s", relay->domain->name);

	if (relay->port) {
		(void)strlcat(buf, sep, sizeof buf);
		(void)snprintf(tmp, sizeof tmp, "port=%d", (int)relay->port);
		(void)strlcat(buf, tmp, sizeof buf);
	}

	if (relay->flags & RELAY_STARTTLS) {
		(void)strlcat(buf, sep, sizeof buf);
		(void)strlcat(buf, "starttls", sizeof buf);
	}

	if (relay->flags & RELAY_SMTPS) {
		(void)strlcat(buf, sep, sizeof buf);
		(void)strlcat(buf, "smtps", sizeof buf);
	}

	if (relay->flags & RELAY_AUTH) {
		(void)strlcat(buf, sep, sizeof buf);
		(void)strlcat(buf, "auth=", sizeof buf);
		(void)strlcat(buf, relay->authtable, sizeof buf);
		(void)strlcat(buf, ":", sizeof buf);
		(void)strlcat(buf, relay->authlabel, sizeof buf);
	}

	if (relay->pki_name) {
		(void)strlcat(buf, sep, sizeof buf);
		(void)strlcat(buf, "pki_name=", sizeof buf);
		(void)strlcat(buf, relay->pki_name, sizeof buf);
	}

	if (relay->flags & RELAY_MX) {
		(void)strlcat(buf, sep, sizeof buf);
		(void)strlcat(buf, "mx", sizeof buf);
	}

	if (relay->backupname) {
		(void)strlcat(buf, sep, sizeof buf);
		(void)strlcat(buf, "backup=", sizeof buf);
		(void)strlcat(buf, relay->backupname, sizeof buf);
	}

	if (relay->sourcetable) {
		(void)strlcat(buf, sep, sizeof buf);
		(void)strlcat(buf, "sourcetable=", sizeof buf);
		(void)strlcat(buf, relay->sourcetable, sizeof buf);
	}

	if (relay->helotable) {
		(void)strlcat(buf, sep, sizeof buf);
		(void)strlcat(buf, "helotable=", sizeof buf);
		(void)strlcat(buf, relay->helotable, sizeof buf);
	}

	if (relay->heloname) {
		(void)strlcat(buf, sep, sizeof buf);
		(void)strlcat(buf, "heloname=", sizeof buf);
		(void)strlcat(buf, relay->heloname, sizeof buf);
	}

	(void)strlcat(buf, "]", sizeof buf);

	return (buf);
}

static void
mta_relay_show(struct mta_relay *r, struct mproc *p, uint32_t id, time_t t)
{
	struct mta_connector	*c;
	void			*iter;
	char			 buf[1024], flags[1024], dur[64];
	time_t			 to;

	flags[0] = '\0';

#define SHOWSTATUS(f, n) do {							\
		if (r->status & (f)) {						\
			if (flags[0])						\
				(void)strlcat(flags, ",", sizeof(flags));	\
			(void)strlcat(flags, (n), sizeof(flags));		\
		}								\
	} while(0)

	SHOWSTATUS(RELAY_WAIT_MX, "MX");
	SHOWSTATUS(RELAY_WAIT_PREFERENCE, "preference");
	SHOWSTATUS(RELAY_WAIT_SECRET, "secret");
	SHOWSTATUS(RELAY_WAIT_LIMITS, "limits");
	SHOWSTATUS(RELAY_WAIT_SOURCE, "source");
	SHOWSTATUS(RELAY_WAIT_CONNECTOR, "connector");
#undef SHOWSTATUS

	if (runq_pending(runq_relay, NULL, r, &to))
		(void)snprintf(dur, sizeof(dur), "%s", duration_to_text(to - t));
	else
		(void)strlcpy(dur, "-", sizeof(dur));

	(void)snprintf(buf, sizeof(buf), "%s refcount=%d ntask=%zu nconn=%zu lastconn=%s timeout=%s wait=%s%s",
	    mta_relay_to_text(r),
	    r->refcount,
	    r->ntask,
	    r->nconn,
	    r->lastconn ? duration_to_text(t - r->lastconn) : "-",
	    dur,
	    flags,
	    (r->state & RELAY_ONHOLD) ? "ONHOLD" : "");
	m_compose(p, IMSG_CTL_MTA_SHOW_RELAYS, id, 0, -1, buf, strlen(buf) + 1);

	iter = NULL;
	while (tree_iter(&r->connectors, &iter, NULL, (void **)&c)) {

		if (runq_pending(runq_connector, NULL, c, &to))
			(void)snprintf(dur, sizeof(dur), "%s", duration_to_text(to - t));
		else
			(void)strlcpy(dur, "-", sizeof(dur));

		flags[0] = '\0';

#define SHOWFLAG(f, n) do {							\
		if (c->flags & (f)) {						\
			if (flags[0])						\
				(void)strlcat(flags, ",", sizeof(flags));	\
			(void)strlcat(flags, (n), sizeof(flags));		\
		}								\
	} while(0)

		SHOWFLAG(CONNECTOR_NEW,		"NEW");
		SHOWFLAG(CONNECTOR_WAIT,	"WAIT");

		SHOWFLAG(CONNECTOR_ERROR_FAMILY,	"ERROR_FAMILY");
		SHOWFLAG(CONNECTOR_ERROR_SOURCE,	"ERROR_SOURCE");
		SHOWFLAG(CONNECTOR_ERROR_MX,		"ERROR_MX");
		SHOWFLAG(CONNECTOR_ERROR_ROUTE_NET,	"ERROR_ROUTE_NET");
		SHOWFLAG(CONNECTOR_ERROR_ROUTE_SMTP,	"ERROR_ROUTE_SMTP");
		SHOWFLAG(CONNECTOR_ERROR_BLOCKED,	"ERROR_BLOCKED");

		SHOWFLAG(CONNECTOR_LIMIT_HOST,		"LIMIT_HOST");
		SHOWFLAG(CONNECTOR_LIMIT_ROUTE,		"LIMIT_ROUTE");
		SHOWFLAG(CONNECTOR_LIMIT_SOURCE,	"LIMIT_SOURCE");
		SHOWFLAG(CONNECTOR_LIMIT_RELAY,		"LIMIT_RELAY");
		SHOWFLAG(CONNECTOR_LIMIT_CONN,		"LIMIT_CONN");
		SHOWFLAG(CONNECTOR_LIMIT_DOMAIN,	"LIMIT_DOMAIN");
#undef SHOWFLAG

		(void)snprintf(buf, sizeof(buf),
		    "  connector %s refcount=%d nconn=%zu lastconn=%s timeout=%s flags=%s",
		    mta_source_to_text(c->source),
		    c->refcount,
		    c->nconn,
		    c->lastconn ? duration_to_text(t - c->lastconn) : "-",
		    dur,
		    flags);
		m_compose(p, IMSG_CTL_MTA_SHOW_RELAYS, id, 0, -1, buf,
		    strlen(buf) + 1);


	}
}

static int
mta_relay_cmp(const struct mta_relay *a, const struct mta_relay *b)
{
	int	r;

	if (a->domain < b->domain)
		return (-1);
	if (a->domain > b->domain)
		return (1);

	if (a->flags < b->flags)
		return (-1);
	if (a->flags > b->flags)
		return (1);

	if (a->port < b->port)
		return (-1);
	if (a->port > b->port)
		return (1);

	if (a->authtable == NULL && b->authtable)
		return (-1);
	if (a->authtable && b->authtable == NULL)
		return (1);
	if (a->authtable && ((r = strcmp(a->authtable, b->authtable))))
		return (r);
	if (a->authlabel && ((r = strcmp(a->authlabel, b->authlabel))))
		return (r);
	if (a->sourcetable == NULL && b->sourcetable)
		return (-1);
	if (a->sourcetable && b->sourcetable == NULL)
		return (1);
	if (a->sourcetable && ((r = strcmp(a->sourcetable, b->sourcetable))))
		return (r);
	if (a->helotable == NULL && b->helotable)
		return (-1);
	if (a->helotable && b->helotable == NULL)
		return (1);
	if (a->helotable && ((r = strcmp(a->helotable, b->helotable))))
		return (r);
	if (a->heloname == NULL && b->heloname)
		return (-1);
	if (a->heloname && b->heloname == NULL)
		return (1);
	if (a->heloname && ((r = strcmp(a->heloname, b->heloname))))
		return (r);

	if (a->pki_name == NULL && b->pki_name)
		return (-1);
	if (a->pki_name && b->pki_name == NULL)
		return (1);
	if (a->pki_name && ((r = strcmp(a->pki_name, b->pki_name))))
		return (r);

	if (a->ca_name == NULL && b->ca_name)
		return (-1);
	if (a->ca_name && b->ca_name == NULL)
		return (1);
	if (a->ca_name && ((r = strcmp(a->ca_name, b->ca_name))))
		return (r);

	if (a->backupname && ((r = strcmp(a->backupname, b->backupname))))
		return (r);

	return (0);
}

SPLAY_GENERATE(mta_relay_tree, mta_relay, entry, mta_relay_cmp);

static struct mta_host *
mta_host(const struct sockaddr *sa)
{
	struct mta_host		key, *h;
	struct sockaddr_storage	ss;

	memmove(&ss, sa, sa->sa_len);
	key.sa = (struct sockaddr*)&ss;
	h = SPLAY_FIND(mta_host_tree, &hosts, &key);

	if (h == NULL) {
		h = xcalloc(1, sizeof(*h), "mta_host");
		h->sa = xmemdup(sa, sa->sa_len, "mta_host");
		SPLAY_INSERT(mta_host_tree, &hosts, h);
		stat_increment("mta.host", 1);
	}

	h->refcount++;
	return (h);
}

static void
mta_host_ref(struct mta_host *h)
{
	h->refcount++;
}

static void
mta_host_unref(struct mta_host *h)
{
	if (--h->refcount)
		return;

	SPLAY_REMOVE(mta_host_tree, &hosts, h);
	free(h->sa);
	free(h->ptrname);
	free(h);
	stat_decrement("mta.host", 1);
}

const char *
mta_host_to_text(struct mta_host *h)
{
	static char buf[1024];

	if (h->ptrname)
		(void)snprintf(buf, sizeof buf, "%s (%s)",
		    sa_to_text(h->sa), h->ptrname);
	else
		(void)snprintf(buf, sizeof buf, "%s", sa_to_text(h->sa));

	return (buf);
}

static int
mta_host_cmp(const struct mta_host *a, const struct mta_host *b)
{
	if (a->sa->sa_len < b->sa->sa_len)
		return (-1);
	if (a->sa->sa_len > b->sa->sa_len)
		return (1);
	return (memcmp(a->sa, b->sa, a->sa->sa_len));
}

SPLAY_GENERATE(mta_host_tree, mta_host, entry, mta_host_cmp);

static struct mta_domain *
mta_domain(char *name, int flags)
{
	struct mta_domain	key, *d;

	key.name = name;
	key.flags = flags;
	d = SPLAY_FIND(mta_domain_tree, &domains, &key);

	if (d == NULL) {
		d = xcalloc(1, sizeof(*d), "mta_domain");
		d->name = xstrdup(name, "mta_domain");
		d->flags = flags;
		TAILQ_INIT(&d->mxs);
		SPLAY_INSERT(mta_domain_tree, &domains, d);
		stat_increment("mta.domain", 1);
	}

	d->refcount++;
	return (d);
}

#if 0
static void
mta_domain_ref(struct mta_domain *d)
{
	d->refcount++;
}
#endif

static void
mta_domain_unref(struct mta_domain *d)
{
	struct mta_mx	*mx;

	if (--d->refcount)
		return;

	while ((mx = TAILQ_FIRST(&d->mxs))) {
		TAILQ_REMOVE(&d->mxs, mx, entry);
		mta_host_unref(mx->host); /* from IMSG_DNS_HOST */
		free(mx);
	}

	SPLAY_REMOVE(mta_domain_tree, &domains, d);
	free(d->name);
	free(d);
	stat_decrement("mta.domain", 1);
}

static int
mta_domain_cmp(const struct mta_domain *a, const struct mta_domain *b)
{
	if (a->flags < b->flags)
		return (-1);
	if (a->flags > b->flags)
		return (1);
	return (strcasecmp(a->name, b->name));
}

SPLAY_GENERATE(mta_domain_tree, mta_domain, entry, mta_domain_cmp);

static struct mta_source *
mta_source(const struct sockaddr *sa)
{
	struct mta_source	key, *s;
	struct sockaddr_storage	ss;

	if (sa) {
		memmove(&ss, sa, sa->sa_len);
		key.sa = (struct sockaddr*)&ss;
	} else
		key.sa = NULL;
	s = SPLAY_FIND(mta_source_tree, &sources, &key);

	if (s == NULL) {
		s = xcalloc(1, sizeof(*s), "mta_source");
		if (sa)
			s->sa = xmemdup(sa, sa->sa_len, "mta_source");
		SPLAY_INSERT(mta_source_tree, &sources, s);
		stat_increment("mta.source", 1);
	}

	s->refcount++;
	return (s);
}

static void
mta_source_ref(struct mta_source *s)
{
	s->refcount++;
}

static void
mta_source_unref(struct mta_source *s)
{
	if (--s->refcount)
		return;

	SPLAY_REMOVE(mta_source_tree, &sources, s);
	free(s->sa);
	free(s);
	stat_decrement("mta.source", 1);
}

static const char *
mta_source_to_text(struct mta_source *s)
{
	static char buf[1024];

	if (s->sa == NULL)
		return "[]";
	(void)snprintf(buf, sizeof buf, "%s", sa_to_text(s->sa));
	return (buf);
}

static int
mta_source_cmp(const struct mta_source *a, const struct mta_source *b)
{
	if (a->sa == NULL)
		return ((b->sa == NULL) ? 0 : -1);
	if (b->sa == NULL)
		return (1);
	if (a->sa->sa_len < b->sa->sa_len)
		return (-1);
	if (a->sa->sa_len > b->sa->sa_len)
		return (1);
	return (memcmp(a->sa, b->sa, a->sa->sa_len));
}

SPLAY_GENERATE(mta_source_tree, mta_source, entry, mta_source_cmp);

static struct mta_connector *
mta_connector(struct mta_relay *relay, struct mta_source *source)
{
	struct mta_connector	*c;

	c = tree_get(&relay->connectors, (uintptr_t)(source));
	if (c == NULL) {
		c = xcalloc(1, sizeof(*c), "mta_connector");
		c->relay = relay;
		c->source = source;
		c->flags |= CONNECTOR_NEW;
		mta_source_ref(source);
		tree_xset(&relay->connectors, (uintptr_t)(source), c);
		stat_increment("mta.connector", 1);
		log_debug("debug: mta: new %s", mta_connector_to_text(c));
	}

	return (c);
}

static void
mta_connector_free(struct mta_connector *c)
{
	log_debug("debug: mta: freeing %s",
	    mta_connector_to_text(c));

	if (c->flags & CONNECTOR_WAIT) {
		log_debug("debug: mta: cancelling timeout for %s",
		    mta_connector_to_text(c));
		runq_cancel(runq_connector, NULL, c);
	}
	mta_source_unref(c->source); /* from constructor */
	free(c);

	stat_decrement("mta.connector", 1);
}

static const char *
mta_connector_to_text(struct mta_connector *c)
{
	static char buf[1024];

	(void)snprintf(buf, sizeof buf, "[connector:%s->%s,0x%x]",
	    mta_source_to_text(c->source),
	    mta_relay_to_text(c->relay),
	    c->flags);
	return (buf);
}

static struct mta_route *
mta_route(struct mta_source *src, struct mta_host *dst)
{
	struct mta_route	key, *r;
	static uint64_t		rid = 0;

	key.src = src;
	key.dst = dst;
	r = SPLAY_FIND(mta_route_tree, &routes, &key);

	if (r == NULL) {
		r = xcalloc(1, sizeof(*r), "mta_route");
		r->src = src;
		r->dst = dst;
		r->flags |= ROUTE_NEW;
		r->id = ++rid;
		SPLAY_INSERT(mta_route_tree, &routes, r);
		mta_source_ref(src);
		mta_host_ref(dst);
		stat_increment("mta.route", 1);
	}
	else if (r->flags & ROUTE_RUNQ) {
		log_debug("debug: mta: mta_route_ref(): cancelling runq for route %s",
		    mta_route_to_text(r));
		r->flags &= ~(ROUTE_RUNQ | ROUTE_KEEPALIVE);
		runq_cancel(runq_route, NULL, r);
		r->refcount--; /* from mta_route_unref() */
	}

	r->refcount++;
	return (r);
}

static void
mta_route_ref(struct mta_route *r)
{
	r->refcount++;
}

static void
mta_route_unref(struct mta_route *r)
{
	time_t	sched, now;
	int	delay;

	if (--r->refcount)
		return;

	/*
	 * Nothing references this route, but we might want to keep it alive
	 * for a while.
	 */
	now = time(NULL);
	sched = 0;

	if (r->penalty) {
#if DELAY_QUADRATIC
		delay = DELAY_ROUTE_BASE * r->penalty * r->penalty;
#else
		delay = 15 * 60;
#endif
		if (delay > DELAY_ROUTE_MAX)
			delay = DELAY_ROUTE_MAX;
		sched = r->lastpenalty + delay;
		log_debug("debug: mta: mta_route_unref(): keeping route %s alive for %llus (penalty %d)",
		    mta_route_to_text(r), (unsigned long long) sched - now, r->penalty);
	} else if (!(r->flags & ROUTE_KEEPALIVE)) {
		if (r->lastconn + max_seen_conndelay_route > now)
			sched = r->lastconn + max_seen_conndelay_route;
		if (r->lastdisc + max_seen_discdelay_route > now &&
		    r->lastdisc + max_seen_discdelay_route < sched)
			sched = r->lastdisc + max_seen_discdelay_route;

		if (sched > now)
			log_debug("debug: mta: mta_route_unref(): keeping route %s alive for %llus (imposed delay)",
			    mta_route_to_text(r), (unsigned long long) sched - now);
	}

	if (sched > now) {
		r->flags |= ROUTE_RUNQ;
		runq_schedule(runq_route, sched, NULL, r);
		r->refcount++;
		return;
	}

	log_debug("debug: mta: mta_route_unref(): really discarding route %s",
	    mta_route_to_text(r));

	SPLAY_REMOVE(mta_route_tree, &routes, r);
	mta_source_unref(r->src); /* from constructor */
	mta_host_unref(r->dst); /* from constructor */
	free(r);
	stat_decrement("mta.route", 1);
}

static const char *
mta_route_to_text(struct mta_route *r)
{
	static char	buf[1024];

	(void)snprintf(buf, sizeof buf, "%s <-> %s",
	    mta_source_to_text(r->src),
	    mta_host_to_text(r->dst));

	return (buf);
}

static int
mta_route_cmp(const struct mta_route *a, const struct mta_route *b)
{
	if (a->src < b->src)
		return (-1);
	if (a->src > b->src)
		return (1);

	if (a->dst < b->dst)
		return (-1);
	if (a->dst > b->dst)
		return (1);

	return (0);
}

SPLAY_GENERATE(mta_route_tree, mta_route, entry, mta_route_cmp);

void
mta_block(struct mta_source *src, char *dom)
{
	struct mta_block key, *b;

	key.source = src;
	key.domain = dom;

	b = SPLAY_FIND(mta_block_tree, &blocks, &key);
	if (b != NULL)
		return;

	b = xcalloc(1, sizeof(*b), "mta_block");
	if (dom)
		b->domain = xstrdup(dom, "mta_block");
	b->source = src;
	mta_source_ref(src);
	SPLAY_INSERT(mta_block_tree, &blocks, b);
}

void
mta_unblock(struct mta_source *src, char *dom)
{
	struct mta_block key, *b;

	key.source = src;
	key.domain = dom;

	b = SPLAY_FIND(mta_block_tree, &blocks, &key);
	if (b == NULL)
		return;

	SPLAY_REMOVE(mta_block_tree, &blocks, b);

	mta_source_unref(b->source);
	free(b->domain);
	free(b);
}

int
mta_is_blocked(struct mta_source *src, char *dom)
{
	struct mta_block key;

	key.source = src;
	key.domain = dom;

	if (SPLAY_FIND(mta_block_tree, &blocks, &key))
		return (1);

	return (0);
}

static
int
mta_block_cmp(const struct mta_block *a, const struct mta_block *b)
{
	if (a->source < b->source)
		return (-1);
	if (a->source > b->source)
		return (1);
	if (!a->domain && b->domain)
		return (-1);
	if (a->domain && !b->domain)
		return (1);
	if (a->domain == b->domain)
		return (0);
	return (strcasecmp(a->domain, b->domain));
}

SPLAY_GENERATE(mta_block_tree, mta_block, entry, mta_block_cmp);



/* hoststat errors are not critical, we do best effort */
void
mta_hoststat_update(const char *host, const char *error)
{
	struct hoststat	*hs = NULL;
	char		 buf[HOST_NAME_MAX+1];
	time_t		 tm;

	if (!lowercase(buf, host, sizeof buf))
		return;

	tm = time(NULL);
	hs = dict_get(&hoststat, buf);
	if (hs == NULL) {
		if ((hs = calloc(1, sizeof *hs)) == NULL)
			return;
		tree_init(&hs->deferred);
		runq_schedule(runq_hoststat, tm+HOSTSTAT_EXPIRE_DELAY, NULL, hs);
	}
	(void)strlcpy(hs->name, buf, sizeof hs->name);
	(void)strlcpy(hs->error, error, sizeof hs->error);
	hs->tm = time(NULL);
	dict_set(&hoststat, buf, hs);

	runq_cancel(runq_hoststat, NULL, hs);
	runq_schedule(runq_hoststat, tm+HOSTSTAT_EXPIRE_DELAY, NULL, hs);
}

void
mta_hoststat_cache(const char *host, uint64_t evpid)
{
	struct hoststat	*hs = NULL;
	char buf[HOST_NAME_MAX+1];

	if (!lowercase(buf, host, sizeof buf))
		return;

	hs = dict_get(&hoststat, buf);
	if (hs == NULL)
		return;

	if (tree_count(&hs->deferred) >= env->sc_mta_max_deferred)
		return;

	tree_set(&hs->deferred, evpid, NULL);
}

void
mta_hoststat_uncache(const char *host, uint64_t evpid)
{
	struct hoststat	*hs = NULL;
	char buf[HOST_NAME_MAX+1];

	if (!lowercase(buf, host, sizeof buf))
		return;

	hs = dict_get(&hoststat, buf);
	if (hs == NULL)
		return;

	tree_pop(&hs->deferred, evpid);
}

void
mta_hoststat_reschedule(const char *host)
{
	struct hoststat	*hs = NULL;
	char		 buf[HOST_NAME_MAX+1];
	uint64_t	 evpid;

	if (!lowercase(buf, host, sizeof buf))
		return;

	hs = dict_get(&hoststat, buf);
	if (hs == NULL)
		return;

	while (tree_poproot(&hs->deferred, &evpid, NULL)) {
		m_compose(p_queue, IMSG_MTA_SCHEDULE, 0, 0, -1,
		    &evpid, sizeof evpid);
	}
}

static void
mta_hoststat_remove_entry(struct hoststat *hs)
{
	while (tree_poproot(&hs->deferred, NULL, NULL))
		;
	dict_pop(&hoststat, hs->name);
	runq_cancel(runq_hoststat, NULL, hs);
}
@


1.204
log
@remove dead code.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.203 2017/01/09 09:53:23 reyk Exp $	*/
d60 1
a180 1
	struct mta_task		*task;
a187 1
	struct mta_envelope	*e;
d208 1
a208 77

			relay = mta_relay(&evp);
			/* ignore if we don't know the limits yet */
			if (relay->limits &&
			    relay->ntask >= (size_t)relay->limits->task_hiwat) {
				if (!(relay->state & RELAY_ONHOLD)) {
					log_info("smtp-out: hiwat reached on %s: holding envelopes",
					    mta_relay_to_text(relay));
					relay->state |= RELAY_ONHOLD;
				}
			}

			/*
			 * If the relay has too many pending tasks, tell the
			 * scheduler to hold it until further notice
			 */
			if (relay->state & RELAY_ONHOLD) {
				relay->state |= RELAY_HOLDQ;
				m_create(p_queue, IMSG_MTA_DELIVERY_HOLD, 0, 0, -1);
				m_add_evpid(p_queue, evp.id);
				m_add_id(p_queue, relay->id);
				m_close(p_queue);
				mta_relay_unref(relay); /* from here */
				return;
			}

			task = NULL;
			TAILQ_FOREACH(task, &relay->tasks, entry)
				if (task->msgid == evpid_to_msgid(evp.id))
					break;

			if (task == NULL) {
				task = xmalloc(sizeof *task, "mta_task");
				TAILQ_INIT(&task->envelopes);
				task->relay = relay;
				relay->ntask += 1;
				TAILQ_INSERT_TAIL(&relay->tasks, task, entry);
				task->msgid = evpid_to_msgid(evp.id);
				if (evp.sender.user[0] || evp.sender.domain[0])
					(void)snprintf(buf, sizeof buf, "%s@@%s",
					    evp.sender.user, evp.sender.domain);
				else
					buf[0] = '\0';
				task->sender = xstrdup(buf, "mta_task:sender");
				stat_increment("mta.task", 1);
			}

			e = xcalloc(1, sizeof *e, "mta_envelope");
			e->id = evp.id;
			e->creation = evp.creation;
			(void)snprintf(buf, sizeof buf, "%s@@%s",
			    evp.dest.user, evp.dest.domain);
			e->dest = xstrdup(buf, "mta_envelope:dest");
			(void)snprintf(buf, sizeof buf, "%s@@%s",
			    evp.rcpt.user, evp.rcpt.domain);
			if (strcmp(buf, e->dest))
				e->rcpt = xstrdup(buf, "mta_envelope:rcpt");
			e->task = task;
			if (evp.dsn_orcpt.user[0] && evp.dsn_orcpt.domain[0]) {
				(void)snprintf(buf, sizeof buf, "%s@@%s",
			    	    evp.dsn_orcpt.user, evp.dsn_orcpt.domain);
				e->dsn_orcpt = xstrdup(buf,
				    "mta_envelope:dsn_orcpt");
			}
			(void)strlcpy(e->dsn_envid, evp.dsn_envid,
			    sizeof e->dsn_envid);
			e->dsn_notify = evp.dsn_notify;
			e->dsn_ret = evp.dsn_ret;

			TAILQ_INSERT_TAIL(&task->envelopes, e, entry);
			log_debug("debug: mta: received evp:%016" PRIx64
			    " for <%s>", e->id, e->dest);

			stat_increment("mta.envelope", 1);

			mta_drain(relay);
			mta_relay_unref(relay); /* from here */
d618 86
@


1.203
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.202 2016/09/03 22:59:06 giovanni Exp $	*/
a392 18
			return;
		}
	}

	if (p->proc == PROC_PARENT) {
		switch (imsg->hdr.type) {
		case IMSG_CTL_VERBOSE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			log_trace_verbose(v);
			return;

		case IMSG_CTL_PROFILE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			profiling = v;
@


1.202
log
@log IP/hostname for all SMTP operations.
patch from Pavel Korovin, thanks
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.201 2016/05/22 16:31:21 gilles Exp $	*/
d403 1
a403 1
			log_verbose(v);
@


1.201
log
@start work on improving the log format, this is work in progress but it'll
be better worked in tree

ok eric@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.200 2016/01/14 18:56:55 mmcc Exp $	*/
d1613 2
a1614 2
	    "from=<%s> to=<%s> rcpt=<%s> source=%s "
	    "relay=%s delay=%s result=%s stat=%s",
@


1.200
log
@Check whether a string from imsg is empty by dereferencing the char*
rather than using strlen. That way we don't have to walk through the
entire string.

ok sunnil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.199 2015/12/28 22:08:30 jung Exp $	*/
d1612 4
a1615 4
	log_info("relay: %s for %016" PRIx64 ": session=%016"PRIx64", "
	    "from=<%s>, to=<%s>, rcpt=<%s>, source=%s, "
	    "relay=%s, delay=%s, stat=%s",
	    prefix,
a1616 1
	    evp->session,
d1623 1
@


1.199
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.198 2015/12/14 10:22:12 jung Exp $	*/
d520 1
a520 1
			if (strlen(dom)) {
d537 1
a537 1
			if (strlen(dom)) {
@


1.198
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.197 2015/12/12 20:02:31 gilles Exp $	*/
d2437 1
a2437 1
	if (! lowercase(buf, host, sizeof buf))
d2463 1
a2463 1
	if (! lowercase(buf, host, sizeof buf))
d2482 1
a2482 1
	if (! lowercase(buf, host, sizeof buf))
d2499 1
a2499 1
	if (! lowercase(buf, host, sizeof buf))
@


1.197
log
@remove CA from pki and no longer allow specifying a CA with 'pki' keyword.
introduce 'ca' keyword to allow specifying a custom CA.
making CA part of pki was a bad idea and several people hit use-cases that
plain couldn't work.

instead of:
    pki foobar.org ca "/etc/mail/CA.pem"

use now:
    ca foobar.org certificate "/etc/mail/CA.pem"


ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.196 2015/12/01 10:48:21 gilles Exp $	*/
d1045 1
a1045 1
			relay->failstr = "No valid route to destination";	
d1909 1
a1909 1
		
@


1.196
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.195 2015/12/01 10:41:35 gilles Exp $	*/
d1651 3
d1681 1
d1737 1
d1966 7
@


1.195
log
@delay between retries when operating as a secondary MX increases too much,
reduce it to something saner. while at it cleanup some whitespaces and set
the relay task pointer to NULL before iterating over tasks
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.194 2015/11/30 12:49:35 gilles Exp $	*/
d1446 1
a1446 1
		 */		
@


1.194
log
@mechanical rename of some IMSG constants

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.193 2015/11/26 08:51:22 tim Exp $	*/
d54 2
a55 2
#define DELAY_ROUTE_BASE	200
#define DELAY_ROUTE_MAX		(3600 * 4)
d235 1
d417 1
a417 1
			
d671 1
a671 1
		mta_route_disable(route, 2, ROUTE_DISABLED_NET);
@


1.193
log
@Don't dereference a route and then reference it again. In this particular case,
the route would be referenced at least twice, so there is no use after free.

Prompted by a mail from David CARLIER to misc@@opensmtpd.

OK eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.192 2015/10/14 22:01:43 gilles Exp $	*/
d386 1
a386 1
		case IMSG_MTA_SSL_INIT:
d390 1
a390 1
		case IMSG_MTA_SSL_VERIFY:
@


1.192
log
@whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.191 2015/01/20 17:37:54 deraadt Exp $	*/
d1249 1
a1249 1
	if (route->flags & ROUTE_DISABLED) {
d1251 3
a1253 2
		mta_route_unref(route); /* from last call to here */
	}
a1255 1
	mta_route_ref(route);
@


1.191
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.190 2015/01/16 06:40:20 deraadt Exp $	*/
d212 1
a212 1
			if (relay->limits && 
d1285 1
a1285 1
	    "refcount=%d, ntask=%zu, nconnector=%zu, nconn=%zu", 
d1472 1
a1472 1
			 */ 
@


1.190
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.189 2014/07/08 13:02:42 eric Exp $	*/
d162 1
a162 1
	char			 name[SMTPD_MAXHOSTNAMELEN];
d164 1
a164 1
	char			 error[SMTPD_MAXLINESIZE];
d197 1
a197 1
	char			 buf[SMTPD_MAXLINESIZE];
d2421 1
a2421 1
	char		 buf[SMTPD_MAXHOSTNAMELEN];
d2448 1
a2448 1
	char buf[SMTPD_MAXHOSTNAMELEN];
d2467 1
a2467 1
	char buf[SMTPD_MAXHOSTNAMELEN];
d2483 1
a2483 1
	char		 buf[SMTPD_MAXHOSTNAMELEN];
@


1.189
log
@make sure to clear the WAIT flag when cancelling the connector timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.186 2014/04/19 13:32:07 gilles Exp $	*/
d34 1
@


1.188
log
@fix typos.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.187 2014/05/20 18:47:01 eric Exp $	*/
d1079 1
@


1.187
log
@format string cleanup: change "%i" to "%d" and fix a few typos
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.186 2014/04/19 13:32:07 gilles Exp $	*/
d895 1
a895 1
		 * another source will not be queried immediatly.
@


1.186
log
@(void) cast strlcpy() / strlcat() / snprintf() that cannot truncate

(void) cast a few calls that are ok to truncate because they are not used
in anything critical / unsafe, but just to make some debug/info logs a bit
more informative
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.185 2014/04/04 16:10:42 eric Exp $	*/
d230 1
a230 1
				mta_relay_unref(relay);
d746 1
a746 1
			log_warnx("warn: bad delivery type %i for %016" PRIx64,
d777 1
a777 1
		log_warnx("warn: bad delivery type %i for %016" PRIx64,
d1077 1
a1077 1
		log_debug("debug: mta: canceling connector timeout");
d2193 1
a2193 1
		log_debug("debug: mta: canceling timeout for %s",
d2237 1
a2237 1
		log_debug("debug: mta: mta_route_ref(): canceling runq for route %s",
d2300 1
a2300 1
	log_debug("debug: mta: ma_route_unref(): really discarding route %s",
@


1.185
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d246 1
a246 1
					snprintf(buf, sizeof buf, "%s@@%s",
d257 1
a257 1
			snprintf(buf, sizeof buf, "%s@@%s",
d260 1
a260 1
			snprintf(buf, sizeof buf, "%s@@%s",
d266 1
a266 1
				snprintf(buf, sizeof buf, "%s@@%s",
d271 1
a271 1
			strlcpy(e->dsn_envid, evp.dsn_envid,
d449 1
a449 1
				snprintf(buf, sizeof(buf),
d475 1
a475 1
				snprintf(buf, sizeof(buf),
d499 1
a499 1
				snprintf(buf, sizeof(buf),
d519 3
a521 2
				strlcpy(buf, dom, sizeof(buf));
				mta_block(source, buf);
d536 3
a538 2
				strlcpy(buf, dom, sizeof(buf));
				mta_unblock(source, buf);
d548 1
a548 1
				snprintf(buf, sizeof(buf), "%s -> %s",
d784 1
a784 1
		strlcpy(e->status, status, sizeof(e->status));
d1323 1
a1323 1
			strlcat(buf, " MX", sizeof buf);
d1325 1
a1325 1
			strlcat(buf, " preference", sizeof buf);
d1327 1
a1327 1
			strlcat(buf, " secret", sizeof buf);
d1329 1
a1329 1
			strlcat(buf, " source", sizeof buf);
d1331 1
a1331 1
			strlcat(buf, " connector", sizeof buf);
d1747 1
a1747 1
	snprintf(buf, sizeof buf, "[relay:%s", relay->domain->name);
d1750 3
a1752 3
		strlcat(buf, sep, sizeof buf);
		snprintf(tmp, sizeof tmp, "port=%d", (int)relay->port);
		strlcat(buf, tmp, sizeof buf);
d1756 2
a1757 2
		strlcat(buf, sep, sizeof buf);
		strlcat(buf, "starttls", sizeof buf);
d1761 2
a1762 2
		strlcat(buf, sep, sizeof buf);
		strlcat(buf, "smtps", sizeof buf);
d1766 5
a1770 5
		strlcat(buf, sep, sizeof buf);
		strlcat(buf, "auth=", sizeof buf);
		strlcat(buf, relay->authtable, sizeof buf);
		strlcat(buf, ":", sizeof buf);
		strlcat(buf, relay->authlabel, sizeof buf);
d1774 3
a1776 3
		strlcat(buf, sep, sizeof buf);
		strlcat(buf, "pki_name=", sizeof buf);
		strlcat(buf, relay->pki_name, sizeof buf);
d1780 2
a1781 2
		strlcat(buf, sep, sizeof buf);
		strlcat(buf, "mx", sizeof buf);
d1785 3
a1787 3
		strlcat(buf, sep, sizeof buf);
		strlcat(buf, "backup=", sizeof buf);
		strlcat(buf, relay->backupname, sizeof buf);
d1791 3
a1793 3
		strlcat(buf, sep, sizeof buf);
		strlcat(buf, "sourcetable=", sizeof buf);
		strlcat(buf, relay->sourcetable, sizeof buf);
d1797 3
a1799 3
		strlcat(buf, sep, sizeof buf);
		strlcat(buf, "helotable=", sizeof buf);
		strlcat(buf, relay->helotable, sizeof buf);
d1803 3
a1805 3
		strlcat(buf, sep, sizeof buf);
		strlcat(buf, "heloname=", sizeof buf);
		strlcat(buf, relay->heloname, sizeof buf);
d1808 1
a1808 1
	strlcat(buf, "]", sizeof buf);
d1823 6
a1828 6
#define SHOWSTATUS(f, n) do {						\
		if (r->status & (f)) {					\
			if (flags[0])					\
				strlcat(flags, ",", sizeof(flags));	\
			strlcat(flags, (n), sizeof(flags));		\
		} 							\
d1840 1
a1840 1
		snprintf(dur, sizeof(dur), "%s", duration_to_text(to - t));
d1842 1
a1842 1
		strlcpy(dur, "-", sizeof(dur));
d1844 1
a1844 1
	snprintf(buf, sizeof(buf), "%s refcount=%d ntask=%zu nconn=%zu lastconn=%s timeout=%s wait=%s%s",
d1859 1
a1859 1
			snprintf(dur, sizeof(dur), "%s", duration_to_text(to - t));
d1861 1
a1861 1
			strlcpy(dur, "-", sizeof(dur));
d1865 6
a1870 6
#define SHOWFLAG(f, n) do {						\
		if (c->flags & (f)) {					\
			if (flags[0])					\
				strlcat(flags, ",", sizeof(flags));	\
			strlcat(flags, (n), sizeof(flags));		\
		} 							\
d1891 1
a1891 1
		snprintf(buf, sizeof(buf),
d2014 1
a2014 1
		snprintf(buf, sizeof buf, "%s (%s)",
d2017 1
a2017 1
		snprintf(buf, sizeof buf, "%s", sa_to_text(h->sa));
d2146 1
a2146 1
	snprintf(buf, sizeof buf, "%s", sa_to_text(s->sa));
d2208 1
a2208 1
	snprintf(buf, sizeof buf, "[connector:%s->%s,0x%x]",
d2315 1
a2315 1
	snprintf(buf, sizeof buf, "%s <-> %s",
d2433 2
a2434 2
	strlcpy(hs->name, buf, sizeof hs->name);
	strlcpy(hs->error, error, sizeof hs->error);
@


1.184
log
@code cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.183 2014/02/20 17:42:29 eric Exp $	*/
a58 4
static void mta_imsg(struct mproc *, struct imsg *);
static void mta_shutdown(void);
static void mta_sig_handler(int, short, void *);

d204 1
a204 1
		case IMSG_MTA_TRANSFER:
d226 1
a226 1
				m_create(p_queue, IMSG_DELIVERY_HOLD, 0, 0, -1);
d286 1
a286 1
		case IMSG_QUEUE_MESSAGE_FD:
d295 1
a295 1
		case IMSG_LKA_SECRET:
d304 1
a304 1
		case IMSG_LKA_SOURCE:
d317 1
a317 1
		case IMSG_LKA_HELO:
d321 1
a321 1
		case IMSG_DNS_HOST:
d340 1
a340 1
		case IMSG_DNS_HOST_END:
d363 1
a363 1
		case IMSG_DNS_MX_PREFERENCE:
d381 1
a381 1
		case IMSG_DNS_PTR:
d385 1
a385 1
		case IMSG_LKA_SSL_INIT:
d389 1
a389 1
		case IMSG_LKA_SSL_VERIFY:
d561 2
a562 2
static void
mta_sig_handler(int sig, short event, void *p)
a563 8
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		mta_shutdown();
		break;
	default:
		fatalx("mta_sig_handler: unexpected signal");
	}
d566 2
a567 2
static void
mta_shutdown(void)
a568 39
	log_info("info: mail transfer agent exiting");
	_exit(0);
}

pid_t
mta(void)
{
	pid_t		 pid;
	struct passwd	*pw;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;

	switch (pid = fork()) {
	case -1:
		fatal("mta: cannot fork");
	case 0:
		post_fork(PROC_MTA);
		break;
	default:
		return (pid);
	}

	purge_config(PURGE_EVERYTHING);

	if ((pw = getpwnam(SMTPD_USER)) == NULL)
		fatalx("unknown user " SMTPD_USER);

	if (chroot(PATH_CHROOT) == -1)
		fatal("mta: chroot");
	if (chdir("/") == -1)
		fatal("mta: chdir(\"/\")");

	config_process(PROC_MTA);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("mta: cannot drop privileges");

a582 3
	imsg_callback = mta_imsg;
	event_init();

d589 1
a590 19
	signal_set(&ev_sigint, SIGINT, mta_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, mta_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	config_peer(PROC_PARENT);
	config_peer(PROC_QUEUE);
	config_peer(PROC_LKA);
	config_peer(PROC_CONTROL);
	config_done();

	if (event_dispatch() < 0)
		fatal("event_dispatch");
	mta_shutdown();

	return (0);
}
d694 1
a694 1
				m_create(p_queue, IMSG_DELIVERY_RELEASE, 0, 0, -1);
d701 1
a701 1
			m_create(p_queue, IMSG_DELIVERY_RELEASE, 0, 0, -1);
d719 2
a720 2
		if (e->delivery == IMSG_DELIVERY_OK) {
			m_create(p_queue, IMSG_DELIVERY_OK, 0, 0, -1);
d724 19
a742 6
		} else if (e->delivery == IMSG_DELIVERY_TEMPFAIL)
			queue_tempfail(e->id, e->status, ESC_OTHER_STATUS);
		else if (e->delivery == IMSG_DELIVERY_PERMFAIL)
			queue_permfail(e->id, e->status, ESC_OTHER_STATUS);
		else if (e->delivery == IMSG_DELIVERY_LOOP)
			queue_loop(e->id);
d766 1
a766 1
	if (delivery == IMSG_DELIVERY_OK)
d768 1
a768 1
	else if (delivery == IMSG_DELIVERY_TEMPFAIL)
d770 1
a770 1
	else if (delivery == IMSG_DELIVERY_PERMFAIL)
d772 1
a772 1
	else if (delivery == IMSG_DELIVERY_LOOP)
d813 1
a813 1
			dns_query_host(id, relay->domain->name);
d815 4
a818 1
			dns_query_mx(id, relay->domain->name);
d852 1
a852 1
	m_create(p_lka, IMSG_LKA_SECRET, 0, 0, -1);
d872 7
a878 2
	dns_query_mx_preference(relay->id, relay->domain->name,
		relay->backupname);
d900 1
a900 1
	m_create(p_lka, IMSG_LKA_SOURCE, 0, 0, -1);
d923 1
a923 1
		relay->fail = IMSG_DELIVERY_TEMPFAIL;
d927 1
a927 1
		relay->fail = IMSG_DELIVERY_PERMFAIL;
d931 1
a931 1
		relay->fail = IMSG_DELIVERY_PERMFAIL;
d935 1
a935 1
		relay->fail = IMSG_DELIVERY_TEMPFAIL;
d964 1
a964 1
		relay->fail = IMSG_DELIVERY_TEMPFAIL;
d1018 1
a1018 1
		relay->fail = IMSG_DELIVERY_TEMPFAIL;
d1022 1
a1022 1
		relay->fail = IMSG_DELIVERY_TEMPFAIL;
d1363 1
a1363 1
	if (fail != IMSG_DELIVERY_TEMPFAIL && fail != IMSG_DELIVERY_PERMFAIL)
d1378 1
a1378 1
			if (fail == IMSG_DELIVERY_TEMPFAIL && domain) {
d1405 1
a1405 1
		m_create(p_queue, IMSG_DELIVERY_RELEASE, 0, 0, -1);
d1712 1
a1712 1
		m_create(p_queue, IMSG_DELIVERY_RELEASE, 0, 0, -1);
@


1.183
log
@use strcasecmp() to compare domains.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.182 2014/02/04 15:44:05 eric Exp $	*/
d69 1
a69 1
static void mta_on_preference(struct mta_relay *, int, int);
d376 7
a382 1
			mta_on_preference(relay, dnserror, preference);
d1025 1
a1025 1
mta_on_preference(struct mta_relay *relay, int dnserror, int preference)
d1027 4
a1030 10
	if (dnserror) {
		log_warnx("warn: Couldn't find backup preference for %s",
		    mta_relay_to_text(relay));
		relay->backuppref = INT_MAX;
	}
	else {
		log_debug("debug: mta: ... got preference for %s: %d, %d",
		    mta_relay_to_text(relay), dnserror, preference);
		relay->backuppref = preference;
	}
@


1.182
log
@Add support for DSN and Enhanced Status Code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2456 1
a2456 1
	return (strcmp(a->domain, b->domain));
@


1.181
log
@Allow the admin to pause relaying to a specific domain:
 - smtpctl pause mta from <source> for <domain>
 - smtpctl resume mta from <source> for <domain>
 - smtpctl show mta paused
@
text
@d269 10
d785 7
a791 4
		if (e->delivery == IMSG_DELIVERY_OK)
			queue_ok(e->id);
		else if (e->delivery == IMSG_DELIVERY_TEMPFAIL)
			queue_tempfail(e->id, e->status);
d793 1
a793 1
			queue_permfail(e->id, e->status);
d806 1
@


1.180
log
@internal improvements and cleanups

- get rid of the whole penalty thing for failed envelopes in the mta and scheduler.
- do not disable routes on smtp errors
- try to schedule all types of envelopes on each scheduler frame.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.179 2014/02/04 13:44:41 eric Exp $	*/
d128 13
d146 1
d187 1
d189 1
d197 1
d499 44
d609 1
d1075 2
d1095 6
d1916 1
d2375 73
d2463 1
a2463 2
		hs = calloc(1, sizeof *hs);
		if (hs == NULL)
@


1.179
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.178 2013/12/26 17:25:32 eric Exp $	*/
d607 1
d615 1
d639 1
d641 1
d716 1
a716 1
			queue_tempfail(e->id, e->penalty, e->status);
d763 1
a763 1
mta_delivery_notify(struct mta_envelope *e, uint32_t penalty)
a766 1
	e->penalty = penalty;
d1358 1
a1358 1
			mta_delivery_notify(e, 0);
@


1.178
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.177 2013/12/06 14:12:34 eric Exp $	*/
d1607 3
a1609 3
	key.cert = e->agent.mta.relay.cert;
	if (!key.cert[0])
		key.cert = NULL;
d1636 1
a1636 1
		r->cert = key.cert ? xstrdup(key.cert, "mta: cert") : NULL;
d1691 1
a1691 1
	free(relay->cert);
d1735 1
a1735 1
	if (relay->cert) {
d1737 2
a1738 2
		strlcat(buf, "cert=", sizeof buf);
		strlcat(buf, relay->cert, sizeof buf);
d1914 1
a1914 1
	if (a->cert == NULL && b->cert)
d1916 1
a1916 1
	if (a->cert && b->cert == NULL)
d1918 1
a1918 1
	if (a->cert && ((r = strcmp(a->cert, b->cert))))
@


1.177
log
@fix smtpctl resume route
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1591 1
a1591 1
	bzero(&key, sizeof key);
@


1.176
log
@When a relay fails, let the scheduler update all envelopes in the
holdq as if they tempfailed.
@
text
@d397 15
a411 1
				mta_route_enable(route);
@


1.175
log
@Rework the envelope flushing loops in mta to avoid sending all delivery
notifications in one go to the queue. Simplify code in the process.
@
text
@d1357 1
a1357 1
		m_add_int(p_queue, 0);
@


1.174
log
@do not send the holdq release message if no envelope were held for a relay.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.173 2013/11/29 00:47:04 tedu Exp $	*/
d76 1
d138 2
d539 1
d545 2
d687 34
d725 1
a725 1
	if (delivery == IMSG_DELIVERY_OK) {
d727 1
a727 2
	}
	else if (delivery == IMSG_DELIVERY_TEMPFAIL) {
d729 1
a729 2
	}
	else if (delivery == IMSG_DELIVERY_PERMFAIL) {
d731 1
a731 2
	}
	else if (delivery == IMSG_DELIVERY_LOOP) {
d733 4
d738 4
a741 2
	else
		errx(1, "bad delivery");
d745 1
a745 2
mta_delivery_notify(struct mta_envelope *e, int delivery, const char *status,
    uint32_t penalty)
d747 8
a754 2
	if (delivery == IMSG_DELIVERY_OK) {
		queue_ok(e->id);
a755 19
	else if (delivery == IMSG_DELIVERY_TEMPFAIL) {
		queue_tempfail(e->id, penalty, status);
	}
	else if (delivery == IMSG_DELIVERY_PERMFAIL) {
		queue_permfail(e->id, status);
	}
	else if (delivery == IMSG_DELIVERY_LOOP) {
		queue_loop(e->id);
	}
	else
		errx(1, "bad delivery");
}

void
mta_delivery(struct mta_envelope *e, const char *source, const char *relay,
    int delivery, const char *status, uint32_t penalty)
{
	mta_delivery_log(e, source, relay, delivery, status);
	mta_delivery_notify(e, delivery, status, penalty);
d1308 1
a1308 2
	size_t			 n;
	size_t			 r;
d1321 1
a1321 2
			mta_delivery(e, NULL, relay->domain->name, fail, error, 0);
			
d1340 3
a1342 3
			free(e->dest);
			free(e->rcpt);
			free(e);
@


1.173
log
@fix missing space from line break
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.172 2013/11/28 13:13:56 eric Exp $	*/
d57 1
d209 1
d663 6
a668 4
			m_create(p_queue, IMSG_DELIVERY_RELEASE, 0, 0, -1);
			m_add_id(p_queue, relay->id);
			m_add_int(p_queue, relay->limits->task_release);
			m_close(p_queue);
d670 1
a670 1
		else if (relay->ntask == 0) {
d1327 6
a1332 4
	m_create(p_queue, IMSG_DELIVERY_RELEASE, 0, 0, -1);
	m_add_id(p_queue, relay->id);
	m_add_int(p_queue, 0);
	m_close(p_queue);
d1634 6
a1639 4
	m_create(p_queue, IMSG_DELIVERY_RELEASE, 0, 0, -1);
	m_add_id(p_queue, relay->id);
	m_add_int(p_queue, 0);
	m_close(p_queue);
@


1.172
log
@limit the number of envelopes to recall in the hoststat cache.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d938 2
a939 2
		log_warnx("warn: Failed to get source address"
			    "for %s", mta_relay_to_text(relay));
@


1.171
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d2295 3
@


1.170
log
@add "smtpctl show relays" and "smtpctl show hosts" commands
@
text
@d1554 2
@


1.169
log
@add missing heloname field for relayhost.
differenciate relays with different helotable/heloname.
improve code a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.168 2013/10/29 11:23:58 eric Exp $	*/
d85 1
d167 1
d398 26
d1722 92
@


1.168
log
@Report mta sessions errors on the route rather than on the MX.
If a route has too many of these errors, disable it for a while.
Reset the error counter for a route when it is re-enabled or when
it could establish a connection successfully.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.167 2013/10/28 09:40:07 eric Exp $	*/
d1528 1
a1528 1
	key.flags = e->agent.mta.relay.flags;
d1545 3
d1570 3
d1614 1
d1667 1
a1667 1
	if (relay->flags & RELAY_BACKUP) {
d1679 12
d1729 12
@


1.167
log
@Set lastmxquery when the MX query returns, not when it is issued.
This fixes a potential race when several relays share a single domain,
resulting in temporary failures and unnecessary delays.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.166 2013/10/27 17:47:53 eric Exp $	*/
d45 1
a45 1
#define MAXERROR_PER_HOST	4
d400 1
a400 1
				    "%llu. %s %c%c%c%c nconn=%zu penalty=%d timeout=%s",
d408 1
d418 1
a553 9
/*
 * TODO:
 * Currently all errors are reported on the host itself.  Technically,
 * it should depend on the error, and it would be probably better to report
 * it at the connector level.  But we would need to have persistent routes
 * for that.  Hosts are "naturally" persisted, as they are referenced from
 * the MX list on the domain.
 * Also, we need a timeout on that.
 */
d557 1
a557 4
	route->dst->nerror++;

	if (route->dst->flags & HOST_IGNORE)
		return;
d559 4
a562 4
	if (route->dst->nerror > MAXERROR_PER_HOST) {
		log_info("smtp-out: Too many errors on host %s: ignoring this MX",
		    mta_host_to_text(route->dst));
		route->dst->flags |= HOST_IGNORE;
d577 1
d1151 1
@


1.166
log
@Implement a feedback mechanism which allows the mta to "hold" envelopes
in the scheduler when it has too many tasks for a given relay.  The
envelopes are put on a wait queue, and are not scheduled again until
the mta "releases" some envelopes from that queue.

It prevents from having too many inflight envelopes, which are out of reach
for the admin.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.165 2013/10/27 07:56:25 eric Exp $	*/
d329 1
a723 1
		relay->domain->lastmxquery = time(NULL);
@


1.165
log
@Create the control socket in the parent process to abort early if
another smtpd instance is running.  Close the inherited socket in
every forked process but control.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.164 2013/10/26 12:27:59 eric Exp $	*/
d56 2
d191 22
d633 19
d1161 1
a1161 1
	
d1301 6
d1598 6
@


1.164
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.163 2013/07/19 21:14:52 eric Exp $	*/
d446 1
@


1.163
log
@Many MTA improvements:

- Better transient error handling logic: failing destinations are
  automatically disabled for a while.  When a destination is active
  again, ask the scheduler to retry previous envelopes immediatly.
- More informative error report when all routes fail for a mail.
- Implement a "smtpctl show hoststats" command to get the latest stat
  message per MX domain.
- Implement a "smtpctl show routes" command to show the state the
  currently known routes to remote MXs.
- Implement a "smtpctl resume route" command to re-enable a route that
  has been disabled.
- Do not hardcode limits
- Minor code improvements
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d297 1
a297 1
					log_debug("	%s preference %i",
d375 1
a375 1
				    "%llu. %s %c%c%c%c nconn=%zu penalty=%i timeout=%s",
d838 1
a838 1
		log_debug("debug: mta: ... got preference for %s: %i, %i",
d1134 1
a1134 1
	    "refcount=%i, ntask=%zu, nconnector=%zu, nconn=%zu", 
d1214 1
a1214 1
	log_debug("debug: mta_flush(%s, %i, \"%s\")",
d1218 1
a1218 1
		errx(1, "unexpected delivery status %i", fail);
d1579 1
a1579 1
		snprintf(tmp, sizeof tmp, "port=%i", (int)relay->port);
d1990 1
a1990 1
		log_debug("debug: mta: mta_route_unref(): keeping route %s alive for %llus (penalty %i)",
@


1.162
log
@scheduler improvements:
- implement suspend/resume scheduling for individual envelopes or message,
  with the associated smtpctl commands.
- allow the mta to request immediate scheduling of an envelope.
- on temporary failures a penalty can be given to further delay the next try.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.161 2013/07/19 11:14:08 eric Exp $	*/
d47 8
a54 8
#define MAXCONN_PER_HOST	10
#define MAXCONN_PER_ROUTE	5
#define MAXCONN_PER_SOURCE	50	/* XXX missing */
#define MAXCONN_PER_CONNECTOR	20
#define MAXCONN_PER_RELAY	100

#define CONNECTOR_DELAY_CONNECT	1
#define CONNECTOR_DELAY_LIMIT	5
d65 2
d68 1
d70 2
a71 1
static void mta_recycle(struct mta_connector *);
a72 2
static void mta_relay_schedule(struct mta_relay *, unsigned int);
static void mta_relay_timeout(int, short, void *);
d74 2
a75 1
static struct mta_route *mta_find_route(struct mta_connector *);
a116 1
#if 0
a117 1
#endif
a128 2
static struct tree batches;

d134 24
a162 1
	struct mta_source	*source;
d164 1
d166 1
a168 1
	struct tree		*batch;
d172 1
d174 1
d177 2
d183 1
a183 12
		case IMSG_MTA_BATCH:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_end(&m);
			batch = xmalloc(sizeof *batch, "mta_batch");
			tree_init(batch);
			tree_xset(&batches, reqid, batch);
			log_trace(TRACE_MTA,
			    "mta: batch:%016" PRIx64 " created", reqid);
			return;

		case IMSG_MTA_BATCH_ADD:
a184 1
			m_get_id(&m, &reqid);
a188 1
			batch = tree_xget(&batches, reqid);
d190 5
a194 3
			if ((task = tree_get(batch, relay->id)) == NULL) {
				log_trace(TRACE_MTA, "mta: new task for %s",
				    mta_relay_to_text(relay));
d198 2
a199 1
				tree_xset(batch, relay->id, task);
d207 2
a208 10
			} else
				mta_relay_unref(relay); /* from here */

			/*
			 * Technically, we could handle that by adding a msg
			 * level, but the batch sent by the scheduler should
			 * be valid.
			 */
			if (task->msgid != evpid_to_msgid(evp.id))
				errx(1, "msgid mismatch in batch");
d221 1
a221 1
			/* XXX honour relay->maxrcpt */
a222 1
			stat_increment("mta.envelope", 1);
a224 1
			return;
d226 4
a229 19
		case IMSG_MTA_BATCH_END:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_end(&m);
			batch = tree_xpop(&batches, reqid);
			log_trace(TRACE_MTA, "mta: batch:%016" PRIx64 " closed",
			    reqid);
			/* For all tasks, queue them on its relay */
			while (tree_poproot(batch, &reqid, (void**)&task)) {
				if (reqid != task->relay->id)
					errx(1, "relay id mismatch!");
				relay = task->relay;
				relay->ntask += 1;
				TAILQ_INSERT_TAIL(&relay->tasks, task, entry);
				stat_increment("mta.task", 1);
				mta_drain(relay);
				mta_relay_unref(relay); /* from BATCH_APPEND */
			}
			free(batch);
d247 1
a247 11
			if (secret[0])
				relay->secret = strdup(secret);
			if (relay->secret == NULL) {
				log_warnx("warn: Failed to retrieve secret "
				    "for %s", mta_relay_to_text(relay));
				relay->fail = IMSG_DELIVERY_TEMPFAIL;
				relay->failstr = "Could not retrieve secret";
			}
			relay->status &= ~RELAY_WAIT_SECRET;
			mta_drain(relay);
			mta_relay_unref(relay); /* from mta_query_secret() */
d254 1
a254 4

			relay = tree_xpop(&wait_source, reqid);
			relay->status &= ~RELAY_WAIT_SOURCE;
			if (status == LKA_OK) {
a255 8
				source = mta_source((struct sockaddr *)&ss);
				mta_on_source(relay, source);
				mta_source_unref(source);
			}
			else {
				log_warnx("warn: Failed to get source address"
				    "for %s", mta_relay_to_text(relay));
			}
d258 3
a260 2
			mta_drain(relay);
			mta_relay_unref(relay); /* from mta_query_source() */
d312 4
d317 1
a317 16
			if (dnserror) {
				log_debug("debug: couldn't find backup "
				    "preference for %s",
				    mta_relay_to_text(relay));
				relay->backuppref = INT_MAX;
			} else {
				m_get_int(&m, &relay->backuppref);
				log_debug("debug: found backup preference %i "
				    "for %s",
				    relay->backuppref,
				    mta_relay_to_text(relay));
			}
			m_end(&m);
			relay->status &= ~RELAY_WAIT_PREFERENCE;
			mta_drain(relay);
			mta_relay_unref(relay); /* from mta_query_preference() */
d352 59
a473 1
	tree_init(&batches);
d478 1
d483 5
d515 1
d520 4
a523 4
	if (!(c->flags & CONNECTOR_SOURCE_ERROR))
		log_info("smtp-out: Error on connector %s: %s",
		    mta_connector_to_text(c), e);
	c->flags |= CONNECTOR_SOURCE_ERROR;
d555 5
a559 1
	log_debug("debug: mta: route ok %s", mta_route_to_text(route));
d561 1
a561 1
	route->dst->nerror = 0;
d564 7
a570 1
	c->flags &= ~CONNECTOR_SOURCE_ERROR;
d578 2
a579 1
	log_debug("debug: mta: route collect %s", mta_route_to_text(route));
d582 1
d586 5
d593 2
a595 11

	c->nconn -= 1;

	if (c->flags & CONNECTOR_LIMIT) {
		log_debug("debug: mta; resetting limit flags on connector %s",
		    mta_connector_to_text(c));
		c->flags &= ~CONNECTOR_LIMIT;
	}

	mta_recycle(c);
	mta_drain(relay);
d614 1
a614 1
mta_delivery(struct mta_envelope *e, const char *source, const char *relay,
a618 1
		queue_ok(e->id);
a621 1
		queue_tempfail(e->id, 0, status);
d625 19
a646 1
		mta_log(e, "PermFail", source, relay, "Loop detected");
d653 8
d669 2
a670 1
	log_debug("debug: mta_query_mx(%s)", relay->domain->name);
d686 16
d707 2
a708 1
	log_debug("debug: mta_query_secret(%s)", mta_relay_to_text(relay));
d728 2
a729 1
	log_debug("debug: mta_query_preference(%s)", mta_relay_to_text(relay));
d741 14
a754 1
	log_debug("debug: mta_query_source(%s)", mta_relay_to_text(relay));
d772 1
a772 1
	log_debug("debug: mta_on_mx(%p, %s, %s)",
d809 40
d851 57
a907 1
	mta_connector(relay, source);
d914 3
d918 1
a918 1
	log_debug("debug: mta_connect() for %s", mta_connector_to_text(c));
d920 80
a999 1
	route = mta_find_route(c);
d1001 21
a1021 5
		mta_recycle(c);
		if (c->queue == &c->relay->c_limit)
			c->clearlimit = time(NULL) + CONNECTOR_DELAY_LIMIT;
		if (c->queue == &c->relay->c_ready)
			fatalx("connector with no route ended up in ready list");
d1025 3
a1029 1
	c->nextconn = c->lastconn + CONNECTOR_DELAY_CONNECT;
d1033 2
d1042 2
a1043 1
	mta_recycle(c);
d1045 1
a1045 2
	mta_relay_ref(c->relay);
	mta_session(c->relay, route);	/* this never fails synchronously */
d1049 1
a1049 1
mta_recycle(struct mta_connector *c)
d1051 4
a1054 1
	TAILQ_REMOVE(c->queue, c, lst_entry);
d1056 6
a1061 4
	if (c->flags & CONNECTOR_ERROR) {
		log_debug("debug: mta: putting %s on error queue",
		    mta_connector_to_text(c));
		c->queue = &c->relay->c_error;
d1063 5
a1067 4
	else if (c->flags & CONNECTOR_LIMIT) {
		log_debug("debug: mta: putting %s on limit queue",
		    mta_connector_to_text(c));
		c->queue = &c->relay->c_limit;
d1069 4
a1072 4
	else if (c->nextconn > time(NULL)) {
		log_debug("debug: mta: putting %s on delay queue",
		    mta_connector_to_text(c));
		c->queue = &c->relay->c_delay;
d1074 5
a1078 4
	else {
		log_debug("debug: mta: putting %s on ready queue",
		    mta_connector_to_text(c));
		c->queue = &c->relay->c_ready;
a1079 2

	TAILQ_INSERT_TAIL(c->queue, c, lst_entry);
d1083 1
a1083 1
mta_relay_timeout(int fd, short ev, void *arg)
d1085 1
a1085 3
	struct mta_relay	*r = arg;
	struct mta_connector	*c;
	time_t			 t;
d1087 8
a1094 1
	log_debug("debug: mta: timeout for %s", mta_relay_to_text(r));
d1096 2
a1097 1
	t = time(NULL);
d1099 7
a1105 24
	/*
	 * Clear the limit flags on all connectors.
	 */
	while ((c = TAILQ_FIRST(&r->c_limit))) {
		/* This requires that the list is always sorted */
		if (c->clearlimit > t)
			break;
		log_debug("debug: mta: clearing limits on %s",
		    mta_connector_to_text(c));
		c->flags &= ~CONNECTOR_LIMIT;
		mta_recycle(c);
	}

	while ((c = TAILQ_FIRST(&r->c_delay))) {
		/* This requires that the list is always sorted */
		if (c->nextconn > t)
			break;
		log_debug("debug: mta: delay expired for %s",
		    mta_connector_to_text(c));
		mta_recycle(c);
	}

	mta_drain(r);
	mta_relay_unref(r); /* from mta_relay_schedule() */
d1109 17
a1125 13
mta_relay_schedule(struct mta_relay *r, unsigned int delay)
{
	struct timeval	tv;

	if (evtimer_pending(&r->ev, &tv))
		return;

	log_debug("debug: mta: adding relay timeout: %u", delay);

	tv.tv_sec = delay;
	tv.tv_usec = 0;
	evtimer_add(&r->ev, &tv);
	mta_relay_ref(r);
a1130 2
	struct mta_connector	*c;
	struct mta_source	*s;
d1136 1
a1136 1
	    r->refcount, r->ntask, r->nconnector, r->nconn);
d1166 4
d1174 1
a1174 1
			strlcat(buf, "MX ", sizeof buf);
d1176 1
a1176 1
			strlcat(buf, "preference ", sizeof buf);
d1178 1
a1178 1
			strlcat(buf, "secret ", sizeof buf);
d1180 4
a1183 2
			strlcat(buf, "source ", sizeof buf);
		log_debug("debug: mta: %s waiting for %s",
d1189 1
a1189 5
	 * Start new connections if possible.
	 * XXX find a better heuristic for the good number of connections
	 * depending on the number of tasks and other factors.  We might
	 * want to try more than the number of task, to have a chance to
	 * hit a mx faster if the first ones timeout.
d1191 9
a1199 70
	while (r->nconn < r->ntask) {
		log_debug("debug: mta: trying to create new connection: "
		    "refcount=%i, ntask=%zu, nconnector=%zu, nconn=%zu", 
		    r->refcount, r->ntask, r->nconnector, r->nconn);

		/* Check the per-relay connection limit */
		if (r->nconn >= MAXCONN_PER_RELAY) {
			log_debug("debug: mta: hit connection limit on %s",
			    mta_relay_to_text(r));
			return;
		}

		/* Use the first connector if ready */
		c = TAILQ_FIRST(&r->c_ready);
		if (c) {
			log_debug("debug: mta: using connector %s",
			    mta_connector_to_text(c));
			r->sourceloop = 0;
			mta_connect(c);
			continue;
		}

		/* No new connectors */
		if (r->sourceloop > r->nconnector) {
			log_debug("debug: mta: no new connector available");

			if (TAILQ_FIRST(&r->c_delay)) {
				mta_relay_schedule(r, 1);
				log_debug(
				    "debug: mta: waiting for relay timeout");
				return;
			}

			if (TAILQ_FIRST(&r->c_limit)) {
				mta_relay_schedule(r, 5);
				log_debug(
				    "debug: mta: waiting for relay timeout");
				return;
			}

			log_debug("debug: mta: failing...");
			/*
			 * All sources have been tried and no connectors can
			 * be used.
			 */
			if (r->nconnector == 0) {
				r->fail = IMSG_DELIVERY_TEMPFAIL;
				r->failstr = "No source address";
			}
			else {
				r->fail = IMSG_DELIVERY_TEMPFAIL;
				r->failstr = "No MX could be reached";
			}
			mta_flush(r, r->fail, r->failstr);
			return;
		}

		r->sourceloop++;
		log_debug("debug: mta: need new connector (attempt %zu)",
			r->sourceloop);
		if (r->sourcetable) {
			log_debug("debug: mta: querying source %s",
			    r->sourcetable);
			mta_query_source(r);
			return;
		}
		log_debug("debug: mta: using default source");
		s = mta_source(NULL);
		mta_on_source(r, s);
		mta_source_unref(s);
d1208 3
d1212 1
d1225 20
a1244 1
			mta_delivery(e, NULL, relay->domain->name, fail, error);
d1263 2
a1264 1
mta_find_route(struct mta_connector *c)
d1267 1
d1270 5
a1274 1
	int			 family_mismatch, seen;
d1276 1
d1279 1
a1284 7
	if (c->nconn >= MAXCONN_PER_CONNECTOR) {
		log_debug("debug: mta: hit limit on connector %s",
		    mta_connector_to_text(c));
		c->flags |= CONNECTOR_LIMIT_SOURCE;
		return (NULL);
	}

d1299 2
a1300 1
			 * preference level but they reached their limit.
d1302 1
a1302 1
			if (limit_host || limit_route)
d1326 5
a1330 2
		if (c->source->sa &&
		    c->source->sa->sa_family != mx->host->sa->sa_family) {
d1335 3
a1337 1
		if (mx->host->nconn >= MAXCONN_PER_HOST) {
d1342 9
d1353 11
a1363 1
		if (route->nconn >= MAXCONN_PER_ROUTE) {
d1369 28
d1399 2
d1408 2
d1415 1
d1417 1
a1417 1
		log_info("smtp-out: No reachable MX for connector %s",
d1419 1
a1419 1
		c->flags |= CONNECTOR_MX_ERROR;
d1422 2
a1423 3
		log_debug("debug: mta: hit route limit on connector %s",
		    mta_connector_to_text(c));
		c->flags |= CONNECTOR_LIMIT_ROUTE;
d1426 9
a1434 1
		log_debug("debug: mta: hit host limit on connector %s",
d1436 1
a1436 1
		c->flags |= CONNECTOR_LIMIT_HOST;
d1438 2
a1439 2
	else if (family_mismatch) {
		log_info("smtp-out: Address family mismatch on connector %s",
d1441 4
a1444 1
		c->flags |= CONNECTOR_FAMILY_ERROR;
d1454 3
a1456 20
	char session[SMTPD_MAXLINESIZE];
	char rcpt[SMTPD_MAXLINESIZE];
	char src[SMTPD_MAXLINESIZE];

	session[0] = '\0';
	if (evp->session)
		snprintf(session, sizeof session, "session=%016"PRIx64", ",
		    evp->session);

	rcpt[0] = '\0';
	if (evp->rcpt)
		snprintf(rcpt, sizeof rcpt, "rcpt=<%s>, ", evp->rcpt);

	src[0] = '\0';
	if (source)
		snprintf(src, sizeof src, "source=%s, ", source);


	log_info("relay: %s for %016" PRIx64 ": %sfrom=<%s>, to=<%s>, "
	    "%s%srelay=%s, delay=%s, stat=%s",
d1459 1
a1459 1
	    session,
d1462 2
a1463 2
	    src,
	    rcpt,
a1506 4
		TAILQ_INIT(&r->c_ready);
		TAILQ_INIT(&r->c_delay);
		TAILQ_INIT(&r->c_limit);
		TAILQ_INIT(&r->c_error);
a1525 2
		evtimer_set(&r->ev, mta_relay_timeout, r);
		log_trace(TRACE_MTA, "mta: new %s", mta_relay_to_text(r));
a1528 1
		log_trace(TRACE_MTA, "mta: reusing %s", mta_relay_to_text(r));
a1562 3
	if (evtimer_pending(&relay->ev, NULL))
		evtimer_del(&relay->ev);

d1887 1
a1888 2
		c->queue = &relay->c_ready;
		TAILQ_INSERT_HEAD(c->queue, c, lst_entry);
a1889 1
		relay->nconnector++;
d1891 1
a1891 2
		log_debug("debug: mta: new connector %s",
		    mta_connector_to_text(c));
d1900 9
a1908 3
	c->relay->nconnector--;
	TAILQ_REMOVE(c->queue, c, lst_entry);
	mta_source_unref(c->source);
d1910 1
d1919 1
a1919 1
	snprintf(buf, sizeof buf, "%s->%s",
d1921 2
a1922 1
	    mta_relay_to_text(c->relay));
d1930 1
d1940 2
d1947 7
a1958 1
#if 0
a1963 1
#endif
d1968 3
d1974 40
d2050 91
@


1.161
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.160 2013/07/19 07:49:08 eric Exp $	*/
d589 1
a589 1
		queue_tempfail(e->id, status);
@


1.160
log
@Remove useless sc_pid from struct smtpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.159 2013/06/04 08:16:10 eric Exp $	*/
d433 4
a436 2
	pw = env->sc_pw;
	if (chroot(pw->pw_dir) == -1)
@


1.159
log
@fix use-after-free in debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.158 2013/06/03 16:04:03 eric Exp $	*/
a425 1
		env->sc_pid = getpid();
@


1.158
log
@plug a couple of memleaks
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1258 3
a1267 3

	while ((tree_poproot(&relay->connectors, NULL, (void**)&c)))
		mta_connector_free(c);
@


1.157
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.155 2013/02/18 13:37:14 eric Exp $	*/
d1257 8
a1264 6
	if (relay->cert)
		free(relay->cert);
	if (relay->authtable)
		free(relay->authtable);
	if (relay->authlabel)
		free(relay->authlabel);
d1424 1
d1500 1
d1555 1
d1615 1
d1670 1
@


1.156
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@a24 1
#include <sys/param.h>
d74 1
a74 1
    const char *);
d579 2
a580 2
mta_delivery(struct mta_envelope *e, const char *relay, int delivery,
    const char *status)
d583 1
a583 1
		mta_log(e, "Ok", relay, status);
d587 1
a587 1
		mta_log(e, "TempFail", relay, status);
d591 1
a591 1
		mta_log(e, "PermFail", relay, status);
d595 1
a595 1
		mta_log(e, "PermFail", relay, "Loop detected");
d636 1
a636 1
	m_create(p_lka, IMSG_LKA_SECRET, 0, 0, -1, 128);
d665 1
a665 1
	m_create(p_lka, IMSG_LKA_SOURCE, 0, 0, -1, 64);
a981 1
	const char		*pfx;
d987 1
a987 5
	if (fail == IMSG_DELIVERY_TEMPFAIL)
		pfx = "TempFail";
	else if (fail == IMSG_DELIVERY_PERMFAIL)
		pfx = "PermFail";
	else
d995 1
a995 1
			mta_delivery(e, relay->domain->name, fail, error);
a1112 5
	else if (family_mismatch) {
		log_info("smtp-out: Address family mismatch on connector %s",
		    mta_connector_to_text(c));
		c->flags |= CONNECTOR_FAMILY_ERROR;
	}
d1123 5
d1133 2
a1134 2
mta_log(const struct mta_envelope *evp, const char *prefix, const char *relay,
    const char *status)
d1136 1
d1138 6
d1149 7
a1155 2
	log_info("relay: %s for %016" PRIx64 ": from=<%s>, to=<%s>, "
	    "%srelay=%s, delay=%s, stat=%s",
d1158 1
d1161 1
@


1.155
log
@missing comma in log message

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.154 2013/02/08 13:29:09 eric Exp $	*/
d151 1
a151 1
	char			 buf[MAX_LINE_SIZE];
d1142 1
a1142 1
	char rcpt[MAX_LINE_SIZE];
@


1.154
log
@retain the MX address order as sent by the lka for MXs with the same
preference.

issue spotted by todd@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.153 2013/02/05 11:45:18 gilles Exp $	*/
d1149 1
a1149 1
	    "%srelay=%s delay=%s, stat=%s",
@


1.153
log
@- handle getaddrinfo() error as LKA_TEMPFAIL
- handle getsockname() error in smtp_connected()
- accept '/' as part of user-part, expand to ':' as done by qmail
- fix wrong check in mda leading to bogus Return-Path header
- fix aliases parsing when there's a white space between key and separator
- some cosmethic cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.151 2013/01/28 16:40:22 eric Exp $	*/
d307 1
a307 1
				if (imx->preference >= mx->preference) {
@


1.152
log
@Spelling fixes: retreive -> retrieve. ok gilles
@
text
@a892 2
		if (r->status & RELAY_WAIT_HELO)
			strlcat(buf, "helo ", sizeof buf);
@


1.151
log
@use a stripped-down mta_envelope structure in the mta process.
reduces memory footprint by a great deal when relaying lots of messages.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.149 2013/01/26 09:37:23 gilles Exp $	*/
d259 1
a259 1
				log_warnx("warn: Failed to retreive secret "
d262 1
a262 1
				relay->failstr = "Could not retreive secret";
@


1.150
log
@- introduce 'smtpctl trace lookup' to trace lookup process
- improve logging of the transfer process

trace by me, logging by eric
@
text
@d74 1
a74 1
static void mta_log(const struct envelope *, const char *, const char *,
d144 1
d147 1
a147 1
	struct envelope		*e;
d151 1
a168 1
			e = xmalloc(sizeof(*e), "mta:envelope");
d171 1
a171 1
			m_get_envelope(&m, e);
d174 1
a174 1
			relay = mta_relay(e);
d184 7
a190 2
				task->msgid = evpid_to_msgid(e->id);
				task->sender = e->sender;
d199 1
a199 1
			if (task->msgid != evpid_to_msgid(e->id))
d202 11
d217 1
a217 2
			    " for <%s@@%s>",
			    e->id, e->dest.user, e->dest.domain);
d580 1
a580 1
mta_delivery(struct envelope *e, const char *relay, int delivery,
d983 4
a986 4
	struct envelope	*e;
	struct mta_task	*task;
	const char	*pfx;
	size_t		 n;
d1004 2
d1009 1
d1141 1
a1141 1
mta_log(const struct envelope *evp, const char *prefix, const char *relay,
d1147 2
a1148 4
	if (strcmp(evp->rcpt.user, evp->dest.user) ||
	    strcmp(evp->rcpt.domain, evp->dest.domain))
		snprintf(rcpt, sizeof rcpt, "rcpt=<%s@@%s>, ",
		    evp->rcpt.user, evp->rcpt.domain);
d1150 1
a1150 1
	log_info("relay: %s for %016" PRIx64 ": from=<%s@@%s>, to=<%s@@%s>, "
d1153 3
a1155 2
	    evp->id, evp->sender.user, evp->sender.domain,
	    evp->dest.user, evp->dest.domain,
@


1.149
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.148 2012/11/12 14:58:53 eric Exp $	*/
d494 1
a494 1
mta_route_error(struct mta_relay *relay, struct mta_route *route, const char *e)
a499 3

	log_info("smtp-out: Error on route %s: %s",
	    mta_route_to_text(route), e);
@


1.148
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.147 2012/10/11 21:52:59 gilles Exp $	*/
d5 1
a5 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d46 1
a46 3
#define MTA_MAXCONN	10	/* connections per route */
#define MTA_MAXMAIL	100	/* mails per session     */
#define MTA_MAXRCPT	1000	/* rcpt per mail         */
d48 5
a52 4
struct mta_batch2 {
	uint64_t	id;
	struct tree	tasks;		/* map route to task */
};
d54 2
a55 1
SPLAY_HEAD(mta_route_tree, mta_route);
d57 1
a57 1
static void mta_imsg(struct imsgev *, struct imsg *);
d61 51
a111 5
static struct mta_route *mta_route_for(struct envelope *);
static void mta_route_drain(struct mta_route *);
static void mta_route_free(struct mta_route *);
static void mta_envelope_done(struct mta_task *, struct envelope *, const char *);
static int mta_route_cmp(struct mta_route *, struct mta_route *);
d113 8
d123 12
a134 2
static struct mta_route_tree routes = SPLAY_INITIALIZER(&routes);
static struct tree batches = SPLAY_INITIALIZER(&batches);
d137 1
a137 1
mta_imsg(struct imsgev *iev, struct imsg *imsg)
d139 1
a139 2
	struct mta_route	*route;
	struct mta_batch2	*batch;
d141 5
d147 4
a150 2
	struct ssl		*ssl;
	uint64_t		 id;
d152 1
a152 1
	if (iev->proc == PROC_QUEUE) {
d155 4
a158 2
		case IMSG_BATCH_CREATE:
			id = *(uint64_t*)(imsg->data);
d160 2
a161 3
			batch->id = id;
			tree_init(&batch->tasks);
			tree_xset(&batches, batch->id, batch);
d163 1
a163 1
			    "mta: batch:%016" PRIx64 " created", batch->id);
d166 6
a171 4
		case IMSG_BATCH_APPEND:
			e = xmemdup(imsg->data, sizeof *e, "mta:envelope");
			route = mta_route_for(e);
			batch = tree_xget(&batches, e->batch_id);
d173 4
a176 1
			if ((task = tree_get(&batch->tasks, route->id)) == NULL) {
d178 1
a178 1
				    mta_route_to_text(route));
d181 2
a182 2
				task->route = route;
				tree_xset(&batch->tasks, route->id, task);
d185 2
a186 2
				route->refcount += 1;
			}
d188 2
a189 1
			/* Technically, we could handle that by adding a msg
d196 1
a196 1
			/* XXX honour route->maxrcpt */
d199 2
a200 1
			log_debug("debug: mta: received evp:%016" PRIx64 " for <%s@@%s>",
d204 5
a208 3
		case IMSG_BATCH_CLOSE:
			id = *(uint64_t*)(imsg->data);
			batch = tree_xpop(&batches, id);
d210 8
a217 8
			    batch->id);
			/* for all tasks, queue them on there route */
			while (tree_poproot(&batch->tasks, &id, (void**)&task)) {
				if (id != task->route->id)
					errx(1, "route id mismatch!");
				task->route->refcount -= 1;
				task->route->ntask += 1;
				TAILQ_INSERT_TAIL(&task->route->tasks, task, entry);
d219 2
a220 1
				mta_route_drain(task->route);
d226 1
a226 1
			mta_session_imsg(iev, imsg);
d231 1
a231 1
	if (iev->proc == PROC_LKA) {
d233 1
d235 45
d281 18
d300 44
d345 1
a345 1
			mta_session_imsg(iev, imsg);
a346 2
		}
	}
d348 2
a349 7
	if (iev->proc == PROC_PARENT) {
		switch (imsg->hdr.type) {
		case IMSG_CONF_START:
			if (env->sc_flags & SMTPD_CONFIGURING)
				return;
			env->sc_flags |= SMTPD_CONFIGURING;
			env->sc_ssl = xcalloc(1, sizeof *env->sc_ssl, "mta:sc_ssl");
d352 2
a353 9
		case IMSG_CONF_SSL:
			if (!(env->sc_flags & SMTPD_CONFIGURING))
				return;
			ssl = xmemdup(imsg->data, sizeof *ssl, "mta:ssl");
			ssl->ssl_cert = xstrdup((char*)imsg->data + sizeof *ssl,
			    "mta:ssl_cert");
			ssl->ssl_key = xstrdup((char*)imsg->data +
			    sizeof *ssl + ssl->ssl_cert_len, "mta:ssl_key");
			SPLAY_INSERT(ssltree, env->sc_ssl, ssl);
d355 2
d358 7
a364 4
		case IMSG_CONF_END:
			if (!(env->sc_flags & SMTPD_CONFIGURING))
				return;
			env->sc_flags &= ~SMTPD_CONFIGURING;
d367 5
a371 2
		case IMSG_CTL_VERBOSE:
			log_verbose(*(int *)imsg->data);
a402 1

a406 7
	struct peer peers[] = {
		{ PROC_PARENT,	imsg_dispatch },
		{ PROC_QUEUE,	imsg_dispatch },
		{ PROC_LKA,	imsg_dispatch },
		{ PROC_CONTROL,	imsg_dispatch }
	};

d411 1
d425 1
a425 2
	smtpd_process = PROC_MTA;
	setproctitle("%s", env->sc_title[smtpd_process]);
d432 12
d454 5
a458 2
	config_pipes(peers, nitems(peers));
	config_peers(peers, nitems(peers));
d467 102
a568 2
const char *
mta_response_status(const char *r)
d570 15
a584 8
	switch (r[0]) {
	case '2':
		return "Sent";
	case '4':
	case '5':
		return "RemoteError";
	default:
		return "LocalError";
d586 2
d590 2
a591 2
int
mta_response_delivery(const char *r)
d593 15
a607 10
	switch (r[0]) {
	case '2':
		return IMSG_QUEUE_DELIVERY_OK;
	case '5':
	case '6':
		if (r[1] == '4' && r[2] == '6')
			return IMSG_QUEUE_DELIVERY_LOOP;
		return IMSG_QUEUE_DELIVERY_PERMFAIL;
	default:
		return IMSG_QUEUE_DELIVERY_TEMPFAIL;
d609 52
d663 2
a664 2
const char *
mta_response_prefix(const char *r)
d666 25
a690 8
	switch (r[0]) {
	case '2':
		return "Ok";
	case '5':
	case '6':
		if (r[1] == '4' && r[2] == '6')
			return "Loop";
		return "PermFail";
d692 2
a693 1
		return "TempFail";
d695 8
d705 2
a706 2
const char *
mta_response_text(const char *r)
d708 1
a708 1
	return (r + 4);
d711 2
a712 2
void
mta_route_error(struct mta_route *route, const char *error)
d714 31
a744 3
	route->nfail += 1;
	strlcpy(route->errorline, error, sizeof route->errorline);
	log_warnx("warn: mta: %s error: %s", mta_route_to_text(route), error);
d747 2
a748 2
void
mta_route_ok(struct mta_route *route)
d750 24
a773 2
	log_debug("debug: mta: %s ready", mta_route_to_text(route));
	route->nfail = 0;
d776 2
a777 2
void
mta_route_collect(struct mta_route *route)
d779 20
a798 1
	route->nsession -= 1;
d800 11
a810 1
	mta_route_drain(route);
d813 2
a814 2
const char *
mta_route_to_text(struct mta_route *route)
d816 6
a821 3
	static char	 buf[1024];
	char		 tmp[32];
	const char	*sep = "";
d823 5
a827 1
	snprintf(buf, sizeof buf, "route:%s[", route->hostname);
d829 26
a854 4
	if (route->port) {
		snprintf(tmp, sizeof tmp, "port=%i", (int)route->port);
		strlcat(buf, tmp, sizeof buf);
		sep = ",";
d857 28
a884 4
	if (route->flags & ROUTE_STARTTLS) {
		strlcat(buf, sep, sizeof buf);
		sep = ",";
		strlcat(buf, "starttls", sizeof buf);
d887 77
a963 4
	if (route->flags & ROUTE_SMTPS) {
		strlcat(buf, sep, sizeof buf);
		sep = ",";
		strlcat(buf, "smtps", sizeof buf);
d965 1
d967 28
a994 5
	if (route->flags & ROUTE_AUTH) {
		strlcat(buf, sep, sizeof buf);
		sep = ",";
		strlcat(buf, "auth=", sizeof buf);
		strlcat(buf, route->auth, sizeof buf);
d997 28
a1024 5
	if (route->cert) {
		strlcat(buf, sep, sizeof buf);
		sep = ",";
		strlcat(buf, "cert=", sizeof buf);
		strlcat(buf, route->cert, sizeof buf);
d1027 68
a1094 4
	if (route->flags & ROUTE_MX) {
		strlcat(buf, sep, sizeof buf);
		sep = ",";
		strlcat(buf, "mx", sizeof buf);
d1097 22
a1118 4
	if (route->flags & ROUTE_BACKUP) {
		strlcat(buf, sep, sizeof buf);
		strlcat(buf, "backup=", sizeof buf);
		strlcat(buf, route->backupname, sizeof buf);
d1121 8
a1128 1
	strlcat(buf, "]", sizeof buf);
d1130 15
a1144 1
	return (buf);
d1147 2
a1148 2
static struct mta_route *
mta_route_for(struct envelope *e)
d1150 1
a1150 2
	struct ssl		ssl;
	struct mta_route	key, *route;
d1154 2
a1155 3
	key.flags = e->agent.mta.relay.flags;
	if (e->agent.mta.relay.flags & ROUTE_BACKUP) {
		key.hostname = e->dest.domain;
d1158 7
a1164 4
		key.hostname = e->agent.mta.relay.hostname;
		key.flags |= ROUTE_MX;
	} else
		key.hostname = e->dest.domain;
d1169 24
a1192 11
	key.auth = e->agent.mta.relay.authmap;
	if (!key.auth[0])
		key.auth = NULL;

	if ((route = SPLAY_FIND(mta_route_tree, &routes, &key)) == NULL) {
		route = xcalloc(1, sizeof *route, "mta_route");
		TAILQ_INIT(&route->tasks);
		route->id = generate_uid();
		route->flags = key.flags;
		route->hostname = xstrdup(key.hostname, "mta: hostname");
		route->backupname = key.backupname ?
d1194 17
a1210 15
		route->port = key.port;
		route->cert = key.cert ? xstrdup(key.cert, "mta: cert") : NULL;
		route->auth = key.auth ? xstrdup(key.auth, "mta: auth") : NULL;
		if (route->cert) {
			strlcpy(ssl.ssl_name, route->cert, sizeof(ssl.ssl_name));
			route->ssl = SPLAY_FIND(ssltree, env->sc_ssl, &ssl);
		}
		SPLAY_INSERT(mta_route_tree, &routes, route);

		route->maxconn = MTA_MAXCONN;
		route->maxmail = MTA_MAXMAIL;
		route->maxrcpt = MTA_MAXRCPT;

		log_trace(TRACE_MTA, "mta: new %s", mta_route_to_text(route));
		stat_increment("mta.route", 1);
d1212 2
a1213 1
		log_trace(TRACE_MTA, "mta: reusing %s", mta_route_to_text(route));
d1216 2
a1217 1
	return (route);
d1221 1
a1221 1
mta_route_free(struct mta_route *route)
d1223 1
a1223 8
	log_trace(TRACE_MTA, "mta: freeing %s", mta_route_to_text(route));
	SPLAY_REMOVE(mta_route_tree, &routes, route);
	free(route->hostname);
	if (route->cert)
		free(route->cert);
	if (route->auth)
		free(route->auth);
	free(route);
d1227 1
a1227 1
mta_route_drain(struct mta_route *route)
d1229 31
a1259 2
	struct mta_task		*task;
	struct envelope		*e;
d1261 1
a1261 3
	log_debug("debug: mta: draining %s (tasks=%i, refs=%i, sessions=%i)",
	    mta_route_to_text(route),
	    route->ntask, route->refcount, route->nsession);
d1263 9
a1271 4
	if (route->ntask == 0 && route->refcount == 0 && route->nsession == 0) {
		mta_route_free(route);
		stat_decrement("mta.route", 1);
		return;
d1274 3
a1276 3
	if (route->ntask == 0) {
		log_debug("debug: mta: no task for %s", mta_route_to_text(route));
		return;
d1279 7
a1285 6
	if (route->nfail > 3) {
		/* Three connection errors in a row: consider that the route
		 * has a problem.
		 */
		log_debug("debug: mta: too many failures on %s",
		    mta_route_to_text(route));
d1287 4
a1290 11
		while ((task = TAILQ_FIRST(&route->tasks))) {
			TAILQ_REMOVE(&route->tasks, task, entry);
			route->ntask -= 1;
			while((e = TAILQ_FIRST(&task->envelopes)))
				mta_envelope_done(task, e, route->errorline);
			free(task);
			stat_decrement("mta.task", 1);
		}
		route->nfail = 0;
		/* XXX maybe close the route for while */
		return;
d1293 3
a1295 10
	/* make sure there are one session for each task */
	while (route->nsession < route->ntask) {
		/* if we have reached the max number of session, wait */
		if (route->nsession >= route->maxconn) {
			log_debug("debug: mta: max conn reached for %s",
			    mta_route_to_text(route));
			return;
		}
		route->nsession += 1;
		mta_session(route);
a1296 1
}
d1298 5
a1302 4
static void
mta_envelope_done(struct mta_task *task, struct envelope *e, const char *status)
{
	char	 relay[MAX_LINE_SIZE];
d1304 5
a1308 1
	envelope_set_errormsg(e, "%s", status);
d1310 1
a1310 1
	snprintf(relay, sizeof relay, "relay=%s, ", task->route->hostname);
d1312 1
a1312 6
	log_envelope(e, relay, mta_response_prefix(e->errorline), e->errorline);
	imsg_compose_event(env->sc_ievs[PROC_QUEUE],
	    mta_response_delivery(e->errorline), 0, 0, -1, e, sizeof(*e));
	TAILQ_REMOVE(&task->envelopes, e, entry);
	free(e);
	stat_decrement("mta.envelope", 1);
d1316 1
a1316 1
mta_route_cmp(struct mta_route *a, struct mta_route *b)
d1320 5
d1335 1
a1335 1
	if (a->auth == NULL && b->auth)
d1337 1
a1337 1
	if (a->auth && b->auth == NULL)
d1339 9
a1347 1
	if (a->auth && ((r = strcmp(a->auth, b->auth))))
d1360 310
a1669 2
	if ((r = strcmp(a->hostname, b->hostname)))
		return (r);
@


1.147
log
@- no need to assign a separator to the last route flag since we're not
	going to use it
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.146 2012/10/10 17:57:05 eric Exp $	*/
d122 1
a122 1
			log_debug("mta: received evp:%016" PRIx64 " for <%s@@%s>",
d212 1
a212 1
	log_info("mail transfer agent exiting");
d308 16
d334 1
a334 1
	log_warnx("mta: %s error: %s", mta_route_to_text(route), error);
d340 1
a340 1
	log_debug("mta: %s ready", mta_route_to_text(route));
d484 1
a484 1
	log_debug("mta: draining %s (tasks=%i, refs=%i, sessions=%i)",
d495 1
a495 1
		log_debug("mta: no task for %s", mta_route_to_text(route));
d503 1
a503 1
		log_debug("mta: too many failures on %s",
d523 1
a523 1
			log_debug("mta: max conn reached for %s",
d535 1
a535 1
	char	relay[MAX_LINE_SIZE];
a539 1
	log_envelope(e, relay, e->errorline);
d541 1
@


1.146
log
@show the port number for a relay if specified.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.145 2012/10/07 14:55:48 gilles Exp $	*/
a384 1
		sep = ",";
@


1.145
log
@bump max number of connections to a route from 5 to 10, the limit is too
low as experienced by myself and another user.

discussed with and ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.144 2012/09/28 14:03:00 chl Exp $	*/
d340 1
d343 1
a343 1
	buf[0] = '\0';
d345 5
a349 1
	snprintf(buf, sizeof buf, "route:%s[", route->hostname);
d352 1
@


1.144
log
@use xmemdup() and xcalloc() helpers

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.143 2012/09/21 12:33:32 eric Exp $	*/
d46 1
a46 1
#define MTA_MAXCONN	5	/* connections per route */
@


1.143
log
@Add a log_envelope() function that log envelope status in a uniform way.
It automagically adds an rcpt=<user@@domain> field if "dest" differs from
the original "rcpt". The function takes an "extra" parameter that allows
to add some specific info depending on the context.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.142 2012/09/18 14:23:01 eric Exp $	*/
d167 1
a167 3
			env->sc_ssl = calloc(1, sizeof *env->sc_ssl);
			if (env->sc_ssl == NULL)
				fatal(NULL);
d173 1
a173 4
			ssl = calloc(1, sizeof *ssl);
			if (ssl == NULL)
				fatal(NULL);
			*ssl = *(struct ssl *)imsg->data;
d175 1
a175 1
			  "mta:ssl_cert");
d177 1
a177 1
			    sizeof *ssl + ssl->ssl_cert_len, "mta_ssl_key");
@


1.142
log
@- add xmemdup() helper.
- remove useless block in switch.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.141 2012/09/16 16:43:28 chl Exp $	*/
d519 2
d523 2
a524 7
	log_info("%016" PRIx64 ": to=<%s@@%s>, delay=%s, relay=%s, stat=%s (%s)",
	    e->id, e->dest.user,
	    e->dest.domain,
	    duration_to_text(time(NULL) - e->creation),
	    task->route->hostname,
	    mta_response_status(e->errorline),
	    mta_response_text(e->errorline));
@


1.141
log
@Factorize log_imsg() in imsg_dispatch() instead of in each imsg_callback()'s
and put it out of profiling, so it's not accounted.

While there, for PROC_PARENT:
- set smtpd_process for PROC_PARENT
- use setproctitle() like other processes

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.140 2012/08/30 18:16:25 eric Exp $	*/
d96 1
a96 3
			e = xmalloc(sizeof *e, "mta:envelope");
			memmove(e, imsg->data, sizeof *e);

@


1.140
log
@- correctly free the task if all rcpt where rejected
- fix refcounting
- add some stat counters

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.139 2012/08/29 16:26:17 gilles Exp $	*/
a80 2

	log_imsg(PROC_MTA, iev->proc, imsg);
@


1.139
log
@Introduce the crypto_backend API and provide support for... encrypted queue
using the new API. By default, OpenSMTPD does not provide queue encryption,
but it can be enabled with "queue encryption [args]" and will transparently
encrypt/decrypt envelopes/messages as they hit the queue.

By default, it will use Blowfish in CBC mode with a different random IV for
each envelope and message. User provided key is expanded using sha256 but a
different cipher and digest may be specified in smtpd.conf

Queue encryption is compatible with compression and if both options are set
it will do them in correct order and transparently.

tested by chl@@, a few users and myself
ok chl@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.138 2012/08/25 10:23:12 gilles Exp $	*/
d125 1
d142 1
d445 1
d478 1
a498 1
			route->refcount -= 1;
d500 1
d537 1
@


1.138
log
@- introduce struct stat_value
- statistics can now have a type (counter, timestamp, timeval, timespec and
  possibly others in the future)
- stat_increment() / stat_decrement() now take an increment/decrement value
  and are at the moment only of type counter
- stat_set() now takes a stat_value
- provide helpers to convert raw values to stat_value

ok eric@@, ok chl@@

while at it fix a rq_queue_dump() call using a bogus timestamp in scheduler
ramqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.137 2012/08/22 11:44:34 eric Exp $	*/
a247 1
	ssl_init();
@


1.137
log
@also need to compare backupname if set.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.136 2012/08/21 20:19:46 eric Exp $	*/
d235 2
a236 1
		{ PROC_LKA,	imsg_dispatch }
@


1.136
log
@Allow smtpd to work as a backup MX, relaying only to MXs with higher
priority in the DNS record. For example:

   accept for domain "foo.org" relay backup "mx3.foo.org"

will relay mails for "foo.org" using only hosts with higher priority
(i.e. lower value) than "mx3.foo.org", which is supposed to be the
current server.

If the specified backup MX is not found in the DNS record, relaying
works as normal.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.135 2012/08/21 13:13:17 eric Exp $	*/
d562 3
@


1.135
log
@Re-enable loop detection, but in mta and mda this time.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.134 2012/08/18 15:45:12 eric Exp $	*/
d347 1
a347 1
	const char	*coma = "";
d354 1
a354 1
		coma = ",";
d359 2
a360 2
		strlcat(buf, coma, sizeof buf);
		coma = ",";
d365 2
a366 2
		strlcat(buf, coma, sizeof buf);
		coma = ",";
d372 2
a373 2
		strlcat(buf, coma, sizeof buf);
		coma = ",";
d379 2
a380 2
		strlcat(buf, coma, sizeof buf);
		coma = ",";
d383 8
d405 4
a408 1
	if (e->agent.mta.relay.hostname[0]) {
d427 2
@


1.134
log
@Major update of the mta internals.

Add a mta_route structure which describes a route through which
outgoing mails are to be sent.  This structure holds connection
parameters and limits.  When an envelope is received in a batch,
the route for it is looked up, and the envelope is added to the
a list of envelope to be sent for this message on that route: a
task.  When the batch is closed, each task is added to the list
of tasks for their respective route.

The routes are drained when new work can happen. The route will
create new mta sessions if necessary.  When a session is up and
ready, it picks the first pending task on the route if any.  In
the other case, it just closes the connection.

Errors on the connection are reported to the route, so that the
route could be flagged as broken.  Currently, three errors on a
an attempt to open a route is reported as a failure for all pen-
ding tasks.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.133 2012/07/29 13:56:24 eric Exp $	*/
d306 2
@


1.133
log
@remove the session tree from the global env and move it to mta_session.c,
along with mta_relay and mta_session definition.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.132 2012/05/11 12:12:02 eric Exp $	*/
d46 11
d61 12
a72 1
static void
d75 6
a80 1
	struct ssl		 *ssl;
d86 1
d88 9
d98 31
d130 16
d181 4
a184 8
			ssl->ssl_cert = strdup((char *)imsg->data +
			     sizeof *ssl);
			if (ssl->ssl_cert == NULL)
				fatal(NULL);
			ssl->ssl_key = strdup((char *)imsg->data +
			    sizeof *ssl + ssl->ssl_cert_len);
			if (ssl->ssl_key == NULL)
				fatal(NULL);
d283 273
@


1.132
log
@split the session logic off mta.c into mta_session.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.131 2012/05/11 08:15:30 eric Exp $	*/
a195 2

	SPLAY_INIT(&env->mta_sessions);
@


1.131
log
@set the status line and log envelope change in mta_envelope_done().
get rid of mta_envelope_log() and makes the code a little more
straightforward.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.130 2012/03/30 16:48:30 chl Exp $	*/
a46 1
static void mta_io(struct io *, int);
a48 12
static struct mta_session *mta_lookup(u_int64_t);
static void mta_enter_state(struct mta_session *, int);
static void mta_status(struct mta_session *, const char *, ...);
static void mta_envelope_done(struct mta_session *, struct envelope *,
    const char *);
static void mta_send(struct mta_session *, char *, ...);
static ssize_t mta_queue_data(struct mta_session *);
static void mta_response(struct mta_session *, char *);

const char * mta_strstate(int);

#define MTA_HIWAT	65535
d53 1
a53 9
	struct mta_batch	*mta_batch;
	struct mta_session	*s;
	struct mta_relay	*relay;
	struct envelope		*e;
	struct secret		*secret;
	struct dns		*dns;
	struct ssl		 key, *ssl;
	char			*cert;
	void			*ptr;
a59 57
			mta_batch = imsg->data;

			s = calloc(1, sizeof *s);
			if (s == NULL)
				fatal(NULL);
			s->id = mta_batch->id;
			s->state = MTA_INIT;

			/* establish host name */
			if (mta_batch->relay.hostname[0]) {
				s->host = strdup(mta_batch->relay.hostname);
				s->flags |= MTA_FORCE_MX;
			}

			/* establish port */
			s->port = ntohs(mta_batch->relay.port); /* XXX */

			/* use auth? */
			if ((mta_batch->relay.flags & F_SSL) &&
			    (mta_batch->relay.flags & F_AUTH)) {
				s->flags |= MTA_USE_AUTH;
				s->authmap = strdup(mta_batch->relay.authmap);
				if (s->authmap == NULL)
					fatalx("mta: strdup authmap");
			}

			/* force a particular SSL mode? */
			switch (mta_batch->relay.flags & F_SSL) {
			case F_SSL:
				s->flags |= MTA_FORCE_ANYSSL;
				break;
			case F_SMTPS:
				s->flags |= MTA_FORCE_SMTPS;
				break;
			case F_STARTTLS:
				/* STARTTLS is tried by default */
				break;
			default:
				s->flags |= MTA_ALLOW_PLAIN;
			}

			/* have cert? */
			cert = mta_batch->relay.cert;
			if (cert[0] != '\0') {
				s->flags |= MTA_USE_CERT;
				strlcpy(key.ssl_name, cert, sizeof(key.ssl_name));
				s->ssl = SPLAY_FIND(ssltree, env->sc_ssl, &key);
			}

			TAILQ_INIT(&s->recipients);
			TAILQ_INIT(&s->relays);
			SPLAY_INSERT(mtatree, &env->mta_sessions, s);

			log_debug("mta: %p: new session for batch %llu", s, s->id);

			return;

a60 18
			e = imsg->data;
			s = mta_lookup(e->batch_id);
			e = malloc(sizeof *e);
			if (e == NULL)
				fatal(NULL);
			*e = *(struct envelope *)imsg->data;
			envelope_set_errormsg(e, "000 init");

			if (s->host == NULL) {
				s->host = strdup(e->dest.domain);
				if (s->host == NULL)
					fatal("strdup");
			}
			log_debug("mta: %p: adding <%s@@%s> from envelope %016" PRIx64,
			    s, e->dest.user, e->dest.domain, e->id);
			TAILQ_INSERT_TAIL(&s->recipients, e, entry);
			return;

a61 9
			mta_batch = imsg->data;
			s = mta_lookup(mta_batch->id);
			if (s->flags & MTA_USE_CERT && s->ssl == NULL) {
				mta_status(s, "190 certificate not found");
				mta_enter_state(s, MTA_DONE);
			} else
				mta_enter_state(mta_lookup(mta_batch->id), MTA_INIT);
			return;

d63 1
a63 8
			mta_batch = imsg->data;
			if (imsg->fd == -1)
				fatalx("mta: cannot obtain msgfd");
			s = mta_lookup(mta_batch->id);
			s->datafp = fdopen(imsg->fd, "r");
			if (s->datafp == NULL)
				fatal("mta: fdopen");
			mta_enter_state(s, MTA_CONNECT);
a70 13
			/* LKA responded to AUTH lookup. */
			secret = imsg->data;
			s = mta_lookup(secret->id);
			s->secret = strdup(secret->secret);
			if (s->secret == NULL)
				fatal(NULL);
			else if (s->secret[0] == '\0') {
				mta_status(s, "190 secrets lookup failed");
				mta_enter_state(s, MTA_DONE);
			} else
				mta_enter_state(s, MTA_MX);
			return;

a71 9
			dns = imsg->data;
			s = mta_lookup(dns->id);
			relay = calloc(1, sizeof *relay);
			if (relay == NULL)
				fatal(NULL);
			relay->sa = dns->ss;
 			TAILQ_INSERT_TAIL(&s->relays, relay, entry);
			return;

a72 17
			/* LKA responded to DNS lookup. */
			dns = imsg->data;
			s = mta_lookup(dns->id);
			if (dns->error) {
				if (dns->error == DNS_RETRY)
					mta_status(s, "100 MX lookup failed temporarily");
				else if (dns->error == DNS_EINVAL)
					mta_status(s, "600 Invalid domain name");
				else if (dns->error == DNS_ENONAME)
					mta_status(s, "600 Domain does not exist");
				else if (dns->error == DNS_ENOTFOUND)
					mta_status(s, "600 No MX address found for domain");
				mta_enter_state(s, MTA_DONE);
			} else
				mta_enter_state(s, MTA_DATA);
			return;

d74 1
a74 21
			dns = imsg->data;
			s = mta_lookup(dns->id);
			relay = TAILQ_FIRST(&s->relays);
			if (dns->error)
				strlcpy(relay->fqdn, "<unknown>", sizeof relay->fqdn);
			else
				strlcpy(relay->fqdn, dns->host, sizeof relay->fqdn);
			log_debug("mta: %p: connected to %s", s, relay->fqdn);

			/* check if we need to start tls now... */
			if (((s->flags & MTA_FORCE_ANYSSL) && relay->used == 1) ||
			    (s->flags & MTA_FORCE_SMTPS)) {
				log_debug("mta: %p: trying smtps (ssl=%p)...", s, s->ssl);
				ptr = ssl_mta_init(s->ssl);
				if (ptr == NULL)
					fatalx("mta: ssl_mta_init");

				io_start_tls(&s->io, ptr);
			} else {
				mta_enter_state(s, MTA_SMTP_BANNER);
			}
a203 635
}

static struct mta_session *
mta_lookup(u_int64_t id)
{
	struct mta_session	 key, *res;

	key.id = id;
	if ((res = SPLAY_FIND(mtatree, &env->mta_sessions, &key)) == NULL)
		fatalx("mta_lookup: session not found");
	return (res);
}

static void
mta_enter_state(struct mta_session *s, int newstate)
{
	int			 oldstate;
	struct secret		 secret;
	struct mta_relay	*relay;
	struct sockaddr		*sa;
	struct envelope		*e;
	int			 max_reuse;
	ssize_t			 q;
	struct mta_batch	 batch;

    again:

	oldstate = s->state;

	log_trace(TRACE_MTA, "mta: %p: %s -> %s", s,
	    mta_strstate(oldstate),
	    mta_strstate(newstate));

	s->state = newstate;

	/* don't try this at home! */
#define mta_enter_state(_s, _st) do { newstate = _st; goto again; } while(0)

	switch (s->state) {
	case MTA_INIT:
		if (s->flags & MTA_USE_AUTH)
			mta_enter_state(s, MTA_SECRET);
		else
			mta_enter_state(s, MTA_MX);
		break;

	case MTA_DATA:
		/*
		 * Obtain message body fd.
		 */
		e = TAILQ_FIRST(&s->recipients);
		batch.id = s->id;
		batch.msgid = evpid_to_msgid(e->id);
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_MESSAGE_FD, 0, 0, -1, &batch, sizeof(batch));
		break;

	case MTA_SECRET:
		/*
		 * Lookup AUTH secret.
		 */
		bzero(&secret, sizeof(secret));
		secret.id = s->id;
		strlcpy(secret.mapname, s->authmap, sizeof(secret.mapname));
		strlcpy(secret.host, s->host, sizeof(secret.host));
		imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_SECRET,
		    0, 0, -1, &secret, sizeof(secret));  
		break;

	case MTA_MX:
		/*
		 * Lookup MX record.
		 */
		if (s->flags & MTA_FORCE_MX)
			dns_query_host(s->host, s->port, s->id);
		else
			dns_query_mx(s->host, 0, s->id);
		break;

	case MTA_CONNECT:
		/*
		 * Connect to the MX.
		 */
		if (oldstate == MTA_CONNECT) {
			/* previous connection failed. clean it up */
			iobuf_clear(&s->iobuf);
			io_clear(&s->io);
		}

		if (s->flags & MTA_FORCE_ANYSSL)
			max_reuse = 2;
		else
			max_reuse = 1;

		/* pick next mx */
		while ((relay = TAILQ_FIRST(&s->relays))) {
			if (relay->used == max_reuse) {
				TAILQ_REMOVE(&s->relays, relay, entry);
				free(relay);
				continue;
			}
			relay->used++;

			log_debug("mta: %p: connecting to %s...", s,
				ss_to_text(&relay->sa));
			sa = (struct sockaddr *)&relay->sa;

			if (s->port)
				sa_set_port(sa, s->port);
			else if ((s->flags & MTA_FORCE_ANYSSL) && relay->used == 1)
				sa_set_port(sa, 465);
			else if (s->flags & MTA_FORCE_SMTPS)
				sa_set_port(sa, 465);
			else
				sa_set_port(sa, 25);

			iobuf_init(&s->iobuf, 0, 0);
			io_init(&s->io, -1, s, mta_io, &s->iobuf);
			io_set_timeout(&s->io, 10000);
			if (io_connect(&s->io, sa) == -1) {
				log_debug("mta: %p: connection failed: %s", s,
				    strerror(errno));
				iobuf_clear(&s->iobuf);
				/*
				 * This error is most likely a "no route",
				 * so there is no need to try the same
				 * relay again.
				 */
				TAILQ_REMOVE(&s->relays, relay, entry);
				free(relay);
				continue;
			}
			return;
		}
		/* tried them all? */
		mta_status(s, "150 Can not connect to MX");
		mta_enter_state(s, MTA_DONE);
		break;

	case MTA_DONE:
		/*
		 * Kill the mta session.
		 */

		log_debug("mta: %p: deleting session...", s);
		io_clear(&s->io);
		iobuf_clear(&s->iobuf);

		if ((e = TAILQ_FIRST(&s->recipients)))
			fatalx("all envelopes should have been sent already");

		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_BATCH_DONE, 0, 0, -1, NULL, 0);

		/* deallocate resources */
		SPLAY_REMOVE(mtatree, &env->mta_sessions, s);
		while ((relay = TAILQ_FIRST(&s->relays))) {
			TAILQ_REMOVE(&s->relays, relay, entry);
			free(relay);
		}

		if (s->datafp)
			fclose(s->datafp);

		free(s->authmap);
		free(s->secret);
		free(s->host);
		free(s);
		break;

	case MTA_SMTP_BANNER:
		/* just wait for banner */
		io_set_read(&s->io);
		break;

	case MTA_SMTP_EHLO:
		s->ext = 0;
		mta_send(s, "EHLO %s", env->sc_hostname);
		break;

	case MTA_SMTP_HELO:
		s->ext = 0;
		mta_send(s, "HELO %s", env->sc_hostname);
		break;

	case MTA_SMTP_STARTTLS:
		if (s->flags & MTA_TLS) /* already started */
			mta_enter_state(s, MTA_SMTP_AUTH);
		else if ((s->ext & MTA_EXT_STARTTLS) == 0)
			/* server doesn't support starttls, do not use it */
			mta_enter_state(s, MTA_SMTP_AUTH);
		else
			mta_send(s, "STARTTLS");
		break;

	case MTA_SMTP_AUTH:
		if (s->secret && s->flags & MTA_TLS)
			mta_send(s, "AUTH PLAIN %s", s->secret);
		else if (s->secret) {
			log_debug("mta: %p: not using AUTH on non-TLS session",
			    s);
			mta_enter_state(s, MTA_CONNECT);
		} else
			mta_enter_state(s, MTA_SMTP_READY);
		break;

	case MTA_SMTP_READY:
		/* ready to send a new mail */
		mta_enter_state(s, MTA_SMTP_MAIL);
		break;

	case MTA_SMTP_MAIL:
		s->currevp = TAILQ_FIRST(&s->recipients);
		if (s->currevp->sender.user[0] &&
		    s->currevp->sender.domain[0])
			mta_send(s, "MAIL FROM: <%s@@%s>",
			    s->currevp->sender.user,
			    s->currevp->sender.domain);
		else
			mta_send(s, "MAIL FROM: <>");
		break;

	case MTA_SMTP_RCPT:
		mta_send(s, "RCPT TO: <%s@@%s>",
		    s->currevp->dest.user,
		    s->currevp->dest.domain);
		break;

	case MTA_SMTP_DATA:
		fseek(s->datafp, 0, SEEK_SET);
		mta_send(s, "DATA");
		break;

	case MTA_SMTP_BODY:
		if (s->datafp == NULL) {
			log_debug("mta: %p: end-of-file", s);
			mta_enter_state(s, MTA_SMTP_DONE);
			break;
		}

		if ((q = mta_queue_data(s)) == -1) {
			mta_enter_state(s, MTA_DONE);
			break;
		}

		log_trace(TRACE_MTA, "mta: %p: >>> [...%zi bytes...]", s, q);
		break;

	case MTA_SMTP_DONE:
		mta_send(s, ".");
		break;

	case MTA_SMTP_QUIT:
		mta_send(s, "QUIT");
		break;

	default:
		fatal("mta_enter_state: unknown state");
	}
#undef mta_enter_state
}

/*
 * Handle a response to an SMTP command
 */
static void
mta_response(struct mta_session *s, char *line)
{
	void		*ssl;
	struct envelope	*evp;

	switch (s->state) {

	case MTA_SMTP_BANNER:
		mta_enter_state(s, MTA_SMTP_EHLO);
		break;

	case MTA_SMTP_EHLO:
		if (line[0] != '2') {
			if ((s->flags & MTA_USE_AUTH) ||
			    !(s->flags & MTA_ALLOW_PLAIN)) {
				mta_status(s, line);
				mta_enter_state(s, MTA_DONE);
				return;
			}
			mta_enter_state(s, MTA_SMTP_HELO);
			return;
		}
		mta_enter_state(s, MTA_SMTP_STARTTLS);
		break;

	case MTA_SMTP_HELO:
		if (line[0] != '2') {
			mta_status(s, line);
			mta_enter_state(s, MTA_DONE);
			return;
		}
		mta_enter_state(s, MTA_SMTP_READY);
		break;

	case MTA_SMTP_STARTTLS:
		if (line[0] != '2') {
			if (s->flags & MTA_ALLOW_PLAIN) {
				mta_enter_state(s, MTA_SMTP_AUTH);
				return;
			}
			/* stop here if ssl can't be used */
			mta_status(s, line);
			mta_enter_state(s, MTA_DONE);
			return;
		}
		ssl = ssl_mta_init(s->ssl);
		if (ssl == NULL)
			fatal("mta: ssl_mta_init");
		io_set_write(&s->io);
		io_start_tls(&s->io, ssl);
		break;

	case MTA_SMTP_AUTH:
		if (line[0] != '2') {
			mta_status(s, line);
			mta_enter_state(s, MTA_DONE);
			return;
		}
		mta_enter_state(s, MTA_SMTP_READY);
		break;

	case MTA_SMTP_MAIL:
		if (line[0] != '2') {
			mta_status(s, line);
			mta_enter_state(s, MTA_DONE);
			return;
		}
		mta_enter_state(s, MTA_SMTP_RCPT);
		break;

	case MTA_SMTP_RCPT:
		evp = s->currevp;
		s->currevp = TAILQ_NEXT(s->currevp, entry);
		if (line[0] != '2')
			mta_envelope_done(s, evp, line);
		if (s->currevp == NULL)
			mta_enter_state(s, MTA_SMTP_DATA);
		else
			mta_enter_state(s, MTA_SMTP_RCPT);
		break;

	case MTA_SMTP_DATA:
		if (line[0] != '2' && line[0] != '3') {
			mta_status(s, line);
			mta_enter_state(s, MTA_DONE);
			return;
		}
		mta_enter_state(s, MTA_SMTP_BODY);
		break;

	case MTA_SMTP_DONE:
		mta_status(s, line);
		if (line[0] != '2')
			mta_enter_state(s, MTA_DONE);
		else
			mta_enter_state(s, MTA_SMTP_QUIT);
		break;

	default:
		fatal("mta_response() bad state");
	}
}

static void
mta_io(struct io *io, int evt)
{
	struct mta_session	*s = io->arg;
	char			*line, *msg;
	ssize_t			 len;
	struct mta_relay	*relay;
	const char		*error;
	int			 cont;

	log_trace(TRACE_IO, "mta: %p: %s %s", s, io_strevent(evt), io_strio(io));

	switch (evt) {

	case IO_CONNECTED:
		io_set_timeout(io, 300000);
		io_set_write(io);
		relay = TAILQ_FIRST(&s->relays);
		dns_query_ptr(&relay->sa, s->id);
		break;

	case IO_TLSREADY:
		s->flags |= MTA_TLS;
		if (s->state == MTA_CONNECT) /* smtps */
			mta_enter_state(s, MTA_SMTP_BANNER);
		else
			mta_enter_state(s, MTA_SMTP_EHLO);
		break;

	case IO_DATAIN:
	    nextline:

		line = iobuf_getline(&s->iobuf, &len);
		if (line == NULL) {
			if (iobuf_len(&s->iobuf) >= SMTP_LINE_MAX) {
				mta_status(s, "150 Input too long");
				mta_enter_state(s, MTA_DONE);
				return;
			}
			iobuf_normalize(&s->iobuf);
			break;
		}

		log_trace(TRACE_MTA, "mta: %p: <<< %s", s, line);

		if ((error = parse_smtp_response(line, len, &msg, &cont))) {
			mta_status(s, "150 Bad response: %s", error);
			mta_enter_state(s, MTA_DONE);
			return;
		}

		/* read extensions */
		if (s->state == MTA_SMTP_EHLO) {
			if (strcmp(msg, "STARTTLS") == 0)
				s->ext |= MTA_EXT_STARTTLS;
			else if (strncmp(msg, "AUTH", 4) == 0)
				s->ext |= MTA_EXT_AUTH;
			else if (strcmp(msg, "PIPELINING") == 0)
				s->ext |= MTA_EXT_PIPELINING;
		}

		if (cont)
			goto nextline;

		if (s->state == MTA_SMTP_QUIT) {
			mta_enter_state(s, MTA_DONE);
			return;
		}

		mta_response(s, line);

		iobuf_normalize(&s->iobuf);
		if (iobuf_queued(&s->iobuf))
			io_set_write(io);
		break;

	case IO_LOWAT:
		if (s->state == MTA_SMTP_BODY)
			mta_enter_state(s, MTA_SMTP_BODY);

		if (iobuf_queued(&s->iobuf) == 0)
			io_set_read(io);
		break;

	case IO_TIMEOUT:
		log_debug("mta: %p: connection timeout", s);
		if (s->state == MTA_CONNECT) {
			/* try the next MX */
			mta_enter_state(s, MTA_CONNECT);
			break;
		}
		mta_status(s, "150 connection timeout");
		mta_enter_state(s, MTA_DONE);
		break;

	case IO_ERROR:
		log_debug("mta: %p: IO error: %s", s, strerror(errno));
		if (s->state == MTA_CONNECT) {
			mta_enter_state(s, MTA_CONNECT);
			break;
		}
		mta_status(s, "150 IO error");
		mta_enter_state(s, MTA_DONE);
		break;

	case IO_DISCONNECTED:
		log_debug("mta: %p: disconnected in state %s", s, mta_strstate(s->state));
		if (s->state == MTA_CONNECT) {
			mta_enter_state(s, MTA_CONNECT);
			break;
		}
		mta_status(s, "150 connection closed unexpectedly");
		mta_enter_state(s, MTA_DONE);
		break;

	default:
		fatal("mta_io()");
	}
}

static void
mta_send(struct mta_session *s, char *fmt, ...)
{
        va_list  ap;
        char    *p;
        int      len;

        va_start(ap, fmt);
        if ((len = vasprintf(&p, fmt, ap)) == -1)
                fatal("mta: vasprintf");
        va_end(ap);

	log_trace(TRACE_MTA, "mta: %p: >>> %s", s, p);

	iobuf_fqueue(&s->iobuf, "%s\r\n", p);

        free(p);
}

/*
 * Queue some data into the input buffer
 */
static ssize_t
mta_queue_data(struct mta_session *s)
{
	char	*ln;
        size_t	 len, q;

	q = iobuf_queued(&s->iobuf);

	while (iobuf_queued(&s->iobuf) < MTA_HIWAT) {
                if ((ln = fgetln(s->datafp, &len)) == NULL)
                        break;
                if (ln[len - 1] == '\n')
                        len--;
		if (*ln == '.')
			iobuf_queue(&s->iobuf, ".", 1);
		iobuf_queue(&s->iobuf, ln, len);
		iobuf_queue(&s->iobuf, "\r\n", 2);
	}

        if (ferror(s->datafp)) {
		mta_status(s, "460 Error reading content file");
		return (-1);
	}

        if (feof(s->datafp)) {
		fclose(s->datafp);
		s->datafp = NULL;
	}

	return (iobuf_queued(&s->iobuf) - q);
}

static void
mta_status(struct mta_session *s, const char *fmt, ...)
{
	char			*status;
	struct envelope		*e;
	va_list			 ap;

	va_start(ap, fmt);
	if (vasprintf(&status, fmt, ap) == -1)
		fatal("vasprintf");
	va_end(ap);

	log_debug("mta: %p: new status for remaining envelopes: %s", s, status);

	while ((e = TAILQ_FIRST(&s->recipients)))
		mta_envelope_done(s, e, status);

	free(status);
}

static void
mta_envelope_done(struct mta_session *s, struct envelope *e, const char *status)
{
	struct mta_relay	*relay = TAILQ_FIRST(&s->relays);
	u_int16_t		msg;

	envelope_set_errormsg(e, "%s", status);

	log_info("%016" PRIx64 ": to=<%s@@%s>, delay=%" PRId64 ", relay=%s [%s], stat=%s (%s)",
	    e->id, e->dest.user,
	    e->dest.domain,
	    (int64_t) (time(NULL) - e->creation),
	    relay ? relay->fqdn : "(none)",
	    relay ? ss_to_text(&relay->sa) : "",
	    *status == '2' ? "Sent" :
	    *status == '5' ? "RemoteError" :
	    *status == '4' ? "RemoteError" : "LocalError",
	    status + 4);

	switch (e->errorline[0]) {
	case '2':
		msg = IMSG_QUEUE_DELIVERY_OK;
		break;
	case '5':
	case '6':
		msg = IMSG_QUEUE_DELIVERY_PERMFAIL;
		break;
	default:
		msg = IMSG_QUEUE_DELIVERY_TEMPFAIL;
		break;
	}
	imsg_compose_event(env->sc_ievs[PROC_QUEUE], msg,
	    0, 0, -1, e, sizeof(*e));
	TAILQ_REMOVE(&s->recipients, e, entry);
	free(e);
}

int
mta_session_cmp(struct mta_session *a, struct mta_session *b)
{
	return (a->id < b->id ? -1 : a->id > b->id);
}

SPLAY_GENERATE(mtatree, mta_session, entry, mta_session_cmp);

#define CASE(x) case x : return #x

const char *
mta_strstate(int state)
{
	switch (state) {
	CASE(MTA_INIT);
	CASE(MTA_SECRET);
	CASE(MTA_DATA);
	CASE(MTA_MX);
	CASE(MTA_CONNECT);
	CASE(MTA_DONE);
	CASE(MTA_SMTP_READY);
	CASE(MTA_SMTP_BANNER);  
	CASE(MTA_SMTP_EHLO);
	CASE(MTA_SMTP_HELO);
	CASE(MTA_SMTP_STARTTLS);
	CASE(MTA_SMTP_AUTH);                             
	CASE(MTA_SMTP_MAIL);
	CASE(MTA_SMTP_RCPT);
	CASE(MTA_SMTP_DATA);
	CASE(MTA_SMTP_QUIT);
	CASE(MTA_SMTP_BODY);
	CASE(MTA_SMTP_DONE);
	default:
		return "MTA_???";
	}
@


1.130
log
@increase timeout to 5m when connecting to a remote mail server, as required
by the RFC 5321 (section 4.5.3.2.1.)

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.129 2012/03/27 12:53:33 eric Exp $	*/
d53 2
a54 2
static void mta_envelope_log(struct mta_session *, struct envelope *);
static void mta_envelope_done(struct mta_session *, struct envelope *);
d714 2
a715 5
		if (line[0] != '2') {
			envelope_set_errormsg(evp, "%s", line);
			mta_envelope_log(s, evp);
			mta_envelope_done(s, evp);
		}
d930 4
a933 7
	while ((e = TAILQ_FIRST(&s->recipients))) {
		log_debug("mta: new status for %s@@%s: %s", e->dest.user,
		    e->dest.domain, status);
		envelope_set_errormsg(e, "%s", status);
		mta_envelope_log(s, e);
		mta_envelope_done(s, e);
	}
d939 1
a939 1
mta_envelope_log(struct mta_session *s, struct envelope *e)
d942 3
a944 1
	char			*status = e->errorline;
a955 6
}

static void
mta_envelope_done(struct mta_session *s, struct envelope *e)
{
	u_int16_t	msg;
@


1.129
log
@Do not try STARTTLS if the server does not advertise support
for it (it apparently triggers very bizarre behaviour on some
servers). Also make sure we are not using AUTH over a clear
channel.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.128 2012/03/25 08:44:24 eric Exp $	*/
d762 1
a762 1
		io_set_timeout(io, 30000);
@


1.128
log
@Do not fatal() when failing to connect to a relay.
Instead, drop the relay and try the next one.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.127 2012/02/01 20:30:40 eric Exp $	*/
d563 3
d571 1
a571 1
		if (s->secret)
d573 5
a577 1
		else
@


1.127
log
@When updating an envelope status, the update is immediatly sent to the
queue and the envelope discarded from the mta batch.  Also make sure
that all condition leading to the MTA_DONE state have properly set the
status of all pending envelopes before. No envelope should be left when
entering that state.

Little cleanup while there: remove mta_message_status() and rename
remaining mta_message_*() to mta_envelope_* to avoid confusion.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.126 2012/01/29 11:37:32 eric Exp $	*/
d494 13
a506 2
			if (io_connect(&s->io, sa) == -1)
				fatal("mta cannot create socket");
@


1.126
log
@Rewrite io code in smtp and mta using the iobuf/ioev interface to have
a better separation between io and protocol logic.  As a side-effect,
it fixes a couple of long-standing issues in the io path, and
hopefully add fresh ones instead.  Kill client.c in the process.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.125 2012/01/28 11:33:06 gilles Exp $	*/
d53 2
a54 3
static void mta_message_status(struct envelope *, char *);
static void mta_message_log(struct mta_session *, struct envelope *);
static void mta_message_done(struct mta_session *, struct envelope *);
d499 1
d512 2
a513 3
		/* update queue status */
		while ((e = TAILQ_FIRST(&s->recipients)))
			mta_message_done(s, e);
d626 1
d694 2
d697 3
a699 2
			mta_message_status(s->currevp, line);
			mta_message_log(s, s->currevp);
a700 1
		s->currevp = TAILQ_NEXT(s->currevp, entry);
d814 1
d816 1
a816 1
			mta_status(s, "110 connect timeout");
d820 1
d825 1
a826 1
			mta_status(s, "110 connect error: %s", strerror(errno));
d830 1
d835 1
a835 1
		log_debug("mta_io(): %p: disconnected in state %s", s, mta_strstate(s->state));
a836 1
			mta_status(s, "110 disconnected: %s", strerror(errno));
d840 1
d907 1
a907 1
	struct envelope		*e, *next;
d915 6
a920 11
	for (e = TAILQ_FIRST(&s->recipients); e; e = next) {
		next = TAILQ_NEXT(e, entry);

		/* save new status */
		mta_message_status(e, status);

		/* remove queue entry */
		if (*status == '2' || *status == '5' || *status == '6') {
			mta_message_log(s, e);
			mta_message_done(s, e);
		}
a925 23

/*
 * XXX this function ought to die.
 * The message status can only be update once: when it's been delivered,
 * or when we know it can't be (general batch failure or refused RCPT).
 */
static void
mta_message_status(struct envelope *e, char *status)
{
	/*
	 * Previous delivery attempts might have assigned an errorline of
	 * higher status (eg. 5yz is of higher status than 4yz), so check
	 * this before deciding to overwrite existing status with a new one.
	 */
	if (*status != '2' && strncmp(e->errorline, status, 3) > 0)
		return;

	/* change status */
	log_debug("mta: new status for %s@@%s: %s", e->dest.user,
	    e->dest.domain, status);
	envelope_set_errormsg(e, "%s", status);
}

d927 1
a927 1
mta_message_log(struct mta_session *s, struct envelope *e)
d945 1
a945 1
mta_message_done(struct mta_session *s, struct envelope *e)
@


1.125
log
@- introduce the scheduler_backend API
- introduce the scheduler_ramqueue backend
- remove all occurences of ramqueue outside of the ramqueue backend
- teach runner how to use the new API

it is now possible to write custom schedulers !

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.124 2012/01/26 12:31:53 eric Exp $	*/
d7 1
d28 1
a43 1
#include "client.h"
d47 1
d51 1
a51 3
static void mta_enter_state(struct mta_session *, int, void *);
static void mta_pickup(struct mta_session *, void *);
static void mta_event(int, short, void *);
d56 7
a62 2
static void mta_connect_done(int, short, void *);
static void mta_request_datafd(struct mta_session *);
d75 1
d163 1
a163 1
				mta_enter_state(s, MTA_DONE, NULL);
d165 1
a165 1
				mta_pickup(s, NULL);
d176 1
a176 1
			mta_enter_state(s, MTA_CONNECT, NULL);
d184 1
d186 9
a194 1
			mta_pickup(mta_lookup(secret->id), secret->secret);
d208 1
d210 13
a222 1
			mta_pickup(mta_lookup(dns->id), &dns->error);
d230 1
a230 2
				strlcpy(relay->fqdn, "<unknown>",
				    sizeof relay->fqdn);
d232 15
a246 3
				strlcpy(relay->fqdn, dns->host,
				    sizeof relay->fqdn);
			mta_pickup(s, NULL);
d390 1
a390 1
mta_enter_state(struct mta_session *s, int newstate, void *p)
d392 1
a396 1
	struct smtp_client	*pcb;
d398 10
d411 3
d415 18
a454 8
	case MTA_DATA:
		/*
		 * Obtain message body fd.
		 */
		log_debug("mta: getting datafd");
		mta_request_datafd(s);
		break;

d459 6
d479 2
a480 1
			log_debug("mta: connect %s", ss_to_text(&relay->sa));
d492 4
a495 2
			s->fd = socket(sa->sa_family, SOCK_STREAM, 0);
			if (s->fd == -1)
d497 1
a497 13
			session_socket_blockmode(s->fd, BM_NONBLOCK);
			session_socket_no_linger(s->fd);

			if (connect(s->fd, sa, sa->sa_len) == -1) {
				if (errno != EINPROGRESS) {
					mta_status(s, "110 connect error: %s",
					    strerror(errno));
					close(s->fd);
					continue;
				}
			}
			event_once(s->fd, EV_WRITE, mta_connect_done, s, NULL);
			break;
a498 1

d500 1
a500 2
		if (relay == NULL)
			mta_enter_state(s, MTA_DONE, NULL);
d503 1
a503 1
	case MTA_PTR:
d505 1
a505 1
		 * Lookup PTR record of the connected host.
a506 9
		relay = TAILQ_FIRST(&s->relays);
		dns_query_ptr(&relay->sa, s->id);
		break;

	case MTA_PROTOCOL:
		/*
		 * Start protocol engine.
		 */
		log_debug("mta: entering smtp phase");
d508 3
a510 44
		fseek(s->datafp, 0, SEEK_SET);
		pcb = client_init(s->fd, s->datafp, env->sc_hostname, 1);

		if (s->ssl) {
			client_certificate(pcb,
			    s->ssl->ssl_cert, s->ssl->ssl_cert_len,
			    s->ssl->ssl_key, s->ssl->ssl_key_len);
		}

		/* choose SMTPS vs. STARTTLS */
		relay = TAILQ_FIRST(&s->relays);
		if ((s->flags & MTA_FORCE_ANYSSL) && relay->used == 1)
			client_ssl_smtps(pcb);
		else if (s->flags & MTA_FORCE_SMTPS)
			client_ssl_smtps(pcb);
		else if (s->flags & MTA_ALLOW_PLAIN)
			client_ssl_optional(pcb);

		/* enable AUTH */
		if (s->secret)
			client_auth(pcb, s->secret);

		/* set envelope sender */
		e = TAILQ_FIRST(&s->recipients);
		if (e->sender.user[0] && e->sender.domain[0])
			client_sender(pcb, "%s@@%s", e->sender.user,
			    e->sender.domain);
		else
			client_sender(pcb, "");
			
		/* set envelope recipients */
		TAILQ_FOREACH(e, &s->recipients, entry)
			client_rcpt(pcb, e, "%s@@%s", e->dest.user,
			    e->dest.domain);

		s->pcb = pcb;
		event_set(&s->ev, s->fd, EV_READ|EV_WRITE, mta_event, s);
		event_add(&s->ev, &pcb->timeout);
		break;

	case MTA_DONE:
		/*
		 * Kill mta session.
		 */
d535 79
d617 1
d620 3
d624 1
a624 1
mta_pickup(struct mta_session *s, void *p)
d626 1
a626 1
	int	 error;
d629 123
a751 3
	case MTA_INIT:
		if (s->flags & MTA_USE_AUTH)
			mta_enter_state(s, MTA_SECRET, NULL);
d753 48
a800 1
			mta_enter_state(s, MTA_MX, NULL);
d803 6
a808 10
	case MTA_SECRET:
		/* LKA responded to AUTH lookup. */
		s->secret = strdup(p);
		if (s->secret == NULL)
			fatal(NULL);
		else if (s->secret[0] == '\0') {
			mta_status(s, "190 secrets lookup failed");
			mta_enter_state(s, MTA_DONE, NULL);
		} else
			mta_enter_state(s, MTA_MX, NULL);
d811 7
a817 14
	case MTA_MX:
		/* LKA responded to DNS lookup. */
		if ((error = *(int *)p)) {
			if (error == DNS_RETRY)
				mta_status(s, "100 MX lookup failed temporarily");
			else if (error == DNS_EINVAL)
				mta_status(s, "600 Invalid domain name");
			else if (error == DNS_ENONAME)
				mta_status(s, "600 Domain does not exist");
			else if (error == DNS_ENOTFOUND)
				mta_status(s, "600 No MX address found for domain");
			mta_enter_state(s, MTA_DONE, NULL);
		} else
			mta_enter_state(s, MTA_DATA, NULL);
d820 7
a826 9
	case MTA_CONNECT:
		/* Remote accepted/rejected connection. */
		error = session_socket_error(s->fd);
		if (error) {
			mta_status(s, "110 connect error: %s", strerror(error));
			close(s->fd);
			mta_enter_state(s, MTA_CONNECT, NULL);
		} else
			mta_enter_state(s, MTA_PTR, NULL);
d829 8
a836 2
	case MTA_PTR:
		mta_enter_state(s, MTA_PROTOCOL, NULL);
d840 1
a840 1
		fatalx("mta_pickup: unexpected state");
d845 1
a845 1
mta_event(int fd, short event, void *p)
d847 8
a854 2
	struct mta_session	*s = p;
	struct smtp_client	*pcb = s->pcb;
d856 27
a882 3
	if (event & EV_TIMEOUT) {
		mta_status(s, "150 timeout");
		goto out;
d885 8
a892 15
	switch (client_talk(pcb, event & EV_WRITE)) {
	case CLIENT_WANT_WRITE:
		goto rw;
	case CLIENT_STOP_WRITE:
		goto ro;
	case CLIENT_RCPT_FAIL:
		mta_message_status(pcb->rcptfail, pcb->reply);
		mta_message_log(s, pcb->rcptfail);
		mta_message_done(s, pcb->rcptfail);
		goto rw;
	case CLIENT_DONE:
		mta_status(s, "%s", pcb->status);
		break;
	default:
		fatalx("mta_event: unexpected code");
d895 1
a895 18
out:
	client_close(pcb);
	s->pcb = NULL;

	if (TAILQ_EMPTY(&s->recipients))
		mta_enter_state(s, MTA_DONE, NULL);
	else
		mta_enter_state(s, MTA_CONNECT, NULL);
	return;

rw:
	event_set(&s->ev, fd, EV_READ|EV_WRITE, mta_event, s);
	event_add(&s->ev, &pcb->timeout);
	return;

ro:
	event_set(&s->ev, fd, EV_READ, mta_event, s);
	event_add(&s->ev, &pcb->timeout);
d926 6
d990 2
a991 2
static void
mta_connect_done(int fd, short event, void *p)
d993 1
a993 1
	mta_pickup(p, NULL);
d996 1
a996 5
static void
mta_request_datafd(struct mta_session *s)
{
	struct mta_batch	mta_batch;
	struct envelope	*e;
d998 1
a998 1
	e = TAILQ_FIRST(&s->recipients);
d1000 2
a1001 8
	mta_batch.id = s->id;
	mta_batch.msgid = evpid_to_msgid(e->id);
	imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_FD,
	    0, 0, -1, &mta_batch, sizeof(mta_batch));
}

int
mta_session_cmp(struct mta_session *a, struct mta_session *b)
d1003 22
a1024 1
	return (a->id < b->id ? -1 : a->id > b->id);
a1025 2

SPLAY_GENERATE(mtatree, mta_session, entry, mta_session_cmp);
@


1.124
log
@Rewind the message fp before starting the SMTP dialog.
It could have been read before during an aborted session
on a previous MX.

reported by Vianney Bouchaud <vianney@@poolp.org>

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.123 2012/01/13 14:01:57 eric Exp $	*/
d62 1
a62 1
	struct ramqueue_batch  	*rq_batch;
d76 1
a76 1
			rq_batch = imsg->data;
d81 1
a81 1
			s->id = rq_batch->b_id;
d85 2
a86 2
			if (rq_batch->relay.hostname[0]) {
				s->host = strdup(rq_batch->relay.hostname);
d91 1
a91 1
			s->port = ntohs(rq_batch->relay.port); /* XXX */
d94 2
a95 2
			if ((rq_batch->relay.flags & F_SSL) &&
			    (rq_batch->relay.flags & F_AUTH)) {
d97 1
a97 1
				s->authmap = strdup(rq_batch->relay.authmap);
d103 1
a103 1
			switch (rq_batch->relay.flags & F_SSL) {
d118 1
a118 1
			cert = rq_batch->relay.cert;
d153 2
a154 2
			rq_batch = imsg->data;
			s = mta_lookup(rq_batch->b_id);
d163 1
a163 1
			rq_batch = imsg->data;
d166 1
a166 1
			s = mta_lookup(rq_batch->b_id);
d737 1
a737 1
	struct ramqueue_batch	rq_batch;
d742 2
a743 2
	rq_batch.b_id = s->id;
	rq_batch.msgid = evpid_to_msgid(e->id);
d745 1
a745 1
	    0, 0, -1, &rq_batch, sizeof(rq_batch));
@


1.123
log
@Stop using envelope->status to report delivery outcome to the
runner/queue.  Instead, replace IMSG_QUEUE_MESSAGE_UPDATE with three
messages:

- IMSG_QUEUE_DELIVERY_OK
- IMSG_QUEUE_DELIVERY_TEMPFAIL
- IMSG_QUEUE_DELIVERY_PERMFAIL

1) it's less confusing as status is also used by smtp
2) it's easier to see what happens just looking at imsg traces
3) it makes the code path generally easier to follow
4) it's safer because it enforces clear semantics and intent, whereas
   the status field is loosely defined and could carry bogus values.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.122 2012/01/11 22:12:07 eric Exp $	*/
d460 1
@


1.122
log
@remove bogus call

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.121 2011/12/18 18:43:30 eric Exp $	*/
d707 2
d710 4
d715 1
a715 5
	case '5':
		e->status = DS_PERMFAILURE;
		break;
	case '2':
		e->status = DS_ACCEPTED;
d718 1
a718 1
		e->status = DS_TEMPFAILURE;
d721 2
a722 2
	imsg_compose_event(env->sc_ievs[PROC_QUEUE],
	    IMSG_QUEUE_MESSAGE_UPDATE, 0, 0, -1, e, sizeof(*e));
@


1.121
log
@- use envelope_set_errormsg() where possible.
- make it use sizeof() rather than a hardcoded limit.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.120 2011/12/11 17:02:10 eric Exp $	*/
a329 1
	ramqueue_init(&env->sc_rqueue);
@


1.120
log
@Make the mta code a bit more straightforward:
- fetch the ssl cert earlier on if needed
- skip mta_pickup() when handling the incoming fd

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.119 2011/11/14 19:23:41 chl Exp $	*/
d140 1
a140 2
			strlcpy(e->errorline, "000 init",
			    sizeof(e->errorline));
d684 1
a684 1
	strlcpy(e->errorline, status, sizeof(e->errorline));
@


1.119
log
@when receiving an unexpected imsg, print its name.

with help and ideas from eric@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.118 2011/10/27 14:32:57 chl Exp $	*/
d68 2
a69 1
	struct ssl		*ssl;
a82 1
			s->batch = rq_batch;
a88 2
			else
				s->host = NULL;
a92 9
			/* have cert? */
			s->cert = strdup(rq_batch->relay.cert);
			if (s->cert == NULL)
				fatal(NULL);
			else if (s->cert[0] == '\0') {
				free(s->cert);
				s->cert = NULL;
			}

a106 1

d109 1
a109 1

d111 1
a111 1
				/* client_* API by default requires STARTTLS */
a112 1

d117 8
d128 3
a132 1

d148 3
a150 1
 			TAILQ_INSERT_TAIL(&s->recipients, e, entry);
d155 6
a160 1
			mta_pickup(mta_lookup(rq_batch->b_id), NULL);
d165 7
a171 1
			mta_pickup(mta_lookup(rq_batch->b_id), &imsg->fd);
d464 1
a464 13
		/* lookup SSL certificate */
		if (s->cert) {
			struct ssl	 key, *res;

			strlcpy(key.ssl_name, s->cert, sizeof(key.ssl_name));
			res = SPLAY_FIND(ssltree, env->sc_ssl, &key);
			if (res == NULL) {
				client_close(pcb);
				s->pcb = NULL;
				mta_status(s, "190 certificate not found");
				mta_enter_state(s, MTA_DONE, NULL);
				break;
			}
d466 2
a467 2
			    res->ssl_cert, res->ssl_cert_len,
			    res->ssl_key, res->ssl_key_len);
a525 1
		free(s->cert);
a572 10
		break;

	case MTA_DATA:
		/* QUEUE replied to body fd request. */
		if (*(int *)p == -1)
			fatalx("mta cannot obtain msgfd");
		s->datafp = fdopen(*(int *)p, "r");
		if (s->datafp == NULL)
			fatal("fdopen");
		mta_enter_state(s, MTA_CONNECT, NULL);
@


1.118
log
@Use PRI{x,d}64 in format strings instead of %llx, %lld or %qd to print {u_,}int64_t or time_t

While there, cast some time_t to int64_t

These will fix build warnings for portable smptd

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.117 2011/10/23 17:09:56 eric Exp $	*/
d27 1
d244 1
a244 1
	fatalx("mta_imsg: unexpected imsg");
@


1.117
log
@plug leak

spotted by chl@@

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.116 2011/10/23 15:36:53 eric Exp $	*/
d30 1
d706 1
a706 1
	log_info("%016llx: to=<%s@@%s>, delay=%lld, relay=%s [%s], stat=%s (%s)",
d709 1
a709 1
	    (long long int) (time(NULL) - e->creation),
@


1.116
log
@a few important fixes:

- use correct endianness when dumping/loading port
- use the right flag set when dumping/loading flags
- keep and use the authmap name when needed, rather than an id that
  might change when smtpd is restarted
- dump/load the authmap name with the envelope
- remove the rule struct from rq_batch as only the relay info is useful

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.115 2011/10/23 09:30:07 gilles Exp $	*/
d523 1
@


1.115
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.114 2011/10/09 18:39:53 eric Exp $	*/
d83 2
a84 2
			if (rq_batch->rule.r_action == A_RELAYVIA) {
				s->host = strdup(rq_batch->rule.r_value.relayhost.hostname);
d91 1
a91 1
			s->port = ntohs(rq_batch->rule.r_value.relayhost.port); /* XXX */
d94 1
a94 1
			s->cert = strdup(rq_batch->rule.r_value.relayhost.cert);
d103 2
a104 2
			if ((rq_batch->rule.r_value.relayhost.flags & F_SSL) &&
			    (rq_batch->rule.r_value.relayhost.flags & F_AUTH)) {
d106 3
a108 1
				s->secmapid = rq_batch->rule.r_value.relayhost.secmapid;
d112 1
a112 1
			switch (rq_batch->rule.r_value.relayhost.flags & F_SSL) {
d359 1
a359 1
		secret.secmapid = s->secmapid;
@


1.114
log
@show messages sent between processes in debug mode

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.113 2011/08/29 21:43:09 chl Exp $	*/
d139 2
a140 2
			strlcpy(e->delivery.errorline, "000 init",
			    sizeof(e->delivery.errorline));
d143 1
a143 1
				s->host = strdup(e->delivery.rcpt.domain);
d483 3
a485 3
		if (e->delivery.from.user[0] && e->delivery.from.domain[0])
			client_sender(pcb, "%s@@%s", e->delivery.from.user,
			    e->delivery.from.domain);
d491 2
a492 2
			client_rcpt(pcb, e, "%s@@%s", e->delivery.rcpt.user,
			    e->delivery.rcpt.domain);
d687 1
a687 1
	if (*status != '2' && strncmp(e->delivery.errorline, status, 3) > 0)
d691 3
a693 3
	log_debug("mta: new status for %s@@%s: %s", e->delivery.rcpt.user,
	    e->delivery.rcpt.domain, status);
	strlcpy(e->delivery.errorline, status, sizeof(e->delivery.errorline));
d700 1
a700 1
	char			*status = e->delivery.errorline;
d703 3
a705 3
	    e->delivery.id, e->delivery.rcpt.user,
	    e->delivery.rcpt.domain,
	    (long long int) (time(NULL) - e->delivery.creation),
d717 1
a717 1
	switch (e->delivery.errorline[0]) {
d720 1
a720 1
		e->delivery.status = DS_PERMFAILURE;
d723 1
a723 1
		e->delivery.status = DS_ACCEPTED;
d726 1
a726 1
		e->delivery.status = DS_TEMPFAILURE;
d750 1
a750 1
	rq_batch.msgid = evpid_to_msgid(e->delivery.id);
@


1.113
log
@cast all printed time_t to long long int, and change format string accordingly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.112 2011/08/29 18:49:29 chl Exp $	*/
d67 2
@


1.112
log
@add missing header needed by signal()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.111 2011/08/26 14:39:47 chl Exp $	*/
d700 1
a700 1
	log_info("%016llx: to=<%s@@%s>, delay=%d, relay=%s [%s], stat=%s (%s)",
d702 2
a703 1
	    e->delivery.rcpt.domain, time(NULL) - e->delivery.creation,
@


1.111
log
@add missing header needed by time()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.110 2011/07/20 10:22:54 eric Exp $	*/
d32 1
@


1.110
log
@Fix reporting of permanent/temporary failures for MX lookups.
Simplify code a bit while there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.109 2011/07/19 13:15:54 eric Exp $	*/
d35 1
@


1.109
log
@Re-add the test which is needed in the case where the session fails
early (in MX or SECRET) and the data file is not yet opened.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.108 2011/07/06 20:56:16 gilles Exp $	*/
d555 9
a563 9
		error = *(int *)p;
		if (error == EAI_AGAIN) {
			mta_status(s, "100 MX lookup failed temporarily");
			mta_enter_state(s, MTA_DONE, NULL);
		} else if (error == EAI_NONAME) {
			mta_status(s, "600 Domain does not exist");
			mta_enter_state(s, MTA_DONE, NULL);
		} else if (error) {
			mta_status(s, "600 Unable to resolve DNS for domain");
@


1.108
log
@fix that fscking "fgetln(): bad file descriptor" bug experienced by many.

long story short: datafp is reused by the possibly multiple client sessions
of a MTA session. fclosing it in client_close() will cause the file pointer
to be invalidated as soon as we fail the primary MX and attempt the second.

bug introduced while trying to fix a leak causing a crash for a user, now
smtpd will unconditionnally fclose() in MTA_DONE and if a leak still exists
then we should track why the mta session doesnt reach MTA_DONE.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.107 2011/05/21 18:39:03 gilles Exp $	*/
d514 2
a515 1
		fclose(s->datafp);
@


1.107
log
@remove annoying log_debug()
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.106 2011/05/16 21:05:52 gilles Exp $	*/
d514 1
a514 2
		if (s->datafp)
			fclose(s->datafp);
@


1.106
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.105 2011/05/01 12:57:11 eric Exp $	*/
a98 2
			log_debug("host: %s", rq_batch->rule.r_value.relayhost.hostname);
			log_debug("flags: %d", rq_batch->rule.r_value.relayhost.flags);
@


1.105
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.104 2011/04/17 13:36:07 gilles Exp $	*/
d61 1
a61 1
	struct envelope		*m;
d99 2
d131 4
a134 4
			m = imsg->data;
			s = mta_lookup(m->batch_id);
			m = malloc(sizeof *m);
			if (m == NULL)
d136 3
a138 3
			*m = *(struct envelope *)imsg->data;
			strlcpy(m->session_errorline, "000 init",
			    sizeof(m->session_errorline));
d141 1
a141 1
				s->host = strdup(m->recipient.domain);
d145 1
a145 1
 			TAILQ_INSERT_TAIL(&s->recipients, m, entry);
d342 1
a342 1
	struct envelope		*m;
d480 4
a483 4
		m = TAILQ_FIRST(&s->recipients);
		if (m->sender.user[0] && m->sender.domain[0])
			client_sender(pcb, "%s@@%s", m->sender.user,
			    m->sender.domain);
d488 3
a490 3
		TAILQ_FOREACH(m, &s->recipients, entry)
			client_rcpt(pcb, m, "%s@@%s", m->recipient.user,
			    m->recipient.domain);
d503 2
a504 2
		while ((m = TAILQ_FIRST(&s->recipients)))
			mta_message_done(s, m);
d653 1
a653 1
	struct envelope		*m, *next;
d661 2
a662 2
	for (m = TAILQ_FIRST(&s->recipients); m; m = next) {
		next = TAILQ_NEXT(m, entry);
d665 1
a665 1
		mta_message_status(m, status);
d669 2
a670 2
			mta_message_log(s, m);
			mta_message_done(s, m);
d678 1
a678 1
mta_message_status(struct envelope *m, char *status)
d685 1
a685 1
	if (*status != '2' && strncmp(m->session_errorline, status, 3) > 0)
d689 3
a691 3
	log_debug("mta: new status for %s@@%s: %s", m->recipient.user,
	    m->recipient.domain, status);
	strlcpy(m->session_errorline, status, sizeof(m->session_errorline));
d695 1
a695 1
mta_message_log(struct mta_session *s, struct envelope *m)
d698 1
a698 1
	char			*status = m->session_errorline;
d701 2
a702 2
	    m->evpid, m->recipient.user,
	    m->recipient.domain, time(NULL) - m->creation,
d712 1
a712 1
mta_message_done(struct mta_session *s, struct envelope *m)
d714 1
a714 1
	switch (m->session_errorline[0]) {
d717 1
a717 1
		m->status = S_MESSAGE_PERMFAILURE;
d720 1
a720 1
		m->status = S_MESSAGE_ACCEPTED;
d723 1
a723 1
		m->status = S_MESSAGE_TEMPFAILURE;
d727 3
a729 3
	    IMSG_QUEUE_MESSAGE_UPDATE, 0, 0, -1, m, sizeof(*m));
	TAILQ_REMOVE(&s->recipients, m, entry);
	free(m);
d742 1
a742 1
	struct envelope	*m;
d744 1
a744 1
	m = TAILQ_FIRST(&s->recipients);
d747 1
a747 1
	rq_batch.msgid = evpid_to_msgid(m->evpid);
@


1.104
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.103 2011/04/17 11:39:22 gilles Exp $	*/
d41 1
a41 1
static void mta_imsg(struct smtpd *, struct imsgev *, struct imsg *);
d44 1
a44 1
static struct mta_session *mta_lookup(struct smtpd *, u_int64_t);
d56 1
a56 1
mta_imsg(struct smtpd *env, struct imsgev *iev, struct imsg *imsg)
a75 1
			s->env = env;
d130 1
a130 1
			s = mta_lookup(env, m->batch_id);
d148 1
a148 1
			mta_pickup(mta_lookup(env, rq_batch->b_id), NULL);
d153 1
a153 1
			mta_pickup(mta_lookup(env, rq_batch->b_id), &imsg->fd);
d162 1
a162 1
			mta_pickup(mta_lookup(env, secret->id), secret->secret);
d167 1
a167 1
			s = mta_lookup(env, dns->id);
d177 1
a177 1
			mta_pickup(mta_lookup(env, dns->id), &dns->error);
d182 1
a182 1
			s = mta_lookup(env, dns->id);
d260 1
a260 1
mta(struct smtpd *env)
d284 1
a284 1
	purge_config(env, PURGE_EVERYTHING);
d303 2
a304 2
	signal_set(&ev_sigint, SIGINT, mta_sig_handler, env);
	signal_set(&ev_sigterm, SIGTERM, mta_sig_handler, env);
d310 2
a311 2
	config_pipes(env, peers, nitems(peers));
	config_peers(env, peers, nitems(peers));
d313 1
a313 1
	ramqueue_init(env, &env->sc_rqueue);
d324 1
a324 1
mta_lookup(struct smtpd *env, u_int64_t id)
d355 1
a355 1
		imsg_compose_event(s->env->sc_ievs[PROC_LKA], IMSG_LKA_SECRET,
d364 1
a364 1
			dns_query_host(s->env, s->host, s->port, s->id);
d366 1
a366 1
			dns_query_mx(s->env, s->host, 0, s->id);
d435 1
a435 1
		dns_query_ptr(s->env, &relay->sa, s->id);
d444 1
a444 1
		pcb = client_init(s->fd, s->datafp, s->env->sc_hostname, 1);
d451 1
a451 1
			res = SPLAY_FIND(ssltree, s->env->sc_ssl, &key);
d504 1
a504 1
		imsg_compose_event(s->env->sc_ievs[PROC_QUEUE],
d508 1
a508 1
		SPLAY_REMOVE(mtatree, &s->env->mta_sessions, s);
d724 1
a724 1
	imsg_compose_event(s->env->sc_ievs[PROC_QUEUE],
d746 1
a746 1
	imsg_compose_event(s->env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_FD,
@


1.103
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.102 2011/04/15 17:01:05 gilles Exp $	*/
d41 13
a53 1
void			 mta_imsg(struct smtpd *, struct imsgev *, struct imsg *);
d55 1
a55 16
__dead void		 mta_shutdown(void);
void			 mta_sig_handler(int, short, void *);

struct mta_session	*mta_lookup(struct smtpd *, u_int64_t);
void			 mta_enter_state(struct mta_session *, int, void *);
void			 mta_pickup(struct mta_session *, void *);
void			 mta_event(int, short, void *);

void			 mta_status(struct mta_session *, const char *, ...);
void			 mta_message_status(struct envelope *, char *);
void			 mta_message_log(struct mta_session *, struct envelope *);
void			 mta_message_done(struct mta_session *, struct envelope *);
void			 mta_connect_done(int, short, void *);
void			 mta_request_datafd(struct mta_session *);

void
d240 1
a240 1
void
d253 1
a253 1
void
d324 1
a324 7
int
mta_session_cmp(struct mta_session *a, struct mta_session *b)
{
	return (a->id < b->id ? -1 : a->id > b->id);
}

struct mta_session *
d335 1
a335 1
void
d529 1
a529 1
void
d600 1
a600 1
void
d648 1
a648 1
void
d676 1
a676 1
void
d693 1
a693 1
void
d710 1
a710 1
void
d731 1
a731 1
void
d737 1
a737 1
void
d749 6
@


1.102
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.101 2011/04/13 20:53:18 gilles Exp $	*/
d52 3
a54 3
void			 mta_message_status(struct message *, char *);
void			 mta_message_log(struct mta_session *, struct message *);
void			 mta_message_done(struct mta_session *, struct message *);
d64 1
a64 1
	struct message		*m;
d138 1
a138 1
			*m = *(struct message *)imsg->data;
d350 1
a350 1
	struct message		*m;
d661 1
a661 1
	struct message		*m, *next;
d686 1
a686 1
mta_message_status(struct message *m, char *status)
d703 1
a703 1
mta_message_log(struct mta_session *s, struct message *m)
d720 1
a720 1
mta_message_done(struct mta_session *s, struct message *m)
d750 1
a750 1
	struct message	*m;
@


1.101
log
@following an idea from jacekm@@, smtpd now uses a ram-queue instead of doing
a continuous walk on the disk-queue. the implementation differs from what
jacekm@@ commited (and I backed out) a while ago in that it uses a queue and
a host tree required for upcoming features.

code will be improved in tree, it requires changes to be done in queue and
bounce API, I just wanted to commit a working version first ...

tested by todd@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.100 2011/03/26 17:43:01 gilles Exp $	*/
d708 2
a709 2
	log_info("%s: to=<%s@@%s>, delay=%d, relay=%s [%s], stat=%s (%s)",
	    m->message_id, m->recipient.user,
d752 2
d755 1
a755 2
	m = TAILQ_FIRST(&s->recipients);
	strlcpy(rq_batch.m_id, m->message_id, sizeof(rq_batch.m_id));
@


1.100
log
@check that we actually have a stdio stream opened for the message before
trying to close it in a mta session. in case of DNS errors; this pointer
will remain NULL and cause a segv in MTA_DONE state.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.99 2011/03/26 10:59:59 gilles Exp $	*/
d61 1
a65 1
	struct batch		*b;
d72 2
a73 1
			b = imsg->data;
d77 1
a77 1
			s->id = b->id;
d80 1
d83 2
a84 2
			if (b->rule.r_action == A_RELAYVIA) {
				s->host = strdup(b->rule.r_value.relayhost.hostname);
d88 1
a88 3
				s->host = strdup(b->hostname);
			if (s->host == NULL)
				fatal(NULL);
d91 1
a91 1
			s->port = ntohs(b->rule.r_value.relayhost.port); /* XXX */
d94 1
a94 1
			s->cert = strdup(b->rule.r_value.relayhost.cert);
d103 2
a104 2
			if ((b->rule.r_value.relayhost.flags & F_SSL) &&
			    (b->rule.r_value.relayhost.flags & F_AUTH)) {
d106 1
a106 1
				s->secmapid = b->rule.r_value.relayhost.secmapid;
d110 1
a110 1
			switch (b->rule.r_value.relayhost.flags & F_SSL) {
d131 1
d141 6
d151 2
a152 2
			b = imsg->data;
			mta_pickup(mta_lookup(env, b->id), NULL);
d156 2
a157 2
			b = imsg->data;
			mta_pickup(mta_lookup(env, b->id), &imsg->fd);
d317 1
d749 1
a749 1
	struct batch	 b;
d752 1
a752 1
	b.id = s->id;
d754 1
a754 1
	strlcpy(b.message_id, m->message_id, sizeof(b.message_id));
d756 1
a756 1
	    0, 0, -1, &b, sizeof(b));
@


1.99
log
@have the client API receive a stdio stream rather than a fd to the message
fd. this shifts responsibility for the fclose to the caller, prevents a
memory leak and makes everyone happy.

diff by Jared Yanovich, thanks !
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.98 2011/03/21 13:02:52 gilles Exp $	*/
d515 4
a518 1
		fclose(s->datafp);
@


1.98
log
@- reset smtp_client pointer to NULL after client_close()
- datafd is closed in client_close()
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.97 2010/11/29 15:25:55 gilles Exp $	*/
a78 1
			s->datafd = -1;
d446 1
a446 1
		pcb = client_init(s->fd, s->datafd, s->env->sc_hostname, 1);
d515 1
d570 1
a570 2
		s->datafd = *(int *)p;
		if (s->datafd == -1)
d572 4
a575 2
		else
			mta_enter_state(s, MTA_CONNECT, NULL);
@


1.97
log
@replace the fork-based-non-blocking-resolver-hack by shiny async resolver
written by eric@@. it is still experimental but still better than what we
had earlier so ... we'll improve in tree :)

diff by me with *lots* of help from eric@@, tested by todd and I (and a
few people out there)
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.96 2010/11/28 14:35:58 gilles Exp $	*/
d457 1
a515 1
		close(s->datafd);
@


1.96
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.95 2010/11/28 13:56:43 gilles Exp $	*/
d82 1
a82 1
			if (b->rule.r_action == A_RELAYVIA)
d84 2
d163 1
a163 1
		case IMSG_DNS_A:
d173 1
a173 1
		case IMSG_DNS_A_END:
d366 4
a369 1
		dns_query_mx(s->env, s->host, 0, s->id);
@


1.95
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.94 2010/10/29 09:16:07 gilles Exp $	*/
a26 3
#include <netinet/in.h>
#include <arpa/inet.h>

a31 1
#include <signal.h>
a34 1
#include <time.h>
@


1.94
log
@smtpd no longer knows a map called "secrets" which holds credentials for
authenticated relaying. one can create many maps holding credentials and
name them however he/she wants, just like any other map.

teach smtpd how to select a credentials map at the rule-level allowing a
setup to relay through the same MX with different credentials depending
on the source.

smtpd.conf.5 updated to reflect changes with help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.93 2010/10/09 22:05:35 gilles Exp $	*/
d32 1
d44 1
@


1.93
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.87 2010/04/21 18:54:43 jacekm Exp $	*/
d106 1
a106 1
			    (b->rule.r_value.relayhost.flags & F_AUTH))
d108 2
d357 1
@


1.92
log
@check event_dispatch() return value

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.91 2010/06/01 23:06:23 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009-2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
a42 1
#include "queue_backend.h"
d49 1
a49 1
struct mta_session	*mta_lookup(struct smtpd *, u_int32_t);
d55 3
a57 3
void			 mta_rcpt_status(struct recipient *, char *);
void			 mta_rcpt_log(struct mta_session *, struct recipient *);
void			 mta_rcpt_done(struct mta_session *, struct recipient *);
d59 1
a63 1
	struct aux		 aux;
a64 1
	struct recipient	*rcpt;
d66 3
a68 1
	struct action		*action;
d75 1
a75 2
			if (imsg->fd < 0)
				fatalx("mta: fd pass fail");
d79 47
a127 6
			s->id = imsg->hdr.peerid;
			s->state = MTA_INIT;
			s->env = env;
			s->datafd = imsg->fd;
			memcpy(&s->content_id, imsg->data,
			    sizeof s->content_id);
d132 4
a135 15
			action = imsg->data;
			s = mta_lookup(env, imsg->hdr.peerid);
			if (s->auxraw == NULL) {
				/*
				 * XXX: queue can batch together actions with
				 * different relay params.
				 */
				s->auxraw = strdup(action->data);
				if (s->auxraw == NULL)
					fatal(NULL);
				auxsplit(&s->aux, s->auxraw);
			}
			auxsplit(&aux, action->data);
			rcpt = malloc(sizeof *rcpt + strlen(aux.rcpt));
			if (rcpt == NULL)
d137 4
a140 4
			rcpt->action_id = action->id;
			strlcpy(rcpt->address, aux.rcpt, strlen(aux.rcpt) + 1);
			strlcpy(rcpt->status, "000 init", sizeof rcpt->status);
 			TAILQ_INSERT_TAIL(&s->recipients, rcpt, entry);
d144 7
a150 3
			s = mta_lookup(env, imsg->hdr.peerid);
			memcpy(&s->birth, imsg->data, sizeof s->birth);
			mta_pickup(s, NULL);
d158 2
a159 1
			mta_pickup(mta_lookup(env, imsg->hdr.peerid), imsg->data);
d326 1
a326 1
mta_lookup(struct smtpd *env, u_int32_t id)
d331 1
a331 2
	res = SPLAY_FIND(mtatree, &env->mta_sessions, &key);
	if (res == NULL)
d333 1
a333 1
	return res;
d339 1
d342 1
a342 1
	struct recipient	*rcpt;
a343 1
	char			*host;
d353 3
a355 6
		if (s->aux.relay_via[0])
			host = s->aux.relay_via;
		else {
			rcpt = TAILQ_FIRST(&s->recipients);
			host = strchr(rcpt->address, '@@') + 1;
		}
d357 1
a357 1
		    s->id, 0, -1, host, strlen(host) + 1);
d364 9
a372 7
		if (s->aux.relay_via[0])
			host = s->aux.relay_via;
		else {
			rcpt = TAILQ_FIRST(&s->recipients);
			host = strchr(rcpt->address, '@@') + 1;
		}
		dns_query_mx(s->env, host, 0, s->id);
d379 1
a379 1
		if (strcmp(s->aux.ssl, "ssl") == 0)
d396 6
a401 7
			if (s->aux.port[0])
				sa_set_port(sa, s->aux.port);
			else if (strcmp(s->aux.ssl, "ssl") == 0 &&
			    relay->used == 1)
				sa_set_port(sa, "465");
			else if (strcmp(s->aux.ssl, "smtps") == 0)
				sa_set_port(sa, "465");
d403 1
a403 1
				sa_set_port(sa, "25");
d407 1
a407 1
				fatal("socket");
d413 1
a413 1
					mta_status(s, "110 connect: %s",
d445 2
a446 2
		if (s->aux.cert[0]) {
			struct ssl key, *res;
d448 1
a448 1
			strlcpy(key.ssl_name, s->aux.cert, sizeof key.ssl_name);
d463 1
a463 1
		if (strcmp(s->aux.ssl, "ssl") == 0 && relay->used == 1)
d465 1
a465 1
		else if (strcmp(s->aux.ssl, "smtps") == 0)
d467 1
a467 1
		else if (s->aux.ssl[0] == '\0')
d475 4
a478 2
		if (s->aux.mail_from[0])
			client_sender(pcb, "%s", s->aux.mail_from);
d483 3
a485 2
		TAILQ_FOREACH(rcpt, &s->recipients, entry)
			client_rcpt(pcb, rcpt, "%s", rcpt->address);
d498 2
a499 2
		while ((rcpt = TAILQ_FIRST(&s->recipients)))
			mta_rcpt_done(s, rcpt);
d502 1
a502 1
		    IMSG_BATCH_DONE, s->id, 0, -1, NULL, 0);
a510 1
		free(s->auxraw);
d512 2
d529 1
a529 1
		if (s->aux.auth[0])
d560 9
d576 1
a576 1
			mta_status(s, "110 connect: %s", strerror(error));
a596 1
	struct recipient	*rcpt;
d609 3
a611 4
		rcpt = pcb->rcptfail;
		mta_rcpt_status(pcb->rcptfail, pcb->reply);
		mta_rcpt_log(s, pcb->rcptfail);
		mta_rcpt_done(s, pcb->rcptfail);
d624 1
a624 2
	if (TAILQ_EMPTY(&s->recipients)) {
		log_debug("%s: leaving", __func__);
d626 1
a626 2
	} else {
		log_debug("%s: connecting to next", __func__);
a627 1
	}
d644 1
a644 1
	struct recipient	*rcpt, *next;
d652 2
a653 2
	for (rcpt = TAILQ_FIRST(&s->recipients); rcpt; rcpt = next) {
		next = TAILQ_NEXT(rcpt, entry);
d656 1
a656 1
		mta_rcpt_status(rcpt, status);
d660 2
a661 2
			mta_rcpt_log(s, rcpt);
			mta_rcpt_done(s, rcpt);
d669 1
a669 1
mta_rcpt_status(struct recipient *rcpt, char *status)
d676 1
a676 1
	if (*status != '2' && strncmp(rcpt->status, status, 3) > 0)
d680 3
a682 2
	log_debug("mta: new status for %s: %s", rcpt->address, status);
	strlcpy(rcpt->status, status, sizeof rcpt->status);
d686 1
a686 1
mta_rcpt_log(struct mta_session *s, struct recipient *rcpt)
d688 2
a689 3
	struct mta_relay *relay;

	relay = TAILQ_FIRST(&s->relays);
d691 3
a693 3
	log_info("%s: to=%s, delay=%d, relay=%s [%s], stat=%s (%s)",
	    queue_be_decode(s->content_id), rcpt->address,
	    time(NULL) - s->birth,
d696 4
a699 4
	    rcpt->status[0] == '2' ? "Sent" :
	    rcpt->status[0] == '5' ? "RemoteError" :
	    rcpt->status[0] == '4' ? "RemoteError" : "LocalError",
	    rcpt->status + 4);
d703 18
a720 14
mta_rcpt_done(struct mta_session *s, struct recipient *rcpt)
{
	struct action *action;

	action = malloc(sizeof *action + strlen(rcpt->status));
	if (action == NULL)
		fatal(NULL);
	action->id = rcpt->action_id;
	strlcpy(action->data, rcpt->status, strlen(rcpt->status) + 1);
	imsg_compose_event(s->env->sc_ievs[PROC_QUEUE], IMSG_BATCH_UPDATE,
	    s->id, 0, -1, action, sizeof *action + strlen(rcpt->status));
	TAILQ_REMOVE(&s->recipients, rcpt, entry);
	free(action);
	free(rcpt);
d727 13
@


1.91
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.89 2010/06/01 11:05:12 jacekm Exp $	*/
d278 2
a279 1
	event_dispatch();
@


1.90
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.87 2010/04/21 18:54:43 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d43 1
d50 1
a50 1
struct mta_session	*mta_lookup(struct smtpd *, u_int64_t);
d56 3
a58 3
void			 mta_message_status(struct message *, char *);
void			 mta_message_log(struct mta_session *, struct message *);
void			 mta_message_done(struct mta_session *, struct message *);
a59 1
void			 mta_request_datafd(struct mta_session *);
d64 1
d66 1
d68 1
a68 3
	struct message		*m;
	struct secret		*secret;
	struct batch		*b;
d75 2
a76 1
			b = imsg->data;
d80 3
a82 1
			s->id = b->id;
d85 3
a87 46
			s->datafd = -1;

			/* establish host name */
			if (b->rule.r_action == A_RELAYVIA)
				s->host = strdup(b->rule.r_value.relayhost.hostname);
			else
				s->host = strdup(b->hostname);
			if (s->host == NULL)
				fatal(NULL);

			/* establish port */
			s->port = ntohs(b->rule.r_value.relayhost.port); /* XXX */

			/* have cert? */
			s->cert = strdup(b->rule.r_value.relayhost.cert);
			if (s->cert == NULL)
				fatal(NULL);
			else if (s->cert[0] == '\0') {
				free(s->cert);
				s->cert = NULL;
			}

			/* use auth? */
			if ((b->rule.r_value.relayhost.flags & F_SSL) &&
			    (b->rule.r_value.relayhost.flags & F_AUTH))
				s->flags |= MTA_USE_AUTH;

			/* force a particular SSL mode? */
			switch (b->rule.r_value.relayhost.flags & F_SSL) {
			case F_SSL:
				s->flags |= MTA_FORCE_ANYSSL;
				break;

			case F_SMTPS:
				s->flags |= MTA_FORCE_SMTPS;

			case F_STARTTLS:
				/* client_* API by default requires STARTTLS */
				break;

			default:
				s->flags |= MTA_ALLOW_PLAIN;
			}

			TAILQ_INIT(&s->recipients);
			TAILQ_INIT(&s->relays);
d92 15
a106 4
			m = imsg->data;
			s = mta_lookup(env, m->batch_id);
			m = malloc(sizeof *m);
			if (m == NULL)
d108 4
a111 4
			*m = *(struct message *)imsg->data;
			strlcpy(m->session_errorline, "000 init",
			    sizeof(m->session_errorline));
 			TAILQ_INSERT_TAIL(&s->recipients, m, entry);
d115 3
a117 7
			b = imsg->data;
			mta_pickup(mta_lookup(env, b->id), NULL);
			return;

		case IMSG_QUEUE_MESSAGE_FD:
			b = imsg->data;
			mta_pickup(mta_lookup(env, b->id), &imsg->fd);
d125 1
a125 2
			secret = imsg->data;
			mta_pickup(mta_lookup(env, secret->id), secret->secret);
d291 1
a291 1
mta_lookup(struct smtpd *env, u_int64_t id)
d296 2
a297 1
	if ((res = SPLAY_FIND(mtatree, &env->mta_sessions, &key)) == NULL)
d299 1
a299 1
	return (res);
a304 1
	struct secret		 secret;
d307 1
a307 1
	struct message		*m;
d309 1
d319 6
a324 3
		bzero(&secret, sizeof(secret));
		secret.id = s->id;
		strlcpy(secret.host, s->host, sizeof(secret.host));
d326 1
a326 1
		    0, 0, -1, &secret, sizeof(secret));  
d333 7
a339 9
		dns_query_mx(s->env, s->host, 0, s->id);
		break;

	case MTA_DATA:
		/*
		 * Obtain message body fd.
		 */
		log_debug("mta: getting datafd");
		mta_request_datafd(s);
d346 1
a346 1
		if (s->flags & MTA_FORCE_ANYSSL)
d363 7
a369 6
			if (s->port)
				sa_set_port(sa, s->port);
			else if ((s->flags & MTA_FORCE_ANYSSL) && relay->used == 1)
				sa_set_port(sa, 465);
			else if (s->flags & MTA_FORCE_SMTPS)
				sa_set_port(sa, 465);
d371 1
a371 1
				sa_set_port(sa, 25);
d375 1
a375 1
				fatal("mta cannot create socket");
d381 1
a381 1
					mta_status(s, "110 connect error: %s",
d413 2
a414 2
		if (s->cert) {
			struct ssl	 key, *res;
d416 1
a416 1
			strlcpy(key.ssl_name, s->cert, sizeof(key.ssl_name));
d431 1
a431 1
		if ((s->flags & MTA_FORCE_ANYSSL) && relay->used == 1)
d433 1
a433 1
		else if (s->flags & MTA_FORCE_SMTPS)
d435 1
a435 1
		else if (s->flags & MTA_ALLOW_PLAIN)
d443 2
a444 4
		m = TAILQ_FIRST(&s->recipients);
		if (m->sender.user[0] && m->sender.domain[0])
			client_sender(pcb, "%s@@%s", m->sender.user,
			    m->sender.domain);
d449 2
a450 3
		TAILQ_FOREACH(m, &s->recipients, entry)
			client_rcpt(pcb, m, "%s@@%s", m->recipient.user,
			    m->recipient.domain);
d463 2
a464 2
		while ((m = TAILQ_FIRST(&s->recipients)))
			mta_message_done(s, m);
d467 1
a467 1
		    IMSG_BATCH_DONE, 0, 0, -1, NULL, 0);
d476 1
a477 2
		free(s->host);
		free(s->cert);
d493 1
a493 1
		if (s->flags & MTA_USE_AUTH)
a523 9
			mta_enter_state(s, MTA_DATA, NULL);
		break;

	case MTA_DATA:
		/* QUEUE replied to body fd request. */
		s->datafd = *(int *)p;
		if (s->datafd == -1)
			fatalx("mta cannot obtain msgfd");
		else
d531 1
a531 1
			mta_status(s, "110 connect error: %s", strerror(error));
d552 1
d565 4
a568 3
		mta_message_status(pcb->rcptfail, pcb->reply);
		mta_message_log(s, pcb->rcptfail);
		mta_message_done(s, pcb->rcptfail);
d581 2
a582 1
	if (TAILQ_EMPTY(&s->recipients))
d584 2
a585 1
	else
d587 1
d604 1
a604 1
	struct message		*m, *next;
d612 2
a613 2
	for (m = TAILQ_FIRST(&s->recipients); m; m = next) {
		next = TAILQ_NEXT(m, entry);
d616 1
a616 1
		mta_message_status(m, status);
d620 2
a621 2
			mta_message_log(s, m);
			mta_message_done(s, m);
d629 1
a629 1
mta_message_status(struct message *m, char *status)
d636 1
a636 1
	if (*status != '2' && strncmp(m->session_errorline, status, 3) > 0)
d640 2
a641 3
	log_debug("mta: new status for %s@@%s: %s", m->recipient.user,
	    m->recipient.domain, status);
	strlcpy(m->session_errorline, status, sizeof(m->session_errorline));
d645 1
a645 1
mta_message_log(struct mta_session *s, struct message *m)
d647 3
a649 2
	struct mta_relay	*relay = TAILQ_FIRST(&s->relays);
	char			*status = m->session_errorline;
d651 3
a653 3
	log_info("%s: to=<%s@@%s>, delay=%d, relay=%s [%s], stat=%s (%s)",
	    m->message_id, m->recipient.user,
	    m->recipient.domain, time(NULL) - m->creation,
d656 4
a659 4
	    *status == '2' ? "Sent" :
	    *status == '5' ? "RemoteError" :
	    *status == '4' ? "RemoteError" : "LocalError",
	    status + 4);
d663 14
a676 18
mta_message_done(struct mta_session *s, struct message *m)
{
	switch (m->session_errorline[0]) {
	case '6':
	case '5':
		m->status = S_MESSAGE_PERMFAILURE;
		break;
	case '2':
		m->status = S_MESSAGE_ACCEPTED;
		break;
	default:
		m->status = S_MESSAGE_TEMPFAILURE;
		break;
	}
	imsg_compose_event(s->env->sc_ievs[PROC_QUEUE],
	    IMSG_QUEUE_MESSAGE_UPDATE, 0, 0, -1, m, sizeof(*m));
	TAILQ_REMOVE(&s->recipients, m, entry);
	free(m);
a682 13
}

void
mta_request_datafd(struct mta_session *s)
{
	struct batch	 b;
	struct message	*m;

	b.id = s->id;
	m = TAILQ_FIRST(&s->recipients);
	strlcpy(b.message_id, m->message_id, sizeof(b.message_id));
	imsg_compose_event(s->env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_FD,
	    0, 0, -1, &b, sizeof(b));
@


1.89
log
@Better errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.88 2010/05/31 23:38:56 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009-2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
a42 1
#include "queue_backend.h"
d49 1
a49 1
struct mta_session	*mta_lookup(struct smtpd *, u_int32_t);
d55 3
a57 3
void			 mta_rcpt_status(struct recipient *, char *);
void			 mta_rcpt_log(struct mta_session *, struct recipient *);
void			 mta_rcpt_done(struct mta_session *, struct recipient *);
d59 1
a63 1
	struct aux		 aux;
a64 1
	struct recipient	*rcpt;
d66 3
a68 1
	struct action		*action;
a70 1
	size_t			 rcpt_sz;
d75 1
a75 2
			if (imsg->fd < 0)
				fatalx("mta: fd pass fail");
d79 47
a127 6
			s->id = imsg->hdr.peerid;
			s->state = MTA_INIT;
			s->env = env;
			s->datafd = imsg->fd;
			memcpy(&s->content_id, imsg->data,
			    sizeof s->content_id);
d132 4
a135 16
			action = imsg->data;
			s = mta_lookup(env, imsg->hdr.peerid);
			if (s->auxraw == NULL) {
				/*
				 * XXX: queue can batch together actions with
				 * different relay params.
				 */
				s->auxraw = strdup(action->arg);
				if (s->auxraw == NULL)
					fatal(NULL);
				auxsplit(&s->aux, s->auxraw);
			}
			auxsplit(&aux, action->arg);
			rcpt_sz = sizeof *rcpt + strlen(aux.rcpt) + 1;
			rcpt = malloc(rcpt_sz);
			if (rcpt == NULL)
d137 4
a140 4
			rcpt->action_id = action->id;
			strlcpy(rcpt->address, aux.rcpt, rcpt_sz - sizeof *rcpt);
			strlcpy(rcpt->status, "000 init", sizeof rcpt->status);
 			TAILQ_INSERT_TAIL(&s->recipients, rcpt, entry);
d144 7
a150 3
			s = mta_lookup(env, imsg->hdr.peerid);
			memcpy(&s->birth, imsg->data, sizeof s->birth);
			mta_pickup(s, NULL);
d158 2
a159 1
			mta_pickup(mta_lookup(env, imsg->hdr.peerid), imsg->data);
d325 1
a325 1
mta_lookup(struct smtpd *env, u_int32_t id)
d330 1
a330 2
	res = SPLAY_FIND(mtatree, &env->mta_sessions, &key);
	if (res == NULL)
d332 1
a332 1
	return res;
d338 1
d341 1
a341 1
	struct recipient	*rcpt;
a342 1
	char			*host;
d352 3
a354 6
		if (s->aux.relay_via[0])
			host = s->aux.relay_via;
		else {
			rcpt = TAILQ_FIRST(&s->recipients);
			host = strchr(rcpt->address, '@@') + 1;
		}
d356 1
a356 1
		    s->id, 0, -1, host, strlen(host) + 1);
d363 9
a371 7
		if (s->aux.relay_via[0])
			host = s->aux.relay_via;
		else {
			rcpt = TAILQ_FIRST(&s->recipients);
			host = strchr(rcpt->address, '@@') + 1;
		}
		dns_query_mx(s->env, host, 0, s->id);
d378 1
a378 1
		if (strcmp(s->aux.ssl, "ssl") == 0)
d395 6
a400 7
			if (s->aux.port[0])
				sa_set_port(sa, s->aux.port);
			else if (strcmp(s->aux.ssl, "ssl") == 0 &&
			    relay->used == 1)
				sa_set_port(sa, "465");
			else if (strcmp(s->aux.ssl, "smtps") == 0)
				sa_set_port(sa, "465");
d402 1
a402 1
				sa_set_port(sa, "25");
d406 1
a406 1
				fatal("socket");
d412 1
a412 1
					mta_status(s, "110 connect: %s",
d444 2
a445 2
		if (s->aux.cert[0]) {
			struct ssl key, *res;
d447 1
a447 1
			strlcpy(key.ssl_name, s->aux.cert, sizeof key.ssl_name);
d462 1
a462 1
		if (strcmp(s->aux.ssl, "ssl") == 0 && relay->used == 1)
d464 1
a464 1
		else if (strcmp(s->aux.ssl, "smtps") == 0)
d466 1
a466 1
		else if (s->aux.ssl[0] == '\0')
d474 4
a477 2
		if (s->aux.mail_from[0])
			client_sender(pcb, "%s", s->aux.mail_from);
d482 3
a484 2
		TAILQ_FOREACH(rcpt, &s->recipients, entry)
			client_rcpt(pcb, rcpt, "%s", rcpt->address);
d497 2
a498 2
		while ((rcpt = TAILQ_FIRST(&s->recipients)))
			mta_rcpt_done(s, rcpt);
d501 1
a501 1
		    IMSG_BATCH_DONE, s->id, 0, -1, NULL, 0);
a509 1
		free(s->auxraw);
d511 2
d528 1
a528 1
		if (s->aux.auth[0])
d559 9
d575 1
a575 1
			mta_status(s, "110 connect: %s", strerror(error));
a595 1
	struct recipient	*rcpt;
d608 3
a610 4
		rcpt = pcb->rcptfail;
		mta_rcpt_status(pcb->rcptfail, pcb->reply);
		mta_rcpt_log(s, pcb->rcptfail);
		mta_rcpt_done(s, pcb->rcptfail);
d623 1
a623 2
	if (TAILQ_EMPTY(&s->recipients)) {
		log_debug("%s: leaving", __func__);
d625 1
a625 2
	} else {
		log_debug("%s: connecting to next", __func__);
a626 1
	}
d643 1
a643 1
	struct recipient	*rcpt, *next;
d651 2
a652 2
	for (rcpt = TAILQ_FIRST(&s->recipients); rcpt; rcpt = next) {
		next = TAILQ_NEXT(rcpt, entry);
d655 1
a655 1
		mta_rcpt_status(rcpt, status);
d659 2
a660 2
			mta_rcpt_log(s, rcpt);
			mta_rcpt_done(s, rcpt);
d668 1
a668 1
mta_rcpt_status(struct recipient *rcpt, char *status)
d675 1
a675 1
	if (*status != '2' && strncmp(rcpt->status, status, 3) > 0)
d679 3
a681 2
	log_debug("mta: new status for %s: %s", rcpt->address, status);
	strlcpy(rcpt->status, status, sizeof rcpt->status);
d685 1
a685 1
mta_rcpt_log(struct mta_session *s, struct recipient *rcpt)
d687 2
a688 3
	struct mta_relay *relay;

	relay = TAILQ_FIRST(&s->relays);
d690 3
a692 3
	log_info("%s: to=%s, delay=%d, relay=%s [%s], stat=%s (%s)",
	    queue_be_decode(s->content_id), rcpt->address,
	    time(NULL) - s->birth,
d695 4
a698 4
	    rcpt->status[0] == '2' ? "Sent" :
	    rcpt->status[0] == '5' ? "RemoteError" :
	    rcpt->status[0] == '4' ? "RemoteError" : "LocalError",
	    rcpt->status + 4);
d702 18
a719 16
mta_rcpt_done(struct mta_session *s, struct recipient *rcpt)
{
	struct action *action;
	int action_sz;

	action_sz = sizeof *action + strlen(rcpt->status) + 1;
	action = malloc(action_sz);
	if (action == NULL)
		fatal(NULL);
	action->id = rcpt->action_id;
	strlcpy(action->arg, rcpt->status, action_sz - sizeof *action);
	imsg_compose_event(s->env->sc_ievs[PROC_QUEUE], IMSG_BATCH_UPDATE,
	    s->id, 0, -1, action, action_sz);
	TAILQ_REMOVE(&s->recipients, rcpt, entry);
	free(action);
	free(rcpt);
d726 13
@


1.88
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.87 2010/04/21 18:54:43 jacekm Exp $	*/
d383 1
a383 1
					mta_status(s, "110 connect error: %s",
d533 1
a533 1
			mta_status(s, "110 connect error: %s", strerror(error));
@


1.87
log
@Runner process is just a helper for queue, so tear down its imsg
channels to parent, mda, mta, lka, smtp, and control.  This leaves
just the channel to queue, which forwards imsgs on runner's behalf
and redirects any replies back to it.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.86 2010/04/21 08:29:01 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d43 1
d50 1
a50 1
struct mta_session	*mta_lookup(struct smtpd *, u_int64_t);
d56 3
a58 3
void			 mta_message_status(struct message *, char *);
void			 mta_message_log(struct mta_session *, struct message *);
void			 mta_message_done(struct mta_session *, struct message *);
a59 1
void			 mta_request_datafd(struct mta_session *);
d64 1
d66 1
d68 1
a68 3
	struct message		*m;
	struct secret		*secret;
	struct batch		*b;
d71 1
d76 2
a77 1
			b = imsg->data;
d81 3
a83 1
			s->id = b->id;
d86 3
a88 46
			s->datafd = -1;

			/* establish host name */
			if (b->rule.r_action == A_RELAYVIA)
				s->host = strdup(b->rule.r_value.relayhost.hostname);
			else
				s->host = strdup(b->hostname);
			if (s->host == NULL)
				fatal(NULL);

			/* establish port */
			s->port = ntohs(b->rule.r_value.relayhost.port); /* XXX */

			/* have cert? */
			s->cert = strdup(b->rule.r_value.relayhost.cert);
			if (s->cert == NULL)
				fatal(NULL);
			else if (s->cert[0] == '\0') {
				free(s->cert);
				s->cert = NULL;
			}

			/* use auth? */
			if ((b->rule.r_value.relayhost.flags & F_SSL) &&
			    (b->rule.r_value.relayhost.flags & F_AUTH))
				s->flags |= MTA_USE_AUTH;

			/* force a particular SSL mode? */
			switch (b->rule.r_value.relayhost.flags & F_SSL) {
			case F_SSL:
				s->flags |= MTA_FORCE_ANYSSL;
				break;

			case F_SMTPS:
				s->flags |= MTA_FORCE_SMTPS;

			case F_STARTTLS:
				/* client_* API by default requires STARTTLS */
				break;

			default:
				s->flags |= MTA_ALLOW_PLAIN;
			}

			TAILQ_INIT(&s->recipients);
			TAILQ_INIT(&s->relays);
d93 16
a108 4
			m = imsg->data;
			s = mta_lookup(env, m->batch_id);
			m = malloc(sizeof *m);
			if (m == NULL)
d110 4
a113 4
			*m = *(struct message *)imsg->data;
			strlcpy(m->session_errorline, "000 init",
			    sizeof(m->session_errorline));
 			TAILQ_INSERT_TAIL(&s->recipients, m, entry);
d117 3
a119 7
			b = imsg->data;
			mta_pickup(mta_lookup(env, b->id), NULL);
			return;

		case IMSG_QUEUE_MESSAGE_FD:
			b = imsg->data;
			mta_pickup(mta_lookup(env, b->id), &imsg->fd);
d127 1
a127 2
			secret = imsg->data;
			mta_pickup(mta_lookup(env, secret->id), secret->secret);
d293 1
a293 1
mta_lookup(struct smtpd *env, u_int64_t id)
d298 2
a299 1
	if ((res = SPLAY_FIND(mtatree, &env->mta_sessions, &key)) == NULL)
d301 1
a301 1
	return (res);
a306 1
	struct secret		 secret;
d309 1
a309 1
	struct message		*m;
d311 1
d321 6
a326 3
		bzero(&secret, sizeof(secret));
		secret.id = s->id;
		strlcpy(secret.host, s->host, sizeof(secret.host));
d328 1
a328 1
		    0, 0, -1, &secret, sizeof(secret));  
d335 7
a341 9
		dns_query_mx(s->env, s->host, 0, s->id);
		break;

	case MTA_DATA:
		/*
		 * Obtain message body fd.
		 */
		log_debug("mta: getting datafd");
		mta_request_datafd(s);
d348 1
a348 1
		if (s->flags & MTA_FORCE_ANYSSL)
d365 7
a371 6
			if (s->port)
				sa_set_port(sa, s->port);
			else if ((s->flags & MTA_FORCE_ANYSSL) && relay->used == 1)
				sa_set_port(sa, 465);
			else if (s->flags & MTA_FORCE_SMTPS)
				sa_set_port(sa, 465);
d373 1
a373 1
				sa_set_port(sa, 25);
d377 1
a377 1
				fatal("mta cannot create socket");
d415 2
a416 2
		if (s->cert) {
			struct ssl	 key, *res;
d418 1
a418 1
			strlcpy(key.ssl_name, s->cert, sizeof(key.ssl_name));
d433 1
a433 1
		if ((s->flags & MTA_FORCE_ANYSSL) && relay->used == 1)
d435 1
a435 1
		else if (s->flags & MTA_FORCE_SMTPS)
d437 1
a437 1
		else if (s->flags & MTA_ALLOW_PLAIN)
d445 2
a446 4
		m = TAILQ_FIRST(&s->recipients);
		if (m->sender.user[0] && m->sender.domain[0])
			client_sender(pcb, "%s@@%s", m->sender.user,
			    m->sender.domain);
d451 2
a452 3
		TAILQ_FOREACH(m, &s->recipients, entry)
			client_rcpt(pcb, m, "%s@@%s", m->recipient.user,
			    m->recipient.domain);
d465 2
a466 2
		while ((m = TAILQ_FIRST(&s->recipients)))
			mta_message_done(s, m);
d469 1
a469 1
		    IMSG_BATCH_DONE, 0, 0, -1, NULL, 0);
d478 1
a479 2
		free(s->host);
		free(s->cert);
d495 1
a495 1
		if (s->flags & MTA_USE_AUTH)
a525 9
			mta_enter_state(s, MTA_DATA, NULL);
		break;

	case MTA_DATA:
		/* QUEUE replied to body fd request. */
		s->datafd = *(int *)p;
		if (s->datafd == -1)
			fatalx("mta cannot obtain msgfd");
		else
d554 1
d567 4
a570 3
		mta_message_status(pcb->rcptfail, pcb->reply);
		mta_message_log(s, pcb->rcptfail);
		mta_message_done(s, pcb->rcptfail);
d583 2
a584 1
	if (TAILQ_EMPTY(&s->recipients))
d586 2
a587 1
	else
d589 1
d606 1
a606 1
	struct message		*m, *next;
d614 2
a615 2
	for (m = TAILQ_FIRST(&s->recipients); m; m = next) {
		next = TAILQ_NEXT(m, entry);
d618 1
a618 1
		mta_message_status(m, status);
d622 2
a623 2
			mta_message_log(s, m);
			mta_message_done(s, m);
d631 1
a631 1
mta_message_status(struct message *m, char *status)
d638 1
a638 1
	if (*status != '2' && strncmp(m->session_errorline, status, 3) > 0)
d642 2
a643 3
	log_debug("mta: new status for %s@@%s: %s", m->recipient.user,
	    m->recipient.domain, status);
	strlcpy(m->session_errorline, status, sizeof(m->session_errorline));
d647 1
a647 1
mta_message_log(struct mta_session *s, struct message *m)
d649 3
a651 2
	struct mta_relay	*relay = TAILQ_FIRST(&s->relays);
	char			*status = m->session_errorline;
d653 3
a655 3
	log_info("%s: to=<%s@@%s>, delay=%d, relay=%s [%s], stat=%s (%s)",
	    m->message_id, m->recipient.user,
	    m->recipient.domain, time(NULL) - m->creation,
d658 4
a661 4
	    *status == '2' ? "Sent" :
	    *status == '5' ? "RemoteError" :
	    *status == '4' ? "RemoteError" : "LocalError",
	    status + 4);
d665 16
a680 18
mta_message_done(struct mta_session *s, struct message *m)
{
	switch (m->session_errorline[0]) {
	case '6':
	case '5':
		m->status = S_MESSAGE_PERMFAILURE;
		break;
	case '2':
		m->status = S_MESSAGE_ACCEPTED;
		break;
	default:
		m->status = S_MESSAGE_TEMPFAILURE;
		break;
	}
	imsg_compose_event(s->env->sc_ievs[PROC_QUEUE],
	    IMSG_QUEUE_MESSAGE_UPDATE, 0, 0, -1, m, sizeof(*m));
	TAILQ_REMOVE(&s->recipients, m, entry);
	free(m);
a686 13
}

void
mta_request_datafd(struct mta_session *s)
{
	struct batch	 b;
	struct message	*m;

	b.id = s->id;
	m = TAILQ_FIRST(&s->recipients);
	strlcpy(b.message_id, m->message_id, sizeof(b.message_id));
	imsg_compose_event(s->env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_FD,
	    0, 0, -1, &b, sizeof(b));
@


1.86
log
@Remove unusable ifdef DEBUG code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.85 2010/04/20 15:34:56 jacekm Exp $	*/
d72 1
a72 1
	if (iev->proc == PROC_RUNNER) {
d147 5
a191 9
	if (iev->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_QUEUE_MESSAGE_FD:
			b = imsg->data;
			mta_pickup(mta_lookup(env, b->id), &imsg->fd);
			return;
		}
	}

a267 1
		{ PROC_RUNNER,	imsg_dispatch },
d500 1
a500 1
		imsg_compose_event(s->env->sc_ievs[PROC_RUNNER],
@


1.85
log
@Kill *2400* lines of code by abstracting common bits of the imsg handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.84 2010/01/03 14:37:37 chl Exp $	*/
a288 1
#ifndef DEBUG
a292 3
#else
#warning disabling privilege revocation and chroot in DEBUG MODE
#endif
a296 1
#ifndef DEBUG
a300 1
#endif
@


1.84
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.83 2009/12/23 17:16:03 jacekm Exp $	*/
d44 2
a48 5
void			 mta_dispatch_parent(int, short, void *);
void			 mta_dispatch_runner(int, short, void *);
void			 mta_dispatch_queue(int, short, void *);
void			 mta_dispatch_lka(int, short, void *);

d62 1
a62 105
mta_sig_handler(int sig, short event, void *p)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		mta_shutdown();
		break;
	default:
		fatalx("mta_sig_handler: unexpected signal");
	}
}

void
mta_dispatch_parent(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_PARENT];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mta_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CONF_START:
			if (env->sc_flags & SMTPD_CONFIGURING)
				break;
			env->sc_flags |= SMTPD_CONFIGURING;

			if ((env->sc_ssl = calloc(1, sizeof(*env->sc_ssl))) == NULL)
				fatal("mta_dispatch_parent: calloc");
			break;
		case IMSG_CONF_SSL: {
			struct ssl	*s;
			struct ssl	*x_ssl;

			if (!(env->sc_flags & SMTPD_CONFIGURING))
				break;

			if ((s = calloc(1, sizeof(*s))) == NULL)
				fatal(NULL);
			x_ssl = imsg.data;
			(void)strlcpy(s->ssl_name, x_ssl->ssl_name,
			    sizeof(s->ssl_name));
			s->ssl_cert_len = x_ssl->ssl_cert_len;
			if ((s->ssl_cert =
			    strdup((char *)imsg.data + sizeof(*s))) == NULL)
				fatal(NULL);
			s->ssl_key_len = x_ssl->ssl_key_len;
			if ((s->ssl_key = strdup((char *)imsg.data +
			    (sizeof(*s) + s->ssl_cert_len))) == NULL)
				fatal(NULL);

			SPLAY_INSERT(ssltree, env->sc_ssl, s);
			break;
		}
		case IMSG_CONF_END:
			if (!(env->sc_flags & SMTPD_CONFIGURING))
				break;
			env->sc_flags &= ~SMTPD_CONFIGURING;
			break;
		case IMSG_CTL_VERBOSE: {
			int verbose;

			IMSG_SIZE_CHECK(&verbose);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		}
		default:
			log_warnx("mta_dispatch_parent: got imsg %d",
			    imsg.hdr.type);
			fatalx("mta_dispatch_parent: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
mta_dispatch_runner(int sig, short event, void *p)
d64 14
a77 39
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_RUNNER];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mta_dispatch_runner: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_BATCH_CREATE: {
			struct batch		*b = imsg.data;
			struct mta_session	*s;

			IMSG_SIZE_CHECK(b);

			if ((s = calloc(1, sizeof(*s))) == NULL)
d129 1
a129 2
			break;
		}
d131 5
a135 8
		case IMSG_BATCH_APPEND: {
			struct message		*append = imsg.data, *m;
			struct mta_session	*s;

			IMSG_SIZE_CHECK(append);

			s = mta_lookup(env, append->batch_id);
			if ((m = malloc(sizeof(*m))) == NULL)
d137 1
a137 1
			*m = *append;
d141 1
a141 5
			break;
		}

		case IMSG_BATCH_CLOSE: {
			struct batch		*b = imsg.data;
d143 2
a144 1
			IMSG_SIZE_CHECK(b);
d146 1
a146 7
			break;
		}

		default:
			log_warnx("mta_dispatch_runner: got imsg %d",
			    imsg.hdr.type);
			fatalx("mta_dispatch_runner: unexpected imsg");
a147 1
		imsg_free(&imsg);
a148 2
	imsg_event_add(iev);
}
d150 5
a154 19
void
mta_dispatch_lka(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_LKA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
a155 28
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mta_dispatch_lka: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_LKA_SECRET: {
			struct secret		*reply = imsg.data;

			IMSG_SIZE_CHECK(reply);

			mta_pickup(mta_lookup(env, reply->id), reply->secret);
			break;
		}

		case IMSG_DNS_A: {
			struct dns		*reply = imsg.data;
			struct mta_relay	*relay;
			struct mta_session	*s;
d157 5
a161 4
			IMSG_SIZE_CHECK(reply);

			s = mta_lookup(env, reply->id);
			if ((relay = calloc(1, sizeof(*relay))) == NULL)
d163 1
a163 1
			relay->sa = reply->ss;
d165 1
a165 2
			break;
		}
d167 4
a170 2
		case IMSG_DNS_A_END: {
			struct dns		*reply = imsg.data;
d172 7
a178 17
			IMSG_SIZE_CHECK(reply);

			mta_pickup(mta_lookup(env, reply->id), &reply->error);
			break;
		}

		case IMSG_DNS_PTR: {
			struct dns		*reply = imsg.data;
			struct mta_session	*s;
			struct mta_relay	*r;

			IMSG_SIZE_CHECK(reply);

			s = mta_lookup(env, reply->id);
			r = TAILQ_FIRST(&s->relays);
			if (reply->error)
				strlcpy(r->fqdn, "<unknown>", sizeof(r->fqdn));
d180 2
a181 1
				strlcpy(r->fqdn, reply->host, sizeof(r->fqdn));
d183 1
a183 7
			break;
		}

		default:
			log_warnx("mta_dispatch_parent: got imsg %d",
			    imsg.hdr.type);
			fatalx("mta_dispatch_lka: unexpected imsg");
a184 1
		imsg_free(&imsg);
a185 2
	imsg_event_add(iev);
}
d187 5
a191 19
void
mta_dispatch_queue(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_QUEUE];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d196 10
a205 4
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}
d207 17
a223 9
	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mta_dispatch_queue: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_QUEUE_MESSAGE_FD: {
			struct batch	*b = imsg.data;
d225 5
a229 1
			IMSG_SIZE_CHECK(b);
d231 3
a233 2
			mta_pickup(mta_lookup(env, b->id), &imsg.fd);
			break;
d235 4
d240 10
a249 6
		default:
			log_warnx("mta_dispatch_queue: got imsg %d",
			    imsg.hdr.type);
			fatalx("mta_dispatch_queue: unexpected imsg");
		}
		imsg_free(&imsg);
a250 1
	imsg_event_add(iev);
d270 4
a273 4
		{ PROC_PARENT,	mta_dispatch_parent },
		{ PROC_QUEUE,	mta_dispatch_queue },
		{ PROC_RUNNER,	mta_dispatch_runner },
		{ PROC_LKA,	mta_dispatch_lka }
d308 1
@


1.83
log
@Implementation of RFC 2920 PIPELINING extension, client side only for now.

This restructures the client_* API internals significantly.  The code becomes
pipelining in nature.  All SMTP commands are put on the output queue and
dequeued as quickly as possible.  Once dequeued, they're moved to the receive
queue so that replies can be matched with previous commands.

Dequeuing commands from the output queue halts when the count of commands
currently in-pipeline (``cmdi'') is equal to the command send window (``cmdw'').
There are three cmdw values useful in practice:

0               clear pipeline, ie. inhibit all future sends
1               disable pipelining, ie. use old ``one-request-one-reply`` mode
SIZE_T_MAX      enable pipelining, ie. dequeue as many commands as possible

At the beginning of session cmdw is 1.  When it is found that peer supports
PIPELINING, it grows to SIZE_T_MAX.  After dequeing DATA it is again 1.  After
sending QUIT it is 0.

Each command dequeued from the output queue becomes a buf in a msgbuf.  The act
of combining multiple commands into a single send operation did not need to be
implemented: buf_write() already combines bufs using iovec and sends them at
once using sendmsg(2).

Tested by todd@@ and oga@@

"looks good" to gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.82 2009/12/14 16:44:14 jacekm Exp $	*/
d149 9
@


1.82
log
@Impose sessions limit on the delivery sessions (mta and mda).
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.81 2009/12/12 14:03:59 jacekm Exp $	*/
d673 2
d682 1
a682 1
		event_set(&s->ev, s->fd, EV_WRITE, mta_event, s);
d797 1
a797 3
	switch (client_talk(pcb)) {
	case CLIENT_WANT_READ:
		goto read;
d799 3
a801 1
		goto write;
d803 4
a806 4
		mta_message_status(pcb->rcptfail->p, pcb->reply);
		mta_message_log(s, pcb->rcptfail->p);
		mta_message_done(s, pcb->rcptfail->p);
		goto write;
d816 1
a816 1
	pcb = NULL;
d824 2
a825 2
read:
	event_set(&s->ev, fd, EV_READ, mta_event, s);
d829 2
a830 2
write:
	event_set(&s->ev, fd, EV_WRITE, mta_event, s);
@


1.81
log
@When acting as a client do content reads from the disk progressively
as the remote accepts more data instead of doing one big read into
the memory in the beginning of session.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.80 2009/12/12 10:33:11 jacekm Exp $	*/
a251 3

			env->stats->mta.sessions++;
			env->stats->mta.sessions_active++;
d693 3
a697 1
		s->env->stats->mta.sessions_active--;
@


1.80
log
@Simplify client_* api, mainly by making fatal conditions result in immediate
fatals instead of passing the error up (kills ~300 lines).

Implement sending of the QUIT command which replaces crude close(2).

tested by gilles@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.79 2009/12/10 15:02:30 jacekm Exp $	*/
d639 1
a639 1
		pcb = client_init(s->fd, s->env->sc_hostname, 1);
a680 3

		/* load message body */
		client_data_fd(pcb, s->datafd);
@


1.79
log
@Fix a case when 2yz status would not override existing 4yz one.
Reported by jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.78 2009/12/07 15:33:42 jsing Exp $	*/
d59 1
a62 1
size_t			 mta_todo(struct mta_session *);
d540 1
d610 2
a611 1
					mta_status(s, "110 connect error: %s", strerror(errno));
d639 1
a639 4
		s->smtp_state = client_init(s->fd, s->env->sc_hostname);
		if (s->smtp_state == NULL)
			fatal("mta: client_init failed");
		client_verbose(s->smtp_state, stderr);
d648 1
a648 2
				client_close(s->smtp_state);
				s->smtp_state = NULL;
d653 1
a653 1
			if (client_certificate(s->smtp_state,
d655 1
a655 2
			    res->ssl_key, res->ssl_key_len) < 0)
				fatal("mta: client_certificate failed");
d660 6
a665 10
		if ((s->flags & MTA_FORCE_ANYSSL) && relay->used == 1) {
			if (client_ssl_smtps(s->smtp_state) < 0)
				fatal("mta: client_ssl_smtps failed");
		} else if (s->flags & MTA_FORCE_SMTPS) {
			if (client_ssl_smtps(s->smtp_state) < 0)
				fatal("mta: client_ssl_smtps failed");
		} else if (s->flags & MTA_ALLOW_PLAIN) {
			if (client_ssl_optional(s->smtp_state) < 0)
				fatal("mta: client_ssl_optional failed");
		}
d669 1
a669 2
			if (client_auth(s->smtp_state, s->secret) < 0)
				fatal("mta: client_auth failed");
d674 2
a675 3
			if (client_sender(s->smtp_state, "%s@@%s",
			    m->sender.user, m->sender.domain) < 0)
				fatal("mta: client_sender failed");
d678 3
a680 6
		TAILQ_FOREACH(m, &s->recipients, entry) {
			if (client_rcpt(s->smtp_state, "%s@@%s", m->recipient.user,
			    m->recipient.domain) < 0)
				fatal("mta: client_rcpt failed");
			client_udata_set(s->smtp_state, m);
		}
d683 1
a683 2
		if (client_data_fd(s->smtp_state, s->datafd) < 0)
			fatal("mta: client_data_fd failed");
d685 1
d687 1
a687 1
		event_add(&s->ev, client_timeout(s->smtp_state));
d772 1
a772 1
			mta_status(s, "110 connect error");
d792 1
a792 2
	int			 error = 0;
	int			(*iofunc)(struct smtp_client *);
a794 1
		log_debug("mta: leaving smtp phase due to timeout");
d796 1
a796 6

		client_close(s->smtp_state);
		s->smtp_state = NULL;

		mta_enter_state(s, MTA_CONNECT, NULL);
		return;
d799 5
a803 6
	if (event & EV_READ)
		iofunc = client_read;
	else
		iofunc = client_write;

	switch (iofunc(s->smtp_state)) {
d805 4
a808 12
		mta_message_status(client_udata_get(s->smtp_state),
		    client_reply(s->smtp_state));
	case CLIENT_WANT_WRITE:
		event_set(&s->ev, fd, EV_WRITE, mta_event, s);
		event_add(&s->ev, client_timeout(s->smtp_state));
		return;
	case CLIENT_WANT_READ:
		event_set(&s->ev, fd, EV_READ, mta_event, s);
		event_add(&s->ev, client_timeout(s->smtp_state));
		return;
	case CLIENT_ERROR:
		error = 1;
d810 1
d812 2
d816 3
a818 9
	log_debug("mta: leaving smtp phase");

	if (error)
		mta_status(s, "%s", client_strerror(s->smtp_state));
	else
		mta_status(s, "%s", client_reply(s->smtp_state));

	client_close(s->smtp_state);
	s->smtp_state = NULL;
d820 1
a820 1
	if (mta_todo(s) == 0)
d824 10
a840 1
	struct mta_relay	*relay;
a853 2
		relay = TAILQ_FIRST(&s->relays);

d856 1
a856 9
			log_info("%s: to=<%s@@%s>, delay=%d, relay=%s [%s],"
			    " stat=%s (%s)",
			    m->message_id, m->recipient.user,
			    m->recipient.domain, time(NULL) - m->creation,
			    relay ? relay->fqdn : "(none)",
			    relay ? ss_to_text(&relay->sa) : "",
			    *status == '2' ? "Sent" :
			    *status == '5' ?  "RemoteError" : "LocalError",
			    m->session_errorline + 4);
d882 17
a935 11
}

size_t
mta_todo(struct mta_session *s)
{
	struct message	*m;
	size_t		 n = 0;

	TAILQ_FOREACH(m, &s->recipients, entry)
		n++;
	return (n);
@


1.78
log
@Avoid dereferencing a null pointer when logging a DNS lookup failure.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.77 2009/11/16 09:40:43 jacekm Exp $	*/
d904 1
a904 1
	if (strncmp(m->session_errorline, status, 3) > 0)
@


1.77
log
@Minimize the delay between receiving response to "." and removing the queue
entry in order to avoid the risk of sending duplicate mail.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.76 2009/11/13 11:27:52 jacekm Exp $	*/
d880 2
a881 1
			log_info("%s: to=<%s@@%s>, delay=%d, relay=%s [%s], stat=%s (%s)",
d884 2
a885 1
			    relay->fqdn, ss_to_text(&relay->sa),
@


1.76
log
@Log FQDN and IP of the server we handed mail to.  As a bonus, don't delay
logging of successful deliveries until all MXs were tried, plus add logging
of 5yz replies.

tested by todd@@, "reads ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.75 2009/11/11 10:04:05 chl Exp $	*/
d58 2
a59 1
void			 mta_status_message(struct message *, char *);
a687 4
			if (m->session_errorline[0] == '2' ||
			    m->session_errorline[0] == '5' ||
			    m->session_errorline[0] == '6')
				continue;
d704 1
a704 1
		 * Update runner.
d708 2
a709 18
		while ((m = TAILQ_FIRST(&s->recipients))) {
			switch (m->session_errorline[0]) {
			case '6':
			case '5':
				m->status = S_MESSAGE_PERMFAILURE;
				break;
			case '2':
				m->status = S_MESSAGE_ACCEPTED;
				break;
			default:
				m->status = S_MESSAGE_TEMPFAILURE;
				break;
			}
			imsg_compose_event(s->env->sc_ievs[PROC_QUEUE],
			    IMSG_QUEUE_MESSAGE_UPDATE, 0, 0, -1, m, sizeof(*m));
			TAILQ_REMOVE(&s->recipients, m, entry);
			free(m);
		}
d825 1
a825 1
		mta_status_message(client_udata_get(s->smtp_state),
d861 1
a861 1
	struct message		*m;
d870 2
a871 5
	TAILQ_FOREACH(m, &s->recipients, entry) {
		if (m->session_errorline[0] == '2' ||
		    m->session_errorline[0] == '5' ||
		    m->session_errorline[0] == '6')
			continue;
d874 1
a874 1
		mta_status_message(m, status);
d878 2
a879 2
		/* log successes/failures quickly */
		if (*status == '2' || *status == '5')
d884 2
a885 1
			    *status == '2' ? "Sent" : "RemoteError",
d887 2
d895 1
a895 1
mta_status_message(struct message *m, char *status)
d912 21
d958 1
a958 4
		if (m->session_errorline[0] != '2' &&
		    m->session_errorline[0] != '5' &&
		    m->session_errorline[0] != '6')
			n++;
@


1.75
log
@add missing headers needed by time()

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.74 2009/11/05 12:11:53 jsing Exp $	*/
d359 17
d539 1
a539 1
	int			 fd, max_reuse;
d600 2
a601 1
			if ((fd = socket(sa->sa_family, SOCK_STREAM, 0)) == -1)
d603 2
a604 2
			session_socket_blockmode(fd, BM_NONBLOCK);
			session_socket_no_linger(fd);
d606 1
a606 1
			if (connect(fd, sa, sa->sa_len) == -1) {
d609 1
a609 1
					close(fd);
d613 1
a613 1
			event_once(fd, EV_WRITE, mta_connect_done, s, NULL);
d622 8
d636 2
a637 3
		fd = *(int *)p;

		if ((s->smtp_state = client_init(fd, s->env->sc_hostname)) == NULL)
d701 1
a701 1
		event_set(&s->ev, fd, EV_WRITE, mta_event, s);
a718 4
				log_info("%s: to=<%s@@%s>, delay=%d, stat=Sent (%s)",
				    m->message_uid, m->recipient.user,
				    m->recipient.domain, time(NULL) - m->creation,
				    m->session_errorline + 4);
d752 1
a752 1
	int	 fd, error;
a777 1
			/* Temporary failure. */
a780 1
			/* No such domain. */
a783 1
			/* Permanent failure. */
d801 1
a801 2
		fd = *(int *)p;
		error = session_socket_error(fd);
d804 1
a804 1
			close(fd);
d807 5
a811 1
			mta_enter_state(s, MTA_PROTOCOL, &fd);
d879 4
a882 3
	char		*status;
	struct message	*m;
	va_list		 ap;
d889 7
a895 1
	TAILQ_FOREACH(m, &s->recipients, entry)
d898 12
d933 1
a933 1
	mta_pickup(p, &fd);
@


1.74
log
@Consider DNS lookups that result in NXDOMAIN to be a permanent failure.

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.70 2009/09/03 08:19:13 jacekm Exp $	*/
d38 1
@


1.73
log
@Introduce a 6yz status code, used internally to report permanent errors.
The 1yz and 6yz status codes are now removed prior to reporting the status
message in bounce messages, which provides an easy way to distinguish
between local and remote status messages. Initial diff from jacekm@@

ok gilles@@ jacekm@@
@
text
@d755 11
a765 2
		if (error) {
			mta_status(s, "100 MX lookup failed");
@


1.72
log
@Extend SMTP client_* API to support SSL+AUTH, and use it in the mta
process to relay mails.  ok gilles@@
@
text
@d662 2
a663 1
			    m->session_errorline[0] == '5')
d687 1
d907 2
a908 1
		    m->session_errorline[0] != '5')
@


1.71
log
@Cope with remote host sending '452 Insufficient system storage'.
Committing on behalf of gilles@@ who doesn't have access to a safe box.
@
text
@d6 1
a29 2
#include <openssl/ssl.h>

d32 1
d41 4
d46 15
a60 17
__dead void	mta_shutdown(void);
void		mta_sig_handler(int, short, void *);
void		mta_dispatch_parent(int, short, void *);
void		mta_dispatch_queue(int, short, void *);
void		mta_dispatch_runner(int, short, void *);
void		mta_dispatch_lka(int, short, void *);
void		mta_setup_events(struct smtpd *);
void		mta_disable_events(struct smtpd *);
void		mta_write(int, short, void *);
int		mta_connect(struct session *);
void		mta_read_handler(struct bufferevent *, void *);
void		mta_write_handler(struct bufferevent *, void *);
void		mta_error_handler(struct bufferevent *, short, void *);
int		mta_reply_handler(struct bufferevent *, void *);
void		mta_batch_update_queue(struct batch *);
void		mta_mxlookup(struct smtpd *, struct session *, char *, struct rule *);
void		ssl_client_init(struct session *);
d158 1
a158 1
mta_dispatch_lka(int sig, short event, void *p)
d166 1
a166 1
	iev = env->sc_ievs[PROC_LKA];
d187 1
a187 1
			fatal("mta_dispatch_lka: imsg_get error");
d192 3
a194 5
		case IMSG_DNS_A: {
			struct session key;
			struct dns *reply = imsg.data;
			struct session *s;
			struct mxhost *mxhost;
d196 1
a196 1
			IMSG_SIZE_CHECK(reply);
d198 14
a211 1
			key.s_id = reply->id;
d213 2
a214 3
			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatal("mta_dispatch_lka: session is gone");
d216 8
a223 3
			mxhost = calloc(1, sizeof(struct mxhost));
			if (mxhost == NULL)
				fatal("mta_dispatch_lka: calloc");
d225 10
a234 1
			mxhost->ss = reply->ss;
d236 2
a237 1
 			TAILQ_INSERT_TAIL(&s->mxhosts, mxhost, entry);
d239 3
a241 2
			break;
		}
d243 3
a245 5
		case IMSG_DNS_A_END: {
			struct session key;
			struct dns *reply = imsg.data;
			struct session *s;
			int ret;
d247 3
a249 16
			IMSG_SIZE_CHECK(reply);

			key.s_id = reply->id;

			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatal("smtp_dispatch_parent: session is gone");

			do {
				ret = mta_connect(s);
			} while (ret == 0);

			if (ret < 0) {
				mta_batch_update_queue(s->batch);
				session_destroy(s);
			}
d251 2
d256 3
a258 3
		case IMSG_LKA_SECRET: {
			struct secret	*reply = imsg.data;
			struct session	 key, *s;
d260 1
a260 1
			IMSG_SIZE_CHECK(reply);
d262 9
a270 1
			key.s_id = reply->id;
d272 2
a273 3
			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatal("smtp_dispatch_parent: session is gone");
d275 2
a276 5
			strlcpy(s->credentials, reply->secret,
			    sizeof(s->credentials));

			mta_mxlookup(env, s, s->batch->hostname,
			    &s->batch->rule);
d281 1
a281 1
			log_warnx("mta_dispatch_parent: got imsg %d",
d283 1
a283 1
			fatalx("mta_dispatch_lka: unexpected imsg");
d291 1
a291 1
mta_dispatch_queue(int sig, short event, void *p)
d299 1
a299 1
	iev = env->sc_ievs[PROC_QUEUE];
d320 1
a320 1
			fatal("mta_dispatch_queue: imsg_get error");
d325 23
a347 11
		case IMSG_QUEUE_MESSAGE_FD: {
			struct batch	*batchp = imsg.data;
			struct session	*sessionp;
			int fd;

			IMSG_SIZE_CHECK(batchp);

			if ((fd = imsg.fd) == -1) {
				/* NEEDS_FIX - unsure yet how it must be handled */
				fatalx("mta_dispatch_queue: imsg.fd == -1");
			}
d349 2
a350 2
			batchp = batch_by_id(env, batchp->id);
			sessionp = batchp->sessionp;
d352 1
a352 2
			if ((batchp->messagefp = fdopen(fd, "r")) == NULL)
				fatal("mta_dispatch_queue: fdopen");
d354 1
a354 2
			session_respond(sessionp, "DATA");
			bufferevent_enable(sessionp->s_bev, EV_READ);
d357 1
d359 1
a359 1
			log_warnx("mta_dispatch_queue: got imsg %d",
d361 1
a361 1
			fatalx("mta_dispatch_queue: unexpected imsg");
d369 1
a369 1
mta_dispatch_runner(int sig, short event, void *p)
d377 1
a377 1
	iev = env->sc_ievs[PROC_RUNNER];
d398 1
a398 1
			fatal("mta_dispatch_runner: imsg_get error");
d403 2
a404 6
		case IMSG_BATCH_CREATE: {
			struct batch *request = imsg.data;
			struct batch *batchp;
			struct session *s;

			IMSG_SIZE_CHECK(request);
d406 1
a406 25
			/* create a client session */
			if ((s = calloc(1, sizeof(*s))) == NULL)
				fatal(NULL);
			s->s_state = S_INIT;
			s->s_env = env;
			s->s_id = queue_generate_id();
			TAILQ_INIT(&s->mxhosts);
			SPLAY_INSERT(sessiontree, &s->s_env->sc_sessions, s);

			/* create the batch for this session */
			batchp = calloc(1, sizeof (struct batch));
			if (batchp == NULL)
				fatal("mta_dispatch_runner: calloc");

			*batchp = *request;
			batchp->env = env;
			batchp->sessionp = s;

			s->batch = batchp;

			TAILQ_INIT(&batchp->messages);
			SPLAY_INSERT(batchtree, &env->batch_queue, batchp);

			env->stats->mta.sessions++;
			env->stats->mta.sessions_active++;
d408 1
a410 34
		case IMSG_BATCH_APPEND: {
			struct message	*append = imsg.data;
			struct message	*messagep;
			struct batch	*batchp;

			IMSG_SIZE_CHECK(append);

			messagep = calloc(1, sizeof (struct message));
			if (messagep == NULL)
				fatal("mta_dispatch_runner: calloc");

			*messagep = *append;

			batchp = batch_by_id(env, messagep->batch_id);
			if (batchp == NULL)
				fatalx("mta_dispatch_runner: internal inconsistency.");

 			TAILQ_INSERT_TAIL(&batchp->messages, messagep, entry);
			break;
		}
		case IMSG_BATCH_CLOSE: {
			struct batch		*batchp = imsg.data;
			struct session		*s;

			IMSG_SIZE_CHECK(batchp);

			batchp = batch_by_id(env, batchp->id);
			if (batchp == NULL)
				fatalx("mta_dispatch_runner: internal inconsistency.");

			/* assume temporary failure by default, safest choice */
			batchp->status = S_BATCH_TEMPFAILURE;

			log_debug("batch ready, we can initiate a session");
a411 19
			s = batchp->sessionp;

			if (batchp->rule.r_value.relayhost.flags & F_AUTH) {
				struct secret	query;

				bzero(&query, sizeof(query));
				query.id = s->s_id;
				strlcpy(query.host,
				    batchp->rule.r_value.relayhost.hostname,
				    sizeof(query.host));

				imsg_compose_event(env->sc_ievs[PROC_LKA],
				    IMSG_LKA_SECRET, 0, 0, -1, &query,
				    sizeof(query));
			} else
				mta_mxlookup(env, s, batchp->hostname,
				    &batchp->rule);
			break;
		}
d413 1
a413 1
			log_warnx("mta_dispatch_runner: got imsg %d",
d415 1
a415 1
			fatalx("mta_dispatch_runner: unexpected imsg");
a428 10
void
mta_setup_events(struct smtpd *env)
{
}

void
mta_disable_events(struct smtpd *env)
{
}

d489 1
a489 1
	SPLAY_INIT(&env->batch_queue);
a490 1
	mta_setup_events(env);
d497 2
a498 2
void
mta_mxlookup(struct smtpd *env, struct session *sessionp, char *hostname, struct rule *rule)
d500 1
a500 22
	int	 port;

	switch (rule->r_value.relayhost.flags & F_SSL) {
	case F_SMTPS:
		port = 465;
		break;
	case F_SSL:
		port = 465;
		rule->r_value.relayhost.flags &= ~F_STARTTLS;
		break;
	default:
		port = 25;
	}
	
	if (rule->r_value.relayhost.port)
		port = ntohs(rule->r_value.relayhost.port);

	if (rule->r_action == A_RELAYVIA)
		dns_query_mx(env, rule->r_value.relayhost.hostname, port,
		    sessionp->s_id);
	else
		dns_query_mx(env, hostname, port, sessionp->s_id);
d503 2
a504 3
/* shamelessly ripped usr.sbin/relayd/check_tcp.c ;) */
int
mta_connect(struct session *sessionp)
d506 6
a511 43
	int s;
	int type;
	struct linger lng;
	struct mxhost *mxhost;

	sessionp->s_fd = -1;

	mxhost = TAILQ_FIRST(&sessionp->mxhosts);
	if (mxhost == NULL)
		return -1;

	if ((s = socket(mxhost->ss.ss_family, SOCK_STREAM, 0)) == -1)
		goto bad;

	bzero(&lng, sizeof(lng));
	if (setsockopt(s, SOL_SOCKET, SO_LINGER, &lng, sizeof (lng)) == -1)
		goto bad;

	type = 1;
	if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &type, sizeof (type)) == -1)
		goto bad;

	session_socket_blockmode(s, BM_NONBLOCK);

	if (connect(s, (struct sockaddr *)&mxhost->ss, mxhost->ss.ss_len) == -1)
		if (errno != EINPROGRESS)
			goto bad;

	sessionp->s_tv.tv_sec = SMTPD_CONNECT_TIMEOUT;
	sessionp->s_tv.tv_usec = 0;
	sessionp->s_fd = s;
	event_set(&sessionp->s_ev, s, EV_TIMEOUT|EV_WRITE, mta_write, sessionp);
	event_add(&sessionp->s_ev, &sessionp->s_tv);

	return 1;

bad:
	if (mxhost) {
		TAILQ_REMOVE(&sessionp->mxhosts, mxhost, entry);
		free(mxhost);
	}
	close(s);
	return 0;
d515 1
a515 1
mta_write(int s, short event, void *arg)
d517 5
a521 4
	struct session *sessionp = arg;
	struct batch *batchp = sessionp->batch;
	struct mxhost *mxhost;
	int ret;
d523 1
a523 1
	mxhost = TAILQ_FIRST(&sessionp->mxhosts);
d525 26
a550 1
	if (event == EV_TIMEOUT) {
d552 44
a595 3
		if (mxhost) {
			TAILQ_REMOVE(&sessionp->mxhosts, mxhost, entry);
			free(mxhost);
a596 2
		close(s);
		sessionp->s_fd = -1;
d598 10
a607 6
		if (sessionp->s_bev) {
			bufferevent_free(sessionp->s_bev);
			sessionp->s_bev = NULL;
		}
		strlcpy(batchp->errorline, "connection timed-out.",
		    sizeof(batchp->errorline));
d609 1
a609 3
		do {
			ret = mta_connect(sessionp);
		} while (ret == 0);
d611 62
a672 4
		if (ret < 0) {
			mta_batch_update_queue(batchp);
			session_destroy(sessionp);
		}
d674 3
a676 2
		return;
	}
d678 4
a681 2
	sessionp->s_bev = bufferevent_new(s, mta_read_handler, mta_write_handler,
	    mta_error_handler, sessionp);
d683 36
a718 5
	if (sessionp->s_bev == NULL) {
		mta_batch_update_queue(batchp);
		session_destroy(sessionp);
		return;
	}
d720 2
a721 4
	if (sessionp->batch->rule.r_value.relayhost.flags & F_SMTPS) {
		log_debug("mta_write: initializing ssl");
		ssl_client_init(sessionp);
		return;
a722 1
	bufferevent_enable(sessionp->s_bev, EV_READ);
d726 1
a726 1
mta_read_handler(struct bufferevent *bev, void *arg)
d728 1
a728 3
	while (mta_reply_handler(bev, arg))
		;
}
d730 7
a736 31
int
mta_reply_handler(struct bufferevent *bev, void *arg)
{
	struct session *sessionp = arg;
	struct batch *batchp = sessionp->batch;
	struct smtpd *env = batchp->env;
	struct message *messagep = NULL;
	char *line;
	int code;
#define F_ISINFO	0x1
#define F_ISPROTOERROR	0x2
	char codebuf[4];
	const char *errstr;
	int flags = 0;

	line = evbuffer_readline(bev->input);
	if (line == NULL)
		return 0;

	log_debug("remote server sent: [%s]", line);

	strlcpy(codebuf, line, sizeof(codebuf));
	code = strtonum(codebuf, 0, UINT16_MAX, &errstr);
	if (errstr || code < 100) {
		/* Server sent invalid line, protocol error */
		batchp->status = S_BATCH_PERMFAILURE;
		strlcpy(batchp->errorline, line, sizeof(batchp->errorline));
		mta_batch_update_queue(batchp);
		session_destroy(sessionp);
		return 0;
	}
d738 11
a748 8
	if (line[3] == '-') {
		if (strcasecmp(&line[4], "STARTTLS") == 0)
			sessionp->s_flags |= F_PEERHASTLS;
		else if (strncasecmp(&line[4], "AUTH ", 5) == 0 ||
		    strncasecmp(&line[4], "AUTH-", 5) == 0)
			sessionp->s_flags |= F_PEERHASAUTH;
		return 1;
	}
d750 9
a758 48
	switch (code) {
	case 250:
		if (sessionp->s_state == S_DONE) {
			batchp->status = S_BATCH_ACCEPTED;
			mta_batch_update_queue(batchp);
			session_destroy(sessionp);
			return 0;
		}

		if (sessionp->s_state == S_GREETED &&
		    (sessionp->s_flags & F_PEERHASTLS) &&
		    !(sessionp->s_flags & F_SECURE)) {
			session_respond(sessionp, "STARTTLS");
			sessionp->s_state = S_TLS;
			return 0;
		}

		if (sessionp->s_state == S_GREETED &&
		    (sessionp->s_flags & F_PEERHASAUTH) &&
		    (sessionp->s_flags & F_SECURE) &&
		    (sessionp->batch->rule.r_value.relayhost.flags & F_AUTH) &&
		    (sessionp->credentials[0] != '\0')) {
			log_debug("AUTH PLAIN %s", sessionp->credentials);
			session_respond(sessionp, "AUTH PLAIN %s",
			    sessionp->credentials);
			sessionp->s_state = S_AUTH_INIT;
			return 0;
		}

		if (sessionp->s_state == S_GREETED &&
		    !(sessionp->s_flags & F_PEERHASTLS) &&
		    (sessionp->batch->rule.r_value.relayhost.flags&F_STARTTLS)){
			/* PERM - we want TLS but it is not advertised */
			batchp->status = S_BATCH_PERMFAILURE;
			mta_batch_update_queue(batchp);
			session_destroy(sessionp);
			return 0;
		}

		if (sessionp->s_state == S_GREETED &&
		    !(sessionp->s_flags & F_PEERHASAUTH) &&
		    (sessionp->batch->rule.r_value.relayhost.flags & F_AUTH)) {
			/* PERM - we want AUTH but it is not advertised */
			batchp->status = S_BATCH_PERMFAILURE;
			mta_batch_update_queue(batchp);
			session_destroy(sessionp);
			return 0;
		}
d760 7
d769 11
a779 52
	case 220:
		if (sessionp->s_state == S_TLS) {
			ssl_client_init(sessionp);
			bufferevent_disable(bev, EV_READ|EV_WRITE);
			sessionp->s_state = S_GREETED;
			return 0;
		}

		session_respond(sessionp, "EHLO %s", env->sc_hostname);
		sessionp->s_state = S_GREETED;
		return 1;

	case 235:
		if (sessionp->s_state == S_AUTH_INIT) {
			sessionp->s_flags |= F_AUTHENTICATED;
			sessionp->s_state = S_GREETED;
			break;
		}
		return 0;
	case 421:
	case 450:
	case 451:
	case 452:
		strlcpy(batchp->errorline, line, sizeof(batchp->errorline));
		mta_batch_update_queue(batchp);
		session_destroy(sessionp);
		return 0;

		/* The following codes are state dependant and will cause
		 * a batch rejection if returned at the wrong state.
		 */
	case 530:
	case 550:
		if (sessionp->s_state == S_RCPT) {
			batchp->messagep->status = (S_MESSAGE_REJECTED|S_MESSAGE_PERMFAILURE);
			log_debug("DOES NOT EXIST !!!: %s", line);
			message_set_errormsg(batchp->messagep, "%s", line);
			break;
		}
	case 354:
		if (sessionp->s_state == S_RCPT && batchp->messagep == NULL) {
			sessionp->s_state = S_DATA;
			break;
		}

	case 221:
		if (sessionp->s_state == S_DONE) {
			batchp->status = S_BATCH_ACCEPTED;
			mta_batch_update_queue(batchp);
			session_destroy(sessionp);
			return 0;
		}
a780 7
	case 535:
		/* Authentication failed*/
	case 554:
		/* Relaying denied */
	case 552:
	case 553:
		flags |= F_ISPROTOERROR;
d782 1
a782 8
		/* Server sent code we know nothing about, error */
		if (!(flags & F_ISPROTOERROR))
			log_warn("SMTP session returned unknown status %d.", code);

		strlcpy(batchp->errorline, line, sizeof(batchp->errorline));
		mta_batch_update_queue(batchp);
		session_destroy(sessionp);
		return 0;
d784 1
d786 6
d793 3
a795 8
	switch (sessionp->s_state) {
	case S_GREETED: {
		char *user;
		char *domain;

		messagep = TAILQ_FIRST(&batchp->messages);
		user = messagep->sender.user;
		domain = messagep->sender.domain;
d797 2
a798 4
		if (user[0] == '\0' && domain[0] == '\0')
			session_respond(sessionp, "MAIL FROM:<>");
		else
			session_respond(sessionp,  "MAIL FROM:<%s@@%s>", user, domain);
d800 2
a801 3
		sessionp->s_state = S_MAIL;

		break;
d804 4
a807 2
	case S_MAIL:
		sessionp->s_state = S_RCPT;
d809 15
a823 40
	case S_RCPT: {
		char *user;
		char *domain;

		/* Is this the first RCPT ? */
		if (batchp->messagep == NULL)
			messagep = TAILQ_FIRST(&batchp->messages);
		else {
			/* We already had a RCPT, mark is as accepted and
			 * fetch next one from queue.
			 */
			messagep = batchp->messagep;
			if ((messagep->status & S_MESSAGE_REJECTED) == 0)
				messagep->status = S_MESSAGE_ACCEPTED;
			messagep = TAILQ_NEXT(batchp->messagep, entry);
		}
		batchp->messagep = messagep;

		if (messagep) {
			user = messagep->recipient.user;
			domain = messagep->recipient.domain;
			session_respond(sessionp, "RCPT TO:<%s@@%s>", user, domain);
		}
		else {
			/* Do we have at least one accepted recipient ? */
			TAILQ_FOREACH(messagep, &batchp->messages, entry) {
				if (messagep->status & S_MESSAGE_ACCEPTED)
					break;
			}
			if (messagep == NULL) {
				batchp->status = S_BATCH_PERMFAILURE;
				mta_batch_update_queue(batchp);
				session_destroy(sessionp);
				return 0;
			}

			imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_FD,
			    0, 0, -1, batchp, sizeof(*batchp));
			bufferevent_disable(sessionp->s_bev, EV_READ);
		}
d827 6
a832 15
	case S_DATA: {
		if (sessionp->s_flags & F_SECURE) {
			log_info("%s: version=%s cipher=%s bits=%d",
			batchp->message_id,
			SSL_get_cipher_version(sessionp->s_ssl),
			SSL_get_cipher_name(sessionp->s_ssl),
			SSL_get_cipher_bits(sessionp->s_ssl, NULL));
		}
		bufferevent_enable(sessionp->s_bev, EV_WRITE);
		break;
	}
	case S_DONE:
		session_respond(sessionp, "QUIT");
		sessionp->s_state = S_QUIT;
		break;
d834 2
a835 3
	default:
		log_info("unknown command: %d", sessionp->s_state);
	}
d837 4
a840 1
	return 1;
d844 1
a844 1
mta_write_handler(struct bufferevent *bev, void *arg)
d846 3
a848 11
	struct session *sessionp = arg;
	struct batch *batchp = sessionp->batch;
	char *buf, *lbuf;
	size_t len;
	
	if (sessionp->s_state == S_QUIT) {
		bufferevent_disable(bev, EV_READ|EV_WRITE);
		log_debug("closing connection because of QUIT");
		close(sessionp->s_fd);
		return;
	}
d850 4
a853 2
	/* Progressively fill the output buffer with data */
	if (sessionp->s_state == S_DATA) {
d855 2
a856 11
		lbuf = NULL;
		if ((buf = fgetln(batchp->messagefp, &len))) {
			if (buf[len - 1] == '\n')
				buf[len - 1] = '\0';
			else {
				if ((lbuf = malloc(len + 1)) == NULL)
					fatal("mta_write_handler: malloc");
				memcpy(lbuf, buf, len);
				lbuf[len] = '\0';
				buf = lbuf;
			}
d858 1
a858 18
			/* "If first character of the line is a period, one
			 *  additional period is inserted at the beginning."
			 * [4.5.2]
			 */
			if (*buf == '.')
				evbuffer_add_printf(sessionp->s_bev->output, ".");

			session_respond(sessionp, "%s", buf);
			free(lbuf);
			lbuf = NULL;
		}
		else {
			session_respond(sessionp, ".");
			sessionp->s_state = S_DONE;
			fclose(batchp->messagefp);
			batchp->messagefp = NULL;
		}
	}
d862 1
a862 1
mta_error_handler(struct bufferevent *bev, short error, void *arg)
d864 7
a870 1
	struct session *sessionp = arg;
d872 4
a875 6
	if (error & (EVBUFFER_TIMEOUT|EVBUFFER_EOF)) {
		bufferevent_disable(bev, EV_READ|EV_WRITE);
		log_debug("closing connection because of an error");
		close(sessionp->s_fd);
		return;
	}
d879 1
a879 1
mta_batch_update_queue(struct batch *batchp)
d881 2
a882 2
	struct smtpd *env = batchp->env;
	struct message *messagep;
d884 5
a888 1
	while ((messagep = TAILQ_FIRST(&batchp->messages)) != NULL) {
d890 6
a895 28
		if (batchp->status == S_BATCH_PERMFAILURE) {
			if ((messagep->status & S_MESSAGE_PERMFAILURE) == 0) {
				messagep->status |= S_MESSAGE_PERMFAILURE;
				message_set_errormsg(messagep, "%s", batchp->errorline);
			}
		}
		
		if (batchp->status == S_BATCH_TEMPFAILURE) {
			if (messagep->status != S_MESSAGE_PERMFAILURE)
				messagep->status |= S_MESSAGE_TEMPFAILURE;
			message_set_errormsg(messagep, "%s", batchp->errorline);
		}

		if ((messagep->status & S_MESSAGE_TEMPFAILURE) == 0 &&
		    (messagep->status & S_MESSAGE_PERMFAILURE) == 0) {
			log_info("%s: to=<%s@@%s>, delay=%d, stat=Sent",
			    messagep->message_uid,
			    messagep->recipient.user,
			    messagep->recipient.domain,
			    time(NULL) - messagep->creation);
		}

		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_MESSAGE_UPDATE, 0, 0, -1, messagep,
		    sizeof(struct message));
		TAILQ_REMOVE(&batchp->messages, messagep, entry);
		free(messagep);
	}
d897 5
a901 1
	SPLAY_REMOVE(batchtree, &env->batch_queue, batchp);
d903 6
a908 4
	if (batchp->messagefp)
		fclose(batchp->messagefp);

	free(batchp);
d910 1
a910 1
}
@


1.70
log
@imsg_get sets errno so use fatal instead of fatalx.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.69 2009/08/26 16:40:19 jacekm Exp $	*/
d810 1
@


1.69
log
@fix previous
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.68 2009/08/26 09:12:41 jacekm Exp $	*/
d103 1
a103 1
			fatalx("mta_dispatch_parent: imsg_get error");
d185 1
a185 1
			fatalx("mta_dispatch_lka: imsg_get error");
d301 1
a301 1
			fatalx("mta_dispatch_queue: imsg_get error");
d368 1
a368 1
			fatalx("mta_dispatch_runner: imsg_get error");
@


1.68
log
@Do not add Delivered-To to outgoing mail.  It will result in premature
bounce as soon as it hits mx2 in mx1 -> mx2 -> mx3 relay chain.
hint by sthen@@, ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.67 2009/08/08 23:02:43 gilles Exp $	*/
d932 1
@


1.67
log
@- simplify a bit queue_message_update()
- make sure queue_message_update() creates bounces using bounce_record()
- when mta sends update to queue and it sees that batch is flagged with
  F_BATCH_PERMFAIL, only update the envelope error message if it doesn't
  have F_MESSAGE_PERMFAIL set, otherwise we may lose the real reason why
  we failed for that recipient. There's cleanup to do around that old
  code, i'm sure we can get it simpler.

this commit fixes a bug pea@@ spotted where a bounce message would not
display the reason of a failure when we generated it after failing to
deliver a relayed message.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.66 2009/08/07 21:47:07 gilles Exp $	*/
a931 5

		session_respond(sessionp, "Delivered-To: %s@@%s",
		    batchp->message.sender.user,
		    batchp->message.sender.domain);

@


1.66
log
@in mta: ssl/ssl.h -> openssl/ssl.h, consistent with other files
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.65 2009/08/06 19:05:30 gilles Exp $	*/
d822 1
d1023 4
a1026 2
			messagep->status |= S_MESSAGE_PERMFAILURE;
			message_set_errormsg(messagep, "%s", batchp->errorline);
@


1.65
log
@fix a crash in mta when forwarding a bounce, caused by a null deref
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.64 2009/08/06 16:29:35 gilles Exp $	*/
d29 1
a29 1
#include <ssl/ssl.h>
@


1.64
log
@replace X-OpenSMPTD-Loop with Delivered-To

idea by jacekm@@ a few weeks ago, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.63 2009/08/06 14:12:48 gilles Exp $	*/
d933 2
a934 2
		    messagep->sender.user,
		    messagep->sender.domain);
@


1.63
log
@- introduce message_set_errormsg() to set the error description that will
  appear in a bounce message, and message_get_errormsg() to retrieve that
  message.
- when loop is detected, call message_set_errormsg()
- in mta, call message_set_errormsg() for each recipient failure
- in mta, call message_set_errormsg() to copy batch errors to recipients if
  we failed to deliver for a session related error
- when bouncing, add the recipient and error reason to the bounce message
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.62 2009/08/06 13:40:45 gilles Exp $	*/
d932 1
a932 1
		session_respond(sessionp, "X-OpenSMTPD-Loop: %s@@%s",
@


1.62
log
@This commit reworks the entire mailer daemon support to actually make it
work for real. As an added bonus, it simplifies it, makes it follow the
same code path as regular messages and kills quite some code from mta,
mda and store. There's still some work needed but the most painful part
is behind us now ;)

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.61 2009/06/20 07:46:13 jacekm Exp $	*/
d822 1
a822 2
			strlcpy(batchp->messagep->session_errorline, line,
			    sizeof(batchp->messagep->session_errorline));
d1023 1
d1029 1
@


1.61
log
@Allocate memory for env->sc_ssl like in smtp; ok gilles@@

From: Josh Elsasser <josh@@elsasser.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.60 2009/06/07 05:56:25 eric Exp $	*/
a703 1
	int i;
d864 3
a866 9
		if (batchp->type & T_DAEMON_BATCH) {
			user = "MAILER-DAEMON";
			domain = env->sc_hostname;
		}
		else {
			messagep = TAILQ_FIRST(&batchp->messages);
			user = messagep->sender.user;
			domain = messagep->sender.domain;
		}
d890 1
a890 2
			 * fetch next one from queue if we aren't dealing
			 * with a daemon batch.
d892 4
a895 8
			if (batchp->type & T_DAEMON_BATCH)
				messagep = NULL;
			else {
				messagep = batchp->messagep;
				if ((messagep->status & S_MESSAGE_REJECTED) == 0)
					messagep->status = S_MESSAGE_ACCEPTED;
				messagep = TAILQ_NEXT(batchp->messagep, entry);
			}
d900 2
a901 8
			if (batchp->type & T_DAEMON_BATCH) {
				user = messagep->sender.user;
				domain = messagep->sender.domain;
			}
			else {
				user = messagep->recipient.user;
				domain = messagep->recipient.domain;
			}
d906 9
a914 11
			if ((batchp->type & T_DAEMON_BATCH) == 0) {
				TAILQ_FOREACH(messagep, &batchp->messages, entry) {
					if (messagep->status & S_MESSAGE_ACCEPTED)
						break;
				}
				if (messagep == NULL) {
					batchp->status = S_BATCH_PERMFAILURE;
					mta_batch_update_queue(batchp);
					session_destroy(sessionp);
					return 0;
				}
d933 3
a935 69
		TAILQ_FOREACH(messagep, &batchp->messages, entry) {
			session_respond(sessionp, "X-OpenSMTPD-Loop: %s@@%s",
			    messagep->session_rcpt.user,
			    messagep->session_rcpt.domain);
		}

		if (batchp->type & T_DAEMON_BATCH) {
			session_respond(sessionp, "Hi !");
			session_respond(sessionp, "%s", "");
			session_respond(sessionp, "This is the MAILER-DAEMON, please DO NOT REPLY to this e-mail it is");
			session_respond(sessionp, "just a notification to let you know that an error has occured.");
			session_respond(sessionp, "%s", "");

			if (batchp->status == S_BATCH_PERMFAILURE) {
				session_respond(sessionp, "You ran into a PERMANENT FAILURE, which means that the e-mail can't");
				session_respond(sessionp, "be delivered to the remote host no matter how much I'll try.");
				session_respond(sessionp, "%s", "");
				session_respond(sessionp, "Diagnostic:");
				session_respond(sessionp, "%s", batchp->errorline);
				session_respond(sessionp, "%s", "");
			}

			if (batchp->status == S_BATCH_TEMPFAILURE) {
				session_respond(sessionp, "You ran into a TEMPORARY FAILURE, which means that the e-mail can't");
				session_respond(sessionp, "be delivered right now, but could be deliberable at a later time. I");
				session_respond(sessionp, "will attempt until it succeeds for the next four days, then let you");
				session_respond(sessionp, "know if it didn't work out.");
				session_respond(sessionp, "%s", "");
				session_respond(sessionp, "Diagnostic:");
				session_respond(sessionp, "%s", batchp->errorline);
				session_respond(sessionp, "%s", "");
			}

			i = 0;
			TAILQ_FOREACH(messagep, &batchp->messages, entry) {
				if (messagep->status & S_MESSAGE_TEMPFAILURE) {
					if (i == 0) {
						session_respond(sessionp, "The following recipients caused a temporary failure:");
						++i;
					}

					session_respond(sessionp,
					    "\t<%s@@%s>:", messagep->recipient.user, messagep->recipient.domain);
					session_respond(sessionp,
					    "%s", messagep->session_errorline);
					session_respond(sessionp, "%s", "");
				}
			}

			i = 0;
			TAILQ_FOREACH(messagep, &batchp->messages, entry) {
				if (messagep->status & S_MESSAGE_PERMFAILURE) {
					if (i == 0) {
						session_respond(sessionp,
						    "The following recipients caused a permanent failure:");
						++i;
					}

					session_respond(sessionp,
					    "\t<%s@@%s>:", messagep->recipient.user, messagep->recipient.domain);
					session_respond(sessionp,
					    "%s", messagep->session_errorline);
					session_respond(sessionp, "%s", "");
				}
			}

			session_respond(sessionp, "Below is a copy of the original message:");
			session_respond(sessionp, "%s", "");
		}
@


1.60
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.59 2009/06/06 04:14:21 pyr Exp $	*/
d112 3
@


1.59
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.58 2009/06/05 20:43:57 pyr Exp $	*/
d310 1
a310 1
			if ((fd = imsg_get_fd(ibuf)) == -1) {
d312 1
a312 1
				fatalx("mta_dispatch_queue: imsg_get_fd");
@


1.58
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.57 2009/06/03 22:04:15 jacekm Exp $	*/
d77 1
d82 2
a83 1
	ibuf = env->sc_ibufs[PROC_PARENT];
d90 1
a90 1
			event_del(&ibuf->ev);
d149 1
a149 1
	imsg_event_add(ibuf);
d156 1
d161 2
a162 1
	ibuf = env->sc_ibufs[PROC_LKA];
d169 1
a169 1
			event_del(&ibuf->ev);
d265 1
a265 1
	imsg_event_add(ibuf);
d272 1
d277 2
a278 1
	ibuf = env->sc_ibufs[PROC_QUEUE];
d285 1
a285 1
			event_del(&ibuf->ev);
d332 1
a332 1
	imsg_event_add(ibuf);
d339 1
d344 2
a345 1
	ibuf = env->sc_ibufs[PROC_RUNNER];
d352 1
a352 1
			event_del(&ibuf->ev);
d451 1
a451 1
				imsg_compose_event(env->sc_ibufs[PROC_LKA],
d466 1
a466 1
	imsg_event_add(ibuf);
d934 1
a934 1
			imsg_compose_event(env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_FD,
d1123 1
a1123 1
		imsg_compose_event(env->sc_ibufs[PROC_QUEUE],
@


1.57
log
@simplify struct batch; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.56 2009/06/02 22:23:35 gilles Exp $	*/
d304 1
a304 1
			if ((fd = imsg_get_fd(ibuf, &imsg)) == -1) {
d443 1
a443 1
				imsg_compose(env->sc_ibufs[PROC_LKA],
d926 1
a926 1
			imsg_compose(env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_FD,
d1115 1
a1115 1
		imsg_compose(env->sc_ibufs[PROC_QUEUE],
@


1.56
log
@make env->sc_listeners and env->sc_ssl pointers, one step further toward
configuration reloading without killing active sessions; ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.55 2009/06/01 13:20:56 jacekm Exp $	*/
a221 2
			s->batch->flags |= F_BATCH_RESOLVED;

a383 1
			batchp->session_id = s->s_id;
a384 1
			batchp->flags = 0;
a413 7
			batchp->session_ss = messagep->session_ss;
			strlcpy(batchp->session_hostname,
			    messagep->session_hostname,
			    sizeof(batchp->session_hostname));
			strlcpy(batchp->session_helo, messagep->session_helo,
			    sizeof(batchp->session_helo));

a425 2

			batchp->flags |= F_BATCH_COMPLETE;
@


1.55
log
@Fix EV_READ/EV_WRITE testing inside IMSG handlers. Based on similar change
to the routing daemons by claudio@@; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.54 2009/05/31 18:34:48 gilles Exp $	*/
d132 1
a132 1
			SPLAY_INSERT(ssltree, &env->sc_ssl, s);
@


1.54
log
@when entering mta_connect() reset session fd to -1
when connect timesout and we close the fd, reset session fd to -1
in session_destroy(), only attempt to close session fd if != -1

fixes a fatal in session_destroy() which happened because we closed a fd
after a timeout, but the session still assumed the fd to be opened.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.53 2009/05/30 23:53:41 gilles Exp $	*/
d82 2
a83 2
	switch (event) {
	case EV_READ:
d92 3
a94 2
		break;
	case EV_WRITE:
a96 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d159 2
a160 2
	switch (event) {
	case EV_READ:
d169 3
a171 2
		break;
	case EV_WRITE:
a173 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d275 2
a276 2
	switch (event) {
	case EV_READ:
d285 3
a287 2
		break;
	case EV_WRITE:
a289 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d340 2
a341 2
	switch (event) {
	case EV_READ:
d350 3
a352 2
		break;
	case EV_WRITE:
a354 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
@


1.53
log
@It is now possible to specify a certificate to use when relaying to another
host which requests client certificates:

	accept [...] relay via [...] ssl certificate "mycert"

diff from Josh Elsasser <josh@@elsasser.org>, tested and okayed by me with
no change but the addition of status 554 to the state machine to deal with
remote host telling us it doesn't like our certificate.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.52 2009/05/30 16:32:59 gilles Exp $	*/
d608 2
d665 1
@


1.52
log
@increment mta.sessions in when we allocate a new session in mta
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.51 2009/05/30 16:30:33 gilles Exp $	*/
d109 34
d513 1
d854 2
@


1.51
log
@- increment stats.mta.sessions_active when session is allocated in mta
- reorder alphabetically and add mta to the statistics
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.50 2009/05/27 13:14:18 jacekm Exp $	*/
d374 1
@


1.50
log
@Insert Received: at receive time instead of delivery time; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.49 2009/05/24 14:38:56 jacekm Exp $	*/
d373 2
@


1.49
log
@Parent process forks 3 types of processes, track them all in a single tree
using newly introduced child struct.

Manage process titles centrally in struct smtpd.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.48 2009/05/19 11:24:24 jacekm Exp $	*/
a915 9
		session_respond(sessionp, "Received: from %s (%s [%s])",
		    batchp->session_helo, batchp->session_hostname,
		    ss_to_text(&batchp->session_ss));

		session_respond(sessionp, "\tby %s with ESMTP id %s;",
		    batchp->env->sc_hostname, batchp->message_id);

		session_respond(sessionp, "\t%s", time_to_text(batchp->creation));

@


1.48
log
@Verify the amount of IMSG payload is exactly as expected; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.47 2009/05/14 15:05:12 eric Exp $	*/
a502 1
	setproctitle("mail transfer agent");
d504 1
@


1.47
log
@use the nitems() macro where appropriate

ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.46 2009/05/13 21:29:16 jacekm Exp $	*/
d161 2
d186 2
d212 2
d275 1
a275 1
			struct batch	*batchp;
d279 2
a285 1
			batchp = (struct batch *)imsg.data;
d343 2
d346 2
a347 1
			struct batch *batchp;
d363 1
a363 1
			*batchp = *(struct batch *)imsg.data;
d377 2
d380 2
a381 1
			struct message	*messagep;
d387 1
a387 1
			*messagep = *(struct message *)imsg.data;
d404 1
a404 1
			struct batch		*batchp;
d407 2
a408 1
			batchp = (struct batch *)imsg.data;
@


1.46
log
@do MX lookups in both "relay" and "relay via" case; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.45 2009/05/09 17:04:55 jacekm Exp $	*/
d508 2
a509 2
	config_pipes(env, peers, 3);
	config_peers(env, peers, 3);
@


1.45
log
@- New API to handle all DNS query types (A, MX, PTR) asynchronously.

- Improve RFC compliance: CNAMEs are resolved, equal preference MXs
are randomized, relaying via MX that has equal/lower preference
than local server is prevented, decision on when to treat domain
name as implicit MX is better.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.44 2009/04/28 21:56:36 gilles Exp $	*/
d541 1
a541 1
		dns_query_a(env, rule->r_value.relayhost.hostname, port,
@


1.44
log
@in mta, change the batch status to S_BATCH_TEMPFAILURE by default so that
we need to explicitely set success and permanent failures, this way if we
hit any condition that we don't explicitely flag as permanent failure the
delivery will be rescheduled later.

while at it, made various checks more strict to prevent hiding bugs and a
bit of knr cleanups

discussed with and "reads good" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.43 2009/04/28 21:27:25 jacekm Exp $	*/
d155 1
a155 1
		case IMSG_LKA_MX: {
d157 1
a157 1
			struct mxrep *mxrep;
d161 1
a161 2
			mxrep = imsg.data;
			key.s_id = mxrep->id;
d171 2
a172 1
			*mxhost = mxrep->mxhost;
d177 2
a178 1
		case IMSG_LKA_MX_END: {
d180 1
a180 1
			struct mxrep *mxrep;
d184 1
a184 2
			mxrep = imsg.data;
			key.s_id = mxrep->id;
d195 1
a195 1
			
d203 19
d408 2
a409 1
			mta_mxlookup(env, s, batchp->hostname, &batchp->rule);
d411 12
d523 1
a523 1
	struct mxreq mxreq;
d525 20
a544 5
	mxreq.id = sessionp->s_id;
	mxreq.rule = *rule;
	(void)strlcpy(mxreq.hostname, hostname, MAXHOSTNAMELEN);
	imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_MX, 0, 0, -1,
	    &mxreq, sizeof(struct mxreq));
a553 2
	struct sockaddr_in ssin;
	struct sockaddr_in6 ssin6;
d573 3
a575 13
	if (mxhost->ss.ss_family == PF_INET) {
		ssin = *(struct sockaddr_in *)&mxhost->ss;
		if (connect(s, (struct sockaddr *)&ssin, sizeof(struct sockaddr_in)) == -1)
			if (errno != EINPROGRESS)
				goto bad;
	}

	if (mxhost->ss.ss_family == PF_INET6) {
		ssin6 = *(struct sockaddr_in6 *)&mxhost->ss;
		if (connect(s, (struct sockaddr *)&ssin6, sizeof(struct sockaddr_in6)) == -1)
			if (errno != EINPROGRESS)
				goto bad;
	}
d640 2
a641 1
	if (mxhost && mxhost->flags & F_SMTPS) {
a669 1
	struct mxhost *mxhost = TAILQ_FIRST(&sessionp->mxhosts);
d717 3
a719 3
		    (mxhost->flags & F_AUTH) &&
		    (mxhost->credentials[0] != '\0')) {
			log_debug("AUTH PLAIN %s", mxhost->credentials);
d721 1
a721 1
			    mxhost->credentials);
d728 1
a728 1
		    mxhost->flags & F_STARTTLS) {
d738 1
a738 1
		    mxhost->flags & F_AUTH) {
@


1.43
log
@let mta, mda, and mfa become idle - no functional change; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.42 2009/04/21 14:37:32 eric Exp $	*/
d382 3
d512 1
a512 2
	if (mxhost == NULL) {
		sessionp->batch->status |= S_BATCH_TEMPFAILURE;
a513 1
	}
d515 1
a515 1
	if ((s = socket(mxhost->ss.ss_family, SOCK_STREAM, 0)) == -1) {
a516 1
	}
d519 1
a519 1
	if (setsockopt(s, SOL_SOCKET, SO_LINGER, &lng, sizeof (lng)) == -1) {
a520 1
	}
d523 1
a523 1
	if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &type, sizeof (type)) == -1) {
a524 1
	}
d530 2
a531 2
		if (connect(s, (struct sockaddr *)&ssin, sizeof(struct sockaddr_in)) == -1) {
			if (errno != EINPROGRESS) {
a532 2
			}
		}
d537 2
a538 2
		if (connect(s, (struct sockaddr *)&ssin6, sizeof(struct sockaddr_in6)) == -1) {
			if (errno != EINPROGRESS) {
a539 2
			}
		}
d541 1
d646 1
a646 1
		batchp->status |= S_BATCH_PERMFAILURE;
d665 1
d695 1
a695 1
			batchp->status |= S_BATCH_PERMFAILURE;
d705 1
a705 1
			batchp->status |= S_BATCH_PERMFAILURE;
a734 1
		batchp->status |= S_BATCH_TEMPFAILURE;
d759 1
d773 1
a773 1
			log_debug("Ouch, SMTP session returned unhandled %d status.", code);
a774 1
		batchp->status |= S_BATCH_PERMFAILURE;
d852 1
a852 1
					batchp->status |= S_BATCH_PERMFAILURE;
d897 1
a897 1
			if (batchp->status & S_BATCH_PERMFAILURE) {
d906 1
a906 1
			if (batchp->status & S_BATCH_TEMPFAILURE) {
d1039 1
a1039 1
		if (batchp->status & S_BATCH_PERMFAILURE) {
d1042 2
a1043 2

		if (batchp->status & S_BATCH_TEMPFAILURE) {
@


1.42
log
@correct some fatal(x) calls and error strings

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.41 2009/04/15 20:02:12 jacekm Exp $	*/
a49 1
void		mta_timeout(int, short, void *);
a409 6
	struct timeval	 tv;

	evtimer_set(&env->sc_ev, mta_timeout, env);
	tv.tv_sec = 3;
	tv.tv_usec = 0;
	evtimer_add(&env->sc_ev, &tv);
a414 12
	evtimer_del(&env->sc_ev);
}

void
mta_timeout(int fd, short event, void *p)
{
	struct smtpd		*env = p;
	struct timeval		 tv;

	tv.tv_sec = 3;
	tv.tv_usec = 0;
	evtimer_add(&env->sc_ev, &tv);
@


1.41
log
@fix a bug where after all MX-es were found to be non-contactable,
smtpd would treat the delivery as successful; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.40 2009/04/09 19:49:34 jacekm Exp $	*/
d105 1
a105 1
			fatal("parent_dispatch_mta: imsg_read error");
d151 1
a151 1
			fatal("mta_dispatch_lka: imsg_read error");
d245 1
a245 1
			fatal("parent_dispatch_mta: imsg_read error");
d312 1
a312 1
			fatal("mta_dispatch_runner: imsg_read error");
@


1.40
log
@change syntax of the "listen on" and "relay via" directives:
1) kill the ssmtp keyword in "ssmtp listen on ...";
2) kill the use keyword in "... use certificate foo";
3) tls no longer implicit, user must explicitely use the tls or smtps option.
4) for "relay via", move the tls/smtps options to right after the
port specification; makes it similar to "listen on".

These directives:

  ssmtp listen on fxp0 use ceritifate "foo"
  accept for all relay via tls "mx.bar.com"

now become:

  listen on fxp0 smtps certificate "foo"
  accept for all relay via "mx.bar.com" tls

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.39 2009/03/29 14:18:20 jacekm Exp $	*/
d528 2
a529 1
	if (mxhost == NULL)
d531 1
@


1.39
log
@turn some log_debugs into log_warns or even fatals; "looks ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.38 2009/03/19 00:12:32 gilles Exp $	*/
d627 1
a627 1
	if (mxhost && mxhost->flags & F_SSMTP) {
@


1.38
log
@in the event of a timeout, mxhost is passed to TAILQ_REMOVE before it is
initialized.
spotted and diff by Matthew Haub <matthew.haub@@alumni.adelaide.edu.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.37 2009/03/18 23:51:34 gilles Exp $	*/
d111 1
a111 1
			log_debug("parent_dispatch_mta: unexpected imsg %d",
d113 1
a113 1
			break;
d205 1
a205 1
			log_debug("mta_dispatch_lka: unexpected imsg %d",
d207 1
a207 1
			break;
d272 1
a272 1
			log_debug("parent_dispatch_mta: unexpected imsg %d",
d274 1
a274 1
			break;
d392 1
a392 1
			log_debug("mta_dispatch_runner: unexpected imsg %d",
d394 1
a394 1
			break;
@


1.37
log
@remove debug X-Cipher and turn it into a useful log_info()
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.36 2009/03/18 00:07:41 gilles Exp $	*/
d589 2
d593 4
a596 2
		TAILQ_REMOVE(&sessionp->mxhosts, mxhost, entry);
		free(mxhost);
d627 1
a627 2
	mxhost = TAILQ_FIRST(&sessionp->mxhosts);
	if (mxhost->flags & F_SSMTP) {
@


1.36
log
@in mta, when remote host advertises AUTH, do not attempt to authenticate
unless we do have F_AUTH set on the mxhost (which means we explicitely
mentionned authentication in config) and we did find credentials in the
secrets map. issue and initial diff from Rivo Nurges <rix@@estpak.ee>
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.35 2009/03/15 19:15:25 gilles Exp $	*/
d896 5
a900 2
			session_respond(sessionp, "X-OpenSMTPD-Cipher: %s",
			    SSL_get_cipher(sessionp->s_ssl));
@


1.35
log
@the mda process no longer uses struct batch as its central structure to
deal with deliveries, it now uses struct session just like mta and smtp
processes. we now keep the mbox and message descriptors in the session,
saving space in struct message which is now as small as we can make it.
While at it, plugged a memory leak and did some cosmethic changes

This was the last planned change to our struct message which means that
later changes will no longer require a queue flush before rebuild.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.34 2009/03/12 11:08:26 pea Exp $	*/
d699 3
a701 1
		    (sessionp->s_flags & F_SECURE)) {
d703 2
a704 1
			session_respond(sessionp, "AUTH PLAIN %s", mxhost->credentials);
@


1.34
log
@Add new function time_to_text to correctly display the date.
Use it to display the date in received from header and when we
store headers.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.33 2009/03/10 22:33:26 jacekm Exp $	*/
a369 1

d1083 1
@


1.33
log
@implement basic logging, needs more work; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.32 2009/03/09 01:43:19 gilles Exp $	*/
d888 1
a888 1
		session_respond(sessionp, "\tby %s with ESMTP id %s",
d890 2
@


1.32
log
@add basic support for outgoing authentication (AUTH PLAIN over ssl) which
can be turned on by adding "enable auth" to a "relay via" rule. this made
me rework the mx resolution so that it is done by the mta process and not
the runner process anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.31 2009/02/22 19:07:33 chl Exp $	*/
d1058 9
@


1.31
log
@add missing headers

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.30 2009/02/22 11:59:12 jacekm Exp $	*/
d47 1
d58 1
a58 1
void		mta_expand_mxarray(struct session *);
d121 94
d327 1
a336 1
			batchp->mx_off = 0;
d388 2
a389 4
			mta_expand_mxarray(s);
			while (! mta_connect(s))
				if (s->mx_off == s->mx_cnt)
					break;
d448 2
a449 1
		{ PROC_RUNNER,	mta_dispatch_runner }
d493 2
a494 2
	config_pipes(env, peers, 2);
	config_peers(env, peers, 2);
d505 12
d519 1
a519 1
mta_connect(struct session* sessionp)
d526 1
d528 5
a532 1
	if ((s = socket(sessionp->mxarray[sessionp->mx_off].ss.ss_family, SOCK_STREAM, 0)) == -1) {
d548 2
a549 2
	if (sessionp->mxarray[sessionp->mx_off].ss.ss_family == PF_INET) {
		ssin = *(struct sockaddr_in *)&sessionp->mxarray[sessionp->mx_off].ss;
d557 2
a558 2
	if (sessionp->mxarray[sessionp->mx_off].ss.ss_family == PF_INET6) {
		ssin6 = *(struct sockaddr_in6 *)&sessionp->mxarray[sessionp->mx_off].ss;
a564 1

d574 4
a577 1
	sessionp->mx_off++;
d587 1
d591 3
a593 1
		sessionp->mx_off++;
d595 1
d603 7
a609 4
		ret = 0;
		while (sessionp->mx_off < sessionp->mx_cnt &&
		    (ret = mta_connect(sessionp)) == 0) {
			continue;
a610 2
		if (ret)
			return;
a611 2
		mta_batch_update_queue(batchp);
		session_destroy(sessionp);
d624 2
a625 1
	if (sessionp->mxarray[sessionp->mx_off].flags & F_SSMTP) {
d654 1
d676 3
d699 9
d709 1
a709 1
		    sessionp->mxarray[sessionp->mx_off].flags & F_STARTTLS) {
d717 10
d741 7
d781 2
a1072 115
}

void
mta_expand_mxarray(struct session *sessionp)
{
	int i;
	int j;
	u_int16_t	port;
	struct mxhost		mxhost;
	struct sockaddr_in	*ssin;
	struct sockaddr_in6	*ssin6;
	struct batch *batchp = sessionp->batch;

	/* First pass, we compute the length of the final mxarray */
	for (i = 0; i < batchp->mx_cnt; ++i) {
		mxhost = batchp->mxarray[i];

		if (mxhost.ss.ss_family == AF_INET) {
			ssin = (struct sockaddr_in *)&mxhost.ss;
			port = ntohs(ssin->sin_port);
		}
		else if (mxhost.ss.ss_family == AF_INET6) {
			ssin6 = (struct sockaddr_in6 *)&mxhost.ss;
			port = ntohs(ssin6->sin6_port);
		}

		if (port) {
			++sessionp->mx_cnt;
			continue;
		}

		switch (mxhost.flags & F_SSL) {
		case F_SSL:
			sessionp->mx_cnt += 2;
			break;
		case F_SSMTP:
		case F_STARTTLS:
		default:
			++sessionp->mx_cnt;
		}
	}

	/* Second pass, we actually fill the array */
	sessionp->mxarray = calloc(sessionp->mx_cnt, sizeof(struct mxhost));
	if (sessionp->mxarray == NULL)
		fatal("calloc");

	for (i = j = 0; i < batchp->mx_cnt; ++i) {
		mxhost = batchp->mxarray[i];

		if (mxhost.ss.ss_family == AF_INET) {
			ssin = (struct sockaddr_in *)&mxhost.ss;
			port = ntohs(ssin->sin_port);
		}
		else if (mxhost.ss.ss_family == AF_INET6) {
			ssin6 = (struct sockaddr_in6 *)&mxhost.ss;
			port = ntohs(ssin6->sin6_port);
		}

		if (port) {
			sessionp->mxarray[j++] = mxhost;
			continue;
		}

		switch (mxhost.flags & F_SSL) {
		case F_SSL: {
			u_int8_t flags = mxhost.flags;

			if (mxhost.ss.ss_family == AF_INET) {
				ssin->sin_port = htons(465);
				mxhost.ss = *(struct sockaddr_storage *)ssin;
			}
			else if (mxhost.ss.ss_family == AF_INET6) {
				ssin6->sin6_port = htons(465);
				mxhost.ss = *(struct sockaddr_storage *)ssin6;
			}
			mxhost.flags = flags & ~F_STARTTLS;
			sessionp->mxarray[j++] = mxhost;

			if (mxhost.ss.ss_family == AF_INET) {
				ssin->sin_port = htons(25);
				mxhost.ss = *(struct sockaddr_storage *)ssin;
			}
			else if (mxhost.ss.ss_family == AF_INET6) {
				ssin6->sin6_port = htons(25);
				mxhost.ss = *(struct sockaddr_storage *)ssin6;
			}
			mxhost.flags = flags & ~F_SSMTP;
			sessionp->mxarray[j++] = mxhost;
			break;
		}
		case F_SSMTP:
			if (mxhost.ss.ss_family == AF_INET) {
				ssin->sin_port = htons(465);
				mxhost.ss = *(struct sockaddr_storage *)ssin;
			}
			else if (mxhost.ss.ss_family == AF_INET6) {
				ssin6->sin6_port = htons(465);
				mxhost.ss = *(struct sockaddr_storage *)ssin6;
			}
			sessionp->mxarray[j++] = mxhost;
			break;
		case F_STARTTLS:
		default:
			if (mxhost.ss.ss_family == AF_INET) {
				ssin->sin_port = htons(25);
				mxhost.ss = *(struct sockaddr_storage *)ssin;
			}
			else if (mxhost.ss.ss_family == AF_INET6) {
				ssin6->sin6_port = htons(25);
				mxhost.ss = *(struct sockaddr_storage *)ssin6;
			}
			sessionp->mxarray[j++] = mxhost;
		}
	}
@


1.30
log
@put repeated inet_ntop calls into new func ss_to_text, which uses
getnameinfo internally; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.29 2009/02/22 11:44:29 form Exp $	*/
d34 1
@


1.29
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.28 2009/02/20 15:27:01 pea Exp $	*/
d734 3
a736 18
		char addrbuf[INET6_ADDRSTRLEN];
		void *p;
		
		if (batchp->session_ss.ss_family == PF_INET) {
                	struct sockaddr_in *ssin = (struct sockaddr_in *)&batchp->session_ss;
                	p = &ssin->sin_addr.s_addr;
        	}
        	if (batchp->session_ss.ss_family == PF_INET6) {
                	struct sockaddr_in6 *ssin6 = (struct sockaddr_in6 *)&batchp->session_ss;
                	p = &ssin6->sin6_addr.s6_addr;
        	}

        	bzero(addrbuf, sizeof (addrbuf));
        	inet_ntop(batchp->session_ss.ss_family, p, addrbuf, sizeof (addrbuf));

		session_respond(sessionp, "Received: from %s (%s [%s%s])",
		    batchp->session_helo, batchp->session_hostname, 
		    batchp->session_ss.ss_family == PF_INET ? "" : "IPv6:", addrbuf);
@


1.28
log
@Fix "Received: from" headers

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.27 2009/02/15 10:32:23 jacekm Exp $	*/
d267 5
a271 2
			strlcpy(batchp->session_hostname, messagep->session_hostname, MAXHOSTNAMELEN);
			strlcpy(batchp->session_helo, messagep->session_helo, MAXHOSTNAMELEN);
d482 2
a483 1
		strlcpy(batchp->errorline, "connection timed-out.", MAX_LINE_SIZE);
d543 1
a543 1
	strlcpy(codebuf, line, sizeof codebuf);
d548 1
a548 1
		strlcpy(batchp->errorline, line, MAX_LINE_SIZE);
d604 1
a604 1
		strlcpy(batchp->errorline, line, MAX_LINE_SIZE);
d616 2
a617 1
			strlcpy(batchp->messagep->session_errorline, line, MAX_LINE_SIZE);
d642 1
a642 1
		strlcpy(batchp->errorline, line, MAX_LINE_SIZE);
@


1.27
log
@New config.c that allows for process cloning. Done by pyr@@ for
relayd at n2k9, and adapted to smtpd; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.26 2009/01/29 15:40:34 gilles Exp $	*/
d729 18
a746 11
/*
		if (fprintf(fp, "Received: from %s (%s [%s%s])\n"
			"\tby %s with ESMTP id %s\n"
			"\tfor <%s@@%s>; %s\n\n",
			messagep->session_helo, messagep->session_hostname,
			messagep->session_ss.ss_family == PF_INET ? "" : "IPv6:", addrbuf,
			batchp->env->sc_hostname, messagep->message_id,
			messagep->sender.user, messagep->sender.domain, ctimebuf) == -1) {
*/
		session_respond(sessionp, "Received: from %s (%s [%s])",
		    batchp->session_helo, batchp->session_hostname, "127.0.0.1");
@


1.26
log
@missing prototype for session_respond() in mta, move session_respond()'s
prototype to smtpd.h
spotted and diff from Oleg Safiullin <form@@pdp-11.org.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.25 2009/01/29 15:20:34 gilles Exp $	*/
d395 1
@


1.25
log
@Received header line was incomplete for mail submitted through the enqueuer
as well as for some outgoing messages, this is fixed now
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.24 2009/01/29 14:50:27 gilles Exp $	*/
a56 3
void		session_respond(struct session *, char *, ...)
		    __attribute__ ((format (printf, 2, 3)));

@


1.24
log
@fix a bug in mta's event masking
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.23 2009/01/29 14:25:55 gilles Exp $	*/
d269 4
d731 9
d741 2
a742 1
		    "localhost", "localhost", "127.0.0.1");
d744 1
a744 1
		    "", batchp->message_id);
@


1.23
log
@initial starttls support in mta, this allows:

	accept for domain "openbsd.org" relay via tls "mx.example.org"

to ensure the relaying of mail for whoever@@openbsd.org will happen through
a secure tls (STARTTLS) session. failure to establish a tls session will be
considered as a permanent failure. As a side effect:

	accept for domain "openbsd.org" relay via ssl "mx.example.org"

can now work as well and ensure that the relaying happens through ssmtp OR
tls, but never through an unsafe channel. no need to specify a port, they
are automatically detected if not specified.

still a work in progress, don't expect that it will work flawlessly.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.22 2009/01/29 13:00:12 gilles Exp $	*/
d175 1
a175 2

			bufferevent_enable(sessionp->s_bev, EV_WRITE|EV_READ);
d505 1
a505 1
	bufferevent_enable(sessionp->s_bev, EV_READ|EV_WRITE);
d532 1
a532 2
	if (line == NULL) {
		bufferevent_enable(bev, EV_READ|EV_WRITE);
a533 3
	}

	bufferevent_enable(bev, EV_READ|EV_WRITE);
a718 1
			bufferevent_disable(sessionp->s_bev, EV_WRITE|EV_READ);
d721 1
a726 2
		bufferevent_enable(sessionp->s_bev, EV_READ|EV_WRITE);
		
a868 1
	bufferevent_enable(sessionp->s_bev, EV_READ|EV_WRITE);
@


1.22
log
@bring initial support for SSL in the mta part of smtpd, allowing for:

	accept for domain "openbsd.org" relay via ssmtp "mx1.example.org"

to ensure that deliveries for whatever@@openbsd.org goes through an SSL session
to mx1.example.org
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.21 2009/01/28 23:46:03 gilles Exp $	*/
d549 1
d554 2
d563 19
d584 1
d588 7
d605 1
d627 1
d642 1
d719 1
@


1.21
log
@fix missing prototype and format related warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.20 2009/01/28 23:38:49 gilles Exp $	*/
d29 2
d60 2
d363 1
d452 1
a452 1
	sessionp->peerfd = s;
d489 1
a492 4
	sessionp->s_l = calloc(1, sizeof(struct listener));
	if (sessionp->s_l == NULL)
		fatal("calloc");
	sessionp->s_l->fd = s;
d498 1
a498 1
		close(s);
d502 4
d705 5
d805 1
a805 1
		close(sessionp->peerfd);
d853 1
a853 1
		close(sessionp->peerfd);
a862 2
	struct session *sessionp;
	struct session  key;
a881 2
	sessionp = batchp->sessionp;

a886 6
	if (sessionp->s_bev)
		bufferevent_free(sessionp->s_bev);

	if (sessionp->peerfd != -1)
		close(sessionp->peerfd);

a887 4

	SPLAY_REMOVE(sessiontree, &env->sc_sessions, &key);
	free(sessionp->mxarray);
	free(sessionp);
@


1.20
log
@now that mta uses a struct session, it can also use session_respond() just
as smtp_session.c does, so move all of the evbuffer_add_printf() calls out
of the way and replace them with session_respond() call.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.19 2009/01/28 23:13:42 gilles Exp $	*/
d55 2
d707 1
a707 1
			session_respond(sessionp, "");
d710 1
a710 1
			session_respond(sessionp, "");
d715 1
a715 1
				session_respond(sessionp, "");
d718 1
a718 1
				session_respond(sessionp, "");
d726 1
a726 1
				session_respond(sessionp, "");
d729 1
a729 1
				session_respond(sessionp, "");
d744 1
a744 1
					session_respond(sessionp, "");
d761 1
a761 1
					session_respond(sessionp, "");
d766 1
a766 1
			session_respond(sessionp, "");
@


1.19
log
@mta session state belongs to struct session, not struct batch, remove the
state field from struct batch and propagate the change
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.18 2009/01/28 22:54:10 gilles Exp $	*/
d168 1
a168 1
			evbuffer_add_printf(sessionp->s_bev->output, "DATA\r\n");
d557 1
a557 1
		evbuffer_add_printf(sessionp->s_bev->output, "EHLO %s\r\n", env->sc_hostname);
d622 1
a622 1
			evbuffer_add_printf(sessionp->s_bev->output, "MAIL FROM:<>\r\n");
d624 2
a625 1
			evbuffer_add_printf(sessionp->s_bev->output, "MAIL FROM:<%s@@%s>\r\n", user, domain);
d666 1
a666 1
			evbuffer_add_printf(sessionp->s_bev->output, "RCPT TO:<%s@@%s>\r\n", user, domain);
d691 4
a694 5

		evbuffer_add_printf(sessionp->s_bev->output,
		    "Received: from %s (%s [%s])\r\n"
		    "\tby %s with ESMTP id %s\r\n",
		    "localhost", "localhost", "127.0.0.1",
d698 3
a700 2
			evbuffer_add_printf(sessionp->s_bev->output, "X-OpenSMTPD-Loop: %s@@%s\r\n",
			    messagep->session_rcpt.user, messagep->session_rcpt.domain);
d704 5
a708 4
			evbuffer_add_printf(sessionp->s_bev->output,
			    "Hi !\r\n\r\n"
			    "This is the MAILER-DAEMON, please DO NOT REPLY to this e-mail it is\r\n"
			    "just a notification to let you know that an error has occured.\r\n\r\n");
d711 6
a716 5
				evbuffer_add_printf(sessionp->s_bev->output,
				    "You ran into a PERMANENT FAILURE, which means that the e-mail can't\r\n"
				    "be delivered to the remote host no matter how much I'll try.\r\n\r\n"
				    "Diagnostic:\r\n"
				    "%s\r\n\r\n", batchp->errorline);
d720 8
a727 7
				evbuffer_add_printf(sessionp->s_bev->output,
				    "You ran into a TEMPORARY FAILURE, which means that the e-mail can't\r\n"
				    "be delivered right now, but could be deliberable at a later time. I\r\n"
				    "will attempt until it succeeds for the next four days, then let you\r\n"
				    "know if it didn't work out.\r\n"
				    "Diagnostic:\r\n"
				    "%s\r\n\r\n", batchp->errorline);
d734 1
a734 2
						evbuffer_add_printf(sessionp->s_bev->output,
						    "The following recipients caused a temporary failure:\r\n");
d738 5
a742 3
					evbuffer_add_printf(sessionp->s_bev->output,
					    "\t<%s@@%s>:\r\n%s\r\n\r\n",
					    messagep->recipient.user, messagep->recipient.domain, messagep->session_errorline);
d750 2
a751 2
						evbuffer_add_printf(sessionp->s_bev->output,
						    "The following recipients caused a permanent failure:\r\n");
d755 5
a759 3
					evbuffer_add_printf(sessionp->s_bev->output,
					    "\t<%s@@%s>:\r\n%s\r\n\r\n",
					    messagep->recipient.user, messagep->recipient.domain, messagep->session_errorline);
d763 2
a764 2
			evbuffer_add_printf(sessionp->s_bev->output,
			    "Below is a copy of the original message:\r\n\r\n");
d770 1
a770 1
		evbuffer_add_printf(sessionp->s_bev->output, "QUIT\r\n");
d818 1
a818 1
			evbuffer_add_printf(sessionp->s_bev->output, "%s\r\n", buf);
d823 1
a823 1
			evbuffer_add_printf(sessionp->s_bev->output, ".\r\n");
@


1.18
log
@everything we need for the event handling dance is in struct session, the
write handler has been changed to set the bufferevent that's in there
rather than the one in struct batch. since struct batch is no longer doing
anything useful for events handling, we can remove many fields of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.17 2009/01/28 22:27:56 gilles Exp $	*/
d550 1
a550 1
		if (batchp->state == S_DONE) {
d558 1
a558 1
		batchp->state = S_GREETED;
d574 1
a574 1
		if (batchp->state == S_RCPT) {
d580 2
a581 2
		if (batchp->state == S_RCPT && batchp->messagep == NULL) {
			batchp->state = S_DATA;
d586 1
a586 1
		if (batchp->state == S_DONE) {
d606 1
a606 1
	switch (batchp->state) {
d625 1
a625 1
		batchp->state = S_MAIL;
d631 1
a631 1
		batchp->state = S_RCPT;
d764 1
a764 1
		batchp->state = S_QUIT;
d768 1
a768 1
		log_info("unknown command: %d", batchp->state);
d782 1
a782 1
	if (batchp->state == S_QUIT) {
d790 1
a790 1
	if (batchp->state == S_DATA) {
d817 1
a817 1
			batchp->state = S_DONE;
@


1.17
log
@since we're expanding "relay via ssl foobar.org" into two mxhosts (one with
F_SSMTP on port 465 and one with F_STARTTLS on port 25) both mxhosts should
only retain the flag that they will use ("via ssl" means the mxhost before
expansion has both flags set). this will make mta_connect() simpler when we
bring ssl support in the way.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.16 2009/01/28 21:44:15 gilles Exp $	*/
d153 1
d163 1
d168 1
a168 1
			evbuffer_add_printf(batchp->bev->output, "DATA\r\n");
d170 1
a170 1
			bufferevent_enable(batchp->bev, EV_WRITE|EV_READ);
d241 1
d264 1
a264 1
			TAILQ_INSERT_TAIL(&batchp->messages, messagep, entry);
a270 1
			struct session		 key;
d281 1
a281 5
			key.s_id = batchp->session_id;

			s = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
			if (s == NULL)
				fatalx("failed to retrieve mta session.");
a407 1
	struct batch *batchp = sessionp->batch;
d443 5
a447 5
	batchp->tv.tv_sec = SMTPD_CONNECT_TIMEOUT;
	batchp->tv.tv_usec = 0;
	batchp->peerfd = s;
	event_set(&batchp->ev, s, EV_TIMEOUT|EV_WRITE, mta_write, sessionp);
	event_add(&batchp->ev, &batchp->tv);
d467 3
a469 3
		if (batchp->bev) {
			bufferevent_free(batchp->bev);
			batchp->bev = NULL;
d485 6
a490 2
	batchp->bev = bufferevent_new(s, mta_read_handler, mta_write_handler,
	    mta_error_handler, batchp);
d492 1
a492 1
	if (batchp->bev == NULL) {
d498 1
a498 1
	bufferevent_enable(batchp->bev, EV_READ|EV_WRITE);
d511 2
a512 1
	struct batch *batchp = arg;
d557 1
a557 1
		evbuffer_add_printf(batchp->bev->output, "EHLO %s\r\n", env->sc_hostname);
d622 1
a622 1
			evbuffer_add_printf(batchp->bev->output, "MAIL FROM:<>\r\n");
d624 1
a624 1
			evbuffer_add_printf(batchp->bev->output, "MAIL FROM:<%s@@%s>\r\n", user, domain);
d665 1
a665 1
			evbuffer_add_printf(batchp->bev->output, "RCPT TO:<%s@@%s>\r\n", user, domain);
d681 1
a681 1
			bufferevent_disable(batchp->bev, EV_WRITE|EV_READ);
d689 1
a689 1
		bufferevent_enable(batchp->bev, EV_READ|EV_WRITE);
d691 1
a691 1
		evbuffer_add_printf(batchp->bev->output,
d698 1
a698 1
			evbuffer_add_printf(batchp->bev->output, "X-OpenSMTPD-Loop: %s@@%s\r\n",
d703 1
a703 1
			evbuffer_add_printf(batchp->bev->output,
d709 1
a709 1
				evbuffer_add_printf(batchp->bev->output,
d717 1
a717 1
				evbuffer_add_printf(batchp->bev->output,
d730 1
a730 1
						evbuffer_add_printf(batchp->bev->output,
d735 1
a735 1
					evbuffer_add_printf(batchp->bev->output,
d745 1
a745 1
						evbuffer_add_printf(batchp->bev->output,
d750 1
a750 1
					evbuffer_add_printf(batchp->bev->output,
d756 1
a756 1
			evbuffer_add_printf(batchp->bev->output,
d763 1
a763 1
		evbuffer_add_printf(batchp->bev->output, "QUIT\r\n");
d777 2
a778 1
	struct batch *batchp = arg;
d781 1
a781 1

d785 1
a785 1
		close(batchp->peerfd);
d809 1
a809 1
				evbuffer_add_printf(batchp->bev->output, ".");
d811 1
a811 1
			evbuffer_add_printf(batchp->bev->output, "%s\r\n", buf);
d816 1
a816 1
			evbuffer_add_printf(batchp->bev->output, ".\r\n");
d822 1
a822 1
	bufferevent_enable(batchp->bev, EV_READ|EV_WRITE);
d828 2
a829 1
	struct batch *batchp = arg;
d833 1
a833 1
		close(batchp->peerfd);
d864 1
a864 4
	key.s_id = batchp->session_id;
	sessionp = SPLAY_FIND(sessiontree, &env->sc_sessions, &key);
	if (sessionp == NULL)
		fatalx("failed to retrieve mta session.");
d871 2
a872 2
	if (batchp->bev)
		bufferevent_free(batchp->bev);
d874 2
a875 2
	if (batchp->peerfd != -1)
		close(batchp->peerfd);
@


1.16
log
@first steps towards better mta code. currently mta uses struct batch to
store a lot of its session related code, but this is just not right and
this commit starts making mta code aware of struct session. This will
ease the implementation of ssl sessions in mta.

while at it, make mta autodetect port to use if it isn't provided in a
rule but can be derived from a parameter (i.e: "relay via ssmtp ...").
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.15 2009/01/28 13:29:40 gilles Exp $	*/
d946 3
a948 1
		case F_SSL:
d957 1
d968 1
d971 1
@


1.15
log
@bring loop detection support. we handle this with a qmail-like approach which
consists of checking headers for a custom header, but we also count how many
hops the mail went through and use a hard limit (currently set to 100 as was
recommanded by RFC) as a safe-guard.

idea discussed with jacekm@@, qmail approach suggested by claudio@@ a long time
ago
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.14 2009/01/28 11:27:57 gilles Exp $	*/
d48 1
a48 1
int		mta_connect(struct batch *);
d54 1
d218 1
d221 9
d235 1
d240 2
d266 3
a268 1
			struct batch	*batchp;
d277 11
a287 2
			while (! mta_connect(batchp)) {
				if (batchp->mx_off == batchp->mx_cnt) {
a288 2
				}
			}
d403 1
a403 1
mta_connect(struct batch *batchp)
d410 1
d412 1
a412 1
	if ((s = socket(batchp->mxarray[batchp->mx_off].ss.ss_family, SOCK_STREAM, 0)) == -1) {
d428 2
a429 2
	if (batchp->mxarray[batchp->mx_off].ss.ss_family == PF_INET) {
		ssin = *(struct sockaddr_in *)&batchp->mxarray[batchp->mx_off].ss;
d437 2
a438 2
	if (batchp->mxarray[batchp->mx_off].ss.ss_family == PF_INET6) {
		ssin6 = *(struct sockaddr_in6 *)&batchp->mxarray[batchp->mx_off].ss;
d449 1
a449 1
	event_set(&batchp->ev, s, EV_TIMEOUT|EV_WRITE, mta_write, batchp);
d455 1
a455 1
	batchp->mx_off++;
d463 2
a464 1
	struct batch *batchp = arg;
d468 1
a468 1
		batchp->mx_off++;
d477 2
a478 2
		while (batchp->mx_off < batchp->mx_cnt &&
		    (ret = mta_connect(batchp)) == 0) {
d839 2
d860 5
d877 114
@


1.14
log
@add a struct path to struct message so that we can keep track of the RCPT
provided recipient even after aliases/forwards expansion, we'll need this
for loop detection.

message id and uid being MAXPATHLEN long is a waste, define MAX_ID_SIZE
which is currently set to 64 (but can probably be further reduced) and
make sure that structures and the few strlcpy's use the right define.

original idea by jacekm@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.13 2009/01/12 19:56:27 jacekm Exp $	*/
d671 1
a671 1
			evbuffer_add_printf(batchp->bev->output, "X-Delivered-To: %s@@%s\r\n",
@


1.13
log
@dot escaping, as required by rfc; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.12 2009/01/01 16:15:47 jacekm Exp $	*/
d670 4
a673 1
		evbuffer_add_printf(batchp->bev->output, "X-OpenSMTPD: experiment\r\n");
@


1.12
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.11 2008/12/13 23:19:34 jacekm Exp $	*/
d772 8
@


1.11
log
@IMSG_* namespace cleanup.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.10 2008/12/06 02:43:58 jacekm Exp $	*/
a30 1
#include <fcntl.h>
a31 1
#include <signal.h>
a32 1
#include <stdint.h>
@


1.10
log
@evbuffer_readline already strips <CRLF> so that callers don't have to.

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.9 2008/12/05 19:09:59 gilles Exp $	*/
d219 1
a219 1
		case IMSG_CREATE_BATCH: {
@


1.9
log
@- more err/errx -> fatal/fatalx, warn/warnx -> log_warn/log_warnx
	contains bits based on an old diff from Jacek Masiulaniec and
	other bits from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.8 2008/12/05 02:51:32 gilles Exp $	*/
a504 2

	line[strcspn(line, "\r")] = '\0';
@


1.8
log
@- last part of the new queue code: the runner process (unprivileged and
	chrooted) is now in charge of doing the scheduling of deliveries,
	and the dispatching of messages to MDA and MTA. queue process only
	does inserts/updates/removals from the queue and can no longer be
	so busy that it delays answers to imsg from smtp server.
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.7 2008/11/25 20:26:40 gilles Exp $	*/
a28 1
#include <err.h>
d159 1
a159 1
				errx(1, "imsg_get_fd");
d166 1
a166 1
				err(1, "fdopen");
d224 1
a224 1
				err(1, "calloc");
d242 1
a242 1
				fatal("calloc");
d248 1
a248 1
				errx(1, "%s: internal inconsistency.", __func__);
d260 1
a260 1
				errx(1, "%s: internal inconsistency.", __func__);
d772 1
a772 1
					err(1, "malloc");
@


1.7
log
@- recent change in parse.y caused htons() to be called twice on the port
	provided to "relay via" rules, once in parse.y once in lka.c, fix.
- rename struct address to struct relayhost, introduce struct mxhost which
	not only holds the sockaddr_storage, but also additionnal flags we
	want forwarded to the mta process.
- propagate the change
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.6 2008/11/24 22:30:19 gilles Exp $	*/
d47 1
d154 66
a271 20
		case IMSG_QUEUE_MESSAGE_FD: {
			struct batch	*batchp;
			int fd;

			if ((fd = imsg_get_fd(ibuf, &imsg)) == -1) {
				/* NEEDS_FIX - unsure yet how it must be handled */
				errx(1, "imsg_get_fd");
			}

			batchp = (struct batch *)imsg.data;
			batchp = batch_by_id(env, batchp->id);

			if ((batchp->messagefp = fdopen(fd, "r")) == NULL)
				err(1, "fdopen");

			evbuffer_add_printf(batchp->bev->output, "DATA\r\n");

			bufferevent_enable(batchp->bev, EV_WRITE|EV_READ);
			break;
		}
d273 1
a273 1
			log_debug("parent_dispatch_mta: unexpected imsg %d",
d327 2
a328 1
		{ PROC_QUEUE,	mta_dispatch_queue }
d371 1
a371 1
	config_peers(env, peers, 1);
@


1.6
log
@- not really a bug since we don't use other descriptor flags, but in
	smtp_setup_events() and mta_connect(), our fcntl() use clears
	flags. use session_socket_blockmode() instead, it makes more
	sense anyway. From Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.5 2008/11/11 02:14:58 tedu Exp $	*/
d161 1
a161 1
			batchp->ss_off = 0;
d199 1
a199 1
				if (batchp->ss_off == batchp->ss_cnt) {
d344 1
a344 1
	if ((s = socket(batchp->ss[batchp->ss_off].ss_family, SOCK_STREAM, 0)) == -1) {
d360 2
a361 2
	if (batchp->ss[batchp->ss_off].ss_family == PF_INET) {
		ssin = *(struct sockaddr_in *)&batchp->ss[batchp->ss_off];
d369 2
a370 2
	if (batchp->ss[batchp->ss_off].ss_family == PF_INET6) {
		ssin6 = *(struct sockaddr_in6 *)&batchp->ss[batchp->ss_off];
d387 1
a387 1
	batchp->ss_off++;
d399 1
a399 1
		batchp->ss_off++;
d408 1
a408 1
		while (batchp->ss_off < batchp->ss_cnt &&
@


1.5
log
@some small improvements.  ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.4 2008/11/10 22:35:23 gilles Exp $	*/
d358 1
a358 3
	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1) {
		goto bad;
	}
@


1.4
log
@- define MAX_LINE_SIZE which is the maximum length of a line we allow from
	a client. it must be set to the highest value we have from all of
	the extensions which are/will be implemented.
- replace all occurences of STRLEN define with MAX_LINE_SIZE, kill STRLEN
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.3 2008/11/10 02:34:50 gilles Exp $	*/
d452 1
a452 1
	char *errstr;
d468 1
a468 1
	code = strtonum(codebuf, 0, UINT16_MAX, (const char **)&errstr);
d734 1
@


1.3
log
@- plug a descriptor leak when session is aborted by a server error instead
	of a client QUIT or client timeout
@
text
@d1 1
a1 1
/*	$OpenBSD: mta.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d407 1
a407 1
		strlcpy(batchp->errorline, "connection timed-out.", STRLEN);
d472 1
a472 1
		strlcpy(batchp->errorline, line, STRLEN);
d498 1
a498 1
		strlcpy(batchp->errorline, line, STRLEN);
d509 1
a509 1
			strlcpy(batchp->messagep->session_errorline, line, STRLEN);
d533 1
a533 1
		strlcpy(batchp->errorline, line, STRLEN);
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d713 1
d751 1
d788 3
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

