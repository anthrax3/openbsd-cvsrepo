head	1.67;
access;
symbols
	OPENBSD_6_2_BASE:1.67
	OPENBSD_6_1:1.66.0.4
	OPENBSD_6_1_BASE:1.66
	OPENBSD_6_0:1.65.0.4
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.64.0.2
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.52.0.6
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.48.0.2
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.43.0.2
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11;
locks; strict;
comment	@ * @;


1.67
date	2017.07.27.18.48.30;	author sunil;	state Exp;
branches;
next	1.66;
commitid	pWVSSHgiJqkUHVKn;

1.66
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.65;
commitid	jM4eOMW1AJwdfKrr;

1.65
date	2016.03.17.19.40.43;	author krw;	state Exp;
branches;
next	1.64;
commitid	aCmYZrmRmWHLuztW;

1.64
date	2016.02.13.08.53.18;	author gilles;	state Exp;
branches;
next	1.63;
commitid	746RTjP2xtXLq8rn;

1.63
date	2016.02.12.03.11.16;	author sunil;	state Exp;
branches;
next	1.62;
commitid	QRjpFVsr3g0wCTYa;

1.62
date	2016.02.10.09.23.53;	author gilles;	state Exp;
branches;
next	1.61;
commitid	f62TF4lKXxT5C9P3;

1.61
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.60;
commitid	ZxnqOQqX6IeYI9jW;

1.60
date	2015.12.15.06.05.15;	author guenther;	state Exp;
branches;
next	1.59;
commitid	sYGGy825PAqrNRs2;

1.59
date	2015.12.13.11.06.19;	author sunil;	state Exp;
branches;
next	1.58;
commitid	C7gMN68Grn4oHQJJ;

1.58
date	2015.12.11.07.10.06;	author guenther;	state Exp;
branches;
next	1.57;
commitid	G9fbs9KCMydJ1jec;

1.57
date	2015.12.07.12.29.19;	author sunil;	state Exp;
branches;
next	1.56;
commitid	NjgUX1eM1Q27CUqm;

1.56
date	2015.10.26.16.38.06;	author sunil;	state Exp;
branches;
next	1.55;
commitid	xMZTQlrFCOypbtwA;

1.55
date	2015.10.17.19.44.07;	author gilles;	state Exp;
branches;
next	1.54;
commitid	ObaVkZtILLiL7Wb5;

1.54
date	2015.10.12.07.58.19;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	SD2NAm0X1clljRst;

1.53
date	2015.10.06.06.04.46;	author gilles;	state Exp;
branches;
next	1.52;
commitid	kHsLvobU8ObZj5n9;

1.52
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	ZBTFreARDSMmzOIV;

1.51
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	Uu5nFG3wCl0LACBb;

1.50
date	2014.10.25.18.48.30;	author gilles;	state Exp;
branches;
next	1.49;
commitid	sZBqzapuTQACAP46;

1.49
date	2014.07.08.13.49.09;	author eric;	state Exp;
branches;
next	1.48;
commitid	pEybL9fsrDOC6PJj;

1.48
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.28.10.43.37;	author eric;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.29.10.50.55;	author eric;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.29.12.56.19;	author tobias;	state Exp;
branches;
next	1.43;

1.43
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.41;

1.41
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.40;

1.40
date	2012.10.13.09.44.25;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2012.10.08.19.45.11;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.07.16.57.14;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2012.09.27.20.34.15;	author chl;	state Exp;
branches;
next	1.36;

1.36
date	2012.09.19.12.59.59;	author eric;	state Exp;
branches;
next	1.35;

1.35
date	2012.09.19.12.45.04;	author eric;	state Exp;
branches;
next	1.34;

1.34
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.29.17.21.43;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2011.05.16.21.27.38;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2011.05.09.09.36.55;	author eric;	state Exp;
branches;
next	1.30;

1.30
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.27.09.49.23;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.21.21.40.56;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.08.23.08.56;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.03.22.57.41;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.17.12.46.47;	author sobrado;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.12.18.19.46;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.08.00.02.22;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.28.20.51.50;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.30.23.53.41;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.10.11.29.40;	author jacekm;	state Exp;
branches;
next	1.16;

1.16
date	2009.04.24.10.02.35;	author jacekm;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.19.22.03.33;	author jacekm;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.09.16.31.09;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.06.23.32.34;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.06.23.29.06;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.17.23.50.58;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.17.23.43.57;	author jacekm;	state Exp;
branches;
next	1.8;

1.8
date	2009.02.14.18.37.12;	author jacekm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.21.12.59.05;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.18.15.19.33;	author jacekm;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.17.23.09.23;	author jacekm;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.17.22.59.36;	author jacekm;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.13.13.15.38;	author jacekm;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.03.21.20.20;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.67
log
@smtpctl(8): Use an int to determine mode instead of __progname.

Ok millert@@ gilles@@
@
text
@/*	$OpenBSD: makemap.c,v 1.66 2017/01/09 09:53:23 reyk Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2008-2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/tree.h>
#include <sys/queue.h>
#include <sys/socket.h>

#include <ctype.h>
#include <db.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>

#include "smtpd.h"
#include "log.h"

#define	PATH_ALIASES	"/etc/mail/aliases"

static void	 usage(void);
static int	 parse_map(DB *, int *, char *);
static int	 parse_entry(DB *, int *, char *, size_t, size_t);
static int	 parse_mapentry(DB *, int *, char *, size_t, size_t);
static int	 parse_setentry(DB *, int *, char *, size_t, size_t);
static int	 make_plain(DBT *, char *);
static int	 make_aliases(DBT *, char *);
static char	*conf_aliases(char *);
static int	 dump_db(const char *, DBTYPE);

struct smtpd	 smtpd;
struct smtpd	*env = &smtpd;
char		*source;
static int	 mode;

enum output_type {
	T_PLAIN,
	T_ALIASES,
	T_SET
} type;

/*
 * Stub functions so that makemap compiles using minimum object files.
 */
void
purge_config(uint8_t what)
{
	memset(env, 0, sizeof(struct smtpd));
}

int
fork_proc_backend(const char *backend, const char *conf, const char *procname)
{
	return (-1);
}

int
makemap(int prog_mode, int argc, char *argv[])
{
	struct stat	 sb;
	char		 dbname[PATH_MAX];
	DB		*db;
	const char	*opts;
	char		*conf, *oflag = NULL;
	int		 ch, dbputs = 0, Uflag = 0;
	DBTYPE		 dbtype = DB_HASH;
	char		*p;
	int		 fd = -1;

	log_init(1, LOG_MAIL);

	mode = prog_mode;
	conf = CONF_FILE;
	type = T_PLAIN;
	opts = "b:C:d:ho:O:t:U";
	if (mode == P_NEWALIASES)
		opts = "f:h";

	while ((ch = getopt(argc, argv, opts)) != -1) {
		switch (ch) {
		case 'b':
			if (optarg && strcmp(optarg, "i") == 0)
				mode = P_NEWALIASES;
			break;
		case 'C':
			break; /* for compatibility */
		case 'd':
			if (strcmp(optarg, "hash") == 0)
				dbtype = DB_HASH;
			else if (strcmp(optarg, "btree") == 0)
				dbtype = DB_BTREE;
			else
				errx(1, "unsupported DB type '%s'", optarg);
			break;
		case 'f':
			conf = optarg;
			break;
		case 'o':
			oflag = optarg;
			break;
		case 'O':
			if (strncmp(optarg, "AliasFile=", 10) != 0)
				break;
			type = T_ALIASES;
			p = strchr(optarg, '=');
			source = ++p;
			break;
		case 't':
			if (strcmp(optarg, "aliases") == 0)
				type = T_ALIASES;
			else if (strcmp(optarg, "set") == 0)
				type = T_SET;
			else
				errx(1, "unsupported type '%s'", optarg);
			break;
		case 'U':
			Uflag = 1;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	/* sendmail-compat makemap ... re-execute using proper interface */
	if (argc == 2) {
		if (oflag)
			usage();

		p = strstr(argv[1], ".db");
		if (p == NULL || strcmp(p, ".db") != 0) {
			if (!bsnprintf(dbname, sizeof dbname, "%s.db",
				argv[1]))
				errx(1, "database name too long");
		}
		else {
			if (strlcpy(dbname, argv[1], sizeof dbname)
			    >= sizeof dbname)
				errx(1, "database name too long");
		}

		execlp("makemap", "makemap", "-d", argv[0], "-o", dbname, "-",
		    (char *)NULL);
		err(1, "execlp");
	}

	if (mode == P_NEWALIASES) {
		if (geteuid())
			errx(1, "need root privileges");
		if (argc != 0)
			usage();
		type = T_ALIASES;
		if (source == NULL)
			source = conf_aliases(conf);
	} else {
		if (argc != 1)
			usage();
		source = argv[0];
	}

	if (Uflag)
		return dump_db(source, dbtype);

	if (oflag == NULL && asprintf(&oflag, "%s.db", source) == -1)
		err(1, "asprintf");

	if (strcmp(source, "-") != 0)
		if (stat(source, &sb) == -1)
			err(1, "stat: %s", source);

	if (!bsnprintf(dbname, sizeof(dbname), "%s.XXXXXXXXXXX", oflag))
		errx(1, "path too long");
	if ((fd = mkstemp(dbname)) == -1)
		err(1, "mkstemp");

	db = dbopen(dbname, O_TRUNC|O_RDWR, 0644, dbtype, NULL);
	if (db == NULL) {
		warn("dbopen: %s", dbname);
		goto bad;
	}

	if (strcmp(source, "-") != 0)
		if (fchmod(db->fd(db), sb.st_mode) == -1 ||
		    fchown(db->fd(db), sb.st_uid, sb.st_gid) == -1) {
			warn("couldn't carry ownership and perms to %s",
			    dbname);
			goto bad;
		}

	if (!parse_map(db, &dbputs, source))
		goto bad;

	if (db->close(db) == -1) {
		warn("dbclose: %s", dbname);
		goto bad;
	}

	/* force to disk before renaming over an existing file */
	if (fsync(fd) == -1) {
		warn("fsync: %s", dbname);
		goto bad;
	}
	if (close(fd) == -1) {
		fd = -1;
		warn("close: %s", dbname);
		goto bad;
	}
	fd = -1;

	if (rename(dbname, oflag) == -1) {
		warn("rename");
		goto bad;
	}

	if (mode == P_NEWALIASES)
		printf("%s: %d aliases\n", source, dbputs);
	else if (dbputs == 0)
		warnx("warning: empty map created: %s", oflag);

	return 0;
bad:
	if (fd != -1)
		close(fd);
	unlink(dbname);
	return 1;
}

static int
parse_map(DB *db, int *dbputs, char *filename)
{
	FILE	*fp;
	char	*line;
	size_t	 len;
	size_t	 lineno = 0;

	if (strcmp(filename, "-") == 0)
		fp = fdopen(0, "r");
	else
		fp = fopen(filename, "r");
	if (fp == NULL) {
		warn("%s", filename);
		return 0;
	}

	if (!isatty(fileno(fp)) && flock(fileno(fp), LOCK_SH|LOCK_NB) == -1) {
		if (errno == EWOULDBLOCK)
			warnx("%s is locked", filename);
		else
			warn("%s: flock", filename);
		fclose(fp);
		return 0;
	}

	while ((line = fparseln(fp, &len, &lineno,
	    NULL, FPARSELN_UNESCCOMM)) != NULL) {
		if (!parse_entry(db, dbputs, line, len, lineno)) {
			free(line);
			fclose(fp);
			return 0;
		}
		free(line);
	}

	fclose(fp);
	return 1;
}

static int
parse_entry(DB *db, int *dbputs, char *line, size_t len, size_t lineno)
{
	switch (type) {
	case T_PLAIN:
	case T_ALIASES:
		return parse_mapentry(db, dbputs, line, len, lineno);
	case T_SET:
		return parse_setentry(db, dbputs, line, len, lineno);
	}
	return 0;
}

static int
parse_mapentry(DB *db, int *dbputs, char *line, size_t len, size_t lineno)
{
	DBT	 key;
	DBT	 val;
	char	*keyp;
	char	*valp;

	keyp = line;
	while (isspace((unsigned char)*keyp))
		keyp++;
	if (*keyp == '\0')
		return 1;

	valp = keyp;
	strsep(&valp, " \t:");
	if (valp == NULL || valp == keyp)
		goto bad;
	while (*valp == ':' || isspace((unsigned char)*valp))
		valp++;
	if (*valp == '\0')
		goto bad;

	/* Check for dups. */
	key.data = keyp;
	key.size = strlen(keyp) + 1;

	xlowercase(key.data, key.data, strlen(key.data) + 1);
	if (db->get(db, &key, &val, 0) == 0) {
		warnx("%s:%zd: duplicate entry for %s", source, lineno, keyp);
		return 0;
	}

	if (type == T_PLAIN) {
		if (!make_plain(&val, valp))
			goto bad;
	}
	else if (type == T_ALIASES) {
		if (!make_aliases(&val, valp))
			goto bad;
	}

	if (db->put(db, &key, &val, 0) == -1) {
		warn("dbput");
		return 0;
	}

	(*dbputs)++;

	free(val.data);

	return 1;

bad:
	warnx("%s:%zd: invalid entry", source, lineno);
	return 0;
}

static int
parse_setentry(DB *db, int *dbputs, char *line, size_t len, size_t lineno)
{
	DBT	 key;
	DBT	 val;
	char	*keyp;

	keyp = line;
	while (isspace((unsigned char)*keyp))
		keyp++;
	if (*keyp == '\0')
		return 1;

	val.data  = "<set>";
	val.size = strlen(val.data) + 1;

	/* Check for dups. */
	key.data = keyp;
	key.size = strlen(keyp) + 1;
	xlowercase(key.data, key.data, strlen(key.data) + 1);
	if (db->get(db, &key, &val, 0) == 0) {
		warnx("%s:%zd: duplicate entry for %s", source, lineno, keyp);
		return 0;
	}

	if (db->put(db, &key, &val, 0) == -1) {
		warn("dbput");
		return 0;
	}

	(*dbputs)++;

	return 1;
}

static int
make_plain(DBT *val, char *text)
{
	val->data = xstrdup(text, "make_plain");
	val->size = strlen(text) + 1;

	return (val->size);
}

static int
make_aliases(DBT *val, char *text)
{
	struct expandnode	xn;
	char		       *subrcpt;
	char		       *origtext;

	val->data = NULL;
	val->size = 0;

	origtext = xstrdup(text, "make_aliases");

	while ((subrcpt = strsep(&text, ",")) != NULL) {
		/* subrcpt: strip initial and trailing whitespace. */
		subrcpt = strip(subrcpt);
		if (*subrcpt == '\0')
			goto error;

		if (!text_to_expandnode(&xn, subrcpt))
			goto error;
	}

	val->data = origtext;
	val->size = strlen(origtext) + 1;
	return (val->size);

error:
	free(origtext);

	return 0;
}

static char *
conf_aliases(char *cfgpath)
{
	struct table	*table;
	char		*path;
	char		*p;

	if (parse_config(env, cfgpath, 0))
		exit(1);

	table = table_find("aliases", NULL);
	if (table == NULL)
		return (PATH_ALIASES);

	path = xstrdup(table->t_config, "conf_aliases");
	p = strstr(path, ".db");
	if (p == NULL || strcmp(p, ".db") != 0) {
		return (path);
	}
	*p = '\0';
	return (path);
}

static int
dump_db(const char *dbname, DBTYPE dbtype)
{
	DB	*db;
	DBT	 key, val;
	char	*keystr, *valstr;
	int	 r;

	db = dbopen(dbname, O_RDONLY, 0644, dbtype, NULL);
	if (db == NULL)
		err(1, "dbopen: %s", dbname);

	for (r = db->seq(db, &key, &val, R_FIRST); r == 0;
	    r = db->seq(db, &key, &val, R_NEXT)) {
		keystr = key.data;
		valstr = val.data;
		if (keystr[key.size - 1] == '\0')
			key.size--;
		if (valstr[val.size - 1] == '\0')
			val.size--;
		printf("%.*s\t%.*s\n", (int)key.size, keystr,
		    (int)val.size, valstr);
	}
	if (r == -1)
		err(1, "db->seq: %s", dbname);

	if (db->close(db) == -1)
		err(1, "dbclose: %s", dbname);

	return 0;
}

static void
usage(void)
{
	if (mode == P_NEWALIASES)
		fprintf(stderr, "usage: newaliases [-f file]\n");
	else
		fprintf(stderr, "usage: makemap [-U] [-d dbtype] [-o dbfile] "
		    "[-t type] file\n");
	exit(1);
}
@


1.66
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.65 2016/03/17 19:40:43 krw Exp $	*/
d58 1
a58 6
extern char	*__progname;

enum program {
	P_MAKEMAP,
	P_NEWALIASES
} mode;
d82 1
a82 1
makemap(int argc, char *argv[])
d96 1
a96 1
	mode = strcmp(__progname, "newaliases") ? P_MAKEMAP : P_NEWALIASES;
d499 1
a499 1
		fprintf(stderr, "usage: %s [-f file]\n", __progname);
d501 2
a502 2
		fprintf(stderr, "usage: %s [-U] [-d dbtype] [-o dbfile] "
		    "[-t type] file\n", __progname);
@


1.65
log
@Last parameter to execl[e]() functions *must* be cast to a pointer.
Just NULL is not good practise as NULL is theoretically allowed to
be an integer rather than a pointer.

Use (char *)NULL consistently instead of scattering a few (char *)0
and (void *)NULL into the mix.

Prompted by and probably ok deraadt@@ millert@@ kettenis@@

Definitely ok mestre@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.64 2016/02/13 08:53:18 gilles Exp $	*/
d99 1
a99 1
	log_init(1);
@


1.64
log
@remove support for 'dbm' which is really 'recno' from our makemap, it can't
work because it requires dbopen() to be the call that creates the db, while
we want mkstemp() to create an empty db ourselves.

it has never worked, no one could ever create a recno db with our makemap &
no one actually noticed so drop it.

ok millert@@, sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.63 2016/02/12 03:11:16 sunil Exp $	*/
d173 1
a173 1
		    NULL);
@


1.63
log
@Cleanup getopt(3) mis-use in sendmail compat code.

Avoid multiple getopt(3) evaluations without optreset set and
unspecified behavior of optind = 0 as per POSIX. Instead, iterate
over argv the first time for classification. Fixes -portable without
any divergence from -current, and all newaliases opts are handled
in one place.

Looks good to me millert@@
Ok gilles@@ jung@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.62 2016/02/10 09:23:53 gilles Exp $	*/
a120 2
			else if (strcmp(optarg, "dbm") == 0)
				dbtype = DB_RECNO;
@


1.62
log
@when creating a db map, we use a temporary file to work on and atomically
move to destination when done. this causes dbopen() to be called with an
empty file which happens to... not work with other db libraries.

adding O_TRUNC is noop for us, fixes the issue for other libraries and
lets us reduce delta between us and portable.

ok sunil@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.61 2015/12/28 22:08:30 jung Exp $	*/
d53 1
a53 1
static int	dump_db(const char *, DBTYPE);
d97 1
a97 1
	int		fd = -1;
d104 1
a104 1
	opts = "ho:t:d:U";
d110 6
d132 7
d185 2
a186 1
		source = conf_aliases(conf);
@


1.61
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.60 2015/12/15 06:05:15 guenther Exp $	*/
d194 1
a194 1
	db = dbopen(dbname, O_RDWR, 0644, dbtype, NULL);
@


1.60
log
@Sync the DB file once when done with fsync(), not on each write with O_SYNC.
The DB file being written is a temp file, so O_EXLOCK is unnecesary.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.59 2015/12/13 11:06:19 sunil Exp $	*/
d151 1
a151 1
			if (! bsnprintf(dbname, sizeof dbname, "%s.db",
d189 1
a189 1
	if (! bsnprintf(dbname, sizeof(dbname), "%s.XXXXXXXXXXX", oflag))
d208 1
a208 1
	if (! parse_map(db, &dbputs, source))
d274 1
a274 1
		if (! parse_entry(db, dbputs, line, len, lineno)) {
d333 1
a333 1
		if (! make_plain(&val, valp))
d337 1
a337 1
		if (! make_aliases(&val, valp))
d419 1
a419 1
		if (! text_to_expandnode(&xn, subrcpt))
@


1.59
log
@Move some variables local to makemap().

Suggested by guenther@@ Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.58 2015/12/11 07:10:06 guenther Exp $	*/
d97 1
d191 1
a191 1
	if (mkstemp(dbname) == -1)
d194 1
a194 1
	db = dbopen(dbname, O_EXLOCK|O_RDWR|O_SYNC, 0644, dbtype, NULL);
d216 12
d240 2
@


1.58
log
@Add -U option like the sendmail makemap, for dumping DB files back to text

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.57 2015/12/07 12:29:19 sunil Exp $	*/
d46 4
a49 4
static int	 parse_map(char *);
static int	 parse_entry(char *, size_t, size_t);
static int	 parse_mapentry(char *, size_t, size_t);
static int	 parse_setentry(char *, size_t, size_t);
d55 1
a55 7
DB	*db;
char	*source;
char	*oflag;
int	 Uflag;
int	 dbputs;

struct smtpd	smtpd;
d57 1
d91 1
d93 2
a94 2
	char		*conf;
	int		 ch;
d207 1
a207 1
	if (! parse_map(source))
d232 1
a232 1
parse_map(char *filename)
d259 1
a259 1
		if (! parse_entry(line, len, lineno)) {
d272 1
a272 1
parse_entry(char *line, size_t len, size_t lineno)
d277 1
a277 1
		return parse_mapentry(line, len, lineno);
d279 1
a279 1
		return parse_setentry(line, len, lineno);
d285 1
a285 1
parse_mapentry(char *line, size_t len, size_t lineno)
d331 1
a331 1
	dbputs++;
d343 1
a343 1
parse_setentry(char *line, size_t len, size_t lineno)
d372 1
a372 1
	dbputs++;
d444 2
a445 1
	DBT	key, val;
d447 1
a447 1
	int	r;
d479 1
a479 1
		fprintf(stderr, "usage: %s [-d dbtype] [-o dbfile] "
@


1.57
log
@Merge makemap(8) into smtpctl(8).

Ok gilles@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.56 2015/10/26 16:38:06 sunil Exp $	*/
d53 1
d58 1
d96 1
a96 1
	char		*opts;
d107 1
a107 1
	opts = "ho:t:d:";
d137 3
d182 3
d443 31
@


1.56
log
@Fix makemap(8) for values containing a '#'.

Ok millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.55 2015/10/17 19:44:07 gilles Exp $	*/
d45 8
a52 10
extern char *__progname;

__dead void	usage(void);
static int parse_map(char *);
static int parse_entry(char *, size_t, size_t);
static int parse_mapentry(char *, size_t, size_t);
static int parse_setentry(char *, size_t, size_t);
static int make_plain(DBT *, char *);
static int make_aliases(DBT *, char *);
static char *conf_aliases(char *);
d61 1
d90 1
a90 1
main(int argc, char *argv[])
d227 1
a227 1
int
d267 1
a267 1
int
d280 1
a280 1
int
d338 1
a338 1
int
d373 1
a373 1
int
d382 1
a382 1
int
d414 1
a414 1
char *
d437 1
a437 1
void
@


1.55
log
@makemap shout strip initial and trailing whitespaces using strip()

ok millert@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.54 2015/10/12 07:58:19 deraadt Exp $	*/
a234 1
	char	 delim[] = { '\\', '\\', '#' };
d254 2
a255 1
	while ((line = fparseln(fp, &len, &lineno, delim, 0)) != NULL) {
d292 1
a292 1
	if (*keyp == '\0' || *keyp == '#')
d301 1
a301 1
	if (*valp == '\0' || *valp == '#')
d349 1
a349 1
	if (*keyp == '\0' || *keyp == '#')
@


1.54
log
@do not umask() [with the wrong umask] around mkstemp() calls, no matter
how broken other systems are.
ok guenther gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.53 2015/10/06 06:04:46 gilles Exp $	*/
a387 1
	char		       *endp;
d396 2
a397 3
		/* subrcpt: strip initial whitespace. */
		while (isspace((unsigned char)*subrcpt))
			++subrcpt;
a399 5

		/* subrcpt: strip trailing whitespace. */
		endp = subrcpt + strlen(subrcpt) - 1;
		while (subrcpt < endp && isspace((unsigned char)*endp))
			*endp-- = '\0';
@


1.53
log
@fix values passed to umask(), they should be octal.
the permissions are even more restrictive than they should.

misc bug reported by qualys
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.52 2015/01/20 17:37:54 deraadt Exp $	*/
a99 1
	mode_t		 omode;
a186 1
	omode = umask(07077);
a188 1
	umask(omode);
@


1.52
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.51 2015/01/16 06:40:20 deraadt Exp $	*/
d188 1
a188 1
	omode = umask(7077);
@


1.51
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.50 2014/10/25 18:48:30 gilles Exp $	*/
d94 1
a94 1
	char		 dbname[SMTPD_MAXPATHLEN];
@


1.50
log
@newaliases / makemap should parse multi-line aliases entries
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.49 2014/07/08 13:49:09 eric Exp $	*/
d37 1
@


1.49
log
@Update the table API: lookup functions can take an optional parameters
dictionnary (currently not set). While there, add a helper for forking
external backends, and remove unused table functions.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d237 1
a237 1
	char	 delim[] = { '\\', 0, 0 };
@


1.48
log
@bcopy -> memmove
bzero -> memset
@
text
@d84 6
@


1.47
log
@unsigned char casts for ctype
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.46 2013/10/29 10:50:55 eric Exp $	*/
d80 1
a80 1
	bzero(env, sizeof(struct smtpd));
@


1.46
log
@sort includes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d286 1
a286 1
	while (isspace((int)*keyp))
d295 1
a295 1
	while (*valp == ':' || isspace((int)*valp))
d343 1
a343 1
	while (isspace((int)*keyp))
d394 1
a394 1
		while (isspace((int)*subrcpt))
d401 1
a401 1
		while (subrcpt < endp && isspace((int)*endp))
@


1.45
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.43 2013/01/31 18:34:43 eric Exp $	*/
d26 1
a27 1
#include <ctype.h>
@


1.44
log
@Prevent race conditions in db file handling.

ok gilles
@
text
@a23 1
#include <sys/param.h>
d36 1
a37 1
#include <unistd.h>
d47 1
a47 1
static int parse_map(FILE *, char *);
d87 1
a87 2
	char		 dbname[MAXPATHLEN];
	FILE		*fp;
d93 1
d175 4
d181 4
d186 1
a186 5
	if (mktemp(dbname) == NULL)
		err(1, "mktemp");

	db = dbopen(dbname, O_EXCL|O_CREAT|O_EXLOCK|O_RDWR|O_SYNC, 0644,
		    dbtype, NULL);
d193 2
a194 13
		fp = fopen(source, "r");
	else
		fp = fdopen(STDIN_FILENO, "r");
	if (fp == NULL) {
		warn("%s", source);
		goto bad;
	}

	if (strcmp(source, "-") != 0) {
		if (fstat(fileno(fp), &sb) == -1)
			err(1, "stat: %s", source);
		if (fchown(db->fd(db), sb.st_uid, sb.st_gid) == -1 ||
		    fchmod(db->fd(db), sb.st_mode) == -1) {
a198 1
	}
d200 1
a200 1
	if (! parse_map(fp, source))
d225 1
a225 1
parse_map(FILE *fp, char *filename)
d227 1
d233 9
d428 1
a428 1
	table = table_findbyname("aliases");
@


1.43
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.42 2013/01/26 09:37:23 gilles Exp $	*/
d48 1
a48 1
static int parse_map(char *);
d89 1
a94 1
	mode_t		 omode;
a175 4
	if (strcmp(source, "-") != 0)
		if (stat(source, &sb) == -1)
			err(1, "stat: %s", source);

a177 4
	omode = umask(7077);
	if (mkstemp(dbname) == -1)
		err(1, "mkstemp");
	umask(omode);
d179 5
a183 1
	db = dbopen(dbname, O_EXLOCK|O_RDWR|O_SYNC, 0644, dbtype, NULL);
d190 13
a202 2
		if (fchmod(db->fd(db), sb.st_mode) == -1 ||
		    fchown(db->fd(db), sb.st_uid, sb.st_gid) == -1) {
d207 1
d209 1
a209 1
	if (! parse_map(source))
d234 1
a234 1
parse_map(char *filename)
a235 1
	FILE	*fp;
a239 9

	if (strcmp(filename, "-") == 0)
		fp = fdopen(0, "r");
	else
		fp = fopen(filename, "r");
	if (fp == NULL) {
		warn("%s", filename);
		return 0;
	}
@


1.42
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.40 2012/10/13 09:44:25 gilles Exp $	*/
a92 1
	char		*execname;
d94 1
a103 1
	execname = argv[0];
d155 1
a155 1
		execlp(execname, execname, "-d", argv[0], "-o", dbname, "-",
d182 1
d185 1
@


1.41
log
@knf

ok gilles@@
@
text
@d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d61 2
a62 1
struct smtpd	*env = NULL;
a84 6
ssl_load_certfile(const char *name, uint8_t flags)
{
	return (0);
}

int
a92 1
	struct smtpd	 smtpd;
a95 2
	env = &smtpd;

d404 1
a404 1
		if (! alias_parse(&xn, subrcpt))
d421 1
a421 1
	struct map	*map;
d428 2
a429 2
	map = map_findbyname("aliases");
	if (map == NULL)
d432 1
a432 1
	path = xstrdup(map->m_config, "conf_aliases");
@


1.40
log
@when makemap is executed in sendmail mode, check if ".db" is part of the
filename and imply it otherwise so that the following works:

	makemap hash /etc/mail/aliases < aliases
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.39 2012/10/08 19:45:11 gilles Exp $	*/
d154 2
a155 1
			if (! bsnprintf(dbname, sizeof dbname, "%s.db", argv[1]))
d159 2
a160 1
			if (strlcpy(dbname, argv[1], sizeof dbname) >= sizeof dbname)
d164 2
a165 1
		execlp(execname, execname, "-d", argv[0], "-o", dbname, "-", NULL);
d203 2
a204 1
			warn("couldn't carry ownership and perms to %s", dbname);
d371 1
a371 1
	}	
d391 3
a393 3
	char	       	*subrcpt;
	char	       	*endp;
	char		*origtext;
d455 2
a456 2
		fprintf(stderr, "usage: %s [-d dbtype] [-o dbfile] [-t type] file\n",
		    __progname);
@


1.39
log
@when building a db map, always lowercase the key before a lookup in makemap

smtpd already does it, but this allows spotting a cycle at makemap time, so
user isn't surprised at runtime.

while at it, be more tolerant when user specifies /etc/mail/aliases instead
of /etc/mail/aliases.db
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.38 2012/10/07 16:57:14 gilles Exp $	*/
d100 1
d151 12
a162 1
		execlp(execname, execname, "-d", argv[0], "-o", argv[1], "-", NULL);
@


1.38
log
@We need to provide a sendmail-like interface to makemap so that some tools
that assume sendmail do not break ... add support for reading map source
from stdin, for specifying the DBTYPE of a map, and teach OUR makemap to
emulate sendmail interface.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.37 2012/09/27 20:34:15 chl Exp $	*/
d295 2
a306 1
		xlowercase(key.data, key.data, strlen(key.data) + 1);
d346 1
d426 3
a428 2
	if (p == NULL || p[3] != '\0')
		errx(1, "%s: %s: no .db suffix present", cfgpath, path);
a429 1

@


1.37
log
@use xstrdup() helper

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.36 2012/09/19 12:59:59 eric Exp $	*/
d97 1
d99 1
d108 1
a108 1
	opts = "ho:t:";
d111 1
d115 10
d146 8
d170 3
a172 2
	if (stat(source, &sb) == -1)
		err(1, "stat: %s", source);
d179 1
a179 1
	db = dbopen(dbname, O_EXLOCK|O_RDWR|O_SYNC, 0644, DB_HASH, NULL);
d185 6
a190 5
	if (fchmod(db->fd(db), sb.st_mode) == -1 ||
	    fchown(db->fd(db), sb.st_uid, sb.st_gid) == -1) {
		warn("couldn't carry ownership and perms to %s", dbname);
		goto bad;
	}
d225 4
a228 1
	fp = fopen(filename, "r");
d234 1
a234 1
	if (flock(fileno(fp), LOCK_SH|LOCK_NB) == -1) {
d437 1
a437 1
		fprintf(stderr, "usage: %s [-o dbfile] [-t type] file\n",
@


1.36
log
@expandnodes must be bzero()'d before parsing to be sure there is no bogus
data left on return, since the RB compare functions uses memcmp().  While
there, remove all calls to bzero() before alias_parse().

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.35 2012/09/19 12:45:04 eric Exp $	*/
d337 1
a337 4
	val->data = strdup(text);
	if (val->data == NULL)
		err(1, "malloc");

d354 1
a354 3
	origtext = strdup(text);
	if (origtext == NULL)
		fatal("strdup");
d396 1
a396 3
	path = strdup(map->m_config);
	if (path == NULL)
		err(1, NULL);
@


1.35
log
@rename variables for consistency

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.34 2012/08/19 14:16:58 chl Exp $	*/
a372 1
		bzero(&xn, sizeof(struct expandnode));
@


1.34
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.33 2012/07/29 17:21:43 gilles Exp $	*/
d349 1
a349 1
	struct expandnode	expnode;
d373 2
a374 2
		bzero(&expnode, sizeof(struct expandnode));
		if (! alias_parse(&expnode, subrcpt))
@


1.33
log
@- introduce xlowercase() and allow lowercase() to fail gracefully
- replace all calls to lowercase() with calls to xlowercase()
- in the format string expansion, lowercase() all formats

we will have to reassess all calls to xlowercase() even though it has never
triggered as far as I know, we can probably gracefully fail some of them.
right now we're just keeping former behaviour.

this commit fixes issue reported by Hugo Osvaldo Barrera where a %u format
could lead to a delivery failure (ie: GILLES@@openbsd.org should be expanded
to gilles, not GILLES ... only for local deliveries).

ok chl@@ on the idea, ok eric@@ on the diff
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.32 2011/05/16 21:27:38 jasper Exp $	*/
d78 1
a78 1
purge_config(u_int8_t what)
d84 1
a84 1
ssl_load_certfile(const char *name, u_int8_t flags)
@


1.32
log
@plug leak in make_aliases()

with/ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.31 2011/05/09 09:36:55 eric Exp $	*/
d279 1
a279 1
		lowercase(key.data, key.data, strlen(key.data) + 1);
@


1.31
log
@fix segfault in newaliases after global env move.

spotted by Christopher Zimmermann
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.30 2011/05/01 12:57:11 eric Exp $	*/
d383 1
a383 1
	free(val->data);
@


1.30
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.29 2011/04/17 13:36:07 gilles Exp $	*/
a390 1
	struct smtpd	 smtpd;
d395 1
a395 1
	if (parse_config(&smtpd, cfgpath, 0))
@


1.29
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.28 2010/11/28 14:35:58 gilles Exp $	*/
d61 2
d78 1
a78 1
purge_config(struct smtpd *env, u_int8_t what)
d84 1
a84 1
ssl_load_certfile(struct smtpd *env, const char *name, u_int8_t flags)
d97 3
d391 1
a391 1
	struct smtpd	 env;
d396 1
a396 1
	if (parse_config(&env, cfgpath, 0))
d399 1
a399 1
	map = map_findbyname(&env, "aliases");
@


1.28
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.27 2010/11/28 13:56:43 gilles Exp $	*/
d48 7
a54 8
int		parse_map(char *);
int		parse_entry(char *, size_t, size_t);
int		parse_mapentry(char *, size_t, size_t);
int		parse_setentry(char *, size_t, size_t);
int		make_plain(DBT *, char *);
int		make_aliases(DBT *, char *);

char		*conf_aliases(char *);
@


1.27
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.26 2010/04/27 09:49:23 gilles Exp $	*/
d27 1
a28 1
#include <db.h>
d37 1
a38 1
#include <util.h>
@


1.26
log
@initial work at fixing aliases support:
- kill struct alias, struct expandnode is used instead
- introduce map_parse_alias() and map_parse_virtual()
- aliases and virtual code no longer assume db(3) but use the map API which
  lets them become backend agnostic AND value-checked. this actually makes
  the code simpler by removing all values parsing from aliases.c
- rename K_SECRETS -> K_SECRET, K_ALIASES -> K_ALIAS for consistency the
  enum has singular names.
- aliases, virtual and forward now work with an expandtree and deal with
  multiple levels of resolving by merging expandtree's

more coming soon ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.25 2010/04/21 21:40:56 gilles Exp $	*/
d33 1
d41 1
@


1.25
log
@when creating a map, make sure we do not store a key/val separator at the
beginning of the key (ie: "gilles: bleh" should not be stored as
key[gilles] val[ bleh])
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.24 2009/11/08 23:08:56 gilles Exp $	*/
a241 2
	DBT	 domkey;
	DBT	 domval;
a243 1
	char	*domp;
a282 15
	/* add key for domain */
	if ((domp = strrchr(key.data, '@@')) != NULL) {
		domkey.data = domp + 1;
		domkey.size = strlen(domkey.data) + 1;

		domval.data  = "<empty>";
		domval.size = strlen(domval.data) + 1;

		if (db->put(db, &domkey, &domval, 0) == -1) {
			warn("dbput");
			return 0;
		}
	}
	

d343 1
a343 1
	struct alias	a;
d346 1
d351 4
d367 2
a368 1
		if (! alias_parse(&a, subrcpt))
a369 6

		val->data = realloc(val->data, val->size + sizeof(a));
		if (val->data == NULL)
			err(1, "get_targets: realloc");
		memcpy((u_int8_t *)val->data + val->size, &a, sizeof(a));
		val->size += sizeof(a);
d372 2
@


1.24
log
@rework a bit expansion and data structures involved in the expansion so we
no longer have a direct mapping between structures saved in aliases/virtual
db and structures used at runtime during expansion.

side effects ? struct alias is smaller, databases are smaller and it is no
longer necessary to rebuild aliases/virtual databases each time jacekm@@ or
I make changes to some obscure structure used indirectely during expansion

rebuild databases, flush queues, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.23 2009/11/03 22:57:41 gilles Exp $	*/
d257 4
@


1.23
log
@teach makemap how to build a set, which is a map containing only keys.
smtpd is now capable of looking primary domains at runtime in a set, which
means that the following becomes possible:

	map "primary" { source db "/etc/mail/primary.db" }
	accept for domain map "primary" deliver to mbox

while at it fix a couple bugs in the aliases resolution path which caused
recipients to bounce if a ruleset did not have an "accept for local" rule

"diff reads good" jacekm@@, flush queue & make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.22 2009/10/17 12:46:47 sobrado Exp $	*/
d357 3
a359 3
	struct alias	 a;
	char		*subrcpt;
	char		*endp;
@


1.22
log
@sort flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.21 2009/10/12 18:19:46 gilles Exp $	*/
d48 2
d67 2
a68 1
	T_ALIASES
d115 2
d227 13
d267 1
a267 2
	switch (type) {
	case T_PLAIN:
d270 2
a271 2
		break;
	case T_ALIASES:
a274 1
		break;
d306 34
@


1.21
log
@to support virtual domains properly, smtpd needed to have the domain stored
as a key in the virtual map, which means that to support virtual domain for
openbsd.org I would do:

openbsd.org		whatevervalue
gilles@@openbsd.org	gilles

this commit teaches makemap how to deduce the special domain keys based on
the entries for that domain, so that only the second line is needed now.
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.20 2009/08/08 00:02:22 gilles Exp $	*/
d376 1
a376 1
		fprintf(stderr, "usage: %s [-t type] [-o dbfile] file\n",
@


1.20
log
@import some changes from portable smtpd to reduce the delta between both.
this commit contains mostly missing casts and cosmethic changes, do not
expect to build this anywhere but on OpenBSD, it does not contain any of
the portable glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.19 2009/07/28 20:51:50 gilles Exp $	*/
d224 2
d228 1
d265 16
@


1.19
log
@slightly change how makemap parses its lines so that we consider #
as a comment only when it starts a line or is preceded by whitespaces.

fixes a bug that was reported to me twice and which i ran into,
ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.18 2009/05/30 23:53:41 gilles Exp $	*/
d228 1
a228 1
	while (isspace(*keyp))
d297 1
a297 1
		while (isspace(*subrcpt))
d304 1
a304 1
		while (subrcpt < endp && isspace(*endp))
@


1.18
log
@It is now possible to specify a certificate to use when relaying to another
host which requests client certificates:

	accept [...] relay via [...] ssl certificate "mycert"

diff from Josh Elsasser <josh@@elsasser.org>, tested and okayed by me with
no change but the addition of status 554 to the state machine to deal with
remote host telling us it doesn't like our certificate.
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.17 2009/05/10 11:29:40 jacekm Exp $	*/
d189 1
a189 1
	char	 delim[] = { '\\', '\\', '#' };
d230 1
a230 1
	if (*keyp == '\0')
@


1.17
log
@assert copyright; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.16 2009/04/24 10:02:35 jacekm Exp $	*/
d78 1
a78 1
ssl_load_certfile(struct smtpd *env, const char *name)
@


1.16
log
@Make aliases case-insensitive, issue reported by Daniel Ouelett; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.15 2009/03/19 22:03:33 jacekm Exp $	*/
d5 1
@


1.15
log
@since maps may contain secrets, carry ownership and perms from source file
to db file; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.14 2009/03/09 16:31:09 jacekm Exp $	*/
d251 1
@


1.14
log
@Drop ALIAS_TEXT, plain maps got implemented in a different way; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.13 2009/03/06 23:32:34 gilles Exp $	*/
d85 5
a89 4
	char	 dbname[MAXPATHLEN];
	char	*opts;
	char	*conf;
	int	 ch;
d137 3
d151 6
a161 5
		goto bad;
	}

	if (chmod(dbname, 0644) == -1) {
		warn("chmod: %s", dbname);
@


1.13
log
@make_plain() deals with a c-string, val->size should contain the nul-byte
or we will truncate the last character of every value we store in a map.
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.12 2009/03/06 23:29:06 gilles Exp $	*/
d269 3
a271 1
	struct alias	*a;
d273 1
a273 17
	a = calloc(1, sizeof(struct alias));
	if (a == NULL)
		err(1, "calloc");

	a->type = ALIAS_TEXT;
	val->data = a->u.text;
	val->size = strlcpy(a->u.text, text, sizeof(a->u.text));

	if (val->size >= sizeof(a->u.text)) {
		free(a);
		return 0;
	}

	/* unlike make_aliases, we deal with a C string, so
	 * val->size should include the nul-byte.
	 */
	val->size++;
@


1.12
log
@fix a bug in the generation of plain maps which would cause the value not
to be correctly inserted into the map.
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.11 2009/02/22 11:44:29 form Exp $	*/
d283 5
@


1.11
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.10 2009/02/17 23:50:58 jacekm Exp $	*/
d276 1
a276 1
	val->data = a;
@


1.10
log
@- flock input file while the database is being built
- make newaliases finish with short summary

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.9 2009/02/17 23:43:57 jacekm Exp $	*/
d136 1
a136 1
	if (! bsnprintf(dbname, MAXPATHLEN, "%s.XXXXXXXXXXX", oflag))
@


1.9
log
@make newaliases read aliases path from smtpd.conf; idea discussed with
gilles@@, pyr@@ and henning@@, diff ok gilles@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.8 2009/02/14 18:37:12 jacekm Exp $	*/
d165 3
a167 1
	if (dbputs == 0)
d188 9
@


1.8
log
@Implement makemap -t and -o, for output type and dest resp.; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.7 2009/01/01 16:15:47 jacekm Exp $	*/
d40 2
d50 2
d67 15
d87 1
d90 2
d93 1
d97 1
a97 1
		opts = "h";
d101 3
d126 1
a126 1
		source = PATH_ALIASES;
d316 26
d346 1
a346 1
		fprintf(stderr, "usage: %s\n", __progname);
@


1.7
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.6 2008/12/21 12:59:05 jacekm Exp $	*/
d45 2
d48 4
a51 3
DB *db;
char *source;
int dbputs;
d58 5
d66 3
a68 2
	char dbname[MAXPATHLEN];
	char dest[MAXPATHLEN];
d71 22
d94 4
a97 3
	switch (mode) {
	case P_MAKEMAP:
		if (argc != 2)
d99 3
a101 3
		source = argv[1];
		break;
	case P_NEWALIASES:
d104 1
a104 6
		if (geteuid())
			errx(1, "need root privileges");
		source = PATH_ALIASES;
		break;
	default:
		abort();
d107 4
a110 1
	if (! bsnprintf(dbname, MAXPATHLEN, "%s.db.XXXXXXXXXXX", source))
d134 1
a134 6
	if (! bsnprintf(dest, MAXPATHLEN, "%s.db", source)) {
		warnx("path too long");
		goto bad;
	}

	if (rename(dbname, dest) == -1) {
d140 1
a140 1
		warnx("warning: empty map created: %s", dest);
d151 5
a155 5
	FILE *fp;
	char *line;
	size_t len;
	size_t lineno = 0;
	char delim[] = { '\\', '\\', '#' };
a163 2
		if (len == 0)
			continue;
d179 9
a187 11
	char *name;
	char *rcpt;
	char *endp;
	char *subrcpt;
	DBT key;
	DBT val;

	/* Blank lines are OK. */
	while (isspace(*line))
		line++;
	if (*line == '\0')
d190 17
a206 6
	name = line;
	switch (mode) {
	case P_MAKEMAP:
		rcpt = strchr(line, ' ');
		if (rcpt == NULL)
			rcpt = strchr(line, '\t');
d208 3
a210 2
	case P_NEWALIASES:
		rcpt = strchr(line, ':');
a211 2
	default:
		abort();
a212 3
	if (rcpt == NULL)
		goto bad;
	*rcpt++ = '\0';
d214 19
a232 5
	/* name: strip initial whitespace. */
	while (isspace(*name))
		++name;
	if (*name == '\0')
		goto bad;
d234 7
a240 4
	/* name: strip trailing whitespace. */
	endp = name + strlen(name) - 1;
	while (name < endp && isspace(*endp))
		*endp-- = '\0';
d242 2
a243 5
	/* Check for dups. */
	key.data = name;
	key.size = strlen(name) + 1;
	if (db->get(db, &key, &val, 0) == 0) {
		warnx("%s:%zd: duplicate entry for %s", source, lineno, name);
d247 12
a258 4
	/* At this point name and rcpt are non-zero nul-terminated strings. */
	while ((subrcpt = strsep(&rcpt, ",")) != NULL) {
		struct alias	 alias;
		void		*p;
d260 1
d265 1
a265 1
			goto bad;
d272 2
a273 11
		if (! alias_parse(&alias, subrcpt))
			goto bad;

		key.data = name;
		key.size = strlen(name) + 1;
		val.data = NULL;
		val.size = 0;
		if (db->get(db, &key, &val, 0) == -1) {
			warn("dbget");
			return 0;
		}
d275 6
a280 15
		p = calloc(1, val.size + sizeof(struct alias));
		if (p == NULL) {
			warn("calloc");
			return 0;
		}
		memcpy(p, val.data, val.size);
		memcpy((u_int8_t *)p + val.size, &alias, sizeof(struct alias));

		val.data = p;
		val.size += sizeof(struct alias);
		if (db->put(db, &key, &val, 0) == -1) {
			warn("dbput");
			free(p);
			return 0;
		}
d282 1
a282 3
		dbputs++;
		free(p);
	}
d284 2
a285 1
	return 1;
a286 3
bad:
	/* The actual line is not printed; it may be mangled by above code. */
	warnx("%s:%zd: invalid entry", source, lineno);
d293 1
a293 5
	switch (mode) {
	case P_MAKEMAP:
		fprintf(stderr, "usage: %s file\n", __progname);
		break;
	case P_NEWALIASES:
d295 3
a297 4
		break;
	default:
		abort();
	}
@


1.6
log
@Add more compile time checking; fix one warning reported by gcc.
From: Nicholas Marriott <nicholas.marriott@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.5 2008/12/18 15:19:33 jacekm Exp $	*/
a23 1

a31 1
#include <limits.h>
@


1.5
log
@Don't err() on blank lines.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.4 2008/12/17 23:09:23 jacekm Exp $	*/
d203 1
a203 2
		warnx("%s:%zd: duplicate entry for %s", source, lineno,
		    key.data);
@


1.4
log
@Warn if empty map is being created; this catches at least usage
error such as "makemap foo.db".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makemap.c,v 1.3 2008/12/17 22:59:36 jacekm Exp $	*/
d164 6
@


1.3
log
@Merge newaliases into makemap.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
d116 3
d246 1
@


1.2
log
@Declare alias_parse in smtpd.h, and fix callers that pass it wrong
number of arguments.

ok gilles@@
@
text
@d1 2
a36 1
#include <sysexits.h>
d44 3
a46 3
static int usage(void);
int parse_map(const char *);
int parse_entry(char *, size_t, size_t);
d49 6
a58 2
	int ch;
	char pathname[MAXPATHLEN];
d60 3
a62 1
	char output[MAXPATHLEN];
d64 15
a78 5
	while ((ch = getopt(argc, argv, "")) != -1) {
		switch (ch) {
		default:
			return usage();
		}
a79 2
	argc -= optind;
	argv += optind;
d81 4
a84 2
	if (argc != 1)
		return usage();
d86 1
a86 9
	bzero(pathname, MAXPATHLEN);
	snprintf(pathname, MAXPATHLEN, "%s.XXXXX", argv[0]);
	if (mkdtemp(pathname) == NULL)
		errx(1, "failed to create temporary directory");

	bzero(dbname, MAXPATHLEN);
	snprintf(dbname, MAXPATHLEN, "%s/map", pathname);
	db = dbopen(dbname, O_CREAT|O_EXLOCK|O_RDWR|O_SYNC, 0644, DB_HASH,
		NULL);
d88 1
a88 1
		warn("dbopen");
d92 5
a96 2
	if (! parse_map(argv[0])) {
		warnx("syntax error in aliases file");
d100 4
a103 1
	db->close(db);
d105 4
a108 1
	snprintf(output, MAXPATHLEN, "%s.db", argv[0]);
d110 1
a110 1
	if (rename(dbname, output) == -1) {
d115 1
a115 7
	if (chmod(output, 0644) == -1)
		err(1, "chmod");

	if (rmdir(pathname) == -1)
		err(1, "rmdir");

	return EX_OK;
d117 1
a117 5
	if (dbname[0] != '\0')
		if (unlink(dbname) == -1)
			err(1, "unlink: %s", dbname);
	if (rmdir(pathname) == -1)
		err(1, "rmdir: %s", pathname);
a120 7
static int
usage(void)
{
	fprintf(stderr, "usage: %s filename\n", __progname);
	return EX_USAGE;
}

d122 1
a122 1
parse_map(const char *filename)
d131 4
a134 3
	if (fp == NULL)
		errx(1, "failed to open aliases file");

d139 5
a143 1
		parse_entry(line, len, lineno);
a154 1
	char *delim;
d156 1
a157 2
	struct alias alias;
	int ret;
d162 18
a179 1
	while (*name && isspace(*name))
d181 1
a181 5

	rcpt = delim = strchr(name, ' ');
	if (rcpt == NULL)
		rcpt = delim = strchr(name, '\t');
	if (rcpt == NULL || name == rcpt)
d184 13
d198 4
a201 8
	*delim-- = 0;
	while (isspace(*delim))
		*delim-- = '\0';
	rcpt++;
	while (*rcpt && isspace(*rcpt))
		++rcpt;
	if (*rcpt == '\0')
		goto bad;
d203 2
a204 3
	/* At this point, name points to nul-terminate name */
	for (; (subrcpt = strsep(&rcpt, ",")) != NULL;) {
		while (*subrcpt && isspace(*subrcpt))
d207 6
a212 1
			continue;
d214 2
a215 4
		delim = subrcpt + strlen(subrcpt);
		delim--;
		while (isspace(*delim))
			*delim-- = '\0';
d219 5
a223 7

		if ((ret = db->get(db, &key, &val, 0)) == -1)
			errx(1, "db->get()");

		if (ret == 1) {
			val.data = NULL;
			val.size = 0;
d226 4
a229 9
		if (! alias_parse(&alias, subrcpt))
			goto bad;

		if (val.size == 0) {
			val.size = sizeof(struct alias);
			val.data = &alias;

			if ((ret = db->put(db, &key, &val, 0)) == -1)
				errx(1, "db->get()");
d231 2
a232 14
		else {
			void *p;

			p = calloc(val.size + sizeof(alias), 1);
			if (p == NULL)
				errx(1, "calloc: memory exhausted");
			memcpy(p, val.data, val.size);
			memcpy((u_int8_t *)p + val.size, &alias, sizeof(alias));

			val.data = p;
			val.size += sizeof(alias);

			if ((ret = db->put(db, &key, &val, 0)) == -1)
				errx(1, "db->get()");
d234 4
d239 1
d241 2
a242 1
		db->sync(db, 0);
d248 2
a249 1
	warnx("line %zd: invalid entry: %s", lineno, line);
d251 16
@


1.1
log
@- smtpd's db maps are incompatible with sendmail's and needs a distinct
	makemap utility, this is needed for virtual users support amongst
	other things. links to smtpd's aliases.c and only provides a
	frontent to parse map descriptions. contains code from pyr@@, chl@@
	and I. Should have also been imported with smtpd.
@
text
@a46 2
int alias_parse(struct alias *, char *, size_t);

d200 1
a200 1
		if (! alias_parse(&alias, subrcpt, strlen(subrcpt)))
@

