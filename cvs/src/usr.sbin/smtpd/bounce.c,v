head	1.77;
access;
symbols
	OPENBSD_6_2:1.77.0.2
	OPENBSD_6_2_BASE:1.77
	OPENBSD_6_1:1.77.0.4
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.72.0.6
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.66.0.6
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.66.0.2
	OPENBSD_5_7_BASE:1.66
	OPENBSD_5_6:1.65.0.4
	OPENBSD_5_6_BASE:1.65
	OPENBSD_5_5:1.62.0.2
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.54.0.2
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.42.0.2
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.2
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17;
locks; strict;
comment	@ * @;


1.77
date	2016.11.30.11.52.48;	author eric;	state Exp;
branches;
next	1.76;
commitid	HLHuvF4EZizEJJ0M;

1.76
date	2016.11.22.07.28.42;	author eric;	state Exp;
branches;
next	1.75;
commitid	8fz9wejpFY08v5WO;

1.75
date	2016.11.21.13.00.43;	author eric;	state Exp;
branches;
next	1.74;
commitid	pP1uMFU0IrsBTn27;

1.74
date	2016.11.20.08.43.36;	author eric;	state Exp;
branches;
next	1.73;
commitid	WsInk7NbLdaIQWny;

1.73
date	2016.11.16.21.30.37;	author eric;	state Exp;
branches;
next	1.72;
commitid	3uoi1oHbQkJMXEjt;

1.72
date	2016.02.03.05.57.09;	author sunil;	state Exp;
branches;
next	1.71;
commitid	1TpFogZwF5CYAIAp;

1.71
date	2015.12.24.16.54.37;	author mmcc;	state Exp;
branches;
next	1.70;
commitid	52DQs4TJie3OmFZq;

1.70
date	2015.12.14.10.31.25;	author sunil;	state Exp;
branches;
next	1.69;
commitid	R62TldLZEvOj4oOd;

1.69
date	2015.12.14.10.22.11;	author jung;	state Exp;
branches;
next	1.68;
commitid	HRAnniyhGW9Sadln;

1.68
date	2015.11.23.06.54.21;	author sunil;	state Exp;
branches;
next	1.67;
commitid	YyzP3p5zJCsjsouQ;

1.67
date	2015.10.07.19.25.42;	author millert;	state Exp;
branches;
next	1.66;
commitid	iJj82XHLhrINosjR;

1.66
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	ZBTFreARDSMmzOIV;

1.65
date	2014.05.28.10.34.16;	author daniel;	state Exp;
branches;
next	1.64;

1.64
date	2014.04.19.17.27.40;	author gilles;	state Exp;
branches;
next	1.63;

1.63
date	2014.04.04.16.10.41;	author eric;	state Exp;
branches;
next	1.62;

1.62
date	2014.02.04.15.44.05;	author eric;	state Exp;
branches;
next	1.61;

1.61
date	2014.02.04.14.56.03;	author eric;	state Exp;
branches;
next	1.60;

1.60
date	2013.12.03.08.32.40;	author eric;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.58;

1.58
date	2013.10.26.12.27.58;	author eric;	state Exp;
branches;
next	1.57;

1.57
date	2013.07.19.15.14.23;	author eric;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.55;

1.55
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.54;

1.54
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.52;

1.52
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.51;

1.51
date	2012.10.07.15.46.38;	author chl;	state Exp;
branches;
next	1.50;

1.50
date	2012.10.03.16.43.19;	author chl;	state Exp;
branches;
next	1.49;

1.49
date	2012.10.02.12.37.38;	author chl;	state Exp;
branches;
next	1.48;

1.48
date	2012.09.26.21.06.45;	author chl;	state Exp;
branches;
next	1.47;

1.47
date	2012.08.18.15.39.26;	author eric;	state Exp;
branches;
next	1.46;

1.46
date	2012.08.09.16.00.31;	author eric;	state Exp;
branches;
next	1.45;

1.45
date	2012.08.09.11.52.32;	author eric;	state Exp;
branches;
next	1.44;

1.44
date	2012.08.09.09.48.02;	author eric;	state Exp;
branches;
next	1.43;

1.43
date	2012.08.08.08.50.42;	author eric;	state Exp;
branches;
next	1.42;

1.42
date	2012.07.09.09.57.53;	author gilles;	state Exp;
branches;
next	1.41;

1.41
date	2012.06.20.20.45.23;	author eric;	state Exp;
branches;
next	1.40;

1.40
date	2012.01.29.11.37.32;	author eric;	state Exp;
branches;
next	1.39;

1.39
date	2012.01.12.22.59.55;	author eric;	state Exp;
branches;
next	1.38;

1.38
date	2012.01.11.17.28.36;	author eric;	state Exp;
branches;
next	1.37;

1.37
date	2011.12.27.14.38.56;	author eric;	state Exp;
branches;
next	1.36;

1.36
date	2011.12.14.23.08.40;	author eric;	state Exp;
branches;
next	1.35;

1.35
date	2011.10.27.14.32.57;	author chl;	state Exp;
branches;
next	1.34;

1.34
date	2011.10.23.09.30.06;	author gilles;	state Exp;
branches;
next	1.33;

1.33
date	2011.09.01.19.56.49;	author eric;	state Exp;
branches;
next	1.32;

1.32
date	2011.05.16.21.05.51;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.17.11.39.22;	author gilles;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.14.21.53.45;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.14.20.11.08;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2011.03.26.10.59.59;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2011.03.21.13.06.25;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2010.10.09.22.11.08;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.01.23.06.23;	author jacekm;	state dead;
branches;
next	1.21;

1.21
date	2010.06.01.19.47.08;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.31.23.38.56;	author jacekm;	state dead;
branches;
next	1.19;

1.19
date	2010.05.19.20.57.10;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.22.12.56.33;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.23.17.16.03;	author jacekm;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.14.23.17.04;	author jacekm;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.14.18.21.53;	author jacekm;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.12.14.03.59;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.12.10.33.11;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.11.10.04.05;	author chl;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.05.12.08.41;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.05.12.05.47;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.16.15.33.06;	author jacekm;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.15.16.50.06;	author jacekm;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.04.18.50.43;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.27.11.37.30;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.06.16.26.39;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.06.14.27.41;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.06.14.16.37;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.06.14.12.48;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.06.13.40.45;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.77
log
@make struct io opaque:

- move struct io definition to ioev.c
- replace io_init/io_clear with io_new/io_free
- allocate an iobuf for each new io internally
- use struct io pointer in the rest of the code
- remove remaining uses of iobuf_*

ok gilles@@ sunil@@
@
text
@/*	$OpenBSD: bounce.c,v 1.76 2016/11/22 07:28:42 eric Exp $	*/

/*
 * Copyright (c) 2009 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>

#include <err.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <inttypes.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

#include "smtpd.h"
#include "log.h"

#define BOUNCE_MAXRUN	2
#define BOUNCE_HIWAT	65535

enum {
	BOUNCE_EHLO,
	BOUNCE_MAIL,
	BOUNCE_RCPT,
	BOUNCE_DATA,
	BOUNCE_DATA_NOTICE,
	BOUNCE_DATA_MESSAGE,
	BOUNCE_DATA_END,
	BOUNCE_QUIT,
	BOUNCE_CLOSE,
};

struct bounce_envelope {
	TAILQ_ENTRY(bounce_envelope)	 entry;
	uint64_t			 id;
	struct mailaddr			 dest;
	char				*report;
	uint8_t				 esc_class;
	uint8_t				 esc_code;
};

struct bounce_message {
	SPLAY_ENTRY(bounce_message)	 sp_entry;
	TAILQ_ENTRY(bounce_message)	 entry;
	uint32_t			 msgid;
	struct delivery_bounce		 bounce;
	char				*smtpname;
	char				*to;
	time_t				 timeout;
	TAILQ_HEAD(, bounce_envelope)	 envelopes;
};

struct bounce_session {
	char				*smtpname;
	struct bounce_message		*msg;
	FILE				*msgfp;
	int				 state;
	struct io			*io;
	uint64_t			 boundary;
};

SPLAY_HEAD(bounce_message_tree, bounce_message);
static int bounce_message_cmp(const struct bounce_message *,
    const struct bounce_message *);
SPLAY_PROTOTYPE(bounce_message_tree, bounce_message, sp_entry,
    bounce_message_cmp);

static void bounce_drain(void);
static void bounce_send(struct bounce_session *, const char *, ...);
static int  bounce_next_message(struct bounce_session *);
static int  bounce_next(struct bounce_session *);
static void bounce_delivery(struct bounce_message *, int, const char *);
static void bounce_status(struct bounce_session *, const char *, ...);
static void bounce_io(struct io *, int, void *);
static void bounce_timeout(int, short, void *);
static void bounce_free(struct bounce_session *);
static const char *action_str(const struct delivery_bounce *);

static struct tree			wait_fd;
static struct bounce_message_tree	messages;
static TAILQ_HEAD(, bounce_message)	pending;

static int				nmessage = 0;
static int				running = 0;
static struct event			ev_timer;

static void
bounce_init(void)
{
	static int	init = 0;

	if (init == 0) {
		TAILQ_INIT(&pending);
		SPLAY_INIT(&messages);
		tree_init(&wait_fd);
		evtimer_set(&ev_timer, bounce_timeout, NULL);
		init = 1;
	}
}

void
bounce_add(uint64_t evpid)
{
	char			 buf[LINE_MAX], *line;
	struct envelope		 evp;
	struct bounce_message	 key, *msg;
	struct bounce_envelope	*be;

	bounce_init();

	if (queue_envelope_load(evpid, &evp) == 0) {
		m_create(p_scheduler, IMSG_QUEUE_DELIVERY_PERMFAIL, 0, 0, -1);
		m_add_evpid(p_scheduler, evpid);
		m_close(p_scheduler);
		return;
	}

	if (evp.type != D_BOUNCE)
		errx(1, "bounce: evp:%016" PRIx64 " is not of type D_BOUNCE!",
		    evp.id);

	key.msgid = evpid_to_msgid(evpid);
	key.bounce = evp.agent.bounce;
	key.smtpname = evp.smtpname;

	switch (evp.esc_class) {
	case ESC_STATUS_OK:
		key.bounce.type = B_DSN;
		break;
	case ESC_STATUS_TEMPFAIL:
		key.bounce.type = B_WARNING;
		break;
	default:
		key.bounce.type = B_ERROR;
	}

	key.bounce.dsn_ret = evp.dsn_ret;
	key.bounce.expire = evp.expire;
	msg = SPLAY_FIND(bounce_message_tree, &messages, &key);
	if (msg == NULL) {
		msg = xcalloc(1, sizeof(*msg), "bounce_add");
		msg->msgid = key.msgid;
		msg->bounce = key.bounce;

		TAILQ_INIT(&msg->envelopes);

		msg->smtpname = xstrdup(evp.smtpname, "bounce_add");
		(void)snprintf(buf, sizeof(buf), "%s@@%s", evp.sender.user,
		    evp.sender.domain);
		msg->to = xstrdup(buf, "bounce_add");
		nmessage += 1;
		SPLAY_INSERT(bounce_message_tree, &messages, msg);
		log_debug("debug: bounce: new message %08" PRIx32,
		    msg->msgid);
		stat_increment("bounce.message", 1);
	} else
		TAILQ_REMOVE(&pending, msg, entry);

	line = evp.errorline;
	if (strlen(line) > 4 && (*line == '1' || *line == '6'))
		line += 4;
	(void)snprintf(buf, sizeof(buf), "%s@@%s: %s\n", evp.dest.user,
	    evp.dest.domain, line);

	be = xmalloc(sizeof *be, "bounce_add");
	be->id = evpid;
	be->report = xstrdup(buf, "bounce_add");
	(void)strlcpy(be->dest.user, evp.dest.user, sizeof(be->dest.user));
	(void)strlcpy(be->dest.domain, evp.dest.domain,
	    sizeof(be->dest.domain));
	be->esc_class = evp.esc_class;
	be->esc_code = evp.esc_code;
	TAILQ_INSERT_TAIL(&msg->envelopes, be, entry);
	buf[strcspn(buf, "\n")] = '\0';
	log_debug("debug: bounce: adding report %16"PRIx64": %s", be->id, buf);

	msg->timeout = time(NULL) + 1;
	TAILQ_INSERT_TAIL(&pending, msg, entry);

	stat_increment("bounce.envelope", 1);
	bounce_drain();
}

void
bounce_fd(int fd)
{
	struct bounce_session	*s;
	struct bounce_message	*msg;

	log_debug("debug: bounce: got enqueue socket %d", fd);

	if (fd == -1 || TAILQ_EMPTY(&pending)) {
		log_debug("debug: bounce: cancelling");
		if (fd != -1)
			close(fd);
		running -= 1;
		bounce_drain();
		return;
	}

	msg = TAILQ_FIRST(&pending);

	s = xcalloc(1, sizeof(*s), "bounce_fd");
	s->smtpname = xstrdup(msg->smtpname, "bounce_fd");
	s->state = BOUNCE_EHLO;
	s->io = io_new();
	io_set_callback(s->io, bounce_io, s);
	io_set_fd(s->io, fd);
	io_set_timeout(s->io, 30000);
	io_set_read(s->io);
	s->boundary = generate_uid();

	log_debug("debug: bounce: new session %p", s);
	stat_increment("bounce.session", 1);
}

static void
bounce_timeout(int fd, short ev, void *arg)
{
	log_debug("debug: bounce: timeout");

	bounce_drain();
}

static void
bounce_drain()
{
	struct bounce_message	*msg;
	struct timeval		 tv;
	time_t			 t;

	log_debug("debug: bounce: drain: nmessage=%d running=%d",
	    nmessage, running);

	while (1) {
		if (running >= BOUNCE_MAXRUN) {
			log_debug("debug: bounce: max session reached");
			return;
		}

		if (nmessage == 0) {
			log_debug("debug: bounce: no more messages");
			return;
		}

		if (running >= nmessage) {
			log_debug("debug: bounce: enough sessions running");
			return;
		}

		if ((msg = TAILQ_FIRST(&pending)) == NULL) {
			log_debug("debug: bounce: no more pending messages");
			return;
		}

		t = time(NULL);
		if (msg->timeout > t) {
			log_debug("debug: bounce: next message not ready yet");
			if (!evtimer_pending(&ev_timer, NULL)) {
				log_debug("debug: bounce: setting timer");
				tv.tv_sec = msg->timeout - t;
				tv.tv_usec = 0;
				evtimer_add(&ev_timer, &tv);
			}
			return;
		}

		log_debug("debug: bounce: requesting new enqueue socket...");
		m_compose(p_pony, IMSG_QUEUE_SMTP_SESSION, 0, 0, -1, NULL, 0);

		running += 1;
	}
}

static void
bounce_send(struct bounce_session *s, const char *fmt, ...)
{
	va_list	 ap;
	char	*p;
	int	 len;

	va_start(ap, fmt);
	if ((len = vasprintf(&p, fmt, ap)) == -1)
		fatal("bounce: vasprintf");
	va_end(ap);

	log_trace(TRACE_BOUNCE, "bounce: %p: >>> %s", s, p);

	io_xprintf(s->io, "%s\n", p);

	free(p);
}

static const char *
bounce_duration(long long int d)
{
	static char buf[32];

	if (d < 60) {
		(void)snprintf(buf, sizeof buf, "%lld second%s", d,
		    (d == 1) ? "" : "s");
	} else if (d < 3600) {
		d = d / 60;
		(void)snprintf(buf, sizeof buf, "%lld minute%s", d,
		    (d == 1) ? "" : "s");
	}
	else if (d < 3600 * 24) {
		d = d / 3600;
		(void)snprintf(buf, sizeof buf, "%lld hour%s", d,
		    (d == 1) ? "" : "s");
	}
	else {
		d = d / (3600 * 24);
		(void)snprintf(buf, sizeof buf, "%lld day%s", d,
		    (d == 1) ? "" : "s");
	}
	return (buf);
}

#define NOTICE_INTRO							    \
	"    Hi!\n\n"							    \
	"    This is the MAILER-DAEMON, please DO NOT REPLY to this email.\n"

const char *notice_error =
    "    An error has occurred while attempting to deliver a message for\n"
    "    the following list of recipients:\n\n";

const char *notice_warning =
    "    A message is delayed for more than %s for the following\n"
    "    list of recipients:\n\n";

const char *notice_warning2 =
    "    Please note that this is only a temporary failure report.\n"
    "    The message is kept in the queue for up to %s.\n"
    "    You DO NOT NEED to re-send the message to these recipients.\n\n";

const char *notice_success =
    "    Your message was successfully delivered to these recipients.\n\n";

const char *notice_relay =
    "    Your message was relayed to these recipients.\n\n";

static int
bounce_next_message(struct bounce_session *s)
{
	struct bounce_message	*msg;
	char			 buf[LINE_MAX];
	int			 fd;
	time_t			 now;

    again:

	now = time(NULL);

	TAILQ_FOREACH(msg, &pending, entry) {
		if (msg->timeout > now)
			continue;
		if (strcmp(msg->smtpname, s->smtpname))
			continue;
		break;
	}
	if (msg == NULL)
		return (0);

	TAILQ_REMOVE(&pending, msg, entry);
	SPLAY_REMOVE(bounce_message_tree, &messages, msg);

	if ((fd = queue_message_fd_r(msg->msgid)) == -1) {
		bounce_delivery(msg, IMSG_QUEUE_DELIVERY_TEMPFAIL,
		    "Could not open message fd");
		goto again;
	}

	if ((s->msgfp = fdopen(fd, "r")) == NULL) {
		(void)snprintf(buf, sizeof(buf), "fdopen: %s", strerror(errno));
		log_warn("warn: bounce: fdopen");
		close(fd);
		bounce_delivery(msg, IMSG_QUEUE_DELIVERY_TEMPFAIL, buf);
		goto again;
	}

	s->msg = msg;
	return (1);
}

static int
bounce_next(struct bounce_session *s)
{
	struct bounce_envelope	*evp;
	char			*line = NULL;
	size_t			 n, sz = 0;
	ssize_t			 len;

	switch (s->state) {
	case BOUNCE_EHLO:
		bounce_send(s, "EHLO %s", s->smtpname);
		s->state = BOUNCE_MAIL;
		break;

	case BOUNCE_MAIL:
	case BOUNCE_DATA_END:
		log_debug("debug: bounce: %p: getting next message...", s);
		if (bounce_next_message(s) == 0) {
			log_debug("debug: bounce: %p: no more messages", s);
			bounce_send(s, "QUIT");
			s->state = BOUNCE_CLOSE;
			break;
		}
		log_debug("debug: bounce: %p: found message %08"PRIx32,
		    s, s->msg->msgid);
		bounce_send(s, "MAIL FROM: <>");
		s->state = BOUNCE_RCPT;
		break;

	case BOUNCE_RCPT:
		bounce_send(s, "RCPT TO: <%s>", s->msg->to);
		s->state = BOUNCE_DATA;
		break;

	case BOUNCE_DATA:
		bounce_send(s, "DATA");
		s->state = BOUNCE_DATA_NOTICE;
		break;

	case BOUNCE_DATA_NOTICE:
		/* Construct an appropriate notice. */

		io_xprintf(s->io,
		    "Subject: Delivery status notification: %s\n"
		    "From: Mailer Daemon <MAILER-DAEMON@@%s>\n"
		    "To: %s\n"
		    "Date: %s\n"
		    "MIME-Version: 1.0\n"
		    "Content-Type: multipart/mixed;"
		    "boundary=\"%16" PRIu64 "/%s\"\n"
		    "\n"
		    "This is a MIME-encapsulated message.\n"
		    "\n",
		    action_str(&s->msg->bounce),
		    s->smtpname,
		    s->msg->to,
		    time_to_text(time(NULL)),
		    s->boundary,
		    s->smtpname);

		io_xprintf(s->io,
		    "--%16" PRIu64 "/%s\n"
		    "Content-Description: Notification\n"
		    "Content-Type: text/plain; charset=us-ascii\n"
		    "\n"
		    NOTICE_INTRO
		    "\n",
		    s->boundary, s->smtpname);

		switch (s->msg->bounce.type) {
		case B_ERROR:
			io_xprint(s->io, notice_error);
			break;
		case B_WARNING:
			io_xprintf(s->io, notice_warning,
			    bounce_duration(s->msg->bounce.delay));
			break;
		case B_DSN:
			io_xprint(s->io, s->msg->bounce.mta_without_dsn ?
			    notice_relay : notice_success);
			break;
		default:
			log_warn("warn: bounce: unknown bounce_type");
		}

		TAILQ_FOREACH(evp, &s->msg->envelopes, entry) {
			io_xprint(s->io, evp->report);
		}
		io_xprint(s->io, "\n");

		if (s->msg->bounce.type == B_WARNING)
			io_xprintf(s->io, notice_warning2,
			    bounce_duration(s->msg->bounce.expire));

		io_xprintf(s->io,
		    "    Below is a copy of the original message:\n"
		    "\n");

		io_xprintf(s->io,
		    "--%16" PRIu64 "/%s\n"
		    "Content-Description: Delivery Report\n"
		    "Content-Type: message/delivery-status\n"
		    "\n",
		    s->boundary, s->smtpname);

		io_xprintf(s->io,
		    "Reporting-MTA: dns; %s\n"
		    "\n",
		    s->smtpname);

		TAILQ_FOREACH(evp, &s->msg->envelopes, entry) {
			io_xprintf(s->io,
			    "Final-Recipient: rfc822; %s@@%s\n"
			    "Action: %s\n"
			    "Status: %s\n"
			    "\n",
			    evp->dest.user,
			    evp->dest.domain,
			    action_str(&s->msg->bounce),
			    esc_code(evp->esc_class, evp->esc_code));
		}

		log_trace(TRACE_BOUNCE, "bounce: %p: >>> [... %zu bytes ...]",
		    s, io_queued(s->io));

		s->state = BOUNCE_DATA_MESSAGE;
		break;

	case BOUNCE_DATA_MESSAGE:
		io_xprintf(s->io,
		    "--%16" PRIu64 "/%s\n"
		    "Content-Description: Message headers\n"
		    "Content-Type: text/rfc822-headers\n"
		    "\n",
		    s->boundary, s->smtpname);

		n = io_queued(s->io);
		while (io_queued(s->io) < BOUNCE_HIWAT) {
			if ((len = getline(&line, &sz, s->msgfp)) == -1)
				break;
			if (len == 1 && line[0] == '\n' && /* end of headers */
			    s->msg->bounce.type == B_DSN &&
			    s->msg->bounce.dsn_ret ==  DSN_RETHDRS) {
				free(line);
				fclose(s->msgfp);
				s->msgfp = NULL;
				io_xprintf(s->io,
				    "\n--%16" PRIu64 "/%s--\n", s->boundary,
				    s->smtpname);
				bounce_send(s, ".");
				s->state = BOUNCE_DATA_END;
				return (0);
			}
			line[len - 1] = '\0';
			io_xprintf(s->io, "%s%s\n",
			    (len == 2 && line[0] == '.') ? "." : "", line);
		}
		free(line);

		if (ferror(s->msgfp)) {
			fclose(s->msgfp);
			s->msgfp = NULL;
			bounce_delivery(s->msg, IMSG_QUEUE_DELIVERY_TEMPFAIL,
			    "Error reading message");
			s->msg = NULL;
			return (-1);
		}

		io_xprintf(s->io,
		    "\n--%16" PRIu64 "/%s--\n", s->boundary, s->smtpname);

		log_trace(TRACE_BOUNCE, "bounce: %p: >>> [... %zu bytes ...]",
		    s, io_queued(s->io) - n);

		if (feof(s->msgfp)) {
			fclose(s->msgfp);
			s->msgfp = NULL;
			bounce_send(s, ".");
			s->state = BOUNCE_DATA_END;
		}
		break;

	case BOUNCE_QUIT:
		bounce_send(s, "QUIT");
		s->state = BOUNCE_CLOSE;
		break;

	default:
		fatalx("bounce: bad state");
	}

	return (0);
}


static void
bounce_delivery(struct bounce_message *msg, int delivery, const char *status)
{
	struct bounce_envelope	*be;
	struct envelope		 evp;
	size_t			 n;
	const char		*f;

	n = 0;
	while ((be = TAILQ_FIRST(&msg->envelopes))) {
		if (delivery == IMSG_QUEUE_DELIVERY_TEMPFAIL) {
			if (queue_envelope_load(be->id, &evp) == 0) {
				fatalx("could not reload envelope!");
			}
			evp.retry++;
			evp.lasttry = msg->timeout;
			envelope_set_errormsg(&evp, "%s", status);
			queue_envelope_update(&evp);
			m_create(p_scheduler, delivery, 0, 0, -1);
			m_add_envelope(p_scheduler, &evp);
			m_close(p_scheduler);
		} else {
			m_create(p_scheduler, delivery, 0, 0, -1);
			m_add_evpid(p_scheduler, be->id);
			m_close(p_scheduler);
			queue_envelope_delete(be->id);
		}
		TAILQ_REMOVE(&msg->envelopes, be, entry);
		free(be->report);
		free(be);
		n += 1;
	}


	if (delivery == IMSG_QUEUE_DELIVERY_TEMPFAIL)
		f = "TempFail";
	else if (delivery == IMSG_QUEUE_DELIVERY_PERMFAIL)
		f = "PermFail";
	else
		f = NULL;

	if (f)
		log_warnx("warn: %s injecting failure report on message %08"
		    PRIx32 " to <%s> for %zu envelope%s: %s",
		    f, msg->msgid, msg->to, n, n > 1 ? "s":"", status);

	nmessage -= 1;
	stat_decrement("bounce.message", 1);
	stat_decrement("bounce.envelope", n);
	free(msg->smtpname);
	free(msg->to);
	free(msg);
}

static void
bounce_status(struct bounce_session *s, const char *fmt, ...)
{
	va_list		 ap;
	char		*status;
	int		 len, delivery;

	/* Ignore if there is no message */
	if (s->msg == NULL)
		return;

	va_start(ap, fmt);
	if ((len = vasprintf(&status, fmt, ap)) == -1)
		fatal("bounce: vasprintf");
	va_end(ap);

	if (*status == '2')
		delivery = IMSG_QUEUE_DELIVERY_OK;
	else if (*status == '5' || *status == '6')
		delivery = IMSG_QUEUE_DELIVERY_PERMFAIL;
	else
		delivery = IMSG_QUEUE_DELIVERY_TEMPFAIL;

	bounce_delivery(s->msg, delivery, status);
	s->msg = NULL;
	if (s->msgfp)
		fclose(s->msgfp);

	free(status);
}

static void
bounce_free(struct bounce_session *s)
{
	log_debug("debug: bounce: %p: deleting session", s);

	io_free(s->io);

	free(s->smtpname);
	free(s);

	running -= 1;
	stat_decrement("bounce.session", 1);
	bounce_drain();
}

static void
bounce_io(struct io *io, int evt, void *arg)
{
	struct bounce_session	*s = arg;
	const char		*error;
	char			*line, *msg;
	int			 cont;
	size_t			 len;

	log_trace(TRACE_IO, "bounce: %p: %s %s", s, io_strevent(evt),
	    io_strio(io));

	switch (evt) {
	case IO_DATAIN:
	    nextline:
		line = io_getline(s->io, &len);
		if (line == NULL && io_datalen(s->io) >= LINE_MAX) {
			bounce_status(s, "Input too long");
			bounce_free(s);
			return;
		}

		if (line == NULL)
			break;

		log_trace(TRACE_BOUNCE, "bounce: %p: <<< %s", s, line);

		if ((error = parse_smtp_response(line, len, &msg, &cont))) {
			bounce_status(s, "Bad response: %s", error);
			bounce_free(s);
			return;
		}
		if (cont)
			goto nextline;

		if (s->state == BOUNCE_CLOSE) {
			bounce_free(s);
			return;
		}

		if (line[0] != '2' && line[0] != '3') {		/* fail */
			bounce_status(s, "%s", line);
			s->state = BOUNCE_QUIT;
		} else if (s->state == BOUNCE_DATA_END) {	/* accepted */
			bounce_status(s, "%s", line);
		}

		if (bounce_next(s) == -1) {
			bounce_free(s);
			return;
		}

		io_set_write(io);
		break;

	case IO_LOWAT:
		if (s->state == BOUNCE_DATA_MESSAGE)
			if (bounce_next(s) == -1) {
				bounce_free(s);
				return;
			}
		if (io_queued(s->io) == 0)
			io_set_read(io);
		break;

	default:
		bounce_status(s, "442 i/o error %d", evt);
		bounce_free(s);
		break;
	}
}

static int
bounce_message_cmp(const struct bounce_message *a,
    const struct bounce_message *b)
{
	int r;

	if (a->msgid < b->msgid)
		return (-1);
	if (a->msgid > b->msgid)
		return (1);
	if ((r = strcmp(a->smtpname, b->smtpname)))
		return (r);

	return memcmp(&a->bounce, &b->bounce, sizeof (a->bounce));
}

static const char *
action_str(const struct delivery_bounce *b)
{
	switch (b->type) {
	case B_ERROR:
		return ("error");
	case B_WARNING:
		return ("delayed");
	case B_DSN:
		if (b->mta_without_dsn)
			return ("relayed");

		return ("success");
	default:
		log_warn("warn: bounce: unknown bounce_type");
		return ("");
	}
}

SPLAY_GENERATE(bounce_message_tree, bounce_message, sp_entry,
    bounce_message_cmp);
@


1.76
log
@Normalize the io input buffer internally when reinstalling the io event, so
the caller doesn't have to bother with this.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.75 2016/11/21 13:00:43 eric Exp $	*/
d83 1
a83 2
	struct iobuf			 iobuf;
	struct io			 io;
d231 5
a235 6
	iobuf_xinit(&s->iobuf, 0, 0, "bounce_run");
	io_init(&s->io, &s->iobuf);
	io_set_callback(&s->io, bounce_io, s);
	io_set_fd(&s->io, fd);
	io_set_timeout(&s->io, 30000);
	io_set_read(&s->io);
d314 1
a314 1
	io_xprintf(&s->io, "%s\n", p);
d453 1
a453 1
		io_xprintf(&s->io,
d471 1
a471 1
		io_xprintf(&s->io,
d482 1
a482 1
			io_xprint(&s->io, notice_error);
d485 1
a485 1
			io_xprintf(&s->io, notice_warning,
d489 1
a489 1
			io_xprint(&s->io, s->msg->bounce.mta_without_dsn ?
d497 1
a497 1
			io_xprint(&s->io, evp->report);
d499 1
a499 1
		io_xprint(&s->io, "\n");
d502 1
a502 1
			io_xprintf(&s->io, notice_warning2,
d505 1
a505 1
		io_xprintf(&s->io,
d509 1
a509 1
		io_xprintf(&s->io,
d516 1
a516 1
		io_xprintf(&s->io,
d522 1
a522 1
			io_xprintf(&s->io,
d534 1
a534 1
		    s, io_queued(&s->io));
d540 1
a540 1
		io_xprintf(&s->io,
d547 2
a548 2
		n = io_queued(&s->io);
		while (io_queued(&s->io) < BOUNCE_HIWAT) {
d557 1
a557 1
				io_xprintf(&s->io,
d565 1
a565 1
			io_xprintf(&s->io, "%s%s\n",
d579 1
a579 1
		io_xprintf(&s->io,
d583 1
a583 1
		    s, io_queued(&s->io) - n);
d696 1
a696 2
	iobuf_clear(&s->iobuf);
	io_clear(&s->io);
d721 2
a722 2
		line = io_getline(&s->io, &len);
		if (line == NULL && io_datalen(&s->io) >= LINE_MAX) {
d767 1
a767 1
		if (io_queued(&s->io) == 0)
@


1.75
log
@replace calls to iobuf_*() functions with the corresponding io_*() wrappers.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.74 2016/11/20 08:43:36 eric Exp $	*/
d731 1
a731 2
		if (line == NULL) {
			iobuf_normalize(&s->iobuf);
a732 1
		}
@


1.74
log
@add dedicated functions to set fd and callback on a struct io.
simplify io_init() prototype.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.73 2016/11/16 21:30:37 eric Exp $	*/
d316 1
a316 1
	iobuf_xfqueue(&s->iobuf, "bounce_send", "%s\n", p);
d455 1
a455 1
		iobuf_xfqueue(&s->iobuf, "bounce_next: HEADER",
d473 1
a473 1
		iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
d484 1
a484 2
			iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
			    notice_error);
d487 1
a487 2
			iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
			    notice_warning,
d491 1
a491 2
			iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
			    s->msg->bounce.mta_without_dsn ?
d499 1
a499 3
			iobuf_xfqueue(&s->iobuf,
			    "bounce_next: DATA_NOTICE",
			    "%s", evp->report);
d501 1
a501 1
		iobuf_xfqueue(&s->iobuf, "bounce_next: DATA_NOTICE", "\n");
d504 1
a504 2
			iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
			    notice_warning2,
d507 1
a507 1
		iobuf_xfqueue(&s->iobuf, "bounce_next: DATA_NOTICE",
d511 1
a511 1
		iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
d518 1
a518 1
		iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
d524 1
a524 1
			iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
d536 1
a536 1
		    s, iobuf_queued(&s->iobuf));
d542 1
a542 1
		iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
d549 2
a550 2
		n = iobuf_queued(&s->iobuf);
		while (iobuf_queued(&s->iobuf) < BOUNCE_HIWAT) {
d559 1
a559 1
				iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
d567 1
a567 2
			iobuf_xfqueue(&s->iobuf,
			    "bounce_next: DATA_MESSAGE", "%s%s\n",
d581 1
a581 1
		iobuf_xfqueue(&s->iobuf, "bounce_next: BODY",
d585 1
a585 1
		    s, iobuf_queued(&s->iobuf) - n);
d724 2
a725 2
		line = iobuf_getline(&s->iobuf, &len);
		if (line == NULL && iobuf_len(&s->iobuf) >= LINE_MAX) {
d772 1
a772 1
		if (iobuf_queued(&s->iobuf) == 0)
@


1.73
log
@pass the user pointer as parameter to the io callback instead of having
the user dereference the io structure.

ok millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.72 2016/02/03 05:57:09 sunil Exp $	*/
d233 3
a235 1
	io_init(&s->io, fd, s, bounce_io, &s->iobuf);
@


1.72
log
@Use "esc_class" to classify bounce type instead of "errorline" as
we no longer prepend status code to "errorline". Fixes mismatch
between DSN's subject line and its content.

Ok jung@@ gilles@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.71 2015/12/24 16:54:37 mmcc Exp $	*/
d100 1
a100 1
static void bounce_io(struct io *, int);
d715 1
a715 1
bounce_io(struct io *io, int evt)
d717 1
a717 1
	struct bounce_session	*s = io->arg;
@


1.71
log
@more e-mail -> email
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.70 2015/12/14 10:31:25 sunil Exp $	*/
d152 5
a156 1
	if (evp.errorline[0] == '4')
d158 2
a159 1
	else if (evp.errorline[0] == '5')
d161 1
a161 2
	else
		key.bounce.type = B_DSN;
@


1.70
log
@Fix bad indents and whitespaces.

Ok jung@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.69 2015/12/14 10:22:11 jung Exp $	*/
d343 1
a343 1
	"    This is the MAILER-DAEMON, please DO NOT REPLY to this e-mail.\n"
@


1.69
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.68 2015/11/23 06:54:21 sunil Exp $	*/
d428 1
a428 1
 			break;
d519 1
a519 1
	    	    "Reporting-MTA: dns; %s\n"
d521 1
a521 1
	    	    s->smtpname);
d525 1
a525 1
	    	    	    "Final-Recipient: rfc822; %s@@%s\n"
d527 2
a528 2
	    	    	    "Status: %s\n"
	    	    	    "\n",
d532 1
a532 1
	    	    	    esc_code(evp->esc_class, evp->esc_code));
d545 3
a547 3
	    	    "Content-Type: text/rfc822-headers\n"
	    	    "\n",
	    	    s->boundary, s->smtpname);
d560 1
a560 1
	    	    		    "\n--%16" PRIu64 "/%s--\n", s->boundary,
d583 1
a583 1
	    	    "\n--%16" PRIu64 "/%s--\n", s->boundary, s->smtpname);
@


1.68
log
@Restructure bounce content as a multi-part MIME message.
Content-Type header diff from Philipp Takacs <philipp<at>bureaucracy.de>

Ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.67 2015/10/07 19:25:42 millert Exp $	*/
d392 1
a392 1
		goto again;		
d811 1
a811 1
		
@


1.67
log
@Use getline(3) rather than fgetln(3).  OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.66 2015/01/20 17:37:54 deraadt Exp $	*/
d61 1
d63 2
d85 1
d103 1
a103 1
static const char *bounce_strtype(enum bounce_type);
d151 10
d190 5
d232 1
d321 2
a322 1
		(void)snprintf(buf, sizeof buf, "%lld second%s", d, (d == 1)?"":"s");
d325 2
a326 1
		(void)snprintf(buf, sizeof buf, "%lld minute%s", d, (d == 1)?"":"s");
d330 2
a331 1
		(void)snprintf(buf, sizeof buf, "%lld hour%s", d, (d == 1)?"":"s");
d335 2
a336 1
		(void)snprintf(buf, sizeof buf, "%lld day%s", d, (d == 1)?"":"s");
d454 3
d458 1
a458 1
		    NOTICE_INTRO
d460 1
a460 1
		    bounce_strtype(s->msg->bounce.type),
d463 12
a474 1
		    time_to_text(time(NULL)));
d511 24
d542 6
a549 1

d559 3
d582 3
d651 2
a652 2
		log_warnx("warn: %s injecting failure report on message %08"PRIx32
		    " to <%s> for %zu envelope%s: %s",
d801 1
a801 1
bounce_strtype(enum bounce_type t)
d803 1
a803 1
	switch (t) {
d807 1
a807 1
		return ("warning");
d809 4
a812 1
		return ("dsn");
@


1.66
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.65 2014/05/28 10:34:16 daniel Exp $	*/
d387 3
a389 2
	char			*line;
	size_t			 len, n;
d484 1
a484 2
			line = fgetln(s->msgfp, &len);
			if (line == NULL)
d489 1
d501 1
@


1.65
log
@remove an errant semicolon.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.64 2014/04/19 17:27:40 gilles Exp $	*/
d38 1
d126 1
a126 1
	char			 buf[SMTPD_MAXLINESIZE], *line;
d344 1
a344 1
	char			 buf[SMTPD_MAXLINESIZE];
d651 1
a651 1
		if (line == NULL && iobuf_len(&s->iobuf) >= SMTPD_MAXLINESIZE) {
@


1.64
log
@(void) cast snprintf() calls that cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.63 2014/04/04 16:10:41 eric Exp $	*/
d314 1
a314 1
};
@


1.63
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d155 1
a155 1
		snprintf(buf, sizeof(buf), "%s@@%s", evp.sender.user,
d169 1
a169 1
	snprintf(buf, sizeof(buf), "%s@@%s: %s\n", evp.dest.user,
d295 2
a296 1
bounce_duration(long long int d) {
d300 1
a300 1
		snprintf(buf, sizeof buf, "%lld second%s", d, (d == 1)?"":"s");
d303 1
a303 1
		snprintf(buf, sizeof buf, "%lld minute%s", d, (d == 1)?"":"s");
d307 1
a307 1
		snprintf(buf, sizeof buf, "%lld hour%s", d, (d == 1)?"":"s");
d311 1
a311 1
		snprintf(buf, sizeof buf, "%lld day%s", d, (d == 1)?"":"s");
d371 1
a371 1
		snprintf(buf, sizeof(buf), "fdopen: %s", strerror(errno));
@


1.62
log
@Add support for DSN and Enhanced Status Code
@
text
@d133 1
a133 1
		m_create(p_scheduler, IMSG_DELIVERY_PERMFAIL, 0, 0, -1);
d269 1
a269 1
		m_compose(p_smtp, IMSG_SMTP_ENQUEUE_FD, 0, 0, -1, NULL, 0);
d364 1
a364 1
		bounce_delivery(msg, IMSG_DELIVERY_TEMPFAIL,
d373 1
a373 1
		bounce_delivery(msg, IMSG_DELIVERY_TEMPFAIL, buf);
d502 1
a502 1
			bounce_delivery(s->msg, IMSG_DELIVERY_TEMPFAIL,
d542 1
a542 1
		if (delivery == IMSG_DELIVERY_TEMPFAIL) {
d566 1
a566 1
	if (delivery == IMSG_DELIVERY_TEMPFAIL)
d568 1
a568 1
	else if (delivery == IMSG_DELIVERY_PERMFAIL)
d603 1
a603 1
		delivery = IMSG_DELIVERY_OK;
d605 1
a605 1
		delivery = IMSG_DELIVERY_PERMFAIL;
d607 1
a607 1
		delivery = IMSG_DELIVERY_TEMPFAIL;
@


1.61
log
@internal improvements and cleanups

- get rid of the whole penalty thing for failed envelopes in the mta and scheduler.
- do not disable routes on smtp errors
- try to schedule all types of envelopes on each scheduler frame.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.60 2013/12/03 08:32:40 eric Exp $	*/
d98 1
d332 6
d430 1
a430 1
		    (s->msg->bounce.type == B_ERROR) ? "error" : "warning",
d435 2
a436 1
		if (s->msg->bounce.type == B_ERROR)
d439 2
a440 1
		else
d444 9
d484 9
d721 16
@


1.60
log
@warn when failing to enqueue an internal bounce.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a524 1
			m_add_u32(p_scheduler, 0);
@


1.59
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d511 1
a511 5

	log_debug("debug: bounce: status %s for message %08"PRIx32": %s",
	    imsg_to_str(delivery),
	    msg->msgid,
	    status);
d538 13
@


1.58
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.57 2013/07/19 15:14:23 eric Exp $	*/
d68 1
d75 1
d144 1
a149 1
		SPLAY_INSERT(bounce_message_tree, &messages, msg);
d153 1
d158 1
d175 2
a176 2
	log_debug("debug: bounce: adding report %16"PRIx64": %s", be->id,
	    be->report);
d189 1
d193 4
a196 1
	if (fd == -1) {
d202 2
d205 1
d337 1
d341 10
a350 2
	msg = TAILQ_FIRST(&pending);
	if (msg == NULL || msg->timeout > time(NULL))
d383 1
a383 1
		bounce_send(s, "EHLO %s", env->sc_hostname);
d424 1
a424 1
		    env->sc_hostname,
d538 1
d546 2
d589 2
d676 2
d682 3
@


1.57
log
@scheduler improvements:
- implement suspend/resume scheduling for individual envelopes or message,
  with the associated smtpctl commands.
- allow the mta to request immediate scheduling of an envelope.
- on temporary failures a penalty can be given to further delay the next try.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d186 1
a186 1
	log_debug("debug: bounce: got enqueue socket %i", fd);
d220 1
a220 1
	log_debug("debug: bounce: drain: nmessage=%i running=%i",
d287 1
a287 1
		snprintf(buf, sizeof buf, "%lli second%s", d, (d == 1)?"":"s");
d290 1
a290 1
		snprintf(buf, sizeof buf, "%lli minute%s", d, (d == 1)?"":"s");
d294 1
a294 1
		snprintf(buf, sizeof buf, "%lli hour%s", d, (d == 1)?"":"s");
d298 1
a298 1
		snprintf(buf, sizeof buf, "%lli day%s", d, (d == 1)?"":"s");
d641 1
a641 1
		bounce_status(s, "442 i/o error %i", evt);
@


1.56
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.54 2013/01/26 09:37:23 gilles Exp $	*/
d509 1
@


1.55
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@a23 1
#include <sys/param.h>
d130 1
a130 1
		m_create(p_scheduler, IMSG_DELIVERY_PERMFAIL, 0, 0, -1, 9);
d442 1
a442 1
		while (iobuf_len(&s->iobuf) < BOUNCE_HIWAT) {
d507 1
a507 1
			m_create(p_scheduler, delivery, 0, 0, -1, MSZ_EVP);
d511 1
a511 2
			m_create(p_scheduler, delivery, 0, 0, -1,
			    sizeof(be->id) + 1);
@


1.54
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.52 2012/11/12 14:58:53 eric Exp $	*/
d123 1
a123 1
	char			 buf[MAX_LINE_SIZE], *line;
d325 1
a325 1
	char			 buf[MAX_LINE_SIZE];
d590 1
a590 1
		if (line == NULL && iobuf_len(&s->iobuf) >= SMTP_LINE_MAX) {
@


1.53
log
@knf

ok gilles@@
@
text
@d4 1
a4 1
 * Copyright (c) 2009 Gilles Chehade <gilles@@openbsd.org>
d43 1
a43 1
#define BOUNCE_MAXRUN	10
d53 1
d58 15
a72 10
struct bounce {
	TAILQ_ENTRY(bounce)	 entry;
	uint64_t		 id;
	uint32_t		 msgid;
	TAILQ_HEAD(, envelope)	 envelopes;
	size_t			 count;
	FILE			*msgfp;
	int			 state;
	struct iobuf		 iobuf;
	struct io		 io;
d74 6
a79 1
	struct event		 evt;
d82 6
d89 5
a93 4
static void bounce_commit(uint32_t);
static void bounce_send(struct bounce *, const char *, ...);
static int  bounce_next(struct bounce *);
static void bounce_status(struct bounce *, const char *, ...);
d96 1
a96 1
static void bounce_free(struct bounce *);
d98 7
a104 2
static struct tree bounces_by_msgid = SPLAY_INITIALIZER(&bounces_by_msgid);
static struct tree bounces_by_uid = SPLAY_INITIALIZER(&bounces_by_uid);
d106 13
a118 2
static int running = 0;
static TAILQ_HEAD(, bounce) runnable = TAILQ_HEAD_INITIALIZER(runnable);
d123 11
a133 11
	struct envelope	*evp;
	struct bounce	*bounce;
	struct timeval	 tv;

	evp = xcalloc(1, sizeof *evp, "bounce_add");

	if (queue_envelope_load(evpid, evp) == 0) {
		evp->id = evpid;
		imsg_compose_event(env->sc_ievs[PROC_SCHEDULER],
		    IMSG_QUEUE_DELIVERY_PERMFAIL, 0, 0, -1, evp, sizeof *evp);
		free(evp);
d137 1
a137 1
	if (evp->type != D_BOUNCE)
d139 1
a139 2
		    evp->id);
	evp->lasttry = time(NULL);
d141 33
a173 5
	bounce = tree_get(&bounces_by_msgid, evpid_to_msgid(evpid));
	if (bounce == NULL) {
		bounce = xcalloc(1, sizeof(*bounce), "bounce_add");
		bounce->msgid = evpid_to_msgid(evpid);
		tree_xset(&bounces_by_msgid, bounce->msgid, bounce);
d175 2
a176 2
		log_debug("debug: bounce: %p: new bounce for msg:%08" PRIx32,
		    bounce, bounce->msgid);
d178 2
a179 19
		TAILQ_INIT(&bounce->envelopes);
		evtimer_set(&bounce->evt, bounce_timeout, &bounce->msgid);
		tv.tv_sec = 1;
		tv.tv_usec = 0;
		evtimer_add(&bounce->evt, &tv);
	}

	log_debug("debug: bounce: %p: adding evp:%16" PRIx64, bounce, evp->id);

	TAILQ_INSERT_TAIL(&bounce->envelopes, evp, entry);
	bounce->count += 1;

	if (bounce->id)
		return;

	evtimer_del(&bounce->evt);
	tv.tv_sec = 1;
	tv.tv_usec = 0;
	evtimer_add(&bounce->evt, &tv);
d183 1
a183 1
bounce_run(uint64_t id, int fd)
d185 1
a185 4
	struct bounce	*bounce;
	int		 msgfd;

	log_trace(TRACE_BOUNCE, "bounce: run %016" PRIx64 " fd %i", id, fd);
d187 1
a187 1
	bounce = tree_xpop(&bounces_by_uid, id);
d190 2
a191 16
		bounce_status(bounce, "failed to receive enqueueing socket");
		bounce_free(bounce);
		return;
	}

	if ((msgfd = queue_message_fd_r(bounce->msgid)) == -1) {
		bounce_status(bounce, "could not open message fd");
		bounce_free(bounce);
		return;
	}

	if ((bounce->msgfp = fdopen(msgfd, "r")) == NULL) {
		log_warn("warn: bounce_run: fdopen");
		bounce_status(bounce, "error %i in fdopen", errno);
		bounce_free(bounce);
		close(msgfd);
d195 6
a200 13
	bounce->state = BOUNCE_EHLO;
	iobuf_xinit(&bounce->iobuf, 0, 0, "bounce_run");
	io_init(&bounce->io, fd, bounce, bounce_io, &bounce->iobuf);
	io_set_timeout(&bounce->io, 30000);
	io_set_read(&bounce->io);
}

static void
bounce_commit(uint32_t msgid)
{
	struct bounce	*bounce;

	log_trace(TRACE_BOUNCE, "bounce: commit msg:%08" PRIx32, msgid);
d202 2
a203 6
	bounce = tree_xget(&bounces_by_msgid, msgid);
	bounce->id = generate_uid();
	evtimer_del(&bounce->evt);
	TAILQ_INSERT_TAIL(&runnable, bounce, entry);

	bounce_drain();
d209 1
a209 1
	uint32_t *msgid = arg;
d211 1
a211 1
	bounce_commit(*msgid);
d217 3
a219 1
	struct bounce	*bounce;
d221 2
a222 1
	while ((bounce = TAILQ_FIRST(&runnable))) {
d224 1
d230 8
a237 5
		TAILQ_REMOVE(&runnable, bounce, entry);
		if (TAILQ_FIRST(&bounce->envelopes) == NULL) {
			log_debug("debug: bounce: %p: no envelopes", bounce);
			bounce_free(bounce);
			continue;
d240 4
a243 1
		tree_xset(&bounces_by_uid, bounce->id, bounce);
d245 11
a255 3
		log_debug("debug: bounce: %p: requesting enqueue socket "
		    "with id 0x%016" PRIx64,
		    bounce, bounce->id);
d257 2
a258 2
		imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_SMTP_ENQUEUE,
		    0, 0, -1, &bounce->id, sizeof (bounce->id));
d265 1
a265 1
bounce_send(struct bounce *bounce, const char *fmt, ...)
d276 1
a276 1
	log_trace(TRACE_BOUNCE, "bounce: %p: >>> %s", bounce, p);
d278 1
a278 1
	iobuf_xfqueue(&bounce->iobuf, "bounce_send", "%s\n", p);
d283 72
a354 1
/* This can simplified once we support PIPELINING */
d356 1
a356 1
bounce_next(struct bounce *bounce)
d358 3
a360 3
	struct envelope	*evp;
	char		*line;
	size_t		 len, s;
d362 1
a362 1
	switch (bounce->state) {
d364 2
a365 2
		bounce_send(bounce, "EHLO %s", env->sc_hostname);
		bounce->state = BOUNCE_MAIL;
d369 12
a380 2
		bounce_send(bounce, "MAIL FROM: <>");
		bounce->state = BOUNCE_RCPT;
d384 2
a385 4
		evp = TAILQ_FIRST(&bounce->envelopes);
		bounce_send(bounce, "RCPT TO: <%s@@%s>",
		    evp->sender.user, evp->sender.domain);
		bounce->state = BOUNCE_DATA;
d389 2
a390 2
		bounce_send(bounce, "DATA");
		bounce->state = BOUNCE_DATA_NOTICE;
d394 1
a394 4
		/* Construct an appropriate reason line. */

		/* prevent more envelopes from being added to this bounce */
		tree_xpop(&bounces_by_msgid, bounce->msgid);
d396 2
a397 4
		evp = TAILQ_FIRST(&bounce->envelopes);

		iobuf_xfqueue(&bounce->iobuf, "bounce_next: DATA_NOTICE",
		    "Subject: Delivery status notification\n"
d399 1
a399 1
		    "To: %s@@%s\n"
d402 1
a402 4
		    "Hi !\n"
		    "\n"
		    "This is the MAILER-DAEMON, please DO NOT REPLY to this e-mail.\n"
		    "An error has occurred while attempting to deliver a message.\n"
d404 1
d406 1
a406 1
		    evp->sender.user, evp->sender.domain,
d409 10
a418 5
		TAILQ_FOREACH(evp, &bounce->envelopes, entry) {
			line = evp->errorline;
			if (strlen(line) > 4 && (*line == '1' || *line == '6'))
				line += 4;
			iobuf_xfqueue(&bounce->iobuf,
d420 1
a420 3
			    "Recipient: %s@@%s\n"
			    "Reason: %s\n",
			    evp->dest.user, evp->dest.domain, line);
d422 1
d424 7
a430 3
		iobuf_xfqueue(&bounce->iobuf, "bounce_next: DATA_NOTICE",
		    "\n"
		    "Below is a copy of the original message:\n"
d434 1
a434 1
		    bounce, iobuf_queued(&bounce->iobuf));
d436 1
a436 1
		bounce->state = BOUNCE_DATA_MESSAGE;
d441 1
a441 1
		s = iobuf_queued(&bounce->iobuf);
d443 2
a444 2
		while (iobuf_len(&bounce->iobuf) < BOUNCE_HIWAT) {
			line = fgetln(bounce->msgfp, &len);
d448 1
a448 1
			iobuf_xfqueue(&bounce->iobuf,
d453 6
a458 2
		if (ferror(bounce->msgfp)) {
			bounce_status(bounce, "460 Error reading message");
d463 1
a463 1
		    bounce, iobuf_queued(&bounce->iobuf) - s);
d465 5
a469 3
		if (feof(bounce->msgfp)) {
			bounce_send(bounce, ".");
			bounce->state = BOUNCE_QUIT;
d474 2
a475 2
		bounce_send(bounce, "QUIT");
		bounce->state = BOUNCE_CLOSE;
d485 44
d530 1
a530 1
bounce_status(struct bounce *bounce, const char *fmt, ...)
d534 1
a534 2
	int		 len, msg;
	struct envelope	*evp;
d536 2
a537 2
	/* ignore if the envelopes have already been updated/deleted */
	if (TAILQ_FIRST(&bounce->envelopes) == NULL)
d546 1
a546 1
		msg = IMSG_QUEUE_DELIVERY_OK;
d548 1
a548 1
		msg = IMSG_QUEUE_DELIVERY_PERMFAIL;
d550 1
a550 1
		msg = IMSG_QUEUE_DELIVERY_TEMPFAIL;
d552 4
a555 15
	while ((evp = TAILQ_FIRST(&bounce->envelopes))) {
		if (msg == IMSG_QUEUE_DELIVERY_TEMPFAIL) {
			evp->retry++;
			envelope_set_errormsg(evp, "%s", status);
			queue_envelope_update(evp);
			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER], msg, 0,
			    0, -1, evp, sizeof *evp);
		} else {
			queue_envelope_delete(evp);
			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER], msg, 0,
			    0, -1, &evp->id, sizeof evp->id);
		}
		TAILQ_REMOVE(&bounce->envelopes, evp, entry);
		free(evp);
	}
d561 1
a561 1
bounce_free(struct bounce *bounce)
d563 1
a563 1
	struct envelope	*evp;
d565 3
a567 15
	log_debug("debug: bounce: %p: deleting session", bounce);

	/* if the envelopes where not sent, it is still in the tree */
	tree_pop(&bounces_by_msgid, bounce->msgid);

	while ((evp = TAILQ_FIRST(&bounce->envelopes))) {
		TAILQ_REMOVE(&bounce->envelopes, evp, entry);
		free(evp);
	}

	if (bounce->msgfp)
		fclose(bounce->msgfp);
	iobuf_clear(&bounce->iobuf);
	io_clear(&bounce->io);
	free(bounce);
d570 1
d577 5
a581 5
	struct bounce	*bounce = io->arg;
	const char	*error;
	char		*line, *msg;
	int		 cont;
	size_t		 len;
d583 2
a584 2
	log_trace(TRACE_IO, "bounce: %p: %s %s",
	    bounce, io_strevent(evt), io_strio(io));
d589 7
a595 1
		line = iobuf_getline(&bounce->iobuf, &len);
d597 1
a597 6
			if (iobuf_len(&bounce->iobuf) >= SMTP_LINE_MAX) {
				bounce_status(bounce, "150 Input too long");
				bounce_free(bounce);
				return;
			}
			iobuf_normalize(&bounce->iobuf);
d601 1
a601 1
		log_trace(TRACE_BOUNCE, "bounce: %p: <<< %s", bounce, line);
d604 2
a605 2
			bounce_status(bounce, "150 Bad response: %s", error);
			bounce_free(bounce);
d611 2
a612 2
		if (bounce->state == BOUNCE_CLOSE) {
			bounce_free(bounce);
d617 4
a620 4
			bounce_status(bounce, "%s", line);
			bounce->state = BOUNCE_QUIT;
		} else if (bounce->state == BOUNCE_QUIT) {	/* accepted */
			bounce_status(bounce, "%s", line);
d623 2
a624 2
		if (bounce_next(bounce) == -1) {
			bounce_free(bounce);
d632 6
a637 3
		if (bounce->state == BOUNCE_DATA_MESSAGE)
			bounce_next(bounce);
		if (iobuf_queued(&bounce->iobuf) == 0)
d642 2
a643 2
		bounce_status(bounce, "442 i/o error %i", evt);
		bounce_free(bounce);
d647 14
@


1.52
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.51 2012/10/07 15:46:38 chl Exp $	*/
d143 1
a143 1
	
d219 2
a220 1
		log_debug("debug: bounce: %p: requesting enqueue socket with id 0x%016" PRIx64,
d246 1
a246 1
        free(p);
d257 1
a257 1
	switch(bounce->state) {
d307 2
a308 1
			iobuf_xfqueue(&bounce->iobuf, "bounce_next: DATA_NOTICE",
d394 2
a395 2
			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER], msg, 0, 0, -1,
			    evp, sizeof *evp);
d398 2
a399 2
			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER], msg, 0, 0, -1,
			    &evp->id, sizeof evp->id);
d457 1
a457 1
		} 
@


1.51
log
@convert iobuf_queue()'s to iobuf_fqueue(). (idea from gilles@@)
introduce iobuf_xinit() and iobuf_xfqueue(). (idea from eric@@)

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.50 2012/10/03 16:43:19 chl Exp $	*/
d114 1
a114 1
		log_debug("bounce: %p: new bounce for msg:%08" PRIx32,
d124 1
a124 1
	log_debug("bounce: %p: adding evp:%16" PRIx64, bounce, evp->id);
d161 1
a161 1
		log_warn("bounce_run: fdopen");
d206 1
a206 1
			log_debug("bounce: max session reached");
d212 1
a212 1
			log_debug("bounce: %p: no envelopes", bounce);
d219 1
a219 1
		log_debug("bounce: %p: requesting enqueue socket with id 0x%016" PRIx64,
d411 1
a411 1
	log_debug("bounce: %p: deleting session", bounce);
@


1.50
log
@don't try to cope with iobuf_init() failure, make it fatal() instead.

from eric@@ input

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.49 2012/10/02 12:37:38 chl Exp $	*/
d169 1
a169 2
	if (iobuf_init(&bounce->iobuf, 0, 0) == -1)
		fatal("iobuf_init");
d243 1
a243 1
	iobuf_fqueue(&bounce->iobuf, "%s\n", p);
d287 1
a287 1
		iobuf_fqueue(&bounce->iobuf,
d306 1
a306 1
			iobuf_fqueue(&bounce->iobuf,
d312 1
a312 1
		iobuf_fqueue(&bounce->iobuf,
d332 3
a334 4
			if(len == 2 && line[0] == '.')
				iobuf_queue(&bounce->iobuf, ".", 1);
			iobuf_queue(&bounce->iobuf, line, len);
			iobuf_queue(&bounce->iobuf, "\n", 1);
@


1.49
log
@check iobuf_init() return value.

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.48 2012/09/26 21:06:45 chl Exp $	*/
d169 2
a170 6
	if (iobuf_init(&bounce->iobuf, 0, 0) == -1) {
		bounce_status(bounce, "iobuf_init");
		bounce_free(bounce);
		close(msgfd);
		return;
	}
@


1.48
log
@fix memory leak in case of fdopen() failure

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.47 2012/08/18 15:39:26 eric Exp $	*/
d169 6
a174 1
	iobuf_init(&bounce->iobuf, 0, 0);
@


1.47
log
@Limit the number of bounce sessions running at the same time.  When
committed, a bounce is put on a runnable list of bounces. This list
is drained to enqueue as much bounces as possible within the limit.

This avoids DoS'ing the server when lots of bounces are enqueued at
startup.

While there, allow new envelopes to be added to a bounce until the
the very last moment (i.e. when the list of recipients is written).

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.46 2012/08/09 16:00:31 eric Exp $	*/
d163 1
@


1.46
log
@Allow failure reports for different recipients of the same message
to be grouped into a single bounce message.

The bounce structure keeps a list of envelopes.  For now, the list
is constructed by delaying the re-enqueuing of a bounce envelope a
bit, to wait for other bounces from the same message to be part of
the same report.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.44 2012/08/09 09:48:02 eric Exp $	*/
d43 1
d58 1
a67 1
	/* temporary workaround */
d71 1
d83 3
d129 3
d146 1
a146 1
	bounce = tree_xget(&bounces_by_uid, id);
d181 2
a182 2
	bounce = tree_xpop(&bounces_by_msgid, msgid);

d184 1
d186 1
a186 14
	if (TAILQ_FIRST(&bounce->envelopes) == NULL) {
		log_debug("bounce: %p: no envelopes", bounce);
		bounce_free(bounce);
		return;
	}

	bounce->id = generate_uid();
	tree_xset(&bounces_by_uid, bounce->id, bounce);

	log_debug("bounce: %p: requesting enqueue socket with id 0x%016" PRIx64,
	    bounce, bounce->id);

	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_SMTP_ENQUEUE, 0, 0, -1,
	  &bounce->id, sizeof (bounce->id));
d198 31
d281 3
d413 3
d426 3
@


1.45
log
@remove unused function and prototypes
@
text
@d28 1
d57 11
a67 5
	struct envelope	 evp;
	FILE		*msgfp;
	int		 state;
	struct iobuf	 iobuf;
	struct io	 io;
d70 1
d75 125
d224 3
a226 2
	char	*line;
	size_t	 len, s;
d240 1
d242 1
a242 1
		    bounce->evp.sender.user, bounce->evp.sender.domain);
d253 3
a255 4
		line = bounce->evp.errorline;
		if (strlen(line) > 4 && (*line == '1' || *line == '6'))
			line += 4;
	
d266 16
a281 4
		    "\n"
		    "Recipient: %s@@%s\n"
		    "Reason:\n"
		    "%s\n"
d284 1
a284 6
		    "\n",
		    env->sc_hostname,
		    bounce->evp.sender.user, bounce->evp.sender.domain,
		    time_to_text(time(NULL)),
		    bounce->evp.dest.user, bounce->evp.dest.domain,
		    line);
a318 1

d339 1
a339 1
	struct envelope *evp;
d341 2
a342 2
	/* ignore if the envelope has already been updated/deleted */
	if (bounce->evp.id == 0)
d357 14
a370 11
	evp = &bounce->evp;
	if (msg == IMSG_QUEUE_DELIVERY_TEMPFAIL) {
		evp->retry++;
		envelope_set_errormsg(evp, "%s", status);
		queue_envelope_update(evp);
		imsg_compose_event(env->sc_ievs[PROC_SCHEDULER], msg, 0, 0, -1,
		    evp, sizeof *evp);
	} else {
		queue_envelope_delete(evp);
		imsg_compose_event(env->sc_ievs[PROC_SCHEDULER], msg, 0, 0, -1,
		    &evp->id, sizeof evp->id);
a372 1
	bounce->evp.id = 0;
d379 2
d383 7
a389 1
	fclose(bounce->msgfp);
a462 40
}

int
bounce_session(int fd, struct envelope *evp)
{
	struct bounce	*bounce = NULL;
	int		 msgfd = -1;
	FILE		*msgfp = NULL;
	u_int32_t	 msgid;

	msgid = evpid_to_msgid(evp->id);

	log_debug("bounce: bouncing envelope id %016" PRIx64 "", evp->id);

	/* get message content */
	if ((msgfd = queue_message_fd_r(msgid)) == -1)
		return (0);

	msgfp = fdopen(msgfd, "r");
	if (msgfp == NULL) {
		log_warn("bounce: fdopen");
		close(msgfd);
		return (0);
	}

	if ((bounce = calloc(1, sizeof(*bounce))) == NULL) {
		log_warn("bounce: calloc");
		fclose(msgfp);
		return (0);
	}

	bounce->evp = *evp;
	bounce->msgfp = msgfp;
	bounce->state = BOUNCE_EHLO;

	iobuf_init(&bounce->iobuf, 0, 0);
	io_init(&bounce->io, fd, bounce, bounce_io, &bounce->iobuf);
	io_set_timeout(&bounce->io, 30000);
	io_set_read(&bounce->io);
	return (1);
@


1.44
log
@Improve the message flows to completely isolate operations on the
queue backend within the queue process.

The scheduler sends envelope ids to the queue process which loads
the envelope and forward the request to the agent responsible for
the delivery.  The result is sent by the agent to the queue which
updates the storage before notifying the scheduler.

Bounces are created and enqueued (from the client side) by the
queue process, rather than the scheduler.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.43 2012/08/08 08:50:42 eric Exp $	*/
a352 15
}

int
bounce_record_message(struct envelope *e, struct envelope *bounce)
{
	if (e->type == D_BOUNCE) {
		log_debug("mailer daemons loop detected !");
		return 0;
	}

	*bounce = *e;
	bounce->type = D_BOUNCE;
	bounce->retry = 0;
	bounce->lasttry = 0;
	return (queue_envelope_create(bounce));
@


1.43
log
@Improve the scheduler backend API.

New envelopes are pushed into the scheduler through the insert()
commit() rollback() transactional interface functions.

Worklists are pulled from the scheduler through a single batch()
interface function, which returns a list of envelope ids and the
type of processing. Envelopes returned in this batch are said to
be "in-flight", as opposed to "pending". They are supposed to be
processed in some way, and either updated() or deleted() at some
point.

The schedule()/remove() functions are used to alter the internal
state of "pending" envelopes to make them schedulable.  The enve-
lopes will be part of a worklist on the next call to batch().

Rewrite the scheduler_ramqueue backend.

The initial queue loading in now done by the queue.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.42 2012/07/09 09:57:53 gilles Exp $	*/
a62 4
/* XXX remove later */
void scheduler_envelope_update(struct envelope *);
void scheduler_envelope_delete(struct envelope *);

d196 4
a199 3
	va_list	 ap;
	char	*status;
	int	 len;
d210 14
a223 5
	if (*status == '2' || *status == '5' || *status == '6') {
		log_debug("#### %s: queue_envelope_delete: %016" PRIx64,
		    __func__, bounce->evp.id);
		queue_envelope_delete(&bounce->evp);
		scheduler_envelope_delete(&bounce->evp);
d225 3
a227 4
		bounce->evp.retry++;
		envelope_set_errormsg(&bounce->evp, "%s", status);
		queue_envelope_update(&bounce->evp);
		scheduler_envelope_update(&bounce->evp);
d229 1
a242 3

	stat_decrement(STATS_SCHEDULER);
	stat_decrement(STATS_SCHEDULER_BOUNCES);
@


1.42
log
@- runner is the terminology we used back when we had runqueues, we no
  longer have them and runner is actually a scheduler so rename.
- introduce scheduler_backend which does the same to scheduler than
  queue_backend does to queue and map_backend does to maps
- remove all occurences of RUNNER and runner, replace them with SCHEDULER
  and scheduler

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.41 2012/06/20 20:45:23 eric Exp $	*/
d63 4
d217 1
d222 1
@


1.41
log
@Finally get rid of the queue_kind enum in the queue API. Keep that
internally in fsqueue backend for now, and let the fsqueue_message()
and fsqueue_envelope() dispatchers do the right thing.

Based on a diff by chl@@

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.40 2012/01/29 11:37:32 eric Exp $	*/
d232 2
a233 2
	stat_decrement(STATS_RUNNER);
	stat_decrement(STATS_RUNNER_BOUNCES);
@


1.40
log
@Rewrite io code in smtp and mta using the iobuf/ioev interface to have
a better separation between io and protocol logic.  As a side-effect,
it fixes a couple of long-standing issues in the io path, and
hopefully add fresh ones instead.  Kill client.c in the process.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.39 2012/01/12 22:59:55 eric Exp $	*/
d212 1
a212 1
		queue_envelope_delete(Q_QUEUE, &bounce->evp);
d216 1
a216 1
		queue_envelope_update(Q_QUEUE, &bounce->evp);
d319 1
a319 1
	if ((msgfd = queue_message_fd_r(Q_QUEUE, msgid)) == -1)
d358 1
a358 1
	return (queue_envelope_create(Q_QUEUE, bounce));
@


1.39
log
@The status field in the envelope is confusing. Its only purpose is to
notify the runner of what happened with an envelope that has been
scheduled.  It is not part of the state of the envelope, and it is not
even dumped.  So it should only be set by mta/mda, checked by runner
to decide what to do with the envelope, and ignored everywhere else.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.38 2012/01/11 17:28:36 eric Exp $	*/
d6 1
a39 1
#include "client.h"
d42 19
a60 5
struct client_ctx {
	struct event		 ev;
	struct envelope		 m;
	struct smtp_client	*pcb;
	FILE			*msgfp;
d63 7
a69 2
int
bounce_session(int fd, struct envelope *m)
d71 3
a73 5
	struct client_ctx	*cc = NULL;
	int			 msgfd = -1;
	char			*reason;
	FILE			*msgfp = NULL;
	u_int32_t		 msgid;
d75 4
a78 1
	msgid = evpid_to_msgid(m->id);
d80 5
a84 62
	/* get message content */
	if ((msgfd = queue_message_fd_r(Q_QUEUE, msgid)) == -1)
		goto fail;
	msgfp = fdopen(msgfd, "r");
	if (msgfp == NULL)
		fatal("fdopen");
	
	/* init smtp session */
	if ((cc = calloc(1, sizeof(*cc))) == NULL) 
		goto fail;
	cc->pcb = client_init(fd, msgfp, env->sc_hostname, 1);
	cc->m = *m;
	cc->msgfp = msgfp;

	client_ssl_optional(cc->pcb);
	client_sender(cc->pcb, "");
	client_rcpt(cc->pcb, NULL, "%s@@%s", m->sender.user,
	    m->sender.domain);

	/* Construct an appropriate reason line. */
	reason = m->errorline;
	if (strlen(reason) > 4 && (*reason == '1' || *reason == '6'))
		reason += 4;
	
	/* create message header */
	/* XXX - The Date: header should be added during SMTP pickup. */
	client_printf(cc->pcb,
	    "Subject: Delivery status notification\n"
	    "From: Mailer Daemon <MAILER-DAEMON@@%s>\n"
	    "To: %s@@%s\n"
	    "Date: %s\n"
	    "\n"
	    "Hi !\n"
	    "\n"
	    "This is the MAILER-DAEMON, please DO NOT REPLY to this e-mail.\n"
	    "An error has occurred while attempting to deliver a message.\n"
	    "\n"
	    "Recipient: %s@@%s\n"
	    "Reason:\n"
	    "%s\n"
	    "\n"
	    "Below is a copy of the original message:\n"
	    "\n",
	    env->sc_hostname,
	    m->sender.user, m->sender.domain,
	    time_to_text(time(NULL)),
	    m->dest.user, m->dest.domain,
	    reason);

	/* setup event */
	session_socket_blockmode(fd, BM_NONBLOCK);
	event_set(&cc->ev, fd, EV_READ|EV_WRITE, bounce_event, cc);
	event_add(&cc->ev, &cc->pcb->timeout);

	return 1;
fail:
	if (cc)
		fclose(cc->msgfp);
	else if (msgfd != -1)
		close(msgfd);
	free(cc);
	return 0;
d87 3
a89 2
void
bounce_event(int fd, short event, void *p)
d91 13
a103 2
	struct client_ctx	*cc = p;
	char			*ep = NULL;
d105 73
a177 4
	if (event & EV_TIMEOUT) {
		ep = "150 timeout";
		goto out;
	}
a178 7
	switch (client_talk(cc->pcb, event & EV_WRITE)) {
	case CLIENT_STOP_WRITE:
		goto ro;
	case CLIENT_WANT_WRITE:
		goto rw;
	case CLIENT_RCPT_FAIL:
		ep = cc->pcb->reply;
d180 4
a183 2
	case CLIENT_DONE:
		ep = cc->pcb->status;
d185 1
d187 1
a187 1
		fatalx("bounce_event: unexpected code");
d190 20
a209 2
out:
	if (*ep == '2' || *ep == '5' || *ep == '6') {
d211 2
a212 2
		    __func__, cc->m.id);
		queue_envelope_delete(Q_QUEUE, &cc->m);
d214 3
a216 3
		cc->m.retry++;
		envelope_set_errormsg(&cc->m, "%s", ep);
		queue_envelope_update(Q_QUEUE, &cc->m);
d218 13
d234 110
a343 13
	client_close(cc->pcb);
	fclose(cc->msgfp);
	free(cc);
	return;

ro:
	event_set(&cc->ev, fd, EV_READ, bounce_event, cc);
	event_add(&cc->ev, &cc->pcb->timeout);
	return;

rw:
	event_set(&cc->ev, fd, EV_READ|EV_WRITE, bounce_event, cc);
	event_add(&cc->ev, &cc->pcb->timeout);
@


1.38
log
@Finally remove the queue_message_update() function which ended up
being only called by bounce sessions, so most of the code there was
actually useless.  The envelope is directly deleted or updated at the
relevant place.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.37 2011/12/27 14:38:56 eric Exp $	*/
a155 1
		cc->m.status = DS_TEMPFAILURE;
a187 1
	bounce->status &= ~DS_PERMFAILURE;
@


1.37
log
@Instead of using a separate "bounce" queue, create the bounce envelope
directly as an envelope of the bounced message, just like "regular"
envelopes.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.36 2011/12/14 23:08:40 eric Exp $	*/
a48 2
static void queue_message_update(struct envelope *);

d151 1
a151 1
	if (*ep == '2') {
d155 3
a157 6
	}
	else {
		if (*ep == '5' || *ep == '6')
			cc->m.status = DS_PERMFAILURE;
		else
			cc->m.status = DS_TEMPFAILURE;
d159 1
a159 1
		queue_message_update(&cc->m);
a192 31
}

static void
queue_message_update(struct envelope *e)
{
	e->batch_id = 0;
	e->status &= ~(DS_ACCEPTED|DS_REJECTED);
	e->retry++;

	if (e->type != D_BOUNCE)
		fatalx("*** queue_message_update called for non-bounce msg");

	if (e->status & DS_PERMFAILURE) {
		if (e->type != D_BOUNCE &&
		    e->sender.user[0] != '\0') {
			struct envelope bounce;

			bounce_record_message(e, &bounce);
		}
		queue_envelope_delete(Q_QUEUE, e);
		return;
	}

	if (e->status & DS_TEMPFAILURE) {
		e->status &= ~DS_TEMPFAILURE;
		queue_envelope_update(Q_QUEUE, e);
		return;
	}

	/* no error, remove envelope */
	queue_envelope_delete(Q_QUEUE, e);
@


1.36
log
@finally kill queue_shared.c and move what is left to bounce.c
where it belongs.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.35 2011/10/27 14:32:57 chl Exp $	*/
a186 4
	u_int32_t msgid;

	bzero(bounce, sizeof(*bounce));

d193 5
a197 12
	 bounce->type = D_BOUNCE;
	 bounce->status &= ~DS_PERMFAILURE;

	msgid = evpid_to_msgid(e->id);
	if (! queue_message_create(Q_BOUNCE, &msgid))
		return 0;

	bounce->id = msgid_to_evpid(msgid);
	if (! queue_envelope_create(Q_BOUNCE, bounce))
		return 0;

	return queue_message_commit(Q_BOUNCE, msgid);
d207 2
@


1.35
log
@Use PRI{x,d}64 in format strings instead of %llx, %lld or %qd to print {u_,}int64_t or time_t

While there, cast some time_t to int64_t

These will fix build warnings for portable smptd

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.34 2011/10/23 09:30:06 gilles Exp $	*/
d49 2
d182 56
@


1.34
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.33 2011/09/01 19:56:49 eric Exp $	*/
d29 1
d152 1
a152 1
		log_debug("#### %s: queue_envelope_delete: %016llx",
@


1.33
log
@Introduce a small set of functions to manage stat counters in a
simpler and hopefully saner way.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.32 2011/05/16 21:05:51 gilles Exp $	*/
d57 1
a57 1
	msgid = evpid_to_msgid(m->delivery.id);
d75 2
a76 2
	client_rcpt(cc->pcb, NULL, "%s@@%s", m->delivery.from.user,
	    m->delivery.from.domain);
d79 1
a79 1
	reason = m->delivery.errorline;
d103 1
a103 1
	    m->delivery.from.user, m->delivery.from.domain,
d105 1
a105 1
	    m->delivery.rcpt.user, m->delivery.rcpt.domain,
d150 3
a152 1
	if (*ep == '2')
d154 1
d157 1
a157 1
			cc->m.delivery.status = DS_PERMFAILURE;
d159 1
a159 1
			cc->m.delivery.status = DS_TEMPFAILURE;
@


1.32
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.31 2011/05/01 12:57:11 eric Exp $	*/
d161 2
a162 2
	env->stats->runner.active--;
	env->stats->runner.bounces_active--;
@


1.31
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.30 2011/04/17 11:39:22 gilles Exp $	*/
d57 1
a57 1
	msgid = evpid_to_msgid(m->evpid);
d75 2
a76 2
	client_rcpt(cc->pcb, NULL, "%s@@%s", m->sender.user,
	    m->sender.domain);
d79 1
a79 1
	reason = m->session_errorline;
d103 1
a103 1
	    m->sender.user, m->sender.domain,
d105 1
a105 1
	    m->recipient.user, m->recipient.domain,
d154 1
a154 1
			cc->m.status = S_MESSAGE_PERMFAILURE;
d156 2
a157 2
			cc->m.status = S_MESSAGE_TEMPFAILURE;
		message_set_errormsg(&cc->m, "%s", ep);
@


1.30
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.29 2011/04/15 17:01:05 gilles Exp $	*/
a44 1
	struct smtpd		*env;
d49 1
a49 1
bounce_session(struct smtpd *env, int fd, struct envelope *m)
d60 1
a60 1
	if ((msgfd = queue_message_fd_r(env, Q_QUEUE, msgid)) == -1)
a69 1
	cc->env = env;
d151 1
a151 1
		queue_envelope_delete(cc->env, Q_QUEUE, &cc->m);
d158 1
a158 1
		queue_message_update(cc->env, &cc->m);
d161 2
a162 2
	cc->env->stats->runner.active--;
	cc->env->stats->runner.bounces_active--;
@


1.29
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.28 2011/04/14 21:53:45 gilles Exp $	*/
d43 1
a43 1
	struct message		 m;
d50 1
a50 1
bounce_session(struct smtpd *env, int fd, struct message *messagep)
d58 1
a58 1
	msgid = evpid_to_msgid(messagep->evpid);
d72 1
a72 1
	cc->m = *messagep;
d77 2
a78 2
	client_rcpt(cc->pcb, NULL, "%s@@%s", messagep->sender.user,
	    messagep->sender.domain);
d81 1
a81 1
	reason = messagep->session_errorline;
d105 1
a105 1
	    messagep->sender.user, messagep->sender.domain,
d107 1
a107 1
	    messagep->recipient.user, messagep->recipient.domain,
@


1.28
log
@fsqueue now provides fsqueue_message_fd_r() and fsqueue_message_fd_rw() to
obtain a read{-only,/write} descriptor to the message file.

make sure smtpd uses the new API everywhere it needs a fd, and kill the
many functions that were used until now.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.27 2011/04/14 20:11:08 gilles Exp $	*/
d56 3
d61 1
a61 2
	if ((msgfd = queue_message_fd_r(env, Q_QUEUE,
		    messagep->message_id)) == -1)
@


1.27
log
@fsqueue queue backend will implement a filesystem queue:
- fsqueue->setup() performs the queue initialization;
- fsqueue->message() controls messages;
- fsqueue->envelope() controls envelopes;

This commit brings the following to fsbackend:
fsqueue_setup(), fsqueue_message_delete(), fsqueue_envelope_load(),
fsqueue_envelope_update(), fsqueue_envelope_delete().

It also makes smtpd use the queue_backend API for these operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.26 2011/03/26 10:59:59 gilles Exp $	*/
d58 2
a59 1
	if ((msgfd = queue_open_message_file(messagep->message_id)) == -1)
@


1.26
log
@have the client API receive a stdio stream rather than a fd to the message
fd. this shifts responsibility for the fclose to the caller, prevents a
memory leak and makes everyone happy.

diff by Jared Yanovich, thanks !
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.25 2011/03/21 13:06:25 gilles Exp $	*/
d150 1
a150 1
		queue_remove_envelope(&cc->m);
d157 1
a157 1
		queue_message_update(&cc->m);
@


1.25
log
@do not close msgfd in bounce_session(), it is closed by client_close()
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.24 2010/11/28 13:56:43 gilles Exp $	*/
d46 1
d55 1
d60 3
d65 1
a65 2
	if ((cc = calloc(1, sizeof(*cc))) == NULL) {
		close(msgfd);
d67 1
a67 2
	}
	cc->pcb = client_init(fd, msgfd, env->sc_hostname, 1);
d70 1
d114 4
a117 2
	if (cc && cc->pcb)
		client_close(cc->pcb);
d163 1
@


1.24
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.23 2010/10/09 22:11:08 gilles Exp $	*/
d58 1
a58 1

d60 2
a61 1
	if ((cc = calloc(1, sizeof(*cc))) == NULL)
d63 1
a109 1
	close(msgfd);
@


1.23
log
@missing from previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.19 2010/05/19 20:57:10 gilles Exp $	*/
d28 1
d39 1
a46 2

void		 bounce_event(int, short, void *);
@


1.22
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.21 2010/06/01 19:47:08 jacekm Exp $	*/
@


1.21
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.19 2010/05/19 20:57:10 gilles Exp $	*/
@


1.20
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@@


1.19
log
@cleanup-only commit, removes unrequired includes, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.18 2010/04/22 12:56:33 jacekm Exp $	*/
@


1.18
log
@Fix a case of runner trying to send imsg directly to smtp process instead
of forwarding it via queue.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.17 2009/12/23 17:16:03 jacekm Exp $	*/
d119 1
a119 1
	char			*ep;
@


1.17
log
@Implementation of RFC 2920 PIPELINING extension, client side only for now.

This restructures the client_* API internals significantly.  The code becomes
pipelining in nature.  All SMTP commands are put on the output queue and
dequeued as quickly as possible.  Once dequeued, they're moved to the receive
queue so that replies can be matched with previous commands.

Dequeuing commands from the output queue halts when the count of commands
currently in-pipeline (``cmdi'') is equal to the command send window (``cmdw'').
There are three cmdw values useful in practice:

0               clear pipeline, ie. inhibit all future sends
1               disable pipelining, ie. use old ``one-request-one-reply`` mode
SIZE_T_MAX      enable pipelining, ie. dequeue as many commands as possible

At the beginning of session cmdw is 1.  When it is found that peer supports
PIPELINING, it grows to SIZE_T_MAX.  After dequeing DATA it is again 1.  After
sending QUIT it is 0.

Each command dequeued from the output queue becomes a buf in a msgbuf.  The act
of combining multiple commands into a single send operation did not need to be
implemented: buf_write() already combines bufs using iovec and sends them at
once using sendmsg(2).

Tested by todd@@ and oga@@

"looks good" to gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.16 2009/12/14 23:17:04 jacekm Exp $	*/
a46 7

void
bounce_process(struct smtpd *env, struct message *message)
{
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_SMTP_ENQUEUE, 0, 0, -1,
		message, sizeof(*message));
}
@


1.16
log
@Handle 6yz code as permanent error.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.15 2009/12/14 18:21:53 jacekm Exp $	*/
d74 1
a74 2

	/* assign recipient */
d110 1
a110 1
	event_set(&cc->ev, fd, EV_WRITE, bounce_event, cc);
d133 3
a135 3
	switch (client_talk(cc->pcb)) {
	case CLIENT_WANT_READ:
		goto read;
d137 1
a137 1
		goto write;
d166 1
a166 1
read:
d171 2
a172 2
write:
	event_set(&cc->ev, fd, EV_WRITE, bounce_event, cc);
@


1.15
log
@Control maximum number of bounce sessions similarly to how the mta and mda
are now controlled.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.14 2009/12/12 14:03:59 jacekm Exp $	*/
d153 1
a153 1
		if (*ep == '5')
@


1.14
log
@When acting as a client do content reads from the disk progressively
as the remote accepts more data instead of doing one big read into
the memory in the beginning of session.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.13 2009/12/12 10:33:11 jacekm Exp $	*/
d43 1
d70 1
d161 2
@


1.13
log
@Simplify client_* api, mainly by making fatal conditions result in immediate
fatals instead of passing the error up (kills ~300 lines).

Implement sending of the QUIT command which replaces crude close(2).

tested by gilles@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.12 2009/11/11 10:04:05 chl Exp $	*/
d61 4
d68 1
a68 1
	cc->pcb = client_init(fd, env->sc_hostname, 1);
d84 1
a84 1
	client_data_printf(cc->pcb,
a105 7

	/* append original message */
	if ((msgfd = queue_open_message_file(messagep->message_id)) == -1)
		goto fail;
	client_data_fd(cc->pcb, msgfd);
	close(msgfd);
	msgfd = -1;
@


1.12
log
@add missing headers needed by time()

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.11 2009/11/05 12:08:41 jsing Exp $	*/
d42 1
a42 1
	struct smtp_client	*sp;
d64 1
a64 2
	if ((cc->sp = client_init(fd, env->sc_hostname)) == NULL)
		goto fail;
d67 1
a67 2
	if (client_ssl_optional(cc->sp) < 0)
		goto fail;
d70 2
a71 3
	if (client_rcpt(cc->sp, "%s@@%s", messagep->sender.user,
	    messagep->sender.domain) < 0)
		goto fail;
d80 1
a80 1
	if (client_data_printf(cc->sp,
d101 1
a101 2
	    reason) < 0)
		goto fail;
d106 1
a106 2
	if (client_data_fd(cc->sp, msgfd) < 0)
		goto fail;
d113 1
a113 1
	event_add(&cc->ev, client_timeout(cc->sp));
d118 2
a119 2
	if (cc && cc->sp)
		client_close(cc->sp);
d128 1
a128 3
	char			*ep = NULL;
	int			 error = 0;
	int			(*iofunc)(struct smtp_client *);
d131 2
a132 6
		message_set_errormsg(&cc->m, "150 timeout");
		cc->m.status = S_MESSAGE_TEMPFAILURE;
		queue_message_update(&cc->m);
		client_close(cc->sp);
		free(cc);
		return;
d135 1
a135 6
	if (event & EV_READ)
		iofunc = client_read;
	else
		iofunc = client_write;

	switch (iofunc(cc->sp)) {
d137 1
a137 3
		event_set(&cc->ev, fd, EV_READ, bounce_event, cc);
		event_add(&cc->ev, client_timeout(cc->sp));
		return;
d139 1
a139 5
		event_set(&cc->ev, fd, EV_WRITE, bounce_event, cc);
		event_add(&cc->ev, client_timeout(cc->sp));
		return;
	case CLIENT_ERROR:
		error = 1;
d141 2
d144 1
d146 2
d150 1
a150 5
	if (error)
		ep = client_strerror(cc->sp);
	else
		ep = client_reply(cc->sp);

d162 1
a162 1
	client_close(cc->sp);
d164 10
@


1.11
log
@Include a Date: header in bounce messages.

ok jacekm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.8 2009/09/15 16:50:06 jacekm Exp $	*/
d33 1
@


1.10
log
@Introduce a 6yz status code, used internally to report permanent errors.
The 1yz and 6yz status codes are now removed prior to reporting the status
message in bounce messages, which provides an easy way to distinguish
between local and remote status messages. Initial diff from jacekm@@

ok gilles@@ jacekm@@
@
text
@d81 1
d86 1
d101 1
@


1.9
log
@Free resources when bounce enqueue fails due to a timeout.
@
text
@d58 1
d75 5
d100 1
a100 1
	    messagep->session_errorline) < 0)
@


1.8
log
@Extend SMTP client_* API to support SSL+AUTH, and use it in the mta
process to relay mails.  ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.7 2009/09/04 18:50:43 jacekm Exp $	*/
d129 1
d131 2
@


1.7
log
@Fix scheduling of bounces that could not be delivered.
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.6 2009/08/27 11:37:30 jacekm Exp $	*/
d64 3
a66 1
	if (client_sender(cc->sp, "") < 0)
a67 1
	cc->m = *messagep;
d76 1
d102 2
d107 2
a108 2
	event_set(&cc->ev, fd, EV_READ, bounce_event, cc);
	event_add(&cc->ev, NULL);
d123 9
a131 2
	char			*ep;
	int			(*iofunc)(struct smtp_client *, char **);
d138 1
a138 1
	switch (iofunc(cc->sp, &ep)) {
d141 1
a141 1
		event_add(&cc->ev, NULL);
d145 1
a145 1
		event_add(&cc->ev, NULL);
d147 3
d151 9
d161 1
a161 3
		break;
	case CLIENT_ERROR:
		message_set_errormsg(&cc->m, "SMTP error: %s", ep);
d166 1
a167 1
		break;
d169 1
@


1.6
log
@Implement client side of the SMTP protocol in a library-like module.
Make bounce code and /usr/sbin/sendmail interface use this new API.
The mta process continues to use its own implementation, but
eventually will be switched to use this shared module.

Buffer routines are taken from buffer.c rather than from evbuffer.
This is one step forward to using a single buffer API across the
program.

"it looks sexy" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.5 2009/08/06 16:26:39 gilles Exp $	*/
d141 5
a145 1
		message_reset_flags(&cc->m);
@


1.5
log
@when writing a bounce, follow the same rule as for mta sessions and prepend
with a dot lines starting with a dot
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.4 2009/08/06 14:27:41 gilles Exp $	*/
d5 1
d36 9
d56 49
a104 24
	char *buf, *lbuf;
	size_t len;
	FILE *fp;
	enum session_state state = S_INIT;

	fp = fdopen(fd, "r+");
	if (fp == NULL)
		goto fail;

	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, "malloc");
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}
		if (! bounce_session_switch(env, fp, &state, buf, messagep))
			goto fail;
	}
	free(lbuf);
a105 1
	fclose(fp);
d108 4
a111 4
	if (fp != NULL)
		fclose(fp);
	else
		close(fd);
d115 2
a116 3
int
bounce_session_switch(struct smtpd *env, FILE *fp, enum session_state *state, char *line,
	struct message *messagep)
d118 3
a120 7
	switch (*state) {
	case S_INIT:
		if (strncmp(line, "220 ", 4) != 0)
			return 0;
		fprintf(fp, "HELO %s\r\n", env->sc_hostname);
		*state = S_GREETED;
		break;
d122 4
a125 3
	case S_GREETED:
		if (strncmp(line, "250 ", 4) != 0)
			return 0;
d127 15
a141 63
		fprintf(fp, "MAIL FROM: <MAILER-DAEMON@@%s>\r\n", env->sc_hostname);
		*state = S_MAIL;
		break;

	case S_MAIL:
		if (strncmp(line, "250 ", 4) != 0)
			return 0;

		fprintf(fp, "RCPT TO: <%s@@%s>\r\n", messagep->sender.user,
			messagep->sender.domain);
		*state = S_RCPT;
		break;

	case S_RCPT:
		if (strncmp(line, "250 ", 4) != 0)
			return 0;

		fprintf(fp, "DATA\r\n");
		*state = S_DATA;
		break;

	case S_DATA: {
		int msgfd;
		FILE *srcfp;

		if (strncmp(line, "354 ", 4) != 0)
			return 0;

		msgfd = queue_open_message_file(messagep->message_id);
		if (msgfd == -1)
			return 0;

		srcfp = fdopen(msgfd, "r");
		if (srcfp == NULL) {
			close(msgfd);
			return 0;
		}

		fprintf(fp, "From: Mailer Daemon <MAILER-DAEMON@@%s>\r\n",
			env->sc_hostname);
		fprintf(fp, "To: %s@@%s\r\n",
			messagep->sender.user, messagep->sender.domain);
		fprintf(fp, "Subject: Delivery attempt failure\r\n");
		fprintf(fp, "\r\n");

		fprintf(fp, "Hi !\r\n");
		fprintf(fp, "This is the MAILER-DAEMON, please DO NOT REPLY to this e-mail.\r\n");
		fprintf(fp, "An error has occurred while attempting to deliver a message.\r\n");
		fprintf(fp, "\r\n");
		fprintf(fp, "Recipient: %s@@%s\r\n", messagep->recipient.user,
			messagep->recipient.domain);
		fprintf(fp, "Reason:\r\n");
		fprintf(fp, "%s\r\n", messagep->session_errorline);

		fprintf(fp, "\r\n");
		fprintf(fp, "Below is a copy of the original message:\r\n\r\n");

		if (! file_copy(fp, srcfp, NULL, 0, 1))
			return 0;

		fprintf(fp, ".\r\n");

		*state = S_DONE;
d144 2
a145 20
	case S_DONE:
		if (strncmp(line, "250 ", 4) != 0)
			return 0;

		fprintf(fp, "QUIT\r\n");
		*state = S_QUIT;
		break;

	case S_QUIT:
		if (strncmp(line, "221 ", 4) != 0)
			return 0;

		break;

	default:
		errx(1, "bounce_session_switch: unknown state.");
	}

	fflush(fp);
	return 1;
@


1.4
log
@factorize file_copy_session() and file_copy() so file_copy() can handle
both deliveries to mailboxes (mbox/maildir) and copying to a session.
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.3 2009/08/06 14:16:37 gilles Exp $	*/
d154 1
a154 1
		if (! file_copy(fp, srcfp, NULL, 0, 1)) {
a155 1
		}
@


1.3
log
@fix a typo in bounce message t -> to
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.2 2009/08/06 14:12:48 gilles Exp $	*/
d154 1
a154 1
		if (! file_copy_session(env, fp, srcfp)) {
@


1.2
log
@- introduce message_set_errormsg() to set the error description that will
  appear in a bounce message, and message_get_errormsg() to retrieve that
  message.
- when loop is detected, call message_set_errormsg()
- in mta, call message_set_errormsg() for each recipient failure
- in mta, call message_set_errormsg() to copy batch errors to recipients if
  we failed to deliver for a session related error
- when bouncing, add the recipient and error reason to the bounce message
@
text
@d1 1
a1 1
/*	$OpenBSD: bounce.c,v 1.1 2009/08/06 13:40:45 gilles Exp $	*/
d143 1
a143 1
		fprintf(fp, "This is the MAILER-DAEMON, please DO NOT REPLY t this e-mail.\r\n");
@


1.1
log
@This commit reworks the entire mailer daemon support to actually make it
work for real. As an added bonus, it simplifies it, makes it follow the
same code path as regular messages and kills quite some code from mta,
mda and store. There's still some work needed but the most painful part
is behind us now ;)

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d145 6
@

