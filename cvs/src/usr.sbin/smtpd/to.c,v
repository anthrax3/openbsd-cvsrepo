head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.2
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.2
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.28
date	2016.05.30.12.33.44;	author mpi;	state Exp;
branches;
next	1.27;
commitid	LgAKRf5OZAa8LRJn;

1.27
date	2016.05.22.11.15.31;	author gilles;	state Exp;
branches;
next	1.26;
commitid	QqypowjXECVFqgtI;

1.26
date	2016.02.15.12.53.50;	author mpi;	state Exp;
branches;
next	1.25;
commitid	Zkj4IbYE7UFC1PIe;

1.25
date	2016.02.14.15.11.10;	author mpi;	state Exp;
branches;
next	1.24;
commitid	g6r8R8tjCiRoF7GG;

1.24
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.23;
commitid	ZxnqOQqX6IeYI9jW;

1.23
date	2015.12.14.10.22.12;	author jung;	state Exp;
branches;
next	1.22;
commitid	HRAnniyhGW9Sadln;

1.22
date	2015.11.30.12.53.08;	author gilles;	state Exp;
branches;
next	1.21;
commitid	w72vQafvsHxL5QKO;

1.21
date	2015.10.28.07.25.30;	author gilles;	state Exp;
branches;
next	1.20;
commitid	t4n4PUOhsPwX6dRm;

1.20
date	2015.10.14.22.01.43;	author gilles;	state Exp;
branches;
next	1.19;
commitid	XSq2zfqNj1sXRZRl;

1.19
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	ZBTFreARDSMmzOIV;

1.18
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2014.04.19.14.27.29;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2014.02.28.08.32.48;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2014.02.04.10.03.32;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2013.11.28.10.43.37;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.28.10.32.17;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.26.20.55.09;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2013.07.19.16.02.00;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.08.06.50.07;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2013.02.15.22.43.21;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2013.02.14.12.30.49;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.26.09.37.24;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Simplify address parsing code by only using inet_net_pton(3).

There's no need to have a separate case for non-CIDR addresses using
inet_pton(3) as inet_net_pton(3) handles them as well.

This simplification is valid for all our daemons parsing addresses,
it is a common patern.

ok gilles@@, millert@@
@
text
@/*	$OpenBSD: to.c,v 1.27 2016/05/22 11:15:31 gilles Exp $	*/

/*
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 * Copyright (c) 2012 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/resource.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <limits.h>
#include <inttypes.h>
#include <libgen.h>
#include <netdb.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

static const char *in6addr_to_text(const struct in6_addr *);
static int alias_is_maildir(struct expandnode *, const char *, size_t);
static int alias_is_filter(struct expandnode *, const char *, size_t);
static int alias_is_username(struct expandnode *, const char *, size_t);
static int alias_is_address(struct expandnode *, const char *, size_t);
static int alias_is_filename(struct expandnode *, const char *, size_t);
static int alias_is_include(struct expandnode *, const char *, size_t);
static int alias_is_error(struct expandnode *, const char *, size_t);

const char *
sockaddr_to_text(struct sockaddr *sa)
{
	static char	buf[NI_MAXHOST];

	if (getnameinfo(sa, sa->sa_len, buf, sizeof(buf), NULL, 0,
	    NI_NUMERICHOST))
		return ("(unknown)");
	else
		return (buf);
}

static const char *
in6addr_to_text(const struct in6_addr *addr)
{
	struct sockaddr_in6	sa_in6;
	uint16_t		tmp16;

	memset(&sa_in6, 0, sizeof(sa_in6));
	sa_in6.sin6_len = sizeof(sa_in6);
	sa_in6.sin6_family = AF_INET6;
	memcpy(&sa_in6.sin6_addr, addr, sizeof(sa_in6.sin6_addr));

	/* XXX thanks, KAME, for this ugliness... adopted from route/show.c */
	if (IN6_IS_ADDR_LINKLOCAL(&sa_in6.sin6_addr) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&sa_in6.sin6_addr)) {
		memcpy(&tmp16, &sa_in6.sin6_addr.s6_addr[2], sizeof(tmp16));
		sa_in6.sin6_scope_id = ntohs(tmp16);
		sa_in6.sin6_addr.s6_addr[2] = 0;
		sa_in6.sin6_addr.s6_addr[3] = 0;
	}

	return (sockaddr_to_text((struct sockaddr *)&sa_in6));
}

int
text_to_mailaddr(struct mailaddr *maddr, const char *email)
{
	char *username;
	char *hostname;
	char  buffer[LINE_MAX];

	if (strlcpy(buffer, email, sizeof buffer) >= sizeof buffer)
		return 0;

	memset(maddr, 0, sizeof *maddr);

	username = buffer;
	hostname = strrchr(username, '@@');

	if (hostname == NULL) {
		if (strlcpy(maddr->user, username, sizeof maddr->user)
		    >= sizeof maddr->user)
			return 0;
	}
	else if (username == hostname) {
		*hostname++ = '\0';
		if (strlcpy(maddr->domain, hostname, sizeof maddr->domain)
		    >= sizeof maddr->domain)
			return 0;
	}
	else {
		*hostname++ = '\0';
		if (strlcpy(maddr->user, username, sizeof maddr->user)
		    >= sizeof maddr->user)
			return 0;
		if (strlcpy(maddr->domain, hostname, sizeof maddr->domain)
		    >= sizeof maddr->domain)
			return 0;
	}

	return 1;
}

const char *
mailaddr_to_text(const struct mailaddr *maddr)
{
	static char  buffer[LINE_MAX];

	(void)strlcpy(buffer, maddr->user, sizeof buffer);
	(void)strlcat(buffer, "@@", sizeof buffer);
	if (strlcat(buffer, maddr->domain, sizeof buffer) >= sizeof buffer)
		return NULL;

	return buffer;
}


const char *
sa_to_text(const struct sockaddr *sa)
{
	static char	 buf[NI_MAXHOST + 5];
	char		*p;

	buf[0] = '\0';
	p = buf;

	if (sa->sa_family == AF_LOCAL)
		(void)strlcpy(buf, "local", sizeof buf);
	else if (sa->sa_family == AF_INET) {
		in_addr_t addr;

		addr = ((const struct sockaddr_in *)sa)->sin_addr.s_addr;
		addr = ntohl(addr);
		(void)bsnprintf(p, NI_MAXHOST, "%d.%d.%d.%d",
		    (addr >> 24) & 0xff, (addr >> 16) & 0xff,
		    (addr >> 8) & 0xff, addr & 0xff);
	}
	else if (sa->sa_family == AF_INET6) {
		const struct sockaddr_in6 *in6;
		const struct in6_addr	*in6_addr;

		in6 = (const struct sockaddr_in6 *)sa;
		(void)strlcpy(buf, "IPv6:", sizeof(buf));
		p = buf + 5;
		in6_addr = &in6->sin6_addr;
		(void)bsnprintf(p, NI_MAXHOST, "%s", in6addr_to_text(in6_addr));
	}

	return (buf);
}

const char *
ss_to_text(const struct sockaddr_storage *ss)
{
	return (sa_to_text((const struct sockaddr*)ss));
}

const char *
time_to_text(time_t when)
{
	struct tm *lt;
	static char buf[40];
	char *day[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	char *month[] = {"Jan","Feb","Mar","Apr","May","Jun",
			 "Jul","Aug","Sep","Oct","Nov","Dec"};
	char *tz;
	long offset;

	lt = localtime(&when);
	if (lt == NULL || when == 0)
		fatalx("time_to_text: localtime");

	offset = lt->tm_gmtoff;
	tz = lt->tm_zone;

	/* We do not use strftime because it is subject to locale substitution*/
	if (!bsnprintf(buf, sizeof(buf),
	    "%s, %d %s %d %02d:%02d:%02d %c%02d%02d (%s)",
	    day[lt->tm_wday], lt->tm_mday, month[lt->tm_mon],
	    lt->tm_year + 1900,
	    lt->tm_hour, lt->tm_min, lt->tm_sec,
	    offset >= 0 ? '+' : '-',
	    abs((int)offset / 3600),
	    abs((int)offset % 3600) / 60,
	    tz))
		fatalx("time_to_text: bsnprintf");

	return buf;
}

const char *
duration_to_text(time_t t)
{
	static char	dst[64];
	char		buf[64];
	int		h, m, s;
	long long	d;

	if (t == 0) {
		(void)strlcpy(dst, "0s", sizeof dst);
		return (dst);
	}

	dst[0] = '\0';
	if (t < 0) {
		(void)strlcpy(dst, "-", sizeof dst);
		t = -t;
	}

	s = t % 60;
	t /= 60;
	m = t % 60;
	t /= 60;
	h = t % 24;
	d = t / 24;

	if (d) {
		(void)snprintf(buf, sizeof buf, "%lldd", d);
		(void)strlcat(dst, buf, sizeof dst);
	}
	if (h) {
		(void)snprintf(buf, sizeof buf, "%dh", h);
		(void)strlcat(dst, buf, sizeof dst);
	}
	if (m) {
		(void)snprintf(buf, sizeof buf, "%dm", m);
		(void)strlcat(dst, buf, sizeof dst);
	}
	if (s) {
		(void)snprintf(buf, sizeof buf, "%ds", s);
		(void)strlcat(dst, buf, sizeof dst);
	}

	return (dst);
}

int
text_to_netaddr(struct netaddr *netaddr, const char *s)
{
	struct sockaddr_storage	ss;
	struct sockaddr_in	ssin;
	struct sockaddr_in6	ssin6;
	int			bits;

	memset(&ssin, 0, sizeof(struct sockaddr_in));
	memset(&ssin6, 0, sizeof(struct sockaddr_in6));

	if (strncasecmp("IPv6:", s, 5) == 0)
		s += 5;

	bits = inet_net_pton(AF_INET, s, &ssin.sin_addr,
	    sizeof(struct in_addr));
	if (bits != -1) {
		ssin.sin_family = AF_INET;
		memcpy(&ss, &ssin, sizeof(ssin));
		ss.ss_len = sizeof(struct sockaddr_in);
	} else {
		bits = inet_net_pton(AF_INET6, s, &ssin6.sin6_addr,
		    sizeof(struct in6_addr));
		if (bits == -1)
			return 0;
		ssin6.sin6_family = AF_INET6;
		memcpy(&ss, &ssin6, sizeof(ssin6));
		ss.ss_len = sizeof(struct sockaddr_in6);
	}

	netaddr->ss   = ss;
	netaddr->bits = bits;
	return 1;
}

int
text_to_relayhost(struct relayhost *relay, const char *s)
{
	static const struct schema {
		const char	*name;
		uint16_t       	 flags;
	} schemas [] = {
		/*
		 * new schemas should be *appended* otherwise the default
		 * schema index needs to be updated later in this function.
		 */
		{ "smtp://",		0				},
		{ "lmtp://",		F_LMTP				},
		{ "smtp+tls://",       	F_TLS_OPTIONAL 			},
		{ "smtps://",		F_SMTPS				},
		{ "tls://",		F_STARTTLS			},
		{ "smtps+auth://",	F_SMTPS|F_AUTH			},
		{ "tls+auth://",	F_STARTTLS|F_AUTH		},
		{ "secure://",		F_SMTPS|F_STARTTLS		},
		{ "secure+auth://",	F_SMTPS|F_STARTTLS|F_AUTH	},
		{ "backup://",		F_BACKUP       			},
		{ "tls+backup://",	F_BACKUP|F_STARTTLS    		}
	};
	const char     *errstr = NULL;
	char	       *p, *q;
	char		buffer[1024];
	char	       *beg, *end;
	size_t		i;
	size_t		len;

	memset(buffer, 0, sizeof buffer);
	if (strlcpy(buffer, s, sizeof buffer) >= sizeof buffer)
		return 0;

	for (i = 0; i < nitems(schemas); ++i)
		if (strncasecmp(schemas[i].name, s,
		    strlen(schemas[i].name)) == 0)
			break;

	if (i == nitems(schemas)) {
		/* there is a schema, but it's not recognized */
		if (strstr(buffer, "://"))
			return 0;

		/* no schema, default to smtp+tls:// */
		i = 2;
		p = buffer;
	}
	else
		p = buffer + strlen(schemas[i].name);

	relay->flags = schemas[i].flags;

	/* need to specify an explicit port for LMTP */
	if (relay->flags & F_LMTP)
		relay->port = 0;

	/* first, we extract the label if any */
	if ((q = strchr(p, '@@')) != NULL) {
		*q = 0;
		if (strlcpy(relay->authlabel, p, sizeof (relay->authlabel))
		    >= sizeof (relay->authlabel))
			return 0;
		p = q + 1;
	}

	/* then, we extract the mail exchanger */
	beg = end = p;
	if (*beg == '[') {
		if ((end = strchr(beg, ']')) == NULL)
			return 0;
		/* skip ']', it has to be included in the relay hostname */
		++end;
		len = end - beg;
	}
	else {
		for (end = beg; *end; ++end)
			if (!isalnum((unsigned char)*end) &&
			    *end != '_' && *end != '.' && *end != '-')
				break;
		len = end - beg;
	}
	if (len >= sizeof relay->hostname)
		return 0;
	for (i = 0; i < len; ++i)
		relay->hostname[i] = beg[i];
	relay->hostname[i] = 0;

	/* finally, we extract the port */
	p = beg + len;
	if (*p == ':') {
		relay->port = strtonum(p+1, 1, 0xffff, &errstr);
		if (errstr)
			return 0;
	}

	if (!valid_domainpart(relay->hostname))
		return 0;
	if ((relay->flags & F_LMTP) && (relay->port == 0))
		return 0;
	if (relay->authlabel[0] == '\0' && relay->flags & F_AUTH)
		return 0;
	if (relay->authlabel[0] != '\0' && !(relay->flags & F_AUTH))
		return 0;
	return 1;
}

const char *
relayhost_to_text(const struct relayhost *relay)
{
	static char	buf[4096];
	char		port[4096];
	uint16_t	mask = F_SMTPS|F_STARTTLS|F_AUTH|F_TLS_OPTIONAL|F_LMTP|F_BACKUP;

	memset(buf, 0, sizeof buf);
	switch (relay->flags & mask) {
	case F_SMTPS|F_STARTTLS|F_AUTH:
		(void)strlcat(buf, "secure+auth://", sizeof buf);
		break;
	case F_SMTPS|F_STARTTLS:
		(void)strlcat(buf, "secure://", sizeof buf);
		break;
	case F_STARTTLS|F_AUTH:
		(void)strlcat(buf, "tls+auth://", sizeof buf);
		break;
	case F_SMTPS|F_AUTH:
		(void)strlcat(buf, "smtps+auth://", sizeof buf);
		break;
	case F_STARTTLS:
		(void)strlcat(buf, "tls://", sizeof buf);
		break;
	case F_SMTPS:
		(void)strlcat(buf, "smtps://", sizeof buf);
		break;
	case F_BACKUP|F_STARTTLS:
		(void)strlcat(buf, "tls+backup://", sizeof buf);
		break;
	case F_BACKUP:
		(void)strlcat(buf, "backup://", sizeof buf);
		break;
	case F_TLS_OPTIONAL:
		(void)strlcat(buf, "smtp+tls://", sizeof buf);
		break;
	case F_LMTP:
		(void)strlcat(buf, "lmtp://", sizeof buf);
		break;
	default:
		(void)strlcat(buf, "smtp://", sizeof buf);
		break;
	}
	if (relay->authlabel[0]) {
		(void)strlcat(buf, relay->authlabel, sizeof buf);
		(void)strlcat(buf, "@@", sizeof buf);
	}
	(void)strlcat(buf, relay->hostname, sizeof buf);
	if (relay->port) {
		(void)strlcat(buf, ":", sizeof buf);
		(void)snprintf(port, sizeof port, "%d", relay->port);
		(void)strlcat(buf, port, sizeof buf);
	}
	return buf;
}

uint64_t
text_to_evpid(const char *s)
{
	uint64_t ulval;
	char	 *ep;

	errno = 0;
	ulval = strtoull(s, &ep, 16);
	if (s[0] == '\0' || *ep != '\0')
		return 0;
	if (errno == ERANGE && ulval == ULLONG_MAX)
		return 0;
	if (ulval == 0)
		return 0;
	return (ulval);
}

uint32_t
text_to_msgid(const char *s)
{
	uint64_t ulval;
	char	 *ep;

	errno = 0;
	ulval = strtoull(s, &ep, 16);
	if (s[0] == '\0' || *ep != '\0')
		return 0;
	if (errno == ERANGE && ulval == ULLONG_MAX)
		return 0;
	if (ulval == 0)
		return 0;
	if (ulval > 0xffffffff)
		return 0;
	return (ulval & 0xffffffff);
}

const char *
rule_to_text(struct rule *r)
{
	static char buf[4096];

	memset(buf, 0, sizeof buf);
	(void)strlcpy(buf, r->r_decision == R_ACCEPT  ? "accept" : "reject", sizeof buf);
	if (r->r_tag[0]) {
		(void)strlcat(buf, " tagged ", sizeof buf);
		if (r->r_nottag)
			(void)strlcat(buf, "! ", sizeof buf);
		(void)strlcat(buf, r->r_tag, sizeof buf);
	}
	(void)strlcat(buf, " from ", sizeof buf);
	if (r->r_notsources)
		(void)strlcat(buf, "! ", sizeof buf);
	(void)strlcat(buf, r->r_sources->t_name, sizeof buf);

	(void)strlcat(buf, " for ", sizeof buf);
	if (r->r_notdestination)
		(void)strlcat(buf, "! ", sizeof buf);
	switch (r->r_desttype) {
	case DEST_DOM:
		if (r->r_destination == NULL) {
			(void)strlcat(buf, " any", sizeof buf);
			break;
		}
		(void)strlcat(buf, " domain ", sizeof buf);
		(void)strlcat(buf, r->r_destination->t_name, sizeof buf);
		if (r->r_mapping) {
			(void)strlcat(buf, " alias ", sizeof buf);
			(void)strlcat(buf, r->r_mapping->t_name, sizeof buf);
		}
		break;
	case DEST_VDOM:
		if (r->r_destination == NULL) {
			(void)strlcat(buf, " any virtual ", sizeof buf);
			(void)strlcat(buf, r->r_mapping->t_name, sizeof buf);
			break;
		}
		(void)strlcat(buf, " domain ", sizeof buf);
		(void)strlcat(buf, r->r_destination->t_name, sizeof buf);
		(void)strlcat(buf, " virtual ", sizeof buf);
		(void)strlcat(buf, r->r_mapping->t_name, sizeof buf);
		break;
	}

	switch (r->r_action) {
	case A_RELAY:
		(void)strlcat(buf, " relay", sizeof buf);
		break;
	case A_RELAYVIA:
		(void)strlcat(buf, " relay via ", sizeof buf);
		(void)strlcat(buf, relayhost_to_text(&r->r_value.relayhost), sizeof buf);
		break;
	case A_MAILDIR:
		(void)strlcat(buf, " deliver to maildir \"", sizeof buf);
		(void)strlcat(buf, r->r_value.buffer, sizeof buf);
		(void)strlcat(buf, "\"", sizeof buf);
		break;
	case A_MBOX:
		(void)strlcat(buf, " deliver to mbox", sizeof buf);
		break;
	case A_FILENAME:
		(void)strlcat(buf, " deliver to filename \"", sizeof buf);
		(void)strlcat(buf, r->r_value.buffer, sizeof buf);
		(void)strlcat(buf, "\"", sizeof buf);
		break;
	case A_MDA:
		(void)strlcat(buf, " deliver to mda \"", sizeof buf);
		(void)strlcat(buf, r->r_value.buffer, sizeof buf);
		(void)strlcat(buf, "\"", sizeof buf);
		break;
	case A_LMTP:
		(void)strlcat(buf, " deliver to lmtp \"", sizeof buf);
		(void)strlcat(buf, r->r_value.buffer, sizeof buf);
		(void)strlcat(buf, "\"", sizeof buf);
		break;
	case A_NONE:
		break;
	}

	return buf;
}

int
text_to_userinfo(struct userinfo *userinfo, const char *s)
{
	char		buf[PATH_MAX];
	char	       *p;
	const char     *errstr;

	memset(buf, 0, sizeof buf);
	p = buf;
	while (*s && *s != ':')
		*p++ = *s++;
	if (*s++ != ':')
		goto error;

	if (strlcpy(userinfo->username, buf,
		sizeof userinfo->username) >= sizeof userinfo->username)
		goto error;

	memset(buf, 0, sizeof buf);
	p = buf;
	while (*s && *s != ':')
		*p++ = *s++;
	if (*s++ != ':')
		goto error;
	userinfo->uid = strtonum(buf, 0, UID_MAX, &errstr);
	if (errstr)
		goto error;

	memset(buf, 0, sizeof buf);
	p = buf;
	while (*s && *s != ':')
		*p++ = *s++;
	if (*s++ != ':')
		goto error;
	userinfo->gid = strtonum(buf, 0, GID_MAX, &errstr);
	if (errstr)
		goto error;

	if (strlcpy(userinfo->directory, s,
		sizeof userinfo->directory) >= sizeof userinfo->directory)
		goto error;

	return 1;

error:
	return 0;
}

int
text_to_credentials(struct credentials *creds, const char *s)
{
	char   *p;
	char	buffer[LINE_MAX];
	size_t	offset;

	p = strchr(s, ':');
	if (p == NULL) {
		creds->username[0] = '\0';
		if (strlcpy(creds->password, s, sizeof creds->password)
		    >= sizeof creds->password)
			return 0;
		return 1;
	}

	offset = p - s;

	memset(buffer, 0, sizeof buffer);
	if (strlcpy(buffer, s, sizeof buffer) >= sizeof buffer)
		return 0;
	p = buffer + offset;
	*p = '\0';

	if (strlcpy(creds->username, buffer, sizeof creds->username)
	    >= sizeof creds->username)
		return 0;
	if (strlcpy(creds->password, p+1, sizeof creds->password)
	    >= sizeof creds->password)
		return 0;

	return 1;
}

int
text_to_expandnode(struct expandnode *expandnode, const char *s)
{
	size_t	l;

	l = strlen(s);
	if (alias_is_error(expandnode, s, l) ||
	    alias_is_include(expandnode, s, l) ||
	    alias_is_filter(expandnode, s, l) ||
	    alias_is_filename(expandnode, s, l) ||
	    alias_is_address(expandnode, s, l) ||
	    alias_is_maildir(expandnode, s, l) ||
	    alias_is_username(expandnode, s, l))
		return (1);

	return (0);
}

const char *
expandnode_to_text(struct expandnode *expandnode)
{
	switch (expandnode->type) {
	case EXPAND_FILTER:
	case EXPAND_FILENAME:
	case EXPAND_INCLUDE:
	case EXPAND_ERROR:
	case EXPAND_MAILDIR:
		return expandnode->u.buffer;
	case EXPAND_USERNAME:
		return expandnode->u.user;
	case EXPAND_ADDRESS:
		return mailaddr_to_text(&expandnode->u.mailaddr);
	case EXPAND_INVALID:
		break;
	}

	return NULL;
}

static int
alias_is_maildir(struct expandnode *alias, const char *line, size_t len)
{
	if (strncasecmp("maildir:", line, 8) != 0)
		return (0);

	line += 8;
	memset(alias, 0, sizeof *alias);
	alias->type = EXPAND_MAILDIR;
	if (strlcpy(alias->u.buffer, line,
	    sizeof(alias->u.buffer)) >= sizeof(alias->u.buffer))
		return (0);

	return (1);
}

/******/
static int
alias_is_filter(struct expandnode *alias, const char *line, size_t len)
{
	int	v = 0;

	if (*line == '"')
		v = 1;
	if (*(line+v) == '|') {
		if (strlcpy(alias->u.buffer, line + v + 1,
		    sizeof(alias->u.buffer)) >= sizeof(alias->u.buffer))
			return 0;
		if (v) {
			v = strlen(alias->u.buffer);
			if (v == 0)
				return (0);
			if (alias->u.buffer[v-1] != '"')
				return (0);
			alias->u.buffer[v-1] = '\0';
		}
		alias->type = EXPAND_FILTER;
		return (1);
	}
	return (0);
}

static int
alias_is_username(struct expandnode *alias, const char *line, size_t len)
{
	memset(alias, 0, sizeof *alias);

	if (strlcpy(alias->u.user, line,
	    sizeof(alias->u.user)) >= sizeof(alias->u.user))
		return 0;

	while (*line) {
		if (!isalnum((unsigned char)*line) &&
		    *line != '_' && *line != '.' && *line != '-' && *line != '+')
			return 0;
		++line;
	}

	alias->type = EXPAND_USERNAME;
	return 1;
}

static int
alias_is_address(struct expandnode *alias, const char *line, size_t len)
{
	char *domain;

	memset(alias, 0, sizeof *alias);

	if (len < 3)	/* x@@y */
		return 0;

	domain = strchr(line, '@@');
	if (domain == NULL)
		return 0;

	/* @@ cannot start or end an address */
	if (domain == line || domain == line + len - 1)
		return 0;

	/* scan pre @@ for disallowed chars */
	*domain++ = '\0';
	(void)strlcpy(alias->u.mailaddr.user, line, sizeof(alias->u.mailaddr.user));
	(void)strlcpy(alias->u.mailaddr.domain, domain,
	    sizeof(alias->u.mailaddr.domain));

	while (*line) {
		char allowedset[] = "!#$%*/?|^{}`~&'+-=_.";
		if (!isalnum((unsigned char)*line) &&
		    strchr(allowedset, *line) == NULL)
			return 0;
		++line;
	}

	while (*domain) {
		char allowedset[] = "-.";
		if (!isalnum((unsigned char)*domain) &&
		    strchr(allowedset, *domain) == NULL)
			return 0;
		++domain;
	}

	alias->type = EXPAND_ADDRESS;
	return 1;
}

static int
alias_is_filename(struct expandnode *alias, const char *line, size_t len)
{
	memset(alias, 0, sizeof *alias);

	if (*line != '/')
		return 0;

	if (strlcpy(alias->u.buffer, line,
	    sizeof(alias->u.buffer)) >= sizeof(alias->u.buffer))
		return 0;
	alias->type = EXPAND_FILENAME;
	return 1;
}

static int
alias_is_include(struct expandnode *alias, const char *line, size_t len)
{
	size_t skip;

	memset(alias, 0, sizeof *alias);

	if (strncasecmp(":include:", line, 9) == 0)
		skip = 9;
	else if (strncasecmp("include:", line, 8) == 0)
		skip = 8;
	else
		return 0;

	if (!alias_is_filename(alias, line + skip, len - skip))
		return 0;

	alias->type = EXPAND_INCLUDE;
	return 1;
}

static int
alias_is_error(struct expandnode *alias, const char *line, size_t len)
{
	size_t	skip;

	memset(alias, 0, sizeof *alias);

	if (strncasecmp(":error:", line, 7) == 0)
		skip = 7;
	else if (strncasecmp("error:", line, 6) == 0)
		skip = 6;
	else
		return 0;

	if (strlcpy(alias->u.buffer, line + skip,
	    sizeof(alias->u.buffer)) >= sizeof(alias->u.buffer))
		return 0;

	if (strlen(alias->u.buffer) < 5)
		return 0;

	/* [45][0-9]{2} [a-zA-Z0-9].* */
	if (alias->u.buffer[3] != ' ' ||
	    !isalnum((unsigned char)alias->u.buffer[4]) ||
	    (alias->u.buffer[0] != '4' && alias->u.buffer[0] != '5') ||
	    !isdigit((unsigned char)alias->u.buffer[1]) ||
	    !isdigit((unsigned char)alias->u.buffer[2]))
		return 0;

	alias->type = EXPAND_ERROR;
	return 1;
}
@


1.27
log
@use temporary variables to store some struct tm values, no functional
change but reduces the changeset with portable version
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.26 2016/02/15 12:53:50 mpi Exp $	*/
d282 14
a295 36
	if (strchr(s, '/') != NULL) {
		/* dealing with netmask */
		bits = inet_net_pton(AF_INET, s, &ssin.sin_addr,
		    sizeof(struct in_addr));
		if (bits != -1) {
			ssin.sin_family = AF_INET;
			memcpy(&ss, &ssin, sizeof(ssin));
			ss.ss_len = sizeof(struct sockaddr_in);
		}
		else {
			bits = inet_net_pton(AF_INET6, s, &ssin6.sin6_addr,
			    sizeof(struct in6_addr));
			if (bits == -1) {
				log_warn("warn: inet_net_pton");
				return 0;
			}
			ssin6.sin6_family = AF_INET6;
			memcpy(&ss, &ssin6, sizeof(ssin6));
			ss.ss_len = sizeof(struct sockaddr_in6);
		}
	}
	else {
		/* IP address ? */
		if (inet_pton(AF_INET, s, &ssin.sin_addr) == 1) {
			ssin.sin_family = AF_INET;
			bits = 32;
			memcpy(&ss, &ssin, sizeof(ssin));
			ss.ss_len = sizeof(struct sockaddr_in);
		}
		else if (inet_pton(AF_INET6, s, &ssin6.sin6_addr) == 1) {
			ssin6.sin6_family = AF_INET6;
			bits = 128;
			memcpy(&ss, &ssin6, sizeof(ssin6));
			ss.ss_len = sizeof(struct sockaddr_in6);
		}
		else return 0;
@


1.26
log
@Revert previous, semarie@@ found a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.25 2016/02/14 15:11:10 mpi Exp $	*/
d197 2
d204 3
d213 4
a216 4
	    lt->tm_gmtoff >= 0 ? '+' : '-',
	    abs((int)lt->tm_gmtoff / 3600),
	    abs((int)lt->tm_gmtoff % 3600) / 60,
	    lt->tm_zone))
@


1.25
log
@Simplify address parsing code by only using inet_net_pton(3).

There's no need to have a separate case for non-CIDR addresses using
inet_pton(3) as inet_net_pton(3) handles them as well.

This simplification is valid for all our daemons parsing addresses,
it is a common patern.

ok gilles@@, millert@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.24 2015/12/28 22:08:30 jung Exp $	*/
d277 20
a296 6
	bits = inet_net_pton(AF_INET, s, &ssin.sin_addr,
	    sizeof(struct in_addr));
	if (bits != -1) {
		ssin.sin_family = AF_INET;
		memcpy(&ss, &ssin, sizeof(ssin));
		ss.ss_len = sizeof(struct sockaddr_in);
d299 12
a310 5
		bits = inet_net_pton(AF_INET6, s, &ssin6.sin6_addr,
		    sizeof(struct in6_addr));
		if (bits == -1) {
			log_warn("warn: inet_net_pton");
			return 0;
d312 1
a312 3
		ssin6.sin6_family = AF_INET6;
		memcpy(&ss, &ssin6, sizeof(ssin6));
		ss.ss_len = sizeof(struct sockaddr_in6);
@


1.24
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.23 2015/12/14 10:22:12 jung Exp $	*/
d277 6
a282 20
	if (strchr(s, '/') != NULL) {
		/* dealing with netmask */
		bits = inet_net_pton(AF_INET, s, &ssin.sin_addr,
		    sizeof(struct in_addr));
		if (bits != -1) {
			ssin.sin_family = AF_INET;
			memcpy(&ss, &ssin, sizeof(ssin));
			ss.ss_len = sizeof(struct sockaddr_in);
		}
		else {
			bits = inet_net_pton(AF_INET6, s, &ssin6.sin6_addr,
			    sizeof(struct in6_addr));
			if (bits == -1) {
				log_warn("warn: inet_net_pton");
				return 0;
			}
			ssin6.sin6_family = AF_INET6;
			memcpy(&ss, &ssin6, sizeof(ssin6));
			ss.ss_len = sizeof(struct sockaddr_in6);
		}
d285 5
a289 12
		/* IP address ? */
		if (inet_pton(AF_INET, s, &ssin.sin_addr) == 1) {
			ssin.sin_family = AF_INET;
			bits = 32;
			memcpy(&ss, &ssin, sizeof(ssin));
			ss.ss_len = sizeof(struct sockaddr_in);
		}
		else if (inet_pton(AF_INET6, s, &ssin6.sin6_addr) == 1) {
			ssin6.sin6_family = AF_INET6;
			bits = 128;
			memcpy(&ss, &ssin6, sizeof(ssin6));
			ss.ss_len = sizeof(struct sockaddr_in6);
d291 3
a293 1
		else return 0;
@


1.23
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.22 2015/11/30 12:53:08 gilles Exp $	*/
d203 1
a203 1
	if (! bsnprintf(buf, sizeof(buf),
d397 1
a397 1
			if (! isalnum((unsigned char)*end) &&
d416 1
a416 1
	if (! valid_domainpart(relay->hostname))
d860 1
a860 1
	if (! alias_is_filename(alias, line + skip, len - skip))
@


1.22
log
@update to.c to fix IPv6 address parsing in smtpd.conf, while at it allow
use of tls+backup:// schema for relaying over TLS to primary MX

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.17 2014/04/19 14:27:29 gilles Exp $	*/
d130 1
a130 1
	}	
@


1.21
log
@aliases support resolving to maildir:/path

ok sunil@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.20 2015/10/14 22:01:43 gilles Exp $	*/
a35 1
#include <fts.h>
d340 2
a341 1
		{ "backup://",		F_BACKUP       			}
d346 1
a346 1
	char	       *sep;
d348 1
a348 1
	int		len;
d377 35
a411 3
	if ((sep = strrchr(p, ':')) != NULL) {
		*sep = 0;
		relay->port = strtonum(sep+1, 1, 0xffff, &errstr);
a413 1
		len = sep - p;
a414 2
	else
		len = strlen(p);
d416 2
d420 1
a420 5

	relay->hostname[len] = 0;

	q = strchr(p, '@@');
	if (q == NULL && relay->flags & F_AUTH)
d422 1
a422 1
	if (q && !(relay->flags & F_AUTH))
a423 14

	if (q == NULL) {
		if (strlcpy(relay->hostname, p, sizeof (relay->hostname))
		    >= sizeof (relay->hostname))
			return 0;
	} else {
		*q = 0;
		if (strlcpy(relay->authlabel, p, sizeof (relay->authlabel))
		    >= sizeof (relay->authlabel))
			return 0;
		if (strlcpy(relay->hostname, q + 1, sizeof (relay->hostname))
		    >= sizeof (relay->hostname))
			return 0;
	}
d454 3
a724 2

/******/
d735 1
a735 1
		sizeof(alias->u.buffer)) >= sizeof(alias->u.buffer))
d741 1
d778 1
a778 1
		    *line != '_' && *line != '.' && *line != '-')
@


1.20
log
@whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.19 2015/01/20 17:37:54 deraadt Exp $	*/
d54 1
d681 1
d696 1
d711 16
@


1.19
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.18 2015/01/16 06:40:21 deraadt Exp $	*/
d583 1
a583 1
	    
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.17 2014/04/19 14:27:29 gilles Exp $	*/
d101 1
a101 1
	char  buffer[SMTPD_MAXLINESIZE];
d138 1
a138 1
	static char  buffer[SMTPD_MAXLINESIZE];
d590 1
a590 1
	char		buf[SMTPD_MAXPATHLEN];
d639 1
a639 1
	char	buffer[SMTPD_MAXLINESIZE];
@


1.17
log
@(void) cast strlcpy/strlcat/snprintf calls that cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.16 2014/02/28 08:32:48 gilles Exp $	*/
d38 1
@


1.16
log
@do not miss out F_BACKUP when dumping envelope or it breaks backup MX

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.15 2014/02/04 10:03:32 eric Exp $	*/
d139 2
a140 2
	strlcpy(buffer, maddr->user, sizeof buffer);
	strlcat(buffer, "@@", sizeof buffer);
d158 1
a158 1
		strlcpy(buf, "local", sizeof buf);
d164 1
a164 1
		bsnprintf(p, NI_MAXHOST, "%d.%d.%d.%d",
d173 1
a173 1
		strlcpy(buf, "IPv6:", sizeof(buf));
d176 1
a176 1
		bsnprintf(p, NI_MAXHOST, "%s", in6addr_to_text(in6_addr));
d225 1
a225 1
		strlcpy(dst, "0s", sizeof dst);
d231 1
a231 1
		strlcpy(dst, "-", sizeof dst);
d243 2
a244 2
		snprintf(buf, sizeof buf, "%lldd", d);
		strlcat(dst, buf, sizeof dst);
d247 2
a248 2
		snprintf(buf, sizeof buf, "%dh", h);
		strlcat(dst, buf, sizeof dst);
d251 2
a252 2
		snprintf(buf, sizeof buf, "%dm", m);
		strlcat(dst, buf, sizeof dst);
d255 2
a256 2
		snprintf(buf, sizeof buf, "%ds", s);
		strlcat(dst, buf, sizeof dst);
d422 1
a422 1
		strlcat(buf, "secure+auth://", sizeof buf);
d425 1
a425 1
		strlcat(buf, "secure://", sizeof buf);
d428 1
a428 1
		strlcat(buf, "tls+auth://", sizeof buf);
d431 1
a431 1
		strlcat(buf, "smtps+auth://", sizeof buf);
d434 1
a434 1
		strlcat(buf, "tls://", sizeof buf);
d437 1
a437 1
		strlcat(buf, "smtps://", sizeof buf);
d440 1
a440 1
		strlcat(buf, "backup://", sizeof buf);
d443 1
a443 1
		strlcat(buf, "smtp+tls://", sizeof buf);
d446 1
a446 1
		strlcat(buf, "lmtp://", sizeof buf);
d449 1
a449 1
		strlcat(buf, "smtp://", sizeof buf);
d453 2
a454 2
		strlcat(buf, relay->authlabel, sizeof buf);
		strlcat(buf, "@@", sizeof buf);
d456 1
a456 1
	strlcat(buf, relay->hostname, sizeof buf);
d458 3
a460 3
		strlcat(buf, ":", sizeof buf);
		snprintf(port, sizeof port, "%d", relay->port);
		strlcat(buf, port, sizeof buf);
d507 1
a507 1
	strlcpy(buf, r->r_decision == R_ACCEPT  ? "accept" : "reject", sizeof buf);
d509 1
a509 1
		strlcat(buf, " tagged ", sizeof buf);
d511 2
a512 2
			strlcat(buf, "! ", sizeof buf);
		strlcat(buf, r->r_tag, sizeof buf);
d514 1
a514 1
	strlcat(buf, " from ", sizeof buf);
d516 2
a517 2
		strlcat(buf, "! ", sizeof buf);
	strlcat(buf, r->r_sources->t_name, sizeof buf);
d519 1
a519 1
	strlcat(buf, " for ", sizeof buf);
d521 1
a521 1
		strlcat(buf, "! ", sizeof buf);
d525 1
a525 1
			strlcat(buf, " any", sizeof buf);
d528 2
a529 2
		strlcat(buf, " domain ", sizeof buf);
		strlcat(buf, r->r_destination->t_name, sizeof buf);
d531 2
a532 2
			strlcat(buf, " alias ", sizeof buf);
			strlcat(buf, r->r_mapping->t_name, sizeof buf);
d537 2
a538 2
			strlcat(buf, " any virtual ", sizeof buf);
			strlcat(buf, r->r_mapping->t_name, sizeof buf);
d541 4
a544 4
		strlcat(buf, " domain ", sizeof buf);
		strlcat(buf, r->r_destination->t_name, sizeof buf);
		strlcat(buf, " virtual ", sizeof buf);
		strlcat(buf, r->r_mapping->t_name, sizeof buf);
d550 1
a550 1
		strlcat(buf, " relay", sizeof buf);
d553 2
a554 2
		strlcat(buf, " relay via ", sizeof buf);
		strlcat(buf, relayhost_to_text(&r->r_value.relayhost), sizeof buf);
d557 3
a559 3
		strlcat(buf, " deliver to maildir \"", sizeof buf);
		strlcat(buf, r->r_value.buffer, sizeof buf);
		strlcat(buf, "\"", sizeof buf);
d562 1
a562 1
		strlcat(buf, " deliver to mbox", sizeof buf);
d565 3
a567 3
		strlcat(buf, " deliver to filename \"", sizeof buf);
		strlcat(buf, r->r_value.buffer, sizeof buf);
		strlcat(buf, "\"", sizeof buf);
d570 3
a572 3
		strlcat(buf, " deliver to mda \"", sizeof buf);
		strlcat(buf, r->r_value.buffer, sizeof buf);
		strlcat(buf, "\"", sizeof buf);
d575 3
a577 3
		strlcat(buf, " deliver to lmtp \"", sizeof buf);
		strlcat(buf, r->r_value.buffer, sizeof buf);
		strlcat(buf, "\"", sizeof buf);
d772 2
a773 2
	strlcpy(alias->u.mailaddr.user, line, sizeof(alias->u.mailaddr.user));
	strlcpy(alias->u.mailaddr.domain, domain,
@


1.15
log
@fix dump function with some combinations of flag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d417 1
a417 1
	uint16_t	mask = F_SMTPS|F_STARTTLS|F_AUTH|F_TLS_OPTIONAL|F_LMTP;
@


1.14
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.13 2013/11/28 10:43:37 eric Exp $	*/
d417 1
d420 1
a420 1
	switch (relay->flags) {
a432 3
	case F_STARTTLS|F_TLS_VERIFY:
		strlcat(buf, "tls://", sizeof buf);
		break;
a436 3
		strlcat(buf, "smtps://", sizeof buf);
		break;
	case F_SMTPS|F_TLS_VERIFY:
@


1.13
log
@unsigned char casts for ctype
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.12 2013/11/06 10:01:29 eric Exp $	*/
d78 1
a78 1
	bzero(&sa_in6, sizeof(sa_in6));
d105 1
a105 1
	bzero(maddr, sizeof *maddr);
d270 2
a271 2
	bzero(&ssin, sizeof(struct sockaddr_in));
	bzero(&ssin6, sizeof(struct sockaddr_in6));
d348 1
a348 1
	bzero(buffer, sizeof buffer);
d418 1
a418 1
	bzero(buf, sizeof buf);
d511 1
a511 1
	bzero(buf, sizeof buf);
d598 1
a598 1
	bzero(buf, sizeof buf);
d609 1
a609 1
	bzero(buf, sizeof buf);
d619 1
a619 1
	bzero(buf, sizeof buf);
d657 1
a657 1
	bzero(buffer, sizeof buffer);
d740 1
a740 1
	bzero(alias, sizeof *alias);
d762 1
a762 1
	bzero(alias, sizeof *alias);
d804 1
a804 1
	bzero(alias, sizeof *alias);
d821 1
a821 1
	bzero(alias, sizeof *alias);
d842 1
a842 1
	bzero(alias, sizeof *alias);
@


1.12
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d747 1
a747 1
		if (!isalnum((int)*line) &&
d783 1
a783 1
		if (!isalnum((int)*line) &&
d791 1
a791 1
		if (!isalnum((int)*domain) &&
d859 2
a860 1
	if (alias->u.buffer[3] != ' ' || !isalnum(alias->u.buffer[4]) ||
d862 2
a863 1
	    !isdigit(alias->u.buffer[1]) || !isdigit(alias->u.buffer[2]))
@


1.11
log
@handle the case where the filter string is quoted
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.10 2013/10/26 20:55:09 eric Exp $	*/
d324 1
a324 1
		uint8_t		 flags;
d326 4
d337 2
a338 2
		{ "ssl://",		F_SMTPS|F_STARTTLS		},
		{ "ssl+auth://",	F_SMTPS|F_STARTTLS|F_AUTH	},
d421 1
a421 1
		strlcat(buf, "ssl+auth://", sizeof buf);
d424 1
a424 1
		strlcat(buf, "ssl://", sizeof buf);
d432 3
d441 3
d514 3
a516 1
		strlcat(buf, " on ", sizeof buf);
d520 2
d524 3
d530 1
a530 1
			strlcat(buf, " for any", sizeof buf);
d533 1
a533 1
		strlcat(buf, " for domain ", sizeof buf);
d542 1
a542 1
			strlcat(buf, " for any virtual ", sizeof buf);
d546 1
a546 1
		strlcat(buf, " for domain ", sizeof buf);
d583 2
@


1.10
log
@fix default schema
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.9 2013/10/26 12:27:59 eric Exp $	*/
d696 16
a711 4
	if (*line == '|') {
		if (strlcpy(alias->u.buffer, line + 1,
			sizeof(alias->u.buffer)) >= sizeof(alias->u.buffer))
			return 0;
d713 1
a713 1
		return 1;
d715 1
a715 1
	return 0;
@


1.9
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.8 2013/07/19 16:02:00 eric Exp $	*/
d359 1
a359 1
		i = 1;
@


1.8
log
@Move the filter infrastructure forward.
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.7 2013/05/24 17:03:14 eric Exp $	*/
d243 1
a243 1
		snprintf(buf, sizeof buf, "%llid", d);
d247 1
a247 1
		snprintf(buf, sizeof buf, "%ih", h);
d251 1
a251 1
		snprintf(buf, sizeof buf, "%im", m);
d255 1
a255 1
		snprintf(buf, sizeof buf, "%is", s);
@


1.7
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.4 2013/02/15 22:43:21 eric Exp $	*/
a457 12
}

uint32_t
evpid_to_msgid(uint64_t evpid)
{
	return (evpid >> 32);
}

uint64_t
msgid_to_evpid(uint32_t msgid)
{
	return ((uint64_t)msgid << 32);
@


1.6
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.5 2013/04/08 06:50:07 gilles Exp $	*/
a21 1
#include <sys/param.h>
d58 1
d273 1
a273 1
	if (strncmp("IPv6:", s, 5) == 0)
d574 5
d587 1
a587 1
	char		buf[MAXPATHLEN];
d672 2
a673 1
	if (alias_is_include(expandnode, s, l) ||
d690 1
d815 31
@


1.5
log
@division of time_t does not necessarily fit in an int

spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.4 2013/02/15 22:43:21 eric Exp $	*/
d100 1
a100 1
	char  buffer[MAX_LINE_SIZE];
d137 1
a137 1
	static char  buffer[MAX_LINE_SIZE];
d631 1
a631 1
	char	buffer[MAX_LINE_SIZE];
@


1.4
log
@add missing bits for lmtp support (from Ashish SHUKLA).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.3 2013/02/14 12:30:49 gilles Exp $	*/
d221 2
a222 1
	int		d, h, m, s;
d243 1
a243 1
		snprintf(buf, sizeof buf, "%id", d);
@


1.3
log
@- smtpctl trace expand, enables tracing of aliases expansion
- replace "users" keyword with "userbase" when providing alternate userbase
- disambiguise expansion nodes when expanding across domains and userbases
- allow use of '=' instead of '=>' when declaring a mapping

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.2 2013/01/31 18:34:43 eric Exp $	*/
d326 1
d366 4
d380 3
d438 3
@


1.2
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: to.c,v 1.1 2013/01/26 09:37:24 gilles Exp $	*/
d663 19
@


1.1
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d269 3
a276 2

		bzero(&ssin, sizeof(struct sockaddr_in));
a278 1

a284 1
			bzero(&ssin6, sizeof(struct sockaddr_in6));
@

