head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.8
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.2
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2;
locks; strict;
comment	@ * @;


1.36
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.35;
commitid	ZxnqOQqX6IeYI9jW;

1.35
date	2015.12.14.10.35.29;	author sunil;	state Exp;
branches;
next	1.34;
commitid	ihoCMx2oebOFBF80;

1.34
date	2015.11.30.14.32.00;	author gilles;	state Exp;
branches;
next	1.33;
commitid	6RiDs7ka0mmDE92w;

1.33
date	2015.11.30.12.26.55;	author sunil;	state Exp;
branches;
next	1.32;
commitid	aGcPak9vEg5kOQ24;

1.32
date	2015.10.14.20.57.17;	author gilles;	state Exp;
branches;
next	1.31;
commitid	wehJ2BcS6LSjiwSg;

1.31
date	2015.10.09.09.56.28;	author gilles;	state Exp;
branches;
next	1.30;
commitid	HkVpHmBTEaz6oiIM;

1.30
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Uu5nFG3wCl0LACBb;

1.29
date	2014.04.19.12.30.54;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2014.02.04.15.44.05;	author eric;	state Exp;
branches;
next	1.27;

1.27
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.26;

1.26
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2013.12.05.09.44.16;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2013.11.28.10.43.37;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2013.11.18.11.47.16;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.26.20.32.48;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.18;

1.18
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.12.08.51.02;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.11.21.49.11;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.11.21.47.48;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.26.19.52.20;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2012.09.19.18.20.36;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2012.09.15.15.12.11;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.02.12.21.22;	author chl;	state Exp;
branches;
next	1.10;

1.10
date	2012.08.24.13.21.56;	author chl;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.21.20.19.46;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.19.10.32.32;	author chl;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.03.19.52.56;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.01.09.24.58;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.15.16.47.49;	author chl;	state Exp;
branches;
next	1.3;

1.3
date	2012.01.12.15.01.33;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.01.11.23.25.29;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.01.11.22.24.37;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.36
log
@remove spaces after '!'

no binary change

ok millert
@
text
@/*	$OpenBSD: envelope.c,v 1.35 2015/12/14 10:35:29 sunil Exp $	*/

/*
 * Copyright (c) 2013 Eric Faurot <eric@@openbsd.org>
 * Copyright (c) 2011-2013 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <inttypes.h>
#include <libgen.h>
#include <pwd.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

static int envelope_upgrade_v1(struct dict *);
static int envelope_ascii_load(struct envelope *, struct dict *);
static void envelope_ascii_dump(const struct envelope *, char **, size_t *,
    const char *);

void
envelope_set_errormsg(struct envelope *e, char *fmt, ...)
{
	int ret;
	va_list ap;

	va_start(ap, fmt);
	ret = vsnprintf(e->errorline, sizeof(e->errorline), fmt, ap);
	va_end(ap);

	/* this should not happen */
	if (ret == -1)
		err(1, "vsnprintf");

	if ((size_t)ret >= sizeof(e->errorline))
		(void)strlcpy(e->errorline + (sizeof(e->errorline) - 4),
		    "...", 4);
}

void
envelope_set_esc_class(struct envelope *e, enum enhanced_status_class class)
{
	e->esc_class = class;
}

void
envelope_set_esc_code(struct envelope *e, enum enhanced_status_code code)
{
	e->esc_code = code;
}

static int
envelope_buffer_to_dict(struct dict *d,  const char *ibuf, size_t buflen)
{
	static char	 lbuf[sizeof(struct envelope)];
	size_t		 len;
	char		*buf, *field, *nextline;

	memset(lbuf, 0, sizeof lbuf);
	if (strlcpy(lbuf, ibuf, sizeof lbuf) >= sizeof lbuf)
		goto err;
	buf = lbuf;

	while (buflen > 0) {
		len = strcspn(buf, "\n");
		buf[len] = '\0';
		nextline = buf + len + 1;
		buflen -= (nextline - buf);

		field = buf;
		while (*buf && (isalnum((unsigned char)*buf) || *buf == '-'))
			buf++;
		if (!*buf)
			goto err;

		/* skip whitespaces before separator */
		while (*buf && isspace((unsigned char)*buf))
			*buf++ = 0;

		/* we *want* ':' */
		if (*buf != ':')
			goto err;
		*buf++ = 0;

		/* skip whitespaces after separator */
		while (*buf && isspace((unsigned char)*buf))
			*buf++ = 0;
		dict_set(d, field, buf);
		buf = nextline;
	}

	return (1);

err:
	return (0);
}

int
envelope_load_buffer(struct envelope *ep, const char *ibuf, size_t buflen)
{
	struct dict	 d;
	const char	*val, *errstr;
	long long	 version;
	int		 ret = 0;

	dict_init(&d);
	if (!envelope_buffer_to_dict(&d, ibuf, buflen)) {
		log_debug("debug: cannot parse envelope to dict");
		goto end;
	}

	val = dict_get(&d, "version");
	if (val == NULL) {
		log_debug("debug: envelope version not found");
		goto end;
	}
	version = strtonum(val, 1, 64, &errstr);
	if (errstr) {
		log_debug("debug: cannot parse envelope version: %s", val);
		goto end;
	}

	switch (version) {
	case 1:
		log_debug("debug: upgrading envelope to version 1");
		if (!envelope_upgrade_v1(&d)) {
			log_debug("debug: failed to upgrade "
			    "envelope to version 1");
			goto end;
		}
		/* FALLTRHOUGH */
	case 2:
		/* Can be missing in some v2 envelopes */
		if (dict_get(&d, "smtpname") == NULL)
			dict_xset(&d, "smtpname", env->sc_hostname);
		break;
	default:
		log_debug("debug: bad envelope version %lld", version);
		goto end;
	}

	memset(ep, 0, sizeof *ep);
	ret = envelope_ascii_load(ep, &d);
	if (ret)
		ep->version = SMTPD_ENVELOPE_VERSION;
end:
	while (dict_poproot(&d, NULL))
		;
	return (ret);
}

int
envelope_dump_buffer(const struct envelope *ep, char *dest, size_t len)
{
	char	*p = dest;

	envelope_ascii_dump(ep, &dest, &len, "version");
	envelope_ascii_dump(ep, &dest, &len, "tag");
	envelope_ascii_dump(ep, &dest, &len, "type");
	envelope_ascii_dump(ep, &dest, &len, "smtpname");
	envelope_ascii_dump(ep, &dest, &len, "helo");
	envelope_ascii_dump(ep, &dest, &len, "hostname");
	envelope_ascii_dump(ep, &dest, &len, "errorline");
	envelope_ascii_dump(ep, &dest, &len, "sockaddr");
	envelope_ascii_dump(ep, &dest, &len, "sender");
	envelope_ascii_dump(ep, &dest, &len, "rcpt");
	envelope_ascii_dump(ep, &dest, &len, "dest");
	envelope_ascii_dump(ep, &dest, &len, "ctime");
	envelope_ascii_dump(ep, &dest, &len, "last-try");
	envelope_ascii_dump(ep, &dest, &len, "last-bounce");
	envelope_ascii_dump(ep, &dest, &len, "expire");
	envelope_ascii_dump(ep, &dest, &len, "retry");
	envelope_ascii_dump(ep, &dest, &len, "flags");
	envelope_ascii_dump(ep, &dest, &len, "dsn-notify");
	envelope_ascii_dump(ep, &dest, &len, "dsn-ret");
	envelope_ascii_dump(ep, &dest, &len, "dsn-envid");
	envelope_ascii_dump(ep, &dest, &len, "dsn-orcpt");
	envelope_ascii_dump(ep, &dest, &len, "esc-class");
	envelope_ascii_dump(ep, &dest, &len, "esc-code");

	switch (ep->type) {
	case D_MDA:
		envelope_ascii_dump(ep, &dest, &len, "mda-buffer");
		envelope_ascii_dump(ep, &dest, &len, "mda-method");
		envelope_ascii_dump(ep, &dest, &len, "mda-user");
		envelope_ascii_dump(ep, &dest, &len, "mda-usertable");
		envelope_ascii_dump(ep, &dest, &len, "mda-delivery-user");
		break;
	case D_MTA:
		envelope_ascii_dump(ep, &dest, &len, "mta-relay");
		envelope_ascii_dump(ep, &dest, &len, "mta-relay-auth");
		envelope_ascii_dump(ep, &dest, &len, "mta-relay-cert");
		envelope_ascii_dump(ep, &dest, &len, "mta-relay-ca");
		envelope_ascii_dump(ep, &dest, &len, "mta-relay-flags");
		envelope_ascii_dump(ep, &dest, &len, "mta-relay-heloname");
		envelope_ascii_dump(ep, &dest, &len, "mta-relay-helotable");
		envelope_ascii_dump(ep, &dest, &len, "mta-relay-source");
		break;
	case D_BOUNCE:
		envelope_ascii_dump(ep, &dest, &len, "bounce-expire");
		envelope_ascii_dump(ep, &dest, &len, "bounce-delay");
		envelope_ascii_dump(ep, &dest, &len, "bounce-type");
		break;
	default:
		return (0);
	}

	if (dest == NULL)
		return (0);

	return (dest - p);
}

static int
ascii_load_uint8(uint8_t *dest, char *buf)
{
	const char *errstr;

	*dest = strtonum(buf, 0, 0xff, &errstr);
	if (errstr)
		return 0;
	return 1;
}

static int
ascii_load_uint16(uint16_t *dest, char *buf)
{
	const char *errstr;

	*dest = strtonum(buf, 0, 0xffff, &errstr);
	if (errstr)
		return 0;
	return 1;
}

static int
ascii_load_uint32(uint32_t *dest, char *buf)
{
	const char *errstr;

	*dest = strtonum(buf, 0, 0xffffffff, &errstr);
	if (errstr)
		return 0;
	return 1;
}

static int
ascii_load_time(time_t *dest, char *buf)
{
	const char *errstr;

	*dest = strtonum(buf, 0, LLONG_MAX, &errstr);
	if (errstr)
		return 0;
	return 1;
}

static int
ascii_load_type(enum delivery_type *dest, char *buf)
{
	if (strcasecmp(buf, "mda") == 0)
		*dest = D_MDA;
	else if (strcasecmp(buf, "mta") == 0)
		*dest = D_MTA;
	else if (strcasecmp(buf, "bounce") == 0)
		*dest = D_BOUNCE;
	else
		return 0;
	return 1;
}

static int
ascii_load_string(char *dest, char *buf, size_t len)
{
	if (strlcpy(dest, buf, len) >= len)
		return 0;
	return 1;
}

static int
ascii_load_sockaddr(struct sockaddr_storage *ss, char *buf)
{
	struct sockaddr_in6 ssin6;
	struct sockaddr_in  ssin;

	memset(&ssin, 0, sizeof ssin);
	memset(&ssin6, 0, sizeof ssin6);

	if (!strcmp("local", buf)) {
		ss->ss_family = AF_LOCAL;
	}
	else if (strncasecmp("IPv6:", buf, 5) == 0) {
		if (inet_pton(AF_INET6, buf + 5, &ssin6.sin6_addr) != 1)
			return 0;
		ssin6.sin6_family = AF_INET6;
		memcpy(ss, &ssin6, sizeof(ssin6));
		ss->ss_len = sizeof(struct sockaddr_in6);
	}
	else {
		if (inet_pton(AF_INET, buf, &ssin.sin_addr) != 1)
			return 0;
		ssin.sin_family = AF_INET;
		memcpy(ss, &ssin, sizeof(ssin));
		ss->ss_len = sizeof(struct sockaddr_in);
	}
	return 1;
}

static int
ascii_load_mda_method(enum action_type *dest, char *buf)
{
	if (strcasecmp(buf, "mbox") == 0)
		*dest = A_MBOX;
	else if (strcasecmp(buf, "maildir") == 0)
		*dest = A_MAILDIR;
	else if (strcasecmp(buf, "filename") == 0)
		*dest = A_FILENAME;
	else if (strcasecmp(buf, "mda") == 0)
		*dest = A_MDA;
	else if (strcasecmp(buf, "lmtp") == 0)
		*dest = A_LMTP;
	else
		return 0;
	return 1;
}

static int
ascii_load_mailaddr(struct mailaddr *dest, char *buf)
{
	if (!text_to_mailaddr(dest, buf))
		return 0;
	return 1;
}

static int
ascii_load_flags(enum envelope_flags *dest, char *buf)
{
	char *flag;

	while ((flag = strsep(&buf, " ,|")) != NULL) {
		if (strcasecmp(flag, "authenticated") == 0)
			*dest |= EF_AUTHENTICATED;
		else if (strcasecmp(flag, "enqueued") == 0)
			;
		else if (strcasecmp(flag, "bounce") == 0)
			*dest |= EF_BOUNCE;
		else if (strcasecmp(flag, "internal") == 0)
			*dest |= EF_INTERNAL;
		else
			return 0;
	}
	return 1;
}

static int
ascii_load_mta_relay_url(struct relayhost *relay, char *buf)
{
	if (!text_to_relayhost(relay, buf))
		return 0;
	return 1;
}

static int
ascii_load_mta_relay_flags(uint16_t *dest, char *buf)
{
	char *flag;

	while ((flag = strsep(&buf, " ,|")) != NULL) {
		if (strcasecmp(flag, "verify") == 0)
			*dest |= F_TLS_VERIFY;
		else if (strcasecmp(flag, "tls") == 0)
			*dest |= F_STARTTLS;
		else
			return 0;
	}

	return 1;
}

static int
ascii_load_bounce_type(enum bounce_type *dest, char *buf)
{
	if (strcasecmp(buf, "error") == 0)
		*dest = B_ERROR;
	else if (strcasecmp(buf, "warn") == 0)
		*dest = B_WARNING;
	else if (strcasecmp(buf, "dsn") == 0)
		*dest = B_DSN;
	else
		return 0;
	return 1;
}

static int
ascii_load_dsn_ret(enum dsn_ret *ret, char *buf)
{
	if (strcasecmp(buf, "HDRS") == 0)
		*ret = DSN_RETHDRS;
	else if (strcasecmp(buf, "FULL") == 0)
		*ret = DSN_RETFULL;
	else
		return 0;
	return 1;
}

static int
ascii_load_field(const char *field, struct envelope *ep, char *buf)
{
	if (strcasecmp("bounce-delay", field) == 0)
		return ascii_load_time(&ep->agent.bounce.delay, buf);

	if (strcasecmp("bounce-expire", field) == 0)
		return ascii_load_time(&ep->agent.bounce.expire, buf);

	if (strcasecmp("bounce-type", field) == 0)
		return ascii_load_bounce_type(&ep->agent.bounce.type, buf);

	if (strcasecmp("ctime", field) == 0)
		return ascii_load_time(&ep->creation, buf);

	if (strcasecmp("dest", field) == 0)
		return ascii_load_mailaddr(&ep->dest, buf);

	if (strcasecmp("errorline", field) == 0)
		return ascii_load_string(ep->errorline, buf,
		    sizeof ep->errorline);

	if (strcasecmp("expire", field) == 0)
		return ascii_load_time(&ep->expire, buf);

	if (strcasecmp("flags", field) == 0)
		return ascii_load_flags(&ep->flags, buf);

	if (strcasecmp("helo", field) == 0)
		return ascii_load_string(ep->helo, buf, sizeof ep->helo);

	if (strcasecmp("hostname", field) == 0)
		return ascii_load_string(ep->hostname, buf,
		    sizeof ep->hostname);

	if (strcasecmp("last-bounce", field) == 0)
		return ascii_load_time(&ep->lastbounce, buf);

	if (strcasecmp("last-try", field) == 0)
		return ascii_load_time(&ep->lasttry, buf);

	if (strcasecmp("mda-buffer", field) == 0)
		return ascii_load_string(ep->agent.mda.buffer, buf,
		    sizeof ep->agent.mda.buffer);

	if (strcasecmp("mda-method", field) == 0)
		return ascii_load_mda_method(&ep->agent.mda.method, buf);

	if (strcasecmp("mda-user", field) == 0)
		return ascii_load_string(ep->agent.mda.username, buf,
		    sizeof ep->agent.mda.username);

	if (strcasecmp("mda-usertable", field) == 0)
		return ascii_load_string(ep->agent.mda.usertable, buf,
		    sizeof ep->agent.mda.usertable);

	if (strcasecmp("mda-delivery-user", field) == 0)
		return ascii_load_string(ep->agent.mda.delivery_user, buf,
		    sizeof ep->agent.mda.delivery_user);

	if (strcasecmp("mta-relay", field) == 0) {
		int ret;
		uint16_t flags = ep->agent.mta.relay.flags;
		ret = ascii_load_mta_relay_url(&ep->agent.mta.relay, buf);
		if (!ret)
			return (0);
		ep->agent.mta.relay.flags |= flags;
		return ret;
	}

	if (strcasecmp("mta-relay-auth", field) == 0)
		return ascii_load_string(ep->agent.mta.relay.authtable, buf,
		    sizeof ep->agent.mta.relay.authtable);

	if (strcasecmp("mta-relay-cert", field) == 0)
		return ascii_load_string(ep->agent.mta.relay.pki_name, buf,
		    sizeof ep->agent.mta.relay.pki_name);

	if (strcasecmp("mta-relay-ca", field) == 0)
		return ascii_load_string(ep->agent.mta.relay.ca_name, buf,
		    sizeof ep->agent.mta.relay.ca_name);

	if (strcasecmp("mta-relay-flags", field) == 0)
		return ascii_load_mta_relay_flags(&ep->agent.mta.relay.flags,
		    buf);

	if (strcasecmp("mta-relay-heloname", field) == 0)
		return ascii_load_string(ep->agent.mta.relay.heloname, buf,
		    sizeof ep->agent.mta.relay.heloname);

	if (strcasecmp("mta-relay-helotable", field) == 0)
		return ascii_load_string(ep->agent.mta.relay.helotable, buf,
		    sizeof ep->agent.mta.relay.helotable);

	if (strcasecmp("mta-relay-source", field) == 0)
		return ascii_load_string(ep->agent.mta.relay.sourcetable, buf,
		    sizeof ep->agent.mta.relay.sourcetable);

	if (strcasecmp("retry", field) == 0)
		return ascii_load_uint16(&ep->retry, buf);

	if (strcasecmp("rcpt", field) == 0)
		return ascii_load_mailaddr(&ep->rcpt, buf);

	if (strcasecmp("sender", field) == 0)
		return ascii_load_mailaddr(&ep->sender, buf);

	if (strcasecmp("smtpname", field) == 0)
		return ascii_load_string(ep->smtpname, buf,
		    sizeof(ep->smtpname));

	if (strcasecmp("sockaddr", field) == 0)
		return ascii_load_sockaddr(&ep->ss, buf);

	if (strcasecmp("tag", field) == 0)
		return ascii_load_string(ep->tag, buf, sizeof ep->tag);

	if (strcasecmp("type", field) == 0)
		return ascii_load_type(&ep->type, buf);

	if (strcasecmp("version", field) == 0)
		return ascii_load_uint32(&ep->version, buf);

	if (strcasecmp("dsn-notify", field) == 0)
		return ascii_load_uint8(&ep->dsn_notify, buf);

	if (strcasecmp("dsn-orcpt", field) == 0)
		return ascii_load_mailaddr(&ep->dsn_orcpt, buf);

	if (strcasecmp("dsn-ret", field) == 0)
		return ascii_load_dsn_ret(&ep->dsn_ret, buf);

	if (strcasecmp("dsn-envid", field) == 0)
		return ascii_load_string(ep->dsn_envid, buf,
		    sizeof(ep->dsn_envid));

	if (strcasecmp("esc-class", field) == 0)
		return ascii_load_uint8(&ep->esc_class, buf);

	if (strcasecmp("esc-code", field) == 0)
		return ascii_load_uint8(&ep->esc_code, buf);

	return (0);
}

static int
envelope_ascii_load(struct envelope *ep, struct dict *d)
{
	const char	       *field;
	char		       *value;
	void		       *hdl;

	hdl = NULL;
	while (dict_iter(d, &hdl, &field, (void **)&value))
		if (!ascii_load_field(field, ep, value))
			goto err;

	return (1);

err:
	log_warnx("envelope: invalid field \"%s\"", field);
	return (0);
}


static int
ascii_dump_uint8(uint8_t src, char *dest, size_t len)
{
	return bsnprintf(dest, len, "%d", src);
}

static int
ascii_dump_uint16(uint16_t src, char *dest, size_t len)
{
	return bsnprintf(dest, len, "%d", src);
}

static int
ascii_dump_uint32(uint32_t src, char *dest, size_t len)
{
	return bsnprintf(dest, len, "%d", src);
}

static int
ascii_dump_time(time_t src, char *dest, size_t len)
{
	return bsnprintf(dest, len, "%lld", (long long) src);
}

static int
ascii_dump_string(const char *src, char *dest, size_t len)
{
	return bsnprintf(dest, len, "%s", src);
}

static int
ascii_dump_type(enum delivery_type type, char *dest, size_t len)
{
	char *p = NULL;

	switch (type) {
	case D_MDA:
		p = "mda";
		break;
	case D_MTA:
		p = "mta";
		break;
	case D_BOUNCE:
		p = "bounce";
		break;
	default:
		return 0;
	}

	return bsnprintf(dest, len, "%s", p);
}

static int
ascii_dump_mda_method(enum action_type type, char *dest, size_t len)
{
	char *p = NULL;

	switch (type) {
	case A_LMTP:
		p = "lmtp";
		break;
	case A_MAILDIR:
		p = "maildir";
		break;
	case A_MBOX:
		p = "mbox";
		break;
	case A_FILENAME:
		p = "filename";
		break;
	case A_MDA:
		p = "mda";
		break;
	default:
		return 0;
	}
	return bsnprintf(dest, len, "%s", p);
}

static int
ascii_dump_mailaddr(const struct mailaddr *addr, char *dest, size_t len)
{
	return bsnprintf(dest, len, "%s@@%s",
	    addr->user, addr->domain);
}

static int
ascii_dump_flags(enum envelope_flags flags, char *buf, size_t len)
{
	size_t cpylen = 0;

	buf[0] = '\0';
	if (flags) {
		if (flags & EF_AUTHENTICATED)
			cpylen = strlcat(buf, "authenticated", len);
		if (flags & EF_BOUNCE) {
			if (buf[0] != '\0')
				(void)strlcat(buf, " ", len);
			cpylen = strlcat(buf, "bounce", len);
		}
		if (flags & EF_INTERNAL) {
			if (buf[0] != '\0')
				(void)strlcat(buf, " ", len);
			cpylen = strlcat(buf, "internal", len);
		}
	}

	return cpylen < len ? 1 : 0;
}

static int
ascii_dump_mta_relay_url(const struct relayhost *relay, char *buf, size_t len)
{
	return bsnprintf(buf, len, "%s", relayhost_to_text(relay));
}

static int
ascii_dump_mta_relay_flags(uint16_t flags, char *buf, size_t len)
{
	size_t cpylen = 0;

	buf[0] = '\0';
	if (flags) {
		if (flags & F_TLS_VERIFY) {
			if (buf[0] != '\0')
				(void)strlcat(buf, " ", len);
			cpylen = strlcat(buf, "verify", len);
		}
		if (flags & F_STARTTLS) {
			if (buf[0] != '\0')
				(void)strlcat(buf, " ", len);
			cpylen = strlcat(buf, "tls", len);
		}
	}

	return cpylen < len ? 1 : 0;
}

static int
ascii_dump_bounce_type(enum bounce_type type, char *dest, size_t len)
{
	char *p = NULL;

	switch (type) {
	case B_ERROR:
		p = "error";
		break;
	case B_WARNING:
		p = "warn";
		break;
	case B_DSN:
		p = "dsn";
		break;
	default:
		return 0;
	}
	return bsnprintf(dest, len, "%s", p);
}


static int
ascii_dump_dsn_ret(enum dsn_ret flag, char *dest, size_t len)
{
	size_t cpylen = 0;

	dest[0] = '\0';
	if (flag == DSN_RETFULL)
		cpylen = strlcat(dest, "FULL", len);
	else if (flag == DSN_RETHDRS)
		cpylen = strlcat(dest, "HDRS", len);

	return cpylen < len ? 1 : 0;
}

static int
ascii_dump_field(const char *field, const struct envelope *ep,
    char *buf, size_t len)
{
	if (strcasecmp(field, "bounce-delay") == 0) {
		if (ep->agent.bounce.type != B_WARNING)
			return (1);
		return ascii_dump_time(ep->agent.bounce.delay, buf, len);
	}

	if (strcasecmp(field, "bounce-expire") == 0) {
		if (ep->agent.bounce.type != B_WARNING)
			return (1);
		return ascii_dump_time(ep->agent.bounce.expire, buf, len);
	}

	if (strcasecmp(field, "bounce-type") == 0)
		return ascii_dump_bounce_type(ep->agent.bounce.type, buf, len);

	if (strcasecmp(field, "ctime") == 0)
		return ascii_dump_time(ep->creation, buf, len);

	if (strcasecmp(field, "dest") == 0)
		return ascii_dump_mailaddr(&ep->dest, buf, len);

	if (strcasecmp(field, "errorline") == 0)
		return ascii_dump_string(ep->errorline, buf, len);

	if (strcasecmp(field, "expire") == 0)
		return ascii_dump_time(ep->expire, buf, len);

	if (strcasecmp(field, "flags") == 0)
		return ascii_dump_flags(ep->flags, buf, len);

	if (strcasecmp(field, "helo") == 0)
		return ascii_dump_string(ep->helo, buf, len);

	if (strcasecmp(field, "hostname") == 0)
		return ascii_dump_string(ep->hostname, buf, len);

	if (strcasecmp(field, "last-bounce") == 0)
		return ascii_dump_time(ep->lastbounce, buf, len);

	if (strcasecmp(field, "last-try") == 0)
		return ascii_dump_time(ep->lasttry, buf, len);

	if (strcasecmp(field, "mda-buffer") == 0)
		return ascii_dump_string(ep->agent.mda.buffer, buf, len);

	if (strcasecmp(field, "mda-method") == 0)
		return ascii_dump_mda_method(ep->agent.mda.method, buf, len);

	if (strcasecmp(field, "mda-user") == 0)
		return ascii_dump_string(ep->agent.mda.username, buf, len);

	if (strcasecmp(field, "mda-delivery-user") == 0)
		return ascii_dump_string(ep->agent.mda.delivery_user, buf, len);

	if (strcasecmp(field, "mda-usertable") == 0)
		return ascii_dump_string(ep->agent.mda.usertable, buf, len);

	if (strcasecmp(field, "mta-relay") == 0) {
		if (ep->agent.mta.relay.hostname[0])
			return ascii_dump_mta_relay_url(&ep->agent.mta.relay,
			    buf, len);
		return (1);
	}

	if (strcasecmp(field, "mta-relay-auth") == 0)
		return ascii_dump_string(ep->agent.mta.relay.authtable,
		    buf, len);

	if (strcasecmp(field, "mta-relay-cert") == 0)
		return ascii_dump_string(ep->agent.mta.relay.pki_name,
		    buf, len);

	if (strcasecmp(field, "mta-relay-ca") == 0)
		return ascii_dump_string(ep->agent.mta.relay.ca_name,
		    buf, len);

	if (strcasecmp(field, "mta-relay-flags") == 0)
		return ascii_dump_mta_relay_flags(ep->agent.mta.relay.flags,
		    buf, len);

	if (strcasecmp(field, "mta-relay-heloname") == 0)
		return ascii_dump_string(ep->agent.mta.relay.heloname,
		    buf, len);

	if (strcasecmp(field, "mta-relay-helotable") == 0)
		return ascii_dump_string(ep->agent.mta.relay.helotable,
		    buf, len);

	if (strcasecmp(field, "mta-relay-source") == 0)
		return ascii_dump_string(ep->agent.mta.relay.sourcetable,
		    buf, len);

	if (strcasecmp(field, "retry") == 0)
		return ascii_dump_uint16(ep->retry, buf, len);

	if (strcasecmp(field, "rcpt") == 0)
		return ascii_dump_mailaddr(&ep->rcpt, buf, len);

	if (strcasecmp(field, "sender") == 0)
		return ascii_dump_mailaddr(&ep->sender, buf, len);

	if (strcasecmp(field, "smtpname") == 0)
		return ascii_dump_string(ep->smtpname, buf, len);

	if (strcasecmp(field, "sockaddr") == 0)
		return ascii_dump_string(ss_to_text(&ep->ss), buf, len);

	if (strcasecmp(field, "tag") == 0)
		return ascii_dump_string(ep->tag, buf, len);

	if (strcasecmp(field, "type") == 0)
		return ascii_dump_type(ep->type, buf, len);

	if (strcasecmp(field, "version") == 0)
		return ascii_dump_uint32(SMTPD_ENVELOPE_VERSION, buf, len);

	if (strcasecmp(field, "dsn-notify") == 0)
		return ascii_dump_uint8(ep->dsn_notify, buf, len);

	if (strcasecmp(field, "dsn-ret") == 0)
		return ascii_dump_dsn_ret(ep->dsn_ret, buf, len);

	if (strcasecmp(field, "dsn-orcpt") == 0) {
		if (ep->dsn_orcpt.user[0] && ep->dsn_orcpt.domain[0])
			return ascii_dump_mailaddr(&ep->dsn_orcpt, buf, len);
		return 1;
	}

	if (strcasecmp(field, "dsn-envid") == 0)
		return ascii_dump_string(ep->dsn_envid, buf, len);

	if (strcasecmp(field, "esc-class") == 0) {
		if (ep->esc_class)
			return ascii_dump_uint8(ep->esc_class, buf, len);
		return 1;
	}

	if (strcasecmp(field, "esc-code") == 0) {
		/* this is not a pasto, we dump esc_code if esc_class is !0 */
		if (ep->esc_class)
			return ascii_dump_uint8(ep->esc_code, buf, len);
		return 1;
	}

	return (0);
}

static void
envelope_ascii_dump(const struct envelope *ep, char **dest, size_t *len,
    const char *field)
{
	char	buf[8192];
	int	l;

	if (*dest == NULL)
		return;

	memset(buf, 0, sizeof buf);
	if (!ascii_dump_field(field, ep, buf, sizeof buf))
		goto err;
	if (buf[0] == '\0')
		return;

	l = snprintf(*dest, *len, "%s: %s\n", field, buf);
	if (l == -1 || (size_t) l >= *len)
		goto err;
	*dest += l;
	*len -= l;

	return;
err:
	*dest = NULL;
}

static int
envelope_upgrade_v1(struct dict *d)
{
	static char	 buf_relay[1024];
	char		*val;

	/*
	 * very very old envelopes had a "msgid" field
	 */
	dict_pop(d, "msgid");

	/*
	 * rename "mta-relay-helo" field to "mta-relay-helotable"
	 */
	if ((val = dict_get(d, "mta-relay-helo"))) {
		dict_xset(d, "mta-relay-helotable", val);
		dict_xpop(d, "mta-relay-helo");
	}

	/*
	 * "ssl" becomes "secure" in "mta-relay" scheme
	 */
	if ((val = dict_get(d, "mta-relay"))) {
		if (strncasecmp("ssl://", val, 6) == 0) {
			if (!bsnprintf(buf_relay, sizeof(buf_relay),
			    "secure://%s", val+6))
				return (0);
			dict_set(d, "mta-relay", buf_relay);
		}
		else if (strncasecmp("ssl+auth://", val, 11) == 0) {
			if (!bsnprintf(buf_relay, sizeof(buf_relay),
			    "secure+auth://%s", val+11))
				return (0);
			dict_set(d, "mta-relay", buf_relay);
		}
	}

	return (1);
}
@


1.35
log
@Wrap long lines and fix bad indents.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.34 2015/11/30 14:32:00 gilles Exp $	*/
d105 1
a105 1
		if (! *buf)
d139 1
a139 1
	if (! envelope_buffer_to_dict(&d, ibuf, buflen)) {
d362 1
a362 1
	if (! text_to_mailaddr(dest, buf))
d390 1
a390 1
	if (! text_to_relayhost(relay, buf))
d502 1
a502 1
		if (! ret)
d592 1
a592 1
		if (! ascii_load_field(field, ep, value))
d939 1
a939 1
	if (! ascii_dump_field(field, ep, buf, sizeof buf))
d979 1
a979 1
			if (! bsnprintf(buf_relay, sizeof(buf_relay),
d985 1
a985 1
			if (! bsnprintf(buf_relay, sizeof(buf_relay),
@


1.34
log
@if a ca_name is set, dump it to on-disk envelope so we recall it on reload.
we don't set ca_name yet, it is part of a larger diff i'm splitting
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.29 2014/04/19 12:30:54 gilles Exp $	*/
d68 2
a69 1
		(void)strlcpy(e->errorline + (sizeof(e->errorline) - 4), "...", 4);
d136 1
a136 1
	int	 	 ret = 0;
d159 2
a160 1
			log_debug("debug: failed to upgrade envelope to version 1");
d521 2
a522 1
		return ascii_load_mta_relay_flags(&ep->agent.mta.relay.flags, buf);
d546 2
a547 1
		return ascii_load_string(ep->smtpname, buf, sizeof(ep->smtpname));
d571 2
a572 1
		return ascii_load_string(ep->dsn_envid, buf, sizeof(ep->dsn_envid));
d766 1
a766 1
        size_t cpylen = 0;
d768 5
a772 5
        dest[0] = '\0';
        if (flag == DSN_RETFULL)
                cpylen = strlcat(dest, "FULL", len);
        else if (flag == DSN_RETHDRS)
                cpylen = strlcat(dest, "HDRS", len);
d774 1
a774 1
        return cpylen < len ? 1 : 0;
d840 2
a841 1
			return ascii_dump_mta_relay_url(&ep->agent.mta.relay, buf, len);
d929 2
a930 1
envelope_ascii_dump(const struct envelope *ep, char **dest, size_t *len, const char *field)
d979 2
a980 1
			if (! bsnprintf(buf_relay, sizeof(buf_relay), "secure://%s", val+6))
d985 2
a986 1
			if (! bsnprintf(buf_relay, sizeof(buf_relay), "secure+auth://%s", val+11))
@


1.33
log
@While delivering to lmtp or mda, accept optional "as user" parameter
whose privileges would be used instead of the default.

Ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.32 2015/10/14 20:57:17 gilles Exp $	*/
d223 1
d514 4
d845 4
@


1.32
log
@we dump esc_code if we have an esc_class, code may be (and actually was)
confused as a pasto, so add a comment to make it clear that this is not
an error
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.31 2015/10/09 09:56:28 gilles Exp $	*/
d217 1
d491 4
d821 3
@


1.31
log
@if enhanced status class is not set, enhanced status code is never dumped
in disk envelope.
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.30 2015/01/16 06:40:20 deraadt Exp $	*/
d896 2
a897 1
		if (ep->esc_code)
@


1.30
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.29 2014/04/19 12:30:54 gilles Exp $	*/
d896 1
a896 1
		if (ep->esc_class)
@


1.29
log
@(void) cast strlcpy(), it cannot truncate
(void) cast strlcat(), they are detected and handled later
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.28 2014/02/04 15:44:05 eric Exp $	*/
d38 1
@


1.28
log
@Add support for DSN and Enhanced Status Code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
		strlcpy(e->errorline + (sizeof(e->errorline) - 4), "...", 4);
d684 1
a684 1
				strlcat(buf, " ", len);
d689 1
a689 1
				strlcat(buf, " ", len);
d712 1
a712 1
				strlcat(buf, " ", len);
d717 1
a717 1
				strlcat(buf, " ", len);
@


1.27
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.26 2013/12/26 17:25:32 eric Exp $	*/
d70 12
d203 6
d242 11
d414 14
d546 18
d588 6
d737 3
d746 15
d872 27
@


1.26
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.25 2013/12/05 09:44:16 eric Exp $	*/
d461 2
a462 2
		return ascii_load_string(ep->agent.mta.relay.cert, buf,
		    sizeof ep->agent.mta.relay.cert);
d745 1
a745 1
		return ascii_dump_string(ep->agent.mta.relay.cert,
@


1.25
log
@warn when failing to parse a field
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.24 2013/11/28 10:43:37 eric Exp $	*/
d77 1
a77 1
	bzero(lbuf, sizeof lbuf);
d159 1
a159 1
	bzero(ep, sizeof *ep);
d284 2
a285 2
	bzero(&ssin, sizeof ssin);
	bzero(&ssin6, sizeof ssin6);
d800 1
a800 1
	bzero(buf, sizeof buf);
@


1.24
log
@unsigned char casts for ctype
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.23 2013/11/18 11:47:16 eric Exp $	*/
d521 1
@


1.23
log
@change dict_poproot() prototype: do not take key placeholder parameter as
it can't work that way.
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.22 2013/11/06 10:01:29 eric Exp $	*/
d89 1
a89 1
		while (*buf && (isalnum(*buf) || *buf == '-'))
d95 1
a95 1
		while (*buf && isspace(*buf))
d104 1
a104 1
		while (*buf && isspace(*buf))
@


1.22
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d164 1
a164 1
	while (dict_poproot(&d, NULL, NULL))
@


1.21
log
@Simplify code for loading and dumping envelopes.  Makes it much easier
to deal with automatic upgrade between envelope versions at load time.
@
text
@d47 1
d143 10
a152 2
		/* very very okd envelopes may still have this */
		dict_pop(&d, "msgid");
d177 1
d203 3
a205 1
		envelope_ascii_dump(ep, &dest, &len, "mta-relay-helo");
d362 17
d464 8
a471 1
	if (strcasecmp("mta-relay-helo", field) == 0)
d488 3
d636 22
d747 9
a755 1
	if (strcasecmp(field, "mta-relay-helo") == 0)
d772 3
d814 38
@


1.20
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.19 2013/01/31 18:34:43 eric Exp $	*/
d4 2
a5 1
 * Copyright (c) 2011 Gilles Chehade <gilles@@poolp.org>
d47 3
a49 22
static int ascii_load_uint16(uint16_t *, char *);
static int ascii_load_uint32(uint32_t *, char *);
static int ascii_load_time(time_t *, char *);
static int ascii_load_type(enum delivery_type *, char *);
static int ascii_load_string(char *, char *, size_t);
static int ascii_load_sockaddr(struct sockaddr_storage *, char *);
static int ascii_load_mda_method(enum action_type *, char *);
static int ascii_load_mailaddr(struct mailaddr *, char *);
static int ascii_load_flags(enum envelope_flags *, char *);
static int ascii_load_mta_relay_url(struct relayhost *, char *);
static int ascii_load_bounce_type(enum bounce_type *, char *);

static int ascii_dump_uint16(uint16_t, char *, size_t);
static int ascii_dump_uint32(uint32_t, char *, size_t);
static int ascii_dump_time(time_t, char *, size_t);
static int ascii_dump_string(const char *, char *, size_t);
static int ascii_dump_type(enum delivery_type, char *, size_t);
static int ascii_dump_mda_method(enum action_type, char *, size_t);
static int ascii_dump_mailaddr(const struct mailaddr *, char *, size_t);
static int ascii_dump_flags(enum envelope_flags, char *, size_t);
static int ascii_dump_mta_relay_url(const struct relayhost *, char *, size_t);
static int ascii_dump_bounce_type(enum bounce_type, char *, size_t);
d69 2
a70 2
int
envelope_load_buffer(struct envelope *ep, const char *ibuf, size_t buflen)
d72 3
a74 37
	enum envelope_field fields[] = {
		EVP_VERSION,
		EVP_TAG,
		EVP_MSGID,
		EVP_HOSTNAME,
		EVP_SOCKADDR,
		EVP_HELO,
		EVP_SENDER,
		EVP_RCPT,
		EVP_DEST,
		EVP_TYPE,
		EVP_CTIME,
		EVP_EXPIRE,
		EVP_RETRY,
		EVP_LASTTRY,
		EVP_LASTBOUNCE,
		EVP_FLAGS,
		EVP_ERRORLINE,
		EVP_MDA_METHOD,
		EVP_MDA_USERTABLE,
		EVP_MDA_BUFFER,
		EVP_MDA_USER,
		EVP_MTA_RELAY_SOURCE,
		EVP_MTA_RELAY_CERT,
		EVP_MTA_RELAY_AUTH,
		EVP_MTA_RELAY_HELO,
		EVP_MTA_RELAY,
		EVP_BOUNCE_TYPE,
		EVP_BOUNCE_DELAY,
		EVP_BOUNCE_EXPIRE,
	};
	char	*field, *nextline;
	char	 lbuf[sizeof(*ep)], *buf;
	size_t	 len;
	int	 i;
	int	 n;
	int	 ret;
a80 3
	n = sizeof(fields) / sizeof(enum envelope_field);
	bzero(ep, sizeof (*ep));

a85 25
		for (i = 0; i < n; ++i) {
			field = envelope_ascii_field_name(fields[i]);
			len = strlen(field);
			if (! strncasecmp(field, buf, len)) {
				/* skip kw and tailing whitespaces */
				buf += len;
				while (*buf && isspace(*buf))
					buf++;

				/* we *want* ':' */
				if (*buf != ':')
					continue;
				buf++;

				/* skip whitespaces after separator */
				while (*buf && isspace(*buf))
				    buf++;

				ret = envelope_ascii_load(fields[i], ep, buf);
				if (ret == 0)
					goto err;
				buf = nextline;
				break;
			}
		}
d87 12
a98 2
		/* unknown keyword */
		if (i == n)
d100 7
d108 1
d116 45
d163 1
a163 1
	char	buf[8192];
d165 16
a180 56
	enum envelope_field fields[] = {
		EVP_VERSION,
		EVP_TAG,
		EVP_TYPE,
		EVP_HELO,
		EVP_HOSTNAME,
		EVP_ERRORLINE,
		EVP_SOCKADDR,
		EVP_SENDER,
		EVP_RCPT,
		EVP_DEST,
		EVP_CTIME,
		EVP_LASTTRY,
		EVP_LASTBOUNCE,
		EVP_EXPIRE,
		EVP_RETRY,
		EVP_FLAGS
	};
	enum envelope_field mda_fields[] = {
		EVP_MDA_METHOD,
		EVP_MDA_USERTABLE,
		EVP_MDA_BUFFER,
		EVP_MDA_USER
	};
	enum envelope_field mta_fields[] = {
		EVP_MTA_RELAY_SOURCE,
		EVP_MTA_RELAY_CERT,
		EVP_MTA_RELAY_AUTH,
		EVP_MTA_RELAY_HELO,
		EVP_MTA_RELAY,
	};
	enum envelope_field bounce_fields[] = {
		EVP_BOUNCE_TYPE,
		EVP_BOUNCE_DELAY,
		EVP_BOUNCE_EXPIRE,
	};
	enum envelope_field *pfields = NULL;
	int	 i, n, l;
	char	*p;

	p = dest;
	n = sizeof(fields) / sizeof(enum envelope_field);
	for (i = 0; i < n; ++i) {
		bzero(buf, sizeof buf);
		if (! envelope_ascii_dump(fields[i], ep, buf, sizeof buf))
			goto err;
		if (buf[0] == '\0')
			continue;

		l = snprintf(dest, len, "%s: %s\n",
			envelope_ascii_field_name(fields[i]), buf);
		if (l == -1 || (size_t) l >= len)
			goto err;
		dest += l;
		len -= l;
	}
d184 4
a187 2
		pfields = mda_fields;
		n = sizeof(mda_fields) / sizeof(enum envelope_field);
d190 5
a194 2
		pfields = mta_fields;
		n = sizeof(mta_fields) / sizeof(enum envelope_field);
d197 3
a199 2
		pfields = bounce_fields;
		n = sizeof(bounce_fields) / sizeof(enum envelope_field);
d202 1
a202 1
		goto err;
d205 2
a206 17
	if (pfields) {
		for (i = 0; i < n; ++i) {
			bzero(buf, sizeof buf);
			if (! envelope_ascii_dump(pfields[i], ep, buf,
				sizeof buf))
				goto err;
			if (buf[0] == '\0')
				continue;

			l = snprintf(dest, len, "%s: %s\n",
				envelope_ascii_field_name(pfields[i]), buf);
			if (l == -1 || (size_t) l >= len)
				goto err;
			dest += l;
			len -= l;
		}
	}
a208 222

err:
	return (0);
}

char *
envelope_ascii_field_name(enum envelope_field field)
{
	switch (field) {
	case EVP_VERSION:
		return "version";
	case EVP_TAG:
		return "tag";
	case EVP_MSGID:
		return "msgid";
	case EVP_TYPE:
		return "type";
	case EVP_HELO:
		return "helo";
	case EVP_HOSTNAME:
		return "hostname";
	case EVP_ERRORLINE:
		return "errorline";
	case EVP_SOCKADDR:
		return "sockaddr";
	case EVP_SENDER:
		return "sender";
	case EVP_RCPT:
		return "rcpt";
	case EVP_DEST:
		return "dest";
	case EVP_CTIME:
		return "ctime";
	case EVP_EXPIRE:
		return "expire";
	case EVP_RETRY:
		return "retry";
	case EVP_LASTTRY:
		return "last-try";
	case EVP_LASTBOUNCE:
		return "last-bounce";
	case EVP_FLAGS:
		return "flags";
	case EVP_MDA_METHOD:
		return "mda-method";
	case EVP_MDA_BUFFER:
		return "mda-buffer";
	case EVP_MDA_USER:
		return "mda-user";
	case EVP_MDA_USERTABLE:
		return "mda-usertable";
	case EVP_MTA_RELAY:
		return "mta-relay";
	case EVP_MTA_RELAY_AUTH:
		return "mta-relay-auth";
	case EVP_MTA_RELAY_CERT:
		return "mta-relay-cert";
	case EVP_MTA_RELAY_SOURCE:
		return "mta-relay-source";
	case EVP_MTA_RELAY_HELO:
		return "mta-relay-helo";
	case EVP_BOUNCE_TYPE:
		return "bounce-type";
	case EVP_BOUNCE_DELAY:
		return "bounce-delay";
	case EVP_BOUNCE_EXPIRE:
		return "bounce-expire";
	}

	return NULL;
}

int
envelope_ascii_load(enum envelope_field field, struct envelope *ep, char *buf)
{
	switch (field) {
	case EVP_VERSION:
		return ascii_load_uint32(&ep->version, buf);
	case EVP_TAG:
		return ascii_load_string(ep->tag, buf, sizeof ep->tag);
	case EVP_MSGID:
		return 1;
	case EVP_TYPE:
		return ascii_load_type(&ep->type, buf);
	case EVP_HELO:
		return ascii_load_string(ep->helo, buf, sizeof ep->helo);
	case EVP_HOSTNAME:
		return ascii_load_string(ep->hostname, buf,
		    sizeof ep->hostname);
	case EVP_ERRORLINE:
		return ascii_load_string(ep->errorline, buf,
		    sizeof ep->errorline);
	case EVP_SOCKADDR:
		return ascii_load_sockaddr(&ep->ss, buf);
	case EVP_SENDER:
		return ascii_load_mailaddr(&ep->sender, buf);
	case EVP_RCPT:
		return ascii_load_mailaddr(&ep->rcpt, buf);
	case EVP_DEST:
		return ascii_load_mailaddr(&ep->dest, buf);
	case EVP_MDA_METHOD:
		return ascii_load_mda_method(&ep->agent.mda.method, buf);
	case EVP_MDA_BUFFER:
		return ascii_load_string(ep->agent.mda.buffer, buf,
		    sizeof ep->agent.mda.buffer);
	case EVP_MDA_USER:
		return ascii_load_string(ep->agent.mda.username, buf,
		    sizeof ep->agent.mda.username);
	case EVP_MDA_USERTABLE:
		return ascii_load_string(ep->agent.mda.usertable, buf,
		    sizeof ep->agent.mda.usertable);
	case EVP_MTA_RELAY_SOURCE:
		return ascii_load_string(ep->agent.mta.relay.sourcetable, buf,
		    sizeof ep->agent.mta.relay.sourcetable);
	case EVP_MTA_RELAY_CERT:
		return ascii_load_string(ep->agent.mta.relay.cert, buf,
		    sizeof ep->agent.mta.relay.cert);
	case EVP_MTA_RELAY_AUTH:
		return ascii_load_string(ep->agent.mta.relay.authtable, buf,
		    sizeof ep->agent.mta.relay.authtable);
	case EVP_MTA_RELAY_HELO:
		return ascii_load_string(ep->agent.mta.relay.helotable, buf,
		    sizeof ep->agent.mta.relay.helotable);
	case EVP_MTA_RELAY:
		return ascii_load_mta_relay_url(&ep->agent.mta.relay, buf);
	case EVP_CTIME:
		return ascii_load_time(&ep->creation, buf);
	case EVP_EXPIRE:
		return ascii_load_time(&ep->expire, buf);
	case EVP_RETRY:
		return ascii_load_uint16(&ep->retry, buf);
	case EVP_LASTTRY:
		return ascii_load_time(&ep->lasttry, buf);
	case EVP_LASTBOUNCE:
		return ascii_load_time(&ep->lastbounce, buf);
	case EVP_FLAGS:
		return ascii_load_flags(&ep->flags, buf);
	case EVP_BOUNCE_TYPE:
		return ascii_load_bounce_type(&ep->agent.bounce.type, buf);
	case EVP_BOUNCE_DELAY:
		return ascii_load_time(&ep->agent.bounce.delay, buf);
	case EVP_BOUNCE_EXPIRE:
		return ascii_load_time(&ep->agent.bounce.expire, buf);
	}
	return 0;
}

int
envelope_ascii_dump(enum envelope_field field, const struct envelope *ep,
    char *buf, size_t len)
{
	switch (field) {
	case EVP_VERSION:
		return ascii_dump_uint32(SMTPD_ENVELOPE_VERSION, buf, len);
	case EVP_TAG:
		return ascii_dump_string(ep->tag, buf, len);
	case EVP_MSGID:
		return 1;
	case EVP_TYPE:
		return ascii_dump_type(ep->type, buf, len);
	case EVP_HELO:
		return ascii_dump_string(ep->helo, buf, len);
	case EVP_HOSTNAME:
		return ascii_dump_string(ep->hostname, buf, len);
	case EVP_ERRORLINE:
		return ascii_dump_string(ep->errorline, buf, len);
	case EVP_SOCKADDR:
		return ascii_dump_string(ss_to_text(&ep->ss), buf, len);
	case EVP_SENDER:
		return ascii_dump_mailaddr(&ep->sender, buf, len);
	case EVP_RCPT:
		return ascii_dump_mailaddr(&ep->rcpt, buf, len);
	case EVP_DEST:
		return ascii_dump_mailaddr(&ep->dest, buf, len);
	case EVP_MDA_METHOD:
		return ascii_dump_mda_method(ep->agent.mda.method, buf, len);
	case EVP_MDA_BUFFER:
		return ascii_dump_string(ep->agent.mda.buffer, buf, len);
	case EVP_MDA_USER:
		return ascii_dump_string(ep->agent.mda.username, buf, len);
	case EVP_MDA_USERTABLE:
		return ascii_dump_string(ep->agent.mda.usertable, buf, len);
	case EVP_MTA_RELAY_SOURCE:
		return ascii_dump_string(ep->agent.mta.relay.sourcetable,
		    buf, len);
	case EVP_MTA_RELAY_CERT:
		return ascii_dump_string(ep->agent.mta.relay.cert,
		    buf, len);
	case EVP_MTA_RELAY_AUTH:
		return ascii_dump_string(ep->agent.mta.relay.authtable,
		    buf, len);
	case EVP_MTA_RELAY_HELO:
		return ascii_dump_string(ep->agent.mta.relay.helotable,
		    buf, len);
	case EVP_MTA_RELAY:
		if (ep->agent.mta.relay.hostname[0])
			return ascii_dump_mta_relay_url(&ep->agent.mta.relay, buf, len);
		return 1;
	case EVP_CTIME:
		return ascii_dump_time(ep->creation, buf, len);
	case EVP_EXPIRE:
		return ascii_dump_time(ep->expire, buf, len);
	case EVP_RETRY:
		return ascii_dump_uint16(ep->retry, buf, len);
	case EVP_LASTTRY:
		return ascii_dump_time(ep->lasttry, buf, len);
	case EVP_LASTBOUNCE:
		return ascii_dump_time(ep->lastbounce, buf, len);
	case EVP_FLAGS:
		return ascii_dump_flags(ep->flags, buf, len);
	case EVP_BOUNCE_TYPE:
		return ascii_dump_bounce_type(ep->agent.bounce.type, buf, len);
	case EVP_BOUNCE_DELAY:
		if (ep->agent.bounce.type != B_WARNING)
			return (1);
		return ascii_dump_time(ep->agent.bounce.delay, buf, len);
	case EVP_BOUNCE_EXPIRE:
		if (ep->agent.bounce.type != B_WARNING)
			return (1);
		return ascii_dump_time(ep->agent.bounce.expire, buf, len);
	}
	return 0;
d238 1
a238 1
	*dest = (time_t) strtonum(buf, 0, 0x7fffffff, &errstr);
d362 125
d501 1
a501 1
	return bsnprintf(dest, len, "%" PRId64, (int64_t) src);
d612 130
@


1.19
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.18 2013/01/26 09:37:23 gilles Exp $	*/
a21 1
#include <sys/param.h>
d594 2
d701 3
@


1.18
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.17 2012/10/12 08:51:02 eric Exp $	*/
d560 3
@


1.17
log
@Extend the "retry" field to 16 bits.  The new quadratic retry formula
makes the maximum retry delay a bit to small on 8 bits.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.16 2012/10/11 21:49:11 gilles Exp $	*/
d4 1
a4 1
 * Copyright (c) 2011 Gilles Chehade <gilles@@openbsd.org>
d55 3
a57 2
static int ascii_load_flags(enum delivery_flags *, char *);
static int ascii_load_mta_relay_flags(uint8_t *, char *);
d62 1
a62 1
static int ascii_dump_string(char *, char *, size_t);
d65 4
a68 4
static int ascii_dump_mailaddr(struct mailaddr *, char *, size_t);
static int ascii_dump_flags(enum delivery_flags, char *, size_t);
static int ascii_dump_mta_relay_port(uint16_t, char *, size_t);
static int ascii_dump_mta_relay_flags(uint8_t, char *, size_t);
d89 1
a89 1
envelope_load_buffer(struct envelope *ep, char *buf, size_t buflen)
d93 1
d106 1
d110 1
d113 1
a113 2
		EVP_MTA_RELAY_HOST,
		EVP_MTA_RELAY_PORT,
d115 6
a120 2
		EVP_MTA_RELAY_FLAGS,
		EVP_MTA_RELAY_AUTHMAP
d123 1
d129 5
d179 1
a179 1
envelope_dump_buffer(struct envelope *ep, char *dest, size_t len)
d185 1
d196 1
d203 1
d208 1
a208 2
		EVP_MTA_RELAY_HOST,
		EVP_MTA_RELAY_PORT,
d210 8
a217 2
		EVP_MTA_RELAY_AUTHMAP,
		EVP_MTA_RELAY_FLAGS
d250 2
a251 1
		/* nothing ! */
d287 2
d315 2
d325 6
a330 6
	case EVP_MTA_RELAY_HOST:
		return "mta-relay-host";
	case EVP_MTA_RELAY_PORT:
		return "mta-relay-port";
	case EVP_MTA_RELAY_FLAGS:
		return "mta-relay-flags";
d333 10
a342 2
	case EVP_MTA_RELAY_AUTHMAP:
		return "mta-relay-authmap";
d354 2
d382 8
a389 13
		return ascii_load_string(ep->agent.mda.user, buf,
		    sizeof ep->agent.mda.user);
	case EVP_MTA_RELAY_HOST:
		return ascii_load_string(ep->agent.mta.relay.hostname, buf,
		    sizeof ep->agent.mta.relay.hostname);
	case EVP_MTA_RELAY_PORT: {
		uint16_t port;

		if (! ascii_load_uint16(&port, buf))
			return 0;
		ep->agent.mta.relay.port = htons(port);
		return 1;
	}
d393 8
a400 6
	case EVP_MTA_RELAY_FLAGS:
		return ascii_load_mta_relay_flags(&ep->agent.mta.relay.flags,
		    buf);
	case EVP_MTA_RELAY_AUTHMAP:
		return ascii_load_string(ep->agent.mta.relay.authmap, buf,
		    sizeof ep->agent.mta.relay.authmap);
d409 2
d413 6
d424 1
a424 1
envelope_ascii_dump(enum envelope_field field, struct envelope *ep,
d430 2
d455 5
a459 6
		return ascii_dump_string(ep->agent.mda.user, buf, len);
	case EVP_MTA_RELAY_HOST:
		return ascii_dump_string(ep->agent.mta.relay.hostname,
		    buf, len);
	case EVP_MTA_RELAY_PORT:
		return ascii_dump_mta_relay_port(ep->agent.mta.relay.port,
d464 2
a465 2
	case EVP_MTA_RELAY_FLAGS:
		return ascii_dump_mta_relay_flags(ep->agent.mta.relay.flags,
d467 2
a468 2
	case EVP_MTA_RELAY_AUTHMAP:
		return ascii_dump_string(ep->agent.mta.relay.authmap,
d470 4
d482 2
d486 10
d600 1
a600 1
	if (! email_to_mailaddr(dest, buf))
d606 1
a606 1
ascii_load_flags(enum delivery_flags *dest, char *buf)
d612 1
a612 1
			*dest |= DF_AUTHENTICATED;
d616 1
a616 1
			*dest |= DF_BOUNCE;
d618 1
a618 1
			*dest |= DF_INTERNAL;
d626 1
a626 1
ascii_load_mta_relay_flags(uint8_t *dest, char *buf)
d628 4
a631 1
	char *flag;
d633 9
a641 12
	while ((flag = strsep(&buf, " ,|")) != NULL) {
		if (strcasecmp(flag, "smtps") == 0)
			*dest |= F_SMTPS;
		else if (strcasecmp(flag, "tls") == 0)
			*dest |= F_STARTTLS;
		else if (strcasecmp(flag, "auth") == 0)
			*dest |= F_AUTH;
		else if (strcasecmp(flag, "backup") == 0)
			*dest |= F_BACKUP;
		else
			return 0;
	}
d664 1
a664 1
ascii_dump_string(char *src, char *dest, size_t len)
d716 1
a716 1
ascii_dump_mailaddr(struct mailaddr *addr, char *dest, size_t len)
d723 1
a723 7
ascii_dump_mta_relay_port(uint16_t port, char *buf, size_t len)
{
	return bsnprintf(buf, len, "%d", ntohs(port));
}

static int
ascii_dump_mta_relay_flags(uint8_t flags, char *buf, size_t len)
d729 3
a731 3
		if (flags & F_SMTPS)
			cpylen = strlcat(buf, "smtps", len);
		if (flags & F_STARTTLS) {
d734 1
a734 1
			cpylen = strlcat(buf, "tls", len);
d736 1
a736 1
		if (flags & F_AUTH) {
d739 1
a739 6
			cpylen = strlcat(buf, "auth", len);
		}
		if (flags & F_BACKUP) {
			if (buf[0] != '\0')
				strlcat(buf, " ", len);
			cpylen = strlcat(buf, "backup", len);
d747 7
a753 1
ascii_dump_flags(enum delivery_flags flags, char *buf, size_t len)
d755 1
a755 1
	size_t cpylen = 0;
d757 9
a765 14
	buf[0] = '\0';
	if (flags) {
		if (flags & DF_AUTHENTICATED)
			cpylen = strlcat(buf, "authenticated", len);
		if (flags & DF_BOUNCE) {
			if (buf[0] != '\0')
				strlcat(buf, " ", len);
			cpylen = strlcat(buf, "bounce", len);
		}
		if (flags & DF_INTERNAL) {
			if (buf[0] != '\0')
				strlcat(buf, " ", len);
			cpylen = strlcat(buf, "internal", len);
		}
d767 1
a767 2

	return cpylen < len ? 1 : 0;
@


1.16
log
@- remove dead store

spotted by clang
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.15 2012/10/11 21:47:48 gilles Exp $	*/
a46 1
static int ascii_load_uint8(uint8_t *, char *);
d58 1
a58 1
static int ascii_dump_uint8(uint8_t, char *, size_t);
d373 1
a373 1
		return ascii_load_uint8(&ep->retry, buf);
d433 1
a433 1
		return ascii_dump_uint8(ep->retry, buf, len);
a442 11
ascii_load_uint8(uint8_t *dest, char *buf)
{
	const char *errstr;

	*dest = strtonum(buf, 0, 0xff, &errstr);
	if (errstr)
		return 0;
	return 1;
}

static int
d588 1
a588 1
ascii_dump_uint8(uint8_t src, char *dest, size_t len)
@


1.15
log
@- remove dead store

spotted by clang
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.14 2012/09/26 19:52:20 eric Exp $	*/
d693 1
a693 1
				cpylen = strlcat(buf, " ", len);
d698 1
a698 1
				cpylen = strlcat(buf, " ", len);
d703 1
a703 1
				cpylen = strlcat(buf, " ", len);
@


1.14
log
@Stop using the delivery_data union (field "to") in delivery_mda.
It's confusing and not necessary as it's only used for "buffer".
Instead, just add a "buffer" member in the structure and rename
"as_user" to "user".

The delivery_data union becomes an anonymous union in expandnode,
which is the only other place where it's used.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.13 2012/09/19 18:20:36 eric Exp $	*/
d722 1
a722 1
				cpylen = strlcat(buf, " ", len);
d727 1
a727 1
				cpylen = strlcat(buf, " ", len);
@


1.13
log
@Remove DF_ENQUEUE flag. It is mostly unused and logically broken.
Ignore it in existing envelopes until it gets completely dropped.
Change "smtpctl show queue" to display the address family of the
envelope source instead of the ENQUEUE flag.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.12 2012/09/15 15:12:11 eric Exp $	*/
d344 2
a345 2
		return ascii_load_string(ep->agent.mda.to.buffer, buf,
		    sizeof ep->agent.mda.to.buffer);
d347 2
a348 2
		return ascii_load_string(ep->agent.mda.as_user, buf,
		    sizeof ep->agent.mda.as_user);
d411 1
a411 1
		return ascii_dump_string(ep->agent.mda.to.buffer, buf, len);
d413 1
a413 1
		return ascii_dump_string(ep->agent.mda.as_user, buf, len);
@


1.12
log
@When enqueueing from the local socket, the input address is faked as "::1".
This is confusing and even broken, as systems running with ipv6 disabled on
lo0 will not be able to enqueue mails using the local socket.

So instead, use AF_LOCAL and print it as "local" in envelopes/maps.  Add it
to the "localhost" and "all" maps accordingly, and fix the ruleset matching.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.11 2012/09/02 12:21:22 chl Exp $	*/
d568 1
a568 1
			*dest |= DF_ENQUEUED;
a719 5
		if (flags & DF_ENQUEUED) {
			if (buf[0] != '\0')
				cpylen = strlcat(buf, " ", len);
			cpylen = strlcat(buf, "enqueued", len);
		}
@


1.11
log
@remove warning

asked by gilles@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.10 2012/08/24 13:21:56 chl Exp $	*/
d515 4
a518 1
	if (strncasecmp("IPv6:", buf, 5) == 0) {
@


1.10
log
@In envelope ascii dump/load:
- remove loading of evpid.
- don't dump the msgid
- ignore msgid at load
- remove now unused functions ascii_{dump,load}_uint{32,64}_hex()

With inputs from eric@@ and gilles@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.9 2012/08/21 20:19:46 eric Exp $	*/
d390 2
@


1.9
log
@Allow smtpd to work as a backup MX, relaying only to MXs with higher
priority in the DNS record. For example:

   accept for domain "foo.org" relay backup "mx3.foo.org"

will relay mails for "foo.org" using only hosts with higher priority
(i.e. lower value) than "mx3.foo.org", which is supposed to be the
current server.

If the specified backup MX is not found in the DNS record, relaying
works as normal.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.8 2012/08/19 14:16:58 chl Exp $	*/
a50 2
static int ascii_load_uint32_hex(uint32_t *, char *);
static int ascii_load_uint64_hex(uint64_t *, char *);
a61 2
static int ascii_dump_uint32_hex(uint32_t, char *, size_t);
static int ascii_dump_uint64_hex(uint64_t, char *, size_t);
a92 1
		EVP_ID,
a172 1
		EVP_MSGID,
a265 2
	case EVP_ID:
		return "id";
a317 3
	uint32_t	msgid;
	int		r;

a320 2
	case EVP_ID:
		return ascii_load_uint64_hex(&ep->id, buf);
d322 1
a322 3
		if ((r = ascii_load_uint32_hex(&msgid, buf)))
			ep->id = msgid_to_evpid(msgid);
		return (r);
a389 4
	case EVP_ID:
		return ascii_dump_uint64_hex(ep->id, buf, len);
	case EVP_MSGID:
		return ascii_dump_uint32_hex(evpid_to_msgid(ep->id), buf, len);
a485 26
ascii_load_uint32_hex(uint32_t *dest, char *buf)
{
	uint64_t	u;
	
	if (ascii_load_uint64_hex(&u, buf) == 0)
		return (0);
	if (u > (uint64_t)0xffffffff)
		return (0);
	*dest = (uint32_t)u;
	return (1);
}

static int
ascii_load_uint64_hex(uint64_t *dest, char *buf)
{
	char *endptr;
	
	*dest = strtoull(buf, &endptr, 16);
	if (buf[0] == '\0' || *endptr != '\0')
		return 0;
	if (errno == ERANGE && *dest == ULLONG_MAX)
		return 0;
	return 1;
}

static int
a609 12
}

static int
ascii_dump_uint32_hex(uint32_t src, char *dest, size_t len)
{
	return bsnprintf(dest, len, "%08" PRIx32, src);
}

static int
ascii_dump_uint64_hex(uint64_t src, char *dest, size_t len)
{
	return bsnprintf(dest, len, "%016" PRIx64, src);
@


1.8
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.7 2012/08/19 10:32:32 chl Exp $	*/
d631 2
d752 5
@


1.7
log
@Kill envelope_{dump,load}_file() and replace them with envelope_{dump,load}_buffer().

with input from eric@@

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.6 2012/06/03 19:52:56 eric Exp $	*/
d47 3
a49 3
static int ascii_load_uint8(u_int8_t *, char *);
static int ascii_load_uint16(u_int16_t *, char *);
static int ascii_load_uint32(u_int32_t *, char *);
d51 2
a52 2
static int ascii_load_uint32_hex(u_int32_t *, char *);
static int ascii_load_uint64_hex(u_int64_t *, char *);
d59 1
a59 1
static int ascii_load_mta_relay_flags(u_int8_t *, char *);
d61 2
a62 2
static int ascii_dump_uint8(u_int8_t, char *, size_t);
static int ascii_dump_uint32(u_int32_t, char *, size_t);
d64 2
a65 2
static int ascii_dump_uint32_hex(u_int32_t, char *, size_t);
static int ascii_dump_uint64_hex(u_int64_t, char *, size_t);
d71 2
a72 2
static int ascii_dump_mta_relay_port(u_int16_t, char *, size_t);
static int ascii_dump_mta_relay_flags(u_int8_t, char *, size_t);
d368 1
a368 1
		u_int16_t port;
d461 1
a461 1
ascii_load_uint8(u_int8_t *dest, char *buf)
d472 1
a472 1
ascii_load_uint16(u_int16_t *dest, char *buf)
d483 1
a483 1
ascii_load_uint32(u_int32_t *dest, char *buf)
d505 1
a505 1
ascii_load_uint32_hex(u_int32_t *dest, char *buf)
d518 1
a518 1
ascii_load_uint64_hex(u_int64_t *dest, char *buf)
d620 1
a620 1
ascii_load_mta_relay_flags(u_int8_t *dest, char *buf)
d638 1
a638 1
ascii_dump_uint8(u_int8_t src, char *dest, size_t len)
d644 1
a644 1
ascii_dump_uint32(u_int32_t src, char *dest, size_t len)
d656 1
a656 1
ascii_dump_uint32_hex(u_int32_t src, char *dest, size_t len)
d662 1
a662 1
ascii_dump_uint64_hex(u_int64_t src, char *dest, size_t len)
d727 1
a727 1
ascii_dump_mta_relay_port(u_int16_t port, char *buf, size_t len)
d733 1
a733 1
ascii_dump_mta_relay_flags(u_int8_t flags, char *buf, size_t len)
@


1.6
log
@Do not store the envelope id within the envelope, only the message id.
Make sure existing envelopes can be properly loaded.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.5 2012/06/01 09:24:58 eric Exp $	*/
d93 1
a93 1
envelope_load_file(struct envelope *ep, FILE *fp)
a94 3
	char *buf, *lbuf;
	char *field;
	size_t	len;
d121 5
a125 3
	int	i;
	int	n;
	int	ret;
a128 11
	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}
d130 5
d156 1
d165 1
a165 2
	free(lbuf);
	return 1;
d168 1
a168 2
	free(lbuf);
	return 0;
d172 1
a172 1
envelope_dump_file(struct envelope *ep, FILE *fp)
d206 2
a207 2
	int	i;
	int	n;
d209 1
d217 7
a223 2
		fprintf(fp, "%s: %s\n",
		    envelope_ascii_field_name(fields[i]), buf);
d250 7
a256 2
			fprintf(fp, "%s: %s\n",
			    envelope_ascii_field_name(pfields[i]), buf);
d260 1
a260 4
	if (fflush(fp) != 0)
		goto err;

	return 1;
d263 1
a263 1
	return 0;
@


1.5
log
@move envelope dump/load functions to envelope.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.4 2012/01/15 16:47:49 chl Exp $	*/
d51 1
d64 1
d101 1
d186 1
a186 1
		EVP_ID,
d274 2
d326 3
d334 4
d407 2
d505 13
d653 6
@


1.4
log
@Add ascii_{load,dump}_time() to properly deal with time_t.

This fixes build warnings for portable smptd.

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.3 2012/01/12 15:01:33 eric Exp $	*/
d88 173
@


1.3
log
@remove envelope_get_errormsg() and move envelope_set_errormsg()
to envelope.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.2 2012/01/11 23:25:29 eric Exp $	*/
d50 1
d62 1
a62 1
static int ascii_dump_uint64(u_int64_t, char *, size_t);
d200 1
a200 1
		return ascii_load_uint32(&ep->creation, buf);
d202 1
a202 1
		return ascii_load_uint32(&ep->expire, buf);
d206 1
a206 1
		return ascii_load_uint32(&ep->lasttry, buf);
d260 1
a260 1
		return ascii_dump_uint64(ep->creation, buf, len);
d262 1
a262 1
		return ascii_dump_uint64(ep->expire, buf, len);
d266 1
a266 1
		return ascii_dump_uint64(ep->lasttry, buf, len);
d307 11
d450 1
a450 1
ascii_dump_uint64(u_int64_t src, char *dest, size_t len)
d452 1
a452 1
	return bsnprintf(dest, len, "%" PRId64, src);
@


1.2
log
@fix flags writing

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envelope.c,v 1.1 2012/01/11 22:24:37 gilles Exp $	*/
d70 18
@


1.1
log
@implement an envelope_ascii API that's not tied to a specific queue_backend
simplify queue_fsqueue
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d530 1
a530 1
			if (buf[0] == '\0')
d535 1
a535 1
			if (buf[0] == '\0')
d540 1
a540 1
			if (buf[0] == '\0')
@

