head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.14
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.12
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.10
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	ZBTFreARDSMmzOIV;

1.4
date	2013.11.18.11.47.16;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.25.20.08.31;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.5
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@/*	$OpenBSD: dict.c,v 1.4 2013/11/18 11:47:16 eric Exp $	*/

/*
 * Copyright (c) 2012 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/tree.h>

#include <sys/socket.h>	/* for smtpd.h */
#include <sys/queue.h>	/* for smtpd.h */
#include <stdio.h>	/* for smtpd.h */
#include <imsg.h>	/* for smtpd.h */

#include <err.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "smtpd.h"

struct dictentry {
	SPLAY_ENTRY(dictentry)	entry;
	const char	       *key;
	void		       *data;
};

static int dictentry_cmp(struct dictentry *, struct dictentry *);

SPLAY_PROTOTYPE(_dict, dictentry, entry, dictentry_cmp);

int
dict_check(struct dict *d, const char *k)
{
	struct dictentry	key;

	key.key = k;
	return (SPLAY_FIND(_dict, &d->dict, &key) != NULL);
}

static inline struct dictentry *
dict_alloc(const char *k, void *data)
{
	struct dictentry	*e;
	size_t			 s = strlen(k) + 1;
	void			*t;

	if ((e = malloc(sizeof(*e) + s)) == NULL)
		return NULL;

	e->key = t = (char*)(e) + sizeof(*e);
	e->data = data;
	memmove(t, k, s);

	return (e);
}

void *
dict_set(struct dict *d, const char *k, void *data)
{
	struct dictentry	*entry, key;
	char			*old;

	key.key = k;
	if ((entry = SPLAY_FIND(_dict, &d->dict, &key)) == NULL) {
		if ((entry = dict_alloc(k, data)) == NULL)
			err(1, "dict_set: malloc");
		SPLAY_INSERT(_dict, &d->dict, entry);
		old = NULL;
		d->count += 1;
	} else {
		old = entry->data;
		entry->data = data;
	}

	return (old);
}

void
dict_xset(struct dict *d, const char * k, void *data)
{
	struct dictentry	*entry;

	if ((entry = dict_alloc(k, data)) == NULL)
		err(1, "dict_xset: malloc");
	if (SPLAY_INSERT(_dict, &d->dict, entry))
		errx(1, "dict_xset(%p, %s)", d, k);
	d->count += 1;
}

void *
dict_get(struct dict *d, const char *k)
{
	struct dictentry	key, *entry;

	key.key = k;
	if ((entry = SPLAY_FIND(_dict, &d->dict, &key)) == NULL)
		return (NULL);

	return (entry->data);
}

void *
dict_xget(struct dict *d, const char *k)
{
	struct dictentry	key, *entry;

	key.key = k;
	if ((entry = SPLAY_FIND(_dict, &d->dict, &key)) == NULL)
		errx(1, "dict_xget(%p, %s)", d, k);

	return (entry->data);
}

void *
dict_pop(struct dict *d, const char *k)
{
	struct dictentry	key, *entry;
	void			*data;

	key.key = k;
	if ((entry = SPLAY_FIND(_dict, &d->dict, &key)) == NULL)
		return (NULL);

	data = entry->data;
	SPLAY_REMOVE(_dict, &d->dict, entry);
	free(entry);
	d->count -= 1;

	return (data);
}

void *
dict_xpop(struct dict *d, const char *k)
{
	struct dictentry	key, *entry;
	void			*data;

	key.key = k;
	if ((entry = SPLAY_FIND(_dict, &d->dict, &key)) == NULL)
		errx(1, "dict_xpop(%p, %s)", d, k);

	data = entry->data;
	SPLAY_REMOVE(_dict, &d->dict, entry);
	free(entry);
	d->count -= 1;

	return (data);
}

int
dict_poproot(struct dict *d, void **data)
{
	struct dictentry	*entry;

	entry = SPLAY_ROOT(&d->dict);
	if (entry == NULL)
		return (0);
	if (data)
		*data = entry->data;
	SPLAY_REMOVE(_dict, &d->dict, entry);
	free(entry);
	d->count -= 1;

	return (1);
}

int
dict_root(struct dict *d, const char **k, void **data)
{
	struct dictentry	*entry;

	entry = SPLAY_ROOT(&d->dict);
	if (entry == NULL)
		return (0);
	if (k)
		*k = entry->key;
	if (data)
		*data = entry->data;
	return (1);
}

int
dict_iter(struct dict *d, void **hdl, const char **k, void **data)
{
	struct dictentry *curr = *hdl;

	if (curr == NULL)
		curr = SPLAY_MIN(_dict, &d->dict);
	else
		curr = SPLAY_NEXT(_dict, &d->dict, curr);

	if (curr) {
		*hdl = curr;
		if (k)
			*k = curr->key;
		if (data)
			*data = curr->data;
		return (1);
	}

	return (0);
}

int
dict_iterfrom(struct dict *d, void **hdl, const char *kfrom, const char **k,
    void **data)
{
	struct dictentry *curr = *hdl, key;

	if (curr == NULL) {
		if (kfrom == NULL)
			curr = SPLAY_MIN(_dict, &d->dict);
		else {
			key.key = kfrom;
			curr = SPLAY_FIND(_dict, &d->dict, &key);
			if (curr == NULL) {
				SPLAY_INSERT(_dict, &d->dict, &key);
				curr = SPLAY_NEXT(_dict, &d->dict, &key);
				SPLAY_REMOVE(_dict, &d->dict, &key);
			}
		}
	} else
		curr = SPLAY_NEXT(_dict, &d->dict, curr);

	if (curr) {
		*hdl = curr;
		if (k)
			*k = curr->key;
		if (data)
			*data = curr->data;
		return (1);
	}

	return (0);
}

void
dict_merge(struct dict *dst, struct dict *src)
{
	struct dictentry	*entry;

	while (!SPLAY_EMPTY(&src->dict)) {
		entry = SPLAY_ROOT(&src->dict);
		SPLAY_REMOVE(_dict, &src->dict, entry);
		if (SPLAY_INSERT(_dict, &dst->dict, entry))
			errx(1, "dict_merge: duplicate");
	}
	dst->count += src->count;
	src->count = 0;
}

static int
dictentry_cmp(struct dictentry *a, struct dictentry *b)
{
	return strcmp(a->key, b->key);
}

SPLAY_GENERATE(_dict, dictentry, entry, dictentry_cmp);
@


1.4
log
@change dict_poproot() prototype: do not take key placeholder parameter as
it can't work that way.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a28 1
//#include <inttypes.h>
d31 1
@


1.3
log
@allocate key storage dynamically instead of using a fixed size buffer
@
text
@d165 1
a165 1
dict_poproot(struct dict *d, const char **k, void **data)
a171 2
	if (k)
		*k = entry->key;
@


1.2
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dict.c,v 1.1 2013/01/26 09:37:23 gilles Exp $	*/
a34 1
#define	MAX_DICTKEY_SIZE	64
d37 1
a37 1
	char			key[MAX_DICTKEY_SIZE];
d50 13
a62 2
	if (strlcpy(key.key, k, sizeof key.key) >= sizeof key.key)
		errx(1, "dict_check(%p, %s): key too large", d, k);
d64 5
a68 1
	return (SPLAY_FIND(_dict, &d->dict, &key) != NULL);
d77 1
a77 2
	if (strlcpy(key.key, k, sizeof key.key) >= sizeof key.key)
		errx(1, "dict_set(%p, %s): key too large", d, k);
d79 1
a79 1
		if ((entry = malloc(sizeof *entry)) == NULL)
a80 1
		(void)strlcpy(entry->key, k, sizeof entry->key);
d84 1
a84 1
	} else
d86 2
a87 2

	entry->data = data;
d97 1
a97 1
	if ((entry = malloc(sizeof *entry)) == NULL)
a98 3
	if (strlcpy(entry->key, k, sizeof entry->key) >= sizeof entry->key)
		errx(1, "dict_xset(%p, %s): key too large", d, k);
	entry->data = data;
d109 1
a109 2
	if (strlcpy(key.key, k, sizeof key.key) >= sizeof key.key)
		errx(1, "dict_get(%p, %s): key too large", d, k);
d121 1
a121 2
	if (strlcpy(key.key, k, sizeof key.key) >= sizeof key.key)
		errx(1, "dict_xget(%p, %s): key too large", d, k);
d134 1
a134 2
	if (strlcpy(key.key, k, sizeof key.key) >= sizeof key.key)
		errx(1, "dict_pop(%p, %s): key too large", d, k);
d152 1
a152 2
	if (strlcpy(key.key, k, sizeof key.key) >= sizeof key.key)
		errx(1, "dict_xpop(%p, %s): key too large", d, k);
d230 1
a230 4
			if (strlcpy(key.key, kfrom, sizeof key.key)
			    >= sizeof key.key)
				errx(1, "dict_iterfrom(%p, %s): key too large",
				    d, kfrom);
@


1.1
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
SPLAY_PROTOTYPE(dict, dictentry, entry, dictentry_cmp);
d54 1
a54 1
	return (SPLAY_FIND(dict, d, &key) != NULL);
d65 3
a67 2
	if ((entry = SPLAY_FIND(dict, d, &key)) == NULL) {
		entry = xmalloc(sizeof *entry, "dict_set");
d69 1
a69 1
		SPLAY_INSERT(dict, d, entry);
d71 1
d85 2
a86 1
	entry = xmalloc(sizeof *entry, "dict_xset");
d90 1
a90 1
	if (SPLAY_INSERT(dict, d, entry))
d92 1
d102 1
a102 1
	if ((entry = SPLAY_FIND(dict, d, &key)) == NULL)
d115 1
a115 1
	if ((entry = SPLAY_FIND(dict, d, &key)) == NULL)
d129 1
a129 1
	if ((entry = SPLAY_FIND(dict, d, &key)) == NULL)
d133 1
a133 1
	SPLAY_REMOVE(dict, d, entry);
d135 1
d148 1
a148 1
	if ((entry = SPLAY_FIND(dict, d, &key)) == NULL)
d152 1
a152 1
	SPLAY_REMOVE(dict, d, entry);
d154 1
d164 1
a164 1
	entry = SPLAY_ROOT(d);
d171 1
a171 1
	SPLAY_REMOVE(dict, d, entry);
d173 2
d183 1
a183 1
	entry = SPLAY_ROOT(d);
d199 1
a199 1
		curr = SPLAY_MIN(dict, d);
d201 1
a201 1
		curr = SPLAY_NEXT(dict, d, curr);
d223 1
a223 1
			curr = SPLAY_MIN(dict, d);
d229 1
a229 1
			curr = SPLAY_FIND(dict, d, &key);
d231 3
a233 3
				SPLAY_INSERT(dict, d, &key);
				curr = SPLAY_NEXT(dict, d, &key);
				SPLAY_REMOVE(dict, d, &key);
d237 1
a237 1
		curr = SPLAY_NEXT(dict, d, curr);
d256 4
a259 4
	while (!SPLAY_EMPTY(src)) {
		entry = SPLAY_ROOT(src);
		SPLAY_REMOVE(dict, src, entry);
		if (SPLAY_INSERT(dict, dst, entry))
d262 2
d272 1
a272 1
SPLAY_GENERATE(dict, dictentry, entry, dictentry_cmp);
@

