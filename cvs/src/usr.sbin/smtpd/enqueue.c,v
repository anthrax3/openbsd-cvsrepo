head	1.113;
access;
symbols
	OPENBSD_6_2:1.113.0.8
	OPENBSD_6_2_BASE:1.113
	OPENBSD_6_1:1.113.0.6
	OPENBSD_6_1_BASE:1.113
	OPENBSD_6_0:1.113.0.4
	OPENBSD_6_0_BASE:1.113
	OPENBSD_5_9:1.112.0.2
	OPENBSD_5_9_BASE:1.112
	OPENBSD_5_8:1.94.0.4
	OPENBSD_5_8_BASE:1.94
	OPENBSD_5_7:1.91.0.2
	OPENBSD_5_7_BASE:1.91
	OPENBSD_5_6:1.83.0.4
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.75.0.2
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.68.0.2
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.67.0.2
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.56.0.2
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.2
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9;
locks; strict;
comment	@ * @;


1.113
date	2016.07.03.14.30.33;	author gilles;	state Exp;
branches;
next	1.112;
commitid	h4Xkny10bo2QNYyX;

1.112
date	2016.02.03.08.03.21;	author gilles;	state Exp;
branches;
next	1.111;
commitid	XxS0r3uGjwajuXVI;

1.111
date	2016.01.12.17.29.43;	author sunil;	state Exp;
branches;
next	1.110;
commitid	bHpUcFTAHFMpObZb;

1.110
date	2015.12.29.17.57.03;	author millert;	state Exp;
branches;
next	1.109;
commitid	VXAg9kRqLIPjkE7F;

1.109
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.108;
commitid	ZxnqOQqX6IeYI9jW;

1.108
date	2015.12.14.10.22.11;	author jung;	state Exp;
branches;
next	1.107;
commitid	HRAnniyhGW9Sadln;

1.107
date	2015.12.07.12.29.19;	author sunil;	state Exp;
branches;
next	1.106;
commitid	NjgUX1eM1Q27CUqm;

1.106
date	2015.12.05.13.14.21;	author claudio;	state Exp;
branches;
next	1.105;
commitid	ZUSyGL2qGrdiWU8r;

1.105
date	2015.11.03.05.06.24;	author mmcc;	state Exp;
branches;
next	1.104;
commitid	dzuFxGfquM4XdS3g;

1.104
date	2015.10.27.21.01.09;	author gilles;	state Exp;
branches;
next	1.103;
commitid	D0yR3YTYj4ECQCD2;

1.103
date	2015.10.17.16.20.46;	author sunil;	state Exp;
branches;
next	1.102;
commitid	FqGSgVsM9pSwDikR;

1.102
date	2015.10.14.22.01.43;	author gilles;	state Exp;
branches;
next	1.101;
commitid	XSq2zfqNj1sXRZRl;

1.101
date	2015.10.14.20.51.53;	author gilles;	state Exp;
branches;
next	1.100;
commitid	7PSTfvtkTXHac8jG;

1.100
date	2015.10.13.08.06.22;	author gilles;	state Exp;
branches;
next	1.99;
commitid	8thfbI76QAnBIpoV;

1.99
date	2015.10.12.21.32.27;	author millert;	state Exp;
branches;
next	1.98;
commitid	Ncezb8PRADitRkeH;

1.98
date	2015.10.09.15.09.09;	author gilles;	state Exp;
branches;
next	1.97;
commitid	JVKxiIloJzaZJPvK;

1.97
date	2015.10.09.14.37.38;	author gilles;	state Exp;
branches;
next	1.96;
commitid	Av5gnXBLeZb6m0W2;

1.96
date	2015.10.06.06.04.46;	author gilles;	state Exp;
branches;
next	1.95;
commitid	kHsLvobU8ObZj5n9;

1.95
date	2015.09.07.15.36.53;	author gilles;	state Exp;
branches;
next	1.94;
commitid	8taqn8BdlYqlAC0r;

1.94
date	2015.05.13.07.34.49;	author gilles;	state Exp;
branches;
next	1.93;
commitid	0X2XJkzNo9Y4Vzvj;

1.93
date	2015.05.03.18.10.58;	author gilles;	state Exp;
branches;
next	1.92;
commitid	mjb5FuHgnQBFb6Hm;

1.92
date	2015.05.03.17.53.50;	author gilles;	state Exp;
branches;
next	1.91;
commitid	9k9mNuE7OhLV0LT6;

1.91
date	2015.02.27.12.17.36;	author millert;	state Exp;
branches;
next	1.90;
commitid	Udk76ZdyxmHuUdVI;

1.90
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.89;
commitid	ZBTFreARDSMmzOIV;

1.89
date	2015.01.15.09.05.37;	author gilles;	state Exp;
branches;
next	1.88;
commitid	7d9HtLBWZEr4hR4Z;

1.88
date	2014.11.12.10.28.07;	author gilles;	state Exp;
branches;
next	1.87;
commitid	3sNoOpzBh9GzEITj;

1.87
date	2014.11.06.08.55.06;	author gilles;	state Exp;
branches;
next	1.86;
commitid	wPE0khucVyyDlngb;

1.86
date	2014.10.26.11.26.08;	author gilles;	state Exp;
branches;
next	1.85;
commitid	Ni5Pl0cMPo5akNXT;

1.85
date	2014.10.08.10.56.01;	author deraadt;	state Exp;
branches;
next	1.84;
commitid	ZwAqRSSo1CMJv5ME;

1.84
date	2014.10.04.03.00.58;	author millert;	state Exp;
branches;
next	1.83;
commitid	wQZ50HSS6M5jE5sE;

1.83
date	2014.07.28.22.18.31;	author krw;	state Exp;
branches;
next	1.82;
commitid	sZ8VD3GKU76EuimB;

1.82
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches;
next	1.81;
commitid	0acpjAf5myNxgwB5;

1.81
date	2014.06.06.15.02.08;	author gilles;	state Exp;
branches;
next	1.80;
commitid	mNwax74b3pix10oi;

1.80
date	2014.04.05.13.43.16;	author gilles;	state Exp;
branches;
next	1.79;

1.79
date	2014.04.04.20.25.44;	author gilles;	state Exp;
branches;
next	1.78;

1.78
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.77;

1.77
date	2014.03.25.10.06.29;	author gilles;	state Exp;
branches;
next	1.76;

1.76
date	2014.03.13.14.28.33;	author chris;	state Exp;
branches;
next	1.75;

1.75
date	2014.02.04.15.44.05;	author eric;	state Exp;
branches;
next	1.74;

1.74
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.73;

1.73
date	2013.12.06.14.26.25;	author eric;	state Exp;
branches;
next	1.72;

1.72
date	2013.11.28.10.43.37;	author eric;	state Exp;
branches;
next	1.71;

1.71
date	2013.11.26.15.52.16;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2013.11.26.12.01.40;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2013.10.25.21.31.23;	author eric;	state Exp;
branches;
next	1.68;

1.68
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.67;

1.67
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.66;

1.66
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.65;

1.65
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.64;

1.64
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.63;

1.63
date	2012.09.27.20.34.15;	author chl;	state Exp;
branches;
next	1.62;

1.62
date	2012.09.27.12.26.35;	author chl;	state Exp;
branches;
next	1.61;

1.61
date	2012.08.23.16.10.19;	author todd;	state Exp;
branches;
next	1.60;

1.60
date	2012.08.23.13.16.02;	author todd;	state Exp;
branches;
next	1.59;

1.59
date	2012.08.23.13.06.29;	author todd;	state Exp;
branches;
next	1.58;

1.58
date	2012.08.23.13.04.41;	author todd;	state Exp;
branches;
next	1.57;

1.57
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.56;

1.56
date	2012.03.17.13.10.03;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2012.02.02.16.52.59;	author eric;	state Exp;
branches;
next	1.54;

1.54
date	2012.01.30.20.21.53;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2012.01.29.10.42.23;	author eric;	state Exp;
branches;
next	1.52;

1.52
date	2012.01.28.21.15.01;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2012.01.28.18.13.53;	author gilles;	state Exp;
branches;
next	1.50;

1.50
date	2011.12.15.17.23.54;	author eric;	state Exp;
branches;
next	1.49;

1.49
date	2011.11.14.16.54.19;	author eric;	state Exp;
branches;
next	1.48;

1.48
date	2011.11.02.12.01.20;	author eric;	state Exp;
branches;
next	1.47;

1.47
date	2011.08.29.21.43.08;	author chl;	state Exp;
branches;
next	1.46;

1.46
date	2011.08.29.18.49.29;	author chl;	state Exp;
branches;
next	1.45;

1.45
date	2011.08.26.14.39.47;	author chl;	state Exp;
branches;
next	1.44;

1.44
date	2011.06.09.03.53.39;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.42;

1.42
date	2011.03.26.10.59.59;	author gilles;	state Exp;
branches;
next	1.41;

1.41
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.40;

1.40
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.02.11.49.02;	author jacekm;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.02.19.16.53;	author chl;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.01.19.47.08;	author jacekm;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.21.17.50.28;	author jacekm;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.11.21.43.37;	author jacekm;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.23.17.16.03;	author jacekm;	state Exp;
branches;
next	1.30;

1.30
date	2009.12.13.22.02.55;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.12.14.03.59;	author jacekm;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.12.10.33.11;	author jacekm;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.12.10.14.07;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.13.20.34.51;	author chl;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.08.21.40.05;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.21.20.35.26;	author jacekm;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.18.00.04.26;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.16.11.46.17;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.15.16.50.06;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.27.11.37.30;	author jacekm;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.08.00.23.34;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.07.05.56.25;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.25.11.17.32;	author jacekm;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.14.15.05.12;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.21.18.12.05;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.17.16.26.18;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.04.16.15.35.06;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2009.04.05.16.10.42;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.01.12.10.24;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.29.15.20.34;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.29.10.18.27;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.28.19.49.57;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.28.14.15.51;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.28.11.27.57;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.28.00.19.27;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.28.00.09.54;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.27.22.48.29;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.113
log
@add -r option to enqueuer as compat interface for mailx

diff by Richard <richard@@aaazen.com>
@
text
@/*	$OpenBSD: enqueue.c,v 1.112 2016/02/03 08:03:21 gilles Exp $	*/

/*
 * Copyright (c) 2005 Henning Brauer <henning@@bulabula.org>
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 * Copyright (c) 2012 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/tree.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <grp.h>
#include <imsg.h>
#include <inttypes.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

#include "smtpd.h"

extern struct imsgbuf	*ibuf;

void usage(void);
static void build_from(char *, struct passwd *);
static int parse_message(FILE *, int, int, FILE *);
static void parse_addr(char *, size_t, int);
static void parse_addr_terminal(int);
static char *qualify_addr(char *);
static void rcpt_add(char *);
static int open_connection(void);
static int get_responses(FILE *, int);
static int send_line(FILE *, int, char *, ...);
static int enqueue_offline(int, char *[], FILE *, FILE *);
static int savedeadletter(struct passwd *, FILE *);

extern int srv_connected(void);

enum headerfields {
	HDR_NONE,
	HDR_FROM,
	HDR_TO,
	HDR_CC,
	HDR_BCC,
	HDR_SUBJECT,
	HDR_DATE,
	HDR_MSGID,
	HDR_MIME_VERSION,
	HDR_CONTENT_TYPE,
	HDR_CONTENT_DISPOSITION,
	HDR_CONTENT_TRANSFER_ENCODING,
	HDR_USER_AGENT
};

struct {
	char			*word;
	enum headerfields	 type;
} keywords[] = {
	{ "From:",			HDR_FROM },
	{ "To:",			HDR_TO },
	{ "Cc:",			HDR_CC },
	{ "Bcc:",			HDR_BCC },
	{ "Subject:",			HDR_SUBJECT },
	{ "Date:",			HDR_DATE },
	{ "Message-Id:",		HDR_MSGID },
	{ "MIME-Version:",		HDR_MIME_VERSION },
	{ "Content-Type:",		HDR_CONTENT_TYPE },
	{ "Content-Disposition:",	HDR_CONTENT_DISPOSITION },
	{ "Content-Transfer-Encoding:",	HDR_CONTENT_TRANSFER_ENCODING },
	{ "User-Agent:",		HDR_USER_AGENT },
};

#define	LINESPLIT		990
#define	SMTP_LINELEN		1000
#define	TIMEOUTMSG		"Timeout\n"

#define WSP(c)			(c == ' ' || c == '\t')

int		 verbose = 0;
static char	 host[HOST_NAME_MAX+1];
char		*user = NULL;
time_t		 timestamp;

struct {
	int	  fd;
	char	 *from;
	char	 *fromname;
	char	**rcpts;
	char	 *dsn_notify;
	char	 *dsn_ret;
	char	 *dsn_envid;
	int	  rcpt_cnt;
	int	  need_linesplit;
	int	  saw_date;
	int	  saw_msgid;
	int	  saw_from;
	int	  saw_mime_version;
	int	  saw_content_type;
	int	  saw_content_disposition;
	int	  saw_content_transfer_encoding;
	int	  saw_user_agent;
	int	  noheader;
} msg;

struct {
	uint		quote;
	uint		comment;
	uint		esc;
	uint		brackets;
	size_t		wpos;
	char		buf[SMTP_LINELEN];
} pstate;

static void
qp_encoded_write(FILE *fp, char *buf, size_t len)
{
	while (len) {
		if (*buf == '=')
			fprintf(fp, "=3D");
		else if (*buf == ' ' || *buf == '\t') {
			char *p = buf;

			while (*p != '\n') {
				if (*p != ' ' && *p != '\t')
					break;
				p++;
			}
			if (*p == '\n')
				fprintf(fp, "=%2X", *buf & 0xff);
			else
				fprintf(fp, "%c", *buf & 0xff);
		}
		else if (!isprint((unsigned char)*buf) && *buf != '\n')
			fprintf(fp, "=%2X", *buf & 0xff);
		else
			fprintf(fp, "%c", *buf);
		buf++;
		len--;
	}
}

int
enqueue(int argc, char *argv[], FILE *ofp)
{
	int			 i, ch, tflag = 0;
	char			*fake_from = NULL, *buf = NULL;
	struct passwd		*pw;
	FILE			*fp = NULL, *fout;
	size_t			 sz = 0, envid_sz = 0;
	ssize_t			 len;
	int			 fd;
	char			 sfn[] = "/tmp/smtpd.XXXXXXXXXX";
	char			*line;
	int			 dotted;
	int			 inheaders = 1;
	int			 save_argc;
	char			**save_argv;
	int			 no_getlogin = 0;

	memset(&msg, 0, sizeof(msg));
	time(&timestamp);

	save_argc = argc;
	save_argv = argv;

	while ((ch = getopt(argc, argv,
	    "A:B:b:E::e:F:f:iJ::L:mN:o:p:qr:R:StvV:x")) != -1) {
		switch (ch) {
		case 'f':
			fake_from = optarg;
			break;
		case 'F':
			msg.fromname = optarg;
			break;
		case 'N':
			msg.dsn_notify = optarg;
			break;
		case 'r':
			fake_from = optarg;
			break;
		case 'R':
			msg.dsn_ret = optarg;
			break;
		case 'S':
			no_getlogin = 1;
			break;
		case 't':
			tflag = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		case 'V':
			msg.dsn_envid = optarg;
			break;
		/* all remaining: ignored, sendmail compat */
		case 'A':
		case 'B':
		case 'b':
		case 'E':
		case 'e':
		case 'i':
		case 'L':
		case 'm':
		case 'o':
		case 'p':
		case 'x':
			break;
		case 'q':
			/* XXX: implement "process all now" */
			return (EX_SOFTWARE);
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (getmailname(host, sizeof(host)) == -1)
		errx(EX_NOHOST, "getmailname");
	if (no_getlogin) {
		if ((pw = getpwuid(getuid())) == NULL)
			user = "anonymous";
		if (pw != NULL)
			user = xstrdup(pw->pw_name, "enqueue");
	}
	else {
		uid_t ruid = getuid();

		if ((user = getlogin()) != NULL && *user != '\0') {
			if ((pw = getpwnam(user)) == NULL ||
			    (ruid != 0 && ruid != pw->pw_uid))
				pw = getpwuid(ruid);
		} else if ((pw = getpwuid(ruid)) == NULL) {
			user = "anonymous";
		}
		user = xstrdup(pw ? pw->pw_name : user, "enqueue");
	}

	build_from(fake_from, pw);

	while (argc > 0) {
		rcpt_add(argv[0]);
		argv++;
		argc--;
	}

	if ((fd = mkstemp(sfn)) == -1 ||
	    (fp = fdopen(fd, "w+")) == NULL) {
		int saved_errno = errno;
		if (fd != -1) {
			unlink(sfn);
			close(fd);
		}
		errc(EX_UNAVAILABLE, saved_errno, "mkstemp");
	}
	unlink(sfn);
	msg.noheader = parse_message(stdin, fake_from == NULL, tflag, fp);

	if (msg.rcpt_cnt == 0)
		errx(EX_SOFTWARE, "no recipients");

	/* init session */
	rewind(fp);

	/* check if working in offline mode */
	/* If the server is not running, enqueue the message offline */

	if (!srv_connected()) {
		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");

		return (enqueue_offline(save_argc, save_argv, fp, ofp));
	}

	if ((msg.fd = open_connection()) == -1)
		errx(EX_UNAVAILABLE, "server too busy");

	if (pledge("stdio wpath cpath", NULL) == -1)
		err(1, "pledge");

	fout = fdopen(msg.fd, "a+");
	if (fout == NULL)
		err(EX_UNAVAILABLE, "fdopen");

	/*
	 * We need to call get_responses after every command because we don't
	 * support PIPELINING on the server-side yet.
	 */

	/* banner */
	if (!get_responses(fout, 1))
		goto fail;

	if (!send_line(fout, verbose, "EHLO localhost\n"))
		goto fail;
	if (!get_responses(fout, 1))
		goto fail;

	if (msg.dsn_envid != NULL)
		envid_sz = strlen(msg.dsn_envid);

	if (!send_line(fout, verbose, "MAIL FROM:<%s> %s%s %s%s\n",
	    msg.from,
	    msg.dsn_ret ? "RET=" : "",
	    msg.dsn_ret ? msg.dsn_ret : "",
	    envid_sz ? "ENVID=" : "",
	    envid_sz ? msg.dsn_envid : ""))
		goto fail;
	if (!get_responses(fout, 1))
		goto fail;

	for (i = 0; i < msg.rcpt_cnt; i++) {
		if (!send_line(fout, verbose, "RCPT TO:<%s> %s%s\n",
		    msg.rcpts[i],
		    msg.dsn_notify ? "NOTIFY=" : "",
		    msg.dsn_notify ? msg.dsn_notify : ""))
			goto fail;
		if (!get_responses(fout, 1))
			goto fail;
	}

	if (!send_line(fout, verbose, "DATA\n"))
		goto fail;
	if (!get_responses(fout, 1))
		goto fail;

	/* add From */
	if (!msg.saw_from && !send_line(fout, 0, "From: %s%s<%s>\n",
	    msg.fromname ? msg.fromname : "", msg.fromname ? " " : "",
	    msg.from))
		goto fail;

	/* add Date */
	if (!msg.saw_date && !send_line(fout, 0, "Date: %s\n",
	    time_to_text(timestamp)))
		goto fail;

	if (msg.need_linesplit) {
		/* we will always need to mime encode for long lines */
		if (!msg.saw_mime_version && !send_line(fout, 0,
		    "MIME-Version: 1.0\n"))
			goto fail;
		if (!msg.saw_content_type && !send_line(fout, 0,
		    "Content-Type: text/plain; charset=unknown-8bit\n"))
			goto fail;
		if (!msg.saw_content_disposition && !send_line(fout, 0,
		    "Content-Disposition: inline\n"))
			goto fail;
		if (!msg.saw_content_transfer_encoding && !send_line(fout, 0,
		    "Content-Transfer-Encoding: quoted-printable\n"))
			goto fail;
	}

	/* add separating newline */
	if (msg.noheader) {
		if (!send_line(fout, 0, "\n"))
			goto fail;
		inheaders = 0;
	}

	for (;;) {
		if ((len = getline(&buf, &sz, fp)) == -1) {
			if (feof(fp))
				break;
			else
				err(EX_UNAVAILABLE, "getline");
		}

		/* newlines have been normalized on first parsing */
		if (buf[len-1] != '\n')
			errx(EX_SOFTWARE, "expect EOL");

		dotted = 0;
		if (buf[0] == '.') {
			if (fputc('.', fout) == EOF)
				goto fail;
			dotted = 1;
		}

		line = buf;

		if (inheaders) {
			if (strncasecmp("from ", line, 5) == 0)
				continue;
			if (strncasecmp("return-path: ", line, 13) == 0)
				continue;
		}

		if (msg.saw_content_transfer_encoding || msg.noheader ||
		    inheaders || !msg.need_linesplit) {
			if (!send_line(fout, 0, "%.*s", (int)len, line))
				goto fail;
			if (inheaders && buf[0] == '\n')
				inheaders = 0;
			continue;
		}

		/* we don't have a content transfer encoding, use our default */
		do {
			if (len < LINESPLIT) {
				qp_encoded_write(fout, line, len);
				break;
			}
			else {
				qp_encoded_write(fout, line,
				    LINESPLIT - 2 - dotted);
				if (!send_line(fout, 0, "=\n"))
					goto fail;
				line += LINESPLIT - 2 - dotted;
				len -= LINESPLIT - 2 - dotted;
			}
		} while (len);
	}
	free(buf);
	if (!send_line(fout, verbose, ".\n"))
		goto fail;
	if (!get_responses(fout, 1))
		goto fail;

	if (!send_line(fout, verbose, "QUIT\n"))
		goto fail;
	if (!get_responses(fout, 1))
		goto fail;

	fclose(fp);
	fclose(fout);

	exit(EX_OK);

fail:
	if (pw)
		savedeadletter(pw, fp);
	exit(EX_SOFTWARE);
}

static int
get_responses(FILE *fin, int n)
{
	char	*buf = NULL;
	size_t	 sz = 0;
	ssize_t	 len;
	int	 e, ret = 0;

	fflush(fin);
	if ((e = ferror(fin))) {
		warnx("ferror: %d", e);
		goto err;
	}

	while (n) {
		if ((len = getline(&buf, &sz, fin)) == -1) {
			if (ferror(fin)) {
				warn("getline");
				goto err;
			} else if (feof(fin))
				break;
			else
				err(EX_UNAVAILABLE, "getline");
		}

		/* account for \r\n linebreaks */
		if (len >= 2 && buf[len - 2] == '\r' && buf[len - 1] == '\n')
			buf[--len - 1] = '\n';

		if (len < 4) {
			warnx("bad response");
			goto err;
		}

		if (verbose)
			printf("<<< %.*s", (int)len, buf);

		if (buf[3] == '-')
			continue;
		if (buf[0] != '2' && buf[0] != '3') {
			warnx("command failed: %.*s", (int)len, buf);
			goto err;
		}
		n--;
	}

	ret = 1;
err:
	free(buf);
	return ret;
}

static int
send_line(FILE *fp, int v, char *fmt, ...)
{
	int ret = 0;
	va_list ap;

	va_start(ap, fmt);
	if (vfprintf(fp, fmt, ap) >= 0)
	    ret = 1;
	va_end(ap);

	if (ret && v) {
		printf(">>> ");
		va_start(ap, fmt);
		vprintf(fmt, ap);
		va_end(ap);
	}

	return (ret);
}

static void
build_from(char *fake_from, struct passwd *pw)
{
	char	*p;

	if (fake_from == NULL)
		msg.from = qualify_addr(user);
	else {
		if (fake_from[0] == '<') {
			if (fake_from[strlen(fake_from) - 1] != '>')
				errx(1, "leading < but no trailing >");
			fake_from[strlen(fake_from) - 1] = 0;
			p = xstrdup(fake_from + 1, "build_from");

			msg.from = qualify_addr(p);
			free(p);
		} else
			msg.from = qualify_addr(fake_from);
	}

	if (msg.fromname == NULL && fake_from == NULL && pw != NULL) {
		int	 len, apos;

		len = strcspn(pw->pw_gecos, ",");
		if ((p = memchr(pw->pw_gecos, '&', len))) {
			apos = p - pw->pw_gecos;
			if (asprintf(&msg.fromname, "%.*s%s%.*s",
			    apos, pw->pw_gecos,
			    pw->pw_name,
			    len - apos - 1, p + 1) == -1)
				err(1, NULL);
			msg.fromname[apos] = toupper((unsigned char)msg.fromname[apos]);
		} else {
			if (asprintf(&msg.fromname, "%.*s", len,
			    pw->pw_gecos) == -1)
				err(1, NULL);
		}
	}
}

static int
parse_message(FILE *fin, int get_from, int tflag, FILE *fout)
{
	char	*buf = NULL;
	size_t	 sz = 0;
	ssize_t	 len;
	uint	 i, cur = HDR_NONE;
	uint	 header_seen = 0, header_done = 0;

	memset(&pstate, 0, sizeof(pstate));
	for (;;) {
		if ((len = getline(&buf, &sz, fin)) == -1) {
			if (feof(fin))
				break;
			else
				err(EX_UNAVAILABLE, "getline");
		}

		/* account for \r\n linebreaks */
		if (len >= 2 && buf[len - 2] == '\r' && buf[len - 1] == '\n')
			buf[--len - 1] = '\n';

		if (len == 1 && buf[0] == '\n')		/* end of header */
			header_done = 1;

		if (!WSP(buf[0])) {	/* whitespace -> continuation */
			if (cur == HDR_FROM)
				parse_addr_terminal(1);
			if (cur == HDR_TO || cur == HDR_CC || cur == HDR_BCC)
				parse_addr_terminal(0);
			cur = HDR_NONE;
		}

		/* not really exact, if we are still in headers */
		if (len + (buf[len - 1] == '\n' ? 0 : 1) >= LINESPLIT)
			msg.need_linesplit = 1;

		for (i = 0; !header_done && cur == HDR_NONE &&
		    i < nitems(keywords); i++)
			if ((size_t)len > strlen(keywords[i].word) &&
			    !strncasecmp(buf, keywords[i].word,
			    strlen(keywords[i].word)))
				cur = keywords[i].type;

		if (cur != HDR_NONE)
			header_seen = 1;

		if (cur != HDR_BCC) {
			if (!send_line(fout, 0, "%.*s", (int)len, buf))
				err(1, "write error");
			if (buf[len - 1] != '\n') {
				if (fputc('\n', fout) == EOF)
					err(1, "write error");
			}
		}

		/*
		 * using From: as envelope sender is not sendmail compatible,
		 * but I really want it that way - maybe needs a knob
		 */
		if (cur == HDR_FROM) {
			msg.saw_from++;
			if (get_from)
				parse_addr(buf, len, 1);
		}

		if (tflag && (cur == HDR_TO || cur == HDR_CC || cur == HDR_BCC))
			parse_addr(buf, len, 0);

		if (cur == HDR_DATE)
			msg.saw_date++;
		if (cur == HDR_MSGID)
			msg.saw_msgid++;
		if (cur == HDR_MIME_VERSION)
			msg.saw_mime_version = 1;
		if (cur == HDR_CONTENT_TYPE)
			msg.saw_content_type = 1;
		if (cur == HDR_CONTENT_DISPOSITION)
			msg.saw_content_disposition = 1;
		if (cur == HDR_CONTENT_TRANSFER_ENCODING)
			msg.saw_content_transfer_encoding = 1;
		if (cur == HDR_USER_AGENT)
			msg.saw_user_agent = 1;
	}

	free(buf);
	return (!header_seen);
}

static void
parse_addr(char *s, size_t len, int is_from)
{
	size_t	 pos = 0;
	int	 terminal = 0;

	/* unless this is a continuation... */
	if (!WSP(s[pos]) && s[pos] != ',' && s[pos] != ';') {
		/* ... skip over everything before the ':' */
		for (; pos < len && s[pos] != ':'; pos++)
			;	/* nothing */
		/* ... and check & reset parser state */
		parse_addr_terminal(is_from);
	}

	/* skip over ':' ',' ';' and whitespace */
	for (; pos < len && !pstate.quote && (WSP(s[pos]) || s[pos] == ':' ||
	    s[pos] == ',' || s[pos] == ';'); pos++)
		;	/* nothing */

	for (; pos < len; pos++) {
		if (!pstate.esc && !pstate.quote && s[pos] == '(')
			pstate.comment++;
		if (!pstate.comment && !pstate.esc && s[pos] == '"')
			pstate.quote = !pstate.quote;

		if (!pstate.comment && !pstate.quote && !pstate.esc) {
			if (s[pos] == ':') {	/* group */
				for (pos++; pos < len && WSP(s[pos]); pos++)
					;	/* nothing */
				pstate.wpos = 0;
			}
			if (s[pos] == '\n' || s[pos] == '\r')
				break;
			if (s[pos] == ',' || s[pos] == ';') {
				terminal = 1;
				break;
			}
			if (s[pos] == '<') {
				pstate.brackets = 1;
				pstate.wpos = 0;
			}
			if (pstate.brackets && s[pos] == '>')
				terminal = 1;
		}

		if (!pstate.comment && !terminal && (!(!(pstate.quote ||
		    pstate.esc) && (s[pos] == '<' || WSP(s[pos]))))) {
			if (pstate.wpos >= sizeof(pstate.buf))
				errx(1, "address exceeds buffer size");
			pstate.buf[pstate.wpos++] = s[pos];
		}

		if (!pstate.quote && pstate.comment && s[pos] == ')')
			pstate.comment--;

		if (!pstate.esc && !pstate.comment && !pstate.quote &&
		    s[pos] == '\\')
			pstate.esc = 1;
		else
			pstate.esc = 0;
	}

	if (terminal)
		parse_addr_terminal(is_from);

	for (; pos < len && (s[pos] == '\r' || s[pos] == '\n'); pos++)
		;	/* nothing */

	if (pos < len)
		parse_addr(s + pos, len - pos, is_from);
}

static void
parse_addr_terminal(int is_from)
{
	if (pstate.comment || pstate.quote || pstate.esc)
		errx(1, "syntax error in address");
	if (pstate.wpos) {
		if (pstate.wpos >= sizeof(pstate.buf))
			errx(1, "address exceeds buffer size");
		pstate.buf[pstate.wpos] = '\0';
		if (is_from)
			msg.from = qualify_addr(pstate.buf);
		else
			rcpt_add(pstate.buf);
		pstate.wpos = 0;
	}
}

static char *
qualify_addr(char *in)
{
	char	*out;

	if (strlen(in) > 0 && strchr(in, '@@') == NULL) {
		if (asprintf(&out, "%s@@%s", in, host) == -1)
			err(1, "qualify asprintf");
	} else
		out = xstrdup(in, "qualify_addr");

	return (out);
}

static void
rcpt_add(char *addr)
{
	void	*nrcpts;
	char	*p;
	int	n;

	n = 1;
	p = addr;
	while ((p = strchr(p, ',')) != NULL) {
		n++;
		p++;
	}

	if ((nrcpts = reallocarray(msg.rcpts,
	    msg.rcpt_cnt + n, sizeof(char *))) == NULL)
		err(1, "rcpt_add realloc");
	msg.rcpts = nrcpts;

	while (n--) {
		if ((p = strchr(addr, ',')) != NULL)
			*p++ = '\0';
		msg.rcpts[msg.rcpt_cnt++] = qualify_addr(addr);
		if (p == NULL)
			break;
		addr = p;
	}
}

static int
open_connection(void)
{
	struct imsg	imsg;
	int		fd;
	int		n;

	imsg_compose(ibuf, IMSG_CTL_SMTP_SESSION, IMSG_VERSION, 0, -1, NULL, 0);

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (1) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		if ((n = imsg_get(ibuf, &imsg)) == -1)
			errx(1, "imsg_get error");
		if (n == 0)
			continue;

		switch (imsg.hdr.type) {
		case IMSG_CTL_OK:
			break;
		case IMSG_CTL_FAIL:
			errx(1, "server disallowed submission request");
		default:
			errx(1, "unexpected imsg reply type");
		}

		fd = imsg.fd;
		imsg_free(&imsg);

		break;
	}

	return fd;
}

static int
enqueue_offline(int argc, char *argv[], FILE *ifile, FILE *ofile)
{
	int	i, ch;

	for (i = 1; i < argc; i++) {
		if (strchr(argv[i], '|') != NULL) {
			warnx("%s contains illegal character", argv[i]);
			ftruncate(fileno(ofile), 0);
			exit(EX_SOFTWARE);
		}
		if (fprintf(ofile, "%s%s", i == 1 ? "" : "|", argv[i]) < 0)
			goto write_error;
	}

	if (fputc('\n', ofile) == EOF)
		goto write_error;

	while ((ch = fgetc(ifile)) != EOF) {
		if (fputc(ch, ofile) == EOF)
			goto write_error;
	}

	if (ferror(ifile)) {
		warn("read error");
		ftruncate(fileno(ofile), 0);
		exit(EX_UNAVAILABLE);
	}

	if (fclose(ofile) == EOF)
		goto write_error;

	return (EX_TEMPFAIL);
write_error:
	warn("write error");
	ftruncate(fileno(ofile), 0);
	exit(EX_UNAVAILABLE);
}

static int
savedeadletter(struct passwd *pw, FILE *in)
{
	char	 buffer[PATH_MAX];
	FILE	*fp;
	char	*buf = NULL;
	size_t	 sz = 0;
	ssize_t	 len;

	(void)snprintf(buffer, sizeof buffer, "%s/dead.letter", pw->pw_dir);

	if (fseek(in, 0, SEEK_SET) != 0)
		return 0;

	if ((fp = fopen(buffer, "w")) == NULL)
		return 0;

	/* add From */
	if (!msg.saw_from)
		fprintf(fp, "From: %s%s<%s>\n",
		    msg.fromname ? msg.fromname : "",
		    msg.fromname ? " " : "",
		    msg.from);

	/* add Date */
	if (!msg.saw_date)
		fprintf(fp, "Date: %s\n", time_to_text(timestamp));

	if (msg.need_linesplit) {
		/* we will always need to mime encode for long lines */
		if (!msg.saw_mime_version)
			fprintf(fp, "MIME-Version: 1.0\n");
		if (!msg.saw_content_type)
			fprintf(fp, "Content-Type: text/plain; "
			    "charset=unknown-8bit\n");
		if (!msg.saw_content_disposition)
			fprintf(fp, "Content-Disposition: inline\n");
		if (!msg.saw_content_transfer_encoding)
			fprintf(fp, "Content-Transfer-Encoding: "
			    "quoted-printable\n");
	}

	/* add separating newline */
	if (msg.noheader)
		fprintf(fp, "\n");

	while ((len = getline(&buf, &sz, in)) != -1) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		fprintf(fp, "%s\n", buf);
	}

	free(buf);
	fprintf(fp, "\n");
	fclose(fp);
	return 1;
}
@


1.112
log
@NULL initialize two file pointers to make it more obvious when reading that
they can't end up uninitialized after the mkstemp/fdopen dance
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.111 2016/01/12 17:29:43 sunil Exp $	*/
d190 1
a190 1
	    "A:B:b:E::e:F:f:iJ::L:mN:o:p:qR:StvV:x")) != -1) {
d200 3
@


1.111
log
@Let smtpd start on machines without a FQDN as hostname.

Ok millert@@ gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.110 2015/12/29 17:57:03 millert Exp $	*/
d171 1
a171 1
	FILE			*fp, *fout;
@


1.110
log
@Change send_line() return value to be 1/0 like get_responses() and
check the return value in the callers.  The inital value of inheaders
has been changed to improve readability.  OK gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.109 2015/12/28 22:08:30 jung Exp $	*/
d241 1
a241 1
		err(EX_NOHOST, "getmailname");
@


1.109
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.108 2015/12/14 10:22:11 jung Exp $	*/
d178 1
a178 1
	int			 inheaders = 0;
d316 2
a317 1
	send_line(fout, verbose, "EHLO localhost\n");
d324 1
a324 1
	send_line(fout, verbose, "MAIL FROM:<%s> %s%s %s%s\n",
d329 2
a330 1
	    envid_sz ? msg.dsn_envid : "");
d335 1
a335 1
		send_line(fout, verbose, "RCPT TO:<%s> %s%s\n",
d338 2
a339 1
		    msg.dsn_notify ? msg.dsn_notify : "");
d344 2
a345 1
	send_line(fout, verbose, "DATA\n");
d350 4
a353 5
	if (!msg.saw_from)
		send_line(fout, 0, "From: %s%s<%s>\n",
		    msg.fromname ? msg.fromname : "",
		    msg.fromname ? " " : "",
		    msg.from);
d356 3
a358 2
	if (!msg.saw_date)
		send_line(fout, 0, "Date: %s\n", time_to_text(timestamp));
d362 12
a373 10
		if (!msg.saw_mime_version)
			send_line(fout, 0, "MIME-Version: 1.0\n");
		if (!msg.saw_content_type)
			send_line(fout, 0, "Content-Type: text/plain; "
			    "charset=unknown-8bit\n");
		if (!msg.saw_content_disposition)
			send_line(fout, 0, "Content-Disposition: inline\n");
		if (!msg.saw_content_transfer_encoding)
			send_line(fout, 0, "Content-Transfer-Encoding: "
			    "quoted-printable\n");
d377 5
a381 4
	if (msg.noheader)
		send_line(fout, 0, "\n");
	else
		inheaders = 1;
d397 2
a398 1
			fputc('.', fout);
d413 2
a414 1
			send_line(fout, 0, "%.*s", (int)len, line);
d429 2
a430 1
				send_line(fout, 0, "=\n");
d437 2
a438 1
	send_line(fout, verbose, ".\n");
d442 2
a443 1
	send_line(fout, verbose, "QUIT\n");
d513 1
a513 1
	int ret;
d517 2
a518 1
	ret = vfprintf(fp, fmt, ap);
d521 2
a522 1
	if (v) {
d524 1
a524 2
		printf(">>> ");
		ret = vprintf(fmt, ap);
d619 1
a619 4
			send_line(fout, 0, "%.*s", (int)len, buf);
			if (buf[len - 1] != '\n')
				fputc('\n', fout);
			if (ferror(fout))
d621 4
@


1.108
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.107 2015/12/07 12:29:19 sunil Exp $	*/
d156 1
a156 1
		else if (! isprint((unsigned char)*buf) && *buf != '\n')
d313 1
a313 1
	if (! get_responses(fout, 1))
d317 1
a317 1
	if (! get_responses(fout, 1))
d329 1
a329 1
	if (! get_responses(fout, 1))
d337 1
a337 1
		if (! get_responses(fout, 1))
d342 1
a342 1
	if (! get_responses(fout, 1))
d428 1
a428 1
	if (! get_responses(fout, 1))
d432 1
a432 1
	if (! get_responses(fout, 1))
@


1.107
log
@Merge makemap(8) into smtpctl(8).

Ok gilles@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.106 2015/12/05 13:14:21 claudio Exp $	*/
d402 1
a402 1
		
d873 1
a873 1
	
@


1.106
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.105 2015/11/03 05:06:24 mmcc Exp $	*/
d102 4
a105 4
int	  verbose = 0;
char	  host[HOST_NAME_MAX+1];
char	 *user = NULL;
time_t	  timestamp;
@


1.105
log
@Blank line after pledge call.
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.104 2015/10/27 21:01:09 gilles Exp $	*/
d793 1
a793 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.104
log
@enqueue pledge: getmailname() needs dns, ~/dead.letter needs cpath/wpath

ok jung@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.103 2015/10/17 16:20:46 sunil Exp $	*/
d293 1
@


1.103
log
@Convert some fgetln to getline.

tested and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.102 2015/10/14 22:01:43 gilles Exp $	*/
d299 1
a299 1
	if (pledge("stdio", NULL) == -1)
@


1.102
log
@whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.101 2015/10/14 20:51:53 gilles Exp $	*/
d169 1
a169 1
	char			*fake_from = NULL, *buf;
d172 2
a173 1
	size_t			 len, envid_sz = 0;
d376 7
a382 5
		buf = fgetln(fp, &len);
		if (buf == NULL && ferror(fp))
			err(EX_UNAVAILABLE, "fgetln");
		if (buf == NULL && feof(fp))
			break;
d425 1
d448 4
a451 3
	char	*buf;
	size_t	 len;
	int	 e;
d456 1
a456 1
		return 0;
d460 8
a467 10
		buf = fgetln(fin, &len);
		if (buf == NULL && ferror(fin)) {
			warn("fgetln");
			return 0;
		}
		if (buf == NULL && feof(fin))
			break;
		if (buf == NULL || len < 1) {
			warn("fgetln weird");
			return 0;
d476 1
a476 1
			return 0;
d486 1
a486 1
			return 0;
d490 5
a494 1
	return 1;
d560 3
a562 2
	char	*buf;
	size_t	 len;
d568 6
a573 7
		buf = fgetln(fin, &len);
		if (buf == NULL && ferror(fin))
			err(1, "fgetln");
		if (buf == NULL && feof(fin))
			break;
		if (buf == NULL || len < 1)
			err(1, "fgetln weird");
d596 1
a596 1
			if (len > strlen(keywords[i].word) &&
d641 1
d862 5
a866 4
	char	buffer[PATH_MAX];
	FILE   *fp;
	char *buf, *lbuf;
	size_t len;
d905 1
a905 3

	lbuf = NULL;
	while ((buf = fgetln(in, &len))) {
a907 8
		else {
			/* EOF without EOL, copy and add the NUL */
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}
a909 1
	free(lbuf);
d911 1
a913 1

@


1.101
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.100 2015/10/13 08:06:22 gilles Exp $	*/
d305 1
a305 1
	/* 
@


1.100
log
@let the enqueuer pledge() in both online and offline modes

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.99 2015/10/12 21:32:27 millert Exp $	*/
d300 1
a300 1
	
@


1.99
log
@Add missing checks for write errors; OK eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.98 2015/10/09 15:09:09 gilles Exp $	*/
d289 3
a291 1
	if (!srv_connected())
d293 1
d298 3
@


1.98
log
@if an error occurs during offline enqueuing after we've dropped group, then
attempt to ftruncate() the fp back to 0.

suggested and ok millert@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.97 2015/10/09 14:37:38 gilles Exp $	*/
d817 2
a818 1
		fprintf(ofile, "%s%s", i == 1 ? "" : "|", argv[i]);
d821 2
a822 1
	fprintf(ofile, "\n");
d824 4
a827 6
	while ((ch = fgetc(ifile)) != EOF)
		if (fputc(ch, ofile) == EOF) {
			warn("write error");
			ftruncate(fileno(ofile), 0);
			exit(EX_UNAVAILABLE);
		}
d835 2
a836 1
	fclose(ofile);
d839 4
@


1.97
log
@turn our local enqueuer setgid _smtpq and restrict access to offline queue,
the enqueuer will revoke group and regain real gid right after mkstemp.

this would have prevented the symlink/hardlink attacks against offline, and
it will avoid having to deal with new ways users can mess with it.

ok eric@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.96 2015/10/06 06:04:46 gilles Exp $	*/
d814 1
d825 1
d831 1
@


1.96
log
@fix values passed to umask(), they should be octal.
the permissions are even more restrictive than they should.

misc bug reported by qualys
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.95 2015/09/07 15:36:53 gilles Exp $	*/
d31 1
a38 1
#include <sysexits.h>
d57 1
a57 1
static int enqueue_offline(int, char *[], FILE *);
d60 1
a60 1
extern int srv_connect(void);
d166 1
a166 1
enqueue(int argc, char *argv[])
d286 1
a286 1
	/* try to connect */
d289 2
a290 2
	if (!srv_connect())
		return (enqueue_offline(save_argc, save_argv, fp));
d807 1
a807 1
enqueue_offline(int argc, char *argv[], FILE *ifile)
d809 1
a809 25
	char	 path[PATH_MAX];
	FILE	*fp;
	int	 i, fd, ch;
	mode_t	 omode;

	if (ckdir(PATH_SPOOL PATH_OFFLINE, 01777, 0, 0, 0) == 0)
		errx(EX_UNAVAILABLE, "error in offline directory setup");

	if (! bsnprintf(path, sizeof(path), "%s%s/%lld.XXXXXXXXXX", PATH_SPOOL,
		PATH_OFFLINE, (long long int) time(NULL)))
		err(EX_UNAVAILABLE, "snprintf");

	omode = umask(07077);
	if ((fd = mkstemp(path)) == -1 || (fp = fdopen(fd, "w+")) == NULL) {
		warn("cannot create temporary file %s", path);
		if (fd != -1)
			unlink(path);
		exit(EX_UNAVAILABLE);
	}
	umask(omode);

	if (fchmod(fd, 0600) == -1) {
		unlink(path);
		exit(EX_SOFTWARE);
	}
a813 1
			unlink(path);
d816 1
a816 1
		fprintf(fp, "%s%s", i == 1 ? "" : "|", argv[i]);
d819 1
a819 1
	fprintf(fp, "\n");
d822 1
a822 1
		if (fputc(ch, fp) == EOF) {
a823 1
			unlink(path);
a828 1
		unlink(path);
d832 1
a832 1
	fclose(fp);
@


1.95
log
@when bypassing the enqueuer, insert Message-Id header if none was found and
the client has connected from a loopback interface.

ok millert@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.94 2015/05/13 07:34:49 gilles Exp $	*/
d821 1
a821 1
	omode = umask(7077);
@


1.94
log
@The enqueuer should never encouter the "From " separator in its headers, as
it is added by the mda. If it sees one, it means that the enqueuer was used
as the mda and it needs to strip it otherwise the message will end with two
delimiters later down the road. Same applies to "Return-Path".

bug experienced by James Turner, confirmed by Giovanni.
fix suggested by Todd Miller, diff ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.93 2015/05/03 18:10:58 gilles Exp $	*/
a347 5
	/* add Message-Id */
	if (!msg.saw_msgid)
		send_line(fout, 0, "Message-Id: <%"PRIu64".enqueue@@%s>\n",
		    generate_uid(), host);

a889 5

	/* add Message-Id */
	if (!msg.saw_msgid)
		fprintf(fp, "Message-Id: <%"PRIu64".enqueue@@%s>\n",
		    generate_uid(), host);
@


1.93
log
@S was misplaced in r1.89, the optarg that was removed was actually needed
by R, so reintroduce it in the proper place.

spotted and diff by Sunil Nimmagadda
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.92 2015/05/03 17:53:50 gilles Exp $	*/
d391 7
@


1.92
log
@smtpd enqueue -S does not take an argument, fix optstring accordingly

fix by Nathanael Rensen
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.91 2015/02/27 12:17:36 millert Exp $	*/
d189 1
a189 1
	    "A:B:b:E::e:F:f:iJ::L:mN:o:p:qRStvV:x")) != -1) {
@


1.91
log
@Do not use the name returned by getlogin() when pw_uid from
getpwnam(getlogin()) doesn't match the real uid, unless the real
uid is 0.  This matches the behavior of sendmail and gives the
corrent sender for mail sent by daemons that got started by a
user who su'd or used sudo.  OK dlg@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.90 2015/01/20 17:37:54 deraadt Exp $	*/
d189 1
a189 1
	    "A:B:b:E::e:F:f:iJ::L:mN:o:p:qRS:tvV:x")) != -1) {
@


1.90
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.89 2015/01/15 09:05:37 gilles Exp $	*/
d248 7
a254 3
		if ((user = getlogin()) != NULL && *user != '\0')
			pw = getpwnam(user);
		else if ((pw = getpwuid(getuid())) == NULL)
d256 1
@


1.89
log
@when enqueueing offline mails from within the daemon session, we should not
rely on getlogin() otherwise mail will end up enqueued as coming from user
who started smtpd.

bug spotted by deraadt@@, diff ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.88 2014/11/12 10:28:07 gilles Exp $	*/
d41 1
d103 1
a103 1
char	  host[SMTPD_MAXHOSTNAMELEN];
d802 1
a802 1
	char	 path[SMTPD_MAXPATHLEN];
d860 1
a860 1
	char	buffer[SMTPD_MAXPATHLEN];
@


1.88
log
@truncate dead.letter
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.87 2014/11/06 08:55:06 gilles Exp $	*/
d179 1
d188 1
a188 1
	    "A:B:b:E::e:F:f:iJ::L:mN:o:p:qR:tvV:x")) != -1) {
d202 3
d240 13
a252 5
	if ((user = getlogin()) != NULL && *user != '\0')
		pw = getpwnam(user);
	else if ((pw = getpwuid(getuid())) == NULL)
		user = "anonymous";
	user = xstrdup(pw ? pw->pw_name : user, "enqueue");
@


1.87
log
@since domain appending is handled at the daemon level, don't try to do it
in the enqueuer itself, it leads to broken headers
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.86 2014/10/26 11:26:08 gilles Exp $	*/
d857 1
a857 1
	if ((fp = fopen(buffer, "a")) == NULL)
@


1.86
log
@when using the local enqueuer, if the internal SMTP session fails, copy the
original message to ~/dead.letter so it's not lost
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.85 2014/10/08 10:56:01 deraadt Exp $	*/
a163 42
static void
send_header(FILE *fout, const char *line, size_t len)
{
	int	i;

	if (strncasecmp("To:", line, 3) != 0 &&
	    strncasecmp("Cc:", line, 3) != 0 &&
	    strncasecmp("Bcc:", line, 4) != 0 &&
	    strncasecmp("From:", line, 5) != 0) {
		send_line(fout, 0, "%.*s", (int)len, line);
		return;
	}
	if (len >= sizeof pstate.buf) {
		send_line(fout, 0, "%.*s", (int)len, line);
		return;
	}

	/* XXX
	 * To, Cc and Bcc may need rewrite, we can reuse the
	 * msg recipients field since former content has already
	 * been used at this point.
	 */
	memset(&pstate, 0, sizeof(pstate));
	memcpy(pstate.buf, line, len);
	pstate.buf[len] = 0;
	pstate.wpos = len - 1;
	msg.rcpts = NULL;
	msg.rcpt_cnt = 0;

	if (strncasecmp("From:", line, 5) == 0) {
		parse_addr_terminal(1);
		send_line(fout, 0, "%s\n", msg.from);
	}
	else {
		parse_addr_terminal(0);
		for (i = 0; i < msg.rcpt_cnt; ++i)
			if (*msg.rcpts[i] != '\0')
				send_line(fout, 0, "%s%s%s\n", i > 0 ? "\t" : "",
				    msg.rcpts[i], i < msg.rcpt_cnt - 1 ? "," : "");
	}
}

d375 1
a375 4
			if (inheaders)
				send_header(fout, line, len);
			else
				send_line(fout, 0, "%.*s", (int)len, line);
@


1.85
log
@obvious reallocarray() use
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.84 2014/10/04 03:00:58 millert Exp $	*/
d54 1
a54 1
static void get_responses(FILE *, int);
d57 1
d124 1
d209 1
a209 1
	int			 i, ch, tflag = 0, noheader;
d302 1
a302 1
	noheader = parse_message(stdin, fake_from == NULL, tflag, fp);
d329 2
a330 1
	get_responses(fout, 1);
d333 2
a334 1
	get_responses(fout, 1);
d345 2
a346 1
	get_responses(fout, 1);
d353 2
a354 1
		get_responses(fout, 1);
d358 2
a359 1
	get_responses(fout, 1);
d392 1
a392 1
	if (noheader)
d415 1
a415 1
		if (msg.saw_content_transfer_encoding || noheader ||
d442 2
a443 1
	get_responses(fout, 1);
d446 2
a447 1
	get_responses(fout, 1);
d453 5
d460 1
a460 1
static void
d468 4
a471 2
	if ((e = ferror(fin)))
		errx(1, "ferror: %d", e);
d475 4
a478 2
		if (buf == NULL && ferror(fin))
			err(1, "fgetln");
d481 4
a484 2
		if (buf == NULL || len < 1)
			err(1, "fgetln weird");
d490 4
a493 2
		if (len < 4)
			errx(1, "bad response");
d500 4
a503 2
		if (buf[0] != '2' && buf[0] != '3')
			errx(1, "command failed: %.*s", (int)len, buf);
d506 1
d887 73
@


1.84
log
@Use getlogin() to determine real user name where possible.
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.83 2014/07/28 22:18:31 krw Exp $	*/
d749 2
a750 2
	if ((nrcpts = realloc(msg.rcpts,
	    sizeof(char *) * (msg.rcpt_cnt + n))) == NULL)
@


1.83
log
@Last (known) msgbuf_write() vs EOF fix.

ok gilles@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.82 2014/07/20 01:38:40 guenther Exp $	*/
d276 3
a278 1
	if ((pw = getpwuid(getuid())) == NULL)
d280 1
a280 2
	if (pw != NULL)
		user = xstrdup(pw->pw_name, "enqueue");
@


1.82
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.81 2014/06/06 15:02:08 gilles Exp $	*/
d773 1
a773 1
		if (msgbuf_write(&ibuf->w) < 0 && errno != EAGAIN)
@


1.81
log
@when relying on the local enqueuer, fix an issue with long To and Cc lines
that can lead to broken headers and confuse some MUA

issue spotted by tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.80 2014/04/05 13:43:16 gilles Exp $	*/
d291 1
d296 1
a296 1
		err(EX_UNAVAILABLE, "mkstemp");
@


1.80
log
@fix writing of multiline To and Cc headers

issue spotted, fix tested and okayed krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.79 2014/04/04 20:25:44 gilles Exp $	*/
d198 3
a200 2
			send_line(fout, 0, "%s%s%s\n", i > 0 ? "\t" : "",
			    msg.rcpts[i], i < msg.rcpt_cnt - 1 ? "," : "");
@


1.79
log
@fix header parsing issue in enqueuer leading to From: header being stripped
in some cases

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d198 2
a199 1
			send_line(fout, 0, "%s%s\n", msg.rcpts[i], i < msg.rcpt_cnt - 1 ? "," : "");
@


1.78
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d190 2
a191 1
	if (strncasecmp("From:", line, 5) == 0)
d193 3
a195 1
	else
d197 3
a199 2
	for (i = 0; i < msg.rcpt_cnt; ++i)
		send_line(fout, 0, "%s%s\n", msg.rcpts[i], i < msg.rcpt_cnt - 1 ? "," : "");
@


1.77
log
@when locally enqueuing messages without specifying a domain for sender or
recipient, the local domain is assumed. this was correctly handled at the
smtp level, but headers were not updated to reflect that.

issue experienced by several people, fix tested by ajacoutot@@ and I
ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.76 2014/03/13 14:28:33 chris Exp $	*/
d763 1
a763 1
	imsg_compose(ibuf, IMSG_SMTP_ENQUEUE_FD, IMSG_VERSION, 0, -1, NULL, 0);
@


1.76
log
@The enqueue utility should not add a User-Agent header to emails.

ok gilles jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.75 2014/02/04 15:44:05 eric Exp $	*/
d162 36
d402 4
a405 1
			send_line(fout, 0, "%.*s", (int)len, line);
@


1.75
log
@Add support for DSN and Enhanced Status Code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a338 3
	if (!msg.saw_user_agent)
		send_line(fout, 0, "User-Agent: %s enqueuer (%s)\n",
		    SMTPD_NAME, "Demoostik");
@


1.74
log
@bcopy -> memmove
bzero -> memset
@
text
@d110 3
d169 1
a171 1
	size_t			 len;
d185 1
a185 1
	    "A:B:b:E::e:F:f:iJ::L:mN:o:p:qR:tvx")) != -1) {
d193 6
d205 3
a216 1
		case 'N': /* XXX: DSN */
a218 1
		case 'R':
d288 9
a296 1
	send_line(fout, verbose, "MAIL FROM:<%s>\n", msg.from);
d300 4
a303 1
		send_line(fout, verbose, "RCPT TO:<%s>\n", msg.rcpts[i]);
@


1.73
log
@now at 5.4.1
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.72 2013/11/28 10:43:37 eric Exp $	*/
d175 1
a175 1
	bzero(&msg, sizeof(msg));
d487 1
a487 1
	bzero(&pstate, sizeof(pstate));
@


1.72
log
@unsigned char casts for ctype
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.71 2013/11/26 15:52:16 henning Exp $	*/
d320 1
a320 1
		    SMTPD_NAME, "Demoosh");
@


1.71
log
@need errno, thx sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.70 2013/11/26 12:01:40 henning Exp $	*/
d150 1
a150 1
		else if (! isprint(*buf) && *buf != '\n')
d470 1
a470 1
			msg.fromname[apos] = toupper(msg.fromname[apos]);
@


1.70
log
@deal with msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d29 1
@


1.69
log
@local enqueuer improvements:

- parse the whole input before trying to establish the connection
  to the local socket: fixes timeout problems when reading the output
  of a long running program.

- use sendmail(8)-like exit status.
@
text
@d708 1
a708 1
		if (msgbuf_write(&ibuf->w) < 0)
@


1.68
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.67 2013/01/31 18:34:43 eric Exp $	*/
a32 1
#include <signal.h>
d37 1
a45 1
static void sighdlr(int);
d55 3
a130 9
sighdlr(int sig)
{
	if (sig == SIGALRM) {
		write(STDERR_FILENO, TIMEOUTMSG, sizeof(TIMEOUTMSG));
		_exit(2);
	}
}

static void
d165 2
d171 2
d177 3
d212 1
a212 1
			return (0);
d221 2
a222 2
	if (gethostname(host, sizeof(host)) == -1)
		err(1, "gethostname");
d236 9
a244 6
	signal(SIGALRM, sighdlr);
	alarm(300);

	fp = tmpfile();
	if (fp == NULL)
		err(1, "tmpfile");
d248 1
a248 1
		errx(1, "no recipients");
d253 6
d260 1
a260 1
		errx(1, "server too busy");
d264 1
a264 1
		err(1, "fdopen");
d277 1
a277 1
	send_line(fout, verbose, "MAIL FROM: <%s>\n", msg.from);
d281 1
a281 1
		send_line(fout, verbose, "RCPT TO: <%s>\n", msg.rcpts[i]);
d330 1
a330 1
			err(1, "fgetln");
d335 1
a335 1
			errx(1, "expect EOL");
d377 1
a377 1
	exit(0);
d389 1
a389 1
		errx(1, "ferror: %i", e);
d740 2
a741 2
int
enqueue_offline(int argc, char *argv[])
d749 1
a749 1
		errx(1, "error in offline directory setup");
d753 1
a753 1
		err(1, "snprintf");
d760 1
a760 1
		exit(1);
d766 1
a766 1
		exit(1);
d773 1
a773 1
			exit(1);
d780 1
a780 1
	while ((ch = fgetc(stdin)) != EOF)
d784 1
a784 1
			exit(1);
d787 1
a787 1
	if (ferror(stdin)) {
d790 1
a790 1
		exit(1);
d795 1
a795 1
	return (0);
@


1.67
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.66 2013/01/26 09:37:23 gilles Exp $	*/
d21 1
a21 1
#include <sys/param.h>
a24 1
#include <sys/types.h>
d98 1
a98 1
char	  host[MAXHOSTNAMELEN];
d696 1
a696 1
	imsg_compose(ibuf, IMSG_SMTP_ENQUEUE_FD, 0, 0, -1, NULL, 0);
d734 1
a734 1
	char	 path[MAXPATHLEN];
d754 5
@


1.66
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.64 2012/11/12 14:58:53 eric Exp $	*/
d26 1
d684 2
d738 1
d747 1
d754 1
@


1.65
log
@knf

ok gilles@@
@
text
@d6 1
d309 2
a310 2
		send_line(fout, 0, "User-Agent: OpenSMTPD enqueuer (%s)\n",
			"Demoosh");
d694 1
a694 1
	imsg_compose(ibuf, IMSG_SMTP_ENQUEUE, 0, 0, -1, NULL, 0);
@


1.64
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.63 2012/09/27 20:34:15 chl Exp $	*/
d144 1
a144 1
			
d229 1
a229 1
	while(argc > 0) {
d282 1
a282 1
		    msg.fromname ? " " : "", 
d299 2
a300 1
			send_line(fout, 0, "Content-Type: text/plain; charset=unknown-8bit\n");
d304 2
a305 1
			send_line(fout, 0, "Content-Transfer-Encoding: quoted-printable\n");
d308 2
a309 1
		send_line(fout, 0, "User-Agent: OpenSMTPD enqueuer (Demoosh)\n");
d335 2
a336 1
		if (msg.saw_content_transfer_encoding || noheader || inheaders || !msg.need_linesplit) {
d350 2
a351 1
				qp_encoded_write(fout, line, LINESPLIT - 2 - dotted);
d359 1
a359 1
	get_responses(fout, 1);	
d362 1
a362 1
	get_responses(fout, 1);	
d381 1
a381 1
	while(n) {
d583 1
a583 1
				for(pos++; pos < len && WSP(s[pos]); pos++)
d642 1
a642 1
	}	
@


1.63
log
@use xstrdup() helper

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.62 2012/09/27 12:26:35 chl Exp $	*/
a408 2
	if (v)
		printf(">>> ");
d411 5
a415 1
	if (v)
d417 3
a419 1
	va_end(ap);
@


1.62
log
@simplify malloc() + strlcpy() dance with xstrdup()

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.61 2012/08/23 16:10:19 todd Exp $	*/
d224 2
a225 2
	if (pw != NULL && (user = strdup(pw->pw_name)) == NULL)
		err(1, "strdup");
d645 1
a645 2
		if ((out = strdup(in)) == NULL)
			err(1, "qualify strdup");
@


1.61
log
@enhance -v mode of 'sendmail' binary
ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.60 2012/08/23 13:16:02 todd Exp $	*/
d431 1
a431 3
			if ((p = malloc(strlen(fake_from))) == NULL)
				err(1, "malloc");
			strlcpy(p, fake_from + 1, strlen(fake_from));
@


1.60
log
@fix multiple recipient support, from sunil on irc
tested by me, ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.59 2012/08/23 13:06:29 todd Exp $	*/
d33 1
d54 1
d264 1
a264 1
	fprintf(fout, "EHLO localhost\n");
d267 1
a267 1
	fprintf(fout, "MAIL FROM: <%s>\n", msg.from);
d271 1
a271 1
		fprintf(fout, "RCPT TO: <%s>\n", msg.rcpts[i]);
d275 1
a275 1
	fprintf(fout, "DATA\n");
d280 1
a280 1
		fprintf(fout, "From: %s%s<%s>\n",
d287 1
a287 1
		fprintf(fout, "Date: %s\n", time_to_text(timestamp));
d291 1
a291 1
		fprintf(fout, "Message-Id: <%"PRIu64".enqueue@@%s>\n",
d297 1
a297 1
			fprintf(fout, "MIME-Version: 1.0\n");
d299 1
a299 1
			fprintf(fout, "Content-Type: text/plain; charset=unknown-8bit\n");
d301 1
a301 1
			fprintf(fout, "Content-Disposition: inline\n");
d303 1
a303 1
			fprintf(fout, "Content-Transfer-Encoding: quoted-printable\n");
d306 1
a306 1
		fprintf(fout, "User-Agent: OpenSMTPD enqueuer (Demoosh)\n");
d310 1
a310 1
		fprintf(fout, "\n");
d333 1
a333 1
			fprintf(fout, "%.*s", (int)len, line);
d347 1
a347 1
				fprintf(fout, "=\n");
d353 1
a353 1
	fprintf(fout, ".\n");
d356 1
a356 1
	fprintf(fout, "QUIT\n");
d393 1
a393 1
			printf(">>> %.*s", (int)len, buf);
d403 16
d509 1
a509 1
			fprintf(fout, "%.*s", (int)len, buf);
@


1.59
log
@add -R to sendmail compat flags that do nothing (for now)
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.58 2012/08/23 13:04:41 todd Exp $	*/
d639 9
d650 1
a650 1
	    sizeof(char *) * (msg.rcpt_cnt + 1))) == NULL)
d653 7
a659 1
	msg.rcpts[msg.rcpt_cnt++] = qualify_addr(addr);
@


1.58
log
@add -N for sendmail compat DSN support; unlimited for now
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.57 2012/08/19 14:16:58 chl Exp $	*/
d178 1
a178 1
	    "A:B:b:E::e:F:f:iJ::L:mN:o:p:qtvx")) != -1) {
d204 1
@


1.57
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.56 2012/03/17 13:10:03 gilles Exp $	*/
d178 1
a178 1
	    "A:B:b:E::e:F:f:iJ::L:mo:p:qtvx")) != -1) {
d201 1
@


1.56
log
@llu -> PRIu64 in enqueue() to avoid warning in portable

diff from Guillaume Leconte <guillaume.leconte@@scality.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.55 2012/02/02 16:52:59 eric Exp $	*/
d117 4
a120 4
	u_int		quote;
	u_int		comment;
	u_int		esc;
	u_int		brackets;
d446 2
a447 2
	u_int	 i, cur = HDR_NONE;
	u_int	 header_seen = 0, header_done = 0;
@


1.55
log
@Only use mime/line-split if the input message actually contains a very
long line.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.54 2012/01/30 20:21:53 gilles Exp $	*/
d30 1
d287 1
a287 1
		fprintf(fout, "Message-Id: <%llu.enqueue@@%s>\n",
@


1.54
log
@do not encode headers, it breaks the resulting message

reported by eric@@ and miod@@
ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.53 2012/01/29 10:42:23 eric Exp $	*/
d87 1
d104 1
d289 11
a299 9
	/* we will always need to mime encode for long lines */
	if (!msg.saw_mime_version)
		fprintf(fout, "MIME-Version: 1.0\n");
	if (!msg.saw_content_type)
		fprintf(fout, "Content-Type: text/plain; charset=unknown-8bit\n");
	if (!msg.saw_content_disposition)
		fprintf(fout, "Content-Disposition: inline\n");
	if (!msg.saw_content_transfer_encoding)
		fprintf(fout, "Content-Transfer-Encoding: quoted-printable\n");
d327 1
a327 1
		if (msg.saw_content_transfer_encoding || noheader || inheaders) {
d336 1
a336 1
			if (len < 76) {
d341 1
a341 1
				qp_encoded_write(fout, line, 76 - 2 - dotted);
d343 2
a344 2
				line += 76 - 2 - dotted;
				len -= 76 - 2 - dotted;
d472 4
@


1.53
log
@fix warning

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.52 2012/01/28 21:15:01 gilles Exp $	*/
d169 1
d297 1
a297 1
		fprintf(fout, "User-Agent: OpenSMTPD enqueuer\n");
d302 2
d323 1
a323 1
		if (msg.saw_content_transfer_encoding) {
d325 2
@


1.52
log
@ok, since we're already encoding =, let's just do full quoted printable
encoding, it's just a few additional lines ...
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.51 2012/01/28 18:13:53 gilles Exp $	*/
d146 1
a146 1
				fprintf(fp, "=%0.2X", *buf & 0xff);
d151 1
a151 1
			fprintf(fp, "=%0.2X", *buf & 0xff);
@


1.51
log
@when enqueuing, check if a MUA did some MIME transfer encoding, otherwise
do quoted-printable transfer encoding so that OpenSMTPD doesn't refuse to
enqueue mails with long lines

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.50 2011/12/15 17:23:54 eric Exp $	*/
d132 1
a132 1
escaped_write(FILE *fp, char *buf, size_t len)
d134 1
a134 1
	while (len--) {
d137 15
d155 1
d327 2
a328 2
			if (len < 72) {
				escaped_write(fout, line, len);
d332 1
a332 1
				escaped_write(fout, line, 72 - 2 - dotted);
d334 2
a335 2
				line += 72 - 2 - dotted;
				len -= 72 - 2 - dotted;
@


1.50
log
@all leading dots must be duplicated.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.49 2011/11/14 16:54:19 eric Exp $	*/
d61 6
a66 1
	HDR_MSGID
d73 12
a84 7
	{ "From:",		HDR_FROM },
	{ "To:",		HDR_TO },
	{ "Cc:",		HDR_CC },
	{ "Bcc:",		HDR_BCC },
	{ "Subject:",		HDR_SUBJECT },
	{ "Date:",		HDR_DATE },
	{ "Message-Id:",	HDR_MSGID }
d106 5
d131 12
d151 2
d270 12
d296 2
a297 1
		if (buf[0] == '.')
d299 23
a321 1
		fprintf(fout, "%.*s", (int)len, buf);
d483 10
@


1.49
log
@make sure that the offline directory has the right owner/perms
before enqueueing offline mail.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.48 2011/11/02 12:01:20 eric Exp $	*/
d255 1
a255 1
		if (len == 2 && buf[0] == '.')
@


1.48
log
@simpler implementation of smtpctl local enqueuer that does not need libevent.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.47 2011/08/29 21:43:08 chl Exp $	*/
d589 3
@


1.47
log
@cast all printed time_t to long long int, and change format string accordingly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.46 2011/08/29 18:49:29 chl Exp $	*/
a38 1
#include "client.h"
d51 1
a51 1
static void enqueue_event(int, short, void *);
a92 2
	char	 *data;
	size_t	  len;
a95 3

	struct smtp_client	*pcb;
	struct event		 ev;
d120 1
a120 1
	char			*fake_from = NULL;
d122 2
a123 1
	FILE			*fp;
d190 2
a191 2
	if ((msg.fd = open_connection()) == -1)
		errx(1, "server too busy");
a194 1
	msg.pcb = client_init(msg.fd, fp, "localhost", verbose);
d196 25
a220 2
	/* set envelope from */
	client_sender(msg.pcb, "%s", msg.from);
d222 2
a223 5
	/* add recipients */
	if (msg.rcpt_cnt == 0)
		errx(1, "no recipients");
	for (i = 0; i < msg.rcpt_cnt; i++)
		client_rcpt(msg.pcb, "%s", msg.rcpts[i]);
d227 1
a227 1
		client_printf(msg.pcb, "From: %s%s<%s>\n",
d234 1
a234 1
		client_printf(msg.pcb, "Date: %s\n", time_to_text(timestamp));
d238 1
a238 1
		client_printf(msg.pcb, "Message-Id: <%llu.enqueue@@%s>\n",
d243 1
a243 1
		client_printf(msg.pcb, "\n");
d245 16
a260 5
	alarm(0);
	event_init();
	session_socket_blockmode(msg.fd, BM_NONBLOCK);
	event_set(&msg.ev, msg.fd, EV_READ|EV_WRITE, enqueue_event, NULL);
	event_add(&msg.ev, &msg.pcb->timeout);
d262 2
a263 2
	if (event_dispatch() < 0)
		err(1, "event_dispatch");
a264 1
	client_close(msg.pcb);
d266 2
d272 1
a272 1
enqueue_event(int fd, short event, void *p)
d274 16
a289 2
	if (event & EV_TIMEOUT)
		errx(1, "timeout");
d291 15
a305 11
	switch (client_talk(msg.pcb, event & EV_WRITE)) {
	case CLIENT_WANT_WRITE:
		goto rw;
	case CLIENT_STOP_WRITE:
		goto ro;
	case CLIENT_RCPT_FAIL:
		errx(1, "%s", msg.pcb->reply);
	case CLIENT_DONE:
		break;
	default:
		errx(1, "enqueue_event: unexpected code");
a306 15

	if (msg.pcb->status[0] != '2')
		errx(1, "%s", msg.pcb->status);

	event_loopexit(NULL);
	return;

ro:
	event_set(&msg.ev, msg.fd, EV_READ, enqueue_event, NULL);
	event_add(&msg.ev, &msg.pcb->timeout);
	return;

rw:
	event_set(&msg.ev, msg.fd, EV_READ|EV_WRITE, enqueue_event, NULL);
	event_add(&msg.ev, &msg.pcb->timeout);
@


1.46
log
@add missing header needed by signal()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.45 2011/08/26 14:39:47 chl Exp $	*/
d561 2
a562 2
	if (! bsnprintf(path, sizeof(path), "%s%s/%d.XXXXXXXXXX", PATH_SPOOL,
		PATH_OFFLINE, time(NULL)))
@


1.45
log
@add missing header needed by time()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.44 2011/06/09 03:53:39 deraadt Exp $	*/
d31 1
@


1.44
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.43 2011/04/17 13:36:07 gilles Exp $	*/
d34 1
@


1.43
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.42 2011/03/26 10:59:59 gilles Exp $	*/
d116 1
a116 1
		_exit (2);
@


1.42
log
@have the client API receive a stdio stream rather than a fd to the message
fd. this shifts responsibility for the fclose to the caller, prevents a
memory leak and makes everyone happy.

diff by Jared Yanovich, thanks !
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.41 2010/11/28 14:35:58 gilles Exp $	*/
d41 10
a50 11
void	 usage(void);
void	 sighdlr(int);
int	 main(int, char *[]);
void	 build_from(char *, struct passwd *);
int	 parse_message(FILE *, int, int, FILE *);
void	 parse_addr(char *, size_t, int);
void	 parse_addr_terminal(int);
char	*qualify_addr(char *);
void	 rcpt_add(char *);
int	 open_connection(void);
void	 enqueue_event(int, short, void *);
d111 1
a111 1
void
d243 1
a243 1
void
d278 1
a278 1
void
d320 1
a320 1
int
d393 1
a393 1
void
d466 1
a466 1
void
d483 1
a483 1
char *
d498 1
a498 1
void
d510 1
a510 1
int
@


1.41
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.40 2010/11/28 13:56:43 gilles Exp $	*/
d199 1
a199 1
	msg.pcb = client_init(msg.fd, fileno(fp), "localhost", verbose);
d240 1
@


1.40
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.39 2010/10/09 22:05:35 gilles Exp $	*/
a27 1
#include <errno.h>
a28 1
#include <fcntl.h>
a29 1
#include <netdb.h>
a30 2
#include <signal.h>
#include <stdarg.h>
a33 1
#include <time.h>
@


1.39
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.33 2010/04/21 17:50:28 jacekm Exp $	*/
d31 1
@


1.38
log
@Ignore SIGPIPE, the delivery of which prevented /usr/sbin/sendmail from
relaying the server diagnostic back to the user (eg. "500 Line too long").
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.37 2010/06/02 19:16:53 chl Exp $	*/
d166 1
a191 1
	signal(SIGPIPE, SIG_IGN);
@


1.37
log
@check event_dispatch() return value

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.36 2010/06/01 23:06:23 jacekm Exp $	*/
d191 1
@


1.36
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.34 2010/05/31 23:38:56 jacekm Exp $	*/
d240 2
a241 1
	event_dispatch();
@


1.35
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.33 2010/04/21 17:50:28 jacekm Exp $	*/
a165 1
			/* XXX: implement "process all now" */
@


1.34
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d166 1
@


1.33
log
@Fix pathetic performance when submitting large mails via /usr/sbin/sendmail,
caused by realloc() abuse.
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.32 2010/01/11 21:43:37 jacekm Exp $	*/
a165 1
			/* XXX: implement "process all now" */
@


1.32
log
@Fix wrong logic in error checking of buf_dynamic, found by pcc.
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.31 2009/12/23 17:16:03 jacekm Exp $	*/
d50 1
a50 1
int	 parse_message(FILE *, int, int, struct buf *);
d132 1
a132 1
	struct buf		*body;
d194 5
d203 2
a204 7
	msg.pcb = client_init(msg.fd, open("/dev/null", O_RDONLY), "localhost",
	    verbose);

	/* parse message */
	if ((body = buf_dynamic(0, SIZE_T_MAX)) == NULL)
		err(1, "buf_dynamic failed");
	noheader = parse_message(stdin, fake_from == NULL, tflag, body);
a234 3
	client_printf(msg.pcb, "%.*s", buf_size(body), body->buf);
	buf_free(body);

d325 1
a325 1
parse_message(FILE *fin, int get_from, int tflag, struct buf *body)
d339 2
a348 3
		if (buf == NULL || len < 1)
			err(1, "fgetln weird");

d368 5
a372 4
			if (buf_add(body, buf, len) < 0)
				err(1, "buf_add failed");
			if (buf[len - 1] != '\n' && buf_add(body, "\n", 1) < 0)
				err(1, "buf_add failed");
@


1.31
log
@Implementation of RFC 2920 PIPELINING extension, client side only for now.

This restructures the client_* API internals significantly.  The code becomes
pipelining in nature.  All SMTP commands are put on the output queue and
dequeued as quickly as possible.  Once dequeued, they're moved to the receive
queue so that replies can be matched with previous commands.

Dequeuing commands from the output queue halts when the count of commands
currently in-pipeline (``cmdi'') is equal to the command send window (``cmdw'').
There are three cmdw values useful in practice:

0               clear pipeline, ie. inhibit all future sends
1               disable pipelining, ie. use old ``one-request-one-reply`` mode
SIZE_T_MAX      enable pipelining, ie. dequeue as many commands as possible

At the beginning of session cmdw is 1.  When it is found that peer supports
PIPELINING, it grows to SIZE_T_MAX.  After dequeing DATA it is again 1.  After
sending QUIT it is 0.

Each command dequeued from the output queue becomes a buf in a msgbuf.  The act
of combining multiple commands into a single send operation did not need to be
implemented: buf_write() already combines bufs using iovec and sends them at
once using sendmsg(2).

Tested by todd@@ and oga@@

"looks good" to gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.30 2009/12/13 22:02:55 jacekm Exp $	*/
d202 1
a202 1
	if ((body = buf_dynamic(0, SIZE_T_MAX)) < 0)
@


1.30
log
@Use safe fd limits in smtp, lka, queue, and control.  Removes a
possibility for fd-starvation fatal when under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.29 2009/12/12 14:03:59 jacekm Exp $	*/
d56 1
d103 3
a131 1
	struct smtp_client	*pcb;
d198 1
a198 1
	pcb = client_init(msg.fd, open("/dev/null", O_RDONLY), "localhost",
d207 1
a207 1
	client_sender(pcb, "%s", msg.from);
d213 1
a213 1
		client_rcpt(pcb, "%s", msg.rcpts[i]);
d217 1
a217 1
		client_printf(pcb, "From: %s%s<%s>\n",
d224 1
a224 1
		client_printf(pcb, "Date: %s\n", time_to_text(timestamp));
d228 1
a228 1
		client_printf(pcb, "Message-Id: <%llu.enqueue@@%s>\n",
d233 1
a233 1
		client_printf(pcb, "\n");
d235 1
a235 1
	client_printf(pcb, "%.*s", buf_size(body), body->buf);
d238 17
a254 15
	/* run the protocol engine */
	for (;;) {
		alarm(pcb->timeout.tv_sec);

		switch (client_talk(pcb)) {
		case CLIENT_WANT_READ:
		case CLIENT_WANT_WRITE:
			continue;
		case CLIENT_RCPT_FAIL:
			errx(1, "%s", pcb->reply);
		case CLIENT_DONE:
			break;
		default:
			errx(1, "client_talk: unexpected code");
		}
d256 8
a263 2
		if (pcb->status[0] != '2')
			errx(1, "%s", pcb->status);
d265 2
d269 5
a273 1
	client_close(pcb);
d275 8
a282 2
	close(msg.fd);
	exit (0);
@


1.29
log
@When acting as a client do content reads from the disk progressively
as the remote accepts more data instead of doing one big read into
the memory in the beginning of session.
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.28 2009/12/12 10:33:11 jacekm Exp $	*/
d191 2
a192 1
	msg.fd = open_connection();
@


1.28
log
@Simplify client_* api, mainly by making fatal conditions result in immediate
fatals instead of passing the error up (kills ~300 lines).

Implement sending of the QUIT command which replaces crude close(2).

tested by gilles@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.27 2009/12/12 10:14:07 jacekm Exp $	*/
d30 1
d194 2
a195 1
	pcb = client_init(msg.fd, "localhost", verbose);
d213 1
a213 1
		client_data_printf(pcb, "From: %s%s<%s>\n",
d220 1
a220 1
		client_data_printf(pcb, "Date: %s\n", time_to_text(timestamp));
d224 1
a224 1
		client_data_printf(pcb, "Message-Id: <%llu.enqueue@@%s>\n",
d229 1
a229 1
		client_data_printf(pcb, "\n");
d231 1
a231 1
	client_data_printf(pcb, "%.*s", buf_size(body), body->buf);
@


1.27
log
@Don't qualify empty sender address with the domain, eg. in sendmail -f "<>".
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.26 2009/11/13 20:34:51 chl Exp $	*/
a80 1
#define	SMTP_TIMEOUT		120
d124 1
a124 1
	int			 i, ch, tflag = 0, noheader, ret;
d127 1
a127 1
	struct smtp_client	*sp;
d188 1
a188 1
	alarm(SMTP_TIMEOUT);
d193 1
a193 4
	if ((sp = client_init(msg.fd, "localhost")) == NULL)
		err(1, "client_init failed");
	if (verbose)
		client_verbose(sp, stdout);
d201 1
a201 2
	if (client_sender(sp, "%s", msg.from) < 0)
		err(1, "client_sender failed");
d207 1
a207 2
		if (client_rcpt(sp, "%s", msg.rcpts[i]) < 0)
			err(1, "client_rcpt failed");
d210 5
a214 10
	if (!msg.saw_from) {
		if (msg.fromname != NULL) {
			if (client_data_printf(sp,
			    "From: %s <%s>\n", msg.fromname, msg.from) < 0)
				err(1, "client_data_printf failed");
		} else
			if (client_data_printf(sp,
			    "From: %s\n", msg.from) < 0)
				err(1, "client_data_printf failed");
	}
d218 1
a218 3
		if (client_data_printf(sp,
		    "Date: %s\n", time_to_text(timestamp)) < 0)
			err(1, "client_data_printf failed");
d222 2
a223 4
		if (client_data_printf(sp,
		    "Message-Id: <%llu.enqueue@@%s>\n",
			generate_uid(), host) < 0)
			err(1, "client_data_printf failed");
d227 1
a227 2
		if (client_data_printf(sp, "\n") < 0)
			err(1, "client_data_printf failed");
d229 1
a229 2
	if (client_data_printf(sp, "%.*s", buf_size(body), body->buf) < 0)
		err(1, "client_data_printf failed");
d234 9
a242 7
		while ((ret = client_read(sp)) == CLIENT_WANT_READ)
			;
		if (ret == CLIENT_ERROR)
			errx(1, "read error: %s", client_strerror(sp));
		if (ret == CLIENT_RCPT_FAIL)
			errx(1, "recipient refused: %s", client_reply(sp));
		if (ret == CLIENT_DONE)
d244 7
a250 4
		while ((ret = client_write(sp)) == CLIENT_WANT_WRITE)
			;
		if (ret == CLIENT_ERROR)
			errx(1, "write error: %s", client_strerror(sp));
d253 1
a253 1
	client_close(sp);
@


1.26
log
@add missing headers needed by time()

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.25 2009/11/08 21:40:05 gilles Exp $	*/
d481 1
a481 1
	if (strchr(in, '@@') == NULL) {
@


1.25
log
@- make aliases expansion use a rb tree instead of a tail queue, the code
  doesn't take advantage of the new structure yet, but this was a needed
  change for upcoming improvements.
- introduce aliasestree_{lookup,insert,remove} to the aliases api
- rename queue_generate_id() to generate_uid() and move it to utils.c as
  it is used all over the place and not only in queue

tree idea discussed with jacekm@@, if you update rebuild aliases db, make
clean and flush queue
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.24 2009/09/21 20:35:26 jacekm Exp $	*/
d37 1
@


1.24
log
@Expand "&" in the name part of gecos similarly to how sendmail and finger
expand it.  Based on a diff from landry@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.23 2009/09/18 00:04:26 jacekm Exp $	*/
d236 1
a236 1
		    queue_generate_id(), host) < 0)
@


1.23
log
@Remove useless Received line added at the /usr/sbin/sendmail stage, it
was not correctly formatted anyway.  Recording of sender uid has
been moved to the server process (getpeereid), which means it is not
subject to forgery.
Based on problem report by Michael Lechtermann <michael@@lechtermann.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.22 2009/09/16 11:46:17 jacekm Exp $	*/
d293 1
a293 1
		size_t		 len;
d296 13
a308 4
		len++;	/* null termination */
		if ((msg.fromname = malloc(len)) == NULL)
			err(1, NULL);
		strlcpy(msg.fromname, pw->pw_gecos, len);
@


1.22
log
@Ignore sendmail's -L, -A, and -q switches: makes clientmqueue cron
job exit silently.
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.21 2009/09/15 16:50:06 jacekm Exp $	*/
a212 10

	/* prepend Received header */
	if (client_data_printf(sp,
	    "Received: (from %s@@localhost, uid %lu)\n"
	    "\tby %s\n"
	    "\t%s\n",
	    user, (u_long)getuid(),
	    host,
	    time_to_text(timestamp)) < 0)
		err(1, "client_data_printf failed");
@


1.21
log
@Extend SMTP client_* API to support SSL+AUTH, and use it in the mta
process to relay mails.  ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.20 2009/08/27 11:37:30 jacekm Exp $	*/
d133 2
a134 1
	while ((ch = getopt(argc, argv, "46B:b:E::e:F:f:iJ::mo:p:tvx")) != -1) {
d149 1
d155 1
d161 3
@


1.20
log
@Implement client side of the SMTP protocol in a library-like module.
Make bounce code and /usr/sbin/sendmail interface use this new API.
The mta process continues to use its own implementation, but
eventually will be switched to use this shared module.

Buffer routines are taken from buffer.c rather than from evbuffer.
This is one step forward to using a single buffer API across the
program.

"it looks sexy" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.19 2009/08/08 00:23:34 gilles Exp $	*/
d125 1
a125 1
	char			*fake_from = NULL, *ep;
d190 1
a190 1
		client_verbose(sp, STDOUT_FILENO);
d254 1
a254 1
		while ((ret = client_read(sp, &ep)) == CLIENT_WANT_READ)
d256 4
a259 2
		if (ep)
			errx(1, "read error: %s", ep);
d262 1
a262 1
		while (client_write(sp, &ep) == CLIENT_WANT_WRITE)
d264 2
a265 2
		if (ep)
			errx(1, "write error: %s", ep);
@


1.19
log
@fix a small typo with no consequence in the generation of message id when
an enqueued message follows the offline codepath. the code used ',' to
separate components of the message uid when it should have used '.'
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.18 2009/06/07 05:56:25 eric Exp $	*/
d5 1
d40 1
a46 3
void	 femail_write(const void *, size_t);
void	 femail_put(const char *, ...);
void	 send_cmd(const char *);
d48 1
a48 1
int	 parse_message(FILE *, int, int);
a52 1
void	 received(void);
a53 7
int	 read_reply(void);
void	 greeting(int);
void	 mailfrom(char *);
void	 rcptto(char *);
void	 start_data(void);
void	 send_message(int);
void	 end_data(void);
a78 7
#define	STATUS_GREETING		220
#define	STATUS_HELO		250
#define	STATUS_MAILFROM		250
#define	STATUS_RCPTTO		250
#define	STATUS_DATA		354
#define	STATUS_QUEUED		250
#define	STATUS_QUIT		221
d124 5
a128 3
	int		 i, ch, tflag = 0, status, noheader;
	char		*fake_from = NULL;
	struct passwd	*pw;
a180 5
	noheader = parse_message(stdin, fake_from == NULL, tflag);

	if (msg.rcpt_cnt == 0)
		errx(1, "no recipients");

d185 19
a203 4
	if ((status = read_reply()) != STATUS_GREETING)
		errx(1, "server greets us with status %d", status);
	greeting(1);
	mailfrom(msg.from);
d205 2
a206 4
		rcptto(msg.rcpts[i]);
	start_data();
	send_message(noheader);
	end_data();
d208 21
a228 3
	close(msg.fd);
	exit (0);
}
d230 5
a234 4
void
femail_write(const void *buf, size_t nbytes)
{
	ssize_t	n;
d236 6
a241 12
	do {
		n = write(msg.fd, buf, nbytes);
	} while (n == -1 && errno == EINTR);

	if (n == 0)
		errx(1, "write: connection closed");
	if (n == -1)
		err(1, "write");
	if ((size_t)n < nbytes)
		errx(1, "short write: %ld of %lu bytes written",
		    (long)n, (u_long)nbytes);
}
d243 4
a246 5
void
femail_put(const char *fmt, ...)
{
	va_list	ap;
	char	buf[SMTP_LINELEN];
d248 3
a250 4
	va_start(ap, fmt);
	if (vsnprintf(buf, sizeof(buf), fmt, ap) >= (int)sizeof(buf))
		errx(1, "line length exceeded");
	va_end(ap);
d252 13
a264 2
	femail_write(buf, strlen(buf));
}
d266 1
a266 5
void
send_cmd(const char *cmd)
{
	if (verbose)
		printf(">>> %s\n", cmd);
d268 2
a269 1
	femail_put("%s\r\n", cmd);
d306 1
a306 1
parse_message(FILE *fin, int get_from, int tflag)
d308 3
a310 4
	char	*buf, *twodots = "..";
	size_t	 len, new_len;
	void	*newp;
	u_int	 i, cur = HDR_NONE, dotonly;
d350 4
a353 23
			/* save data, \n -> \r\n, . -> .. */
			if (buf[len - 1] == '\n')
				new_len = msg.len + len + 1;
			else
				new_len = msg.len + len + 2;

			if ((len == 1 && buf[0] == '.') ||
			    (len > 1 && buf[0] == '.' && buf[1] == '\n')) {
				dotonly = 1;
				new_len++;
			} else
				dotonly = 0;

			if ((newp = realloc(msg.data, new_len)) == NULL)
				err(1, "realloc header");
			msg.data = newp;
			if (dotonly)
				memcpy(msg.data + msg.len, twodots, 2);
			else
				memcpy(msg.data + msg.len, buf, len);
			msg.len = new_len;
			msg.data[msg.len - 2] = '\r';
			msg.data[msg.len - 1] = '\n';
a494 8
void
received(void)
{
	femail_put(
	    "Received: (from %s@@%s, uid %lu)\r\n\tby %s\r\n\t%s\r\n",
	    user, "localhost", (u_long)getuid(), host, time_to_text(timestamp));
}

a534 170
}

int
read_reply(void)
{
	char		*lbuf = NULL;
	size_t		 len, pos, spos;
	long		 status = 0;
	char		 buf[BUFSIZ];
	ssize_t		 rlen;
	int		 done = 0;

	for (len = pos = spos = 0; !done;) {
		if (pos == 0 ||
		    (pos > 0 && memchr(buf + pos, '\n', len - pos) == NULL)) {
			memmove(buf, buf + pos, len - pos);
			len -= pos;
			pos = 0;
			if ((rlen = read(msg.fd, buf + len,
			    sizeof(buf) - len)) == -1)
				err(1, "read");
			len += rlen;
		}
		spos = pos;

		/* status code */
		for (; pos < len && buf[pos] >= '0' && buf[pos] <= '9'; pos++)
			;	/* nothing */

		if (pos == len)
			return (0);

		if (buf[pos] == ' ')
			done = 1;
		else if (buf[pos] != '-')
			errx(1, "invalid syntax in reply from server");

		/* skip up to \n */
		for (; pos < len && buf[pos - 1] != '\n'; pos++)
			;	/* nothing */

		if (verbose) {
			size_t	clen;

			clen = pos - spos + 1;	/* + 1 for trailing \0 */
			if (buf[pos - 1] == '\n')
				clen--;
			if (buf[pos - 2] == '\r')
				clen--;
			if ((lbuf = malloc(clen)) == NULL)
				err(1, NULL);
			strlcpy(lbuf, buf + spos, clen);
			printf("<<< %s\n", lbuf);
			free(lbuf);
		}
	}

	status = strtol(buf, NULL, 10);
	if (status < 100 || status > 999)
		errx(1, "error reading status: out of range");

	return (status);
}

void
greeting(int use_ehlo)
{
	int	 status;
	char	*cmd, *how;

	if (use_ehlo)
		how = "EHLO";
	else
		how = "HELO";

	if (asprintf(&cmd, "%s %s", how, host) == -1)
		err(1, "asprintf");
	send_cmd(cmd);
	free(cmd);

	if ((status = read_reply()) != STATUS_HELO) {
		if (use_ehlo)
			greeting(0);
		else
			errx(1, "remote host refuses our greeting");
	}
}

void
mailfrom(char *addr)
{
	int	 status;
	char	*cmd;

	if (asprintf(&cmd, "MAIL FROM:<%s>", addr) == -1)
		err(1, "asprintf");
	send_cmd(cmd);
	free(cmd);

	if ((status = read_reply()) != STATUS_MAILFROM)
		errx(1, "mail from %s refused by server", addr);
}

void
rcptto(char *addr)
{
	int	 status;
	char	*cmd;

	if (asprintf(&cmd, "RCPT TO:<%s>", addr) == -1)
		err(1, "asprintf");
	send_cmd(cmd);
	free(cmd);

	if ((status = read_reply()) != STATUS_RCPTTO)
		errx(1, "rcpt to %s refused by server", addr);
}

void
start_data(void)
{
	int	 status;

	send_cmd("DATA");

	if ((status = read_reply()) != STATUS_DATA)
		errx(1, "server sends error after DATA");
}

void
send_message(int noheader)
{
	/* our own headers */
	received();

	if (!msg.saw_from) {
		if (msg.fromname != NULL)
			femail_put("From: %s <%s>\r\n", msg.fromname, msg.from);
		else
			femail_put("From: %s\r\n", msg.from);
	}

	if (!msg.saw_date)
		femail_put("Date: %s\r\n", time_to_text(timestamp));

	if (!msg.saw_msgid)
		femail_put("Message-Id: <%llu.enqueue@@%s>\r\n",
		    queue_generate_id(), host);

	if (noheader)
		femail_write("\r\n", 2);

	if (msg.data != NULL)
		femail_write(msg.data, msg.len);
}

void
end_data(void)
{
	int	status;

	femail_write(".\r\n", 3);

	if ((status = read_reply()) != STATUS_QUEUED)
		errx(1, "error after sending mail, got status %d", status);

	send_cmd("QUIT");

	if ((status = read_reply()) != STATUS_QUIT)
		errx(1, "server sends error after QUIT");
@


1.18
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.17 2009/06/05 20:43:57 pyr Exp $	*/
d729 1
a729 1
	if (! bsnprintf(path, sizeof(path), "%s%s/%d,XXXXXXXXXX", PATH_SPOOL,
@


1.17
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.16 2009/05/25 11:17:32 jacekm Exp $	*/
d543 1
a543 1
		fd = imsg_get_fd(ibuf);
@


1.16
log
@Disallow submission using /usr/sbin/sendmail while the server is
paused, configuring, or exiting; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.15 2009/05/14 15:05:12 eric Exp $	*/
d543 1
a543 1
		fd = imsg_get_fd(ibuf, &imsg);
@


1.15
log
@use the nitems() macro where appropriate

ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.14 2009/04/21 18:12:05 jacekm Exp $	*/
d533 9
@


1.14
log
@Make /usr/sbin/sendmail not fail due to smtpd being down.

The approach is to save cmdline + stdin in a file under a newly
added directory /var/spool/smtpd/offline (uid 0 gid 0 mode 1777).
Next time daemon starts, it uses information in that directory
to replay sendmail on user's behalf.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.13 2009/04/17 16:26:18 jacekm Exp $	*/
d328 1
a328 1
		    i < (sizeof(keywords) / sizeof(keywords[0])); i++)
@


1.13
log
@handle case when no input is provided, fixes confusing error:

$ echo -n | sendmail root
sendmail: write: connection closed
$
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.12 2009/04/16 15:35:06 jacekm Exp $	*/
a62 1
int	 enqueue(int, char **);
d711 47
@


1.12
log
@Total rewrite of the sendmail interface. Adds support for -t, -v,
and -F cmdline args. Also, date and Message-Id headers are added
when missing.

The main trouble with the current enqueue code is that it requires
dealing with problems in the control process that are already solved
in the smtp process, ie. duplicating a lot of code which interacts
with untrusted clients. This diff solves this by making sendmail
obtain a SMTP socket from smtp via smtpd.sock, and using that socket
to deliver the message. For smtpd it looks as if connection was
made from the network, only difference being the F_MESSAGE_ENQUEUED
message flag, handy when differentation between local and remote
deliveries is wanted.

Most of the features come from the femail program, created by henning@@.

Additional testing by Nigel J. Taylor.

ok gilles@@, henning@@ happy with smtpd using femail code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d694 2
a695 1
	femail_write(msg.data, msg.len);
@


1.11
log
@ignore -o option (for now at least) when working in enqueue mode, this
prevents smtpctl from choking and allows it to work with more mua's by
default.

spotted and added to my todo list by oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.10 2009/03/01 12:10:24 jacekm Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d14 3
a16 3
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d19 1
a19 1
#include <sys/types.h>
d21 1
d23 1
a23 6
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <netinet/in.h>
#include <arpa/inet.h>
d29 1
d31 2
d42 95
a136 7
__dead void	usage(void);
int		enqueue(int, char **);
int		enqueue_init(struct message *);
int		enqueue_add_recipient(struct message *, char *);
int		enqueue_messagefd(struct message *);
int		enqueue_write_message(FILE *, FILE *);
int		enqueue_commit(struct message *);
d141 3
a143 15
	int		ch;
	int		fd;
	FILE		*fpout;
	struct message	message;
	char		sender[MAX_PATH_SIZE];

	uid_t uid;
	char *username;
	char hostname[MAXHOSTNAMELEN];
	struct passwd *pw;

	uid = getuid();
	pw = safe_getpwuid(uid);
	if (pw == NULL)
		errx(1, "you don't exist, go away.");
d145 2
a146 2
	username = pw->pw_name;
	gethostname(hostname, sizeof(hostname));
d148 1
a148 4
	if (! bsnprintf(sender, sizeof(sender), "%s@@%s", username, hostname))
		errx(1, "sender address too long.");

	while ((ch = getopt(argc, argv, "f:i")) != -1) {
d151 4
a154 3
			if (strlcpy(sender, optarg, sizeof(sender))
			    >= sizeof(sender))
				errx(1, "sender address too long.");
d156 13
a168 1
		case 'i': /* ignore, interface compatibility */
d170 2
d181 16
a196 1
	bzero(&message, sizeof(struct message));
d198 2
a199 27
	strlcpy(message.session_helo, "localhost",
	    sizeof(message.session_helo));
	strlcpy(message.session_hostname, hostname,
	    sizeof(message.session_hostname));
	
	/* build sender */
	if (! recipient_to_path(&message.sender, sender))
		errx(1, "invalid sender address.");
	
	if (! enqueue_init(&message))
		errx(1, "failed to initialize enqueue message.");
	
	if (argc == 0)
		errx(1, "no recipient.");

	while (argc--) {
		if (! enqueue_add_recipient(&message, *argv))
			errx(1, "invalid recipient.");
		++argv;
	}

	fd = enqueue_messagefd(&message);
	if (fd == -1 || (fpout = fdopen(fd, "w")) == NULL)
		errx(1, "failed to open message file for writing.");

	if (! enqueue_write_message(stdin, fpout))
		errx(1, "failed to write message to message file.");
d201 2
a202 2
	if (! safe_fclose(fpout))
		errx(1, "error while writing to message file.");
d204 10
a213 2
	if (! enqueue_commit(&message))
		errx(1, "failed to commit message to queue.");
d215 2
a216 1
	return 0;
d219 20
a238 2
int
enqueue_add_recipient(struct message *messagep, char *recipient)
d240 2
a241 43
	char buffer[MAX_PATH_SIZE];
	struct message_recipient mr;
	struct sockaddr_in6 *ssin6;
	struct sockaddr_in *ssin;
	struct message message;
	int done = 0;
	int n;
	struct imsg imsg;

	bzero(&mr, sizeof(mr));

	message = *messagep;

	if (strlcpy(buffer, recipient, sizeof(buffer)) >= sizeof(buffer))
		errx(1, "recipient address too long.");

	if (strchr(buffer, '@@') == NULL) {
		if (! bsnprintf(buffer, sizeof(buffer), "%s@@%s",
			buffer, messagep->sender.domain))
			errx(1, "recipient address too long.");
	}
	
	if (! recipient_to_path(&message.recipient, buffer))
		errx(1, "invalid recipient address.");

	message.session_rcpt = message.recipient;

	mr.ss.ss_family = AF_INET6;
	mr.ss.ss_len = sizeof(*ssin6);
	ssin6 = (struct sockaddr_in6 *)&mr.ss;
	if (inet_pton(AF_INET6, "::1", &ssin6->sin6_addr) != 1) {
		mr.ss.ss_family = AF_INET;
		mr.ss.ss_len = sizeof(*ssin);
		ssin = (struct sockaddr_in *)&mr.ss;
		if (inet_pton(AF_INET, "127.0.0.1", &ssin->sin_addr) != 1)
			return 0;
	}
	message.session_ss = mr.ss;

	mr.path = message.recipient;
	mr.id = message.session_id;
	mr.msg = message;
	mr.msg.flags |= F_MESSAGE_ENQUEUED;
d243 7
a249 4
	imsg_compose(ibuf, IMSG_MFA_RCPT, 0, 0, -1, &mr, sizeof (mr));
	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) < 0)
			err(1, "write error");	
d251 5
a255 5
	while (!done) {
		if ((n = imsg_read(ibuf)) == -1)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");
d257 2
a258 2
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			errx(1, "imsg_get error");
d260 4
a263 2
		if (n == 0)
			continue;
d265 15
a279 11
		done = 1;
		switch (imsg.hdr.type) {
		case IMSG_CTL_OK: {
			return 1;
		}
		case IMSG_CTL_FAIL:
			return 0;
		default:
			errx(1, "unexpected reply (%d)", imsg.hdr.type);
		}
		imsg_free(&imsg);
d282 9
a290 1
	return 1;
d294 1
a294 1
enqueue_write_message(FILE *fpin, FILE *fpout)
d296 85
a380 19
	char *buf, *lbuf;
	size_t len;
	
	lbuf = NULL;
	while ((buf = fgetln(fpin, &len))) {
		if (buf[len - 1] == '\n') {
			buf[len - 1] = '\0';
			len--;
		}
		else {
			/* EOF without EOL, copy and add the NUL */
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}
		if (fprintf(fpout, "%s\n", buf) != (int)len + 1)
			return 0;
d382 2
a383 2
	free(lbuf);
	return 1;
d386 2
a387 2
int
enqueue_init(struct message *messagep)
d389 65
a453 3
	int done = 0;
	int n;
	struct imsg imsg;
d455 20
a474 4
	imsg_compose(ibuf, IMSG_QUEUE_CREATE_MESSAGE, 0, 0, -1, messagep, sizeof(*messagep));
	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) < 0)
			err(1, "write error");	
d476 4
a479 5
	while (!done) {
		if ((n = imsg_read(ibuf)) == -1)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");
d481 6
a486 2
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			errx(1, "imsg_get error");
d488 2
a489 2
		if (n == 0)
			continue;
d491 4
a494 9
		done = 1;
		switch (imsg.hdr.type) {
		case IMSG_CTL_OK: {
			struct message *mp;
			
			mp = imsg.data;
			messagep->session_id = mp->session_id;
			strlcpy(messagep->message_id, mp->message_id,
			    sizeof(messagep->message_id));
d496 6
a501 9
			return 1;
		}
		case IMSG_CTL_FAIL:
			return 0;
		default:
			err(1, "unexpected reply (%d)", imsg.hdr.type);
		}
		imsg_free(&imsg);
	}
d503 6
a508 1
	return 0;
d512 1
a512 1
enqueue_messagefd(struct message *messagep)
d514 5
a518 3
	int done = 0;
	int n;
	struct imsg imsg;
a519 1
	imsg_compose(ibuf, IMSG_QUEUE_MESSAGE_FILE, 0, 0, -1, messagep, sizeof(*messagep));
d522 1
a522 1
			err(1, "write error");	
d524 1
a524 1
	while (!done) {
a531 1

d535 61
a595 8
		done = 1;
		switch (imsg.hdr.type) {
		case IMSG_CTL_OK:
			return imsg_get_fd(ibuf, &imsg);
		case IMSG_CTL_FAIL:
			return -1;
		default:
			err(1, "unexpected reply (%d)", imsg.hdr.type);
a596 1
		imsg_free(&imsg);
d599 29
a627 1
	return -1;
d630 10
d641 6
a646 2
int
enqueue_commit(struct message *messagep)
d648 2
a649 3
	int done = 0;
	int n;
	struct imsg imsg;
d651 13
a663 4
	imsg_compose(ibuf, IMSG_QUEUE_COMMIT_MESSAGE, 0, 0, -1, messagep, sizeof(*messagep));
	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) < 0)
			err(1, "write error");	
d665 1
a665 5
	while (!done) {
		if ((n = imsg_read(ibuf)) == -1)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");
d667 3
a669 2
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			errx(1, "imsg_get error");
d671 5
a675 2
		if (n == 0)
			continue;
d677 5
a681 12
		done = 1;
		switch (imsg.hdr.type) {
		case IMSG_CTL_OK: {
			return 1;
		}
		case IMSG_CTL_FAIL: {
			return 0;
		}
		default:
			err(1, "unexpected reply (%d)", imsg.hdr.type);
		}
		imsg_free(&imsg);
d684 27
a710 1
	return 0;
@


1.10
log
@ss_len was set to sizeof pointer, should be sizeof structure; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.9 2009/02/22 11:44:29 form Exp $	*/
d83 2
a84 1
		case 'i':
@


1.9
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.8 2009/01/29 15:20:34 gilles Exp $	*/
d163 1
a163 1
	mr.ss.ss_len = sizeof(ssin6);
d167 1
a167 1
		mr.ss.ss_len = sizeof(ssin);
@


1.8
log
@Received header line was incomplete for mail submitted through the enqueuer
as well as for some outgoing messages, this is fixed now
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.7 2009/01/29 10:18:27 gilles Exp $	*/
d73 1
a73 2
	if (! bsnprintf(sender, MAX_PATH_SIZE, "%s@@%s",
		username, hostname))
d79 2
a80 2
			if (strlcpy(sender, optarg, MAX_PATH_SIZE)
			    >= MAX_PATH_SIZE)
d95 4
a98 2
	strlcpy(message.session_helo, "localhost", MAXHOSTNAMELEN);
	strlcpy(message.session_hostname, hostname, MAXHOSTNAMELEN);
d270 2
a271 1
			strlcpy(messagep->message_id, mp->message_id, MAXPATHLEN);
@


1.7
log
@- remove a very annoying debug printf()
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.6 2009/01/28 19:49:57 jacekm Exp $	*/
d95 3
d171 1
@


1.6
log
@cleanup; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.5 2009/01/28 14:15:51 gilles Exp $	*/
a151 2

	printf("recipient: %s", buffer);
@


1.5
log
@if recipient was provided as a username, append the local hostname, this
unbreaks:

$ echo foo | mail gilles
send-mail: invalid recipient address.
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.4 2009/01/28 11:27:57 gilles Exp $	*/
d100 1
a100 1
	if (! enqueue_init(&message)) {
a101 2
		return 1;
	}
d103 2
a104 4
	if (argc == 0) {
		fprintf(stdout, "no recipient.\n");
		return 1;
	}
d113 1
a113 1
	if (fd == -1 || (fpout = fdopen(fd, "w")) == NULL) {
a114 2
		return 1;
	}
d116 1
a116 1
	if (! enqueue_write_message(stdin, fpout)) {
a117 3
		return 1;
	}
	safe_fclose(fpout);
d119 4
a122 1
	if (! enqueue_commit(&message)) {
a123 2
		return 1;
	}
d144 1
a144 1
	if (strlcpy(buffer, recipient, sizeof(buffer)) >= sizeof(buffer)) {
a145 2
		return 0;
	}
d155 1
a155 1
	if (! recipient_to_path(&message.recipient, buffer)) {
a156 2
		return 0;
	}
d201 1
a201 1
			err(1, "unexpected reply (%d)", imsg.hdr.type);
a204 1

@


1.4
log
@add a struct path to struct message so that we can keep track of the RCPT
provided recipient even after aliases/forwards expansion, we'll need this
for loop detection.

message id and uid being MAXPATHLEN long is a waste, define MAX_ID_SIZE
which is currently set to 64 (but can probably be further reduced) and
make sure that structures and the few strlcpy's use the right define.

original idea by jacekm@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.3 2009/01/28 00:19:27 gilles Exp $	*/
d156 8
@


1.3
log
@a bit of enqueue cleanup, and while at it set the sender local address to
::1 (fallback to 127.0.0.1) before sending the enqueue request.
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.2 2009/01/28 00:09:54 gilles Exp $	*/
d161 2
@


1.2
log
@- remove debug messages
@
text
@d1 1
a1 1
/*	$OpenBSD: enqueue.c,v 1.1 2009/01/27 22:48:29 gilles Exp $	*/
d95 1
a95 1

d99 1
a99 1

d101 1
d141 1
d162 10
a171 6
	/* NEEDS_FIX */
	mr.ss.ss_family = AF_INET;
	mr.ss.ss_len = sizeof(ssin);
	ssin = (struct sockaddr_in *)&mr.ss;
	if (inet_pton(AF_INET, "127.0.0.1", &ssin->sin_addr) != 1)
		return 0;
@


1.1
log
@first bricks of enqueue code which allows smtpctl to submit mail to queue
without "talking" smtp to listeners. currently, a big part of the server
side code is done (and requires a cleanup), next step is to get it usable
properly from a mail user agent.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a72 3
	fprintf(stdout, "username: %s\n", username);
	fprintf(stdout, "hostname: %s\n", hostname);

a103 2
	fprintf(stdout, "created layout with id: %s\n", message.message_id);

@

