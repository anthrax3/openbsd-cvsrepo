head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.2
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.29
date	2017.03.17.20.57.57;	author eric;	state Exp;
branches;
next	1.28;
commitid	HN2G714NH93Ax0XY;

1.28
date	2016.09.14.08.59.56;	author eric;	state Exp;
branches;
next	1.27;
commitid	Pzp5KcDMwOAOgDJB;

1.27
date	2016.09.08.12.06.43;	author eric;	state Exp;
branches;
next	1.26;
commitid	LkfnyKFoItZAAepX;

1.26
date	2016.09.03.16.06.26;	author eric;	state Exp;
branches;
next	1.25;
commitid	KHEgnvbdOZ4TgZyl;

1.25
date	2016.09.02.13.41.10;	author eric;	state Exp;
branches;
next	1.24;
commitid	skjTtyB6IjCnwknY;

1.24
date	2016.09.01.15.12.45;	author eric;	state Exp;
branches;
next	1.23;
commitid	c7xQVmVRnL8xbXxX;

1.23
date	2016.09.01.14.19.33;	author eric;	state Exp;
branches;
next	1.22;
commitid	CLoiVOfpDThHGgHG;

1.22
date	2016.09.01.10.07.20;	author eric;	state Exp;
branches;
next	1.21;
commitid	Ch0RMqdovbewwGAQ;

1.21
date	2016.08.31.21.49.01;	author eric;	state Exp;
branches;
next	1.20;
commitid	nfyDx1DVV3J9mwcW;

1.20
date	2016.06.06.20.48.15;	author eric;	state Exp;
branches;
next	1.19;
commitid	STAXJwSzLFzYP3HL;

1.19
date	2016.03.25.15.06.58;	author krw;	state Exp;
branches;
next	1.18;
commitid	0NIU7T9t8yqZHZQl;

1.18
date	2016.02.10.15.03.37;	author millert;	state Exp;
branches;
next	1.17;
commitid	K8DtK2ihAjAP4aL7;

1.17
date	2016.02.09.11.50.49;	author sunil;	state Exp;
branches;
next	1.16;
commitid	ptRtJkxCooGHNdZi;

1.16
date	2015.12.05.13.14.21;	author claudio;	state Exp;
branches;
next	1.15;
commitid	ZUSyGL2qGrdiWU8r;

1.15
date	2015.10.14.21.27.29;	author gilles;	state Exp;
branches;
next	1.14;
commitid	GiSaMJW1H8O9FDIr;

1.14
date	2015.10.14.21.18.19;	author gilles;	state Exp;
branches;
next	1.13;
commitid	QRY2X4Ru3Pci1doN;

1.13
date	2015.10.02.00.32.05;	author gilles;	state Exp;
branches;
next	1.12;
commitid	7ODx5x7OP8OY3kPb;

1.12
date	2015.06.11.19.27.16;	author gilles;	state Exp;
branches
	1.12.4.1;
next	1.11;
commitid	GEcjZqjmmeXkyNAX;

1.11
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches
	1.11.2.1;
next	1.10;
commitid	Uu5nFG3wCl0LACBb;

1.10
date	2014.07.08.13.49.09;	author eric;	state Exp;
branches
	1.10.4.1;
next	1.9;
commitid	pEybL9fsrDOC6PJj;

1.9
date	2014.04.29.19.13.13;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.19.17.45.05;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2013.11.21.08.35.54;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.24.19.20.46;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2013.07.19.15.18.42;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	;

1.10.4.1
date	2015.06.11.19.24.38;	author gilles;	state Exp;
branches;
next	1.10.4.2;
commitid	2MgOc7xM534QdvKb;

1.10.4.2
date	2015.10.02.01.33.33;	author gilles;	state Exp;
branches;
next	;
commitid	2Q56YgF5PzqMcagu;

1.11.2.1
date	2015.06.11.19.25.36;	author gilles;	state Exp;
branches;
next	1.11.2.2;
commitid	LgFG0Lz9wu3aNTWL;

1.11.2.2
date	2015.10.02.01.28.43;	author gilles;	state Exp;
branches;
next	;
commitid	pAamrt3DJscJjb10;

1.12.4.1
date	2015.10.02.00.55.02;	author gilles;	state Exp;
branches;
next	;
commitid	5SntIHNUPMG4dcQ1;


desc
@@


1.29
log
@switch to recallocarray() and remove useless pre-allocation.

prodded by deraadt@@ ok gilles@@
@
text
@/*	$OpenBSD: mproc.c,v 1.28 2016/09/14 08:59:56 eric Exp $	*/

/*
 * Copyright (c) 2012 Eric Faurot <eric@@faurot.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/tree.h>
#include <sys/queue.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <err.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

static void mproc_dispatch(int, short, void *);

static ssize_t imsg_read_nofd(struct imsgbuf *);

int
mproc_fork(struct mproc *p, const char *path, char *argv[])
{
	int sp[2];

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, sp) < 0)
		return (-1);

	io_set_nonblocking(sp[0]);
	io_set_nonblocking(sp[1]);

	if ((p->pid = fork()) == -1)
		goto err;

	if (p->pid == 0) {
		/* child process */
		dup2(sp[0], STDIN_FILENO);
		if (closefrom(STDERR_FILENO + 1) < 0)
			exit(1);

		execv(path, argv);
		err(1, "execv: %s", path);
	}

	/* parent process */
	close(sp[0]);
	mproc_init(p, sp[1]);
	return (0);

err:
	log_warn("warn: Failed to start process %s, instance of %s", argv[0], path);
	close(sp[0]);
	close(sp[1]);
	return (-1);
}

void
mproc_init(struct mproc *p, int fd)
{
	imsg_init(&p->imsgbuf, fd);
}

void
mproc_clear(struct mproc *p)
{
	log_debug("debug: clearing p=%s, fd=%d, pid=%d", p->name, p->imsgbuf.fd, p->pid);

	event_del(&p->ev);
	close(p->imsgbuf.fd);
	imsg_clear(&p->imsgbuf);
}

void
mproc_enable(struct mproc *p)
{
	if (p->enable == 0) {
		log_trace(TRACE_MPROC, "mproc: %s -> %s: enabled",
		    proc_name(smtpd_process),
		    proc_name(p->proc));
		p->enable = 1;
	}
	mproc_event_add(p);
}

void
mproc_disable(struct mproc *p)
{
	if (p->enable == 1) {
		log_trace(TRACE_MPROC, "mproc: %s -> %s: disabled",
		    proc_name(smtpd_process),
		    proc_name(p->proc));
		p->enable = 0;
	}
	mproc_event_add(p);
}

void
mproc_event_add(struct mproc *p)
{
	short	events;

	if (p->enable)
		events = EV_READ;
	else
		events = 0;

	if (p->imsgbuf.w.queued)
		events |= EV_WRITE;

	if (p->events)
		event_del(&p->ev);

	p->events = events;
	if (events) {
		event_set(&p->ev, p->imsgbuf.fd, events, mproc_dispatch, p);
		event_add(&p->ev, NULL);
	}
}

static void
mproc_dispatch(int fd, short event, void *arg)
{
	struct mproc	*p = arg;
	struct imsg	 imsg;
	ssize_t		 n;

	p->events = 0;

	if (event & EV_READ) {

		if (p->proc == PROC_CLIENT)
			n = imsg_read_nofd(&p->imsgbuf);
		else
			n = imsg_read(&p->imsgbuf);

		switch (n) {
		case -1:
			if (errno == EAGAIN)
				break;
			log_warn("warn: %s -> %s: imsg_read",
			    proc_name(smtpd_process),  p->name);
			fatal("exiting");
			/* NOTREACHED */
		case 0:
			/* this pipe is dead, so remove the event handler */
			log_debug("debug: %s -> %s: pipe closed",
			    proc_name(smtpd_process),  p->name);
			p->handler(p, NULL);
			return;
		default:
			break;
		}
	}

	if (event & EV_WRITE) {
		n = msgbuf_write(&p->imsgbuf.w);
		if (n == 0 || (n == -1 && errno != EAGAIN)) {
			/* this pipe is dead, so remove the event handler */
			log_debug("debug: %s -> %s: pipe closed",
			    proc_name(smtpd_process),  p->name);
			p->handler(p, NULL);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(&p->imsgbuf, &imsg)) == -1) {

			if (smtpd_process == PROC_CONTROL &&
			    p->proc == PROC_CLIENT) {
				log_warnx("warn: client sent invalid imsg "
				    "over control socket");
				p->handler(p, NULL);
				return;
			}
			log_warn("fatal: %s: error in imsg_get for %s",
			    proc_name(smtpd_process),  p->name);
			fatalx(NULL);
		}
		if (n == 0)
			break;

		p->handler(p, &imsg);

		imsg_free(&imsg);
	}

	mproc_event_add(p);
}

/* This should go into libutil */
static ssize_t
imsg_read_nofd(struct imsgbuf *ibuf)
{
	ssize_t	 n;
	char	*buf;
	size_t	 len;

	buf = ibuf->r.buf + ibuf->r.wpos;
	len = sizeof(ibuf->r.buf) - ibuf->r.wpos;

	while ((n = recv(ibuf->fd, buf, len, 0)) == -1) {
		if (errno != EINTR)
			return (n);
	}

	ibuf->r.wpos += n;
	return (n);
}

void
m_forward(struct mproc *p, struct imsg *imsg)
{
	imsg_compose(&p->imsgbuf, imsg->hdr.type, imsg->hdr.peerid,
	    imsg->hdr.pid, imsg->fd, imsg->data,
	    imsg->hdr.len - sizeof(imsg->hdr));

	if (imsg->hdr.type != IMSG_STAT_DECREMENT &&
	    imsg->hdr.type != IMSG_STAT_INCREMENT)
		log_trace(TRACE_MPROC, "mproc: %s -> %s : %zu %s (forward)",
		    proc_name(smtpd_process),
		    proc_name(p->proc),
		    imsg->hdr.len - sizeof(imsg->hdr),
		    imsg_to_str(imsg->hdr.type));

	mproc_event_add(p);
}

void
m_compose(struct mproc *p, uint32_t type, uint32_t peerid, pid_t pid, int fd,
    void *data, size_t len)
{
	imsg_compose(&p->imsgbuf, type, peerid, pid, fd, data, len);

	if (type != IMSG_STAT_DECREMENT &&
	    type != IMSG_STAT_INCREMENT)
		log_trace(TRACE_MPROC, "mproc: %s -> %s : %zu %s",
		    proc_name(smtpd_process),
		    proc_name(p->proc),
		    len,
		    imsg_to_str(type));

	mproc_event_add(p);
}

void
m_composev(struct mproc *p, uint32_t type, uint32_t peerid, pid_t pid,
    int fd, const struct iovec *iov, int n)
{
	size_t	len;
	int	i;

	imsg_composev(&p->imsgbuf, type, peerid, pid, fd, iov, n);

	len = 0;
	for (i = 0; i < n; i++)
		len += iov[i].iov_len;

	if (type != IMSG_STAT_DECREMENT &&
	    type != IMSG_STAT_INCREMENT)
		log_trace(TRACE_MPROC, "mproc: %s -> %s : %zu %s",
		    proc_name(smtpd_process),
		    proc_name(p->proc),
		    len,
		    imsg_to_str(type));

	mproc_event_add(p);
}

void
m_create(struct mproc *p, uint32_t type, uint32_t peerid, pid_t pid, int fd)
{
	p->m_pos = 0;
	p->m_type = type;
	p->m_peerid = peerid;
	p->m_pid = pid;
	p->m_fd = fd;
}

void
m_add(struct mproc *p, const void *data, size_t len)
{
	size_t	 alloc;
	void	*tmp;

	if (p->m_pos + len + IMSG_HEADER_SIZE > MAX_IMSGSIZE) {
		log_warnx("warn: message to large");
		fatal(NULL);
	}

	alloc = p->m_alloc ? p->m_alloc : 128;
	while (p->m_pos + len > alloc)
		alloc *= 2;
	if (alloc != p->m_alloc) {
		log_trace(TRACE_MPROC, "mproc: %s -> %s: realloc %zu -> %zu",
		    proc_name(smtpd_process),
		    proc_name(p->proc),
		    p->m_alloc,
		    alloc);

		tmp = recallocarray(p->m_buf, p->m_alloc, alloc, 1);
		if (tmp == NULL)
			fatal("realloc");
		p->m_alloc = alloc;
		p->m_buf = tmp;
	}

	memmove(p->m_buf + p->m_pos, data, len);
	p->m_pos += len;
}

void
m_close(struct mproc *p)
{
	if (imsg_compose(&p->imsgbuf, p->m_type, p->m_peerid, p->m_pid, p->m_fd,
	    p->m_buf, p->m_pos) == -1)
		fatal("imsg_compose");

	log_trace(TRACE_MPROC, "mproc: %s -> %s : %zu %s",
		    proc_name(smtpd_process),
		    proc_name(p->proc),
		    p->m_pos,
		    imsg_to_str(p->m_type));

	mproc_event_add(p);
}

void
m_flush(struct mproc *p)
{
	if (imsg_compose(&p->imsgbuf, p->m_type, p->m_peerid, p->m_pid, p->m_fd,
	    p->m_buf, p->m_pos) == -1)
		fatal("imsg_compose");

	log_trace(TRACE_MPROC, "mproc: %s -> %s : %zu %s (flush)",
	    proc_name(smtpd_process),
	    proc_name(p->proc),
	    p->m_pos,
	    imsg_to_str(p->m_type));

	p->m_pos = 0;

	imsg_flush(&p->imsgbuf);
}

static struct imsg * current;

static void
m_error(const char *error)
{
	char	buf[512];

	(void)snprintf(buf, sizeof buf, "%s: %s: %s",
	    proc_name(smtpd_process),
	    imsg_to_str(current->hdr.type),
	    error);
	fatalx("%s", buf);
}

void
m_msg(struct msg *m, struct imsg *imsg)
{
	current = imsg;
	m->pos = imsg->data;
	m->end = m->pos + (imsg->hdr.len - sizeof(imsg->hdr));
}

void
m_end(struct msg *m)
{
	if (m->pos != m->end)
		m_error("not at msg end");
}

int
m_is_eom(struct msg *m)
{
	return (m->pos == m->end);
}

static inline void
m_get(struct msg *m, void *dst, size_t sz)
{
	if (sz > MAX_IMSGSIZE ||
	    m->end - m->pos < (ssize_t)sz)
		fatalx("msg too short");

	memmove(dst, m->pos, sz);
	m->pos += sz;
}

void
m_add_int(struct mproc *m, int v)
{
	m_add(m, &v, sizeof(v));
};

void
m_add_u32(struct mproc *m, uint32_t u32)
{
	m_add(m, &u32, sizeof(u32));
};

void
m_add_size(struct mproc *m, size_t sz)
{
	m_add(m, &sz, sizeof(sz));
};

void
m_add_time(struct mproc *m, time_t v)
{
	m_add(m, &v, sizeof(v));
};

void
m_add_string(struct mproc *m, const char *v)
{
	m_add(m, v, strlen(v) + 1);
};

void
m_add_data(struct mproc *m, const void *v, size_t len)
{
	m_add_size(m, len);
	m_add(m, v, len);
};

void
m_add_id(struct mproc *m, uint64_t v)
{
	m_add(m, &v, sizeof(v));
}

void
m_add_evpid(struct mproc *m, uint64_t v)
{
	m_add(m, &v, sizeof(v));
}

void
m_add_msgid(struct mproc *m, uint32_t v)
{
	m_add(m, &v, sizeof(v));
}

void
m_add_sockaddr(struct mproc *m, const struct sockaddr *sa)
{
	m_add_size(m, sa->sa_len);
	m_add(m, sa, sa->sa_len);
}

void
m_add_mailaddr(struct mproc *m, const struct mailaddr *maddr)
{
	m_add(m, maddr, sizeof(*maddr));
}

void
m_add_envelope(struct mproc *m, const struct envelope *evp)
{
	char	buf[sizeof(*evp)];

	envelope_dump_buffer(evp, buf, sizeof(buf));
	m_add_evpid(m, evp->id);
	m_add_string(m, buf);
}

void
m_add_params(struct mproc *m, struct dict *d)
{
	const char *key;
	char *value;
	void *iter;

	if (d == NULL) {
		m_add_size(m, 0);
		return;
	}
	m_add_size(m, dict_count(d));
	iter = NULL;
	while (dict_iter(d, &iter, &key, (void **)&value)) {
		m_add_string(m, key);
		m_add_string(m, value);
	}
}

void
m_get_int(struct msg *m, int *i)
{
	m_get(m, i, sizeof(*i));
}

void
m_get_u32(struct msg *m, uint32_t *u32)
{
	m_get(m, u32, sizeof(*u32));
}

void
m_get_size(struct msg *m, size_t *sz)
{
	m_get(m, sz, sizeof(*sz));
}

void
m_get_time(struct msg *m, time_t *t)
{
	m_get(m, t, sizeof(*t));
}

void
m_get_string(struct msg *m, const char **s)
{
	uint8_t	*end;

	if (m->pos >= m->end)
		m_error("msg too short");

	end = memchr(m->pos, 0, m->end - m->pos);
	if (end == NULL)
		m_error("unterminated string");

	*s = m->pos;
	m->pos = end + 1;
}

void
m_get_data(struct msg *m, const void **data, size_t *sz)
{
	m_get_size(m, sz);

	if (m->pos + *sz > m->end)
		m_error("msg too short");

	*data = m->pos;
	m->pos += *sz;
}

void
m_get_evpid(struct msg *m, uint64_t *evpid)
{
	m_get(m, evpid, sizeof(*evpid));
}

void
m_get_msgid(struct msg *m, uint32_t *msgid)
{
	m_get(m, msgid, sizeof(*msgid));
}

void
m_get_id(struct msg *m, uint64_t *id)
{
	m_get(m, id, sizeof(*id));
}

void
m_get_sockaddr(struct msg *m, struct sockaddr *sa)
{
	size_t len;

	m_get_size(m, &len);
	m_get(m, sa, len);
}

void
m_get_mailaddr(struct msg *m, struct mailaddr *maddr)
{
	m_get(m, maddr, sizeof(*maddr));
}

void
m_get_envelope(struct msg *m, struct envelope *evp)
{
	uint64_t	 evpid;
	const char	*buf;

	m_get_evpid(m, &evpid);
	m_get_string(m, &buf);

	if (!envelope_load_buffer(evp, buf, strlen(buf)))
		fatalx("failed to retrieve envelope");
	evp->id = evpid;
}

void
m_get_params(struct msg *m, struct dict *d)
{
	size_t	c;
	const char *key;
	const char *value;
	char *tmp;

	dict_init(d);

	m_get_size(m, &c);

	for (; c; c--) {
		m_get_string(m, &key);
		m_get_string(m, &value);
		if ((tmp = strdup(value)) == NULL)
			fatal("m_get_params");
		dict_set(d, key, tmp);
	}
}

void
m_clear_params(struct dict *d)
{
	char *value;

	while (dict_poproot(d, (void **)&value))
		free(value);
}
@


1.28
log
@remove useless #ifndef

ok sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.27 2016/09/08 12:06:43 eric Exp $	*/
a297 11
	if (p->m_buf == NULL) {
		p->m_alloc = 128;
		log_trace(TRACE_MPROC, "mproc: %s -> %s: allocating %zu",
		    proc_name(smtpd_process),
		    proc_name(p->proc),
		    p->m_alloc);
		p->m_buf = malloc(p->m_alloc);
		if (p->m_buf == NULL)
			fatal("warn: m_create: malloc");
	}

d316 1
a316 1
	alloc = p->m_alloc;
d326 1
a326 1
		tmp = realloc(p->m_buf, alloc);
@


1.27
log
@Streamline the daemon shutdown sequence.

Only the parent process handles SIGTERM and SIGINT.  Upon receiving one
of those, it closes all imsg sockets and waitpid() for the children. It
fatal()s if one of the sockets is closed unexpectedly.  Other processes
exit() "normally" when one of the imsg sockets is closed.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.26 2016/09/03 16:06:26 eric Exp $	*/
a495 1
#ifndef BUILD_FILTER
a504 1
#endif
a609 1
#ifndef BUILD_FILTER
a622 1
#endif
@


1.26
log
@get rid of the type-checking system on internal messages.
bump all imsg protocol versions since message format changed.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.25 2016/09/02 13:41:10 eric Exp $	*/
d91 2
d171 2
a172 4
			if (smtpd_process != PROC_CONTROL ||
			    p->proc != PROC_CLIENT)
				log_warnx("warn: %s -> %s: pipe closed",
				    proc_name(smtpd_process),  p->name);
d184 2
a185 4
			if (smtpd_process != PROC_CONTROL ||
			    p->proc != PROC_CLIENT)
				log_warnx("warn: %s -> %s: pipe closed",
				    proc_name(smtpd_process),  p->name);
@


1.25
log
@use imsg_read_nofd() implementation from bgpd.
let the caller handle EAGAIN.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.24 2016/09/01 15:12:45 eric Exp $	*/
d422 4
a425 2
	if (m->pos + sz > m->end)
		m_error("msg too short");
a429 56
static inline void
m_get_typed(struct msg *m, uint8_t type, void *dst, size_t sz)
{
	if (m->pos + 1 + sz > m->end)
		m_error("msg too short");
	if (*m->pos != type)
		m_error("msg bad type");
	memmove(dst, m->pos + 1, sz);
	m->pos += sz + 1;
}

static inline void
m_get_typed_sized(struct msg *m, uint8_t type, const void **dst, size_t *sz)
{
	if (m->pos + 1 + sizeof(*sz) > m->end)
		m_error("msg too short");
	if (*m->pos != type)
		m_error("msg bad type");
	memmove(sz, m->pos + 1, sizeof(*sz));
	m->pos += sizeof(sz) + 1;
	if (m->pos + *sz > m->end)
		m_error("msg too short");
	*dst = m->pos;
	m->pos += *sz;
}

static void
m_add_typed(struct mproc *p, uint8_t type, const void *data, size_t len)
{
	m_add(p, &type, 1);
	m_add(p, data, len);
}

static void
m_add_typed_sized(struct mproc *p, uint8_t type, const void *data, size_t len)
{
	m_add(p, &type, 1);
	m_add(p, &len, sizeof(len));
	m_add(p, data, len);
}

enum {
	M_INT,
	M_UINT32,
	M_SIZET,
	M_TIME,
	M_STRING,
	M_DATA,
	M_ID,
	M_EVPID,
	M_MSGID,
	M_SOCKADDR,
	M_MAILADDR,
	M_ENVELOPE,
};

d433 1
a433 1
	m_add_typed(m, M_INT, &v, sizeof v);
d439 1
a439 1
	m_add_typed(m, M_UINT32, &u32, sizeof u32);
d445 1
a445 1
	m_add_typed(m, M_SIZET, &sz, sizeof sz);
d451 1
a451 1
	m_add_typed(m, M_TIME, &v, sizeof v);
d457 1
a457 1
	m_add_typed(m, M_STRING, v, strlen(v) + 1);
d463 2
a464 1
	m_add_typed_sized(m, M_DATA, v, len);
d470 1
a470 1
	m_add_typed(m, M_ID, &v, sizeof(v));
d476 1
a476 1
	m_add_typed(m, M_EVPID, &v, sizeof(v));
d482 1
a482 1
	m_add_typed(m, M_MSGID, &v, sizeof(v));
d488 2
a489 1
	m_add_typed_sized(m, M_SOCKADDR, sa, sa->sa_len);
d495 1
a495 1
	m_add_typed(m, M_MAILADDR, maddr, sizeof(*maddr));
d506 1
a506 1
	m_add_typed_sized(m, M_ENVELOPE, buf, strlen(buf) + 1);
d532 1
a532 1
	m_get_typed(m, M_INT, i, sizeof(*i));
d538 1
a538 1
	m_get_typed(m, M_UINT32, u32, sizeof(*u32));
d544 1
a544 1
	m_get_typed(m, M_SIZET, sz, sizeof(*sz));
d550 1
a550 1
	m_get_typed(m, M_TIME, t, sizeof(*t));
d558 1
a558 1
	if (m->pos + 2 > m->end)
a559 2
	if (*m->pos != M_STRING)
		m_error("bad msg type");
d561 1
a561 1
	end = memchr(m->pos + 1, 0, m->end - (m->pos + 1));
d565 1
a565 1
	*s = m->pos + 1;
d572 7
a578 1
	m_get_typed_sized(m, M_DATA, data, sz);
d584 1
a584 1
	m_get_typed(m, M_EVPID, evpid, sizeof(*evpid));
d590 1
a590 1
	m_get_typed(m, M_MSGID, msgid, sizeof(*msgid));
d596 1
a596 1
	m_get_typed(m, M_ID, id, sizeof(*id));
d602 1
a602 2
	size_t		 s;
	const void	*d;
d604 2
a605 2
	m_get_typed_sized(m, M_SOCKADDR, &d, &s);
	memmove(sa, d, s);
d611 1
a611 1
	m_get_typed(m, M_MAILADDR, maddr, sizeof(*maddr));
d619 1
a619 2
	size_t		 s;
	const void	*d;
d622 1
a622 1
	m_get_typed_sized(m, M_ENVELOPE, &d, &s);
d624 1
a624 1
	if (!envelope_load_buffer(evp, d, s - 1))
@


1.24
log
@zap dead code

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.23 2016/09/01 14:19:33 eric Exp $	*/
d229 3
a231 5
    again:
	if ((n = recv(ibuf->fd, buf, len, 0)) == -1) {
		if (errno != EINTR && errno != EAGAIN)
			goto fail;
		goto again;
d234 2
a235 3
        ibuf->r.wpos += n;
fail:
        return (n);
@


1.23
log
@Get rid of the custom msgbuf_write2() function adapted from libutil.
It is not necessary now that the profiling code is gone.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.22 2016/09/01 10:07:20 eric Exp $	*/
a556 3
#if 0
	m_add_typed(m, M_ENVELOPE, evp, sizeof(*evp));
#else
a561 1
#endif
a669 3
#if 0
	m_get_typed(m, M_ENVELOPE, evp, sizeof(*evp));
#else
a679 1
#endif
@


1.22
log
@get rid of the imsg buffer usage profiling code.

ok gilles@@ jung@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.21 2016/08/31 21:49:01 eric Exp $	*/
a43 1
static ssize_t msgbuf_write2(struct msgbuf *);
d181 1
a181 1
		n = msgbuf_write2(&p->imsgbuf.w);
a215 68
}

/* XXX msgbuf_write() should return n ... */
static ssize_t
msgbuf_write2(struct msgbuf *msgbuf)
{
	struct iovec	 iov[IOV_MAX];
	struct ibuf	*buf;
	unsigned int	 i = 0;
	ssize_t		 n;
	struct msghdr	 msg;
	struct cmsghdr	*cmsg;
	union {
		struct cmsghdr	hdr;
		char		buf[CMSG_SPACE(sizeof(int))];
	} cmsgbuf;

	memset(&iov, 0, sizeof(iov));
	memset(&msg, 0, sizeof(msg));
	TAILQ_FOREACH(buf, &msgbuf->bufs, entry) {
		if (i >= IOV_MAX)
			break;
		iov[i].iov_base = buf->buf + buf->rpos;
		iov[i].iov_len = buf->wpos - buf->rpos;
		i++;
		if (buf->fd != -1)
			break;
	}

	msg.msg_iov = iov;
	msg.msg_iovlen = i;

	if (buf != NULL && buf->fd != -1) {
		msg.msg_control = (caddr_t)&cmsgbuf.buf;
		msg.msg_controllen = sizeof(cmsgbuf.buf);
		cmsg = CMSG_FIRSTHDR(&msg);
		cmsg->cmsg_len = CMSG_LEN(sizeof(int));
		cmsg->cmsg_level = SOL_SOCKET;
		cmsg->cmsg_type = SCM_RIGHTS;
		*(int *)CMSG_DATA(cmsg) = buf->fd;
	}

again:
	if ((n = sendmsg(msgbuf->fd, &msg, 0)) == -1) {
		if (errno == EINTR)
			goto again;
		if (errno == ENOBUFS)
			errno = EAGAIN;
		return (-1);
	}

	if (n == 0) {			/* connection closed */
		errno = 0;
		return (0);
	}

	/*
	 * assumption: fd got sent if sendmsg sent anything
	 * this works because fds are passed one at a time
	 */
	if (buf != NULL && buf->fd != -1) {
		close(buf->fd);
		buf->fd = -1;
	}

	msgbuf_drain(msgbuf, n);

	return (n);
@


1.21
log
@Remove dead code. queue_flow_control() has never been used and is
probably a bad idea.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.20 2016/06/06 20:48:15 eric Exp $	*/
a176 1
			p->bytes_in += n;
a190 3
		} else if (n != -1) {
			p->bytes_out += n;
			p->bytes_queued -= n;
a210 1
		p->msg_in += 1;
a324 5
	p->msg_out += 1;
	p->bytes_queued += imsg->hdr.len;
	if (p->bytes_queued > p->bytes_queued_max)
		p->bytes_queued_max = p->bytes_queued;

a341 5
	p->msg_out += 1;
	p->bytes_queued += len + IMSG_HEADER_SIZE;
	if (p->bytes_queued > p->bytes_queued_max)
		p->bytes_queued_max = p->bytes_queued;

a357 5
	p->msg_out += 1;
	p->bytes_queued += IMSG_HEADER_SIZE + len;
	if (p->bytes_queued > p->bytes_queued_max)
		p->bytes_queued_max = p->bytes_queued;

a434 5
	p->msg_out += 1;
	p->bytes_queued += p->m_pos + IMSG_HEADER_SIZE;
	if (p->bytes_queued > p->bytes_queued_max)
		p->bytes_queued_max = p->bytes_queued;

a450 1
	p->msg_out += 1;
@


1.20
log
@do not return on EAGAIN otherwise the event is never reloaded.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.19 2016/03/25 15:06:58 krw Exp $	*/
a219 5

#if 0
	if (smtpd_process == PROC_QUEUE)
		queue_flow_control();
#endif
@


1.19
log
@Nuke session_socket_blockmode() and session_socket_linger(). Use
the identical io_set_blocking() and io_set_linger().

Since both are always called to turn off blocking or lingering,
nuke the parameter and associated enum in favour of "just doing the
right thing".

While passing remove the unneeded last parameter to the remaining
fcntl(F_GETFL).

Finally, rename the functions to io_set_nonblocking() and
io_set_nolinger() for clarity.

No functional change.

Started with a sweep of fcntl() usage inspired by guenther@@.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.18 2016/02/10 15:03:37 millert Exp $	*/
d163 1
a163 1
				return;
@


1.18
log
@Change imsg_read() return value checking from an if..else block to
a switch statement for improved readability.  OK jung@@ sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.17 2016/02/09 11:50:49 sunil Exp $	*/
d55 2
a56 2
	session_socket_blockmode(sp[0], BM_NONBLOCK);
	session_socket_blockmode(sp[1], BM_NONBLOCK);
@


1.17
log
@r1.16 accidentally masked retries on EAGAIN introduced in r1.15.
Fix and simplify imsg_read() return value checking into a single
if..else block.

Ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.16 2015/12/05 13:14:21 claudio Exp $	*/
d160 4
a163 3
		if (n == -1 && errno == EAGAIN)
			return;
		else if (n == -1) {
d167 2
a168 1
		} else if (n == 0) {
d176 1
a176 1
		} else
d178 2
@


1.16
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.15 2015/10/14 21:27:29 gilles Exp $	*/
d160 3
a162 1
		if (n == -1 && errno != EAGAIN) {
a164 2
			if (errno == EAGAIN)
				return;
d166 1
a166 2
		}
		if (n == 0) {
d174 1
a174 1
		} else if (n != -1)
@


1.15
log
@imsg_read() may return EAGAIN, handle it in mproc_dispatch()
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.14 2015/10/14 21:18:19 gilles Exp $	*/
d160 1
a160 1
		if (n == -1) {
d175 2
a176 2
		}
		p->bytes_in += n;
@


1.14
log
@whitespace + only log TRACE_MPROC if not IMSG_STAT_{IN,DE}CREMENT
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.13 2015/10/02 00:32:05 gilles Exp $	*/
d163 2
@


1.13
log
@introduce imsg_read_nofd() to allow reading imsg while discarding fd's when
reading from a context where we don't expect/want to receive one.

this prevents a local user from exhausting resources and causing smtpd to
hang by crafting valid imsg that don't expect a descriptor but passing one
anyways.

reported by Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.12 2015/06/11 19:27:16 gilles Exp $	*/
d322 3
a324 1
	log_trace(TRACE_MPROC, "mproc: %s -> %s : %zu %s (forward)",
d344 3
a346 1
	log_trace(TRACE_MPROC, "mproc: %s -> %s : %zu %s",
d378 3
a380 1
	log_trace(TRACE_MPROC, "mproc: %s -> %s : %zu %s",
d394 1
a394 1
		log_trace(TRACE_MPROC, "mproc: %s -> %s: allocating %zu", 
d720 1
a720 1
	
@


1.12
log
@local user can cause smtpd to fail by sending invalid imsg to control sock
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.11 2015/01/16 06:40:20 deraadt Exp $	*/
d45 1
d155 6
a160 1
		if ((n = imsg_read(&p->imsgbuf)) == -1) {
d290 23
@


1.12.4.1
log
@Errata 004:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.12 2015/06/11 19:27:16 gilles Exp $	*/
a44 1
static ssize_t imsg_read_nofd(struct imsgbuf *);
d154 1
a154 6
		if (p->proc == PROC_CLIENT)
			n = imsg_read_nofd(&p->imsgbuf);
		else
			n = imsg_read(&p->imsgbuf);

		if (n == -1) {
a283 23
}

/* This should go into libutil */
static ssize_t
imsg_read_nofd(struct imsgbuf *ibuf)
{
	ssize_t	 n;
	char	*buf;
	size_t	 len;

	buf = ibuf->r.buf + ibuf->r.wpos;
	len = sizeof(ibuf->r.buf) - ibuf->r.wpos;

    again:
	if ((n = recv(ibuf->fd, buf, len, 0)) == -1) {
		if (errno != EINTR && errno != EAGAIN)
			goto fail;
		goto again;
	}

        ibuf->r.wpos += n;
fail:
        return (n);
@


1.11
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.10 2014/07/08 13:49:09 eric Exp $	*/
d189 8
@


1.11.2.1
log
@errata 8
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.11 2015/01/16 06:40:20 deraadt Exp $	*/
a188 8

			if (smtpd_process == PROC_CONTROL &&
			    p->proc == PROC_CLIENT) {
				log_warnx("warn: client sent invalid imsg "
				    "over control socket");
				p->handler(p, NULL);
				return;
			}
@


1.11.2.2
log
@Errata 017:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.11.2.1 2015/06/11 19:25:36 gilles Exp $	*/
a44 1
static ssize_t imsg_read_nofd(struct imsgbuf *);
d154 1
a154 6
		if (p->proc == PROC_CLIENT)
			n = imsg_read_nofd(&p->imsgbuf);
		else
			n = imsg_read(&p->imsgbuf);

		if (n == -1) {
a283 23
}

/* This should go into libutil */
static ssize_t
imsg_read_nofd(struct imsgbuf *ibuf)
{
	ssize_t	 n;
	char	*buf;
	size_t	 len;

	buf = ibuf->r.buf + ibuf->r.wpos;
	len = sizeof(ibuf->r.buf) - ibuf->r.wpos;

    again:
	if ((n = recv(ibuf->fd, buf, len, 0)) == -1) {
		if (errno != EINTR && errno != EAGAIN)
			goto fail;
		goto again;
	}

        ibuf->r.wpos += n;
fail:
        return (n);
@


1.10
log
@Update the table API: lookup functions can take an optional parameters
dictionnary (currently not set). While there, add a helper for forking
external backends, and remove unused table functions.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.8 2014/04/19 17:45:05 gilles Exp $	*/
d35 1
@


1.10.4.1
log
@errata 25
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.10 2014/07/08 13:49:09 eric Exp $	*/
a187 8

			if (smtpd_process == PROC_CONTROL &&
			    p->proc == PROC_CLIENT) {
				log_warnx("warn: client sent invalid imsg "
				    "over control socket");
				p->handler(p, NULL);
				return;
			}
@


1.10.4.2
log
@Errata 031:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.10.4.1 2015/06/11 19:24:38 gilles Exp $	*/
a43 1
static ssize_t imsg_read_nofd(struct imsgbuf *);
d153 1
a153 6
		if (p->proc == PROC_CLIENT)
			n = imsg_read_nofd(&p->imsgbuf);
		else
			n = imsg_read(&p->imsgbuf);

		if (n == -1) {
a282 23
}

/* This should go into libutil */
static ssize_t
imsg_read_nofd(struct imsgbuf *ibuf)
{
	ssize_t	 n;
	char	*buf;
	size_t	 len;

	buf = ibuf->r.buf + ibuf->r.wpos;
	len = sizeof(ibuf->r.buf) - ibuf->r.wpos;

    again:
	if ((n = recv(ibuf->fd, buf, len, 0)) == -1) {
		if (errno != EINTR && errno != EAGAIN)
			goto fail;
		goto again;
	}

        ibuf->r.wpos += n;
fail:
        return (n);
@


1.9
log
@Implement RSA privilege separation for OpenSMTPD, based on my previous
implementation for relayd(8).  The smtpd(8) pony processes (mta
client, smtp server) don't keep the private keys in memory but send
their private key operations as imsgs to the "lookup"/mta process.
It's worth mentioning that this prevents acidental private key leakage
as it could have been caused by "Heartbleed".

ok gilles@@
@
text
@d46 1
a46 1
mproc_fork(struct mproc *p, const char *path, const char *arg)
d65 2
a66 2
		execl(path, arg, NULL);
		err(1, "execl");
d75 1
a75 1
	log_warn("warn: Failed to start process %s, instance of %s", arg, path);
d449 1
a449 1
	fatalx(buf);
d621 19
d741 30
@


1.8
log
@(void) cast snprintf() call used to craft fatalx() message from within
	smtpd, buffer is large enough and truncation harmless, we want to
	avoid memory allocation in that case and use a best-effort
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.7 2013/12/26 17:25:32 eric Exp $	*/
a40 1
static void mproc_event_add(struct mproc *);
d119 1
a119 1
static void
d419 19
d526 1
d551 6
d630 6
@


1.7
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d427 1
a427 1
	snprintf(buf, sizeof buf, "%s: %s: %s",
@


1.6
log
@correctly handle EAGAIN and closed pipe in msgbuf_write()
@
text
@d225 2
a226 2
	bzero(&iov, sizeof(iov));
	bzero(&msg, sizeof(msg));
@


1.5
log
@Do not fatal() immediatly on write error, but report to the upper layer.
Fix a bug where the server would stop if smtpctl exits early.
@
text
@d173 1
a173 1
		if (n == -1) {
d181 3
a184 2
		p->bytes_out += n;
		p->bytes_queued -= n;
d252 1
a252 1
		if (errno == EAGAIN || errno == EINTR)
@


1.4
log
@typo
@
text
@d173 9
a181 2
		if (n == -1)
			fatal("msgbuf_write");
@


1.3
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.2 2013/01/31 18:34:43 eric Exp $	*/
d678 1
a678 1
		fatalx("failed to retreive envelope");
@


1.2
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mproc.c,v 1.1 2013/01/26 09:37:23 gilles Exp $	*/
a45 3
static uint32_t	reqtype;
static size_t	reqlen;

d100 2
a101 1
		log_debug("debug: enabling %s -> %s", proc_name(smtpd_process),
d112 2
a113 1
		log_debug("debug: disabling %s -> %s", proc_name(smtpd_process),
d154 5
a158 2
		if ((n = imsg_read(&p->imsgbuf)) == -1)
			fatal("imsg_read");
d161 4
d277 6
d297 6
d315 1
d320 4
d325 1
a325 3
	p->bytes_queued += IMSG_HEADER_SIZE;
	for (i = 0; i < n; i++)
		p->bytes_queued += iov[i].iov_len;
d329 6
d339 1
a339 2
m_create(struct mproc *p, uint32_t type, uint32_t peerid, pid_t pid, int fd,
    size_t len)
d341 10
a350 5
	if (p->ibuf)
		fatal("ibuf already rhere");

	reqtype = type;
	reqlen = len;
d352 5
a356 6
	p->ibuf = imsg_create(&p->imsgbuf, type, peerid, pid, len);
	if (p->ibuf == NULL)
		fatal("imsg_create");

	/* Is this a problem with imsg? */
	p->ibuf->fd = fd;
d362 17
a378 2
	if (p->ibuferror)
		return;
d380 9
a388 2
	if (ibuf_add(p->ibuf, data, len) == -1)
		p->ibuferror = 1;
d394 3
a396 1
	imsg_close(&p->imsgbuf, p->ibuf);
d398 1
a398 11
	if (verbose & TRACE_IMSGSIZE &&
	    reqlen != p->ibuf->wpos - IMSG_HEADER_SIZE)
		log_debug("msg-len: too %s %zu -> %zu : %s -> %s : %s",
		    (reqlen < p->ibuf->wpos - IMSG_HEADER_SIZE) ? "small" : "large",
		    reqlen, p->ibuf->wpos - IMSG_HEADER_SIZE,
		    proc_name(smtpd_process),
		    proc_name(p->proc),
		    imsg_to_str(reqtype));
	else if (verbose & TRACE_IMSGSIZE)
		log_debug("msg-len: ok %zu : %s -> %s : %s",
		    p->ibuf->wpos - IMSG_HEADER_SIZE,
d401 2
a402 1
		    imsg_to_str(reqtype));
d405 1
a405 1
	p->bytes_queued += p->ibuf->wpos;
a407 1
	p->ibuf = NULL;
d485 2
a486 6
	if (p->ibuferror)
		return;

	if (ibuf_add(p->ibuf, &type, 1) == -1 ||
	    ibuf_add(p->ibuf, data, len) == -1)
		p->ibuferror = 1;
d492 3
a494 7
	if (p->ibuferror)
		return;

	if (ibuf_add(p->ibuf, &type, 1) == -1 ||
	    ibuf_add(p->ibuf, &len, sizeof(len)) == -1 ||
	    ibuf_add(p->ibuf, data, len) == -1)
		p->ibuferror = 1;
d571 1
d585 1
d663 1
d678 1
a678 1
		fatalx("failed to load envelope");
d682 1
@


1.1
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.61 2012/11/12 14:58:53 eric Exp $	*/
d174 5
a178 2
		if ((n = imsg_get(&p->imsgbuf, &imsg)) == -1)
			fatal("imsg_get");
d322 3
a326 3

	if (p->ibuf == NULL)
		fatal("imsg_create");
d349 6
@

