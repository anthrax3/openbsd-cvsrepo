head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.8
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.6
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.25.0.2
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.29
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.28;
commitid	ZxnqOQqX6IeYI9jW;

1.28
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	ZBTFreARDSMmzOIV;

1.27
date	2014.05.09.21.30.11;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.19.12.43.19;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.24.20.39.23;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2013.02.14.12.30.49;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2012.10.10.18.02.37;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2012.09.27.18.57.25;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2012.09.21.19.37.08;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2012.09.21.16.40.20;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.19.12.45.04;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2012.09.19.09.06.35;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2012.09.18.15.35.13;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.01.19.47.08;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.19.20.57.10;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.27.09.49.23;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.09.23.49.34;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.09.10.32.48;	author jacekm;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.08.23.15.03;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.29
log
@remove spaces after '!'

no binary change

ok millert
@
text
@/*	$OpenBSD: expand.c,v 1.28 2015/01/20 17:37:54 deraadt Exp $	*/

/*
 * Copyright (c) 2009 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>

#include <ctype.h>
#include <event.h>
#include <imsg.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include "smtpd.h"
#include "log.h"

static const char *expandnode_info(struct expandnode *);

struct expandnode *
expand_lookup(struct expand *expand, struct expandnode *key)
{
	return RB_FIND(expandtree, &expand->tree, key);
}

int
expand_to_text(struct expand *expand, char *buf, size_t sz)
{
	struct expandnode *xn;

	buf[0] = '\0';

	RB_FOREACH(xn, expandtree, &expand->tree) {
		if (buf[0])
			(void)strlcat(buf, ", ", sz);
		if (strlcat(buf, expandnode_to_text(xn), sz) >= sz)
			return 0;
	}

	return 1;
}

void
expand_insert(struct expand *expand, struct expandnode *node)
{
	struct expandnode *xn;

	node->parent = expand->parent;

	log_trace(TRACE_EXPAND, "expand: %p: expand_insert() called for %s",
	    expand, expandnode_info(node));
	if (node->type == EXPAND_USERNAME &&
	    expand->parent &&
	    expand->parent->type == EXPAND_USERNAME &&
	    !strcmp(expand->parent->u.user, node->u.user)) {
		log_trace(TRACE_EXPAND, "expand: %p: setting sameuser = 1",
		    expand);
		node->sameuser = 1;
	}

	if (expand_lookup(expand, node)) {
		log_trace(TRACE_EXPAND, "expand: %p: node found, discarding",
			expand);
		return;
	}

	xn = xmemdup(node, sizeof *xn, "expand_insert");
	xn->rule = expand->rule;
	xn->parent = expand->parent;
	xn->alias = expand->alias;
	if (xn->parent)
		xn->depth = xn->parent->depth + 1;
	else
		xn->depth = 0;
	RB_INSERT(expandtree, &expand->tree, xn);
	if (expand->queue)
		TAILQ_INSERT_TAIL(expand->queue, xn, tq_entry);
	expand->nb_nodes++;
	log_trace(TRACE_EXPAND, "expand: %p: inserted node %p", expand, xn);
}

void
expand_clear(struct expand *expand)
{
	struct expandnode *xn;

	log_trace(TRACE_EXPAND, "expand: %p: clearing expand tree", expand);
	if (expand->queue)
		while ((xn = TAILQ_FIRST(expand->queue)))
			TAILQ_REMOVE(expand->queue, xn, tq_entry);

	while ((xn = RB_ROOT(&expand->tree)) != NULL) {
		RB_REMOVE(expandtree, &expand->tree, xn);
		free(xn);
	}
}

void
expand_free(struct expand *expand)
{
	expand_clear(expand);

	log_trace(TRACE_EXPAND, "expand: %p: freeing expand tree", expand);
	free(expand);
}

int
expand_cmp(struct expandnode *e1, struct expandnode *e2)
{
	struct expandnode *p1, *p2;
	int		   r;

	if (e1->type < e2->type)
		return -1;
	if (e1->type > e2->type)
		return 1;
	if (e1->sameuser < e2->sameuser)
		return -1;
	if (e1->sameuser > e2->sameuser)
		return 1;
	if (e1->mapping < e2->mapping)
		return -1;
	if (e1->mapping > e2->mapping)
		return 1;
	if (e1->userbase < e2->userbase)
		return -1;
	if (e1->userbase > e2->userbase)
		return 1;

	r = memcmp(&e1->u, &e2->u, sizeof(e1->u));
	if (r)
		return (r);


	if (e1->parent == e2->parent)
		return (0);

	if (e1->parent == NULL)
		return (-1);
	if (e2->parent == NULL)
		return (1);

	/*
	 * The same node can be expanded in for different dest context.
	 * Wen need to distinguish between those.
	 */
	for(p1 = e1->parent; p1->type != EXPAND_ADDRESS; p1 = p1->parent)
		;
	for(p2 = e2->parent; p2->type != EXPAND_ADDRESS; p2 = p2->parent)
		;
	if (p1 < p2)
		return (-1);
	if (p1 > p2)
		return (1);

	if (e1->type != EXPAND_FILENAME && e1->type != EXPAND_FILTER)
		return (0);

	/*
	 * For external delivery, we need to distinguish between users.
	 * If we can't find a username, we assume it is _smtpd.
	 */
	for(p1 = e1->parent; p1 && p1->type != EXPAND_USERNAME; p1 = p1->parent)
		;
	for(p2 = e2->parent; p2 && p2->type != EXPAND_USERNAME; p2 = p2->parent)
		;
	if (p1 < p2)
		return (-1);
	if (p1 > p2)
		return (1);

	return (0);
}

static int
expand_line_split(char **line, char **ret)
{
	static char	buffer[LINE_MAX];
	int		esc, dq, sq;
	size_t		i;
	char	       *s;

	memset(buffer, 0, sizeof buffer);
	esc = dq = sq = 0;
	i = 0;
	for (s = *line; (*s) && (i < sizeof(buffer)); ++s) {
		if (esc) {
			buffer[i++] = *s;
			esc = 0;
			continue;
		}
		if (*s == '\\') {
			esc = 1;
			continue;
		}
		if (*s == ',' && !dq && !sq) {
			*ret = buffer;
			*line = s+1;
			return (1);
		}

		buffer[i++] = *s;
		esc = 0;

		if (*s == '"' && !sq)
			dq ^= 1;
		if (*s == '\'' && !dq)
			sq ^= 1;
	}

	if (esc || dq || sq || i == sizeof(buffer))
		return (-1);

	*ret = buffer;
	*line = s;
	return (i ? 1 : 0);
}

int
expand_line(struct expand *expand, const char *s, int do_includes)
{
	struct expandnode	xn;
	char			buffer[LINE_MAX];
	char		       *p, *subrcpt;
	int			ret;

	memset(buffer, 0, sizeof buffer);
	if (strlcpy(buffer, s, sizeof buffer) >= sizeof buffer)
		return 0;

	p = buffer;
	while ((ret = expand_line_split(&p, &subrcpt)) > 0) {
		subrcpt = strip(subrcpt);
		if (subrcpt[0] == '\0')
			continue;
		if (!text_to_expandnode(&xn, subrcpt))
			return 0;
		if (!do_includes)
			if (xn.type == EXPAND_INCLUDE)
				continue;
		expand_insert(expand, &xn);
	}

	if (ret >= 0)
		return 1;

	/* expand_line_split() returned < 0 */
	return 0;
}

static const char *
expandnode_info(struct expandnode *e)
{
	static char	buffer[1024];
	const char     *type = NULL;
	const char     *value = NULL;
	char		tmp[64];

	switch (e->type) {
	case EXPAND_FILTER:
		type = "filter";
		break;
	case EXPAND_FILENAME:
		type = "filename";
		break;
	case EXPAND_INCLUDE:
		type = "include";
		break;
	case EXPAND_USERNAME:
		type = "username";
		break;
	case EXPAND_ADDRESS:
		type = "address";
		break;
	case EXPAND_ERROR:
		type = "error";
		break;
	case EXPAND_INVALID:
	default:
		return NULL;
	}

	if ((value = expandnode_to_text(e)) == NULL)
		return NULL;

	(void)strlcpy(buffer, type, sizeof buffer);
	(void)strlcat(buffer, ":", sizeof buffer);
	if (strlcat(buffer, value, sizeof buffer) >= sizeof buffer)
		return NULL;

	(void)snprintf(tmp, sizeof(tmp), "[parent=%p", e->parent);
	if (strlcat(buffer, tmp, sizeof buffer) >= sizeof buffer)
		return NULL;

	if (e->mapping) {
		(void)strlcat(buffer, ", mapping=", sizeof buffer);
		(void)strlcat(buffer, e->mapping->t_name, sizeof buffer);
	}

	if (e->userbase) {
		(void)strlcat(buffer, ", userbase=", sizeof buffer);
		(void)strlcat(buffer, e->userbase->t_name, sizeof buffer);
	}

	if (strlcat(buffer, "]", sizeof buffer) >= sizeof buffer)
		return NULL;

	return buffer;
}

RB_GENERATE(expandtree, expandnode, entry, expand_cmp);
@


1.28
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.27 2014/05/09 21:30:11 tedu Exp $	*/
d254 1
a254 1
		if (! text_to_expandnode(&xn, subrcpt))
d256 1
a256 1
		if (! do_includes)
@


1.27
log
@stop casting sizeof to int
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.26 2014/04/19 12:43:19 gilles Exp $	*/
d29 1
d196 1
a196 1
	static char	buffer[SMTPD_MAXLINESIZE];
d241 1
a241 1
	char			buffer[SMTPD_MAXLINESIZE];
@


1.26
log
@unchecked strlcat() call in expand_to_text() may cause aliases expansion to
fail later, make it fail early.

(void) cast other calls, they are detected and handled correctly later
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.25 2013/12/26 17:25:32 eric Exp $	*/
d196 2
a197 1
	int		esc, i, dq, sq;
d201 3
a203 2
	esc = dq = sq = i = 0;
	for (s = *line; (*s) && (i < (int)sizeof(buffer)); ++s) {
@


1.25
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 3
a54 2
			strlcat(buf, ", ", sz);
		strlcat(buf, expandnode_to_text(xn), sz);
d301 2
a302 2
	strlcpy(buffer, type, sizeof buffer);
	strlcat(buffer, ":", sizeof buffer);
d306 1
a306 1
	snprintf(tmp, sizeof(tmp), "[parent=%p", e->parent);
d311 2
a312 2
		strlcat(buffer, ", mapping=", sizeof buffer);
		strlcat(buffer, e->mapping->t_name, sizeof buffer);
d316 2
a317 2
		strlcat(buffer, ", userbase=", sizeof buffer);
		strlcat(buffer, e->userbase->t_name, sizeof buffer);
@


1.24
log
@When building the expansion tree, distinguish between apparently
identical nodes that appear in different contexts.  The same delivery
can happen for different users, or as a different destination address.

Fixes a bug with setups like the following, where a mail sent to
contact@@foo.net was not delivered to both /tmp/me and /tmp/she.

table foobar { me@@foo.net = vmail, she@@foo.net = vmail, \
               contact@@foo.net = "me@@foo.net,she@@foo.net" }
accept for domain foo.net virtual <foobar>
    deliver to maildir "/tmp/%{dest.user}"
@
text
@d198 1
a198 1
	bzero(buffer, sizeof buffer);
d241 1
a241 1
	bzero(buffer, sizeof buffer);
@


1.23
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.21 2013/02/14 12:30:49 gilles Exp $	*/
d64 2
a82 1
	log_trace(TRACE_EXPAND, "expand: %p: inserting node", expand);
d95 1
d126 3
d146 43
a188 1
	return memcmp(&e1->u, &e2->u, sizeof(e1->u));
d271 1
a303 7
	if (e->mapping || e->userbase) {
		strlcat(buffer, " [", sizeof buffer);
		if (e->mapping) {
			strlcat(buffer, "mapping=", sizeof buffer);
			strlcat(buffer, e->mapping->t_name, sizeof buffer);
			if (e->userbase)
				strlcat(buffer, ", ", sizeof buffer);
d305 12
a316 7
		}
		if (e->userbase) {
			strlcat(buffer, "userbase=", sizeof buffer);
			strlcat(buffer, e->userbase->t_name, sizeof buffer);
		}
		if (strlcat(buffer, "]", sizeof buffer) >= sizeof buffer)
			return NULL;
d318 4
@


1.22
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@a22 1
#include <sys/param.h>
d43 16
d240 3
@


1.21
log
@- smtpctl trace expand, enables tracing of aliases expansion
- replace "users" keyword with "userbase" when providing alternate userbase
- disambiguise expansion nodes when expanding across domains and userbases
- allow use of '=' instead of '=>' when declaring a mapping

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.20 2013/01/31 18:34:43 eric Exp $	*/
d132 1
a132 1
	static char	buffer[MAX_LINE_SIZE];
d175 1
a175 1
	char			buffer[MAX_LINE_SIZE];
@


1.20
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.19 2013/01/26 09:37:23 gilles Exp $	*/
d36 2
d49 2
d54 3
a56 1
	    !strcmp(expand->parent->u.user, node->u.user))
d58 1
d60 3
a62 1
	if (expand_lookup(expand, node))
d64 1
d66 1
d86 1
d101 2
d117 8
d201 54
@


1.19
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.18 2012/10/10 18:02:37 eric Exp $	*/
d71 1
a71 1
expand_free(struct expand *expand)
d83 7
@


1.18
log
@For each alias node, mark if it has been expanded from an alias map or
from a .forward file.  Local deliveries for files and filters expanded
from an alias map are run as user _smtpd.

issue reported by tood@@

ok gilles@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.17 2012/09/27 18:57:25 eric Exp $	*/
d4 1
a4 1
 * Copyright (c) 2009 Gilles Chehade <gilles@@openbsd.org>
d26 1
d67 1
d98 74
@


1.17
log
@clarify the alias expansion code.

The session manages a list of nodes to process. A node has a link to the
parent node from which it has been expanded, and a link to the rule that
led to its creation. Depending on its type and the associated rule, each
node is either "expanded" to create new nodes or "submitted" to create a
final envelope.  Nodes which have already been seen, either processed or
not, are discarded to avoid loops.

The expansion process is bootstrapped by creating an EXPAND_ADDRESS node
from the original dest, with no rule and no parent.  It is done when all
nodes have been expanded or if an error occurs before.  The expand depth
is limited 5 levels.  The whole expansion fails if the limit is reached.

While there, make sure that only one .forward file is queried at a time,
and only append the subfolder tag in the maildir case.

Fixe issues with some virtual map setups where the dest would get mixed
up, and make the whole expansion process generally easier to follow.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.16 2012/09/21 19:37:08 eric Exp $	*/
d58 1
@


1.16
log
@Do not pass the username to forwards_get() which does not have to care about
this.  Instead, set the username on the expand context, and copy it on the
expand nodes as they are inserted.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.15 2012/09/21 16:40:20 eric Exp $	*/
d5 1
d46 6
d56 6
a61 4

	/* copy expansion context on node */
	strlcpy(xn->as_user, expand->user, sizeof xn->as_user);

d63 2
d72 4
a86 1

d88 4
@


1.15
log
@wrap expandtree into a "struct expand".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.14 2012/09/19 12:45:04 eric Exp $	*/
d49 4
@


1.14
log
@rename variables for consistency

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.13 2012/09/19 09:06:35 eric Exp $	*/
d35 1
a35 1
expand_lookup(struct expandtree *expandtree, struct expandnode *key)
d37 1
a37 1
	return RB_FIND(expandtree, expandtree, key);
d41 1
a41 1
expand_insert(struct expandtree *expandtree, struct expandnode *node)
d45 1
a45 1
	if (expand_lookup(expandtree, node))
d49 1
a49 1
	RB_INSERT(expandtree, expandtree, xn);
d53 1
a53 1
expand_free(struct expandtree *expandtree)
d57 2
a58 2
	while ((xn = RB_ROOT(expandtree)) != NULL) {
		RB_REMOVE(expandtree, expandtree, xn);
@


1.13
log
@start cleaning the expansion code:

- change expandtree_* prefix to expand_ for better readability and
  because the structure might change at some point
- rename <>_free_nodes() to <>_free()
- remove unused <>_remove_node()
- refcounting has no purpose at all; just remove it as well as the
  decrement/increment functions, and replace the latter with <>_insert
- expandnode flags is only used to know if it's been processed or not,
  don't make it a flag but a simple field with clear name.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.12 2012/09/18 15:35:13 eric Exp $	*/
d43 1
a43 1
	struct expandnode *p;
d48 2
a49 2
	p = xmemdup(node, sizeof *p, "expand_insert");
	RB_INSERT(expandtree, expandtree, p);
@


1.12
log
@make use of expandtree_free_nodes() in lka_session_destroy().
change to a simpler implementation for it while there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.11 2010/11/28 14:35:58 gilles Exp $	*/
d35 1
a35 1
expandtree_lookup(struct expandtree *expandtree, struct expandnode *node)
d37 1
a37 33
	struct expandnode key;

	key = *node;
	return RB_FIND(expandtree, expandtree, &key);
}

void
expandtree_increment_node(struct expandtree *expandtree, struct expandnode *node)
{
	struct expandnode *p;

	p = expandtree_lookup(expandtree, node);
	if (p == NULL) {
		p = calloc(1, sizeof(struct expandnode));
		if (p == NULL)
			fatal("calloc");
		*p = *node;
		if (RB_INSERT(expandtree, expandtree, p))
			fatalx("expandtree_increment_node: node already exists");
	}
	p->refcnt++;
}

void
expandtree_decrement_node(struct expandtree *expandtree, struct expandnode *node)
{
	struct expandnode *p;

	p = expandtree_lookup(expandtree, node);
	if (p == NULL)
		fatalx("expandtree_decrement_node: node doesn't exist.");

	p->refcnt--;
d41 1
a41 1
expandtree_remove_node(struct expandtree *expandtree, struct expandnode *node)
d45 2
a46 3
	p = expandtree_lookup(expandtree, node);
	if (p == NULL)
		fatalx("expandtree_remove: node doesn't exist.");
d48 2
a49 1
	RB_REMOVE(expandtree, expandtree, p);
d53 1
a53 1
expandtree_free_nodes(struct expandtree *expandtree)
@


1.11
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.10 2010/11/28 13:56:43 gilles Exp $	*/
d87 1
a87 2
	struct expandnode *p;
	struct expandnode *nxt;
d89 3
a91 4
	for (p = RB_MIN(expandtree, expandtree); p != NULL; p = nxt) {
		nxt = RB_NEXT(expandtree, expandtree, p);
		RB_REMOVE(expandtree, expandtree, p);
		free(p);
@


1.10
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.9 2010/10/09 22:05:35 gilles Exp $	*/
a24 2
#include <ctype.h>
#include <errno.h>
a25 1
#include <fcntl.h>
@


1.9
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.5 2010/05/19 20:57:10 gilles Exp $	*/
d29 1
d35 1
@


1.8
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.6 2010/05/31 23:38:56 jacekm Exp $	*/
d36 1
a36 1
expandtree_lookup(struct expandtree *tree, struct expandnode *node)
d41 1
a41 1
	return RB_FIND(expandtree, tree, &key);
d45 1
a45 1
expandtree_increment_node(struct expandtree *tree, struct expandnode *node)
d49 1
a49 1
	p = expandtree_lookup(tree, node);
d51 1
a51 1
		p = malloc(sizeof *node);
d53 4
a56 3
			fatal(NULL);
		*p = *node;			/* XXX p->refcnt == node->refcnt */
		RB_INSERT(expandtree, tree, p);
d89 1
d91 2
a92 1
	while ((p = RB_MIN(expandtree, expandtree))) {
@


1.7
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.5 2010/05/19 20:57:10 gilles Exp $	*/
d36 1
a36 1
expandtree_lookup(struct expandtree *expandtree, struct expandnode *node)
d41 1
a41 1
	return RB_FIND(expandtree, expandtree, &key);
d45 1
a45 1
expandtree_increment_node(struct expandtree *expandtree, struct expandnode *node)
d49 1
a49 1
	p = expandtree_lookup(expandtree, node);
d51 1
a51 1
		p = calloc(1, sizeof(struct expandnode));
d53 3
a55 4
			fatal("calloc");
		*p = *node;
		if (RB_INSERT(expandtree, expandtree, p))
			fatalx("expandtree_increment_node: node already exists");
a87 1
	struct expandnode *nxt;
d89 1
a89 2
	for (p = RB_MIN(expandtree, expandtree); p != NULL; p = nxt) {
		nxt = RB_NEXT(expandtree, expandtree, p);
@


1.6
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d36 1
a36 1
expandtree_lookup(struct expandtree *tree, struct expandnode *node)
d41 1
a41 1
	return RB_FIND(expandtree, tree, &key);
d45 1
a45 1
expandtree_increment_node(struct expandtree *tree, struct expandnode *node)
d49 1
a49 1
	p = expandtree_lookup(tree, node);
d51 1
a51 1
		p = malloc(sizeof *node);
d53 4
a56 3
			fatal(NULL);
		*p = *node;			/* XXX p->refcnt == node->refcnt */
		RB_INSERT(expandtree, tree, p);
d89 1
d91 2
a92 1
	while ((p = RB_MIN(expandtree, expandtree))) {
@


1.5
log
@cleanup-only commit, removes unrequired includes, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.4 2010/04/27 09:49:23 gilles Exp $	*/
d36 1
a36 1
expandtree_lookup(struct expandtree *expandtree, struct expandnode *node)
d41 1
a41 1
	return RB_FIND(expandtree, expandtree, &key);
d45 1
a45 1
expandtree_increment_node(struct expandtree *expandtree, struct expandnode *node)
d49 1
a49 1
	p = expandtree_lookup(expandtree, node);
d51 1
a51 1
		p = calloc(1, sizeof(struct expandnode));
d53 3
a55 4
			fatal("calloc");
		*p = *node;
		if (RB_INSERT(expandtree, expandtree, p))
			fatalx("expandtree_increment_node: node already exists");
a87 1
	struct expandnode *nxt;
d89 1
a89 2
	for (p = RB_MIN(expandtree, expandtree); p != NULL; p = nxt) {
		nxt = RB_NEXT(expandtree, expandtree, p);
@


1.4
log
@initial work at fixing aliases support:
- kill struct alias, struct expandnode is used instead
- introduce map_parse_alias() and map_parse_virtual()
- aliases and virtual code no longer assume db(3) but use the map API which
  lets them become backend agnostic AND value-checked. this actually makes
  the code simpler by removing all values parsing from aliases.c
- rename K_SECRETS -> K_SECRET, K_ALIASES -> K_ALIAS for consistency the
  enum has singular names.
- aliases, virtual and forward now work with an expandtree and deal with
  multiple levels of resolving by merging expandtree's

more coming soon ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.3 2009/11/09 23:49:34 gilles Exp $	*/
a31 1
#include <util.h>
@


1.3
log
@- add a reference count and flags to struct expand_node
- during expansion, no longer create a new node for each result but try to
  lookup for an existing equivalent node and increment its reference count
  so that: a) we save on memory, b) we don't need to expand the same users
  again and again just because they keep appearing in expansion results.
- while expanding, flag nodes as F_EXPAND_DONE so that we know which nodes
  we already processed
- be smarter when expanding, if we have a clue that an iteration has not
  brought any new result (because no new nodes were added and all existing
  nodes have F_EXPAND_DONE), end expansion and proceed to delivery.
- various small cleanups

discussed with jacekm@@ yesterday, rebuild aliases db, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.2 2009/11/09 10:32:48 jacekm Exp $	*/
d36 2
a37 2
struct expand_node *
expandtree_lookup(struct expandtree *expandtree, struct expand_node *node)
d39 1
a39 1
	struct expand_node key;
d46 1
a46 1
expandtree_increment_node(struct expandtree *expandtree, struct expand_node *node)
d48 1
a48 1
	struct expand_node *p;
d52 1
a52 1
		p = calloc(1, sizeof(struct expand_node));
d63 1
a63 1
expandtree_decrement_node(struct expandtree *expandtree, struct expand_node *node)
d65 1
a65 1
	struct expand_node *p;
d75 1
a75 1
expandtree_remove_node(struct expandtree *expandtree, struct expand_node *node)
d77 1
a77 1
	struct expand_node *p;
d86 13
d100 1
a100 1
expand_cmp(struct expand_node *e1, struct expand_node *e2)
d111 1
a111 1
RB_GENERATE(expandtree, expand_node, entry, expand_cmp);
@


1.2
log
@fatal on RB_INSERT failure
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.1 2009/11/08 23:15:03 gilles Exp $	*/
d46 1
a46 1
expandtree_insert(struct expandtree *expandtree, struct expand_node *node)
d48 12
a59 3
	node->id = generate_uid();
	if (RB_INSERT(expandtree, expandtree, node))
		fatalx("expandtree_insert: node already exists");
d63 13
a75 1
expandtree_remove(struct expandtree *expandtree, struct expand_node *node)
d82 2
a83 1
	RB_REMOVE(expandtree, expandtree, node);
d89 1
a89 1
	if (e1->id < e2->id)
d92 1
a92 1
	if (e1->id > e2->id)
d95 1
a95 1
	return 0;
@


1.1
log
@move expansion code to new expand.c to clearly separate it from aliases
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 2
a50 1
	RB_INSERT(expandtree, expandtree, node);
@

