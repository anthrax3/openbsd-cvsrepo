head	1.127;
access;
symbols
	OPENBSD_6_2_BASE:1.127
	OPENBSD_6_1:1.126.0.4
	OPENBSD_6_1_BASE:1.126
	OPENBSD_6_0:1.119.0.4
	OPENBSD_6_0_BASE:1.119
	OPENBSD_5_9:1.117.0.2
	OPENBSD_5_9_BASE:1.117
	OPENBSD_5_8:1.109.0.6
	OPENBSD_5_8_BASE:1.109
	OPENBSD_5_7:1.109.0.2
	OPENBSD_5_7_BASE:1.109
	OPENBSD_5_6:1.107.0.4
	OPENBSD_5_6_BASE:1.107
	OPENBSD_5_5:1.102.0.2
	OPENBSD_5_5_BASE:1.102
	OPENBSD_5_4:1.94.0.2
	OPENBSD_5_4_BASE:1.94
	OPENBSD_5_3:1.89.0.2
	OPENBSD_5_3_BASE:1.89
	OPENBSD_5_2:1.67.0.4
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.2
	OPENBSD_5_0:1.56.0.2
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9;
locks; strict;
comment	@ * @;


1.127
date	2017.07.31.16.45.03;	author gilles;	state Exp;
branches;
next	1.126;
commitid	LNv1ngk3Ao7phcEZ;

1.126
date	2016.11.30.17.43.32;	author eric;	state Exp;
branches;
next	1.125;
commitid	12DZR8Z2gR4qMwKF;

1.125
date	2016.11.30.11.52.48;	author eric;	state Exp;
branches;
next	1.124;
commitid	HLHuvF4EZizEJJ0M;

1.124
date	2016.11.24.12.58.27;	author eric;	state Exp;
branches;
next	1.123;
commitid	5gZmKKc6mC73nyDO;

1.123
date	2016.11.21.13.00.43;	author eric;	state Exp;
branches;
next	1.122;
commitid	pP1uMFU0IrsBTn27;

1.122
date	2016.11.20.08.43.36;	author eric;	state Exp;
branches;
next	1.121;
commitid	WsInk7NbLdaIQWny;

1.121
date	2016.11.16.21.30.37;	author eric;	state Exp;
branches;
next	1.120;
commitid	3uoi1oHbQkJMXEjt;

1.120
date	2016.09.01.15.12.45;	author eric;	state Exp;
branches;
next	1.119;
commitid	c7xQVmVRnL8xbXxX;

1.119
date	2016.05.22.16.31.21;	author gilles;	state Exp;
branches;
next	1.118;
commitid	JDbBqpKvf906qrdL;

1.118
date	2016.03.25.15.06.58;	author krw;	state Exp;
branches;
next	1.117;
commitid	0NIU7T9t8yqZHZQl;

1.117
date	2016.02.02.05.45.27;	author sunil;	state Exp;
branches;
next	1.116;
commitid	6duraeEH9T82qL9j;

1.116
date	2016.01.08.19.31.29;	author chrisz;	state Exp;
branches;
next	1.115;
commitid	57QPUFw7Ye8PhdTe;

1.115
date	2015.12.14.10.38.40;	author sunil;	state Exp;
branches;
next	1.114;
commitid	nAzD5lsiGrBsYOmF;

1.114
date	2015.11.30.13.10.13;	author gilles;	state Exp;
branches;
next	1.113;
commitid	J2PQ7bQJabYiaC2p;

1.113
date	2015.11.30.12.26.55;	author sunil;	state Exp;
branches;
next	1.112;
commitid	aGcPak9vEg5kOQ24;

1.112
date	2015.10.27.21.20.11;	author jung;	state Exp;
branches;
next	1.111;
commitid	YRcUZhsvrsRgoY3W;

1.111
date	2015.10.26.09.22.03;	author jsg;	state Exp;
branches;
next	1.110;
commitid	72KpYVAXaldHL8JT;

1.110
date	2015.10.11.12.09.06;	author sunil;	state Exp;
branches;
next	1.109;
commitid	v2HZ7HfyrgAkSLzc;

1.109
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.108;
commitid	ZBTFreARDSMmzOIV;

1.108
date	2015.01.05.21.00.36;	author gilles;	state Exp;
branches;
next	1.107;
commitid	yxu6ugyHrRZIoam0;

1.107
date	2014.07.08.07.59.31;	author sobrado;	state Exp;
branches;
next	1.106;
commitid	QejPnWBk7nSpcYUN;

1.106
date	2014.04.30.09.17.29;	author gilles;	state Exp;
branches;
next	1.105;

1.105
date	2014.04.19.17.42.18;	author gilles;	state Exp;
branches;
next	1.104;

1.104
date	2014.04.19.13.07.56;	author gilles;	state Exp;
branches;
next	1.103;

1.103
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.102;

1.102
date	2014.02.04.15.44.05;	author eric;	state Exp;
branches;
next	1.101;

1.101
date	2014.02.04.14.56.03;	author eric;	state Exp;
branches;
next	1.100;

1.100
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.99;

1.99
date	2013.11.28.10.43.37;	author eric;	state Exp;
branches;
next	1.98;

1.98
date	2013.11.20.09.22.42;	author eric;	state Exp;
branches;
next	1.97;

1.97
date	2013.10.28.09.14.58;	author eric;	state Exp;
branches;
next	1.96;

1.96
date	2013.10.27.07.56.25;	author eric;	state Exp;
branches;
next	1.95;

1.95
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.94;

1.94
date	2013.07.19.15.14.23;	author eric;	state Exp;
branches;
next	1.93;

1.93
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.92;

1.92
date	2013.07.19.07.49.08;	author eric;	state Exp;
branches;
next	1.91;

1.91
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.90;

1.90
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.89;

1.89
date	2013.02.05.11.45.18;	author gilles;	state Exp;
branches;
next	1.88;

1.88
date	2013.02.05.10.53.57;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2013.01.31.18.18.40;	author eric;	state Exp;
branches;
next	1.86;

1.86
date	2013.01.28.16.32.10;	author eric;	state Exp;
branches;
next	1.85;

1.85
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.84;

1.84
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.83;

1.83
date	2012.11.02.16.02.33;	author eric;	state Exp;
branches;
next	1.82;

1.82
date	2012.10.25.09.51.08;	author eric;	state Exp;
branches;
next	1.81;

1.81
date	2012.10.17.17.14.11;	author eric;	state Exp;
branches;
next	1.80;

1.80
date	2012.10.14.20.18.22;	author eric;	state Exp;
branches;
next	1.79;

1.79
date	2012.10.14.18.50.25;	author eric;	state Exp;
branches;
next	1.78;

1.78
date	2012.09.28.13.40.21;	author eric;	state Exp;
branches;
next	1.77;

1.77
date	2012.09.27.17.47.49;	author chl;	state Exp;
branches;
next	1.76;

1.76
date	2012.09.26.19.52.20;	author eric;	state Exp;
branches;
next	1.75;

1.75
date	2012.09.21.12.33.32;	author eric;	state Exp;
branches;
next	1.74;

1.74
date	2012.09.20.09.27.49;	author eric;	state Exp;
branches;
next	1.73;

1.73
date	2012.09.16.16.43.28;	author chl;	state Exp;
branches;
next	1.72;

1.72
date	2012.08.25.10.23.11;	author gilles;	state Exp;
branches;
next	1.71;

1.71
date	2012.08.25.08.27.03;	author eric;	state Exp;
branches;
next	1.70;

1.70
date	2012.08.21.13.13.17;	author eric;	state Exp;
branches;
next	1.69;

1.69
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.68;

1.68
date	2012.08.09.09.48.02;	author eric;	state Exp;
branches;
next	1.67;

1.67
date	2012.01.13.14.01.57;	author eric;	state Exp;
branches;
next	1.66;

1.66
date	2012.01.12.20.59.07;	author eric;	state Exp;
branches;
next	1.65;

1.65
date	2011.12.18.18.43.30;	author eric;	state Exp;
branches;
next	1.64;

1.64
date	2011.12.13.21.44.47;	author gilles;	state Exp;
branches;
next	1.63;

1.63
date	2011.11.14.19.23.41;	author chl;	state Exp;
branches;
next	1.62;

1.62
date	2011.10.27.14.32.57;	author chl;	state Exp;
branches;
next	1.61;

1.61
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.60;

1.60
date	2011.10.09.18.39.53;	author eric;	state Exp;
branches;
next	1.59;

1.59
date	2011.08.29.21.43.08;	author chl;	state Exp;
branches;
next	1.58;

1.58
date	2011.08.29.18.49.29;	author chl;	state Exp;
branches;
next	1.57;

1.57
date	2011.08.26.14.39.47;	author chl;	state Exp;
branches;
next	1.56;

1.56
date	2011.05.16.21.05.51;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.17.11.39.22;	author gilles;	state Exp;
branches;
next	1.52;

1.52
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.50;

1.50
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.02.19.16.53;	author chl;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.44;

1.44
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2010.04.21.18.54.43;	author jacekm;	state Exp;
branches;
next	1.42;

1.42
date	2010.04.21.08.29.01;	author jacekm;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.20.18.18.36;	author jacekm;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.20.15.34.56;	author jacekm;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.19.20.10.36;	author jacekm;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.19.08.14.07;	author jacekm;	state Exp;
branches;
next	1.37;

1.37
date	2010.03.03.10.52.31;	author jacekm;	state Exp;
branches;
next	1.36;

1.36
date	2010.03.01.22.00.52;	author gilles;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.34;

1.34
date	2009.12.14.16.44.14;	author jacekm;	state Exp;
branches;
next	1.33;

1.33
date	2009.12.14.13.17.51;	author jacekm;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.13.12.01.54;	author jacekm;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.11.10.04.05;	author chl;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.23.09.40.39;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.04.16.28.42;	author jacekm;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.04.11.49.23;	author jacekm;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.03.08.19.13;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.02.12.47.06;	author jacekm;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.02.11.11.10;	author jacekm;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.06.13.40.45;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2009.06.07.05.56.25;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.03.22.04.15;	author jacekm;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.01.13.20.56;	author jacekm;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.24.14.38.56;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.19.11.24.24;	author jacekm;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.14.15.05.12;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2009.04.28.21.27.25;	author jacekm;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.21.14.37.32;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.29.14.18.20;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.23.08.25.15;	author tobias;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.15.19.15.25;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.10.22.33.26;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.22.19.07.33;	author chl;	state Exp;
branches;
next	1.8;

1.8
date	2009.02.15.10.32.23;	author jacekm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.27.22.48.29;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.13.23.19.34;	author jacekm;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.05.19.09.59;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.05.02.51.32;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.127
log
@handle empty output correctly in mda_getlastline()

diff from Casper Ti. Vector, ok eric@@
@
text
@/*	$OpenBSD: mda.c,v 1.126 2016/11/30 17:43:32 eric Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <inttypes.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <vis.h>

#include "smtpd.h"
#include "log.h"

#define MDA_HIWAT		65536

struct mda_envelope {
	TAILQ_ENTRY(mda_envelope)	 entry;
	uint64_t			 id;
	time_t				 creation;
	char				*sender;
	char				*dest;
	char				*rcpt;
	enum action_type		 method;
	char				*user;
	char				*buffer;
};

#define USER_WAITINFO	0x01
#define USER_RUNNABLE	0x02
#define USER_ONHOLD	0x04
#define USER_HOLDQ	0x08

struct mda_user {
	uint64_t			id;
	TAILQ_ENTRY(mda_user)		entry;
	TAILQ_ENTRY(mda_user)		entry_runnable;
	char				name[LOGIN_NAME_MAX];
	char				usertable[PATH_MAX];
	size_t				evpcount;
	TAILQ_HEAD(, mda_envelope)	envelopes;
	int				flags;
	size_t				running;
	struct userinfo			userinfo;
};

struct mda_session {
	uint64_t		 id;
	struct mda_user		*user;
	struct mda_envelope	*evp;
	struct io		*io;
	FILE			*datafp;
};

static void mda_io(struct io *, int, void *);
static int mda_check_loop(FILE *, struct mda_envelope *);
static int mda_getlastline(int, char *, size_t);
static void mda_done(struct mda_session *);
static void mda_fail(struct mda_user *, int, const char *,
    enum enhanced_status_code);
static void mda_drain(void);
static void mda_log(const struct mda_envelope *, const char *, const char *);
static void mda_queue_ok(uint64_t);
static void mda_queue_tempfail(uint64_t, const char *,
    enum enhanced_status_code);
static void mda_queue_permfail(uint64_t, const char *, enum enhanced_status_code);
static void mda_queue_loop(uint64_t);
static struct mda_user *mda_user(const struct envelope *);
static void mda_user_free(struct mda_user *);
static const char *mda_user_to_text(const struct mda_user *);
static struct mda_envelope *mda_envelope(const struct envelope *);
static void mda_envelope_free(struct mda_envelope *);
static struct mda_session * mda_session(struct mda_user *);

static struct tree	sessions;
static struct tree	users;

static TAILQ_HEAD(, mda_user)	runnable;

void
mda_imsg(struct mproc *p, struct imsg *imsg)
{
	struct mda_session	*s;
	struct mda_user		*u;
	struct mda_envelope	*e;
	struct envelope		 evp;
	struct userinfo		*userinfo;
	struct deliver		 deliver;
	struct msg		 m;
	const void		*data;
	const char		*error, *parent_error;
	uint64_t		 reqid;
	time_t			 now;
	size_t			 sz;
	char			 out[256], buf[LINE_MAX];
	int			 n;
	enum lka_resp_status	status;

	if (p->proc == PROC_LKA) {
		switch (imsg->hdr.type) {
		case IMSG_MDA_LOOKUP_USERINFO:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_int(&m, (int *)&status);
			if (status == LKA_OK)
				m_get_data(&m, &data, &sz);
			m_end(&m);

			u = tree_xget(&users, reqid);

			if (status == LKA_TEMPFAIL)
				mda_fail(u, 0,
				    "Temporary failure in user lookup",
				    ESC_OTHER_ADDRESS_STATUS);
			else if (status == LKA_PERMFAIL)
				mda_fail(u, 1,
				    "Permanent failure in user lookup",
				    ESC_DESTINATION_MAILBOX_HAS_MOVED);
			else {
				if (sz != sizeof(u->userinfo))
					fatalx("mda: userinfo size mismatch");
				memmove(&u->userinfo, data, sz);
				u->flags &= ~USER_WAITINFO;
				u->flags |= USER_RUNNABLE;
				TAILQ_INSERT_TAIL(&runnable, u, entry_runnable);
				mda_drain();
			}
			return;
		}
	}

	if (p->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {

		case IMSG_QUEUE_DELIVER:
			m_msg(&m, imsg);
			m_get_envelope(&m, &evp);
			m_end(&m);

			u = mda_user(&evp);

			if (u->evpcount >= env->sc_mda_task_hiwat) {
				if (!(u->flags & USER_ONHOLD)) {
					log_debug("debug: mda: hiwat reached for "
					    "user \"%s\": holding envelopes",
					    mda_user_to_text(u));
					u->flags |= USER_ONHOLD;
				}
			}

			if (u->flags & USER_ONHOLD) {
				u->flags |= USER_HOLDQ;
				m_create(p_queue, IMSG_MDA_DELIVERY_HOLD,
				    0, 0, -1);
				m_add_evpid(p_queue, evp.id);
				m_add_id(p_queue, u->id);
				m_close(p_queue);
				return;
			}

			e = mda_envelope(&evp);
			TAILQ_INSERT_TAIL(&u->envelopes, e, entry);
			u->evpcount += 1;
			stat_increment("mda.pending", 1);

			if (!(u->flags & USER_RUNNABLE) &&
			    !(u->flags & USER_WAITINFO)) {
				u->flags |= USER_RUNNABLE;
				TAILQ_INSERT_TAIL(&runnable, u, entry_runnable);
			}

			mda_drain();
			return;

		case IMSG_MDA_OPEN_MESSAGE:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_end(&m);

			s = tree_xget(&sessions, reqid);
			e = s->evp;

			if (imsg->fd == -1) {
				log_debug("debug: mda: cannot get message fd");
				mda_queue_tempfail(e->id,
				    "Cannot get message fd",
				    ESC_OTHER_MAIL_SYSTEM_STATUS);
				mda_log(e, "TempFail", "Cannot get message fd");
				mda_done(s);
				return;
			}

			log_debug("debug: mda: got message fd %d "
			    "for session %016"PRIx64 " evpid %016"PRIx64,
			    imsg->fd, s->id, e->id);

			if ((s->datafp = fdopen(imsg->fd, "r")) == NULL) {
				log_warn("warn: mda: fdopen");
				close(imsg->fd);
				mda_queue_tempfail(e->id, "fdopen failed",
				    ESC_OTHER_MAIL_SYSTEM_STATUS);
				mda_log(e, "TempFail", "fdopen failed");
				mda_done(s);
				return;
			}

			/* check delivery loop */
			if (mda_check_loop(s->datafp, e)) {
				log_debug("debug: mda: loop detected");
				mda_queue_loop(e->id);
				mda_log(e, "PermFail", "Loop detected");
				mda_done(s);
				return;
			}

			n = 0;
			/* 
			 * prepend "From " separator ... for 
			 * A_MDA and A_FILENAME backends only
			 */
			if (e->method == A_MDA || e->method == A_FILENAME) {
				time(&now);
				if (e->sender[0])
					n = io_printf(s->io, "From %s %s",
					    e->sender, ctime(&now));
				else
					n = io_printf(s->io,
					    "From MAILER-DAEMON@@%s %s",
					    env->sc_hostname, ctime(&now));
			}
			if (n != -1) {
				/* start queueing delivery headers */
				if (e->sender[0])
					/* 
					 * XXX: remove existing Return-Path,
					 * if any
					 */
					n = io_printf(s->io,
					    "Return-Path: %s\n"
					    "Delivered-To: %s\n",
					    e->sender,
					    e->rcpt ? e->rcpt : e->dest);
				else
					n = io_printf(s->io,
					    "Delivered-To: %s\n",
					    e->rcpt ? e->rcpt : e->dest);
			}
			if (n == -1) {
				log_warn("warn: mda: "
				    "fail to write delivery info");
				mda_queue_tempfail(e->id, "Out of memory",
				    ESC_OTHER_MAIL_SYSTEM_STATUS);
				mda_log(e, "TempFail", "Out of memory");
				mda_done(s);
				return;
			}

			/* request parent to fork a helper process */
			userinfo = &s->user->userinfo;
			memset(&deliver, 0, sizeof deliver);
			switch (e->method) {
			case A_MDA:
				deliver.mode = A_MDA;
				deliver.userinfo = *userinfo;
				(void)strlcpy(deliver.user, userinfo->username,
				    sizeof(deliver.user));
				if (strlcpy(deliver.to, e->buffer,
					sizeof(deliver.to))
				    >= sizeof(deliver.to)) {
					mda_queue_tempfail(e->id,
					    "mda command too long",
					    ESC_OTHER_MAIL_SYSTEM_STATUS);
					mda_log(e, "TempFail",
					    "mda command too long");
					mda_done(s);
					return;
				}
				break;

			case A_MBOX:
				/* 
				 * MBOX is a special case as we MUST
				 * deliver as root, just override the uid.
				 */
				deliver.mode = A_MBOX;
				deliver.userinfo = *userinfo;
				deliver.userinfo.uid = 0;
				(void)strlcpy(deliver.user, "root",
				    sizeof(deliver.user));
				(void)strlcpy(deliver.from, e->sender,
				    sizeof(deliver.from));
				(void)strlcpy(deliver.to, userinfo->username,
				    sizeof(deliver.to));
				break;

			case A_MAILDIR:
				deliver.mode = A_MAILDIR;
				deliver.userinfo = *userinfo;
				(void)strlcpy(deliver.user, userinfo->username,
				    sizeof(deliver.user));
				(void)strlcpy(deliver.dest, e->dest,
				    sizeof(deliver.dest));
				if (strlcpy(deliver.to, e->buffer,
					sizeof(deliver.to))
				    >= sizeof(deliver.to)) {
					log_warn("warn: mda: "
					    "deliver buffer too large");
					mda_queue_tempfail(e->id,
					    "Maildir path too long",
					    ESC_OTHER_MAIL_SYSTEM_STATUS);
					mda_log(e, "TempFail",
					    "Maildir path too long");
					mda_done(s);
					return;
				}
				break;

			case A_FILENAME:
				deliver.mode = A_FILENAME;
				deliver.userinfo = *userinfo;
				(void)strlcpy(deliver.user, userinfo->username,
				    sizeof deliver.user);
				if (strlcpy(deliver.to, e->buffer,
					sizeof(deliver.to))
				    >= sizeof(deliver.to)) {
					log_warn("warn: mda: "
					    "deliver buffer too large");
					mda_queue_tempfail(e->id,
					    "filename path too long",
					    ESC_OTHER_MAIL_SYSTEM_STATUS);
					mda_log(e, "TempFail",
					    "filename path too long");
					mda_done(s);
					return;
				}
				break;

			case A_LMTP:
				deliver.mode = A_LMTP;
				deliver.userinfo = *userinfo;
				(void)strlcpy(deliver.user, e->user,
				    sizeof(deliver.user));
				(void)strlcpy(deliver.from, e->sender,
				    sizeof(deliver.from));
				(void)strlcpy(deliver.dest, e->dest,
				    sizeof(deliver.dest));
				if (strlcpy(deliver.to, e->buffer,
					sizeof(deliver.to))
				    >= sizeof(deliver.to)) {
					log_warn("warn: mda: "
					    "deliver buffer too large");
					mda_queue_tempfail(e->id,
					    "socket path too long",
					    ESC_OTHER_MAIL_SYSTEM_STATUS);
					mda_log(e, "TempFail",
					    "socket path too long");
					mda_done(s);
					return;
				}
				break;

			default:
				errx(1, "mda: unknown delivery method: %d",
				    e->method);
			}

			log_debug("debug: mda: querying mda fd "
			    "for session %016"PRIx64 " evpid %016"PRIx64,
			    s->id, s->evp->id);

			m_create(p_parent, IMSG_MDA_FORK, 0, 0, -1);
			m_add_id(p_parent, reqid);
			m_add_data(p_parent, &deliver, sizeof(deliver));
			m_close(p_parent);
			return;
		}
	}

	if (p->proc == PROC_PARENT) {
		switch (imsg->hdr.type) {
		case IMSG_MDA_FORK:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_end(&m);

			s = tree_xget(&sessions, reqid);
			e = s->evp;
			if (imsg->fd == -1) {
				log_warn("warn: mda: fail to retrieve mda fd");
				mda_queue_tempfail(e->id, "Cannot get mda fd",
				    ESC_OTHER_MAIL_SYSTEM_STATUS);
				mda_log(e, "TempFail", "Cannot get mda fd");
				mda_done(s);
				return;
			}

			log_debug("debug: mda: got mda fd %d "
			    "for session %016"PRIx64 " evpid %016"PRIx64,
			    imsg->fd, s->id, s->evp->id);

			io_set_nonblocking(imsg->fd);
			io_set_fd(s->io, imsg->fd);
			io_set_write(s->io);
			return;

		case IMSG_MDA_DONE:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &parent_error);
			m_end(&m);

			s = tree_xget(&sessions, reqid);
			e = s->evp;
			/*
			 * Grab last line of mda stdout/stderr if available.
			 */
			out[0] = '\0';
			if (imsg->fd != -1)
				mda_getlastline(imsg->fd, out, sizeof(out));
			/*
			 * Choose between parent's description of error and
			 * child's output, the latter having preference over
			 * the former.
			 */
			error = NULL;
			if (strcmp(parent_error, "exited okay") == 0) {
				if (s->datafp || (s->io && io_queued(s->io)))
					error = "mda exited prematurely";
			} else
				error = out[0] ? out : parent_error;

			/* update queue entry */
			if (error) {
				mda_queue_tempfail(e->id, error,
				    ESC_OTHER_MAIL_SYSTEM_STATUS);
				(void)snprintf(buf, sizeof buf,
				    "Error (%s)", error);
				mda_log(e, "TempFail", buf);
			}
			else {
				mda_queue_ok(e->id);
				mda_log(e, "Ok", "Delivered");
			}
			mda_done(s);
			return;
		}
	}

	errx(1, "mda_imsg: unexpected %s imsg", imsg_to_str(imsg->hdr.type));
}

void
mda_postfork()
{
}

void
mda_postprivdrop()
{
	tree_init(&sessions);
	tree_init(&users);
	TAILQ_INIT(&runnable);
}

static void
mda_io(struct io *io, int evt, void *arg)
{
	struct mda_session	*s = arg;
	char			*ln = NULL;
	size_t			 sz = 0;
	ssize_t			 len;

	log_trace(TRACE_IO, "mda: %p: %s %s", s, io_strevent(evt),
	    io_strio(io));

	switch (evt) {
	case IO_LOWAT:

	/* done */
	done:
		if (s->datafp == NULL) {
			log_debug("debug: mda: all data sent for session"
			    " %016"PRIx64 " evpid %016"PRIx64,
			    s->id, s->evp->id);
			io_free(io);
			s->io = NULL;
			return;
		}

		while (io_queued(s->io) < MDA_HIWAT) {
			if ((len = getline(&ln, &sz, s->datafp)) == -1)
				break;
			if (io_write(s->io, ln, len) == -1) {
				m_create(p_parent, IMSG_MDA_KILL,
				    0, 0, -1);
				m_add_id(p_parent, s->id);
				m_add_string(p_parent, "Out of memory");
				m_close(p_parent);
				io_pause(io, IO_OUT);
				free(ln);
				return;
			}
		}

		free(ln);
		ln = NULL;
		if (ferror(s->datafp)) {
			log_debug("debug: mda: ferror on session %016"PRIx64,
			    s->id);
			m_create(p_parent, IMSG_MDA_KILL, 0, 0, -1);
			m_add_id(p_parent, s->id);
			m_add_string(p_parent, "Error reading body");
			m_close(p_parent);
			io_pause(io, IO_OUT);
			return;
		}

		if (feof(s->datafp)) {
			log_debug("debug: mda: end-of-file for session"
			    " %016"PRIx64 " evpid %016"PRIx64,
			    s->id, s->evp->id);
			fclose(s->datafp);
			s->datafp = NULL;
			if (io_queued(s->io) == 0)
				goto done;
		}
		return;

	case IO_TIMEOUT:
		log_debug("debug: mda: timeout on session %016"PRIx64, s->id);
		io_pause(io, IO_OUT);
		return;

	case IO_ERROR:
		log_debug("debug: mda: io error on session %016"PRIx64": %s",
		    s->id, io_error(io));
		io_pause(io, IO_OUT);
		return;

	case IO_DISCONNECTED:
		log_debug("debug: mda: io disconnected on session %016"PRIx64,
		    s->id);
		io_pause(io, IO_OUT);
		return;

	default:
		log_debug("debug: mda: unexpected event on session %016"PRIx64,
		    s->id);
		io_pause(io, IO_OUT);
		return;
	}
}

static int
mda_check_loop(FILE *fp, struct mda_envelope *e)
{
	char		*buf = NULL;
	size_t		 sz = 0;
	ssize_t		 len;
	int		 ret = 0;

	while ((len = getline(&buf, &sz, fp)) != -1) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';

		if (strchr(buf, ':') == NULL && !isspace((unsigned char)*buf))
			break;

		if (strncasecmp("Delivered-To: ", buf, 14) == 0) {
			if (strcasecmp(buf + 14, e->dest) == 0) {
				ret = 1;
				break;
			}
		}
	}

	free(buf);
	fseek(fp, SEEK_SET, 0);
	return (ret);
}

static int
mda_getlastline(int fd, char *dst, size_t dstsz)
{
	FILE	*fp;
	char	*ln = NULL;
	size_t	 sz = 0;
	ssize_t	 len;
	int	 out = 0;
	
	if (lseek(fd, 0, SEEK_SET) < 0) {
		log_warn("warn: mda: lseek");
		close(fd);
		return (-1);
	}
	fp = fdopen(fd, "r");
	if (fp == NULL) {
		log_warn("warn: mda: fdopen");
		close(fd);
		return (-1);
	}
	while ((len = getline(&ln, &sz, fp)) != -1) {
		if (ln[len - 1] == '\n')
			ln[len - 1] = '\0';
		out = 1;
	}
	fclose(fp);

	if (out) {
		(void)strlcpy(dst, "\"", dstsz);
		(void)strnvis(dst + 1, ln, dstsz - 2, VIS_SAFE | VIS_CSTYLE);
		(void)strlcat(dst, "\"", dstsz);
	}

	free(ln);
	return (0);
}

static void
mda_fail(struct mda_user *user, int permfail, const char *error,
    enum enhanced_status_code code)
{
	struct mda_envelope	*e;

	while ((e = TAILQ_FIRST(&user->envelopes))) {
		TAILQ_REMOVE(&user->envelopes, e, entry);
		if (permfail) {
			mda_log(e, "PermFail", error);
			mda_queue_permfail(e->id, error, code);
		}
		else {
			mda_log(e, "TempFail", error);
			mda_queue_tempfail(e->id, error, code);
		}
		mda_envelope_free(e);
	}

	mda_user_free(user);
}

static void
mda_drain(void)
{
	struct mda_user		*u;

	while ((u = (TAILQ_FIRST(&runnable)))) {

		TAILQ_REMOVE(&runnable, u, entry_runnable);

		if (u->evpcount == 0 && u->running == 0) {
			log_debug("debug: mda: all done for user \"%s\"",
			    mda_user_to_text(u));
			mda_user_free(u);
			continue;
		}

		if (u->evpcount == 0) {
			log_debug("debug: mda: no more envelope for \"%s\"",
			    mda_user_to_text(u));
			u->flags &= ~USER_RUNNABLE;
			continue;
		}

		if (u->running >= env->sc_mda_max_user_session) {
			log_debug("debug: mda: "
			    "maximum number of session reached for user \"%s\"",
			    mda_user_to_text(u));
			u->flags &= ~USER_RUNNABLE;
			continue;
		}

		if (tree_count(&sessions) >= env->sc_mda_max_session) {
			log_debug("debug: mda: "
			    "maximum number of session reached");
			TAILQ_INSERT_HEAD(&runnable, u, entry_runnable);
			return;
		}

		mda_session(u);

		if (u->evpcount == env->sc_mda_task_lowat) {
			if (u->flags & USER_ONHOLD) {
				log_debug("debug: mda: down to lowat for user "
				    "\"%s\": releasing",
				    mda_user_to_text(u));
				u->flags &= ~USER_ONHOLD;
			}
			if (u->flags & USER_HOLDQ) {
				m_create(p_queue, IMSG_MDA_HOLDQ_RELEASE,
				    0, 0, -1);
				m_add_id(p_queue, u->id);
				m_add_int(p_queue, env->sc_mda_task_release);
				m_close(p_queue);
			}
		}

		/* re-add the user at the tail of the queue */
		TAILQ_INSERT_TAIL(&runnable, u, entry_runnable);
	}
}

static void
mda_done(struct mda_session *s)
{
	log_debug("debug: mda: session %016" PRIx64 " done", s->id);

	tree_xpop(&sessions, s->id);

	mda_envelope_free(s->evp);

	s->user->running--;
	if (!(s->user->flags & USER_RUNNABLE)) {
		log_debug("debug: mda: user \"%s\" becomes runnable",
		    s->user->name);
		TAILQ_INSERT_TAIL(&runnable, s->user, entry_runnable);
		s->user->flags |= USER_RUNNABLE;
	}

	if (s->datafp)
		fclose(s->datafp);
	if (s->io)
		io_free(s->io);

	free(s);

	stat_decrement("mda.running", 1);

	mda_drain();
}

static void
mda_log(const struct mda_envelope *evp, const char *prefix, const char *status)
{
	char rcpt[LINE_MAX];
	const char *method;

	rcpt[0] = '\0';
	if (evp->rcpt)
		(void)snprintf(rcpt, sizeof rcpt, "rcpt=<%s>, ", evp->rcpt);

	if (evp->method == A_MAILDIR)
		method = "maildir";
	else if (evp->method == A_MBOX)
		method = "mbox";
	else if (evp->method == A_FILENAME)
		method = "file";
	else if (evp->method == A_MDA)
		method = "mda";
	else if (evp->method == A_LMTP)
		method = "lmtp";
	else
		method = "???";

	log_info("%016"PRIx64" mda event=delivery evpid=%016" PRIx64 " from=<%s> to=<%s> "
	    "%suser=%s method=%s delay=%s result=%s stat=%s",
	    (uint64_t)0,
	    evp->id,
	    evp->sender ? evp->sender : "",
	    evp->dest,
	    rcpt,
	    evp->user,
	    method,
	    duration_to_text(time(NULL) - evp->creation),
	    prefix,
	    status);
}

static void
mda_queue_ok(uint64_t evpid)
{
	m_create(p_queue, IMSG_MDA_DELIVERY_OK, 0, 0, -1);
	m_add_evpid(p_queue, evpid);
	m_close(p_queue);
}

static void
mda_queue_tempfail(uint64_t evpid, const char *reason,
    enum enhanced_status_code code)
{
	m_create(p_queue, IMSG_MDA_DELIVERY_TEMPFAIL, 0, 0, -1);
	m_add_evpid(p_queue, evpid);
	m_add_string(p_queue, reason);
	m_add_int(p_queue, (int)code);
	m_close(p_queue);
}

static void
mda_queue_permfail(uint64_t evpid, const char *reason,
    enum enhanced_status_code code)
{
	m_create(p_queue, IMSG_MDA_DELIVERY_PERMFAIL, 0, 0, -1);
	m_add_evpid(p_queue, evpid);
	m_add_string(p_queue, reason);
	m_add_int(p_queue, (int)code);
	m_close(p_queue);
}

static void
mda_queue_loop(uint64_t evpid)
{
	m_create(p_queue, IMSG_MDA_DELIVERY_LOOP, 0, 0, -1);
	m_add_evpid(p_queue, evpid);
	m_close(p_queue);
}

static struct mda_user *
mda_user(const struct envelope *evp)
{
	struct mda_user	*u;
	void		*i;

	i = NULL;
	while (tree_iter(&users, &i, NULL, (void**)(&u))) {
		if (!strcmp(evp->agent.mda.username, u->name) &&
		    !strcmp(evp->agent.mda.usertable, u->usertable))
			return (u);
	}

	u = xcalloc(1, sizeof *u, "mda_user");
	u->id = generate_uid();
	TAILQ_INIT(&u->envelopes);
	(void)strlcpy(u->name, evp->agent.mda.username, sizeof(u->name));
	(void)strlcpy(u->usertable, evp->agent.mda.usertable,
	    sizeof(u->usertable));

	tree_xset(&users, u->id, u);

	m_create(p_lka, IMSG_MDA_LOOKUP_USERINFO, 0, 0, -1);
	m_add_id(p_lka, u->id);
	m_add_string(p_lka, evp->agent.mda.usertable);
	if (evp->agent.mda.delivery_user[0])
		m_add_string(p_lka, evp->agent.mda.delivery_user);
	else
		m_add_string(p_lka, evp->agent.mda.username);
	m_close(p_lka);
	u->flags |= USER_WAITINFO;

	stat_increment("mda.user", 1);

	if (evp->agent.mda.delivery_user[0])
		log_debug("mda: new user %016" PRIx64
		    " for \"%s\" delivering as \"%s\"",
		    u->id, mda_user_to_text(u), evp->agent.mda.delivery_user);
	else
		log_debug("mda: new user %016" PRIx64
		    " for \"%s\"", u->id, mda_user_to_text(u));

	return (u);
}

static void
mda_user_free(struct mda_user *u)
{
	tree_xpop(&users, u->id);

	if (u->flags & USER_HOLDQ) {
		m_create(p_queue, IMSG_MDA_HOLDQ_RELEASE, 0, 0, -1);
		m_add_id(p_queue, u->id);
		m_add_int(p_queue, 0);
		m_close(p_queue);
	}

	free(u);
	stat_decrement("mda.user", 1);
}

static const char *
mda_user_to_text(const struct mda_user *u)
{
	static char buf[1024];

	(void)snprintf(buf, sizeof(buf), "%s:%s", u->usertable, u->name);

	return (buf);
}

static struct mda_envelope *
mda_envelope(const struct envelope *evp)
{
	struct mda_envelope	*e;
	char			 buf[LINE_MAX];

	e = xcalloc(1, sizeof *e, "mda_envelope");
	e->id = evp->id;
	e->creation = evp->creation;
	buf[0] = '\0';
	if (evp->sender.user[0] && evp->sender.domain[0])
		(void)snprintf(buf, sizeof buf, "%s@@%s",
		    evp->sender.user, evp->sender.domain);
	e->sender = xstrdup(buf, "mda_envelope:sender");
	(void)snprintf(buf, sizeof buf, "%s@@%s", evp->dest.user,
	    evp->dest.domain);
	e->dest = xstrdup(buf, "mda_envelope:dest");
	(void)snprintf(buf, sizeof buf, "%s@@%s", evp->rcpt.user,
	    evp->rcpt.domain);
	if (strcmp(buf, e->dest))
		e->rcpt = xstrdup(buf, "mda_envelope:rcpt");
	e->method = evp->agent.mda.method;
	e->buffer = xstrdup(evp->agent.mda.buffer, "mda_envelope:buffer");
	e->user = xstrdup(evp->agent.mda.username, "mda_envelope:user");

	stat_increment("mda.envelope", 1);

	return (e);
}

static void
mda_envelope_free(struct mda_envelope *e)
{
	free(e->sender);
	free(e->dest);
	free(e->rcpt);
	free(e->user);
	free(e->buffer);
	free(e);

	stat_decrement("mda.envelope", 1);
}

static struct mda_session *
mda_session(struct mda_user * u)
{
	struct mda_session *s;

	s = xcalloc(1, sizeof *s, "mda_session");
	s->id = generate_uid();
	s->user = u;
	s->io = io_new();
	io_set_callback(s->io, mda_io, s);

	tree_xset(&sessions, s->id, s);

	s->evp = TAILQ_FIRST(&u->envelopes);
	TAILQ_REMOVE(&u->envelopes, s->evp, entry);
	u->evpcount--;
	u->running++;

	stat_decrement("mda.pending", 1);
	stat_increment("mda.running", 1);

	log_debug("debug: mda: new session %016" PRIx64
	    " for user \"%s\" evpid %016" PRIx64, s->id,
	    mda_user_to_text(u), s->evp->id);

	m_create(p_queue, IMSG_MDA_OPEN_MESSAGE, 0, 0, -1);
	m_add_id(p_queue, s->id);
	m_add_msgid(p_queue, evpid_to_msgid(s->evp->id));
	m_close(p_queue);

	return (s);
}
@


1.126
log
@hide internal io flags and rename IO_PAUSE_{IN,OUT} to IO_{IN,OUT}

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.125 2016/11/30 11:52:48 eric Exp $	*/
d620 2
a621 1

d636 1
d640 1
a640 1
	if (sz != 0) {
@


1.125
log
@make struct io opaque:

- move struct io definition to ioev.c
- replace io_init/io_clear with io_new/io_free
- allocate an iobuf for each new io internally
- use struct io pointer in the rest of the code
- remove remaining uses of iobuf_*

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.124 2016/11/24 12:58:27 eric Exp $	*/
d530 1
a530 1
				io_pause(io, IO_PAUSE_OUT);
d545 1
a545 1
			io_pause(io, IO_PAUSE_OUT);
d562 1
a562 1
		io_pause(io, IO_PAUSE_OUT);
d568 1
a568 1
		io_pause(io, IO_PAUSE_OUT);
d574 1
a574 1
		io_pause(io, IO_PAUSE_OUT);
d580 1
a580 1
		io_pause(io, IO_PAUSE_OUT);
@


1.124
log
@add an io_error() accessor to avoid dereferencing the io struct directly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.123 2016/11/21 13:00:43 eric Exp $	*/
d82 1
a82 2
	struct io		 io;
	struct iobuf		 iobuf;
d255 1
a255 1
					n = io_printf(&s->io, "From %s %s",
d258 1
a258 1
					n = io_printf(&s->io,
d269 1
a269 1
					n = io_printf(&s->io,
d275 1
a275 1
					n = io_printf(&s->io,
d433 2
a434 2
			io_set_fd(&s->io, imsg->fd);
			io_set_write(&s->io);
d458 1
a458 1
				if (s->datafp || io_queued(&s->io))
d516 2
a517 1
			io_clear(io);
d521 1
a521 1
		while (io_queued(&s->io) < MDA_HIWAT) {
d524 1
a524 1
			if (io_write(&s->io, ln, len) == -1) {
d555 1
a555 1
			if (io_queued(&s->io) == 0)
d750 2
a751 2
	io_clear(&s->io);
	iobuf_clear(&s->iobuf);
d957 2
a958 4
	if (iobuf_init(&s->iobuf, 0, 0) == -1)
		fatal("mda_session");
	io_init(&s->io, &s->iobuf);
	io_set_callback(&s->io, mda_io, s);
@


1.123
log
@replace calls to iobuf_*() functions with the corresponding io_*() wrappers.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.122 2016/11/20 08:43:36 eric Exp $	*/
d567 1
a567 1
		    s->id, io->error);
@


1.122
log
@add dedicated functions to set fd and callback on a struct io.
simplify io_init() prototype.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.121 2016/11/16 21:30:37 eric Exp $	*/
d256 2
a257 3
					n = iobuf_fqueue(&s->iobuf,
					    "From %s %s", e->sender,
					    ctime(&now));
d259 1
a259 1
					n = iobuf_fqueue(&s->iobuf,
d270 1
a270 1
					n = iobuf_fqueue(&s->iobuf,
d276 1
a276 1
					n = iobuf_fqueue(&s->iobuf,
d459 1
a459 1
				if (s->datafp || iobuf_queued(&s->iobuf))
d521 1
a521 1
		while (iobuf_queued(&s->iobuf) < MDA_HIWAT) {
d524 1
a524 1
			if (iobuf_queue(&s->iobuf, ln, len) == -1) {
d555 1
a555 1
			if (iobuf_queued(&s->iobuf) == 0)
@


1.121
log
@pass the user pointer as parameter to the io callback instead of having
the user dereference the io structure.

ok millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.120 2016/09/01 15:12:45 eric Exp $	*/
d435 1
a435 1
			io_init(&s->io, imsg->fd, s, mda_io, &s->iobuf);
a957 1
	s->io.sock = -1;
d960 2
@


1.120
log
@zap dead code

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.119 2016/05/22 16:31:21 gilles Exp $	*/
d87 1
a87 1
static void mda_io(struct io *, int);
d499 1
a499 1
mda_io(struct io *io, int evt)
d501 1
a501 1
	struct mda_session	*s = io->arg;
@


1.119
log
@start work on improving the log format, this is work in progress but it'll
be better worked in tree

ok eric@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.118 2016/03/25 15:06:58 krw Exp $	*/
a534 5
#if 0
			log_debug("debug: mda: %zu bytes queued "
			    "for session %016"PRIx64 " evpid %016"PRIx64,
			    iobuf_queued(&s->iobuf), s->id, s->evp->id);
#endif
@


1.118
log
@Nuke session_socket_blockmode() and session_socket_linger(). Use
the identical io_set_blocking() and io_set_linger().

Since both are always called to turn off blocking or lingering,
nuke the parameter and associated enum in favour of "just doing the
right thing".

While passing remove the unneeded last parameter to the remaining
fcntl(F_GETFL).

Finally, rename the functions to io_set_nonblocking() and
io_set_nolinger() for clarity.

No functional change.

Started with a sweep of fcntl() usage inspired by guenther@@.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.117 2016/02/02 05:45:27 sunil Exp $	*/
d789 3
a791 3
	log_info("delivery: %s for %016" PRIx64 ": from=<%s>, to=<%s>, "
	    "%suser=%s, method=%s, delay=%s, stat=%s",
	    prefix,
d799 1
@


1.117
log
@Check imsg data size before use.

Ok eric@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.116 2016/01/08 19:31:29 chrisz Exp $	*/
d434 1
a434 1
			io_set_blocking(imsg->fd, 0);
@


1.116
log
@Add missing space in "Delivered-to:%s\n" header.

OK sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.115 2015/12/14 10:38:40 sunil Exp $	*/
d152 2
@


1.115
log
@Wrap long lines.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.114 2015/11/30 13:10:13 gilles Exp $	*/
d270 2
a271 2
					    "Return-Path: %s\nDelivered-To:"
					    "%s\n",
@


1.114
log
@handle "mda command too long" as a tempfail
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.113 2015/11/30 12:26:55 sunil Exp $	*/
d91 2
a92 1
static void mda_fail(struct mda_user *, int, const char *, enum enhanced_status_code);
d96 2
a97 1
static void mda_queue_tempfail(uint64_t, const char *, enum enhanced_status_code);
d183 2
a184 1
				m_create(p_queue, IMSG_MDA_DELIVERY_HOLD, 0, 0, -1);
d215 2
a216 1
				mda_queue_tempfail(e->id, "Cannot get message fd",
d247 4
a250 1
			/* prepend "From " separator ... for A_MDA and A_FILENAME backends only */
d255 2
a256 1
					    "From %s %s", e->sender, ctime(&now));
d259 2
a260 1
					    "From MAILER-DAEMON@@%s %s", env->sc_hostname, ctime(&now));
d265 4
a268 1
					/* XXX: remove existing Return-Path, if any */
d270 4
a273 2
					    "Return-Path: %s\nDelivered-To: %s\n",
					    e->sender, e->rcpt ? e->rcpt : e->dest);
d312 3
a314 2
				/* MBOX is a special case as we MUST deliver as root,
				 * just override the uid.
d467 2
a468 1
				(void)snprintf(buf, sizeof buf, "Error (%s)", error);
d510 2
a511 2
		/* done */
	   done:
d559 1
a559 1
 			if (iobuf_queued(&s->iobuf) == 0)
d653 2
a654 1
mda_fail(struct mda_user *user, int permfail, const char *error, enum enhanced_status_code code)
d716 2
a717 1
				log_debug("debug: mda: down to lowat for user \"%s\": releasing",
d722 2
a723 1
				m_create(p_queue, IMSG_MDA_HOLDQ_RELEASE, 0, 0, -1);
d809 2
a810 1
mda_queue_tempfail(uint64_t evpid, const char *reason, enum enhanced_status_code code)
d820 2
a821 1
mda_queue_permfail(uint64_t evpid, const char *reason, enum enhanced_status_code code)
d873 2
a874 1
		log_debug("mda: new user %016" PRIx64 " for \"%s\" delivering as \"%s\"",
d877 2
a878 1
		log_debug("mda: new user %016" PRIx64 " for \"%s\"", u->id, mda_user_to_text(u));
d923 2
a924 1
	(void)snprintf(buf, sizeof buf, "%s@@%s", evp->dest.user, evp->dest.domain);
d926 2
a927 1
	(void)snprintf(buf, sizeof buf, "%s@@%s", evp->rcpt.user, evp->rcpt.domain);
@


1.113
log
@While delivering to lmtp or mda, accept optional "as user" parameter
whose privileges would be used instead of the default.

Ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.112 2015/10/27 21:20:11 jung Exp $	*/
d284 11
a294 2
				(void)strlcpy(deliver.to, e->buffer,
				    sizeof(deliver.to));
@


1.112
log
@add a rcpt-to parameter to be able to use the original (probably expanded)
RCPT TO within LMTP sessions

ok gilles eric
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.111 2015/10/26 09:22:03 jsg Exp $	*/
d348 1
a348 1
				(void)strlcpy(deliver.user, userinfo->username,
d833 4
a836 1
	m_add_string(p_lka, evp->agent.mda.username);
d842 5
a846 1
	log_debug("mda: new user %llx for \"%s\"", u->id, mda_user_to_text(u));
@


1.111
log
@avoid a potential double free
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.110 2015/10/11 12:09:06 sunil Exp $	*/
d352 2
@


1.110
log
@Convert some fgetln to getline.

Suggestion and ok millert@@, ok gilles@@, eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.109 2015/01/20 17:37:54 deraadt Exp $	*/
d514 1
@


1.109
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.108 2015/01/05 21:00:36 gilles Exp $	*/
d473 3
a475 2
	char			*ln;
	size_t			 len;
d494 1
a494 1
			if ((ln = fgetln(s->datafp, &len)) == NULL)
d503 1
d513 1
d564 3
a566 2
	char		*buf, *lbuf;
	size_t		 len;
d569 1
a569 2
	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
a571 7
		else {
			/* EOF without EOL, copy and add the NUL */
			lbuf = xmalloc(len + 1, "mda_check_loop");
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}
a581 4
		if (lbuf) {
			free(lbuf);
			lbuf = NULL;
		}
a582 2
	if (lbuf)
		free(lbuf);
d584 1
a585 1

d593 3
a595 2
	char	*ln, buf[LINE_MAX];
	size_t	 len;
a596 1
	memset(buf, 0, sizeof buf);
d608 1
a608 1
	while ((ln = fgetln(fp, &len))) {
d610 1
a610 7
			len--;
		if (len == 0)
			continue;
		if (len >= sizeof buf)
			len = (sizeof buf) - 1;
		memmove(buf, ln, len);
		buf[len] = '\0';
d614 1
a614 1
	if (buf[0]) {
d616 1
a616 1
		(void)strnvis(dst + 1, buf, dstsz - 2, VIS_SAFE | VIS_CSTYLE);
d620 1
@


1.108
log
@some third-party mda require a prepended From separator line, so remove the
prepending from delivery_filename backend and prepend conditionally earlier
in the code path if delivery method is through mda or filename.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.107 2014/07/08 07:59:31 sobrado Exp $	*/
d40 1
d69 2
a70 2
	char				name[SMTPD_MAXLOGNAME];
	char				usertable[SMTPD_MAXPATHLEN];
d125 1
a125 1
	char			 out[256], buf[SMTPD_MAXLINESIZE];
d603 1
a603 1
	char	*ln, buf[SMTPD_MAXLINESIZE];
d751 1
a751 1
	char rcpt[SMTPD_MAXLINESIZE];
d886 1
a886 1
	char			 buf[SMTPD_MAXLINESIZE];
@


1.107
log
@fix typos.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.106 2014/04/30 09:17:29 gilles Exp $	*/
d122 1
d241 23
a263 10
			/* start queueing delivery headers */
			if (e->sender[0])
				/* XXX: remove existing Return-Path, if any */
				n = iobuf_fqueue(&s->iobuf,
				    "Return-Path: %s\nDelivered-To: %s\n",
				    e->sender, e->rcpt ? e->rcpt : e->dest);
			else
				n = iobuf_fqueue(&s->iobuf,
				    "Delivered-To: %s\n",
				    e->rcpt ? e->rcpt : e->dest);
@


1.106
log
@when using maildir, do not create automatically create folders to match tag
in email address (ie: gilles+tag => ~/Maildir/.tag), instead use the folder
if it already exists and deliver to the mail Maildir otherwise.

ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.105 2014/04/19 17:42:18 gilles Exp $	*/
d242 1
a242 1
				/* XXX: remove exising Return-Path, if any */
@


1.105
log
@(void) cast snprintf calls that cannot truncate or for which earlier checks
ensure the copy won't fail
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.104 2014/04/19 13:07:56 gilles Exp $	*/
d293 2
@


1.104
log
@add missing checks to strlcpy() when copying envelope "destination" buffer
to the mda delivery buffer. we should never hit these unless we mistakenly
change the value of a define, better be safe than sorry.

(void) cast strlcpy/strlcat that cannot truncate or that we know and want
to truncate rather than lose (informative data not used by smtpd but
intended to help the human reading the log)
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.103 2014/04/04 16:10:42 eric Exp $	*/
d424 1
a424 1
				snprintf(buf, sizeof buf, "Error (%s)", error);
d739 1
a739 1
		snprintf(rcpt, sizeof rcpt, "rcpt=<%s>, ", evp->rcpt);
d860 1
a860 1
	snprintf(buf, sizeof(buf), "%s:%s", u->usertable, u->name);
d876 1
a876 1
		snprintf(buf, sizeof buf, "%s@@%s",
d879 1
a879 1
	snprintf(buf, sizeof buf, "%s@@%s", evp->dest.user, evp->dest.domain);
d881 1
a881 1
	snprintf(buf, sizeof buf, "%s@@%s", evp->rcpt.user, evp->rcpt.domain);
@


1.103
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d267 1
a267 1
				strlcpy(deliver.user, userinfo->username,
d269 1
a269 1
				strlcpy(deliver.to, e->buffer,
d280 1
a280 1
				strlcpy(deliver.user, "root",
d282 3
a284 1
				strlcpy(deliver.to, userinfo->username,
a285 2
				strlcpy(deliver.from, e->sender,
				    sizeof(deliver.from));
d291 1
a291 1
				strlcpy(deliver.user, userinfo->username,
d293 13
a305 2
				strlcpy(deliver.to, e->buffer,
				    sizeof(deliver.to));
d311 1
a311 1
				strlcpy(deliver.user, userinfo->username,
d313 13
a325 2
				strlcpy(deliver.to, e->buffer,
				    sizeof deliver.to);
d331 1
a331 1
				strlcpy(deliver.user, userinfo->username,
d333 1
a333 3
				strlcpy(deliver.to, e->buffer,
				    sizeof(deliver.to));
				strlcpy(deliver.from, e->sender,
d335 13
d614 3
a616 3
		strlcpy(dst, "\"", dstsz);
		strnvis(dst + 1, buf, dstsz - 2, VIS_SAFE | VIS_CSTYLE);
		strlcat(dst, "\"", dstsz);
d819 2
a820 2
	strlcpy(u->name, evp->agent.mda.username, sizeof(u->name));
	strlcpy(u->usertable, evp->agent.mda.usertable,
@


1.102
log
@Add support for DSN and Enhanced Status Code
@
text
@a85 1
static void mda_imsg(struct mproc *, struct imsg *);
a86 2
static void mda_shutdown(void);
static void mda_sig_handler(int, short, void *);
d93 4
d109 1
a109 1
static void
d124 1
a124 1
	int			 n, v;
d129 1
a129 1
		case IMSG_LKA_USERINFO:
d161 1
a161 1
		case IMSG_MDA_DELIVER:
d179 1
a179 1
				m_create(p_queue, IMSG_DELIVERY_HOLD, 0, 0, -1);
d200 1
a200 1
		case IMSG_QUEUE_MESSAGE_FD:
d210 1
a210 1
				queue_tempfail(e->id, "Cannot get message fd",
d224 1
a224 1
				queue_tempfail(e->id, "fdopen failed",
d234 1
a234 1
				queue_loop(e->id);
d253 1
a253 1
				queue_tempfail(e->id, "Out of memory",
d326 1
a326 1
			m_create(p_parent, IMSG_PARENT_FORK_MDA, 0, 0, -1);
d336 1
a336 1
		case IMSG_PARENT_FORK_MDA:
d345 1
a345 1
				queue_tempfail(e->id, "Cannot get mda fd",
d389 1
a389 1
				queue_tempfail(e->id, error,
d395 1
a395 1
				queue_ok(e->id);
a399 14

		case IMSG_CTL_VERBOSE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			log_verbose(v);
			return;

		case IMSG_CTL_PROFILE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			profiling = v;
			return;
d406 2
a407 2
static void
mda_sig_handler(int sig, short event, void *p)
a408 8
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		mda_shutdown();
		break;
	default:
		fatalx("mda_sig_handler: unexpected signal");
	}
d411 2
a412 9
static void
mda_shutdown(void)
{
	log_info("info: mail delivery agent exiting");
	_exit(0);
}

pid_t
mda(void)
a413 32
	pid_t		 pid;
	struct passwd	*pw;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;

	switch (pid = fork()) {
	case -1:
		fatal("mda: cannot fork");
	case 0:
		post_fork(PROC_MDA);
		break;
	default:
		return (pid);
	}

	purge_config(PURGE_EVERYTHING);

	if ((pw = getpwnam(SMTPD_USER)) == NULL)
		fatalx("unknown user " SMTPD_USER);

	if (chroot(PATH_CHROOT) == -1)
		fatal("mda: chroot");
	if (chdir("/") == -1)
		fatal("mda: chdir(\"/\")");

	config_process(PROC_MDA);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("mda: cannot drop privileges");

a416 22

	imsg_callback = mda_imsg;
	event_init();

	signal_set(&ev_sigint, SIGINT, mda_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, mda_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	config_peer(PROC_PARENT);
	config_peer(PROC_QUEUE);
	config_peer(PROC_LKA);
	config_peer(PROC_CONTROL);
	config_done();

	if (event_dispatch() < 0)
		fatal("event_dispatch");
	mda_shutdown();

	return (0);
d446 1
a446 1
				m_create(p_parent, IMSG_PARENT_KILL_MDA,
d464 1
a464 1
			m_create(p_parent, IMSG_PARENT_KILL_MDA, 0, 0, -1);
d598 1
a598 1
			queue_permfail(e->id, error, code);
d602 1
a602 1
			queue_tempfail(e->id, error, code);
d657 1
a657 1
				m_create(p_queue, IMSG_DELIVERY_RELEASE, 0, 0, -1);
d734 36
d792 1
a792 1
	m_create(p_lka, IMSG_LKA_USERINFO, 0, 0, -1);
d812 1
a812 1
		m_create(p_queue, IMSG_DELIVERY_RELEASE, 0, 0, -1);
d899 1
a899 1
	m_create(p_queue, IMSG_QUEUE_MESSAGE_FD, 0, 0, -1);
@


1.101
log
@internal improvements and cleanups

- get rid of the whole penalty thing for failed envelopes in the mta and scheduler.
- do not disable routes on smtp errors
- try to schedule all types of envelopes on each scheduler frame.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.100 2013/12/26 17:25:32 eric Exp $	*/
d93 1
a93 1
static void mda_fail(struct mda_user *, int, const char *);
d140 2
a141 1
				    "Temporary failure in user lookup");
d144 2
a145 1
				    "Permanent failure in user lookup");
d209 2
a210 1
				queue_tempfail(e->id, "Cannot get message fd");
d223 2
a224 1
				queue_tempfail(e->id, "fdopen failed");
d252 2
a253 1
				queue_tempfail(e->id, "Out of memory");
d344 2
a345 1
				queue_tempfail(e->id, "Cannot get mda fd");
d388 2
a389 1
				queue_tempfail(e->id, error);
d672 1
a672 1
mda_fail(struct mda_user *user, int permfail, const char *error)
d680 1
a680 1
			queue_permfail(e->id, error);
d684 1
a684 1
			queue_tempfail(e->id, error);
@


1.100
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d207 1
a207 1
				queue_tempfail(e->id, 0, "Cannot get message fd");
d220 1
a220 1
				queue_tempfail(e->id, 0, "fdopen failed");
d248 1
a248 1
				queue_tempfail(e->id, 0, "Out of memory");
d339 1
a339 1
				queue_tempfail(e->id, 0, "Cannot get mda fd");
d382 1
a382 1
				queue_tempfail(e->id, 0, error);
d677 1
a677 1
			queue_tempfail(e->id, 0, error);
@


1.99
log
@unsigned char casts for ctype
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.98 2013/11/20 09:22:42 eric Exp $	*/
d256 1
a256 1
			bzero(&deliver, sizeof deliver);
d631 1
a631 1
	bzero(buf, sizeof buf);
@


1.98
log
@Rework the mda and scheduler to use the holdq mechanism instead of
tempfail for limiting the number of pending deliveries to the same
user.  This allows to reach optimal delivery time even in case of
burst, while keeping the number of inflight envelopes low.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d602 1
a602 1
		if (strchr(buf, ':') == NULL && !isspace((int)*buf))
@


1.97
log
@bzero() some structs before using them, to be safe.
@
text
@a46 5
#define MDA_MAXEVP		200000
#define MDA_MAXEVPUSER		15000
#define MDA_MAXSESS		50
#define MDA_MAXSESSUSER		7

d59 4
a62 2
#define FLAG_USER_WAITINFO	0x01
#define FLAG_USER_RUNNABLE	0x02
d65 1
d96 6
a102 1
size_t			evpcount;
d104 1
a105 1
static TAILQ_HEAD(, mda_user)	users;
a106 1
size_t				running;
a119 1
	const char		*username, *usertable;
d130 1
a130 2
			m_get_string(&m, &usertable);
			m_get_string(&m, &username);
d136 1
a136 6
			TAILQ_FOREACH(u, &users, entry)
				if (!strcmp(username, u->name) &&
				    !strcmp(usertable, u->usertable))
					break;
			if (u == NULL)
				return;
d146 2
a147 2
				u->flags &= ~FLAG_USER_WAITINFO;
				u->flags |= FLAG_USER_RUNNABLE;
d163 1
a163 37
			e = xcalloc(1, sizeof *e, "mda_envelope");
			e->id = evp.id;
			e->creation = evp.creation;
			buf[0] = '\0';
			if (evp.sender.user[0] && evp.sender.domain[0])
				snprintf(buf, sizeof buf, "%s@@%s",
				    evp.sender.user, evp.sender.domain);
			e->sender = xstrdup(buf, "mda_envelope:sender");
			snprintf(buf, sizeof buf, "%s@@%s",
			    evp.dest.user, evp.dest.domain);
			e->dest = xstrdup(buf, "mda_envelope:dest");
			snprintf(buf, sizeof buf, "%s@@%s",
			    evp.rcpt.user, evp.rcpt.domain);
			if (strcmp(buf, e->dest))
				e->rcpt = xstrdup(buf, "mda_envelope:rcpt");
			e->method = evp.agent.mda.method;
			e->buffer = xstrdup(evp.agent.mda.buffer,
			    "mda_envelope:buffer");
			e->user = xstrdup(evp.agent.mda.username,
			    "mda_envelope:user");

			if (evpcount >= MDA_MAXEVP) {
				log_debug("debug: mda: too many envelopes");
				queue_tempfail(e->id, 0,
				    "Too many envelopes in the delivery agent: "
				    "will try again later");
				mda_log(e, "TempFail",
				    "Too many envelopes in the delivery agent: "
				    "will try again later");
				free(e->sender);
				free(e->dest);
				free(e->rcpt);
				free(e->user);
				free(e->buffer);
				free(e);
				return;
			}
d165 15
a179 34
			username = evp.agent.mda.username;
			usertable = evp.agent.mda.usertable;
			TAILQ_FOREACH(u, &users, entry)
			    if (!strcmp(username, u->name) &&
				!strcmp(usertable, u->usertable))
					break;

			if (u == NULL) {
				u = xcalloc(1, sizeof *u, "mda_user");
				TAILQ_INSERT_TAIL(&users, u, entry);
				TAILQ_INIT(&u->envelopes);
				strlcpy(u->name, username, sizeof u->name);
				strlcpy(u->usertable, usertable, sizeof u->usertable);
				u->flags |= FLAG_USER_WAITINFO;
				m_create(p_lka, IMSG_LKA_USERINFO, 0, 0, -1);
				m_add_string(p_lka, usertable);
				m_add_string(p_lka, username);
				m_close(p_lka);
				stat_increment("mda.user", 1);
			} else if (u->evpcount >= MDA_MAXEVPUSER) {
				log_debug("debug: mda: too many envelopes for "
				    "\"%s\"", u->name);
				queue_tempfail(e->id, 0,
				    "Too many envelopes for this user in the "
				    "delivery agent: will try again later");
				mda_log(e, "TempFail",
				    "Too many envelopes for this user in the "
				    "delivery agent: will try again later");
				free(e->sender);
				free(e->dest);
				free(e->rcpt);
				free(e->user);
				free(e->buffer);
				free(e);
a180 4
			} else if (!(u->flags & FLAG_USER_RUNNABLE) &&
				   !(u->flags & FLAG_USER_WAITINFO)) {
				u->flags |= FLAG_USER_RUNNABLE;
				TAILQ_INSERT_TAIL(&runnable, u, entry_runnable);
d183 3
a185 1
			stat_increment("mda.envelope", 1);
d188 5
a192 3
			evpcount += 1;
			u->evpcount += 1;
			TAILQ_INSERT_TAIL(&u->envelopes, e, entry);
d219 1
a222 1
				close(imsg->fd);
d468 1
a468 1
	TAILQ_INIT(&users);
a469 2
	evpcount = 0;
	running = 0;
d679 1
a679 7
		free(e->sender);
		free(e->dest);
		free(e->rcpt);
		free(e->user);
		free(e->buffer);
		free(e);
		stat_decrement("mda.envelope", 1);
d682 1
a682 3
	TAILQ_REMOVE(&users, user, entry);
	free(user);
	stat_decrement("mda.user", 1);
a687 1
	struct mda_session	*s;
d691 1
d696 2
a697 4
			    u->name);
			TAILQ_REMOVE(&users, u, entry);
			free(u);
			stat_decrement("mda.user", 1);
d703 2
a704 2
			    u->name);
			u->flags &= ~FLAG_USER_RUNNABLE;
d708 1
a708 1
		if (u->running >= MDA_MAXSESSUSER) {
d711 2
a712 2
			    u->name);
			u->flags &= ~FLAG_USER_RUNNABLE;
d716 1
a716 1
		if (running >= MDA_MAXSESS) {
d723 1
a723 18
		s = xcalloc(1, sizeof *s, "mda_drain");
		s->user = u;
		s->evp = TAILQ_FIRST(&u->envelopes);
		TAILQ_REMOVE(&u->envelopes, s->evp, entry);
		s->id = generate_uid();
		if (iobuf_init(&s->iobuf, 0, 0) == -1)
			fatal("mda_drain");
		s->io.sock = -1;
		tree_xset(&sessions, s->id, s);

		log_debug("debug: mda: new session %016" PRIx64
		    " for user \"%s\" evpid %016" PRIx64, s->id, u->name,
		    s->evp->id);

		m_create(p_queue, IMSG_QUEUE_MESSAGE_FD, 0, 0, -1);
		m_add_id(p_queue, s->id);
		m_add_msgid(p_queue, evpid_to_msgid(s->evp->id));
		m_close(p_queue);
d725 13
a737 7
		evpcount--;
		u->evpcount--;
		stat_decrement("mda.pending", 1);

		running++;
		u->running++;
		stat_increment("mda.running", 1);
d739 1
a739 1
		/* Re-add the user at the tail of the queue */
d747 1
a747 1
	struct mda_user	*u;
d751 1
a751 3
	log_debug("debug: mda: session %016" PRIx64 " done", s->id);

	u = s->user;
d753 7
a759 3
	running--;
	u->running--;
	stat_decrement("mda.running", 1);
a765 6
	free(s->evp->sender);
	free(s->evp->dest);
	free(s->evp->rcpt);
	free(s->evp->user);
	free(s->evp->buffer);
	free(s->evp);
a766 1
	stat_decrement("mda.envelope", 1);
d768 1
a768 5
	if (!(u->flags & FLAG_USER_RUNNABLE)) {
		log_debug("debug: mda: user \"%s\" becomes runnable", u->name);
		TAILQ_INSERT_TAIL(&runnable, u, entry_runnable);
		u->flags |= FLAG_USER_RUNNABLE;
	}
d807 137
@


1.96
log
@Create the control socket in the parent process to abort early if
another smtpd instance is running.  Close the inherited socket in
every forked process but control.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.95 2013/10/26 12:27:59 eric Exp $	*/
d316 1
@


1.95
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.94 2013/07/19 15:14:23 eric Exp $	*/
d503 1
@


1.94
log
@scheduler improvements:
- implement suspend/resume scheduling for individual envelopes or message,
  with the associated smtpctl commands.
- allow the mta to request immediate scheduling of an envelope.
- on temporary failures a penalty can be given to further delay the next try.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d273 1
a273 1
			log_debug("debug: mda: got message fd %i "
d404 1
a404 1
			log_debug("debug: mda: got mda fd %i "
@


1.93
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.92 2013/07/19 07:49:08 eric Exp $	*/
d191 1
a191 1
				queue_tempfail(e->id,
d228 1
a228 1
				queue_tempfail(e->id,
d267 1
a267 1
				queue_tempfail(e->id, "Cannot get message fd");
d279 1
a279 1
				queue_tempfail(e->id, "fdopen failed");
d308 1
a308 1
				queue_tempfail(e->id, "Out of memory");
d398 1
a398 1
				queue_tempfail(e->id, "Cannot get mda fd");
d441 1
a441 1
				queue_tempfail(e->id, error);
d737 1
a737 1
			queue_tempfail(e->id, error);
@


1.92
log
@Remove useless sc_pid from struct smtpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.91 2013/05/24 17:03:14 eric Exp $	*/
d510 2
a511 1
	pw = env->sc_pw;
d513 1
a513 1
	if (chroot(pw->pw_dir) == -1)
@


1.91
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.89 2013/02/05 11:45:18 gilles Exp $	*/
a502 1
		env->sc_pid = getpid();
@


1.90
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@a24 1
#include <sys/param.h>
d70 2
a71 2
	char				name[MAXLOGNAME];
	char				usertable[MAXPATHLEN];
d220 1
a220 2
				m_create(p_lka, IMSG_LKA_USERINFO, 0, 0, -1,
				    32 + strlen(usertable) + strlen(username));
d359 11
d379 1
a379 2
			m_create(p_parent, IMSG_PARENT_FORK_MDA, 0, 0, -1,
			    32 + sizeof(deliver));
d568 1
d582 1
a582 1
				    0, 0, -1, 128);
d599 1
a599 1
			m_create(p_parent, IMSG_PARENT_KILL_MDA, 0, 0, -1, 128);
d613 2
d807 1
a807 1
		m_create(p_queue, IMSG_QUEUE_MESSAGE_FD, 0, 0, -1, 18);
d881 2
@


1.89
log
@- handle getaddrinfo() error as LKA_TEMPFAIL
- handle getsockname() error in smtp_connected()
- accept '/' as part of user-part, expand to ':' as done by qmail
- fix wrong check in mda leading to bogus Return-Path header
- fix aliases parsing when there's a white space between key and separator
- some cosmethic cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.87 2013/01/31 18:18:40 eric Exp $	*/
d122 1
a122 1
	char			 out[256], buf[MAX_LINE_SIZE];
d677 1
a677 1
	char	*ln, buf[MAX_LINE_SIZE];
d855 1
a855 1
	char rcpt[MAX_LINE_SIZE];
@


1.88
log
@Spelling fixes: retreive -> retrieve. ok gilles
@
text
@d298 1
a298 1
			if (e->sender)
@


1.87
log
@update mda to use a smaller struct mda_envelope internally.
raise internal envelope limits.
simplify code.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.85 2013/01/26 09:37:23 gilles Exp $	*/
d389 1
a389 1
				log_warn("warn: mda: fail to retreive mda fd");
@


1.86
log
@log sender address as "<>" when delivering bounces

ok gilles@@
@
text
@d48 2
a49 2
#define MDA_MAXEVP		5000
#define MDA_MAXEVPUSER		500
d53 15
d69 9
a77 9
	TAILQ_ENTRY(mda_user)	entry;
	TAILQ_ENTRY(mda_user)	entry_runnable;
	char			name[MAXLOGNAME];
	char			usertable[MAXPATHLEN];
	size_t			evpcount;
	TAILQ_HEAD(, envelope)	envelopes;
	int			runnable;
	size_t			running;
	struct userinfo		userinfo;
d83 1
a83 1
	struct envelope		*evp;
d93 1
a93 1
static int mda_check_loop(FILE *, struct envelope *);
d98 1
a98 1
static void mda_log(const struct envelope *, const char *, const char *);
a109 1
	struct delivery_mda	*d_mda;
d112 2
a113 1
	struct envelope		*e;
d122 3
a124 2
	char			 out[256], stat[MAX_LINE_SIZE];
	int			 n, v, status;
d132 1
a132 1
			m_get_int(&m, &status);
d152 2
a153 1
				u->runnable = 1;
a164 1
			e = xmalloc(sizeof(*e), "mda:envelope");
d166 1
a166 1
			m_get_envelope(&m, e);
d169 21
d193 2
a194 1
				    "Global envelope limit reached");
d196 7
a202 1
				    "Global envelope limit reached");
d207 2
a208 2
			username = e->agent.mda.username;
			usertable = e->agent.mda.usertable;
a213 11
			if (u && u->evpcount >= MDA_MAXEVPUSER) {
				log_debug("debug: mda: too many envelopes for "
				    "\"%s\"", u->name);
				queue_tempfail(e->id,
				    "User envelope limit reached");
				mda_log(e, "TempFail",
				    "User envelope limit reached");
				free(e);
				return;
			}

d216 1
d220 1
a220 1
				TAILQ_INSERT_TAIL(&users, u, entry);
d226 21
d249 1
d255 1
d269 2
a270 4
				queue_tempfail(s->evp->id,
				    "Cannot get message fd");
				mda_log(e, "TempFail",
				    "Cannot get messafe fd");
d275 4
d281 1
a281 1
				queue_tempfail(s->evp->id, "fdopen failed");
d284 1
d289 1
a289 1
			if (mda_check_loop(s->datafp, s->evp)) {
d291 1
a291 1
				queue_loop(s->evp->id);
d298 1
a298 1
			if (s->evp->sender.user[0] && s->evp->sender.domain[0])
d301 2
a302 4
				    "Return-Path: %s@@%s\nDelivered-To: %s@@%s\n",
				    s->evp->sender.user, s->evp->sender.domain,
				    s->evp->rcpt.user,
				    s->evp->rcpt.domain);
d305 2
a306 3
				    "Delivered-To: %s@@%s\n",
				    s->evp->rcpt.user,
				    s->evp->rcpt.domain);
d310 2
a311 2
				queue_tempfail(s->evp->id, "Out of memory");
				mda_log(s->evp, "TempFail", "Out of memory");
a316 1
			d_mda = &s->evp->agent.mda;
d318 1
a318 1
			switch (d_mda->method) {
d324 1
a324 1
				strlcpy(deliver.to, d_mda->buffer,
d339 2
a340 4
				snprintf(deliver.from, sizeof(deliver.from),
				    "%s@@%s",
				    s->evp->sender.user,
				    s->evp->sender.domain);
d348 1
a348 1
				strlcpy(deliver.to, d_mda->buffer,
d357 1
a357 1
				strlcpy(deliver.to, d_mda->buffer,
d363 1
a363 1
				    d_mda->method);
d366 4
d390 1
a390 1
				queue_tempfail(s->evp->id, "Cannot get mda fd");
d396 4
d412 1
d433 3
a435 4
				queue_tempfail(s->evp->id, error);
				snprintf(stat, sizeof stat, "Error (%s)",
				    error);
				mda_log(s->evp, "TempFail", stat);
d438 2
a439 2
				queue_ok(s->evp->id);
				mda_log(s->evp, "Ok", "Delivered");
d520 1
d561 3
d580 5
d588 2
a589 1
			log_debug("debug: mda_io: %p: ferror", s);
d599 3
d608 1
a608 1
		log_debug("debug: mda_io: timeout");
d613 2
a614 1
		log_debug("debug: mda_io: io error: %s", io->error);
d619 2
a620 1
		log_debug("debug: mda_io: disconnected");
d625 2
a626 1
		log_debug("debug: mda_io: unexpected io event: %i", evt);
d633 1
a633 1
mda_check_loop(FILE *fp, struct envelope *ep)
a636 1
	struct mailaddr	 maddr;
d655 1
a655 6

			bzero(&maddr, sizeof maddr);
			if (! text_to_mailaddr(&maddr, buf + 14))
				continue;
			if (strcasecmp(maddr.user, ep->dest.user) == 0 &&
			    strcasecmp(maddr.domain, ep->dest.domain) == 0) {
d716 1
a716 1
	struct envelope	*e;
d728 5
d734 1
d739 1
d746 13
a758 1
	struct mda_user		*user;
d760 14
a773 1
	while ((user = (TAILQ_FIRST(&runnable)))) {
d778 1
a781 3
		log_debug("debug: mda: new session for user \"%s\"",
		    user->name);

d783 3
a785 3
		s->user = user;
		s->evp = TAILQ_FIRST(&user->envelopes);
		TAILQ_REMOVE(&user->envelopes, s->evp, entry);
d792 4
d801 2
d805 2
a806 3
		user->evpcount--;
		evpcount--;

d809 2
a810 17
		user->running++;
		running++;

		/*
		 * The user is still runnable if there are pending envelopes
		 * and the session limit is not reached. We put it at the tail
		 * so that everyone gets a fair share.
		 */
		TAILQ_REMOVE(&runnable, user, entry_runnable);
		user->runnable = 0;
		if (TAILQ_FIRST(&user->envelopes) &&
		    user->running < MDA_MAXSESSUSER) {
			TAILQ_INSERT_TAIL(&runnable, user, entry_runnable);
			user->runnable = 1;
			log_debug("debug: mda: user \"%s\" still runnable",
			    user->name);
		}
d817 2
d821 4
d826 1
a826 2
	s->user->running--;

a828 14
	if (TAILQ_FIRST(&s->user->envelopes) == NULL && s->user->running == 0) {
		log_debug("debug: mda: "
		    "all done for user \"%s\"", s->user->name);
		TAILQ_REMOVE(&users, s->user, entry);
		free(s->user);
	} else if (s->user->runnable == 0 &&
	    TAILQ_FIRST(&s->user->envelopes) &&
	    s->user->running < MDA_MAXSESSUSER) {
		log_debug("debug: mda: user \"%s\" becomes runnable",
		    s->user->name);
		TAILQ_INSERT_TAIL(&runnable, s->user, entry_runnable);
		s->user->runnable = 1;
	}

d833 6
d841 7
d853 1
a853 1
mda_log(const struct envelope *evp, const char *prefix, const char *status)
a855 1
	char sender[MAX_LINE_SIZE];
d859 2
a860 9
	if (strcmp(evp->rcpt.user, evp->dest.user) ||
	    strcmp(evp->rcpt.domain, evp->dest.domain))
		snprintf(rcpt, sizeof rcpt, "rcpt=<%s@@%s>, ",
		    evp->rcpt.user, evp->rcpt.domain);

	sender[0] = '\0';
	if (evp->sender.user[0] || evp->sender.domain[0])
		snprintf(sender, sizeof(sender), "%s@@%s",
		    evp->sender.user, evp->sender.domain);
d862 1
a862 1
	if (evp->agent.mda.method == A_MAILDIR)
d864 1
a864 1
	else if (evp->agent.mda.method == A_MBOX)
d866 1
a866 1
	else if (evp->agent.mda.method == A_FILENAME)
d868 1
a868 1
	else if (evp->agent.mda.method == A_MDA)
d873 1
a873 1
	log_info("delivery: %s for %016" PRIx64 ": from=<%s>, to=<%s@@%s>, "
d877 2
a878 2
	    sender,
	    evp->dest.user, evp->dest.domain,
d880 2
a881 1
	    evp->agent.mda.username, method,
@


1.85
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.84 2012/11/12 14:58:53 eric Exp $	*/
d760 1
d769 5
d785 1
a785 1
	log_info("delivery: %s for %016" PRIx64 ": from=<%s@@%s>, to=<%s@@%s>, "
d788 2
a789 1
	    evp->id, evp->sender.user, evp->sender.domain,
@


1.84
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.82 2012/10/25 09:51:08 eric Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d57 1
d62 1
d66 1
a66 1
	uint32_t		 id;
d74 1
a74 1
static void mda_imsg(struct imsgev *, struct imsg *);
d80 2
a81 1
static void mda_done(struct mda_session *, int);
d83 1
a86 1
static uint32_t		mda_id = 0;
d93 1
a93 1
mda_imsg(struct imsgev *iev, struct imsg *imsg)
d95 1
a95 3
	char			 output[128], *error, *parent_error, *name;
	char			 stat[MAX_LINE_SIZE];
	struct deliver		 deliver;
d98 45
a142 5
	struct delivery_mda	*d_mda;
	struct envelope		*ep;
	uint16_t		 msg;
	uint32_t		 id;
	int			 n;
d144 1
a144 1
	if (iev->proc == PROC_QUEUE) {
d147 5
a151 2
		case IMSG_MDA_SESS_NEW:
			ep = xmemdup(imsg->data, sizeof *ep, "mda_imsg");
d155 3
a157 1
				envelope_set_errormsg(ep,
d159 1
a159 4
				imsg_compose_event(env->sc_ievs[PROC_QUEUE],
				    IMSG_QUEUE_DELIVERY_TEMPFAIL, 0, 0, -1,
				    ep, sizeof *ep);
				free(ep);
d163 2
a164 1
			name = ep->agent.mda.user;
d166 2
a167 1
				if (!strcmp(name, u->name))
d169 1
d171 5
a175 3
				log_debug("debug: mda: too many envelopes for \"%s\"",
				    u->name);
				envelope_set_errormsg(ep,
d177 1
a177 4
				imsg_compose_event(env->sc_ievs[PROC_QUEUE],
				    IMSG_QUEUE_DELIVERY_TEMPFAIL, 0, 0, -1,
				    ep, sizeof *ep);
				free(ep);
d180 1
d184 2
a185 1
				strlcpy(u->name, name, sizeof u->name);
d187 5
a191 6
			}
			if (u->runnable == 0 && u->running < MDA_MAXSESSUSER) {
				log_debug("debug: mda: \"%s\" immediatly runnable",
				    u->name);
				TAILQ_INSERT_TAIL(&runnable, u, entry_runnable);
				u->runnable = 1;
d198 1
a198 1
			TAILQ_INSERT_TAIL(&u->envelopes, ep, entry);
d203 6
a208 2
			id = *(uint32_t*)(imsg->data);
			s = tree_xget(&sessions, id);
d212 1
a212 1
				envelope_set_errormsg(s->evp,
d214 3
a216 1
				mda_done(s, IMSG_QUEUE_DELIVERY_TEMPFAIL);
d222 3
a224 2
				envelope_set_errormsg(s->evp, "fdopen failed");
				mda_done(s, IMSG_QUEUE_DELIVERY_TEMPFAIL);
d231 3
a233 2
				envelope_set_errormsg(s->evp, "Loop detected");
				mda_done(s, IMSG_QUEUE_DELIVERY_LOOP);
d251 5
a255 3
				log_warn("warn: mda: fail to write delivery info");
				envelope_set_errormsg(s->evp, "Out of memory");
				mda_done(s, IMSG_QUEUE_DELIVERY_TEMPFAIL);
a259 1
			ep = s->evp;
d261 1
d265 3
a267 2
				strlcpy(deliver.user, d_mda->user,
				    sizeof (deliver.user));
d269 1
a269 1
				    sizeof deliver.to);
d271 1
a271 1
				
d273 3
d277 2
d280 3
a282 3
				    sizeof (deliver.user));
				strlcpy(deliver.to, d_mda->user,
				    sizeof (deliver.to));
d284 3
a286 2
				    "%s@@%s", ep->sender.user,
				    ep->sender.domain);
d291 3
a293 2
				strlcpy(deliver.user, d_mda->user,
				    sizeof deliver.user);
d295 1
a295 1
				    sizeof deliver.to);
d300 2
a301 1
				strlcpy(deliver.user, d_mda->user,
d312 5
a316 3
			imsg_compose_event(env->sc_ievs[PROC_PARENT],
			    IMSG_PARENT_FORK_MDA, id, 0, -1, &deliver,
			    sizeof deliver);
d321 1
a321 1
	if (iev->proc == PROC_PARENT) {
d324 6
a329 1
			s = tree_xget(&sessions, imsg->hdr.peerid);
d332 3
a334 3
				envelope_set_errormsg(s->evp,
				    "Cannot get mda fd");
				mda_done(s, IMSG_QUEUE_DELIVERY_TEMPFAIL);
d344 6
a349 1
			s = tree_xget(&sessions, imsg->hdr.peerid);
d353 1
a353 1
			output[0] = '\0';
d355 1
a355 2
				mda_getlastline(imsg->fd, output, sizeof output);

a361 1
			parent_error = imsg->data;
d366 1
a366 1
				error = output[0] ? output : parent_error;
a368 1
			msg = IMSG_QUEUE_DELIVERY_OK;
d370 10
a379 7
				msg = IMSG_QUEUE_DELIVERY_TEMPFAIL;
				envelope_set_errormsg(s->evp, "%s", error);
				snprintf(stat, sizeof stat, "Error (%s)", error);
			}
			log_envelope(s->evp, NULL, error ? "TempFail" : "Ok",
				     error ? stat : "Delivered");
			mda_done(s, msg);
d383 11
a393 1
			log_verbose(*(int *)imsg->data);
a425 1

a428 6
	struct peer peers[] = {
		{ PROC_PARENT,	imsg_dispatch },
		{ PROC_QUEUE,	imsg_dispatch },
		{ PROC_CONTROL,	imsg_dispatch }
	};

d433 1
d448 1
a448 2
	smtpd_process = PROC_MDA;
	setproctitle("%s", env->sc_title[smtpd_process]);
d470 5
a474 2
	config_pipes(peers, nitems(peers));
	config_peers(peers, nitems(peers));
d487 1
a487 1
	char			*ln, buf[256];
d490 2
a491 3
	log_trace(TRACE_IO, "mda: %p: %s %s", s, io_strevent(evt), io_strio(io));

	switch(evt) {
d493 1
d506 5
a510 4
				snprintf(buf, sizeof buf, "Out of memory");
				imsg_compose_event(env->sc_ievs[PROC_PARENT],
				    IMSG_PARENT_KILL_MDA, s->id, 0, -1,
				    buf, strlen(buf) + 1);
d518 4
a521 4
			snprintf(buf, sizeof buf, "Error reading body");
			imsg_compose_event(env->sc_ievs[PROC_PARENT],
			    IMSG_PARENT_KILL_MDA, s->id, 0, -1,
			    buf, strlen(buf) + 1);
d538 1
a538 1
		log_debug("debug: mda_io: io error: %s", strerror(errno));
d580 1
a580 1
			if (! email_to_mailaddr(&maddr, buf + 14))
d608 1
d642 22
d672 2
a673 1
			log_debug("debug: mda: maximum number of session reached");
d677 2
a678 1
		log_debug("debug: mda: new session for user \"%s\"", user->name);
d684 1
a684 1
		s->id = mda_id++;
d689 5
a693 3
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_MESSAGE_FD, evpid_to_msgid(s->evp->id), 0, -1,
		    &s->id, sizeof(s->id));
d716 2
a717 1
			log_debug("debug: mda: user \"%s\" still runnable", user->name);
d723 1
a723 1
mda_done(struct mda_session *s, int msg)
a726 3
	imsg_compose_event(env->sc_ievs[PROC_QUEUE], msg, 0, 0, -1,
	    s->evp, sizeof *s->evp);

d733 2
a734 1
		log_debug("debug: mda: all done for user \"%s\"", s->user->name);
d738 6
a743 6
		   TAILQ_FIRST(&s->user->envelopes) &&
		    s->user->running < MDA_MAXSESSUSER) {
			log_debug("debug: mda: user \"%s\" becomes runnable",
			    s->user->name);
			TAILQ_INSERT_TAIL(&runnable, s->user, entry_runnable);
			s->user->runnable = 1;
d754 34
@


1.83
log
@Consistency and robustness improvements in mda:

- Introduce a mda_getlastline function(); improve the code to avoid
  useless allocations and string formatting; make it return the last
  line with content (skip trailing empty lines if found).
- Add a mechanism by which the mda can request the parent to abort a
  local delivery by killing the process.
- Use ioev/iobuf for draining data to the delivery process.
- Make sure to catch all transient errors and make them result in a
  tempfail rather than calling fatal().
- Make sure that the envelope status is properly set for all failures.
- Stop using SMTP response codes; it makes no sense in this context.

ok gilles@@
@
text
@d110 1
a110 1
				log_debug("mda: too many envelopes");
d125 1
a125 1
				log_debug("mda: too many envelopes for \"%s\"",
d142 1
a142 1
				log_debug("mda: \"%s\" immediatly runnable",
d161 1
a161 1
				log_debug("mda: cannot get message fd");
d169 1
a169 1
				log_warn("mda: fdopen");
d177 1
a177 1
				log_debug("mda: loop detected");
d197 1
a197 1
				log_warn("mda: fail to write delivery info");
d259 1
a259 1
				log_warn("mda: fail to retreive mda fd");
d300 2
a301 1
			log_envelope(s->evp, NULL, error ? stat : "Delivered");
d330 1
a330 1
	log_info("mail delivery agent exiting");
d433 1
a433 1
			log_debug("mda_io: %p: ferror", s);
d449 1
a449 1
		log_debug("mda_io: timeout");
d454 1
a454 1
		log_debug("mda_io: io error: %s", strerror(errno));
d459 1
a459 1
		log_debug("mda_io: disconnected");
d464 1
a464 1
		log_debug("mda_io: unexpected io event: %i", evt);
d525 1
a525 1
		log_warn("mda: lseek");
d531 1
a531 1
		log_warn("mda: fdopen");
d565 1
a565 1
			log_debug("mda: maximum number of session reached");
d569 1
a569 1
		log_debug("mda: new session for user \"%s\"", user->name);
d605 1
a605 1
			log_debug("mda: user \"%s\" still runnable", user->name);
d624 1
a624 1
		log_debug("mda: all done for user \"%s\"", s->user->name);
d630 1
a630 1
			log_debug("mda: user \"%s\" becomes runnable",
@


1.82
log
@Make the mda request the message fd from the queue when needed, instead of
pushing the fd with the envelope.  This allows the mda to deal itself with
session limits.  Envelopes are sent at full rate to the mda, which buffers
them on per-user queues, or sends them back for rescheduling if it already
has too many pending envelopes.  Delivery sessions are created (within per-
user and global limits) to drain the queues.

This makes the server handle envelope bursts more efficiently.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.81 2012/10/17 17:14:11 eric Exp $	*/
d7 1
d30 1
d46 2
d67 2
a68 2
	struct msgbuf		 w;
	struct event		 ev;
d73 1
a75 2
static void mda_store(struct mda_session *);
static void mda_store_event(int, short, void *);
d77 1
a98 1
	FILE			*fp;
d101 1
d111 2
d127 2
d158 1
d160 7
a166 1
			s = tree_xget(&sessions, id);
d168 6
a173 3
			s->datafp = fdopen(imsg->fd, "r");
			if (s->datafp == NULL)
				fatalx("mda: fdopen");
d175 1
d178 1
a178 2
				envelope_set_errormsg(s->evp,
				    "646 loop detected");
d183 20
d258 11
a268 4
			if (imsg->fd < 0)
				fatalx("mda: fd pass fail");
			s->w.fd = imsg->fd;
			mda_store(s);
d277 2
a278 30
			if (imsg->fd != -1) {
				char *ln, *buf;
				size_t len;

				buf = NULL;
				if (lseek(imsg->fd, 0, SEEK_SET) < 0)
					fatalx("lseek");
				fp = fdopen(imsg->fd, "r");
				if (fp == NULL)
					fatal("mda: fdopen");
				while ((ln = fgetln(fp, &len))) {
					if (ln[len - 1] == '\n')
						ln[len - 1] = '\0';
					else {
						buf = xmalloc(len + 1,
						    "mda_imsg");
						memcpy(buf, ln, len);
						buf[len] = '\0';
						ln = buf;
					}
					strlcpy(output, "\"", sizeof output);
					strnvis(output + 1, ln,
					    sizeof(output) - 2,
					    VIS_SAFE | VIS_CSTYLE);
					strlcat(output, "\"", sizeof output);
					log_debug("mda_out: %s", output);
				}
				free(buf);
				fclose(fp);
			}
d288 1
a288 1
				if (!feof(s->datafp) || s->w.queued)
d290 2
a291 6
			} else {
				if (output[0])
					error = output;
				else
					error = parent_error;
			}
d400 1
a400 1
mda_store(struct mda_session *s)
d402 15
a416 28
	char		*p;
	struct ibuf	*buf;
	int		 len;

	if (s->evp->sender.user[0] && s->evp->sender.domain[0])
		/* XXX: remove user provided Return-Path, if any */
		len = asprintf(&p, "Return-Path: %s@@%s\nDelivered-To: %s@@%s\n",
		    s->evp->sender.user, s->evp->sender.domain,
		    s->evp->rcpt.user,
		    s->evp->rcpt.domain);
	else
		len = asprintf(&p, "Delivered-To: %s@@%s\n",
		    s->evp->rcpt.user,
		    s->evp->rcpt.domain);

	if (len == -1)
		fatal("mda_store: asprintf");

	session_socket_blockmode(s->w.fd, BM_NONBLOCK);
	if ((buf = ibuf_open(len)) == NULL)
		fatal(NULL);
	if (ibuf_add(buf, p, len) < 0)
		fatal(NULL);
	ibuf_close(&s->w, buf);
	event_set(&s->ev, s->w.fd, EV_WRITE, mda_store_event, s);
	event_add(&s->ev, NULL);
	free(p);
}
d418 12
a429 7
static void
mda_store_event(int fd, short event, void *p)
{
	char			 tmp[16384];
	struct mda_session	*s = p;
	struct ibuf		*buf;
	size_t			 len;
d431 7
a437 9
	if (s->w.queued == 0) {
		if ((buf = ibuf_dynamic(0, sizeof tmp)) == NULL)
			fatal(NULL);
		len = fread(tmp, 1, sizeof tmp, s->datafp);
		if (ferror(s->datafp))
			fatal("mda_store_event: fread failed");
		if (feof(s->datafp) && len == 0) {
			close(s->w.fd);
			s->w.fd = -1;
a439 4
		if (ibuf_add(buf, tmp, len) < 0)
			fatal(NULL);
		ibuf_close(&s->w, buf);
	}
d441 24
a464 3
	if (ibuf_write(&s->w) < 0) {
		close(s->w.fd);
		s->w.fd = -1;
a466 3

	event_set(&s->ev, fd, EV_WRITE, mda_store_event, s);
	event_add(&s->ev, NULL);
d516 39
d575 3
a577 1
		msgbuf_init(&s->w);
d637 2
a638 4
	if (s->w.fd != -1)
		close(s->w.fd);
	event_del(&s->ev);
	msgbuf_clear(&s->w);
@


1.81
log
@rename field msg -> evp.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.80 2012/10/14 20:18:22 eric Exp $	*/
d44 14
a57 1
#define MDA_MAXPERUSER	7
d60 3
a62 1
	struct envelope		 evp;
a67 6
struct mda_user {
	TAILQ_ENTRY(mda_user)	entry;
	char			name[MAXLOGNAME];
	size_t			running;
};

d74 2
a75 2
static int mda_user_increment(const char *);
static void mda_user_decrement(const char *);
d77 1
d82 2
d88 1
a88 1
	char			 output[128], *error, *parent_error;
d92 1
d101 1
d103 1
a103 4
			ep = (struct envelope *)imsg->data;
			fp = fdopen(imsg->fd, "r");
			if (fp == NULL)
				fatalx("mda: fdopen");
d105 2
a106 3
			if (mda_check_loop(fp, ep)) {
				log_debug("mda: loop detected");
				envelope_set_errormsg(ep, "646 loop detected");
d108 3
a110 3
				    IMSG_QUEUE_DELIVERY_LOOP, 0, 0, -1, ep,
				    sizeof *ep);
				fclose(fp);
d114 7
a120 2
			if (mda_user_increment(ep->agent.mda.user) == -1) {
				envelope_set_errormsg(ep, "mda limit reached");
d122 3
a124 3
				    IMSG_QUEUE_DELIVERY_TEMPFAIL, 0, 0, -1, ep,
				    sizeof *ep);
				fclose(fp);
d127 12
d140 24
a163 7
			/* make new session based on provided args */
			s = xcalloc(1, sizeof *s, "mda_imsg");
			msgbuf_init(&s->w);
			s->evp = *ep;
			s->datafp = fp;
			id = mda_id++;
			tree_xset(&sessions, id, s);
d166 2
a167 2
			ep    = &s->evp;
			d_mda = &s->evp.agent.mda;
d227 1
a227 1
			s = tree_xpop(&sessions, imsg->hdr.peerid);
d284 1
a284 1
				envelope_set_errormsg(&s->evp, "%s", error);
d287 2
a288 15
			imsg_compose_event(env->sc_ievs[PROC_QUEUE], msg,
			    0, 0, -1, &s->evp, sizeof s->evp);

			log_envelope(&s->evp, NULL, error ? stat : "Delivered");

			mda_user_decrement(s->evp.agent.mda.user);

			/* destroy session */
			if (s->w.fd != -1)
				close(s->w.fd);
			if (s->datafp)
				fclose(s->datafp);
			msgbuf_clear(&s->w);
			event_del(&s->ev);
			free(s);
d363 2
d393 1
a393 1
	if (s->evp.sender.user[0] && s->evp.sender.domain[0])
d396 3
a398 3
		    s->evp.sender.user, s->evp.sender.domain,
		    s->evp.rcpt.user,
		    s->evp.rcpt.domain);
d401 2
a402 2
		    s->evp.rcpt.user,
		    s->evp.rcpt.domain);
d499 2
a500 2
static int
mda_user_increment(const char *name)
d502 4
a505 1
	struct mda_user	*user;
d507 3
a509 9
	TAILQ_FOREACH(user, &users, entry)
		if (!strcmp(name, user->name)) {
			if (user->running >= MDA_MAXPERUSER) {
				log_debug("mda: too many mda proc for user %s",
				    name);
				return (-1);
			}
			user->running += 1;
			return (0);
d512 1
a512 4
	user = xmalloc(sizeof *user, "mda_user");
	strlcpy(user->name, name, sizeof user->name);
	user->running = 1;
	TAILQ_INSERT_TAIL(&users, user, entry);
d514 35
a548 1
	return (0);
d552 1
a552 1
mda_user_decrement(const char *name)
d554 7
a560 1
	struct mda_user	*user;
d562 25
a586 7
	TAILQ_FOREACH(user, &users, entry)
		if (!strcmp(name, user->name))
			if (--user->running == 0) {
				TAILQ_REMOVE(&users, user, entry);
				free(user);
				break;
			}
@


1.80
log
@As discussed with gilles@@, actually impose the per-user limit regardless
of the delivery method.  Bump the limit a bit.

requested by and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.79 2012/10/14 18:50:25 eric Exp $	*/
d47 1
a47 1
	struct envelope		 msg;
d116 1
a116 1
			s->msg = *ep;
d122 2
a123 2
			ep    = &s->msg;
			d_mda = &s->msg.agent.mda;
d240 1
a240 1
				envelope_set_errormsg(&s->msg, "%s", error);
d244 1
a244 1
			    0, 0, -1, &s->msg, sizeof s->msg);
d246 1
a246 1
			log_envelope(&s->msg, NULL, error ? stat : "Delivered");
d248 1
a248 1
			mda_user_decrement(s->msg.agent.mda.user);
d360 1
a360 1
	if (s->msg.sender.user[0] && s->msg.sender.domain[0])
d363 3
a365 3
		    s->msg.sender.user, s->msg.sender.domain,
		    s->msg.rcpt.user,
		    s->msg.rcpt.domain);
d368 2
a369 2
		    s->msg.rcpt.user,
		    s->msg.rcpt.domain);
@


1.79
log
@Limit the number of per-user mda (external program) deliveries that can be
running at the same time. It prevents a user from consuming all mda "slots"
with a long-running filter in his .forward file.  Other delivery types are
not affected.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.78 2012/09/28 13:40:21 eric Exp $	*/
d44 1
a44 1
#define MDA_MAXPERUSER	5
d104 1
a104 2
			if (ep->agent.mda.method == A_MDA &&
			    mda_user_increment(ep->agent.mda.user) == -1) {
d248 1
a248 2
			if(s->msg.agent.mda.method == A_MDA)
				mda_user_decrement(s->msg.agent.mda.user);
@


1.78
log
@Move mda_session to mda.c, and make it use a tree instead of a list,
but still use uint32_t keys since ithe key is used as peerid in msg.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.77 2012/09/27 17:47:49 chl Exp $	*/
d44 2
d53 6
d65 2
d71 2
d104 10
d249 3
d333 1
d466 38
@


1.77
log
@use xmalloc()/xcalloc() helpers

while there unify usage of log_trace() in ramstat_set()

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.76 2012/09/26 19:52:20 eric Exp $	*/
d44 7
a56 1
static struct mda_session *mda_lookup(uint32_t);
d58 2
a59 1
uint32_t mda_id;
d72 1
a95 1
			s->id = mda_id++;
d97 2
a98 1
			LIST_INSERT_HEAD(&env->mda_sessions, s, entry);
d140 2
a141 2
				log_debug("mda: unknown rule action: %d", d_mda->method);
				fatalx("mda: unknown rule action");
d145 1
a145 1
			    IMSG_PARENT_FORK_MDA, s->id, 0, -1, &deliver,
d154 1
a154 2
			s = mda_lookup(imsg->hdr.peerid);

a157 1

d162 1
a162 2
			s = mda_lookup(imsg->hdr.peerid);

d181 2
a182 1
						buf = xmalloc(len + 1, "mda_imsg");
a227 1
			LIST_REMOVE(s, entry);
d307 1
a307 1
	LIST_INIT(&env->mda_sessions);
a392 15
}

static struct mda_session *
mda_lookup(uint32_t id)
{
	struct mda_session *s;

	LIST_FOREACH(s, &env->mda_sessions, entry)
		if (s->id == id)
			break;

	if (s == NULL)
		fatalx("mda: bogus session id");

	return s;
@


1.76
log
@Stop using the delivery_data union (field "to") in delivery_mda.
It's confusing and not necessary as it's only used for "buffer".
Instead, just add a "buffer" member in the structure and rename
"as_user" to "user".

The delivery_data union becomes an anonymous union in expandnode,
which is the only other place where it's used.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.75 2012/09/21 12:33:32 eric Exp $	*/
d85 1
a85 3
			s = calloc(1, sizeof *s);
			if (s == NULL)
				fatal(NULL);
d176 1
a176 3
						buf = malloc(len + 1);
						if (buf == NULL)
							fatal(NULL);
d419 1
a419 2
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
@


1.75
log
@Add a log_envelope() function that log envelope status in a uniform way.
It automagically adds an rcpt=<user@@domain> field if "dest" differs from
the original "rcpt". The function takes an "extra" parameter that allows
to add some specific info depending on the context.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.74 2012/09/20 09:27:49 eric Exp $	*/
d100 1
a100 1
				strlcpy(deliver.user, d_mda->as_user,
d102 1
a102 1
				strlcpy(deliver.to, d_mda->to.buffer,
d110 1
a110 1
				strlcpy(deliver.to, d_mda->to.user,
d119 1
a119 1
				strlcpy(deliver.user, d_mda->as_user,
d121 1
a121 1
				strlcpy(deliver.to, d_mda->to.buffer,
d127 1
a127 1
				strlcpy(deliver.user, d_mda->as_user,
d129 1
a129 1
				strlcpy(deliver.to, d_mda->to.buffer,
@


1.74
log
@envelope type is necessarily D_MDA here.

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.73 2012/09/16 16:43:28 chl Exp $	*/
d58 1
a61 1
	struct mailaddr		*maddr;
d218 1
d223 1
a223 20
			/*
			 * XXX: which struct path gets used for logging depends
			 * on whether lka did aliases or .forward processing;
			 * lka may need to be changed to present data in more
			 * unified way.
			 */
			if (s->msg.rule.r_action == A_MAILDIR ||
			    s->msg.rule.r_action == A_MBOX)
				maddr = &s->msg.dest;
			else
				maddr = &s->msg.rcpt;

			/* log status */
			if (error && asprintf(&error, "Error (%s)", error) < 0)
				fatal("mda: asprintf");
			log_info("%016" PRIx64 ": to=<%s@@%s>, delay=%s, stat=%s",
			    s->msg.id, maddr->user, maddr->domain,
			    duration_to_text(time(NULL) - s->msg.creation),
			    error ? error : "Sent");
			free(error);
@


1.73
log
@Factorize log_imsg() in imsg_dispatch() instead of in each imsg_callback()'s
and put it out of profiling, so it's not accounted.

While there, for PROC_PARENT:
- set smtpd_process for PROC_PARENT
- use setproctitle() like other processes

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.72 2012/08/25 10:23:11 gilles Exp $	*/
d432 1
a432 1
	struct mailaddr	 maddr, dest;
d456 2
a457 5

			dest = (ep->type == D_BOUNCE) ? ep->sender : ep->dest;

			if (strcasecmp(maddr.user, dest.user) == 0 &&
			    strcasecmp(maddr.domain, dest.domain) == 0) {
@


1.72
log
@- introduce struct stat_value
- statistics can now have a type (counter, timestamp, timeval, timespec and
  possibly others in the future)
- stat_increment() / stat_decrement() now take an increment/decrement value
  and are at the moment only of type counter
- stat_set() now takes a stat_value
- provide helpers to convert raw values to stat_value

ok eric@@, ok chl@@

while at it fix a rq_queue_dump() call using a bogus timestamp in scheduler
ramqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.71 2012/08/25 08:27:03 eric Exp $	*/
a64 2

	log_imsg(PROC_MDA, iev->proc, imsg);
@


1.71
log
@use duration_to_text() when logging delay, for consistency.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.70 2012/08/21 13:13:17 eric Exp $	*/
d296 2
a297 1
		{ PROC_QUEUE,	imsg_dispatch }
@


1.70
log
@Re-enable loop detection, but in mta and mda this time.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.69 2012/08/19 14:16:58 chl Exp $	*/
d239 1
a239 1
			log_info("%016" PRIx64 ": to=<%s@@%s>, delay=%" PRId64 ", stat=%s",
d241 1
a241 1
			    (int64_t) (time(NULL) - s->msg.creation),
@


1.69
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.68 2012/08/09 09:48:02 eric Exp $	*/
d27 1
d49 1
d63 1
d71 15
d91 1
a91 1
			s->msg = *(struct envelope *)imsg->data;
d93 1
a93 3
			s->datafp = fdopen(imsg->fd, "r");
			if (s->datafp == NULL)
				fatalx("mda: fdopen");
a167 1
				FILE *fp;
d426 51
@


1.68
log
@Improve the message flows to completely isolate operations on the
queue backend within the queue process.

The scheduler sends envelope ids to the queue process which loads
the envelope and forward the request to the agent responsible for
the delivery.  The result is sent by the agent to the queue which
updates the storage before notifying the scheduler.

Bounces are created and enqueued (from the client side) by the
queue process, rather than the scheduler.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.67 2012/01/13 14:01:57 eric Exp $	*/
d48 1
a48 1
static struct mda_session *mda_lookup(u_int32_t);
d50 1
a50 1
u_int32_t mda_id;
d61 1
a61 1
	u_int16_t		 msg;
d399 1
a399 1
mda_lookup(u_int32_t id)
@


1.67
log
@Stop using envelope->status to report delivery outcome to the
runner/queue.  Instead, replace IMSG_QUEUE_MESSAGE_UPDATE with three
messages:

- IMSG_QUEUE_DELIVERY_OK
- IMSG_QUEUE_DELIVERY_TEMPFAIL
- IMSG_QUEUE_DELIVERY_PERMFAIL

1) it's less confusing as status is also used by smtp
2) it's easier to see what happens just looking at imsg traces
3) it makes the code path generally easier to follow
4) it's safer because it enforces clear semantics and intent, whereas
   the status field is loosely defined and could carry bogus values.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.66 2012/01/12 20:59:07 eric Exp $	*/
a238 4

			/* update queue's session count */
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_MDA_SESS_NEW, 0, 0, -1, NULL, 0);
@


1.66
log
@use mbox backend for mbox delivery.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.65 2011/12/18 18:43:30 eric Exp $	*/
d61 1
a73 1
			s->msg.status = DS_TEMPFAILURE;
d201 3
a203 3
			if (error == NULL)
				s->msg.status = DS_ACCEPTED;
			else
d205 3
a207 3
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_QUEUE_MESSAGE_UPDATE, 0, 0, -1, &s->msg,
			    sizeof s->msg);
@


1.65
log
@- use envelope_set_errormsg() where possible.
- make it use sizeof() rather than a hardcoded limit.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.64 2011/12/13 21:44:47 gilles Exp $	*/
d93 1
a93 1
				deliver.mode = A_MDA;
d96 5
a100 5
				snprintf(deliver.to, sizeof (deliver.to),
				    "%s -f %s@@%s %s", PATH_MAILLOCAL,
				    ep->sender.user,
				    ep->sender.domain,
				    d_mda->to.user);
@


1.64
log
@- introduce delivery backend API (delivery.c)
- move each delivery method to it's own delivery backend
- simplify smtpd.c accordingly
- rename A_EXT -> A_MDA since that's what we really do

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.63 2011/11/14 19:23:41 chl Exp $	*/
d204 1
a204 2
				strlcpy(s->msg.errorline, error,
				    sizeof s->msg.errorline);
@


1.63
log
@when receiving an unexpected imsg, print its name.

with help and ideas from eric@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.62 2011/10/27 14:32:57 chl Exp $	*/
d84 2
a85 2
			case A_EXT:
				deliver.mode = A_EXT;
d93 1
a93 1
				deliver.mode = A_EXT;
@


1.62
log
@Use PRI{x,d}64 in format strings instead of %llx, %lld or %qd to print {u_,}int64_t or time_t

While there, cast some time_t to int64_t

These will fix build warnings for portable smptd

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.61 2011/10/23 09:30:07 gilles Exp $	*/
d27 1
d252 1
a252 1
	fatalx("mda_imsg: unexpected imsg");
@


1.61
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.60 2011/10/09 18:39:53 eric Exp $	*/
d29 1
d224 1
a224 1
			log_info("%016llx: to=<%s@@%s>, delay=%lld, stat=%s",
d226 1
a226 1
			    (long long int) (time(NULL) - s->msg.creation),
@


1.60
log
@show messages sent between processes in debug mode

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.59 2011/08/29 21:43:08 chl Exp $	*/
a55 1
	struct delivery		*d;
d58 1
d71 1
a71 1
			s->msg.delivery.status = DS_TEMPFAILURE;
d79 2
a80 2
			d     = &s->msg.delivery;
			d_mda = &s->msg.delivery.agent.mda;
d96 2
a97 2
				    d->from.user,
				    d->from.domain,
d200 1
a200 1
				s->msg.delivery.status = DS_ACCEPTED;
d202 2
a203 2
				strlcpy(s->msg.delivery.errorline, error,
				    sizeof s->msg.delivery.errorline);
d216 1
a216 1
				maddr = &s->msg.delivery.rcpt;
d218 1
a218 1
				maddr = &s->msg.delivery.rcpt_orig;
d224 2
a225 2
			    s->msg.delivery.id, maddr->user, maddr->domain,
			    (long long int) (time(NULL) - s->msg.delivery.creation),
d342 1
a342 1
	if (s->msg.delivery.from.user[0] && s->msg.delivery.from.domain[0])
d345 3
a347 3
		    s->msg.delivery.from.user, s->msg.delivery.from.domain,
		    s->msg.delivery.rcpt_orig.user,
		    s->msg.delivery.rcpt_orig.domain);
d350 2
a351 2
		    s->msg.delivery.rcpt_orig.user,
		    s->msg.delivery.rcpt_orig.domain);
@


1.59
log
@cast all printed time_t to long long int, and change format string accordingly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.58 2011/08/29 18:49:29 chl Exp $	*/
d59 2
@


1.58
log
@add missing header needed by signal()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.57 2011/08/26 14:39:47 chl Exp $	*/
d221 1
a221 1
			log_info("%016llx: to=<%s@@%s>, delay=%d, stat=%s",
d223 1
a223 1
			    time(NULL) - s->msg.delivery.creation,
@


1.57
log
@add missing header needed by time()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.56 2011/05/16 21:05:51 gilles Exp $	*/
d30 1
@


1.56
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.55 2011/05/01 12:57:11 eric Exp $	*/
d33 1
@


1.55
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.54 2011/04/17 13:36:07 gilles Exp $	*/
d54 3
a56 1
	struct path		*path;
d67 1
a67 1
			s->msg.status = S_MESSAGE_TEMPFAILURE;
d75 3
a77 2
			path = &s->msg.recipient;
			switch (path->rule.r_action) {
d80 3
a82 3
				strlcpy(deliver.user, path->pw_name,
				    sizeof deliver.user);
				strlcpy(deliver.to, path->rule.r_value.buffer,
d85 1
a85 1

d89 2
a90 2
				    sizeof deliver.user);
				snprintf(deliver.to, sizeof deliver.to,
d92 3
a94 2
				    s->msg.sender.user, s->msg.sender.domain,
				    path->pw_name);
d99 1
a99 1
				strlcpy(deliver.user, path->pw_name,
d101 1
a101 1
				strlcpy(deliver.to, path->rule.r_value.buffer,
d107 1
a107 2
				/* XXX: unconditional SMTPD_USER is wrong. */
				strlcpy(deliver.user, SMTPD_USER,
d109 1
a109 1
				strlcpy(deliver.to, path->u.filename,
d114 1
d196 1
a196 1
				s->msg.status = S_MESSAGE_ACCEPTED;
d198 2
a199 2
				strlcpy(s->msg.session_errorline, error,
				    sizeof s->msg.session_errorline);
d210 3
a212 3
			if (s->msg.recipient.rule.r_action == A_MAILDIR ||
			    s->msg.recipient.rule.r_action == A_MBOX)
				path = &s->msg.recipient;
d214 1
a214 1
				path = &s->msg.session_rcpt;
d220 2
a221 2
			    s->msg.evpid, path->user, path->domain,
			    time(NULL) - s->msg.creation,
d338 1
a338 1
	if (s->msg.sender.user[0] && s->msg.sender.domain[0])
d341 3
a343 2
		    s->msg.sender.user, s->msg.sender.domain,
		    s->msg.session_rcpt.user, s->msg.session_rcpt.domain);
d346 2
a347 1
		    s->msg.session_rcpt.user, s->msg.session_rcpt.domain);
@


1.54
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.53 2011/04/17 11:39:22 gilles Exp $	*/
d39 1
a39 1
static void mda_imsg(struct smtpd *, struct imsgev *, struct imsg *);
d44 1
a44 1
static struct mda_session *mda_lookup(struct smtpd *, u_int32_t);
d49 1
a49 1
mda_imsg(struct smtpd *env, struct imsgev *iev, struct imsg *imsg)
d124 1
a124 1
			s = mda_lookup(env, imsg->hdr.peerid);
d134 1
a134 1
			s = mda_lookup(env, imsg->hdr.peerid);
d266 1
a266 1
mda(struct smtpd *env)
d288 1
a288 1
	purge_config(env, PURGE_EVERYTHING);
d310 2
a311 2
	signal_set(&ev_sigint, SIGINT, mda_sig_handler, env);
	signal_set(&ev_sigterm, SIGTERM, mda_sig_handler, env);
d317 2
a318 2
	config_pipes(env, peers, nitems(peers));
	config_peers(env, peers, nitems(peers));
d392 1
a392 1
mda_lookup(struct smtpd *env, u_int32_t id)
@


1.53
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.52 2011/04/15 17:01:05 gilles Exp $	*/
d39 6
a44 6
void			 mda_imsg(struct smtpd *, struct imsgev *, struct imsg *);
__dead void		 mda_shutdown(void);
void			 mda_sig_handler(int, short, void *);
void			 mda_store(struct mda_session *);
void			 mda_store_event(int, short, void *);
struct mda_session	*mda_lookup(struct smtpd *, u_int32_t);
d48 1
a48 1
void
d245 1
a245 1
void
d258 1
a258 1
void
d327 1
a327 1
void
d357 1
a357 1
void
d391 1
a391 1
struct mda_session *
@


1.52
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.51 2010/11/28 14:35:58 gilles Exp $	*/
d64 1
a64 1
			s->msg = *(struct message *)imsg->data;
@


1.51
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.50 2010/11/28 13:56:43 gilles Exp $	*/
d215 2
a216 2
			log_info("%s: to=<%s@@%s>, delay=%d, stat=%s",
			    s->msg.message_id, path->user, path->domain,
@


1.50
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.49 2010/10/09 22:05:35 gilles Exp $	*/
a26 1
#include <errno.h>
a29 1
#include <signal.h>
a32 1
#include <time.h>
@


1.49
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.44 2010/05/26 13:56:08 nicm Exp $	*/
d29 1
d40 1
a44 2
void			 mda_setup_events(struct smtpd *);
void			 mda_disable_events(struct smtpd *);
a267 10
void
mda_setup_events(struct smtpd *env)
{
}

void
mda_disable_events(struct smtpd *env)
{
}

a322 1
	mda_setup_events(env);
@


1.48
log
@check event_dispatch() return value

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.47 2010/06/01 23:06:23 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009-2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
a38 1
#include "queue_backend.h"
d49 2
d57 1
a57 1
	struct action		*action;
d61 3
a63 2
		case IMSG_BATCH_CREATE:
			s = malloc(sizeof *s);
d67 3
a69 3
			bzero(&s->ev, sizeof s->ev);
			s->id = imsg->hdr.peerid;
			s->content_id = *(u_int64_t *)imsg->data;
a73 1
			return;
d75 37
a111 13
		case IMSG_BATCH_APPEND:
			LIST_FOREACH(s, &env->mda_sessions, entry)
				if (s->id == imsg->hdr.peerid)
					break;
			if (s == NULL)
				fatalx("mda: bogus append");
			action = imsg->data;
			s->action_id = action->id;
			s->auxraw = strdup(action->data);
			if (s->auxraw == NULL)
				fatal(NULL);
			auxsplit(&s->aux, s->auxraw);
			return;
d113 3
a115 7
		case IMSG_BATCH_CLOSE:
			LIST_FOREACH(s, &env->mda_sessions, entry)
				if (s->id == imsg->hdr.peerid)
					break;
			if (s == NULL)
				fatalx("mda: bogus close");
			memcpy(&s->birth, imsg->data, sizeof s->birth);
a116 12
			/* request helper process from parent */
			if (s->aux.mode[0] == 'M') {
				deliver.mode = 'P';
				strlcpy(deliver.user, "root", sizeof deliver.user);
				snprintf(deliver.to, sizeof deliver.to,
				    "exec /usr/libexec/mail.local %s",
				    s->aux.user_to);
			} else {
				deliver.mode = s->aux.mode[0];
				strlcpy(deliver.user, s->aux.user_to, sizeof deliver.user);
				strlcpy(deliver.to, s->aux.path, sizeof deliver.to);
			}
a138 4
			/* all parent errors are temporary */
			if (asprintf(&parent_error, "100 %s", (char *)imsg->data) < 0)
				fatal("mda: asprintf");

d165 3
a167 3
					strlcpy(output, "100 \"", sizeof output);
					strnvis(output + 5, ln,
					    sizeof(output) - 6,
d170 1
d181 3
a183 1
			if (strcmp(parent_error + 4, "exited okay") == 0) {
d185 1
a185 3
					error = "100 mda exited prematurely";
				else
					error = "200 ok";
d194 5
a198 5
			action = malloc(sizeof *action + strlen(error));
			if (action == NULL)
				fatal(NULL);
			action->id = s->action_id;
			strlcpy(action->data, error, strlen(error) + 1);
d200 14
a213 4
			    IMSG_BATCH_UPDATE, s->id, 0, -1, action,
			    sizeof *action + strlen(error));
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_BATCH_DONE, s->id, 0, -1, NULL, 0);
d216 7
a222 6
			log_info("%s: to=%s, delay=%d, stat=%s%s%s",
			    queue_be_decode(s->content_id), rcpt_pretty(&s->aux),
			    time(NULL) - s->birth,
			    *error == '2' ? "Sent" : "Error (",
			    *error == '2' ? "" : error + 4,
			    *error == '2' ? "" : ")");
a231 1
			free(s->auxraw);
d233 4
a236 1
			free(parent_error);
d328 1
d348 5
a352 4
	/* XXX: remove user provided Return-Path, if any */
	if (s->aux.mail_from[0])
		len = asprintf(&p, "Return-Path: %s\nDelivered-To: %s\n",
		    s->aux.mail_from, s->aux.rcpt_to);
d354 2
a355 1
		len = asprintf(&p, "Delivered-To: %s\n", s->aux.rcpt_to);
@


1.47
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.45 2010/05/31 23:38:56 jacekm Exp $	*/
d315 1
a315 1
		log_warn("event_dispatch");
@


1.46
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.44 2010/05/26 13:56:08 nicm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d39 1
a49 2
u_int32_t mda_id;

d56 1
a56 1
	struct path		*path;
d60 2
a61 3
		case IMSG_MDA_SESS_NEW:
			/* make new session based on provided args */
			s = calloc(1, sizeof *s);
d65 3
a67 3
			s->msg = *(struct message *)imsg->data;
			s->msg.status = S_MESSAGE_TEMPFAILURE;
			s->id = mda_id++;
d72 15
d88 12
a99 15
			/* request parent to fork a helper process */
			path = &s->msg.recipient;
			switch (path->rule.r_action) {
			case A_EXT:
				deliver.mode = A_EXT;
				strlcpy(deliver.user, path->pw_name,
				    sizeof deliver.user);
				strlcpy(deliver.to, path->rule.r_value.path,
				    sizeof deliver.to);
				break;

			case A_MBOX:
				deliver.mode = A_EXT;
				strlcpy(deliver.user, "root",
				    sizeof deliver.user);
d101 6
a106 24
				    "%s -f %s@@%s %s", PATH_MAILLOCAL,
				    s->msg.sender.user, s->msg.sender.domain,
				    path->pw_name);
				break;

			case A_MAILDIR:
				deliver.mode = A_MAILDIR;
				strlcpy(deliver.user, path->pw_name,
				    sizeof deliver.user);
				strlcpy(deliver.to, path->rule.r_value.path,
				    sizeof deliver.to);
				break;

			case A_FILENAME:
				deliver.mode = A_FILENAME;
				/* XXX: unconditional SMTPD_USER is wrong. */
				strlcpy(deliver.user, SMTPD_USER,
				    sizeof deliver.user);
				strlcpy(deliver.to, path->u.filename,
				    sizeof deliver.to);
				break;

			default:
				fatalx("mda: unknown rule action");
a107 1

d130 4
d160 3
a162 3
					strlcpy(output, "\"", sizeof output);
					strnvis(output + 1, ln,
					    sizeof(output) - 2,
a164 1
					log_debug("mda_out: %s", output);
d175 1
a175 3
			error = NULL;
			parent_error = imsg->data;
			if (strcmp(parent_error, "exited okay") == 0) {
d177 3
a179 1
					error = "mda exited prematurely";
d188 8
a195 5
			if (error == NULL)
				s->msg.status = S_MESSAGE_ACCEPTED;
			else
				strlcpy(s->msg.session_errorline, error,
				    sizeof s->msg.session_errorline);
d197 1
a197 14
			    IMSG_QUEUE_MESSAGE_UPDATE, 0, 0, -1, &s->msg,
			    sizeof s->msg);

			/*
			 * XXX: which struct path gets used for logging depends
			 * on whether lka did aliases or .forward processing;
			 * lka may need to be changed to present data in more
			 * unified way.
			 */
			if (s->msg.recipient.rule.r_action == A_MAILDIR ||
			    s->msg.recipient.rule.r_action == A_MBOX)
				path = &s->msg.recipient;
			else
				path = &s->msg.session_rcpt;
d200 6
a205 7
			if (error && asprintf(&error, "Error (%s)", error) < 0)
				fatal("mda: asprintf");
			log_info("%s: to=<%s@@%s>, delay=%d, stat=%s",
			    s->msg.message_id, path->user, path->domain,
			    time(NULL) - s->msg.creation,
			    error ? error : "Sent");
			free(error);
d215 1
d217 1
a217 4

			/* update queue's session count */
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_MDA_SESS_NEW, 0, 0, -1, NULL, 0);
a308 1
	signal(SIGHUP, SIG_IGN);
d314 2
a315 1
	event_dispatch();
d328 4
a331 5
	if (s->msg.sender.user[0] && s->msg.sender.domain[0])
		/* XXX: remove user provided Return-Path, if any */
		len = asprintf(&p, "Return-Path: %s@@%s\nDelivered-To: %s@@%s\n",
		    s->msg.sender.user, s->msg.sender.domain,
		    s->msg.session_rcpt.user, s->msg.session_rcpt.domain);
d333 1
a333 2
		len = asprintf(&p, "Delivered-To: %s@@%s\n",
		    s->msg.session_rcpt.user, s->msg.session_rcpt.domain);
@


1.45
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d6 1
a6 1
 * Copyright (c) 2009-2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
a38 1
#include "queue_backend.h"
d49 2
d57 1
a57 2
	struct action		*action;
	size_t			 action_sz;
d61 3
a63 2
		case IMSG_BATCH_CREATE:
			s = malloc(sizeof *s);
d67 3
a69 3
			bzero(&s->ev, sizeof s->ev);
			s->id = imsg->hdr.peerid;
			s->content_id = *(u_int64_t *)imsg->data;
a73 1
			return;
d75 37
a111 13
		case IMSG_BATCH_APPEND:
			LIST_FOREACH(s, &env->mda_sessions, entry)
				if (s->id == imsg->hdr.peerid)
					break;
			if (s == NULL)
				fatalx("mda: bogus append");
			action = imsg->data;
			s->action_id = action->id;
			s->auxraw = strdup(action->arg);
			if (s->auxraw == NULL)
				fatal(NULL);
			auxsplit(&s->aux, s->auxraw);
			return;
d113 3
a115 7
		case IMSG_BATCH_CLOSE:
			LIST_FOREACH(s, &env->mda_sessions, entry)
				if (s->id == imsg->hdr.peerid)
					break;
			if (s == NULL)
				fatalx("mda: bogus close");
			memcpy(&s->birth, imsg->data, sizeof s->birth);
a116 12
			/* request helper process from parent */
			if (s->aux.mode[0] == 'M') {
				deliver.mode = 'P';
				strlcpy(deliver.user, "root", sizeof deliver.user);
				snprintf(deliver.to, sizeof deliver.to,
				    "exec /usr/libexec/mail.local %s",
				    s->aux.user_to);
			} else {
				deliver.mode = s->aux.mode[0];
				strlcpy(deliver.user, s->aux.user_to, sizeof deliver.user);
				strlcpy(deliver.to, s->aux.path, sizeof deliver.to);
			}
a138 4
			/* all parent errors are temporary */
			if (asprintf(&parent_error, "100 %s", (char *)imsg->data) < 0)
				fatal("mda: asprintf");

d165 3
a167 3
					strlcpy(output, "100 \"", sizeof output);
					strnvis(output + 5, ln,
					    sizeof(output) - 6,
d170 1
d181 3
a183 1
			if (strcmp(parent_error + 4, "exited okay") == 0) {
d185 1
a185 3
					error = "100 mda exited prematurely";
				else
					error = "200 ok";
d194 5
a198 6
			action_sz = sizeof *action + strlen(error) + 1;
			action = malloc(action_sz);
			if (action == NULL)
				fatal(NULL);
			action->id = s->action_id;
			strlcpy(action->arg, error, action_sz - sizeof *action);
d200 14
a213 3
			    IMSG_BATCH_UPDATE, s->id, 0, -1, action, action_sz);
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_BATCH_DONE, s->id, 0, -1, NULL, 0);
d216 7
a222 6
			log_info("%s: to=%s, delay=%d, stat=%s%s%s",
			    queue_be_decode(s->content_id), rcpt_pretty(&s->aux),
			    time(NULL) - s->birth,
			    *error == '2' ? "Sent" : "Error (",
			    *error == '2' ? "" : error + 4,
			    *error == '2' ? "" : ")");
a231 1
			free(s->auxraw);
d233 4
a236 1
			free(parent_error);
d328 1
d334 1
a334 2
	if (event_dispatch() < 0)
		log_warn("event_dispatch");
d347 5
a351 4
	/* XXX: remove user provided Return-Path, if any */
	if (s->aux.mail_from[0])
		len = asprintf(&p, "Return-Path: %s\nDelivered-To: %s\n",
		    s->aux.mail_from, s->aux.rcpt_to);
d353 2
a354 1
		len = asprintf(&p, "Delivered-To: %s\n", s->aux.rcpt_to);
@


1.44
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.43 2010/04/21 18:54:43 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d39 1
a49 2
u_int32_t mda_id;

d56 2
a57 1
	struct path		*path;
d61 2
a62 3
		case IMSG_MDA_SESS_NEW:
			/* make new session based on provided args */
			s = calloc(1, sizeof *s);
d66 3
a68 3
			s->msg = *(struct message *)imsg->data;
			s->msg.status = S_MESSAGE_TEMPFAILURE;
			s->id = mda_id++;
d73 15
d89 12
a100 15
			/* request parent to fork a helper process */
			path = &s->msg.recipient;
			switch (path->rule.r_action) {
			case A_EXT:
				deliver.mode = A_EXT;
				strlcpy(deliver.user, path->pw_name,
				    sizeof deliver.user);
				strlcpy(deliver.to, path->rule.r_value.path,
				    sizeof deliver.to);
				break;

			case A_MBOX:
				deliver.mode = A_EXT;
				strlcpy(deliver.user, "root",
				    sizeof deliver.user);
d102 6
a107 24
				    "%s -f %s@@%s %s", PATH_MAILLOCAL,
				    s->msg.sender.user, s->msg.sender.domain,
				    path->pw_name);
				break;

			case A_MAILDIR:
				deliver.mode = A_MAILDIR;
				strlcpy(deliver.user, path->pw_name,
				    sizeof deliver.user);
				strlcpy(deliver.to, path->rule.r_value.path,
				    sizeof deliver.to);
				break;

			case A_FILENAME:
				deliver.mode = A_FILENAME;
				/* XXX: unconditional SMTPD_USER is wrong. */
				strlcpy(deliver.user, SMTPD_USER,
				    sizeof deliver.user);
				strlcpy(deliver.to, path->u.filename,
				    sizeof deliver.to);
				break;

			default:
				fatalx("mda: unknown rule action");
a108 1

d131 4
d161 3
a163 3
					strlcpy(output, "\"", sizeof output);
					strnvis(output + 1, ln,
					    sizeof(output) - 2,
a165 1
					log_debug("mda_out: %s", output);
d176 1
a176 3
			error = NULL;
			parent_error = imsg->data;
			if (strcmp(parent_error, "exited okay") == 0) {
d178 3
a180 1
					error = "mda exited prematurely";
d189 8
a196 5
			if (error == NULL)
				s->msg.status = S_MESSAGE_ACCEPTED;
			else
				strlcpy(s->msg.session_errorline, error,
				    sizeof s->msg.session_errorline);
d198 1
a198 14
			    IMSG_QUEUE_MESSAGE_UPDATE, 0, 0, -1, &s->msg,
			    sizeof s->msg);

			/*
			 * XXX: which struct path gets used for logging depends
			 * on whether lka did aliases or .forward processing;
			 * lka may need to be changed to present data in more
			 * unified way.
			 */
			if (s->msg.recipient.rule.r_action == A_MAILDIR ||
			    s->msg.recipient.rule.r_action == A_MBOX)
				path = &s->msg.recipient;
			else
				path = &s->msg.session_rcpt;
d201 6
a206 7
			if (error && asprintf(&error, "Error (%s)", error) < 0)
				fatal("mda: asprintf");
			log_info("%s: to=<%s@@%s>, delay=%d, stat=%s",
			    s->msg.message_id, path->user, path->domain,
			    time(NULL) - s->msg.creation,
			    error ? error : "Sent");
			free(error);
d216 1
d218 1
a218 4

			/* update queue's session count */
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_MDA_SESS_NEW, 0, 0, -1, NULL, 0);
a309 1
	signal(SIGHUP, SIG_IGN);
d315 2
a316 1
	event_dispatch();
d329 4
a332 5
	if (s->msg.sender.user[0] && s->msg.sender.domain[0])
		/* XXX: remove user provided Return-Path, if any */
		len = asprintf(&p, "Return-Path: %s@@%s\nDelivered-To: %s@@%s\n",
		    s->msg.sender.user, s->msg.sender.domain,
		    s->msg.session_rcpt.user, s->msg.session_rcpt.domain);
d334 1
a334 2
		len = asprintf(&p, "Delivered-To: %s@@%s\n",
		    s->msg.session_rcpt.user, s->msg.session_rcpt.domain);
@


1.43
log
@Runner process is just a helper for queue, so tear down its imsg
channels to parent, mda, mta, lka, smtp, and control.  This leaves
just the channel to queue, which forwards imsgs on runner's behalf
and redirects any replies back to it.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.42 2010/04/21 08:29:01 jacekm Exp $	*/
d344 1
a344 1
	struct buf	*buf;
d360 1
a360 1
	if ((buf = buf_open(len)) == NULL)
d362 1
a362 1
	if (buf_add(buf, p, len) < 0)
d364 1
a364 1
	buf_close(&s->w, buf);
d375 1
a375 1
	struct buf		*buf;
d379 1
a379 1
		if ((buf = buf_dynamic(0, sizeof tmp)) == NULL)
d389 1
a389 1
		if (buf_add(buf, tmp, len) < 0)
d391 1
a391 1
		buf_close(&s->w, buf);
d394 1
a394 1
	if (buf_write(&s->w) < 0) {
@


1.42
log
@Remove unusable ifdef DEBUG code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.41 2010/04/20 18:18:36 jacekm Exp $	*/
d59 1
a59 1
	if (iev->proc == PROC_RUNNER) {
d234 2
a235 2
			/* update runner's session count */
			imsg_compose_event(env->sc_ievs[PROC_RUNNER],
d289 1
a289 2
		{ PROC_QUEUE,	imsg_dispatch },
		{ PROC_RUNNER,	imsg_dispatch }
@


1.41
log
@Use correct type for ``mda_id'', ie. match with type used in imsg header.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.40 2010/04/20 15:34:56 jacekm Exp $	*/
a305 1
#ifndef DEBUG
a309 3
#else
#warning disabling privilege revocation and chroot in DEBUG MODE
#endif
a313 1
#ifndef DEBUG
a317 1
#endif
@


1.40
log
@Kill *2400* lines of code by abstracting common bits of the imsg handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.39 2010/04/19 20:10:36 jacekm Exp $	*/
d49 1
a49 1
int mda_id;
@


1.39
log
@Use larger buffer for mda output.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.38 2010/04/19 08:14:07 jacekm Exp $	*/
d40 1
a42 3
void			 mda_dispatch_parent(int, short, void *);
void			 mda_dispatch_queue(int, short, void *);
void			 mda_dispatch_runner(int, short, void *);
d52 1
a52 1
mda_sig_handler(int sig, short event, void *p)
d54 62
a115 9
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		mda_shutdown();
		break;
	default:
		fatalx("mda_sig_handler: unexpected signal");
	}
}
d117 3
a119 19
void
mda_dispatch_parent(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_PARENT];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d124 4
a127 16
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mda_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_PARENT_FORK_MDA: {
			struct mda_session	*s;

			s = mda_lookup(env, imsg.hdr.peerid);
d129 1
a129 1
			if (imsg.fd < 0)
d131 1
a131 1
			s->w.fd = imsg.fd;
a132 1
			/* send message content to the helper process */
d134 1
a134 2
			break;
		}
d136 2
a137 7
		case IMSG_MDA_DONE: {
			char			 output[128];
			struct mda_session	*s;
			struct path		*path;
			char			*error, *parent_error;

			s = mda_lookup(env, imsg.hdr.peerid);
d143 1
a143 1
			if (imsg.fd != -1) {
d149 1
a149 1
				if (lseek(imsg.fd, 0, SEEK_SET) < 0)
d151 1
a151 1
				fp = fdopen(imsg.fd, "r");
d182 1
a182 1
			parent_error = imsg.data;
d237 1
a237 7
			break;
		}

		case IMSG_CTL_VERBOSE: {
			int verbose;

			IMSG_SIZE_CHECK(&verbose);
d239 2
a240 34
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		}

		default:
			log_warnx("mda_dispatch_parent: got imsg %d",
			    imsg.hdr.type);
			fatalx("mda_dispatch_parent: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
mda_dispatch_queue(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_QUEUE];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d245 1
a245 20
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mda_dispatch_queue: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("mda_dispatch_queue: got imsg %d",
			    imsg.hdr.type);
			fatalx("mda_dispatch_queue: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d249 1
a249 1
mda_dispatch_runner(int sig, short event, void *p)
d251 7
a257 103
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_RUNNER];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mda_dispatch_runner: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_MDA_SESS_NEW: {
			struct deliver		 deliver;
			struct mda_session	*s;
			struct path		*path;

			/* make new session based on provided args */
			s = calloc(1, sizeof *s);
			if (s == NULL)
				fatal(NULL);
			msgbuf_init(&s->w);
			s->msg = *(struct message *)imsg.data;
			s->msg.status = S_MESSAGE_TEMPFAILURE;
			s->id = mda_id++;
			s->datafp = fdopen(imsg.fd, "r");
			if (s->datafp == NULL)
				fatalx("mda: fdopen");
			LIST_INSERT_HEAD(&env->mda_sessions, s, entry);

			/* request parent to fork a helper process */
			path = &s->msg.recipient;
			switch (path->rule.r_action) {
			case A_EXT:
				deliver.mode = A_EXT;
				strlcpy(deliver.user, path->pw_name,
				    sizeof deliver.user);
				strlcpy(deliver.to, path->rule.r_value.path,
				    sizeof deliver.to);
				break;

			case A_MBOX:
				deliver.mode = A_EXT;
				strlcpy(deliver.user, "root",
				    sizeof deliver.user);
				snprintf(deliver.to, sizeof deliver.to,
				    "%s -f %s@@%s %s", PATH_MAILLOCAL,
				    s->msg.sender.user, s->msg.sender.domain,
				    path->pw_name);
				break;

			case A_MAILDIR:
				deliver.mode = A_MAILDIR;
				strlcpy(deliver.user, path->pw_name,
				    sizeof deliver.user);
				strlcpy(deliver.to, path->rule.r_value.path,
				    sizeof deliver.to);
				break;

			case A_FILENAME:
				deliver.mode = A_FILENAME;
				/* XXX: unconditional SMTPD_USER is wrong. */
				strlcpy(deliver.user, SMTPD_USER,
				    sizeof deliver.user);
				strlcpy(deliver.to, path->u.filename,
				    sizeof deliver.to);
				break;

			default:
				fatalx("unknown rule action");
			}

			imsg_compose_event(env->sc_ievs[PROC_PARENT],
			    IMSG_PARENT_FORK_MDA, s->id, 0, -1, &deliver,
			    sizeof deliver);
			break;
		}
		default:
			log_warnx("mda_dispatch_runner: got imsg %d",
			    imsg.hdr.type);
			fatalx("mda_dispatch_runner: unexpected imsg");
		}
		imsg_free(&imsg);
a258 1
	imsg_event_add(iev);
a260 1

d288 3
a290 3
		{ PROC_PARENT,	mda_dispatch_parent },
		{ PROC_QUEUE,	mda_dispatch_queue },
		{ PROC_RUNNER,	mda_dispatch_runner }
d327 1
@


1.38
log
@Simplify local delivery codepath:
- replace uses of struct batch in the parent with simpler struct delivery.
- replace IMSG_BATCH_* dance with single IMSG_MDA_SESS_NEW.
- make mda assume it delivers to external program over a pipe.
- fork helper process when delivering to maildir or a file.

New feature: upon external mda failure use last line of its output
as an error message.

With input and tests from nicm@@.

OK nicm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.37 2010/03/03 10:52:31 jacekm Exp $	*/
d116 1
a116 1
			char			 output[64];
@


1.37
log
@tweak mda.c rev. 1.36: eliminate risk of busy waiting for socket
to become writable, and make code more idiomatic.

tested by nicm@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.36 2010/03/01 22:00:52 gilles Exp $	*/
d36 1
d40 12
a51 11
__dead void	mda_shutdown(void);
void		mda_sig_handler(int, short, void *);
void		mda_dispatch_parent(int, short, void *);
void		mda_dispatch_queue(int, short, void *);
void		mda_dispatch_runner(int, short, void *);
void		mda_setup_events(struct smtpd *);
void		mda_disable_events(struct smtpd *);
void		mda_store(struct batch *);
void		mda_event(int, short, void *);
void		mda_store_done(struct batch *);
void		mda_done(struct smtpd *, struct batch *);
d101 2
a102 4
		case IMSG_PARENT_MAILBOX_OPEN: {
			struct batch		*b = imsg.data;

			IMSG_SIZE_CHECK(b);
d104 1
a104 2
			if ((b = batch_by_id(env, b->id)) == NULL)
				fatalx("mda: internal inconsistency");
d106 3
a108 10
			/* parent ensures mboxfd is valid */
			if (imsg.fd == -1)
				fatalx("mda: mboxfd pass failure");

			/* got user's mbox fd */
			if ((b->mboxfp = fdopen(imsg.fd, "w")) == NULL) {
				log_warn("mda: fdopen");
				mda_done(env, b);
				break;
			}
d110 2
a111 10
			/* 
			 * From now on, delivery session must be deinited in
			 * the parent process as well as in mda.
			 */
			b->cleanup_parent = 1;

			/* get message content fd */
			imsg_compose_event(env->sc_ievs[PROC_PARENT],
			    IMSG_PARENT_MESSAGE_OPEN, 0, 0, -1, b,
			    sizeof(*b));
d115 5
a119 2
		case IMSG_PARENT_MESSAGE_OPEN: {
			struct batch	*b = imsg.data;
d121 1
a121 1
			IMSG_SIZE_CHECK(b);
d123 35
a157 6
			if ((b = batch_by_id(env, b->id)) == NULL)
				fatalx("mda: internal inconsistency");

			if (imsg.fd == -1) {
				mda_done(env, b);
				break;
d160 15
a174 4
			if ((b->datafp = fdopen(imsg.fd, "r")) == NULL) {
				log_warn("mda: fdopen");
				mda_done(env, b);
				break;
d177 9
a185 4
			/* got message content, copy it to mbox */
			mda_store(b);
			break;
		}
d187 34
a220 12
		case IMSG_MDA_FINALIZE: {
			struct batch		*b = imsg.data;
			enum message_status	 status;

			IMSG_SIZE_CHECK(b);

			status = b->message.status;
			if ((b = batch_by_id(env, b->id)) == NULL)
				fatalx("mda: internal inconsistency");
			b->message.status = status;

			mda_done(env, b);
d233 1
d324 8
a331 8
		case IMSG_BATCH_CREATE: {
			struct batch	*req = imsg.data;
			struct batch	*b;

			IMSG_SIZE_CHECK(req);

			/* runner opens delivery session */
			if ((b = malloc(sizeof(*b))) == NULL)
d333 19
a351 8
			*b = *req;
			msgbuf_init(&b->w);
			b->env = env;
			b->mboxfp = NULL;
			b->datafp = NULL;
			SPLAY_INSERT(batchtree, &env->batch_queue, b);
			break;
		}
d353 9
a361 12
		case IMSG_BATCH_APPEND: {
			struct message	*append = imsg.data;
			struct batch	*b;

			IMSG_SIZE_CHECK(append);

			/* runner submits the message to deliver */
			if ((b = batch_by_id(env, append->batch_id)) == NULL)
				fatalx("mda: internal inconsistency");
			if (b->message.message_id[0])
				fatal("mda: runner submitted extra msg");
			b->message = *append;
d363 7
a369 4
			/* safe default */
			b->message.status = S_MESSAGE_TEMPFAILURE;
			break;
		}
d371 8
a378 2
		case IMSG_BATCH_CLOSE: {
			struct batch	*b = imsg.data;
d380 3
a382 1
			IMSG_SIZE_CHECK(b);
a383 4
			/* runner finished opening delivery session;
			 * request user's mbox fd */
			if ((b = batch_by_id(env, b->id)) == NULL)
				fatalx("mda: internal inconsistency");
d385 2
a386 2
			    IMSG_PARENT_MAILBOX_OPEN, 0, 0, -1, b,
			    sizeof(*b));
d464 1
a464 1
	SPLAY_INIT(&env->batch_queue);
d486 1
a486 1
mda_store(struct batch *b)
d490 1
a490 1
	int		 ch, len;
d492 1
a492 1
	if (b->message.sender.user[0] && b->message.sender.domain[0])
d495 2
a496 4
		    b->message.sender.user,
		    b->message.sender.domain,
		    b->message.session_rcpt.user,
		    b->message.session_rcpt.domain);
d499 1
a499 2
		    b->message.session_rcpt.user,
		    b->message.session_rcpt.domain);
d504 8
a511 22
	if (b->message.recipient.rule.r_action == A_MAILDIR) {
		fprintf(b->mboxfp, "%s", p);
		while ((ch = fgetc(b->datafp)) != EOF)
			if (fputc(ch, b->mboxfp) == EOF)
				break;
		if (ferror(b->datafp))
			fatal("mda_store: cannot read message in queue");
		if (fflush(b->mboxfp) || ferror(b->mboxfp))
			fatal("mda_store: cannot write to file");
		mda_store_done(b);
	} else {
		b->w.fd = fileno(b->mboxfp);
		session_socket_blockmode(b->w.fd, BM_NONBLOCK);
		if ((buf = buf_open(len)) == NULL)
			fatal(NULL);
		if (buf_add(buf, p, len) < 0)
			fatal(NULL);
		buf_close(&b->w, buf);
		event_set(&b->ev, b->w.fd, EV_WRITE, mda_event, b);
		event_add(&b->ev, NULL);
	}

d516 1
a516 1
mda_event(int fd, short event, void *p)
d518 4
a521 4
	char		 tmp[16384];
	struct batch	*b = p;
	struct buf	*buf;
	size_t		 len;
d523 2
a524 2
	if (b->w.queued == 0) {
		if ((buf = buf_dynamic(0, sizeof(tmp))) == NULL)
d526 6
a531 5
		len = fread(tmp, 1, sizeof(tmp), b->datafp);
		if (ferror(b->datafp))
			fatal("mda_event: fread failed");
		if (feof(b->datafp) && len == 0) {
			mda_store_done(b);
d536 1
a536 1
		buf_close(&b->w, buf);
d539 3
a541 5
	if (buf_write(&b->w) < 0) {
		/* XXX: if $? is zero, message is considered delivered despite
		 * write error. */
		log_warn("mda_event: write failed");
		mda_store_done(b);
d545 2
a546 2
	event_set(&b->ev, fd, EV_WRITE, mda_event, b);
	event_add(&b->ev, NULL);
d549 2
a550 2
void
mda_store_done(struct batch *b)
d552 1
a552 2
	fclose(b->datafp);
	b->datafp = NULL;
d554 3
a556 11
	/* closing mboxfd will trigger EOF in forked mda */
	fsync(fileno(b->mboxfp));
	fclose(b->mboxfp);
	b->mboxfp = NULL;

	/* ... unless it is maildir, in which case we need to
	 * "trigger EOF" differently */
	if (b->message.recipient.rule.r_action == A_MAILDIR)
		imsg_compose_event(b->env->sc_ievs[PROC_PARENT],
		    IMSG_PARENT_MAILDIR_RENAME, 0, 0, -1, b,
		    sizeof(*b));
d558 2
a559 3
	/* Waiting for IMSG_MDA_FINALIZE... */
	b->cleanup_parent = 0;
}
d561 1
a561 80
void
mda_done(struct smtpd *env, struct batch *b)
{
	if (b->cleanup_parent) {
		/*
		 * Error has occured while both parent and mda maintain some
		 * state for this delivery session.  Need to deinit both.
		 * Deinit parent first.
		 */

		if (b->message.recipient.rule.r_action == A_MAILDIR) {
			/*
			 * In case of maildir, deiniting parent's state consists
			 * of removing the file in tmp.
			 */
			imsg_compose_event(env->sc_ievs[PROC_PARENT],
			    IMSG_PARENT_MAILDIR_FAIL, 0, 0, -1, b,
			    sizeof(*b));
		} else {
			/*
			 * In all other cases, ie. mbox and external, deiniting
			 * parent's state consists of killing its child, and
			 * freeing associated struct child.
			 *
			 * Requesting that parent does this cleanup involves
			 * racing issues.  The race-free way is to simply wait.
			 * Eventually, child timeout in parent will be hit.
			 */
		}

		/*
		 * Either way, parent will eventually send IMSG_MDA_FINALIZE.
		 * Then, the mda deinit will happen.
		 */
		b->cleanup_parent = 0;
	} else {
		/*
		 * Deinit mda.
		 */

		/* update runner (currently: via queue) */
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_MESSAGE_UPDATE, 0, 0, -1,
		    &b->message, sizeof(b->message));

		imsg_compose_event(env->sc_ievs[PROC_RUNNER],
		    IMSG_BATCH_DONE, 0, 0, -1, NULL, 0);

		/* log status */
		if (b->message.recipient.rule.r_action != A_MAILDIR &&
		    b->message.recipient.rule.r_action != A_MBOX) {
			log_info("%s: to=<%s@@%s>, delay=%d, stat=%s",
			    b->message.message_id,
			    b->message.session_rcpt.user,
			    b->message.session_rcpt.domain,
			    time(NULL) - b->message.creation,
			    b->message.status & S_MESSAGE_PERMFAILURE ? "MdaPermError" :
			    b->message.status & S_MESSAGE_TEMPFAILURE ? "MdaTempError" :
			    "Sent");
		}
		else {
			log_info("%s: to=<%s@@%s>, delay=%d, stat=%s",
			    b->message.message_id,
			    b->message.recipient.user,
			    b->message.recipient.domain,
			    time(NULL) - b->message.creation,
			    b->message.status & S_MESSAGE_PERMFAILURE ? "MdaPermError" :
			    b->message.status & S_MESSAGE_TEMPFAILURE ? "MdaTempError" :
			    "Sent");
		}

		/* deallocate resources */
		SPLAY_REMOVE(batchtree, &env->batch_queue, b);
		if (b->mboxfp)
			fclose(b->mboxfp);
		if (b->datafp)
			fclose(b->datafp);
		msgbuf_clear(&b->w);
		free(b);
	}
@


1.36
log
@mda_event() assumed the mbox fp to be a file when it could be a pipe, do
not fatal on read/write errors otherwise a broken pipe in an external mda
will bring smtpd down.

mda_store() assumed write would succeed and fatal otherwise, change code
so that EINTR/EAGAIN trigger a new write while other errors gracefully
return causing the message to be rescheduled later.

these two prevent a fatal() from being hit when execution of a filter or
external mda fails (bug experienced and fix verified by nicm@@)

while at it, fix a small bug where logs would not display the recipient
when mail went through a ~/.forward / aliases expansion.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.35 2010/01/03 14:37:37 chl Exp $	*/
d279 1
d419 2
a420 2
	int		 ch, ret, nbytes;
	socklen_t	 len;
d424 1
a424 1
		ret = asprintf(&p, "Return-Path: %s@@%s\nDelivered-To: %s@@%s\n",
d430 1
a430 1
		ret = asprintf(&p, "Delivered-To: %s@@%s\n",
d434 1
a434 1
	if (ret == -1)
d448 3
a450 6
		session_socket_blockmode(fileno(b->mboxfp), BM_NONBLOCK);
		len = sizeof(b->rbufsz);
		if (getsockopt(fileno(b->mboxfp), SOL_SOCKET, SO_SNDLOWAT,
		    &b->rbufsz, &len) == -1)
			fatal("mda_store: getsockopt");
		if ((b->rbuf = malloc(b->rbufsz)) == NULL)
d452 4
a455 16

		do {
			nbytes = write(fileno(b->mboxfp), p, ret);
			if (nbytes == -1 &&
			    (errno != EINTR && errno != EAGAIN))
				break;
		} while (nbytes == -1);

		if (nbytes == -1) {
			log_warn("mda_store: write");
			fclose(b->mboxfp);
			return;
		}

		event_set(&b->ev, fileno(b->mboxfp), EV_WRITE|EV_PERSIST,
		    mda_event, b);
d465 1
d467 1
a468 1
	int		 error;
d470 13
a482 5
	error = 0;
	len = fread(b->rbuf, 1, b->rbufsz, b->datafp);
	if (ferror(b->datafp)) {
		log_warnx("mda_event: read failure");
		error = 1;
d485 6
a490 3
	if (write(fd, b->rbuf, len) != (ssize_t)len) {
		log_warnx("mda_event: write failure");
		error = 1;
d493 2
a494 4
	if (feof(b->datafp) || error) {
		event_del(&b->ev);
		mda_store_done(b);
	}
d596 1
a596 1
		free(b->rbuf);
@


1.35
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.34 2009/12/14 16:44:14 jacekm Exp $	*/
d27 1
d418 1
a418 1
	int		 ch, ret;
d454 14
a467 2
		if (write(fileno(b->mboxfp), p, ret) != ret)
			fatal("mda_store: write");
d481 1
d483 1
d485 11
a495 5
	if (ferror(b->datafp))
		fatal("mda_event: fread");
	if (write(fd, b->rbuf, len) != (ssize_t)len)
		fatal("mda_event: write");
	if (feof(b->datafp)) {
d572 21
a592 8
		log_info("%s: to=<%s@@%s>, delay=%d, stat=%s",
		    b->message.message_id,
		    b->message.recipient.user,
		    b->message.recipient.domain,
		    time(NULL) - b->message.creation,
		    b->message.status & S_MESSAGE_PERMFAILURE ? "MdaPermError" :
		    b->message.status & S_MESSAGE_TEMPFAILURE ? "MdaTempError" :
		    "Sent");
@


1.34
log
@Impose sessions limit on the delivery sessions (mta and mda).
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.33 2009/12/14 13:17:51 jacekm Exp $	*/
d169 9
@


1.33
log
@Do non-blocking I/O when delivering locally over a pipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.32 2009/11/13 12:01:54 jacekm Exp $	*/
d537 3
@


1.32
log
@Add logging of failed local deliveries.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.31 2009/11/11 10:04:05 chl Exp $	*/
d45 3
a47 1
int		mda_store(struct batch *);
d150 1
a150 22
			if (! mda_store(b)) {
				env->stats->mda.write_error++;
				mda_done(env, b);
				break;
			}
			fclose(b->datafp);
			b->datafp = NULL;

			/* closing mboxfd will trigger EOF in forked mda */
			fsync(fileno(b->mboxfp));
			fclose(b->mboxfp);
			b->mboxfp = NULL;

			/* ... unless it is maildir, in which case we need to
			 * "trigger EOF" differently */
			if (b->message.recipient.rule.r_action == A_MAILDIR)
				imsg_compose_event(env->sc_ievs[PROC_PARENT],
				    IMSG_PARENT_MAILDIR_RENAME, 0, 0, -1, b,
				    sizeof(*b));
			
			/* Waiting for IMSG_MDA_FINALIZE... */
			b->cleanup_parent = 0;
d404 1
a404 1
int
d407 7
a413 9
	FILE	 *src = b->datafp;
	FILE	 *dst = b->mboxfp;
	int	  ch;
 
	/* add Return-Path to preserve envelope sender */
	/* XXX: remove user provided Return-Path, if any */
	if (b->message.sender.user[0] &&
	    b->message.sender.domain[0]) {
		fprintf(dst, "Return-Path: %s@@%s\n",
d415 53
a467 1
		    b->message.sender.domain);
d469 22
a490 15
	 
	/* add Delivered-To to help loop detection */
	fprintf(dst, "Delivered-To: %s@@%s\n",
	    b->message.session_rcpt.user,
	    b->message.session_rcpt.domain);

	/* write message data */
	/* XXX: it blocks in !mdir case */
	while ((ch = fgetc(src)) != EOF)
		if (fputc(ch, dst) == EOF)
			break;
	if (ferror(src) || fflush(dst) || ferror(dst))
		return 0;
	
	return 1;
d554 1
@


1.31
log
@add missing headers needed by time()

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.30 2009/09/23 09:40:39 jacekm Exp $	*/
d501 8
a508 10
		if (b->message.status & S_MESSAGE_PERMFAILURE)
			log_debug("mda: permanent failure");
		else if (b->message.status & S_MESSAGE_TEMPFAILURE)
			log_debug("mda: temporary failure");
		else
			log_info("%s: to=<%s@@%s>, delay=%d, stat=Sent",
			    b->message.message_uid,
			    b->message.recipient.user,
			    b->message.recipient.domain,
			    time(NULL) - b->message.creation);
@


1.30
log
@Plug memleak.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.29 2009/09/04 16:28:42 jacekm Exp $	*/
d33 1
@


1.29
log
@Prepend Return-Path.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.28 2009/09/04 11:49:23 jacekm Exp $	*/
d108 5
a112 1
			b->mboxfd = imsg.fd;
d140 5
a144 1
			b->datafd = imsg.fd;
d152 2
a153 2
			close(b->datafd);
			b->datafd = -1;
d156 3
a158 3
			fsync(b->mboxfd);
			close(b->mboxfd);
			b->mboxfd = -1;
d288 2
a289 2
			b->mboxfd = -1;
			b->datafd = -1;
d425 2
a426 2
	FILE	 *dst;
	FILE	 *src;
a428 5
	if ((dst = fdopen(b->mboxfd, "w")) == NULL)
		return 0;
	if ((src = fdopen(b->datafd, "r")) == NULL)
		return 0;

d513 4
a516 2
		close(b->mboxfd);
		close(b->datafd);
@


1.28
log
@Major mda update:
- Fix: check external mda / mail.local exit code.
- Fix: check maildir rename(2) return code.
- Fix: check read(2) and write(2) return codes.
- Fix: in parent, batchp->env was not set to the env of the current process.
- Fix: clean file in tmp if maildir delivery fails.
- Fix: mark message as temporarily failed upon start, unmark upon sucessful
delivery. (safe default)
- Fix: kill all message drops, aka. PERMFAILUREs, with one exception: when the
local user no longer exists.
- Cleanup: store.c is merged with its only user, mda.c
- Feature: in parent, child_add now returns pointer to the new child struct.
This is used to store and later access child->mda_batch member in order to
associate children with their batches.
- Feature: in parent, external mda / mail.local will timeout after 5 minutes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.27 2009/09/03 08:19:13 jacekm Exp $	*/
d425 9
@


1.27
log
@imsg_get sets errno so use fatal instead of fatalx.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.26 2009/09/02 12:47:06 jacekm Exp $	*/
d6 1
d44 2
a45 1
void		mda_remove_message(struct smtpd *, struct batch *, struct message *x);
d95 20
a114 26
		case IMSG_MDA_MAILBOX_FILE: {
			struct batch	*batchp = imsg.data;
			struct session	*s;
			struct message	*messagep;
			enum message_status status;

			IMSG_SIZE_CHECK(batchp);

			messagep = &batchp->message;
			status = messagep->status;

			batchp = batch_by_id(env, batchp->id);
			if (batchp == NULL)
				fatalx("mda_dispatch_parent: internal inconsistency.");
			s = batchp->sessionp;

			messagep = message_by_id(env, batchp, messagep->id);
			if (messagep == NULL)
				fatalx("mda_dispatch_parent: internal inconsistency.");
			messagep->status = status;

			s->mboxfd = imsg.fd;
			if (s->mboxfd == -1) {
				mda_remove_message(env, batchp, messagep);
				break;
			}
d116 1
a116 1
			batchp->message = *messagep;
d118 2
a119 2
			    IMSG_PARENT_MESSAGE_OPEN, 0, 0, -1, batchp,
			    sizeof(struct batch));
d123 10
a132 26
		case IMSG_MDA_MESSAGE_FILE: {
			struct batch	*batchp = imsg.data;
			struct session	*s;
			struct message	*messagep;
			enum message_status status;

			IMSG_SIZE_CHECK(batchp);

			messagep = &batchp->message;
			status = messagep->status;

			batchp = batch_by_id(env, batchp->id);
			if (batchp == NULL)
				fatalx("mda_dispatch_parent: internal inconsistency.");
			s = batchp->sessionp;

			messagep = message_by_id(env, batchp, messagep->id);
			if (messagep == NULL)
				fatalx("mda_dispatch_parent: internal inconsistency.");
			messagep->status = status;

			s->messagefd = imsg.fd;
			if (s->messagefd == -1) {
				if (s->mboxfd != -1)
					close(s->mboxfd);
				mda_remove_message(env, batchp, messagep);
d136 4
a139 7
			if (store_message(batchp, messagep)) {
				if (batchp->message.recipient.rule.r_action == A_MAILDIR)
					imsg_compose_event(env->sc_ievs[PROC_PARENT],
					    IMSG_PARENT_MAILBOX_RENAME, 0, 0, -1, batchp,
					    sizeof(struct batch));
			} else {
				/* XXX: remove junk from tmp/ in mdir case */
d141 2
a142 1
				messagep->status |= S_MESSAGE_TEMPFAILURE;
d144 19
d164 10
a173 4
			if (s->mboxfd != -1)
				close(s->mboxfd);
			if (s->messagefd != -1)
				close(s->messagefd);
d175 1
a175 1
			mda_remove_message(env, batchp, messagep);
d178 1
d270 2
a271 3
			struct batch *request = imsg.data;
			struct batch *batchp;
			struct session *s;
d273 1
a273 1
			IMSG_SIZE_CHECK(request);
d275 2
a276 2
			/* create a client session */
			if ((s = calloc(1, sizeof(*s))) == NULL)
d278 5
a282 18
			s->s_state = S_INIT;
			s->s_env = env;
			s->s_id = queue_generate_id();
			SPLAY_INSERT(sessiontree, &s->s_env->sc_sessions, s);

			/* create the batch for this session */
			batchp = calloc(1, sizeof (struct batch));
			if (batchp == NULL)
				fatal("mda_dispatch_runner: calloc");

			*batchp = *request;
			batchp->env = env;
			batchp->sessionp = s;

			s->batch = batchp;

			TAILQ_INIT(&batchp->messages);
			SPLAY_INSERT(batchtree, &env->batch_queue, batchp);
d288 1
a288 2
			struct message	*messagep;
			struct batch	*batchp;
d292 6
a297 5
			messagep = calloc(1, sizeof (struct message));
			if (messagep == NULL)
				fatal("mda_dispatch_runner: calloc");

			*messagep = *append;
d299 2
a300 5
			batchp = batch_by_id(env, messagep->batch_id);
			if (batchp == NULL)
				fatalx("mda_dispatch_runner: internal inconsistency.");

 			TAILQ_INSERT_TAIL(&batchp->messages, messagep, entry);
d305 11
a315 20
			struct batch	*batchp = imsg.data;
			struct session	*s;
			struct batch	 lookup;
			struct message	*messagep;

			IMSG_SIZE_CHECK(batchp);

			batchp = batch_by_id(env, batchp->id);
			if (batchp == NULL)
				fatalx("mda_dispatch_runner: internal inconsistency.");

			s = batchp->sessionp;

			lookup = *batchp;
			TAILQ_FOREACH(messagep, &batchp->messages, entry) {
				lookup.message = *messagep;
				imsg_compose_event(env->sc_ievs[PROC_PARENT],
				    IMSG_PARENT_MAILBOX_OPEN, 0, 0, -1, &lookup,
				    sizeof(struct batch));
			}
d414 28
d443 1
a443 1
mda_remove_message(struct smtpd *env, struct batch *batchp, struct message *messagep)
d445 59
a503 10
	imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_UPDATE, 0, 0,
	    -1, messagep, sizeof (struct message));

	if ((messagep->status & S_MESSAGE_TEMPFAILURE) == 0 &&
	    (messagep->status & S_MESSAGE_PERMFAILURE) == 0) {
		log_info("%s: to=<%s@@%s>, delay=%d, stat=Sent",
		    messagep->message_uid,
		    messagep->recipient.user,
		    messagep->recipient.domain,
		    time(NULL) - messagep->creation);
a504 5

	SPLAY_REMOVE(sessiontree, &env->sc_sessions, batchp->sessionp);
	free(batchp->sessionp);

	queue_remove_batch_message(env, batchp, messagep);
@


1.26
log
@Include mbox write errors in "show stats".  Suggested by gilles.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.25 2009/09/02 11:11:10 jacekm Exp $	*/
d88 1
a88 1
			fatalx("mda_dispatch_parent: imsg_get error");
d215 1
a215 1
			fatalx("mda_dispatch_queue: imsg_get error");
d260 1
a260 1
			fatalx("mda_dispatch_runner: imsg_get error");
@


1.25
log
@Do not lose mail when write(2) to mbox fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.24 2009/08/06 13:40:45 gilles Exp $	*/
d163 1
@


1.24
log
@This commit reworks the entire mailer daemon support to actually make it
work for real. As an added bonus, it simplifies it, makes it follow the
same code path as regular messages and kills quite some code from mta,
mda and store. There's still some work needed but the most painful part
is behind us now ;)

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.23 2009/06/07 05:56:25 eric Exp $	*/
d161 3
d441 2
a442 2
	if ((batchp->message.status & S_MESSAGE_TEMPFAILURE) == 0 &&
	    (batchp->message.status & S_MESSAGE_PERMFAILURE) == 0) {
@


1.23
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.22 2009/06/06 04:14:21 pyr Exp $	*/
a131 1
			int (*store)(struct batch *, struct message *) = store_write_message;
d156 1
a156 6
			/* If batch is a daemon message, override the default store function */
			if (batchp->type & T_DAEMON_BATCH) {
				store = store_write_daemon;
			}

			if (store_message(batchp, messagep, store)) {
@


1.22
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.21 2009/06/05 20:43:57 pyr Exp $	*/
d114 1
a114 1
			s->mboxfd = imsg_get_fd(ibuf);
d149 1
a149 1
			s->messagefd = imsg_get_fd(ibuf);
@


1.21
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.20 2009/06/03 22:04:15 jacekm Exp $	*/
d62 1
d67 2
a68 1
	ibuf = env->sc_ibufs[PROC_PARENT];
d75 1
a75 1
			event_del(&ibuf->ev);
d121 1
a121 1
			imsg_compose_event(env->sc_ibufs[PROC_PARENT],
d164 1
a164 1
					imsg_compose_event(env->sc_ibufs[PROC_PARENT],
d184 1
a184 1
	imsg_event_add(ibuf);
d191 1
d196 2
a197 1
	ibuf = env->sc_ibufs[PROC_QUEUE];
d204 1
a204 1
			event_del(&ibuf->ev);
d229 1
a229 1
	imsg_event_add(ibuf);
d236 1
d241 2
a242 1
	ibuf = env->sc_ibufs[PROC_RUNNER];
d249 1
a249 1
			event_del(&ibuf->ev);
d336 1
a336 1
				imsg_compose_event(env->sc_ibufs[PROC_PARENT],
d349 1
a349 1
	imsg_event_add(ibuf);
d441 1
a441 1
	imsg_compose_event(env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_UPDATE, 0, 0,
@


1.20
log
@simplify struct batch; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.19 2009/06/01 13:20:56 jacekm Exp $	*/
d112 1
a112 1
			s->mboxfd = imsg_get_fd(ibuf, &imsg);
d119 1
a119 1
			imsg_compose(env->sc_ibufs[PROC_PARENT],
d147 1
a147 1
			s->messagefd = imsg_get_fd(ibuf, &imsg);
d162 1
a162 1
					imsg_compose(env->sc_ibufs[PROC_PARENT],
d330 1
a330 1
				imsg_compose(env->sc_ibufs[PROC_PARENT],
d435 1
a435 1
	imsg_compose(env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_MESSAGE_UPDATE, 0, 0,
@


1.19
log
@Fix EV_READ/EV_WRITE testing inside IMSG handlers. Based on similar change
to the routing daemons by claudio@@; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.18 2009/05/24 14:38:56 jacekm Exp $	*/
a281 1
			batchp->session_id = s->s_id;
a282 1
			batchp->flags = 0;
a308 7
			batchp->session_ss = messagep->session_ss;
			strlcpy(batchp->session_hostname,
			    messagep->session_hostname,
			    sizeof(batchp->session_hostname));
			strlcpy(batchp->session_helo, messagep->session_helo,
			    sizeof(batchp->session_helo));

a324 1
			batchp->flags |= F_BATCH_COMPLETE;
@


1.18
log
@Parent process forks 3 types of processes, track them all in a single tree
using newly introduced child struct.

Manage process titles centrally in struct smtpd.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.17 2009/05/19 11:24:24 jacekm Exp $	*/
d67 2
a68 2
	switch (event) {
	case EV_READ:
d77 3
a79 2
		break;
	case EV_WRITE:
a81 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d194 2
a195 2
	switch (event) {
	case EV_READ:
d204 3
a206 2
		break;
	case EV_WRITE:
a208 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d237 2
a238 2
	switch (event) {
	case EV_READ:
d247 3
a249 2
		break;
	case EV_WRITE:
a251 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
@


1.17
log
@Verify the amount of IMSG payload is exactly as expected; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.16 2009/05/14 15:05:12 eric Exp $	*/
a419 1
	setproctitle("mail delivery agent");
d421 1
@


1.16
log
@use the nitems() macro where appropriate

ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.15 2009/04/28 21:27:25 jacekm Exp $	*/
d95 1
a96 1
			struct batch	*batchp;
d100 2
a101 1
			batchp = (struct batch *)imsg.data;
d129 1
a130 1
			struct batch	*batchp;
d135 2
a136 1
			batchp = (struct batch *)imsg.data;
d271 2
d274 2
a275 1
			struct batch *batchp;
d290 1
a290 1
			*batchp = *(struct batch *)imsg.data;
d304 2
d307 2
a308 1
			struct message	*messagep;
d314 1
a314 1
			*messagep = *(struct message *)imsg.data;
d332 3
a334 3
			struct batch		*batchp;
			struct session		*s;
			struct batch	lookup;
d337 2
a338 1
			batchp = (struct batch *)imsg.data;
@


1.15
log
@let mta, mda, and mfa become idle - no functional change; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.14 2009/04/21 14:37:32 eric Exp $	*/
d432 2
a433 2
	config_pipes(env, peers, 3);
	config_peers(env, peers, 3);
@


1.14
log
@correct some fatal(x) calls and error strings

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.13 2009/03/29 14:18:20 jacekm Exp $	*/
a42 1
void		mda_timeout(int, short, void *);
a366 6
	struct timeval	 tv;

	evtimer_set(&env->sc_ev, mda_timeout, env);
	tv.tv_sec = 3;
	tv.tv_usec = 0;
	evtimer_add(&env->sc_ev, &tv);
a371 12
	evtimer_del(&env->sc_ev);
}

void
mda_timeout(int fd, short event, void *p)
{
	struct smtpd		*env = p;
	struct timeval		 tv;

	tv.tv_sec = 3;
	tv.tv_usec = 0;
	evtimer_add(&env->sc_ev, &tv);
@


1.13
log
@turn some log_debugs into log_warns or even fatals; "looks ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.12 2009/03/23 08:25:15 tobias Exp $	*/
d90 1
a90 1
			fatal("mda_dispatch_parent: imsg_read error");
d218 1
a218 1
			fatal("parent_dispatch_queue: imsg_read error");
d264 1
a264 1
			fatal("parent_dispatch_runner: imsg_read error");
@


1.12
log
@Fixed a leaking of a fd each time a file is delivered to a mbox, which
was introduced in revision 1.7.

ok and log message by gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.11 2009/03/15 19:15:25 gilles Exp $	*/
d178 1
a178 1
			log_debug("mda_dispatch_parent: unexpected imsg %d",
d180 1
a180 1
			break;
d224 1
a224 1
			log_debug("parent_dispatch_queue: unexpected imsg %d",
d226 1
a226 1
			break;
d348 1
a348 1
			log_debug("parent_dispatch_runner: unexpected imsg %d",
d350 1
a350 1
			break;
@


1.11
log
@the mda process no longer uses struct batch as its central structure to
deal with deliveries, it now uses struct session just like mta and smtp
processes. we now keep the mbox and message descriptors in the session,
saving space in struct message which is now as small as we can make it.
While at it, plugged a memory leak and did some cosmethic changes

This was the last planned change to our struct message which means that
later changes will no longer require a queue flush before rebuild.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.10 2009/03/10 22:33:26 jacekm Exp $	*/
d168 1
a168 1
			else
@


1.10
log
@implement basic logging, needs more work; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.9 2009/02/22 19:07:33 chl Exp $	*/
d31 1
d96 1
d108 1
d115 2
a116 2
			messagep->mboxfd = imsg_get_fd(ibuf, &imsg);
			if (messagep->mboxfd == -1) {
d129 1
d142 1
d149 4
a152 4
			messagep->messagefd = imsg_get_fd(ibuf, &imsg);
			if (messagep->messagefd == -1) {
				if (messagep->mboxfd != -1)
					close(messagep->mboxfd);
d169 4
a172 4
			if (messagep->mboxfd != -1)
				close(messagep->mboxfd);
			if (messagep->messagefd != -1)
				close(messagep->messagefd);
d270 10
a279 1
			struct batch	*batchp;
d281 1
d284 2
a285 1
				fatal("calloc");
d287 1
d290 3
d305 1
a305 1
				fatal("calloc");
d308 1
d313 8
a320 1
			TAILQ_INSERT_TAIL(&batchp->messages, messagep, entry);
d325 2
a327 1
			struct batch	*batchp;
d330 2
a331 2
			lookup = *(struct batch *)imsg.data;
			batchp = batch_by_id(env, lookup.id);
d335 3
a344 1

d475 3
@


1.9
log
@add missing headers

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.8 2009/02/15 10:32:23 jacekm Exp $	*/
d435 9
@


1.8
log
@New config.c that allows for process cloning. Done by pyr@@ for
relayd at n2k9, and adapted to smtpd; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.7 2009/01/27 22:48:29 gilles Exp $	*/
d28 1
@


1.7
log
@first bricks of enqueue code which allows smtpctl to submit mail to queue
without "talking" smtp to listeners. currently, a big part of the server
side code is done (and requires a cleanup), next step is to get it usable
properly from a mail user agent.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.6 2009/01/01 16:15:47 jacekm Exp $	*/
d419 1
@


1.6
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.5 2008/12/13 23:19:34 jacekm Exp $	*/
d162 1
a162 1

@


1.5
log
@IMSG_* namespace cleanup.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.4 2008/12/05 19:09:59 gilles Exp $	*/
a24 1
#include <sys/stat.h>
a25 1
#include <err.h>
a27 1
#include <signal.h>
a29 1
#include <string.h>
@


1.4
log
@- more err/errx -> fatal/fatalx, warn/warnx -> log_warn/log_warnx
	contains bits based on an old diff from Jacek Masiulaniec and
	other bits from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.3 2008/12/05 02:51:32 gilles Exp $	*/
d267 1
a267 1
		case IMSG_CREATE_BATCH: {
@


1.3
log
@- last part of the new queue code: the runner process (unprivileged and
	chrooted) is now in charge of doing the scheduling of deliveries,
	and the dispatching of messages to MDA and MTA. queue process only
	does inserts/updates/removals from the queue and can no longer be
	so busy that it delays answers to imsg from smtp server.
@
text
@d1 1
a1 1
/*	$OpenBSD: mda.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d92 1
a92 1
			fatal("parent_dispatch_mda: imsg_read error");
d108 1
a108 1
				errx(1, "%s: internal inconsistency.", __func__);
d112 1
a112 1
				errx(1, "%s: internal inconsistency.", __func__);
d140 1
a140 1
				errx(1, "%s: internal inconsistency.", __func__);
d144 1
a144 1
				errx(1, "%s: internal inconsistency.", __func__);
d176 1
a176 1
			log_debug("parent_dispatch_mda: unexpected imsg %d",
d293 1
a293 1
				errx(1, "%s: internal inconsistency.", __func__);
d307 1
a307 1
				errx(1, "%s: internal inconsistency.", __func__);
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
d221 46
a318 1

d320 1
a320 1
			log_debug("parent_dispatch_queue: unexpected imsg %d",
d376 2
a377 1
		{ PROC_QUEUE,	mda_dispatch_queue }
d423 1
a423 1
	config_peers(env, peers, 2);
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

