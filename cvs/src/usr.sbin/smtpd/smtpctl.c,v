head	1.154;
access;
symbols
	OPENBSD_6_2:1.154.0.2
	OPENBSD_6_2_BASE:1.154
	OPENBSD_6_1:1.152.0.4
	OPENBSD_6_1_BASE:1.152
	OPENBSD_6_0:1.149.0.4
	OPENBSD_6_0_BASE:1.149
	OPENBSD_5_9:1.147.0.2
	OPENBSD_5_9_BASE:1.147
	OPENBSD_5_8:1.125.0.6
	OPENBSD_5_8_BASE:1.125
	OPENBSD_5_7:1.125.0.2
	OPENBSD_5_7_BASE:1.125
	OPENBSD_5_6:1.124.0.4
	OPENBSD_5_6_BASE:1.124
	OPENBSD_5_5:1.116.0.2
	OPENBSD_5_5_BASE:1.116
	OPENBSD_5_4:1.108.0.2
	OPENBSD_5_4_BASE:1.108
	OPENBSD_5_3:1.101.0.2
	OPENBSD_5_3_BASE:1.101
	OPENBSD_5_2:1.83.0.2
	OPENBSD_5_2_BASE:1.83
	OPENBSD_5_1_BASE:1.78
	OPENBSD_5_1:1.78.0.2
	OPENBSD_5_0:1.61.0.2
	OPENBSD_5_0_BASE:1.61
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.31.0.4
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15;
locks; strict;
comment	@ * @;


1.154
date	2017.07.27.18.48.30;	author sunil;	state Exp;
branches;
next	1.153;
commitid	pWVSSHgiJqkUHVKn;

1.153
date	2017.05.19.19.56.42;	author eric;	state Exp;
branches;
next	1.152;
commitid	3yKE51d7YMOnBx0M;

1.152
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.151;
commitid	jM4eOMW1AJwdfKrr;

1.151
date	2016.09.04.09.33.49;	author eric;	state Exp;
branches;
next	1.150;
commitid	k6ATrLH73tETES8n;

1.150
date	2016.09.03.16.06.26;	author eric;	state Exp;
branches;
next	1.149;
commitid	KHEgnvbdOZ4TgZyl;

1.149
date	2016.04.29.08.55.08;	author eric;	state Exp;
branches;
next	1.148;
commitid	oxMoHf5ouZJ0D4QU;

1.148
date	2016.03.17.19.40.43;	author krw;	state Exp;
branches;
next	1.147;
commitid	aCmYZrmRmWHLuztW;

1.147
date	2016.02.12.03.11.16;	author sunil;	state Exp;
branches;
next	1.146;
commitid	QRjpFVsr3g0wCTYa;

1.146
date	2016.02.09.10.38.02;	author gilles;	state Exp;
branches;
next	1.145;
commitid	2amcmXMJq8TOe8lq;

1.145
date	2016.02.03.08.03.21;	author gilles;	state Exp;
branches;
next	1.144;
commitid	XxS0r3uGjwajuXVI;

1.144
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.143;
commitid	ZxnqOQqX6IeYI9jW;

1.143
date	2015.12.22.21.50.22;	author gilles;	state Exp;
branches;
next	1.142;
commitid	KkThm9ciqzsObo2s;

1.142
date	2015.12.22.15.59.10;	author sunil;	state Exp;
branches;
next	1.141;
commitid	MdhvgPKjnEGyRbVw;

1.141
date	2015.12.21.11.20.07;	author sunil;	state Exp;
branches;
next	1.140;
commitid	oexZJQn4LLZ7tFgb;

1.140
date	2015.12.11.07.30.24;	author gilles;	state Exp;
branches;
next	1.139;
commitid	8OA7358Hg7R449vE;

1.139
date	2015.12.10.07.49.58;	author sunil;	state Exp;
branches;
next	1.138;
commitid	qsBFUWovDNs63G3N;

1.138
date	2015.12.07.12.29.19;	author sunil;	state Exp;
branches;
next	1.137;
commitid	NjgUX1eM1Q27CUqm;

1.137
date	2015.12.05.13.14.21;	author claudio;	state Exp;
branches;
next	1.136;
commitid	ZUSyGL2qGrdiWU8r;

1.136
date	2015.11.05.09.14.31;	author sunil;	state Exp;
branches;
next	1.135;
commitid	3vo6L6sIqhuEjLcD;

1.135
date	2015.10.29.10.25.36;	author sunil;	state Exp;
branches;
next	1.134;
commitid	TXZugvtal96cI6ec;

1.134
date	2015.10.28.07.24.28;	author sunil;	state Exp;
branches;
next	1.133;
commitid	jDoyXq1uotObAjNc;

1.133
date	2015.10.27.21.01.09;	author gilles;	state Exp;
branches;
next	1.132;
commitid	D0yR3YTYj4ECQCD2;

1.132
date	2015.10.16.13.37.44;	author millert;	state Exp;
branches;
next	1.131;
commitid	H99PcNtHGZMrNl2r;

1.131
date	2015.10.15.08.18.23;	author sunil;	state Exp;
branches;
next	1.130;
commitid	1gy8qVoyriyUWv4d;

1.130
date	2015.10.13.08.06.22;	author gilles;	state Exp;
branches;
next	1.129;
commitid	8thfbI76QAnBIpoV;

1.129
date	2015.10.12.07.58.19;	author deraadt;	state Exp;
branches;
next	1.128;
commitid	SD2NAm0X1clljRst;

1.128
date	2015.10.09.14.37.38;	author gilles;	state Exp;
branches;
next	1.127;
commitid	Av5gnXBLeZb6m0W2;

1.127
date	2015.10.06.06.07.28;	author gilles;	state Exp;
branches;
next	1.126;
commitid	1tZmtWo0oaRKISbq;

1.126
date	2015.10.06.05.48.34;	author gilles;	state Exp;
branches;
next	1.125;
commitid	LfGrhzZIeOm2z9BP;

1.125
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.124;
commitid	ZBTFreARDSMmzOIV;

1.124
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches;
next	1.123;
commitid	0acpjAf5myNxgwB5;

1.123
date	2014.07.08.20.14.46;	author eric;	state Exp;
branches;
next	1.122;
commitid	AHjSiMjlXwD7KM7Y;

1.122
date	2014.07.07.09.11.24;	author eric;	state Exp;
branches;
next	1.121;
commitid	i5e19t9Ki1zvGnyP;

1.121
date	2014.05.23.13.28.32;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2014.05.20.18.47.01;	author eric;	state Exp;
branches;
next	1.119;

1.119
date	2014.04.22.13.57.58;	author gilles;	state Exp;
branches;
next	1.118;

1.118
date	2014.04.19.13.57.17;	author gilles;	state Exp;
branches;
next	1.117;

1.117
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.116;

1.116
date	2014.02.17.13.33.56;	author eric;	state Exp;
branches;
next	1.115;

1.115
date	2014.02.04.15.22.39;	author eric;	state Exp;
branches;
next	1.114;

1.114
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.113;

1.113
date	2013.11.13.09.15.41;	author eric;	state Exp;
branches;
next	1.112;

1.112
date	2013.10.30.21.37.48;	author eric;	state Exp;
branches;
next	1.111;

1.111
date	2013.10.27.17.47.53;	author eric;	state Exp;
branches;
next	1.110;

1.110
date	2013.10.25.21.31.23;	author eric;	state Exp;
branches;
next	1.109;

1.109
date	2013.10.25.18.58.10;	author eric;	state Exp;
branches;
next	1.108;

1.108
date	2013.07.19.21.14.52;	author eric;	state Exp;
branches;
next	1.107;

1.107
date	2013.07.19.15.14.23;	author eric;	state Exp;
branches;
next	1.106;

1.106
date	2013.07.19.13.41.23;	author eric;	state Exp;
branches;
next	1.105;

1.105
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.104;

1.104
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.103;

1.103
date	2013.04.17.15.02.38;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.101;

1.101
date	2013.02.14.12.30.49;	author gilles;	state Exp;
branches;
next	1.100;

1.100
date	2013.01.28.11.09.53;	author gilles;	state Exp;
branches;
next	1.99;

1.99
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.98;

1.98
date	2012.11.23.09.25.44;	author eric;	state Exp;
branches;
next	1.97;

1.97
date	2012.11.20.09.47.46;	author eric;	state Exp;
branches;
next	1.96;

1.96
date	2012.11.13.09.35.18;	author eric;	state Exp;
branches;
next	1.95;

1.95
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.94;

1.94
date	2012.10.26.19.16.42;	author chl;	state Exp;
branches;
next	1.93;

1.93
date	2012.10.14.11.58.23;	author gilles;	state Exp;
branches;
next	1.92;

1.92
date	2012.10.10.19.39.11;	author gilles;	state Exp;
branches;
next	1.91;

1.91
date	2012.09.19.20.08.53;	author eric;	state Exp;
branches;
next	1.90;

1.90
date	2012.09.19.18.20.36;	author eric;	state Exp;
branches;
next	1.89;

1.89
date	2012.08.30.22.06.00;	author gilles;	state Exp;
branches;
next	1.88;

1.88
date	2012.08.25.10.23.12;	author gilles;	state Exp;
branches;
next	1.87;

1.87
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.86;

1.86
date	2012.08.18.18.18.23;	author gilles;	state Exp;
branches;
next	1.85;

1.85
date	2012.08.08.17.33.55;	author eric;	state Exp;
branches;
next	1.84;

1.84
date	2012.08.07.20.36.10;	author eric;	state Exp;
branches;
next	1.83;

1.83
date	2012.07.09.09.57.53;	author gilles;	state Exp;
branches;
next	1.82;

1.82
date	2012.07.02.17.00.05;	author eric;	state Exp;
branches;
next	1.81;

1.81
date	2012.06.20.20.45.23;	author eric;	state Exp;
branches;
next	1.80;

1.80
date	2012.05.13.09.18.52;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2012.04.15.12.12.35;	author chl;	state Exp;
branches;
next	1.78;

1.78
date	2012.01.28.11.33.07;	author gilles;	state Exp;
branches;
next	1.77;

1.77
date	2012.01.24.12.20.18;	author eric;	state Exp;
branches;
next	1.76;

1.76
date	2012.01.12.22.59.55;	author eric;	state Exp;
branches;
next	1.75;

1.75
date	2012.01.12.18.06.18;	author eric;	state Exp;
branches;
next	1.74;

1.74
date	2011.12.18.22.52.25;	author chl;	state Exp;
branches;
next	1.73;

1.73
date	2011.12.14.18.42.27;	author eric;	state Exp;
branches;
next	1.72;

1.72
date	2011.11.23.13.48.03;	author chl;	state Exp;
branches;
next	1.71;

1.71
date	2011.11.15.23.06.39;	author gilles;	state Exp;
branches;
next	1.70;

1.70
date	2011.10.26.20.47.31;	author gilles;	state Exp;
branches;
next	1.69;

1.69
date	2011.10.23.17.12.41;	author gilles;	state Exp;
branches;
next	1.68;

1.68
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.67;

1.67
date	2011.09.01.19.56.49;	author eric;	state Exp;
branches;
next	1.66;

1.66
date	2011.08.30.07.06.06;	author chl;	state Exp;
branches;
next	1.65;

1.65
date	2011.08.29.21.43.09;	author chl;	state Exp;
branches;
next	1.64;

1.64
date	2011.08.26.14.39.47;	author chl;	state Exp;
branches;
next	1.63;

1.63
date	2011.08.16.19.12.40;	author gilles;	state Exp;
branches;
next	1.62;

1.62
date	2011.08.16.19.02.03;	author gilles;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.21.23.29.24;	author gilles;	state Exp;
branches;
next	1.60;

1.60
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.59;

1.59
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2011.04.13.20.53.18;	author gilles;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.02.16.40.19;	author eric;	state Exp;
branches;
next	1.56;

1.56
date	2011.03.09.20.59.22;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.54;

1.54
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2010.11.24.23.27.04;	author todd;	state Exp;
branches;
next	1.52;

1.52
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.01.23.06.25;	author jacekm;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.01.11.37.26;	author jacekm;	state Exp;
branches;
next	1.48;

1.48
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.21.18.54.43;	author jacekm;	state Exp;
branches;
next	1.46;

1.46
date	2010.01.10.16.42.35;	author gilles;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.14.18.21.53;	author jacekm;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.14.16.44.14;	author jacekm;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.13.22.02.55;	author jacekm;	state Exp;
branches;
next	1.41;

1.41
date	2009.12.13.21.48.21;	author jacekm;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.13.20.34.51;	author chl;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.25.19.46.31;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.12.12.24.51;	author jacekm;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.12.09.38.45;	author gilles;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.12.09.22.33;	author gilles;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.02.12.47.06;	author jacekm;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.27.11.38.50;	author jacekm;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.08.19.16.41;	author ian;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.08.00.16.49;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.30;

1.30
date	2009.06.06.03.22.21;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2009.05.30.16.30.33;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2009.05.27.13.09.07;	author jacekm;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.24.14.22.24;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.20.11.58.06;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.18.20.23.35;	author jacekm;	state Exp;
branches;
next	1.24;

1.24
date	2009.04.23.08.28.45;	author jacekm;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.21.18.12.05;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.20.17.07.01;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.16.15.35.06;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.15.20.34.59;	author jacekm;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.23.21.48.40;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.22.13.52.03;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.15.19.32.10;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.01.12.12.58;	author jacekm;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.24.12.07.47;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.17.22.49.22;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.13.20.44.46;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.30.21.52.55;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.30.21.40.21;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.30.21.22.33;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.29.22.34.21;	author jacekm;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.29.21.59.15;	author jacekm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.29.12.43.25;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.27.22.48.29;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.04.22.35.09;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.04.19.37.41;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.27.16.45.01;	author jacekm;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.06.02.44.08;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.05.03.28.37;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.154
log
@smtpctl(8): Use an int to determine mode instead of __progname.

Ok millert@@ gilles@@
@
text
@/*	$OpenBSD: smtpctl.c,v 1.153 2017/05/19 19:56:42 eric Exp $	*/

/*
 * Copyright (c) 2013 Eric Faurot <eric@@openbsd.org>
 * Copyright (c) 2006 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <event.h>
#include <fts.h>
#include <imsg.h>
#include <inttypes.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

#include "smtpd.h"
#include "parser.h"
#include "log.h"

#define PATH_GZCAT	"/usr/bin/gzcat"
#define	PATH_CAT	"/bin/cat"
#define PATH_QUEUE	"/queue"
#define PATH_ENCRYPT	"/usr/bin/encrypt"

int srv_connect(void);
int srv_connected(void);

void usage(void);
static void show_queue_envelope(struct envelope *, int);
static void getflag(uint *, int, char *, char *, size_t);
static void display(const char *);
static int str_to_trace(const char *);
static int str_to_profile(const char *);
static void show_offline_envelope(uint64_t);
static int is_gzip_fp(FILE *);
static int is_encrypted_fp(FILE *);
static int is_encrypted_buffer(const char *);
static int is_gzip_buffer(const char *);
static FILE *offline_file(void);
static void sendmail_compat(int, char **);

extern char	*__progname;
int		 sendmail;
struct smtpd	*env;
struct imsgbuf	*ibuf;
struct imsg	 imsg;
char		*rdata;
size_t		 rlen;
time_t		 now;

struct queue_backend queue_backend_null;
struct queue_backend queue_backend_proc;
struct queue_backend queue_backend_ram;

__dead void
usage(void)
{
	if (sendmail)
		fprintf(stderr, "usage: %s [-tv] [-f from] [-F name] to ...\n",
		    __progname);
	else
		fprintf(stderr, "usage: %s command [argument ...]\n",
		    __progname);
	exit(1);
}

void stat_increment(const char *k, size_t v)
{
}

void stat_decrement(const char *k, size_t v)
{
}

int
srv_connect(void)
{
	struct sockaddr_un	s_un;
	int			ctl_sock, saved_errno;

	/* connect to smtpd control socket */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	memset(&s_un, 0, sizeof(s_un));
	s_un.sun_family = AF_UNIX;
	(void)strlcpy(s_un.sun_path, SMTPD_SOCKET, sizeof(s_un.sun_path));
	if (connect(ctl_sock, (struct sockaddr *)&s_un, sizeof(s_un)) == -1) {
		saved_errno = errno;
		close(ctl_sock);
		errno = saved_errno;
		return (0);
	}

	ibuf = xcalloc(1, sizeof(struct imsgbuf), "smtpctl:srv_connect");
	imsg_init(ibuf, ctl_sock);

	return (1);
}

int
srv_connected(void)
{
	return ibuf != NULL ? 1 : 0;
}

FILE *
offline_file(void)
{
	char	path[PATH_MAX];
	int	fd;
	FILE   *fp;

	if (!bsnprintf(path, sizeof(path), "%s%s/%lld.XXXXXXXXXX", PATH_SPOOL,
		PATH_OFFLINE, (long long int) time(NULL)))
		err(EX_UNAVAILABLE, "snprintf");

	if ((fd = mkstemp(path)) == -1 || (fp = fdopen(fd, "w+")) == NULL) {
		if (fd != -1)
			unlink(path);
		err(EX_UNAVAILABLE, "cannot create temporary file %s", path);
	}

	if (fchmod(fd, 0600) == -1) {
		unlink(path);
		err(EX_SOFTWARE, "fchmod");
	}

	return fp;
}


static void
srv_flush(void)
{
	if (imsg_flush(ibuf) == -1)
		err(1, "write error");
}

static void
srv_send(int msg, const void *data, size_t len)
{
	if (ibuf == NULL && !srv_connect())
		errx(1, "smtpd doesn't seem to be running");
	imsg_compose(ibuf, msg, IMSG_VERSION, 0, -1, data, len);
}

static void
srv_recv(int type)
{
	ssize_t	n;

	srv_flush();

	while (1) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			errx(1, "imsg_get error");
		if (n) {
			if (imsg.hdr.type == IMSG_CTL_FAIL &&
			    imsg.hdr.peerid != 0 &&
			    imsg.hdr.peerid != IMSG_VERSION)
				errx(1, "incompatible smtpctl and smtpd");
			if (type != -1 && type != (int)imsg.hdr.type)
				errx(1, "bad message type");
			rdata = imsg.data;
			rlen = imsg.hdr.len - sizeof(imsg.hdr);
			break;
		}

		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");
	}
}

static void
srv_read(void *dst, size_t sz)
{
	if (sz == 0)
		return;
	if (rlen < sz)
		errx(1, "message too short");
	if (dst)
		memmove(dst, rdata, sz);
	rlen -= sz;
	rdata += sz;
}

static void
srv_get_int(int *i)
{
	srv_read(i, sizeof(*i));
}

static void
srv_get_time(time_t *t)
{
	srv_read(t, sizeof(*t));
}

static void
srv_get_evpid(uint64_t *evpid)
{
	srv_read(evpid, sizeof(*evpid));
}

static void
srv_get_string(const char **s)
{
	const char *end;
	size_t len;

	if (rlen == 0)
		errx(1, "message too short");

	end = memchr(rdata, 0, rlen);
	if (end == NULL)
		errx(1, "unterminated string");

	len = end + 1 - rdata;

	*s = rdata;
	rlen -= len;
	rdata += len;
}

static void
srv_get_envelope(struct envelope *evp)
{
	uint64_t	 evpid;
	const char	*str;

	srv_get_evpid(&evpid);
	srv_get_string(&str);

	envelope_load_buffer(evp, str, strlen(str));
	evp->id = evpid;
}

static void
srv_end(void)
{
	if (rlen)
		errx(1, "bogus data");
	imsg_free(&imsg);
}

static int
srv_check_result(int verbose_)
{
	srv_recv(-1);
	srv_end();

	switch (imsg.hdr.type) {
	case IMSG_CTL_OK:
		if (verbose_)
			printf("command succeeded\n");
		return (0);
	case IMSG_CTL_FAIL:
		if (verbose_) {
			if (rlen)
				printf("command failed: %s\n", rdata);
			else
				printf("command failed\n");
		}
		return (1);
	default:
		errx(1, "wrong message in response: %u", imsg.hdr.type);
	}
	return (0);
}

static int
srv_iter_messages(uint32_t *res)
{
	static uint32_t	*msgids = NULL, from = 0;
	static size_t	 n, curr;
	static int	 done = 0;

	if (done)
		return (0);

	if (msgids == NULL) {
		srv_send(IMSG_CTL_LIST_MESSAGES, &from, sizeof(from));
		srv_recv(IMSG_CTL_LIST_MESSAGES);
		if (rlen == 0) {
			srv_end();
			done = 1;
			return (0);
		}
		msgids = malloc(rlen);
		n = rlen / sizeof(*msgids);
		srv_read(msgids, rlen);
		srv_end();

		curr = 0;
		from = msgids[n - 1] + 1;
		if (from == 0)
			done = 1;
	}

	*res = msgids[curr++];
	if (curr == n) {
		free(msgids);
		msgids = NULL;
	}

	return (1);
}

static int
srv_iter_envelopes(uint32_t msgid, struct envelope *evp)
{
	static uint32_t	currmsgid = 0;
	static uint64_t	from = 0;
	static int	done = 0, need_send = 1, found;
	int		flags;
	time_t		nexttry;

	if (currmsgid != msgid) {
		if (currmsgid != 0 && !done)
			errx(1, "must finish current iteration first");
		currmsgid = msgid;
		from = msgid_to_evpid(msgid);
		done = 0;
		found = 0;
		need_send = 1;
	}

	if (done)
		return (0);

    again:
	if (need_send) {
		found = 0;
		srv_send(IMSG_CTL_LIST_ENVELOPES, &from, sizeof(from));
	}
	need_send = 0;

	srv_recv(IMSG_CTL_LIST_ENVELOPES);
	if (rlen == 0) {
		srv_end();
		if (!found || evpid_to_msgid(from) != msgid) {
			done = 1;
			return (0);
		}
		need_send = 1;
		goto again;
	}

	srv_get_int(&flags);
	srv_get_time(&nexttry);
	srv_get_envelope(evp);
	srv_end();

	evp->flags |= flags;
	evp->nexttry = nexttry;

	from = evp->id + 1;
	found++;
	return (1);
}

static int
srv_iter_evpids(uint32_t msgid, uint64_t *evpid, int *offset)
{
	static uint64_t	*evpids = NULL, *tmp;
	static int	 n, tmpalloc, alloc = 0;
	struct envelope	 evp;

	if (*offset == 0) {
		n = 0;
		while (srv_iter_envelopes(msgid, &evp)) {
			if (n == alloc) {
				tmpalloc = alloc ? (alloc * 2) : 128;
				tmp = recallocarray(evpids, alloc, tmpalloc,
				    sizeof(*evpids));
				if (tmp == NULL)
					err(1, "recallocarray");
				evpids = tmp;
				alloc = tmpalloc;
			}
			evpids[n++] = evp.id;
		}
	}

	if (*offset >= n)
		return (0);
	*evpid = evpids[*offset];
	*offset += 1;
	return (1);
}

static void
srv_foreach_envelope(struct parameter *argv, int ctl, size_t *total, size_t *ok)
{
	uint32_t	msgid;
	uint64_t	evpid;
	int		i;

	*total = 0;
	*ok = 0;

	if (argv == NULL) {
		while (srv_iter_messages(&msgid)) {
			i = 0;
			while (srv_iter_evpids(msgid, &evpid, &i)) {
				*total += 1;
				srv_send(ctl, &evpid, sizeof(evpid));
				if (srv_check_result(0) == 0)
					*ok += 1;
			}
		}
	} else if (argv->type == P_MSGID) {
		i = 0;
		while (srv_iter_evpids(argv->u.u_msgid, &evpid, &i)) {
			srv_send(ctl, &evpid, sizeof(evpid));
			if (srv_check_result(0) == 0)
				*ok += 1;
		}
	} else {
		*total += 1;
		srv_send(ctl, &argv->u.u_evpid, sizeof(evpid));
		if (srv_check_result(0) == 0)
			*ok += 1;
	}
}

static void
srv_show_cmd(int cmd, const void *data, size_t len)
{
	int	done = 0;

	srv_send(cmd, data, len);

	do {
		srv_recv(cmd);
		if (rlen) {
			printf("%s\n", rdata);
			srv_read(NULL, rlen);
		}
		else
			done = 1;
		srv_end();
	} while (!done);
}

static int
do_log_brief(int argc, struct parameter *argv)
{
	int	v = 0;

	srv_send(IMSG_CTL_VERBOSE, &v, sizeof(v));
	return srv_check_result(1);
}

static int
do_log_verbose(int argc, struct parameter *argv)
{
	int	v = TRACE_DEBUG;

	srv_send(IMSG_CTL_VERBOSE, &v, sizeof(v));
	return srv_check_result(1);
}

static int
do_monitor(int argc, struct parameter *argv)
{
	struct stat_digest	last, digest;
	size_t			count;

	memset(&last, 0, sizeof(last));
	count = 0;

	while (1) {
		srv_send(IMSG_CTL_GET_DIGEST, NULL, 0);
		srv_recv(IMSG_CTL_GET_DIGEST);
		srv_read(&digest, sizeof(digest));
		srv_end();

		if (count % 25 == 0) {
			if (count != 0)
				printf("\n");
			printf("--- client ---  "
			    "-- envelope --   "
			    "---- relay/delivery --- "
			    "------- misc -------\n"
			    "curr conn disc  "
			    "curr  enq  deq   "
			    "ok tmpfail prmfail loop "
			    "expire remove bounce\n");
		}
		printf("%4zu %4zu %4zu  "
		    "%4zu %4zu %4zu "
		    "%4zu    %4zu    %4zu %4zu   "
		    "%4zu   %4zu   %4zu\n",
		    digest.clt_connect - digest.clt_disconnect,
		    digest.clt_connect - last.clt_connect,
		    digest.clt_disconnect - last.clt_disconnect,

		    digest.evp_enqueued - digest.evp_dequeued,
		    digest.evp_enqueued - last.evp_enqueued,
		    digest.evp_dequeued - last.evp_dequeued,

		    digest.dlv_ok - last.dlv_ok,
		    digest.dlv_tempfail - last.dlv_tempfail,
		    digest.dlv_permfail - last.dlv_permfail,
		    digest.dlv_loop - last.dlv_loop,

		    digest.evp_expired - last.evp_expired,
		    digest.evp_removed - last.evp_removed,
		    digest.evp_bounce - last.evp_bounce);

		last = digest;
		count++;
		sleep(1);
	}

	return (0);
}

static int
do_pause_envelope(int argc, struct parameter *argv)
{
	size_t	total, ok;

	srv_foreach_envelope(argv, IMSG_CTL_PAUSE_EVP, &total, &ok);
	printf("%zu envelope%s paused\n", ok, (ok > 1) ? "s" : "");

	return (0);
}

static int
do_pause_mda(int argc, struct parameter *argv)
{
	srv_send(IMSG_CTL_PAUSE_MDA, NULL, 0);
	return srv_check_result(1);
}

static int
do_pause_mta(int argc, struct parameter *argv)
{
	srv_send(IMSG_CTL_PAUSE_MTA, NULL, 0);
	return srv_check_result(1);
}

static int
do_pause_smtp(int argc, struct parameter *argv)
{
	srv_send(IMSG_CTL_PAUSE_SMTP, NULL, 0);
	return srv_check_result(1);
}

static int
do_profile(int argc, struct parameter *argv)
{
	int	v;

	v = str_to_profile(argv[0].u.u_str);

	srv_send(IMSG_CTL_PROFILE_ENABLE, &v, sizeof(v));
	return srv_check_result(1);
}

static int
do_remove(int argc, struct parameter *argv)
{
	size_t	total, ok;

	srv_foreach_envelope(argv, IMSG_CTL_REMOVE, &total, &ok);
	printf("%zu envelope%s removed\n", ok, (ok > 1) ? "s" : "");

	return (0);
}

static int
do_resume_envelope(int argc, struct parameter *argv)
{
	size_t	total, ok;

	srv_foreach_envelope(argv, IMSG_CTL_RESUME_EVP, &total, &ok);
	printf("%zu envelope%s resumed\n", ok, (ok > 1) ? "s" : "");

	return (0);
}

static int
do_resume_mda(int argc, struct parameter *argv)
{
	srv_send(IMSG_CTL_RESUME_MDA, NULL, 0);
	return srv_check_result(1);
}

static int
do_resume_mta(int argc, struct parameter *argv)
{
	srv_send(IMSG_CTL_RESUME_MTA, NULL, 0);
	return srv_check_result(1);
}

static int
do_resume_route(int argc, struct parameter *argv)
{
	uint64_t	v;

	if (argc == 0)
		v = 0;
	else
		v = argv[0].u.u_routeid;

	srv_send(IMSG_CTL_RESUME_ROUTE, &v, sizeof(v));
	return srv_check_result(1);
}

static int
do_resume_smtp(int argc, struct parameter *argv)
{
	srv_send(IMSG_CTL_RESUME_SMTP, NULL, 0);
	return srv_check_result(1);
}

static int
do_schedule(int argc, struct parameter *argv)
{
	size_t	total, ok;

	srv_foreach_envelope(argv, IMSG_CTL_SCHEDULE, &total, &ok);
	printf("%zu envelope%s scheduled\n", ok, (ok > 1) ? "s" : "");

	return (0);
}

static int
do_show_envelope(int argc, struct parameter *argv)
{
	char	 buf[PATH_MAX];

	if (!bsnprintf(buf, sizeof(buf), "%s%s/%02x/%08x/%016" PRIx64,
	    PATH_SPOOL,
	    PATH_QUEUE,
	    (evpid_to_msgid(argv[0].u.u_evpid) & 0xff000000) >> 24,
	    evpid_to_msgid(argv[0].u.u_evpid),
	    argv[0].u.u_evpid))
		errx(1, "unable to retrieve envelope");

	display(buf);

	return (0);
}

static int
do_show_hoststats(int argc, struct parameter *argv)
{
	srv_show_cmd(IMSG_CTL_MTA_SHOW_HOSTSTATS, NULL, 0);

	return (0);
}

static int
do_show_message(int argc, struct parameter *argv)
{
	char	 buf[PATH_MAX];
	uint32_t msgid;

	if (argv[0].type == P_EVPID)
		msgid = evpid_to_msgid(argv[0].u.u_evpid);
	else
		msgid = argv[0].u.u_msgid;

	if (!bsnprintf(buf, sizeof(buf), "%s%s/%02x/%08x/message",
		PATH_SPOOL,
		PATH_QUEUE,
		(msgid & 0xff000000) >> 24,
		msgid))
		errx(1, "unable to retrieve message");

	display(buf);

	return (0);
}

static int
do_show_queue(int argc, struct parameter *argv)
{
	struct envelope	 evp;
	uint32_t	 msgid;
	FTS		*fts;
	FTSENT		*ftse;
	char		*qpath[] = {"/queue", NULL};
	char		*tmp;
	uint64_t	 evpid;

	now = time(NULL);

	if (!srv_connect()) {
		log_init(1, LOG_MAIL);
		queue_init("fs", 0);
		if (chroot(PATH_SPOOL) == -1 || chdir("/") == -1)
			err(1, "%s", PATH_SPOOL);
		fts = fts_open(qpath, FTS_PHYSICAL|FTS_NOCHDIR, NULL);
		if (fts == NULL)
			err(1, "%s/queue", PATH_SPOOL);

		while ((ftse = fts_read(fts)) != NULL) {
			switch (ftse->fts_info) {
			case FTS_DP:
			case FTS_DNR:
				break;
			case FTS_F:
				tmp = NULL;
				evpid = strtoull(ftse->fts_name, &tmp, 16);
				if (tmp && *tmp != '\0')
					break;
				show_offline_envelope(evpid);
			}
		}

		fts_close(fts);
		return (0);
	}

	if (argc == 0) {
		msgid = 0;
		while (srv_iter_messages(&msgid))
			while (srv_iter_envelopes(msgid, &evp))
				show_queue_envelope(&evp, 1);
	} else if (argv[0].type == P_MSGID) {
		while (srv_iter_envelopes(argv[0].u.u_msgid, &evp))
			show_queue_envelope(&evp, 1);
	}

	return (0);
}

static int
do_show_hosts(int argc, struct parameter *argv)
{
	srv_show_cmd(IMSG_CTL_MTA_SHOW_HOSTS, NULL, 0);

	return (0);
}

static int
do_show_relays(int argc, struct parameter *argv)
{
	srv_show_cmd(IMSG_CTL_MTA_SHOW_RELAYS, NULL, 0);

	return (0);
}

static int
do_show_routes(int argc, struct parameter *argv)
{
	srv_show_cmd(IMSG_CTL_MTA_SHOW_ROUTES, NULL, 0);

	return (0);
}

static int
do_show_stats(int argc, struct parameter *argv)
{
	struct stat_kv	kv;
	time_t		duration;

	memset(&kv, 0, sizeof kv);

	while (1) {
		srv_send(IMSG_CTL_GET_STATS, &kv, sizeof kv);
		srv_recv(IMSG_CTL_GET_STATS);
		srv_read(&kv, sizeof(kv));
		srv_end();

		if (kv.iter == NULL)
			break;

		if (strcmp(kv.key, "uptime") == 0) {
			duration = time(NULL) - kv.val.u.counter;
			printf("uptime=%lld\n", (long long)duration);
			printf("uptime.human=%s\n",
			    duration_to_text(duration));
		}
		else {
			switch (kv.val.type) {
			case STAT_COUNTER:
				printf("%s=%zd\n",
				    kv.key, kv.val.u.counter);
				break;
			case STAT_TIMESTAMP:
				printf("%s=%" PRId64 "\n",
				    kv.key, (int64_t)kv.val.u.timestamp);
				break;
			case STAT_TIMEVAL:
				printf("%s=%lld.%lld\n",
				    kv.key, (long long)kv.val.u.tv.tv_sec,
				    (long long)kv.val.u.tv.tv_usec);
				break;
			case STAT_TIMESPEC:
				printf("%s=%lld.%06ld\n",
				    kv.key,
				    (long long)kv.val.u.ts.tv_sec * 1000000 +
				    kv.val.u.ts.tv_nsec / 1000000,
				    kv.val.u.ts.tv_nsec % 1000000);
				break;
			}
		}
	}

	return (0);
}

static int
do_show_status(int argc, struct parameter *argv)
{
	uint32_t	sc_flags;

	srv_send(IMSG_CTL_SHOW_STATUS, NULL, 0);
	srv_recv(IMSG_CTL_SHOW_STATUS);
	srv_read(&sc_flags, sizeof(sc_flags));
	srv_end();
	printf("MDA %s\n",
	    (sc_flags & SMTPD_MDA_PAUSED) ? "paused" : "running");
	printf("MTA %s\n",
	    (sc_flags & SMTPD_MTA_PAUSED) ? "paused" : "running");
	printf("SMTP %s\n",
	    (sc_flags & SMTPD_SMTP_PAUSED) ? "paused" : "running");
	return (0);
}

static int
do_trace(int argc, struct parameter *argv)
{
	int	v;

	v = str_to_trace(argv[0].u.u_str);

	srv_send(IMSG_CTL_TRACE_ENABLE, &v, sizeof(v));
	return srv_check_result(1);
}

static int
do_unprofile(int argc, struct parameter *argv)
{
	int	v;

	v = str_to_profile(argv[0].u.u_str);

	srv_send(IMSG_CTL_PROFILE_DISABLE, &v, sizeof(v));
	return srv_check_result(1);
}

static int
do_untrace(int argc, struct parameter *argv)
{
	int	v;

	v = str_to_trace(argv[0].u.u_str);

	srv_send(IMSG_CTL_TRACE_DISABLE, &v, sizeof(v));
	return srv_check_result(1);
}

static int
do_update_table(int argc, struct parameter *argv)
{
	const char	*name = argv[0].u.u_str;

	srv_send(IMSG_CTL_UPDATE_TABLE, name, strlen(name) + 1);
	return srv_check_result(1);
}

static int
do_encrypt(int argc, struct parameter *argv)
{
	const char *p = NULL;

	if (argv)
		p = argv[0].u.u_str;
	execl(PATH_ENCRYPT, "encrypt", p, (char *)NULL);
	errx(1, "execl");
}

static int
do_block_mta(int argc, struct parameter *argv)
{
	struct ibuf *m;

	if (ibuf == NULL && !srv_connect())
		errx(1, "smtpd doesn't seem to be running");
	m = imsg_create(ibuf, IMSG_CTL_MTA_BLOCK, IMSG_VERSION, 0,
	    sizeof(argv[0].u.u_ss) + strlen(argv[1].u.u_str) + 1);
	if (imsg_add(m, &argv[0].u.u_ss, sizeof(argv[0].u.u_ss)) == -1)
		errx(1, "imsg_add");
	if (imsg_add(m, argv[1].u.u_str, strlen(argv[1].u.u_str) + 1) == -1)
		errx(1, "imsg_add");
	imsg_close(ibuf, m);

	return srv_check_result(1);
}

static int
do_unblock_mta(int argc, struct parameter *argv)
{
	struct ibuf *m;

	if (ibuf == NULL && !srv_connect())
		errx(1, "smtpd doesn't seem to be running");

	m = imsg_create(ibuf, IMSG_CTL_MTA_UNBLOCK, IMSG_VERSION, 0,
	    sizeof(argv[0].u.u_ss) + strlen(argv[1].u.u_str) + 1);
	if (imsg_add(m, &argv[0].u.u_ss, sizeof(argv[0].u.u_ss)) == -1)
		errx(1, "imsg_add");
	if (imsg_add(m, argv[1].u.u_str, strlen(argv[1].u.u_str) + 1) == -1)
		errx(1, "imsg_add");
	imsg_close(ibuf, m);

	return srv_check_result(1);
}

static int
do_show_mta_block(int argc, struct parameter *argv)
{
	srv_show_cmd(IMSG_CTL_MTA_SHOW_BLOCK, NULL, 0);

	return (0);
}

static int
do_discover(int argc, struct parameter *argv)
{
	uint64_t evpid;
	uint32_t msgid;
	size_t	 n_evp;

	if (ibuf == NULL && !srv_connect())
		errx(1, "smtpd doesn't seem to be running");

	if (argv[0].type == P_EVPID) {
		evpid = argv[0].u.u_evpid;
		srv_send(IMSG_CTL_DISCOVER_EVPID, &evpid, sizeof evpid);
		srv_recv(IMSG_CTL_DISCOVER_EVPID);
	} else {
		msgid = argv[0].u.u_msgid;
		srv_send(IMSG_CTL_DISCOVER_MSGID, &msgid, sizeof msgid);
		srv_recv(IMSG_CTL_DISCOVER_MSGID);
	}

	if (rlen == 0) {
		srv_end();
		return (0);
	} else {
		srv_read(&n_evp, sizeof n_evp);
		srv_end();
	}

	printf("%zu envelope%s discovered\n", n_evp, (n_evp != 1) ? "s" : "");
	return (0);
}

static int
do_uncorrupt(int argc, struct parameter *argv)
{
	uint32_t msgid;
	int	 ret;

	if (ibuf == NULL && !srv_connect())
		errx(1, "smtpd doesn't seem to be running");

	msgid = argv[0].u.u_msgid;
	srv_send(IMSG_CTL_UNCORRUPT_MSGID, &msgid, sizeof msgid);
	srv_recv(IMSG_CTL_UNCORRUPT_MSGID);

	if (rlen == 0) {
		srv_end();
		return (0);
	} else {
		srv_read(&ret, sizeof ret);
		srv_end();
	}

	printf("command %s\n", ret ? "succeeded" : "failed");
	return (0);
}

int
main(int argc, char **argv)
{
	gid_t		 gid;
	char		*argv_mailq[] = { "show", "queue", NULL };

	sendmail_compat(argc, argv);
	if (geteuid())
		errx(1, "need root privileges");

	gid = getgid();
	if (setresgid(gid, gid, gid) == -1)
		err(1, "setresgid");

	cmd_install("discover <evpid>",		do_discover);
	cmd_install("discover <msgid>",		do_discover);
	cmd_install("encrypt",			do_encrypt);
	cmd_install("encrypt <str>",		do_encrypt);
	cmd_install("pause mta from <addr> for <str>", do_block_mta);
	cmd_install("resume mta from <addr> for <str>", do_unblock_mta);
	cmd_install("show mta paused",		do_show_mta_block);
	cmd_install("log brief",		do_log_brief);
	cmd_install("log verbose",		do_log_verbose);
	cmd_install("monitor",			do_monitor);
	cmd_install("pause envelope <evpid>",	do_pause_envelope);
	cmd_install("pause envelope <msgid>",	do_pause_envelope);
	cmd_install("pause envelope all",	do_pause_envelope);
	cmd_install("pause mda",		do_pause_mda);
	cmd_install("pause mta",		do_pause_mta);
	cmd_install("pause smtp",		do_pause_smtp);
	cmd_install("profile <str>",		do_profile);
	cmd_install("remove <evpid>",		do_remove);
	cmd_install("remove <msgid>",		do_remove);
	cmd_install("remove all",		do_remove);
	cmd_install("resume envelope <evpid>",	do_resume_envelope);
	cmd_install("resume envelope <msgid>",	do_resume_envelope);
	cmd_install("resume envelope all",	do_resume_envelope);
	cmd_install("resume mda",		do_resume_mda);
	cmd_install("resume mta",		do_resume_mta);
	cmd_install("resume route <routeid>",	do_resume_route);
	cmd_install("resume smtp",		do_resume_smtp);
	cmd_install("schedule <msgid>",		do_schedule);
	cmd_install("schedule <evpid>",		do_schedule);
	cmd_install("schedule all",		do_schedule);
	cmd_install("show envelope <evpid>",	do_show_envelope);
	cmd_install("show hoststats",		do_show_hoststats);
	cmd_install("show message <msgid>",	do_show_message);
	cmd_install("show message <evpid>",	do_show_message);
	cmd_install("show queue",		do_show_queue);
	cmd_install("show queue <msgid>",	do_show_queue);
	cmd_install("show hosts",		do_show_hosts);
	cmd_install("show relays",		do_show_relays);
	cmd_install("show routes",		do_show_routes);
	cmd_install("show stats",		do_show_stats);
	cmd_install("show status",		do_show_status);
	cmd_install("trace <str>",		do_trace);
	cmd_install("uncorrupt <msgid>",	do_uncorrupt);
	cmd_install("unprofile <str>",		do_unprofile);
	cmd_install("untrace <str>",		do_untrace);
	cmd_install("update table <str>",	do_update_table);

	if (strcmp(__progname, "mailq") == 0)
		return cmd_run(2, argv_mailq);
	if (strcmp(__progname, "smtpctl") == 0)
		return cmd_run(argc - 1, argv + 1);

	errx(1, "unsupported mode");
	return (0);
}

void
sendmail_compat(int argc, char **argv)
{
	FILE	*offlinefp = NULL;
	gid_t	 gid;
	int	 i;

	if (strcmp(__progname, "sendmail") == 0 ||
	    strcmp(__progname, "send-mail") == 0) {
		/*
		 * determine whether we are called with flags
		 * that should invoke makemap/newaliases.
		 */
		for (i = 1; i < argc; i++)
			if (strncmp(argv[i], "-bi", 3) == 0)
				exit(makemap(P_NEWALIASES, argc, argv));

		if (!srv_connect())
			offlinefp = offline_file();

		gid = getgid();
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

		/* we'll reduce further down the road */
		if (pledge("stdio rpath wpath cpath tmppath flock "
			"dns getpw recvfd", NULL) == -1)
			err(1, "pledge");

		sendmail = 1;
		exit(enqueue(argc, argv, offlinefp));
	} else if (strcmp(__progname, "makemap") == 0)
		exit(makemap(P_MAKEMAP, argc, argv));
	else if (strcmp(__progname, "newaliases") == 0)
		exit(makemap(P_NEWALIASES, argc, argv));
}

static void
show_queue_envelope(struct envelope *e, int online)
{
	const char	*src = "?", *agent = "?";
	char		 status[128], runstate[128];

	status[0] = '\0';

	getflag(&e->flags, EF_BOUNCE, "bounce", status, sizeof(status));
	getflag(&e->flags, EF_AUTHENTICATED, "auth", status, sizeof(status));
	getflag(&e->flags, EF_INTERNAL, "internal", status, sizeof(status));
	getflag(&e->flags, EF_SUSPEND, "suspend", status, sizeof(status));
	getflag(&e->flags, EF_HOLD, "hold", status, sizeof(status));

	if (online) {
		if (e->flags & EF_PENDING)
			(void)snprintf(runstate, sizeof runstate, "pending|%zd",
			    (ssize_t)(e->nexttry - now));
		else if (e->flags & EF_INFLIGHT)
			(void)snprintf(runstate, sizeof runstate,
			    "inflight|%zd", (ssize_t)(now - e->lasttry));
		else
			(void)snprintf(runstate, sizeof runstate, "invalid|");
		e->flags &= ~(EF_PENDING|EF_INFLIGHT);
	}
	else
		(void)strlcpy(runstate, "offline|", sizeof runstate);

	if (e->flags)
		errx(1, "%016" PRIx64 ": unexpected flags 0x%04x", e->id,
		    e->flags);

	if (status[0])
		status[strlen(status) - 1] = '\0';

	if (e->type == D_MDA)
		agent = "mda";
	else if (e->type == D_MTA)
		agent = "mta";
	else if (e->type == D_BOUNCE)
		agent = "bounce";

	if (e->ss.ss_family == AF_LOCAL)
		src = "local";
	else if (e->ss.ss_family == AF_INET)
		src = "inet4";
	else if (e->ss.ss_family == AF_INET6)
		src = "inet6";

	printf("%016"PRIx64
	    "|%s|%s|%s|%s@@%s|%s@@%s|%s@@%s"
	    "|%zu|%zu|%zu|%zu|%s|%s\n",

	    e->id,

	    src,
	    agent,
	    status,
	    e->sender.user, e->sender.domain,
	    e->rcpt.user, e->rcpt.domain,
	    e->dest.user, e->dest.domain,

	    (size_t) e->creation,
	    (size_t) (e->creation + e->expire),
	    (size_t) e->lasttry,
	    (size_t) e->retry,
	    runstate,
	    e->errorline);
}

static void
getflag(uint *bitmap, int bit, char *bitstr, char *buf, size_t len)
{
	if (*bitmap & bit) {
		*bitmap &= ~bit;
		(void)strlcat(buf, bitstr, len);
		(void)strlcat(buf, ",", len);
	}
}

static void
show_offline_envelope(uint64_t evpid)
{
	FILE   *fp = NULL;
	char	pathname[PATH_MAX];
	size_t	plen;
	char   *p;
	size_t	buflen;
	char	buffer[sizeof(struct envelope)];

	struct envelope	evp;

	if (!bsnprintf(pathname, sizeof pathname,
		"/queue/%02x/%08x/%016"PRIx64,
		(evpid_to_msgid(evpid) & 0xff000000) >> 24,
		evpid_to_msgid(evpid), evpid))
		goto end;
	fp = fopen(pathname, "r");
	if (fp == NULL)
		goto end;

	buflen = fread(buffer, 1, sizeof (buffer) - 1, fp);
	p = buffer;
	plen = buflen;
	buffer[buflen] = '\0';

	if (is_encrypted_buffer(p)) {
		warnx("offline encrypted queue is not supported yet");
		goto end;
	}

	if (is_gzip_buffer(p)) {
		warnx("offline compressed queue is not supported yet");
		goto end;
	}

	if (!envelope_load_buffer(&evp, p, plen))
		goto end;
	evp.id = evpid;
	show_queue_envelope(&evp, 0);

end:
	if (fp)
		fclose(fp);
}

static void
display(const char *s)
{
	FILE   *fp;
	char   *key;
	int	gzipped;
	char   *gzcat_argv0 = strrchr(PATH_GZCAT, '/') + 1;

	if ((fp = fopen(s, "r")) == NULL)
		err(1, "fopen");

	if (is_encrypted_fp(fp)) {
		int	i;
		int	fd;
		FILE   *ofp = NULL;
		char	sfn[] = "/tmp/smtpd.XXXXXXXXXX";

		if ((fd = mkstemp(sfn)) == -1 ||
		    (ofp = fdopen(fd, "w+")) == NULL) {
			int saved_errno = errno;
			if (fd != -1) {
				unlink(sfn);
				close(fd);
			}
			errc(1, saved_errno, "mkstemp");
		}
		unlink(sfn);

		for (i = 0; i < 3; i++) {
			key = getpass("key> ");
			if (crypto_setup(key, strlen(key)))
				break;
		}
		if (i == 3)
			errx(1, "crypto-setup: invalid key");

		if (!crypto_decrypt_file(fp, ofp)) {
			printf("object is encrypted: %s\n", key);
			exit(1);
		}

		fclose(fp);
		fp = ofp;
		fseek(fp, 0, SEEK_SET);
	}
	gzipped = is_gzip_fp(fp);

	lseek(fileno(fp), 0, SEEK_SET);
	(void)dup2(fileno(fp), STDIN_FILENO);
	if (gzipped)
		execl(PATH_GZCAT, gzcat_argv0, (char *)NULL);
	else
		execl(PATH_CAT, "cat", (char *)NULL);
	err(1, "execl");
}

static int
str_to_trace(const char *str)
{
	if (!strcmp(str, "imsg"))
		return TRACE_IMSG;
	if (!strcmp(str, "io"))
		return TRACE_IO;
	if (!strcmp(str, "smtp"))
		return TRACE_SMTP;
	if (!strcmp(str, "filters"))
		return TRACE_FILTERS;
	if (!strcmp(str, "mta"))
		return TRACE_MTA;
	if (!strcmp(str, "bounce"))
		return TRACE_BOUNCE;
	if (!strcmp(str, "scheduler"))
		return TRACE_SCHEDULER;
	if (!strcmp(str, "lookup"))
		return TRACE_LOOKUP;
	if (!strcmp(str, "stat"))
		return TRACE_STAT;
	if (!strcmp(str, "rules"))
		return TRACE_RULES;
	if (!strcmp(str, "mproc"))
		return TRACE_MPROC;
	if (!strcmp(str, "expand"))
		return TRACE_EXPAND;
	if (!strcmp(str, "all"))
		return ~TRACE_DEBUG;
	errx(1, "invalid trace keyword: %s", str);
	return (0);
}

static int
str_to_profile(const char *str)
{
	if (!strcmp(str, "imsg"))
		return PROFILE_IMSG;
	if (!strcmp(str, "queue"))
		return PROFILE_QUEUE;
	errx(1, "invalid profile keyword: %s", str);
	return (0);
}

static int
is_gzip_buffer(const char *buffer)
{
	uint16_t	magic;

	memcpy(&magic, buffer, sizeof magic);
#define	GZIP_MAGIC	0x8b1f
	return (magic == GZIP_MAGIC);
}

static int
is_gzip_fp(FILE *fp)
{
	uint8_t		magic[2];
	int		ret = 0;

	if (fread(&magic, 1, sizeof magic, fp) != sizeof magic)
		goto end;

	ret = is_gzip_buffer((const char *)&magic);
end:
	fseek(fp, 0, SEEK_SET);
	return ret;
}


/* XXX */
/*
 * queue supports transparent encryption.
 * encrypted chunks are prefixed with an API version byte
 * which we ensure is unambiguous with gzipped / plain
 * objects.
 */

static int
is_encrypted_buffer(const char *buffer)
{
	uint8_t	magic;

	magic = *buffer;
#define	ENCRYPTION_MAGIC	0x1
	return (magic == ENCRYPTION_MAGIC);
}

static int
is_encrypted_fp(FILE *fp)
{
	uint8_t	magic;
	int	ret = 0;

	if (fread(&magic, 1, sizeof magic, fp) != sizeof magic)
		goto end;

	ret = is_encrypted_buffer((const char *)&magic);
end:
	fseek(fp, 0, SEEK_SET);
	return ret;
}
@


1.153
log
@- switch to recallocarray
- remove pre-allocation
- use a better growth pattern

ok gilles@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.152 2017/01/09 09:53:23 reyk Exp $	*/
d1099 2
a1100 4
			if (strncmp(argv[i], "-bi", 3) == 0) {
				__progname = "newaliases";
				exit(makemap(argc, argv));
			}
d1116 4
a1119 3
	} else if (strcmp(__progname, "makemap") == 0 ||
	    strcmp(__progname, "newaliases") == 0)
		exit(makemap(argc, argv));
@


1.152
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.151 2016/09/04 09:33:49 eric Exp $	*/
d399 1
a399 1
	static int	 n, alloc = 0;
a401 7
	if (evpids == NULL) {
		alloc = 1000;
		evpids = calloc(alloc, sizeof(*evpids));
		if (evpids == NULL)
			err(1, "calloc");
	}

d406 2
a407 2
				alloc += 256;
				tmp = reallocarray(evpids, alloc,
d410 1
a410 1
					err(1, "reallocarray");
d412 1
@


1.151
log
@Remove the "smtpctl stop" command.
The daemon is stopped with kill(1).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.150 2016/09/03 16:06:26 eric Exp $	*/
d733 1
a733 1
		log_init(1);
@


1.150
log
@get rid of the type-checking system on internal messages.
bump all imsg protocol versions since message format changed.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.149 2016/04/29 08:55:08 eric Exp $	*/
a866 7
do_stop(int argc, struct parameter *argv)
{
	srv_send(IMSG_CTL_SHUTDOWN, NULL, 0);
	return srv_check_result(1);
}

static int
a1075 1
	cmd_install("stop",			do_stop);
@


1.149
log
@fix "smtpctl show queue" reporting "invalid" envelope state.
runtime state is not serialized with the envelope, so add it to the imsg.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.148 2016/03/17 19:40:43 krw Exp $	*/
a222 3
	uint8_t type;

	srv_read(&type, 1);
a228 3
	uint8_t type;

	srv_read(&type, 1);
d235 8
a242 1
	uint8_t type;
d244 12
a255 2
	srv_read(&type, 1);
	srv_read(evpid, sizeof(*evpid));
d262 1
a262 3
	uint8_t		 type;
	size_t		 s;
	const void	*d;
d265 1
a265 4
	srv_read(&type, sizeof(type));
	srv_read(&s, sizeof(s));
	d = rdata;
	srv_read(NULL, s);
d267 1
a267 1
	envelope_load_buffer(evp, d, s - 1);
@


1.148
log
@Last parameter to execl[e]() functions *must* be cast to a pointer.
Just NULL is not good practise as NULL is theoretically allowed to
be an integer rather than a pointer.

Use (char *)NULL consistently instead of scattering a few (char *)0
and (void *)NULL into the mix.

Prompted by and probably ok deraadt@@ millert@@ kettenis@@

Definitely ok mestre@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.147 2016/02/12 03:11:16 sunil Exp $	*/
d221 45
d342 2
a343 3
	char		buf[sizeof(*evp)];
	size_t		buflen;
	uint64_t	evpid;
d376 7
a382 5
	srv_read(&evpid, sizeof evpid);
	buflen = rlen;
	srv_read(buf, rlen);
	envelope_load_buffer(evp, buf, buflen - 1);
	evp->id = evpid;
a383 1
	srv_end();
@


1.147
log
@Cleanup getopt(3) mis-use in sendmail compat code.

Avoid multiple getopt(3) evaluations without optreset set and
unspecified behavior of optind = 0 as per POSIX. Instead, iterate
over argv the first time for classification. Fixes -portable without
any divergence from -current, and all newaliases opts are handled
in one place.

Looks good to me millert@@
Ok gilles@@ jung@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.146 2016/02/09 10:38:02 gilles Exp $	*/
d871 1
a871 1
	execl(PATH_ENCRYPT, "encrypt", p, NULL);
d1262 1
a1262 1
		execl(PATH_GZCAT, gzcat_argv0, NULL);
d1264 1
a1264 1
		execl(PATH_CAT, "cat", NULL);
@


1.146
log
@rename variable sun to s_un to ease portability

diff from Freddy DISSAUX, ok gilles@@, jung@@, sunil@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.145 2016/02/03 08:03:21 gilles Exp $	*/
d70 1
a979 1
	arglist		 args;
a981 64
	char		*aliases_path = NULL, *p;
	FILE		*offlinefp = NULL;
	int		 ch, i, sendmail_makemap = 0;

	gid = getgid();
	if (strcmp(__progname, "sendmail") == 0 ||
	    strcmp(__progname, "send-mail") == 0) {
		/*
		 * determine whether we are called with flags
		 * that should invoke makemap/newaliases.
		 */
		opterr = 0;
		while ((ch = getopt(argc, argv, "b:C:O:")) != -1) {
			switch (ch) {
			case 'b':
				if (strcmp(optarg, "i") == 0)
					sendmail_makemap = 1;
				break;
			case 'C':
				break; /* compatibility, not required */
			case 'O':
				if (strncmp(optarg, "AliasFile=", 10) != 0)
					break;
				p = strchr(optarg, '=');
				aliases_path = ++p;
				break;
			}
		}
		opterr = 1;

		if (sendmail_makemap) {
			argc -= optind;
			argv += optind;
			optind = 0;

			memset(&args, 0, sizeof args);
			addargs(&args, "%s", "makemap");
			for (i = 0; i < argc; i++)
				addargs(&args, "%s", argv[i]);

			addargs(&args, "%s", "-taliases");
			if (aliases_path)
				addargs(&args, "%s", aliases_path);

			return makemap(args.num, args.list);
		}
		optind = 0;

		if (!srv_connect())
			offlinefp = offline_file();

		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

		/* we'll reduce further down the road */
		if (pledge("stdio rpath wpath cpath tmppath flock "
			"dns getpw recvfd", NULL) == -1)
			err(1, "pledge");

		sendmail = 1;
		return (enqueue(argc, argv, offlinefp));
	} else if (strcmp(__progname, "makemap") == 0 ||
	    strcmp(__progname, "newaliases") == 0)
		return makemap(argc, argv);
d983 1
d987 1
d1046 20
d1067 17
@


1.145
log
@NULL initialize two file pointers to make it more obvious when reading that
they can't end up uninitialized after the mkstemp/fdopen dance
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.144 2015/12/28 22:08:30 jung Exp $	*/
d107 1
a107 1
	struct sockaddr_un	sun;
d114 4
a117 4
	memset(&sun, 0, sizeof(sun));
	sun.sun_family = AF_UNIX;
	(void)strlcpy(sun.sun_path, SMTPD_SOCKET, sizeof(sun.sun_path));
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
@


1.144
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.143 2015/12/22 21:50:22 gilles Exp $	*/
d1251 1
a1251 1
		FILE   *ofp;
@


1.143
log
@fix sendmail options parsing
diff from Serguey Parkhomovsky <sergueyparkhomovsky@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.142 2015/12/22 15:59:10 sunil Exp $	*/
d143 1
a143 1
	if (! bsnprintf(path, sizeof(path), "%s%s/%lld.XXXXXXXXXX", PATH_SPOOL,
d623 1
a623 1
	if (! bsnprintf(buf, sizeof(buf), "%s%s/%02x/%08x/%016" PRIx64,
d655 1
a655 1
	if (! bsnprintf(buf, sizeof(buf), "%s%s/%02x/%08x/message",
d1203 1
a1203 1
	if (! bsnprintf(pathname, sizeof pathname,
d1227 1
a1227 1
	if (! envelope_load_buffer(&evp, p, plen))
d1273 1
a1273 1
		if (! crypto_decrypt_file(fp, ofp)) {
@


1.142
log
@Kill a trailing whitespace that snuck in with previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.141 2015/12/21 11:20:07 sunil Exp $	*/
d993 1
d1010 2
a1011 3
		argc -= optind;
		argv += optind;
		optind = 0;
d1013 4
d1028 1
@


1.141
log
@Start accepting some sendmail compatible commandline arguments.

This diff teaches smtpctl to understand '-bi -O AliasFile=<path_aliases>'
and generate aliases.db.

Ok gilles@@ jung@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.140 2015/12/11 07:30:24 gilles Exp $	*/
d999 1
a999 1
			case 'C':	 
@


1.140
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.139 2015/12/10 07:49:58 sunil Exp $	*/
d979 1
d982 1
d984 1
d989 36
@


1.139
log
@While listing envelopes using mailq(or smtpctl show queue), pass
the data between processes by dumping to and loading from a buffer
which is shorter compared to transferring a structure.  Also fixes
mailq on platforms where PATH_MAX is way larger than on OpenBSD
thus exceeding max imsg.

Ok jung@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.138 2015/12/07 12:29:19 sunil Exp $	*/
d333 1
a333 1
	srv_read(buf, rlen);	
@


1.138
log
@Merge makemap(8) into smtpctl(8).

Ok gilles@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.137 2015/12/05 13:14:21 claudio Exp $	*/
d296 3
d331 6
a336 1
	srv_read(evp, sizeof(*evp));
@


1.137
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.136 2015/11/05 09:14:31 sunil Exp $	*/
a86 2
	extern char *__progname;

d938 1
a938 1
	
d988 1
a988 1
		
d991 3
a993 1
	}
d1078 2
a1079 2
			(void)snprintf(runstate, sizeof runstate, "inflight|%zd",
			    (ssize_t)(now - e->lasttry));
d1333 1
a1333 1
	int    	ret = 0;
@


1.136
log
@Implement smtpctl uncorrupt <msgid>

"uncorrupt" moves envelopes from corrupt bucket back to the queue
for further discovery by the daemon.

After correcting the corrupt envelopes, admin could now...

# smtpctl uncorrupt msgid
# smtpctl discover msgid

to schedule the messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.135 2015/10/29 10:25:36 sunil Exp $	*/
d201 1
a201 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.135
log
@Implement smtpctl discover <evpid|msgid>.

discover subcommand schedules envelopes manually moved to the queue.
It triggers a queue walk searching for envelopes with the given id,
schedules them and informs the user number of envelopes scheduled.
Admins no longer would need to restart the daemon to discover
manually moved messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.134 2015/10/28 07:24:28 sunil Exp $	*/
d945 25
d1044 1
@


1.134
log
@Remove dead code.

Ok jung@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.133 2015/10/27 21:01:09 gilles Exp $	*/
d913 32
d976 2
@


1.133
log
@enqueue pledge: getmailname() needs dns, ~/dead.letter needs cpath/wpath

ok jung@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.132 2015/10/16 13:37:44 millert Exp $	*/
a697 5
		/*
		while ((r = queue_envelope_walk(&evp)) != -1)
			if (r)
				show_queue_envelope(&evp, 0);
		*/
@


1.132
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.131 2015/10/15 08:18:23 sunil Exp $	*/
d935 2
a936 1
		if (pledge("stdio rpath tmppath flock getpw recvfd", NULL) == -1)
@


1.131
log
@Let "all" as an argument for "resume envelope", "pause envelope"
and "remove" subcommands.

seems potentially useful millert@@, Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.130 2015/10/13 08:06:22 gilles Exp $	*/
d935 1
a935 1
		if (pledge("stdio rpath tmppath getpw recvfd", NULL) == -1)
@


1.130
log
@let the enqueuer pledge() in both online and offline modes

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.129 2015/10/12 07:58:19 deraadt Exp $	*/
d958 1
d965 1
d968 1
@


1.129
log
@do not umask() [with the wrong umask] around mkstemp() calls, no matter
how broken other systems are.
ok guenther gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.128 2015/10/09 14:37:38 gilles Exp $	*/
d934 4
@


1.128
log
@turn our local enqueuer setgid _smtpq and restrict access to offline queue,
the enqueuer will revoke group and regain real gid right after mkstemp.

this would have prevented the symlink/hardlink attacks against offline, and
it will avoid having to deal with new ways users can mess with it.

ok eric@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.127 2015/10/06 06:07:28 gilles Exp $	*/
a141 1
	mode_t	omode;
a148 1
	omode = umask(07077);
a153 1
	umask(omode);
@


1.127
log
@fix chdir() call for the sake of correctness

reported by qualys
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.126 2015/10/06 05:48:34 gilles Exp $	*/
d30 1
d56 1
d69 1
d132 35
d924 3
a926 1
	char	*argv_mailq[] = { "show", "queue", NULL };
d928 1
d931 6
d938 1
a938 1
		return (enqueue(argc, argv));
d943 3
@


1.126
log
@fix reallocarray() constructs to always use temporary variable
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.125 2015/01/20 17:37:54 deraadt Exp $	*/
d642 1
a642 1
		if (chroot(PATH_SPOOL) == -1 || chdir(".") == -1)
@


1.125
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.124 2014/07/20 01:38:40 guenther Exp $	*/
d305 1
a305 1
	static uint64_t	*evpids = NULL;
d321 1
a321 1
				evpids = reallocarray(evpids, alloc,
d323 1
a323 1
				if (evpids == NULL)
d325 1
@


1.124
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.123 2014/07/08 20:14:46 eric Exp $	*/
d43 1
d579 1
a579 1
	char	 buf[SMTPD_MAXPATHLEN];
d605 1
a605 1
	char	 buf[SMTPD_MAXPATHLEN];
d1032 1
a1032 1
	char	pathname[SMTPD_MAXPATHLEN];
@


1.123
log
@get rid of mfa leftovers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.121 2014/05/23 13:28:32 espie Exp $	*/
d1092 1
d1097 1
a1097 1
			err(1, "mkstemp");
@


1.122
log
@Allow to enable profiling at runtime and fix timings output.

ok gilles@@
@
text
@d1137 2
a1138 2
	if (!strcmp(str, "mfa"))
		return TRACE_MFA;
@


1.121
log
@use reallocarray
okay gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.120 2014/05/20 18:47:01 eric Exp $	*/
d503 1
a503 1
	srv_send(IMSG_CTL_PROFILE, &v, sizeof(v));
@


1.120
log
@format string cleanup: change "%i" to "%d" and fix a few typos
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.119 2014/04/22 13:57:58 gilles Exp $	*/
d320 2
a321 1
				evpids = realloc(evpids, alloc * sizeof(*evpids));
d323 1
a323 1
					err(1, "realloc");
@


1.119
log
@malloc -> calloc
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.118 2014/04/19 13:57:17 gilles Exp $	*/
d962 1
a962 1
			(void)snprintf(runstate, sizeof runstate, "pending|%zi",
d965 1
a965 1
			(void)snprintf(runstate, sizeof runstate, "inflight|%zi",
@


1.118
log
@(void) cast a strlcpy() that cannot truncate
(void) cast a few snprintf()/strlcat() that cannot truncate and that would
	be harmless if they could
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.117 2014/04/04 16:10:42 eric Exp $	*/
d310 1
a310 1
		evpids = malloc(alloc * sizeof(*evpids));
d312 1
a312 1
			err(1, "malloc");
@


1.117
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d114 1
a114 1
	strlcpy(sun.sun_path, SMTPD_SOCKET, sizeof(sun.sun_path));
d962 1
a962 1
			snprintf(runstate, sizeof runstate, "pending|%zi",
d965 1
a965 1
			snprintf(runstate, sizeof runstate, "inflight|%zi",
d968 1
a968 1
			snprintf(runstate, sizeof runstate, "invalid|");
d972 1
a972 1
		strlcpy(runstate, "offline|", sizeof runstate);
d1021 2
a1022 2
		strlcat(buf, bitstr, len);
		strlcat(buf, ",", len);
@


1.116
log
@new "smtpctl show status" command to show if mta/mda/smtp are currently running or paused.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.115 2014/02/04 15:22:39 eric Exp $	*/
d417 2
a418 2
		srv_send(IMSG_DIGEST, NULL, 0);
		srv_recv(IMSG_DIGEST);
d714 2
a715 2
		srv_send(IMSG_STATS_GET, &kv, sizeof kv);
		srv_recv(IMSG_STATS_GET);
d789 1
a789 1
	srv_send(IMSG_CTL_TRACE, &v, sizeof(v));
d800 1
a800 1
	srv_send(IMSG_CTL_UNPROFILE, &v, sizeof(v));
d811 1
a811 1
	srv_send(IMSG_CTL_UNTRACE, &v, sizeof(v));
d820 1
a820 1
	srv_send(IMSG_LKA_UPDATE_TABLE, name, strlen(name) + 1);
@


1.115
log
@Allow the admin to pause relaying to a specific domain:
 - smtpctl pause mta from <source> for <domain>
 - smtpctl resume mta from <source> for <domain>
 - smtpctl show mta paused
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d758 18
d929 1
@


1.114
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.113 2013/11/13 09:15:41 eric Exp $	*/
d122 1
a122 2
	if ((ibuf = calloc(1, sizeof(struct imsgbuf))) == NULL)
		err(1, "calloc");
d817 45
d878 3
@


1.113
log
@document smtpctl "show hosts" and "show relays".
add an encrypt wrapper usable for auth tables.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 1
a112 1
	bzero(&sun, sizeof(sun));
d414 1
a414 1
	bzero(&last, sizeof(last));
d712 1
a712 1
	bzero(&kv, sizeof kv);
@


1.112
log
@add "smtpctl show relays" and "smtpctl show hosts" commands
@
text
@d51 1
d807 11
d832 2
@


1.111
log
@Implement a feedback mechanism which allows the mta to "hold" envelopes
in the scheduler when it has too many tasks for a given relay.  The
envelopes are put on a wait queue, and are not scheduled again until
the mta "releases" some envelopes from that queue.

It prevents from having too many inflight envelopes, which are out of reach
for the admin.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.110 2013/10/25 21:31:23 eric Exp $	*/
d682 16
d846 2
@


1.110
log
@local enqueuer improvements:

- parse the whole input before trying to establish the connection
  to the local socket: fixes timeout problems when reading the output
  of a long running program.

- use sendmail(8)-like exit status.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d860 1
@


1.109
log
@Improve reporting in smtpctl and a few fixes.

When sending a request to the scheduler, wait for the success/failure
report from the scheduler.  Simplify the code by introducing generic
functions for interruptible iteration over envelopes.  Report the total
number of affected envelopes for schedule, pause, resume and remove
envelope operations.
@
text
@d728 1
a728 1
				printf("%s=%lli.%06li\n",
d798 1
a798 3
		if (srv_connect())
			return (enqueue(argc, argv));
		return (enqueue_offline(argc, argv));
@


1.108
log
@Many MTA improvements:

- Better transient error handling logic: failing destinations are
  automatically disabled for a while.  When a destination is active
  again, ask the scheduler to retry previous envelopes immediatly.
- More informative error report when all routes fail for a mail.
- Implement a "smtpctl show hoststats" command to get the latest stat
  message per MX domain.
- Implement a "smtpctl show routes" command to show the state the
  currently known routes to remote MXs.
- Implement a "smtpctl resume route" command to re-enable a route that
  has been disabled.
- Do not hardcode limits
- Minor code improvements
@
text
@d52 2
d101 1
a101 1
static int
d194 1
a194 1
srv_check_result(void)
d201 2
a202 1
		printf("command succeeded\n");
d205 6
a210 4
		if (rlen)
			printf("command failed: %s\n", rdata);
		else
			printf("command failed\n");
d302 88
d395 1
a395 1
	return srv_check_result();
d404 1
a404 1
	return srv_check_result();
d466 1
a466 2
	struct envelope	 evp;
	uint32_t	 msgid;
d468 2
a469 17
	if (argc == 0) {
		while (srv_iter_messages(&msgid)) {
			while (srv_iter_envelopes(msgid, &evp)) {
				srv_send(IMSG_CTL_PAUSE_EVP, &evp.id,
				    sizeof(evp.id));
				srv_check_result();
			}
		}
	} else if (argv[0].type == P_MSGID) {
		while (srv_iter_envelopes(argv[0].u.u_msgid, &evp)) {
			srv_send(IMSG_CTL_PAUSE_EVP, &evp.id, sizeof(evp.id));
			srv_check_result();
		}
	} else {
		srv_send(IMSG_CTL_PAUSE_EVP, &argv[0].u.u_evpid, sizeof(evp.id));
		srv_check_result();
	}
d478 1
a478 1
	return srv_check_result();
d485 1
a485 1
	return srv_check_result();
d492 1
a492 1
	return srv_check_result();
d503 1
a503 1
	return srv_check_result();
d509 1
a509 2
	struct envelope	 evp;
	uint32_t	 msgid;
d511 2
a512 17
	if (argc == 0) {
		while (srv_iter_messages(&msgid)) {
			while (srv_iter_envelopes(msgid, &evp)) {
				srv_send(IMSG_CTL_REMOVE, &evp.id,
				    sizeof(evp.id));
				srv_check_result();
			}
		}
	} else if (argv[0].type == P_MSGID) {
		while (srv_iter_envelopes(argv[0].u.u_msgid, &evp)) {
			srv_send(IMSG_CTL_REMOVE, &evp.id, sizeof(evp.id));
			srv_check_result();
		}
	} else {
		srv_send(IMSG_CTL_REMOVE, &argv[0].u.u_evpid, sizeof(evp.id));
		srv_check_result();
	}
d520 1
a520 2
	struct envelope	 evp;
	uint32_t	 msgid;
d522 2
a523 17
	if (argc == 0) {
		while (srv_iter_messages(&msgid)) {
			while (srv_iter_envelopes(msgid, &evp)) {
				srv_send(IMSG_CTL_RESUME_EVP, &evp.id,
				    sizeof(evp.id));
				srv_check_result();
			}
		}
	} else if (argv[0].type == P_MSGID) {
		while (srv_iter_envelopes(argv[0].u.u_msgid, &evp)) {
			srv_send(IMSG_CTL_RESUME_EVP, &evp.id, sizeof(evp.id));
			srv_check_result();
		}
	} else {
		srv_send(IMSG_CTL_RESUME_EVP, &argv[0].u.u_evpid, sizeof(evp.id));
		srv_check_result();
	}
d532 1
a532 1
	return srv_check_result();
d539 1
a539 1
	return srv_check_result();
d553 1
a553 1
	return srv_check_result();
d560 1
a560 1
	return srv_check_result();
d566 1
a566 2
	struct envelope	 evp;
	uint32_t	 msgid;
d568 2
a569 18
	if (argc == 0) {
		while (srv_iter_messages(&msgid)) {
			while (srv_iter_envelopes(msgid, &evp)) {
				srv_send(IMSG_CTL_SCHEDULE, &evp.id,
				    sizeof(evp.id));
				srv_check_result();
			}
		}

	} else if (argv[0].type == P_MSGID) {
		while (srv_iter_envelopes(argv[0].u.u_msgid, &evp)) {
			srv_send(IMSG_CTL_SCHEDULE, &evp.id, sizeof(evp.id));
			srv_check_result();
		}
	} else {
		srv_send(IMSG_CTL_SCHEDULE, &argv[0].u.u_evpid, sizeof(evp.id));
		srv_check_result();
	}
d595 1
a595 10
	srv_send(IMSG_CTL_MTA_SHOW_HOSTSTATS, NULL, 0);

	do {
		srv_recv(IMSG_CTL_MTA_SHOW_HOSTSTATS);
		if (rlen) {
			printf("%s\n", rdata);
			srv_read(NULL, rlen);
		}
		srv_end();
	} while (rlen);
d684 1
a684 10
	srv_send(IMSG_CTL_MTA_SHOW_ROUTES, NULL, 0);

	do {
		srv_recv(IMSG_CTL_MTA_SHOW_ROUTES);
		if (rlen) {
			printf("%s\n", rdata);
			srv_read(NULL, rlen);
		}
		srv_end();
	} while (rlen);
d745 1
a745 1
	return srv_check_result();
d756 1
a756 1
	return srv_check_result();
d767 1
a767 1
	return srv_check_result();
d778 1
a778 1
	return srv_check_result();
d787 1
a787 1
	return srv_check_result();
d950 1
a950 1
	buflen = fread(buffer, 1, sizeof buffer, fp);
d953 1
d1017 1
a1017 1
		fseek(fp, SEEK_SET, 0);
d1021 1
d1095 1
a1095 1
	fseek(fp, SEEK_SET, 0);
d1129 1
a1129 1
	fseek(fp, SEEK_SET, 0);
@


1.107
log
@scheduler improvements:
- implement suspend/resume scheduling for individual envelopes or message,
  with the associated smtpctl commands.
- allow the mta to request immediate scheduling of an envelope.
- on temporary failures a penalty can be given to further delay the next try.
@
text
@d498 14
d565 17
d663 17
d811 1
d817 1
d822 1
@


1.106
log
@New implementation for smtpctl and the command line parser.  Allows
richer syntax, and makes the code way simpler to follow and extend
with new commands.
@
text
@d371 27
d457 27
d751 2
d759 2
d800 1
@


1.105
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.104 2013/05/24 17:03:14 eric Exp $	*/
d4 1
d34 1
a47 1
#define PATH_CAT	"/bin/cat"
d49 1
a52 4
static void setup_env(struct smtpd *);
static int show_command_output(struct imsg *);
static void show_stats_output(void);
static void show_queue(int);
d56 11
a66 15
static void show_envelope(const char *);
static void show_message(const char *);
static void show_monitor(struct stat_digest *);

static int try_connect(void);
static void flush(void);
static void next_message(struct imsg *);
static int action_schedule_all(void);

static int action_show_queue(void);
static int action_show_queue_message(uint32_t);
static uint32_t trace_convert(uint32_t);
static uint32_t profile_convert(uint32_t);

int proctype;
d68 4
a71 7

int sendmail = 0;
extern char *__progname;

struct smtpd	*env = NULL;

time_t now;
d74 1
d91 1
a91 2
static void
setup_env(struct smtpd *smtpd)
d93 1
a93 2
	bzero(smtpd, sizeof (*smtpd));
	env = smtpd;
d95 2
a96 2
	if (!queue_init("fs", 0))
		errx(1, "invalid directory permissions");
d100 1
a100 1
try_connect(void)
d127 1
a127 1
flush(void)
d134 9
a142 1
next_message(struct imsg *imsg)
d146 2
d149 1
a149 1
		if ((n = imsg_get(ibuf, imsg)) == -1)
d151 11
a161 2
		if (n)
			return;
d170 23
a192 2
int
main(int argc, char *argv[])
d194 2
a195 9
	struct parse_result	*res = NULL;
	struct imsg		imsg;
	struct smtpd		smtpd;
	uint64_t		ulval;
	char			name[SMTPD_MAXLINESIZE];
	int			done = 0;
	int			verb = 0;
	int			profile = 0;
	int			action = -1;
d197 12
a208 7
	/* parse options */
	if (strcmp(__progname, "sendmail") == 0 ||
	    strcmp(__progname, "send-mail") == 0) {
		sendmail = 1;
		if (try_connect())
			return (enqueue(argc, argv));
		return (enqueue_offline(argc, argv));
d210 2
d213 9
a221 2
	if (geteuid())
		errx(1, "need root privileges");
d223 7
a229 25
	if (strcmp(__progname, "mailq") == 0)
		action = SHOW_QUEUE;
	else if (strcmp(__progname, "smtpctl") == 0) {
		if ((res = parse(argc - 1, argv + 1)) == NULL)
			exit(1);
		action = res->action;
	} else
		errx(1, "unsupported mode");

	if (action == SHOW_ENVELOPE ||
	    action == SHOW_MESSAGE ||
	    !try_connect()) {
		setup_env(&smtpd);
		switch (action) {
		case SHOW_QUEUE:
			show_queue(0);
			break;
		case SHOW_ENVELOPE:
			show_envelope(res->data);
			break;
		case SHOW_MESSAGE:
			show_message(res->data);
			break;
		default:
			errx(1, "smtpd doesn't seem to be running");
d231 15
a245 1
		return (0);
d248 2
a249 127
	/* process user request */
	switch (action) {
	case NONE:
		usage();
		/* not reached */

	case SCHEDULE:
		if (! strcmp(res->data, "all"))
			return action_schedule_all();

		if ((ulval = text_to_evpid(res->data)) == 0)
			errx(1, "invalid msgid/evpid");
		imsg_compose(ibuf, IMSG_CTL_SCHEDULE, IMSG_VERSION, 0, -1, &ulval,
		    sizeof(ulval));
		break;
	case REMOVE:
		if ((ulval = text_to_evpid(res->data)) == 0)
			errx(1, "invalid msgid/evpid");
		imsg_compose(ibuf, IMSG_CTL_REMOVE, IMSG_VERSION, 0, -1, &ulval,
		    sizeof(ulval));
		break;
	case SHOW_QUEUE:
		return action_show_queue();
	case SHUTDOWN:
		imsg_compose(ibuf, IMSG_CTL_SHUTDOWN, IMSG_VERSION, 0, -1, NULL, 0);
		break;
	case PAUSE_MDA:
		imsg_compose(ibuf, IMSG_CTL_PAUSE_MDA, IMSG_VERSION, 0, -1, NULL, 0);
		break;
	case PAUSE_MTA:
		imsg_compose(ibuf, IMSG_CTL_PAUSE_MTA, IMSG_VERSION, 0, -1, NULL, 0);
		break;
	case PAUSE_SMTP:
		imsg_compose(ibuf, IMSG_CTL_PAUSE_SMTP, IMSG_VERSION, 0, -1, NULL, 0);
		break;
	case RESUME_MDA:
		imsg_compose(ibuf, IMSG_CTL_RESUME_MDA, IMSG_VERSION, 0, -1, NULL, 0);
		break;
	case RESUME_MTA:
		imsg_compose(ibuf, IMSG_CTL_RESUME_MTA, IMSG_VERSION, 0, -1, NULL, 0);
		break;
	case RESUME_SMTP:
		imsg_compose(ibuf, IMSG_CTL_RESUME_SMTP, IMSG_VERSION, 0, -1, NULL, 0);
		break;
	case SHOW_STATS:
		imsg_compose(ibuf, IMSG_STATS, IMSG_VERSION, 0, -1, NULL, 0);
		break;
	case UPDATE_TABLE:
		if (strlcpy(name, res->data, sizeof name) >= sizeof name)
			errx(1, "table name too long.");
		imsg_compose(ibuf, IMSG_LKA_UPDATE_TABLE, IMSG_VERSION, 0, -1,
		    name, strlen(name) + 1);
		done = 1;
		break;
	case MONITOR:
		while (1) {
			imsg_compose(ibuf, IMSG_DIGEST, IMSG_VERSION, 0, -1, NULL, 0);
			flush();
			next_message(&imsg);
			show_monitor(imsg.data);
			imsg_free(&imsg);
			sleep(1);
		}
		break;
	case LOG_VERBOSE:
		verb = TRACE_DEBUG;
		/* FALLTHROUGH */
	case LOG_BRIEF:
		imsg_compose(ibuf, IMSG_CTL_VERBOSE, IMSG_VERSION, 0, -1, &verb,
		    sizeof(verb));
		printf("logging request sent.\n");
		done = 1;
		break;

	case LOG_TRACE_IMSG:
	case LOG_TRACE_IO:
	case LOG_TRACE_SMTP:
	case LOG_TRACE_MFA:
	case LOG_TRACE_MTA:
	case LOG_TRACE_BOUNCE:
	case LOG_TRACE_SCHEDULER:
	case LOG_TRACE_LOOKUP:
	case LOG_TRACE_STAT:
	case LOG_TRACE_RULES:
	case LOG_TRACE_MPROC:
	case LOG_TRACE_EXPAND:
	case LOG_TRACE_ALL:
		verb = trace_convert(action);
		imsg_compose(ibuf, IMSG_CTL_TRACE, IMSG_VERSION, 0, -1, &verb,
		    sizeof(verb));
		done = 1;
		break;

	case LOG_UNTRACE_IMSG:
	case LOG_UNTRACE_IO:
	case LOG_UNTRACE_SMTP:
	case LOG_UNTRACE_MFA:
	case LOG_UNTRACE_MTA:
	case LOG_UNTRACE_BOUNCE:
	case LOG_UNTRACE_SCHEDULER:
	case LOG_UNTRACE_LOOKUP:
	case LOG_UNTRACE_STAT:
	case LOG_UNTRACE_RULES:
	case LOG_UNTRACE_MPROC:
	case LOG_UNTRACE_EXPAND:
	case LOG_UNTRACE_ALL:
		verb = trace_convert(action);
		imsg_compose(ibuf, IMSG_CTL_UNTRACE, IMSG_VERSION, 0, -1, &verb,
		    sizeof(verb));
		done = 1;
		break;

	case LOG_PROFILE_IMSG:
	case LOG_PROFILE_QUEUE:
		profile = profile_convert(action);
		imsg_compose(ibuf, IMSG_CTL_PROFILE, IMSG_VERSION, 0, -1, &profile,
		    sizeof(profile));
		done = 1;
		break;

	case LOG_UNPROFILE_IMSG:
	case LOG_UNPROFILE_QUEUE:
		profile = profile_convert(action);
		imsg_compose(ibuf, IMSG_CTL_UNPROFILE, IMSG_VERSION, 0, -1, &profile,
		    sizeof(profile));
		done = 1;
		break;
d251 15
a265 2
	default:
		errx(1, "unknown request (%d)", action);
d268 2
a269 3
	do {
		flush();
		next_message(&imsg);
d271 13
a283 4
		/* ANY command can return IMSG_CTL_FAIL if version mismatch */
		if (imsg.hdr.type == IMSG_CTL_FAIL) {
			show_command_output(&imsg);
			break;
d285 19
d305 14
a318 53
		switch (action) {
		case REMOVE:
		case SCHEDULE:
		case SHUTDOWN:
		case PAUSE_MDA:
		case PAUSE_MTA:
		case PAUSE_SMTP:
		case RESUME_MDA:
		case RESUME_MTA:
		case RESUME_SMTP:
		case LOG_VERBOSE:
		case LOG_BRIEF:
		case LOG_TRACE_IMSG:
		case LOG_TRACE_IO:
		case LOG_TRACE_SMTP:
		case LOG_TRACE_MFA:
		case LOG_TRACE_MTA:
		case LOG_TRACE_BOUNCE:
		case LOG_TRACE_SCHEDULER:
		case LOG_TRACE_LOOKUP:
		case LOG_TRACE_STAT:
		case LOG_TRACE_RULES:
		case LOG_TRACE_MPROC:
		case LOG_TRACE_EXPAND:
		case LOG_TRACE_ALL:
		case LOG_UNTRACE_IMSG:
		case LOG_UNTRACE_IO:
		case LOG_UNTRACE_SMTP:
		case LOG_UNTRACE_MFA:
		case LOG_UNTRACE_MTA:
		case LOG_UNTRACE_BOUNCE:
		case LOG_UNTRACE_SCHEDULER:
		case LOG_UNTRACE_LOOKUP:
		case LOG_UNTRACE_STAT:
		case LOG_UNTRACE_RULES:
		case LOG_UNTRACE_MPROC:
		case LOG_UNTRACE_EXPAND:
		case LOG_UNTRACE_ALL:
		case LOG_PROFILE_IMSG:
		case LOG_PROFILE_QUEUE:
		case LOG_UNPROFILE_IMSG:
		case LOG_UNPROFILE_QUEUE:
			done = show_command_output(&imsg);
			break;
		case SHOW_STATS:
			show_stats_output();
			done = 1;
			break;
		case NONE:
			break;
		case UPDATE_TABLE:
			break;
		case MONITOR:
d320 2
a321 3
		default:
			err(1, "unexpected reply (%d)", action);
		}
d323 43
a365 3
		imsg_free(&imsg);
	} while (!done);
	free(ibuf);
d370 6
d378 1
a378 1
action_show_queue_message(uint32_t msgid)
d380 3
a382 4
	struct imsg	 imsg;
	struct envelope	*evp;
	uint64_t	 evpid;
	size_t		 found;
d384 6
a389 1
	evpid = msgid_to_evpid(msgid);
d391 6
a396 1
    nextbatch:
d398 3
a400 4
	found = 0;
	imsg_compose(ibuf, IMSG_CTL_LIST_ENVELOPES, IMSG_VERSION, 0, -1,
	    &evpid, sizeof evpid);
	flush();
d402 5
a406 4
	while (1) {
		next_message(&imsg);
		if (imsg.hdr.type != IMSG_CTL_LIST_ENVELOPES)
			errx(1, "unexpected message %i", imsg.hdr.type);
d408 7
a414 5
		if (imsg.hdr.len == sizeof imsg.hdr) {
			imsg_free(&imsg);
			if (!found || evpid_to_msgid(++evpid) != msgid)
				return (0);
			goto nextbatch;
d416 8
a423 5
		found++;
		evp = imsg.data;
		evpid = evp->id;
		show_queue_envelope(evp, 1);
		imsg_free(&imsg);
d426 15
d444 1
a444 1
action_show_queue(void)
d446 3
a448 3
	struct imsg	 imsg;
	uint32_t	*msgids, msgid;
	size_t		 i, n;
d450 5
a454 2
	msgid = 0;
	now = time(NULL);
d456 7
a462 16
	do {
		imsg_compose(ibuf, IMSG_CTL_LIST_MESSAGES, IMSG_VERSION, 0, -1,
		    &msgid, sizeof msgid);
		flush();
		next_message(&imsg);
		if (imsg.hdr.type != IMSG_CTL_LIST_MESSAGES)
			errx(1, "unexpected message type %i", imsg.hdr.type);
		msgids = imsg.data;
		n = (imsg.hdr.len - sizeof imsg.hdr) / sizeof (*msgids);
		if (n == 0) {
			imsg_free(&imsg);
			break;
		}
		for (i = 0; i < n; i++) {
			msgid = msgids[i];
			action_show_queue_message(msgid);
a463 1
		imsg_free(&imsg);
d465 9
a473 1
	} while (++msgid);
d479 1
a479 1
action_schedule_all(void)
d481 11
a491 4
	struct imsg	 imsg;
	uint32_t	*msgids, from;
	uint64_t	 evpid;
	size_t		 i, n;
d493 2
a494 12
	from = 0;
	while (1) {
		imsg_compose(ibuf, IMSG_CTL_LIST_MESSAGES, IMSG_VERSION, 0, -1,
		    &from, sizeof from);
		flush();
		next_message(&imsg);
		if (imsg.hdr.type != IMSG_CTL_LIST_MESSAGES)
			errx(1, "unexpected message type %i", imsg.hdr.type);
		msgids = imsg.data;
		n = (imsg.hdr.len - sizeof imsg.hdr) / sizeof (*msgids);
		if (n == 0)
			break;
d496 5
a500 6
		for (i = 0; i < n; i++) {
			evpid = msgids[i];
			imsg_compose(ibuf, IMSG_CTL_SCHEDULE, IMSG_VERSION,
			    0, -1, &evpid, sizeof(evpid));
		}
		from = msgids[n - 1] + 1;
d502 4
a505 2
		imsg_free(&imsg);
		flush();
d507 6
a512 6
		for (i = 0; i < n; i++) {
			next_message(&imsg);
			if (imsg.hdr.type != IMSG_CTL_OK)
				errx(1, "unexpected message type %i",
				    imsg.hdr.type);
		}
d514 1
a514 3
		if (from == 0)
			break;
	}
d520 1
a520 1
show_command_output(struct imsg *imsg)
d522 50
a571 12
	switch (imsg->hdr.type) {
	case IMSG_CTL_OK:
		printf("command succeeded\n");
		break;
	case IMSG_CTL_FAIL:
		if (imsg->hdr.peerid != IMSG_VERSION)
			printf("command failed: incompatible smtpctl and smtpd\n");
		else
			printf("command failed\n");
		break;
	default:
		errx(1, "wrong message in summary: %u", imsg->hdr.type);
d573 2
a574 1
	return (1);
d577 2
a578 2
static void
show_stats_output(void)
d580 1
a580 2
	struct stat_kv	kv, *kvp;
	struct imsg	imsg;
d586 7
a592 11
		imsg_compose(ibuf, IMSG_STATS_GET, IMSG_VERSION, 0, -1, &kv, sizeof kv);
		flush();
		next_message(&imsg);
		if (imsg.hdr.type != IMSG_STATS_GET)
			errx(1, "invalid imsg type");

		kvp = imsg.data;
		if (kvp->iter == NULL) {
			imsg_free(&imsg);
			return;
		}
d594 3
a596 3
		if (strcmp(kvp->key, "uptime") == 0) {
			duration = time(NULL) - kvp->val.u.counter;
			printf("uptime=%zd\n", (size_t)duration);
d601 1
a601 1
			switch (kvp->val.type) {
d604 1
a604 1
				    kvp->key, kvp->val.u.counter);
d608 1
a608 1
				    kvp->key, (int64_t)kvp->val.u.timestamp);
d611 3
a613 3
				printf("%s=%zd.%zd\n",
				    kvp->key, kvp->val.u.tv.tv_sec,
				    kvp->val.u.tv.tv_usec);
d616 5
a620 5
				printf("%s=%li.%06li\n",
				    kvp->key,
				    kvp->val.u.ts.tv_sec * 1000000 +
				    kvp->val.u.ts.tv_nsec / 1000000,
				    kvp->val.u.ts.tv_nsec % 1000000);
d624 22
d647 29
a675 3
		kv = *kvp;
		imsg_free(&imsg);
	}
d678 2
a679 2
static void
show_queue(flags)
d681 9
a689 2
	struct envelope	 envelope;
	int		 r;
d691 2
a692 1
	log_init(1);
d694 34
a727 2
	if (chroot(PATH_SPOOL) == -1 || chdir(".") == -1)
		err(1, "%s", PATH_SPOOL);
a728 3
	while ((r = queue_envelope_walk(&envelope)) != -1)
		if (r)
			show_queue_envelope(&envelope, flags);
d739 3
a741 6
	getflag(&e->flags, EF_BOUNCE, "bounce",
	    status, sizeof(status));
	getflag(&e->flags, EF_AUTHENTICATED, "auth",
	    status, sizeof(status));
	getflag(&e->flags, EF_INTERNAL, "internal",
	    status, sizeof(status));
d810 1
a810 31
display(const char *s)
{
	pid_t	pid;
	arglist args;
	char	*cmd;
	int	status;

	pid = fork();
	if (pid < 0)
		err(1, "fork");
	if (pid == 0) {
		cmd = PATH_GZCAT;
		bzero(&args, sizeof(args));
		addargs(&args, "%s", cmd);
		addargs(&args, "%s", s);
		execvp(cmd, args.list);
		err(1, "execvp");
	}
	wait(&status);
	if (WIFEXITED(status) && WEXITSTATUS(status) == 0)
		exit(0);
	cmd = PATH_CAT;
	bzero(&args, sizeof(args));
	addargs(&args, "%s", cmd);
	addargs(&args, "%s", s);
	execvp(cmd, args.list);
	err(1, "execvp");
}

static void
show_envelope(const char *s)
d812 6
a817 2
	char	 buf[SMTPD_MAXPATHLEN];
	uint64_t evpid;
d819 1
a819 2
	if ((evpid = text_to_evpid(s)) == 0)
		errx(1, "invalid msgid/evpid");
d821 2
a822 3
	if (! bsnprintf(buf, sizeof(buf), "%s%s/%02x/%08x/%016" PRIx64,
		PATH_SPOOL,
		PATH_QUEUE,
d824 28
a851 5
		evpid_to_msgid(evpid),
		evpid))
		errx(1, "unable to retrieve envelope");

	display(buf);
d855 1
a855 1
show_message(const char *s)
d857 23
a879 3
	char	 buf[SMTPD_MAXPATHLEN];
	uint32_t msgid;
	uint64_t evpid;
d881 7
a887 2
	if ((evpid = text_to_evpid(s)) == 0)
		errx(1, "invalid msgid/evpid");
d889 4
a892 7
	msgid = evpid_to_msgid(evpid);
	if (! bsnprintf(buf, sizeof(buf), "%s%s/%02x/%08x/message",
		PATH_SPOOL,
		PATH_QUEUE,
		(evpid_to_msgid(evpid) & 0xff000000) >> 24,
		msgid))
		errx(1, "unable to retrieve message");
d894 12
a905 1
	display(buf);
d908 2
a909 2
static void
show_monitor(struct stat_digest *d)
d911 1
a911 52
	static int init = 0;
	static size_t count = 0;
	static struct stat_digest last;

	if (init == 0) {
		init = 1;
		bzero(&last, sizeof last);
	}

	if (count % 25 == 0) {
		if (count != 0)
			printf("\n");
		printf("--- client ---  "
		    "-- envelope --   "
		    "---- relay/delivery --- "
		    "------- misc -------\n"
		    "curr conn disc  "
		    "curr  enq  deq   "
		    "ok tmpfail prmfail loop "
		    "expire remove bounce\n");
	}
	printf("%4zu %4zu %4zu  "
	    "%4zu %4zu %4zu "
	    "%4zu    %4zu    %4zu %4zu   "
	    "%4zu   %4zu   %4zu\n",
	    d->clt_connect - d->clt_disconnect,
	    d->clt_connect - last.clt_connect,
	    d->clt_disconnect - last.clt_disconnect,

	    d->evp_enqueued - d->evp_dequeued,
	    d->evp_enqueued - last.evp_enqueued,
	    d->evp_dequeued - last.evp_dequeued,

	    d->dlv_ok - last.dlv_ok,
	    d->dlv_tempfail - last.dlv_tempfail,
	    d->dlv_permfail - last.dlv_permfail,
	    d->dlv_loop - last.dlv_loop,

	    d->evp_expired - last.evp_expired,
	    d->evp_removed - last.evp_removed,
	    d->evp_bounce - last.evp_bounce);

	last = *d;
	count++;
}

static uint32_t
trace_convert(uint32_t trace)
{
	switch (trace) {
	case LOG_TRACE_IMSG:
	case LOG_UNTRACE_IMSG:
d913 1
a913 3

	case LOG_TRACE_IO:
	case LOG_UNTRACE_IO:
d915 1
a915 3

	case LOG_TRACE_SMTP:
	case LOG_UNTRACE_SMTP:
d917 1
a917 3

	case LOG_TRACE_MFA:
	case LOG_UNTRACE_MFA:
d919 21
d941 10
a950 3
	case LOG_TRACE_MTA:
	case LOG_UNTRACE_MTA:
		return TRACE_MTA;
d952 4
a955 3
	case LOG_TRACE_BOUNCE:
	case LOG_UNTRACE_BOUNCE:
		return TRACE_BOUNCE;
d957 4
a960 3
	case LOG_TRACE_SCHEDULER:
	case LOG_UNTRACE_SCHEDULER:
		return TRACE_SCHEDULER;
d962 5
a966 3
	case LOG_TRACE_LOOKUP:
	case LOG_UNTRACE_LOOKUP:
		return TRACE_LOOKUP;
d968 2
a969 3
	case LOG_TRACE_STAT:
	case LOG_UNTRACE_STAT:
		return TRACE_STAT;
d971 5
a975 3
	case LOG_TRACE_RULES:
	case LOG_UNTRACE_RULES:
		return TRACE_RULES;
a976 3
	case LOG_TRACE_MPROC:
	case LOG_UNTRACE_MPROC:
		return TRACE_MPROC;
d978 7
a984 3
	case LOG_TRACE_EXPAND:
	case LOG_UNTRACE_EXPAND:
		return TRACE_EXPAND;
d986 4
a989 4
	case LOG_TRACE_ALL:
	case LOG_UNTRACE_ALL:
		return ~TRACE_DEBUG;
	}
d991 3
a993 1
	return 0;
d996 2
a997 2
static uint32_t
profile_convert(uint32_t prof)
d999 2
a1000 4
	switch (prof) {
	case LOG_PROFILE_IMSG:
	case LOG_UNPROFILE_IMSG:
		return PROFILE_IMSG;
d1002 2
a1003 4
	case LOG_PROFILE_QUEUE:
	case LOG_UNPROFILE_QUEUE:
		return PROFILE_QUEUE;
	}
d1005 4
a1008 1
	return 0;
@


1.104
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.101 2013/02/14 12:30:49 gilles Exp $	*/
a103 13

	if ((env->sc_pw = getpwnam(SMTPD_USER)) == NULL)
		errx(1, "unknown user %s", SMTPD_USER);
	if ((env->sc_pw = pw_dup(env->sc_pw)) == NULL)
		err(1, NULL);

	env->sc_pwqueue = getpwnam(SMTPD_QUEUE_USER);
	if (env->sc_pwqueue)
		env->sc_pwqueue = pw_dup(env->sc_pwqueue);
	else
		env->sc_pwqueue = pw_dup(env->sc_pw);
	if (env->sc_pwqueue == NULL)
		err(1, NULL);
@


1.103
log
@large time_t problems
ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.102 2013/04/12 18:22:49 eric Exp $	*/
d28 1
a28 1
#include <sys/param.h>
d47 1
a47 1
#define PATH_GZCAT	"/bin/gzcat"
d240 1
a240 1
		imsg_compose(ibuf, IMSG_CTL_SCHEDULE, 0, 0, -1, &ulval,
d246 1
a246 1
		imsg_compose(ibuf, IMSG_CTL_REMOVE, 0, 0, -1, &ulval,
d252 1
a252 1
		imsg_compose(ibuf, IMSG_CTL_SHUTDOWN, 0, 0, -1, NULL, 0);
d255 1
a255 1
		imsg_compose(ibuf, IMSG_CTL_PAUSE_MDA, 0, 0, -1, NULL, 0);
d258 1
a258 1
		imsg_compose(ibuf, IMSG_CTL_PAUSE_MTA, 0, 0, -1, NULL, 0);
d261 1
a261 1
		imsg_compose(ibuf, IMSG_CTL_PAUSE_SMTP, 0, 0, -1, NULL, 0);
d264 1
a264 1
		imsg_compose(ibuf, IMSG_CTL_RESUME_MDA, 0, 0, -1, NULL, 0);
d267 1
a267 1
		imsg_compose(ibuf, IMSG_CTL_RESUME_MTA, 0, 0, -1, NULL, 0);
d270 1
a270 1
		imsg_compose(ibuf, IMSG_CTL_RESUME_SMTP, 0, 0, -1, NULL, 0);
d273 1
a273 1
		imsg_compose(ibuf, IMSG_STATS, 0, 0, -1, NULL, 0);
d278 1
a278 1
		imsg_compose(ibuf, IMSG_LKA_UPDATE_TABLE, 0, 0, -1,
d284 1
a284 1
			imsg_compose(ibuf, IMSG_DIGEST, 0, 0, -1, NULL, 0);
d293 1
a293 1
		verb = TRACE_VERBOSE;
d296 1
a296 1
		imsg_compose(ibuf, IMSG_CTL_VERBOSE, 0, 0, -1, &verb,
d312 1
a312 1
	case LOG_TRACE_IMSG_SIZE:
d316 1
a316 1
		imsg_compose(ibuf, IMSG_CTL_TRACE, 0, 0, -1, &verb,
d331 1
a331 1
	case LOG_UNTRACE_IMSG_SIZE:
d335 1
a335 1
		imsg_compose(ibuf, IMSG_CTL_UNTRACE, 0, 0, -1, &verb,
d343 1
a343 1
		imsg_compose(ibuf, IMSG_CTL_PROFILE, 0, 0, -1, &profile,
d351 1
a351 1
		imsg_compose(ibuf, IMSG_CTL_UNPROFILE, 0, 0, -1, &profile,
d364 6
d392 1
a392 1
		case LOG_TRACE_IMSG_SIZE:
d405 1
a405 1
		case LOG_UNTRACE_IMSG_SIZE:
d449 1
a449 1
	imsg_compose(ibuf, IMSG_CTL_LIST_ENVELOPES, 0, 0, -1,
d484 1
a484 1
		imsg_compose(ibuf, IMSG_CTL_LIST_MESSAGES, 0, 0, -1,
d517 1
a517 1
		imsg_compose(ibuf, IMSG_CTL_LIST_MESSAGES, 0, 0, -1,
d530 1
a530 1
			imsg_compose(ibuf, IMSG_CTL_SCHEDULE, 0,
d560 4
a563 1
		printf("command failed\n");
d581 1
a581 1
		imsg_compose(ibuf, IMSG_STATS_GET, 0, 0, -1, &kv, sizeof kv);
d595 1
a595 1
			printf("uptime=%lld\n", (long long)duration);
d610 2
a611 2
				printf("%s=%lld.%ld\n",
				    kvp->key, (long long)kvp->val.u.tv.tv_sec,
d729 1
d732 1
d734 4
a737 1
	if (env->sc_queue_flags & QUEUE_COMPRESS)
d739 10
a748 3
	else
		cmd = PATH_CAT;

d753 1
a753 1
	errx(1, "execvp");
d759 1
a759 1
	char	 buf[MAXPATHLEN];
d779 1
a779 1
	char	 buf[MAXPATHLEN];
d788 4
a791 4
	    PATH_SPOOL,
	    PATH_QUEUE,
	    msgid & 0xff,
	    msgid))
d890 3
a892 3
	case LOG_TRACE_IMSG_SIZE:
	case LOG_UNTRACE_IMSG_SIZE:
		return TRACE_IMSGSIZE;
d900 1
a900 1
		return ~TRACE_VERBOSE;
@


1.102
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.101 2013/02/14 12:30:49 gilles Exp $	*/
d586 1
a586 1
			printf("uptime=%zd\n", (size_t)duration);
d601 2
a602 2
				printf("%s=%zd.%zd\n",
				    kvp->key, kvp->val.u.tv.tv_sec,
@


1.101
log
@- smtpctl trace expand, enables tracing of aliases expansion
- replace "users" keyword with "userbase" when providing alternate userbase
- disambiguise expansion nodes when expanding across domains and userbases
- allow use of '=' instead of '=>' when declaring a mapping

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.100 2013/01/28 11:09:53 gilles Exp $	*/
d181 1
a181 1
	char			name[MAX_LINE_SIZE];
@


1.100
log
@- introduce 'smtpctl trace lookup' to trace lookup process
- improve logging of the transfer process

trace by me, logging by eric
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.99 2013/01/26 09:37:23 gilles Exp $	*/
d313 1
d332 1
d387 1
d400 1
d872 4
@


1.99
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.95 2012/11/12 14:58:53 eric Exp $	*/
d309 1
d327 1
d381 1
d393 1
d852 4
@


1.98
log
@Replace the qwalk API (to retreive on disk envelopes at runtime) with
a simple QOP_WALK queue operation. Some knf and formating fixes while
there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.97 2012/11/20 09:47:46 eric Exp $	*/
d4 1
d69 2
d82 3
d107 2
d110 7
a116 3
	env->sc_queue = queue_backend_lookup("fs");
	if (env->sc_queue == NULL)
		errx(1, "could not find queue backend");
d118 1
a118 1
	if (!env->sc_queue->init(0))
d183 2
a184 1
	int			verbose = 0;
d235 6
a240 2
		ulval = strtoevpid(res->data);
		imsg_compose(ibuf, IMSG_SCHEDULER_SCHEDULE, 0, 0, -1, &ulval,
d244 3
a246 2
		ulval = strtoevpid(res->data);
		imsg_compose(ibuf, IMSG_SCHEDULER_REMOVE, 0, 0, -1, &ulval,
a250 2
	case SCHEDULE_ALL:
		return action_schedule_all();
d255 1
a255 1
		imsg_compose(ibuf, IMSG_QUEUE_PAUSE_MDA, 0, 0, -1, NULL, 0);
d258 1
a258 1
		imsg_compose(ibuf, IMSG_QUEUE_PAUSE_MTA, 0, 0, -1, NULL, 0);
d261 1
a261 1
		imsg_compose(ibuf, IMSG_SMTP_PAUSE, 0, 0, -1, NULL, 0);
d264 1
a264 1
		imsg_compose(ibuf, IMSG_QUEUE_RESUME_MDA, 0, 0, -1, NULL, 0);
d267 1
a267 1
		imsg_compose(ibuf, IMSG_QUEUE_RESUME_MTA, 0, 0, -1, NULL, 0);
d270 1
a270 1
		imsg_compose(ibuf, IMSG_SMTP_RESUME, 0, 0, -1, NULL, 0);
d275 1
a275 1
	case UPDATE_MAP:
d277 2
a278 2
			errx(1, "map name too long.");
		imsg_compose(ibuf, IMSG_LKA_UPDATE_MAP, 0, 0, -1,
a282 1
		done = 1;
d293 1
a293 1
		verbose = 1;
d296 2
a297 2
		imsg_compose(ibuf, IMSG_CTL_VERBOSE, 0, 0, -1, &verbose,
		    sizeof(verbose));
d301 51
d372 26
d406 1
a406 1
		case UPDATE_MAP:
d435 1
a435 1
	imsg_compose(ibuf, IMSG_SCHEDULER_ENVELOPES, 0, 0, -1,
d441 1
a441 1
		if (imsg.hdr.type != IMSG_SCHEDULER_ENVELOPES)
d470 1
a470 1
		imsg_compose(ibuf, IMSG_SCHEDULER_MESSAGES, 0, 0, -1,
d474 1
a474 1
		if (imsg.hdr.type != IMSG_SCHEDULER_MESSAGES)
d503 1
a503 1
		imsg_compose(ibuf, IMSG_SCHEDULER_MESSAGES, 0, 0, -1,
d507 1
a507 1
		if (imsg.hdr.type != IMSG_SCHEDULER_MESSAGES)
d516 1
a516 1
			imsg_compose(ibuf, IMSG_SCHEDULER_SCHEDULE, 0,
d613 1
a613 1
show_queue(int flags)
d636 1
a636 1
	getflag(&e->flags, DF_BOUNCE, "bounce",
d638 1
a638 1
	getflag(&e->flags, DF_AUTHENTICATED, "auth",
d640 1
a640 1
	getflag(&e->flags, DF_INTERNAL, "internal",
d644 1
a644 1
		if (e->flags & DF_PENDING)
d647 1
a647 1
		else if (e->flags & DF_INFLIGHT)
d652 1
a652 1
		e->flags &= ~(DF_PENDING|DF_INFLIGHT);
d733 9
a741 7
	evpid = strtoevpid(s);
	if (! bsnprintf(buf, sizeof(buf), "%s%s/%02x/%08x%s/%016" PRIx64,
	    PATH_SPOOL,
	    PATH_QUEUE,
	    evpid_to_msgid(evpid) & 0xff,
	    evpid_to_msgid(evpid),
	    PATH_ENVELOPES, evpid))
d752 4
d757 1
a757 1
	msgid = evpid_to_msgid(strtoevpid(s));
d815 68
@


1.97
log
@Allow "smtpctl show queue" to run in "online" mode if the smtpd server
is running.  The scheduler sends the runtime state of each envelope to
the queue process which loads the envelope, fills the runtime bits and
sends the envelope back to the client. Iteration over the envelope set
happens in small chunks to make the request interruptible and to allow
the server to keep doing its job in the meantime.

Adpat "smtpctl schedule-all" to schedule the messages one by one using
the same iteration mechanism.

Document "smtpctl monitor" and "smtpctl show queue".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.95 2012/11/12 14:58:53 eric Exp $	*/
a522 1
	struct qwalk	*q;
d524 1
a524 1
	uint64_t	 evpid;
d531 3
a533 9
	q = qwalk_new(0);

	while (qwalk(q, &evpid)) {
		if (! queue_envelope_load(evpid, &envelope))
			continue;
		show_queue_envelope(&envelope, flags);
	}

	qwalk_close(q);
a534 1

@


1.96
log
@Simplify the smtpctl code: add a try_connect() function to test if
the server is running, and flush()/next_message() helpers to make
imsg request/response loops easier.

ok gilles@@
@
text
@d64 4
d77 2
d85 1
a85 1
		fprintf(stderr, "usage: %s [-tv] [-f from] [-F name] to ..\n",
d88 2
a89 1
		fprintf(stderr, "usage: %s command [argument ...]\n", __progname);
d149 1
a149 1
	while(1) {
a184 1
	setup_env(&smtpd);
d195 17
a211 7
	/* test for not connected actions */
	switch (action) {
	case SHOW_QUEUE:
		show_queue(0);
		return (0);
	case SHOW_ENVELOPE:
		show_envelope(res->data);
a212 5
	case SHOW_MESSAGE:
		show_message(res->data);
		return (0);
	default:
		break;
a214 3
	if (!try_connect())
		errx(1, "smtpd doesn't seem to be running");

d231 2
d234 1
a234 4
		ulval = 0;
		imsg_compose(ibuf, IMSG_SCHEDULER_SCHEDULE, 0, 0, -1, &ulval,
		    sizeof(ulval));
		break;
d290 1
a290 2
	while (!done) {

d294 1
a294 1
		switch(action) {
a296 1
		case SCHEDULE_ALL:
d323 118
a441 1
	free(ibuf);
d471 1
a471 1
	while(1) {
d486 1
a486 1
			printf("uptime=%zd\n", (size_t)duration); 
d543 1
d545 1
a545 1
show_queue_envelope(struct envelope *e, int flags)
d547 2
a548 2
	const char *src = "?";
	char	 status[128];
d559 14
d576 1
a576 1
	
a578 2
	else
		strlcpy(status, "-", sizeof(status));
d580 6
a585 13
	switch (e->type) {
	case D_MDA:
		printf("mda");
		break;
	case D_MTA:
		printf("mta");
		break;
	case D_BOUNCE:
		printf("bounce");
		break;
	default:
		printf("unknown");
	}
d594 4
a597 1
	printf("|%016" PRIx64 "|%s|%s|%s@@%s|%s@@%s|%" PRId64 "|%" PRId64 "|%u",
d599 1
d601 1
d604 1
a605 6
	    (int64_t) e->lasttry,
	    (int64_t) e->expire,
	    e->retry);
	
	if (e->errorline[0] != '\0')
		printf("|%s", e->errorline);
d607 6
a612 1
	printf("\n");
@


1.95
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.94 2012/10/26 19:16:42 chl Exp $	*/
d61 4
d103 52
a157 1
	struct sockaddr_un	sun;
d161 2
a162 1
	int			ctl_sock;
d164 2
a165 1
	int			n, verbose = 0;
d168 2
a169 1
	if (strcmp(__progname, "sendmail") == 0 || strcmp(__progname, "send-mail") == 0)
d171 4
a174 13
	else if (strcmp(__progname, "mailq") == 0) {
		if (geteuid())
			errx(1, "need root privileges");
		setup_env(&smtpd);
		show_queue(0);
		return 0;
	} else if (strcmp(__progname, "smtpctl") == 0) {

		/* check for root privileges */
		if (geteuid())
			errx(1, "need root privileges");

		setup_env(&smtpd);
d176 7
d185 1
a185 16

		/* handle "disconnected" commands */
		switch (res->action) {
		case SHOW_QUEUE:
			show_queue(0);
			break;
		case SHOW_ENVELOPE:
			show_envelope(res->data);
			break;
		case SHOW_MESSAGE:
			show_message(res->data);
			break;
		default:
			goto connected;
		}
		return 0;
d189 13
a201 12
connected:
	/* connect to smtpd control socket */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, SMTPD_SOCKET, sizeof(sun.sun_path));
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		if (sendmail)
			return enqueue_offline(argc, argv);
		err(1, "connect: %s", SMTPD_SOCKET);
d204 2
a205 6
	if ((ibuf = calloc(1, sizeof(struct imsgbuf))) == NULL)
		err(1, NULL);
	imsg_init(ibuf, ctl_sock);

	if (sendmail)
		return enqueue(argc, argv);
d208 1
a208 1
	switch (res->action) {
a213 3
	case REMOVE: {
		uint64_t ulval;

d215 2
a216 6
		if (res->action == SCHEDULE)
			imsg_compose(ibuf, IMSG_SCHEDULER_SCHEDULE, 0, 0, -1, &ulval,
			    sizeof(ulval));
		if (res->action == REMOVE)
			imsg_compose(ibuf, IMSG_SCHEDULER_REMOVE, 0, 0, -1, &ulval,
			    sizeof(ulval));
d218 7
a224 5
	}

	case SCHEDULE_ALL: {
		uint64_t ulval = 0;

a227 2
	}

d252 1
a252 3
	case UPDATE_MAP: {
		char	name[MAX_LINE_SIZE];

a258 1
	}
d260 9
a268 2
    again:
		imsg_compose(ibuf, IMSG_DIGEST, 0, 0, -1, NULL, 0);
d280 1
a280 1
		errx(1, "unknown request (%d)", res->action);
d283 1
a283 3
	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) < 0)
			err(1, "write error");
d285 2
a286 5
	while (!done) {
		if ((n = imsg_read(ibuf)) == -1)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");
d288 24
a311 38
		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;
			switch(res->action) {
			case REMOVE:
			case SCHEDULE:
			case SCHEDULE_ALL:
			case SHUTDOWN:
			case PAUSE_MDA:
			case PAUSE_MTA:
			case PAUSE_SMTP:
			case RESUME_MDA:
			case RESUME_MTA:
			case RESUME_SMTP:
			case LOG_VERBOSE:
			case LOG_BRIEF:
				done = show_command_output(&imsg);
				break;
			case SHOW_STATS:
				show_stats_output();
				done = 1;
				break;
			case NONE:
				break;
			case UPDATE_MAP:
				break;
			case MONITOR:
				show_monitor(imsg.data);
				imsg_free(&imsg);
				sleep(1);
				goto again;
				break;
			default:
				err(1, "unexpected reply (%d)", res->action);
			}
			/* insert imsg replies switch here */
d313 2
a314 1
			imsg_free(&imsg);
d316 2
a318 1
	close(ctl_sock);
a344 1
	int		n;
d349 6
a354 6
again:
	imsg_compose(ibuf, IMSG_STATS_GET, 0, 0, -1, &kv, sizeof kv);
	
	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) < 0)
			err(1, "write error");
d356 5
a360 5
	do {
		if ((n = imsg_read(ibuf)) == -1)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");
d362 27
a388 4
		do {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
a389 7
			if (imsg.hdr.type != IMSG_STATS_GET)
				errx(1, "invalid imsg type");

			kvp = imsg.data;
			if (kvp->iter == NULL) {
				imsg_free(&imsg);
				return;
d391 1
d393 3
a395 38
			if (strcmp(kvp->key, "uptime") == 0) {
				duration = time(NULL) - kvp->val.u.counter;
				printf("uptime=%zd\n", (size_t)duration); 
				printf("uptime.human=%s\n",
				    duration_to_text(duration));
			} else {
				switch (kvp->val.type) {
				case STAT_COUNTER:
					printf("%s=%zd\n",
					    kvp->key, kvp->val.u.counter);
					break;
				case STAT_TIMESTAMP:
					printf("%s=%" PRId64 "\n",
					    kvp->key, (int64_t)kvp->val.u.timestamp);
					break;
				case STAT_TIMEVAL:
					printf("%s=%zd.%zd\n",
					    kvp->key, kvp->val.u.tv.tv_sec,
					    kvp->val.u.tv.tv_usec);
					break;
				case STAT_TIMESPEC:
					printf("%s=%li.%06li\n",
					    kvp->key,
					    kvp->val.u.ts.tv_sec * 1000000 +
					    kvp->val.u.ts.tv_nsec / 1000000,
					    kvp->val.u.ts.tv_nsec % 1000000);
					break;
				}
			}

			kv = *kvp;

			imsg_free(&imsg);
			goto again;

		} while (n != 0);

	} while (n != 0);
@


1.94
log
@add a new uptime.human entry in stats, derived from uptime, but displayed
in a human readable fashion:

uptime=123456
uptime.human=1d10h17m36s

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.93 2012/10/14 11:58:23 gilles Exp $	*/
d59 1
d232 2
a233 1
		/* XXX */
d285 1
d287 4
d361 1
a361 1
				printf("uptime=%zd\n", duration); 
d544 49
@


1.93
log
@introduce map_file.c which will deprecate map_stdio.c

The idea is to have a file-backed map but to have smtpd(8) cache the maps
so that it cannot be partially read if edited while mail is received. The
file is read and converted to a static map (map_static.c), changes aren't
visible to smtpd until an explicit: smtpctl update map  which reads file,
builds a new static map and invalidates the former.

partial-read issue discussed with beck@@ and halex@@
idea to convert internally to a static map by eric@@

diff ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.92 2012/10/10 19:39:11 gilles Exp $	*/
d320 2
a321 2
	int n;

d352 6
a357 4
			if (strcmp(kvp->key, "uptime") == 0)
				printf("%s=%zd\n", kvp->key,
				    time(NULL) - kvp->val.u.counter);
			else {
@


1.92
log
@teach smtpctl how to display envelopes and messages using their id.
this allows an admin to inspect the queue without having to manually
extract bucket and find the path to an envelope or message.

diff by Sunil Nimmagadda <sunil@@poolp.org>

ok eric@@, chl@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.91 2012/09/19 20:08:53 eric Exp $	*/
d220 10
d282 1
@


1.91
log
@use lower case for envelope fields.

requested by gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.90 2012/09/19 18:20:36 eric Exp $	*/
d45 4
d56 3
d134 6
a176 10
		char *ep;

		errno = 0;
		ulval = strtoull(res->data, &ep, 16);
		if (res->data[0] == '\0' || *ep != '\0')
			errx(1, "invalid msgid/evpid");
		if (errno == ERANGE && ulval == ULLONG_MAX)
			errx(1, "invalid msgid/evpid");
		if (ulval == 0)
			errx(1, "invalid msgid/evpid");
d178 1
d471 53
@


1.90
log
@Remove DF_ENQUEUE flag. It is mostly unused and logically broken.
Ignore it in existing envelopes until it gets completely dropped.
Change "smtpctl show queue" to display the address family of the
envelope source instead of the ENQUEUE flag.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.89 2012/08/30 22:06:00 gilles Exp $	*/
d406 1
a406 1
	getflag(&e->flags, DF_BOUNCE, "BOUNCE",
d408 1
a408 1
	getflag(&e->flags, DF_AUTHENTICATED, "AUTH",
d410 1
a410 1
	getflag(&e->flags, DF_INTERNAL, "INTERNAL",
d424 1
a424 1
		printf("MDA");
d427 1
a427 1
		printf("MTA");
d430 1
a430 1
		printf("BOUNCE");
d433 1
a433 1
		printf("UNKNOWN");
d437 1
a437 1
		src = "LOCAL";
d439 1
a439 1
		src = "INET4";
d441 1
a441 1
		src = "INET6";
@


1.89
log
@- rename show_envelope() to show_queue_envelope()
- remove SHOW_RUNQUEUE it was a noop since runqueues have been removed
  years ago from smtpd
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.88 2012/08/25 10:23:12 gilles Exp $	*/
d401 1
a409 2
	getflag(&e->flags, DF_ENQUEUED, "ENQUEUED",
	    status, sizeof(status));
d435 9
a443 2
	
	printf("|%016" PRIx64 "|%s|%s@@%s|%s@@%s|%" PRId64 "|%" PRId64 "|%u",
d445 1
@


1.88
log
@- introduce struct stat_value
- statistics can now have a type (counter, timestamp, timeval, timespec and
  possibly others in the future)
- stat_increment() / stat_decrement() now take an increment/decrement value
  and are at the moment only of type counter
- stat_set() now takes a stat_value
- provide helpers to convert raw values to stat_value

ok eric@@, ok chl@@

while at it fix a rq_queue_dump() call using a bogus timestamp in scheduler
ramqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.87 2012/08/19 14:16:58 chl Exp $	*/
d50 1
a50 1
static void show_envelope(struct envelope *, int);
a126 2
		case SHOW_RUNQUEUE:
			break;
d392 1
a392 1
		show_envelope(&envelope, flags);
d399 1
a399 1
show_envelope(struct envelope *e, int flags)
@


1.87
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.86 2012/08/18 18:18:23 gilles Exp $	*/
d340 26
a365 3
				printf("%s=%zd\n", kvp->key, time(NULL) - kvp->val);
			else
				printf("%s=%zd\n", kvp->key, kvp->val);
@


1.86
log
@- introduce stat_backend, an API for pluggable statistic backends
  > statistics are no longer static structures in shared memory
  > statistics are only set, smtpd never uses them in its logic
  > each statistic is a key/value where key can be any (dynamic) string
- convert all uses of the former API to use the new one
- implement stat_ramstat that keeps non-persistent stats in ram structure

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.85 2012/08/08 17:33:55 eric Exp $	*/
d51 1
a51 1
static void getflag(u_int *, int, char *, char *, size_t);
d165 1
a165 1
		u_int64_t ulval;
d187 1
a187 1
		u_int64_t ulval = 0;
d359 1
a359 1
	u_int64_t	 evpid;
d432 1
a432 1
getflag(u_int *bitmap, int bit, char *bitstr, char *buf, size_t len)
@


1.85
log
@remove useless defines

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.84 2012/08/07 20:36:10 eric Exp $	*/
d48 1
a48 1
static int show_stats_output(struct imsg *);
d265 2
a266 1
				done = show_stats_output(&imsg);
d303 1
a303 1
stat_print(int stat, int what)
d305 3
a307 38
	static const char *names[STATS_MAX] = {
		"smtp.sessions",
		"smtp.sessions.inet4",
		"smtp.sessions.inet6",
		"smtp.sessions.smtps",
		"smtp.sessions.starttls",

		"mta.sessions",

		"mda.sessions",

		"control.sessions",

		"lka.sessions",
		"lka.sessions.mx",
		"lka.sessions.host",
		"lka.sessions.cname",
		"lka.sessions.failure",

		"scheduler",
		"scheduler.bounces",

		"queue.inserts.local",
		"queue.inserts.remote",

		"ramqueue.envelopes",
		"ramqueue.messages",
		"ramqueue.batches",
		"ramqueue.hosts",
	};
	const char *sfx;

	if (what == STAT_ACTIVE)
		sfx = ".active";
	else if (what == STAT_MAXACTIVE)
		sfx = ".maxactive";
	else
		sfx = "";
a308 2
	printf("%s%s=%zd\n", names[stat], sfx, stat_get(stat, what));
}
d310 1
a310 4
static int
show_stats_output(struct imsg *imsg)
{
	struct stats	*stats;
d312 2
a313 2
	if (imsg->hdr.type != IMSG_STATS)
		errx(1, "show_stats_output: bad hdr type (%d)", imsg->hdr.type);
d315 3
a317 2
	if (imsg->hdr.len - IMSG_HEADER_SIZE != sizeof(*stats))
		errx(1, "show_stats_output: bad data size");
d319 5
a323 2
	stats = imsg->data;
	stat_init(stats->counters, STATS_MAX);
d325 18
a342 75
	stat_print(STATS_CONTROL_SESSION, STAT_COUNT);
	stat_print(STATS_CONTROL_SESSION, STAT_ACTIVE);
	stat_print(STATS_CONTROL_SESSION, STAT_MAXACTIVE);

	stat_print(STATS_MDA_SESSION, STAT_COUNT);
	stat_print(STATS_MDA_SESSION, STAT_ACTIVE);
	stat_print(STATS_MDA_SESSION, STAT_MAXACTIVE);

	stat_print(STATS_MTA_SESSION, STAT_COUNT);
	stat_print(STATS_MTA_SESSION, STAT_ACTIVE);
	stat_print(STATS_MTA_SESSION, STAT_MAXACTIVE);

	stat_print(STATS_LKA_SESSION, STAT_COUNT);
	stat_print(STATS_LKA_SESSION, STAT_ACTIVE);
	stat_print(STATS_LKA_SESSION, STAT_MAXACTIVE);
	stat_print(STATS_LKA_SESSION_MX, STAT_COUNT);
	stat_print(STATS_LKA_SESSION_HOST, STAT_COUNT);
	stat_print(STATS_LKA_SESSION_CNAME, STAT_COUNT);
	stat_print(STATS_LKA_FAILURE, STAT_COUNT);

	printf("parent.uptime=%lld\n",
	    (long long int) (time(NULL) - stats->parent.start));

	stat_print(STATS_QUEUE_LOCAL, STAT_COUNT);
	stat_print(STATS_QUEUE_REMOTE, STAT_COUNT);

	stat_print(STATS_SCHEDULER, STAT_COUNT);
	stat_print(STATS_SCHEDULER, STAT_ACTIVE);
	stat_print(STATS_SCHEDULER, STAT_MAXACTIVE);

	stat_print(STATS_SCHEDULER_BOUNCES, STAT_COUNT);
	stat_print(STATS_SCHEDULER_BOUNCES, STAT_ACTIVE);
	stat_print(STATS_SCHEDULER_BOUNCES, STAT_MAXACTIVE);

	stat_print(STATS_RAMQUEUE_HOST, STAT_ACTIVE);
	stat_print(STATS_RAMQUEUE_BATCH, STAT_ACTIVE);
	stat_print(STATS_RAMQUEUE_MESSAGE, STAT_ACTIVE);
	stat_print(STATS_RAMQUEUE_ENVELOPE, STAT_ACTIVE);

	stat_print(STATS_RAMQUEUE_HOST, STAT_MAXACTIVE);
	stat_print(STATS_RAMQUEUE_BATCH, STAT_MAXACTIVE);
	stat_print(STATS_RAMQUEUE_MESSAGE, STAT_MAXACTIVE);
	stat_print(STATS_RAMQUEUE_ENVELOPE, STAT_MAXACTIVE);

	printf("smtp.errors.delays=%zd\n", stats->smtp.delays);
	printf("smtp.errors.linetoolong=%zd\n", stats->smtp.linetoolong);
	printf("smtp.errors.read_eof=%zd\n", stats->smtp.read_eof);
	printf("smtp.errors.read_system=%zd\n", stats->smtp.read_error);
	printf("smtp.errors.read_timeout=%zd\n", stats->smtp.read_timeout);
	printf("smtp.errors.tempfail=%zd\n", stats->smtp.tempfail);
	printf("smtp.errors.toofast=%zd\n", stats->smtp.toofast);
	printf("smtp.errors.write_eof=%zd\n", stats->smtp.write_eof);
	printf("smtp.errors.write_system=%zd\n", stats->smtp.write_error);
	printf("smtp.errors.write_timeout=%zd\n", stats->smtp.write_timeout);

	stat_print(STATS_SMTP_SESSION, STAT_COUNT);
	stat_print(STATS_SMTP_SESSION_INET4, STAT_COUNT);
	stat_print(STATS_SMTP_SESSION_INET6, STAT_COUNT);
	printf("smtp.sessions.aborted=%zd\n", stats->smtp.read_eof +
	    stats->smtp.read_error + stats->smtp.write_eof +
	    stats->smtp.write_error);

	stat_print(STATS_SMTP_SESSION, STAT_ACTIVE);
	stat_print(STATS_SMTP_SESSION, STAT_MAXACTIVE);

	printf("smtp.sessions.timeout=%zd\n", stats->smtp.read_timeout +
	    stats->smtp.write_timeout);

	stat_print(STATS_SMTP_SMTPS, STAT_COUNT);
	stat_print(STATS_SMTP_SMTPS, STAT_ACTIVE);
	stat_print(STATS_SMTP_SMTPS, STAT_MAXACTIVE);

	stat_print(STATS_SMTP_STARTTLS, STAT_COUNT);
	stat_print(STATS_SMTP_STARTTLS, STAT_ACTIVE);
	stat_print(STATS_SMTP_STARTTLS, STAT_MAXACTIVE);
d344 8
a351 1
	return (1);
@


1.84
log
@fix evpid parsing on 32bit archs

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.83 2012/07/09 09:57:53 gilles Exp $	*/
d354 1
a354 1
	if (IMSG_DATA_SIZE(imsg) != sizeof(*stats))
@


1.83
log
@- runner is the terminology we used back when we had runqueues, we no
  longer have them and runner is actually a scheduler so rename.
- introduce scheduler_backend which does the same to scheduler than
  queue_backend does to queue and map_backend does to maps
- remove all occurences of RUNNER and runner, replace them with SCHEDULER
  and scheduler

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.82 2012/07/02 17:00:05 eric Exp $	*/
d169 1
a169 1
		ulval = strtoul(res->data, &ep, 16);
@


1.82
log
@Lookup queue and scheduler backends by name, rather than enum.
Add a command-line option to specify the backend to use at runtime.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.81 2012/06/20 20:45:23 eric Exp $	*/
d178 1
a178 1
			imsg_compose(ibuf, IMSG_RUNNER_SCHEDULE, 0, 0, -1, &ulval,
d181 1
a181 1
			imsg_compose(ibuf, IMSG_RUNNER_REMOVE, 0, 0, -1, &ulval,
d189 1
a189 1
		imsg_compose(ibuf, IMSG_RUNNER_SCHEDULE, 0, 0, -1, &ulval,
d323 2
a324 2
		"runner",
		"runner.bounces",
d386 7
a392 7
	stat_print(STATS_RUNNER, STAT_COUNT);
	stat_print(STATS_RUNNER, STAT_ACTIVE);
	stat_print(STATS_RUNNER, STAT_MAXACTIVE);

	stat_print(STATS_RUNNER_BOUNCES, STAT_COUNT);
	stat_print(STATS_RUNNER_BOUNCES, STAT_ACTIVE);
	stat_print(STATS_RUNNER_BOUNCES, STAT_MAXACTIVE);
@


1.81
log
@Finally get rid of the queue_kind enum in the queue API. Keep that
internally in fsqueue backend for now, and let the fsqueue_message()
and fsqueue_envelope() dispatchers do the right thing.

Based on a diff by chl@@

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.80 2012/05/13 09:18:52 nicm Exp $	*/
d83 1
a83 1
	env->sc_queue = queue_backend_lookup(QT_FS);
@


1.80
log
@Remove sizes entry so it doesn't appear as a valid command in the
"smtpctl show" output, and use errx rather than err for the unknown
message error.

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.79 2012/04/15 12:12:35 chl Exp $	*/
d49 1
a49 1
static void show_queue(enum queue_kind, int);
d109 1
a109 1
		show_queue(Q_QUEUE, 0);
d125 1
a125 1
			show_queue(Q_QUEUE, 0);
d440 1
a440 1
show_queue(enum queue_kind kind, int flags)
d451 1
a451 1
	q = qwalk_new(kind, 0);
d454 1
a454 1
		if (! queue_envelope_load(kind, evpid, &envelope))
@


1.79
log
@Remove dead assignments and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.78 2012/01/28 11:33:07 gilles Exp $	*/
d231 1
a231 1
		err(1, "unknown request (%d)", res->action);
@


1.78
log
@- introduce the scheduler_backend API
- introduce the scheduler_ramqueue backend
- remove all occurences of ramqueue outside of the ramqueue backend
- teach runner how to use the new API

it is now possible to write custom schedulers !

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.77 2012/01/24 12:20:18 eric Exp $	*/
a349 1
	struct stat_counter	*s;
a358 1
	s = stats->counters;
@


1.77
log
@Add a parameter to the queue backend init() call to specify wether the
call is issued by smtpd or smtpctl.  In the latter case, only perform
sanity checks and do not touch directories.  A running server no
longer lose its "incoming/" directory each time smtpctl is called...

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.76 2012/01/12 22:59:55 eric Exp $	*/
a46 1
static void show_sizes(void);
a128 3
		case SHOW_SIZES:
			show_sizes();
			break;
a300 24
void
show_sizes(void)
{
	/*
	 * size _does_ matter.
	 *
	 * small changes to ramqueue and diskqueue structures may cause
	 * large changes to memory and disk usage on busy/large hosts.
	 *
	 * this will help developers optimize memory/disk use, and help
	 * admins understand how the ramqueue.size / ramqueue.size.max
	 * stats are computed (smtpctl show stats).
	 *
	 * -- gilles@@
	 *
	 */
	printf("struct ramqueue: %zu\n", sizeof (struct ramqueue));
	printf("struct ramqueue_host: %zu\n", sizeof (struct ramqueue_host));
	printf("struct ramqueue_message: %zu\n", sizeof (struct ramqueue_message));
	printf("struct ramqueue_envelope: %zu\n", sizeof (struct ramqueue_envelope));

	printf("struct envelope: %zu\n", sizeof (struct envelope));
}

a404 11

	printf("ramqueue.size=%zd\n",
	    s[STATS_RAMQUEUE_HOST].active * sizeof(struct ramqueue_host) +
	    s[STATS_RAMQUEUE_BATCH].active * sizeof(struct ramqueue_batch) +
	    s[STATS_RAMQUEUE_MESSAGE].active * sizeof(struct ramqueue_message) +
	    s[STATS_RAMQUEUE_ENVELOPE].active * sizeof(struct ramqueue_envelope));
	printf("ramqueue.size.max=%zd\n",
	    s[STATS_RAMQUEUE_HOST].maxactive * sizeof(struct ramqueue_host) +
	    s[STATS_RAMQUEUE_BATCH].maxactive * sizeof(struct ramqueue_batch) +
	    s[STATS_RAMQUEUE_MESSAGE].maxactive * sizeof(struct ramqueue_message) +
	    s[STATS_RAMQUEUE_ENVELOPE].maxactive * sizeof(struct ramqueue_envelope));
@


1.76
log
@The status field in the envelope is confusing. Its only purpose is to
notify the runner of what happened with an envelope that has been
scheduled.  It is not part of the state of the envelope, and it is not
even dumped.  So it should only be set by mta/mda, checked by runner
to decide what to do with the envelope, and ignored everywhere else.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.75 2012/01/12 18:06:18 eric Exp $	*/
d88 1
a88 1
	if (!env->sc_queue->init())
@


1.75
log
@Remove dead code for config reloading for now. It is not functionnal
and confusing.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.74 2011/12/18 22:52:25 chl Exp $	*/
a508 7

	getflag(&e->status, DS_TEMPFAILURE, "TEMPFAIL",
	    status, sizeof(status));

	if (e->status)
		errx(1, "%016" PRIx64 ": unexpected status 0x%04x", e->id,
		    e->status);
@


1.74
log
@Add missing header needed by PRI format string

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.73 2011/12/14 18:42:27 eric Exp $	*/
a253 1
			/* case RELOAD: */
@


1.73
log
@move show_queue() and related functions from queue_shared.c
to smtpctl.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.72 2011/11/23 13:48:03 chl Exp $	*/
d33 1
@


1.72
log
@Fix Segmentation Fault when launching mailq(8)

Bug reported by Mark Patruck <mark at wrapped.cx>

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.71 2011/11/15 23:06:39 gilles Exp $	*/
d42 1
d49 3
d478 94
@


1.71
log
@Qwalk, our API to linearly walk over the persistent queue, did not take the
queue_backend into account and assumed a filesystem with a specific layout.

This commit does plenty of things:

- make qwalk an abstraction in the queue_backend API, and impose queue
  drivers to implement qwalk_open(), qwalk() and qwalk_close();

- move previous qwalk_open(), qwalk() and qwalk_close() to the fsqueue
  driver since they were fsqueue specific ...

- make qwalk API work with msgid/evpid instead of pathnames since we're
  going to use the queue_backend API to load envelopes by evpid anyway;

- makes smtpd use *solely* the queue_backend API when manipulating the
  queue. pathnames were removed from smtpd.h and moved into the fsqueue
  which means we can now store a queue anywhere ... as long as we write
  the ten functions or so required for a queue driver ;-)

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.70 2011/10/26 20:47:31 gilles Exp $	*/
d44 1
d70 17
d93 1
d104 1
a107 1
		struct smtpd smtpd;
d113 1
a113 11
		bzero(&smtpd, sizeof (smtpd));
		env = &smtpd;
		if ((env->sc_pw = getpwnam(SMTPD_USER)) == NULL)
			errx(1, "unknown user %s", SMTPD_USER);

		env->sc_queue = queue_backend_lookup(QT_FS);
		if (env->sc_queue == NULL)
			errx(1, "could not find queue backend");

		if (!env->sc_queue->init())
			errx(1, "invalid directory permissions");
@


1.70
log
@- fix smtpctl pause/resume so the ramqueue scheduling is done correctly
- rename IMSG and smtpctl pause/resume parameters
- update man page

tested by me, ok chl@@, eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.69 2011/10/23 17:12:41 gilles Exp $	*/
d33 1
d85 1
a85 1
		show_queue(PATH_QUEUE, 0);
d88 2
d94 12
d112 1
a112 1
			show_queue(PATH_QUEUE, 0);
@


1.69
log
@- smtpctl schedule no longer works, instead, use 'smtpctl schedule-id <id>'
- introduce 'smtpctl schedule-all'

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.68 2011/10/23 09:30:07 gilles Exp $	*/
d173 1
a173 1
		imsg_compose(ibuf, IMSG_QUEUE_PAUSE_LOCAL, 0, 0, -1, NULL, 0);
d176 1
a176 1
		imsg_compose(ibuf, IMSG_QUEUE_PAUSE_OUTGOING, 0, 0, -1, NULL, 0);
d182 1
a182 1
		imsg_compose(ibuf, IMSG_QUEUE_RESUME_LOCAL, 0, 0, -1, NULL, 0);
d185 1
a185 1
		imsg_compose(ibuf, IMSG_QUEUE_RESUME_OUTGOING, 0, 0, -1, NULL, 0);
@


1.68
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.67 2011/09/01 19:56:49 eric Exp $	*/
d149 2
d161 8
d228 1
@


1.67
log
@Introduce a small set of functions to manage stat counters in a
simpler and hopefully saner way.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.66 2011/08/30 07:06:06 chl Exp $	*/
a287 1
	printf("struct delivery: %zu\n", sizeof (struct delivery));
@


1.66
log
@fix format string

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.65 2011/08/29 21:43:09 chl Exp $	*/
d291 45
d340 1
d349 2
d352 19
a370 21
	printf("control.sessions=%zd\n", stats->control.sessions);
	printf("control.sessions_active=%zd\n",
	    stats->control.sessions_active);
	printf("control.sessions_maxactive=%zd\n",
	    stats->control.sessions_maxactive);

	printf("mda.sessions=%zd\n", stats->mda.sessions);
	printf("mda.sessions.active=%zd\n", stats->mda.sessions_active);
	printf("mda.sessions.maxactive=%zd\n", stats->mda.sessions_maxactive);

	printf("mta.sessions=%zd\n", stats->mta.sessions);
	printf("mta.sessions.active=%zd\n", stats->mta.sessions_active);
	printf("mta.sessions.maxactive=%zd\n", stats->mta.sessions_maxactive);

	printf("lka.queries=%zd\n", stats->lka.queries);
	printf("lka.queries.active=%zd\n", stats->lka.queries_active);
	printf("lka.queries.maxactive=%zd\n", stats->lka.queries_maxactive);
	printf("lka.queries.mx=%zd\n", stats->lka.queries_mx);
	printf("lka.queries.host=%zd\n", stats->lka.queries_host);
	printf("lka.queries.cname=%zd\n", stats->lka.queries_cname);
	printf("lka.queries.failure=%zd\n", stats->lka.queries_failure);
d375 20
a394 2
	printf("queue.inserts.local=%zd\n", stats->queue.inserts_local);
	printf("queue.inserts.remote=%zd\n", stats->queue.inserts_remote);
a395 15
	printf("runner.active=%zd\n", stats->runner.active);
	printf("runner.maxactive=%zd\n", stats->runner.maxactive);
	printf("runner.bounces=%zd\n", stats->runner.bounces);
	printf("runner.bounces.active=%zd\n", stats->runner.bounces_active);
	printf("runner.bounces.maxactive=%zd\n",
	    stats->runner.bounces_maxactive);

	printf("ramqueue.hosts=%zd\n", stats->ramqueue.hosts);
	printf("ramqueue.batches=%zd\n", stats->ramqueue.batches);
	printf("ramqueue.messages=%zd\n", stats->ramqueue.messages);
	printf("ramqueue.envelopes=%zd\n", stats->ramqueue.envelopes);
	printf("ramqueue.hosts.max=%zd\n", stats->ramqueue.hosts_max);
	printf("ramqueue.batches.max=%zd\n", stats->ramqueue.batches_max);
	printf("ramqueue.messages.max=%zd\n", stats->ramqueue.messages_max);
	printf("ramqueue.envelopes.max=%zd\n", stats->ramqueue.envelopes_max);
d397 4
a400 4
	    stats->ramqueue.hosts * sizeof(struct ramqueue_host) +
	    stats->ramqueue.batches * sizeof(struct ramqueue_batch) +
	    stats->ramqueue.messages * sizeof(struct ramqueue_message) +
	    stats->ramqueue.envelopes * sizeof(struct ramqueue_envelope));
d402 4
a405 4
	    stats->ramqueue.hosts_max * sizeof(struct ramqueue_host) +
	    stats->ramqueue.batches_max * sizeof(struct ramqueue_batch) +
	    stats->ramqueue.messages_max * sizeof(struct ramqueue_message) +
	    stats->ramqueue.envelopes_max * sizeof(struct ramqueue_envelope));
d418 3
a420 4
	printf("smtp.sessions.inet4=%zd\n", stats->smtp.sessions_inet4);
	printf("smtp.sessions.inet6=%zd\n", stats->smtp.sessions_inet6);

	printf("smtp.sessions=%zd\n", stats->smtp.sessions);
d424 4
a427 3
	printf("smtp.sessions.active=%zd\n", stats->smtp.sessions_active);
	printf("smtp.sessions.maxactive=%zd\n",
	    stats->smtp.sessions_maxactive);
d430 8
a437 9
	printf("smtp.sessions.smtps=%zd\n", stats->smtp.smtps);
	printf("smtp.sessions.smtps.active=%zd\n", stats->smtp.smtps_active);
	printf("smtp.sessions.smtps.maxactive=%zd\n",
	    stats->smtp.smtps_maxactive);
	printf("smtp.sessions.starttls=%zd\n", stats->smtp.starttls);
	printf("smtp.sessions.starttls.active=%zd\n",
	    stats->smtp.starttls_active);
	printf("smtp.sessions.starttls.maxactive=%zd\n",
	    stats->smtp.starttls_maxactive);
@


1.65
log
@cast all printed time_t to long long int, and change format string accordingly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.64 2011/08/26 14:39:47 chl Exp $	*/
d282 4
a285 4
	printf("struct ramqueue: %ld\n", sizeof (struct ramqueue));
	printf("struct ramqueue_host: %ld\n", sizeof (struct ramqueue_host));
	printf("struct ramqueue_message: %ld\n", sizeof (struct ramqueue_message));
	printf("struct ramqueue_envelope: %ld\n", sizeof (struct ramqueue_envelope));
d287 2
a288 2
	printf("struct envelope: %ld\n", sizeof (struct envelope));
	printf("struct delivery: %ld\n", sizeof (struct delivery));
@


1.64
log
@add missing header needed by time()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.63 2011/08/16 19:12:40 gilles Exp $	*/
d326 2
a327 1
	printf("parent.uptime=%d\n", time(NULL) - stats->parent.start);
@


1.63
log
@smtpctl show sizes, displays the size of queue-related structures, useful
for developers to see the impact of structure changes on memory and disk
usage, and useful for users to better understand 'smtpctl show stats'
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.62 2011/08/16 19:02:03 gilles Exp $	*/
d36 1
@


1.62
log
@add a host-tree and an envelope-tree in the ramqueue, they will be used to
improve scheduling and general ramqueue operations. unused yet
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.61 2011/07/21 23:29:24 gilles Exp $	*/
d42 2
a43 1
static int show_command_output(struct imsg*);
d100 3
d263 25
@


1.61
log
@- update smtpctl.8 to reflect reality
- bring back 'smtpctl schedule' and 'smtpctl remove' to life

Things you should know:

The ramqueue data structure is not finished yet and lacks an envelope tree
for evpid lookups. I wanted to wait until I'm done but too many people are
affected by not being able to reschedule envelopes, this is a quick fix.

So right now there's an O(rrible) complexity as both commands will perform
a (possibly aborted) queue scan leading to O(n). I will make that O(log n)
soon.

Also, smtpctl remove no longer supports removing an entire message, I will
fix that very soon too.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.60 2011/05/01 12:57:11 eric Exp $	*/
d310 1
d314 1
d319 1
d321 5
@


1.60
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.59 2011/04/17 13:36:07 gilles Exp $	*/
d30 1
d132 22
d211 2
@


1.59
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.58 2011/04/13 20:53:18 gilles Exp $	*/
d49 2
@


1.58
log
@following an idea from jacekm@@, smtpd now uses a ram-queue instead of doing
a continuous walk on the disk-queue. the implementation differs from what
jacekm@@ commited (and I backed out) a while ago in that it uses a queue and
a host tree required for upcoming features.

code will be improved in tree, it requires changes to be done in queue and
bounce API, I just wanted to commit a working version first ...

tested by todd@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.57 2011/04/02 16:40:19 eric Exp $	*/
d40 3
a42 3
__dead void	usage(void);
int		show_command_output(struct imsg*);
int		show_stats_output(struct imsg *);
d218 1
a218 1
int
d234 1
a234 1
int
@


1.57
log
@add stat counters for the lookup agent

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.56 2011/03/09 20:59:22 gilles Exp $	*/
a94 1
			show_queue(PATH_RUNQUEUE, 0);
a131 5
/*
	case RELOAD:
		imsg_compose(ibuf, IMSG_CONF_RELOAD, 0, 0, -1, NULL, 0);
		break;
 */
a152 18
	case SCHEDULE: {
		struct sched s;

		s.fd = -1;
		bzero(s.mid, sizeof (s.mid));
		strlcpy(s.mid, res->data, sizeof (s.mid));
		imsg_compose(ibuf, IMSG_QUEUE_SCHEDULE, 0, 0, -1, &s, sizeof (s));
		break;
	}
	case REMOVE: {
		struct remove s;

		s.fd = -1;
		bzero(s.mid, sizeof (s.mid));
		strlcpy(s.mid, res->data, sizeof (s.mid));
		imsg_compose(ibuf, IMSG_QUEUE_REMOVE, 0, 0, -1, &s, sizeof (s));
		break;
	}
d185 1
a185 1
/*			case RELOAD:*/
a186 2
			case SCHEDULE:
			case REMOVE:
d280 11
@


1.56
log
@smtpctl show stats displays inet4/inet6 repartition for incoming sessions
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.55 2010/11/28 14:35:58 gilles Exp $	*/
d286 8
@


1.55
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.54 2010/11/28 13:56:43 gilles Exp $	*/
d309 3
@


1.54
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.53 2010/11/24 23:27:04 todd Exp $	*/
a28 6
#include <net/if.h>
#include <net/if_media.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <arpa/inet.h>

d30 1
a30 1
#include <errno.h>
a34 1
#include <time.h>
a35 1
#include <event.h>
@


1.53
log
@add *maxactive stats
"ok and no need to keep them for yourself" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.52 2010/10/09 22:05:35 gilles Exp $	*/
d37 1
@


1.52
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.47 2010/04/21 18:54:43 jacekm Exp $	*/
d281 4
a284 1
	printf("control.sessions_active=%zd\n", stats->control.sessions_active);
d288 1
d292 1
d300 1
d303 2
d322 2
d328 2
d333 2
@


1.51
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.49 2010/06/01 11:37:26 jacekm Exp $	*/
a45 1
#include "queue_backend.h"
a48 1
void		show_queue(int);
a75 1
	u_int64_t		content_id;
d86 1
a86 1
		show_queue(0);
d99 1
a99 4
			show_queue(0);
			break;
		case SHOW_QUEUE_RAW:
			show_queue(1);
d102 1
d149 1
a149 1
		imsg_compose(ibuf, IMSG_QUEUE_PAUSE_RELAY, 0, 0, -1, NULL, 0);
d158 1
a158 1
		imsg_compose(ibuf, IMSG_QUEUE_RESUME_RELAY, 0, 0, -1, NULL, 0);
d166 16
a181 19
	case SCHEDULE:
		if (strcmp(res->data, "all") == 0)
			content_id = 0;
		else
			content_id = queue_be_encode(res->data);
		if (content_id == INVALID_ID)
			errx(1, "invalid id: %s", res->data);
		imsg_compose(ibuf, IMSG_QUEUE_SCHEDULE, 0, 0, -1, &content_id,
		    sizeof content_id);
		break;
	case REMOVE:
		if (strcmp(res->data, "all") == 0)
			content_id = 0;
		else
			content_id = queue_be_encode(res->data);
		if (content_id == INVALID_ID)
			errx(1, "invalid id: %s", res->data);
		imsg_compose(ibuf, IMSG_QUEUE_REMOVE, 0, 0, -1, &content_id,
		    sizeof content_id);
d183 1
a266 70
void
show_queue(int raw)
{
	struct action_be a;
	struct aux	 aux;
	int		 ret, title;

	if (chdir(PATH_SPOOL) < 0)
		err(1, "chdir");

	title = 0;
	for (;;) {
		ret = queue_be_getnext(&a);
		if (ret == -1)
			err(1, "getnext error");
		if (ret == -2)
			continue;	/* unlinked during scan */
		if (a.content_id == 0)
			break;		/* end of queue */
		if (a.birth == 0)
			continue;	/* uncommitted */
		auxsplit(&aux, a.aux);

		if (raw) {
			printf("%s|", queue_be_decode(a.content_id));
			printf("%d|", a.birth);
			printf("%s|%s|", aux.mode, aux.mail_from);
			if (aux.mode[0] == 'R')
				printf("%s", aux.rcpt);
			else
				printf("%s", aux.rcpt_to);
			printf("\n");
			continue;
		}

		if (title == 0) {
			printf("Message  Envelope\n");
			title = 1;
		}
		printf("%s ", queue_be_decode(a.content_id));
		if (aux.user_from[0])
			printf("%s (", aux.user_from);
		if (aux.mail_from[0])
			printf("%s", aux.mail_from);
		else
			printf("BOUNCE");
		if (aux.user_from[0])
			printf(")");
		printf(" -> ");
		if (aux.mode[0] == 'R') {
			printf("%s", aux.rcpt);
			if (strcmp(aux.rcpt, aux.rcpt_to) != 0)
				printf(" (%s)", aux.rcpt_to);
		} else {
			if (aux.user_to[0])
				printf("%s (", aux.user_to);
			printf("%s", aux.rcpt_to);
			if (aux.user_to[0])
				printf(")");
		}
		if (a.status[0]) {
			if (a.status[0] == '1' || a.status[0] == '6')
				printf(" [%s]", a.status + 4);
			else
				printf(" [\"%s\"]", a.status + 4);
		}
		printf("\n");
	}
}

d291 6
a296 2
	printf("queue.inserts=%zd\n", stats->queue.inserts);
	printf("queue.length=%zd\n", stats->queue.length);
@


1.50
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.47 2010/04/21 18:54:43 jacekm Exp $	*/
d46 1
d50 1
d78 1
d89 1
a89 1
		show_queue(PATH_QUEUE, 0);
d102 4
a105 1
			show_queue(PATH_QUEUE, 0);
a107 1
			show_queue(PATH_RUNQUEUE, 0);
d154 1
a154 1
		imsg_compose(ibuf, IMSG_QUEUE_PAUSE_OUTGOING, 0, 0, -1, NULL, 0);
d163 1
a163 1
		imsg_compose(ibuf, IMSG_QUEUE_RESUME_OUTGOING, 0, 0, -1, NULL, 0);
d171 19
a189 16
	case SCHEDULE: {
		struct sched s;

		s.fd = -1;
		bzero(s.mid, sizeof (s.mid));
		strlcpy(s.mid, res->data, sizeof (s.mid));
		imsg_compose(ibuf, IMSG_QUEUE_SCHEDULE, 0, 0, -1, &s, sizeof (s));
		break;
	}
	case REMOVE: {
		struct remove s;

		s.fd = -1;
		bzero(s.mid, sizeof (s.mid));
		strlcpy(s.mid, res->data, sizeof (s.mid));
		imsg_compose(ibuf, IMSG_QUEUE_REMOVE, 0, 0, -1, &s, sizeof (s));
a190 1
	}
d274 70
d368 2
a369 6
	printf("queue.inserts.local=%zd\n", stats->queue.inserts_local);
	printf("queue.inserts.remote=%zd\n", stats->queue.inserts_remote);

	printf("runner.active=%zd\n", stats->runner.active);
	printf("runner.bounces=%zd\n", stats->runner.bounces);
	printf("runner.bounces.active=%zd\n", stats->runner.bounces_active);
@


1.49
log
@Include birth time in smtpctl show queue raw.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.48 2010/05/31 23:38:56 jacekm Exp $	*/
a45 1
#include "queue_backend.h"
a48 1
void		show_queue(int);
a75 1
	u_int64_t		content_id;
d86 1
a86 1
		show_queue(0);
d99 1
a99 4
			show_queue(0);
			break;
		case SHOW_QUEUE_RAW:
			show_queue(1);
d102 1
d149 1
a149 1
		imsg_compose(ibuf, IMSG_QUEUE_PAUSE_RELAY, 0, 0, -1, NULL, 0);
d158 1
a158 1
		imsg_compose(ibuf, IMSG_QUEUE_RESUME_RELAY, 0, 0, -1, NULL, 0);
d166 16
a181 19
	case SCHEDULE:
		if (strcmp(res->data, "all") == 0)
			content_id = 0;
		else
			content_id = queue_be_encode(res->data);
		if (content_id == INVALID_ID)
			errx(1, "invalid id: %s", res->data);
		imsg_compose(ibuf, IMSG_QUEUE_SCHEDULE, 0, 0, -1, &content_id,
		    sizeof content_id);
		break;
	case REMOVE:
		if (strcmp(res->data, "all") == 0)
			content_id = 0;
		else
			content_id = queue_be_encode(res->data);
		if (content_id == INVALID_ID)
			errx(1, "invalid id: %s", res->data);
		imsg_compose(ibuf, IMSG_QUEUE_REMOVE, 0, 0, -1, &content_id,
		    sizeof content_id);
d183 1
a266 70
void
show_queue(int raw)
{
	struct action_be a;
	struct aux	 aux;
	int		 ret, title;

	if (chdir(PATH_SPOOL) < 0)
		err(1, "chdir");

	title = 0;
	for (;;) {
		ret = queue_be_getnext(&a);
		if (ret == -1)
			err(1, "getnext error");
		if (ret == -2)
			continue;	/* unlinked during scan */
		if (a.content_id == 0)
			break;		/* end of queue */
		if (a.birth == 0)
			continue;	/* uncommitted */
		auxsplit(&aux, a.aux);

		if (raw) {
			printf("%s|", queue_be_decode(a.content_id));
			printf("%d|", a.birth);
			printf("%s|%s|", aux.mode, aux.mail_from);
			if (aux.mode[0] == 'R')
				printf("%s", aux.rcpt);
			else
				printf("%s", aux.rcpt_to);
			printf("\n");
			continue;
		}

		if (title == 0) {
			printf("Message  Envelope\n");
			title = 1;
		}
		printf("%s ", queue_be_decode(a.content_id));
		if (aux.user_from[0])
			printf("%s (", aux.user_from);
		if (aux.mail_from[0])
			printf("%s", aux.mail_from);
		else
			printf("BOUNCE");
		if (aux.user_from[0])
			printf(")");
		printf(" -> ");
		if (aux.mode[0] == 'R') {
			printf("%s", aux.rcpt);
			if (strcmp(aux.rcpt, aux.rcpt_to) != 0)
				printf(" (%s)", aux.rcpt_to);
		} else {
			if (aux.user_to[0])
				printf("%s (", aux.user_to);
			printf("%s", aux.rcpt_to);
			if (aux.user_to[0])
				printf(")");
		}
		if (a.status[0]) {
			if (a.status[0] == '1' || a.status[0] == '6')
				printf(" [%s]", a.status + 4);
			else
				printf(" [\"%s\"]", a.status + 4);
		}
		printf("\n");
	}
}

d291 6
a296 2
	printf("queue.inserts=%zd\n", stats->queue.inserts);
	printf("queue.length=%zd\n", stats->queue.length);
@


1.48
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.47 2010/04/21 18:54:43 jacekm Exp $	*/
d299 1
@


1.47
log
@Runner process is just a helper for queue, so tear down its imsg
channels to parent, mda, mta, lka, smtp, and control.  This leaves
just the channel to queue, which forwards imsgs on runner's behalf
and redirects any replies back to it.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.46 2010/01/10 16:42:35 gilles Exp $	*/
d46 1
d50 1
d78 1
d89 1
a89 1
		show_queue(PATH_QUEUE, 0);
d102 4
a105 1
			show_queue(PATH_QUEUE, 0);
a107 1
			show_queue(PATH_RUNQUEUE, 0);
d154 1
a154 1
		imsg_compose(ibuf, IMSG_QUEUE_PAUSE_OUTGOING, 0, 0, -1, NULL, 0);
d163 1
a163 1
		imsg_compose(ibuf, IMSG_QUEUE_RESUME_OUTGOING, 0, 0, -1, NULL, 0);
d171 19
a189 16
	case SCHEDULE: {
		struct sched s;

		s.fd = -1;
		bzero(s.mid, sizeof (s.mid));
		strlcpy(s.mid, res->data, sizeof (s.mid));
		imsg_compose(ibuf, IMSG_QUEUE_SCHEDULE, 0, 0, -1, &s, sizeof (s));
		break;
	}
	case REMOVE: {
		struct remove s;

		s.fd = -1;
		bzero(s.mid, sizeof (s.mid));
		strlcpy(s.mid, res->data, sizeof (s.mid));
		imsg_compose(ibuf, IMSG_QUEUE_REMOVE, 0, 0, -1, &s, sizeof (s));
a190 1
	}
d274 69
d367 2
a368 6
	printf("queue.inserts.local=%zd\n", stats->queue.inserts_local);
	printf("queue.inserts.remote=%zd\n", stats->queue.inserts_remote);

	printf("runner.active=%zd\n", stats->runner.active);
	printf("runner.bounces=%zd\n", stats->runner.bounces);
	printf("runner.bounces.active=%zd\n", stats->runner.bounces_active);
@


1.46
log
@- teach runner how to remove a message from queue given a message id/uid
	and assuming message is not in processing/scheduled state
- teach smtpctl how to request message removal from runner

discussed with todd@@, idea ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.45 2010/01/03 14:37:37 chl Exp $	*/
d146 1
a146 1
		imsg_compose(ibuf, IMSG_MDA_PAUSE, 0, 0, -1, NULL, 0);
d149 1
a149 1
		imsg_compose(ibuf, IMSG_MTA_PAUSE, 0, 0, -1, NULL, 0);
d155 1
a155 1
		imsg_compose(ibuf, IMSG_MDA_RESUME, 0, 0, -1, NULL, 0);
d158 1
a158 1
		imsg_compose(ibuf, IMSG_MTA_RESUME, 0, 0, -1, NULL, 0);
d172 1
a172 1
		imsg_compose(ibuf, IMSG_RUNNER_SCHEDULE, 0, 0, -1, &s, sizeof (s));
d181 1
a181 1
		imsg_compose(ibuf, IMSG_RUNNER_REMOVE, 0, 0, -1, &s, sizeof (s));
@


1.45
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.44 2009/12/14 18:21:53 jacekm Exp $	*/
a50 17
/*
struct imsgname {
	int type;
	char *name;
	void (*func)(struct imsg *);
};

struct imsgname imsgs[] = {
	{ IMSG_CTL_SHUTDOWN,		"stop",			NULL },
	{ IMSG_CONF_RELOAD,		"reload",		NULL },
	{ 0,				NULL,			NULL }
};
struct imsgname imsgunknown = {
	-1,				"<unknown>",		NULL
};
*/

d175 9
d219 1
@


1.44
log
@Control maximum number of bounce sessions similarly to how the mta and mda
are now controlled.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.43 2009/12/14 16:44:14 jacekm Exp $	*/
d95 1
a95 1
	int			n;
d195 9
d233 2
@


1.43
log
@Impose sessions limit on the delivery sessions (mta and mda).
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.42 2009/12/13 22:02:55 jacekm Exp $	*/
d291 2
@


1.42
log
@Use safe fd limits in smtp, lka, queue, and control.  Removes a
possibility for fd-starvation fatal when under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.40 2009/11/13 20:34:51 chl Exp $	*/
d279 3
a281 1
	printf("mda.errors.write_system=%zd\n", stats->mda.write_error);
@


1.41
log
@typo
@
text
@d276 3
@


1.40
log
@add missing headers needed by time()

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.39 2009/10/25 19:46:31 gilles Exp $	*/
d277 1
a277 1
	printf("mta.sessions=%zd\n", stats->smtp.sessions);
@


1.39
log
@smtpctl reload is work in progress, do not expose it and make sure smtpd's
control process does not try to handle it.

spotted and reported by martijn@@bunix.org
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.38 2009/09/12 12:24:51 jacekm Exp $	*/
d40 1
@


1.38
log
@Simplify line len checking: use one limit for all SMTP exchanges.
This is not as strict as various RFCs want it, but we can make it
more granular later.  For now, let all mails flow by using the
maximum of all limits found in the RFCs.
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.37 2009/09/12 09:38:45 gilles Exp $	*/
d156 1
d160 1
d214 1
a214 1
			case RELOAD:
@


1.37
log
@cmdlinetoolong stat was incremented at the wrong place, fix
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.36 2009/09/12 09:22:33 gilles Exp $	*/
a285 2
	printf("smtp.errors.cmdlinetoolong=%zd\n", stats->smtp.cmdlinetoolong);
	printf("smtp.errors.datalinetoolong=%zd\n", stats->smtp.datalinetoolong);
@


1.36
log
@- fix a compile time warning
- add a new stats counter to distinguish between command lines which
  exceeded the limit and data lines which exceeded the limits
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.35 2009/09/02 12:47:06 jacekm Exp $	*/
d285 1
@


1.35
log
@Include mbox write errors in "show stats".  Suggested by gilles.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.34 2009/08/27 11:38:50 jacekm Exp $	*/
d285 2
a286 1
	printf("smtp.errors.linetoolong=%zd\n", stats->smtp.linetoolong);
@


1.34
log
@s/relayd/smtpd/
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.33 2009/08/08 19:16:41 ian Exp $	*/
d273 1
@


1.33
log
@mailq is a common sendmail alias for showing the queue; make smtpctl
implement this, ignoring sendmail options for now.
OK gilles@@, jackekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.32 2009/08/08 00:16:49 gilles Exp $	*/
d128 1
a128 1
	/* connect to relayd control socket */
@


1.32
log
@missing header
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.31 2009/06/06 04:14:21 pyr Exp $	*/
d99 6
a104 1
	else if (strcmp(__progname, "smtpctl") == 0) {
@


1.31
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.30 2009/06/06 03:22:21 jacekm Exp $	*/
d27 1
@


1.30
log
@if smtpctl is run in unsupported mode, exit with a warning instead of
defaulting to smtpctl-mode; aja@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.29 2009/05/30 16:30:33 gilles Exp $	*/
a84 7
/* dummy function so that smtpctl does not need libevent */
void
imsg_event_add(struct imsgbuf *i)
{
	/* nothing */
}

d137 1
a137 1
	imsg_init(ibuf, ctl_sock, NULL);
@


1.29
log
@- increment stats.mta.sessions_active when session is allocated in mta
- reorder alphabetically and add mta to the statistics
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.28 2009/05/27 13:09:07 jacekm Exp $	*/
d105 1
a105 1
	else {
d125 2
a126 1
	}
@


1.28
log
@request flood mitigation:
1) each state may have 2 responses sent quickly;
2) more responses are delayed exponentially, up to a defined limit.

Delay count is user visible (smtp.errors.delays).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.27 2009/05/24 14:22:24 jacekm Exp $	*/
d272 3
@


1.27
log
@Instead of keeping stats private to each process, and querying every
process individually whenever stats need to be fetched, keep stats
in MAP_ANON shared memory allocated by parent.

This means control has direct access to stats and can respond very
quickly without troubling any other daemon processes.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.26 2009/05/20 11:58:06 gilles Exp $	*/
d280 1
@


1.26
log
@fix a pasto causing "smtpctl resume mta" to try to resume mda
spotted and diff by giovanni <qgiovanni@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.25 2009/05/18 20:23:35 jacekm Exp $	*/
d263 1
a263 5
	static int	 	left = 4;
	static struct s_parent	s_parent;
	static struct s_queue	s_queue;
	static struct s_runner	s_runner;
	static struct s_session	s_smtp;
d265 1
a265 14
	switch (imsg->hdr.type) {
	case IMSG_PARENT_STATS:
		s_parent = *(struct s_parent *)imsg->data;
		break;
	case IMSG_QUEUE_STATS:
		s_queue = *(struct s_queue *)imsg->data;
		break;
	case IMSG_RUNNER_STATS:
		s_runner = *(struct s_runner *)imsg->data;
		break;
	case IMSG_SMTP_STATS:
		s_smtp = *(struct s_session *)imsg->data;
		break;
	default:
d267 35
a301 33
	}

	left--;
	if (left > 0)
		return (0);

	printf("parent.uptime=%d\n", time(NULL) - s_parent.start);

	printf("queue.inserts.local=%zd\n", s_queue.inserts_local);
	printf("queue.inserts.remote=%zd\n", s_queue.inserts_remote);

	printf("runner.active=%zd\n", s_runner.active);

	printf("smtp.errors.linetoolong=%zd\n", s_smtp.linetoolong);
	printf("smtp.errors.read_eof=%zd\n", s_smtp.read_eof);
	printf("smtp.errors.read_system=%zd\n", s_smtp.read_error);
	printf("smtp.errors.read_timeout=%zd\n", s_smtp.read_timeout);
	printf("smtp.errors.tempfail=%zd\n", s_smtp.tempfail);
	printf("smtp.errors.toofast=%zd\n", s_smtp.toofast);
	printf("smtp.errors.write_eof=%zd\n", s_smtp.write_eof);
	printf("smtp.errors.write_system=%zd\n", s_smtp.write_error);
	printf("smtp.errors.write_timeout=%zd\n", s_smtp.write_timeout);

	printf("smtp.sessions=%zd\n", s_smtp.sessions);
	printf("smtp.sessions.aborted=%zd\n", s_smtp.read_eof +
	    s_smtp.read_error + s_smtp.write_eof + s_smtp.write_error);
	printf("smtp.sessions.active=%zd\n", s_smtp.sessions_active);
	printf("smtp.sessions.timeout=%zd\n", s_smtp.read_timeout +
	    s_smtp.write_timeout);
	printf("smtp.sessions.smtps=%zd\n", s_smtp.smtps);
	printf("smtp.sessions.smtps.active=%zd\n", s_smtp.smtps_active);
	printf("smtp.sessions.starttls=%zd\n", s_smtp.starttls);
	printf("smtp.sessions.starttls.active=%zd\n", s_smtp.starttls_active);
@


1.25
log
@Complete rework of bufferevent event masking allowing for  more
strictness:
- Drop clients attempting command pipelining; protects the daemon
from all kinds of abuse.
- Replace F_EVLOCKED flag with F_WRITEONLY which has cleaner sematics:
when up, session must not be destroyed nor read from, but may be
written to.
- Write callback becomes a central place for enabling EV_READ.
- Delay bufferevent creation until after ssl handshake is completed.

A bunch of session error stats were added to smtpctl's "show stats".
These could help spotting event masking errors in the future.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.24 2009/04/23 08:28:45 jacekm Exp $	*/
d172 1
a172 1
		imsg_compose(ibuf, IMSG_MDA_RESUME, 0, 0, -1, NULL, 0);
@


1.24
log
@sort "show stats" output
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.23 2009/04/21 18:12:05 jacekm Exp $	*/
d297 10
d308 2
a309 1
	printf("smtp.sessions.aborted=%zd\n", s_smtp.aborted);
d311 2
a312 1
	printf("smtp.sessions.timeout=%zd\n", s_smtp.timeout);
@


1.23
log
@Make /usr/sbin/sendmail not fail due to smtpd being down.

The approach is to save cmdline + stdin in a file under a newly
added directory /var/spool/smtpd/offline (uid 0 gid 0 mode 1777).
Next time daemon starts, it uses information in that directory
to replay sendmail on user's behalf.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.22 2009/04/20 17:07:01 jacekm Exp $	*/
d299 1
a300 1
	printf("smtp.sessions.active=%zd\n", s_smtp.sessions_active);
@


1.22
log
@Rewrite smtp session timeouts; use evtimer_* from event(3) instead
of regularly walking session tree in search of idle clients. Gives
the smtp process a chance to become idle.

As a bonus, add smtp.sessions.timeout counter to "smtpctl show stats".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.21 2009/04/16 15:35:06 jacekm Exp $	*/
a47 1
int		enqueue(int, char **);
d135 3
a137 1
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
d139 1
@


1.21
log
@Total rewrite of the sendmail interface. Adds support for -t, -v,
and -F cmdline args. Also, date and Message-Id headers are added
when missing.

The main trouble with the current enqueue code is that it requires
dealing with problems in the control process that are already solved
in the smtp process, ie. duplicating a lot of code which interacts
with untrusted clients. This diff solves this by making sendmail
obtain a SMTP socket from smtp via smtpd.sock, and using that socket
to deliver the message. For smtpd it looks as if connection was
made from the network, only difference being the F_MESSAGE_ENQUEUED
message flag, handy when differentation between local and remote
deliveries is wanted.

Most of the features come from the femail program, created by henning@@.

Additional testing by Nigel J. Taylor.

ok gilles@@, henning@@ happy with smtpd using femail code
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.20 2009/04/15 20:34:59 jacekm Exp $	*/
d297 1
@


1.20
log
@s/ssmtp/smtps/; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.19 2009/03/23 21:48:40 jmc Exp $	*/
d79 2
a80 1
		fprintf(stderr, "usage: %s [-i] rcpt [...]\n", __progname);
@


1.19
log
@various minor improvements; ok jacekm gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.18 2009/03/22 13:52:03 ian Exp $	*/
d297 2
a298 2
	printf("smtp.sessions.ssmtp=%zd\n", s_smtp.ssmtp);
	printf("smtp.sessions.ssmtp.active=%zd\n", s_smtp.ssmtp_active);
@


1.18
log
@trivial message repair, ok jacek@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.17 2009/03/15 19:32:10 gilles Exp $	*/
d81 1
a81 1
		fprintf(stderr, "usage: %s <command> [arg [...]]\n", __progname);
@


1.17
log
@since we are going to share code in smtp sessions and mta sessions, we need
to also share the statistics structure, still being worked on
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.16 2009/03/01 12:12:58 jacekm Exp $	*/
d79 1
a79 1
		fprintf(stderr, "usage: %s [-i] rcpt [...]]\n", __progname);
@


1.16
log
@In "smtpctl show stats", break queue.inserts into queue.inserts.remote
and queue.inserts.local; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.15 2009/02/24 12:07:47 gilles Exp $	*/
d264 1
a264 1
	static struct s_smtp	s_smtp;
d277 1
a277 1
		s_smtp = *(struct s_smtp *)imsg->data;
@


1.15
log
@teach smtpctl's parser how to deal with parameters that are not necessarily
a token so that it is possible to do: smtpctl schedule <message id/uid>

introduce F_MESSAGE_FORCESCHEDULE which lets the runner schedule a message
even if the retry delay has not been expired.

F_MESSAGE_ENQUEUED is a valid flag for a message and should not cause an\
errx() in smtpctl show queue
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.14 2009/02/17 22:49:22 jacekm Exp $	*/
d289 2
a290 1
	printf("queue.inserts=%zd\n", s_queue.inserts);
@


1.14
log
@imsg_init depends on ibuf being calloc'd. fix few places where malloc
is used instead; ok gilles@@

Problem made visible by malloc.conf = AFGJ, and pointed out by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.13 2009/02/13 20:44:46 jacekm Exp $	*/
d50 1
d65 1
d177 9
d211 1
@


1.13
log
@Make stats output more sysctl-like by killing spaces around '='; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.12 2009/01/30 21:52:55 gilles Exp $	*/
d136 1
a136 1
	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
@


1.12
log
@when decreasing ssl related counters, make sure the session was flagged as
F_SECURE. while at it, add "smtp.sessions.aborted" which keeps track of
sessions which were interrupted before completion.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.11 2009/01/30 21:40:21 gilles Exp $	*/
d275 1
a275 1
	printf("parent.uptime = %d\n", time(NULL) - s_parent.start);
d277 1
a277 1
	printf("queue.inserts = %zd\n", s_queue.inserts);
d279 1
a279 1
	printf("runner.active = %zd\n", s_runner.active);
d281 7
a287 7
	printf("smtp.sessions = %zd\n", s_smtp.sessions);
	printf("smtp.sessions.aborted = %zd\n", s_smtp.aborted);
	printf("smtp.sessions.active = %zd\n", s_smtp.sessions_active);
	printf("smtp.sessions.ssmtp = %zd\n", s_smtp.ssmtp);
	printf("smtp.sessions.ssmtp.active = %zd\n", s_smtp.ssmtp_active);
	printf("smtp.sessions.starttls = %zd\n", s_smtp.starttls);
	printf("smtp.sessions.starttls.active = %zd\n", s_smtp.starttls_active);
@


1.11
log
@improve statistics for smtp process. not only collect the current sessions
count, but also the total sessions count, ssmtp sessions (both current and
total) and starttls sessions (both current and total)

# ./smtpctl/smtpctl show stats|grep smtp.sessions
smtp.sessions = 0
smtp.sessions.active = 0
smtp.sessions.ssmtp = 0
smtp.sessions.ssmtp.active = 0
smtp.sessions.starttls = 0
smtp.sessions.starttls.active = 0
#
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.9 2009/01/29 22:34:21 jacekm Exp $	*/
d282 1
@


1.10
log
@clear the F_EVLOCK flag earlier to prevent the error event handler from
being called again with F_EVLOCK set. this fixes a bug where disconnect
after smtpd sends greeting and before entering any command failed to go
into session_destroy().

while at it, rename the "smtp.clients" statistic to "smtp.sessions" and
add counters to struct s_smtp so that I can add ssmtp and starttls with
my next commit ;)
@
text
@d276 1
d278 1
d280 1
d282 5
@


1.9
log
@fix compiler warning
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.8 2009/01/29 21:59:15 jacekm Exp $	*/
d278 1
a278 1
	printf("smtp.clients = %zd\n", s_smtp.clients);
@


1.8
log
@Implement "smtpctl show stats"; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.7 2009/01/29 12:43:25 jacekm Exp $	*/
d275 1
a275 1
	printf("parent.uptime = %zd\n", time(NULL) - s_parent.start);
@


1.7
log
@Common queue walking code for smtpd and smtpctl. Kills majority of showqueue.c,
the remaining code was moved to queue_shared.c; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.6 2009/01/27 22:48:29 gilles Exp $	*/
d47 1
d172 3
d208 3
d242 38
@


1.6
log
@first bricks of enqueue code which allows smtpctl to submit mail to queue
without "talking" smtp to listeners. currently, a big part of the server
side code is done (and requires a cleanup), next step is to get it usable
properly from a mail user agent.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.5 2009/01/04 22:35:09 gilles Exp $	*/
a46 2
void		show_queue(int);
void		show_runqueue(int);
d113 1
a113 1
			show_queue(0);
d116 1
a116 1
			show_runqueue(0);
@


1.5
log
@- smtp can now pause/resume the accepting of incoming messages
- smtpctl recognizes "pause incoming" and "resume incoming"
- setup imsg communication between control process and smtp process
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.4 2009/01/04 19:37:41 gilles Exp $	*/
d49 1
d69 3
d77 4
a80 1
	fprintf(stderr, "usage: %s <command> [arg [...]]\n", __progname);
d95 1
a95 1
	struct parse_result	*res;
a100 4
	/* check for root privileges */
	if (geteuid())
		errx(1, "need root privileges");

d102 22
a123 13
	if ((res = parse(argc - 1, argv + 1)) == NULL)
		exit(1);

	/* handle "disconnected" commands */
	switch (res->action) {
	case SHOW_QUEUE:
		show_queue(0);
		break;
	case SHOW_RUNQUEUE:
		show_runqueue(0);
		break;
	default:
		goto connected;
a124 1
	return 0;
d141 3
a238 1

@


1.4
log
@- runner is now capable of pausing/resuming the scheduling of deliveries
for both mda and mta batches.
- smtpctl can be used to disable/enable deliveries at runtime using the
pause/resume commands.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.3 2008/12/27 16:45:01 jacekm Exp $	*/
d142 1
a142 1
		imsg_compose(ibuf, IMSG_RUNNER_PAUSE_MDA, 0, 0, -1, NULL, 0);
d145 4
a148 1
		imsg_compose(ibuf, IMSG_RUNNER_PAUSE_MTA, 0, 0, -1, NULL, 0);
d151 1
a151 1
		imsg_compose(ibuf, IMSG_RUNNER_RESUME_MDA, 0, 0, -1, NULL, 0);
d154 4
a157 1
		imsg_compose(ibuf, IMSG_RUNNER_RESUME_MTA, 0, 0, -1, NULL, 0);
d186 1
d189 1
@


1.3
log
@Break showqueue and showrunqueue into 2 words; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.2 2008/12/06 02:44:08 gilles Exp $	*/
d141 12
d178 4
@


1.2
log
@- teach smtpctl how to inspect queue and runqueue, it supports two commands
	`showqueue' which displays the content of the queue (all envelopes)
	`showrunqueue` which displays envelopes scheduled for delivery. The
	utility will be improved and extended, but for now we need at least
	this basic support to help debug queue-related issues.

	Output format is spamdb-alike:
	type|envelope uid|sender|recipient|last delivery date|retry count

	ok jacek@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpctl.c,v 1.1 2008/12/05 03:28:37 gilles Exp $	*/
d104 1
a104 1
	case SHOWQUEUE:
d107 1
a107 1
	case SHOWRUNQUEUE:
a128 1
	done = 0;
d144 2
d172 2
@


1.1
log
@- smtpctl utility to control the smtpd, don't expect too much yet as it is
	just an empty clone of relayctl with the glue needed to have it
	exchange imsg with smtpd correctly. code mostly by pyr@@, reviewed
	by chl@@ and I a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.33 2008/01/31 12:12:50 thib Exp $	*/
d47 2
d94 4
d102 14
@

