head	1.530;
access;
symbols
	OPENBSD_6_1:1.530.0.2
	OPENBSD_6_1_BASE:1.530
	OPENBSD_6_0:1.516.0.4
	OPENBSD_6_0_BASE:1.516
	OPENBSD_5_9:1.513.0.2
	OPENBSD_5_9_BASE:1.513
	OPENBSD_5_8:1.474.0.4
	OPENBSD_5_8_BASE:1.474
	OPENBSD_5_7:1.473.0.2
	OPENBSD_5_7_BASE:1.473
	OPENBSD_5_6:1.468.0.4
	OPENBSD_5_6_BASE:1.468
	OPENBSD_5_5:1.450.0.2
	OPENBSD_5_5_BASE:1.450
	OPENBSD_5_4:1.423.0.2
	OPENBSD_5_4_BASE:1.423
	OPENBSD_5_3:1.407.0.2
	OPENBSD_5_3_BASE:1.407
	OPENBSD_5_2:1.310.0.2
	OPENBSD_5_2_BASE:1.310
	OPENBSD_5_1_BASE:1.286
	OPENBSD_5_1:1.286.0.2
	OPENBSD_5_0:1.229.0.2
	OPENBSD_5_0_BASE:1.229
	OPENBSD_4_9:1.200.0.2
	OPENBSD_4_9_BASE:1.200
	OPENBSD_4_8:1.193.0.2
	OPENBSD_4_8_BASE:1.193
	OPENBSD_4_7:1.170.0.2
	OPENBSD_4_7_BASE:1.170
	OPENBSD_4_6:1.129.0.4
	OPENBSD_4_6_BASE:1.129
	OPENBSD_4_5:1.77.0.2
	OPENBSD_4_5_BASE:1.77;
locks; strict;
comment	@ * @;


1.530
date	2017.02.13.12.23.47;	author gilles;	state Exp;
branches;
next	1.529;
commitid	YoNQfVbDQc2kwy0s;

1.529
date	2017.02.03.08.23.46;	author guenther;	state Exp;
branches;
next	1.528;
commitid	RkgZAc0srXet0WqL;

1.528
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.527;
commitid	jM4eOMW1AJwdfKrr;

1.527
date	2016.11.30.18.38.32;	author eric;	state Exp;
branches;
next	1.526;
commitid	FwxH1kwyHJkP7A4S;

1.526
date	2016.11.30.11.52.48;	author eric;	state Exp;
branches;
next	1.525;
commitid	HLHuvF4EZizEJJ0M;

1.525
date	2016.11.25.09.21.21;	author gilles;	state Exp;
branches;
next	1.524;
commitid	i0WTm5qmEuQnkvJ0;

1.524
date	2016.11.17.17.34.55;	author eric;	state Exp;
branches;
next	1.523;
commitid	8UKnvWDg7NJwNwWd;

1.523
date	2016.09.04.09.33.49;	author eric;	state Exp;
branches;
next	1.522;
commitid	k6ATrLH73tETES8n;

1.522
date	2016.09.03.16.06.26;	author eric;	state Exp;
branches;
next	1.521;
commitid	KHEgnvbdOZ4TgZyl;

1.521
date	2016.09.01.10.54.25;	author eric;	state Exp;
branches;
next	1.520;
commitid	fYsbH2IujjKSME9c;

1.520
date	2016.09.01.10.07.20;	author eric;	state Exp;
branches;
next	1.519;
commitid	Ch0RMqdovbewwGAQ;

1.519
date	2016.08.31.21.49.01;	author eric;	state Exp;
branches;
next	1.518;
commitid	nfyDx1DVV3J9mwcW;

1.518
date	2016.08.31.15.24.04;	author gilles;	state Exp;
branches;
next	1.517;
commitid	NECHGW1EDKL3apgc;

1.517
date	2016.08.31.10.18.08;	author gilles;	state Exp;
branches;
next	1.516;
commitid	jWkTljYAPNXFatSw;

1.516
date	2016.07.24.16.04.53;	author gilles;	state Exp;
branches;
next	1.515;
commitid	M4HqXOaOTSNU0JT4;

1.515
date	2016.05.28.21.21.20;	author eric;	state Exp;
branches;
next	1.514;
commitid	KhU4hSodVCiVoZ62;

1.514
date	2016.03.25.15.06.58;	author krw;	state Exp;
branches;
next	1.513;
commitid	0NIU7T9t8yqZHZQl;

1.513
date	2016.02.21.15.17.25;	author gilles;	state Exp;
branches;
next	1.512;
commitid	0wCJWvU8FgEygIUl;

1.512
date	2016.02.13.20.43.07;	author gilles;	state Exp;
branches;
next	1.511;
commitid	qHtqvYWG27YyW9EZ;

1.511
date	2016.02.05.19.21.04;	author jung;	state Exp;
branches;
next	1.510;
commitid	EaIqIFqjlnzBEQGD;

1.510
date	2016.01.27.12.46.03;	author sunil;	state Exp;
branches;
next	1.509;
commitid	zKnEiCIfZ7vWdZVV;

1.509
date	2016.01.04.13.30.20;	author jung;	state Exp;
branches;
next	1.508;
commitid	CF2whypVOFPTyiTY;

1.508
date	2015.12.13.11.06.13;	author gilles;	state Exp;
branches;
next	1.507;
commitid	gGRH8DZn3x91Ps32;

1.507
date	2015.12.13.09.52.44;	author gilles;	state Exp;
branches;
next	1.506;
commitid	OUT78jWdQV3PCjhK;

1.506
date	2015.12.12.17.16.56;	author gilles;	state Exp;
branches;
next	1.505;
commitid	O1qQ3TEBrjXRGaeN;

1.505
date	2015.12.12.12.22.26;	author gilles;	state Exp;
branches;
next	1.504;
commitid	w98xM5rwyFdbQWM5;

1.504
date	2015.12.12.10.52.22;	author gilles;	state Exp;
branches;
next	1.503;
commitid	xkUuJSgKQnjAYEPu;

1.503
date	2015.12.12.10.03.33;	author gilles;	state Exp;
branches;
next	1.502;
commitid	tw51bmtlyugOnMcB;

1.502
date	2015.12.12.10.00.59;	author gilles;	state Exp;
branches;
next	1.501;
commitid	Tn5fg2ReiKLIkThb;

1.501
date	2015.12.12.09.58.33;	author gilles;	state Exp;
branches;
next	1.500;
commitid	LxzPBzTILWTZofuD;

1.500
date	2015.12.12.09.09.40;	author gilles;	state Exp;
branches;
next	1.499;
commitid	qURFTJ289CU71OTq;

1.499
date	2015.12.12.09.00.22;	author gilles;	state Exp;
branches;
next	1.498;
commitid	fBIblfrnKYx0CCqR;

1.498
date	2015.12.12.08.35.19;	author gilles;	state Exp;
branches;
next	1.497;
commitid	a6Im8Op2Y1HqHkyB;

1.497
date	2015.12.11.21.44.01;	author gilles;	state Exp;
branches;
next	1.496;
commitid	4sl0Vm3vIoWoEZs0;

1.496
date	2015.12.11.07.51.38;	author gilles;	state Exp;
branches;
next	1.495;
commitid	h5MJW0yIphCIq8s0;

1.495
date	2015.12.11.07.48.33;	author gilles;	state Exp;
branches;
next	1.494;
commitid	EFDZoUEuv0uAiKaq;

1.494
date	2015.12.07.12.29.19;	author sunil;	state Exp;
branches;
next	1.493;
commitid	NjgUX1eM1Q27CUqm;

1.493
date	2015.12.03.21.11.33;	author jung;	state Exp;
branches;
next	1.492;
commitid	KMDOdtoOlQlcNX1b;

1.492
date	2015.12.01.18.22.30;	author gilles;	state Exp;
branches;
next	1.491;
commitid	qHxbKaYfo1Z7mM09;

1.491
date	2015.12.01.09.39.07;	author gilles;	state Exp;
branches;
next	1.490;
commitid	FtZctoCbNkux44w3;

1.490
date	2015.12.01.09.33.17;	author gilles;	state Exp;
branches;
next	1.489;
commitid	Y91zLTPzwb4lVNZb;

1.489
date	2015.11.30.14.27.25;	author gilles;	state Exp;
branches;
next	1.488;
commitid	3CmWgQYA3M7IDkDS;

1.488
date	2015.11.30.14.13.03;	author gilles;	state Exp;
branches;
next	1.487;
commitid	uzQcYiSR90ELNfI7;

1.487
date	2015.11.30.12.49.35;	author gilles;	state Exp;
branches;
next	1.486;
commitid	ZyOzw2IPUjoaWKi5;

1.486
date	2015.11.30.12.26.55;	author sunil;	state Exp;
branches;
next	1.485;
commitid	aGcPak9vEg5kOQ24;

1.485
date	2015.11.23.21.50.12;	author gilles;	state Exp;
branches;
next	1.484;
commitid	HCn8C2lUMSgPueow;

1.484
date	2015.11.05.09.14.31;	author sunil;	state Exp;
branches;
next	1.483;
commitid	3vo6L6sIqhuEjLcD;

1.483
date	2015.10.29.10.25.36;	author sunil;	state Exp;
branches;
next	1.482;
commitid	TXZugvtal96cI6ec;

1.482
date	2015.10.28.14.30.03;	author gilles;	state Exp;
branches;
next	1.481;
commitid	QT5VIPQgbnYXebKH;

1.481
date	2015.10.28.07.25.30;	author gilles;	state Exp;
branches;
next	1.480;
commitid	t4n4PUOhsPwX6dRm;

1.480
date	2015.10.27.20.14.19;	author gilles;	state Exp;
branches;
next	1.479;
commitid	GOsX5yaydgUh46mb;

1.479
date	2015.10.21.16.44.28;	author jsing;	state Exp;
branches;
next	1.478;
commitid	VeKjz2xsP9Q9IzaX;

1.478
date	2015.10.17.22.24.36;	author gilles;	state Exp;
branches;
next	1.477;
commitid	Xkf5erzxtvmccNIE;

1.477
date	2015.10.14.22.16.38;	author gilles;	state Exp;
branches;
next	1.476;
commitid	t4iuuhcr1JYW1Pha;

1.476
date	2015.10.09.14.37.38;	author gilles;	state Exp;
branches;
next	1.475;
commitid	Av5gnXBLeZb6m0W2;

1.475
date	2015.09.07.15.36.53;	author gilles;	state Exp;
branches;
next	1.474;
commitid	8taqn8BdlYqlAC0r;

1.474
date	2015.04.19.20.29.12;	author gilles;	state Exp;
branches;
next	1.473;
commitid	bBwp0YicyQAoRflI;

1.473
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches
	1.473.2.1;
next	1.472;
commitid	ZBTFreARDSMmzOIV;

1.472
date	2014.12.24.13.53.39;	author eric;	state Exp;
branches;
next	1.471;
commitid	1nvxo7U2tVx1d6Y4;

1.471
date	2014.12.14.15.26.56;	author gilles;	state Exp;
branches;
next	1.470;
commitid	101jHHHL4Fs6QGmi;

1.470
date	2014.11.16.19.07.50;	author bluhm;	state Exp;
branches;
next	1.469;
commitid	ohVlnYugDUFcNu2w;

1.469
date	2014.10.15.08.09.02;	author gilles;	state Exp;
branches;
next	1.468;
commitid	vGE3mGVwO8jbYedn;

1.468
date	2014.07.10.14.45.02;	author eric;	state Exp;
branches
	1.468.4.1;
next	1.467;
commitid	dolePHRcgnf1dDVL;

1.467
date	2014.07.09.12.44.54;	author eric;	state Exp;
branches;
next	1.466;
commitid	4IcOkOZNwhQIYGGx;

1.466
date	2014.07.09.09.53.37;	author eric;	state Exp;
branches;
next	1.465;
commitid	RHRCVJhvTqNHZi7Q;

1.465
date	2014.07.08.21.58.33;	author eric;	state Exp;
branches;
next	1.464;
commitid	AEY7C0r4blCyV4nd;

1.464
date	2014.07.08.20.14.46;	author eric;	state Exp;
branches;
next	1.463;
commitid	AHjSiMjlXwD7KM7Y;

1.463
date	2014.07.08.15.45.32;	author eric;	state Exp;
branches;
next	1.462;
commitid	BLF7pkUK3dHr6Hox;

1.462
date	2014.07.08.13.49.09;	author eric;	state Exp;
branches;
next	1.461;
commitid	pEybL9fsrDOC6PJj;

1.461
date	2014.05.04.16.38.19;	author reyk;	state Exp;
branches;
next	1.460;

1.460
date	2014.05.01.15.50.20;	author reyk;	state Exp;
branches;
next	1.459;

1.459
date	2014.04.30.09.17.29;	author gilles;	state Exp;
branches;
next	1.458;

1.458
date	2014.04.30.08.23.43;	author reyk;	state Exp;
branches;
next	1.457;

1.457
date	2014.04.29.19.13.14;	author reyk;	state Exp;
branches;
next	1.456;

1.456
date	2014.04.29.12.18.27;	author reyk;	state Exp;
branches;
next	1.455;

1.455
date	2014.04.19.16.55.15;	author gilles;	state Exp;
branches;
next	1.454;

1.454
date	2014.04.09.18.55.19;	author eric;	state Exp;
branches;
next	1.453;

1.453
date	2014.04.09.12.47.23;	author eric;	state Exp;
branches;
next	1.452;

1.452
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.451;

1.451
date	2014.03.22.09.41.28;	author gilles;	state Exp;
branches;
next	1.450;

1.450
date	2014.02.17.13.33.56;	author eric;	state Exp;
branches
	1.450.2.1;
next	1.449;

1.449
date	2014.02.10.09.28.05;	author eric;	state Exp;
branches;
next	1.448;

1.448
date	2014.02.04.15.44.06;	author eric;	state Exp;
branches;
next	1.447;

1.447
date	2014.02.04.15.22.39;	author eric;	state Exp;
branches;
next	1.446;

1.446
date	2014.02.04.14.56.03;	author eric;	state Exp;
branches;
next	1.445;

1.445
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.444;

1.444
date	2014.02.04.10.38.06;	author eric;	state Exp;
branches;
next	1.443;

1.443
date	2014.02.04.09.50.31;	author eric;	state Exp;
branches;
next	1.442;

1.442
date	2014.02.04.09.05.06;	author eric;	state Exp;
branches;
next	1.441;

1.441
date	2013.12.06.14.26.25;	author eric;	state Exp;
branches;
next	1.440;

1.440
date	2013.12.05.10.06.32;	author eric;	state Exp;
branches;
next	1.439;

1.439
date	2013.12.03.09.06.26;	author eric;	state Exp;
branches;
next	1.438;

1.438
date	2013.11.30.10.11.57;	author eric;	state Exp;
branches;
next	1.437;

1.437
date	2013.11.28.13.13.56;	author eric;	state Exp;
branches;
next	1.436;

1.436
date	2013.11.20.09.22.42;	author eric;	state Exp;
branches;
next	1.435;

1.435
date	2013.11.19.10.01.20;	author eric;	state Exp;
branches;
next	1.434;

1.434
date	2013.11.18.12.24.26;	author eric;	state Exp;
branches;
next	1.433;

1.433
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.432;

1.432
date	2013.10.30.21.37.48;	author eric;	state Exp;
branches;
next	1.431;

1.431
date	2013.10.29.17.04.46;	author eric;	state Exp;
branches;
next	1.430;

1.430
date	2013.10.29.14.30.05;	author eric;	state Exp;
branches;
next	1.429;

1.429
date	2013.10.29.11.23.58;	author eric;	state Exp;
branches;
next	1.428;

1.428
date	2013.10.27.17.47.53;	author eric;	state Exp;
branches;
next	1.427;

1.427
date	2013.10.27.11.01.47;	author eric;	state Exp;
branches;
next	1.426;

1.426
date	2013.10.27.07.56.25;	author eric;	state Exp;
branches;
next	1.425;

1.425
date	2013.10.26.20.32.48;	author eric;	state Exp;
branches;
next	1.424;

1.424
date	2013.10.25.21.31.23;	author eric;	state Exp;
branches;
next	1.423;

1.423
date	2013.07.19.22.22.39;	author eric;	state Exp;
branches;
next	1.422;

1.422
date	2013.07.19.21.34.31;	author eric;	state Exp;
branches;
next	1.421;

1.421
date	2013.07.19.21.14.52;	author eric;	state Exp;
branches;
next	1.420;

1.420
date	2013.07.19.20.37.07;	author eric;	state Exp;
branches;
next	1.419;

1.419
date	2013.07.19.19.53.33;	author eric;	state Exp;
branches;
next	1.418;

1.418
date	2013.07.19.16.02.00;	author eric;	state Exp;
branches;
next	1.417;

1.417
date	2013.07.19.15.14.23;	author eric;	state Exp;
branches;
next	1.416;

1.416
date	2013.07.19.13.41.23;	author eric;	state Exp;
branches;
next	1.415;

1.415
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.414;

1.414
date	2013.07.19.08.12.19;	author eric;	state Exp;
branches;
next	1.413;

1.413
date	2013.07.19.07.49.08;	author eric;	state Exp;
branches;
next	1.412;

1.412
date	2013.07.19.07.37.29;	author eric;	state Exp;
branches;
next	1.411;

1.411
date	2013.06.04.08.42.00;	author eric;	state Exp;
branches;
next	1.410;

1.410
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.409;

1.409
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.408;

1.408
date	2013.03.06.21.42.40;	author sthen;	state Exp;
branches;
next	1.407;

1.407
date	2013.02.15.22.43.21;	author eric;	state Exp;
branches;
next	1.406;

1.406
date	2013.02.14.13.11.40;	author gilles;	state Exp;
branches;
next	1.405;

1.405
date	2013.02.14.12.30.49;	author gilles;	state Exp;
branches;
next	1.404;

1.404
date	2013.02.10.15.01.16;	author eric;	state Exp;
branches;
next	1.403;

1.403
date	2013.02.05.15.23.40;	author gilles;	state Exp;
branches;
next	1.402;

1.402
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.401;

1.401
date	2013.01.31.18.24.47;	author eric;	state Exp;
branches;
next	1.400;

1.400
date	2013.01.28.16.40.22;	author eric;	state Exp;
branches;
next	1.399;

1.399
date	2013.01.28.11.09.53;	author gilles;	state Exp;
branches;
next	1.398;

1.398
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.397;

1.397
date	2012.11.23.09.25.44;	author eric;	state Exp;
branches;
next	1.396;

1.396
date	2012.11.20.09.47.46;	author eric;	state Exp;
branches;
next	1.395;

1.395
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.394;

1.394
date	2012.11.02.19.30.57;	author eric;	state Exp;
branches;
next	1.393;

1.393
date	2012.11.02.16.02.33;	author eric;	state Exp;
branches;
next	1.392;

1.392
date	2012.11.02.14.46.43;	author eric;	state Exp;
branches;
next	1.391;

1.391
date	2012.10.28.08.46.26;	author eric;	state Exp;
branches;
next	1.390;

1.390
date	2012.10.16.12.02.23;	author eric;	state Exp;
branches;
next	1.389;

1.389
date	2012.10.14.11.58.23;	author gilles;	state Exp;
branches;
next	1.388;

1.388
date	2012.10.12.08.51.02;	author eric;	state Exp;
branches;
next	1.387;

1.387
date	2012.10.11.21.43.11;	author gilles;	state Exp;
branches;
next	1.386;

1.386
date	2012.10.11.21.14.32;	author gilles;	state Exp;
branches;
next	1.385;

1.385
date	2012.10.10.20.29.46;	author gilles;	state Exp;
branches;
next	1.384;

1.384
date	2012.10.10.19.39.11;	author gilles;	state Exp;
branches;
next	1.383;

1.383
date	2012.10.10.18.02.37;	author eric;	state Exp;
branches;
next	1.382;

1.382
date	2012.10.09.20.33.02;	author gilles;	state Exp;
branches;
next	1.381;

1.381
date	2012.10.08.20.35.16;	author gilles;	state Exp;
branches;
next	1.380;

1.380
date	2012.10.07.17.21.37;	author eric;	state Exp;
branches;
next	1.379;

1.379
date	2012.10.07.15.46.38;	author chl;	state Exp;
branches;
next	1.378;

1.378
date	2012.10.03.19.42.16;	author gilles;	state Exp;
branches;
next	1.377;

1.377
date	2012.10.03.17.58.03;	author gilles;	state Exp;
branches;
next	1.376;

1.376
date	2012.09.30.14.28.16;	author gilles;	state Exp;
branches;
next	1.375;

1.375
date	2012.09.29.11.02.41;	author eric;	state Exp;
branches;
next	1.374;

1.374
date	2012.09.29.10.35.01;	author eric;	state Exp;
branches;
next	1.373;

1.373
date	2012.09.29.10.32.08;	author eric;	state Exp;
branches;
next	1.372;

1.372
date	2012.09.28.17.28.30;	author eric;	state Exp;
branches;
next	1.371;

1.371
date	2012.09.28.13.40.21;	author eric;	state Exp;
branches;
next	1.370;

1.370
date	2012.09.28.12.00.09;	author eric;	state Exp;
branches;
next	1.369;

1.369
date	2012.09.27.18.57.25;	author eric;	state Exp;
branches;
next	1.368;

1.368
date	2012.09.26.19.52.20;	author eric;	state Exp;
branches;
next	1.367;

1.367
date	2012.09.25.17.38.55;	author eric;	state Exp;
branches;
next	1.366;

1.366
date	2012.09.21.19.37.08;	author eric;	state Exp;
branches;
next	1.365;

1.365
date	2012.09.21.16.40.20;	author eric;	state Exp;
branches;
next	1.364;

1.364
date	2012.09.21.13.23.07;	author eric;	state Exp;
branches;
next	1.363;

1.363
date	2012.09.21.12.33.32;	author eric;	state Exp;
branches;
next	1.362;

1.362
date	2012.09.21.10.22.29;	author eric;	state Exp;
branches;
next	1.361;

1.361
date	2012.09.20.14.28.57;	author eric;	state Exp;
branches;
next	1.360;

1.360
date	2012.09.19.18.20.36;	author eric;	state Exp;
branches;
next	1.359;

1.359
date	2012.09.19.11.57.35;	author eric;	state Exp;
branches;
next	1.358;

1.358
date	2012.09.19.10.10.30;	author eric;	state Exp;
branches;
next	1.357;

1.357
date	2012.09.19.09.06.35;	author eric;	state Exp;
branches;
next	1.356;

1.356
date	2012.09.18.14.23.01;	author eric;	state Exp;
branches;
next	1.355;

1.355
date	2012.09.18.13.42.39;	author eric;	state Exp;
branches;
next	1.354;

1.354
date	2012.09.18.13.13.43;	author eric;	state Exp;
branches;
next	1.353;

1.353
date	2012.09.18.12.13.22;	author eric;	state Exp;
branches;
next	1.352;

1.352
date	2012.09.17.20.19.18;	author eric;	state Exp;
branches;
next	1.351;

1.351
date	2012.09.16.16.54.55;	author chl;	state Exp;
branches;
next	1.350;

1.350
date	2012.09.16.15.55.55;	author chl;	state Exp;
branches;
next	1.349;

1.349
date	2012.09.16.11.53.57;	author gilles;	state Exp;
branches;
next	1.348;

1.348
date	2012.09.14.19.22.04;	author eric;	state Exp;
branches;
next	1.347;

1.347
date	2012.09.11.08.37.52;	author eric;	state Exp;
branches;
next	1.346;

1.346
date	2012.09.01.16.25.27;	author gilles;	state Exp;
branches;
next	1.345;

1.345
date	2012.09.01.16.09.14;	author gilles;	state Exp;
branches;
next	1.344;

1.344
date	2012.08.30.21.59.46;	author chl;	state Exp;
branches;
next	1.343;

1.343
date	2012.08.30.19.33.25;	author chl;	state Exp;
branches;
next	1.342;

1.342
date	2012.08.30.18.25.44;	author gilles;	state Exp;
branches;
next	1.341;

1.341
date	2012.08.29.16.26.17;	author gilles;	state Exp;
branches;
next	1.340;

1.340
date	2012.08.28.14.03.49;	author chl;	state Exp;
branches;
next	1.339;

1.339
date	2012.08.26.11.52.48;	author gilles;	state Exp;
branches;
next	1.338;

1.338
date	2012.08.25.23.35.09;	author chl;	state Exp;
branches;
next	1.337;

1.337
date	2012.08.25.22.03.26;	author gilles;	state Exp;
branches;
next	1.336;

1.336
date	2012.08.25.21.33.33;	author gilles;	state Exp;
branches;
next	1.335;

1.335
date	2012.08.25.15.39.11;	author gilles;	state Exp;
branches;
next	1.334;

1.334
date	2012.08.25.11.38.18;	author gilles;	state Exp;
branches;
next	1.333;

1.333
date	2012.08.25.10.23.12;	author gilles;	state Exp;
branches;
next	1.332;

1.332
date	2012.08.24.13.21.56;	author chl;	state Exp;
branches;
next	1.331;

1.331
date	2012.08.24.13.13.13;	author chl;	state Exp;
branches;
next	1.330;

1.330
date	2012.08.24.12.29.50;	author eric;	state Exp;
branches;
next	1.329;

1.329
date	2012.08.21.20.19.46;	author eric;	state Exp;
branches;
next	1.328;

1.328
date	2012.08.21.13.13.17;	author eric;	state Exp;
branches;
next	1.327;

1.327
date	2012.08.20.21.14.17;	author gilles;	state Exp;
branches;
next	1.326;

1.326
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.325;

1.325
date	2012.08.19.10.32.32;	author chl;	state Exp;
branches;
next	1.324;

1.324
date	2012.08.19.08.45.44;	author chl;	state Exp;
branches;
next	1.323;

1.323
date	2012.08.18.20.52.36;	author eric;	state Exp;
branches;
next	1.322;

1.322
date	2012.08.18.18.18.23;	author gilles;	state Exp;
branches;
next	1.321;

1.321
date	2012.08.18.15.45.12;	author eric;	state Exp;
branches;
next	1.320;

1.320
date	2012.08.10.11.05.55;	author eric;	state Exp;
branches;
next	1.319;

1.319
date	2012.08.09.16.00.31;	author eric;	state Exp;
branches;
next	1.318;

1.318
date	2012.08.09.11.52.32;	author eric;	state Exp;
branches;
next	1.317;

1.317
date	2012.08.09.09.48.02;	author eric;	state Exp;
branches;
next	1.316;

1.316
date	2012.08.08.17.33.55;	author eric;	state Exp;
branches;
next	1.315;

1.315
date	2012.08.08.08.50.42;	author eric;	state Exp;
branches;
next	1.314;

1.314
date	2012.08.07.21.47.57;	author eric;	state Exp;
branches;
next	1.313;

1.313
date	2012.07.29.17.21.43;	author gilles;	state Exp;
branches;
next	1.312;

1.312
date	2012.07.29.16.33.01;	author eric;	state Exp;
branches;
next	1.311;

1.311
date	2012.07.29.13.56.24;	author eric;	state Exp;
branches;
next	1.310;

1.310
date	2012.07.12.08.51.43;	author chl;	state Exp;
branches;
next	1.309;

1.309
date	2012.07.10.23.21.34;	author chl;	state Exp;
branches;
next	1.308;

1.308
date	2012.07.10.16.11.43;	author chl;	state Exp;
branches;
next	1.307;

1.307
date	2012.07.10.11.13.40;	author gilles;	state Exp;
branches;
next	1.306;

1.306
date	2012.07.09.17.57.54;	author gilles;	state Exp;
branches;
next	1.305;

1.305
date	2012.07.09.09.57.53;	author gilles;	state Exp;
branches;
next	1.304;

1.304
date	2012.07.09.08.08.29;	author gilles;	state Exp;
branches;
next	1.303;

1.303
date	2012.07.08.18.13.08;	author chl;	state Exp;
branches;
next	1.302;

1.302
date	2012.07.02.17.00.05;	author eric;	state Exp;
branches;
next	1.301;

1.301
date	2012.06.20.20.45.23;	author eric;	state Exp;
branches;
next	1.300;

1.300
date	2012.06.17.15.17.08;	author gilles;	state Exp;
branches;
next	1.299;

1.299
date	2012.06.14.21.56.13;	author gilles;	state Exp;
branches;
next	1.298;

1.298
date	2012.06.03.19.52.56;	author eric;	state Exp;
branches;
next	1.297;

1.297
date	2012.06.01.10.40.14;	author chl;	state Exp;
branches;
next	1.296;

1.296
date	2012.06.01.09.24.58;	author eric;	state Exp;
branches;
next	1.295;

1.295
date	2012.05.29.19.53.10;	author gilles;	state Exp;
branches;
next	1.294;

1.294
date	2012.05.29.19.29.44;	author gilles;	state Exp;
branches;
next	1.293;

1.293
date	2012.05.13.00.10.49;	author gilles;	state Exp;
branches;
next	1.292;

1.292
date	2012.05.12.21.49.31;	author gilles;	state Exp;
branches;
next	1.291;

1.291
date	2012.05.12.18.41.10;	author gilles;	state Exp;
branches;
next	1.290;

1.290
date	2012.05.12.17.41.27;	author eric;	state Exp;
branches;
next	1.289;

1.289
date	2012.05.12.15.29.16;	author gilles;	state Exp;
branches;
next	1.288;

1.288
date	2012.05.11.12.12.02;	author eric;	state Exp;
branches;
next	1.287;

1.287
date	2012.03.07.22.54.49;	author gilles;	state Exp;
branches;
next	1.286;

1.286
date	2012.01.31.21.05.26;	author gilles;	state Exp;
branches;
next	1.285;

1.285
date	2012.01.29.11.37.32;	author eric;	state Exp;
branches;
next	1.284;

1.284
date	2012.01.28.16.50.02;	author gilles;	state Exp;
branches;
next	1.283;

1.283
date	2012.01.28.15.11.06;	author eric;	state Exp;
branches;
next	1.282;

1.282
date	2012.01.28.11.33.07;	author gilles;	state Exp;
branches;
next	1.281;

1.281
date	2012.01.24.12.20.18;	author eric;	state Exp;
branches;
next	1.280;

1.280
date	2012.01.18.13.41.54;	author chl;	state Exp;
branches;
next	1.279;

1.279
date	2012.01.13.21.58.35;	author eric;	state Exp;
branches;
next	1.278;

1.278
date	2012.01.13.14.27.55;	author eric;	state Exp;
branches;
next	1.277;

1.277
date	2012.01.13.14.01.58;	author eric;	state Exp;
branches;
next	1.276;

1.276
date	2012.01.12.20.59.07;	author eric;	state Exp;
branches;
next	1.275;

1.275
date	2012.01.12.18.06.18;	author eric;	state Exp;
branches;
next	1.274;

1.274
date	2012.01.12.15.01.33;	author eric;	state Exp;
branches;
next	1.273;

1.273
date	2012.01.11.22.55.16;	author gilles;	state Exp;
branches;
next	1.272;

1.272
date	2012.01.11.22.24.37;	author gilles;	state Exp;
branches;
next	1.271;

1.271
date	2012.01.11.17.46.36;	author eric;	state Exp;
branches;
next	1.270;

1.270
date	2012.01.11.17.07.18;	author eric;	state Exp;
branches;
next	1.269;

1.269
date	2011.12.27.17.13.05;	author eric;	state Exp;
branches;
next	1.268;

1.268
date	2011.12.18.22.55.31;	author chl;	state Exp;
branches;
next	1.267;

1.267
date	2011.12.14.23.08.40;	author eric;	state Exp;
branches;
next	1.266;

1.266
date	2011.12.14.22.28.02;	author eric;	state Exp;
branches;
next	1.265;

1.265
date	2011.12.14.18.42.27;	author eric;	state Exp;
branches;
next	1.264;

1.264
date	2011.12.14.17.55.55;	author eric;	state Exp;
branches;
next	1.263;

1.263
date	2011.12.13.23.55.00;	author gilles;	state Exp;
branches;
next	1.262;

1.262
date	2011.12.13.22.04.35;	author eric;	state Exp;
branches;
next	1.261;

1.261
date	2011.12.13.21.44.47;	author gilles;	state Exp;
branches;
next	1.260;

1.260
date	2011.12.12.17.20.36;	author eric;	state Exp;
branches;
next	1.259;

1.259
date	2011.12.12.16.45.16;	author chl;	state Exp;
branches;
next	1.258;

1.258
date	2011.12.11.19.58.09;	author eric;	state Exp;
branches;
next	1.257;

1.257
date	2011.12.11.17.02.10;	author eric;	state Exp;
branches;
next	1.256;

1.256
date	2011.12.08.17.00.28;	author todd;	state Exp;
branches;
next	1.255;

1.255
date	2011.11.28.20.29.27;	author chl;	state Exp;
branches;
next	1.254;

1.254
date	2011.11.21.18.57.54;	author eric;	state Exp;
branches;
next	1.253;

1.253
date	2011.11.16.19.38.56;	author eric;	state Exp;
branches;
next	1.252;

1.252
date	2011.11.16.11.18.55;	author eric;	state Exp;
branches;
next	1.251;

1.251
date	2011.11.15.23.06.39;	author gilles;	state Exp;
branches;
next	1.250;

1.250
date	2011.11.14.19.23.41;	author chl;	state Exp;
branches;
next	1.249;

1.249
date	2011.11.14.11.53.10;	author eric;	state Exp;
branches;
next	1.248;

1.248
date	2011.11.07.11.14.10;	author eric;	state Exp;
branches;
next	1.247;

1.247
date	2011.10.26.20.47.31;	author gilles;	state Exp;
branches;
next	1.246;

1.246
date	2011.10.23.15.36.53;	author eric;	state Exp;
branches;
next	1.245;

1.245
date	2011.10.23.13.08.18;	author eric;	state Exp;
branches;
next	1.244;

1.244
date	2011.10.23.13.03.05;	author gilles;	state Exp;
branches;
next	1.243;

1.243
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.242;

1.242
date	2011.10.22.00.16.34;	author eric;	state Exp;
branches;
next	1.241;

1.241
date	2011.10.09.18.39.54;	author eric;	state Exp;
branches;
next	1.240;

1.240
date	2011.09.19.13.10.47;	author chl;	state Exp;
branches;
next	1.239;

1.239
date	2011.09.18.21.37.53;	author gilles;	state Exp;
branches;
next	1.238;

1.238
date	2011.09.12.20.47.15;	author gilles;	state Exp;
branches;
next	1.237;

1.237
date	2011.09.01.19.56.49;	author eric;	state Exp;
branches;
next	1.236;

1.236
date	2011.08.31.18.56.30;	author gilles;	state Exp;
branches;
next	1.235;

1.235
date	2011.08.27.22.37.35;	author gilles;	state Exp;
branches;
next	1.234;

1.234
date	2011.08.27.22.32.41;	author gilles;	state Exp;
branches;
next	1.233;

1.233
date	2011.08.17.20.35.11;	author gilles;	state Exp;
branches;
next	1.232;

1.232
date	2011.08.17.20.04.43;	author gilles;	state Exp;
branches;
next	1.231;

1.231
date	2011.08.17.19.36.23;	author gilles;	state Exp;
branches;
next	1.230;

1.230
date	2011.08.16.19.02.03;	author gilles;	state Exp;
branches;
next	1.229;

1.229
date	2011.07.21.23.29.24;	author gilles;	state Exp;
branches;
next	1.228;

1.228
date	2011.07.20.10.22.54;	author eric;	state Exp;
branches;
next	1.227;

1.227
date	2011.06.09.17.41.52;	author gilles;	state Exp;
branches;
next	1.226;

1.226
date	2011.05.21.19.57.34;	author gilles;	state Exp;
branches;
next	1.225;

1.225
date	2011.05.21.18.43.08;	author gilles;	state Exp;
branches;
next	1.224;

1.224
date	2011.05.17.18.54.32;	author gilles;	state Exp;
branches;
next	1.223;

1.223
date	2011.05.17.16.42.06;	author gilles;	state Exp;
branches;
next	1.222;

1.222
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.221;

1.221
date	2011.05.06.19.21.43;	author eric;	state Exp;
branches;
next	1.220;

1.220
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.219;

1.219
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.218;

1.218
date	2011.04.17.12.46.46;	author gilles;	state Exp;
branches;
next	1.217;

1.217
date	2011.04.17.11.39.23;	author gilles;	state Exp;
branches;
next	1.216;

1.216
date	2011.04.17.11.16.57;	author gilles;	state Exp;
branches;
next	1.215;

1.215
date	2011.04.15.19.03.28;	author gilles;	state Exp;
branches;
next	1.214;

1.214
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.213;

1.213
date	2011.04.14.23.26.16;	author gilles;	state Exp;
branches;
next	1.212;

1.212
date	2011.04.14.22.46.38;	author gilles;	state Exp;
branches;
next	1.211;

1.211
date	2011.04.14.22.36.09;	author gilles;	state Exp;
branches;
next	1.210;

1.210
date	2011.04.14.20.11.08;	author gilles;	state Exp;
branches;
next	1.209;

1.209
date	2011.04.14.17.06.43;	author gilles;	state Exp;
branches;
next	1.208;

1.208
date	2011.04.13.20.53.18;	author gilles;	state Exp;
branches;
next	1.207;

1.207
date	2011.04.02.16.40.19;	author eric;	state Exp;
branches;
next	1.206;

1.206
date	2011.03.29.20.43.51;	author eric;	state Exp;
branches;
next	1.205;

1.205
date	2011.03.26.21.41.31;	author eric;	state Exp;
branches;
next	1.204;

1.204
date	2011.03.26.10.59.59;	author gilles;	state Exp;
branches;
next	1.203;

1.203
date	2011.03.26.10.54.22;	author eric;	state Exp;
branches;
next	1.202;

1.202
date	2011.03.15.19.24.55;	author gilles;	state Exp;
branches;
next	1.201;

1.201
date	2011.03.09.20.59.22;	author gilles;	state Exp;
branches;
next	1.200;

1.200
date	2010.11.29.15.25.56;	author gilles;	state Exp;
branches;
next	1.199;

1.199
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.198;

1.198
date	2010.11.24.23.27.04;	author todd;	state Exp;
branches;
next	1.197;

1.197
date	2010.10.29.09.16.08;	author gilles;	state Exp;
branches;
next	1.196;

1.196
date	2010.10.28.21.15.50;	author gilles;	state Exp;
branches;
next	1.195;

1.195
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.194;

1.194
date	2010.09.20.09.01.09;	author gilles;	state Exp;
branches;
next	1.193;

1.193
date	2010.06.10.19.34.51;	author chl;	state Exp;
branches;
next	1.192;

1.192
date	2010.06.09.20.00.55;	author zinovik;	state Exp;
branches;
next	1.191;

1.191
date	2010.06.01.23.06.25;	author jacekm;	state Exp;
branches;
next	1.190;

1.190
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.189;

1.189
date	2010.06.01.14.21.52;	author jacekm;	state Exp;
branches;
next	1.188;

1.188
date	2010.05.31.23.50.28;	author jacekm;	state Exp;
branches;
next	1.187;

1.187
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.186;

1.186
date	2010.05.31.22.25.26;	author chl;	state Exp;
branches;
next	1.185;

1.185
date	2010.05.27.15.36.04;	author gilles;	state Exp;
branches;
next	1.184;

1.184
date	2010.05.27.11.18.34;	author gilles;	state Exp;
branches;
next	1.183;

1.183
date	2010.05.27.11.17.29;	author gilles;	state Exp;
branches;
next	1.182;

1.182
date	2010.04.27.10.17.53;	author gilles;	state Exp;
branches;
next	1.181;

1.181
date	2010.04.27.09.49.23;	author gilles;	state Exp;
branches;
next	1.180;

1.180
date	2010.04.22.12.56.33;	author jacekm;	state Exp;
branches;
next	1.179;

1.179
date	2010.04.21.21.47.39;	author gilles;	state Exp;
branches;
next	1.178;

1.178
date	2010.04.21.21.04.29;	author gilles;	state Exp;
branches;
next	1.177;

1.177
date	2010.04.21.19.53.16;	author gilles;	state Exp;
branches;
next	1.176;

1.176
date	2010.04.21.19.45.07;	author gilles;	state Exp;
branches;
next	1.175;

1.175
date	2010.04.21.18.54.43;	author jacekm;	state Exp;
branches;
next	1.174;

1.174
date	2010.04.20.15.34.56;	author jacekm;	state Exp;
branches;
next	1.173;

1.173
date	2010.04.19.10.12.48;	author gilles;	state Exp;
branches;
next	1.172;

1.172
date	2010.04.19.08.14.07;	author jacekm;	state Exp;
branches;
next	1.171;

1.171
date	2010.04.11.22.46.28;	author jacekm;	state Exp;
branches;
next	1.170;

1.170
date	2010.03.03.11.11.55;	author jacekm;	state Exp;
branches;
next	1.169;

1.169
date	2010.02.17.13.47.31;	author gilles;	state Exp;
branches;
next	1.168;

1.168
date	2010.01.10.16.42.35;	author gilles;	state Exp;
branches;
next	1.167;

1.167
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.166;

1.166
date	2009.12.24.14.19.46;	author gilles;	state Exp;
branches;
next	1.165;

1.165
date	2009.12.14.19.56.55;	author jacekm;	state Exp;
branches;
next	1.164;

1.164
date	2009.12.14.18.21.53;	author jacekm;	state Exp;
branches;
next	1.163;

1.163
date	2009.12.14.16.44.14;	author jacekm;	state Exp;
branches;
next	1.162;

1.162
date	2009.12.14.13.17.51;	author jacekm;	state Exp;
branches;
next	1.161;

1.161
date	2009.12.13.22.02.55;	author jacekm;	state Exp;
branches;
next	1.160;

1.160
date	2009.12.12.10.33.11;	author jacekm;	state Exp;
branches;
next	1.159;

1.159
date	2009.11.13.11.27.52;	author jacekm;	state Exp;
branches;
next	1.158;

1.158
date	2009.11.09.23.49.34;	author gilles;	state Exp;
branches;
next	1.157;

1.157
date	2009.11.08.23.20.07;	author gilles;	state Exp;
branches;
next	1.156;

1.156
date	2009.11.08.23.08.56;	author gilles;	state Exp;
branches;
next	1.155;

1.155
date	2009.11.08.21.40.05;	author gilles;	state Exp;
branches;
next	1.154;

1.154
date	2009.11.08.19.38.26;	author gilles;	state Exp;
branches;
next	1.153;

1.153
date	2009.11.05.10.27.24;	author gilles;	state Exp;
branches;
next	1.152;

1.152
date	2009.11.03.22.57.41;	author gilles;	state Exp;
branches;
next	1.151;

1.151
date	2009.11.03.20.55.23;	author gilles;	state Exp;
branches;
next	1.150;

1.150
date	2009.11.03.19.13.34;	author gilles;	state Exp;
branches;
next	1.149;

1.149
date	2009.10.19.20.48.13;	author gilles;	state Exp;
branches;
next	1.148;

1.148
date	2009.10.19.20.00.46;	author gilles;	state Exp;
branches;
next	1.147;

1.147
date	2009.10.12.22.34.37;	author gilles;	state Exp;
branches;
next	1.146;

1.146
date	2009.10.11.17.40.49;	author gilles;	state Exp;
branches;
next	1.145;

1.145
date	2009.10.07.18.09.12;	author gilles;	state Exp;
branches;
next	1.144;

1.144
date	2009.09.23.09.40.39;	author jacekm;	state Exp;
branches;
next	1.143;

1.143
date	2009.09.15.16.50.06;	author jacekm;	state Exp;
branches;
next	1.142;

1.142
date	2009.09.12.12.24.51;	author jacekm;	state Exp;
branches;
next	1.141;

1.141
date	2009.09.12.09.38.45;	author gilles;	state Exp;
branches;
next	1.140;

1.140
date	2009.09.12.09.22.33;	author gilles;	state Exp;
branches;
next	1.139;

1.139
date	2009.09.04.11.49.23;	author jacekm;	state Exp;
branches;
next	1.138;

1.138
date	2009.09.02.12.47.06;	author jacekm;	state Exp;
branches;
next	1.137;

1.137
date	2009.08.27.11.37.30;	author jacekm;	state Exp;
branches;
next	1.136;

1.136
date	2009.08.27.09.21.28;	author jacekm;	state Exp;
branches;
next	1.135;

1.135
date	2009.08.07.19.02.55;	author gilles;	state Exp;
branches;
next	1.134;

1.134
date	2009.08.06.16.46.57;	author gilles;	state Exp;
branches;
next	1.133;

1.133
date	2009.08.06.14.27.41;	author gilles;	state Exp;
branches;
next	1.132;

1.132
date	2009.08.06.14.12.48;	author gilles;	state Exp;
branches;
next	1.131;

1.131
date	2009.08.06.13.40.45;	author gilles;	state Exp;
branches;
next	1.130;

1.130
date	2009.07.28.22.03.55;	author gilles;	state Exp;
branches;
next	1.129;

1.129
date	2009.06.26.11.48.00;	author okan;	state Exp;
branches;
next	1.128;

1.128
date	2009.06.06.18.31.42;	author pyr;	state Exp;
branches;
next	1.127;

1.127
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.126;

1.126
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.125;

1.125
date	2009.06.05.08.50.00;	author pyr;	state Exp;
branches;
next	1.124;

1.124
date	2009.06.03.22.04.15;	author jacekm;	state Exp;
branches;
next	1.123;

1.123
date	2009.06.03.18.16.29;	author gilles;	state Exp;
branches;
next	1.122;

1.122
date	2009.06.02.22.23.36;	author gilles;	state Exp;
branches;
next	1.121;

1.121
date	2009.06.01.18.24.01;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2009.05.30.23.53.41;	author gilles;	state Exp;
branches;
next	1.119;

1.119
date	2009.05.28.08.50.08;	author jacekm;	state Exp;
branches;
next	1.118;

1.118
date	2009.05.27.13.11.39;	author jacekm;	state Exp;
branches;
next	1.117;

1.117
date	2009.05.27.13.09.07;	author jacekm;	state Exp;
branches;
next	1.116;

1.116
date	2009.05.25.14.00.36;	author jacekm;	state Exp;
branches;
next	1.115;

1.115
date	2009.05.24.15.47.31;	author jacekm;	state Exp;
branches;
next	1.114;

1.114
date	2009.05.24.14.38.56;	author jacekm;	state Exp;
branches;
next	1.113;

1.113
date	2009.05.24.14.22.24;	author jacekm;	state Exp;
branches;
next	1.112;

1.112
date	2009.05.20.14.29.44;	author gilles;	state Exp;
branches;
next	1.111;

1.111
date	2009.05.19.11.42.52;	author jacekm;	state Exp;
branches;
next	1.110;

1.110
date	2009.05.19.11.37.44;	author jacekm;	state Exp;
branches;
next	1.109;

1.109
date	2009.05.19.11.24.24;	author jacekm;	state Exp;
branches;
next	1.108;

1.108
date	2009.05.18.20.23.35;	author jacekm;	state Exp;
branches;
next	1.107;

1.107
date	2009.05.09.20.03.07;	author jacekm;	state Exp;
branches;
next	1.106;

1.106
date	2009.05.09.17.04.55;	author jacekm;	state Exp;
branches;
next	1.105;

1.105
date	2009.04.28.23.11.25;	author gilles;	state Exp;
branches;
next	1.104;

1.104
date	2009.04.24.10.02.35;	author jacekm;	state Exp;
branches;
next	1.103;

1.103
date	2009.04.24.08.35.48;	author jacekm;	state Exp;
branches;
next	1.102;

1.102
date	2009.04.24.08.32.12;	author jacekm;	state Exp;
branches;
next	1.101;

1.101
date	2009.04.21.18.12.05;	author jacekm;	state Exp;
branches;
next	1.100;

1.100
date	2009.04.20.17.07.01;	author jacekm;	state Exp;
branches;
next	1.99;

1.99
date	2009.04.16.15.35.06;	author jacekm;	state Exp;
branches;
next	1.98;

1.98
date	2009.04.15.20.34.59;	author jacekm;	state Exp;
branches;
next	1.97;

1.97
date	2009.04.09.19.49.34;	author jacekm;	state Exp;
branches;
next	1.96;

1.96
date	2009.03.22.22.53.47;	author gilles;	state Exp;
branches;
next	1.95;

1.95
date	2009.03.19.20.27.49;	author jacekm;	state Exp;
branches;
next	1.94;

1.94
date	2009.03.15.19.32.11;	author gilles;	state Exp;
branches;
next	1.93;

1.93
date	2009.03.15.19.15.25;	author gilles;	state Exp;
branches;
next	1.92;

1.92
date	2009.03.15.18.12.15;	author gilles;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.12.11.08.26;	author pea;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.10.22.33.26;	author jacekm;	state Exp;
branches;
next	1.89;

1.89
date	2009.03.09.23.35.04;	author jacekm;	state Exp;
branches;
next	1.88;

1.88
date	2009.03.09.16.31.09;	author jacekm;	state Exp;
branches;
next	1.87;

1.87
date	2009.03.09.01.43.19;	author gilles;	state Exp;
branches;
next	1.86;

1.86
date	2009.03.08.20.39.49;	author gilles;	state Exp;
branches;
next	1.85;

1.85
date	2009.03.08.19.11.22;	author gilles;	state Exp;
branches;
next	1.84;

1.84
date	2009.03.08.17.54.20;	author gilles;	state Exp;
branches;
next	1.83;

1.83
date	2009.03.06.23.45.00;	author gilles;	state Exp;
branches;
next	1.82;

1.82
date	2009.03.03.23.33.52;	author gilles;	state Exp;
branches;
next	1.81;

1.81
date	2009.03.03.23.23.52;	author gilles;	state Exp;
branches;
next	1.80;

1.80
date	2009.03.03.15.47.27;	author gilles;	state Exp;
branches;
next	1.79;

1.79
date	2009.03.01.21.58.53;	author jacekm;	state Exp;
branches;
next	1.78;

1.78
date	2009.03.01.12.12.58;	author jacekm;	state Exp;
branches;
next	1.77;

1.77
date	2009.02.24.12.07.47;	author gilles;	state Exp;
branches;
next	1.76;

1.76
date	2009.02.23.22.59.40;	author gilles;	state Exp;
branches;
next	1.75;

1.75
date	2009.02.22.11.59.12;	author jacekm;	state Exp;
branches;
next	1.74;

1.74
date	2009.02.19.11.33.25;	author jacekm;	state Exp;
branches;
next	1.73;

1.73
date	2009.02.18.22.39.12;	author jacekm;	state Exp;
branches;
next	1.72;

1.72
date	2009.02.17.23.43.57;	author jacekm;	state Exp;
branches;
next	1.71;

1.71
date	2009.02.15.13.12.19;	author jacekm;	state Exp;
branches;
next	1.70;

1.70
date	2009.02.15.10.32.23;	author jacekm;	state Exp;
branches;
next	1.69;

1.69
date	2009.02.14.18.37.12;	author jacekm;	state Exp;
branches;
next	1.68;

1.68
date	2009.01.30.21.52.55;	author gilles;	state Exp;
branches;
next	1.67;

1.67
date	2009.01.30.21.40.21;	author gilles;	state Exp;
branches;
next	1.66;

1.66
date	2009.01.30.21.22.33;	author gilles;	state Exp;
branches;
next	1.65;

1.65
date	2009.01.30.20.11.13;	author form;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.30.17.34.58;	author gilles;	state Exp;
branches;
next	1.63;

1.63
date	2009.01.30.16.37.52;	author gilles;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.29.21.59.15;	author jacekm;	state Exp;
branches;
next	1.61;

1.61
date	2009.01.29.15.40.35;	author gilles;	state Exp;
branches;
next	1.60;

1.60
date	2009.01.29.15.20.34;	author gilles;	state Exp;
branches;
next	1.59;

1.59
date	2009.01.29.14.25.55;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2009.01.29.13.00.12;	author gilles;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.29.12.43.25;	author jacekm;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.28.23.13.42;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2009.01.28.22.54.10;	author gilles;	state Exp;
branches;
next	1.54;

1.54
date	2009.01.28.21.44.15;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2009.01.28.19.38.46;	author gilles;	state Exp;
branches;
next	1.52;

1.52
date	2009.01.28.17.29.11;	author jacekm;	state Exp;
branches;
next	1.51;

1.51
date	2009.01.28.13.29.40;	author gilles;	state Exp;
branches;
next	1.50;

1.50
date	2009.01.28.12.58.17;	author gilles;	state Exp;
branches;
next	1.49;

1.49
date	2009.01.28.11.27.57;	author gilles;	state Exp;
branches;
next	1.48;

1.48
date	2009.01.27.22.48.29;	author gilles;	state Exp;
branches;
next	1.47;

1.47
date	2009.01.26.22.20.31;	author gilles;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.14.23.48.35;	author gilles;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.08.19.17.31;	author jacekm;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.04.22.35.09;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2009.01.04.19.37.41;	author gilles;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.04.19.25.19;	author jacekm;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.04.17.45.58;	author gilles;	state Exp;
branches;
next	1.40;

1.40
date	2009.01.04.16.40.58;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.04.14.46.14;	author jacekm;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.04.00.58.59;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2008.12.27.17.36.37;	author jacekm;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.27.17.03.29;	author jacekm;	state Exp;
branches;
next	1.35;

1.35
date	2008.12.26.10.28.31;	author jacekm;	state Exp;
branches;
next	1.34;

1.34
date	2008.12.21.02.18.46;	author gilles;	state Exp;
branches;
next	1.33;

1.33
date	2008.12.20.00.18.03;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.19.00.39.05;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.18.23.57.17;	author jacekm;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.18.23.49.56;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.18.23.38.12;	author jacekm;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.17.18.47.37;	author jacekm;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.13.23.19.34;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.13.13.15.38;	author jacekm;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.12.20.19.56;	author jacekm;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.11.22.18.15;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.07.15.38.35;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.07.03.14.24;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.06.15.18.36;	author weerd;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.05.02.51.32;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.04.17.24.13;	author cloder;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.04.01.16.14;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.03.17.58.00;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.25.23.06.15;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.25.23.03.24;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.25.23.01.00;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.25.20.26.40;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.25.15.55.13;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.17.21.50.43;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.17.21.27.50;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.11.01.08.08;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.10.23.18.47;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.10.22.35.23;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.10.21.29.18;	author chl;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.10.20.10.38;	author chl;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.10.17.24.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.10.00.22.05;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;

1.450.2.1
date	2015.04.19.20.29.43;	author gilles;	state Exp;
branches;
next	;
commitid	hcouPHQe4WQRrGA6;

1.468.4.1
date	2015.04.19.20.30.06;	author gilles;	state Exp;
branches;
next	;
commitid	SFi8NK6NRchJSgfL;

1.473.2.1
date	2015.04.19.20.30.33;	author gilles;	state Exp;
branches;
next	;
commitid	V7mUb6iisKdaCe7F;


desc
@@


1.530
log
@allow negation of authenticated keyword:
	accept ! authenticated [...]

ok sunil@@, jung@@
@
text
@/*	$OpenBSD: smtpd.h,v 1.529 2017/02/03 08:23:46 guenther Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef nitems
#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
#endif

#include <netinet/in.h>
#include <event.h>

#include "smtpd-defines.h"
#include "smtpd-api.h"
#include "ioev.h"

#include "rfc2822.h"

#define CHECK_IMSG_DATA_SIZE(imsg, expected_sz) do {			\
	if ((imsg)->hdr.len - IMSG_HEADER_SIZE != (expected_sz))	\
		fatalx("smtpd: imsg %d: data size expected %zd got %zd",\
	   	    (imsg)->hdr.type,					\
	   	    (expected_sz), (imsg)->hdr.len - IMSG_HEADER_SIZE);	\
} while (0)

#define CONF_FILE		 "/etc/mail/smtpd.conf"
#define MAILNAME_FILE		 "/etc/mail/mailname"
#define CA_FILE			 "/etc/ssl/cert.pem"

#define PROC_COUNT		 7

#define MAX_HOPS_COUNT		 100
#define	DEFAULT_MAX_BODY_SIZE	(35*1024*1024)
#define	MAX_FILTER_NAME		 32
#define	MAX_FILTER_ARGS		 255

#define	EXPAND_BUFFER		 1024

#define SMTPD_QUEUE_EXPIRY	 (4 * 24 * 60 * 60)
#define SMTPD_SOCKET		 "/var/run/smtpd.sock"
#define	SMTPD_NAME		 "OpenSMTPD"
#define	SMTPD_VERSION		 "6.0.0"
#define SMTPD_SESSION_TIMEOUT	 300
#define SMTPD_BACKLOG		 5

#define	PATH_SMTPCTL		"/usr/sbin/smtpctl"

#define PATH_OFFLINE		"/offline"
#define PATH_PURGE		"/purge"
#define PATH_TEMPORARY		"/temporary"

#define	PATH_LIBEXEC		"/usr/local/libexec/smtpd"


/*
 * RFC 5322 defines these characters as valid, some of them are
 * potentially dangerous and need to be escaped.
 */
#define	MAILADDR_ALLOWED       	"!#$%&'*/?^`{|}~+-=_"
#define	MAILADDR_ESCAPE		"!#$%&'*/?^`{|}~"


#define F_STARTTLS		0x01
#define F_SMTPS			0x02
#define	F_TLS_OPTIONAL		0x04
#define F_SSL		       (F_STARTTLS | F_SMTPS)
#define F_AUTH			0x08
#define	F_BACKUP		0x10	/* XXX - MUST BE SYNC-ED WITH RELAY_BACKUP */
#define	F_STARTTLS_REQUIRE	0x20
#define	F_AUTH_REQUIRE		0x40
#define	F_LMTP			0x80
#define	F_MASK_SOURCE		0x100
#define	F_TLS_VERIFY		0x200
#define	F_EXT_DSN		0x400
#define	F_RECEIVEDAUTH		0x800
#define	F_MASQUERADE		0x1000

/* must match F_* for mta */
#define RELAY_STARTTLS		0x01
#define RELAY_SMTPS		0x02
#define	RELAY_TLS_OPTIONAL     	0x04
#define RELAY_SSL		(RELAY_STARTTLS | RELAY_SMTPS)
#define RELAY_AUTH		0x08
#define RELAY_BACKUP		0x10	/* XXX - MUST BE SYNC-ED WITH F_BACKUP */
#define RELAY_MX		0x20
#define RELAY_LMTP		0x80
#define	RELAY_TLS_VERIFY	0x200

#define MTA_EXT_DSN		0x400


struct userinfo {
	char username[SMTPD_VUSERNAME_SIZE];
	char directory[PATH_MAX];
	uid_t uid;
	gid_t gid;
};

struct netaddr {
	struct sockaddr_storage ss;
	int bits;
};

struct relayhost {
	uint16_t flags;
	char hostname[HOST_NAME_MAX+1];
	uint16_t port;
	char pki_name[HOST_NAME_MAX+1];
	char ca_name[HOST_NAME_MAX+1];
	char authtable[SMTPD_TABLENAME_SIZE];
	char authlabel[PATH_MAX];
	char sourcetable[PATH_MAX];
	char heloname[HOST_NAME_MAX+1];
	char helotable[PATH_MAX];
};

struct credentials {
	char username[LINE_MAX];
	char password[LINE_MAX];
};

struct destination {
	char	name[HOST_NAME_MAX+1];
};

struct source {
	struct sockaddr_storage	addr;
};

struct addrname {
	struct sockaddr_storage	addr;
	char			name[HOST_NAME_MAX+1];
};

union lookup {
	struct expand		*expand;
	struct credentials	 creds;
	struct netaddr		 netaddr;
	struct source		 source;
	struct destination	 domain;
	struct userinfo		 userinfo;
	struct mailaddr		 mailaddr;
	struct addrname		 addrname;
	struct maddrmap		*maddrmap;
};

/*
 * Bump IMSG_VERSION whenever a change is made to enum imsg_type.
 * This will ensure that we can never use a wrong version of smtpctl with smtpd.
 */
#define	IMSG_VERSION		16

enum imsg_type {
	IMSG_NONE,

	IMSG_CTL_OK,
	IMSG_CTL_FAIL,

	IMSG_CTL_GET_DIGEST,
	IMSG_CTL_GET_STATS,
	IMSG_CTL_LIST_MESSAGES,
	IMSG_CTL_LIST_ENVELOPES,
	IMSG_CTL_MTA_SHOW_HOSTS,
	IMSG_CTL_MTA_SHOW_RELAYS,
	IMSG_CTL_MTA_SHOW_ROUTES,
	IMSG_CTL_MTA_SHOW_HOSTSTATS,
	IMSG_CTL_MTA_BLOCK,
	IMSG_CTL_MTA_UNBLOCK,
	IMSG_CTL_MTA_SHOW_BLOCK,
	IMSG_CTL_PAUSE_EVP,
	IMSG_CTL_PAUSE_MDA,
	IMSG_CTL_PAUSE_MTA,
	IMSG_CTL_PAUSE_SMTP,
	IMSG_CTL_PROFILE,
	IMSG_CTL_PROFILE_DISABLE,
	IMSG_CTL_PROFILE_ENABLE,
	IMSG_CTL_RESUME_EVP,
	IMSG_CTL_RESUME_MDA,
	IMSG_CTL_RESUME_MTA,
	IMSG_CTL_RESUME_SMTP,
	IMSG_CTL_RESUME_ROUTE,
	IMSG_CTL_REMOVE,
	IMSG_CTL_SCHEDULE,
	IMSG_CTL_SHOW_STATUS,
	IMSG_CTL_TRACE_DISABLE,
	IMSG_CTL_TRACE_ENABLE,
	IMSG_CTL_UPDATE_TABLE,
	IMSG_CTL_VERBOSE,
	IMSG_CTL_DISCOVER_EVPID,
	IMSG_CTL_DISCOVER_MSGID,
	IMSG_CTL_UNCORRUPT_MSGID,

	IMSG_CTL_SMTP_SESSION,

	IMSG_SETUP_KEY,
	IMSG_SETUP_PEER,
	IMSG_SETUP_DONE,

	IMSG_CONF_START,
	IMSG_CONF_END,

	IMSG_STAT_INCREMENT,
	IMSG_STAT_DECREMENT,
	IMSG_STAT_SET,

	IMSG_LKA_AUTHENTICATE,
	IMSG_LKA_OPEN_FORWARD,
	IMSG_LKA_ENVELOPE_SUBMIT,
	IMSG_LKA_ENVELOPE_COMMIT,

	IMSG_QUEUE_DELIVER,
	IMSG_QUEUE_DELIVERY_OK,
	IMSG_QUEUE_DELIVERY_TEMPFAIL,
	IMSG_QUEUE_DELIVERY_PERMFAIL,
	IMSG_QUEUE_DELIVERY_LOOP,
	IMSG_QUEUE_DISCOVER_EVPID,
	IMSG_QUEUE_DISCOVER_MSGID,
	IMSG_QUEUE_ENVELOPE_ACK,
	IMSG_QUEUE_ENVELOPE_COMMIT,
	IMSG_QUEUE_ENVELOPE_REMOVE,
	IMSG_QUEUE_ENVELOPE_SCHEDULE,
	IMSG_QUEUE_ENVELOPE_SUBMIT,
	IMSG_QUEUE_HOLDQ_HOLD,
	IMSG_QUEUE_HOLDQ_RELEASE,
	IMSG_QUEUE_MESSAGE_COMMIT,
	IMSG_QUEUE_MESSAGE_ROLLBACK,
	IMSG_QUEUE_SMTP_SESSION,
	IMSG_QUEUE_TRANSFER,

	IMSG_MDA_DELIVERY_OK,
	IMSG_MDA_DELIVERY_TEMPFAIL,
	IMSG_MDA_DELIVERY_PERMFAIL,
	IMSG_MDA_DELIVERY_LOOP,
	IMSG_MDA_DELIVERY_HOLD,
	IMSG_MDA_DONE,
	IMSG_MDA_FORK,
	IMSG_MDA_HOLDQ_RELEASE,
	IMSG_MDA_LOOKUP_USERINFO,
	IMSG_MDA_KILL,
	IMSG_MDA_OPEN_MESSAGE,

	IMSG_MFA_SMTP_RESPONSE,

	IMSG_MTA_DELIVERY_OK,
	IMSG_MTA_DELIVERY_TEMPFAIL,
	IMSG_MTA_DELIVERY_PERMFAIL,
	IMSG_MTA_DELIVERY_LOOP,
	IMSG_MTA_DELIVERY_HOLD,
	IMSG_MTA_DNS_HOST,
	IMSG_MTA_DNS_HOST_END,
	IMSG_MTA_DNS_PTR,
	IMSG_MTA_DNS_MX,
	IMSG_MTA_DNS_MX_PREFERENCE,
	IMSG_MTA_HOLDQ_RELEASE,
	IMSG_MTA_LOOKUP_CREDENTIALS,
	IMSG_MTA_LOOKUP_SOURCE,
	IMSG_MTA_LOOKUP_HELO,
	IMSG_MTA_OPEN_MESSAGE,
	IMSG_MTA_SCHEDULE,
	IMSG_MTA_TLS_INIT,
	IMSG_MTA_TLS_VERIFY_CERT,
	IMSG_MTA_TLS_VERIFY_CHAIN,
	IMSG_MTA_TLS_VERIFY,

	IMSG_SCHED_ENVELOPE_BOUNCE,
	IMSG_SCHED_ENVELOPE_DELIVER,
	IMSG_SCHED_ENVELOPE_EXPIRE,
	IMSG_SCHED_ENVELOPE_INJECT,
	IMSG_SCHED_ENVELOPE_REMOVE,
	IMSG_SCHED_ENVELOPE_TRANSFER,

	IMSG_SMTP_AUTHENTICATE,
	IMSG_SMTP_DNS_PTR,
	IMSG_SMTP_MESSAGE_COMMIT,
	IMSG_SMTP_MESSAGE_CREATE,
	IMSG_SMTP_MESSAGE_ROLLBACK,
	IMSG_SMTP_MESSAGE_OPEN,
	IMSG_SMTP_CHECK_SENDER,
	IMSG_SMTP_EXPAND_RCPT,
	IMSG_SMTP_LOOKUP_HELO,
	IMSG_SMTP_TLS_INIT,
	IMSG_SMTP_TLS_VERIFY_CERT,
	IMSG_SMTP_TLS_VERIFY_CHAIN,
	IMSG_SMTP_TLS_VERIFY,

	IMSG_SMTP_REQ_CONNECT,
	IMSG_SMTP_REQ_HELO,
	IMSG_SMTP_REQ_MAIL,
	IMSG_SMTP_REQ_RCPT,
	IMSG_SMTP_REQ_DATA,
	IMSG_SMTP_REQ_EOM,
	IMSG_SMTP_EVENT_RSET,
	IMSG_SMTP_EVENT_COMMIT,
	IMSG_SMTP_EVENT_ROLLBACK,
	IMSG_SMTP_EVENT_DISCONNECT,

	IMSG_CA_PRIVENC,
	IMSG_CA_PRIVDEC
};

enum smtp_proc_type {
	PROC_PARENT = 0,
	PROC_LKA,
	PROC_QUEUE,
	PROC_CONTROL,
	PROC_SCHEDULER,
	PROC_PONY,
	PROC_CA,

	PROC_FILTER,
	PROC_CLIENT,
};

enum table_type {
	T_NONE		= 0,
	T_DYNAMIC	= 0x01,	/* table with external source	*/
	T_LIST		= 0x02,	/* table holding a list		*/
	T_HASH		= 0x04,	/* table holding a hash table	*/
};

struct table {
	char				 t_name[LINE_MAX];
	enum table_type			 t_type;
	char				 t_config[PATH_MAX];

	struct dict			 t_dict;

	void				*t_handle;
	struct table_backend		*t_backend;
	void				*t_iter;
};

struct table_backend {
	const unsigned int	services;
	int	(*config)(struct table *);
	void   *(*open)(struct table *);
	int	(*update)(struct table *);
	void	(*close)(void *);
	int	(*lookup)(void *, struct dict *, const char *, enum table_service, union lookup *);
	int	(*fetch)(void *, struct dict *, enum table_service, union lookup *);
};


enum dest_type {
	DEST_DOM,
	DEST_VDOM
};

enum action_type {
	A_NONE,
	A_RELAY,
	A_RELAYVIA,
	A_MAILDIR,
	A_MBOX,
	A_FILENAME,
	A_MDA,
	A_LMTP
};

enum decision {
	R_REJECT,
	R_ACCEPT
};

struct rule {
	uint64_t			r_id;
	TAILQ_ENTRY(rule)		r_entry;
	enum decision			r_decision;
	uint8_t				r_nottag;
	char				r_tag[SMTPD_TAG_SIZE];

	uint8_t				r_notsources;
	struct table		       *r_sources;

	uint8_t				r_notsenders;
	struct table		       *r_senders;

	uint8_t				r_notrecipients;
	struct table		       *r_recipients;

	uint8_t				r_notdestination;
	enum dest_type			r_desttype;
	struct table		       *r_destination;

	uint8_t				r_wantauth;
	uint8_t				r_negwantauth;

	enum action_type		r_action;
	union rule_dest {
		char			buffer[EXPAND_BUFFER];
		struct relayhost	relayhost;
	}				r_value;

	struct mailaddr		       *r_as;
	struct table		       *r_mapping;
	struct table		       *r_userbase;
	time_t				r_qexpire;
	uint8_t				r_forwardonly;
	char				r_delivery_user[LINE_MAX];
};

struct delivery_mda {
	enum action_type	method;
	char			usertable[SMTPD_TABLENAME_SIZE];
	char			username[SMTPD_VUSERNAME_SIZE];
	char			buffer[EXPAND_BUFFER];
	char			delivery_user[SMTPD_VUSERNAME_SIZE];
};

struct delivery_mta {
	struct relayhost	relay;
};

enum bounce_type {
	B_ERROR,
	B_WARNING,
	B_DSN
};

enum dsn_ret {
	DSN_RETFULL = 1,
	DSN_RETHDRS
};

struct delivery_bounce {
	enum bounce_type	type;
	time_t			delay;
	time_t			expire;
	enum dsn_ret		dsn_ret;
        int			mta_without_dsn;
};

enum expand_type {
	EXPAND_INVALID,
	EXPAND_USERNAME,
	EXPAND_FILENAME,
	EXPAND_FILTER,
	EXPAND_INCLUDE,
	EXPAND_ADDRESS,
	EXPAND_ERROR,
	EXPAND_MAILDIR
};

struct expandnode {
	RB_ENTRY(expandnode)	entry;
	TAILQ_ENTRY(expandnode)	tq_entry;
	enum expand_type	type;
	int			sameuser;
	int			alias;
	struct rule	       *rule;
	struct expandnode      *parent;
	unsigned int		depth;
	struct table   	       *mapping;
	struct table   	       *userbase;
	union {
		/*
		 * user field handles both expansion user and system user
		 * so we MUST make it large enough to fit a mailaddr user
		 */
		char		user[SMTPD_MAXLOCALPARTSIZE];
		char		buffer[EXPAND_BUFFER];
		struct mailaddr	mailaddr;
	}			u;
};

struct expand {
	RB_HEAD(expandtree, expandnode)	 tree;
	TAILQ_HEAD(xnodes, expandnode)	*queue;
	int				 alias;
	size_t				 nb_nodes;
	struct rule			*rule;
	struct expandnode		*parent;
};

struct maddrnode {
	TAILQ_ENTRY(maddrnode)		entries;
	struct mailaddr			mailaddr;
};

struct maddrmap {
	TAILQ_HEAD(xmaddr, maddrnode)	queue;
};

#define DSN_SUCCESS 0x01
#define DSN_FAILURE 0x02
#define DSN_DELAY   0x04
#define DSN_NEVER   0x08

#define	DSN_ENVID_LEN	100

#define	SMTPD_ENVELOPE_VERSION		2
struct envelope {
	TAILQ_ENTRY(envelope)		entry;

	char				tag[SMTPD_TAG_SIZE];

	uint32_t			version;
	uint64_t			id;
	enum envelope_flags		flags;

	char				smtpname[HOST_NAME_MAX+1];
	char				helo[HOST_NAME_MAX+1];
	char				hostname[HOST_NAME_MAX+1];
	char				errorline[LINE_MAX];
	struct sockaddr_storage		ss;

	struct mailaddr			sender;
	struct mailaddr			rcpt;
	struct mailaddr			dest;

	enum delivery_type		type;
	union {
		struct delivery_mda	mda;
		struct delivery_mta	mta;
		struct delivery_bounce	bounce;
	}				agent;

	uint16_t			retry;
	time_t				creation;
	time_t				expire;
	time_t				lasttry;
	time_t				nexttry;
	time_t				lastbounce;

	struct mailaddr			dsn_orcpt;
	char				dsn_envid[DSN_ENVID_LEN+1];
	uint8_t				dsn_notify;
	enum dsn_ret			dsn_ret;

	uint8_t				esc_class;
	uint8_t				esc_code;
};

struct listener {
	uint16_t       		 flags;
	int			 fd;
	struct sockaddr_storage	 ss;
	in_port_t		 port;
	struct timeval		 timeout;
	struct event		 ev;
	char			 pki_name[PATH_MAX];
	char			 ca_name[PATH_MAX];
	char			 tag[SMTPD_TAG_SIZE];
	char			 filter[PATH_MAX];
	char			 authtable[LINE_MAX];
	char			 hostname[HOST_NAME_MAX+1];
	char			 hostnametable[PATH_MAX];
	char			 sendertable[PATH_MAX];

	TAILQ_ENTRY(listener)	 entry;

	int			 local;		/* there must be a better way */
};

struct smtpd {
	char				sc_conffile[PATH_MAX];
	size_t				sc_maxsize;

#define SMTPD_OPT_VERBOSE		0x00000001
#define SMTPD_OPT_NOACTION		0x00000002
	uint32_t			sc_opts;

#define SMTPD_EXITING			0x00000001 /* unused */
#define SMTPD_MDA_PAUSED		0x00000002
#define SMTPD_MTA_PAUSED		0x00000004
#define SMTPD_SMTP_PAUSED		0x00000008
#define SMTPD_MDA_BUSY			0x00000010
#define SMTPD_MTA_BUSY			0x00000020
#define SMTPD_BOUNCE_BUSY		0x00000040
#define SMTPD_SMTP_DISABLED		0x00000080
	uint32_t			sc_flags;

#define QUEUE_COMPRESSION      		0x00000001
#define QUEUE_ENCRYPTION      		0x00000002
#define QUEUE_EVPCACHE			0x00000004
	uint32_t			sc_queue_flags;
	char			       *sc_queue_key;
	size_t				sc_queue_evpcache_size;

	size_t				sc_session_max_rcpt;
	size_t				sc_session_max_mails;

	size_t				sc_mda_max_session;
	size_t				sc_mda_max_user_session;
	size_t				sc_mda_task_hiwat;
	size_t				sc_mda_task_lowat;
	size_t				sc_mda_task_release;

	size_t				sc_mta_max_deferred;

	size_t				sc_scheduler_max_inflight;
	size_t				sc_scheduler_max_evp_batch_size;
	size_t				sc_scheduler_max_msg_batch_size;
	size_t				sc_scheduler_max_schedule;

	int				sc_qexpire;
#define MAX_BOUNCE_WARN			4
	time_t				sc_bounce_warn[MAX_BOUNCE_WARN];
	char				sc_hostname[HOST_NAME_MAX+1];
	struct stat_backend	       *sc_stat;
	struct compress_backend	       *sc_comp;

	time_t					 sc_uptime;

	/* This is a listener for a local socket used by smtp_enqueue(). */
	struct listener                         *sc_sock_listener;

	TAILQ_HEAD(listenerlist, listener)	*sc_listeners;

	TAILQ_HEAD(rulelist, rule)		*sc_rules;

	struct dict			       *sc_ca_dict;
	struct dict			       *sc_pki_dict;
	struct dict			       *sc_ssl_dict;

	struct dict			       *sc_tables_dict;		/* keyed lookup	*/

	struct dict			       *sc_limits_dict;

	struct dict				sc_filters;
	uint32_t				filtermask;

	char					sc_enqueue_filter[PATH_MAX];

	char				       *sc_tls_ciphers;

	char				       *sc_subaddressing_delim;
};

#define	TRACE_DEBUG	0x0001
#define	TRACE_IMSG	0x0002
#define	TRACE_IO	0x0004
#define	TRACE_SMTP	0x0008
#define	TRACE_FILTERS	0x0010
#define	TRACE_MTA	0x0020
#define	TRACE_BOUNCE	0x0040
#define	TRACE_SCHEDULER	0x0080
#define	TRACE_LOOKUP	0x0100
#define	TRACE_STAT	0x0200
#define	TRACE_RULES	0x0400
#define	TRACE_MPROC	0x0800
#define	TRACE_EXPAND	0x1000
#define	TRACE_TABLES	0x2000
#define	TRACE_QUEUE	0x4000

#define PROFILE_TOSTAT	0x0001
#define PROFILE_IMSG	0x0002
#define PROFILE_QUEUE	0x0004

struct forward_req {
	uint64_t			id;
	uint8_t				status;

	char				user[SMTPD_VUSERNAME_SIZE];
	uid_t				uid;
	gid_t				gid;
	char				directory[PATH_MAX];
};

struct deliver {
	char			to[EXPAND_BUFFER];
	char			from[SMTPD_MAXMAILADDRSIZE];
	char			dest[SMTPD_MAXMAILADDRSIZE];
	char			user[SMTPD_VUSERNAME_SIZE];
	short			mode;

	struct userinfo		userinfo;
};

#define MAX_FILTER_PER_CHAIN	16
struct filter_conf {
	int		 chain;
	int		 done;
	int		 argc;
	char		*name;
	char		*argv[MAX_FILTER_ARGS + 1];
	char		*path;
};

struct mta_host {
	SPLAY_ENTRY(mta_host)	 entry;
	struct sockaddr		*sa;
	char			*ptrname;
	int			 refcount;
	size_t			 nconn;
	time_t			 lastconn;
	time_t			 lastptrquery;

#define HOST_IGNORE	0x01
	int			 flags;
};

struct mta_mx {
	TAILQ_ENTRY(mta_mx)	 entry;
	struct mta_host		*host;
	int			 preference;
};

struct mta_domain {
	SPLAY_ENTRY(mta_domain)	 entry;
	char			*name;
	int			 flags;
	TAILQ_HEAD(, mta_mx)	 mxs;
	int			 mxstatus;
	int			 refcount;
	size_t			 nconn;
	time_t			 lastconn;
	time_t			 lastmxquery;
};

struct mta_source {
	SPLAY_ENTRY(mta_source)	 entry;
	struct sockaddr		*sa;
	int			 refcount;
	size_t			 nconn;
	time_t			 lastconn;
};

struct mta_connector {
	struct mta_source		*source;
	struct mta_relay		*relay;

#define CONNECTOR_ERROR_FAMILY		0x0001
#define CONNECTOR_ERROR_SOURCE		0x0002
#define CONNECTOR_ERROR_MX		0x0004
#define CONNECTOR_ERROR_ROUTE_NET	0x0008
#define CONNECTOR_ERROR_ROUTE_SMTP	0x0010
#define CONNECTOR_ERROR_ROUTE		0x0018
#define CONNECTOR_ERROR_BLOCKED		0x0020
#define CONNECTOR_ERROR			0x00ff

#define CONNECTOR_LIMIT_HOST		0x0100
#define CONNECTOR_LIMIT_ROUTE		0x0200
#define CONNECTOR_LIMIT_SOURCE		0x0400
#define CONNECTOR_LIMIT_RELAY		0x0800
#define CONNECTOR_LIMIT_CONN		0x1000
#define CONNECTOR_LIMIT_DOMAIN		0x2000
#define CONNECTOR_LIMIT			0xff00

#define CONNECTOR_NEW			0x10000
#define CONNECTOR_WAIT			0x20000
	int				 flags;

	int				 refcount;
	size_t				 nconn;
	time_t				 lastconn;
};

struct mta_route {
	SPLAY_ENTRY(mta_route)	 entry;
	uint64_t		 id;
	struct mta_source	*src;
	struct mta_host		*dst;
#define ROUTE_NEW		0x01
#define ROUTE_RUNQ		0x02
#define ROUTE_KEEPALIVE		0x04
#define ROUTE_DISABLED		0xf0
#define ROUTE_DISABLED_NET	0x10
#define ROUTE_DISABLED_SMTP	0x20
	int			 flags;
	int			 nerror;
	int			 penalty;
	int			 refcount;
	size_t			 nconn;
	time_t			 lastconn;
	time_t			 lastdisc;
	time_t			 lastpenalty;
};

struct mta_limits {
	size_t	maxconn_per_host;
	size_t	maxconn_per_route;
	size_t	maxconn_per_source;
	size_t	maxconn_per_connector;
	size_t	maxconn_per_relay;
	size_t	maxconn_per_domain;

	time_t	conndelay_host;
	time_t	conndelay_route;
	time_t	conndelay_source;
	time_t	conndelay_connector;
	time_t	conndelay_relay;
	time_t	conndelay_domain;

	time_t	discdelay_route;

	size_t	max_mail_per_session;
	time_t	sessdelay_transaction;
	time_t	sessdelay_keepalive;

	size_t	max_failures_per_session;

	int	family;

	int	task_hiwat;
	int	task_lowat;
	int	task_release;
};

struct mta_relay {
	SPLAY_ENTRY(mta_relay)	 entry;
	uint64_t		 id;

	struct mta_domain	*domain;
	struct mta_limits	*limits;
	int			 flags;
	char			*backupname;
	int			 backuppref;
	char			*sourcetable;
	uint16_t		 port;
	char			*pki_name;
	char			*ca_name;
	char			*authtable;
	char			*authlabel;
	char			*helotable;
	char			*heloname;
	char			*secret;

	int			 state;
	size_t			 ntask;
	TAILQ_HEAD(, mta_task)	 tasks;

	struct tree		 connectors;
	size_t			 sourceloop;
	time_t			 lastsource;
	time_t			 nextsource;

	int			 fail;
	char			*failstr;

#define RELAY_WAIT_MX		0x01
#define RELAY_WAIT_PREFERENCE	0x02
#define RELAY_WAIT_SECRET	0x04
#define RELAY_WAIT_LIMITS	0x08
#define RELAY_WAIT_SOURCE	0x10
#define RELAY_WAIT_CONNECTOR	0x20
#define RELAY_WAITMASK		0x3f
	int			 status;

	int			 refcount;
	size_t			 nconn;
	size_t			 nconn_ready;
	time_t			 lastconn;
};

struct mta_envelope {
	TAILQ_ENTRY(mta_envelope)	 entry;
	uint64_t			 id;
	uint64_t			 session;
	time_t				 creation;
	char				*dest;
	char				*rcpt;
	struct mta_task			*task;
	int				 delivery;

	int				 ext;
	char				*dsn_orcpt;
	char				dsn_envid[DSN_ENVID_LEN+1];
	uint8_t				dsn_notify;
	enum dsn_ret			dsn_ret;

	char				 status[LINE_MAX];
};

struct mta_task {
	TAILQ_ENTRY(mta_task)		 entry;
	struct mta_relay		*relay;
	uint32_t			 msgid;
	TAILQ_HEAD(, mta_envelope)	 envelopes;
	char				*sender;
};

struct passwd;

struct queue_backend {
	int	(*init)(struct passwd *, int, const char *);
};

struct compress_backend {
	size_t	(*compress_chunk)(void *, size_t, void *, size_t);
	size_t	(*uncompress_chunk)(void *, size_t, void *, size_t);
	int	(*compress_file)(FILE *, FILE *);
	int	(*uncompress_file)(FILE *, FILE *);
};

/* auth structures */
enum auth_type {
	AUTH_BSD,
	AUTH_PWD,
};

struct auth_backend {
	int	(*authenticate)(char *, char *);
};


/* delivery_backend */
struct delivery_backend {
	int	allow_root;
	void	(*open)(struct deliver *);
};

struct scheduler_backend {
	int	(*init)(const char *);

	int	(*insert)(struct scheduler_info *);
	size_t	(*commit)(uint32_t);
	size_t	(*rollback)(uint32_t);

	int	(*update)(struct scheduler_info *);
	int	(*delete)(uint64_t);
	int	(*hold)(uint64_t, uint64_t);
	int	(*release)(int, uint64_t, int);

	int	(*batch)(int, int*, size_t*, uint64_t*, int*);

	size_t	(*messages)(uint32_t, uint32_t *, size_t);
	size_t	(*envelopes)(uint64_t, struct evpstate *, size_t);
	int	(*schedule)(uint64_t);
	int	(*remove)(uint64_t);
	int	(*suspend)(uint64_t);
	int	(*resume)(uint64_t);
	int	(*query)(uint64_t);
};

enum stat_type {
	STAT_COUNTER,
	STAT_TIMESTAMP,
	STAT_TIMEVAL,
	STAT_TIMESPEC,
};

struct stat_value {
	enum stat_type	type;
	union stat_v {
		size_t		counter;
		time_t		timestamp;
		struct timeval	tv;
		struct timespec	ts;
	} u;
};

#define	STAT_KEY_SIZE	1024
struct stat_kv {
	void	*iter;
	char	key[STAT_KEY_SIZE];
	struct stat_value	val;
};

struct stat_backend {
	void	(*init)(void);
	void	(*close)(void);
	void	(*increment)(const char *, size_t);
	void	(*decrement)(const char *, size_t);
	void	(*set)(const char *, const struct stat_value *);
	int	(*iter)(void **, char **, struct stat_value *);
};

struct stat_digest {
	time_t			 startup;
	time_t			 timestamp;

	size_t			 clt_connect;
	size_t			 clt_disconnect;

	size_t			 evp_enqueued;
	size_t			 evp_dequeued;

	size_t			 evp_expired;
	size_t			 evp_removed;
	size_t			 evp_bounce;

	size_t			 dlv_ok;
	size_t			 dlv_permfail;
	size_t			 dlv_tempfail;
	size_t			 dlv_loop;
};


struct mproc {
	pid_t		 pid;
	char		*name;
	int		 proc;
	void		(*handler)(struct mproc *, struct imsg *);
	struct imsgbuf	 imsgbuf;

	char		*m_buf;
	size_t		 m_alloc;
	size_t		 m_pos;
	uint32_t	 m_type;
	uint32_t	 m_peerid;
	pid_t		 m_pid;
	int		 m_fd;

	int		 enable;
	short		 events;
	struct event	 ev;
	void		*data;
};

struct msg {
	const uint8_t	*pos;
	const uint8_t	*end;
};

extern enum smtp_proc_type	smtpd_process;

extern int tracing;
extern int foreground_log;
extern int profiling;

extern struct mproc *p_control;
extern struct mproc *p_parent;
extern struct mproc *p_lka;
extern struct mproc *p_queue;
extern struct mproc *p_scheduler;
extern struct mproc *p_pony;
extern struct mproc *p_ca;

extern struct smtpd	*env;
extern void (*imsg_callback)(struct mproc *, struct imsg *);

struct imsgproc {
	pid_t			pid;
	struct event		ev;
	struct imsgbuf	       *ibuf;
	char		       *path;
	char		       *name;
	void		      (*cb)(struct imsg *, void *);
	void		       *cb_arg;
};

/* inter-process structures */

struct bounce_req_msg {
	uint64_t		evpid;
	time_t			timestamp;
	struct delivery_bounce	bounce;
};

enum dns_error {
	DNS_OK = 0,
	DNS_RETRY,
	DNS_EINVAL,
	DNS_ENONAME,
	DNS_ENOTFOUND,
};

enum lka_resp_status {
	LKA_OK,
	LKA_TEMPFAIL,
	LKA_PERMFAIL
};

enum ca_resp_status {
	CA_OK,
	CA_FAIL
};

struct ca_cert_req_msg {
	uint64_t		reqid;
	char			name[HOST_NAME_MAX+1];
	int			fallback;
};

struct ca_cert_resp_msg {
	uint64_t		reqid;
	enum ca_resp_status	status;
	char			name[HOST_NAME_MAX+1];
	char		       *cert;
	off_t			cert_len;
};

struct ca_vrfy_req_msg {
	uint64_t		reqid;
	char			name[HOST_NAME_MAX+1];
	int			fallback;
	unsigned char  	       *cert;
	off_t			cert_len;
	size_t			n_chain;
	size_t			chain_offset;
	unsigned char	      **chain_cert;
	off_t		       *chain_cert_len;
};

struct ca_vrfy_resp_msg {
	uint64_t		reqid;
	enum ca_resp_status	status;
};

struct msg_walkinfo {
	struct event	 ev;
	uint32_t	 msgid;
	uint32_t	 peerid;
	size_t		 n_evp;
	void		*data;
	int		 done;
};

/* aliases.c */
int aliases_get(struct expand *, const char *);
int aliases_virtual_get(struct expand *, const struct mailaddr *);
int alias_parse(struct expandnode *, const char *);


/* auth.c */
struct auth_backend *auth_backend_lookup(enum auth_type);


/* bounce.c */
void bounce_add(uint64_t);
void bounce_fd(int);


/* ca.c */
int	 ca(void);
int	 ca_X509_verify(void *, void *, const char *, const char *, const char **);
void	 ca_imsg(struct mproc *, struct imsg *);
void	 ca_init(void);
void	 ca_engine_init(void);

/* compress_backend.c */
struct compress_backend *compress_backend_lookup(const char *);
size_t	compress_chunk(void *, size_t, void *, size_t);
size_t	uncompress_chunk(void *, size_t, void *, size_t);
int	compress_file(FILE *, FILE *);
int	uncompress_file(FILE *, FILE *);

/* config.c */
#define PURGE_LISTENERS		0x01
#define PURGE_TABLES		0x02
#define PURGE_RULES		0x04
#define PURGE_PKI		0x08
#define PURGE_PKI_KEYS		0x10
#define PURGE_EVERYTHING	0x0f
void purge_config(uint8_t);
void config_process(enum smtp_proc_type);
void config_peer(enum smtp_proc_type);


/* control.c */
int control(void);
int control_create_socket(void);


/* crypto.c */
int	crypto_setup(const char *, size_t);
int	crypto_encrypt_file(FILE *, FILE *);
int	crypto_decrypt_file(FILE *, FILE *);
size_t	crypto_encrypt_buffer(const char *, size_t, char *, size_t);
size_t	crypto_decrypt_buffer(const char *, size_t, char *, size_t);


/* delivery.c */
struct delivery_backend *delivery_backend_lookup(enum action_type);


/* dns.c */
void dns_imsg(struct mproc *, struct imsg *);


/* enqueue.c */
int		 enqueue(int, char **, FILE *);


/* envelope.c */
void envelope_set_errormsg(struct envelope *, char *, ...);
void envelope_set_esc_class(struct envelope *, enum enhanced_status_class);
void envelope_set_esc_code(struct envelope *, enum enhanced_status_code);
int envelope_load_buffer(struct envelope *, const char *, size_t);
int envelope_dump_buffer(const struct envelope *, char *, size_t);


/* expand.c */
int expand_cmp(struct expandnode *, struct expandnode *);
void expand_insert(struct expand *, struct expandnode *);
struct expandnode *expand_lookup(struct expand *, struct expandnode *);
void expand_clear(struct expand *);
void expand_free(struct expand *);
int expand_line(struct expand *, const char *, int);
int expand_to_text(struct expand *, char *, size_t);
RB_PROTOTYPE(expandtree, expandnode, nodes, expand_cmp);


/* filter.c */
void filter_postfork(void);
void filter_configure(void);
void filter_connect(uint64_t, const struct sockaddr *,
    const struct sockaddr *, const char *, const char *);
void filter_mailaddr(uint64_t, int, const struct mailaddr *);
void filter_line(uint64_t, int, const char *);
void filter_eom(uint64_t, int, size_t);
void filter_event(uint64_t, int);
void filter_build_fd_chain(uint64_t, int);


/* forward.c */
int forwards_get(int, struct expand *);


/* imsgproc.c */
void imsgproc_init(void);
struct imsgproc *imsgproc_fork(const char *, const char *,
    void (*)(struct imsg *, void *), void *);
void imsgproc_set_read(struct imsgproc *);
void imsgproc_set_write(struct imsgproc *);
void imsgproc_set_read_write(struct imsgproc *);
void imsgproc_reset_callback(struct imsgproc *, void (*)(struct imsg *, void *), void *);


/* limit.c */
void limit_mta_set_defaults(struct mta_limits *);
int limit_mta_set(struct mta_limits *, const char*, int64_t);


/* lka.c */
int lka(void);


/* lka_session.c */
void lka_session(uint64_t, struct envelope *);
void lka_session_forward_reply(struct forward_req *, int);


/* log.c */
void vlog(int, const char *, va_list);
void logit(int, const char *, ...) __attribute__((format (printf, 2, 3)));


/* mda.c */
void mda_postfork(void);
void mda_postprivdrop(void);
void mda_imsg(struct mproc *, struct imsg *);


/* makemap.c */
int makemap(int, char **);


/* mailaddr.c */
int mailaddr_line(struct maddrmap *, const char *);
void maddrmap_init(struct maddrmap *);
void maddrmap_insert(struct maddrmap *, struct maddrnode *);
void maddrmap_free(struct maddrmap *);


/* mproc.c */
int mproc_fork(struct mproc *, const char*, char **);
void mproc_init(struct mproc *, int);
void mproc_clear(struct mproc *);
void mproc_enable(struct mproc *);
void mproc_disable(struct mproc *);
void mproc_event_add(struct mproc *);
void m_compose(struct mproc *, uint32_t, uint32_t, pid_t, int, void *, size_t);
void m_composev(struct mproc *, uint32_t, uint32_t, pid_t, int,
    const struct iovec *, int);
void m_forward(struct mproc *, struct imsg *);
void m_create(struct mproc *, uint32_t, uint32_t, pid_t, int);
void m_add(struct mproc *, const void *, size_t);
void m_add_int(struct mproc *, int);
void m_add_u32(struct mproc *, uint32_t);
void m_add_size(struct mproc *, size_t);
void m_add_time(struct mproc *, time_t);
void m_add_string(struct mproc *, const char *);
void m_add_data(struct mproc *, const void *, size_t);
void m_add_evpid(struct mproc *, uint64_t);
void m_add_msgid(struct mproc *, uint32_t);
void m_add_id(struct mproc *, uint64_t);
void m_add_sockaddr(struct mproc *, const struct sockaddr *);
void m_add_mailaddr(struct mproc *, const struct mailaddr *);
void m_add_envelope(struct mproc *, const struct envelope *);
void m_add_params(struct mproc *, struct dict *);
void m_close(struct mproc *);
void m_flush(struct mproc *);

void m_msg(struct msg *, struct imsg *);
int  m_is_eom(struct msg *);
void m_end(struct msg *);
void m_get_int(struct msg *, int *);
void m_get_size(struct msg *, size_t *);
void m_get_u32(struct msg *, uint32_t *);
void m_get_time(struct msg *, time_t *);
void m_get_string(struct msg *, const char **);
void m_get_data(struct msg *, const void **, size_t *);
void m_get_evpid(struct msg *, uint64_t *);
void m_get_msgid(struct msg *, uint32_t *);
void m_get_id(struct msg *, uint64_t *);
void m_get_sockaddr(struct msg *, struct sockaddr *);
void m_get_mailaddr(struct msg *, struct mailaddr *);
void m_get_envelope(struct msg *, struct envelope *);
void m_get_params(struct msg *, struct dict *);
void m_clear_params(struct dict *);


/* mta.c */
void mta_postfork(void);
void mta_postprivdrop(void);
void mta_imsg(struct mproc *, struct imsg *);
void mta_route_ok(struct mta_relay *, struct mta_route *);
void mta_route_error(struct mta_relay *, struct mta_route *);
void mta_route_down(struct mta_relay *, struct mta_route *);
void mta_route_collect(struct mta_relay *, struct mta_route *);
void mta_source_error(struct mta_relay *, struct mta_route *, const char *);
void mta_delivery_log(struct mta_envelope *, const char *, const char *, int, const char *);
void mta_delivery_notify(struct mta_envelope *);
struct mta_task *mta_route_next_task(struct mta_relay *, struct mta_route *);
const char *mta_host_to_text(struct mta_host *);
const char *mta_relay_to_text(struct mta_relay *);


/* mta_session.c */
void mta_session(struct mta_relay *, struct mta_route *);
void mta_session_imsg(struct mproc *, struct imsg *);


/* parse.y */
int parse_config(struct smtpd *, const char *, int);
int cmdline_symset(char *);


/* queue.c */
int queue(void);


/* queue_backend.c */
uint32_t queue_generate_msgid(void);
uint64_t queue_generate_evpid(uint32_t);
int queue_init(const char *, int);
int queue_close(void);
int queue_message_create(uint32_t *);
int queue_message_delete(uint32_t);
int queue_message_commit(uint32_t);
int queue_message_fd_r(uint32_t);
int queue_message_fd_rw(uint32_t);
int queue_message_corrupt(uint32_t);
int queue_message_uncorrupt(uint32_t);
int queue_envelope_create(struct envelope *);
int queue_envelope_delete(uint64_t);
int queue_envelope_load(uint64_t, struct envelope *);
int queue_envelope_update(struct envelope *);
int queue_envelope_walk(struct envelope *);
int queue_message_walk(struct envelope *, uint32_t, int *, void **);


/* ruleset.c */
struct rule *ruleset_match(const struct envelope *);


/* scheduler.c */
int scheduler(void);


/* scheduler_bakend.c */
struct scheduler_backend *scheduler_backend_lookup(const char *);
void scheduler_info(struct scheduler_info *, struct envelope *);


/* pony.c */
int pony(void);
void pony_imsg(struct mproc *, struct imsg *);


/* smtp.c */
void smtp_postfork(void);
void smtp_postprivdrop(void);
void smtp_imsg(struct mproc *, struct imsg *);
void smtp_configure(void);
void smtp_collect(void);


/* smtp_session.c */
int smtp_session(struct listener *, int, const struct sockaddr_storage *,
    const char *);
void smtp_session_imsg(struct mproc *, struct imsg *);
void smtp_filter_response(uint64_t, int, int, uint32_t, const char *);
void smtp_filter_fd(uint64_t, int);


/* smtpd.c */
void imsg_dispatch(struct mproc *, struct imsg *);
const char *proc_name(enum smtp_proc_type);
const char *proc_title(enum smtp_proc_type);
const char *imsg_to_str(int);
void log_imsg(int, int, struct imsg *);
int fork_proc_backend(const char *, const char *, const char *);


/* ssl_smtpd.c */
void   *ssl_mta_init(void *, char *, off_t, const char *);
void   *ssl_smtp_init(void *, int);


/* stat_backend.c */
struct stat_backend	*stat_backend_lookup(const char *);
void	stat_increment(const char *, size_t);
void	stat_decrement(const char *, size_t);
void	stat_set(const char *, const struct stat_value *);
struct stat_value *stat_counter(size_t);
struct stat_value *stat_timestamp(time_t);
struct stat_value *stat_timeval(struct timeval *);
struct stat_value *stat_timespec(struct timespec *);


/* table.c */
struct table *table_find(const char *, const char *);
struct table *table_create(const char *, const char *, const char *,
    const char *);
int	table_config(struct table *);
int	table_open(struct table *);
int	table_update(struct table *);
void	table_close(struct table *);
int	table_check_use(struct table *, uint32_t, uint32_t);
int	table_check_type(struct table *, uint32_t);
int	table_check_service(struct table *, uint32_t);
int	table_lookup(struct table *, struct dict *, const char *, enum table_service,
    union lookup *);
int	table_fetch(struct table *, struct dict *, enum table_service, union lookup *);
void table_destroy(struct table *);
void table_add(struct table *, const char *, const char *);
int table_domain_match(const char *, const char *);
int table_netaddr_match(const char *, const char *);
int table_mailaddr_match(const char *, const char *);
void	table_open_all(void);
void	table_dump_all(void);
void	table_close_all(void);
int table_parse_lookup(enum table_service, const char *, const char *,
    union lookup *);


/* to.c */
int email_to_mailaddr(struct mailaddr *, char *);
int text_to_netaddr(struct netaddr *, const char *);
int text_to_mailaddr(struct mailaddr *, const char *);
int text_to_relayhost(struct relayhost *, const char *);
int text_to_userinfo(struct userinfo *, const char *);
int text_to_credentials(struct credentials *, const char *);
int text_to_expandnode(struct expandnode *, const char *);
uint64_t text_to_evpid(const char *);
uint32_t text_to_msgid(const char *);
const char *sa_to_text(const struct sockaddr *);
const char *ss_to_text(const struct sockaddr_storage *);
const char *time_to_text(time_t);
const char *duration_to_text(time_t);
const char *relayhost_to_text(const struct relayhost *);
const char *rule_to_text(struct rule *);
const char *sockaddr_to_text(struct sockaddr *);
const char *mailaddr_to_text(const struct mailaddr *);
const char *expandnode_to_text(struct expandnode *);


/* util.c */
typedef struct arglist arglist;
struct arglist {
	char	**list;
	uint	  num;
	uint	  nalloc;
};
void addargs(arglist *, char *, ...)
	__attribute__((format(printf, 2, 3)));
int bsnprintf(char *, size_t, const char *, ...)
	__attribute__((format (printf, 3, 4)));
int mkdirs(char *, mode_t);
int safe_fclose(FILE *);
int hostname_match(const char *, const char *);
int mailaddr_match(const struct mailaddr *, const struct mailaddr *);
int valid_localpart(const char *);
int valid_domainpart(const char *);
int secure_file(int, char *, char *, uid_t, int);
int  lowercase(char *, const char *, size_t);
void xlowercase(char *, const char *, size_t);
int  uppercase(char *, const char *, size_t);
uint64_t generate_uid(void);
int availdesc(void);
int ckdir(const char *, mode_t, uid_t, gid_t, int);
int rmtree(char *, int);
int mvpurge(char *, char *);
int mktmpfile(void);
const char *parse_smtp_response(char *, size_t, char **, int *);
void *xmalloc(size_t, const char *);
void *xcalloc(size_t, size_t, const char *);
char *xstrdup(const char *, const char *);
void *xmemdup(const void *, size_t, const char *);
char *strip(char *);
int io_xprint(struct io *, const char *);
int io_xprintf(struct io *, const char *, ...);
void log_envelope(const struct envelope *, const char *, const char *,
    const char *);
int session_socket_error(int);
int getmailname(char *, size_t);
int base64_encode(unsigned char const *, size_t, char *, size_t);
int base64_decode(char const *, unsigned char *, size_t);


/* waitq.c */
int  waitq_wait(void *, void (*)(void *, void *, void *), void *);
void waitq_run(void *, void *);


/* runq.c */
struct runq;

int runq_init(struct runq **, void (*)(struct runq *, void *));
int runq_schedule(struct runq *, time_t, void (*)(struct runq *, void *), void *);
int runq_delay(struct runq *, unsigned int, void (*)(struct runq *, void *), void *);
int runq_cancel(struct runq *, void (*)(struct runq *, void *), void *);
int runq_pending(struct runq *, void (*)(struct runq *, void *), void *, time_t *);
int runq_next(struct runq *, void (**)(struct runq *, void *), void **, time_t *);
@


1.529
log
@Stop assuming that in_{addr,port}_t are typedefed in <sys/types.h> and
instead pull in <netinet/in.h> or <arpa/inet.h> when those are needed.

ok florian@@ beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.528 2017/01/09 09:53:23 reyk Exp $	*/
d401 2
a402 1
	
@


1.528
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.527 2016/11/30 18:38:32 eric Exp $	*/
d25 1
@


1.527
log
@remove unused iobuf helpers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.526 2016/11/30 11:52:48 eric Exp $	*/
d1021 1
a1021 1
extern int verbose;
@


1.526
log
@make struct io opaque:

- move struct io definition to ioev.c
- replace io_init/io_clear with io_new/io_free
- allocate an iobuf for each new io internally
- use struct io pointer in the rest of the code
- remove remaining uses of iobuf_*

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.525 2016/11/25 09:21:21 gilles Exp $	*/
a29 1
#include "iobuf.h"
a1496 2
void iobuf_xinit(struct iobuf *, size_t, size_t, const char *);
void iobuf_xfqueue(struct iobuf *, const char *, const char *, ...);
@


1.525
log
@assign an id to each rule in the ruleset, first step towards an MTA layer
and scheduler simplification

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.524 2016/11/17 17:34:55 eric Exp $	*/
d24 2
@


1.524
log
@Add io api functions for dealing with buffered data, as wrapper around
their iobuf counterparts.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.523 2016/09/04 09:33:49 eric Exp $	*/
d379 1
@


1.523
log
@Remove the "smtpctl stop" command.
The daemon is stopped with kill(1).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.522 2016/09/03 16:06:26 eric Exp $	*/
d1497 2
@


1.522
log
@get rid of the type-checking system on internal messages.
bump all imsg protocol versions since message format changed.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.521 2016/09/01 10:54:25 eric Exp $	*/
d164 1
a164 1
#define	IMSG_VERSION		15
a197 1
	IMSG_CTL_SHUTDOWN,
d574 1
a574 1
#define SMTPD_EXITING			0x00000001
@


1.521
log
@remove noop function

ok sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.520 2016/09/01 10:07:20 eric Exp $	*/
d164 1
a164 1
#define	IMSG_VERSION		14
@


1.520
log
@get rid of the imsg buffer usage profiling code.

ok gilles@@ jung@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.519 2016/08/31 21:49:01 eric Exp $	*/
a1150 1
void config_done(void);
@


1.519
log
@Remove dead code. queue_flow_control() has never been used and is
probably a bad idea.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.518 2016/08/31 15:24:04 gilles Exp $	*/
a660 1
#define PROFILE_BUFFERS	0x0008
a1010 7

	off_t		 msg_in;
	off_t		 msg_out;
	off_t		 bytes_in;
	off_t		 bytes_out;
	size_t		 bytes_queued;
	size_t		 bytes_queued_max;
@


1.518
log
@introduce "authenticated" parameter so rules may apply to authenticated
sessions specifically

ok eric@@, sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.517 2016/08/31 10:18:08 gilles Exp $	*/
a1343 1
void queue_flow_control(void);
@


1.517
log
@allow overriding the subaddressing delimiter with subaddressing-delimiter
keyword, the default is still +

ok eric@@, sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.516 2016/07/24 16:04:53 gilles Exp $	*/
d398 2
@


1.516
log
@bump version

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.515 2016/05/28 21:21:20 eric Exp $	*/
d636 2
@


1.515
log
@Implement the fork+exec pattern in smtpd.

The parent process forks child processes and re-exec each of them with
an additional "-x <proc>" argument.  During the early setup phase, the
parent process sends ipc socket pairs to interconnect the child
processes as needed, and it passes the queue encryption key to the
queue if necessary. When this is done, all processes have their
environment set as in the fork-only case, and they can start doing
their work as before.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.514 2016/03/25 15:06:58 krw Exp $	*/
d55 1
a55 1
#define	SMTPD_VERSION		 "5.9.1"
@


1.514
log
@Nuke session_socket_blockmode() and session_socket_linger(). Use
the identical io_set_blocking() and io_set_linger().

Since both are always called to turn off blocking or lingering,
nuke the parameter and associated enum in favour of "just doing the
right thing".

While passing remove the unneeded last parameter to the remaining
fcntl(F_GETFL).

Finally, rename the functions to io_set_nonblocking() and
io_set_nolinger() for clarity.

No functional change.

Started with a sweep of fcntl() usage inspired by guenther@@.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.513 2016/02/21 15:17:25 gilles Exp $	*/
d209 4
d1132 1
a1132 1
pid_t	 ca(void);
a1152 1
void init_pipes(void);
d1159 1
a1159 1
pid_t control(void);
d1234 1
a1234 1
pid_t lka(void);
d1339 1
a1339 1
pid_t queue(void);
d1368 1
a1368 1
pid_t scheduler(void);
d1377 1
a1377 1
pid_t pony(void);
a1398 1
void post_fork(int);
@


1.513
log
@bump version
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.512 2016/02/13 20:43:07 gilles Exp $	*/
a310 5
enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK
};

a1503 2
void session_socket_blockmode(int, enum blockmodes);
void session_socket_no_linger(int);
@


1.512
log
@handle enqueuer socket as a regular listener that can be configured with
"listen on socket". this simplifies a bit of code, removes some special
cases and will allow attaching filters & masking source just as on lo0.

diff from Peter Bisroev <peter@@int19h.net>
ok gilles@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.511 2016/02/05 19:21:04 jung Exp $	*/
d55 1
a55 1
#define	SMTPD_VERSION		 "master"
@


1.511
log
@remove no longer relevant ifndef

suggested by gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.510 2016/01/27 12:46:03 sunil Exp $	*/
d615 3
@


1.510
log
@Check imsg data length before use.

Ok jung@@ gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.509 2016/01/04 13:30:20 jung Exp $	*/
a53 1
#ifndef SMTPD_NAME
a54 1
#endif
@


1.509
log
@switch to /usr/local/libexec when looking for -extras and drop loop iterating
paths

this effectively reverts table.c r1.21 which was mainly introduced for a smooth
transition in -current

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.508 2015/12/13 11:06:13 gilles Exp $	*/
d31 7
@


1.508
log
@smtpd is no longer 5.4.6
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.507 2015/12/13 09:52:44 gilles Exp $	*/
d60 1
a60 2
#define	PATH_LIBEXEC_DEPRECATED	"/usr/libexec/smtpd"
#define	PATH_LIBEXEC		"/usr/local/libexec/smtpd:/usr/libexec/smtpd"
@


1.507
log
@refactor a bit to move the SNI handling away from smtp_session into smtp

ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.506 2015/12/12 17:16:56 gilles Exp $	*/
d50 1
a50 1
#define	SMTPD_VERSION		 "5.4.6"
@


1.506
log
@allow overriding the default cipher-suite

ok jung@@, sunil@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.505 2015/12/12 12:22:26 gilles Exp $	*/
d1404 1
a1404 1
void   *ssl_smtp_init(void *, void *, int);
@


1.505
log
@add bits so local enqueuer can run filters when they are enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.504 2015/12/12 10:52:22 gilles Exp $	*/
d628 2
d1403 1
a1403 1
void   *ssl_mta_init(void *, char *, off_t);
@


1.504
log
@expose foreground_log in smtpd.h so filters can inherit it
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.503 2015/12/12 10:03:33 gilles Exp $	*/
d626 2
@


1.503
log
@sender and recipient are mail addresses, not pathnames, use proper define
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.502 2015/12/12 10:00:59 gilles Exp $	*/
d1015 1
@


1.502
log
@use smtpd specific define for table name sizes
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.501 2015/12/12 09:58:33 gilles Exp $	*/
d660 3
a662 3
	char			to[PATH_MAX];
	char			from[PATH_MAX];
	char			dest[LINE_MAX];
@


1.501
log
@pki name and ca name must match a hostname, use HOST_NAME_MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.500 2015/12/12 09:09:40 gilles Exp $	*/
d119 1
a119 1
	char authtable[PATH_MAX];
d411 1
a411 1
	char			usertable[PATH_MAX];
@


1.500
log
@do not limit usernames to LOGIN_NAME_MAX in places where "virtual users"
may be used, in such places an email address may be specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.499 2015/12/12 09:00:22 gilles Exp $	*/
d117 2
a118 2
	char pki_name[PATH_MAX];
	char ca_name[PATH_MAX];
@


1.499
log
@rename an smtpd specific define
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.498 2015/12/12 08:35:19 gilles Exp $	*/
d100 1
d102 1
a102 1
	char username[LOGIN_NAME_MAX];
d412 1
a412 1
	char			username[LOGIN_NAME_MAX];
d414 1
a414 1
	char			delivery_user[LINE_MAX];
d556 1
d653 1
a653 1
	char				user[LOGIN_NAME_MAX];
d663 1
a663 1
	char			user[LOGIN_NAME_MAX];
@


1.498
log
@prepare some imsg structures for upcoming diff to support wildcard ca
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.497 2015/12/11 21:44:01 gilles Exp $	*/
a39 1
#define MAX_TAG_SIZE		 32
d379 1
a379 1
	char				r_tag[MAX_TAG_SIZE];
d501 1
a501 1
	char				tag[MAX_TAG_SIZE];
d549 1
a549 1
	char			 tag[MAX_TAG_SIZE];
@


1.497
log
@rename field member + whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.496 2015/12/11 07:51:38 gilles Exp $	*/
d1067 1
d1073 1
d1081 1
@


1.496
log
@add filter.c prototypes, unused for now
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.495 2015/12/11 07:48:33 gilles Exp $	*/
d1078 1
a1078 1
	char			pkiname[HOST_NAME_MAX+1];
d1213 1
d1218 1
d1313 1
d1348 1
d1455 1
d1504 1
@


1.495
log
@prepare smtpd.h for masquerading
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.494 2015/12/07 12:29:19 sunil Exp $	*/
d1188 12
d1236 1
d1240 1
d1375 2
@


1.494
log
@Merge makemap(8) into smtpctl(8).

Ok gilles@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.493 2015/12/03 21:11:33 jung Exp $	*/
d86 1
d555 1
@


1.493
log
@introduce limit session keyword replacing fixed values

original diff from Renaud Allard

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.492 2015/12/01 18:22:30 gilles Exp $	*/
d1222 2
@


1.492
log
@add received-auth parameter to listener to identify authenticated sessions
in locally appended Received header when enabled

ok millert@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.491 2015/12/01 09:39:07 gilles Exp $	*/
d583 3
@


1.491
log
@add IMSG_SMTP_CHECK_SENDER in preparation for another diff
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.490 2015/12/01 09:33:17 gilles Exp $	*/
d85 1
@


1.490
log
@prepare the ground for the CA certificate handling refactor, this commit
adds the parse.y bit + structures & members needed but does not make use
of it yet
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.489 2015/11/30 14:27:25 gilles Exp $	*/
d282 1
@


1.489
log
@add ca_name field to some structures in preparation for a larger
diff to refactor handling of CA certificates
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.488 2015/11/30 14:13:03 gilles Exp $	*/
d607 2
a608 1
	
@


1.488
log
@when looking up tables, start in /usr/local/libexec before /usr/libexec, so
ports/packages can be installed in the proper place

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.487 2015/11/30 12:49:35 gilles Exp $	*/
d116 1
d546 1
d802 1
@


1.487
log
@mechanical rename of some IMSG constants

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.486 2015/11/30 12:26:55 sunil Exp $	*/
d61 2
a62 1
#define	PATH_LIBEXEC		"/usr/libexec/smtpd"
@


1.486
log
@While delivering to lmtp or mda, accept optional "as user" parameter
whose privileges would be used instead of the default.

Ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.485 2015/11/23 21:50:12 gilles Exp $	*/
d262 4
a265 4
	IMSG_MTA_SSL_INIT,
	IMSG_MTA_SSL_VERIFY_CERT,
	IMSG_MTA_SSL_VERIFY_CHAIN,
	IMSG_MTA_SSL_VERIFY,
d282 4
a285 4
	IMSG_SMTP_SSL_INIT,
	IMSG_SMTP_SSL_VERIFY_CERT,
	IMSG_SMTP_SSL_VERIFY_CHAIN,
	IMSG_SMTP_SSL_VERIFY,
@


1.485
log
@allow table API to lookup for mailaddr mappings

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.484 2015/11/05 09:14:31 sunil Exp $	*/
d401 1
d409 1
@


1.484
log
@Implement smtpctl uncorrupt <msgid>

"uncorrupt" moves envelopes from corrupt bucket back to the queue
for further discovery by the daemon.

After correcting the corrupt envelopes, admin could now...

# smtpctl uncorrupt msgid
# smtpctl discover msgid

to schedule the messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.483 2015/10/29 10:25:36 sunil Exp $	*/
d149 1
@


1.483
log
@Implement smtpctl discover <evpid|msgid>.

discover subcommand schedules envelopes manually moved to the queue.
It triggers a queue walk searching for envelopes with the given id,
schedules them and informs the user number of envelopes scheduled.
Admins no longer would need to restart the daemon to discover
manually moved messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.482 2015/10/28 14:30:03 gilles Exp $	*/
d155 1
a155 1
#define	IMSG_VERSION		13
d196 1
d1306 1
@


1.482
log
@masquerade and senders map require being able to lookup mailaddr structures
in tables, prepare for such features by bringing the helpers + smtpd.h part

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.481 2015/10/28 07:25:30 gilles Exp $	*/
d155 1
a155 1
#define	IMSG_VERSION		11
d194 2
d216 2
d905 1
d1076 8
d1310 1
a1310 1

@


1.481
log
@aliases support resolving to maildir:/path

ok sunil@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.480 2015/10/27 20:14:19 gilles Exp $	*/
d469 9
d1194 7
@


1.480
log
@aliases_virtual_check() has been unneeded for a while

ok jung@@, ok sunil@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.479 2015/10/21 16:44:28 jsing Exp $	*/
d434 2
a435 1
	EXPAND_ERROR
@


1.479
log
@Only enable SSL_VERIFY_PEER when the verify option is set on a listener.

Always enabling SSL_VERIFY_PEER unnecessarily increases the number of
messages/bytes in the TLS handshake and increases our attack surface,
since we request and then process client certificates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.478 2015/10/17 22:24:36 gilles Exp $	*/
a1063 1
int aliases_virtual_check(struct table *, const struct mailaddr *);
@


1.478
log
@mailaddr_match() allows comparing two struct mailaddr taking into account
catchall and +-tags

ok millert@@ and jung@@ for util.c
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.477 2015/10/14 22:16:38 gilles Exp $	*/
d1327 1
a1327 1
void   *ssl_smtp_init(void *, void *);
@


1.477
log
@smtpd in tree is no longer neither 5.4.4, nor 5.4.5, bump SMTPD_VERSION
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.476 2015/10/09 14:37:38 gilles Exp $	*/
d1401 1
@


1.476
log
@turn our local enqueuer setgid _smtpq and restrict access to offline queue,
the enqueuer will revoke group and regain real gid right after mkstemp.

this would have prevented the symlink/hardlink attacks against offline, and
it will avoid having to deal with new ways users can mess with it.

ok eric@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.475 2015/09/07 15:36:53 gilles Exp $	*/
d51 1
a51 1
#define	SMTPD_VERSION		 "5.4.4"
@


1.475
log
@when bypassing the enqueuer, insert Message-Id header if none was found and
the client has connected from a loopback interface.

ok millert@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.474 2015/04/19 20:29:12 gilles Exp $	*/
d1128 1
a1128 1
int		 enqueue(int, char **);
@


1.474
log
@Incorrect logic in smtpd(8) can lead to unexpected client disconnect, invalid
certificate in SNI negotiation or server crash.

spotted by Edwin Torok
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.473 2015/01/20 17:37:54 deraadt Exp $	*/
d532 2
@


1.473
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.472 2014/12/24 13:53:39 eric Exp $	*/
d1325 1
a1325 1
void   *ssl_smtp_init(void *, void *, void *);
@


1.473.2.1
log
@Incorrect logic in smtpd(8) can lead to unexpected client disconnect, invalid
certificate in SNI negotiation or server crash.

spotted by Edwin Torok
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.473 2015/01/20 17:37:54 deraadt Exp $	*/
d1325 1
a1325 1
void   *ssl_smtp_init(void *, void *);
@


1.472
log
@bump version
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.471 2014/12/14 15:26:56 gilles Exp $	*/
d99 2
a100 2
	char username[SMTPD_MAXLOGNAME];
	char directory[SMTPD_MAXPATHLEN];
d112 1
a112 1
	char hostname[SMTPD_MAXHOSTNAMELEN];
d114 6
a119 6
	char pki_name[SMTPD_MAXPATHLEN];
	char authtable[SMTPD_MAXPATHLEN];
	char authlabel[SMTPD_MAXPATHLEN];
	char sourcetable[SMTPD_MAXPATHLEN];
	char heloname[SMTPD_MAXHOSTNAMELEN];
	char helotable[SMTPD_MAXPATHLEN];
d123 2
a124 2
	char username[SMTPD_MAXLINESIZE];
	char password[SMTPD_MAXLINESIZE];
d128 1
a128 1
	char	name[SMTPD_MAXHOSTNAMELEN];
d137 1
a137 1
	char			name[SMTPD_MAXHOSTNAMELEN];
d322 1
a322 1
	char				 t_name[SMTPD_MAXLINESIZE];
d324 1
a324 1
	char				 t_config[SMTPD_MAXPATHLEN];
d399 2
a400 2
	char			usertable[SMTPD_MAXPATHLEN];
	char			username[SMTPD_MAXLOGNAME];
d485 4
a488 4
	char				smtpname[SMTPD_MAXHOSTNAMELEN];
	char				helo[SMTPD_MAXHOSTNAMELEN];
	char				hostname[SMTPD_MAXHOSTNAMELEN];
	char				errorline[SMTPD_MAXLINESIZE];
d525 1
a525 1
	char			 pki_name[SMTPD_MAXPATHLEN];
d527 4
a530 4
	char			 filter[SMTPD_MAXPATHLEN];
	char			 authtable[SMTPD_MAXLINESIZE];
	char			 hostname[SMTPD_MAXHOSTNAMELEN];
	char			 hostnametable[SMTPD_MAXPATHLEN];
d535 1
a535 1
	char				sc_conffile[SMTPD_MAXPATHLEN];
d575 1
a575 1
	char				sc_hostname[SMTPD_MAXHOSTNAMELEN];
d621 1
a621 1
	char				user[SMTPD_MAXLOGNAME];
d624 1
a624 1
	char				directory[SMTPD_MAXPATHLEN];
d628 4
a631 4
	char			to[SMTPD_MAXPATHLEN];
	char			from[SMTPD_MAXPATHLEN];
	char			dest[SMTPD_MAXLINESIZE];
	char			user[SMTPD_MAXLOGNAME];
d828 1
a828 1
	char				 status[SMTPD_MAXLINESIZE];
d1033 1
a1033 1
	char			name[SMTPD_MAXHOSTNAMELEN];
d1045 1
a1045 1
	char			pkiname[SMTPD_MAXHOSTNAMELEN];
@


1.471
log
@these are no longer used, remove
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.470 2014/11/16 19:07:50 bluhm Exp $	*/
d51 1
a51 1
#define	SMTPD_VERSION		 "5.4.3"
@


1.470
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.469 2014/10/15 08:09:02 gilles Exp $	*/
a30 1
#include "rfc822.h"
@


1.469
log
@when From, To and Cc headers present users without domains, append the
listener hostname to avoid smtpd relaying a header that will be rewritten
by the destination MX.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.468 2014/07/10 14:45:02 eric Exp $	*/
d1177 1
@


1.468
log
@Improve the scheduler, better and simpler.

- Get rid of the scheduler_batch structure. The scheduler can now return
  envelopes of different types in a single run, interlacing them to avoid
  batch effects.

- Ask for an acknowledgement from the queue when removing or expiring
  an envelope to benefit from the inflight envelope limitation mechanism.
  This ensures that the scheduler always keeps sending envelopes at a rate
  that the queue can sustain in all cases.

- Limit the number of envelopes in a holdq.  When a holdq is full,
  new envelopes are put back in the pending queue instead, with a
  shorter retry time.

- Plumbing for proc-ified schedulers.

imsg version bump. smtpctl stop before updating.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.467 2014/07/09 12:44:54 eric Exp $	*/
d29 3
@


1.468.4.1
log
@Incorrect logic in smtpd(8) can lead to unexpected client disconnect, invalid
certificate in SNI negotiation or server crash.

spotted by Edwin Torok
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.468 2014/07/10 14:45:02 eric Exp $	*/
d1322 1
a1322 1
void   *ssl_smtp_init(void *, void *);
@


1.467
log
@add a "no-dsn" listener option to disable DSN extension.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.466 2014/07/09 09:53:37 eric Exp $	*/
d153 1
a153 1
#define	IMSG_VERSION		10
d212 1
d868 1
a868 1
	int	(*init)(void);
d879 1
a879 1
	int	(*batch)(int, struct scheduler_batch *);
a1288 1
time_t scheduler_compute_schedule(struct scheduler_info *);
@


1.466
log
@config parser improvements:

- fail if the same option is specified multiple times on a listener
- prompt for queue encryption key after config parsing, not during.
- add ip addresses to localnames table
- prepare for filters
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.465 2014/07/08 21:58:33 eric Exp $	*/
d81 1
@


1.465
log
@update filter configuration parsing (not plugged yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.464 2014/07/08 20:14:46 eric Exp $	*/
d523 1
@


1.464
log
@get rid of mfa leftovers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.463 2014/07/08 15:45:32 eric Exp $	*/
d40 1
d633 7
a639 6
struct filter {
	int			chain;
	int			done;
	char			name[MAX_FILTER_NAME];
	char			path[SMTPD_MAXPATHLEN];
	char			filters[MAX_FILTER_NAME][MAX_FILTER_PER_CHAIN];
@


1.463
log
@various queue improvements:

- add a "close" hook to the backend API.
- improve the sync() pattern in queue_fs: only sync at commit
  time and not for every envelope creation
- various fixes to the experimental external queue API.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.462 2014/07/08 13:49:09 eric Exp $	*/
d594 1
a594 1
#define	TRACE_MFA	0x0010
a1004 6
enum mfa_resp_status {
	MFA_OK,
	MFA_FAIL,
	MFA_CLOSE,
};

a1174 18


/* mfa.c */
pid_t mfa(void);
void mfa_ready(void);


/* mfa_session.c */
void mfa_filter_prepare(void);
void mfa_filter_init(void);
void mfa_filter_connect(uint64_t, const struct sockaddr *,
    const struct sockaddr *, const char *);
void mfa_filter_mailaddr(uint64_t, int, const struct mailaddr *);
void mfa_filter_line(uint64_t, int, const char *);
void mfa_filter_eom(uint64_t, int, size_t);
void mfa_filter(uint64_t, int);
void mfa_filter_event(uint64_t, int);
void mfa_build_fd_chain(uint64_t, int);
@


1.462
log
@Update the table API: lookup functions can take an optional parameters
dictionnary (currently not set). While there, add a helper for forking
external backends, and remove unused table functions.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.461 2014/05/04 16:38:19 reyk Exp $	*/
d835 1
a835 1
	int	(*init)(struct passwd *, int);
d1283 1
@


1.461
log
@Create a new default RSA engine instead of patching the existing one
if none is available.  Fixes SSL/TLS and a possible fatalx() on
machines without a default RSA engine.

Thanks to Bjorn Ketelaars for reporting and testing.

ok gilles@@ (for the relayd part)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.460 2014/05/01 15:50:20 reyk Exp $	*/
d58 1
a58 2
#define	PATH_FILTERS		"/usr/libexec/smtpd"
#define	PATH_TABLES		"/usr/libexec/smtpd"
d334 2
a335 2
	int	(*lookup)(void *, const char *, enum table_service, union lookup *);
	int	(*fetch)(void *, enum table_service, union lookup *);
d1202 1
a1202 1
int mproc_fork(struct mproc *, const char*, const char *);
d1226 1
d1245 2
d1336 1
d1366 1
a1366 1
int	table_lookup(struct table *, const char *, enum table_service,
d1368 1
a1368 1
int	table_fetch(struct table *, enum table_service, union lookup *);
a1370 1
void table_delete(struct table *, const char *);
a1376 1
const void	*table_get(struct table *, const char *);
@


1.460
log
@Move RSA keys from "lka" to a new dedicated "ca" process because lka
is handling some async requests and shouldn't be busy with sync RSA.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.459 2014/04/30 09:17:29 gilles Exp $	*/
d1081 1
a1081 1
int	 ca_engine_init(void);
@


1.459
log
@when using maildir, do not create automatically create folders to match tag
in email address (ie: gilles+tag => ~/Maildir/.tag), instead use the folder
if it already exists and deliver to the mail Maildir otherwise.

ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.458 2014/04/30 08:23:43 reyk Exp $	*/
d34 1
a34 1
#define PROC_COUNT		 6
d304 1
d983 1
d1077 1
@


1.458
log
@The RSA engine (used by pony) has to wait for a response from the
privileged process (lka) and receive the imsgs in a while loop
synchronously.  But the lka also sends other imsgs (DNS etc.) that can
still be queued up in the buffer when waiting for the RSA response.
This only happens under load with many concurrent connections.  For
now, we just call the pony imsg handler for non-RSA imsgs that are
already in the buffer.

ok gilles@@ eric@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.457 2014/04/29 19:13:14 reyk Exp $	*/
d624 1
@


1.457
log
@Implement RSA privilege separation for OpenSMTPD, based on my previous
implementation for relayd(8).  The smtpd(8) pony processes (mta
client, smtp server) don't keep the private keys in memory but send
their private key operations as imsgs to the "lookup"/mta process.
It's worth mentioning that this prevents acidental private key leakage
as it could have been caused by "Heartbleed".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.456 2014/04/29 12:18:27 reyk Exp $	*/
d1306 1
d1329 1
@


1.456
log
@Remove unused arguments from ssl_smtp_init()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.455 2014/04/19 16:55:15 gilles Exp $	*/
d287 3
a1037 2
	char		       *key;
	off_t			key_len;
d1074 4
a1077 2
int	ca_X509_verify(void *, void *, const char *, const char *, const char **);

d1091 2
a1092 1
#define PURGE_EVERYTHING	0xff
d1204 1
d1213 1
d1224 1
d1230 1
d1331 1
a1331 1
void   *ssl_mta_init(char *, off_t, char *, off_t);
@


1.455
log
@certs are looked up by hostname, the size of the buffer should use the
max hostname len, not max pathname len as before
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.454 2014/04/09 18:55:19 eric Exp $	*/
d1324 1
a1324 1
void   *ssl_smtp_init(void *, char *, off_t, char *, off_t, void *, void *);
@


1.454
log
@Zap the mfa process. It is not currently doing anything, and content filtering
will be done at session level anyway.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1027 1
a1027 1
	char			name[SMTPD_MAXPATHLEN];
@


1.453
log
@remove useless define for banner

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.452 2014/04/04 16:10:42 eric Exp $	*/
d34 1
a34 1
#define PROC_COUNT		 7
a295 1
	PROC_MFA,
a974 1
extern struct mproc *p_mfa;
@


1.452
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 1
#define SMTPD_BANNER		 "220 %s ESMTP %s"
@


1.451
log
@disable the imsg buffers profiling code unless requested, this will prevent
all processes from waking up every second
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.450 2014/02/17 13:33:56 eric Exp $	*/
d34 1
a34 1
#define PROC_COUNT		 10
d48 1
a48 1
#define	SMTPD_VERSION		 "5.4.2"
d153 1
a153 1
#define	IMSG_VERSION		9
d157 2
a158 1
	IMSG_CTL_OK,		/* answer to smtpctl requests */
d160 12
a171 2
	IMSG_CTL_SHUTDOWN,
	IMSG_CTL_VERBOSE,
d176 3
a183 2
	IMSG_CTL_LIST_MESSAGES,
	IMSG_CTL_LIST_ENVELOPES,
d187 5
d193 1
a193 12
	IMSG_CTL_TRACE,
	IMSG_CTL_UNTRACE,
	IMSG_CTL_PROFILE,
	IMSG_CTL_UNPROFILE,

	IMSG_CTL_MTA_SHOW_HOSTS,
	IMSG_CTL_MTA_SHOW_RELAYS,
	IMSG_CTL_MTA_SHOW_ROUTES,
	IMSG_CTL_MTA_SHOW_HOSTSTATS,
	IMSG_CTL_MTA_BLOCK,
	IMSG_CTL_MTA_UNBLOCK,
	IMSG_CTL_MTA_SHOW_BLOCK,
a195 12
	IMSG_CONF_SSL,
	IMSG_CONF_LISTENER,
	IMSG_CONF_TABLE,
	IMSG_CONF_TABLE_CONTENT,
	IMSG_CONF_RULE,
	IMSG_CONF_RULE_SOURCE,
	IMSG_CONF_RULE_SENDER,
	IMSG_CONF_RULE_DESTINATION,
	IMSG_CONF_RULE_RECIPIENT,
	IMSG_CONF_RULE_MAPPING,
	IMSG_CONF_RULE_USERS,
	IMSG_CONF_FILTER,
d198 4
a201 6
	IMSG_LKA_UPDATE_TABLE,
	IMSG_LKA_EXPAND_RCPT,
	IMSG_LKA_SECRET,
	IMSG_LKA_SOURCE,
	IMSG_LKA_HELO,
	IMSG_LKA_USERINFO,
d203 25
a227 15
	IMSG_LKA_SSL_INIT,
	IMSG_LKA_SSL_VERIFY_CERT,
	IMSG_LKA_SSL_VERIFY_CHAIN,
	IMSG_LKA_SSL_VERIFY,

	IMSG_DELIVERY_OK,
	IMSG_DELIVERY_TEMPFAIL,
	IMSG_DELIVERY_PERMFAIL,
	IMSG_DELIVERY_LOOP,
	IMSG_DELIVERY_HOLD,
	IMSG_DELIVERY_RELEASE,

	IMSG_BOUNCE_INJECT,

	IMSG_MDA_DELIVER,
d229 5
a234 10
	IMSG_MFA_REQ_CONNECT,
	IMSG_MFA_REQ_HELO,
	IMSG_MFA_REQ_MAIL,
	IMSG_MFA_REQ_RCPT,
	IMSG_MFA_REQ_DATA,
	IMSG_MFA_REQ_EOM,
	IMSG_MFA_EVENT_RSET,
	IMSG_MFA_EVENT_COMMIT,
	IMSG_MFA_EVENT_ROLLBACK,
	IMSG_MFA_EVENT_DISCONNECT,
d237 15
a251 1
	IMSG_MTA_TRANSFER,
d253 35
a287 31

	IMSG_QUEUE_CREATE_MESSAGE,
	IMSG_QUEUE_SUBMIT_ENVELOPE,
	IMSG_QUEUE_COMMIT_ENVELOPES,
	IMSG_QUEUE_REMOVE_MESSAGE,
	IMSG_QUEUE_COMMIT_MESSAGE,
	IMSG_QUEUE_MESSAGE_FD,
	IMSG_QUEUE_MESSAGE_FILE,
	IMSG_QUEUE_REMOVE,
	IMSG_QUEUE_EXPIRE,
	IMSG_QUEUE_BOUNCE,

	IMSG_PARENT_FORWARD_OPEN,
	IMSG_PARENT_FORK_MDA,
	IMSG_PARENT_KILL_MDA,

	IMSG_SMTP_ENQUEUE_FD,

	IMSG_DNS_HOST,
	IMSG_DNS_HOST_END,
	IMSG_DNS_PTR,
	IMSG_DNS_MX,
	IMSG_DNS_MX_PREFERENCE,

	IMSG_STAT_INCREMENT,
	IMSG_STAT_DECREMENT,
	IMSG_STAT_SET,

	IMSG_DIGEST,
	IMSG_STATS,
	IMSG_STATS_GET,
a296 1
	PROC_SMTP,
a299 2
	PROC_MDA,
	PROC_MTA,
d302 1
a976 1
extern struct mproc *p_mda;
a977 1
extern struct mproc *p_mta;
d980 1
a980 1
extern struct mproc *p_smtp;
a1116 4
void dns_query_host(uint64_t, const char *);
void dns_query_ptr(uint64_t, const struct sockaddr *);
void dns_query_mx(uint64_t, const char *);
void dns_query_mx_preference(uint64_t, const char *, const char *);
d1174 3
a1176 1
pid_t mda(void);
d1183 1
d1196 1
d1239 3
a1241 1
pid_t mta(void);
a1264 4
void queue_ok(uint64_t);
void queue_tempfail(uint64_t, const char *, enum enhanced_status_code);
void queue_permfail(uint64_t, const char *, enum enhanced_status_code);
void queue_loop(uint64_t);
d1299 4
d1304 4
a1307 1
pid_t smtp(void);
@


1.450
log
@new "smtpctl show status" command to show if mta/mda/smtp are currently running or paused.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.449 2014/02/10 09:28:05 eric Exp $	*/
d595 1
@


1.450.2.1
log
@Incorrect logic in smtpd(8) can lead to unexpected client disconnect, invalid
certificate in SNI negotiation or server crash.

spotted by Edwin Torok
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.450 2014/02/17 13:33:56 eric Exp $	*/
d1310 1
a1310 1
void   *ssl_smtp_init(void *, char *, off_t, char *, off_t, void *);
@


1.449
log
@tweak usage() and bump version.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.448 2014/02/04 15:44:06 eric Exp $	*/
d153 1
a153 1
#define	IMSG_VERSION		8
d174 1
@


1.448
log
@Add support for DSN and Enhanced Status Code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
#define	SMTPD_VERSION		 "5.4.1"
@


1.447
log
@Allow the admin to pause relaying to a specific domain:
 - smtpctl pause mta from <source> for <domain>
 - smtpctl resume mta from <source> for <domain>
 - smtpctl show mta paused
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.446 2014/02/04 14:56:03 eric Exp $	*/
d94 2
d391 6
d403 2
d448 7
d488 8
d797 7
d1117 2
d1251 2
a1252 2
void queue_tempfail(uint64_t, const char *);
void queue_permfail(uint64_t, const char *);
@


1.446
log
@internal improvements and cleanups

- get rid of the whole penalty thing for failed envelopes in the mta and scheduler.
- do not disable routes on smtp errors
- try to schedule all types of envelopes on each scheduler frame.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.445 2014/02/04 13:44:41 eric Exp $	*/
d151 1
a151 1
#define	IMSG_VERSION		7
d182 3
a480 2
	struct ssl		*ssl;
	void			*ssl_ctx;
d647 1
@


1.445
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.444 2014/02/04 10:38:06 eric Exp $	*/
d707 2
a769 1
	int				 penalty;
d1197 1
a1197 1
void mta_delivery_notify(struct mta_envelope *, uint32_t);
d1215 1
a1215 1
void queue_tempfail(uint64_t, uint32_t, const char *);
d1248 1
a1248 1
void scheduler_info(struct scheduler_info *, struct envelope *, uint32_t);
@


1.444
log
@extend allowed charset for email address, escape all potentially dangerous ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.443 2014/02/04 09:50:31 eric Exp $	*/
d110 1
a110 1
	char cert[SMTPD_MAXPATHLEN];
d477 1
a477 1
	char			 ssl_cert_name[SMTPD_MAXPATHLEN];
d495 8
a502 9
#define SMTPD_CONFIGURING		0x00000001
#define SMTPD_EXITING			0x00000002
#define SMTPD_MDA_PAUSED		0x00000004
#define SMTPD_MTA_PAUSED		0x00000008
#define SMTPD_SMTP_PAUSED		0x00000010
#define SMTPD_MDA_BUSY			0x00000020
#define SMTPD_MTA_BUSY			0x00000040
#define SMTPD_BOUNCE_BUSY		0x00000080
#define SMTPD_SMTP_DISABLED		0x00000100
d536 1
a536 1
	TAILQ_HEAD(rulelist, rule)		*sc_rules, *sc_rules_reload;
d538 1
d725 1
a725 1
	char			*cert;
d1042 1
a1042 1
#define PURGE_SSL		0x08
d1272 1
a1272 1
void   *ssl_smtp_init(void *, char *, off_t, char *, off_t);
@


1.443
log
@add base64_encode/base64_decode helpers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.442 2014/02/04 09:05:06 eric Exp $	*/
d61 9
@


1.442
log
@get rid of fdlimit()
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.441 2013/12/06 14:26:25 eric Exp $	*/
d1365 2
@


1.441
log
@now at 5.4.1
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.440 2013/12/05 10:06:32 eric Exp $	*/
a1345 1
void fdlimit(double);
@


1.440
log
@move defines around
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
#define	SMTPD_VERSION		 "5.4"
@


1.439
log
@Rework the envelope flushing loops in mta to avoid sending all delivery
notifications in one go to the queue. Simplify code in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.438 2013/11/30 10:11:57 eric Exp $	*/
a43 2
#define SMTPD_USER		 "_smtpd"
#define SMTPD_QUEUE_USER	 "_smtpq"
a54 2
#define PATH_CHROOT             "/var/empty"
#define PATH_SPOOL		"/var/spool/smtpd"
@


1.438
log
@do not hardcode scheduler batch size, and reduce default limit to avoid
hammering effects.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.437 2013/11/28 13:13:56 eric Exp $	*/
d763 2
d1191 1
a1191 2
void mta_delivery_notify(struct mta_envelope *, int, const char *, uint32_t);
void mta_delivery(struct mta_envelope *, const char *, const char *, int, const char *, uint32_t);
@


1.437
log
@limit the number of envelopes to recall in the hoststat cache.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.436 2013/11/20 09:22:42 eric Exp $	*/
d517 3
@


1.436
log
@Rework the mda and scheduler to use the holdq mechanism instead of
tempfail for limiting the number of pending deliveries to the same
user.  This allows to reach optimal delivery time even in case of
burst, while keeping the number of inflight envelopes low.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.435 2013/11/19 10:01:20 eric Exp $	*/
d513 2
@


1.435
log
@Add a limit on the number of inflight envelopes.  The scheduler suspends
scheduling of mta/mda envelopes until the number of inflight envelopes
falls below that line.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.434 2013/11/18 12:24:26 eric Exp $	*/
d508 6
d515 1
d808 1
a808 1
	int	(*release)(uint64_t, int);
@


1.434
log
@Allow overriding the local ca
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.433 2013/11/06 10:01:29 eric Exp $	*/
d508 1
@


1.433
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d976 1
@


1.432
log
@add "smtpctl show relays" and "smtpctl show hosts" commands
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.431 2013/10/29 17:04:46 eric Exp $	*/
d33 1
a33 1
#define MAX_LISTEN		 16
a34 1
#define MAX_NAME_SIZE		 64
a37 1

a38 4

#define	MAX_TABLE_BACKEND_SIZE	 32

/* return and forward path size */
a42 2
#define SMTPD_QUEUE_INTERVAL	 (15 * 60)
#define SMTPD_QUEUE_MAXINTERVAL	 (4 * 60 * 60)
d75 2
a76 3

#define F_SCERT			0x01
#define F_CCERT			0x02
d87 1
d102 1
a102 1
	uint8_t flags;
d109 1
a109 1
	char heloname[SMTPD_MAXPATHLEN];
d320 1
d338 1
d340 2
d343 2
d347 4
d364 1
d430 1
a430 1
#define	SMTPD_ENVELOPE_VERSION		1
d440 1
d466 1
a466 1
	uint8_t			 flags;
d477 2
a478 1
	char			 helo[SMTPD_MAXHOSTNAMELEN];
@


1.431
log
@add missing heloname field for relayhost.
differenciate relays with different helotable/heloname.
improve code a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.430 2013/10/29 14:30:05 eric Exp $	*/
d154 1
a154 1
#define	IMSG_VERSION		6
d181 2
d195 1
@


1.430
log
@use "/etc/mail/mailname" instead of "/etc/mailname" and make it a define.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.429 2013/10/29 11:23:58 eric Exp $	*/
d117 1
@


1.429
log
@Report mta sessions errors on the route rather than on the MX.
If a route has too many of these errors, disable it for a while.
Reset the error counter for a route when it is re-enabled or when
it could establish a connection successfully.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.428 2013/10/27 17:47:53 eric Exp $	*/
d31 1
@


1.428
log
@Implement a feedback mechanism which allows the mta to "hold" envelopes
in the scheduler when it has too many tasks for a given relay.  The
envelopes are put on a wait queue, and are not scheduled again until
the mta "releases" some envelopes from that queue.

It prevents from having too many inflight envelopes, which are out of reach
for the admin.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.427 2013/10/27 11:01:47 eric Exp $	*/
a579 1
	int			 nerror;
d649 1
@


1.427
log
@Make the filter infrastructure move forward.
This is a work-in-progress and it's not supposed to be useable for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.426 2013/10/27 07:56:25 eric Exp $	*/
a147 1
/* XXX */
d152 1
a152 1
#define	IMSG_VERSION		5
d212 2
a229 1
	IMSG_MFA_SMTP_DATA,
d680 4
d704 1
d789 2
@


1.426
log
@Create the control socket in the parent process to abort early if
another smtpd instance is running.  Close the inherited socket in
every forked process but control.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.425 2013/10/26 20:32:48 eric Exp $	*/
d560 1
d562 2
a563 1
	struct imsgproc	       *process;
d566 1
d1104 1
d1107 1
a1107 1
void mfa_filter_data(uint64_t, const char *);
@


1.425
log
@Simplify code for loading and dumping envelopes.  Makes it much easier
to deal with automatic upgrade between envelope versions at load time.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.424 2013/10/25 21:31:23 eric Exp $	*/
d1012 1
d1223 1
@


1.424
log
@local enqueuer improvements:

- parse the whole input before trying to establish the connection
  to the local socket: fixes timeout problems when reading the output
  of a long running program.

- use sendmail(8)-like exit status.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.423 2013/07/19 22:22:39 eric Exp $	*/
a455 32
enum envelope_field {
	EVP_VERSION,
	EVP_TAG,
	EVP_MSGID,
	EVP_TYPE,
	EVP_HELO,
	EVP_HOSTNAME,
	EVP_ERRORLINE,
	EVP_SOCKADDR,
	EVP_SENDER,
	EVP_RCPT,
	EVP_DEST,
	EVP_CTIME,
	EVP_EXPIRE,
	EVP_RETRY,
	EVP_LASTTRY,
	EVP_LASTBOUNCE,
	EVP_FLAGS,
	EVP_MDA_METHOD,
	EVP_MDA_BUFFER,
	EVP_MDA_USER,
	EVP_MDA_USERTABLE,
	EVP_MTA_RELAY,
	EVP_MTA_RELAY_AUTH,
	EVP_MTA_RELAY_CERT,
	EVP_MTA_RELAY_SOURCE,
	EVP_MTA_RELAY_HELO,
	EVP_BOUNCE_TYPE,
	EVP_BOUNCE_DELAY,
	EVP_BOUNCE_EXPIRE,
};

a1039 4
char *envelope_ascii_field_name(enum envelope_field);
int envelope_ascii_load(enum envelope_field, struct envelope *, char *);
int envelope_ascii_dump(enum envelope_field, const struct envelope *, char *,
    size_t);
@


1.423
log
@We are basically at 5.4 now
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.422 2013/07/19 21:34:31 eric Exp $	*/
a1067 1
int		 enqueue_offline(int, char **);
d1367 1
@


1.422
log
@Implement a scheduler_proc backend
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.421 2013/07/19 21:14:52 eric Exp $	*/
d57 1
a57 1
#define	SMTPD_VERSION		 "5.3.3"
@


1.421
log
@Many MTA improvements:

- Better transient error handling logic: failing destinations are
  automatically disabled for a while.  When a destination is active
  again, ask the scheduler to retry previous envelopes immediatly.
- More informative error report when all routes fail for a mail.
- Implement a "smtpctl show hoststats" command to get the latest stat
  message per MX domain.
- Implement a "smtpctl show routes" command to show the state the
  currently known routes to remote MXs.
- Implement a "smtpctl resume route" command to re-enable a route that
  has been disabled.
- Do not hardcode limits
- Minor code improvements
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.420 2013/07/19 20:37:07 eric Exp $	*/
a358 6
enum delivery_type {
	D_MDA,
	D_MTA,
	D_BOUNCE,
};

a421 12
enum envelope_flags {
	EF_AUTHENTICATED	= 0x01,
	EF_BOUNCE		= 0x02,
	EF_INTERNAL		= 0x04, /* Internal expansion forward */

	/* runstate, not saved on disk */

	EF_PENDING		= 0x10,
	EF_INFLIGHT		= 0x20,
	EF_SUSPEND		= 0x40,
};

a801 34
};

struct evpstate {
	uint64_t		evpid;
	uint16_t		flags;
	uint16_t		retry;
	time_t			time;
};

struct scheduler_info {
	uint64_t		evpid;
	enum delivery_type	type;
	uint16_t		retry;
	time_t			creation;
	time_t			expire;
	time_t			lasttry;
	time_t			lastbounce;
	time_t			nexttry;
	uint8_t			penalty;
};

#define SCHED_NONE		0x00
#define SCHED_DELAY		0x01
#define SCHED_REMOVE		0x02
#define SCHED_EXPIRE		0x04
#define SCHED_BOUNCE		0x08
#define SCHED_MDA		0x10
#define SCHED_MTA		0x20

struct scheduler_batch {
	int		 type;
	time_t		 delay;
	size_t		 evpcount;
	uint64_t	*evpids;
@


1.420
log
@Assorted queue improvements:
- cleanup the internal queue backend API and get rid of the QOP_* thing.
- implement a queue_proc backend
- rename queue_fsqueue.c to queue_fs
- enable support for queue encryption
- add an envelope cache
- better logging and error reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.419 2013/07/19 19:53:33 eric Exp $	*/
d153 1
a153 1
#define	IMSG_VERSION		3
d169 1
d180 3
d232 1
a232 3
	IMSG_MTA_BATCH,
	IMSG_MTA_BATCH_ADD,
	IMSG_MTA_BATCH_END,
d565 2
a656 1
	TAILQ_ENTRY(mta_connector)	 lst_entry;
a658 1
	struct mta_connectors		*queue;
d660 18
a677 9
#define CONNECTOR_FAMILY_ERROR	0x01
#define CONNECTOR_SOURCE_ERROR	0x02
#define CONNECTOR_MX_ERROR	0x04
#define CONNECTOR_ERROR		0x0f

#define CONNECTOR_LIMIT_HOST	0x10
#define CONNECTOR_LIMIT_ROUTE	0x20
#define CONNECTOR_LIMIT_SOURCE	0x40
#define CONNECTOR_LIMIT		0xf0
a682 2
	time_t				 nextconn;
	time_t				 clearlimit;
d687 1
d690 8
d701 2
d705 23
a727 1
TAILQ_HEAD(mta_connectors, mta_connector);
d734 1
a744 1

a750 1
	size_t			 nconnector;
d752 2
a753 6

	struct mta_connectors	 c_ready;
	struct mta_connectors	 c_limit;
	struct mta_connectors	 c_delay;
	struct mta_connectors	 c_error;
	struct event		 ev;
d761 4
a764 2
#define RELAY_WAIT_SOURCE	0x08
#define RELAY_WAITMASK		0x0f
d769 1
a770 2

	size_t			 maxconn;
d781 1
d1157 3
d1238 1
d1241 3
a1243 1
void mta_delivery(struct mta_envelope *, const char *, const char *, int, const char *);
d1425 10
@


1.419
log
@Add a table_proc backend for delegating table lookups to another
process.  Stop building experimental table_sqlite and table_ldap as
they will be provided as external backends.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.418 2013/07/19 16:02:00 eric Exp $	*/
a68 2
#define PATH_INCOMING		"/incoming"
#define PATH_MESSAGE		"/message"
d540 2
d543 2
a752 12
enum queue_op {
	QOP_CREATE,
	QOP_DELETE,
	QOP_UPDATE,
	QOP_WALK,
	QOP_COMMIT,
	QOP_LOAD,
	QOP_FD_RW,
	QOP_FD_R,
	QOP_CORRUPT,
};

a756 2
	int	(*message)(enum queue_op, uint32_t *);
	int	(*envelope)(enum queue_op, uint64_t *, char *, size_t);
a836 1

a1225 1
int queue_message_incoming_path(uint32_t, char *, size_t);
@


1.418
log
@Move the filter infrastructure forward.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.417 2013/07/19 15:14:23 eric Exp $	*/
d73 1
a291 12
};

enum table_service {
	K_NONE		= 0x00,
	K_ALIAS		= 0x01,	/* returns struct expand	*/
	K_DOMAIN	= 0x02,	/* returns struct destination	*/
	K_CREDENTIALS	= 0x04,	/* returns struct credentials	*/
	K_NETADDR	= 0x08,	/* returns struct netaddr	*/
	K_USERINFO	= 0x10,	/* returns struct userinfo	*/
	K_SOURCE	= 0x20, /* returns struct source	*/
	K_MAILADDR	= 0x40, /* returns struct mailaddr	*/
	K_ADDRNAME	= 0x80, /* returns struct addrname	*/
@


1.417
log
@scheduler improvements:
- implement suspend/resume scheduling for individual envelopes or message,
  with the associated smtpctl commands.
- allow the mta to request immediate scheduling of an envelope.
- on temporary failures a penalty can be given to further delay the next try.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.416 2013/07/19 13:41:23 eric Exp $	*/
d1165 1
a1341 2
uint32_t evpid_to_msgid(uint64_t);
uint64_t msgid_to_evpid(uint32_t);
@


1.416
log
@New implementation for smtpctl and the command line parser.  Allows
richer syntax, and makes the code way simpler to follow and extend
with new commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.415 2013/07/19 11:14:08 eric Exp $	*/
d154 1
a154 1
#define	IMSG_VERSION		2
d162 1
d166 1
d232 1
d448 1
d822 1
d856 2
d1239 1
a1239 1
void queue_tempfail(uint64_t, const char *);
d1273 1
a1273 1
void scheduler_info(struct scheduler_info *, struct envelope *);
@


1.415
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.414 2013/07/19 08:12:19 eric Exp $	*/
d1074 8
@


1.414
log
@Introduce expand string modifiers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.413 2013/07/19 07:49:08 eric Exp $	*/
a51 1
#define SMTPD_FILTER_USER	 "_smtpf"
d64 1
a553 2
	struct passwd		       *sc_pw;
	struct passwd		       *sc_pwqueue;
d770 2
d773 1
a773 1
	int	(*init)(int);
@


1.413
log
@Remove useless sc_pid from struct smtpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.412 2013/07/19 07:37:29 eric Exp $	*/
d1365 1
@


1.412
log
@get rid of sa_set_port() and its awfully contorted implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.411 2013/06/04 08:42:00 eric Exp $	*/
a531 2

	pid_t				sc_pid;
@


1.411
log
@we are at 5.3.3 now.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.410 2013/05/24 17:03:14 eric Exp $	*/
a1366 1
void sa_set_port(struct sockaddr *, int);
@


1.410
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.408 2013/03/06 21:42:40 sthen Exp $	*/
d58 1
a58 1
#define	SMTPD_VERSION		 "5.3.2"
@


1.409
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@d25 1
d31 1
d45 1
a45 2
#define MAX_PATH_SIZE		 256
/*#define MAX_RULEBUFFER_LEN	 512*/
d58 1
a58 1
#define	SMTPD_VERSION		 "5.3"
a73 10

/* number of MX records to lookup */
#define MAX_MX_COUNT		10

/* max response delay under flood conditions */
#define MAX_RESPONSE_DELAY	60

/* how many responses per state are undelayed */
#define FAST_RESPONSES		2

a96 2
typedef uint32_t	objid_t;

d98 2
a99 2
	char username[MAXLOGNAME];
	char directory[MAXPATHLEN];
a108 5
union sockaddr_any {
	struct in6_addr		in6;
	struct in_addr		in4;
};

d111 1
a111 1
	char hostname[MAXHOSTNAMELEN];
d113 5
a117 5
	char cert[PATH_MAX];
	char authtable[MAX_PATH_SIZE];
	char authlabel[MAX_PATH_SIZE];
	char sourcetable[MAX_PATH_SIZE];
	char helotable[MAX_PATH_SIZE];
d126 1
a126 1
	char	name[MAXHOSTNAMELEN];
d130 1
a130 1
	union sockaddr_any	addr;
d134 2
a135 2
	union sockaddr_any	addr;
	char			name[MAXHOSTNAMELEN];
d138 18
a244 1
	IMSG_PARENT_SEND_CONFIG,
d278 3
a303 1
	objid_t				 t_id;
d305 1
a305 2
	char				 t_src[MAX_TABLE_BACKEND_SIZE];
	char				 t_config[MAXPATHLEN];
a310 1
	void				*t_payload;
a311 1
	char				 t_cfgtable[MAXPATHLEN];
d316 2
a317 2
	int	(*config)(struct table *, const char *);
	void	*(*open)(struct table *);
d320 2
a321 2
	int	(*lookup)(void *, const char *, enum table_service, void **);
	int	(*fetch)(void *, enum table_service, char **);
d336 2
a337 1
	A_MDA
d375 2
a376 2
	char			usertable[MAX_PATH_SIZE];
	char			username[MAXLOGNAME];
d401 2
a402 1
	EXPAND_ADDRESS
d421 1
a421 1
		char		user[MAX_LOCALPART_SIZE];
d457 2
a458 2
	char				helo[MAXHOSTNAMELEN];
	char				hostname[MAXHOSTNAMELEN];
d520 1
a520 1
	char			 ssl_cert_name[PATH_MAX];
d525 1
a525 1
	char			 helo[MAXHOSTNAMELEN];
d530 1
a530 1
	char				sc_conffile[MAXPATHLEN];
d538 1
d549 2
d552 1
a552 2
#define QUEUE_COMPRESS			0x00000001
	char			       *sc_queue_compress_algo;
a555 1
	struct event			sc_ev;
d558 1
a558 2
	char				sc_hostname[MAXHOSTNAMELEN];
	struct scheduler_backend       *sc_scheduler;
d560 1
a570 1
	struct tree			       *sc_tables_tree;		/* id lookup	*/
d576 1
a576 1
#define	TRACE_VERBOSE	0x0001
d587 1
a587 1
#define	TRACE_IMSGSIZE	0x0800
d589 2
d600 1
a600 1
	char				user[MAXLOGNAME];
d603 1
a603 1
	char				directory[MAXPATHLEN];
d607 3
a609 3
	char			to[PATH_MAX];
	char			from[PATH_MAX];
	char			user[MAXLOGNAME];
d618 1
a618 1
	char			path[MAXPATHLEN];
d747 1
d781 4
a784 6
	void *	(*compress_new)(void);
	size_t	(*compress_chunk)(void *, void *, size_t, void *, size_t);
	size_t	(*compress_finalize)(void *, void *, size_t);
	void *	(*uncompress_new)(void);
	size_t	(*uncompress_chunk)(void *, void *, size_t, void *, size_t);
	size_t	(*uncompress_finalize)(void *, void *, size_t);
d838 1
a838 1
	void	(*init)(void);
d840 1
a840 1
	void	(*insert)(struct scheduler_info *);
d844 2
a845 2
	void	(*update)(struct scheduler_info *);
	void	(*delete)(uint64_t);
d847 1
a847 1
	void	(*batch)(int, struct scheduler_batch *);
d851 2
a852 2
	void	(*schedule)(uint64_t);
	void	(*remove)(uint64_t);
a908 2
#define MSZ_EVP		512

d916 9
a924 2
	struct ibuf	*ibuf;
	int		 ibuferror;
d1006 1
a1006 1
	char			name[MAXPATHLEN];
d1055 4
a1058 9
int	compress_backend_init(const char *);
void*	compress_new(void);
size_t	compress_chunk(void *, void *, size_t, void *, size_t);
size_t	compress_finalize(void *, void *, size_t);
size_t	compress_buffer(char *, size_t, char *, size_t);
void*	uncompress_new(void);
size_t	uncompress_chunk(void *, void *, size_t, void *, size_t);
size_t	uncompress_finalize(void *, void *, size_t);
size_t	uncompress_buffer(char *, size_t, char *, size_t);
d1112 1
a1133 4
/* log.c */
void vlog(int, const char *, va_list);


d1139 4
d1171 1
a1171 1
void m_create(struct mproc *, uint32_t, uint32_t, pid_t, int, size_t);
d1208 1
a1208 1
void mta_delivery(struct mta_envelope *, const char *, int, const char *);
d1299 4
d1304 1
a1304 1
void	table_update(struct table *);
d1309 3
a1311 5
int	table_lookup(struct table *, const char *, enum table_service, void **);
int	table_fetch(struct table *, enum table_service, char **);
struct table *table_find(objid_t);
struct table *table_findbyname(const char *);
struct table *table_create(const char *, const char *, const char *);
a1314 2
void table_delete_all(struct table *);
void table_replace(struct table *, struct table *);
d1319 1
a1320 4
void	table_set_payload(struct table *, void *);
void   *table_get_payload(struct table *);
void	table_set_configuration(struct table *, struct table *);
struct table	*table_get_configuration(struct table *);
d1322 2
a1323 5

void *table_config_create(void);
const char *table_config_get(void *, const char *);
void table_config_destroy(void *);
int table_config_parse(void *, const char *, enum table_type);
@


1.408
log
@as done in ospf{,6}d/relayd, sync yyerror in various other daemons with
that from bgpd, so that it logs to syslog when daemonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.407 2013/02/15 22:43:21 eric Exp $	*/
a82 3
/* max len of any smtp line */
#define	SMTP_LINE_MAX		MAX_LINE_SIZE

d137 2
a138 2
	char username[MAX_LINE_SIZE];
	char password[MAX_LINE_SIZE];
d299 1
a299 1
	char				 t_name[MAX_LINE_SIZE];
d457 1
a457 1
	char				errorline[MAX_LINE_SIZE + 1];
d522 1
a522 1
	char			 authtable[MAX_LINE_SIZE];
@


1.407
log
@add missing bits for lmtp support (from Ashish SHUKLA).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.406 2013/02/14 13:11:40 gilles Exp $	*/
d1131 4
@


1.406
log
@- log smtpd version at startup

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.405 2013/02/14 12:30:49 gilles Exp $	*/
d94 1
d107 1
@


1.405
log
@- smtpctl trace expand, enables tracing of aliases expansion
- replace "users" keyword with "userbase" when providing alternate userbase
- disambiguise expansion nodes when expanding across domains and userbases
- allow use of '=' instead of '=>' when declaring a mapping

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.404 2013/02/10 15:01:16 eric Exp $	*/
d57 1
@


1.404
log
@When getting the next batch of envelope to schedule, use an array to
store envelope ids, rather than a dynamic list.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.403 2013/02/05 15:23:40 gilles Exp $	*/
d362 1
a362 1
	struct table		       *r_users;
d412 2
d586 1
d1027 1
a1027 1
int aliases_get(struct table *, struct expand *, const char *);
d1029 1
a1029 1
int aliases_virtual_get(struct table *, struct expand *, const struct mailaddr *);
d1344 1
a1344 1

@


1.403
log
@unbreak broken smtpctl table update

fix by eric and I, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.402 2013/01/31 18:34:43 eric Exp $	*/
a815 5
struct id_list {
	struct id_list	*next;
	uint64_t	 id;
};

d828 1
a828 1
	struct id_list	*evpids;
@


1.402
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.401 2013/01/31 18:24:47 eric Exp $	*/
d727 1
a727 2
#define RELAY_WAIT_HELO		0x10
#define RELAY_WAITMASK		0x1f
d1308 1
@


1.401
log
@do not need to tweak the socket sndbuf, now that the envelopes are passed
in compressed form. reduce the default size for envelope messages.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.398 2013/01/26 09:37:23 gilles Exp $	*/
d1109 1
@


1.400
log
@use a stripped-down mta_envelope structure in the mta process.
reduces memory footprint by a great deal when relaying lots of messages.

ok gilles@@
@
text
@d909 2
a910 5
#if 1
#define MSZ_EVP	(32 + sizeof(struct envelope))
#else
#define MSZ_EVP	384
#endif
@


1.399
log
@- introduce 'smtpctl trace lookup' to trace lookup process
- improve logging of the transfer process

trace by me, logging by eric
@
text
@d738 9
d748 5
a752 5
	TAILQ_ENTRY(mta_task)	 entry;
	struct mta_relay	*relay;
	uint32_t		 msgid;
	TAILQ_HEAD(, envelope)	 envelopes;
	struct mailaddr		 sender;
d1205 1
a1205 1
void mta_delivery(struct envelope *, const char *, int, const char *);
@


1.398
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.395 2012/11/12 14:58:53 eric Exp $	*/
d580 4
a583 3
#define	TRACE_STAT	0x0100
#define	TRACE_RULES	0x0200
#define	TRACE_IMSGSIZE	0x0400
d1193 1
a1193 1
void mta_route_error(struct mta_relay *, struct mta_route *, const char *);
@


1.397
log
@Replace the qwalk API (to retreive on disk envelopes at runtime) with
a simple QOP_WALK queue operation. Some knf and formating fixes while
there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.396 2012/11/20 09:47:46 eric Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d25 1
a25 1
#include "filter_api.h"
d31 1
a31 1
#define PROC_COUNT		 9
d39 1
d44 2
a45 1
#define MAX_RULEBUFFER_LEN	 512
d51 2
a52 1
#define SMTPD_FILTER_USER	 "_smtpmfa"
d54 4
a57 1
#define SMTPD_BANNER		 "220 %s ESMTP OpenSMTPD"
a67 1
#define PATH_ENVELOPES		"/envelopes"
d70 3
d87 6
a92 6
#define F_AUTH			0x04
#define F_SSL		       (F_SMTPS|F_STARTTLS)
#define	F_STARTTLS_REQUIRE	0x08
#define	F_AUTH_REQUIRE		0x10

#define	F_BACKUP		0x20	/* XXX - MUST BE SYNC-ED WITH ROUTE_BACKUP */
d98 7
a104 6
#define ROUTE_STARTTLS		0x01
#define ROUTE_SMTPS		0x02
#define ROUTE_SSL		(ROUTE_STARTTLS | ROUTE_SMTPS)
#define ROUTE_AUTH		0x04
#define ROUTE_MX		0x08
#define ROUTE_BACKUP		0x20	/* XXX - MUST BE SYNC-ED WITH F_BACKUP */
d108 7
d120 5
d130 22
a151 1
	char authmap[MAX_PATH_SIZE];
d160 16
d179 2
a180 2
	IMSG_CONF_MAP,
	IMSG_CONF_MAP_CONTENT,
d183 4
d190 16
a205 1
	IMSG_LKA_UPDATE_MAP,
d207 1
a207 4
	IMSG_LKA_MAIL,
	IMSG_LKA_RCPT,
	IMSG_LKA_SECRET,
	IMSG_LKA_RULEMATCH,
d209 1
a209 1
	IMSG_MDA_SESS_NEW,
d212 16
a227 8
	IMSG_MFA_CONNECT,
	IMSG_MFA_HELO,
	IMSG_MFA_MAIL,
	IMSG_MFA_RCPT,
	IMSG_MFA_DATALINE,
	IMSG_MFA_QUIT,
	IMSG_MFA_CLOSE,
	IMSG_MFA_RSET,
a233 10
	IMSG_QUEUE_TEMPFAIL,
	IMSG_QUEUE_PAUSE_MDA,
	IMSG_QUEUE_PAUSE_MTA,
	IMSG_QUEUE_RESUME_MDA,
	IMSG_QUEUE_RESUME_MTA,

	IMSG_QUEUE_DELIVERY_OK,
	IMSG_QUEUE_DELIVERY_TEMPFAIL,
	IMSG_QUEUE_DELIVERY_PERMFAIL,
	IMSG_QUEUE_DELIVERY_LOOP,
d238 1
a238 9

	IMSG_SCHEDULER_MESSAGES,
	IMSG_SCHEDULER_ENVELOPES,
	IMSG_SCHEDULER_REMOVE,
	IMSG_SCHEDULER_SCHEDULE,

	IMSG_BATCH_CREATE,
	IMSG_BATCH_APPEND,
	IMSG_BATCH_CLOSE,
a242 2

	IMSG_PARENT_AUTHENTICATE,
d245 1
a245 3
	IMSG_SMTP_ENQUEUE,
	IMSG_SMTP_PAUSE,
	IMSG_SMTP_RESUME,
d249 1
d251 1
a251 1
	IMSG_DNS_PTR,
a266 14
struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	void			*data;
	int			 proc;
	short			 events;
};

struct ctl_id {
	objid_t		 id;
	char		 name[MAX_NAME_SIZE];
};

a276 5
} smtpd_process;

struct peer {
	enum smtp_proc_type	 id;
	void			(*cb)(int, short, void *);
d279 43
a321 5
enum map_src {
	S_NONE,
	S_FILE,
	S_DB /*,
	S_LDAP*/
a323 13
enum map_kind {
	K_NONE,
	K_ALIAS,
	K_VIRTUAL,
	K_CREDENTIALS,
	K_NETADDR
};	

struct mapel {
	TAILQ_ENTRY(mapel)		 me_entry;
	char				 me_key[MAX_LINE_SIZE];
	char				 me_val[MAX_LINE_SIZE];
};
d325 3
a327 31
struct map {
	TAILQ_ENTRY(map)		 m_entry;
	char				 m_name[MAX_LINE_SIZE];
	objid_t				 m_id;
	enum map_src			 m_src;
	char				 m_config[MAXPATHLEN];
	TAILQ_HEAD(mapel_list, mapel)	 m_contents;
	void				*m_handle;
};


struct map_backend {
	void *(*open)(struct map *);
	void (*update)(struct map *);
	void (*close)(void *);
	void *(*lookup)(void *, const char *, enum map_kind);
	int  (*compare)(void *, const char *, enum map_kind,
	    int (*)(const char *, const char *));
};


enum cond_type {
	COND_ANY,
	COND_DOM,
	COND_VDOM
};

struct cond {
	TAILQ_ENTRY(cond)		 c_entry;
	objid_t				 c_map;
	enum cond_type			 c_type;
d348 6
a353 3
	int				r_accept;
	struct map		       *r_sources;
	struct cond			r_condition;
d356 1
a356 1
		char			buffer[MAX_RULEBUFFER_LEN];
d361 2
a362 1
	objid_t				r_amap;
a365 5
struct mailaddr {
	char	user[MAX_LOCALPART_SIZE];
	char	domain[MAX_DOMAINPART_SIZE];
};

d369 1
a369 1
	D_BOUNCE
d372 5
a376 3
enum delivery_status {
	DS_PERMFAILURE	= 1,
	DS_TEMPFAILURE	= 2,
d379 2
a380 9
enum delivery_flags {
	DF_AUTHENTICATED	= 0x1,
	DF_BOUNCE		= 0x4,
	DF_INTERNAL		= 0x8, /* internal expansion forward */

	/* runstate, not saved on disk */

	DF_PENDING		= 0x10,
	DF_INFLIGHT		= 0x20,
d383 3
a385 4
struct delivery_mda {
	enum action_type	method;
	char			user[MAXLOGNAME];
	char			buffer[MAX_RULEBUFFER_LEN];
d388 4
a391 2
struct delivery_mta {
	struct relayhost	relay;
d418 1
a418 1
		char		buffer[MAX_RULEBUFFER_LEN];
d427 1
d432 11
a448 3
	uint64_t			session_id;
	uint64_t			batch_id;

d451 1
a451 1
	enum delivery_type		type;
d462 2
a463 1
	union delivery_method {
d466 2
a467 1
	} agent;
d469 6
a474 6
	time_t				 creation;
	time_t				 lasttry;
	time_t				 expire;
	uint16_t			 retry;
	enum delivery_flags		 flags;
	time_t				 nexttry;
d479 1
d493 1
d498 3
a500 3
	EVP_MTA_RELAY_HOST,
	EVP_MTA_RELAY_PORT,
	EVP_MTA_RELAY_FLAGS,
d502 5
a506 42
	EVP_MTA_RELAY_AUTHMAP
};


enum session_state {
	S_NEW = 0,
	S_CONNECTED,
	S_INIT,
	S_GREETED,
	S_TLS,
	S_AUTH_INIT,
	S_AUTH_USERNAME,
	S_AUTH_PASSWORD,
	S_AUTH_FINALIZE,
	S_RSET,
	S_HELO,
	S_MAIL_MFA,
	S_MAIL_QUEUE,
	S_MAIL,
	S_RCPT_MFA,
	S_RCPT,
	S_DATA,
	S_DATA_QUEUE,
	S_DATACONTENT,
	S_DONE,
	S_QUIT,
	S_CLOSE
};
#define STATE_COUNT	22

struct ssl {
	SPLAY_ENTRY(ssl)	 ssl_nodes;
	char			 ssl_name[PATH_MAX];
	char			*ssl_ca;
	off_t			 ssl_ca_len;
	char			*ssl_cert;
	off_t			 ssl_cert_len;
	char			*ssl_key;
	off_t			 ssl_key_len;
	char			*ssl_dhparams;
	off_t			 ssl_dhparams_len;
	uint8_t			 flags;
d520 2
a524 47
struct auth {
	uint64_t	 id;
	char		 user[MAXLOGNAME];
	char		 pass[MAX_LINE_SIZE + 1];
	int		 success;
};

enum session_flags {
	F_EHLO		= 0x01,
	F_8BITMIME	= 0x02,
	F_SECURE	= 0x04,
	F_AUTHENTICATED	= 0x08,
	F_WAITIMSG	= 0x10,
	F_ZOMBIE	= 0x20,
	F_KICK		= 0x40,
};

struct session {
	SPLAY_ENTRY(session)		 s_nodes;
	uint64_t			 s_id;

	struct iobuf			 s_iobuf;
	struct io			 s_io;

	enum session_flags		 s_flags;
	enum session_state		 s_state;
	struct sockaddr_storage		 s_ss;
	char				 s_hostname[MAXHOSTNAMELEN];
	struct event			 s_ev;
	struct listener			*s_l;
	struct timeval			 s_tv;
	struct envelope			 s_msg;
	short				 s_nresp[STATE_COUNT];

	char				 cmd[SMTP_LINE_MAX];
	size_t				 kickcount;
	size_t				 mailcount;
	size_t				 rcptcount;
	long				 s_datalen;

	struct auth			 s_auth;
	int				 s_dstatus;

	FILE				*datafp;
};


d529 2
d548 2
a550 5
	int			       *sc_pipes[PROC_COUNT][PROC_COUNT];
	struct imsgev		       *sc_ievs[PROC_COUNT];
	int				sc_instances[PROC_COUNT];
	int				sc_instance;
	char			       *sc_title[PROC_COUNT];
d552 1
a553 2
	struct queue_backend	       *sc_queue;
	struct compress_backend	       *sc_compress;
d559 1
a559 1
	TAILQ_HEAD(filterlist, filter)		*sc_filters;
a560 2
	TAILQ_HEAD(listenerlist, listener)	*sc_listeners;
	TAILQ_HEAD(maplist, map)		*sc_maps, *sc_maps_reload;
d562 2
a563 6
	SPLAY_HEAD(sessiontree, session)	 sc_sessions;
	SPLAY_HEAD(ssltree, ssl)		*sc_ssl;
	SPLAY_HEAD(childtree, child)		 children;
	SPLAY_HEAD(lkatree, lka_session)	 lka_sessions;
	SPLAY_HEAD(mfatree, mfa_session)	 mfa_sessions;
	LIST_HEAD(mdalist, mda_session)		 mda_sessions;
d565 5
a569 1
	uint64_t				 filtermask;
d576 11
a586 21
#define	TRACE_MTA	0x0010
#define	TRACE_BOUNCE	0x0020
#define	TRACE_SCHEDULER	0x0040
#define	TRACE_STAT	0x0080
#define	TRACE_PROFILING	0x0100


struct submit_status {
	uint64_t			 id;
	int				 code;
	union submit_path {
		struct mailaddr		 maddr;
		uint32_t		 msgid;
		uint64_t		 evpid;
		char			 errormsg[MAX_LINE_SIZE + 1];
		char			 dataline[MAX_LINE_SIZE + 1];
	}				 u;
	enum delivery_flags		 flags;
	struct sockaddr_storage		 ss;
	struct envelope			 envelope;
};
d589 2
a590 4
	uint64_t			 id;
	uint8_t				 status;
	char				 as_user[MAXLOGNAME];
};
d592 4
a595 24
enum dns_status {
	DNS_OK = 0,
	DNS_RETRY,
	DNS_EINVAL,
	DNS_ENONAME,
	DNS_ENOTFOUND,
};

struct dns {
	uint64_t		 id;
	char			 host[MAXHOSTNAMELEN];
	char			 backup[MAXHOSTNAMELEN];
	int			 port;
	int			 error;
	int			 type;
	struct imsgev		*asker;
	struct sockaddr_storage	 ss;
};

struct secret {
	uint64_t		 id;
	char			 mapname[MAX_PATH_SIZE];
	char			 host[MAXHOSTNAMELEN];
	char			 secret[MAX_LINE_SIZE];
a602 1
};
d604 1
a604 3
struct rulematch {
	uint64_t		 id;
	struct submit_status	 ss;
d608 1
a608 4
	TAILQ_ENTRY(filter)     f_entry;
	pid_t			pid;
	struct event		ev;
	struct imsgbuf		*ibuf;
d613 31
a643 3
struct mfa_session {
	SPLAY_ENTRY(mfa_session)	 nodes;
	uint64_t			 id;
d645 6
a650 4
	enum session_state		 state;
	struct submit_status		 ss;
	struct filter			*filter;
	struct filter_msg		 fm;
d653 23
a675 1
struct mta_session;
d679 11
d692 2
a693 2
	uint8_t			 flags;
	char			*hostname;
d695 2
d699 6
a704 2
	char			*auth;
	void			*ssl;
d706 12
a717 4
	/* route limits	*/
	int			 maxconn; 	/* in parallel */
	int			 maxmail;	/* per session */
	int			 maxrcpt;	/* per mail */
d719 2
a720 1
	int			 refcount;
d722 7
a728 2
	int			 ntask;
	TAILQ_HEAD(, mta_task)	 tasks;
d730 3
a732 1
	int			 nsession;
d734 1
a734 2
	int			 nfail;
	char			 errorline[64];
d739 1
a739 1
	struct mta_route	*route;
a742 21
	struct mta_session	*session;
};

/* maps return structures */
struct map_credentials {
	char username[MAX_LINE_SIZE];
	char password[MAX_LINE_SIZE];
};

struct map_alias {
	size_t			nbnodes;
	struct expand		expand;
};

struct map_virtual {
	size_t			nbnodes;
	struct expand		expand;
};

struct map_netaddr {
	struct netaddr		netaddr;
d752 1
d764 6
a769 4
	int	(*compress_file)(FILE *, FILE *);
	int	(*uncompress_file)(FILE *, FILE *);
	size_t	(*compress_buffer)(char *, size_t, char *, size_t);
	size_t	(*uncompress_buffer)(char *, size_t, char *, size_t);
a782 19
/* user structures */
enum user_type {
	USER_PWD,
};

#define	MAXPASSWORDLEN	128
struct mta_user {
	char username[MAXLOGNAME];
	char directory[MAXPATHLEN];
	char password[MAXPASSWORDLEN];
	uid_t uid;
	gid_t gid;
};

struct user_backend {
	int (*getbyname)(struct mta_user *, const char *);
};


d799 1
d801 1
d803 2
a804 2
	time_t			expire;
	uint16_t		retry;
d899 47
d947 73
a1019 1
extern void (*imsg_callback)(struct imsgev *, struct imsg *);
d1023 4
a1026 4
int aliases_get(objid_t, struct expand *, const char *);
int aliases_virtual_get(objid_t, struct expand *, const struct mailaddr *);
int aliases_vdomain_exists(objid_t, const char *);
int alias_parse(struct expandnode *, char *);
d1035 2
a1036 1
void bounce_run(uint64_t, int);
d1038 15
d1056 1
a1056 1
#define PURGE_MAPS		0x02
a1060 2
void unconfigure(void);
void configure(void);
d1062 3
a1064 2
void config_pipes(struct peer *, uint);
void config_peers(struct peer *, uint);
d1076 5
a1080 4
void dns_query_host(char *, int, uint64_t);
void dns_query_mx(char *, char *, int, uint64_t);
void dns_query_ptr(struct sockaddr_storage *, uint64_t);
void dns_async(struct imsgev *, int, struct dns *);
d1092 4
a1095 3
int envelope_ascii_dump(enum envelope_field, struct envelope *, char *, size_t);
int envelope_load_buffer(struct envelope *, char *, size_t);
int envelope_dump_buffer(struct envelope *, char *, size_t);
d1103 1
d1111 10
d1126 1
a1126 1
void lka_session(struct submit_status *);
a1129 16
/* map.c */
void *map_open(struct map *);
void  map_update(struct map *);
void  map_close(struct map *, void *);
void *map_lookup(objid_t, const char *, enum map_kind);
int map_compare(objid_t, const char *, enum map_kind,
    int (*)(const char *, const char *));
struct map *map_find(objid_t);
struct map *map_findbyname(const char *);
struct map *map_create(enum map_src, const char *);
void map_destroy(struct map *);
void map_add(struct map *, const char *, const char *);
void map_delete(struct map *, const char *);
void map_delete_all(struct map *);


d1136 1
a1136 1

d1139 48
a1186 1
void mfa_session(struct submit_status *, enum session_state);
d1191 8
a1198 9
int mta_response_delivery(const char *);
const char *mta_response_prefix(const char *);
const char *mta_response_status(const char *);
const char *mta_response_text(const char *);
void mta_route_ok(struct mta_route *);
void mta_route_error(struct mta_route *, const char *);
void mta_route_collect(struct mta_route *);
const char *mta_route_to_text(struct mta_route *);

d1201 2
a1202 2
void mta_session(struct mta_route *);
void mta_session_imsg(struct imsgev *, struct imsg *);
d1212 5
d1221 2
a1222 2
uint64_t queue_generate_evpid(uint32_t msgid);
struct queue_backend *queue_backend_lookup(const char *);
a1223 2
int queue_envelope_incoming_path(uint64_t, char *, size_t);
int queue_message_incoming_delete(uint32_t);
d1231 1
a1231 1
int queue_envelope_delete(struct envelope *);
a1236 8
/* compress_backend.c */
struct compress_backend *compress_backend_lookup(const char *);
int compress_file(FILE *, FILE *);
int uncompress_file(FILE *, FILE *);
size_t compress_buffer(char *, size_t, char *, size_t);
size_t uncompress_buffer(char *, size_t, char *, size_t);


d1253 1
a1253 2
void smtp_resume(void);
void smtp_destroy(struct session *);
d1257 3
a1259 8
void session_init(struct listener *, struct session *);
int session_cmp(struct session *, struct session *);
void session_io(struct io *, int);
void session_pickup(struct session *, struct submit_status *);
void session_destroy(struct session *, const char *);
void session_respond(struct session *, char *, ...)
	__attribute__((format (printf, 2, 3)));
SPLAY_PROTOTYPE(sessiontree, session, s_nodes, session_cmp);
d1263 9
a1271 22
void imsg_event_add(struct imsgev *);
void imsg_compose_event(struct imsgev *, uint16_t, uint32_t, pid_t,
    int, void *, uint16_t);
void imsg_dispatch(int, short, void *);
const char * proc_to_str(int);
const char * imsg_to_str(int);


/* ssl.c */
void ssl_init(void);
int ssl_load_certfile(const char *, uint8_t);
void ssl_setup(struct listener *);
void *ssl_smtp_init(void *);
void *ssl_mta_init(struct ssl *);
const char *ssl_to_text(void *);
int ssl_cmp(struct ssl *, struct ssl *);
SPLAY_PROTOTYPE(ssltree, ssl, ssl_nodes, ssl_cmp);


/* ssl_privsep.c */
int	 ssl_ctx_use_private_key(void *, char *, off_t);
int	 ssl_ctx_use_certificate_chain(void *, char *, off_t);
d1285 31
a1315 16
/* tree.c */
SPLAY_HEAD(tree, treeentry);
#define tree_init(t) SPLAY_INIT((t))
#define tree_empty(t) SPLAY_EMPTY((t))
int tree_check(struct tree *, uint64_t);
void *tree_set(struct tree *, uint64_t, void *);
void tree_xset(struct tree *, uint64_t, void *);
void *tree_get(struct tree *, uint64_t);
void *tree_xget(struct tree *, uint64_t);
void *tree_pop(struct tree *, uint64_t);
void *tree_xpop(struct tree *, uint64_t);
int tree_poproot(struct tree *, uint64_t *, void **);
int tree_root(struct tree *, uint64_t *, void **);
int tree_iter(struct tree *, void **, uint64_t *, void **);
int tree_iterfrom(struct tree *, void **, uint64_t, uint64_t *, void **);
void tree_merge(struct tree *, struct tree *);
d1318 20
a1337 2
/* user.c */
struct user_backend *user_backend_lookup(enum user_type);
a1353 1
int email_to_mailaddr(struct mailaddr *, char *);
a1355 3
char *ss_to_text(const struct sockaddr_storage *);
char *time_to_text(time_t);
char *duration_to_text(time_t);
a1362 2
uint32_t evpid_to_msgid(uint64_t);
uint64_t msgid_to_evpid(uint32_t);
a1367 2
int text_to_netaddr(struct netaddr *, const char *);
int text_to_relayhost(struct relayhost *, const char *);
d1372 1
a1379 1
uint64_t strtoevpid(const char *);
@


1.396
log
@Allow "smtpctl show queue" to run in "online" mode if the smtpd server
is running.  The scheduler sends the runtime state of each envelope to
the queue process which loads the envelope, fills the runtime bits and
sends the envelope back to the client. Iteration over the envelope set
happens in small chunks to make the request interruptible and to allow
the server to keep doing its job in the meantime.

Adpat "smtpctl schedule-all" to schedule the messages one by one using
the same iteration mechanism.

Document "smtpctl monitor" and "smtpctl show queue".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.395 2012/11/12 14:58:53 eric Exp $	*/
d35 1
a35 1
#define	DEFAULT_MAX_BODY_SIZE  	(35*1024*1024)
d49 1
a49 1
#define SMTPD_FILTER_USER      	 "_smtpmfa"
d77 6
a82 6
#define F_STARTTLS		 0x01
#define F_SMTPS			 0x02
#define F_AUTH			 0x04
#define F_SSL			(F_SMTPS|F_STARTTLS)
#define	F_STARTTLS_REQUIRE     	 0x08
#define	F_AUTH_REQUIRE		 0x10
d139 4
a142 4
 	IMSG_MFA_HELO,
 	IMSG_MFA_MAIL,
 	IMSG_MFA_RCPT,
 	IMSG_MFA_DATALINE,
d306 7
a312 7
	TAILQ_ENTRY(rule)		 r_entry;
	enum decision			 r_decision;
	char				 r_tag[MAX_TAG_SIZE];
	int				 r_accept;
	struct map			*r_sources;
	struct cond			 r_condition;
	enum action_type		 r_action;
d314 7
a320 7
		char			 buffer[MAX_RULEBUFFER_LEN];
		struct relayhost       	 relayhost;
	}				 r_value;

	struct mailaddr			*r_as;
	objid_t				 r_amap;
	time_t				 r_qexpire;
d345 1
d370 8
a377 8
	RB_ENTRY(expandnode)	 entry;
	TAILQ_ENTRY(expandnode)	 tq_entry;
	enum expand_type       	 type;
	int			 sameuser;
	int			 alias;
	struct rule		*rule;
	struct expandnode	*parent;
	unsigned int		 depth;
d383 4
a386 4
		char		 user[MAX_LOCALPART_SIZE];
		char		 buffer[MAX_RULEBUFFER_LEN];
		struct mailaddr	 mailaddr;
	} 			 u;
d561 2
a562 2
	char					 sc_conffile[MAXPATHLEN];
	size_t					 sc_maxsize;
d564 29
a592 30
#define SMTPD_OPT_VERBOSE			 0x00000001
#define SMTPD_OPT_NOACTION			 0x00000002
	uint32_t				 sc_opts;
#define SMTPD_CONFIGURING			 0x00000001
#define SMTPD_EXITING				 0x00000002
#define SMTPD_MDA_PAUSED		       	 0x00000004
#define SMTPD_MTA_PAUSED		       	 0x00000008
#define SMTPD_SMTP_PAUSED		       	 0x00000010
#define SMTPD_MDA_BUSY			       	 0x00000020
#define SMTPD_MTA_BUSY			       	 0x00000040
#define SMTPD_BOUNCE_BUSY      		       	 0x00000080
#define SMTPD_SMTP_DISABLED			 0x00000100
	uint32_t				 sc_flags;
	uint32_t				 sc_queue_flags;
#define QUEUE_COMPRESS				 0x00000001
	char					*sc_queue_compress_algo;
	int					 sc_qexpire;
	struct event				 sc_ev;
	int					 *sc_pipes[PROC_COUNT]
							[PROC_COUNT];
	struct imsgev				*sc_ievs[PROC_COUNT];
	int					 sc_instances[PROC_COUNT];
	int					 sc_instance;
	char					*sc_title[PROC_COUNT];
	struct passwd				*sc_pw;
	char					 sc_hostname[MAXHOSTNAMELEN];
	struct queue_backend			*sc_queue;
	struct compress_backend			*sc_compress;
	struct scheduler_backend		*sc_scheduler;
	struct stat_backend			*sc_stat;
a759 1
	QOP_INVALID=0,
d763 1
d771 3
a773 7
	int (*init)(int);
	int (*message)(enum queue_op, uint32_t *);
	int (*envelope)(enum queue_op, uint64_t *, char *, size_t);

	void *(*qwalk_new)(uint32_t);
	int   (*qwalk)(void *, uint64_t *);
	void  (*qwalk_close)(void *);
d790 1
a790 1
	int (*authenticate)(char *, char *);
d815 2
a816 2
	int			allow_root;
	void (*open)(struct deliver *);
d989 1
d997 1
d1005 1
d1010 1
a1014 1

d1050 1
d1055 1
d1060 1
d1064 1
d1082 2
a1083 3
void *qwalk_new(uint32_t);
int   qwalk(void *, uint64_t *);
void  qwalk_close(void *);
d1100 1
d1106 1
d1112 1
d1120 1
a1120 2
	__attribute__ ((format (printf, 2, 3)));

a1153 1

d1192 1
a1192 1
	__attribute__ ((format (printf, 3, 4)));
d1230 1
@


1.395
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.391 2012/10/28 08:46:26 eric Exp $	*/
d167 2
d342 5
a346 1
	DF_INTERNAL		= 0x8 /* internal expansion forward */
d428 1
d823 7
d871 2
d1171 1
@


1.394
log
@Add a "kick counter" that gets incremented on each command, to detect
clients that don't do their best to do something useful, and just hog
the session.  When that kick counter reaches the limit, the client is
disconnected.  The counter is reset after the first HELO/EHLO command,
after tls is established, after a succesful authentication, and after
a message is accepted. It is decremented when a RCPT is accepted.

ok gilles@@
@
text
@a56 2
#define	DIRHASH_BUCKETS		 4096

d194 1
a249 6
enum mapel_type {
	ME_STRING,
	ME_NET,
	ME_NETMASK
};

d252 2
a253 4
	union mapel_data {
		char			 med_string[MAX_LINE_SIZE];
	}				 me_key;
	union mapel_data		 me_val;
a259 1
	enum mapel_type			 m_eltype;
d333 2
a334 2
	DS_PERMFAILURE	= 0x1,
	DS_TEMPFAILURE	= 0x2,
d538 2
a571 1
	struct timeval				 sc_qintval;
d895 19
d1027 1
d1119 1
d1204 2
a1205 1
void log_envelope(const struct envelope *, const char *, const char *);
@


1.393
log
@Consistency and robustness improvements in mda:

- Introduce a mda_getlastline function(); improve the code to avoid
  useless allocations and string formatting; make it return the last
  line with content (skip trailing empty lines if found).
- Add a mechanism by which the mda can request the parent to abort a
  local delivery by killing the process.
- Use ioev/iobuf for draining data to the delivery process.
- Make sure to catch all transient errors and make them result in a
  tempfail rather than calling fatal().
- Make sure that the envelope status is properly set for all failures.
- Stop using SMTP response codes; it makes no sense in this context.

ok gilles@@
@
text
@d529 1
d548 1
@


1.392
log
@Make counters more informative in the scheduler:

- Change the scheduler backend API a bit: commit() and rollback()
  API calls return the number of envelopes added or canceled; put
  the number of envelopes in the structure returned by batch().

- Properly report the number of incoming, registered, removed and
  expired envelopes, as well as the outcome of deliveries.

ok gilles@@
@
text
@d178 1
@


1.391
log
@Limit the number of messages that can be enqueued on a single SMTP
connection, and the number of recipients in each of them.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.390 2012/10/16 12:02:23 eric Exp $	*/
d847 1
d855 2
a856 2
	void	(*commit)(uint32_t);
	void	(*rollback)(uint32_t);
@


1.390
log
@MAX_RULEBUFFER_LEN is too small, bump it.

discussed with gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.389 2012/10/14 11:58:23 gilles Exp $	*/
d546 1
@


1.389
log
@introduce map_file.c which will deprecate map_stdio.c

The idea is to have a file-backed map but to have smtpd(8) cache the maps
so that it cannot be partially read if edited while mail is received. The
file is read and converted to a static map (map_static.c), changes aren't
visible to smtpd until an explicit: smtpctl update map  which reads file,
builds a new static map and invalidates the former.

partial-read issue discussed with beck@@ and halex@@
idea to convert internally to a static map by eric@@

diff ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.388 2012/10/12 08:51:02 eric Exp $	*/
d43 1
a43 1
#define MAX_RULEBUFFER_LEN	 256
@


1.388
log
@Extend the "retry" field to 16 bits.  The new quadratic retry formula
makes the maximum retry delay a bit to small on 8 bits.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.387 2012/10/11 21:43:11 gilles Exp $	*/
d129 3
d136 1
d237 1
a237 1
	S_PLAIN,
d272 1
d278 1
d981 4
d991 1
d993 2
@


1.387
log
@- map_create() takes a map_src not a map_kind

ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.386 2012/10/11 21:14:32 gilles Exp $	*/
d423 1
a423 1
	uint8_t				 retry;
d821 1
a821 1
	uint8_t			retry;
@


1.386
log
@- replace "from all" and "for all" with "from any" and "for any"

ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.385 2012/10/10 20:29:46 gilles Exp $	*/
d980 1
a980 1
struct map *map_create(enum map_kind, const char *);
@


1.385
log
@F_BACKUP and ROUTE_BACKUP must be sync-ed for now, otherwise smtpd won't
work as a backup MX ...

bug experienced by todd, verified and analyzed by eric
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.384 2012/10/10 19:39:11 gilles Exp $	*/
d281 3
a283 3
	C_ALL,
	C_DOM,
	C_VDOM
@


1.384
log
@teach smtpctl how to display envelopes and messages using their id.
this allows an admin to inspect the queue without having to manually
extract bucket and find the path to an envelope or message.

diff by Sunil Nimmagadda <sunil@@poolp.org>

ok eric@@, chl@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.383 2012/10/10 18:02:37 eric Exp $	*/
d86 1
a86 1
#define	F_BACKUP		0x20	/* XXX */
d97 1
a97 1
#define ROUTE_BACKUP		0x10	/* XXX */
@


1.383
log
@For each alias node, mark if it has been expanded from an alias map or
from a .forward file.  Local deliveries for files and filters expanded
from an alias map are run as user _smtpd.

issue reported by tood@@

ok gilles@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.382 2012/10/09 20:33:02 gilles Exp $	*/
d1178 1
@


1.382
log
@- allow a listen statement to impose tls on its clients;
- make listen statements impose authentication if 'auth' is specified and
	to make it optional if 'auth-optional' is specified;
- sync documentation accordingly

with ideas and input from beck@@ and halex@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.381 2012/10/08 20:35:16 gilles Exp $	*/
d370 1
d388 1
@


1.381
log
@disk space is cheap but we still want to limit the default size of a body
to a sane default for everyone.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.380 2012/10/07 17:21:37 eric Exp $	*/
d83 2
d86 1
a86 1
#define	F_BACKUP		0x10	/* XXX */
@


1.380
log
@Implement a simple wait queue API.  The idea is to allow multiple "waiters"
to wait on the same "tag" for a deferred result.

A waiter is a callback and a void *argument.  The first waiter (the one for
which waitq_wait() returns true) is supposed to run some code that leads to
waitq_run() being run, which will destroy that waitq and call all callbacks
in turn.

Not used at the moment, but will be soon.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.379 2012/10/07 15:46:38 chl Exp $	*/
d35 1
@


1.379
log
@convert iobuf_queue()'s to iobuf_fqueue(). (idea from gilles@@)
introduce iobuf_xinit() and iobuf_xfqueue(). (idea from eric@@)

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.378 2012/10/03 19:42:16 gilles Exp $	*/
d1173 4
@


1.378
log
@we reintroduced a bug that was fixed 2 years ago with the aliases rewrite:

During the entire expansion process, a username may be larger than
MAXLOGNAME because it may be an alias going through another expansion.
We should use a buffer that's large enough to fit a mailaddr user-part so
we avoid hitting a truncation check leading to a fatal().

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.377 2012/10/03 17:58:03 gilles Exp $	*/
d1167 2
@


1.377
log
@disallow root deliveries for "deliver to filename" and "deliver to mda"
rules, we only allow them for mbox and maildir though users should really
create a root alias ...

discussed with eric@@ and chl@@, ok both
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.376 2012/09/30 14:28:16 gilles Exp $	*/
d371 5
a375 1
		char		 user[MAXLOGNAME];
@


1.376
log
@- add decision to the rule so that we can actually perform a reject match
  ie:

	reject from 192.168.1.0/24 for domain "openbsd.org"
	accept from 192.168.0.0/16 for domain "openbsd.org" deliver to mbox

it was documented but not working.

ok eric@@ & chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.375 2012/09/29 11:02:41 eric Exp $	*/
d802 2
a803 1
	void	(*open)(struct deliver *);
@


1.375
log
@some mfa_session cleanups.

- move mfa_session() prototype to smtpd.h
- make mfa session use a tree
- make static functions static
- merge mfa_session_init() into mfa_session()

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.374 2012/09/29 10:35:01 eric Exp $	*/
d298 5
d305 1
@


1.374
log
@finally remove rule member from struct envelope.

"wow!" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.373 2012/09/29 10:32:08 eric Exp $	*/
d974 5
a978 2
int mfa_session_cmp(struct mfa_session *, struct mfa_session *);
SPLAY_PROTOTYPE(mfatree, mfa_session, nodes, mfa_session_cmp);
@


1.373
log
@Remove support for "as user" for local deliveries.
It's not documented and not implemented.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.372 2012/09/28 17:28:30 eric Exp $	*/
a382 1
	struct rule			rule;
@


1.372
log
@some smtpd.{c,h} cleanups:

- move struct child to smtpd.c
- make it use a tree keyed on the pid
- change child_add to take the title directly as a const char *
- remove useless child_lookup() and child_del()
- remove CHILD_INVALID

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.371 2012/09/28 13:40:21 eric Exp $	*/
a309 1
	char				*r_user;
@


1.371
log
@Move mda_session to mda.c, and make it use a tree instead of a list,
but still use uint32_t keys since ithe key is used as peerid in msg.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.370 2012/09/28 12:00:09 eric Exp $	*/
a440 17
enum child_type {
	CHILD_INVALID,
	CHILD_DAEMON,
	CHILD_MDA,
	CHILD_ENQUEUE_OFFLINE,
};

struct child {
	SPLAY_ENTRY(child)	 entry;
	pid_t			 pid;
	enum child_type		 type;
	enum smtp_proc_type	 title;
	int			 mda_out;
	uint32_t		 mda_id;
	char			*path;
};

a1058 1
int	 child_cmp(struct child *, struct child *);
a1064 1
SPLAY_PROTOTYPE(childtree, child, entry, child_cmp);
@


1.370
log
@smtpd.h/control.c cleanups:

- move session_socket_* prototypes under util.c
- move struct ctl_conn in control.c
- make static functions static
- remove unused functions
- call unlink() in control_shutdown()
- make control_close() take a ctl_conn * instead of a fd

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.369 2012/09/27 18:57:25 eric Exp $	*/
a662 9
};

struct mda_session {
	LIST_ENTRY(mda_session)	 entry;
	struct envelope		 msg;
	struct msgbuf		 w;
	struct event		 ev;
	uint32_t		 id;
	FILE			*datafp;
@


1.369
log
@clarify the alias expansion code.

The session manages a list of nodes to process. A node has a link to the
parent node from which it has been expanded, and a link to the rule that
led to its creation. Depending on its type and the associated rule, each
node is either "expanded" to create new nodes or "submitted" to create a
final envelope.  Nodes which have already been seen, either processed or
not, are discarded to avoid loops.

The expansion process is bootstrapped by creating an EXPAND_ADDRESS node
from the original dest, with no rule and no parent.  It is done when all
nodes have been expanded or if an error occurs before.  The expand depth
is limited 5 levels.  The whole expansion fails if the limit is reached.

While there, make sure that only one .forward file is queried at a time,
and only append the subfolder tag in the maildir case.

Fixe issues with some virtual map setups where the dest would get mixed
up, and make the whole expansion process generally easier to follow.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.368 2012/09/26 19:52:20 eric Exp $	*/
a205 8
struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	 entry;
	uint8_t			 flags;
#define CTL_CONN_NOTIFY		 0x01
	struct imsgev		 iev;
};
TAILQ_HEAD(ctl_connlist, ctl_conn);

a941 3
void session_socket_blockmode(int, enum blockmodes);
void session_socket_no_linger(int);
int session_socket_error(int);
d1184 3
@


1.368
log
@Stop using the delivery_data union (field "to") in delivery_mda.
It's confusing and not necessary as it's only used for "buffer".
Instead, just add a "buffer" member in the structure and rename
"as_user" to "user".

The delivery_data union becomes an anonymous union in expandnode,
which is the only other place where it's used.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.367 2012/09/25 17:38:55 eric Exp $	*/
d353 1
a353 1
	struct relayhost relay;
d366 7
a372 4
	RB_ENTRY(expandnode)	entry;
	int			done;
	enum expand_type       	type;
	char			as_user[MAXLOGNAME];
d374 4
a377 4
		char		user[MAXLOGNAME];
		char		buffer[MAX_RULEBUFFER_LEN];
		struct mailaddr	mailaddr;
	} u;
d381 4
a384 2
	RB_HEAD(expandtree, expandnode)	tree;
	char				user[MAXLOGNAME];
a644 1
	struct envelope			 envelope;
@


1.367
log
@make const arguments const, and static functions static.

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.366 2012/09/21 19:37:08 eric Exp $	*/
a345 6
union delivery_data {
	char user[MAXLOGNAME];
	char buffer[MAX_RULEBUFFER_LEN];
	struct mailaddr mailaddr;
};

d348 2
a349 2
	union delivery_data	to;
	char			as_user[MAXLOGNAME];
d370 5
a374 1
	union delivery_data    	u;
@


1.366
log
@Do not pass the username to forwards_get() which does not have to care about
this.  Instead, set the username on the expand context, and copy it on the
expand nodes as they are inserted.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.365 2012/09/21 16:40:20 eric Exp $	*/
d824 1
a824 1
	int (*getbyname)(struct mta_user *, char *);
@


1.365
log
@wrap expandtree into a "struct expand".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.364 2012/09/21 13:23:07 eric Exp $	*/
d381 1
d985 1
a985 1
int forwards_get(int, struct expand *, const char *);
@


1.364
log
@move struct lka_session definition in lka_session.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.363 2012/09/21 12:33:32 eric Exp $	*/
d379 3
a381 1
RB_HEAD(expandtree, expandnode);
d757 1
a757 1
	struct expandtree	expandtree;
d762 1
a762 1
	struct expandtree	expandtree;
d916 2
a917 2
int aliases_get(objid_t, struct expandtree *, const char *);
int aliases_virtual_get(objid_t, struct expandtree *, const struct mailaddr *);
d978 3
a980 3
void expand_insert(struct expandtree *, struct expandnode *);
struct expandnode *expand_lookup(struct expandtree *, struct expandnode *);
void expand_free(struct expandtree *);
d984 1
a984 1
int forwards_get(int, struct expandtree *, const char *);
@


1.363
log
@Add a log_envelope() function that log envelope status in a uniform way.
It automagically adds an rcpt=<user@@domain> field if "dest" differs from
the original "rcpt". The function takes an "extra" parameter that allows
to add some specific info depending on the context.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.362 2012/09/21 10:22:29 eric Exp $	*/
a686 17
};

enum lka_session_flags {
	F_ERROR		= 0x1
};

struct lka_session {
	SPLAY_ENTRY(lka_session)	 nodes;
	uint64_t			 id;

	TAILQ_HEAD(, envelope)		 deliverylist;
	struct expandtree		 expandtree;

	uint8_t				 iterations;
	uint32_t			 pending;
	enum lka_session_flags		 flags;
	struct submit_status		 ss;
@


1.362
log
@Move ruleset_match() prototype to smtpd.h and make the envelope const.
Adapt a lot of functions in chain to use const args where required.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.361 2012/09/20 14:28:57 eric Exp $	*/
d1206 1
@


1.361
log
@constify parameters that are supposed to be const.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.360 2012/09/19 18:20:36 eric Exp $	*/
d279 3
a281 2
	void *(*lookup)(void *, char *, enum map_kind);
	int  (*compare)(void *, char *, enum map_kind, int (*)(char *, char *));
d1010 3
a1012 2
void *map_lookup(objid_t, char *, enum map_kind);
int map_compare(objid_t, char *, enum map_kind, int (*)(char *, char *));
d1077 5
d1179 1
a1179 1
int hostname_match(char *, char *);
d1183 1
a1183 1
char *ss_to_text(struct sockaddr_storage *);
d1200 2
a1201 2
int text_to_netaddr(struct netaddr *, char *);
int text_to_relayhost(struct relayhost *, char *);
@


1.360
log
@Remove DF_ENQUEUE flag. It is mostly unused and logically broken.
Ignore it in existing envelopes until it gets completely dropped.
Change "smtpctl show queue" to display the address family of the
envelope source instead of the ENQUEUE flag.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.359 2012/09/19 11:57:35 eric Exp $	*/
d930 3
a932 3
int aliases_get(objid_t, struct expandtree *, char *);
int aliases_virtual_get(objid_t, struct expandtree *, struct mailaddr *);
int aliases_vdomain_exists(objid_t, char *);
d998 1
a998 1
int forwards_get(int, struct expandtree *, char *);
d1180 2
a1181 2
int  lowercase(char *, char *, size_t);
void xlowercase(char *, char *, size_t);
@


1.359
log
@remove IS_RELAY and IS_MAILBOX macros.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.358 2012/09/19 10:10:30 eric Exp $	*/
a340 1
	DF_ENQUEUED		= 0x2,
@


1.358
log
@Remove aliases_exists() and aliases_virtual_exists(). The corresponding
*_get() functions can be called directly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.357 2012/09/19 09:06:35 eric Exp $	*/
a303 3

#define IS_MAILBOX(x)	((x).r_action == A_MAILDIR || (x).r_action == A_MBOX || (x).r_action == A_FILENAME)
#define IS_RELAY(x)	((x).r_action == A_RELAY || (x).r_action == A_RELAYVIA)
@


1.357
log
@start cleaning the expansion code:

- change expandtree_* prefix to expand_ for better readability and
  because the structure might change at some point
- rename <>_free_nodes() to <>_free()
- remove unused <>_remove_node()
- refcounting has no purpose at all; just remove it as well as the
  decrement/increment functions, and replace the latter with <>_insert
- expandnode flags is only used to know if it's been processed or not,
  don't make it a flag but a simple field with clear name.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.356 2012/09/18 14:23:01 eric Exp $	*/
a933 1
int aliases_exist(objid_t, char *);
d935 1
a936 2
int aliases_virtual_exist(objid_t, struct mailaddr *);
int aliases_virtual_get(objid_t, struct expandtree *, struct mailaddr *);
@


1.356
log
@- add xmemdup() helper.
- remove useless block in switch.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.355 2012/09/18 13:42:39 eric Exp $	*/
a373 5
enum expand_flags {
	F_EXPAND_NONE,
	F_EXPAND_DONE
};

d376 1
a376 2
	size_t			refcnt;
	enum expand_flags      	flags;
d998 3
a1000 5
void expandtree_increment_node(struct expandtree *, struct expandnode *);
void expandtree_decrement_node(struct expandtree *, struct expandnode *);
void expandtree_remove_node(struct expandtree *, struct expandnode *);
struct expandnode *expandtree_lookup(struct expandtree *, struct expandnode *);
void expandtree_free_nodes(struct expandtree *);
a1001 1

@


1.355
log
@simple lka cleanups:

- fix lka* function prototypes in smtpd.h
- make static functions static
- merge lka_session_init() into lka_session()
- make lka_session.c use tree.c to store sessions

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.354 2012/09/18 13:13:43 eric Exp $	*/
d1213 1
@


1.354
log
@this structure is not useful and ill-named. remove it.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.353 2012/09/18 12:13:22 eric Exp $	*/
a1017 2
int lka_session_cmp(struct lka_session *, struct lka_session *);
SPLAY_PROTOTYPE(lkatree, lka_session, nodes, lka_session_cmp);
d1020 2
a1021 4
struct lka_session *lka_session_init(struct submit_status *);
void lka_session_fail(struct lka_session *);
void lka_session_destroy(struct lka_session *);

@


1.353
log
@remove C_NET. it's not used and there is no plan for it at the moment.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.352 2012/09/17 20:19:18 eric Exp $	*/
a423 1
TAILQ_HEAD(deliverylist, envelope);
d706 1
a706 1
	struct deliverylist		 deliverylist;
@


1.352
log
@Add map_create() and map_add() helpers.  Simplify the config parser by a
great deal.

While there, rename the default "localhost" map to "<localhost>" to make
it look more internal, and create a single "<anyhost>" map referenced by
"from all" rules, instead of creating a dynamic one for each of them.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.351 2012/09/16 16:54:55 chl Exp $	*/
a285 1
	C_NET,
@


1.351
log
@now that log_imsg() is only used in smtpd.c, set it as static.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.350 2012/09/16 15:55:55 chl Exp $	*/
d1034 2
@


1.350
log
@silent warnings

reported by ajacoutot@@

ok gilles@@ ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.349 2012/09/16 11:53:57 gilles Exp $	*/
a1206 1
void log_imsg(int, int, struct imsg*);
@


1.349
log
@replace BSD-licensed mkdir_p() with ISC-licensed mkdirs(), this allows us
to avoid a dual-licensed util.c for no reason

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.348 2012/09/14 19:22:04 eric Exp $	*/
d819 2
a820 2
	size_t	(*compress_buffer)(const char *, size_t, char *, size_t);
	size_t	(*uncompress_buffer)(const char *, size_t, char *, size_t);
d1091 2
a1092 2
size_t compress_buffer(const char *, size_t, char *, size_t);
size_t uncompress_buffer(const char *, size_t, char *, size_t);
@


1.348
log
@Remove s_ssl from the smtp session since it is duplicated in the io struct.
Change ssl_session_init to ssl_smtp_init and make it simpler:  only create
an SSL* from the SSL_CTX* passed as parameter, so it does not have to know
about the struct session itself.  Kill some dead prototypes while there.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.347 2012/09/11 08:37:52 eric Exp $	*/
d1189 1
a1189 1
int mkdir_p(char *, mode_t);
@


1.347
log
@Rework the scheduler internals.  Fix some scheduling loop issues and
handle envelope scheduling/expiration better.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.346 2012/09/01 16:25:27 gilles Exp $	*/
a553 1
	void				*s_ssl;
a1131 3
void ssl_transaction(struct session *);
void ssl_session_init(struct session *);
void ssl_session_destroy(struct session *);
d1134 2
a1136 1
void *ssl_mta_init(struct ssl *);
@


1.346
log
@remove unused flag
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.345 2012/09/01 16:09:14 gilles Exp $	*/
d897 1
a897 1
	void	(*batch)(int, time_t, struct scheduler_batch *);
@


1.345
log
@- remove crypto_backend
- remove support for encrypted queue, it will be reintroduced later after
  pouring more thinking into it

if you had it enabled, flush your queue before updating
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.344 2012/08/30 21:59:46 chl Exp $	*/
a586 1
#define QUEUE_ENCRYPT				 0x00000002
@


1.344
log
@change crypto_setup() prototype to use const char * instead of uint8_t *

while there do some KNF:
- change 8 spaces to tab
- add/remove some missing/extra space after if's

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.343 2012/08/30 19:33:25 chl Exp $	*/
a588 3
	char					*sc_queue_crypto_cipher;
	char					*sc_queue_crypto_digest;
	char					*sc_queue_crypto_key;
a979 9


/* crypto_backend.c */
int	crypto_setup(const char *, const char *, const char *);
void	crypto_clear(void);
int	crypto_encrypt_file(FILE *, FILE *);
int	crypto_decrypt_file(FILE *, FILE *);
size_t	crypto_encrypt_buffer(const char *, size_t, char *, size_t);
size_t	crypto_decrypt_buffer(const char *, size_t, char *, size_t);
@


1.343
log
@switch compress_backend to use FILE * instead of file descriptors, like
crypto_backend

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.342 2012/08/30 18:25:44 gilles Exp $	*/
d986 1
a986 1
int	crypto_setup(uint8_t *, uint8_t *, uint8_t *);
@


1.342
log
@- import latest aldap.[ch] and ber.[ch] from ypldap
- revive map_ldap.c by updating it to the current API

diff by Mathieu Masson who played puzzle with an oooold changeset of mine,
this import is to let us work on it in tree, it won't work as is.

idea ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.341 2012/08/29 16:26:17 gilles Exp $	*/
d822 2
a823 2
	int	(*compress_file)(int, int);
	int	(*uncompress_file)(int, int);
d1103 2
a1104 2
int compress_file(int, int);
int uncompress_file(int, int);
@


1.341
log
@Introduce the crypto_backend API and provide support for... encrypted queue
using the new API. By default, OpenSMTPD does not provide queue encryption,
but it can be enabled with "queue encryption [args]" and will transparently
encrypt/decrypt envelopes/messages as they hit the queue.

By default, it will use Blowfish in CBC mode with a different random IV for
each envelope and message. User provided key is expanded using sha256 but a
different cipher and digest may be specified in smtpd.conf

Queue encryption is compatible with compression and if both options are set
it will do them in correct order and transparently.

tested by chl@@, a few users and myself
ok chl@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.340 2012/08/28 14:03:49 chl Exp $	*/
d239 2
a240 1
	S_DB
@


1.340
log
@remove encrypt.c prototypes leftovers

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.339 2012/08/26 11:52:48 gilles Exp $	*/
d588 3
a590 2
	char					*sc_queue_encrypt_cipher;
	char					*sc_queue_encrypt_key;
d982 9
@


1.339
log
@- define ZLIB_BUFFER_SIZE instead of hardcoding 8192
- check gzdopen() failure
- call gzclose() whenever a failure occurs after gzdopen()
- simplify slightly some checks in compress/uncompress
- create PATH_TEMPORARY in /var/spool/smtpd, chmod 700, owned by _smtpd
- compress_zlib should use PATH_TEMPORARY instread of /tmp as we're
	chrooted and this will otherwise lead to a fatal()

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.338 2012/08/25 23:35:09 chl Exp $	*/
a1095 6

/* encrypt.c */
int encrypt_file(int, int);
int decrypt_file(int, int);
size_t encrypt_buffer(const char *, size_t, char *, size_t);
size_t decrypt_buffer(const char *, size_t, char *, size_t);
@


1.338
log
@Add compress_backend, allowing compression of messages and envelopes in the queue.
To use it, just add "queue compress" in smtpd.conf. For now, only zlib is used.

lots of feedback from eric@@ and gilles@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.337 2012/08/25 22:03:26 gilles Exp $	*/
d61 1
@


1.337
log
@- add myself to the copyright in control.c, i've done quite a few changes
there in the last few years ;-)
- get rid of availdesc(): getdtablecount() is so much more reliable
- get rid of env->sc_maxconn, we can be much smarter with getdtablecount()
	and getdtablesize()
- disable accept when we hit the control process fd reserve
- disable accept when we fail
- enable accept when we're back below the limit

this is not the full fd exhaustion diff, i'll merge changes from relayd
tomorrow, this was only required to get rid of the env->sc_maxconn and
availdesc() mess

"reads alright" eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.336 2012/08/25 21:33:33 gilles Exp $	*/
d583 6
d601 1
d818 6
d1089 13
d1221 1
@


1.336
log
@- stop accepting clients if we hit our fd reserve limit (or if we fail)
- resume if we go below the fd reserve

with feedback and ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.335 2012/08/25 15:39:11 gilles Exp $	*/
a584 1
	uint32_t				 sc_maxconn;
@


1.335
log
@- offline enqueue does not need to use the user_backend API, it relies on
	system users ... use getpwuid() instead of ub->getbyuid()
- since that was the only caller, get rid of user_backend->getbyuid()

this is the first step towards removing the user_backend API and making
user lookups available through the maps API (yes, virtual user support ;)

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.334 2012/08/25 11:38:18 gilles Exp $	*/
d581 1
@


1.334
log
@- introduce TRACE_PROFILING
- when smtpd starts with -T profiling it will log_trace() some prof. info
- when smtpd starts with -T profstat, it will push them to stats API with
	type STAT_TIMESPEC under key profiling.imsg.*

with this diff we can get live profiling of events with a very minimal
overhead :-)

ok chl@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.333 2012/08/25 10:23:12 gilles Exp $	*/
a838 1
	int (*getbyuid)(struct mta_user *, uid_t);
@


1.333
log
@- introduce struct stat_value
- statistics can now have a type (counter, timestamp, timeval, timespec and
  possibly others in the future)
- stat_increment() / stat_decrement() now take an increment/decrement value
  and are at the moment only of type counter
- stat_set() now takes a stat_value
- provide helpers to convert raw values to stat_value

ok eric@@, ok chl@@

while at it fix a rq_queue_dump() call using a bogus timestamp in scheduler
ramqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.332 2012/08/24 13:21:56 chl Exp $	*/
d623 1
@


1.332
log
@In envelope ascii dump/load:
- remove loading of evpid.
- don't dump the msgid
- ignore msgid at load
- remove now unused functions ascii_{dump,load}_uint{32,64}_hex()

With inputs from eric@@ and gilles@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.331 2012/08/24 13:13:13 chl Exp $	*/
d892 17
d913 1
a913 1
	size_t	val;
d919 4
a922 4
	void	(*increment)(const char *);
	void	(*decrement)(const char *);
	void	(*set)(const char *, size_t);
	int	(*iter)(void **, char **, size_t *);
d1131 8
a1138 3
void	stat_increment(const char *);
void	stat_decrement(const char *);
void	stat_set(const char *, size_t);
@


1.331
log
@Don't pass struct envelope pointer in queue backend API, instead use envelope id and
an envelope ascii buffer.

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.330 2012/08/24 12:29:50 eric Exp $	*/
a426 1
	EVP_ID,
@


1.330
log
@Remove the rq_host and rq_batch structures from the ramqueue scheduler.
The scheduler should only allow admin to schedule specific envelopes by
id, or msgid. More advanced scheduling (per host/route/whatever) should
be achieved using smtpctl schedule-id and proper filtering on the queue,
or using ad-hoc scheduler backend and tools.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.329 2012/08/21 20:19:46 eric Exp $	*/
d804 1
a804 1
	int (*envelope)(enum queue_op, struct envelope *);
a1035 1

a1038 1

a1058 1

@


1.329
log
@Allow smtpd to work as a backup MX, relaying only to MXs with higher
priority in the DNS record. For example:

   accept for domain "foo.org" relay backup "mx3.foo.org"

will relay mails for "foo.org" using only hosts with higher priority
(i.e. lower value) than "mx3.foo.org", which is supposed to be the
current server.

If the specified backup MX is not found in the DNS record, relaying
works as normal.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.328 2012/08/21 13:13:17 eric Exp $	*/
a849 2
	char			destination[MAXHOSTNAMELEN];

@


1.328
log
@Re-enable loop detection, but in mta and mda this time.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.327 2012/08/20 21:14:17 gilles Exp $	*/
d82 2
d93 1
d659 1
a664 1
	struct dns		*next;
d739 1
d961 1
a961 1
void dns_query_mx(char *, int, uint64_t);
@


1.327
log
@MAX_LINE_SIZE is supposed to define the max length of a SMTP line ...
... but SMTP_LINE_MAX *also* defines it ... with a different value ...
and did I mention both were too small anyway ?

quick fix until we kill one or the other: bump MAX_LINE_SIZE and define
SMTP_LINE_MAX to be MAX_LINE_SIZE. this fixes the immediate issue while
we decide which one bites the dust.

fixes the crashes and "line too long" errors spotted by todd@@
ok todd@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.326 2012/08/19 14:16:58 chl Exp $	*/
d152 1
@


1.326
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.325 2012/08/19 10:32:32 chl Exp $	*/
d37 1
a37 4
/* SYNC WITH filter.h		  */
//#define MAX_LINE_SIZE		 1000
//#define MAX_LOCALPART_SIZE	 128
//#define MAX_DOMAINPART_SIZE	 MAXHOSTNAMELEN
d75 1
a75 1
#define	SMTP_LINE_MAX		1000
@


1.325
log
@Kill envelope_{dump,load}_file() and replace them with envelope_{dump,load}_buffer().

with input from eric@@

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.324 2012/08/19 08:45:44 chl Exp $	*/
d95 1
a95 1
typedef u_int32_t	objid_t;
d103 1
a103 1
	u_int8_t flags;
d105 1
a105 1
	u_int16_t port;
d206 1
a206 1
	u_int8_t		 flags;
d395 2
a396 2
	u_int64_t			session_id;
	u_int64_t			batch_id;
d398 2
a399 2
	u_int32_t			version;
	u_int64_t			id;
d419 1
a419 1
	u_int8_t			 retry;
d465 1
a465 1
	u_int32_t		 mda_id;
d506 1
a506 1
	u_int8_t		 flags;
d510 1
a510 1
	u_int8_t		 flags;
d524 1
a524 1
	u_int64_t	 id;
d541 1
a541 1
	u_int64_t			 s_id;
d572 1
a572 1
	u_int32_t				 sc_opts;
d581 1
a581 1
	u_int32_t				 sc_flags;
d584 1
a584 1
	u_int32_t				 sc_maxconn;
d612 1
a612 1
	u_int64_t				 filtermask;
d626 1
a626 1
	u_int64_t			 id;
d630 2
a631 2
		u_int32_t		 msgid;
		u_int64_t		 evpid;
d641 2
a642 2
	u_int64_t			 id;
	u_int8_t			 status;
d656 1
a656 1
	u_int64_t		 id;
d667 1
a667 1
	u_int64_t		 id;
d678 1
a678 1
	u_int32_t		 id;
d690 1
a690 1
	u_int64_t		 id;
d700 1
a700 1
	u_int64_t			 id;
d705 2
a706 2
	u_int8_t			 iterations;
	u_int32_t			 pending;
d722 1
a722 1
	u_int64_t			 id;
d801 1
a801 1
	int (*message)(enum queue_op, u_int32_t *);
d804 2
a805 2
	void *(*qwalk_new)(u_int32_t);
	int   (*qwalk)(void *, u_int64_t *);
d847 1
a847 1
	u_int64_t		evpid;
d854 1
a854 1
	u_int8_t		retry;
d880 2
a881 2
	void	(*commit)(u_int32_t);
	void	(*rollback)(u_int32_t);
d884 1
a884 1
	void	(*delete)(u_int64_t);
d888 2
a889 2
	void	(*schedule)(u_int64_t);
	void	(*remove)(u_int64_t);
d938 1
a938 1
void purge_config(u_int8_t);
d942 2
a943 2
void config_pipes(struct peer *, u_int);
void config_peers(struct peer *, u_int);
d958 3
a960 3
void dns_query_host(char *, int, u_int64_t);
void dns_query_mx(char *, int, u_int64_t);
void dns_query_ptr(struct sockaddr_storage *, u_int64_t);
d1042 2
a1043 2
u_int32_t queue_generate_msgid(void);
u_int64_t queue_generate_evpid(u_int32_t msgid);
d1045 9
a1053 9
int queue_message_incoming_path(u_int32_t, char *, size_t);
int queue_envelope_incoming_path(u_int64_t, char *, size_t);
int queue_message_incoming_delete(u_int32_t);
int queue_message_create(u_int32_t *);
int queue_message_delete(u_int32_t);
int queue_message_commit(u_int32_t);
int queue_message_fd_r(u_int32_t);
int queue_message_fd_rw(u_int32_t);
int queue_message_corrupt(u_int32_t);
d1056 1
a1056 1
int queue_envelope_load(u_int64_t, struct envelope *);
d1058 2
a1059 2
void *qwalk_new(u_int32_t);
int   qwalk(void *, u_int64_t *);
d1091 2
a1092 2
void imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t, pid_t,
    int, void *, u_int16_t);
d1104 1
a1104 1
int ssl_load_certfile(const char *, u_int8_t);
d1147 3
a1149 3
	char    **list;
	u_int   num;
	u_int   nalloc;
d1168 1
a1168 1
u_int64_t generate_uid(void);
d1171 2
a1172 2
u_int32_t evpid_to_msgid(u_int64_t);
u_int64_t msgid_to_evpid(u_int32_t);
@


1.324
log
@fix an issue where too long lines were not spot properly.

issue reported by todd@@

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.323 2012/08/18 20:52:36 eric Exp $	*/
d974 2
a975 2
int envelope_load_file(struct envelope *, FILE *);
int envelope_dump_file(struct envelope *, FILE *);
@


1.323
log
@zap struct mta_batch. Only pass ids where needed.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.322 2012/08/18 18:18:23 gilles Exp $	*/
d38 1
a38 1
//#define MAX_LINE_SIZE		 1024
d78 1
a78 1
#define	SMTP_LINE_MAX		1024
@


1.322
log
@- introduce stat_backend, an API for pluggable statistic backends
  > statistics are no longer static structures in shared memory
  > statistics are only set, smtpd never uses them in its logic
  > each statistic is a key/value where key can be any (dynamic) string
- convert all uses of the former API to use the new one
- implement stat_ramstat that keeps non-persistent stats in ram structure

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.321 2012/08/18 15:45:12 eric Exp $	*/
a765 7
};

struct mta_batch {
	u_int64_t		id;
	struct relayhost	relay;

	u_int32_t		msgid;
@


1.321
log
@Major update of the mta internals.

Add a mta_route structure which describes a route through which
outgoing mails are to be sent.  This structure holds connection
parameters and limits.  When an envelope is received in a batch,
the route for it is looked up, and the envelope is added to the
a list of envelope to be sent for this message on that route: a
task.  When the batch is closed, each task is added to the list
of tasks for their respective route.

The routes are drained when new work can happen. The route will
create new mta sessions if necessary.  When a session is up and
ready, it picks the first pending task on the route if any.  In
the other case, it just closes the connection.

Errors on the connection are reported to the route, so that the
route could be flagged as broken.  Currently, three errors on a
an attempt to open a route is reported as a failure for all pen-
ding tasks.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.320 2012/08/10 11:05:55 eric Exp $	*/
a172 1
	IMSG_STATS,
d180 8
a187 1
	IMSG_DNS_PTR
d596 3
a611 1
	struct stats				*stats;
d622 1
a623 67
enum {
	STATS_SMTP_SESSION = 0,
	STATS_SMTP_SESSION_INET4,
	STATS_SMTP_SESSION_INET6,
	STATS_SMTP_SMTPS,
	STATS_SMTP_STARTTLS,

	STATS_MTA_SESSION,

	STATS_MDA_SESSION,

	STATS_CONTROL_SESSION,

	STATS_LKA_SESSION,
	STATS_LKA_SESSION_MX,
	STATS_LKA_SESSION_HOST,
	STATS_LKA_SESSION_CNAME,
	STATS_LKA_FAILURE,

	STATS_SCHEDULER,
	STATS_SCHEDULER_BOUNCES,

	STATS_QUEUE_LOCAL,
	STATS_QUEUE_REMOTE,

	STATS_RAMQUEUE_ENVELOPE,
	STATS_RAMQUEUE_MESSAGE,
	STATS_RAMQUEUE_BATCH,
	STATS_RAMQUEUE_HOST,

	STATS_MAX,
};

#define STAT_COUNT	0
#define STAT_ACTIVE	1
#define STAT_MAXACTIVE	2

struct	stat_counter {
	size_t	count;
	size_t	active;
	size_t	maxactive;
};

struct s_parent {
	time_t		start;
};

struct s_session {
	size_t		read_error;
	size_t		read_timeout;
	size_t		read_eof;
	size_t		write_error;
	size_t		write_timeout;
	size_t		write_eof;
	size_t		toofast;
	size_t		tempfail;
	size_t		linetoolong;
	size_t		delays;
};

struct stats {
	struct s_parent		 parent;
	struct s_session	 mta;
	struct s_session	 smtp;

	struct stat_counter	 counters[STATS_MAX];
};
d899 18
d1081 1
a1081 1

d1122 6
a1127 5
/* stats.c */
void	stat_init(struct stat_counter *, int);
size_t	stat_get(int, int);
size_t	stat_increment(int);
size_t	stat_decrement(int);
@


1.320
log
@Move mta and smtp specific defines into their own files.
Some formatting cleanups while there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.319 2012/08/09 16:00:31 eric Exp $	*/
d88 7
d788 38
d1067 7
d1076 1
@


1.319
log
@Allow failure reports for different recipients of the same message
to be grouped into a single bounce message.

The bounce structure keeps a list of envelopes.  For now, the list
is constructed by delaying the re-enqueuing of a bounce envelope a
bit, to wait for other bounces from the same message to be part of
the same report.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.318 2012/08/09 11:52:32 eric Exp $	*/
a87 9
#define ADVERTISE_TLS(s) \
	((s)->s_l->flags & F_STARTTLS && !((s)->s_flags & F_SECURE))

#define ADVERTISE_AUTH(s) \
	((s)->s_l->flags & F_AUTH && (s)->s_flags & F_SECURE && \
	 !((s)->s_flags & F_AUTHENTICATED))

		

a779 35

enum mta_state {
	MTA_INIT,
	MTA_SECRET,
	MTA_DATA,
	MTA_MX,
	MTA_CONNECT,
	MTA_DONE,
	MTA_SMTP_READY,
	MTA_SMTP_BANNER,
	MTA_SMTP_EHLO,
	MTA_SMTP_HELO,
	MTA_SMTP_STARTTLS,
	MTA_SMTP_AUTH,
	MTA_SMTP_MAIL,
	MTA_SMTP_RCPT,
	MTA_SMTP_DATA,
	MTA_SMTP_QUIT,
	MTA_SMTP_BODY,
	MTA_SMTP_DONE,
	MTA_SMTP_RSET,
};

/* mta session flags */
#define	MTA_FORCE_ANYSSL	0x01
#define	MTA_FORCE_SMTPS		0x02
#define	MTA_ALLOW_PLAIN		0x04
#define	MTA_USE_AUTH		0x08
#define	MTA_FORCE_MX		0x10
#define	MTA_USE_CERT		0x20
#define	MTA_TLS			0x40

#define MTA_EXT_STARTTLS     0x01
#define MTA_EXT_AUTH         0x02
#define MTA_EXT_PIPELINING   0x04
@


1.318
log
@remove unused function and prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.317 2012/08/09 09:48:02 eric Exp $	*/
d974 3
a976 2
int bounce_session(int, struct envelope *);
void bounce_event(int, short, void *);
@


1.317
log
@Improve the message flows to completely isolate operations on the
queue backend within the queue process.

The scheduler sends envelope ids to the queue process which loads
the envelope and forward the request to the agent responsible for
the delivery.  The result is sent by the agent to the queue which
updates the storage before notifying the scheduler.

Bounces are created and enqueued (from the client side) by the
queue process, rather than the scheduler.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.316 2012/08/08 17:33:55 eric Exp $	*/
a974 1
int bounce_session_switch(FILE *, enum session_state *, char *, struct envelope *);
a975 1
int bounce_record_message(struct envelope *, struct envelope *);
@


1.316
log
@remove useless defines

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.315 2012/08/08 08:50:42 eric Exp $	*/
a158 1
	IMSG_QUEUE_SCHEDULE,
d160 1
a167 1
	IMSG_BATCH_DONE,
a325 1
	D_INVALID = 0,
a1077 2
void queue_submit_envelope(struct envelope *);
void queue_commit_envelopes(struct envelope *);
@


1.315
log
@Improve the scheduler backend API.

New envelopes are pushed into the scheduler through the insert()
commit() rollback() transactional interface functions.

Worklists are pulled from the scheduler through a single batch()
interface function, which returns a list of envelope ids and the
type of processing. Envelopes returned in this batch are said to
be "in-flight", as opposed to "pending". They are supposed to be
processed in some way, and either updated() or deleted() at some
point.

The schedule()/remove() functions are used to alter the internal
state of "pending" envelopes to make them schedulable.  The enve-
lopes will be part of a worklist on the next call to batch().

Rewrite the scheduler_ramqueue backend.

The initial queue loading in now done by the queue.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.314 2012/08/07 21:47:57 eric Exp $	*/
a27 7

#define IMSG_SIZE_CHECK(p) do {					\
		if (IMSG_DATA_SIZE(&imsg) != sizeof(*p))	\
			fatalx("bad length imsg received");	\
	} while (0)
#define IMSG_DATA_SIZE(imsg)	((imsg)->hdr.len - IMSG_HEADER_SIZE)

@


1.314
log
@Implement a set of tree_* functions for storing arbitrary pointers in splay
trees with uint64_t keys. Also add x{m,c}alloc and xstrdup helpers.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.313 2012/07/29 17:21:43 gilles Exp $	*/
d6 1
d920 2
a921 2
	u_int64_t	evpid;
	char		destination[MAXHOSTNAMELEN];
d930 19
a950 3
	int	(*setup)(void);

	int	(*next)(u_int64_t *, time_t *);
d953 2
a954 2
	void	(*schedule)(u_int64_t);
	void	(*remove)(u_int64_t);
d956 2
a957 5
	void	*(*host)(char *);
	void	*(*message)(u_int32_t);
	void	*(*batch)(u_int64_t);
	void	*(*queue)(void);
	void	 (*close)(void *);
d959 1
a959 2
	int	 (*fetch)(void *, u_int64_t *);
	int	 (*force)(u_int64_t);
d961 2
a962 1
	void	 (*display)(void);	/* may be NULL */
a964 2


a1114 1
void message_reset_flags(struct envelope *);
d1116 1
a1116 2

/* scheduler.c */
d1119 1
a1119 1

d1212 1
@


1.313
log
@- introduce xlowercase() and allow lowercase() to fail gracefully
- replace all calls to lowercase() with calls to xlowercase()
- in the format string expansion, lowercase() all formats

we will have to reassess all calls to xlowercase() even though it has never
triggered as far as I know, we can probably gracefully fail some of them.
right now we're just keeping former behaviour.

this commit fixes issue reported by Hugo Osvaldo Barrera where a %u format
could lead to a delivery failure (ie: GILLES@@openbsd.org should be expanded
to gilles, not GILLES ... only for local deliveries).

ok chl@@ on the idea, ok eric@@ on the diff
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.312 2012/07/29 16:33:01 eric Exp $	*/
d1162 17
d1218 3
@


1.312
log
@get rid of A_INVALID.
little code cleanup while here.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.311 2012/07/29 13:56:24 eric Exp $	*/
d1186 2
a1187 1
void lowercase(char *, char *, size_t);
@


1.311
log
@remove the session tree from the global env and move it to mta_session.c,
along with mta_relay and mta_session definition.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.310 2012/07/12 08:51:43 chl Exp $	*/
a297 1
	A_INVALID,
a307 1
#define IS_EXT(x)	((x).r_action == A_EXT)
@


1.310
log
@add support for maildir tagging/folders.

ok gilles@@
ok eric@@ on previous versions of this patch
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.309 2012/07/10 23:21:34 chl Exp $	*/
a612 1
	SPLAY_HEAD(mtatree, mta_session)	 mta_sessions;
a830 9
struct mta_relay {
	TAILQ_ENTRY(mta_relay)	 entry;
	struct sockaddr_storage	 sa;
	char			 fqdn[MAXHOSTNAMELEN];
	int			 used;
};

struct mta_task;

a833 21

struct mta_session {
	SPLAY_ENTRY(mta_session) entry;
	u_int64_t		 id;
	enum mta_state		 state;
	char			*host;
	int			 port;
	int			 flags;
	TAILQ_HEAD(,mta_relay)	 relays;
	char			*authmap;
	char			*secret;
	FILE			*datafp;

	TAILQ_HEAD(,mta_task)	 tasks;

	struct envelope		*currevp;
	struct iobuf		 iobuf;
	struct io		 io;
	int			 ext; /* extension */
	struct ssl		*ssl;
};
@


1.309
log
@backout the:
- remove the /envelopes subdirectory, envelopes are at the same level than
  the message file
- kill PATH_ENVELOPES define

but keep the:
- reduce the number of buckets from 0xfff to 0xff, this avoid performances
  of the queue to decrease when we start having tons of buckets

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.308 2012/07/10 16:11:43 chl Exp $	*/
d1210 1
a1216 2
int valid_message_id(char *);
int valid_message_uid(char *);
@


1.308
log
@accept address literal for the recipient domain.
while there, change valid_{local,domain}part() prototypes to use const char *.

with input from gilles@@ and eric@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.307 2012/07/10 11:13:40 gilles Exp $	*/
d71 1
@


1.307
log
@- simplify the scheduler loop logic further, it is ridiculously simple now
  and I don't think we can do much better (at that level) :-p
- always break out of the handler after processing an envelope, this will
  avoid a busy scheduler from not getting a chance to handle SIGTERM/SIGINT
  YES we can now ctrl-c a maaaaad scheduler !

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.306 2012/07/09 17:57:54 gilles Exp $	*/
d1212 2
a1213 2
int valid_localpart(char *);
int valid_domainpart(char *);
@


1.306
log
@- introduce log_trace(TRACE_SCHEDULER, ...)
- simplify a tiny tiny bit the scheduler loop
- no functional change (yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.305 2012/07/09 09:57:53 gilles Exp $	*/
d963 1
a963 1
	int	(*setup)(time_t, time_t);
@


1.305
log
@- runner is the terminology we used back when we had runqueues, we no
  longer have them and runner is actually a scheduler so rename.
- introduce scheduler_backend which does the same to scheduler than
  queue_backend does to queue and map_backend does to maps
- remove all occurences of RUNNER and runner, replace them with SCHEDULER
  and scheduler

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.304 2012/07/09 08:08:29 gilles Exp $	*/
d625 1
@


1.304
log
@first step of simplifying fsqueue:

- remove the /envelopes subdirectory, envelopes are at the same level than
  the message file
- kill PATH_ENVELOPES define
- reduce the number of buckets from 0xfff to 0xff, this avoid performances
  of the queue to decrease when we start having tons of buckets

this diff introduces a change to the queue layout, you will want to empty
your queue before updating. more cleanup to come

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.303 2012/07/08 18:13:08 chl Exp $	*/
d167 2
a168 2
	IMSG_RUNNER_REMOVE,
	IMSG_RUNNER_SCHEDULE,
d228 1
a228 1
	PROC_RUNNER,
d645 2
a646 2
	STATS_RUNNER,
	STATS_RUNNER_BOUNCES,
d1132 2
a1133 2
/* runner.c */
pid_t runner(void);
@


1.303
log
@remove enum queue_kind from queue_fsqueue.c.
incoming messages are now always stored in /incoming, whatever the queue_backend is.
remove QOP_FD_RW and fsqueue_message_fd_rw().
while there check return value of generated paths before calling rmtree()

with advice from gilles@@ and eric@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.302 2012/07/02 17:00:05 eric Exp $	*/
a70 1
#define PATH_ENVELOPES		"/envelopes"
@


1.302
log
@Lookup queue and scheduler backends by name, rather than enum.
Add a command-line option to specify the backend to use at runtime.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.301 2012/06/20 20:45:23 eric Exp $	*/
d70 3
a899 1
	QOP_FD_RW,
d1115 3
@


1.301
log
@Finally get rid of the queue_kind enum in the queue API. Keep that
internally in fsqueue backend for now, and let the fsqueue_message()
and fsqueue_envelope() dispatchers do the right thing.

Based on a diff by chl@@

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.300 2012/06/17 15:17:08 gilles Exp $	*/
a888 6
/* queue structures */
enum queue_type {
	QT_INVALID=0,
	QT_FS
};

a947 6

/* scheduler_backend */
enum scheduler_type {
	SCHED_RAMQUEUE,
};

d1112 1
a1112 1
struct queue_backend *queue_backend_lookup(enum queue_type);
d1134 1
a1134 1
struct scheduler_backend *scheduler_backend_lookup(enum scheduler_type);
@


1.300
log
@- introduce struct scheduler_info and the scheduler_info() function to fill
  a struct scheduler_info given a struct envelope
- adapt the scheduler API and the scheduler_ramqueue backend to use the new
  struct scheduler_info instead of a struct envelope

idea discussed with eric@@ and chl@@, mechanical diff, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.299 2012/06/14 21:56:13 gilles Exp $	*/
a894 6
enum queue_kind {
	Q_INCOMING,
	Q_QUEUE,
	Q_CORRUPT
};

d909 2
a910 2
	int (*message)(enum queue_kind, enum queue_op, u_int32_t *);
	int (*envelope)(enum queue_kind, enum queue_op, struct envelope *);
d912 1
a912 1
	void *(*qwalk_new)(enum queue_kind, u_int32_t);
d1125 11
a1135 11
int queue_message_create(enum queue_kind, u_int32_t *);
int queue_message_delete(enum queue_kind, u_int32_t);
int queue_message_commit(enum queue_kind, u_int32_t);
int queue_message_fd_r(enum queue_kind, u_int32_t);
int queue_message_fd_rw(enum queue_kind, u_int32_t);
int queue_message_corrupt(enum queue_kind, u_int32_t);
int queue_envelope_create(enum queue_kind, struct envelope *);
int queue_envelope_delete(enum queue_kind, struct envelope *);
int queue_envelope_load(enum queue_kind, u_int64_t, struct envelope *);
int queue_envelope_update(enum queue_kind, struct envelope *);
void *qwalk_new(enum queue_kind, u_int32_t);
@


1.299
log
@- rename filter.h -> filter_api.h to be consistent with upcoming changes
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.298 2012/06/03 19:52:56 eric Exp $	*/
d966 11
d983 1
a983 1
	void	(*insert)(struct envelope *);
d1153 1
@


1.298
log
@Do not store the envelope id within the envelope, only the message id.
Make sure existing envelopes can be properly loaded.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.297 2012/06/01 10:40:14 chl Exp $	*/
d24 1
a24 1
#include "filter.h"
@


1.297
log
@remove unused fields

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.296 2012/06/01 09:24:58 eric Exp $	*/
d430 1
@


1.296
log
@move envelope dump/load functions to envelope.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.295 2012/05/29 19:53:10 gilles Exp $	*/
a564 2
	int				 mboxfd;
	int				 messagefd;
@


1.295
log
@- introduce map_static.c as a backend to static maps in parse.y, this has
  the benefit that we no longer have two code paths whenever we deal with
  maps, we can always use the backend mechanism.

I have not plugged this in yet, I'll do it in a later commit, just get it
out of my sandbox
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.294 2012/05/29 19:29:44 gilles Exp $	*/
d1055 3
a1057 3
int envelope_ascii_dump(enum envelope_field, struct envelope *, char *,
    size_t);

@


1.294
log
@- introduce text_to_relayhost() which converts an url into a relayhost.
  urls are of the form: [schema://]host[:ip]

not used, yet other commits are following ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.293 2012/05/13 00:10:49 gilles Exp $	*/
d274 1
a274 1
	void *(*open)(char *);
@


1.293
log
@- cleanup parse.y by removing lots of code that should not have been there,
  but in ruleset.c and util.c instead.

- introduce the new map_compare() map API call to allow iterating over keys
  and comparing them with provided key using provided function. this allows
  checking a partial key in a key set, very useful for comparing an address
  to a set of netmask.

- introduce new map kind K_NETADDR
- implement K_NETADDR for map_db and map_stdio
- teach ruleset checking how to use the map_compare() with K_NETADDR

we can now do the following:

   map "srcaddr" source plain "/etc/mail/srcaddr.txt"

   accept from map srcaddr for domain "openbsd.org" [...]
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.292 2012/05/12 21:49:31 gilles Exp $	*/
d1234 1
@


1.292
log
@- remove unused sources S_EXT, S_DYN and S_EXT from enum map_src
- continue simplification of parse.y
- remove "for network", if we ever need it we can reimport, probably no
  one knows of that undocumented strange feature ;-)
- change syntax for virtual domains configuration:

	  accept for virtual vmap	[...] <- wrong
	  accept for virtual map vmap	[...] <- right

  the reason for this change is that we will soon implement relay rules
  through maps and that keeping that syntax would make it inconsistent
  with the other rules.

- update man pages for makemap and smtpd.conf to reflect changes

ok eric@@, looks ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.291 2012/05/12 18:41:10 gilles Exp $	*/
d244 2
a245 1
	K_CREDENTIALS
a257 1
		struct netaddr		 med_addr;
d277 1
d886 3
d1086 1
d1233 1
@


1.291
log
@- simplify a bit maps by removing fields which are still unused years
  after the initial ambitious implementation: byebye map type & map flags

- simplify a bit parse.y by removing assignations to these otherwise unused
  fields

- remove the DNS map source, it may be a good idea, but we can just add it
  when we plan to implement it (if we do)

- make the { } options in map declaration, it's been annoying me for a long
  time now, this allows the following to work:

       map "foobar" source plain "/etc/mail/foobar"

- update smtpd.conf.5 accordingly ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.290 2012/05/12 17:41:27 eric Exp $	*/
a235 2
	S_DYN,
	S_DNS,
d237 1
a237 2
	S_DB,
	S_EXT
@


1.290
log
@Update the internal mta implementation so that a session now has a
list of messages to send to the remote smtp server over the same
connection. It's not currently used as the scheduler/runner is not
aware of this yet, and the imsg protocol would need to be updated.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.289 2012/05/12 15:29:16 gilles Exp $	*/
a233 6
enum map_type {
	T_SINGLE,
	T_LIST,
	T_HASH
};

a266 3
#define F_USED				 0x01
#define F_DYNAMIC			 0x02
	u_int8_t			 m_flags;
a268 1
	enum map_type			 m_type;
@


1.289
log
@- rename all occurences of K_SECRET to K_CREDENTIALS
- rename all occurences of struct map_secret to map_credentials
- do not fatal if the credentials map has disappeared, instead make the
  auth fail with a lookup failure. the mail will be temporary failed so
  it stays in queue until admin fixes smtpd.conf, removes mail, or lets
  it expires
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.288 2012/05/11 12:12:02 eric Exp $	*/
d829 1
a860 1
	TAILQ_HEAD(,envelope)	 recipients;
d865 2
@


1.288
log
@split the session logic off mta.c into mta_session.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.287 2012/03/07 22:54:49 gilles Exp $	*/
d253 1
a253 1
	K_SECRET
d881 1
a881 1
struct map_secret {
@


1.287
log
@various reliability fixes:

- prevent queue_fsqueue from fatal() when it hits an ENOENT, it can happen
- change a bit the scheduler API to simplify it, fix runner accordingly

- we can't remove msg/batch from ramqueue while envelope is offloaded or
  it will cause a double, instead we add refcnt to both msg/batch and
  only free them when it hits 0
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.286 2012/01/31 21:05:26 gilles Exp $	*/
a1107 2
int mta_session_cmp(struct mta_session *, struct mta_session *);
SPLAY_PROTOTYPE(mtatree, mta_session, entry, mta_session_cmp);
d1109 2
@


1.286
log
@fix an issue observed this week-end while flooding ajacoutot@@ :

we keep track of available fd's to prevent scheduling of messages if we
know that we are going to fail. however, since the envelope is not
removed from the scheduler, it will be rescheduled right away leading to
a busy loop in the scheduler. we know flag the mda/mta processes as BUSY
and do not schedule envelopes that target a BUSY process.

also, fix a potential bug that could lead to a use after free when doing
a batch/message/host traversal of schedulable envelopes.

while at it fix misuse of env->sc_opts as env->sc_flags, was not really
causing any issue as the misuse was constant ...
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.285 2012/01/29 11:37:32 eric Exp $	*/
d981 2
a982 1
	void	(*remove)(void *, u_int64_t);
d991 1
a991 1
	int	 (*schedule)(u_int64_t);
@


1.285
log
@Rewrite io code in smtp and mta using the iobuf/ioev interface to have
a better separation between io and protocol logic.  As a side-effect,
it fixes a couple of long-standing issues in the io path, and
hopefully add fresh ones instead.  Kill client.c in the process.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.284 2012/01/28 16:50:02 gilles Exp $	*/
d594 3
d981 1
a981 1
	void	(*remove)(u_int64_t);
@


1.284
log
@add optional display handler to scheduler_backend, if not NULL the handler
will be called for each iteration of the runner

implement a display handler for scheduler_ramqueue to display the entire
ramqueue (hosttree, msgtree and linear queue) in log_debug
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.283 2012/01/28 15:11:06 eric Exp $	*/
d25 2
d545 6
a550 8
	F_EHLO		= 0x1,
	F_QUIT		= 0x2,
	F_8BITMIME	= 0x4,
	F_SECURE	= 0x8,
	F_AUTHENTICATED	= 0x10,
	F_PEERHASTLS	= 0x20,
	F_PEERHASAUTH	= 0x40,
	F_WRITEONLY	= 0x80
d557 3
a561 1
	int				 s_fd;
a564 1
	struct bufferevent		*s_bev;
a566 2
	u_char				*s_buf;
	int				 s_buflen;
d813 13
a825 3
	MTA_PTR,
	MTA_PROTOCOL,
	MTA_DONE
d835 1
d844 6
a860 1
	int			 fd;
d862 5
a866 2
	struct event		 ev;
	void			*pcb;
d1155 1
d1157 1
a1157 1
void session_destroy(struct session *);
d1160 1
a1160 1
void session_bufferevent_new(struct session *);
d1183 1
@


1.283
log
@remove useless state

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.282 2012/01/28 11:33:07 gilles Exp $	*/
d970 2
@


1.282
log
@- introduce the scheduler_backend API
- introduce the scheduler_ramqueue backend
- remove all occurences of ramqueue outside of the ramqueue backend
- teach runner how to use the new API

it is now possible to write custom schedulers !

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.281 2012/01/24 12:20:18 eric Exp $	*/
a808 1
	MTA_INVALID_STATE,
@


1.281
log
@Add a parameter to the queue backend init() call to specify wether the
call is issued by smtpd or smtpctl.  In the latter case, only perform
sanity checks and do not touch directories.  A running server no
longer lose its "incoming/" directory each time smtpctl is called...

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.280 2012/01/18 13:41:54 chl Exp $	*/
a582 37
/* ram-queue structures */
struct ramqueue_host {
	RB_ENTRY(ramqueue_host)		hosttree_entry;
	TAILQ_HEAD(,ramqueue_batch)	batch_queue;
	u_int64_t			h_id;
	char				hostname[MAXHOSTNAMELEN];
};
struct ramqueue_batch {
	TAILQ_ENTRY(ramqueue_batch)	batch_entry;
	TAILQ_HEAD(,ramqueue_envelope)	envelope_queue;
	enum delivery_type		type;
	u_int64_t			h_id;
	u_int64_t			b_id;
	u_int32_t      			msgid;
	struct relayhost		relay;
};
struct ramqueue_envelope {
	TAILQ_ENTRY(ramqueue_envelope)	 queue_entry;
	TAILQ_ENTRY(ramqueue_envelope)	 batchqueue_entry;
	RB_ENTRY(ramqueue_envelope)	 evptree_entry;
	struct ramqueue_batch		*rq_batch;
	struct ramqueue_message		*rq_msg;
	struct ramqueue_host		*rq_host;
	u_int64_t      			 evpid;
	time_t				 sched;
};
struct ramqueue_message {
	RB_ENTRY(ramqueue_message)		msgtree_entry;
	RB_HEAD(evptree, ramqueue_envelope)	evptree;
	u_int32_t				msgid;
};
struct ramqueue {
	RB_HEAD(hosttree, ramqueue_host)	hosttree;
	RB_HEAD(msgtree, ramqueue_message)	msgtree;
	TAILQ_HEAD(,ramqueue_envelope)		queue;
};

a607 1
	struct ramqueue				 sc_rqueue;
d609 1
d853 6
d949 24
a1118 35
/* ramqueue.c */
void ramqueue_init(struct ramqueue *);
int ramqueue_load(struct ramqueue *, time_t *);
int ramqueue_host_cmp(struct ramqueue_host *, struct ramqueue_host *);
int ramqueue_msg_cmp(struct ramqueue_message *, struct ramqueue_message *);
int ramqueue_evp_cmp(struct ramqueue_envelope *, struct ramqueue_envelope *);
int ramqueue_is_empty(struct ramqueue *);
int ramqueue_is_empty(struct ramqueue *);
int ramqueue_batch_is_empty(struct ramqueue_batch *);
int ramqueue_host_is_empty(struct ramqueue_host *);
void ramqueue_remove_batch(struct ramqueue_host *, struct ramqueue_batch *);
void ramqueue_remove_host(struct ramqueue *, struct ramqueue_host *);
struct ramqueue_envelope *ramqueue_envelope_by_id(struct ramqueue *, u_int64_t);
struct ramqueue_envelope *ramqueue_first_envelope(struct ramqueue *);
struct ramqueue_envelope *ramqueue_next_envelope(struct ramqueue *);
struct ramqueue_envelope *ramqueue_batch_first_envelope(struct ramqueue_batch *);
void ramqueue_insert(struct ramqueue *, struct envelope *, time_t);
int ramqueue_message_is_empty(struct ramqueue_message *);
void ramqueue_remove_message(struct ramqueue *, struct ramqueue_message *);

struct ramqueue_host *ramqueue_lookup_host(struct ramqueue *, char *);
struct ramqueue_message *ramqueue_lookup_message(struct ramqueue *, u_int32_t);
struct ramqueue_envelope *ramqueue_lookup_envelope(struct ramqueue *, u_int64_t);

void ramqueue_schedule(struct ramqueue *, u_int64_t);
void ramqueue_schedule_envelope(struct ramqueue *, struct ramqueue_envelope *);

void ramqueue_remove_envelope(struct ramqueue *, struct ramqueue_envelope *);


RB_PROTOTYPE(hosttree, ramqueue_host, hosttree_entry, ramqueue_host_cmp);
RB_PROTOTYPE(msgtree,  ramqueue_message, msg_entry, ramqueue_msg_cmp);
RB_PROTOTYPE(evptree,  ramqueue_envelope, evp_entry, ramqueue_evp_cmp);


d1122 4
a1125 3
void runner_schedule(struct ramqueue *, u_int64_t);
void runner_remove(struct ramqueue *, u_int64_t);
void runner_remove_envelope(struct ramqueue *, struct ramqueue_envelope *);
@


1.280
log
@Add new filters callbacks for:
- network events (CONNECT/CLOSE)
- commands (QUIT/RSET)

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.279 2012/01/13 21:58:35 eric Exp $	*/
d933 1
a933 1
	int (*init)(void);
@


1.279
log
@queue_message_purge() and queue_message_delete() are actually the same
thing. Remove queue_message_purge() in favor of queue_message_delete
and simplify fsqueue_message_delete() implementation to move the
message dir to purge/

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.278 2012/01/13 14:27:55 eric Exp $	*/
d135 8
a142 4
	IMSG_MFA_HELO,
	IMSG_MFA_MAIL,
	IMSG_MFA_RCPT,
	IMSG_MFA_DATALINE,
d482 2
a483 1
	S_INVALID = 0,
d491 1
d502 2
a503 1
	S_QUIT
d505 1
a505 1
#define STATE_COUNT	19
@


1.278
log
@remove the status field from struct envelope, move it to the smtp
session, and cleanup the DS_* flags.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.277 2012/01/13 14:01:58 eric Exp $	*/
a921 1
	QOP_PURGE,
a1108 1
int queue_message_purge(enum queue_kind, u_int32_t);
@


1.277
log
@Stop using envelope->status to report delivery outcome to the
runner/queue.  Instead, replace IMSG_QUEUE_MESSAGE_UPDATE with three
messages:

- IMSG_QUEUE_DELIVERY_OK
- IMSG_QUEUE_DELIVERY_TEMPFAIL
- IMSG_QUEUE_DELIVERY_PERMFAIL

1) it's less confusing as status is also used by smtp
2) it's easier to see what happens just looking at imsg traces
3) it makes the code path generally easier to follow
4) it's safer because it enforces clear semantics and intent, whereas
   the status field is loosely defined and could carry bogus values.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.276 2012/01/12 20:59:07 eric Exp $	*/
d345 2
a346 4
	DS_PERMFAILURE	= 0x2,
	DS_TEMPFAILURE	= 0x4,
	DS_REJECTED	= 0x8,
	DS_ACCEPTED	= 0x10
a429 2
	enum delivery_status		 status;

d568 1
@


1.276
log
@use mbox backend for mbox delivery.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.275 2012/01/12 18:06:18 eric Exp $	*/
d151 3
a153 1
	IMSG_QUEUE_MESSAGE_UPDATE,
@


1.275
log
@Remove dead code for config reloading for now. It is not functionnal
and confusing.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.274 2012/01/12 15:01:33 eric Exp $	*/
a60 1
#define	PATH_MAILLOCAL		"/usr/libexec/mail.local"
d793 1
@


1.274
log
@remove envelope_get_errormsg() and move envelope_set_errormsg()
to envelope.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.273 2012/01/11 22:55:16 gilles Exp $	*/
a128 1
	IMSG_CONF_RELOAD,
a732 5
};

struct reload {
	int			fd;
	int			ret;
@


1.273
log
@remove stateful iteration from ramqueue, if we ever need to reintroduce it
we'll do it, but it isn't used and causes potential bugs

idea by Nathanael Rensel, diff by me, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.272 2012/01/11 22:24:37 gilles Exp $	*/
d1044 1
a1245 2
void envelope_set_errormsg(struct envelope *, char *, ...);
char *envelope_get_errormsg(struct envelope *);
@


1.272
log
@implement an envelope_ascii API that's not tied to a specific queue_backend
simplify queue_fsqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.271 2012/01/11 17:46:36 eric Exp $	*/
a610 1
	struct ramqueue_envelope	       *current_evp;
@


1.271
log
@Simplify runner/queue by getting rid of Q_PURGE.  Instead, let smtpd
periodically clear the purge/ directory.  At init time, the fsqueue
backend simply moves the existing incoming/ dir in purge/ to discard
aborted sessions.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.270 2012/01/11 17:07:18 eric Exp $	*/
d437 26
d1042 7
@


1.270
log
@remove dead prototype

from Nathanael Rensen

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.269 2011/12/27 17:13:05 eric Exp $	*/
d68 1
a891 1
	Q_PURGE,
d1223 2
@


1.269
log
@Q_BOUNCE is not used anymore

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.268 2011/12/18 22:55:31 chl Exp $	*/
a1097 1
int ramqueue_load_offline(struct ramqueue *);
@


1.268
log
@Sync comments with latest cleanup changes

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.267 2011/12/14 23:08:40 eric Exp $	*/
a888 1
	Q_INVALID=0,
a891 1
	Q_BOUNCE,
@


1.267
log
@finally kill queue_shared.c and move what is left to bounce.c
where it belongs.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.266 2011/12/14 22:28:02 eric Exp $	*/
d973 1
a973 1
/* auth_backend.c */
d1004 1
a1004 1
/* delivery_backend.c */
d1190 1
a1190 1
/* user_backend.c */
@


1.266
log
@split auth_backend.c for consistency

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.265 2011/12/14 18:42:27 eric Exp $	*/
d981 1
a981 1

a1094 5


/* queue_shared.c */
void queue_message_update(struct envelope *);
int bounce_record_message(struct envelope *, struct envelope *);
@


1.265
log
@move show_queue() and related functions from queue_shared.c
to smtpctl.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.264 2011/12/14 17:55:55 eric Exp $	*/
a922 1
	AUTH_INVALID=0,
d924 1
a924 1
	AUTH_GETPWNAM,
a927 1
	enum auth_type	type;
@


1.264
log
@make queue_fsqueue backend consistent with the backend scheme.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.263 2011/12/13 23:55:00 gilles Exp $	*/
a1101 1
void show_queue(enum queue_kind, int);
@


1.263
log
@*finally* make use of certificate authority file if available !

bits from relayd, ok chl@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.262 2011/12/13 22:04:35 eric Exp $	*/
a910 2
	enum queue_type	type;

@


1.262
log
@split user_backend.c into user.c and user_pwd.c to be consistent with the
backend scheme. Also rename USER_GETPWNAM to USER_PWD.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.261 2011/12/13 21:44:47 gilles Exp $	*/
d480 2
@


1.261
log
@- introduce delivery backend API (delivery.c)
- move each delivery method to it's own delivery backend
- simplify smtpd.c accordingly
- rename A_EXT -> A_MDA since that's what we really do

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.260 2011/12/12 17:20:36 eric Exp $	*/
d936 1
a936 2
	USER_INVALID=0,
	USER_GETPWNAM,
a948 1
	enum user_type	type;
@


1.260
log
@add a session_enter_state() function to change the state of an smtp
session and allow those state changes to be traced (add traces flags
for upcoming changes while there).

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.259 2011/12/12 16:45:16 chl Exp $	*/
d306 1
a306 1
	A_EXT
a587 1

d956 8
d1006 4
@


1.259
log
@remove comments about dead "struct delivery"

"obvious ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.258 2011/12/11 19:58:09 eric Exp $	*/
d634 6
a639 2
#define	TRACE_VERBOSE	0x01
#define	TRACE_IMSG	0x02
@


1.258
log
@utility function for parsing and validating SMTP response lines

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.257 2011/12/11 17:02:10 eric Exp $	*/
a406 2

//	struct delivery			delivery;
@


1.257
log
@Make the mta code a bit more straightforward:
- fetch the ssl cert earlier on if needed
- skip mta_pickup() when handling the incoming fd

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.256 2011/12/08 17:00:28 todd Exp $	*/
d1223 1
@


1.256
log
@rename struct user to struct mta_user to avoid namespace conflict elsewhere
ok chl@@ & gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.255 2011/11/28 20:29:27 chl Exp $	*/
d834 1
a856 1
	char			*cert;
d858 1
a858 1
	struct ramqueue_batch	*batch;
@


1.255
log
@fix STATE_COUNT count

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.254 2011/11/21 18:57:54 eric Exp $	*/
d940 1
a940 1
struct user {
d950 2
a951 2
	int (*getbyname)(struct user *, char *);
	int (*getbyuid)(struct user *, uid_t);
@


1.254
log
@get rid of the "enqueue/" queue; use "incoming/" instead.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.253 2011/11/16 19:38:56 eric Exp $	*/
d477 1
a477 1
#define STATE_COUNT	18
@


1.253
log
@remove unused functions

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.252 2011/11/16 11:18:55 eric Exp $	*/
a886 1
	Q_ENQUEUE,
@


1.252
log
@Do not unlink an offline message until it has been correctly enqueued.
While there, simplify the offline_enqueue() function by doing all the
sanity checks in the forked process,  and remove all fatal(): on error,
the offline message is left untouched in the directory.  Also, get rid
of the path_starts_with() check since all paths to offline messages are
now constructed internally.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.251 2011/11/15 23:06:39 gilles Exp $	*/
a1219 2
u_int32_t msgid_generate(void);
u_int64_t evpid_generate(u_int32_t);
a1221 2
u_int32_t filename_to_msgid(char *);
u_int64_t filename_to_evpid(char *);
@


1.251
log
@Qwalk, our API to linearly walk over the persistent queue, did not take the
queue_backend into account and assumed a filesystem with a specific layout.

This commit does plenty of things:

- make qwalk an abstraction in the queue_backend API, and impose queue
  drivers to implement qwalk_open(), qwalk() and qwalk_close();

- move previous qwalk_open(), qwalk() and qwalk_close() to the fsqueue
  driver since they were fsqueue specific ...

- make qwalk API work with msgid/evpid instead of pathnames since we're
  going to use the queue_backend API to load envelopes by evpid anyway;

- makes smtpd use *solely* the queue_backend API when manipulating the
  queue. pathnames were removed from smtpd.h and moved into the fsqueue
  which means we can now store a queue anywhere ... as long as we write
  the ten functions or so required for a queue driver ;-)

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.250 2011/11/14 19:23:41 chl Exp $	*/
d453 1
@


1.250
log
@when receiving an unexpected imsg, print its name.

with help and ideas from eric@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.249 2011/11/14 11:53:10 eric Exp $	*/
a66 10

#define PATH_ENQUEUE		"/enqueue"
#define PATH_INCOMING		"/incoming"
#define PATH_QUEUE		"/queue"
#define PATH_PURGE		"/purge"
#define PATH_CORRUPT		"/corrupt"

#define PATH_MESSAGE		"/message"
#define PATH_ENVELOPES		"/envelopes"

a67 1
#define PATH_BOUNCE		"/bounce"
a889 1
	Q_OFFLINE,
d909 1
d913 4
d1069 2
d1083 3
a1089 3
struct qwalk	*qwalk_new(char *);
int qwalk(struct qwalk *, char *);
void qwalk_close(struct qwalk *);
d1091 1
a1091 1
void show_queue(char *, int);
@


1.249
log
@The spool and offline directories are backend-independent, so they
must be created early by smtpd, rather than in fsqueue.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.248 2011/11/07 11:14:10 eric Exp $	*/
d1165 2
@


1.248
log
@Let the smtpd process handle the enqueueing of offline messages at
startup, rather than playing tricks with the runner. This will allow
further simplifications and improvements in the runner/queue.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.247 2011/10/26 20:47:31 gilles Exp $	*/
d1229 1
@


1.247
log
@- fix smtpctl pause/resume so the ramqueue scheduling is done correctly
- rename IMSG and smtpctl pause/resume parameters
- update man page

tested by me, ok chl@@, eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.246 2011/10/23 15:36:53 eric Exp $	*/
a176 1
	IMSG_PARENT_ENQUEUE_OFFLINE,
@


1.246
log
@a few important fixes:

- use correct endianness when dumping/loading port
- use the right flag set when dumping/loading flags
- keep and use the authmap name when needed, rather than an id that
  might change when smtpd is restarted
- dump/load the authmap name with the envelope
- remove the rule struct from rq_batch as only the relay info is useful

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.245 2011/10/23 13:08:18 eric Exp $	*/
d158 4
a161 4
	IMSG_QUEUE_PAUSE_LOCAL,
	IMSG_QUEUE_PAUSE_OUTGOING,
	IMSG_QUEUE_RESUME_LOCAL,
	IMSG_QUEUE_RESUME_OUTGOING,
@


1.245
log
@relay_as is not used anuwhere

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.244 2011/10/23 13:03:05 gilles Exp $	*/
d121 1
a121 1
	objid_t secmapid;
d577 1
a577 1
	struct rule			rule;
d766 1
a766 1
	objid_t			 secmapid;
d862 1
a862 1
	objid_t			 secmapid;
@


1.244
log
@introduce Q_CORRUPT and queue_backend operation to move a message from
schedule queue to corrupt queue upon envelope loading failure.

tested by me, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.243 2011/10/23 09:30:07 gilles Exp $	*/
a382 1
	struct mailaddr	relay_as;
@


1.243
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.242 2011/10/22 00:16:34 eric Exp $	*/
d72 1
d904 2
a905 1
	Q_BOUNCE
d917 2
a918 1
	QOP_PURGE
d1085 1
@


1.242
log
@Add a log_trace() call to toggle logging of specific debugging info in
verbose mode, and an associated -T command line option.  Use it for
the imsg traces.

Requested by gilles@@ who doesn't like verbose to be too verbose.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.241 2011/10/09 18:39:54 eric Exp $	*/
d358 1
a358 4
	DS_ACCEPTED	= 0x10,
	DS_RETRY       	= 0x20,
	DS_EDNS		= 0x40,
	DS_ECONNECT	= 0x80
d362 4
a365 8
	DF_RESOLVED		= 0x1,
	DF_SCHEDULED		= 0x2,
	DF_PROCESSING		= 0x4,
	DF_AUTHENTICATED	= 0x8,
	DF_ENQUEUED		= 0x10,
	DF_FORCESCHEDULE	= 0x20,
	DF_BOUNCE		= 0x40,
	DF_INTERNAL		= 0x80 /* internal expansion forward */
a384 26
struct delivery {
	u_int64_t			id;
	enum delivery_type		type;

	char				helo[MAXHOSTNAMELEN];
	char				hostname[MAXHOSTNAMELEN];
	char				errorline[MAX_LINE_SIZE + 1];
	struct sockaddr_storage		ss;

	struct mailaddr			from;
	struct mailaddr			rcpt;
	struct mailaddr			rcpt_orig;

	union delivery_method {
		struct delivery_mda	mda;
		struct delivery_mta	mta;
	} agent;

	time_t				 creation;
	time_t				 lasttry;
	time_t				 expire;
	u_int8_t			 retry;
	enum delivery_flags		 flags;
	enum delivery_status		 status;
};

d410 1
a410 1

d420 27
a446 1
	struct delivery			delivery;
d1220 2
@


1.241
log
@show messages sent between processes in debug mode

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.240 2011/09/19 13:10:47 chl Exp $	*/
d653 3
@


1.240
log
@Quick fix to avoid fatal() when we receive a line which have a length of exactly 1024.

Better fix comming soon.

Committing on behalf of gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.239 2011/09/18 21:37:53 gilles Exp $	*/
d1228 1
@


1.239
log
@a single ramqueue message may be shared by many ramqueue envelopes to be
delivered to many ramqueue hosts, therefore storing the rq_host pointer in
the rq_msg envelope is wrong and causes baaaaad behavior.

this commit fixes reliability issues in runner process, experienced and
reported by many
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.238 2011/09/12 20:47:15 gilles Exp $	*/
d89 1
a89 1
#define	SMTP_LINE_MAX		16384
d398 1
a398 1
	char				errorline[MAX_LINE_SIZE];
d526 1
a526 1
	char		 pass[MAX_LINE_SIZE];
d734 2
a735 2
		char			 errormsg[MAX_LINE_SIZE];
		char			 dataline[MAX_LINE_SIZE];
@


1.238
log
@- introduce filtermask in struct smtpd
- do not forward lines to mfa when FILTER_DATALINE is not set in filtermask

prevents smtpd from handling mails slowly while I'm hacking on filters
support
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.237 2011/09/01 19:56:49 eric Exp $	*/
d592 1
a598 1
	struct ramqueue_host		       *rq_host;
@


1.237
log
@Introduce a small set of functions to manage stat counters in a
simpler and hopefully saner way.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.236 2011/08/31 18:56:30 gilles Exp $	*/
d651 1
@


1.236
log
@add support for per-line DATA callbacks, this allows filters to take their
decisions *while* the message is being received by the client.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.235 2011/08/27 22:37:35 gilles Exp $	*/
a105 1
#define SET_IF_GREATER(x,y) do { y = MAX(x,y); } while(0)
d653 31
a683 2
struct s_parent {
	time_t		start;
d686 8
a693 3
struct s_queue {
	size_t		inserts_local;
	size_t		inserts_remote;
d696 2
a697 6
struct s_runner {
	size_t		active;
	size_t		maxactive;
	size_t		bounces_active;
	size_t		bounces_maxactive;
	size_t		bounces;
a700 14
	size_t		sessions;
	size_t		sessions_inet4;
	size_t		sessions_inet6;
	size_t		sessions_active;
	size_t		sessions_maxactive;

	size_t		smtps;
	size_t		smtps_active;
	size_t		smtps_maxactive;

	size_t		starttls;
	size_t		starttls_active;
	size_t		starttls_maxactive;

a712 33
struct s_mda {
	size_t		sessions;
	size_t		sessions_active;
	size_t		sessions_maxactive;
};

struct s_control {
	size_t		sessions;
	size_t		sessions_active;
	size_t		sessions_maxactive;
};

struct s_lka {
	size_t		queries;
	size_t		queries_active;
	size_t		queries_maxactive;
	size_t		queries_mx;
	size_t		queries_host;
	size_t		queries_cname;
	size_t		queries_failure;
};

struct s_ramqueue {
	size_t		hosts;
	size_t		batches;
	size_t		messages;
	size_t		envelopes;
	size_t		hosts_max;
	size_t		batches_max;
	size_t		messages_max;
	size_t		envelopes_max;
};

a714 2
	struct s_queue		 queue;
	struct s_runner		 runner;
a715 1
	struct s_mda		 mda;
d717 2
a718 3
	struct s_control	 control;
	struct s_lka		 lka;
	struct s_ramqueue	 ramqueue;
d1183 6
@


1.235
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.234 2011/08/27 22:32:41 gilles Exp $	*/
d150 1
a150 1
	IMSG_MFA_DISCONNECT,
d756 1
@


1.234
log
@initial support for a session-time filtering API

currently only HELO/EHLO, MAIL, RCPT are supported, however ... I have
voluntarily disabled filters at smtpd.conf level so people don't play with
it until the API has stabilized a bit

discussed with several people in private, no one opposed the feature
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.233 2011/08/17 20:35:11 gilles Exp $	*/
d55 1
a55 1
#define SMTPD_FILTER_USER      	 "_smtpdmfa"
@


1.233
log
@move ramqueue_host pointer from ramqueue_envelope to ramqueue_message.
this allows us to save one pointer from each envelope stored in ram while
still allowing O(1) host lookups by ramqueue_envelope.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.232 2011/08/17 20:04:43 gilles Exp $	*/
d24 2
a39 4
/* sizes include the tailing '\0' */
#define MAX_LINE_SIZE		 1024
#define MAX_LOCALPART_SIZE	 128
#define MAX_DOMAINPART_SIZE	 MAXHOSTNAMELEN
d41 4
d47 1
d55 1
d137 1
d146 3
d150 1
a150 1
	IMSG_MFA_MAIL,
a347 1

d463 1
a463 1
	CHILD_ENQUEUE_OFFLINE
d638 2
d647 1
d832 19
d1078 2
a1079 1

@


1.232
log
@- teach smtpctl remove about the new ramqueue structure
- bonus #1: O(log n) removal of envelopes
- bonus #2: removing all envelopes that have the same msgid works again
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.231 2011/08/17 19:36:23 gilles Exp $	*/
d584 2
a585 3
	struct ramqueue_host		*host;
	struct ramqueue_batch		*batch;
	struct ramqueue_message		*message;
d592 1
d1119 1
a1119 1
void ramqueue_remove_renvelope(struct ramqueue *, struct ramqueue_envelope *);
d1130 3
@


1.231
log
@- introduce ramqueue_lookup_{host,message,envelope} to perform lookups in
  the new ramqueue structure
- introduce ramqueue_reschedule() and ramqueue_reschedule_envelope() which
  to reschedule a message or a specific envelope.

O(n) ->  O(log n)  \o/
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.230 2011/08/16 19:02:03 gilles Exp $	*/
a1097 1
void ramqueue_remove(struct ramqueue *, struct ramqueue_envelope *);
d1116 5
a1120 2
void ramqueue_reschedule(struct ramqueue *, u_int64_t);
void ramqueue_reschedule_envelope(struct ramqueue *, struct ramqueue_envelope *);
@


1.230
log
@add a host-tree and an envelope-tree in the ramqueue, they will be used to
improve scheduling and general ramqueue operations. unused yet
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.229 2011/07/21 23:29:24 gilles Exp $	*/
a1104 1
void ramqueue_reschedule(struct ramqueue *, u_int64_t);
d1112 7
@


1.229
log
@- update smtpctl.8 to reflect reality
- bring back 'smtpctl schedule' and 'smtpctl remove' to life

Things you should know:

The ramqueue data structure is not finished yet and lacks an envelope tree
for evpid lookups. I wanted to wait until I'm done but too many people are
affected by not being able to reschedule envelopes, this is a quick fix.

So right now there's an O(rrible) complexity as both commands will perform
a (possibly aborted) queue scan leading to O(n). I will make that O(log n)
soon.

Also, smtpctl remove no longer supports removing an entire message, I will
fix that very soon too.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.228 2011/07/20 10:22:54 eric Exp $	*/
d566 1
a566 1
	RB_ENTRY(ramqueue_host)		host_entry;
d583 1
d586 1
d590 5
a594 1

d598 1
a634 1
	SPLAY_HEAD(msgtree, envelope)		 sc_messages;
d713 1
d717 1
d1096 2
d1110 7
a1116 1
RB_PROTOTYPE(hosttree, ramqueue_host, host_entry, ramqueue_host_cmp);
@


1.228
log
@Fix reporting of permanent/temporary failures for MX lookups.
Simplify code a bit while there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.227 2011/06/09 17:41:52 gilles Exp $	*/
d161 3
d1095 2
@


1.227
log
@'relay as' and 'relay via as' rules allow smtpd to rewrite the user part,
the domain part or the entire address of the sender at the SMTP sesssion
level. this is not masquerade but allows smtpd to communicate with hosts
that do a check of SMTP sender fqdn.

sent to tech@@, a couple 'no regression' feedbacks
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.226 2011/05/21 19:57:34 gilles Exp $	*/
d746 8
@


1.226
log
@remove unused commented structure
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.225 2011/05/21 18:43:08 gilles Exp $	*/
d327 1
d380 1
@


1.225
log
@until now the map_backend API was not really useful for backends that are
not key/val stores. refactored a bit so that smtpd can really take
advantage of backends. preliminary work for ldap support ;-)

no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.224 2011/05/17 18:54:32 gilles Exp $	*/
a342 12

/*
enum delivery_method {
	DM_INVALID = 0,
	DM_RELAY,
	DM_RELAYVIA,
	DM_MAILDIR,
	DM_MBOX,
	DM_FILENAME,
	DM_EXT
};
*/
@


1.224
log
@introduce new user_backend API for smtpd to lookup the users it wants to
deliver mail to. the only backend supported for now is USER_GETPWNAM and
it is not yet possible to switch to an alternate backend.

yes this means that we're very close from smtpd being able to handle fully
virtual accounts for both incoming and outgoing messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.223 2011/05/17 16:42:06 gilles Exp $	*/
d279 1
a280 1
	enum map_src source;
d283 1
a283 2
	char *(*get)(void *, char *, size_t *);
	int (*put)(void *, char *, char *);
a285 4
struct map_parser {
	enum map_kind kind;
	void *(*extract)(char *, char *, size_t);
};
@


1.223
log
@smtpd now uses an auth_backend API to authenticate users that are allowed
to send mail so they do not necessarily need a local system account.

two backends are provided by default, bsd_auth(3) and getpwnam(3), however
smtpd will only select bsd_auth(3) for the moment and not provide a way to
chose any other backend (that's on purpose ;p).

bye bye authenticate() !
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.222 2011/05/16 21:05:52 gilles Exp $	*/
d917 1
a917 1
/* queue structures */
d930 22
d1151 4
d1175 1
a1175 1
int secure_file(int, char *, struct passwd *, int);
@


1.222
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.221 2011/05/06 19:21:43 eric Exp $	*/
d917 13
d943 2
a944 2
/* authenticate.c */
int authenticate_user(char *, char *);
@


1.221
log
@move dns session specific structs and prototypes out of smtpd.h.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.220 2011/05/01 12:57:11 eric Exp $	*/
d315 3
a317 3
#define IS_MAILBOX(x)	((x).rule.r_action == A_MAILDIR || (x).rule.r_action == A_MBOX || (x).rule.r_action == A_FILENAME)
#define IS_RELAY(x)	((x).rule.r_action == A_RELAY || (x).rule.r_action == A_RELAYVIA)
#define IS_EXT(x)	((x).rule.r_action == A_EXT)
a335 11
enum path_flags {
	F_PATH_ALIAS = 0x1,
	F_PATH_VIRTUAL = 0x2,
	F_PATH_EXPANDED = 0x4,
	F_PATH_NOFORWARD = 0x8,
	F_PATH_FORWARDED = 0x10,
	F_PATH_ACCOUNT = 0x20,
	F_PATH_AUTHENTICATED = 0x40,
	F_PATH_RELAY = 0x80,
};

d341 44
a384 4
union path_data {
	char username[MAXLOGNAME];
	char filename[MAXPATHLEN];
	char filter[MAXPATHLEN];
d388 34
a421 9
struct path {
	TAILQ_ENTRY(path)		 entry;
	struct rule			 rule;
	enum path_flags			 flags;
	u_int8_t			 forwardcnt;
	char				 user[MAX_LOCALPART_SIZE];
	char				 domain[MAX_DOMAINPART_SIZE];
	char				 pw_name[MAXLOGNAME];
	union path_data			 u;
a422 1
TAILQ_HEAD(deliverylist, path);
d443 2
a444 1
	union path_data		u;
a448 25
enum message_type {
	T_MDA_MESSAGE		= 0x1,
	T_MTA_MESSAGE		= 0x2,
	T_BOUNCE_MESSAGE	= 0x4
};

enum message_status {
	S_MESSAGE_PERMFAILURE	= 0x2,
	S_MESSAGE_TEMPFAILURE	= 0x4,
	S_MESSAGE_REJECTED	= 0x8,
	S_MESSAGE_ACCEPTED	= 0x10,
	S_MESSAGE_RETRY		= 0x20,
	S_MESSAGE_EDNS		= 0x40,
	S_MESSAGE_ECONNECT	= 0x80
};

enum message_flags {
	F_MESSAGE_RESOLVED	= 0x1,
	F_MESSAGE_SCHEDULED	= 0x2,
	F_MESSAGE_PROCESSING	= 0x4,
	F_MESSAGE_AUTHENTICATED	= 0x8,
	F_MESSAGE_ENQUEUED	= 0x10,
	F_MESSAGE_FORCESCHEDULE	= 0x20,
	F_MESSAGE_BOUNCE	= 0x40
};
d451 1
a451 1
	TAILQ_ENTRY(envelope)		 entry;
d453 2
a454 1
	enum message_type		 type;
d456 2
a457 3
	u_int64_t			 id;
	u_int64_t			 session_id;
	u_int64_t			 batch_id;
d459 3
a461 1
	char				 tag[MAX_TAG_SIZE];
a462 17
	u_int64_t			 evpid;
	char				 session_helo[MAXHOSTNAMELEN];
	char				 session_hostname[MAXHOSTNAMELEN];
	char				 session_errorline[MAX_LINE_SIZE];
	struct sockaddr_storage		 session_ss;
	struct path			 session_rcpt;

	struct path			 sender;
	struct path			 recipient;

	time_t				 creation;
	time_t				 lasttry;
	time_t				 expire;
	u_int8_t			 retry;
	enum message_flags		 flags;
	enum message_status		 status;
};
d586 1
a586 1
	enum message_type		type;
d643 1
a643 1
	SPLAY_HEAD(lkatree, lkasession)		 lka_sessions;
d746 1
a746 1
		struct path		 path;
d751 1
a751 1
	enum message_flags		 flags;
d753 1
a753 1
	struct envelope			 msg;
d759 2
a760 1
	char				 pw_name[MAXLOGNAME];
d801 1
a801 1
enum lkasession_flags {
d805 2
a806 2
struct lkasession {
	SPLAY_ENTRY(lkasession)		 nodes;
d809 1
a809 3
	struct path			 path;
	struct deliverylist    		 deliverylist;

d814 1
a814 2
	enum lkasession_flags		 flags;
	struct envelope			 message;
d925 2
a926 2
int aliases_virtual_exist(objid_t, struct path *);
int aliases_virtual_get(objid_t, struct expandtree *, struct path *);
d984 1
a984 1
int forwards_get(int, struct expandtree *);
d989 7
a995 2
int lkasession_cmp(struct lkasession *, struct lkasession *);
SPLAY_PROTOTYPE(lkatree, lkasession, nodes, lkasession_cmp);
d1129 1
a1129 1
int recipient_to_path(struct path *, char *);
d1138 2
a1139 2
void message_set_errormsg(struct envelope *, char *, ...);
char *message_get_errormsg(struct envelope *);
a1140 1
struct path *path_dup(struct path *);
@


1.220
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.219 2011/04/17 13:36:07 gilles Exp $	*/
a629 1
	SPLAY_HEAD(dnstree, dnssession)		 dns_sessions;
a805 17
struct mx {
        char    host[MAXHOSTNAMELEN];
        int     prio;
};

struct dnssession {
        SPLAY_ENTRY(dnssession)          nodes;
        u_int64_t                        id;
        struct dns                       query;
        struct event                     ev;
        struct asr_query                *aq;
        struct mx                        mxarray[MAX_MX_COUNT];
        size_t                           mxarraysz;
        size_t                           mxcurrent;
	size_t				 mxfound;
};

a953 2
int dnssession_cmp(struct dnssession *, struct dnssession *);
SPLAY_PROTOTYPE(dnstree, dnssession, nodes, dnssession_cmp);
@


1.219
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.218 2011/04/17 12:46:46 gilles Exp $	*/
a193 1
	struct smtpd		*env;
a507 1
	struct smtpd		*env;
a544 1
	struct smtpd			*s_env;
a587 1
	struct smtpd			       *env;
a756 1
	struct smtpd		*env;
a852 1
	struct smtpd		*env;
d917 3
a919 4
	int (*init)(struct smtpd *);
	int (*message)(struct smtpd *, enum queue_kind, enum queue_op, u_int32_t *);
	int (*envelope)(struct smtpd *, enum queue_kind, enum queue_op,
	    struct envelope *);
d923 2
a924 1
extern void (*imsg_callback)(struct smtpd *, struct imsgev *, struct imsg *);
d928 5
a932 5
int aliases_exist(struct smtpd *, objid_t, char *);
int aliases_get(struct smtpd *, objid_t, struct expandtree *, char *);
int aliases_vdomain_exists(struct smtpd *, objid_t, char *);
int aliases_virtual_exist(struct smtpd *, objid_t, struct path *);
int aliases_virtual_get(struct smtpd *, objid_t, struct expandtree *, struct path *);
d941 2
a942 3
int bounce_session(struct smtpd *, int, struct envelope *);
int bounce_session_switch(struct smtpd *, FILE *, enum session_state *, char *,
	struct envelope *);
d952 6
a957 6
void purge_config(struct smtpd *, u_int8_t);
void unconfigure(struct smtpd *);
void configure(struct smtpd *);
void init_pipes(struct smtpd *);
void config_pipes(struct smtpd *, struct peer *, u_int);
void config_peers(struct smtpd *, struct peer *, u_int);
d961 1
a961 1
pid_t control(struct smtpd *);
d968 4
a971 5
void dns_query_host(struct smtpd *, char *, int, u_int64_t);
void dns_query_mx(struct smtpd *, char *, int, u_int64_t);
void dns_query_ptr(struct smtpd *, struct sockaddr_storage *,
    u_int64_t);
void dns_async(struct smtpd *, struct imsgev *, int, struct dns *);
d996 1
a996 1
pid_t lka(struct smtpd *);
d1002 3
a1004 3
void *map_lookup(struct smtpd *, objid_t, char *, enum map_kind);
struct map *map_find(struct smtpd *, objid_t);
struct map *map_findbyname(struct smtpd *, const char *);
d1008 1
a1008 1
pid_t mda(struct smtpd *);
d1012 1
a1012 1
pid_t mfa(struct smtpd *);
d1016 1
a1016 1
pid_t mta(struct smtpd *);
d1027 3
a1029 3
pid_t queue(struct smtpd *);
void queue_submit_envelope(struct smtpd *, struct envelope *);
void queue_commit_envelopes(struct smtpd *, struct envelope *);
d1034 10
a1043 14
int queue_message_create(struct smtpd *, enum queue_kind, u_int32_t *);
int queue_message_delete(struct smtpd *, enum queue_kind, u_int32_t);
int queue_message_commit(struct smtpd *, enum queue_kind, u_int32_t);
int queue_message_fd_r(struct smtpd *, enum queue_kind, u_int32_t);
int queue_message_fd_rw(struct smtpd *, enum queue_kind, u_int32_t);
int queue_message_purge(struct smtpd *, enum queue_kind, u_int32_t);
int queue_envelope_create(struct smtpd *, enum queue_kind,
    struct envelope *);
int queue_envelope_delete(struct smtpd *, enum queue_kind,
    struct envelope *);
int queue_envelope_load(struct smtpd *, enum queue_kind,
    u_int64_t, struct envelope *);
int queue_envelope_update(struct smtpd *, enum queue_kind,
    struct envelope *);
d1047 1
a1047 1
void queue_message_update(struct smtpd *, struct envelope *);
d1051 1
a1051 1
int bounce_record_message(struct smtpd *, struct envelope *, struct envelope *);
d1056 1
a1056 1
void ramqueue_init(struct smtpd *, struct ramqueue *);
d1074 1
a1074 1
pid_t runner(struct smtpd *);
d1079 2
a1080 2
pid_t smtp(struct smtpd *);
void smtp_resume(struct smtpd *);
d1108 2
a1109 2
int ssl_load_certfile(struct smtpd *, const char *, u_int8_t);
void ssl_setup(struct smtpd *, struct listener *);
@


1.218
log
@remove unused IMSG_ defines
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.217 2011/04/17 11:39:23 gilles Exp $	*/
d929 1
a932 1

d954 11
a964 11
#define		 PURGE_LISTENERS	0x01
#define		 PURGE_MAPS		0x02
#define		 PURGE_RULES		0x04
#define		 PURGE_SSL		0x08
#define		 PURGE_EVERYTHING	0xff
void		 purge_config(struct smtpd *, u_int8_t);
void		 unconfigure(struct smtpd *);
void		 configure(struct smtpd *);
void		 init_pipes(struct smtpd *);
void		 config_pipes(struct smtpd *, struct peer *, u_int);
void		 config_peers(struct smtpd *, struct peer *, u_int);
d968 4
a971 4
pid_t		 control(struct smtpd *);
void		 session_socket_blockmode(int, enum blockmodes);
void		 session_socket_no_linger(int);
int		 session_socket_error(int);
d975 3
a977 3
void		 dns_query_host(struct smtpd *, char *, int, u_int64_t);
void		 dns_query_mx(struct smtpd *, char *, int, u_int64_t);
void		 dns_query_ptr(struct smtpd *, struct sockaddr_storage *,
d979 3
a981 1
void		 dns_async(struct smtpd *, struct imsgev *, int, struct dns *);
d1004 2
a1005 3
pid_t		 lka(struct smtpd *);
int		 lkasession_cmp(struct lkasession *, struct lkasession *);
int		 dnssession_cmp(struct dnssession *, struct dnssession *);
a1006 1
SPLAY_PROTOTYPE(dnstree, dnssession, nodes, dnssession_cmp);
d1010 3
a1012 4
void		*map_lookup(struct smtpd *, objid_t, char *, enum map_kind);
struct map	*map_find(struct smtpd *, objid_t);
struct map	*map_findbyname(struct smtpd *, const char *);

d1016 1
a1016 1
pid_t		 mda(struct smtpd *);
d1020 1
a1020 1
pid_t		mfa(struct smtpd *);
d1024 2
a1025 2
pid_t		 mta(struct smtpd *);
int		 mta_session_cmp(struct mta_session *, struct mta_session *);
d1030 2
a1031 2
int		 parse_config(struct smtpd *, const char *, int);
int		 cmdline_symset(char *);
d1035 3
a1037 3
pid_t		 queue(struct smtpd *);
void		 queue_submit_envelope(struct smtpd *, struct envelope *);
void		 queue_commit_envelopes(struct smtpd *, struct envelope *);
d1042 7
a1048 7
int	queue_message_create(struct smtpd *, enum queue_kind, u_int32_t *);
int	queue_message_delete(struct smtpd *, enum queue_kind, u_int32_t);
int	queue_message_commit(struct smtpd *, enum queue_kind, u_int32_t);
int	queue_message_fd_r(struct smtpd *, enum queue_kind, u_int32_t);
int	queue_message_fd_rw(struct smtpd *, enum queue_kind, u_int32_t);
int	queue_message_purge(struct smtpd *, enum queue_kind, u_int32_t);
int	queue_envelope_create(struct smtpd *, enum queue_kind,
d1050 1
a1050 1
int	queue_envelope_delete(struct smtpd *, enum queue_kind,
d1052 1
a1052 1
int	queue_envelope_load(struct smtpd *, enum queue_kind,
d1054 1
a1054 1
int	queue_envelope_update(struct smtpd *, enum queue_kind,
d1059 1
a1059 1
void		 queue_message_update(struct smtpd *, struct envelope *);
d1061 4
a1064 4
int		 qwalk(struct qwalk *, char *);
void		 qwalk_close(struct qwalk *);
int		 bounce_record_message(struct smtpd *, struct envelope *, struct envelope *);
void		 show_queue(char *, int);
d1068 11
a1078 11
void		 ramqueue_init(struct smtpd *, struct ramqueue *);
int		 ramqueue_load(struct ramqueue *, time_t *);
int		 ramqueue_load_offline(struct ramqueue *);
int		 ramqueue_host_cmp(struct ramqueue_host *, struct ramqueue_host *);
void		 ramqueue_remove(struct ramqueue *, struct ramqueue_envelope *);
int		 ramqueue_is_empty(struct ramqueue *);
int		 ramqueue_is_empty(struct ramqueue *);
int		 ramqueue_batch_is_empty(struct ramqueue_batch *);
int		 ramqueue_host_is_empty(struct ramqueue_host *);
void		 ramqueue_remove_batch(struct ramqueue_host *, struct ramqueue_batch *);
void		 ramqueue_remove_host(struct ramqueue *, struct ramqueue_host *);
d1086 2
a1087 2
pid_t		 runner(struct smtpd *);
void		 message_reset_flags(struct envelope *);
d1091 2
a1092 2
pid_t		 smtp(struct smtpd *);
void		 smtp_resume(struct smtpd *);
d1096 7
a1102 8
void		 session_init(struct listener *, struct session *);
int		 session_cmp(struct session *, struct session *);
void		 session_pickup(struct session *, struct submit_status *);
void		 session_destroy(struct session *);
void		 session_respond(struct session *, char *, ...)
		    __attribute__ ((format (printf, 2, 3)));
void		 session_bufferevent_new(struct session *);

d1108 4
a1112 4
void	 imsg_event_add(struct imsgev *);
void	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t, pid_t,
	    int, void *, u_int16_t);
void	 imsg_dispatch(int, short, void *);
d1116 7
a1122 8
void	 ssl_init(void);
void	 ssl_transaction(struct session *);

void	 ssl_session_init(struct session *);
void	 ssl_session_destroy(struct session *);
int	 ssl_load_certfile(struct smtpd *, const char *, u_int8_t);
void	 ssl_setup(struct smtpd *, struct listener *);
int	 ssl_cmp(struct ssl *, struct ssl *);
d1138 26
a1163 26
void		 addargs(arglist *, char *, ...)
		     __attribute__((format(printf, 2, 3)));
int		 bsnprintf(char *, size_t, const char *, ...)
    __attribute__ ((format (printf, 3, 4)));
int		 safe_fclose(FILE *);
int		 hostname_match(char *, char *);
int		 recipient_to_path(struct path *, char *);
int		 valid_localpart(char *);
int		 valid_domainpart(char *);
char		*ss_to_text(struct sockaddr_storage *);
int		 valid_message_id(char *);
int		 valid_message_uid(char *);
char		*time_to_text(time_t);
int		 secure_file(int, char *, struct passwd *, int);
void		 lowercase(char *, char *, size_t);
void		 message_set_errormsg(struct envelope *, char *, ...);
char		*message_get_errormsg(struct envelope *);
void		 sa_set_port(struct sockaddr *, int);
struct path	*path_dup(struct path *);
u_int64_t	 generate_uid(void);
void		 fdlimit(double);
int		 availdesc(void);
u_int32_t	 evpid_to_msgid(u_int64_t);
u_int64_t	 msgid_to_evpid(u_int32_t);
u_int32_t	 filename_to_msgid(char *);
u_int64_t	 filename_to_evpid(char *);
@


1.217
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.215 2011/04/15 19:03:28 gilles Exp $	*/
d25 3
a27 3
	if (IMSG_DATA_SIZE(&imsg) != sizeof(*p))		\
		fatalx("bad length imsg received");		\
} while (0)
a30 1

a41 1
/*#define MAX_ID_SIZE		 64*/
a127 2
	IMSG_CONF_SSL_CERT,
	IMSG_CONF_SSL_KEY,
a132 2
	IMSG_CONF_CONDITION,
	IMSG_CONF_OPTION,
a149 1
	IMSG_QUEUE_STATS,
a154 1
	IMSG_QUEUE_REMOVE_SUBMISSION,
a168 1
	IMSG_PARENT_STATS,
a171 2

	IMSG_SMTP_STATS,
@


1.216
log
@no functionnal change, getting rid of deprecated prototypes
@
text
@d433 2
a434 2
struct message {
	TAILQ_ENTRY(message)		 entry;
d563 1
a563 1
	struct message			 s_msg;
d641 1
a641 1
	SPLAY_HEAD(msgtree, message)		 sc_messages;
d755 1
a755 1
	struct message			 msg;
d785 1
a785 1
	struct message		 msg;
d819 1
a819 1
	struct message			 message;
d874 1
a874 1
	TAILQ_HEAD(,message)	 recipients;
d937 1
a937 1
		struct message *);
d958 1
a958 1
int bounce_session(struct smtpd *, int, struct message *);
d960 1
a960 1
	struct message *);
d1048 2
a1049 2
void		 queue_submit_envelope(struct smtpd *, struct message *);
void		 queue_commit_envelopes(struct smtpd *, struct message *);
d1061 1
a1061 1
    struct message *);
d1063 1
a1063 1
    struct message *);
d1065 1
a1065 1
    u_int64_t, struct message *);
d1067 1
a1067 1
    struct message *);
d1071 1
a1071 1
void		 queue_message_update(struct smtpd *, struct message *);
d1075 1
a1075 1
int		 bounce_record_message(struct smtpd *, struct message *, struct message *);
d1099 1
a1099 1
void		 message_reset_flags(struct message *);
d1167 2
a1168 2
void		 message_set_errormsg(struct message *, char *, ...);
char		*message_get_errormsg(struct message *);
d1176 1
a1176 1
u_int32_t	 filename_to_msgpid(char *);
@


1.215
log
@whenever an envelope is reinserted into the ramqueue after a trip to mda or
mta, call runner_reset_events() so runner starts reprocessing ramqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.214 2011/04/15 17:01:05 gilles Exp $	*/
a1047 3
int		 queue_load_envelope(struct message *, char *);
int		 queue_update_envelope(struct message *);
int		 queue_remove_envelope(struct message *);
d1049 1
a1049 2
void		 queue_commit_envelopes(struct smtpd *, struct message*);
u_int16_t	 queue_hash(char *);
a1070 24
int		 queue_create_layout_message(char *, char *);
int		 queue_record_layout_envelope(char *, struct message *);
int		 queue_remove_layout_envelope(char *, struct message *);
int		 queue_commit_layout_message(char *, struct message *);
int		 queue_open_layout_messagefile(char *, struct message *);
int		 enqueue_create_layout(char *);
void		 enqueue_delete_message(char *);
int		 enqueue_record_envelope(struct message *);
int		 enqueue_remove_envelope(struct message *);
int		 enqueue_commit_message(struct message *);
int		 enqueue_open_messagefile(struct message *);
int		 bounce_create_layout(struct smtpd *, char *, struct message *);
void		 bounce_delete_message(char *);
int		 bounce_record_envelope(struct message *);
int		 bounce_remove_envelope(struct message *);
int		 bounce_commit_message(struct message *);
int		 bounce_record_message(struct smtpd *, struct message *, struct message *);
int		 queue_create_incoming_layout(char *);
void		 queue_delete_incoming_message(char *);
int		 queue_record_incoming_envelope(struct message *);
int		 queue_remove_incoming_envelope(struct message *);
int		 queue_commit_incoming_message(struct message *);
int		 queue_open_incoming_message_file(struct message *);
int		 queue_open_message_file(char *msgid);
a1071 1
void		 queue_delete_message(char *);
d1075 1
a1076 1
u_int16_t	 queue_hash(char *);
d1174 4
a1177 2
u_int32_t	evpid_to_msgid(u_int64_t);
u_int64_t	msgid_to_evpid(u_int32_t);
@


1.214
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.213 2011/04/14 23:26:16 gilles Exp $	*/
a444 3
//	char				 message_id[MAX_ID_SIZE];
//	char				 message_uid[MAX_ID_SIZE];

@


1.213
log
@- implement missing operations for fsqueue:
	fsqueue_envelope_create(), fsqueue_message_purge()
- kill deprecated functions in queue_shared.c

At this point fsqueue backend is almost complete, all that is left to do is
to move the qwalk() API inside the queue_backend API, then make sure smtpd
is no longer calling anything queue related directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.212 2011/04/14 22:46:38 gilles Exp $	*/
d43 1
a43 1
#define MAX_ID_SIZE		 64
d444 3
a446 2
	char				 message_id[MAX_ID_SIZE];
	char				 message_uid[MAX_ID_SIZE];
d592 1
a592 1
	char				m_id[MAX_ID_SIZE];
d600 1
a600 1
	char				 id[MAX_ID_SIZE];
d752 2
a753 1
		char			 msgid[MAX_ID_SIZE];
d938 1
a938 1
	int (*message)(struct smtpd *, enum queue_kind, enum queue_op, char *);
d1061 6
a1066 6
int	queue_message_create(struct smtpd *, enum queue_kind, char *);
int	queue_message_delete(struct smtpd *, enum queue_kind, char *);
int	queue_message_commit(struct smtpd *, enum queue_kind, char *);
int	queue_message_fd_r(struct smtpd *, enum queue_kind, char *);
int	queue_message_fd_rw(struct smtpd *, enum queue_kind, char *);
int	queue_message_purge(struct smtpd *, enum queue_kind, char *);
d1072 1
a1072 1
    char *, struct message *);
d1206 2
@


1.212
log
@no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.211 2011/04/14 22:36:09 gilles Exp $	*/
d929 2
a930 1
	QOP_FD_RW
d1064 1
a1074 2


a1076 1
void		 queue_delete_layout_message(char *, char *);
@


1.211
log
@- implement fsqueue_message_create() and fsqueue_message_commit()
- change a few prototypes to allow bounce messages to use the
	queue_backend API until it gets merged in
- kill functions of the queue API that have been deprecated
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.210 2011/04/14 20:11:08 gilles Exp $	*/
d934 1
a934 1
	int (*setup)(struct smtpd *);
@


1.210
log
@fsqueue queue backend will implement a filesystem queue:
- fsqueue->setup() performs the queue initialization;
- fsqueue->message() controls messages;
- fsqueue->envelope() controls envelopes;

This commit brings the following to fsbackend:
fsqueue_setup(), fsqueue_message_delete(), fsqueue_envelope_load(),
fsqueue_envelope_update(), fsqueue_envelope_delete().

It also makes smtpd use the queue_backend API for these operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.209 2011/04/14 17:06:43 gilles Exp $	*/
d1088 1
a1088 1
int		 bounce_create_layout(char *, struct message *);
d1093 1
a1093 1
int		 bounce_record_message(struct message *, struct message *);
@


1.209
log
@smtpd makes too many assumptions about the structure and layout of its
disk-based queue, it makes it near impossible to make changes to it without
editing twenty files... how am i going to implement mongodb support ? :-)

bring a new queue_backend API which hides the details of the disk-based
queue to smtpd. it is not "plugged in" yet and I'm filling the holes.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.208 2011/04/13 20:53:18 gilles Exp $	*/
d934 1
d1101 1
a1101 1
void		 queue_message_update(struct message *);
@


1.208
log
@following an idea from jacekm@@, smtpd now uses a ram-queue instead of doing
a continuous walk on the disk-queue. the implementation differs from what
jacekm@@ commited (and I backed out) a while ago in that it uses a queue and
a host tree required for upcoming features.

code will be improved in tree, it requires changes to be done in queue and
bounce API, I just wanted to commit a working version first ...

tested by todd@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.207 2011/04/02 16:40:19 eric Exp $	*/
d637 1
d905 34
d1053 19
@


1.207
log
@add stat counters for the lookup agent

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.206 2011/03/29 20:43:51 eric Exp $	*/
a73 2
#define PATH_RUNQUEUE		"/runqueue"

a463 17
enum batch_type {
	T_MDA_BATCH		= 0x1,
	T_MTA_BATCH		= 0x2,
	T_BOUNCE_BATCH		= 0x4
};

struct batch {
	SPLAY_ENTRY(batch)	 b_nodes;
	u_int64_t		 id;
	enum batch_type		 type;
	struct rule		 rule;
	struct smtpd		*env;
	char			 message_id[MAX_ID_SIZE];
	char			 hostname[MAXHOSTNAMELEN];
	TAILQ_HEAD(, message)	 messages;
};

a570 1
	struct batch			*batch;
d577 34
d636 2
a643 2

	SPLAY_HEAD(batchtree, batch)		 batch_queue;
d719 9
d737 1
a737 12
};

struct sched {
	int			fd;
	char			mid[MAX_ID_SIZE];
	int			ret;
};

struct remove {
	int			fd;
	char			mid[MAX_ID_SIZE];
	int			ret;
d883 1
a1016 2
int		 batch_cmp(struct batch *, struct batch *);
struct batch    *batch_by_id(struct smtpd *, u_int64_t);
d1038 1
a1038 1
int		 bounce_record_message(struct message *);
d1055 18
a1075 1
SPLAY_PROTOTYPE(batchtree, batch, b_nodes, batch_cmp);
@


1.206
log
@remove unused code now that reverse lookups are done through asr.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.205 2011/03/26 21:41:31 eric Exp $	*/
d695 10
d713 1
@


1.205
log
@missing file in previous commit

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.204 2011/03/26 10:59:59 gilles Exp $	*/
a1098 1
char		*ss_to_ptr(struct sockaddr_storage *);
@


1.204
log
@have the client API receive a stdio stream rather than a fd to the message
fd. this shifts responsibility for the fclose to the caller, prevents a
memory leak and makes everyone happy.

diff by Jared Yanovich, thanks !
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.203 2011/03/26 10:54:22 eric Exp $	*/
d814 1
@


1.203
log
@use an index for iterating into the mx list.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.202 2011/03/15 19:24:55 gilles Exp $	*/
d855 1
a855 1
	int			 datafd;
@


1.202
log
@let smtpd use user-provided Diffie-Hellman parameters for ephemeral key
exchange. if no DH parameters are found, fallback to builtin parameters
as was done until now.

since we now accept user-provided DH parameters, make smtpd more strict
and fatal() if the parameters are bogus.

bump the key size of the DH parameters from 512bits to 1024bits, it might
be bumped further after some more research.

thanks to mikeb@@ for his suggestions

diff ok mikeb@@ , man ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.201 2011/03/09 20:59:22 gilles Exp $	*/
a802 1
        struct mx *next;
d813 1
a813 1
        struct mx                       *mxcurrent;
@


1.201
log
@smtpctl show stats displays inet4/inet6 repartition for incoming sessions
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.200 2010/11/29 15:25:56 gilles Exp $	*/
d529 2
@


1.200
log
@replace the fork-based-non-blocking-resolver-hack by shiny async resolver
written by eric@@. it is still experimental but still better than what we
had earlier so ... we'll improve in tree :)

diff by me with *lots* of help from eric@@, tested by todd and I (and a
few people out there)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.199 2010/11/28 13:56:43 gilles Exp $	*/
d656 2
@


1.199
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.198 2010/11/24 23:27:04 todd Exp $	*/
d191 2
a192 2
	IMSG_DNS_A,
	IMSG_DNS_A_END,
d630 1
d742 2
d796 17
d826 5
a830 4
#define	MTA_FORCE_ANYSSL	0x1
#define	MTA_FORCE_SMTPS		0x2
#define	MTA_ALLOW_PLAIN		0x4
#define	MTA_USE_AUTH		0x8
d922 1
a922 1
void		 dns_query_a(struct smtpd *, char *, int, u_int64_t);
d951 1
d953 1
d1095 1
@


1.198
log
@add *maxactive stats
"ok and no need to keep them for yourself" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.197 2010/10/29 09:16:08 gilles Exp $	*/
a19 2
#include			 <imsg.h>

d30 2
d855 2
a857 1
extern void (*imsg_callback)(struct smtpd *, struct imsgev *, struct imsg *);
d867 1
d871 1
d876 15
d892 6
a897 13
/* log.c */
void		log_init(int);
void		log_verbose(int);
void		log_warn(const char *, ...)
    __attribute__ ((format (printf, 1, 2)));
void		log_warnx(const char *, ...)
    __attribute__ ((format (printf, 1, 2)));
void		log_info(const char *, ...)
    __attribute__ ((format (printf, 1, 2)));
void		log_debug(const char *, ...)
    __attribute__ ((format (printf, 1, 2)));
__dead void	fatal(const char *);
__dead void	fatalx(const char *);
d904 9
a912 3
		     u_int64_t);
void		 dns_async(struct smtpd *, struct imsgev *, int,
		     struct dns *);
d922 1
a925 7
/* smtpd.c */
int	 child_cmp(struct child *, struct child *);
SPLAY_PROTOTYPE(childtree, child, entry, child_cmp);
void	 imsg_event_add(struct imsgev *);
void	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t, pid_t,
	    int, void *, u_int16_t);
void	 imsg_dispatch(int, short, void *);
d932 12
d945 13
a957 2
pid_t		 mfa(struct smtpd *);
int		 msg_cmp(struct message *, struct message *);
d970 1
d1003 1
a1004 22
u_int16_t	queue_hash(char *);

/* map.c */
void		*map_lookup(struct smtpd *, objid_t, char *, enum map_kind);

/* mda.c */
pid_t		 mda(struct smtpd *);

/* mta.c */
pid_t		 mta(struct smtpd *);
int		 mta_session_cmp(struct mta_session *, struct mta_session *);
SPLAY_PROTOTYPE(mtatree, mta_session, entry, mta_session_cmp);

/* control.c */
pid_t		 control(struct smtpd *);
void		 session_socket_blockmode(int, enum blockmodes);
void		 session_socket_no_linger(int);
int		 session_socket_error(int);

/* enqueue.c */
int		 enqueue(int, char **);
int		 enqueue_offline(int, char **);
d1011 1
d1016 1
a1027 12
/* config.c */
#define		 PURGE_LISTENERS	0x01
#define		 PURGE_MAPS		0x02
#define		 PURGE_RULES		0x04
#define		 PURGE_SSL		0x08
#define		 PURGE_EVERYTHING	0xff
void		 purge_config(struct smtpd *, u_int8_t);
void		 unconfigure(struct smtpd *);
void		 configure(struct smtpd *);
void		 init_pipes(struct smtpd *);
void		 config_pipes(struct smtpd *, struct peer *, u_int);
void		 config_peers(struct smtpd *, struct peer *, u_int);
d1029 8
a1036 3
/* parse.y */
int		 parse_config(struct smtpd *, const char *, int);
int		 cmdline_symset(char *);
d1049 1
a1053 3
/* map.c */
struct map	*map_find(struct smtpd *, objid_t);
struct map	*map_findbyname(struct smtpd *, const char *);
@


1.197
log
@smtpd no longer knows a map called "secrets" which holds credentials for
authenticated relaying. one can create many maps holding credentials and
name them however he/she wants, just like any other map.

teach smtpd how to select a credentials map at the rule-level allowing a
setup to relay through the same MX with different credentials depending
on the source.

smtpd.conf.5 updated to reflect changes with help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.196 2010/10/28 21:15:50 gilles Exp $	*/
d106 3
d647 1
d649 1
d656 1
d660 1
d664 1
d681 1
d687 1
@


1.196
log
@teach smtpd how to handle per-rule delays for message expiry, this allows
some rules to have a longer expiry delay than the default:

	accept for [...] relay expire 8d  # will stay 8 days in queue

I added the man page bits so I don't forget but I need to reword it a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.195 2010/10/09 22:05:35 gilles Exp $	*/
d106 2
d118 1
a216 2
typedef u_int32_t		 objid_t;

d738 1
d818 1
@


1.195
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.185 2010/05/27 15:36:04 gilles Exp $	*/
d343 1
d456 1
@


1.194
log
@- fix a regression caused by latest commit (long story made short: do not
  attempt to expand the local delivery buffer when relaying mail, it was
  kind of ok before but no longer is)
- use the same buffer for local deliveries to files and commands

tested by jmc@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.193 2010/06/10 19:34:51 chl Exp $	*/
d26 4
d34 1
a34 1
#define PROC_COUNT		 8
d43 1
d48 1
a48 1
#define	MAX_RULEBUFFER_LEN	 256
d50 3
a52 1
#define SMTPD_EXPIRE		 (4 * 24 * 60 * 60)
d59 1
d61 3
d65 11
d77 1
d139 1
d141 1
a141 1
	IMSG_LKA_SECRET,
d143 1
a144 1
	IMSG_MFA_RCPT,
d146 6
a151 5
	IMSG_QUEUE_CREATE,
	IMSG_QUEUE_APPEND,
	IMSG_QUEUE_OPEN,
	IMSG_QUEUE_CLOSE,
	IMSG_QUEUE_DELETE,
d154 1
a154 1
	IMSG_QUEUE_PAUSE_RELAY,
d156 6
a161 1
	IMSG_QUEUE_RESUME_RELAY,
a167 1
	IMSG_BATCH_UPDATE,
d170 1
d229 2
a230 1
	PROC_CONTROL
d404 4
a407 4
struct action {
	SLIST_ENTRY(action)	 entry;
	u_int64_t		 id;
	char			 data[1];	/* actually bigger */
d410 8
a417 62
struct content {
	SLIST_HEAD(,action)	 actions;
	u_int64_t		 id;
	int		 	 ref;
	struct event		*ev;
};

#define NO_RETRY_EXPIRED	 0
#define RETRY_NOW		 1

struct batch {
	SLIST_ENTRY(batch)	 entry;
	SLIST_HEAD(,action)	 actions;
	struct content		*content;
	time_t			 retry;
	char			 sortkey[1];	/* actually bigger */
};

struct incoming {
	SLIST_ENTRY(incoming)	  entry;
	SLIST_HEAD(,batch)	  batches[3];
	struct content		 *content;
	char			**local;
	int			  local_sz;
	int			  nlocal;
};

#define Q_LOCAL		0
#define Q_RELAY		1
#define Q_BOUNCE	2

struct queue {
	SLIST_HEAD(,batch)	  head;
	struct event		  ev;
	struct smtpd		 *env;
	char			 *name;
	void			**session;
	int			  session_sz;
	size_t			  sessions;
	size_t			  max;
};

struct aux {
	char	*mode;
	char	*mail_from;
	char	*rcpt_to;
	char	*user_from;
	char	*user_to;
	char	*path;
	char	*rcpt;
	char	*relay_via;
	char	*port;
	char	*ssl;
	char	*cert;
	char	*auth;
};

struct bounce {
	struct event		 ev;
	struct batch		*batch;
	struct smtp_client	*pcb;
	int			 id;
d421 7
a427 6
	F_MESSAGE_AUTHENTICATED = 0x1
};

enum message_status {
	S_MESSAGE_PERMFAILURE   = 0x1,
	S_MESSAGE_TEMPFAILURE   = 0x2
d433 6
d441 2
a442 3
	u_int32_t			 id;		/* smtp session id */
	u_int32_t			 session_id;	/* smtp session id */
	u_int32_t			 queue_id;
d460 17
d561 1
a561 1
	u_int32_t			 s_id;
a586 3

	u_int32_t			 queue_id;
	u_int64_t			 content_id;
d602 2
a604 1
	int					 sc_qexpire;
d621 1
d635 8
a642 2
	size_t		length;
	size_t		inserts;
d680 1
d687 12
d709 1
d718 1
a718 1
	u_int32_t			 id;
d733 6
d741 1
a743 3
	time_t			 birth;
	u_int64_t		 content_id;
	u_int64_t		 action_id;
a744 2
	struct aux		 aux;
	char			*auxraw;
a748 1
	int			mode;
d751 1
d765 1
a765 1
	u_int32_t			 id;
d783 1
d791 6
a803 7
struct recipient {
	TAILQ_ENTRY(recipient)	 entry;
	u_int64_t		 action_id;
	char			 status[128];
	char			 address[1];	/* actually bigger */
};

d806 1
a806 1
	u_int32_t		 id;
d809 4
a812 5
	time_t			 birth;
	u_int64_t		 content_id;
	struct aux		 aux;
	char			*auxraw;
	TAILQ_HEAD(,recipient)	 recipients;
d818 1
d822 1
d908 1
d912 43
d977 5
d989 1
a989 1
void		 session_pickup(struct session *);
d1044 1
d1050 2
d1055 3
a1057 1
void		 sa_set_port(struct sockaddr *, char *);
a1061 4
int		 table_alloc(void ***, int *);
void		*table_lookup(void **, int, int);
void		 auxsplit(struct aux *, char *);
char		*rcpt_pretty(struct aux *);
@


1.193
log
@allow configure queue expiry

with help from jacekm@@

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.192 2010/06/09 20:00:55 zinovik Exp $	*/
d43 1
d306 1
a306 1
		char			 path[MAXPATHLEN];
a307 2
#define	MAXCOMMANDLEN	256
		char			 command[MAXCOMMANDLEN];
@


1.192
log
@switch `ref' data type to int, because it is tested for negative value in
queue_mem_content_unref() function

ok jacekm@@, gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.191 2010/06/01 23:06:25 jacekm Exp $	*/
d607 1
@


1.191
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.189 2010/06/01 14:21:52 jacekm Exp $	*/
d383 1
a383 1
	u_int32_t		 ref;
@


1.190
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.186 2010/05/31 22:25:26 chl Exp $	*/
a25 4
#define IMSG_SIZE_CHECK(p) do {					\
	if (IMSG_DATA_SIZE(&imsg) != sizeof(*p))		\
		fatalx("bad length imsg received");		\
} while (0)
d30 1
a30 1
#define PROC_COUNT		 9
a38 1
#define MAX_ID_SIZE		 64
d44 1
a44 3
#define SMTPD_QUEUE_INTERVAL	 (15 * 60)
#define SMTPD_QUEUE_MAXINTERVAL	 (4 * 60 * 60)
#define SMTPD_QUEUE_EXPIRY	 (4 * 24 * 60 * 60)
a50 1
#define	PATH_MAILLOCAL		"/usr/libexec/mail.local"
a51 3

#define	DIRHASH_BUCKETS		 4096

a52 11

#define PATH_ENQUEUE		"/enqueue"
#define PATH_INCOMING		"/incoming"
#define PATH_QUEUE		"/queue"
#define PATH_PURGE		"/purge"

#define PATH_MESSAGE		"/message"
#define PATH_ENVELOPES		"/envelopes"

#define PATH_RUNQUEUE		"/runqueue"

a53 1
#define PATH_BOUNCE		"/bounce"
d115 1
a116 2
	IMSG_LKA_RULEMATCH,
	IMSG_MDA_SESS_NEW,
d118 1
a119 1
	IMSG_MFA_MAIL,
d121 5
a125 6
	IMSG_QUEUE_CREATE_MESSAGE,
	IMSG_QUEUE_SUBMIT_ENVELOPE,
	IMSG_QUEUE_COMMIT_ENVELOPES,
	IMSG_QUEUE_REMOVE_MESSAGE,
	IMSG_QUEUE_COMMIT_MESSAGE,
	IMSG_QUEUE_TEMPFAIL,
d128 1
a128 1
	IMSG_QUEUE_PAUSE_OUTGOING,
d130 1
a130 6
	IMSG_QUEUE_RESUME_OUTGOING,

	IMSG_QUEUE_REMOVE_SUBMISSION,
	IMSG_QUEUE_MESSAGE_UPDATE,
	IMSG_QUEUE_MESSAGE_FD,
	IMSG_QUEUE_MESSAGE_FILE,
d137 1
a139 1
	IMSG_PARENT_ENQUEUE_OFFLINE,
d198 1
a198 2
	PROC_CONTROL,
	PROC_RUNNER,
d374 61
a434 4
enum message_type {
	T_MDA_MESSAGE		= 0x1,
	T_MTA_MESSAGE		= 0x2,
	T_BOUNCE_MESSAGE	= 0x4
d437 5
a441 8
enum message_status {
	S_MESSAGE_PERMFAILURE	= 0x2,
	S_MESSAGE_TEMPFAILURE	= 0x4,
	S_MESSAGE_REJECTED	= 0x8,
	S_MESSAGE_ACCEPTED	= 0x10,
	S_MESSAGE_RETRY		= 0x20,
	S_MESSAGE_EDNS		= 0x40,
	S_MESSAGE_ECONNECT	= 0x80
d445 6
a450 7
	F_MESSAGE_RESOLVED	= 0x1,
	F_MESSAGE_SCHEDULED	= 0x2,
	F_MESSAGE_PROCESSING	= 0x4,
	F_MESSAGE_AUTHENTICATED	= 0x8,
	F_MESSAGE_ENQUEUED	= 0x10,
	F_MESSAGE_FORCESCHEDULE	= 0x20,
	F_MESSAGE_BOUNCE	= 0x40
a455 6
	enum message_type		 type;

	u_int64_t			 id;
	u_int64_t			 session_id;
	u_int64_t			 batch_id;

d458 3
a460 2
	char				 message_id[MAX_ID_SIZE];
	char				 message_uid[MAX_ID_SIZE];
a477 17
enum batch_type {
	T_MDA_BATCH		= 0x1,
	T_MTA_BATCH		= 0x2,
	T_BOUNCE_BATCH		= 0x4
};

struct batch {
	SPLAY_ENTRY(batch)	 b_nodes;
	u_int64_t		 id;
	enum batch_type		 type;
	struct rule		 rule;
	struct smtpd		*env;
	char			 message_id[MAX_ID_SIZE];
	char			 hostname[MAXHOSTNAMELEN];
	TAILQ_HEAD(, message)	 messages;
};

d562 1
a562 1
	u_int64_t			 s_id;
d588 3
a605 1
	struct timeval				 sc_qintval;
a622 1
	SPLAY_HEAD(batchtree, batch)		 batch_queue;
d636 2
a637 8
	size_t		inserts_local;
	size_t		inserts_remote;
};

struct s_runner {
	size_t		active;
	size_t		bounces_active;
	size_t		bounces;
a674 1
	struct s_runner		 runner;
a680 12
struct sched {
	int			fd;
	char			mid[MAX_ID_SIZE];
	int			ret;
};

struct remove {
	int			fd;
	char			mid[MAX_ID_SIZE];
	int			ret;
};

a690 1
		char			 msgid[MAX_ID_SIZE];
d699 1
a699 1
	u_int64_t			 id;
a713 6
struct secret {
	u_int64_t		 id;
	char			 host[MAXHOSTNAMELEN];
	char			 secret[MAX_LINE_SIZE];
};

a715 1
	struct message		 msg;
d718 3
d722 2
d728 1
a730 1
	short			mode;
d744 1
a744 1
	u_int64_t			 id;
a761 1
	MTA_DATA,
a768 6
/* mta session flags */
#define	MTA_FORCE_ANYSSL	0x1
#define	MTA_FORCE_SMTPS		0x2
#define	MTA_ALLOW_PLAIN		0x4
#define	MTA_USE_AUTH		0x8

d776 7
d785 1
a785 1
	u_int64_t		 id;
d788 5
a792 4
	char			*host;
	int			 port;
	int			 flags;
	TAILQ_HEAD(,message)	 recipients;
a797 1
	char			*cert;
a800 1

a885 1
int		 msg_cmp(struct message *, struct message *);
a888 43
int		 queue_load_envelope(struct message *, char *);
int		 queue_update_envelope(struct message *);
int		 queue_remove_envelope(struct message *);
void		 queue_submit_envelope(struct smtpd *, struct message *);
void		 queue_commit_envelopes(struct smtpd *, struct message*);
int		 batch_cmp(struct batch *, struct batch *);
struct batch    *batch_by_id(struct smtpd *, u_int64_t);
u_int16_t	 queue_hash(char *);

/* queue_shared.c */
int		 queue_create_layout_message(char *, char *);
void		 queue_delete_layout_message(char *, char *);
int		 queue_record_layout_envelope(char *, struct message *);
int		 queue_remove_layout_envelope(char *, struct message *);
int		 queue_commit_layout_message(char *, struct message *);
int		 queue_open_layout_messagefile(char *, struct message *);
int		 enqueue_create_layout(char *);
void		 enqueue_delete_message(char *);
int		 enqueue_record_envelope(struct message *);
int		 enqueue_remove_envelope(struct message *);
int		 enqueue_commit_message(struct message *);
int		 enqueue_open_messagefile(struct message *);
int		 bounce_create_layout(char *, struct message *);
void		 bounce_delete_message(char *);
int		 bounce_record_envelope(struct message *);
int		 bounce_remove_envelope(struct message *);
int		 bounce_commit_message(struct message *);
int		 bounce_record_message(struct message *);
int		 queue_create_incoming_layout(char *);
void		 queue_delete_incoming_message(char *);
int		 queue_record_incoming_envelope(struct message *);
int		 queue_remove_incoming_envelope(struct message *);
int		 queue_commit_incoming_message(struct message *);
int		 queue_open_incoming_message_file(struct message *);
int		 queue_open_message_file(char *msgid);
void		 queue_message_update(struct message *);
void		 queue_delete_message(char *);
struct qwalk	*qwalk_new(char *);
int		 qwalk(struct qwalk *, char *);
void		 qwalk_close(struct qwalk *);
void		 show_queue(char *, int);

u_int16_t	queue_hash(char *);
a910 5
/* runner.c */
pid_t		 runner(struct smtpd *);
void		 message_reset_flags(struct message *);
SPLAY_PROTOTYPE(batchtree, batch, b_nodes, batch_cmp);

d918 1
a918 1
void		 session_pickup(struct session *, struct submit_status *);
a972 1
int		 safe_fclose(FILE *);
a977 2
int		 valid_message_id(char *);
int		 valid_message_uid(char *);
d981 1
a981 3
void		 message_set_errormsg(struct message *, char *, ...);
char		*message_get_errormsg(struct message *);
void		 sa_set_port(struct sockaddr *, int);
d986 4
@


1.189
log
@Schedule newly arrived mail immediately, ie. place it at the beginning
of the list of next items to try, or near the beginning if the schedule
contains expired mail, which is of highest priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.188 2010/05/31 23:50:28 jacekm Exp $	*/
d26 4
d34 1
a34 1
#define PROC_COUNT		 8
d43 1
d49 3
a51 1
#define SMTPD_EXPIRE		 (4 * 24 * 60 * 60)
d58 1
d60 3
d64 11
d76 1
d138 1
d140 1
a140 1
	IMSG_LKA_SECRET,
d142 1
a143 1
	IMSG_MFA_RCPT,
d145 6
a150 5
	IMSG_QUEUE_CREATE,
	IMSG_QUEUE_APPEND,
	IMSG_QUEUE_OPEN,
	IMSG_QUEUE_CLOSE,
	IMSG_QUEUE_DELETE,
d153 1
a153 1
	IMSG_QUEUE_PAUSE_RELAY,
d155 6
a160 1
	IMSG_QUEUE_RESUME_RELAY,
a166 1
	IMSG_BATCH_UPDATE,
d169 1
d228 2
a229 1
	PROC_CONTROL
d405 4
a408 4
struct action {
	SLIST_ENTRY(action)	 entry;
	u_int64_t		 id;
	char			 arg[];
d411 8
a418 62
struct content {
	SLIST_HEAD(,action)	 actions;
	u_int64_t		 id;
	u_int32_t		 ref;
	struct event		*ev;
};

#define NO_RETRY_EXPIRED	 0
#define RETRY_NOW		 1

struct batch {
	SLIST_ENTRY(batch)	 entry;
	SLIST_HEAD(,action)	 actions;
	struct content		*content;
	time_t			 retry;
	char			 sortkey[];
};

struct incoming {
	SLIST_ENTRY(incoming)	  entry;
	SLIST_HEAD(,batch)	  batches[3];
	struct content		 *content;
	char			**local;
	int			  local_sz;
	int			  nlocal;
};

#define Q_LOCAL		0
#define Q_RELAY		1
#define Q_BOUNCE	2

struct queue {
	SLIST_HEAD(,batch)	  head;
	struct event		  ev;
	struct smtpd		 *env;
	char			 *name;
	void			**session;
	int			  session_sz;
	size_t			  sessions;
	size_t			  max;
};

struct aux {
	char	*mode;
	char	*mail_from;
	char	*rcpt_to;
	char	*user_from;
	char	*user_to;
	char	*path;
	char	*rcpt;
	char	*relay_via;
	char	*port;
	char	*ssl;
	char	*cert;
	char	*auth;
};

struct bounce {
	struct event		 ev;
	struct batch		*batch;
	struct smtp_client	*pcb;
	int			 id;
d422 7
a428 6
	F_MESSAGE_AUTHENTICATED = 0x1
};

enum message_status {
	S_MESSAGE_PERMFAILURE   = 0x1,
	S_MESSAGE_TEMPFAILURE   = 0x2
d434 6
d442 2
a443 3
	u_int32_t			 id;		/* smtp session id */
	u_int32_t			 session_id;	/* smtp session id */
	u_int32_t			 queue_id;
d461 17
d562 1
a562 1
	u_int32_t			 s_id;
a587 3

	u_int32_t			 queue_id;
	u_int64_t			 content_id;
d603 1
d621 1
d635 8
a642 2
	size_t		length;
	size_t		inserts;
d680 1
d687 12
d709 1
d718 1
a718 1
	u_int32_t			 id;
d733 6
d741 1
a743 3
	time_t			 birth;
	u_int64_t		 content_id;
	u_int64_t		 action_id;
a744 2
	struct aux		 aux;
	char			*auxraw;
a748 1
	int			mode;
d751 1
d765 1
a765 1
	u_int32_t			 id;
d783 1
d791 6
a803 7
struct recipient {
	TAILQ_ENTRY(recipient)	 entry;
	u_int64_t		 action_id;
	char			 status[128];
	char			 address[];
};

d806 1
a806 1
	u_int32_t		 id;
d809 4
a812 5
	time_t			 birth;
	u_int64_t		 content_id;
	struct aux		 aux;
	char			*auxraw;
	TAILQ_HEAD(,recipient)	 recipients;
d818 1
d822 1
d908 1
d912 43
d977 5
d989 1
a989 1
void		 session_pickup(struct session *);
d1044 1
d1050 2
d1055 3
a1057 1
void		 sa_set_port(struct sockaddr *, char *);
a1061 4
int		 table_alloc(void ***, int *);
void		*table_lookup(void **, int, int);
void		 auxsplit(struct aux *, char *);
char		*rcpt_pretty(struct aux *);
@


1.188
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.187 2010/05/31 23:38:56 jacekm Exp $	*/
d388 1
@


1.187
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.186 2010/05/31 22:25:26 chl Exp $	*/
d52 1
a52 1
#define PATH_SPOOL		"/usr/obj/smtpd"
@


1.186
log
@imsg_compose_event() return value was never checked. Make it fatal() if needed.

ok jacekm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.185 2010/05/27 15:36:04 gilles Exp $	*/
a25 4
#define IMSG_SIZE_CHECK(p) do {					\
	if (IMSG_DATA_SIZE(&imsg) != sizeof(*p))		\
		fatalx("bad length imsg received");		\
} while (0)
d30 1
a30 1
#define PROC_COUNT		 9
a38 1
#define MAX_ID_SIZE		 64
d44 1
a44 3
#define SMTPD_QUEUE_INTERVAL	 (15 * 60)
#define SMTPD_QUEUE_MAXINTERVAL	 (4 * 60 * 60)
#define SMTPD_QUEUE_EXPIRY	 (4 * 24 * 60 * 60)
a50 1
#define	PATH_MAILLOCAL		"/usr/libexec/mail.local"
d52 1
a52 15

#define	DIRHASH_BUCKETS		 4096

#define PATH_SPOOL		"/var/spool/smtpd"

#define PATH_ENQUEUE		"/enqueue"
#define PATH_INCOMING		"/incoming"
#define PATH_QUEUE		"/queue"
#define PATH_PURGE		"/purge"

#define PATH_MESSAGE		"/message"
#define PATH_ENVELOPES		"/envelopes"

#define PATH_RUNQUEUE		"/runqueue"

a53 1
#define PATH_BOUNCE		"/bounce"
d115 1
a116 2
	IMSG_LKA_RULEMATCH,
	IMSG_MDA_SESS_NEW,
d118 1
a119 1
	IMSG_MFA_MAIL,
d121 5
a125 6
	IMSG_QUEUE_CREATE_MESSAGE,
	IMSG_QUEUE_SUBMIT_ENVELOPE,
	IMSG_QUEUE_COMMIT_ENVELOPES,
	IMSG_QUEUE_REMOVE_MESSAGE,
	IMSG_QUEUE_COMMIT_MESSAGE,
	IMSG_QUEUE_TEMPFAIL,
d128 1
a128 1
	IMSG_QUEUE_PAUSE_OUTGOING,
d130 1
a130 6
	IMSG_QUEUE_RESUME_OUTGOING,

	IMSG_QUEUE_REMOVE_SUBMISSION,
	IMSG_QUEUE_MESSAGE_UPDATE,
	IMSG_QUEUE_MESSAGE_FD,
	IMSG_QUEUE_MESSAGE_FILE,
d137 1
a139 1
	IMSG_PARENT_ENQUEUE_OFFLINE,
d198 1
a198 2
	PROC_CONTROL,
	PROC_RUNNER,
d374 60
a433 4
enum message_type {
	T_MDA_MESSAGE		= 0x1,
	T_MTA_MESSAGE		= 0x2,
	T_BOUNCE_MESSAGE	= 0x4
d436 5
a440 8
enum message_status {
	S_MESSAGE_PERMFAILURE	= 0x2,
	S_MESSAGE_TEMPFAILURE	= 0x4,
	S_MESSAGE_REJECTED	= 0x8,
	S_MESSAGE_ACCEPTED	= 0x10,
	S_MESSAGE_RETRY		= 0x20,
	S_MESSAGE_EDNS		= 0x40,
	S_MESSAGE_ECONNECT	= 0x80
d444 6
a449 7
	F_MESSAGE_RESOLVED	= 0x1,
	F_MESSAGE_SCHEDULED	= 0x2,
	F_MESSAGE_PROCESSING	= 0x4,
	F_MESSAGE_AUTHENTICATED	= 0x8,
	F_MESSAGE_ENQUEUED	= 0x10,
	F_MESSAGE_FORCESCHEDULE	= 0x20,
	F_MESSAGE_BOUNCE	= 0x40
a454 6
	enum message_type		 type;

	u_int64_t			 id;
	u_int64_t			 session_id;
	u_int64_t			 batch_id;

d457 3
a459 2
	char				 message_id[MAX_ID_SIZE];
	char				 message_uid[MAX_ID_SIZE];
a476 17
enum batch_type {
	T_MDA_BATCH		= 0x1,
	T_MTA_BATCH		= 0x2,
	T_BOUNCE_BATCH		= 0x4
};

struct batch {
	SPLAY_ENTRY(batch)	 b_nodes;
	u_int64_t		 id;
	enum batch_type		 type;
	struct rule		 rule;
	struct smtpd		*env;
	char			 message_id[MAX_ID_SIZE];
	char			 hostname[MAXHOSTNAMELEN];
	TAILQ_HEAD(, message)	 messages;
};

d561 1
a561 1
	u_int64_t			 s_id;
d587 3
a604 1
	struct timeval				 sc_qintval;
a621 1
	SPLAY_HEAD(batchtree, batch)		 batch_queue;
d635 2
a636 8
	size_t		inserts_local;
	size_t		inserts_remote;
};

struct s_runner {
	size_t		active;
	size_t		bounces_active;
	size_t		bounces;
a673 1
	struct s_runner		 runner;
a679 12
struct sched {
	int			fd;
	char			mid[MAX_ID_SIZE];
	int			ret;
};

struct remove {
	int			fd;
	char			mid[MAX_ID_SIZE];
	int			ret;
};

a689 1
		char			 msgid[MAX_ID_SIZE];
d698 1
a698 1
	u_int64_t			 id;
a712 6
struct secret {
	u_int64_t		 id;
	char			 host[MAXHOSTNAMELEN];
	char			 secret[MAX_LINE_SIZE];
};

a714 1
	struct message		 msg;
d717 3
d721 2
d727 1
a729 1
	short			mode;
d743 1
a743 1
	u_int64_t			 id;
a760 1
	MTA_DATA,
a767 6
/* mta session flags */
#define	MTA_FORCE_ANYSSL	0x1
#define	MTA_FORCE_SMTPS		0x2
#define	MTA_ALLOW_PLAIN		0x4
#define	MTA_USE_AUTH		0x8

d775 7
d784 1
a784 1
	u_int64_t		 id;
d787 5
a791 4
	char			*host;
	int			 port;
	int			 flags;
	TAILQ_HEAD(,message)	 recipients;
a796 1
	char			*cert;
a799 1

a884 1
int		 msg_cmp(struct message *, struct message *);
a887 43
int		 queue_load_envelope(struct message *, char *);
int		 queue_update_envelope(struct message *);
int		 queue_remove_envelope(struct message *);
void		 queue_submit_envelope(struct smtpd *, struct message *);
void		 queue_commit_envelopes(struct smtpd *, struct message*);
int		 batch_cmp(struct batch *, struct batch *);
struct batch    *batch_by_id(struct smtpd *, u_int64_t);
u_int16_t	 queue_hash(char *);

/* queue_shared.c */
int		 queue_create_layout_message(char *, char *);
void		 queue_delete_layout_message(char *, char *);
int		 queue_record_layout_envelope(char *, struct message *);
int		 queue_remove_layout_envelope(char *, struct message *);
int		 queue_commit_layout_message(char *, struct message *);
int		 queue_open_layout_messagefile(char *, struct message *);
int		 enqueue_create_layout(char *);
void		 enqueue_delete_message(char *);
int		 enqueue_record_envelope(struct message *);
int		 enqueue_remove_envelope(struct message *);
int		 enqueue_commit_message(struct message *);
int		 enqueue_open_messagefile(struct message *);
int		 bounce_create_layout(char *, struct message *);
void		 bounce_delete_message(char *);
int		 bounce_record_envelope(struct message *);
int		 bounce_remove_envelope(struct message *);
int		 bounce_commit_message(struct message *);
int		 bounce_record_message(struct message *);
int		 queue_create_incoming_layout(char *);
void		 queue_delete_incoming_message(char *);
int		 queue_record_incoming_envelope(struct message *);
int		 queue_remove_incoming_envelope(struct message *);
int		 queue_commit_incoming_message(struct message *);
int		 queue_open_incoming_message_file(struct message *);
int		 queue_open_message_file(char *msgid);
void		 queue_message_update(struct message *);
void		 queue_delete_message(char *);
struct qwalk	*qwalk_new(char *);
int		 qwalk(struct qwalk *, char *);
void		 qwalk_close(struct qwalk *);
void		 show_queue(char *, int);

u_int16_t	queue_hash(char *);
a909 5
/* runner.c */
pid_t		 runner(struct smtpd *);
void		 message_reset_flags(struct message *);
SPLAY_PROTOTYPE(batchtree, batch, b_nodes, batch_cmp);

d917 1
a917 1
void		 session_pickup(struct session *, struct submit_status *);
a971 1
int		 safe_fclose(FILE *);
a976 2
int		 valid_message_id(char *);
int		 valid_message_uid(char *);
d980 1
a980 3
void		 message_set_errormsg(struct message *, char *, ...);
char		*message_get_errormsg(struct message *);
void		 sa_set_port(struct sockaddr *, int);
d985 4
@


1.185
log
@when a rule has two conditions (ie: accept for { domain foo, domain bar } )
expand to two rules each having its own condition rather than one rule
with a tail queue of conditions. this simplifies code a bit and removes a
couple hacks.

basic testing by oga and me
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.184 2010/05/27 11:18:34 gilles Exp $	*/
d897 1
a897 1
int	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t, pid_t,
@


1.184
log
@struct opt as not used anywhere else, kill it, we can reintroduce it later
if we feel a need for it
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.183 2010/05/27 11:17:29 gilles Exp $	*/
d333 1
a333 1
	TAILQ_HEAD(condlist, cond)	 r_conditions;
a371 1
	struct cond			*cond;
@


1.183
log
@kill struct opt from struct rule, we don't use it, we don't need it
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.182 2010/04/27 10:17:53 gilles Exp $	*/
a311 10
};

enum opt_type {
	O_RWUSER,			/* rewrite user */
	O_RWDOMAIN,			/* rewrite domain */
};

struct opt {
	TAILQ_ENTRY(opt)		 o_entry;
	enum opt_type			 o_type;
@


1.182
log
@this commit enables "plain" as a backend for maps (that means aliases,
virtual AND secrets), adds a description in smtpd.conf.5 and removes a
mention to special map "aliases" which was removed a while ago.

to use plain maps:  map "myaliases" { source plain "/etc/mail/aliases" }

code diff was okayd a while ago by jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.181 2010/04/27 09:49:23 gilles Exp $	*/
a350 1
	TAILQ_HEAD(optlist, opt)	 r_options;
@


1.181
log
@initial work at fixing aliases support:
- kill struct alias, struct expandnode is used instead
- introduce map_parse_alias() and map_parse_virtual()
- aliases and virtual code no longer assume db(3) but use the map API which
  lets them become backend agnostic AND value-checked. this actually makes
  the code simpler by removing all values parsing from aliases.c
- rename K_SECRETS -> K_SECRET, K_ALIASES -> K_ALIAS for consistency the
  enum has singular names.
- aliases, virtual and forward now work with an expandtree and deal with
  multiple levels of resolving by merging expandtree's

more coming soon ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.180 2010/04/22 12:56:33 jacekm Exp $	*/
d247 1
a247 1
	S_FILE,
@


1.180
log
@Fix a case of runner trying to send imsg directly to smtp process instead
of forwarding it via queue.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.179 2010/04/21 21:47:39 gilles Exp $	*/
d254 1
a254 1
	K_ALIASES,
d256 1
a256 1
	K_SECRETS
d298 1
a298 6
	void *(*extract)(char *, size_t);
};

struct map_secret {
	char username[MAX_LINE_SIZE];
	char password[MAX_LINE_SIZE];
d407 2
a408 2
struct expand_node {
	RB_ENTRY(expand_node)	entry;
d415 1
a415 4
struct alias {
	enum expand_type type;
	union path_data		u;
};
d782 1
a782 1
	RB_HEAD(expandtree, expand_node)	expandtree;
d835 18
d861 1
a861 2
int alias_parse(struct alias *, char *);
void alias_to_expand_node(struct expand_node *, struct alias *);
d894 7
a900 6
int expand_cmp(struct expand_node *, struct expand_node *);
void expandtree_increment_node(struct expandtree *, struct expand_node *);
void expandtree_decrement_node(struct expandtree *, struct expand_node *);
void expandtree_remove_node(struct expandtree *, struct expand_node *);
struct expand_node *expandtree_lookup(struct expandtree *, struct expand_node *);
RB_PROTOTYPE(expandtree, expand_node, nodes, expand_cmp);
@


1.179
log
@introduce first map parser for maps of kind K_SECRETS !

map_parse_secret() converts a map value into a struct map_secret. lka no
longer needs to do any parsing, it simply calls map_lookup() with kind
K_SECRETS, checks if it returned a !NULL value, and call lka_encode_secret
to safely do the base64 encoding.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.178 2010/04/21 21:04:29 gilles Exp $	*/
a857 1
void bounce_process(struct smtpd *, struct message *);
@


1.178
log
@map.c is growing big, split it into three different files:
map.c contains the map API calls as usable by smtpd processes,
map_backend.c contains backend implementations and map_parser.c contains
parser implementations used internally by the map API
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.177 2010/04/21 19:53:16 gilles Exp $	*/
d301 5
d960 1
a960 1
char		*map_lookup(struct smtpd *, objid_t, char *, enum map_kind);
@


1.177
log
@map_lookup() takes an additionnal parameter of type enum map_kind which
will be used to select the appropriate map parser. make sure every call
to map_lookup() is updated. map_lookup() currently ignores the value.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.176 2010/04/21 19:45:07 gilles Exp $	*/
d288 13
d836 1
@


1.176
log
@introduce enum map_kind, the map_parsers array and map_parser_lookup()
which will be used to perform stronger checks on map values. they are
unused yet ...
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.175 2010/04/21 18:54:43 jacekm Exp $	*/
d255 2
a256 1
	K_CREDENTIALS
d941 1
a941 1
char		*map_lookup(struct smtpd *, objid_t, char *);
@


1.175
log
@Runner process is just a helper for queue, so tear down its imsg
channels to parent, mda, mta, lka, smtp, and control.  This leaves
just the channel to queue, which forwards imsgs on runner's behalf
and redirects any replies back to it.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.174 2010/04/20 15:34:56 jacekm Exp $	*/
d251 6
@


1.174
log
@Kill *2400* lines of code by abstracting common bits of the imsg handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.173 2010/04/19 10:12:48 gilles Exp $	*/
d152 4
d161 2
a162 5

	IMSG_RUNNER_UPDATE_ENVELOPE,
	IMSG_RUNNER_STATS,
	IMSG_RUNNER_SCHEDULE,
	IMSG_RUNNER_REMOVE,
a176 3
	IMSG_MDA_PAUSE,
	IMSG_MTA_PAUSE,
	IMSG_SMTP_PAUSE,
a178 4
	IMSG_MDA_RESUME,
	IMSG_MTA_RESUME,
	IMSG_SMTP_RESUME,

a179 1

d181 2
@


1.173
log
@basic support for SIZE extension, has been sitting in my tree for a month
or so ...

okayd by jacekm@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.172 2010/04/19 08:14:07 jacekm Exp $	*/
d205 2
d822 2
d881 1
@


1.172
log
@Simplify local delivery codepath:
- replace uses of struct batch in the parent with simpler struct delivery.
- replace IMSG_BATCH_* dance with single IMSG_MDA_SESS_NEW.
- make mda assume it delivers to external program over a pipe.
- fork helper process when delivering to maildir or a file.

New feature: upon external mda failure use last line of its output
as an error message.

With input and tests from nicm@@.

OK nicm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.171 2010/04/11 22:46:28 jacekm Exp $	*/
d590 1
@


1.171
log
@Increase limit on the length of "user" in user@@domain.com to a value
higher than specified in rfc.  Too many mailers don't conform to it,
and it is harmless as far as I can see.

From Tim van der Molen <tbvdm@@xs4all.nl>

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.170 2010/03/03 11:11:55 jacekm Exp $	*/
d140 2
a141 1
	IMSG_MDA_FINALIZE,
d170 1
a170 4
	IMSG_PARENT_MAILBOX_OPEN,
	IMSG_PARENT_MESSAGE_OPEN,
	IMSG_PARENT_MAILDIR_RENAME,
	IMSG_PARENT_MAILDIR_FAIL,
a409 1
	S_MESSAGE_LOCKFAILURE	= 0x1,
a466 1

a469 1

a470 1

a472 2

	struct message		 message;
a473 6

	FILE			*mboxfp;
	FILE			*datafp;
	struct msgbuf		 w;
	int			 cleanup_parent;
	struct event		 ev;
a484 1

d488 2
a489 1
	struct batch		 mda_batch;
d622 1
d734 15
@


1.170
log
@tweak mda.c rev. 1.36: eliminate risk of busy waiting for socket
to become writable, and make code more idiomatic.

tested by nicm@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.169 2010/02/17 13:47:31 gilles Exp $	*/
d41 1
a41 1
#define MAX_LOCALPART_SIZE	 65
@


1.169
log
@the map api becomes backend-agnostic with initial support for db(3) and
stdio(3) backends, though for now we only enable db(3). this is the first
commit of a serie to improve maps and everything related.

idea discussed with and diff okay jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.168 2010/01/10 16:42:35 gilles Exp $	*/
d485 1
a485 2
	void			*rbuf;
	int			 rbufsz;
@


1.168
log
@- teach runner how to remove a message from queue given a message id/uid
	and assuming message is not in processing/scheduled state
- teach smtpctl how to request message removal from runner

discussed with todd@@, idea ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.167 2010/01/03 14:37:37 chl Exp $	*/
d932 1
a932 2
char		*map_dblookup(struct smtpd *, objid_t, char *);
char		*map_dblookupbyname(struct smtpd *, char *, char *);
@


1.167
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.166 2009/12/24 14:19:46 gilles Exp $	*/
d160 1
d699 6
@


1.166
log
@kill PATH_RUNQUEUEHIGH and PATH_RUNQUEUELOW, i had great plans for them but
they're still unused months later and there's many ways to achieve having a
set of priorities on envelopes without needing additionnal queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.165 2009/12/14 19:56:55 jacekm Exp $	*/
d122 1
d831 1
@


1.165
log
@Tweak the logic behind setting the fd limits so that smtpd is less likely
to get upset by custom soft/hard ulimit settings.

Suggested by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.164 2009/12/14 18:21:53 jacekm Exp $	*/
a73 2
#define PATH_RUNQUEUEHIGH	"/runqueue-high"
#define PATH_RUNQUEUELOW	"/runqueue-low"
@


1.164
log
@Control maximum number of bounce sessions similarly to how the mta and mda
are now controlled.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.163 2009/12/14 16:44:14 jacekm Exp $	*/
d1029 1
a1029 1
void		 fdlimit(int);
@


1.163
log
@Impose sessions limit on the delivery sessions (mta and mda).
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.162 2009/12/14 13:17:51 jacekm Exp $	*/
d652 2
@


1.162
log
@Do non-blocking I/O when delivering locally over a pipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.161 2009/12/13 22:02:55 jacekm Exp $	*/
d165 1
d677 2
a678 1
	size_t		write_error;
@


1.161
log
@Use safe fd limits in smtp, lka, queue, and control.  Removes a
possibility for fd-starvation fatal when under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.160 2009/12/12 10:33:11 jacekm Exp $	*/
d484 2
d487 1
@


1.160
log
@Simplify client_* api, mainly by making fatal conditions result in immediate
fatals instead of passing the error up (kills ~300 lines).

Implement sending of the QUIT command which replaces crude close(2).

tested by gilles@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.159 2009/11/13 11:27:52 jacekm Exp $	*/
d676 5
d688 1
d946 1
d1022 2
@


1.159
log
@Log FQDN and IP of the server we handed mail to.  As a bonus, don't delay
logging of successful deliveries until all MXs were tried, plus add logging
of 5yz replies.

tested by todd@@, "reads ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.158 2009/11/09 23:49:34 gilles Exp $	*/
d796 1
a796 1
	void			*smtp_state;
@


1.158
log
@- add a reference count and flags to struct expand_node
- during expansion, no longer create a new node for each result but try to
  lookup for an existing equivalent node and increment its reference count
  so that: a) we save on memory, b) we don't need to expand the same users
  again and again just because they keep appearing in expansion results.
- while expanding, flag nodes as F_EXPAND_DONE so that we know which nodes
  we already processed
- be smarter when expanding, if we have a clue that an iteration has not
  brought any new result (because no new nodes were added and all existing
  nodes have F_EXPAND_DONE), end expansion and proceed to delivery.
- various small cleanups

discussed with jacekm@@ yesterday, rebuild aliases db, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.157 2009/11/08 23:20:07 gilles Exp $	*/
d763 1
d777 1
d792 1
@


1.157
log
@add an alias_to_expand_node() function and use it in aliases.c
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.156 2009/11/08 23:08:56 gilles Exp $	*/
d378 1
d386 5
d393 2
a394 1
	u_int64_t	        id;
d837 3
a839 2
void expandtree_insert(struct expandtree *, struct expand_node *);
void expandtree_remove(struct expandtree *, struct expand_node *);
@


1.156
log
@rework a bit expansion and data structures involved in the expansion so we
no longer have a direct mapping between structures saved in aliases/virtual
db and structures used at runtime during expansion.

side effects ? struct alias is smaller, databases are smaller and it is no
longer necessary to rebuild aliases/virtual databases each time jacekm@@ or
I make changes to some obscure structure used indirectely during expansion

rebuild databases, flush queues, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.155 2009/11/08 21:40:05 gilles Exp $	*/
d796 1
a796 5
int expand_cmp(struct expand_node *, struct expand_node *);
void expandtree_insert(struct expandtree *, struct expand_node *);
void expandtree_remove(struct expandtree *, struct expand_node *);
struct expand_node *expandtree_lookup(struct expandtree *, struct expand_node *);
RB_PROTOTYPE(expandtree, expand_node, nodes, expand_cmp);
d828 6
a833 1

@


1.155
log
@- make aliases expansion use a rb tree instead of a tail queue, the code
  doesn't take advantage of the new structure yet, but this was a needed
  change for upcoming improvements.
- introduce aliasestree_{lookup,insert,remove} to the aliases api
- rename queue_generate_id() to generate_uid() and move it to utils.c as
  it is used all over the place and not only in queue

tree idea discussed with jacekm@@, if you update rebuild aliases db, make
clean and flush queue
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.154 2009/11/08 19:38:26 gilles Exp $	*/
d352 12
d373 1
a373 4
	union path_data {
		char filename[MAXPATHLEN];
		char filter[MAXPATHLEN];
	}				 u;
d377 13
a389 6
enum alias_type {
	ALIAS_USERNAME,
	ALIAS_FILENAME,
	ALIAS_FILTER,
	ALIAS_INCLUDE,
	ALIAS_ADDRESS
d393 2
a394 9
	RB_ENTRY(alias)			entry;
	u_int64_t			 id;
	enum alias_type			 type;
	union alias_data {
		char username[MAXLOGNAME];
		char filename[MAXPATHLEN];
		char filter[MAXPATHLEN];
		struct path path;
	}                                   u;
d740 1
a740 1
	RB_HEAD(aliasestree, alias)	 aliasestree;
d791 1
a791 1
int aliases_get(struct smtpd *, objid_t, struct aliasestree *, char *);
d794 1
a794 1
int aliases_virtual_get(struct smtpd *, objid_t, struct aliasestree *, struct path *);
d796 5
a800 5
int alias_cmp(struct alias *, struct alias *);
void aliasestree_insert(struct aliasestree *, struct alias *);
void aliasestree_remove(struct aliasestree *, struct alias *);
struct alias *aliasestree_lookup(struct aliasestree *, struct alias *);
RB_PROTOTYPE(aliasestree, alias, entry, alias_cmp);
d835 1
a835 1
int forwards_get(int, struct aliasestree *);
@


1.154
log
@first commit of a serie to cleanup, simplify and improve aliases resolution
which is probably the most complex code in smtpd right now. no longer use a
single list to hold aliases to be resolved and resolved aliases, and do not
use struct alias to hold resolved aliases. instead use a delivery list that
is a list of struct path, and populate it with resolved aliases.

idea discussed with jacekm@@, this needs some testing to make sure it does
not introduce a regression with aliases. flush your queue and make clean.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.153 2009/11/05 10:27:24 gilles Exp $	*/
d377 2
a378 1
	TAILQ_ENTRY(alias)		entry;
a386 1
TAILQ_HEAD(aliaseslist, alias);
a728 1
	struct aliaseslist		 aliaseslist;
d730 3
d782 1
a782 1
int aliases_get(struct smtpd *, objid_t, struct aliaseslist *, char *);
d785 1
a785 1
int aliases_virtual_get(struct smtpd *, objid_t, struct aliaseslist *, struct path *);
d787 5
d826 1
a826 1
int forwards_get(int, struct aliaseslist *);
a845 1
u_int64_t	 queue_generate_id(void);
d993 1
@


1.153
log
@- move a couple prototypes in smtpd.h
- remove prototypes from deprecated functions
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.152 2009/11/03 22:57:41 gilles Exp $	*/
d349 1
d366 1
d730 1
d986 1
@


1.152
log
@teach makemap how to build a set, which is a map containing only keys.
smtpd is now capable of looking primary domains at runtime in a set, which
means that the following becomes possible:

	map "primary" { source db "/etc/mail/primary.db" }
	accept for domain map "primary" deliver to mbox

while at it fix a couple bugs in the aliases resolution path which caused
recipients to bounce if a ruleset did not have an "accept for local" rule

"diff reads good" jacekm@@, flush queue & make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.151 2009/11/03 20:55:23 gilles Exp $	*/
d840 2
@


1.151
log
@this commit removes the hardcoded special "aliases" map and brings support
for multiple aliases maps that can be attached at the rule level. with it,
you can for example define different aliases maps for different domains or
different aliases maps for the same domain depending on the client source:

map "localiases" { source db "/etc/mail/localiases.db" }
map "netaliases" { source db "/etc/mail/netaliases.db" }

accept from 192.168.0.0/16 for local alias "localiases" deliver to mbox
accept from all for local alias "netaliases" deliver to mbox

idea discussed with jacekm@@ and various other hackers, diff contains some
bug fixes too which were not part of the original diff. man page follows
very shortly ... make clean & flush queue !
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.150 2009/11/03 19:13:34 gilles Exp $	*/
d880 2
a881 1
char		*map_dblookup(struct smtpd *, char *, char *);
@


1.150
log
@- remove a useless member of struct cond
- have virtual related functions take a map id instead of a map
- shrink a tiny bit ruleset matching
- add missing lka_resolve_path() call in aliases resolution leading to
  issues spotted by nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.149 2009/10/19 20:48:13 gilles Exp $	*/
d338 1
d776 2
a777 2
int aliases_exist(struct smtpd *, char *);
int aliases_get(struct smtpd *, struct aliaseslist *, char *);
@


1.149
log
@currently, smtpd is capable of having multiple listeners with different
options but they will all share the same ruleset. this means that there
is no way to have a rule apply to a session established on one listener
but not applied on another.

this commit brings initial support for tagging listeners and having the
rules able to match these specific listeners. The following will define
a rule which will only apply to interfaces tagged as "mynet":

listen on lo0			# implicit lo0 tag
listen on fxp0 tag mynet
listen on fxp1 tag mynet

accept on mynet for domain "example.org" deliver to mbox
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.148 2009/10/19 20:00:46 gilles Exp $	*/
a295 1
	struct map			*c_match;
d777 3
a779 3
int aliases_vdomain_exists(struct smtpd *, struct map *, char *);
int aliases_virtual_exist(struct smtpd *, struct map *, struct path *);
int aliases_virtual_get(struct smtpd *, struct map *, struct aliaseslist *, struct path *);
@


1.148
log
@users within virtual domains do not necessarily map to a real user account,
teach smtpd how to deliver using specific user permissions:

	accept for virtual map "foo" deliver to maildir "/m/%d/%u" user foo

will deliver mail under /m/domain/user as user foo

idea and initial diff discussed with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.147 2009/10/12 22:34:37 gilles Exp $	*/
d44 1
d325 1
d422 2
d529 1
@


1.147
log
@- fix a null deref which could happen after a couple iterations of the
  aliases/virtual domains resolution code.

- fix a logic bug which caused virtual domains not to be correctly
  handled after one iteration of the aliases resolution code.

- introduce a few helper functions to help clean up and simplify the
  lka code.

- simplify the IS_EXT/IS_MAILBOX/IS_RELAY macros so they manipulate a
  struct path * instead of the mess of dereferences we were passing them.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.146 2009/10/11 17:40:49 gilles Exp $	*/
d335 2
@


1.146
log
@implement proper virtual domains instead of faking them on top of primary
domains. this means that:

- virtual domains no longer deliver to a local user when not told to
- they no longer attempt to resolve aliases when not told to
- they no longer need an explicit rule in smtpd.conf for EACH domain
- the "virtual" map is no longer hardcoded
- smtpd no longer needs a restart to support a new domain

instead we introduce the: accept for virtual map "mapname" [...] syntax
which refers to a map that can be manipulated at runtime.

idea discussed and okayd with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.145 2009/10/07 18:09:12 gilles Exp $	*/
d317 4
a320 3
#define IS_MAILBOX(x)	((x) == A_MAILDIR || (x) == A_MBOX || (x) == A_FILENAME)
#define IS_RELAY(x)	((x) == A_RELAY || (x) == A_RELAYVIA)
#define IS_EXT(x)	((x) == A_EXT)
@


1.145
log
@currently both mfa and lka perform ruleset matching for their own purposes.
make lka the only caller of ruleset_match(), mfa request match through imsg
which will shrink its code and help me implement virtual domains properly.

idea discussed with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.144 2009/09/23 09:40:39 jacekm Exp $	*/
d287 2
a288 1
	C_DOM
d349 1
d770 3
a772 2
int aliases_virtual_exist(struct smtpd *, struct path *);
int aliases_virtual_get(struct smtpd *, struct aliaseslist *, struct path *);
@


1.144
log
@Plug memleak.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.143 2009/09/15 16:50:06 jacekm Exp $	*/
d139 1
d701 5
@


1.143
log
@Extend SMTP client_* API to support SSL+AUTH, and use it in the mta
process to relay mails.  ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.142 2009/09/12 12:24:51 jacekm Exp $	*/
d454 2
a455 2
	int			 mboxfd;
	int			 datafd;
@


1.142
log
@Simplify line len checking: use one limit for all SMTP exchanges.
This is not as strict as various RFCs want it, but we can make it
more granular later.  For now, let all mails flow by using the
maximum of all limits found in the RFCs.
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.141 2009/09/12 09:38:45 gilles Exp $	*/
a47 2
/*#define SMTPD_CONNECT_TIMEOUT	 (60)*/
#define SMTPD_CONNECT_TIMEOUT	 (10)
a117 5
struct mxhost {
	TAILQ_ENTRY(mxhost)	 entry;
	struct sockaddr_storage ss;
};

a432 10
enum batch_status {
	S_BATCH_PERMFAILURE	= 0x1,
	S_BATCH_TEMPFAILURE	= 0x2,
	S_BATCH_REJECTED	= 0x4,
	S_BATCH_ACCEPTED	= 0x8,
	S_BATCH_RETRY		= 0x10,
	S_BATCH_EDNS		= 0x20,
	S_BATCH_ECONNECT	= 0x40
};

a449 3
	char			 errorline[MAX_LINE_SIZE];

	struct session		*sessionp;
a451 2
	struct message		*messagep;
	FILE			*messagefp;
a456 2

	enum batch_status	 status;
d476 2
a477 1
	S_INIT = 0,
a562 3

	char				 credentials[MAX_LINE_SIZE];

a563 1
	TAILQ_HEAD(mxhostlist, mxhost) mxhosts;
d603 1
d719 40
a819 2
int		 queue_remove_batch_message(struct smtpd *, struct batch *,
 		     struct message *);
a824 1
struct message	*message_by_id(struct smtpd *, struct batch *, u_int64_t);
d870 2
d876 2
a887 1

d962 1
@


1.141
log
@cmdlinetoolong stat was incremented at the wrong place, fix
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.140 2009/09/12 09:22:33 gilles Exp $	*/
d90 2
a91 4
/* rfc5321 limits */
#define	SMTP_DATALINE_MAX	1000
#define	SMTP_CMDLINE_MAX	512
#define	SMTP_ANYLINE_MAX	SMTP_DATALINE_MAX
a665 2
	size_t		cmdlinetoolong;
	size_t		datalinetoolong;
@


1.140
log
@- fix a compile time warning
- add a new stats counter to distinguish between command lines which
  exceeded the limit and data lines which exceeded the limits
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.139 2009/09/04 11:49:23 jacekm Exp $	*/
d667 1
@


1.139
log
@Major mda update:
- Fix: check external mda / mail.local exit code.
- Fix: check maildir rename(2) return code.
- Fix: check read(2) and write(2) return codes.
- Fix: in parent, batchp->env was not set to the env of the current process.
- Fix: clean file in tmp if maildir delivery fails.
- Fix: mark message as temporarily failed upon start, unmark upon sucessful
delivery. (safe default)
- Fix: kill all message drops, aka. PERMFAILUREs, with one exception: when the
local user no longer exists.
- Cleanup: store.c is merged with its only user, mda.c
- Feature: in parent, child_add now returns pointer to the new child struct.
This is used to store and later access child->mda_batch member in order to
associate children with their batches.
- Feature: in parent, external mda / mail.local will timeout after 5 minutes.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.138 2009/09/02 12:47:06 jacekm Exp $	*/
d91 1
a91 1
#define	SMTP_TEXTLINE_MAX	1000
d93 1
a93 1
#define	SMTP_ANYLINE_MAX	SMTP_TEXTLINE_MAX
d667 2
a668 1
	size_t		linetoolong;
@


1.138
log
@Include mbox write errors in "show stats".  Suggested by gilles.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.137 2009/08/27 11:37:30 jacekm Exp $	*/
d148 1
a148 2
	IMSG_MDA_MAILBOX_FILE,
	IMSG_MDA_MESSAGE_FILE,
d177 2
a178 1
	IMSG_PARENT_MAILBOX_RENAME,
a457 15
enum child_type {
	CHILD_INVALID,
	CHILD_DAEMON,
	CHILD_MDA,
	CHILD_ENQUEUE_OFFLINE
};

struct child {
	SPLAY_ENTRY(child)	entry;

	pid_t			pid;
	enum child_type		type;
	enum smtp_proc_type	title;
};

d478 4
d485 16
a888 7

/* store.c */
int file_copy(FILE *, FILE *, struct path *, enum action_type, int);
int store_write_header(struct batch *, struct message *, FILE *, int);
int store_write_message(struct batch *, struct message *);
int store_write_daemon(struct batch *, struct message *);
int store_message(struct batch *, struct message *);
@


1.137
log
@Implement client side of the SMTP protocol in a library-like module.
Make bounce code and /usr/sbin/sendmail interface use this new API.
The mta process continues to use its own implementation, but
eventually will be switched to use this shared module.

Buffer routines are taken from buffer.c rather than from evbuffer.
This is one step forward to using a single buffer API across the
program.

"it looks sexy" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.136 2009/08/27 09:21:28 jacekm Exp $	*/
d666 4
d675 1
@


1.136
log
@getpwnam failure that results in setting errno could confuse the
check for non-existent ~/.forward, so make the check more robust;
fix a fd leak under rare circumstances; use secure_file for
testing .forward file security.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.135 2009/08/07 19:02:55 gilles Exp $	*/
d862 1
@


1.135
log
@wrap auth_userokay in a new function authenticate_user() and make sure
that only authenticate.c knows about bsd_auth, no functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.134 2009/08/06 16:46:57 gilles Exp $	*/
d942 1
a942 1
int		 secure_file(int, char *, struct passwd *);
@


1.134
log
@- change all occurences of T_DAEMON_BATCH,MESSAGE to T_BOUNCE_BATCH/MESSAGE
- make sure T_BOUNCE_MESSAGE is no longer OR-ed to T_MDA/MTA_MESSAGE
- define F_MESSAGE_BOUNCE flag and make sure bounce sessions set it
- teach smtpctl show queue how to recognize a bounce message
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.133 2009/08/06 14:27:41 gilles Exp $	*/
d743 3
@


1.133
log
@factorize file_copy_session() and file_copy() so file_copy() can handle
both deliveries to mailboxes (mbox/maildir) and copying to a session.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.132 2009/08/06 14:12:48 gilles Exp $	*/
d390 1
a390 1
	T_DAEMON_MESSAGE	= 0x4
d410 2
a411 1
	F_MESSAGE_FORCESCHEDULE	= 0x20
d455 1
a455 1
	T_DAEMON_BATCH		= 0x4
@


1.132
log
@- introduce message_set_errormsg() to set the error description that will
  appear in a bounce message, and message_get_errormsg() to retrieve that
  message.
- when loop is detected, call message_set_errormsg()
- in mta, call message_set_errormsg() for each recipient failure
- in mta, call message_set_errormsg() to copy batch errors to recipients if
  we failed to deliver for a session related error
- when bouncing, add the recipient and error reason to the bounce message
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.131 2009/08/06 13:40:45 gilles Exp $	*/
d876 1
a876 2
int
file_copy_session(struct smtpd *, FILE *, FILE *);
@


1.131
log
@This commit reworks the entire mailer daemon support to actually make it
work for real. As an added bonus, it simplifies it, makes it follow the
same code path as regular messages and kills quite some code from mta,
mda and store. There's still some work needed but the most painful part
is behind us now ;)

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.130 2009/07/28 22:03:55 gilles Exp $	*/
d941 2
@


1.130
log
@introduce daemon_record_message() and needed glue in queue_shared.c to
atomically create a mailer daemon out of a message. it is unreferenced
for now, this commit makes no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.129 2009/06/26 11:48:00 okan Exp $	*/
d79 1
a79 1
#define PATH_DAEMON		"/daemon"
d609 1
a609 1
						     [PROC_COUNT];
d743 5
d817 6
a822 6
int		 daemon_create_layout(char *, struct message *);
void		 daemon_delete_message(char *);
int		 daemon_record_envelope(struct message *);
int		 daemon_remove_envelope(struct message *);
int		 daemon_commit_message(struct message *);
int		 daemon_record_message(struct message *);
d876 2
d881 1
a881 2
int store_message(struct batch *, struct message *,
    int (*)(struct batch *, struct message *));
@


1.129
log
@locally define nitems() macro, #ifndef'd.

"please commit" gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.128 2009/06/06 18:31:42 pyr Exp $	*/
d79 1
d812 6
@


1.128
log
@Get ready for including imsg.h from a lib, when it comes along.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.127 2009/06/06 04:14:21 pyr Exp $	*/
d21 4
@


1.127
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.126 2009/06/05 20:43:57 pyr Exp $	*/
d20 1
a20 1
#include			 "imsg.h"
@


1.126
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.125 2009/06/05 08:50:00 pyr Exp $	*/
d203 8
d215 1
a215 1
	struct imsgbuf		 ibuf;
d605 1
a605 1
	struct imsgbuf				*sc_ibufs[PROC_COUNT];
d758 1
a758 1
void		 dns_async(struct smtpd *, struct imsgbuf *, int,
d768 2
a769 2
void	 imsg_event_add(struct imsgbuf *); /* needs to be provided externally */
int	 imsg_compose_event(struct imsgbuf *, u_int16_t, u_int32_t, pid_t,
@


1.125
log
@Destroy gilles' fantasy function.
ok by a desillusionned gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.124 2009/06/03 22:04:15 jacekm Exp $	*/
d20 8
a30 1
#define READ_BUF_SIZE		 32768
a121 55
/* buffer specific headers */
struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 max;
	size_t			 wpos;
	size_t			 rpos;
	int			 fd;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

struct buf_read {
	u_char			 buf[READ_BUF_SIZE];
	u_char			*rptr;
	size_t			 wpos;
};

struct imsg_fd  {
	TAILQ_ENTRY(imsg_fd)	 entry;
	int			 fd;
	u_int32_t		 id;
};

struct imsgbuf {
	TAILQ_HEAD(, imsg_fd)	 fds;
	struct buf_read		 r;
	struct msgbuf		 w;
	struct event		 ev;
	void			(*handler)(int, short, void *);
	int			 fd;
	pid_t			 pid;
	short			 events;
	void			*data;
	u_int32_t		 id;
};

struct imsg_hdr {
	u_int16_t		 type;
	u_int16_t		 len;
	u_int32_t		 peerid;
	pid_t			 pid;
};

struct imsg {
	struct imsg_hdr		 hdr;
	u_int32_t		 id;
	void			*data;
};

a197 9
#define IMSG_HEADER_SIZE	 sizeof(struct imsg_hdr)
#define IMSG_DATA_SIZE(imsg)	((imsg)->hdr.len - IMSG_HEADER_SIZE)
#define	MAX_IMSGSIZE		 16384

#define IMSG_SIZE_CHECK(p) do {						\
	if (IMSG_DATA_SIZE(&imsg) != sizeof(*p))			\
		fatalx("bad length imsg received");			\
} while (0)

a744 12
/* buffer.c */
struct buf	*buf_open(size_t);
struct buf	*buf_dynamic(size_t, size_t);
int		 buf_add(struct buf *, void *, size_t);
void		*buf_reserve(struct buf *, size_t);
int		 buf_close(struct msgbuf *, struct buf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);


a756 20

/* imsg.c */
void	 imsg_init(struct imsgbuf *, int, void (*)(int, short, void *));
ssize_t	 imsg_read(struct imsgbuf *);
ssize_t	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    int, void *, u_int16_t);
int	 imsg_composev(struct imsgbuf *, enum imsg_type, u_int32_t,
	    pid_t, int, const struct iovec *, int);
struct buf *imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    u_int16_t);
int	 imsg_add(struct buf *, void *, u_int16_t);
int	 imsg_append(struct imsgbuf *, struct buf *);
int	 imsg_close(struct imsgbuf *, struct buf *);
void	 imsg_free(struct imsg *);
void	 imsg_event_add(struct imsgbuf *); /* needs to be provided externally */
int	 imsg_get_fd(struct imsgbuf *, struct imsg *);
int	 imsg_flush(struct imsgbuf *);
void	 imsg_clear(struct imsgbuf *);

d760 3
@


1.124
log
@simplify struct batch; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.123 2009/06/03 18:16:29 gilles Exp $	*/
a834 2
int	 imsg_compose_fds(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    void *, u_int16_t, int, ...);
@


1.123
log
@rename sc_config to sc_conffile since that's what this field is about, it
will prevent a confusion with sc_config which will be a pointer to the
actual configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.122 2009/06/02 22:23:36 gilles Exp $	*/
a500 7
enum batch_flags {
	F_BATCH_COMPLETE	= 0x1,
	F_BATCH_RESOLVED	= 0x2,
	F_BATCH_SCHEDULED	= 0x4,
	F_BATCH_EXPIRED		= 0x8,
};

a519 1
	u_int64_t		 session_id;
d521 1
a521 3
	enum batch_flags	 flags;

	struct rule			 rule;
d523 1
a523 1
	struct smtpd			*env;
d525 3
a527 11
	char				 message_id[MAX_ID_SIZE];
	char				 hostname[MAXHOSTNAMELEN];
	char				 errorline[MAX_LINE_SIZE];

	char				 session_helo[MAXHOSTNAMELEN];
	char				 session_hostname[MAXHOSTNAMELEN];
	struct sockaddr_storage		 session_ss;

	time_t				 creation;
	time_t				 lasttry;
	u_int8_t			 retry;
d529 1
a529 1
	struct session			*sessionp;
d531 4
a534 4
	struct message			message;
	struct message			*messagep;
	FILE				*messagefp;
	TAILQ_HEAD(messagelist, message) messages;
d536 1
a536 1
	enum batch_status		status;
@


1.122
log
@make env->sc_listeners and env->sc_ssl pointers, one step further toward
configuration reloading without killing active sessions; ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.121 2009/06/01 18:24:01 deraadt Exp $	*/
d656 1
a656 1
	char					 sc_config[MAXPATHLEN];
@


1.121
log
@No need for save_getpwuid and such functions which call endpwent.
endpwent is not needed unless setpwent (with stayopen = 1) or getpwent
was used.  getpwuid/getpwnam do not use getpwent; i think people must
be assuming this.  we are going to improve the man pages for this.
ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.120 2009/05/30 23:53:41 gilles Exp $	*/
d678 1
a678 1
	TAILQ_HEAD(listenerlist, listener)	 sc_listeners;
d683 1
a683 1
	SPLAY_HEAD(ssltree, ssl)		 sc_ssl;
@


1.120
log
@It is now possible to specify a certificate to use when relaying to another
host which requests client certificates:

	accept [...] relay via [...] ssl certificate "mycert"

diff from Josh Elsasser <josh@@elsasser.org>, tested and okayed by me with
no change but the addition of status 554 to the state machine to deal with
remote host telling us it doesn't like our certificate.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.119 2009/05/28 08:50:08 jacekm Exp $	*/
a1011 2
struct passwd 	*safe_getpwnam(const char *);
struct passwd 	*safe_getpwuid(uid_t);
@


1.119
log
@Log the incoming message size; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.118 2009/05/27 13:11:39 jacekm Exp $	*/
d88 3
d107 1
d586 1
d987 1
a987 1
int	 ssl_load_certfile(struct smtpd *, const char *);
@


1.118
log
@After a successful AUTH command completes, reject any further AUTH commands.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.117 2009/05/27 13:09:07 jacekm Exp $	*/
d636 1
@


1.117
log
@request flood mitigation:
1) each state may have 2 responses sent quickly;
2) more responses are delayed exponentially, up to a defined limit.

Delay count is user visible (smtp.errors.delays).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.116 2009/05/25 14:00:36 jacekm Exp $	*/
d92 2
a93 1
	((s)->s_l->flags & F_AUTH && ((s)->s_flags & F_SECURE))
@


1.116
log
@merge smtp_listener_setup into its only caller; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.115 2009/05/24 15:47:31 jacekm Exp $	*/
d70 7
a76 1
#define MAX_MX_COUNT	10
d572 1
d633 1
d717 1
@


1.115
log
@Parent process shouldn't be base64-decoding untrusted strings, move
this code to privsep smtp process; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.114 2009/05/24 14:38:56 jacekm Exp $	*/
a928 1
void		 smtp_listener_setup(struct smtpd *, struct listener *);
@


1.114
log
@Parent process forks 3 types of processes, track them all in a single tree
using newly introduced child struct.

Manage process titles centrally in struct smtpd.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.113 2009/05/24 14:22:24 jacekm Exp $	*/
d590 5
a594 8
struct session_auth_req {
	u_int64_t	session_id;
	char		buffer[MAX_LINE_SIZE];
};

struct session_auth_reply {
	u_int64_t	session_id;
	u_int8_t	value;
d628 1
a628 1
	struct session_auth_req		 s_auth;
@


1.113
log
@Instead of keeping stats private to each process, and querying every
process individually whenever stats need to be fetched, keep stats
in MAP_ANON shared memory allocated by parent.

This means control has direct access to stats and can respond very
quickly without troubling any other daemon processes.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.112 2009/05/20 14:29:44 gilles Exp $	*/
d499 1
d504 2
a505 2
struct mdaproc {
	SPLAY_ENTRY(mdaproc)	mdaproc_nodes;
d509 1
d663 1
d673 3
a675 3
	SPLAY_HEAD(batchtree, batch)		batch_queue;
	SPLAY_HEAD(mdaproctree, mdaproc)	mdaproc_queue;
	SPLAY_HEAD(lkatree, lkasession)		lka_sessions;
d853 4
a912 2
int		 mdaproc_cmp(struct mdaproc *, struct mdaproc *);
SPLAY_PROTOTYPE(mdaproctree, mdaproc, mdaproc_nodes, mdaproc_cmp);
d961 1
a961 1
void		 init_peers(struct smtpd *);
d984 1
a984 1
/* smtpd.c */
@


1.112
log
@first step towards configuration reload in smtpd, smtpctl reload will parse
the configuration file again and replace current configuration with new one
in all processes. what we don't support yet is graceful restart, clients in
sessions at the moment of the reload will have a temp failure thrown at 'em
which is ok RFC-wise but which we will try to improve anyway.

tested with various setups, "diff reads good" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.111 2009/05/19 11:42:52 jacekm Exp $	*/
d673 2
d712 5
a716 8
	int			fd;
	union u_stats {
		struct s_parent	parent;
		struct s_queue	queue;
		struct s_runner	runner;
		struct s_session smtp;
		struct s_session mta;
	}			u;
@


1.111
log
@- Don't advertise nor accept STARTTLS command when session is secure.
- Make the condition when STARTTLS and AUTH are advertised & accepted
more readable.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.110 2009/05/19 11:37:44 jacekm Exp $	*/
d170 1
d172 1
d642 2
d664 2
a665 2
	TAILQ_HEAD(maplist, map)		*sc_maps;
	TAILQ_HEAD(rulelist, rule)		*sc_rules;
d723 5
@


1.110
log
@Do not ever run /usr/sbin/sendmail, it could link to sendmail
interface for a different MTA. Use the binary in /usr/libexec
directly instead.

Based on remark claudio@@ made in passing.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.109 2009/05/19 11:24:24 jacekm Exp $	*/
d82 5
@


1.109
log
@Verify the amount of IMSG payload is exactly as expected; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.108 2009/05/18 20:23:35 jacekm Exp $	*/
d49 1
@


1.108
log
@Complete rework of bufferevent event masking allowing for  more
strictness:
- Drop clients attempting command pipelining; protects the daemon
from all kinds of abuse.
- Replace F_EVLOCKED flag with F_WRITEONLY which has cleaner sematics:
when up, session must not be destroyed nor read from, but may be
written to.
- Write callback becomes a central place for enabling EV_READ.
- Delay bufferevent creation until after ssl handshake is completed.

A bunch of session error stats were added to smtpctl's "show stats".
These could help spotting event masking errors in the future.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.107 2009/05/09 20:03:07 jacekm Exp $	*/
d228 1
d230 5
@


1.107
log
@give few states more meaningful names; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.106 2009/05/09 17:04:55 jacekm Exp $	*/
a549 1
#define	IS_AUTH(x)	((x) == S_AUTH_INIT || (x) == S_AUTH_USERNAME || (x) == S_AUTH_PASSWORD || (x) == S_AUTH_FINALIZE)
d592 1
a592 1
	F_EVLOCKED	= 0x80
d682 9
a690 2
	size_t		aborted;
	size_t		timeout;
d916 1
@


1.106
log
@- New API to handle all DNS query types (A, MX, PTR) asynchronously.

- Improve RFC compliance: CNAMEs are resolved, equal preference MXs
are randomized, relaying via MX that has equal/lower preference
than local server is prevented, decision on when to treat domain
name as implicit MX is better.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.105 2009/04/28 23:11:25 gilles Exp $	*/
d539 2
a540 1
	S_MAILREQUEST,
d542 1
a542 1
	S_RCPTREQUEST,
a543 1
	S_DATAREQUEST,
d545 1
@


1.105
log
@smtp auth happened to work by luck because delivery to mbox action was the
first action of an enum and we allocated a struct using calloc, but we did
not properly initialize the action for authenticated users.

while at it, change the name of path action flags so that we know at first
sight that they are path related.

this diff fixes the immediate issue but still needs work.
ok jacekm@@, "we'll work out a long term solution"
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.104 2009/04/24 10:02:35 jacekm Exp $	*/
a68 1
#define MXARRAYSIZE	5
a94 1
	u_int8_t flags;
a95 1
	char credentials[MAX_LINE_SIZE];
d171 1
a171 3
	IMSG_LKA_MX,
	IMSG_LKA_MX_END,
	IMSG_LKA_HOST,
d219 6
a224 1
	IMSG_SMTP_ENQUEUE
d617 2
d722 8
a729 4
struct mxreq {
	u_int64_t id;
	char hostname[MAXHOSTNAMELEN];
	struct rule rule;
d732 4
a735 4
struct mxrep {
	u_int64_t id;
	int getaddrinfo_error;
	struct mxhost mxhost;
d790 6
a795 1
int		 getmxbyname(char *, char ***);
@


1.104
log
@Make aliases case-insensitive, issue reported by Daniel Ouelett; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.103 2009/04/24 08:35:48 jacekm Exp $	*/
d363 7
a369 6
	F_ALIAS = 0x1,
	F_VIRTUAL = 0x2,
	F_EXPANDED = 0x4,
	F_NOFORWARD = 0x8,
	F_FORWARDED = 0x10,
	F_ACCOUNT = 0x20,
@


1.103
log
@use same timeout at each session state, and make use of
bufferevent_settimeout instead of rolling our own; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.102 2009/04/24 08:32:12 jacekm Exp $	*/
d966 1
@


1.102
log
@kill unnecessary struct message_recipient; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.101 2009/04/21 18:12:05 jacekm Exp $	*/
a604 1
	struct event			 s_timeout;
@


1.101
log
@Make /usr/sbin/sendmail not fail due to smtpd being down.

The approach is to save cmdline + stdin in a file under a newly
added directory /var/spool/smtpd/offline (uid 0 gid 0 mode 1777).
Next time daemon starts, it uses information in that directory
to replay sendmail on user's behalf.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.100 2009/04/20 17:07:01 jacekm Exp $	*/
a710 8
	struct message			 msg;
};

struct message_recipient {
	u_int64_t			 id;
	struct sockaddr_storage		 ss;
	enum message_flags		 flags;
	struct path			 path;
@


1.100
log
@Rewrite smtp session timeouts; use evtimer_* from event(3) instead
of regularly walking session tree in search of idle clients. Gives
the smtp process a chance to become idle.

As a bonus, add smtp.sessions.timeout counter to "smtpctl show stats".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.99 2009/04/16 15:35:06 jacekm Exp $	*/
d66 2
d203 1
d482 6
d492 1
d885 4
@


1.99
log
@Total rewrite of the sendmail interface. Adds support for -t, -v,
and -F cmdline args. Also, date and Message-Id headers are added
when missing.

The main trouble with the current enqueue code is that it requires
dealing with problems in the control process that are already solved
in the smtp process, ie. duplicating a lot of code which interacts
with untrusted clients. This diff solves this by making sendmail
obtain a SMTP socket from smtp via smtpd.sock, and using that socket
to deliver the message. For smtpd it looks as if connection was
made from the network, only difference being the F_MESSAGE_ENQUEUED
message flag, handy when differentation between local and remote
deliveries is wanted.

Most of the features come from the femail program, created by henning@@.

Additional testing by Nigel J. Taylor.

ok gilles@@, henning@@ happy with smtpd using femail code
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.98 2009/04/15 20:34:59 jacekm Exp $	*/
a589 1
	time_t				 s_tm;
d595 1
d671 1
@


1.98
log
@s/ssmtp/smtps/; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.97 2009/04/09 19:49:34 jacekm Exp $	*/
d219 3
a221 1
	IMSG_STATS
a231 8
enum ctl_state {
	CS_NONE = 0,
	CS_INIT,
	CS_RCPT,
	CS_FD,
	CS_DONE
};

a236 1
	enum ctl_state		 state;
@


1.97
log
@change syntax of the "listen on" and "relay via" directives:
1) kill the ssmtp keyword in "ssmtp listen on ...";
2) kill the use keyword in "... use certificate foo";
3) tls no longer implicit, user must explicitely use the tls or smtps option.
4) for "relay via", move the tls/smtps options to right after the
port specification; makes it similar to "listen on".

These directives:

  ssmtp listen on fxp0 use ceritifate "foo"
  accept for all relay via tls "mx.bar.com"

now become:

  listen on fxp0 smtps certificate "foo"
  accept for all relay via "mx.bar.com" tls

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.96 2009/03/22 22:53:47 gilles Exp $	*/
d671 2
a672 2
	size_t		ssmtp;
	size_t		ssmtp_active;
@


1.96
log
@fix a bug in the resolution of forward files which would cause usernames
not to be taken into account if they had no ~/.forward file AND were the
result of an alias expansion that expanded to more than one username.

while at it, I spotted another bug where I would check T_MDA_MESSAGE on
the flags field instead of the type field. the bug could cause two MDA
message to end up in the same batch which is no longer valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.95 2009/03/19 20:27:49 jacekm Exp $	*/
d76 1
a76 1
#define F_SSMTP			 0x02
d78 1
a78 1
#define F_SSL			(F_SSMTP|F_STARTTLS)
@


1.95
log
@make action_type == 0 mean A_INVALID, not A_RELAY; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.94 2009/03/15 19:32:11 gilles Exp $	*/
d720 1
@


1.94
log
@since we are going to share code in smtp sessions and mta sessions, we need
to also share the statistics structure, still being worked on
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.93 2009/03/15 19:15:25 gilles Exp $	*/
d339 1
@


1.93
log
@the mda process no longer uses struct batch as its central structure to
deal with deliveries, it now uses struct session just like mta and smtp
processes. we now keep the mbox and message descriptors in the session,
saving space in struct message which is now as small as we can make it.
While at it, plugged a memory leak and did some cosmethic changes

This was the last planned change to our struct message which means that
later changes will no longer require a queue flush before rebuild.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.92 2009/03/15 18:12:15 gilles Exp $	*/
d666 1
a666 1
struct s_smtp {
d685 2
a686 1
		struct s_smtp	smtp;
@


1.92
log
@save 4 bytes per message by moving the datafp field of struct message to
struct session where it really belongs.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.91 2009/03/12 11:08:26 pea Exp $	*/
a459 3

	int				 mboxfd;
	int				 messagefd;
d617 2
@


1.91
log
@Add new function time_to_text to correctly display the date.
Use it to display the date in received from header and when we
store headers.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.90 2009/03/10 22:33:26 jacekm Exp $	*/
a460 1
	FILE				*datafp;
d618 2
@


1.90
log
@implement basic logging, needs more work; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.89 2009/03/09 23:35:04 jacekm Exp $	*/
d962 1
@


1.89
log
@run external mda directly, not via sh -c; this steals addargs() API
from OpenSSH; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.88 2009/03/09 16:31:09 jacekm Exp $	*/
d613 1
a613 1
	u_int32_t			 rcptcount;
@


1.88
log
@Drop ALIAS_TEXT, plain maps got implemented in a different way; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.87 2009/03/09 01:43:19 gilles Exp $	*/
d942 8
@


1.87
log
@add basic support for outgoing authentication (AUTH PLAIN over ssl) which
can be turned on by adding "enable auth" to a "relay via" rule. this made
me rework the mx resolution so that it is done by the mta process and not
the runner process anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.86 2009/03/08 20:39:49 gilles Exp $	*/
a36 3
/* makemap mapped value text length */
#define MAX_MAKEMAP_SIZE	 256

d393 1
a393 2
	ALIAS_ADDRESS,
	ALIAS_TEXT
a402 1
		char text[MAX_MAKEMAP_SIZE];
@


1.86
log
@when operating in enqueue mode, it was easy to make smtpctl fatal() by
writing a small app that sent out of order imsg's. prevent this by use
of a state machine and read event masking.

issue spotted by jacekm@@, temporary fix by me. there are ideas around
this, but we want to experiment them a bit and they are low priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.85 2009/03/08 19:11:22 gilles Exp $	*/
d71 1
d96 1
d99 1
d176 1
a519 5
	int8_t				 getaddrinfo_error;
	struct mxhost			 mxarray[MXARRAYSIZE*2];
	u_int8_t			 mx_cnt;
	u_int8_t			 mx_off;

d595 2
a596 1
	F_EVLOCKED	= 0x40
a621 4
	struct mxhost			*mxarray;
	u_int8_t			 mx_cnt;
	u_int8_t			 mx_off;

d623 1
a623 1

d724 12
@


1.85
log
@shrink struct message a bit by removing a couple fields which are no longer
used and by moving the rcpt count in struct session where it really belongs

while at it, remove some unused splay tree generation in mfa
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.84 2009/03/08 17:54:20 gilles Exp $	*/
d229 8
d242 1
@


1.84
log
@~/.forward files handling was fixed recently so that it is the privileged
process that does the opening, this commit does some cleanup, and fixes a
bug I experienced today which was caused by a use-after-free.

I did some testing to make sure a user cannot cause smtpd to deadlock, or
loop, with broken setups (self-referencing forwards/aliases, empty files,
broken files...), but if you are playing with aliases/forwards PLEASE let
me know of any bug you run into.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.83 2009/03/06 23:45:00 gilles Exp $	*/
a426 1
	SPLAY_ENTRY(message)		 nodes;
a445 3
	TAILQ_HEAD(pathlist,path)	 recipients;

	u_int16_t			 rcptcount;
d452 1
d609 1
a808 1
SPLAY_PROTOTYPE(msgtree, message, nodes, msg_cmp);
@


1.83
log
@missing prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.82 2009/03/03 23:33:52 gilles Exp $	*/
a622 22
struct forward_req {
	u_int64_t			 id;
	char				 pw_name[MAXLOGNAME];
};

enum lkasession_flags {
	F_ERROR		= 0x1
};

struct lkasession {
	SPLAY_ENTRY(lkasession)		 nodes;
	u_int64_t			 id;

	struct path			 path;
	struct aliaseslist		 aliaseslist;
	u_int8_t			 iterations;
	u_int32_t			 pending;
	enum lkasession_flags		 flags;
	struct message			 message;
	struct submit_status		 *ss;
};

d718 21
@


1.82
log
@when forwards/aliases expansion fails in an lka session, make sure that mfa
is notified so that the session does not hang
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.81 2009/03/03 23:23:52 gilles Exp $	*/
d855 3
@


1.81
log
@Fix a long standing issue where ~/.forward files were opened by user _smtpd
causing them not to be handled when a user's homedir is set to mode 0700. I
still need to do some cleanup and make sure it works as it should, but this
diff provides better behavior than what we had.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.80 2009/03/03 15:47:27 gilles Exp $	*/
d642 1
@


1.80
log
@fix mbox locking by having it done by mail.local(8) which in turns uses
lockspool(1). this means our mbox delivery follows a code path that has
become almost identical to external mda deliveries. this is the first
of a serie of diffs actually...

lockspool(1) suggestion by deraadt@@, mail.local(8) idea by jacekm@@, and
fix and testing by me
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.79 2009/03/01 21:58:53 jacekm Exp $	*/
d200 1
d623 21
d673 1
d779 1
a779 1
int forwards_get(struct aliaseslist *, char *);
d805 2
@


1.79
log
@- Refuse delivery to mbox that is a symlink, pipe, chardev, etc. etc.
- Introduce secure_file, based on secure_filename from OpenSSH, it
checks that mbox has right perms, and that path components are
trustworthy, too.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.78 2009/03/01 12:12:58 jacekm Exp $	*/
d50 2
@


1.78
log
@In "smtpctl show stats", break queue.inserts into queue.inserts.remote
and queue.inserts.local; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.77 2009/02/24 12:07:47 gilles Exp $	*/
d915 1
@


1.77
log
@teach smtpctl's parser how to deal with parameters that are not necessarily
a token so that it is possible to do: smtpctl schedule <message id/uid>

introduce F_MESSAGE_FORCESCHEDULE which lets the runner schedule a message
even if the retry delay has not been expired.

F_MESSAGE_ENQUEUED is a valid flag for a message and should not cause an\
errx() in smtpctl show queue
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.75 2009/02/22 11:59:12 jacekm Exp $	*/
d656 2
a657 1
	size_t		inserts;
@


1.76
log
@add valid_message_id() and valid_message_uid() which test that a message id
and uid do not look wrong. this was not needed earlier because we only deal
with message id's coming from trusted sources, but smtpctl will soon have a
new feature which requires us to deal with user provided message id's.
@
text
@d192 1
d419 2
a420 1
	F_MESSAGE_ENQUEUED	= 0x10
d684 6
@


1.75
log
@put repeated inet_ntop calls into new func ss_to_text, which uses
getnameinfo internally; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.74 2009/02/19 11:33:25 jacekm Exp $	*/
d904 2
@


1.74
log
@don't let libevent buffer long lines forever; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.73 2009/02/18 22:39:12 jacekm Exp $	*/
d903 1
@


1.73
log
@- add basic syntax checking to mfa
- decline source routing at MAIL FROM, strip at RCPT TO

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.72 2009/02/17 23:43:57 jacekm Exp $	*/
d73 1
@


1.72
log
@make newaliases read aliases path from smtpd.conf; idea discussed with
gilles@@, pyr@@ and henning@@, diff ok gilles@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.71 2009/02/15 13:12:19 jacekm Exp $	*/
d900 2
@


1.71
log
@If MX query fails due to DNS error, do not attempt more queries; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.70 2009/02/15 10:32:23 jacekm Exp $	*/
a65 4

/* used by newaliases */
#define	PATH_ALIASES		"/etc/mail/aliases"
#define	PATH_ALIASESDB		"/etc/mail/aliases.db"
@


1.70
log
@New config.c that allows for process cloning. Done by pyr@@ for
relayd at n2k9, and adapted to smtpd; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.69 2009/02/14 18:37:12 jacekm Exp $	*/
d744 1
a744 1
size_t getmxbyname(char *, char ***);
@


1.69
log
@Implement makemap -t and -o, for output type and dest resp.; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.68 2009/01/30 21:52:55 gilles Exp $	*/
d634 2
a635 2
	int					 sc_pipes[PROC_COUNT]
						    [PROC_COUNT][2];
d637 2
d870 1
@


1.68
log
@when decreasing ssl related counters, make sure the session was flagged as
F_SECURE. while at it, add "smtp.sessions.aborted" which keeps track of
sessions which were interrupted before completion.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.67 2009/01/30 21:40:21 gilles Exp $	*/
d37 3
d382 2
a383 1
	ALIAS_ADDRESS
d393 1
@


1.67
log
@improve statistics for smtp process. not only collect the current sessions
count, but also the total sessions count, ssmtp sessions (both current and
total) and starttls sessions (both current and total)

# ./smtpctl/smtpctl show stats|grep smtp.sessions
smtp.sessions = 0
smtp.sessions.active = 0
smtp.sessions.ssmtp = 0
smtp.sessions.ssmtp.active = 0
smtp.sessions.starttls = 0
smtp.sessions.starttls.active = 0
#
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.66 2009/01/30 21:22:33 gilles Exp $	*/
d666 2
@


1.66
log
@clear the F_EVLOCK flag earlier to prevent the error event handler from
being called again with F_EVLOCK set. this fixes a bug where disconnect
after smtpd sends greeting and before entering any command failed to go
into session_destroy().

while at it, rename the "smtp.clients" statistic to "smtp.sessions" and
add counters to struct s_smtp so that I can add ssmtp and starttls with
my next commit ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.65 2009/01/30 20:11:13 form Exp $	*/
d659 2
d662 2
d665 1
@


1.65
log
@Do not break header for messages received via smtp.

look ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.64 2009/01/30 17:34:58 gilles Exp $	*/
d658 3
a660 1
	size_t		clients;
@


1.64
log
@bump descriptors limit to the max and set the maximum connections count to
three quarters of that limit (a session typically has 3 descriptors). when
we hit that limit, we stop accepting connections, and when client closes a
session, we start accepting connections again. this prevents us from going
into a session that is likely to fail because of scarce resources.

idea discussed with jacekm@@, code mostly ripped from relayd
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.63 2009/01/30 16:37:52 gilles Exp $	*/
d838 1
a838 1
int store_write_header(struct batch *, struct message *, FILE *);
@


1.63
log
@fix a very annoying events masking issue which would cause a fatal() to be
hit under certain conditions; while tracking the bug I ran into other bugs
which were kind of related and could cause us to hit a fatal() too.

fix by me, but with lots of testing and investigation with jacekm@@,
ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.62 2009/01/29 21:59:15 jacekm Exp $	*/
d627 1
@


1.62
log
@Implement "smtpctl show stats"; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.61 2009/01/29 15:40:35 gilles Exp $	*/
d582 2
a583 1
	F_PEERHASTLS	= 0x20
@


1.61
log
@missing prototype for session_respond() in mta, move session_respond()'s
prototype to smtpd.h
spotted and diff from Oleg Safiullin <form@@pdp-11.org.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.60 2009/01/29 15:20:34 gilles Exp $	*/
d183 1
d191 1
d200 1
d208 1
d212 3
a214 1
	IMSG_SMTP_RESUME
d641 26
@


1.60
log
@Received header line was incomplete for mail submitted through the enqueuer
as well as for some outgoing messages, this is fixed now
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.59 2009/01/29 14:25:55 gilles Exp $	*/
d798 3
@


1.59
log
@initial starttls support in mta, this allows:

	accept for domain "openbsd.org" relay via tls "mx.example.org"

to ensure the relaying of mail for whoever@@openbsd.org will happen through
a secure tls (STARTTLS) session. failure to establish a tls session will be
considered as a permanent failure. As a side effect:

	accept for domain "openbsd.org" relay via ssl "mx.example.org"

can now work as well and ensure that the relaying happens through ssmtp OR
tls, but never through an unsafe channel. no need to specify a port, they
are automatically detected if not specified.

still a work in progress, don't expect that it will work flawlessly.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.58 2009/01/29 13:00:12 gilles Exp $	*/
d492 4
@


1.58
log
@bring initial support for SSL in the mta part of smtpd, allowing for:

	accept for domain "openbsd.org" relay via ssmtp "mx1.example.org"

to ensure that deliveries for whatever@@openbsd.org goes through an SSL session
to mx1.example.org
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.57 2009/01/29 12:43:25 jacekm Exp $	*/
d571 2
a572 1
	F_AUTHENTICATED	= 0x10
@


1.57
log
@Common queue walking code for smtpd and smtpctl. Kills majority of showqueue.c,
the remaining code was moved to queue_shared.c; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.56 2009/01/28 23:13:42 gilles Exp $	*/
a595 1
	int				 peerfd;
@


1.56
log
@mta session state belongs to struct session, not struct batch, remove the
state field from struct batch and propagate the change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.55 2009/01/28 22:54:10 gilles Exp $	*/
d740 25
a764 21
int		queue_create_layout_message(char *, char *);
void		queue_delete_layout_message(char *, char *);
int		queue_record_layout_envelope(char *, struct message *);
int		queue_remove_layout_envelope(char *, struct message *);
int		queue_commit_layout_message(char *, struct message *);
int		queue_open_layout_messagefile(char *, struct message *);
int		enqueue_create_layout(char *);
void		enqueue_delete_message(char *);
int		enqueue_record_envelope(struct message *);
int		enqueue_remove_envelope(struct message *);
int		enqueue_commit_message(struct message *);
int		enqueue_open_messagefile(struct message *);
int		queue_create_incoming_layout(char *);
void		queue_delete_incoming_message(char *);
int		queue_record_incoming_envelope(struct message *);
int		queue_remove_incoming_envelope(struct message *);
int		queue_commit_incoming_message(struct message *);
int		queue_open_incoming_message_file(struct message *);
int		queue_open_message_file(char *msgid);
void		queue_message_update(struct message *);
void		queue_delete_message(char *);
@


1.55
log
@everything we need for the event handling dance is in struct session, the
write handler has been changed to set the bufferevent that's in there
rather than the one in struct batch. since struct batch is no longer doing
anything useful for events handling, we can remove many fields of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.54 2009/01/28 21:44:15 gilles Exp $	*/
a486 1
	u_int8_t			 state;
@


1.54
log
@first steps towards better mta code. currently mta uses struct batch to
store a lot of its session related code, but this is just not right and
this commit starts making mta code aware of struct session. This will
ease the implementation of ssl sessions in mta.

while at it, make mta autodetect port to use if it isn't provided in a
rule but can be derived from a parameter (i.e: "relay via ssmtp ...").
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.53 2009/01/28 19:38:46 gilles Exp $	*/
a486 4
	struct event			 ev;
	struct timeval			 tv;
	int				 peerfd;
	struct bufferevent		*bev;
d503 2
d597 1
@


1.53
log
@when pausing listeners, do not simply disable their events as new
clients would still be able to connect. instead, at pause time we
close and remove the listeners, and at resume time we request the
parent to reconfigure all listeners.

discussed with pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.52 2009/01/28 17:29:11 jacekm Exp $	*/
d481 1
d598 7
@


1.52
log
@Make races between queue and runner impossible by implementing the policy:
1) queue never reads /queue.
2) queue writes to /queue only at message injection time.
3) runner does all reading, and all writing apart from 2).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.51 2009/01/28 13:29:40 gilles Exp $	*/
d200 1
@


1.51
log
@bring loop detection support. we handle this with a qmail-like approach which
consists of checking headers for a custom header, but we also count how many
hops the mail went through and use a hard limit (currently set to 100 as was
recommanded by RFC) as a safe-guard.

idea discussed with jacekm@@, qmail approach suggested by claudio@@ a long time
ago
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.50 2009/01/28 12:58:17 gilles Exp $	*/
d188 2
@


1.50
log
@move some functions from queue.c to queue_shared.c as they are not only
used by queue process but also by runner, while at it change the prototype
of queue_open_message_file() so it takes the message id and not a batch,
runner process requires the decriptor before it even starts building a
batch.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.49 2009/01/28 11:27:57 gilles Exp $	*/
d25 2
@


1.49
log
@add a struct path to struct message so that we can keep track of the RCPT
provided recipient even after aliases/forwards expansion, we'll need this
for loop detection.

message id and uid being MAXPATHLEN long is a waste, define MAX_ID_SIZE
which is currently set to 64 (but can probably be further reduced) and
make sure that structures and the few strlcpy's use the right define.

original idea by jacekm@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.48 2009/01/27 22:48:29 gilles Exp $	*/
d728 1
a728 1
/* sharedqueue.c */
d747 4
@


1.48
log
@first bricks of enqueue code which allows smtpctl to submit mail to queue
without "talking" smtp to listeners. currently, a big part of the server
side code is done (and requires a cleanup), next step is to get it usable
properly from a mail user agent.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.47 2009/01/26 22:20:31 gilles Exp $	*/
d30 1
d418 2
a419 2
	char				 message_id[MAXPATHLEN];
	char				 message_uid[MAXPATHLEN];
d425 1
d488 1
a488 1
	char				 message_id[MAXPATHLEN];
d627 1
a627 1
		char			 msgid[MAXPATHLEN];
@


1.47
log
@move some queue related functions that are needed outside of smtpd to the
sharedqueue.c file, smtpctl cannot link queue.o without creating a mess
otherwise. while at it, move some prototypes to smtpd.h as they will be
needed by enqueue code
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.46 2009/01/14 23:48:35 gilles Exp $	*/
d403 2
a404 1
	F_MESSAGE_AUTHENTICATED	= 0x8
d733 12
d822 1
d824 1
@


1.46
log
@live testing shows that some clients will not even send EHLO if banner does
not contain ESMTP. Now that we support some extensions, let's just say that
we are ESMTP ...
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.45 2009/01/08 19:17:31 jacekm Exp $	*/
d49 1
d724 9
@


1.45
log
@ensure getpwnam is always followed by endpwent; ok gilles@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.44 2009/01/04 22:35:09 gilles Exp $	*/
d41 1
a41 1
#define SMTPD_BANNER		 "220 %s OpenSMTPD"
@


1.44
log
@- smtp can now pause/resume the accepting of incoming messages
- smtpctl recognizes "pause incoming" and "resume incoming"
- setup imsg communication between control process and smtp process
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.43 2009/01/04 19:37:41 gilles Exp $	*/
d795 1
a795 1
int		bsnprintf(char *, size_t, const char *, ...)
d797 3
a799 2
int		safe_fclose(FILE *);
int		hostname_match(char *, char *);
@


1.43
log
@- runner is now capable of pausing/resuming the scheduling of deliveries
for both mda and mta batches.
- smtpctl can be used to disable/enable deliveries at runtime using the
pause/resume commands.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.42 2009/01/04 19:25:19 jacekm Exp $	*/
d195 7
a201 4
	IMSG_RUNNER_PAUSE_MDA,
	IMSG_RUNNER_PAUSE_MTA,
	IMSG_RUNNER_RESUME_MDA,
	IMSG_RUNNER_RESUME_MTA
d598 1
@


1.42
log
@kill F_MESSAGE_EXPIRED; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.41 2009/01/04 17:45:58 gilles Exp $	*/
d193 1
a193 1
	IMSG_PARENT_AUTHENTICATE
d195 4
d593 2
@


1.41
log
@When matching a recipient domain to a rule, do not use strcasecmp, but use
new hostname_match() function which recognizes * as a wildcard. We can now
do: accept for domain "*.example.org" to match all subdomains.

idea from Nicholas Marriott <nicholas.marriott@@gmail.com>, hostname_match()
from me in place of his fnmatch() calls.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.40 2009/01/04 16:40:58 gilles Exp $	*/
d393 3
a395 4
	F_MESSAGE_EXPIRED	= 0x2,
	F_MESSAGE_SCHEDULED	= 0x4,
	F_MESSAGE_PROCESSING	= 0x8,
	F_MESSAGE_AUTHENTICATED	= 0x10
@


1.40
log
@- change name of "masked" member in struct netaddr, it was misleading
- allow "from all" so that the ugly "accept from { 0.0.0.0/0, ::/0 }"
construct becomes a nice looking "accept from all"

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.39 2009/01/04 14:46:14 jacekm Exp $	*/
d789 1
@


1.39
log
@cleanup; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.38 2009/01/04 00:58:59 gilles Exp $	*/
d79 1
a79 1
	int masked;
@


1.38
log
@aliases/forwards expansion was not done correctly and a race could
cause delivery to happen before expansion is over, causing some of
the recipients to never receive the mail. change how the mfa, lka,
queue and smtp processes communicate to ensure smtp never receives
an acknowledgment before ALL expanded envelopes are on disk. While
at it, lka was doing work which belongs in mfa, fix that also.

this is based on an idea from a talk with jacekm@@, change not over
but already better than what we had.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.37 2008/12/27 17:36:37 jacekm Exp $	*/
a165 1
	IMSG_LKA_ALIAS,
a166 1
	IMSG_LKA_FORWARD,
@


1.37
log
@cleanup; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.36 2008/12/27 17:03:29 jacekm Exp $	*/
d177 1
d180 1
d196 1
d338 2
a339 1
	F_FORWARDED = 0x10
d621 1
d629 1
@


1.36
log
@Merge hash() and queue_message_hash() into one func, queue_hash(). Fix callers
to use this interface consistently; ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.35 2008/12/26 10:28:31 jacekm Exp $	*/
d701 5
a708 1
int		 queue_remove_batch_message(struct smtpd *, struct batch *, struct message *);
@


1.35
log
@parse.y doesn't allow listen backlog configuration, so "bzero default" is used.
Hardcode it instead: 5 is a popular choice across the tree; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.34 2008/12/21 02:18:46 gilles Exp $	*/
d705 1
@


1.34
log
@- AUTH PLAIN may receive credentials as a parameter to AUTH or on a
	following line, this commit brings support for the latter which was
	not supported yet.
- AUTH LOGIN is now supported, allowing smtp auth support on clients that
	do not support AUTH PLAIN (ie: my mobile phone for instance ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.33 2008/12/20 00:18:03 gilles Exp $	*/
d43 1
a43 2

#define RCPTBUFSZ		 256
a531 1
	int			 backlog;
@


1.33
log
@- import first bricks of SMTP AUTH support. currently only AUTH PLAIN is
	supported, AUTH LOGIN will follow soon. AUTH will only work if a
	listen directive has "enable auth" keywords, AND session is safe
	(ssmtp or starttls).
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.32 2008/12/19 00:39:05 gilles Exp $	*/
d502 4
a505 1
	S_AUTH,
d517 1
d580 2
@


1.32
log
@- smtpd handled mbox locking failures as "regular" temporary failures which
	is not good at all. As a result, under heavy load messages would be
	kept in queue, and delayed for hours just because we failed locking
	a few times. This commit makes smtpd distinguish between lock fails
	and "regular" temporary fails.
- delivery scheduler will reschedule immediately a message that couldn't be
	delivered because of a lock fail. If we fail to lock too many times
	we fallback to previous "delay increase" logic.

	"looks sane" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.31 2008/12/18 23:57:17 jacekm Exp $	*/
d74 1
a372 17
struct submit_status {
	u_int64_t			 id;
	int				 code;
	union submit_path {
		struct path		 path;
		char			 msgid[MAXPATHLEN];
		char			 errormsg[MAX_LINE_SIZE];
	}				 u;
	struct sockaddr_storage		 ss;
};

struct message_recipient {
	u_int64_t			 id;
	struct sockaddr_storage		 ss;
	struct path			 path;
};

d394 2
a395 1
	F_MESSAGE_PROCESSING	= 0x8
d602 20
@


1.31
log
@Introduce safe_fclose, which tries to push file to the disk as
quickly as possible; it fails under temporary error conditions,
letting caller react appropriately.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.30 2008/12/18 23:49:56 jacekm Exp $	*/
d396 8
a403 7
	S_MESSAGE_PERMFAILURE	= 0x1,
	S_MESSAGE_TEMPFAILURE	= 0x2,
	S_MESSAGE_REJECTED	= 0x4,
	S_MESSAGE_ACCEPTED	= 0x8,
	S_MESSAGE_RETRY		= 0x10,
	S_MESSAGE_EDNS		= 0x20,
	S_MESSAGE_ECONNECT	= 0x40
@


1.30
log
@Declarations for functions used only in smtp_session.c were moved
to that file from smtpd.h.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.29 2008/12/18 23:38:12 jacekm Exp $	*/
d769 1
@


1.29
log
@Check fwrite return code at DATA stage.

Add basic line length checking, as required by rfc.

It is no longer required to disable EV_READ upon evbuffer_readline failure.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.28 2008/12/17 18:47:37 jacekm Exp $	*/
a718 3
void		 session_read(struct bufferevent *, void *);
void		 session_write(struct bufferevent *, void *);
void		 session_error(struct bufferevent *, short, void *);
a719 1
void		 session_msg_submit(struct session *);
@


1.28
log
@Introduce /purge, where all msgs scheduled for deletion are put by
queue, and removed from disk by runner.

On startup, clean /incoming by moving msgs within it to /purge.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.27 2008/12/13 23:19:34 jacekm Exp $	*/
d68 3
@


1.27
log
@IMSG_* namespace cleanup.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.26 2008/12/13 13:15:38 jacekm Exp $	*/
d52 2
@


1.26
log
@Declare alias_parse in smtpd.h, and fix callers that pass it wrong
number of arguments.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.25 2008/12/12 20:19:56 jacekm Exp $	*/
d159 6
a164 13
	IMSG_LKA_LOOKUP_MAIL,
	IMSG_LKA_LOOKUP_RCPT,
	IMSG_LKA_ALIAS_LOOKUP,
	IMSG_LKA_VUSER_LOOKUP,
	IMSG_LKA_ALIAS_RESULT,
	IMSG_LKA_VUSER_RESULT,
	IMSG_LKA_ALIAS_RESULT_ACK,
	IMSG_LKA_ALIAS_SCHEDULE,
	IMSG_LKA_ALIAS_END,
	IMSG_LKA_NO_ALIAS,
	IMSG_LKA_MX_LOOKUP,
	IMSG_LKA_FORWARD_LOOKUP,
	IMSG_LKA_HOSTNAME_LOOKUP,
d167 2
a168 7
	IMSG_MDA_MAILBOX_FILE_ERROR,
	IMSG_MDA_MESSAGE_FILE_ERROR,
	IMSG_MFA_RPATH_SUBMIT,
	IMSG_MFA_RCPT_SUBMIT,
	IMSG_MFA_DATA_SUBMIT,
	IMSG_MFA_LOOKUP_MAIL,
	IMSG_MFA_LOOKUP_RCPT,
a175 3
	IMSG_QUEUE_CREATE_MESSAGE_FILE,
	IMSG_QUEUE_DELETE_MESSAGE_FILE,
	IMSG_QUEUE_MESSAGE_SUBMIT,
a176 4
	IMSG_QUEUE_MESSAGE_COMPLETE,
	IMSG_QUEUE_MESSAGE_ACK,
	IMSG_QUEUE_BATCH_COMPLETE,
	IMSG_QUEUE_BATCH_CLOSE,
d180 1
a180 8
	IMSG_QUEUE_ACCEPTED_CLOSE,
	IMSG_QUEUE_RETRY_CLOSE,
	IMSG_QUEUE_REJECTED_CLOSE,

	IMSG_QUEUE_RECIPIENT_ACCEPTED,
	IMSG_QUEUE_RECIPIENT_UPDATED,

	IMSG_CREATE_BATCH,
a183 5
	IMSG_SMTP_MESSAGE_ID,

	IMSG_SMTP_MESSAGE_FILE,
	IMSG_SMTP_SUBMIT_ACK,
	IMSG_SMTP_HOSTNAME_ANSWER,
@


1.25
log
@Format string checking for bsnprintf.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.24 2008/12/11 22:18:15 gilles Exp $	*/
d648 1
@


1.24
log
@- missing prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.23 2008/12/07 15:38:35 jacekm Exp $	*/
d796 2
a797 1
int		bsnprintf(char *, size_t, const char *, ...);
@


1.23
log
@Replace evbuffer_add_printf calls with wrapper function, session_respond,
which additionally suffixes <CRLF>, and enables EV_WRITE.

Remove bufferevent_enable(.., EV_WRITE) from session_command and
session_pickup so that EV_WRITE is enabled in exactly one place,
session_respond.

Change some responses slightly to make code fit 80 columns.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.22 2008/12/07 03:14:24 gilles Exp $	*/
d794 3
@


1.22
log
@- getaddrinfo() uses negative values for its error defines, our use of an
	u_int8_t to hold the value leads to invalid checking in
	runner_batch_resolved(), this lead to a crash in MTA because we
	assumed a batch had its mx resolved when it had not. while at it,
	be more strict about errors we don't know and fatal(), it should
	not happen.

	ok jacekm@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.21 2008/12/06 15:18:36 weerd Exp $	*/
d41 1
a41 1
#define SMTPD_BANNER		 "220 %s OpenSMTPD\r\n"
@


1.21
log
@Get rid of anonymous unions. Discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.20 2008/12/05 02:51:32 gilles Exp $	*/
d521 1
a521 1
	u_int8_t			 getaddrinfo_error;
@


1.20
log
@- last part of the new queue code: the runner process (unprivileged and
	chrooted) is now in charge of doing the scheduling of deliveries,
	and the dispatching of messages to MDA and MTA. queue process only
	does inserts/updates/removals from the queue and can no longer be
	so busy that it delays answers to imsg from smtp server.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.19 2008/12/04 17:24:13 cloder Exp $	*/
d347 1
a347 1
	union {
d372 1
a372 1
	union {
d375 1
a375 1
	} u;
d389 1
a389 1
	union {
d394 1
a394 1
	} u;
d401 1
a401 1
	union {
d405 1
a405 1
	} u;
@


1.19
log
@Declare printf-style functions with __attribute__((format(printf,x,x)))
and fix some of the errors caught by this. Part of a general push to
make yyerror() -Wformat clean throughout the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.18 2008/12/04 01:16:14 gilles Exp $	*/
d22 1
a22 1
#define PROC_COUNT		 8
d254 1
a626 1
	struct event				 sc_rqev;
a719 1
SPLAY_PROTOTYPE(batchtree, batch, b_nodes, batch_cmp);
d732 5
@


1.18
log
@- fix event masking for DATA and make DATA look more like MAIL and RCPT
	with regard to communication with queue process (one state before
	sending imsg, another state when imsg has returned). this fixes an
	issue that I observed when clients send DATA and content without
	even looking at server replies.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.17 2008/12/03 17:58:00 gilles Exp $	*/
d652 8
a659 4
void		log_warn(const char *, ...);
void		log_warnx(const char *, ...);
void		log_info(const char *, ...);
void		log_debug(const char *, ...);
@


1.17
log
@- fix event masking issues in smtp process which could lead to a fatal() if
	queue process did not answer fast enough to an imsg. spotted by
	Jacek Masiulaniec <jacekm@@dobremiasto.net>
- queue layout was mostly to bootstrap the project, it does not behave good
	under load, it does complex things to stay in a recoverable state
	and it probably didnt do it too well. New queue code is simpler,
	smaller and allows for atomic submissions (a mail can never be in a
	state where it needs to be recovered). It still needs some work but
	works better than previous code, no regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.16 2008/11/25 23:06:15 gilles Exp $	*/
d547 1
@


1.16
log
@- more prototype moving to smtpd.h
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.15 2008/11/25 23:03:24 gilles Exp $	*/
d46 2
d50 3
a52 4
#define PATH_MESSAGES		"/messages"
#define PATH_LOCAL		"/local"
#define PATH_RELAY		"/relay"
#define PATH_DAEMON		"/daemon"
d55 4
d181 6
d197 1
d210 2
d431 4
a434 5
	F_MESSAGE_COMPLETE	= 0x1,
	F_MESSAGE_RESOLVED	= 0x2,
	F_MESSAGE_READY		= 0x4,
	F_MESSAGE_EXPIRED	= 0x8,
	F_MESSAGE_PROCESSING	= 0x10
d625 1
@


1.15
log
@- move prototype to smtpd.h
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.14 2008/11/25 23:01:00 gilles Exp $	*/
d659 4
@


1.14
log
@- move prototypes to smtpd.h
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.13 2008/11/25 20:26:40 gilles Exp $	*/
d655 5
@


1.13
log
@- recent change in parse.y caused htons() to be called twice on the port
	provided to "relay via" rules, once in parse.y once in lka.c, fix.
- rename struct address to struct relayhost, introduce struct mxhost which
	not only holds the sockaddr_storage, but also additionnal flags we
	want forwarded to the mta process.
- propagate the change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.12 2008/11/25 15:55:13 gilles Exp $	*/
d629 5
a633 1
int		is_alias(struct path *);
@


1.12
log
@- F_IMSG_SENT is no longer used, kill
	suggested by Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.11 2008/11/17 21:50:43 gilles Exp $	*/
d61 13
a73 1
struct address {
d78 2
a79 1
struct netaddr {
a80 1
	int masked;
d334 1
a334 1
		struct address		 host;
d508 3
a510 3
	struct sockaddr_storage		 ss[MXARRAYSIZE*2];
	u_int8_t			 ss_cnt;
	u_int8_t			 ss_off;
a549 3
#define F_STARTTLS		 0x01
#define F_SSMTP			 0x02
#define F_SSL			(F_SSMTP|F_STARTTLS)
@


1.11
log
@- until now a client could issue a command from an extension even though it
	greeted with helo and not ehlo. introduce session flag F_EHLO and
	make sure the session_command() dispatch only looks at extensions
	when a session does not have the F_EHLO flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.10 2008/11/17 21:27:50 gilles Exp $	*/
d568 3
a570 4
	F_IMSG_SENT	= 0x4,
	F_8BITMIME	= 0x8,
	F_SECURE	= 0x10,
	F_AUTHENTICATED	= 0x20
@


1.10
log
@- remove prototypes for the atomic API, we don't use it anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.9 2008/11/11 01:08:08 gilles Exp $	*/
d566 6
a571 5
	F_QUIT		= 0x1,
	F_IMSG_SENT	= 0x2,
	F_8BITMIME	= 0x4,
	F_SECURE	= 0x8,
	F_AUTHENTICATED	= 0x10
@


1.9
log
@- queue process no longer schedules messages which do not have flag
	F_MESSAGE_COMPLETE
- submit recipients to the queue as we read them from RCPT instead of
	submiting them all at once when DATA is over. this prevents us
	from having to keep a potentially large number of recipients in
	memory during the whole session.
- remove all code that dealt with the recipients queue of a message as
	it is no longer used.
- several small changes to make sure the server is always in a recoverable
	state in case of an unexpected shutdown.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.8 2008/11/10 23:18:47 gilles Exp $	*/
a620 5

/* atomic.c */
ssize_t		atomic_read(int, void *, size_t);
ssize_t		atomic_write(int, const void *, size_t);
ssize_t		atomic_printfd(int, const char *, ...);
@


1.8
log
@- open the message file earlier after a successful MAIL command instead of
	waiting for the DATA command. this currently has no impact on the
	session but is needed for another change that will make submission
	of recipients safer with regard to "unexpected shutdowns at bad
	timings"
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.7 2008/11/10 22:35:23 gilles Exp $	*/
d169 2
d518 1
a518 1
	S_MAILGETFILE,
d520 1
@


1.7
log
@- define MAX_LINE_SIZE which is the maximum length of a line we allow from
	a client. it must be set to the highest value we have from all of
	the extensions which are/will be implemented.
- replace all occurences of STRLEN define with MAX_LINE_SIZE, kill STRLEN
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.6 2008/11/10 21:29:18 chl Exp $	*/
d516 1
@


1.6
log
@rename h_errno field into getaddrinfo_error, to avoid confusion with errno.

h_errno has been obsoleted since the gethostbyname() --> getaddrinfo() replacement.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.5 2008/11/10 20:10:38 chl Exp $	*/
a21 1
#define STRLEN			 1024
d27 1
d257 1
a257 1
		char			 med_string[STRLEN];
d268 1
a268 1
	char				 m_name[STRLEN];
d375 1
a375 1
		char			 errormsg[STRLEN];
d425 1
a425 1
	char				 session_errorline[STRLEN];
d491 1
a491 1
	char				 errorline[STRLEN];
d553 1
a553 1
	char		buffer[STRLEN];
@


1.5
log
@fix store_write_header() prototype.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.4 2008/11/10 17:24:24 deraadt Exp $	*/
d493 1
a493 1
	u_int8_t			 h_errno;
@


1.4
log
@spaces fixed while reading code
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.3 2008/11/10 00:22:05 gilles Exp $	*/
d710 1
a710 1
int store_write_header(struct batch *, struct message *);
@


1.3
log
@- make READ_BUF_SIZE a power of 2
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.h,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d406 1
a406 1
	F_MESSAGE_EXPIRED      	= 0x8,
d412 1
a412 1
	TAILQ_ENTRY(message)    	 entry;
d474 1
a474 1
	SPLAY_ENTRY(batch)     	 b_nodes;
d476 1
a476 1
	u_int64_t      		 id;
d478 1
a478 1
	enum batch_flags       	 flags;
d591 2
a592 2
#define SMTPD_OPT_VERBOSE	 		 0x00000001
#define SMTPD_OPT_NOACTION	 		 0x00000002
d699 1
a699 1
void	 	 session_init(struct listener *, struct session *);
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d24 1
a24 1
#define READ_BUF_SIZE		 65535
d30 2
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

