head	1.18;
access;
symbols
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@ * @;


1.18
date	2015.10.17.13.35.45;	author gilles;	state dead;
branches;
next	1.17;
commitid	QK1COi4yIwKE7KMt;

1.17
date	2015.10.14.22.01.43;	author gilles;	state Exp;
branches;
next	1.16;
commitid	XSq2zfqNj1sXRZRl;

1.16
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	ZBTFreARDSMmzOIV;

1.15
date	2014.07.08.14.24.16;	author eric;	state Exp;
branches;
next	1.14;
commitid	J5xwY1c9OfJT14c6;

1.14
date	2014.04.19.17.35.48;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.09.18.55.19;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.06.10.12.07;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.27.11.01.47;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2013.07.19.16.02.00;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2012.11.23.13.54.12;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.16.16.16.09;	author chl;	state Exp;
branches;
next	1.2;

1.2
date	2012.06.14.21.56.13;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.15.23.22.47;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.18
log
@this file is deprecated
@
text
@/*	$OpenBSD: filter_api.c,v 1.17 2015/10/14 22:01:43 gilles Exp $	*/

/*
 * Copyright (c) 2013 Eric Faurot <eric@@openbsd.org>
 * Copyright (c) 2011 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/uio.h>

#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <inttypes.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

#define FILTER_HIWAT 65536

static struct tree	queries;
static struct tree	sessions;

struct filter_session {
	uint64_t	id;
	uint64_t	qid;
	int		qtype;
	size_t		datalen;

	struct {
		int		 eom_called;

		int		 error;
		struct io	 iev;
		struct iobuf	 ibuf;
		size_t		 idatalen;
		struct io	 oev;
		struct iobuf	 obuf;
		size_t		 odatalen;
	} pipe;

	struct {
		int		 ready;
		int		 status;
		int		 code;
		char		*line;
	} response;
};

static int		 register_done;
static const char	*filter_name;

static struct filter_internals {
	struct mproc	p;

	uint32_t	hooks;
	uint32_t	flags;

	uid_t		uid;
	gid_t		gid;
	const char     *rootpath;

	struct {
		int  (*connect)(uint64_t, struct filter_connect *);
		int  (*helo)(uint64_t, const char *);
		int  (*mail)(uint64_t, struct mailaddr *);
		int  (*rcpt)(uint64_t, struct mailaddr *);
		int  (*data)(uint64_t);
		void (*dataline)(uint64_t, const char *);
		int  (*eom)(uint64_t, size_t);

		void (*disconnect)(uint64_t);
		void (*reset)(uint64_t);
		void (*commit)(uint64_t);
		void (*rollback)(uint64_t);
	} cb;
} fi;

static void filter_api_init(void);
static void filter_response(struct filter_session *, int, int, const char *);
static void filter_send_response(struct filter_session *);
static void filter_register_query(uint64_t, uint64_t, int);
static void filter_dispatch(struct mproc *, struct imsg *);
static void filter_dispatch_dataline(uint64_t, const char *);
static void filter_dispatch_data(uint64_t);
static void filter_dispatch_eom(uint64_t, size_t);
static void filter_dispatch_connect(uint64_t, struct filter_connect *);
static void filter_dispatch_helo(uint64_t, const char *);
static void filter_dispatch_mail(uint64_t, struct mailaddr *);
static void filter_dispatch_rcpt(uint64_t, struct mailaddr *);
static void filter_dispatch_reset(uint64_t);
static void filter_dispatch_commit(uint64_t);
static void filter_dispatch_rollback(uint64_t);
static void filter_dispatch_disconnect(uint64_t);

static void filter_trigger_eom(struct filter_session *);
static void filter_io_in(struct io *, int);
static void filter_io_out(struct io *, int);
static const char *filterimsg_to_str(int);
static const char *hook_to_str(int);
static const char *query_to_str(int);
static const char *event_to_str(int);


static void
filter_response(struct filter_session *s, int status, int code, const char *line)
{
	log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" %s filter_response(%d, %d, %s)",
	    filter_name, s->id, query_to_str(s->qtype), status, code, line);

	s->response.ready = 1;
	s->response.status = status;
	s->response.code = code;
	if (line)
		s->response.line = strdup(line);
	else
		s->response.line = NULL;

	/* eom is special, as the reponse has to be deferred until the pipe is all flushed */
	if (s->qtype == QUERY_EOM)
		filter_trigger_eom(s);
	else
		filter_send_response(s);
}

static void
filter_send_response(struct filter_session *s)
{
	log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" %s filter_send_response() -> %d, %d, %s",
	    filter_name, s->id, query_to_str(s->qtype),
	    s->response.status,
	    s->response.code,
	    s->response.line);

	tree_xpop(&queries, s->qid);

	m_create(&fi.p, IMSG_FILTER_RESPONSE, 0, 0, -1);
	m_add_id(&fi.p, s->qid);
	m_add_int(&fi.p, s->qtype);
	if (s->qtype == QUERY_EOM)
		m_add_u32(&fi.p, s->datalen);
	m_add_int(&fi.p, s->response.status);
	m_add_int(&fi.p, s->response.code);
	if (s->response.line) {
		m_add_string(&fi.p, s->response.line);
		free(s->response.line);
		s->response.line = NULL;
	}
	m_close(&fi.p);

	s->qid = 0;
	s->response.ready = 0;
}

static void
filter_dispatch(struct mproc *p, struct imsg *imsg)
{
	struct filter_session	*s;
	struct filter_connect	 q_connect;
	struct mailaddr		 maddr;
	struct msg		 m;
	const char		*line, *name;
	uint32_t		 v, datalen;
	uint64_t		 id, qid;
	int			 status, type;
	int			 fds[2], fdin, fdout;

	log_trace(TRACE_FILTERS, "filter-api:%s imsg %s", filter_name,
	    filterimsg_to_str(imsg->hdr.type));

	switch (imsg->hdr.type) {
	case IMSG_FILTER_REGISTER:
		m_msg(&m, imsg);
		m_get_u32(&m, &v);
		m_get_string(&m, &name);
		filter_name = strdup(name);
		m_end(&m);
		if (v != FILTER_API_VERSION) {
			log_warnx("warn: filter-api:%s API mismatch", filter_name);
			fatalx("filter-api: exiting");
		}
		m_create(p, IMSG_FILTER_REGISTER, 0, 0, -1);
		m_add_int(p, fi.hooks);
		m_add_int(p, fi.flags);
		m_close(p);
		break;

	case IMSG_FILTER_EVENT:
		m_msg(&m, imsg);
		m_get_id(&m, &id);
		m_get_int(&m, &type);
		m_end(&m);
		switch (type) {
		case EVENT_CONNECT:
			s = xcalloc(1, sizeof(*s), "filter_dispatch");
			s->id = id;
			s->pipe.iev.sock = -1;
			s->pipe.oev.sock = -1;
			tree_xset(&sessions, id, s);
			break;
		case EVENT_DISCONNECT:
			filter_dispatch_disconnect(id);
			s = tree_xpop(&sessions, id);
			free(s);
			break;
		case EVENT_RESET:
			filter_dispatch_reset(id);
			break;
		case EVENT_COMMIT:
			filter_dispatch_commit(id);
			break;
		case EVENT_ROLLBACK:
			filter_dispatch_rollback(id);
			break;
		default:
			log_warnx("warn: filter-api:%s bad event %d", filter_name, type);
			fatalx("filter-api: exiting");
		}
		break;

	case IMSG_FILTER_QUERY:
		m_msg(&m, imsg);
		m_get_id(&m, &id);
		m_get_id(&m, &qid);
		m_get_int(&m, &type);
		switch(type) {
		case QUERY_CONNECT:
			m_get_sockaddr(&m, (struct sockaddr*)&q_connect.local);
			m_get_sockaddr(&m, (struct sockaddr*)&q_connect.remote);
			m_get_string(&m, &q_connect.hostname);
			m_end(&m);
			filter_register_query(id, qid, type);
			filter_dispatch_connect(id, &q_connect);
			break;
		case QUERY_HELO:
			m_get_string(&m, &line);
			m_end(&m);
			filter_register_query(id, qid, type);
			filter_dispatch_helo(id, line);
			break;
		case QUERY_MAIL:
			m_get_mailaddr(&m, &maddr);
			m_end(&m);
			filter_register_query(id, qid, type);
			filter_dispatch_mail(id, &maddr);
			break;
		case QUERY_RCPT:
			m_get_mailaddr(&m, &maddr);
			m_end(&m);
			filter_register_query(id, qid, type);
			filter_dispatch_rcpt(id, &maddr);
			break;
		case QUERY_DATA:
			m_end(&m);
			filter_register_query(id, qid, type);
			filter_dispatch_data(id);
			break;
		case QUERY_EOM:
			m_get_u32(&m, &datalen);
			m_end(&m);
			filter_register_query(id, qid, type);
			filter_dispatch_eom(id, datalen);
			break;
		default:
			log_warnx("warn: filter-api:%s bad query %d", filter_name, type);
			fatalx("filter-api: exiting");
		}
		break;

	case IMSG_FILTER_PIPE:
		m_msg(&m, imsg);
		m_get_id(&m, &id);
		m_end(&m);

		fdout = imsg->fd;
		fdin = -1;

		if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, fds) == -1) {
			log_warn("warn: filter-api:%s socketpair", filter_name);
			close(fdout);
		}
		else {
			s = tree_xget(&sessions, id);

			s->pipe.eom_called = 0;
			s->pipe.error = 0;
			s->pipe.idatalen = 0;
			s->pipe.odatalen = 0;

			iobuf_init(&s->pipe.obuf, 0, 0);
			io_init(&s->pipe.oev, fdout, s, filter_io_out, &s->pipe.obuf);
			io_set_write(&s->pipe.oev);

			iobuf_init(&s->pipe.ibuf, 0, 0);
			io_init(&s->pipe.iev, fds[0], s, filter_io_in, &s->pipe.ibuf);
			io_set_read(&s->pipe.iev);

			fdin = fds[1];
		}

		log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" tx pipe %d -> %d",
		    filter_name, id, fdin, fdout);

		m_create(&fi.p, IMSG_FILTER_PIPE, 0, 0, fdin);
		m_add_id(&fi.p, id);
		m_close(&fi.p);

		break;
	}
}

static void
filter_register_query(uint64_t id, uint64_t qid, int type)
{
	struct filter_session	*s;

	log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" %s", filter_name, id, query_to_str(type));

	s = tree_xget(&sessions, id);
	if (s->qid) {
		log_warnx("warn: filter-api:%s query already in progess",
		    filter_name);
		fatalx("filter-api: exiting");
	}
	s->qid = qid;
	s->qtype = type;
	s->response.ready = 0;

	tree_xset(&queries, qid, s);
}

static void
filter_dispatch_connect(uint64_t id, struct filter_connect *conn)
{
	if (fi.cb.connect)
		fi.cb.connect(id, conn);
	else
		filter_api_accept(id);
}

static void
filter_dispatch_helo(uint64_t id, const char *helo)
{
	if (fi.cb.helo)
		fi.cb.helo(id, helo);
	else
		filter_api_accept(id);
}

static void
filter_dispatch_mail(uint64_t id, struct mailaddr *mail)
{
	if (fi.cb.mail)
		fi.cb.mail(id, mail);
	else
		filter_api_accept(id);
}

static void
filter_dispatch_rcpt(uint64_t id, struct mailaddr *rcpt)
{
	if (fi.cb.rcpt)
		fi.cb.rcpt(id, rcpt);
	else
		filter_api_accept(id);
}

static void
filter_dispatch_data(uint64_t id)
{
	if (fi.cb.data)
		fi.cb.data(id);
	else
		filter_api_accept(id);
}

static void
filter_dispatch_reset(uint64_t id)
{
	if (fi.cb.reset)
		fi.cb.reset(id);
}

static void
filter_dispatch_commit(uint64_t id)
{
	if (fi.cb.commit)
		fi.cb.commit(id);
}

static void
filter_dispatch_rollback(uint64_t id)
{
	if (fi.cb.rollback)
		fi.cb.rollback(id);
}

static void
filter_dispatch_disconnect(uint64_t id)
{
	if (fi.cb.disconnect)
		fi.cb.disconnect(id);
}

static void
filter_dispatch_dataline(uint64_t id, const char *data)
{
	if (fi.cb.dataline)
		fi.cb.dataline(id, data);
	else
		filter_api_writeln(id, data);
}

static void
filter_dispatch_eom(uint64_t id, size_t datalen)
{
	struct filter_session	*s;

	s = tree_xget(&sessions, id);
	s->datalen = datalen;

	filter_trigger_eom(s);
}

static void
filter_trigger_eom(struct filter_session *s)
{
	log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" filter_trigger_eom(%d, %d, %zu, %zu, %zu)",
	    filter_name, s->id, s->pipe.iev.sock, s->pipe.oev.sock,
	    s->datalen, s->pipe.idatalen, s->pipe.odatalen);

	/* This is called when
	 * - EOM query is first received
	 * - input data is closed
	 * - output has been written
	 */

	/* input not done yet, or EOM query not received */
	if (s->pipe.iev.sock != -1 || s->qid == 0)
		return;

	if (s->pipe.error)
		goto fail;

	/* if size don't match, error out */
	if (s->pipe.idatalen != s->datalen) {
		log_trace(TRACE_FILTERS, "filter-api:%s tx datalen mismatch: %zu/%zu",
		    filter_name, s->pipe.idatalen, s->datalen);
		s->pipe.error = 1;
		goto fail;
	}

	/* if we didn't send the eom to the user do it now */
	if (!s->pipe.eom_called) {
		s->pipe.eom_called = 1;
		if (fi.cb.eom)
			fi.cb.eom(s->id, s->datalen);
		else
			filter_api_accept(s->id);
		return;
	}

	if (s->pipe.error)
		goto fail;

	/* wait for the output socket to be closed */
	if (s->pipe.oev.sock != -1)
		return;

	s->datalen = s->pipe.odatalen;
	filter_send_response(s);

    fail:
	/* XXX */
	return;
}

static void
filter_io_in(struct io *io, int evt)
{
	struct filter_session	*s = io->arg;
	char			*line;
	size_t			 len;

	log_trace(TRACE_FILTERS, "filter-api:%s filter_io_in(%p, %s)",
	    filter_name, s, io_strevent(evt));

	switch (evt) {
	case IO_DATAIN:
	    nextline:
		line = iobuf_getline(&s->pipe.ibuf, &len);
		if ((line == NULL && iobuf_len(&s->pipe.ibuf) >= LINE_MAX) ||
		    (line && len >= LINE_MAX)) {
			s->pipe.error = 1;
			break;
		}
		/* No complete line received */
		if (line == NULL) {
			iobuf_normalize(&s->pipe.ibuf);
			/* flow control */
			if (iobuf_queued(&s->pipe.obuf) >= FILTER_HIWAT)
				io_pause(&s->pipe.iev, IO_PAUSE_IN);
			return;
		}

		s->pipe.idatalen += len + 1;
		/* XXX warning: do not clear io from this call! */
		filter_dispatch_dataline(s->id, line);
		goto nextline;

	case IO_DISCONNECTED:
		if (iobuf_len(&s->pipe.ibuf)) {
			log_warn("warn: filter-api:%s %016"PRIx64" incomplete input",
			    filter_name, s->id);
		}
		log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" input done (%zu bytes)",
		    filter_name, s->id, s->pipe.idatalen);
		break;

	default:
		log_warn("warn: filter-api:%s %016"PRIx64": unexpected io event %d on data pipe",
		    filter_name, s->id, evt);
		s->pipe.error = 1;

	}
	if (s->pipe.error) {
		io_clear(&s->pipe.oev);
		iobuf_clear(&s->pipe.obuf);
	}
	io_clear(&s->pipe.iev);
	iobuf_clear(&s->pipe.ibuf);
	filter_trigger_eom(s);
}

static void
filter_io_out(struct io *io, int evt)
{
	struct filter_session    *s = io->arg;

	log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" filter_io_out(%s)",
	    filter_name, s->id, io_strevent(evt));

	switch (evt) {
	case IO_TIMEOUT:
	case IO_DISCONNECTED:
	case IO_ERROR:
		log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" io error on output pipe",
		    filter_name, s->id);
		s->pipe.error = 1;
		break;

	case IO_LOWAT:
		/* flow control */
		if (s->pipe.iev.sock != -1 && s->pipe.iev.flags & IO_PAUSE_IN) {
			io_resume(&s->pipe.iev, IO_PAUSE_IN);
			return;
		}

		/* if the input is done and there is a response we are done */
		if (s->pipe.iev.sock == -1 && s->response.ready)
			break;

		/* just wait for more data to send */
		return;

	default:
		fatalx("filter_io_out()");
	}

	io_clear(&s->pipe.oev);
	iobuf_clear(&s->pipe.obuf);
	if (s->pipe.error) {
		io_clear(&s->pipe.iev);
		iobuf_clear(&s->pipe.ibuf);
	}
	filter_trigger_eom(s);
}

#define CASE(x) case x : return #x

static const char *
filterimsg_to_str(int imsg)
{
	switch (imsg) {
	CASE(IMSG_FILTER_REGISTER);
	CASE(IMSG_FILTER_EVENT);
	CASE(IMSG_FILTER_QUERY);
	CASE(IMSG_FILTER_PIPE);
	CASE(IMSG_FILTER_RESPONSE);
	default:
		return ("IMSG_FILTER_???");
	}
}

static const char *
hook_to_str(int hook)
{
	switch (hook) {
	CASE(HOOK_CONNECT);
	CASE(HOOK_HELO);
	CASE(HOOK_MAIL);
	CASE(HOOK_RCPT);
	CASE(HOOK_DATA);
	CASE(HOOK_EOM);
	CASE(HOOK_RESET);
	CASE(HOOK_DISCONNECT);
	CASE(HOOK_COMMIT);
	CASE(HOOK_ROLLBACK);
	CASE(HOOK_DATALINE);
	default:
		return ("HOOK_???");
	}
}

static const char *
query_to_str(int query)
{
	switch (query) {
	CASE(QUERY_CONNECT);
	CASE(QUERY_HELO);
	CASE(QUERY_MAIL);
	CASE(QUERY_RCPT);
	CASE(QUERY_DATA);
	CASE(QUERY_EOM);
	CASE(QUERY_DATALINE);
	default:
		return ("QUERY_???");
	}
}

static const char *
event_to_str(int event)
{
	switch (event) {
	CASE(EVENT_CONNECT);
	CASE(EVENT_RESET);
	CASE(EVENT_DISCONNECT);
	CASE(EVENT_COMMIT);
	CASE(EVENT_ROLLBACK);
	default:
		return ("EVENT_???");
	}
}

/*
 * These functions are called from mproc.c
 */

enum smtp_proc_type smtpd_process;

const char *
proc_name(enum smtp_proc_type proc)
{
	if (proc == PROC_FILTER)
		return (filter_name);
	return ("filter");
}

const char *
imsg_to_str(int imsg)
{
	static char buf[32];

	snprintf(buf, sizeof(buf), "%d", imsg);

	return (buf);
}


/*
 * These functions are callable by filters
 */

void
filter_api_setugid(uid_t uid, gid_t gid)
{
	filter_api_init();

	if (! uid) {
		log_warn("warn: filter-api:%s can't set uid 0", filter_name);
		fatalx("filter-api: exiting");
	}
	if (! gid) {
		log_warn("warn: filter-api:%s can't set gid 0", filter_name);
		fatalx("filter-api: exiting");
	}
	fi.uid = uid;
	fi.gid = gid;
}

void
filter_api_no_chroot(void)
{
	filter_api_init();

	fi.rootpath = NULL;
}

void
filter_api_set_chroot(const char *rootpath)
{
	filter_api_init();

	fi.rootpath = rootpath;
}

static void
filter_api_init(void)
{
	extern const char *__progname;
	struct passwd  *pw;
	static int	init = 0;

	if (init)
		return;

	init = 1;

	log_init(-1);
	log_verbose(1);

	pw = getpwnam(SMTPD_USER);
	if (pw == NULL) {
		log_warn("warn: filter-api:%s getpwnam", filter_name);
		fatalx("filter-api: exiting");
	}

	smtpd_process = PROC_FILTER;
	filter_name = __progname;

	tree_init(&queries);
	tree_init(&sessions);
	event_init();

	memset(&fi, 0, sizeof(fi));
	fi.p.proc = PROC_PONY;
	fi.p.name = "filter";
	fi.p.handler = filter_dispatch;
	fi.uid = pw->pw_uid;
	fi.gid = pw->pw_gid;
	fi.rootpath = PATH_CHROOT;

	/* XXX just for now */
	fi.hooks = ~0;

	mproc_init(&fi.p, 0);
}

void
filter_api_on_connect(int(*cb)(uint64_t, struct filter_connect *))
{
	filter_api_init();

	fi.hooks |= HOOK_CONNECT;
	fi.cb.connect = cb;
}

void
filter_api_on_helo(int(*cb)(uint64_t, const char *))
{
	filter_api_init();

	fi.hooks |= HOOK_HELO;
	fi.cb.helo = cb;
}

void
filter_api_on_mail(int(*cb)(uint64_t, struct mailaddr *))
{
	filter_api_init();

	fi.hooks |= HOOK_MAIL;
	fi.cb.mail = cb;
}

void
filter_api_on_rcpt(int(*cb)(uint64_t, struct mailaddr *))
{
	filter_api_init();

	fi.hooks |= HOOK_RCPT;
	fi.cb.rcpt = cb;
}

void
filter_api_on_data(int(*cb)(uint64_t))
{
	filter_api_init();

	fi.hooks |= HOOK_DATA;
	fi.cb.data = cb;
}

void
filter_api_on_dataline(void(*cb)(uint64_t, const char *))
{
	filter_api_init();

	fi.hooks |= HOOK_DATALINE | HOOK_EOM;
	fi.cb.dataline = cb;
}

void
filter_api_on_eom(int(*cb)(uint64_t, size_t))
{
	filter_api_init();

	fi.hooks |= HOOK_EOM;
	fi.cb.eom = cb;
}

void
filter_api_on_reset(void(*cb)(uint64_t))
{
	filter_api_init();

	fi.hooks |= HOOK_RESET;
	fi.cb.reset = cb;
}

void
filter_api_on_disconnect(void(*cb)(uint64_t))
{
	filter_api_init();

	fi.hooks |= HOOK_DISCONNECT;
	fi.cb.disconnect = cb;
}

void
filter_api_on_commit(void(*cb)(uint64_t))
{
	filter_api_init();

	fi.hooks |= HOOK_COMMIT;
	fi.cb.commit = cb;
}

void
filter_api_on_rollback(void(*cb)(uint64_t))
{
	filter_api_init();

	fi.hooks |= HOOK_ROLLBACK;
	fi.cb.rollback = cb;
}

void
filter_api_loop(void)
{
	if (register_done) {
		log_warnx("warn: filter-api:%s filter_api_loop() already called", filter_name);
		fatalx("filter-api: exiting");
	}

	filter_api_init();

	register_done = 1;

	mproc_enable(&fi.p);

	if (fi.rootpath) {
		if (chroot(fi.rootpath) == -1) {
			log_warn("warn: filter-api:%s chroot", filter_name);
			fatalx("filter-api: exiting");
		}
		if (chdir("/") == -1) {
			log_warn("warn: filter-api:%s chdir", filter_name);
			fatalx("filter-api: exiting");
		}
	}

	if (setgroups(1, &fi.gid) ||
	    setresgid(fi.gid, fi.gid, fi.gid) ||
	    setresuid(fi.uid, fi.uid, fi.uid)) {
		log_warn("warn: filter-api:%s cannot drop privileges", filter_name);
		fatalx("filter-api: exiting");
	}

	if (event_dispatch() < 0) {
		log_warn("warn: filter-api:%s event_dispatch", filter_name);
		fatalx("filter-api: exiting");
	}
}

int
filter_api_accept(uint64_t id)
{
	struct filter_session	*s;

	log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" filter_api_accept()", filter_name, id);

	s = tree_xget(&sessions, id);
	filter_response(s, FILTER_OK, 0, NULL);

	return (1);
}

int
filter_api_reject(uint64_t id, enum filter_status status)
{
	struct filter_session	*s;

	log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" filter_api_reject(%d)",
	    filter_name, id, status);

	s = tree_xget(&sessions, id);

	/* This is NOT an acceptable status for a failure */
	if (status == FILTER_OK)
		status = FILTER_FAIL;

	filter_response(s, status, 0, NULL);

	return (1);
}

int
filter_api_reject_code(uint64_t id, enum filter_status status, uint32_t code,
    const char *line)
{
	struct filter_session	*s;

	log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" filter_api_reject_code(%d, %u, %s)",
	    filter_name, id, status, code, line);

	s = tree_xget(&sessions, id);

	/* This is NOT an acceptable status for a failure */
	if (status == FILTER_OK)
		status = FILTER_FAIL;

	filter_response(s, status, code, line);

	return (1);
}

void
filter_api_writeln(uint64_t id, const char *line)
{
	struct filter_session	*s;

	log_trace(TRACE_FILTERS, "filter-api:%s %016"PRIx64" filter_api_writeln(%s)", filter_name, id, line);

	s = tree_xget(&sessions, id);

	if (s->pipe.oev.sock == -1) {
		log_warnx("warn: filter:%s: cannot write at this point", filter_name);
		fatalx("exiting");
	}

	s->pipe.odatalen += strlen(line) + 1;
	iobuf_fqueue(&s->pipe.obuf, "%s\n", line);
	io_reload(&s->pipe.oev);
}

const char *
filter_api_sockaddr_to_text(const struct sockaddr *sa)
{
	static char	buf[NI_MAXHOST];

	if (getnameinfo(sa, sa->sa_len, buf, sizeof(buf), NULL, 0,
		NI_NUMERICHOST))
		return ("(unknown)");
	else
		return (buf);
}

const char *
filter_api_mailaddr_to_text(const struct mailaddr *maddr)
{
	static char  buffer[LINE_MAX];

	strlcpy(buffer, maddr->user, sizeof buffer);
	strlcat(buffer, "@@", sizeof buffer);
	if (strlcat(buffer, maddr->domain, sizeof buffer) >= sizeof buffer)
		return (NULL);

	return (buffer);
}
@


1.17
log
@whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: filter_api.c,v 1.16 2015/01/20 17:37:54 deraadt Exp $	*/
@


1.16
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: filter_api.c,v 1.15 2014/07/08 14:24:16 eric Exp $	*/
d450 1
a450 1
	/* This is called when 
@


1.15
log
@make the filter API move forward (still not plugged).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d510 2
a511 2
		if ((line == NULL && iobuf_len(&s->pipe.ibuf) >= SMTPD_MAXLINESIZE) ||
		    (line && len >= SMTPD_MAXLINESIZE)) {
d990 1
a990 1
	static char  buffer[SMTPD_MAXLINESIZE];
@


1.14
log
@remove dead code ... in code that's not plugged in yet ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: filter_api.c,v 1.13 2014/04/09 18:55:19 eric Exp $	*/
d45 2
a46 1
	int		qhook;
d49 2
a50 1
		size_t		 datalen;
a63 1
		int		 notify;
d82 5
a86 6
		void (*notify)(uint64_t, enum filter_status);
		void (*connect)(uint64_t, struct filter_connect *);
		void (*helo)(uint64_t, const char *);
		void (*mail)(uint64_t, struct mailaddr *);
		void (*rcpt)(uint64_t, struct mailaddr *);
		void (*data)(uint64_t);
d88 6
a93 2
		void (*eom)(uint64_t);
		void (*event)(uint64_t, enum filter_hook);
d98 1
a98 1
static void filter_response(struct filter_session *, int, int, const char *line, int);
d100 1
a100 1
static void filter_register_query(uint64_t, uint64_t, enum filter_hook);
a101 1
static void filter_dispatch_event(uint64_t, enum filter_hook);
d103 11
a113 7
static void filter_dispatch_data(uint64_t, uint64_t);
static void filter_dispatch_eom(uint64_t, uint64_t, size_t);
static void filter_dispatch_notify(uint64_t, enum filter_status);
static void filter_dispatch_connect(uint64_t, uint64_t, struct filter_connect *);
static void filter_dispatch_helo(uint64_t, uint64_t, const char *);
static void filter_dispatch_mail(uint64_t, uint64_t, struct mailaddr *);
static void filter_dispatch_rcpt(uint64_t, uint64_t, struct mailaddr *);
d119 2
a121 182
void
filter_api_on_notify(void(*cb)(uint64_t, enum filter_status))
{
	filter_api_init();

	fi.cb.notify = cb;
}

void
filter_api_on_connect(void(*cb)(uint64_t, struct filter_connect *))
{
	filter_api_init();

	fi.hooks |= HOOK_CONNECT;
	fi.cb.connect = cb;
}

void
filter_api_on_helo(void(*cb)(uint64_t, const char *))
{
	filter_api_init();

	fi.hooks |= HOOK_HELO;
	fi.cb.helo = cb;
}

void
filter_api_on_mail(void(*cb)(uint64_t, struct mailaddr *))
{
	filter_api_init();

	fi.hooks |= HOOK_MAIL;
	fi.cb.mail = cb;
}

void
filter_api_on_rcpt(void(*cb)(uint64_t, struct mailaddr *))
{
	filter_api_init();

	fi.hooks |= HOOK_RCPT;
	fi.cb.rcpt = cb;
}

void
filter_api_on_data(void(*cb)(uint64_t))
{
	filter_api_init();

	fi.hooks |= HOOK_DATA;
	fi.cb.data = cb;
}

void
filter_api_on_dataline(void(*cb)(uint64_t, const char *))
{
	filter_api_init();

	fi.hooks |= HOOK_DATALINE | HOOK_EOM;
	fi.cb.dataline = cb;
}

void
filter_api_on_eom(void(*cb)(uint64_t))
{
	filter_api_init();

	fi.hooks |= HOOK_EOM;
	fi.cb.eom = cb;
}

void
filter_api_on_event(void(*cb)(uint64_t, enum filter_hook))
{
	filter_api_init();

	fi.hooks |= HOOK_DISCONNECT | HOOK_RESET | HOOK_COMMIT;
	fi.cb.event = cb;
}

void
filter_api_loop(void)
{
	if (register_done) {
		log_warnx("warn: filter-api:%s: filter_api_loop() already called", filter_name);
		fatalx("filter-api: exiting");
	}

	filter_api_init();

	register_done = 1;

	mproc_enable(&fi.p);

	if (fi.rootpath) {
		if (chroot(fi.rootpath) == -1) {
			log_warn("warn: filter-api:%s: chroot", filter_name);
			fatalx("filter-api: exiting");
		}
		if (chdir("/") == -1) {
			log_warn("warn: filter-api:%s: chdir", filter_name);
			fatalx("filter-api: exiting");
		}
	}

	if (setgroups(1, &fi.gid) ||
	    setresgid(fi.gid, fi.gid, fi.gid) ||
	    setresuid(fi.uid, fi.uid, fi.uid)) {
		log_warn("warn: filter-api:%s: cannot drop privileges", filter_name);
		fatalx("filter-api: exiting");
	}

	if (event_dispatch() < 0) {
		log_warn("warn: filter-api:%s: event_dispatch", filter_name);
		fatalx("filter-api: exiting");
	}
}

void
filter_api_accept(uint64_t id)
{
	struct filter_session	*s;

	s = tree_xget(&sessions, id);
	filter_response(s, FILTER_OK, 0, NULL, 0);
}

void
filter_api_accept_notify(uint64_t id, uint64_t *qid)
{
	struct filter_session	*s;

	s = tree_xget(&sessions, id);
	*qid = s->qid;
	filter_response(s, FILTER_OK, 0, NULL, 1);
}

void
filter_api_reject(uint64_t id, enum filter_status status)
{
	struct filter_session	*s;

	s = tree_xget(&sessions, id);

	/* This is NOT an acceptable status for a failure */
	if (status == FILTER_OK)
		status = FILTER_FAIL;

	filter_response(s, status, 0, NULL, 0);
}

void
filter_api_reject_code(uint64_t id, enum filter_status status, uint32_t code,
    const char *line)
{
	struct filter_session	*s;

	s = tree_xget(&sessions, id);

	/* This is NOT an acceptable status for a failure */
	if (status == FILTER_OK)
		status = FILTER_FAIL;

	filter_response(s, status, code, line, 0);
}

void
filter_api_writeln(uint64_t id, const char *line)
{
	struct filter_session	*s;

	s = tree_xget(&sessions, id);

	if (s->pipe.oev.sock == -1) {
		log_warnx("warn: filter:%s: cannot write at this point", filter_name);
		fatalx("exiting");
	}

	s->pipe.odatalen += strlen(line) + 1;
	iobuf_fqueue(&s->pipe.obuf, "%s\n", line);
	io_reload(&s->pipe.oev);
}
d124 1
a124 1
filter_response(struct filter_session *s, int status, int code, const char *line, int notify)
d126 2
a127 5
	log_debug("debug: filter-api:%s: got response %s for %016"PRIx64" %d %d %s",
	    filter_name, hook_to_str(s->qhook), s->id,
	    s->response.status,
	    s->response.code,
	    s->response.line);
a131 1
	s->response.notify = notify;
d137 5
a141 9
	/* For HOOK_EOM, wait until the obuf is drained before sending the  */
	if (s->qhook == HOOK_EOM &&
	    fi.hooks & HOOK_DATALINE &&
	    s->pipe.oev.sock != -1) {
		log_debug("debug: filter-api:%s: got response, waiting for opipe to be closed", filter_name);
		return;
	}

	filter_send_response(s);
d147 2
a148 2
	log_debug("debug: filter-api:%s: sending response %s for %016"PRIx64" %d %d %s",
	    filter_name, hook_to_str(s->qhook), s->id,
d157 3
a159 4
	m_add_int(&fi.p, s->qhook);
	if (s->qhook == HOOK_EOM)
		m_add_u32(&fi.p, (s->qhook & HOOK_DATALINE) ?
		    s->pipe.odatalen : s->pipe.datalen);
a161 1
	m_add_int(&fi.p, s->response.notify);
a172 72
void
filter_api_setugid(uid_t uid, gid_t gid)
{
	filter_api_init();

	if (! uid) {
		log_warn("warn: filter-api:%s: can't set uid 0", filter_name);
		fatalx("filter-api: exiting");
	}
	if (! gid) {
		log_warn("warn: filter-api:%s: can't set gid 0", filter_name);
		fatalx("filter-api: exiting");
	}
	fi.uid = uid;
	fi.gid = gid;
}

void
filter_api_no_chroot(void)
{
	filter_api_init();

	fi.rootpath = NULL;
}

void
filter_api_set_chroot(const char *rootpath)
{
	filter_api_init();

	fi.rootpath = rootpath;
}

static void
filter_api_init(void)
{
	extern const char *__progname;
	struct passwd  *pw;
	static int	init = 0;

	if (init)
		return;

	init = 1;

	log_init(-1);
	log_verbose(1);

	pw = getpwnam(SMTPD_USER);
	if (pw == NULL) {
		log_warn("warn: filter-api:%s: getpwnam", filter_name);
		fatalx("filter-api: exiting");
	}

	smtpd_process = PROC_FILTER;
	filter_name = __progname;

	tree_init(&queries);
	tree_init(&sessions);
	event_init();

	memset(&fi, 0, sizeof(fi));
	fi.p.proc = PROC_PONY;
	fi.p.name = "filter";
	fi.p.handler = filter_dispatch;
	fi.uid = pw->pw_uid;
	fi.gid = pw->pw_gid;
	fi.rootpath = PATH_CHROOT;
	
	mproc_init(&fi.p, 0);
}

d183 1
a183 1
	int			 status, event, hook;
d186 1
a186 1
	log_debug("debug: filter-api:%s: imsg %s", filter_name,
d197 1
a197 1
			log_warnx("warn: filter-api:%s: API mismatch", filter_name);
d209 1
a209 1
		m_get_int(&m, &event);
d211 10
a220 2
		filter_dispatch_event(id, event);
		if (event == HOOK_DISCONNECT) {
d223 13
d243 3
a245 3
		m_get_int(&m, &hook);
		switch(hook) {
		case HOOK_CONNECT:
d250 8
a257 13
			s = xcalloc(1, sizeof(*s), "filter_dispatch");
			s->id = id;
			s->pipe.iev.sock = -1;
			s->pipe.oev.sock = -1;
			tree_xset(&sessions, id, s);
			filter_register_query(id, qid, hook);
			filter_dispatch_connect(id, qid, &q_connect);
			break;
		case HOOK_HELO:
			m_get_string(&m, &line);
			m_end(&m);
			filter_register_query(id, qid, hook);
			filter_dispatch_helo(id, qid, line);
d259 1
a259 1
		case HOOK_MAIL:
d262 2
a263 2
			filter_register_query(id, qid, hook);
			filter_dispatch_mail(id, qid, &maddr);
d265 1
a265 1
		case HOOK_RCPT:
d268 2
a269 2
			filter_register_query(id, qid, hook);
			filter_dispatch_rcpt(id, qid, &maddr);
d271 1
a271 1
		case HOOK_DATA:
d273 2
a274 2
			filter_register_query(id, qid, hook);
			filter_dispatch_data(id, qid);
d276 1
a276 1
		case HOOK_EOM:
d279 2
a280 2
			filter_register_query(id, qid, hook);
			filter_dispatch_eom(id, qid, datalen);
d283 1
a283 1
			log_warnx("warn: filter-api:%s: bad hook %d", filter_name, hook);
d288 1
a288 1
	case IMSG_FILTER_PIPE_SETUP:
d297 1
a297 1
			log_warn("warn: filter-api:%s: socketpair", filter_name);
d302 6
a316 1
			/* XXX notify? */
d318 5
a322 2
		log_debug("debug: filter-api:%s: tx pipe %d -> %d for %016"PRIx64, filter_name, fdin, fdout, id);
		m_create(&fi.p, IMSG_FILTER_PIPE_SETUP, 0, 0, fdin);
a324 1
		break;
a325 14
	case IMSG_FILTER_PIPE_ABORT:
		m_msg(&m, imsg);
		m_get_id(&m, &id);
		m_end(&m);
		s = tree_xget(&sessions, id);
		if (s->pipe.iev.sock != -1) {
			io_clear(&s->pipe.iev);
			iobuf_clear(&s->pipe.ibuf);
		}
		if (s->pipe.oev.sock != -1) {
			io_clear(&s->pipe.oev);
			iobuf_clear(&s->pipe.obuf);
		}
		/* XXX notify? */
a326 9

	case IMSG_FILTER_NOTIFY:
		m_msg(&m, imsg);
		m_get_id(&m, &qid);
		m_get_int(&m, &status);
		m_end(&m);
		filter_dispatch_notify(qid, status);
		break;

d331 1
a331 1
filter_register_query(uint64_t id, uint64_t qid, enum filter_hook hook)
d335 1
a335 2
	log_debug("debug: filter-api:%s: query %s for %016"PRIx64,
		filter_name, hook_to_str(hook), id);
d339 1
a339 1
		log_warn("warn: filter-api:%s: query already in progess",
d344 1
a344 1
	s->qhook = hook;
d351 1
a351 1
filter_dispatch_event(uint64_t id, enum filter_hook event)
d353 4
a356 1
	fi.cb.event(id, event);
d360 1
a360 1
filter_dispatch_notify(uint64_t qid, enum filter_status status)
d362 4
a365 1
	fi.cb.notify(qid, status);
d369 1
a369 1
filter_dispatch_connect(uint64_t id, uint64_t qid, struct filter_connect *conn)
d371 4
a374 1
	fi.cb.connect(id, conn);
d378 1
a378 1
filter_dispatch_helo(uint64_t id, uint64_t qid, const char *helo)
d380 4
a383 1
	fi.cb.helo(id, helo);
d387 1
a387 1
filter_dispatch_mail(uint64_t id, uint64_t qid, struct mailaddr *mail)
d389 4
a392 1
	fi.cb.mail(id, mail);
d396 1
a396 1
filter_dispatch_rcpt(uint64_t id, uint64_t qid, struct mailaddr *rcpt)
d398 2
a399 1
	fi.cb.rcpt(id, rcpt);
d403 1
a403 1
filter_dispatch_data(uint64_t id, uint64_t qid)
d405 2
a406 1
	fi.cb.data(id);
d410 1
a410 1
filter_dispatch_eom(uint64_t id, uint64_t qid, size_t datalen)
d412 3
a414 1
	struct filter_session	*s;
d416 5
a420 15
	s = tree_xget(&sessions, id);
	s->pipe.datalen = datalen;

	if (fi.hooks & HOOK_DATALINE) {
		/* wait for the io to be done  */
		if (s->pipe.iev.sock != -1) {
			log_debug("debug: filter-api:%s: eom received for %016"PRIx64", waiting for io to end",
			    filter_name, id);
			return;
		}
		filter_trigger_eom(s);
		return;
	}

	fi.cb.eom(s->id);
d426 15
a440 1
	fi.cb.dataline(id, data);
d446 16
a461 1
	log_debug("debug: filter-api:%s: tx eom (%zu) for %016"PRIx64, filter_name, s->pipe.datalen, s->id);
d463 4
a466 3
	if (!s->pipe.error && s->pipe.idatalen != s->pipe.datalen) {
		log_debug("debug: filter-api:%s: tx datalen mismatch: %zu/%zu",
		    filter_name, s->pipe.idatalen, s->pipe.datalen);
d468 1
d470 9
a478 3
	if (s->pipe.error) {
		log_debug("debug: filter-api:%s: tx pipe.error", filter_name);
		/* XXX error? */
d481 13
a493 22
	/* if the filter has no eom callback, we accept the message */
	if (fi.cb.eom) {
		log_debug("debug: filter-api:%s: calling eom callback", filter_name);
		fi.cb.eom(s->id);
	} else {
		log_debug("debug: filter-api:%s: accepting by default", filter_name);
		filter_api_accept(s->id);
	}

	/* if the output is done and the response is ready, send it */
	if ((s->pipe.oev.sock == -1 || iobuf_queued(&s->pipe.obuf) == 0) &&
	    s->response.ready) {
		log_debug("debug: filter-api:%s: sending response", filter_name);
		if (s->pipe.oev.sock != -1) {
			io_clear(&s->pipe.oev);
			iobuf_clear(&s->pipe.obuf);
		}
		filter_send_response(s);
	}
	else {
		log_debug("debug: filter-api:%s: waiting for obuf to drain", filter_name);
	}
d503 1
a503 1
	log_debug("debug: filter-api:%s: filter_io_in(%p, %s)",
a512 2
			io_clear(&s->pipe.oev);
			iobuf_clear(&s->pipe.obuf);
d520 1
a520 1
				io_pause(&s->pipe.oev, IO_PAUSE_IN);
d523 1
d525 1
d530 3
a532 5
		if (s->qhook == HOOK_EOM)
			filter_trigger_eom(s);
		else {
			log_debug("debug: filter-api:%s: datain closed, for %016"PRIx64", waiting for eom",
		    filter_name, s->id);
d534 2
d537 1
d539 2
d542 3
d550 1
d558 2
a559 2
	log_debug("debug: filter-api:%s: filter_io_out(%p, %s)",
	    filter_name, s, io_strevent(evt));
d565 2
a566 2
		log_debug("debug: filter-api:%s: io error on output pipe",
		    filter_name);
a567 6
		io_clear(&s->pipe.oev);
		iobuf_clear(&s->pipe.obuf);
		if (s->pipe.iev.sock != -1) {
			io_clear(&s->pipe.iev);
			iobuf_clear(&s->pipe.ibuf);
		}
d572 1
a572 1
		if (s->pipe.iev.sock != -1 && s->pipe.iev.flags & IO_PAUSE_IN)
d574 9
a583 7
		/* if the input is done and there is a response, send it */
		if (s->pipe.iev.sock == -1 && s->response.ready) {
			io_clear(&s->pipe.oev);
			iobuf_clear(&s->pipe.obuf);
			filter_send_response(s);
		}
		break;
d587 8
d606 1
a606 3
	CASE(IMSG_FILTER_PIPE_SETUP);
	CASE(IMSG_FILTER_PIPE_ABORT);
	CASE(IMSG_FILTER_NOTIFY);
d609 1
a609 1
		return "IMSG_FILTER_???";
d629 31
a659 1
		return "HOOK_???";
d673 325
a997 2
		return filter_name;
	return "filter";
@


1.13
log
@Zap the mfa process. It is not currently doing anything, and content filtering
will be done at session level anyway.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a854 10
}

const char *
imsg_to_str(int imsg)
{
	static char buf[32];

	snprintf(buf, sizeof(buf), "%d", imsg);

	return (buf);
@


1.12
log
@bcopy -> memmove
bzero -> memset
@
text
@d418 1
a418 1
	fi.p.proc = PROC_MFA;
@


1.11
log
@fix format string
@
text
@d417 1
a417 1
	bzero(&fi, sizeof(fi));
@


1.10
log
@Make the filter infrastructure move forward.
This is a work-in-progress and it's not supposed to be useable for now.
@
text
@d679 1
a679 1
	log_debug("debug: filter-api:%s: tx eom (%zu) for %p", filter_name, s->pipe.datalen, s->id);
d683 1
a683 1
		    filter_name, s->pipe.idatalen != s->pipe.datalen);
@


1.9
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: filter_api.c,v 1.8 2013/07/19 16:02:00 eric Exp $	*/
d4 1
a23 1
#include <err.h>
d27 1
d35 1
d37 1
a37 1
static struct tree		queries;
d39 26
a64 3
struct query {
	uint64_t		qid;
	enum filter_hook	hook;
a65 1
static int			register_done;
d67 2
a68 1
static const char *filter_name;
d82 5
a86 5
		void (*connect)(uint64_t, uint64_t, struct filter_connect *);
		void (*helo)(uint64_t, uint64_t, const char *);
		void (*mail)(uint64_t, uint64_t, struct mailaddr *);
		void (*rcpt)(uint64_t, uint64_t, struct mailaddr *);
		void (*data)(uint64_t, uint64_t);
d88 1
a88 1
		void (*eom)(uint64_t, uint64_t);
a90 1

d94 3
a96 1
static void filter_response(uint64_t, int, int, const char *line, int);
d101 1
a101 1
static void filter_dispatch_eom(uint64_t, uint64_t);
d107 5
d122 1
a122 1
filter_api_on_connect(void(*cb)(uint64_t, uint64_t, struct filter_connect *))
d131 1
a131 1
filter_api_on_helo(void(*cb)(uint64_t, uint64_t, const char *))
d140 1
a140 1
filter_api_on_mail(void(*cb)(uint64_t, uint64_t, struct mailaddr *))
d149 1
a149 1
filter_api_on_rcpt(void(*cb)(uint64_t, uint64_t, struct mailaddr *))
d158 1
a158 1
filter_api_on_data(void(*cb)(uint64_t, uint64_t))
d167 1
a167 1
filter_api_on_dataline(void(*cb)(uint64_t, const char *), int flags)
d171 1
a171 2
	fi.hooks |= HOOK_DATALINE;
	fi.flags |= flags & FILTER_ALTERDATA;
d176 1
a176 1
filter_api_on_eom(void(*cb)(uint64_t, uint64_t))
d197 2
a198 2
		errx(1, "filter_api_loop already called");
		return;
a206 2
	usleep(1000000);

d208 8
a215 4
		if (chroot(fi.rootpath) == -1)
			err(1, "chroot");
		if (chdir("/") == -1)
			err(1, "chdir");
d219 5
a223 3
            setresgid(fi.gid, fi.gid, fi.gid) ||
            setresuid(fi.uid, fi.uid, fi.uid))
                err(1, "cannot drop privileges");
d225 4
a228 2
	if (event_dispatch() < 0)
		errx(1, "event_dispatch");
d234 4
a237 1
	filter_response(id, FILTER_OK, 0, NULL, 0);
d241 1
a241 1
filter_api_accept_notify(uint64_t id)
d243 5
a247 1
	filter_response(id, FILTER_OK, 0, NULL, 1);
d253 4
d261 1
a261 1
	filter_response(id, status, 0, NULL, 0);
d268 4
d276 1
a276 1
	filter_response(id, status, code, line, 0);
d280 1
a280 1
filter_api_data(uint64_t id, const char *line)
d282 41
a322 4
	m_create(&fi.p, IMSG_FILTER_DATA, 0, 0, -1);
	m_add_id(&fi.p, id);
	m_add_string(&fi.p, line);
	m_close(&fi.p);
d326 1
a326 1
filter_response(uint64_t qid, int status, int code, const char *line, int notify)
d328 5
a332 1
	struct filter_query	*q;
d334 1
a334 2
	q = tree_xpop(&queries, qid);
	free(q);
d337 13
a349 6
	m_add_id(&fi.p, qid);
	m_add_int(&fi.p, status);
	m_add_int(&fi.p, code);
	m_add_int(&fi.p, notify);
	if (line)
		m_add_string(&fi.p, line);
d351 3
d361 8
a368 4
	if (! uid)
		errx(1, "filter_api_setugid: can't set uid=0");
	if (! gid)
		errx(1, "filter_api_setugid: can't set gid=0");
d401 3
d405 4
a408 2
	if (pw == NULL)
		err(1, "getpwnam");
d414 1
d431 1
d435 2
a436 2
	const char		*line;
	uint32_t		 v;
d439 1
d441 2
a442 1
	log_debug("debug: %s: imsg %d", filter_name, imsg->hdr.type);
d448 2
d451 4
a454 2
		if (v != FILTER_API_VERSION)
			errx(1, "API version mismatch");
d467 4
a477 1
		tree_xset(&queries, qid, NULL);
d484 6
d495 1
d501 1
d507 1
d512 1
d516 1
d518 2
a519 1
			filter_dispatch_eom(id, qid);
d522 16
a537 1
			errx(1, "bad query hook: %d", hook);
d539 33
a581 7
	case IMSG_FILTER_DATA:
		m_msg(&m, imsg);
		m_get_id(&m, &id);
		m_get_string(&m, &line);
		m_end(&m);
		filter_dispatch_dataline(id, line);
		break;
d586 22
a607 1
filter_dispatch_event(uint64_t id,  enum filter_hook event)
d621 1
a621 1
	fi.cb.connect(id, qid, conn);
d627 1
a627 1
	fi.cb.helo(id, qid, helo);
d633 1
a633 1
	fi.cb.mail(id, qid, mail);
d639 1
a639 1
	fi.cb.rcpt(id, qid, rcpt);
d645 23
a667 1
	fi.cb.data(id, qid);
d677 1
a677 1
filter_dispatch_eom(uint64_t id, uint64_t qid)
d679 162
a840 1
	fi.cb.eom(id, qid);
@


1.8
log
@Move the filter infrastructure forward.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d328 1
a328 1
	log_debug("debug: %s: imsg %i", filter_name, imsg->hdr.type);
d484 1
a484 1
	snprintf(buf, sizeof(buf), "%i", imsg);
@


1.7
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter_api.c,v 1.6 2013/01/26 09:37:23 gilles Exp $	*/
d27 1
d51 4
d179 12
d255 29
d288 1
d296 4
d310 4
a313 1

d389 1
a389 1
			errx(1, "bad query hook", hook);
@


1.6
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter_api.c,v 1.4 2012/08/19 14:16:58 chl Exp $	*/
d42 2
a76 6
const char *
proc_to_str(int proc)
{
	return "PEER";
}

d170 4
d214 1
a214 1
	m_create(&fi.p, IMSG_FILTER_DATA, 0, 0, -1, 1024);
d228 1
a228 1
	m_create(&fi.p, IMSG_FILTER_RESPONSE, 0, 0, -1, 64);
d241 1
d249 3
a251 1
	bzero(&fi, sizeof(fi));
d254 6
d274 2
d283 1
a283 1
		m_create(p, IMSG_FILTER_REGISTER, 0, 0, -1, 18);
d409 24
@


1.5
log
@knf
@
text
@d4 1
a4 1
 * Copyright (c) 2011 Gilles Chehade <gilles@@openbsd.org>
d32 9
a40 1
#include "filter_api.h"
d43 1
a43 2
	struct event	ev;
	struct imsgbuf	ibuf;
d45 14
a58 35
	enum filter_status
	(*connect_cb)(uint64_t, struct filter_connect *, void *);
	void *connect_cb_arg;

	enum filter_status
	(*helo_cb)(uint64_t, struct filter_helo *, void *);
	void *helo_cb_arg;

	enum filter_status
	(*ehlo_cb)(uint64_t, struct filter_helo *, void *);
	void *ehlo_cb_arg;

	enum filter_status
	(*mail_cb)(uint64_t, struct filter_mail *, void *);
	void *mail_cb_arg;

	enum filter_status
	(*rcpt_cb)(uint64_t, struct filter_rcpt *, void *);
	void *rcpt_cb_arg;

	enum filter_status
	(*dataline_cb)(uint64_t, struct filter_dataline *, void *);
	void *dataline_cb_arg;

	enum filter_status
	(*quit_cb)(uint64_t, void *);
	void *quit_cb_arg;

	enum filter_status
	(*close_cb)(uint64_t, void *);
	void *close_cb_arg;

	enum filter_status
	(*rset_cb)(uint64_t, void *);
	void *rset_cb_arg;
d62 35
a96 2
static void filter_handler(int, short, void *);
static void filter_register_callback(enum filter_type, void *, void *);
d99 1
a99 1
filter_init(void)
d101 1
a101 1
	bzero(&fi, sizeof (fi));
d103 8
a110 1
	imsg_init(&fi.ibuf, 0);
d112 11
a122 3
	event_init();
	event_set(&fi.ev, 0, EV_READ, filter_handler, (void *)&fi);
	event_add(&fi.ev, NULL);
d126 1
a126 1
filter_loop(void)
d128 4
a131 2
	if (event_dispatch() < 0)
		errx(1, "event_dispatch");
d135 1
a135 2
filter_register_connect_callback(enum filter_status
    (*cb)(uint64_t, struct filter_connect *, void *), void *cb_arg)
d137 5
a141 1
	filter_register_callback(FILTER_CONNECT, cb, cb_arg);
d145 1
a145 2
filter_register_helo_callback(enum filter_status
    (*cb)(uint64_t, struct filter_helo *, void *), void *cb_arg)
d147 4
a150 1
	filter_register_callback(FILTER_HELO, cb, cb_arg);
d154 1
a154 2
filter_register_ehlo_callback(enum filter_status
    (*cb)(uint64_t, struct filter_helo *, void *), void *cb_arg)
d156 4
a159 1
	filter_register_callback(FILTER_EHLO, cb, cb_arg);
d163 1
a163 2
filter_register_mail_callback(enum filter_status
    (*cb)(uint64_t, struct filter_mail *, void *), void *cb_arg)
d165 11
a175 1
	filter_register_callback(FILTER_MAIL, cb, cb_arg);
d179 1
a179 2
filter_register_rcpt_callback(enum filter_status
    (*cb)(uint64_t, struct filter_rcpt *, void *), void *cb_arg)
d181 1
a181 1
	filter_register_callback(FILTER_RCPT, cb, cb_arg);
d185 1
a185 2
filter_register_dataline_callback(enum filter_status
    (*cb)(uint64_t, struct filter_dataline *, void *), void *cb_arg)
d187 1
a187 1
	filter_register_callback(FILTER_DATALINE, cb, cb_arg);
d191 1
a191 2
filter_register_quit_callback(enum filter_status
    (*cb)(uint64_t, void *), void *cb_arg)
d193 5
a197 1
	filter_register_callback(FILTER_QUIT, cb, cb_arg);
d201 2
a202 2
filter_register_close_callback(enum filter_status
    (*cb)(uint64_t, void *), void *cb_arg)
d204 5
a208 1
	filter_register_callback(FILTER_CLOSE, cb, cb_arg);
d212 1
a212 2
filter_register_rset_callback(enum filter_status
    (*cb)(uint64_t, void *), void *cb_arg)
d214 22
a235 1
	filter_register_callback(FILTER_RSET, cb, cb_arg);
d239 1
a239 1
filter_register_callback(enum filter_type type, void *cb, void *cb_arg)
d241 1
a241 5
	switch (type) {
	case FILTER_CONNECT:
		fi.connect_cb = cb;
		fi.connect_cb_arg = cb_arg;
		break;
d243 2
a244 4
	case FILTER_HELO:
		fi.helo_cb = cb;
		fi.helo_cb_arg = cb_arg;
		break;
d246 1
a246 4
	case FILTER_EHLO:
		fi.ehlo_cb = cb;
		fi.ehlo_cb_arg = cb_arg;
		break;
d248 5
a252 4
	case FILTER_MAIL:
		fi.mail_cb = cb;
		fi.mail_cb_arg = cb_arg;
		break;
d254 22
a275 3
	case FILTER_RCPT:
		fi.rcpt_cb = cb;
		fi.rcpt_cb_arg = cb_arg;
d278 6
a283 3
	case FILTER_DATALINE:
		fi.dataline_cb = cb;
		fi.dataline_cb_arg = cb_arg;
d286 40
a325 3
	case FILTER_QUIT:
		fi.quit_cb = cb;
		fi.quit_cb_arg = cb_arg;
d328 6
a333 3
	case FILTER_CLOSE:
		fi.close_cb = cb;
		fi.close_cb_arg = cb_arg;
d336 6
a341 3
	case FILTER_RSET:
		fi.rset_cb = cb;
		fi.rset_cb_arg = cb_arg;
a342 3

	default:
		errx(1, "filter_register_callback: unknown filter type");
d347 1
a347 1
filter_handler(int fd, short event, void *p)
d349 2
a350 16
	struct imsg		imsg;
	ssize_t			n;
	short			evflags = EV_READ;
	enum filter_status	ret;
	struct filter_msg	fm;

	if (event & EV_READ) {
		n = imsg_read(&fi.ibuf);
		if (n == -1)
			err(1, "imsg_read");
		if (n == 0) {
			event_del(&fi.ev);
			event_loopexit(NULL);
			return;
		}
	}
d352 5
a356 6
	if (event & EV_WRITE) {
		if (msgbuf_write(&fi.ibuf.w) == -1)
			err(1, "msgbuf_write");
		if (fi.ibuf.w.queued)
			evflags |= EV_WRITE;
	}
d358 5
a362 6
	for (;;) {
		n = imsg_get(&fi.ibuf, &imsg);
		if (n == -1)
			errx(1, "imsg_get");
		if (n == 0)
			break;
d364 5
a368 3
		if ((imsg.hdr.len - IMSG_HEADER_SIZE)
		    != sizeof(fm))
			errx(1, "corrupted imsg");
d370 5
a374 3
		memcpy(&fm, imsg.data, sizeof (fm));
		if (fm.version != FILTER_API_VERSION)
			errx(1, "API version mismatch");
d376 5
a380 52
		switch (imsg.hdr.type) {
		case FILTER_CONNECT:
			if (fi.connect_cb == NULL)
				goto ignore;
			ret = fi.connect_cb(fm.cl_id, &fm.u.connect,
			    fi.connect_cb_arg);
			break;
		case FILTER_HELO:
			if (fi.helo_cb == NULL)
				goto ignore;
			ret = fi.helo_cb(fm.cl_id, &fm.u.helo,
			    fi.helo_cb_arg);
			break;
		case FILTER_EHLO:
			if (fi.ehlo_cb == NULL)
				goto ignore;
			ret = fi.ehlo_cb(fm.cl_id, &fm.u.helo,
			    fi.ehlo_cb_arg);
			break;
		case FILTER_MAIL:
			if (fi.mail_cb == NULL)
				goto ignore;
			ret = fi.mail_cb(fm.cl_id, &fm.u.mail,
			    fi.mail_cb_arg);
			break;
		case FILTER_RCPT:
			if (fi.rcpt_cb == NULL)
				goto ignore;
			ret = fi.rcpt_cb(fm.cl_id, &fm.u.rcpt,
			    fi.rcpt_cb_arg);
			break;
		case FILTER_DATALINE:
			if (fi.dataline_cb == NULL)
				goto ignore;
			ret = fi.dataline_cb(fm.cl_id, &fm.u.dataline,
			    fi.dataline_cb_arg);
			break;
		case FILTER_QUIT:
			if (fi.quit_cb == NULL)
				goto ignore;
			ret = fi.quit_cb(fm.cl_id, fi.quit_cb_arg);
			break;
		case FILTER_CLOSE:
			if (fi.close_cb == NULL)
				goto ignore;
			ret = fi.close_cb(fm.cl_id, fi.close_cb_arg);
			break;
		case FILTER_RSET:
			if (fi.rset_cb == NULL)
				goto ignore;
			ret = fi.rset_cb(fm.cl_id, fi.rset_cb_arg);
			break;
d382 5
a386 3
		default:
			errx(1, "unsupported imsg");
		}
d388 5
a392 12
		switch (ret) {
		case STATUS_ACCEPT:
		case STATUS_REJECT:
			fm.code = ret;
			imsg_compose(&fi.ibuf, imsg.hdr.type, 0, 0, -1, &fm,
			    sizeof fm);
			evflags |= EV_WRITE;
			break;
		case STATUS_WAITING:
			/* waiting for asynchronous call ... */
			break;
		}
d394 4
a397 14
		imsg_free(&imsg);
	}

	event_set(&fi.ev, 0, evflags, filter_handler, &fi);
	event_add(&fi.ev, NULL);
	return;

ignore:
	imsg_free(&imsg);
	fm.code = STATUS_IGNORE;
	imsg_compose(&fi.ibuf, imsg.hdr.type, 0, 0, -1, &fm, sizeof fm);
	evflags |= EV_WRITE;
	event_set(&fi.ev, 0, evflags, filter_handler, &fi);
	event_add(&fi.ev, NULL);
@


1.4
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter_api.c,v 1.3 2012/06/16 16:16:09 chl Exp $	*/
d38 2
a39 1
	enum filter_status (*connect_cb)(uint64_t, struct filter_connect *, void *);
d42 2
a43 1
	enum filter_status (*helo_cb)(uint64_t, struct filter_helo *, void *);
d46 2
a47 1
	enum filter_status (*ehlo_cb)(uint64_t, struct filter_helo *, void *);
d50 2
a51 1
	enum filter_status (*mail_cb)(uint64_t, struct filter_mail *, void *);
d54 2
a55 1
	enum filter_status (*rcpt_cb)(uint64_t, struct filter_rcpt *, void *);
d58 2
a59 1
	enum filter_status (*dataline_cb)(uint64_t, struct filter_dataline *, void *);
d62 2
a63 1
	enum filter_status (*quit_cb)(uint64_t, void *);
d66 2
a67 1
	enum filter_status (*close_cb)(uint64_t, void *);
d70 2
a71 1
	enum filter_status (*rset_cb)(uint64_t, void *);
d99 2
a100 1
filter_register_connect_callback(enum filter_status (*cb)(uint64_t, struct filter_connect *, void *), void *cb_arg)
d106 2
a107 1
filter_register_helo_callback(enum filter_status (*cb)(uint64_t, struct filter_helo *, void *), void *cb_arg)
d113 2
a114 1
filter_register_ehlo_callback(enum filter_status (*cb)(uint64_t, struct filter_helo *, void *), void *cb_arg)
d120 2
a121 1
filter_register_mail_callback(enum filter_status (*cb)(uint64_t, struct filter_mail *, void *), void *cb_arg)
d127 2
a128 1
filter_register_rcpt_callback(enum filter_status (*cb)(uint64_t, struct filter_rcpt *, void *), void *cb_arg)
d134 2
a135 1
filter_register_dataline_callback(enum filter_status (*cb)(uint64_t, struct filter_dataline *, void *), void *cb_arg)
d141 2
a142 1
filter_register_quit_callback(enum filter_status (*cb)(uint64_t, void *), void *cb_arg)
d148 2
a149 1
filter_register_close_callback(enum filter_status (*cb)(uint64_t, void *), void *cb_arg)
d155 2
a156 1
filter_register_rset_callback(enum filter_status (*cb)(uint64_t, void *), void *cb_arg)
d308 1
a308 1
 			break;
@


1.3
log
@rename filter.c --> filter_api.c (to be consistent with upcoming changes)

prompted by and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter_api.c,v 1.7 2012/06/14 21:56:13 gilles Exp $	*/
d38 1
a38 1
	enum filter_status (*connect_cb)(u_int64_t, struct filter_connect *, void *);
d41 1
a41 1
	enum filter_status (*helo_cb)(u_int64_t, struct filter_helo *, void *);
d44 1
a44 1
	enum filter_status (*ehlo_cb)(u_int64_t, struct filter_helo *, void *);
d47 1
a47 1
	enum filter_status (*mail_cb)(u_int64_t, struct filter_mail *, void *);
d50 1
a50 1
	enum filter_status (*rcpt_cb)(u_int64_t, struct filter_rcpt *, void *);
d53 1
a53 1
	enum filter_status (*dataline_cb)(u_int64_t, struct filter_dataline *, void *);
d56 1
a56 1
	enum filter_status (*quit_cb)(u_int64_t, void *);
d59 1
a59 1
	enum filter_status (*close_cb)(u_int64_t, void *);
d62 1
a62 1
	enum filter_status (*rset_cb)(u_int64_t, void *);
d90 1
a90 1
filter_register_connect_callback(enum filter_status (*cb)(u_int64_t, struct filter_connect *, void *), void *cb_arg)
d96 1
a96 1
filter_register_helo_callback(enum filter_status (*cb)(u_int64_t, struct filter_helo *, void *), void *cb_arg)
d102 1
a102 1
filter_register_ehlo_callback(enum filter_status (*cb)(u_int64_t, struct filter_helo *, void *), void *cb_arg)
d108 1
a108 1
filter_register_mail_callback(enum filter_status (*cb)(u_int64_t, struct filter_mail *, void *), void *cb_arg)
d114 1
a114 1
filter_register_rcpt_callback(enum filter_status (*cb)(u_int64_t, struct filter_rcpt *, void *), void *cb_arg)
d120 1
a120 1
filter_register_dataline_callback(enum filter_status (*cb)(u_int64_t, struct filter_dataline *, void *), void *cb_arg)
d126 1
a126 1
filter_register_quit_callback(enum filter_status (*cb)(u_int64_t, void *), void *cb_arg)
d132 1
a132 1
filter_register_close_callback(enum filter_status (*cb)(u_int64_t, void *), void *cb_arg)
d138 1
a138 1
filter_register_rset_callback(enum filter_status (*cb)(u_int64_t, void *), void *cb_arg)
@


1.2
log
@- rename filter.h -> filter_api.h to be consistent with upcoming changes
@
text
@d1 1
a1 1
/*	$OpenBSD: filter_api.c,v 1.1 2011/11/15 23:22:47 gilles Exp $	*/
d20 11
d33 291
@


1.1
log
@- change callback prototypes in filter.c to allow stricter checks
- introduce STATUS_WAITING, filters will reroute async DNS queries through
  LKA in a near future
- filter_api.c will contain our filter API (empty for now)
- Makefile to build libsmtpdfilter (not linked to the build,dev stuff only)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d21 1
a21 1
#include "filter.h"
@

