head	1.56;
access;
symbols
	OPENBSD_5_0:1.49.0.2
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14;
locks; strict;
comment	@ * @;


1.56
date	2011.12.14.23.08.40;	author eric;	state dead;
branches;
next	1.55;

1.55
date	2011.12.14.18.42.27;	author eric;	state Exp;
branches;
next	1.54;

1.54
date	2011.11.15.23.06.39;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2011.10.27.14.32.57;	author chl;	state Exp;
branches;
next	1.52;

1.52
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2011.08.29.21.43.09;	author chl;	state Exp;
branches;
next	1.50;

1.50
date	2011.08.28.22.20.27;	author chl;	state Exp;
branches;
next	1.49;

1.49
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.48;

1.48
date	2011.05.10.17.04.43;	author gilles;	state Exp;
branches;
next	1.47;

1.47
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.46;

1.46
date	2011.04.17.11.39.22;	author gilles;	state Exp;
branches;
next	1.45;

1.45
date	2011.04.15.17.30.23;	author gilles;	state Exp;
branches;
next	1.44;

1.44
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.14.23.29.56;	author gilles;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.14.23.26.16;	author gilles;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.14.22.36.09;	author gilles;	state Exp;
branches;
next	1.40;

1.40
date	2011.04.14.22.00.26;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.14.21.53.46;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.14.20.11.08;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.13.20.53.18;	author gilles;	state Exp;
branches;
next	1.36;

1.36
date	2011.03.21.09.21.57;	author gilles;	state Exp;
branches;
next	1.35;

1.35
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.34;

1.34
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.33;

1.33
date	2010.11.15.14.57.40;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2010.10.28.21.15.50;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2010.10.09.22.12.26;	author gilles;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.01.23.06.23;	author jacekm;	state dead;
branches;
next	1.29;

1.29
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.31.23.38.56;	author jacekm;	state dead;
branches;
next	1.27;

1.27
date	2009.12.14.18.16.01;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.08.21.40.05;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.15.16.50.06;	author jacekm;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.04.13.33.00;	author jacekm;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.04.11.44.23;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.08.23.02.43;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.06.16.46.57;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.06.13.40.45;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.28.22.03.55;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.10.11.29.40;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.19.12.42.39;	author jacekm;	state Exp;
branches;
next	1.16;

1.16
date	2009.04.12.12.33.43;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.09.11.29.52;	author jacekm;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.24.12.07.47;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.23.00.51.32;	author chl;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.22.23.29.54;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.22.11.55.17;	author jacekm;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.16.10.15.10;	author jacekm;	state Exp;
branches;
next	1.8;

1.8
date	2009.02.15.13.44.06;	author jacekm;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.14.00.00.47;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.30.16.37.52;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.29.12.43.25;	author jacekm;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.28.17.29.11;	author jacekm;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.28.12.58.17;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.28.11.27.57;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.27.22.54.01;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.56
log
@finally kill queue_shared.c and move what is left to bounce.c
where it belongs.

ok gilles@@
@
text
@/*	$OpenBSD: queue_shared.c,v 1.55 2011/12/14 18:42:27 eric Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2008-2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

int
bounce_record_message(struct envelope *e, struct envelope *bounce)
{
	u_int32_t msgid;

	bzero(bounce, sizeof(*bounce));

	if (e->type == D_BOUNCE) {
		log_debug("mailer daemons loop detected !");
		return 0;
	}

	*bounce = *e;
	 bounce->type = D_BOUNCE;
	 bounce->status &= ~DS_PERMFAILURE;

	msgid = evpid_to_msgid(e->id);
	if (! queue_message_create(Q_BOUNCE, &msgid))
		return 0;

	bounce->id = msgid_to_evpid(msgid);
	if (! queue_envelope_create(Q_BOUNCE, bounce))
		return 0;

	return queue_message_commit(Q_BOUNCE, msgid);
}

void
queue_message_update(struct envelope *e)
{
	e->batch_id = 0;
	e->status &= ~(DS_ACCEPTED|DS_REJECTED);
	e->retry++;


	if (e->status & DS_PERMFAILURE) {
		if (e->type != D_BOUNCE &&
		    e->sender.user[0] != '\0') {
			struct envelope bounce;

			bounce_record_message(e, &bounce);
		}
		queue_envelope_delete(Q_QUEUE, e);
		return;
	}

	if (e->status & DS_TEMPFAILURE) {
		e->status &= ~DS_TEMPFAILURE;
		queue_envelope_update(Q_QUEUE, e);
		return;
	}

	/* no error, remove envelope */
	queue_envelope_delete(Q_QUEUE, e);
}
@


1.55
log
@move show_queue() and related functions from queue_shared.c
to smtpctl.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.54 2011/11/15 23:06:39 gilles Exp $	*/
@


1.54
log
@Qwalk, our API to linearly walk over the persistent queue, did not take the
queue_backend into account and assumed a filesystem with a specific layout.

This commit does plenty of things:

- make qwalk an abstraction in the queue_backend API, and impose queue
  drivers to implement qwalk_open(), qwalk() and qwalk_close();

- move previous qwalk_open(), qwalk() and qwalk_close() to the fsqueue
  driver since they were fsqueue specific ...

- make qwalk API work with msgid/evpid instead of pathnames since we're
  going to use the queue_backend API to load envelopes by evpid anyway;

- makes smtpd use *solely* the queue_backend API when manipulating the
  queue. pathnames were removed from smtpd.h and moved into the fsqueue
  which means we can now store a queue anywhere ... as long as we write
  the ten functions or so required for a queue driver ;-)

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.53 2011/10/27 14:32:57 chl Exp $	*/
a42 5
int	fsqueue_load_envelope_ascii(FILE *, struct envelope *);

void		display_envelope(struct envelope *, int);
void		getflag(u_int *, int, char *, char *, size_t);

a96 94
}

void
show_queue(enum queue_kind kind, int flags)
{
	struct qwalk	*q;
	struct envelope	 envelope;
	u_int64_t	 evpid;

	log_init(1);

	if (chroot(PATH_SPOOL) == -1 || chdir(".") == -1)
		err(1, "%s", PATH_SPOOL);

	q = qwalk_new(kind, 0);

	while (qwalk(q, &evpid)) {
		if (! queue_envelope_load(kind, evpid, &envelope))
			continue;
		display_envelope(&envelope, flags);
	}

	qwalk_close(q);
}

void
display_envelope(struct envelope *e, int flags)
{
	char	 status[128];

	status[0] = '\0';

	getflag(&e->status, DS_TEMPFAILURE, "TEMPFAIL",
	    status, sizeof(status));

	if (e->status)
		errx(1, "%016" PRIx64 ": unexpected status 0x%04x", e->id,
		    e->status);

	getflag(&e->flags, DF_BOUNCE, "BOUNCE",
	    status, sizeof(status));
	getflag(&e->flags, DF_AUTHENTICATED, "AUTH",
	    status, sizeof(status));
	getflag(&e->flags, DF_ENQUEUED, "ENQUEUED",
	    status, sizeof(status));
	getflag(&e->flags, DF_INTERNAL, "INTERNAL",
	    status, sizeof(status));

	if (e->flags)
		errx(1, "%016" PRIx64 ": unexpected flags 0x%04x", e->id,
		    e->flags);
	
	if (status[0])
		status[strlen(status) - 1] = '\0';
	else
		strlcpy(status, "-", sizeof(status));

	switch (e->type) {
	case D_MDA:
		printf("MDA");
		break;
	case D_MTA:
		printf("MTA");
		break;
	case D_BOUNCE:
		printf("BOUNCE");
		break;
	default:
		printf("UNKNOWN");
	}
	
	printf("|%016" PRIx64 "|%s|%s@@%s|%s@@%s|%" PRId64 "|%" PRId64 "|%u",
	    e->id,
	    status,
	    e->sender.user, e->sender.domain,
	    e->dest.user, e->dest.domain,
	    (int64_t) e->lasttry,
	    (int64_t) e->expire,
	    e->retry);
	
	if (e->errorline[0] != '\0')
		printf("|%s", e->errorline);

	printf("\n");
}

void
getflag(u_int *bitmap, int bit, char *bitstr, char *buf, size_t len)
{
	if (*bitmap & bit) {
		*bitmap &= ~bit;
		strlcat(buf, bitstr, len);
		strlcat(buf, ",", len);
	}
@


1.53
log
@Use PRI{x,d}64 in format strings instead of %llx, %lld or %qd to print {u_,}int64_t or time_t

While there, cast some time_t to int64_t

These will fix build warnings for portable smptd

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.52 2011/10/23 09:30:07 gilles Exp $	*/
a42 4
#define	QWALK_AGAIN	0x1
#define	QWALK_RECURSE	0x2
#define	QWALK_RETURN	0x3

a44 12
struct qwalk {
	char	  path[MAXPATHLEN];
	DIR	 *dirs[3];
	int	(*filefn)(struct qwalk *, char *);
	int	  bucket;
	int	  level;
	int	  strict;
};

int		walk_simple(struct qwalk *, char *);
int		walk_queue(struct qwalk *, char *);

a103 77
struct qwalk *
qwalk_new(char *path)
{
	struct qwalk *q;

	q = calloc(1, sizeof(struct qwalk));
	if (q == NULL)
		fatal("qwalk_new: calloc");

	strlcpy(q->path, path, sizeof(q->path));

	q->level = 0;
	q->strict = 0;
	q->filefn = walk_simple;

	if (smtpd_process == PROC_QUEUE || smtpd_process == PROC_RUNNER)
		q->strict = 1;

	if (strcmp(path, PATH_QUEUE) == 0)
		q->filefn = walk_queue;

	q->dirs[0] = opendir(q->path);
	if (q->dirs[0] == NULL)
		fatal("qwalk_new: opendir");

	return (q);
}

int
qwalk(struct qwalk *q, char *filepath)
{
	struct dirent	*dp;

again:
	errno = 0;
	dp = readdir(q->dirs[q->level]);
	if (errno)
		fatal("qwalk: readdir");
	if (dp == NULL) {
		closedir(q->dirs[q->level]);
		q->dirs[q->level] = NULL;
		if (q->level == 0)
			return (0);
		q->level--;
		goto again;
	}

	if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
		goto again;

	switch (q->filefn(q, dp->d_name)) {
	case QWALK_AGAIN:
		goto again;
	case QWALK_RECURSE:
		goto recurse;
	case QWALK_RETURN:
		if (! bsnprintf(filepath, MAXPATHLEN, "%s/%s", q->path,
			dp->d_name))
			fatalx("qwalk: snprintf");
		return (1);
	default:
		fatalx("qwalk: callback failed");
	}

recurse:
	q->level++;
	q->dirs[q->level] = opendir(q->path);
	if (q->dirs[q->level] == NULL) {
		if (errno == ENOENT && !q->strict) {
			q->level--;
			goto again;
		}
		fatal("qwalk: opendir");
	}
	goto again;
}

d105 1
a105 20
qwalk_close(struct qwalk *q)
{
	int i;

	for (i = 0; i <= q->level; i++)
		if (q->dirs[i])
			closedir(q->dirs[i]);

	bzero(q, sizeof(struct qwalk));
	free(q);
}

int
walk_simple(struct qwalk *q, char *fname)
{
	return (QWALK_RETURN);
}

int
walk_queue(struct qwalk *q, char *fname)
a106 37
	char	*ep;

	switch (q->level) {
	case 0:
		if (strcmp(fname, "envelope.tmp") == 0)
			return (QWALK_AGAIN);

		q->bucket = strtoul(fname, &ep, 16);
		if (fname[0] == '\0' || *ep != '\0') {
			log_warnx("walk_queue: invalid bucket: %s", fname);
			return (QWALK_AGAIN);
		}
		if (errno == ERANGE || q->bucket >= DIRHASH_BUCKETS) {
			log_warnx("walk_queue: invalid bucket: %s", fname);
			return (QWALK_AGAIN);
		}
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%03x", PATH_QUEUE,
			q->bucket & 0xfff))
			fatalx("walk_queue: snprintf");
		return (QWALK_RECURSE);
	case 1:
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%03x/%s%s",
			PATH_QUEUE, q->bucket & 0xfff, fname, PATH_ENVELOPES))
			fatalx("walk_queue: snprintf");
		return (QWALK_RECURSE);
	case 2:
		return (QWALK_RETURN);
	}

	return (-1);
}

void
show_queue(char *queuepath, int flags)
{
	char		 path[MAXPATHLEN];
	struct envelope	 message;
d108 2
a109 1
	FILE		*fp;
d116 1
a116 14
	q = qwalk_new(queuepath);

	while (qwalk(q, path)) {
		fp = fopen(path, "r");
		if (fp == NULL) {
			if (errno == ENOENT)
				continue;
			err(1, "%s", path);
		}

		errno = 0;
		if (! fsqueue_load_envelope_ascii(fp, &message))
			err(1, "%s", path);
		fclose(fp);
d118 4
a121 1
		display_envelope(&message, flags);
@


1.52
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.51 2011/08/29 21:43:09 chl Exp $	*/
d34 1
d296 1
a296 1
		errx(1, "%016llx: unexpected status 0x%04x", e->id,
d309 1
a309 1
		errx(1, "%016llx: unexpected flags 0x%04x", e->id,
d331 1
a331 1
	printf("|%016llx|%s|%s@@%s|%s@@%s|%lld|%lld|%u",
d336 2
a337 2
	    (long long int) e->lasttry,
	    (long long int) e->expire,
@


1.51
log
@cast all printed time_t to long long int, and change format string accordingly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.50 2011/08/28 22:20:27 chl Exp $	*/
d46 2
d70 1
a70 1
	if (e->delivery.type == D_BOUNCE) {
d76 2
a77 2
	 bounce->delivery.type = D_BOUNCE;
	 bounce->delivery.status &= ~DS_PERMFAILURE;
d79 1
a79 1
	msgid = evpid_to_msgid(e->delivery.id);
d83 1
a83 1
	bounce->delivery.id = msgid_to_evpid(msgid);
d94 2
a95 3
	e->delivery.flags &= ~DF_PROCESSING;
	e->delivery.status &= ~(DS_ACCEPTED|DS_REJECTED);
	e->delivery.retry++;
d98 3
a100 3
	if (e->delivery.status & DS_PERMFAILURE) {
		if (e->delivery.type != D_BOUNCE &&
		    e->delivery.from.user[0] != '\0') {
d109 2
a110 2
	if (e->delivery.status & DS_TEMPFAILURE) {
		e->delivery.status &= ~DS_TEMPFAILURE;
d234 2
a235 2
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%04x", PATH_QUEUE,
			q->bucket))
d239 2
a240 2
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%04x/%s%s",
			PATH_QUEUE, q->bucket, fname, PATH_ENVELOPES))
d274 1
a274 1
		if (fread(&message, sizeof(message), 1, fp) != 1)
d291 1
a291 1
	getflag(&e->delivery.status, DS_TEMPFAILURE, "TEMPFAIL",
d294 3
a296 3
	if (e->delivery.status)
		errx(1, "%016llx: unexpected status 0x%04x", e->delivery.id,
		    e->delivery.status);
d298 1
a298 5
	getflag(&e->delivery.flags, DF_BOUNCE, "BOUNCE",
	    status, sizeof(status));
	getflag(&e->delivery.flags, DF_AUTHENTICATED, "AUTH",
	    status, sizeof(status));
	getflag(&e->delivery.flags, DF_PROCESSING, "PROCESSING",
d300 1
a300 1
	getflag(&e->delivery.flags, DF_SCHEDULED, "SCHEDULED",
d302 1
a302 1
	getflag(&e->delivery.flags, DF_ENQUEUED, "ENQUEUED",
d304 1
a304 1
	getflag(&e->delivery.flags, DF_FORCESCHEDULE, "SCHEDULED_MANUAL",
d307 3
a309 3
	if (e->delivery.flags)
		errx(1, "%016llx: unexpected flags 0x%04x", e->delivery.id,
		    e->delivery.flags);
d316 1
a316 1
	switch (e->delivery.type) {
d331 1
a331 1
	    e->delivery.id,
d333 5
a337 5
	    e->delivery.from.user, e->delivery.from.domain,
	    e->delivery.rcpt.user, e->delivery.rcpt.domain,
	    (long long int) e->delivery.lasttry,
	    (long long int) e->delivery.expire,
	    e->delivery.retry);
d339 2
a340 2
	if (e->delivery.errorline[0] != '\0')
		printf("|%s", e->delivery.errorline);
@


1.50
log
@Clear bounce envelope structure, to avoid wrong use when bounce_record_message() returns 0.

Initial report from me, tweak from gilles@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.49 2011/05/16 21:05:52 gilles Exp $	*/
d333 1
a333 1
	printf("|%016llx|%s|%s@@%s|%s@@%s|%d|%d|%u",
d338 2
a339 2
	    e->delivery.lasttry,
	    e->delivery.expire,
@


1.49
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.48 2011/05/10 17:04:43 gilles Exp $	*/
d65 2
@


1.48
log
@fix an off-by-one that made smtpd skip an "invalid" bucket that was
actually valid.

bugfix tested by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.47 2011/05/01 12:57:11 eric Exp $	*/
d62 1
a62 1
bounce_record_message(struct envelope *m, struct envelope *bounce)
d66 1
a66 1
	if (m->type == T_BOUNCE_MESSAGE) {
d71 3
a73 3
	*bounce = *m;
	 bounce->type = T_BOUNCE_MESSAGE;
	 bounce->status &= ~S_MESSAGE_PERMFAILURE;
d75 1
a75 1
	msgid = evpid_to_msgid(m->evpid);
d79 1
a79 1
	bounce->evpid = msgid_to_evpid(msgid);
d87 1
a87 1
queue_message_update(struct envelope *m)
d89 9
a97 8
	m->flags &= ~F_MESSAGE_PROCESSING;
	m->status &= ~(S_MESSAGE_ACCEPTED|S_MESSAGE_REJECTED);
	m->batch_id = 0;
	m->retry++;

	if (m->status & S_MESSAGE_PERMFAILURE) {
		if (m->type != T_BOUNCE_MESSAGE &&
		    m->sender.user[0] != '\0') {
d100 1
a100 1
			bounce_record_message(m, &bounce);
d102 1
a102 1
		queue_envelope_delete(Q_QUEUE, m);
d106 3
a108 3
	if (m->status & S_MESSAGE_TEMPFAILURE) {
		m->status &= ~S_MESSAGE_TEMPFAILURE;
		queue_envelope_update(Q_QUEUE, m);
d113 1
a113 1
	queue_envelope_delete(Q_QUEUE, m);
d282 1
a282 1
display_envelope(struct envelope *m, int flags)
d288 1
a288 1
	getflag(&m->status, S_MESSAGE_TEMPFAILURE, "TEMPFAIL",
d291 3
a293 3
	if (m->status)
		errx(1, "%016llx: unexpected status 0x%04x", m->evpid,
		    m->status);
d295 1
a295 1
	getflag(&m->flags, F_MESSAGE_BOUNCE, "BOUNCE",
d297 1
a297 1
	getflag(&m->flags, F_MESSAGE_AUTHENTICATED, "AUTH",
d299 1
a299 1
	getflag(&m->flags, F_MESSAGE_PROCESSING, "PROCESSING",
d301 1
a301 1
	getflag(&m->flags, F_MESSAGE_SCHEDULED, "SCHEDULED",
d303 1
a303 1
	getflag(&m->flags, F_MESSAGE_ENQUEUED, "ENQUEUED",
d305 1
a305 1
	getflag(&m->flags, F_MESSAGE_FORCESCHEDULE, "SCHEDULED_MANUAL",
d308 3
a310 3
	if (m->flags)
		errx(1, "%016llx: unexpected flags 0x%04x", m->evpid,
		    m->flags);
d317 2
a318 2
	switch (m->type) {
	case T_MDA_MESSAGE:
d321 1
a321 1
	case T_MTA_MESSAGE:
d324 1
a324 1
	case T_BOUNCE_MESSAGE:
d332 1
a332 1
	    m->evpid,
d334 5
a338 5
	    m->sender.user, m->sender.domain,
	    m->recipient.user, m->recipient.domain,
	    m->lasttry,
	    m->expire,
	    m->retry);
d340 2
a341 2
	if (m->session_errorline[0] != '\0')
		printf("|%s", m->session_errorline);
@


1.47
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.46 2011/04/17 11:39:22 gilles Exp $	*/
d226 1
a226 1
		if (errno == ERANGE || q->bucket >= DIRHASH_BUCKETS - 1) {
@


1.46
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.45 2011/04/15 17:30:23 gilles Exp $	*/
d62 1
a62 1
bounce_record_message(struct smtpd *env, struct envelope *m, struct envelope *bounce)
d76 1
a76 1
	if (! queue_message_create(env, Q_BOUNCE, &msgid))
d80 1
a80 1
	if (! queue_envelope_create(env, Q_BOUNCE, bounce))
d83 1
a83 1
	return queue_message_commit(env, Q_BOUNCE, msgid);
d87 1
a87 1
queue_message_update(struct smtpd *env, struct envelope *m)
d99 1
a99 1
			bounce_record_message(env, m, &bounce);
d101 1
a101 1
		queue_envelope_delete(env, Q_QUEUE, m);
d107 1
a107 1
		queue_envelope_update(env, Q_QUEUE, m);
d112 1
a112 1
	queue_envelope_delete(env, Q_QUEUE, m);
@


1.45
log
@teach walk_queue() about the new disk-queue layout
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.44 2011/04/15 17:01:05 gilles Exp $	*/
d58 1
a58 1
void		display_envelope(struct message *, int);
d62 1
a62 1
bounce_record_message(struct smtpd *env, struct message *messagep, struct message *mbounce)
d66 1
a66 1
	if (messagep->type == T_BOUNCE_MESSAGE) {
d71 3
a73 3
	*mbounce = *messagep;
	mbounce->type = T_BOUNCE_MESSAGE;
	mbounce->status &= ~S_MESSAGE_PERMFAILURE;
d75 1
a75 1
	msgid = evpid_to_msgid(messagep->evpid);
d79 2
a80 2
	mbounce->evpid = msgid_to_evpid(msgid);
	if (! queue_envelope_create(env, Q_BOUNCE, mbounce))
d87 1
a87 1
queue_message_update(struct smtpd *env, struct message *messagep)
d89 9
a97 9
	messagep->flags &= ~F_MESSAGE_PROCESSING;
	messagep->status &= ~(S_MESSAGE_ACCEPTED|S_MESSAGE_REJECTED);
	messagep->batch_id = 0;
	messagep->retry++;

	if (messagep->status & S_MESSAGE_PERMFAILURE) {
		if (messagep->type != T_BOUNCE_MESSAGE &&
		    messagep->sender.user[0] != '\0') {
			struct message bounce;
d99 1
a99 1
			bounce_record_message(env, messagep, &bounce);
d101 1
a101 1
		queue_envelope_delete(env, Q_QUEUE, messagep);
d105 3
a107 3
	if (messagep->status & S_MESSAGE_TEMPFAILURE) {
		messagep->status &= ~S_MESSAGE_TEMPFAILURE;
		queue_envelope_update(env, Q_QUEUE, messagep);
d112 1
a112 1
	queue_envelope_delete(env, Q_QUEUE, messagep);
d250 1
a250 1
	struct message	 message;
d270 1
a270 1
		if (fread(&message, sizeof(struct message), 1, fp) != 1)
d281 1
a281 1
display_envelope(struct message *envelope, int flags)
d287 1
a287 1
	getflag(&envelope->status, S_MESSAGE_TEMPFAILURE, "TEMPFAIL",
d290 3
a292 3
	if (envelope->status)
		errx(1, "%016llx: unexpected status 0x%04x", envelope->evpid,
		    envelope->status);
d294 1
a294 1
	getflag(&envelope->flags, F_MESSAGE_BOUNCE, "BOUNCE",
d296 1
a296 1
	getflag(&envelope->flags, F_MESSAGE_AUTHENTICATED, "AUTH",
d298 1
a298 1
	getflag(&envelope->flags, F_MESSAGE_PROCESSING, "PROCESSING",
d300 1
a300 1
	getflag(&envelope->flags, F_MESSAGE_SCHEDULED, "SCHEDULED",
d302 1
a302 1
	getflag(&envelope->flags, F_MESSAGE_ENQUEUED, "ENQUEUED",
d304 1
a304 1
	getflag(&envelope->flags, F_MESSAGE_FORCESCHEDULE, "SCHEDULED_MANUAL",
d307 3
a309 3
	if (envelope->flags)
		errx(1, "%016llx: unexpected flags 0x%04x", envelope->evpid,
		    envelope->flags);
d316 1
a316 1
	switch (envelope->type) {
d331 1
a331 1
	    envelope->evpid,
d333 5
a337 5
	    envelope->sender.user, envelope->sender.domain,
	    envelope->recipient.user, envelope->recipient.domain,
	    envelope->lasttry,
	    envelope->expire,
	    envelope->retry);
d339 2
a340 2
	if (envelope->session_errorline[0] != '\0')
		printf("|%s", envelope->session_errorline);
@


1.44
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.43 2011/04/14 23:29:56 gilles Exp $	*/
d214 1
a214 1
	const char	*errstr;
d220 7
a226 2
		q->bucket = strtonum(fname, 0, DIRHASH_BUCKETS - 1, &errstr);
		if (errstr) {
d230 1
a230 1
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%d", PATH_QUEUE,
d235 1
a235 1
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%d/%s%s",
@


1.43
log
@bye bye queue_hash() you can now rest in peace.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.42 2011/04/14 23:26:16 gilles Exp $	*/
d64 1
a64 1
	char	msgid[MAX_ID_SIZE];
d75 2
a76 2
	strlcpy(msgid, messagep->message_id, sizeof(msgid));
	if (! queue_message_create(env, Q_BOUNCE, msgid))
d79 1
a79 1
	strlcpy(mbounce->message_id, msgid, sizeof(mbounce->message_id));
d286 1
a286 1
		errx(1, "%s: unexpected status 0x%04x", envelope->message_uid,
d303 1
a303 1
		errx(1, "%s: unexpected flags 0x%04x", envelope->message_uid,
d325 2
a326 2
	printf("|%s|%s|%s@@%s|%s@@%s|%d|%d|%u",
	    envelope->message_uid,
@


1.42
log
@- implement missing operations for fsqueue:
	fsqueue_envelope_create(), fsqueue_message_purge()
- kill deprecated functions in queue_shared.c

At this point fsqueue backend is almost complete, all that is left to do is
to move the qwalk() API inside the queue_backend API, then make sure smtpd
is no longer calling anything queue related directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.41 2011/04/14 22:36:09 gilles Exp $	*/
a112 11
}

u_int16_t
queue_hash(char *msgid)
{
	u_int16_t	h;

	for (h = 5381; *msgid; msgid++)
		h = ((h << 5) + h) + *msgid;

	return (h % DIRHASH_BUCKETS);
@


1.41
log
@- implement fsqueue_message_create() and fsqueue_message_commit()
- change a few prototypes to allow bounce messages to use the
	queue_backend API until it gets merged in
- kill functions of the queue API that have been deprecated
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.40 2011/04/14 22:00:26 gilles Exp $	*/
a60 128
void
queue_delete_layout_message(char *queuepath, char *msgid)
{
	char rootdir[MAXPATHLEN];
	char purgedir[MAXPATHLEN];

	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%s", queuepath, msgid))
		fatalx("snprintf");

	if (! bsnprintf(purgedir, sizeof(purgedir), "%s/%s", PATH_PURGE, msgid))
		fatalx("snprintf");

	if (rename(rootdir, purgedir) == -1)
		fatal("queue_delete_layout_message: rename");
}

int
queue_record_layout_envelope(char *queuepath, struct message *message)
{
	char evpname[MAXPATHLEN];
	FILE *fp;
	int fd;

	fp = NULL;

again:
	if (! bsnprintf(evpname, sizeof(evpname), "%s/%s%s/%s.%qu", queuepath,
		message->message_id, PATH_ENVELOPES, message->message_id,
		(u_int64_t)arc4random()))
		fatalx("queue_record_incoming_envelope: snprintf");

	fd = open(evpname, O_WRONLY|O_CREAT|O_EXCL, 0600);
	if (fd == -1) {
		if (errno == EEXIST)
			goto again;
		if (errno == ENOSPC || errno == ENFILE)
			goto tempfail;
		fatal("queue_record_incoming_envelope: open");
	}

	fp = fdopen(fd, "w");
	if (fp == NULL)
		fatal("queue_record_incoming_envelope: fdopen");

	message->creation = time(NULL);
	if (strlcpy(message->message_uid, strrchr(evpname, '/') + 1,
	    sizeof(message->message_uid)) >= sizeof(message->message_uid))
		fatalx("queue_record_incoming_envelope: truncation");

	if (fwrite(message, sizeof (struct message), 1, fp) != 1) {
		if (errno == ENOSPC)
			goto tempfail;
		fatal("queue_record_incoming_envelope: write");
	}

	if (! safe_fclose(fp)) {
		fp = NULL;
		fd = -1;
		goto tempfail;
	}

	return 1;

tempfail:
	unlink(evpname);
	if (fp)
		fclose(fp);
	else if (fd != -1)
		close(fd);
	message->creation = 0;
	message->message_uid[0] = '\0';

	return 0;
}

int
queue_remove_layout_envelope(char *queuepath, struct message *message)
{
	char pathname[MAXPATHLEN];

	if (! bsnprintf(pathname, sizeof(pathname), "%s/%s%s/%s", queuepath,
		message->message_id, PATH_ENVELOPES, message->message_uid))
		fatal("queue_remove_incoming_envelope: snprintf");

	if (unlink(pathname) == -1)
		fatal("queue_remove_incoming_envelope: unlink");

	return 1;
}

void
enqueue_delete_message(char *msgid)
{
	queue_delete_layout_message(PATH_ENQUEUE, msgid);
}

int
enqueue_record_envelope(struct message *message)
{
	return queue_record_layout_envelope(PATH_ENQUEUE, message);
}

int
enqueue_remove_envelope(struct message *message)
{
	return queue_remove_layout_envelope(PATH_ENQUEUE, message);
}

void
bounce_delete_message(char *msgid)
{
	queue_delete_layout_message(PATH_BOUNCE, msgid);
}

int
bounce_record_envelope(struct message *message)
{
	message->lasttry = 0;
	message->retry = 0;
	return queue_record_layout_envelope(PATH_BOUNCE, message);
}

int
bounce_remove_envelope(struct message *message)
{
	return queue_remove_layout_envelope(PATH_BOUNCE, message);
}

d80 1
a80 1
	if (! bounce_record_envelope(mbounce))
a83 18
}

void
queue_delete_incoming_message(char *msgid)
{
	queue_delete_layout_message(PATH_INCOMING, msgid);
}

int
queue_record_incoming_envelope(struct message *message)
{
	return queue_record_layout_envelope(PATH_INCOMING, message);
}

int
queue_remove_incoming_envelope(struct message *message)
{
	return queue_remove_layout_envelope(PATH_INCOMING, message);
@


1.40
log
@remove annoying log_debug()
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.39 2011/04/14 21:53:46 gilles Exp $	*/
a60 37
int
queue_create_layout_message(char *queuepath, char *message_id)
{
	char rootdir[MAXPATHLEN];
	char evpdir[MAXPATHLEN];

	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%d.XXXXXXXXXXXXXXXX",
		queuepath, time(NULL)))
		fatalx("queue_create_layout_message: snprintf");

	if (mkdtemp(rootdir) == NULL) {
		if (errno == ENOSPC) {
			bzero(message_id, MAX_ID_SIZE);
			return 0;
		}
		fatal("queue_create_layout_message: mkdtemp");
	}

	if (strlcpy(message_id, rootdir + strlen(queuepath) + 1, MAX_ID_SIZE)
	    >= MAX_ID_SIZE)
		fatalx("queue_create_layout_message: truncation");

	if (! bsnprintf(evpdir, sizeof(evpdir), "%s%s", rootdir,
		PATH_ENVELOPES))
		fatalx("queue_create_layout_message: snprintf");

	if (mkdir(evpdir, 0700) == -1) {
		if (errno == ENOSPC) {
			rmdir(rootdir);
			bzero(message_id, MAX_ID_SIZE);
			return 0;
		}
		fatal("queue_create_layout_message: mkdir");
	}
	return 1;
}

a150 41
int
queue_commit_layout_message(char *queuepath, struct message *messagep)
{
	char rootdir[MAXPATHLEN];
	char queuedir[MAXPATHLEN];
	
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%s", queuepath,
		messagep->message_id))
		fatal("queue_commit_message_incoming: snprintf");

	if (! bsnprintf(queuedir, sizeof(queuedir), "%s/%d", PATH_QUEUE,
		queue_hash(messagep->message_id)))
		fatal("queue_commit_message_incoming: snprintf");

	if (mkdir(queuedir, 0700) == -1) {
		if (errno == ENOSPC)
			return 0;
		if (errno != EEXIST)
			fatal("queue_commit_message_incoming: mkdir");
	}

	if (strlcat(queuedir, "/", sizeof(queuedir)) >= sizeof(queuedir) ||
	    strlcat(queuedir, messagep->message_id, sizeof(queuedir)) >=
	    sizeof(queuedir))
		fatalx("queue_commit_incoming_message: truncation");

	if (rename(rootdir, queuedir) == -1) {
		if (errno == ENOSPC)
			return 0;
		fatal("queue_commit_message_incoming: rename");
	}

	return 1;
}

int
enqueue_create_layout(char *msgid)
{
	return queue_create_layout_message(PATH_ENQUEUE, msgid);
}

a168 30
int
enqueue_commit_message(struct message *message)
{
	return queue_commit_layout_message(PATH_ENQUEUE, message);
}

int
bounce_create_layout(char *msgid, struct message *message)
{
	char	msgpath[MAXPATHLEN];
	char	lnkpath[MAXPATHLEN];

	if (! queue_create_layout_message(PATH_BOUNCE, msgid))
		return 0;

	if (! bsnprintf(msgpath, sizeof(msgpath), "%s/%d/%s/message",
		PATH_QUEUE, queue_hash(message->message_id),
		message->message_id))
		return 0;

	if (! bsnprintf(lnkpath, sizeof(lnkpath), "%s/%s/message",
		PATH_BOUNCE, msgid))
		return 0;

	if (link(msgpath, lnkpath) == -1)
		fatal("link");

	return 1;
}

d190 1
a190 7
bounce_commit_message(struct message *message)
{
	return queue_commit_layout_message(PATH_BOUNCE, message);
}

int
bounce_record_message(struct message *messagep, struct message *mbounce)
d203 2
a204 1
	if (! bounce_create_layout(msgid, messagep))
d211 1
a211 7
	return bounce_commit_message(mbounce);
}

int
queue_create_incoming_layout(char *msgid)
{
	return queue_create_layout_message(PATH_INCOMING, msgid);
a231 6
int
queue_commit_incoming_message(struct message *message)
{
	return queue_commit_layout_message(PATH_INCOMING, message);
}

d245 1
a245 1
			bounce_record_message(messagep, &bounce);
@


1.39
log
@fsqueue now provides fsqueue_message_fd_r() and fsqueue_message_fd_rw() to
obtain a read{-only,/write} descriptor to the message file.

make sure smtpd uses the new API everywhere it needs a fd, and kill the
many functions that were used until now.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.38 2011/04/14 20:11:08 gilles Exp $	*/
a72 1
			log_debug("FAILED WITH ENOSPC");
a88 1
			log_debug("FAILED WITH ENOSPC");
d110 1
a110 4
	if (rename(rootdir, purgedir) == -1) {
		log_debug("ID: %s", msgid);
		log_debug("PATH: %s", rootdir);
		log_debug("PURGE: %s", purgedir);
a111 1
	}
@


1.38
log
@fsqueue queue backend will implement a filesystem queue:
- fsqueue->setup() performs the queue initialization;
- fsqueue->message() controls messages;
- fsqueue->envelope() controls envelopes;

This commit brings the following to fsbackend:
fsqueue_setup(), fsqueue_message_delete(), fsqueue_envelope_load(),
fsqueue_envelope_update(), fsqueue_envelope_delete().

It also makes smtpd use the queue_backend API for these operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.37 2011/04/13 20:53:18 gilles Exp $	*/
a229 12
queue_open_layout_messagefile(char *queuepath, struct message *messagep)
{
	char pathname[MAXPATHLEN];
	
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%s/message", queuepath,
		messagep->message_id))
		fatal("queue_open_incoming_message_file: snprintf");

	return open(pathname, O_CREAT|O_EXCL|O_RDWR, 0600);
}

int
a259 6
enqueue_open_messagefile(struct message *message)
{
	return queue_open_layout_messagefile(PATH_ENQUEUE, message);
}

int
a360 25
}

int
queue_open_incoming_message_file(struct message *message)
{
	return queue_open_layout_messagefile(PATH_INCOMING, message);
}

int
queue_open_message_file(char *msgid)
{
	int fd;
	char pathname[MAXPATHLEN];
	u_int16_t hval;

	hval = queue_hash(msgid);

	if (! bsnprintf(pathname, sizeof(pathname), "%s/%d/%s/message",
		PATH_QUEUE, hval, msgid))
		fatal("queue_open_message_file: snprintf");

	if ((fd = open(pathname, O_RDONLY)) == -1)
		fatal("queue_open_message_file: open");

	return fd;
@


1.37
log
@following an idea from jacekm@@, smtpd now uses a ram-queue instead of doing
a continuous walk on the disk-queue. the implementation differs from what
jacekm@@ commited (and I backed out) a while ago in that it uses a queue and
a host tree required for upcoming features.

code will be improved in tree, it requires changes to be done in queue and
bounce API, I just wanted to commit a working version first ...

tested by todd@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.36 2011/03/21 09:21:57 gilles Exp $	*/
d407 1
a407 44
queue_delete_message(char *msgid)
{
	char rootdir[MAXPATHLEN];
	char evpdir[MAXPATHLEN];
	char msgpath[MAXPATHLEN];
	u_int16_t hval;

	hval = queue_hash(msgid);
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%d/%s", PATH_QUEUE,
		hval, msgid))
		fatal("queue_delete_message: snprintf");

	if (! bsnprintf(evpdir, sizeof(evpdir), "%s%s", rootdir,
		PATH_ENVELOPES))
		fatal("queue_delete_message: snprintf");
	
	if (! bsnprintf(msgpath, sizeof(msgpath), "%s/message", rootdir))
		fatal("queue_delete_message: snprintf");

	if (unlink(msgpath) == -1)
		fatal("queue_delete_message: unlink");

	if (rmdir(evpdir) == -1) {
		/* It is ok to fail rmdir with ENOENT here
		 * because upon successful delivery of the
		 * last envelope, we remove the directory.
		 */
		if (errno != ENOENT)
			fatal("queue_delete_message: rmdir");
	}

	if (rmdir(rootdir) == -1)
		fatal("#2 queue_delete_message: rmdir");

	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%d", PATH_QUEUE, hval))
		fatal("queue_delete_message: snprintf");

	rmdir(rootdir);

	return;
}

void
queue_message_update(struct message *messagep)
d421 1
a421 1
		queue_remove_envelope(messagep);
d427 1
a427 1
		queue_update_envelope(messagep);
d432 1
a432 107
	queue_remove_envelope(messagep);
}

int
queue_remove_envelope(struct message *messagep)
{
	char pathname[MAXPATHLEN];
	u_int16_t hval;

	hval = queue_hash(messagep->message_id);

	if (! bsnprintf(pathname, sizeof(pathname), "%s/%d/%s%s/%s",
		PATH_QUEUE, hval, messagep->message_id, PATH_ENVELOPES,
		messagep->message_uid))
		fatal("queue_remove_envelope: snprintf");

	if (unlink(pathname) == -1)
		fatal("queue_remove_envelope: unlink");

	if (! bsnprintf(pathname, sizeof(pathname), "%s/%d/%s%s", PATH_QUEUE,
		hval, messagep->message_id, PATH_ENVELOPES))
		fatal("queue_remove_envelope: snprintf");

	if (rmdir(pathname) != -1)
		queue_delete_message(messagep->message_id);

	return 1;
}

int
queue_update_envelope(struct message *messagep)
{
	char temp[MAXPATHLEN];
	char dest[MAXPATHLEN];
	FILE *fp;
	u_int64_t batch_id;

	batch_id = messagep->batch_id;
	messagep->batch_id = 0;

	if (! bsnprintf(temp, sizeof(temp), "%s/envelope.tmp", PATH_QUEUE))
		fatalx("queue_update_envelope");

	if (! bsnprintf(dest, sizeof(dest), "%s/%d/%s%s/%s", PATH_QUEUE,
		queue_hash(messagep->message_id), messagep->message_id,
		PATH_ENVELOPES, messagep->message_uid))
		fatal("queue_update_envelope: snprintf");

	fp = fopen(temp, "w");
	if (fp == NULL) {
		if (errno == ENOSPC || errno == ENFILE)
			goto tempfail;
		fatal("queue_update_envelope: open");
	}
	if (fwrite(messagep, sizeof(struct message), 1, fp) != 1) {
		if (errno == ENOSPC)
			goto tempfail;
		fatal("queue_update_envelope: fwrite");
	}
	if (! safe_fclose(fp))
		goto tempfail;

	if (rename(temp, dest) == -1) {
		if (errno == ENOSPC)
			goto tempfail;
		fatal("queue_update_envelope: rename");
	}

	messagep->batch_id = batch_id;
	return 1;

tempfail:
	if (unlink(temp) == -1)
		fatal("queue_update_envelope: unlink");
	if (fp)
		fclose(fp);

	messagep->batch_id = batch_id;
	return 0;
}

int
queue_load_envelope(struct message *messagep, char *evpid)
{
	char pathname[MAXPATHLEN];
	char msgid[MAX_ID_SIZE];
	FILE *fp;

	if (strlcpy(msgid, evpid, sizeof(msgid)) >= sizeof(msgid))
		fatalx("queue_load_envelope: truncation");
	*strrchr(msgid, '.') = '\0';

	if (! bsnprintf(pathname, sizeof(pathname), "%s/%d/%s%s/%s", PATH_QUEUE,
		queue_hash(msgid), msgid, PATH_ENVELOPES, evpid))
		fatalx("queue_load_envelope: snprintf");

	fp = fopen(pathname, "r");
	if (fp == NULL) {
		if (errno == ENOENT || errno == ENFILE)
			return 0;
		fatal("queue_load_envelope: fopen");
	}
	if (fread(messagep, sizeof(struct message), 1, fp) != 1)
		fatal("queue_load_envelope: fread");
	fclose(fp);

	return 1;
@


1.36
log
@fix a memory leak in client.c and properly close envelope in
queue_shared.c

diff from Jared Yanovich, sent to bugs@@ by Jonny Mosco
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.35 2010/11/28 14:35:58 gilles Exp $	*/
d328 1
a328 1
bounce_record_message(struct message *messagep)
a330 1
	struct message mbounce;
d337 3
a339 3
	mbounce = *messagep;
	mbounce.type = T_BOUNCE_MESSAGE;
	mbounce.status &= ~S_MESSAGE_PERMFAILURE;
d344 2
a345 2
	strlcpy(mbounce.message_id, msgid, sizeof(mbounce.message_id));
	if (! bounce_record_envelope(&mbounce))
d348 1
a348 1
	return bounce_commit_message(&mbounce);
d459 5
a463 2
		    messagep->sender.user[0] != '\0')
			bounce_record_message(messagep);
@


1.35
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.34 2010/11/28 13:56:43 gilles Exp $	*/
d127 2
d159 3
a161 1
	if (! safe_fclose(fp))
d163 1
d169 4
a172 1
	close(fd);
@


1.34
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.33 2010/11/15 14:57:40 jsing Exp $	*/
d32 1
a33 2
#include <fcntl.h>
#include <pwd.h>
a36 1
#include <time.h>
@


1.33
log
@Do not fatal if an attempt to open a message envelope results in ENOENT.
This prevents smtpd from exiting if 'smtpctl schedule' is run with a valid
but non-existent message ID. Whilst here make ENOSPC fatal since this
should not happen.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.31 2010/10/09 22:12:26 gilles Exp $	*/
d32 1
d42 1
@


1.32
log
@teach smtpd how to handle per-rule delays for message expiry, this allows
some rules to have a longer expiry delay than the default:

	accept for [...] relay expire 8d  # will stay 8 days in queue

I added the man page bits so I don't forget but I need to reword it a bit
@
text
@d563 1
a563 1
		if (errno == ENOSPC || errno == ENFILE)
@


1.31
log
@these need to be re-added too
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.27 2009/12/14 18:16:01 jacekm Exp $	*/
d795 1
a795 1
	printf("|%s|%s|%s@@%s|%s@@%s|%d|%u",
d801 1
@


1.30
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.29 2010/06/01 19:47:09 jacekm Exp $	*/
@


1.29
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.27 2009/12/14 18:16:01 jacekm Exp $	*/
@


1.28
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@@


1.27
log
@Clear S_MESSAGE_PERMFAILURE when creating the bounce message.  Makes the
bounce mails visible in mailq output.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.26 2009/11/08 21:40:05 gilles Exp $	*/
@


1.26
log
@- make aliases expansion use a rb tree instead of a tail queue, the code
  doesn't take advantage of the new structure yet, but this was a needed
  change for upcoming improvements.
- introduce aliasestree_{lookup,insert,remove} to the aliases api
- rename queue_generate_id() to generate_uid() and move it to utils.c as
  it is used all over the place and not only in queue

tree idea discussed with jacekm@@, if you update rebuild aliases db, make
clean and flush queue
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.25 2009/09/15 16:50:06 jacekm Exp $	*/
d332 1
@


1.25
log
@Extend SMTP client_* API to support SSL+AUTH, and use it in the mta
process to relay mails.  ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.24 2009/09/04 13:33:00 jacekm Exp $	*/
a570 17
}

u_int64_t
queue_generate_id(void)
{
	u_int64_t	id;
	struct timeval	tp;

	if (gettimeofday(&tp, NULL) == -1)
		fatal("queue_generate_id: time");

	id = (u_int32_t)tp.tv_sec;
	id <<= 32;
	id |= (u_int32_t)tp.tv_usec;
	usleep(1);

	return (id);
@


1.24
log
@Fix scheduling of bounce messages.

From gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.23 2009/09/04 11:44:23 jacekm Exp $	*/
d785 2
d811 1
a811 1
	printf("|%s|%s|%s@@%s|%s@@%s|%d|%u\n",
d818 5
@


1.23
log
@Fix a crash when messagep->batch_id is read from disk and used long
after the batch has ceased to exist.

From gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.22 2009/08/08 23:02:43 gilles Exp $	*/
d302 2
@


1.22
log
@- simplify a bit queue_message_update()
- make sure queue_message_update() creates bounces using bounce_record()
- when mta sends update to queue and it sees that batch is flagged with
  F_BATCH_PERMFAIL, only update the envelope error message if it doesn't
  have F_MESSAGE_PERMFAIL set, otherwise we may lose the real reason why
  we failed for that recipient. There's cleanup to do around that old
  code, i'm sure we can get it simpler.

this commit fixes a bug pea@@ spotted where a bounce message would not
display the reason of a failure when we generated it after failing to
deliver a relayed message.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.21 2009/08/06 16:46:57 gilles Exp $	*/
d497 4
d530 1
d539 1
@


1.21
log
@- change all occurences of T_DAEMON_BATCH,MESSAGE to T_BOUNCE_BATCH/MESSAGE
- make sure T_BOUNCE_MESSAGE is no longer OR-ed to T_MDA/MTA_MESSAGE
- define F_MESSAGE_BOUNCE flag and make sure bounce sessions set it
- teach smtpctl show queue how to recognize a bounce message
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.20 2009/08/06 13:40:45 gilles Exp $	*/
d448 4
a451 12
		if (messagep->type == T_BOUNCE_MESSAGE ||
		    (messagep->sender.user[0] == '\0' && messagep->sender.domain[0] == '\0'))
			queue_remove_envelope(messagep);
		else {
			messagep->id = queue_generate_id();
			messagep->type = T_BOUNCE_MESSAGE;
			messagep->status &= ~S_MESSAGE_PERMFAILURE;
			messagep->lasttry = 0;
			messagep->retry = 0;
			messagep->creation = time(NULL);
			queue_update_envelope(messagep);
		}
@


1.20
log
@This commit reworks the entire mailer daemon support to actually make it
work for real. As an added bonus, it simplifies it, makes it follow the
same code path as regular messages and kills quite some code from mta,
mda and store. There's still some work needed but the most painful part
is behind us now ;)

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.19 2009/07/28 22:03:55 gilles Exp $	*/
d323 1
a323 1
	if (messagep->type == T_DAEMON_MESSAGE) {
d329 1
a329 1
	mbounce.type = T_DAEMON_MESSAGE;
d448 1
a448 1
		if (messagep->type & T_DAEMON_MESSAGE ||
d453 1
a453 1
			messagep->type |= T_DAEMON_MESSAGE;
d775 2
d802 2
a803 5
	case T_MDA_MESSAGE|T_DAEMON_MESSAGE:
		printf("MDA-DAEMON");
		break;
	case T_MTA_MESSAGE|T_DAEMON_MESSAGE:
		printf("MTA-DAEMON");
@


1.19
log
@introduce daemon_record_message() and needed glue in queue_shared.c to
atomically create a mailer daemon out of a message. it is unreferenced
for now, this commit makes no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.18 2009/05/10 11:29:40 jacekm Exp $	*/
d270 1
a270 1
daemon_create_layout(char *msgid, struct message *message)
d275 1
a275 1
	if (! queue_create_layout_message(PATH_DAEMON, msgid))
d284 1
a284 1
		PATH_DAEMON, msgid))
d294 1
a294 1
daemon_delete_message(char *msgid)
d296 1
a296 1
	queue_delete_layout_message(PATH_DAEMON, msgid);
d300 1
a300 1
daemon_record_envelope(struct message *message)
d302 1
a302 1
	return queue_record_layout_envelope(PATH_DAEMON, message);
d306 1
a306 1
daemon_remove_envelope(struct message *message)
d308 1
a308 1
	return queue_remove_layout_envelope(PATH_DAEMON, message);
d312 1
a312 1
daemon_commit_message(struct message *message)
d314 1
a314 1
	return queue_commit_layout_message(PATH_DAEMON, message);
d318 1
a318 1
daemon_record_message(struct message *messagep)
d321 1
a321 1
	struct message mdaemon;
d328 2
a329 2
	mdaemon = *messagep;
	mdaemon.type |= T_DAEMON_MESSAGE;
d331 1
a331 1
	if (! daemon_create_layout(msgid, messagep))
d334 2
a335 2
	strlcpy(mdaemon.message_id, msgid, sizeof(mdaemon.message_id));
	if (! daemon_record_envelope(&mdaemon))
d338 1
a338 1
	return daemon_commit_message(&mdaemon);
@


1.18
log
@assert copyright; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.17 2009/04/19 12:42:39 jacekm Exp $	*/
d269 71
@


1.17
log
@error checking for readdir(2); ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.16 2009/04/12 12:33:43 gilles Exp $	*/
d6 1
@


1.16
log
@when an error occurs while delivering a message with an empty envelope as a
sender, do not try to generate a mailer daemon message for it.

fixes a crash experienced by sthen@@ that I could reproduce
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.15 2009/03/09 11:29:52 jacekm Exp $	*/
d563 1
d565 2
@


1.15
log
@add hunk that should have been included in rev. 1.12, fixes occasional
crash; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.14 2009/02/24 12:07:47 gilles Exp $	*/
d376 2
a377 1
		if (messagep->type & T_DAEMON_MESSAGE)
@


1.14
log
@teach smtpctl's parser how to deal with parameters that are not necessarily
a token so that it is possible to do: smtpctl schedule <message id/uid>

introduce F_MESSAGE_FORCESCHEDULE which lets the runner schedule a message
even if the retry delay has not been expired.

F_MESSAGE_ENQUEUED is a valid flag for a message and should not cause an\
errx() in smtpctl show queue
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.13 2009/02/23 00:51:32 chl Exp $	*/
d433 1
a433 1
	if (! bsnprintf(temp, sizeof(temp), "%s/envelope.tmp", PATH_INCOMING))
@


1.13
log
@add missing headers needed by time()

ok jacekm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.12 2009/02/22 23:29:54 jacekm Exp $	*/
d704 2
@


1.12
log
@Fix race possible between runner and queue when starting up.
runner_reset_flags would attempt to update envelope, but its
envelope.tmp could be renamed by queue_purge. The fix is to store
envelope.tmp in a place no other process writes to, and
/queue/envelope.tmp is perfect for this.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.11 2009/02/22 11:55:17 jacekm Exp $	*/
d36 1
@


1.11
log
@simplify qwalk() error handling; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.10 2009/02/22 11:44:29 form Exp $	*/
d627 2
@


1.10
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.9 2009/02/16 10:15:10 jacekm Exp $	*/
d50 1
d539 1
d542 3
d592 1
a592 8
		/*
		 * ENOENT is unacceptable in queue/runner. It's perfectly fine
		 * for others (eg. smtpctl).
		 */
		if (errno == ENOENT) {
			if (smtpd_process == PROC_QUEUE ||
			    smtpd_process == PROC_RUNNER)
				fatal("qwalk: opendir");
@


1.9
log
@Don't warn about F_MESSAGE_SCHEDULED flag being present in on-disk version of
the envelope; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.8 2009/02/15 13:44:06 jacekm Exp $	*/
d64 1
a64 1
	if (! bsnprintf(rootdir, MAXPATHLEN, "%s/%d.XXXXXXXXXXXXXXXX",
d81 2
a82 1
	if (! bsnprintf(evpdir, MAXPATHLEN, "%s%s", rootdir, PATH_ENVELOPES))
d103 1
a103 1
	if (! bsnprintf(rootdir, MAXPATHLEN, "%s/%s", queuepath, msgid))
d106 1
a106 1
	if (! bsnprintf(purgedir, MAXPATHLEN, "%s/%s", PATH_PURGE, msgid))
d125 1
a125 1
	if (! bsnprintf(evpname, MAXPATHLEN, "%s/%s%s/%s.%qu", queuepath,
d144 2
a145 2
	if (strlcpy(message->message_uid, strrchr(evpname, '/') + 1, MAX_ID_SIZE)
	    >= MAX_ID_SIZE)
d173 1
a173 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s/%s%s/%s", queuepath,
d189 1
a189 1
	if (! bsnprintf(rootdir, MAXPATHLEN, "%s/%s", queuepath,
d193 1
a193 1
	if (! bsnprintf(queuedir, MAXPATHLEN, "%s/%d", PATH_QUEUE,
d204 3
a206 2
	if (strlcat(queuedir, "/", MAXPATHLEN) >= MAXPATHLEN ||
	    strlcat(queuedir, messagep->message_id, MAXPATHLEN) >= MAXPATHLEN)
d223 1
a223 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s/%s/message", queuepath,
d312 2
a313 2
	if (! bsnprintf(pathname, MAXPATHLEN, "%s/%d/%s/message", PATH_QUEUE,
		hval, msgid))
d331 1
a331 1
	if (! bsnprintf(rootdir, MAXPATHLEN, "%s/%d/%s", PATH_QUEUE,
d335 2
a336 2
	if (! bsnprintf(evpdir, MAXPATHLEN, "%s%s",
		rootdir, PATH_ENVELOPES))
d339 1
a339 1
	if (! bsnprintf(msgpath, MAXPATHLEN, "%s/message", rootdir))
d357 1
a357 2
	if (! bsnprintf(rootdir, MAXPATHLEN, "%s/%d", PATH_QUEUE,
		hval))
d406 2
a407 2
	if (! bsnprintf(pathname, MAXPATHLEN, "%s/%d/%s%s/%s", PATH_QUEUE,
		hval, messagep->message_id, PATH_ENVELOPES,
d414 1
a414 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s/%d/%s%s", PATH_QUEUE,
d431 1
a431 1
	if (! bsnprintf(temp, MAXPATHLEN, "%s/envelope.tmp", PATH_INCOMING))
d434 1
a434 1
	if (! bsnprintf(dest, MAXPATHLEN, "%s/%d/%s%s/%s", PATH_QUEUE,
d477 1
a477 1
	if (strlcpy(msgid, evpid, MAX_ID_SIZE) >= MAX_ID_SIZE)
d481 1
a481 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s/%d/%s%s/%s", PATH_QUEUE,
d634 1
a634 1
		if (! bsnprintf(q->path, MAXPATHLEN, "%s/%d", PATH_QUEUE,
d639 2
a640 2
		if (! bsnprintf(q->path, MAXPATHLEN, "%s/%d/%s%s", PATH_QUEUE,
			q->bucket, fname, PATH_ENVELOPES))
@


1.8
log
@kill local vars that are used only once; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.7 2009/02/14 00:00:47 jacekm Exp $	*/
d697 1
a697 1
	getflag(&envelope->flags, F_MESSAGE_SCHEDULED, "SCHEDULED",
d700 2
@


1.7
log
@Display envelope status & flags in "show queue"; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.6 2009/01/30 16:37:52 gilles Exp $	*/
a219 1
	mode_t mode = O_CREAT|O_EXCL|O_RDWR;
d225 1
a225 1
	return open(pathname, mode, 0600);
a305 1
	mode_t mode = O_RDONLY;
d314 1
a314 1
	if ((fd = open(pathname, mode)) == -1)
@


1.6
log
@fix a very annoying events masking issue which would cause a fatal() to be
hit under certain conditions; while tracking the bug I ran into other bugs
which were kind of related and could cause us to hit a fatal() too.

fix by me, but with lots of testing and investigation with jacekm@@,
ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.5 2009/01/29 12:43:25 jacekm Exp $	*/
d56 1
d370 1
d688 25
d729 2
a730 2

	printf("|%s|%s@@%s|%s@@%s|%d|%u\n",
d732 1
d737 10
@


1.5
log
@Common queue walking code for smtpd and smtpctl. Kills majority of showqueue.c,
the remaining code was moved to queue_shared.c; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.4 2009/01/28 17:29:11 jacekm Exp $	*/
d68 3
a70 1
		if (errno == ENOSPC)
d72 1
d85 1
d87 1
d108 3
@


1.4
log
@Make races between queue and runner impossible by implementing the policy:
1) queue never reads /queue.
2) queue writes to /queue only at message injection time.
3) runner does all reading, and all writing apart from 2).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.3 2009/01/28 12:58:17 gilles Exp $	*/
d28 1
d40 17
d515 186
@


1.3
log
@move some functions from queue.c to queue_shared.c as they are not only
used by queue process but also by runner, while at it change the prototype
of queue_open_message_file() so it takes the message id and not a batch,
runner process requires the decriptor before it even starts building a
batch.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.2 2009/01/28 11:27:57 gilles Exp $	*/
d85 1
a85 3
		if (errno == ENOENT)
			return;
		fatal("queue_delete_incoming_message: rename");
d150 1
a150 2
		if (errno != ENOENT)
			fatal("queue_remove_incoming_envelope: unlink");
d316 1
a316 2
		if (errno != ENOENT)
			fatal("queue_delete_message: unlink");
d318 5
a322 1
	if (rmdir(evpdir) == -1)
d325 1
d328 1
a328 2
		if (errno != ENOENT)
			fatal("queue_delete_message: rmdir");
d436 1
a436 2
		if (errno != ENOENT)
			fatal("queue_update_envelope: unlink");
a459 2
		if (errno == ENOENT)
			return 0;
@


1.2
log
@add a struct path to struct message so that we can keep track of the RCPT
provided recipient even after aliases/forwards expansion, we'll need this
for loop detection.

message id and uid being MAXPATHLEN long is a waste, define MAX_ID_SIZE
which is currently set to 64 (but can probably be further reduced) and
make sure that structures and the few strlcpy's use the right define.

original idea by jacekm@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_shared.c,v 1.1 2009/01/27 22:54:01 gilles Exp $	*/
d276 213
@


1.1
log
@follow the naming convention of other files, discussed with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sharedqueue.c,v 1.2 2009/01/27 22:48:29 gilles Exp $	*/
d55 2
a56 2
	if (strlcpy(message_id, rootdir + strlen(queuepath) + 1, MAXPATHLEN)
	    >= MAXPATHLEN)
d118 2
a119 2
	if (strlcpy(message->message_uid, strrchr(evpname, '/') + 1, MAXPATHLEN)
	    >= MAXPATHLEN)
@

