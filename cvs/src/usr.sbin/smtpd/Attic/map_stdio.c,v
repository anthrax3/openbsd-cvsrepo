head	1.12;
access;
symbols
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@ * @;


1.12
date	2012.10.14.11.59.34;	author gilles;	state dead;
branches;
next	1.11;

1.11
date	2012.09.27.20.34.15;	author chl;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.27.17.47.49;	author chl;	state Exp;
branches;
next	1.9;

1.9
date	2012.09.21.16.40.20;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.21.10.22.29;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.19.12.59.59;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.19.12.45.04;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.09.19.09.06.35;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.05.29.19.53.10;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2012.05.13.00.10.49;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2012.05.12.15.29.16;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2011.12.13.23.00.52;	author eric;	state Exp;
branches;
next	;


desc
@@


1.12
log
@missing from previous commit, byebye map_stdio.c

ok eric@@ and chl@@
@
text
@/*	$OpenBSD: map_stdio.c,v 1.11 2012/09/27 20:34:15 chl Exp $	*/

/*
 * Copyright (c) 2011 Gilles Chehade <gilles@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/param.h>
#include <sys/socket.h>

#include <ctype.h>
#include <err.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "smtpd.h"
#include "log.h"


/* stdio(3) backend */
static void *map_stdio_open(struct map *);
static void *map_stdio_lookup(void *, const char *, enum map_kind);
static int   map_stdio_compare(void *, const char *, enum map_kind,
    int (*)(const char *, const char *));
static void  map_stdio_close(void *);

static char *map_stdio_get_entry(void *, const char *, size_t *);
static void *map_stdio_credentials(const char *, char *, size_t);
static void *map_stdio_alias(const char *, char *, size_t);
static void *map_stdio_virtual(const char *, char *, size_t);
static void *map_stdio_netaddr(const char *, char *, size_t);


struct map_backend map_backend_stdio = {
	map_stdio_open,
	map_stdio_close,
	map_stdio_lookup,
	map_stdio_compare
};


static void *
map_stdio_open(struct map *map)
{
	return fopen(map->m_config, "r");
}

static void
map_stdio_close(void *hdl)
{
	FILE *fp = hdl;

	fclose(fp);
}

static void *
map_stdio_lookup(void *hdl, const char *key, enum map_kind kind)
{
	char *line;
	size_t len;
	void *ret;

	line = map_stdio_get_entry(hdl, key, &len);
	if (line == NULL)
		return NULL;

	ret = NULL;
	switch (kind) {
	case K_ALIAS:
		ret = map_stdio_alias(key, line, len);
		break;

	case K_CREDENTIALS:
		ret = map_stdio_credentials(key, line, len);
		break;

	case K_VIRTUAL:
		ret = map_stdio_virtual(key, line, len);
		break;

	case K_NETADDR:
		ret = map_stdio_netaddr(key, line, len);
		break;

	default:
		break;
	}

	free(line);

	return ret;
}

static int
map_stdio_compare(void *hdl, const char *key, enum map_kind kind,
    int (*func)(const char *, const char *))
{
	char *buf, *lbuf;
	size_t flen;
	char *keyp;
	FILE *fp = hdl;
	int ret = 0;

	lbuf = NULL;
	while ((buf = fgetln(fp, &flen))) {
		if (buf[flen - 1] == '\n')
			buf[flen - 1] = '\0';
		else {
			lbuf = xmalloc(flen + 1, "map_stdio_compare");
			memcpy(lbuf, buf, flen);
			lbuf[flen] = '\0';
			buf = lbuf;
		}

		keyp = buf;
		while (isspace((int)*keyp))
			++keyp;
		if (*keyp == '\0' || *keyp == '#')
			continue;

		if (! func(key, keyp))
			continue;

		ret = 1;
		break;
	}
	free(lbuf);

	return ret;
}

static char *
map_stdio_get_entry(void *hdl, const char *key, size_t *len)
{
	char *buf, *lbuf;
	size_t flen;
	char *keyp;
	char *valp;
	FILE *fp = hdl;
	char *result = NULL;

	lbuf = NULL;
	while ((buf = fgetln(fp, &flen))) {
		if (buf[flen - 1] == '\n')
			buf[flen - 1] = '\0';
		else {
			lbuf = xmalloc(flen + 1, "map_stdio_get_entry");
			memcpy(lbuf, buf, flen);
			lbuf[flen] = '\0';
			buf = lbuf;
		}

		keyp = buf;
		while (isspace((int)*keyp))
			++keyp;
		if (*keyp == '\0' || *keyp == '#')
			continue;

		valp = keyp;
		strsep(&valp, " \t:");
		if (valp == NULL || valp == keyp)
			continue;

		if (strcmp(keyp, key) != 0)
			continue;

		result = xstrdup(valp, "map_stdio_get_entry");
		*len = strlen(result);

		break;
	}
	free(lbuf);

	return result;
}


static void *
map_stdio_credentials(const char *key, char *line, size_t len)
{
	struct map_credentials *map_credentials = NULL;
	char *p;

	/* credentials are stored as user:password */
	if (len < 3)
		return NULL;

	/* too big to fit in a smtp session line */
	if (len >= MAX_LINE_SIZE)
		return NULL;

	p = strchr(line, ':');
	if (p == NULL)
		return NULL;

	if (p == line || p == line + len - 1)
		return NULL;
	*p++ = '\0';

	map_credentials = xcalloc(1, sizeof *map_credentials,
	    "map_stdio_credentials");

	if (strlcpy(map_credentials->username, line,
		sizeof(map_credentials->username)) >=
	    sizeof(map_credentials->username))
		goto err;

	if (strlcpy(map_credentials->password, p,
		sizeof(map_credentials->password)) >=
	    sizeof(map_credentials->password))
		goto err;

	return map_credentials;

err:
	free(map_credentials);
	return NULL;
}

static void *
map_stdio_alias(const char *key, char *line, size_t len)
{
	char	       	*subrcpt;
	char	       	*endp;
	struct map_alias	*map_alias = NULL;
	struct expandnode	 xn;

	map_alias = xcalloc(1, sizeof *map_alias, "map_stdio_alias");

	while ((subrcpt = strsep(&line, ",")) != NULL) {
		/* subrcpt: strip initial whitespace. */
		while (isspace((int)*subrcpt))
			++subrcpt;
		if (*subrcpt == '\0')
			goto error;

		/* subrcpt: strip trailing whitespace. */
		endp = subrcpt + strlen(subrcpt) - 1;
		while (subrcpt < endp && isspace((int)*endp))
			*endp-- = '\0';

		if (! alias_parse(&xn, subrcpt))
			goto error;

		expand_insert(&map_alias->expand, &xn);
		map_alias->nbnodes++;
	}

	return map_alias;

error:
	expand_free(&map_alias->expand);
	free(map_alias);
	return NULL;
}

static void *
map_stdio_virtual(const char *key, char *line, size_t len)
{
	char	       	*subrcpt;
	char	       	*endp;
	struct map_virtual	*map_virtual = NULL;
	struct expandnode	 xn;

	map_virtual = xcalloc(1, sizeof *map_virtual, "map_stdio_virtual");

	/* domain key, discard value */
	if (strchr(key, '@@') == NULL)
		return map_virtual;

	while ((subrcpt = strsep(&line, ",")) != NULL) {
		/* subrcpt: strip initial whitespace. */
		while (isspace((int)*subrcpt))
			++subrcpt;
		if (*subrcpt == '\0')
			goto error;

		/* subrcpt: strip trailing whitespace. */
		endp = subrcpt + strlen(subrcpt) - 1;
		while (subrcpt < endp && isspace((int)*endp))
			*endp-- = '\0';

		if (! alias_parse(&xn, subrcpt))
			goto error;

		expand_insert(&map_virtual->expand, &xn);
		map_virtual->nbnodes++;
	}

	return map_virtual;

error:
	expand_free(&map_virtual->expand);
	free(map_virtual);
	return NULL;
}

static void *
map_stdio_netaddr(const char *key, char *line, size_t len)
{
	struct map_netaddr	*map_netaddr = NULL;

	map_netaddr = xcalloc(1, sizeof *map_netaddr, "map_stdio_netaddr");

	if (! text_to_netaddr(&map_netaddr->netaddr, line))
	    goto error;

	return map_netaddr;

error:
	free(map_netaddr);
	return NULL;
}
@


1.11
log
@use xstrdup() helper

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: map_stdio.c,v 1.10 2012/09/27 17:47:49 chl Exp $	*/
@


1.10
log
@use xmalloc()/xcalloc() helpers

while there unify usage of log_trace() in ramstat_set()

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: map_stdio.c,v 1.9 2012/09/21 16:40:20 eric Exp $	*/
d185 1
a185 3
		result = strdup(valp);
		if (result == NULL)
			err(1, NULL);
@


1.9
log
@wrap expandtree into a "struct expand".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: map_stdio.c,v 1.8 2012/09/21 10:22:29 eric Exp $	*/
d127 1
a127 2
			if ((lbuf = malloc(flen + 1)) == NULL)
				err(1, NULL);
d165 1
a165 2
			if ((lbuf = malloc(flen + 1)) == NULL)
				err(1, NULL);
d220 2
a221 3
	map_credentials = calloc(1, sizeof(struct map_credentials));
	if (map_credentials == NULL)
		fatalx("calloc");
d248 1
a248 3
	map_alias = calloc(1, sizeof(struct map_alias));
	if (map_alias == NULL)
		fatalx("calloc");
d285 1
a285 3
	map_virtual = calloc(1, sizeof(struct map_virtual));
	if (map_virtual == NULL)
		fatalx("calloc");
d323 1
a323 3
	map_netaddr = calloc(1, sizeof(struct map_netaddr));
	if (map_netaddr == NULL)
		fatalx("calloc");
@


1.8
log
@Move ruleset_match() prototype to smtpd.h and make the envelope const.
Adapt a lot of functions in chain to use const args where required.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: map_stdio.c,v 1.7 2012/09/19 12:59:59 eric Exp $	*/
d270 1
a270 1
		expand_insert(&map_alias->expandtree, &xn);
d277 1
a277 2
	/* free elements in map_alias->expandtree */
	expand_free(&map_alias->expandtree);
d313 1
a313 1
		expand_insert(&map_virtual->expandtree, &xn);
d320 1
a320 2
	/* free elements in map_virtual->expandtree */
	expand_free(&map_virtual->expandtree);
@


1.7
log
@expandnodes must be bzero()'d before parsing to be sure there is no bogus
data left on return, since the RB compare functions uses memcmp().  While
there, remove all calls to bzero() before alias_parse().

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: map_stdio.c,v 1.6 2012/09/19 12:45:04 eric Exp $	*/
d40 3
a42 3
static void *map_stdio_lookup(void *, char *, enum map_kind);
static int   map_stdio_compare(void *, char *, enum map_kind,
    int (*)(char *, char *));
d45 5
a49 5
static char *map_stdio_get_entry(void *, char *, size_t *);
static void *map_stdio_credentials(char *, char *, size_t);
static void *map_stdio_alias(char *, char *, size_t);
static void *map_stdio_virtual(char *, char *, size_t);
static void *map_stdio_netaddr(char *, char *, size_t);
d75 1
a75 1
map_stdio_lookup(void *hdl, char *key, enum map_kind kind)
d113 2
a114 2
map_stdio_compare(void *hdl, char *key, enum map_kind kind,
    int (*func)(char *, char *))
d152 1
a152 1
map_stdio_get_entry(void *hdl, char *key, size_t *len)
d201 1
a201 1
map_stdio_credentials(char *key, char *line, size_t len)
d244 1
a244 1
map_stdio_alias(char *key, char *line, size_t len)
d284 1
a284 1
map_stdio_virtual(char *key, char *line, size_t len)
d328 1
a328 1
map_stdio_netaddr(char *key, char *line, size_t len)
@


1.6
log
@rename variables for consistency

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: map_stdio.c,v 1.5 2012/09/19 09:06:35 eric Exp $	*/
a266 1
		bzero(&xn, sizeof (struct expandnode));
a310 1
		bzero(&xn, sizeof (struct expandnode));
@


1.5
log
@start cleaning the expansion code:

- change expandtree_* prefix to expand_ for better readability and
  because the structure might change at some point
- rename <>_free_nodes() to <>_free()
- remove unused <>_remove_node()
- refcounting has no purpose at all; just remove it as well as the
  decrement/increment functions, and replace the latter with <>_insert
- expandnode flags is only used to know if it's been processed or not,
  don't make it a flag but a simple field with clear name.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: map_stdio.c,v 1.4 2012/05/29 19:53:10 gilles Exp $	*/
d249 1
a249 1
	struct expandnode	 expnode;
d267 2
a268 2
		bzero(&expnode, sizeof (struct expandnode));
		if (! alias_parse(&expnode, subrcpt))
d271 1
a271 1
		expand_insert(&map_alias->expandtree, &expnode);
d290 1
a290 1
	struct expandnode	 expnode;
d312 2
a313 2
		bzero(&expnode, sizeof (struct expandnode));
		if (! alias_parse(&expnode, subrcpt))
d316 1
a316 1
		expand_insert(&map_virtual->expandtree, &expnode);
@


1.4
log
@- introduce map_static.c as a backend to static maps in parse.y, this has
  the benefit that we no longer have two code paths whenever we deal with
  maps, we can always use the backend mechanism.

I have not plugged this in yet, I'll do it in a later commit, just get it
out of my sandbox
@
text
@d1 1
a1 1
/*	$OpenBSD: map_stdio.c,v 1.3 2012/05/13 00:10:49 gilles Exp $	*/
d271 1
a271 1
		expandtree_increment_node(&map_alias->expandtree, &expnode);
d279 1
a279 1
	expandtree_free_nodes(&map_alias->expandtree);
d316 1
a316 1
		expandtree_increment_node(&map_virtual->expandtree, &expnode);
d324 1
a324 1
	expandtree_free_nodes(&map_virtual->expandtree);
@


1.3
log
@- cleanup parse.y by removing lots of code that should not have been there,
  but in ruleset.c and util.c instead.

- introduce the new map_compare() map API call to allow iterating over keys
  and comparing them with provided key using provided function. this allows
  checking a partial key in a key set, very useful for comparing an address
  to a set of netmask.

- introduce new map kind K_NETADDR
- implement K_NETADDR for map_db and map_stdio
- teach ruleset checking how to use the map_compare() with K_NETADDR

we can now do the following:

   map "srcaddr" source plain "/etc/mail/srcaddr.txt"

   accept from map srcaddr for domain "openbsd.org" [...]
@
text
@d1 1
a1 1
/*	$OpenBSD: map_stdio.c,v 1.2 2012/05/12 15:29:16 gilles Exp $	*/
d39 1
a39 1
static void *map_stdio_open(char *);
d61 1
a61 1
map_stdio_open(char *src)
d63 1
a63 1
	return fopen(src, "r");
@


1.2
log
@- rename all occurences of K_SECRET to K_CREDENTIALS
- rename all occurences of struct map_secret to map_credentials
- do not fatal if the credentials map has disappeared, instead make the
  auth fail with a lookup failure. the mail will be temporary failed so
  it stays in queue until admin fixes smtpd.conf, removes mail, or lets
  it expires
@
text
@d1 1
a1 1
/*	$OpenBSD: map_stdio.c,v 1.1 2011/12/13 23:00:52 eric Exp $	*/
d41 2
d49 1
d55 2
a56 1
	map_stdio_lookup
d79 1
a79 1
	struct map_alias *ma;
d85 1
a85 1
	ma = NULL;
d88 1
a88 1
		ma = map_stdio_alias(key, line, len);
d92 1
a92 1
		ma = map_stdio_credentials(key, line, len);
d96 5
a100 1
		ma = map_stdio_virtual(key, line, len);
d109 40
a148 1
	return ma;
d326 19
@


1.1
log
@rename files for consistency.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: map_backend_stdio.c,v 1.2 2011/08/30 11:19:51 chl Exp $	*/
d44 1
a44 1
static void *map_stdio_secret(char *, char *, size_t);
d87 2
a88 2
	case K_SECRET:
		ma = map_stdio_secret(key, line, len);
d154 1
a154 1
map_stdio_secret(char *key, char *line, size_t len)
d156 1
a156 1
	struct map_secret *map_secret = NULL;
d175 2
a176 2
	map_secret = calloc(1, sizeof(struct map_secret));
	if (map_secret == NULL)
d179 3
a181 3
	if (strlcpy(map_secret->username, line,
		sizeof(map_secret->username)) >=
	    sizeof(map_secret->username))
d184 3
a186 3
	if (strlcpy(map_secret->password, p,
		sizeof(map_secret->password)) >=
	    sizeof(map_secret->password))
d189 1
a189 1
	return map_secret;
d192 1
a192 1
	free(map_secret);
@

