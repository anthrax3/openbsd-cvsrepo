head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.07.09.12.16.24;	author eric;	state dead;
branches;
next	1.5;

1.5
date	2012.06.14.20.59.42;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.16.10.57.41;	author blambert;	state Exp;
branches;
next	1.3;

1.3
date	2011.03.27.17.39.17;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2011.03.26.11.04.05;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2010.11.29.15.25.56;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.6
log
@move to the new resolver implementation, with temporary glue to use
the relevant files from asr directly.

ok gilles@@
@
text
@/*	$OpenBSD: sockaddr.c,v 1.5 2012/06/14 20:59:42 gilles Exp $	*/
/*
 * Copyright (c) 2010		Eric Faurot	<eric@@faurot.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "dnsutil.h"

int
sockaddr_from_rr(struct sockaddr *sa, struct rr *rr)
{
	struct sockaddr_in	*sin;
	struct sockaddr_in6	*sin6;

	if (rr->rr_class != C_IN)
		return (-1);

	switch (rr->rr_type) {
	case T_A:
		sin = (struct sockaddr_in*)sa;
		memset(sin, 0, sizeof *sin);
		sin->sin_len = sizeof *sin;
		sin->sin_family = PF_INET;
		sin->sin_addr = rr->rr.in_a.addr;
		sin->sin_port = 0;
		return (0);
	case T_AAAA:
		sin6 = (struct sockaddr_in6*)sa;
		memset(sin6, 0, sizeof *sin6);
		sin6->sin6_len = sizeof *sin6;
		sin6->sin6_family = PF_INET6;
		sin6->sin6_addr = rr->rr.in_aaaa.addr6;
		sin6->sin6_port = 0;
		return (0);

	default:
		break;
	}

	return (-1);
}

int
sockaddr_from_str(struct sockaddr *sa, int family, const char *str)
{
	struct in_addr		 ina;
	struct in6_addr		 in6a;
	struct sockaddr_in	*sin;
	struct sockaddr_in6	*sin6;

	switch (family) {
	case PF_UNSPEC:
		if (sockaddr_from_str(sa, PF_INET, str) == 0)
			return (0);
		return sockaddr_from_str(sa, PF_INET6, str);

	case PF_INET:
		if (inet_pton(PF_INET, str, &ina) != 1)
			return (-1);

		sin = (struct sockaddr_in *)sa;
		memset(sin, 0, sizeof *sin);
		sin->sin_len = sizeof(struct sockaddr_in);
		sin->sin_family = PF_INET;
		sin->sin_addr.s_addr = ina.s_addr;
		return (0);

	case PF_INET6:
		if (inet_pton(PF_INET6, str, &in6a) != 1)
			return (-1);

		sin6 = (struct sockaddr_in6 *)sa;
		memset(sin6, 0, sizeof *sin6);
		sin6->sin6_len = sizeof(struct sockaddr_in6);
		sin6->sin6_family = PF_INET6;
		sin6->sin6_addr = in6a;
		return (0);

	default:
		break;
	}

	return (-1);
}

ssize_t
sockaddr_as_fqdn(const struct sockaddr *sa, char *dst, size_t max)
{
	const struct in6_addr	*in6_addr;
	in_addr_t		 addr;

	switch (sa->sa_family) {
	case AF_INET:
		addr = ntohl(((const struct sockaddr_in *)sa)->sin_addr.s_addr);
		snprintf(dst, max,
		    "%d.%d.%d.%d.in-addr.arpa.",
		    addr & 0xff,
		    (addr >> 8) & 0xff,
		    (addr >> 16) & 0xff,
		    (addr >> 24) & 0xff);
		break;
	case AF_INET6:
		in6_addr = &((const struct sockaddr_in6 *)sa)->sin6_addr;
		snprintf(dst, max,
		    "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x."
		    "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x."
		    "ip6.arpa.",
		    in6_addr->s6_addr[15] & 0xf,
		    (in6_addr->s6_addr[15] >> 4) & 0xf,
		    in6_addr->s6_addr[14] & 0xf,
		    (in6_addr->s6_addr[14] >> 4) & 0xf,
		    in6_addr->s6_addr[13] & 0xf,
		    (in6_addr->s6_addr[13] >> 4) & 0xf,
		    in6_addr->s6_addr[12] & 0xf,
		    (in6_addr->s6_addr[12] >> 4) & 0xf,
		    in6_addr->s6_addr[11] & 0xf,
		    (in6_addr->s6_addr[11] >> 4) & 0xf,
		    in6_addr->s6_addr[10] & 0xf,
		    (in6_addr->s6_addr[10] >> 4) & 0xf,
		    in6_addr->s6_addr[9] & 0xf,
		    (in6_addr->s6_addr[9] >> 4) & 0xf,
		    in6_addr->s6_addr[8] & 0xf,
		    (in6_addr->s6_addr[8] >> 4) & 0xf,
		    in6_addr->s6_addr[7] & 0xf,
		    (in6_addr->s6_addr[7] >> 4) & 0xf,
		    in6_addr->s6_addr[6] & 0xf,
		    (in6_addr->s6_addr[6] >> 4) & 0xf,
		    in6_addr->s6_addr[5] & 0xf,
		    (in6_addr->s6_addr[5] >> 4) & 0xf,
		    in6_addr->s6_addr[4] & 0xf,
		    (in6_addr->s6_addr[4] >> 4) & 0xf,
		    in6_addr->s6_addr[3] & 0xf,
		    (in6_addr->s6_addr[3] >> 4) & 0xf,
		    in6_addr->s6_addr[2] & 0xf,
		    (in6_addr->s6_addr[2] >> 4) & 0xf,
		    in6_addr->s6_addr[1] & 0xf,
		    (in6_addr->s6_addr[1] >> 4) & 0xf,
		    in6_addr->s6_addr[0] & 0xf,
		    (in6_addr->s6_addr[0] >> 4) & 0xf);
		break;
	default:
		break;
	}

	return (-1);
}

void
sockaddr_set_port(struct sockaddr *sa, int portno)
{
	struct sockaddr_in	*sin;
	struct sockaddr_in6	*sin6;

	switch (sa->sa_family) {
	case PF_INET:
		sin = (struct sockaddr_in *)sa;
		sin->sin_port = htons(portno);
		break;
	case PF_INET6:
		sin6 = (struct sockaddr_in6 *)sa;
		sin6->sin6_port = htons(portno);
		break;
	}
}

int
sockaddr_connect(const struct sockaddr *sa, int socktype)
{
	int errno_save, flags, sock;

	if ((sock = socket(sa->sa_family, socktype, 0)) == -1)
		goto fail;

	if ((flags = fcntl(sock, F_GETFL, 0)) == -1)
		goto fail;

	flags |= O_NONBLOCK;

	if ((flags = fcntl(sock, F_SETFL, flags)) == -1)
		goto fail;

	if (connect(sock, sa, sa->sa_len) == -1) {
		if (errno == EINPROGRESS)
			return (sock);
		goto fail;
	}

	return (sock);

    fail:

	if (sock != -1) {
		errno_save = errno;
		close(sock);
		errno = errno_save;
	}

	return (-1);
}

int
sockaddr_listen(const struct sockaddr *sa, int socktype)
{
	int errno_save, sock;

	if ((sock = socket(sa->sa_family, socktype, 0)) == -1)
		return (-1);

	if (bind(sock, sa, sa->sa_len) == -1) {
		errno_save = errno;
		close(sock);
		errno = errno_save;
		return (-1);
	}

        return (sock);
}
@


1.5
log
@- make sockaddr_as_fqdn() endian-safe

bug spotted by Jan Stary
fix by eric@@, committing this on his behalf, ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sockaddr.c,v 1.4 2011/05/16 10:57:41 blambert Exp $	*/
@


1.4
log
@Print IPv6 addresses in hex, not decimal; from Tim van der Molen

committing on behalf of gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sockaddr.c,v 1.3 2011/03/27 17:39:17 eric Exp $	*/
d117 1
a117 1
		addr = ((const struct sockaddr_in *)sa)->sin_addr.s_addr;
d120 2
a121 1
		    (addr >> 24) & 0xff,
d123 1
a123 2
		    (addr >> 8) & 0xff,
		    addr & 0xff);
@


1.3
log
@add missing CVS markers and update copyright year.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d128 2
a129 2
		    "%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d."
		    "%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d."
@


1.2
log
@Merge a reverse lookup query implementation into asr.
Not used by the rest of smtpd for now.

ok gilles@@
@
text
@d1 1
@


1.1
log
@replace the fork-based-non-blocking-resolver-hack by shiny async resolver
written by eric@@. it is still experimental but still better than what we
had earlier so ... we'll improve in tree :)

diff by me with *lots* of help from eric@@, tested by todd and I (and a
few people out there)
@
text
@d25 1
d101 62
@

