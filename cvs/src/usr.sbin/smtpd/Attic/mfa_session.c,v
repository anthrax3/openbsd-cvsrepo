head	1.23;
access;
symbols
	OPENBSD_5_5:1.20.0.2
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2;
locks; strict;
comment	@ * @;


1.23
date	2014.05.20.08.09.04;	author eric;	state dead;
branches;
next	1.22;

1.22
date	2014.04.19.13.18.14;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.27.11.01.47;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.18;

1.18
date	2013.07.19.16.02.00;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.26.13.30.29;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2012.11.23.13.54.12;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.11.21.51.37;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.29.11.02.41;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2012.09.11.12.47.36;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.18.13.41.54;	author chl;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.28.22.13.27;	author chl;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2011.09.01.09.42.15;	author chl;	state Exp;
branches;
next	1.3;

1.3
date	2011.08.31.18.56.30;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2011.08.28.00.03.24;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2011.08.27.22.32.41;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.23
log
@remove dead files
@
text
@/*	$OpenBSD: mfa_session.c,v 1.22 2014/04/19 13:18:14 gilles Exp $	*/

/*
 * Copyright (c) 2011 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <inttypes.h>
#include <resolv.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

enum {
	QT_QUERY,
	QT_EVENT,
};

enum {
	QUERY_READY,
	QUERY_WAITING,
	QUERY_RUNNING,
	QUERY_DONE
};


struct mfa_filterproc {
	TAILQ_ENTRY(mfa_filterproc)	 entry;
	struct mproc			 mproc;
	int				 hooks;
	int				 flags;
	int				 ready;
};

struct mfa_filter {
	TAILQ_ENTRY(mfa_filter)		 entry;
	struct mfa_filterproc		*proc;
};
TAILQ_HEAD(mfa_filters, mfa_filter);

struct mfa_session {
	uint64_t				 id;
	int					 terminate;
	TAILQ_HEAD(mfa_queries, mfa_query)	 queries;
	struct mfa_filters			*filters;
	struct mfa_filter			*fcurr;
};

struct mfa_query {
	uint64_t		 qid;
	int			 type;
	int			 hook;
	struct mfa_session	*session;
	TAILQ_ENTRY(mfa_query)	 entry;

	int			 state;
	int			 hasrun;
	struct mfa_filter	*current;
	struct tree		 notify;  /* list of filters to notify */

	/* current data */
	union {
		struct {
			struct sockaddr_storage	 local;
			struct sockaddr_storage	 remote;
			char			 hostname[SMTPD_MAXHOSTNAMELEN];
		} connect;
		char			line[SMTPD_MAXLINESIZE];
		struct mailaddr		maddr;
		size_t			datalen;
	} u;

	/* current response */
	struct {
		int	 status;
		int	 code;
		char	*response;	
	} smtp;
};

static void mfa_filter_imsg(struct mproc *, struct imsg *);
static struct mfa_query *mfa_query(struct mfa_session *, int, int);
static void mfa_drain_query(struct mfa_query *);
static void mfa_run_query(struct mfa_filter *, struct mfa_query *);
static void mfa_set_fdout(struct mfa_session *, int);

static TAILQ_HEAD(, mfa_filterproc)	procs;
struct dict				chains;

static const char * mfa_query_to_text(struct mfa_query *);
static const char * mfa_filter_to_text(struct mfa_filter *);
static const char * mfa_filterproc_to_text(struct mfa_filterproc *);
static const char * type_to_str(int);
static const char * hook_to_str(int);
static const char * status_to_str(int);
static const char * filterimsg_to_str(int);

struct tree	sessions;
struct tree	queries;


static void
mfa_extend_chain(struct mfa_filters *chain, const char *name)
{
	struct mfa_filter	*n;
	struct mfa_filters	*fchain;
	struct filter		*fconf;
	int			 i;

	fconf = dict_xget(&env->sc_filters, name);
	if (fconf->chain) {
		log_debug("mfa:     extending with \"%s\"", name);
		for (i = 0; i < MAX_FILTER_PER_CHAIN; i++) {
			if (!fconf->filters[i][0])
				break;
			mfa_extend_chain(chain, fconf->filters[i]);
		}
	}
	else {
		log_debug("mfa:     adding filter \"%s\"", name);
		n = xcalloc(1, sizeof(*n), "mfa_extend_chain");
		fchain = dict_get(&chains, name);
		n->proc = TAILQ_FIRST(fchain)->proc;
		TAILQ_INSERT_TAIL(chain, n, entry);
	}
}

void
mfa_filter_prepare(void)
{
	static int		 prepare = 0;
	struct filter		*filter;
	void			*iter;
	struct mfa_filterproc	*proc;
	struct mfa_filters	*fchain;
	struct mfa_filter	*f;
	struct mproc		*p;
	int			 done, i;

	if (prepare)
		return;
	prepare = 1;

	TAILQ_INIT(&procs);
	dict_init(&chains);

	log_debug("mfa: building simple chains...");

	/* create all filter proc and associated chains */
	iter = NULL;
	while (dict_iter(&env->sc_filters, &iter, NULL, (void **)&filter)) {
		if (filter->chain)
			continue;

		log_debug("mfa: building simple chain \"%s\"", filter->name);

		proc = xcalloc(1, sizeof(*proc), "mfa_filter_init");
		p = &proc->mproc;
		p->handler = mfa_filter_imsg;
		p->proc = PROC_FILTER;
		p->name = xstrdup(filter->name, "mfa_filter_init");
		p->data = proc;
		if (mproc_fork(p, filter->path, filter->name) < 0)
			fatalx("mfa_filter_init");

		log_debug("mfa: registering proc \"%s\"", filter->name);

		f = xcalloc(1, sizeof(*f), "mfa_filter_init");
		f->proc = proc;

		TAILQ_INSERT_TAIL(&procs, proc, entry);
		fchain = xcalloc(1, sizeof(*fchain), "mfa_filter_prepare");
		TAILQ_INIT(fchain);
		TAILQ_INSERT_TAIL(fchain, f, entry);
		dict_xset(&chains, filter->name, fchain);
		filter->done = 1;
	}

	log_debug("mfa: building complex chains...");

	/* resolve all chains */
	done = 0;
	while (!done) {
		done = 1;
		iter = NULL;
		while (dict_iter(&env->sc_filters, &iter, NULL, (void **)&filter)) {
			if (filter->done)
				continue;
			done = 0;
			filter->done = 1;
			for (i = 0; i < MAX_FILTER_PER_CHAIN; i++) {
				if (!filter->filters[i][0])
					break;
				if (!dict_get(&chains, filter->filters[i])) {
					filter->done = 0;
					break;
				}
			}
			if (filter->done == 0)
				continue;
			fchain = xcalloc(1, sizeof(*fchain), "mfa_filter_prepare");
			TAILQ_INIT(fchain);
			log_debug("mfa: building chain \"%s\"...", filter->name);
			for (i = 0; i < MAX_FILTER_PER_CHAIN; i++) {
				if (!filter->filters[i][0])
					break;
				mfa_extend_chain(fchain, filter->filters[i]);
			}
			log_debug("mfa: done building chain \"%s\"", filter->name);
			dict_xset(&chains, filter->name, fchain);
		}
	}
	log_debug("mfa: done building complex chains");

	if (dict_get(&chains, "default") == NULL) {
		log_debug("mfa: done building default chain");
		fchain = xcalloc(1, sizeof(*fchain), "mfa_filter_prepare");
		TAILQ_INIT(fchain);
		dict_xset(&chains, "default", fchain);
	}
}

void
mfa_filter_init(void)
{
	static int		 init = 0;
	struct mfa_filterproc	*p;

	if (init)
		return;
	init = 1;

	tree_init(&sessions);
	tree_init(&queries);

	TAILQ_FOREACH(p, &procs, entry) {
		m_create(&p->mproc, IMSG_FILTER_REGISTER, 0, 0, -1);
		m_add_u32(&p->mproc, FILTER_API_VERSION);
		m_add_string(&p->mproc, p->mproc.name);
		m_close(&p->mproc);
		mproc_enable(&p->mproc);
	}

	if (TAILQ_FIRST(&procs) == NULL)
		mfa_ready();
}

void
mfa_filter_connect(uint64_t id, const struct sockaddr *local,
	const struct sockaddr *remote, const char *host)
{
	struct mfa_session	*s;
	struct mfa_query	*q;

	s = xcalloc(1, sizeof(*s), "mfa_query_connect");
	s->id = id;
	s->filters = dict_xget(&chains, "default");
	TAILQ_INIT(&s->queries);
	tree_xset(&sessions, s->id, s);

	q = mfa_query(s, QT_QUERY, HOOK_CONNECT);

	memmove(&q->u.connect.local, local, local->sa_len);
	memmove(&q->u.connect.remote, remote, remote->sa_len);
	if (strlcpy(q->u.connect.hostname, host,
		sizeof(q->u.connect.hostname)) >=
	    sizeof(q->u.connect.hostname))
		fatalx("hostname too large");

	q->smtp.status = MFA_OK;
	q->smtp.code = 0;
	q->smtp.response = NULL;

	mfa_drain_query(q);
}

void
mfa_filter_event(uint64_t id, int hook)
{
	struct mfa_session	*s;
	struct mfa_query	*q;

	/* On disconnect, the session is virtualy dead */
	if (hook == HOOK_DISCONNECT)
		s = tree_xpop(&sessions, id);
	else
		s = tree_xget(&sessions, id);
	q = mfa_query(s, QT_EVENT, hook);

	mfa_drain_query(q);
}

void
mfa_filter_mailaddr(uint64_t id, int hook, const struct mailaddr *maddr)
{
	struct mfa_session	*s;
	struct mfa_query	*q;

	s = tree_xget(&sessions, id);
	q = mfa_query(s, QT_QUERY, hook);

	if (strlcpy(q->u.maddr.user, maddr->user, sizeof(q->u.maddr.user))
	    >= sizeof(q.u.maddr.user))
		fatalx("username too large");
	if (strlcpy(q->u.maddr.domain, maddr->domain, sizeof(q->u.maddr.domain))
	    >= sizeof(q.u.maddr.domain))
		fatalx("hostname too large");

	mfa_drain_query(q);
}

void
mfa_filter_line(uint64_t id, int hook, const char *line)
{
	struct mfa_session	*s;
	struct mfa_query	*q;

	s = tree_xget(&sessions, id);
	q = mfa_query(s, QT_QUERY, hook);

	if (strlcpy(q->u.line, line, sizeof(q->u.line))
	    >= sizeof(q->u.line))
		fatalx("line too large");

	mfa_drain_query(q);
}

void
mfa_filter_eom(uint64_t id, int hook, size_t datalen)
{
	struct mfa_session	*s;
	struct mfa_query	*q;

	s = tree_xget(&sessions, id);
	q = mfa_query(s, QT_QUERY, hook);
	q->u.datalen = datalen;

	mfa_drain_query(q);
}

void
mfa_filter(uint64_t id, int hook)
{
	struct mfa_session	*s;
	struct mfa_query	*q;

	s = tree_xget(&sessions, id);
	q = mfa_query(s, QT_QUERY, hook);

	mfa_drain_query(q);
}

static void
mfa_set_fdout(struct mfa_session *s, int fdout)
{
	struct mproc	*p;

	while(s->fcurr) {
		if (s->fcurr->proc->hooks & HOOK_DATALINE) {
			log_trace(TRACE_MFA, "mfa: sending fd %d to %s", fdout, mfa_filter_to_text(s->fcurr));
			p = &s->fcurr->proc->mproc;
			m_create(p, IMSG_FILTER_PIPE_SETUP, 0, 0, fdout);
			m_add_id(p, s->id);
			m_close(p);
			return;
		}
		s->fcurr = TAILQ_PREV(s->fcurr, mfa_filters, entry);
	}

	log_trace(TRACE_MFA, "mfa: chain input is %d", fdout);

	m_create(p_pony, IMSG_SMTP_MESSAGE_OPEN, 0, 0, fdout); /* XXX bogus */
	m_add_id(p_pony, s->id);
	m_add_int(p_pony, 1);
	m_close(p_pony);
	return;
}

void
mfa_build_fd_chain(uint64_t id, int fdout)
{
	struct mfa_session	*s;

	s = tree_xget(&sessions, id);
	s->fcurr = TAILQ_LAST(s->filters, mfa_filters);
	mfa_set_fdout(s, fdout);
}

static struct mfa_query *
mfa_query(struct mfa_session *s, int type, int hook)
{
	struct mfa_query	*q;

	q = xcalloc(1, sizeof *q, "mfa_query");
	q->qid = generate_uid();
	q->session = s;
	q->type = type;
	q->hook = hook;
	tree_init(&q->notify);
	TAILQ_INSERT_TAIL(&s->queries, q, entry);

	q->state = QUERY_READY;
	q->current = TAILQ_FIRST(s->filters);
	q->hasrun = 0;

	log_trace(TRACE_MFA, "filter: new query %s %s", type_to_str(type),
	    hook_to_str(hook));

	return (q);
}

static void
mfa_drain_query(struct mfa_query *q)
{
	struct mfa_filterproc	*proc;
	struct mfa_query	*prev;

	log_trace(TRACE_MFA, "filter: draining query %s", mfa_query_to_text(q));

	/*
	 * The query must be passed through all filters that registered
	 * a hook, until one rejects it.  
	 */
	while (q->state != QUERY_DONE) {

		/* Walk over all filters */
		while (q->current) {

			/* Trigger the current filter if not done yet. */
			if (!q->hasrun) {
				mfa_run_query(q->current, q);
				q->hasrun = 1;
			}
			if (q->state == QUERY_RUNNING) {
				log_trace(TRACE_MFA,
				    "filter: waiting for running query %s",
				    mfa_query_to_text(q));
				return;
			}

			/*
			 * Do not move forward if the query ahead of us is
			 * waiting on this filter.
			 */
			prev = TAILQ_PREV(q, mfa_queries, entry);
			if (prev && prev->current == q->current) {
				q->state = QUERY_WAITING;
				log_trace(TRACE_MFA,
				    "filter: query blocked by previoius query %s",
				    mfa_query_to_text(prev));
				return;
			}

			q->current = TAILQ_NEXT(q->current, entry);
			q->hasrun = 0;
		}
		q->state = QUERY_DONE;
	}

	if (q->type == QT_QUERY) {

		log_trace(TRACE_MFA,
		    "filter: query %016"PRIx64" done: "
		    "status=%s code=%d response=\"%s\"",
		    q->qid,
		    status_to_str(q->smtp.status),
		    q->smtp.code,
		    q->smtp.response);

		/* Done, notify all listeners and return smtp response */
		while (tree_poproot(&q->notify, NULL, (void**)&proc)) {
			m_create(&proc->mproc, IMSG_FILTER_NOTIFY, 0, 0, -1);
			m_add_id(&proc->mproc, q->qid);
			m_add_int(&proc->mproc, q->smtp.status);
			m_close(&proc->mproc);
		}

		m_create(p_pony, IMSG_MFA_SMTP_RESPONSE, 0, 0, -1);
		m_add_id(p_pony, q->session->id);
		m_add_int(p_pony, q->smtp.status);
		m_add_u32(p_pony, q->smtp.code);
		if (q->smtp.response)
			m_add_string(p_pony, q->smtp.response);
		m_close(p_pony);

		free(q->smtp.response);
	}

	TAILQ_REMOVE(&q->session->queries, q, entry);
	/* If the query was a disconnect event, the session can be freed */
	if (q->hook == HOOK_DISCONNECT) {
		/* XXX assert prev == NULL */
		log_trace(TRACE_MFA, "filter: freeing session %016" PRIx64, q->session->id);
		free(q->session);
	}

	log_trace(TRACE_MFA, "filter: freeing query %016" PRIx64, q->qid);
	free(q);
}

static void
mfa_run_query(struct mfa_filter *f, struct mfa_query *q)
{
	if ((f->proc->hooks & q->hook) == 0) {
		log_trace(TRACE_MFA, "filter: skipping filter %s for query %s",
		    mfa_filter_to_text(f), mfa_query_to_text(q));
		return;
	}

	log_trace(TRACE_MFA, "filter: running filter %s for query %s",
	    mfa_filter_to_text(f), mfa_query_to_text(q));

	if (q->type == QT_QUERY) {
		m_create(&f->proc->mproc, IMSG_FILTER_QUERY, 0, 0, -1);
		m_add_id(&f->proc->mproc, q->session->id);
		m_add_id(&f->proc->mproc, q->qid);
		m_add_int(&f->proc->mproc, q->hook);

		switch (q->hook) {
		case HOOK_CONNECT:
			m_add_sockaddr(&f->proc->mproc,
			    (struct sockaddr *)&q->u.connect.local);
			m_add_sockaddr(&f->proc->mproc,
			    (struct sockaddr *)&q->u.connect.remote);
			m_add_string(&f->proc->mproc, q->u.connect.hostname);
			break;
		case HOOK_HELO:
			m_add_string(&f->proc->mproc, q->u.line);
			break;
		case HOOK_MAIL:
		case HOOK_RCPT:
			m_add_mailaddr(&f->proc->mproc, &q->u.maddr);
			break;
		case HOOK_EOM:
			m_add_u32(&f->proc->mproc, q->u.datalen);
			break;
		default:
			break;
		}
		m_close(&f->proc->mproc);

		tree_xset(&queries, q->qid, q);
		q->state = QUERY_RUNNING;
	}
	else {
		m_create(&f->proc->mproc, IMSG_FILTER_EVENT, 0, 0, -1);
		m_add_id(&f->proc->mproc, q->session->id);
		m_add_int(&f->proc->mproc, q->hook);
		m_close(&f->proc->mproc);
 	}
}

static void
mfa_filter_imsg(struct mproc *p, struct imsg *imsg)
{
	struct mfa_filterproc	*proc = p->data;
	struct mfa_session	*s;
	struct mfa_query	*q, *next;
	struct msg		 m;
	const char		*line;
	uint64_t		 qid;
	uint32_t		 datalen;
	int			 qhook, status, code, notify;

	if (imsg == NULL) {
		log_warnx("warn: filter \"%s\" closed unexpectedly", p->name);
		fatalx("exiting");
	}

	log_trace(TRACE_MFA, "filter: imsg %s from procfilter %s",
	    filterimsg_to_str(imsg->hdr.type),
	    mfa_filterproc_to_text(proc));

	switch (imsg->hdr.type) {

	case IMSG_FILTER_REGISTER:
		if (proc->ready) {
			log_warnx("warn: filter \"%s\" already registered",
			    proc->mproc.name);
			exit(1);
		}
		
		m_msg(&m, imsg);
		m_get_int(&m, &proc->hooks);
		m_get_int(&m, &proc->flags);
		m_end(&m);
		proc->ready = 1;

		log_debug("debug: filter \"%s\": hooks 0x%08x flags 0x%04x",
		    proc->mproc.name, proc->hooks, proc->flags);

		TAILQ_FOREACH(proc, &procs, entry)
			if (!proc->ready)
				return;
		mfa_ready();
		break;

	case IMSG_FILTER_RESPONSE:
		m_msg(&m, imsg);
		m_get_id(&m, &qid);
		m_get_int(&m, &qhook);
		if (qhook == HOOK_EOM)
			m_get_u32(&m, &datalen);
		m_get_int(&m, &status);
		m_get_int(&m, &code);
		m_get_int(&m, &notify);
		if (m_is_eom(&m))
			line = NULL;
		else
			m_get_string(&m, &line);
		m_end(&m);

		q = tree_xpop(&queries, qid);
		if (q->hook != qhook) {
			log_warnx("warn: mfa: hook mismatch %d != %d", q->hook, qhook);
			fatalx("exiting");
		}
		q->smtp.status = status;
		if (code)
			q->smtp.code = code;
		if (line) {
			free(q->smtp.response);
			q->smtp.response = xstrdup(line, "mfa_filter_imsg");
		}
		q->state = (status == FILTER_OK) ? QUERY_READY : QUERY_DONE;
		if (notify)
			tree_xset(&q->notify, (uintptr_t)(proc), proc);
		if (qhook == HOOK_EOM)
			q->u.datalen = datalen;

		next = TAILQ_NEXT(q, entry);
		mfa_drain_query(q);

		/*
		 * If there is another query after this one which is waiting,
		 * make it move forward.
		 */
		if (next && next->state == QUERY_WAITING)
			mfa_drain_query(next);
		break;

	case IMSG_FILTER_PIPE_SETUP:
		m_msg(&m, imsg);
		m_get_id(&m, &qid);
		m_end(&m);

		s = tree_xget(&sessions, qid);
		s->fcurr = TAILQ_PREV(s->fcurr, mfa_filters, entry);
		mfa_set_fdout(s, imsg->fd);
		break;

	default:
		log_warnx("warn: bad imsg from filter %s", p->name);
		exit(1);
	}
}


static const char *
mfa_query_to_text(struct mfa_query *q)
{
	static char buf[1024];
	char tmp[1024];
	int ret;

	tmp[0] = '\0';

	switch(q->hook) {

	case HOOK_CONNECT:
		(void)strlcat(tmp, "=", sizeof tmp);
		(void)strlcat(tmp, ss_to_text(&q->u.connect.local), sizeof tmp);
		(void)strlcat(tmp, " <-> ", sizeof tmp);
		(void)strlcat(tmp, ss_to_text(&q->u.connect.remote), sizeof tmp);
		(void)strlcat(tmp, "(", sizeof tmp);
		(void)strlcat(tmp, q->u.connect.hostname, sizeof tmp);
		if (strlcat(tmp, ")", sizeof tmp) >= sizeof tmp)
			fatalx("line too large");
		break;

	case HOOK_MAIL:
	case HOOK_RCPT:
		ret = snprintf(tmp, sizeof tmp, "=%s@@%s",
		    q->u.maddr.user, q->u.maddr.domain);
		if (ret == -1 || ret >= sizeof tmp)
			fatalx("line too large");
		break;

	case HOOK_HELO:
		ret = snprintf(tmp, sizeof tmp, "=%s", q->u.line);
		if (ret == -1 || ret >= sizeof tmp)
			fatalx("line too large");
		break;

	default:
		break;
	}

	ret = snprintf(buf, sizeof buf, "%016"PRIx64"[%s,%s%s]",
	    q->qid, type_to_str(q->type), hook_to_str(q->hook), tmp);
	if (ret == -1 || ret >= sizeof buf)
		fatalx("line too large");
	return (buf);
}

static const char *
mfa_filter_to_text(struct mfa_filter *f)
{
	static char buf[1024];
	int ret;

	ret = snprintf(buf, sizeof buf, "filter:%s", mfa_filterproc_to_text(f->proc));
	if (ret == -1 || ret >= sizeof buf)
		fatalx("line too large");

	return (buf);
}

static const char *
mfa_filterproc_to_text(struct mfa_filterproc *proc)
{
	static char buf[1024];
	int ret;

	ret = snprintf(buf, sizeof buf, "%s[hooks=0x%08x,flags=0x%04x]",
	    proc->mproc.name, proc->hooks, proc->flags);
	if (ret == -1 || ret >= sizeof buf)
		fatalx("line too large");

	return (buf);
}

#define CASE(x) case x : return #x

static const char *
filterimsg_to_str(int imsg)
{
	switch (imsg) {
	CASE(IMSG_FILTER_REGISTER);
	CASE(IMSG_FILTER_EVENT);
	CASE(IMSG_FILTER_QUERY);
	CASE(IMSG_FILTER_PIPE_SETUP);
	CASE(IMSG_FILTER_PIPE_ABORT);
	CASE(IMSG_FILTER_NOTIFY);
	CASE(IMSG_FILTER_RESPONSE);
	default:
		return "IMSG_FILTER_???";
	}
}

static const char *
hook_to_str(int hook)
{
	switch (hook) {
	CASE(HOOK_CONNECT);
	CASE(HOOK_HELO);
	CASE(HOOK_MAIL);
	CASE(HOOK_RCPT);
	CASE(HOOK_DATA);
	CASE(HOOK_EOM);
	CASE(HOOK_RESET);
	CASE(HOOK_DISCONNECT);
	CASE(HOOK_COMMIT);
	CASE(HOOK_ROLLBACK);
	CASE(HOOK_DATALINE);
	default:
		return "HOOK_???";
	}
}

static const char *
type_to_str(int type)
{
	switch (type) {
	CASE(QT_QUERY);
	CASE(QT_EVENT);
	default:
		return "QT_???";
	}
}

static const char *
status_to_str(int status)
{
	switch (status) {
	CASE(MFA_OK);
	CASE(MFA_FAIL);
	CASE(MFA_CLOSE);
	default:
		return "MFA_???";
	}
}
@


1.22
log
@(void) cast some strlcat() calls that cannot truncate
add a few fatalx() calls at places where it shouldn't fail, we'll assess
which one may be relaxed later as this code is not finished nor plugged
yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.21 2014/04/04 16:10:42 eric Exp $	*/
@


1.21
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d294 4
a297 1
	strlcpy(q->u.connect.hostname, host, sizeof(q->u.connect.hostname));
d331 6
a336 2
	strlcpy(q->u.maddr.user, maddr->user, sizeof(q->u.maddr.user));
	strlcpy(q->u.maddr.domain, maddr->domain, sizeof(q->u.maddr.domain));
d350 3
a352 1
	strlcpy(q->u.line, line, sizeof(q->u.line));
d693 1
d700 8
a707 7
		strlcat(tmp, "=", sizeof tmp);
		strlcat(tmp, ss_to_text(&q->u.connect.local), sizeof tmp);
		strlcat(tmp, " <-> ", sizeof tmp);
		strlcat(tmp, ss_to_text(&q->u.connect.remote), sizeof tmp);
		strlcat(tmp, "(", sizeof tmp);
		strlcat(tmp, q->u.connect.hostname, sizeof tmp);
		strlcat(tmp, ")", sizeof tmp);
d712 1
a712 1
		snprintf(tmp, sizeof tmp, "=%s@@%s",
d714 2
d719 3
a721 1
		snprintf(tmp, sizeof tmp, "=%s", q->u.line);
d728 1
a728 1
	snprintf(buf, sizeof buf, "%016"PRIx64"[%s,%s%s]",
d730 2
a731 1

d739 1
d741 3
a743 1
	snprintf(buf, sizeof buf, "filter:%s", mfa_filterproc_to_text(f->proc));
d752 1
d754 1
a754 1
	snprintf(buf, sizeof buf, "%s[hooks=0x%08x,flags=0x%04x]",
d756 2
@


1.20
log
@Make the filter infrastructure move forward.
This is a work-in-progress and it's not supposed to be useable for now.
@
text
@d392 4
a395 4
	m_create(p_smtp, IMSG_QUEUE_MESSAGE_FILE, 0, 0, fdout);
	m_add_id(p_smtp, s->id);
	m_add_int(p_smtp, 1);
	m_close(p_smtp);
d498 4
a501 4
		m_create(p_smtp, IMSG_MFA_SMTP_RESPONSE, 0, 0, -1);
		m_add_id(p_smtp, q->session->id);
		m_add_int(p_smtp, q->smtp.status);
		m_add_u32(p_smtp, q->smtp.code);
d503 2
a504 2
			m_add_string(p_smtp, q->smtp.response);
		m_close(p_smtp);
@


1.19
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.18 2013/07/19 16:02:00 eric Exp $	*/
d55 3
a57 2
struct mfa_filter {
	TAILQ_ENTRY(mfa_filter)		 entry;
d64 3
a66 2
struct mfa_filter_chain {
	TAILQ_HEAD(, mfa_filter)	filters;
d68 1
d71 5
a75 3
	uint64_t				id;
	int					terminate;
	TAILQ_HEAD(mfa_queries, mfa_query)	queries;
d99 1
d114 4
a117 2
static void mfa_run_data(struct mfa_filter *, uint64_t, const char *);
static struct mfa_filter_chain	chain;
d121 1
d130 27
d163 2
d167 1
d173 2
a174 1
	TAILQ_INIT(&chain.filters);
d176 3
d181 7
a187 2
		f = xcalloc(1, sizeof *f, "mfa_filter_init");
		p = &f->mproc;
d191 1
a191 1
		p->data = f;
d194 55
a248 1
		TAILQ_INSERT_TAIL(&chain.filters, f, entry);
d256 1
a256 2
	struct mfa_filter	*f;
	struct mproc		*p;
d265 6
a270 6
	TAILQ_FOREACH(f, &chain.filters, entry) {
		p = &f->mproc;
		m_create(p, IMSG_FILTER_REGISTER, 0, 0, -1);
		m_add_u32(p, FILTER_API_VERSION);
		m_close(p);
		mproc_enable(p);
d273 1
a273 1
	if (TAILQ_FIRST(&chain.filters) == NULL)
d286 1
d349 1
a349 1
mfa_filter(uint64_t id, int hook)
d356 1
d362 1
a362 1
mfa_filter_data(uint64_t id, const char *line)
d364 7
a370 1
	mfa_run_data(TAILQ_FIRST(&chain.filters), id, line);
d374 1
a374 1
mfa_run_data(struct mfa_filter *f, uint64_t id, const char *line)
d378 6
a383 10
	log_trace(TRACE_MFA,
	    "filter: running data for %016"PRIx64" on filter %p: %s", id, f, line);

	/* Send the dataline to the filters that want to see it. */
	while (f) {
		if (f->hooks & HOOK_DATALINE) {
			p = &f->mproc;
			m_create(p, IMSG_FILTER_DATA, 0, 0, -1);
			m_add_id(p, id);
			m_add_string(p, line);
d385 1
a385 12

			/*
			 * If this filter wants to alter data, we stop
			 * iterating here, and the filter becomes responsible
			 * for sending datalines back.
			 */
			if (f->flags & FILTER_ALTERDATA) {
				log_trace(TRACE_MFA,
	 			   "filter: expect datalines from filter %s",
				   mfa_filter_to_text(f));
				return;
			}
d387 1
a387 1
		f = TAILQ_NEXT(f, entry);
d390 1
a390 3
	/* When all filters are done, send the line back to the smtp process. */
	log_trace(TRACE_MFA,
	    "filter: sending final data to smtp for %016"PRIx64" on filter %p: %s", id, f, line);
d392 3
a394 3
	m_create(p_smtp, IMSG_MFA_SMTP_DATA, 0, 0, -1);
	m_add_id(p_smtp, id);
	m_add_string(p_smtp, line);
d396 11
d423 1
a423 1
	q->current = TAILQ_FIRST(&chain.filters);
d435 1
a435 1
	struct mfa_filter	*f;
d483 1
a483 1
		    "filter: query 0x%016"PRIx64" done: "
d491 5
a495 5
		while (tree_poproot(&q->notify, NULL, (void**)&f)) {
			m_create(&f->mproc, IMSG_FILTER_NOTIFY, 0, 0, -1);
			m_add_id(&f->mproc, q->qid);
			m_add_int(&f->mproc, q->smtp.status);
			m_close(&f->mproc);
d511 1
a511 1
	if (q->type == HOOK_DISCONNECT) {
d513 1
d524 1
a524 1
	if ((f->hooks & q->hook) == 0) {
d534 4
a537 4
		m_create(&f->mproc, IMSG_FILTER_QUERY, 0, 0, -1);
		m_add_id(&f->mproc, q->session->id);
		m_add_id(&f->mproc, q->qid);
		m_add_int(&f->mproc, q->hook);
d541 1
a541 1
			m_add_sockaddr(&f->mproc,
d543 1
a543 1
			m_add_sockaddr(&f->mproc,
d545 1
a545 1
			m_add_string(&f->mproc, q->u.connect.hostname);
d548 1
a548 1
			m_add_string(&f->mproc, q->u.line);
d552 4
a555 1
			m_add_mailaddr(&f->mproc, &q->u.maddr);
d560 1
a560 2

		m_close(&f->mproc);
d566 4
a569 4
		m_create(&f->mproc, IMSG_FILTER_EVENT, 0, 0, -1);
		m_add_id(&f->mproc, q->session->id);
		m_add_int(&f->mproc, q->hook);
		m_close(&f->mproc);
d576 2
a577 1
	struct mfa_filter	*f;
d581 3
a583 4
	uint64_t		 id, qid;
	int			 status, code, notify;

	f = p->data;
d586 1
a586 2
		log_warnx("warn: filter \"%s\" closed unexpectedly",
		    p->name);
d590 1
a590 1
	log_trace(TRACE_MFA, "filter: imsg %s from filter %s",
d592 1
a592 1
	    mfa_filter_to_text(f));
d597 1
a597 1
		if (f->ready) {
d599 1
a599 1
			    f->mproc.name);
d604 2
a605 2
		m_get_int(&m, &f->hooks);
		m_get_int(&m, &f->flags);
d607 1
a607 1
		f->ready = 1;
d610 1
a610 1
		    f->mproc.name, f->hooks, f->flags);
d612 2
a613 2
		TAILQ_FOREACH(f, &chain.filters, entry)
			if (!f->ready)
a617 8
	case IMSG_FILTER_DATA:
		m_msg(&m, imsg);
		m_get_id(&m, &id);
		m_get_string(&m, &line);
		m_end(&m);
		mfa_run_data(TAILQ_NEXT(f, entry), id, line);
		break;

d621 3
a630 1
		
d634 4
d647 3
a649 1
			tree_xset(&q->notify, (uintptr_t)(f), f);
d662 10
d673 1
a673 1
		log_warnx("bad imsg from filter %s", p->name);
d724 1
a724 2
	snprintf(buf, sizeof buf, "%s[hooks=0x%04x,flags=0x%x]",
	    f->mproc.name, f->hooks, f->flags);
d729 10
d749 2
a751 1
	CASE(IMSG_FILTER_DATA);
@


1.18
log
@Move the filter infrastructure forward.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d381 1
a381 1
		    "status=%s code=%i response=\"%s\"",
@


1.17
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.15 2013/03/26 13:30:29 millert Exp $	*/
d122 1
a122 1
mfa_filter_init(void)
d124 1
a124 1
	static int		 init = 0;
d130 1
a130 1
	if (init)
d132 1
a132 4
	init = 1;

	tree_init(&sessions);
	tree_init(&queries);
d146 20
a169 1
		TAILQ_INSERT_TAIL(&chain.filters, f, entry);
a267 1
	size_t		 len;
d270 1
a270 3
	    "mfa: running data for %016"PRIx64" on filter %p: %s", id, f, line);

	len = 16 + strlen(line);
d288 1
a288 1
	 			   "mfa: expect datalines from filter %s",
d298 1
a298 1
	    "mfa: sending final data to smtp for %016"PRIx64" on filter %p: %s", id, f, line);
d323 1
a323 1
	log_trace(TRACE_MFA, "mfa: new query %s %s", type_to_str(type),
a333 1
	size_t			 len;
d335 1
a335 1
	log_trace(TRACE_MFA, "mfa: draining query %s", mfa_query_to_text(q));
d353 1
a353 1
				    "mfa: waiting for running query %s",
d366 1
a366 1
				    "mfa: query blocked by previoius query %s",
d380 1
a380 1
		    "mfa: query 0x%016"PRIx64" done: "
a394 3
		len = 48;
		if (q->smtp.response)
			len += strlen(q->smtp.response);
d413 1
a413 1
	log_trace(TRACE_MFA, "mfa: freeing query %016" PRIx64, q->qid);
d421 1
a421 1
		log_trace(TRACE_MFA, "mfa: skipping filter %s for query %s",
d426 1
a426 1
	log_trace(TRACE_MFA, "mfa: running filter %s for query %s",
d485 1
a485 1
	log_trace(TRACE_MFA, "mfa: imsg %s from filter %s",
@


1.16
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@a22 1
#include <sys/param.h>
d90 1
a90 1
			char			 hostname[MAXHOSTNAMELEN];
d144 1
a144 1
		p->proc = -1;
d149 1
a149 1
		m_create(p, IMSG_FILTER_REGISTER, 0, 0, -1, 5);
d263 1
a263 1
			m_create(p, IMSG_FILTER_DATA, 0, 0, -1, len);
d287 1
a287 1
	m_create(p_smtp, IMSG_MFA_SMTP_DATA, 0, 0, -1, len);
d377 1
a377 1
			m_create(&f->mproc, IMSG_FILTER_NOTIFY, 0, 0, -1, 16);
d386 1
a386 1
		m_create(p_smtp, IMSG_MFA_SMTP_RESPONSE, 0, 0, -1, len);
d421 1
a421 1
		m_create(&f->mproc, IMSG_FILTER_QUERY, 0, 0, -1, 1024);
d451 1
a451 1
		m_create(&f->mproc, IMSG_FILTER_EVENT, 0, 0, -1, 16);
d469 7
@


1.15
log
@Include inttypes.h to get PRIx64; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.14 2013/01/31 18:34:43 eric Exp $	*/
d93 1
a93 1
		char			line[MAX_LINE_SIZE];
@


1.14
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.13 2013/01/26 09:37:23 gilles Exp $	*/
d33 1
@


1.13
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.11 2012/10/11 21:51:37 gilles Exp $	*/
d397 1
a404 2

	TAILQ_REMOVE(&q->session->queries, q, entry);
@


1.12
log
@knf
@
text
@d4 2
a5 1
 * Copyright (c) 2011 Gilles Chehade <gilles@@openbsd.org>
d43 74
a116 6
static int mfa_session_proceed(struct mfa_session *);
static void mfa_session_pickup(struct mfa_session *);
static void mfa_session_fail(struct mfa_session *);
static void mfa_session_destroy(struct mfa_session *);
static void mfa_session_done(struct mfa_session *);
static void mfa_session_imsg(int, short, void *);
d118 2
a119 1
struct tree sessions;
d122 1
a122 1
mfa_session(struct submit_status *ss, enum session_state state)
d124 5
a128 1
	struct mfa_session *ms;
d130 108
a237 6
	ms = xcalloc(1, sizeof(*ms), "mfa_session");
	ms->id = generate_uid();
	ms->ss = *ss;
	ms->ss.code = 250;
	ms->state = state;
	ms->filter = TAILQ_FIRST(env->sc_filters);
d239 2
a240 1
	tree_xset(&sessions, ms->id, ms);
d242 4
a245 4
	if (ms->filter == NULL)
		mfa_session_done(ms);
	else if (!mfa_session_proceed(ms))
		mfa_session_fail(ms);
d248 2
a249 2
static int
mfa_session_proceed(struct mfa_session *ms)
d251 2
a252 1
	struct filter_msg	fm;
d254 2
a255 3
	fm.id = ms->id;
	fm.cl_id = ms->ss.id;
	fm.version = FILTER_API_VERSION;
d257 1
a257 1
	switch (ms->state) {
d259 53
a311 8
	case S_CONNECTED:
		fm.type = FILTER_CONNECT;
		if (strlcpy(fm.u.connect.hostname, ms->ss.envelope.hostname,
			    sizeof(fm.u.connect.hostname))
		    >= sizeof(fm.u.connect.hostname))
			fatalx("mfa_session_proceed: CONNECT: truncation");
		fm.u.connect.hostaddr = ms->ss.envelope.ss;
		break;
d313 2
a314 7
	case S_HELO:
		fm.type = FILTER_HELO;
		if (strlcpy(fm.u.helo.helohost, ms->ss.envelope.helo,
			sizeof(fm.u.helo.helohost))
		    >= sizeof(fm.u.helo.helohost))
			fatalx("mfa_session_proceed: HELO: truncation");
		break;
d316 42
a357 9
	case S_MAIL_MFA:
		fm.type = FILTER_MAIL;
		if (strlcpy(fm.u.mail.user, ms->ss.u.maddr.user,
			sizeof(fm.u.mail.user)) >= sizeof(fm.u.mail.user))
			fatalx("mfa_session_proceed: MAIL: user truncation");
		if (strlcpy(fm.u.mail.domain, ms->ss.u.maddr.domain,
			sizeof(fm.u.mail.domain)) >= sizeof(fm.u.mail.domain))
			fatalx("mfa_session_proceed: MAIL: domain truncation");
		break;
d359 5
a363 9
	case S_RCPT_MFA:
		fm.type = FILTER_RCPT;
		if (strlcpy(fm.u.mail.user, ms->ss.u.maddr.user,
			sizeof(fm.u.mail.user)) >= sizeof(fm.u.mail.user))
			fatalx("mfa_session_proceed: RCPT: user truncation");
		if (strlcpy(fm.u.mail.domain, ms->ss.u.maddr.domain,
			sizeof(fm.u.mail.domain)) >= sizeof(fm.u.mail.domain))
			fatalx("mfa_session_proceed: RCPT: domain truncation");
		break;
d365 1
a365 7
	case S_DATACONTENT:
		fm.type = FILTER_DATALINE;
		if (strlcpy(fm.u.dataline.line, ms->ss.u.dataline,
			sizeof(fm.u.dataline.line))
		    >= sizeof(fm.u.dataline.line))
			fatalx("mfa_session_proceed: DATA: line truncation");
		break;
d367 15
a381 3
	case S_QUIT:
		fm.type = FILTER_QUIT;
		break;
d383 10
a392 3
	case S_CLOSE:
		fm.type = FILTER_CLOSE;
		break;
d394 2
a395 3
	case S_RSET:
		fm.type = FILTER_RSET;
		break;
d397 4
a400 2
	default:
		fatalx("mfa_session_proceed: no such state");
d403 4
a406 6
	imsg_compose(ms->filter->ibuf, fm.type, 0, 0, -1,
	    &fm, sizeof(fm));
	event_set(&ms->filter->ev, ms->filter->ibuf->fd, EV_READ|EV_WRITE,
	    mfa_session_imsg, ms->filter);
	event_add(&ms->filter->ev, NULL);
	return 1;
d410 1
a410 1
mfa_session_pickup(struct mfa_session *ms)
d412 3
a414 2
	if (ms->fm.code == STATUS_REJECT) {
		mfa_session_fail(ms);
d418 39
a456 5
	ms->filter = TAILQ_NEXT(ms->filter, f_entry);
	if (ms->filter == NULL)
		mfa_session_done(ms);
	else
		mfa_session_proceed(ms);
d460 1
a460 1
mfa_session_done(struct mfa_session *ms)
d462 19
a480 16
	enum imsg_type imsg_type;

	switch (ms->state) {
	case S_CONNECTED:
		imsg_type = IMSG_MFA_CONNECT;
		break;
	case S_HELO:
		imsg_type = IMSG_MFA_HELO;
		break;
	case S_MAIL_MFA:
		if (ms->ss.code != 530) {
			imsg_compose_event(env->sc_ievs[PROC_LKA],
			    IMSG_LKA_MAIL, 0, 0, -1,
			    &ms->ss, sizeof(ms->ss));
			mfa_session_destroy(ms);
			return;
d482 44
a525 9
		imsg_type = IMSG_MFA_MAIL;
		break;
	case S_RCPT_MFA:
		if (ms->ss.code != 530) {
			imsg_compose_event(env->sc_ievs[PROC_LKA],
			    IMSG_LKA_RULEMATCH, 0, 0, -1,
			    &ms->ss, sizeof(ms->ss));
			mfa_session_destroy(ms);
			return;
d527 13
a539 1
		imsg_type = IMSG_MFA_RCPT;
d541 26
a566 6
	case S_DATACONTENT:
		if (ms->ss.code != 530 && ms->fm.code != 0)
			(void)strlcpy(ms->ss.u.dataline,
			    ms->fm.u.dataline.line,
			    sizeof(ms->ss.u.dataline));
		imsg_type = IMSG_MFA_DATALINE;
d568 5
a572 2
	case S_QUIT:
		imsg_type = IMSG_MFA_QUIT;
d574 3
a576 6
	case S_CLOSE:
		/* Why answer back to SMTP? The session is closed! */
		mfa_session_destroy(ms);
		return;
	case S_RSET:
		imsg_type = IMSG_MFA_RSET;
d578 1
d580 1
a580 1
		fatalx("mfa_session_done: unsupported state");
d583 4
a586 3
	imsg_compose_event(env->sc_ievs[PROC_SMTP], imsg_type, 0, 0,
	    -1, &ms->ss, sizeof(struct submit_status));
	mfa_session_destroy(ms);
d589 2
a590 2
static void
mfa_session_fail(struct mfa_session *ms)
d592 6
a597 2
	ms->ss.code = 530;
	mfa_session_done(ms);
d600 5
a604 2
static void
mfa_session_destroy(struct mfa_session *ms)
d606 10
a615 2
	tree_xpop(&sessions, ms->id);
	free(ms);
d618 2
a619 2
static void
mfa_session_imsg(int fd, short event, void *p)
d621 14
a634 16
	struct filter	       *filter = p;
	struct mfa_session     *ms;
	struct imsg		imsg;
	ssize_t			n;
	struct filter_msg	fm;
	short			evflags = EV_READ;

	if (event & EV_READ) {
		n = imsg_read(filter->ibuf);
		if (n == -1)
			fatal("mfa_session_imsg: imsg_read");
		if (n == 0) {
			event_del(&filter->ev);
			event_loopexit(NULL);
			return;
		}
d636 1
d638 8
a645 5
	if (event & EV_WRITE) {
		if (msgbuf_write(&filter->ibuf->w) == -1)
			fatal("mfa_session_imsg: msgbuf_write");
		if (filter->ibuf->w.queued)
			evflags |= EV_WRITE;
d647 1
d649 9
a657 40
	for (;;) {
		n = imsg_get(filter->ibuf, &imsg);
		if (n == -1)
			fatalx("mfa_session_imsg: imsg_get");
		if (n == 0)
			break;

		if ((imsg.hdr.len - IMSG_HEADER_SIZE)
		    != sizeof(fm))
			fatalx("mfa_session_imsg: corrupted imsg");

		memcpy(&fm, imsg.data, sizeof (fm));
		if (fm.version != FILTER_API_VERSION)
			fatalx("mfa_session_imsg: API version mismatch");

		switch (imsg.hdr.type) {
		case FILTER_CONNECT:
		case FILTER_HELO:
		case FILTER_EHLO:
		case FILTER_MAIL:
		case FILTER_RCPT:
		case FILTER_DATALINE:
		case FILTER_QUIT:
		case FILTER_CLOSE:
		case FILTER_RSET:
			ms = tree_xget(&sessions, fm.id);

			/* overwrite filter code */
			ms->fm.code = fm.code;

			/* success, overwrite */
			if (fm.code == STATUS_ACCEPT)
				ms->fm = fm;

			mfa_session_pickup(ms);
			break;
		default:
			fatalx("mfa_session_imsg: unsupported imsg");
		}
		imsg_free(&imsg);
a658 3
	event_set(&filter->ev, filter->ibuf->fd, evflags,
	    mfa_session_imsg, filter);
	event_add(&filter->ev, NULL);
@


1.11
log
@- no need to set imsg_type to IMSG_MFA_CLOSE when we're not going to answer
  to SMTP ..
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.10 2012/09/29 11:02:41 eric Exp $	*/
d74 1
a74 1
	struct filter_msg      	 fm;
d85 2
a86 1
			    sizeof(fm.u.connect.hostname)) >= sizeof(fm.u.connect.hostname))
d91 1
a91 1
 	case S_HELO:
d94 2
a95 1
			sizeof(fm.u.helo.helohost)) >= sizeof(fm.u.helo.helohost))
d122 2
a123 1
			sizeof(fm.u.dataline.line)) >= sizeof(fm.u.dataline.line))
d145 2
a146 1
	event_set(&ms->filter->ev, ms->filter->ibuf->fd, EV_READ|EV_WRITE, mfa_session_imsg, ms->filter);
d180 3
a182 2
			imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_MAIL, 0,
			    0, -1, &ms->ss, sizeof(ms->ss));
d190 3
a192 2
			imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_RULEMATCH,
			    0, 0, -1, &ms->ss, sizeof(ms->ss));
d200 3
a202 2
			(void)strlcpy(ms->ss.u.dataline, ms->fm.u.dataline.line,
				      sizeof(ms->ss.u.dataline));
@


1.10
log
@some mfa_session cleanups.

- move mfa_session() prototype to smtpd.h
- make mfa session use a tree
- make static functions static
- merge mfa_session_init() into mfa_session()

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.9 2012/09/11 12:47:36 eric Exp $	*/
a201 1
		imsg_type = IMSG_MFA_CLOSE;
@


1.9
log
@log the process name and place when calling fatal().

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.8 2012/08/19 14:16:58 chl Exp $	*/
d42 6
a47 9
void mfa_session(struct submit_status *, enum session_state);
struct mfa_session *mfa_session_init(struct submit_status *, enum session_state);
struct mfa_session *mfa_session_find(uint64_t);
struct mfa_session *mfa_session_xfind(uint64_t);
int mfa_session_proceed(struct mfa_session *);
void mfa_session_pickup(struct mfa_session *);
void mfa_session_fail(struct mfa_session *);
void mfa_session_destroy(struct mfa_session *);
void mfa_session_done(struct mfa_session *);
d49 1
a49 1
void mfa_session_imsg(int, short, void *);
d56 1
a56 18
	ms = mfa_session_init(ss, state);
	if (ms->filter == NULL) {
		mfa_session_done(ms);
		return;
	}
	if (! mfa_session_proceed(ms))
		mfa_session_fail(ms);
}

struct mfa_session *
mfa_session_init(struct submit_status *ss, enum session_state state)
{
	struct mfa_session *ms;

	ms = calloc(1, sizeof(*ms));
	if (ms == NULL)
		fatal("mfa_session_init: calloc");

d63 1
a63 1
	SPLAY_INSERT(mfatree, &env->mfa_sessions, ms);
d65 4
a68 1
	return ms;
d71 1
a71 2

int
d147 1
a147 1
void
d162 1
a162 1
void
d218 1
a218 22
struct mfa_session *
mfa_session_find(uint64_t id)
{
	struct mfa_session key;

	key.id = id;
	return SPLAY_FIND(mfatree, &env->mfa_sessions, &key);
}

struct mfa_session *
mfa_session_xfind(uint64_t id)
{
	struct mfa_session *ms;

	ms = mfa_session_find(id);
	if (ms == NULL)
		fatalx("mfa_session_xfind: mfa session missing");

	return ms;
}

void
d225 1
a225 1
void
d228 1
a228 1
	SPLAY_REMOVE(mfatree, &env->mfa_sessions, ms);
d232 1
a232 1
void
d285 1
a285 1
			ms = mfa_session_xfind(fm.id);
a304 17

int
mfa_session_cmp(struct mfa_session *s1, struct mfa_session *s2)
{
	/*
	 * do not return uint64_t's
	 */
	if (s1->id < s2->id)
		return -1;

	if (s1->id > s2->id)
		return 1;

	return 0;
}

SPLAY_GENERATE(mfatree, mfa_session, nodes, mfa_session_cmp);
@


1.8
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.7 2012/01/18 13:41:54 chl Exp $	*/
d284 1
a284 1
			fatal("imsg_read");
d294 1
a294 1
			fatal("msgbuf_write");
d302 1
a302 1
			fatalx("imsg_get");
d308 1
a308 1
			fatalx("corrupted imsg");
d312 1
a312 1
			fatalx("API version mismatch");
d336 1
a336 1
			fatalx("unsupported imsg");
@


1.7
log
@Add new filters callbacks for:
- network events (CONNECT/CLOSE)
- commands (QUIT/RSET)

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.6 2011/11/28 22:13:27 chl Exp $	*/
d44 2
a45 2
struct mfa_session *mfa_session_find(u_int64_t);
struct mfa_session *mfa_session_xfind(u_int64_t);
d237 1
a237 1
mfa_session_find(u_int64_t id)
d246 1
a246 1
mfa_session_xfind(u_int64_t id)
d349 1
a349 1
	 * do not return u_int64_t's
@


1.6
log
@use STATUS_* filter codes, instead of -1/0/1 hard coded values

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.5 2011/10/23 09:30:07 gilles Exp $	*/
d99 10
a108 1
	case S_HELO:
d110 2
a111 2
		if (strlcpy(fm.u.helo.buffer, ms->ss.envelope.helo,
			sizeof(fm.u.helo.buffer)) >= sizeof(fm.u.helo.buffer))
d142 12
d186 3
d216 11
d315 1
d321 3
@


1.5
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.4 2011/09/01 09:42:15 chl Exp $	*/
d147 1
a147 1
	if (ms->fm.code == -1) {
d291 1
a291 1
			if (fm.code == 1)
@


1.4
log
@- if no filter is setup, do not overwrite the data line with filtmsg buffer
- remove annoying debug lines
- disable back filters at smtpd.conf level

committing on behalf of gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.3 2011/08/31 18:56:30 gilles Exp $	*/
d101 1
a101 1
		if (strlcpy(fm.u.helo.buffer, ms->ss.envelope.delivery.helo,
@


1.3
log
@add support for per-line DATA callbacks, this allows filters to take their
decisions *while* the message is being received by the client.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.2 2011/08/28 00:03:24 gilles Exp $	*/
d187 1
a187 1
		if (ms->ss.code != 530)
d189 1
a189 1
			    sizeof(ms->ss.u.dataline));
@


1.2
log
@fix pasto in strlcpy() truncation test
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa_session.c,v 1.1 2011/08/27 22:32:41 gilles Exp $	*/
d126 7
d186 6
d284 1
a284 1
		case FILTER_DATA:
@


1.1
log
@initial support for a session-time filtering API

currently only HELO/EHLO, MAIL, RCPT are supported, however ... I have
voluntarily disabled filters at smtpd.conf level so people don't play with
it until the API has stabilized a bit

discussed with several people in private, no one opposed the feature
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 1
a109 1
			sizeof(ms->ss.u.maddr.user)) >= sizeof(ms->ss.u.maddr.user))
d112 1
a112 1
			sizeof(ms->ss.u.maddr.domain)) >= sizeof(ms->ss.u.maddr.domain))
d119 1
a119 1
			sizeof(ms->ss.u.maddr.user)) >= sizeof(ms->ss.u.maddr.user))
d122 1
a122 1
			sizeof(ms->ss.u.maddr.domain)) >= sizeof(ms->ss.u.maddr.domain))
@

