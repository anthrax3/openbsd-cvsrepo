head	1.65;
access;
symbols
	OPENBSD_5_3:1.58.0.2
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.46.0.2
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.2
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12;
locks; strict;
comment	@ * @;


1.65
date	2013.07.19.20.37.07;	author eric;	state dead;
branches;
next	1.64;

1.64
date	2013.07.19.15.09.40;	author eric;	state Exp;
branches;
next	1.63;

1.63
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.62;

1.62
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.61;

1.61
date	2013.04.02.09.17.14;	author gilles;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.31.14.42.21;	author gilles;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.30.10.41.03;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.57;

1.57
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2012.11.23.09.25.44;	author eric;	state Exp;
branches;
next	1.55;

1.55
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.54;

1.54
date	2012.10.22.21.58.14;	author chl;	state Exp;
branches;
next	1.53;

1.53
date	2012.08.30.18.19.50;	author eric;	state Exp;
branches;
next	1.52;

1.52
date	2012.08.26.17.08.41;	author eric;	state Exp;
branches;
next	1.51;

1.51
date	2012.08.24.13.13.13;	author chl;	state Exp;
branches;
next	1.50;

1.50
date	2012.08.24.10.07.28;	author eric;	state Exp;
branches;
next	1.49;

1.49
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.48;

1.48
date	2012.08.19.10.32.32;	author chl;	state Exp;
branches;
next	1.47;

1.47
date	2012.08.08.17.31.55;	author eric;	state Exp;
branches;
next	1.46;

1.46
date	2012.07.10.23.21.34;	author chl;	state Exp;
branches;
next	1.45;

1.45
date	2012.07.09.08.08.29;	author gilles;	state Exp;
branches;
next	1.44;

1.44
date	2012.07.08.18.13.08;	author chl;	state Exp;
branches;
next	1.43;

1.43
date	2012.07.02.13.22.14;	author eric;	state Exp;
branches;
next	1.42;

1.42
date	2012.06.20.20.45.23;	author eric;	state Exp;
branches;
next	1.41;

1.41
date	2012.06.01.11.42.34;	author eric;	state Exp;
branches;
next	1.40;

1.40
date	2012.06.01.09.24.58;	author eric;	state Exp;
branches;
next	1.39;

1.39
date	2012.03.07.22.54.49;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2012.01.31.21.05.26;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2012.01.29.16.54.13;	author eric;	state Exp;
branches;
next	1.36;

1.36
date	2012.01.29.10.40.05;	author eric;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.24.12.20.18;	author eric;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.14.19.35.31;	author eric;	state Exp;
branches;
next	1.33;

1.33
date	2012.01.14.12.56.49;	author eric;	state Exp;
branches;
next	1.32;

1.32
date	2012.01.14.10.48.47;	author eric;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.14.08.37.16;	author eric;	state Exp;
branches;
next	1.30;

1.30
date	2012.01.13.22.01.23;	author eric;	state Exp;
branches;
next	1.29;

1.29
date	2012.01.13.21.58.35;	author eric;	state Exp;
branches;
next	1.28;

1.28
date	2012.01.12.17.00.56;	author eric;	state Exp;
branches;
next	1.27;

1.27
date	2012.01.11.22.24.37;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.11.17.46.36;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.27.17.13.05;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.23.12.10.06;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.22.18.41.30;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.14.17.55.55;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2011.11.21.18.57.54;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.15.23.12.44;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.15.23.06.39;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.14.11.53.10;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.06.16.57.27;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2011.10.27.14.32.57;	author chl;	state Exp;
branches;
next	1.15;

1.15
date	2011.10.23.13.03.05;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2011.08.26.14.39.47;	author chl;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.17.11.39.22;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.16.09.13.38;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.14.23.29.56;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.14.23.26.16;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.14.22.36.09;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.14.21.53.46;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.14.21.14.20;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.14.20.11.08;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.14.17.06.43;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Assorted queue improvements:
- cleanup the internal queue backend API and get rid of the QOP_* thing.
- implement a queue_proc backend
- rename queue_fsqueue.c to queue_fs
- enable support for queue encryption
- add an envelope cache
- better logging and error reporting
@
text
@/*	$OpenBSD: queue_fsqueue.c,v 1.64 2013/07/19 15:09:40 eric Exp $	*/

/*
 * Copyright (c) 2011 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/mount.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <fts.h>
#include <imsg.h>
#include <inttypes.h>
#include <libgen.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

static int	fsqueue_envelope_create(uint64_t *, char *, size_t);
static int	fsqueue_envelope_load(uint64_t, char *, size_t);
static int	fsqueue_envelope_update(uint64_t, char *, size_t);
static int	fsqueue_envelope_delete(uint64_t);
static int	fsqueue_envelope_walk(uint64_t *, char *, size_t);

static int	fsqueue_message_create(uint32_t *);
static int	fsqueue_message_commit(uint32_t);
static int	fsqueue_message_fd_r(uint32_t);
static int	fsqueue_message_fd_rw(uint32_t);
static int	fsqueue_message_delete(uint32_t);
static int	fsqueue_message_corrupt(uint32_t);

static void	fsqueue_message_path(uint32_t, char *, size_t);
static void	fsqueue_envelope_path(uint64_t, char *, size_t);
static void	fsqueue_envelope_incoming_path(uint64_t, char *, size_t);

static int	fsqueue_envelope_dump(char *, char *, size_t, int, int);

static int	fsqueue_init(struct passwd *, int);
static int	fsqueue_message(enum queue_op, uint32_t *);
static int	fsqueue_envelope(enum queue_op , uint64_t *, char *, size_t);

static void    *fsqueue_qwalk_new(void);
static int	fsqueue_qwalk(void *, uint64_t *);
static void	fsqueue_qwalk_close(void *);

struct tree	evpcount;

#define PATH_QUEUE		"/queue"
#define PATH_CORRUPT		"/corrupt"

#define PATH_EVPTMP		PATH_INCOMING "/envelope.tmp"

/* percentage of remaining space / inodes required to accept new messages */
#define	MINSPACE		5
#define	MININODES		5

struct queue_backend	queue_backend_fs = {
	fsqueue_init,
	fsqueue_message,
	fsqueue_envelope,
};

static struct timespec	startup;

static int
fsqueue_check_space(void)
{
	struct statfs	buf;
	uint64_t	used;
	uint64_t	total;

	if (statfs(PATH_QUEUE, &buf) < 0) {
		log_warn("warn: fsqueue_check_space: statfs");
		return 0;
	}

	used = buf.f_blocks - buf.f_bfree;
	total = buf.f_bavail + used;
	if (total != 0)
		used = (float)used / (float)total * 100;
	else
		used = 100;
	if (100 - used < MINSPACE) {
		log_warnx("warn: not enough disk space: %llu%% left", 100 - used);
		log_warnx("warn: temporarily rejecting messages");
		return 0;
	}

	used = buf.f_files - buf.f_ffree;
	total = buf.f_favail + used;
	if (total != 0)
		used = (float)used / (float)total * 100;
	else
		used = 100;
	if (100 - used < MININODES) {
		log_warnx("warn: not enough inodes: %llu%% left", 100 - used);
		log_warnx("warn: temporarily rejecting messages");
		return 0;
	}

	return 1;
}

static void
fsqueue_message_path(uint32_t msgid, char *buf, size_t len)
{
	if (! bsnprintf(buf, len, "%s/%02x/%08x",
		PATH_QUEUE,
		(msgid & 0xff000000) >> 24,
		msgid))
		fatalx("fsqueue_message_path: path does not fit buffer");
}

static void
fsqueue_message_corrupt_path(uint32_t msgid, char *buf, size_t len)
{
	if (! bsnprintf(buf, len, "%s/%08x",
		PATH_CORRUPT,
		msgid))
		fatalx("fsqueue_message_corrupt_path: path does not fit buffer");
}

static void
fsqueue_envelope_path(uint64_t evpid, char *buf, size_t len)
{
	if (! bsnprintf(buf, len, "%s/%02x/%08x/%016" PRIx64,
		PATH_QUEUE,
		(evpid_to_msgid(evpid) & 0xff000000) >> 24,
		evpid_to_msgid(evpid),
		evpid))
		fatalx("fsqueue_envelope_path: path does not fit buffer");
}

static void
fsqueue_envelope_incoming_path(uint64_t evpid, char *buf, size_t len)
{
	if (! bsnprintf(buf, len, "%s/%08x/%016" PRIx64,
		PATH_INCOMING,
		evpid_to_msgid(evpid),
		evpid))
		fatalx("fsqueue_envelope_incoming_path: path does not fit buffer");
}

static int
fsqueue_envelope_dump(char *dest, char *evpbuf, size_t evplen, int do_atomic, int do_sync)
{
	const char     *path = do_atomic ? PATH_EVPTMP : dest;
	FILE	       *fp = NULL;
	int		fd;
	size_t		w;

	if ((fd = open(path, O_RDWR | O_CREAT | O_EXCL, 0600)) == -1) {
		if (errno == EEXIST)
			return -1;
		log_warn("warn: fsqueue_envelope_dump: open");
		goto tempfail;
	}

	if ((fp = fdopen(fd, "w")) == NULL) {
		log_warn("warn: fsqueue_envelope_dump: fdopen");
		goto tempfail;
	}

	w = fwrite(evpbuf, 1, evplen, fp);
	if (w < evplen) {
		log_warn("warn: fsqueue_envelope_dump: short write");
		goto tempfail;
	}
	if (fflush(fp)) {
		log_warn("warn: fsqueue_envelope_dump: fflush");
		goto tempfail;
	}
	if (do_sync && fsync(fileno(fp))) {
		log_warn("warn: fsqueue_envelope_dump: fsync");
		goto tempfail;
	}
	if (fclose(fp) != 0) {
		log_warn("warn: fsqueue_envelope_dump: fclose");
		fp = NULL;
		goto tempfail;
	}
	fp = NULL;
	fd = -1;

	if (do_atomic && rename(path, dest) == -1) {
		log_warn("warn: fsqueue_envelope_dump: rename");
		goto tempfail;
	}
	return (1);

tempfail:
	if (fp)
		fclose(fp);
	else if (fd != -1)
		close(fd);
	if (unlink(path) == -1)
		log_warn("warn: fsqueue_envelope_dump: unlink");
	return (0);
}

static int
fsqueue_envelope_create(uint64_t *evpid, char *buf, size_t len)
{
	char		path[SMTPD_MAXPATHLEN];
	uint32_t	msgid;
	int		queued = 0, i, r = 0;
	struct stat	sb;
	uintptr_t	*n;

	msgid = evpid_to_msgid(*evpid);
	if (msgid == 0) {
		log_warnx("warn: fsqueue_envelope_create: msgid=0, "
		    "evpid=%016"PRIx64, *evpid);
		goto done;
	}
	
	queue_message_incoming_path(msgid, path, sizeof(path));
	if (stat(path, &sb) == -1)
		queued = 1;

	for (i = 0; i < 20; i ++) {
		*evpid = queue_generate_evpid(msgid);
		if (queued)
			fsqueue_envelope_path(*evpid, path, sizeof(path));
		else
			fsqueue_envelope_incoming_path(*evpid, path,
			    sizeof(path));

		r = fsqueue_envelope_dump(path, buf, len, 0, 1);
		if (r >= 0)
			goto done;
	}
	r = 0;
	log_warnx("warn: fsqueue_envelope_create: could not allocate evpid");

done:
	if (r) {
		n = tree_pop(&evpcount, msgid);
		n += 1;
		tree_xset(&evpcount, msgid, n);
	}
	return (r);
}

static int
fsqueue_envelope_load(uint64_t evpid, char *buf, size_t len)
{
	char	 pathname[SMTPD_MAXPATHLEN];
	FILE	*fp;
	size_t	 r;

	fsqueue_envelope_path(evpid, pathname, sizeof(pathname));

	fp = fopen(pathname, "r");
	if (fp == NULL) {
		if (errno != ENOENT && errno != ENFILE)
			log_warn("warn: fsqueue_envelope_load: fopen");
		return 0;
	}

	r = fread(buf, 1, len, fp);
	if (r) {
		if (r == len) {
			log_warn("warn: fsqueue_envelope_load: too large");
			r = 0;
		}
		else
			buf[r] = '\0';
	}
	fclose(fp);

	return (r);
}

static int
fsqueue_envelope_update(uint64_t evpid, char *buf, size_t len)
{
	char dest[SMTPD_MAXPATHLEN];

	fsqueue_envelope_path(evpid, dest, sizeof(dest));

	return (fsqueue_envelope_dump(dest, buf, len, 1, 1));
}

static int
fsqueue_envelope_delete(uint64_t evpid)
{
	char		pathname[SMTPD_MAXPATHLEN];
	uint32_t	msgid;
	uintptr_t	*n;

	fsqueue_envelope_path(evpid, pathname, sizeof(pathname));
	if (unlink(pathname) == -1)
		if (errno != ENOENT)
			return 0;

	msgid = evpid_to_msgid(evpid);
	n = tree_pop(&evpcount, msgid);
	n -= 1;
	if (n == NULL)
		fsqueue_message_delete(msgid);
	else
		tree_xset(&evpcount, msgid, n);

	return (1);
}

static int
fsqueue_envelope_walk(uint64_t *evpid, char *buf, size_t len)
{
	static int	 done = 0;
	static void	*hdl = NULL;
	uintptr_t	*n;
	int		 r;
	uint32_t	 msgid;

	if (done)
		return (-1);

	if (hdl == NULL)
		hdl = fsqueue_qwalk_new();

	if (fsqueue_qwalk(hdl, evpid)) {
		bzero(buf, len);
		r = fsqueue_envelope_load(*evpid, buf, len);
		if (r) {
			msgid = evpid_to_msgid(*evpid);
			n = tree_pop(&evpcount, msgid);
			n += 1;
			tree_xset(&evpcount, msgid, n);
		}
		return (r);
	}

	fsqueue_qwalk_close(hdl);
	done = 1;
	return (-1);
}

static int
fsqueue_message_create(uint32_t *msgid)
{
	char		rootdir[SMTPD_MAXPATHLEN];
	struct stat	sb;

	if (! fsqueue_check_space())
		return 0;

again:
	*msgid = queue_generate_msgid();

	/* prevent possible collision later when moving to Q_QUEUE */
	fsqueue_message_path(*msgid, rootdir, sizeof(rootdir));
	if (stat(rootdir, &sb) != -1)
		goto again;

	/* we hit an unexpected error, temporarily fail */
	if (errno != ENOENT) {
		*msgid = 0;
		return 0;
	}

	queue_message_incoming_path(*msgid, rootdir, sizeof(rootdir));
	if (mkdir(rootdir, 0700) == -1) {
		if (errno == EEXIST)
			goto again;

		if (errno == ENOSPC) {
			*msgid = 0;
			return 0;
		}

		log_warn("warn: fsqueue_message_create: mkdir");
		*msgid = 0;
		return 0;
	}

	return (1);
}

static int
fsqueue_message_commit(uint32_t msgid)
{
	char incomingdir[SMTPD_MAXPATHLEN];
	char queuedir[SMTPD_MAXPATHLEN];
	char msgdir[SMTPD_MAXPATHLEN];

	queue_message_incoming_path(msgid, incomingdir, sizeof(incomingdir));
	fsqueue_message_path(msgid, msgdir, sizeof(msgdir));
	strlcpy(queuedir, msgdir, sizeof(queuedir));

	/* first attempt to rename */
	if (rename(incomingdir, msgdir) == 0)
		return 1;
	if (errno == ENOSPC)
		return 0;
	if (errno != ENOENT) {
		log_warn("warn: fsqueue_message_commit: rename");
		return 0;
	}

	/* create the bucket */
	*strrchr(queuedir, '/') = '\0';
	if (mkdir(queuedir, 0700) == -1) {
		if (errno == ENOSPC)
			return 0;
		if (errno != EEXIST) {
			log_warn("warn: fsqueue_message_commit: mkdir");
			return 0;
		}
	}

	/* rename */
	if (rename(incomingdir, msgdir) == -1) {
		if (errno == ENOSPC)
			return 0;
		log_warn("warn: fsqueue_message_commit: rename");
		return 0;
	}

	return 1;
}

static int
fsqueue_message_fd_r(uint32_t msgid)
{
	int fd;
	char path[SMTPD_MAXPATHLEN];

	fsqueue_message_path(msgid, path, sizeof(path));
	strlcat(path, PATH_MESSAGE, sizeof(path));

	if ((fd = open(path, O_RDONLY)) == -1) {
		log_warn("fsqueue_message_fd_r: open");
		return -1;
	}

	return fd;
}

static int
fsqueue_message_fd_rw(uint32_t msgid)
{
	char msgpath[SMTPD_MAXPATHLEN];

	queue_message_incoming_path(msgid, msgpath, sizeof msgpath);
	strlcat(msgpath, PATH_MESSAGE, sizeof(msgpath));

	return open(msgpath, O_RDWR | O_CREAT | O_EXCL, 0600);
}

static int
fsqueue_message_delete(uint32_t msgid)
{
	char		path[SMTPD_MAXPATHLEN];
	struct stat	sb;

	queue_message_incoming_path(msgid, path, sizeof(path));
	if (stat(path, &sb) == -1)
		fsqueue_message_path(msgid, path, sizeof(path));

	if (rmtree(path, 0) == -1)
		log_warn("warn: fsqueue_message_delete: rmtree");

	tree_pop(&evpcount, msgid);

	return 1;
}

static int
fsqueue_message_corrupt(uint32_t msgid)
{
	struct stat sb;
	char rootdir[SMTPD_MAXPATHLEN];
	char corruptdir[SMTPD_MAXPATHLEN];
	char buf[64];
	int  retry = 0;

	fsqueue_message_path(msgid, rootdir, sizeof(rootdir));
	fsqueue_message_corrupt_path(msgid, corruptdir,
	    sizeof(corruptdir));

again:
	if (stat(corruptdir, &sb) != -1 || errno != ENOENT) {
		fsqueue_message_corrupt_path(msgid, corruptdir,
		    sizeof(corruptdir));
		snprintf(buf, sizeof(buf), ".%i", retry++);
		strlcat(corruptdir, buf, sizeof(corruptdir));
		goto again;
	}

	if (rename(rootdir, corruptdir) == -1) {
		log_warn("warn: fsqueue_message_corrupt: rename");
		return 0;
	}

	tree_pop(&evpcount, msgid);

	return 1;
}

static int
fsqueue_init(struct passwd *pwq, int server)
{
	unsigned int	 n;
	char		*paths[] = { PATH_QUEUE, PATH_CORRUPT, PATH_INCOMING };
	char		 path[SMTPD_MAXPATHLEN];
	int		 ret;
	struct timeval	 tv;

	/* remove incoming/ if it exists */
	if (server)
		mvpurge(PATH_SPOOL PATH_INCOMING, PATH_SPOOL PATH_PURGE);

	fsqueue_envelope_path(0, path, sizeof(path));

	ret = 1;
	for (n = 0; n < nitems(paths); n++) {
		strlcpy(path, PATH_SPOOL, sizeof(path));
		if (strlcat(path, paths[n], sizeof(path)) >= sizeof(path))
			errx(1, "path too long %s%s", PATH_SPOOL, paths[n]);

		if (ckdir(path, 0700, pwq->pw_uid, 0, server) == 0)
			ret = 0;
	}

	if (gettimeofday(&tv, NULL) == -1)
		err(1, "gettimeofday");
	TIMEVAL_TO_TIMESPEC(&tv, &startup);

	tree_init(&evpcount);

	return ret;
}

static int
fsqueue_message(enum queue_op qop, uint32_t *msgid)
{
	switch (qop) {
	case QOP_CREATE:
		return fsqueue_message_create(msgid);
	case QOP_DELETE:
		return fsqueue_message_delete(*msgid);
	case QOP_COMMIT:
		return fsqueue_message_commit(*msgid);
	case QOP_FD_R:
		return fsqueue_message_fd_r(*msgid);
	case QOP_FD_RW:
		return fsqueue_message_fd_rw(*msgid);
	case QOP_CORRUPT:
		return fsqueue_message_corrupt(*msgid);
	default:
		fatalx("queue_fsqueue_message: unsupported operation.");
	}
	return 0;
}

static int
fsqueue_envelope(enum queue_op qop, uint64_t *evpid, char *buf, size_t len)
{
	switch (qop) {
	case QOP_CREATE:
		return fsqueue_envelope_create(evpid, buf, len);
	case QOP_DELETE:
		return fsqueue_envelope_delete(*evpid);
	case QOP_LOAD:
		return fsqueue_envelope_load(*evpid, buf, len);
	case QOP_UPDATE:
		return fsqueue_envelope_update(*evpid, buf, len);
	case QOP_WALK:
		return fsqueue_envelope_walk(evpid, buf, len);
	default:
		fatalx("queue_fsqueue_envelope: unsupported operation.");
	}
	return 0;
}

struct qwalk {
	FTS	*fts;
	int	 depth;
};

static void *
fsqueue_qwalk_new(void)
{
	char		 path[SMTPD_MAXPATHLEN];
	char * const	 path_argv[] = { path, NULL };
	struct qwalk	*q;

	q = xcalloc(1, sizeof(*q), "fsqueue_qwalk_new");
	strlcpy(path, PATH_QUEUE, sizeof(path));
	q->fts = fts_open(path_argv,
	    FTS_PHYSICAL | FTS_NOCHDIR, NULL);

	if (q->fts == NULL)
		err(1, "fsqueue_qwalk_new: fts_open: %s", path);

	return (q);
}

static void
fsqueue_qwalk_close(void *hdl)
{
	struct qwalk	*q = hdl;

	fts_close(q->fts);

	free(q);
}

static int
fsqueue_qwalk(void *hdl, uint64_t *evpid)
{
	struct qwalk	*q = hdl;
	FTSENT		*e;
	char		*tmp;

	while ((e = fts_read(q->fts)) != NULL) {
		switch (e->fts_info) {
		case FTS_D:
			q->depth += 1;
			if (q->depth == 2 && e->fts_namelen != 2) {
				log_debug("debug: fsqueue: bogus directory %s",
				    e->fts_path);
				fts_set(q->fts, e, FTS_SKIP);
				break;
			}
			if (q->depth == 3 && e->fts_namelen != 8) {
				log_debug("debug: fsqueue: bogus directory %s",
				    e->fts_path);
				fts_set(q->fts, e, FTS_SKIP);
				break;
			}
			break;

		case FTS_DP:
		case FTS_DNR:
			q->depth -= 1;
			break;

		case FTS_F:
			if (q->depth != 3)
				break;
			if (e->fts_namelen != 16)
				break;
			if (timespeccmp(&e->fts_statp->st_mtim, &startup, >))
				break;
			tmp = NULL;
			*evpid = strtoull(e->fts_name, &tmp, 16);
			if (tmp && *tmp !=  '\0') {
				log_debug("debug: fsqueue: bogus file %s",
				    e->fts_path);
				break;
			}
			return (1);
		default:
			break;
		}
	}

	return (0);
}
@


1.64
log
@need to create the incoming directory
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.63 2013/07/19 11:14:08 eric Exp $	*/
@


1.63
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.62 2013/05/24 17:03:14 eric Exp $	*/
d533 1
a533 1
	char		*paths[] = { PATH_QUEUE, PATH_CORRUPT };
d537 4
@


1.62
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.58 2013/01/31 18:34:43 eric Exp $	*/
d65 1
a65 1
static int	fsqueue_init(int);
d530 1
a530 1
fsqueue_init(int server)
d546 1
a546 1
		if (ckdir(path, 0700, env->sc_pwqueue->pw_uid, 0, server) == 0)
@


1.61
log
@change log format to fix warning
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.60 2013/03/31 14:42:21 gilles Exp $	*/
a21 1
#include <sys/param.h>
d81 2
a82 2
#define	MINSPACE		10
#define	MININODES		10
d112 1
d124 1
d231 1
a231 1
	char		path[MAXPATHLEN];
d275 1
a275 1
	char	 pathname[MAXPATHLEN];
d305 1
a305 1
	char dest[MAXPATHLEN];
d315 1
a315 1
	char		pathname[MAXPATHLEN];
a342 1
	struct envelope	 ep;
d355 3
a357 7
			if (! envelope_load_buffer(&ep, buf, r))
				(void)fsqueue_message_corrupt(msgid);
			else {
				n = tree_pop(&evpcount, msgid);
				n += 1;
				tree_xset(&evpcount, msgid, n);
			}
d370 2
a371 2
	char rootdir[MAXPATHLEN];
	struct stat sb;
d381 1
a381 1
	if (stat(rootdir, &sb) != -1 || errno != ENOENT)
d384 6
d411 3
a413 3
	char incomingdir[MAXPATHLEN];
	char queuedir[MAXPATHLEN];
	char msgdir[MAXPATHLEN];
d455 1
a455 1
	char path[MAXPATHLEN];
d471 1
a471 1
	char msgpath[MAXPATHLEN];
d482 1
a482 1
	char		path[MAXPATHLEN];
d501 2
a502 2
	char rootdir[MAXPATHLEN];
	char corruptdir[MAXPATHLEN];
d524 2
d534 1
a534 1
	char		 path[MAXPATHLEN];
d609 1
a609 1
	char		 path[MAXPATHLEN];
@


1.60
log
@ooops, forgot to lower the define after my very last test: it's 10% not 99%
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.59 2013/03/30 10:41:03 gilles Exp $	*/
d112 1
a112 1
		log_warnx("warn: not enough disk space: %lu%% left", 100 - used);
d123 1
a123 1
		log_warnx("warn: not enough inodes: %lu%% left", 100 - used);
@


1.59
log
@have smtpd temporarily refuse new messages if file system holding the queue
has less than 10% of disk space or inodes left. a warning is logged and the
clients will get a temporarily failure asking them to retry later.

prompted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.58 2013/01/31 18:34:43 eric Exp $	*/
d82 1
a82 1
#define	MINSPACE		99
@


1.58
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.57 2013/01/26 09:37:23 gilles Exp $	*/
d25 2
d81 4
d93 37
d376 3
@


1.57
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.55 2012/11/12 14:58:53 eric Exp $	*/
d160 1
a160 1
	if (fclose(fp)) {
d162 1
d233 1
a233 1
	ssize_t	 r;
d245 8
a252 1

d308 1
@


1.56
log
@Replace the qwalk API (to retreive on disk envelopes at runtime) with
a simple QOP_WALK queue operation. Some knf and formating fixes while
there.

ok gilles@@
@
text
@d4 1
a4 1
 * Copyright (c) 2011 Gilles Chehade <gilles@@openbsd.org>
d54 1
d58 5
a62 3
static int	fsqueue_message_path(uint32_t, char *, size_t);
static int	fsqueue_envelope_path(uint64_t, char *, size_t);
static int	fsqueue_envelope_dump_atomic(char *, char *, size_t);
d72 2
d87 1
a87 1
static int
d90 5
a94 4
	return bsnprintf(buf, len, "%s/%02x/%08x",
	    PATH_QUEUE,
	    msgid & 0xff,
	    msgid);
d97 1
a97 1
static int
d100 4
a103 3
	return bsnprintf(buf, len, "%s/%08x",
	    PATH_CORRUPT,
	    msgid);
d106 1
a106 1
static int
d109 16
a124 5
	return bsnprintf(buf, len, "%s/%02x/%08x%s/%016" PRIx64,
	    PATH_QUEUE,
	    evpid_to_msgid(evpid) & 0xff,
	    evpid_to_msgid(evpid),
	    PATH_ENVELOPES, evpid);
d128 1
a128 1
fsqueue_envelope_dump_atomic(char *dest, char *evpbuf, size_t evplen)
d130 4
a133 3
	int	 fd;
	char	 evpname[MAXPATHLEN];
	ssize_t	 w;
d135 6
a140 5
	/* temporary fix for multi-process access to the queue,
	 * should be fixed by rerouting ALL queue access through
	 * the queue process.
	 */
	snprintf(evpname, sizeof evpname, PATH_EVPTMP".%d", getpid());
d142 3
a144 4
	if ((fd = open(evpname, O_RDWR | O_CREAT | O_EXCL, 0600)) == -1) {
		if (errno == ENOSPC || errno == ENFILE)
			goto tempfail;
		fatal("fsqueue_envelope_dump_atomic: open");
d147 12
a158 6
	w = write(fd, evpbuf, evplen);
	if (w == -1) {
		log_warn("warn: fsqueue_envelope_dump_atomic: write");
		if (errno == ENOSPC)
			goto tempfail;
		fatal("fsqueue_envelope_dump_atomic: write");
d160 2
a161 3

	if ((size_t) w != evplen) {
		log_warnx("warn: fsqueue_envelope_dump_atomic: partial write");
d164 2
d167 3
a169 9
	if (fsync(fd))
		fatal("fsync");
	close(fd);

	if (rename(evpname, dest) == -1) {
		log_warn("warn: fsqueue_envelope_dump_atomic: rename");
		if (errno == ENOSPC)
			goto tempfail;
		fatal("fsqueue_envelope_dump_atomic: rename");
a170 1

d174 3
a176 1
	if (fd != -1)
d178 2
a179 2
	if (unlink(evpname) == -1)
		fatal("fsqueue_envelope_dump_atomic: unlink");
d188 1
a188 1
	int		queued = 0, i;
d190 1
d193 6
d208 1
a208 1
			queue_envelope_incoming_path(*evpid, path,
d211 12
a222 2
		if (stat(path, &sb) == -1 && errno == ENOENT)
			goto found;
d224 1
a224 4
	fatal("couldn't figure out a new envelope id");

found:
	return (fsqueue_envelope_dump_atomic(path, buf, len));
d238 3
a240 3
		if (errno == ENOENT || errno == ENFILE)
			return (0);
		fatal("fsqueue_envelope_load: fopen");
d257 1
a257 1
	return (fsqueue_envelope_dump_atomic(dest, buf, len));
d263 3
a265 1
	char pathname[MAXPATHLEN];
a267 1

d269 2
a270 1
		fatal("fsqueue_envelope_delete: unlink");
d272 7
a278 1
	*strrchr(pathname, '/') = '\0';
d280 1
a280 4
	if (rmdir(pathname) != -1)
		fsqueue_message_delete(evpid_to_msgid(evpid));

	return 1;
d288 4
d299 14
a312 2
	if (fsqueue_qwalk(hdl, evpid))
		return (fsqueue_envelope_load(*evpid, buf, len));
a322 1
	char evpdir[MAXPATHLEN];
a341 5
		fatal("fsqueue_message_create: mkdir");
	}

	strlcpy(evpdir, rootdir, sizeof(evpdir));
	strlcat(evpdir, PATH_ENVELOPES, sizeof(evpdir));
d343 3
a345 7
	if (mkdir(evpdir, 0700) == -1) {
		if (errno == ENOSPC) {
			rmdir(rootdir);
			*msgid = 0;
			return 0;
		}
		fatal("fsqueue_message_create: mkdir");
d348 1
a348 1
	return 1;
d361 12
a373 1

d377 4
a380 2
		if (errno != EEXIST)
			fatal("fsqueue_message_commit: mkdir");
d383 1
d387 2
a388 1
		fatal("fsqueue_message_commit: rename");
d403 4
a406 2
	if ((fd = open(path, O_RDONLY)) == -1)
		fatal("fsqueue_message_fd_r: open");
d412 11
d425 6
a430 1
	char rootdir[MAXPATHLEN];
d432 2
a433 2
	if (! fsqueue_message_path(msgid, rootdir, sizeof(rootdir)))
		fatal("fsqueue_message_delete: snprintf");
d435 1
a435 2
	if (rmtree(rootdir, 0) == -1)
		fatal("fsqueue_message_delete: rmtree");
d462 4
a465 2
	if (rename(rootdir, corruptdir) == -1)
		fatalx("fsqueue_message_corrupt: rename");
d479 1
a479 2
	if (!fsqueue_envelope_path(0, path, sizeof(path)))
		errx(1, "cannot store envelope path in %s", PATH_QUEUE);
d487 1
a487 1
		if (ckdir(path, 0700, env->sc_pw->pw_uid, 0, server) == 0)
d495 2
d512 2
d601 1
d606 1
a606 1
			if (q->depth != 4)
@


1.55
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.54 2012/10/22 21:58:14 chl Exp $	*/
d49 1
d65 1
a65 1
static void    *fsqueue_qwalk_new(uint32_t);
d75 3
a77 6
	  fsqueue_init,
	  fsqueue_message,
	  fsqueue_envelope,
	  fsqueue_qwalk_new,
	  fsqueue_qwalk,
	  fsqueue_qwalk_close
d180 2
a181 1
			queue_envelope_incoming_path(*evpid, path, sizeof(path));
d244 20
d272 1
a272 1
	
d372 2
a373 1
	fsqueue_message_corrupt_path(msgid, corruptdir, sizeof(corruptdir));
d377 2
a378 1
		fsqueue_message_corrupt_path(msgid, corruptdir, sizeof(corruptdir));
d422 2
a423 2
        switch (qop) {
        case QOP_CREATE:
d425 1
a425 2

        case QOP_DELETE:
d427 1
a427 2

        case QOP_COMMIT:
d429 2
a430 4

        case QOP_FD_R:
                return fsqueue_message_fd_r(*msgid);

d433 1
a433 2

        default:
d435 1
a435 2
        }

d442 2
a443 2
        switch (qop) {
        case QOP_CREATE:
d445 1
a445 2

        case QOP_DELETE:
d447 1
a447 2

        case QOP_LOAD:
d449 1
a449 2

        case QOP_UPDATE:
d451 3
a453 2

        default:
d455 1
a455 2
        }

a460 1
	uint32_t msgid;
d465 1
a465 1
fsqueue_qwalk_new(uint32_t msgid)
a471 1
	q->msgid = msgid;
d496 1
a496 1
        FTSENT 		*e;
a497 1
	uint32_t	 msgid;
d499 2
a500 3
        while ((e = fts_read(q->fts)) != NULL) {

		switch(e->fts_info) {
a514 8
			if (q->msgid && (q->depth == 2 || q->depth == 3)) {
				msgid = strtoull(e->fts_name, &tmp, 16);
				if (msgid != (q->depth == 1) ?
				    (q->msgid & 0xff) : q->msgid) {
					fts_set(q->fts, e, FTS_SKIP);
					break;
				}
			}
d541 1
a541 1
        return (0); 
@


1.54
log
@switch from {open,read,close}() to {fopen,fread,fclose}() in fsqueue_envelope_load(),
also fix a potential fd leak.

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.53 2012/08/30 18:19:50 eric Exp $	*/
d132 1
a132 1
		log_warn("fsqueue_envelope_dump_atomic: write");
d139 1
a139 1
		log_warnx("fsqueue_envelope_dump_atomic: partial write");
d148 1
a148 1
		log_warn("fsqueue_envelope_dump_atomic: rename");
d496 1
a496 1
				log_debug("fsqueue: bogus directory %s",
d502 1
a502 1
				log_debug("fsqueue: bogus directory %s",
d531 1
a531 1
				log_debug("fsqueue: bogus file %s",
@


1.53
log
@when reloading the envelopes from disk, skip envelopes that are
more recent than the startup time, since they are already known
to the scheduler.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.52 2012/08/26 17:08:41 eric Exp $	*/
d197 1
a197 1
	int	 fd;
d202 2
a203 2
	fd = open(pathname, O_RDONLY);
	if (fd == -1) {
d206 1
a206 1
		fatal("fsqueue_envelope_load: open");
d209 1
a209 2
	if ((r = read(fd, buf, len)) == -1)
		return (0);
d211 1
a211 1
	close(fd);
@


1.52
log
@sane rewrite of the disk-queue traversal code, and log bogus files found
in there.  fixes issues reported by many.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.51 2012/08/24 13:13:13 chl Exp $	*/
d82 2
d377 1
d392 4
d526 2
@


1.51
log
@Don't pass struct envelope pointer in queue backend API, instead use envelope id and
an envelope ascii buffer.

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.49 2012/08/19 14:16:58 chl Exp $	*/
a26 1
#include <dirent.h>
d31 1
a440 4
#define	QWALK_AGAIN	0x1
#define	QWALK_RECURSE	0x2
#define	QWALK_RETURN	0x3

d442 1
a442 5
	char	  path[MAXPATHLEN];
	DIR	 *dirs[3];
	int	(*filefn)(struct qwalk *, char *);
	int	  bucket;
	int	  level;
d444 1
a446 2
static int walk_queue(struct qwalk *, char *);

d450 3
a452 5
	struct qwalk *q;

	q = calloc(1, sizeof(struct qwalk));
	if (q == NULL)
		fatal("qwalk_new: calloc");
d454 1
a454 3
	strlcpy(q->path, PATH_QUEUE, sizeof(q->path));

	q->level = 0;
d456 3
d460 2
a461 12
	if (q->msgid) {
		/* force level and bucket */
		q->bucket = q->msgid & 0xff;
		q->level = 2;
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%02x/%08x%s",
				PATH_QUEUE, q->bucket, q->msgid, PATH_ENVELOPES))
			fatalx("walk_queue: snprintf");
	}
	q->filefn = walk_queue;
	q->dirs[q->level] = opendir(q->path);
	if (q->dirs[q->level] == NULL)
		fatal("qwalk_new: opendir");
a465 60
static int
fsqueue_qwalk(void *hdl, uint64_t *evpid)
{
	struct qwalk *q = hdl;
	struct dirent	*dp;

again:
	errno = 0;
	dp = readdir(q->dirs[q->level]);
	if (errno)
		fatal("qwalk: readdir");
	if (dp == NULL) {
		closedir(q->dirs[q->level]);
		q->dirs[q->level] = NULL;
		if (q->level == 0 || q->msgid)
			return (0);
		q->level--;
		goto again;
	}

	if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
		goto again;

	switch (q->filefn(q, dp->d_name)) {
	case QWALK_AGAIN:
		goto again;
	case QWALK_RECURSE:
		goto recurse;
	case QWALK_RETURN: {
		char *endptr;

		errno = 0;
		*evpid = (uint64_t)strtoull(dp->d_name, &endptr, 16);
		if (q->path[0] == '\0' || *endptr != '\0')
			goto again;
		if (errno == ERANGE && *evpid == ULLONG_MAX)
			goto again;
		if (q->msgid)
			if (evpid_to_msgid(*evpid) != q->msgid)
				return 0;

		return (1);
	}
	default:
		fatalx("qwalk: callback failed");
	}

recurse:
	q->level++;
	q->dirs[q->level] = opendir(q->path);
	if (q->dirs[q->level] == NULL) {
		if (errno == ENOENT) {
			q->level--;
			goto again;
		}
		fatal("qwalk: opendir");
	}
	goto again;
}

d469 1
a469 2
	int i;
	struct qwalk *q = hdl;
d471 1
a471 3
	for (i = 0; i <= q->level; i++)
		if (q->dirs[i])
			closedir(q->dirs[i]);
a472 1
	bzero(q, sizeof(struct qwalk));
d477 1
a477 1
walk_queue(struct qwalk *q, char *fname)
d479 51
a529 12
	char	*ep;

	switch (q->level) {
	case 0:
		q->bucket = strtoul(fname, &ep, 16);
		if (fname[0] == '\0' || *ep != '\0') {
			log_warnx("walk_queue: invalid bucket: %s", fname);
			return (QWALK_AGAIN);
		}
		if (errno == ERANGE || q->bucket >= DIRHASH_BUCKETS) {
			log_warnx("walk_queue: invalid bucket: %s", fname);
			return (QWALK_AGAIN);
a530 12
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%02x",
			PATH_QUEUE, q->bucket & 0xff))
			fatalx("walk_queue: snprintf");
		return (QWALK_RECURSE);
	case 1:
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%02x/%s%s",
				PATH_QUEUE, q->bucket & 0xff, fname,
				PATH_ENVELOPES))
			fatalx("walk_queue: snprintf");
		return (QWALK_RECURSE);
	case 2:
		return (QWALK_RETURN);
d533 1
a533 1
	return (-1);
@


1.50
log
@When creating an envelope, check if the message is incoming or
queued to decide the path for the envelope. Remove the need to
check the envelope type.

ok gilles@@ chl@@
@
text
@d45 4
a48 3
static int	fsqueue_envelope_load(struct envelope *);
static int	fsqueue_envelope_update(struct envelope *);
static int	fsqueue_envelope_delete(struct envelope *);
d58 1
a58 1
static int	fsqueue_envelope_dump_atomic(char *, struct envelope *);
d62 1
a62 1
static int	fsqueue_envelope(enum queue_op , struct envelope *);
d110 1
a110 1
fsqueue_envelope_dump_atomic(char *dest, struct envelope *ep)
a113 2
	char	 evpbuf[sizeof(struct envelope)];
	size_t	 evplen;
a115 4
	evplen = envelope_dump_buffer(ep, evpbuf, sizeof evpbuf);
	if (evplen == 0)
		return (0);

d163 1
a163 1
fsqueue_envelope_create(struct envelope *ep)
a165 1
	uint64_t	evpid;
d170 1
a170 1
	msgid = evpid_to_msgid(ep->id);
d176 1
a176 1
		evpid = queue_generate_evpid(msgid);
d178 1
a178 1
			fsqueue_envelope_path(evpid, path, sizeof(path));
d180 1
a180 1
			queue_envelope_incoming_path(evpid, path, sizeof(path));
d187 2
a188 3
    found:
	ep->id = evpid;
	return (fsqueue_envelope_dump_atomic(path, ep));
d192 1
a192 1
fsqueue_envelope_load(struct envelope *ep)
a194 1
	char	 evpbuf[sizeof(struct envelope)];
d198 1
a198 1
	fsqueue_envelope_path(ep->id, pathname, sizeof(pathname));
d207 1
a207 1
	if ((r = read(fd, evpbuf, sizeof evpbuf)) == -1)
d212 1
a212 1
	return (envelope_load_buffer(ep, evpbuf, r));
d216 1
a216 1
fsqueue_envelope_update(struct envelope *ep)
d220 1
a220 1
	fsqueue_envelope_path(ep->id, dest, sizeof(dest));
d222 1
a222 1
	return (fsqueue_envelope_dump_atomic(dest, ep));
d226 1
a226 1
fsqueue_envelope_delete(struct envelope *ep)
d230 1
a230 1
	fsqueue_envelope_path(ep->id, pathname, sizeof(pathname));
d238 1
a238 1
		fsqueue_message_delete(evpid_to_msgid(ep->id));
d419 1
a419 1
fsqueue_envelope(enum queue_op qop, struct envelope *m)
d423 1
a423 1
		return fsqueue_envelope_create(m);
d426 1
a426 1
		return fsqueue_envelope_delete(m);
d429 1
a429 1
		return fsqueue_envelope_load(m);
d432 1
a432 1
		return fsqueue_envelope_update(m);
@


1.49
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.48 2012/08/19 10:32:32 chl Exp $	*/
d170 1
a170 1
	char		evpname[MAXPATHLEN];
d172 2
d176 11
a186 6
again:
	evpid = queue_generate_evpid(evpid_to_msgid(ep->id));
	if (ep->type == D_BOUNCE)
		fsqueue_envelope_path(evpid, evpname, sizeof(evpname));
	else
		queue_envelope_incoming_path(evpid, evpname, sizeof(evpname));
d188 6
a193 2
	if (stat(evpname, &sb) != -1 || errno != ENOENT)
		goto again;
d195 1
a195 2

	return (fsqueue_envelope_dump_atomic(evpname, ep));
@


1.48
log
@Kill envelope_{dump,load}_file() and replace them with envelope_{dump,load}_buffer().

with input from eric@@

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.47 2012/08/08 17:31:55 eric Exp $	*/
d49 5
a53 5
static int	fsqueue_message_create(u_int32_t *);
static int	fsqueue_message_commit(u_int32_t);
static int	fsqueue_message_fd_r(u_int32_t);
static int	fsqueue_message_delete(u_int32_t);
static int	fsqueue_message_corrupt(u_int32_t);
d56 1
a56 1
static int	fsqueue_envelope_path(u_int64_t, char *, size_t);
d60 1
a60 1
static int	fsqueue_message(enum queue_op, u_int32_t *);
d63 2
a64 2
static void    *fsqueue_qwalk_new(u_int32_t);
static int	fsqueue_qwalk(void *, u_int64_t *);
d171 1
a171 1
	u_int64_t	evpid;
d242 1
a242 1
fsqueue_message_create(u_int32_t *msgid)
d284 1
a284 1
fsqueue_message_commit(u_int32_t msgid)
d312 1
a312 1
fsqueue_message_fd_r(u_int32_t msgid)
d327 1
a327 1
fsqueue_message_delete(u_int32_t msgid)
d341 1
a341 1
fsqueue_message_corrupt(u_int32_t msgid)
d391 1
a391 1
fsqueue_message(enum queue_op qop, u_int32_t *msgid)
d449 1
a449 1
	u_int32_t msgid;
d455 1
a455 1
fsqueue_qwalk_new(u_int32_t msgid)
d485 1
a485 1
fsqueue_qwalk(void *hdl, u_int64_t *evpid)
d516 1
a516 1
		*evpid = (u_int64_t)strtoull(dp->d_name, &endptr, 16);
@


1.47
log
@cleanup some old debug traces

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.46 2012/07/10 23:21:34 chl Exp $	*/
d111 9
a119 2
	FILE	*fp;
	char	 buf[MAXPATHLEN];
d125 1
a125 1
	snprintf(buf, sizeof buf, PATH_EVPTMP".%d", getpid());
d127 1
a127 2
	fp = fopen(buf, "w");
	if (fp == NULL) {
d133 3
a135 1
	if (! envelope_dump_file(ep, fp)) {
d138 1
a138 1
		fatal("fsqueue_envelope_dump_atomic: fwrite");
d141 2
a142 1
	if (! safe_fclose(fp))
d144 5
a148 1
	fp = NULL;
d150 2
a151 1
	if (rename(buf, dest) == -1) {
d157 1
a157 1
	return 1;
d160 3
a162 3
	if (fp)
		fclose(fp);
	if (unlink(buf) == -1)
d164 1
a164 1
	return 0;
d191 4
a194 3
	char pathname[MAXPATHLEN];
	FILE *fp;
	int  ret;
d198 2
a199 2
	fp = fopen(pathname, "r");
	if (fp == NULL) {
d201 2
a202 2
			return 0;
		fatal("fsqueue_envelope_load: fopen");
a203 1
	ret = envelope_load_file(ep, fp);
d205 4
a208 1
	fclose(fp);
d210 1
a210 1
	return ret;
@


1.46
log
@backout the:
- remove the /envelopes subdirectory, envelopes are at the same level than
  the message file
- kill PATH_ENVELOPES define

but keep the:
- reduce the number of buckets from 0xfff to 0xff, this avoid performances
  of the queue to decrease when we start having tons of buckets

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.45 2012/07/09 08:08:29 gilles Exp $	*/
a210 2
	log_debug("#### %s: queue_envelope_delete: %016" PRIx64,
	    __func__, ep->id);
d213 1
a213 2
	if (unlink(pathname) == -1) {
		log_debug("######: %s [errno: %d]", pathname, errno);
a214 1
	}
@


1.45
log
@first step of simplifying fsqueue:

- remove the /envelopes subdirectory, envelopes are at the same level than
  the message file
- kill PATH_ENVELOPES define
- reduce the number of buckets from 0xfff to 0xff, this avoid performances
  of the queue to decrease when we start having tons of buckets

this diff introduces a change to the queue layout, you will want to empty
your queue before updating. more cleanup to come

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.44 2012/07/08 18:13:08 chl Exp $	*/
d101 1
a101 1
	return bsnprintf(buf, len, "%s/%02x/%08x/%016" PRIx64,
d104 2
a105 1
	    evpid_to_msgid(evpid), evpid);
a209 1
	struct stat	sb;
d211 2
d215 2
a216 1
	if (unlink(pathname) == -1)
d218 1
d222 2
a223 3
	if (stat(pathname, &sb) != -1)
		if (sb.st_nlink == 2)
			fsqueue_message_delete(evpid_to_msgid(ep->id));
d232 1
d254 13
d459 2
a460 2
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%02x/%08x/",
			PATH_QUEUE, q->bucket, q->msgid))
d566 3
a568 2
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%02x/%s",
			PATH_QUEUE, q->bucket & 0xff, fname))
@


1.44
log
@remove enum queue_kind from queue_fsqueue.c.
incoming messages are now always stored in /incoming, whatever the queue_backend is.
remove QOP_FD_RW and fsqueue_message_fd_rw().
while there check return value of generated paths before calling rmtree()

with advice from gilles@@ and eric@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.43 2012/07/02 13:22:14 eric Exp $	*/
d84 1
a84 1
	return bsnprintf(buf, len, "%s/%03x/%08x",
d86 1
a86 1
	    msgid & 0xfff,
d101 1
a101 1
	return bsnprintf(buf, len, "%s/%03x/%08x%s/%016" PRIx64,
d103 2
a104 3
	    evpid_to_msgid(evpid) & 0xfff,
	    evpid_to_msgid(evpid),
	    PATH_ENVELOPES, evpid);
d209 1
a210 2
	log_debug("#### %s: queue_envelope_delete: %016" PRIx64,
	    __func__, ep->id);
d213 1
a213 2
	if (unlink(pathname) == -1) {
		log_debug("######: %s [errno: %d]", pathname, errno);
a214 1
	}
d218 3
a220 2
	if (rmdir(pathname) != -1)
		fsqueue_message_delete(evpid_to_msgid(ep->id));
a228 1
	char evpdir[MAXPATHLEN];
a249 13

	strlcpy(evpdir, rootdir, sizeof(evpdir));
	strlcat(evpdir, PATH_ENVELOPES, sizeof(evpdir));

	if (mkdir(evpdir, 0700) == -1) {
		if (errno == ENOSPC) {
			rmdir(rootdir);
			*msgid = 0;
			return 0;
		}
		fatal("fsqueue_message_create: mkdir");
	}

d440 1
a440 1
		q->bucket = q->msgid & 0xfff;
d442 2
a443 2
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%03x/%08x/%s",
			PATH_QUEUE, q->bucket, q->msgid, PATH_ENVELOPES))
d544 2
a545 2
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%03x",
			PATH_QUEUE, q->bucket & 0xfff))
d549 2
a550 3
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%03x/%s%s",
			PATH_QUEUE, q->bucket & 0xfff, fname,
			PATH_ENVELOPES))
@


1.43
log
@make backend functions static.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.42 2012/06/20 20:45:23 eric Exp $	*/
d45 9
a53 16
enum queue_kind {
	Q_INCOMING,
	Q_QUEUE,
	Q_CORRUPT
};

static int	fsqueue_envelope_load(enum queue_kind, struct envelope *);
static int	fsqueue_envelope_update(enum queue_kind, struct envelope *);
static int	fsqueue_envelope_delete(enum queue_kind, struct envelope *);

static int	fsqueue_message_create(enum queue_kind, u_int32_t *);
static int	fsqueue_message_commit(enum queue_kind, u_int32_t);
static int	fsqueue_message_fd_r(enum queue_kind, u_int32_t);
static int	fsqueue_message_fd_rw(enum queue_kind, u_int32_t);
static int	fsqueue_message_delete(enum queue_kind, u_int32_t);
static int	fsqueue_message_corrupt(enum queue_kind, u_int32_t);
d55 2
a56 2
static int	fsqueue_message_path(enum queue_kind, uint32_t, char *, size_t);
static int	fsqueue_envelope_path(enum queue_kind, u_int64_t, char *, size_t);
a66 1
#define PATH_INCOMING		"/incoming"
a69 3
#define PATH_MESSAGE		"/message"
#define PATH_ENVELOPES		"/envelopes"

d82 1
a82 1
fsqueue_message_path(enum queue_kind qkind, uint32_t msgid, char *buf, size_t len)
d84 4
a87 15
	switch (qkind) {
	case Q_QUEUE:
		return bsnprintf(buf, len, "%s/%03x/%08x",
 		    PATH_QUEUE,
		    msgid & 0xfff,
		    msgid);
	case Q_INCOMING:
	case Q_CORRUPT:
		return bsnprintf(buf, len, "%s/%08x",
		    qkind == Q_INCOMING ? PATH_INCOMING : PATH_CORRUPT,
		    msgid);
	default:
		fatalx("fsqueue_message_path: unsupported queue kind.");
	}
	return (0);
d91 6
a96 18
fsqueue_envelope_path(enum queue_kind qkind, uint64_t evpid, char *buf, size_t len)
{
	switch (qkind) {
	case Q_QUEUE:
		return bsnprintf(buf, len, "%s/%03x/%08x%s/%016" PRIx64,
		    PATH_QUEUE,
		    evpid_to_msgid(evpid) & 0xfff,
		    evpid_to_msgid(evpid),
		    PATH_ENVELOPES, evpid);
	case Q_INCOMING:
	case Q_CORRUPT:
		return bsnprintf(buf, len, "%s/%08x%s/%016" PRIx64,
		    qkind == Q_INCOMING ? PATH_INCOMING : PATH_CORRUPT,
		    evpid_to_msgid(evpid),
		    PATH_ENVELOPES, evpid);
	default:
		fatalx("fsqueue_envelope_path: unsupported queue kind.");
	}
d98 8
a105 1
	return (0);
d154 1
a154 1
fsqueue_envelope_create(enum queue_kind qkind, struct envelope *ep)
d162 5
a166 1
	fsqueue_envelope_path(qkind, evpid, evpname, sizeof(evpname));
d175 1
a175 1
fsqueue_envelope_load(enum queue_kind qkind, struct envelope *ep)
d181 1
a181 1
	fsqueue_envelope_path(qkind, ep->id, pathname, sizeof(pathname));
d197 1
a197 1
fsqueue_envelope_update(enum queue_kind qkind, struct envelope *ep)
d201 1
a201 1
	fsqueue_envelope_path(qkind, ep->id, dest, sizeof(dest));
d207 1
a207 1
fsqueue_envelope_delete(enum queue_kind qkind, struct envelope *ep)
d213 1
a213 1
	fsqueue_envelope_path(qkind, ep->id, pathname, sizeof(pathname));
d223 1
a223 1
		fsqueue_message_delete(qkind, evpid_to_msgid(ep->id));
d229 1
a229 1
fsqueue_message_create(enum queue_kind qkind, u_int32_t *msgid)
d239 1
a239 1
	fsqueue_message_path(Q_QUEUE, *msgid, rootdir, sizeof(rootdir));
d243 1
a243 1
	fsqueue_message_path(qkind, *msgid, rootdir, sizeof(rootdir));
d271 1
a271 1
fsqueue_message_commit(enum queue_kind qkind, u_int32_t msgid)
d273 1
a273 1
	char rootdir[MAXPATHLEN];
d277 2
a278 2
	fsqueue_message_path(qkind, msgid, rootdir, sizeof(rootdir));
	fsqueue_message_path(Q_QUEUE, msgid, msgdir, sizeof(msgdir));
d289 1
a289 1
	if (rename(rootdir, msgdir) == -1) {
d299 1
a299 1
fsqueue_message_fd_r(enum queue_kind qkind, u_int32_t msgid)
d304 1
a304 1
	fsqueue_message_path(qkind, msgid, path, sizeof(path));
d314 1
a314 12
fsqueue_message_fd_rw(enum queue_kind qkind, u_int32_t msgid)
{
	char path[MAXPATHLEN];

	fsqueue_message_path(qkind, msgid, path, sizeof(path));
	strlcat(path, PATH_MESSAGE, sizeof(path));

	return open(path, O_CREAT|O_EXCL|O_RDWR, 0600);
}

static int
fsqueue_message_delete(enum queue_kind qkind, u_int32_t msgid)
d318 2
a319 1
	fsqueue_message_path(qkind, msgid, rootdir, sizeof(rootdir));
d328 1
a328 1
fsqueue_message_corrupt(enum queue_kind qkind, u_int32_t msgid)
d336 3
a338 2
	fsqueue_message_path(qkind, msgid, rootdir, sizeof(rootdir));
	fsqueue_message_path(Q_CORRUPT, msgid, corruptdir, sizeof(corruptdir));
d341 1
a341 1
		fsqueue_message_path(Q_CORRUPT, msgid, corruptdir, sizeof(corruptdir));
d357 1
a357 1
	char		*paths[] = { PATH_INCOMING, PATH_QUEUE, PATH_CORRUPT };
d361 1
a361 1
	if (!fsqueue_envelope_path(Q_QUEUE, 0, path, sizeof(path)))
a362 5
	if (!fsqueue_envelope_path(Q_INCOMING, 0, path, sizeof(path)))
		errx(1, "cannot store envelope path in %s", PATH_INCOMING);

	if (server)
		mvpurge(PATH_SPOOL PATH_INCOMING, PATH_SPOOL PATH_PURGE);
d382 1
a382 1
		return fsqueue_message_create(Q_INCOMING, msgid);
d385 1
a385 1
		return fsqueue_message_delete(Q_INCOMING, *msgid);
d388 1
a388 1
		return fsqueue_message_commit(Q_INCOMING, *msgid);
d391 1
a391 4
                return fsqueue_message_fd_r(Q_QUEUE, *msgid);

        case QOP_FD_RW:
                return fsqueue_message_fd_rw(Q_INCOMING, *msgid);
d394 1
a394 1
		return fsqueue_message_corrupt(Q_QUEUE, *msgid);
d408 1
a408 5
		/* currently, only bounce envelopes are created in queued
		 * messages
		 */
		return fsqueue_envelope_create(
		    m->type == D_BOUNCE ? Q_QUEUE : Q_INCOMING, m);
d411 1
a411 1
		return fsqueue_envelope_delete(Q_QUEUE, m);
d414 1
a414 1
		return fsqueue_envelope_load(Q_QUEUE, m);
d417 1
a417 1
		return fsqueue_envelope_update(Q_QUEUE, m);
@


1.42
log
@Finally get rid of the queue_kind enum in the queue API. Keep that
internally in fsqueue backend for now, and let the fsqueue_message()
and fsqueue_envelope() dispatchers do the right thing.

Based on a diff by chl@@

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.41 2012/06/01 11:42:34 eric Exp $	*/
d66 7
a72 9
int	fsqueue_init(int);
int	fsqueue_message(enum queue_op, u_int32_t *);
int	fsqueue_envelope(enum queue_op , struct envelope *);
int	fsqueue_load_envelope_ascii(FILE *, struct envelope *);
int	fsqueue_dump_envelope_ascii(FILE *, struct envelope *);

void   *fsqueue_qwalk_new(u_int32_t);
int	fsqueue_qwalk(void *, u_int64_t *);
void	fsqueue_qwalk_close(void *);
d385 1
a385 1
int
d414 1
a414 1
int
d443 1
a443 1
int
d483 1
a483 1
int walk_queue(struct qwalk *, char *);
d485 1
a485 1
void *
d515 1
a515 1
int
d575 1
a575 1
void
d589 1
a589 1
int
@


1.41
log
@on envelope creation, setup and reset the relevant envelope fields in
the wrapper function rather than in individual backends.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.40 2012/06/01 09:24:58 eric Exp $	*/
d45 5
a49 1
static char	*fsqueue_getpath(enum queue_kind);
d67 2
a68 2
int	fsqueue_message(enum queue_kind, enum queue_op, u_int32_t *);
int	fsqueue_envelope(enum queue_kind, enum queue_op , struct envelope *);
d72 1
a72 1
void   *fsqueue_qwalk_new(enum queue_kind, u_int32_t);
a93 19
static char *
fsqueue_getpath(enum queue_kind kind)
{
        switch (kind) {
        case Q_INCOMING:
                return (PATH_INCOMING);

        case Q_QUEUE:
                return (PATH_QUEUE);

        case Q_CORRUPT:
                return (PATH_CORRUPT);

        default:
		fatalx("queue_fsqueue_getpath: unsupported queue kind.");
        }
	return NULL;
}

d97 2
a98 1
	if (qkind == Q_QUEUE)
d100 1
a100 1
		    fsqueue_getpath(qkind),
d103 2
a104 1
	else
d106 1
a106 1
		    fsqueue_getpath(qkind),
d108 4
d117 2
a118 1
	if (qkind == Q_QUEUE)
d120 1
a120 1
		    fsqueue_getpath(qkind),
d124 2
a125 1
	else
d127 1
a127 1
		    fsqueue_getpath(qkind),
d130 5
d417 1
a417 1
fsqueue_message(enum queue_kind qkind, enum queue_op qop, u_int32_t *msgid)
d421 1
a421 1
		return fsqueue_message_create(qkind, msgid);
d424 1
a424 1
		return fsqueue_message_delete(qkind, *msgid);
d427 1
a427 1
		return fsqueue_message_commit(qkind, *msgid);
d430 1
a430 1
                return fsqueue_message_fd_r(qkind, *msgid);
d433 1
a433 1
                return fsqueue_message_fd_rw(qkind, *msgid);
d436 1
a436 1
		return fsqueue_message_corrupt(qkind, *msgid);
d446 1
a446 1
fsqueue_envelope(enum queue_kind qkind, enum queue_op qop, struct envelope *m)
d450 5
a454 1
		return fsqueue_envelope_create(qkind, m);
d457 1
a457 1
		return fsqueue_envelope_delete(qkind, m);
d460 1
a460 1
		return fsqueue_envelope_load(qkind, m);
d463 1
a463 1
		return fsqueue_envelope_update(qkind, m);
a476 1
	enum queue_kind kind;
d485 1
a485 3
int		walk_simple(struct qwalk *, char *);
int		walk_queue(struct qwalk *, char *);
int		walk_queue_nobucket(struct qwalk *, char *);
d488 1
a488 1
fsqueue_qwalk_new(enum queue_kind kind, u_int32_t msgid)
d496 1
a496 2
	strlcpy(q->path, fsqueue_getpath(kind),
	    sizeof(q->path));
a497 1
	q->kind = kind;
a498 1
	q->filefn = walk_simple;
d509 1
a509 6

	if (kind == Q_QUEUE)
		q->filefn = walk_queue;
	if (kind == Q_INCOMING)
		q->filefn = walk_queue_nobucket;

a590 7

int
walk_simple(struct qwalk *q, char *fname)
{
	return (QWALK_RETURN);
}

d608 1
a608 1
			fsqueue_getpath(q->kind), q->bucket & 0xfff))
d613 1
a613 1
			fsqueue_getpath(q->kind), q->bucket & 0xfff, fname,
a617 16
		return (QWALK_RETURN);
	}

	return (-1);
}

int
walk_queue_nobucket(struct qwalk *q, char *fname)
{
	switch (q->level) {
	case 0:
		if (! bsnprintf(q->path, sizeof(q->path), "%s/%s%s",
			fsqueue_getpath(q->kind), fname, PATH_ENVELOPES))
			fatalx("walk_queue_nobucket: snprintf");
		return (QWALK_RECURSE);
	case 1:
@


1.40
log
@move envelope dump/load functions to envelope.c

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.39 2012/03/07 22:54:49 gilles Exp $	*/
a189 1
	int		r;
a195 2

	ep->creation = time(NULL);
d198 1
a198 6
	if ((r = fsqueue_envelope_dump_atomic(evpname, ep)) == 0) {
		ep->creation = 0;
		ep->id = 0;
	}

	return (r);
@


1.39
log
@various reliability fixes:

- prevent queue_fsqueue from fatal() when it hits an ENOENT, it can happen
- change a bit the scheduler API to simplify it, fix runner accordingly

- we can't remove msg/batch from ramqueue while envelope is offloaded or
  it will cause a double, instead we add refcnt to both msg/batch and
  only free them when it hits 0
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.38 2012/01/31 21:05:26 gilles Exp $	*/
d158 1
a158 1
	if (! fsqueue_dump_envelope_ascii(fp, ep)) {
d224 1
a224 1
	ret = fsqueue_load_envelope_ascii(fp, ep);
a661 173
}

int
fsqueue_load_envelope_ascii(FILE *fp, struct envelope *ep)
{
	char *buf, *lbuf;
	char *field;
	size_t	len;
	enum envelope_field fields[] = {
		EVP_VERSION,
		EVP_ID,
		EVP_HOSTNAME,
		EVP_SOCKADDR,
		EVP_HELO,
		EVP_SENDER,
		EVP_RCPT,
		EVP_DEST,
		EVP_TYPE,
		EVP_CTIME,
		EVP_EXPIRE,
		EVP_RETRY,
		EVP_LASTTRY,
		EVP_FLAGS,
		EVP_ERRORLINE,
		EVP_MDA_METHOD,
		EVP_MDA_BUFFER,
		EVP_MDA_USER,
		EVP_MTA_RELAY_HOST,
		EVP_MTA_RELAY_PORT,
		EVP_MTA_RELAY_CERT,
		EVP_MTA_RELAY_FLAGS,
		EVP_MTA_RELAY_AUTHMAP
	};
	int	i;
	int	n;
	int	ret;

	n = sizeof(fields) / sizeof(enum envelope_field);
	bzero(ep, sizeof (*ep));
	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}

		for (i = 0; i < n; ++i) {
			field = envelope_ascii_field_name(fields[i]);
			len = strlen(field);
			if (! strncasecmp(field, buf, len)) {
				/* skip kw and tailing whitespaces */
				buf += len;
				while (*buf && isspace(*buf))
					buf++;

				/* we *want* ':' */
				if (*buf != ':')
					continue;
				buf++;

				/* skip whitespaces after separator */
				while (*buf && isspace(*buf))
				    buf++;

				ret = envelope_ascii_load(fields[i], ep, buf);
				if (ret == 0)
					goto err;
				break;
			}
		}

		/* unknown keyword */
		if (i == n)
			goto err;
	}
	free(lbuf);
	return 1;

err:
	free(lbuf);
	return 0;
}

int
fsqueue_dump_envelope_ascii(FILE *fp, struct envelope *ep)
{
	char	buf[8192];

	enum envelope_field fields[] = {
		EVP_VERSION,
		EVP_ID,
		EVP_TYPE,
		EVP_HELO,
		EVP_HOSTNAME,
		EVP_ERRORLINE,
		EVP_SOCKADDR,
		EVP_SENDER,
		EVP_RCPT,
		EVP_DEST,
		EVP_CTIME,
		EVP_LASTTRY,
		EVP_EXPIRE,
		EVP_RETRY,
		EVP_FLAGS
	};
	enum envelope_field mda_fields[] = {
		EVP_MDA_METHOD,
		EVP_MDA_BUFFER,
		EVP_MDA_USER
	};
	enum envelope_field mta_fields[] = {
		EVP_MTA_RELAY_HOST,
		EVP_MTA_RELAY_PORT,
		EVP_MTA_RELAY_CERT,
		EVP_MTA_RELAY_AUTHMAP,
		EVP_MTA_RELAY_FLAGS
	};
	enum envelope_field *pfields = NULL;
	int	i;
	int	n;

	n = sizeof(fields) / sizeof(enum envelope_field);
	for (i = 0; i < n; ++i) {
		bzero(buf, sizeof buf);
		if (! envelope_ascii_dump(fields[i], ep, buf, sizeof buf))
			goto err;
		if (buf[0] == '\0')
			continue;
		fprintf(fp, "%s: %s\n",
		    envelope_ascii_field_name(fields[i]), buf);
	}

	switch (ep->type) {
	case D_MDA:
		pfields = mda_fields;
		n = sizeof(mda_fields) / sizeof(enum envelope_field);
		break;
	case D_MTA:
		pfields = mta_fields;
		n = sizeof(mta_fields) / sizeof(enum envelope_field);
		break;
	case D_BOUNCE:
		/* nothing ! */
		break;
	default:
		goto err;
	}

	if (pfields) {
		for (i = 0; i < n; ++i) {
			bzero(buf, sizeof buf);
			if (! envelope_ascii_dump(pfields[i], ep, buf,
				sizeof buf))
				goto err;
			if (buf[0] == '\0')
				continue;
			fprintf(fp, "%s: %s\n",
			    envelope_ascii_field_name(pfields[i]), buf);
		}
	}

	if (fflush(fp) != 0)
		goto err;

	return 1;

err:
	return 0;
@


1.38
log
@fix an issue observed this week-end while flooding ajacoutot@@ :

we keep track of available fd's to prevent scheduling of messages if we
know that we are going to fail. however, since the envelope is not
removed from the scheduler, it will be rescheduled right away leading to
a busy loop in the scheduler. we know flag the mda/mta processes as BUSY
and do not schedule envelopes that target a BUSY process.

also, fix a potential bug that could lead to a use after free when doing
a batch/message/host traversal of schedulable envelopes.

while at it fix misuse of env->sc_opts as env->sc_flags, was not really
causing any issue as the misuse was constant ...
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.37 2012/01/29 16:54:13 eric Exp $	*/
a488 1
	int	  strict;
a509 1
	q->strict = 0;
a521 3
	if (smtpd_process == PROC_QUEUE || smtpd_process == PROC_RUNNER)
		q->strict = 1;

d585 1
a585 1
		if (errno == ENOENT && !q->strict) {
@


1.37
log
@Remove message directories right away instead of moving them to purge/.
Prevent hitting dir entry limits when dealing with lots of mails.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.36 2012/01/29 10:40:05 eric Exp $	*/
d246 2
@


1.36
log
@Quick fix to prevent two processes from using the same temporary
envelope file at the same time.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.35 2012/01/24 12:20:18 eric Exp $	*/
d364 2
a365 2
	if (mvpurge(rootdir, PATH_PURGE) == -1)
		fatal("fsqueue_message_delete: mvpurge");
@


1.35
log
@Add a parameter to the queue backend init() call to specify wether the
call is issued by smtpd or smtpctl.  In the latter case, only perform
sanity checks and do not touch directories.  A running server no
longer lose its "incoming/" directory each time smtpctl is called...

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.34 2012/01/14 19:35:31 eric Exp $	*/
d143 1
d145 7
a151 1
	fp = fopen(PATH_EVPTMP, "w");
d157 1
d163 1
d168 1
a168 1
	if (rename(PATH_EVPTMP, dest) == -1) {
d179 1
a179 1
	if (unlink(PATH_EVPTMP) == -1)
a180 1

@


1.34
log
@When moving a message to the corrupt/ directory, give it an alternate name
if there is already an entry with the same name.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.33 2012/01/14 12:56:49 eric Exp $	*/
d62 1
a62 1
int	fsqueue_init(void);
d388 1
a388 1
fsqueue_init(void)
d400 2
a401 1
	mvpurge(PATH_SPOOL PATH_INCOMING, PATH_SPOOL PATH_PURGE);
d409 1
a409 1
		if (ckdir(path, 0700, env->sc_pw->pw_uid, 0, 1) == 0)
@


1.33
log
@Change fsqueue_*_path() to report success or failure instead of
fatal(). Make sure at init time that all paths can contain envelopes,
then these calls will never fail (provided that buffers are always
correctly sized, which is true internally).

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.32 2012/01/14 10:48:47 eric Exp $	*/
d365 1
d368 2
d373 7
@


1.32
log
@When creating a new message (in incoming/) make sure that the msgid does not
already exist in queue/ to prevent possible collision on commit.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.31 2012/01/14 08:37:16 eric Exp $	*/
d45 1
a45 1
static char		*fsqueue_getpath(enum queue_kind);
d58 2
a59 1
static void	fsqueue_envelope_path(enum queue_kind, u_int64_t, char *, size_t);
d109 1
a109 1
static void
a111 2
	int r;

d113 1
a113 1
		r = bsnprintf(buf, len, "%s/%03x/%08x",
d118 1
a118 1
		r = bsnprintf(buf, len, "%s/%08x",
a120 5

	if (!r)
		fatalx("fsqueue_message_path: snprintf");

	log_debug("envelope path: %s", buf);
d123 1
a123 1
static void
a125 2
	int r;

d127 1
a127 1
		r = bsnprintf(buf, len, "%s/%03x/%08x%s/%016" PRIx64,
d133 1
a133 1
		r = bsnprintf(buf, len, "%s/%08x%s/%016" PRIx64,
a136 5

	if (!r)
		fatalx("fsqueue_envelope_path: snprintf");

	log_debug("envelope path: %s", buf);
d384 5
@


1.31
log
@Add a fsqueue_message_path() function to build path to message dir
and use it where appropriate.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.30 2012/01/13 22:01:23 eric Exp $	*/
d271 1
d275 6
a281 1

@


1.30
log
@use a simpler way to get to the parent directory

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.29 2012/01/13 21:58:35 eric Exp $	*/
d109 21
d274 1
a274 3
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%08x",
		fsqueue_getpath(qkind), *msgid))
		fatalx("fsqueue_message_create: snprintf");
d287 2
a288 3
	if (! bsnprintf(evpdir, sizeof(evpdir), "%s%s", rootdir,
		PATH_ENVELOPES))
		fatalx("fsqueue_message_create: snprintf");
d308 5
a312 8
	
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%08x",
		fsqueue_getpath(qkind), msgid))
		fatal("fsqueue_message_commit: snprintf");

	if (! bsnprintf(queuedir, sizeof(queuedir), "%s/%03x",
		fsqueue_getpath(Q_QUEUE), msgid & 0xfff))
		fatal("fsqueue_message_commit: snprintf");
a320 4
	if (! bsnprintf(msgdir, sizeof(msgdir),"%s/%08x",
		queuedir, msgid))
		fatal("fsqueue_message_commit: snprintf");

d334 1
a334 1
	char pathname[MAXPATHLEN];
d336 2
a337 10
	if (qkind == Q_INCOMING) {
		if (! bsnprintf(pathname, sizeof(pathname), "%s/%08x/message",
			fsqueue_getpath(qkind), msgid))
			fatal("fsqueue_message_fd_r: snprintf");
	}
	else {
		if (! bsnprintf(pathname, sizeof(pathname), "%s/%03x/%08x/message",
			fsqueue_getpath(qkind), msgid & 0xfff, msgid))
			fatal("fsqueue_message_fd_r: snprintf");
	}
d339 1
a339 1
	if ((fd = open(pathname, O_RDONLY)) == -1)
d348 4
a351 6
	char pathname[MAXPATHLEN];
	
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%08x/message",
		fsqueue_getpath(qkind),
		msgid))
		fatal("fsqueue_message_fd_rw: snprintf");
d353 1
a353 1
	return open(pathname, O_CREAT|O_EXCL|O_RDWR, 0600);
d361 1
a361 9
	if (qkind == Q_QUEUE) {
		if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%03x/%08x",
			fsqueue_getpath(qkind), msgid & 0xfff, msgid))
			fatal("fsqueue_message_delete: snprintf");
	} else {
		if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%08x",
			fsqueue_getpath(qkind), msgid))
			fatalx("fsqueue_message_delete: snprintf");
	}
d375 2
a376 7
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%03x/%08x",
		fsqueue_getpath(qkind), msgid & 0xfff, msgid))
		fatalx("fsqueue_message_corrupt: snprintf");

	if (! bsnprintf(corruptdir, sizeof(corruptdir), "%s/%08x",
		fsqueue_getpath(Q_CORRUPT), msgid))
		fatalx("fsqueue_message_corrupt: snprintf");
a382 1

@


1.29
log
@queue_message_purge() and queue_message_delete() are actually the same
thing. Remove queue_message_purge() in favor of queue_message_delete
and simplify fsqueue_message_delete() implementation to move the
message dir to purge/

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.28 2012/01/12 17:00:56 eric Exp $	*/
d237 1
a237 4
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%03x/%08x%s", PATH_QUEUE,
		evpid_to_msgid(ep->id) & 0xfff,
		evpid_to_msgid(ep->id), PATH_ENVELOPES))
		fatal("fsqueue_envelope_delete: snprintf");
@


1.28
log
@Add a fsqueue_envelope_dump_atomic() function that writes an envelope
to incoming/envelope.tmp before moving it to its final destination.
This allows to make sure that envelopes created directly in the queue
(such as bounces) can't let the queue in an inconsistent state if
the program stops in the middle of an envelope dump.

This also allow to simplify qwalk, since we don't put any temporary
contents anywhere in "walkable" queue dirs.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.27 2012/01/11 22:24:37 gilles Exp $	*/
a55 1
static int	fsqueue_message_purge(enum queue_kind, u_int32_t);
a361 4
	char evpdir[MAXPATHLEN];
	char msgpath[MAXPATHLEN];
	DIR *dirp;
	struct dirent *dp;
d364 2
a365 2
		if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%03x/%08x", PATH_QUEUE,
			msgid & 0xfff, msgid))
d367 4
a372 56
	if (! bsnprintf(evpdir, sizeof(evpdir), "%s%s", rootdir,
		PATH_ENVELOPES))
		fatal("fsqueue_message_delete: snprintf");

	dirp = opendir(evpdir);
	if (dirp) {
		char envelope[MAXPATHLEN];

		while ((dp = readdir(dirp)) != NULL) {
			if (! bsnprintf(envelope, MAXPATHLEN, "%s/%s",
				evpdir, dp->d_name))
				fatal("fsqueue_message_delete: truncated evp");
			unlink(envelope);
		}
		closedir(dirp);
	}

	if (! bsnprintf(msgpath, sizeof(msgpath), "%s/message", rootdir))
		fatal("fsqueue_message_delete: snprintf");

	if (unlink(msgpath) == -1) {
		if (errno != ENOENT)
			fatal("fsqueue_message_delete: unlink");
	}

	if (rmdir(evpdir) == -1) {
		/* It is ok to fail rmdir with ENOENT here
		 * because upon successful delivery of the
		 * last envelope, we remove the directory.
		 */
		if (errno != ENOENT)
			fatal("fsqueue_message_delete: rmdir");
	}

	if (rmdir(rootdir) == -1)
		fatal("#2 fsqueue_message_delete: rmdir");


	if (qkind == Q_QUEUE) {
		if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%03x", PATH_QUEUE, msgid & 0xffff))
			fatal("fsqueue_message_delete: snprintf");
		rmdir(rootdir);
	}

	return 1;
}

static int
fsqueue_message_purge(enum queue_kind qkind, u_int32_t msgid)
{
	char rootdir[MAXPATHLEN];

	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%08x",
		fsqueue_getpath(qkind), msgid))
		fatalx("fsqueue_message_purge: snprintf");

d374 1
a374 1
		fatal("fsqueue_message_purge: mvpurge");
a440 3

	case QOP_PURGE:
		return fsqueue_message_purge(qkind, *msgid);
@


1.27
log
@implement an envelope_ascii API that's not tied to a specific queue_backend
simplify queue_fsqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.26 2012/01/11 17:46:36 eric Exp $	*/
d60 1
d79 1
d133 1
a133 1
fsqueue_envelope_create(enum queue_kind qkind, struct envelope *ep)
d135 1
a135 4
	char evpname[MAXPATHLEN];
	FILE *fp;
	int fd;
	u_int64_t evpid;
d137 2
a138 11
	fp = NULL;

again:
	evpid = queue_generate_evpid(evpid_to_msgid(ep->id));

	fsqueue_envelope_path(qkind, evpid, evpname, sizeof(evpname));

	fd = open(evpname, O_WRONLY|O_CREAT|O_EXCL, 0600);
	if (fd == -1) {
		if (errno == EEXIST)
			goto again;
d141 1
a141 1
		fatal("fsqueue_envelope_create: open");
a142 8

	fp = fdopen(fd, "w");
	if (fp == NULL)
		fatal("fsqueue_envelope_create: fdopen");
 
	ep->creation = time(NULL);
	ep->id = evpid;

d146 1
a146 1
		fatal("fsqueue_dump_envelope_ascii: write");
d148 3
d152 4
a155 4
	if (! safe_fclose(fp)) {
		fp = NULL;
		fd = -1;
		goto tempfail;
a160 1
	unlink(evpname);
d163 2
a164 4
	else if (fd != -1)
		close(fd);
	ep->creation = 0;
	ep->id = 0;
d170 25
a218 1
	char temp[MAXPATHLEN];
a219 4
	FILE *fp;

	if (! bsnprintf(temp, sizeof(temp), "%s/envelope.tmp", PATH_QUEUE))
		fatalx("fsqueue_envelope_update");
d223 1
a223 29
	fp = fopen(temp, "w");
	if (fp == NULL) {
		if (errno == ENOSPC || errno == ENFILE)
			goto tempfail;
		fatal("fsqueue_envelope_update: open");
	}
	if (! fsqueue_dump_envelope_ascii(fp, ep)) {
		if (errno == ENOSPC)
			goto tempfail;
		fatal("fsqueue_dump_envelope_ascii: fwrite");
	}
	if (! safe_fclose(fp))
		goto tempfail;

	if (rename(temp, dest) == -1) {
		if (errno == ENOSPC)
			goto tempfail;
		fatal("fsqueue_envelope_update: rename");
	}

	return 1;

tempfail:
	if (unlink(temp) == -1)
		fatal("fsqueue_envelope_update: unlink");
	if (fp)
		fclose(fp);

	return 0;
a476 5
	if (! bsnprintf(path, sizeof path, "%s/envelope.tmp", PATH_QUEUE))
		errx(1, "path too long %s/envelope.tmp", PATH_QUEUE);

	unlink(path);

a683 3
		if (strcmp(fname, "envelope.tmp") == 0)
			return (QWALK_AGAIN);

a714 2
		if (strcmp(fname, "envelope.tmp") == 0)
			return (QWALK_AGAIN);
@


1.26
log
@Simplify runner/queue by getting rid of Q_PURGE.  Instead, let smtpd
periodically clear the purge/ directory.  At init time, the fsqueue
backend simply moves the existing incoming/ dir in purge/ to discard
aborted sessions.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.25 2011/12/27 17:13:05 eric Exp $	*/
d26 1
d760 173
@


1.25
log
@Q_BOUNCE is not used anymore

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.24 2011/12/23 12:10:06 eric Exp $	*/
a71 1
#define PATH_PURGE		"/purge"
a96 3
        case Q_PURGE:
                return (PATH_PURGE);

a397 5
	else if (qkind == Q_PURGE) {
		if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%08x", PATH_PURGE,
			msgid))
			fatal("fsqueue_message_delete: snprintf");
	}
a449 1
	char purgedir[MAXPATHLEN];
d455 2
a456 6
	if (! bsnprintf(purgedir, sizeof(purgedir), "%s/%08x",
		fsqueue_getpath(Q_PURGE), msgid))
		fatalx("fsqueue_message_purge: snprintf");

	if (rename(rootdir, purgedir) == -1)
		fatal("fsqueue_message_purge: rename");
d486 1
a486 2
	char		*paths[] = { PATH_INCOMING, PATH_QUEUE,
				     PATH_PURGE, PATH_CORRUPT };
d490 2
d616 1
a616 1
	if (kind == Q_INCOMING || kind == Q_PURGE)
@


1.24
log
@On envelope creation, get the message id in a saner way than the
current confusing hack.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.23 2011/12/22 18:41:30 eric Exp $	*/
a73 1
#define PATH_BOUNCE		"/bounce"
a100 3
        case Q_BOUNCE:
                return (PATH_BOUNCE);

a163 5
	if (qkind == Q_BOUNCE) {
		ep->lasttry = 0;
		ep->retry = 0;
	}

a282 6
	char *queuepath = fsqueue_getpath(qkind);
	char msgpath[MAXPATHLEN];
	char lnkpath[MAXPATHLEN];
	u_int32_t msgid_save;

	msgid_save = *msgid;
d287 1
a287 1
		queuepath, *msgid))
a313 15
	if (qkind == Q_BOUNCE) {
		if (! bsnprintf(msgpath, sizeof(msgpath), "%s/%03x/%08x/message",
			fsqueue_getpath(Q_QUEUE),
			msgid_save & 0xfff,
			msgid_save))
			return 0;

		if (! bsnprintf(lnkpath, sizeof(lnkpath), "%s/%08x/message",
			fsqueue_getpath(Q_BOUNCE), *msgid))
			return 0;
		
		if (link(msgpath, lnkpath) == -1)
			fatal("link");
	}

d501 1
a501 1
				     PATH_PURGE, PATH_BOUNCE, PATH_CORRUPT };
@


1.23
log
@Add fqueue_envelope_path() function to create path to envelopes.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.22 2011/12/14 17:55:55 eric Exp $	*/
d148 1
a148 1
	evpid = queue_generate_evpid(ep->id);
@


1.22
log
@make queue_fsqueue backend consistent with the backend scheme.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.21 2011/11/21 18:57:54 eric Exp $	*/
d58 2
d114 23
d150 1
a150 5
	if (! bsnprintf(evpname, sizeof(evpname), "%s/%08x%s/%016" PRIx64,
		fsqueue_getpath(qkind),
		evpid_to_msgid(evpid),
		PATH_ENVELOPES, evpid))
		fatalx("fsqueue_envelope_create: snprintf");
d206 1
a206 6
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%03x/%08x%s/%016" PRIx64,
		fsqueue_getpath(qkind),
		evpid_to_msgid(ep->id) & 0xfff,
		evpid_to_msgid(ep->id),
		PATH_ENVELOPES, ep->id))
		fatalx("fsqueue_envelope_load: snprintf");
d231 1
a231 6
	if (! bsnprintf(dest, sizeof(dest), "%s/%03x/%08x%s/%016" PRIx64,
		fsqueue_getpath(qkind),
		evpid_to_msgid(ep->id) & 0xfff,
		evpid_to_msgid(ep->id),
		PATH_ENVELOPES, ep->id))
		fatal("fsqueue_envelope_update: snprintf");
d269 1
a269 7
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%03x/%08x%s/%016" PRIx64,
		fsqueue_getpath(qkind),
		evpid_to_msgid(ep->id) & 0xfff,
		evpid_to_msgid(ep->id),
		PATH_ENVELOPES,
		ep->id))
		fatal("fsqueue_envelope_delete: snprintf");
@


1.21
log
@get rid of the "enqueue/" queue; use "incoming/" instead.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.20 2011/11/15 23:12:44 gilles Exp $	*/
d77 9
@


1.20
log
@wooooops defines missing from previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.19 2011/11/15 23:06:39 gilles Exp $	*/
a67 1
#define PATH_ENQUEUE		"/enqueue"
a84 3
        case Q_ENQUEUE:
                return (PATH_ENQUEUE);

d374 1
a374 1
	if (qkind == Q_ENQUEUE || qkind == Q_INCOMING) {
d516 1
a516 1
	char		*paths[] = { PATH_INCOMING, PATH_ENQUEUE, PATH_QUEUE,
d645 1
a645 1
	if (kind == Q_INCOMING || kind == Q_ENQUEUE || kind == Q_PURGE)
@


1.19
log
@Qwalk, our API to linearly walk over the persistent queue, did not take the
queue_backend into account and assumed a filesystem with a specific layout.

This commit does plenty of things:

- make qwalk an abstraction in the queue_backend API, and impose queue
  drivers to implement qwalk_open(), qwalk() and qwalk_close();

- move previous qwalk_open(), qwalk() and qwalk_close() to the fsqueue
  driver since they were fsqueue specific ...

- make qwalk API work with msgid/evpid instead of pathnames since we're
  going to use the queue_backend API to load envelopes by evpid anyway;

- makes smtpd use *solely* the queue_backend API when manipulating the
  queue. pathnames were removed from smtpd.h and moved into the fsqueue
  which means we can now store a queue anywhere ... as long as we write
  the ten functions or so required for a queue driver ;-)

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.18 2011/11/14 11:53:10 eric Exp $	*/
a42 1
#include "queue_fsqueue.h"
d67 11
@


1.18
log
@The spool and offline directories are backend-independent, so they
must be created early by smtpd, rather than in fsqueue.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.17 2011/11/06 16:57:27 eric Exp $	*/
d26 1
d43 1
a61 1

d65 4
a84 3
        case Q_OFFLINE:
                return (PATH_OFFLINE);

a102 1
	u_int32_t rnd;
d108 1
a108 4
	rnd = (u_int32_t)arc4random();
	if (rnd == 0)
		goto again;
	evpid = ep->id | rnd;
d280 1
a280 1
	*msgid = (u_int32_t)arc4random();
d404 2
d407 10
a416 3
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%03x/%08x", PATH_QUEUE,
		msgid & 0xfff, msgid))
		fatal("queue_delete_message: snprintf");
d420 15
a434 2
		fatal("queue_delete_message: snprintf");
	
d436 1
a436 1
		fatal("queue_delete_message: snprintf");
d438 4
a441 2
	if (unlink(msgpath) == -1)
		fatal("queue_delete_message: unlink");
d449 1
a449 1
			fatal("queue_delete_message: rmdir");
d453 1
a453 1
		fatal("#2 queue_delete_message: rmdir");
a454 2
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%03x", PATH_QUEUE, msgid & 0xffff))
		fatal("queue_delete_message: snprintf");
d456 5
a460 1
	rmdir(rootdir);
d524 6
d586 196
@


1.17
log
@No need to save/restore the batch_id since the envelope is not dumped
as a structure anymore.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.16 2011/10/27 14:32:57 chl Exp $	*/
d487 2
a488 4
				     PATH_PURGE, PATH_OFFLINE, PATH_BOUNCE,
				     PATH_CORRUPT };
	char		 pathname[MAXPATHLEN];
	struct stat	 sb;
a490 43
	if (! bsnprintf(pathname, sizeof(pathname), "%s", PATH_SPOOL))
		fatal("snprintf");

	if (stat(pathname, &sb) == -1) {
		if (errno != ENOENT) {
			warn("stat: %s", pathname);
			return 0;
		}

		if (mkdir(pathname, 0711) == -1) {
			warn("mkdir: %s", pathname);
			return 0;
		}

		if (chown(pathname, 0, 0) == -1) {
			warn("chown: %s", pathname);
			return 0;
		}

		if (stat(pathname, &sb) == -1)
			err(1, "stat: %s", pathname);
	}

	/* check if it's a directory */
	if (!S_ISDIR(sb.st_mode)) {
		warnx("%s is not a directory", pathname);
		return 0;
	}

	/* check that it is owned by uid/gid */
	if (sb.st_uid != 0 || sb.st_gid != 0) {
		warnx("%s must be owned by root:wheel", pathname);
		return 0;
	}

	/* check permission */
	if ((sb.st_mode & (S_IRUSR|S_IWUSR|S_IXUSR)) != (S_IRUSR|S_IWUSR|S_IXUSR) ||
	    (sb.st_mode & (S_IRGRP|S_IWGRP|S_IXGRP)) != S_IXGRP ||
	    (sb.st_mode & (S_IROTH|S_IWOTH|S_IXOTH)) != S_IXOTH) {
		warnx("%s must be rwx--x--x (0711)", pathname);
		return 0;
	}

d493 3
a495 64
		mode_t	mode;
		uid_t	owner;
		gid_t	group;

		if (!strcmp(paths[n], PATH_OFFLINE)) {
			mode = 01777;
			owner = 0;
			group = 0;
		} else {
			mode = 0700;
			owner = env->sc_pw->pw_uid;
			group = 0;
		}

		if (! bsnprintf(pathname, sizeof(pathname), "%s%s", PATH_SPOOL,
			paths[n]))
			fatal("snprintf");

		if (stat(pathname, &sb) == -1) {
			if (errno != ENOENT) {
				warn("stat: %s", pathname);
				ret = 0;
				continue;
			}

			/* chmod is deffered to avoid umask effect */
			if (mkdir(pathname, 0) == -1) {
				ret = 0;
				warn("mkdir: %s", pathname);
			}

			if (chown(pathname, owner, group) == -1) {
				ret = 0;
				warn("chown: %s", pathname);
			}

			if (chmod(pathname, mode) == -1) {
				ret = 0;
				warn("chmod: %s", pathname);
			}

			if (stat(pathname, &sb) == -1)
				err(1, "stat: %s", pathname);
		}

		/* check if it's a directory */
		if (!S_ISDIR(sb.st_mode)) {
			ret = 0;
			warnx("%s is not a directory", pathname);
		}

		/* check that it is owned by owner/group */
		if (sb.st_uid != owner) {
			ret = 0;
			warnx("%s is not owned by uid %d", pathname, owner);
		}
		if (sb.st_gid != group) {
			ret = 0;
			warnx("%s is not owned by gid %d", pathname, group);
		}

		/* check permission */
		if ((sb.st_mode & 07777) != mode) {
			char mode_str[12];
d497 1
a498 4
			strmode(mode, mode_str);
			mode_str[10] = '\0';
			warnx("%s must be %s (%o)", pathname, mode_str + 1, mode);
		}
@


1.16
log
@Use PRI{x,d}64 in format strings instead of %llx, %lld or %qd to print {u_,}int64_t or time_t

While there, cast some time_t to int64_t

These will fix build warnings for portable smptd

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.15 2011/10/23 13:03:05 gilles Exp $	*/
a197 4
	u_int64_t batch_id;

	batch_id = ep->batch_id;
	ep->batch_id = 0;
a228 1
	ep->batch_id = batch_id;
a236 1
	ep->batch_id = batch_id;
@


1.15
log
@introduce Q_CORRUPT and queue_backend operation to move a message from
schedule queue to corrupt queue upon envelope loading failure.

tested by me, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.14 2011/10/23 09:30:07 gilles Exp $	*/
d31 1
d112 1
a112 1
	if (! bsnprintf(evpname, sizeof(evpname), "%s/%08x%s/%016llx",
d172 1
a172 1
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%03x/%08x%s/%016llx",
d206 1
a206 1
	if (! bsnprintf(dest, sizeof(dest), "%s/%03x/%08x%s/%016llx",
d251 1
a251 1
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%03x/%08x%s/%016llx",
@


1.14
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.13 2011/08/26 14:39:47 chl Exp $	*/
d54 1
d85 3
d169 1
d184 2
a185 2
	if (! fsqueue_load_envelope_ascii(fp, ep))
		fatal("fsqueue_load_envelope_ascii: fread");
d187 2
a188 1
	return 1;
d466 20
d492 2
a493 1
				     PATH_PURGE, PATH_OFFLINE, PATH_BOUNCE };
d638 3
@


1.13
log
@add missing header needed by time()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.12 2011/05/16 21:05:52 gilles Exp $	*/
a42 1
/*static*/ u_int16_t	 fsqueue_hash(u_int32_t);
d59 3
a89 6
/*static*/ u_int16_t
fsqueue_hash(u_int32_t h)
{
        return (h % DIRHASH_BUCKETS);
}

d105 1
a105 2
	evpid = ep->delivery.id | rnd;

d125 3
a127 3

	ep->delivery.creation = time(NULL);
	ep->delivery.id = evpid;
d130 2
a131 2
		ep->delivery.lasttry = 0;
		ep->delivery.retry = 0;
d134 1
a134 1
	if (fwrite(ep, sizeof (*ep), 1, fp) != 1) {
d137 1
a137 1
		fatal("fsqueue_envelope_create: write");
d154 2
a155 2
	ep->delivery.creation = 0;
	ep->delivery.id = 0;
d166 1
a166 1
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%04x/%08x%s/%016llx",
d168 3
a170 3
		fsqueue_hash(evpid_to_msgid(ep->delivery.id)),
		evpid_to_msgid(ep->delivery.id),
		PATH_ENVELOPES, ep->delivery.id))
d179 2
a180 2
	if (fread(ep, sizeof (*ep), 1, fp) != 1)
		fatal("fsqueue_envelope_load: fread");
d199 1
a199 1
	if (! bsnprintf(dest, sizeof(dest), "%s/%04x/%08x%s/%016llx",
d201 3
a203 3
		fsqueue_hash(evpid_to_msgid(ep->delivery.id)),
		evpid_to_msgid(ep->delivery.id),
		PATH_ENVELOPES, ep->delivery.id))
d212 1
a212 1
	if (fwrite(ep, sizeof (*ep), 1, fp) != 1) {
d215 1
a215 1
		fatal("fsqueue_envelope_update: fwrite");
a242 3
	u_int16_t hval;

	hval = fsqueue_hash(evpid_to_msgid(ep->delivery.id));
d244 1
a244 1
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%04x/%08x%s/%016llx",
d246 2
a247 2
		hval,
		evpid_to_msgid(ep->delivery.id),
d249 1
a249 1
		ep->delivery.id))
d252 2
a253 1
	if (unlink(pathname) == -1)
d255 1
d257 3
a259 2
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%04x/%08x%s", PATH_QUEUE,
		hval, evpid_to_msgid(ep->delivery.id), PATH_ENVELOPES))
d263 1
a263 1
		fsqueue_message_delete(qkind, evpid_to_msgid(ep->delivery.id));
d311 1
a311 1
		if (! bsnprintf(msgpath, sizeof(msgpath), "%s/%04x/%08x/message",
d313 1
a313 1
			fsqueue_hash(msgid_save),
d339 2
a340 2
	if (! bsnprintf(queuedir, sizeof(queuedir), "%s/%04x",
		fsqueue_getpath(Q_QUEUE), fsqueue_hash(msgid)))
d342 1
a342 1
	
a367 1
	u_int16_t hval;
d375 2
a376 3
		hval = fsqueue_hash(msgid);
		if (! bsnprintf(pathname, sizeof(pathname), "%s/%04x/%08x/message",
			fsqueue_getpath(qkind), hval, msgid))
a404 1
	u_int16_t hval;
d406 2
a407 3
	hval = fsqueue_hash(msgid);
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%04x/%08x", PATH_QUEUE,
		hval, msgid))
d432 1
a432 1
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%04x", PATH_QUEUE, hval))
@


1.12
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.11 2011/05/01 12:57:11 eric Exp $	*/
d36 1
@


1.11
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.10 2011/04/17 11:39:22 gilles Exp $	*/
d94 1
a94 1
fsqueue_envelope_create(enum queue_kind qkind, struct envelope *m)
d108 2
a109 1
	evpid = m->evpid | rnd;
d130 2
a131 2
	m->creation = time(NULL);
	m->evpid = evpid;
d134 2
a135 2
		m->lasttry = 0;
		m->retry = 0;
d138 1
a138 1
	if (fwrite(m, sizeof (*m), 1, fp) != 1) {
d158 2
a159 2
	m->creation = 0;
	m->evpid = 0;
d165 1
a165 1
fsqueue_envelope_load(enum queue_kind qkind, struct envelope *m)
d172 3
a174 3
		fsqueue_hash(evpid_to_msgid(m->evpid)),
		evpid_to_msgid(m->evpid),
		PATH_ENVELOPES, m->evpid))
d183 1
a183 1
	if (fread(m, sizeof(*m), 1, fp) != 1)
d190 1
a190 1
fsqueue_envelope_update(enum queue_kind qkind, struct envelope *m)
d197 2
a198 2
	batch_id = m->batch_id;
	m->batch_id = 0;
d205 3
a207 3
		fsqueue_hash(evpid_to_msgid(m->evpid)),
		evpid_to_msgid(m->evpid),
		PATH_ENVELOPES, m->evpid))
d216 1
a216 1
	if (fwrite(m, sizeof(*m), 1, fp) != 1) {
d230 1
a230 1
	m->batch_id = batch_id;
d239 1
a239 1
	m->batch_id = batch_id;
d244 1
a244 1
fsqueue_envelope_delete(enum queue_kind qkind, struct envelope *m)
d249 1
a249 1
	hval = fsqueue_hash(evpid_to_msgid(m->evpid));
d254 1
a254 1
		evpid_to_msgid(m->evpid),
d256 1
a256 1
		m->evpid))
d263 1
a263 1
		hval, evpid_to_msgid(m->evpid), PATH_ENVELOPES))
d267 1
a267 1
		fsqueue_message_delete(qkind, evpid_to_msgid(m->evpid));
@


1.10
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.9 2011/04/16 09:13:38 gilles Exp $	*/
d44 14
a57 16
static int	fsqueue_envelope_load(struct smtpd *, enum queue_kind, struct envelope *);
static int	fsqueue_envelope_update(struct smtpd *, enum queue_kind, struct envelope *);
static int	fsqueue_envelope_delete(struct smtpd *, enum queue_kind, struct envelope *);

static int	fsqueue_message_create(struct smtpd *, enum queue_kind, u_int32_t *);
static int	fsqueue_message_commit(struct smtpd *, enum queue_kind, u_int32_t);
static int	fsqueue_message_fd_r(struct smtpd *, enum queue_kind, u_int32_t);
static int	fsqueue_message_fd_rw(struct smtpd *, enum queue_kind, u_int32_t);
static int	fsqueue_message_delete(struct smtpd *, enum queue_kind, u_int32_t);
static int	fsqueue_message_purge(struct smtpd *, enum queue_kind, u_int32_t);

int	fsqueue_init(struct smtpd *);
int	fsqueue_message(struct smtpd *, enum queue_kind,
    enum queue_op, u_int32_t *);
int	fsqueue_envelope(struct smtpd *, enum queue_kind,
    enum queue_op , struct envelope *);
d94 1
a94 2
fsqueue_envelope_create(struct smtpd *env, enum queue_kind qkind,
    struct envelope *m)
d164 1
a164 2
fsqueue_envelope_load(struct smtpd *env, enum queue_kind qkind,
    struct envelope *m)
d189 1
a189 2
fsqueue_envelope_update(struct smtpd *env, enum queue_kind qkind,
    struct envelope *m)
d243 1
a243 2
fsqueue_envelope_delete(struct smtpd *env, enum queue_kind qkind,
    struct envelope *m)
d266 1
a266 1
		fsqueue_message_delete(env, qkind, evpid_to_msgid(m->evpid));
d272 1
a272 1
fsqueue_message_create(struct smtpd *env, enum queue_kind qkind, u_int32_t *msgid)
d332 1
a332 1
fsqueue_message_commit(struct smtpd *env, enum queue_kind qkind, u_int32_t msgid)
d367 1
a367 1
fsqueue_message_fd_r(struct smtpd *env, enum queue_kind qkind, u_int32_t msgid)
d392 1
a392 1
fsqueue_message_fd_rw(struct smtpd *env, enum queue_kind qkind, u_int32_t msgid)
d405 1
a405 1
fsqueue_message_delete(struct smtpd *env, enum queue_kind qkind, u_int32_t msgid)
d448 1
a448 1
fsqueue_message_purge(struct smtpd *env, enum queue_kind qkind, u_int32_t msgid)
d469 1
a469 1
fsqueue_init(struct smtpd *env)
d598 1
a598 2
fsqueue_message(struct smtpd *env, enum queue_kind qkind,
    enum queue_op qop, u_int32_t *msgid)
d602 1
a602 1
		return fsqueue_message_create(env, qkind, msgid);
d605 1
a605 1
		return fsqueue_message_delete(env, qkind, *msgid);
d608 1
a608 1
		return fsqueue_message_commit(env, qkind, *msgid);
d611 1
a611 1
                return fsqueue_message_fd_r(env, qkind, *msgid);
d614 1
a614 1
                return fsqueue_message_fd_rw(env, qkind, *msgid);
d617 1
a617 1
		return fsqueue_message_purge(env, qkind, *msgid);
d627 1
a627 2
fsqueue_envelope(struct smtpd *env, enum queue_kind qkind,
    enum queue_op qop, struct envelope *m)
d631 1
a631 1
		return fsqueue_envelope_create(env, qkind, m);
d634 1
a634 1
		return fsqueue_envelope_delete(env, qkind, m);
d637 1
a637 1
		return fsqueue_envelope_load(env, qkind, m);
d640 1
a640 1
		return fsqueue_envelope_update(env, qkind, m);
@


1.9
log
@I accidentally changed group ownership of fsqueue to _smtpd, it used to be
owned by wheel. This commit reverts to original behavior
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.8 2011/04/15 17:01:05 gilles Exp $	*/
d44 3
a46 3
static int	fsqueue_envelope_load(struct smtpd *, enum queue_kind, struct message *);
static int	fsqueue_envelope_update(struct smtpd *, enum queue_kind, struct message *);
static int	fsqueue_envelope_delete(struct smtpd *, enum queue_kind, struct message *);
d59 1
a59 1
    enum queue_op , struct message *);
d97 1
a97 1
    struct message *envelope)
d111 1
a111 1
	evpid = envelope->evpid | rnd;
d132 2
a133 2
	envelope->creation = time(NULL);
	envelope->evpid = evpid;
d136 2
a137 2
		envelope->lasttry = 0;
		envelope->retry = 0;
d140 1
a140 1
	if (fwrite(envelope, sizeof (struct message), 1, fp) != 1) {
d160 2
a161 2
	envelope->creation = 0;
	envelope->evpid = 0;
d168 1
a168 1
    struct message *envelope)
d175 3
a177 3
		fsqueue_hash(evpid_to_msgid(envelope->evpid)),
		evpid_to_msgid(envelope->evpid),
		PATH_ENVELOPES, envelope->evpid))
d186 1
a186 1
	if (fread(envelope, sizeof(struct message), 1, fp) != 1)
d194 1
a194 1
    struct message *envelope)
d201 2
a202 2
	batch_id = envelope->batch_id;
	envelope->batch_id = 0;
d209 3
a211 3
		fsqueue_hash(evpid_to_msgid(envelope->evpid)),
		evpid_to_msgid(envelope->evpid),
		PATH_ENVELOPES, envelope->evpid))
d220 1
a220 1
	if (fwrite(envelope, sizeof(struct message), 1, fp) != 1) {
d234 1
a234 1
	envelope->batch_id = batch_id;
d243 1
a243 1
	envelope->batch_id = batch_id;
d249 1
a249 1
    struct message *envelope)
d254 1
a254 1
	hval = fsqueue_hash(evpid_to_msgid(envelope->evpid));
d259 1
a259 1
		evpid_to_msgid(envelope->evpid),
d261 1
a261 1
		envelope->evpid))
d268 1
a268 1
		hval, evpid_to_msgid(envelope->evpid), PATH_ENVELOPES))
d272 1
a272 1
		fsqueue_message_delete(env, qkind, evpid_to_msgid(envelope->evpid));
d635 1
a635 1
    enum queue_op qop, struct message *envelope)
d639 1
a639 1
		return fsqueue_envelope_create(env, qkind, envelope);
d642 1
a642 1
		return fsqueue_envelope_delete(env, qkind, envelope);
d645 1
a645 1
		return fsqueue_envelope_load(env, qkind, envelope);
d648 1
a648 1
		return fsqueue_envelope_update(env, qkind, envelope);
@


1.8
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.7 2011/04/14 23:29:56 gilles Exp $	*/
d540 1
a540 1
			group = env->sc_pw->pw_gid;
@


1.7
log
@bye bye queue_hash() you can now rest in peace.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.6 2011/04/14 23:26:16 gilles Exp $	*/
d42 1
a42 1
/*static*/ u_int16_t	 fsqueue_hash(char *);
d48 6
a53 6
static int	fsqueue_message_create(struct smtpd *, enum queue_kind, char *);
static int	fsqueue_message_commit(struct smtpd *, enum queue_kind, char *);
static int	fsqueue_message_fd_r(struct smtpd *, enum queue_kind, char *);
static int	fsqueue_message_fd_rw(struct smtpd *, enum queue_kind, char *);
static int	fsqueue_message_delete(struct smtpd *, enum queue_kind, char *);
static int	fsqueue_message_purge(struct smtpd *, enum queue_kind, char *);
d57 1
a57 1
    enum queue_op, char *);
d90 1
a90 1
fsqueue_hash(char *msgid)
a91 5
	u_int16_t h;

        for (h = 5381; *msgid; msgid++)
                h = ((h << 5) + h) + *msgid;
	
d102 2
d108 9
a116 4
	if (! bsnprintf(evpname, sizeof(evpname), "%s/%s%s/%s.%qu",
		fsqueue_getpath(qkind), envelope->message_id,
		PATH_ENVELOPES, envelope->message_id,
		(u_int64_t)arc4random()))
d133 1
a133 3
	if (strlcpy(envelope->message_uid, strrchr(evpname, '/') + 1,
	    sizeof(envelope->message_uid)) >= sizeof(envelope->message_uid))
		fatalx("fsqueue_envelope_create: truncation");
d161 1
a161 1
	envelope->message_uid[0] = '\0';
a170 1
	char msgid[MAX_ID_SIZE];
d173 1
a173 5
	if (strlcpy(msgid, envelope->message_uid, sizeof(msgid)) >= sizeof(msgid))
		return 0;

	*strrchr(msgid, '.') = '\0';
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%d/%s%s/%s",
d175 3
a177 1
		fsqueue_hash(msgid), msgid, PATH_ENVELOPES, envelope->message_uid))
d207 1
a207 1
	if (! bsnprintf(dest, sizeof(dest), "%s/%d/%s%s/%s",
d209 3
a211 3
		fsqueue_hash(envelope->message_id),
		envelope->message_id,
		PATH_ENVELOPES, envelope->message_uid))
d254 1
a254 1
	hval = fsqueue_hash(envelope->message_id);
d256 1
a256 1
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%d/%s%s/%s",
d258 4
a261 2
		hval, envelope->message_id, PATH_ENVELOPES,
		envelope->message_uid))
d267 2
a268 2
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%d/%s%s", PATH_QUEUE,
		hval, envelope->message_id, PATH_ENVELOPES))
d272 1
a272 1
		fsqueue_message_delete(env, qkind, envelope->message_id);
d278 1
a278 1
fsqueue_message_create(struct smtpd *env, enum queue_kind qkind, char *msgid)
d285 1
a285 1
	char msgid_save[MAX_ID_SIZE];
d287 1
a287 1
	strlcpy(msgid_save, msgid, sizeof(msgid_save));
d289 4
a292 2
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%d.XXXXXXXXXXXXXXXX",
		queuepath, time(NULL)))
d295 4
a298 1
	if (mkdtemp(rootdir) == NULL) {
d300 1
a300 1
			bzero(msgid, MAX_ID_SIZE);
d303 1
a303 1
		fatal("fsqueue_message_create: mkdtemp");
a305 4
	if (strlcpy(msgid, rootdir + strlen(queuepath) + 1, MAX_ID_SIZE)
	    >= MAX_ID_SIZE)
		fatalx("fsqueue_message_create: truncation");

d313 1
a313 1
			bzero(msgid, MAX_ID_SIZE);
d320 1
a320 1
		if (! bsnprintf(msgpath, sizeof(msgpath), "%s/%d/%s/message",
d322 2
a323 1
			fsqueue_hash(msgid_save), msgid_save))
d326 2
a327 2
		if (! bsnprintf(lnkpath, sizeof(lnkpath), "%s/%s/message",
			fsqueue_getpath(Q_BOUNCE), msgid))
d338 1
a338 1
fsqueue_message_commit(struct smtpd *env, enum queue_kind qkind, char *msgid)
d342 1
d344 1
a344 1
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%s",
d348 1
a348 1
	if (! bsnprintf(queuedir, sizeof(queuedir), "%s/%d",
d359 3
a361 4
	if (strlcat(queuedir, "/", sizeof(queuedir)) >= sizeof(queuedir) ||
	    strlcat(queuedir, msgid, sizeof(queuedir)) >=
	    sizeof(queuedir))
		fatalx("fsqueue_message_commit: truncation");
d363 1
a363 1
	if (rename(rootdir, queuedir) == -1) {
d373 1
a373 1
fsqueue_message_fd_r(struct smtpd *env, enum queue_kind qkind, char *msgid)
d380 1
a380 1
		if (! bsnprintf(pathname, sizeof(pathname), "%s/%s/message",
d386 1
a386 1
		if (! bsnprintf(pathname, sizeof(pathname), "%s/%d/%s/message",
d398 1
a398 1
fsqueue_message_fd_rw(struct smtpd *env, enum queue_kind qkind, char *msgid)
d402 1
a402 1
	if (! bsnprintf(pathname, sizeof(pathname), "%s/%s/message",
d411 1
a411 1
fsqueue_message_delete(struct smtpd *env, enum queue_kind qkind, char *msgid)
d419 1
a419 1
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%d/%s", PATH_QUEUE,
d445 1
a445 1
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%d", PATH_QUEUE, hval))
d454 1
a454 1
fsqueue_message_purge(struct smtpd *env, enum queue_kind qkind, char *msgid)
d459 1
a459 1
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%s",
d463 1
a463 1
	if (! bsnprintf(purgedir, sizeof(purgedir), "%s/%s",
d605 1
a605 1
    enum queue_op qop, char *msgid)
d612 1
a612 1
		return fsqueue_message_delete(env, qkind, msgid);
d615 1
a615 1
		return fsqueue_message_commit(env, qkind, msgid);
d618 1
a618 1
                return fsqueue_message_fd_r(env, qkind, msgid);
d621 1
a621 1
                return fsqueue_message_fd_rw(env, qkind, msgid);
d624 1
a624 1
		return fsqueue_message_purge(env, qkind, msgid);
@


1.6
log
@- implement missing operations for fsqueue:
	fsqueue_envelope_create(), fsqueue_message_purge()
- kill deprecated functions in queue_shared.c

At this point fsqueue backend is almost complete, all that is left to do is
to move the qwalk() API inside the queue_backend API, then make sure smtpd
is no longer calling anything queue related directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.5 2011/04/14 22:36:09 gilles Exp $	*/
d42 1
a42 1
static u_int16_t	 fsqueue_hash(char *);
d89 1
a89 1
static u_int16_t
d322 1
a322 1
			queue_hash(msgid_save), msgid_save))
@


1.5
log
@- implement fsqueue_message_create() and fsqueue_message_commit()
- change a few prototypes to allow bounce messages to use the
	queue_backend API until it gets merged in
- kill functions of the queue API that have been deprecated
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.4 2011/04/14 21:53:46 gilles Exp $	*/
d48 2
d53 1
d101 66
d452 21
d622 3
d638 1
a638 1
                return 0;
@


1.4
log
@fsqueue now provides fsqueue_message_fd_r() and fsqueue_message_fd_rw() to
obtain a read{-only,/write} descriptor to the message file.

make sure smtpd uses the new API everywhere it needs a fd, and kill the
many functions that were used until now.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.3 2011/04/14 21:14:20 gilles Exp $	*/
d210 93
a320 1
	log_debug("pathname: %s", pathname);
d336 1
a336 1
	log_debug("path: %s", pathname);
d518 1
a518 1
                return 0;
d524 1
a524 1
                return 0;
@


1.3
log
@fsqueue_message_delete() should use fsqueue_hash() not queue_hash() as i'm
going to kill it with lots of violence soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.2 2011/04/14 20:11:08 gilles Exp $	*/
d29 1
d48 2
d66 1
a66 1
                return (PATH_INCOMING);
d126 1
a126 1
int
d181 1
a181 1
int
d209 40
a248 1
int
d435 1
a435 1
                return 0;
d438 1
a438 1
                return 0;
@


1.2
log
@fsqueue queue backend will implement a filesystem queue:
- fsqueue->setup() performs the queue initialization;
- fsqueue->message() controls messages;
- fsqueue->envelope() controls envelopes;

This commit brings the following to fsbackend:
fsqueue_setup(), fsqueue_message_delete(), fsqueue_envelope_load(),
fsqueue_envelope_update(), fsqueue_envelope_delete().

It also makes smtpd use the queue_backend API for these operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_fsqueue.c,v 1.1 2011/04/14 17:06:43 gilles Exp $	*/
d214 1
a214 1
	hval = queue_hash(msgid);
@


1.1
log
@smtpd makes too many assumptions about the structure and layout of its
disk-based queue, it makes it near impossible to make changes to it without
editing twenty files... how am i going to implement mongodb support ? :-)

bring a new queue_backend API which hides the details of the disk-based
queue to smtpd. it is not "plugged in" yet and I'm filling the holes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 2
d40 11
a50 1
int	queue_fsqueue_message(struct smtpd *, enum queue_kind,
d52 1
a52 1
int	queue_fsqueue_envelope(struct smtpd *, enum queue_kind,
d55 323
d379 1
a379 1
queue_fsqueue_message(struct smtpd *env, enum queue_kind qkind,
d382 20
d406 1
a406 1
queue_fsqueue_envelope(struct smtpd *env, enum queue_kind qkind,
d409 17
@

