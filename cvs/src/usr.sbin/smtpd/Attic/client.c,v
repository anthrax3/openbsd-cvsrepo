head	1.40;
access;
symbols
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26;
locks; strict;
comment	@ * @;


1.40
date	2012.01.29.11.37.32;	author eric;	state dead;
branches;
next	1.39;

1.39
date	2011.12.11.19.58.09;	author eric;	state Exp;
branches;
next	1.38;

1.38
date	2011.11.03.14.34.13;	author chl;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.06.20.56.16;	author gilles;	state Exp;
branches;
next	1.36;

1.36
date	2011.05.14.11.06.32;	author gilles;	state Exp;
branches;
next	1.35;

1.35
date	2011.03.26.10.59.59;	author gilles;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.21.09.21.57;	author gilles;	state Exp;
branches;
next	1.33;

1.33
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.01.19.47.08;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.26.16.44.32;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.02.16.41.19;	author jacekm;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.02.13.42.42;	author jacekm;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.02.11.06.37;	author jacekm;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.23.17.16.03;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.16.21.40.01;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.16.02.20.32;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.15.11.45.51;	author jacekm;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.12.14.03.59;	author jacekm;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.12.10.33.11;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.17.09.22.19;	author jacekm;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.11.15.36.10;	author jacekm;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.11.11.41.05;	author jacekm;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.11.11.25.17;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.11.10.27.41;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.10.14.57.03;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.10.14.54.13;	author jacekm;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.10.00.24.53;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.25.20.43.29;	author chl;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.19.19.53.05;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.03.10.02.43;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.22.15.44.31;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.22.12.24.06;	author jacekm;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.17.23.51.23;	author jacekm;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.15.16.50.06;	author jacekm;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.27.11.42.50;	author jacekm;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.27.11.41.26;	author jacekm;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Rewrite io code in smtp and mta using the iobuf/ioev interface to have
a better separation between io and protocol logic.  As a side-effect,
it fixes a couple of long-standing issues in the io path, and
hopefully add fresh ones instead.  Kill client.c in the process.

ok gilles@@
@
text
@/*	$OpenBSD: client.c,v 1.39 2011/12/11 19:58:09 eric Exp $	*/

/*
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/uio.h>

#include <ctype.h>
#include <errno.h>
#include <imsg.h>
#include <limits.h>
#include <netdb.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <openssl/ssl.h>

#include "client.h"
#include "log.h"

int		 client_ssl_connect(struct smtp_client *);
SSL		*ssl_client_init(int, char *, size_t, char *, size_t);
int		 ssl_buf_read(SSL *, struct ibuf_read *);
int		 ssl_buf_write(SSL *, struct msgbuf *);

const char *parse_smtp_response(char *, size_t, char **, int *);

/*
 * Initialize SMTP session.
 */
struct smtp_client *
client_init(int fd, FILE *body, char *ehlo, int verbose)
{
	struct smtp_client	*sp = NULL;
	struct client_cmd	*c;
	socklen_t		 len;

	if ((sp = calloc(1, sizeof(*sp))) == NULL)
		fatal(NULL);
	if (ehlo == NULL || *ehlo == '\0') {
		char			 buf[NI_MAXHOST];
		struct sockaddr_storage	 sa;

		len = sizeof(sa);
		if (getsockname(fd, (struct sockaddr *)&sa, &len))
			fatal("client_init: getsockname");
		if (getnameinfo((struct sockaddr *)&sa, len, buf, sizeof(buf),
		    NULL, 0, NI_NUMERICHOST))
			fatalx("client_init: getnameinfo");
		if (asprintf(&sp->ehlo, "[%s]", buf) == -1)
			fatal("client_init: asprintf");
	} else if ((sp->ehlo = strdup(ehlo)) == NULL)
		fatal(NULL);
	if (verbose)
		sp->verbose = stdout;
	else if ((sp->verbose = fopen("/dev/null", "a")) == NULL)
		fatal("client_init: fopen");
	sp->body = body;
	sp->timeout.tv_sec = 300;
	msgbuf_init(&sp->w);
	sp->w.fd = fd;
	sp->flags = CLIENT_FLAG_FIRSTTIME;
	len = sizeof(sp->sndlowat);
	if (getsockopt(fd, SOL_SOCKET, SO_SNDLOWAT, &sp->sndlowat, &len) == -1)
		fatal("client_init: getsockopt");

	sp->exts[CLIENT_EXT_STARTTLS].want = 1;
	sp->exts[CLIENT_EXT_STARTTLS].must = 1;
	sp->exts[CLIENT_EXT_STARTTLS].name = "STARTTLS";

	sp->exts[CLIENT_EXT_AUTH].want = 0;
	sp->exts[CLIENT_EXT_AUTH].must = 0;
	sp->exts[CLIENT_EXT_AUTH].name = "AUTH";

	sp->exts[CLIENT_EXT_PIPELINING].want = 1;
	sp->exts[CLIENT_EXT_PIPELINING].must = 0;
	sp->exts[CLIENT_EXT_PIPELINING].name = "PIPELINING";

	TAILQ_INIT(&sp->cmdsendq);
	TAILQ_INIT(&sp->cmdrecvq);
	sp->cmdi = 1;
	sp->cmdw = 1;

	c = cmd_new(CLIENT_BANNER, "<banner>");
	TAILQ_INSERT_HEAD(&sp->cmdrecvq, c, entry);

	c = cmd_new(CLIENT_EHLO, "EHLO %s", sp->ehlo);
	TAILQ_INSERT_TAIL(&sp->cmdsendq, c, entry);

	return (sp);
}

/*
 * Create SMTP command.
 */
struct client_cmd *
cmd_new(int type, char *fmt, ...)
{
	struct client_cmd	*cmd;
	va_list			 ap;

	va_start(ap, fmt);
	if ((cmd = calloc(1, sizeof(*cmd))) == NULL)
		fatal(NULL);
	cmd->type = type;
	if (vasprintf(&cmd->action, fmt, ap) == -1)
		fatal(NULL);
	va_end(ap);
	return (cmd);
}

void
cmd_free(struct client_cmd *cmd)
{
	free(cmd->action);
	free(cmd);
}

/*
 * Request that connection be secured using SSL from the start.
 */
void
client_ssl_smtps(struct smtp_client *sp)
{
	sp->flags |= CLIENT_FLAG_HANDSHAKING;
	sp->exts[CLIENT_EXT_STARTTLS].want = 0;
	sp->exts[CLIENT_EXT_STARTTLS].must = 0;
}

/*
 * Allow session to progress in plaintext if STARTTLS fails.
 */
void
client_ssl_optional(struct smtp_client *sp)
{
	sp->exts[CLIENT_EXT_STARTTLS].must = 0;
}

/*
 * Use the provided certificate during SSL handshake.
 */
void
client_certificate(struct smtp_client *sp, char *cert, size_t certsz,
    char *key, size_t keysz)
{
	if ((sp->auth.cert = malloc(certsz)) == NULL)
		fatal(NULL);
	if ((sp->auth.key = malloc(keysz)) == NULL)
		fatal(NULL);
	memcpy(sp->auth.cert, cert, certsz);
	memcpy(sp->auth.key, key, keysz);
	sp->auth.certsz = certsz;
	sp->auth.keysz = keysz;
}

/*
 * Use the AUTH extension.
 */
void
client_auth(struct smtp_client *sp, char *secret)
{
	if ((sp->auth.plain = strdup(secret)) == NULL)
		fatal(NULL);

	sp->exts[CLIENT_EXT_AUTH].want = 1;
	sp->exts[CLIENT_EXT_AUTH].must = 1;
}

/*
 * Set envelope sender.
 */
void
client_sender(struct smtp_client *sp, char *fmt, ...)
{
	struct client_cmd	*c;
	char			*s;
	va_list			 ap;

	va_start(ap, fmt);
	if (vasprintf(&s, fmt, ap) == -1)
		fatal("client_sender: vasprintf");
	va_end(ap);
	c = cmd_new(CLIENT_MAILFROM, "MAIL FROM:<%s>", s);
	TAILQ_INSERT_TAIL(&sp->cmdsendq, c, entry);
	free(s);
}

/*
 * Add envelope recipient.
 */
void
client_rcpt(struct smtp_client *sp, void *data, char *fmt, ...)
{
	struct client_cmd	*c;
	char			*r;
	va_list			 ap;

	va_start(ap, fmt);
	if (vasprintf(&r, fmt, ap) == -1)
		fatal("client_rcpt: vasprintf");
	va_end(ap);
	c = cmd_new(CLIENT_RCPTTO, "RCPT TO:<%s>", r);
	c->data = data;
	TAILQ_INSERT_TAIL(&sp->cmdsendq, c, entry);
	free(r);
}

/*
 * Append string to the data buffer.
 */
void
client_printf(struct smtp_client *sp, char *fmt, ...)
{
	va_list	 ap;
	char	*p, *ln, *tmp;
	int	 len;

	if (sp->head == NULL)
		sp->head = ibuf_dynamic(0, SIZE_T_MAX);
	if (sp->head == NULL)
		fatal(NULL);

	va_start(ap, fmt);
	if ((len = vasprintf(&p, fmt, ap)) == -1)
		fatal("client_data_printf: vasprintf");
	va_end(ap);

	/* must end with a newline */
	if (len == 0 || p[len - 1] != '\n')
		fatalx("client_printf: invalid use");
	p[len - 1] = '\0';

	/* split into lines, deal with dot escaping etc. */
	tmp = p;
	while ((ln = strsep(&tmp, "\n"))) {
		if (*ln == '.' && ibuf_add(sp->head, ".", 1))
			fatal(NULL);
		if (ibuf_add(sp->head, ln, strlen(ln)))
			fatal(NULL);
		if (ibuf_add(sp->head, "\r\n", 2))
			fatal(NULL);
	}

	free(p);
}

/*
 * Routine called by the user to progress the session.
 */
int
client_talk(struct smtp_client *sp, int writable)
{
	struct client_cmd	*c;

	/* first call -> complete the initialisation */
	if (sp->flags & CLIENT_FLAG_FIRSTTIME) {
		sp->flags &= ~CLIENT_FLAG_FIRSTTIME;

		c = cmd_new(CLIENT_DATA, "DATA");
		TAILQ_INSERT_TAIL(&sp->cmdsendq, c, entry);

		c = cmd_new(CLIENT_DOT, ".");
		TAILQ_INSERT_TAIL(&sp->cmdsendq, c, entry);

		c = cmd_new(CLIENT_QUIT, "QUIT");
		TAILQ_INSERT_TAIL(&sp->cmdsendq, c, entry);

		/* prepare for the banner */
		writable = 0;
	}

	if (sp->flags & CLIENT_FLAG_HANDSHAKING) {
		if (sp->ssl == NULL) {
			log_debug("client: ssl handshake started");
			sp->ssl = ssl_client_init(sp->w.fd,
			    sp->auth.cert, sp->auth.certsz,
			    sp->auth.key, sp->auth.keysz);
			if (sp->ssl == NULL) {
				client_status(sp, "130 SSL init failed");
				return (CLIENT_DONE);
			}
			return (CLIENT_WANT_WRITE);
		} else
			return client_ssl_connect(sp);
	}

	/* regular handlers */
	return (writable ? client_write(sp) : client_read(sp));
}

/*
 * Handler to be called when socket becomes readable.
 */
int
client_read(struct smtp_client *sp)
{
	struct client_cmd	*cmd;
	int			 ret;

	if ((ret = client_socket_read(sp)))
		return (ret);

	while ((cmd = TAILQ_FIRST(&sp->cmdrecvq))) {
		if (client_getln(sp, cmd->type) < 0)
			return (CLIENT_DONE);
		if (*sp->reply == '\0')
			return client_poll(sp);

		/* reply fully received */
		TAILQ_REMOVE(&sp->cmdrecvq, cmd, entry);
		sp->cmdi--;

		/* if dying, ignore all replies as we wait for an EOF. */
		if (!(sp->flags & CLIENT_FLAG_DYING))
			client_get_reply(sp, cmd, &ret);

		cmd_free(cmd);

		/* handle custom return code, e.g. CLIENT_RCPT_FAIL */
		if (ret)
			return (ret);
	}

	return client_poll(sp);
}

/*
 * Parse reply to previously sent command.
 */
void
client_get_reply(struct smtp_client *sp, struct client_cmd *cmd, int *ret)
{
	switch (cmd->type) {
	case CLIENT_BANNER:
	case CLIENT_HELO:
	case CLIENT_MAILFROM:
		if (*sp->reply != '2') {
			client_status(sp, "%s", sp->reply);
			client_quit(sp);
		}
		return;

	case CLIENT_EHLO:
		if (*sp->reply != '2') {
			if (sp->exts[CLIENT_EXT_STARTTLS].must ||
			    sp->exts[CLIENT_EXT_AUTH].must) {
				client_status(sp, "%s", sp->reply);
				client_quit(sp);
			} else {
				cmd = cmd_new(CLIENT_HELO, "HELO %s", sp->ehlo);
				TAILQ_INSERT_HEAD(&sp->cmdsendq, cmd, entry);
			}
			return;
		}

		if (client_use_extensions(sp) < 0)
			client_quit(sp);
		return;

	case CLIENT_STARTTLS:
		if (*sp->reply != '2') {
			sp->exts[CLIENT_EXT_STARTTLS].fail = 1;
			if (client_use_extensions(sp) < 0)
				client_quit(sp);
		} else
			sp->flags |= CLIENT_FLAG_HANDSHAKING;
		return;

	case CLIENT_AUTH:
		if (*sp->reply != '2')
			sp->exts[CLIENT_EXT_AUTH].fail = 1;
		else
			sp->exts[CLIENT_EXT_AUTH].done = 1;

		if (client_use_extensions(sp) < 0)
			client_quit(sp);
		return;

	case CLIENT_RCPTTO:
		if (*sp->reply == '2')
			sp->flags |= CLIENT_FLAG_RCPTOKAY;
		else {
			sp->rcptfail = cmd->data;
			*ret = CLIENT_RCPT_FAIL;
		}
		return;

	case CLIENT_DATA:
		if (*sp->reply != '3') {
			client_status(sp, "%s", sp->reply);
			client_quit(sp);
		} else if (sp->flags & CLIENT_FLAG_RCPTOKAY) {
			sp->content = sp->head;
			sp->head = NULL;
			if (sp->content == NULL)
				sp->content = client_content_read(sp->body,
				    sp->sndlowat);
		} else {
			/*
			 * Leaving content pointer at NULL will make us proceed
			 * straight to "." as required by RFC 2920.
			 */
			client_status(sp, "600 all recipients refused");
		}
		return;

	case CLIENT_DOT:
		client_status(sp, "%s", sp->reply);
		client_quit(sp);
		return;

	default:
		fatalx("client_get_reply: unexpected type");
	}
}

/*
 * Handler to be called when socket becomes writable.
 */
int
client_write(struct smtp_client *sp)
{
	struct client_cmd	*cmd;
	int			 ret;

	if (sp->content) {
		ibuf_close(&sp->w, sp->content);
		sp->content = client_content_read(sp->body, sp->sndlowat);
	} else {
		while (sp->cmdi < sp->cmdw) {
			if ((cmd = TAILQ_FIRST(&sp->cmdsendq)) == NULL)
				fatalx("client_write: empty sendq");
			TAILQ_REMOVE(&sp->cmdsendq, cmd, entry);
			TAILQ_INSERT_TAIL(&sp->cmdrecvq, cmd, entry);
			client_putln(sp, "%s", cmd->action);
			sp->cmdi++;

			if (cmd->type == CLIENT_EHLO || cmd->type == CLIENT_HELO){
				sp->exts[CLIENT_EXT_STARTTLS].have = 0;
				sp->exts[CLIENT_EXT_STARTTLS].fail = 0;
				sp->exts[CLIENT_EXT_AUTH].have = 0;
				sp->exts[CLIENT_EXT_AUTH].fail = 0;
				sp->exts[CLIENT_EXT_PIPELINING].have = 0;
				sp->exts[CLIENT_EXT_PIPELINING].fail = 0;
			}

			if (cmd->type == CLIENT_DATA) {
				sp->timeout.tv_sec = 180;
				sp->cmdw = 1; /* stop pipelining */
			}

			if (cmd->type == CLIENT_DOT)
				sp->timeout.tv_sec = 600;

			if (cmd->type == CLIENT_QUIT) {
				sp->timeout.tv_sec = 300;
				sp->cmdw = 0; /* stop all output */
			}
		}
	}

	if ((ret = client_socket_write(sp)))
		return (ret);

	return client_poll(sp);
}

/*
 * Progress SSL handshake.
 */
int
client_ssl_connect(struct smtp_client *sp)
{
	struct client_cmd	*c;
	int			 ret;

	ret = SSL_connect(sp->ssl);

	switch (SSL_get_error(sp->ssl, ret)) {
	case SSL_ERROR_WANT_READ:
		return (CLIENT_STOP_WRITE);

	case SSL_ERROR_WANT_WRITE:
		return (CLIENT_WANT_WRITE);

	case SSL_ERROR_NONE:
		log_debug("client: ssl handshake completed");
		sp->flags &= ~CLIENT_FLAG_HANDSHAKING;

		if (sp->exts[CLIENT_EXT_STARTTLS].want) {
			c = cmd_new(CLIENT_EHLO, "EHLO %s", sp->ehlo);
			TAILQ_INSERT_HEAD(&sp->cmdsendq, c, entry);
		}
		sp->exts[CLIENT_EXT_STARTTLS].done = 1;
		return client_poll(sp);

	default:
		log_debug("client: ssl handshake failed");
		sp->flags &= ~CLIENT_FLAG_HANDSHAKING;

		if (sp->exts[CLIENT_EXT_STARTTLS].want) {
			sp->exts[CLIENT_EXT_STARTTLS].fail = 1;
			SSL_free(sp->ssl);
			sp->ssl = NULL;
			if (client_use_extensions(sp) < 0)
				return (CLIENT_DONE);
			else
				return client_poll(sp);
		} else {
			client_status(sp, "130 SSL_connect error");
			return (CLIENT_DONE);
		}
	}
}

/*
 * Deinitialization routine.
 */
void
client_close(struct smtp_client *sp)
{
	struct client_cmd	*cmd;

	free(sp->ehlo);
	free(sp->auth.plain);
	free(sp->auth.cert);
	free(sp->auth.key);
	if (sp->head)
		ibuf_free(sp->head);
	if (sp->content)
		ibuf_free(sp->content);
	msgbuf_clear(&sp->w);
	while ((cmd = TAILQ_FIRST(&sp->cmdsendq))) {
		TAILQ_REMOVE(&sp->cmdsendq, cmd, entry);
		cmd_free(cmd);
	}
	while ((cmd = TAILQ_FIRST(&sp->cmdrecvq))) {
		TAILQ_REMOVE(&sp->cmdrecvq, cmd, entry);
		cmd_free(cmd);
	}
	if (sp->ssl)
		SSL_free(sp->ssl);
	close(sp->w.fd);
	free(sp);
}

/*
 * Decide if any extensions need to be requested before proceeding to
 * the MAIL FROM command.
 */
int
client_use_extensions(struct smtp_client *sp)
{
	struct client_ext	*e;
	struct client_cmd	*c;
	size_t			 i;

	for (i = 0; i < nitems(sp->exts); i++) {
		e = &sp->exts[i];
		if (!e->want || e->done)
			continue;
		if (e->have && !e->fail) {
			if (i == CLIENT_EXT_STARTTLS) {
				c = cmd_new(CLIENT_STARTTLS, "STARTTLS");
				TAILQ_INSERT_HEAD(&sp->cmdsendq, c, entry);
				break;
			}
			if (i == CLIENT_EXT_AUTH) {
				c = cmd_new(CLIENT_AUTH, "AUTH PLAIN %s",
				    sp->auth.plain);
				TAILQ_INSERT_HEAD(&sp->cmdsendq, c, entry);
				break;
			}
			if (i == CLIENT_EXT_PIPELINING) {
				sp->cmdw = SIZE_T_MAX;
				sp->exts[i].done = 1;
				continue;
			}
			fatalx("client_use_extensions: invalid extension");
		} else if (e->must) {
			client_status(sp, "600 %s %s", e->name,
			     e->fail ? "failed" : "not available");
			return (-1);
		}
	}

	return (0);
}

/*
 * Update status field which the caller uses to check if any errors were
 * encountered.
 */
void
client_status(struct smtp_client *sp, char *fmt, ...)
{
	va_list ap;

	if (sp->flags & CLIENT_FLAG_DYING)
		return;

	va_start(ap, fmt);
	if (vsnprintf(sp->status, sizeof(sp->status), fmt, ap) == -1)
		fatal("client_status: vnprintf");
	va_end(ap);
}

/*
 * Read and validate next line from the input buffer.
 */
int
client_getln(struct smtp_client *sp, int type)
{
	const char	*e;
	char		*ln = NULL, *msg, cause[1024];
	int		 cont, rv = -1;

	sp->reply[0] = '\0';

	/* get a reply, dealing with multiline responses */
	for (cont = 1; cont;) {
		free(ln);
		errno = 0;
		if ((ln = buf_getln(&sp->r)) == NULL) {
			if (errno)
				strlcpy(cause, "150 buf_getln error", sizeof(cause));
			else
				rv = 0;
			goto done;
		}

		fprintf(sp->verbose, "<<< %s\n", ln);

		if ((e = parse_smtp_response(ln, strlen(ln), &msg, &cont))) {
			snprintf(cause, sizeof(cause), "150 %s", e);
			goto done;
		}

		if (type == CLIENT_EHLO) {
			if (strcmp(msg, "STARTTLS") == 0)
				sp->exts[CLIENT_EXT_STARTTLS].have = 1;
			else if (strncmp(msg, "AUTH", 4) == 0)
				sp->exts[CLIENT_EXT_AUTH].have = 1;
			else if (strcmp(msg, "PIPELINING") == 0)
				sp->exts[CLIENT_EXT_PIPELINING].have = 1;
		}
	}

	strlcpy(sp->reply, ln, sizeof(sp->reply));

	rv = 0;
done:
	if (rv)
		client_status(sp, cause);
	free(ln);
	return (rv);
}

/*
 * Add a line to the output buffer.
 */
void
client_putln(struct smtp_client *sp, char *fmt, ...)
{
	struct ibuf	*cmd = NULL;
	char		*p = NULL;
	int		 len;
	va_list		 ap;

	va_start(ap, fmt);
	if ((len = vasprintf(&p, fmt, ap)) == -1)
		fatal("client_putln: vasprintf");
	va_end(ap);

	fprintf(sp->verbose, ">>> %s\n", p);

	if ((cmd = ibuf_open(len + 2)) == NULL)
		fatal(NULL);
	if (ibuf_add(cmd, p, len))
		fatal(NULL);
	if (ibuf_add(cmd, "\r\n", 2))
		fatal(NULL);
	ibuf_close(&sp->w, cmd);

	free(p);
}

/*
 * Put chunk of message content to output buffer.
 */
struct ibuf *
client_content_read(FILE *fp, size_t max)
{
	struct ibuf	*b;
	char		*ln;
	size_t		 len;

	if ((b = ibuf_dynamic(0, SIZE_T_MAX)) == NULL)
		fatal(NULL);

	while (ibuf_size(b) < max) {
		if ((ln = fgetln(fp, &len)) == NULL)
			break;
		if (ln[len - 1] == '\n')
			len--;
		if (*ln == '.' && ibuf_add(b, ".", 1))
			fatal(NULL);
		if (ibuf_add(b, ln, len))
			fatal(NULL);
		if (ibuf_add(b, "\r\n", 2))
			fatal(NULL);
	}
	if (ferror(fp))
		fatal("client_body: fgetln");
	if (feof(fp) && ibuf_size(b) == 0) {
		ibuf_free(b);
		b = NULL;
	}

	return (b);
}

/*
 * Inform the caller what kind of polling should be done.
 */
int
client_poll(struct smtp_client *sp)
{
	if (sp->cmdi < sp->cmdw || sp->w.queued)
		return (CLIENT_WANT_WRITE);
	else
		return (CLIENT_STOP_WRITE);
}

/*
 * Move to dying stage.
 */
void
client_quit(struct smtp_client *sp)
{
	struct client_cmd *cmd;

	while ((cmd = TAILQ_FIRST(&sp->cmdsendq))) {
		if (cmd->type == CLIENT_QUIT)
			break;
		TAILQ_REMOVE(&sp->cmdsendq, cmd, entry);
		cmd_free(cmd);
	}
	sp->flags |= CLIENT_FLAG_DYING;
}

/*
 * Receive data from socket to internal buffer.
 */
int
client_socket_read(struct smtp_client *sp)
{
	if (sp->ssl) {
		switch (ssl_buf_read(sp->ssl, &sp->r)) {
		case SSL_ERROR_NONE:
			break;
		case SSL_ERROR_WANT_READ:
			return (CLIENT_STOP_WRITE);
		case SSL_ERROR_WANT_WRITE:
			return (CLIENT_WANT_WRITE);
		default:
			client_status(sp, "130 ssl_buf_read error");
			return (CLIENT_DONE);
		}
	}
	if (sp->ssl == NULL) {
		errno = 0;
		if (buf_read(sp->w.fd, &sp->r) == -1) {
			if (errno)
				client_status(sp, "130 buf_read: %s",
				    strerror(errno));
			else
				client_status(sp, "130 buf_read: "
				    "connection closed");
			return (CLIENT_DONE);
		}
	}
	return (0);
}

/*
 * Send data to socket from the msgbuf.
 */
int
client_socket_write(struct smtp_client *sp)
{
	if (sp->ssl) {
		switch (ssl_buf_write(sp->ssl, &sp->w)) {
		case SSL_ERROR_NONE:
			break;
		case SSL_ERROR_WANT_READ:
			return (CLIENT_STOP_WRITE);
		case SSL_ERROR_WANT_WRITE:
			return (CLIENT_WANT_WRITE);
		default:
			client_status(sp, "130 ssl_buf_write error");
			return (CLIENT_DONE);
		}
	}
	if (sp->ssl == NULL) {
		if (ibuf_write(&sp->w) < 0) {
			client_status(sp, "130 buf_write error");
			return (CLIENT_DONE);
		}
	}

	return (0);
}

/*
 * Read a full line from the read buffer.
 */
char *
buf_getln(struct ibuf_read *r)
{
	char	*line;
	u_char	*buf = r->buf;
	size_t	 bufsz = r->wpos, i;

	/* look for terminating newline */
	for (i = 0; i < bufsz; i++)
		if (buf[i] == '\n')
			break;
	if (i == bufsz)
		return (NULL);

	/* make a copy of the line */
	if ((line = calloc(i + 1, 1)) == NULL)
		return (NULL);
	memcpy(line, buf, i);

	/* handle CRLF */
	if (i != 0 && line[i - 1] == '\r')
		line[i - 1] = '\0';

	/* drain the buffer */
	memmove(buf, buf + i + 1, bufsz - i - 1);
	r->wpos -= i + 1;

	return (line);
}

/*
 * I/O routine for reading UNIX socket.
 */
int
buf_read(int fd, struct ibuf_read *r)
{
	u_char		*buf = r->buf + r->wpos;
	size_t		 bufsz = sizeof(r->buf) - r->wpos;
	ssize_t		 n;

	if (bufsz == 0) {
		errno = EMSGSIZE;
		return (-1);
	}

	if ((n = read(fd, buf, bufsz)) == -1) {
		if (errno == EAGAIN || errno == EINTR)
			return (-2);
		return (-1);
	} else if (n == 0)
		return (-1);

	r->wpos += n;

	return (0);
}
@


1.39
log
@utility function for parsing and validating SMTP response lines

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.38 2011/11/03 14:34:13 chl Exp $	*/
@


1.38
log
@since smtpctl doesn't need to be build along with client.c,
client.c doesn't need to be build with -DCLIENT_NO_SSL anymore,
so get rid of #ifdef CLIENT_NO_SSL

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.37 2011/07/06 20:56:16 gilles Exp $	*/
d47 2
d635 3
a637 2
	char	*ln = NULL, *cause = "";
	int	 i, rv = -1;
d642 2
a643 1
	for (;;) {
d647 1
a647 1
				cause = "150 buf_getln error";
d655 2
a656 15
		/* 3-char replies are invalid on their own, append space */
		if (strlen(ln) == 3) {
			char buf[5];

			strlcpy(buf, ln, sizeof(buf));
			strlcat(buf, " ", sizeof(buf));
			free(ln);
			if ((ln = strdup(buf)) == NULL) {
				cause = "150 strdup error";
				goto done;
			}
		}

		if (strlen(ln) < 4 || (ln[3] != ' ' && ln[3] != '-')) {
			cause = "150 garbled smtp reply";
d661 1
a661 1
			if (strcmp(ln + 4, "STARTTLS") == 0)
d663 1
a663 1
			else if (strncmp(ln + 4, "AUTH", 4) == 0)
d665 1
a665 1
			else if (strcmp(ln + 4, "PIPELINING") == 0)
a666 19
		}

		if (ln[3] == ' ')
			break;

		free(ln);
	}

	/* validate reply code */
	if (ln[0] < '2' || ln[0] > '5' || !isdigit(ln[1]) || !isdigit(ln[2])) {
		cause = "150 reply code out of range";
		goto done;
	}

	/* validate reply message */
	for (i = 0; ln[i] != '\0'; i++) {
		if (!isprint(ln[i])) {
			cause = "150 non-printable character in reply";
			goto done;
@


1.37
log
@fix that fscking "fgetln(): bad file descriptor" bug experienced by many.

long story short: datafp is reused by the possibly multiple client sessions
of a MTA session. fclosing it in client_close() will cause the file pointer
to be invalidated as soon as we fail the primary MX and attempt the second.

bug introduced while trying to fix a leak causing a crash for a user, now
smtpd will unconditionnally fclose() in MTA_DONE and if a leak still exists
then we should track why the mta session doesnt reach MTA_DONE.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.36 2011/05/14 11:06:32 gilles Exp $	*/
a41 1
#ifndef CLIENT_NO_SSL
a45 1
#endif
a87 4
#ifdef CLIENT_NO_SSL
	sp->exts[CLIENT_EXT_STARTTLS].want = 0;
	sp->exts[CLIENT_EXT_STARTTLS].must = 0;
#endif
a290 1
#ifndef CLIENT_NO_SSL
a304 1
#endif
a486 1
#ifndef CLIENT_NO_SSL
a533 1
#endif
a559 1
#ifndef CLIENT_NO_SSL
a561 1
#endif
a806 1
#ifndef CLIENT_NO_SSL
a819 1
#endif
a840 1
#ifndef CLIENT_NO_SSL
a853 1
#endif
@


1.36
log
@char -> u_char
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.35 2011/03/26 10:59:59 gilles Exp $	*/
a574 1
	fclose(sp->body);
@


1.35
log
@have the client API receive a stdio stream rather than a fd to the message
fd. this shifts responsibility for the fclose to the caller, prevents a
memory leak and makes everyone happy.

diff by Jared Yanovich, thanks !
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.34 2011/03/21 09:21:57 gilles Exp $	*/
d887 2
a888 1
	char	*buf = r->buf, *line;
d920 1
a920 1
	char		*buf = r->buf + r->wpos;
@


1.34
log
@fix a memory leak in client.c and properly close envelope in
queue_shared.c

diff from Jared Yanovich, sent to bugs@@ by Jonny Mosco
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.33 2010/11/28 13:56:43 gilles Exp $	*/
d53 1
a53 1
client_init(int fd, int body, char *ehlo, int verbose)
d79 1
a79 2
	if ((sp->body = fdopen(body, "r")) == NULL)
		fatal("client_init: fdopen");
@


1.33
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.32 2010/10/09 22:05:35 gilles Exp $	*/
d576 1
d694 2
@


1.32
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.28 2010/05/26 16:44:32 nicm Exp $	*/
d40 1
a40 17

struct client_cmd *cmd_new(int, char *, ...);
void		 cmd_free(struct client_cmd *);
int		 client_read(struct smtp_client *);
void		 client_get_reply(struct smtp_client *, struct client_cmd *,
		     int *);
int		 client_write(struct smtp_client *);
int		 client_use_extensions(struct smtp_client *);
void		 client_status(struct smtp_client *, char *, ...);
int		 client_getln(struct smtp_client *, int);
void		 client_putln(struct smtp_client *, char *, ...);
struct ibuf	*client_content_read(FILE *, size_t);
int		 client_poll(struct smtp_client *);
void		 client_quit(struct smtp_client *);

int		 client_socket_read(struct smtp_client *);
int		 client_socket_write(struct smtp_client *);
a47 7

char		*buf_getln(struct ibuf_read *);
int		 buf_read(int, struct ibuf_read *);

void		 log_debug(const char *, ...);	/* XXX */
void		 fatal(const char *);	/* XXX */
void		 fatalx(const char *);	/* XXX */
@


1.31
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.29 2010/05/31 23:38:56 jacekm Exp $	*/
@


1.30
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.28 2010/05/26 16:44:32 nicm Exp $	*/
@


1.29
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@a957 2
	//log_debug("%s: '%.*s'", __func__, sizeof(r->buf) - r->wpos, r->buf);

@


1.28
log
@Move imsg into libutil and add a man page.

Minor bump for libutil.

Previous versions of this diff and man page looked at by various people.

"you should just commit" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.27 2010/05/26 13:56:08 nicm Exp $	*/
d957 2
@


1.27
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.26 2010/01/02 16:41:19 jacekm Exp $	*/
d28 1
a38 1
#include "imsg.h"
@


1.26
log
@Replace 3 struct smtp_client members (ssl_handshake, rcptokay, dying) with a
bitmap called "flags".
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.25 2010/01/02 13:42:42 jacekm Exp $	*/
d51 1
a51 1
struct buf	*client_content_read(FILE *, size_t);
d61 1
a61 1
int		 ssl_buf_read(SSL *, struct buf_read *);
d65 2
a66 2
char		*buf_getln(struct buf_read *);
int		 buf_read(int, struct buf_read *);
d268 1
a268 1
		sp->head = buf_dynamic(0, SIZE_T_MAX);
d285 1
a285 1
		if (*ln == '.' && buf_add(sp->head, ".", 1))
d287 1
a287 1
		if (buf_add(sp->head, ln, strlen(ln)))
d289 1
a289 1
		if (buf_add(sp->head, "\r\n", 2))
d478 1
a478 1
		buf_close(&sp->w, sp->content);
d582 1
a582 1
		buf_free(sp->head);
d584 1
a584 1
		buf_free(sp->content);
d748 1
a748 1
	struct buf	*cmd = NULL;
d760 1
a760 1
	if ((cmd = buf_open(len + 2)) == NULL)
d762 1
a762 1
	if (buf_add(cmd, p, len))
d764 1
a764 1
	if (buf_add(cmd, "\r\n", 2))
d766 1
a766 1
	buf_close(&sp->w, cmd);
d774 1
a774 1
struct buf *
d777 1
a777 1
	struct buf	*b;
d781 1
a781 1
	if ((b = buf_dynamic(0, SIZE_T_MAX)) == NULL)
d784 1
a784 1
	while (buf_size(b) < max) {
d789 1
a789 1
		if (*ln == '.' && buf_add(b, ".", 1))
d791 1
a791 1
		if (buf_add(b, ln, len))
d793 1
a793 1
		if (buf_add(b, "\r\n", 2))
d798 2
a799 2
	if (feof(fp) && buf_size(b) == 0) {
		buf_free(b);
d893 1
a893 1
		if (buf_write(&sp->w) < 0) {
d906 1
a906 1
buf_getln(struct buf_read *r)
d938 1
a938 1
buf_read(int fd, struct buf_read *r)
@


1.25
log
@Factor out parts of client_read() into client_socket_read() and
client_get_reply(), downsizing it from 170+ to just over 30 lines.
The gotos are now gone, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.24 2010/01/02 11:06:37 jacekm Exp $	*/
d80 1
a86 1
		socklen_t		 len;
d107 4
a110 1
	sp->sndlowat = -1;
d174 1
a174 1
	sp->ssl_handshake = 1;
a302 1
	socklen_t		 len;
d305 2
a306 5
	if (sp->sndlowat == -1) {
		len = sizeof(sp->sndlowat);
		if (getsockopt(sp->w.fd, SOL_SOCKET, SO_SNDLOWAT,
		    &sp->sndlowat, &len) == -1)
			fatal("client_talk: getsockopt");
d322 1
a322 2
	/* transition to ssl requested? */
	if (sp->ssl_handshake) {
d365 1
a365 1
		if (!sp->dying)
d417 1
a417 1
			sp->ssl_handshake = 1;
d432 1
a432 1
			sp->rcptokay++;
d443 1
a443 1
		} else if (sp->rcptokay > 0) {
d539 9
a547 2
		sp->ssl_handshake = 0;
		break;
d551 1
a551 1
		sp->ssl_handshake = 0;
d557 3
a559 1
			if (client_use_extensions(sp) == 0)
d561 1
a561 1
		} else
d563 2
a564 2

		return (CLIENT_DONE);
a565 11

	log_debug("client: ssl handshake completed");

	if (sp->exts[CLIENT_EXT_STARTTLS].want) {
		c = cmd_new(CLIENT_EHLO, "EHLO %s", sp->ehlo);
		TAILQ_INSERT_HEAD(&sp->cmdsendq, c, entry);
	}

	sp->exts[CLIENT_EXT_STARTTLS].done = 1;

	return client_poll(sp);
d654 1
a654 1
	if (sp->dying)
d832 1
a832 1
	sp->dying = 1; 
@


1.24
log
@Simplify code by removing struct smtp_client member, int iomode, which was
used for keeping track of the current polling mode.  Introduce new function
client_poll() that determines what mode of polling is required at the time of
call.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.23 2009/12/23 17:16:03 jacekm Exp $	*/
d42 1
d44 2
a48 1

d53 4
d158 7
d350 5
a354 3
	struct client_cmd	*cmd, *c;
	int			 type;
	void			*data;
d356 5
a360 5
#ifndef CLIENT_NO_SSL
	if (sp->ssl) {
		switch (ssl_buf_read(sp->ssl, &sp->r)) {
		case SSL_ERROR_NONE:
			break;
d362 3
a364 2
		case SSL_ERROR_WANT_READ:
			return (CLIENT_STOP_WRITE);
d366 3
a368 2
		case SSL_ERROR_WANT_WRITE:
			return (CLIENT_WANT_WRITE);
d370 1
a370 18
		default:
			client_status(sp, "130 ssl_buf_read error");
			return (CLIENT_DONE);
		}
	}
#endif
	if (sp->ssl == NULL) {
		errno = 0;
		if (buf_read(sp->w.fd, &sp->r) == -1) {
			if (errno)
				client_status(sp, "130 buf_read: %s",
				    strerror(errno));
			else
				client_status(sp, "130 buf_read: "
				    "connection closed");
			return (CLIENT_DONE);
		}
	}
d372 3
a374 5
again:
	/* each reply corresponds to past command */
	if ((cmd = TAILQ_FIRST(&sp->cmdrecvq)) == NULL) {
		client_status(sp, "170 client_read: unexpected data");
		return (CLIENT_DONE);
d377 2
a378 13
	/* get server reply */
	if (client_getln(sp, cmd->type) < 0)
		goto quit2;
	if (*sp->reply == '\0')
		return client_poll(sp);

	/* reply fully received */
	TAILQ_REMOVE(&sp->cmdrecvq, cmd, entry);
	type = cmd->type;
	data = cmd->data;
	free(cmd->action);
	free(cmd);
	sp->cmdi--;
d380 7
a386 5
	/* dying?  ignore all replies as we wait for EOF. */
	if (sp->dying)
		return client_poll(sp);

	switch (type) {
d388 7
a394 3
		if (*sp->reply != '2')
			goto quit;
		break;
d399 6
a404 5
			    sp->exts[CLIENT_EXT_AUTH].must)
				goto quit;
			else {
				c = cmd_new(CLIENT_HELO, "HELO %s", sp->ehlo);
				TAILQ_INSERT_HEAD(&sp->cmdsendq, c, entry);
d406 1
a406 1
			break;
d410 2
a411 7
			goto quit2;
		break;

	case CLIENT_HELO:
		if (*sp->reply != '2')
			goto quit;
		break;
d417 1
a417 1
				goto quit2;
d420 1
a420 1
		break;
d429 2
a430 7
			goto quit2;
		break;

	case CLIENT_MAILFROM:
		if (*sp->reply != '2')
			goto quit;
		break;
d436 2
a437 2
			sp->rcptfail = data;
			return (CLIENT_RCPT_FAIL);
d439 1
a439 1
		break;
d442 4
a445 3
		if (*sp->reply != '3')
			goto quit;
		else if (sp->rcptokay > 0) {
d458 1
a458 1
		break;
d461 3
a463 1
		goto quit;
d466 1
a466 1
		fatalx("client_read: unexpected type");
a467 22

	if (!TAILQ_EMPTY(&sp->cmdrecvq))
		goto again;

	return client_poll(sp);

quit:
	client_status(sp, "%s", sp->reply);
quit2:
	/* reduce send queue to just the final QUIT */
	while ((c = TAILQ_FIRST(&sp->cmdsendq))) {
		if (c->type == CLIENT_QUIT)
			break;
		TAILQ_REMOVE(&sp->cmdsendq, c, entry);
		free(c->action);
		free(c);
	}

	/* ignore all replies from now on, eg. those still in the pipeline */
	sp->dying = 1; 

	return client_poll(sp);
d477 1
d515 2
a516 24
#ifndef CLIENT_NO_SSL
	if (sp->ssl) {
		switch (ssl_buf_write(sp->ssl, &sp->w)) {
		case SSL_ERROR_NONE:
			break;

		case SSL_ERROR_WANT_READ:
			return (CLIENT_STOP_WRITE);

		case SSL_ERROR_WANT_WRITE:
			return (CLIENT_WANT_WRITE);

		default:
			client_status(sp, "130 ssl_buf_write error");
			return (CLIENT_DONE);
		}
	}
#endif
	if (sp->ssl == NULL) {
		if (buf_write(&sp->w) < 0) {
			client_status(sp, "130 buf_write error");
			return (CLIENT_DONE);
		}
	}
d592 1
a592 2
		free(cmd->action);
		free(cmd);
d596 1
a596 2
		free(cmd->action);
		free(cmd);
d820 84
@


1.23
log
@Implementation of RFC 2920 PIPELINING extension, client side only for now.

This restructures the client_* API internals significantly.  The code becomes
pipelining in nature.  All SMTP commands are put on the output queue and
dequeued as quickly as possible.  Once dequeued, they're moved to the receive
queue so that replies can be matched with previous commands.

Dequeuing commands from the output queue halts when the count of commands
currently in-pipeline (``cmdi'') is equal to the command send window (``cmdw'').
There are three cmdw values useful in practice:

0               clear pipeline, ie. inhibit all future sends
1               disable pipelining, ie. use old ``one-request-one-reply`` mode
SIZE_T_MAX      enable pipelining, ie. dequeue as many commands as possible

At the beginning of session cmdw is 1.  When it is found that peer supports
PIPELINING, it grows to SIZE_T_MAX.  After dequeing DATA it is again 1.  After
sending QUIT it is 0.

Each command dequeued from the output queue becomes a buf in a msgbuf.  The act
of combining multiple commands into a single send operation did not need to be
implemented: buf_write() already combines bufs using iovec and sends them at
once using sendmsg(2).

Tested by todd@@ and oga@@

"looks good" to gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.22 2009/12/16 21:40:01 jacekm Exp $	*/
d50 1
a101 1
	sp->iomode = CLIENT_WANT_WRITE;
a305 1
		sp->iomode = CLIENT_STOP_WRITE;
d321 1
a321 2
			sp->iomode = CLIENT_WANT_WRITE;
			return (sp->iomode);
d348 1
a348 2
			sp->iomode = CLIENT_STOP_WRITE;
			return (sp->iomode);
d351 1
a351 2
			sp->iomode = CLIENT_WANT_WRITE;
			return (sp->iomode);
d383 1
a383 1
		return (sp->iomode);
a392 6
	/* re-enable write events if window allows */
	if (sp->cmdi < sp->cmdw)
		sp->iomode = CLIENT_WANT_WRITE;
	else
		sp->iomode = CLIENT_STOP_WRITE;

d395 1
a395 1
		return (sp->iomode);
d485 1
a485 1
	return (sp->iomode);
d502 1
a502 1
	return (sp->iomode);
d556 1
a556 2
			sp->iomode = CLIENT_STOP_WRITE;
			return (sp->iomode);
d559 1
a559 2
			sp->iomode = CLIENT_WANT_WRITE;
			return (sp->iomode);
d574 1
a574 7
	/*
	 * Disable write events when send window prevents us from sending more.
	 */
	if (sp->w.queued == 0 && sp->cmdi >= sp->cmdw)
		sp->iomode = CLIENT_STOP_WRITE;

	return (sp->iomode);
d591 1
a591 2
		sp->iomode = CLIENT_STOP_WRITE;
		return (sp->iomode);
d594 1
a594 2
		sp->iomode = CLIENT_WANT_WRITE;
		return (sp->iomode);
d608 2
a609 4
			if (client_use_extensions(sp) == 0) {
				sp->iomode = CLIENT_WANT_WRITE;
				return (sp->iomode);
			}
d621 1
a621 3
		sp->iomode = CLIENT_WANT_WRITE;
	} else
		sp->iomode = CLIENT_STOP_WRITE;
d625 1
a625 1
	return (sp->iomode);
d866 12
@


1.22
log
@Don't lose a line each time a chunkful of content is read off the disk.
Problem spotted by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.21 2009/12/16 02:20:32 jacekm Exp $	*/
d41 1
d44 1
a44 1
int		 client_next_state(struct smtp_client *);
d47 1
a47 1
int		 client_getln(struct smtp_client *);
d49 1
a49 1
void		 client_body(struct msgbuf *, FILE *);
d72 1
a90 2
	if ((sp->sender = strdup("")) == NULL)
		fatal(NULL);
a96 2
	sp->state = CLIENT_INIT;
	sp->handler = client_write;
d100 2
a101 1
	TAILQ_INIT(&sp->recipients);
a108 1
	sp->exts[CLIENT_EXT_STARTTLS].state = CLIENT_STARTTLS;
a112 1
	sp->exts[CLIENT_EXT_AUTH].state = CLIENT_AUTH;
d115 15
d134 19
d158 1
a158 1
	sp->state = CLIENT_SSL_INIT;
d203 1
a203 1
 * Set envelope sender.  If not called, the sender is assumed to be "<>".
d208 3
a210 3
	va_list		 ap;

	free(sp->sender);
d213 1
a213 1
	if (vasprintf(&sp->sender, fmt, ap) == -1)
d216 3
d222 1
a222 1
 * Add mail recipient.
d225 1
a225 1
client_rcpt(struct smtp_client *sp, void *p, char *fmt, ...)
d227 3
a229 6
	va_list		 ap;
	struct rcpt	*rp = NULL;

	if ((rp = calloc(1, sizeof(*rp))) == NULL)
		fatal(NULL);
	rp->p = p;
d232 1
a232 1
	if (vasprintf(&rp->mbox, fmt, ap) == -1)
d235 4
a238 3

	TAILQ_INSERT_TAIL(&sp->recipients, rp, entry);
	sp->rcpt = TAILQ_FIRST(&sp->recipients);
d284 1
a284 1
client_talk(struct smtp_client *sp)
d286 2
a287 1
	int ret;
d289 20
a308 1
	ret = sp->handler(sp);
d310 18
a327 4
	if (ret == CLIENT_WANT_READ)
		sp->handler = client_read;
	else if (ret == CLIENT_WANT_WRITE || ret == CLIENT_RCPT_FAIL)
		sp->handler = client_write;
d329 2
a330 1
	return (ret);
d339 4
a343 4
	if (sp->state == CLIENT_SSL_CONNECT)
		return client_ssl_connect(sp);

	/* read data from the socket */
d350 2
a351 1
			return (CLIENT_WANT_READ);
d354 2
a355 1
			return (CLIENT_WANT_WRITE);
d376 7
d384 1
a384 1
	if (client_getln(sp) < 0)
d387 15
a401 1
		return (CLIENT_WANT_READ);
d403 3
a405 14
	/*
	 * Devalue untimely 5yz reply down to 1yz in order to protect
	 * the caller from dropping mail for trifle reason.
	 */ 
	if (*sp->reply == '5' &&
	    sp->state != CLIENT_EHLO &&
	    sp->state != CLIENT_AUTH &&
	    sp->state != CLIENT_MAILFROM &&
	    sp->state != CLIENT_RCPTTO &&
	    sp->state != CLIENT_DATA &&
	    sp->state != CLIENT_DATA_BODY) {
		client_status(sp, "190 untimely 5yz reply: %s", sp->reply);
		goto quit2;
	}
d407 2
a408 2
	switch (sp->state) {
	case CLIENT_INIT:
a410 2
		else
			sp->state = CLIENT_EHLO;
d418 4
a421 2
			else
				sp->state = CLIENT_HELO;
d424 2
a425 2
	
		if ((sp->state = client_next_state(sp)) == 0)
a431 2
		else
			sp->state = CLIENT_MAILFROM;
d437 1
a437 1
			if ((sp->state = client_next_state(sp)) == 0)
d440 1
a440 1
			sp->state = CLIENT_SSL_INIT;
d449 1
a449 1
		if ((sp->state = client_next_state(sp)) == 0)
a455 2
		else
			sp->state = CLIENT_RCPTTO;
d459 1
a459 1
		if (*sp->reply == '2') {
d461 2
a462 4
			sp->rcpt = TAILQ_NEXT(sp->rcpt, entry);
		} else {
			sp->rcptfail = sp->rcpt;
			sp->rcpt = TAILQ_NEXT(sp->rcpt, entry);
d470 13
a482 2
		else
			sp->state = CLIENT_DATA_BODY;
d485 1
a485 1
	case CLIENT_DATA_BODY:
a487 3
	case CLIENT_QUIT:
		return (CLIENT_WANT_READ);

d489 1
a489 1
		fatalx("client_read: unexpected state");
d492 4
a495 1
	return (CLIENT_WANT_WRITE);
d500 13
a512 2
	sp->state = CLIENT_QUIT;
	return (CLIENT_WANT_WRITE);
d521 1
d523 20
a542 4
#ifndef CLIENT_NO_SSL
	if (sp->state == CLIENT_SSL_CONNECT)
		return client_ssl_connect(sp);
#endif
d544 4
a547 20
	/* complete any pending write */
	if (sp->w.queued)
		goto write;

	switch (sp->state) {
#ifndef CLIENT_NO_SSL
	case CLIENT_SSL_INIT:
		log_debug("client: ssl handshake started");
		sp->ssl = ssl_client_init(sp->w.fd,
		    sp->auth.cert, sp->auth.certsz,
		    sp->auth.key, sp->auth.keysz);
		if (sp->ssl == NULL) {
			client_status(sp, "130 SSL init failed");
			return (CLIENT_DONE);
		} else {
			sp->state = CLIENT_SSL_CONNECT;
			return (CLIENT_WANT_WRITE);
		}
		break;
#endif
d549 2
a550 3
	case CLIENT_INIT:
		/* read the banner */
		return (CLIENT_WANT_READ);
d552 4
a555 31
	case CLIENT_EHLO:
	case CLIENT_HELO:
		sp->exts[CLIENT_EXT_STARTTLS].have = 0;
		sp->exts[CLIENT_EXT_STARTTLS].fail = 0;

		sp->exts[CLIENT_EXT_AUTH].have = 0;
		sp->exts[CLIENT_EXT_AUTH].fail = 0;

		client_putln(sp, "%s %s", sp->state == CLIENT_EHLO ? "EHLO" :
		    "HELO", sp->ehlo);
		break;

	case CLIENT_AUTH:
		client_putln(sp, "AUTH PLAIN %s", sp->auth.plain);
		break;

	case CLIENT_STARTTLS:
		client_putln(sp, "STARTTLS");
		break;

	case CLIENT_MAILFROM:
		client_putln(sp, "MAIL FROM:<%s>", sp->sender);
		break;

	case CLIENT_RCPTTO:
		if (sp->rcpt == NULL) {
			if (sp->rcptokay > 0)
				sp->state = CLIENT_DATA;
			else
				sp->state = CLIENT_QUIT;
			return (CLIENT_WANT_WRITE);
a556 24
		client_putln(sp, "RCPT TO:<%s>", sp->rcpt->mbox);
		break;

	case CLIENT_DATA:
		sp->timeout.tv_sec = 120;
		client_putln(sp, "DATA");
		break;

	case CLIENT_DATA_BODY:
		sp->timeout.tv_sec = 180;
		if (sp->head) {
			buf_close(&sp->w, sp->head);
			sp->head = NULL;
		}
		client_body(&sp->w, sp->body);
		break;

	case CLIENT_QUIT:
		sp->timeout.tv_sec = 300;
		client_putln(sp, "QUIT");
		break;

	default:
		fatalx("client_write: unexpected state");
a558 1
write:
d566 2
a567 1
			return (CLIENT_WANT_READ);
d570 2
a571 1
			return (CLIENT_WANT_WRITE);
d586 5
a590 6
	if (sp->state == CLIENT_DATA_BODY) {
		if (!feof(sp->body))
			return (CLIENT_WANT_WRITE);
		else
			sp->timeout.tv_sec = 600;
	}
d592 1
a592 1
	return (sp->w.queued ? CLIENT_WANT_WRITE : CLIENT_WANT_READ);
d602 2
a603 1
	int	 ret;
d609 2
a610 1
		return (CLIENT_WANT_READ);
d613 2
a614 1
		return (CLIENT_WANT_WRITE);
d617 1
d622 1
d628 4
a631 2
			if ((sp->state = client_next_state(sp)) != 0)
				return (CLIENT_WANT_WRITE);
d640 6
a645 4
	if (sp->exts[CLIENT_EXT_STARTTLS].want)
		sp->state = CLIENT_EHLO;
	else
		sp->state = CLIENT_INIT;
d649 1
a649 1
	return (CLIENT_WANT_WRITE);
d659 1
a659 1
	struct rcpt	*rp;
a661 1
	free(sp->sender);
d667 2
d670 9
a678 4
	while ((rp = TAILQ_FIRST(&sp->recipients))) {
		TAILQ_REMOVE(&sp->recipients, rp, entry);
		free(rp->mbox);
		free(rp);
d693 1
a693 1
client_next_state(struct smtp_client *sp)
d696 1
a698 1
	/* Request extensions that require use of a verb. */
d701 7
a707 7
		if (e->want && !e->done) {
			if (e->have && !e->fail)
				return (e->state);
			else if (e->must) {
				client_status(sp, "600 %s %s", e->name,
				     e->fail ? "failed" : "not available");
				return (0);
d709 16
d728 1
a728 1
	return (CLIENT_MAILFROM);
d740 1
a740 2
	/* Don't record errors that occurred at QUIT. */
	if (sp->state == CLIENT_QUIT)
d753 1
a753 1
client_getln(struct smtp_client *sp)
d791 1
a791 1
		if (sp->state == CLIENT_EHLO) {
d796 2
d860 2
a861 2
void
client_body(struct msgbuf *out, FILE *fp)
d865 1
a865 1
	size_t		 len, total = 0;
d870 3
a872 1
	while (total < 4096 && (ln = fgetln(fp, &len))) {
a880 1
		total += len;
d884 4
a887 2
	if (feof(fp) && buf_add(b, ".\r\n", 3))
		fatal(NULL);
d889 1
a889 1
	buf_close(out, b);
@


1.21
log
@Fix RCPT TO failure handling, bug introduced in r1.18.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.20 2009/12/15 11:45:51 jacekm Exp $	*/
d794 1
a794 1
	while ((ln = fgetln(fp, &len)) && total < 4096) {
@


1.20
log
@Simplify SSL code client-side, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.19 2009/12/12 14:03:59 jacekm Exp $	*/
d260 1
a260 1
	else if (ret == CLIENT_WANT_WRITE)
@


1.19
log
@When acting as a client do content reads from the disk progressively
as the remote accepts more data instead of doing one big read into
the memory in the beginning of session.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.18 2009/12/12 10:33:11 jacekm Exp $	*/
d104 2
a108 3
#else
	sp->exts[CLIENT_EXT_STARTTLS].want = 1;
	sp->exts[CLIENT_EXT_STARTTLS].must = 1;
a274 1
#endif
d277 2
a278 3
#ifndef CLIENT_NO_SSL
	if (sp->ssl_state) {
		switch (ssl_buf_read(sp->ssl_state, &sp->r)) {
d292 1
a292 2
#else
	if (0) {
d294 1
a294 1
	} else {
d440 1
a440 1
		sp->ssl_state = ssl_client_init(sp->w.fd,
d443 1
a443 1
		if (sp->ssl_state == NULL) {
d517 2
a518 2
	if (sp->ssl_state) {
		switch (ssl_buf_write(sp->ssl_state, &sp->w)) {
d532 1
a532 2
#else
	if (0) {
d534 1
a534 1
	} else {
d560 1
a560 1
	ret = SSL_connect(sp->ssl_state);
d562 1
a562 1
	switch (SSL_get_error(sp->ssl_state, ret)) {
d577 2
a578 2
			SSL_free(sp->ssl_state);
			sp->ssl_state = NULL;
d622 2
a623 2
	if (sp->ssl_state)
		SSL_free(sp->ssl_state);
@


1.18
log
@Simplify client_* api, mainly by making fatal conditions result in immediate
fatals instead of passing the error up (kills ~300 lines).

Implement sending of the QUIT command which replaces crude close(2).

tested by gilles@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.17 2009/11/17 09:22:19 jacekm Exp $	*/
d48 1
a48 1
void		 client_data_add(struct smtp_client *, char *, size_t);
d68 1
a68 1
client_init(int fd, char *ehlo, int verbose)
d95 2
a96 2
	if ((sp->data = buf_dynamic(0, SIZE_T_MAX)) == NULL)
		fatal(NULL);
a210 24
 * Append file referenced by fd to the data buffer.
 */
void
client_data_fd(struct smtp_client *sp, int fd)
{
	struct stat	 sb;
	char		*map;

	if (fstat(fd, &sb) == -1)
		fatal("client_data_fd: fstat");
	if ((size_t)sb.st_size > SIZE_T_MAX)
		fatalx("client_data_fd: file too large");
	if (!S_ISREG(sb.st_mode))
		fatalx("client_data_fd: non-regular file");
	map = mmap(NULL, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd,
	    (off_t)0);
	if (map == MAP_FAILED)
		fatal("client_data_fd: mmap failed");
	madvise(map, sb.st_size, MADV_SEQUENTIAL);
	client_data_add(sp, map, sb.st_size);
	munmap(map, sb.st_size);
}

/*
d214 1
a214 1
client_data_printf(struct smtp_client *sp, char *fmt, ...)
d217 1
a217 1
	char	*p = NULL;
d220 5
d229 17
a245 1
	client_data_add(sp, p, len);
d503 5
a507 4
		if (buf_add(sp->data, ".\r\n", 3) < 0)
			fatal("client_write: buf_add failed");
		buf_close(&sp->w, sp->data);
		sp->data = NULL;
d546 6
a551 5
	/*
	 * Extend timeout after having sent final "." character.
	 */
	if (sp->state == CLIENT_DATA_BODY && sp->w.queued == 0)
		sp->timeout.tv_sec = 600;
d618 2
a619 2
	if (sp->data)
		buf_free(sp->data);
d777 1
a777 1
	if (buf_add(cmd, p, len) < 0)
d779 1
a779 1
	if (buf_add(cmd, "\r\n", 2) < 0)
d787 1
a787 1
 * Append buffer to the data buffer, performing necessary transformations.
d790 1
a790 1
client_data_add(struct smtp_client *sp, char *buf, size_t len)
d792 3
a794 1
	char	*ln;
d796 2
a797 4
	/* must end with a newline */
	if (len == 0 || buf[len - 1] != '\n')
		fatalx("client_data_add: bad buffer");
	buf[len - 1] = '\0';
d799 4
a802 3
	/* split into lines, deal with dot escaping etc. */
	while ((ln = strsep(&buf, "\n"))) {
		if (*ln == '.' && buf_add(sp->data, ".", 1) < 0)
d804 1
a804 1
		if (buf_add(sp->data, ln, strlen(ln)) < 0)
d806 1
a806 1
		if (buf_add(sp->data, "\r\n", 2) < 0)
d808 1
d810 6
@


1.17
log
@Fix handling of 5yz response to EHLO, ie. fallback to HELO.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.16 2009/11/11 15:36:10 jacekm Exp $	*/
d41 2
d44 1
d47 2
a48 2
int		 client_putln(struct smtp_client *, char *, ...);
int		 client_data_add(struct smtp_client *, char *, size_t);
d60 4
a64 2
 * client_init()
 *
d68 1
a68 1
client_init(int fd, char *ehlo)
a70 1
	int			 rv = -1;
d73 1
a73 1
		goto done;
d81 1
a81 1
			goto done;
d84 1
a84 1
			goto done;
d86 1
a86 1
			goto done;
d88 1
a88 1
		goto done;
d90 5
a94 1
		goto done;
d96 1
a96 1
		goto done;
d98 2
d104 4
a107 1
#ifndef CLIENT_NO_SSL
d110 1
a112 1
#endif
a118 10
	rv = 0;
done:
	if (rv && sp != NULL) {
		free(sp->ehlo);
		free(sp->sender);
		if (sp->data)
			buf_free(sp->data);
		free(sp);
		sp = NULL;
	}
d123 1
a123 3
 * client_verbose()
 *
 * Enable logging of SMTP commands.
a125 11
client_verbose(struct smtp_client *sp, FILE *fp)
{
	sp->verbose = fp;
}

/*
 * client_ssl_smtps()
 *
 * Request that connection be secured using SSL from the start.
 */
int
a127 5
	/* check if too late */
	if (sp->state != CLIENT_INIT)
		return (-1);

#ifndef CLIENT_NO_SSL
a130 5

	return (0);
#else
	return (-1);
#endif
a133 2
 * client_ssl_optional()
 *
d136 1
a136 1
int
a138 4
	if (sp->state != CLIENT_INIT)
		return (-1);

#ifndef CLIENT_NO_SSL
a139 5

	return (0);
#else
	return (-1);
#endif
a142 2
 * client_certificate()
 *
d145 1
a145 1
int
a148 5
	int	 rv = -1;

	if (sp->state != CLIENT_INIT && sp->state != CLIENT_SSL_INIT)
		goto done;

d150 1
a150 1
		goto done;
d152 1
a152 1
		goto done;
a156 12

	rv = 0;
done:
	if (rv) {
		free(sp->auth.cert);
		free(sp->auth.key);
		sp->auth.cert = NULL;
		sp->auth.certsz = 0;
		sp->auth.key = NULL;
		sp->auth.keysz = 0;
	}
	return (rv);
a159 2
 * client_auth()
 *
d162 1
a162 1
int
a164 5
	int	 rv = -1;

	if (sp->state != CLIENT_INIT && sp->state != CLIENT_SSL_INIT)
		goto done;

d166 1
a166 1
		goto done;
a169 8

	rv = 0;
done:
	if (rv) {
		free(sp->auth.plain);
		sp->auth.plain = NULL;
	}
	return (rv);
a172 2
 * client_sender()
 *
d175 1
a175 1
int
a178 15
	char		*mbox = NULL;
	int		 rv = -1;

	va_start(ap, fmt);

	/* check if too late */
	switch (sp->state) {
	case CLIENT_INIT:
	case CLIENT_SSL_INIT:
	case CLIENT_EHLO:
	case CLIENT_HELO:
		break;
	default:
		goto done;
	}
a179 2
	if (vasprintf(&mbox, fmt, ap) == -1)
		goto done;
a180 1
	sp->sender = mbox;
d182 3
a184 2
	rv = 0;
done:
a185 3
	if (rv)
		free(mbox);
	return (rv);
a188 2
 * client_rcpt()
 *
d191 2
a192 2
int
client_rcpt(struct smtp_client *sp, char *fmt, ...)
d196 4
a199 1
	int		 rv = -1;
d202 3
a205 16
	/* check if too late */
	switch (sp->state) {
	case CLIENT_INIT:
	case CLIENT_SSL_INIT:
	case CLIENT_EHLO:
	case CLIENT_HELO:
	case CLIENT_MAILFROM:
		break;
	default:
		goto done;
	}

	if ((rp = calloc(1, sizeof(*rp))) == NULL)
		goto done;
	if (vasprintf(&rp->mbox, fmt, ap) == -1)
		goto done;
d207 1
a207 10

	rv = 0;
done:
	va_end(ap);
	if (rv) {
		if (rp)
			free(rp->mbox);
		free(rp);
	}
	return (rv);
a210 2
 * client_data_fd()
 *
d213 1
a213 1
int
d217 1
a217 2
	char		*map = NULL;
	int		 rv = -1;
d220 1
a220 1
		goto done;
d222 1
a222 1
		goto done;
d224 1
a224 1
		goto done;
d228 1
a228 1
		goto done;
d230 2
a231 9

	if (client_data_add(sp, map, sb.st_size) < 0)
		goto done;

	rv = 0;
done:
	if (map)
		munmap(map, sb.st_size);
	return (rv);
a234 2
 * client_data_printf()
 *
d237 1
a237 1
int
d242 1
a242 1
	int	 len, rv = -1;
d246 1
a246 7
		goto done;

	if (client_data_add(sp, p, len) < 0)
		goto done;

	rv = 0;
done:
d248 1
a249 1
	return (rv);
d253 1
a253 3
 * client_udata_set()
 *
 * Associate user pointer with the most recently recorded recipient.
d255 2
a256 2
void
client_udata_set(struct smtp_client *sp, void *p)
d258 3
a260 1
	struct rcpt *lastrcpt;
d262 4
a265 3
	lastrcpt = TAILQ_LAST(&sp->recipients, rlist);
	lastrcpt->udata = p;
}
d267 1
a267 9
/*
 * client_udata_get()
 *
 * Return user pointer associated with most recently sent recipient.
 */
void *
client_udata_get(struct smtp_client *sp)
{
	return (sp->rcptsent->udata);
a270 2
 * client_read()
 *
a275 2
	int	 rv = CLIENT_ERROR;

d295 2
a296 3
			strlcpy(sp->ebuf, "130 ssl_buf_read error",
			    sizeof(sp->ebuf));
			return (CLIENT_ERROR);
d305 2
a306 2
				snprintf(sp->ebuf, sizeof(sp->ebuf),
				    "130 buf_read: %s", strerror(errno));
d308 3
a310 3
				snprintf(sp->ebuf, sizeof(sp->ebuf),
				    "130 buf_read: connection closed");
			return (CLIENT_ERROR);
d316 1
a316 1
		return (CLIENT_ERROR);
d331 2
a332 2
		memcpy(sp->reply, "190", 3);
		goto done;
d338 1
a338 1
			goto done;
d347 1
a347 1
				goto done;
d354 1
a354 1
			return (CLIENT_ERROR);
d359 1
a359 1
			goto done;
d368 1
a368 1
				return (CLIENT_ERROR);
d380 1
a380 1
			return (CLIENT_ERROR);
d385 1
a385 1
			goto done;
d391 8
a398 5
		if (*sp->reply != '2') {
			rv = CLIENT_RCPT_FAIL;
			goto done;
		} else if (TAILQ_NEXT(sp->rcptsent, entry) == NULL)
			sp->state = CLIENT_DATA;
d403 1
a403 1
			goto done;
d409 4
a412 3
		if (*sp->reply == '2')
			rv = CLIENT_DONE;
		goto done;
d415 1
a415 1
		abort();
d418 7
a424 5
	rv = CLIENT_WANT_WRITE;
done:
	if (rv == CLIENT_ERROR)
		strlcpy(sp->ebuf, sp->reply, sizeof(sp->ebuf));
	return (rv);
a427 2
 * client_write()
 *
a432 1
	int	 rv = CLIENT_ERROR;
d446 1
a446 2
		if (sp->verbose)
			fprintf(sp->verbose, "client: ssl handshake started\n");
d451 2
a452 3
			strlcpy(sp->ebuf, "130 SSL init failed",
			    sizeof(sp->ebuf));
			return (CLIENT_ERROR);
d472 2
a473 3
		if (client_putln(sp, "%sLO %s",
		    sp->state == CLIENT_EHLO ? "EH" : "HE", sp->ehlo) < 0)
			goto done;
d477 1
a477 2
		if (client_putln(sp, "AUTH PLAIN %s", sp->auth.plain) < 0)
			goto done;
d481 1
a481 2
		if (client_putln(sp, "STARTTLS") < 0)
			goto done;
d485 1
a485 2
		if (client_putln(sp, "MAIL FROM:<%s>", sp->sender) < 0)
			goto done;
d489 8
a496 10
		if (sp->rcptsent == NULL)
			sp->rcptsent = TAILQ_FIRST(&sp->recipients);
		else
			sp->rcptsent = TAILQ_NEXT(sp->rcptsent, entry);

		if (sp->rcptsent == NULL)
			goto done;

		if (client_putln(sp, "RCPT TO:<%s>", sp->rcptsent->mbox) < 0)
			goto done;
d500 2
a501 2
		if (client_putln(sp, "DATA") < 0)
			goto done;
d505 3
a507 5
		if (buf_add(sp->data, ".\r\n", 3) < 0) {
			strlcpy(sp->ebuf, "190 buf_add error",
			    sizeof(sp->ebuf));
			goto done;
		}
d512 5
d518 1
a518 1
		abort();
d529 1
a529 2
			rv = CLIENT_WANT_READ;
			goto done;
d532 1
a532 2
			rv = CLIENT_WANT_WRITE;
			goto done;
d535 2
a536 3
			strlcpy(sp->ebuf, "130 ssl_buf_write error",
			    sizeof(sp->ebuf));
			goto done;
d543 2
a544 3
			strlcpy(sp->ebuf, "130 buf_write error",
			    sizeof(sp->ebuf));
			goto done;
d548 7
a554 3
	rv = sp->w.queued ? CLIENT_WANT_WRITE : CLIENT_WANT_READ;
done:
	return (rv);
a558 2
 * client_ssl_connect()
 *
a568 3
	case SSL_ERROR_NONE:
		break;

d575 3
d579 1
a579 2
		if (sp->verbose)
			fprintf(sp->verbose, "client: ssl handshake failed\n");
a582 1

d585 4
d590 1
a590 8
			if ((sp->state = client_next_state(sp)) == 0)
				return (CLIENT_ERROR);
			else
				return (CLIENT_WANT_WRITE);
		} else {
			strlcpy(sp->ebuf, "130 SSL_connect error", sizeof(sp->ebuf));
			return (CLIENT_ERROR);
		}
d593 1
a593 2
	if (sp->verbose)
		fprintf(sp->verbose, "client: ssl handshake completed\n");
a606 27
 * client_strerror()
 *
 * Access error string explaining most recent client_{read,write} failure.
 */
char *
client_strerror(struct smtp_client *sp)
{
	if (sp->ebuf[0] == '\0')
		return (NULL);
	else
		return (sp->ebuf);
}

/*
 * client_reply()
 *
 * Access string containing most recent server reply.
 */
char *
client_reply(struct smtp_client *sp)
{
	return (sp->reply);
}

/*
 * client_close()
 *
a635 2
 * client_next_state()
 *
d652 1
a652 2
				snprintf(sp->ebuf, sizeof(sp->ebuf),
				     "%s %s", e->name,
d663 2
a664 3
 * client_timeout()
 *
 * Return a timeout that applies to the current session state.
d666 2
a667 2
struct timeval *
client_timeout(struct smtp_client *sp)
d669 1
a669 4
	switch (sp->state) {
	case CLIENT_DATA:
		sp->timeout.tv_sec = 120;
		break;
d671 3
a673 6
	case CLIENT_DATA_BODY:
		if (sp->w.queued)
			sp->timeout.tv_sec = 180;
		else
			sp->timeout.tv_sec = 600;
		break;
d675 4
a678 7
	default:
		sp->timeout.tv_sec = 300;
	}

	sp->timeout.tv_usec = 0;

	return (&sp->timeout);
a681 2
 * client_getln()
 *
d703 1
a703 2
		if (sp->verbose)
			fprintf(sp->verbose, "<<< %s\n", ln);
d753 1
a753 1
		strlcpy(sp->ebuf, cause, sizeof(sp->ebuf));
a758 2
 * client_putln()
 *
d761 1
a761 1
int
d766 1
a766 1
	int		 len, rv = -1;
d771 2
a772 1
		goto done;
d774 1
a774 2
	if (sp->verbose)
		fprintf(sp->verbose, ">>> %s\n", p);
d777 1
a777 1
		goto done;
d779 1
a779 1
		goto done;
d781 1
a781 1
		goto done;
a782 1
	cmd = NULL;
a783 6

	rv = 0;
done:
	if (rv)
		snprintf(sp->ebuf, sizeof(sp->ebuf), "190 %s", strerror(errno));
	va_end(ap);
a784 3
	if (cmd)
		buf_free(cmd);
	return (rv);
a787 2
 * client_data_add()
 *
d790 1
a790 1
int
a794 13
	/* check if too late */
	switch (sp->state) {
	case CLIENT_INIT:
	case CLIENT_SSL_INIT:
	case CLIENT_EHLO:
	case CLIENT_HELO:
	case CLIENT_MAILFROM:
	case CLIENT_RCPTTO:
		break;
	default:
		return (-1);
	}

d797 1
a797 1
		return (-1);
d803 1
a803 1
			return (-1);
d805 1
a805 1
			return (-1);
d807 1
a807 1
			return (-1);
a808 2

	return (0);
a811 2
 * buf_getln()
 *
a843 2
 * buf_read()
 *
@


1.16
log
@Check if the receive buffer has any unused space before reading from socket in
buf_read (and in ssl_buf_read).
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.15 2009/11/11 11:41:05 jacekm Exp $	*/
d463 1
@


1.15
log
@Fix crlf issue in buf_getln, similar to that in smtp_session.c r1.123.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.14 2009/11/11 11:25:17 jacekm Exp $	*/
d440 1
d442 6
a447 2
			strlcpy(sp->ebuf, "130 buf_read error",
			    sizeof(sp->ebuf));
a886 2
			else if (sp->r.wpos >= sizeof(sp->r.buf))
				cause = "150 reply too big";
d1072 2
d1076 6
a1081 2
	n = read(fd, r->buf + r->wpos, sizeof(r->buf) - r->wpos);
	if (n == -1) {
d1085 1
a1085 4
	}

	if (n == 0) {
		errno = 0;
a1086 1
	}
@


1.14
log
@improve buf_getln readability, no fuctional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.13 2009/11/11 10:27:41 jacekm Exp $	*/
a4 1
 * Copyright (c) 2002, 2003 Niels Provos <provos@@citi.umich.edu>
d1040 1
a1040 1
		if (buf[i] == '\r' || buf[i] == '\n')
d1046 1
a1046 1
        if ((line = malloc(i + 1)) == NULL)
d1048 5
a1052 2
        memcpy(line, buf, i);
        line[i] = '\0';
a1054 6
	if (i < bufsz - 1) {
		char fch = buf[i], sch = buf[i + 1];

		if ((sch == '\r' || sch == '\n') && sch != fch)
			i += 1;
	}
@


1.13
log
@Ensure all replies are at least 4 chars long.  If only 3 chars were
received, append a space character.  This enables other parts of
the daemon to safely index into 4th character of the reply buffer
without the risk of accessing one byte beyond NUL.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.12 2009/11/10 14:57:03 jacekm Exp $	*/
d1036 2
a1037 2
	char	*line;
	size_t	 i;
d1040 2
a1041 2
	for (i = 0; i < r->wpos; i++)
		if (r->buf[i] == '\r' || r->buf[i] == '\n')
d1043 1
a1043 1
	if (i == r->wpos)
d1049 1
a1049 1
        memcpy(line, r->buf, i);
d1053 2
a1054 2
	if (i < r->wpos - 1) {
		char fch = r->buf[i], sch = r->buf[i + 1];
d1059 1
a1059 1
	memmove(r->buf, r->buf + i + 1, r->wpos - i - 1);
@


1.12
log
@Eliminate space after colon in "RCPT TO:" as required by RFC.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.11 2009/11/10 14:54:13 jacekm Exp $	*/
d893 14
a906 3
		if (strlen(ln) == 3)
			break;
		else if (strlen(ln) < 4 || (ln[3] != ' ' && ln[3] != '-')) {
@


1.11
log
@In absence of the ehlo parameter, generate one based on locally
bound IP address ("EHLO [1.2.3.4]") as dictated by RFC.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.10 2009/11/10 00:24:53 jacekm Exp $	*/
d633 1
a633 1
		if (client_putln(sp, "RCPT TO: <%s>", sp->rcptsent->mbox) < 0)
@


1.10
log
@Check for extension keywords on final multiline reply.  Skip the
check for states other than CLIENT_EHLO.  Verify response is not
shorter than 3 chars.

From Nils Frohberg
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.9 2009/10/25 20:43:29 chl Exp $	*/
d22 1
d30 1
d71 14
a84 1
	if ((sp->ehlo = strdup(ehlo)) == NULL)
@


1.9
log
@Fix potential null dereference.

Found by LLVM/Clang Static Analyzer.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.8 2009/10/19 19:53:05 gilles Exp $	*/
d878 1
a878 1
		if (strlen(ln) == 3 || ln[3] == ' ')
d880 2
a881 2
		else if (ln[3] != '-') {
			cause = "150 garbled multiline reply";
d885 9
a893 4
		if (strcmp(ln + 4, "STARTTLS") == 0)
			sp->exts[CLIENT_EXT_STARTTLS].have = 1;
		if (strncmp(ln + 4, "AUTH", 4) == 0)
			sp->exts[CLIENT_EXT_AUTH].have = 1;
@


1.8
log
@fix compile time warning due to missing cast
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.7 2009/10/03 10:02:43 jacekm Exp $	*/
d94 1
a94 1
	if (rv) {
@


1.7
log
@Avoid NULL dereference when the final RCPT TO is refused.
Reported by Didier Wiroth <dwiroth@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.6 2009/09/22 15:44:31 jacekm Exp $	*/
d318 1
a318 1
	if (sb.st_size > SIZE_T_MAX)
@


1.6
log
@Make the error messages for failures at EHLO more precise by
distinguishing between unavailable extensions and those that are
available but have failed.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.5 2009/09/22 12:24:06 jacekm Exp $	*/
d614 3
@


1.5
log
@When at MAIL FROM stage, handle the case when STARTTLS is required but not
available.  Also, make the client_next_state() calls across the code more
idiomatic.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.4 2009/09/17 23:51:23 jacekm Exp $	*/
d807 2
a808 1
				    "150 Could not use %s", e->name);
@


1.4
log
@The client API is meant to require STARTTLS by default, a behaviour which
can be altered using client_ssl_optional().
Reported by Michael Lechtermann <michael@@lechtermann.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.3 2009/09/15 16:50:06 jacekm Exp $	*/
d84 1
d90 1
d471 2
a472 1
		sp->state = client_next_state(sp);
d485 2
a486 4
			if (client_next_state(sp))
				sp->state = client_next_state(sp);
			else
				goto done;
d497 2
a498 4
		if (client_next_state(sp))
			sp->state = client_next_state(sp);
		else
			goto done;
d707 3
a709 2
			if (client_next_state(sp)) {
				sp->state = client_next_state(sp);
a710 5
			} else {
				strlcpy(sp->ebuf, "130 SSL_connect error",
				    sizeof(sp->ebuf));
				return (CLIENT_ERROR);
			}
d805 3
a807 1
			else if (e->must)
d809 1
@


1.3
log
@Extend SMTP client_* API to support SSL+AUTH, and use it in the mta
process to relay mails.  ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.2 2009/08/27 11:42:50 jacekm Exp $	*/
d81 2
a82 2
	sp->exts[CLIENT_EXT_STARTTLS].want = 0;
	sp->exts[CLIENT_EXT_STARTTLS].must = 0;
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 2
d40 4
a43 3
int		 client_readln(struct smtp_client *, char **);
int		 client_writeln(struct smtp_client *, char *, ...);
int		 client_error(struct smtp_client *, char **, char *);
d45 8
d54 1
d56 5
d71 2
d79 11
a89 1
	
d92 1
a92 1
	if (rv < 0) {
d94 1
d103 5
d109 91
a199 1
client_verbose(struct smtp_client *sp, int fd)
d201 18
a218 1
	sp->verbose = fdopen(fd, "w");
d221 5
d238 1
d248 1
a248 2
	if (sp->sender)
		free(sp->sender);
d254 1
a254 1
	if (rv < 0)
d259 5
d276 1
d294 1
a294 1
	if (rv < 0) {
d302 5
a330 1
	close(fd);
d336 5
d362 30
d393 1
a393 1
client_read(struct smtp_client *sp, char **ep)
d395 1
a395 1
	char	*reply;
d397 4
a400 1
	*ep = NULL;
d402 33
a434 4
	/* read server reply */
	if (client_readln(sp, &reply) < 0)
		return client_error(sp, ep, reply);
	if (reply == NULL)
d437 14
a450 1
	/* send command */
d453 2
a454 2
		if (*reply != '2')
			client_error(sp, ep, reply);
d460 15
a474 2
		if (*reply != '2')
			sp->state = CLIENT_HELO;
d479 19
a497 3
	case CLIENT_HELO:
		if (*reply != '2')
			client_error(sp, ep, reply);
d499 1
a499 1
			sp->state = CLIENT_MAILFROM;
d503 2
a504 2
		if (*reply != '2')
			client_error(sp, ep, reply);
d510 4
a513 3
		if (*reply != '2')
			client_error(sp, ep, reply);
		else if (TAILQ_EMPTY(&sp->recipients))
d518 2
a519 2
		if (*reply != '3')
			client_error(sp, ep, reply);
d525 3
a527 5
		if (*reply != '2')
			client_error(sp, ep, reply);
		else
			return (CLIENT_DONE);
		break;
d530 1
a530 1
		client_error(sp, ep, "invalid state");
a531 1
	free(reply);
d533 5
a537 5
	/* may have been set by client_error */
	if (*ep)
		return (CLIENT_ERROR);

	return (CLIENT_WANT_WRITE);
d540 5
d546 1
a546 1
client_write(struct smtp_client *sp, char **ep)
d548 1
a548 1
	struct rcpt	*rp;
d550 4
a553 1
	*ep = NULL;
d560 22
d583 10
a592 2
		if (client_writeln(sp, "EHLO %s", sp->ehlo) < 0)
			return client_error(sp, ep, NULL);
d595 8
a602 3
	case CLIENT_HELO:
		if (client_writeln(sp, "HELO %s", sp->ehlo) < 0)
			return client_error(sp, ep, NULL);
d606 2
a607 2
		if (client_writeln(sp, "MAIL FROM:<%s>", sp->sender) < 0)
			return client_error(sp, ep, NULL);
d611 7
a617 6
		rp = TAILQ_FIRST(&sp->recipients);
		TAILQ_REMOVE(&sp->recipients, rp, entry);
		if (client_writeln(sp, "RCPT TO:<%s>", rp->mbox) < 0)
			return client_error(sp, ep, NULL);
		free(rp->mbox);
		free(rp);
d621 2
a622 2
		if (client_writeln(sp, "DATA") < 0)
			return client_error(sp, ep, NULL);
d626 5
a630 2
		if (buf_add(sp->data, ".\r\n", 3) == -1)
			return client_error(sp, ep, NULL);
d636 1
a636 1
		return client_error(sp, ep, "invalid state");
d640 34
a673 2
	if (buf_write(&sp->w) < 0)
		return client_error(sp, ep, NULL);
d675 84
a758 1
	return (sp->w.queued ? CLIENT_WANT_WRITE : CLIENT_WANT_READ);
d761 5
d773 3
d784 4
d792 6
d799 1
a799 1
client_readln(struct smtp_client *sp, char **reply)
d801 2
a802 4
	struct buf_read	*r = &sp->r;
	size_t		 i;
	char		*ln = NULL;
	int		 n, rv = -1;
d804 26
a829 1
	*reply = NULL;
d831 3
a833 5
	/* read data from the socket */
	n = read(sp->w.fd, r->buf + r->wpos, sizeof(r->buf) - r->wpos);
	if (n == -1) {
		if (errno == EAGAIN || errno == EINTR)
			rv = 0;
d835 5
a839 2
			*reply = strerror(errno);
		goto done;
d841 18
a858 1
	r->wpos += n;
d863 1
a863 1
		if ((ln = buf_getln(r)) == NULL) {
d865 3
a867 3
				*reply = strerror(errno);
			else if (r->wpos >= sizeof(r->buf))
				*reply = "reply too big";
d879 1
a879 1
			*reply = "garbled multiline reply";
d882 5
d889 1
d891 1
a891 1
		*reply = "reply code out of range"; 
d895 1
d898 1
a898 1
			*reply = "non-printable character in server reply";
d903 1
a903 1
	*reply = ln;
d907 3
a909 2
	if (rv < 0)
		free(ln);
d913 5
d919 1
a919 1
client_writeln(struct smtp_client *sp, char *fmt, ...)
d945 2
d954 5
d967 1
d995 5
a999 12
int
client_error(struct smtp_client *sp, char **ep, char *errormsg)
{
	if (errormsg == NULL)
		errormsg = strerror(errno);
	strlcpy(sp->errbuf, errormsg, sizeof(sp->errbuf));
	*ep = sp->errbuf;
	sp->state = -1;

	return (CLIENT_ERROR);
}

d1030 27
@


1.1
log
@Implement client side of the SMTP protocol in a library-like module.
Make bounce code and /usr/sbin/sendmail interface use this new API.
The mta process continues to use its own implementation, but
eventually will be switched to use this shared module.

Buffer routines are taken from buffer.c rather than from evbuffer.
This is one step forward to using a single buffer API across the
program.

"it looks sexy" gilles@@
@
text
@d1 2
@

