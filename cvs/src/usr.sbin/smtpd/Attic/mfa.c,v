head	1.83;
access;
symbols
	OPENBSD_5_5:1.81.0.2
	OPENBSD_5_5_BASE:1.81
	OPENBSD_5_4:1.79.0.2
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.75.0.2
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.67.0.4
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.2
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.54.0.2
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.36.0.4
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15;
locks; strict;
comment	@ * @;


1.83
date	2014.05.20.08.09.04;	author eric;	state dead;
branches;
next	1.82;

1.82
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.81;

1.81
date	2013.10.27.11.01.47;	author eric;	state Exp;
branches;
next	1.80;

1.80
date	2013.10.27.07.56.25;	author eric;	state Exp;
branches;
next	1.79;

1.79
date	2013.07.19.16.02.00;	author eric;	state Exp;
branches;
next	1.78;

1.78
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.77;

1.77
date	2013.07.19.07.49.08;	author eric;	state Exp;
branches;
next	1.76;

1.76
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.75;

1.75
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.74;

1.74
date	2012.11.23.13.54.12;	author eric;	state Exp;
branches;
next	1.73;

1.73
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.72;

1.72
date	2012.10.25.14.06.08;	author eric;	state Exp;
branches;
next	1.71;

1.71
date	2012.09.29.11.02.41;	author eric;	state Exp;
branches;
next	1.70;

1.70
date	2012.09.27.17.58.56;	author chl;	state Exp;
branches;
next	1.69;

1.69
date	2012.09.19.19.40.36;	author eric;	state Exp;
branches;
next	1.68;

1.68
date	2012.09.16.16.43.28;	author chl;	state Exp;
branches;
next	1.67;

1.67
date	2012.01.18.13.41.54;	author chl;	state Exp;
branches;
next	1.66;

1.66
date	2011.11.14.19.23.41;	author chl;	state Exp;
branches;
next	1.65;

1.65
date	2011.11.10.17.37.08;	author chl;	state Exp;
branches;
next	1.64;

1.64
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.63;

1.63
date	2011.10.09.18.39.53;	author eric;	state Exp;
branches;
next	1.62;

1.62
date	2011.09.27.18.53.24;	author chl;	state Exp;
branches;
next	1.61;

1.61
date	2011.08.31.18.56.30;	author gilles;	state Exp;
branches;
next	1.60;

1.60
date	2011.08.27.22.32.41;	author gilles;	state Exp;
branches;
next	1.59;

1.59
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2011.04.17.11.39.22;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.54;

1.54
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.52;

1.52
date	2010.10.29.09.16.07;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2010.10.28.21.15.50;	author gilles;	state Exp;
branches;
next	1.50;

1.50
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.02.19.16.53;	author chl;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.21.08.29.01;	author jacekm;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.20.15.34.56;	author jacekm;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.18.20.41.21;	author gilles;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.12.22.34.37;	author gilles;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.07.18.19.39;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.07.18.09.12;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.07.17.30.41;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.03.08.19.13;	author jacekm;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.01.23.15.48;	author gilles;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.01.22.51.47;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.01.13.20.56;	author jacekm;	state Exp;
branches;
next	1.31;

1.31
date	2009.05.24.14.38.56;	author jacekm;	state Exp;
branches;
next	1.30;

1.30
date	2009.05.21.01.07.13;	author gilles;	state Exp;
branches;
next	1.29;

1.29
date	2009.05.20.16.07.26;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2009.05.20.14.36.55;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.20.14.29.44;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.19.11.24.24;	author jacekm;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.14.15.05.12;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2009.04.28.23.11.25;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.28.21.27.25;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.27.16.15.21;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.24.08.32.12;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.21.14.37.32;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.16.15.35.06;	author jacekm;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.29.14.18.20;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.08.19.11.22;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.08.17.54.20;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.22.19.07.33;	author chl;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.18.22.39.12;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.18.16.42.30;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.17.21.38.47;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.15.10.32.23;	author jacekm;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.27.22.48.29;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.04.17.45.58;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.04.16.40.58;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.04.14.46.14;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.04.00.58.59;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.20.00.18.03;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.13.23.19.34;	author jacekm;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.83
log
@remove dead files
@
text
@/*	$OpenBSD: mfa.c,v 1.82 2014/04/04 16:10:42 eric Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>

#include <err.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <inttypes.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

struct mfa_tx {
	uint64_t	 reqid;
	struct io	 io;
	struct iobuf	 iobuf;
	FILE		*ofile;
	size_t		 datain;
	size_t		 datalen;
	int		 eom;
	int		 error;
};

static void mfa_imsg(struct mproc *, struct imsg *);
static void mfa_shutdown(void);
static void mfa_sig_handler(int, short, void *);
static void mfa_tx_io(struct io *, int);
static int mfa_tx(uint64_t, int);
static void mfa_tx_done(struct mfa_tx *);

struct tree tx_tree;

static void
mfa_imsg(struct mproc *p, struct imsg *imsg)
{
	struct sockaddr_storage	 local, remote;
	struct mailaddr		 maddr;
	struct msg		 m;
	const char		*line, *hostname;
	uint64_t		 reqid;
	uint32_t		 datalen; /* XXX make it off_t? */
	int			 v, success, fdout;

	if (p->proc == PROC_PONY) {
		switch (imsg->hdr.type) {
		case IMSG_SMTP_REQ_CONNECT:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_sockaddr(&m, (struct sockaddr *)&local);
			m_get_sockaddr(&m, (struct sockaddr *)&remote);
			m_get_string(&m, &hostname);
			m_end(&m);
			mfa_filter_connect(reqid, (struct sockaddr *)&local,
			    (struct sockaddr *)&remote, hostname);
			return;

		case IMSG_SMTP_REQ_HELO:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &line);
			m_end(&m);
			mfa_filter_line(reqid, HOOK_HELO, line);
			return;

		case IMSG_SMTP_REQ_MAIL:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_mailaddr(&m, &maddr);
			m_end(&m);
			mfa_filter_mailaddr(reqid, HOOK_MAIL, &maddr);
			return;

		case IMSG_SMTP_REQ_RCPT:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_mailaddr(&m, &maddr);
			m_end(&m);
			mfa_filter_mailaddr(reqid, HOOK_RCPT, &maddr);
			return;

		case IMSG_SMTP_REQ_DATA:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_end(&m);
			mfa_filter(reqid, HOOK_DATA);
			return;

		case IMSG_SMTP_REQ_EOM:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_u32(&m, &datalen);
			m_end(&m);
			mfa_filter_eom(reqid, HOOK_EOM, datalen);
			return;

		case IMSG_SMTP_EVENT_RSET:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_end(&m);
			mfa_filter_event(reqid, HOOK_RESET);
			return;

		case IMSG_SMTP_EVENT_COMMIT:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_end(&m);
			mfa_filter_event(reqid, HOOK_COMMIT);
			return;

		case IMSG_SMTP_EVENT_ROLLBACK:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_end(&m);
			mfa_filter_event(reqid, HOOK_ROLLBACK);
			return;

		case IMSG_SMTP_EVENT_DISCONNECT:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_end(&m);
			mfa_filter_event(reqid, HOOK_DISCONNECT);
			return;
		}
	}

	if (p->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_SMTP_MESSAGE_OPEN: /* XXX bogus */
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_int(&m, &success);
			m_end(&m);

			fdout = mfa_tx(reqid, imsg->fd);
			mfa_build_fd_chain(reqid, fdout);
			return;
		}
	}

	if (p->proc == PROC_PARENT) {
		switch (imsg->hdr.type) {
		case IMSG_CONF_START:
			return;

		case IMSG_CONF_END:
			mfa_filter_init();
			return;
			
		case IMSG_CTL_VERBOSE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			log_verbose(v);
			return;

		case IMSG_CTL_PROFILE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			profiling = v;
			return;
		}
	}

	errx(1, "mfa_imsg: unexpected %s imsg", imsg_to_str(imsg->hdr.type));
}

static void
mfa_sig_handler(int sig, short event, void *p)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		mfa_shutdown();
		break;

	case SIGCHLD:
		fatalx("unexpected SIGCHLD");
		break;

	default:
		fatalx("mfa_sig_handler: unexpected signal");
	}
}

static void
mfa_shutdown(void)
{
	pid_t pid;

	do {
		pid = waitpid(WAIT_MYPGRP, NULL, 0);
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	log_info("info: mail filter exiting");
	_exit(0);
}

pid_t
mfa(void)
{
	pid_t		 pid;
	struct passwd	*pw;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct event	 ev_sigchld;

	switch (pid = fork()) {
	case -1:
		fatal("filter: cannot fork");
	case 0:
		post_fork(PROC_MFA);
		break;
	default:
		return (pid);
	}

	mfa_filter_prepare();

	purge_config(PURGE_EVERYTHING);

	if ((pw =  getpwnam(SMTPD_USER)) == NULL)
		fatalx("unknown user " SMTPD_USER);

	config_process(PROC_MFA);

	if (chroot(PATH_CHROOT) == -1)
		fatal("scheduler: chroot");
	if (chdir("/") == -1)
		fatal("scheduler: chdir(\"/\")");

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("filter: cannot drop privileges");

	imsg_callback = mfa_imsg;
	event_init();

	signal_set(&ev_sigint, SIGINT, mfa_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, mfa_sig_handler, NULL);
	signal_set(&ev_sigchld, SIGCHLD, mfa_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sigchld, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	config_peer(PROC_PARENT);
	config_peer(PROC_CONTROL);
	config_peer(PROC_PONY);
	config_done();

	mproc_disable(p_pony);

	if (event_dispatch() < 0)
		fatal("event_dispatch");
	mfa_shutdown();

	return (0);
}

void
mfa_ready(void)
{
	log_debug("debug: mfa ready");
	mproc_enable(p_pony);
}

static int
mfa_tx(uint64_t reqid, int fdout)
{
	struct mfa_tx	*tx;
	int		 sp[2];

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, sp) == -1) {
		log_warn("warn: mfa: socketpair");
		return (-1);
	}

	tx = xcalloc(1, sizeof(*tx), "mfa_tx");

	if ((tx->ofile = fdopen(fdout, "w")) == NULL) {
		log_warn("warn: mfa: fdopen");
		free(tx);
		close(sp[0]);
		close(sp[1]);
		return (-1);
	}

	iobuf_init(&tx->iobuf, 0, 0);
	io_init(&tx->io, sp[0], tx, mfa_tx_io, &tx->iobuf);
	io_set_read(&tx->io);
	tx->reqid = reqid;
	tree_xset(&tx_tree, reqid, tx);

	return (sp[1]);
}

static void
mfa_tx_io(struct io *io, int evt)
{
	struct mfa_tx	*tx = io->arg;
	size_t		 len, n;
	char		*data;

	switch (evt) {
	case IO_DATAIN:
		data = iobuf_data(&tx->iobuf);
		len = iobuf_len(&tx->iobuf);
		log_debug("debug: mfa: tx data (%zu) for req %016"PRIx64,
		    len, tx->reqid);
		n = fwrite(data, 1, len, tx->ofile);
		if (n != len) {
			tx->error = 1;
			break;
		}
		tx->datain += n;
		iobuf_drop(&tx->iobuf, n);
		iobuf_normalize(&tx->iobuf);
		return;

	case IO_DISCONNECTED:
		log_debug("debug: mfa: tx done for req %016"PRIx64,
		    tx->reqid);
		break;

	default:
		log_debug("debug: mfa: tx error for req %016"PRIx64,
		    tx->reqid);
		tx->error = 1;
		break;
	}

	io_clear(&tx->io);
	iobuf_clear(&tx->iobuf);
	fclose(tx->ofile);
	tx->ofile = NULL;
	if (tx->eom)
		mfa_tx_done(tx);
}

static void
mfa_tx_done(struct mfa_tx *tx)
{
	log_debug("debug: mfa: tx done for %016"PRIx64, tx->reqid);

	if (!tx->error && tx->datain != tx->datalen) {
		log_debug("debug: mfa: tx datalen mismatch: %zu/%zu",
		    tx->datain, tx->datalen);
		tx->error = 1;
	}

	if (tx->error) {
		log_debug("debug: mfa: tx error");

		m_create(p_pony, IMSG_MFA_SMTP_RESPONSE, 0, 0, -1);
		m_add_id(p_pony, tx->reqid);
		m_add_int(p_pony, MFA_FAIL);
		m_add_u32(p_pony, 0);
		m_add_string(p_pony, "Internal server error");
		m_close(p_pony);
	}
#if 0
	else
		mfa_filter(tx->reqid, HOOK_EOM);
#endif
	free(tx);
}
@


1.82
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.81
log
@Make the filter infrastructure move forward.
This is a work-in-progress and it's not supposed to be useable for now.
@
text
@d72 1
a72 1
	if (p->proc == PROC_SMTP) {
d74 1
a74 1
		case IMSG_MFA_REQ_CONNECT:
d85 1
a85 1
		case IMSG_MFA_REQ_HELO:
d93 1
a93 1
		case IMSG_MFA_REQ_MAIL:
d101 1
a101 1
		case IMSG_MFA_REQ_RCPT:
d109 1
a109 1
		case IMSG_MFA_REQ_DATA:
d116 1
a116 1
		case IMSG_MFA_REQ_EOM:
d124 1
a124 1
		case IMSG_MFA_EVENT_RSET:
d131 1
a131 1
		case IMSG_MFA_EVENT_COMMIT:
d138 1
a138 1
		case IMSG_MFA_EVENT_ROLLBACK:
d145 1
a145 1
		case IMSG_MFA_EVENT_DISCONNECT:
d156 1
a156 1
		case IMSG_QUEUE_MESSAGE_FILE:
a172 3
		case IMSG_CONF_FILTER:
			return;

a277 1
	config_peer(PROC_SMTP);
d279 1
d282 1
a282 1
	mproc_disable(p_smtp);
d295 1
a295 1
	mproc_enable(p_smtp);
d385 6
a390 6
		m_create(p_smtp, IMSG_MFA_SMTP_RESPONSE, 0, 0, -1);
		m_add_id(p_smtp, tx->reqid);
		m_add_int(p_smtp, MFA_FAIL);
		m_add_u32(p_smtp, 0);
		m_add_string(p_smtp, "Internal server error");
		m_close(p_smtp);
@


1.80
log
@Create the control socket in the parent process to abort early if
another smtpd instance is running.  Close the inherited socket in
every forked process but control.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.79 2013/07/19 16:02:00 eric Exp $	*/
d30 1
d41 11
d55 5
d69 2
a70 1
	int			 v;
d119 1
d121 1
a121 9
			mfa_filter(reqid, HOOK_EOM);
			return;

		case IMSG_MFA_SMTP_DATA:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &line);
			m_end(&m);
			mfa_filter_data(reqid, line);
d154 14
d299 101
@


1.79
log
@Move the filter infrastructure forward.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d218 1
@


1.78
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.77 2013/07/19 07:49:08 eric Exp $	*/
a48 1
	struct filter		*filter;
a145 1
			dict_init(&env->sc_filters);
a148 3
			filter = xmemdup(imsg->data, sizeof *filter,
			    "mfa_imsg");
			dict_set(&env->sc_filters, filter->name, filter);
d154 1
a154 1

d216 1
a216 1
		fatal("mfa: cannot fork");
d223 2
d232 5
d240 1
a240 1
		fatal("mfa: cannot drop privileges");
@


1.77
log
@Remove useless sc_pid from struct smtpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.76 2013/05/24 17:03:14 eric Exp $	*/
d230 2
a231 4
	if ((env->sc_pw =  getpwnam(SMTPD_FILTER_USER)) == NULL)
		if ((env->sc_pw =  getpwnam(SMTPD_USER)) == NULL)
			fatalx("unknown user " SMTPD_USER);
	pw = env->sc_pw;
@


1.76
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.75 2013/01/26 09:37:23 gilles Exp $	*/
a222 1
		env->sc_pid = getpid();
@


1.75
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.73 2012/11/12 14:58:53 eric Exp $	*/
a23 1
#include <sys/param.h>
@


1.74
log
@knf
@
text
@d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d41 1
a41 1
static void mfa_imsg(struct imsgev *, struct imsg *);
a43 11
static void mfa_test_connect(struct envelope *);
static void mfa_test_helo(struct envelope *);
static void mfa_test_mail(struct envelope *);
static void mfa_test_rcpt(struct envelope *);
static void mfa_test_rcpt_resume(struct submit_status *);
static void mfa_test_dataline(struct submit_status *);
static void mfa_test_quit(struct envelope *);
static void mfa_test_close(struct envelope *);
static void mfa_test_rset(struct envelope *);
static int mfa_strip_source_route(char *, size_t);
static int mfa_fork_filter(struct filter *);
d46 1
a46 1
mfa_imsg(struct imsgev *iev, struct imsg *imsg)
d48 7
a54 1
	struct filter *filter;
d56 1
a56 1
	if (iev->proc == PROC_SMTP) {
d58 83
a140 42
		case IMSG_MFA_CONNECT:
			mfa_test_connect(imsg->data);
			return;
		case IMSG_MFA_HELO:
			mfa_test_helo(imsg->data);
			return;
		case IMSG_MFA_MAIL:
			mfa_test_mail(imsg->data);
			return;
		case IMSG_MFA_RCPT:
			mfa_test_rcpt(imsg->data);
			return;
		case IMSG_MFA_DATALINE:
			mfa_test_dataline(imsg->data);
			return;
		case IMSG_MFA_QUIT:
			mfa_test_quit(imsg->data);
			return;
		case IMSG_MFA_CLOSE:
			mfa_test_close(imsg->data);
			return;
		case IMSG_MFA_RSET:
			mfa_test_rset(imsg->data);
			return;
		}
	}

	if (iev->proc == PROC_LKA) {
		switch (imsg->hdr.type) {
		case IMSG_LKA_MAIL:
			imsg_compose_event(env->sc_ievs[PROC_SMTP],
			    IMSG_MFA_MAIL, 0, 0, -1, imsg->data,
			    sizeof(struct submit_status));
			return;
		case IMSG_LKA_RCPT:
			imsg_compose_event(env->sc_ievs[PROC_SMTP],
			    IMSG_MFA_RCPT, 0, 0, -1, imsg->data,
			    sizeof(struct submit_status));
			return;

		case IMSG_LKA_RULEMATCH:
			mfa_test_rcpt_resume(imsg->data);
d145 1
a145 1
	if (iev->proc == PROC_PARENT) {
d148 1
a148 3
			env->sc_filters = xcalloc(1, sizeof *env->sc_filters,
			    "mfa_imsg");
			TAILQ_INIT(env->sc_filters);
d154 1
a154 1
			TAILQ_INSERT_TAIL(env->sc_filters, filter, f_entry);
d158 1
a158 6
			TAILQ_FOREACH(filter, env->sc_filters, f_entry) {
				log_info("info: Forking filter: %s",
				    filter->name);
				if (! mfa_fork_filter(filter))
					fatalx("could not fork filter");
			}
d162 11
a172 1
			log_verbose(*(int *)imsg->data);
a201 5
	struct filter *filter;

	TAILQ_FOREACH(filter, env->sc_filters, f_entry) {
		kill(filter->pid, SIGTERM);
	}
a210 1

a215 1

a219 7
	struct peer peers[] = {
		{ PROC_PARENT,	imsg_dispatch },
		{ PROC_SMTP,	imsg_dispatch },
		{ PROC_LKA,	imsg_dispatch },
		{ PROC_CONTROL,	imsg_dispatch }
	};

d224 1
d234 1
a234 1
			fatalx("unknown user " SMTPD_FILTER_USER);
d237 1
a237 2
	smtpd_process = PROC_MFA;
	setproctitle("%s", env->sc_title[smtpd_process]);
a246 3
	SPLAY_INIT(&env->mfa_sessions);
	TAILQ_INIT(env->sc_filters);

d256 6
a261 2
	config_pipes(peers, nitems(peers));
	config_peers(peers, nitems(peers));
d270 2
a271 14
static void
mfa_test_connect(struct envelope *e)
{
	struct submit_status	 ss;

	ss.id = e->session_id;
	ss.code = 530;
	ss.envelope = *e;

	mfa_session(&ss, S_CONNECTED);
}

static void
mfa_test_helo(struct envelope *e)
d273 2
a274 182
	struct submit_status	 ss;

	ss.id = e->session_id;
	ss.code = 530;
	ss.envelope = *e;

	mfa_session(&ss, S_HELO);
}

static void
mfa_test_mail(struct envelope *e)
{
	struct submit_status	 ss;

	ss.id = e->session_id;
	ss.code = 530;
	ss.u.maddr = e->sender;

	if (mfa_strip_source_route(ss.u.maddr.user, sizeof(ss.u.maddr.user)))
		goto refuse;

	if (! valid_localpart(ss.u.maddr.user) ||
	    ! valid_domainpart(ss.u.maddr.domain)) {
		/*
		 * "MAIL FROM:<>" is the exception we allow.
		 */
		if (!(ss.u.maddr.user[0] == '\0' &&
			ss.u.maddr.domain[0] == '\0'))
			goto refuse;
	}

	mfa_session(&ss, S_MAIL_MFA);
	return;

refuse:
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_MAIL, 0, 0, -1,
	    &ss, sizeof(ss));
	return;
}

static void
mfa_test_rcpt(struct envelope *e)
{
	struct submit_status	 ss;

	ss.id = e->session_id;
	ss.code = 530;
	ss.u.maddr = e->rcpt;
	ss.ss = e->ss;
	ss.envelope = *e;
	ss.envelope.dest = e->rcpt;
	ss.flags = e->flags;

	mfa_strip_source_route(ss.u.maddr.user, sizeof(ss.u.maddr.user));

	if (! valid_localpart(ss.u.maddr.user) ||
	    ! valid_domainpart(ss.u.maddr.domain))
		goto refuse;

	mfa_session(&ss, S_RCPT_MFA);
	return;

refuse:
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT, 0, 0, -1,
	    &ss, sizeof(ss));
}

static void
mfa_test_rcpt_resume(struct submit_status *ss)
{
	if (ss->code != 250) {
		imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT, 0, 0,
		    -1, ss, sizeof(*ss));
		return;
	}

	ss->envelope.dest = ss->u.maddr;
	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_RCPT, 0, 0, -1,
	    ss, sizeof(*ss));
}

static void
mfa_test_dataline(struct submit_status *ss)
{
	ss->code = 250;

	mfa_session(ss, S_DATACONTENT);
}

static void
mfa_test_quit(struct envelope *e)
{
	struct submit_status	 ss;

	ss.id = e->session_id;
	ss.code = 530;
	ss.envelope = *e;

	mfa_session(&ss, S_QUIT);
}

static void
mfa_test_close(struct envelope *e)
{
	struct submit_status	 ss;

	ss.id = e->session_id;
	ss.code = 530;
	ss.envelope = *e;

	mfa_session(&ss, S_CLOSE);
}

static void
mfa_test_rset(struct envelope *e)
{
	struct submit_status	 ss;

	ss.id = e->session_id;
	ss.code = 530;
	ss.envelope = *e;

	mfa_session(&ss, S_RSET);
}

static int
mfa_strip_source_route(char *buf, size_t len)
{
	char *p;

	p = strchr(buf, ':');
	if (p != NULL) {
		p++;
		memmove(buf, p, strlen(p) + 1);
		return 1;
	}

	return 0;
}

static int
mfa_fork_filter(struct filter *filter)
{
	pid_t	pid;
	int	sockpair[2];

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, sockpair) < 0)
		return 0;

	session_socket_blockmode(sockpair[0], BM_NONBLOCK);
	session_socket_blockmode(sockpair[1], BM_NONBLOCK);

	filter->ibuf = calloc(1, sizeof(struct imsgbuf));
	if (filter->ibuf == NULL)
		goto err;

	pid = fork();
	if (pid == -1)
		goto err;

	if (pid == 0) {
		/* filter */
		dup2(sockpair[0], STDIN_FILENO);

		if (closefrom(STDERR_FILENO + 1) < 0)
			exit(1);

		execl(filter->path, filter->name, NULL);
		exit(1);
	}

	/* in parent */
	close(sockpair[0]);
	imsg_init(filter->ibuf, sockpair[1]);

	return 1;

err:
	free(filter->ibuf);
	close(sockpair[0]);
	close(sockpair[1]);
	return 0;
@


1.73
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.72 2012/10/25 14:06:08 eric Exp $	*/
d118 2
a119 1
			filter = xmemdup(imsg->data, sizeof *filter, "mfa_imsg");
d125 2
a126 1
				log_info("info: Forking filter: %s", filter->name);
d285 2
a286 1
		if (!(ss.u.maddr.user[0] == '\0' && ss.u.maddr.domain[0] == '\0'))
d294 2
a295 2
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_MAIL, 0, 0, -1, &ss,
	    sizeof(ss));
d313 1
a313 1
	
d322 2
a323 2
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT, 0, 0, -1, &ss,
	    sizeof(ss));
d330 2
a331 2
		imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT, 0, 0, -1, ss,
		    sizeof(*ss));
d422 1
a422 1
		
@


1.72
log
@send the semantically correct msg when RCPT fails, even if the exact value
does not matter.

spotted by chl@@

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.71 2012/09/29 11:02:41 eric Exp $	*/
d124 1
a124 1
				log_info("forking filter: %s", filter->name);
d171 1
a171 1
	log_info("mail filter exiting");
@


1.71
log
@some mfa_session cleanups.

- move mfa_session() prototype to smtpd.h
- make mfa session use a tree
- make static functions static
- merge mfa_session_init() into mfa_session()

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.70 2012/09/27 17:58:56 chl Exp $	*/
d93 4
d99 1
a99 1
			    IMSG_MFA_MAIL, 0, 0, -1, imsg->data,
@


1.70
log
@simplify calloc() + strlcpy()/memcpy() dance with xmemdup()
use xcalloc() helper
remove newly unused variable

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.69 2012/09/19 19:40:36 eric Exp $	*/
a54 1
void mfa_session(struct submit_status *, enum session_state);
@


1.69
log
@Set envelope expirancy in lka before sending the envelope to mfa.
The goal is to eventually have only the lka see the rules.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.68 2012/09/16 16:43:28 chl Exp $	*/
d109 2
a110 3
			env->sc_filters = calloc(1, sizeof *env->sc_filters);
			if (env->sc_filters == NULL)
				fatal(NULL);
d115 1
a115 4
			filter = calloc(1, sizeof *filter);
			if (filter == NULL)
				fatal(NULL);
			memcpy(filter, (struct filter *)imsg->data, sizeof (*filter));
@


1.68
log
@Factorize log_imsg() in imsg_dispatch() instead of in each imsg_callback()'s
and put it out of profiling, so it's not accounted.

While there, for PROC_PARENT:
- set smtpd_process for PROC_PARENT
- use setproctitle() like other processes

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.67 2012/01/18 13:41:54 chl Exp $	*/
a333 1
	ss->envelope.expire = ss->envelope.rule.r_qexpire;
@


1.67
log
@Add new filters callbacks for:
- network events (CONNECT/CLOSE)
- commands (QUIT/RSET)

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.66 2011/11/14 19:23:41 chl Exp $	*/
a60 2

	log_imsg(PROC_MFA, iev->proc, imsg);
@


1.66
log
@when receiving an unexpected imsg, print its name.

with help and ideas from eric@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.65 2011/11/10 17:37:08 chl Exp $	*/
d44 1
d50 3
d66 3
d81 9
d246 12
a266 1
	return;
d327 2
a328 1
mfa_test_rcpt_resume(struct submit_status *ss) {
d347 36
@


1.65
log
@Use STDIN_FILENO instead of magic constant 0

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.64 2011/10/23 09:30:07 gilles Exp $	*/
d27 1
d123 1
a123 1
	fatalx("mfa_imsg: unexpected imsg");
@


1.64
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.63 2011/10/09 18:39:53 eric Exp $	*/
d357 1
a357 1
		dup2(sockpair[0], 0);
@


1.63
log
@show messages sent between processes in debug mode

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.62 2011/09/27 18:53:24 chl Exp $	*/
d248 1
a248 1
	ss.u.maddr = e->delivery.from;
d278 2
a279 2
	ss.u.maddr = e->delivery.rcpt_orig;
	ss.ss = e->delivery.ss;
d281 2
a282 2
	ss.envelope.delivery.rcpt = e->delivery.rcpt_orig;
	ss.flags = e->delivery.flags;
d306 2
a307 2
	ss->envelope.delivery.rcpt = ss->u.maddr;
	ss->envelope.delivery.expire = ss->envelope.rule.r_qexpire;
@


1.62
log
@check closefrom() return value
use STDERR_FILENO instead of hard coded value

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.61 2011/08/31 18:56:30 gilles Exp $	*/
d56 2
@


1.61
log
@add support for per-line DATA callbacks, this allows filters to take their
decisions *while* the message is being received by the client.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.60 2011/08/27 22:32:41 gilles Exp $	*/
d357 2
a358 1
		closefrom(3);
@


1.60
log
@initial support for a session-time filtering API

currently only HELO/EHLO, MAIL, RCPT are supported, however ... I have
voluntarily disabled filters at smtpd.conf level so people don't play with
it until the API has stabilized a bit

discussed with several people in private, no one opposed the feature
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.59 2011/05/16 21:05:52 gilles Exp $	*/
d47 1
d68 3
d308 8
@


1.59
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.58 2011/05/01 12:57:11 eric Exp $	*/
d21 1
d27 1
d31 1
d43 1
d48 2
d54 2
d58 3
a63 1

d87 23
d127 5
d140 11
d164 1
d184 3
a188 5
	if (chroot(pw->pw_dir) == -1)
		fatal("mfa: chroot");
	if (chdir("/") == -1)
		fatal("mfa: chdir(\"/\")");

d200 3
d205 1
d208 1
d222 14
a235 1
void
d256 2
a257 2
	/* Current policy is to allow all well-formed addresses. */
	goto accept;
a262 5

accept:
	ss.code = 250;
	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_MAIL, 0,
	    0, -1, &ss, sizeof(ss));
d284 2
a285 2
	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_RULEMATCH, 0, 0, -1,
	    &ss, sizeof(ss));
a286 1
	return;
d318 43
@


1.58
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.57 2011/04/17 13:36:07 gilles Exp $	*/
d170 1
a170 1
mfa_test_mail(struct envelope *m)
d174 1
a174 1
	ss.id = m->id;
d176 1
a176 1
	ss.u.path = m->sender;
d178 1
a178 1
	if (mfa_strip_source_route(ss.u.path.user, sizeof(ss.u.path.user)))
d181 2
a182 2
	if (! valid_localpart(ss.u.path.user) ||
	    ! valid_domainpart(ss.u.path.domain)) {
d186 1
a186 1
		if (!(ss.u.path.user[0] == '\0' && ss.u.path.domain[0] == '\0'))
d205 1
a205 1
mfa_test_rcpt(struct envelope *m)
d209 1
a209 1
	ss.id = m->session_id;
d211 10
a220 10
	ss.u.path = m->session_rcpt;
	ss.ss = m->session_ss;
	ss.msg = *m;
	ss.msg.recipient = m->session_rcpt;
	ss.flags = m->flags;

	mfa_strip_source_route(ss.u.path.user, sizeof(ss.u.path.user));

	if (! valid_localpart(ss.u.path.user) ||
	    ! valid_domainpart(ss.u.path.domain))
a222 3
	if (ss.flags & F_MESSAGE_AUTHENTICATED)
		ss.u.path.flags |= F_PATH_AUTHENTICATED;

d240 2
a241 2
	ss->msg.recipient = ss->u.path;
	ss->msg.expire = ss->msg.recipient.rule.r_qexpire;
@


1.57
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.56 2011/04/17 11:39:22 gilles Exp $	*/
d37 1
a37 1
static void mfa_imsg(struct smtpd *, struct imsgev *, struct imsg *);
d40 3
a42 3
static void mfa_test_mail(struct smtpd *, struct envelope *);
static void mfa_test_rcpt(struct smtpd *, struct envelope *);
static void mfa_test_rcpt_resume(struct smtpd *, struct submit_status *);
d46 1
a46 1
mfa_imsg(struct smtpd *env, struct imsgev *iev, struct imsg *imsg)
d51 1
a51 1
			mfa_test_mail(env, imsg->data);
d55 1
a55 1
			mfa_test_rcpt(env, imsg->data);
d70 1
a70 1
			mfa_test_rcpt_resume(env, imsg->data);
d108 1
a108 1
mfa(struct smtpd *env)
d132 1
a132 1
	purge_config(env, PURGE_EVERYTHING);
d152 2
a153 2
	signal_set(&ev_sigint, SIGINT, mfa_sig_handler, env);
	signal_set(&ev_sigterm, SIGTERM, mfa_sig_handler, env);
d159 2
a160 2
	config_pipes(env, peers, nitems(peers));
	config_peers(env, peers, nitems(peers));
d170 1
a170 1
mfa_test_mail(struct smtpd *env, struct envelope *m)
d205 1
a205 1
mfa_test_rcpt(struct smtpd *env, struct envelope *m)
d236 1
a236 1
mfa_test_rcpt_resume(struct smtpd *env, struct submit_status *ss) {
@


1.56
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.55 2011/04/15 17:01:05 gilles Exp $	*/
d37 7
a43 7
void		mfa_imsg(struct smtpd *, struct imsgev *, struct imsg *);
__dead void	mfa_shutdown(void);
void		mfa_sig_handler(int, short, void *);
void		mfa_test_mail(struct smtpd *, struct envelope *);
void		mfa_test_rcpt(struct smtpd *, struct envelope *);
void		mfa_test_rcpt_resume(struct smtpd *, struct submit_status *);
int		mfa_strip_source_route(char *, size_t);
d45 1
a45 1
void
d86 1
a86 1
void
d99 1
a99 1
void
d204 1
a204 1
void
d235 1
a235 1
void
d249 1
a249 1
int
@


1.55
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.54 2010/11/28 14:35:58 gilles Exp $	*/
d40 2
a41 2
void		mfa_test_mail(struct smtpd *, struct message *);
void		mfa_test_rcpt(struct smtpd *, struct message *);
d170 1
a170 1
mfa_test_mail(struct smtpd *env, struct message *m)
d205 1
a205 1
mfa_test_rcpt(struct smtpd *env, struct message *m)
@


1.54
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.53 2010/11/28 13:56:43 gilles Exp $	*/
a207 3

	if (! valid_message_id(m->message_id))
		fatalx("mfa_test_rcpt: received corrupted message_id");
@


1.53
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.52 2010/10/29 09:16:07 gilles Exp $	*/
a25 1
#include <ctype.h>
a28 1
#include <signal.h>
@


1.52
log
@smtpd no longer knows a map called "secrets" which holds credentials for
authenticated relaying. one can create many maps holding credentials and
name them however he/she wants, just like any other map.

teach smtpd how to select a credentials map at the rule-level allowing a
setup to relay through the same MX with different credentials depending
on the source.

smtpd.conf.5 updated to reflect changes with help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.51 2010/10/28 21:15:50 gilles Exp $	*/
d28 1
d37 1
a41 3
void		mfa_setup_events(struct smtpd *);
void		mfa_disable_events(struct smtpd *);

d45 1
a45 4

int		strip_source_route(char *, size_t);

struct rule    *ruleset_match(struct smtpd *, struct path *, struct sockaddr_storage *);
a107 9
void
mfa_setup_events(struct smtpd *env)
{
}

void
mfa_disable_events(struct smtpd *env)
{
}
a163 1
	mfa_setup_events(env);
a170 14
int
msg_cmp(struct message *m1, struct message *m2)
{
	/*
	 * do not return u_int64_t's
	 */
	if (m1->id - m2->id > 0)
		return (1);
	else if (m1->id - m2->id < 0)
		return (-1);
	else
		return (0);
}

d180 1
a180 1
	if (strip_source_route(ss.u.path.user, sizeof(ss.u.path.user)))
d222 1
a222 1
	strip_source_route(ss.u.path.user, sizeof(ss.u.path.user));
d255 1
a255 1
strip_source_route(char *buf, size_t len)
@


1.51
log
@teach smtpd how to handle per-rule delays for message expiry, this allows
some rules to have a longer expiry delay than the default:

	accept for [...] relay expire 8d  # will stay 8 days in queue

I added the man page bits so I don't forget but I need to reword it a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.50 2010/10/09 22:05:35 gilles Exp $	*/
a277 1
	log_debug("EXPIRE IN %d", ss->msg.expire);
@


1.50
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.45 2010/04/21 08:29:01 jacekm Exp $	*/
d277 2
@


1.49
log
@check event_dispatch() return value

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.48 2010/06/01 23:06:23 jacekm Exp $	*/
d45 1
d69 1
d71 2
a72 2
			    IMSG_MFA_MAIL, imsg->hdr.peerid, 0, -1, imsg->data,
			    imsg->hdr.len - sizeof imsg->hdr);
d75 2
a76 4
		case IMSG_LKA_RCPT:
			imsg_compose_event(env->sc_ievs[PROC_SMTP],
			    IMSG_MFA_RCPT, imsg->hdr.peerid, 0, -1, imsg->data,
			    imsg->hdr.len - sizeof imsg->hdr);
d185 14
d202 1
a202 1
	int status;
d204 5
a208 1
	if (strip_source_route(m->sender.user, sizeof(m->sender.user)))
d211 2
a212 2
	if (! valid_localpart(m->sender.user) ||
	    ! valid_domainpart(m->sender.domain)) {
d216 1
a216 1
		if (!(m->sender.user[0] == '\0' && m->sender.domain[0] == '\0'))
d224 2
a225 3
	status = S_MESSAGE_PERMFAILURE;
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_MAIL, m->id, 0, -1,
	    &status, sizeof status);
d229 1
d231 1
a231 1
	    0, -1, m, sizeof *m);
d237 4
a240 1
	int status;
d242 7
a248 1
	m->recipient = m->session_rcpt;
d250 1
a250 1
	strip_source_route(m->recipient.user, sizeof(m->recipient.user));
d252 2
a253 2
	if (! valid_localpart(m->recipient.user) ||
	    ! valid_domainpart(m->recipient.domain))
d256 5
a260 2
	if (m->flags & F_MESSAGE_AUTHENTICATED)
		m->recipient.flags |= F_PATH_AUTHENTICATED;
a261 2
	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_RCPT, 0, 0, -1,
	    m, sizeof *m);
d264 15
a278 3
	status = S_MESSAGE_PERMFAILURE;
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT, m->id, 0, -1,
	    &status, sizeof status);
@


1.48
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.46 2010/05/31 23:38:56 jacekm Exp $	*/
d178 2
a179 1
	event_dispatch();
@


1.47
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.45 2010/04/21 08:29:01 jacekm Exp $	*/
a44 1
void		mfa_test_rcpt_resume(struct smtpd *, struct submit_status *);
a67 1
		case IMSG_LKA_RCPT:
d69 2
a70 2
			    IMSG_MFA_MAIL, 0, 0, -1, imsg->data,
			    sizeof(struct submit_status));
d73 4
a76 2
		case IMSG_LKA_RULEMATCH:
			mfa_test_rcpt_resume(env, imsg->data);
a183 14
int
msg_cmp(struct message *m1, struct message *m2)
{
	/*
	 * do not return u_int64_t's
	 */
	if (m1->id - m2->id > 0)
		return (1);
	else if (m1->id - m2->id < 0)
		return (-1);
	else
		return (0);
}

d187 1
a187 1
	struct submit_status	 ss;
d189 1
a189 5
	ss.id = m->id;
	ss.code = 530;
	ss.u.path = m->sender;

	if (strip_source_route(ss.u.path.user, sizeof(ss.u.path.user)))
d192 2
a193 2
	if (! valid_localpart(ss.u.path.user) ||
	    ! valid_domainpart(ss.u.path.domain)) {
d197 1
a197 1
		if (!(ss.u.path.user[0] == '\0' && ss.u.path.domain[0] == '\0'))
d205 3
a207 2
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_MAIL, 0, 0, -1, &ss,
	    sizeof(ss));
a210 1
	ss.code = 250;
d212 1
a212 1
	    0, -1, &ss, sizeof(ss));
d218 1
a218 4
	struct submit_status	 ss;

	if (! valid_message_id(m->message_id))
		fatalx("mfa_test_rcpt: received corrupted message_id");
d220 1
a220 7
	ss.id = m->session_id;
	ss.code = 530;
	ss.u.path = m->session_rcpt;
	ss.ss = m->session_ss;
	ss.msg = *m;
	ss.msg.recipient = m->session_rcpt;
	ss.flags = m->flags;
d222 1
a222 1
	strip_source_route(ss.u.path.user, sizeof(ss.u.path.user));
d224 2
a225 2
	if (! valid_localpart(ss.u.path.user) ||
	    ! valid_domainpart(ss.u.path.domain))
d228 2
a229 5
	if (ss.flags & F_MESSAGE_AUTHENTICATED)
		ss.u.path.flags |= F_PATH_AUTHENTICATED;

	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_RULEMATCH, 0, 0, -1,
	    &ss, sizeof(ss));
d231 2
d235 3
a237 15
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT, 0, 0, -1, &ss,
	    sizeof(ss));
}

void
mfa_test_rcpt_resume(struct smtpd *env, struct submit_status *ss) {
	if (ss->code != 250) {
		imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT, 0, 0, -1, ss,
		    sizeof(*ss));
		return;
	}

	ss->msg.recipient = ss->u.path;
	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_RCPT, 0, 0, -1,
	    ss, sizeof(*ss));
@


1.46
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d45 1
d69 1
d71 2
a72 2
			    IMSG_MFA_MAIL, imsg->hdr.peerid, 0, -1, imsg->data,
			    imsg->hdr.len - sizeof imsg->hdr);
d75 2
a76 4
		case IMSG_LKA_RCPT:
			imsg_compose_event(env->sc_ievs[PROC_SMTP],
			    IMSG_MFA_RCPT, imsg->hdr.peerid, 0, -1, imsg->data,
			    imsg->hdr.len - sizeof imsg->hdr);
d184 14
d201 1
a201 1
	int status;
d203 5
a207 1
	if (strip_source_route(m->sender.user, sizeof(m->sender.user)))
d210 2
a211 2
	if (! valid_localpart(m->sender.user) ||
	    ! valid_domainpart(m->sender.domain)) {
d215 1
a215 1
		if (!(m->sender.user[0] == '\0' && m->sender.domain[0] == '\0'))
d223 2
a224 3
	status = S_MESSAGE_PERMFAILURE;
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_MAIL, m->id, 0, -1,
	    &status, sizeof status);
d228 1
d230 1
a230 1
	    0, -1, m, sizeof *m);
d236 4
a239 1
	int status;
d241 7
a247 1
	m->recipient = m->session_rcpt;
d249 1
a249 1
	strip_source_route(m->recipient.user, sizeof(m->recipient.user));
d251 2
a252 2
	if (! valid_localpart(m->recipient.user) ||
	    ! valid_domainpart(m->recipient.domain))
d255 5
a259 2
	if (m->flags & F_MESSAGE_AUTHENTICATED)
		m->recipient.flags |= F_PATH_AUTHENTICATED;
a260 2
	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_RCPT, 0, 0, -1,
	    m, sizeof *m);
d263 15
a277 3
	status = S_MESSAGE_PERMFAILURE;
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT, m->id, 0, -1,
	    &status, sizeof status);
@


1.45
log
@Remove unusable ifdef DEBUG code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.44 2010/04/20 15:34:56 jacekm Exp $	*/
a44 1
void		mfa_test_rcpt_resume(struct smtpd *, struct submit_status *);
a67 1
		case IMSG_LKA_RCPT:
d69 2
a70 2
			    IMSG_MFA_MAIL, 0, 0, -1, imsg->data,
			    sizeof(struct submit_status));
d73 4
a76 2
		case IMSG_LKA_RULEMATCH:
			mfa_test_rcpt_resume(env, imsg->data);
a183 14
int
msg_cmp(struct message *m1, struct message *m2)
{
	/*
	 * do not return u_int64_t's
	 */
	if (m1->id - m2->id > 0)
		return (1);
	else if (m1->id - m2->id < 0)
		return (-1);
	else
		return (0);
}

d187 1
a187 1
	struct submit_status	 ss;
d189 1
a189 5
	ss.id = m->id;
	ss.code = 530;
	ss.u.path = m->sender;

	if (strip_source_route(ss.u.path.user, sizeof(ss.u.path.user)))
d192 2
a193 2
	if (! valid_localpart(ss.u.path.user) ||
	    ! valid_domainpart(ss.u.path.domain)) {
d197 1
a197 1
		if (!(ss.u.path.user[0] == '\0' && ss.u.path.domain[0] == '\0'))
d205 3
a207 2
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_MAIL, 0, 0, -1, &ss,
	    sizeof(ss));
a210 1
	ss.code = 250;
d212 1
a212 1
	    0, -1, &ss, sizeof(ss));
d218 1
a218 4
	struct submit_status	 ss;

	if (! valid_message_id(m->message_id))
		fatalx("mfa_test_rcpt: received corrupted message_id");
d220 1
a220 7
	ss.id = m->session_id;
	ss.code = 530;
	ss.u.path = m->session_rcpt;
	ss.ss = m->session_ss;
	ss.msg = *m;
	ss.msg.recipient = m->session_rcpt;
	ss.flags = m->flags;
d222 1
a222 1
	strip_source_route(ss.u.path.user, sizeof(ss.u.path.user));
d224 2
a225 2
	if (! valid_localpart(ss.u.path.user) ||
	    ! valid_domainpart(ss.u.path.domain))
d228 2
a229 5
	if (ss.flags & F_MESSAGE_AUTHENTICATED)
		ss.u.path.flags |= F_PATH_AUTHENTICATED;

	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_RULEMATCH, 0, 0, -1,
	    &ss, sizeof(ss));
d231 2
d235 3
a237 15
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT, 0, 0, -1, &ss,
	    sizeof(ss));
}

void
mfa_test_rcpt_resume(struct smtpd *env, struct submit_status *ss) {
	if (ss->code != 250) {
		imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT, 0, 0, -1, ss,
		    sizeof(*ss));
		return;
	}

	ss->msg.recipient = ss->u.path;
	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_LKA_RCPT, 0, 0, -1,
	    ss, sizeof(*ss));
@


1.44
log
@Kill *2400* lines of code by abstracting common bits of the imsg handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.43 2010/01/03 14:37:37 chl Exp $	*/
a150 1
#ifndef DEBUG
a154 3
#else
#warning disabling privilege revocation and chroot in DEBUG MODE
#endif
a158 1
#ifndef DEBUG
a162 1
#endif
@


1.43
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.42 2009/10/18 20:41:21 gilles Exp $	*/
d37 1
a39 4
void		mfa_dispatch_parent(int, short, void *);
void		mfa_dispatch_smtp(int, short, void *);
void		mfa_dispatch_lka(int, short, void *);
void		mfa_dispatch_control(int, short, void *);
d52 1
a52 1
mfa_sig_handler(int sig, short event, void *p)
d54 5
a58 9
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		mfa_shutdown();
		break;
	default:
		fatalx("mfa_sig_handler: unexpected signal");
	}
}
d60 2
a61 19
void
mfa_dispatch_parent(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_PARENT];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d66 8
a73 30
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mfa_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_VERBOSE: {
			int verbose;

			IMSG_SIZE_CHECK(&verbose);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		}
		default:
			log_warnx("mfa_dispatch_parent: got imsg %d",
			    imsg.hdr.type);
			fatalx("mfa_dispatch_parent: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}
d75 2
a76 19
void
mfa_dispatch_smtp(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_SMTP];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d81 4
a84 59
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mfa_dispatch_smtp: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_MFA_MAIL: {
			struct message	*m = imsg.data;

			IMSG_SIZE_CHECK(m);

			mfa_test_mail(env, m);
			break;
		}

		case IMSG_MFA_RCPT: {
			struct message	*m = imsg.data;

			IMSG_SIZE_CHECK(m);

			mfa_test_rcpt(env, m);
			break;
		}

		default:
			log_warnx("mfa_dispatch_smtp: got imsg %d",
			    imsg.hdr.type);
			fatalx("mfa_dispatch_smtp: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
mfa_dispatch_lka(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_LKA];
	ibuf = &iev->ibuf; 

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d89 1
a89 46
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mfa_dispatch_lka: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_LKA_MAIL: {
			struct submit_status	 *ss = imsg.data;

			IMSG_SIZE_CHECK(ss);

			imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_MAIL,
			    0, 0, -1, ss, sizeof(*ss));
			break;
		}
		case IMSG_LKA_RCPT: {
			struct submit_status	 *ss = imsg.data;

			IMSG_SIZE_CHECK(ss);

			imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_MFA_RCPT,
			    0, 0, -1, ss, sizeof(*ss));
			break;
		}
		case IMSG_LKA_RULEMATCH: {
			struct submit_status	 *ss = imsg.data;

			IMSG_SIZE_CHECK(ss);

			mfa_test_rcpt_resume(env, ss);
			break;
		}
		default:
			log_warnx("mfa_dispatch_lka: got imsg %d",
			    imsg.hdr.type);
			fatalx("mfa_dispatch_lka: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d93 1
a93 1
mfa_dispatch_control(int sig, short event, void *p)
d95 7
a101 38
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_CONTROL];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("mfa_dispatch_control: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("mfa_dispatch_control: got imsg %d",
			    imsg.hdr.type);
			fatalx("mfa_dispatch_control: unexpected imsg");
		}
		imsg_free(&imsg);
a102 1
	imsg_event_add(iev);
d132 4
a135 4
		{ PROC_PARENT,	mfa_dispatch_parent },
		{ PROC_SMTP,	mfa_dispatch_smtp },
		{ PROC_LKA,	mfa_dispatch_lka },
		{ PROC_CONTROL,	mfa_dispatch_control},
d170 1
@


1.42
log
@fix a bug that was introduced by my changes in ruleset matching and which
caused an envelope to be saved with action A_INVALID when it matches
either A_RELAY or A_RELAYVIA.

reported by various people
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.41 2009/10/12 22:34:37 gilles Exp $	*/
d102 9
@


1.41
log
@- fix a null deref which could happen after a couple iterations of the
  aliases/virtual domains resolution code.

- fix a logic bug which caused virtual domains not to be correctly
  handled after one iteration of the aliases resolution code.

- introduce a few helper functions to help clean up and simplify the
  lka code.

- simplify the IS_EXT/IS_MAILBOX/IS_RELAY macros so they manipulate a
  struct path * instead of the mess of dereferences we were passing them.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.40 2009/10/07 18:19:39 gilles Exp $	*/
d466 1
@


1.40
log
@now that mfa no longer does ruleset matching, parent no longer needs to
send it the ruleset configuration, and mfa no longer needs to interpret
it and load it in memory. kill kill kill. as an added bonus: removes 88
lines of code :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.39 2009/10/07 18:09:12 gilles Exp $	*/
d437 1
@


1.39
log
@currently both mfa and lka perform ruleset matching for their own purposes.
make lka the only caller of ruleset_match(), mfa request match through imsg
which will shrink its code and help me implement virtual domains properly.

idea discussed with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.38 2009/10/07 17:30:41 gilles Exp $	*/
a101 87
		case IMSG_CONF_START:
			if ((env->sc_rules_reload = calloc(1, sizeof(*env->sc_rules))) == NULL)
				fatal("mfa_dispatch_parent: calloc");
			if ((env->sc_maps_reload = calloc(1, sizeof(*env->sc_maps))) == NULL)
				fatal("mfa_dispatch_parent: calloc");
			TAILQ_INIT(env->sc_rules_reload);
			TAILQ_INIT(env->sc_maps_reload);
			break;
		case IMSG_CONF_RULE: {
			struct rule *rule = imsg.data;

			IMSG_SIZE_CHECK(rule);

			rule = calloc(1, sizeof(*rule));
			if (rule == NULL)
				fatal("mfa_dispatch_parent: calloc");
			*rule = *(struct rule *)imsg.data;

			TAILQ_INIT(&rule->r_conditions);
			TAILQ_INSERT_TAIL(env->sc_rules_reload, rule, r_entry);
			break;
		}
		case IMSG_CONF_CONDITION: {
			struct rule *r = TAILQ_LAST(env->sc_rules_reload, rulelist);
			struct cond *cond = imsg.data;

			IMSG_SIZE_CHECK(cond);

			cond = calloc(1, sizeof(*cond));
			if (cond == NULL)
				fatal("mfa_dispatch_parent: calloc");
			*cond = *(struct cond *)imsg.data;

			TAILQ_INSERT_TAIL(&r->r_conditions, cond, c_entry);
			break;
		}
		case IMSG_CONF_MAP: {
			struct map *m = imsg.data;

			IMSG_SIZE_CHECK(m);

			m = calloc(1, sizeof(*m));
			if (m == NULL)
				fatal("mfa_dispatch_parent: calloc");
			*m = *(struct map *)imsg.data;

			TAILQ_INIT(&m->m_contents);
			TAILQ_INSERT_TAIL(env->sc_maps_reload, m, m_entry);
			break;
		}
		case IMSG_CONF_RULE_SOURCE: {
			struct rule *rule = TAILQ_LAST(env->sc_rules_reload, rulelist);
			char *sourcemap = imsg.data;
			void *temp = env->sc_maps;

			/* map lookup must be done in the reloaded conf */
			env->sc_maps = env->sc_maps_reload;
			rule->r_sources = map_findbyname(env, sourcemap);
			if (rule->r_sources == NULL)
				fatalx("maps inconsistency");
			env->sc_maps = temp;
			break;
		}
		case IMSG_CONF_MAP_CONTENT: {
			struct map *m = TAILQ_LAST(env->sc_maps_reload, maplist);
			struct mapel *mapel = imsg.data;
			
			IMSG_SIZE_CHECK(mapel);
			
			mapel = calloc(1, sizeof(*mapel));
			if (mapel == NULL)
				fatal("mfa_dispatch_parent: calloc");
			*mapel = *(struct mapel *)imsg.data;

			TAILQ_INSERT_TAIL(&m->m_contents, mapel, me_entry);
			break;
		}
		case IMSG_CONF_END: {
			/* switch and destroy old ruleset */
			if (env->sc_rules)
				purge_config(env, PURGE_RULES);
			if (env->sc_maps)
				purge_config(env, PURGE_MAPS);
			env->sc_rules = env->sc_rules_reload;
			env->sc_maps = env->sc_maps_reload;
			break;
		}
@


1.38
log
@since the bounce code rewrite, we no longer need to perform ruleset match
and aliases resolution on the sender before envelope is written in queue:

- mfa_test_mail() no longer calls ruleset_match()
- lka_verify_mail() no longer resolves sender and set rule action
- lka_resolve_mail() becomes dead code so just kill it

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.37 2009/09/03 08:19:13 jacekm Exp $	*/
d48 1
d315 8
a514 1
	struct rule *r;
d535 2
a536 3
	r = ruleset_match(env, &ss.u.path, &ss.ss);
	if (r == NULL)
		goto refuse;
d538 1
a538 3
	ss.u.path.rule = *r;
	goto accept;
		
d542 9
a550 1
	return;
a551 2
accept:
	ss.code = 250;
d553 1
a553 1
	    &ss, sizeof(ss));
@


1.37
log
@imsg_get sets errno so use fatal instead of fatalx.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.36 2009/06/06 04:14:21 pyr Exp $	*/
a470 1
	struct rule *r;
a488 5
	r = ruleset_match(env, &ss.u.path, NULL);
	if (r == NULL)
		ss.u.path.rule.r_action = A_RELAY;
	else
		ss.u.path.rule = *r;
@


1.36
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.35 2009/06/05 20:43:57 pyr Exp $	*/
d96 1
a96 1
			fatalx("mfa_dispatch_parent: imsg_get error");
d228 1
a228 1
			fatalx("mfa_dispatch_smtp: imsg_get error");
d291 1
a291 1
			fatalx("mfa_dispatch_lka: imsg_get error");
d354 1
a354 1
			fatalx("mfa_dispatch_control: imsg_get error");
@


1.35
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.34 2009/06/01 23:15:48 gilles Exp $	*/
d70 1
d75 2
a76 1
	ibuf = env->sc_ibufs[PROC_PARENT];
d83 1
a83 1
			event_del(&ibuf->ev);
d195 1
a195 1
	imsg_event_add(ibuf);
d202 1
d207 2
a208 1
	ibuf = env->sc_ibufs[PROC_SMTP];
d215 1
a215 1
			event_del(&ibuf->ev);
d258 1
a258 1
	imsg_event_add(ibuf);
d265 1
d270 2
a271 1
	ibuf = env->sc_ibufs[PROC_LKA];
d278 1
a278 1
			event_del(&ibuf->ev);
d301 1
a301 1
			imsg_compose_event(env->sc_ibufs[PROC_SMTP], IMSG_MFA_MAIL,
d310 1
a310 1
			imsg_compose_event(env->sc_ibufs[PROC_SMTP], IMSG_MFA_RCPT,
d321 1
a321 1
	imsg_event_add(ibuf);
d328 1
d333 2
a334 1
	ibuf = env->sc_ibufs[PROC_CONTROL];
d341 1
a341 1
			event_del(&ibuf->ev);
d366 1
a366 1
	imsg_event_add(ibuf);
d498 1
a498 1
	imsg_compose_event(env->sc_ibufs[PROC_SMTP], IMSG_MFA_MAIL, 0, 0, -1, &ss,
d504 1
a504 1
	imsg_compose_event(env->sc_ibufs[PROC_LKA], IMSG_LKA_MAIL, 0,
d541 1
a541 1
	imsg_compose_event(env->sc_ibufs[PROC_SMTP], IMSG_MFA_RCPT, 0, 0, -1, &ss,
d547 1
a547 1
	imsg_compose_event(env->sc_ibufs[PROC_LKA], IMSG_LKA_RCPT, 0, 0, -1,
@


1.34
log
@yet another cleanup in mfa/lka, don't roll their own loops to release maps
and rules when config.c provides us with purge_config(), PURGE_MAPS and
PURGE_RULES. kills lots of lines with no functionnal change. ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.33 2009/06/01 22:51:47 gilles Exp $	*/
d295 1
a295 1
			imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_MFA_MAIL,
d304 1
a304 1
			imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_MFA_RCPT,
d490 1
a490 1
	imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_MFA_MAIL, 0, 0, -1, &ss,
d496 1
a496 1
	imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_MAIL, 0,
d533 1
a533 1
	imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_MFA_RCPT, 0, 0, -1, &ss,
d539 1
a539 1
	imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_RCPT, 0, 0, -1,
@


1.33
log
@add new file ruleset.c with code related to the ruleset matching, and kill
the two or three "almost" identical versions of ruleset matching loops from
lka and mfa by having one unified function in ruleset.c; ok jacekm@@

while at it, bring maildir support back to life; trivial one-liner by me
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.32 2009/06/01 13:20:56 jacekm Exp $	*/
a176 6
			void *temp;
			struct rule *r;
			struct cond *cond;
			struct map *m;
			struct mapel *mapel;
			
d178 4
a181 1
			temp = env->sc_rules;
a182 3
			env->sc_rules_reload = temp;

			temp = env->sc_maps;
a183 28
			env->sc_maps_reload = temp;
			
			if (env->sc_rules_reload) {
				while ((r = TAILQ_FIRST(env->sc_rules_reload))) {
					TAILQ_REMOVE(env->sc_rules_reload, r, r_entry);
					while ((cond = TAILQ_FIRST(&r->r_conditions))) {
						TAILQ_REMOVE(&r->r_conditions, cond, c_entry);
						free(cond);
					}
					free(r);
				}
				free(env->sc_rules_reload);
				env->sc_rules_reload = NULL;
			}

			if (env->sc_maps_reload) {
				while ((m = TAILQ_FIRST(env->sc_maps_reload))) {
					TAILQ_REMOVE(env->sc_maps_reload, m, m_entry);
					while ((mapel = TAILQ_FIRST(&m->m_contents))) {
						TAILQ_REMOVE(&m->m_contents, mapel, me_entry);
						free(mapel);
					}
					free(m);
				}
				free(env->sc_maps_reload);
				env->sc_maps_reload = NULL;
			}

@


1.32
log
@Fix EV_READ/EV_WRITE testing inside IMSG handlers. Based on similar change
to the routing daemons by claudio@@; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.31 2009/05/24 14:38:56 jacekm Exp $	*/
a25 3
#include <netinet/in.h>
#include <arpa/inet.h>

a47 3
int		mfa_ruletest_rcpt(struct smtpd *, struct path *, struct sockaddr_storage *);
int		mfa_check_source(struct map *, struct sockaddr_storage *);
int		mfa_match_mask(struct sockaddr_storage *, struct netaddr *);
d51 2
d497 1
d516 5
d538 1
d559 6
a564 2
	if (mfa_ruletest_rcpt(env, &ss.u.path, &ss.ss))
		goto accept;
a574 106
}

int
mfa_ruletest_rcpt(struct smtpd *env, struct path *path, struct sockaddr_storage *ss)
{
	struct rule *r;
	struct cond *cond;
	struct map *map;
	struct mapel *me;

	TAILQ_FOREACH(r, env->sc_rules, r_entry) {
		if (!(path->flags & F_PATH_AUTHENTICATED) &&
		    ! mfa_check_source(r->r_sources, ss))
			continue;

		TAILQ_FOREACH(cond, &r->r_conditions, c_entry) {
			if (cond->c_type == C_ALL) {
				path->rule = *r;
				return 1;
			}

			if (cond->c_type == C_DOM) {
				cond->c_match = map_find(env, cond->c_map);
				if (cond->c_match == NULL)
					fatal("mfa failed to lookup map.");

				map = cond->c_match;
				TAILQ_FOREACH(me, &map->m_contents, me_entry) {
					log_debug("matching: %s to %s",
					    path->domain, me->me_key.med_string);
					if (hostname_match(path->domain, me->me_key.med_string)) {
						path->rule = *r;
						return 1;
					}
				}
			}
		}
	}
	return 0;
}

int
mfa_check_source(struct map *map, struct sockaddr_storage *ss)
{
	struct mapel *me;

	if (ss == NULL) {
		/* This happens when caller is part of an internal
		 * lookup (ie: alias resolved to a remote address)
		 */
		return 1;
	}

	TAILQ_FOREACH(me, &map->m_contents, me_entry) {

		if (ss->ss_family != me->me_key.med_addr.ss.ss_family)
			continue;

		if (ss->ss_len != me->me_key.med_addr.ss.ss_len)
			continue;

		if (mfa_match_mask(ss, &me->me_key.med_addr))
			return 1;
	}

	return 0;
}

int
mfa_match_mask(struct sockaddr_storage *ss, struct netaddr *ssmask)
{
	if (ss->ss_family == AF_INET) {
		struct sockaddr_in *ssin = (struct sockaddr_in *)ss;
		struct sockaddr_in *ssinmask = (struct sockaddr_in *)&ssmask->ss;

		if ((ssin->sin_addr.s_addr & ssinmask->sin_addr.s_addr) ==
		    ssinmask->sin_addr.s_addr)
			return (1);
		return (0);
	}

	if (ss->ss_family == AF_INET6) {
		struct in6_addr	*in;
		struct in6_addr	*inmask;
		struct in6_addr	 mask;
		int		 i;

		bzero(&mask, sizeof(mask));
		for (i = 0; i < (128 - ssmask->bits) / 8; i++)
			mask.s6_addr[i] = 0xff;
		i = ssmask->bits % 8;
		if (i)
			mask.s6_addr[ssmask->bits / 8] = 0xff00 >> i;

		in = &((struct sockaddr_in6 *)ss)->sin6_addr;
		inmask = &((struct sockaddr_in6 *)&ssmask->ss)->sin6_addr;

		for (i = 0; i < 16; i++) {
			if ((in->s6_addr[i] & mask.s6_addr[i]) !=
			    inmask->s6_addr[i])
				return (0);
		}
		return (1);
	}

	return (0);
@


1.31
log
@Parent process forks 3 types of processes, track them all in a single tree
using newly introduced child struct.

Manage process titles centrally in struct smtpd.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.30 2009/05/21 01:07:13 gilles Exp $	*/
d79 2
a80 2
	switch (event) {
	case EV_READ:
d89 3
a91 2
		break;
	case EV_WRITE:
a93 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d243 2
a244 2
	switch (event) {
	case EV_READ:
d253 3
a255 2
		break;
	case EV_WRITE:
a257 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d304 2
a305 2
	switch (event) {
	case EV_READ:
d314 3
a316 2
		break;
	case EV_WRITE:
a318 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d365 2
a366 2
	switch (event) {
	case EV_READ:
d375 3
a377 2
		break;
	case EV_WRITE:
a379 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
@


1.30
log
@fix sockaddr_storage lenght check in mfa_check_source()
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.29 2009/05/20 16:07:26 gilles Exp $	*/
a465 1
	setproctitle("mail filter agent");
d467 1
@


1.29
log
@previous commit to add reload support was missing some code, this diffs
contains the missing parts + a memleak plug
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.28 2009/05/20 14:36:55 gilles Exp $	*/
d638 1
a638 1
		if (ss->ss_len == me->me_key.med_addr.ss.ss_len)
@


1.28
log
@replace a TAILQ_FOREACH loop with a TAILQ_FIRST loop when releasing entries
of the tailq, this is how it must be done.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.27 2009/05/20 14:29:44 gilles Exp $	*/
d124 1
d152 1
d156 27
d186 1
d188 1
d198 1
a198 1

d202 4
d215 4
@


1.27
log
@first step towards configuration reload in smtpd, smtpctl reload will parse
the configuration file again and replace current configuration with new one
in all processes. what we don't support yet is graceful restart, clients in
sessions at the moment of the reload will have a temp failure thrown at 'em
which is ok RFC-wise but which we will try to improve anyway.

tested with various setups, "diff reads good" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.26 2009/05/19 11:24:24 jacekm Exp $	*/
d169 2
a170 1
				TAILQ_FOREACH(r, env->sc_rules_reload, r_entry) {
d178 2
a179 1
				TAILQ_FOREACH(m, env->sc_maps_reload, m_entry) {
@


1.26
log
@Verify the amount of IMSG payload is exactly as expected; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.25 2009/05/14 15:05:12 eric Exp $	*/
d106 80
d412 1
a412 1
//	purge_config(env, PURGE_EVERYTHING);
@


1.25
log
@use the nitems() macro where appropriate

ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.24 2009/04/28 23:11:25 gilles Exp $	*/
d152 6
a157 2
		case IMSG_MFA_MAIL:
			mfa_test_mail(env, imsg.data);
d159 8
a166 2
		case IMSG_MFA_RCPT:
			mfa_test_rcpt(env, imsg.data);
d168 2
d217 3
a219 1
			struct submit_status	 *ss;
a220 1
			ss = imsg.data;
d226 3
a228 1
			struct submit_status	 *ss;
a229 1
			ss = imsg.data;
@


1.24
log
@smtp auth happened to work by luck because delivery to mbox action was the
first action of an enum and we allocated a struct using calloc, but we did
not properly initialize the action for authenticated users.

while at it, change the name of path action flags so that we know at first
sight that they are path related.

this diff fixes the immediate issue but still needs work.
ok jacekm@@, "we'll work out a long term solution"
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.23 2009/04/28 21:27:25 jacekm Exp $	*/
d350 2
a351 2
	config_pipes(env, peers, 4);
	config_peers(env, peers, 4);
@


1.23
log
@let mta, mda, and mfa become idle - no functional change; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.22 2009/04/27 16:15:21 jacekm Exp $	*/
d431 1
a431 1
		goto accept;
d456 2
a457 1
		if (! mfa_check_source(r->r_sources, ss))
@


1.22
log
@check message_id received from smtp uses valid format.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.21 2009/04/24 08:32:12 jacekm Exp $	*/
a47 1
void		mfa_timeout(int, short, void *);
a285 6
	struct timeval	 tv;

	evtimer_set(&env->sc_ev, mfa_timeout, env);
	tv.tv_sec = 3;
	tv.tv_usec = 0;
	evtimer_add(&env->sc_ev, &tv);
a290 12
	evtimer_del(&env->sc_ev);
}

void
mfa_timeout(int fd, short event, void *p)
{
	struct smtpd		*env = p;
	struct timeval		 tv;

	tv.tv_sec = 3;
	tv.tv_usec = 0;
	evtimer_add(&env->sc_ev, &tv);
@


1.21
log
@kill unnecessary struct message_recipient; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.20 2009/04/21 14:37:32 eric Exp $	*/
d432 3
@


1.20
log
@correct some fatal(x) calls and error strings

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.19 2009/04/16 15:35:06 jacekm Exp $	*/
d51 1
a51 1
void		mfa_test_rcpt(struct smtpd *, struct message_recipient *);
d429 1
a429 1
mfa_test_rcpt(struct smtpd *env, struct message_recipient *mr)
d433 1
a433 1
	ss.id = mr->id;
d435 4
a438 5
	ss.u.path = mr->path;
	ss.ss = mr->ss;
	ss.msg = mr->msg;

	ss.flags = mr->flags;
@


1.19
log
@Total rewrite of the sendmail interface. Adds support for -t, -v,
and -F cmdline args. Also, date and Message-Id headers are added
when missing.

The main trouble with the current enqueue code is that it requires
dealing with problems in the control process that are already solved
in the smtp process, ie. duplicating a lot of code which interacts
with untrusted clients. This diff solves this by making sendmail
obtain a SMTP socket from smtp via smtpd.sock, and using that socket
to deliver the message. For smtpd it looks as if connection was
made from the network, only difference being the F_MESSAGE_ENQUEUED
message flag, handy when differentation between local and remote
deliveries is wanted.

Most of the features come from the femail program, created by henning@@.

Additional testing by Nigel J. Taylor.

ok gilles@@, henning@@ happy with smtpd using femail code
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.18 2009/03/29 14:18:20 jacekm Exp $	*/
d102 1
a102 1
			fatal("parent_dispatch_mfa: imsg_read error");
d148 1
a148 1
			fatal("mfa_dispatch_smtp: imsg_read error");
d200 1
a200 1
			fatal("mfa_dispatch_lka: imsg_read error");
d262 1
a262 1
			fatal("mfa_dispatch_smtp: imsg_read error");
@


1.18
log
@turn some log_debugs into log_warns or even fatals; "looks ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.17 2009/03/08 19:11:22 gilles Exp $	*/
d50 2
a51 2
void		mfa_test_mail(struct smtpd *, struct message *, int);
void		mfa_test_rcpt(struct smtpd *, struct message_recipient *, int);
d154 1
a154 1
			mfa_test_mail(env, imsg.data, PROC_SMTP);
d157 1
a157 1
			mfa_test_rcpt(env, imsg.data, PROC_SMTP);
d217 2
a218 6
			if (ss->msg.flags & F_MESSAGE_ENQUEUED)
				imsg_compose(env->sc_ibufs[PROC_CONTROL], IMSG_MFA_RCPT,
				    0, 0, -1, ss, sizeof(*ss));
			else
				imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_MFA_RCPT,
				    0, 0, -1, ss, sizeof(*ss));
a266 3
		case IMSG_MFA_RCPT:
			mfa_test_rcpt(env, imsg.data, PROC_CONTROL);
			break;
d394 1
a394 1
mfa_test_mail(struct smtpd *env, struct message *m, int sender)
d418 1
a418 1
	imsg_compose(env->sc_ibufs[sender], IMSG_MFA_MAIL, 0, 0, -1, &ss,
d429 1
a429 1
mfa_test_rcpt(struct smtpd *env, struct message_recipient *mr, int sender)
d447 1
a447 1
	if (sender == PROC_SMTP && (ss.flags & F_MESSAGE_AUTHENTICATED))
d454 1
a454 1
	imsg_compose(env->sc_ibufs[sender], IMSG_MFA_RCPT, 0, 0, -1, &ss,
@


1.17
log
@shrink struct message a bit by removing a couple fields which are no longer
used and by moving the rcpt count in struct session where it really belongs

while at it, remove some unused splay tree generation in mfa
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.16 2009/03/08 17:54:20 gilles Exp $	*/
d108 1
a108 1
			log_debug("parent_dispatch_mfa: unexpected imsg %d",
d110 1
a110 1
			break;
d160 1
a160 1
			log_debug("mfa_dispatch_smtp: unexpected imsg %d",
d162 1
a162 1
			break;
d226 1
a226 1
			log_debug("mfa_dispatch_lka: unexpected imsg %d",
d228 1
a228 1
			break;
d275 1
a275 1
			log_debug("mfa_dispatch_smtp: unexpected imsg %d",
d277 1
a277 1
			break;
@


1.16
log
@~/.forward files handling was fixed recently so that it is the privileged
process that does the opening, this commit does some cleanup, and fixes a
bug I experienced today which was caused by a use-after-free.

I did some testing to make sure a user cannot cause smtpd to deadlock, or
loop, with broken setups (self-referencing forwards/aliases, empty files,
broken files...), but if you are playing with aliases/forwards PLEASE let
me know of any bug you run into.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.15 2009/02/22 19:07:33 chl Exp $	*/
a589 2

SPLAY_GENERATE(msgtree, message, nodes, msg_cmp);
@


1.15
log
@add missing headers

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.14 2009/02/18 22:39:12 jacekm Exp $	*/
d217 1
a217 1
			if (ss->msg.flags & F_MESSAGE_ENQUEUED) {
d220 1
a220 2
			}
			else {
a222 1
			}
@


1.14
log
@- add basic syntax checking to mfa
- decline source routing at MAIL FROM, strip at RCPT TO

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.13 2009/02/18 16:42:30 jacekm Exp $	*/
d32 1
@


1.13
log
@IMSG_MFA_RCPT handlers are almost identical, put common code in new
mfa_test_rcpt; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.12 2009/02/17 21:38:47 gilles Exp $	*/
d29 1
d49 1
d55 2
d152 2
a153 12
		case IMSG_MFA_MAIL: {
			struct message		*m;
			struct submit_status	 ss;

			m = imsg.data;
			log_debug("mfa_dispatch_smtp: testing return path");
			ss.id = m->id;
			ss.code = 250;
			ss.u.path = m->sender;

			imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_MAIL, 0,
			    0, -1, &ss, sizeof(ss));
a154 1
		}
d402 35
d449 6
d461 1
d575 15
@


1.12
log
@- remove two debug messages
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.11 2009/02/15 10:32:23 jacekm Exp $	*/
d48 2
a49 1
int		mfa_check_rcpt(struct smtpd *, struct path *, struct sockaddr_storage *);
d162 2
a163 25
		case IMSG_MFA_RCPT: {
			struct message_recipient *mr;
			struct submit_status	 ss;

			mr = imsg.data;
			log_debug("mfa_dispatch_smtp: testing forward path");
			ss.id = mr->id;
			ss.code = 530;
			ss.u.path = mr->path;
			ss.ss = mr->ss;
			ss.msg = mr->msg;

			ss.flags = mr->flags;

			if (! mfa_check_rcpt(env, &ss.u.path, &ss.ss) &&
			    ! (ss.flags & F_MESSAGE_AUTHENTICATED)) {
				imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_MFA_RCPT, 0,
				    0, -1, &ss, sizeof(ss));
			}
			else {
				ss.code = 250;
				imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_RCPT, 0,
				    0, -1, &ss, sizeof(ss));
			}

a164 1
		}
d279 2
a280 24
		case IMSG_MFA_RCPT: {
			struct message_recipient *mr;
			struct submit_status	 ss;

			mr = imsg.data;
			log_debug("mfa_dispatch_control: testing forward path");
			ss.id = mr->id;
			ss.code = 530;
			ss.u.path = mr->path;
			ss.ss = mr->ss;
			ss.msg = mr->msg;

			ss.flags = mr->flags;

			if (! mfa_check_rcpt(env, &ss.u.path, &ss.ss)) {
				imsg_compose(ibuf, IMSG_MFA_RCPT, 0,
				    0, -1, &ss, sizeof(ss));
			}
			else {
				ss.code = 250;
				imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_RCPT, 0,
				    0, -1, &ss, sizeof(ss));
			}

a281 1
		}
d408 29
d438 1
a438 1
mfa_check_rcpt(struct smtpd *env, struct path *path, struct sockaddr_storage *ss)
@


1.11
log
@New config.c that allows for process cloning. Done by pyr@@ for
relayd at n2k9, and adapted to smtpd; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.10 2009/01/27 22:48:29 gilles Exp $	*/
a246 1
				log_debug("FOOO");
a250 1
				log_debug("BAAR");
@


1.10
log
@first bricks of enqueue code which allows smtpctl to submit mail to queue
without "talking" smtp to listeners. currently, a big part of the server
side code is done (and requires a cleanup), next step is to get it usable
properly from a mail user agent.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.9 2009/01/04 17:45:58 gilles Exp $	*/
d432 1
@


1.9
log
@When matching a recipient domain to a rule, do not use strcasecmp, but use
new hostname_match() function which recognizes * as a wildcard. We can now
do: accept for domain "*.example.org" to match all subdomains.

idea from Nicholas Marriott <nicholas.marriott@@gmail.com>, hostname_match()
from me in place of his fnmatch() calls.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.8 2009/01/04 16:40:58 gilles Exp $	*/
d43 1
d246 10
a255 2
			imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_MFA_RCPT,
			    0, 0, -1, ss, sizeof(*ss));
d269 72
d388 1
d432 1
a432 1
	config_peers(env, peers, 3);
a466 1
		log_debug("client authorized");
d480 2
d515 1
a516 1
	}
@


1.8
log
@- change name of "masked" member in struct netaddr, it was misleading
- allow "from all" so that the ugly "accept from { 0.0.0.0/0, ::/0 }"
construct becomes a nice looking "accept from all"

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.7 2009/01/04 14:46:14 jacekm Exp $	*/
d399 1
a399 2
					if (strcasecmp(me->me_key.med_string,
						path->domain) == 0) {
@


1.7
log
@cleanup; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.6 2009/01/04 00:58:59 gilles Exp $	*/
d458 1
a458 1
		for (i = 0; i < (128 - ssmask->masked) / 8; i++)
d460 1
a460 1
		i = ssmask->masked % 8;
d462 1
a462 1
			mask.s6_addr[ssmask->masked / 8] = 0xff00 >> i;
@


1.6
log
@aliases/forwards expansion was not done correctly and a race could
cause delivery to happen before expansion is over, causing some of
the recipients to never receive the mail. change how the mfa, lka,
queue and smtp processes communicate to ensure smtp never receives
an acknowledgment before ALL expanded envelopes are on disk. While
at it, lka was doing work which belongs in mfa, fix that also.

this is based on an idea from a talk with jacekm@@, change not over
but already better than what we had.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.5 2009/01/01 16:15:47 jacekm Exp $	*/
d33 1
a33 1
#include <strings.h>
d48 1
a48 1
int		mfa_check_source(struct smtpd *, struct map *, struct sockaddr_storage *);
d382 1
a382 1
		if (! mfa_check_source(env, r->r_sources, ss))
d412 1
a412 1
mfa_check_source(struct smtpd *env, struct map *map, struct sockaddr_storage *ss)
@


1.5
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.4 2008/12/20 00:18:03 gilles Exp $	*/
d26 3
d33 1
d47 4
d167 1
a167 1
			ss.code = 250;
d170 1
d174 11
a184 2
			imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_RCPT, 0,
			    0, -1, &ss, sizeof(ss));
d371 105
@


1.4
log
@- import first bricks of SMTP AUTH support. currently only AUTH PLAIN is
	supported, AUTH LOGIN will follow soon. AUTH will only work if a
	listen directive has "enable auth" keywords, AND session is safe
	(ssmtp or starttls).
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.3 2008/12/13 23:19:34 jacekm Exp $	*/
a24 1
#include <sys/time.h>
a27 1
#include <signal.h>
a29 1
#include <string.h>
@


1.3
log
@IMSG_* namespace cleanup.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfa.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d165 2
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d141 1
a141 1
		case IMSG_MFA_RPATH_SUBMIT: {
d151 2
a152 2
			imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_LOOKUP_MAIL, 0, 0, -1,
				&ss, sizeof(ss));
d155 1
a155 1
		case IMSG_MFA_RCPT_SUBMIT: {
d166 2
a167 2
			imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_LOOKUP_RCPT, 0, 0, -1,
				&ss, sizeof(ss));
a169 2
		case IMSG_MFA_DATA_SUBMIT:
			break;
d216 1
a216 1
		case IMSG_MFA_LOOKUP_MAIL: {
d220 2
a221 2
			imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_MFA_RPATH_SUBMIT, 0, 0, -1,
			    ss, sizeof(*ss));
d224 1
a224 1
		case IMSG_MFA_LOOKUP_RCPT: {
d228 2
a229 2
			imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_MFA_RCPT_SUBMIT, 0, 0, -1,
			    ss, sizeof(*ss));
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

