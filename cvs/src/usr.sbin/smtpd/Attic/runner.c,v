head	1.145;
access;
symbols
	OPENBSD_5_1_BASE:1.135
	OPENBSD_5_1:1.135.0.2
	OPENBSD_5_0:1.108.0.2
	OPENBSD_5_0_BASE:1.108
	OPENBSD_4_9:1.95.0.2
	OPENBSD_4_9_BASE:1.95
	OPENBSD_4_7:1.78.0.2
	OPENBSD_4_7_BASE:1.78
	OPENBSD_4_6:1.53.0.4
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33;
locks; strict;
comment	@ * @;


1.145
date	2012.07.09.09.57.53;	author gilles;	state dead;
branches;
next	1.144;

1.144
date	2012.07.09.08.08.29;	author gilles;	state Exp;
branches;
next	1.143;

1.143
date	2012.07.08.18.13.08;	author chl;	state Exp;
branches;
next	1.142;

1.142
date	2012.07.02.17.00.05;	author eric;	state Exp;
branches;
next	1.141;

1.141
date	2012.06.20.20.45.23;	author eric;	state Exp;
branches;
next	1.140;

1.140
date	2012.06.20.20.27.41;	author eric;	state Exp;
branches;
next	1.139;

1.139
date	2012.06.17.15.17.08;	author gilles;	state Exp;
branches;
next	1.138;

1.138
date	2012.04.15.12.12.35;	author chl;	state Exp;
branches;
next	1.137;

1.137
date	2012.03.19.20.38.49;	author gilles;	state Exp;
branches;
next	1.136;

1.136
date	2012.03.07.22.54.49;	author gilles;	state Exp;
branches;
next	1.135;

1.135
date	2012.01.31.21.05.26;	author gilles;	state Exp;
branches;
next	1.134;

1.134
date	2012.01.28.16.50.02;	author gilles;	state Exp;
branches;
next	1.133;

1.133
date	2012.01.28.11.33.07;	author gilles;	state Exp;
branches;
next	1.132;

1.132
date	2012.01.13.14.01.58;	author eric;	state Exp;
branches;
next	1.131;

1.131
date	2012.01.12.23.17.02;	author gilles;	state Exp;
branches;
next	1.130;

1.130
date	2012.01.12.22.59.55;	author eric;	state Exp;
branches;
next	1.129;

1.129
date	2012.01.12.22.40.16;	author gilles;	state Exp;
branches;
next	1.128;

1.128
date	2012.01.12.22.00.21;	author gilles;	state Exp;
branches;
next	1.127;

1.127
date	2012.01.11.17.46.36;	author eric;	state Exp;
branches;
next	1.126;

1.126
date	2011.11.16.19.38.56;	author eric;	state Exp;
branches;
next	1.125;

1.125
date	2011.11.15.23.06.39;	author gilles;	state Exp;
branches;
next	1.124;

1.124
date	2011.11.14.19.23.41;	author chl;	state Exp;
branches;
next	1.123;

1.123
date	2011.11.07.11.14.10;	author eric;	state Exp;
branches;
next	1.122;

1.122
date	2011.10.27.14.32.57;	author chl;	state Exp;
branches;
next	1.121;

1.121
date	2011.10.26.20.47.31;	author gilles;	state Exp;
branches;
next	1.120;

1.120
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.119;

1.119
date	2011.10.09.18.39.53;	author eric;	state Exp;
branches;
next	1.118;

1.118
date	2011.09.18.21.37.53;	author gilles;	state Exp;
branches;
next	1.117;

1.117
date	2011.09.01.19.56.49;	author eric;	state Exp;
branches;
next	1.116;

1.116
date	2011.08.30.17.06.01;	author chl;	state Exp;
branches;
next	1.115;

1.115
date	2011.08.29.21.43.09;	author chl;	state Exp;
branches;
next	1.114;

1.114
date	2011.08.29.18.49.29;	author chl;	state Exp;
branches;
next	1.113;

1.113
date	2011.08.26.14.39.47;	author chl;	state Exp;
branches;
next	1.112;

1.112
date	2011.08.17.20.54.16;	author gilles;	state Exp;
branches;
next	1.111;

1.111
date	2011.08.17.20.35.11;	author gilles;	state Exp;
branches;
next	1.110;

1.110
date	2011.08.17.20.04.43;	author gilles;	state Exp;
branches;
next	1.109;

1.109
date	2011.08.16.19.02.03;	author gilles;	state Exp;
branches;
next	1.108;

1.108
date	2011.07.21.23.29.24;	author gilles;	state Exp;
branches;
next	1.107;

1.107
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.106;

1.106
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.105;

1.105
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.104;

1.104
date	2011.04.17.11.39.23;	author gilles;	state Exp;
branches;
next	1.103;

1.103
date	2011.04.15.19.03.28;	author gilles;	state Exp;
branches;
next	1.102;

1.102
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.101;

1.101
date	2011.04.15.11.39.57;	author gilles;	state Exp;
branches;
next	1.100;

1.100
date	2011.04.14.23.29.56;	author gilles;	state Exp;
branches;
next	1.99;

1.99
date	2011.04.14.22.36.09;	author gilles;	state Exp;
branches;
next	1.98;

1.98
date	2011.04.14.21.53.46;	author gilles;	state Exp;
branches;
next	1.97;

1.97
date	2011.04.14.20.11.08;	author gilles;	state Exp;
branches;
next	1.96;

1.96
date	2011.04.13.20.53.18;	author gilles;	state Exp;
branches;
next	1.95;

1.95
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.94;

1.94
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.93;

1.93
date	2010.11.24.23.27.04;	author todd;	state Exp;
branches;
next	1.92;

1.92
date	2010.10.28.21.15.50;	author gilles;	state Exp;
branches;
next	1.91;

1.91
date	2010.10.09.22.12.26;	author gilles;	state Exp;
branches;
next	1.90;

1.90
date	2010.06.01.23.06.23;	author jacekm;	state dead;
branches;
next	1.89;

1.89
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.88;

1.88
date	2010.05.31.23.38.56;	author jacekm;	state dead;
branches;
next	1.87;

1.87
date	2010.05.19.20.57.10;	author gilles;	state Exp;
branches;
next	1.86;

1.86
date	2010.04.22.12.56.33;	author jacekm;	state Exp;
branches;
next	1.85;

1.85
date	2010.04.22.12.13.33;	author jacekm;	state Exp;
branches;
next	1.84;

1.84
date	2010.04.21.18.54.43;	author jacekm;	state Exp;
branches;
next	1.83;

1.83
date	2010.04.21.08.29.01;	author jacekm;	state Exp;
branches;
next	1.82;

1.82
date	2010.04.21.00.12.49;	author jacekm;	state Exp;
branches;
next	1.81;

1.81
date	2010.04.20.20.55.04;	author jacekm;	state Exp;
branches;
next	1.80;

1.80
date	2010.04.20.15.34.56;	author jacekm;	state Exp;
branches;
next	1.79;

1.79
date	2010.04.19.08.14.07;	author jacekm;	state Exp;
branches;
next	1.78;

1.78
date	2010.01.10.16.42.35;	author gilles;	state Exp;
branches;
next	1.77;

1.77
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.76;

1.76
date	2009.12.14.19.56.55;	author jacekm;	state Exp;
branches;
next	1.75;

1.75
date	2009.12.14.18.21.53;	author jacekm;	state Exp;
branches;
next	1.74;

1.74
date	2009.12.14.16.44.14;	author jacekm;	state Exp;
branches;
next	1.73;

1.73
date	2009.12.13.22.02.55;	author jacekm;	state Exp;
branches;
next	1.72;

1.72
date	2009.11.08.23.08.56;	author gilles;	state Exp;
branches;
next	1.71;

1.71
date	2009.11.08.21.40.05;	author gilles;	state Exp;
branches;
next	1.70;

1.70
date	2009.11.03.11.10.43;	author jacekm;	state Exp;
branches;
next	1.69;

1.69
date	2009.11.01.22.15.27;	author gilles;	state Exp;
branches;
next	1.68;

1.68
date	2009.10.12.22.34.37;	author gilles;	state Exp;
branches;
next	1.67;

1.67
date	2009.09.04.19.11.32;	author jacekm;	state Exp;
branches;
next	1.66;

1.66
date	2009.09.04.13.33.00;	author jacekm;	state Exp;
branches;
next	1.65;

1.65
date	2009.09.04.11.44.23;	author jacekm;	state Exp;
branches;
next	1.64;

1.64
date	2009.09.03.08.19.13;	author jacekm;	state Exp;
branches;
next	1.63;

1.63
date	2009.08.27.11.37.30;	author jacekm;	state Exp;
branches;
next	1.62;

1.62
date	2009.08.11.14.46.58;	author jacekm;	state Exp;
branches;
next	1.61;

1.61
date	2009.08.11.14.45.19;	author jacekm;	state Exp;
branches;
next	1.60;

1.60
date	2009.08.08.00.02.22;	author gilles;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.06.16.46.57;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2009.08.06.16.29.35;	author gilles;	state Exp;
branches;
next	1.57;

1.57
date	2009.08.06.14.32.34;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2009.08.06.14.12.48;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2009.08.06.13.40.45;	author gilles;	state Exp;
branches;
next	1.54;

1.54
date	2009.07.28.22.03.55;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.29.10.11.07;	author martynas;	state Exp;
branches;
next	1.52;

1.52
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.51;

1.51
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2009.06.03.22.04.15;	author jacekm;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.01.13.20.56;	author jacekm;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.24.14.38.56;	author jacekm;	state Exp;
branches;
next	1.47;

1.47
date	2009.05.24.14.22.23;	author jacekm;	state Exp;
branches;
next	1.46;

1.46
date	2009.05.19.11.24.24;	author jacekm;	state Exp;
branches;
next	1.45;

1.45
date	2009.05.14.15.05.12;	author eric;	state Exp;
branches;
next	1.44;

1.44
date	2009.05.10.11.29.40;	author jacekm;	state Exp;
branches;
next	1.43;

1.43
date	2009.04.21.18.39.00;	author jacekm;	state Exp;
branches;
next	1.42;

1.42
date	2009.04.21.18.12.05;	author jacekm;	state Exp;
branches;
next	1.41;

1.41
date	2009.04.21.14.37.32;	author eric;	state Exp;
branches;
next	1.40;

1.40
date	2009.04.18.21.13.56;	author jacekm;	state Exp;
branches;
next	1.39;

1.39
date	2009.04.12.15.42.13;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.29.14.18.20;	author jacekm;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.22.22.53.47;	author gilles;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.18.10.29.27;	author gilles;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.15.19.15.25;	author gilles;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.09.01.43.19;	author gilles;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.24.12.07.47;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.22.23.29.54;	author jacekm;	state Exp;
branches;
next	1.31;

1.31
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.15.10.32.23;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.14.17.49.09;	author jacekm;	state Exp;
branches;
next	1.28;

1.28
date	2009.01.29.21.59.15;	author jacekm;	state Exp;
branches;
next	1.27;

1.27
date	2009.01.29.12.43.25;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2009.01.28.17.43.45;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.28.17.29.11;	author jacekm;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.28.13.29.40;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.27.22.48.29;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.08.19.15.23;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.06.23.02.07;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.06.20.17.23;	author jacekm;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.04.22.35.09;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.04.22.18.23;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.04.20.52.06;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.04.19.37.41;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.04.19.26.30;	author jacekm;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.04.19.25.19;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.04.19.23.06;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.27.17.45.54;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.27.17.36.37;	author jacekm;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.27.17.03.29;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.19.00.39.05;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.17.18.47.37;	author jacekm;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.13.23.19.34;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.11.22.59.14;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.11.22.32.27;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.07.03.14.24;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.07.01.55.41;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.05.19.09.59;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.05.02.51.32;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.145
log
@- runner is the terminology we used back when we had runqueues, we no
  longer have them and runner is actually a scheduler so rename.
- introduce scheduler_backend which does the same to scheduler than
  queue_backend does to queue and map_backend does to maps
- remove all occurences of RUNNER and runner, replace them with SCHEDULER
  and scheduler

ok eric@@, ok chl@@
@
text
@/*	$OpenBSD: runner.c,v 1.144 2012/07/09 08:08:29 gilles Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2008-2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <inttypes.h>
#include <libgen.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

static void runner_imsg(struct imsgev *, struct imsg *);
static void runner_shutdown(void);
static void runner_sig_handler(int, short, void *);
static void runner_setup_events(void);
static void runner_reset_events(void);
static void runner_disable_events(void);
static void runner_timeout(int, short, void *);
static void runner_remove(u_int64_t);
static void runner_remove_envelope(u_int64_t);
static int runner_process_envelope(u_int64_t);
static int runner_process_batch(enum delivery_type, u_int64_t);
static int runner_check_loop(struct envelope *);
static int runner_message_to_scheduler(u_int32_t);

static struct scheduler_backend *scheduler = NULL;

extern const char *backend_scheduler;

void
runner_imsg(struct imsgev *iev, struct imsg *imsg)
{
	struct envelope	*e, bounce;
	struct scheduler_info	si;

	log_imsg(PROC_RUNNER, iev->proc, imsg);

	switch (imsg->hdr.type) {
	case IMSG_QUEUE_COMMIT_MESSAGE:
		e = imsg->data;
		runner_message_to_scheduler(evpid_to_msgid(e->id));
		runner_reset_events();
		return;

	case IMSG_QUEUE_DELIVERY_OK:
		stat_decrement(STATS_RUNNER);
		e = imsg->data;
		log_debug("queue_delivery_ok: %016"PRIx64, e->id);
		scheduler->remove(e->id);
		queue_envelope_delete(e);
		return;

	case IMSG_QUEUE_DELIVERY_TEMPFAIL:
		stat_decrement(STATS_RUNNER);
		e = imsg->data;
		e->retry++;
		queue_envelope_update(e);
		log_debug("queue_delivery_tempfail: %016"PRIx64, e->id);
		scheduler_info(&si, e);
		scheduler->insert(&si);
		runner_reset_events();
		return;

	case IMSG_QUEUE_DELIVERY_PERMFAIL:
		stat_decrement(STATS_RUNNER);
		e = imsg->data;
		if (e->type != D_BOUNCE && e->sender.user[0] != '\0') {
			bounce_record_message(e, &bounce);
			log_debug("queue_delivery_permfail: %016"PRIx64,
			    bounce.id);
			scheduler_info(&si, &bounce);
			scheduler->insert(&si);
			runner_reset_events();
		}
		scheduler->remove(e->id);
		queue_envelope_delete(e);
		return;

	case IMSG_MDA_SESS_NEW:
		stat_decrement(STATS_MDA_SESSION);
		if (env->sc_maxconn - stat_get(STATS_MDA_SESSION, STAT_ACTIVE))
			env->sc_flags &= ~SMTPD_MDA_BUSY;
		runner_reset_events();
		return;

	case IMSG_BATCH_DONE:
		stat_decrement(STATS_MTA_SESSION);
		if (env->sc_maxconn - stat_get(STATS_MTA_SESSION, STAT_ACTIVE))
			env->sc_flags &= ~SMTPD_MTA_BUSY;
		runner_reset_events();
		return;

	case IMSG_SMTP_ENQUEUE:
		e = imsg->data;
		if (imsg->fd < 0 || !bounce_session(imsg->fd, e)) {
			queue_envelope_update(e);
			log_debug("smtp_enqueue: %016"PRIx64, e->id);
			scheduler_info(&si, e);
			scheduler->insert(&si);
			runner_reset_events();
			return;
		}
		return;

	case IMSG_QUEUE_PAUSE_MDA:
		env->sc_flags |= SMTPD_MDA_PAUSED;
		return;

	case IMSG_QUEUE_RESUME_MDA:
		env->sc_flags &= ~SMTPD_MDA_PAUSED;
		runner_reset_events();
		return;

	case IMSG_QUEUE_PAUSE_MTA:
		env->sc_flags |= SMTPD_MTA_PAUSED;
		return;

	case IMSG_QUEUE_RESUME_MTA:
		env->sc_flags &= ~SMTPD_MTA_PAUSED;
		runner_reset_events();
		return;

	case IMSG_CTL_VERBOSE:
		log_verbose(*(int *)imsg->data);
		return;

	case IMSG_RUNNER_SCHEDULE:
		scheduler->force(*(u_int64_t *)imsg->data);
		runner_reset_events();		
		return;

	case IMSG_RUNNER_REMOVE: {
		runner_remove(*(u_int64_t *)imsg->data);
		runner_reset_events();
		return;
	}
	}

	errx(1, "runner_imsg: unexpected %s imsg", imsg_to_str(imsg->hdr.type));
}

void
runner_sig_handler(int sig, short event, void *p)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		runner_shutdown();
		break;
	default:
		fatalx("runner_sig_handler: unexpected signal");
	}
}

void
runner_shutdown(void)
{
	log_info("runner handler exiting");
	_exit(0);
}

void
runner_setup_events(void)
{
	struct timeval	 tv;

	evtimer_set(&env->sc_ev, runner_timeout, NULL);
	tv.tv_sec = 0;
	tv.tv_usec = 10;
	evtimer_add(&env->sc_ev, &tv);
}

void
runner_reset_events(void)
{
	struct timeval	 tv;

	tv.tv_sec = 0;
	tv.tv_usec = 10;
	evtimer_add(&env->sc_ev, &tv);
}

void
runner_disable_events(void)
{
	evtimer_del(&env->sc_ev);
}

pid_t
runner(void)
{
	pid_t		 pid;
	struct passwd	*pw;

	struct event	 ev_sigint;
	struct event	 ev_sigterm;

	struct peer peers[] = {
		{ PROC_CONTROL,	imsg_dispatch },
		{ PROC_QUEUE,	imsg_dispatch }
	};

	switch (pid = fork()) {
	case -1:
		fatal("runner: cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	purge_config(PURGE_EVERYTHING);

	pw = env->sc_pw;

	if (chroot(PATH_SPOOL) == -1)
		fatal("runner: chroot");
	if (chdir("/") == -1)
		fatal("runner: chdir(\"/\")");

	smtpd_process = PROC_RUNNER;
	setproctitle("%s", env->sc_title[smtpd_process]);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("runner: cannot drop privileges");

	/* see fdlimit()-related comment in queue.c */
	fdlimit(1.0);
	if ((env->sc_maxconn = availdesc() / 4) < 1)
		fatalx("runner: fd starvation");

	env->sc_scheduler = scheduler_backend_lookup(backend_scheduler);
	if (env->sc_scheduler == NULL)
		errx(1, "cannot find scheduler backend \"%s\"", backend_scheduler);
	scheduler = env->sc_scheduler;

	scheduler->init();

	imsg_callback = runner_imsg;
	event_init();

	signal_set(&ev_sigint, SIGINT, runner_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, runner_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	config_pipes(peers, nitems(peers));
	config_peers(peers, nitems(peers));

	runner_setup_events();
	event_dispatch();
	runner_disable_events();
	runner_shutdown();

	return (0);
}

void
runner_timeout(int fd, short event, void *p)
{
	struct timeval		 tv;
	static int		 rq_done = 0;
	time_t			 nsched;
	time_t			 curtm;
	u_int64_t		 evpid;

	nsched = 0;

again:
/*
	if (scheduler->display)
		scheduler->display();
*/

	curtm = time(NULL);

	/* set nsched to the time() of next schedulable envelope */
	scheduler->next(NULL, &nsched);

	/* load as many envelopes as possible from disk-queue to
	 * ram-queue until a schedulable envelope is found.
	 */
	if (! rq_done)
		rq_done = scheduler->setup(curtm, nsched);

	if (rq_done) {
		if (! scheduler->next(NULL, &nsched))
			goto scheduler_sleep;
		if (curtm < nsched)
			goto scheduler_pause;
	}

	/* let's do the schedule dance baby ! */
	while (scheduler->next(&evpid, &nsched)) {
		if (curtm < nsched)
			goto scheduler_pause;

		runner_process_envelope(evpid);
	}

	if (rq_done)
		goto scheduler_sleep;

	goto again;


scheduler_pause:
	nsched = nsched - curtm;

	log_debug("runner: nothing to do for the next %lld seconds, zZzZzZ",
	    (long long int) nsched);

	tv.tv_sec = nsched;
	tv.tv_usec = 0;
	evtimer_add(&env->sc_ev, &tv);
	return;


scheduler_sleep:
	log_debug("runner: nothing to schedule, wake me up. zZzZzZ");
	return;
}

static int
runner_process_envelope(u_int64_t evpid)
{
	struct envelope	 envelope;
	size_t		 mta_av, mda_av, bnc_av;
	struct scheduler_info	si;

	mta_av = env->sc_maxconn - stat_get(STATS_MTA_SESSION, STAT_ACTIVE);
	mda_av = env->sc_maxconn - stat_get(STATS_MDA_SESSION, STAT_ACTIVE);
	bnc_av = env->sc_maxconn - stat_get(STATS_RUNNER_BOUNCES, STAT_ACTIVE);

	if (! queue_envelope_load(evpid, &envelope))
		return 0;

	if (envelope.type == D_MDA)
		if (mda_av == 0) {
			env->sc_flags |= SMTPD_MDA_BUSY;
			return 0;
		}

	if (envelope.type == D_MTA)
		if (mta_av == 0) {
			env->sc_flags |= SMTPD_MTA_BUSY;
			return 0;
		}

	if (envelope.type == D_BOUNCE)
		if (bnc_av == 0) {
			env->sc_flags |= SMTPD_BOUNCE_BUSY;
			return 0;
		}

	if (runner_check_loop(&envelope)) {
		struct envelope bounce;

		envelope_set_errormsg(&envelope, "loop has been detected");
		if (bounce_record_message(&envelope, &bounce)) {
			scheduler_info(&si, &bounce);
			scheduler->insert(&si);
		}
		scheduler->remove(evpid);
		queue_envelope_delete(&envelope);

		runner_reset_events();

		return 0;
	}


	return runner_process_batch(envelope.type, evpid);
}

static int
runner_process_batch(enum delivery_type type, u_int64_t evpid)
{
	struct envelope evp;
	void *batch;
	int fd;

	batch = scheduler->batch(evpid);
	switch (type) {
	case D_BOUNCE:
		while (scheduler->fetch(batch, &evpid)) {
			if (! queue_envelope_load(evpid, &evp))
				goto end;

			evp.lasttry = time(NULL);
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_SMTP_ENQUEUE, PROC_SMTP, 0, -1, &evp,
			    sizeof evp);
			scheduler->schedule(evpid);
		}
		stat_increment(STATS_RUNNER);
		stat_increment(STATS_RUNNER_BOUNCES);
		break;
		
	case D_MDA:
		scheduler->fetch(batch, &evpid);
		if (! queue_envelope_load(evpid, &evp))
			goto end;
		
		evp.lasttry = time(NULL);
		fd = queue_message_fd_r(evpid_to_msgid(evpid));
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_MDA_SESS_NEW, PROC_MDA, 0, fd, &evp,
		    sizeof evp);
		scheduler->schedule(evpid);

		stat_increment(STATS_RUNNER);
		stat_increment(STATS_MDA_SESSION);
		break;

	case D_MTA: {
		struct mta_batch mta_batch;

		/* FIXME */
		if (! scheduler->fetch(batch, &evpid))
			goto end;
		if (! queue_envelope_load(evpid, &evp))
			goto end;

		bzero(&mta_batch, sizeof mta_batch);
		mta_batch.id    = arc4random();
		mta_batch.relay = evp.agent.mta.relay;

		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_BATCH_CREATE, PROC_MTA, 0, -1, &mta_batch,
		    sizeof mta_batch);

		while (scheduler->fetch(batch, &evpid)) {
			if (! queue_envelope_load(evpid, &evp))
				goto end;
			evp.lasttry = time(NULL); /* FIXME */
			evp.batch_id = mta_batch.id;

			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_BATCH_APPEND, PROC_MTA, 0, -1, &evp,
			    sizeof evp);

			scheduler->schedule(evpid);
			stat_increment(STATS_RUNNER);
		}

		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_BATCH_CLOSE, PROC_MTA, 0, -1, &mta_batch,
		    sizeof mta_batch);

		stat_increment(STATS_MTA_SESSION);
		break;
	}
		
	default:
		fatalx("runner_process_batchqueue: unknown type");
	}

end:
	scheduler->close(batch);
	return 1;
}

static int
runner_message_to_scheduler(u_int32_t msgid)
{
	struct qwalk	*q;
	u_int64_t	 evpid;
	struct envelope	 envelope;
	struct scheduler_info	si;

	q = qwalk_new(msgid);
	while (qwalk(q, &evpid)) {
		if (! queue_envelope_load(evpid, &envelope))
			continue;
		scheduler_info(&si, &envelope);
		scheduler->insert(&si);
	}
 	qwalk_close(q);

	return 1;
}

static int
runner_check_loop(struct envelope *ep)
{
	int fd;
	FILE *fp;
	char *buf, *lbuf;
	size_t len;
	struct mailaddr maddr;
	int ret = 0;
	int rcvcount = 0;

	fd = queue_message_fd_r(evpid_to_msgid(ep->id));
	if ((fp = fdopen(fd, "r")) == NULL)
		fatal("fdopen");

	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			/* EOF without EOL, copy and add the NUL */
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}

		if (strchr(buf, ':') == NULL && !isspace((int)*buf))
			break;

		if (strncasecmp("Received: ", buf, 10) == 0) {
			rcvcount++;
			if (rcvcount == MAX_HOPS_COUNT) {
				ret = 1;
				break;
			}
		}

		else if (strncasecmp("Delivered-To: ", buf, 14) == 0) {
			struct mailaddr dest;

			bzero(&maddr, sizeof (struct mailaddr));
			if (! email_to_mailaddr(&maddr, buf + 14))
				continue;
			
			dest = ep->dest;
			if (ep->type == D_BOUNCE)
				dest = ep->sender;

			if (strcasecmp(maddr.user, dest.user) == 0 &&
			    strcasecmp(maddr.domain, dest.domain) == 0) {
				ret = 1;
				break;
			}
		}
	}
	free(lbuf);

	fclose(fp);
	return ret;
}

static void
runner_remove(u_int64_t id)
{
	void	*msg;

	/* removing by evpid */
	if (id > 0xffffffffL) {
		runner_remove_envelope(id);
		return;
	}

	/* removing by msgid */
	msg = scheduler->message(id);
	while (scheduler->fetch(msg, &id))
		runner_remove_envelope(id);
	scheduler->close(msg);
}

static void
runner_remove_envelope(u_int64_t evpid)
{
	struct envelope evp;

	evp.id = evpid;
	queue_envelope_delete(&evp);
	scheduler->remove(evpid);
}
@


1.144
log
@first step of simplifying fsqueue:

- remove the /envelopes subdirectory, envelopes are at the same level than
  the message file
- kill PATH_ENVELOPES define
- reduce the number of buckets from 0xfff to 0xff, this avoid performances
  of the queue to decrease when we start having tons of buckets

this diff introduces a change to the queue layout, you will want to empty
your queue before updating. more cleanup to come

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.143 2012/07/08 18:13:08 chl Exp $	*/
@


1.143
log
@remove enum queue_kind from queue_fsqueue.c.
incoming messages are now always stored in /incoming, whatever the queue_backend is.
remove QOP_FD_RW and fsqueue_message_fd_rw().
while there check return value of generated paths before calling rmtree()

with advice from gilles@@ and eric@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.142 2012/07/02 17:00:05 eric Exp $	*/
d309 1
d312 1
@


1.142
log
@Lookup queue and scheduler backends by name, rather than enum.
Add a command-line option to specify the backend to use at runtime.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.141 2012/06/20 20:45:23 eric Exp $	*/
d459 1
a459 2
		if (! queue_envelope_load(evpid,
				&evp))
d471 1
a471 2
			if (! queue_envelope_load(evpid,
				&evp))
@


1.141
log
@Finally get rid of the queue_kind enum in the queue API. Keep that
internally in fsqueue backend for now, and let the fsqueue_message()
and fsqueue_envelope() dispatchers do the right thing.

Based on a diff by chl@@

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.140 2012/06/20 20:27:41 eric Exp $	*/
d63 2
d269 3
a271 1
	env->sc_scheduler = scheduler_backend_lookup(SCHED_RAMQUEUE);
@


1.140
log
@fix runner spinning on message loop.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.139 2012/06/17 15:17:08 gilles Exp $	*/
d83 1
a83 1
		queue_envelope_delete(Q_QUEUE, e);
d90 1
a90 1
		queue_envelope_update(Q_QUEUE, e);
d109 1
a109 1
		queue_envelope_delete(Q_QUEUE, e);
d129 1
a129 1
			queue_envelope_update(Q_QUEUE, e);
d368 1
a368 1
	if (! queue_envelope_load(Q_QUEUE, evpid, &envelope))
d398 1
a398 1
		queue_envelope_delete(Q_QUEUE, &envelope);
d401 1
d420 1
a420 1
			if (! queue_envelope_load(Q_QUEUE, evpid, &evp))
d435 1
a435 1
		if (! queue_envelope_load(Q_QUEUE, evpid, &evp))
d439 1
a439 1
		fd = queue_message_fd_r(Q_QUEUE, evpid_to_msgid(evpid));
d455 1
a455 1
		if (! queue_envelope_load(Q_QUEUE, evpid,
d468 1
a468 1
			if (! queue_envelope_load(Q_QUEUE, evpid,
d507 1
a507 1
	q = qwalk_new(Q_QUEUE, msgid);
d509 1
a509 2
		if (! queue_envelope_load(Q_QUEUE, evpid,
			&envelope))
d530 1
a530 2
	fd = queue_message_fd_r(Q_QUEUE,
	    evpid_to_msgid(ep->id));
d606 1
a606 1
	queue_envelope_delete(Q_QUEUE, &evp);
@


1.139
log
@- introduce struct scheduler_info and the scheduler_info() function to fill
  a struct scheduler_info given a struct envelope
- adapt the scheduler API and the scheduler_ramqueue backend to use the new
  struct scheduler_info instead of a struct envelope

idea discussed with eric@@ and chl@@, mechanical diff, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.138 2012/04/15 12:12:35 chl Exp $	*/
d400 1
a400 1
		runner_setup_events();
@


1.138
log
@Remove dead assignments and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.137 2012/03/19 20:38:49 gilles Exp $	*/
d67 1
d92 2
a93 1
		scheduler->insert(e);
d104 2
a105 1
			scheduler->insert(&bounce);
d131 2
a132 1
			scheduler->insert(e);
d362 1
d393 4
a396 2
		if (bounce_record_message(&envelope, &bounce))
			scheduler->insert(&bounce);
d504 1
d511 2
a512 1
		scheduler->insert(&envelope);
@


1.137
log
@when a mailer daemon loop is detected, do not insert new bounce in ramqueue

fixes an issue experienced by myself and Roman Kravchuck

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.136 2012/03/07 22:54:49 gilles Exp $	*/
a495 1
	time_t		 curtm;
a497 1
	curtm = time(NULL);
@


1.136
log
@various reliability fixes:

- prevent queue_fsqueue from fatal() when it hits an ENOENT, it can happen
- change a bit the scheduler API to simplify it, fix runner accordingly

- we can't remove msg/batch from ramqueue while envelope is offloaded or
  it will cause a double, instead we add refcnt to both msg/batch and
  only free them when it hits 0
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.135 2012/01/31 21:05:26 gilles Exp $	*/
d388 2
a389 2
		bounce_record_message(&envelope, &bounce);
		scheduler->insert(&bounce);
@


1.135
log
@fix an issue observed this week-end while flooding ajacoutot@@ :

we keep track of available fd's to prevent scheduling of messages if we
know that we are going to fail. however, since the envelope is not
removed from the scheduler, it will be rescheduled right away leading to
a busy loop in the scheduler. we know flag the mda/mta processes as BUSY
and do not schedule envelopes that target a BUSY process.

also, fix a potential bug that could lead to a use after free when doing
a batch/message/host traversal of schedulable envelopes.

while at it fix misuse of env->sc_opts as env->sc_flags, was not really
causing any issue as the misuse was constant ...
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.134 2012/01/28 16:50:02 gilles Exp $	*/
d81 1
d105 1
d157 1
a157 1
		scheduler->schedule(*(u_int64_t *)imsg->data);
d258 5
a277 5
	/* see fdlimit()-related comment in queue.c */
	fdlimit(1.0);
	if ((env->sc_maxconn = availdesc() / 4) < 1)
		fatalx("runner: fd starvation");

d390 1
a390 1
		scheduler->remove(NULL, evpid);
d419 1
a419 1
			scheduler->remove(batch, evpid);
d435 1
a435 1
		scheduler->remove(batch, evpid);
d470 1
a470 1
			scheduler->remove(batch, evpid);
d601 1
a601 1
	scheduler->remove(NULL, evpid);
@


1.134
log
@add optional display handler to scheduler_backend, if not NULL the handler
will be called for each iteration of the runner

implement a display handler for scheduler_ramqueue to display the entire
ramqueue (hosttree, msgtree and linear queue) in log_debug
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.133 2012/01/28 11:33:07 gilles Exp $	*/
d80 1
d89 1
a97 1
			log_debug("PERMFAIL #2: %016" PRIx64, e->id);
d99 2
a102 1

d109 3
d116 3
d125 1
d133 1
a133 1
		env->sc_opts |= SMTPD_MDA_PAUSED;
d137 1
a137 1
		env->sc_opts &= ~SMTPD_MDA_PAUSED;
d142 1
a142 1
		env->sc_opts |= SMTPD_MTA_PAUSED;
d146 1
a146 1
		env->sc_opts &= ~SMTPD_MTA_PAUSED;
d360 1
a360 1
	
d365 2
a366 1
		if (mda_av == 0)
d368 1
d371 2
a372 1
		if (mta_av == 0)
d374 1
d377 2
a378 1
		if (bnc_av == 0)
d380 1
d388 1
d395 1
d417 1
a417 1
			scheduler->remove(evpid);
d433 1
a433 1
		scheduler->remove(evpid);
d468 1
a468 1
			scheduler->remove(evpid);
d599 1
a599 1
	scheduler->remove(evpid);
@


1.133
log
@- introduce the scheduler_backend API
- introduce the scheduler_ramqueue backend
- remove all occurences of ramqueue outside of the ramqueue backend
- teach runner how to use the new API

it is now possible to write custom schedulers !

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.132 2012/01/13 14:01:58 eric Exp $	*/
d290 3
@


1.132
log
@Stop using envelope->status to report delivery outcome to the
runner/queue.  Instead, replace IMSG_QUEUE_MESSAGE_UPDATE with three
messages:

- IMSG_QUEUE_DELIVERY_OK
- IMSG_QUEUE_DELIVERY_TEMPFAIL
- IMSG_QUEUE_DELIVERY_PERMFAIL

1) it's less confusing as status is also used by smtp
2) it's easier to see what happens just looking at imsg traces
3) it makes the code path generally easier to follow
4) it's safer because it enforces clear semantics and intent, whereas
   the status field is loosely defined and could carry bogus values.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.131 2012/01/12 23:17:02 gilles Exp $	*/
a46 1

d54 4
a57 2
static int runner_process_envelope(struct ramqueue_envelope *, time_t);
static void runner_process_batch(struct ramqueue_envelope *, time_t);
d59 1
a59 1
static int runner_force_message_to_ramqueue(struct ramqueue *, u_int32_t);
d61 1
d73 1
a73 2
		runner_force_message_to_ramqueue(&env->sc_rqueue,
		    evpid_to_msgid(e->id));
d88 1
a88 1
		ramqueue_insert(&env->sc_rqueue, e, time(NULL));
d98 1
a98 1
			ramqueue_insert(&env->sc_rqueue, &bounce, time(NULL));
d100 1
d117 1
a117 1
			ramqueue_insert(&env->sc_rqueue, e, time(NULL));
d146 1
a146 2
		runner_schedule(&env->sc_rqueue,
		    *(u_int64_t *)imsg->data);
d151 1
a151 2
		runner_remove(&env->sc_rqueue,
		    *(u_int64_t *)imsg->data);
d247 4
a250 1
	ramqueue_init(&env->sc_rqueue);
a280 2
	struct ramqueue		 *rqueue = &env->sc_rqueue;
	struct ramqueue_envelope *rq_evp;
d285 1
d290 4
a293 3
	rq_evp = ramqueue_next_envelope(rqueue);
	if (rq_evp)
		nsched = rq_evp->sched;
d299 8
a306 1
		rq_done = ramqueue_load(rqueue, &nsched);
d309 5
a313 9
	curtm = time(NULL);
	rq_evp = ramqueue_next_envelope(rqueue);
	while (rq_evp) {
		if (rq_evp->sched > curtm) {
			nsched = rq_evp->sched;
			break;
		}
		runner_process_envelope(rq_evp, curtm);
		rq_evp = ramqueue_next_envelope(rqueue);
d316 4
a319 4
	if (rq_evp == NULL && rq_done) {
		log_debug("runner: nothing to schedule, wake me up. zZzZzZ");
		return;
	}
a320 8
	/* disk-queues not fully loaded, no time for sleeping */
	if (!rq_done)
		nsched = 0;
	else {
		nsched = nsched - curtm;
		if (nsched < 0)
			nsched = 0;
	}
d322 2
a323 2
	if (nsched == 0)
		goto again;
d331 6
d339 2
a340 2
int
runner_process_envelope(struct ramqueue_envelope *rq_evp, time_t curtm)
d342 1
a343 1
	struct envelope	 envelope;
d349 4
a352 1
	if (rq_evp->rq_batch->type == D_MDA)
d356 1
a356 1
	if (rq_evp->rq_batch->type == D_MTA)
d360 1
a360 1
	if (rq_evp->rq_batch->type == D_BOUNCE)
a363 3
	if (! queue_envelope_load(Q_QUEUE, rq_evp->evpid, &envelope))
		return 0;

d369 3
a371 1
		ramqueue_insert(&env->sc_rqueue, &bounce, time(NULL));
a372 3
		log_debug("#### %s: queue_envelope_delete: %016" PRIx64,
		    __func__, envelope.id);
		queue_envelope_delete(Q_QUEUE, &envelope);
d376 1
a376 3
	runner_process_batch(rq_evp, curtm);

	return 1;
d379 2
a380 3

void
runner_process_batch(struct ramqueue_envelope *rq_evp, time_t curtm)
a381 3
	struct ramqueue_batch	 *rq_batch;
	struct ramqueue_message	 *rq_msg;
	struct ramqueue_host	 *rq_host;
d383 1
d386 6
a391 3
	rq_msg = rq_evp->rq_msg;
	rq_batch = rq_evp->rq_batch;
	rq_host = rq_evp->rq_host;
d393 1
a393 7
	switch (rq_batch->type) {
	case D_BOUNCE:
		while ((rq_evp = ramqueue_batch_first_envelope(rq_batch))) {
			if (! queue_envelope_load(Q_QUEUE, rq_evp->evpid,
				&evp))
				return;
			evp.lasttry = curtm;
d397 1
a397 1
			ramqueue_remove_envelope(&env->sc_rqueue, rq_evp);
a398 1

a400 1

d404 6
a409 6
		rq_evp = ramqueue_batch_first_envelope(rq_batch);
		if (! queue_envelope_load(Q_QUEUE, rq_evp->evpid, &evp))
			return;
		evp.lasttry = curtm;
		fd = queue_message_fd_r(Q_QUEUE,
		    evpid_to_msgid(rq_evp->evpid));
d413 1
a413 1
		ramqueue_remove_envelope(&env->sc_rqueue, rq_evp);
d417 15
a432 3
		break;
		
	case D_MTA:
d434 5
a438 4
		    IMSG_BATCH_CREATE, PROC_MTA, 0, -1, rq_batch,
		    sizeof *rq_batch);
		while ((rq_evp = ramqueue_batch_first_envelope(rq_batch))) {
			if (! queue_envelope_load(Q_QUEUE, rq_evp->evpid,
d440 4
a443 3
				return;
			evp.lasttry = curtm;
			evp.batch_id = rq_batch->b_id;
d447 2
a448 1
			ramqueue_remove_envelope(&env->sc_rqueue, rq_evp);
d451 1
d453 2
a454 2
		    IMSG_BATCH_CLOSE, PROC_MTA, 0, -1, rq_batch,
		    sizeof *rq_batch);
d458 1
d464 3
a466 8
	if (ramqueue_message_is_empty(rq_msg))
		ramqueue_remove_message(&env->sc_rqueue, rq_msg);

	if (ramqueue_batch_is_empty(rq_batch))
		ramqueue_remove_batch(rq_host, rq_batch);

	if (ramqueue_host_is_empty(rq_host))
		ramqueue_remove_host(&env->sc_rqueue, rq_host);
d469 2
a470 2
int
runner_force_message_to_ramqueue(struct ramqueue *rqueue, u_int32_t msgid)
d483 1
a483 1
		ramqueue_insert(rqueue, &envelope, curtm);
d490 1
a490 1
int
d554 2
a555 9
void
runner_schedule(struct ramqueue *rq, u_int64_t id)
{
	ramqueue_schedule(rq, id);
}


void
runner_remove(struct ramqueue *rq, u_int64_t id)
d557 1
a557 2
	struct ramqueue_message *rq_msg;
	struct ramqueue_envelope *rq_evp;
d561 1
a561 4
		rq_evp = ramqueue_lookup_envelope(rq, id);
		if (rq_evp == NULL)
			return;
		runner_remove_envelope(rq, rq_evp);
d565 5
a569 8
	rq_msg = ramqueue_lookup_message(rq, id);
	if (rq_msg == NULL)
		return;

	/* scheduling by msgid */
	RB_FOREACH(rq_evp, evptree, &rq_msg->evptree) {
		runner_remove_envelope(rq, rq_evp);
	}
d572 2
a573 2
void
runner_remove_envelope(struct ramqueue *rq, struct ramqueue_envelope *rq_evp)
d577 3
a579 7
	if (queue_envelope_load(Q_QUEUE, rq_evp->evpid, &evp)) {
		log_debug("#### %s: queue_envelope_delete: %016" PRIx64,
		    __func__, evp.id);
		queue_envelope_delete(Q_QUEUE, &evp);
	}

	ramqueue_remove_envelope(rq, rq_evp);
@


1.131
log
@we should never use ramqueue_first_envelope() as a mean to determine the
first schedulable envelope otherwise we end up with nsched wrong ...

heck, let's kill ramqueue_first_envelope() and be done with it ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.130 2012/01/12 22:59:55 eric Exp $	*/
d64 1
a64 1
	struct envelope	*e;
d76 8
a83 1
	case IMSG_QUEUE_MESSAGE_UPDATE:
d86 6
d93 5
a97 8

		/* temporary failure, message remains in queue,
		 * gets reinserted in ramqueue
		 */
		if (e->status & DS_TEMPFAILURE) {
			log_debug("TEMPFAIL: %016" PRIx64, e->id);
			queue_envelope_update(Q_QUEUE, e);
			ramqueue_insert(&env->sc_rqueue, e, time(NULL));
a98 1
			return;
a99 21

		/* permanent failure, eventually generate a
		 * bounce (and insert bounce in ramqueue).
		 */
		if (e->status & DS_PERMFAILURE) {
			struct envelope bounce;
			log_debug("PERMFAIL: %016" PRIx64, e->id);
			if (e->type != D_BOUNCE &&
			    e->sender.user[0] != '\0') {
				log_debug("PERMFAIL #2: %016" PRIx64, e->id);
				bounce_record_message(e, &bounce);
				ramqueue_insert(&env->sc_rqueue, &bounce, time(NULL));
				runner_reset_events();
			}
		}

		/* successful delivery or permanent failure,
		 * remove envelope from queue.
		 */
		log_debug("#### %s: queue_envelope_delete: %016" PRIx64,
		    __func__, e->id);
@


1.130
log
@The status field in the envelope is confusing. Its only purpose is to
notify the runner of what happened with an envelope that has been
scheduled.  It is not part of the state of the envelope, and it is not
even dumped.  So it should only be set by mta/mda, checked by runner
to decide what to do with the envelope, and ignored everywhere else.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.129 2012/01/12 22:40:16 gilles Exp $	*/
d300 1
a300 1
	rq_evp = ramqueue_first_envelope(rqueue);
@


1.129
log
@the ramqueue filling at startup was busted, it would load envelopes one by
one instead of doing it efficiently.

fix runner_timeout() and ramqueue_load() so that at startup smtpd fills the
ramqueue as long as there's no schedulable envelope in it, interrupts
filling if there is and resume once it's scheduled.

bug spotted by Nathanael Rensel, bug fix by me w/ help from eric@@
tested by eric@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.128 2012/01/12 22:00:21 gilles Exp $	*/
a85 1
			e->status &= ~DS_TEMPFAILURE;
a125 1
			e->status = 0;
@


1.128
log
@now that we no longer do a stateful iteration on schedule queue, we need
to make ramqueue_next_envelope() aware of pauses in mda/mta. while at it
kill the pausing of bounces since they are reinjected in smtp and end up
paused by the mda/mta cases.

fixes an infinite loop observed by eric@@ when pausing deliveries and
trying to interrupt smtpd while it attempts to fetch next envelope :)

tested by eric@@ and I, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.127 2012/01/11 17:46:36 eric Exp $	*/
d300 2
a311 1

d324 1
a324 2
	if (rq_evp == NULL ||
	    (rq_done && ramqueue_is_empty(rqueue))) {
d337 3
@


1.127
log
@Simplify runner/queue by getting rid of Q_PURGE.  Instead, let smtpd
periodically clear the purge/ directory.  At init time, the fsqueue
backend simply moves the existing incoming/ dir in purge/ to discard
aborted sessions.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.126 2011/11/16 19:38:56 eric Exp $	*/
d356 1
a356 3
	if (rq_evp->rq_batch->type == D_MDA) {
		if (env->sc_opts & SMTPD_MDA_PAUSED)
			return 0;
a358 1
	}
d360 1
a360 3
	if (rq_evp->rq_batch->type == D_MTA) {
		if (env->sc_opts & SMTPD_MTA_PAUSED)
			return 0;
a362 1
	}
d364 1
a364 3
	if (rq_evp->rq_batch->type == D_BOUNCE) {
		if (env->sc_opts & (SMTPD_MDA_PAUSED|SMTPD_MTA_PAUSED))
			return 0;
a366 1
	}
@


1.126
log
@remove unused functions

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.125 2011/11/15 23:06:39 gilles Exp $	*/
a56 1
static void runner_purge_run(void);
a298 2
	runner_purge_run();

a502 15
}

void
runner_purge_run(void)
{
	struct qwalk	*q;
	u_int32_t	 msgid;
	u_int64_t	 evpid;

	q = qwalk_new(Q_PURGE, 0);
	while (qwalk(q, &evpid)) {
		msgid = evpid_to_msgid(evpid);
		queue_message_delete(Q_PURGE, msgid);
	}
	qwalk_close(q);
@


1.125
log
@Qwalk, our API to linearly walk over the persistent queue, did not take the
queue_backend into account and assumed a filesystem with a specific layout.

This commit does plenty of things:

- make qwalk an abstraction in the queue_backend API, and impose queue
  drivers to implement qwalk_open(), qwalk() and qwalk_close();

- move previous qwalk_open(), qwalk() and qwalk_close() to the fsqueue
  driver since they were fsqueue specific ...

- make qwalk API work with msgid/evpid instead of pathnames since we're
  going to use the queue_backend API to load envelopes by evpid anyway;

- makes smtpd use *solely* the queue_backend API when manipulating the
  queue. pathnames were removed from smtpd.h and moved into the fsqueue
  which means we can now store a queue anywhere ... as long as we write
  the ten functions or so required for a queue driver ;-)

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.124 2011/11/14 19:23:41 chl Exp $	*/
a59 5


/*temporary*/
u_int64_t	filename_to_evpid(char *);
u_int32_t	filename_to_msgid(char *);
@


1.124
log
@when receiving an unexpected imsg, print its name.

with help and ideas from eric@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.123 2011/11/07 11:14:10 eric Exp $	*/
a57 1
static void runner_purge_message(u_int32_t);
a286 2
	unlink(PATH_QUEUE "/envelope.tmp");

a491 1
/* XXX - temporary solution */
d495 4
a498 13
	char path[MAXPATHLEN];
	DIR *dirp;
	struct dirent *dp;
	struct envelope envelope;
	time_t curtm;

	if (! bsnprintf(path, MAXPATHLEN, "%s/%03x/%08x/envelopes",
		PATH_QUEUE, msgid & 0xfff, msgid))
		return 0;

	dirp = opendir(path);
	if (dirp == NULL)
		return 0;
d501 2
a502 12
	while ((dp = readdir(dirp)) != NULL) {
		u_int64_t evpid;

		if (dp->d_name[0] == '.')
			continue;

		if ((evpid = filename_to_evpid(dp->d_name)) == 0) {
			log_warnx("runner_force_message_to_ramqueue: "
				  "invalid evpid: %016" PRIx64, evpid);
			continue;
		}

d508 1
a508 1
	closedir(dirp);
a515 1
	char		 path[MAXPATHLEN];
d517 2
d520 4
a523 15
	q = qwalk_new(PATH_PURGE);

	while (qwalk(q, path)) {
		u_int32_t msgid;
		char *bpath;
		
		bpath = basename(path);
		if (bpath[0] == '.')
			continue;

		if ((msgid = filename_to_msgid(bpath)) == 0) {
			log_warnx("runner_purge_run: invalid msgid: %08x", msgid);
			continue;
		}
		runner_purge_message(msgid);
a524 1

a525 54
}

void
runner_purge_message(u_int32_t msgid)
{
	char rootdir[MAXPATHLEN];
	char evpdir[MAXPATHLEN];
	char evppath[MAXPATHLEN];
	char msgpath[MAXPATHLEN];
	DIR *dirp;
	struct dirent *dp;
	
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%08x", PATH_PURGE, msgid))
		fatal("runner_purge_message: snprintf");

	if (! bsnprintf(evpdir, sizeof(evpdir), "%s%s", rootdir,
		PATH_ENVELOPES))
		fatal("runner_purge_message: snprintf");
	
	if (! bsnprintf(msgpath, sizeof(msgpath), "%s/message", rootdir))
		fatal("runner_purge_message: snprintf");

	if (unlink(msgpath) == -1)
		if (errno != ENOENT)
			fatal("runner_purge_message: unlink");

	dirp = opendir(evpdir);
	if (dirp == NULL) {
		if (errno == ENOENT)
			goto delroot;
		fatal("runner_purge_message: opendir");
	}
	while ((dp = readdir(dirp)) != NULL) {
		if (strcmp(dp->d_name, ".") == 0 ||
		    strcmp(dp->d_name, "..") == 0)
			continue;
		if (! bsnprintf(evppath, sizeof(evppath), "%s/%s", evpdir,
			dp->d_name))
			fatal("runner_purge_message: snprintf");

		if (unlink(evppath) == -1)
			if (errno != ENOENT)
				fatal("runner_purge_message: unlink");
	}
	closedir(dirp);

	if (rmdir(evpdir) == -1)
		if (errno != ENOENT)
			fatal("runner_purge_message: rmdir");

delroot:
	if (rmdir(rootdir) == -1)
		if (errno != ENOENT)
			fatal("runner_purge_message: rmdir");
@


1.123
log
@Let the smtpd process handle the enqueueing of offline messages at
startup, rather than playing tricks with the runner. This will allow
further simplifications and improvements in the runner/queue.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.122 2011/10/27 14:32:57 chl Exp $	*/
d178 1
a178 1
	fatalx("runner_imsg: unexpected imsg");
@


1.122
log
@Use PRI{x,d}64 in format strings instead of %llx, %lld or %qd to print {u_,}int64_t or time_t

While there, cast some time_t to int64_t

These will fix build warnings for portable smptd

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.121 2011/10/26 20:47:31 gilles Exp $	*/
a130 4
	case IMSG_PARENT_ENQUEUE_OFFLINE:
		/*		runner_process_offline();*/
		return;

a304 1
	static int		 rq_off_done = 0;
a314 9

	/* fetch one offline message at a time to prevent a huge
	 * offline queue from hogging the deliveries of incoming
	 * messages.
	 */
	if (! rq_off_done)
		rq_off_done = ramqueue_load_offline(rqueue);


d335 1
a335 1
	    (rq_done && rq_off_done && ramqueue_is_empty(rqueue))) {
d341 1
a341 1
	if (!rq_done || !rq_off_done)
@


1.121
log
@- fix smtpctl pause/resume so the ramqueue scheduling is done correctly
- rename IMSG and smtpctl pause/resume parameters
- update man page

tested by me, ok chl@@, eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.120 2011/10/23 09:30:07 gilles Exp $	*/
d34 1
d92 1
a92 1
			log_debug("TEMPFAIL: %016llx", e->id);
d105 1
a105 1
			log_debug("PERMFAIL: %016llx", e->id);
d108 1
a108 1
				log_debug("PERMFAIL #2: %016llx", e->id);
d118 1
a118 1
		log_debug("#### %s: queue_envelope_delete: %016llx",
d412 1
a412 1
		log_debug("#### %s: queue_envelope_delete: %016llx",
d535 2
a536 1
			log_warnx("runner_force_message_to_ramqueue: invalid evpid: %016llx", evpid);
d732 1
a732 1
		log_debug("#### %s: queue_envelope_delete: %016llx",
@


1.120
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.119 2011/10/09 18:39:53 eric Exp $	*/
d145 1
a145 1
	case IMSG_QUEUE_PAUSE_LOCAL:
d149 1
a149 1
	case IMSG_QUEUE_RESUME_LOCAL:
d151 1
d154 1
a154 1
	case IMSG_QUEUE_PAUSE_OUTGOING:
d158 1
a158 1
	case IMSG_QUEUE_RESUME_OUTGOING:
d160 1
d339 2
a340 1
		if (rq_evp->sched > curtm)
d342 1
d347 3
a349 2
	if (rq_done && rq_off_done && ramqueue_is_empty(rqueue)) {
		log_debug("runner: ramqueue is empty, wake me up. zZzZzZ");
d380 1
a380 4
	if (! queue_envelope_load(Q_QUEUE, rq_evp->evpid, &envelope))
		return 0;

	if (envelope.type & D_MDA) {
d387 1
a387 1
	if (envelope.type & D_MTA) {
d394 1
a394 1
	if (envelope.type & D_BOUNCE) {
d400 3
@


1.119
log
@show messages sent between processes in debug mode

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.118 2011/09/18 21:37:53 gilles Exp $	*/
a62 1
u_int16_t	fsqueue_hash(u_int32_t);
d77 2
a78 1
		runner_force_message_to_ramqueue(&env->sc_rqueue, e->delivery.id>>32);
d84 1
a84 1
		e->delivery.retry++;
d90 3
a92 2
		if (e->delivery.status & DS_TEMPFAILURE) {
			e->delivery.status &= ~DS_TEMPFAILURE;
d102 1
a102 1
		if (e->delivery.status & DS_PERMFAILURE) {
d104 4
a107 3

			if (e->delivery.type != D_BOUNCE &&
			    e->delivery.from.user[0] != '\0') {
d117 2
d137 1
a137 1
			e->delivery.status = 0;
d378 1
a378 1
	if (envelope.delivery.type & D_MDA) {
d385 1
a385 1
	if (envelope.delivery.type & D_MTA) {
d392 1
a392 1
	if (envelope.delivery.type & D_BOUNCE) {
d406 2
d437 1
a437 1
			evp.delivery.lasttry = curtm;
d453 3
a455 2
		evp.delivery.lasttry = curtm;
		fd = queue_message_fd_r(Q_QUEUE, rq_evp->evpid>>32);
d474 1
a474 1
			evp.delivery.lasttry = curtm;
d513 2
a514 2
	if (! bsnprintf(path, MAXPATHLEN, "%s/%04x/%08x/envelopes",
		PATH_QUEUE, fsqueue_hash(msgid), msgid))
d634 2
a635 1
	fd = queue_message_fd_r(Q_QUEUE, ep->delivery.id>>32);
d664 1
a664 1
			struct mailaddr rcpt;
d669 4
d674 2
a675 6
			rcpt = ep->delivery.rcpt;
			if (ep->delivery.type == D_BOUNCE)
				rcpt = ep->delivery.from;

			if (strcasecmp(maddr.user, rcpt.user) == 0 &&
			    strcasecmp(maddr.domain, rcpt.domain) == 0) {
d724 3
a726 1
	if (queue_envelope_load(Q_QUEUE, rq_evp->evpid, &evp))
d728 1
@


1.118
log
@a single ramqueue message may be shared by many ramqueue envelopes to be
delivered to many ramqueue hosts, therefore storing the rq_host pointer in
the rq_msg envelope is wrong and causes baaaaad behavior.

this commit fixes reliability issues in runner process, experienced and
reported by many
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.117 2011/09/01 19:56:49 eric Exp $	*/
d72 2
@


1.117
log
@Introduce a small set of functions to manage stat counters in a
simpler and hopefully saner way.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.116 2011/08/30 17:06:01 chl Exp $	*/
d421 1
a421 1
	rq_host = rq_msg->rq_host;
@


1.116
log
@Call free() into ramqueue_remove_{batch,host,message,envelope}() instead of just after the function call.

While there, also include stats counters into their respective function.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.115 2011/08/29 21:43:09 chl Exp $	*/
d83 1
a83 1
		env->stats->runner.active--;
d117 1
a117 1
		env->stats->mda.sessions_active--;
d121 1
a121 1
		env->stats->mta.sessions_active--;
d365 3
a367 3
	mta_av = env->sc_maxconn - env->stats->mta.sessions_active;
	mda_av = env->sc_maxconn - env->stats->mda.sessions_active;
	bnc_av = env->sc_maxconn - env->stats->runner.bounces_active;
d435 4
a438 7
		env->stats->runner.bounces_active++;
		env->stats->runner.bounces++;
		SET_IF_GREATER(env->stats->runner.bounces_active,
		    env->stats->runner.bounces_maxactive);
		env->stats->runner.active++;
		SET_IF_GREATER(env->stats->runner.active,
		    env->stats->runner.maxactive);
d452 3
a454 7
		env->stats->mda.sessions_active++;
		env->stats->mda.sessions++;
		SET_IF_GREATER(env->stats->mda.sessions_active,
		    env->stats->mda.sessions_maxactive);
		env->stats->runner.active++;
		SET_IF_GREATER(env->stats->runner.active,
		    env->stats->runner.maxactive);
d471 1
a471 3
			env->stats->runner.active++;
			SET_IF_GREATER(env->stats->runner.active,
			    env->stats->runner.maxactive);
d476 2
a477 4
		env->stats->mta.sessions_active++;
		env->stats->mta.sessions++;
		SET_IF_GREATER(env->stats->mta.sessions_active,
		    env->stats->mta.sessions_maxactive);
@


1.115
log
@cast all printed time_t to long long int, and change format string accordingly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.114 2011/08/29 18:49:29 chl Exp $	*/
a433 1
			free(rq_evp);
a453 1
		free(rq_evp);
a477 1
			free(rq_evp);
d495 1
a495 1
	if (ramqueue_message_is_empty(rq_msg)) {
a496 4
		free(rq_msg);
		env->stats->ramqueue.messages--;
		
	}
d498 1
a498 1
	if (ramqueue_batch_is_empty(rq_batch)) {
a499 4
		free(rq_batch);
		env->stats->ramqueue.batches--;
		
	}
d501 1
a501 1
	if (ramqueue_host_is_empty(rq_host)) {
a502 3
		free(rq_host);
		env->stats->ramqueue.hosts--;
	}
a728 1
	free(rq_evp);
@


1.114
log
@add missing header needed by signal()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.113 2011/08/26 14:39:47 chl Exp $	*/
d351 2
a352 2
	log_debug("runner: nothing to do for the next %d seconds, zZzZzZ",
	    nsched);
@


1.113
log
@add missing header needed by time()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.112 2011/08/17 20:54:16 gilles Exp $	*/
d36 1
@


1.112
log
@- plug a memory leak in runner_remove_envelope()
- cosmetic change
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.111 2011/08/17 20:35:11 gilles Exp $	*/
d39 1
@


1.111
log
@move ramqueue_host pointer from ramqueue_envelope to ramqueue_message.
this allows us to save one pointer from each envelope stored in ram while
still allowing O(1) host lookups by ramqueue_envelope.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.110 2011/08/17 20:04:43 gilles Exp $	*/
d414 1
a414 1
	struct envelope envelope;
d425 1
a425 1
				&envelope))
d427 1
a427 1
			envelope.delivery.lasttry = curtm;
d429 2
a430 2
			    IMSG_SMTP_ENQUEUE, PROC_SMTP, 0, -1, &envelope,
			    sizeof envelope);
d445 1
a445 1
		if (! queue_envelope_load(Q_QUEUE, rq_evp->evpid, &envelope))
d447 1
a447 1
		envelope.delivery.lasttry = curtm;
d450 2
a451 2
		    IMSG_MDA_SESS_NEW, PROC_MDA, 0, fd, &envelope,
		    sizeof envelope);
d470 1
a470 1
				&envelope))
d472 2
a473 2
			envelope.delivery.lasttry = curtm;
			envelope.batch_id = rq_batch->b_id;
d475 2
a476 2
			    IMSG_BATCH_APPEND, PROC_MTA, 0, -1, &envelope,
			    sizeof envelope);
d741 1
@


1.110
log
@- teach smtpctl remove about the new ramqueue structure
- bonus #1: O(log n) removal of envelopes
- bonus #2: removing all envelopes that have the same msgid works again
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.109 2011/08/16 19:02:03 gilles Exp $	*/
d411 3
a413 3
	struct ramqueue_host	 *host = rq_evp->host;
	struct ramqueue_batch	 *batch = rq_evp->batch;
	struct ramqueue_message	 *message = rq_evp->message;
d417 5
a421 1
	switch (batch->type) {
d423 1
a423 1
		while ((rq_evp = ramqueue_batch_first_envelope(batch))) {
d444 1
a444 2

		rq_evp = ramqueue_batch_first_envelope(batch);
d466 3
a468 3
		    IMSG_BATCH_CREATE, PROC_MTA, 0, -1, batch,
		    sizeof *batch);
		while ((rq_evp = ramqueue_batch_first_envelope(batch))) {
d473 1
a473 1
			envelope.batch_id = batch->b_id;
d484 2
a485 2
		    IMSG_BATCH_CLOSE, PROC_MTA, 0, -1, batch,
		    sizeof *batch);
d496 3
a498 3
	if (ramqueue_message_is_empty(message)) {
		ramqueue_remove_message(&env->sc_rqueue, message);
		free(message);
d503 3
a505 3
	if (ramqueue_batch_is_empty(batch)) {
		ramqueue_remove_batch(host, batch);
		free(batch);
d510 3
a512 3
	if (ramqueue_host_is_empty(host)) {
		ramqueue_remove_host(&env->sc_rqueue, host);
		free(host);
@


1.109
log
@add a host-tree and an envelope-tree in the ramqueue, they will be used to
improve scheduling and general ramqueue operations. unused yet
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.108 2011/07/21 23:29:24 gilles Exp $	*/
d158 1
a158 1
		ramqueue_reschedule(&env->sc_rqueue,
d164 2
a165 15
		u_int64_t ullval = *(u_int64_t *)imsg->data;
		struct envelope	 envelope;
		struct ramqueue_envelope *rq_evp;
		
		if (! queue_envelope_load(Q_QUEUE, ullval, &envelope))
			return;
		
		rq_evp = ramqueue_envelope_by_id(&env->sc_rqueue, ullval);
		if (rq_evp == NULL)
			return;

		ramqueue_remove(&env->sc_rqueue, rq_evp);

		queue_envelope_delete(Q_QUEUE, &envelope);

d427 1
a427 1
			ramqueue_remove(&env->sc_rqueue, rq_evp);
d449 1
a449 1
		ramqueue_remove(&env->sc_rqueue, rq_evp);
d474 1
a474 1
			ramqueue_remove(&env->sc_rqueue, rq_evp);
d695 43
@


1.108
log
@- update smtpctl.8 to reflect reality
- bring back 'smtpctl schedule' and 'smtpctl remove' to life

Things you should know:

The ramqueue data structure is not finished yet and lacks an envelope tree
for evpid lookups. I wanted to wait until I'm done but too many people are
affected by not being able to reschedule envelopes, this is a quick fix.

So right now there's an O(rrible) complexity as both commands will perform
a (possibly aborted) queue scan leading to O(n). I will make that O(log n)
soon.

Also, smtpctl remove no longer supports removing an entire message, I will
fix that very soon too.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.107 2011/05/16 21:05:52 gilles Exp $	*/
a44 2
void ramqueue_insert(struct ramqueue *, struct envelope *, time_t);

d426 1
d504 7
@


1.107
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.106 2011/05/01 12:57:11 eric Exp $	*/
d158 26
d246 1
@


1.106
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.105 2011/04/17 13:36:07 gilles Exp $	*/
d71 1
a71 1
	struct envelope	*m;
d75 2
a76 2
		m = imsg->data;
		runner_force_message_to_ramqueue(&env->sc_rqueue, m->evpid>>32);
d81 2
a82 2
		m = imsg->data;
		m->retry++;
d88 4
a91 4
		if (m->status & S_MESSAGE_TEMPFAILURE) {
			m->status &= ~S_MESSAGE_TEMPFAILURE;
			queue_envelope_update(Q_QUEUE, m);
			ramqueue_insert(&env->sc_rqueue, m, time(NULL));
d99 1
a99 1
		if (m->status & S_MESSAGE_PERMFAILURE) {
d102 3
a104 3
			if (m->type != T_BOUNCE_MESSAGE &&
			    m->sender.user[0] != '\0') {
				bounce_record_message(m, &bounce);
d113 1
a113 1
		queue_envelope_delete(Q_QUEUE, m);
d129 5
a133 5
		m = imsg->data;
		if (imsg->fd < 0 || !bounce_session(imsg->fd, m)) {
			m->status = 0;
			queue_envelope_update(Q_QUEUE, m);
			ramqueue_insert(&env->sc_rqueue, m, time(NULL));
d358 1
a358 1
	if (envelope.type & T_MDA_MESSAGE) {
d365 1
a365 1
	if (envelope.type & T_MTA_MESSAGE) {
d372 1
a372 1
	if (envelope.type & T_BOUNCE_MESSAGE) {
d382 1
a382 1
		message_set_errormsg(&envelope, "loop has been detected");
a389 4
	log_debug("dispatching host: %p, batch: %p, envelope: %p, %016llx",
	    rq_evp->host,
	    rq_evp->batch,
	    rq_evp, rq_evp->evpid);
d405 1
a405 1
	case T_BOUNCE_MESSAGE:		
d410 1
a410 1
			envelope.lasttry = curtm;
d426 1
a426 1
	case T_MDA_MESSAGE:
d431 1
a431 1
		envelope.lasttry = curtm;
d448 1
a448 1
	case T_MTA_MESSAGE:
d456 1
a456 1
			envelope.lasttry = curtm;
d615 1
a615 1
runner_check_loop(struct envelope *messagep)
d621 1
a621 1
	struct path chkpath;
d625 1
a625 1
	fd = queue_message_fd_r(Q_QUEUE, messagep->evpid>>32);
d654 1
a654 1
			struct path rcpt;
d656 2
a657 2
			bzero(&chkpath, sizeof (struct path));
			if (! recipient_to_path(&chkpath, buf + 14))
d660 3
a662 3
			rcpt = messagep->recipient;
			if (messagep->type == T_BOUNCE_MESSAGE)
				rcpt = messagep->sender;
d664 2
a665 2
			if (strcasecmp(chkpath.user, rcpt.user) == 0 &&
			    strcasecmp(chkpath.domain, rcpt.domain) == 0) {
@


1.105
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.104 2011/04/17 11:39:23 gilles Exp $	*/
d47 1
a47 1
static void runner_imsg(struct smtpd *, struct imsgev *, struct imsg *);
d50 3
a52 3
static void runner_setup_events(struct smtpd *);
static void runner_reset_events(struct smtpd *);
static void runner_disable_events(struct smtpd *);
d54 2
a55 2
static int runner_process_envelope(struct smtpd *, struct ramqueue_envelope *, time_t);
static void runner_process_batch(struct smtpd *, struct ramqueue_envelope *, time_t);
d58 1
a58 1
static int runner_check_loop(struct smtpd *, struct envelope *);
d69 1
a69 1
runner_imsg(struct smtpd *env, struct imsgev *iev, struct imsg *imsg)
d77 1
a77 1
		runner_reset_events(env);
d90 1
a90 1
			queue_envelope_update(env, Q_QUEUE, m);
d92 1
a92 1
			runner_reset_events(env);
d104 1
a104 1
				bounce_record_message(env, m, &bounce);
d106 1
a106 1
				runner_reset_events(env);
d113 1
a113 1
		queue_envelope_delete(env, Q_QUEUE, m);
d125 1
a125 1
		/*		runner_process_offline(env);*/
d130 1
a130 1
		if (imsg->fd < 0 || !bounce_session(env, imsg->fd, m)) {
d132 1
a132 1
			queue_envelope_update(env, Q_QUEUE, m);
d134 1
a134 1
			runner_reset_events(env);
d184 1
a184 1
runner_setup_events(struct smtpd *env)
d188 1
a188 1
	evtimer_set(&env->sc_ev, runner_timeout, env);
d195 1
a195 1
runner_reset_events(struct smtpd *env)
d205 1
a205 1
runner_disable_events(struct smtpd *env)
d211 1
a211 1
runner(struct smtpd *env)
d232 1
a232 1
	purge_config(env, PURGE_EVERYTHING);
d249 1
a249 1
	ramqueue_init(env, &env->sc_rqueue);
d254 2
a255 2
	signal_set(&ev_sigint, SIGINT, runner_sig_handler, env);
	signal_set(&ev_sigterm, SIGTERM, runner_sig_handler, env);
d266 2
a267 2
	config_pipes(env, peers, nitems(peers));
	config_peers(env, peers, nitems(peers));
d271 1
a271 1
	runner_setup_events(env);
d273 1
a273 1
	runner_disable_events(env);
a281 1
	struct smtpd		*env = p;
d319 1
a319 1
		runner_process_envelope(env, rq_evp, curtm);
d346 1
a346 1
runner_process_envelope(struct smtpd *env, struct ramqueue_envelope *rq_evp, time_t curtm)
d355 1
a355 1
	if (! queue_envelope_load(env, Q_QUEUE, rq_evp->evpid, &envelope))
d379 1
a379 1
	if (runner_check_loop(env, &envelope)) {
d383 1
a383 1
		bounce_record_message(env, &envelope, &bounce);
d385 2
a386 2
		runner_setup_events(env);
		queue_envelope_delete(env, Q_QUEUE, &envelope);
d394 1
a394 1
	runner_process_batch(env, rq_evp, curtm);
d401 1
a401 1
runner_process_batch(struct smtpd *env, struct ramqueue_envelope *rq_evp, time_t curtm)
d411 1
a411 1
			if (! queue_envelope_load(env, Q_QUEUE, rq_evp->evpid,
d433 1
a433 2
		if (! queue_envelope_load(env, Q_QUEUE, rq_evp->evpid,
			&envelope))
d436 1
a436 1
		fd = queue_message_fd_r(env, Q_QUEUE, rq_evp->evpid>>32);
d457 1
a457 1
			if (! queue_envelope_load(env, Q_QUEUE, rq_evp->evpid,
d528 1
a528 1
		if (! queue_envelope_load(rqueue->env, Q_QUEUE, evpid,
d619 1
a619 1
runner_check_loop(struct smtpd *env, struct envelope *messagep)
d629 1
a629 1
	fd = queue_message_fd_r(env, Q_QUEUE, messagep->evpid>>32);
@


1.104
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.103 2011/04/15 19:03:28 gilles Exp $	*/
a43 1
void		runner_imsg(struct smtpd *, struct imsgev *, struct imsg *);
d45 1
a45 5
__dead void	runner_shutdown(void);
void		runner_sig_handler(int, short, void *);
void		runner_setup_events(struct smtpd *);
void		runner_reset_events(struct smtpd *);
void		runner_disable_events(struct smtpd *);
d47 13
a59 1
void		runner_timeout(int, short, void *);
a60 11
int		runner_process_envelope(struct smtpd *, struct ramqueue_envelope *, time_t);
void		runner_process_batch(struct smtpd *, struct ramqueue_envelope *, time_t);

void		runner_purge_run(void);
void		runner_purge_message(u_int32_t);

int		runner_check_loop(struct smtpd *, struct envelope *);

int		runner_force_message_to_ramqueue(struct ramqueue *, u_int32_t);

void		ramqueue_insert(struct ramqueue *, struct envelope *, time_t);
d67 1
d273 1
@


1.103
log
@whenever an envelope is reinserted into the ramqueue after a trip to mda or
mta, call runner_reset_events() so runner starts reprocessing ramqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.102 2011/04/15 17:01:05 gilles Exp $	*/
d60 1
a60 1
int		runner_check_loop(struct smtpd *, struct message *);
d64 1
a64 1
void		ramqueue_insert(struct ramqueue *, struct message *, time_t);
d74 1
a74 1
	struct message	*m;
d103 1
a103 1
			struct message bounce;
d352 1
a352 1
	struct message	 envelope;
d383 1
a383 1
		struct message bounce;
d408 1
a408 1
	struct message envelope;
d509 1
a509 1
	struct message envelope;
d623 1
a623 1
runner_check_loop(struct smtpd *env, struct message *messagep)
@


1.102
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.101 2011/04/15 11:39:57 gilles Exp $	*/
d49 1
d80 1
a80 1
		runner_setup_events(env);
d95 1
a95 1
			runner_setup_events(env);
d109 1
a109 1
				runner_setup_events(env);
d137 1
a137 1
			runner_setup_events(env);
d192 10
@


1.101
log
@temporarily add fsqueue_hash() prototype until runner is fully converted to
queue_backend API
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.100 2011/04/14 23:29:56 gilles Exp $	*/
d57 1
a57 1
void		runner_purge_message(char *);
d61 1
a61 1
int		runner_force_message_to_ramqueue(struct ramqueue *, char *);
d64 5
a68 1
/*temporary*/ u_int16_t	 fsqueue_hash(char *);
d78 1
a78 1
		runner_force_message_to_ramqueue(&env->sc_rqueue, m->message_id);
d347 1
a347 1
	if (! queue_envelope_load(env, Q_QUEUE, rq_evp->id, &envelope))
d382 1
a382 1
	log_debug("dispatching host: %p, batch: %p, envelope: %p, %s",
d385 1
a385 1
	    rq_evp, rq_evp->id);
d403 1
a403 1
			if (! queue_envelope_load(env, Q_QUEUE, rq_evp->id,
d425 1
a425 1
		if (! queue_envelope_load(env, Q_QUEUE, rq_evp->id,
d429 1
a429 1
		fd = queue_message_fd_r(env, Q_QUEUE, rq_evp->batch->m_id);
d450 1
a450 1
			if (! queue_envelope_load(env, Q_QUEUE, rq_evp->id,
d493 1
a493 1
runner_force_message_to_ramqueue(struct ramqueue *rqueue, char *mid)
d501 2
a502 2
	if (! bsnprintf(path, MAXPATHLEN, "%s/%d/%s/envelopes",
		PATH_QUEUE, fsqueue_hash(mid), mid))
d511 8
a518 5
		if (valid_message_uid(dp->d_name)) {
			if (! queue_envelope_load(rqueue->env, Q_QUEUE, dp->d_name,
				&envelope))
				continue;
			ramqueue_insert(rqueue, &envelope, curtm);
d520 5
d539 14
a552 2
	while (qwalk(q, path))
		runner_purge_message(basename(path));
d558 1
a558 1
runner_purge_message(char *msgid)
d567 1
a567 1
	if (! bsnprintf(rootdir, sizeof(rootdir), "%s/%s", PATH_PURGE, msgid))
d622 1
a622 1
	fd = queue_message_fd_r(env, Q_QUEUE, messagep->message_id);
@


1.100
log
@bye bye queue_hash() you can now rest in peace.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.99 2011/04/14 22:36:09 gilles Exp $	*/
d64 1
@


1.99
log
@- implement fsqueue_message_create() and fsqueue_message_commit()
- change a few prototypes to allow bounce messages to use the
	queue_backend API until it gets merged in
- kill functions of the queue API that have been deprecated
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.98 2011/04/14 21:53:46 gilles Exp $	*/
d497 1
a497 1
		PATH_QUEUE, queue_hash(mid), mid))
a498 1

@


1.98
log
@fsqueue now provides fsqueue_message_fd_r() and fsqueue_message_fd_rw() to
obtain a read{-only,/write} descriptor to the message file.

make sure smtpd uses the new API everywhere it needs a fd, and kill the
many functions that were used until now.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.97 2011/04/14 20:11:08 gilles Exp $	*/
d101 1
a101 1
				bounce_record_message(m, &bounce);
d370 1
a370 1
		bounce_record_message(&envelope, &bounce);
@


1.97
log
@fsqueue queue backend will implement a filesystem queue:
- fsqueue->setup() performs the queue initialization;
- fsqueue->message() controls messages;
- fsqueue->envelope() controls envelopes;

This commit brings the following to fsbackend:
fsqueue_setup(), fsqueue_message_delete(), fsqueue_envelope_load(),
fsqueue_envelope_update(), fsqueue_envelope_delete().

It also makes smtpd use the queue_backend API for these operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.96 2011/04/13 20:53:18 gilles Exp $	*/
d59 1
a59 1
int		runner_check_loop(struct message *);
d366 1
a366 1
	if (runner_check_loop(&envelope)) {
d424 1
a424 1
		fd = queue_open_message_file(envelope.message_id);
d588 1
a588 1
runner_check_loop(struct message *messagep)
d598 1
a598 1
	fd = queue_open_message_file(messagep->message_id);
@


1.96
log
@following an idea from jacekm@@, smtpd now uses a ram-queue instead of doing
a continuous walk on the disk-queue. the implementation differs from what
jacekm@@ commited (and I backed out) a while ago in that it uses a queue and
a host tree required for upcoming features.

code will be improved in tree, it requires changes to be done in queue and
bounce API, I just wanted to commit a working version first ...

tested by todd@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.95 2010/11/28 14:35:58 gilles Exp $	*/
d87 1
a87 1
			queue_update_envelope(m);
d110 1
a110 1
		queue_remove_envelope(m);
d129 1
a129 1
			queue_update_envelope(m);
d342 1
a342 1
	if (! queue_load_envelope(&envelope, rq_evp->id))
d373 1
a373 1
		queue_remove_envelope(&envelope);
d398 2
a399 1
			if (! queue_load_envelope(&envelope, rq_evp->id))
d420 2
a421 1
		if (! queue_load_envelope(&envelope, rq_evp->id))
d445 2
a446 1
			if (! queue_load_envelope(&envelope, rq_evp->id))
d508 2
a509 1
			if (! queue_load_envelope(&envelope, dp->d_name))
@


1.95
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.94 2010/11/28 13:56:43 gilles Exp $	*/
a50 3
void		runner_reset_flags(void);
void		runner_process_offline(struct smtpd *);

d53 2
a54 5
void		runner_process_queue(struct smtpd *);
void		runner_process_runqueue(struct smtpd *);
void		runner_process_batchqueue(struct smtpd *);

int		runner_message_schedule(struct message *, time_t);
d61 1
a61 2
struct batch	*batch_record(struct smtpd *, struct message *);
struct batch	*batch_lookup(struct smtpd *, struct message *);
d63 1
a63 5
int		runner_force_envelope_schedule(char *);
int		runner_force_message_schedule(char *);

int		runner_force_envelope_remove(char *);
int		runner_force_message_remove(char *);
a68 2
	struct remove	*rem;
	struct sched	*sched;
d71 6
d78 2
d81 30
a110 1
		queue_message_update(imsg->data);
a120 22
	case IMSG_QUEUE_SCHEDULE:
		sched = imsg->data;
		sched->ret = 0;
		if (valid_message_uid(sched->mid))
			sched->ret = runner_force_envelope_schedule(sched->mid);
		else if (valid_message_id(sched->mid))
			sched->ret = runner_force_message_schedule(sched->mid);
		imsg_compose_event(iev, IMSG_QUEUE_SCHEDULE, imsg->hdr.peerid,
		    0, -1, sched, sizeof *sched);
		return;

	case IMSG_QUEUE_REMOVE:
		rem = imsg->data;
		rem->ret = 0;
		if (valid_message_uid(rem->mid))
			rem->ret = runner_force_envelope_remove(rem->mid);
		else if (valid_message_id(rem->mid))
			rem->ret = runner_force_message_remove(rem->mid);
		imsg_compose_event(iev, IMSG_QUEUE_REMOVE, imsg->hdr.peerid, 0,
		    -1, rem, sizeof *rem);
		return;

d122 1
a122 1
		runner_process_offline(env);
d128 5
a132 2
			m->status = S_MESSAGE_TEMPFAILURE;
			queue_message_update(m);
d236 1
a236 1
	SPLAY_INIT(&env->batch_queue);
a256 2
	runner_reset_flags();
	runner_process_offline(env);
d266 1
a266 1
runner_process_offline(struct smtpd *env)
d268 15
a282 2
	char		 path[MAXPATHLEN];
	struct qwalk	*q;
a283 1
	q = qwalk_new(PATH_OFFLINE);
d285 6
a290 4
	if (qwalk(q, path))
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_PARENT_ENQUEUE_OFFLINE, PROC_PARENT, 0, -1, path,
		    strlen(path) + 1);
a291 2
	qwalk_close(q);
}
d293 5
a297 6
void
runner_reset_flags(void)
{
	char		 path[MAXPATHLEN];
	struct message	 message;
	struct qwalk	*q;
a298 1
	q = qwalk_new(PATH_QUEUE);
d300 8
a307 4
	while (qwalk(q, path)) {
		while (! queue_load_envelope(&message, basename(path)))
			sleep(1);
		message_reset_flags(&message);
d310 4
a313 2
	qwalk_close(q);
}
d315 8
a322 7
void
runner_timeout(int fd, short event, void *p)
{
	struct smtpd		*env = p;
	struct timeval		 tv;

	runner_purge_run();
d324 2
a325 3
	runner_process_queue(env);
	runner_process_runqueue(env);
	runner_process_batchqueue(env);
d327 1
a327 1
	tv.tv_sec = 1;
d332 2
a333 2
void
runner_process_queue(struct smtpd *env)
a334 4
	char		 path[MAXPATHLEN];
	char		 rqpath[MAXPATHLEN];
	struct message	 message;
	time_t		 now;
d336 1
a336 1
	struct qwalk	*q;
d341 3
d345 6
a350 2
	now = time(NULL);
	q = qwalk_new(PATH_QUEUE);
d352 6
a357 3
	while (qwalk(q, path)) {
		if (! queue_load_envelope(&message, basename(path)))
			continue;
d359 6
a364 6
		if (message.type & T_MDA_MESSAGE) {
			if (env->sc_opts & SMTPD_MDA_PAUSED)
				continue;
			if (mda_av == 0)
				continue;
		}
d366 2
a367 6
		if (message.type & T_MTA_MESSAGE) {
			if (env->sc_opts & SMTPD_MTA_PAUSED)
				continue;
			if (mta_av == 0)
				continue;
		}
d369 7
a375 6
		if (message.type & T_BOUNCE_MESSAGE) {
			if (env->sc_opts & (SMTPD_MDA_PAUSED|SMTPD_MTA_PAUSED))
				continue;
			if (bnc_av == 0)
				continue;
		}
d377 5
a381 2
		if (! runner_message_schedule(&message, now))
			continue;
d383 1
a383 32
		if (runner_check_loop(&message)) {
			message_set_errormsg(&message, "loop has been detected");
			bounce_record_message(&message);
			queue_remove_envelope(&message);
			continue;
		}

		message.flags |= F_MESSAGE_SCHEDULED;
		message.flags &= ~F_MESSAGE_FORCESCHEDULE;
		queue_update_envelope(&message);

		if (! bsnprintf(rqpath, sizeof(rqpath), "%s/%s", PATH_RUNQUEUE,
			basename(path)))
			fatalx("runner_process_queue: snprintf");

		if (symlink(path, rqpath) == -1) {
			if (errno == EEXIST)
				continue;
			if (errno == ENOSPC)
				break;
			fatal("runner_process_queue: symlink");
		}

		if (message.type & T_MDA_MESSAGE)
			mda_av--;
		if (message.type & T_MTA_MESSAGE)
			mta_av--;
		if (message.type & T_BOUNCE_MESSAGE)
			bnc_av--;
	}
	
	qwalk_close(q);
a385 47
void
runner_process_runqueue(struct smtpd *env)
{
	char		 path[MAXPATHLEN];
	struct message	 message;
	time_t		 tm;
	struct batch	*batchp;
	struct message	*messagep;
	struct qwalk	*q;

	tm = time(NULL);

	q = qwalk_new(PATH_RUNQUEUE);

	while (qwalk(q, path)) {
		unlink(path);

		if (! queue_load_envelope(&message, basename(path)))
			continue;

		if (message.flags & F_MESSAGE_PROCESSING)
			continue;

		message.lasttry = tm;
		message.flags &= ~F_MESSAGE_SCHEDULED;
		message.flags |= F_MESSAGE_PROCESSING;

		if (! queue_update_envelope(&message))
			continue;

		messagep = calloc(1, sizeof (struct message));
		if (messagep == NULL)
			fatal("runner_process_runqueue: calloc");
		*messagep = message;

		messagep->batch_id = 0;
		batchp = batch_lookup(env, messagep);
		if (batchp != NULL)
			messagep->batch_id = batchp->id;

		batchp = batch_record(env, messagep);
		if (messagep->batch_id == 0)
			messagep->batch_id = batchp->id;
	}

	qwalk_close(q);
}
d388 1
a388 1
runner_process_batchqueue(struct smtpd *env)
d390 4
a393 3
	struct batch	*batchp;
	struct message	*m;
	int		 fd;
d395 6
a400 19
	while ((batchp = SPLAY_MIN(batchtree, &env->batch_queue)) != NULL) {
		switch (batchp->type) {
		case T_BOUNCE_BATCH:
			while ((m = TAILQ_FIRST(&batchp->messages))) {
				imsg_compose_event(env->sc_ievs[PROC_QUEUE],
				    IMSG_SMTP_ENQUEUE, PROC_SMTP, 0, -1, m,
				    sizeof *m);
				TAILQ_REMOVE(&batchp->messages, m, entry);
				free(m);
			}
			env->stats->runner.bounces_active++;
			env->stats->runner.bounces++;
			SET_IF_GREATER(env->stats->runner.bounces_active,
				env->stats->runner.bounces_maxactive);
			break;

		case T_MDA_BATCH:
			m = TAILQ_FIRST(&batchp->messages);
			fd = queue_open_message_file(m->message_id);
d402 15
a416 9
			    IMSG_MDA_SESS_NEW, PROC_MDA, 0, fd, m,
			    sizeof *m);
			TAILQ_REMOVE(&batchp->messages, m, entry);
			free(m);
			env->stats->mda.sessions_active++;
			env->stats->mda.sessions++;
			SET_IF_GREATER(env->stats->mda.sessions_active,
				env->stats->mda.sessions_maxactive);
			break;
d418 29
a446 11
		case T_MTA_BATCH:
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_BATCH_CREATE, PROC_MTA, 0, -1, batchp,
			    sizeof *batchp);
			while ((m = TAILQ_FIRST(&batchp->messages))) {
				imsg_compose_event(env->sc_ievs[PROC_QUEUE],
				    IMSG_BATCH_APPEND, PROC_MTA, 0, -1, m,
				    sizeof *m);
				TAILQ_REMOVE(&batchp->messages, m, entry);
				free(m);
			}
d448 7
a454 10
			    IMSG_BATCH_CLOSE, PROC_MTA, 0, -1, batchp,
			    sizeof *batchp);
			env->stats->mta.sessions_active++;
			env->stats->mta.sessions++;
			SET_IF_GREATER(env->stats->mta.sessions_active,
				env->stats->mta.sessions_maxactive);
			break;

		default:
			fatalx("runner_process_batchqueue: unknown type");
d456 11
a466 3

		SPLAY_REMOVE(batchtree, &env->batch_queue, batchp);
		free(batchp);
a467 6
}

int
runner_message_schedule(struct message *messagep, time_t tm)
{
	time_t delay;
d469 5
a473 14
	if (messagep->flags & (F_MESSAGE_SCHEDULED|F_MESSAGE_PROCESSING))
		return 0;

	if (messagep->flags & F_MESSAGE_FORCESCHEDULE)
		return 1;

	/* Batch has been in the queue for too long and expired */
	if (tm - messagep->creation >= messagep->expire) {
		message_set_errormsg(messagep,
		    "message expired after sitting in queue for %d days",
		    messagep->expire / 60 / 60 / 24);
		bounce_record_message(messagep);
		queue_remove_envelope(messagep);
		return 0;
d476 4
a479 24
	if (messagep->lasttry == 0)
		return 1;

	delay = SMTPD_QUEUE_MAXINTERVAL;

	// recompute path

	if (messagep->type == T_MDA_MESSAGE ||
	    messagep->type == T_BOUNCE_MESSAGE) {
		if (messagep->retry < 5)
			return 1;
			
		if (messagep->retry < 15)
			delay = (messagep->retry * 60) + arc4random_uniform(60);
	}

	if (messagep->type == T_MTA_MESSAGE) {
		if (messagep->retry < 3)
			delay = SMTPD_QUEUE_INTERVAL;
		else if (messagep->retry <= 7) {
			delay = SMTPD_QUEUE_INTERVAL * (1 << (messagep->retry - 3));
			if (delay > SMTPD_QUEUE_MAXINTERVAL)
				delay = SMTPD_QUEUE_MAXINTERVAL;
		}
a480 24

	if (tm >= messagep->lasttry + delay)
		return 1;

	return 0;
}

int
runner_force_envelope_schedule(char *mid)
{
	struct message message;

	if (! queue_load_envelope(&message, mid))
		return 0;

	if (message.flags & (F_MESSAGE_PROCESSING|F_MESSAGE_SCHEDULED))
		return 1;

	message.flags |= F_MESSAGE_FORCESCHEDULE;

	if (! queue_update_envelope(&message))
		return 0;

	return 1;
d483 1
d485 1
a485 1
runner_force_message_schedule(char *mid)
d490 2
a496 41
	dirp = opendir(path);
	if (dirp == NULL)
		return 0;

	while ((dp = readdir(dirp)) != NULL) {
		if (valid_message_uid(dp->d_name))
			runner_force_envelope_schedule(dp->d_name);
	}
	closedir(dirp);

	return 1;
}


int
runner_force_envelope_remove(char *mid)
{
	struct message message;

	if (! queue_load_envelope(&message, mid))
		return 0;

	if (message.flags & (F_MESSAGE_PROCESSING|F_MESSAGE_SCHEDULED))
		return 0;

	if (! queue_remove_envelope(&message))
		return 0;

	return 1;
}

int
runner_force_message_remove(char *mid)
{
	char path[MAXPATHLEN];
	DIR *dirp;
	struct dirent *dp;

	if (! bsnprintf(path, MAXPATHLEN, "%s/%d/%s/envelopes",
		PATH_QUEUE, queue_hash(mid), mid))
		return 0;
d502 1
d504 5
a508 2
		if (valid_message_uid(dp->d_name))
			runner_force_envelope_remove(dp->d_name);
a582 108
struct batch *
batch_record(struct smtpd *env, struct message *messagep)
{
	struct batch *batchp;
	struct path *path;

	batchp = NULL;
	if (messagep->batch_id != 0) {
		batchp = batch_by_id(env, messagep->batch_id);
		if (batchp == NULL)
			fatalx("batch_record: internal inconsistency.");
	}
	if (batchp == NULL) {
		batchp = calloc(1, sizeof(struct batch));
		if (batchp == NULL)
			fatal("batch_record: calloc");

		batchp->id = generate_uid();

		(void)strlcpy(batchp->message_id, messagep->message_id,
		    sizeof(batchp->message_id));
		TAILQ_INIT(&batchp->messages);
		SPLAY_INSERT(batchtree, &env->batch_queue, batchp);

		if (messagep->type & T_BOUNCE_MESSAGE) {
			batchp->type = T_BOUNCE_BATCH;
			path = &messagep->sender;
		}
		else {
			path = &messagep->recipient;
		}
		batchp->rule = path->rule;

		(void)strlcpy(batchp->hostname, path->domain,
		    sizeof(batchp->hostname));

		if (batchp->type != T_BOUNCE_BATCH) {
			if (IS_MAILBOX(*path) || IS_EXT(*path)) {
				batchp->type = T_MDA_BATCH;
			}
			else {
				batchp->type = T_MTA_BATCH;
			}
		}
	}

	TAILQ_INSERT_TAIL(&batchp->messages, messagep, entry);
	env->stats->runner.active++;
	SET_IF_GREATER(env->stats->runner.active,
		env->stats->runner.maxactive);
	return batchp;
}

struct batch *
batch_lookup(struct smtpd *env, struct message *message)
{
	struct batch *batchp;
	struct batch lookup;

	/* We only support delivery of one message at a time, in MDA
	 * and bounces messages.
	 */
	if (message->type == T_BOUNCE_MESSAGE || message->type == T_MDA_MESSAGE)
		return NULL;

	/* If message->batch_id != 0, we can retrieve batch by id */
	if (message->batch_id != 0) {
		lookup.id = message->batch_id;
		return SPLAY_FIND(batchtree, &env->batch_queue, &lookup);
	}

	/* We do not know the batch_id yet, maybe it was created but we could not
	 * be notified, or it just does not exist. Let's scan to see if we can do
	 * a match based on our message_id and flags.
	 */
	SPLAY_FOREACH(batchp, batchtree, &env->batch_queue) {

		if (batchp->type != message->type)
			continue;

		if (strcasecmp(batchp->message_id, message->message_id) != 0)
			continue;

		if (batchp->type & T_MTA_BATCH)
			if (strcasecmp(batchp->hostname, message->recipient.domain) != 0)
				continue;

		break;
	}

	return batchp;
}

int
batch_cmp(struct batch *s1, struct batch *s2)
{
	/*
	 * do not return u_int64_t's
	 */
	if (s1->id < s2->id)
		return (-1);

	if (s1->id > s2->id)
		return (1);

	return (0);
}

a644 12

void
message_reset_flags(struct message *m)
{
	m->flags &= ~F_MESSAGE_SCHEDULED;
	m->flags &= ~F_MESSAGE_PROCESSING;

	while (! queue_update_envelope(m))
		sleep(1);
}

SPLAY_GENERATE(batchtree, batch, b_nodes, batch_cmp);
@


1.94
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.93 2010/11/24 23:27:04 todd Exp $	*/
a27 3
#include <netinet/in.h>
#include <arpa/inet.h>

a32 1
#include <fcntl.h>
a34 1
#include <netdb.h>
a35 1
#include <signal.h>
a38 1
#include <time.h>
@


1.93
log
@add *maxactive stats
"ok and no need to keep them for yourself" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.92 2010/10/28 21:15:50 gilles Exp $	*/
d37 1
d49 1
@


1.92
log
@teach smtpd how to handle per-rule delays for message expiry, this allows
some rules to have a longer expiry delay than the default:

	accept for [...] relay expire 8d  # will stay 8 days in queue

I added the man page bits so I don't forget but I need to reword it a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.91 2010/10/09 22:12:26 gilles Exp $	*/
d464 2
d478 2
d498 2
d765 2
@


1.91
log
@these need to be re-added too
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.87 2010/05/19 20:57:10 gilles Exp $	*/
d517 4
a520 3
	if (tm - messagep->creation >= SMTPD_QUEUE_EXPIRY) {
		message_set_errormsg(messagep, "message expired after sitting in queue for %d days",
			SMTPD_QUEUE_EXPIRY / 60 / 60 / 24);
@


1.90
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.89 2010/06/01 19:47:09 jacekm Exp $	*/
@


1.89
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.87 2010/05/19 20:57:10 gilles Exp $	*/
@


1.88
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@@


1.87
log
@cleanup-only commit, removes unrequired includes, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.86 2010/04/22 12:56:33 jacekm Exp $	*/
@


1.86
log
@Fix a case of runner trying to send imsg directly to smtp process instead
of forwarding it via queue.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.85 2010/04/22 12:13:33 jacekm Exp $	*/
a26 1
#include <sys/time.h>
@


1.85
log
@- kill the runner_imsg_compose wrapper to reduce indirection
- kill noisy log_debug
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.84 2010/04/21 18:54:43 jacekm Exp $	*/
d457 3
a459 1
				bounce_process(env, m);
@


1.84
log
@Runner process is just a helper for queue, so tear down its imsg
channels to parent, mda, mta, lka, smtp, and control.  This leaves
just the channel to queue, which forwards imsgs on runner's behalf
and redirects any replies back to it.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.83 2010/04/21 08:29:01 jacekm Exp $	*/
a81 3
void		runner_imsg_compose(struct smtpd *, int, u_int16_t,
		    u_int32_t, pid_t, int, void *, u_int16_t);

a87 4
	int		 proc;

	/* queue stores imsg sender process number in the ``peerid'' field. */
	proc = imsg->hdr.peerid;
d110 2
a111 2
		runner_imsg_compose(env, proc, IMSG_QUEUE_SCHEDULE, 0, 0, -1,
		    sched, sizeof *sched);
d121 2
a122 2
		runner_imsg_compose(env, proc, IMSG_QUEUE_REMOVE, 0, 0, -1, rem,
		    sizeof *rem);
d277 2
a278 2
		runner_imsg_compose(env, PROC_PARENT,
		    IMSG_PARENT_ENQUEUE_OFFLINE, 0, 0, -1, path,
d468 3
a470 2
			runner_imsg_compose(env, PROC_MDA, IMSG_MDA_SESS_NEW,
			    0, 0, fd, m, sizeof *m);
d478 3
a480 2
			runner_imsg_compose(env, PROC_MTA, IMSG_BATCH_CREATE,
			    0, 0, -1, batchp, sizeof *batchp);
d482 3
a484 2
				runner_imsg_compose(env, PROC_MTA,
				    IMSG_BATCH_APPEND, 0, 0, -1, m, sizeof *m);
d488 3
a490 2
			runner_imsg_compose(env, PROC_MTA, IMSG_BATCH_CLOSE,
			    0, 0, -1, batchp, sizeof *batchp);
a885 10
}

void
runner_imsg_compose(struct smtpd *env, int proc, u_int16_t type,
    u_int32_t peerid, pid_t pid, int fd, void *data, u_int16_t datalen)
{
	/* forward via the queue process */
	log_debug("runner: sending %d imsg type %d", proc, type);
	imsg_compose_event(env->sc_ievs[PROC_QUEUE], type, proc, pid, fd,
	    data, datalen);
@


1.83
log
@Remove unusable ifdef DEBUG code.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.82 2010/04/21 00:12:49 jacekm Exp $	*/
d82 3
d91 1
d93 2
a94 16
	if (iev->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_RUNNER_UPDATE_ENVELOPE:
			env->stats->runner.active--;
			queue_message_update(imsg->data);
			return;
		}
	}

	if (iev->proc == PROC_MDA) {
		switch (imsg->hdr.type) {
		case IMSG_MDA_SESS_NEW:
			env->stats->mda.sessions_active--;
			return;
		}
	}
d96 67
a162 72
	if (iev->proc == PROC_MTA) {
		switch (imsg->hdr.type) {
		case IMSG_BATCH_DONE:
			env->stats->mta.sessions_active--;
			return;
		}
	}

	if (iev->proc == PROC_SMTP) {
		switch (imsg->hdr.type) {
		case IMSG_SMTP_ENQUEUE:
			m = imsg->data;
			if (imsg->fd < 0 || !bounce_session(env, imsg->fd, m)) {
				m->status = S_MESSAGE_TEMPFAILURE;
				queue_message_update(m);
			}
			return;
		}
	}

	if (iev->proc == PROC_CONTROL) {
		switch (imsg->hdr.type) {
		case IMSG_MDA_PAUSE:
			env->sc_opts |= SMTPD_MDA_PAUSED;
			return;

		case IMSG_MTA_PAUSE:
			env->sc_opts |= SMTPD_MTA_PAUSED;
			return;

		case IMSG_MDA_RESUME:
			env->sc_opts &= ~SMTPD_MDA_PAUSED;
			return;

		case IMSG_MTA_RESUME:
			env->sc_opts &= ~SMTPD_MTA_PAUSED;
			return;

		case IMSG_RUNNER_SCHEDULE:
			sched = imsg->data;
			sched->ret = 0;
			if (valid_message_uid(sched->mid))
				sched->ret = runner_force_envelope_schedule(sched->mid);
			else if (valid_message_id(sched->mid))
				sched->ret = runner_force_message_schedule(sched->mid);
			imsg_compose_event(iev, IMSG_RUNNER_SCHEDULE, 0, 0, -1,
			    sched, sizeof *sched);
			return;

		case IMSG_RUNNER_REMOVE:
			rem = imsg->data;
			rem->ret = 0;
			if (valid_message_uid(rem->mid))
				rem->ret = runner_force_envelope_remove(rem->mid);
			else if (valid_message_id(rem->mid))
				rem->ret = runner_force_message_remove(rem->mid);
			imsg_compose_event(iev, IMSG_RUNNER_REMOVE, 0, 0, -1,
			    rem, sizeof *rem);
			return;
		}
	}

	if (iev->proc == PROC_PARENT) {
		switch (imsg->hdr.type) {
		case IMSG_PARENT_ENQUEUE_OFFLINE:
			runner_process_offline(env);
			return;

		case IMSG_CTL_VERBOSE:
			log_verbose(*(int *)imsg->data);
			return;
		}
d215 1
a215 7
		{ PROC_PARENT,	imsg_dispatch },
		{ PROC_CONTROL,	imsg_dispatch },
		{ PROC_MDA,	imsg_dispatch },
		{ PROC_MTA,	imsg_dispatch },
		{ PROC_QUEUE,	imsg_dispatch },
		{ PROC_LKA,	imsg_dispatch },
		{ PROC_SMTP,	imsg_dispatch }
d284 1
a284 1
		imsg_compose_event(env->sc_ievs[PROC_PARENT],
d475 2
a476 2
			imsg_compose_event(env->sc_ievs[PROC_MDA],
			    IMSG_MDA_SESS_NEW, 0, 0, fd, m, sizeof *m);
d484 2
a485 3
			imsg_compose_event(env->sc_ievs[PROC_MTA],
			    IMSG_BATCH_CREATE, 0, 0, -1, batchp,
			    sizeof *batchp);
d487 1
a487 1
				imsg_compose_event(env->sc_ievs[PROC_MTA],
d492 2
a493 2
			imsg_compose_event(env->sc_ievs[PROC_MTA],
			    IMSG_BATCH_CLOSE, 0, 0, -1, batchp, sizeof *batchp);
d889 10
@


1.82
log
@Fix logic error just like the one in previous revision.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.81 2010/04/20 20:55:04 jacekm Exp $	*/
a251 1
#ifndef DEBUG
a255 3
#else
#warning disabling privilege revocation and chroot in DEBUG MODE
#endif
a259 1
#ifndef DEBUG
a263 1
#endif
@


1.81
log
@Fix crash that could happen when attempting ``smtpctl remove'' while
the message is being delivered.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.80 2010/04/20 15:34:56 jacekm Exp $	*/
d595 1
a595 1
	if (! message.flags & (F_MESSAGE_PROCESSING|F_MESSAGE_SCHEDULED))
@


1.80
log
@Kill *2400* lines of code by abstracting common bits of the imsg handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.79 2010/04/19 08:14:07 jacekm Exp $	*/
d639 1
a639 1
	if (! message.flags & (F_MESSAGE_PROCESSING|F_MESSAGE_SCHEDULED))
@


1.79
log
@Simplify local delivery codepath:
- replace uses of struct batch in the parent with simpler struct delivery.
- replace IMSG_BATCH_* dance with single IMSG_MDA_SESS_NEW.
- make mda assume it delivers to external program over a pipe.
- fork helper process when delivering to maildir or a file.

New feature: upon external mda failure use last line of its output
as an error message.

With input and tests from nicm@@.

OK nicm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.78 2010/01/10 16:42:35 gilles Exp $	*/
d50 2
a53 7
void		runner_dispatch_parent(int, short, void *);
void	        runner_dispatch_control(int, short, void *);
void	        runner_dispatch_queue(int, short, void *);
void	        runner_dispatch_mda(int, short, void *);
void		runner_dispatch_mta(int, short, void *);
void		runner_dispatch_lka(int, short, void *);
void		runner_dispatch_smtp(int, short, void *);
d83 1
a83 1
runner_sig_handler(int sig, short event, void *p)
d85 11
a95 7
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		runner_shutdown();
		break;
	default:
		fatalx("runner_sig_handler: unexpected signal");
a96 1
}
d98 4
a101 19
void
runner_dispatch_parent(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_PARENT];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d106 5
a110 28
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("runner_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_PARENT_ENQUEUE_OFFLINE:
			runner_process_offline(env);
			break;
		case IMSG_CTL_VERBOSE: {
			int verbose;

			IMSG_SIZE_CHECK(&verbose);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		}
		default:
			log_warnx("runner_dispatch_parent: got imsg %d",
			    imsg.hdr.type);
			fatalx("runner_dispatch_parent: unexpected imsg");
a111 1
		imsg_free(&imsg);
a112 2
	imsg_event_add(iev);
}
d114 8
a121 19
void
runner_dispatch_control(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_CONTROL];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d126 2
a127 12
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("runner_dispatch_control: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
d130 2
a131 1
			break;
d134 2
a135 1
			break;
d138 2
a139 1
			break;
d142 1
a142 25
			break;
		case IMSG_RUNNER_SCHEDULE: {
			struct sched *s = imsg.data;

			IMSG_SIZE_CHECK(s);

			s->ret = 0;
			if (valid_message_uid(s->mid))
				s->ret = runner_force_envelope_schedule(s->mid);
			else if (valid_message_id(s->mid))
				s->ret = runner_force_message_schedule(s->mid);

			imsg_compose_event(iev, IMSG_RUNNER_SCHEDULE, 0, 0, -1, s, sizeof(*s));
			break;
		}
		case IMSG_RUNNER_REMOVE: {
			struct remove *s = imsg.data;

			IMSG_SIZE_CHECK(s);

			s->ret = 0;
			if (valid_message_uid(s->mid))
				s->ret = runner_force_envelope_remove(s->mid);
			else if (valid_message_id(s->mid))
				s->ret = runner_force_message_remove(s->mid);
d144 9
a152 32
			imsg_compose_event(iev, IMSG_RUNNER_REMOVE, 0, 0, -1, s, sizeof(*s));
			break;
		}
		default:
			log_warnx("runner_dispatch_control: got imsg %d",
			    imsg.hdr.type);
			fatalx("runner_dispatch_control: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
runner_dispatch_queue(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_QUEUE];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
a153 17
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("runner_dispatch_queue: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_RUNNER_UPDATE_ENVELOPE: {
			struct message	*m = imsg.data;
d155 9
a163 35
			IMSG_SIZE_CHECK(m);

			env->stats->runner.active--;
			queue_message_update(m);
			break;
		}
		default:
			log_warnx("runner_dispatch_queue: got imsg %d",
			    imsg.hdr.type);
			fatalx("runner_dispatch_queue: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
runner_dispatch_mda(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_MDA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d168 4
a171 45
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("runner_dispatch_mda: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_MDA_SESS_NEW:
			env->stats->mda.sessions_active--;
			break;

		default:
			log_warnx("runner_dispatch_mda: got imsg %d",
			    imsg.hdr.type);
			fatalx("runner_dispatch_mda: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
runner_dispatch_mta(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_MTA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
a172 28
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("runner_dispatch_mta: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_BATCH_DONE:
			env->stats->mta.sessions_active--;
			break;

		default:
			log_warnx("runner_dispatch_mta: got imsg %d",
			    imsg.hdr.type);
			fatalx("runner_dispatch_mta: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}
d174 2
a175 19
void
runner_dispatch_lka(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_LKA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
d180 1
a180 20
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("runner_dispatch_lka: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("runner_dispatch_lka: got imsg %d",
			    imsg.hdr.type);
			fatalx("runner_dispatch_lka: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d184 1
a184 1
runner_dispatch_smtp(int sig, short event, void *p)
d186 7
a192 50
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_SMTP];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("runner_dispatch_smtp: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_SMTP_ENQUEUE: {
			struct message	*m = imsg.data;

			IMSG_SIZE_CHECK(m);

			if (imsg.fd < 0 || ! bounce_session(env, imsg.fd, m)) {
				m->status = S_MESSAGE_TEMPFAILURE;
				queue_message_update(m);
			}
			break;
		}

		default:
			log_warnx("runner_dispatch_smtp: got imsg %d",
			    imsg.hdr.type);
			fatalx("runner_dispatch_smtp: unexpected imsg");
		}
		imsg_free(&imsg);
a193 1
	imsg_event_add(iev);
d230 7
a236 7
		{ PROC_PARENT,	runner_dispatch_parent },
		{ PROC_CONTROL,	runner_dispatch_control },
		{ PROC_MDA,	runner_dispatch_mda },
		{ PROC_MTA,	runner_dispatch_mta },
		{ PROC_QUEUE,	runner_dispatch_queue },
		{ PROC_LKA,	runner_dispatch_lka },
		{ PROC_SMTP,	runner_dispatch_smtp }
d273 1
@


1.78
log
@- teach runner how to remove a message from queue given a message id/uid
	and assuming message is not in processing/scheduled state
- teach smtpctl how to request message removal from runner

discussed with todd@@, idea ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.77 2010/01/03 14:37:37 chl Exp $	*/
a70 2
void		runner_batch_dispatch(struct smtpd *, struct batch *, time_t);

d331 1
a331 1
		case IMSG_BATCH_DONE:
d782 3
a784 2
	time_t curtime;
	struct batch *batchp, *nxt;
d786 11
a796 5
	curtime = time(NULL);
	for (batchp = SPLAY_MIN(batchtree, &env->batch_queue);
	     batchp != NULL;
	     batchp = nxt) {
		nxt = SPLAY_NEXT(batchtree, &env->batch_queue, batchp);
d798 30
a827 1
		runner_batch_dispatch(env, batchp, curtime);
a829 1
		bzero(batchp, sizeof(struct batch));
a833 47
void
runner_batch_dispatch(struct smtpd *env, struct batch *batchp, time_t curtime)
{
	u_int8_t proctype;
	struct message *messagep;

	if ((batchp->type & (T_BOUNCE_BATCH|T_MDA_BATCH|T_MTA_BATCH)) == 0)
		fatal("runner_batch_dispatch: unknown batch type");

	log_debug("in batch dispatch");
	if (batchp->type == T_BOUNCE_BATCH) {
		while ((messagep = TAILQ_FIRST(&batchp->messages))) {
			bounce_process(env, messagep);
			TAILQ_REMOVE(&batchp->messages, messagep, entry);
			bzero(messagep, sizeof(*messagep));
			free(messagep);
		}
		env->stats->runner.bounces_active++;
		env->stats->runner.bounces++;
		return;
	}

	if (batchp->type & T_MDA_BATCH) {
		proctype = PROC_MDA;
		env->stats->mda.sessions_active++;
		env->stats->mda.sessions++;
	} else if (batchp->type & T_MTA_BATCH) {
		proctype = PROC_MTA;
		env->stats->mta.sessions_active++;
		env->stats->mta.sessions++;
	}

	imsg_compose_event(env->sc_ievs[proctype], IMSG_BATCH_CREATE, 0, 0, -1,
	    batchp, sizeof (struct batch));

	while ((messagep = TAILQ_FIRST(&batchp->messages))) {
		imsg_compose_event(env->sc_ievs[proctype], IMSG_BATCH_APPEND, 0, 0,
		    -1, messagep, sizeof (struct message));
		TAILQ_REMOVE(&batchp->messages, messagep, entry);
		bzero(messagep, sizeof(struct message));
		free(messagep);
	}

	imsg_compose_event(env->sc_ievs[proctype], IMSG_BATCH_CLOSE, 0, 0, -1,
	    batchp, sizeof(struct batch));
}

d862 5
a866 4
		messagep->type == T_BOUNCE_MESSAGE) {
		if (messagep->status & S_MESSAGE_LOCKFAILURE) {
			if (messagep->retry < 128)
				return 1;
a867 8
		}
		else {
			if (messagep->retry < 5)
				return 1;
			
			if (messagep->retry < 15)
				delay = (messagep->retry * 60) + arc4random_uniform(60);
		}
@


1.77
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.76 2009/12/14 19:56:55 jacekm Exp $	*/
d86 3
d220 14
d944 42
@


1.76
log
@Tweak the logic behind setting the fd limits so that smtpd is less likely
to get upset by custom soft/hard ulimit settings.

Suggested by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.75 2009/12/14 18:21:53 jacekm Exp $	*/
d137 9
@


1.75
log
@Control maximum number of bounce sessions similarly to how the mta and mda
are now controlled.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.74 2009/12/14 16:44:14 jacekm Exp $	*/
d559 1
a559 1
	fdlimit(getdtablesize() * 2);
@


1.74
log
@Impose sessions limit on the delivery sessions (mta and mda).
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.73 2009/12/13 22:02:55 jacekm Exp $	*/
d635 1
d638 4
d652 1
a652 1
			if (env->stats->mda.sessions_active >= env->sc_maxconn)
d659 8
a666 1
			if (env->stats->mta.sessions_active >= env->sc_maxconn)
d696 6
a701 9
		if (message.type & T_MDA_MESSAGE) {
			env->stats->mda.sessions_active++;
			env->stats->mda.sessions++;
		}

		if (message.type & T_MTA_MESSAGE) {
			env->stats->mta.sessions_active++;
			env->stats->mta.sessions++;
		}
d792 2
d797 1
a797 1
	if (batchp->type & T_MDA_BATCH)
d799 3
a801 1
	else if (batchp->type & T_MTA_BATCH)
d803 3
@


1.73
log
@Use safe fd limits in smtp, lka, queue, and control.  Removes a
possibility for fd-starvation fatal when under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.72 2009/11/08 23:08:56 gilles Exp $	*/
d307 4
d356 3
d560 2
d644 1
a644 1
		if (message.type & T_MDA_MESSAGE)
d647 3
d651 1
a651 1
		if (message.type & T_MTA_MESSAGE)
d654 3
d682 10
@


1.72
log
@rework a bit expansion and data structures involved in the expansion so we
no longer have a direct mapping between structures saved in aliases/virtual
db and structures used at runtime during expansion.

side effects ? struct alias is smaller, databases are smaller and it is no
longer necessary to rebuild aliases/virtual databases each time jacekm@@ or
I make changes to some obscure structure used indirectely during expansion

rebuild databases, flush queues, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.71 2009/11/08 21:40:05 gilles Exp $	*/
d550 3
@


1.71
log
@- make aliases expansion use a rb tree instead of a tail queue, the code
  doesn't take advantage of the new structure yet, but this was a needed
  change for upcoming improvements.
- introduce aliasestree_{lookup,insert,remove} to the aliases api
- rename queue_generate_id() to generate_uid() and move it to utils.c as
  it is used all over the place and not only in queue

tree idea discussed with jacekm@@, if you update rebuild aliases db, make
clean and flush queue
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.70 2009/11/03 11:10:43 jacekm Exp $	*/
d802 2
@


1.70
log
@Improve error logging.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.69 2009/11/01 22:15:27 gilles Exp $	*/
d963 1
a963 1
		batchp->id = queue_generate_id();
@


1.69
log
@fix a couple log_info()s,
from Tim van der Molen <tbvdm@@xs4all.nl>
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.68 2009/10/12 22:34:37 gilles Exp $	*/
a749 1
			log_debug("starting");
a751 1
			log_debug("ending");
@


1.68
log
@- fix a null deref which could happen after a couple iterations of the
  aliases/virtual domains resolution code.

- fix a logic bug which caused virtual domains not to be correctly
  handled after one iteration of the aliases resolution code.

- introduce a few helper functions to help clean up and simplify the
  lka code.

- simplify the IS_EXT/IS_MAILBOX/IS_RELAY macros so they manipulate a
  struct path * instead of the mess of dereferences we were passing them.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.67 2009/09/04 19:11:32 jacekm Exp $	*/
d468 1
a468 1
	log_info("runner handler");
@


1.67
log
@Fix scheduling of bounces that could not be delivered.
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.66 2009/09/04 13:33:00 jacekm Exp $	*/
d985 1
a985 2
			if (IS_MAILBOX(path->rule.r_action) ||
			    IS_EXT(path->rule.r_action)) {
@


1.66
log
@Fix scheduling of bounce messages.

From gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.65 2009/09/04 11:44:23 jacekm Exp $	*/
d443 9
a451 4
		case IMSG_SMTP_ENQUEUE:
			if (imsg.fd == -1 || ! bounce_session(env, imsg.fd,
			    imsg.data))
				message_reset_flags(imsg.data);
d453 2
@


1.65
log
@Fix a crash when messagep->batch_id is read from disk and used long
after the batch has ceased to exist.

From gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.64 2009/09/03 08:19:13 jacekm Exp $	*/
a777 3
	if (messagep->type == T_BOUNCE_MESSAGE)
		return 1;

d798 2
a799 1
	if (messagep->type & T_MDA_MESSAGE) {
d814 1
a814 1
	if (messagep->type & T_MTA_MESSAGE) {
@


1.64
log
@imsg_get sets errno so use fatal instead of fatalx.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.63 2009/08/27 11:37:30 jacekm Exp $	*/
d698 1
d1004 1
a1004 1
	if (message->type & (T_BOUNCE_MESSAGE|T_MDA_MESSAGE))
@


1.63
log
@Implement client side of the SMTP protocol in a library-like module.
Make bounce code and /usr/sbin/sendmail interface use this new API.
The mta process continues to use its own implementation, but
eventually will be switched to use this shared module.

Buffer routines are taken from buffer.c rather than from evbuffer.
This is one step forward to using a single buffer API across the
program.

"it looks sexy" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.62 2009/08/11 14:46:58 jacekm Exp $	*/
d129 1
a129 1
			fatalx("runner_dispatch_parent: imsg_get error");
d177 1
a177 1
			fatalx("runner_dispatch_control: imsg_get error");
d248 1
a248 1
			fatalx("runner_dispatch_queue: imsg_get error");
d302 1
a302 1
			fatalx("runner_dispatch_mda: imsg_get error");
d347 1
a347 1
			fatalx("runner_dispatch_mta: imsg_get error");
d393 1
a393 1
			fatalx("runner_dispatch_lka: imsg_get error");
d438 1
a438 1
			fatalx("runner_dispatch_smtp: imsg_get error");
@


1.62
log
@call reset_flags in bounce_session failure code path.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.61 2009/08/11 14:45:19 jacekm Exp $	*/
a85 2
void		reset_flags(struct message *);

d443 4
a446 12
		case IMSG_SMTP_ENQUEUE: {
			struct message *messagep = imsg.data;
			if (imsg.fd == -1) {
				reset_flags(messagep);
				break;
			}

			if (bounce_session(env, imsg.fd, messagep))
				queue_remove_envelope(messagep);
			else
				reset_flags(messagep);

a447 1
		}
d586 1
a586 1
		reset_flags(&message);
d1113 1
a1113 1
reset_flags(struct message *m)
@


1.61
log
@do not repeat flag resetting code, introduce reset_flags().
discussed with gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.60 2009/08/08 00:02:22 gilles Exp $	*/
d454 2
@


1.60
log
@import some changes from portable smtpd to reduce the delta between both.
this commit contains mostly missing casts and cosmethic changes, do not
expect to build this anywhere but on OpenBSD, it does not contain any of
the portable glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.59 2009/08/06 16:46:57 gilles Exp $	*/
d86 2
d448 1
a448 5
				messagep->flags &= ~F_MESSAGE_SCHEDULED;
				messagep->flags &= ~F_MESSAGE_PROCESSING;

				while (! queue_update_envelope(messagep))
					sleep(1);
d595 1
a595 6

		message.flags &= ~F_MESSAGE_SCHEDULED;
		message.flags &= ~F_MESSAGE_PROCESSING;

		while (! queue_update_envelope(&message))
			sleep(1);
d1119 10
@


1.59
log
@- change all occurences of T_DAEMON_BATCH,MESSAGE to T_BOUNCE_BATCH/MESSAGE
- make sure T_BOUNCE_MESSAGE is no longer OR-ed to T_MDA/MTA_MESSAGE
- define F_MESSAGE_BOUNCE flag and make sure bounce sessions set it
- teach smtpctl show queue how to recognize a bounce message
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.58 2009/08/06 16:29:35 gilles Exp $	*/
d1093 1
a1093 1
		if (strchr(buf, ':') == NULL && !isspace(*buf))
@


1.58
log
@replace X-OpenSMPTD-Loop with Delivered-To

idea by jacekm@@ a few weeks ago, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.57 2009/08/06 14:32:34 gilles Exp $	*/
d752 1
a752 1
	if ((batchp->type & (T_DAEMON_BATCH|T_MDA_BATCH|T_MTA_BATCH)) == 0)
d756 1
a756 1
	if (batchp->type == T_DAEMON_BATCH) {
d793 1
a793 1
	if (messagep->type == T_DAEMON_MESSAGE)
d982 2
a983 2
		if (messagep->type & T_DAEMON_MESSAGE) {
			batchp->type = T_DAEMON_BATCH;
d994 1
a994 1
		if (batchp->type != T_DAEMON_BATCH) {
d1019 1
a1019 1
	if (message->type & (T_DAEMON_MESSAGE|T_MDA_MESSAGE))
a1098 1
				log_debug("LOOP DETECTED THROUGH RECEIVED LINES COUNT");
d1112 1
a1112 1
			if (messagep->type == T_DAEMON_MESSAGE)
a1116 2
				log_debug("LOOP DETECTED THROUGH X-OPENSMTPD-LOOP HEADER: %s@@%s",
				    chkpath.user, chkpath.domain);
@


1.57
log
@when a message in queue expires, generate a bounce before we remove it
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.56 2009/08/06 14:12:48 gilles Exp $	*/
d1105 1
a1105 1
		else if (strncasecmp("X-OpenSMTPD-Loop: ", buf, 18) == 0) {
d1109 1
a1109 1
			if (! recipient_to_path(&chkpath, buf + 18))
@


1.56
log
@- introduce message_set_errormsg() to set the error description that will
  appear in a bounce message, and message_get_errormsg() to retrieve that
  message.
- when loop is detected, call message_set_errormsg()
- in mta, call message_set_errormsg() for each recipient failure
- in mta, call message_set_errormsg() to copy batch errors to recipients if
  we failed to deliver for a session related error
- when bouncing, add the recipient and error reason to the bounce message
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.55 2009/08/06 13:40:45 gilles Exp $	*/
d804 3
@


1.55
log
@This commit reworks the entire mailer daemon support to actually make it
work for real. As an added bonus, it simplifies it, makes it follow the
same code path as regular messages and kills quite some code from mta,
mda and store. There's still some work needed but the most painful part
is behind us now ;)

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.54 2009/07/28 22:03:55 gilles Exp $	*/
d653 1
@


1.54
log
@introduce daemon_record_message() and needed glue in queue_shared.c to
atomically create a mailer daemon out of a message. it is unreferenced
for now, this commit makes no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.53 2009/06/29 10:11:07 martynas Exp $	*/
d58 1
d409 61
d509 1
d653 1
a653 1
			/*daemon_record_message(&message);*/
d751 1
a751 1
	if ((batchp->type & (T_MDA_BATCH|T_MTA_BATCH)) == 0)
d754 13
d792 3
d990 8
a997 6
		if (IS_MAILBOX(path->rule.r_action) ||
		    IS_EXT(path->rule.r_action)) {
			batchp->type |= T_MDA_BATCH;
		}
		else {
			batchp->type |= T_MTA_BATCH;
d1012 4
a1015 2
	/* We only support delivery of one message at a time, in MDA */
	if (message->type & T_MDA_MESSAGE)
d1102 2
d1108 6
a1113 2
			if (strcasecmp(chkpath.user, messagep->recipient.user) == 0 &&
			    strcasecmp(chkpath.domain, messagep->recipient.domain) == 0) {
@


1.53
log
@since upper-bound is not a power of two here, use arc4random_uniform
instead, to avoid modulo bias.  ok jacekm@@, gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.52 2009/06/06 04:14:21 pyr Exp $	*/
d590 1
a590 1
			log_debug("TODO: generate mailer daemon");
@


1.52
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.51 2009/06/05 20:43:57 pyr Exp $	*/
d737 1
a737 1
			delay = (messagep->retry * 60) + arc4random() % 60;
d744 1
a744 1
				delay = (messagep->retry * 60) + arc4random() % 60;
@


1.51
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.50 2009/06/03 22:04:15 jacekm Exp $	*/
d102 1
d107 2
a108 1
	ibuf = env->sc_ibufs[PROC_PARENT];
d115 1
a115 1
			event_del(&ibuf->ev);
d143 1
a143 1
	imsg_event_add(ibuf);
d150 1
d155 2
a156 1
	ibuf = env->sc_ibufs[PROC_CONTROL];
d163 1
a163 1
			event_del(&ibuf->ev);
d204 1
a204 1
			imsg_compose_event(ibuf, IMSG_RUNNER_SCHEDULE, 0, 0, -1, s, sizeof(*s));
d214 1
a214 1
	imsg_event_add(ibuf);
d221 1
d226 2
a227 1
	ibuf = env->sc_ibufs[PROC_QUEUE];
d234 1
a234 1
			event_del(&ibuf->ev);
d268 1
a268 1
	imsg_event_add(ibuf);
d275 1
d280 2
a281 1
	ibuf = env->sc_ibufs[PROC_MDA];
d288 1
a288 1
			event_del(&ibuf->ev);
d313 1
a313 1
	imsg_event_add(ibuf);
d320 1
d325 2
a326 1
	ibuf = env->sc_ibufs[PROC_MTA];
d333 1
a333 1
			event_del(&ibuf->ev);
d359 1
a359 1
	imsg_event_add(ibuf);
d366 1
d371 2
a372 1
	ibuf = env->sc_ibufs[PROC_LKA];
d379 1
a379 1
			event_del(&ibuf->ev);
d404 1
a404 1
	imsg_event_add(ibuf);
d515 1
a515 1
		imsg_compose_event(env->sc_ibufs[PROC_PARENT],
d696 1
a696 1
	imsg_compose_event(env->sc_ibufs[proctype], IMSG_BATCH_CREATE, 0, 0, -1,
d700 1
a700 1
		imsg_compose_event(env->sc_ibufs[proctype], IMSG_BATCH_APPEND, 0, 0,
d707 1
a707 1
	imsg_compose_event(env->sc_ibufs[proctype], IMSG_BATCH_CLOSE, 0, 0, -1,
@


1.50
log
@simplify struct batch; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.49 2009/06/01 13:20:56 jacekm Exp $	*/
d200 1
a200 1
			imsg_compose(ibuf, IMSG_RUNNER_SCHEDULE, 0, 0, -1, s, sizeof(*s));
d503 1
a503 1
		imsg_compose(env->sc_ibufs[PROC_PARENT],
d684 1
a684 1
	imsg_compose(env->sc_ibufs[proctype], IMSG_BATCH_CREATE, 0, 0, -1,
d688 1
a688 1
		imsg_compose(env->sc_ibufs[proctype], IMSG_BATCH_APPEND, 0, 0,
d695 1
a695 1
	imsg_compose(env->sc_ibufs[proctype], IMSG_BATCH_CLOSE, 0, 0, -1,
@


1.49
log
@Fix EV_READ/EV_WRITE testing inside IMSG handlers. Based on similar change
to the routing daemons by claudio@@; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.48 2009/05/24 14:38:56 jacekm Exp $	*/
a880 1
		batchp->creation = messagep->creation;
@


1.48
log
@Parent process forks 3 types of processes, track them all in a single tree
using newly introduced child struct.

Manage process titles centrally in struct smtpd.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.47 2009/05/24 14:22:23 jacekm Exp $	*/
d107 2
a108 2
	switch (event) {
	case EV_READ:
d117 3
a119 2
		break;
	case EV_WRITE:
a121 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d153 2
a154 2
	switch (event) {
	case EV_READ:
d163 3
a165 2
		break;
	case EV_WRITE:
a167 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d222 2
a223 2
	switch (event) {
	case EV_READ:
d232 3
a234 2
		break;
	case EV_WRITE:
a236 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d274 2
a275 2
	switch (event) {
	case EV_READ:
d284 3
a286 2
		break;
	case EV_WRITE:
a288 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d317 2
a318 2
	switch (event) {
	case EV_READ:
d327 3
a329 2
		break;
	case EV_WRITE:
a331 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d361 2
a362 2
	switch (event) {
	case EV_READ:
d371 3
a373 2
		break;
	case EV_WRITE:
a375 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
@


1.47
log
@Instead of keeping stats private to each process, and querying every
process individually whenever stats need to be fetched, keep stats
in MAP_ANON shared memory allocated by parent.

This means control has direct access to stats and can respond very
quickly without troubling any other daemon processes.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.46 2009/05/19 11:24:24 jacekm Exp $	*/
a476 1
	setproctitle("runner");
d478 1
@


1.46
log
@Verify the amount of IMSG payload is exactly as expected; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.45 2009/05/14 15:05:12 eric Exp $	*/
a84 2
struct s_runner	 s_runner;

a194 9
		case IMSG_STATS: {
			struct stats *s = imsg.data;

			IMSG_SIZE_CHECK(s);

			s->u.runner = s_runner;
			imsg_compose(ibuf, IMSG_STATS, 0, 0, -1, s, sizeof(*s));
			break;
		}
d260 1
a260 1
			s_runner.active--;
d928 1
a928 1
	s_runner.active++;
@


1.45
log
@use the nitems() macro where appropriate

ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.44 2009/05/10 11:29:40 jacekm Exp $	*/
d198 3
a200 1
			struct stats *s;
a201 1
			s = imsg.data;
d207 1
a207 1
			struct sched *s;
d209 1
a209 1
			s = imsg.data;
d267 4
d272 1
a272 1
			queue_message_update(imsg.data);
@


1.44
log
@assert copyright; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.43 2009/04/21 18:39:00 jacekm Exp $	*/
d504 2
a505 2
	config_pipes(env, peers, 6);
	config_peers(env, peers, 6);
@


1.43
log
@small corrections to log_warns and fatals
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.42 2009/04/21 18:12:05 jacekm Exp $	*/
d6 1
@


1.42
log
@Make /usr/sbin/sendmail not fail due to smtpd being down.

The approach is to save cmdline + stdin in a file under a newly
added directory /var/spool/smtpd/offline (uid 0 gid 0 mode 1777).
Next time daemon starts, it uses information in that directory
to replay sendmail on user's behalf.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.41 2009/04/21 14:37:32 eric Exp $	*/
d130 1
a130 1
			fatal("runner_dispatch_parent: imsg_read error");
@


1.41
log
@correct some fatal(x) calls and error strings

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.40 2009/04/18 21:13:56 jacekm Exp $	*/
d51 1
d61 1
d100 49
d452 1
d503 2
a504 2
	config_pipes(env, peers, 5);
	config_peers(env, peers, 5);
d508 1
d515 16
@


1.40
log
@correct function name in fatal
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.39 2009/04/12 15:42:13 gilles Exp $	*/
d128 1
a128 1
			fatal("runner_dispatch_control: imsg_read error");
d208 1
a208 1
			fatal("runner_dispatch_queue: imsg_read error");
d259 1
a259 1
			fatal("runner_dispatch_mda: imsg_read error");
d305 1
a305 1
			fatal("runner_dispatch_mta: imsg_read error");
d352 1
a352 1
			fatal("runner_dispatch_lka: imsg_read error");
@


1.39
log
@When runner_check_loop() detects a mail loop, remove the envelope. This is
only half of the problem solved, we need to generate a mailer daemon too.
This fixes a bug in my smtpd where it would try to schedule a message,
detect that it is a loop and not schedule it, then trying again at next
queue walk ...
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.38 2009/03/29 14:18:20 jacekm Exp $	*/
d774 1
a774 1
		fatal("queue_delete_incoming_message: snprintf");
d778 1
a778 1
		fatal("queue_delete_incoming_message: snprintf");
d781 1
a781 1
		fatal("queue_delete_incoming_message: snprintf");
d785 1
a785 1
			fatal("queue_delete_incoming_message: unlink");
d791 1
a791 1
		fatal("queue_delete_incoming_message: opendir");
d799 1
a799 1
			fatal("queue_delete_incoming_message: snprintf");
d803 1
a803 1
				fatal("queue_delete_incoming_message: unlink");
d809 1
a809 1
			fatal("queue_delete_incoming_message: rmdir");
d814 1
a814 1
			fatal("queue_delete_incoming_message: rmdir");
@


1.38
log
@turn some log_debugs into log_warns or even fatals; "looks ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.37 2009/03/22 22:53:47 gilles Exp $	*/
d531 5
a535 1
		runner_check_loop(&message);
@


1.37
log
@fix a bug in the resolution of forward files which would cause usernames
not to be taken into account if they had no ~/.forward file AND were the
result of an alias expansion that expanded to more than one username.

while at it, I spotted another bug where I would check T_MDA_MESSAGE on
the flags field instead of the type field. the bug could cause two MDA
message to end up in the same batch which is no longer valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.36 2009/03/18 10:29:27 gilles Exp $	*/
d168 1
a168 1
			log_debug("queue_dispatch_control: unexpected imsg %d",
d170 1
a170 1
			break;
d219 1
a219 1
			log_debug("runner_dispatch_queue: unexpected imsg %d",
d221 1
a221 1
			break;
d265 1
a265 1
			log_debug("runner_dispatch_mda: unexpected imsg %d",
d267 1
a267 1
			break;
d312 1
a312 1
			log_debug("runner_dispatch_mta: unexpected imsg %d",
d314 1
a314 1
			break;
d358 1
a358 1
			log_debug("runner_dispatch_lka: unexpected imsg %d",
d360 1
a360 1
			break;
@


1.36
log
@we can no longer create batches of MDA deliveries, so make sure runner
does not do a batch lookup when dealing with a MDA message
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.35 2009/03/15 19:15:25 gilles Exp $	*/
d871 1
a871 1
	if (message->flags & T_MDA_MESSAGE)
@


1.35
log
@the mda process no longer uses struct batch as its central structure to
deal with deliveries, it now uses struct session just like mta and smtp
processes. we now keep the mbox and message descriptors in the session,
saving space in struct message which is now as small as we can make it.
While at it, plugged a memory leak and did some cosmethic changes

This was the last planned change to our struct message which means that
later changes will no longer require a queue flush before rebuild.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.34 2009/03/09 01:43:19 gilles Exp $	*/
d869 4
@


1.34
log
@add basic support for outgoing authentication (AUTH PLAIN over ssl) which
can be turned on by adding "enable auth" to a "relay via" rule. this made
me rework the mx resolution so that it is done by the mta process and not
the runner process anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.33 2009/02/24 12:07:47 gilles Exp $	*/
a610 4
//		if ((batchp->type & T_MTA_BATCH) &&
//		    (batchp->flags & F_BATCH_RESOLVED) == 0) {
//			continue;
//		}
a855 2
//			imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_MX,
//			    0, 0, -1, batchp, sizeof(struct batch));
@


1.33
log
@teach smtpctl's parser how to deal with parameters that are not necessarily
a token so that it is possible to do: smtpctl schedule <message id/uid>

introduce F_MESSAGE_FORCESCHEDULE which lets the runner schedule a message
even if the retry delay has not been expired.

F_MESSAGE_ENQUEUED is a valid flag for a message and should not cause an\
errx() in smtpctl show queue
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.32 2009/02/22 23:29:54 jacekm Exp $	*/
a66 1
int		runner_batch_resolved(struct smtpd *, struct batch *);
a356 4
		case IMSG_LKA_MX: {
			runner_batch_resolved(env, imsg.data);
			break;
		}
d611 4
a614 4
		if ((batchp->type & T_MTA_BATCH) &&
		    (batchp->flags & F_BATCH_RESOLVED) == 0) {
			continue;
		}
a623 65
int
runner_batch_resolved(struct smtpd *env, struct batch *lookup)
{
	u_int32_t i;
	struct batch *batchp;

	batchp = batch_by_id(env, lookup->id);
	batchp->getaddrinfo_error = lookup->getaddrinfo_error;
	batchp->mx_cnt = lookup->mx_cnt;

/*
           EAI_NODATA        no address associated with hostname
           EAI_NONAME        hostname or servname not provided, or not known
           EAI_PROTOCOL      resolved protocol is unknown
           EAI_SERVICE       servname not supported for ai_socktype
           EAI_SOCKTYPE      ai_socktype not supported
           EAI_SYSTEM        system error returned in errno


 */

	switch (batchp->getaddrinfo_error) {
	case 0:
		batchp->flags |= F_BATCH_RESOLVED;
		for (i = 0; i < batchp->mx_cnt; ++i) {
			batchp->mxarray[i].flags = lookup->mxarray[i].flags;
			batchp->mxarray[i].ss = lookup->mxarray[i].ss;
		}
		break;
	case EAI_ADDRFAMILY:
	case EAI_BADFLAGS:
	case EAI_BADHINTS:
	case EAI_FAIL:
	case EAI_FAMILY:
	case EAI_NODATA:
	case EAI_NONAME:
	case EAI_SERVICE:
	case EAI_SOCKTYPE:
	case EAI_SYSTEM:
		/* XXX */
		/*
		 * In the case of a DNS permanent error, do not generate a
		 * daemon message if the error originates from one already
		 * as this would cause a loop. Remove the initial batch as
		 * it will never succeed.
		 *
		 */
		return 0;

	case EAI_AGAIN:
	case EAI_MEMORY:
		/* XXX */
		/*
		 * Do not generate a daemon message if this error happened
		 * while processing a daemon message. Do NOT remove batch,
		 * it may succeed later.
		 */
		return 0;

	default:
		fatalx("runner_batch_resolved: unknown getaddrinfo error.");
	}
	return 1;
}

d860 2
a861 2
			imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_MX,
			    0, 0, -1, batchp, sizeof(struct batch));
@


1.32
log
@Fix race possible between runner and queue when starting up.
runner_reset_flags would attempt to update envelope, but its
envelope.tmp could be renamed by queue_purge. The fix is to store
envelope.tmp in a place no other process writes to, and
/queue/envelope.tmp is perfect for this.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.31 2009/02/22 11:44:29 form Exp $	*/
d80 3
d154 14
d539 1
d731 3
d774 43
@


1.31
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.30 2009/02/15 10:32:23 jacekm Exp $	*/
d442 1
d763 1
a763 6
	while (qwalk(q, path)) {
		if (strcmp(basename(path), "envelope.tmp") == 0) {
			if (unlink(path) == -1)
				fatal("runner_purge_run: unlink");
			continue;
		}
a764 1
	}
@


1.30
log
@New config.c that allows for process cloning. Done by pyr@@ for
relayd at n2k9, and adapted to smtpd; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.29 2009/02/14 17:49:09 jacekm Exp $	*/
d784 1
a784 1
	if (! bsnprintf(rootdir, MAXPATHLEN, "%s/%s", PATH_PURGE, msgid))
d787 2
a788 1
	if (! bsnprintf(evpdir, MAXPATHLEN, "%s%s", rootdir, PATH_ENVELOPES))
d791 1
a791 1
	if (! bsnprintf(msgpath, MAXPATHLEN, "%s/message", rootdir))
d808 1
a808 1
		if (! bsnprintf(evppath, MAXPATHLEN, "%s/%s", evpdir,
@


1.29
log
@Initialize time_t now as necessary, fixes delivery rescheduling; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.28 2009/01/29 21:59:15 jacekm Exp $	*/
d439 1
@


1.28
log
@Implement "smtpctl show stats"; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.27 2009/01/29 12:43:25 jacekm Exp $	*/
d499 1
@


1.27
log
@Common queue walking code for smtpd and smtpctl. Kills majority of showqueue.c,
the remaining code was moved to queue_shared.c; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.26 2009/01/28 17:43:45 gilles Exp $	*/
d80 2
d143 8
d198 1
d874 1
@


1.26
log
@relayhost flags were not properly copied to the relayhost array of the
batch we're handing over to mta. this prevented mta from knowing if a
session has to be established over ssl or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.25 2009/01/28 17:29:11 jacekm Exp $	*/
d37 1
d59 1
a59 1
int		runner_reset_flags(void);
d63 1
a63 1
void		runner_process_envelope(struct message *);
a66 3
void		runner_envelope_rewind(void);
int		runner_envelope_next(struct message *);

a79 2
static DIR	*curdir, *dir_queue, *dir_bucket, *dir_envelope;

d430 1
a430 2
	while (! runner_reset_flags())
		sleep(1);
d439 1
a439 1
int
d442 5
a446 1
	struct message message;
d448 3
a450 1
	runner_envelope_rewind();
a451 1
	while (runner_envelope_next(&message)) {
d455 2
a456 2
		if (! queue_update_envelope(&message))
			return 0;
d459 1
a459 1
	return 1;
a465 1
	struct message		 message;
a468 13
	runner_envelope_rewind();

	while (runner_envelope_next(&message)) {
		if (message.type & T_MDA_MESSAGE)
			if (env->sc_opts & SMTPD_MDA_PAUSED)
				continue;

		if (message.type & T_MTA_MESSAGE)
			if (env->sc_opts & SMTPD_MTA_PAUSED)
				continue;

		runner_process_envelope(&message);
	}
d470 1
d480 1
a480 1
runner_process_envelope(struct message *messagep)
d482 11
a492 3
	char evppath[MAXPATHLEN];
	char rqpath[MAXPATHLEN];
	struct stat sb;
d494 12
a505 2
	if (! runner_message_schedule(messagep, time(NULL)))
		return;
d507 2
a508 1
	runner_check_loop(messagep);
d510 3
a512 3
	messagep->flags |= F_MESSAGE_SCHEDULED;
	if (! queue_update_envelope(messagep))
		return;
d514 6
a519 16
	if (! bsnprintf(evppath, MAXPATHLEN, "%s/%d/%s%s/%s", PATH_QUEUE,
		queue_hash(messagep->message_id), messagep->message_id,
		PATH_ENVELOPES, messagep->message_uid))
		fatal("runner_process_envelope: snprintf");

	if (! bsnprintf(rqpath, MAXPATHLEN, "%s/%s", PATH_RUNQUEUE,
		messagep->message_uid))
		fatal("runner_process_envelope: snprintf");

	if (stat(rqpath, &sb) == -1) {
		if (errno != ENOENT)
			fatal("runner_process_envelope: stat");

		if (symlink(evppath, rqpath) == -1) {
			log_info("queue_process_envelope: "
			    "failed to place envelope in runqueue");
d522 2
d529 6
a534 7
	DIR *dirp;
	struct dirent *dp;
	struct message message;
	struct message *messagep;
	struct batch *batchp;
	char pathname[MAXPATHLEN];
	time_t tm;
d538 1
a538 8
	dirp = opendir(PATH_RUNQUEUE);
	if (dirp == NULL)
		fatal("runner_process_runqueue: opendir");

	while ((dp = readdir(dirp)) != NULL) {
		if (strcmp(dp->d_name, ".") == 0 ||
		    strcmp(dp->d_name, "..") == 0)
			continue;
d540 2
a541 3
		snprintf(pathname, MAXPATHLEN, "%s/%s", PATH_RUNQUEUE,
		    dp->d_name);
		unlink(pathname);
d543 1
a543 1
		if (! queue_load_envelope(&message, dp->d_name))
d570 1
a570 1
	closedir(dirp);
a596 74
void
runner_envelope_rewind(void)
{
	if (dir_queue != NULL) {
		closedir(dir_queue);
		closedir(dir_bucket);
		closedir(dir_envelope);
	}

	curdir = dir_queue = opendir(PATH_QUEUE);
	if (curdir == NULL)
		fatal("runner_envelope_rewind: opendir");
}

int
runner_envelope_next(struct message *messagep)
{
	static int	 bucket;
	char		 path[MAXPATHLEN];
	const char	*errstr;
	struct dirent	*dp;

again:
	dp = readdir(curdir);

	if (dp == NULL)
		closedir(curdir);
	else if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
		goto again;

	if (curdir == dir_queue) {
		if (dp == NULL) {
			dir_queue = NULL;
			return (0);
		}
		bucket = strtonum(dp->d_name, 0, DIRHASH_BUCKETS - 1, &errstr);
		if (errstr) {
			log_warnx("runner_envelope_next: invalid bucket: %s/%s",
			    PATH_QUEUE, dp->d_name);
			goto again;
		}
		if (! bsnprintf(path, MAXPATHLEN, "%s/%d", PATH_QUEUE, bucket))
			fatalx("runner_envelope_next: snprintf");
		curdir = dir_bucket = opendir(path);
		goto recurse;
	}

	if (curdir == dir_bucket) {
		if (dp == NULL) {
			curdir = dir_queue;
			goto again;
		}
		if (! bsnprintf(path, MAXPATHLEN, "%s/%d/%s%s", PATH_QUEUE,
			bucket, dp->d_name, PATH_ENVELOPES))
			fatalx("runner_envelope_next: snprintf");
		curdir = dir_envelope = opendir(path);
		goto recurse;
	}

	if (curdir == dir_envelope) {
		if (dp == NULL) {
			curdir = dir_bucket;
			goto again;
		}
		queue_load_envelope(messagep, dp->d_name);
		return (1);
	}

recurse:
	if (curdir == NULL)
		fatal("runner_envelope_next: opendir failed");
	goto again;
}

d744 2
a745 2
	DIR		*dirp;
	struct dirent	*dp;
d747 1
a747 11
	dirp = opendir(PATH_PURGE);
	if (dirp == NULL)
		fatal("runner_purge_run: opendir");

	while ((dp = readdir(dirp)) != NULL) {
		if (strcmp(dp->d_name, ".") == 0 ||
		    strcmp(dp->d_name, "..") == 0) {
			continue;
		}
		if (strcmp(dp->d_name, "envelope.tmp") == 0) {
			char path[MAXPATHLEN];
d749 2
a750 3
			if (! bsnprintf(path, MAXPATHLEN, "%s/envelope.tmp",
				PATH_PURGE))
				fatalx("runner_purge_run: snprintf");
d753 3
a755 2
		} else
			runner_purge_message(dp->d_name);
d758 1
a758 1
	closedir(dirp);
@


1.25
log
@Make races between queue and runner impossible by implementing the policy:
1) queue never reads /queue.
2) queue writes to /queue only at message injection time.
3) runner does all reading, and all writing apart from 2).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.24 2009/01/28 13:29:40 gilles Exp $	*/
d563 1
d706 2
a707 1
		for (i = 0; i < batchp->mx_cnt; ++i)
d709 1
@


1.24
log
@bring loop detection support. we handle this with a qmail-like approach which
consists of checking headers for a custom header, but we also count how many
hops the mail went through and use a hard limit (currently set to 100 as was
recommanded by RFC) as a safe-guard.

idea discussed with jacekm@@, qmail approach suggested by claudio@@ a long time
ago
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.23 2009/01/27 22:48:29 gilles Exp $	*/
d191 4
d505 2
a506 1
	queue_update_envelope(messagep);
d563 2
a564 1
		queue_update_envelope(&message);
d676 1
a676 3
	if (curdir == NULL) {
		if (errno == ENOENT)
			goto again;
a677 1
	}
@


1.23
log
@first bricks of enqueue code which allows smtpctl to submit mail to queue
without "talking" smtp to listeners. currently, a big part of the server
side code is done (and requires a cleanup), next step is to get it usable
properly from a mail user agent.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.22 2009/01/08 19:15:23 jacekm Exp $	*/
d31 1
d33 1
d77 2
d498 2
d1002 60
@


1.22
log
@clear processing flags early so that there's never doubt whether they
belong to previous or current smtpd instance; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.21 2009/01/06 23:02:07 jacekm Exp $	*/
a349 1

@


1.21
log
@rework /queue traversal; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.20 2009/01/06 20:17:23 jacekm Exp $	*/
d55 3
a77 2
u_int8_t flagreset = 1;

d427 3
d437 18
a476 1
	flagreset = 0;
a490 5

	if (flagreset) {
		messagep->flags &= ~(F_MESSAGE_SCHEDULED|F_MESSAGE_PROCESSING);
		queue_update_envelope(messagep);
	}
@


1.20
log
@make file update in queue_update_envelope atomic; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.19 2009/01/04 22:35:09 gilles Exp $	*/
d57 1
a57 4
void		runner_process_queue(struct smtpd *);
void		runner_process_bucket(struct smtpd *, u_int16_t);
void		runner_process_message(struct smtpd *, char *);
void		runner_process_envelope(struct smtpd *, char *, char *);
d61 3
d77 2
d437 1
d441 14
a454 1
	runner_process_queue(env);
d465 1
a465 27
runner_process_queue(struct smtpd *env)
{
	DIR *dirp;
	struct dirent *dp;
	const char *errstr;
	u_int16_t bucket;

	dirp = opendir(PATH_QUEUE);
	if (dirp == NULL)
		fatal("runner_process_queue: opendir");
	while ((dp = readdir(dirp)) != NULL) {
		if (strcmp(dp->d_name, ".") == 0 ||
		    strcmp(dp->d_name, "..") == 0)
			continue;
		bucket = strtonum(dp->d_name, 0, DIRHASH_BUCKETS - 1, &errstr);
		if (errstr) {
			log_warnx("runner_process_queue: invalid bucket: %s/%s",
			    PATH_QUEUE, dp->d_name);
			continue;
		}
		runner_process_bucket(env, bucket);
	}
	closedir(dirp);
}

void
runner_process_bucket(struct smtpd *env, u_int16_t bucket)
a466 47
	DIR *dirp = NULL;
	struct dirent *dp;
	char bucketpath[MAXPATHLEN];

	if (! bsnprintf(bucketpath, MAXPATHLEN, "%s/%d", PATH_QUEUE, bucket))
		fatal("runner_process_bucket: snprintf");
	dirp = opendir(bucketpath);
	if (dirp == NULL)
		return;
	while ((dp = readdir(dirp)) != NULL) {
		if (strcmp(dp->d_name, ".") == 0 ||
		    strcmp(dp->d_name, "..") == 0)
			continue;
		runner_process_message(env, dp->d_name);
	}
	closedir(dirp);
}

void
runner_process_message(struct smtpd *env, char *messageid)
{
	DIR *dirp = NULL;
	struct dirent *dp;
	char evppath[MAXPATHLEN];
	u_int16_t hval;

	hval = queue_hash(messageid);
	if (! bsnprintf(evppath, MAXPATHLEN, "%s/%d/%s%s", PATH_QUEUE, hval,
		messageid, PATH_ENVELOPES))
		fatal("runner_process_message: snprintf");
	dirp = opendir(evppath);
	if (dirp == NULL)
		return;
	while ((dp = readdir(dirp)) != NULL) {
		if (strcmp(dp->d_name, ".") == 0 ||
		    strcmp(dp->d_name, "..") == 0)
			continue;
		runner_process_envelope(env, dp->d_name, dp->d_name);
	}
	closedir(dirp);
}

void
runner_process_envelope(struct smtpd *env, char *msgid, char *evpid)
{
	struct message message;
	time_t tm;
a468 1
	u_int16_t hval;
a470 5
	if (! queue_load_envelope(&message, evpid))
		return;

	tm = time(NULL);

d472 2
a473 2
		message.flags &= ~(F_MESSAGE_SCHEDULED|F_MESSAGE_PROCESSING);
		queue_update_envelope(&message);
d476 1
a476 1
	if ((message.type & T_MDA_MESSAGE) && (env->sc_opts & SMTPD_MDA_PAUSED))
d479 2
a480 5
	if ((message.type & T_MTA_MESSAGE) && (env->sc_opts & SMTPD_MTA_PAUSED))
		return;

	if (! runner_message_schedule(&message, tm))
		return;
d482 3
a484 6
	message.flags |= F_MESSAGE_SCHEDULED;
	queue_update_envelope(&message);

	hval = queue_hash(msgid);
	if (! bsnprintf(evppath, MAXPATHLEN, "%s/%d/%s%s/%s", PATH_QUEUE, hval,
		msgid, PATH_ENVELOPES, evpid))
d487 2
a488 1
	if (! bsnprintf(rqpath, MAXPATHLEN, "%s/%s", PATH_RUNQUEUE, evpid))
d578 77
@


1.19
log
@- smtp can now pause/resume the accepting of incoming messages
- smtpctl recognizes "pause incoming" and "resume incoming"
- setup imsg communication between control process and smtp process
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.18 2009/01/04 22:18:23 gilles Exp $	*/
d805 10
a814 1
		runner_purge_message(dp->d_name);
@


1.18
log
@- remove runstates global, we don't need it actually.
- while at it, move the runner states check a bit earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.17 2009/01/04 20:52:06 gilles Exp $	*/
d126 1
a126 1
		case IMSG_RUNNER_PAUSE_MDA:
d129 1
a129 1
		case IMSG_RUNNER_PAUSE_MTA:
d132 1
a132 1
		case IMSG_RUNNER_RESUME_MDA:
d135 1
a135 1
		case IMSG_RUNNER_RESUME_MTA:
@


1.17
log
@make sure runner resets scheduling related flags on envelopes when the
queue is processed for the first time since a (re)start. this ensures
that deliveries scheduling can recover properly in case of a badly timed
shutdown.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.16 2009/01/04 19:37:41 gilles Exp $	*/
a74 3
#define	RUNNER_MDA	0x1
#define	RUNNER_MTA	0x2
u_int8_t runstates = RUNNER_MDA|RUNNER_MTA;
d127 1
a127 1
			runstates &= ~RUNNER_MDA;
d130 1
a130 1
			runstates &= ~RUNNER_MTA;
d133 1
a133 1
			runstates |= RUNNER_MDA;
d136 1
a136 1
			runstates |= RUNNER_MTA;
d539 6
a745 4
		return 0;

	if (((messagep->type & T_MDA_MESSAGE) && !(runstates & RUNNER_MDA)) ||
	    ((messagep->type & T_MTA_MESSAGE) && !(runstates & RUNNER_MTA)))
@


1.16
log
@- runner is now capable of pausing/resuming the scheduling of deliveries
for both mda and mta batches.
- smtpctl can be used to disable/enable deliveries at runtime using the
pause/resume commands.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.15 2009/01/04 19:26:30 jacekm Exp $	*/
d78 1
d442 1
d537 5
d741 1
a741 1
	
@


1.15
log
@remove unnecessary "messagep->retry == 255" expiry condition; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.14 2009/01/04 19:25:19 jacekm Exp $	*/
d75 4
d128 12
d736 4
@


1.14
log
@kill F_MESSAGE_EXPIRED; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.13 2009/01/04 19:23:06 jacekm Exp $	*/
a724 4
		return 0;
	}

	if (messagep->retry == 255) {
@


1.13
log
@fix bug where runner would expire message that is being delivered,
leading to double unlink on envelope file; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.12 2008/12/27 17:45:54 jacekm Exp $	*/
d519 1
a519 5
	if (! runner_message_schedule(&message, tm)) {
		if (message.flags & F_MESSAGE_EXPIRED) {
			log_debug("message has expired, mdaemon");
			queue_remove_envelope(&message);
		}
a520 1
	}
d724 1
a724 1
		messagep->flags |= F_MESSAGE_EXPIRED;
a728 1
		messagep->flags |= F_MESSAGE_EXPIRED;
@


1.12
log
@log_warn -> log_warnx
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.11 2008/12/27 17:36:37 jacekm Exp $	*/
d723 3
a736 6
	
	if ((messagep->flags & F_MESSAGE_SCHEDULED) != 0)
		return 0;

	if ((messagep->flags & F_MESSAGE_PROCESSING) != 0)
		return 0;
@


1.11
log
@cleanup; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.10 2008/12/27 17:03:29 jacekm Exp $	*/
d450 1
a450 1
			log_warn("runner_process_queue: invalid bucket: %s/%s",
@


1.10
log
@Merge hash() and queue_message_hash() into one func, queue_hash(). Fix callers
to use this interface consistently; ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.9 2008/12/19 00:39:05 gilles Exp $	*/
a74 4
int		queue_load_envelope(struct message *, char *);
int		queue_update_envelope(struct message *);
int		queue_remove_envelope(struct message *);

d443 1
a443 2
		fatal("queue_process: opendir");

a444 1

a447 1

d450 1
a450 1
			log_warn("queue_process: %s/%s is not a valid bucket",
a453 1

d467 1
a467 2
		fatal("queue_process_bucket: snprintf");

a470 1

a471 1

a474 1
		
a476 1

d486 1
a486 1
	u_int16_t hval = 0;
a488 1

d491 1
a491 2
		fatal("queue_process_message: snprintf");

a494 1

a495 1

a498 1

a500 1

d533 1
a533 1
		fatal("queue_process_envelope: snprintf");
d536 1
a536 1
		fatal("queue_process_envelope: snprintf");
d540 1
a540 1
			fatal("queue_process_envelope: stat");
d564 1
a564 1
		fatal("queue_process_runqueue: opendir");
d571 2
a572 1
		snprintf(pathname, MAXPATHLEN, "%s/%s", PATH_RUNQUEUE, dp->d_name);
d575 1
a575 1
		if (! queue_load_envelope(&message, dp->d_name)) {
a576 1
		}
@


1.9
log
@- smtpd handled mbox locking failures as "regular" temporary failures which
	is not good at all. As a result, under heavy load messages would be
	kept in queue, and delayed for hours just because we failed locking
	a few times. This commit makes smtpd distinguish between lock fails
	and "regular" temporary fails.
- delivery scheduler will reschedule immediately a message that couldn't be
	delivered because of a lock fail. If we fail to lock too many times
	we fallback to previous "delay increase" logic.

	"looks sane" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.8 2008/12/17 18:47:37 jacekm Exp $	*/
a78 2
u_int32_t	hash(u_int8_t *, size_t);

d501 1
a501 1
	hval = hash(messageid, strlen(messageid)) % DIRHASH_BUCKETS;
d549 1
a549 1
	hval = hash(msgid, strlen(msgid)) % DIRHASH_BUCKETS;
@


1.8
log
@Introduce /purge, where all msgs scheduled for deletion are put by
queue, and removed from disk by runner.

On startup, clean /incoming by moving msgs within it to /purge.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.7 2008/12/13 23:19:34 jacekm Exp $	*/
d768 3
a770 4
		if (messagep->retry < 5)
			return 1;

		if (messagep->retry < 15)
d772 8
@


1.7
log
@IMSG_* namespace cleanup.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.6 2008/12/11 22:59:14 gilles Exp $	*/
d69 3
d429 1
d789 74
@


1.6
log
@- snprintf -> bsnprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.5 2008/12/11 22:32:27 gilles Exp $	*/
d312 1
a312 1
		case IMSG_LKA_MX_LOOKUP: {
d721 1
a721 1
	imsg_compose(env->sc_ibufs[proctype], IMSG_CREATE_BATCH, 0, 0, -1,
d830 2
a831 2
			imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_LKA_MX_LOOKUP, 0, 0, -1,
			    batchp, sizeof(struct batch));
@


1.5
log
@- fix a bug that would cause the runner to hit a fatal() when running out
	of luck under load. Long story made short: the runner process opens
	the queue and sequentially opens each bucket to process messages.
	If a message is delivered by MDA/MTA after the opendir(), then the
	queue process will garbage collect the message from the queue and
	the runner will attempt to opendir() a path that no longer exists.

	Reported by Daniel Lidberg <daniel.lidberg@@gmail.com>, observed by
	jacekm@@ and debugged by me, that's collaborative work ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.4 2008/12/07 03:14:24 gilles Exp $	*/
a467 1
	int spret;
d472 1
a472 2
	spret = snprintf(bucketpath, MAXPATHLEN, "%s/%d", PATH_QUEUE, bucket);
	if (spret == -1 || spret >= MAXPATHLEN)
a493 1
	int spret;
d501 2
a502 3
	spret = snprintf(evppath, MAXPATHLEN, "%s/%d/%s%s", PATH_QUEUE, hval,
	    messageid, PATH_ENVELOPES);
	if (spret == -1 || spret >= MAXPATHLEN)
a523 1
	int spret;
d548 2
a549 3
	spret = snprintf(evppath, MAXPATHLEN, "%s/%d/%s%s/%s", PATH_QUEUE, hval,
	    msgid, PATH_ENVELOPES, evpid);
	if (spret == -1 || spret >= MAXPATHLEN)
d552 1
a552 2
	spret = snprintf(rqpath, MAXPATHLEN, "%s/%s", PATH_RUNQUEUE, evpid);
	if (spret == -1 || spret >= MAXPATHLEN)
@


1.4
log
@- getaddrinfo() uses negative values for its error defines, our use of an
	u_int8_t to hold the value leads to invalid checking in
	runner_batch_resolved(), this lead to a crash in MTA because we
	assumed a batch had its mx resolved when it had not. while at it,
	be more strict about errors we don't know and fatal(), it should
	not happen.

	ok jacekm@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.3 2008/12/07 01:55:41 gilles Exp $	*/
d479 1
a479 1
		fatal("queue_process_bucket: opendir");
d511 1
a511 1
		fatal("queue_process_message: opendir");
d536 1
a536 2
	if (! queue_load_envelope(&message, evpid)) {
		log_debug("failed to load envelope: %s", evpid);
a537 1
	}
a598 1
			log_debug("failed to load envelope");
@


1.3
log
@- fix function name in fatal()
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.2 2008/12/05 19:09:59 gilles Exp $	*/
d676 5
d712 1
a712 3
		batchp->flags |= F_BATCH_RESOLVED;
		for (i = 0; i < batchp->mx_cnt; ++i)
			batchp->mxarray[i].ss = lookup->mxarray[i].ss;
@


1.2
log
@- more err/errx -> fatal/fatalx, warn/warnx -> log_warn/log_warnx
	contains bits based on an old diff from Jacek Masiulaniec and
	other bits from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.1 2008/12/05 02:51:32 gilles Exp $	*/
d721 1
a721 1
		fatal("batch_send: unknown batch type");
@


1.1
log
@- last part of the new queue code: the runner process (unprivileged and
	chrooted) is now in charge of doing the scheduling of deliveries,
	and the dispatching of messages to MDA and MTA. queue process only
	does inserts/updates/removals from the queue and can no longer be
	so busy that it delays answers to imsg from smtp server.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a31 1
#include <err.h>
d615 1
a615 1
			err(1, "calloc");
d804 1
a804 1
			errx(1, "%s: internal inconsistency.", __func__);
d809 1
a809 1
			err(1, "%s: calloc", __func__);
@

