head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.27
date	2017.05.17.14.00.06;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	CQ2bJKe5Leh53ur4;

1.26
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.25;
commitid	jM4eOMW1AJwdfKrr;

1.25
date	2016.09.08.12.06.43;	author eric;	state Exp;
branches;
next	1.24;
commitid	LkfnyKFoItZAAepX;

1.24
date	2016.09.04.16.10.31;	author eric;	state Exp;
branches;
next	1.23;
commitid	I2r1xe6emhZl6xPg;

1.23
date	2016.09.01.10.54.25;	author eric;	state Exp;
branches;
next	1.22;
commitid	fYsbH2IujjKSME9c;

1.22
date	2016.05.28.21.21.20;	author eric;	state Exp;
branches;
next	1.21;
commitid	KhU4hSodVCiVoZ62;

1.21
date	2016.02.02.21.18.04;	author gilles;	state Exp;
branches;
next	1.20;
commitid	dQqiq0HEeT9fbcBX;

1.20
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.19;
commitid	ZxnqOQqX6IeYI9jW;

1.19
date	2015.12.05.13.14.21;	author claudio;	state Exp;
branches;
next	1.18;
commitid	ZUSyGL2qGrdiWU8r;

1.18
date	2015.11.05.12.35.58;	author jung;	state Exp;
branches;
next	1.17;
commitid	jasZAz9nQhjiEdTD;

1.17
date	2015.10.17.13.06.03;	author gilles;	state Exp;
branches;
next	1.16;
commitid	3XGmBci0leIdX0bl;

1.16
date	2015.10.14.21.05.31;	author gilles;	state Exp;
branches;
next	1.15;
commitid	JuYI9l0pfZuknXP8;

1.15
date	2015.10.13.08.07.35;	author gilles;	state Exp;
branches;
next	1.14;
commitid	rfXJuJy4Qa42pMp4;

1.14
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	ZBTFreARDSMmzOIV;

1.13
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	Uu5nFG3wCl0LACBb;

1.12
date	2014.12.24.08.43.58;	author eric;	state Exp;
branches;
next	1.11;
commitid	ALZI6KM22QjFu8pH;

1.11
date	2014.10.02.19.14.56;	author gilles;	state Exp;
branches;
next	1.10;
commitid	qiWANFv8jjiqFBTR;

1.10
date	2014.07.10.20.16.48;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mobxEvguwOilXuOk;

1.9
date	2014.07.10.15.54.55;	author eric;	state Exp;
branches;
next	1.8;
commitid	Uxz21DeZX3Z1gOVr;

1.8
date	2014.07.08.11.03.51;	author eric;	state Exp;
branches;
next	1.7;
commitid	QtJalKfmQfMA0Y0S;

1.7
date	2014.05.04.16.38.19;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2014.05.01.15.50.20;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.30.08.23.42;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.29.19.13.13;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.21.08.36.51;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.28.17.02.08;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Introduce more use of freezero().  Also, remove ptr conditionals before
many functions which are free(NULL)-compat
ok gilles
@
text
@/*	$OpenBSD: ca.c,v 1.26 2017/01/09 09:53:23 reyk Exp $	*/

/*
 * Copyright (c) 2014 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2012 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <err.h>
#include <imsg.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <openssl/ssl.h>
#include <openssl/pem.h>
#include <openssl/evp.h>
#include <openssl/rsa.h>
#include <openssl/engine.h>
#include <openssl/err.h>

#include "smtpd.h"
#include "log.h"
#include "ssl.h"

static int	 ca_verify_cb(int, X509_STORE_CTX *);

static int	 rsae_send_imsg(int, const unsigned char *, unsigned char *,
		    RSA *, int, unsigned int);
static int	 rsae_pub_enc(int, const unsigned char *, unsigned char *,
		    RSA *, int);
static int	 rsae_pub_dec(int,const unsigned char *, unsigned char *,
		    RSA *, int);
static int	 rsae_priv_enc(int, const unsigned char *, unsigned char *,
		    RSA *, int);
static int	 rsae_priv_dec(int, const unsigned char *, unsigned char *,
		    RSA *, int);
static int	 rsae_mod_exp(BIGNUM *, const BIGNUM *, RSA *, BN_CTX *);
static int	 rsae_bn_mod_exp(BIGNUM *, const BIGNUM *, const BIGNUM *,
		    const BIGNUM *, BN_CTX *, BN_MONT_CTX *);
static int	 rsae_init(RSA *);
static int	 rsae_finish(RSA *);
static int	 rsae_keygen(RSA *, int, BIGNUM *, BN_GENCB *);

static uint64_t	 rsae_reqid = 0;

static void
ca_shutdown(void)
{
	log_debug("debug: ca agent exiting");
	_exit(0);
}

int
ca(void)
{
	struct passwd	*pw;

	purge_config(PURGE_LISTENERS|PURGE_TABLES|PURGE_RULES);

	if ((pw = getpwnam(SMTPD_USER)) == NULL)
		fatalx("unknown user " SMTPD_USER);

	if (chroot(PATH_CHROOT) == -1)
		fatal("ca: chroot");
	if (chdir("/") == -1)
		fatal("ca: chdir(\"/\")");

	config_process(PROC_CA);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("ca: cannot drop privileges");

	imsg_callback = ca_imsg;
	event_init();

	signal(SIGINT, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	config_peer(PROC_CONTROL);
	config_peer(PROC_PARENT);
	config_peer(PROC_PONY);

	/* Ignore them until we get our config */
	mproc_disable(p_pony);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	event_dispatch();
	fatalx("exited event loop");

	return (0);
}

void
ca_init(void)
{
	BIO		*in = NULL;
	EVP_PKEY	*pkey = NULL;
	struct pki	*pki;
	const char	*k;
	void		*iter_dict;

	log_debug("debug: init private ssl-tree");
	iter_dict = NULL;
	while (dict_iter(env->sc_pki_dict, &iter_dict, &k, (void **)&pki)) {
		if (pki->pki_key == NULL)
			continue;

		if ((in = BIO_new_mem_buf(pki->pki_key,
		    pki->pki_key_len)) == NULL)
			fatalx("ca_launch: key");

		if ((pkey = PEM_read_bio_PrivateKey(in,
		    NULL, NULL, NULL)) == NULL)
			fatalx("ca_launch: PEM");
		BIO_free(in);

		pki->pki_pkey = pkey;

		freezero(pki->pki_key, pki->pki_key_len);
		pki->pki_key = NULL;
	}
}

static int
ca_verify_cb(int ok, X509_STORE_CTX *ctx)
{
	switch (X509_STORE_CTX_get_error(ctx)) {
	case X509_V_OK:
		break;
        case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
		break;
        case X509_V_ERR_CERT_NOT_YET_VALID:
        case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:
		break;
        case X509_V_ERR_CERT_HAS_EXPIRED:
        case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:
		break;
        case X509_V_ERR_NO_EXPLICIT_POLICY:
		break;
	}
	return ok;
}

int
ca_X509_verify(void *certificate, void *chain, const char *CAfile,
    const char *CRLfile, const char **errstr)
{
	X509_STORE     *store = NULL;
	X509_STORE_CTX *xsc = NULL;
	int		ret = 0;

	if ((store = X509_STORE_new()) == NULL)
		goto end;

	if (!X509_STORE_load_locations(store, CAfile, NULL)) {
		log_warn("warn: unable to load CA file %s", CAfile);
		goto end;
	}
	X509_STORE_set_default_paths(store);

	if ((xsc = X509_STORE_CTX_new()) == NULL)
		goto end;

	if (X509_STORE_CTX_init(xsc, store, certificate, chain) != 1)
		goto end;

	X509_STORE_CTX_set_verify_cb(xsc, ca_verify_cb);

	ret = X509_verify_cert(xsc);

end:
	*errstr = NULL;
	if (ret != 1) {
		if (xsc)
			*errstr = X509_verify_cert_error_string(xsc->error);
		else if (ERR_peek_last_error())
			*errstr = ERR_error_string(ERR_peek_last_error(), NULL);
	}

	X509_STORE_CTX_free(xsc);
	X509_STORE_free(store);

	return ret > 0 ? 1 : 0;
}

void
ca_imsg(struct mproc *p, struct imsg *imsg)
{
	RSA			*rsa;
	const void		*from = NULL;
	unsigned char		*to = NULL;
	struct msg		 m;
	const char		*pkiname;
	size_t			 flen, tlen, padding;
	struct pki		*pki;
	int			 ret = 0;
	uint64_t		 id;
	int			 v;

	if (imsg == NULL)
		ca_shutdown();

	if (p->proc == PROC_PARENT) {
		switch (imsg->hdr.type) {
		case IMSG_CONF_START:
			return;
		case IMSG_CONF_END:
			ca_init();

			/* Start fulfilling requests */
			mproc_enable(p_pony);
			return;
		}
	}

	if (p->proc == PROC_CONTROL) {
		switch (imsg->hdr.type) {
		case IMSG_CTL_VERBOSE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			log_trace_verbose(v);
			return;
		case IMSG_CTL_PROFILE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			profiling = v;
			return;
		}
	}

	if (p->proc == PROC_PONY) {
		switch (imsg->hdr.type) {
		case IMSG_CA_PRIVENC:
		case IMSG_CA_PRIVDEC:
			m_msg(&m, imsg);
			m_get_id(&m, &id);
			m_get_string(&m, &pkiname);
			m_get_data(&m, &from, &flen);
			m_get_size(&m, &tlen);
			m_get_size(&m, &padding);
			m_end(&m);

			pki = dict_get(env->sc_pki_dict, pkiname);
			if (pki == NULL || pki->pki_pkey == NULL ||
			    (rsa = EVP_PKEY_get1_RSA(pki->pki_pkey)) == NULL)
				fatalx("ca_imsg: invalid pki");

			if ((to = calloc(1, tlen)) == NULL)
				fatalx("ca_imsg: calloc");

			switch (imsg->hdr.type) {
			case IMSG_CA_PRIVENC:
				ret = RSA_private_encrypt(flen, from, to, rsa,
				    padding);
				break;
			case IMSG_CA_PRIVDEC:
				ret = RSA_private_decrypt(flen, from, to, rsa,
				    padding);
				break;
			}

			m_create(p, imsg->hdr.type, 0, 0, -1);
			m_add_id(p, id);
			m_add_int(p, ret);
			if (ret > 0)
				m_add_data(p, to, (size_t)ret);
			m_close(p);

			free(to);
			RSA_free(rsa);

			return;
		}
	}

	errx(1, "ca_imsg: unexpected %s imsg", imsg_to_str(imsg->hdr.type));
}

/*
 * RSA privsep engine (called from unprivileged processes)
 */

const RSA_METHOD *rsa_default = NULL;

static RSA_METHOD rsae_method = {
	"RSA privsep engine",
	rsae_pub_enc,
	rsae_pub_dec,
	rsae_priv_enc,
	rsae_priv_dec,
	rsae_mod_exp,
	rsae_bn_mod_exp,
	rsae_init,
	rsae_finish,
	0,
	NULL,
	NULL,
	NULL,
	rsae_keygen
};

static int
rsae_send_imsg(int flen, const unsigned char *from, unsigned char *to,
    RSA *rsa, int padding, unsigned int cmd)
{
	int		 ret = 0;
	struct imsgbuf	*ibuf;
	struct imsg	 imsg;
	int		 n, done = 0;
	const void	*toptr;
	char		*pkiname;
	size_t		 tlen;
	struct msg	 m;
	uint64_t	 id;

	if ((pkiname = RSA_get_ex_data(rsa, 0)) == NULL)
		return (0);

	/*
	 * Send a synchronous imsg because we cannot defer the RSA
	 * operation in OpenSSL's engine layer.
	 */
	m_create(p_ca, cmd, 0, 0, -1);
	rsae_reqid++;
	m_add_id(p_ca, rsae_reqid);
	m_add_string(p_ca, pkiname);
	m_add_data(p_ca, (const void *)from, (size_t)flen);
	m_add_size(p_ca, (size_t)RSA_size(rsa));
	m_add_size(p_ca, (size_t)padding);
	m_flush(p_ca);

	ibuf = &p_ca->imsgbuf;

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatalx("imsg_read");
		if (n == 0)
			fatalx("pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				fatalx("imsg_get error");
			if (n == 0)
				break;

			log_imsg(PROC_PONY, PROC_CA, &imsg);

			switch (imsg.hdr.type) {
			case IMSG_CA_PRIVENC:
			case IMSG_CA_PRIVDEC:
				break;
			default:
				/* Another imsg is queued up in the buffer */
				pony_imsg(p_ca, &imsg);
				imsg_free(&imsg);
				continue;
			}

			m_msg(&m, &imsg);
			m_get_id(&m, &id);
			if (id != rsae_reqid)
				fatalx("invalid response id");
			m_get_int(&m, &ret);
			if (ret > 0)
				m_get_data(&m, &toptr, &tlen);
			m_end(&m);

			if (ret > 0)
				memcpy(to, toptr, tlen);
			done = 1;

			imsg_free(&imsg);
		}
	}
	mproc_event_add(p_ca);

	return (ret);
}

static int
rsae_pub_enc(int flen,const unsigned char *from, unsigned char *to, RSA *rsa,
    int padding)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	return (rsa_default->rsa_pub_enc(flen, from, to, rsa, padding));
}

static int
rsae_pub_dec(int flen,const unsigned char *from, unsigned char *to, RSA *rsa,
    int padding)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	return (rsa_default->rsa_pub_dec(flen, from, to, rsa, padding));
}

static int
rsae_priv_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa,
    int padding)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	if (RSA_get_ex_data(rsa, 0) != NULL) {
		return (rsae_send_imsg(flen, from, to, rsa, padding,
		    IMSG_CA_PRIVENC));
	}
	return (rsa_default->rsa_priv_enc(flen, from, to, rsa, padding));
}

static int
rsae_priv_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa,
    int padding)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	if (RSA_get_ex_data(rsa, 0) != NULL) {
		return (rsae_send_imsg(flen, from, to, rsa, padding,
		    IMSG_CA_PRIVDEC));
	}
	return (rsa_default->rsa_priv_dec(flen, from, to, rsa, padding));
}

static int
rsae_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	return (rsa_default->rsa_mod_exp(r0, I, rsa, ctx));
}

static int
rsae_bn_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	return (rsa_default->bn_mod_exp(r, a, p, m, ctx, m_ctx));
}

static int
rsae_init(RSA *rsa)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	if (rsa_default->init == NULL)
		return (1);
	return (rsa_default->init(rsa));
}

static int
rsae_finish(RSA *rsa)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	if (rsa_default->finish == NULL)
		return (1);
	return (rsa_default->finish(rsa));
}

static int
rsae_keygen(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	return (rsa_default->rsa_keygen(rsa, bits, e, cb));
}

void
ca_engine_init(void)
{
	ENGINE		*e;
	const char	*errstr, *name;

	if ((e = ENGINE_get_default_RSA()) == NULL) {
		if ((e = ENGINE_new()) == NULL) {
			errstr = "ENGINE_new";
			goto fail;
		}
		if (!ENGINE_set_name(e, rsae_method.name)) {
			errstr = "ENGINE_set_name";
			goto fail;
		}
		if ((rsa_default = RSA_get_default_method()) == NULL) {
			errstr = "RSA_get_default_method";
			goto fail;
		}
	} else if ((rsa_default = ENGINE_get_RSA(e)) == NULL) {
		errstr = "ENGINE_get_RSA";
		goto fail;
	}

	if ((name = ENGINE_get_name(e)) == NULL)
		name = "unknown RSA engine";

	log_debug("debug: %s: using %s", __func__, name);

	if (rsa_default->flags & RSA_FLAG_SIGN_VER)
		fatalx("unsupported RSA engine");

	if (rsa_default->rsa_mod_exp == NULL)
		rsae_method.rsa_mod_exp = NULL;
	if (rsa_default->bn_mod_exp == NULL)
		rsae_method.bn_mod_exp = NULL;
	if (rsa_default->rsa_keygen == NULL)
		rsae_method.rsa_keygen = NULL;
	rsae_method.flags = rsa_default->flags |
	    RSA_METHOD_FLAG_NO_CHECK;
	rsae_method.app_data = rsa_default->app_data;

	if (!ENGINE_set_RSA(e, &rsae_method)) {
		errstr = "ENGINE_set_RSA";
		goto fail;
	}
	if (!ENGINE_set_default_RSA(e)) {
		errstr = "ENGINE_set_default_RSA";
		goto fail;
	}

	return;

 fail:
	ssl_error(errstr);
	fatalx("%s", errstr);
}
@


1.26
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.25 2016/09/08 12:06:43 eric Exp $	*/
d145 1
a145 2
		explicit_bzero(pki->pki_key, pki->pki_key_len);
		free(pki->pki_key);
d206 2
a207 4
	if (xsc)
		X509_STORE_CTX_free(xsc);
	if (store)
		X509_STORE_free(store);
@


1.25
log
@Streamline the daemon shutdown sequence.

Only the parent process handles SIGTERM and SIGINT.  Upon receiving one
of those, it closes all imsg sockets and waitpid() for the children. It
fatal()s if one of the sockets is closed unexpectedly.  Other processes
exit() "normally" when one of the imsg sockets is closed.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.24 2016/09/04 16:10:31 eric Exp $	*/
d251 1
a251 1
			log_verbose(v);
@


1.24
log
@The smtpd processes are not expected to ever leave their event loop.
So stop pretending that the *_shutdown() functions could ever be called
in this context, and just fatal() if event_dispatch() returns.

ok gilles@@ sunil@@ giovanni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.23 2016/09/01 10:54:25 eric Exp $	*/
d69 1
a69 1
	log_info("info: ca agent exiting");
a72 13
static void
ca_sig_handler(int sig, short event, void *p)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		ca_shutdown();
		break;
	default:
		fatalx("ca_sig_handler: unexpected signal");
	}
}

a76 2
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
d98 2
a99 4
	signal_set(&ev_sigint, SIGINT, ca_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, ca_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
d228 3
@


1.23
log
@remove noop function

ok sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.22 2016/05/28 21:21:20 eric Exp $	*/
d130 2
a131 3
	if (event_dispatch() < 0)
		fatal("event_dispatch");
	ca_shutdown();
@


1.22
log
@Implement the fork+exec pattern in smtpd.

The parent process forks child processes and re-exec each of them with
an additional "-x <proc>" argument.  During the early setup phase, the
parent process sends ipc socket pairs to interconnect the child
processes as needed, and it passes the queue encryption key to the
queue if necessary. When this is done, all processes have their
environment set as in the fork-only case, and they can start doing
their work as before.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.21 2016/02/02 21:18:04 gilles Exp $	*/
a122 1
	config_done();
@


1.21
log
@in RSA privsep engine, do not provide methods for rsa_sign / rsa_verify,
they are unused in OpenSMTPD and lead to crashes in -portable when we're
linked to OpenSSL starting with 1.0.2f

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.20 2015/12/28 22:08:30 jung Exp $	*/
d86 1
a86 1
pid_t
a88 1
	pid_t		 pid;
a91 10

	switch (pid = fork()) {
	case -1:
		fatal("ca: cannot fork");
	case 0:
		post_fork(PROC_CA);
		break;
	default:
		return (pid);
	}
@


1.20
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.19 2015/12/05 13:14:21 claudio Exp $	*/
a61 4
static int	 rsae_sign(int, const unsigned char *, unsigned int,
		    unsigned char *, unsigned int *, const RSA *);
static int	 rsae_verify(int dtype, const unsigned char *m, unsigned int,
		    const unsigned char *, unsigned int, const RSA *);
d355 2
a356 2
	rsae_sign,
	rsae_verify,
a508 18
}

static int
rsae_sign(int type, const unsigned char *m, unsigned int m_length,
    unsigned char *sigret, unsigned int *siglen, const RSA *rsa)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	return (rsa_default->rsa_sign(type, m, m_length,
	    sigret, siglen, rsa));
}

static int
rsae_verify(int dtype, const unsigned char *m, unsigned int m_length,
    const unsigned char *sigbuf, unsigned int siglen, const RSA *rsa)
{
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
	return (rsa_default->rsa_verify(dtype, m, m_length,
	    sigbuf, siglen, rsa));
@


1.19
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.18 2015/11/05 12:35:58 jung Exp $	*/
d216 1
a216 1
	if (! X509_STORE_load_locations(store, CAfile, NULL)) {
@


1.18
log
@replace u_char and u_int* with standard stdint.h types to ease portable version
also remove trailing whitespaces while here

no binary change

ok sunil millert gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.17 2015/10/17 13:06:03 gilles Exp $	*/
d397 1
a397 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.16 2015/10/14 21:05:31 gilles Exp $	*/
d47 10
a56 6
static int	 rsae_send_imsg(int, const u_char *, u_char *, RSA *,
		    int, u_int);
static int	 rsae_pub_enc(int, const u_char *, u_char *, RSA *, int);
static int	 rsae_pub_dec(int,const u_char *, u_char *, RSA *, int);
static int	 rsae_priv_enc(int, const u_char *, u_char *, RSA *, int);
static int	 rsae_priv_dec(int, const u_char *, u_char *, RSA *, int);
d62 4
a65 4
static int	 rsae_sign(int, const u_char *, u_int, u_char *, u_int *,
		    const RSA *);
static int	 rsae_verify(int dtype, const u_char *m, u_int, const u_char *,
		    u_int, const RSA *);
d254 1
a254 1
	u_char			 *to = NULL;
d365 2
a366 2
rsae_send_imsg(int flen, const u_char *from, u_char *to, RSA *rsa,
    int padding, u_int cmd)
d443 2
a444 1
rsae_pub_enc(int flen,const u_char *from, u_char *to, RSA *rsa,int padding)
d451 2
a452 1
rsae_pub_dec(int flen,const u_char *from, u_char *to, RSA *rsa,int padding)
d459 2
a460 1
rsae_priv_enc(int flen, const u_char *from, u_char *to, RSA *rsa, int padding)
d471 2
a472 1
rsae_priv_dec(int flen, const u_char *from, u_char *to, RSA *rsa, int padding)
d516 2
a517 2
rsae_sign(int type, const u_char *m, u_int m_length, u_char *sigret,
    u_int *siglen, const RSA *rsa)
d525 2
a526 2
rsae_verify(int dtype, const u_char *m, u_int m_length, const u_char *sigbuf,
    u_int siglen, const RSA *rsa)
@


1.16
log
@remove a handful of log_warn that we should handle at a different place to
make them really useful
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.15 2015/10/13 08:07:35 gilles Exp $	*/
d25 4
d30 1
a31 2
#include <limits.h>
#include <stdlib.h>
a32 4
#include <limits.h>
#include <imsg.h>
#include <pwd.h>
#include <err.h>
@


1.15
log
@pledge("stdio") the RSA-privsep process
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.14 2015/01/20 17:37:54 deraadt Exp $	*/
a188 1
		log_warnx("warn: unable to get issuer cert");
a191 1
		log_warnx("warn: certificate not yet valid");
a194 1
		log_warnx("warn: certificate has expired");
a196 1
		log_warnx("warn: no explicit policy");
@


1.14
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.13 2015/01/16 06:40:20 deraadt Exp $	*/
d139 3
@


1.13
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.12 2014/12/24 08:43:58 eric Exp $	*/
d23 1
d30 1
@


1.12
log
@missing include
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.11 2014/10/02 19:14:56 gilles Exp $	*/
d26 1
@


1.11
log
@no need to set the same field NULL twice ;-)

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.10 2014/07/10 20:16:48 jsg Exp $	*/
d24 1
@


1.10
log
@add additional includes required to build with -DOPENSSL_NO_DEPRECATED
ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.9 2014/07/10 15:54:55 eric Exp $	*/
a561 2
	if (rsa_default->rsa_mod_exp == NULL)
		rsae_method.rsa_mod_exp = NULL;
@


1.9
log
@make the control process broadcast verbose/profile admin requests directly,
rather than going through the parent process. simplify code in the meantime.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.7 2014/04/22 08:04:23 reyk Exp $	*/
d36 1
@


1.8
log
@fatalx(errorstr) -> fatalx("%s", errorstr)
add missing include and remove redundant debug trace while here.
@
text
@d127 1
d266 5
@


1.7
log
@Create a new default RSA engine instead of patching the existing one
if none is available.  Fixes SSL/TLS and a possible fatalx() on
machines without a default RSA engine.

Thanks to Bjorn Ketelaars for reporting and testing.

ok gilles@@ (for the relayd part)
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.6 2014/05/01 15:50:20 reyk Exp $	*/
d31 1
a254 2
	log_imsg(smtpd_process, p->proc, imsg);

d580 1
a580 1
	fatalx(errstr);
@


1.6
log
@Move RSA keys from "lka" to a new dedicated "ca" process because lka
is handling some async requests and shouldn't be busy with sync RSA.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.5 2014/04/30 08:23:42 reyk Exp $	*/
d524 1
a524 1
int
d527 20
a546 1
	ENGINE	*e;
d548 2
a549 1
	log_debug("debug: %s: %s", proc_name(smtpd_process), __func__);
d551 1
a551 3
	if ((e = ENGINE_get_default_RSA()) == NULL ||
	    (rsa_default = ENGINE_get_RSA(e)) == NULL)
		return (-1);
d568 10
a577 3
	if (!ENGINE_set_RSA(e, &rsae_method) ||
	    !ENGINE_set_default_RSA(e))
		return (-1);
d579 3
a581 1
	return (0);
@


1.5
log
@The RSA engine (used by pony) has to wait for a response from the
privileged process (lka) and receive the imsgs in a while loop
synchronously.  But the lka also sends other imsgs (DNS etc.) that can
still be queued up in the buffer when waiting for the RSA response.
This only happens under load with many concurrent connections.  For
now, we just call the pony imsg handler for non-RSA imsgs that are
already in the buffer.

ok gilles@@ eric@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.4 2014/04/29 19:13:13 reyk Exp $	*/
d26 1
d28 2
d61 79
d252 3
d256 23
a278 25
	m_msg(&m, imsg);
	m_get_id(&m, &id);
	m_get_string(&m, &pkiname);
	m_get_data(&m, &from, &flen);
	m_get_size(&m, &tlen);
	m_get_size(&m, &padding);
	m_end(&m);

	pki = dict_get(env->sc_pki_dict, pkiname);
	if (pki == NULL || pki->pki_pkey == NULL ||
	    (rsa = EVP_PKEY_get1_RSA(pki->pki_pkey)) == NULL)
		fatalx("ca_imsg: invalid pki");

	if ((to = calloc(1, tlen)) == NULL)
		fatalx("ca_imsg: calloc");

	switch (imsg->hdr.type) {
	case IMSG_CA_PRIVENC:
		ret = RSA_private_encrypt(flen, from, to, rsa,
		    padding);
		break;
	case IMSG_CA_PRIVDEC:
		ret = RSA_private_decrypt(flen, from, to, rsa,
		    padding);
		break;
d281 44
a324 6
	m_create(p, imsg->hdr.type, 0, 0, -1);
	m_add_id(p, id);
	m_add_int(p, ret);
	if (ret > 0)
		m_add_data(p, to, (size_t)ret);
	m_close(p);
d326 1
a326 2
	free(to);
	RSA_free(rsa);
d373 1
a373 1
	m_create(p_lka, cmd, 0, 0, -1);
d375 6
a380 6
	m_add_id(p_lka, rsae_reqid);
	m_add_string(p_lka, pkiname);
	m_add_data(p_lka, (const void *)from, (size_t)flen);
	m_add_size(p_lka, (size_t)RSA_size(rsa));
	m_add_size(p_lka, (size_t)padding);
	m_flush(p_lka);
d382 1
a382 1
	ibuf = &p_lka->imsgbuf;
d396 1
a396 1
			log_imsg(PROC_PONY, PROC_LKA, &imsg);
d404 1
a404 1
				pony_imsg(p_lka, &imsg);
d425 1
a425 1
	mproc_event_add(p_lka);
@


1.4
log
@Implement RSA privilege separation for OpenSMTPD, based on my previous
implementation for relayd(8).  The smtpd(8) pony processes (mta
client, smtp server) don't keep the private keys in memory but send
their private key operations as imsgs to the "lookup"/mta process.
It's worth mentioning that this prevents acidental private key leakage
as it could have been caused by "Heartbleed".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.7 2014/04/22 08:04:23 reyk Exp $	*/
d56 2
d169 1
d172 1
d199 1
d244 1
d254 2
d275 13
a287 2
			if (imsg.hdr.type != cmd)
				fatalx("invalid response");
d290 3
@


1.3
log
@fail if lka can't load cert file
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
d21 2
d24 8
a31 2
#include <openssl/err.h>
#include <openssl/ssl.h>
d33 1
d35 1
d37 50
a86 1
int	ca_X509_verify(X509 *, STACK_OF(X509) *, const char *, const char *, const char **);
d89 1
a89 1
verify_cb(int ok, X509_STORE_CTX *ctx)
d113 1
a113 1
ca_X509_verify(X509 *certificate, STACK_OF(X509) *chain, const char *CAfile,
d135 1
a135 1
	X509_STORE_CTX_set_verify_cb(xsc, verify_cb);
d154 259
@


1.2
log
@Report the ssl certificate verification status in the mail header.
Log ssl certificate validation errors.
Fix several ssl-related leaks.
@
text
@d63 4
a66 1
	X509_STORE_load_locations(store, CAfile, NULL);
@


1.1
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d24 2
d28 24
d71 2
@

