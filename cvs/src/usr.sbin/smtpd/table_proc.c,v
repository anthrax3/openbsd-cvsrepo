head	1.6;
access;
symbols
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.8
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.6
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.05.13.14.21;	author claudio;	state Exp;
branches;
next	1.5;
commitid	ZUSyGL2qGrdiWU8r;

1.5
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	ZBTFreARDSMmzOIV;

1.4
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	Uu5nFG3wCl0LACBb;

1.3
date	2014.07.08.13.49.09;	author eric;	state Exp;
branches;
next	1.2;
commitid	pEybL9fsrDOC6PJj;

1.2
date	2014.02.04.13.55.34;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2013.07.19.19.53.33;	author eric;	state Exp;
branches;
next	;


desc
@@


1.6
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@/*	$OpenBSD: table_proc.c,v 1.5 2015/01/20 17:37:54 deraadt Exp $	*/

/*
 * Copyright (c) 2013 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>

#include <ctype.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

struct table_proc_priv {
	pid_t		pid;
	struct imsgbuf	ibuf;
};

static struct imsg	 imsg;
static size_t		 rlen;
static char		*rdata;

extern char	**environ;

static void
table_proc_call(struct table_proc_priv *p)
{
	ssize_t	n;

	if (imsg_flush(&p->ibuf) == -1) {
		log_warn("warn: table-proc: imsg_flush");
		fatalx("table-proc: exiting");
	}

	while (1) {
		if ((n = imsg_get(&p->ibuf, &imsg)) == -1) {
			log_warn("warn: table-proc: imsg_get");
			break;
		}
		if (n) {
			rlen = imsg.hdr.len - IMSG_HEADER_SIZE;
			rdata = imsg.data;

			if (imsg.hdr.type != PROC_TABLE_OK) {
				log_warnx("warn: table-proc: bad response");
				break;
			}
			return;
		}

		if ((n = imsg_read(&p->ibuf)) == -1 && errno != EAGAIN) {
			log_warn("warn: table-proc: imsg_read");
			break;
		}

		if (n == 0) {
			log_warnx("warn: table-proc: pipe closed");
			break;
		}
	}

	fatalx("table-proc: exiting");
}

static void
table_proc_read(void *dst, size_t len)
{
	if (len > rlen) {
		log_warnx("warn: table-proc: bad msg len");
		fatalx("table-proc: exiting");
	}

	if (dst)
		memmove(dst, rdata, len);

	rlen -= len;
	rdata += len;
}

static void
table_proc_end(void)
{
	if (rlen) {
		log_warnx("warn: table-proc: bogus data");
		fatalx("table-proc: exiting");
	}
	imsg_free(&imsg);
}

/*
 * API
 */

static void *
table_proc_open(struct table *table)
{
	struct table_proc_priv	*priv;
	struct table_open_params op;
	int			 fd;

	priv = xcalloc(1, sizeof(*priv), "table_proc_open");

	fd = fork_proc_backend("table", table->t_config, table->t_name);
	if (fd == -1)
		fatalx("table-proc: exiting");

	imsg_init(&priv->ibuf, fd);

	memset(&op, 0, sizeof op);
	op.version = PROC_TABLE_API_VERSION;
	(void)strlcpy(op.name, table->t_name, sizeof op.name);
	imsg_compose(&priv->ibuf, PROC_TABLE_OPEN, 0, 0, -1, &op, sizeof op);

	table_proc_call(priv);
	table_proc_end();

	return (priv);
}

static int
table_proc_update(struct table *table)
{
	struct table_proc_priv	*priv = table->t_handle;
	int r;

	imsg_compose(&priv->ibuf, PROC_TABLE_UPDATE, 0, 0, -1, NULL, 0);

	table_proc_call(priv);
	table_proc_read(&r, sizeof(r));
	table_proc_end();

	return (r);
}

static void
table_proc_close(void *arg)
{
	struct table_proc_priv	*priv = arg;

	imsg_compose(&priv->ibuf, PROC_TABLE_CLOSE, 0, 0, -1, NULL, 0);
	imsg_flush(&priv->ibuf);
}

static int
imsg_add_params(struct ibuf *buf, struct dict *params)
{
	size_t count;
	const char *key;
	char *value;
	void *iter;

	count = 0;
	if (params)
		count = dict_count(params);

	if (imsg_add(buf, &count, sizeof(count)) == -1)
		return (-1);

	if (count == 0)
		return (0);

	iter = NULL;
	while (dict_iter(params, &iter, &key, (void **)&value)) {
		if (imsg_add(buf, key, strlen(key) + 1) == -1)
			return (-1);
		if (imsg_add(buf, value, strlen(value) + 1) == -1)
			return (-1);
	}

	return (0);
}

static int
table_proc_lookup(void *arg, struct dict *params, const char *k, enum table_service s,
    union lookup *lk)
{
	struct table_proc_priv	*priv = arg;
	struct ibuf		*buf;
	int			 r;

	buf = imsg_create(&priv->ibuf,
	    lk ? PROC_TABLE_LOOKUP : PROC_TABLE_CHECK, 0, 0,
	    sizeof(s) + strlen(k) + 1);

	if (buf == NULL)
		return (-1);
	if (imsg_add(buf, &s, sizeof(s)) == -1)
		return (-1);
	if (imsg_add_params(buf, params) == -1)
		return (-1);
	if (imsg_add(buf, k, strlen(k) + 1) == -1)
		return (-1);
	imsg_close(&priv->ibuf, buf);

	table_proc_call(priv);
	table_proc_read(&r, sizeof(r));

	if (r == 1 && lk) {
		if (rlen == 0) {
			log_warnx("warn: table-proc: empty response");
			fatalx("table-proc: exiting");
		}
		if (rdata[rlen - 1] != '\0') {
			log_warnx("warn: table-proc: not NUL-terminated");
			fatalx("table-proc: exiting");
		}
		r = table_parse_lookup(s, k, rdata, lk);
		table_proc_read(NULL, rlen);
	}

	table_proc_end();

	return (r);
}

static int
table_proc_fetch(void *arg, struct dict *params, enum table_service s, union lookup *lk)
{
	struct table_proc_priv	*priv = arg;
	struct ibuf		*buf;
	int			 r;

	buf = imsg_create(&priv->ibuf, PROC_TABLE_FETCH, 0, 0, sizeof(s));
	if (buf == NULL)
		return (-1);
	if (imsg_add(buf, &s, sizeof(s)) == -1)
		return (-1);
	if (imsg_add_params(buf, params) == -1)
		return (-1);
	imsg_close(&priv->ibuf, buf);

	table_proc_call(priv);
	table_proc_read(&r, sizeof(r));

	if (r == 1) {
		if (rlen == 0) {
			log_warnx("warn: table-proc: empty response");
			fatalx("table-proc: exiting");
		}
		if (rdata[rlen - 1] != '\0') {
			log_warnx("warn: table-proc: not NUL-terminated");
			fatalx("table-proc: exiting");
		}
		r = table_parse_lookup(s, NULL, rdata, lk);
		table_proc_read(NULL, rlen);
	}

	table_proc_end();

	return (r);
}

struct table_backend table_backend_proc = {
	K_ANY,
	NULL,
	table_proc_open,
	table_proc_update,
	table_proc_close,
	table_proc_lookup,
	table_proc_fetch,
};
@


1.5
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: table_proc.c,v 1.4 2015/01/16 06:40:21 deraadt Exp $	*/
d76 1
a76 1
		if ((n = imsg_read(&p->ibuf)) == -1) {
@


1.4
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: table_proc.c,v 1.3 2014/07/08 13:49:09 eric Exp $	*/
d33 1
@


1.3
log
@Update the table API: lookup functions can take an optional parameters
dictionnary (currently not set). While there, add a helper for forking
external backends, and remove unused table functions.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a21 1
#include <sys/param.h>
@


1.2
log
@socketmap table backend.
@
text
@a121 1
	int			 sp[2];
a122 1
	char			*environ_new[2];
d124 1
a125 6
	errno = 0;

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, sp) < 0) {
		log_warn("warn: table-proc: socketpair");
		return (NULL);
	}
d128 3
a130 18
	if ((priv->pid = fork()) == -1) {
		log_warn("warn: table-proc: fork");
		goto err;
	}

	if (priv->pid == 0) {
		/* child process */
		dup2(sp[0], STDIN_FILENO);
		if (closefrom(STDERR_FILENO + 1) < 0)
			exit(1);

		environ_new[0] = "PATH=" _PATH_DEFPATH;
		environ_new[1] = (char *)NULL;
		environ = environ_new;
		execle("/bin/sh", "/bin/sh", "-c", table->t_config, (char *)NULL,
		    environ_new);
		fatal("execl");
	}
d132 1
a132 3
	/* parent process */
	close(sp[0]);
	imsg_init(&priv->ibuf, sp[1]);
a142 5
err:
	free(priv);
	close(sp[0]);
	close(sp[1]);
	return (NULL);
d170 30
a199 1
table_proc_lookup(void *arg, const char *k, enum table_service s,
d214 2
d242 1
a242 1
table_proc_fetch(void *arg, enum table_service s, union lookup *lk)
d252 2
@


1.1
log
@Add a table_proc backend for delegating table lookups to another
process.  Stop building experimental table_sqlite and table_ldap as
they will be provided as external backends.
@
text
@a122 1
	uint32_t		 version;
d125 1
d133 1
a133 1
	priv = calloc(1, sizeof(*priv));
d158 4
a161 3
	version = PROC_TABLE_API_VERSION;
	imsg_compose(&priv->ibuf, PROC_TABLE_OPEN, 0, 0, -1,
	    &version, sizeof(version));
@

