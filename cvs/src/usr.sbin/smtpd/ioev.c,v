head	1.41;
access;
symbols
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.16.0.2
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2;
locks; strict;
comment	@ * @;


1.41
date	2017.05.17.14.00.06;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	CQ2bJKe5Leh53ur4;

1.40
date	2016.12.03.15.46.33;	author eric;	state Exp;
branches;
next	1.39;
commitid	yPPL7RLvXaJP0xcR;

1.39
date	2016.11.30.17.43.32;	author eric;	state Exp;
branches;
next	1.38;
commitid	12DZR8Z2gR4qMwKF;

1.38
date	2016.11.30.11.52.48;	author eric;	state Exp;
branches;
next	1.37;
commitid	HLHuvF4EZizEJJ0M;

1.37
date	2016.11.25.16.17.41;	author eric;	state Exp;
branches;
next	1.36;
commitid	UPWxMMXcsa6NOUmP;

1.36
date	2016.11.24.21.25.21;	author eric;	state Exp;
branches;
next	1.35;
commitid	85eBrsNLf8b4heK8;

1.35
date	2016.11.24.20.52.13;	author eric;	state Exp;
branches;
next	1.34;
commitid	UvPJmlWnlqtYXKpn;

1.34
date	2016.11.24.20.44.04;	author eric;	state Exp;
branches;
next	1.33;
commitid	NUNgQusDh5a3bpBi;

1.33
date	2016.11.24.12.58.27;	author eric;	state Exp;
branches;
next	1.32;
commitid	5gZmKKc6mC73nyDO;

1.32
date	2016.11.24.07.57.48;	author eric;	state Exp;
branches;
next	1.31;
commitid	PtnknknQfwIKwJ99;

1.31
date	2016.11.22.07.28.42;	author eric;	state Exp;
branches;
next	1.30;
commitid	8fz9wejpFY08v5WO;

1.30
date	2016.11.20.08.43.36;	author eric;	state Exp;
branches;
next	1.29;
commitid	WsInk7NbLdaIQWny;

1.29
date	2016.11.17.17.34.55;	author eric;	state Exp;
branches;
next	1.28;
commitid	8UKnvWDg7NJwNwWd;

1.28
date	2016.11.17.07.33.06;	author eric;	state Exp;
branches;
next	1.27;
commitid	6eHngXNIBgMGOO6G;

1.27
date	2016.11.16.21.30.37;	author eric;	state Exp;
branches;
next	1.26;
commitid	3uoi1oHbQkJMXEjt;

1.26
date	2016.05.16.21.43.16;	author millert;	state Exp;
branches;
next	1.25;
commitid	1oMuQUIHB0iKnbqw;

1.25
date	2016.03.25.15.06.58;	author krw;	state Exp;
branches;
next	1.24;
commitid	0NIU7T9t8yqZHZQl;

1.24
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.23;
commitid	ZxnqOQqX6IeYI9jW;

1.23
date	2015.12.22.07.54.57;	author sunil;	state Exp;
branches;
next	1.22;
commitid	TgCTyMVkvobPHclj;

1.22
date	2015.10.16.21.13.33;	author sthen;	state Exp;
branches;
next	1.21;
commitid	OZlZin0TY3Yru2bR;

1.21
date	2015.10.14.22.01.43;	author gilles;	state Exp;
branches;
next	1.20;
commitid	XSq2zfqNj1sXRZRl;

1.20
date	2014.12.24.13.51.31;	author eric;	state Exp;
branches;
next	1.19;
commitid	hxnMsgzQw5aKfNFY;

1.19
date	2014.07.08.07.59.31;	author sobrado;	state Exp;
branches;
next	1.18;
commitid	QejPnWBk7nSpcYUN;

1.18
date	2014.04.19.17.36.54;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.19.12.48.54;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2014.02.04.09.59.21;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.03.15.57.40;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2013.02.05.11.45.18;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2012.10.25.18.14.24;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.10.10.19.38.04;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.09.14.19.20.52;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.19.10.28.28;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.05.25.13.52.33;	author chl;	state Exp;
branches;
next	1.2;

1.2
date	2012.01.30.10.02.55;	author chl;	state Exp;
branches;
next	1.1;

1.1
date	2012.01.29.00.32.51;	author eric;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Introduce more use of freezero().  Also, remove ptr conditionals before
many functions which are free(NULL)-compat
ok gilles
@
text
@/*	$OpenBSD: ioev.c,v 1.40 2016/12/03 15:46:33 eric Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>

#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

#include "ioev.h"
#include "iobuf.h"

#ifdef IO_SSL
#include <openssl/err.h>
#include <openssl/ssl.h>
#endif

enum {
	IO_STATE_NONE,
	IO_STATE_CONNECT,
	IO_STATE_CONNECT_SSL,
	IO_STATE_ACCEPT_SSL,
	IO_STATE_UP,

	IO_STATE_MAX,
};

#define IO_PAUSE_IN 		IO_IN
#define IO_PAUSE_OUT		IO_OUT
#define IO_READ			0x04
#define IO_WRITE		0x08
#define IO_RW			(IO_READ | IO_WRITE)
#define IO_RESET		0x10  /* internal */
#define IO_HELD			0x20  /* internal */

struct io {
	int		 sock;
	void		*arg;
	void		(*cb)(struct io*, int, void *);
	struct iobuf	 iobuf;
	size_t		 lowat;
	int		 timeout;
	int		 flags;
	int		 state;
	struct event	 ev;
	void		*ssl;
	const char	*error; /* only valid immediately on callback */
};

const char* io_strflags(int);
const char* io_evstr(short);

void	_io_init(void);
void	io_hold(struct io *);
void	io_release(struct io *);
void	io_callback(struct io*, int);
void	io_dispatch(int, short, void *);
void	io_dispatch_connect(int, short, void *);
size_t	io_pending(struct io *);
size_t	io_queued(struct io*);
void	io_reset(struct io *, short, void (*)(int, short, void*));
void	io_frame_enter(const char *, struct io *, int);
void	io_frame_leave(struct io *);

#ifdef IO_SSL
void	ssl_error(const char *); /* XXX external */

static const char* io_ssl_error(void);
void	io_dispatch_accept_ssl(int, short, void *);
void	io_dispatch_connect_ssl(int, short, void *);
void	io_dispatch_read_ssl(int, short, void *);
void	io_dispatch_write_ssl(int, short, void *);
void	io_reload_ssl(struct io *io);
#endif

static struct io	*current = NULL;
static uint64_t		 frame = 0;
static int		_io_debug = 0;

#define io_debug(args...) do { if (_io_debug) printf(args); } while(0)


const char*
io_strio(struct io *io)
{
	static char	buf[128];
	char		ssl[128];

	ssl[0] = '\0';
#ifdef IO_SSL
	if (io->ssl) {
		(void)snprintf(ssl, sizeof ssl, " ssl=%s:%s:%d",
		    SSL_get_version(io->ssl),
		    SSL_get_cipher_name(io->ssl),
		    SSL_get_cipher_bits(io->ssl, NULL));
	}
#endif

	(void)snprintf(buf, sizeof buf,
	    "<io:%p fd=%d to=%d fl=%s%s ib=%zu ob=%zu>",
	    io, io->sock, io->timeout, io_strflags(io->flags), ssl,
	    io_pending(io), io_queued(io));

	return (buf);
}

#define CASE(x) case x : return #x

const char*
io_strevent(int evt)
{
	static char buf[32];

	switch (evt) {
	CASE(IO_CONNECTED);
	CASE(IO_TLSREADY);
	CASE(IO_DATAIN);
	CASE(IO_LOWAT);
	CASE(IO_DISCONNECTED);
	CASE(IO_TIMEOUT);
	CASE(IO_ERROR);
	default:
		(void)snprintf(buf, sizeof(buf), "IO_? %d", evt);
		return buf;
	}
}

void
io_set_nonblocking(int fd)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL)) == -1)
		err(1, "io_set_blocking:fcntl(F_GETFL)");

	flags |= O_NONBLOCK;

	if (fcntl(fd, F_SETFL, flags) == -1)
		err(1, "io_set_blocking:fcntl(F_SETFL)");
}

void
io_set_nolinger(int fd)
{
	struct linger    l;

	memset(&l, 0, sizeof(l));
	if (setsockopt(fd, SOL_SOCKET, SO_LINGER, &l, sizeof(l)) == -1)
		err(1, "io_set_linger:setsockopt()");
}

/*
 * Event framing must not rely on an io pointer to refer to the "same" io
 * throughout the frame, because this is not always the case:
 *
 * 1) enter(addr0) -> free(addr0) -> leave(addr0) = SEGV
 * 2) enter(addr0) -> free(addr0) -> malloc == addr0 -> leave(addr0) = BAD!
 *
 * In both case, the problem is that the io is freed in the callback, so
 * the pointer becomes invalid. If that happens, the user is required to
 * call io_clear, so we can adapt the frame state there.
 */
void
io_frame_enter(const char *where, struct io *io, int ev)
{
	io_debug("\n=== %" PRIu64 " ===\n"
	    "io_frame_enter(%s, %s, %s)\n",
	    frame, where, io_evstr(ev), io_strio(io));

	if (current)
		errx(1, "io_frame_enter: interleaved frames");

	current = io;

	io_hold(io);
}

void
io_frame_leave(struct io *io)
{
	io_debug("io_frame_leave(%" PRIu64 ")\n", frame);

	if (current && current != io)
		errx(1, "io_frame_leave: io mismatch");

	/* io has been cleared */
	if (current == NULL)
		goto done;

	/* TODO: There is a possible optimization there:
	 * In a typical half-duplex request/response scenario,
	 * the io is waiting to read a request, and when done, it queues
	 * the response in the output buffer and goes to write mode.
	 * There, the write event is set and will be triggered in the next
	 * event frame.  In most case, the write call could be done
	 * immediately as part of the last read frame, thus avoiding to go
	 * through the event loop machinery. So, as an optimisation, we
	 * could detect that case here and force an event dispatching.
	 */

	/* Reload the io if it has not been reset already. */
	io_release(io);
	current = NULL;
    done:
	io_debug("=== /%" PRIu64 "\n", frame);

	frame += 1;
}

void
_io_init()
{
	static int init = 0;

	if (init)
		return;

	init = 1;
	_io_debug = getenv("IO_DEBUG") != NULL;
}

struct io *
io_new(void)
{
	struct io *io;

	_io_init();

	if ((io = calloc(1, sizeof(*io))) == NULL)
		return NULL;

	io->sock = -1;
	io->timeout = -1;

	if (iobuf_init(&io->iobuf, 0, 0) == -1) {
		free(io);
		return NULL;
	}

	return io;
}

void
io_free(struct io *io)
{
	io_debug("io_clear(%p)\n", io);

	/* the current io is virtually dead */
	if (io == current)
		current = NULL;

#ifdef IO_SSL
	SSL_free(io->ssl);
	io->ssl = NULL;
#endif

	if (event_initialized(&io->ev))
		event_del(&io->ev);
	if (io->sock != -1) {
		close(io->sock);
		io->sock = -1;
	}

	iobuf_clear(&io->iobuf);
	free(io);
}

void
io_hold(struct io *io)
{
	io_debug("io_enter(%p)\n", io);

	if (io->flags & IO_HELD)
		errx(1, "io_hold: io is already held");

	io->flags &= ~IO_RESET;
	io->flags |= IO_HELD;
}

void
io_release(struct io *io)
{
	if (!(io->flags & IO_HELD))
		errx(1, "io_release: io is not held");

	io->flags &= ~IO_HELD;
	if (!(io->flags & IO_RESET))
		io_reload(io);
}

void
io_set_fd(struct io *io, int fd)
{
	io->sock = fd;
	if (fd != -1)
		io_reload(io);
}

void
io_set_callback(struct io *io, void(*cb)(struct io *, int, void *), void *arg)
{
	io->cb = cb;
	io->arg = arg;
}

void
io_set_timeout(struct io *io, int msec)
{
	io_debug("io_set_timeout(%p, %d)\n", io, msec);

	io->timeout = msec;
}

void
io_set_lowat(struct io *io, size_t lowat)
{
	io_debug("io_set_lowat(%p, %zu)\n", io, lowat);

	io->lowat = lowat;
}

void
io_pause(struct io *io, int dir)
{
	io_debug("io_pause(%p, %x)\n", io, dir);

	io->flags |= dir & (IO_PAUSE_IN | IO_PAUSE_OUT);
	io_reload(io);
}

void
io_resume(struct io *io, int dir)
{
	io_debug("io_resume(%p, %x)\n", io, dir);

	io->flags &= ~(dir & (IO_PAUSE_IN | IO_PAUSE_OUT));
	io_reload(io);
}

void
io_set_read(struct io *io)
{
	int	mode;

	io_debug("io_set_read(%p)\n", io);

	mode = io->flags & IO_RW;
	if (!(mode == 0 || mode == IO_WRITE))
		errx(1, "io_set_read(): full-duplex or reading");

	io->flags &= ~IO_RW;
	io->flags |= IO_READ;
	io_reload(io);
}

void
io_set_write(struct io *io)
{
	int	mode;

	io_debug("io_set_write(%p)\n", io);

	mode = io->flags & IO_RW;
	if (!(mode == 0 || mode == IO_READ))
		errx(1, "io_set_write(): full-duplex or writing");

	io->flags &= ~IO_RW;
	io->flags |= IO_WRITE;
	io_reload(io);
}

const char *
io_error(struct io *io)
{
	return io->error;
}

void *
io_ssl(struct io *io)
{
	return io->ssl;
}

int
io_fileno(struct io *io)
{
	return io->sock;
}

int
io_paused(struct io *io, int what)
{
	return (io->flags & (IO_PAUSE_IN | IO_PAUSE_OUT)) == what;
}

/*
 * Buffered output functions
 */

int
io_write(struct io *io, const void *buf, size_t len)
{
	int r;

	r = iobuf_queue(&io->iobuf, buf, len);

	io_reload(io);

	return r;
}

int
io_writev(struct io *io, const struct iovec *iov, int iovcount)
{
	int r;

	r = iobuf_queuev(&io->iobuf, iov, iovcount);

	io_reload(io);

	return r;
}

int
io_print(struct io *io, const char *s)
{
	return io_write(io, s, strlen(s));
}

int
io_printf(struct io *io, const char *fmt, ...)
{
	va_list ap;
	int r;

	va_start(ap, fmt);
	r = io_vprintf(io, fmt, ap);
	va_end(ap);

	return r;
}

int
io_vprintf(struct io *io, const char *fmt, va_list ap)
{

	char *buf;
	int len;

	len = vasprintf(&buf, fmt, ap);
	if (len == -1)
		return -1;
	len = io_write(io, buf, len);
	free(buf);

	return len;
}

size_t
io_queued(struct io *io)
{
	return iobuf_queued(&io->iobuf);
}

/*
 * Buffered input functions
 */

void *
io_data(struct io *io)
{
	return iobuf_data(&io->iobuf);
}

size_t
io_datalen(struct io *io)
{
	return iobuf_len(&io->iobuf);
}

char *
io_getline(struct io *io, size_t *sz)
{
	return iobuf_getline(&io->iobuf, sz);
}

void
io_drop(struct io *io, size_t sz)
{
	return iobuf_drop(&io->iobuf, sz);
}


#define IO_READING(io) (((io)->flags & IO_RW) != IO_WRITE)
#define IO_WRITING(io) (((io)->flags & IO_RW) != IO_READ)

/*
 * Setup the necessary events as required by the current io state,
 * honouring duplex mode and i/o pauses.
 */
void
io_reload(struct io *io)
{
	short	events;

	/* io will be reloaded at release time */
	if (io->flags & IO_HELD)
		return;

	iobuf_normalize(&io->iobuf);

#ifdef IO_SSL
	if (io->ssl) {
		io_reload_ssl(io);
		return;
	}
#endif

	io_debug("io_reload(%p)\n", io);

	events = 0;
	if (IO_READING(io) && !(io->flags & IO_PAUSE_IN))
		events = EV_READ;
	if (IO_WRITING(io) && !(io->flags & IO_PAUSE_OUT) && io_queued(io))
		events |= EV_WRITE;

	io_reset(io, events, io_dispatch);
}

/* Set the requested event. */
void
io_reset(struct io *io, short events, void (*dispatch)(int, short, void*))
{
	struct timeval	tv, *ptv;

	io_debug("io_reset(%p, %s, %p) -> %s\n",
	    io, io_evstr(events), dispatch, io_strio(io));

	/*
	 * Indicate that the event has already been reset so that reload
	 * is not called on frame_leave.
	 */
	io->flags |= IO_RESET;

	if (event_initialized(&io->ev))
		event_del(&io->ev);

	/*
	 * The io is paused by the user, so we don't want the timeout to be
	 * effective.
	 */
	if (events == 0)
		return;

	event_set(&io->ev, io->sock, events, dispatch, io);
	if (io->timeout >= 0) {
		tv.tv_sec = io->timeout / 1000;
		tv.tv_usec = (io->timeout % 1000) * 1000;
		ptv = &tv;
	} else
		ptv = NULL;

	event_add(&io->ev, ptv);
}

size_t
io_pending(struct io *io)
{
	return iobuf_len(&io->iobuf);
}

const char*
io_strflags(int flags)
{
	static char	buf[64];

	buf[0] = '\0';

	switch (flags & IO_RW) {
	case 0:
		(void)strlcat(buf, "rw", sizeof buf);
		break;
	case IO_READ:
		(void)strlcat(buf, "R", sizeof buf);
		break;
	case IO_WRITE:
		(void)strlcat(buf, "W", sizeof buf);
		break;
	case IO_RW:
		(void)strlcat(buf, "RW", sizeof buf);
		break;
	}

	if (flags & IO_PAUSE_IN)
		(void)strlcat(buf, ",F_PI", sizeof buf);
	if (flags & IO_PAUSE_OUT)
		(void)strlcat(buf, ",F_PO", sizeof buf);

	return buf;
}

const char*
io_evstr(short ev)
{
	static char	buf[64];
	char		buf2[16];
	int		n;

	n = 0;
	buf[0] = '\0';

	if (ev == 0) {
		(void)strlcat(buf, "<NONE>", sizeof(buf));
		return buf;
	}

	if (ev & EV_TIMEOUT) {
		(void)strlcat(buf, "EV_TIMEOUT", sizeof(buf));
		ev &= ~EV_TIMEOUT;
		n++;
	}

	if (ev & EV_READ) {
		if (n)
			(void)strlcat(buf, "|", sizeof(buf));
		(void)strlcat(buf, "EV_READ", sizeof(buf));
		ev &= ~EV_READ;
		n++;
	}

	if (ev & EV_WRITE) {
		if (n)
			(void)strlcat(buf, "|", sizeof(buf));
		(void)strlcat(buf, "EV_WRITE", sizeof(buf));
		ev &= ~EV_WRITE;
		n++;
	}

	if (ev & EV_SIGNAL) {
		if (n)
			(void)strlcat(buf, "|", sizeof(buf));
		(void)strlcat(buf, "EV_SIGNAL", sizeof(buf));
		ev &= ~EV_SIGNAL;
		n++;
	}

	if (ev) {
		if (n)
			(void)strlcat(buf, "|", sizeof(buf));
		(void)strlcat(buf, "EV_?=0x", sizeof(buf));
		(void)snprintf(buf2, sizeof(buf2), "%hx", ev);
		(void)strlcat(buf, buf2, sizeof(buf));
	}

	return buf;
}

void
io_dispatch(int fd, short ev, void *humppa)
{
	struct io	*io = humppa;
	size_t		 w;
	ssize_t		 n;
	int		 saved_errno;

	io_frame_enter("io_dispatch", io, ev);

	if (ev == EV_TIMEOUT) {
		io_callback(io, IO_TIMEOUT);
		goto leave;
	}

	if (ev & EV_WRITE && (w = io_queued(io))) {
		if ((n = iobuf_write(&io->iobuf, io->sock)) < 0) {
			if (n == IOBUF_WANT_WRITE) /* kqueue bug? */
				goto read;
			if (n == IOBUF_CLOSED)
				io_callback(io, IO_DISCONNECTED);
			else {
				saved_errno = errno;
				io->error = strerror(errno);
				errno = saved_errno;
				io_callback(io, IO_ERROR);
			}
			goto leave;
		}
		if (w > io->lowat && w - n <= io->lowat)
			io_callback(io, IO_LOWAT);
	}
    read:

	if (ev & EV_READ) {
		iobuf_normalize(&io->iobuf);
		if ((n = iobuf_read(&io->iobuf, io->sock)) < 0) {
			if (n == IOBUF_CLOSED)
				io_callback(io, IO_DISCONNECTED);
			else {
				saved_errno = errno;
				io->error = strerror(errno);
				errno = saved_errno;
				io_callback(io, IO_ERROR);
			}
			goto leave;
		}
		if (n)
			io_callback(io, IO_DATAIN);
	}

leave:
	io_frame_leave(io);
}

void
io_callback(struct io *io, int evt)
{
	io->cb(io, evt, io->arg);
}

int
io_connect(struct io *io, const struct sockaddr *sa, const struct sockaddr *bsa)
{
	int	sock, errno_save;

	if ((sock = socket(sa->sa_family, SOCK_STREAM, 0)) == -1)
		goto fail;

	io_set_nonblocking(sock);
	io_set_nolinger(sock);

	if (bsa && bind(sock, bsa, bsa->sa_len) == -1)
		goto fail;

	if (connect(sock, sa, sa->sa_len) == -1)
		if (errno != EINPROGRESS)
			goto fail;

	io->sock = sock;
	io_reset(io, EV_WRITE, io_dispatch_connect);

	return (sock);

    fail:
	if (sock != -1) {
		errno_save = errno;
		close(sock);
		errno = errno_save;
		io->error = strerror(errno);
	}
	return (-1);
}

void
io_dispatch_connect(int fd, short ev, void *humppa)
{
	struct io	*io = humppa;
	int		 r, e;
	socklen_t	 sl;

	io_frame_enter("io_dispatch_connect", io, ev);

	if (ev == EV_TIMEOUT) {
		close(fd);
		io->sock = -1;
		io_callback(io, IO_TIMEOUT);
	} else {
		sl = sizeof(e);
		r = getsockopt(fd, SOL_SOCKET, SO_ERROR, &e, &sl);
		if (r == -1)  {
			warn("io_dispatch_connect: getsockopt");
			e = errno;
		}
		if (e) {
			close(fd);
			io->sock = -1;
			io->error = strerror(e);
			io_callback(io, e == ETIMEDOUT ? IO_TIMEOUT : IO_ERROR);
		}
		else {
			io->state = IO_STATE_UP;
			io_callback(io, IO_CONNECTED);
		}
	}

	io_frame_leave(io);
}

#ifdef IO_SSL

static const char*
io_ssl_error(void)
{
	static char	buf[128];
	unsigned long	e;

	e = ERR_peek_last_error();
	if (e) {
		ERR_error_string(e, buf);
		return (buf);
	}

	return ("No SSL error");
}

int
io_start_tls(struct io *io, void *ssl)
{
	int	mode;

	mode = io->flags & IO_RW;
	if (mode == 0 || mode == IO_RW)
		errx(1, "io_start_tls(): full-duplex or unset");

	if (io->ssl)
		errx(1, "io_start_tls(): SSL already started");
	io->ssl = ssl;

	if (SSL_set_fd(io->ssl, io->sock) == 0) {
		ssl_error("io_start_ssl:SSL_set_fd");
		return (-1);
	}

	if (mode == IO_WRITE) {
		io->state = IO_STATE_CONNECT_SSL;
		SSL_set_connect_state(io->ssl);
		io_reset(io, EV_WRITE, io_dispatch_connect_ssl);
	} else {
		io->state = IO_STATE_ACCEPT_SSL;
		SSL_set_accept_state(io->ssl);
		io_reset(io, EV_READ, io_dispatch_accept_ssl);
	}

	return (0);
}

void
io_dispatch_accept_ssl(int fd, short event, void *humppa)
{
	struct io	*io = humppa;
	int		 e, ret;

	io_frame_enter("io_dispatch_accept_ssl", io, event);

	if (event == EV_TIMEOUT) {
		io_callback(io, IO_TIMEOUT);
		goto leave;
	}

	if ((ret = SSL_accept(io->ssl)) > 0) {
		io->state = IO_STATE_UP;
		io_callback(io, IO_TLSREADY);
		goto leave;
	}

	switch ((e = SSL_get_error(io->ssl, ret))) {
	case SSL_ERROR_WANT_READ:
		io_reset(io, EV_READ, io_dispatch_accept_ssl);
		break;
	case SSL_ERROR_WANT_WRITE:
		io_reset(io, EV_WRITE, io_dispatch_accept_ssl);
		break;
	default:
		io->error = io_ssl_error();
		ssl_error("io_dispatch_accept_ssl:SSL_accept");
		io_callback(io, IO_ERROR);
		break;
	}

    leave:
	io_frame_leave(io);
}

void
io_dispatch_connect_ssl(int fd, short event, void *humppa)
{
	struct io	*io = humppa;
	int		 e, ret;

	io_frame_enter("io_dispatch_connect_ssl", io, event);

	if (event == EV_TIMEOUT) {
		io_callback(io, IO_TIMEOUT);
		goto leave;
	}

	if ((ret = SSL_connect(io->ssl)) > 0) {
		io->state = IO_STATE_UP;
		io_callback(io, IO_TLSREADY);
		goto leave;
	}

	switch ((e = SSL_get_error(io->ssl, ret))) {
	case SSL_ERROR_WANT_READ:
		io_reset(io, EV_READ, io_dispatch_connect_ssl);
		break;
	case SSL_ERROR_WANT_WRITE:
		io_reset(io, EV_WRITE, io_dispatch_connect_ssl);
		break;
	default:
		io->error = io_ssl_error();
		ssl_error("io_dispatch_connect_ssl:SSL_connect");
		io_callback(io, IO_TLSERROR);
		break;
	}

    leave:
	io_frame_leave(io);
}

void
io_dispatch_read_ssl(int fd, short event, void *humppa)
{
	struct io	*io = humppa;
	int		 n, saved_errno;

	io_frame_enter("io_dispatch_read_ssl", io, event);

	if (event == EV_TIMEOUT) {
		io_callback(io, IO_TIMEOUT);
		goto leave;
	}

again:
	iobuf_normalize(&io->iobuf);
	switch ((n = iobuf_read_ssl(&io->iobuf, (SSL*)io->ssl))) {
	case IOBUF_WANT_READ:
		io_reset(io, EV_READ, io_dispatch_read_ssl);
		break;
	case IOBUF_WANT_WRITE:
		io_reset(io, EV_WRITE, io_dispatch_read_ssl);
		break;
	case IOBUF_CLOSED:
		io_callback(io, IO_DISCONNECTED);
		break;
	case IOBUF_ERROR:
		saved_errno = errno;
		io->error = strerror(errno);
		errno = saved_errno;
		io_callback(io, IO_ERROR);
		break;
	case IOBUF_SSLERROR:
		io->error = io_ssl_error();
		ssl_error("io_dispatch_read_ssl:SSL_read");
		io_callback(io, IO_ERROR);
		break;
	default:
		io_debug("io_dispatch_read_ssl(...) -> r=%d\n", n);
		io_callback(io, IO_DATAIN);
		if (current == io && IO_READING(io) && SSL_pending(io->ssl))
			goto again;
	}

    leave:
	io_frame_leave(io);
}

void
io_dispatch_write_ssl(int fd, short event, void *humppa)
{
	struct io	*io = humppa;
	int		 n, saved_errno;
	size_t		 w2, w;

	io_frame_enter("io_dispatch_write_ssl", io, event);

	if (event == EV_TIMEOUT) {
		io_callback(io, IO_TIMEOUT);
		goto leave;
	}

	w = io_queued(io);
	switch ((n = iobuf_write_ssl(&io->iobuf, (SSL*)io->ssl))) {
	case IOBUF_WANT_READ:
		io_reset(io, EV_READ, io_dispatch_write_ssl);
		break;
	case IOBUF_WANT_WRITE:
		io_reset(io, EV_WRITE, io_dispatch_write_ssl);
		break;
	case IOBUF_CLOSED:
		io_callback(io, IO_DISCONNECTED);
		break;
	case IOBUF_ERROR:
		saved_errno = errno;
		io->error = strerror(errno);
		errno = saved_errno;
		io_callback(io, IO_ERROR);
		break;
	case IOBUF_SSLERROR:
		io->error = io_ssl_error();
		ssl_error("io_dispatch_write_ssl:SSL_write");
		io_callback(io, IO_ERROR);
		break;
	default:
		io_debug("io_dispatch_write_ssl(...) -> w=%d\n", n);
		w2 = io_queued(io);
		if (w > io->lowat && w2 <= io->lowat)
			io_callback(io, IO_LOWAT);
		break;
	}

    leave:
	io_frame_leave(io);
}

void
io_reload_ssl(struct io *io)
{
	short	ev = 0;
	void	(*dispatch)(int, short, void*) = NULL;

	switch (io->state) {
	case IO_STATE_CONNECT_SSL:
		ev = EV_WRITE;
		dispatch = io_dispatch_connect_ssl;
		break;
	case IO_STATE_ACCEPT_SSL:
		ev = EV_READ;
		dispatch = io_dispatch_accept_ssl;
		break;
	case IO_STATE_UP:
		ev = 0;
		if (IO_READING(io) && !(io->flags & IO_PAUSE_IN)) {
			ev = EV_READ;
			dispatch = io_dispatch_read_ssl;
		}
		else if (IO_WRITING(io) && !(io->flags & IO_PAUSE_OUT) &&
		    io_queued(io)) {
			ev = EV_WRITE;
			dispatch = io_dispatch_write_ssl;
		}
		if (!ev)
			return; /* paused */
		break;
	default:
		errx(1, "io_reload_ssl(): bad state");
	}

	io_reset(io, ev, dispatch);
}

#endif /* IO_SSL */
@


1.40
log
@embed the struct iobuf instead of using a pointer.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.39 2016/11/30 17:43:32 eric Exp $	*/
d275 2
a276 4
	if (io->ssl) {
		SSL_free(io->ssl);
		io->ssl = NULL;
	}
@


1.39
log
@hide internal io flags and rename IO_PAUSE_{IN,OUT} to IO_{IN,OUT}

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.38 2016/11/30 11:52:48 eric Exp $	*/
d62 1
a62 1
	struct iobuf	*iobuf;
d121 4
a124 9
	if (io->iobuf == NULL)
		(void)snprintf(buf, sizeof buf,
		    "<io:%p fd=%d to=%d fl=%s%s>",
		    io, io->sock, io->timeout, io_strflags(io->flags), ssl);
	else
		(void)snprintf(buf, sizeof buf,
		    "<io:%p fd=%d to=%d fl=%s%s ib=%zu ob=%zu>",
		    io, io->sock, io->timeout, io_strflags(io->flags), ssl,
		    io_pending(io), io_queued(io));
a255 1
	io->iobuf = calloc(1, sizeof(*io->iobuf));
d257 1
a257 7
	if (io->iobuf == NULL) {
		free(io);
		return NULL;
	}

	if (iobuf_init(io->iobuf, 0, 0) == -1) {
		free(io->iobuf);
d288 1
a288 2
	iobuf_clear(io->iobuf);
	free(io->iobuf);
d429 1
a429 1
	r = iobuf_queue(io->iobuf, buf, len);
d441 1
a441 1
	r = iobuf_queuev(io->iobuf, iov, iovcount);
d486 1
a486 1
	return iobuf_queued(io->iobuf);
d496 1
a496 1
	return iobuf_data(io->iobuf);
d502 1
a502 1
	return iobuf_len(io->iobuf);
d508 1
a508 1
	return iobuf_getline(io->iobuf, sz);
d514 1
a514 1
	return iobuf_drop(io->iobuf, sz);
d534 1
a534 2
	if (io->iobuf)
		iobuf_normalize(io->iobuf);
d593 1
a593 1
	return iobuf_len(io->iobuf);
d698 1
a698 1
		if ((n = iobuf_write(io->iobuf, io->sock)) < 0) {
d717 2
a718 2
		iobuf_normalize(io->iobuf);
		if ((n = iobuf_read(io->iobuf, io->sock)) < 0) {
d947 2
a948 2
	iobuf_normalize(io->iobuf);
	switch ((n = iobuf_read_ssl(io->iobuf, (SSL*)io->ssl))) {
d995 1
a995 1
	switch ((n = iobuf_write_ssl(io->iobuf, (SSL*)io->ssl))) {
@


1.38
log
@make struct io opaque:

- move struct io definition to ioev.c
- replace io_init/io_clear with io_new/io_free
- allocate an iobuf for each new io internally
- use struct io pointer in the rest of the code
- remove remaining uses of iobuf_*

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.37 2016/11/25 16:17:41 eric Exp $	*/
d49 8
@


1.37
log
@normalize iobuf before reading into it.

fix regression introduced in recent cleanup

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.36 2016/11/24 21:25:21 eric Exp $	*/
d24 1
d50 14
d241 2
a242 2
void
io_init(struct io *io, struct iobuf *iobuf)
d244 2
d248 2
a249 1
	memset(io, 0, sizeof *io);
d253 14
a266 1
	io->iobuf = iobuf;
d270 1
a270 1
io_clear(struct io *io)
d291 4
@


1.36
log
@add an io_paused() function.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.35 2016/11/24 20:52:13 eric Exp $	*/
d688 1
d918 1
@


1.35
log
@add an io_fileno() accessor

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.34 2016/11/24 20:44:04 eric Exp $	*/
d382 6
@


1.34
log
@add an io_ssl() accessor

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.33 2016/11/24 12:58:27 eric Exp $	*/
d376 6
@


1.33
log
@add an io_error() accessor to avoid dereferencing the io struct directly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.32 2016/11/24 07:57:48 eric Exp $	*/
d370 6
@


1.32
log
@reset the io event when data is queued.
remove all calls to io_reload() which are now unnecessary.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.31 2016/11/22 07:28:42 eric Exp $	*/
d364 6
@


1.31
log
@Normalize the io input buffer internally when reinstalling the io event, so
the caller doesn't have to bother with this.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.30 2016/11/20 08:43:36 eric Exp $	*/
d373 7
a379 1
	return iobuf_queue(io->iobuf, buf, len);
d385 7
a391 1
	return iobuf_queuev(io->iobuf, iov, iovcount);
@


1.30
log
@add dedicated functions to set fd and callback on a struct io.
simplify io_init() prototype.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.29 2016/11/17 17:34:55 eric Exp $	*/
d467 3
@


1.29
log
@Add io api functions for dealing with buffered data, as wrapper around
their iobuf counterparts.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.28 2016/11/17 07:33:06 eric Exp $	*/
d227 1
a227 2
io_init(struct io *io, int sock, void *arg,
	void(*cb)(struct io*, int, void *), struct iobuf *iobuf)
d233 1
a233 1
	io->sock = sock;
a234 1
	io->arg = arg;
a235 4
	io->cb = cb;

	if (sock != -1)
		io_reload(io);
d283 15
@


1.28
log
@remove IO_TLSVERIFIED which is not a io event, and inline necessary code
where the callback functions are called for this event.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.27 2016/11/16 21:30:37 eric Exp $	*/
d357 86
a516 6
}

size_t
io_queued(struct io *io)
{
	return iobuf_queued(io->iobuf);
@


1.27
log
@pass the user pointer as parameter to the io callback instead of having
the user dereference the io structure.

ok millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.26 2016/05/16 21:43:16 millert Exp $	*/
a120 1
	CASE(IO_TLSVERIFIED);
@


1.26
log
@No need to store the return value of fcntl(fd, F_SETFL, flags).
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.25 2016/03/25 15:06:58 krw Exp $	*/
d229 1
a229 1
	void(*cb)(struct io*, int), struct iobuf *iobuf)
d583 1
a583 1
	io->cb(io, evt);
@


1.25
log
@Nuke session_socket_blockmode() and session_socket_linger(). Use
the identical io_set_blocking() and io_set_linger().

Since both are always called to turn off blocking or lingering,
nuke the parameter and associated enum in favour of "just doing the
right thing".

While passing remove the unneeded last parameter to the remaining
fcntl(F_GETFL).

Finally, rename the functions to io_set_nonblocking() and
io_set_nolinger() for clarity.

No functional change.

Started with a sweep of fcntl() usage inspired by guenther@@.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.24 2015/12/28 22:08:30 jung Exp $	*/
d143 1
a143 1
	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
@


1.24
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.23 2015/12/22 07:54:57 sunil Exp $	*/
d134 1
a134 1
io_set_blocking(int fd, int blocking)
d138 1
a138 1
	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
d141 1
a141 4
	if (blocking)
		flags &= ~O_NONBLOCK;
	else
		flags |= O_NONBLOCK;
d148 1
a148 1
io_set_linger(int fd, int linger)
a152 2
	l.l_onoff = linger ? 1 : 0;
	l.l_linger = linger;
d594 2
a595 2
	io_set_blocking(sock, 0);
	io_set_linger(sock, 0);
@


1.23
log
@Wrap long lines.

Ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.22 2015/10/16 21:13:33 sthen Exp $	*/
d901 1
a901 1
		if (! ev)
@


1.22
log
@Use SSL_get_version() not SSL_get_cipher_version(); the former gives the TLS
version used for the connection, the latter gives "the SSL/TLS protocol version
that first defined the cipher". Fixes "TLS version=TLSv1/SSLv3" in received/log
lines.

ok millert@@ "I was going to commit this today, so yes definitely" ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.21 2015/10/14 22:01:43 gilles Exp $	*/
d896 2
a897 1
		else if (IO_WRITING(io) && !(io->flags & IO_PAUSE_OUT) && io_queued(io)) {
@


1.21
log
@whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.20 2014/12/24 13:51:31 eric Exp $	*/
d92 1
a92 1
		    SSL_get_cipher_version(io->ssl),
@


1.20
log
@Correctly fallback to PLAIN if opportunistics TLS fails during TLS handshake.

fix by Stefan Sieg

ok gilles
@
text
@d1 2
a2 2
/*	$OpenBSD: ioev.c,v 1.19 2014/07/08 07:59:31 sobrado Exp $	*/
/*      
@


1.19
log
@fix typos.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.18 2014/04/19 17:36:54 gilles Exp $	*/
d773 1
a773 1
		io_callback(io, IO_ERROR);
@


1.18
log
@(void) cast snprintf() calls that cannot truncate (and would be harmless
	otherwise)
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.17 2014/04/19 12:48:54 gilles Exp $	*/
d164 1
a164 1
 * throughout the frame, beacuse this is not always the case:
d206 1
a206 1
	 * immediatly as part of the last read frame, thus avoiding to go
@


1.17
log
@(void) cast strlcat(), they can't truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.16 2014/02/04 09:59:21 eric Exp $	*/
d91 1
a91 1
		snprintf(ssl, sizeof ssl, " ssl=%s:%s:%d",
d99 1
a99 1
		snprintf(buf, sizeof buf,
d103 1
a103 1
		snprintf(buf, sizeof buf,
d128 1
a128 1
		snprintf(buf, sizeof(buf), "IO_? %d", evt);
@


1.16
log
@do not call event_del() on non-initialized events
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d454 1
a454 1
		strlcat(buf, "rw", sizeof buf);
d457 1
a457 1
		strlcat(buf, "R", sizeof buf);
d460 1
a460 1
		strlcat(buf, "W", sizeof buf);
d463 1
a463 1
		strlcat(buf, "RW", sizeof buf);
d468 1
a468 1
		strlcat(buf, ",F_PI", sizeof buf);
d470 1
a470 1
		strlcat(buf, ",F_PO", sizeof buf);
d486 1
a486 1
		strlcat(buf, "<NONE>", sizeof(buf));
d491 1
a491 1
		strlcat(buf, "EV_TIMEOUT", sizeof(buf));
d498 2
a499 2
			strlcat(buf, "|", sizeof(buf));
		strlcat(buf, "EV_READ", sizeof(buf));
d506 2
a507 2
			strlcat(buf, "|", sizeof(buf));
		strlcat(buf, "EV_WRITE", sizeof(buf));
d514 2
a515 2
			strlcat(buf, "|", sizeof(buf));
		strlcat(buf, "EV_SIGNAL", sizeof(buf));
d522 4
a525 4
			strlcat(buf, "|", sizeof(buf));
		strlcat(buf, "EV_?=0x", sizeof(buf));
		snprintf(buf2, sizeof(buf2), "%hx", ev);
		strlcat(buf, buf2, sizeof(buf));
@


1.15
log
@bcopy -> memmove
bzero -> memset
@
text
@d266 2
a267 1
	event_del(&io->ev);
d412 2
a413 1
	event_del(&io->ev);
@


1.14
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.13 2013/06/03 15:57:40 eric Exp $	*/
d155 1
a155 1
	bzero(&l, sizeof(l));
@


1.13
log
@call SSL_read() again if there is data pending in the SSL buffer.
fixes possible timeout on ssl sessions.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d91 1
a91 1
		snprintf(ssl, sizeof ssl, " ssl=%s:%s:%i",
d100 1
a100 1
		    "<io:%p fd=%i to=%i fl=%s%s>",
d104 1
a104 1
		    "<io:%p fd=%i to=%i fl=%s%s ib=%zu ob=%zu>",
d128 1
a128 1
		snprintf(buf, sizeof(buf), "IO_? %i", evt);
d299 1
a299 1
	io_debug("io_set_timeout(%p, %i)\n", io, msec);
d815 1
a815 1
		io_debug("io_dispatch_read_ssl(...) -> r=%i\n", n);
d862 1
a862 1
		io_debug("io_dispatch_write_ssl(...) -> w=%i\n", n);
@


1.12
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.11 2013/02/05 11:45:18 gilles Exp $	*/
d792 1
d817 2
@


1.11
log
@- handle getaddrinfo() error as LKA_TEMPFAIL
- handle getsockname() error in smtp_connected()
- accept '/' as part of user-part, expand to ':' as done by qmail
- fix wrong check in mda leading to bogus Return-Path header
- fix aliases parsing when there's a white space between key and separator
- some cosmethic cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.10 2013/01/26 09:37:23 gilles Exp $	*/
d18 1
a18 1
#include <sys/param.h>
d121 1
d626 2
d636 16
a651 2
		io->state = IO_STATE_UP;
		io_callback(io, IO_CONNECTED);
d695 1
a695 1
		io_reset(io, EV_READ | EV_WRITE, io_dispatch_connect_ssl);
d699 1
a699 1
		io_reset(io, EV_READ | EV_WRITE, io_dispatch_accept_ssl);
d873 1
d878 1
d882 1
d886 3
a888 1
		if ((io->flags & IO_RW) == IO_READ)
d890 3
a892 3
		else {
			if (io_queued(io) == 0)
				return; /* nothing to write */
d895 2
d902 1
a902 1
	io_reset(io, EV_READ | EV_WRITE, dispatch);
@


1.10
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.8 2012/11/12 14:58:53 eric Exp $	*/
a487 2
		if (n)
			strlcat(buf, "|", sizeof(buf));
@


1.9
log
@knf

ok gilles@@
@
text
@a30 1
#include "log.h"
d35 2
a36 1
#	include <openssl/ssl.h>
d67 1
d536 1
d547 1
a547 3
			if (n == IOBUF_ERROR || n == IOBUF_WANT_WRITE)
				log_warn("warn: io_dispatch: iobuf_write");
			if (n == IOBUF_WANT_WRITE)  /* kqueue bug? */
d549 8
a556 2
			io_callback(io, n == IOBUF_CLOSED ?
			    IO_DISCONNECTED : IO_ERROR);
d566 8
a573 4
			if (n == IO_ERROR)
				log_warn("warn: io_dispatch: iobuf_read");
			io_callback(io, n == IOBUF_CLOSED ?
			    IO_DISCONNECTED : IO_ERROR);
d618 1
d644 15
d717 1
d754 1
d768 1
a768 1
	int		 n;
d788 7
d811 1
a811 1
	int		 n;
d833 7
@


1.8
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.7 2012/10/25 18:14:24 eric Exp $	*/
d117 1
a117 1
	switch(evt) {
d426 1
a426 1
        event_add(&io->ev, ptv);
d448 1
a448 1
	switch(flags & IO_RW) {
d570 1
a570 1
   leave:
d818 1
a818 1
	switch(io->state) {
@


1.7
log
@Handle the case where writev() fails with EAGAIN.  In theory it cannot
happen, but it seems that kqueue triggers the event sometimes, even if
the socket is not immediatly writeable.  Temporary workaround it while
the real issue is being investigated.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.6 2012/10/10 19:38:04 eric Exp $	*/
d546 1
a546 1
				log_warn("io_dispatch: iobuf_write");
d561 1
a561 1
				log_warn("io_dispatch: iobuf_read");
@


1.6
log
@io_connect() can take an optional address to bind() before connecting.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.5 2012/09/14 19:20:52 eric Exp $	*/
d545 1
a545 1
			if (n == IO_ERROR)
d547 2
d556 1
@


1.5
log
@When printing ioev, do not segfault if there is no associated iobuf.
Also give info about the cipher if there is an ssl context.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.4 2012/08/19 10:28:28 eric Exp $	*/
d578 1
a578 1
io_connect(struct io *io, const struct sockaddr *sa)
d587 3
@


1.4
log
@Add warnings on io errors to help diagnosis.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.3 2012/05/25 13:52:33 chl Exp $	*/
d85 21
a106 3
	snprintf(buf, sizeof buf, "<io:%p fd=%i to=%i fl=%s ib=%zu ob=%zu>",
			io, io->sock, io->timeout, io_strflags(io->flags),
			io_pending(io), io_queued(io));
@


1.3
log
@remove unused variable

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.2 2012/01/30 10:02:55 chl Exp $	*/
d31 1
d527 2
d530 1
a530 1
				IO_DISCONNECTED : IO_ERROR);
d539 2
d703 1
d736 1
d774 1
@


1.2
log
@Add missing header needed by PRI format string

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioev.c,v 1.1 2012/01/29 00:32:51 eric Exp $	*/
a513 1
	char		 buf[64];
a517 2

	buf[0] = 0;
@


1.1
log
@Import generic network IO code.  The plan is to hide the boring
details of IO operations such as buffering or SSL, and provide a
slightly nicer interface to the protocol writer.

Not plugged to the rest of the code yet.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.5 2011/07/13 14:52:21 eric Exp $	*/
d25 1
@

