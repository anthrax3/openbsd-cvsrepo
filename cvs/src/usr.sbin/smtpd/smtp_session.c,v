head	1.307;
access;
symbols
	OPENBSD_6_1:1.302.0.4
	OPENBSD_6_1_BASE:1.302
	OPENBSD_6_0:1.284.0.4
	OPENBSD_6_0_BASE:1.284
	OPENBSD_5_9:1.268.0.2
	OPENBSD_5_9_BASE:1.268
	OPENBSD_5_8:1.230.0.4
	OPENBSD_5_8_BASE:1.230
	OPENBSD_5_7:1.227.0.2
	OPENBSD_5_7_BASE:1.227
	OPENBSD_5_6:1.215.0.4
	OPENBSD_5_6_BASE:1.215
	OPENBSD_5_5:1.196.0.2
	OPENBSD_5_5_BASE:1.196
	OPENBSD_5_4:1.184.0.2
	OPENBSD_5_4_BASE:1.184
	OPENBSD_5_3:1.181.0.2
	OPENBSD_5_3_BASE:1.181
	OPENBSD_5_2:1.162.0.2
	OPENBSD_5_2_BASE:1.162
	OPENBSD_5_1_BASE:1.161
	OPENBSD_5_1:1.161.0.2
	OPENBSD_5_0:1.142.0.2
	OPENBSD_5_0_BASE:1.142
	OPENBSD_4_9:1.138.0.2
	OPENBSD_4_9_BASE:1.138
	OPENBSD_4_8:1.135.0.2
	OPENBSD_4_8_BASE:1.135
	OPENBSD_4_7:1.128.0.2
	OPENBSD_4_7_BASE:1.128
	OPENBSD_4_6:1.107.0.4
	OPENBSD_4_6_BASE:1.107
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58;
locks; strict;
comment	@ * @;


1.307
date	2017.08.30.07.11.25;	author eric;	state Exp;
branches;
next	1.306;
commitid	YR4844zTbMuMQWyP;

1.306
date	2017.08.30.06.43.42;	author eric;	state Exp;
branches;
next	1.305;
commitid	HUlZCDv1Cx8hl46Q;

1.305
date	2017.08.13.11.10.30;	author eric;	state Exp;
branches;
next	1.304;
commitid	gfmSsnStq4224Spd;

1.304
date	2017.06.19.08.35.56;	author gilles;	state Exp;
branches;
next	1.303;
commitid	ZB9diUAYIXUa3N77;

1.303
date	2017.05.17.14.00.06;	author deraadt;	state Exp;
branches;
next	1.302;
commitid	CQ2bJKe5Leh53ur4;

1.302
date	2016.11.30.17.43.32;	author eric;	state Exp;
branches;
next	1.301;
commitid	12DZR8Z2gR4qMwKF;

1.301
date	2016.11.30.11.52.48;	author eric;	state Exp;
branches;
next	1.300;
commitid	HLHuvF4EZizEJJ0M;

1.300
date	2016.11.24.21.25.21;	author eric;	state Exp;
branches;
next	1.299;
commitid	85eBrsNLf8b4heK8;

1.299
date	2016.11.24.20.52.13;	author eric;	state Exp;
branches;
next	1.298;
commitid	UvPJmlWnlqtYXKpn;

1.298
date	2016.11.24.20.44.04;	author eric;	state Exp;
branches;
next	1.297;
commitid	NUNgQusDh5a3bpBi;

1.297
date	2016.11.24.12.58.27;	author eric;	state Exp;
branches;
next	1.296;
commitid	5gZmKKc6mC73nyDO;

1.296
date	2016.11.24.07.57.48;	author eric;	state Exp;
branches;
next	1.295;
commitid	PtnknknQfwIKwJ99;

1.295
date	2016.11.22.07.28.42;	author eric;	state Exp;
branches;
next	1.294;
commitid	8fz9wejpFY08v5WO;

1.294
date	2016.11.21.13.00.43;	author eric;	state Exp;
branches;
next	1.293;
commitid	pP1uMFU0IrsBTn27;

1.293
date	2016.11.20.08.43.36;	author eric;	state Exp;
branches;
next	1.292;
commitid	WsInk7NbLdaIQWny;

1.292
date	2016.11.18.09.35.27;	author eric;	state Exp;
branches;
next	1.291;
commitid	X2dTPBb8osr05H74;

1.291
date	2016.11.17.07.33.06;	author eric;	state Exp;
branches;
next	1.290;
commitid	6eHngXNIBgMGOO6G;

1.290
date	2016.11.16.21.30.37;	author eric;	state Exp;
branches;
next	1.289;
commitid	3uoi1oHbQkJMXEjt;

1.289
date	2016.10.16.17.15.15;	author eric;	state Exp;
branches;
next	1.288;
commitid	QXDRhRYrjBEYDtZz;

1.288
date	2016.10.13.15.47.32;	author gilles;	state Exp;
branches;
next	1.287;
commitid	qen1i3tp9AWn8jny;

1.287
date	2016.10.03.19.36.11;	author eric;	state Exp;
branches;
next	1.286;
commitid	YfR6LdQ3Y3QOBDD1;

1.286
date	2016.09.03.22.59.06;	author giovanni;	state Exp;
branches;
next	1.285;
commitid	s881VySc776wR5bJ;

1.285
date	2016.07.29.08.53.07;	author giovanni;	state Exp;
branches;
next	1.284;
commitid	jfgW1TXdp28XRfuO;

1.284
date	2016.07.22.12.12.29;	author eric;	state Exp;
branches
	1.284.4.1;
next	1.283;
commitid	AhdNzxVB1NJgNqoI;

1.283
date	2016.07.02.09.32.30;	author eric;	state Exp;
branches;
next	1.282;
commitid	WEWf1eV5ph0b2jgG;

1.282
date	2016.07.02.08.47.30;	author eric;	state Exp;
branches;
next	1.281;
commitid	xeKsqHJf4iPTK8x7;

1.281
date	2016.07.02.07.55.59;	author eric;	state Exp;
branches;
next	1.280;
commitid	OiL5TJFI2qQ5gab8;

1.280
date	2016.07.01.19.52.31;	author eric;	state Exp;
branches;
next	1.279;
commitid	z33NLrw5m8vvIXGi;

1.279
date	2016.07.01.17.53.23;	author eric;	state Exp;
branches;
next	1.278;
commitid	eQAXyof5NBgxe8Jc;

1.278
date	2016.06.29.06.46.06;	author eric;	state Exp;
branches;
next	1.277;
commitid	Zr1tUk1x7OqbFhmN;

1.277
date	2016.06.23.11.56.19;	author eric;	state Exp;
branches;
next	1.276;
commitid	MeGBQbnXszK8gZva;

1.276
date	2016.06.17.18.56.51;	author otto;	state Exp;
branches;
next	1.275;
commitid	nneBCgp2XLkUvzIR;

1.275
date	2016.06.15.21.52.47;	author eric;	state Exp;
branches;
next	1.274;
commitid	rTzvRpTzT5VXR4CX;

1.274
date	2016.06.15.19.56.07;	author gilles;	state Exp;
branches;
next	1.273;
commitid	CqFwPJNY8k1yrQTw;

1.273
date	2016.06.08.06.52.56;	author gilles;	state Exp;
branches;
next	1.272;
commitid	HKzd5xCp7GDhK4tQ;

1.272
date	2016.05.22.16.31.21;	author gilles;	state Exp;
branches;
next	1.271;
commitid	JDbBqpKvf906qrdL;

1.271
date	2016.05.16.19.25.05;	author gilles;	state Exp;
branches;
next	1.270;
commitid	MArJCIQmAKtpqVOA;

1.270
date	2016.05.08.20.24.01;	author millert;	state Exp;
branches;
next	1.269;
commitid	uaS9bINWFnIGI8wB;

1.269
date	2016.03.25.15.06.58;	author krw;	state Exp;
branches;
next	1.268;
commitid	0NIU7T9t8yqZHZQl;

1.268
date	2016.02.05.19.15.15;	author jung;	state Exp;
branches
	1.268.2.1;
next	1.267;
commitid	iziLYeslx9zPwtRs;

1.267
date	2016.02.04.20.27.33;	author eric;	state Exp;
branches;
next	1.266;
commitid	YQkMvnncFvF4KEg6;

1.266
date	2016.02.03.13.38.40;	author eric;	state Exp;
branches;
next	1.265;
commitid	gr7Hgyy1nu0YMWtN;

1.265
date	2016.02.03.11.16.19;	author eric;	state Exp;
branches;
next	1.264;
commitid	dx3BKb5w7T2UV5cM;

1.264
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.263;
commitid	ZxnqOQqX6IeYI9jW;

1.263
date	2015.12.14.10.22.12;	author jung;	state Exp;
branches;
next	1.262;
commitid	HRAnniyhGW9Sadln;

1.262
date	2015.12.13.10.54.11;	author gilles;	state Exp;
branches;
next	1.261;
commitid	7oThDZgvowAZS6Fw;

1.261
date	2015.12.13.10.33.42;	author gilles;	state Exp;
branches;
next	1.260;
commitid	d6ONEK8zdnW9gqvD;

1.260
date	2015.12.13.09.52.44;	author gilles;	state Exp;
branches;
next	1.259;
commitid	OUT78jWdQV3PCjhK;

1.259
date	2015.12.12.20.02.31;	author gilles;	state Exp;
branches;
next	1.258;
commitid	eO2zB2XyKCWqQLmz;

1.258
date	2015.12.12.18.49.38;	author gilles;	state Exp;
branches;
next	1.257;
commitid	wCM0D96m6r1a6i9q;

1.257
date	2015.12.12.18.42.58;	author gilles;	state Exp;
branches;
next	1.256;
commitid	G22x8kT15ezTCPfr;

1.256
date	2015.12.12.14.33.35;	author gilles;	state Exp;
branches;
next	1.255;
commitid	cNnr2W5K78QDHb7P;

1.255
date	2015.12.12.14.27.03;	author gilles;	state Exp;
branches;
next	1.254;
commitid	uoD1USKGnEKmFaj4;

1.254
date	2015.12.12.14.15.53;	author gilles;	state Exp;
branches;
next	1.253;
commitid	8LGhUKK77rdgY9s0;

1.253
date	2015.12.12.14.01.56;	author gilles;	state Exp;
branches;
next	1.252;
commitid	mJWInRKRsVvJCwXr;

1.252
date	2015.12.12.11.31.29;	author sunil;	state Exp;
branches;
next	1.251;
commitid	xbftp8DyefrEq9pW;

1.251
date	2015.12.12.10.35.52;	author gilles;	state Exp;
branches;
next	1.250;
commitid	5awqNn0BDgxddQIs;

1.250
date	2015.12.12.10.33.21;	author gilles;	state Exp;
branches;
next	1.249;
commitid	XUKZfjIng0wEyJ0I;

1.249
date	2015.12.12.10.31.01;	author gilles;	state Exp;
branches;
next	1.248;
commitid	3N6aciewtgvs4cU8;

1.248
date	2015.12.12.10.27.18;	author gilles;	state Exp;
branches;
next	1.247;
commitid	SHX4nIi0VeWyPYmt;

1.247
date	2015.12.12.10.24.27;	author gilles;	state Exp;
branches;
next	1.246;
commitid	9J6BE0U38eBiU4fy;

1.246
date	2015.12.12.10.22.39;	author gilles;	state Exp;
branches;
next	1.245;
commitid	NQYXLAQLZ0kKDpuN;

1.245
date	2015.12.12.09.59.04;	author gilles;	state Exp;
branches;
next	1.244;
commitid	vzX08zM0vLp1N1XZ;

1.244
date	2015.12.11.21.44.01;	author gilles;	state Exp;
branches;
next	1.243;
commitid	4sl0Vm3vIoWoEZs0;

1.243
date	2015.12.11.21.23.42;	author gilles;	state Exp;
branches;
next	1.242;
commitid	mrAjOy2m2jgFfqUT;

1.242
date	2015.12.03.21.11.33;	author jung;	state Exp;
branches;
next	1.241;
commitid	KMDOdtoOlQlcNX1b;

1.241
date	2015.12.01.18.22.30;	author gilles;	state Exp;
branches;
next	1.240;
commitid	qHxbKaYfo1Z7mM09;

1.240
date	2015.11.30.12.49.35;	author gilles;	state Exp;
branches;
next	1.239;
commitid	ZyOzw2IPUjoaWKi5;

1.239
date	2015.11.05.08.55.09;	author gilles;	state Exp;
branches;
next	1.238;
commitid	TVpp1PxacTHNqZd0;

1.238
date	2015.10.21.16.44.28;	author jsing;	state Exp;
branches;
next	1.237;
commitid	VeKjz2xsP9Q9IzaX;

1.237
date	2015.10.16.21.13.33;	author sthen;	state Exp;
branches;
next	1.236;
commitid	OZlZin0TY3Yru2bR;

1.236
date	2015.10.13.11.32.47;	author eric;	state Exp;
branches;
next	1.235;
commitid	Q4QsC3gfeGQXvaAe;

1.235
date	2015.10.12.20.16.31;	author gilles;	state Exp;
branches;
next	1.234;
commitid	8q1VNZu7VYx0M3IR;

1.234
date	2015.10.02.00.44.30;	author gilles;	state Exp;
branches;
next	1.233;
commitid	ycD3KILo1e7vHFre;

1.233
date	2015.09.07.15.36.53;	author gilles;	state Exp;
branches;
next	1.232;
commitid	8taqn8BdlYqlAC0r;

1.232
date	2015.09.03.05.10.19;	author gilles;	state Exp;
branches;
next	1.231;
commitid	BUUIshzUJ3BcvjTW;

1.231
date	2015.08.15.17.27.43;	author gilles;	state Exp;
branches;
next	1.230;
commitid	7yVWvl1jKD1Ber6v;

1.230
date	2015.05.15.07.34.45;	author gilles;	state Exp;
branches
	1.230.4.1;
next	1.229;
commitid	d6y4b1W64TgzuDAC;

1.229
date	2015.04.19.20.29.12;	author gilles;	state Exp;
branches;
next	1.228;
commitid	bBwp0YicyQAoRflI;

1.228
date	2015.04.06.13.47.00;	author gilles;	state Exp;
branches;
next	1.227;
commitid	R2G5VwW0pSMSIu7K;

1.227
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches
	1.227.2.1;
next	1.226;
commitid	ZBTFreARDSMmzOIV;

1.226
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.225;
commitid	Uu5nFG3wCl0LACBb;

1.225
date	2015.01.14.08.50.32;	author gilles;	state Exp;
branches;
next	1.224;
commitid	kgg1Zfy1T1prIxMe;

1.224
date	2015.01.11.18.25.54;	author gilles;	state Exp;
branches;
next	1.223;
commitid	XMnmxj3Acd6RfZIp;

1.223
date	2015.01.07.18.28.12;	author gilles;	state Exp;
branches;
next	1.222;
commitid	VXNmDHY1UhSgVnZw;

1.222
date	2015.01.06.10.31.09;	author gilles;	state Exp;
branches;
next	1.221;
commitid	tKAUUHnbXd75vdzC;

1.221
date	2014.12.17.15.49.23;	author millert;	state Exp;
branches;
next	1.220;
commitid	cWckc2dm7WMjBT2C;

1.220
date	2014.11.02.21.46.03;	author gilles;	state Exp;
branches;
next	1.219;
commitid	TFHZhLX2yU2MZHMr;

1.219
date	2014.11.02.21.13.32;	author gilles;	state Exp;
branches;
next	1.218;
commitid	nTz7wzWaxzBhFNdg;

1.218
date	2014.10.15.08.09.02;	author gilles;	state Exp;
branches;
next	1.217;
commitid	vGE3mGVwO8jbYedn;

1.217
date	2014.10.04.08.43.24;	author gilles;	state Exp;
branches;
next	1.216;
commitid	tPtWSb8HfuhzWH4G;

1.216
date	2014.10.02.21.27.54;	author gilles;	state Exp;
branches;
next	1.215;
commitid	jaLVC9LCk16ZGWPI;

1.215
date	2014.07.09.12.44.54;	author eric;	state Exp;
branches
	1.215.4.1;
next	1.214;
commitid	4IcOkOZNwhQIYGGx;

1.214
date	2014.07.08.20.14.46;	author eric;	state Exp;
branches;
next	1.213;
commitid	AHjSiMjlXwD7KM7Y;

1.213
date	2014.07.08.07.59.31;	author sobrado;	state Exp;
branches;
next	1.212;
commitid	QejPnWBk7nSpcYUN;

1.212
date	2014.07.04.15.24.46;	author eric;	state Exp;
branches;
next	1.211;
commitid	yoEZ5EbIFWOyYrCf;

1.211
date	2014.05.17.20.07.54;	author chl;	state Exp;
branches;
next	1.210;

1.210
date	2014.04.29.19.13.13;	author reyk;	state Exp;
branches;
next	1.209;

1.209
date	2014.04.29.12.18.27;	author reyk;	state Exp;
branches;
next	1.208;

1.208
date	2014.04.29.10.18.06;	author reyk;	state Exp;
branches;
next	1.207;

1.207
date	2014.04.19.17.04.42;	author gilles;	state Exp;
branches;
next	1.206;

1.206
date	2014.04.19.17.03.42;	author gilles;	state Exp;
branches;
next	1.205;

1.205
date	2014.04.19.16.56.34;	author gilles;	state Exp;
branches;
next	1.204;

1.204
date	2014.04.19.16.52.20;	author gilles;	state Exp;
branches;
next	1.203;

1.203
date	2014.04.19.16.50.28;	author gilles;	state Exp;
branches;
next	1.202;

1.202
date	2014.04.19.16.44.01;	author gilles;	state Exp;
branches;
next	1.201;

1.201
date	2014.04.19.16.26.23;	author gilles;	state Exp;
branches;
next	1.200;

1.200
date	2014.04.09.18.55.19;	author eric;	state Exp;
branches;
next	1.199;

1.199
date	2014.04.09.12.47.23;	author eric;	state Exp;
branches;
next	1.198;

1.198
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.197;

1.197
date	2014.03.14.11.14.11;	author eric;	state Exp;
branches;
next	1.196;

1.196
date	2014.02.17.11.06.54;	author eric;	state Exp;
branches
	1.196.2.1;
next	1.195;

1.195
date	2014.02.04.15.44.05;	author eric;	state Exp;
branches;
next	1.194;

1.194
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.193;

1.193
date	2014.02.04.09.50.31;	author eric;	state Exp;
branches;
next	1.192;

1.192
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.191;

1.191
date	2013.11.28.12.39.23;	author eric;	state Exp;
branches;
next	1.190;

1.190
date	2013.11.28.10.43.37;	author eric;	state Exp;
branches;
next	1.189;

1.189
date	2013.11.18.12.24.26;	author eric;	state Exp;
branches;
next	1.188;

1.188
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.187;

1.187
date	2013.10.28.17.02.08;	author eric;	state Exp;
branches;
next	1.186;

1.186
date	2013.10.27.11.01.47;	author eric;	state Exp;
branches;
next	1.185;

1.185
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.184;

1.184
date	2013.07.19.21.18.54;	author eric;	state Exp;
branches;
next	1.183;

1.183
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.182;

1.182
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.181;

1.181
date	2013.02.21.14.22.52;	author eric;	state Exp;
branches;
next	1.180;

1.180
date	2013.02.16.16.20.07;	author gilles;	state Exp;
branches;
next	1.179;

1.179
date	2013.02.15.17.36.08;	author eric;	state Exp;
branches;
next	1.178;

1.178
date	2013.02.05.11.45.18;	author gilles;	state Exp;
branches;
next	1.177;

1.177
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.176;

1.176
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.175;

1.175
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.174;

1.174
date	2012.11.02.19.30.57;	author eric;	state Exp;
branches;
next	1.173;

1.173
date	2012.10.28.08.46.26;	author eric;	state Exp;
branches;
next	1.172;

1.172
date	2012.10.11.21.24.51;	author gilles;	state Exp;
branches;
next	1.171;

1.171
date	2012.10.09.20.33.02;	author gilles;	state Exp;
branches;
next	1.170;

1.170
date	2012.10.07.15.46.38;	author chl;	state Exp;
branches;
next	1.169;

1.169
date	2012.09.14.19.22.04;	author eric;	state Exp;
branches;
next	1.168;

1.168
date	2012.08.25.10.23.12;	author gilles;	state Exp;
branches;
next	1.167;

1.167
date	2012.08.24.18.46.46;	author eric;	state Exp;
branches;
next	1.166;

1.166
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.165;

1.165
date	2012.08.18.18.18.23;	author gilles;	state Exp;
branches;
next	1.164;

1.164
date	2012.08.18.16.05.54;	author chl;	state Exp;
branches;
next	1.163;

1.163
date	2012.08.10.11.05.55;	author eric;	state Exp;
branches;
next	1.162;

1.162
date	2012.05.08.11.52.57;	author eric;	state Exp;
branches;
next	1.161;

1.161
date	2012.01.29.16.51.00;	author eric;	state Exp;
branches;
next	1.160;

1.160
date	2012.01.29.15.33.08;	author eric;	state Exp;
branches;
next	1.159;

1.159
date	2012.01.29.11.37.32;	author eric;	state Exp;
branches;
next	1.158;

1.158
date	2012.01.27.00.01.04;	author gilles;	state Exp;
branches;
next	1.157;

1.157
date	2012.01.26.23.59.28;	author gilles;	state Exp;
branches;
next	1.156;

1.156
date	2012.01.26.23.18.08;	author gilles;	state Exp;
branches;
next	1.155;

1.155
date	2012.01.21.19.50.30;	author gilles;	state Exp;
branches;
next	1.154;

1.154
date	2012.01.18.13.41.54;	author chl;	state Exp;
branches;
next	1.153;

1.153
date	2012.01.13.14.27.55;	author eric;	state Exp;
branches;
next	1.152;

1.152
date	2012.01.12.12.57.26;	author eric;	state Exp;
branches;
next	1.151;

1.151
date	2011.12.12.17.20.36;	author eric;	state Exp;
branches;
next	1.150;

1.150
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.149;

1.149
date	2011.10.03.19.20.51;	author gilles;	state Exp;
branches;
next	1.148;

1.148
date	2011.09.28.18.19.10;	author gilles;	state Exp;
branches;
next	1.147;

1.147
date	2011.09.12.20.47.15;	author gilles;	state Exp;
branches;
next	1.146;

1.146
date	2011.09.01.19.56.49;	author eric;	state Exp;
branches;
next	1.145;

1.145
date	2011.09.01.09.42.15;	author chl;	state Exp;
branches;
next	1.144;

1.144
date	2011.08.31.18.56.30;	author gilles;	state Exp;
branches;
next	1.143;

1.143
date	2011.08.27.22.32.41;	author gilles;	state Exp;
branches;
next	1.142;

1.142
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.141;

1.141
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.140;

1.140
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.139;

1.139
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.138;

1.138
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.137;

1.137
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.136;

1.136
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.135;

1.135
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.134;

1.134
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.133;

1.133
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.132;

1.132
date	2010.04.24.19.16.11;	author chl;	state Exp;
branches;
next	1.131;

1.131
date	2010.04.21.20.32.57;	author gilles;	state Exp;
branches;
next	1.130;

1.130
date	2010.04.19.10.26.40;	author gilles;	state Exp;
branches;
next	1.129;

1.129
date	2010.04.19.10.12.48;	author gilles;	state Exp;
branches;
next	1.128;

1.128
date	2009.12.31.15.37.55;	author gilles;	state Exp;
branches;
next	1.127;

1.127
date	2009.12.13.22.02.55;	author jacekm;	state Exp;
branches;
next	1.126;

1.126
date	2009.11.16.10.38.11;	author jacekm;	state Exp;
branches;
next	1.125;

1.125
date	2009.11.13.11.40.06;	author jacekm;	state Exp;
branches;
next	1.124;

1.124
date	2009.11.13.11.37.27;	author jacekm;	state Exp;
branches;
next	1.123;

1.123
date	2009.11.05.23.30.01;	author gilles;	state Exp;
branches;
next	1.122;

1.122
date	2009.10.19.20.48.13;	author gilles;	state Exp;
branches;
next	1.121;

1.121
date	2009.10.06.18.20.44;	author gilles;	state Exp;
branches;
next	1.120;

1.120
date	2009.09.12.12.24.51;	author jacekm;	state Exp;
branches;
next	1.119;

1.119
date	2009.09.12.09.50.31;	author gilles;	state Exp;
branches;
next	1.118;

1.118
date	2009.09.12.09.38.45;	author gilles;	state Exp;
branches;
next	1.117;

1.117
date	2009.09.12.09.22.33;	author gilles;	state Exp;
branches;
next	1.116;

1.116
date	2009.09.12.09.01.19;	author gilles;	state Exp;
branches;
next	1.115;

1.115
date	2009.09.01.15.23.02;	author jacekm;	state Exp;
branches;
next	1.114;

1.114
date	2009.08.12.13.32.19;	author jacekm;	state Exp;
branches;
next	1.113;

1.113
date	2009.08.08.00.02.22;	author gilles;	state Exp;
branches;
next	1.112;

1.112
date	2009.08.07.21.59.01;	author gilles;	state Exp;
branches;
next	1.111;

1.111
date	2009.08.07.20.21.48;	author gilles;	state Exp;
branches;
next	1.110;

1.110
date	2009.08.06.17.09.13;	author gilles;	state Exp;
branches;
next	1.109;

1.109
date	2009.08.01.15.33.28;	author gilles;	state Exp;
branches;
next	1.108;

1.108
date	2009.07.19.19.06.02;	author jacekm;	state Exp;
branches;
next	1.107;

1.107
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.106;

1.106
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.105;

1.105
date	2009.06.01.14.53.18;	author gilles;	state Exp;
branches;
next	1.104;

1.104
date	2009.05.31.18.34.48;	author gilles;	state Exp;
branches;
next	1.103;

1.103
date	2009.05.30.16.22.07;	author gilles;	state Exp;
branches;
next	1.102;

1.102
date	2009.05.28.08.50.08;	author jacekm;	state Exp;
branches;
next	1.101;

1.101
date	2009.05.28.08.48.46;	author jacekm;	state Exp;
branches;
next	1.100;

1.100
date	2009.05.27.13.14.18;	author jacekm;	state Exp;
branches;
next	1.99;

1.99
date	2009.05.27.13.11.39;	author jacekm;	state Exp;
branches;
next	1.98;

1.98
date	2009.05.27.13.09.07;	author jacekm;	state Exp;
branches;
next	1.97;

1.97
date	2009.05.25.13.29.47;	author jacekm;	state Exp;
branches;
next	1.96;

1.96
date	2009.05.24.15.47.31;	author jacekm;	state Exp;
branches;
next	1.95;

1.95
date	2009.05.24.14.58.43;	author jacekm;	state Exp;
branches;
next	1.94;

1.94
date	2009.05.24.14.22.24;	author jacekm;	state Exp;
branches;
next	1.93;

1.93
date	2009.05.20.16.12.11;	author jacekm;	state Exp;
branches;
next	1.92;

1.92
date	2009.05.20.14.29.44;	author gilles;	state Exp;
branches;
next	1.91;

1.91
date	2009.05.19.12.33.53;	author jacekm;	state Exp;
branches;
next	1.90;

1.90
date	2009.05.19.11.42.52;	author jacekm;	state Exp;
branches;
next	1.89;

1.89
date	2009.05.18.20.23.35;	author jacekm;	state Exp;
branches;
next	1.88;

1.88
date	2009.05.14.15.05.12;	author eric;	state Exp;
branches;
next	1.87;

1.87
date	2009.05.14.08.29.37;	author jacekm;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.10.14.24.19;	author jacekm;	state Exp;
branches;
next	1.85;

1.85
date	2009.05.10.13.06.23;	author jacekm;	state Exp;
branches;
next	1.84;

1.84
date	2009.05.10.11.29.40;	author jacekm;	state Exp;
branches;
next	1.83;

1.83
date	2009.05.10.11.23.04;	author jacekm;	state Exp;
branches;
next	1.82;

1.82
date	2009.05.09.23.23.38;	author jacekm;	state Exp;
branches;
next	1.81;

1.81
date	2009.05.09.20.03.07;	author jacekm;	state Exp;
branches;
next	1.80;

1.80
date	2009.05.09.18.59.09;	author jacekm;	state Exp;
branches;
next	1.79;

1.79
date	2009.04.28.21.56.45;	author jacekm;	state Exp;
branches;
next	1.78;

1.78
date	2009.04.28.21.55.16;	author jacekm;	state Exp;
branches;
next	1.77;

1.77
date	2009.04.27.20.17.21;	author jacekm;	state Exp;
branches;
next	1.76;

1.76
date	2009.04.27.16.20.34;	author jacekm;	state Exp;
branches;
next	1.75;

1.75
date	2009.04.27.16.10.20;	author jacekm;	state Exp;
branches;
next	1.74;

1.74
date	2009.04.24.15.26.59;	author jacekm;	state Exp;
branches;
next	1.73;

1.73
date	2009.04.24.09.38.11;	author jacekm;	state Exp;
branches;
next	1.72;

1.72
date	2009.04.24.08.35.48;	author jacekm;	state Exp;
branches;
next	1.71;

1.71
date	2009.04.24.08.32.12;	author jacekm;	state Exp;
branches;
next	1.70;

1.70
date	2009.04.20.18.48.23;	author jacekm;	state Exp;
branches;
next	1.69;

1.69
date	2009.04.20.17.40.38;	author jacekm;	state Exp;
branches;
next	1.68;

1.68
date	2009.04.20.17.07.01;	author jacekm;	state Exp;
branches;
next	1.67;

1.67
date	2009.04.19.12.48.27;	author jacekm;	state Exp;
branches;
next	1.66;

1.66
date	2009.04.16.15.35.06;	author jacekm;	state Exp;
branches;
next	1.65;

1.65
date	2009.04.09.20.19.03;	author todd;	state Exp;
branches;
next	1.64;

1.64
date	2009.04.09.19.49.34;	author jacekm;	state Exp;
branches;
next	1.63;

1.63
date	2009.03.15.19.32.10;	author gilles;	state Exp;
branches;
next	1.62;

1.62
date	2009.03.15.18.12.15;	author gilles;	state Exp;
branches;
next	1.61;

1.61
date	2009.03.11.09.58.20;	author gilles;	state Exp;
branches;
next	1.60;

1.60
date	2009.03.10.22.33.26;	author jacekm;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.08.19.11.22;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2009.02.22.11.59.12;	author jacekm;	state Exp;
branches;
next	1.57;

1.57
date	2009.02.19.11.33.25;	author jacekm;	state Exp;
branches;
next	1.56;

1.56
date	2009.02.18.00.29.52;	author gilles;	state Exp;
branches;
next	1.55;

1.55
date	2009.02.18.00.17.39;	author gilles;	state Exp;
branches;
next	1.54;

1.54
date	2009.02.17.21.53.55;	author gilles;	state Exp;
branches;
next	1.53;

1.53
date	2009.02.13.19.59.49;	author jacekm;	state Exp;
branches;
next	1.52;

1.52
date	2009.01.30.21.52.55;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2009.01.30.21.40.21;	author gilles;	state Exp;
branches;
next	1.50;

1.50
date	2009.01.30.21.22.33;	author gilles;	state Exp;
branches;
next	1.49;

1.49
date	2009.01.30.17.34.58;	author gilles;	state Exp;
branches;
next	1.48;

1.48
date	2009.01.30.16.37.52;	author gilles;	state Exp;
branches;
next	1.47;

1.47
date	2009.01.29.21.59.15;	author jacekm;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.29.15.40.35;	author gilles;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.29.15.27.34;	author gilles;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.29.15.20.34;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2009.01.28.18.10.19;	author jacekm;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.28.17.29.11;	author jacekm;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.28.11.27.57;	author gilles;	state Exp;
branches;
next	1.40;

1.40
date	2009.01.12.19.56.27;	author jacekm;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.04.00.58.59;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.37;

1.37
date	2008.12.22.13.21.39;	author jacekm;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.22.00.44.32;	author jacekm;	state Exp;
branches;
next	1.35;

1.35
date	2008.12.21.19.27.57;	author jacekm;	state Exp;
branches;
next	1.34;

1.34
date	2008.12.21.18.51.08;	author gilles;	state Exp;
branches;
next	1.33;

1.33
date	2008.12.21.02.18.46;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.20.00.18.03;	author gilles;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.18.23.57.17;	author jacekm;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.18.23.49.56;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.18.23.38.12;	author jacekm;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.18.15.11.21;	author jacekm;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.13.23.19.34;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.07.15.41.16;	author jacekm;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.07.15.38.35;	author jacekm;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.07.01.03.25;	author jacekm;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.06.14.58.09;	author jacekm;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.06.14.30.51;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.06.04.49.52;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.06.02.43.58;	author jacekm;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.05.17.29.11;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.04.23.02.12;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.04.04.09.55;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.04.02.04.50;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.04.01.16.14;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.03.17.58.00;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.25.20.35.54;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.25.15.58.14;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.25.15.55.13;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.24.23.55.25;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.17.21.56.18;	author chl;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.17.21.52.00;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.17.21.50.43;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.17.20.11.27;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.11.01.08.08;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.10.23.18.47;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.10.17.24.24;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;

1.196.2.1
date	2015.04.19.20.29.43;	author gilles;	state Exp;
branches;
next	;
commitid	hcouPHQe4WQRrGA6;

1.215.4.1
date	2015.04.19.20.30.06;	author gilles;	state Exp;
branches;
next	1.215.4.2;
commitid	SFi8NK6NRchJSgfL;

1.215.4.2
date	2015.10.02.01.33.33;	author gilles;	state Exp;
branches;
next	;
commitid	2Q56YgF5PzqMcagu;

1.227.2.1
date	2015.04.19.20.30.33;	author gilles;	state Exp;
branches;
next	1.227.2.2;
commitid	V7mUb6iisKdaCe7F;

1.227.2.2
date	2015.10.02.01.28.43;	author gilles;	state Exp;
branches;
next	;
commitid	pAamrt3DJscJjb10;

1.230.4.1
date	2015.10.02.00.55.02;	author gilles;	state Exp;
branches;
next	;
commitid	5SntIHNUPMG4dcQ1;

1.268.2.1
date	2016.05.16.19.29.13;	author gilles;	state Exp;
branches;
next	1.268.2.2;
commitid	EksDywL8AfqDY78p;

1.268.2.2
date	2016.10.13.15.44.09;	author gilles;	state Exp;
branches;
next	;
commitid	TDfBlWg3euClvuuT;

1.284.4.1
date	2016.10.04.00.12.27;	author jsg;	state Exp;
branches;
next	1.284.4.2;
commitid	c3en7uMAbGQaWM36;

1.284.4.2
date	2016.10.13.15.46.05;	author gilles;	state Exp;
branches;
next	;
commitid	CJ19Nz5R2982Bxn3;


desc
@@


1.307
log
@rename function
@
text
@/*	$OpenBSD: smtp_session.c,v 1.306 2017/08/30 06:43:42 eric Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2008-2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <limits.h>
#include <inttypes.h>
#include <openssl/ssl.h>
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <vis.h>

#include "smtpd.h"
#include "log.h"
#include "ssl.h"

#define	DATA_HIWAT			65535
#define	APPEND_DOMAIN_BUFFER_SIZE	4096

enum smtp_state {
	STATE_NEW = 0,
	STATE_CONNECTED,
	STATE_TLS,
	STATE_HELO,
	STATE_AUTH_INIT,
	STATE_AUTH_USERNAME,
	STATE_AUTH_PASSWORD,
	STATE_AUTH_FINALIZE,
	STATE_BODY,
	STATE_QUIT,
};

enum session_flags {
	SF_EHLO			= 0x0001,
	SF_8BITMIME		= 0x0002,
	SF_SECURE		= 0x0004,
	SF_AUTHENTICATED	= 0x0008,
	SF_BOUNCE		= 0x0010,
	SF_VERIFIED		= 0x0020,
	SF_BADINPUT		= 0x0080,
};

enum message_flags {
	MF_QUEUE_ENVELOPE_FAIL	= 0x00001,
	MF_ERROR_SIZE		= 0x01000,
	MF_ERROR_IO		= 0x02000,
	MF_ERROR_LOOP		= 0x04000,
	MF_ERROR_MALFORMED     	= 0x08000,
	MF_ERROR_RESOURCES     	= 0x10000,
};
#define MF_ERROR	(MF_ERROR_SIZE | MF_ERROR_IO | MF_ERROR_LOOP | MF_ERROR_MALFORMED | MF_ERROR_RESOURCES)

enum smtp_command {
	CMD_HELO = 0,
	CMD_EHLO,
	CMD_STARTTLS,
	CMD_AUTH,
	CMD_MAIL_FROM,
	CMD_RCPT_TO,
	CMD_DATA,
	CMD_RSET,
	CMD_QUIT,
	CMD_HELP,
	CMD_WIZ,
	CMD_NOOP,
};

struct smtp_rcpt {
	TAILQ_ENTRY(smtp_rcpt)	 entry;
 	struct mailaddr		 maddr;
	size_t			 destcount;
};

struct smtp_tx {
	struct smtp_session	*session;
	uint32_t		 msgid;

	struct envelope		 evp;
	size_t			 rcptcount;
	size_t			 destcount;
	TAILQ_HEAD(, smtp_rcpt)	 rcpts;

	size_t			 datain;
	size_t			 odatalen;
	FILE			*ofile;
	int			 hdrdone;
	int			 rcvcount;
	int			 dataeom;

	int			 msgflags;
	int			 msgcode;

	int			 skiphdr;
	struct rfc2822_parser	 rfc2822_parser;
};

struct smtp_session {
	uint64_t		 id;
	struct io		*io;
	struct listener		*listener;
	void			*ssl_ctx;
	struct sockaddr_storage	 ss;
	char			 hostname[HOST_NAME_MAX+1];
	char			 smtpname[HOST_NAME_MAX+1];

	int			 flags;
	enum smtp_state		 state;

	char			 helo[LINE_MAX];
	char			 cmd[LINE_MAX];
	char			 username[SMTPD_MAXMAILADDRSIZE];

	size_t			 mailcount;
	struct event		 pause;

	struct smtp_tx		*tx;
};

#define ADVERTISE_TLS(s) \
	((s)->listener->flags & F_STARTTLS && !((s)->flags & SF_SECURE))

#define ADVERTISE_AUTH(s) \
	((s)->listener->flags & F_AUTH && (s)->flags & SF_SECURE && \
	 !((s)->flags & SF_AUTHENTICATED))

#define ADVERTISE_EXT_DSN(s) \
	((s)->listener->flags & F_EXT_DSN)

static int smtp_mailaddr(struct mailaddr *, char *, int, char **, const char *);
static void smtp_session_init(void);
static int smtp_lookup_servername(struct smtp_session *);
static void smtp_connected(struct smtp_session *);
static void smtp_send_banner(struct smtp_session *);
static void smtp_tls_verified(struct smtp_session *);
static void smtp_io(struct io *, int, void *);
static void smtp_data_io_done(struct smtp_session *);
static void smtp_enter_state(struct smtp_session *, int);
static void smtp_reply(struct smtp_session *, char *, ...);
static void smtp_command(struct smtp_session *, char *);
static int smtp_parse_mail_args(struct smtp_session *, char *);
static int smtp_parse_rcpt_args(struct smtp_session *, char *);
static void smtp_rfc4954_auth_plain(struct smtp_session *, char *);
static void smtp_rfc4954_auth_login(struct smtp_session *, char *);
static void smtp_message_end(struct smtp_session *);
static int smtp_message_printf(struct smtp_session *, const char *, ...);
static void smtp_free(struct smtp_session *, const char *);
static const char *smtp_strstate(int);
static int smtp_verify_certificate(struct smtp_session *);
static uint8_t dsn_notify_str_to_uint8(const char *);
static void smtp_auth_failure_pause(struct smtp_session *);
static void smtp_auth_failure_resume(int, short, void *);

static int  smtp_tx(struct smtp_session *);
static void smtp_tx_free(struct smtp_tx *);

static void smtp_queue_create_message(struct smtp_session *);
static void smtp_queue_open_message(struct smtp_session *);
static void smtp_queue_commit(struct smtp_session *);
static void smtp_queue_rollback(struct smtp_session *);

static void smtp_dataline(struct smtp_session *, const char *);

static struct { int code; const char *cmd; } commands[] = {
	{ CMD_HELO,		"HELO" },
	{ CMD_EHLO,		"EHLO" },
	{ CMD_STARTTLS,		"STARTTLS" },
	{ CMD_AUTH,		"AUTH" },
	{ CMD_MAIL_FROM,	"MAIL FROM" },
	{ CMD_RCPT_TO,		"RCPT TO" },
	{ CMD_DATA,		"DATA" },
	{ CMD_RSET,		"RSET" },
	{ CMD_QUIT,		"QUIT" },
	{ CMD_HELP,		"HELP" },
	{ CMD_WIZ,		"WIZ" },
	{ CMD_NOOP,		"NOOP" },
	{ -1, NULL },
};

static struct tree wait_lka_ptr;
static struct tree wait_lka_helo;
static struct tree wait_lka_mail;
static struct tree wait_lka_rcpt;
static struct tree wait_filter;
static struct tree wait_filter_data;
static struct tree wait_parent_auth;
static struct tree wait_queue_msg;
static struct tree wait_queue_fd;
static struct tree wait_queue_commit;
static struct tree wait_ssl_init;
static struct tree wait_ssl_verify;

static void
header_default_callback(const struct rfc2822_header *hdr, void *arg)
{
	struct smtp_session    *s = arg;
	struct rfc2822_line    *l;

	if (smtp_message_printf(s, "%s:", hdr->name) == -1)
		return;

	TAILQ_FOREACH(l, &hdr->lines, next)
		if (smtp_message_printf(s, "%s\n", l->buffer) == -1)
			return;
}

static void
dataline_callback(const char *line, void *arg)
{
	struct smtp_session	*s = arg;

	smtp_message_printf(s, "%s\n", line);
}

static void
header_bcc_callback(const struct rfc2822_header *hdr, void *arg)
{
}

static void
header_append_domain_buffer(char *buffer, char *domain, size_t len)
{
	size_t	i;
	int	escape, quote, comment, bracket;
	int	has_domain, has_bracket, has_group;
	int	pos_bracket, pos_component, pos_insert;
	char	copy[APPEND_DOMAIN_BUFFER_SIZE];

	i = 0;
	escape = quote = comment = bracket = 0;
	has_domain = has_bracket = has_group = 0;
	pos_bracket = pos_insert = pos_component = 0;
	for (i = 0; buffer[i]; ++i) {
		if (buffer[i] == '(' && !escape && !quote)
			comment++;
		if (buffer[i] == '"' && !escape && !comment)
			quote = !quote;
		if (buffer[i] == ')' && !escape && !quote && comment)
			comment--;
		if (buffer[i] == '\\' && !escape && !comment && !quote)
			escape = 1;
		else
			escape = 0;
		if (buffer[i] == '<' && !escape && !comment && !quote && !bracket) {
			bracket++;
			has_bracket = 1;
		}
		if (buffer[i] == '>' && !escape && !comment && !quote && bracket) {
			bracket--;
			pos_bracket = i;
		}
		if (buffer[i] == '@@' && !escape && !comment && !quote)
			has_domain = 1;
		if (buffer[i] == ':' && !escape && !comment && !quote)
			has_group = 1;

		/* update insert point if not in comment and not on a whitespace */
		if (!comment && buffer[i] != ')' && !isspace((unsigned char)buffer[i]))
			pos_component = i;
	}

	/* parse error, do not attempt to modify */
	if (escape || quote || comment || bracket)
		return;

	/* domain already present, no need to modify */
	if (has_domain)
		return;

	/* address is group, skip */
	if (has_group)
		return;

	/* there's an address between brackets, just append domain */
	if (has_bracket) {
		pos_bracket--;
		while (isspace((unsigned char)buffer[pos_bracket]))
			pos_bracket--;
		if (buffer[pos_bracket] == '<')
			return;
		pos_insert = pos_bracket + 1;
	}
	else {
		/* otherwise append address to last component */
		pos_insert = pos_component + 1;

		/* empty address */
                if (buffer[pos_component] == '\0' ||
		    isspace((unsigned char)buffer[pos_component]))
                        return;
	}

	if (snprintf(copy, sizeof copy, "%.*s@@%s%s",
		(int)pos_insert, buffer,
		domain,
		buffer+pos_insert) >= (int)sizeof copy)
		return;

	memcpy(buffer, copy, len);
}

static void
header_domain_append_callback(const struct rfc2822_header *hdr, void *arg)
{
	struct smtp_session    *s = arg;
	struct rfc2822_line    *l;
	size_t			i, j;
	int			escape, quote, comment, skip;
	char			buffer[APPEND_DOMAIN_BUFFER_SIZE];

	if (smtp_message_printf(s, "%s:", hdr->name) == -1)
		return;

	i = j = 0;
	escape = quote = comment = skip = 0;
	memset(buffer, 0, sizeof buffer);

	TAILQ_FOREACH(l, &hdr->lines, next) {
		for (i = 0; i < strlen(l->buffer); ++i) {
			if (l->buffer[i] == '(' && !escape && !quote)
				comment++;
			if (l->buffer[i] == '"' && !escape && !comment)
				quote = !quote;
			if (l->buffer[i] == ')' && !escape && !quote && comment)
				comment--;
			if (l->buffer[i] == '\\' && !escape && !comment && !quote)
				escape = 1;
			else
				escape = 0;

			/* found a separator, buffer contains a full address */
			if (l->buffer[i] == ',' && !escape && !quote && !comment) {
				if (!skip && j + strlen(s->listener->hostname) + 1 < sizeof buffer)
					header_append_domain_buffer(buffer, s->listener->hostname, sizeof buffer);
				if (smtp_message_printf(s, "%s,", buffer) == -1)
					return;
				j = 0;
				skip = 0;
				memset(buffer, 0, sizeof buffer);
			}
			else {
				if (skip) {
					if (smtp_message_printf(s, "%c",
					    l->buffer[i]) == -1)
						return;
				}
				else {
					buffer[j++] = l->buffer[i];
					if (j == sizeof (buffer) - 1) {
						if (smtp_message_printf(s, "%s",
						    buffer) != -1)
							return;
						skip = 1;
						j = 0;
						memset(buffer, 0, sizeof buffer);
					}
				}
			}
		}
		if (skip) {
			if (smtp_message_printf(s, "\n") == -1)
				return;
		}
		else {
			buffer[j++] = '\n';
			if (j == sizeof (buffer) - 1) {
				if (smtp_message_printf(s, "%s", buffer) == -1)
					return;
				skip = 1;
				j = 0;
				memset(buffer, 0, sizeof buffer);
			}
		}
	}

	/* end of header, if buffer is not empty we'll process it */
	if (buffer[0]) {
		if (j + strlen(s->listener->hostname) + 1 < sizeof buffer)
			header_append_domain_buffer(buffer, s->listener->hostname, sizeof buffer);
		smtp_message_printf(s, "%s", buffer);
	}
}

static void
header_address_rewrite_buffer(char *buffer, const char *address, size_t len)
{
	size_t	i;
	int	address_len;
	int	escape, quote, comment, bracket;
	int	has_bracket, has_group;
	int	pos_bracket_beg, pos_bracket_end, pos_component_beg, pos_component_end;
	int	insert_beg, insert_end;
	char	copy[APPEND_DOMAIN_BUFFER_SIZE];

	escape = quote = comment = bracket = 0;
	has_bracket = has_group = 0;
	pos_bracket_beg = pos_bracket_end = pos_component_beg = pos_component_end = 0;
	for (i = 0; buffer[i]; ++i) {
		if (buffer[i] == '(' && !escape && !quote)
			comment++;
		if (buffer[i] == '"' && !escape && !comment)
			quote = !quote;
		if (buffer[i] == ')' && !escape && !quote && comment)
			comment--;
		if (buffer[i] == '\\' && !escape && !comment && !quote)
			escape = 1;
		else
			escape = 0;
		if (buffer[i] == '<' && !escape && !comment && !quote && !bracket) {
			bracket++;
			has_bracket = 1;
			pos_bracket_beg = i+1;
		}
		if (buffer[i] == '>' && !escape && !comment && !quote && bracket) {
			bracket--;
			pos_bracket_end = i;
		}
		if (buffer[i] == ':' && !escape && !comment && !quote)
			has_group = 1;

		/* update insert point if not in comment and not on a whitespace */
		if (!comment && buffer[i] != ')' && !isspace((unsigned char)buffer[i]))
			pos_component_end = i;
	}

	/* parse error, do not attempt to modify */
	if (escape || quote || comment || bracket)
		return;

	/* address is group, skip */
	if (has_group)
		return;

	/* there's an address between brackets, just replace everything brackets */
	if (has_bracket) {
		insert_beg = pos_bracket_beg;
		insert_end = pos_bracket_end;
	}
	else {
		if (pos_component_end == 0)
			pos_component_beg = 0;
		else {
			for (pos_component_beg = pos_component_end; pos_component_beg >= 0; --pos_component_beg)
				if (buffer[pos_component_beg] == ')' || isspace(buffer[pos_component_beg]))
					break;
			pos_component_beg += 1;
			pos_component_end += 1;
		}
		insert_beg = pos_component_beg;
		insert_end = pos_component_end;
	}

	/* check that masquerade won' t overflow */
	address_len = strlen(address);
	if (strlen(buffer) - (insert_end - insert_beg) + address_len >= len)
		return;

	(void)strlcpy(copy, buffer, sizeof copy);
	(void)strlcpy(copy+insert_beg, address, sizeof (copy) - insert_beg);
	(void)strlcat(copy, buffer+insert_end, sizeof (copy));
	memcpy(buffer, copy, len);
}

static void
header_masquerade_callback(const struct rfc2822_header *hdr, void *arg)
{
	struct smtp_session    *s = arg;
	struct rfc2822_line    *l;
	size_t			i, j;
	int			escape, quote, comment, skip;
	char			buffer[APPEND_DOMAIN_BUFFER_SIZE];

	if (smtp_message_printf(s, "%s:", hdr->name) == -1)
		return;

	j = 0;
	escape = quote = comment = skip = 0;
	memset(buffer, 0, sizeof buffer);

	TAILQ_FOREACH(l, &hdr->lines, next) {
		for (i = 0; i < strlen(l->buffer); ++i) {
			if (l->buffer[i] == '(' && !escape && !quote)
				comment++;
			if (l->buffer[i] == '"' && !escape && !comment)
				quote = !quote;
			if (l->buffer[i] == ')' && !escape && !quote && comment)
				comment--;
			if (l->buffer[i] == '\\' && !escape && !comment && !quote)
				escape = 1;
			else
				escape = 0;

			/* found a separator, buffer contains a full address */
			if (l->buffer[i] == ',' && !escape && !quote && !comment) {
				if (!skip && j + strlen(s->listener->hostname) + 1 < sizeof buffer) {
					header_append_domain_buffer(buffer, s->listener->hostname, sizeof buffer);
					header_address_rewrite_buffer(buffer, mailaddr_to_text(&s->tx->evp.sender),
					    sizeof buffer);
				}
				if (smtp_message_printf(s, "%s,", buffer) == -1)
					return;
				j = 0;
				skip = 0;
				memset(buffer, 0, sizeof buffer);
			}
			else {
				if (skip) {
					if (smtp_message_printf(s, "%c", l->buffer[i]) == -1)
						return;
				}
				else {
					buffer[j++] = l->buffer[i];
					if (j == sizeof (buffer) - 1) {
						if (smtp_message_printf(s, "%s", buffer) == -1)
							return;
						skip = 1;
						j = 0;
						memset(buffer, 0, sizeof buffer);
					}
				}
			}
		}
		if (skip) {
			if (smtp_message_printf(s, "\n") == -1)
				return;
		}
		else {
			buffer[j++] = '\n';
			if (j == sizeof (buffer) - 1) {
				if (smtp_message_printf(s, "%s", buffer) == -1)
					return;
				skip = 1;
				j = 0;
				memset(buffer, 0, sizeof buffer);
			}
		}
	}

	/* end of header, if buffer is not empty we'll process it */
	if (buffer[0]) {
		if (j + strlen(s->listener->hostname) + 1 < sizeof buffer) {
			header_append_domain_buffer(buffer, s->listener->hostname, sizeof buffer);
			header_address_rewrite_buffer(buffer, mailaddr_to_text(&s->tx->evp.sender),
			    sizeof buffer);
		}
		smtp_message_printf(s, "%s", buffer);
	}
}

static void
header_missing_callback(const char *header, void *arg)
{
	struct smtp_session	*s = arg;

	if (strcasecmp(header, "message-id") == 0)
		smtp_message_printf(s, "Message-Id: <%016"PRIx64"@@%s>\n",
		    generate_uid(), s->listener->hostname);

	if (strcasecmp(header, "date") == 0)
		smtp_message_printf(s, "Date: %s\n", time_to_text(time(NULL)));
}

static void
smtp_session_init(void)
{
	static int	init = 0;

	if (!init) {
		tree_init(&wait_lka_ptr);
		tree_init(&wait_lka_helo);
		tree_init(&wait_lka_mail);
		tree_init(&wait_lka_rcpt);
		tree_init(&wait_filter);
		tree_init(&wait_filter_data);
		tree_init(&wait_parent_auth);
		tree_init(&wait_queue_msg);
		tree_init(&wait_queue_fd);
		tree_init(&wait_queue_commit);
		tree_init(&wait_ssl_init);
		tree_init(&wait_ssl_verify);
		init = 1;
	}
}

int
smtp_session(struct listener *listener, int sock,
    const struct sockaddr_storage *ss, const char *hostname)
{
	struct smtp_session	*s;

	log_debug("debug: smtp: new client on listener: %p", listener);

	smtp_session_init();

	if ((s = calloc(1, sizeof(*s))) == NULL)
		return (-1);

	s->id = generate_uid();
	s->listener = listener;
	memmove(&s->ss, ss, sizeof(*ss));
	s->io = io_new();
	io_set_callback(s->io, smtp_io, s);
	io_set_fd(s->io, sock);
	io_set_timeout(s->io, SMTPD_SESSION_TIMEOUT * 1000);
	io_set_write(s->io);

	s->state = STATE_NEW;

	(void)strlcpy(s->smtpname, listener->hostname, sizeof(s->smtpname));

	log_trace(TRACE_SMTP, "smtp: %p: connected to listener %p "
	    "[hostname=%s, port=%d, tag=%s]", s, listener,
	    listener->hostname, ntohs(listener->port), listener->tag);

	/* For local enqueueing, the hostname is already set */
	if (hostname) {
		s->flags |= SF_AUTHENTICATED;
		/* A bit of a hack */
		if (!strcmp(hostname, "localhost"))
			s->flags |= SF_BOUNCE;
		(void)strlcpy(s->hostname, hostname, sizeof(s->hostname));
		if (smtp_lookup_servername(s))
			smtp_connected(s);
	} else {
		m_create(p_lka,  IMSG_SMTP_DNS_PTR, 0, 0, -1);
		m_add_id(p_lka, s->id);
		m_add_sockaddr(p_lka, (struct sockaddr *)&s->ss);
		m_close(p_lka);
		tree_xset(&wait_lka_ptr, s->id, s);
	}

	/* session may have been freed by now */

	return (0);
}

void
smtp_session_imsg(struct mproc *p, struct imsg *imsg)
{
	struct ca_cert_resp_msg       	*resp_ca_cert;
	struct ca_vrfy_resp_msg       	*resp_ca_vrfy;
	struct smtp_session		*s;
	struct smtp_rcpt		*rcpt;
	void				*ssl;
	char				 user[LOGIN_NAME_MAX];
	struct msg			 m;
	const char			*line, *helo;
	uint64_t			 reqid, evpid;
	uint32_t			 msgid;
	int				 status, success, dnserror;
	void				*ssl_ctx;

	switch (imsg->hdr.type) {
	case IMSG_SMTP_DNS_PTR:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &dnserror);
		if (dnserror)
			line = "<unknown>";
		else
			m_get_string(&m, &line);
		m_end(&m);
		s = tree_xpop(&wait_lka_ptr, reqid);
		(void)strlcpy(s->hostname, line, sizeof s->hostname);
		if (smtp_lookup_servername(s))
			smtp_connected(s);
		return;

	case IMSG_SMTP_CHECK_SENDER:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &status);
		m_end(&m);
		s = tree_xpop(&wait_lka_mail, reqid);
		switch (status) {
		case LKA_OK:
			smtp_queue_create_message(s);

			/* sender check passed, override From callback if masquerading */
			if (s->listener->flags & F_MASQUERADE)
				rfc2822_header_callback(&s->tx->rfc2822_parser, "from",
				    header_masquerade_callback, s);
			break;

		case LKA_PERMFAIL:
			smtp_tx_free(s->tx);
			smtp_reply(s, "%d %s", 530, "Sender rejected");
			break;
		case LKA_TEMPFAIL:
			smtp_tx_free(s->tx);
			smtp_reply(s, "421 %s: Temporary Error",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
			break;
		}
		return;

	case IMSG_SMTP_EXPAND_RCPT:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &status);
		m_get_string(&m, &line);
		m_end(&m);
		s = tree_xpop(&wait_lka_rcpt, reqid);
		switch (status) {
		case LKA_OK:
			fatalx("unexpected ok");
		case LKA_PERMFAIL:
			smtp_reply(s, "%s", line);
			break;
		case LKA_TEMPFAIL:
			smtp_reply(s, "%s", line);
		}
		return;

	case IMSG_SMTP_LOOKUP_HELO:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		s = tree_xpop(&wait_lka_helo, reqid);
		m_get_int(&m, &status);
		if (status == LKA_OK) {
			m_get_string(&m, &helo);
			(void)strlcpy(s->smtpname, helo, sizeof(s->smtpname));
		}
		m_end(&m);
		smtp_connected(s);
		return;

	case IMSG_SMTP_MESSAGE_CREATE:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &success);
		s = tree_xpop(&wait_queue_msg, reqid);
		if (success) {
			m_get_msgid(&m, &msgid);
			s->tx->msgid = msgid;
			s->tx->evp.id = msgid_to_evpid(msgid);
			s->tx->rcptcount = 0;
			smtp_reply(s, "250 %s: Ok",
			    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
		} else {
			smtp_tx_free(s->tx);
			smtp_reply(s, "421 %s: Temporary Error",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
			smtp_enter_state(s, STATE_QUIT);
		}
		m_end(&m);
		return;

	case IMSG_SMTP_MESSAGE_OPEN:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &success);
		m_end(&m);

		s = tree_xpop(&wait_queue_fd, reqid);
		if (!success || imsg->fd == -1) {
			if (imsg->fd != -1)
				close(imsg->fd);
			smtp_reply(s, "421 %s: Temporary Error",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
			smtp_enter_state(s, STATE_QUIT);
			return;
		}

		log_debug("smtp: %p: fd %d from queue", s, imsg->fd);

		tree_xset(&wait_filter, s->id, s);
		smtp_filter_fd(s->id, imsg->fd);
		return;

	case IMSG_QUEUE_ENVELOPE_SUBMIT:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &success);
		s = tree_xget(&wait_lka_rcpt, reqid);
		if (success) {
			m_get_evpid(&m, &evpid);
			s->tx->destcount++;
		}
		else
			s->tx->msgflags |= MF_QUEUE_ENVELOPE_FAIL;
		m_end(&m);
		return;

	case IMSG_QUEUE_ENVELOPE_COMMIT:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &success);
		m_end(&m);
		if (!success)
			fatalx("commit evp failed: not supposed to happen");
		s = tree_xpop(&wait_lka_rcpt, reqid);
		if (s->tx->msgflags & MF_QUEUE_ENVELOPE_FAIL) {
			/*
			 * If an envelope failed, we can't cancel the last
			 * RCPT only so we must cancel the whole transaction
			 * and close the connection.
			 */
			smtp_reply(s, "421 %s: Temporary failure",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
			smtp_enter_state(s, STATE_QUIT);
		}
		else {
			rcpt = xcalloc(1, sizeof(*rcpt), "smtp_rcpt");
			rcpt->destcount = s->tx->destcount;
			rcpt->maddr = s->tx->evp.rcpt;
			TAILQ_INSERT_TAIL(&s->tx->rcpts, rcpt, entry);

			s->tx->destcount = 0;
			s->tx->rcptcount++;
			smtp_reply(s, "250 %s %s: Recipient ok",
			    esc_code(ESC_STATUS_OK, ESC_DESTINATION_ADDRESS_VALID),
			    esc_description(ESC_DESTINATION_ADDRESS_VALID));
		}
		return;

	case IMSG_SMTP_MESSAGE_COMMIT:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &success);
		m_end(&m);
		s = tree_xpop(&wait_queue_commit, reqid);
		if (!success) {
			smtp_tx_free(s->tx);
			smtp_reply(s, "421 %s: Temporary failure",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
			smtp_enter_state(s, STATE_QUIT);
			return;
		}

		smtp_reply(s, "250 %s: %08x Message accepted for delivery",
		    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS),
		    s->tx->msgid);

		TAILQ_FOREACH(rcpt, &s->tx->rcpts, entry) {
			log_info("%016"PRIx64" smtp event=message address=%s host=%s "
			    "msgid=%08x from=<%s%s%s> to=<%s%s%s> size=%zu ndest=%zu proto=%s",
			    s->id,
			    ss_to_text(&s->ss), s->hostname,
			    s->tx->msgid,
			    s->tx->evp.sender.user,
			    s->tx->evp.sender.user[0] == '\0' ? "" : "@@",
			    s->tx->evp.sender.domain,
			    rcpt->maddr.user,
			    rcpt->maddr.user[0] == '\0' ? "" : "@@",
			    rcpt->maddr.domain,
			    s->tx->odatalen,
			    rcpt->destcount,
			    s->flags & SF_EHLO ? "ESMTP" : "SMTP");
		}
		smtp_tx_free(s->tx);
		s->mailcount++;
		smtp_enter_state(s, STATE_HELO);
		return;

	case IMSG_SMTP_AUTHENTICATE:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &success);
		m_end(&m);

		s = tree_xpop(&wait_parent_auth, reqid);
		strnvis(user, s->username, sizeof user, VIS_WHITE | VIS_SAFE);
		if (success == LKA_OK) {
			log_info("%016"PRIx64" smtp "
			    "event=authentication user=%s address=%s "
			    "host=%s result=ok",
			    s->id, user, ss_to_text(&s->ss), s->hostname);
			s->flags |= SF_AUTHENTICATED;
			smtp_reply(s, "235 %s: Authentication succeeded",
			    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
		}
		else if (success == LKA_PERMFAIL) {
			log_info("%016"PRIx64" smtp "
			    "event=authentication user=%s address=%s "
			    "host=%s result=permfail",
			    s->id, user, ss_to_text(&s->ss), s->hostname);
			smtp_auth_failure_pause(s);
			return;
		}
		else if (success == LKA_TEMPFAIL) {
			log_info("%016"PRIx64" smtp "
			    "event=authentication user=%s address=%s "
			    "host=%s result=tempfail",
			    s->id, user, ss_to_text(&s->ss), s->hostname);
			smtp_reply(s, "421 %s: Temporary failure",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
		}
		else
			fatalx("bad lka response");

		smtp_enter_state(s, STATE_HELO);
		return;

	case IMSG_SMTP_TLS_INIT:
		resp_ca_cert = imsg->data;
		s = tree_xpop(&wait_ssl_init, resp_ca_cert->reqid);

		if (resp_ca_cert->status == CA_FAIL) {
			log_info("%016"PRIx64" smtp event=closed address=%s host=%s "
			    "reason=ca-failure",
			    s->id, ss_to_text(&s->ss), s->hostname);
			smtp_free(s, "CA failure");
			return;
		}

		resp_ca_cert = xmemdup(imsg->data, sizeof *resp_ca_cert, "smtp:ca_cert");
		resp_ca_cert->cert = xstrdup((char *)imsg->data +
		    sizeof *resp_ca_cert, "smtp:ca_cert");
		ssl_ctx = dict_get(env->sc_ssl_dict, resp_ca_cert->name);
		ssl = ssl_smtp_init(ssl_ctx, s->listener->flags & F_TLS_VERIFY);
		io_set_read(s->io);
		io_start_tls(s->io, ssl);

		freezero(resp_ca_cert->cert, resp_ca_cert->cert_len);
		free(resp_ca_cert);
		return;

	case IMSG_SMTP_TLS_VERIFY:
		resp_ca_vrfy = imsg->data;
		s = tree_xpop(&wait_ssl_verify, resp_ca_vrfy->reqid);

		if (resp_ca_vrfy->status == CA_OK)
			s->flags |= SF_VERIFIED;
		else if (s->listener->flags & F_TLS_VERIFY) {
			log_info("%016"PRIx64" smtp "
			    "event=closed address=%s host=%s reason=cert-check-failed",
			    s->id, ss_to_text(&s->ss), s->hostname);
			smtp_free(s, "SSL certificate check failed");
			return;
		}
		smtp_tls_verified(s);
		io_resume(s->io, IO_IN);
		return;
	}

	log_warnx("smtp_session_imsg: unexpected %s imsg",
	    imsg_to_str(imsg->hdr.type));
	fatalx(NULL);
}

static void
smtp_tls_verified(struct smtp_session *s)
{
	X509 *x;

	x = SSL_get_peer_certificate(io_ssl(s->io));
	if (x) {
		log_info("%016"PRIx64" smtp "
		    "event=client-cert-check address=%s host=%s result=\"%s\"",
		    s->id, ss_to_text(&s->ss), s->hostname,
		    (s->flags & SF_VERIFIED) ? "success" : "failure");
		X509_free(x);
	}

	if (s->listener->flags & F_SMTPS) {
		stat_increment("smtp.smtps", 1);
		io_set_write(s->io);
		smtp_send_banner(s);
	}
	else {
		stat_increment("smtp.tls", 1);
		smtp_enter_state(s, STATE_HELO);
	}
}

void
smtp_filter_fd(uint64_t id, int fd)
{
	struct smtp_session	*s;
	X509			*x;

	s = tree_xpop(&wait_filter, id);

	log_debug("smtp: %p: fd %d from filter", s, fd);

	if (fd == -1 || (s->tx->ofile = fdopen(fd, "w")) == NULL) {
		if (fd != -1)
			close(fd);
		smtp_reply(s, "421 %s: Temporary Error",
		    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
		smtp_enter_state(s, STATE_QUIT);
		return;
	}

	s->tx->odatalen = 0;

	smtp_message_printf(s, "Received: ");
	if (!(s->listener->flags & F_MASK_SOURCE)) {
		smtp_message_printf(s, "from %s (%s [%s])",
		    s->helo,
		    s->hostname,
		    ss_to_text(&s->ss));
	}
	smtp_message_printf(s, "\n\tby %s (%s) with %sSMTP%s%s id %08x",
	    s->smtpname,
	    SMTPD_NAME,
	    s->flags & SF_EHLO ? "E" : "",
	    s->flags & SF_SECURE ? "S" : "",
	    s->flags & SF_AUTHENTICATED ? "A" : "",
	    s->tx->msgid);

	if (s->flags & SF_SECURE) {
		x = SSL_get_peer_certificate(io_ssl(s->io));
		smtp_message_printf(s, " (%s:%s:%d:%s)",
		    SSL_get_version(io_ssl(s->io)),
		    SSL_get_cipher_name(io_ssl(s->io)),
		    SSL_get_cipher_bits(io_ssl(s->io), NULL),
		    (s->flags & SF_VERIFIED) ? "YES" : (x ? "FAIL" : "NO"));
		X509_free(x);

		if (s->listener->flags & F_RECEIVEDAUTH) {
			smtp_message_printf(s, " auth=%s",
			    s->username[0] ? "yes" : "no");
			if (s->username[0])
				smtp_message_printf(s, " user=%s", s->username);
		}
	}

	if (s->tx->rcptcount == 1) {
		smtp_message_printf(s, "\n\tfor <%s@@%s>",
		    s->tx->evp.rcpt.user,
		    s->tx->evp.rcpt.domain);
	}

	smtp_message_printf(s, ";\n\t%s\n", time_to_text(time(NULL)));

	smtp_enter_state(s, STATE_BODY);
	smtp_reply(s, "354 Enter mail, end with \".\""
	    " on a line by itself");

	tree_xset(&wait_filter_data, s->id, s);
}

static void
smtp_io(struct io *io, int evt, void *arg)
{
	struct ca_cert_req_msg	req_ca_cert;
	struct smtp_session    *s = arg;
	char		       *line;
	size_t			len;

	log_trace(TRACE_IO, "smtp: %p: %s %s", s, io_strevent(evt),
	    io_strio(io));

	switch (evt) {

	case IO_TLSREADY:
		log_info("%016"PRIx64" smtp event=starttls address=%s host=%s ciphers=\"%s\"",
		    s->id, ss_to_text(&s->ss), s->hostname, ssl_to_text(io_ssl(s->io)));

		s->flags |= SF_SECURE;
		s->helo[0] = '\0';

		if (smtp_verify_certificate(s)) {
			io_pause(s->io, IO_IN);
			break;
		}

		if (s->listener->flags & F_TLS_VERIFY) {
			log_info("%016"PRIx64" smtp "
			    "event=closed address=%s host=%s reason=no-client-cert",
			    s->id, ss_to_text(&s->ss), s->hostname);
			smtp_free(s, "client did not present certificate");
			return;
		}

		smtp_tls_verified(s);
		break;

	case IO_DATAIN:
	    nextline:
		line = io_getline(s->io, &len);
		if ((line == NULL && io_datalen(s->io) >= LINE_MAX) ||
		    (line && len >= LINE_MAX)) {
			s->flags |= SF_BADINPUT;
			smtp_reply(s, "500 %s: Line too long",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_STATUS));
			smtp_enter_state(s, STATE_QUIT);
			io_set_write(io);
			return;
		}

		/* No complete line received */
		if (line == NULL)
			return;

		/* Message body */
		if (s->state == STATE_BODY && strcmp(line, ".")) {
			smtp_dataline(s, line);
			goto nextline;
		}

		/* Pipelining not supported */
		if (io_datalen(s->io)) {
			s->flags |= SF_BADINPUT;
			smtp_reply(s, "500 %s %s: Pipelining not supported",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			smtp_enter_state(s, STATE_QUIT);
			io_set_write(io);
			return;
		}

		/* End of body */
		if (s->state == STATE_BODY) {
			log_trace(TRACE_SMTP, "<<< [EOM]");

			rfc2822_parser_flush(&s->tx->rfc2822_parser);

			io_set_write(io);

			s->tx->dataeom = 1;
			smtp_data_io_done(s);
			return;
		}

		/* Must be a command */
		(void)strlcpy(s->cmd, line, sizeof s->cmd);
		io_set_write(io);
		smtp_command(s, line);
		break;

	case IO_LOWAT:
		if (s->state == STATE_QUIT) {
			log_info("%016"PRIx64" smtp event=closed address=%s host=%s "
			    "reason=quit",
			    s->id, ss_to_text(&s->ss), s->hostname);
			smtp_free(s, "done");
			break;
		}

		/* Wait for the client to start tls */
		if (s->state == STATE_TLS) {
			req_ca_cert.reqid = s->id;

			if (s->listener->pki_name[0]) {
				(void)strlcpy(req_ca_cert.name, s->listener->pki_name,
				    sizeof req_ca_cert.name);
				req_ca_cert.fallback = 0;
			}
			else {
				(void)strlcpy(req_ca_cert.name, s->smtpname,
				    sizeof req_ca_cert.name);
				req_ca_cert.fallback = 1;
			}
			m_compose(p_lka, IMSG_SMTP_TLS_INIT, 0, 0, -1,
			    &req_ca_cert, sizeof(req_ca_cert));
			tree_xset(&wait_ssl_init, s->id, s);
			break;
		}

		io_set_read(io);
		break;

	case IO_TIMEOUT:
		log_info("%016"PRIx64" smtp event=closed address=%s host=%s "
		    "reason=timeout",
		    s->id, ss_to_text(&s->ss), s->hostname);
		smtp_free(s, "timeout");
		break;

	case IO_DISCONNECTED:
		log_info("%016"PRIx64" smtp event=closed address=%s host=%s "
		    "reason=disconnect",
		    s->id, ss_to_text(&s->ss), s->hostname);
		smtp_free(s, "disconnected");
		break;

	case IO_ERROR:
		log_info("%016"PRIx64" smtp event=closed address=%s host=%s "
		    "reason=\"io-error: %s\"",
		    s->id, ss_to_text(&s->ss), s->hostname, io_error(io));
		smtp_free(s, "IO error");
		break;

	default:
		fatalx("smtp_io()");
	}
}

static int
smtp_tx(struct smtp_session *s)
{
	struct smtp_tx *tx;

	tx = calloc(1, sizeof(*tx));
	if (tx == NULL)
		return 0;

	TAILQ_INIT(&tx->rcpts);

	s->tx = tx;
	tx->session = s;

	/* setup the envelope */
	s->tx->evp.ss = s->ss;
	(void)strlcpy(s->tx->evp.tag, s->listener->tag, sizeof(s->tx->evp.tag));
	(void)strlcpy(s->tx->evp.smtpname, s->smtpname, sizeof(s->tx->evp.smtpname));
	(void)strlcpy(s->tx->evp.hostname, s->hostname, sizeof s->tx->evp.hostname);
	(void)strlcpy(s->tx->evp.helo, s->helo, sizeof s->tx->evp.helo);

	if (s->flags & SF_BOUNCE)
		s->tx->evp.flags |= EF_BOUNCE;
	if (s->flags & SF_AUTHENTICATED)
		s->tx->evp.flags |= EF_AUTHENTICATED;

	/* Setup parser and callbacks */
	rfc2822_parser_init(&tx->rfc2822_parser);
	rfc2822_header_default_callback(&tx->rfc2822_parser,
	    header_default_callback, s);
	rfc2822_header_callback(&tx->rfc2822_parser, "bcc",
	    header_bcc_callback, s);
	rfc2822_header_callback(&tx->rfc2822_parser, "from",
	    header_domain_append_callback, s);
	rfc2822_header_callback(&tx->rfc2822_parser, "to",
	    header_domain_append_callback, s);
	rfc2822_header_callback(&tx->rfc2822_parser, "cc",
	    header_domain_append_callback, s);
	rfc2822_body_callback(&tx->rfc2822_parser,
	    dataline_callback, s);

	if (s->listener->local || s->listener->port == 587) {
		rfc2822_missing_header_callback(&tx->rfc2822_parser, "date",
		    header_missing_callback, s);
		rfc2822_missing_header_callback(&tx->rfc2822_parser, "message-id",
		    header_missing_callback, s);
	}

	return 1;
}

static void
smtp_tx_free(struct smtp_tx *tx)
{
	struct smtp_rcpt *rcpt;

	rfc2822_parser_release(&tx->rfc2822_parser);

	while ((rcpt = TAILQ_FIRST(&tx->rcpts))) {
		TAILQ_REMOVE(&tx->rcpts, rcpt, entry);
		free(rcpt);
	}

	if (tx->ofile)
		fclose(tx->ofile);

	tx->session->tx = NULL;

	free(tx);
}

static void
smtp_data_io_done(struct smtp_session *s)
{
	log_debug("debug: smtp: %p: data io done (%zu bytes)", s, s->tx->odatalen);

	if (s->tx->msgflags & MF_ERROR) {

		tree_pop(&wait_filter_data, s->id);

		smtp_queue_rollback(s);

		if (s->tx->msgflags & MF_ERROR_SIZE)
			smtp_reply(s, "554 Message too big");
		else if (s->tx->msgflags & MF_ERROR_LOOP)
			smtp_reply(s, "500 %s %s: Loop detected",
				esc_code(ESC_STATUS_PERMFAIL, ESC_ROUTING_LOOP_DETECTED),
				esc_description(ESC_ROUTING_LOOP_DETECTED));
                else if (s->tx->msgflags & MF_ERROR_RESOURCES)
                        smtp_reply(s, "421 %s: Temporary Error",
                            esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
                else if (s->tx->msgflags & MF_ERROR_MALFORMED)
                        smtp_reply(s, "550 %s %s: Message is not RFC 2822 compliant",
                            esc_code(ESC_STATUS_PERMFAIL,
				ESC_DELIVERY_NOT_AUTHORIZED_MESSAGE_REFUSED),
                            esc_description(ESC_DELIVERY_NOT_AUTHORIZED_MESSAGE_REFUSED));
		else if (s->tx->msgflags)
			smtp_reply(s, "421 Internal server error");
		smtp_tx_free(s->tx);
		smtp_enter_state(s, STATE_HELO);
	}
	else {
		smtp_message_end(s);
	}
}

static void
smtp_command(struct smtp_session *s, char *line)
{
	char			       *args, *eom, *method;
	int				cmd, i;

	log_trace(TRACE_SMTP, "smtp: %p: <<< %s", s, line);

	/*
	 * These states are special.
	 */
	if (s->state == STATE_AUTH_INIT) {
		smtp_rfc4954_auth_plain(s, line);
		return;
	}
	if (s->state == STATE_AUTH_USERNAME || s->state == STATE_AUTH_PASSWORD) {
		smtp_rfc4954_auth_login(s, line);
		return;
	}

	/*
	 * Unlike other commands, "mail from" and "rcpt to" contain a
	 * space in the command name.
	 */
	if (strncasecmp("mail from:", line, 10) == 0 ||
	    strncasecmp("rcpt to:", line, 8) == 0)
		args = strchr(line, ':');
	else
		args = strchr(line, ' ');

	if (args) {
		*args++ = '\0';
		while (isspace((unsigned char)*args))
			args++;
	}

	cmd = -1;
	for (i = 0; commands[i].code != -1; i++)
		if (!strcasecmp(line, commands[i].cmd)) {
			cmd = commands[i].code;
			break;
		}

	switch (cmd) {
	/*
	 * INIT
	 */
	case CMD_HELO:
	case CMD_EHLO:
		if (s->helo[0]) {
			smtp_reply(s, "503 %s %s: Already identified",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}

		if (args == NULL) {
			smtp_reply(s, "501 %s %s: %s requires domain name",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND),
			    (cmd == CMD_HELO) ? "HELO" : "EHLO");

			break;
		}

		if (!valid_domainpart(args)) {
			smtp_reply(s, "501 %s %s: Invalid domain name",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),
			    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));
			break;
		}
		(void)strlcpy(s->helo, args, sizeof(s->helo));
		s->flags &= SF_SECURE | SF_AUTHENTICATED | SF_VERIFIED;
		if (cmd == CMD_EHLO) {
			s->flags |= SF_EHLO;
			s->flags |= SF_8BITMIME;
		}

		smtp_enter_state(s, STATE_HELO);
		smtp_reply(s, "250%c%s Hello %s [%s], pleased to meet you",
		    (s->flags & SF_EHLO) ? '-' : ' ',
		    s->smtpname,
		    s->helo,
		    ss_to_text(&s->ss));

		if (s->flags & SF_EHLO) {
			smtp_reply(s, "250-8BITMIME");
			smtp_reply(s, "250-ENHANCEDSTATUSCODES");
			smtp_reply(s, "250-SIZE %zu", env->sc_maxsize);
			if (ADVERTISE_EXT_DSN(s))
				smtp_reply(s, "250-DSN");
			if (ADVERTISE_TLS(s))
				smtp_reply(s, "250-STARTTLS");
			if (ADVERTISE_AUTH(s))
				smtp_reply(s, "250-AUTH PLAIN LOGIN");
			smtp_reply(s, "250 HELP");
		}
		break;
	/*
	 * SETUP
	 */
	case CMD_STARTTLS:
		if (s->helo[0] == '\0' || s->tx) {
			smtp_reply(s, "503 %s %s: Command not allowed at this point.",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}

		if (!(s->listener->flags & F_STARTTLS)) {
			smtp_reply(s, "503 %s %s: Command not supported",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}

		if (s->flags & SF_SECURE) {
			smtp_reply(s, "503 %s %s: Channel already secured",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}
		if (args != NULL) {
			smtp_reply(s, "501 %s %s: No parameters allowed",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),
			    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));
			break;
		}
		smtp_reply(s, "220 %s: Ready to start TLS",
		    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
		smtp_enter_state(s, STATE_TLS);
		break;

	case CMD_AUTH:
		if (s->helo[0] == '\0' || s->tx) {
			smtp_reply(s, "503 %s %s: Command not allowed at this point.",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}

		if (s->flags & SF_AUTHENTICATED) {
			smtp_reply(s, "503 %s %s: Already authenticated",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}

		if (!ADVERTISE_AUTH(s)) {
			smtp_reply(s, "503 %s %s: Command not supported",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}

		if (args == NULL) {
			smtp_reply(s, "501 %s %s: No parameters given",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),
			    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));
			break;
		}

		method = args;
		eom = strchr(args, ' ');
		if (eom == NULL)
			eom = strchr(args, '\t');
		if (eom != NULL)
			*eom++ = '\0';
		if (strcasecmp(method, "PLAIN") == 0)
			smtp_rfc4954_auth_plain(s, eom);
		else if (strcasecmp(method, "LOGIN") == 0)
			smtp_rfc4954_auth_login(s, eom);
		else
			smtp_reply(s, "504 %s %s: AUTH method \"%s\" not supported",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_SECURITY_FEATURES_NOT_SUPPORTED),
			    esc_description(ESC_SECURITY_FEATURES_NOT_SUPPORTED),
			    method);
		break;

	case CMD_MAIL_FROM:
		if (s->helo[0] == '\0' || s->tx) {
			smtp_reply(s, "503 %s %s: Command not allowed at this point.",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));

			break;
		}

		if (s->listener->flags & F_STARTTLS_REQUIRE &&
		    !(s->flags & SF_SECURE)) {
			smtp_reply(s,
			    "530 %s %s: Must issue a STARTTLS command first",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}

		if (s->listener->flags & F_AUTH_REQUIRE &&
		    !(s->flags & SF_AUTHENTICATED)) {
			smtp_reply(s,
			    "530 %s %s: Must issue an AUTH command first",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}

		if (s->mailcount >= env->sc_session_max_mails) {
			/* we can pretend we had too many recipients */
			smtp_reply(s, "452 %s %s: Too many messages sent",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_TOO_MANY_RECIPIENTS),
			    esc_description(ESC_TOO_MANY_RECIPIENTS));
			break;
		}

		if (!smtp_tx(s)) {
			smtp_reply(s, "421 %s: Temporary Error",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
			smtp_enter_state(s, STATE_QUIT);
			break;
		}

		if (smtp_mailaddr(&s->tx->evp.sender, args, 1, &args,
			s->smtpname) == 0) {
			smtp_tx_free(s->tx);
			smtp_reply(s, "553 %s: Sender address syntax error",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_ADDRESS_STATUS));
			break;
		}
		if (args && smtp_parse_mail_args(s, args) == -1) {
			smtp_tx_free(s->tx);
			break;
		}

		/* only check sendertable if defined and user has authenticated */
		if (s->flags & SF_AUTHENTICATED && s->listener->sendertable[0]) {
			m_create(p_lka, IMSG_SMTP_CHECK_SENDER, 0, 0, -1);
			m_add_id(p_lka, s->id);
			m_add_string(p_lka, s->listener->sendertable);
			m_add_string(p_lka, s->username);
			m_add_mailaddr(p_lka, &s->tx->evp.sender);
			m_close(p_lka);
			tree_xset(&wait_lka_mail, s->id, s);
		}
		else
			smtp_queue_create_message(s);
		break;
	/*
	 * TRANSACTION
	 */
	case CMD_RCPT_TO:
		if (s->tx == NULL) {
			smtp_reply(s, "503 %s %s: Command not allowed at this point.",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}

		if (s->tx->rcptcount >= env->sc_session_max_rcpt) {
			smtp_reply(s, "451 %s %s: Too many recipients",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_TOO_MANY_RECIPIENTS),
			    esc_description(ESC_TOO_MANY_RECIPIENTS));
			break;
		}

		if (smtp_mailaddr(&s->tx->evp.rcpt, args, 0, &args,
		    s->smtpname) == 0) {
			smtp_reply(s,
			    "501 %s: Recipient address syntax error",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_BAD_DESTINATION_MAILBOX_ADDRESS_SYNTAX));
			break;
		}
		if (args && smtp_parse_rcpt_args(s, args) == -1)
			break;

		m_create(p_lka, IMSG_SMTP_EXPAND_RCPT, 0, 0, -1);
		m_add_id(p_lka, s->id);
		m_add_envelope(p_lka, &s->tx->evp);
		m_close(p_lka);
		tree_xset(&wait_lka_rcpt, s->id, s);
		break;

	case CMD_RSET:
		if (s->helo[0] == '\0') {
			smtp_reply(s, "503 %s %s: Command not allowed at this point.",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}

		if (s->tx) {
			if (s->tx->msgid)
				smtp_queue_rollback(s);
			smtp_tx_free(s->tx);
		}

		smtp_reply(s, "250 %s: Reset state",
		    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
		break;

	case CMD_DATA:
		if (s->tx == NULL) {
			smtp_reply(s, "503 %s %s: Command not allowed at this point.",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
			break;
		}
		if (s->tx->rcptcount == 0) {
			smtp_reply(s, "503 %s %s: No recipient specified",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),
			    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));
			break;
		}

		smtp_queue_open_message(s);
		break;
	/*
	 * ANY
	 */
	case CMD_QUIT:
		smtp_reply(s, "221 %s: Bye",
		    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
		smtp_enter_state(s, STATE_QUIT);
		break;

	case CMD_NOOP:
		smtp_reply(s, "250 %s: Ok",
		    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
		break;

	case CMD_HELP:
		smtp_reply(s, "214- This is " SMTPD_NAME);
		smtp_reply(s, "214- To report bugs in the implementation, "
		    "please contact bugs@@openbsd.org");
		smtp_reply(s, "214- with full details");
		smtp_reply(s, "214 %s: End of HELP info",
		    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
		break;

	case CMD_WIZ:
		smtp_reply(s, "500 %s %s: this feature is not supported yet ;-)",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
		break;

	default:
		smtp_reply(s, "500 %s %s: Command unrecognized",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),
			    esc_description(ESC_INVALID_COMMAND));
		break;
	}
}

static void
smtp_rfc4954_auth_plain(struct smtp_session *s, char *arg)
{
	char		 buf[1024], *user, *pass;
	int		 len;

	switch (s->state) {
	case STATE_HELO:
		if (arg == NULL) {
			smtp_enter_state(s, STATE_AUTH_INIT);
			smtp_reply(s, "334 ");
			return;
		}
		smtp_enter_state(s, STATE_AUTH_INIT);
		/* FALLTHROUGH */

	case STATE_AUTH_INIT:
		/* String is not NUL terminated, leave room. */
		if ((len = base64_decode(arg, (unsigned char *)buf,
			    sizeof(buf) - 1)) == -1)
			goto abort;
		/* buf is a byte string, NUL terminate. */
		buf[len] = '\0';

		/*
		 * Skip "foo" in "foo\0user\0pass", if present.
		 */
		user = memchr(buf, '\0', len);
		if (user == NULL || user >= buf + len - 2)
			goto abort;
		user++; /* skip NUL */
		if (strlcpy(s->username, user, sizeof(s->username))
		    >= sizeof(s->username))
			goto abort;

		pass = memchr(user, '\0', len - (user - buf));
		if (pass == NULL || pass >= buf + len - 2)
			goto abort;
		pass++; /* skip NUL */

		m_create(p_lka,  IMSG_SMTP_AUTHENTICATE, 0, 0, -1);
		m_add_id(p_lka, s->id);
		m_add_string(p_lka, s->listener->authtable);
		m_add_string(p_lka, user);
		m_add_string(p_lka, pass);
		m_close(p_lka);
		tree_xset(&wait_parent_auth, s->id, s);
		return;

	default:
		fatal("smtp_rfc4954_auth_plain: unknown state");
	}

abort:
	smtp_reply(s, "501 %s %s: Syntax error",
	    esc_code(ESC_STATUS_PERMFAIL, ESC_SYNTAX_ERROR),
	    esc_description(ESC_SYNTAX_ERROR));
	smtp_enter_state(s, STATE_HELO);
}

static void
smtp_rfc4954_auth_login(struct smtp_session *s, char *arg)
{
	char		buf[LINE_MAX];

	switch (s->state) {
	case STATE_HELO:
		smtp_enter_state(s, STATE_AUTH_USERNAME);
		smtp_reply(s, "334 VXNlcm5hbWU6");
		return;

	case STATE_AUTH_USERNAME:
		memset(s->username, 0, sizeof(s->username));
		if (base64_decode(arg, (unsigned char *)s->username,
				  sizeof(s->username) - 1) == -1)
			goto abort;

		smtp_enter_state(s, STATE_AUTH_PASSWORD);
		smtp_reply(s, "334 UGFzc3dvcmQ6");
		return;

	case STATE_AUTH_PASSWORD:
		memset(buf, 0, sizeof(buf));
		if (base64_decode(arg, (unsigned char *)buf,
				  sizeof(buf)-1) == -1)
			goto abort;

		m_create(p_lka,  IMSG_SMTP_AUTHENTICATE, 0, 0, -1);
		m_add_id(p_lka, s->id);
		m_add_string(p_lka, s->listener->authtable);
		m_add_string(p_lka, s->username);
		m_add_string(p_lka, buf);
		m_close(p_lka);
		tree_xset(&wait_parent_auth, s->id, s);
		return;

	default:
		fatal("smtp_rfc4954_auth_login: unknown state");
	}

abort:
	smtp_reply(s, "501 %s %s: Syntax error",
	    esc_code(ESC_STATUS_PERMFAIL, ESC_SYNTAX_ERROR),
	    esc_description(ESC_SYNTAX_ERROR));
	smtp_enter_state(s, STATE_HELO);
}

static uint8_t
dsn_notify_str_to_uint8(const char *arg)
{
	if (strcasecmp(arg, "SUCCESS") == 0)
		return DSN_SUCCESS;
	else if (strcasecmp(arg, "FAILURE") == 0)
		return DSN_FAILURE;
	else if (strcasecmp(arg, "DELAY") == 0)
		return DSN_DELAY;
	else if (strcasecmp(arg, "NEVER") == 0)
		return DSN_NEVER;

	return (0);
}

static int
smtp_parse_rcpt_args(struct smtp_session *s, char *args)
{
	char 	*b, *p;
	uint8_t flag;

	while ((b = strsep(&args, " "))) {
		if (*b == '\0')
			continue;

		if (ADVERTISE_EXT_DSN(s) && strncasecmp(b, "NOTIFY=", 7) == 0) {
			b += 7;
			while ((p = strsep(&b, ","))) {
				if (*p == '\0')
					continue;

				if ((flag = dsn_notify_str_to_uint8(p)) == 0)
					continue;

				s->tx->evp.dsn_notify |= flag;
			}
			if (s->tx->evp.dsn_notify & DSN_NEVER &&
			    s->tx->evp.dsn_notify & (DSN_SUCCESS | DSN_FAILURE |
			    DSN_DELAY)) {
				smtp_reply(s,
				    "553 NOTIFY option NEVER cannot be \
				    combined with other options");
				return (-1);
			}
		} else if (ADVERTISE_EXT_DSN(s) && strncasecmp(b, "ORCPT=", 6) == 0) {
			b += 6;
			if (!text_to_mailaddr(&s->tx->evp.dsn_orcpt, b)) {
				smtp_reply(s, "553 ORCPT address syntax error");
				return (-1);
			}
		} else {
			smtp_reply(s, "503 Unsupported option %s", b);
			return (-1);
		}
	}

	return (0);
}

static int
smtp_parse_mail_args(struct smtp_session *s, char *args)
{
	char *b;

	while ((b = strsep(&args, " "))) {
		if (*b == '\0')
			continue;

		if (strncasecmp(b, "AUTH=", 5) == 0)
			log_debug("debug: smtp: AUTH in MAIL FROM command");
		else if (strncasecmp(b, "SIZE=", 5) == 0)
			log_debug("debug: smtp: SIZE in MAIL FROM command");
		else if (strcasecmp(b, "BODY=7BIT") == 0)
			/* XXX only for this transaction */
			s->flags &= ~SF_8BITMIME;
		else if (strcasecmp(b, "BODY=8BITMIME") == 0)
			;
		else if (ADVERTISE_EXT_DSN(s) && strncasecmp(b, "RET=", 4) == 0) {
			b += 4;
			if (strcasecmp(b, "HDRS") == 0)
				s->tx->evp.dsn_ret = DSN_RETHDRS;
			else if (strcasecmp(b, "FULL") == 0)
				s->tx->evp.dsn_ret = DSN_RETFULL;
		} else if (ADVERTISE_EXT_DSN(s) && strncasecmp(b, "ENVID=", 6) == 0) {
			b += 6;
			if (strlcpy(s->tx->evp.dsn_envid, b, sizeof(s->tx->evp.dsn_envid))
			    >= sizeof(s->tx->evp.dsn_envid)) {
				smtp_reply(s, "503 %s %s: option too large, truncated: %s",
				    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),
				    esc_description(ESC_INVALID_COMMAND_ARGUMENTS), b);
				return (-1);
			}
		} else {
			smtp_reply(s, "503 %s %s: Unsupported option %s",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),
			    esc_description(ESC_INVALID_COMMAND_ARGUMENTS), b);
			return (-1);
		}
	}

	return (0);
}

static int
smtp_lookup_servername(struct smtp_session *s)
{
	struct sockaddr		*sa;
	socklen_t		 sa_len;
	struct sockaddr_storage	 ss;

	if (s->listener->hostnametable[0]) {
		sa_len = sizeof(ss);
		sa = (struct sockaddr *)&ss;
		if (getsockname(io_fileno(s->io), sa, &sa_len) == -1) {
			log_warn("warn: getsockname()");
		}
		else {
			m_create(p_lka, IMSG_SMTP_LOOKUP_HELO, 0, 0, -1);
			m_add_id(p_lka, s->id);
			m_add_string(p_lka, s->listener->hostnametable);
			m_add_sockaddr(p_lka, sa);
			m_close(p_lka);
			tree_xset(&wait_lka_helo, s->id, s);
			return 0;
		}
	}
	return 1;
}

static void
smtp_connected(struct smtp_session *s)
{
	struct ca_cert_req_msg	req_ca_cert;
	struct sockaddr_storage	ss;
	socklen_t		sl;

	smtp_enter_state(s, STATE_CONNECTED);

	log_info("%016"PRIx64" smtp event=connected address=%s host=%s",
	    s->id, ss_to_text(&s->ss), s->hostname);

	sl = sizeof(ss);
	if (getsockname(io_fileno(s->io), (struct sockaddr*)&ss, &sl) == -1) {
		smtp_free(s, strerror(errno));
		return;
	}

	if (s->listener->flags & F_SMTPS) {
		req_ca_cert.reqid = s->id;
		if (s->listener->pki_name[0]) {
			(void)strlcpy(req_ca_cert.name, s->listener->pki_name,
			    sizeof req_ca_cert.name);
			req_ca_cert.fallback = 0;
		}
		else {
			(void)strlcpy(req_ca_cert.name, s->smtpname,
			    sizeof req_ca_cert.name);
			req_ca_cert.fallback = 1;
		}
		m_compose(p_lka, IMSG_SMTP_TLS_INIT, 0, 0, -1,
		    &req_ca_cert, sizeof(req_ca_cert));
		tree_xset(&wait_ssl_init, s->id, s);
		return;
	}

	smtp_send_banner(s);
}

static void
smtp_send_banner(struct smtp_session *s)
{
	smtp_reply(s, "220 %s ESMTP %s", s->smtpname, SMTPD_NAME);
}

void
smtp_enter_state(struct smtp_session *s, int newstate)
{
	log_trace(TRACE_SMTP, "smtp: %p: %s -> %s", s,
	    smtp_strstate(s->state),
	    smtp_strstate(newstate));

	s->state = newstate;
}

static void
smtp_message_end(struct smtp_session *s)
{
	log_debug("debug: %p: end of message, msgflags=0x%04x", s, s->tx->msgflags);

	tree_xpop(&wait_filter_data, s->id);

	if (s->tx->msgflags & MF_ERROR) {
		smtp_queue_rollback(s);
		if (s->tx->msgflags & MF_ERROR_SIZE)
			smtp_reply(s, "554 %s %s: Transaction failed, message too big",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_MESSAGE_TOO_BIG_FOR_SYSTEM),
			    esc_description(ESC_MESSAGE_TOO_BIG_FOR_SYSTEM));
		else
			smtp_reply(s, "%d Message rejected", s->tx->msgcode);
		smtp_tx_free(s->tx);
		smtp_enter_state(s, STATE_HELO);
		return;
	}

	fclose(s->tx->ofile);
	s->tx->ofile = NULL;

	smtp_queue_commit(s);
}

static int
smtp_message_printf(struct smtp_session *s, const char *fmt, ...)
{
	va_list	ap;
	int	len;

	if (s->tx->msgflags & MF_ERROR)
		return -1;

	va_start(ap, fmt);
	len = vfprintf(s->tx->ofile, fmt, ap);
	va_end(ap);

	if (len < 0) {
		log_warn("smtp-in: session %016"PRIx64": vfprintf", s->id);
		s->tx->msgflags |= MF_ERROR_IO;
	}
	else
		s->tx->odatalen += len;

	return len;
}

static void
smtp_reply(struct smtp_session *s, char *fmt, ...)
{
	va_list	 ap;
	int	 n;
	char	 buf[LINE_MAX], tmp[LINE_MAX];

	va_start(ap, fmt);
	n = vsnprintf(buf, sizeof buf, fmt, ap);
	va_end(ap);
	if (n == -1 || n >= LINE_MAX)
		fatalx("smtp_reply: line too long");
	if (n < 4)
		fatalx("smtp_reply: response too short");

	log_trace(TRACE_SMTP, "smtp: %p: >>> %s", s, buf);

	io_xprintf(s->io, "%s\r\n", buf);

	switch (buf[0]) {
	case '5':
	case '4':
		if (s->flags & SF_BADINPUT) {
			log_info("%016"PRIx64" smtp "
			    "event=bad-input address=%s host=%s result=\"%.*s\"",
			    s->id, ss_to_text(&s->ss), s->hostname, n, buf);
		}
		else if (s->state == STATE_AUTH_INIT) {
			log_info("%016"PRIx64" smtp "
			    "event=failed-command address=%s host=%s "
			    "command=\"AUTH PLAIN (...)\" result=\"%.*s\"",
			    s->id, ss_to_text(&s->ss), s->hostname, n, buf);
		}
		else if (s->state == STATE_AUTH_USERNAME) {
			log_info("%016"PRIx64" smtp "
			    "event=failed-command address=%s host=%s "
			    "command=\"AUTH LOGIN (username)\" result=\"%.*s\"",
			    s->id, ss_to_text(&s->ss), s->hostname, n, buf);
		}
		else if (s->state == STATE_AUTH_PASSWORD) {
			log_info("%016"PRIx64" smtp "
			    "event=failed-command address=%s host=%s "
			    "command=\"AUTH LOGIN (password)\" result=\"%.*s\"",
			    s->id, ss_to_text(&s->ss), s->hostname, n, buf);
		}
		else {
			strnvis(tmp, s->cmd, sizeof tmp, VIS_SAFE | VIS_CSTYLE);
			log_info("%016"PRIx64" smtp "
			    "event=failed-command address=%s host=%s command=\"%s\" "
			    "result=\"%.*s\"",
			    s->id, ss_to_text(&s->ss), s->hostname, tmp, n, buf);
		}
		break;
	}
}

static void
smtp_free(struct smtp_session *s, const char * reason)
{
	log_debug("debug: smtp: %p: deleting session: %s", s, reason);

	tree_pop(&wait_filter_data, s->id);

	if (s->tx) {
		if (s->tx->msgid)
			smtp_queue_rollback(s);
		smtp_tx_free(s->tx);
	}

	if (s->flags & SF_SECURE && s->listener->flags & F_SMTPS)
		stat_decrement("smtp.smtps", 1);
	if (s->flags & SF_SECURE && s->listener->flags & F_STARTTLS)
		stat_decrement("smtp.tls", 1);

	io_free(s->io);
	free(s);

	smtp_collect();
}

static int
smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,
    const char *domain)
{
	char   *p, *e;

	if (line == NULL)
		return (0);

	if (*line != '<')
		return (0);

	e = strchr(line, '>');
	if (e == NULL)
		return (0);
	*e++ = '\0';
	while (*e == ' ')
		e++;
	*args = e;

	if (!text_to_mailaddr(maddr, line + 1))
		return (0);

	p = strchr(maddr->user, ':');
	if (p != NULL) {
		p++;
		memmove(maddr->user, p, strlen(p) + 1);
	}

	if (!valid_localpart(maddr->user) ||
	    !valid_domainpart(maddr->domain)) {
		/* accept empty return-path in MAIL FROM, required for bounces */
		if (mailfrom && maddr->user[0] == '\0' && maddr->domain[0] == '\0')
			return (1);

		/* no user-part, reject */
		if (maddr->user[0] == '\0')
			return (0);

		/* no domain, local user */
		if (maddr->domain[0] == '\0') {
			(void)strlcpy(maddr->domain, domain,
			    sizeof(maddr->domain));
			return (1);
		}
		return (0);
	}

	return (1);
}

static int
smtp_verify_certificate(struct smtp_session *s)
{
#define MAX_CERTS	16
#define MAX_CERT_LEN	(MAX_IMSGSIZE - (IMSG_HEADER_SIZE + sizeof(req_ca_vrfy)))
	struct ca_vrfy_req_msg	req_ca_vrfy;
	struct iovec		iov[2];
	X509		       *x;
	STACK_OF(X509)	       *xchain;
	const char	       *name;
	unsigned char	       *cert_der[MAX_CERTS];
	int			cert_len[MAX_CERTS];
	int			i, cert_count, res;

	res = 0;
	memset(cert_der, 0, sizeof(cert_der));
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);

	/* Send the client certificate */
	if (s->listener->ca_name[0]) {
		name = s->listener->ca_name;
		req_ca_vrfy.fallback = 0;
	}
	else {
		name = s->smtpname;
		req_ca_vrfy.fallback = 1;
	}

	if (strlcpy(req_ca_vrfy.name, name, sizeof req_ca_vrfy.name)
	    >= sizeof req_ca_vrfy.name)
		return 0;

	x = SSL_get_peer_certificate(io_ssl(s->io));
	if (x == NULL)
		return 0;
	xchain = SSL_get_peer_cert_chain(io_ssl(s->io));

	/*
	 * Client provided a certificate and possibly a certificate chain.
	 * SMTP can't verify because it does not have the information that
	 * it needs, instead it will pass the certificate and chain to the
	 * lookup process and wait for a reply.
	 *
	 */

	cert_len[0] = i2d_X509(x, &cert_der[0]);
	X509_free(x);

	if (cert_len[0] < 0) {
		log_warnx("warn: failed to encode certificate");
		goto end;
	}
	log_debug("debug: certificate 0: len=%d", cert_len[0]);
	if (cert_len[0] > (int)MAX_CERT_LEN) {
		log_warnx("warn: certificate too long");
		goto end;
	}

	if (xchain) {
		cert_count = sk_X509_num(xchain);
		log_debug("debug: certificate chain len: %d", cert_count);
		if (cert_count >= MAX_CERTS) {
			log_warnx("warn: certificate chain too long");
			goto end;
		}
	}
	else
		cert_count = 0;

	for (i = 0; i < cert_count; ++i) {
		x = sk_X509_value(xchain, i);
		cert_len[i+1] = i2d_X509(x, &cert_der[i+1]);
		if (cert_len[i+1] < 0) {
			log_warnx("warn: failed to encode certificate");
			goto end;
		}
		log_debug("debug: certificate %i: len=%d", i+1, cert_len[i+1]);
		if (cert_len[i+1] > (int)MAX_CERT_LEN) {
			log_warnx("warn: certificate too long");
			goto end;
		}
	}

	tree_xset(&wait_ssl_verify, s->id, s);

	/* Send the client certificate */
	req_ca_vrfy.reqid = s->id;
	req_ca_vrfy.cert_len = cert_len[0];
	req_ca_vrfy.n_chain = cert_count;
	iov[0].iov_base = &req_ca_vrfy;
	iov[0].iov_len = sizeof(req_ca_vrfy);
	iov[1].iov_base = cert_der[0];
	iov[1].iov_len = cert_len[0];
	m_composev(p_lka, IMSG_SMTP_TLS_VERIFY_CERT, 0, 0, -1,
	    iov, nitems(iov));

	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	req_ca_vrfy.reqid = s->id;

	/* Send the chain, one cert at a time */
	for (i = 0; i < cert_count; ++i) {
		req_ca_vrfy.cert_len = cert_len[i+1];
		iov[1].iov_base = cert_der[i+1];
		iov[1].iov_len  = cert_len[i+1];
		m_composev(p_lka, IMSG_SMTP_TLS_VERIFY_CHAIN, 0, 0, -1,
		    iov, nitems(iov));
	}

	/* Tell lookup process that it can start verifying, we're done */
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	req_ca_vrfy.reqid = s->id;
	m_compose(p_lka, IMSG_SMTP_TLS_VERIFY, 0, 0, -1,
	    &req_ca_vrfy, sizeof req_ca_vrfy);

	res = 1;

    end:
	for (i = 0; i < MAX_CERTS; ++i)
		free(cert_der[i]);

	return res;
}

static void
smtp_auth_failure_resume(int fd, short event, void *p)
{
	struct smtp_session *s = p;

	smtp_reply(s, "535 Authentication failed");
	smtp_enter_state(s, STATE_HELO);
}

static void
smtp_auth_failure_pause(struct smtp_session *s)
{
	struct timeval	tv;

	tv.tv_sec = 0;
	tv.tv_usec = arc4random_uniform(1000000);
	log_trace(TRACE_SMTP, "smtp: timing-attack protection triggered, "
	    "will defer answer for %lu microseconds", tv.tv_usec);
	evtimer_set(&s->pause, smtp_auth_failure_resume, s);
	evtimer_add(&s->pause, &tv);
}

static void
smtp_queue_create_message(struct smtp_session *s)
{
	m_create(p_queue, IMSG_SMTP_MESSAGE_CREATE, 0, 0, -1);
	m_add_id(p_queue, s->id);
	m_close(p_queue);
	tree_xset(&wait_queue_msg, s->id, s);
}

static void
smtp_queue_open_message(struct smtp_session *s)
{
	m_create(p_queue, IMSG_SMTP_MESSAGE_OPEN, 0, 0, -1);
	m_add_id(p_queue, s->id);
	m_add_msgid(p_queue, s->tx->msgid);
	m_close(p_queue);
	tree_xset(&wait_queue_fd, s->id, s);
}

static void
smtp_queue_commit(struct smtp_session *s)
{
	m_create(p_queue, IMSG_SMTP_MESSAGE_COMMIT, 0, 0, -1);
	m_add_id(p_queue, s->id);
	m_add_msgid(p_queue, s->tx->msgid);
	m_close(p_queue);
	tree_xset(&wait_queue_commit, s->id, s);
}

static void
smtp_queue_rollback(struct smtp_session *s)
{
	m_create(p_queue, IMSG_SMTP_MESSAGE_ROLLBACK, 0, 0, -1);
	m_add_msgid(p_queue, s->tx->msgid);
	m_close(p_queue);
}

static void
smtp_dataline(struct smtp_session *s, const char *line)
{
	int	ret;

	log_trace(TRACE_SMTP, "<<< [MSG] %s", line);

	/* ignore data line if an error flag is set */
	if (s->tx->msgflags & MF_ERROR)
		return;

	/* escape lines starting with a '.' */
	if (line[0] == '.')
		line += 1;

	/* account for newline */
	s->tx->datain += strlen(line) + 1;
	if (s->tx->datain > env->sc_maxsize) {
		s->tx->msgflags |= MF_ERROR_SIZE;
		return;
	}

	if (!s->tx->hdrdone) {

		/* folded header that must be skipped */
		if (isspace((unsigned char)line[0]) && s->tx->skiphdr)
			return;
		s->tx->skiphdr = 0;

		/* BCC should be stripped from headers */
		if (strncasecmp("bcc:", line, 4) == 0) {
			s->tx->skiphdr = 1;
			return;
		}

		/* check for loop */
		if (strncasecmp("Received: ", line, 10) == 0)
			s->tx->rcvcount++;
		if (s->tx->rcvcount == MAX_HOPS_COUNT) {
			s->tx->msgflags |= MF_ERROR_LOOP;
			log_warnx("warn: loop detected");
			return;
		}

		if (line[0] == '\0')
			s->tx->hdrdone = 1;
	}

	ret = rfc2822_parser_feed(&s->tx->rfc2822_parser, line);
	if (ret == -1) {
		s->tx->msgflags |= MF_ERROR_RESOURCES;
		return;
	}

	if (ret == 0) {
		s->tx->msgflags |= MF_ERROR_MALFORMED;
		return;
	}
}

#define CASE(x) case x : return #x

const char *
smtp_strstate(int state)
{
	static char	buf[32];

	switch (state) {
	CASE(STATE_NEW);
	CASE(STATE_CONNECTED);
	CASE(STATE_TLS);
	CASE(STATE_HELO);
	CASE(STATE_AUTH_INIT);
	CASE(STATE_AUTH_USERNAME);
	CASE(STATE_AUTH_PASSWORD);
	CASE(STATE_AUTH_FINALIZE);
	CASE(STATE_BODY);
	CASE(STATE_QUIT);
	default:
		(void)snprintf(buf, sizeof(buf), "STATE_??? (%d)", state);
		return (buf);
	}
}
@


1.306
log
@remove smtp_filter_*() indirections.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.305 2017/08/13 11:10:30 eric Exp $	*/
d192 1
a192 1
static void smtp_filter_dataline(struct smtp_session *, const char *);
d1120 1
a1120 1
			smtp_filter_dataline(s, line);
d2324 1
a2324 1
smtp_filter_dataline(struct smtp_session *s, const char *line)
@


1.305
log
@bypass the filter code for incoming smtp sessions.
experimental support for filters has been removed from the config
parser already, and we want to get rid of the remaining code.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.304 2017/06/19 08:35:56 gilles Exp $	*/
a191 6
static void smtp_filter_connect(struct smtp_session *, struct sockaddr *);
static void smtp_filter_eom(struct smtp_session *);
static void smtp_filter_helo(struct smtp_session *);
static void smtp_filter_mail(struct smtp_session *);
static void smtp_filter_rcpt(struct smtp_session *);
static void smtp_filter_data(struct smtp_session *);
a997 144
smtp_filter_response(uint64_t id, int query, int status, uint32_t code,
    const char *line)
{
	struct smtp_session	*s;
	struct ca_cert_req_msg	 req_ca_cert;

	s = tree_xpop(&wait_filter, id);

	if (status == FILTER_CLOSE) {
		code = code ? code : 421;
		line = line ? line : "Temporary failure";
		smtp_reply(s, "%d %s", code, line);
		smtp_enter_state(s, STATE_QUIT);
		return;
	}

	switch (query) {

	case QUERY_CONNECT:
		if (status != FILTER_OK) {
			log_info("%016"PRIx64" smtp "
			    "event=closed address=%s host=%s reason=filter-reject",
			    s->id, ss_to_text(&s->ss), s->hostname);
			smtp_free(s, "rejected by filter");
			return;
		}

		if (s->listener->flags & F_SMTPS) {
			req_ca_cert.reqid = s->id;
			if (s->listener->pki_name[0]) {
				(void)strlcpy(req_ca_cert.name, s->listener->pki_name,
				    sizeof req_ca_cert.name);
				req_ca_cert.fallback = 0;
			}
			else {
				(void)strlcpy(req_ca_cert.name, s->smtpname,
				    sizeof req_ca_cert.name);
				req_ca_cert.fallback = 1;
			}
			m_compose(p_lka, IMSG_SMTP_TLS_INIT, 0, 0, -1,
			    &req_ca_cert, sizeof(req_ca_cert));
			tree_xset(&wait_ssl_init, s->id, s);
			return;
		}
		smtp_send_banner(s);
		return;

	case QUERY_HELO:
		if (status != FILTER_OK) {
			code = code ? code : 530;
			line = line ? line : "Hello rejected";
			smtp_reply(s, "%d %s", code, line);
			return;
		}

		smtp_enter_state(s, STATE_HELO);
		smtp_reply(s, "250%c%s Hello %s [%s], pleased to meet you",
		    (s->flags & SF_EHLO) ? '-' : ' ',
		    s->smtpname,
		    s->helo,
		    ss_to_text(&s->ss));

		if (s->flags & SF_EHLO) {
			smtp_reply(s, "250-8BITMIME");
			smtp_reply(s, "250-ENHANCEDSTATUSCODES");
			smtp_reply(s, "250-SIZE %zu", env->sc_maxsize);
			if (ADVERTISE_EXT_DSN(s))
				smtp_reply(s, "250-DSN");
			if (ADVERTISE_TLS(s))
				smtp_reply(s, "250-STARTTLS");
			if (ADVERTISE_AUTH(s))
				smtp_reply(s, "250-AUTH PLAIN LOGIN");
			smtp_reply(s, "250 HELP");
		}
		return;

	case QUERY_MAIL:
		if (status != FILTER_OK) {
			smtp_tx_free(s->tx);
			code = code ? code : 530;
			line = line ? line : "Sender rejected";
			smtp_reply(s, "%d %s", code, line);
			return;
		}

		/* only check sendertable if defined and user has authenticated */
		if (s->flags & SF_AUTHENTICATED && s->listener->sendertable[0]) {
			m_create(p_lka, IMSG_SMTP_CHECK_SENDER, 0, 0, -1);
			m_add_id(p_lka, s->id);
			m_add_string(p_lka, s->listener->sendertable);
			m_add_string(p_lka, s->username);
			m_add_mailaddr(p_lka, &s->tx->evp.sender);
			m_close(p_lka);
			tree_xset(&wait_lka_mail, s->id, s);
		}
		else
			smtp_queue_create_message(s);
		return;

	case QUERY_RCPT:
		if (status != FILTER_OK) {
			code = code ? code : 530;
			line = line ? line : "Recipient rejected";
			smtp_reply(s, "%d %s", code, line);
			return;
		}

		m_create(p_lka, IMSG_SMTP_EXPAND_RCPT, 0, 0, -1);
		m_add_id(p_lka, s->id);
		m_add_envelope(p_lka, &s->tx->evp);
		m_close(p_lka);
		tree_xset(&wait_lka_rcpt, s->id, s);
		return;

	case QUERY_DATA:
		if (status != FILTER_OK) {
			code = code ? code : 530;
			line = line ? line : "Message rejected";
			smtp_reply(s, "%d %s", code, line);
			return;
		}
		smtp_queue_open_message(s);
		return;

	case QUERY_EOM:
		if (status != FILTER_OK) {
			tree_pop(&wait_filter_data, s->id);
			smtp_queue_rollback(s);
			smtp_tx_free(s->tx);
			code = code ? code : 530;
			line = line ? line : "Message rejected";
			smtp_reply(s, "%d %s", code, line);
			smtp_enter_state(s, STATE_HELO);
			return;
		}
		smtp_message_end(s);
		return;

	default:
		log_warn("smtp: bad mfa query type %d", query);
	}
}

void
d1314 1
a1314 1
		smtp_filter_eom(s);
d1396 19
a1414 1
		smtp_filter_helo(s);
d1551 12
a1562 1
		smtp_filter_mail(s);
d1592 5
a1596 1
		smtp_filter_rcpt(s);
d1631 1
a1631 1
		smtp_filter_data(s);
d1909 1
d1924 19
a1942 1
	smtp_filter_connect(s, (struct sockaddr *)&ss);
a2320 42
}

static void
smtp_filter_connect(struct smtp_session *s, struct sockaddr *sa)
{
	tree_xset(&wait_filter, s->id, s);
	smtp_filter_response(s->id, QUERY_CONNECT, FILTER_OK, 0, NULL);
}

static void
smtp_filter_eom(struct smtp_session *s)
{
	tree_xset(&wait_filter, s->id, s);
	smtp_filter_response(s->id, QUERY_EOM, FILTER_OK, 0, NULL);
}

static void
smtp_filter_helo(struct smtp_session *s)
{
	tree_xset(&wait_filter, s->id, s);
	smtp_filter_response(s->id, QUERY_HELO, FILTER_OK, 0, NULL);
}

static void
smtp_filter_mail(struct smtp_session *s)
{
	tree_xset(&wait_filter, s->id, s);
	smtp_filter_response(s->id, QUERY_MAIL, FILTER_OK, 0, NULL);
}

static void
smtp_filter_rcpt(struct smtp_session *s)
{
	tree_xset(&wait_filter, s->id, s);
	smtp_filter_response(s->id, QUERY_RCPT, FILTER_OK, 0, NULL);
}

static void
smtp_filter_data(struct smtp_session *s)
{
	tree_xset(&wait_filter, s->id, s);
	smtp_filter_response(s->id, QUERY_DATA, FILTER_OK, 0, NULL);
@


1.304
log
@fix descriptor leak in the smtp congestion mechanism

diff from Henri Kemppainen; ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.303 2017/05/17 14:00:06 deraadt Exp $	*/
a71 3
	SF_FILTERCONN		= 0x0100,
	SF_FILTERDATA		= 0x0200,
	SF_FILTERTX		= 0x0400,
d116 1
a116 1
	struct io		*oev;
a166 1
static void smtp_data_io(struct io *, int, void *);
a192 5
static void smtp_filter_rset(struct smtp_session *);
static void smtp_filter_disconnect(struct smtp_session *);
static void smtp_filter_tx_begin(struct smtp_session *);
static void smtp_filter_tx_commit(struct smtp_session *);
static void smtp_filter_tx_rollback(struct smtp_session *);
a721 1
			smtp_filter_tx_rollback(s);
a725 1
			smtp_filter_tx_rollback(s);
a776 1
			smtp_filter_tx_rollback(s);
d804 1
a804 1
		filter_build_fd_chain(s->id, imsg->fd);
a859 1
			smtp_filter_tx_rollback(s);
a866 1
		smtp_filter_tx_commit(s);
a1081 1
			smtp_filter_tx_rollback(s);
a1130 1
			smtp_filter_tx_rollback(s);
d1157 3
a1159 1
	if (fd == -1) {
d1166 1
a1166 4
	io_set_nonblocking(fd);
	s->tx->oev = io_new();
	io_set_callback(s->tx->oev, smtp_data_io, s);
	io_set_fd(s->tx->oev, fd);
d1168 1
a1168 1
	io_print(s->tx->oev, "Received: ");
d1170 1
a1170 1
		io_printf(s->tx->oev, "from %s (%s [%s])",
d1175 1
a1175 1
	io_printf(s->tx->oev, "\n\tby %s (%s) with %sSMTP%s%s id %08x",
d1185 1
a1185 1
		io_printf(s->tx->oev, " (%s:%s:%d:%s)",
d1193 2
a1194 1
			io_printf(s->tx->oev, " auth=%s", s->username[0] ? "yes" : "no");
d1196 1
a1196 1
				io_printf(s->tx->oev, " user=%s", s->username);
d1201 1
a1201 1
		io_printf(s->tx->oev, "\n\tfor <%s@@%s>",
d1206 1
a1206 5
	io_printf(s->tx->oev, ";\n\t%s\n", time_to_text(time(NULL)));

	s->tx->odatalen = io_queued(s->tx->oev);

	io_set_write(s->tx->oev);
d1294 1
a1294 2
			if (io_queued(s->tx->oev) == 0)
				smtp_data_io_done(s);
d1425 2
a1426 2
	if (tx->oev)
		io_free(tx->oev);
a1433 36
smtp_data_io(struct io *io, int evt, void *arg)
{
	struct smtp_session    *s = arg;

	log_trace(TRACE_IO, "smtp: %p (data): %s %s", s, io_strevent(evt),
	    io_strio(io));

	switch (evt) {
	case IO_TIMEOUT:
	case IO_DISCONNECTED:
	case IO_ERROR:
		log_debug("debug: smtp: %p: io error on mfa", s);
		io_free(s->tx->oev);
		s->tx->oev = NULL;
		s->tx->msgflags |= MF_ERROR_IO;
		if (io_paused(s->io, IO_IN)) {
			log_debug("debug: smtp: %p: resuming session after mfa error", s);
			io_resume(s->io, IO_IN);
		}
		break;

	case IO_LOWAT:
		if (io_paused(s->io, IO_IN)) {
			log_debug("debug: smtp: %p: filter congestion over: resuming session", s);
			io_resume(s->io, IO_IN);
		}
		if (s->tx->dataeom && io_queued(s->tx->oev) == 0)
			smtp_data_io_done(s);
		break;

	default:
		fatalx("smtp_data_io()");
	}
}

static void
a1437 5
	if (s->tx->oev) {
		io_free(s->tx->oev);
		s->tx->oev = NULL;
	}

a1441 1
		smtp_filter_tx_rollback(s);
d1540 1
a1540 1
		s->flags &= SF_SECURE | SF_AUTHENTICATED | SF_VERIFIED | SF_FILTERCONN;
a1682 1
		smtp_filter_tx_begin(s);
a1724 1
			smtp_filter_tx_rollback(s);
a1729 1
		smtp_filter_rset(s);
a2039 1
	s->flags |= SF_FILTERCONN;
a2066 1
		smtp_filter_tx_rollback(s);
d2079 3
d2095 1
a2095 1
	len = io_vprintf(s->tx->oev, fmt, ap);
a2173 1
		smtp_filter_tx_rollback(s);
a2176 3
	if (s->flags & SF_FILTERCONN)
		smtp_filter_disconnect(s);

a2421 33
smtp_filter_rset(struct smtp_session *s)
{
	filter_event(s->id, EVENT_RESET);
}

static void
smtp_filter_tx_begin(struct smtp_session *s)
{
	s->flags |= SF_FILTERTX;
	filter_event(s->id, EVENT_TX_BEGIN);
}

static void
smtp_filter_tx_commit(struct smtp_session *s)
{
	s->flags &= ~SF_FILTERTX;
	filter_event(s->id, EVENT_TX_COMMIT);
}

static void
smtp_filter_tx_rollback(struct smtp_session *s)
{
	s->flags &= ~SF_FILTERTX;
	filter_event(s->id, EVENT_TX_ROLLBACK);
}

static void
smtp_filter_disconnect(struct smtp_session *s)
{
	filter_event(s->id, EVENT_DISCONNECT);
}

static void
a2423 2
	char	*filter;

d2425 1
a2425 4

	filter = s->listener->filter[0] ? s->listener->filter : NULL;

	filter_connect(s->id, sa, (struct sockaddr *)&s->ss, s->hostname, filter);
d2432 1
a2432 1
	filter_eom(s->id, QUERY_EOM, s->tx->odatalen);
d2439 1
a2439 1
	filter_line(s->id, QUERY_HELO, s->helo);
d2446 1
a2446 1
	filter_mailaddr(s->id, QUERY_MAIL, &s->tx->evp.sender);
d2453 1
a2453 1
	filter_mailaddr(s->id, QUERY_RCPT, &s->tx->evp.rcpt);
d2460 1
a2460 1
	filter_line(s->id, QUERY_DATA, NULL);
a2519 5
	}

	if (io_queued(s->tx->oev) > DATA_HIWAT && !io_paused(s->io, IO_IN)) {
		log_debug("debug: smtp: %p: filter congestion: pausing session", s);
		io_pause(s->io, IO_IN);
@


1.303
log
@Introduce more use of freezero().  Also, remove ptr conditionals before
many functions which are free(NULL)-compat
ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.302 2016/11/30 17:43:32 eric Exp $	*/
d1477 1
a1477 3
		if (s->tx->dataeom && io_queued(s->tx->oev) == 0) {
			smtp_data_io_done(s);
		} else if (io_paused(s->io, IO_IN)) {
d1481 2
@


1.302
log
@hide internal io flags and rename IO_PAUSE_{IN,OUT} to IO_{IN,OUT}

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.301 2016/11/30 11:52:48 eric Exp $	*/
d965 1
a965 2
		explicit_bzero(resp_ca_cert->cert, resp_ca_cert->cert_len);
		free(resp_ca_cert->cert);
d1207 1
a1207 2
		if (x)
			X509_free(x);
@


1.301
log
@make struct io opaque:

- move struct io definition to ioev.c
- replace io_init/io_clear with io_new/io_free
- allocate an iobuf for each new io internally
- use struct io pointer in the rest of the code
- remove remaining uses of iobuf_*

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.300 2016/11/24 21:25:21 eric Exp $	*/
d984 1
a984 1
		io_resume(s->io, IO_PAUSE_IN);
d1258 1
a1258 1
			io_pause(s->io, IO_PAUSE_IN);
d1472 1
a1472 1
		if (io_paused(s->io, IO_PAUSE_IN)) {
d1474 1
a1474 1
			io_resume(s->io, IO_PAUSE_IN);
d1481 1
a1481 1
		} else if (io_paused(s->io, IO_PAUSE_IN)) {
d1483 1
a1483 1
			io_resume(s->io, IO_PAUSE_IN);
d2631 1
a2631 1
	if (io_queued(s->tx->oev) > DATA_HIWAT && !io_paused(s->io, IO_PAUSE_IN)) {
d2633 1
a2633 1
		io_pause(s->io, IO_PAUSE_IN);
@


1.300
log
@add an io_paused() function.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.299 2016/11/24 20:52:13 eric Exp $	*/
d119 1
a119 2
	struct iobuf		 obuf;
	struct io		 oev;
d133 1
a133 2
	struct iobuf		 iobuf;
	struct io		 io;
a642 5
	if (iobuf_init(&s->iobuf, LINE_MAX, LINE_MAX) == -1) {
		free(s);
		return (-1);
	}

d646 5
a650 5
	io_init(&s->io, &s->iobuf);
	io_set_callback(&s->io, smtp_io, s);
	io_set_fd(&s->io, sock);
	io_set_timeout(&s->io, SMTPD_SESSION_TIMEOUT * 1000);
	io_set_write(&s->io);
d962 2
a963 2
		io_set_read(&s->io);
		io_start_tls(&s->io, ssl);
d984 1
a984 1
		io_resume(&s->io, IO_PAUSE_IN);
d998 1
a998 1
	x = SSL_get_peer_certificate(io_ssl(&s->io));
d1009 1
a1009 1
		io_set_write(&s->io);
a1180 1
	iobuf_init(&s->tx->obuf, 0, 0);
d1182 3
a1184 3
	io_init(&s->tx->oev, &s->tx->obuf);
	io_set_callback(&s->tx->oev, smtp_data_io, s);
	io_set_fd(&s->tx->oev, fd);
d1186 1
a1186 1
	io_print(&s->tx->oev, "Received: ");
d1188 1
a1188 1
		io_printf(&s->tx->oev, "from %s (%s [%s])",
d1193 1
a1193 1
	io_printf(&s->tx->oev, "\n\tby %s (%s) with %sSMTP%s%s id %08x",
d1202 5
a1206 5
		x = SSL_get_peer_certificate(io_ssl(&s->io));
		io_printf(&s->tx->oev, " (%s:%s:%d:%s)",
		    SSL_get_version(io_ssl(&s->io)),
		    SSL_get_cipher_name(io_ssl(&s->io)),
		    SSL_get_cipher_bits(io_ssl(&s->io), NULL),
d1212 1
a1212 1
			io_printf(&s->tx->oev, " auth=%s", s->username[0] ? "yes" : "no");
d1214 1
a1214 1
				io_printf(&s->tx->oev, " user=%s", s->username);
d1219 1
a1219 1
		io_printf(&s->tx->oev, "\n\tfor <%s@@%s>",
d1224 1
a1224 1
	io_printf(&s->tx->oev, ";\n\t%s\n", time_to_text(time(NULL)));
d1226 1
a1226 1
	s->tx->odatalen = io_queued(&s->tx->oev);
d1228 1
a1228 1
	io_set_write(&s->tx->oev);
d1252 1
a1252 1
		    s->id, ss_to_text(&s->ss), s->hostname, ssl_to_text(io_ssl(&s->io)));
d1258 1
a1258 1
			io_pause(&s->io, IO_PAUSE_IN);
d1275 2
a1276 2
		line = io_getline(&s->io, &len);
		if ((line == NULL && io_datalen(&s->io) >= LINE_MAX) ||
d1297 1
a1297 1
		if (io_datalen(&s->io)) {
d1316 1
a1316 1
			if (io_queued(&s->tx->oev) == 0)
a1394 1
	io_init(&tx->oev, NULL);
d1448 3
d1469 2
a1470 2
		io_clear(&s->tx->oev);
		iobuf_clear(&s->tx->obuf);
d1472 1
a1472 1
		if (io_paused(&s->io, IO_PAUSE_IN)) {
d1474 1
a1474 1
			io_resume(&s->io, IO_PAUSE_IN);
d1479 1
a1479 1
		if (s->tx->dataeom && io_queued(&s->tx->oev) == 0) {
d1481 1
a1481 1
		} else if (io_paused(&s->io, IO_PAUSE_IN)) {
d1483 1
a1483 1
			io_resume(&s->io, IO_PAUSE_IN);
d1496 5
a1500 2
	io_clear(&s->tx->oev);
	iobuf_clear(&s->tx->obuf);
d2075 1
a2075 1
		if (getsockname(io_fileno(&s->io), sa, &sa_len) == -1) {
d2103 1
a2103 1
	if (getsockname(io_fileno(&s->io), (struct sockaddr*)&ss, &sl) == -1) {
d2162 1
a2162 1
	len = io_vprintf(&s->tx->oev, fmt, ap);
d2192 1
a2192 1
	io_xprintf(&s->io, "%s\r\n", buf);
d2239 1
a2239 1
		if (s->tx->msgid) {
a2240 3
			io_clear(&s->tx->oev);
			iobuf_clear(&s->tx->obuf);
		}
d2253 1
a2253 2
	io_clear(&s->io);
	iobuf_clear(&s->iobuf);
d2342 1
a2342 1
	x = SSL_get_peer_certificate(io_ssl(&s->io));
d2345 1
a2345 1
	xchain = SSL_get_peer_cert_chain(io_ssl(&s->io));
d2631 1
a2631 1
	if (io_queued(&s->tx->oev) > DATA_HIWAT && !io_paused(&s->io, IO_PAUSE_IN)) {
d2633 1
a2633 1
		io_pause(&s->io, IO_PAUSE_IN);
@


1.299
log
@add an io_fileno() accessor

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.298 2016/11/24 20:44:04 eric Exp $	*/
d1478 1
a1478 1
		if (s->io.flags & IO_PAUSE_IN) {
d1487 1
a1487 1
		} else if (s->io.flags & IO_PAUSE_IN) {
d2638 2
a2639 2
	if (io_queued(&s->tx->oev) > DATA_HIWAT && !(s->io.flags & IO_PAUSE_IN)) {
		log_debug("debug: smtp: %p: filter congestion over: pausing session", s);
@


1.298
log
@add an io_ssl() accessor

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.297 2016/11/24 12:58:27 eric Exp $	*/
d2078 1
a2078 1
		if (getsockname(s->io.sock, sa, &sa_len) == -1) {
d2106 1
a2106 1
	if (getsockname(s->io.sock, (struct sockaddr*)&ss, &sl) == -1) {
@


1.297
log
@add an io_error() accessor to avoid dereferencing the io struct directly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.296 2016/11/24 07:57:48 eric Exp $	*/
d1005 1
a1005 1
	x = SSL_get_peer_certificate(s->io.ssl);
d1210 1
a1210 1
		x = SSL_get_peer_certificate(s->io.ssl);
d1212 3
a1214 3
		    SSL_get_version(s->io.ssl),
		    SSL_get_cipher_name(s->io.ssl),
		    SSL_get_cipher_bits(s->io.ssl, NULL),
d1260 1
a1260 1
		    s->id, ss_to_text(&s->ss), s->hostname, ssl_to_text(s->io.ssl));
d2349 1
a2349 1
	x = SSL_get_peer_certificate(s->io.ssl);
d2352 1
a2352 1
	xchain = SSL_get_peer_cert_chain(s->io.ssl);
@


1.296
log
@reset the io event when data is queued.
remove all calls to io_reload() which are now unnecessary.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.295 2016/11/22 07:28:42 eric Exp $	*/
d1384 1
a1384 1
		    s->id, ss_to_text(&s->ss), s->hostname, io->error);
@


1.295
log
@Normalize the io input buffer internally when reinstalling the io event, so
the caller doesn't have to bother with this.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.294 2016/11/21 13:00:43 eric Exp $	*/
a740 1
			io_reload(&s->io);
a746 1
			io_reload(&s->io);
a766 1
		io_reload(&s->io);
a801 1
		io_reload(&s->io);
a816 1
			io_reload(&s->io);
a869 1
		io_reload(&s->io);
a883 1
			io_reload(&s->io);
a910 1
		io_reload(&s->io);
a949 1
		io_reload(&s->io);
a1038 1
		io_reload(&s->io);
a1077 1
			io_reload(&s->io);
a1099 1
		io_reload(&s->io);
a1108 1
			io_reload(&s->io);
a1130 1
			io_reload(&s->io);
a1145 1
			io_reload(&s->io);
a1160 1
			io_reload(&s->io);
a1184 1
		io_reload(&s->io);
a1242 1
	io_reload(&s->io);
a1325 2
			else
				io_reload(&s->tx->oev);
a1529 1
		io_reload(&s->io);
a2118 1
	io_reload(&s->io);
a2446 1
	io_reload(&s->io);
a2641 1
	io_reload(&s->tx->oev);
@


1.294
log
@replace calls to iobuf_*() functions with the corresponding io_*() wrappers.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.293 2016/11/20 08:43:36 eric Exp $	*/
d1313 1
a1313 2
		if (line == NULL) {
			iobuf_normalize(&s->iobuf);
a1314 1
		}
a1338 1
			iobuf_normalize(&s->iobuf);
a1352 1
		iobuf_normalize(&s->iobuf);
@


1.293
log
@add dedicated functions to set fd and callback on a struct io.
simplify io_init() prototype.

ok sunil@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.292 2016/11/18 09:35:27 eric Exp $	*/
d1211 1
a1211 1
	iobuf_fqueue(&s->tx->obuf, "Received: ");
d1213 1
a1213 1
		iobuf_fqueue(&s->tx->obuf, "from %s (%s [%s])",
d1218 1
a1218 1
	iobuf_fqueue(&s->tx->obuf, "\n\tby %s (%s) with %sSMTP%s%s id %08x",
d1228 1
a1228 2
		iobuf_fqueue(&s->tx->obuf,
		    " (%s:%s:%d:%s)",
d1237 1
a1237 1
			iobuf_fqueue(&s->tx->obuf, " auth=%s", s->username[0] ? "yes" : "no");
d1239 1
a1239 1
				iobuf_fqueue(&s->tx->obuf, " user=%s", s->username);
d1244 1
a1244 1
		iobuf_fqueue(&s->tx->obuf, "\n\tfor <%s@@%s>",
d1249 1
a1249 1
	iobuf_fqueue(&s->tx->obuf, ";\n\t%s\n", time_to_text(time(NULL)));
d1251 1
a1251 1
	s->tx->odatalen = iobuf_queued(&s->tx->obuf);
d1301 2
a1302 2
		line = iobuf_getline(&s->iobuf, &len);
		if ((line == NULL && iobuf_len(&s->iobuf) >= LINE_MAX) ||
d1325 1
a1325 1
		if (iobuf_len(&s->iobuf)) {
d1345 1
a1345 1
			if (iobuf_queued(&s->tx->obuf) == 0)
d1509 1
a1509 1
		if (s->tx->dataeom && iobuf_queued(&s->tx->obuf) == 0) {
d2191 1
a2191 1
	len = iobuf_vfqueue(&s->tx->obuf, fmt, ap);
d2221 1
a2221 1
	iobuf_xfqueue(&s->iobuf, "smtp_reply", "%s\r\n", buf);
d2665 1
a2665 1
	if (iobuf_queued(&s->tx->obuf) > DATA_HIWAT && !(s->io.flags & IO_PAUSE_IN)) {
@


1.292
log
@fix regression introduced in previous commit

spotted by Heiko Zimmermann

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.291 2016/11/17 07:33:06 eric Exp $	*/
d653 3
a655 1
	io_init(&s->io, sock, s, smtp_io, &s->iobuf);
d1207 3
a1209 1
	io_init(&s->tx->oev, fd, s, smtp_data_io, &s->tx->obuf);
d1428 1
a1428 1
	io_init(&tx->oev, -1, s, NULL, NULL); /* initialise 'sock', but not to 0 */
@


1.291
log
@remove IO_TLSVERIFIED which is not a io event, and inline necessary code
where the callback functions are called for this event.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.290 2016/11/16 21:30:37 eric Exp $	*/
d170 1
a701 1
	X509				*x;
d997 1
a997 20

		x = SSL_get_peer_certificate(s->io.ssl);
		if (x) {
			log_info("%016"PRIx64" smtp "
			    "event=client-cert-check address=%s host=%s result=\"%s\"",
			    s->id, ss_to_text(&s->ss), s->hostname,
			    (s->flags & SF_VERIFIED) ? "success" : "failure");
			X509_free(x);
		}

		if (s->listener->flags & F_SMTPS) {
			stat_increment("smtp.smtps", 1);
			io_set_write(&s->io);
			smtp_send_banner(s);
		}
		else {
			stat_increment("smtp.tls", 1);
			smtp_enter_state(s, STATE_HELO);
		}

d1007 25
d1293 2
a1294 1
		/* No verification required, cascade */
@


1.290
log
@pass the user pointer as parameter to the io callback instead of having
the user dereference the io structure.

ok millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.289 2016/10/16 17:15:15 eric Exp $	*/
d701 1
d997 20
a1016 1
		smtp_io(&s->io, IO_TLSVERIFIED, s->io.arg);
a1260 1
	X509		       *x;
a1287 21

	case IO_TLSVERIFIED:
		x = SSL_get_peer_certificate(s->io.ssl);
		if (x) {
			log_info("%016"PRIx64" smtp "
			    "event=client-cert-check address=%s host=%s result=\"%s\"",
			    s->id, ss_to_text(&s->ss), s->hostname,
			    (s->flags & SF_VERIFIED) ? "success" : "failure");
			X509_free(x);
		}

		if (s->listener->flags & F_SMTPS) {
			stat_increment("smtp.smtps", 1);
			io_set_write(&s->io);
			smtp_send_banner(s);
		}
		else {
			stat_increment("smtp.tls", 1);
			smtp_enter_state(s, STATE_HELO);
		}
		break;
@


1.289
log
@Remove the "phase" state variable from the smtp session.  Simply check
"helo[0]" to see if an HELO/EHLO command was received (reset after
starttls), and "tx" to know if we are in a transaction.

ok  gilles@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.288 2016/10/13 15:47:32 gilles Exp $	*/
d170 2
a171 2
static void smtp_io(struct io *, int);
static void smtp_data_io(struct io *, int);
d996 1
a996 1
		smtp_io(&s->io, IO_TLSVERIFIED);
d1235 1
a1235 1
smtp_io(struct io *io, int evt)
d1238 1
a1238 1
	struct smtp_session    *s = io->arg;
d1479 1
a1479 1
smtp_data_io(struct io *io, int evt)
d1481 1
a1481 1
	struct smtp_session    *s = io->arg;
@


1.288
log
@A logic issue in smtpd's header parsing can cause SMTP sessions to hang.

diff by eric@@, ok me
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.287 2016/10/03 19:36:11 eric Exp $	*/
a50 6
enum smtp_phase {
	PHASE_INIT = 0,
	PHASE_SETUP,
	PHASE_TRANSACTION
};

a142 1
	int			 phase;
a656 1
	s->phase = PHASE_INIT;
a791 1
			s->phase = PHASE_TRANSACTION;
a913 1
		s->phase = PHASE_SETUP;
a1082 1
		s->phase = PHASE_SETUP;
a1147 1
			s->phase = PHASE_SETUP;
d1253 1
a1253 1
		s->phase = PHASE_INIT;
a1545 1
		s->phase = PHASE_SETUP;
d1602 1
a1602 1
		if (s->phase != PHASE_INIT) {
d1637 1
a1637 1
		if (s->phase != PHASE_SETUP) {
d1669 1
a1669 1
		if (s->phase != PHASE_SETUP) {
d1715 1
a1715 1
		if (s->phase != PHASE_SETUP) {
d1775 1
a1775 1
		if (s->phase != PHASE_TRANSACTION) {
d1803 1
a1803 1
		if (s->phase != PHASE_TRANSACTION && s->phase != PHASE_SETUP) {
a1817 2

		s->phase = PHASE_SETUP;
d1823 1
a1823 1
		if (s->phase != PHASE_TRANSACTION) {
a2154 2

	s->phase = PHASE_SETUP;
@


1.287
log
@fix smtp session logic bug that can lead to a server crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.286 2016/09/03 22:59:06 giovanni Exp $	*/
d1351 2
@


1.286
log
@log IP/hostname for all SMTP operations.
patch from Pavel Korovin, thanks
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.285 2016/07/29 08:53:07 giovanni Exp $	*/
d1159 1
d1556 1
@


1.285
log
@log ip addresses as well in authentication phase
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.284 2016/07/22 12:12:29 eric Exp $	*/
d906 2
a907 2
			log_info("%016"PRIx64" smtp event=message msgid=%08x "
			    "from=<%s%s%s> to=<%s%s%s> size=%zu ndest=%zu proto=%s",
d909 1
d973 3
a975 2
			log_info("%016"PRIx64" smtp event=closed reason=ca-failure",
			    s->id);
d1001 2
a1002 2
			    "event=closed reason=cert-check-failed",
			    s->id);
d1039 2
a1040 2
			    "event=closed reason=filter-reject",
			    s->id);
d1260 2
a1261 2
		log_info("%016"PRIx64" smtp event=starttls ciphers=\"%s\"",
		    s->id, ssl_to_text(s->io.ssl));
d1273 2
a1274 2
			    "event=closed reason=no-client-cert",
			    s->id);
d1285 2
a1286 2
			    "event=client-cert-check result=\"%s\"",
			    s->id,
d1362 3
a1364 2
			log_info("%016"PRIx64" smtp event=closed reason=quit",
			    s->id);
d1393 3
a1395 2
		log_info("%016"PRIx64" smtp event=closed reason=timeout",
		    s->id);
d1400 3
a1402 2
		log_info("%016"PRIx64" smtp event=closed reason=disconnect",
		    s->id);
d1407 3
a1409 2
		log_info("%016"PRIx64" smtp event=closed reason=\"io-error: %s\"",
		    s->id, io->error);
d2233 2
a2234 2
			    "event=bad-input result=\"%.*s\"",
			    s->id, n, buf);
d2237 4
a2240 2
			log_info("smtp-in: Failed command on session %016"PRIx64
			    ": \"AUTH PLAIN (...)\" => %.*s", s->id, n, buf);
d2243 4
a2246 2
			log_info("smtp-in: Failed command on session %016"PRIx64
			    ": \"AUTH LOGIN (username)\" => %.*s", s->id, n, buf);
d2249 4
a2252 2
			log_info("smtp-in: Failed command on session %016"PRIx64
			    ": \"AUTH LOGIN (password)\" => %.*s", s->id, n, buf);
d2257 3
a2259 2
			    "event=failed-command command=\"%s\" result=\"%.*s\"",
			    s->id, tmp, n, buf);
@


1.284
log
@Create a smtp transaction context on a session only for the duration of
that transaction.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.278 2016/06/29 06:46:06 eric Exp $	*/
d937 3
a939 2
			    "event=authentication user=%s result=ok",
			    s->id, user);
d946 3
a948 2
			    "event=authentication user=%s result=permfail",
			    s->id, user);
d954 3
a956 2
			    "event=authentication user=%s result=tempfail",
			    s->id, user);
@


1.284.4.1
log
@OpenBSD 6.0 errata 10, Oct 3, 2016

A bug in the smtp session logic can lead to a server crash.
Found and reported by Mickael Torres.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.284 2016/07/22 12:12:29 eric Exp $	*/
a1153 1
			s->phase = PHASE_SETUP;
a1545 1
		s->phase = PHASE_SETUP;
@


1.284.4.2
log
@"A logic issue in smtpd's header parsing can cause SMTP sessions to hang"
errata 014
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.284.4.1 2016/10/04 00:12:27 jsg Exp $	*/
a1345 2
			else
				io_reload(&s->tx->oev);
@


1.283
log
@remove misleading comment. it's not true anymore.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.282 2016/07/02 08:47:30 eric Exp $	*/
a187 1
static void smtp_message_reset(struct smtp_session *, int);
a650 5
	if (smtp_tx(s) == 0) {
		free(s);
		return -1;
	}

a651 1
		smtp_tx_free(s->tx);
a654 1
	TAILQ_INIT(&s->tx->rcpts);
a661 1
	io_init(&s->tx->oev, -1, s, NULL, NULL); /* initialise 'sock', but not to 0 */
a671 22
	/* Setup parser and callbacks before smtp_connected() can be called */
	rfc2822_parser_init(&s->tx->rfc2822_parser);
	rfc2822_header_default_callback(&s->tx->rfc2822_parser,
	    header_default_callback, s);
	rfc2822_header_callback(&s->tx->rfc2822_parser, "bcc",
	    header_bcc_callback, s);
	rfc2822_header_callback(&s->tx->rfc2822_parser, "from",
	    header_domain_append_callback, s);
	rfc2822_header_callback(&s->tx->rfc2822_parser, "to",
	    header_domain_append_callback, s);
	rfc2822_header_callback(&s->tx->rfc2822_parser, "cc",
	    header_domain_append_callback, s);
	rfc2822_body_callback(&s->tx->rfc2822_parser,
	    dataline_callback, s);

	if (listener->local || listener->port == 587) {
		rfc2822_missing_header_callback(&s->tx->rfc2822_parser, "date",
		    header_missing_callback, s);
		rfc2822_missing_header_callback(&s->tx->rfc2822_parser, "message-id",
		    header_missing_callback, s);
	}

d744 1
d750 1
d805 1
d892 1
d920 1
a920 1

a922 1
		smtp_message_reset(s, 0);
d1095 1
d1149 1
a1152 1
			smtp_message_reset(s, 0);
d1418 3
d1424 34
d1464 9
d1544 1
a1544 1
		smtp_message_reset(s, 0);
a1630 2
		smtp_message_reset(s, 1);

d1749 6
a1754 1
		smtp_message_reset(s, 1);
d1758 1
d1763 2
a1764 1
		if (args && smtp_parse_mail_args(s, args) == -1)
d1766 1
d1810 1
a1810 1
		if (s->flags & SF_FILTERTX)
d1812 4
a1815 2
		if (s->tx->msgid)
			smtp_queue_rollback(s);
a1819 1
		smtp_message_reset(s, 0);
a1837 2
		rfc2822_parser_reset(&s->tx->rfc2822_parser);

d2169 1
a2169 1
		smtp_message_reset(s, 0);
a2176 35
static void
smtp_message_reset(struct smtp_session *s, int prepare)
{
	struct smtp_rcpt	*rcpt;

	while ((rcpt = TAILQ_FIRST(&s->tx->rcpts))) {
		TAILQ_REMOVE(&s->tx->rcpts, rcpt, entry);
		free(rcpt);
	}

	s->tx->msgid = 0;
	memset(&s->tx->evp, 0, sizeof s->tx->evp);
	s->tx->msgflags = 0;
	s->tx->destcount = 0;
	s->tx->rcptcount = 0;
	s->tx->datain = 0;
	s->tx->odatalen = 0;
	s->tx->dataeom = 0;
	s->tx->rcvcount = 0;
	s->tx->hdrdone = 0;

	if (prepare) {
		s->tx->evp.ss = s->ss;
		(void)strlcpy(s->tx->evp.tag, s->listener->tag, sizeof(s->tx->evp.tag));
		(void)strlcpy(s->tx->evp.smtpname, s->smtpname, sizeof(s->tx->evp.smtpname));
		(void)strlcpy(s->tx->evp.hostname, s->hostname, sizeof s->tx->evp.hostname);
		(void)strlcpy(s->tx->evp.helo, s->helo, sizeof s->tx->evp.helo);

		if (s->flags & SF_BOUNCE)
			s->tx->evp.flags |= EF_BOUNCE;
		if (s->flags & SF_AUTHENTICATED)
			s->tx->evp.flags |= EF_AUTHENTICATED;
	}
}

a2251 2
	struct smtp_rcpt	*rcpt;

d2256 8
a2263 4
	if (s->tx->msgid) {
		smtp_queue_rollback(s);
		io_clear(&s->tx->oev);
		iobuf_clear(&s->tx->obuf);
a2265 3
	if (s->flags & SF_FILTERTX)
		smtp_filter_tx_rollback(s);

a2273 7
	while ((rcpt = TAILQ_FIRST(&s->tx->rcpts))) {
		TAILQ_REMOVE(&s->tx->rcpts, rcpt, entry);
		free(rcpt);
	}

	rfc2822_parser_release(&s->tx->rfc2822_parser);

a2275 1
	smtp_tx_free(s->tx);
@


1.282
log
@datain counter is part of the transaction state

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.281 2016/07/02 07:55:59 eric Exp $	*/
a1254 4
	/*
	 * XXX This is not exactly fair, since this is not really
	 * user data.
	 */
@


1.281
log
@set the msgid on the transaction

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.280 2016/07/01 19:52:31 eric Exp $	*/
d123 1
a156 3

	size_t			 datain;

d2172 1
a2172 1
	s->datain = 0;
d2635 2
a2636 2
	s->datain += strlen(line) + 1;
	if (s->datain > env->sc_maxsize) {
@


1.280
log
@always refer to the helo string stored on the session

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.279 2016/07/01 17:53:23 eric Exp $	*/
d116 1
d828 1
d932 1
a932 1
		    evpid_to_msgid(s->tx->evp.id));
d938 1
a938 1
			    evpid_to_msgid(s->tx->evp.id),
d1229 1
a1229 1
	    evpid_to_msgid(s->tx->evp.id));
d1793 1
a1793 1
		if (s->tx->evp.id)
d2169 1
d2275 1
a2275 1
	if (s->tx->evp.id) {
d2518 1
a2518 1
	m_add_msgid(p_queue, evpid_to_msgid(s->tx->evp.id));
d2528 1
a2528 1
	m_add_msgid(p_queue, evpid_to_msgid(s->tx->evp.id));
d2537 1
a2537 1
	m_add_msgid(p_queue, evpid_to_msgid(s->tx->evp.id));
@


1.279
log
@flag the local socket listener as local.
clarify check for local listeners.

ok gilles@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.278 2016/06/29 06:46:06 eric Exp $	*/
d1101 1
a1101 1
		    s->tx->evp.helo,
d1217 1
a1217 1
		    s->tx->evp.helo,
@


1.278
log
@Explicitely enclose SMTP transactions between BEGIN and COMMIT/ROLLBACK
filter events. Bump filter API version.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.277 2016/06/23 11:56:19 eric Exp $	*/
d697 1
a697 1
	if (hostname || listener->local || listener->port == 587) {
@


1.277
log
@move transaction-specific states from struct smtp_session to struct smtp_tx

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.276 2016/06/17 18:56:51 otto Exp $	*/
d80 1
d209 3
a211 2
static void smtp_filter_commit(struct smtp_session *);
static void smtp_filter_rollback(struct smtp_session *);
d775 1
d780 1
d833 1
d919 1
a919 1
			smtp_filter_rollback(s);
d927 1
a927 1
		smtp_filter_commit(s);
d1122 1
a1122 1
			smtp_filter_rollback(s);
d1174 1
a1174 1
			smtp_filter_rollback(s);
d1510 1
a1510 1
		smtp_filter_rollback(s);
d1747 1
d1789 2
a1790 2
		smtp_filter_rset(s);

d1794 2
d2141 1
d2278 3
d2545 8
a2552 1
smtp_filter_commit(struct smtp_session *s)
d2554 2
a2555 1
	filter_event(s->id, EVENT_COMMIT);
d2559 1
a2559 1
smtp_filter_rollback(struct smtp_session *s)
d2561 2
a2562 1
	filter_event(s->id, EVENT_ROLLBACK);
@


1.276
log
@Also add missing date or message-id when listening on the submit port
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.275 2016/06/15 21:52:47 eric Exp $	*/
d113 22
a152 2
	struct envelope		 evp;

a154 6
	int			 msgflags;
	int			 msgcode;
	size_t			 rcptcount;
	size_t			 destcount;
	TAILQ_HEAD(, smtp_rcpt)	 rcpts;

a155 6
	size_t			 odatalen;
	struct iobuf		 obuf;
	struct io		 oev;
	int			 hdrdone;
	int			 rcvcount;
	int			 dataeom;
a156 1
	int			 skiphdr;
d159 1
a159 1
	struct rfc2822_parser	 rfc2822_parser;
d197 3
d550 1
a550 1
					header_address_rewrite_buffer(buffer, mailaddr_to_text(&s->evp.sender),
d596 1
a596 1
			header_address_rewrite_buffer(buffer, mailaddr_to_text(&s->evp.sender),
d650 6
d657 1
d661 1
a661 1
	TAILQ_INIT(&s->rcpts);
d669 1
a669 1
	io_init(&s->oev, -1, s, NULL, NULL); /* initialise 'sock', but not to 0 */
d681 2
a682 2
	rfc2822_parser_init(&s->rfc2822_parser);
	rfc2822_header_default_callback(&s->rfc2822_parser,
d684 1
a684 1
	rfc2822_header_callback(&s->rfc2822_parser, "bcc",
d686 1
a686 1
	rfc2822_header_callback(&s->rfc2822_parser, "from",
d688 1
a688 1
	rfc2822_header_callback(&s->rfc2822_parser, "to",
d690 1
a690 1
	rfc2822_header_callback(&s->rfc2822_parser, "cc",
d692 1
a692 1
	rfc2822_body_callback(&s->rfc2822_parser,
d696 1
a696 1
		rfc2822_missing_header_callback(&s->rfc2822_parser, "date",
d698 1
a698 1
		rfc2822_missing_header_callback(&s->rfc2822_parser, "message-id",
d768 1
a768 1
				rfc2822_header_callback(&s->rfc2822_parser, "from",
d823 2
a824 2
			s->evp.id = msgid_to_evpid(msgid);
			s->rcptcount = 0;
d867 1
a867 1
			s->destcount++;
d870 1
a870 1
			s->msgflags |= MF_QUEUE_ENVELOPE_FAIL;
d882 1
a882 1
		if (s->msgflags & MF_QUEUE_ENVELOPE_FAIL) {
d894 3
a896 3
			rcpt->destcount = s->destcount;
			rcpt->maddr = s->evp.rcpt;
			TAILQ_INSERT_TAIL(&s->rcpts, rcpt, entry);
d898 2
a899 2
			s->destcount = 0;
			s->rcptcount++;
d925 1
a925 1
		    evpid_to_msgid(s->evp.id));
d927 1
a927 1
		TAILQ_FOREACH(rcpt, &s->rcpts, entry) {
d931 4
a934 4
			    evpid_to_msgid(s->evp.id),
			    s->evp.sender.user,
			    s->evp.sender.user[0] == '\0' ? "" : "@@",
			    s->evp.sender.domain,
d938 1
a938 1
			    s->odatalen,
d1096 1
a1096 1
		    s->evp.helo,
d1131 1
a1131 1
			m_add_mailaddr(p_lka, &s->evp.sender);
d1150 1
a1150 1
		m_add_envelope(p_lka, &s->evp);
d1205 1
a1205 1
	iobuf_init(&s->obuf, 0, 0);
d1207 1
a1207 1
	io_init(&s->oev, fd, s, smtp_data_io, &s->obuf);
d1209 1
a1209 1
	iobuf_fqueue(&s->obuf, "Received: ");
d1211 2
a1212 2
		iobuf_fqueue(&s->obuf, "from %s (%s [%s])",
		    s->evp.helo,
d1216 1
a1216 1
	iobuf_fqueue(&s->obuf, "\n\tby %s (%s) with %sSMTP%s%s id %08x",
d1222 1
a1222 1
	    evpid_to_msgid(s->evp.id));
d1226 1
a1226 1
		iobuf_fqueue(&s->obuf,
d1236 1
a1236 1
			iobuf_fqueue(&s->obuf, " auth=%s", s->username[0] ? "yes" : "no");
d1238 1
a1238 1
				iobuf_fqueue(&s->obuf, " user=%s", s->username);
d1242 4
a1245 4
	if (s->rcptcount == 1) {
		iobuf_fqueue(&s->obuf, "\n\tfor <%s@@%s>",
		    s->evp.rcpt.user,
		    s->evp.rcpt.domain);
d1248 1
a1248 1
	iobuf_fqueue(&s->obuf, ";\n\t%s\n", time_to_text(time(NULL)));
d1254 1
a1254 1
	s->odatalen = iobuf_queued(&s->obuf);
d1256 1
a1256 1
	io_set_write(&s->oev);
d1363 1
a1363 1
			rfc2822_parser_flush(&s->rfc2822_parser);
d1368 2
a1369 2
			s->dataeom = 1;
			if (iobuf_queued(&s->obuf) == 0)
d1435 23
d1471 3
a1473 3
		io_clear(&s->oev);
		iobuf_clear(&s->obuf);
		s->msgflags |= MF_ERROR_IO;
d1481 1
a1481 1
		if (s->dataeom && iobuf_queued(&s->obuf) == 0) {
d1497 3
a1499 3
	log_debug("debug: smtp: %p: data io done (%zu bytes)", s, s->odatalen);
	io_clear(&s->oev);
	iobuf_clear(&s->obuf);
d1501 1
a1501 1
	if (s->msgflags & MF_ERROR) {
d1508 1
a1508 1
		if (s->msgflags & MF_ERROR_SIZE)
d1510 1
a1510 1
		else if (s->msgflags & MF_ERROR_LOOP)
d1514 1
a1514 1
                else if (s->msgflags & MF_ERROR_RESOURCES)
d1517 1
a1517 1
                else if (s->msgflags & MF_ERROR_MALFORMED)
d1522 1
a1522 1
		else if (s->msgflags)
d1733 1
a1733 1
		if (smtp_mailaddr(&s->evp.sender, args, 1, &args,
d1755 1
a1755 1
		if (s->rcptcount >= env->sc_session_max_rcpt) {
d1762 1
a1762 1
		if (smtp_mailaddr(&s->evp.rcpt, args, 0, &args,
d1785 1
a1785 1
		if (s->evp.id)
d1801 1
a1801 1
		if (s->rcptcount == 0) {
d1808 1
a1808 1
		rfc2822_parser_reset(&s->rfc2822_parser);
d1990 1
a1990 1
				s->evp.dsn_notify |= flag;
d1992 2
a1993 2
			if (s->evp.dsn_notify & DSN_NEVER &&
			    s->evp.dsn_notify & (DSN_SUCCESS | DSN_FAILURE |
d2002 1
a2002 1
			if (!text_to_mailaddr(&s->evp.dsn_orcpt, b)) {
d2036 1
a2036 1
				s->evp.dsn_ret = DSN_RETHDRS;
d2038 1
a2038 1
				s->evp.dsn_ret = DSN_RETFULL;
d2041 2
a2042 2
			if (strlcpy(s->evp.dsn_envid, b, sizeof(s->evp.dsn_envid))
			    >= sizeof(s->evp.dsn_envid)) {
d2126 1
a2126 1
	log_debug("debug: %p: end of message, msgflags=0x%04x", s, s->msgflags);
d2132 1
a2132 1
	if (s->msgflags & MF_ERROR) {
d2134 1
a2134 1
		if (s->msgflags & MF_ERROR_SIZE)
d2139 1
a2139 1
			smtp_reply(s, "%d Message rejected", s->msgcode);
d2153 2
a2154 2
	while ((rcpt = TAILQ_FIRST(&s->rcpts))) {
		TAILQ_REMOVE(&s->rcpts, rcpt, entry);
d2158 4
a2161 4
	memset(&s->evp, 0, sizeof s->evp);
	s->msgflags = 0;
	s->destcount = 0;
	s->rcptcount = 0;
d2163 4
a2166 4
	s->odatalen = 0;
	s->dataeom = 0;
	s->rcvcount = 0;
	s->hdrdone = 0;
d2169 5
a2173 5
		s->evp.ss = s->ss;
		(void)strlcpy(s->evp.tag, s->listener->tag, sizeof(s->evp.tag));
		(void)strlcpy(s->evp.smtpname, s->smtpname, sizeof(s->evp.smtpname));
		(void)strlcpy(s->evp.hostname, s->hostname, sizeof s->evp.hostname);
		(void)strlcpy(s->evp.helo, s->helo, sizeof s->evp.helo);
d2176 1
a2176 1
			s->evp.flags |= EF_BOUNCE;
d2178 1
a2178 1
			s->evp.flags |= EF_AUTHENTICATED;
d2188 1
a2188 1
	if (s->msgflags & MF_ERROR)
d2192 1
a2192 1
	len = iobuf_vfqueue(&s->obuf, fmt, ap);
d2197 1
a2197 1
		s->msgflags |= MF_ERROR_IO;
d2200 1
a2200 1
		s->odatalen += len;
d2263 1
a2263 1
	if (s->evp.id) {
d2265 2
a2266 2
		io_clear(&s->oev);
		iobuf_clear(&s->obuf);
d2277 2
a2278 2
	while ((rcpt = TAILQ_FIRST(&s->rcpts))) {
		TAILQ_REMOVE(&s->rcpts, rcpt, entry);
d2282 1
a2282 1
	rfc2822_parser_release(&s->rfc2822_parser);
d2286 1
d2503 1
a2503 1
	m_add_msgid(p_queue, evpid_to_msgid(s->evp.id));
d2513 1
a2513 1
	m_add_msgid(p_queue, evpid_to_msgid(s->evp.id));
d2522 1
a2522 1
	m_add_msgid(p_queue, evpid_to_msgid(s->evp.id));
d2566 1
a2566 1
	filter_eom(s->id, QUERY_EOM, s->odatalen);
d2580 1
a2580 1
	filter_mailaddr(s->id, QUERY_MAIL, &s->evp.sender);
d2587 1
a2587 1
	filter_mailaddr(s->id, QUERY_RCPT, &s->evp.rcpt);
d2605 1
a2605 1
	if (s->msgflags & MF_ERROR)
d2615 1
a2615 1
		s->msgflags |= MF_ERROR_SIZE;
d2619 1
a2619 1
	if (!s->hdrdone) {
d2622 1
a2622 1
		if (isspace((unsigned char)line[0]) && s->skiphdr)
d2624 1
a2624 1
		s->skiphdr = 0;
d2628 1
a2628 1
			s->skiphdr = 1;
d2634 3
a2636 3
			s->rcvcount++;
		if (s->rcvcount == MAX_HOPS_COUNT) {
			s->msgflags |= MF_ERROR_LOOP;
d2642 1
a2642 1
			s->hdrdone = 1;
d2645 1
a2645 1
	ret = rfc2822_parser_feed(&s->rfc2822_parser, line);
d2647 1
a2647 1
		s->msgflags |= MF_ERROR_RESOURCES;
d2652 1
a2652 1
		s->msgflags |= MF_ERROR_MALFORMED;
d2656 1
a2656 1
	if (iobuf_queued(&s->obuf) > DATA_HIWAT && !(s->io.flags & IO_PAUSE_IN)) {
d2660 1
a2660 1
	io_reload(&s->oev);
@


1.275
log
@properly reset the transaction when a filter rejects a message.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.274 2016/06/15 19:56:07 gilles Exp $	*/
d678 1
a678 1
	if (hostname || listener->local) {
@


1.274
log
@'Received' header violates RFC when receiving a TLS session, rework format

reported by vstakhov
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.273 2016/06/08 06:52:56 gilles Exp $	*/
d1153 1
d1157 2
@


1.273
log
@quote space-containing values in smtpd logs or they become hard to parse

diff by Pavel Korovin <p@@tristero.se>, ok giovanni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.272 2016/05/22 16:31:21 gilles Exp $	*/
d1207 1
a1207 1
		    "\n\tTLS version=%s cipher=%s bits=%d verify=%s",
@


1.272
log
@start work on improving the log format, this is work in progress but it'll
be better worked in tree

ok eric@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.271 2016/05/16 19:25:05 gilles Exp $	*/
d1261 1
a1261 1
		log_info("%016"PRIx64" smtp event=starttls ciphers=%s",
d1286 1
a1286 1
			    "event=client-cert-check result=%s",
d1405 1
a1405 1
		log_info("%016"PRIx64" smtp event=closed reason=io-error: %s",
d2186 1
a2186 1
			    "event=bad-input result=%.*s",
d2204 1
a2204 1
			    "event=failed-command command=%s result=%.*s",
@


1.271
log
@fix logic in error code path of smtp state machine that can lead to an
invalid state ending in fatal(), while at it plug a file pointer leak.

ok eric@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.270 2016/05/08 20:24:01 millert Exp $	*/
d911 3
a913 3
			log_info("smtp-in: Accepted message %08x "
			    "on session %016"PRIx64
			    ": from=<%s%s%s>, to=<%s%s%s>, size=%zu, ndest=%zu, proto=%s",
a914 1
			    s->id,
d942 3
a944 2
			log_info("smtp-in: Accepted authentication for user %s "
			    "on session %016"PRIx64, user, s->id);
d950 3
a952 2
			log_info("smtp-in: Authentication failed for user %s "
			    "on session %016"PRIx64, user, s->id);
d957 3
a959 2
			log_info("smtp-in: Authentication temporarily failed "
			    "for user %s on session %016"PRIx64, user, s->id);
d975 2
a976 2
			log_info("smtp-in: Disconnecting session %016" PRIx64
			    ": CA failure", s->id);
d1001 3
a1003 2
			log_info("smtp-in: Disconnecting session %016" PRIx64
			    ": SSL certificate check failed", s->id);
d1039 3
a1041 2
			log_info("smtp-in: Disconnecting session %016" PRIx64
			    ": rejected by filter", s->id);
d1261 1
a1261 1
		log_info("smtp-in: Started TLS on session %016"PRIx64": %s",
d1273 3
a1275 2
			log_info("smtp-in: Disconnecting session %016" PRIx64
			    ": client did not present certificate", s->id);
d1285 4
a1288 4
			log_info("smtp-in: Client certificate verification %s "
			    "on session %016"PRIx64,
			    (s->flags & SF_VERIFIED) ? "succeeded" : "failed",
			    s->id);
d1363 2
a1364 1
			log_info("smtp-in: Closing session %016" PRIx64, s->id);
d1393 2
a1394 2
		log_info("smtp-in: Disconnecting session %016"PRIx64": "
		    "session timeout", s->id);
d1399 1
a1399 1
		log_info("smtp-in: Received disconnect from session %016"PRIx64,
d1405 2
a1406 2
		log_info("smtp-in: Disconnecting session %016"PRIx64": "
		    "IO error: %s", s->id, io->error);
d2050 2
a2051 2
	log_info("smtp-in: New session %016"PRIx64" from host %s [%s]",
	    s->id, s->hostname, ss_to_text(&s->ss));
d2185 3
a2187 2
			log_info("smtp-in: Bad input on session %016"PRIx64
			    ": %.*s", s->id, n, buf);
d2203 3
a2205 2
			log_info("smtp-in: Failed command on session %016"PRIx64
			    ": \"%s\" => %.*s", s->id, tmp, n, buf);
@


1.270
log
@The "loop detected" message should not print the errno string.
OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.269 2016/03/25 15:06:58 krw Exp $	*/
d1147 1
d1453 2
@


1.269
log
@Nuke session_socket_blockmode() and session_socket_linger(). Use
the identical io_set_blocking() and io_set_linger().

Since both are always called to turn off blocking or lingering,
nuke the parameter and associated enum in favour of "just doing the
right thing".

While passing remove the unneeded last parameter to the remaining
fcntl(F_GETFL).

Finally, rename the functions to io_set_nonblocking() and
io_set_nolinger() for clarity.

No functional change.

Started with a sweep of fcntl() usage inspired by guenther@@.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.268 2016/02/05 19:15:15 jung Exp $	*/
d2582 1
a2582 1
			log_warn("warn: loop detected");
@


1.268
log
@use SMTPD_NAME define

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.267 2016/02/04 20:27:33 eric Exp $	*/
d1181 1
a1181 1
	io_set_blocking(fd, 0);
@


1.268.2.1
log
@fix logic in error code path of smtp state machine that can lead to invalid
state and result in fatal(), while at it plug file pointer leak.

errata 006

ok eric@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.268 2016/02/05 19:15:15 jung Exp $	*/
a1146 1
			tree_pop(&wait_filter_data, s->id);
a1451 2

		tree_pop(&wait_filter_data, s->id);
@


1.268.2.2
log
@"A logic issue in smtpd's header parsing can cause SMTP sessions to hang."
errata 031
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.268.2.1 2016/05/16 19:29:13 gilles Exp $	*/
a1345 2
			else
				io_reload(&s->oev);
@


1.267
log
@Make code more readable by putting the message parsing logic in a single place.

ok gilles@@ sunil@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.266 2016/02/03 13:38:40 eric Exp $	*/
d1775 1
a1775 1
		smtp_reply(s, "214- This is OpenSMTPD");
@


1.266
log
@Add helpers function to talk to the queue. Make the code simpler.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.265 2016/02/03 11:16:19 eric Exp $	*/
a1317 19

			if (line[0] == '.') {
				line += 1;
				len -= 1;
			}

			if (isspace((unsigned char)line[0]) && s->skiphdr)
                                goto nextline;
                        s->skiphdr = 0;

                        /* BCC should be stripped from headers */
                        if (!s->hdrdone) {
                                if (strncasecmp("bcc:", line, 4) == 0) {
                                        s->skiphdr = 1;
                                        goto nextline;
                                }
                        }

			log_trace(TRACE_SMTP, "<<< [MSG] %s", line);
d2547 2
d2553 3
a2555 2
	if (*line == '\0')
		s->hdrdone = 1;
a2563 1
	/* check for loops */
d2565 13
d2585 3
@


1.265
log
@tell filters to rollback the current transaction if MAIL or EOM fails

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.264 2015/12/28 22:08:30 jung Exp $	*/
d190 5
d747 1
a747 4
			m_create(p_queue, IMSG_SMTP_MESSAGE_CREATE, 0, 0, -1);
			m_add_id(p_queue, s->id);
			m_close(p_queue);
			tree_xset(&wait_queue_msg, s->id, s);
d1114 2
a1115 6
		else {
			m_create(p_queue, IMSG_SMTP_MESSAGE_CREATE, 0, 0, -1);
			m_add_id(p_queue, s->id);
			m_close(p_queue);
			tree_xset(&wait_queue_msg, s->id, s);
		}
d1142 1
a1142 5
		m_create(p_queue, IMSG_SMTP_MESSAGE_OPEN, 0, 0, -1);
		m_add_id(p_queue, s->id);
		m_add_msgid(p_queue, evpid_to_msgid(s->evp.id));
		m_close(p_queue);
		tree_xset(&wait_queue_fd, s->id, s);
d1473 1
a1474 3
		m_create(p_queue, IMSG_SMTP_MESSAGE_ROLLBACK, 0, 0, -1);
		m_add_msgid(p_queue, evpid_to_msgid(s->evp.id));
		m_close(p_queue);
d1752 2
a1753 5
		if (s->evp.id) {
			m_create(p_queue, IMSG_SMTP_MESSAGE_ROLLBACK, 0, 0, -1);
			m_add_msgid(p_queue, evpid_to_msgid(s->evp.id));
			m_close(p_queue);
		}
d2100 1
a2100 3
		m_create(p_queue, IMSG_SMTP_MESSAGE_ROLLBACK, 0, 0, -1);
		m_add_msgid(p_queue, evpid_to_msgid(s->evp.id));
		m_close(p_queue);
d2112 1
a2112 5
	m_create(p_queue, IMSG_SMTP_MESSAGE_COMMIT, 0, 0, -1);
	m_add_id(p_queue, s->id);
	m_add_msgid(p_queue, evpid_to_msgid(s->evp.id));
	m_close(p_queue);
	tree_xset(&wait_queue_commit, s->id, s);
d2229 1
a2229 3
		m_create(p_queue, IMSG_SMTP_MESSAGE_ROLLBACK, 0, 0, -1);
		m_add_msgid(p_queue, evpid_to_msgid(s->evp.id));
		m_close(p_queue);
d2451 37
@


1.264
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.263 2015/12/14 10:22:12 jung Exp $	*/
d1094 1
d1153 1
@


1.263
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.262 2015/12/13 10:54:11 gilles Exp $	*/
d1189 1
a1189 1
	if (! (s->listener->flags & F_MASK_SOURCE)) {
d1333 1
a1333 1
                        if (! s->hdrdone) {
@


1.262
log
@refactor smtp_session to plug into the filters infrastructure
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.209 2014/04/29 12:18:27 reyk Exp $	*/
d1956 1
a1956 1
		
@


1.261
log
@remove prototype to now unused function + pass fallback hint to lka
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.260 2015/12/13 09:52:44 gilles Exp $	*/
a144 2
	size_t			 datalen;
	FILE			*ofile;
a169 2
static void smtp_mfa_response(struct smtp_session *, int, int, uint32_t,
    const char *);
d171 2
a179 1
static void smtp_message_write(struct smtp_session *, const char *);
a223 1
static struct tree wait_mfa_data;
a612 1
		tree_init(&wait_mfa_data);
d647 1
a715 1
	X509				*x;
d825 1
a825 2
		if (!success || imsg->fd == -1 ||
		    (s->ofile = fdopen(imsg->fd, "w")) == NULL) {
d835 1
a835 40
		smtp_message_printf(s, "Received: ");
		if (! (s->listener->flags & F_MASK_SOURCE)) {
			smtp_message_printf(s, "from %s (%s [%s])",
			    s->evp.helo,
			    s->hostname,
			    ss_to_text(&s->ss));
		}
		smtp_message_printf(s, "\n\tby %s (%s) with %sSMTP%s%s id %08x",
		    s->smtpname,
		    SMTPD_NAME,
		    s->flags & SF_EHLO ? "E" : "",
		    s->flags & SF_SECURE ? "S" : "",
		    s->flags & SF_AUTHENTICATED ? "A" : "",
		    evpid_to_msgid(s->evp.id));

		if (s->flags & SF_SECURE) {
			x = SSL_get_peer_certificate(s->io.ssl);
			smtp_message_printf(s,
			    "\n\tTLS version=%s cipher=%s bits=%d verify=%s",
			    SSL_get_version(s->io.ssl),
			    SSL_get_cipher_name(s->io.ssl),
			    SSL_get_cipher_bits(s->io.ssl, NULL),
			    (s->flags & SF_VERIFIED) ? "YES" : (x ? "FAIL" : "NO"));
			if (x)
				X509_free(x);

			if (s->listener->flags & F_RECEIVEDAUTH) {
				smtp_message_printf(s,
				    " auth=%s", s->username[0] ? "yes" : "no");
				if (s->username[0])
					smtp_message_printf(s,
					    " user=%s", s->username);
			}
		}

		if (s->rcptcount == 1) {
			smtp_message_printf(s, "\n\tfor <%s@@%s>",
			    s->evp.rcpt.user,
			    s->evp.rcpt.domain);
		}
d837 2
a838 16
		smtp_message_printf(s, ";\n\t%s\n", time_to_text(time(NULL)));

		if (s->msgflags & MF_ERROR) {
			smtp_reply(s, "421 %s: Temporary Error",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
			smtp_enter_state(s, STATE_QUIT);
			io_reload(&s->io);
			return;
		}

		smtp_enter_state(s, STATE_BODY);
		smtp_reply(s, "354 Enter mail, end with \".\""
		    " on a line by itself");

		tree_xset(&wait_mfa_data, s->id, s);
		io_reload(&s->io);
d920 1
a920 1
			    s->datalen,
d1012 2
a1013 2
static void
smtp_mfa_response(struct smtp_session *s, int msg, int status, uint32_t code,
d1016 4
a1019 1
	struct ca_cert_req_msg		 req_ca_cert;
d1030 1
a1030 1
	switch (msg) {
d1032 1
a1032 1
	case IMSG_SMTP_REQ_CONNECT:
d1060 1
a1060 1
	case IMSG_SMTP_REQ_HELO:
d1092 1
a1092 1
	case IMSG_SMTP_REQ_MAIL:
d1119 1
a1119 1
	case IMSG_SMTP_REQ_RCPT:
d1135 1
a1135 1
	case IMSG_SMTP_REQ_DATA:
d1150 1
a1150 1
	case IMSG_SMTP_REQ_EOM:
d1162 63
a1224 1
		fatal("bad mfa_imsg");
d1226 17
d1328 14
a1341 1
			smtp_message_write(s, line);
d1358 2
d1365 3
a1367 1
			smtp_filter_eom(s);
d1432 75
d1578 1
a1578 1
		s->flags &= SF_SECURE | SF_AUTHENTICATED | SF_VERIFIED;
a2099 43
smtp_message_write(struct smtp_session *s, const char *line)
{
	int	ret;

	log_trace(TRACE_SMTP, "<<< [MSG] %s", line);

	/* Don't waste resources on message if it's going to bin anyway. */
	if (s->msgflags & MF_ERROR)
		return;

	if (*line == '\0')
		s->hdrdone = 1;

	/* account for newline */
	s->datain += strlen(line) + 1;
	if (s->datain > env->sc_maxsize) {
		s->msgflags |= MF_ERROR_SIZE;
		return;
	}

	/* check for loops */
	if (!s->hdrdone) {
		if (strncasecmp("Received: ", line, 10) == 0)
			s->rcvcount++;
		if (s->rcvcount == MAX_HOPS_COUNT) {
			s->msgflags |= MF_ERROR_LOOP;
			log_warnx("warn: loop detected");
			return;
		}
	}

	ret = rfc2822_parser_feed(&s->rfc2822_parser, line);
	if (ret == -1) {
		s->msgflags |= MF_ERROR_RESOURCES;
		return;
	}
	if (ret == 0) {
		s->msgflags |= MF_ERROR_MALFORMED;
		return;
	}
}

static void
d2104 1
a2104 1
	tree_xpop(&wait_mfa_data, s->id);
a2107 3
	fclose(s->ofile);
	s->ofile = NULL;

a2115 11
		else if (s->msgflags & MF_ERROR_LOOP)
			smtp_reply(s, "500 %s %s: Loop detected",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_ROUTING_LOOP_DETECTED),
			    esc_description(ESC_ROUTING_LOOP_DETECTED));
		else if (s->msgflags & MF_ERROR_RESOURCES)
			smtp_reply(s, "421 %s: Temporary Error",
			    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));
		else if (s->msgflags & MF_ERROR_MALFORMED)
			smtp_reply(s, "550 %s %s: Message is not RFC 2822 compliant",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_DELIVERY_NOT_AUTHORIZED_MESSAGE_REFUSED),
			    esc_description(ESC_DELIVERY_NOT_AUTHORIZED_MESSAGE_REFUSED));
d2145 2
a2146 1
	s->datalen = 0;
d2174 1
a2174 1
	len = vfprintf(s->ofile, fmt, ap);
d2182 1
a2182 1
		s->datalen += len;
d2241 1
a2241 4
	tree_pop(&wait_mfa_data, s->id);

	if (s->ofile)
		fclose(s->ofile);
d2247 2
d2473 1
d2479 1
d2485 1
d2491 1
d2497 7
a2503 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_CONNECT, FILTER_OK, 0, NULL);
d2509 2
a2510 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_EOM, FILTER_OK, 0, NULL);
d2516 2
a2517 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_HELO, FILTER_OK, 0, NULL);
d2523 2
a2524 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_MAIL, FILTER_OK, 0, NULL);
d2530 2
a2531 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_RCPT, FILTER_OK, 0, NULL);
d2537 2
a2538 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_DATA, FILTER_OK, 0, NULL);
d2544 43
@


1.260
log
@refactor a bit to move the SNI handling away from smtp_session into smtp

ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.259 2015/12/12 20:02:31 gilles Exp $	*/
a191 1
static const char *smtp_sni_get_servername(struct smtp_session *);
d1348 2
a1349 1
			if (s->listener->pki_name[0])
d1352 3
a1354 1
			else
d1357 2
@


1.259
log
@remove CA from pki and no longer allow specifying a CA with 'pki' keyword.
introduce 'ca' keyword to allow specifying a custom CA.
making CA part of pki was a bad idea and several people hit use-cases that
plain couldn't work.

instead of:
    pki foobar.org ca "/etc/mail/CA.pem"

use now:
    ca foobar.org certificate "/etc/mail/CA.pem"


ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.258 2015/12/12 18:49:38 gilles Exp $	*/
a121 1
	char			 sni[HOST_NAME_MAX+1];
a191 1
static int smtp_sni_callback(SSL *, int *, void *);
d1041 1
a1041 2
		ssl = ssl_smtp_init(ssl_ctx, smtp_sni_callback,
		    s->listener->flags & F_TLS_VERIFY);
a1227 1
	const char	       *sn;
a1243 8
		sn = smtp_sni_get_servername(s);
		if (sn) {
			if (strlcpy(s->sni, sn, sizeof s->sni) >= sizeof s->sni) {
				smtp_free(s, "client SNI exceeds max hostname length");
				return;
			}
		}

a2405 22
}

static const char *
smtp_sni_get_servername(struct smtp_session *s)
{
	return SSL_get_servername(s->io.ssl, TLSEXT_NAMETYPE_host_name);
}

static int
smtp_sni_callback(SSL *ssl, int *ad, void *arg)
{
	const char		*sn;
	void			*ssl_ctx;

	sn = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
	if (sn == NULL)
		return SSL_TLSEXT_ERR_NOACK;
	ssl_ctx = dict_get(env->sc_ssl_dict, sn);
	if (ssl_ctx == NULL)
		return SSL_TLSEXT_ERR_NOACK;
	SSL_set_SSL_CTX(ssl, ssl_ctx);
	return SSL_TLSEXT_ERR_OK;
@


1.258
log
@when using senders map to restrict email address a user may use in SMTP
dialogue, if `masquerade' is used as a parameter then rewrite the email
address of the DATA From header to the email address in the map.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.257 2015/12/12 18:42:58 gilles Exp $	*/
a716 1
	char				*pkiname;
d1042 1
a1042 6
		if (s->listener->pki_name[0])
			pkiname = s->listener->pki_name;
		else
			pkiname = s->smtpname;
		ssl_ctx = dict_get(env->sc_ssl_dict, pkiname);

d2283 1
a2283 1
	const char	       *pkiname;
d2292 11
a2302 5
	if (s->listener->pki_name[0])
		pkiname = s->listener->pki_name;
	else
		pkiname = s->smtpname;
	if (strlcpy(req_ca_vrfy.name, pkiname, sizeof req_ca_vrfy.name)
@


1.257
log
@add the plumbing for masquerading

ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.256 2015/12/12 14:33:35 gilles Exp $	*/
d755 5
@


1.256
log
@rename enum value
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.255 2015/12/12 14:27:03 gilles Exp $	*/
d425 166
@


1.255
log
@remove whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.254 2015/12/12 14:15:53 gilles Exp $	*/
a76 1
	SF_MFACONNSENT		= 0x0040,
d1806 1
a1806 1
	s->flags |= SF_MFACONNSENT;
d2036 1
a2036 1
	if (s->flags & SF_MFACONNSENT)
@


1.254
log
@do not limit smtp session username to LOGIN_NAME_MAX it could be a virtual
username
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.253 2015/12/12 14:01:56 gilles Exp $	*/
d898 1
a898 1
			smtp_free(s, "SSL certificate check failed");	
d1100 1
a1100 1
			smtp_free(s, "client did not present certificate");	
a1863 1
		
d2153 1
a2153 1
		log_warnx("warn: failed to encode certificate");	
d2158 1
a2158 1
		log_warnx("warn: certificate too long");	
d2166 1
a2166 1
			log_warnx("warn: certificate chain too long");	
d2177 1
a2177 1
			log_warnx("warn: failed to encode certificate");	
d2182 1
a2182 1
			log_warnx("warn: certificate too long");	
@


1.253
log
@remove redundant check
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.252 2015/12/12 11:31:29 sunil Exp $	*/
d131 1
a131 1
	char			 username[LOGIN_NAME_MAX];
@


1.252
log
@Implement senders map.

senders table allows to restrict the addresses that an authenticated
user can use in the SMTP dialogue.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.251 2015/12/12 10:35:52 gilles Exp $	*/
a870 2
		if (resp_ca_cert == NULL)
			fatal(NULL);
@


1.251
log
@add a log_trace() for debugging purposes
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.250 2015/12/12 10:33:21 gilles Exp $	*/
d578 26
d999 16
a1014 4
		m_create(p_queue, IMSG_SMTP_MESSAGE_CREATE, 0, 0, -1);
		m_add_id(p_queue, s->id);
		m_close(p_queue);
		tree_xset(&wait_queue_msg, s->id, s);
@


1.250
log
@prepare struct smtp_session for handling of filters
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.249 2015/12/12 10:31:01 gilles Exp $	*/
d495 4
@


1.249
log
@add watermark define which will be needed for filters
add two session flags which will be needed for filters
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.248 2015/12/12 10:27:18 gilles Exp $	*/
d144 3
d151 1
d153 1
@


1.248
log
@if ca name not specified, pass hint to lka that a wildcard can match
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.247 2015/12/12 10:24:27 gilles Exp $	*/
d48 1
d79 2
@


1.247
log
@declare and init filter wait queues (unused yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.246 2015/12/12 10:22:39 gilles Exp $	*/
d902 1
a902 1
			if (s->listener->pki_name[0])
d905 3
a907 1
			else
d910 2
@


1.246
log
@add filter_dataline prototype + empty function
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.245 2015/12/12 09:59:04 gilles Exp $	*/
d221 2
a222 2
static struct tree wait_lka_filter;
static struct tree wait_lka_filter_data;
d445 2
a446 2
		tree_init(&wait_lka_filter);
		tree_init(&wait_lka_filter_data);
@


1.245
log
@fix prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.244 2015/12/11 21:44:01 gilles Exp $	*/
d199 1
d219 1
d221 2
d443 1
d445 2
d2275 5
@


1.244
log
@rename field member + whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.243 2015/12/11 21:23:42 gilles Exp $	*/
d196 3
a198 3
static void smtp_filter_mail(struct smtp_session *s);
static void smtp_filter_rcpt(struct smtp_session *s);
static void smtp_filter_data(struct smtp_session *s);
@


1.243
log
@rename header_masquerade_callback() to header_domain_append_callback(), the
name was confusing on what this function really does
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.242 2015/12/03 21:11:33 jung Exp $	*/
d2074 2
a2075 2
	if (strlcpy(req_ca_vrfy.pkiname, pkiname, sizeof req_ca_vrfy.pkiname)
	    >= sizeof req_ca_vrfy.pkiname)
@


1.242
log
@introduce limit session keyword replacing fixed values

original diff from Renaud Allard

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.241 2015/12/01 18:22:30 gilles Exp $	*/
d337 1
a337 1
header_masquerade_callback(const struct rfc2822_header *hdr, void *arg)
d488 1
a488 1
	    header_masquerade_callback, s);
d490 1
a490 1
	    header_masquerade_callback, s);
d492 1
a492 1
	    header_masquerade_callback, s);
@


1.241
log
@add received-auth parameter to listener to identify authenticated sessions
in locally appended Received header when enabled

ok millert@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.240 2015/11/30 12:49:35 gilles Exp $	*/
a47 3
#define SMTP_LIMIT_MAIL		100
#define SMTP_LIMIT_RCPT		1000

d1366 1
a1366 1
		if (s->mailcount >= SMTP_LIMIT_MAIL) {
d1398 1
a1398 1
		if (s->rcptcount >= SMTP_LIMIT_RCPT) {
@


1.240
log
@mechanical rename of some IMSG constants

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.239 2015/11/05 08:55:09 gilles Exp $	*/
d658 8
@


1.239
log
@when a message consists solely of headers and does not end them with an
empty line, the message parser gets confused, and forgets to flush last
header to message file.

detect if we're still in headers when hitting EOM, and flush if that is
the case.

reported by Philipp Takacs <philipp@@bureaucracy.de>

ok millert@@, jung@@, sunil@@, eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.238 2015/10/21 16:44:28 jsing Exp $	*/
d809 1
a809 1
	case IMSG_SMTP_SSL_INIT:
d841 1
a841 1
	case IMSG_SMTP_SSL_VERIFY:
d896 1
a896 1
			m_compose(p_lka, IMSG_SMTP_SSL_INIT, 0, 0, -1,
d1139 1
a1139 1
			m_compose(p_lka, IMSG_SMTP_SSL_INIT, 0, 0, -1,
d2134 1
a2134 1
	m_composev(p_lka, IMSG_SMTP_SSL_VERIFY_CERT, 0, 0, -1,
d2145 1
a2145 1
		m_composev(p_lka, IMSG_SMTP_SSL_VERIFY_CHAIN, 0, 0, -1,
d2152 1
a2152 1
	m_compose(p_lka, IMSG_SMTP_SSL_VERIFY, 0, 0, -1,
@


1.238
log
@Only enable SSL_VERIFY_PEER when the verify option is set on a listener.

Always enabling SSL_VERIFY_PEER unnecessarily increases the number of
messages/bytes in the TLS handshake and increases our attack surface,
since we request and then process client certificates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.237 2015/10/16 21:13:33 sthen Exp $	*/
d1107 2
@


1.237
log
@Use SSL_get_version() not SSL_get_cipher_version(); the former gives the TLS
version used for the connection, the latter gives "the SSL/TLS protocol version
that first defined the cipher". Fixes "TLS version=TLSv1/SSLv3" in received/log
lines.

ok millert@@ "I was going to commit this today, so yes definitely" ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.236 2015/10/13 11:32:47 eric Exp $	*/
d831 2
a832 1
		ssl = ssl_smtp_init(ssl_ctx, smtp_sni_callback);
@


1.236
log
@Add a helper for writing the message to simplify the code.
It also fixes the reported message length by taking prepended
headers into account and adds missing error checks there.

ok millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.235 2015/10/12 20:16:31 gilles Exp $	*/
d652 1
a652 1
			    SSL_get_cipher_version(s->io.ssl),
@


1.235
log
@add Date header when a session iniated locally doesn't add one

ok millert@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.234 2015/10/02 00:44:30 gilles Exp $	*/
d182 1
a234 1
	size_t			len;
d236 1
a236 3
	len = strlen(hdr->name) + 1;
	if (fprintf(s->ofile, "%s:", hdr->name) != (int)len) {
		s->msgflags |= MF_ERROR_IO;
a237 2
	}
	s->datalen += len;
d239 2
a240 4
	TAILQ_FOREACH(l, &hdr->lines, next) {
		len = strlen(l->buffer) + 1;
		if (fprintf(s->ofile, "%s\n", l->buffer) != (int)len) {
			s->msgflags |= MF_ERROR_IO;
a241 3
		}
		s->datalen += len;
	}
a247 3
	size_t			len;

	len = strlen(line) + 1;
d249 1
a249 6
	if (fprintf(s->ofile, "%s\n", line) != (int)len) {
		s->msgflags |= MF_ERROR_IO;
		return;
	}

	s->datalen += len;
a345 1
	size_t			len;
d348 2
a349 4
	len = strlen(hdr->name) + 1;
	if (fprintf(s->ofile, "%s:", hdr->name) != (int)len)
		goto ioerror;
	s->datalen += len;
d372 2
a373 4
				len = strlen(buffer) + 1;
				if (fprintf(s->ofile, "%s,", buffer) != (int)len)
					goto ioerror;
				s->datalen += len;
d380 3
a382 3
					if (fprintf(s->ofile, "%c", l->buffer[i]) != (int)1)
						goto ioerror;
					s->datalen += 1;
d387 3
a389 4
						len = strlen(buffer);
						if (fprintf(s->ofile, "%s", buffer) != (int)len)
							goto ioerror;
						s->datalen += len;
d398 2
a399 3
			if (fprintf(s->ofile, "\n") != (int)1)
				goto ioerror;
			s->datalen += 1;
d404 2
a405 4
				len = strlen(buffer);
				if (fprintf(s->ofile, "%s", buffer) != (int)len)
					goto ioerror;
				s->datalen += len;
d417 1
a417 4
		len = strlen(buffer);
		if (fprintf(s->ofile, "%s", buffer) != (int)len)
			goto ioerror;
		s->datalen += len;
a418 5
	return;

ioerror:
	s->msgflags |= MF_ERROR_IO;
	return;
a424 1
	int			 len;
d426 2
a427 2
	if (strcasecmp(header, "message-id") == 0) {
		len = fprintf(s->ofile, "Message-Id: <%016"PRIx64"@@%s>\n",
a428 6
		if (len == -1) {
			s->msgflags |= MF_ERROR_IO;
			return;
		}
		s->datalen += len;
	}
d430 2
a431 8
	if (strcasecmp(header, "date") == 0) {
		len = fprintf(s->ofile, "Date: %s\n", time_to_text(time(NULL)));
		if (len == -1) {
			s->msgflags |= MF_ERROR_IO;
			return;
		}
		s->datalen += len;
	}
d633 1
a633 1
		fprintf(s->ofile, "Received: ");
d635 1
a635 1
			fprintf(s->ofile, "from %s (%s [%s])",
d640 1
a640 1
		fprintf(s->ofile, "\n\tby %s (%s) with %sSMTP%s%s id %08x",
d650 1
a650 1
			fprintf(s->ofile,
d661 1
a661 1
			fprintf(s->ofile, "\n\tfor <%s@@%s>",
d666 9
a674 1
		fprintf(s->ofile, ";\n\t%s\n", time_to_text(time(NULL)));
d1881 23
@


1.234
log
@detect that a certificate chain will not fit in imsg calls before passing
part of it and failing others, this may leave the lookup process in a weird
state and cause use-after-free and out-of-bounds memory reads, leading to
crashes or potential arbitrary code execution in unprivileged process.

reported by Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.233 2015/09/07 15:36:53 gilles Exp $	*/
d470 9
d547 2
@


1.233
log
@when bypassing the enqueuer, insert Message-Id header if none was found and
the client has connected from a loopback interface.

ok millert@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.232 2015/09/03 05:10:19 gilles Exp $	*/
d143 1
a260 5
	if (s->datalen + len > env->sc_maxsize) {
		s->msgflags |= MF_ERROR_SIZE;
		return;
	}

d1803 7
d1892 1
d2052 2
a2057 1
	int			i;
d2059 15
d2088 2
a2089 1
	tree_xset(&wait_ssl_verify, s->id, s);
d2091 18
a2108 4
	/* Send the client certificate */
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	if (s->listener->pki_name[0])
		pkiname = s->listener->pki_name;
d2110 15
a2124 1
		pkiname = s->smtpname;
d2126 1
a2126 3
	if (strlcpy(req_ca_vrfy.pkiname, pkiname, sizeof req_ca_vrfy.pkiname)
	    >= sizeof req_ca_vrfy.pkiname)
		return 0;
d2128 1
d2130 2
a2131 3
	req_ca_vrfy.cert_len = i2d_X509(x, &req_ca_vrfy.cert);
	if (xchain)
		req_ca_vrfy.n_chain = sk_X509_num(xchain);
d2134 2
a2135 2
	iov[1].iov_base = req_ca_vrfy.cert;
	iov[1].iov_len = req_ca_vrfy.cert_len;
a2137 2
	free(req_ca_vrfy.cert);
	X509_free(x);
d2139 10
a2148 15
	if (xchain) {		
		/* Send the chain, one cert at a time */
		for (i = 0; i < sk_X509_num(xchain); ++i) {
			memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
			req_ca_vrfy.reqid = s->id;
			x = sk_X509_value(xchain, i);
			req_ca_vrfy.cert_len = i2d_X509(x, &req_ca_vrfy.cert);
			iov[0].iov_base = &req_ca_vrfy;
			iov[0].iov_len  = sizeof(req_ca_vrfy);
			iov[1].iov_base = req_ca_vrfy.cert;
			iov[1].iov_len  = req_ca_vrfy.cert_len;
			m_composev(p_lka, IMSG_SMTP_SSL_VERIFY_CHAIN, 0, 0, -1,
			    iov, nitems(iov));
			free(req_ca_vrfy.cert);
		}
d2157 7
a2163 1
	return 1;
@


1.232
log
@the session kicking mechanism has an accounting bug leading to some legit
sessions being kicked if they generate too many consecutive errors.
remove the mechanism altogether until it is redesigned.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.231 2015/08/15 17:27:43 gilles Exp $	*/
d460 17
d540 5
@


1.231
log
@assume messages use 8bit bytes by default, not just when 8BITMIME extension
is used, this is what the world expects, this is what other MTA do.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.230 2015/05/15 07:34:45 gilles Exp $	*/
a50 3
#define SMTP_KICK_CMD		5
#define SMTP_KICK_RCPTFAIL	50

d78 3
a80 4
	SF_KICK			= 0x0020,
	SF_VERIFIED		= 0x0040,
	SF_MFACONNSENT		= 0x0080,
	SF_BADINPUT		= 0x0100,
a134 1
	size_t			 kickcount;
a140 1
	size_t			 rcptfail;
a591 6
			s->rcptfail += 1;
			if (s->rcptfail >= SMTP_KICK_RCPTFAIL) {
				log_info("smtp-in: Ending session %016"PRIx64
				    ": too many failed RCPT", s->id);
				smtp_enter_state(s, STATE_QUIT);
			}
a733 1
			s->kickcount--;
a778 1
		s->kickcount = 0;
a795 1
			s->kickcount = 0;
a940 1
		s->kickcount = 0;
a964 7

			s->rcptfail += 1;
			if (s->rcptfail >= SMTP_KICK_RCPTFAIL) {
				log_info("smtp-in: Ending session %016" PRIx64
				    ": too many failed RCPT", s->id);
				smtp_enter_state(s, STATE_QUIT);
			}
a1026 1
		s->kickcount = 0;
a1127 2
		if (s->flags & SF_KICK)
			smtp_free(s, "kick");
a1184 8

	if (++s->kickcount >= SMTP_KICK_CMD) {
		log_info("smtp-in: Disconnecting session %016" PRIx64
		    ": session not moving forward", s->id);
		s->flags |= SF_KICK;
		stat_increment("smtp.kick", 1);
		return;
	}
@


1.230
log
@the code to prevent AUTH PLAIN from logging credentials upon authentication
failure does not catch the AUTH LOGIN case. rework to use the session state
rather than using the session command.

spotted by pkern@@debian.org
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.229 2015/04/19 20:29:12 gilles Exp $	*/
d1037 1
a1037 1
	size_t			len, i;
a1121 5

			if (!(s->flags & SF_8BITMIME))
				for (i = 0; i < len; ++i)
					if (line[i] & 0x80)
						line[i] = line[i] & 0x7f;
@


1.230.4.1
log
@Errata 004:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.230 2015/05/15 07:34:45 gilles Exp $	*/
a148 1
	size_t			 datain;
d266 5
a1823 7
	/* account for newline */
	s->datain += strlen(line) + 1;
	if (s->datain > env->sc_maxsize) {
		s->msgflags |= MF_ERROR_SIZE;
		return;
	}

a1905 1
	s->datain = 0;
a2064 2
#define MAX_CERTS	16
#define MAX_CERT_LEN	(MAX_IMSGSIZE - (IMSG_HEADER_SIZE + sizeof(req_ca_vrfy)))
d2069 1
a2070 15
	unsigned char	       *cert_der[MAX_CERTS];
	int			cert_len[MAX_CERTS];
	int			i, cert_count, res;

	res = 0;
	memset(cert_der, 0, sizeof(cert_der));
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);

	if (s->listener->pki_name[0])
		pkiname = s->listener->pki_name;
	else
		pkiname = s->smtpname;
	if (strlcpy(req_ca_vrfy.pkiname, pkiname, sizeof req_ca_vrfy.pkiname)
	    >= sizeof req_ca_vrfy.pkiname)
		return 0;
d2085 1
a2085 2
	cert_len[0] = i2d_X509(x, &cert_der[0]);
	X509_free(x);
d2087 4
a2090 18
	if (cert_len[0] < 0) {
		log_warnx("warn: failed to encode certificate");	
		goto end;
	}
	log_debug("debug: certificate 0: len=%d", cert_len[0]);
	if (cert_len[0] > (int)MAX_CERT_LEN) {
		log_warnx("warn: certificate too long");	
		goto end;
	}

	if (xchain) {
		cert_count = sk_X509_num(xchain);
		log_debug("debug: certificate chain len: %d", cert_count);
		if (cert_count >= MAX_CERTS) {
			log_warnx("warn: certificate chain too long");	
			goto end;
		}
	}
d2092 1
a2092 1
		cert_count = 0;
d2094 3
a2096 13
	for (i = 0; i < cert_count; ++i) {
		x = sk_X509_value(xchain, i);
		cert_len[i+1] = i2d_X509(x, &cert_der[i+1]);
		if (cert_len[i+1] < 0) {
			log_warnx("warn: failed to encode certificate");	
			goto end;
		}
		log_debug("debug: certificate %i: len=%d", i+1, cert_len[i+1]);
		if (cert_len[i+1] > (int)MAX_CERT_LEN) {
			log_warnx("warn: certificate too long");	
			goto end;
		}
	}
a2097 3
	tree_xset(&wait_ssl_verify, s->id, s);

	/* Send the client certificate */
d2099 3
a2101 2
	req_ca_vrfy.cert_len = cert_len[0];
	req_ca_vrfy.n_chain = cert_count;
d2104 2
a2105 2
	iov[1].iov_base = cert_der[0];
	iov[1].iov_len = cert_len[0];
d2108 2
d2111 15
a2125 10
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	req_ca_vrfy.reqid = s->id;

	/* Send the chain, one cert at a time */
	for (i = 0; i < cert_count; ++i) {
		req_ca_vrfy.cert_len = cert_len[i+1];
		iov[1].iov_base = cert_der[i+1];
		iov[1].iov_len  = cert_len[i+1];
		m_composev(p_lka, IMSG_SMTP_SSL_VERIFY_CHAIN, 0, 0, -1,
		    iov, nitems(iov));
d2134 1
a2134 7
	res = 1;

    end:
	for (i = 0; i < MAX_CERTS; ++i)
		free(cert_der[i]);

	return res;
@


1.229
log
@Incorrect logic in smtpd(8) can lead to unexpected client disconnect, invalid
certificate in SNI negotiation or server crash.

spotted by Edwin Torok
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.228 2015/04/06 13:47:00 gilles Exp $	*/
d1950 1
a1950 1
		else if (strstr(s->cmd, "AUTH ") == s->cmd) {
d1952 9
a1960 1
			    ": \"AUTH [...]\" => %.*s", s->id, n, buf);
@


1.228
log
@remove superfluous ';' in Received lines
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.227 2015/01/20 17:37:54 deraadt Exp $	*/
d194 1
d856 1
a856 1
		ssl = ssl_smtp_init(ssl_ctx, smtp_sni_callback, s);
d1035 1
d1053 8
d2152 6
a2161 1
	struct smtp_session	*s = arg;
a2166 4
	if (strlcpy(s->sni, sn, sizeof s->sni) >= sizeof s->sni) {
		log_warnx("warn: client SNI exceeds max hostname length");
		return SSL_TLSEXT_ERR_NOACK;
	}
d2168 1
a2168 3
	if (ssl_ctx == NULL) {
		log_info("smtp-in: No PKI entry for requested SNI \"%s\""
		    "on session %016"PRIx64, sn, s->id);
a2169 1
	}
@


1.227
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.226 2015/01/16 06:40:21 deraadt Exp $	*/
d664 1
a664 1
			fprintf(s->ofile, "from %s (%s [%s]);\n\t",
d669 1
a669 1
		fprintf(s->ofile, "by %s (%s) with %sSMTP%s%s id %08x;\n",
d680 1
a680 1
			    "\tTLS version=%s cipher=%s bits=%d verify=%s;\n",
d690 1
a690 1
			fprintf(s->ofile, "\tfor <%s@@%s>;\n",
d695 1
a695 1
		fprintf(s->ofile, "\t%s\n", time_to_text(time(NULL)));
@


1.227.2.1
log
@Incorrect logic in smtpd(8) can lead to unexpected client disconnect, invalid
certificate in SNI negotiation or server crash.

spotted by Edwin Torok
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.227 2015/01/20 17:37:54 deraadt Exp $	*/
a193 1
static const char *smtp_sni_get_servername(struct smtp_session *);
d855 1
a855 1
		ssl = ssl_smtp_init(ssl_ctx, smtp_sni_callback);
a1033 1
	const char	       *sn;
a1050 8
		sn = smtp_sni_get_servername(s);
		if (sn) {
			if (strlcpy(s->sni, sn, sizeof s->sni) >= sizeof s->sni) {
				smtp_free(s, "client SNI exceeds max hostname length");
				return;
			}
		}

a2141 6
static const char *
smtp_sni_get_servername(struct smtp_session *s)
{
	return SSL_get_servername(s->io.ssl, TLSEXT_NAMETYPE_host_name);
}

d2146 1
d2152 4
d2157 3
a2159 1
	if (ssl_ctx == NULL)
d2161 1
@


1.227.2.2
log
@Errata 017:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.227.2.1 2015/04/19 20:30:33 gilles Exp $	*/
a148 1
	size_t			 datain;
d266 5
a1823 7
	/* account for newline */
	s->datain += strlen(line) + 1;
	if (s->datain > env->sc_maxsize) {
		s->msgflags |= MF_ERROR_SIZE;
		return;
	}

a1905 1
	s->datain = 0;
a2056 2
#define MAX_CERTS	16
#define MAX_CERT_LEN	(MAX_IMSGSIZE - (IMSG_HEADER_SIZE + sizeof(req_ca_vrfy)))
d2061 1
a2062 15
	unsigned char	       *cert_der[MAX_CERTS];
	int			cert_len[MAX_CERTS];
	int			i, cert_count, res;

	res = 0;
	memset(cert_der, 0, sizeof(cert_der));
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);

	if (s->listener->pki_name[0])
		pkiname = s->listener->pki_name;
	else
		pkiname = s->smtpname;
	if (strlcpy(req_ca_vrfy.pkiname, pkiname, sizeof req_ca_vrfy.pkiname)
	    >= sizeof req_ca_vrfy.pkiname)
		return 0;
d2077 1
a2077 2
	cert_len[0] = i2d_X509(x, &cert_der[0]);
	X509_free(x);
d2079 4
a2082 18
	if (cert_len[0] < 0) {
		log_warnx("warn: failed to encode certificate");	
		goto end;
	}
	log_debug("debug: certificate 0: len=%d", cert_len[0]);
	if (cert_len[0] > (int)MAX_CERT_LEN) {
		log_warnx("warn: certificate too long");	
		goto end;
	}

	if (xchain) {
		cert_count = sk_X509_num(xchain);
		log_debug("debug: certificate chain len: %d", cert_count);
		if (cert_count >= MAX_CERTS) {
			log_warnx("warn: certificate chain too long");	
			goto end;
		}
	}
d2084 1
a2084 1
		cert_count = 0;
d2086 3
a2088 13
	for (i = 0; i < cert_count; ++i) {
		x = sk_X509_value(xchain, i);
		cert_len[i+1] = i2d_X509(x, &cert_der[i+1]);
		if (cert_len[i+1] < 0) {
			log_warnx("warn: failed to encode certificate");	
			goto end;
		}
		log_debug("debug: certificate %i: len=%d", i+1, cert_len[i+1]);
		if (cert_len[i+1] > (int)MAX_CERT_LEN) {
			log_warnx("warn: certificate too long");	
			goto end;
		}
	}
a2089 3
	tree_xset(&wait_ssl_verify, s->id, s);

	/* Send the client certificate */
d2091 3
a2093 2
	req_ca_vrfy.cert_len = cert_len[0];
	req_ca_vrfy.n_chain = cert_count;
d2096 2
a2097 2
	iov[1].iov_base = cert_der[0];
	iov[1].iov_len = cert_len[0];
d2100 2
d2103 15
a2117 10
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	req_ca_vrfy.reqid = s->id;

	/* Send the chain, one cert at a time */
	for (i = 0; i < cert_count; ++i) {
		req_ca_vrfy.cert_len = cert_len[i+1];
		iov[1].iov_base = cert_der[i+1];
		iov[1].iov_len  = cert_len[i+1];
		m_composev(p_lka, IMSG_SMTP_SSL_VERIFY_CHAIN, 0, 0, -1,
		    iov, nitems(iov));
d2126 1
a2126 7
	res = 1;

    end:
	for (i = 0; i < MAX_CERTS; ++i)
		free(cert_der[i]);

	return res;
@


1.226
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.225 2015/01/14 08:50:32 gilles Exp $	*/
d125 3
a127 3
	char			 hostname[SMTPD_MAXHOSTNAMELEN];
	char			 smtpname[SMTPD_MAXHOSTNAMELEN];
	char			 sni[SMTPD_MAXHOSTNAMELEN];
d133 3
a135 3
	char			 helo[SMTPD_MAXLINESIZE];
	char			 cmd[SMTPD_MAXLINESIZE];
	char			 username[SMTPD_MAXLOGNAME];
d496 1
a496 1
	if (iobuf_init(&s->iobuf, SMTPD_MAXLINESIZE, SMTPD_MAXLINESIZE) == -1) {
d560 1
a560 1
	char				 user[SMTPD_MAXLOGNAME];
d1089 2
a1090 2
		if ((line == NULL && iobuf_len(&s->iobuf) >= SMTPD_MAXLINESIZE) ||
		    (line && len >= SMTPD_MAXLINESIZE)) {
d1589 1
a1589 1
	char		buf[SMTPD_MAXLINESIZE];
d1919 1
a1919 1
	char	 buf[SMTPD_MAXLINESIZE], tmp[SMTPD_MAXLINESIZE];
d1924 1
a1924 1
	if (n == -1 || n >= SMTPD_MAXLINESIZE)
@


1.225
log
@bring back reverted commits, the crash was unrelated
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.223 2015/01/07 18:28:12 gilles Exp $	*/
d34 1
@


1.224
log
@revert two latest commits until a crash is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.221 2014/12/17 15:49:23 millert Exp $	*/
d318 3
a320 1
		if (! isspace(buffer[i]))
d339 1
a339 1
		while (isspace(buffer[pos_bracket]))
d350 2
a351 1
                if (buffer[pos_component] == '\0' || isspace(buffer[pos_component]))
d513 15
d545 1
a545 13
	rfc2822_parser_init(&s->rfc2822_parser);
	rfc2822_header_default_callback(&s->rfc2822_parser,
	    header_default_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "bcc",
	    header_bcc_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "from",
	    header_masquerade_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "to",
	    header_masquerade_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "cc",
	    header_masquerade_callback, s);
	rfc2822_body_callback(&s->rfc2822_parser,
	    dataline_callback, s);
@


1.223
log
@fix ctype casting bug spotted by Jonas 'Sortie' Termansen
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.222 2015/01/06 10:31:09 gilles Exp $	*/
d318 1
a318 3

		/* update insert point if not in comment and not on a whitespace */
		if (!comment && buffer[i] != ')' && !isspace((unsigned char)buffer[i]))
d337 1
a337 1
		while (isspace((unsigned char)buffer[pos_bracket]))
d348 1
a348 2
                if (buffer[pos_component] == '\0' ||
		    isspace((unsigned char)buffer[pos_component]))
a509 15
	/* Setup parser and callbacks before smtp_connected() can be called */
	rfc2822_parser_init(&s->rfc2822_parser);
	rfc2822_header_default_callback(&s->rfc2822_parser,
	    header_default_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "bcc",
	    header_bcc_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "from",
	    header_masquerade_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "to",
	    header_masquerade_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "cc",
	    header_masquerade_callback, s);
	rfc2822_body_callback(&s->rfc2822_parser,
	    dataline_callback, s);

d527 13
a539 1
	/* session may have been freed by now */
@


1.222
log
@move the message parser init earlier to avoid a possible use after free in
an unlikely error code path
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.221 2014/12/17 15:49:23 millert Exp $	*/
d320 1
a320 1
		if (!comment && buffer[i] != ')' && !isspace((int)buffer[i]))
d339 1
a339 1
		while (isspace(buffer[pos_bracket]))
d350 2
a351 1
                if (buffer[pos_component] == '\0' || isspace(buffer[pos_component]))
@


1.221
log
@Use log_warnx() not log_warn() for mail loop warning since errno
is not set.  OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.220 2014/11/02 21:46:03 gilles Exp $	*/
d318 3
a320 1
		if (! isspace(buffer[i]))
d512 15
d544 1
a544 13
	rfc2822_parser_init(&s->rfc2822_parser);
	rfc2822_header_default_callback(&s->rfc2822_parser,
	    header_default_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "bcc",
	    header_bcc_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "from",
	    header_masquerade_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "to",
	    header_masquerade_callback, s);
	rfc2822_header_callback(&s->rfc2822_parser, "cc",
	    header_masquerade_callback, s);
	rfc2822_body_callback(&s->rfc2822_parser,
	    dataline_callback, s);
@


1.220
log
@increment s->datalen counter in append domain code to correctly account for
the data we wrote
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.219 2014/11/02 21:13:32 gilles Exp $	*/
d1813 1
a1813 1
			log_warn("warn: loop detected");
@


1.219
log
@rework domain append by locating either the brackets or the last component
of an address and appending domain if not already there. this works better
than trying to parse addresses and render them back, while allowing us to
do the append "in place" and cope nicely with multi-line addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.218 2014/10/15 08:09:02 gilles Exp $	*/
d409 1
d417 1
d428 1
d436 1
d451 1
@


1.218
log
@when From, To and Cc headers present users without domains, append the
listener hostname to avoid smtpd relaying a header that will be rewritten
by the destination MX.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.217 2014/10/04 08:43:24 gilles Exp $	*/
d53 2
d283 79
a364 1
	struct rfc822_parser	rp;
d366 2
a367 1
	struct rfc822_address  *ra;
d369 1
a369 7
	char			buf[SMTPD_MAXLINESIZE];
	int			ret;

	rfc822_parser_init(&rp);
	TAILQ_FOREACH(l, &hdr->lines, next)
	    if (! rfc822_parser_feed(&rp, l->buffer))
		    goto fail;
d372 2
a373 5
	if (fprintf(s->ofile, "%s:", hdr->name) != (int)len) {
		s->msgflags |= MF_ERROR_IO;
		rfc822_parser_reset(&rp);
		return;
	}
d376 45
a420 9
	TAILQ_FOREACH(ra, &rp.addresses, next) {
		/* no address provided, append local host */
		if (strchr(ra->address, '@@') == NULL) {
			(void)strlcat(ra->address, "@@", sizeof ra->address);
			if (strlcat(ra->address, s->listener->hostname,
				sizeof ra->address) >= sizeof ra->address) {
				s->msgflags |= MF_ERROR_MALFORMED;
				rfc822_parser_reset(&rp);
				return;
d423 3
a425 6

		if (ra->name[0] == '\0') {
			ret = snprintf(buf, sizeof buf, "%s%s%s",
			    TAILQ_FIRST(&rp.addresses) == ra ? " " : "\t",
			    ra->address,
			    TAILQ_LAST(&rp.addresses, addresses) == ra ? "" : ",");
d428 9
a436 10
			ret = snprintf(buf, sizeof buf, "%s%s <%s>%s",
			    TAILQ_FIRST(&rp.addresses) == ra ? " " : "\t",
			    ra->name,
			    ra->address,
			    TAILQ_LAST(&rp.addresses, addresses) == ra ? "" : ",");
		}
		if (ret == -1 || ret >= (int)sizeof buf) {
			s->msgflags |= MF_ERROR_MALFORMED;
			rfc822_parser_reset(&rp);
			return;
d438 1
d440 7
a446 7
		len = strlen(buf) + 1;
		if (fprintf(s->ofile, "%s\n", buf) != (int)len) {
			s->msgflags |= MF_ERROR_IO;
			rfc822_parser_reset(&rp);
			return;
		}
		s->datalen += len;
a447 1
	rfc822_parser_reset(&rp);
d450 3
a452 3
fail:
	rfc822_parser_reset(&rp);
	header_default_callback(hdr, arg);
@


1.217
log
@some MUA will bypass the local enqueuer and send an empty BCC header in the
DATA part of the SMTP transaction. force smtpd to strip these headers when
it sees them.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.216 2014/10/02 21:27:54 gilles Exp $	*/
d85 6
a90 4
	MF_QUEUE_ENVELOPE_FAIL	= 0x0001,
	MF_ERROR_SIZE		= 0x1000,
	MF_ERROR_IO		= 0x2000,
	MF_ERROR_LOOP		= 0x4000,
d92 1
a92 1
#define MF_ERROR	(MF_ERROR_SIZE | MF_ERROR_IO | MF_ERROR_LOOP)
a150 1
	int			 skiphdr;
d152 2
d231 121
d418 14
a996 12
			if (isspace(line[0]) && s->skiphdr)
				goto nextline;
			s->skiphdr = 0;

			/* BCC should be stripped from headers */
			if (! s->hdrdone) {
				if (strncasecmp("bcc:", line, 4) == 0) {
					s->skiphdr = 1;
					goto nextline;
				}
			}

d1369 2
d1687 1
a1687 1
	size_t	len;
d1709 3
a1711 4
	len = strlen(line) + 1;

	if (s->datalen + len > env->sc_maxsize) {
		s->msgflags |= MF_ERROR_SIZE;
d1713 1
d1715 2
a1716 3

	if (fprintf(s->ofile, "%s\n", line) != (int)len) {
		s->msgflags |= MF_ERROR_IO;
a1718 2

	s->datalen += len;
d1745 7
d1867 2
@


1.216
log
@when no domain is specified in MAIL FROM or RCPT TO, assume local user
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.215 2014/07/09 12:44:54 eric Exp $	*/
d149 1
d857 12
@


1.215
log
@add a "no-dsn" listener option to disable DSN extension.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.214 2014/07/08 20:14:46 eric Exp $	*/
d1761 2
a1762 4
		/* We accept empty sender for MAIL FROM */
		if (mailfrom &&
		    maddr->user[0] == '\0' &&
		    maddr->domain[0] == '\0')
d1765 6
a1770 4
		/* We accept empty domain for RCPT TO if user is postmaster */
		if (!mailfrom &&
		    strcasecmp(maddr->user, "postmaster") == 0 &&
		    maddr->domain[0] == '\0') {
a1774 1
			
@


1.215.4.1
log
@Incorrect logic in smtpd(8) can lead to unexpected client disconnect, invalid
certificate in SNI negotiation or server crash.

spotted by Edwin Torok
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.215 2014/07/09 12:44:54 eric Exp $	*/
a186 1
static const char *smtp_sni_get_servername(struct smtp_session *);
d600 1
a600 1
		ssl = ssl_smtp_init(ssl_ctx, smtp_sni_callback);
a778 1
	const char	       *sn;
a795 8
		sn = smtp_sni_get_servername(s);
		if (sn) {
			if (strlcpy(s->sni, sn, sizeof s->sni) >= sizeof s->sni) {
				smtp_free(s, "client SNI exceeds max hostname length");
				return;
			}
		}

a1879 6
static const char *
smtp_sni_get_servername(struct smtp_session *s)
{
	return SSL_get_servername(s->io.ssl, TLSEXT_NAMETYPE_host_name);
}

d1884 1
d1890 4
d1895 3
a1897 1
	if (ssl_ctx == NULL)
d1899 1
@


1.215.4.2
log
@Errata 031:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.215.4.1 2015/04/19 20:30:06 gilles Exp $	*/
a143 1
	size_t			 datain;
a1566 7
	/* account for newline */
	s->datain += strlen(line) + 1;
	if (s->datain > env->sc_maxsize) {
		s->msgflags |= MF_ERROR_SIZE;
		return;
	}

d1580 5
a1644 1
	s->datain = 0;
a1794 2
#define MAX_CERTS	16
#define MAX_CERT_LEN	(MAX_IMSGSIZE - (IMSG_HEADER_SIZE + sizeof(req_ca_vrfy)))
d1799 1
a1800 15
	unsigned char	       *cert_der[MAX_CERTS];
	int			cert_len[MAX_CERTS];
	int			i, cert_count, res;

	res = 0;
	memset(cert_der, 0, sizeof(cert_der));
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);

	if (s->listener->pki_name[0])
		pkiname = s->listener->pki_name;
	else
		pkiname = s->smtpname;
	if (strlcpy(req_ca_vrfy.pkiname, pkiname, sizeof req_ca_vrfy.pkiname)
	    >= sizeof req_ca_vrfy.pkiname)
		return 0;
d1815 1
a1815 2
	cert_len[0] = i2d_X509(x, &cert_der[0]);
	X509_free(x);
d1817 4
a1820 18
	if (cert_len[0] < 0) {
		log_warnx("warn: failed to encode certificate");	
		goto end;
	}
	log_debug("debug: certificate 0: len=%d", cert_len[0]);
	if (cert_len[0] > (int)MAX_CERT_LEN) {
		log_warnx("warn: certificate too long");	
		goto end;
	}

	if (xchain) {
		cert_count = sk_X509_num(xchain);
		log_debug("debug: certificate chain len: %d", cert_count);
		if (cert_count >= MAX_CERTS) {
			log_warnx("warn: certificate chain too long");	
			goto end;
		}
	}
d1822 1
a1822 1
		cert_count = 0;
d1824 3
a1826 13
	for (i = 0; i < cert_count; ++i) {
		x = sk_X509_value(xchain, i);
		cert_len[i+1] = i2d_X509(x, &cert_der[i+1]);
		if (cert_len[i+1] < 0) {
			log_warnx("warn: failed to encode certificate");	
			goto end;
		}
		log_debug("debug: certificate %i: len=%d", i+1, cert_len[i+1]);
		if (cert_len[i+1] > (int)MAX_CERT_LEN) {
			log_warnx("warn: certificate too long");	
			goto end;
		}
	}
a1827 3
	tree_xset(&wait_ssl_verify, s->id, s);

	/* Send the client certificate */
d1829 3
a1831 2
	req_ca_vrfy.cert_len = cert_len[0];
	req_ca_vrfy.n_chain = cert_count;
d1834 2
a1835 2
	iov[1].iov_base = cert_der[0];
	iov[1].iov_len = cert_len[0];
d1838 2
d1841 15
a1855 10
	memset(&req_ca_vrfy, 0, sizeof req_ca_vrfy);
	req_ca_vrfy.reqid = s->id;

	/* Send the chain, one cert at a time */
	for (i = 0; i < cert_count; ++i) {
		req_ca_vrfy.cert_len = cert_len[i+1];
		iov[1].iov_base = cert_der[i+1];
		iov[1].iov_len  = cert_len[i+1];
		m_composev(p_lka, IMSG_SMTP_SSL_VERIFY_CHAIN, 0, 0, -1,
		    iov, nitems(iov));
d1864 1
a1864 7
	res = 1;

    end:
	for (i = 0; i < MAX_CERTS; ++i)
		free(cert_der[i]);

	return res;
@


1.214
log
@get rid of mfa leftovers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.213 2014/07/08 07:59:31 sobrado Exp $	*/
d159 3
d692 2
a693 1
			smtp_reply(s, "250-DSN");
d1401 1
a1401 1
		if (strncasecmp(b, "NOTIFY=", 7) == 0) {
d1420 1
a1420 1
		} else if (strncasecmp(b, "ORCPT=", 6) == 0) {
d1453 1
a1453 1
		else if (strncasecmp(b, "RET=", 4) == 0) {
d1459 1
a1459 1
		} else if (strncasecmp(b, "ENVID=", 6) == 0) {
@


1.213
log
@fix typos.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.212 2014/07/04 15:24:46 eric Exp $	*/
d634 1
a634 1
	if (status == MFA_CLOSE) {
d646 1
a646 1
		if (status != MFA_OK) {
d670 1
a670 1
		if (status != MFA_OK) {
d702 1
a702 1
		if (status != MFA_OK) {
d717 1
a717 1
		if (status != MFA_OK) {
d740 1
a740 1
		if (status != MFA_OK) {
d755 1
a755 1
		if (status != MFA_OK) {
d1923 1
a1923 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_CONNECT, MFA_OK, 0, NULL);
d1929 1
a1929 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_EOM, MFA_OK, 0, NULL);
d1935 1
a1935 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_HELO, MFA_OK, 0, NULL);
d1941 1
a1941 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_MAIL, MFA_OK, 0, NULL);
d1947 1
a1947 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_RCPT, MFA_OK, 0, NULL);
d1953 1
a1953 1
	smtp_mfa_response(s, IMSG_SMTP_REQ_DATA, MFA_OK, 0, NULL);
@


1.212
log
@It makes much more sense to do the loop checking on incoming mails rather
than on outgoing mails...

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.211 2014/05/17 20:07:54 chl Exp $	*/
d998 1
a998 1
			smtp_reply(s, "503 %s %s: Already indentified",
@


1.211
log
@add missing header needed by str* and mem* functions

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.210 2014/04/29 19:13:13 reyk Exp $	*/
d88 1
a88 1
	MF_ERROR_MFA		= 0x4000,
d90 1
a143 1

d146 2
d1547 1
a1547 1
	if (s->msgflags & (MF_ERROR_IO | MF_ERROR_SIZE | MF_ERROR_MFA))
d1550 14
d1591 1
a1591 1
	if (s->msgflags & (MF_ERROR_SIZE | MF_ERROR_MFA | MF_ERROR_IO)) {
d1599 4
d1632 2
@


1.210
log
@Implement RSA privilege separation for OpenSMTPD, based on my previous
implementation for relayd(8).  The smtpd(8) pony processes (mta
client, smtp server) don't keep the private keys in memory but send
their private key operations as imsgs to the "lookup"/mta process.
It's worth mentioning that this prevents acidental private key leakage
as it could have been caused by "Heartbleed".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.209 2014/04/29 12:18:27 reyk Exp $	*/
d39 1
@


1.209
log
@Remove unused arguments from ssl_smtp_init()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.208 2014/04/29 10:18:06 reyk Exp $	*/
d298 1
a587 5

		resp_ca_cert->key = xstrdup((char *)imsg->data +
		    sizeof *resp_ca_cert + resp_ca_cert->cert_len,
		    "smtp:ca_key");

d589 1
a589 1
			ssl_ctx = dict_get(env->sc_ssl_dict, s->listener->pki_name);
d591 2
a592 1
			ssl_ctx = dict_get(env->sc_ssl_dict, s->smtpname);
a598 1
		explicit_bzero(resp_ca_cert->key, resp_ca_cert->key_len);
a599 1
		free(resp_ca_cert->key);
@


1.208
log
@use explicit_bzero() instead of memset() to clear out sensitive data.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.207 2014/04/19 17:04:42 gilles Exp $	*/
d597 1
a597 4
		ssl = ssl_smtp_init(ssl_ctx,
		    resp_ca_cert->cert, resp_ca_cert->cert_len,
		    resp_ca_cert->key, resp_ca_cert->key_len,
		    smtp_sni_callback, s);
@


1.207
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.205 2014/04/19 16:56:34 gilles Exp $	*/
d604 2
a605 2
		memset(resp_ca_cert->cert, 0, resp_ca_cert->cert_len);
		memset(resp_ca_cert->key, 0, resp_ca_cert->key_len);
@


1.206
log
@add a missing strlcpy() check in MAIL FROM's DSN parameters parsing, the
truncation would lead to a failure later in the code path but we can fail
earlier with a nice enhanced status code
@
text
@d1464 3
a1466 3
			smtp_reply(s, "503 %s %s: option too large, truncated: %s",
			    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),
			    esc_description(ESC_INVALID_COMMAND_ARGUMENTS), b);
@


1.205
log
@(void) cast strlcpy() calls that cannot truncate (copies between buffers of
	same size with a truncation check on the initial buffer)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.204 2014/04/19 16:52:20 gilles Exp $	*/
d1462 7
a1468 1
			strlcpy(s->evp.dsn_envid, b, sizeof(s->evp.dsn_envid));
@


1.204
log
@(void) cast a strlcpy() that cannot truncate because lka.c ensures the
	reply will fit in the buffer before returning the answer
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.203 2014/04/19 16:50:28 gilles Exp $	*/
d661 1
a661 1
				strlcpy(req_ca_cert.name, s->listener->pki_name,
d664 1
a664 1
				strlcpy(req_ca_cert.name, s->smtpname,
d908 1
a908 1
				strlcpy(req_ca_cert.name, s->listener->pki_name,
d911 1
a911 1
				strlcpy(req_ca_cert.name, s->smtpname,
@


1.203
log
@(void) cast strlcpy() that cannot truncate, dns.c ensures the reply will
	fit in the buffer before returning the answer
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.202 2014/04/19 16:44:01 gilles Exp $	*/
d355 1
a355 1
			strlcpy(s->smtpname, helo, sizeof(s->smtpname));
@


1.202
log
@(void) cast strlcpy() calls that cannot truncate or where the source data
	has a length check right before the copy
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.201 2014/04/19 16:26:23 gilles Exp $	*/
d318 1
a318 1
		strlcpy(s->hostname, line, sizeof s->hostname);
@


1.201
log
@(void) cast a snprintf() call that cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.200 2014/04/09 18:55:19 eric Exp $	*/
d268 1
a268 1
	strlcpy(s->smtpname, listener->hostname, sizeof(s->smtpname));
d276 1
a276 1
		strlcpy(s->hostname, hostname, sizeof(s->hostname));
d889 1
a889 1
		strlcpy(s->cmd, line, sizeof s->cmd);
d1024 1
a1024 1
		strlcpy(s->helo, args, sizeof(s->helo));
d1616 4
a1619 4
		strlcpy(s->evp.tag, s->listener->tag, sizeof(s->evp.tag));
		strlcpy(s->evp.smtpname, s->smtpname, sizeof(s->evp.smtpname));
		strlcpy(s->evp.hostname, s->hostname, sizeof s->evp.hostname);
		strlcpy(s->evp.helo, s->helo, sizeof s->evp.helo);
@


1.200
log
@Zap the mfa process. It is not currently doing anything, and content filtering
will be done at session level anyway.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1954 1
a1954 1
		snprintf(buf, sizeof(buf), "STATE_??? (%d)", state);
@


1.199
log
@remove useless define for banner

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.198 2014/04/04 16:10:42 eric Exp $	*/
a125 2
	enum imsg_type		 mfa_imsg; /* last send */

d161 1
a161 1
static void smtp_mfa_response(struct smtp_session *, int, uint32_t,
a173 1
static void smtp_wait_mfa(struct smtp_session *s, int);
d182 11
a211 1
static struct tree wait_mfa_response;
a228 1
		tree_init(&wait_mfa_response);
d302 1
a302 1
	uint32_t			 code, msgid;
a360 14
	case IMSG_MFA_SMTP_RESPONSE:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_int(&m, &status);
		m_get_u32(&m, &code);
		if (!m_is_eom(&m))
			m_get_string(&m, &line);
		else
			line = NULL;
		m_end(&m);
		s = tree_xpop(&wait_mfa_response, reqid);
		smtp_mfa_response(s, status, code, line);
		return;

d498 1
a498 3
			m_create(p_mfa, IMSG_SMTP_EVENT_ROLLBACK, 0, 0, -1);
			m_add_id(p_mfa, s->id);
			m_close(p_mfa);
d506 1
a506 4
		m_create(p_mfa, IMSG_SMTP_EVENT_COMMIT, 0, 0, -1);
		m_add_id(p_mfa, s->id);
		m_close(p_mfa);

d634 1
a634 1
smtp_mfa_response(struct smtp_session *s, int status, uint32_t code,
d648 1
a648 1
	switch (s->mfa_imsg) {
d884 1
a884 5
			m_create(p_mfa, IMSG_SMTP_REQ_EOM, 0, 0, -1);
			m_add_id(p_mfa, s->id);
			m_add_u32(p_mfa, s->datalen);
			m_close(p_mfa);
			smtp_wait_mfa(s, IMSG_SMTP_REQ_EOM);
d1033 1
a1033 6
		m_create(p_mfa, IMSG_SMTP_REQ_HELO, 0, 0, -1);
		m_add_id(p_mfa, s->id);
		m_add_string(p_mfa, s->helo);
		m_close(p_mfa);
		smtp_wait_mfa(s, IMSG_SMTP_REQ_HELO);

d1162 1
a1162 5
		m_create(p_mfa, IMSG_SMTP_REQ_MAIL, 0, 0, -1);
		m_add_id(p_mfa, s->id);
		m_add_mailaddr(p_mfa, &s->evp.sender);
		m_close(p_mfa);
		smtp_wait_mfa(s, IMSG_SMTP_REQ_MAIL);
d1192 1
a1192 5
		m_create(p_mfa, IMSG_SMTP_REQ_RCPT, 0, 0, -1);
		m_add_id(p_mfa, s->id);
		m_add_mailaddr(p_mfa, &s->evp.rcpt);
		m_close(p_mfa);
		smtp_wait_mfa(s, IMSG_SMTP_REQ_RCPT);
d1203 1
a1203 3
		m_create(p_mfa, IMSG_SMTP_EVENT_RSET, 0, 0, -1);
		m_add_id(p_mfa, s->id);
		m_close(p_mfa);
d1231 1
a1231 4
		m_create(p_mfa, IMSG_SMTP_REQ_DATA, 0, 0, -1);
		m_add_id(p_mfa, s->id);
		m_close(p_mfa);
		smtp_wait_mfa(s, IMSG_SMTP_REQ_DATA);
a1516 6
	m_create(p_mfa, IMSG_SMTP_REQ_CONNECT, 0, 0, -1);
	m_add_id(p_mfa, s->id);
	m_add_sockaddr(p_mfa, (struct sockaddr *)&ss);
	m_add_sockaddr(p_mfa, (struct sockaddr *)&s->ss);
	m_add_string(p_mfa, s->hostname);
	m_close(p_mfa);
d1518 1
a1518 1
	smtp_wait_mfa(s, IMSG_SMTP_REQ_CONNECT);
a1667 7
smtp_wait_mfa(struct smtp_session *s, int type)
{
	s->mfa_imsg = type;
	tree_xset(&wait_mfa_response, s->id, s);	
}

static void
a1674 1
	tree_pop(&wait_mfa_response, s->id);
d1685 2
a1686 5
	if (s->flags & SF_MFACONNSENT) {
		m_create(p_mfa, IMSG_SMTP_EVENT_DISCONNECT, 0, 0, -1);
		m_add_id(p_mfa, s->id);
		m_close(p_mfa);
	}
d1879 55
@


1.198
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1565 1
a1565 1
	smtp_reply(s, SMTPD_BANNER, s->smtpname, SMTPD_NAME);
@


1.197
log
@more informative log message on unknown SNI.

looks better to tedu@@, ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.196 2014/02/17 11:06:54 eric Exp $	*/
d274 4
a277 1
		dns_query_ptr(s->id, (struct sockaddr *)&s->ss);
d302 1
a302 1
	case IMSG_DNS_PTR:
d317 1
a317 1
	case IMSG_LKA_EXPAND_RCPT:
d342 1
a342 1
	case IMSG_LKA_HELO:
d369 1
a369 1
	case IMSG_QUEUE_CREATE_MESSAGE:
d390 1
a390 1
	case IMSG_QUEUE_MESSAGE_FILE:
d451 1
a451 1
	case IMSG_QUEUE_SUBMIT_ENVELOPE:
d465 1
a465 1
	case IMSG_QUEUE_COMMIT_ENVELOPES:
d499 1
a499 1
	case IMSG_QUEUE_COMMIT_MESSAGE:
d506 1
a506 1
			m_create(p_mfa, IMSG_MFA_EVENT_ROLLBACK, 0, 0, -1);
d516 1
a516 1
		m_create(p_mfa, IMSG_MFA_EVENT_COMMIT, 0, 0, -1);
d549 1
a549 1
	case IMSG_LKA_AUTHENTICATE:
d584 1
a584 1
	case IMSG_LKA_SSL_INIT:
d624 1
a624 1
	case IMSG_LKA_SSL_VERIFY:
d663 1
a663 1
	case IMSG_MFA_REQ_CONNECT:
d679 1
a679 1
			m_compose(p_lka, IMSG_LKA_SSL_INIT, 0, 0, -1,
d687 1
a687 1
	case IMSG_MFA_REQ_HELO:
d719 1
a719 1
	case IMSG_MFA_REQ_MAIL:
d728 1
a728 1
		m_create(p_queue, IMSG_QUEUE_CREATE_MESSAGE, 0, 0, -1);
d734 1
a734 1
	case IMSG_MFA_REQ_RCPT:
d750 1
a750 1
		m_create(p_lka, IMSG_LKA_EXPAND_RCPT, 0, 0, -1);
d757 1
a757 1
	case IMSG_MFA_REQ_DATA:
d765 1
a765 1
		m_create(p_queue, IMSG_QUEUE_MESSAGE_FILE, 0, 0, -1);
d772 1
a772 1
	case IMSG_MFA_REQ_EOM:
d897 1
a897 1
			m_create(p_mfa, IMSG_MFA_REQ_EOM, 0, 0, -1);
d901 1
a901 1
			smtp_wait_mfa(s, IMSG_MFA_REQ_EOM);
d930 1
a930 1
			m_compose(p_lka, IMSG_LKA_SSL_INIT, 0, 0, -1,
d1050 1
a1050 1
		m_create(p_mfa, IMSG_MFA_REQ_HELO, 0, 0, -1);
d1054 1
a1054 1
		smtp_wait_mfa(s, IMSG_MFA_REQ_HELO);
d1184 1
a1184 1
		m_create(p_mfa, IMSG_MFA_REQ_MAIL, 0, 0, -1);
d1188 1
a1188 1
		smtp_wait_mfa(s, IMSG_MFA_REQ_MAIL);
d1218 1
a1218 1
		m_create(p_mfa, IMSG_MFA_REQ_RCPT, 0, 0, -1);
d1222 1
a1222 1
		smtp_wait_mfa(s, IMSG_MFA_REQ_RCPT);
d1233 1
a1233 1
		m_create(p_mfa, IMSG_MFA_EVENT_RSET, 0, 0, -1);
d1238 1
a1238 1
			m_create(p_queue, IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1);
d1263 1
a1263 1
		m_create(p_mfa, IMSG_MFA_REQ_DATA, 0, 0, -1);
d1266 1
a1266 1
		smtp_wait_mfa(s, IMSG_MFA_REQ_DATA);
d1345 1
a1345 1
		m_create(p_lka,  IMSG_LKA_AUTHENTICATE, 0, 0, -1);
d1392 1
a1392 1
		m_create(p_lka,  IMSG_LKA_AUTHENTICATE, 0, 0, -1);
d1523 1
a1523 1
			m_create(p_lka, IMSG_LKA_HELO, 0, 0, -1);
d1552 1
a1552 1
	m_create(p_mfa, IMSG_MFA_REQ_CONNECT, 0, 0, -1);
d1559 1
a1559 1
	smtp_wait_mfa(s, IMSG_MFA_REQ_CONNECT);
d1618 1
a1618 1
		m_create(p_queue, IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1);
d1632 1
a1632 1
	m_create(p_queue, IMSG_QUEUE_COMMIT_MESSAGE, 0, 0, -1);
d1729 1
a1729 1
		m_create(p_queue, IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1);
d1735 1
a1735 1
		m_create(p_mfa, IMSG_MFA_EVENT_DISCONNECT, 0, 0, -1);
d1853 1
a1853 1
	m_composev(p_lka, IMSG_LKA_SSL_VERIFY_CERT, 0, 0, -1,
d1869 1
a1869 1
			m_composev(p_lka, IMSG_LKA_SSL_VERIFY_CHAIN, 0, 0, -1,
d1878 1
a1878 1
	m_compose(p_lka, IMSG_LKA_SSL_VERIFY, 0, 0, -1,
@


1.196
log
@do not lookup pki based on hostname if one was specified for the listener
otherwise we may fail to find it and reject client.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.195 2014/02/04 15:44:05 eric Exp $	*/
d1920 2
a1921 1
		log_warnx("warn: SNI name not found in PKI");
@


1.196.2.1
log
@Incorrect logic in smtpd(8) can lead to unexpected client disconnect, invalid
certificate in SNI negotiation or server crash.

spotted by Edwin Torok
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.196 2014/02/17 11:06:54 eric Exp $	*/
a183 1
static const char *smtp_sni_get_servername(struct smtp_session *);
d610 1
a610 1
		    smtp_sni_callback);
a789 1
	const char	       *sn;
a806 8
		sn = smtp_sni_get_servername(s);
		if (sn) {
			if (strlcpy(s->sni, sn, sizeof s->sni) >= sizeof s->sni) {
				smtp_free(s, "client SNI exceeds max hostname length");
				return;
			}
		}

a1903 6
static const char *
smtp_sni_get_servername(struct smtp_session *s)
{
	return SSL_get_servername(s->io.ssl, TLSEXT_NAMETYPE_host_name);
}

d1908 1
d1914 4
d1919 2
a1920 1
	if (ssl_ctx == NULL)
d1922 1
@


1.195
log
@Add support for DSN and Enhanced Status Code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d670 6
a675 2
			strlcpy(req_ca_cert.name, s->smtpname,
			    sizeof req_ca_cert.name);
d921 6
a926 2
			strlcpy(req_ca_cert.name, s->smtpname,
			    sizeof req_ca_cert.name);
@


1.194
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.193 2014/02/04 09:50:31 eric Exp $	*/
d101 1
d170 1
d180 1
d196 1
d376 2
a377 1
			smtp_reply(s, "250 Ok");
d379 2
a380 1
			smtp_reply(s, "421 Temporary Error");
d398 2
a399 1
			smtp_reply(s, "421 Temporary Error");
d476 2
a477 1
			smtp_reply(s, "421 Temporary failure");
d489 3
a491 1
			smtp_reply(s, "250 Recipient ok");
d506 2
a507 1
			smtp_reply(s, "421 Temporary failure");
d517 2
a518 1
		smtp_reply(s, "250 %08x Message accepted for delivery",
d559 2
a560 1
			smtp_reply(s, "235 Authentication succeeded");
d571 2
a572 1
			smtp_reply(s, "421 Temporary failure");
d700 1
d844 2
a845 1
			smtp_reply(s, "500 Line too long");
d877 3
a879 1
			smtp_reply(s, "500 Pipelining not supported");
d954 2
a955 2
	char			*args, *eom, *method;
	int			 cmd, i;
d1009 3
a1011 1
			smtp_reply(s, "503 Already indentified");
d1016 3
a1018 1
			smtp_reply(s, "501 %s requires domain name",
d1020 1
d1025 3
a1027 1
			smtp_reply(s, "501 Invalid domain name");
d1051 3
a1053 1
			smtp_reply(s, "503 Command not allowed at this point.");
d1058 3
a1060 1
			smtp_reply(s, "503 Command not supported");
d1065 3
a1067 1
			smtp_reply(s, "503 Channel already secured");
d1071 3
a1073 1
			smtp_reply(s, "501 No parameters allowed");
d1076 2
a1077 1
		smtp_reply(s, "220 Ready to start TLS");
d1083 3
a1085 1
			smtp_reply(s, "503 Command not allowed at this point.");
d1090 3
a1092 1
			smtp_reply(s, "503 Already authenticated");
d1097 3
a1099 1
			smtp_reply(s, "503 Command not supported");
d1104 3
a1106 1
			smtp_reply(s, "501 No parameters given");
d1121 3
a1123 1
			smtp_reply(s, "504 AUTH method \"%s\" not supported",
d1129 4
a1132 1
			smtp_reply(s, "503 Command not allowed at this point.");
d1139 3
a1141 1
			    "530 Must issue a STARTTLS command first");
d1148 3
a1150 1
			    "530 Must issue an AUTH command first");
d1155 4
a1158 1
			smtp_reply(s, "452 Too many messages sent");
d1165 3
a1167 2
		    s->smtpname) == 0) {
			smtp_reply(s, "553 Sender address syntax error");
d1184 3
a1186 1
			smtp_reply(s, "503 Command not allowed at this point.");
d1191 3
a1193 1
			smtp_reply(s, "452 Too many recipients");
d1200 2
a1201 1
			    "553 Recipient address syntax error");
d1204 1
a1204 3
		if (*args) {
			smtp_reply(s,
			    "553 No option supported on RCPT TO");
a1205 1
		}
d1216 3
a1218 1
			smtp_reply(s, "503 Command not allowed at this point.");
d1234 2
a1235 1
		smtp_reply(s, "250 2.0.0 Reset state");
d1240 3
a1242 1
			smtp_reply(s, "503 Command not allowed at this point.");
d1246 3
a1248 1
			smtp_reply(s, "503 5.5.1 No recipient specified");
d1261 2
a1262 1
		smtp_reply(s, "221 Bye");
d1267 2
a1268 1
		smtp_reply(s, "250 Ok");
d1276 8
a1283 1
		smtp_reply(s, "214 End of HELP info");
d1287 3
a1289 1
		smtp_reply(s, "500 Command unrecognized");
d1348 3
a1350 1
	smtp_reply(s, "501 Syntax error");
d1395 3
a1397 1
	smtp_reply(s, "501 Syntax error");
d1401 59
d1473 1
a1473 1
		else if (!strcasecmp(b, "BODY=7BIT"))
d1478 13
a1490 2
		else {
			smtp_reply(s, "503 Unsupported option %s", b);
d1611 3
a1613 1
			smtp_reply(s, "554 Message too big");
d1918 1
@


1.193
log
@add base64_encode/base64_decode helpers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.192 2013/12/26 17:25:32 eric Exp $	*/
d115 1
d119 1
d159 1
d180 1
d267 2
a268 1
		smtp_connected(s);
d292 1
d306 2
a307 1
		smtp_connected(s);
d345 1
a345 2
		smtp_reply(s, SMTPD_BANNER, s->smtpname, SMTPD_NAME);
		io_reload(&s->io);
d588 6
a593 1
		ssl = ssl_smtp_init(s->listener->ssl_ctx,
d595 2
a596 1
		    resp_ca_cert->key, resp_ca_cert->key_len);
d656 1
a656 1
			strlcpy(req_ca_cert.name, s->listener->ssl_cert_name,
a895 1

d899 1
a899 1
			strlcpy(req_ca_cert.name, s->listener->ssl_cert_name,
d1349 26
a1404 21
	struct sockaddr_storage	 ss;
	struct sockaddr		*sa;
	socklen_t		 sa_len;

	if (s->listener->hostnametable[0]) {
		sa_len = sizeof(ss);
		sa = (struct sockaddr *)&ss;
		if (getsockname(s->io.sock, sa, &sa_len) == -1) {
			log_warn("warn: getsockname()");
		}
		else {
			m_create(p_lka, IMSG_LKA_HELO, 0, 0, -1);
			m_add_id(p_lka, s->id);
			m_add_string(p_lka, s->listener->hostnametable);
			m_add_sockaddr(p_lka, sa);
			m_close(p_lka);
			tree_xset(&wait_lka_helo, s->id, s);
			return;
		}
	}

d1655 1
d1674 6
a1679 1
	if (strlcpy(req_ca_vrfy.pkiname, s->listener->ssl_cert_name, sizeof req_ca_vrfy.pkiname)
d1745 22
@


1.192
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.191 2013/11/28 12:39:23 eric Exp $	*/
d1226 1
a1226 1
		if ((len = __b64_pton(arg, (unsigned char *)buf,
d1279 2
a1280 2
		if (__b64_pton(arg, (unsigned char *)s->username,
		    sizeof(s->username) - 1) == -1)
d1289 2
a1290 1
		if (__b64_pton(arg, (unsigned char *)buf, sizeof(buf)-1) == -1)
@


1.191
log
@better response
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.190 2013/11/28 10:43:37 eric Exp $	*/
d588 2
a589 2
		bzero(resp_ca_cert->cert, resp_ca_cert->cert_len);
		bzero(resp_ca_cert->key, resp_ca_cert->key_len);
d1278 1
a1278 1
		bzero(s->username, sizeof(s->username));
d1288 1
a1288 1
		bzero(buf, sizeof(buf));
d1470 1
a1470 1
	bzero(&s->evp, sizeof s->evp);
d1655 1
a1655 1
	bzero(&req_ca_vrfy, sizeof req_ca_vrfy);
d1676 1
a1676 1
			bzero(&req_ca_vrfy, sizeof req_ca_vrfy);
d1691 1
a1691 1
	bzero(&req_ca_vrfy, sizeof req_ca_vrfy);
@


1.190
log
@unsigned char casts for ctype
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.189 2013/11/18 12:24:26 eric Exp $	*/
d985 1
a985 1
			smtp_reply(s, "501 %s requires domain address",
@


1.189
log
@Allow overriding the local ca
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d962 1
a962 1
		while (isspace((int)*args))
@


1.188
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d1656 4
@


1.187
log
@Report the ssl certificate verification status in the mail header.
Log ssl certificate validation errors.
Fix several ssl-related leaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.186 2013/10/27 11:01:47 eric Exp $	*/
d117 1
d155 1
a155 1
static int smtp_mailaddr(struct mailaddr *, char *, int, char **);
d158 1
d194 1
d212 1
d254 2
d282 1
a282 1
	const char			*line;
d328 14
d392 9
a400 7
		fprintf(s->ofile,
		    "Received: from %s (%s [%s]);\n"
		    "\tby %s (%s) with %sSMTP%s%s id %08x;\n",
		    s->evp.helo,
		    s->hostname,
		    ss_to_text(&s->ss),
		    s->listener->helo[0] ? s->listener->helo : env->sc_hostname,
d601 6
a606 1

d651 1
a651 5
		if (s->listener->helo[0])
			smtp_reply(s, SMTPD_BANNER, s->listener->helo, SMTPD_NAME);
		else
			smtp_reply(s, SMTPD_BANNER, env->sc_hostname, SMTPD_NAME);
		io_reload(&s->io);
d666 1
a666 1
		    env->sc_hostname,
d781 7
a801 1
			smtp_reply(s, SMTPD_BANNER, env->sc_hostname, SMTPD_NAME);
d803 1
d1099 2
a1100 1
		if (smtp_mailaddr(&s->evp.sender, args, 1, &args) == 0) {
d1127 2
a1128 1
		if (smtp_mailaddr(&s->evp.rcpt, args, 0, &args) == 0) {
d1364 28
d1479 1
d1579 2
a1580 1
smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args)
d1614 10
@


1.186
log
@Make the filter infrastructure move forward.
This is a work-in-progress and it's not supposed to be useable for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.185 2013/10/26 12:27:59 eric Exp $	*/
d280 1
d386 1
d392 3
a394 6
			    "NO");
			/* XXX - this can be uncommented when we *fully* verify */
			/*
			 *  (s->flags & SF_VERIFIED) ? "YES" :
			 *  (SSL_get_peer_certificate(s->io.ssl) ? "FAIL" : "NO"));
			 */
d568 2
d738 1
d761 2
a762 1
		if (SSL_get_peer_certificate(s->io.ssl))
d767 2
d1595 1
@


1.185
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.184 2013/07/19 21:18:54 eric Exp $	*/
a320 9
	case IMSG_MFA_SMTP_DATA:
		m_msg(&m, imsg);
		m_get_id(&m, &reqid);
		m_get_string(&m, &line);
		m_end(&m);
		if ((s = tree_get(&wait_mfa_data, reqid)))
			smtp_message_write(s, line);
		return;

d547 1
a547 1
			smtp_free(s, "CA failure");	
d827 1
@


1.184
log
@When accepting a message, log one line per recipient with the number of
generated envelopes for each.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1390 1
a1390 1
			smtp_reply(s, "%i Message rejected", s->msgcode);
@


1.183
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.181 2013/02/21 14:22:52 eric Exp $	*/
d104 6
d136 1
d138 2
a139 1
	size_t			 destcount;
d238 2
d272 1
d455 6
d491 16
a506 10
		log_info("smtp-in: Accepted message %08x on session %016"PRIx64
		    ": from=<%s%s%s>, size=%zu, nrcpts=%zu, proto=%s",
		    evpid_to_msgid(s->evp.id),
		    s->id,
		    s->evp.sender.user,
		    s->evp.sender.user[0] == '\0' ? "" : "@@",
		    s->evp.sender.domain,
		    s->datalen,
		    s->rcptcount,
		    s->flags & SF_EHLO ? "ESMTP" : "SMTP");
d1406 7
d1481 2
d1507 5
@


1.182
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@a24 1
#include <sys/param.h>
d80 1
d110 1
a110 1
	char			 hostname[MAXHOSTNAMELEN];
d120 1
a120 1
	char			 username[MAXLOGNAME];
d135 2
d165 2
d263 1
a263 1
	char				 user[MAXLOGNAME];
d289 1
d296 1
a296 1
			smtp_reply(s, "550 Invalid recipient");
d305 1
a305 3
			smtp_reply(s, "421 Temporary failure");
			smtp_enter_state(s, STATE_QUIT);
			break;
d346 1
d371 1
a371 1
		    "\tby %s (%s) with %sSMTP id %08x;\n",
d378 2
d458 1
a458 1
			m_create(p_mfa, IMSG_MFA_EVENT_ROLLBACK, 0, 0, -1, 8);
d467 1
a467 1
		m_create(p_mfa, IMSG_MFA_EVENT_COMMIT, 0, 0, -1, 16);
d511 2
a512 1
			smtp_reply(s, "535 Authentication failed");
d521 1
d656 1
a656 1
		m_create(p_queue, IMSG_QUEUE_CREATE_MESSAGE, 0, 0, -1, 32);
d678 1
a678 1
		m_create(p_lka, IMSG_LKA_EXPAND_RCPT, 0, 0, -1, MSZ_EVP);
d693 1
a693 1
		m_create(p_queue, IMSG_QUEUE_MESSAGE_FILE, 0, 0, -1, 16);
d767 1
d799 1
d811 1
a811 1
			m_create(p_mfa, IMSG_MFA_REQ_EOM, 0, 0, -1, 16);
d953 1
a953 2
		m_create(p_mfa, IMSG_MFA_REQ_HELO, 0, 0, -1,
		    32 + strlen(s->helo));
d1056 1
a1056 2
		m_create(p_mfa, IMSG_MFA_REQ_MAIL, 0, 0, -1,
		    32 + sizeof(struct mailaddr));
d1087 1
a1087 2
		m_create(p_mfa, IMSG_MFA_REQ_RCPT, 0, 0, -1,
		    32 + sizeof(struct mailaddr));
d1100 1
a1100 1
		m_create(p_mfa, IMSG_MFA_EVENT_RSET, 0, 0, -1, 8);
d1105 1
a1105 2
			m_create(p_queue, IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1,
			    4);
d1125 1
a1125 1
		m_create(p_mfa, IMSG_MFA_REQ_DATA, 0, 0, -1, 16);
d1196 1
a1196 1
		m_create(p_lka,  IMSG_LKA_AUTHENTICATE, 0, 0, -1, 128);
d1240 1
a1240 1
		m_create(p_lka,  IMSG_LKA_AUTHENTICATE, 0, 0, -1, 128);
d1302 1
a1302 1
	m_create(p_mfa, IMSG_MFA_REQ_CONNECT, 0, 0, -1, 64 + strlen(s->hostname));
d1361 1
a1361 1
		m_create(p_queue, IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1, 4);
d1373 1
a1373 1
	m_create(p_queue, IMSG_QUEUE_COMMIT_MESSAGE, 0, 0, -1, 16);
d1424 13
a1436 3
		strnvis(tmp, s->cmd, sizeof tmp, VIS_SAFE | VIS_CSTYLE);
		log_info("smtp-in: Failed command on session %016" PRIx64
		    ": \"%s\" => %.*s", s->id, tmp, n, buf);
d1460 1
a1460 1
		m_create(p_queue, IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1, 5);
d1466 1
a1466 1
		m_create(p_mfa, IMSG_MFA_EVENT_DISCONNECT, 0, 0, -1, 16);
d1512 1
a1512 1
	    !valid_localpart(maddr->domain)) {
d1587 24
@


1.181
log
@do not send disconnect event to the mfa if connect event was not sent.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.180 2013/02/16 16:20:07 gilles Exp $	*/
d118 2
a119 2
	char			 helo[SMTP_LINE_MAX];
	char			 cmd[SMTP_LINE_MAX];
d222 1
a222 1
	if (iobuf_init(&s->iobuf, MAX_LINE_SIZE, MAX_LINE_SIZE) == -1) {
d757 2
a758 2
		if ((line == NULL && iobuf_len(&s->iobuf) >= SMTP_LINE_MAX) ||
		    (line && len >= SMTP_LINE_MAX)) {
d1211 1
a1211 1
	char		buf[MAX_LINE_SIZE + 1];
d1401 1
a1401 1
	char	 buf[SMTP_LINE_MAX], tmp[SMTP_LINE_MAX];
d1406 1
a1406 1
	if (n == -1 || n >= SMTP_LINE_MAX)
@


1.180
log
@only use local hostname in Received lines if listener has not overriden it,
otherwise use the listener hostname

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.179 2013/02/15 17:36:08 eric Exp $	*/
d80 1
d1302 1
d1449 5
a1453 3
	m_create(p_mfa, IMSG_MFA_EVENT_DISCONNECT, 0, 0, -1, 16);
	m_add_id(p_mfa, s->id);
	m_close(p_mfa);
@


1.179
log
@terminate session instead of fatal() if getsockname() fails.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.178 2013/02/05 11:45:18 gilles Exp $	*/
d370 1
a370 1
		    env->sc_hostname,
@


1.178
log
@- handle getaddrinfo() error as LKA_TEMPFAIL
- handle getsockname() error in smtp_connected()
- accept '/' as part of user-part, expand to ':' as done by qmail
- fix wrong check in mda leading to bogus Return-Path header
- fix aliases parsing when there's a white space between key and separator
- some cosmethic cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.177 2013/01/26 09:37:23 gilles Exp $	*/
d1290 4
a1293 2
	if (getsockname(s->io.sock, (struct sockaddr*)&ss, &sl) == -1)
		fatal("getsockname");
@


1.177
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.175 2012/11/12 14:58:53 eric Exp $	*/
d1290 2
a1291 1
	getsockname(s->io.sock, (struct sockaddr*)&ss, &sl);
@


1.176
log
@knf

ok gilles@@
@
text
@d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d27 1
d36 1
a42 2
#include <openssl/ssl.h>

d45 1
d47 2
a48 1
#define SMTP_KICKTHRESHOLD	50
d50 2
a51 2
#define SMTP_MAXMAIL	100
#define SMTP_MAXRCPT	1000
d53 5
a57 2
#define ADVERTISE_TLS(s) \
	((s)->s_l->flags & F_STARTTLS && !((s)->s_flags & F_SECURE))
d59 12
a70 3
#define ADVERTISE_AUTH(s) \
	((s)->s_l->flags & F_AUTH && (s)->s_flags & F_SECURE && \
	 !((s)->s_flags & F_AUTHENTICATED))
d72 8
a79 38
void	 ssl_error(const char *);

static int session_rfc5321_helo_handler(struct session *, char *);
static int session_rfc5321_ehlo_handler(struct session *, char *);
static int session_rfc5321_rset_handler(struct session *, char *);
static int session_rfc5321_noop_handler(struct session *, char *);
static int session_rfc5321_data_handler(struct session *, char *);
static int session_rfc5321_mail_handler(struct session *, char *);
static int session_rfc5321_rcpt_handler(struct session *, char *);
static int session_rfc5321_vrfy_handler(struct session *, char *);
static int session_rfc5321_expn_handler(struct session *, char *);
static int session_rfc5321_turn_handler(struct session *, char *);
static int session_rfc5321_help_handler(struct session *, char *);
static int session_rfc5321_quit_handler(struct session *, char *);

static int session_rfc1652_mail_handler(struct session *, char *);

static int session_rfc3207_stls_handler(struct session *, char *);

static int session_rfc4954_auth_handler(struct session *, char *);
static void session_rfc4954_auth_plain(struct session *, char *);
static void session_rfc4954_auth_login(struct session *, char *);

static void session_line(struct session *, char *, size_t);
static void session_read_data(struct session *, char *);
static void session_command(struct session *, char *);
static void session_respond_delayed(int, short, void *);
static int session_set_mailaddr(struct mailaddr *, char *);
static void session_imsg(struct session *, enum smtp_proc_type,
    enum imsg_type, uint32_t, pid_t, int, void *, uint16_t);

static void session_enter_state(struct session *, int);

const char *session_strstate(int);

struct session_cmd {
	char	 *name;
	int		(*func)(struct session *, char *);
d82 5
a86 13
struct session_cmd rfc5321_cmdtab[] = {
	{ "helo",	session_rfc5321_helo_handler },
	{ "ehlo",	session_rfc5321_ehlo_handler },
	{ "rset",	session_rfc5321_rset_handler },
	{ "noop",	session_rfc5321_noop_handler },
	{ "data",	session_rfc5321_data_handler },
	{ "mail from",	session_rfc5321_mail_handler },
	{ "rcpt to",	session_rfc5321_rcpt_handler },
	{ "vrfy",	session_rfc5321_vrfy_handler },
	{ "expn",	session_rfc5321_expn_handler },
	{ "turn",	session_rfc5321_turn_handler },
	{ "help",	session_rfc5321_help_handler },
	{ "quit",	session_rfc5321_quit_handler }
d89 12
a100 2
struct session_cmd rfc1652_cmdtab[] = {
	{ "mail from",	session_rfc1652_mail_handler },
d103 28
a130 3
struct session_cmd rfc3207_cmdtab[] = {
	{ "starttls",	session_rfc3207_stls_handler }
};
d132 2
a133 2
struct session_cmd rfc4954_cmdtab[] = {
	{ "auth",	session_rfc4954_auth_handler }
d136 2
a137 5
static int
session_rfc3207_stls_handler(struct session *s, char *args)
{
	if (! ADVERTISE_TLS(s))
		return 0;
d139 3
a141 4
	if (s->s_state == S_GREETED) {
		session_respond(s, "503 Polite people say HELO first");
		return 1;
	}
d143 34
a176 4
	if (s->s_state != S_HELO) {
		session_respond(s, "503 TLS not allowed at this stage");
		return 1;
	}
d178 10
a187 4
	if (args != NULL) {
		session_respond(s, "501 No parameters allowed");
		return 1;
	}
d189 4
a192 2
	session_enter_state(s, S_TLS);
	session_respond(s, "220 Ready to start TLS");
d194 13
a206 1
	return 1;
d209 3
a211 2
static int
session_rfc4954_auth_handler(struct session *s, char *args)
d213 1
a213 2
	char	*method;
	char	*eom;
d215 1
a215 7
	if (! ADVERTISE_AUTH(s)) {
		if (s->s_flags & F_AUTHENTICATED) {
			session_respond(s, "503 Already authenticated");
			return 1;
		} else
			return 0;
	}
d217 1
a217 4
	if (s->s_state == S_GREETED) {
		session_respond(s, "503 Polite people say HELO first");
		return 1;
	}
d219 5
a223 3
	if (s->s_state != S_HELO) {
		session_respond(s, "503 Session already in progress");
		return 1;
d225 21
a245 4

	if (args == NULL) {
		session_respond(s, "501 No parameters given");
		return 1;
d248 1
a248 15
	method = args;
	eom = strchr(args, ' ');
	if (eom == NULL)
		eom = strchr(args, '\t');
	if (eom != NULL)
		*eom++ = '\0';

	if (strcasecmp(method, "PLAIN") == 0)
		session_rfc4954_auth_plain(s, eom);
	else if (strcasecmp(method, "LOGIN") == 0)
		session_rfc4954_auth_login(s, eom);
	else
		session_respond(s, "504 AUTH method '%s' unsupported", method);

	return 1;
d251 2
a252 2
static void
session_rfc4954_auth_plain(struct session *s, char *arg)
d254 25
a278 3
	struct auth	*a = &s->s_auth;
	char		 buf[1024], *user, *pass;
	int		 len;
d280 22
a301 6
	switch (s->s_state) {
	case S_HELO:
		if (arg == NULL) {
			session_enter_state(s, S_AUTH_INIT);
			session_respond(s, "334 ");
			return;
d303 2
a304 2
		session_enter_state(s, S_AUTH_INIT);
		/* FALLTHROUGH */
d306 8
a313 7
	case S_AUTH_INIT:
		/* String is not NUL terminated, leave room. */
		if ((len = __b64_pton(arg, (unsigned char *)buf,
			    sizeof(buf) - 1)) == -1)
			goto abort;
		/* buf is a byte string, NUL terminate. */
		buf[len] = '\0';
d315 13
a327 9
		/*
		 * Skip "foo" in "foo\0user\0pass", if present.
		 */
		user = memchr(buf, '\0', len);
		if (user == NULL || user >= buf + len - 2)
			goto abort;
		user++; /* skip NUL */
		if (strlcpy(a->user, user, sizeof(a->user)) >= sizeof(a->user))
			goto abort;
d329 17
a345 6
		pass = memchr(user, '\0', len - (user - buf));
		if (pass == NULL || pass >= buf + len - 2)
			goto abort;
		pass++; /* skip NUL */
		if (strlcpy(a->pass, pass, sizeof(a->pass)) >= sizeof(a->pass))
			goto abort;
d347 16
a362 1
		session_enter_state(s, S_AUTH_FINALIZE);
d364 24
a387 3
		a->id = s->s_id;
		session_imsg(s, PROC_PARENT, IMSG_PARENT_AUTHENTICATE, 0, 0, -1,
		    a, sizeof(*a));
d389 5
a393 2
		bzero(a->pass, sizeof(a->pass));
		return;
d395 1
a395 3
	default:
		fatal("session_rfc4954_auth_plain: unknown state");
	}
d397 3
a399 4
abort:
	session_respond(s, "501 Syntax error");
	session_enter_state(s, S_HELO);
}
d401 3
a403 4
static void
session_rfc4954_auth_login(struct session *s, char *arg)
{
	struct auth	*a = &s->s_auth;
d405 12
a416 4
	switch (s->s_state) {
	case S_HELO:
		session_enter_state(s, S_AUTH_USERNAME);
		session_respond(s, "334 VXNlcm5hbWU6");
d419 23
a441 8
	case S_AUTH_USERNAME:
		bzero(a->user, sizeof(a->user));
		if (__b64_pton(arg, (unsigned char *)a->user,
			sizeof(a->user) - 1) == -1)
			goto abort;

		session_enter_state(s, S_AUTH_PASSWORD);
		session_respond(s, "334 UGFzc3dvcmQ6");
d444 15
a458 5
	case S_AUTH_PASSWORD:
		bzero(a->pass, sizeof(a->pass));
		if (__b64_pton(arg, (unsigned char *)a->pass,
			sizeof(a->pass) - 1) == -1)
			goto abort;
d460 17
a476 1
		session_enter_state(s, S_AUTH_FINALIZE);
d478 6
a483 5
		a->id = s->s_id;
		session_imsg(s, PROC_PARENT, IMSG_PARENT_AUTHENTICATE, 0, 0, -1,
		    a, sizeof(*a));

		bzero(a->pass, sizeof(a->pass));
d486 24
a509 27
	default:
		fatal("session_rfc4954_auth_login: unknown state");
	}

abort:
	session_respond(s, "501 Syntax error");
	session_enter_state(s, S_HELO);
}

static int
session_rfc1652_mail_handler(struct session *s, char *args)
{
	char *body;

	if (s->s_state == S_GREETED) {
		session_respond(s, "503 5.5.1 Polite people say HELO first");
		return 1;
	}

	for (body = strrchr(args, ' '); body != NULL;
		body = strrchr(args, ' ')) {
		*body++ = '\0';

		if (strncasecmp(body, "AUTH=", 5) == 0) {
			log_debug("debug: smtp: "
			    "AUTH in MAIL FROM command, skipping");
			continue;
d511 5
d517 3
a519 2
		if (strncasecmp(body, "BODY=", 5) == 0) {
			log_debug("debug: smtp: BODY in MAIL FROM command");
d521 5
a525 10
			if (strncasecmp("body=7bit", body, 9) == 0) {
				s->s_flags &= ~F_8BITMIME;
				continue;
			}

			else if (strncasecmp("body=8bitmime", body, 13) != 0) {
				session_respond(s,
				    "503 5.5.4 Unsupported option %s", body);
				return 1;
			}
a526 1
	}
d528 20
a547 2
	return session_rfc5321_mail_handler(s, args);
}
d549 3
a551 7
static int
session_rfc5321_helo_handler(struct session *s, char *args)
{
	if (args == NULL || !valid_domainpart(args)) {
		session_respond(s, "501 HELO requires domain address");
		return 1;
	}
d553 2
a554 5
	if (strlcpy(s->s_msg.helo, args, sizeof(s->s_msg.helo))
	    >= sizeof(s->s_msg.helo)) {
		session_respond(s, "501 Invalid domain name");
		return 1;
	}
d556 3
a558 21
	s->s_msg.session_id = s->s_id;
	s->s_flags &= F_SECURE|F_AUTHENTICATED;
	session_enter_state(s, S_HELO);

	session_imsg(s, PROC_MFA, IMSG_MFA_HELO, 0, 0, -1, &s->s_msg,
	    sizeof(s->s_msg));
	return 1;
}

static int
session_rfc5321_ehlo_handler(struct session *s, char *args)
{
	if (args == NULL || !valid_domainpart(args)) {
		session_respond(s, "501 EHLO requires domain address");
		return 1;
	}

	if (strlcpy(s->s_msg.helo, args, sizeof(s->s_msg.helo))
	    >= sizeof(s->s_msg.helo)) {
		session_respond(s, "501 Invalid domain name");
		return 1;
d561 3
a563 9
	s->s_msg.session_id = s->s_id;
	s->s_flags &= F_SECURE|F_AUTHENTICATED;
	s->s_flags |= F_EHLO;
	s->s_flags |= F_8BITMIME;
	session_enter_state(s, S_HELO);

	session_imsg(s, PROC_MFA, IMSG_MFA_HELO, 0, 0, -1, &s->s_msg,
	    sizeof(s->s_msg));
	return 1;
d566 3
a568 2
static int
session_rfc5321_rset_handler(struct session *s, char *args)
d570 1
a570 1
	session_enter_state(s, S_RSET);
d572 7
a578 19
	session_imsg(s, PROC_MFA, IMSG_MFA_RSET, 0, 0, -1, &s->s_msg,
	    sizeof(s->s_msg));
	return 1;
}

static int
session_rfc5321_noop_handler(struct session *s, char *args)
{
	session_respond(s, "250 2.0.0 OK");

	return 1;
}

static int
session_rfc5321_mail_handler(struct session *s, char *args)
{
	if (s->s_state == S_GREETED) {
		session_respond(s, "503 5.5.1 Polite people say HELO first");
		return 1;
d581 1
d583 6
a588 5
	if (s->s_l->flags & F_STARTTLS_REQUIRE)
		if (!(s->s_flags & F_SECURE)) {
			session_respond(s,
			    "530 5.7.0 Must issue a STARTTLS command first");
			return 1;
d591 8
a598 5
	if (s->s_l->flags & F_AUTH_REQUIRE)
		if (!(s->s_flags & F_AUTHENTICATED)) {
			session_respond(s,
			    "530 5.7.0 Must issue an AUTH command first");
			return 1;
d600 6
d607 8
a614 4
	if (s->s_state != S_HELO) {
		session_respond(s, "503 5.5.1 Sender already specified");
		return 1;
	}
d616 21
a636 4
	if (s->mailcount >= SMTP_MAXMAIL) {
		session_respond(s, "452 Too many messages sent");
		return 1;
	}
d638 8
a645 5
	if (! session_set_mailaddr(&s->s_msg.sender, args)) {
		/* No need to even transmit to MFA, path is invalid */
		session_respond(s, "553 5.1.7 Sender address syntax error");
		return 1;
	}
d647 5
a651 2
	s->rcptcount = 0;
	s->s_msg.id = 0;
d653 15
a667 5
	session_enter_state(s, S_MAIL_MFA);
	session_imsg(s, PROC_MFA, IMSG_MFA_MAIL, 0, 0, -1, &s->s_msg,
	    sizeof(s->s_msg));
	return 1;
}
d669 6
a674 7
static int
session_rfc5321_rcpt_handler(struct session *s, char *args)
{
	if (s->s_state == S_GREETED) {
		session_respond(s, "503 5.5.1 Polite people say HELO first");
		return 1;
	}
d676 14
a689 4
	if (s->s_state == S_HELO) {
		session_respond(s, "503 5.5.1 Need MAIL before RCPT");
		return 1;
	}
d691 10
a700 4
	if (s->rcptcount >= SMTP_MAXRCPT) {
		session_respond(s, "452 Too many recipients");
		return 1;
	}
d702 2
a703 40
	if (! session_set_mailaddr(&s->s_msg.rcpt, args)) {
		/* No need to even transmit to MFA, path is invalid */
		session_respond(s, "553 5.1.3 Recipient address syntax error");
		return 1;
	}

	session_enter_state(s, S_RCPT_MFA);
	session_imsg(s, PROC_MFA, IMSG_MFA_RCPT, 0, 0, -1, &s->s_msg,
	    sizeof(s->s_msg));
	return 1;
}

static int
session_rfc5321_quit_handler(struct session *s, char *args)
{
	session_enter_state(s, S_QUIT);
	session_respond(s, "221 2.0.0 %s Closing connection", env->sc_hostname);
/*
	session_imsg(s, PROC_MFA, IMSG_MFA_QUIT, 0, 0, -1, &s->s_msg,
	    sizeof(s->s_msg));
*/
	return 1;
}

static int
session_rfc5321_data_handler(struct session *s, char *args)
{
	if (s->s_state == S_GREETED) {
		session_respond(s, "503 5.5.1 Polite people say HELO first");
		return 1;
	}

	if (s->s_state == S_HELO) {
		session_respond(s, "503 5.5.1 Need MAIL before DATA");
		return 1;
	}

	if (s->s_state == S_MAIL) {
		session_respond(s, "503 5.5.1 Need RCPT before DATA");
		return 1;
a704 46

	session_enter_state(s, S_DATA_QUEUE);

	session_imsg(s, PROC_QUEUE, IMSG_QUEUE_MESSAGE_FILE, 0, 0, -1,
	    &s->s_msg, sizeof(s->s_msg));

	return 1;
}

static int
session_rfc5321_vrfy_handler(struct session *s, char *args)
{
	session_respond(s,
	    "252 5.5.1 Cannot VRFY; try RCPT to attempt delivery");

	return 1;
}

static int
session_rfc5321_expn_handler(struct session *s, char *args)
{
	session_respond(s,
	    "502 5.5.2 Sorry, we do not allow this operation");

	return 1;
}

static int
session_rfc5321_turn_handler(struct session *s, char *args)
{
	session_respond(s,
	    "502 5.5.2 Sorry, we do not allow this operation");

	return 1;
}

static int
session_rfc5321_help_handler(struct session *s, char *args)
{
	session_respond(s, "214- This is OpenSMTPD");
	session_respond(s, "214- To report bugs in the implementation, please "
	    "contact bugs@@openbsd.org");
	session_respond(s, "214- with full details");
	session_respond(s, "214 End of HELP info");

	return 1;
d708 1
a708 1
session_enter_state(struct session *s, int newstate)
d710 4
a713 3
	log_trace(TRACE_SMTP, "smtp: %p: %s -> %s", s,
	    session_strstate(s->s_state),
	    session_strstate(newstate));
d715 2
a716 2
	s->s_state = newstate;
}
d718 1
a718 5
static void
session_command(struct session *s, char *cmd)
{
	char		*ep, *args;
	unsigned int	 i;
d720 3
a722 9
	/*
	 * unlike other commands, "mail from" and "rcpt to" contain a
	 * space in the command name.
	 */
	if (strncasecmp("mail from:", cmd, 10) == 0 ||
	    strncasecmp("rcpt to:", cmd, 8) == 0)
		ep = strchr(cmd, ':');
	else
		ep = strchr(cmd, ' ');
d724 3
a726 10
	if (ep != NULL) {
		*ep = '\0';
		args = ++ep;
		while (isspace((int)*args))
			args++;
	} else
		args = NULL;

	if (!(s->s_flags & F_EHLO))
		goto rfc5321;
d728 2
a729 3
	/* RFC 1652 - 8BITMIME */
	for (i = 0; i < nitems(rfc1652_cmdtab); ++i)
		if (strcasecmp(rfc1652_cmdtab[i].name, cmd) == 0)
d731 1
a731 22
	if (i < nitems(rfc1652_cmdtab)) {
		if (rfc1652_cmdtab[i].func(s, args))
			return;
	}

	/* RFC 3207 - STARTTLS */
	for (i = 0; i < nitems(rfc3207_cmdtab); ++i)
		if (strcasecmp(rfc3207_cmdtab[i].name, cmd) == 0)
			break;
	if (i < nitems(rfc3207_cmdtab)) {
		if (rfc3207_cmdtab[i].func(s, args))
			return;
	}

	/* RFC 4954 - AUTH */
	for (i = 0; i < nitems(rfc4954_cmdtab); ++i)
		if (strcasecmp(rfc4954_cmdtab[i].name, cmd) == 0)
			break;
	if (i < nitems(rfc4954_cmdtab)) {
		if (rfc4954_cmdtab[i].func(s, args))
			return;
	}
d733 1
a733 9
rfc5321:
	/* RFC 5321 - SMTP */
	for (i = 0; i < nitems(rfc5321_cmdtab); ++i)
		if (strcasecmp(rfc5321_cmdtab[i].name, cmd) == 0)
			break;
	if (i < nitems(rfc5321_cmdtab)) {
		if (rfc5321_cmdtab[i].func(s, args))
			return;
	}
d735 6
a740 2
	session_respond(s, "500 Command unrecognized");
}
d742 1
a742 16
void
session_io(struct io *io, int evt)
{
	struct session	*s = io->arg;
	void		*ssl;
	char		*line;
	size_t		 len;

	log_trace(TRACE_IO, "smtp: %p: %s %s", s, io_strevent(evt),
	    io_strio(io));

	switch (evt) {

	case IO_TLSREADY:
		s->s_flags |= F_SECURE;
		if (s->s_l->flags & F_SMTPS)
d744 4
a747 1
		if (s->s_l->flags & F_STARTTLS)
d749 1
a749 3
		if (s->s_state == S_INIT) {
			io_set_write(&s->s_io);
			session_respond(s, SMTPD_BANNER, env->sc_hostname);
a750 4
		log_info("smtp-in: Started TLS on session %016" PRIx64 ": %s",
		    s->s_id, ssl_to_text(s->s_io.ssl));
		s->kickcount = 0;
		session_enter_state(s, S_GREETED);
d755 2
a756 2
		line = iobuf_getline(&s->s_iobuf, &len);
		if ((line == NULL && iobuf_len(&s->s_iobuf) >= SMTP_LINE_MAX) ||
d758 2
a759 2
			session_respond(s, "500 5.0.0 Line too long");
			session_enter_state(s, S_QUIT);
d764 1
d766 1
a766 1
			iobuf_normalize(&s->s_iobuf);
d770 6
a775 6
		if (s->s_state == S_DATACONTENT && strcmp(line, ".")) {
			/* more data to come */
			session_line(s, line, len);
			if (s->s_flags & F_KICK) {
				session_destroy(s, "kick");
				return;
d777 7
d787 4
a790 5
		/* pipelining not supported */
		if (iobuf_len(&s->s_iobuf)) {
			session_respond(s,
			    "500 5.0.0 Pipelining not supported");
			session_enter_state(s, S_QUIT);
d795 9
a803 4
		strlcpy(s->cmd, line, sizeof s->cmd);
		session_line(s, line, len);
		if (s->s_flags & F_KICK) {
			session_destroy(s, "kick");
d806 3
a808 1
		iobuf_normalize(&s->s_iobuf);
d810 4
d817 3
a819 4
		if (s->s_state == S_QUIT) {
			log_info("smtp-in: Closing session %016" PRIx64,
			    s->s_id);
			session_destroy(s, "done");
a822 1
		io_set_read(io);
d824 9
a832 4
		/* wait for the client to start tls */
		if (s->s_state == S_TLS) {
			ssl = ssl_smtp_init(s->s_l->ssl_ctx);
			io_start_tls(io, ssl);
d834 2
d839 3
a841 3
		log_info("smtp-in: Disconnecting session %016" PRIx64
		    ": session timeout", s->s_id);
		session_destroy(s, "timeout");
d845 3
a847 3
		log_info("smtp-in: "
		    "Received disconnect from session %016" PRIx64, s->s_id);
		session_destroy(s, "disconnected");
d851 3
a853 3
		log_info("smtp-in: Disconnecting session %016" PRIx64
		    ": IO error: %s", s->s_id, strerror(errno));
		session_destroy(s, "error");
d857 1
a857 1
		fatal("session_io()");
d861 2
a862 2
void
session_pickup(struct session *s, struct submit_status *ss)
d864 4
a867 2
	char	 user[MAXLOGNAME];
	void	*ssl;
d869 7
a875 1
	s->s_flags &= ~F_WAITIMSG;
d877 9
a885 6
	if ((ss != NULL && ss->code == 421) ||
	    (s->s_dstatus & DS_TEMPFAILURE)) {
		stat_increment("smtp.tempfail", 1);
		session_respond(s, "421 Service temporarily unavailable");
		session_enter_state(s, S_QUIT);
		io_reload(&s->s_io);
d889 33
a921 14
	switch (s->s_state) {

	case S_CONNECTED:
		session_enter_state(s, S_INIT);
		log_info("smtp-in: "
		    "New session %016" PRIx64 " from host %s [%s]",
		    s->s_id,
		    s->s_hostname,
		    ss_to_text(&s->s_ss));
		s->s_msg.session_id = s->s_id;
		s->s_msg.ss = s->s_ss;
		session_imsg(s, PROC_MFA, IMSG_MFA_CONNECT, 0, 0, -1,
		    &s->s_msg, sizeof(s->s_msg));
		break;
d923 4
a926 6
	case S_INIT:
		if (ss->code != 250) {
			log_info("smtp-in: Disconnecting session %016" PRIx64
			    ": rejected by filter", s->s_id);
			session_destroy(s, "rejected by filter");
			return;
d929 9
a937 5
		if (s->s_l->flags & F_SMTPS) {
			ssl = ssl_smtp_init(s->s_l->ssl_ctx);
			io_set_read(&s->s_io);
			io_start_tls(&s->s_io, ssl);
			return;
d940 9
a948 2
		session_respond(s, SMTPD_BANNER, env->sc_hostname);
		session_enter_state(s, S_GREETED);
d950 13
d964 7
a970 11
	case S_AUTH_FINALIZE:
		strnvis(user, s->s_auth.user, sizeof user, VIS_WHITE|VIS_SAFE);
		if (s->s_flags & F_AUTHENTICATED) {
			session_respond(s, "235 Authentication succeeded");
			log_info("smtp-in: Accepted authentication for user %s "
			    "on session %016" PRIx64, user, s->s_id);
			s->kickcount = 0;
		} else {
			log_info("smtp-in: Failed authentication for user %s "
			    "on session %016" PRIx64, user, s->s_id);
			session_respond(s, "535 Authentication failed");
d972 2
a973 1
		session_enter_state(s, S_HELO);
d976 34
a1009 3
	case S_RSET:
		session_respond(s, "250 2.0.0 Reset state");
		session_enter_state(s, S_HELO);
d1012 3
a1014 4
	case S_HELO:
		if (ss->code != 250) {
			session_enter_state(s, S_GREETED);
			session_respond(s, "%d Helo rejected", ss->code);
d1018 6
a1023 3
		session_respond(s, "250%c%s Hello %s [%s], pleased to meet you",
		    (s->s_flags & F_EHLO) ? '-' : ' ',
		    env->sc_hostname, s->s_msg.helo, ss_to_text(&s->s_ss));
d1025 6
a1030 4
		if (s->s_flags & F_EHLO) {
			/* unconditionnal extensions go first */
			session_respond(s, "250-8BITMIME");
			session_respond(s, "250-ENHANCEDSTATUSCODES");
d1032 4
a1035 5
			/* XXX */
			/* we also want to support reading SIZE from MAIL
			 * parameters
			 */
			session_respond(s, "250-SIZE %zu", env->sc_maxsize);
d1037 1
a1037 2
			if (ADVERTISE_TLS(s))
				session_respond(s, "250-STARTTLS");
d1039 3
a1041 3
			if (ADVERTISE_AUTH(s))
				session_respond(s, "250-AUTH PLAIN LOGIN");
			session_respond(s, "250 HELP");
d1043 9
a1051 1
		s->kickcount = 0;
d1053 8
d1062 2
a1063 4
	case S_MAIL_MFA:
		if (ss->code != 250) {
			session_enter_state(s, S_HELO);
			session_respond(s, "%d Sender rejected", ss->code);
d1067 10
a1076 2
		session_enter_state(s, S_MAIL_QUEUE);
		s->s_msg.sender = ss->u.maddr;
d1078 6
a1083 2
		session_imsg(s, PROC_QUEUE, IMSG_QUEUE_CREATE_MESSAGE, 0, 0, -1,
		    &s->s_msg, sizeof(s->s_msg));
d1086 20
a1105 3
	case S_MAIL_QUEUE:
		session_enter_state(s, S_MAIL);
		session_respond(s, "%d 2.1.0 Sender ok", ss->code);
d1108 7
a1114 12
	case S_RCPT_MFA:
		/* recipient was not accepted */
		if (ss->code != 250) {
			/* We do not have a valid recipient, downgrade state */
			if (s->rcptcount == 0)
				session_enter_state(s, S_MAIL);
			else
				session_enter_state(s, S_RCPT);
			session_respond(s, "%d 5.0.0 Recipient rejected: %s@@%s",
			    ss->code,
			    s->s_msg.rcpt.user,
			    s->s_msg.rcpt.domain);
d1118 4
a1121 5
		session_enter_state(s, S_RCPT);
		s->rcptcount++;
		s->kickcount--;
		s->s_msg.dest = ss->u.maddr;
		session_respond(s, "%d 2.0.0 Recipient ok", ss->code);
d1123 6
a1128 26

	case S_DATA_QUEUE:
		session_enter_state(s, S_DATACONTENT);
		session_respond(s, "354 Enter mail, end with \".\" on a line by"
		    " itself");

		fprintf(s->datafp, "Received: from %s (%s [%s])\n",
		    s->s_msg.helo, s->s_hostname, ss_to_text(&s->s_ss));
		fprintf(s->datafp, "\tby %s (OpenSMTPD) with %sSMTP id %08x",
		    env->sc_hostname, s->s_flags & F_EHLO ? "E" : "",
		    evpid_to_msgid(s->s_msg.id));

		if (s->s_flags & F_SECURE) {
			fprintf(s->datafp, "\n\t(version=%s cipher=%s bits=%d)",
			    SSL_get_cipher_version(s->s_io.ssl),
			    SSL_get_cipher_name(s->s_io.ssl),
			    SSL_get_cipher_bits(s->s_io.ssl, NULL));
		}
		if (s->rcptcount == 1)
			fprintf(s->datafp, "\n\tfor <%s@@%s>; ",
			    s->s_msg.rcpt.user,
			    s->s_msg.rcpt.domain);
		else
			fprintf(s->datafp, ";\n\t");

		fprintf(s->datafp, "%s\n", time_to_text(time(NULL)));
d1131 2
a1132 4
	case S_DATACONTENT:
		if (ss->code != 250)
			s->s_dstatus |= DS_PERMFAILURE;
		session_read_data(s, ss->u.dataline);
d1135 6
a1140 19
	case S_DONE:
		session_respond(s,
		    "250 2.0.0 %08x Message accepted for delivery",
		    evpid_to_msgid(s->s_msg.id));
		log_info("smtp-in: Accepted message %08x on session %016" PRIx64
		    ": from=<%s%s%s>, size=%ld, nrcpts=%zu, proto=%s",
		    evpid_to_msgid(s->s_msg.id),
		    s->s_id,
		    s->s_msg.sender.user,
		    s->s_msg.sender.user[0] == '\0' ? "" : "@@",
		    s->s_msg.sender.domain,
		    s->s_datalen,
		    s->rcptcount,
		    s->s_flags & F_EHLO ? "ESMTP" : "SMTP");
		session_enter_state(s, S_HELO);
		s->s_msg.id = 0;
		s->mailcount++;
		s->kickcount = 0;
		bzero(&s->s_nresp, sizeof(s->s_nresp));
d1144 2
a1145 1
		fatal("session_pickup: unknown state");
a1146 2

	io_reload(&s->s_io);
d1150 1
a1150 1
session_line(struct session *s, char *line, size_t len)
d1152 2
a1153 1
	struct submit_status ss;
d1155 5
a1159 7
	if (s->s_state != S_DATACONTENT) {
		log_trace(TRACE_SMTP, "smtp: %p: <<< %s", s, line);
		if (++s->kickcount >= SMTP_KICKTHRESHOLD) {
			log_info("smtp-in: Disconnecting session %016" PRIx64
			    ": session not moving forward", s->s_id);
			s->s_flags |= F_KICK;
			stat_increment("smtp.kick", 1);
d1162 2
a1163 1
	}
d1165 7
a1171 6
	switch (s->s_state) {
	case S_AUTH_INIT:
		if (s->s_dstatus & DS_TEMPFAILURE)
			goto tempfail;
		session_rfc4954_auth_plain(s, line);
		break;
d1173 10
a1182 6
	case S_AUTH_USERNAME:
	case S_AUTH_PASSWORD:
		if (s->s_dstatus & DS_TEMPFAILURE)
			goto tempfail;
		session_rfc4954_auth_login(s, line);
		break;
d1184 4
a1187 8
	case S_GREETED:
	case S_HELO:
	case S_MAIL:
	case S_RCPT:
		if (s->s_dstatus & DS_TEMPFAILURE)
			goto tempfail;
		session_command(s, line);
		break;
d1189 8
a1196 15
	case S_DATACONTENT:
		if (env->filtermask & FILTER_DATALINE) {
			bzero(&ss, sizeof(ss));
			ss.id = s->s_id;
			if (strlcpy(ss.u.dataline, line,
				sizeof(ss.u.dataline)) >= sizeof(ss.u.dataline))
				fatal("session_line: data truncation");

			session_imsg(s, PROC_MFA, IMSG_MFA_DATALINE,
			    0, 0, -1, &ss, sizeof(ss));
		} else {
			/* no filtering */
			session_read_data(s, line);
		}
		break;
d1199 1
a1199 2
		log_debug("debug: session_read: %i", s->s_state);
		fatalx("session_read: unexpected state");
d1202 3
a1204 6
	return;

tempfail:
	session_respond(s, "421 4.0.0 Service temporarily unavailable");
	stat_increment("smtp.tempfail", 1);
	session_enter_state(s, S_QUIT);
d1208 1
a1208 1
session_read_data(struct session *s, char *line)
d1210 6
a1215 22
	size_t datalen;
	size_t len;
	size_t i;

	if (strcmp(line, ".") == 0) {
		s->s_datalen = ftell(s->datafp);
		if (! safe_fclose(s->datafp))
			s->s_dstatus |= DS_TEMPFAILURE;
		s->datafp = NULL;

		if (s->s_dstatus & DS_PERMFAILURE) {
			session_respond(s, "554 5.0.0 Transaction failed");
			session_enter_state(s, S_HELO);
		} else if (s->s_dstatus & DS_TEMPFAILURE) {
			session_respond(s, "421 4.0.0 Temporary failure");
			session_enter_state(s, S_QUIT);
			stat_increment("smtp.tempfail", 1);
		} else {
			session_imsg(s, PROC_QUEUE, IMSG_QUEUE_COMMIT_MESSAGE,
			    0, 0, -1, &s->s_msg, sizeof(s->s_msg));
			session_enter_state(s, S_DONE);
		}
a1216 1
	}
d1218 8
a1225 2
	/* Don't waste resources on message if it's going to bin anyway. */
	if (s->s_dstatus & (DS_PERMFAILURE|DS_TEMPFAILURE))
d1228 4
a1231 5
	/* "If the first character is a period and there are other characters
	 *  on the line, the first character is deleted." [4.5.2]
	 */
	if (*line == '.')
		line++;
d1233 8
a1240 1
	len = strlen(line);
d1242 2
a1243 8
	/* If size of data overflows a size_t or exceeds max size allowed
	 * for a message, set permanent failure.
	 */
	datalen = ftell(s->datafp);
	if (SIZE_MAX - datalen < len + 1 ||
	    datalen + len + 1 > env->sc_maxsize) {
		s->s_dstatus |= DS_PERMFAILURE;
		return;
d1246 27
a1272 4
	if (! (s->s_flags & F_8BITMIME)) {
		for (i = 0; i < len; ++i)
			if (line[i] & 0x80)
				line[i] = line[i] & 0x7f;
d1275 1
a1275 2
	if (fprintf(s->datafp, "%s\n", line) != (int)len + 1)
		s->s_dstatus |= DS_TEMPFAILURE;
d1278 2
a1279 2
void
session_destroy(struct session *s, const char * reason)
d1281 4
a1284 1
	uint32_t msgid;
d1286 14
a1299 1
	log_debug("debug: smtp: %p: deleting session: %s", s, reason);
d1301 6
a1306 2
	if (s->s_flags & F_ZOMBIE)
		goto finalize;
d1308 2
a1309 2
	if (s->datafp != NULL)
		fclose(s->datafp);
d1311 4
a1314 5
	if (s->s_msg.id != 0 && s->s_state != S_DONE) {
		msgid = evpid_to_msgid(s->s_msg.id);
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1, &msgid, sizeof(msgid));
	}
d1316 1
a1316 8
	if (s->s_io.ssl) {
		if (s->s_l->flags & F_SMTPS)
			if (s->s_flags & F_SECURE)
				stat_decrement("smtp.smtps", 1);
		if (s->s_l->flags & F_STARTTLS)
			if (s->s_flags & F_SECURE)
				stat_decrement("smtp.tls", 1);
	}
d1318 3
a1320 3
	event_del(&s->s_ev); /* in case something was scheduled */
	io_clear(&s->s_io);
	iobuf_clear(&s->s_iobuf);
d1322 1
a1322 2
	/* resume when session count decreases to 95% */
	stat_decrement("smtp.session", 1);
d1324 2
a1325 5
	/* If the session is waiting for an imsg, do not kill it now, since
	 * the id must still be valid.
	 */
	if (s->s_flags & F_WAITIMSG) {
		s->s_flags = F_ZOMBIE;
d1329 4
a1332 3
    finalize:

	smtp_destroy(s);
d1334 1
a1334 3
	SPLAY_REMOVE(sessiontree, &env->sc_sessions, s);
	bzero(s, sizeof(*s));
	free(s);
d1337 2
a1338 2
int
session_cmp(struct session *s1, struct session *s2)
d1340 8
a1347 5
	/*
	 * do not return uint64_t's
	 */
	if (s1->s_id < s2->s_id)
		return (-1);
d1349 12
a1360 2
	if (s1->s_id > s2->s_id)
		return (1);
d1362 5
a1366 1
	return (0);
d1369 2
a1370 2
static int
session_set_mailaddr(struct mailaddr *maddr, char *line)
d1372 5
a1376 1
	size_t len;
d1378 11
a1388 6
	len = strlen(line);
	if (*line != '<' || line[len - 1] != '>')
		return 0;
	line[len - 1] = '\0';

	return email_to_mailaddr(maddr, line + 1);
d1391 2
a1392 2
void
session_respond(struct session *s, char *fmt, ...)
d1395 1
a1395 1
	int	 n, delay;
d1402 1
a1402 1
		fatal("session_respond: line too long");
d1404 1
a1404 1
		fatal("session_respond: response too short");
d1408 1
a1408 1
	iobuf_xfqueue(&s->s_iobuf, "session_respond", "%s\r\n", buf);
a1409 4
	/*
	 * Log failures.  Might be annoying in the long term, but it is a good
	 * development aid for now.
	 */
d1415 1
a1415 1
		    ": \"%s\" => %.*s", s->s_id, tmp, n, buf);
d1418 19
d1438 4
a1441 8
	/* Detect multi-line response. */
	switch (buf[3]) {
	case '-':
		return;
	case ' ':
		break;
	default:
		fatalx("session_respond: invalid response");
d1444 26
a1469 5
	/*
	 * Deal with request flooding; avoid letting response rate keep up
	 * with incoming request rate.
	 */
	s->s_nresp[s->s_state]++;
d1471 7
a1477 6
	if (s->s_state == S_RCPT)
		delay = 0;
	else if ((n = s->s_nresp[s->s_state] - FAST_RESPONSES) > 0)
		delay = MIN(1 << (n - 1), MAX_RESPONSE_DELAY);
	else
		delay = 0;
d1479 2
a1480 2
	if (delay > 0) {
		struct timeval tv = { delay, 0 };
d1482 5
a1486 2
		io_pause(&s->s_io, IO_PAUSE_OUT);
		stat_increment("smtp.delays", 1);
d1488 8
a1495 4
		/* in case session_respond is called multiple times */
		evtimer_del(&s->s_ev);
		evtimer_set(&s->s_ev, session_respond_delayed, s);
		evtimer_add(&s->s_ev, &tv);
d1497 2
d1501 2
a1502 2
static void
session_respond_delayed(int fd, short event, void *p)
d1504 5
a1508 1
	struct session	*s = p;
d1510 4
a1513 2
	io_resume(&s->s_io, IO_PAUSE_OUT);
}
a1514 7
/*
 * Send IMSG, waiting for reply safely.
 */
static void
session_imsg(struct session *s, enum smtp_proc_type proc, enum imsg_type type,
    uint32_t peerid, pid_t pid, int fd, void *data, uint16_t datalen)
{
d1516 5
a1520 6
	 * Each outgoing IMSG has a response IMSG associated that must be
	 * waited for before the session can be progressed further.
	 * During the wait period:
	 * 1) session must not be destroyed,
	 * 2) session must not be read from,
	 * 3) session may be written to.
d1523 40
a1562 3
	s->s_flags |= F_WAITIMSG;
	imsg_compose_event(env->sc_ievs[proc], type, peerid, pid, fd, data,
	    datalen);
a1564 2
SPLAY_GENERATE(sessiontree, session, s_nodes, session_cmp);

d1568 1
a1568 1
session_strstate(int state)
d1573 10
a1582 22
	CASE(S_NEW);
	CASE(S_CONNECTED);
	CASE(S_INIT);
	CASE(S_GREETED);
	CASE(S_TLS);
	CASE(S_AUTH_INIT);
	CASE(S_AUTH_USERNAME);
	CASE(S_AUTH_PASSWORD);
	CASE(S_AUTH_FINALIZE);
	CASE(S_RSET);
	CASE(S_HELO);
	CASE(S_MAIL_MFA);
	CASE(S_MAIL_QUEUE);
	CASE(S_MAIL);
	CASE(S_RCPT_MFA);
	CASE(S_RCPT);
	CASE(S_DATA);
	CASE(S_DATA_QUEUE);
	CASE(S_DATACONTENT);
	CASE(S_DONE);
	CASE(S_QUIT);
	CASE(S_CLOSE);
d1584 2
a1585 2
		snprintf(buf, sizeof(buf), "S_??? (%d)", state);
		return buf;
@


1.175
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.173 2012/10/28 08:46:26 eric Exp $	*/
d217 2
a218 1
		if ((len = __b64_pton(arg, (unsigned char *)buf, sizeof(buf) - 1)) == -1)
d271 2
a272 1
		if (__b64_pton(arg, (unsigned char *)a->user, sizeof(a->user) - 1) == -1)
d281 2
a282 1
		if (__b64_pton(arg, (unsigned char *)a->pass, sizeof(a->pass) - 1) == -1)
d293 1
a293 1
	
d318 3
a320 2
			log_debug("debug: smtp: AUTH in MAIL FROM command, skipping");
			continue;		
d332 2
a333 1
				session_respond(s, "503 5.5.4 Unsupported option %s", body);
d338 1
a338 1
	
d527 2
a528 1
	session_respond(s, "252 5.5.1 Cannot VRFY; try RCPT to attempt delivery");
d536 2
a537 1
	session_respond(s, "502 5.5.2 Sorry, we do not allow this operation");
d545 2
a546 1
	session_respond(s, "502 5.5.2 Sorry, we do not allow this operation");
d648 2
a649 1
	log_trace(TRACE_IO, "smtp: %p: %s %s", s, io_strevent(evt), io_strio(io));
d651 1
a651 1
	switch(evt) {
d697 2
a698 1
			session_respond(s, "500 5.0.0 Pipelining not supported");
d738 2
a739 2
		log_info("smtp-in: Received disconnect from session %016" PRIx64,
		    s->s_id);
d775 5
a779 4
		log_info("smtp-in: New session %016" PRIx64 " from host %s [%s]",
		   s->s_id,
		   s->s_hostname,
		   ss_to_text(&s->s_ss));
d806 1
a806 1
		strnvis(user, s->s_auth.user, sizeof user, VIS_WHITE | VIS_SAFE);
d841 4
a844 1
			/* XXX - we also want to support reading SIZE from MAIL parameters */
d884 2
a885 1
			session_respond(s, "%d 5.0.0 Recipient rejected: %s@@%s", ss->code,
d932 2
a933 1
		session_respond(s, "250 2.0.0 %08x Message accepted for delivery",
@


1.174
log
@Add a "kick counter" that gets incremented on each command, to detect
clients that don't do their best to do something useful, and just hog
the session.  When that kick counter reaches the limit, the client is
disconnected.  The counter is reset after the first HELO/EHLO command,
after tls is established, after a succesful authentication, and after
a message is accepted. It is decremented when a RCPT is accepted.

ok gilles@@
@
text
@d31 1
d34 1
d39 1
d315 1
a315 1
			log_debug("smtp: AUTH in MAIL FROM command, skipping");
d320 1
a320 1
			log_debug("smtp: BODY in MAIL FROM command");
d654 2
d694 1
d706 2
d722 2
d728 2
d734 2
d747 1
d765 4
d777 2
d795 1
d798 2
d801 3
a803 1
		} else
d805 1
d919 2
a920 2
		log_info("%08x: from=<%s%s%s>, size=%ld, nrcpts=%zu, proto=%s, "
		    "relay=%s [%s]",
d922 1
d928 1
a928 4
		    s->s_flags & F_EHLO ? "ESMTP" : "SMTP",
		    s->s_hostname,
		    ss_to_text(&s->s_ss));

d951 2
d999 1
a999 1
		log_debug("session_read: %i", s->s_state);
d1076 1
a1076 1
	log_debug("smtp: %p: deleting session: %s", s, reason);
d1156 1
a1156 1
	char	 buf[SMTP_LINE_MAX];
d1177 3
a1179 5
		log_info("%08x: from=<%s@@%s>, relay=%s [%s], stat=LocalError (%.*s)",
		    evpid_to_msgid(s->s_msg.id),
		    s->s_msg.sender.user, s->s_msg.sender.domain,
		    s->s_hostname, ss_to_text(&s->s_ss),
		    n, buf);
@


1.173
log
@Limit the number of messages that can be enqueued on a single SMTP
connection, and the number of recipients in each of them.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.172 2012/10/11 21:24:51 gilles Exp $	*/
d43 2
d651 1
d674 4
d690 4
d753 1
a753 1
			     &s->s_msg, sizeof(s->s_msg));
d774 1
a774 1
		if (s->s_flags & F_AUTHENTICATED)
d776 2
a777 1
		else
d813 1
d851 1
d907 1
d923 1
a923 1
	if (s->s_state != S_DATACONTENT)
d925 6
@


1.172
log
@- ssize_t -> size_t

spotted with clang, ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.171 2012/10/09 20:33:02 gilles Exp $	*/
d43 3
d426 5
d459 5
d892 1
@


1.171
log
@- allow a listen statement to impose tls on its clients;
- make listen statements impose authentication if 'auth' is specified and
	to make it optional if 'auth-optional' is specified;
- sync documentation accordingly

with ideas and input from beck@@ and halex@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.170 2012/10/07 15:46:38 chl Exp $	*/
d620 1
a620 1
	ssize_t		 len;
@


1.170
log
@convert iobuf_queue()'s to iobuf_fqueue(). (idea from gilles@@)
introduce iobuf_xinit() and iobuf_xfqueue(). (idea from eric@@)

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.169 2012/09/14 19:22:04 eric Exp $	*/
d402 15
@


1.169
log
@Remove s_ssl from the smtp session since it is duplicated in the io struct.
Change ssl_session_init to ssl_smtp_init and make it simpler:  only create
an SSL* from the SSL_CTX* passed as parameter, so it does not have to know
about the struct session itself.  Kill some dead prototypes while there.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.168 2012/08/25 10:23:12 gilles Exp $	*/
d1091 1
a1091 2
	iobuf_queue(&s->s_iobuf, buf, n);
	iobuf_queue(&s->s_iobuf, "\r\n", 2);
@


1.168
log
@- introduce struct stat_value
- statistics can now have a type (counter, timestamp, timeval, timespec and
  possibly others in the future)
- stat_increment() / stat_decrement() now take an increment/decrement value
  and are at the moment only of type counter
- stat_set() now takes a stat_value
- provide helpers to convert raw values to stat_value

ok eric@@, ok chl@@

while at it fix a rq_queue_dump() call using a bogus timestamp in scheduler
ramqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.167 2012/08/24 18:46:46 eric Exp $	*/
d603 1
d669 2
a670 2
			ssl_session_init(s);
			io_start_tls(io, s->s_ssl);
d694 2
d724 1
a724 1
			ssl_session_init(s);
d726 1
a726 1
			io_start_tls(&s->s_io, s->s_ssl);
d827 3
a829 3
			    SSL_get_cipher_version(s->s_ssl),
			    SSL_get_cipher_name(s->s_ssl),
			    SSL_get_cipher_bits(s->s_ssl, NULL));
d1013 1
a1013 1
	if (s->s_ssl) {
@


1.167
log
@When an smtp session fails and IMSG_QUEUE_REMOVE_MESSAGE is sent to the
queue, also notify the scheduler so it can rollback the current update.
Send only the msgid while there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.166 2012/08/19 14:16:58 chl Exp $	*/
d613 1
a613 1
			stat_increment("smtp.smtps");
d615 1
a615 1
			stat_increment("smtp.tls");
d697 1
a697 1
		stat_increment("smtp.tempfail");
d927 1
a927 1
	stat_increment("smtp.tempfail");
d950 1
a950 1
			stat_increment("smtp.tempfail");
d1013 1
a1013 1
				stat_decrement("smtp.smtps");
d1016 1
a1016 1
				stat_decrement("smtp.tls");
d1024 1
a1024 1
	stat_decrement("smtp.session");
d1133 1
a1133 1
		stat_increment("smtp.delays");
@


1.166
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.165 2012/08/18 18:18:23 gilles Exp $	*/
d994 2
d1004 2
a1005 1
	if (s->s_msg.id != 0 && s->s_state != S_DONE)
d1007 2
a1008 2
		    IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1, &s->s_msg,
		    sizeof(s->s_msg));
@


1.165
log
@- introduce stat_backend, an API for pluggable statistic backends
  > statistics are no longer static structures in shared memory
  > statistics are only set, smtpd never uses them in its logic
  > each statistic is a key/value where key can be any (dynamic) string
- convert all uses of the former API to use the new one
- implement stat_ramstat that keeps non-persistent stats in ram structure

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.164 2012/08/18 16:05:54 chl Exp $	*/
d79 1
a79 1
    enum imsg_type, u_int32_t, pid_t, int, void *, u_int16_t);
d1044 1
a1044 1
	 * do not return u_int64_t's
d1152 1
a1152 1
    u_int32_t peerid, pid_t pid, int fd, void *data, u_int16_t datalen)
@


1.164
log
@Disallow empty domain/address sent after HELO/EHLO command.

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.163 2012/08/10 11:05:55 eric Exp $	*/
d613 1
a613 1
			stat_increment(STATS_SMTP_SMTPS);
d615 1
a615 1
			stat_increment(STATS_SMTP_STARTTLS);
d697 1
a697 1
		env->stats->smtp.tempfail++;
d927 1
a927 1
	env->stats->smtp.tempfail++;
d950 1
a950 1
			env->stats->smtp.tempfail++;
a993 2
	size_t	resume;

d1010 1
a1010 1
				stat_decrement(STATS_SMTP_SMTPS);
d1013 1
a1013 1
				stat_decrement(STATS_SMTP_STARTTLS);
d1021 1
a1021 5
	resume = env->sc_maxconn * 95 / 100;
	if (stat_decrement(STATS_SMTP_SESSION) == resume) {
		log_warnx("re-enabling incoming connections");
		smtp_resume();
	}
d1032 3
d1130 1
a1130 1
		env->stats->smtp.delays++;
@


1.163
log
@Move mta and smtp specific defines into their own files.
Some formatting cleanups while there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.162 2012/05/08 11:52:57 eric Exp $	*/
d332 1
a332 1
	if (args == NULL) {
d355 1
a355 1
	if (args == NULL) {
@


1.162
log
@fix and re-enable connect notification to the mfa.
filtering now occurs before setting up ssl on smtps connections.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.161 2012/01/29 16:51:00 eric Exp $	*/
d42 7
@


1.161
log
@For some reason, all recipients are rejected if the msg field is not
initialized here. Fix it, but this requires further investigation.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.160 2012/01/29 15:33:08 eric Exp $	*/
d609 1
a609 1
		if (s->s_state == S_INIT) /* XXX improve this */
d611 3
a613 1
		session_pickup(s, NULL);
a685 3
	if (s == NULL)
		fatal("session_pickup: desynchronized");

a700 1
		s->s_state = S_INIT;
a702 7
		if (s->s_l->flags & F_SMTPS) {
			ssl_session_init(s);
			io_set_read(&s->s_io);
			io_start_tls(&s->s_io, s->s_ssl);
			return;
		}
#if 0
a705 2
#endif
		/* fallthrough */
a707 1
#if 0
d709 8
a716 2
			session_enter_state(s, S_CLOSE);
			session_respond(s, "%d Connection rejected", ss->code);
d719 1
a719 2
#endif
		log_debug("session_pickup: greeting client");
a723 4
	case S_TLS:
		session_enter_state(s, S_GREETED);
		break;

a737 2
		if (ss == NULL)
			fatalx("bad ss at S_HELO");
a765 2
		if (ss == NULL)
			fatalx("bad ss at S_MAIL_MFA");
a779 2
		if (ss == NULL)
			fatalx("bad ss at S_MAIL_QUEUE");
a784 2
		if (ss == NULL)
			fatalx("bad ss at S_RCPT_MFA");
a800 5

		/* log_debug("smtp: %p: new recipient <%s@@%s>", s,
		    ss->u.maddr.user,
		    ss->u.maddr.domain); */

@


1.160
log
@disable connection filter hook for now. fixes smtps.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.159 2012/01/29 11:37:32 eric Exp $	*/
d703 2
a711 2
		s->s_msg.session_id = s->s_id;
		s->s_msg.ss = s->s_ss;
@


1.159
log
@Rewrite io code in smtp and mta using the iobuf/ioev interface to have
a better separation between io and protocol logic.  As a side-effect,
it fixes a couple of long-standing issues in the io path, and
hopefully add fresh ones instead.  Kill client.c in the process.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.158 2012/01/27 00:01:04 gilles Exp $	*/
d609 2
d709 1
d715 2
d719 1
d725 1
@


1.158
log
@that log_debug is no longer needed
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.157 2012/01/26 23:59:28 gilles Exp $	*/
d7 1
d43 2
d66 1
a66 1
static void session_read(struct bufferevent *, void *);
a67 2
static void session_write(struct bufferevent *, void *);
static void session_error(struct bufferevent *, short event, void *);
a68 1
static char *session_readline(struct session *);
d444 1
a444 1
	s->s_flags |= F_QUIT;
a548 2
	log_debug("command: %s\targs: %s", cmd, args);

d593 87
d685 2
d689 1
d691 2
a692 2
		env->stats->smtp.tempfail++;
		s->s_flags |= F_QUIT;
d700 7
a724 3
		if (s->s_flags & F_WRITEONLY)
			fatalx("session_pickup: corrupt session");
		bufferevent_enable(s->s_bev, EV_READ);
d747 1
a747 1
			return;
d814 4
d857 1
a857 1
		log_info("%08x: from=<%s%s%s>, size=%ld, nrcpts=%zd, proto=%s, "
a876 11
}

void
session_init(struct listener *l, struct session *s)
{
	session_enter_state(s, S_CONNECTED);

	if (l->flags & F_SMTPS) {
		ssl_session_init(s);
		return;
	}
d878 1
a878 21
	session_bufferevent_new(s);
	session_pickup(s, NULL);
}

void
session_bufferevent_new(struct session *s)
{
	if (s->s_bev != NULL)
		fatalx("session_bufferevent_new: attempt to override existing "
		    "bufferevent");

	if (s->s_flags & F_WRITEONLY)
		fatalx("session_bufferevent_new: corrupt session");

	s->s_bev = bufferevent_new(s->s_fd, session_read, session_write,
	    session_error, s);
	if (s->s_bev == NULL)
		fatal("session_bufferevent_new");

	bufferevent_settimeout(s->s_bev, SMTPD_SESSION_TIMEOUT,
	    SMTPD_SESSION_TIMEOUT);
d882 1
a882 1
session_read(struct bufferevent *bev, void *p)
d884 1
a884 2
	struct session	*s = p;
	char		*line;
d886 2
a887 4
	for (;;) {
		line = session_readline(s);
		if (line == NULL)
			return;
d889 6
a894 6
		switch (s->s_state) {
		case S_AUTH_INIT:
			if (s->s_dstatus & DS_TEMPFAILURE)
				goto tempfail;
			session_rfc4954_auth_plain(s, line);
			break;
d896 6
a901 6
		case S_AUTH_USERNAME:
		case S_AUTH_PASSWORD:
			if (s->s_dstatus & DS_TEMPFAILURE)
				goto tempfail;
			session_rfc4954_auth_login(s, line);
			break;
d903 8
a910 11
		case S_GREETED:
		case S_HELO:
		case S_MAIL:
		case S_RCPT:
			if (s->s_dstatus & DS_TEMPFAILURE)
				goto tempfail;
			session_command(s, line);
			break;

		case S_DATACONTENT: {
			struct submit_status ss;
d912 2
d918 1
a918 1
				fatal("session_read: data truncation");
d920 5
a924 16
			if (env->filtermask & FILTER_DATALINE) {
				session_imsg(s, PROC_MFA, IMSG_MFA_DATALINE,
				    0, 0, -1, &ss, sizeof(ss));
				free(line);
				return;
			}
			else {
				/* no filtering, let's pretend that filtering
				 * succeeded ;-)
				 *
				 * -- gilles@@
				 */
				ss.code = 250;
				session_pickup(s, &ss);
			}
			break;
d926 1
d928 4
a931 3
		default:
			fatalx("session_read: unexpected state");
		}
a932 2
		free(line);
	}
d938 1
a938 2
	s->s_flags |= F_QUIT;
	free(line);
d959 1
a959 1
			s->s_flags |= F_QUIT;
a1000 84
static void
session_write(struct bufferevent *bev, void *p)
{
	struct session	*s = p;

	if (s->s_flags & F_WRITEONLY) {
		/*
		 * Finished writing to a session that is waiting for an IMSG
		 * response, therefore can't destroy session nor re-enable
		 * reading from it.
		 *
		 * If session_respond caller used F_QUIT to request session
		 * destroy after final write, then session will be destroyed
		 * in session_lookup.
		 *
		 * Reading from session will be re-enabled in session_pickup
		 * using another call to session_respond.
		 */
		return;
	} else if (s->s_flags & F_QUIT) {
		/*
		 * session_respond caller requested the session to be dropped.
		 */
		session_destroy(s);
	} else if (s->s_state == S_TLS) {
		/*
		 * Start the TLS conversation.
		 * Destroy the bufferevent as the SSL module re-creates it.
		 */
		bufferevent_free(s->s_bev);
		s->s_bev = NULL;
		ssl_session_init(s);
	} else {
		/*
		 * Common case of responding to client's request.
		 * Re-enable reading from session so that more commands can
		 * be processed.
		 */
		bufferevent_enable(s->s_bev, EV_READ);
	}
}

static void
session_error(struct bufferevent *bev, short event, void *p)
{
	struct session	*s = p;
	char		*ip = ss_to_text(&s->s_ss);

	if (event & EVBUFFER_READ) {
		if (event & EVBUFFER_TIMEOUT) {
			log_warnx("client %s read timeout", ip);
			env->stats->smtp.read_timeout++;
		} else if (event & EVBUFFER_EOF)
			env->stats->smtp.read_eof++;
		else if (event & EVBUFFER_ERROR) {
			log_warn("client %s read error", ip);
			env->stats->smtp.read_error++;
		}

		session_destroy(s);
		return;
	}

	if (event & EVBUFFER_WRITE) {
		if (event & EVBUFFER_TIMEOUT) {
			log_warnx("client %s write timeout", ip);
			env->stats->smtp.write_timeout++;
		} else if (event & EVBUFFER_EOF)
			env->stats->smtp.write_eof++;
		else if (event & EVBUFFER_ERROR) {
			log_warn("client %s write error", ip);
			env->stats->smtp.write_error++;
		}

		if (s->s_flags & F_WRITEONLY)
			s->s_flags |= F_QUIT;
		else
			session_destroy(s);
		return;
	}

	fatalx("session_error: unexpected error");
}

d1002 1
a1002 1
session_destroy(struct session *s)
d1004 1
a1004 1
	size_t resume;
d1006 1
a1006 1
	log_debug("session_destroy: killing client: %p", s);
d1008 2
a1009 2
	if (s->s_flags & F_WRITEONLY)
		fatalx("session_destroy: corrupt session");
d1019 8
a1026 7
	session_imsg(s, PROC_MFA, IMSG_MFA_CLOSE, 0, 0, -1, &s->s_msg,
	    sizeof(s->s_msg));

	ssl_session_destroy(s);

	if (s->s_bev != NULL)
		bufferevent_free(s->s_bev);
d1028 3
a1030 2
	if (s->s_fd != -1 && close(s->s_fd) == -1)
		fatal("session_destroy: close");
d1039 9
a1052 42
static char *
session_readline(struct session *s)
{
	char	*line, *line2;
	size_t	 nr;

	nr = EVBUFFER_LENGTH(s->s_bev->input);
	line = evbuffer_readln(s->s_bev->input, NULL, EVBUFFER_EOL_CRLF);
	if (line == NULL) {
		if (EVBUFFER_LENGTH(s->s_bev->input) > SMTP_LINE_MAX) {
			session_respond(s, "500 5.0.0 Line too long");
			env->stats->smtp.linetoolong++;
			s->s_flags |= F_QUIT;
		}
		return NULL;
	}
	nr -= EVBUFFER_LENGTH(s->s_bev->input);

	if (s->s_flags & F_WRITEONLY)
		fatalx("session_readline: corrupt session");

	if (nr > SMTP_LINE_MAX) {
		session_respond(s, "500 5.0.0 Line too long");
		env->stats->smtp.linetoolong++;
		s->s_flags |= F_QUIT;
		return NULL;
	}
	
	if ((s->s_state != S_DATACONTENT || strcmp(line, ".") == 0) &&
	    (line2 = evbuffer_readln(s->s_bev->input, NULL,
		EVBUFFER_EOL_CRLF)) != NULL) {
		session_respond(s, "500 5.0.0 Pipelining unsupported");
		env->stats->smtp.toofast++;
		s->s_flags |= F_QUIT;
		free(line);
		free(line2);
		return NULL;
	}

	return line;
}

d1086 1
a1086 2

	n = EVBUFFER_LENGTH(EVBUFFER_OUTPUT(s->s_bev));
d1089 1
a1089 3
	if (evbuffer_add_vprintf(EVBUFFER_OUTPUT(s->s_bev), fmt, ap) == -1 ||
	    evbuffer_add_printf(EVBUFFER_OUTPUT(s->s_bev), "\r\n") == -1)
		fatal("session_respond: evbuffer_add_vprintf failed");
d1091 4
d1096 4
a1099 1
	bufferevent_disable(s->s_bev, EV_READ);
d1105 1
a1105 1
	switch (EVBUFFER_DATA(EVBUFFER_OUTPUT(s->s_bev))[n]) {
d1112 1
a1112 2
		    (int)EVBUFFER_LENGTH(EVBUFFER_OUTPUT(s->s_bev)) - n - 2,
		    EVBUFFER_DATA(EVBUFFER_OUTPUT(s->s_bev)));
d1117 1
a1117 3
	if (EVBUFFER_LENGTH(EVBUFFER_OUTPUT(s->s_bev)) - n < 4)
		fatalx("session_respond: invalid response length");
	switch (EVBUFFER_DATA(EVBUFFER_OUTPUT(s->s_bev))[n + 3]) {
d1142 1
d1144 3
d1149 1
a1149 2
	} else
		bufferevent_enable(s->s_bev, EV_WRITE);
d1157 1
a1157 1
	bufferevent_enable(s->s_bev, EV_WRITE);
a1166 3
	if (s->s_flags & F_WRITEONLY)
		fatalx("session_imsg: corrupt session");

a1173 4
	 * Session flag F_WRITEONLY is needed to enforce this policy.
	 *
	 * F_WRITEONLY is cleared in session_lookup.
	 * Reading is re-enabled in session_pickup.
d1175 2
a1176 2
	s->s_flags |= F_WRITEONLY;
	bufferevent_disable(s->s_bev, EV_READ);
@


1.157
log
@in session_read_data() do NOT enable back read event otherwise it will
corrupt the session and cause a fatal.

reported by Roman Kravchuk, with this diff in OpenSMTPD survives again the
evil smtp_tester.py :-p
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.156 2012/01/26 23:18:08 gilles Exp $	*/
a1010 3
		if (s->s_flags & F_WRITEONLY)
			//s->s_flags |= F_QUIT;
			log_debug("session_error:EVBUFFER_READ while F_WRITEONLY");
@


1.156
log
@Do not call session_respond() AND session_imsg() from the same handler as
they are exclusive. In the quit handler, it will lead to a corrupted
session as the F_QUIT is set and session_respond() will kill the session
before session_imsg() is done.

For now, comment session_imsg(IMSG_MFA_QUIT) as we don't have filters
enabled anyways. The proper fix will be to have session_imsg() called
from the handler THEN upon return in smtp process do the session_respond()
call.

Fixes a segv reported by Roman Kravchuk. While at it, revert my last commit
in session_error() which was probably needed because of this bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.155 2012/01/21 19:50:30 gilles Exp $	*/
d917 1
a917 1
		goto end;
d922 1
a922 1
		goto end;
d939 1
a939 1
		goto end;
d948 1
a948 1
	if (fprintf(s->datafp, "%s\n", line) != (int)len + 1) {
a949 5
		goto end;
	}

end:
	bufferevent_enable(s->s_bev, EV_READ);
d1011 3
@


1.155
log
@in session_error(), do not call session_destroy() when the F_WRITEONLY
session flag is set, set F_QUIT instead.

fixes a "corrupted session" fatalx() that triggers when a client
disconnects after sending the end of message '.' but without waiting
for server to acknowledge.

reported by Roman Kravchuk <kravchuk.kp@@gmail.com> a while ago, could not
reproduce until today.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.154 2012/01/18 13:41:54 chl Exp $	*/
d446 1
d449 1
a449 1

d1016 1
a1016 4
		if (s->s_flags & F_WRITEONLY)
			s->s_flags |= F_QUIT;
		else
			session_destroy(s);
@


1.154
log
@Add new filters callbacks for:
- network events (CONNECT/CLOSE)
- commands (QUIT/RSET)

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.153 2012/01/13 14:27:55 eric Exp $	*/
d1015 4
a1018 1
		session_destroy(s);
@


1.153
log
@remove the status field from struct envelope, move it to the smtp
session, and cleanup the DS_* flags.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.152 2012/01/12 12:57:26 eric Exp $	*/
d373 1
a373 2
	session_enter_state(s, S_HELO);
	session_respond(s, "250 2.0.0 Reset state");
d375 2
a408 1
	s->s_msg.ss = s->s_ss;
d446 2
d608 9
d618 6
d643 5
d785 1
a785 1
	s->s_state = S_INIT;
d1058 3
d1264 2
a1265 1
	CASE(S_INVALID);
d1273 1
d1285 1
@


1.152
log
@alter line contents before writing it, rather than after...

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.151 2011/12/12 17:20:36 eric Exp $	*/
d598 1
a598 1
	    (s->s_msg.status & DS_TEMPFAILURE)) {
d731 1
a731 1
			s->s_msg.status |= DS_PERMFAILURE;
d806 1
a806 1
			if (s->s_msg.status & DS_TEMPFAILURE)
d813 1
a813 1
			if (s->s_msg.status & DS_TEMPFAILURE)
d822 1
a822 1
			if (s->s_msg.status & DS_TEMPFAILURE)
d879 1
a879 1
			s->s_msg.status |= DS_TEMPFAILURE;
d882 1
a882 1
		if (s->s_msg.status & DS_PERMFAILURE) {
d885 1
a885 1
		} else if (s->s_msg.status & DS_TEMPFAILURE) {
d898 1
a898 1
	if (s->s_msg.status & (DS_PERMFAILURE|DS_TEMPFAILURE))
d915 1
a915 1
		s->s_msg.status |= DS_PERMFAILURE;
d926 1
a926 1
		s->s_msg.status |= DS_TEMPFAILURE;
@


1.151
log
@add a session_enter_state() function to change the state of an smtp
session and allow those state changes to be traced (add traces flags
for upcoming changes while there).

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.150 2011/10/23 09:30:07 gilles Exp $	*/
a918 5
	if (fprintf(s->datafp, "%s\n", line) != (int)len + 1) {
		s->s_msg.status |= DS_TEMPFAILURE;
		goto end;
	}

d923 5
@


1.150
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.149 2011/10/03 19:20:51 gilles Exp $	*/
d74 4
d131 1
a131 1
	s->s_state = S_TLS;
d193 1
a193 1
			s->s_state = S_AUTH_INIT;
d197 1
a197 1
		s->s_state = S_AUTH_INIT;
d224 1
a224 1
		s->s_state = S_AUTH_FINALIZE;
d239 1
a239 1
	s->s_state = S_HELO;
d249 1
a249 1
		s->s_state = S_AUTH_USERNAME;
d258 1
a258 1
		s->s_state = S_AUTH_PASSWORD;
d267 1
a267 1
		s->s_state = S_AUTH_FINALIZE;
d282 1
a282 1
	s->s_state = S_HELO;
d300 1
a300 1
			log_debug("AUTH in MAIL FROM command, skipping");
d305 1
a305 1
			log_debug("BODY in MAIL FROM command");
a336 1
	s->s_state = S_HELO;
d338 1
a359 1
	s->s_state = S_HELO;
d363 1
d373 1
a373 1
	s->s_state = S_HELO;
a406 1
	s->s_state = S_MAIL_MFA;
d410 1
a410 2
	log_debug("session_rfc5321_mail_handler: sending notification to mfa");

d435 1
a435 1
	s->s_state = S_RCPT_MFA;
d446 1
d468 1
a468 1
	s->s_state = S_DATA_QUEUE;
d513 10
a606 2
		s->s_state = S_GREETED;
		log_debug("session_pickup: greeting client");
d608 1
d615 1
a615 1
		s->s_state = S_GREETED;
d623 1
a623 1
		s->s_state = S_HELO;
d630 1
a630 1
			s->s_state = S_GREETED;
d660 1
a660 1
			s->s_state = S_HELO;
d662 1
a662 1
			return;
d665 1
a665 1
		s->s_state = S_MAIL_QUEUE;
d675 1
a675 1
		s->s_state = S_MAIL;
d686 1
a686 1
				s->s_state = S_MAIL;
d688 1
a688 1
				s->s_state = S_RCPT;
d692 1
a692 1
			return;
d695 1
a695 1
		s->s_state = S_RCPT;
d703 1
a703 1
		s->s_state = S_DATACONTENT;
d750 1
a750 1
		s->s_state = S_HELO;
d884 1
a884 1
			s->s_state = S_HELO;
d892 1
a892 1
			s->s_state = S_DONE;
d1230 33
@


1.149
log
@- fix a segv caused by a deep recursion introduced with a recent quick-fix
  and triggering if clients sent a large number of DATA lines in one write
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.148 2011/09/28 18:19:10 gilles Exp $	*/
d326 2
a327 2
	if (strlcpy(s->s_msg.delivery.helo, args, sizeof(s->s_msg.delivery.helo))
	    >= sizeof(s->s_msg.delivery.helo)) {
d349 2
a350 2
	if (strlcpy(s->s_msg.delivery.helo, args, sizeof(s->s_msg.delivery.helo))
	    >= sizeof(s->s_msg.delivery.helo)) {
d396 1
a396 1
	if (! session_set_mailaddr(&s->s_msg.delivery.from, args)) {
d404 2
a405 2
	s->s_msg.delivery.id = 0;
	s->s_msg.delivery.ss = s->s_ss;
d427 1
a427 1
	if (! session_set_mailaddr(&s->s_msg.delivery.rcpt_orig, args)) {
d585 1
a585 1
	    (s->s_msg.delivery.status & DS_TEMPFAILURE)) {
d625 1
a625 1
		    env->sc_hostname, s->s_msg.delivery.helo, ss_to_text(&s->s_ss));
d654 1
a654 1
		s->s_msg.delivery.from = ss->u.maddr;
d678 2
a679 2
			    s->s_msg.delivery.rcpt_orig.user,
			    s->s_msg.delivery.rcpt_orig.domain);
d685 1
a685 1
		s->s_msg.delivery.rcpt = ss->u.maddr;
d696 1
a696 1
		    s->s_msg.delivery.helo, s->s_hostname, ss_to_text(&s->s_ss));
d699 1
a699 1
		    (u_int32_t)(s->s_msg.delivery.id >> 32));
d709 2
a710 2
			    s->s_msg.delivery.rcpt_orig.user,
			    s->s_msg.delivery.rcpt_orig.domain);
d719 1
a719 1
			s->s_msg.delivery.status |= DS_PERMFAILURE;
d725 1
a725 1
		    (u_int32_t)(s->s_msg.delivery.id >> 32));
d728 4
a731 4
		    (u_int32_t)(s->s_msg.delivery.id >> 32),
		    s->s_msg.delivery.from.user,
		    s->s_msg.delivery.from.user[0] == '\0' ? "" : "@@",
		    s->s_msg.delivery.from.domain,
d739 1
a739 1
		s->s_msg.delivery.id = 0;
d794 1
a794 1
			if (s->s_msg.delivery.status & DS_TEMPFAILURE)
d801 1
a801 1
			if (s->s_msg.delivery.status & DS_TEMPFAILURE)
d810 1
a810 1
			if (s->s_msg.delivery.status & DS_TEMPFAILURE)
d867 1
a867 1
			s->s_msg.delivery.status |= DS_TEMPFAILURE;
d870 1
a870 1
		if (s->s_msg.delivery.status & DS_PERMFAILURE) {
d873 1
a873 1
		} else if (s->s_msg.delivery.status & DS_TEMPFAILURE) {
d886 1
a886 1
	if (s->s_msg.delivery.status & (DS_PERMFAILURE|DS_TEMPFAILURE))
d903 1
a903 1
		s->s_msg.delivery.status |= DS_PERMFAILURE;
d908 1
a908 1
		s->s_msg.delivery.status |= DS_TEMPFAILURE;
d1019 1
a1019 1
	if (s->s_msg.delivery.id != 0 && s->s_state != S_DONE)
d1138 2
a1139 2
		    (u_int32_t)(s->s_msg.delivery.id >> 32),
		    s->s_msg.delivery.from.user, s->s_msg.delivery.from.domain,
@


1.148
log
@removing annoying debug log
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.147 2011/09/12 20:47:15 gilles Exp $	*/
a822 1
			free(line);
d824 1
a824 1
			if (env->filtermask & FILTER_DATALINE)
d827 3
d839 1
a839 1
			return;
a919 1
	session_read(s->s_bev, s);
@


1.147
log
@- introduce filtermask in struct smtpd
- do not forward lines to mfa when FILTER_DATALINE is not set in filtermask

prevents smtpd from handling mails slowly while I'm hacking on filters
support
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.146 2011/09/01 19:56:49 eric Exp $	*/
d829 5
a833 1
				log_debug("no filter");
@


1.146
log
@Introduce a small set of functions to manage stat counters in a
simpler and hopefully saner way.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.145 2011/09/01 09:42:15 chl Exp $	*/
a822 4

			session_imsg(s, PROC_MFA, IMSG_MFA_DATALINE,
			    0, 0, -1, &ss, sizeof(ss));

d825 8
@


1.145
log
@- if no filter is setup, do not overwrite the data line with filtmsg buffer
- remove annoying debug lines
- disable back filters at smtpd.conf level

committing on behalf of gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.144 2011/08/31 18:56:30 gilles Exp $	*/
a1022 2
	env->stats->smtp.sessions_active--;

d1025 1
a1025 1
	if (env->stats->smtp.sessions_active == resume) {
@


1.144
log
@add support for per-line DATA callbacks, this allows filters to take their
decisions *while* the message is being received by the client.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.143 2011/08/27 22:32:41 gilles Exp $	*/
a591 1
	log_debug("state: %d", s->s_state);
a717 1
		log_debug("line: %s\n", ss->u.dataline);
@


1.143
log
@initial support for a session-time filtering API

currently only HELO/EHLO, MAIL, RCPT are supported, however ... I have
voluntarily disabled filters at smtpd.conf level so people don't play with
it until the API has stabilized a bit

discussed with several people in private, no one opposed the feature
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.142 2011/05/16 21:05:52 gilles Exp $	*/
d592 1
d718 7
d817 16
a832 3
		case S_DATACONTENT:
			session_read_data(s, line);
			break;
d874 1
a874 1
		return;
d879 1
a879 1
		return;
d896 1
a896 1
		return;
d901 1
a901 1
		return;
d909 4
@


1.142
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.141 2011/05/01 12:57:11 eric Exp $	*/
d332 1
d336 2
a337 3
	session_respond(s, "250 %s Hello %s [%s], pleased to meet you",
	    env->sc_hostname, args, ss_to_text(&s->s_ss));

d355 1
d361 2
a362 18
	session_respond(s, "250-%s Hello %s [%s], pleased to meet you",
	    env->sc_hostname, args, ss_to_text(&s->s_ss));

	/* unconditionnal extensions go first */
	session_respond(s, "250-8BITMIME");
	session_respond(s, "250-ENHANCEDSTATUSCODES");

	/* XXX - we also want to support reading SIZE from MAIL parameters */
	session_respond(s, "250-SIZE %zu", env->sc_maxsize);

	if (ADVERTISE_TLS(s))
		session_respond(s, "250-STARTTLS");

	if (ADVERTISE_AUTH(s))
		session_respond(s, "250-AUTH PLAIN LOGIN");

	session_respond(s, "250 HELP");

a403 1
	s->s_msg.session_id = s->s_id;
a433 1

d442 1
a443 3

	s->s_flags |= F_QUIT;

d614 30
a852 1

a1049 1

@


1.141
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.140 2011/04/17 13:36:07 gilles Exp $	*/
d70 1
a70 1
static int session_set_path(struct path *, char *);
d326 2
a327 2
	if (strlcpy(s->s_msg.session_helo, args, sizeof(s->s_msg.session_helo))
	    >= sizeof(s->s_msg.session_helo)) {
d349 2
a350 2
	if (strlcpy(s->s_msg.session_helo, args, sizeof(s->s_msg.session_helo))
	    >= sizeof(s->s_msg.session_helo)) {
d411 1
a411 1
	if (! session_set_path(&s->s_msg.sender, args)) {
a418 1
	s->s_msg.id = s->s_id;
d420 2
a421 1
	s->s_msg.session_ss = s->s_ss;
d443 1
a443 1
	if (! session_set_path(&s->s_msg.session_rcpt, args)) {
d604 1
a604 1
	    (s->s_msg.status & S_MESSAGE_TEMPFAILURE)) {
d643 1
a643 1
		s->s_msg.sender = ss->u.path;
d667 2
a668 1
			    s->s_msg.session_rcpt.user, s->s_msg.session_rcpt.domain);
d674 1
a674 1
		s->s_msg.recipient = ss->u.path;
d685 1
a685 1
		    s->s_msg.session_helo, s->s_hostname, ss_to_text(&s->s_ss));
d688 1
a688 1
		    (u_int32_t)(s->s_msg.evpid >> 32));
d698 2
a699 2
			    s->s_msg.session_rcpt.user,
			    s->s_msg.session_rcpt.domain);
d708 1
a708 1
		    (u_int32_t)(s->s_msg.evpid >> 32));
d711 4
a714 4
		    (u_int32_t)(s->s_msg.evpid >> 32),
		    s->s_msg.sender.user,
		    s->s_msg.sender.user[0] == '\0' ? "" : "@@",
		    s->s_msg.sender.domain,
d722 1
a722 1
		s->s_msg.evpid = 0;
d777 1
a777 1
			if (s->s_msg.status & S_MESSAGE_TEMPFAILURE)
d784 1
a784 1
			if (s->s_msg.status & S_MESSAGE_TEMPFAILURE)
d793 1
a793 1
			if (s->s_msg.status & S_MESSAGE_TEMPFAILURE)
d827 1
a827 1
			s->s_msg.status |= S_MESSAGE_TEMPFAILURE;
d830 1
a830 1
		if (s->s_msg.status & S_MESSAGE_PERMFAILURE) {
d833 1
a833 1
		} else if (s->s_msg.status & S_MESSAGE_TEMPFAILURE) {
d847 1
a847 1
	if (s->s_msg.status & (S_MESSAGE_PERMFAILURE|S_MESSAGE_TEMPFAILURE))
d864 1
a864 1
		s->s_msg.status |= S_MESSAGE_PERMFAILURE;
d869 1
a869 1
		s->s_msg.status |= S_MESSAGE_TEMPFAILURE;
d977 1
a977 1
	if (s->s_msg.evpid != 0 && s->s_state != S_DONE)
d1063 1
a1063 1
session_set_path(struct path *path, char *line)
d1072 1
a1072 1
	return recipient_to_path(path, line + 1);
d1099 2
a1100 2
		    (u_int32_t)(s->s_msg.evpid >> 32),
		    s->s_msg.sender.user, s->s_msg.sender.domain,
@


1.140
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.139 2011/04/15 17:01:05 gilles Exp $	*/
d336 1
a336 1
	    s->s_env->sc_hostname, args, ss_to_text(&s->s_ss));
d361 1
a361 1
	    s->s_env->sc_hostname, args, ss_to_text(&s->s_ss));
d368 1
a368 1
	session_respond(s, "250-SIZE %zu", s->s_env->sc_maxsize);
d459 1
a459 1
	session_respond(s, "221 2.0.0 %s Closing connection", s->s_env->sc_hostname);
d606 1
a606 1
		s->s_env->stats->smtp.tempfail++;
d615 1
a615 1
		session_respond(s, SMTPD_BANNER, s->s_env->sc_hostname);
d686 1
a686 1
		    s->s_env->sc_hostname, s->s_flags & F_EHLO ? "E" : "",
d811 1
a811 1
	s->s_env->stats->smtp.tempfail++;
d835 1
a835 1
			s->s_env->stats->smtp.tempfail++;
d862 1
a862 1
	    datalen + len + 1 > s->s_env->sc_maxsize) {
d930 1
a930 1
			s->s_env->stats->smtp.read_timeout++;
d932 1
a932 1
			s->s_env->stats->smtp.read_eof++;
d935 1
a935 1
			s->s_env->stats->smtp.read_error++;
d945 1
a945 1
			s->s_env->stats->smtp.write_timeout++;
d947 1
a947 1
			s->s_env->stats->smtp.write_eof++;
d950 1
a950 1
			s->s_env->stats->smtp.write_error++;
d977 1
a977 1
		imsg_compose_event(s->s_env->sc_ievs[PROC_QUEUE],
d989 1
a989 1
	s->s_env->stats->smtp.sessions_active--;
d992 2
a993 2
	resume = s->s_env->sc_maxconn * 95 / 100;
	if (s->s_env->stats->smtp.sessions_active == resume) {
d995 1
a995 1
		smtp_resume(s->s_env);
d998 1
a998 1
	SPLAY_REMOVE(sessiontree, &s->s_env->sc_sessions, s);
d1014 1
a1014 1
			s->s_env->stats->smtp.linetoolong++;
d1026 1
a1026 1
		s->s_env->stats->smtp.linetoolong++;
d1035 1
a1035 1
		s->s_env->stats->smtp.toofast++;
d1134 1
a1134 1
		s->s_env->stats->smtp.delays++;
d1173 1
a1173 1
	imsg_compose_event(s->s_env->sc_ievs[proc], type, peerid, pid, fd, data,
@


1.139
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.138 2010/11/28 14:35:58 gilles Exp $	*/
d42 31
a72 32
int	 	 session_rfc5321_helo_handler(struct session *, char *);
int		 session_rfc5321_ehlo_handler(struct session *, char *);
int		 session_rfc5321_rset_handler(struct session *, char *);
int		 session_rfc5321_noop_handler(struct session *, char *);
int		 session_rfc5321_data_handler(struct session *, char *);
int		 session_rfc5321_mail_handler(struct session *, char *);
int		 session_rfc5321_rcpt_handler(struct session *, char *);
int		 session_rfc5321_vrfy_handler(struct session *, char *);
int		 session_rfc5321_expn_handler(struct session *, char *);
int		 session_rfc5321_turn_handler(struct session *, char *);
int		 session_rfc5321_help_handler(struct session *, char *);
int		 session_rfc5321_quit_handler(struct session *, char *);
int		 session_rfc5321_none_handler(struct session *, char *);

int		 session_rfc1652_mail_handler(struct session *, char *);

int		 session_rfc3207_stls_handler(struct session *, char *);

int		 session_rfc4954_auth_handler(struct session *, char *);
void		 session_rfc4954_auth_plain(struct session *, char *);
void		 session_rfc4954_auth_login(struct session *, char *);

void		 session_read(struct bufferevent *, void *);
void		 session_read_data(struct session *, char *);
void		 session_write(struct bufferevent *, void *);
void		 session_error(struct bufferevent *, short event, void *);
void		 session_command(struct session *, char *);
char		*session_readline(struct session *);
void		 session_respond_delayed(int, short, void *);
int		 session_set_path(struct path *, char *);
void		 session_imsg(struct session *, enum smtp_proc_type,
		     enum imsg_type, u_int32_t, pid_t, int, void *, u_int16_t);
d106 1
a106 1
int
d133 1
a133 1
int
d179 1
a179 1
void
d238 1
a238 1
void
d281 1
a281 1
int
d318 1
a318 1
int
d341 1
a341 1
int
d381 1
a381 1
int
d390 1
a390 1
int
d398 1
a398 1
int
d430 1
a430 1
int
d456 1
a456 1
int
d466 1
a466 1
int
d492 1
a492 1
int
d500 1
a500 1
int
d508 1
a508 1
int
d516 1
a516 1
int
d528 1
a528 1
void
d763 1
a763 1
void
d816 1
a816 1
void
d879 1
a879 1
void
d921 1
a921 1
void
d1003 1
a1003 1
char *
d1061 1
a1061 1
int
d1141 1
a1141 1
void
d1152 1
a1152 1
void
@


1.138
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.137 2010/11/28 13:56:43 gilles Exp $	*/
d686 1
a686 1
		fprintf(s->datafp, "\tby %s (OpenSMTPD) with %sSMTP id %s",
d688 1
a688 1
		    s->s_msg.message_id);
d707 3
a709 3
		session_respond(s, "250 2.0.0 %s Message accepted for delivery",
		    s->s_msg.message_id);
		log_info("%s: from=<%s%s%s>, size=%ld, nrcpts=%zd, proto=%s, "
d711 1
a711 1
		    s->s_msg.message_id,
d722 1
a722 2
		s->s_msg.message_id[0] = '\0';
		s->s_msg.message_uid[0] = '\0';
d977 1
a977 1
	if (s->s_msg.message_id[0] != '\0' && s->s_state != S_DONE)
d1098 2
a1099 2
		log_info("%s: from=<%s@@%s>, relay=%s [%s], stat=LocalError (%.*s)",
		    s->s_msg.message_id[0] ? s->s_msg.message_id : "(none)",
@


1.137
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.136 2010/10/09 22:05:35 gilles Exp $	*/
a27 3
#include <arpa/inet.h>

#include <openssl/ssl.h>
a29 1
#include <errno.h>
a31 2
#include <pwd.h>
#include <regex.h>
a34 1
#include <string.h>
d36 2
@


1.136
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.132 2010/04/24 19:16:11 chl Exp $	*/
d35 1
d45 1
@


1.135
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.133 2010/05/31 23:38:56 jacekm Exp $	*/
a43 1
#include "queue_backend.h"
d427 2
a452 2
	s->s_msg.queue_id = s->queue_id;

d490 2
a491 2
	session_imsg(s, PROC_QUEUE, IMSG_QUEUE_OPEN, s->s_id, 0, -1,
	    &s->queue_id, sizeof s->queue_id);
d602 1
a602 1
session_pickup(struct session *s)
d607 2
a608 1
	if (s->s_msg.status & S_MESSAGE_TEMPFAILURE) {
d638 3
a640 1
		if (s->s_msg.status & S_MESSAGE_PERMFAILURE) {
d642 1
a642 1
			session_respond(s, "530 Sender rejected");
d645 1
d647 4
a650 2
		session_imsg(s, PROC_QUEUE, IMSG_QUEUE_CREATE, s->s_id, 0, -1,
		    NULL, 0);
d654 2
d657 1
a657 1
		session_respond(s, "250 2.1.0 Sender ok");
d661 2
d664 1
a664 1
		if (s->s_msg.status & S_MESSAGE_PERMFAILURE) {
d670 1
a670 1
			session_respond(s, "530 5.0.0 Recipient rejected: %s@@%s",
d674 2
d677 3
a679 2
		s->s_state = S_RCPT;
		session_respond(s, "250 2.0.0 Recipient ok");
d691 1
a691 1
		    queue_be_decode(s->content_id));
d710 14
a723 16
		if (s->s_msg.status & S_MESSAGE_PERMFAILURE)
			session_respond(s, "554 5.4.6 Routing loop detected");
		else {
			session_respond(s, "250 2.0.0 %s Message accepted for delivery",
			    queue_be_decode(s->content_id));
			log_info("%s: from=%s%s%s, size=%ld, nrcpts=%zd, "
			    "relay=%s [%s]",
			    queue_be_decode(s->content_id),
			    s->s_msg.sender.user,
			    s->s_msg.sender.user[0] == '\0' ? "" : "@@",
			    s->s_msg.sender.domain,
			    s->s_datalen,
			    s->rcptcount,
			    s->s_hostname,
			    ss_to_text(&s->s_ss));
		}
d725 2
a726 1
		s->content_id = 0;
d746 1
a746 1
	session_pickup(s);
d830 1
a830 1
		if (fclose(s->datafp) == EOF)
d842 2
a843 2
			session_imsg(s, PROC_QUEUE, IMSG_QUEUE_CLOSE,
			    s->s_id, 0, -1, &s->queue_id, sizeof s->queue_id);
d981 1
a981 2
	if (s->content_id && s->s_state != S_DONE) {
		log_debug("%s: deleting queue session", __func__);
d983 2
a984 3
		    IMSG_QUEUE_DELETE, 0, 0, -1, &s->queue_id,
		    sizeof s->queue_id);
	}
d1004 1
d1102 3
a1104 4
		log_info("(none): from=<%s%s%s>, relay=%s [%s], stat=LocalError (%.*s)",
		    s->s_msg.sender.user,
		    s->s_msg.sender.user[0] == '\0' ? "" : "@@",
		    s->s_msg.sender.domain,
@


1.134
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.132 2010/04/24 19:16:11 chl Exp $	*/
d44 1
a427 2
	log_debug("session_rfc5321_mail_handler: sending notification to mfa");

d452 2
d491 2
a492 2
	session_imsg(s, PROC_QUEUE, IMSG_QUEUE_MESSAGE_FILE, 0, 0, -1,
	    &s->s_msg, sizeof(s->s_msg));
d603 1
a603 1
session_pickup(struct session *s, struct submit_status *ss)
d608 1
a608 2
	if ((ss != NULL && ss->code == 421) ||
	    (s->s_msg.status & S_MESSAGE_TEMPFAILURE)) {
d638 1
a638 3
		if (ss == NULL)
			fatalx("bad ss at S_MAIL_MFA");
		if (ss->code != 250) {
d640 1
a640 1
			session_respond(s, "%d Sender rejected", ss->code);
a642 1

d644 2
a645 4
		s->s_msg.sender = ss->u.path;

		session_imsg(s, PROC_QUEUE, IMSG_QUEUE_CREATE_MESSAGE, 0, 0, -1,
		    &s->s_msg, sizeof(s->s_msg));
a648 2
		if (ss == NULL)
			fatalx("bad ss at S_MAIL_QUEUE");
d650 1
a650 1
		session_respond(s, "%d 2.1.0 Sender ok", ss->code);
a653 2
		if (ss == NULL)
			fatalx("bad ss at S_RCPT_MFA");
d655 1
a655 1
		if (ss->code != 250) {
d661 1
a661 1
			session_respond(s, "%d 5.0.0 Recipient rejected: %s@@%s", ss->code,
d665 1
a665 1

d667 1
a667 4
		s->rcptcount++;
		s->s_msg.recipient = ss->u.path;

		session_respond(s, "%d 2.0.0 Recipient ok", ss->code);
d679 1
a679 1
		    s->s_msg.message_id);
d698 16
a713 14
		session_respond(s, "250 2.0.0 %s Message accepted for delivery",
		    s->s_msg.message_id);
		log_info("%s: from=<%s%s%s>, size=%ld, nrcpts=%zd, proto=%s, "
		    "relay=%s [%s]",
		    s->s_msg.message_id,
		    s->s_msg.sender.user,
		    s->s_msg.sender.user[0] == '\0' ? "" : "@@",
		    s->s_msg.sender.domain,
		    s->s_datalen,
		    s->rcptcount,
		    s->s_flags & F_EHLO ? "ESMTP" : "SMTP",
		    s->s_hostname,
		    ss_to_text(&s->s_ss));

d715 1
a715 2
		s->s_msg.message_id[0] = '\0';
		s->s_msg.message_uid[0] = '\0';
d735 1
a735 1
	session_pickup(s, NULL);
d819 1
a819 1
		if (! safe_fclose(s->datafp))
d831 2
a832 2
			session_imsg(s, PROC_QUEUE, IMSG_QUEUE_COMMIT_MESSAGE,
			    0, 0, -1, &s->s_msg, sizeof(s->s_msg));
d970 2
a971 1
	if (s->s_msg.message_id[0] != '\0' && s->s_state != S_DONE)
d973 3
a975 2
		    IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1, &s->s_msg,
		    sizeof(s->s_msg));
a994 1
	bzero(s, sizeof(*s));
d1092 4
a1095 3
		log_info("%s: from=<%s@@%s>, relay=%s [%s], stat=LocalError (%.*s)",
		    s->s_msg.message_id[0] ? s->s_msg.message_id : "(none)",
		    s->s_msg.sender.user, s->s_msg.sender.domain,
@


1.133
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@a43 1
#include "queue_backend.h"
d427 2
a452 2
	s->s_msg.queue_id = s->queue_id;

d490 2
a491 2
	session_imsg(s, PROC_QUEUE, IMSG_QUEUE_OPEN, s->s_id, 0, -1,
	    &s->queue_id, sizeof s->queue_id);
d602 1
a602 1
session_pickup(struct session *s)
d607 2
a608 1
	if (s->s_msg.status & S_MESSAGE_TEMPFAILURE) {
d638 3
a640 1
		if (s->s_msg.status & S_MESSAGE_PERMFAILURE) {
d642 1
a642 1
			session_respond(s, "530 Sender rejected");
d645 1
d647 4
a650 2
		session_imsg(s, PROC_QUEUE, IMSG_QUEUE_CREATE, s->s_id, 0, -1,
		    NULL, 0);
d654 2
d657 1
a657 1
		session_respond(s, "250 2.1.0 Sender ok");
d661 2
d664 1
a664 1
		if (s->s_msg.status & S_MESSAGE_PERMFAILURE) {
d670 1
a670 1
			session_respond(s, "530 5.0.0 Recipient rejected: %s@@%s",
d674 2
d677 3
a679 2
		s->s_state = S_RCPT;
		session_respond(s, "250 2.0.0 Recipient ok");
d691 1
a691 1
		    queue_be_decode(s->content_id));
d710 14
a723 16
		if (s->s_msg.status & S_MESSAGE_PERMFAILURE)
			session_respond(s, "554 5.4.6 Routing loop detected");
		else {
			session_respond(s, "250 2.0.0 %s Message accepted for delivery",
			    queue_be_decode(s->content_id));
			log_info("%s: from=%s%s%s, size=%ld, nrcpts=%zd, "
			    "relay=%s [%s]",
			    queue_be_decode(s->content_id),
			    s->s_msg.sender.user,
			    s->s_msg.sender.user[0] == '\0' ? "" : "@@",
			    s->s_msg.sender.domain,
			    s->s_datalen,
			    s->rcptcount,
			    s->s_hostname,
			    ss_to_text(&s->s_ss));
		}
d725 2
a726 1
		s->content_id = 0;
d746 1
a746 1
	session_pickup(s);
d830 1
a830 1
		if (fclose(s->datafp) == EOF)
d842 2
a843 2
			session_imsg(s, PROC_QUEUE, IMSG_QUEUE_CLOSE,
			    s->s_id, 0, -1, &s->queue_id, sizeof s->queue_id);
d981 1
a981 2
	if (s->content_id && s->s_state != S_DONE) {
		log_debug("%s: deleting queue session", __func__);
d983 2
a984 3
		    IMSG_QUEUE_DELETE, 0, 0, -1, &s->queue_id,
		    sizeof s->queue_id);
	}
d1004 1
d1102 3
a1104 4
		log_info("(none): from=<%s%s%s>, relay=%s [%s], stat=LocalError (%.*s)",
		    s->s_msg.sender.user,
		    s->s_msg.sender.user[0] == '\0' ? "" : "@@",
		    s->s_msg.sender.domain,
@


1.132
log
@fix format string

while there, print SIZE unconditonnally (prompted by gilles@@)

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.131 2010/04/21 20:32:57 gilles Exp $	*/
d44 1
a427 2
	log_debug("session_rfc5321_mail_handler: sending notification to mfa");

d452 2
d491 2
a492 2
	session_imsg(s, PROC_QUEUE, IMSG_QUEUE_MESSAGE_FILE, 0, 0, -1,
	    &s->s_msg, sizeof(s->s_msg));
d603 1
a603 1
session_pickup(struct session *s, struct submit_status *ss)
d608 1
a608 2
	if ((ss != NULL && ss->code == 421) ||
	    (s->s_msg.status & S_MESSAGE_TEMPFAILURE)) {
d638 1
a638 3
		if (ss == NULL)
			fatalx("bad ss at S_MAIL_MFA");
		if (ss->code != 250) {
d640 1
a640 1
			session_respond(s, "%d Sender rejected", ss->code);
a642 1

d644 2
a645 4
		s->s_msg.sender = ss->u.path;

		session_imsg(s, PROC_QUEUE, IMSG_QUEUE_CREATE_MESSAGE, 0, 0, -1,
		    &s->s_msg, sizeof(s->s_msg));
a648 2
		if (ss == NULL)
			fatalx("bad ss at S_MAIL_QUEUE");
d650 1
a650 1
		session_respond(s, "%d 2.1.0 Sender ok", ss->code);
a653 2
		if (ss == NULL)
			fatalx("bad ss at S_RCPT_MFA");
d655 1
a655 1
		if (ss->code != 250) {
d661 1
a661 1
			session_respond(s, "%d 5.0.0 Recipient rejected: %s@@%s", ss->code,
d665 1
a665 1

d667 1
a667 4
		s->rcptcount++;
		s->s_msg.recipient = ss->u.path;

		session_respond(s, "%d 2.0.0 Recipient ok", ss->code);
d679 1
a679 1
		    s->s_msg.message_id);
d698 16
a713 14
		session_respond(s, "250 2.0.0 %s Message accepted for delivery",
		    s->s_msg.message_id);
		log_info("%s: from=<%s%s%s>, size=%ld, nrcpts=%zd, proto=%s, "
		    "relay=%s [%s]",
		    s->s_msg.message_id,
		    s->s_msg.sender.user,
		    s->s_msg.sender.user[0] == '\0' ? "" : "@@",
		    s->s_msg.sender.domain,
		    s->s_datalen,
		    s->rcptcount,
		    s->s_flags & F_EHLO ? "ESMTP" : "SMTP",
		    s->s_hostname,
		    ss_to_text(&s->s_ss));

d715 1
a715 2
		s->s_msg.message_id[0] = '\0';
		s->s_msg.message_uid[0] = '\0';
d735 1
a735 1
	session_pickup(s, NULL);
d819 1
a819 1
		if (! safe_fclose(s->datafp))
d831 2
a832 2
			session_imsg(s, PROC_QUEUE, IMSG_QUEUE_COMMIT_MESSAGE,
			    0, 0, -1, &s->s_msg, sizeof(s->s_msg));
d970 2
a971 1
	if (s->s_msg.message_id[0] != '\0' && s->s_state != S_DONE)
d973 3
a975 2
		    IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1, &s->s_msg,
		    sizeof(s->s_msg));
a994 1
	bzero(s, sizeof(*s));
d1092 4
a1095 3
		log_info("%s: from=<%s@@%s>, relay=%s [%s], stat=LocalError (%.*s)",
		    s->s_msg.message_id[0] ? s->s_msg.message_id : "(none)",
		    s->s_msg.sender.user, s->s_msg.sender.domain,
@


1.131
log
@my evbuffer_readln_crlf() hack can be killed now that nicm@@ has brought us
an update to libevent that ships with evbuffer_readln(). beers for nicm@@ !
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.130 2010/04/19 10:26:40 gilles Exp $	*/
d372 1
a372 2
	if (s->s_env->sc_maxsize < SIZE_MAX)
		session_respond(s, "250-SIZE %lu", s->s_env->sc_maxsize);
@


1.130
log
@initial support for ENHANCEDSTATUSCODES, has been sitting in my tree for
a month or so
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.129 2010/04/19 10:12:48 gilles Exp $	*/
a76 1
char		*evbuffer_readln_crlf(struct evbuffer *);
d1016 1
a1016 1
	line = evbuffer_readln_crlf(s->s_bev->input);
d1038 2
a1039 1
	    (line2 = evbuffer_readln_crlf(s->s_bev->input)) != NULL) {
a1181 33

char *
evbuffer_readln_crlf(struct evbuffer *buffer)
{
        u_char *data = EVBUFFER_DATA(buffer);
        size_t len = EVBUFFER_LENGTH(buffer);
        char *line;
        unsigned int i, j;

        for (i = 0; i < len; ++i) {
                if (data[i] == '\n')
                        break;
        }

        if (i == len)
                return NULL;

        j = i;
        if (i != 0 && data[i - 1] == '\r')
                --j;

        line = calloc(j + 1, 1);
        if (line == NULL)
                fatal("calloc");

        if (j != 0)
                memcpy(line, data, j);

	evbuffer_drain(buffer, i + 1);

        return (line);
}

@


1.129
log
@basic support for SIZE extension, has been sitting in my tree for a month
or so ...

okayd by jacekm@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.128 2009/12/31 15:37:55 gilles Exp $	*/
d292 1
a292 1
		session_respond(s, "503 Polite people say HELO first");
d314 1
a314 1
				session_respond(s, "503 Invalid BODY");
d367 2
d370 1
d391 1
a391 1
	session_respond(s, "250 Reset state");
d399 1
a399 1
	session_respond(s, "250 OK");
d408 1
a408 1
		session_respond(s, "503 Polite people say HELO first");
d413 1
a413 1
		session_respond(s, "503 Sender already specified");
d419 1
a419 1
		session_respond(s, "553 Sender address syntax error");
d440 1
a440 1
		session_respond(s, "503 Polite people say HELO first");
d445 1
a445 1
		session_respond(s, "503 Need MAIL before RCPT");
d451 1
a451 1
		session_respond(s, "553 Recipient address syntax error");
d465 1
a465 1
	session_respond(s, "221 %s Closing connection", s->s_env->sc_hostname);
d476 1
a476 1
		session_respond(s, "503 Polite people say HELO first");
d481 1
a481 1
		session_respond(s, "503 Need MAIL before DATA");
d486 1
a486 1
		session_respond(s, "503 Need RCPT before DATA");
d501 1
a501 1
	session_respond(s, "252 Cannot VRFY; try RCPT to attempt delivery");
d509 1
a509 1
	session_respond(s, "502 Sorry, we do not allow this operation");
d517 1
a517 1
	session_respond(s, "502 Sorry, we do not allow this operation");
d659 1
a659 1
		session_respond(s, "%d Sender ok", ss->code);
d672 1
a672 1
			session_respond(s, "%d Recipient rejected: %s@@%s", ss->code,
d681 1
a681 1
		session_respond(s, "%d Recipient ok", ss->code);
d712 1
a712 1
		session_respond(s, "250 %s Message accepted for delivery",
d817 1
a817 1
	session_respond(s, "421 Service temporarily unavailable");
d837 1
a837 1
			session_respond(s, "554 Transaction failed");
d840 1
a840 1
			session_respond(s, "421 Temporary failure");
d1020 1
a1020 1
			session_respond(s, "500 Line too long");
d1032 1
a1032 1
		session_respond(s, "500 Line too long");
d1040 1
a1040 1
		session_respond(s, "500 Pipelining unsupported");
@


1.128
log
@when separating command from parameters in smtp session, the parser tries
to use ':' as a separator then fallbacks to ' ' so that it can detect the
command names that contain more than one words (MAIL FROM and RCPT TO) or
the one word ones (HELO, DATA, ...).

this is incorrect and the parser can get confused if the parameter to any
command contains a ':', for example "HELO [ipv6:...]" cause the parser to
lookup for command "HELO [ipv6".

fix this by using ':' as a delimiter for 'mail from' and 'rcpt to', while
using ' ' as a delimiter for all other commands.

fixes bug 6285/system reported by Lionel Le Folgoc <lionel@@lefolgoc.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.127 2009/12/13 22:02:55 jacekm Exp $	*/
d369 4
d823 1
d860 10
@


1.127
log
@Use safe fd limits in smtp, lka, queue, and control.  Removes a
possibility for fd-starvation fatal when under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.126 2009/11/16 10:38:11 jacekm Exp $	*/
d533 8
a540 1
	if ((ep = strchr(cmd, ':')) == NULL)
d542 1
@


1.126
log
@Kill dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.125 2009/11/13 11:40:06 jacekm Exp $	*/
a420 1
	(void)strlcpy(s->s_msg.tag, s->s_l->tag, sizeof(s->s_msg.tag));
d947 2
d971 6
a976 8
	if (s->s_env->stats->smtp.sessions_active < s->s_env->sc_maxconn &&
	    !(s->s_msg.flags & F_MESSAGE_ENQUEUED)) {
		/*
		 * if our session_destroy occurs because of a configuration
		 * reload, our listener no longer exist and s->s_l is NULL.
		 */
		if (s->s_l != NULL)
			event_add(&s->s_l->ev, NULL);
@


1.125
log
@Log all 4yz and 5yz replies that we send to our clients.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.124 2009/11/13 11:37:27 jacekm Exp $	*/
d969 9
a977 18
	switch (smtpd_process) {
	case PROC_MTA:
		s->s_env->stats->mta.sessions_active--;
		break;
	case PROC_SMTP:
		s->s_env->stats->smtp.sessions_active--;
		if (s->s_env->stats->smtp.sessions_active < s->s_env->sc_maxconn &&
		    !(s->s_msg.flags & F_MESSAGE_ENQUEUED)) {
			/*
			 * if our session_destroy occurs because of a configuration
			 * reload, our listener no longer exist and s->s_l is NULL.
			 */
			if (s->s_l != NULL)
				event_add(&s->s_l->ev, NULL);
		}
		break;
	default:
		fatalx("session_destroy: cannot be called from this process");
a1067 5

	if (smtpd_process == PROC_MTA) {
		bufferevent_enable(s->s_bev, EV_WRITE);
		return;
	}
@


1.124
log
@Include recipient address in "Recipient rejected" reply.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.123 2009/11/05 23:30:01 gilles Exp $	*/
d1092 4
a1095 2
		log_debug("session error: %s: \"%.*s\"",
		    ss_to_text(&s->s_ss),
@


1.123
log
@evbuffer_readline() assumes end of line to be \r, \n, \r\n, \n\r or \r\r.
smtp protocol expects lines to end with \r\n.

if a client sends a very long line which is unfortunately read up to \r,
evbuffer_readline() will return the line, then will detect another line
when the buffer is filled again and starts with \n, returning again with
an empty line. this is a bug which trigger very rarely and usually shows
up as an empty line in the middle of headers, causing all subsequent
headers to appear as part of the body to most mail user agents.

upstream fixes this with evbuffer_readln() in version 2.0 of libevent, a
mail will be sent to see if they can backport it, meanwhile we fix it by
introducing evbuffer_readln_crlf().

discussed with and ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.122 2009/10/19 20:48:13 gilles Exp $	*/
d658 2
a659 1
			session_respond(s, "%d Recipient rejected", ss->code);
@


1.122
log
@currently, smtpd is capable of having multiple listeners with different
options but they will all share the same ruleset. this means that there
is no way to have a rule apply to a session established on one listener
but not applied on another.

this commit brings initial support for tagging listeners and having the
rules able to match these specific listeners. The following will define
a rule which will only apply to interfaces tagged as "mynet":

listen on lo0			# implicit lo0 tag
listen on fxp0 tag mynet
listen on fxp1 tag mynet

accept on mynet for domain "example.org" deliver to mbox
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.121 2009/10/06 18:20:44 gilles Exp $	*/
d77 1
d1000 1
a1000 1
	line = evbuffer_readline(s->s_bev->input);
d1022 1
a1022 1
	    (line2 = evbuffer_readline(s->s_bev->input)) != NULL) {
d1168 33
@


1.121
log
@disallow AUTH once a session is in progress, this prevents a fatal from
being triggered in smtp process when client sends AUTH after MAIL.

bug reported and fix tested by James Turner <james@@bsdgroup.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.120 2009/09/12 12:24:51 jacekm Exp $	*/
d420 1
@


1.120
log
@Simplify line len checking: use one limit for all SMTP exchanges.
This is not as strict as various RFCs want it, but we can make it
more granular later.  For now, let all mails flow by using the
maximum of all limits found in the RFCs.
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.119 2009/09/12 09:50:31 gilles Exp $	*/
d153 5
@


1.119
log
@fix a wrong computation in session_readline() where the length of line was
deduced from the buffer size prior and after evbuffer_readline() call. the
problem is that this accounts for the characters which evbuffer_readline()
removed and we do not know how many they were (\n, \r\n ..). fix just does
a strlen() call of line which is a bit slower but way safer.

This could very well fix the broken headers issue some people reported
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.118 2009/09/12 09:38:45 gilles Exp $	*/
d68 1
a68 1
void		 session_read_data(struct session *, char *, size_t);
d71 2
a72 2
void		 session_command(struct session *, char *, size_t);
char		*session_readline(struct session *, size_t *);
d522 1
a522 1
session_command(struct session *s, char *cmd, size_t nr)
a526 6
	if (nr > SMTP_CMDLINE_MAX) {
		session_respond(s, "500 Line too long");
		s->s_env->stats->smtp.cmdlinetoolong++;
		return;
	}

a752 1
	size_t		 nr;
d755 1
a755 1
		line = session_readline(s, &nr);
d779 1
a779 1
			session_command(s, line, nr);
d783 1
a783 1
			session_read_data(s, line, nr);
d802 1
a802 1
session_read_data(struct session *s, char *line, size_t nread)
a832 6
	if (nread > SMTP_DATALINE_MAX) {
		s->s_msg.status |= S_MESSAGE_PERMFAILURE;
		s->s_env->stats->smtp.datalinetoolong++;
		return;
	}

d987 1
a987 1
session_readline(struct session *s, size_t *nr)
d990 1
d992 1
a992 1
	*nr = 0;
d995 1
a995 1
		if (EVBUFFER_LENGTH(s->s_bev->input) > SMTP_ANYLINE_MAX) {
d1002 1
d1006 7
a1024 1
	*nr = strlen(line);
@


1.118
log
@cmdlinetoolong stat was incremented at the wrong place, fix
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.117 2009/09/12 09:22:33 gilles Exp $	*/
d1004 1
a1004 1
	*nr = EVBUFFER_LENGTH(s->s_bev->input);
a1013 1
	*nr -= EVBUFFER_LENGTH(s->s_bev->input);
d1029 1
@


1.117
log
@- fix a compile time warning
- add a new stats counter to distinguish between command lines which
  exceeded the limit and data lines which exceeded the limits
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.116 2009/09/12 09:01:19 gilles Exp $	*/
d529 1
d1009 1
a1009 1
			s->s_env->stats->smtp.cmdlinetoolong++;
@


1.116
log
@replace a fwrite || fwrite construct with a fprintf which achieves the same
while being less error prone
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.115 2009/09/01 15:23:02 jacekm Exp $	*/
d839 1
a839 1
	if (nread > SMTP_TEXTLINE_MAX) {
d841 1
d853 1
a853 1
	if (fprintf(s->datafp, "%s\n", line) != len + 1) {
d1008 1
a1008 1
			s->s_env->stats->smtp.linetoolong++;
@


1.115
log
@Log all 4yz/5yz responses we send when in debug mode; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.114 2009/08/12 13:32:19 jacekm Exp $	*/
d852 1
a852 2
	if (fwrite(line, 1, len, s->datafp) != len ||
	    fwrite("\n", 1, 1, s->datafp) != 1) {
@


1.114
log
@Fix unwanted rejects by parsing (and ignoring) AUTH=<...> MAIL
command argument.  Testers, you want this.
Committing on gilles@@'s behalf.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.113 2009/08/08 00:02:22 gilles Exp $	*/
d1080 14
@


1.113
log
@import some changes from portable smtpd to reduce the delta between both.
this commit contains mostly missing casts and cosmethic changes, do not
expect to build this anywhere but on OpenBSD, it does not contain any of
the portable glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.112 2009/08/07 21:59:01 gilles Exp $	*/
d290 2
a291 2
	body = strrchr(args, ' ');
	if (body != NULL) {
d294 3
a296 2
		if (strcasecmp("body=7bit", body) == 0) {
			s->s_flags &= ~F_8BITMIME;
d299 12
a310 3
		else if (strcasecmp("body=8bitmime", body) != 0) {
			session_respond(s, "503 Invalid BODY");
			return 1;
a311 2

		return session_rfc5321_mail_handler(s, args);
d313 2
a314 2

	return 0;
@


1.112
log
@smtp_session: ssl/ssl.h -> openssl/ssl.h
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.111 2009/08/07 20:21:48 gilles Exp $	*/
d197 1
a197 1
		if ((len = __b64_pton(arg, buf, sizeof(buf) - 1)) == -1)
d250 1
a250 1
		if (__b64_pton(arg, a->user, sizeof(a->user) - 1) == -1)
d259 1
a259 1
		if (__b64_pton(arg, a->pass, sizeof(a->pass) - 1) == -1)
@


1.111
log
@we were linking to libkeynote to use kn_base64_encode/decode, but honestly
this was a ugly hack, and i'd rather include resolv.h and use __b64_encode
and __b64_decode as openssh does. this commit kills all references to
libkeynote in smtpd, should help a bit with porting ... no functionnal
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.110 2009/08/06 17:09:13 gilles Exp $	*/
d30 1
a30 1
#include <ssl/ssl.h>
@


1.110
log
@in smtp_session, fix logging so that when we accepted an empty envelope for
the sender, we dont log 'from=<@@>' but from=<> instead
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.109 2009/08/01 15:33:28 gilles Exp $	*/
d37 1
a42 2
#include <keynote.h>

d197 1
a197 1
		if ((len = kn_decode_base64(arg, buf, sizeof(buf) - 1)) == -1)
d250 1
a250 1
		if (kn_decode_base64(arg, a->user, sizeof(a->user) - 1) == -1)
d259 1
a259 1
		if (kn_decode_base64(arg, a->pass, sizeof(a->pass) - 1) == -1)
@


1.109
log
@when receiving characters with the most significant bit set over a session
not flagged with F_8BITMIME, clear the bit instead of permanently erroring
the whole message. some mta's do not always request 8BITMIME when they are
sending messages which are not 8bit clean, this lets us be less strict for
them while not violating RFC ourselves.

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.108 2009/07/19 19:06:02 jacekm Exp $	*/
d690 1
a690 1
		log_info("%s: from=<%s@@%s>, size=%ld, nrcpts=%zd, proto=%s, "
d694 1
@


1.108
log
@fix fwrite return code checking.
bug exposed by recent change to fwrite, and reported by oga.
ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.107 2009/06/06 04:14:21 pyr Exp $	*/
d853 1
a853 5
				break;
		if (i != len) {
			s->s_msg.status |= S_MESSAGE_PERMFAILURE;
			return;
		}
@


1.107
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.106 2009/06/05 20:43:57 pyr Exp $	*/
d844 1
a844 1
	if (fwrite(line, len, 1, s->datafp) != 1 ||
@


1.106
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.105 2009/06/01 14:53:18 gilles Exp $	*/
d957 1
a957 1
		imsg_compose_event(s->s_env->sc_ibufs[PROC_QUEUE],
d1144 1
a1144 1
	imsg_compose_event(s->s_env->sc_ibufs[proc], type, peerid, pid, fd, data,
@


1.105
log
@display ssl negociation information in the received line of incoming
sessions; ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.104 2009/05/31 18:34:48 gilles Exp $	*/
d957 1
a957 1
		imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE],
d1144 1
a1144 1
	imsg_compose(s->s_env->sc_ibufs[proc], type, peerid, pid, fd, data,
@


1.104
log
@when entering mta_connect() reset session fd to -1
when connect timesout and we close the fd, reset session fd to -1
in session_destroy(), only attempt to close session fd if != -1

fixes a fatal in session_destroy() which happened because we closed a fd
after a timeout, but the session still assumed the fd to be opened.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.103 2009/05/30 16:22:07 gilles Exp $	*/
d30 2
d671 6
@


1.103
log
@fix a bug where sessions_active counter, used to compute accept limits, was
decremented below 0 after the recent change that moved stats to shared mmap
memory. session_destroy() which is called from mta and smtp processes didnt
differentiate between them and decremented the counter when we had outgoing
sessions destroyed.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.102 2009/05/28 08:50:08 jacekm Exp $	*/
d958 1
a958 1
	if (close(s->s_fd) == -1)
@


1.102
log
@Log the incoming message size; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.101 2009/05/28 08:48:46 jacekm Exp $	*/
d961 18
a978 9
	s->s_env->stats->smtp.sessions_active--;
	if (s->s_env->stats->smtp.sessions_active < s->s_env->sc_maxconn &&
	    !(s->s_msg.flags & F_MESSAGE_ENQUEUED)) {
		/*
		 * if our session_destroy occurs because of a configuration
		 * reload, our listener no longer exist and s->s_l is NULL.
		 */
		if (s->s_l != NULL)
			event_add(&s->s_l->ev, NULL);
@


1.101
log
@Log the "for <foo@@bar.com>" part in the Received field; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.100 2009/05/27 13:14:18 jacekm Exp $	*/
d682 2
a683 1
		log_info("%s: from=<%s@@%s>, nrcpts=%zd, proto=%s, relay=%s [%s]",
d687 1
d798 1
@


1.100
log
@Insert Received: at receive time instead of delivery time; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.99 2009/05/27 13:11:39 jacekm Exp $	*/
d662 1
d665 1
a665 1
		fprintf(s->datafp, "\tby %s with %sSMTP id %s;\n",
d668 9
a676 1
		fprintf(s->datafp, "\t%s\n", time_to_text(time(NULL)));
@


1.99
log
@After a successful AUTH command completes, reject any further AUTH commands.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.98 2009/05/27 13:09:07 jacekm Exp $	*/
d662 6
@


1.98
log
@request flood mitigation:
1) each state may have 2 responses sent quickly;
2) more responses are delayed exponentially, up to a defined limit.

Delay count is user visible (smtp.errors.delays).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.97 2009/05/25 13:29:47 jacekm Exp $	*/
d142 7
a148 2
	if (! ADVERTISE_AUTH(s))
		return 0;
d323 1
a323 1
	s->s_flags &= F_SECURE;
d346 1
a346 1
	s->s_flags &= F_SECURE;
@


1.97
log
@Recent event masking scheme change turned the S_GREETED and S_HELO cases
in session_pickup into unreached code, so remove them; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.96 2009/05/24 15:47:31 jacekm Exp $	*/
d72 1
d130 1
a132 2
	s->s_state = S_TLS;

d182 1
a183 1
			s->s_state = S_AUTH_INIT;
d186 1
d238 1
a238 1
		/* "Username:" base64 encoded is "VXNlcm5hbWU6" */
a239 1
		s->s_state = S_AUTH_USERNAME;
d247 1
a247 1
		/* "Password:" base64 encoded is "UGFzc3dvcmQ6" */
a248 1
		s->s_state = S_AUTH_PASSWORD;
a659 1
		s->s_state = S_HELO;
d671 1
d674 1
d1019 4
a1022 1
	va_list ap;
d1030 47
a1076 2
	if (smtpd_process == PROC_SMTP)
		bufferevent_disable(s->s_bev, EV_READ);
@


1.96
log
@Parent process shouldn't be base64-decoding untrusted strings, move
this code to privsep smtp process; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.95 2009/05/24 14:58:43 jacekm Exp $	*/
a592 4
		break;

	case S_GREETED:
	case S_HELO:
@


1.95
log
@Implement pipelining detection inside session_readline, makes the calling
code cleaner; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.94 2009/05/24 14:22:24 jacekm Exp $	*/
d63 2
a64 3
int		 session_rfc4954_auth_plain(struct session *, char *, size_t);
int		 session_rfc4954_auth_login(struct session *, char *, size_t);
void		 session_auth_pickup(struct session *, char *, size_t);
d163 1
a163 1
		return session_rfc4954_auth_plain(s, eom, eom ? strlen(eom) : 0);
d165 3
a167 1
		return session_rfc4954_auth_login(s, eom, eom ? strlen(eom) : 0);
a168 1
	session_respond(s, "501 Syntax error");
a169 1

d172 2
a173 2
int
session_rfc4954_auth_plain(struct session *s, char *arg, size_t nr)
d175 12
a186 5
	if (arg == NULL) {
		session_respond(s, "334 ");
		s->s_state = S_AUTH_INIT;
		return 1;
	}
d188 29
a216 6
	s->s_auth.session_id = s->s_id;
	if (strlcpy(s->s_auth.buffer, arg, sizeof(s->s_auth.buffer)) >=
	    sizeof(s->s_auth.buffer)) {
		session_respond(s, "501 Syntax error");
		return 1;
	}
d218 2
a219 1
	s->s_state = S_AUTH_FINALIZE;
d221 3
a223 2
	session_imsg(s, PROC_PARENT, IMSG_PARENT_AUTHENTICATE, 0, 0, -1,
	    &s->s_auth, sizeof(s->s_auth));
d225 3
a227 1
	return 1;
d230 2
a231 2
int
session_rfc4954_auth_login(struct session *s, char *arg, size_t nr)
d233 1
a233 3
	struct session_auth_req req;
	int blen = 0;
	size_t len = 0;
a238 1
		s->s_auth.session_id = s->s_id;
d240 1
a240 1
		return 1;
d243 3
a245 7
		bzero(s->s_auth.buffer, sizeof(s->s_auth.buffer));
		if ((blen = kn_decode_base64(arg, req.buffer, sizeof(req.buffer) - 1)) == -1)
			goto err;
		/* req.buffer is a byte string, NUL terminate */
		req.buffer[blen] = '\0';
		if (! bsnprintf(s->s_auth.buffer + 1, sizeof(s->s_auth.buffer) - 1, "%s", req.buffer))
			goto err;
d250 6
d257 1
a257 1
		return 1;
d259 3
a261 9
	case S_AUTH_PASSWORD: {
		if ((blen = kn_decode_base64(arg, req.buffer, sizeof(req.buffer) - 1)) == -1)
			goto err;
		/* req.buffer is a byte string, NUL terminate */
		req.buffer[blen] = '\0';

		len = strlen(s->s_auth.buffer + 1);
		if (! bsnprintf(s->s_auth.buffer + len + 2, sizeof(s->s_auth.buffer) - len - 2, "%s", req.buffer))
			goto err;
d263 3
a265 2
		break;
	}
d270 2
a271 12
	s->s_state = S_AUTH_FINALIZE;

	req = s->s_auth;
	len = strlen(s->s_auth.buffer + 1) + strlen(arg) + 2;
	if (kn_encode_base64(req.buffer, len, s->s_auth.buffer, sizeof(s->s_auth.buffer)) == -1)
		goto err;

	session_imsg(s, PROC_PARENT, IMSG_PARENT_AUTHENTICATE, 0, 0, -1,
	    &s->s_auth, sizeof(s->s_auth));

	return 1;
err:
a272 2
	session_respond(s, "535 Authentication failed");
	return 1;
a430 4
	if (s->s_flags & F_AUTHENTICATED) {
		s->s_msg.flags |= F_MESSAGE_AUTHENTICATED;
	}

a574 29
session_auth_pickup(struct session *s, char *arg, size_t nr)
{
	if (s == NULL)
		fatal("session_auth_pickup: desynchronized");

	switch (s->s_state) {
	case S_AUTH_INIT:
		session_rfc4954_auth_plain(s, arg, nr);
		break;
	case S_AUTH_USERNAME:
		session_rfc4954_auth_login(s, arg, nr);
		break;
	case S_AUTH_PASSWORD:
		session_rfc4954_auth_login(s, arg, nr);
		break;
	case S_AUTH_FINALIZE:
		if (s->s_flags & F_AUTHENTICATED)
			session_respond(s, "235 Authentication succeeded");
		else
			session_respond(s, "535 Authentication failed");
		s->s_state = S_HELO;
		break;
	default:
		fatal("session_auth_pickup: unknown state");
	}
	return;
}

void
d606 8
d733 5
d740 1
a740 3
		case S_AUTH_FINALIZE:
			if (s->s_msg.status & S_MESSAGE_TEMPFAILURE) {
				free(line);
d742 1
a742 2
			}
			session_auth_pickup(s, line, nr);
d749 1
a749 2
			if (s->s_msg.status & S_MESSAGE_TEMPFAILURE) {
				free(line);
a750 1
			}
d770 1
@


1.94
log
@Instead of keeping stats private to each process, and querying every
process individually whenever stats need to be fetched, keep stats
in MAP_ANON shared memory allocated by parent.

This means control has direct access to stats and can respond very
quickly without troubling any other daemon processes.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.93 2009/05/20 16:12:11 jacekm Exp $	*/
a734 1
	int		 expect_lines = 1;
a740 11
		if (! expect_lines) {
			session_respond(s, "500 Pipelining unsupported");
			s->s_env->stats->smtp.toofast++;
			s->s_flags |= F_QUIT;
			return;
		}
		expect_lines = 0;

		if (s->s_flags & F_WRITEONLY)
			fatalx("session_read: corrupt session");

a764 2
			if (strcmp(line, ".") != 0)
				expect_lines = 1;
d970 1
a970 1
	char *line;
d983 14
@


1.93
log
@Delay enabling of EV_READ until S_INIT (smtps) or S_TLS (starttls).
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.92 2009/05/20 14:29:44 gilles Exp $	*/
a76 2
extern struct s_session	s_smtp;

d601 1
a601 1
		s_smtp.tempfail++;
d744 1
a744 1
			s_smtp.toofast++;
d792 1
a792 1
	s_smtp.tempfail++;
d813 1
a813 1
			s_smtp.tempfail++;
d908 1
a908 1
			s_smtp.read_timeout++;
d910 1
a910 1
			s_smtp.read_eof++;
d913 1
a913 1
			s_smtp.read_error++;
d923 1
a923 1
			s_smtp.write_timeout++;
d925 1
a925 1
			s_smtp.write_eof++;
d928 1
a928 1
			s_smtp.write_error++;
d965 2
a966 2
	s_smtp.sessions_active--;
	if (s_smtp.sessions_active < s->s_env->sc_maxconn &&
d991 1
a991 1
			s_smtp.linetoolong++;
@


1.92
log
@first step towards configuration reload in smtpd, smtpctl reload will parse
the configuration file again and replace current configuration with new one
in all processes. what we don't support yet is graceful restart, clients in
sessions at the moment of the reload will have a temp failure thrown at 'em
which is ok RFC-wise but which we will try to improve anyway.

tested with various setups, "diff reads good" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.91 2009/05/19 12:33:53 jacekm Exp $	*/
d620 3
a728 2
	
	bufferevent_enable(s->s_bev, EV_READ);
@


1.91
log
@Accept STARTTLS only after EHLO; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.90 2009/05/19 11:42:52 jacekm Exp $	*/
d759 4
d770 4
d789 6
d968 8
a975 2
	    !(s->s_msg.flags & F_MESSAGE_ENQUEUED))
		event_add(&s->s_l->ev, NULL);
@


1.90
log
@- Don't advertise nor accept STARTTLS command when session is secure.
- Make the condition when STARTTLS and AUTH are advertised & accepted
more readable.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.89 2009/05/18 20:23:35 jacekm Exp $	*/
d119 5
@


1.89
log
@Complete rework of bufferevent event masking allowing for  more
strictness:
- Drop clients attempting command pipelining; protects the daemon
from all kinds of abuse.
- Replace F_EVLOCKED flag with F_WRITEONLY which has cleaner sematics:
when up, session must not be destroyed nor read from, but may be
written to.
- Write callback becomes a central place for enabling EV_READ.
- Delay bufferevent creation until after ssl handshake is completed.

A bunch of session error stats were added to smtpctl's "show stats".
These could help spotting event masking errors in the future.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.88 2009/05/14 15:05:12 eric Exp $	*/
d114 3
d140 3
d332 1
a332 2
	/* only advertise starttls if listener can support it */
	if (s->s_l->flags & F_STARTTLS)
d335 1
a335 2
	/* only advertise auth if session is secure */
	if ((s->s_l->flags & F_AUTH) && (s->s_flags & F_SECURE))
d539 6
a544 8
	if ((s->s_l->flags & F_AUTH) && (s->s_flags & F_SECURE)) {
		for (i = 0; i < nitems(rfc4954_cmdtab); ++i)
			if (strcasecmp(rfc4954_cmdtab[i].name, cmd) == 0)
				break;
		if (i < nitems(rfc4954_cmdtab)) {
			if (rfc4954_cmdtab[i].func(s, args))
				return;
		}
@


1.88
log
@use the nitems() macro where appropriate

ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.87 2009/05/14 08:29:37 jacekm Exp $	*/
d44 32
a75 31
int		session_rfc5321_helo_handler(struct session *, char *);
int		session_rfc5321_ehlo_handler(struct session *, char *);
int		session_rfc5321_rset_handler(struct session *, char *);
int		session_rfc5321_noop_handler(struct session *, char *);
int		session_rfc5321_data_handler(struct session *, char *);
int		session_rfc5321_mail_handler(struct session *, char *);
int		session_rfc5321_rcpt_handler(struct session *, char *);
int		session_rfc5321_vrfy_handler(struct session *, char *);
int		session_rfc5321_expn_handler(struct session *, char *);
int		session_rfc5321_turn_handler(struct session *, char *);
int		session_rfc5321_help_handler(struct session *, char *);
int		session_rfc5321_quit_handler(struct session *, char *);
int		session_rfc5321_none_handler(struct session *, char *);

int		session_rfc1652_mail_handler(struct session *, char *);

int		session_rfc3207_stls_handler(struct session *, char *);

int		session_rfc4954_auth_handler(struct session *, char *);
int		session_rfc4954_auth_plain(struct session *, char *, size_t);
int		session_rfc4954_auth_login(struct session *, char *, size_t);
void		session_auth_pickup(struct session *, char *, size_t);

void		session_read(struct bufferevent *, void *);
int		session_read_data(struct session *, char *, size_t);
void		session_write(struct bufferevent *, void *);
void		session_error(struct bufferevent *, short, void *);
void		session_command(struct session *, char *, char *);
int		session_set_path(struct path *, char *);
void		session_imsg(struct session *, enum smtp_proc_type,
		    enum imsg_type, u_int32_t, pid_t, int, void *, u_int16_t);
a126 2
	bufferevent_disable(s->s_bev, EV_READ);
	ssl_session_init(s);
a423 1
	bufferevent_disable(s->s_bev, EV_READ);
d491 1
a491 1
session_command(struct session *s, char *cmd, char *args)
d493 19
a511 1
	unsigned int	i;
a563 2
	bufferevent_enable(s->s_bev, EV_READ);

a592 2
	bufferevent_enable(s->s_bev, EV_READ);

d596 1
a597 1
		bufferevent_disable(s->s_bev, EV_READ);
a692 7
	if ((s->s_bev = bufferevent_new(s->s_fd, session_read, session_write,
	    session_error, s)) == NULL)
		fatalx("session_init: bufferevent_new failed");

	bufferevent_settimeout(s->s_bev, SMTPD_SESSION_TIMEOUT,
	    SMTPD_SESSION_TIMEOUT);

a693 3
		log_debug("session_init: initializing ssl");
		s->s_flags |= F_EVLOCKED;
		bufferevent_disable(s->s_bev, EV_READ|EV_WRITE);
d698 1
d703 21
a727 2
	char		*ep;
	char		*args;
d729 1
d731 8
a738 6
read:
	nr = EVBUFFER_LENGTH(bev->input);
	line = evbuffer_readline(bev->input);
	if (line == NULL) {
		if (EVBUFFER_LENGTH(bev->input) > SMTP_ANYLINE_MAX) {
			session_respond(s, "500 Line too long");
d740 1
a740 1
			bufferevent_disable(s->s_bev, EV_READ);
d742 25
a766 3
		return;
	}
	nr -= EVBUFFER_LENGTH(bev->input);
d768 2
a769 4
	if (s->s_state == S_DATACONTENT) {
		if (session_read_data(s, line, nr)) {
			free(line);
			return;
a770 3
		free(line);
		goto read;
	}
a771 2
	if (IS_AUTH(s->s_state)) {
		session_auth_pickup(s, line, nr);
a772 6
		return;
	}

	if (nr > SMTP_CMDLINE_MAX) {
		session_respond(s, "500 Line too long");
		return;
a773 14

	if ((ep = strchr(line, ':')) == NULL)
		ep = strchr(line, ' ');
	if (ep != NULL) {
		*ep = '\0';
		args = ++ep;
		while (isspace((int)*args))
			args++;
	} else
		args = NULL;
	log_debug("command: %s\targs: %s", line, args);
	session_command(s, line, args);
	free(line);
	return;
d776 1
a776 1
int
d792 2
a793 1
			s->s_state = S_HELO;
d800 1
a800 1
		return 1;
d805 1
a805 1
		return 0;
d809 1
a809 1
		return 0;
d823 1
a823 1
		return 0;
d832 1
a832 1
			return 0;
d835 6
d842 35
a876 1
	return 0;
d880 1
a880 1
session_write(struct bufferevent *bev, void *p)
d883 12
a895 1
	if (s->s_flags & F_QUIT)
d897 22
d926 3
d932 1
a932 5
	if (s->s_msg.message_id[0] != '\0' && s->s_state != S_DONE) {
		/*
		 * IMSG_QUEUE_REMOVE_MESSAGE must not be sent using session_imsg
		 * since no reply for it is expected.
		 */
a935 3
		s->s_msg.message_id[0] = '\0';
		s->s_msg.message_uid[0] = '\0';
	}
d937 7
a943 1
	close(s->s_fd);
a949 5
	if (s->s_bev != NULL) {
		bufferevent_free(s->s_bev);
	}
	ssl_session_destroy(s);

d955 2
a956 2
void
session_error(struct bufferevent *bev, short event, void *p)
d958 13
a970 1
	struct session	*s = p;
d972 1
a972 14
	if (event & EVBUFFER_TIMEOUT)
		s_smtp.timeout++;
	else
		s_smtp.aborted++;

	/* If events are locked, do not destroy session
	 * but set F_QUIT flag so that we destroy it as
	 * soon as the event lock is removed.
	 */
	if (s->s_flags & F_EVLOCKED) {
		s->s_flags |= F_QUIT;
		bufferevent_disable(s->s_bev, EV_READ);
	} else
		session_destroy(s);
d1014 2
d1026 2
a1027 2
	imsg_compose(s->s_env->sc_ibufs[proc], type, peerid, pid, fd, data,
	    datalen);
d1030 10
a1039 3
	 * Most IMSGs require replies before session can be safely resumed.
	 * Ignore client events so that malicious client cannot trigger
	 * session_pickup at a bad time.
d1041 1
d1043 2
a1044 11

	/*
	 * If session is unexpectedly teared down, event(3) calls session_error
	 * without honoring EV_READ block.
	 * To avoid session data being destroyed while an IMSG requiring it
	 * is with other process, provide a flag that session_error can use to
	 * determine if it is safe to destroy session data.
	 */
	if (s->s_flags & F_EVLOCKED)
		fatalx("session_imsg: imsg sent when another is pending");
	s->s_flags |= F_EVLOCKED;
@


1.87
log
@correct function name in fatal
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.86 2009/05/10 14:24:19 jacekm Exp $	*/
d495 1
a495 1
	int	i;
d501 1
a501 1
	for (i = 0; i < (int)(sizeof(rfc1652_cmdtab) / sizeof(struct session_cmd)); ++i)
d504 1
a504 1
	if (i < (int)(sizeof(rfc1652_cmdtab) / sizeof(struct session_cmd))) {
d510 1
a510 1
	for (i = 0; i < (int)(sizeof(rfc3207_cmdtab) / sizeof(struct session_cmd)); ++i)
d513 1
a513 1
	if (i < (int)(sizeof(rfc3207_cmdtab) / sizeof(struct session_cmd))) {
d520 1
a520 1
		for (i = 0; i < (int)(sizeof(rfc4954_cmdtab) / sizeof(struct session_cmd)); ++i)
d523 1
a523 1
		if (i < (int)(sizeof(rfc4954_cmdtab) / sizeof(struct session_cmd))) {
d531 1
a531 1
	for (i = 0; i < (int)(sizeof(rfc5321_cmdtab) / sizeof(struct session_cmd)); ++i)
d534 1
a534 1
	if (i < (int)(sizeof(rfc5321_cmdtab) / sizeof(struct session_cmd))) {
@


1.86
log
@use both read and write timeout arguments in the bufferevent_settimeout
call; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.85 2009/05/10 13:06:23 jacekm Exp $	*/
d546 1
a546 1
		fatal("session_pickup: desynchronized");
@


1.85
log
@use rfc number 4954 in auth_plain handler name, rfc 4616 is implied
because rfc 4954 references it.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.84 2009/05/10 11:29:40 jacekm Exp $	*/
d685 2
a686 1
	bufferevent_settimeout(s->s_bev, SMTPD_SESSION_TIMEOUT, 0);
@


1.84
log
@assert copyright; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.83 2009/05/10 11:23:04 jacekm Exp $	*/
d63 1
a63 1
int		session_rfc4616_auth_plain(struct session *, char *, size_t);
d156 1
a156 1
		return session_rfc4616_auth_plain(s, eom, eom ? strlen(eom) : 0);
d166 1
a166 1
session_rfc4616_auth_plain(struct session *s, char *arg, size_t nr)
d552 1
a552 1
		session_rfc4616_auth_plain(s, arg, nr);
@


1.83
log
@RFC 4954 says the response to "AUTH PLAIN" must be "334 ", not "334";
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.82 2009/05/09 23:23:38 jacekm Exp $	*/
d6 1
d126 2
a600 2
		s->s_flags |= F_EVLOCKED;
		bufferevent_disable(s->s_bev, EV_READ|EV_WRITE);
a601 1
		ssl_session_init(s);
d822 2
a823 9
	if (!(s->s_flags & F_QUIT)) {
		
		if (s->s_state == S_TLS)
			session_pickup(s, NULL);

		return;
	}

	session_destroy(s);
@


1.82
log
@correct AUTH PLAIN rfc number, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.81 2009/05/09 20:03:07 jacekm Exp $	*/
d166 1
a166 1
		session_respond(s, "334");
@


1.81
log
@give few states more meaningful names; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.80 2009/05/09 18:59:09 jacekm Exp $	*/
d62 1
a62 1
int		session_rfc4954_auth_plain(struct session *, char *, size_t);
d153 1
a153 1
		return session_rfc4954_auth_plain(s, eom, eom ? strlen(eom) : 0);
d163 1
a163 1
session_rfc4954_auth_plain(struct session *s, char *arg, size_t nr)
d549 1
a549 1
		session_rfc4954_auth_plain(s, arg, nr);
@


1.80
log
@fix function names in log_debug
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.79 2009/04/28 21:56:45 jacekm Exp $	*/
d374 1
a374 1
	s->s_state = S_MAILREQUEST;
d405 1
a405 1
	s->s_state = S_RCPTREQUEST;
d445 1
a445 1
	s->s_state = S_DATAREQUEST;
d604 1
a604 1
	case S_MAILREQUEST:
d606 1
a606 2
			fatalx("bad ss at S_MAILREQUEST");
		/* sender was not accepted, downgrade state */
d613 1
a613 1
		s->s_state = S_MAIL;
d620 1
a620 1
	case S_MAIL:
d622 2
a623 1
			fatalx("bad ss at S_MAIL");
d627 1
a627 1
	case S_RCPTREQUEST:
d629 1
a629 1
			fatalx("bad ss at S_RCPTREQUEST");
d648 1
a648 1
	case S_DATAREQUEST:
@


1.79
log
@don't use strlcpy before calling a function that uses strlcpy
internally anyway; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.78 2009/04/28 21:55:16 jacekm Exp $	*/
d379 1
a379 1
	log_debug("session_mail_handler: sending notification to mfa");
@


1.78
log
@make S_DATAREQUEST state similar to S_{MAIL,RCPT}REQUEST; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.77 2009/04/27 20:17:21 jacekm Exp $	*/
a356 2
	char buffer[MAX_PATH_SIZE];

d367 1
a367 6
	if (strlcpy(buffer, args, sizeof(buffer)) >= sizeof(buffer)) {
		session_respond(s, "553 Sender address syntax error");
		return 1;
	}

	if (! session_set_path(&s->s_msg.sender, buffer)) {
a388 2
	char buffer[MAX_PATH_SIZE];

d399 1
a399 6
	if (strlcpy(buffer, args, sizeof(buffer)) >= sizeof(buffer)) {
		session_respond(s, "553 Recipient address syntax error");
		return 1;
	}

	if (! session_set_path(&s->s_msg.session_rcpt, buffer)) {
a405 1

@


1.77
log
@kill 2-line session_msg_submit, used just once; ok gilles@@ long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.76 2009/04/27 16:20:34 jacekm Exp $	*/
d461 4
a464 1
	session_pickup(s, NULL);
d594 6
a599 2
	    (s->s_msg.status & S_MESSAGE_TEMPFAILURE))
		goto tempfail;
a663 11
		s->s_state = S_DATA;
		session_imsg(s, PROC_QUEUE, IMSG_QUEUE_MESSAGE_FILE, 0, 0, -1,
		    &s->s_msg, sizeof(s->s_msg));
		break;

	case S_DATA:
		if (ss == NULL)
			fatalx("bad ss at S_DATA");
		if (s->datafp == NULL)
			goto tempfail;

a687 1
		break;
a688 8

	return;

tempfail:
	session_respond(s, "421 Service temporarily unavailable");
	s->s_flags |= F_QUIT;
	bufferevent_disable(s->s_bev, EV_READ);
	return;
@


1.76
log
@session_cleanup call in MAIL FROM handler may be removed as a
consequence of rev. 1.70. This makes session_destroy the only
caller so merge the two; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.75 2009/04/27 16:10:20 jacekm Exp $	*/
a69 1
void		session_msg_submit(struct session *);
d801 2
a802 1
			session_msg_submit(s);
a916 8
}

void
session_msg_submit(struct session *s)
{
	session_imsg(s, PROC_QUEUE, IMSG_QUEUE_COMMIT_MESSAGE, 0, 0, -1,
	    &s->s_msg, sizeof(s->s_msg));
	s->s_state = S_DONE;
@


1.75
log
@Disable EV_READ when setting F_QUIT flag up. Malicious client may
send more commands after QUIT, these must not be processed; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.74 2009/04/24 15:26:59 jacekm Exp $	*/
a72 1
void		session_cleanup(struct session *);
a380 1
	session_cleanup(s);
d864 16
a879 1
	session_cleanup(s);
a880 1
	log_debug("session_destroy: killing client: %p", s);
a895 21
}

void
session_cleanup(struct session *s)
{
	if (s->datafp != NULL) {
		fclose(s->datafp);
		s->datafp = NULL;
	}

	if (s->s_msg.message_id[0] != '\0' && s->s_state != S_DONE) {
		/*
		 * IMSG_QUEUE_REMOVE_MESSAGE must not be sent using session_imsg
		 * since no reply for it is expected.
		 */
		imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE],
		    IMSG_QUEUE_REMOVE_MESSAGE, 0, 0, -1, &s->s_msg,
		    sizeof(s->s_msg));
		s->s_msg.message_id[0] = '\0';
		s->s_msg.message_uid[0] = '\0';
	}
@


1.74
log
@in session_pickup, do not handle S_RCPT state, it must never be
called in this state; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.73 2009/04/24 09:38:11 jacekm Exp $	*/
d440 1
d701 1
d703 1
a703 1
	session_respond(s, "421 Service temporarily unavailable");
d745 1
d921 1
a921 1
	if (s->s_flags & F_EVLOCKED)
d923 2
a924 1
	else
@


1.73
log
@Enclose common imsg handling code in a function, which additionally
does some sanity checking. Fix a bug that could lead to fatal under
rare circumstances, exposed by this newly added check; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.72 2009/04/24 08:35:48 jacekm Exp $	*/
a654 3
	case S_RCPT:
		if (ss == NULL)
			fatalx("bad ss at S_RCPT");
@


1.72
log
@use same timeout at each session state, and make use of
bufferevent_settimeout instead of rolling our own; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.71 2009/04/24 08:32:12 jacekm Exp $	*/
d894 1
a894 1
	if (s->s_msg.message_id[0] != '\0') {
@


1.71
log
@kill unnecessary struct message_recipient; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.70 2009/04/20 18:48:23 jacekm Exp $	*/
a42 2
struct session_timeout;

a72 2
void		session_set_timeout(struct session *, struct session_timeout *);
void		smtp_timeout(int, short, void *);
a78 17
struct session_timeout {
	enum session_state	state;
	time_t			timeout;
};

struct session_timeout rfc5321_timeouttab[] = {
	{ S_INIT,		300 },
	{ S_GREETED,		300 },
	{ S_HELO,		300 },
	{ S_MAIL,		300 },
	{ S_RCPT,		300 },
	{ S_DATA,		120 },
	{ S_DATACONTENT,	180 },
	{ S_DONE,		600 },
	{ 0,			0   }
};

a712 3
	evtimer_set(&s->s_timeout, smtp_timeout, s);
	session_set_timeout(s, rfc5321_timeouttab);

d717 2
a739 1
	session_set_timeout(s, rfc5321_timeouttab);
a879 1
	evtimer_del(&s->s_timeout);
d912 5
a920 1
	s_smtp.aborted++;
a960 31
}

void
session_set_timeout(struct session *s, struct session_timeout *tab)
{
	struct timeval tv;

	bzero(&tv, sizeof(tv));

	for (; tab->timeout; tab++)
		if (s->s_state == tab->state) {
			tv.tv_sec = tab->timeout;
			break;
		}
	if (! tab->timeout)
		tv.tv_sec = SMTPD_SESSION_TIMEOUT;
	evtimer_add(&s->s_timeout, &tv);
}

void
smtp_timeout(int fd, short event, void *p)
{
	struct session *s = p;

	log_debug("smtp_timeout: fd %d at state %d", s->s_fd, s->s_state);

	s_smtp.timeout++;
	if (s->s_flags & F_EVLOCKED)
		s->s_flags |= F_QUIT;
	else
		session_destroy(s);
@


1.70
log
@Allow MAIL FROM only in the S_HELO state, which results in behaviour
dictated by rfc in "4.1.4 Order of commands".

pointed out and initial diff by pea@@, ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.69 2009/04/20 17:40:38 jacekm Exp $	*/
a420 1
	struct message_recipient	mr;
a431 2
	bzero(&mr, sizeof(mr));

d437 1
a437 1
	if (! session_set_path(&mr.path, buffer)) {
a442 3
	s->s_msg.session_rcpt = mr.path;

	mr.id = s->s_msg.id;
a443 2
	mr.ss = s->s_ss;
	mr.msg = s->s_msg;
a447 1
		mr.flags |= F_MESSAGE_AUTHENTICATED;
d450 2
a451 1
	session_imsg(s, PROC_MFA, IMSG_MFA_RCPT, 0, 0, -1, &mr, sizeof(mr));
@


1.69
log
@fix previous, evtimer_set should be called only once, in session_init.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.68 2009/04/20 17:07:01 jacekm Exp $	*/
d384 5
@


1.68
log
@Rewrite smtp session timeouts; use evtimer_* from event(3) instead
of regularly walking session tree in search of idle clients. Gives
the smtp process a chance to become idle.

As a bonus, add smtp.sessions.timeout counter to "smtpctl show stats".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.67 2009/04/19 12:48:27 jacekm Exp $	*/
d75 1
a75 2
void		session_set_timeout(struct session *, struct session_timeout *,
		    void (*)(int, short, void *));
d737 2
a738 1
	session_set_timeout(s, rfc5321_timeouttab, smtp_timeout);
d765 1
a765 1
	session_set_timeout(s, rfc5321_timeouttab, smtp_timeout);
d987 1
a987 2
session_set_timeout(struct session *s, struct session_timeout *tab,
    void (*cb)(int, short, void *))
a999 1
	evtimer_set(&s->s_timeout, cb, s);
@


1.67
log
@Wrap the EV_READ+EVLOCKED dance in one well documented function.
Additionally, check that EVLOCKED is not already set, which would
indicate an attempt to send IMSG w/o waiting for reply for some
other IMSG sent earlier.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.66 2009/04/16 15:35:06 jacekm Exp $	*/
d43 2
d75 3
a77 1
void		session_timeout(int, short, void *);
d97 2
a98 1
	{ S_DONE,		600 }
d738 2
d765 1
a765 1
	s->s_tm = time(NULL);
d906 1
d987 2
a988 1
session_timeout(int fd, short event, void *p)
d990 1
a990 15
	struct smtpd		*env = p;
	struct session		*sessionp;
	struct session		*rmsession;
	struct timeval		 tv;
	time_t			 tm;
	u_int8_t		 i;

	tm = time(NULL);
	rmsession = NULL;
	SPLAY_FOREACH(sessionp, sessiontree, &env->sc_sessions) {

		if (rmsession != NULL) {
			session_destroy(rmsession);
			rmsession = NULL;
		}
d992 1
a992 4
		for (i = 0; i < sizeof (rfc5321_timeouttab) /
			 sizeof(struct session_timeout); ++i)
			if (rfc5321_timeouttab[i].state == sessionp->s_state)
				break;
d994 4
a997 6
		if (i == sizeof (rfc5321_timeouttab) / sizeof (struct session_timeout)) {
			if (tm - SMTPD_SESSION_TIMEOUT < sessionp->s_tm)
				continue;
		}
		else if (tm - rfc5321_timeouttab[i].timeout < sessionp->s_tm) {
				continue;
d999 5
d1005 4
a1008 2
		rmsession = sessionp;
	}
d1010 1
a1010 2
	if (rmsession != NULL)
		session_destroy(rmsession);
d1012 5
a1016 3
	tv.tv_sec = 1;
	tv.tv_usec = 0;
	evtimer_add(&env->sc_ev, &tv);
@


1.66
log
@Total rewrite of the sendmail interface. Adds support for -t, -v,
and -F cmdline args. Also, date and Message-Id headers are added
when missing.

The main trouble with the current enqueue code is that it requires
dealing with problems in the control process that are already solved
in the smtp process, ie. duplicating a lot of code which interacts
with untrusted clients. This diff solves this by making sendmail
obtain a SMTP socket from smtp via smtpd.sock, and using that socket
to deliver the message. For smtpd it looks as if connection was
made from the network, only difference being the F_MESSAGE_ENQUEUED
message flag, handy when differentation between local and remote
deliveries is wanted.

Most of the features come from the femail program, created by henning@@.

Additional testing by Nigel J. Taylor.

ok gilles@@, henning@@ happy with smtpd using femail code
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.65 2009/04/09 20:19:03 todd Exp $	*/
d75 2
d199 2
a200 4
	imsg_compose(s->s_env->sc_ibufs[PROC_PARENT], IMSG_PARENT_AUTHENTICATE,
	    0, 0, -1, &s->s_auth, sizeof(s->s_auth));
	s->s_flags |= F_EVLOCKED;
	bufferevent_disable(s->s_bev, EV_READ);
d258 2
a259 4
	imsg_compose(s->s_env->sc_ibufs[PROC_PARENT], IMSG_PARENT_AUTHENTICATE,
	    0, 0, -1, &s->s_auth, sizeof(s->s_auth));
	s->s_flags |= F_EVLOCKED;
	bufferevent_disable(s->s_bev, EV_READ);
d403 2
a404 4
	imsg_compose(s->s_env->sc_ibufs[PROC_MFA], IMSG_MFA_MAIL,
	    0, 0, -1, &s->s_msg, sizeof(s->s_msg));
	s->s_flags |= F_EVLOCKED;
	bufferevent_disable(s->s_bev, EV_READ);
d450 1
a450 4
	imsg_compose(s->s_env->sc_ibufs[PROC_MFA], IMSG_MFA_RCPT,
	    0, 0, -1, &mr, sizeof(mr));
	s->s_flags |= F_EVLOCKED;
	bufferevent_disable(s->s_bev, EV_READ);
d647 2
a648 5
		imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE],
		    IMSG_QUEUE_CREATE_MESSAGE, 0, 0, -1, &s->s_msg,
		    sizeof(s->s_msg));
		s->s_flags |= F_EVLOCKED;
		bufferevent_disable(s->s_bev, EV_READ);
d683 2
a684 5
		imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE],
		    IMSG_QUEUE_MESSAGE_FILE, 0, 0, -1, &s->s_msg,
		    sizeof(s->s_msg));
		s->s_flags |= F_EVLOCKED;
		bufferevent_disable(s->s_bev, EV_READ);
d914 4
a922 2
		s->s_flags |= F_EVLOCKED;
		bufferevent_disable(s->s_bev, EV_READ);
d945 2
a946 5
	imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE],
	    IMSG_QUEUE_COMMIT_MESSAGE, 0, 0, -1, &s->s_msg,
	    sizeof(s->s_msg));
	s->s_flags |= F_EVLOCKED;
	bufferevent_disable(s->s_bev, EV_READ);
d1033 29
@


1.65
log
@fixes for smtp auth LOGIN, inspired from smtp auth PLAIN fixes
(NUL terminate buffers, duh!)
with suggestions from oga@@
"please commit" jacekm@@, ok gilles@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.64 2009/04/09 19:49:34 jacekm Exp $	*/
d904 2
a905 1
	if (s_smtp.sessions_active < s->s_env->sc_maxconn)
@


1.64
log
@change syntax of the "listen on" and "relay via" directives:
1) kill the ssmtp keyword in "ssmtp listen on ...";
2) kill the use keyword in "... use certificate foo";
3) tls no longer implicit, user must explicitely use the tls or smtps option.
4) for "relay via", move the tls/smtps options to right after the
port specification; makes it similar to "listen on".

These directives:

  ssmtp listen on fxp0 use ceritifate "foo"
  accept for all relay via tls "mx.bar.com"

now become:

  listen on fxp0 smtps certificate "foo"
  accept for all relay via "mx.bar.com" tls

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.63 2009/03/15 19:32:10 gilles Exp $	*/
d209 1
d214 1
d222 5
a226 2
		if (kn_decode_base64(arg, req.buffer, 1024) == -1 ||
		    ! bsnprintf(s->s_auth.buffer + 1, sizeof(s->s_auth.buffer) - 1, "%s", req.buffer))
d229 1
d236 5
d242 1
a242 2
		if (kn_decode_base64(arg, req.buffer, 1024) == -1 ||
		    ! bsnprintf(s->s_auth.buffer + len + 2, sizeof(s->s_auth.buffer) - len - 2, "%s", req.buffer))
@


1.63
log
@since we are going to share code in smtp sessions and mta sessions, we need
to also share the statistics structure, still being worked on
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.62 2009/03/15 18:12:15 gilles Exp $	*/
d740 1
a740 1
	if (l->flags & F_SSMTP) {
@


1.62
log
@save 4 bytes per message by moving the datafp field of struct message to
struct session where it really belongs.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.61 2009/03/11 09:58:20 gilles Exp $	*/
d76 1
a76 1
extern struct s_smtp	s_smtp;
@


1.61
log
@fix log_info(), while other processes know about message uid, the smtp
process only knows about message id

bug spotted by pea@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.60 2009/03/10 22:33:26 jacekm Exp $	*/
d693 1
a693 1
		if (s->s_msg.datafp == NULL)
d815 1
a815 1
		if (! safe_fclose(s->s_msg.datafp))
d817 1
a817 1
		s->s_msg.datafp = NULL;
d850 2
a851 2
	if (fwrite(line, len, 1, s->s_msg.datafp) != 1 ||
	    fwrite("\n", 1, 1, s->s_msg.datafp) != 1) {
d910 3
a912 3
	if (s->s_msg.datafp != NULL) {
		fclose(s->s_msg.datafp);
		s->s_msg.datafp = NULL;
@


1.60
log
@implement basic logging, needs more work; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.59 2009/03/08 19:11:22 gilles Exp $	*/
d706 1
a706 1
		    s->s_msg.message_uid,
@


1.59
log
@shrink struct message a bit by removing a couple fields which are no longer
used and by moving the rcpt count in struct session where it really belongs

while at it, remove some unused splay tree generation in mfa
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.58 2009/02/22 11:59:12 jacekm Exp $	*/
d705 9
@


1.58
log
@put repeated inet_ntop calls into new func ss_to_text, which uses
getnameinfo internally; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.57 2009/02/19 11:33:25 jacekm Exp $	*/
d387 1
a388 1
	s->s_msg.rcptcount = 0;
d663 1
a663 1
			if (s->s_msg.rcptcount == 0)
d672 1
a672 1
		s->s_msg.rcptcount++;
@


1.57
log
@don't let libevent buffer long lines forever; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.56 2009/02/18 00:29:52 gilles Exp $	*/
a291 3
	void	*p;
	char	 addrbuf[INET6_ADDRSTRLEN];

d306 2
a307 15
	if (s->s_ss.ss_family == PF_INET) {
		struct sockaddr_in *ssin = (struct sockaddr_in *)&s->s_ss;
		p = &ssin->sin_addr.s_addr;
	}
	if (s->s_ss.ss_family == PF_INET6) {
		struct sockaddr_in6 *ssin6 = (struct sockaddr_in6 *)&s->s_ss;
		p = &ssin6->sin6_addr.s6_addr;
	}

	bzero(addrbuf, sizeof (addrbuf));
	inet_ntop(s->s_ss.ss_family, p, addrbuf, sizeof (addrbuf));

	session_respond(s, "250 %s Hello %s [%s%s], pleased to meet you",
	    s->s_env->sc_hostname, args,
	    s->s_ss.ss_family == PF_INET ? "" : "IPv6:", addrbuf);
a314 3
	void	*p;
	char	 addrbuf[INET6_ADDRSTRLEN];

d331 2
a332 15
	if (s->s_ss.ss_family == PF_INET) {
		struct sockaddr_in *ssin = (struct sockaddr_in *)&s->s_ss;
		p = &ssin->sin_addr.s_addr;
	}
	if (s->s_ss.ss_family == PF_INET6) {
		struct sockaddr_in6 *ssin6 = (struct sockaddr_in6 *)&s->s_ss;
		p = &ssin6->sin6_addr.s6_addr;
	}

	bzero(addrbuf, sizeof (addrbuf));
	inet_ntop(s->s_ss.ss_family, p, addrbuf, sizeof (addrbuf));
	session_respond(s, "250-%s Hello %s [%s%s], pleased to meet you",
	    s->s_env->sc_hostname, args,
	    s->s_ss.ss_family == PF_INET ? "" : "IPv6:", addrbuf);

@


1.56
log
@previous commit was incomplete, this fixes ssmtp
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.55 2009/02/18 00:17:39 gilles Exp $	*/
d787 5
a791 1
	if (line == NULL)
d793 1
@


1.55
log
@smtp_accept() now requests from lka that it performs the hostname lookup
and inserts the session into the session tree. session_init() is called
only when we receive the resolution answer.

this fixes a race condition that would sometimes cause the hostname to
appear as "<unknown>" in headers just because dns was lagging, and it
unbreaks ssmtp support which suffered from th very same race condition.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.54 2009/02/17 21:53:55 gilles Exp $	*/
d765 2
d770 2
@


1.54
log
@after a message has been commited to queue, do not incondtionnally clear
the message id and uid immediately. only do it if session has been flagged
with F_QUIT, otherwise session_pickup() will do it when in state S_DONE.

this fixes a bug reported by pea@@ where the message id was not displayed
in the "message accepted for delivery" line.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.53 2009/02/13 19:59:49 jacekm Exp $	*/
a757 1
	s->s_id = queue_generate_id();
a761 9

	strlcpy(s->s_hostname, "<unknown>", MAXHOSTNAMELEN);
	strlcpy(s->s_msg.session_hostname, s->s_hostname, MAXHOSTNAMELEN);
	imsg_compose(s->s_env->sc_ibufs[PROC_LKA], IMSG_LKA_HOST, 0, 0, -1, s,
	    sizeof(struct session));
	s->s_flags |= F_EVLOCKED;
	bufferevent_disable(s->s_bev, EV_READ);

	SPLAY_INSERT(sessiontree, &s->s_env->sc_sessions, s);
@


1.53
log
@Ensure ss is never dereferenced when NULL. Can't happen with current code,
but it could in future, and fatal is better than segv. Reported by sthen@@.
ok gilles@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.52 2009/01/30 21:52:55 gilles Exp $	*/
a734 1
		s->s_msg.message_id[0] = '\0';
d737 2
a738 1

@


1.52
log
@when decreasing ssl related counters, make sure the session was flagged as
F_SECURE. while at it, add "smtp.sessions.aborted" which keeps track of
sessions which were interrupted before completion.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.51 2009/01/30 21:40:21 gilles Exp $	*/
d664 2
d684 2
a685 1

d690 2
d708 2
d723 2
@


1.51
log
@improve statistics for smtp process. not only collect the current sessions
count, but also the total sessions count, ssmtp sessions (both current and
total) and starttls sessions (both current and total)

# ./smtpctl/smtpctl show stats|grep smtp.sessions
smtp.sessions = 0
smtp.sessions.active = 0
smtp.sessions.ssmtp = 0
smtp.sessions.ssmtp.active = 0
smtp.sessions.starttls = 0
smtp.sessions.starttls.active = 0
#
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.50 2009/01/30 21:22:33 gilles Exp $	*/
d950 1
@


1.50
log
@clear the F_EVLOCK flag earlier to prevent the error event handler from
being called again with F_EVLOCK set. this fixes a bug where disconnect
after smtpd sends greeting and before entering any command failed to go
into session_destroy().

while at it, rename the "smtp.clients" statistic to "smtp.sessions" and
add counters to struct s_smtp so that I can add ssmtp and starttls with
my next commit ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.49 2009/01/30 17:34:58 gilles Exp $	*/
d908 2
a909 2
	s_smtp.sessions--;
	if (s_smtp.sessions < s->s_env->sc_maxconn)
@


1.49
log
@bump descriptors limit to the max and set the maximum connections count to
three quarters of that limit (a session typically has 3 descriptors). when
we hit that limit, we stop accepting connections, and when client closes a
session, we start accepting connections again. this prevents us from going
into a session that is likely to fail because of scarce resources.

idea discussed with jacekm@@, code mostly ripped from relayd
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.48 2009/01/30 16:37:52 gilles Exp $	*/
a607 1
	s->s_flags &= ~F_EVLOCKED;
a638 1
	s->s_flags &= ~F_EVLOCKED;
d908 2
a909 2
	s_smtp.clients--;
	if (s_smtp.clients < s->s_env->sc_maxconn)
@


1.48
log
@fix a very annoying events masking issue which would cause a fatal() to be
hit under certain conditions; while tracking the bug I ran into other bugs
which were kind of related and could cause us to hit a fatal() too.

fix by me, but with lots of testing and investigation with jacekm@@,
ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.47 2009/01/29 21:59:15 jacekm Exp $	*/
a750 2
	s->s_env = l->env;
	s->s_l = l;
a752 2
	s_smtp.clients++;

d911 2
@


1.47
log
@Implement "smtpctl show stats"; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.46 2009/01/29 15:40:35 gilles Exp $	*/
d199 1
d250 1
d429 1
d478 1
d608 1
d640 1
d659 1
d679 1
a685 1

a702 1
		session_respond(s, "%d Recipient ok", ss->code);
d705 1
d713 1
a734 1
		log_debug("session_pickup: state value: %d", s->s_state);
d757 4
d765 2
a766 4

	if ((s->s_bev = bufferevent_new(s->s_fd, session_read, session_write,
	    session_error, s)) == NULL)
		fatalx("session_init: bufferevent_new failed");
a774 2

	session_pickup(s, NULL);
d940 2
d950 8
a957 1
	session_destroy(s);
d966 1
@


1.46
log
@missing prototype for session_respond() in mta, move session_respond()'s
prototype to smtpd.h
spotted and diff from Oleg Safiullin <form@@pdp-11.org.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.45 2009/01/29 15:27:34 gilles Exp $	*/
d76 2
d748 2
d906 2
@


1.45
log
@- remove debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.44 2009/01/29 15:20:34 gilles Exp $	*/
a73 2
void		session_respond(struct session *, char *, ...)
		    __attribute__ ((format (printf, 2, 3)));
@


1.44
log
@Received header line was incomplete for mail submitted through the enqueuer
as well as for some outgoing messages, this is fixed now
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.43 2009/01/28 18:10:19 jacekm Exp $	*/
a373 3


	log_debug("messagep->helo: %s / args", s->s_msg.session_helo, args);
@


1.43
log
@reuse recipient_to_path; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.42 2009/01/28 17:29:11 jacekm Exp $	*/
d374 3
@


1.42
log
@Make races between queue and runner impossible by implementing the policy:
1) queue never reads /queue.
2) queue writes to /queue only at message injection time.
3) runner does all reading, and all writing apart from 2).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.41 2009/01/28 11:27:57 gilles Exp $	*/
a968 2
	char *username;
	char *hostname;
d975 1
a975 26
	username = line + 1;
	hostname = strchr(username, '@@');

	if (username[0] == '\0') {
		*path->user = '\0';
		*path->domain = '\0';
		return 1;
	}

	if (hostname == NULL) {
		if (strcasecmp(username, "postmaster") != 0)
			return 0;
		hostname = "localhost";
	} else {
		*hostname++ = '\0';
	}

	if (strlcpy(path->user, username, sizeof(path->user))
	    >= MAX_LOCALPART_SIZE)
		return 0;

	if (strlcpy(path->domain, hostname, sizeof(path->domain))
	    >= MAX_DOMAINPART_SIZE)
		return 0;

	return 1;
@


1.41
log
@add a struct path to struct message so that we can keep track of the RCPT
provided recipient even after aliases/forwards expansion, we'll need this
for loop detection.

message id and uid being MAXPATHLEN long is a waste, define MAX_ID_SIZE
which is currently set to 64 (but can probably be further reduced) and
make sure that structures and the few strlcpy's use the right define.

original idea by jacekm@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.40 2009/01/12 19:56:27 jacekm Exp $	*/
d720 1
a720 1

@


1.40
log
@dot escaping, as required by rfc; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.39 2009/01/04 00:58:59 gilles Exp $	*/
d459 2
@


1.39
log
@aliases/forwards expansion was not done correctly and a race could
cause delivery to happen before expansion is over, causing some of
the recipients to never receive the mail. change how the mfa, lka,
queue and smtp processes communicate to ensure smtp never receives
an acknowledgment before ALL expanded envelopes are on disk. While
at it, lka was doing work which belongs in mfa, fix that also.

this is based on an idea from a talk with jacekm@@, change not over
but already better than what we had.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.38 2009/01/01 16:15:47 jacekm Exp $	*/
d821 1
a821 1
	size_t len = strlen(line);
d851 8
@


1.38
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.37 2008/12/22 13:21:39 jacekm Exp $	*/
d463 1
d635 2
a636 1
	if (ss != NULL && ss->code == 421)
d694 1
a694 5
		imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE],
		    IMSG_QUEUE_SUBMIT_ENVELOPE, 0, 0, -1, &s->s_msg,
		    sizeof(s->s_msg));
		bufferevent_disable(s->s_bev, EV_READ);
		break;
a696 1
		session_respond(s, "%d Recipient ok", ss->code);
@


1.37
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.36 2008/12/22 00:44:32 jacekm Exp $	*/
a33 1
#include <signal.h>
a36 1
#include <time.h>
@


1.36
log
@To reset state, it's enough to set s->s_state = S_HELO, rcptcount
is zeroed in MAIL FROM handler; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.35 2008/12/21 19:27:57 jacekm Exp $	*/
d750 1
d753 2
a754 5

	SPLAY_INSERT(sessiontree, &s->s_env->sc_sessions, s);

	imsg_compose(s->s_env->sc_ibufs[PROC_LKA], IMSG_LKA_HOST,
	    0, 0, -1, s, sizeof(struct session));
d758 3
a760 1
		fatal(NULL);
@


1.35
log
@fix session flags resetting; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.34 2008/12/21 18:51:08 gilles Exp $	*/
a382 1
	s->s_msg.rcptcount = 0;
@


1.34
log
@- missing prototype + smtp.c was misusing session_auth_pickup()
- unlike starttls, ssmtp sets the F_SECURE flag on session before helo/ehlo
	handlers are called. this means that if we clear all flags in helo/
	helo handlers, we prevent smtpd from advertising AUTH as it will do
	so only for F_SECURE sessions. This commits unbreaks SMTP AUTH with
	smtp sessions. Problem spotted by James Turner <james@@bsdgroup.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.33 2008/12/21 02:18:46 gilles Exp $	*/
d307 1
a307 2
	if (s->s_flags & F_SECURE)
		s->s_flags = F_SECURE;
d346 1
a346 2
	if (s->s_flags & F_SECURE)
		s->s_flags = F_SECURE;
@


1.33
log
@- AUTH PLAIN may receive credentials as a parameter to AUTH or on a
	following line, this commit brings support for the latter which was
	not supported yet.
- AUTH LOGIN is now supported, allowing smtp auth support on clients that
	do not support AUTH PLAIN (ie: my mobile phone for instance ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.32 2008/12/20 00:18:03 gilles Exp $	*/
d307 2
a308 1
	s->s_flags = 0;
d347 3
a349 1
	s->s_flags = F_EHLO;
@


1.32
log
@- import first bricks of SMTP AUTH support. currently only AUTH PLAIN is
	supported, AUTH LOGIN will follow soon. AUTH will only work if a
	listen directive has "enable auth" keywords, AND session is safe
	(ssmtp or starttls).
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.31 2008/12/18 23:57:17 jacekm Exp $	*/
d33 1
d41 2
d64 3
a152 1
	struct session_auth_req req;
d171 22
a192 2
	if (eom == NULL) {
		/* NEEDS_FIX - unsupported yet */
d197 31
a227 4
	req.session_id = s->s_id;
	if (strlcpy(req.buffer, eom, sizeof(req.buffer)) >=
	    sizeof(req.buffer)) {
		session_respond(s, "501 Syntax error");
d229 11
d242 6
a247 1
	s->s_state = S_AUTH;
d250 1
a250 1
	    0, 0, -1, &req, sizeof(req));
d254 4
d372 1
a372 1
		session_respond(s, "250-AUTH %s", "PLAIN");
d598 31
a655 7
	case S_AUTH:
		if (s->s_flags & F_AUTHENTICATED)
			session_respond(s, "235 Authentication succeeded");
		else
			session_respond(s, "535 Authentication failed");
		break;

d795 6
@


1.31
log
@Introduce safe_fclose, which tries to push file to the disk as
quickly as possible; it fails under temporary error conditions,
letting caller react appropriately.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.30 2008/12/18 23:49:56 jacekm Exp $	*/
d299 1
a299 2
	/*
	if (s->s_flags & F_SECURE)
d301 1
a301 1
	 */
d394 6
d502 8
a509 7
	/*
	for (i = 0; i < (int)(sizeof(rfc4954_cmdtab) / sizeof(struct session_cmd)); ++i)
		if (strcasecmp(rfc4954_cmdtab[i].name, cmd) == 0)
			break;
	if (i < (int)(sizeof(rfc4954_cmdtab) / sizeof(struct session_cmd))) {
		if (rfc4954_cmdtab[i].func(s, args))
			return;
a510 1
	*/
@


1.30
log
@Declarations for functions used only in smtp_session.c were moved
to that file from smtpd.h.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.29 2008/12/18 23:38:12 jacekm Exp $	*/
d723 1
a723 1
		if (fclose(s->s_msg.datafp))
@


1.29
log
@Check fwrite return code at DATA stage.

Add basic line length checking, as required by rfc.

It is no longer required to disable EV_READ upon evbuffer_readline failure.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.28 2008/12/18 15:11:21 jacekm Exp $	*/
d62 5
@


1.28
log
@Cleanup /incoming before handling each MAIL FROM.
Improve cleanup condition to cover more cases.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.27 2008/12/13 23:19:34 jacekm Exp $	*/
d672 1
d676 1
d678 1
a678 3
	if (line == NULL) {
		if (s->s_state != S_DATACONTENT)
			bufferevent_disable(s->s_bev, EV_READ);
d680 1
a680 1
	}
d683 1
a683 14
		/*log_debug("content: %s", line);*/
		if (strcmp(line, ".") == 0) {
			s->s_state = S_DONE;
			fclose(s->s_msg.datafp);
			s->s_msg.datafp = NULL;

			bufferevent_disable(s->s_bev, EV_READ);

			if (s->s_msg.status & S_MESSAGE_PERMFAILURE) {
				session_respond(s, "554 Transaction failed");
				free(line);
				return;
			}
			session_msg_submit(s);
a685 20
		} else {
			size_t i;
			size_t len;

			len = strlen(line);
			fwrite(line, 1, len, s->s_msg.datafp);
			fwrite("\n", 1, 1, s->s_msg.datafp);
			fflush(s->s_msg.datafp);

			if (! (s->s_flags & F_8BITMIME)) {
				for (i = 0; i < len; ++i) {
					if (line[i] & 0x80) {
						s->s_msg.status |= S_MESSAGE_PERMFAILURE;
						strlcpy(s->s_msg.session_errorline,
						    "8BIT data transfered over 7BIT limited channel",
							sizeof s->s_msg.session_errorline);
					}
				}
			}
			free(line);
d687 1
d691 5
d711 53
d829 1
@


1.27
log
@IMSG_* namespace cleanup.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.26 2008/12/07 15:41:16 jacekm Exp $	*/
d67 1
d342 2
a344 2

	s->s_state = S_MAILREQUEST;
a692 4

				/* Remove message file */
				imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_REMOVE_MESSAGE,
				    0, 0, -1, &s->s_msg, sizeof(s->s_msg));
d757 2
a758 3
	/*
	 * cleanup
	 */
a761 10
	if (s->s_msg.datafp != NULL) {
		fclose(s->s_msg.datafp);
		s->s_msg.datafp = NULL;
	}

	if (s->s_state >= S_MAIL) {
		imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_REMOVE_MESSAGE,
		    0, 0, -1, &s->s_msg, sizeof(s->s_msg));
	}

d770 17
@


1.26
log
@Disable EV_READ when sending IMSG_PARENT_AUTHENTICATE.

This is for consistency, code is not reached yet.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.25 2008/12/07 15:38:35 jacekm Exp $	*/
d350 1
a350 1
	imsg_compose(s->s_env->sc_ibufs[PROC_MFA], IMSG_MFA_RPATH_SUBMIT,
d389 1
a389 1
	imsg_compose(s->s_env->sc_ibufs[PROC_MFA], IMSG_MFA_RCPT_SUBMIT,
d648 1
a648 1
	imsg_compose(s->s_env->sc_ibufs[PROC_LKA], IMSG_LKA_HOSTNAME_LOOKUP,
@


1.25
log
@Replace evbuffer_add_printf calls with wrapper function, session_respond,
which additionally suffixes <CRLF>, and enables EV_WRITE.

Remove bufferevent_enable(.., EV_WRITE) from session_command and
session_pickup so that EV_WRITE is enabled in exactly one place,
session_respond.

Change some responses slightly to make code fit 80 columns.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.24 2008/12/07 01:03:25 jacekm Exp $	*/
d177 1
@


1.24
log
@Don't check / reset s->s_msg.datafp where its state is obviously known.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.23 2008/12/06 14:58:09 jacekm Exp $	*/
d65 2
d120 1
a120 2
		evbuffer_add_printf(s->s_bev->output,
		    "503 Polite people say HELO first\r\n");
d125 1
a125 2
		evbuffer_add_printf(s->s_bev->output,
		    "501 Syntax error (no parameters allowed)\r\n");
d129 1
a129 2
	evbuffer_add_printf(s->s_bev->output,
	    "220 Ready to start TLS\r\n");
d144 1
a144 2
		evbuffer_add_printf(s->s_bev->output,
		    "503 Polite people say HELO first\r\n");
d149 1
a149 2
		evbuffer_add_printf(s->s_bev->output,
		    "501 Syntax error (no parameters given)\r\n");
d162 1
a162 2
		evbuffer_add_printf(s->s_bev->output,
		    "501 Syntax error\r\n");
d169 1
a169 2
		evbuffer_add_printf(s->s_bev->output,
		    "501 Syntax error\r\n");
d187 1
a187 2
		evbuffer_add_printf(s->s_bev->output,
		    "503 Polite people say HELO first\r\n");
d200 1
a200 2
			evbuffer_add_printf(s->s_bev->output,
			    "503 Invalid BODY\r\n");
d217 1
a217 2
		evbuffer_add_printf(s->s_bev->output,
		    "501 HELO requires domain address.\r\n");
d223 1
a223 2
		evbuffer_add_printf(s->s_bev->output,
		    "501 Invalid domain name\r\n");
d242 1
a242 2
	evbuffer_add_printf(s->s_bev->output,
	    "250 %s Hello %s [%s%s], pleased to meet you\r\n",
d256 1
a256 2
		evbuffer_add_printf(s->s_bev->output,
		    "501 EHLO requires domain address.\r\n");
d262 1
a262 2
		evbuffer_add_printf(s->s_bev->output,
		    "501 Invalid domain name\r\n");
d281 1
a281 2
	evbuffer_add_printf(s->s_bev->output,
	    "250-%s Hello %s [%s%s], pleased to meet you\r\n",
d285 1
a285 1
	evbuffer_add_printf(s->s_bev->output, "250-8BITMIME\r\n");
d289 1
a289 1
		evbuffer_add_printf(s->s_bev->output, "250-STARTTLS\r\n");
d294 1
a294 1
		evbuffer_add_printf(s->s_bev->output, "250-AUTH %s\r\n", "PLAIN");
d296 1
a296 1
	evbuffer_add_printf(s->s_bev->output, "250 HELP\r\n");
d306 1
a306 1
	evbuffer_add_printf(s->s_bev->output, "250 Reset state.\r\n");
d314 1
a314 1
	evbuffer_add_printf(s->s_bev->output, "250 OK.\r\n");
d325 1
a325 2
		evbuffer_add_printf(s->s_bev->output,
		    "503 Polite people say HELO first\r\n");
d330 1
a330 2
		evbuffer_add_printf(s->s_bev->output,
		    "553 Syntax error for sender address\r\n");
d336 1
a336 2
		evbuffer_add_printf(s->s_bev->output,
		    "553 Syntax error for sender address\r\n");
d362 1
a362 2
		evbuffer_add_printf(s->s_bev->output,
		    "503 Polite people say HELO first\r\n");
d367 1
a367 2
		evbuffer_add_printf(s->s_bev->output,
		    "503 Need MAIL before RCPT\r\n");
d374 1
a374 2
		evbuffer_add_printf(s->s_bev->output,
		    "553 Syntax error for recipient address\r\n");
d380 1
a380 2
		evbuffer_add_printf(s->s_bev->output,
		    "553 Syntax error for recipient address\r\n");
d397 1
a397 2
	evbuffer_add_printf(s->s_bev->output, "221 %s Closing connection.\r\n",
	    s->s_env->sc_hostname);
d408 1
a408 2
		evbuffer_add_printf(s->s_bev->output,
		    "503 Polite people say HELO first\r\n");
d413 1
a413 2
		evbuffer_add_printf(s->s_bev->output,
		    "503 Need MAIL before DATA\r\n");
d418 1
a418 2
		evbuffer_add_printf(s->s_bev->output,
		    "503 Need RCPT before DATA\r\n");
d430 1
a430 2
	evbuffer_add_printf(s->s_bev->output,
	    "252 Cannot VRFY user; try RCPT to attempt delivery.\r\n");
d438 1
a438 2
	evbuffer_add_printf(s->s_bev->output,
	    "502 Sorry, we do not allow this operation.\r\n");
d446 1
a446 2
	evbuffer_add_printf(s->s_bev->output,
	    "502 Sorry, we do not allow this operation.\r\n");
d454 5
a458 6
	evbuffer_add_printf(s->s_bev->output,
	    "214- This is OpenSMTPD\r\n"
	    "214- To report bugs in the implementation, please contact\r\n"
	    "214- bugs@@openbsd.org with full details\r\n");
	evbuffer_add_printf(s->s_bev->output,
	    "214 End of HELP info\r\n");
a467 2
	bufferevent_enable(s->s_bev, EV_WRITE);

d510 1
a510 2
	evbuffer_add_printf(s->s_bev->output,
	    "500 Command unrecognized.\r\n");
d519 1
a519 1
	bufferevent_enable(s->s_bev, EV_READ|EV_WRITE);
d528 1
a528 2
		evbuffer_add_printf(s->s_bev->output,
		    SMTPD_BANNER, s->s_env->sc_hostname);
d542 4
a545 8
		if (s->s_flags & F_AUTHENTICATED) {
			evbuffer_add_printf(s->s_bev->output,
			    "235 Authentication Succeeded\r\n");
		}
		else {
			evbuffer_add_printf(s->s_bev->output,
			    "535 Authentication Credentials Invalid\r\n");
		}
d552 1
a552 2
			evbuffer_add_printf(s->s_bev->output,
			    "%d Sender rejected\r\n", ss->code);
d567 1
a567 2
		evbuffer_add_printf(s->s_bev->output, "%d Sender ok\r\n",
		    ss->code);
d579 1
a579 2
			evbuffer_add_printf(s->s_bev->output,
			    "%d Recipient rejected\r\n", ss->code);
d593 1
a593 2
		evbuffer_add_printf(s->s_bev->output, "%d Recipient ok\r\n",
		    ss->code);
d609 2
a610 2
		evbuffer_add_printf(s->s_bev->output,
		    "354 Enter mail, end with \".\" on a line by itself\r\n");
d616 1
a616 2
		evbuffer_add_printf(s->s_bev->output,
		    "250 %s Message accepted for delivery\r\n",
d631 1
a631 2
	evbuffer_add_printf(s->s_bev->output,
	    "421 Service temporarily unavailable\r\n");
d690 1
a690 3
				bufferevent_disable(s->s_bev, EV_WRITE);
				evbuffer_add_printf(s->s_bev->output,
				    "554 Transaction failed\r\n");
d900 13
@


1.23
log
@In session_destroy, use "if (s->s_state >= S_MAIL)", and not
"if (s->s_state > S_MAIL)". Otherwise, session timeout after
MAIL FROM would leave mess in queue.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.22 2008/12/06 14:30:51 jacekm Exp $	*/
a595 7
		if (s->s_msg.datafp != NULL) {
			fclose(s->s_msg.datafp);
			s->s_msg.datafp = NULL;
			imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_REMOVE_MESSAGE,
			    0, 0, -1, &s->s_msg, sizeof(s->s_msg));
		}

a655 1
		s->s_msg.datafp = NULL;
@


1.22
log
@Don't include <err.h> where log.c API must be used.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.21 2008/12/06 04:49:52 jacekm Exp $	*/
d822 1
a822 1
	if (s->s_state > S_MAIL) {
@


1.21
log
@NULL-ify s_msg.datafp upon fclose unconditionally.

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.20 2008/12/06 02:43:58 jacekm Exp $	*/
a29 1
#include <err.h>
@


1.20
log
@evbuffer_readline already strips <CRLF> so that callers don't have to.

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.19 2008/12/05 17:29:11 gilles Exp $	*/
d736 1
a744 1
				s->s_msg.datafp = NULL;
@


1.19
log
@- cosmethic, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.18 2008/12/04 23:02:12 gilles Exp $	*/
a731 1
		line[strcspn(line, "\r")] = '\0';
a777 1
	line[strcspn(line, "\r")] = '\0';
@


1.18
log
@- in session_read(), set EV_WRITE if we are going to send a "transaction
	failed" error. found by Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.17 2008/12/04 04:09:55 gilles Exp $	*/
d626 1
a626 1
			    "%d %s\r\n", ss->code, "Recipient rejected");
@


1.17
log
@- when in state S_DATACONTENT, do not disable EV_READ if the last line we
	read is empty, instead return and only disable EV_READ when we read
	"."
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.16 2008/12/04 02:04:50 gilles Exp $	*/
d741 1
@


1.16
log
@- when doing the session timeout lookup, do not remove the last session
	that timed out twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.15 2008/12/04 01:16:14 gilles Exp $	*/
d726 2
a727 1
		bufferevent_disable(s->s_bev, EV_READ);
d733 1
a733 1
		/*		log_debug("content: %s", line);*/
d738 2
a750 1
			bufferevent_disable(s->s_bev, EV_READ);
@


1.15
log
@- fix event masking for DATA and make DATA look more like MAIL and RCPT
	with regard to communication with queue process (one state before
	sending imsg, another state when imsg has returned). this fixes an
	issue that I observed when clients send DATA and content without
	even looking at server replies.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.14 2008/12/03 17:58:00 gilles Exp $	*/
d814 1
a814 1
	log_debug("session_destroy: killing client");
d923 1
a923 1
		if (rmsession != NULL)
d925 2
@


1.14
log
@- fix event masking issues in smtp process which could lead to a fatal() if
	queue process did not answer fast enough to an imsg. spotted by
	Jacek Masiulaniec <jacekm@@dobremiasto.net>
- queue layout was mostly to bootstrap the project, it does not behave good
	under load, it does complex things to stay in a recoverable state
	and it probably didnt do it too well. New queue code is simpler,
	smaller and allows for atomic submissions (a mail can never be in a
	state where it needs to be recovered). It still needs some work but
	works better than previous code, no regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.13 2008/11/25 20:35:54 gilles Exp $	*/
d368 1
a368 1

d411 1
a411 1

d447 2
a448 5
	s->s_state = S_DATA;
	imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE],
	    IMSG_QUEUE_MESSAGE_FILE, 0, 0, -1, &s->s_msg,
	    sizeof(s->s_msg));
	bufferevent_disable(s->s_bev, EV_READ);
d644 8
a660 3
	case S_DATACONTENT:
		break;

d726 1
d732 1
@


1.13
log
@- plug memory leak
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.12 2008/11/25 15:58:14 gilles Exp $	*/
a405 1

d448 4
a451 2
	session_pickup(s, NULL);

d500 2
d554 4
a557 2
	bufferevent_disable(s->s_bev, EV_READ);
	bufferevent_enable(s->s_bev, EV_WRITE);
d572 1
a574 1
		bufferevent_disable(s->s_bev, EV_READ|EV_WRITE);
d600 7
d608 1
a608 1
		    IMSG_QUEUE_CREATE_MESSAGE_FILE, 0, 0, -1, &s->s_msg,
d610 1
a610 1

a613 2
		evbuffer_add_printf(s->s_bev->output,
		    "%d Sender ok\r\n", ss->code);
d615 2
a616 1
		strlcpy(s->s_msg.message_id, ss->u.msgid, MAXPATHLEN);
a617 6
		if (s->s_msg.datafp == NULL) {
			/* Remove message file */
			imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_DELETE_MESSAGE_FILE,
			    0, 0, -1, &s->s_msg, sizeof(s->s_msg));
			return;
		}
d637 1
a637 1
		    IMSG_QUEUE_MESSAGE_SUBMIT, 0, 0, -1, &s->s_msg,
d639 1
a639 1

d643 2
a644 2
		evbuffer_add_printf(s->s_bev->output,
		    "%d Recipient ok\r\n", ss->code);
d648 3
a650 5
		if (s->s_msg.datafp == NULL) {
			evbuffer_add_printf(s->s_bev->output,
			    "421 Service temporarily unavailable\r\n");
			return;
		}
d661 1
d674 8
a723 2
		bufferevent_disable(s->s_bev, EV_READ);
		bufferevent_enable(s->s_bev, EV_WRITE);
d739 1
a739 1
				imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_DELETE_MESSAGE_FILE,
a740 1
				bufferevent_enable(s->s_bev, EV_WRITE);
d761 2
a762 1
						strlcpy(s->s_msg.session_errorline, "8BIT data transfered over 7BIT limited channel",
a770 2
	bufferevent_disable(s->s_bev, EV_READ);
	bufferevent_enable(s->s_bev, EV_WRITE);
d794 1
a794 5
		if (! EVBUFFER_LENGTH(EVBUFFER_OUTPUT(bev))) {
			bufferevent_disable(s->s_bev, EV_WRITE);
			bufferevent_enable(s->s_bev, EV_READ);
		}

d801 1
a801 3
	if (! EVBUFFER_LENGTH(EVBUFFER_OUTPUT(bev))) {
		session_destroy(s);
	}
d816 4
a819 2
		/* Remove message file */
		imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_DELETE_MESSAGE_FILE,
a823 1
		bufferevent_disable(s->s_bev, EV_READ|EV_WRITE);
d845 1
a845 1
	    IMSG_QUEUE_MESSAGE_COMPLETE, 0, 0, -1, &s->s_msg,
@


1.12
log
@- update email address for bug reports when replying to HELP
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.11 2008/11/25 15:55:13 gilles Exp $	*/
d757 1
@


1.11
log
@- F_IMSG_SENT is no longer used, kill
	suggested by Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.10 2008/11/24 23:55:25 gilles Exp $	*/
d487 1
a487 1
	    "214- bugs@@poolp.org\r\n");
@


1.10
log
@- when using fread/fwrite, do not swap the size and nmemb arguments. no
	functionnal change here, just making use of fonctions the way C
	intended it ;-)
From Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.9 2008/11/17 21:56:18 chl Exp $	*/
a359 1
	s->s_flags |= F_IMSG_SENT;
a407 1
	s->s_flags |= F_IMSG_SENT;
a709 1
	s->s_flags &= ~F_IMSG_SENT;
@


1.9
log
@add missing header needed by time(), ctime_r() and tzset().

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.8 2008/11/17 21:52:00 gilles Exp $	*/
d747 2
a748 2
			fwrite(line, len, 1, s->s_msg.datafp);
			fwrite("\n", 1, 1,  s->s_msg.datafp);
@


1.8
log
@- clear session flags upon helo/ehlo
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.7 2008/11/17 21:50:43 gilles Exp $	*/
d38 1
@


1.7
log
@- until now a client could issue a command from an extension even though it
	greeted with helo and not ehlo. introduce session flag F_EHLO and
	make sure the session_command() dispatch only looks at extensions
	when a session does not have the F_EHLO flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.6 2008/11/17 20:11:27 gilles Exp $	*/
d237 1
d279 1
a279 1
	s->s_flags |= F_EHLO;
@


1.6
log
@- remove several constructs where format strings are used in an evbuffer
	printf with constant parameters, turn them into a constant string.
- when client sends EHLO without a parameter, send the appropriate error
	message ("EHLO takes ..." instead of "HELO takes ...")

From Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.5 2008/11/11 01:08:08 gilles Exp $	*/
d278 1
d499 3
d531 1
@


1.5
log
@- queue process no longer schedules messages which do not have flag
	F_MESSAGE_COMPLETE
- submit recipients to the queue as we read them from RCPT instead of
	submiting them all at once when DATA is over. this prevents us
	from having to keep a potentially large number of recipients in
	memory during the whole session.
- remove all code that dealt with the recipients queue of a message as
	it is no longer used.
- several small changes to make sure the server is always in a recoverable
	state in case of an unexpected shutdown.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.4 2008/11/10 23:18:47 gilles Exp $	*/
d266 1
a266 1
		    "501 HELO requires domain address.\r\n");
d343 1
a343 1
		    "%d %s\r\n", 553, "Syntax error for sender address");
d350 1
a350 1
		    "%d %s\r\n", 553, "Syntax error for sender address");
d392 1
a392 1
		    "%d %s\r\n", 553, "Syntax error for recipient address");
d399 1
a399 1
		    "%d %s\r\n", 553, "Syntax error for recipient address");
d640 1
a640 2
			    "%d %s\r\n", 421,
			    "Service temporarily unavailable");
d645 1
a645 2
		    "%d %s\r\n", 354,
		    "Enter mail, end with \".\" on a line by itself");
@


1.4
log
@- open the message file earlier after a successful MAIL command instead of
	waiting for the DATA command. this currently has no impact on the
	session but is needed for another change that will make submission
	of recipients safer with regard to "unexpected shutdowns at bad
	timings"
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.3 2008/11/10 17:24:24 deraadt Exp $	*/
a314 7
	struct path *pathp;

	while ((pathp = TAILQ_FIRST(&s->s_msg.recipients)) != NULL) {
		TAILQ_REMOVE(&s->s_msg.recipients, pathp, entry);
		free(pathp);
	}

a332 1
	struct path *pathp;
a353 4
	while ((pathp = TAILQ_FIRST(&s->s_msg.recipients)) != NULL) {
		TAILQ_REMOVE(&s->s_msg.recipients, pathp, entry);
		free(pathp);
	}
d356 1
a356 1
	s->s_state = S_MAILGETFILE;
d405 1
a405 1
	s->s_state = S_RCPT;
a406 1

a542 2
	struct path *path;

d578 1
a578 1
	case S_MAILGETFILE:
d588 2
a596 2

		s->s_msg.sender = ss->u.path;
d600 2
d610 1
a610 1
	case S_RCPT:
d616 2
d623 1
a623 5
		path = calloc(1, sizeof(struct path));
		if (path == NULL)
			err(1, "calloc");
		*path = ss->u.path;
		TAILQ_INSERT_TAIL(&s->s_msg.recipients, path, entry);
d625 8
a653 4
		s->s_msg.rcptcount--;
		if (s->s_msg.rcptcount)
			return;

a675 1

d677 1
a677 2

	TAILQ_INIT(&s->s_msg.recipients);
a801 2
	struct path *pathp;

a821 5
	while ((pathp = TAILQ_FIRST(&s->s_msg.recipients)) != NULL) {
		TAILQ_REMOVE(&s->s_msg.recipients, pathp, entry);
		free(pathp);
	}

d838 4
a841 9
	struct path *rpath;

	strlcpy(s->s_msg.session_hostname, s->s_hostname, MAXHOSTNAMELEN);
	TAILQ_FOREACH(rpath, &s->s_msg.recipients, entry) {
		s->s_msg.recipient = *rpath;
		imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE],
		    IMSG_QUEUE_MESSAGE_SUBMIT, 0, 0, -1, &s->s_msg,
		    sizeof(s->s_msg));
	}
@


1.3
log
@spaces fixed while reading code
@
text
@d1 1
a1 1
/*	$OpenBSD: smtp_session.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d368 1
a368 1
	s->s_state = S_MAIL;
d371 2
d461 1
a461 7
	s->s_flags |= F_IMSG_SENT;
	s->s_msg.session_id = s->s_id;
	s->s_msg.session_ss = s->s_ss;

	imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE],
	    IMSG_QUEUE_CREATE_MESSAGE_FILE, 0, 0, -1, &s->s_msg,
	    sizeof(s->s_msg));
d593 1
a593 1
	case S_MAIL:
d602 9
d614 7
a645 3
			/* Remove message file */
			imsg_compose(s->s_env->sc_ibufs[PROC_QUEUE], IMSG_QUEUE_DELETE_MESSAGE_FILE,
			    0, 0, -1, &s->s_msg, sizeof(s->s_msg));
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d171 1
a171 1
	if (strlcpy(req.buffer, eom, sizeof(req.buffer)) >= 
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

