head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.7.0.6
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.10
date	2017.02.04.19.25.24;	author guenther;	state Exp;
branches;
next	1.9;
commitid	VWNunXXv8AMLk1ub;

1.9
date	2016.10.13.15.47.32;	author gilles;	state Exp;
branches;
next	1.8;
commitid	qen1i3tp9AWn8jny;

1.8
date	2016.08.20.20.47.08;	author eric;	state Exp;
branches;
next	1.7;
commitid	7WDyGaCRuA92Mjxf;

1.7
date	2016.02.04.22.35.17;	author eric;	state Exp;
branches
	1.7.2.1
	1.7.6.1;
next	1.6;
commitid	g2b5tfVfePI55hjT;

1.6
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.5;
commitid	ZxnqOQqX6IeYI9jW;

1.5
date	2015.11.05.08.55.09;	author gilles;	state Exp;
branches;
next	1.4;
commitid	TVpp1PxacTHNqZd0;

1.4
date	2015.09.07.15.36.53;	author gilles;	state Exp;
branches;
next	1.3;
commitid	8taqn8BdlYqlAC0r;

1.3
date	2014.11.23.21.27.53;	author gilles;	state Exp;
branches;
next	1.2;
commitid	l7IdWZzlPVcsga3B;

1.2
date	2014.10.15.19.23.29;	author gilles;	state Exp;
branches;
next	1.1;
commitid	BVF5vY3hDrZuySna;

1.1
date	2014.10.12.16.19.30;	author gilles;	state Exp;
branches;
next	;
commitid	gT1baX1pSl5KBufz;

1.7.2.1
date	2016.10.13.15.44.09;	author gilles;	state Exp;
branches;
next	;
commitid	TDfBlWg3euClvuuT;

1.7.6.1
date	2016.08.23.11.15.17;	author jasper;	state Exp;
branches;
next	1.7.6.2;
commitid	Z3CQJZzZ0XOEhO4O;

1.7.6.2
date	2016.10.13.15.46.05;	author gilles;	state Exp;
branches;
next	;
commitid	CJ19Nz5R2982Bxn3;


desc
@@


1.10
log
@Cast char to unsigned char for isspace()

ok gilles@@
@
text
@/*	$OpenBSD: rfc2822.c,v 1.9 2016/10/13 15:47:32 gilles Exp $	*/

/*
 * Copyright (c) 2014 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "rfc2822.h"

/* default no-op callbacks */
static void hdr_dflt_cb(const struct rfc2822_header *hdr, void *arg) {}
static void body_dflt_cb(const char *line, void *arg) {}

static void
header_reset(struct rfc2822_header *hdr)
{
	struct rfc2822_line	*line;

	while ((line = TAILQ_FIRST(&hdr->lines))) {
		TAILQ_REMOVE(&hdr->lines, line, next);
		free(line);
	}
}

static void
header_callback(struct rfc2822_parser *rp)
{
	struct rfc2822_hdr_cb		*hdr_cb;
	struct rfc2822_hdr_miss_cb	*hdr_miss_cb;

	if (!rp->in_hdr)
		goto end;

	TAILQ_FOREACH(hdr_cb, &rp->hdr_cb, next)
	    if (strcasecmp(hdr_cb->name, rp->header.name) == 0) {
		    hdr_cb->func(&rp->header, hdr_cb->arg);
		    goto end;
	    }
	rp->hdr_dflt_cb.func(&rp->header, rp->hdr_dflt_cb.arg);

end:
	TAILQ_FOREACH(hdr_miss_cb, &rp->hdr_miss_cb, next)
	    if (strcasecmp(hdr_miss_cb->name, rp->header.name) == 0)
		    break;
	if (hdr_miss_cb)
		TAILQ_REMOVE(&rp->hdr_miss_cb, hdr_miss_cb, next);
	free(hdr_miss_cb);
	header_reset(&rp->header);
	rp->in_hdr = 0;
	return;
}

static void
missing_headers_callback(struct rfc2822_parser *rp)
{
	struct rfc2822_hdr_miss_cb	*hdr_miss_cb;

	while ((hdr_miss_cb = TAILQ_FIRST(&rp->hdr_miss_cb))) {
		hdr_miss_cb->func(hdr_miss_cb->name, hdr_miss_cb->arg);
		TAILQ_REMOVE(&rp->hdr_miss_cb, hdr_miss_cb, next);
		free(hdr_miss_cb);
	}
}

static void
body_callback(struct rfc2822_parser *rp, const char *line)
{
	rp->body_line_cb.func(line, rp->body_line_cb.arg);
}

static int
parser_feed_header(struct rfc2822_parser *rp, char *line)
{
	struct rfc2822_line	*hdrline;
	char			*pos;

	/* new header */
	if (!isspace((unsigned char)*line) && *line != '\0') {
		rp->in_hdr = 1;
		if ((pos = strchr(line, ':')) == NULL)
			return 0;
		memset(rp->header.name, 0, sizeof rp->header.name);
		(void)memcpy(rp->header.name, line, pos - line);
		if (isspace((unsigned char)pos[1]))
			return parser_feed_header(rp, pos + 1);
		else {
			*pos = ' ';
			return parser_feed_header(rp, pos);
		}
	}

	/* continuation */
	if (!rp->in_hdr)
		return 0;

	/* append line to header */
	if ((hdrline = calloc(1, sizeof *hdrline)) == NULL)
		return -1;
	(void)strlcpy(hdrline->buffer, line, sizeof hdrline->buffer);
	TAILQ_INSERT_TAIL(&rp->header.lines, hdrline, next);
	return 1;
}

static int
parser_feed_body(struct rfc2822_parser *rp, const char *line)
{
	/* for now, we only support per-line callbacks */
	body_callback(rp, line);
	return 1;
}


void
rfc2822_parser_init(struct rfc2822_parser *rp)
{
	memset(rp, 0, sizeof *rp);
	TAILQ_INIT(&rp->hdr_cb);
	TAILQ_INIT(&rp->hdr_miss_cb);
	TAILQ_INIT(&rp->header.lines);
	rfc2822_header_default_callback(rp, hdr_dflt_cb, NULL);
	rfc2822_body_callback(rp, body_dflt_cb, NULL);
	rfc2822_parser_reset(rp);
}

void
rfc2822_parser_flush(struct rfc2822_parser *rp)
{
	if (!rp->in_hdrs)
		return;

	header_callback(rp);

	missing_headers_callback(rp);
}

void
rfc2822_parser_reset(struct rfc2822_parser *rp)
{
	header_reset(&rp->header);
	rp->in_hdrs = 1;
}

void
rfc2822_parser_release(struct rfc2822_parser *rp)
{
	struct rfc2822_hdr_cb		*cb;
	struct rfc2822_hdr_miss_cb	*mcb;

	rfc2822_parser_reset(rp);
	while ((cb = TAILQ_FIRST(&rp->hdr_cb))) {
		TAILQ_REMOVE(&rp->hdr_cb, cb, next);
		free(cb);
	}
	while ((mcb = TAILQ_FIRST(&rp->hdr_miss_cb))) {
		TAILQ_REMOVE(&rp->hdr_miss_cb, mcb, next);
		free(mcb);
	}
}

int
rfc2822_parser_feed(struct rfc2822_parser *rp, const char *line)
{
	char			buffer[RFC2822_MAX_LINE_SIZE+1];

	/* in header and line is not a continuation, execute callback */
	if (rp->in_hdr && (*line == '\0' || !isspace((unsigned char)*line)))
		header_callback(rp);

	/* no longer in headers */
	if (*line == '\0') {
		if (rp->in_hdrs)
			missing_headers_callback(rp);
		rp->in_hdrs = 0;
	}

	if (rp->in_hdrs) {
		/* line exceeds RFC maximum size requirement */
		if (strlcpy(buffer, line, sizeof buffer) >= sizeof buffer)
			return 0;
		return parser_feed_header(rp, buffer);
	}

	/* don't enforce line max length on content, too many MUA break */
	return parser_feed_body(rp, line);
}

int
rfc2822_header_callback(struct rfc2822_parser *rp, const char *header,
    void (*func)(const struct rfc2822_header *, void *), void *arg)
{
	struct rfc2822_hdr_cb  *cb;
	struct rfc2822_hdr_cb  *cb_tmp;
	char			buffer[RFC2822_MAX_LINE_SIZE+1];

	/* line exceeds RFC maximum size requirement */
	if (strlcpy(buffer, header, sizeof buffer) >= sizeof buffer)
		return 0;

	TAILQ_FOREACH_SAFE(cb, &rp->hdr_cb, next, cb_tmp) {
		if (strcasecmp(cb->name, buffer) == 0) {
			TAILQ_REMOVE(&rp->hdr_cb, cb, next);
			free(cb);
		}
	}

	if ((cb = calloc(1, sizeof *cb)) == NULL)
		return -1;
	(void)strlcpy(cb->name, buffer, sizeof cb->name);
	cb->func = func;
	cb->arg  = arg;
	TAILQ_INSERT_TAIL(&rp->hdr_cb, cb, next);
	return 1;
}

int
rfc2822_missing_header_callback(struct rfc2822_parser *rp, const char *header,
    void (*func)(const char *, void *), void *arg)
{
	struct rfc2822_hdr_miss_cb  *cb;
	struct rfc2822_hdr_miss_cb  *cb_tmp;
	char			buffer[RFC2822_MAX_LINE_SIZE+1];

	/* line exceeds RFC maximum size requirement */
	if (strlcpy(buffer, header, sizeof buffer) >= sizeof buffer)
		return 0;

	TAILQ_FOREACH_SAFE(cb, &rp->hdr_miss_cb, next, cb_tmp) {
		if (strcasecmp(cb->name, buffer) == 0) {
			TAILQ_REMOVE(&rp->hdr_miss_cb, cb, next);
			free(cb);
		}
	}

	if ((cb = calloc(1, sizeof *cb)) == NULL)
		return -1;
	(void)strlcpy(cb->name, buffer, sizeof cb->name);
	cb->func = func;
	cb->arg  = arg;
	TAILQ_INSERT_TAIL(&rp->hdr_miss_cb, cb, next);
	return 1;
}

void
rfc2822_header_default_callback(struct rfc2822_parser *rp,
    void (*func)(const struct rfc2822_header *, void *), void *arg)
{
	struct rfc2822_hdr_cb	*cb;

	cb = &rp->hdr_dflt_cb;
	cb->func = func;
	cb->arg  = arg;
}

void
rfc2822_body_callback(struct rfc2822_parser *rp,
    void (*func)(const char *, void *), void *arg)
{
	struct rfc2822_line_cb	*cb;

	cb = &rp->body_line_cb;
	cb->func = func;
	cb->arg  = arg;
}

@


1.9
log
@A logic issue in smtpd's header parsing can cause SMTP sessions to hang.

diff by eric@@, ok me
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.8 2016/08/20 20:47:08 eric Exp $	*/
d100 1
a100 1
	if (!isspace(*line) && *line != '\0') {
d106 1
a106 1
		if (isspace(*(pos + 1)))
d188 1
a188 1
	if (rp->in_hdr && (*line == '\0' || !isspace(*line)))
@


1.8
log
@Properly initialize the message parser. fix a regression where the
message headers would not be altered as expected.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.7 2016/02/04 22:35:17 eric Exp $	*/
d53 3
d154 2
@


1.7
log
@fix memory leak

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.6 2015/12/28 22:08:30 jung Exp $	*/
d141 1
@


1.7.2.1
log
@"A logic issue in smtpd's header parsing can cause SMTP sessions to hang."
errata 031
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.7 2016/02/04 22:35:17 eric Exp $	*/
a52 3
	if (!rp->in_hdr)
		goto end;

a149 2

	missing_headers_callback(rp);
@


1.7.6.1
log
@backport from -current; original commit by eric@@:

Properly initialize the message parser. fix a regression where the
message headers would not be altered as expected.
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.7 2016/02/04 22:35:17 eric Exp $	*/
a140 1
	rfc2822_parser_reset(rp);
@


1.7.6.2
log
@"A logic issue in smtpd's header parsing can cause SMTP sessions to hang"
errata 014
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.7.6.1 2016/08/23 11:15:17 jasper Exp $	*/
a52 3
	if (!rp->in_hdr)
		goto end;

a150 2

	missing_headers_callback(rp);
@


1.6
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.5 2015/11/05 08:55:09 gilles Exp $	*/
d66 1
@


1.5
log
@when a message consists solely of headers and does not end them with an
empty line, the message parser gets confused, and forgets to flush last
header to message file.

detect if we're still in headers when hitting EOM, and flush if that is
the case.

reported by Philipp Takacs <philipp@@bureaucracy.de>

ok millert@@, jung@@, sunil@@, eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.4 2015/09/07 15:36:53 gilles Exp $	*/
d96 1
a96 1
	if (! isspace(*line) && *line != '\0') {
d111 1
a111 1
	if (! rp->in_hdr)
d145 1
a145 1
	if (! rp->in_hdrs)
@


1.4
log
@when bypassing the enqueuer, insert Message-Id header if none was found and
the client has connected from a loopback interface.

ok millert@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.3 2014/11/23 21:27:53 gilles Exp $	*/
d140 9
@


1.3
log
@some third-party applications generate malformed headers which we can still
parse correctly, do not reject message as malformed in this case
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.2 2014/10/15 19:23:29 gilles Exp $	*/
d50 2
a51 1
	struct rfc2822_hdr_cb	*hdr_cb;
d56 1
a56 3
		    header_reset(&rp->header);
		    rp->in_hdr = 0;
		    return;
d58 1
d60 6
a65 1
	rp->hdr_dflt_cb.func(&rp->header, rp->hdr_dflt_cb.arg);
d72 12
d136 1
d152 2
a153 1
	struct rfc2822_hdr_cb	*cb;
d160 4
d176 3
a178 1
	if (*line == '\0')
d180 1
d218 28
@


1.2
log
@- allow empty headers
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc2822.c,v 1.1 2014/10/12 16:19:30 gilles Exp $	*/
d85 6
a90 1
		return parser_feed_header(rp, pos + 1);
@


1.1
log
@simple message parser to be used in smtp incoming sessions, not plugged yet
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 2
a79 2
	/* new header */	
	if (! isspace(*line)) {
@

