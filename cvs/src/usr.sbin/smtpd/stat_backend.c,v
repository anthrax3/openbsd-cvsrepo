head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.12
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.10
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.10
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	ZBTFreARDSMmzOIV;

1.9
date	2014.07.08.10.22.15;	author eric;	state Exp;
branches;
next	1.8;
commitid	5H29d7OT2dwIl1rn;

1.8
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.08.19.11.52;	author chl;	state Exp;
branches;
next	1.6;

1.6
date	2013.01.26.09.37.24;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.25.10.23.12;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.20.18.18.16;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.18.18.18.23;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.10
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@/*	$OpenBSD: stat_backend.c,v 1.9 2014/07/08 10:22:15 eric Exp $	*/

/*
 * Copyright (c) 2012 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/tree.h>

#include <event.h>
#include <imsg.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>

#include "log.h"
#include "smtpd.h"

struct stat_backend	stat_backend_ramstat;
struct stat_backend	stat_backend_sqlite;

struct stat_backend *
stat_backend_lookup(const char *name)
{
	if (!strcmp(name, "ram"))
		return &stat_backend_ramstat;

	if (!strcmp(name, "sqlite"))
		return &stat_backend_sqlite;

	return (NULL);
}

void
stat_increment(const char *key, size_t count)
{
	struct stat_value	*value;

	if (count == 0)
		return;

	value = stat_counter(count);

	m_create(p_control, IMSG_STAT_INCREMENT, 0, 0, -1);
	m_add_string(p_control, key);
	m_add_data(p_control, value, sizeof(*value));
	m_close(p_control);
}

void
stat_decrement(const char *key, size_t count)
{
	struct stat_value	*value;

	if (count == 0)
		return;

	value = stat_counter(count);

	m_create(p_control, IMSG_STAT_DECREMENT, 0, 0, -1);
	m_add_string(p_control, key);
	m_add_data(p_control, value, sizeof(*value));
	m_close(p_control);
}

void
stat_set(const char *key, const struct stat_value *value)
{
	m_create(p_control, IMSG_STAT_SET, 0, 0, -1);
	m_add_string(p_control, key);
	m_add_data(p_control, value, sizeof(*value));
	m_close(p_control);
}

/* helpers */

struct stat_value *
stat_counter(size_t counter)
{
	static struct stat_value value;

	value.type = STAT_COUNTER;
	value.u.counter = counter;
	return &value;
}

struct stat_value *
stat_timestamp(time_t timestamp)
{
	static struct stat_value value;

	value.type = STAT_TIMESTAMP;
	value.u.timestamp = timestamp;
	return &value;
}

struct stat_value *
stat_timeval(struct timeval *tv)
{
	static struct stat_value value;

	value.type = STAT_TIMEVAL;
	value.u.tv = *tv;
	return &value;
}

struct stat_value *
stat_timespec(struct timespec *ts)
{
	static struct stat_value value;

	value.type = STAT_TIMESPEC;
	value.u.ts = *ts;
	return &value;
}
@


1.9
log
@no need to send a stat update message when {inc,dec}rementing by 0.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 1
@


1.8
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stat_backend.c,v 1.7 2013/03/08 19:11:52 chl Exp $	*/
d52 3
d67 3
@


1.7
log
@Add missing $OpenBSD$ RCS tags

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a22 1
#include <sys/param.h>
a49 1
	size_t			 len;
d54 1
a54 2
	len = 32 + strlen(key) + sizeof(*value);
	m_create(p_control, IMSG_STAT_INCREMENT, 0, 0, -1, len);
a62 1
	size_t			 len;
d67 1
a67 2
	len = 32 + strlen(key) + sizeof(*value);
	m_create(p_control, IMSG_STAT_DECREMENT, 0, 0, -1, len);
d76 1
a76 4
	size_t			 len;

	len = 32 + strlen(key) + sizeof(*value);
	m_create(p_control, IMSG_STAT_SET, 0, 0, -1, len);
@


1.6
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 2
@


1.5
log
@knf

ok gilles@@
@
text
@d2 1
a2 1
 * Copyright (c) 2012 Gilles Chehade <gilles@@openbsd.org>
d47 1
a47 1
stat_increment(const char *name, size_t count)
d49 2
a50 3
	char	*s, buf[STAT_KEY_SIZE + sizeof (struct stat_value)];
	size_t	 len;
	struct stat_value *value;
a52 7
	memmove(buf, value, sizeof *value);
	s = buf + sizeof *value;
	if ((len = strlcpy(s, name, STAT_KEY_SIZE)) >= STAT_KEY_SIZE) {
		len = STAT_KEY_SIZE - 1;
		log_warn("warn: stat_increment: truncated key '%s', ignored",
		    name);
	}
d54 5
a58 2
	imsg_compose_event(env->sc_ievs[PROC_CONTROL],
	    IMSG_STAT_INCREMENT, 0, 0, -1, buf, sizeof (*value) + len + 1);
d62 1
a62 1
stat_decrement(const char *name, size_t count)
d64 2
a65 3
	char	*s, buf[STAT_KEY_SIZE + sizeof (struct stat_value)];
	size_t	 len;
	struct stat_value *value;
a67 7
	memmove(buf, value, sizeof *value);
	s = buf + sizeof *value;
	if ((len = strlcpy(s, name, STAT_KEY_SIZE)) >= STAT_KEY_SIZE) {
		len = STAT_KEY_SIZE - 1;
		log_warn("warn: stat_increment: truncated key '%s', ignored",
		    name);
	}
d69 5
a73 2
	imsg_compose_event(env->sc_ievs[PROC_CONTROL],
	    IMSG_STAT_DECREMENT, 0, 0, -1, buf, sizeof (*value) + len + 1);
d77 1
a77 1
stat_set(const char *name, const struct stat_value *value)
d79 1
a79 2
	char	*s, buf[STAT_KEY_SIZE + sizeof (struct stat_value)];
	size_t	 len;
d81 5
a85 10
	memmove(buf, value, sizeof *value);
	s = buf + sizeof *value;
	if ((len = strlcpy(s, name, STAT_KEY_SIZE)) >= STAT_KEY_SIZE) {
		len = STAT_KEY_SIZE - 1;
		log_warn("warn: stat_increment: truncated key '%s', ignored",
		    name);
	}

	imsg_compose_event(env->sc_ievs[PROC_CONTROL],
	    IMSG_STAT_SET, 0, 0, -1, buf, sizeof (*value) + len + 1);
a86 1

@


1.4
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d58 2
a59 1
		log_warn("warn: stat_increment: truncated key '%s', ignored", name);
d78 2
a79 1
		log_warn("warn: stat_increment: truncated key '%s', ignored", name);
d96 2
a97 1
		log_warn("warn: stat_increment: truncated key '%s', ignored", name);
@


1.3
log
@- introduce struct stat_value
- statistics can now have a type (counter, timestamp, timeval, timespec and
  possibly others in the future)
- stat_increment() / stat_decrement() now take an increment/decrement value
  and are at the moment only of type counter
- stat_set() now takes a stat_value
- provide helpers to convert raw values to stat_value

ok eric@@, ok chl@@

while at it fix a rq_queue_dump() call using a bogus timestamp in scheduler
ramqueue.
@
text
@d58 1
a58 1
		log_warn("stat_increment: truncated key '%s', ignored", name);
d77 1
a77 1
		log_warn("stat_increment: truncated key '%s', ignored", name);
d94 1
a94 1
		log_warn("stat_increment: truncated key '%s', ignored", name);
@


1.2
log
@Do not send more bytes than necessary with IMSG_STAT_*.  The INCREMENT
and DECREMENT messages just contain the key with the ending zero.  For
IMSG_STAT_SET, the value is found at the beginning of the message, and
the rest is the key.

ok gilles@@
@
text
@d47 1
a47 1
stat_increment(const char *name)
d49 3
a51 2
	char	key[STAT_KEY_SIZE];
	size_t	len;
d53 5
a57 2
	if ((len = strlcpy(key, name, sizeof key)) >= sizeof key) {
		len = sizeof(key) - 1;
d62 1
a62 1
	    IMSG_STAT_INCREMENT, 0, 0, -1, key, len + 1);
d66 1
a66 1
stat_decrement(const char *name)
d68 3
a70 2
	char	key[STAT_KEY_SIZE];
	size_t	len;
d72 5
a76 2
	if ((len = strlcpy(key, name, sizeof key)) >= sizeof key) {
		len = sizeof(key) - 1;
d81 1
a81 1
	    IMSG_STAT_DECREMENT, 0, 0, -1, key, len + 1);
d85 1
a85 1
stat_set(const char *name, size_t value)
d87 1
a87 1
	char	*s, buf[STAT_KEY_SIZE + sizeof (value)];
d90 2
a91 2
	memmove(buf, &value, sizeof value);
	s = buf + sizeof value;
d98 44
a141 1
	    IMSG_STAT_SET, 0, 0, -1, buf, sizeof (value) + len + 1);
@


1.1
log
@- introduce stat_backend, an API for pluggable statistic backends
  > statistics are no longer static structures in shared memory
  > statistics are only set, smtpd never uses them in its logic
  > each statistic is a key/value where key can be any (dynamic) string
- convert all uses of the former API to use the new one
- implement stat_ramstat that keeps non-persistent stats in ram structure

ok eric@@, ok chl@@
@
text
@d50 1
d52 2
a53 1
	if (strlcpy(key, name, sizeof key) >= sizeof key)
d55 1
d58 1
a58 1
	    IMSG_STAT_INCREMENT, 0, 0, -1, key, sizeof key);
d65 1
d67 2
a68 1
	if (strlcpy(key, name, sizeof key) >= sizeof key)
d70 1
d73 1
a73 1
	    IMSG_STAT_DECREMENT, 0, 0, -1, key, sizeof key);
d79 2
a80 1
	struct stat_kv	kv;
d82 4
a85 2
	bzero(&kv, sizeof kv);
	if (strlcpy(kv.key, name, sizeof kv.key) >= sizeof kv.key)
d87 1
a87 1
	kv.val = value;
d90 1
a90 1
	    IMSG_STAT_SET, 0, 0, -1, &kv, sizeof kv);
@

