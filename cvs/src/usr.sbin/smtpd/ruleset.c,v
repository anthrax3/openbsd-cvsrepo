head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.32.0.6
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.2
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.34
date	2017.02.13.12.23.47;	author gilles;	state Exp;
branches;
next	1.33;
commitid	YoNQfVbDQc2kwy0s;

1.33
date	2016.08.31.15.24.04;	author gilles;	state Exp;
branches;
next	1.32;
commitid	NECHGW1EDKL3apgc;

1.32
date	2015.10.27.20.14.19;	author gilles;	state Exp;
branches;
next	1.31;
commitid	GOsX5yaydgUh46mb;

1.31
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	ZBTFreARDSMmzOIV;

1.30
date	2014.07.08.13.49.09;	author eric;	state Exp;
branches;
next	1.29;
commitid	pEybL9fsrDOC6PJj;

1.29
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2012.10.13.08.01.47;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.11.21.14.32;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.21.10.22.29;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2012.09.15.15.12.11;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2012.05.13.00.10.49;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.21.18.39.03;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.27.15.36.04;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.21.19.53.16;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.28.12.23.12;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.26.15.06.40;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.17.13.47.31;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.03.22.57.41;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.03.19.13.34;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.03.17.50.13;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.19.20.48.13;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.12.18.14.51;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.11.17.40.49;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.07.13.29.40;	author jacekm;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.22.51.47;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.34
log
@allow negation of authenticated keyword:
	accept ! authenticated [...]

ok sunil@@, jung@@
@
text
@/*	$OpenBSD: ruleset.c,v 1.33 2016/08/31 15:24:04 gilles Exp $ */

/*
 * Copyright (c) 2009 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>

#include "smtpd.h"
#include "log.h"


static int ruleset_check_source(struct table *,
    const struct sockaddr_storage *, int);
static int ruleset_check_mailaddr(struct table *, const struct mailaddr *);

struct rule *
ruleset_match(const struct envelope *evp)
{
	const struct mailaddr		*maddr = &evp->dest;
	const struct sockaddr_storage	*ss = &evp->ss;
	struct rule			*r;
	int				 ret;

	TAILQ_FOREACH(r, env->sc_rules, r_entry) {

		if (r->r_tag[0] != '\0') {
			ret = strcmp(r->r_tag, evp->tag);
			if (ret != 0 && !r->r_nottag)
				continue;
			if (ret == 0 && r->r_nottag)
				continue;
		}

		if ((r->r_wantauth && !r->r_negwantauth) && !(evp->flags & EF_AUTHENTICATED))
			continue;
		if ((r->r_wantauth && r->r_negwantauth) && (evp->flags & EF_AUTHENTICATED))
			continue;

		ret = ruleset_check_source(r->r_sources, ss, evp->flags);
		if (ret == -1) {
			errno = EAGAIN;
			return (NULL);
		}
		if ((ret == 0 && !r->r_notsources) || (ret != 0 && r->r_notsources))
			continue;

		if (r->r_senders) {
			ret = ruleset_check_mailaddr(r->r_senders, &evp->sender);
			if (ret == -1) {
				errno = EAGAIN;
				return (NULL);
			}
			if ((ret == 0 && !r->r_notsenders) || (ret != 0 && r->r_notsenders))
				continue;
		}

		if (r->r_recipients) {
			ret = ruleset_check_mailaddr(r->r_recipients, &evp->dest);
			if (ret == -1) {
				errno = EAGAIN;
				return (NULL);
			}
			if ((ret == 0 && !r->r_notrecipients) || (ret != 0 && r->r_notrecipients))
				continue;
		}

		ret = r->r_destination == NULL ? 1 :
		    table_lookup(r->r_destination, NULL, maddr->domain, K_DOMAIN,
			NULL);
		if (ret == -1) {
			errno = EAGAIN;
			return NULL;
		}
		if ((ret == 0 && !r->r_notdestination) || (ret != 0 && r->r_notdestination))
			continue;

		goto matched;
	}

	errno = 0;
	log_trace(TRACE_RULES, "no rule matched");
	return (NULL);

matched:
	log_trace(TRACE_RULES, "rule matched: %s", rule_to_text(r));
	return r;
}

static int
ruleset_check_source(struct table *table, const struct sockaddr_storage *ss,
    int evpflags)
{
	const char   *key;

	if (evpflags & (EF_AUTHENTICATED | EF_INTERNAL))
		key = "local";
	else
		key = ss_to_text(ss);
	switch (table_lookup(table, NULL, key, K_NETADDR, NULL)) {
	case 1:
		return 1;
	case -1:
		log_warnx("warn: failure to perform a table lookup on table %s",
		    table->t_name);
		return -1;
	default:
		break;
	}

	return 0;
}

static int
ruleset_check_mailaddr(struct table *table, const struct mailaddr *maddr)
{
	const char	*key;

	key = mailaddr_to_text(maddr);
	if (key == NULL)
		return -1;

	switch (table_lookup(table, NULL, key, K_MAILADDR, NULL)) {
	case 1:
		return 1;
	case -1:
		log_warnx("warn: failure to perform a table lookup on table %s",
		    table->t_name);
		return -1;
	default:
		break;
	}
	return 0;
}
@


1.33
log
@introduce "authenticated" parameter so rules may apply to authenticated
sessions specifically

ok eric@@, sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.32 2015/10/27 20:14:19 gilles Exp $ */
d59 1
a59 1
		if (r->r_wantauth && !(evp->flags & EF_AUTHENTICATED))
d61 3
a63 1
		
@


1.32
log
@aliases_virtual_check() has been unneeded for a while

ok jung@@, ok sunil@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.31 2015/01/20 17:37:54 deraadt Exp $ */
d59 3
@


1.31
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.30 2014/07/08 13:49:09 eric Exp $ */
a96 7
		if (r->r_desttype == DEST_VDOM &&
		    (r->r_action == A_RELAY || r->r_action == A_RELAYVIA)) {
			if (! aliases_virtual_check(r->r_mapping,
				&evp->rcpt)) {
				return NULL;
			}
		}
@


1.30
log
@Update the table API: lookup functions can take an optional parameters
dictionnary (currently not set). While there, add a helper for forking
external backends, and remove unused table functions.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d31 1
@


1.29
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d87 1
a87 1
		    table_lookup(r->r_destination, maddr->domain, K_DOMAIN,
d125 1
a125 1
	switch (table_lookup(table, key, K_NETADDR, NULL)) {
d148 1
a148 1
	switch (table_lookup(table, key, K_MAILADDR, NULL)) {
@


1.28
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.27 2013/01/26 09:37:23 gilles Exp $ */
d38 1
a38 1
static int ruleset_check_sender(struct table *, const struct mailaddr *);
d50 7
a56 2
		if (r->r_tag[0] != '\0' && strcmp(r->r_tag, evp->tag) != 0)
			continue;
d63 1
a63 1
		if (ret == 0)
d67 11
a77 1
			ret = ruleset_check_sender(r->r_senders, &evp->sender);
d82 1
a82 1
			if (ret == 0)
d93 8
a100 7
		if (ret) {
			if (r->r_desttype == DEST_VDOM &&
			    (r->r_action == A_RELAY || r->r_action == A_RELAYVIA)) {
				if (! aliases_virtual_check(r->r_mapping,
					&evp->rcpt)) {
					return NULL;
				}
a101 1
			goto matched;
d103 1
d107 1
d140 1
a140 1
ruleset_check_sender(struct table *table, const struct mailaddr *maddr)
a157 1

@


1.27
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.26 2012/11/12 14:58:53 eric Exp $ */
a21 1
#include <sys/param.h>
@


1.26
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.25 2012/10/13 08:01:47 eric Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Gilles Chehade <gilles@@openbsd.org>
d37 3
a39 5
static int ruleset_check_source(struct map *, const struct sockaddr_storage *);
static int ruleset_match_mask(struct sockaddr_storage *, struct netaddr *);
static int ruleset_inet4_match(struct sockaddr_in *, struct netaddr *);
static int ruleset_inet6_match(struct sockaddr_in6 *, struct netaddr *);

d44 4
a47 9
	const struct mailaddr *maddr = &evp->dest;
	const struct sockaddr_storage *ss = &evp->ss;
	struct rule	*r;
	struct map	*map;
	struct mapel	*me;
	int		 v;

	if (evp->flags & DF_INTERNAL)
		ss = NULL;
d54 11
a64 3
		if (ss != NULL && !(evp->flags & DF_AUTHENTICATED)) {
			v = ruleset_check_source(r->r_sources, ss);
			if (v == -1) {
d68 1
a68 1
			if (v == 0)
d72 13
a84 12
		if (r->r_condition.c_type == COND_ANY)
			return r;

		if (r->r_condition.c_type == COND_DOM) {
			map = map_find(r->r_condition.c_map);
			if (map == NULL)
				fatal("failed to lookup map.");

			if (map->m_src == S_NONE) {
				TAILQ_FOREACH(me, &map->m_contents, me_entry) {
					if (hostname_match(maddr->domain, me->me_key))
						return r;
d87 1
a87 18
			else if (map_lookup(map->m_id, maddr->domain,
			    K_VIRTUAL) != NULL) {
				return (r);
			} else if (errno) {
				errno = EAGAIN;
				return (NULL);
			}
		}

		if (r->r_condition.c_type == COND_VDOM) {
			v = aliases_vdomain_exists(r->r_condition.c_map,
			    maddr->domain);
			if (v == -1) {
				errno = EAGAIN;
				return (NULL);
			}
			if (v)
				return (r);
a92 10
}

static int
ruleset_cmp_source(const char *s1, const char *s2)
{
	struct netaddr n1;
	struct netaddr n2;

	if (! text_to_netaddr(&n1, s1))
		return 0;
d94 3
a96 9
	if (! text_to_netaddr(&n2, s2))
		return 0;

	if (n1.ss.ss_family != n2.ss.ss_family)
		return 0;
	if (n1.ss.ss_len != n2.ss.ss_len)
		return 0;

	return ruleset_match_mask(&n1.ss, &n2);
d100 2
a101 1
ruleset_check_source(struct map *map, const struct sockaddr_storage *ss)
d103 1
a103 1
	struct mapel *me;
d105 6
a110 4
	if (ss == NULL) {
		/* This happens when caller is part of an internal
		 * lookup (ie: alias resolved to a remote address)
		 */
d112 6
a117 19
	}

	if (map->m_src == S_NONE) {
		TAILQ_FOREACH(me, &map->m_contents, me_entry) {
			if (ss->ss_family == AF_LOCAL) {
				if (!strcmp(me->me_key, "local"))
					return 1;
				continue;
			}
			if (ruleset_cmp_source(ss_to_text(ss), me->me_key))
				return 1;
		}
	}
	else {
		if (map_compare(map->m_id, ss_to_text(ss), K_NETADDR,
		    ruleset_cmp_source))
			return (1);
		if (errno)
			return (-1);
d124 1
a124 1
ruleset_match_mask(struct sockaddr_storage *ss, struct netaddr *ssmask)
d126 1
a126 2
	if (ss->ss_family == AF_INET)
		return ruleset_inet4_match((struct sockaddr_in *)ss, ssmask);
d128 3
a130 5
	if (ss->ss_family == AF_INET6)
		return ruleset_inet6_match((struct sockaddr_in6 *)ss, ssmask);

	return (0);
}
d132 2
a133 15
static int
ruleset_inet4_match(struct sockaddr_in *ss, struct netaddr *ssmask)
{
	in_addr_t mask;
	int i;

	/* a.b.c.d/8 -> htonl(0xff000000) */
	mask = 0;
	for (i = 0; i < ssmask->bits; ++i)
		mask = (mask >> 1) | 0x80000000;
	mask = htonl(mask);

	/* (addr & mask) == (net & mask) */
 	if ((ss->sin_addr.s_addr & mask) ==
	    (((struct sockaddr_in *)ssmask)->sin_addr.s_addr & mask))
d135 6
a140 26
	
	return 0;
}

static int
ruleset_inet6_match(struct sockaddr_in6 *ss, struct netaddr *ssmask)
{
	struct in6_addr	*in;
	struct in6_addr	*inmask;
	struct in6_addr	 mask;
	int		 i;
	
	bzero(&mask, sizeof(mask));
	for (i = 0; i < ssmask->bits / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = ssmask->bits % 8;
	if (i)
		mask.s6_addr[ssmask->bits / 8] = 0xff00 >> i;
	
	in = &ss->sin6_addr;
	inmask = &((struct sockaddr_in6 *)&ssmask->ss)->sin6_addr;
	
	for (i = 0; i < 16; i++) {
		if ((in->s6_addr[i] & mask.s6_addr[i]) !=
		    (inmask->s6_addr[i] & mask.s6_addr[i]))
			return (0);
d143 1
a143 1
	return (1);
@


1.25
log
@Make map_lookup() and make_compare() set errno on failure to distinguish
between "no match" and "internal error" (e.g. missing or broken db file).
Adapt alias expansion and ruleset matching code to check for such errors,
in which case the current processing is aborted, and a temporary failure
is reported to the smtp session.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.24 2012/10/11 21:14:32 gilles Exp $ */
d81 1
a81 2
					if (hostname_match(maddr->domain,
					    me->me_key.med_string))
d145 1
a145 1
				if (!strcmp(me->me_key.med_string, "local"))
d149 1
a149 2
			if (ruleset_cmp_source(ss_to_text(ss),
				me->me_key.med_string))
@


1.24
log
@- replace "from all" and "for all" with "from any" and "for any"

ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.23 2012/09/21 10:22:29 eric Exp $ */
d27 1
a45 3
	struct rule *r;
	struct map *map;
	struct mapel *me;
d48 4
d61 9
a69 4
		if (ss != NULL &&
		    (!(evp->flags & DF_AUTHENTICATED) &&
			! ruleset_check_source(r->r_sources, ss)))
			continue;
d82 1
a82 1
						me->me_key.med_string))
d87 5
a91 2
				K_VIRTUAL) != NULL) {
				return r;
d96 8
a103 3
			if (aliases_vdomain_exists(r->r_condition.c_map,
				maddr->domain))
				return r;
d107 2
a108 1
	return NULL;
d157 4
a160 2
			    ruleset_cmp_source))
			return 1;
@


1.23
log
@Move ruleset_match() prototype to smtpd.h and make the envelope const.
Adapt a lot of functions in chain to use const args where required.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.22 2012/09/15 15:12:11 eric Exp $ */
d64 1
a64 1
		if (r->r_condition.c_type == C_ALL)
d67 1
a67 1
		if (r->r_condition.c_type == C_DOM) {
d85 1
a85 1
		if (r->r_condition.c_type == C_VDOM) {
@


1.22
log
@When enqueueing from the local socket, the input address is faked as "::1".
This is confusing and even broken, as systems running with ipv6 disabled on
lo0 will not be able to enqueue mails using the local socket.

So instead, use AF_LOCAL and print it as "local" in envelopes/maps.  Add it
to the "localhost" and "all" maps accordingly, and fix the ruleset matching.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.21 2012/05/13 00:10:49 gilles Exp $ */
d36 1
a36 3
struct rule *ruleset_match(struct envelope *);

static int ruleset_check_source(struct map *, struct sockaddr_storage *);
d43 1
a43 1
ruleset_match(struct envelope *evp)
d48 2
a49 2
	struct mailaddr *maddr = &evp->dest;
	struct sockaddr_storage *ss = &evp->ss;
d96 1
a96 1
ruleset_cmp_source(char *s1, char *s2)
d116 1
a116 1
ruleset_check_source(struct map *map, struct sockaddr_storage *ss)
@


1.21
log
@- cleanup parse.y by removing lots of code that should not have been there,
  but in ruleset.c and util.c instead.

- introduce the new map_compare() map API call to allow iterating over keys
  and comparing them with provided key using provided function. this allows
  checking a partial key in a key set, very useful for comparing an address
  to a set of netmask.

- introduce new map kind K_NETADDR
- implement K_NETADDR for map_db and map_stdio
- teach ruleset checking how to use the map_compare() with K_NETADDR

we can now do the following:

   map "srcaddr" source plain "/etc/mail/srcaddr.txt"

   accept from map srcaddr for domain "openbsd.org" [...]
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.20 2011/10/23 09:30:07 gilles Exp $ */
d131 5
@


1.20
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.19 2011/05/21 18:39:03 gilles Exp $ */
d74 1
a74 2
			switch (map->m_src) {
			case S_NONE:
d76 2
a77 1
					if (hostname_match(maddr->domain, me->me_key.med_string))
d80 4
a83 8
				break;
			case S_DB:
				if (map_lookup(map->m_id, maddr->domain, K_VIRTUAL) != NULL)
					return r;
				break;
			default:
				log_info("unsupported map source for domain map");
				continue;
d87 3
a89 2
		if (r->r_condition.c_type == C_VDOM)
			if (aliases_vdomain_exists(r->r_condition.c_map, maddr->domain))
d91 1
d98 20
d129 10
a138 9
	TAILQ_FOREACH(me, &map->m_contents, me_entry) {

		if (ss->ss_family != me->me_key.med_addr.ss.ss_family)
			continue;

		if (ss->ss_len != me->me_key.med_addr.ss.ss_len)
			continue;

		if (ruleset_match_mask(ss, &me->me_key.med_addr))
@


1.19
log
@remove annoying log_debug()
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.18 2011/05/16 21:05:52 gilles Exp $ */
d50 2
a51 2
	struct mailaddr *maddr = &evp->delivery.rcpt;
	struct sockaddr_storage *ss = &evp->delivery.ss;
d53 1
a53 1
	if (evp->delivery.flags & DF_INTERNAL)
d62 1
a62 1
		    (!(evp->delivery.flags & DF_AUTHENTICATED) &&
@


1.18
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.17 2011/05/01 12:57:11 eric Exp $ */
a52 1
	log_debug("flags: %d", evp->delivery.flags);
@


1.17
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.16 2011/04/17 13:36:07 gilles Exp $ */
d36 1
a36 1
struct rule *ruleset_match(char *tag, struct path *, struct sockaddr_storage *);
d45 1
a45 1
ruleset_match(char *tag, struct path *path, struct sockaddr_storage *ss)
d50 6
d59 1
a59 1
		if (r->r_tag[0] != '\0' && strcmp(r->r_tag, tag) != 0)
d63 1
a63 1
		    (!(path->flags & F_PATH_AUTHENTICATED) &&
d78 1
a78 1
					if (hostname_match(path->domain, me->me_key.med_string))
d83 1
a83 1
				if (map_lookup(map->m_id, path->domain, K_VIRTUAL) != NULL)
d93 1
a93 1
			if (aliases_vdomain_exists(r->r_condition.c_map, path->domain))
@


1.16
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.15 2010/11/28 14:35:58 gilles Exp $ */
d36 1
a36 1
struct rule *ruleset_match(struct smtpd *, char *tag, struct path *, struct sockaddr_storage *);
d45 1
a45 1
ruleset_match(struct smtpd *env, char *tag, struct path *path, struct sockaddr_storage *ss)
d65 1
a65 1
			map = map_find(env, r->r_condition.c_map);
d77 1
a77 1
				if (map_lookup(env, map->m_id, path->domain, K_VIRTUAL) != NULL)
d87 1
a87 1
			if (aliases_vdomain_exists(env, r->r_condition.c_map, path->domain))
@


1.15
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.14 2010/11/28 13:56:43 gilles Exp $ */
d35 8
a42 5
struct rule    *ruleset_match(struct smtpd *, char *tag, struct path *, struct sockaddr_storage *);
int		ruleset_check_source(struct map *, struct sockaddr_storage *);
int		ruleset_match_mask(struct sockaddr_storage *, struct netaddr *);
int		ruleset_inet4_match(struct sockaddr_in *, struct netaddr *);
int		ruleset_inet6_match(struct sockaddr_in6 *, struct netaddr *);
d94 1
a94 1
int
d121 1
a121 1
int
d133 1
a133 1
int
d153 1
a153 1
int
@


1.14
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.13 2010/05/27 15:36:04 gilles Exp $ */
a25 1
#include <arpa/inet.h>
a26 2
#include <db.h>
#include <errno.h>
a28 1
#include <fcntl.h>
a29 1
#include <stdlib.h>
@


1.13
log
@when a rule has two conditions (ie: accept for { domain foo, domain bar } )
expand to two rules each having its own condition rather than one rule
with a tail queue of conditions. this simplifies code a bit and removes a
couple hacks.

basic testing by oga and me
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.12 2010/04/21 19:53:16 gilles Exp $ */
d31 1
d38 1
@


1.12
log
@map_lookup() takes an additionnal parameter of type enum map_kind which
will be used to select the appropriate map parser. make sure every call
to map_lookup() is updated. map_lookup() currently ignores the value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.11 2010/02/28 12:23:12 gilles Exp $ */
a47 1
	struct cond *cond;
d61 2
a62 5
		TAILQ_FOREACH(cond, &r->r_conditions, c_entry) {
			if (cond->c_type == C_ALL) {
				path->cond = cond;
				return r;
			}
d64 9
a72 17
			if (cond->c_type == C_DOM) {
				map = map_find(env, cond->c_map);
				if (map == NULL)
					fatal("failed to lookup map.");

				switch (map->m_src) {
				case S_NONE:
					TAILQ_FOREACH(me, &map->m_contents, me_entry) {
						if (hostname_match(path->domain, me->me_key.med_string)) {
							path->cond = cond;
							return r;
						}
					}
					break;
				case S_DB:
					if (map_lookup(env, map->m_id, path->domain, K_VIRTUAL) != NULL) {
						path->cond = cond;
a73 5
					}
					break;
				default:
					log_info("unsupported map source for domain map");
					continue;
d75 3
a77 5
			}

			if (cond->c_type == C_VDOM) {
				if (aliases_vdomain_exists(env, cond->c_map, path->domain)) {
					path->cond = cond;
d79 4
a82 1
				}
d85 4
@


1.11
log
@the netmask fix I commited a couple days ago lacked the AF_INET6 bits,
this commit fixes pr user/6328

bug reported and fix verified by Martin Hedenfalk <martinh@@bzero.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.10 2010/02/26 15:06:40 gilles Exp $ */
d83 1
a83 1
					if (map_lookup(env, map->m_id, path->domain) != NULL) {
@


1.10
log
@- fix netmask matching for AF_INET, it was broken in many ways, problem
  was reported by nicm@@ which spent a couple hours with me trying to
  understand what was causing the bug, and helping me write and test fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.9 2010/02/17 13:47:31 gilles Exp $ */
d174 1
a174 1
	for (i = 0; i < (128 - ssmask->bits) / 8; i++)
d185 1
a185 1
		    inmask->s6_addr[i])
d188 1
@


1.9
log
@the map api becomes backend-agnostic with initial support for db(3) and
stdio(3) backends, though for now we only enable db(3). this is the first
commit of a serie to improve maps and everything related.

idea discussed with and diff okay jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.8 2009/11/03 22:57:41 gilles Exp $ */
d41 2
a42 1

d136 2
a137 9
	if (ss->ss_family == AF_INET) {
		struct sockaddr_in *ssin = (struct sockaddr_in *)ss;
		struct sockaddr_in *ssinmask = (struct sockaddr_in *)&ssmask->ss;

		if ((ssin->sin_addr.s_addr & ssinmask->sin_addr.s_addr) ==
		    ssinmask->sin_addr.s_addr)
			return (1);
		return (0);
	}
d139 2
a140 23
	if (ss->ss_family == AF_INET6) {
		struct in6_addr	*in;
		struct in6_addr	*inmask;
		struct in6_addr	 mask;
		int		 i;

		bzero(&mask, sizeof(mask));
		for (i = 0; i < (128 - ssmask->bits) / 8; i++)
			mask.s6_addr[i] = 0xff;
		i = ssmask->bits % 8;
		if (i)
			mask.s6_addr[ssmask->bits / 8] = 0xff00 >> i;

		in = &((struct sockaddr_in6 *)ss)->sin6_addr;
		inmask = &((struct sockaddr_in6 *)&ssmask->ss)->sin6_addr;

		for (i = 0; i < 16; i++) {
			if ((in->s6_addr[i] & mask.s6_addr[i]) !=
			    inmask->s6_addr[i])
				return (0);
		}
		return (1);
	}
d143 46
@


1.8
log
@teach makemap how to build a set, which is a map containing only keys.
smtpd is now capable of looking primary domains at runtime in a set, which
means that the following becomes possible:

	map "primary" { source db "/etc/mail/primary.db" }
	accept for domain map "primary" deliver to mbox

while at it fix a couple bugs in the aliases resolution path which caused
recipients to bounce if a ruleset did not have an "accept for local" rule

"diff reads good" jacekm@@, flush queue & make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.7 2009/11/03 19:13:34 gilles Exp $ */
d82 1
a82 1
					if (map_dblookup(env, map->m_id, path->domain) != NULL) {
@


1.7
log
@- remove a useless member of struct cond
- have virtual related functions take a map id instead of a map
- shrink a tiny bit ruleset matching
- add missing lka_resolve_path() call in aliases resolution leading to
  issues spotted by nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.6 2009/11/03 17:50:13 gilles Exp $ */
d72 11
a82 2
				TAILQ_FOREACH(me, &map->m_contents, me_entry) {
					if (hostname_match(path->domain, me->me_key.med_string)) {
d86 4
@


1.6
log
@remove annoying log_debug
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.5 2009/10/19 20:48:13 gilles Exp $ */
d68 2
a69 2
				cond->c_match = map_find(env, cond->c_map);
				if (cond->c_match == NULL)
a71 1
				map = cond->c_match;
d81 1
a81 6
				cond->c_match = map_find(env, cond->c_map);
				if (cond->c_match == NULL)
					fatal("failed to lookup map.");

				map = cond->c_match;
				if (aliases_vdomain_exists(env, map, path->domain)) {
@


1.5
log
@currently, smtpd is capable of having multiple listeners with different
options but they will all share the same ruleset. this means that there
is no way to have a rule apply to a session established on one listener
but not applied on another.

this commit brings initial support for tagging listeners and having the
rules able to match these specific listeners. The following will define
a rule which will only apply to interfaces tagged as "mynet":

listen on lo0			# implicit lo0 tag
listen on fxp0 tag mynet
listen on fxp1 tag mynet

accept on mynet for domain "example.org" deliver to mbox
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.4 2009/10/12 18:14:51 gilles Exp $ */
a49 3

	if (tag)
		log_debug("tag: %s", tag);
@


1.4
log
@fix a bug where matching a "for all" rule with multiple condition will not
let us know which condition we matched.
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.3 2009/10/11 17:40:49 gilles Exp $ */
d38 1
a38 1
struct rule    *ruleset_match(struct smtpd *, struct path *, struct sockaddr_storage *);
d44 1
a44 1
ruleset_match(struct smtpd *env, struct path *path, struct sockaddr_storage *ss)
d51 3
d55 3
@


1.3
log
@implement proper virtual domains instead of faking them on top of primary
domains. this means that:

- virtual domains no longer deliver to a local user when not told to
- they no longer attempt to resolve aliases when not told to
- they no longer need an explicit rule in smtpd.conf for EACH domain
- the "virtual" map is no longer hardcoded
- smtpd no longer needs a restart to support a new domain

instead we introduce the: accept for virtual map "mapname" [...] syntax
which refers to a map that can be manipulated at runtime.

idea discussed and okayd with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.2 2009/10/07 13:29:40 jacekm Exp $ */
d59 2
a60 1
			if (cond->c_type == C_ALL)
d62 1
@


1.2
log
@remove noisy log_debug, requested by gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruleset.c,v 1.1 2009/06/01 22:51:47 gilles Exp $ */
d70 1
d73 12
@


1.1
log
@add new file ruleset.c with code related to the ruleset matching, and kill
the two or three "almost" identical versions of ruleset matching loops from
lka and mfa by having one unified function in ruleset.c; ok jacekm@@

while at it, bring maildir support back to life; trivial one-liner by me
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a68 2
					log_debug("matching: %s to %s",
					    path->domain, me->me_key.med_string);
@

