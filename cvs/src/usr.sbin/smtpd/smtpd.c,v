head	1.288;
access;
symbols
	OPENBSD_6_1_BASE:1.288
	OPENBSD_6_0:1.279.0.4
	OPENBSD_6_0_BASE:1.279
	OPENBSD_5_9:1.274.0.2
	OPENBSD_5_9_BASE:1.274
	OPENBSD_5_8:1.239.0.4
	OPENBSD_5_8_BASE:1.239
	OPENBSD_5_7:1.238.0.2
	OPENBSD_5_7_BASE:1.238
	OPENBSD_5_6:1.234.0.4
	OPENBSD_5_6_BASE:1.234
	OPENBSD_5_5:1.213.0.2
	OPENBSD_5_5_BASE:1.213
	OPENBSD_5_4:1.198.0.2
	OPENBSD_5_4_BASE:1.198
	OPENBSD_5_3:1.188.0.2
	OPENBSD_5_3_BASE:1.188
	OPENBSD_5_2:1.155.0.2
	OPENBSD_5_2_BASE:1.155
	OPENBSD_5_1_BASE:1.150
	OPENBSD_5_1:1.150.0.2
	OPENBSD_5_0:1.126.0.2
	OPENBSD_5_0_BASE:1.126
	OPENBSD_4_9:1.115.0.2
	OPENBSD_4_9_BASE:1.115
	OPENBSD_4_8:1.112.0.2
	OPENBSD_4_8_BASE:1.112
	OPENBSD_4_7:1.96.0.2
	OPENBSD_4_7_BASE:1.96
	OPENBSD_4_6:1.75.0.4
	OPENBSD_4_6_BASE:1.75
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33;
locks; strict;
comment	@ * @;


1.288
date	2017.01.09.09.53.23;	author reyk;	state Exp;
branches;
next	1.287;
commitid	jM4eOMW1AJwdfKrr;

1.287
date	2016.10.19.14.06.07;	author jmc;	state Exp;
branches;
next	1.286;
commitid	u7XyXM7ESNheV3R6;

1.286
date	2016.09.08.12.06.43;	author eric;	state Exp;
branches;
next	1.285;
commitid	LkfnyKFoItZAAepX;

1.285
date	2016.09.06.16.34.29;	author eric;	state Exp;
branches;
next	1.284;
commitid	35Mttwmj19Lpz3bg;

1.284
date	2016.09.04.16.10.31;	author eric;	state Exp;
branches;
next	1.283;
commitid	I2r1xe6emhZl6xPg;

1.283
date	2016.09.04.09.33.49;	author eric;	state Exp;
branches;
next	1.282;
commitid	k6ATrLH73tETES8n;

1.282
date	2016.09.01.10.54.25;	author eric;	state Exp;
branches;
next	1.281;
commitid	fYsbH2IujjKSME9c;

1.281
date	2016.09.01.10.07.20;	author eric;	state Exp;
branches;
next	1.280;
commitid	Ch0RMqdovbewwGAQ;

1.280
date	2016.08.19.15.35.08;	author eric;	state Exp;
branches;
next	1.279;
commitid	KAzTWoQS6eePde5d;

1.279
date	2016.06.20.20.26.04;	author gilles;	state Exp;
branches;
next	1.278;
commitid	Bknb6gGfvSGnZJ6N;

1.278
date	2016.06.07.06.52.49;	author gilles;	state Exp;
branches;
next	1.277;
commitid	YQwNrCW4X7CRWlNO;

1.277
date	2016.05.28.21.21.20;	author eric;	state Exp;
branches;
next	1.276;
commitid	KhU4hSodVCiVoZ62;

1.276
date	2016.04.21.14.27.41;	author jsing;	state Exp;
branches;
next	1.275;
commitid	y261bjeJ4UOVSbjW;

1.275
date	2016.03.17.19.40.43;	author krw;	state Exp;
branches;
next	1.274;
commitid	aCmYZrmRmWHLuztW;

1.274
date	2016.02.05.19.15.15;	author jung;	state Exp;
branches;
next	1.273;
commitid	iziLYeslx9zPwtRs;

1.273
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.272;
commitid	LQHdRRMF0nq0fugE;

1.272
date	2016.01.27.12.46.03;	author sunil;	state Exp;
branches;
next	1.271;
commitid	zKnEiCIfZ7vWdZVV;

1.271
date	2016.01.18.11.29.34;	author sunil;	state Exp;
branches;
next	1.270;
commitid	uRbK0PDjZccfAEaG;

1.270
date	2016.01.04.13.30.20;	author jung;	state Exp;
branches;
next	1.269;
commitid	CF2whypVOFPTyiTY;

1.269
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.268;
commitid	ZxnqOQqX6IeYI9jW;

1.268
date	2015.12.20.14.06.24;	author gilles;	state Exp;
branches;
next	1.267;
commitid	HYXZhqDBRYdl4NUQ;

1.267
date	2015.12.14.10.22.12;	author jung;	state Exp;
branches;
next	1.266;
commitid	HRAnniyhGW9Sadln;

1.266
date	2015.12.12.20.02.31;	author gilles;	state Exp;
branches;
next	1.265;
commitid	eO2zB2XyKCWqQLmz;

1.265
date	2015.12.12.11.31.29;	author sunil;	state Exp;
branches;
next	1.264;
commitid	xbftp8DyefrEq9pW;

1.264
date	2015.12.12.10.48.43;	author gilles;	state Exp;
branches;
next	1.263;
commitid	ua8QN1snTVetgJnY;

1.263
date	2015.12.12.10.26.57;	author sunil;	state Exp;
branches;
next	1.262;
commitid	cnZTHMLCHMYiKiF5;

1.262
date	2015.12.11.07.44.59;	author sunil;	state Exp;
branches;
next	1.261;
commitid	jSab0JL5Up0jW3aR;

1.261
date	2015.12.10.14.07.04;	author sunil;	state Exp;
branches;
next	1.260;
commitid	LO45PxPM3PEO0RHx;

1.260
date	2015.12.10.09.33.50;	author sunil;	state Exp;
branches;
next	1.259;
commitid	dIoRztIOC4tDsaIX;

1.259
date	2015.12.08.17.28.03;	author sunil;	state Exp;
branches;
next	1.258;
commitid	mlrxv41mOWqJnJLd;

1.258
date	2015.12.05.21.27.42;	author mmcc;	state Exp;
branches;
next	1.257;
commitid	u7cKDttUUhTVcGIY;

1.257
date	2015.12.01.20.04.38;	author gilles;	state Exp;
branches;
next	1.256;
commitid	zNeMc9LvXTbN7N9v;

1.256
date	2015.11.30.14.13.03;	author gilles;	state Exp;
branches;
next	1.255;
commitid	uzQcYiSR90ELNfI7;

1.255
date	2015.11.30.12.49.35;	author gilles;	state Exp;
branches;
next	1.254;
commitid	ZyOzw2IPUjoaWKi5;

1.254
date	2015.11.05.09.14.31;	author sunil;	state Exp;
branches;
next	1.253;
commitid	3vo6L6sIqhuEjLcD;

1.253
date	2015.10.29.10.25.36;	author sunil;	state Exp;
branches;
next	1.252;
commitid	TXZugvtal96cI6ec;

1.252
date	2015.10.26.09.56.01;	author jung;	state Exp;
branches;
next	1.251;
commitid	PSZ0qNLXlqBEXM52;

1.251
date	2015.10.22.08.46.31;	author gilles;	state Exp;
branches;
next	1.250;
commitid	C5sYemDuhOqSfaHy;

1.250
date	2015.10.17.16.03.20;	author sunil;	state Exp;
branches;
next	1.249;
commitid	BiuIanVrfX7L5Fi8;

1.249
date	2015.10.17.04.36.10;	author deraadt;	state Exp;
branches;
next	1.248;
commitid	xftZ5fll1vW6vwKg;

1.248
date	2015.10.16.20.54.55;	author gilles;	state Exp;
branches;
next	1.247;
commitid	boYoR4i6MQmPk7oH;

1.247
date	2015.10.14.19.56.58;	author gilles;	state Exp;
branches;
next	1.246;
commitid	hnS09G1mdpnr90Z0;

1.246
date	2015.10.14.09.14.11;	author sunil;	state Exp;
branches;
next	1.245;
commitid	lp3olG9CDKzYsfmn;

1.245
date	2015.10.13.07.18.53;	author gilles;	state Exp;
branches;
next	1.244;
commitid	TjEUAxy0VEvs5dMw;

1.244
date	2015.10.12.07.58.19;	author deraadt;	state Exp;
branches;
next	1.243;
commitid	SD2NAm0X1clljRst;

1.243
date	2015.10.09.17.44.25;	author gilles;	state Exp;
branches;
next	1.242;
commitid	Dm2geOsS7pVWssxI;

1.242
date	2015.10.06.08.51.35;	author gilles;	state Exp;
branches;
next	1.241;
commitid	DHnAFyhLsnllLYXo;

1.241
date	2015.10.06.06.04.46;	author gilles;	state Exp;
branches;
next	1.240;
commitid	kHsLvobU8ObZj5n9;

1.240
date	2015.10.02.00.37.53;	author gilles;	state Exp;
branches;
next	1.239;
commitid	ppKhaJyJbWGnjEqV;

1.239
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches
	1.239.4.1;
next	1.238;
commitid	GouatFiJVxwlAVIQ;

1.238
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches
	1.238.2.1;
next	1.237;
commitid	ZBTFreARDSMmzOIV;

1.237
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.236;
commitid	Uu5nFG3wCl0LACBb;

1.236
date	2015.01.15.09.05.37;	author gilles;	state Exp;
branches;
next	1.235;
commitid	7d9HtLBWZEr4hR4Z;

1.235
date	2014.08.25.07.50.26;	author doug;	state Exp;
branches;
next	1.234;
commitid	vcwz0sp1JH7QzUmA;

1.234
date	2014.07.10.15.54.55;	author eric;	state Exp;
branches
	1.234.4.1;
next	1.233;
commitid	Uxz21DeZX3Z1gOVr;

1.233
date	2014.07.10.14.45.02;	author eric;	state Exp;
branches;
next	1.232;
commitid	dolePHRcgnf1dDVL;

1.232
date	2014.07.09.09.53.37;	author eric;	state Exp;
branches;
next	1.231;
commitid	RHRCVJhvTqNHZi7Q;

1.231
date	2014.07.08.21.55.53;	author eric;	state Exp;
branches;
next	1.230;
commitid	o37aYl7hXS6sIRRi;

1.230
date	2014.07.08.21.25.14;	author eric;	state Exp;
branches;
next	1.229;
commitid	5hjliVJ57uN3BND6;

1.229
date	2014.07.08.20.14.46;	author eric;	state Exp;
branches;
next	1.228;
commitid	AHjSiMjlXwD7KM7Y;

1.228
date	2014.07.08.13.49.09;	author eric;	state Exp;
branches;
next	1.227;
commitid	pEybL9fsrDOC6PJj;

1.227
date	2014.07.07.09.11.24;	author eric;	state Exp;
branches;
next	1.226;
commitid	i5e19t9Ki1zvGnyP;

1.226
date	2014.05.01.15.50.20;	author reyk;	state Exp;
branches;
next	1.225;

1.225
date	2014.04.30.08.23.42;	author reyk;	state Exp;
branches;
next	1.224;

1.224
date	2014.04.29.21.04.17;	author reyk;	state Exp;
branches;
next	1.223;

1.223
date	2014.04.29.19.13.13;	author reyk;	state Exp;
branches;
next	1.222;

1.222
date	2014.04.29.10.18.06;	author reyk;	state Exp;
branches;
next	1.221;

1.221
date	2014.04.19.14.00.45;	author gilles;	state Exp;
branches;
next	1.220;

1.220
date	2014.04.09.19.12.45;	author eric;	state Exp;
branches;
next	1.219;

1.219
date	2014.04.09.18.55.19;	author eric;	state Exp;
branches;
next	1.218;

1.218
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.217;

1.217
date	2014.04.04.13.13.58;	author eric;	state Exp;
branches;
next	1.216;

1.216
date	2014.04.01.09.00.46;	author gilles;	state Exp;
branches;
next	1.215;

1.215
date	2014.03.24.14.55.12;	author gilles;	state Exp;
branches;
next	1.214;

1.214
date	2014.03.22.09.41.28;	author gilles;	state Exp;
branches;
next	1.213;

1.213
date	2014.02.17.13.33.56;	author eric;	state Exp;
branches;
next	1.212;

1.212
date	2014.02.10.09.28.05;	author eric;	state Exp;
branches;
next	1.211;

1.211
date	2014.02.04.15.22.39;	author eric;	state Exp;
branches;
next	1.210;

1.210
date	2014.02.04.13.44.41;	author eric;	state Exp;
branches;
next	1.209;

1.209
date	2014.02.04.09.05.06;	author eric;	state Exp;
branches;
next	1.208;

1.208
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.207;

1.207
date	2013.11.28.12.50.40;	author eric;	state Exp;
branches;
next	1.206;

1.206
date	2013.11.13.13.02.44;	author eric;	state Exp;
branches;
next	1.205;

1.205
date	2013.11.13.08.57.24;	author eric;	state Exp;
branches;
next	1.204;

1.204
date	2013.11.06.10.01.29;	author eric;	state Exp;
branches;
next	1.203;

1.203
date	2013.10.30.21.37.48;	author eric;	state Exp;
branches;
next	1.202;

1.202
date	2013.10.27.17.47.53;	author eric;	state Exp;
branches;
next	1.201;

1.201
date	2013.10.27.11.01.47;	author eric;	state Exp;
branches;
next	1.200;

1.200
date	2013.10.27.07.56.25;	author eric;	state Exp;
branches;
next	1.199;

1.199
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.198;

1.198
date	2013.07.19.21.58.54;	author eric;	state Exp;
branches;
next	1.197;

1.197
date	2013.07.19.21.14.52;	author eric;	state Exp;
branches;
next	1.196;

1.196
date	2013.07.19.20.37.07;	author eric;	state Exp;
branches;
next	1.195;

1.195
date	2013.07.19.15.53.35;	author eric;	state Exp;
branches;
next	1.194;

1.194
date	2013.07.19.15.14.23;	author eric;	state Exp;
branches;
next	1.193;

1.193
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.192;

1.192
date	2013.07.04.07.04.07;	author gilles;	state Exp;
branches;
next	1.191;

1.191
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.190;

1.190
date	2013.04.17.15.02.38;	author deraadt;	state Exp;
branches;
next	1.189;

1.189
date	2013.04.12.18.22.49;	author eric;	state Exp;
branches;
next	1.188;

1.188
date	2013.02.14.13.11.40;	author gilles;	state Exp;
branches;
next	1.187;

1.187
date	2013.02.14.12.30.49;	author gilles;	state Exp;
branches;
next	1.186;

1.186
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.185;

1.185
date	2013.01.28.11.09.53;	author gilles;	state Exp;
branches;
next	1.184;

1.184
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.183;

1.183
date	2012.11.23.15.10.07;	author eric;	state Exp;
branches;
next	1.182;

1.182
date	2012.11.20.09.47.46;	author eric;	state Exp;
branches;
next	1.181;

1.181
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.180;

1.180
date	2012.11.02.16.02.33;	author eric;	state Exp;
branches;
next	1.179;

1.179
date	2012.10.17.16.39.49;	author eric;	state Exp;
branches;
next	1.178;

1.178
date	2012.10.15.18.32.25;	author eric;	state Exp;
branches;
next	1.177;

1.177
date	2012.10.15.17.54.28;	author eric;	state Exp;
branches;
next	1.176;

1.176
date	2012.10.14.11.58.23;	author gilles;	state Exp;
branches;
next	1.175;

1.175
date	2012.10.11.21.55.16;	author gilles;	state Exp;
branches;
next	1.174;

1.174
date	2012.10.04.18.25.39;	author eric;	state Exp;
branches;
next	1.173;

1.173
date	2012.10.03.17.58.03;	author gilles;	state Exp;
branches;
next	1.172;

1.172
date	2012.09.28.17.28.30;	author eric;	state Exp;
branches;
next	1.171;

1.171
date	2012.09.16.16.54.55;	author chl;	state Exp;
branches;
next	1.170;

1.170
date	2012.09.16.16.43.29;	author chl;	state Exp;
branches;
next	1.169;

1.169
date	2012.09.11.12.47.36;	author eric;	state Exp;
branches;
next	1.168;

1.168
date	2012.09.01.16.09.14;	author gilles;	state Exp;
branches;
next	1.167;

1.167
date	2012.08.29.16.26.17;	author gilles;	state Exp;
branches;
next	1.166;

1.166
date	2012.08.26.16.35.17;	author gilles;	state Exp;
branches;
next	1.165;

1.165
date	2012.08.26.11.52.48;	author gilles;	state Exp;
branches;
next	1.164;

1.164
date	2012.08.25.23.35.09;	author chl;	state Exp;
branches;
next	1.163;

1.163
date	2012.08.25.15.39.11;	author gilles;	state Exp;
branches;
next	1.162;

1.162
date	2012.08.25.11.38.18;	author gilles;	state Exp;
branches;
next	1.161;

1.161
date	2012.08.21.13.13.17;	author eric;	state Exp;
branches;
next	1.160;

1.160
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.159;

1.159
date	2012.08.19.08.47.41;	author chl;	state Exp;
branches;
next	1.158;

1.158
date	2012.08.18.18.18.23;	author gilles;	state Exp;
branches;
next	1.157;

1.157
date	2012.08.09.09.48.02;	author eric;	state Exp;
branches;
next	1.156;

1.156
date	2012.08.08.17.28.36;	author eric;	state Exp;
branches;
next	1.155;

1.155
date	2012.07.09.17.57.54;	author gilles;	state Exp;
branches;
next	1.154;

1.154
date	2012.07.09.09.57.53;	author gilles;	state Exp;
branches;
next	1.153;

1.153
date	2012.07.08.18.13.08;	author chl;	state Exp;
branches;
next	1.152;

1.152
date	2012.07.02.17.00.05;	author eric;	state Exp;
branches;
next	1.151;

1.151
date	2012.06.01.14.55.09;	author eric;	state Exp;
branches;
next	1.150;

1.150
date	2012.01.28.16.52.24;	author gilles;	state Exp;
branches;
next	1.149;

1.149
date	2012.01.24.12.20.18;	author eric;	state Exp;
branches;
next	1.148;

1.148
date	2012.01.18.13.41.54;	author chl;	state Exp;
branches;
next	1.147;

1.147
date	2012.01.13.14.01.58;	author eric;	state Exp;
branches;
next	1.146;

1.146
date	2012.01.12.18.06.18;	author eric;	state Exp;
branches;
next	1.145;

1.145
date	2012.01.12.12.52.11;	author eric;	state Exp;
branches;
next	1.144;

1.144
date	2012.01.11.17.46.36;	author eric;	state Exp;
branches;
next	1.143;

1.143
date	2011.12.13.23.55.00;	author gilles;	state Exp;
branches;
next	1.142;

1.142
date	2011.12.13.22.04.35;	author eric;	state Exp;
branches;
next	1.141;

1.141
date	2011.12.13.21.44.47;	author gilles;	state Exp;
branches;
next	1.140;

1.140
date	2011.12.12.17.20.36;	author eric;	state Exp;
branches;
next	1.139;

1.139
date	2011.12.08.17.00.28;	author todd;	state Exp;
branches;
next	1.138;

1.138
date	2011.11.16.11.18.54;	author eric;	state Exp;
branches;
next	1.137;

1.137
date	2011.11.14.19.23.41;	author chl;	state Exp;
branches;
next	1.136;

1.136
date	2011.11.14.11.53.10;	author eric;	state Exp;
branches;
next	1.135;

1.135
date	2011.11.07.11.14.10;	author eric;	state Exp;
branches;
next	1.134;

1.134
date	2011.10.26.20.47.31;	author gilles;	state Exp;
branches;
next	1.133;

1.133
date	2011.10.22.06.42.44;	author jmc;	state Exp;
branches;
next	1.132;

1.132
date	2011.10.22.00.16.33;	author eric;	state Exp;
branches;
next	1.131;

1.131
date	2011.10.09.18.39.54;	author eric;	state Exp;
branches;
next	1.130;

1.130
date	2011.09.01.19.56.49;	author eric;	state Exp;
branches;
next	1.129;

1.129
date	2011.08.29.21.43.09;	author chl;	state Exp;
branches;
next	1.128;

1.128
date	2011.08.27.22.32.41;	author gilles;	state Exp;
branches;
next	1.127;

1.127
date	2011.08.26.14.39.47;	author chl;	state Exp;
branches;
next	1.126;

1.126
date	2011.05.17.18.54.32;	author gilles;	state Exp;
branches;
next	1.125;

1.125
date	2011.05.17.16.42.06;	author gilles;	state Exp;
branches;
next	1.124;

1.124
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.123;

1.123
date	2011.05.04.20.45.30;	author eric;	state Exp;
branches;
next	1.122;

1.122
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.121;

1.121
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.120;

1.120
date	2011.04.14.22.46.38;	author gilles;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.14.20.11.08;	author gilles;	state Exp;
branches;
next	1.118;

1.118
date	2011.04.14.17.06.43;	author gilles;	state Exp;
branches;
next	1.117;

1.117
date	2011.04.13.20.53.18;	author gilles;	state Exp;
branches;
next	1.116;

1.116
date	2011.03.15.19.24.55;	author gilles;	state Exp;
branches;
next	1.115;

1.115
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.114;

1.114
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.113;

1.113
date	2010.10.09.22.05.35;	author gilles;	state Exp;
branches;
next	1.112;

1.112
date	2010.06.02.19.16.53;	author chl;	state Exp;
branches;
next	1.111;

1.111
date	2010.06.01.23.06.25;	author jacekm;	state Exp;
branches;
next	1.110;

1.110
date	2010.06.01.19.47.09;	author jacekm;	state Exp;
branches;
next	1.109;

1.109
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	1.108;

1.108
date	2010.05.31.22.25.26;	author chl;	state Exp;
branches;
next	1.107;

1.107
date	2010.05.27.15.36.04;	author gilles;	state Exp;
branches;
next	1.106;

1.106
date	2010.05.23.18.44.14;	author jacekm;	state Exp;
branches;
next	1.105;

1.105
date	2010.05.21.08.45.02;	author jacekm;	state Exp;
branches;
next	1.104;

1.104
date	2010.05.20.18.35.33;	author gilles;	state Exp;
branches;
next	1.103;

1.103
date	2010.05.09.15.24.49;	author gilles;	state Exp;
branches;
next	1.102;

1.102
date	2010.04.21.18.54.43;	author jacekm;	state Exp;
branches;
next	1.101;

1.101
date	2010.04.20.15.34.56;	author jacekm;	state Exp;
branches;
next	1.100;

1.100
date	2010.04.20.01.01.43;	author jacekm;	state Exp;
branches;
next	1.99;

1.99
date	2010.04.20.00.57.22;	author jacekm;	state Exp;
branches;
next	1.98;

1.98
date	2010.04.19.20.09.58;	author jacekm;	state Exp;
branches;
next	1.97;

1.97
date	2010.04.19.08.14.07;	author jacekm;	state Exp;
branches;
next	1.96;

1.96
date	2010.03.01.13.04.03;	author gilles;	state Exp;
branches;
next	1.95;

1.95
date	2010.01.10.08.59.19;	author gilles;	state Exp;
branches;
next	1.94;

1.94
date	2010.01.03.14.37.37;	author chl;	state Exp;
branches;
next	1.93;

1.93
date	2009.12.24.14.19.46;	author gilles;	state Exp;
branches;
next	1.92;

1.92
date	2009.12.14.19.56.55;	author jacekm;	state Exp;
branches;
next	1.91;

1.91
date	2009.12.14.13.17.51;	author jacekm;	state Exp;
branches;
next	1.90;

1.90
date	2009.12.13.22.02.55;	author jacekm;	state Exp;
branches;
next	1.89;

1.89
date	2009.11.14.18.48.05;	author chl;	state Exp;
branches;
next	1.88;

1.88
date	2009.11.03.11.10.43;	author jacekm;	state Exp;
branches;
next	1.87;

1.87
date	2009.10.19.20.00.46;	author gilles;	state Exp;
branches;
next	1.86;

1.86
date	2009.10.07.18.19.39;	author gilles;	state Exp;
branches;
next	1.85;

1.85
date	2009.09.04.11.49.23;	author jacekm;	state Exp;
branches;
next	1.84;

1.84
date	2009.09.03.08.19.13;	author jacekm;	state Exp;
branches;
next	1.83;

1.83
date	2009.08.27.09.21.28;	author jacekm;	state Exp;
branches;
next	1.82;

1.82
date	2009.08.07.20.21.48;	author gilles;	state Exp;
branches;
next	1.81;

1.81
date	2009.08.07.19.02.55;	author gilles;	state Exp;
branches;
next	1.80;

1.80
date	2009.08.06.16.46.57;	author gilles;	state Exp;
branches;
next	1.79;

1.79
date	2009.08.06.13.40.45;	author gilles;	state Exp;
branches;
next	1.78;

1.78
date	2009.07.28.22.03.55;	author gilles;	state Exp;
branches;
next	1.77;

1.77
date	2009.07.28.21.12.26;	author jsg;	state Exp;
branches;
next	1.76;

1.76
date	2009.07.28.13.54.35;	author gilles;	state Exp;
branches;
next	1.75;

1.75
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.74;

1.74
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.73;

1.73
date	2009.06.03.18.16.29;	author gilles;	state Exp;
branches;
next	1.72;

1.72
date	2009.06.02.22.23.36;	author gilles;	state Exp;
branches;
next	1.71;

1.71
date	2009.06.01.18.24.01;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.01.13.20.56;	author jacekm;	state Exp;
branches;
next	1.69;

1.69
date	2009.05.30.23.53.41;	author gilles;	state Exp;
branches;
next	1.68;

1.68
date	2009.05.30.23.28.52;	author gilles;	state Exp;
branches;
next	1.67;

1.67
date	2009.05.25.14.00.36;	author jacekm;	state Exp;
branches;
next	1.66;

1.66
date	2009.05.24.15.47.31;	author jacekm;	state Exp;
branches;
next	1.65;

1.65
date	2009.05.24.14.38.56;	author jacekm;	state Exp;
branches;
next	1.64;

1.64
date	2009.05.24.14.22.24;	author jacekm;	state Exp;
branches;
next	1.63;

1.63
date	2009.05.20.16.07.26;	author gilles;	state Exp;
branches;
next	1.62;

1.62
date	2009.05.20.14.29.44;	author gilles;	state Exp;
branches;
next	1.61;

1.61
date	2009.05.19.22.54.46;	author gilles;	state Exp;
branches;
next	1.60;

1.60
date	2009.05.19.11.37.44;	author jacekm;	state Exp;
branches;
next	1.59;

1.59
date	2009.05.19.11.24.24;	author jacekm;	state Exp;
branches;
next	1.58;

1.58
date	2009.05.14.15.05.12;	author eric;	state Exp;
branches;
next	1.57;

1.57
date	2009.05.10.11.29.40;	author jacekm;	state Exp;
branches;
next	1.56;

1.56
date	2009.04.21.18.39.00;	author jacekm;	state Exp;
branches;
next	1.55;

1.55
date	2009.04.21.18.12.05;	author jacekm;	state Exp;
branches;
next	1.54;

1.54
date	2009.04.21.14.37.32;	author eric;	state Exp;
branches;
next	1.53;

1.53
date	2009.04.15.20.36.48;	author jacekm;	state Exp;
branches;
next	1.52;

1.52
date	2009.04.03.05.20.17;	author oga;	state Exp;
branches;
next	1.51;

1.51
date	2009.03.29.14.18.20;	author jacekm;	state Exp;
branches;
next	1.50;

1.50
date	2009.03.22.22.53.47;	author gilles;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.10.21.14.21;	author jacekm;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.10.19.13.28;	author jacekm;	state Exp;
branches;
next	1.47;

1.47
date	2009.03.10.19.09.29;	author jacekm;	state Exp;
branches;
next	1.46;

1.46
date	2009.03.10.18.44.28;	author jacekm;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.10.13.05.05;	author jacekm;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.10.10.01.39;	author jacekm;	state Exp;
branches;
next	1.43;

1.43
date	2009.03.09.23.35.04;	author jacekm;	state Exp;
branches;
next	1.42;

1.42
date	2009.03.08.17.54.20;	author gilles;	state Exp;
branches;
next	1.41;

1.41
date	2009.03.04.00.00.40;	author gilles;	state Exp;
branches;
next	1.40;

1.40
date	2009.03.03.23.23.52;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2009.03.03.15.47.27;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.01.21.58.53;	author jacekm;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.01.21.36.50;	author jacekm;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.01.15.06.23;	author jacekm;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.01.13.08.47;	author jacekm;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.01.13.07.52;	author jacekm;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.25.09.08.34;	author jacekm;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.23.00.51.32;	author chl;	state Exp;
branches;
next	1.31;

1.31
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.15.10.32.23;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2009.01.30.17.34.58;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2009.01.30.10.03.29;	author form;	state Exp;
branches;
next	1.27;

1.27
date	2009.01.29.21.59.15;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2009.01.28.19.38.46;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.27.11.42.30;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.21.00.00.30;	author jacekm;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.10.23.54.15;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.08.19.17.31;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.27.17.03.29;	author jacekm;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.22.12.56.21;	author jacekm;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.21.02.18.46;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.19.00.44.40;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.19.00.39.05;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.17.18.47.37;	author jacekm;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.11.23.10.28;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.05.02.51.32;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.03.17.58.00;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.22.22.22.05;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.17.20.37.48;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.17.20.14.23;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.11.21.02.20;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.11.01.01.39;	author chl;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.10.17.24.24;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.10.03.41.53;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.10.00.57.35;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.08.19.13;	author jmc;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;

1.234.4.1
date	2015.10.02.01.33.33;	author gilles;	state Exp;
branches;
next	;
commitid	2Q56YgF5PzqMcagu;

1.238.2.1
date	2015.10.02.01.28.43;	author gilles;	state Exp;
branches;
next	;
commitid	pAamrt3DJscJjb10;

1.239.4.1
date	2015.10.02.00.55.02;	author gilles;	state Exp;
branches;
next	;
commitid	5SntIHNUPMG4dcQ1;


desc
@@


1.288
log
@smtpd joins the 7 other daemons that share the same log.c file.

The only major difference was the "log_trace" concept that is only
used by smtpd - move it from log.c into util.c and make it a local
concept.  This also needed to rename the global "verbose" variable to
"tracing" in a few places.

OK krw@@ gilles@@ eric@@
@
text
@/*	$OpenBSD: smtpd.c,v 1.287 2016/10/19 14:06:07 jmc Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <sys/mman.h>

#include <bsd_auth.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <fts.h>
#include <imsg.h>
#include <inttypes.h>
#include <login_cap.h>
#include <paths.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include <openssl/ssl.h>
#include <openssl/evp.h>

#include "smtpd.h"
#include "log.h"
#include "ssl.h"

#define SMTPD_MAXARG 32

static void parent_imsg(struct mproc *, struct imsg *);
static void usage(void);
static int smtpd(void);
static void parent_shutdown(void);
static void parent_send_config(int, short, void *);
static void parent_send_config_lka(void);
static void parent_send_config_pony(void);
static void parent_send_config_ca(void);
static void parent_sig_handler(int, short, void *);
static void forkmda(struct mproc *, uint64_t, struct deliver *);
static int parent_forward_open(char *, char *, uid_t, gid_t);
static struct child *child_add(pid_t, int, const char *);
static struct mproc *start_child(int, char **, char *);
static struct mproc *setup_peer(enum smtp_proc_type, pid_t, int);
static void setup_peers(struct mproc *, struct mproc *);
static void setup_done(struct mproc *);
static void setup_proc(void);
static struct mproc *setup_peer(enum smtp_proc_type, pid_t, int);
static int imsg_wait(struct imsgbuf *, struct imsg *, int);

static void	offline_scan(int, short, void *);
static int	offline_add(char *);
static void	offline_done(void);
static int	offline_enqueue(char *);

static void	purge_task(void);
static int	parent_auth_user(const char *, const char *);
static void	load_pki_tree(void);
static void	load_pki_keys(void);

enum child_type {
	CHILD_DAEMON,
	CHILD_MDA,
	CHILD_ENQUEUE_OFFLINE,
};

struct child {
	pid_t			 pid;
	enum child_type		 type;
	const char		*title;
	int			 mda_out;
	uint64_t		 mda_id;
	char			*path;
	char			*cause;
};

struct offline {
	TAILQ_ENTRY(offline)	 entry;
	char			*path;
};

#define OFFLINE_READMAX		20
#define OFFLINE_QUEUEMAX	5
static size_t			offline_running = 0;
TAILQ_HEAD(, offline)		offline_q;

static struct event		config_ev;
static struct event		offline_ev;
static struct timeval		offline_timeout;

static pid_t			purge_pid = -1;

extern char	**environ;
void		(*imsg_callback)(struct mproc *, struct imsg *);

enum smtp_proc_type	smtpd_process;

struct smtpd	*env = NULL;

struct mproc	*p_control = NULL;
struct mproc	*p_lka = NULL;
struct mproc	*p_parent = NULL;
struct mproc	*p_queue = NULL;
struct mproc	*p_scheduler = NULL;
struct mproc	*p_pony = NULL;
struct mproc	*p_ca = NULL;

const char	*backend_queue = "fs";
const char	*backend_scheduler = "ramqueue";
const char	*backend_stat = "ram";

int	profiling = 0;
int	debug = 0;
int	foreground = 0;
int	control_socket = -1;

struct tree	 children;

static void
parent_imsg(struct mproc *p, struct imsg *imsg)
{
	struct forward_req	*fwreq;
	struct deliver		 deliver;
	struct child		*c;
	struct msg		 m;
	const void		*data;
	const char		*username, *password, *cause;
	uint64_t		 reqid;
	size_t			 sz;
	void			*i;
	int			 fd, n, v, ret;

	if (imsg == NULL)
		fatalx("process %s socket closed", p->name);

	if (p->proc == PROC_LKA) {
		switch (imsg->hdr.type) {
		case IMSG_LKA_OPEN_FORWARD:
			CHECK_IMSG_DATA_SIZE(imsg, sizeof *fwreq);
			fwreq = imsg->data;
			fd = parent_forward_open(fwreq->user, fwreq->directory,
			    fwreq->uid, fwreq->gid);
			fwreq->status = 0;
			if (fd == -1 && errno != ENOENT) {
				if (errno == EAGAIN)
					fwreq->status = -1;
			}
			else
				fwreq->status = 1;
			m_compose(p, IMSG_LKA_OPEN_FORWARD, 0, 0, fd,
			    fwreq, sizeof *fwreq);
			return;

		case IMSG_LKA_AUTHENTICATE:
			/*
			 * If we reached here, it means we want root to lookup
			 * system user.
			 */
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &username);
			m_get_string(&m, &password);
			m_end(&m);

			ret = parent_auth_user(username, password);

			m_create(p, IMSG_LKA_AUTHENTICATE, 0, 0, -1);
			m_add_id(p, reqid);
			m_add_int(p, ret);
			m_close(p);
			return;
		}
	}

	if (p->proc == PROC_PONY) {
		switch (imsg->hdr.type) {
		case IMSG_MDA_FORK:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_data(&m, &data, &sz);
			m_end(&m);
			if (sz != sizeof(deliver))
				fatalx("expected deliver");
			memmove(&deliver, data, sz);
			forkmda(p, reqid, &deliver);
			return;

		case IMSG_MDA_KILL:
			m_msg(&m, imsg);
			m_get_id(&m, &reqid);
			m_get_string(&m, &cause);
			m_end(&m);

			i = NULL;
			while ((n = tree_iter(&children, &i, NULL, (void**)&c)))
				if (c->type == CHILD_MDA &&
				    c->mda_id == reqid &&
				    c->cause == NULL)
					break;
			if (!n) {
				log_debug("debug: smtpd: "
				    "kill request: proc not found");
				return;
			}

			c->cause = xstrdup(cause, "parent_imsg");
			log_debug("debug: smtpd: kill requested for %u: %s",
			    c->pid, c->cause);
			kill(c->pid, SIGTERM);
			return;
		}
	}

	if (p->proc == PROC_CONTROL) {
		switch (imsg->hdr.type) {
		case IMSG_CTL_VERBOSE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			log_trace_verbose(v);
			return;

		case IMSG_CTL_PROFILE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			profiling = v;
			return;
		}
	}

	errx(1, "parent_imsg: unexpected %s imsg from %s",
	    imsg_to_str(imsg->hdr.type), proc_title(p->proc));
}

static void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr, "usage: %s [-dFhnv] [-D macro=value] "
	    "[-f file] [-P system] [-T trace]\n", __progname);
	exit(1);
}

static void
parent_shutdown(void)
{
	pid_t pid;

	mproc_clear(p_ca);
	mproc_clear(p_pony);
	mproc_clear(p_control);
	mproc_clear(p_lka);
	mproc_clear(p_scheduler);
	mproc_clear(p_queue);

	do {
		pid = waitpid(WAIT_MYPGRP, NULL, 0);
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	unlink(SMTPD_SOCKET);

	log_info("Exiting");
	exit(0);
}

static void
parent_send_config(int fd, short event, void *p)
{
	parent_send_config_lka();
	parent_send_config_pony();
	parent_send_config_ca();
	purge_config(PURGE_PKI);
}

static void
parent_send_config_pony(void)
{
	log_debug("debug: parent_send_config: configuring pony process");
	m_compose(p_pony, IMSG_CONF_START, 0, 0, -1, NULL, 0);
	m_compose(p_pony, IMSG_CONF_END, 0, 0, -1, NULL, 0);
}

void
parent_send_config_lka()
{
	log_debug("debug: parent_send_config_ruleset: reloading");
	m_compose(p_lka, IMSG_CONF_START, 0, 0, -1, NULL, 0);
	m_compose(p_lka, IMSG_CONF_END, 0, 0, -1, NULL, 0);
}

static void
parent_send_config_ca(void)
{
	log_debug("debug: parent_send_config: configuring ca process");
	m_compose(p_ca, IMSG_CONF_START, 0, 0, -1, NULL, 0);
	m_compose(p_ca, IMSG_CONF_END, 0, 0, -1, NULL, 0);
}

static void
parent_sig_handler(int sig, short event, void *p)
{
	struct child	*child;
	int		 status, fail;
	pid_t		 pid;
	char		*cause;

	switch (sig) {
	case SIGTERM:
	case SIGINT:
		log_debug("debug: got signal %d", sig);
		parent_shutdown();
		/* NOT REACHED */

	case SIGCHLD:
		do {
			int len;

			pid = waitpid(-1, &status, WNOHANG);
			if (pid <= 0)
				continue;

			fail = 0;
			if (WIFSIGNALED(status)) {
				fail = 1;
				len = asprintf(&cause, "terminated; signal %d",
				    WTERMSIG(status));
			} else if (WIFEXITED(status)) {
				if (WEXITSTATUS(status) != 0) {
					fail = 1;
					len = asprintf(&cause,
					    "exited abnormally");
				} else
					len = asprintf(&cause, "exited okay");
			} else
				/* WIFSTOPPED or WIFCONTINUED */
				continue;

			if (len == -1)
				fatal("asprintf");

			if (pid == purge_pid)
				purge_pid = -1;

			child = tree_pop(&children, pid);
			if (child == NULL)
				goto skip;

			switch (child->type) {
			case CHILD_DAEMON:
				if (fail)
					log_warnx("warn: lost child: %s %s",
					    child->title, cause);
				break;

			case CHILD_MDA:
				if (WIFSIGNALED(status) &&
				    WTERMSIG(status) == SIGALRM) {
					char *tmp;
					if (asprintf(&tmp,
					    "terminated; timeout") != -1) {
						free(cause);
						cause = tmp;
					}
				}
				else if (child->cause &&
				    WIFSIGNALED(status) &&
				    WTERMSIG(status) == SIGTERM) {
					free(cause);
					cause = child->cause;
					child->cause = NULL;
				}
				free(child->cause);
				log_debug("debug: smtpd: mda process done "
				    "for session %016"PRIx64 ": %s",
				    child->mda_id, cause);
				m_create(p_pony, IMSG_MDA_DONE, 0, 0,
				    child->mda_out);
				m_add_id(p_pony, child->mda_id);
				m_add_string(p_pony, cause);
				m_close(p_pony);
				/* free(cause); */
				break;

			case CHILD_ENQUEUE_OFFLINE:
				if (fail)
					log_warnx("warn: smtpd: "
					    "couldn't enqueue offline "
					    "message %s; smtpctl %s",
					    child->path, cause);
				else
					unlink(child->path);
				free(child->path);
				offline_done();
				break;

			default:
				fatalx("smtpd: unexpected child type");
			}
			free(child);
    skip:
			free(cause);
		} while (pid > 0 || (pid == -1 && errno == EINTR));

		break;
	default:
		fatalx("smtpd: unexpected signal");
	}
}

int
main(int argc, char *argv[])
{
	int		 c, i;
	int		 opts, flags;
	const char	*conffile = CONF_FILE;
	int		 save_argc = argc;
	char		**save_argv = argv;
	char		*rexec = NULL;
	struct smtpd	 conf;

	env = &conf;

	flags = 0;
	opts = 0;
	debug = 0;
	tracing = 0;

	log_init(1, LOG_MAIL);

	TAILQ_INIT(&offline_q);

	while ((c = getopt(argc, argv, "B:dD:hnP:f:FT:vx:")) != -1) {
		switch (c) {
		case 'B':
			if (strstr(optarg, "queue=") == optarg)
				backend_queue = strchr(optarg, '=') + 1;
			else if (strstr(optarg, "scheduler=") == optarg)
				backend_scheduler = strchr(optarg, '=') + 1;
			else if (strstr(optarg, "stat=") == optarg)
				backend_stat = strchr(optarg, '=') + 1;
			else
				log_warnx("warn: "
				    "invalid backend specifier %s",
				    optarg);
			break;
		case 'd':
			foreground = 1;
			foreground_log = 1;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("warn: "
				    "could not parse macro definition %s",
				    optarg);
			break;
		case 'h':
			log_info("version: " SMTPD_NAME " " SMTPD_VERSION);
			usage();
			break;
		case 'n':
			debug = 2;
			opts |= SMTPD_OPT_NOACTION;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'F':
			foreground = 1;
			break;

		case 'T':
			if (!strcmp(optarg, "imsg"))
				tracing |= TRACE_IMSG;
			else if (!strcmp(optarg, "io"))
				tracing |= TRACE_IO;
			else if (!strcmp(optarg, "smtp"))
				tracing |= TRACE_SMTP;
			else if (!strcmp(optarg, "mfa") ||
			    !strcmp(optarg, "filter") ||
			    !strcmp(optarg, "filters"))
				tracing |= TRACE_FILTERS;
			else if (!strcmp(optarg, "mta") ||
			    !strcmp(optarg, "transfer"))
				tracing |= TRACE_MTA;
			else if (!strcmp(optarg, "bounce") ||
			    !strcmp(optarg, "bounces"))
				tracing |= TRACE_BOUNCE;
			else if (!strcmp(optarg, "scheduler"))
				tracing |= TRACE_SCHEDULER;
			else if (!strcmp(optarg, "lookup"))
				tracing |= TRACE_LOOKUP;
			else if (!strcmp(optarg, "stat") ||
			    !strcmp(optarg, "stats"))
				tracing |= TRACE_STAT;
			else if (!strcmp(optarg, "rules"))
				tracing |= TRACE_RULES;
			else if (!strcmp(optarg, "mproc"))
				tracing |= TRACE_MPROC;
			else if (!strcmp(optarg, "expand"))
				tracing |= TRACE_EXPAND;
			else if (!strcmp(optarg, "table") ||
			    !strcmp(optarg, "tables"))
				tracing |= TRACE_TABLES;
			else if (!strcmp(optarg, "queue"))
				tracing |= TRACE_QUEUE;
			else if (!strcmp(optarg, "all"))
				tracing |= ~TRACE_DEBUG;
			else if (!strcmp(optarg, "profstat"))
				profiling |= PROFILE_TOSTAT;
			else if (!strcmp(optarg, "profile-imsg"))
				profiling |= PROFILE_IMSG;
			else if (!strcmp(optarg, "profile-queue"))
				profiling |= PROFILE_QUEUE;
			else
				log_warnx("warn: unknown trace flag \"%s\"",
				    optarg);
			break;
		case 'P':
			if (!strcmp(optarg, "smtp"))
				flags |= SMTPD_SMTP_PAUSED;
			else if (!strcmp(optarg, "mta"))
				flags |= SMTPD_MTA_PAUSED;
			else if (!strcmp(optarg, "mda"))
				flags |= SMTPD_MDA_PAUSED;
			break;
		case 'v':
			tracing |=  TRACE_DEBUG;
			break;
		case 'x':
			rexec = optarg;
			break;
		default:
			usage();
		}
	}

	argv += optind;
	argc -= optind;

	if (argc || *argv)
		usage();

	ssl_init();

	if (parse_config(&conf, conffile, opts))
		exit(1);

	if (strlcpy(env->sc_conffile, conffile, PATH_MAX)
	    >= PATH_MAX)
		errx(1, "config file exceeds PATH_MAX");

	if (env->sc_opts & SMTPD_OPT_NOACTION) {
		if (env->sc_queue_key &&
		    crypto_setup(env->sc_queue_key,
		    strlen(env->sc_queue_key)) == 0) {
			fatalx("crypto_setup:"
			    "invalid key for queue encryption");
		}
		load_pki_tree();
		load_pki_keys();
		fprintf(stderr, "configuration OK\n");
		exit(0);
	}

	env->sc_flags |= flags;

	/* check for root privileges */
	if (geteuid())
		errx(1, "need root privileges");

	log_init(foreground_log, LOG_MAIL);
	log_trace_verbose(tracing);
	load_pki_tree();
	load_pki_keys();

	log_debug("debug: using \"%s\" queue backend", backend_queue);
	log_debug("debug: using \"%s\" scheduler backend", backend_scheduler);
	log_debug("debug: using \"%s\" stat backend", backend_stat);

	if (env->sc_hostname[0] == '\0')
		errx(1, "machine does not have a hostname set");
	env->sc_uptime = time(NULL);

	if (rexec == NULL) {
		smtpd_process = PROC_PARENT;

		if (env->sc_queue_flags & QUEUE_ENCRYPTION) {
			if (env->sc_queue_key == NULL) {
				char	*password;

				password = getpass("queue key: ");
				if (password == NULL)
					err(1, "getpass");

				env->sc_queue_key = strdup(password);
				explicit_bzero(password, strlen(password));
				if (env->sc_queue_key == NULL)
					err(1, "strdup");
			}
			else {
				char   *buf = NULL;
				size_t	sz = 0;
				ssize_t	len;

				if (strcasecmp(env->sc_queue_key, "stdin") == 0) {
					if ((len = getline(&buf, &sz, stdin)) == -1)
						err(1, "getline");
					if (buf[len - 1] == '\n')
						buf[len - 1] = '\0';
					env->sc_queue_key = buf;
				}
			}
		}

		log_info("info: %s %s starting", SMTPD_NAME, SMTPD_VERSION);

		if (!foreground)
			if (daemon(0, 0) == -1)
				err(1, "failed to daemonize");

		/* setup all processes */

		p_ca = start_child(save_argc, save_argv, "ca");
		p_ca->proc = PROC_CA;

		p_control = start_child(save_argc, save_argv, "control");
		p_control->proc = PROC_CONTROL;

		p_lka = start_child(save_argc, save_argv, "lka");
		p_lka->proc = PROC_LKA;

		p_pony = start_child(save_argc, save_argv, "pony");
		p_pony->proc = PROC_PONY;

		p_queue = start_child(save_argc, save_argv, "queue");
		p_queue->proc = PROC_QUEUE;

		p_scheduler = start_child(save_argc, save_argv, "scheduler");
		p_scheduler->proc = PROC_SCHEDULER;

		setup_peers(p_control, p_ca);
		setup_peers(p_control, p_lka);
		setup_peers(p_control, p_pony);
		setup_peers(p_control, p_queue);
		setup_peers(p_control, p_scheduler);
		setup_peers(p_pony, p_ca);
		setup_peers(p_pony, p_lka);
		setup_peers(p_pony, p_queue);
		setup_peers(p_queue, p_lka);
		setup_peers(p_queue, p_scheduler);

		if (env->sc_queue_key) {
			if (imsg_compose(&p_queue->imsgbuf, IMSG_SETUP_KEY, 0,
			    0, -1, env->sc_queue_key, strlen(env->sc_queue_key)
			    + 1) == -1)
				fatal("imsg_compose");
			if (imsg_flush(&p_queue->imsgbuf) == -1)
				fatal("imsg_flush");
		}

		setup_done(p_ca);
		setup_done(p_control);
		setup_done(p_lka);
		setup_done(p_pony);
		setup_done(p_queue);
		setup_done(p_scheduler);

		log_debug("smtpd: setup done");

		return smtpd();
	}

	if (!strcmp(rexec, "ca")) {
		smtpd_process = PROC_CA;
		setup_proc();

		return ca();
	}

	else if (!strcmp(rexec, "control")) {
		smtpd_process = PROC_CONTROL;
		setup_proc();

		/* the control socket ensures that only one smtpd instance is running */
		control_socket = control_create_socket();

		env->sc_stat = stat_backend_lookup(backend_stat);
		if (env->sc_stat == NULL)
			errx(1, "could not find stat backend \"%s\"", backend_stat);

		return control();
	}

	else if (!strcmp(rexec, "lka")) {
		smtpd_process = PROC_LKA;
		setup_proc();

		return lka();
	}

	else if (!strcmp(rexec, "pony")) {
		smtpd_process = PROC_PONY;
		setup_proc();

		return pony();
	}

	else if (!strcmp(rexec, "queue")) {
		smtpd_process = PROC_QUEUE;
		setup_proc();

		if (env->sc_queue_flags & QUEUE_COMPRESSION)
			env->sc_comp = compress_backend_lookup("gzip");

		if (!queue_init(backend_queue, 1))
			errx(1, "could not initialize queue backend");

		return queue();
	}

	else if (!strcmp(rexec, "scheduler")) {
		smtpd_process = PROC_SCHEDULER;
		setup_proc();

		for (i = 0; i < MAX_BOUNCE_WARN; i++) {
			if (env->sc_bounce_warn[i] == 0)
				break;
			log_debug("debug: bounce warning after %s",
			    duration_to_text(env->sc_bounce_warn[i]));
		}

		return scheduler();
	}

	fatalx("bad rexec: %s", rexec);

	return (1);
}

static struct mproc *
start_child(int save_argc, char **save_argv, char *rexec)
{
	struct mproc *p;
	char *argv[SMTPD_MAXARG];
	int sp[2], argc = 0;
	pid_t pid;

	if (save_argc >= SMTPD_MAXARG - 2)
		fatalx("too many arguments");

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, sp) == -1)
		fatal("socketpair");

	io_set_nonblocking(sp[0]);
	io_set_nonblocking(sp[1]);

	switch (pid = fork()) {
	case -1:
		fatal("%s: fork", save_argv[0]);
	case 0:
		break;
	default:
		close(sp[0]);
		p = calloc(1, sizeof(*p));
		if (p == NULL)
			fatal("calloc");
		if((p->name = strdup(rexec)) == NULL)
			fatal("strdup");
		mproc_init(p, sp[1]);
		p->pid = pid;
		p->handler = parent_imsg;
		return p;
	}

	if (dup2(sp[0], 3) == -1)
		fatal("%s: dup2", rexec);

	if (closefrom(4) == -1)
		fatal("%s: closefrom", rexec);

	for (argc = 0; argc < save_argc; argc++)
		argv[argc] = save_argv[argc];
	argv[argc++] = "-x";
	argv[argc++] = rexec;
	argv[argc++] = NULL;

	execvp(argv[0], argv);
	fatal("%s: execvp", rexec);
}

static void
setup_peers(struct mproc *a, struct mproc *b)
{
	int sp[2];

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, sp) == -1)
		fatal("socketpair");

	io_set_nonblocking(sp[0]);
	io_set_nonblocking(sp[1]);

	if (imsg_compose(&a->imsgbuf, IMSG_SETUP_PEER, b->proc, b->pid, sp[0],
	    NULL, 0) == -1)
		fatal("imsg_compose");
	if (imsg_flush(&a->imsgbuf) == -1)
		fatal("imsg_flush");

	if (imsg_compose(&b->imsgbuf, IMSG_SETUP_PEER, a->proc, a->pid, sp[1],
	    NULL, 0) == -1)
		fatal("imsg_compose");
	if (imsg_flush(&b->imsgbuf) == -1)
		fatal("imsg_flush");
}

static void
setup_done(struct mproc *p)
{
	struct imsg imsg;

	if (imsg_compose(&p->imsgbuf, IMSG_SETUP_DONE, 0, 0, -1, NULL, 0) == -1)
		fatal("imsg_compose");
	if (imsg_flush(&p->imsgbuf) == -1)
		fatal("imsg_flush");

	if (imsg_wait(&p->imsgbuf, &imsg, 10000) == -1)
		fatal("imsg_wait");

	if (imsg.hdr.type != IMSG_SETUP_DONE)
		fatalx("expect IMSG_SETUP_DONE");

	log_debug("setup_done: %s[%d] done", p->name, p->pid);

	imsg_free(&imsg);
}

static void
setup_proc(void)
{
	struct imsgbuf *ibuf;
	struct imsg imsg;
        int setup = 1;

	log_procinit(proc_title(smtpd_process));

	p_parent = calloc(1, sizeof(*p_parent));
	if (p_parent == NULL)
		fatal("calloc");
	if((p_parent->name = strdup("parent")) == NULL)
		fatal("strdup");
	p_parent->proc = PROC_PARENT;
	p_parent->handler = imsg_dispatch;
	mproc_init(p_parent, 3);

	ibuf = &p_parent->imsgbuf;

	while (setup) {
		if (imsg_wait(ibuf, &imsg, 10000) == -1)
			fatal("imsg_wait");

		switch (imsg.hdr.type) {
		case IMSG_SETUP_KEY:
			env->sc_queue_key = strdup(imsg.data);
			break;
		case IMSG_SETUP_PEER:
			setup_peer(imsg.hdr.peerid, imsg.hdr.pid, imsg.fd);
			break;
		case IMSG_SETUP_DONE:
			setup = 0;
			break;
		default:
			fatal("bad imsg %d", imsg.hdr.type);
		}
		imsg_free(&imsg);
	}

	if (imsg_compose(ibuf, IMSG_SETUP_DONE, 0, 0, -1, NULL, 0) == -1)
		fatal("imsg_compose");

	if (imsg_flush(ibuf) == -1)
		fatal("imsg_flush");

	log_debug("setup_proc: %s done", proc_title(smtpd_process));
}

static struct mproc *
setup_peer(enum smtp_proc_type proc, pid_t pid, int sock)
{
	struct mproc *p, **pp;

	log_debug("setup_peer: %s -> %s[%u] fd=%d", proc_title(smtpd_process),
	    proc_title(proc), pid, sock);

	if (sock == -1)
		fatalx("peer socket not received");

	switch (proc) {
	case PROC_LKA:
		pp = &p_lka;
		break;
	case PROC_QUEUE:
		pp = &p_queue;
		break;
	case PROC_CONTROL:
		pp = &p_control;
		break;
	case PROC_SCHEDULER:
		pp = &p_scheduler;
		break;
	case PROC_PONY:
		pp = &p_pony;
		break;
	case PROC_CA:
		pp = &p_ca;
		break;
	default:
		fatalx("unknown peer");
	}

	if (*pp)
		fatalx("peer already set");

	p = calloc(1, sizeof(*p));
	if (p == NULL)
		fatal("calloc");
	if((p->name = strdup(proc_title(proc))) == NULL)
		fatal("strdup");
	mproc_init(p, sock);
	p->pid = pid;
	p->proc = proc;
	p->handler = imsg_dispatch;

	*pp = p;

	return p;
}

static int
imsg_wait(struct imsgbuf *ibuf, struct imsg *imsg, int timeout)
{
	struct pollfd pfd[1];
	ssize_t n;

	pfd[0].fd = ibuf->fd;
	pfd[0].events = POLLIN;
	
	while (1) {
		if ((n = imsg_get(ibuf, imsg)) == -1)
			return -1;
		if (n)
			return 1;

		n = poll(pfd, 1, timeout);
		if (n == -1)
			return -1;
		if (n == 0) {
			errno = ETIMEDOUT;
			return -1;
		}

		if (((n = imsg_read(ibuf)) == -1 && errno != EAGAIN) || n == 0)
			return -1;
	}
}

int
smtpd(void) {
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct event	 ev_sigchld;
	struct event	 ev_sighup;
	struct timeval	 tv;

	imsg_callback = parent_imsg;

	tree_init(&children);

	child_add(p_queue->pid, CHILD_DAEMON, proc_title(PROC_QUEUE));
	child_add(p_control->pid, CHILD_DAEMON, proc_title(PROC_CONTROL));
	child_add(p_lka->pid, CHILD_DAEMON, proc_title(PROC_LKA));
	child_add(p_scheduler->pid, CHILD_DAEMON, proc_title(PROC_SCHEDULER));
	child_add(p_pony->pid, CHILD_DAEMON, proc_title(PROC_PONY));
	child_add(p_ca->pid, CHILD_DAEMON, proc_title(PROC_CA));

	event_init();

	signal_set(&ev_sigint, SIGINT, parent_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, parent_sig_handler, NULL);
	signal_set(&ev_sigchld, SIGCHLD, parent_sig_handler, NULL);
	signal_set(&ev_sighup, SIGHUP, parent_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sigchld, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);

	config_peer(PROC_CONTROL);
	config_peer(PROC_LKA);
	config_peer(PROC_QUEUE);
	config_peer(PROC_CA);
	config_peer(PROC_PONY);

	evtimer_set(&config_ev, parent_send_config, NULL);
	memset(&tv, 0, sizeof(tv));
	evtimer_add(&config_ev, &tv);

	/* defer offline scanning for a second */
	evtimer_set(&offline_ev, offline_scan, NULL);
	offline_timeout.tv_sec = 1;
	offline_timeout.tv_usec = 0;
	evtimer_add(&offline_ev, &offline_timeout);

	purge_task();

	if (pledge("stdio rpath wpath cpath fattr flock tmppath "
	    "getpw sendfd proc exec id inet unix", NULL) == -1)
		err(1, "pledge");

	event_dispatch();
	fatalx("exited event loop");

	return (0);
}

static void
load_pki_tree(void)
{
	struct pki	*pki;
	struct ca	*sca;
	const char	*k;
	void		*iter_dict;

	log_debug("debug: init ssl-tree");
	iter_dict = NULL;
	while (dict_iter(env->sc_pki_dict, &iter_dict, &k, (void **)&pki)) {
		log_debug("info: loading pki information for %s", k);
		if (pki->pki_cert_file == NULL)
			fatalx("load_pki_tree: missing certificate file");
		if (pki->pki_key_file == NULL)
			fatalx("load_pki_tree: missing key file");

		if (!ssl_load_certificate(pki, pki->pki_cert_file))
			fatalx("load_pki_tree: failed to load certificate file");
	}

	log_debug("debug: init ca-tree");
	iter_dict = NULL;
	while (dict_iter(env->sc_ca_dict, &iter_dict, &k, (void **)&sca)) {
		log_debug("info: loading CA information for %s", k);
		if (!ssl_load_cafile(sca, sca->ca_cert_file))
			fatalx("load_pki_tree: failed to load CA file");
	}
}

void
load_pki_keys(void)
{
	struct pki	*pki;
	const char	*k;
	void		*iter_dict;

	log_debug("debug: init ssl-tree");
	iter_dict = NULL;
	while (dict_iter(env->sc_pki_dict, &iter_dict, &k, (void **)&pki)) {
		log_debug("info: loading pki keys for %s", k);

		if (!ssl_load_keyfile(pki, pki->pki_key_file, k))
			fatalx("load_pki_keys: failed to load key file");
	}
}

int
fork_proc_backend(const char *key, const char *conf, const char *procname)
{
	pid_t		pid;
	int		sp[2];
	char		path[PATH_MAX];
	char		name[PATH_MAX];
	char		*arg;

	if (strlcpy(name, conf, sizeof(name)) >= sizeof(name)) {
		log_warnx("warn: %s-proc: conf too long", key);
		return (0);
	}

	arg = strchr(name, ':');
	if (arg)
		*arg++ = '\0';

	if (snprintf(path, sizeof(path), PATH_LIBEXEC "/%s-%s", key, name) >=
	    (ssize_t)sizeof(path)) {
		log_warn("warn: %s-proc: exec path too long", key);
		return (-1);
	}

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, sp) == -1) {
		log_warn("warn: %s-proc: socketpair", key);
		return (-1);
	}

	if ((pid = fork()) == -1) {
		log_warn("warn: %s-proc: fork", key);
		close(sp[0]);
		close(sp[1]);
		return (-1);
	}

	if (pid == 0) {
		/* child process */
		dup2(sp[0], STDIN_FILENO);
		if (closefrom(STDERR_FILENO + 1) < 0)
			exit(1);

		if (procname == NULL)
			procname = name;

		execl(path, procname, arg, (char *)NULL);
		err(1, "execl: %s", path);
	}

	/* parent process */
	close(sp[0]);

	return (sp[1]);
}

struct child *
child_add(pid_t pid, int type, const char *title)
{
	struct child	*child;

	if ((child = calloc(1, sizeof(*child))) == NULL)
		fatal("smtpd: child_add: calloc");

	child->pid = pid;
	child->type = type;
	child->title = title;

	tree_xset(&children, pid, child);

	return (child);
}

static void
purge_task(void)
{
	struct passwd	*pw;
	DIR		*d;
	int		 n;
	uid_t		 uid;
	gid_t		 gid;

	n = 0;
	if ((d = opendir(PATH_SPOOL PATH_PURGE))) {
		while (readdir(d) != NULL)
			n++;
		closedir(d);
	} else
		log_warn("warn: purge_task: opendir");

	if (n > 2) {
		switch (purge_pid = fork()) {
		case -1:
			log_warn("warn: purge_task: fork");
			break;
		case 0:
			if ((pw = getpwnam(SMTPD_USER)) == NULL)
				fatalx("unknown user " SMTPD_USER);
			if (chroot(PATH_SPOOL PATH_PURGE) == -1)
				fatal("smtpd: chroot");
			if (chdir("/") == -1)
				fatal("smtpd: chdir");
			uid = pw->pw_uid;
			gid = pw->pw_gid;
			if (setgroups(1, &gid) ||
			    setresgid(gid, gid, gid) ||
			    setresuid(uid, uid, uid))
				fatal("smtpd: cannot drop privileges");
			rmtree("/", 1);
			_exit(0);
			break;
		default:
			break;
		}
	}
}

static void
forkmda(struct mproc *p, uint64_t id, struct deliver *deliver)
{
	char		 ebuf[128], sfn[32];
	struct delivery_backend	*db;
	struct child	*child;
	pid_t		 pid;
	int		 allout, pipefd[2];

	log_debug("debug: smtpd: forking mda for session %016"PRIx64
	    ": \"%s\" as %s", id, deliver->to, deliver->user);

	db = delivery_backend_lookup(deliver->mode);
	if (db == NULL) {
		(void)snprintf(ebuf, sizeof ebuf, "could not find delivery backend");
		m_create(p_pony, IMSG_MDA_DONE, 0, 0, -1);
		m_add_id(p_pony, id);
		m_add_string(p_pony, ebuf);
		m_close(p_pony);
		return;
	}

	if (deliver->userinfo.uid == 0 && !db->allow_root) {
		(void)snprintf(ebuf, sizeof ebuf, "not allowed to deliver to: %s",
		    deliver->user);
		m_create(p_pony, IMSG_MDA_DONE, 0, 0, -1);
		m_add_id(p_pony, id);
		m_add_string(p_pony, ebuf);
		m_close(p_pony);
		return;
	}

	if (pipe(pipefd) < 0) {
		(void)snprintf(ebuf, sizeof ebuf, "pipe: %s", strerror(errno));
		m_create(p_pony, IMSG_MDA_DONE, 0, 0, -1);
		m_add_id(p_pony, id);
		m_add_string(p_pony, ebuf);
		m_close(p_pony);
		return;
	}

	/* prepare file which captures stdout and stderr */
	(void)strlcpy(sfn, "/tmp/smtpd.out.XXXXXXXXXXX", sizeof(sfn));
	allout = mkstemp(sfn);
	if (allout < 0) {
		(void)snprintf(ebuf, sizeof ebuf, "mkstemp: %s", strerror(errno));
		m_create(p_pony, IMSG_MDA_DONE, 0, 0, -1);
		m_add_id(p_pony, id);
		m_add_string(p_pony, ebuf);
		m_close(p_pony);
		close(pipefd[0]);
		close(pipefd[1]);
		return;
	}
	unlink(sfn);

	pid = fork();
	if (pid < 0) {
		(void)snprintf(ebuf, sizeof ebuf, "fork: %s", strerror(errno));
		m_create(p_pony, IMSG_MDA_DONE, 0, 0, -1);
		m_add_id(p_pony, id);
		m_add_string(p_pony, ebuf);
		m_close(p_pony);
		close(pipefd[0]);
		close(pipefd[1]);
		close(allout);
		return;
	}

	/* parent passes the child fd over to mda */
	if (pid > 0) {
		child = child_add(pid, CHILD_MDA, NULL);
		child->mda_out = allout;
		child->mda_id = id;
		close(pipefd[0]);
		m_create(p, IMSG_MDA_FORK, 0, 0, pipefd[1]);
		m_add_id(p, id);
		m_close(p);
		return;
	}

	if (chdir(deliver->userinfo.directory) < 0 && chdir("/") < 0)
		err(1, "chdir");
	if (setgroups(1, &deliver->userinfo.gid) ||
	    setresgid(deliver->userinfo.gid, deliver->userinfo.gid, deliver->userinfo.gid) ||
	    setresuid(deliver->userinfo.uid, deliver->userinfo.uid, deliver->userinfo.uid))
		err(1, "forkmda: cannot drop privileges");
	if (dup2(pipefd[0], STDIN_FILENO) < 0 ||
	    dup2(allout, STDOUT_FILENO) < 0 ||
	    dup2(allout, STDERR_FILENO) < 0)
		err(1, "forkmda: dup2");
	if (closefrom(STDERR_FILENO + 1) < 0)
		err(1, "closefrom");
	if (setsid() < 0)
		err(1, "setsid");
	if (signal(SIGPIPE, SIG_DFL) == SIG_ERR ||
	    signal(SIGINT, SIG_DFL) == SIG_ERR ||
	    signal(SIGTERM, SIG_DFL) == SIG_ERR ||
	    signal(SIGCHLD, SIG_DFL) == SIG_ERR ||
	    signal(SIGHUP, SIG_DFL) == SIG_ERR)
		err(1, "signal");

	/* avoid hangs by setting 5m timeout */
	alarm(300);

	db->open(deliver);
}

static void
offline_scan(int fd, short ev, void *arg)
{
	char		*path_argv[2];
	FTS		*fts = arg;
	FTSENT		*e;
	int		 n = 0;

	path_argv[0] = PATH_SPOOL PATH_OFFLINE;
	path_argv[1] = NULL;

	if (fts == NULL) {
		log_debug("debug: smtpd: scanning offline queue...");
		fts = fts_open(path_argv, FTS_PHYSICAL | FTS_NOCHDIR, NULL);
		if (fts == NULL) {
			log_warn("fts_open: %s", path_argv[0]);
			return;
		}
	}

	while ((e = fts_read(fts)) != NULL) {
		if (e->fts_info != FTS_F)
			continue;

		/* offline files must be at depth 1 */
		if (e->fts_level != 1)
			continue;

		/* offline file group must match parent directory group */
		if (e->fts_statp->st_gid != e->fts_parent->fts_statp->st_gid)
			continue;

		if (e->fts_statp->st_size == 0) {
			if (unlink(e->fts_accpath) == -1)
				log_warnx("warn: smtpd: could not unlink %s", e->fts_accpath);
			continue;
		}

		if (offline_add(e->fts_name)) {
			log_warnx("warn: smtpd: "
			    "could not add offline message %s", e->fts_name);
			continue;
		}

		if ((n++) == OFFLINE_READMAX) {
			evtimer_set(&offline_ev, offline_scan, fts);
			offline_timeout.tv_sec = 0;
			offline_timeout.tv_usec = 100000;
			evtimer_add(&offline_ev, &offline_timeout);
			return;
		}
	}

	log_debug("debug: smtpd: offline scanning done");
	fts_close(fts);
}

static int
offline_enqueue(char *name)
{
	char		*path;
	struct stat	 sb;
	pid_t		 pid;
	struct child	*child;
	struct passwd	*pw;
	int		 pathlen;

	pathlen = asprintf(&path, "%s/%s", PATH_SPOOL PATH_OFFLINE, name);
	if (pathlen == -1) {
		log_warnx("warn: smtpd: asprintf");
		return (-1);
	}

	if (pathlen >= PATH_MAX) {
		log_warnx("warn: smtpd: pathname exceeds PATH_MAX");
		free(path);
		return (-1);
	}

	log_debug("debug: smtpd: enqueueing offline message %s", path);

	if ((pid = fork()) == -1) {
		log_warn("warn: smtpd: fork");
		free(path);
		return (-1);
	}

	if (pid == 0) {
		char	*envp[2], *p = NULL, *tmp;
		int	 fd;
		FILE	*fp;
		size_t	 sz = 0;
		ssize_t	 len;
		arglist	 args;

		if (closefrom(STDERR_FILENO + 1) == -1)
			_exit(1);

		memset(&args, 0, sizeof(args));

		if ((fd = open(path, O_RDONLY|O_NOFOLLOW|O_NONBLOCK)) == -1) {
			log_warn("warn: smtpd: open: %s", path);
			_exit(1);
		}

		if (fstat(fd, &sb) == -1) {
			log_warn("warn: smtpd: fstat: %s", path);
			_exit(1);
		}

		if (!S_ISREG(sb.st_mode)) {
			log_warnx("warn: smtpd: file %s (uid %d) not regular",
			    path, sb.st_uid);
			_exit(1);
		}

		if (sb.st_nlink != 1) {
			log_warnx("warn: smtpd: file %s is hard-link", path);
			_exit(1);
		}

		pw = getpwuid(sb.st_uid);
		if (pw == NULL) {
			log_warnx("warn: smtpd: getpwuid for uid %d failed",
			    sb.st_uid);
			_exit(1);
		}

		if (setgroups(1, &pw->pw_gid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
			_exit(1);

		if ((fp = fdopen(fd, "r")) == NULL)
			_exit(1);

		if (chdir(pw->pw_dir) == -1 && chdir("/") == -1)
			_exit(1);

		if (setsid() == -1 ||
		    signal(SIGPIPE, SIG_DFL) == SIG_ERR ||
		    dup2(fileno(fp), STDIN_FILENO) == -1)
			_exit(1);

		if ((len = getline(&p, &sz, fp)) == -1)
			_exit(1);

		if (p[len - 1] != '\n')
			_exit(1);
		p[len - 1] = '\0';

		addargs(&args, "%s", "sendmail");
		addargs(&args, "%s", "-S");

		while ((tmp = strsep(&p, "|")) != NULL)
			addargs(&args, "%s", tmp);

		free(p);
		if (lseek(fileno(fp), len, SEEK_SET) == -1)
			_exit(1);

		envp[0] = "PATH=" _PATH_DEFPATH;
		envp[1] = (char *)NULL;
		environ = envp;

		execvp(PATH_SMTPCTL, args.list);
		_exit(1);
	}

	offline_running++;
	child = child_add(pid, CHILD_ENQUEUE_OFFLINE, NULL);
	child->path = path;

	return (0);
}

static int
offline_add(char *path)
{
	struct offline	*q;

	if (offline_running < OFFLINE_QUEUEMAX)
		/* skip queue */
		return offline_enqueue(path);

	q = malloc(sizeof(*q) + strlen(path) + 1);
	if (q == NULL)
		return (-1);
	q->path = (char *)q + sizeof(*q);
	memmove(q->path, path, strlen(path) + 1);
	TAILQ_INSERT_TAIL(&offline_q, q, entry);

	return (0);
}

static void
offline_done(void)
{
	struct offline	*q;

	offline_running--;

	while (offline_running < OFFLINE_QUEUEMAX) {
		if ((q = TAILQ_FIRST(&offline_q)) == NULL)
			break; /* all done */
		TAILQ_REMOVE(&offline_q, q, entry);
		offline_enqueue(q->path);
		free(q);
	}
}

static int
parent_forward_open(char *username, char *directory, uid_t uid, gid_t gid)
{
	char		pathname[PATH_MAX];
	int		fd;
	struct stat	sb;

	if (!bsnprintf(pathname, sizeof (pathname), "%s/.forward",
		directory)) {
		log_warnx("warn: smtpd: %s: pathname too large", pathname);
		return -1;
	}

	if (stat(directory, &sb) < 0) {
		log_warn("warn: smtpd: parent_forward_open: %s", directory);
		return -1;
	}
	if (sb.st_mode & S_ISVTX) {
		log_warnx("warn: smtpd: parent_forward_open: %s is sticky",
		    directory);
		errno = EAGAIN;
		return -1;
	}

	do {
		fd = open(pathname, O_RDONLY|O_NOFOLLOW|O_NONBLOCK);
	} while (fd == -1 && errno == EINTR);
	if (fd == -1) {
		if (errno == ENOENT)
			return -1;
		if (errno == EMFILE || errno == ENFILE || errno == EIO) {
			errno = EAGAIN;
			return -1;
		}
		if (errno == ELOOP)
			log_warnx("warn: smtpd: parent_forward_open: %s: "
			    "cannot follow symbolic links", pathname);
		else
			log_warn("warn: smtpd: parent_forward_open: %s", pathname);
		return -1;
	}

	if (!secure_file(fd, pathname, directory, uid, 1)) {
		log_warnx("warn: smtpd: %s: unsecure file", pathname);
		close(fd);
		return -1;
	}

	return fd;
}

void
imsg_dispatch(struct mproc *p, struct imsg *imsg)
{
	struct timespec	t0, t1, dt;
	int		msg;

	if (imsg == NULL) {
		imsg_callback(p, imsg);
		return;
	}

	log_imsg(smtpd_process, p->proc, imsg);

	if (profiling & PROFILE_IMSG)
		clock_gettime(CLOCK_MONOTONIC, &t0);

	msg = imsg->hdr.type;
	imsg_callback(p, imsg);

	if (profiling & PROFILE_IMSG) {
		clock_gettime(CLOCK_MONOTONIC, &t1);
		timespecsub(&t1, &t0, &dt);

		log_debug("profile-imsg: %s %s %s %d %lld.%09ld",
		    proc_name(smtpd_process),
		    proc_name(p->proc),
		    imsg_to_str(msg),
		    (int)imsg->hdr.len,
		    (long long)dt.tv_sec,
		    dt.tv_nsec);

		if (profiling & PROFILE_TOSTAT) {
			char	key[STAT_KEY_SIZE];
			/* can't profstat control process yet */
			if (smtpd_process == PROC_CONTROL)
				return;

			if (!bsnprintf(key, sizeof key,
				"profiling.imsg.%s.%s.%s",
				proc_name(smtpd_process),
				proc_name(p->proc),
				imsg_to_str(msg)))
				return;
			stat_set(key, stat_timespec(&dt));
		}
	}
}

void
log_imsg(int to, int from, struct imsg *imsg)
{

	if (to == PROC_CONTROL && imsg->hdr.type == IMSG_STAT_SET)
		return;

	if (imsg->fd != -1)
		log_trace(TRACE_IMSG, "imsg: %s <- %s: %s (len=%zu, fd=%d)",
		    proc_name(to),
		    proc_name(from),
		    imsg_to_str(imsg->hdr.type),
		    imsg->hdr.len - IMSG_HEADER_SIZE,
		    imsg->fd);
	else
		log_trace(TRACE_IMSG, "imsg: %s <- %s: %s (len=%zu)",
		    proc_name(to),
		    proc_name(from),
		    imsg_to_str(imsg->hdr.type),
		    imsg->hdr.len - IMSG_HEADER_SIZE);
}

const char *
proc_title(enum smtp_proc_type proc)
{
	switch (proc) {
	case PROC_PARENT:
		return "[priv]";
	case PROC_LKA:
		return "lookup";
	case PROC_QUEUE:
		return "queue";
	case PROC_CONTROL:
		return "control";
	case PROC_SCHEDULER:
		return "scheduler";
	case PROC_PONY:
		return "pony express";
	case PROC_CA:
		return "klondike";
	default:
		return "unknown";
	}
}

const char *
proc_name(enum smtp_proc_type proc)
{
	switch (proc) {
	case PROC_PARENT:
		return "parent";
	case PROC_LKA:
		return "lka";
	case PROC_QUEUE:
		return "queue";
	case PROC_CONTROL:
		return "control";
	case PROC_SCHEDULER:
		return "scheduler";
	case PROC_PONY:
		return "pony";
	case PROC_CA:
		return "ca";
	case PROC_FILTER:
		return "filter-proc";
	case PROC_CLIENT:
		return "client-proc";
	default:
		return "unknown";
	}
}

#define CASE(x) case x : return #x

const char *
imsg_to_str(int type)
{
	static char	 buf[32];

	switch (type) {
	CASE(IMSG_NONE);

	CASE(IMSG_CTL_OK);
	CASE(IMSG_CTL_FAIL);

	CASE(IMSG_CTL_GET_DIGEST);
	CASE(IMSG_CTL_GET_STATS);
	CASE(IMSG_CTL_LIST_MESSAGES);
	CASE(IMSG_CTL_LIST_ENVELOPES);
	CASE(IMSG_CTL_MTA_SHOW_HOSTS);
	CASE(IMSG_CTL_MTA_SHOW_RELAYS);
	CASE(IMSG_CTL_MTA_SHOW_ROUTES);
	CASE(IMSG_CTL_MTA_SHOW_HOSTSTATS);
	CASE(IMSG_CTL_MTA_BLOCK);
	CASE(IMSG_CTL_MTA_UNBLOCK);
	CASE(IMSG_CTL_MTA_SHOW_BLOCK);
	CASE(IMSG_CTL_PAUSE_EVP);
	CASE(IMSG_CTL_PAUSE_MDA);
	CASE(IMSG_CTL_PAUSE_MTA);
	CASE(IMSG_CTL_PAUSE_SMTP);
	CASE(IMSG_CTL_PROFILE);
	CASE(IMSG_CTL_PROFILE_DISABLE);
	CASE(IMSG_CTL_PROFILE_ENABLE);
	CASE(IMSG_CTL_RESUME_EVP);
	CASE(IMSG_CTL_RESUME_MDA);
	CASE(IMSG_CTL_RESUME_MTA);
	CASE(IMSG_CTL_RESUME_SMTP);
	CASE(IMSG_CTL_RESUME_ROUTE);
	CASE(IMSG_CTL_REMOVE);
	CASE(IMSG_CTL_SCHEDULE);
	CASE(IMSG_CTL_SHOW_STATUS);
	CASE(IMSG_CTL_TRACE_DISABLE);
	CASE(IMSG_CTL_TRACE_ENABLE);
	CASE(IMSG_CTL_UPDATE_TABLE);
	CASE(IMSG_CTL_VERBOSE);
	CASE(IMSG_CTL_DISCOVER_EVPID);
	CASE(IMSG_CTL_DISCOVER_MSGID);
	CASE(IMSG_CTL_UNCORRUPT_MSGID);

	CASE(IMSG_CTL_SMTP_SESSION);

	CASE(IMSG_SETUP_KEY);
	CASE(IMSG_SETUP_PEER);
	CASE(IMSG_SETUP_DONE);

	CASE(IMSG_CONF_START);
	CASE(IMSG_CONF_END);

	CASE(IMSG_STAT_INCREMENT);
	CASE(IMSG_STAT_DECREMENT);
	CASE(IMSG_STAT_SET);

	CASE(IMSG_LKA_AUTHENTICATE);
	CASE(IMSG_LKA_OPEN_FORWARD);
	CASE(IMSG_LKA_ENVELOPE_SUBMIT);
	CASE(IMSG_LKA_ENVELOPE_COMMIT);

	CASE(IMSG_QUEUE_DELIVER);
	CASE(IMSG_QUEUE_DELIVERY_OK);
	CASE(IMSG_QUEUE_DELIVERY_TEMPFAIL);
	CASE(IMSG_QUEUE_DELIVERY_PERMFAIL);
	CASE(IMSG_QUEUE_DELIVERY_LOOP);
	CASE(IMSG_QUEUE_DISCOVER_EVPID);
	CASE(IMSG_QUEUE_DISCOVER_MSGID);
	CASE(IMSG_QUEUE_ENVELOPE_ACK);
	CASE(IMSG_QUEUE_ENVELOPE_COMMIT);
	CASE(IMSG_QUEUE_ENVELOPE_REMOVE);
	CASE(IMSG_QUEUE_ENVELOPE_SCHEDULE);
	CASE(IMSG_QUEUE_ENVELOPE_SUBMIT);
	CASE(IMSG_QUEUE_HOLDQ_HOLD);
	CASE(IMSG_QUEUE_HOLDQ_RELEASE);
	CASE(IMSG_QUEUE_MESSAGE_COMMIT);
	CASE(IMSG_QUEUE_MESSAGE_ROLLBACK);
	CASE(IMSG_QUEUE_SMTP_SESSION);
	CASE(IMSG_QUEUE_TRANSFER);

	CASE(IMSG_MDA_DELIVERY_OK);
	CASE(IMSG_MDA_DELIVERY_TEMPFAIL);
	CASE(IMSG_MDA_DELIVERY_PERMFAIL);
	CASE(IMSG_MDA_DELIVERY_LOOP);
	CASE(IMSG_MDA_DELIVERY_HOLD);
	CASE(IMSG_MDA_DONE);
	CASE(IMSG_MDA_FORK);
	CASE(IMSG_MDA_HOLDQ_RELEASE);
	CASE(IMSG_MDA_LOOKUP_USERINFO);
	CASE(IMSG_MDA_KILL);
	CASE(IMSG_MDA_OPEN_MESSAGE);

	CASE(IMSG_MTA_DELIVERY_OK);
	CASE(IMSG_MTA_DELIVERY_TEMPFAIL);
	CASE(IMSG_MTA_DELIVERY_PERMFAIL);
	CASE(IMSG_MTA_DELIVERY_LOOP);
	CASE(IMSG_MTA_DELIVERY_HOLD);
	CASE(IMSG_MTA_DNS_HOST);
	CASE(IMSG_MTA_DNS_HOST_END);
	CASE(IMSG_MTA_DNS_PTR);
	CASE(IMSG_MTA_DNS_MX);
	CASE(IMSG_MTA_DNS_MX_PREFERENCE);
	CASE(IMSG_MTA_HOLDQ_RELEASE);
	CASE(IMSG_MTA_LOOKUP_CREDENTIALS);
	CASE(IMSG_MTA_LOOKUP_SOURCE);
	CASE(IMSG_MTA_LOOKUP_HELO);
	CASE(IMSG_MTA_OPEN_MESSAGE);
	CASE(IMSG_MTA_SCHEDULE);
	CASE(IMSG_MTA_TLS_INIT);
	CASE(IMSG_MTA_TLS_VERIFY_CERT);
	CASE(IMSG_MTA_TLS_VERIFY_CHAIN);
	CASE(IMSG_MTA_TLS_VERIFY);

	CASE(IMSG_SCHED_ENVELOPE_BOUNCE);
	CASE(IMSG_SCHED_ENVELOPE_DELIVER);
	CASE(IMSG_SCHED_ENVELOPE_EXPIRE);
	CASE(IMSG_SCHED_ENVELOPE_INJECT);
	CASE(IMSG_SCHED_ENVELOPE_REMOVE);
	CASE(IMSG_SCHED_ENVELOPE_TRANSFER);

	CASE(IMSG_SMTP_AUTHENTICATE);
	CASE(IMSG_SMTP_DNS_PTR);
	CASE(IMSG_SMTP_MESSAGE_COMMIT);
	CASE(IMSG_SMTP_MESSAGE_CREATE);
	CASE(IMSG_SMTP_MESSAGE_ROLLBACK);
	CASE(IMSG_SMTP_MESSAGE_OPEN);
	CASE(IMSG_SMTP_CHECK_SENDER);
	CASE(IMSG_SMTP_EXPAND_RCPT);
	CASE(IMSG_SMTP_LOOKUP_HELO);
	CASE(IMSG_SMTP_TLS_INIT);
	CASE(IMSG_SMTP_TLS_VERIFY_CERT);
	CASE(IMSG_SMTP_TLS_VERIFY_CHAIN);
	CASE(IMSG_SMTP_TLS_VERIFY);

	CASE(IMSG_SMTP_REQ_CONNECT);
	CASE(IMSG_SMTP_REQ_HELO);
	CASE(IMSG_SMTP_REQ_MAIL);
	CASE(IMSG_SMTP_REQ_RCPT);
	CASE(IMSG_SMTP_REQ_DATA);
	CASE(IMSG_SMTP_REQ_EOM);
	CASE(IMSG_SMTP_EVENT_RSET);
	CASE(IMSG_SMTP_EVENT_COMMIT);
	CASE(IMSG_SMTP_EVENT_ROLLBACK);
	CASE(IMSG_SMTP_EVENT_DISCONNECT);

	CASE(IMSG_CA_PRIVENC);
	CASE(IMSG_CA_PRIVDEC);
	default:
		(void)snprintf(buf, sizeof(buf), "IMSG_??? (%d)", type);

		return buf;
	}
}

int
parent_auth_user(const char *username, const char *password)
{
	char	user[LOGIN_NAME_MAX];
	char	pass[LINE_MAX];
	int	ret;

	(void)strlcpy(user, username, sizeof(user));
	(void)strlcpy(pass, password, sizeof(pass));

	ret = auth_userokay(user, NULL, "auth-smtp", pass);
	if (ret)
		return LKA_OK;
	return LKA_PERMFAIL;
}
@


1.287
log
@add -F to usage() too;
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.286 2016/09/08 12:06:43 eric Exp $	*/
a141 1
int	verbose = 0;
a143 1
int	foreground_log = 0;
d249 1
a249 1
			log_verbose(v);
d457 1
a457 1
	verbose = 0;
d459 1
a459 1
	log_init(1);
d504 1
a504 1
				verbose |= TRACE_IMSG;
d506 1
a506 1
				verbose |= TRACE_IO;
d508 1
a508 1
				verbose |= TRACE_SMTP;
d512 1
a512 1
				verbose |= TRACE_FILTERS;
d515 1
a515 1
				verbose |= TRACE_MTA;
d518 1
a518 1
				verbose |= TRACE_BOUNCE;
d520 1
a520 1
				verbose |= TRACE_SCHEDULER;
d522 1
a522 1
				verbose |= TRACE_LOOKUP;
d525 1
a525 1
				verbose |= TRACE_STAT;
d527 1
a527 1
				verbose |= TRACE_RULES;
d529 1
a529 1
				verbose |= TRACE_MPROC;
d531 1
a531 1
				verbose |= TRACE_EXPAND;
d534 1
a534 1
				verbose |= TRACE_TABLES;
d536 1
a536 1
				verbose |= TRACE_QUEUE;
d538 1
a538 1
				verbose |= ~TRACE_DEBUG;
d558 1
a558 1
			verbose |=  TRACE_DEBUG;
d602 2
a603 3
	log_init(foreground_log);
	log_verbose(verbose);

d873 2
@


1.286
log
@Streamline the daemon shutdown sequence.

Only the parent process handles SIGTERM and SIGINT.  Upon receiving one
of those, it closes all imsg sockets and waitpid() for the children. It
fatal()s if one of the sockets is closed unexpectedly.  Other processes
exit() "normally" when one of the imsg sockets is closed.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.285 2016/09/06 16:34:29 eric Exp $	*/
d272 1
a272 1
	fprintf(stderr, "usage: %s [-dhnv] [-D macro=value] "
@


1.285
log
@use closefrom() before reexec to make sure the new process only gets
the imsg socket.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.284 2016/09/04 16:10:31 eric Exp $	*/
d63 1
a63 1
static void parent_shutdown(int);
d165 2
a166 2
		exit(1);
	
d278 1
a278 1
parent_shutdown(int ret)
d280 1
a280 3
	void		*iter;
	struct child	*child;
	pid_t		 pid;
d282 6
a287 4
	iter = NULL;
	while (tree_iter(&children, &iter, NULL, (void**)&child))
		if (child->type == CHILD_DAEMON)
			kill(child->pid, SIGTERM);
d295 2
a296 2
	log_warnx("warn: parent terminating");
	exit(ret);
d336 1
a336 1
	int		 die = 0, die_gracefully = 0, status, fail;
d343 4
a346 3
		log_info("info: %s, shutting down", strsignal(sig));
		die_gracefully = 1;
		/* FALLTHROUGH */
a382 1
				die = 1;
a436 4
		if (die)
			parent_shutdown(1);
		else if (die_gracefully)
			parent_shutdown(0);
d1596 1
a1596 1
		exit(1);
@


1.284
log
@The smtpd processes are not expected to ever leave their event loop.
So stop pretending that the *_shutdown() functions could ever be called
in this context, and just fatal() if event_dispatch() returns.

ok gilles@@ sunil@@ giovanni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.283 2016/09/04 09:33:49 eric Exp $	*/
a812 2
	close(sp[1]);

d815 3
@


1.283
log
@Remove the "smtpctl stop" command.
The daemon is stopped with kill(1).

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.282 2016/09/01 10:54:25 eric Exp $	*/
d1053 2
a1054 2
	if (event_dispatch() < 0)
		fatal("smtpd: event_dispatch");
@


1.282
log
@remove noop function

ok sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.281 2016/09/01 10:07:20 eric Exp $	*/
a259 4

		case IMSG_CTL_SHUTDOWN:
			parent_shutdown(0);
			return;
a1750 1
	CASE(IMSG_CTL_SHUTDOWN);
@


1.281
log
@get rid of the imsg buffer usage profiling code.

ok gilles@@ jung@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.280 2016/08/19 15:35:08 eric Exp $	*/
a1039 1
	config_done();
@


1.280
log
@make smtpd less verbose at startup

ok gilles@@ sunil@@ jung@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.279 2016/06/20 20:26:04 gilles Exp $	*/
a554 2
			else if (!strcmp(optarg, "profile-buffers"))
				profiling |= PROFILE_BUFFERS;
@


1.279
log
@with new fork+reexec, in case of failure in init of any child process
causing it to exit, we could end up with a NULL deref in parent.

free commit offered by eric@@, ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.278 2016/06/07 06:52:49 gilles Exp $	*/
d712 1
a712 1
		log_info("smtpd: setup done");
d874 1
a874 1
	log_info("setup_done: %s[%d] done", p->name, p->pid);
d923 1
a923 1
	log_info("setup_proc: %s done", proc_title(smtpd_process));
d931 1
a931 1
	log_info("setup_peer: %s -> %s[%u] fd=%d", proc_title(smtpd_process),
@


1.278
log
@use io_set_nonblocking() instead of SOCK_NONBLOCKING to reduce delta with
-portable
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.277 2016/05/28 21:21:20 eric Exp $	*/
d164 3
@


1.277
log
@Implement the fork+exec pattern in smtpd.

The parent process forks child processes and re-exec each of them with
an additional "-x <proc>" argument.  During the early setup phase, the
parent process sends ipc socket pairs to interconnect the child
processes as needed, and it passes the queue encryption key to the
queue if necessary. When this is done, all processes have their
environment set as in the fork-only case, and they can start doing
their work as before.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.276 2016/04/21 14:27:41 jsing Exp $	*/
d792 1
a792 1
	if (socketpair(AF_UNIX, SOCK_STREAM|SOCK_NONBLOCK, PF_UNSPEC, sp) == -1)
d795 3
d836 1
a836 1
	if (socketpair(AF_UNIX, SOCK_STREAM|SOCK_NONBLOCK, PF_UNSPEC, sp) == -1)
d838 3
@


1.276
log
@Use automatic DH parameters, instead of fixed ones. Also disable DHE by
default since it is computationally expensive and a potential DoS vector.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.275 2016/03/17 19:40:43 krw Exp $	*/
d41 1
d58 2
d62 1
a70 1
static void fork_peers(void);
d72 7
d454 4
a457 6
	struct smtpd	 smtpd;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct event	 ev_sigchld;
	struct event	 ev_sighup;
	struct timeval	 tv;
d459 1
a459 1
	env = &smtpd;
d470 1
a470 1
	while ((c = getopt(argc, argv, "B:dD:hnP:f:FT:v")) != -1) {
d569 3
d585 1
a585 1
	if (parse_config(&smtpd, conffile, opts))
d611 13
a623 2
	/* the control socket ensures that only one smtpd instance is running */
	control_socket = control_create_socket();
d625 2
a626 2
	if (!queue_init(backend_queue, 1))
		errx(1, "could not initialize queue backend");
d628 12
a639 28
	env->sc_stat = stat_backend_lookup(backend_stat);
	if (env->sc_stat == NULL)
		errx(1, "could not find stat backend \"%s\"", backend_stat);

	if (env->sc_queue_flags & QUEUE_ENCRYPTION) {
		if (env->sc_queue_key == NULL) {
			char	*password;

			password = getpass("queue key: ");
			if (password == NULL)
				err(1, "getpass");

			env->sc_queue_key = strdup(password);
			explicit_bzero(password, strlen(password));
			if (env->sc_queue_key == NULL)
				err(1, "strdup");
		}
		else {
			char   *buf = NULL;
			size_t	sz = 0;
			ssize_t	len;

			if (strcasecmp(env->sc_queue_key, "stdin") == 0) {
				if ((len = getline(&buf, &sz, stdin)) == -1)
					err(1, "getline");
				if (buf[len - 1] == '\n')
					buf[len - 1] = '\0';
				env->sc_queue_key = buf;
d641 59
d701 32
d735 6
a740 2
	if (env->sc_queue_flags & QUEUE_COMPRESSION)
		env->sc_comp = compress_backend_lookup("gzip");
d742 116
a857 2
	log_init(foreground_log);
	log_verbose(verbose);
d859 2
a860 2
	load_pki_tree();
	load_pki_keys();
d862 2
a863 1
	log_info("info: %s %s starting", SMTPD_NAME, SMTPD_VERSION);
d865 1
a865 3
	if (!foreground)
		if (daemon(0, 0) == -1)
			err(1, "failed to daemonize");
d867 34
a900 2
	for (i = 0; i < MAX_BOUNCE_WARN; i++) {
		if (env->sc_bounce_warn[i] == 0)
d902 4
a905 2
		log_debug("debug: bounce warning after %s",
		    duration_to_text(env->sc_bounce_warn[i]));
d908 83
a990 3
	log_debug("debug: using \"%s\" queue backend", backend_queue);
	log_debug("debug: using \"%s\" scheduler backend", backend_scheduler);
	log_debug("debug: using \"%s\" stat backend", backend_stat);
d992 4
a995 3
	if (env->sc_hostname[0] == '\0')
		errx(1, "machine does not have a hostname set");
	env->sc_uptime = time(NULL);
d997 7
a1003 1
	fork_peers();
d1006 10
a1103 31
static void
fork_peers(void)
{
	tree_init(&children);

	init_pipes();

	child_add(queue(), CHILD_DAEMON, proc_title(PROC_QUEUE));
	child_add(control(), CHILD_DAEMON, proc_title(PROC_CONTROL));
	child_add(lka(), CHILD_DAEMON, proc_title(PROC_LKA));
	child_add(scheduler(), CHILD_DAEMON, proc_title(PROC_SCHEDULER));
	child_add(pony(), CHILD_DAEMON, proc_title(PROC_PONY));
	child_add(ca(), CHILD_DAEMON, proc_title(PROC_CA));
	post_fork(PROC_PARENT);
}

void
post_fork(int proc)
{
	if (proc != PROC_QUEUE && env->sc_queue_key) {
		explicit_bzero(env->sc_queue_key, strlen(env->sc_queue_key));
		if (strcasecmp(env->sc_queue_key, "stdin") != 0)
			free(env->sc_queue_key);
	}

	if (proc != PROC_CONTROL) {
		close(control_socket);
		control_socket = -1;
	}
}

d1759 4
@


1.275
log
@Last parameter to execl[e]() functions *must* be cast to a pointer.
Just NULL is not good practise as NULL is theoretically allowed to
be an integer rather than a pointer.

Use (char *)NULL consistently instead of scattering a few (char *)0
and (void *)NULL into the mix.

Prompted by and probably ok deraadt@@ millert@@ kettenis@@

Definitely ok mestre@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.274 2016/02/05 19:15:15 jung Exp $	*/
a730 4

		if (pki->pki_dhparams_file)
			if (!ssl_load_dhparams(pki, pki->pki_dhparams_file))
				fatalx("load_pki_tree: failed to load dhparams file");
@


1.274
log
@use SMTPD_NAME define

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.273 2016/02/02 17:51:11 sthen Exp $	*/
d839 1
a839 1
		execl(path, procname, arg, NULL);
@


1.273
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.272 2016/01/27 12:46:03 sunil Exp $	*/
d487 1
a487 1
			log_info("version: OpenSMTPD " SMTPD_VERSION);
@


1.272
log
@Check imsg data length before use.

Ok jung@@ gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.271 2016/01/18 11:29:34 sunil Exp $	*/
a668 2

	config_process(PROC_PARENT);
@


1.271
log
@Load pki keys before daemon(3). Keys with passphrase require access
to stdin.

Ok millert@@ jung@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.270 2016/01/04 13:30:20 jung Exp $	*/
d157 1
@


1.270
log
@switch to /usr/local/libexec when looking for -extras and drop loop iterating
paths

this effectively reverts table.c r1.21 which was mainly introduced for a smooth
transition in -current

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.269 2015/12/28 22:08:30 jung Exp $	*/
d644 1
a791 4
	}

	if (proc == PROC_CA) {
		load_pki_keys();
@


1.269
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.268 2015/12/20 14:06:24 gilles Exp $	*/
d816 1
a816 1
	if (snprintf(path, sizeof(path), PATH_LIBEXEC_DEPRECATED "/%s-%s", key, name) >=
@


1.268
log
@remove redundant log
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.267 2015/12/14 10:22:12 jung Exp $	*/
d647 1
a647 1
	if (! foreground)
d729 1
a729 1
		if (! ssl_load_certificate(pki, pki->pki_cert_file))
d733 1
a733 1
			if (! ssl_load_dhparams(pki, pki->pki_dhparams_file))
d741 1
a741 1
		if (! ssl_load_cafile(sca, sca->ca_cert_file))
d758 1
a758 1
		if (! ssl_load_keyfile(pki, pki->pki_key_file, k))
d936 1
a936 1
	if (deliver->userinfo.uid == 0 && ! db->allow_root) {
d1132 1
a1132 1
		if (! S_ISREG(sb.st_mode)) {
d1240 1
a1240 1
	if (! bsnprintf(pathname, sizeof (pathname), "%s/.forward",
d1275 1
a1275 1
	if (! secure_file(fd, pathname, directory, uid, 1)) {
d1321 1
a1321 1
			if (! bsnprintf(key, sizeof key,
@


1.267
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.266 2015/12/12 20:02:31 gilles Exp $	*/
a660 1
	log_info("info: startup%s", (verbose & TRACE_DEBUG)?" [debug mode]":"");
@


1.266
log
@remove CA from pki and no longer allow specifying a CA with 'pki' keyword.
introduce 'ca' keyword to allow specifying a custom CA.
making CA part of pki was a bad idea and several people hit use-cases that
plain couldn't work.

instead of:
    pki foobar.org ca "/etc/mail/CA.pem"

use now:
    ca foobar.org certificate "/etc/mail/CA.pem"


ok sunil@@, jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.265 2015/12/12 11:31:29 sunil Exp $	*/
d499 1
a499 1
			
@


1.265
log
@Implement senders map.

senders table allows to restrict the addresses that an authenticated
user can use in the SMTP dialogue.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.264 2015/12/12 10:48:43 gilles Exp $	*/
a732 3
		if (pki->pki_ca_file)
			if (! ssl_load_cafile(pki, pki->pki_ca_file))
				fatalx("load_pki_tree: failed to load CA file");
d742 2
a743 4
		/*
		 * if (! ssl_load_cafile(sca, sca->ca_cert_file))
		 *	fatalx("load_pki_tree: failed to load CA file");
		 */
@


1.264
log
@prepare load_pki_tree() for pki/ca split
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.263 2015/12/12 10:26:57 sunil Exp $	*/
d1537 1
@


1.263
log
@In the configuration test mode (smtpd -n) setup queue crypto iff a
valid queue key is specified.

Ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.262 2015/12/11 07:44:59 sunil Exp $	*/
d717 1
d739 10
@


1.262
log
@New '-F' option to let smtpd run in foreground while logging to
syslog.

Ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.261 2015/12/10 14:07:04 sunil Exp $	*/
d581 6
@


1.261
log
@free sc_queue_key only when it points to something other than "stdin"
string literal.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.260 2015/12/10 09:33:50 sunil Exp $	*/
d135 1
d461 1
a461 1
	while ((c = getopt(argc, argv, "B:dD:hnP:f:T:v")) != -1) {
d477 1
d496 4
d634 1
a634 1
	log_init(foreground);
@


1.260
log
@Do not fatal when a log_warn suffices.

Ok jung@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.259 2015/12/08 17:28:03 sunil Exp $	*/
d767 2
a768 1
		free(env->sc_queue_key);
d869 1
a869 1
	
d1042 1
a1042 1
		
@


1.259
log
@Let smtpd shutdown gracefully with a zero exit code when the priv
process receives a SIGINT/SIGTERM.

Initial diff by nfnty <git@@nfnty.se>

Ok gilles@@ jung@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.258 2015/12/05 21:27:42 mmcc Exp $	*/
d1223 4
a1226 2
		directory))
		fatal("smtpd: parent_forward_open: snprintf");
@


1.258
log
@Remove a few NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.257 2015/12/01 20:04:38 gilles Exp $	*/
d325 1
a325 1
	int		 die = 0, status, fail;
d332 2
a333 1
		die = 1;
d428 2
@


1.257
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.256 2015/11/30 14:13:03 gilles Exp $	*/
d393 1
a393 2
				if (child->cause)
					free(child->cause);
@


1.256
log
@when looking up tables, start in /usr/local/libexec before /usr/libexec, so
ports/packages can be installed in the proper place

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.255 2015/11/30 12:49:35 gilles Exp $	*/
d692 1
a692 1
	
@


1.255
log
@mechanical rename of some IMSG constants

ok sunil@@, ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.254 2015/11/05 09:14:31 sunil Exp $	*/
d796 1
a796 1
	if (snprintf(path, sizeof(path), PATH_LIBEXEC "/%s-%s", key, name) >=
@


1.254
log
@Implement smtpctl uncorrupt <msgid>

"uncorrupt" moves envelopes from corrupt bucket back to the queue
for further discovery by the daemon.

After correcting the corrupt envelopes, admin could now...

# smtpctl uncorrupt msgid
# smtpctl discover msgid

to schedule the messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.253 2015/10/29 10:25:36 sunil Exp $	*/
d1491 4
a1494 4
	CASE(IMSG_MTA_SSL_INIT);
	CASE(IMSG_MTA_SSL_VERIFY_CERT);
	CASE(IMSG_MTA_SSL_VERIFY_CHAIN);
	CASE(IMSG_MTA_SSL_VERIFY);
d1511 4
a1514 4
	CASE(IMSG_SMTP_SSL_INIT);
	CASE(IMSG_SMTP_SSL_VERIFY_CERT);
	CASE(IMSG_SMTP_SSL_VERIFY_CHAIN);
	CASE(IMSG_SMTP_SSL_VERIFY);
@


1.253
log
@Implement smtpctl discover <evpid|msgid>.

discover subcommand schedules envelopes manually moved to the queue.
It triggers a queue walk searching for envelopes with the given id,
schedules them and informs the user number of envelopes scheduled.
Admins no longer would need to restart the daemon to discover
manually moved messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.252 2015/10/26 09:56:01 jung Exp $	*/
d1428 1
@


1.252
log
@remove unneeded pidfile() from smtpd

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.251 2015/10/22 08:46:31 gilles Exp $	*/
d1426 2
d1448 2
@


1.251
log
@delivery to maildir needs pledge fattr

from Gregor Best <gbe@@unobtanium.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.250 2015/10/17 16:03:20 sunil Exp $	*/
a48 1
#include <util.h>
a685 3

	if (pidfile(NULL) < 0)
		err(1, "pidfile");
@


1.250
log
@LMTP delivery requires "inet unix".

Ok millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.249 2015/10/17 04:36:10 deraadt Exp $	*/
d693 1
a693 1
	if (pledge("stdio rpath wpath cpath flock tmppath "
@


1.249
log
@smtpd starts rather robustly with a gigantic pledge request group (keep
in mind that a gigantic group is already < ~50% of POSIX).  It then
grinds these down bit by bit as it sets up privsep for the various
processes.  At startup, smtpd will need the new "id" request as well.
ok gilles tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.248 2015/10/16 20:54:55 gilles Exp $	*/
d693 2
a694 2
	if (pledge("stdio rpath wpath cpath flock tmppath getpw sendfd proc exec id",
	    NULL) == -1)
@


1.248
log
@add flock to pledge request, needed by delivery_filename

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.247 2015/10/14 19:56:58 gilles Exp $	*/
d693 2
a694 1
	if (pledge("stdio rpath wpath cpath flock tmppath getpw sendfd proc exec", NULL) == -1)
@


1.247
log
@pledge() privileged process

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.246 2015/10/14 09:14:11 sunil Exp $	*/
d693 1
a693 1
	if (pledge("stdio rpath wpath cpath tmppath getpw sendfd proc exec", NULL) == -1)
@


1.246
log
@Convert fgetln to getline.

Ok millert@@ eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.245 2015/10/13 07:18:53 gilles Exp $	*/
d693 3
@


1.245
log
@offline queue is no longer user-writable, do not attempt resetting fchflags
it serves no purpose.

ok millert@@, ok jung@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.244 2015/10/12 07:58:19 deraadt Exp $	*/
d610 3
a612 3
			char   *buf;
			char   *lbuf;
			size_t	len;
d615 5
a619 15
				lbuf = NULL;
				buf = fgetln(stdin, &len);
				if (buf[len - 1] == '\n') {
					lbuf = calloc(len, 1);
					if (lbuf == NULL)
						err(1, "calloc");
					memcpy(lbuf, buf, len-1);
				}
				else {
					lbuf = calloc(len+1, 1);
					if (lbuf == NULL)
						err(1, "calloc");
					memcpy(lbuf, buf, len);
				}
				env->sc_queue_key = lbuf;
d763 1
a763 1
	if (proc != PROC_QUEUE && env->sc_queue_key)
d765 2
d1090 1
a1090 1
		char	*envp[2], *p, *tmp;
d1093 2
a1094 1
		size_t	 len;
d1146 1
a1146 1
		if ((p = fgetln(fp, &len)) == NULL)
d1159 1
@


1.244
log
@do not umask() [with the wrong umask] around mkstemp() calls, no matter
how broken other systems are.
ok guenther gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.243 2015/10/09 17:44:25 gilles Exp $	*/
a1133 5
			_exit(1);
		}

		if (fchflags(fd, 0) == -1) {
			log_warn("warn: smtpd: chflags: %s", path);
@


1.243
log
@upon smtpd restart, when scanning the offline queue, unlink 0-sized offline
messages as they are left-overs from an errored enqueue.

ok millert@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.242 2015/10/06 08:51:35 gilles Exp $	*/
a909 1
	mode_t		 omode;
a944 1
	omode = umask(07077);
a945 1
	umask(omode);
@


1.242
log
@we don't need this temporary buffer since we're going to strdup() it right
away anyways

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.241 2015/10/06 06:04:46 gilles Exp $	*/
d36 1
d1016 3
a1018 2
	DIR		*dir = arg;
	struct dirent	*d;
d1021 4
a1024 1
	if (dir == NULL) {
d1026 5
a1030 2
		if ((dir = opendir(PATH_SPOOL PATH_OFFLINE)) == NULL)
			errx(1, "smtpd: opendir");
d1033 6
a1038 2
	while ((d = readdir(dir)) != NULL) {
		if (d->d_type != DT_REG)
d1041 11
a1051 1
		if (offline_add(d->d_name)) {
d1053 1
a1053 1
			    "could not add offline message %s", d->d_name);
d1058 1
a1058 1
			evtimer_set(&offline_ev, offline_scan, dir);
d1067 1
a1067 1
	closedir(dir);
@


1.241
log
@fix values passed to umask(), they should be octal.
the permissions are even more restrictive than they should.

misc bug reported by qualys
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.240 2015/10/02 00:37:53 gilles Exp $	*/
d1051 1
a1051 1
	char		 t[PATH_MAX], *path;
d1056 1
d1058 3
a1060 2
	if (!bsnprintf(t, sizeof t, "%s/%s", PATH_SPOOL PATH_OFFLINE, name)) {
		log_warnx("warn: smtpd: path name too long");
d1064 3
a1066 2
	if ((path = strdup(t)) == NULL) {
		log_warn("warn: smtpd: strdup");
@


1.240
log
@prevent users from playing hardlink/symlink/mkfifo games with their offline
messages and ~/.forward files. this allowed a local user to hang smtpd or
even reset chflags and read first line of any arbitrary file.

while at it, do not fatal() on unexpected cause of SIGCHLD as this allows a
specially crafted mda to cause smtpd to exit.

reporte by Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.239 2015/06/03 02:24:36 millert Exp $	*/
d945 1
a945 1
	omode = umask(7077);
@


1.239
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.238 2015/01/20 17:37:54 deraadt Exp $	*/
d355 2
a356 1
				fatalx("smtpd: unexpected cause of SIGCHLD");
d1077 1
d1082 3
d1087 2
a1088 2
		if (lstat(path, &sb) == -1) {
			log_warn("warn: smtpd: lstat: %s", path);
d1092 13
a1104 2
		if (chflags(path, 0) == -1) {
			log_warn("warn: smtpd: chflags: %s", path);
d1115 2
a1116 3
		if (! S_ISREG(sb.st_mode)) {
			log_warnx("warn: smtpd: file %s (uid %d) not regular",
			    path, sb.st_uid);
d1122 1
a1122 2
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) ||
		    closefrom(STDERR_FILENO + 1) == -1)
d1125 1
a1125 1
		if ((fp = fopen(path, "r")) == NULL)
d1225 1
a1225 1
		fd = open(pathname, O_RDONLY);
d1234 5
a1238 1
		log_warn("warn: smtpd: parent_forward_open: %s", pathname);
@


1.239.4.1
log
@Errata 004:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.239 2015/06/03 02:24:36 millert Exp $	*/
d355 1
a355 2
				/* WIFSTOPPED or WIFCONTINUED */
				continue;
a1075 1
		int	 fd;
a1079 3
		if (closefrom(STDERR_FILENO + 1) == -1)
			_exit(1);

d1082 2
a1083 2
		if ((fd = open(path, O_RDONLY|O_NOFOLLOW|O_NONBLOCK)) == -1) {
			log_warn("warn: smtpd: open: %s", path);
d1087 2
a1088 13
		if (fstat(fd, &sb) == -1) {
			log_warn("warn: smtpd: fstat: %s", path);
			_exit(1);
		}

		if (! S_ISREG(sb.st_mode)) {
			log_warnx("warn: smtpd: file %s (uid %d) not regular",
			    path, sb.st_uid);
			_exit(1);
		}

		if (sb.st_nlink != 1) {
			log_warnx("warn: smtpd: file %s is hard-link", path);
d1099 3
a1101 2
		if (fchflags(fd, 0) == -1) {
			log_warn("warn: smtpd: chflags: %s", path);
d1107 2
a1108 1
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
d1111 1
a1111 1
		if ((fp = fdopen(fd, "r")) == NULL)
d1211 1
a1211 1
		fd = open(pathname, O_RDONLY|O_NOFOLLOW|O_NONBLOCK);
d1220 1
a1220 5
		if (errno == ELOOP)
			log_warnx("warn: smtpd: parent_forward_open: %s: "
			    "cannot follow symbolic links", pathname);
		else
			log_warn("warn: smtpd: parent_forward_open: %s", pathname);
@


1.238
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.237 2015/01/16 06:40:21 deraadt Exp $	*/
d336 2
d345 1
a345 1
				asprintf(&cause, "terminated; signal %d",
d350 2
a351 1
					asprintf(&cause, "exited abnormally");
d353 1
a353 1
					asprintf(&cause, "exited okay");
d357 3
d378 6
a383 2
					free(cause);
					asprintf(&cause, "terminated; timeout");
@


1.238.2.1
log
@Errata 017:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.238 2015/01/20 17:37:54 deraadt Exp $	*/
d352 1
a352 2
				/* WIFSTOPPED or WIFCONTINUED */
				continue;
a1065 1
		int	 fd;
a1069 3
		if (closefrom(STDERR_FILENO + 1) == -1)
			_exit(1);

d1072 2
a1073 2
		if ((fd = open(path, O_RDONLY|O_NOFOLLOW|O_NONBLOCK)) == -1) {
			log_warn("warn: smtpd: open: %s", path);
d1077 2
a1078 13
		if (fstat(fd, &sb) == -1) {
			log_warn("warn: smtpd: fstat: %s", path);
			_exit(1);
		}

		if (! S_ISREG(sb.st_mode)) {
			log_warnx("warn: smtpd: file %s (uid %d) not regular",
			    path, sb.st_uid);
			_exit(1);
		}

		if (sb.st_nlink != 1) {
			log_warnx("warn: smtpd: file %s is hard-link", path);
d1089 3
a1091 2
		if (fchflags(fd, 0) == -1) {
			log_warn("warn: smtpd: chflags: %s", path);
d1097 2
a1098 1
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
d1101 1
a1101 1
		if ((fp = fdopen(fd, "r")) == NULL)
d1201 1
a1201 1
		fd = open(pathname, O_RDONLY|O_NOFOLLOW|O_NONBLOCK);
d1210 1
a1210 5
		if (errno == ELOOP)
			log_warnx("warn: smtpd: parent_forward_open: %s: "
			    "cannot follow symbolic links", pathname);
		else
			log_warn("warn: smtpd: parent_forward_open: %s", pathname);
@


1.237
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.236 2015/01/15 09:05:37 gilles Exp $	*/
d557 3
a559 3
	if (strlcpy(env->sc_conffile, conffile, SMTPD_MAXPATHLEN)
	    >= SMTPD_MAXPATHLEN)
		errx(1, "config file exceeds SMTPD_MAXPATHLEN");
d779 2
a780 2
	char		path[SMTPD_MAXPATHLEN];
	char		name[SMTPD_MAXPATHLEN];
d1040 1
a1040 1
	char		 t[SMTPD_MAXPATHLEN], *path;
d1181 1
a1181 1
	char		pathname[SMTPD_MAXPATHLEN];
d1495 2
a1496 2
	char	user[SMTPD_MAXLOGNAME];
	char	pass[SMTPD_MAXLINESIZE];
@


1.236
log
@when enqueueing offline mails from within the daemon session, we should not
rely on getlogin() otherwise mail will end up enqueued as coming from user
who started smtpd.

bug spotted by deraadt@@, diff ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.235 2014/08/25 07:50:26 doug Exp $	*/
d43 1
@


1.235
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.234 2014/07/10 15:54:55 eric Exp $	*/
d1119 1
@


1.234
log
@make the control process broadcast verbose/profile admin requests directly,
rather than going through the parent process. simplify code in the meantime.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.221 2014/04/19 14:00:45 gilles Exp $	*/
d592 1
a592 1
			memset(password, 0, strlen(password));
@


1.234.4.1
log
@Errata 031:
fix multiple security and reliability issues found during an audit by
Qualys Security
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.234 2014/07/10 15:54:55 eric Exp $	*/
d351 1
a351 2
				/* WIFSTOPPED or WIFCONTINUED */
				continue;
a1064 1
		int	 fd;
a1068 3
		if (closefrom(STDERR_FILENO + 1) == -1)
			_exit(1);

d1071 2
a1072 2
		if ((fd = open(path, O_RDONLY|O_NOFOLLOW|O_NONBLOCK)) == -1) {
			log_warn("warn: smtpd: open: %s", path);
d1076 2
a1077 13
		if (fstat(fd, &sb) == -1) {
			log_warn("warn: smtpd: fstat: %s", path);
			_exit(1);
		}

		if (! S_ISREG(sb.st_mode)) {
			log_warnx("warn: smtpd: file %s (uid %d) not regular",
			    path, sb.st_uid);
			_exit(1);
		}

		if (sb.st_nlink != 1) {
			log_warnx("warn: smtpd: file %s is hard-link", path);
d1088 3
a1090 2
		if (fchflags(fd, 0) == -1) {
			log_warn("warn: smtpd: chflags: %s", path);
d1096 2
a1097 1
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
d1100 1
a1100 1
		if ((fp = fdopen(fd, "r")) == NULL)
d1199 1
a1199 1
		fd = open(pathname, O_RDONLY|O_NOFOLLOW|O_NONBLOCK);
d1208 1
a1208 5
		if (errno == ELOOP)
			log_warnx("warn: smtpd: parent_forward_open: %s: "
			    "cannot follow symbolic links", pathname);
		else
			log_warn("warn: smtpd: parent_forward_open: %s", pathname);
@


1.233
log
@Improve the scheduler, better and simpler.

- Get rid of the scheduler_batch structure. The scheduler can now return
  envelopes of different types in a single run, interlacing them to avoid
  batch effects.

- Ask for an acknowledgement from the queue when removing or expiring
  an envelope to benefit from the inflight envelope limitation mechanism.
  This ensures that the scheduler always keeps sending envelopes at a rate
  that the queue can sustain in all cases.

- Limit the number of envelopes in a holdq.  When a holdq is full,
  new envelopes are put back in the pending queue instead, with a
  shorter retry time.

- Plumbing for proc-ified schedulers.

imsg version bump. smtpctl stop before updating.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.232 2014/07/09 09:53:37 eric Exp $	*/
a65 2
static void parent_broadcast_verbose(uint32_t);
static void parent_broadcast_profile(uint32_t);
a235 4
			m_forward(p_lka, imsg);
			m_forward(p_queue, imsg);
			m_forward(p_pony, imsg);
			m_forward(p_ca, imsg);
d238 1
a238 1
		case IMSG_CTL_TRACE_ENABLE:
d242 1
a242 28
			verbose |= v;
			log_verbose(verbose);
			parent_broadcast_verbose(verbose);
			return;

		case IMSG_CTL_TRACE_DISABLE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			verbose &= ~v;
			log_verbose(verbose);
			parent_broadcast_verbose(verbose);
			return;

		case IMSG_CTL_PROFILE_ENABLE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			profiling |= v;
			parent_broadcast_profile(profiling);
			return;

		case IMSG_CTL_PROFILE_DISABLE:
			m_msg(&m, imsg);
			m_get_int(&m, &v);
			m_end(&m);
			profiling &= ~v;
			parent_broadcast_profile(profiling);
a1503 40
}

static void
parent_broadcast_verbose(uint32_t v)
{
	m_create(p_lka, IMSG_CTL_VERBOSE, 0, 0, -1);
	m_add_int(p_lka, v);
	m_close(p_lka);
	
	m_create(p_pony, IMSG_CTL_VERBOSE, 0, 0, -1);
	m_add_int(p_pony, v);
	m_close(p_pony);
	
	m_create(p_queue, IMSG_CTL_VERBOSE, 0, 0, -1);
	m_add_int(p_queue, v);
	m_close(p_queue);

	m_create(p_ca, IMSG_CTL_VERBOSE, 0, 0, -1);
	m_add_int(p_ca, v);
	m_close(p_ca);
}

static void
parent_broadcast_profile(uint32_t v)
{
	m_create(p_lka, IMSG_CTL_PROFILE, 0, 0, -1);
	m_add_int(p_lka, v);
	m_close(p_lka);
	
	m_create(p_pony, IMSG_CTL_PROFILE, 0, 0, -1);
	m_add_int(p_pony, v);
	m_close(p_pony);
	
	m_create(p_queue, IMSG_CTL_PROFILE, 0, 0, -1);
	m_add_int(p_queue, v);
	m_close(p_queue);

	m_create(p_ca, IMSG_CTL_PROFILE, 0, 0, -1);
	m_add_int(p_ca, v);
	m_close(p_ca);
@


1.232
log
@config parser improvements:

- fail if the same option is specified multiple times on a listener
- prompt for queue encryption key after config parsing, not during.
- add ip addresses to localnames table
- prepare for filters
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.231 2014/07/08 21:55:53 eric Exp $	*/
d1438 1
@


1.231
log
@send correct imsg when enabling profiling at runtime
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.230 2014/07/08 21:25:14 eric Exp $	*/
d615 38
@


1.230
log
@partially revert bogus commit
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.229 2014/07/08 20:14:46 eric Exp $	*/
d1535 1
a1535 1
	m_create(p_ca, IMSG_CTL_VERBOSE, 0, 0, -1);
@


1.229
log
@get rid of mfa leftovers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.228 2014/07/08 13:49:09 eric Exp $	*/
d524 1
a524 1
			else if (!strcmp(optarg, "filters") ||
@


1.228
log
@Update the table API: lookup functions can take an optional parameters
dictionnary (currently not set). While there, add a helper for forking
external backends, and remove unused table functions.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.227 2014/07/07 09:11:24 eric Exp $	*/
d523 2
a524 2
				verbose |= TRACE_MFA;
			else if (!strcmp(optarg, "mta") ||
a1421 2

	CASE(IMSG_MFA_SMTP_RESPONSE);
@


1.227
log
@Allow to enable profiling at runtime and fix timings output.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.226 2014/05/01 15:50:20 reyk Exp $	*/
d766 55
@


1.226
log
@Move RSA keys from "lka" to a new dedicated "ca" process because lka
is handling some async requests and shouldn't be busy with sync RSA.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.225 2014/04/30 08:23:42 reyk Exp $	*/
d1184 1
a1184 1
		log_debug("profile-imsg: %s %s %s %d %lld.%06ld",
d1189 2
a1190 2
		    (long long)dt.tv_sec * 1000000 + dt.tv_nsec / 1000000,
		    dt.tv_nsec % 1000000);
@


1.225
log
@The RSA engine (used by pony) has to wait for a response from the
privileged process (lka) and receive the imsgs in a while loop
synchronously.  But the lka also sends other imsgs (DNS etc.) that can
still be queued up in the buffer when waiting for the RSA response.
This only happens under load with many concurrent connections.  For
now, we just call the pony imsg handler for non-RSA imsgs that are
already in the buffer.

ok gilles@@ eric@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.224 2014/04/29 21:04:17 reyk Exp $	*/
d62 1
d126 1
d241 1
d284 2
a285 1
	errx(1, "parent_imsg: unexpected %s imsg", imsg_to_str(imsg->hdr.type));
d325 1
d346 8
d666 1
d748 1
d763 1
a763 1
	if (proc == PROC_LKA) {
d1247 2
d1270 2
d1461 4
d1481 4
@


1.224
log
@For RSA private key privsep, only ever load the keys after forking the
separated process.  This improves the previous because we don't trust
the PEM and BIO routines to cleanup the keys correctly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.223 2014/04/29 19:13:13 reyk Exp $	*/
a75 1
static void	log_imsg(int, int, struct imsg *);
d1194 1
a1194 1
static void
@


1.223
log
@Implement RSA privilege separation for OpenSMTPD, based on my previous
implementation for relayd(8).  The smtpd(8) pony processes (mta
client, smtp server) don't keep the private keys in memory but send
their private key operations as imsgs to the "lookup"/mta process.
It's worth mentioning that this prevents acidental private key leakage
as it could have been caused by "Heartbleed".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.222 2014/04/29 10:18:06 reyk Exp $	*/
d79 1
d583 1
a695 2
		if (! ssl_load_keyfile(pki, pki->pki_key_file, k))
			fatalx("load_pki_tree: failed to load key file");
d706 17
d747 4
@


1.222
log
@use explicit_bzero() instead of memset() to clear out sensitive data.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.221 2014/04/19 14:00:45 gilles Exp $	*/
d50 1
d1382 3
@


1.221
log
@(void) cast snprintf calls that cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.220 2014/04/09 19:12:45 eric Exp $	*/
d724 1
a724 1
		memset(env->sc_queue_key, 0, strlen(env->sc_queue_key));
@


1.220
log
@display correct imsg when profiling is on and if the type was changed
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.219 2014/04/09 18:55:19 eric Exp $	*/
d808 1
a808 1
		snprintf(ebuf, sizeof ebuf, "could not find delivery backend");
d817 1
a817 1
		snprintf(ebuf, sizeof ebuf, "not allowed to deliver to: %s",
d827 1
a827 1
		snprintf(ebuf, sizeof ebuf, "pipe: %s", strerror(errno));
d836 1
a836 1
	strlcpy(sfn, "/tmp/smtpd.out.XXXXXXXXXXX", sizeof(sfn));
d841 1
a841 1
		snprintf(ebuf, sizeof ebuf, "mkstemp: %s", strerror(errno));
d854 1
a854 1
		snprintf(ebuf, sizeof ebuf, "fork: %s", strerror(errno));
d1382 1
a1382 1
		snprintf(buf, sizeof(buf), "IMSG_??? (%d)", type);
d1395 2
a1396 2
	strlcpy(user, username, sizeof(user));
	strlcpy(pass, password, sizeof(pass));
@


1.219
log
@Zap the mfa process. It is not currently doing anything, and content filtering
will be done at session level anyway.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1128 2
a1129 1
	struct timespec		 t0, t1, dt;
d1141 1
d1151 1
a1151 1
		    imsg_to_str(imsg->hdr.type),
d1166 1
a1166 1
				imsg_to_str(imsg->hdr.type)))
@


1.218
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@a59 1
static void parent_send_config_mfa(void);
a119 1
struct mproc	*p_mfa = NULL;
a235 1
			m_forward(p_mfa, imsg);
a318 1
	parent_send_config_mfa();
a331 8
parent_send_config_mfa()
{
	log_debug("debug: parent_send_config_mfa: reloading");
	m_compose(p_mfa, IMSG_CONF_START, 0, 0, -1, NULL, 0);
	m_compose(p_mfa, IMSG_CONF_END, 0, 0, -1, NULL, 0);
}

void
a649 1
	config_peer(PROC_MFA);
a714 1
	child_add(mfa(), CHILD_DAEMON, proc_title(PROC_MFA));
a1198 2
	case PROC_MFA:
		return "filter";
a1219 2
	case PROC_MFA:
		return "mfa";
a1412 4
	m_create(p_mfa, IMSG_CTL_VERBOSE, 0, 0, -1);
	m_add_int(p_mfa, v);
	m_close(p_mfa);
	
a1427 4
	
	m_create(p_mfa, IMSG_CTL_PROFILE, 0, 0, -1);
	m_add_int(p_mfa, v);
	m_close(p_mfa);
@


1.217
log
@start the purge task after events are set, or we can miss SIGCHLD

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.216 2014/04/01 09:00:46 gilles Exp $	*/
d61 1
a61 1
static void parent_send_config_smtp(void);
a120 1
struct mproc	*p_mda = NULL;
a121 1
struct mproc	*p_mta = NULL;
d125 1
a125 1
struct mproc	*p_smtp = NULL;
d155 1
a155 1
		case IMSG_PARENT_FORWARD_OPEN:
d166 1
a166 1
			m_compose(p, IMSG_PARENT_FORWARD_OPEN, 0, 0, fd,
d191 1
a191 1
	if (p->proc == PROC_MDA) {
d193 1
a193 1
		case IMSG_PARENT_FORK_MDA:
d204 1
a204 1
		case IMSG_PARENT_KILL_MDA:
a237 1
			m_forward(p_mda, imsg);
a238 1
			m_forward(p_mta, imsg);
d240 1
a240 1
			m_forward(p_smtp, imsg);
d243 1
a243 1
		case IMSG_CTL_TRACE:
d252 1
a252 1
		case IMSG_CTL_UNTRACE:
d261 1
a261 1
		case IMSG_CTL_PROFILE:
d269 1
a269 1
		case IMSG_CTL_UNPROFILE:
d323 1
a323 1
	parent_send_config_smtp();
d328 1
a328 1
parent_send_config_smtp(void)
d330 3
a332 3
	log_debug("debug: parent_send_config: configuring smtp");
	m_compose(p_smtp, IMSG_CONF_START, 0, 0, -1, NULL, 0);
	m_compose(p_smtp, IMSG_CONF_END, 0, 0, -1, NULL, 0);
a337 3
	struct filter	       *f;
	void		       *iter_dict = NULL;

a339 4

	while (dict_iter(&env->sc_filters, &iter_dict, NULL, (void **)&f))
		m_compose(p_mfa, IMSG_CONF_FILTER, 0, 0, -1, f, sizeof(*f));

d417 1
a417 1
				m_create(p_mda, IMSG_MDA_DONE, 0, 0,
d419 3
a421 3
				m_add_id(p_mda, child->mda_id);
				m_add_string(p_mda, cause);
				m_close(p_mda);
a661 1
	config_peer(PROC_MDA);
a662 2
	config_peer(PROC_MTA);
	config_peer(PROC_SMTP);
d664 1
a727 1
	child_add(mda(), CHILD_DAEMON, proc_title(PROC_MDA));
a728 1
	child_add(mta(), CHILD_DAEMON, proc_title(PROC_MTA));
d730 1
a730 2
	child_add(smtp(), CHILD_DAEMON, proc_title(PROC_SMTP));

d823 4
a826 4
		m_create(p_mda, IMSG_MDA_DONE, 0, 0, -1);
		m_add_id(p_mda,	id);
		m_add_string(p_mda, ebuf);
		m_close(p_mda);
d833 4
a836 4
		m_create(p_mda, IMSG_MDA_DONE, 0, 0, -1);
		m_add_id(p_mda,	id);
		m_add_string(p_mda, ebuf);
		m_close(p_mda);
d842 4
a845 4
		m_create(p_mda, IMSG_MDA_DONE, 0, 0, -1);
		m_add_id(p_mda,	id);
		m_add_string(p_mda, ebuf);
		m_close(p_mda);
d856 4
a859 4
		m_create(p_mda, IMSG_MDA_DONE, 0, 0, -1);
		m_add_id(p_mda,	id);
		m_add_string(p_mda, ebuf);
		m_close(p_mda);
d869 4
a872 4
		m_create(p_mda, IMSG_MDA_DONE, 0, 0, -1);
		m_add_id(p_mda,	id);
		m_add_string(p_mda, ebuf);
		m_close(p_mda);
d885 1
a885 1
		m_create(p, IMSG_PARENT_FORK_MDA, 0, 0, pipefd[1]);
a1212 2
	case PROC_SMTP:
		return "smtp";
a1218 4
	case PROC_MDA:
		return "delivery";
	case PROC_MTA:
		return "transfer";
d1223 2
a1235 2
	case PROC_SMTP:
		return "smtp";
a1241 4
	case PROC_MDA:
		return "mda";
	case PROC_MTA:
		return "mta";
d1246 2
a1247 1

d1266 1
d1269 12
a1280 2
	CASE(IMSG_CTL_SHUTDOWN);
	CASE(IMSG_CTL_VERBOSE);
d1285 3
a1292 2
	CASE(IMSG_CTL_LIST_MESSAGES);
	CASE(IMSG_CTL_LIST_ENVELOPES);
d1296 5
d1302 1
a1302 12
	CASE(IMSG_CTL_TRACE);
	CASE(IMSG_CTL_UNTRACE);
	CASE(IMSG_CTL_PROFILE);
	CASE(IMSG_CTL_UNPROFILE);

	CASE(IMSG_CTL_MTA_SHOW_HOSTS);
	CASE(IMSG_CTL_MTA_SHOW_RELAYS);
	CASE(IMSG_CTL_MTA_SHOW_ROUTES);
	CASE(IMSG_CTL_MTA_SHOW_HOSTSTATS);
	CASE(IMSG_CTL_MTA_BLOCK);
	CASE(IMSG_CTL_MTA_UNBLOCK);
	CASE(IMSG_CTL_MTA_SHOW_BLOCK);
a1304 12
	CASE(IMSG_CONF_SSL);
	CASE(IMSG_CONF_LISTENER);
	CASE(IMSG_CONF_TABLE);
	CASE(IMSG_CONF_TABLE_CONTENT);
	CASE(IMSG_CONF_RULE);
	CASE(IMSG_CONF_RULE_SOURCE);
	CASE(IMSG_CONF_RULE_SENDER);
	CASE(IMSG_CONF_RULE_DESTINATION);
	CASE(IMSG_CONF_RULE_RECIPIENT);
	CASE(IMSG_CONF_RULE_MAPPING);
	CASE(IMSG_CONF_RULE_USERS);
	CASE(IMSG_CONF_FILTER);
d1307 4
a1310 6
	CASE(IMSG_LKA_UPDATE_TABLE);
	CASE(IMSG_LKA_EXPAND_RCPT);
	CASE(IMSG_LKA_SECRET);
	CASE(IMSG_LKA_SOURCE);
	CASE(IMSG_LKA_HELO);
	CASE(IMSG_LKA_USERINFO);
d1312 25
a1336 15
	CASE(IMSG_LKA_SSL_INIT);
	CASE(IMSG_LKA_SSL_VERIFY_CERT);
	CASE(IMSG_LKA_SSL_VERIFY_CHAIN);
	CASE(IMSG_LKA_SSL_VERIFY);

	CASE(IMSG_DELIVERY_OK);
	CASE(IMSG_DELIVERY_TEMPFAIL);
	CASE(IMSG_DELIVERY_PERMFAIL);
	CASE(IMSG_DELIVERY_LOOP);
	CASE(IMSG_DELIVERY_HOLD);
	CASE(IMSG_DELIVERY_RELEASE);

	CASE(IMSG_BOUNCE_INJECT);

	CASE(IMSG_MDA_DELIVER);
d1338 5
a1343 10
	CASE(IMSG_MFA_REQ_CONNECT);
	CASE(IMSG_MFA_REQ_HELO);
	CASE(IMSG_MFA_REQ_MAIL);
	CASE(IMSG_MFA_REQ_RCPT);
	CASE(IMSG_MFA_REQ_DATA);
	CASE(IMSG_MFA_REQ_EOM);
	CASE(IMSG_MFA_EVENT_RSET);
	CASE(IMSG_MFA_EVENT_COMMIT);
	CASE(IMSG_MFA_EVENT_ROLLBACK);
	CASE(IMSG_MFA_EVENT_DISCONNECT);
d1346 15
a1360 1
	CASE(IMSG_MTA_TRANSFER);
d1362 35
a1396 32

	CASE(IMSG_QUEUE_CREATE_MESSAGE);
	CASE(IMSG_QUEUE_SUBMIT_ENVELOPE);
	CASE(IMSG_QUEUE_COMMIT_ENVELOPES);
	CASE(IMSG_QUEUE_REMOVE_MESSAGE);
	CASE(IMSG_QUEUE_COMMIT_MESSAGE);
	CASE(IMSG_QUEUE_MESSAGE_FD);
	CASE(IMSG_QUEUE_MESSAGE_FILE);
	CASE(IMSG_QUEUE_REMOVE);
	CASE(IMSG_QUEUE_EXPIRE);
	CASE(IMSG_QUEUE_BOUNCE);

	CASE(IMSG_PARENT_FORWARD_OPEN);
	CASE(IMSG_PARENT_FORK_MDA);
	CASE(IMSG_PARENT_KILL_MDA);

	CASE(IMSG_SMTP_ENQUEUE_FD);

	CASE(IMSG_DNS_HOST);
	CASE(IMSG_DNS_HOST_END);
	CASE(IMSG_DNS_PTR);
	CASE(IMSG_DNS_MX);
	CASE(IMSG_DNS_MX_PREFERENCE);

	CASE(IMSG_STAT_INCREMENT);
	CASE(IMSG_STAT_DECREMENT);
	CASE(IMSG_STAT_SET);

	CASE(IMSG_DIGEST);
	CASE(IMSG_STATS);
	CASE(IMSG_STATS_GET);

d1427 3
a1429 3
	m_create(p_mda, IMSG_CTL_VERBOSE, 0, 0, -1);
	m_add_int(p_mda, v);
	m_close(p_mda);
a1434 4
	m_create(p_mta, IMSG_CTL_VERBOSE, 0, 0, -1);
	m_add_int(p_mta, v);
	m_close(p_mta);
	
a1437 4
	
	m_create(p_smtp, IMSG_CTL_VERBOSE, 0, 0, -1);
	m_add_int(p_smtp, v);
	m_close(p_smtp);
d1447 3
a1449 3
	m_create(p_mda, IMSG_CTL_PROFILE, 0, 0, -1);
	m_add_int(p_mda, v);
	m_close(p_mda);
a1454 4
	m_create(p_mta, IMSG_CTL_PROFILE, 0, 0, -1);
	m_add_int(p_mta, v);
	m_close(p_mta);
	
a1457 4
	
	m_create(p_smtp, IMSG_CTL_PROFILE, 0, 0, -1);
	m_add_int(p_smtp, v);
	m_close(p_smtp);
@


1.216
log
@cleanup forkmda() and get rid of a useless seteuid()-based dance

prompted by deraadt@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.215 2014/03/24 14:55:12 gilles Exp $	*/
a618 1
	purge_task();
d692 2
@


1.215
log
@do not call purge_task every 10 secs, it is only needed once at startup and
will cause the parent process to wake up unnecessarily at runtime

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.214 2014/03/22 09:41:28 gilles Exp $	*/
d836 6
a841 1
	if (db == NULL)
d843 1
a854 4
	/* lower privs early to allow fork fail due to ulimit */
	if (seteuid(deliver->userinfo.uid) < 0)
		fatal("smtpd: forkmda: cannot lower privileges");

a856 2
		if (seteuid(0) < 0)
			fatal("smtpd: forkmda: cannot restore privileges");
a870 2
		if (seteuid(0) < 0)
			fatal("smtpd: forkmda: cannot restore privileges");
a883 2
		if (seteuid(0) < 0)
			fatal("smtpd: forkmda: cannot restore privileges");
a895 2
		if (seteuid(0) < 0)
			fatal("smtpd: forkmda: cannot restore privileges");
a905 3
#define error(m) { perror(m); _exit(1); }
	if (seteuid(0) < 0)
		error("forkmda: cannot restore privileges");
d907 5
a911 1
		error("chdir");
d915 1
a915 1
		error("forkmda: dup2");
d917 1
a917 5
		error("closefrom");
	if (setgroups(1, &deliver->userinfo.gid) ||
	    setresgid(deliver->userinfo.gid, deliver->userinfo.gid, deliver->userinfo.gid) ||
	    setresuid(deliver->userinfo.uid, deliver->userinfo.uid, deliver->userinfo.uid))
		error("forkmda: cannot drop privileges");
d919 1
a919 1
		error("setsid");
d925 1
a925 1
		error("signal");
a930 2

	error("forkmda: unknown mode");
a931 1
#undef error
@


1.214
log
@disable the imsg buffers profiling code unless requested, this will prevent
all processes from waking up every second
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.213 2014/02/17 13:33:56 eric Exp $	*/
d75 1
a75 1
static void	purge_task(int, short, void *);
d110 1
a110 3
static pid_t			purge_pid;
static struct timeval		purge_timeout;
static struct event		purge_ev;
d619 1
a690 6
	purge_pid = -1;
	evtimer_set(&purge_ev, purge_task, NULL);
	purge_timeout.tv_sec = 10;
	purge_timeout.tv_usec = 0;
	evtimer_add(&purge_ev, &purge_timeout);

d779 1
a779 1
purge_task(int fd, short ev, void *arg)
d787 31
a817 34
	if (purge_pid == -1) {

		n = 0;
		if ((d = opendir(PATH_SPOOL PATH_PURGE))) {
			while (readdir(d) != NULL)
				n++;
			closedir(d);
		} else
			log_warn("warn: purge_task: opendir");

		if (n > 2) {
			switch (purge_pid = fork()) {
			case -1:
				log_warn("warn: purge_task: fork");
				break;
			case 0:
				if ((pw = getpwnam(SMTPD_USER)) == NULL)
					fatalx("unknown user " SMTPD_USER);
				if (chroot(PATH_SPOOL PATH_PURGE) == -1)
					fatal("smtpd: chroot");
				if (chdir("/") == -1)
					fatal("smtpd: chdir");
				uid = pw->pw_uid;
				gid = pw->pw_gid;
				if (setgroups(1, &gid) ||
				    setresgid(gid, gid, gid) ||
				    setresuid(uid, uid, uid))
					fatal("smtpd: cannot drop privileges");
				rmtree("/", 1);
				_exit(0);
				break;
			default:
				break;
			}
a819 2

	evtimer_add(&purge_ev, &purge_timeout);
@


1.213
log
@new "smtpctl show status" command to show if mta/mda/smtp are currently running or paused.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.212 2014/02/10 09:28:05 eric Exp $	*/
d567 2
@


1.212
log
@tweak usage() and bump version.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1329 1
@


1.211
log
@Allow the admin to pause relaying to a specific domain:
 - smtpctl pause mta from <source> for <domain>
 - smtpctl resume mta from <source> for <domain>
 - smtpctl show mta paused
@
text
@d297 2
a298 2
	fprintf(stderr, "usage: %s [-dnv] [-D macro=value] "
	    "[-f file] [-P system]\n", __progname);
d490 1
a490 1
	while ((c = getopt(argc, argv, "B:dD:nP:f:T:v")) != -1) {
d512 4
@


1.210
log
@pki code cleanup

- rename "struct ssl" and "cert" to "struct pki" and "cert" to "pki_name"
- inherit pki conf on fork instead of passing it through imsg at startup
- implement SNI on smtp listeners
@
text
@d1335 3
@


1.209
log
@get rid of fdlimit()
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.208 2013/12/26 17:25:32 eric Exp $	*/
d78 1
a78 1
static void	load_ssl_tree(void);
d330 1
a330 1
	purge_config(PURGE_SSL);
a335 6
	struct listener		*l;
	struct ssl		*s;
	void			*iter = NULL;
	struct iovec		 iov[5];
	int			 opt;

a337 28

	while (dict_iter(env->sc_ssl_dict, &iter, NULL, (void **)&s)) {
		iov[0].iov_base = s;
		iov[0].iov_len = sizeof(*s);
		iov[1].iov_base = s->ssl_cert;
		iov[1].iov_len = s->ssl_cert_len;
		iov[2].iov_base = s->ssl_key;
		iov[2].iov_len = s->ssl_key_len;
		iov[3].iov_base = s->ssl_dhparams;
		iov[3].iov_len = s->ssl_dhparams_len;
		iov[4].iov_base = s->ssl_ca;
		iov[4].iov_len = s->ssl_ca_len;
		m_composev(p_smtp, IMSG_CONF_SSL, 0, 0, -1, iov, nitems(iov));
	}

	TAILQ_FOREACH(l, env->sc_listeners, entry) {
		if ((l->fd = socket(l->ss.ss_family, SOCK_STREAM, 0)) == -1)
			fatal("smtpd: socket");
		opt = 1;
		if (setsockopt(l->fd, SOL_SOCKET, SO_REUSEADDR, &opt,
			sizeof(opt)) < 0)
			fatal("smtpd: setsockopt");
		if (bind(l->fd, (struct sockaddr *)&l->ss, l->ss.ss_len) == -1)
			fatal("smtpd: bind");
		m_compose(p_smtp, IMSG_CONF_LISTENER, 0, 0, l->fd,
		    l, sizeof(*l));
	}

a358 11
	struct rule	       *r;
	struct table	       *t;
	void		       *iter_tree;
	void		       *iter_dict;
	const char	       *k;
	char		       *v;
	char		       *buffer;
	size_t			buflen;
	struct ssl	       *s;
	struct iovec		iov[5];

a360 74

	iter_dict = NULL;
	while (dict_iter(env->sc_ssl_dict, &iter_dict, NULL, (void **)&s)) {
		iov[0].iov_base = s;
		iov[0].iov_len = sizeof(*s);
		iov[1].iov_base = s->ssl_cert;
		iov[1].iov_len = s->ssl_cert_len;
		iov[2].iov_base = s->ssl_key;
		iov[2].iov_len = s->ssl_key_len;
		iov[3].iov_base = s->ssl_dhparams;
		iov[3].iov_len = s->ssl_dhparams_len;
		iov[4].iov_base = s->ssl_ca;
		iov[4].iov_len = s->ssl_ca_len;
		m_composev(p_lka, IMSG_CONF_SSL, 0, 0, -1, iov, nitems(iov));
	}

	iter_tree = NULL;
	while (dict_iter(env->sc_tables_dict, &iter_tree, NULL,
		(void **)&t)) {
		m_compose(p_lka, IMSG_CONF_TABLE, 0, 0, -1, t, sizeof(*t));

		iter_dict = NULL;
		while (dict_iter(&t->t_dict, &iter_dict, &k,
			(void **)&v)) {
			buflen = strlen(k) + 1;
			if (v)
				buflen += strlen(v) + 1;
			buffer = xcalloc(1, buflen,
			    "parent_send_config_ruleset");
			memcpy(buffer, k, strlen(k) + 1);
			if (v)
				memcpy(buffer + strlen(k) + 1, v,
				    strlen(v) + 1);
			m_compose(p_lka, IMSG_CONF_TABLE_CONTENT, 0, 0, -1,
			    buffer, buflen);
			free(buffer);
		}
	}

	TAILQ_FOREACH(r, env->sc_rules, r_entry) {
		m_compose(p_lka, IMSG_CONF_RULE, 0, 0, -1, r, sizeof(*r));
		m_compose(p_lka, IMSG_CONF_RULE_SOURCE, 0, 0, -1,
		    &r->r_sources->t_name,
		    sizeof(r->r_sources->t_name));
		if (r->r_senders) {
			m_compose(p_lka, IMSG_CONF_RULE_SENDER,
			    0, 0, -1,
			    &r->r_senders->t_name,
			    sizeof(r->r_senders->t_name));
		}
		if (r->r_recipients) {
			m_compose(p_lka, IMSG_CONF_RULE_RECIPIENT,
			    0, 0, -1,
			    &r->r_recipients->t_name,
			    sizeof(r->r_recipients->t_name));
		}
		if (r->r_destination) {
			m_compose(p_lka, IMSG_CONF_RULE_DESTINATION,
			    0, 0, -1,
			    &r->r_destination->t_name,
			    sizeof(r->r_destination->t_name));
		}
		if (r->r_mapping) {
			m_compose(p_lka, IMSG_CONF_RULE_MAPPING, 0, 0, -1,
			    &r->r_mapping->t_name,
			    sizeof(r->r_mapping->t_name));
		}
		if (r->r_userbase) {
			m_compose(p_lka, IMSG_CONF_RULE_USERS, 0, 0, -1,
			    &r->r_userbase->t_name,
			    sizeof(r->r_userbase->t_name));
		}
	}

d599 1
a599 1
		load_ssl_tree();
d626 1
a626 1
	load_ssl_tree();
d702 1
a702 1
load_ssl_tree(void)
d704 2
a705 1
	struct ssl	*ssl;
a706 1
	const char	*k;
d710 1
a710 1
	while (dict_iter(env->sc_ssl_dict, &iter_dict, &k, (void **)&ssl)) {
d712 16
a727 16
		if (ssl->ssl_cert_file == NULL)
			fatalx("load_ssl_tree: missing certificate file");
		if (ssl->ssl_key_file == NULL)
			fatalx("load_ssl_tree: missing key file");

		if (! ssl_load_certificate(ssl, ssl->ssl_cert_file))
			fatalx("load_ssl_tree: failed to load certificate file");
		if (! ssl_load_keyfile(ssl, ssl->ssl_key_file, k))
			fatalx("load_ssl_tree: failed to load key file");

		if (ssl->ssl_ca_file)
			if (! ssl_load_cafile(ssl, ssl->ssl_ca_file))
				fatalx("load_ssl_tree: failed to load CA file");
		if (ssl->ssl_dhparams_file)
			if (! ssl_load_dhparams(ssl, ssl->ssl_dhparams_file))
				fatalx("load_ssl_tree: failed to load dhparams file");
@


1.208
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.207 2013/11/28 12:50:40 eric Exp $	*/
a853 15

	/*
	 * Pick descriptor limit that will guarantee impossibility of fd
	 * starvation condition.  The logic:
	 *
	 * Treat hardlimit as 100%.
	 * Limit smtp to 50% (inbound connections)
	 * Limit mta to 50% (outbound connections)
	 * Limit mda to 50% (local deliveries)
	 * In all three above, compute max session limit by halving the fd
	 * limit (50% -> 25%), because each session costs two fds.
	 * Limit queue to 100% to cover the extreme case when tons of fds are
	 * opened for all four possible purposes (smtp, mta, mda, bounce)
	 */
	fdlimit(0.5);
@


1.207
log
@fix loading of passphrase-protected keys.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d796 1
a796 1
	bzero(&tv, sizeof(tv));
d1154 1
a1154 1
		bzero(&args, sizeof(args));
@


1.206
log
@exit with 0 on admin shutdown
@
text
@d745 2
a768 2
	load_ssl_tree();

d830 1
a830 2
		log_debug("debug: loading pki information for %s", k);

d832 1
a832 1
			errx(1, "load_ssl_tree: missing certificate file for %s", k);
d834 1
a834 1
			errx(1, "load_ssl_tree: missing key file for %s", k);
d837 3
a839 3
			errx(1, "load_ssl_tree: failed to load certificate file for %s", k);
		if (! ssl_load_keyfile(ssl, ssl->ssl_key_file))
			errx(1, "load_ssl_tree: failed to load certificate file for %s", k);
d843 1
a843 1
				errx(1, "load_ssl_tree: failed to load CA file for %s", k);
d846 1
a846 1
				errx(1, "load_ssl_tree: failed to load dhparams file for %s", k);
@


1.205
log
@disable .forward lookup if sticky bit is set on homedir
@
text
@d57 1
a57 1
static void parent_shutdown(void);
d284 1
a284 1
			parent_shutdown();
d303 1
a303 1
parent_shutdown(void)
d321 1
a321 1
	exit(0);
d578 1
a578 1
			parent_shutdown();
@


1.204
log
@Much much improved config parser and related changes.
Simplify code and do not impose an order on conditions and rule options.

Format changes that may require smtpd.conf update for some setups:

- SSL certificates are no longer automatically loaded, but must be
  explicitely declared using the "pki" keyword.
- "certificate" option becomes "pki" in listener and accept rules.
- "ssl://" becomes "secure://" in relay via rules.
- "helo" becomes "hostnames" in relay rules

New features:

- accept rules do not need an explicit action, in which case alias table
  or .forward must provide one.
- new "forward-only" action to force relaying and reject rcpts that expand
  as local delivery.
- "!" (negation) modifier on rule matching conditions.
- new "recipient" rule matching condition.
- new "verify" option on listeners and relay rules to reject invalid
  certificates.

Other changes:

- remember the helo name advertised on incoming mail and use it for sending
  bounces.
- bump envelope version (existing envelopes are updated on-the-fly).
@
text
@d1265 3
a1267 2
	char pathname[SMTPD_MAXPATHLEN];
	int	fd;
d1272 11
@


1.203
log
@add "smtpctl show relays" and "smtpctl show hosts" commands
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.202 2013/10/27 17:47:53 eric Exp $	*/
d78 1
a78 1
static void	load_ssl_trees(void);
a345 2
		if (!(s->flags & F_SCERT))
			continue;
d456 6
d718 1
a718 1
		load_ssl_trees();
d767 1
a767 1
	load_ssl_trees();
d821 1
a821 1
load_ssl_trees(void)
a822 1
	struct listener	*l;
d824 2
a825 1
	struct rule	*r;
d827 4
a830 14
	log_debug("debug: init server-ssl tree");
	TAILQ_FOREACH(l, env->sc_listeners, entry) {
		if (!(l->flags & F_SSL))
			continue;

		ssl = dict_get(env->sc_ssl_dict, l->ssl_cert_name);
		if (ssl == NULL) {
			if (! ssl_load_certfile(&ssl, "/etc/mail/certs",
			    l->ssl_cert_name, F_SCERT))
				errx(1, "cannot load certificate: %s",
				    l->ssl_cert_name);
			dict_set(env->sc_ssl_dict, ssl->ssl_name, ssl);
		}
	}
d832 16
a847 17
	log_debug("debug: init client-ssl tree");
	TAILQ_FOREACH(r, env->sc_rules, r_entry) {
		if (r->r_action != A_RELAY && r->r_action != A_RELAYVIA)
			continue;
		if (! r->r_value.relayhost.cert[0])
			continue;

		ssl = dict_get(env->sc_ssl_dict, r->r_value.relayhost.cert);
		if (ssl)
			ssl->flags |= F_CCERT;
		else {
			if (! ssl_load_certfile(&ssl, "/etc/mail/certs",
			    r->r_value.relayhost.cert, F_CCERT))
				errx(1, "cannot load certificate: %s",
				    r->r_value.relayhost.cert);
			dict_set(env->sc_ssl_dict, ssl->ssl_name, ssl);
		}
d1345 1
a1345 1
	if (to == PROC_CONTROL)
@


1.202
log
@Implement a feedback mechanism which allows the mta to "hold" envelopes
in the scheduler when it has too many tasks for a given relay.  The
envelopes are put on a wait queue, and are not scheduled again until
the mta "releases" some envelopes from that queue.

It prevents from having too many inflight envelopes, which are out of reach
for the admin.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.201 2013/10/27 11:01:47 eric Exp $	*/
d1461 2
d1475 1
@


1.201
log
@Make the filter infrastructure move forward.
This is a work-in-progress and it's not supposed to be useable for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.200 2013/10/27 07:56:25 eric Exp $	*/
d1494 2
@


1.200
log
@Create the control socket in the parent process to abort early if
another smtpd instance is running.  Close the inherited socket in
every forked process but control.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.199 2013/10/26 12:27:59 eric Exp $	*/
a1509 1
	CASE(IMSG_MFA_SMTP_DATA);
@


1.199
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.198 2013/07/19 21:58:54 eric Exp $	*/
d139 1
d725 3
a880 3
	if (env->sc_queue_key)
		memset(env->sc_queue_key, 0, strlen(env->sc_queue_key));

d888 14
@


1.198
log
@Temporarily allow alternate names for traces, until this get cleaned up.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1308 1
a1308 1
		log_debug("profile-imsg: %s %s %s %i %lld.%06li",
d1341 1
a1341 1
		log_trace(TRACE_IMSG, "imsg: %s <- %s: %s (len=%zu, fd=%i)",
@


1.197
log
@Many MTA improvements:

- Better transient error handling logic: failing destinations are
  automatically disabled for a while.  When a destination is active
  again, ask the scheduler to retry previous envelopes immediatly.
- More informative error report when all routes fail for a mail.
- Implement a "smtpctl show hoststats" command to get the latest stat
  message per MX domain.
- Implement a "smtpctl show routes" command to show the state the
  currently known routes to remote MXs.
- Implement a "smtpctl resume route" command to re-enable a route that
  has been disabled.
- Do not hardcode limits
- Minor code improvements
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.196 2013/07/19 20:37:07 eric Exp $	*/
d641 3
a643 1
			else if (!strcmp(optarg, "mfa"))
d645 2
a646 1
			else if (!strcmp(optarg, "mta"))
d648 2
a649 1
			else if (!strcmp(optarg, "bounce"))
d655 2
a656 1
			else if (!strcmp(optarg, "stat"))
d664 2
a665 1
			else if (!strcmp(optarg, "tables"))
@


1.196
log
@Assorted queue improvements:
- cleanup the internal queue backend API and get rid of the QOP_* thing.
- implement a queue_proc backend
- rename queue_fsqueue.c to queue_fs
- enable support for queue encryption
- add an envelope cache
- better logging and error reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.195 2013/07/19 15:53:35 eric Exp $	*/
d1429 1
d1440 3
d1492 1
a1492 3
	CASE(IMSG_MTA_BATCH);
	CASE(IMSG_MTA_BATCH_ADD);
	CASE(IMSG_MTA_BATCH_END);
@


1.195
log
@assorted fixes:
- fix client certificates
- unlink control socket on exit
- write a pidfile
- minor code updates
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.194 2013/07/19 15:14:23 eric Exp $	*/
d870 4
a878 1
	child_add(queue(), CHILD_DAEMON, proc_title(PROC_QUEUE));
@


1.194
log
@scheduler improvements:
- implement suspend/resume scheduling for individual envelopes or message,
  with the associated smtpctl commands.
- allow the mta to request immediate scheduling of an envelope.
- on temporary failures a penalty can be given to further delay the next try.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.193 2013/07/19 11:14:08 eric Exp $	*/
d47 1
d317 2
a409 2
		if (!(s->flags & F_SCERT))
			continue;
d797 3
d817 9
a825 6
		ssl = NULL;
		if (! ssl_load_certfile(&ssl, "/etc/mail/certs",
			l->ssl_cert_name, F_SCERT))
			errx(1, "cannot load certificate: %s",
			    l->ssl_cert_name);
		dict_set(env->sc_ssl_dict, ssl->ssl_name, ssl);
d834 11
a844 6
		ssl = NULL;
		if (! ssl_load_certfile(&ssl, "/etc/mail/certs",
			r->r_value.relayhost.cert, F_CCERT))
			errx(1, "cannot load certificate: %s",
			    r->r_value.relayhost.cert);
		dict_set(env->sc_ssl_dict, ssl->ssl_name, ssl);
d953 1
a953 1
	int		 n, allout, pipefd[2];
d978 1
a978 1
		n = snprintf(ebuf, sizeof ebuf, "pipe: %s", strerror(errno));
d994 1
a994 1
		n = snprintf(ebuf, sizeof ebuf, "mkstemp: %s", strerror(errno));
d1009 1
a1009 1
		n = snprintf(ebuf, sizeof ebuf, "fork: %s", strerror(errno));
d1299 1
a1299 1
		log_debug("profile-imsg: %s %s %s %i %li.%06li",
d1304 1
a1304 1
		    dt.tv_sec * 1000000 + dt.tv_nsec / 1000000,
@


1.193
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.192 2013/07/04 07:04:07 gilles Exp $	*/
d1406 1
d1410 1
d1476 1
@


1.192
log
@somehow a return; was removed

spotted by David Hill and Maxime Villard
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.191 2013/05/24 17:03:14 eric Exp $	*/
a590 1
	struct passwd	*pwq;
a716 27
	if ((env->sc_pw = getpwnam(SMTPD_USER)) == NULL)
		errx(1, "unknown user %s", SMTPD_USER);
	if ((env->sc_pw = pw_dup(env->sc_pw)) == NULL)
		err(1, NULL);

	env->sc_pwqueue = getpwnam(SMTPD_QUEUE_USER);
	if (env->sc_pwqueue)
		pwq = env->sc_pwqueue = pw_dup(env->sc_pwqueue);
	else
		pwq = env->sc_pwqueue = pw_dup(env->sc_pw);
	if (env->sc_pwqueue == NULL)
		err(1, NULL);

	if (ckdir(PATH_SPOOL, 0711, 0, 0, 1) == 0)
		errx(1, "error in spool directory setup");
	if (ckdir(PATH_SPOOL PATH_OFFLINE, 01777, 0, 0, 1) == 0)
		errx(1, "error in offline directory setup");
	if (ckdir(PATH_SPOOL PATH_PURGE, 0700, pwq->pw_uid, 0, 1) == 0)
		errx(1, "error in purge directory setup");
	if (ckdir(PATH_SPOOL PATH_TEMPORARY, 0700, pwq->pw_uid, 0, 1) == 0)
		errx(1, "error in purge directory setup");

	mvpurge(PATH_SPOOL PATH_INCOMING, PATH_SPOOL PATH_PURGE);

	if (ckdir(PATH_SPOOL PATH_INCOMING, 0700, pwq->pw_uid, 0, 1) == 0)
		errx(1, "error in incoming directory setup");

d888 1
d910 2
d916 2
a917 2
				uid = env->sc_pw->pw_uid;
				gid = env->sc_pw->pw_gid;
@


1.191
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.188 2013/02/14 13:11:40 gilles Exp $	*/
d1330 2
a1331 1
				imsg_to_str(imsg->hdr.type)));
@


1.190
log
@large time_t problems
ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.189 2013/04/12 18:22:49 eric Exp $	*/
a23 1
#include <sys/param.h>
d77 1
d105 1
d137 1
a154 8
	if (p->proc == PROC_SMTP) {
		switch (imsg->hdr.type) {
		case IMSG_PARENT_SEND_CONFIG:
			parent_send_config_smtp();
			return;
		}
	}

d185 1
a185 1
			m_create(p, IMSG_LKA_AUTHENTICATE, 0, 0, -1, 128);
d219 1
a219 1
				log_debug("debug: smptd: "
d225 1
a225 1
			log_debug("debug: smptd: kill requested for %u: %s",
d423 1
a423 1
	while (tree_iter(env->sc_tables_tree, &iter_tree, NULL,
d544 1
a544 1
				    child->mda_out, 32 + strlen(cause));
a591 3
	struct listener	*l;
	struct rule	*r;
	struct ssl	*ssl;
d619 1
a619 2
			debug = 2;
			verbose |= TRACE_VERBOSE;
d655 2
a656 2
			else if (!strcmp(optarg, "imsg-size"))
				verbose |= TRACE_IMSGSIZE;
d659 4
d664 1
a664 1
				verbose |= ~TRACE_VERBOSE;
d684 1
a684 1
			verbose |=  TRACE_VERBOSE;
a690 3
	if (!(verbose & TRACE_VERBOSE))
		verbose = 0;

d702 3
a704 2
	if (strlcpy(env->sc_conffile, conffile, MAXPATHLEN) >= MAXPATHLEN)
		errx(1, "config file exceeds MAXPATHLEN");
d707 1
d752 4
a755 1
	log_init(debug);
d760 1
a760 1
	if (!debug)
d774 1
a774 1
	log_info("info: startup%s", (debug > 1)?" [debug mode]":"");
d780 1
a780 23
	log_debug("debug: init server-ssl tree");
	TAILQ_FOREACH(l, env->sc_listeners, entry) {
		if (!(l->flags & F_SSL))
			continue;
		ssl = NULL;
		if (! ssl_load_certfile(&ssl, "/etc/mail/certs",
			l->ssl_cert_name, F_SCERT))
			errx(1, "cannot load certificate: %s", l->ssl_cert_name);
		dict_set(env->sc_ssl_dict, ssl->ssl_name, ssl);
	}

	log_debug("debug: init client-ssl tree");
	TAILQ_FOREACH(r, env->sc_rules, r_entry) {
		if (r->r_action != A_RELAY && r->r_action != A_RELAYVIA)
			continue;
		if (! r->r_value.relayhost.cert[0])
			continue;
		ssl = NULL;
		if (! ssl_load_certfile(&ssl, "/etc/mail/certs",
			r->r_value.relayhost.cert, F_CCERT))
			errx(1, "cannot load certificate: %s", r->r_value.relayhost.cert);
		dict_set(env->sc_ssl_dict, ssl->ssl_name, ssl);
	}
d808 1
a808 1
	evtimer_set(&env->sc_ev, parent_send_config, NULL);
d810 1
a810 1
	evtimer_add(&env->sc_ev, &tv);
d831 34
d979 1
a979 1
		m_create(p_mda, IMSG_MDA_DONE, 0, 0, -1, 128);
d994 1
a994 1
		m_create(p_mda, IMSG_MDA_DONE, 0, 0, -1, 128);
d1010 1
a1010 1
		m_create(p_mda, IMSG_MDA_DONE, 0, 0, -1, 128);
d1025 1
a1025 1
		m_create(p_mda, IMSG_MDA_DONE, 0, 0, -1, 128);
d1043 1
a1043 1
		m_create(p, IMSG_PARENT_FORK_MDA, 0, 0, pipefd[1], 9);
d1121 1
a1121 1
	char		 t[MAXPATHLEN], *path;
d1261 1
a1261 1
	char pathname[MAXPATHLEN];
a1296 1
		log_warnx("warn: pipe error with %s", p->name);
d1312 1
a1312 1
		log_debug("profile-imsg: %s %s %s %i %lld.%06li",
d1317 1
a1317 1
		    (long long)dt.tv_sec * 1000000 + dt.tv_nsec / 1000000,
d1362 6
a1367 2
	case PROC_CONTROL:
		return "control";
d1370 2
a1373 2
	case PROC_MFA:
		return "filter";
d1376 2
a1377 4
	case PROC_PARENT:
		return "[priv]";
	case PROC_QUEUE:
		return "queue";
a1379 2
	case PROC_SMTP:
		return "smtp";
d1407 5
a1512 1
	CASE(IMSG_PARENT_SEND_CONFIG);
d1540 1
a1540 1
	char	user[MAXLOGNAME];
d1556 1
a1556 1
	m_create(p_lka, IMSG_CTL_VERBOSE, 0, 0, -1, sizeof v);
d1560 1
a1560 1
	m_create(p_mda, IMSG_CTL_VERBOSE, 0, 0, -1, sizeof v);
d1564 1
a1564 1
	m_create(p_mfa, IMSG_CTL_VERBOSE, 0, 0, -1, sizeof v);
d1568 1
a1568 1
	m_create(p_mta, IMSG_CTL_VERBOSE, 0, 0, -1, sizeof v);
d1572 1
a1572 1
	m_create(p_queue, IMSG_CTL_VERBOSE, 0, 0, -1, sizeof v);
d1576 1
a1576 1
	m_create(p_smtp, IMSG_CTL_VERBOSE, 0, 0, -1, sizeof v);
d1584 1
a1584 1
	m_create(p_lka, IMSG_CTL_PROFILE, 0, 0, -1, sizeof v);
d1588 1
a1588 1
	m_create(p_mda, IMSG_CTL_PROFILE, 0, 0, -1, sizeof v);
d1592 1
a1592 1
	m_create(p_mfa, IMSG_CTL_PROFILE, 0, 0, -1, sizeof v);
d1596 1
a1596 1
	m_create(p_mta, IMSG_CTL_PROFILE, 0, 0, -1, sizeof v);
d1600 1
a1600 1
	m_create(p_queue, IMSG_CTL_PROFILE, 0, 0, -1, sizeof v);
d1604 1
a1604 1
	m_create(p_smtp, IMSG_CTL_PROFILE, 0, 0, -1, sizeof v);
@


1.189
log
@replace MAX_LINE_SIZE and SMTP_LINE_MAX with SMTPD_MAXLINESIZE for
consistency and clarity.  Remove useless and confusing extra byte in
a few arrays based on this define.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.188 2013/02/14 13:11:40 gilles Exp $	*/
d1305 1
a1305 1
		log_debug("profile-imsg: %s %s %s %i %li.%06li",
d1310 1
a1310 1
		    dt.tv_sec * 1000000 + dt.tv_nsec / 1000000,
@


1.188
log
@- log smtpd version at startup

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.187 2013/02/14 12:30:49 gilles Exp $	*/
d1530 1
a1530 1
	char	pass[MAX_LINE_SIZE + 1];
@


1.187
log
@- smtpctl trace expand, enables tracing of aliases expansion
- replace "users" keyword with "userbase" when providing alternate userbase
- disambiguise expansion nodes when expanding across domains and userbases
- allow use of '=' instead of '=>' when declaring a mapping

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.186 2013/01/31 18:34:43 eric Exp $	*/
d761 2
@


1.186
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.184 2013/01/26 09:37:23 gilles Exp $	*/
d473 1
a473 1
		if (r->r_users) {
d475 2
a476 2
			    &r->r_users->t_name,
			    sizeof(r->r_users->t_name));
d667 2
@


1.185
log
@- introduce 'smtpctl trace lookup' to trace lookup process
- improve logging of the transfer process

trace by me, logging by eric
@
text
@d38 1
d546 3
d799 1
a799 1
			r->r_value.relayhost.cert, F_CCERT) < 0)
a904 1
	struct dirent	*de;
d913 1
a913 1
			while ((de = readdir(d)) != NULL)
d955 1
d957 2
a958 2
	log_debug("debug: forkmda: to \"%s\" as %s",
	    deliver->to, deliver->user);
d991 1
d993 1
d1016 1
@


1.184
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.181 2012/11/12 14:58:53 eric Exp $	*/
d655 2
@


1.183
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.182 2012/11/20 09:47:46 eric Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d31 1
d35 1
a36 1
#include <event.h>
d38 1
d48 2
d52 1
d54 1
a54 1
static void parent_imsg(struct imsgev *, struct imsg *);
d58 3
a60 3
static void parent_send_config_listeners(void);
static void parent_send_config_client_certs(void);
static void parent_send_config_ruleset(int);
d62 4
a65 2
static void forkmda(struct imsgev *, uint32_t, struct deliver *);
static int parent_forward_open(char *);
d76 1
d89 1
a89 1
	uint32_t		 mda_id;
d112 3
a114 1
void		(*imsg_callback)(struct imsgev *, struct imsg *);
d118 10
d132 3
a134 2
static int	 profiling;
static int	 profstat;
d139 1
a139 1
parent_imsg(struct imsgev *iev, struct imsg *imsg)
d142 1
a142 2
	struct auth		*auth;
	struct auth_backend	*auth_backend;
d144 5
a148 1
	size_t			 len;
d150 1
a150 1
	int			 fd, n;
d152 1
a152 1
	if (iev->proc == PROC_SMTP) {
d155 1
a155 10
			parent_send_config_listeners();
			return;

		case IMSG_PARENT_AUTHENTICATE:
			auth_backend = auth_backend_lookup(AUTH_BSD);
			auth = imsg->data;
			auth->success = auth_backend->authenticate(auth->user,
			    auth->pass);
			imsg_compose_event(iev, IMSG_PARENT_AUTHENTICATE, 0, 0,
			    -1, auth, sizeof *auth);
d160 1
a160 1
	if (iev->proc == PROC_LKA) {
d164 2
a165 1
			fd = parent_forward_open(fwreq->as_user);
d167 5
a171 2
			if (fd == -2) {
				/* no ~/.forward, however it's optional. */
d173 21
a193 5
				fd = -1;
			} else if (fd != -1)
				fwreq->status = 1;
			imsg_compose_event(iev, IMSG_PARENT_FORWARD_OPEN, 0, 0,
			    fd, fwreq, sizeof *fwreq);
d198 1
a198 1
	if (iev->proc == PROC_MDA) {
d201 8
a208 1
			forkmda(iev, imsg->hdr.peerid, imsg->data);
d212 5
d220 1
a220 1
				    c->mda_id == imsg->hdr.peerid &&
d224 2
a225 2
				log_debug("debug: smptd: kill request: "
				    "proc not found");
d228 2
a229 8
			len = imsg->hdr.len - sizeof imsg->hdr;
			if (len == 0)
				c->cause = xstrdup("no reason", "parent_imsg");
			else {
				c->cause = xmemdup(imsg->data, len,
				    "parent_imsg");
				c->cause[len - 1] = '\0';
			}
d237 1
a237 1
	if (iev->proc == PROC_CONTROL) {
d240 37
a276 1
			log_verbose(*(int *)imsg->data);
d278 6
a283 19
			/* forward to other processes */
			imsg_compose_event(env->sc_ievs[PROC_LKA],
			    IMSG_CTL_VERBOSE, 0, 0, -1, imsg->data,
			    sizeof(int));
			imsg_compose_event(env->sc_ievs[PROC_MDA],
			    IMSG_CTL_VERBOSE, 0, 0, -1, imsg->data,
			    sizeof(int));
			imsg_compose_event(env->sc_ievs[PROC_MFA],
			    IMSG_CTL_VERBOSE, 0, 0, -1, imsg->data,
			    sizeof(int));
			imsg_compose_event(env->sc_ievs[PROC_MTA],
			    IMSG_CTL_VERBOSE, 0, 0, -1, imsg->data,
			    sizeof(int));
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_CTL_VERBOSE, 0, 0, -1, imsg->data,
			    sizeof(int));
			imsg_compose_event(env->sc_ievs[PROC_SMTP],
			    IMSG_CTL_VERBOSE, 0, 0, -1, imsg->data,
			    sizeof(int));
d328 4
a331 4
	parent_send_config_listeners();
	parent_send_config_client_certs();
	parent_send_config_ruleset(PROC_MFA);
	parent_send_config_ruleset(PROC_LKA);
d335 1
a335 1
parent_send_config_listeners(void)
d339 1
d344 1
a344 2
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_CONF_START,
	    0, 0, -1, NULL, 0);
d346 1
a346 1
	SPLAY_FOREACH(s, ssltree, env->sc_ssl) {
a348 1

d359 1
a359 4

		imsg_composev(&env->sc_ievs[PROC_SMTP]->ibuf,
		    IMSG_CONF_SSL, 0, 0, -1, iov, nitems(iov));
		imsg_event_add(env->sc_ievs[PROC_SMTP]);
d367 1
a367 1
		    sizeof(opt)) < 0)
d371 2
a372 2
		imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_CONF_LISTENER,
		    0, 0, l->fd, l, sizeof(*l));
d375 1
a375 2
	imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_CONF_END,
	    0, 0, -1, NULL, 0);
d378 2
a379 2
static void
parent_send_config_client_certs(void)
d381 11
a391 2
	struct ssl		*s;
	struct iovec		 iov[3];
d393 13
a405 3
	log_debug("debug: parent_send_config_client_certs: configuring smtp");
	imsg_compose_event(env->sc_ievs[PROC_MTA], IMSG_CONF_START,
	    0, 0, -1, NULL, 0);
d407 6
a412 2
	SPLAY_FOREACH(s, ssltree, env->sc_ssl) {
		if (!(s->flags & F_CCERT))
a413 1

d420 6
d427 21
a447 3
		imsg_composev(&env->sc_ievs[PROC_MTA]->ibuf, IMSG_CONF_SSL,
		    0, 0, -1, iov, nitems(iov));
		imsg_event_add(env->sc_ievs[PROC_MTA]);
d450 16
a465 20
	imsg_compose_event(env->sc_ievs[PROC_MTA], IMSG_CONF_END,
	    0, 0, -1, NULL, 0);
}

void
parent_send_config_ruleset(int proc)
{
	struct rule		*r;
	struct map		*m;
	struct mapel		*mapel;
	struct filter		*f;

	log_debug("debug: parent_send_config_ruleset: reloading");
	imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_START,
	    0, 0, -1, NULL, 0);

	if (proc == PROC_MFA) {
		TAILQ_FOREACH(f, env->sc_filters, f_entry) {
			imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_FILTER,
			    0, 0, -1, f, sizeof(*f));
d467 4
a470 9
	}
	else {
		TAILQ_FOREACH(m, env->sc_maps, m_entry) {
			imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_MAP,
			    0, 0, -1, m, sizeof(*m));
			TAILQ_FOREACH(mapel, &m->m_contents, me_entry)
				imsg_compose_event(env->sc_ievs[proc],
				    IMSG_CONF_MAP_CONTENT, 0, 0, -1, mapel,
				    sizeof(*mapel));
d472 4
a475 8

		TAILQ_FOREACH(r, env->sc_rules, r_entry) {
			imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_RULE,
			    0, 0, -1, r, sizeof(*r));
			imsg_compose_event(env->sc_ievs[proc],
			    IMSG_CONF_RULE_SOURCE, 0, 0, -1,
			    &r->r_sources->m_name,
			    sizeof(r->r_sources->m_name));
d479 1
a479 2
	imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_END,
	    0, 0, -1, NULL, 0);
d545 6
a550 3
				imsg_compose_event(env->sc_ievs[PROC_MDA],
				    IMSG_MDA_DONE, child->mda_id, 0,
				    child->mda_out, cause, strlen(cause) + 1);
d584 1
a584 2
	int		 c;
	int		 debug, verbose;
d593 4
a596 9
	struct peer	 peers[] = {
		{ PROC_CONTROL,	imsg_dispatch },
		{ PROC_LKA,	imsg_dispatch },
		{ PROC_MDA,	imsg_dispatch },
		{ PROC_MFA,	imsg_dispatch },
		{ PROC_MTA,	imsg_dispatch },
		{ PROC_SMTP,	imsg_dispatch },
		{ PROC_QUEUE,	imsg_dispatch }
	};
d619 2
a620 1
				log_warnx("warn: invalid backend specifier %s",
d629 2
a630 2
				log_warnx(
				    "warn: could not parse macro definition %s",
d647 2
d657 4
a660 6
			else if (!strcmp(optarg, "profiling")) {
				verbose |= TRACE_PROFILING;
				profiling = 1;
			}
			else if (!strcmp(optarg, "profstat"))
				profstat = 1;
d663 6
d717 1
a717 1
	if ((env->sc_pw =  getpwnam(SMTPD_USER)) == NULL)
d719 10
d730 1
a730 1
	if (!ckdir(PATH_SPOOL, 0711, 0, 0, 1))
d732 1
a732 1
	if (!ckdir(PATH_SPOOL PATH_OFFLINE, 01777, 0, 0, 1))
d734 1
a734 1
	if (!ckdir(PATH_SPOOL PATH_PURGE, 0700, env->sc_pw->pw_uid, 0, 1))
d736 1
a736 1
	if (!ckdir(PATH_SPOOL PATH_TEMPORARY, 0700, env->sc_pw->pw_uid, 0, 1))
d741 1
a741 1
	if (!ckdir(PATH_SPOOL PATH_INCOMING, 0700, env->sc_pw->pw_uid, 0, 1))
d744 1
a744 5
	env->sc_queue = queue_backend_lookup(backend_queue);
	if (env->sc_queue == NULL)
		errx(1, "could not find queue backend \"%s\"", backend_queue);

	if (!env->sc_queue->init(1))
a750 8
	if (env->sc_queue_compress_algo) {
		env->sc_compress = compress_backend_lookup(
		    env->sc_queue_compress_algo);
		if (env->sc_compress == NULL)
			errx(1, "could not find queue compress backend \"%s\"",
			    env->sc_queue_compress_algo);
	}

d758 7
d774 24
d800 1
a800 2
	smtpd_process = PROC_PARENT;
	setproctitle("%s", env->sc_title[smtpd_process]);
d815 8
a822 2
	config_pipes(peers, nitems(peers));
	config_peers(peers, nitems(peers));
a865 10
	env->sc_instances[PROC_CONTROL] = 1;
	env->sc_instances[PROC_LKA] = 1;
	env->sc_instances[PROC_MDA] = 1;
	env->sc_instances[PROC_MFA] = 1;
	env->sc_instances[PROC_MTA] = 1;
	env->sc_instances[PROC_PARENT] = 1;
	env->sc_instances[PROC_QUEUE] = 1;
	env->sc_instances[PROC_SCHEDULER] = 1;
	env->sc_instances[PROC_SMTP] = 1;

d868 8
a875 18
	env->sc_title[PROC_CONTROL] = "control";
	env->sc_title[PROC_LKA] = "lookup";
	env->sc_title[PROC_MDA] = "delivery";
	env->sc_title[PROC_MFA] = "filter";
	env->sc_title[PROC_MTA] = "transfer";
	env->sc_title[PROC_PARENT] = "[priv]";
	env->sc_title[PROC_QUEUE] = "queue";
	env->sc_title[PROC_SCHEDULER] = "scheduler";
	env->sc_title[PROC_SMTP] = "smtp";

	child_add(control(), CHILD_DAEMON, env->sc_title[PROC_CONTROL]);
	child_add(lka(), CHILD_DAEMON, env->sc_title[PROC_LKA]);
	child_add(mda(), CHILD_DAEMON, env->sc_title[PROC_MDA]);
	child_add(mfa(), CHILD_DAEMON, env->sc_title[PROC_MFA]);
	child_add(mta(), CHILD_DAEMON, env->sc_title[PROC_MTA]);
	child_add(queue(), CHILD_DAEMON, env->sc_title[PROC_QUEUE]);
	child_add(scheduler(), CHILD_DAEMON, env->sc_title[PROC_SCHEDULER]);
	child_add(smtp(), CHILD_DAEMON, env->sc_title[PROC_SMTP]);
a894 29
void
imsg_event_add(struct imsgev *iev)
{
	if (iev->handler == NULL) {
		imsg_flush(&iev->ibuf);
		return;
	}

	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev->data);
	event_add(&iev->ev, NULL);
}

void
imsg_compose_event(struct imsgev *iev, uint16_t type, uint32_t peerid,
    pid_t pid, int fd, void *data, uint16_t datalen)
{
	if (imsg_compose(&iev->ibuf, type, peerid, pid, fd, data, datalen)
	    == -1)
		err(1, "%s: imsg_compose(%s)",
		    proc_to_str(smtpd_process),
		    imsg_to_str(type));
	imsg_event_add(iev);
}

d943 1
a943 2
forkmda(struct imsgev *iev, uint32_t id,
    struct deliver *deliver)
a945 1
	struct user_backend	*ub;
a946 1
	struct mta_user u;
d951 2
a952 12
	log_debug("debug: forkmda: to \"%s\" as %s", deliver->to,
	    deliver->user);

	bzero(&u, sizeof (u));
	ub = user_backend_lookup(USER_PWD);
	errno = 0;
	if (! ub->getbyname(&u, deliver->user)) {
		n = snprintf(ebuf, sizeof ebuf, "getpwnam: %s",
		    errno ? strerror(errno) : "no such user");
		imsg_compose_event(iev, IMSG_MDA_DONE, id, 0, -1, ebuf, n + 1);
		return;
	}
d958 2
a959 2
	if (u.uid == 0 && ! db->allow_root) {
		n = snprintf(ebuf, sizeof ebuf, "not allowed to deliver to: %s",
d961 4
a964 1
		imsg_compose_event(iev, IMSG_MDA_DONE, id, 0, -1, ebuf, n + 1);
d969 1
a969 1
	if (seteuid(u.uid) < 0)
d976 4
a979 1
		imsg_compose_event(iev, IMSG_MDA_DONE, id, 0, -1, ebuf, n + 1);
d990 4
a993 1
		imsg_compose_event(iev, IMSG_MDA_DONE, id, 0, -1, ebuf, n + 1);
d1005 3
a1007 1
		imsg_compose_event(iev, IMSG_MDA_DONE, id, 0, -1, ebuf, n + 1);
d1022 3
a1024 2
		imsg_compose_event(iev, IMSG_PARENT_FORK_MDA, id, 0, pipefd[1],
		    NULL, 0);
d1031 1
a1031 1
	if (chdir(u.directory) < 0 && chdir("/") < 0)
d1039 3
a1041 3
	if (setgroups(1, &u.gid) ||
	    setresgid(u.gid, u.gid, u.gid) ||
	    setresuid(u.uid, u.uid, u.uid))
d1079 2
a1080 2
			log_warnx("warn: Could not add offline message %s",
			    d->d_name);
d1238 1
a1238 1
parent_forward_open(char *username)
a1239 2
	struct user_backend *ub;
	struct mta_user u;
d1241 1
a1241 6
	int fd;

	bzero(&u, sizeof (u));
	ub = user_backend_lookup(USER_PWD);
	if (! ub->getbyname(&u, username))
		return -1;
d1244 1
a1244 1
	    u.directory))
d1247 3
a1249 1
	fd = open(pathname, O_RDONLY);
d1252 5
a1256 1
			return -2;
d1261 1
a1261 1
	if (! secure_file(fd, pathname, u.directory, u.uid, 1)) {
d1271 1
a1271 1
imsg_dispatch(int fd, short event, void *p)
a1272 3
	struct imsgev		*iev = p;
	struct imsg		 imsg;
	ssize_t			 n;
d1275 4
a1278 9
	if (event & EV_READ) {
		if ((n = imsg_read(&iev->ibuf)) == -1)
			err(1, "%s: imsg_read", proc_to_str(smtpd_process));
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
d1281 1
a1281 4
	if (event & EV_WRITE) {
		if (msgbuf_write(&iev->ibuf.w) == -1)
			err(1, "%s: msgbuf_write", proc_to_str(smtpd_process));
	}
d1283 2
a1284 5
	for (;;) {
		if ((n = imsg_get(&iev->ibuf, &imsg)) == -1)
			err(1, "%s: imsg_get", proc_to_str(smtpd_process));
		if (n == 0)
			break;
d1286 1
a1286 1
		log_imsg(smtpd_process, iev->proc, &imsg);
d1288 3
a1290 2
		if (profiling || profstat)
			clock_gettime(CLOCK_MONOTONIC, &t0);
d1292 13
a1304 1
		imsg_callback(iev, &imsg);
d1306 6
a1311 26
		if (profiling || profstat) {
			clock_gettime(CLOCK_MONOTONIC, &t1);
			timespecsub(&t1, &t0, &dt);

			log_trace(TRACE_PROFILING, "PROFILE %s %s %s %li.%06li",
			    proc_to_str(smtpd_process),
			    proc_to_str(iev->proc),
			    imsg_to_str(imsg.hdr.type),
			    dt.tv_sec * 1000000 + dt.tv_nsec / 1000000,
			    dt.tv_nsec % 1000000);

			if (profstat) {
				char	key[STAT_KEY_SIZE];

				/* can't profstat control process yet */
				if (smtpd_process == PROC_CONTROL)
					return;

				if (! bsnprintf(key, sizeof key,
					"profiling.imsg.%s.%s.%s",
					imsg_to_str(imsg.hdr.type),
					proc_to_str(iev->proc),
					proc_to_str(smtpd_process)))
					return;
				stat_set(key, stat_timespec(&dt));
			}
a1312 2

		imsg_free(&imsg);
a1313 1
	imsg_event_add(iev);
d1319 4
d1325 2
a1326 2
		    proc_to_str(to),
		    proc_to_str(from),
d1332 2
a1333 2
		    proc_to_str(to),
		    proc_to_str(from),
d1338 26
a1363 1
#define CASE(x) case x : return #x
d1366 1
a1366 1
proc_to_str(int proc)
d1369 18
a1386 9
	CASE(PROC_PARENT);
	CASE(PROC_SMTP);
	CASE(PROC_MFA);
	CASE(PROC_LKA);
	CASE(PROC_QUEUE);
	CASE(PROC_MDA);
	CASE(PROC_MTA);
	CASE(PROC_CONTROL);
	CASE(PROC_SCHEDULER);
d1388 1
a1388 1
		return "PROC_???";
d1392 2
d1405 16
d1424 2
a1425 2
	CASE(IMSG_CONF_MAP);
	CASE(IMSG_CONF_MAP_CONTENT);
d1428 4
d1435 2
a1436 3
	CASE(IMSG_LKA_UPDATE_MAP);
	CASE(IMSG_LKA_MAIL);
	CASE(IMSG_LKA_RCPT);
d1438 17
a1454 2
	CASE(IMSG_LKA_RULEMATCH);
	CASE(IMSG_MDA_SESS_NEW);
d1457 16
a1472 8
	CASE(IMSG_MFA_CONNECT);
	CASE(IMSG_MFA_HELO);
	CASE(IMSG_MFA_MAIL);
	CASE(IMSG_MFA_RCPT);
	CASE(IMSG_MFA_DATALINE);
	CASE(IMSG_MFA_QUIT);
	CASE(IMSG_MFA_CLOSE);
	CASE(IMSG_MFA_RSET);
a1478 11
	CASE(IMSG_QUEUE_TEMPFAIL);
	CASE(IMSG_QUEUE_PAUSE_MDA);
	CASE(IMSG_QUEUE_PAUSE_MTA);
	CASE(IMSG_QUEUE_RESUME_MDA);
	CASE(IMSG_QUEUE_RESUME_MTA);

	CASE(IMSG_QUEUE_DELIVERY_OK);
	CASE(IMSG_QUEUE_DELIVERY_TEMPFAIL);
	CASE(IMSG_QUEUE_DELIVERY_PERMFAIL);
	CASE(IMSG_QUEUE_DELIVERY_LOOP);

d1483 1
a1483 9

	CASE(IMSG_SCHEDULER_MESSAGES);
	CASE(IMSG_SCHEDULER_ENVELOPES);
	CASE(IMSG_SCHEDULER_REMOVE);
	CASE(IMSG_SCHEDULER_SCHEDULE);

	CASE(IMSG_BATCH_CREATE);
	CASE(IMSG_BATCH_APPEND);
	CASE(IMSG_BATCH_CLOSE);
a1487 2

	CASE(IMSG_PARENT_AUTHENTICATE);
d1490 1
a1490 3
	CASE(IMSG_SMTP_ENQUEUE);
	CASE(IMSG_SMTP_PAUSE);
	CASE(IMSG_SMTP_RESUME);
d1494 1
d1496 1
a1496 1
	CASE(IMSG_DNS_PTR);
d1505 1
d1511 72
@


1.182
log
@Allow "smtpctl show queue" to run in "online" mode if the smtpd server
is running.  The scheduler sends the runtime state of each envelope to
the queue process which loads the envelope, fills the runtime bits and
sends the envelope back to the client. Iteration over the envelope set
happens in small chunks to make the request interruptible and to allow
the server to keep doing its job in the meantime.

Adpat "smtpctl schedule-all" to schedule the messages one by one using
the same iteration mechanism.

Document "smtpctl monitor" and "smtpctl show queue".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.181 2012/11/12 14:58:53 eric Exp $	*/
d177 2
a178 1
				log_debug("debug: smptd: kill request: proc not found");
d202 18
a219 12
			imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, imsg->data, sizeof(int));
			imsg_compose_event(env->sc_ievs[PROC_MDA], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, imsg->data, sizeof(int));
			imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, imsg->data, sizeof(int));
			imsg_compose_event(env->sc_ievs[PROC_MTA], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, imsg->data, sizeof(int));
			imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, imsg->data, sizeof(int));
			imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, imsg->data, sizeof(int));
d306 2
a307 1
		if (setsockopt(l->fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
d356 2
a357 2
	
	log_debug("debug: parent_send_config_ruleset: reloading rules and maps");
d371 4
a374 4
			TAILQ_FOREACH(mapel, &m->m_contents, me_entry) {
			imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_MAP_CONTENT,
			    0, 0, -1, mapel, sizeof(*mapel));
			}
d376 1
a376 1
	
d380 4
a383 2
			imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_RULE_SOURCE,
			    0, 0, -1, &r->r_sources->m_name, sizeof(r->r_sources->m_name));
d386 1
a386 1
	
d461 4
a464 2
					log_warnx("warn: smtpd: couldn't enqueue offline "
					    "message %s; smtpctl %s", child->path, cause);
d531 2
a532 1
				log_warnx("warn: invalid backend specifier %s", optarg);
d540 2
a541 1
				log_warnx("warn: could not parse macro definition %s",
d575 2
a576 1
				log_warnx("warn: unknown trace flag \"%s\"", optarg);
d625 1
a625 1
	if (ckdir(PATH_SPOOL, 0711, 0, 0, 1) == 0)
d627 1
a627 1
	if (ckdir(PATH_SPOOL PATH_OFFLINE, 01777, 0, 0, 1) == 0)
d629 1
a629 1
	if (ckdir(PATH_SPOOL PATH_PURGE, 0700, env->sc_pw->pw_uid, 0, 1) == 0)
d631 1
a631 1
	if (ckdir(PATH_SPOOL PATH_TEMPORARY, 0700, env->sc_pw->pw_uid, 0, 1) == 0)
d636 1
a636 1
	if (ckdir(PATH_SPOOL PATH_INCOMING, 0700, env->sc_pw->pw_uid, 0, 1) == 0)
d651 2
a652 2
		env->sc_compress = 
			compress_backend_lookup(env->sc_queue_compress_algo);
d807 2
a808 1
	if (imsg_compose(&iev->ibuf, type, peerid, pid, fd, data, datalen) == -1)
a814 1

d835 1
a835 1
			switch(purge_pid = fork()) {
d874 2
a875 1
	log_debug("debug: forkmda: to \"%s\" as %s", deliver->to, deliver->user);
d995 1
a995 1
	while((d = readdir(dir)) != NULL) {
d1000 2
a1001 1
			log_warnx("warn: smtpd: could not add offline message %s", d->d_name);
a1068 1
		
d1149 1
a1149 1
	while(offline_running < OFFLINE_QUEUEMAX) {
d1171 2
a1172 1
	if (! bsnprintf(pathname, sizeof (pathname), "%s/.forward", u.directory))
d1305 1
a1305 1
	switch(type) {
d1390 1
a1390 1
  	CASE(IMSG_STATS_GET);
@


1.181
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.179 2012/10/17 16:39:49 eric Exp $	*/
d1342 2
@


1.180
log
@Consistency and robustness improvements in mda:

- Introduce a mda_getlastline function(); improve the code to avoid
  useless allocations and string formatting; make it return the last
  line with content (skip trailing empty lines if found).
- Add a mechanism by which the mda can request the parent to abort a
  local delivery by killing the process.
- Use ioev/iobuf for draining data to the delivery process.
- Make sure to catch all transient errors and make them result in a
  tempfail rather than calling fatal().
- Make sure that the envelope status is properly set for all failures.
- Stop using SMTP response codes; it makes no sense in this context.

ok gilles@@
@
text
@d177 1
a177 1
				log_debug("smptd: kill request: proc not found");
d188 1
a188 1
			log_debug("smptd: kill requested for %u: %s",
d250 1
a250 1
	log_warnx("parent terminating");
d271 1
a271 1
	log_debug("parent_send_config: configuring smtp");
d317 1
a317 1
	log_debug("parent_send_config_client_certs: configuring smtp");
d349 1
a349 1
	log_debug("parent_send_config_ruleset: reloading rules and maps");
d425 1
a425 1
					log_warnx("lost child: %s %s",
d451 1
a451 1
					log_warnx("smtpd: couldn't enqueue offline "
d519 1
a519 1
				log_warnx("invalid backend specifier %s", optarg);
d527 1
a527 1
				log_warnx("could not parse macro definition %s",
d561 1
a561 1
				log_warnx("unknown trace flag \"%s\"", optarg);
d650 4
a653 4
	log_debug("using \"%s\" queue backend", backend_queue);
	log_debug("using \"%s\" scheduler backend", backend_scheduler);
	log_debug("using \"%s\" stat backend", backend_stat);
	log_info("startup%s", (debug > 1)?" [debug mode]":"");
d817 1
a817 1
			log_warn("purge_task: opendir");
d822 1
a822 1
				log_warn("purge_task: fork");
d859 1
a859 1
	log_debug("forkmda: to \"%s\" as %s", deliver->to, deliver->user);
d974 1
a974 1
		log_debug("smtpd: scanning offline queue...");
d984 1
a984 1
			log_warnx("smtpd: could not add offline message %s", d->d_name);
d997 1
a997 1
	log_debug("smtpd: offline scanning done");
d1011 1
a1011 1
		log_warnx("smtpd: path name too long");
d1016 1
a1016 1
		log_warn("smtpd: strdup");
d1020 1
a1020 1
	log_debug("smtpd: enqueueing offline message %s", path);
d1023 1
a1023 1
		log_warn("smtpd: fork");
d1037 1
a1037 1
			log_warn("smtpd: lstat: %s", path);
d1042 1
a1042 1
			log_warn("smtpd: chflags: %s", path);
d1048 1
a1048 1
			log_warnx("smtpd: getpwuid for uid %d failed",
d1055 1
a1055 1
			log_warnx("smtpd: file %s (uid %d) not regular",
d1162 1
a1162 1
		log_warn("smtpd: parent_forward_open: %s", pathname);
d1167 1
a1167 1
		log_warnx("smtpd: %s: unsecure file", pathname);
d1369 1
@


1.179
log
@Document the -P option.  While there, remove reference to -T, it's incomplete,
subject to changes and internal.

feedback from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.178 2012/10/15 18:32:25 eric Exp $	*/
d83 1
d123 4
a126 1
	int			 fd;
d168 24
d435 9
d859 1
a859 1
	log_debug("forkmda: to %s as %s", deliver->to, deliver->user);
d1351 1
@


1.178
log
@implement and document "smtpctl stop"

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.177 2012/10/15 17:54:28 eric Exp $	*/
d202 1
a202 1
	    "[-f file] [-T trace]\n", __progname);
@


1.177
log
@use shorter names for process titles.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.176 2012/10/14 11:58:23 gilles Exp $	*/
d185 4
@


1.176
log
@introduce map_file.c which will deprecate map_stdio.c

The idea is to have a file-backed map but to have smtpd(8) cache the maps
so that it cannot be partially read if edited while mail is received. The
file is read and converted to a static map (map_static.c), changes aren't
visible to smtpd until an explicit: smtpctl update map  which reads file,
builds a new static map and invalidates the former.

partial-read issue discussed with beck@@ and halex@@
idea to convert internally to a static map by eric@@

diff ok eric@@ and chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.175 2012/10/11 21:55:16 gilles Exp $	*/
d694 4
a697 4
	env->sc_title[PROC_LKA] = "lookup agent";
	env->sc_title[PROC_MDA] = "mail delivery agent";
	env->sc_title[PROC_MFA] = "mail filter agent";
	env->sc_title[PROC_MTA] = "mail transfer agent";
d701 1
a701 1
	env->sc_title[PROC_SMTP] = "smtp server";
@


1.175
log
@- if argc / argv not empty after getopt() loop, display usage
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.174 2012/10/04 18:25:39 eric Exp $	*/
d1263 1
@


1.174
log
@delay the call to log_debug() for displaying the backends used until
the "real" debug mode is set.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.173 2012/10/03 17:58:03 gilles Exp $	*/
d543 3
@


1.173
log
@disallow root deliveries for "deliver to filename" and "deliver to mda"
rules, we only allow them for mbox and maildir though users should really
create a root alias ...

discussed with eric@@ and chl@@, ok both
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.172 2012/09/28 17:28:30 eric Exp $	*/
a579 4
	log_debug("using \"%s\" queue backend", backend_queue);
	log_debug("using \"%s\" scheduler backend", backend_scheduler);
	log_debug("using \"%s\" stat backend", backend_stat);

d606 3
@


1.172
log
@some smtpd.{c,h} cleanups:

- move struct child to smtpd.c
- make it use a tree keyed on the pid
- change child_add to take the title directly as a const char *
- remove useless child_lookup() and child_del()
- remove CHILD_INVALID

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.171 2012/09/16 16:54:55 chl Exp $	*/
d831 7
@


1.171
log
@now that log_imsg() is only used in smtpd.c, set it as static.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.170 2012/09/16 16:43:29 chl Exp $	*/
d60 1
a60 3
static struct child *child_lookup(pid_t);
static struct child *child_add(pid_t, int, int);
static void child_del(pid_t);
d70 14
d114 2
d205 1
d209 2
a210 1
	SPLAY_FOREACH(child, childtree, &env->children)
d385 1
a385 1
			child = child_lookup(pid);
d394 1
a394 1
					    env->sc_title[child->title], cause);
d421 1
a421 2

			child_del(child->pid);
d662 1
a662 1
	SPLAY_INIT(&env->children);
d701 8
a708 8
	child_add(control(), CHILD_DAEMON, PROC_CONTROL);
	child_add(lka(), CHILD_DAEMON, PROC_LKA);
	child_add(mda(), CHILD_DAEMON, PROC_MDA);
	child_add(mfa(), CHILD_DAEMON, PROC_MFA);
	child_add(mta(), CHILD_DAEMON, PROC_MTA);
	child_add(queue(), CHILD_DAEMON, PROC_QUEUE);
	child_add(scheduler(), CHILD_DAEMON, PROC_SCHEDULER);
	child_add(smtp(), CHILD_DAEMON, PROC_SMTP);
d712 1
a712 1
child_add(pid_t pid, int type, int title)
d723 1
a723 2
	if (SPLAY_INSERT(childtree, &env->children, child) != NULL)
		fatalx("child_add: double insert");
a727 23
static void
child_del(pid_t pid)
{
	struct child	*p;

	p = child_lookup(pid);
	if (p == NULL)
		fatalx("smtpd: child_del: unknown child");

	if (SPLAY_REMOVE(childtree, &env->children, p) == NULL)
		fatalx("smtpd: child_del: tree remove failed");
	free(p);
}

static struct child *
child_lookup(pid_t pid)
{
	struct child	 key;

	key.pid = pid;
	return SPLAY_FIND(childtree, &env->children, &key);
}

d874 1
a874 1
		child = child_add(pid, CHILD_MDA, -1);
d1051 1
a1051 1
	child = child_add(pid, CHILD_ENQUEUE_OFFLINE, -1);
a1124 12
int
child_cmp(struct child *c1, struct child *c2)
{
	if (c1->pid < c2->pid)
		return (-1);

	if (c1->pid > c2->pid)
		return (1);

	return (0);
}

a1193 2

SPLAY_GENERATE(childtree, child, entry, child_cmp);
@


1.170
log
@Factorize log_imsg() in imsg_dispatch() instead of in each imsg_callback()'s
and put it out of profiling, so it's not accounted.

While there, for PROC_PARENT:
- set smtpd_process for PROC_PARENT
- use setproctitle() like other processes

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.169 2012/09/11 12:47:36 eric Exp $	*/
d70 1
d1218 1
a1218 1
void
@


1.169
log
@log the process name and place when calling fatal().

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.168 2012/09/01 16:09:14 gilles Exp $	*/
a108 2
	log_imsg(PROC_PARENT, iev->proc, imsg);

d602 3
d680 1
a692 2

	setproctitle("[priv]");
d1174 2
@


1.168
log
@- remove crypto_backend
- remove support for encrypted queue, it will be reintroduced later after
  pouring more thinking into it

if you had it enabled, flush your queue before updating
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.167 2012/08/29 16:26:17 gilles Exp $	*/
d250 1
a250 1
			fatal("socket");
d253 1
a253 1
			fatal("setsockopt");
d255 1
a255 1
			fatal("bind");
d365 1
a365 1
				fatalx("unexpected cause of SIGCHLD");
d404 1
a404 1
				fatalx("unexpected child type");
d416 1
a416 1
		fatalx("unexpected signal");
d637 1
a637 1
		fatal("event_dispatch");
d701 1
a701 1
		fatal(NULL);
d720 1
a720 1
		fatalx("child_del: unknown child");
d723 1
a723 1
		fatalx("child_del: tree remove failed");
d758 3
a760 1
		fatal("imsg_compose_event");
d842 1
a842 1
		fatal("cannot lower privileges");
d847 1
a847 1
			fatal("forkmda: cannot restore privileges");
d858 1
a858 1
			fatal("forkmda: cannot restore privileges");
d870 1
a870 1
			fatal("forkmda: cannot restore privileges");
d881 1
a881 1
			fatal("forkmda: cannot restore privileges");
d1114 1
a1114 1
		fatal("snprintf");
d1120 1
a1120 1
		log_warn("parent_forward_open: %s", pathname);
d1125 1
a1125 1
		log_warnx("%s: unsecure file", pathname);
d1155 1
a1155 1
			fatal("imsg_read");
d1166 1
a1166 1
			fatal("msgbuf_write");
d1171 1
a1171 1
			fatal("imsg_get");
@


1.167
log
@Introduce the crypto_backend API and provide support for... encrypted queue
using the new API. By default, OpenSMTPD does not provide queue encryption,
but it can be enabled with "queue encryption [args]" and will transparently
encrypt/decrypt envelopes/messages as they hit the queue.

By default, it will use Blowfish in CBC mode with a different random IV for
each envelope and message. User provided key is expanded using sha256 but a
different cipher and digest may be specified in smtpd.conf

Queue encryption is compatible with compression and if both options are set
it will do them in correct order and transparently.

tested by chl@@, a few users and myself
ok chl@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.166 2012/08/26 16:35:17 gilles Exp $	*/
a533 18

	if (env->sc_queue_crypto_key) {
		if (! crypto_setup(env->sc_queue_crypto_cipher,
			env->sc_queue_crypto_digest,
			env->sc_queue_crypto_key))
			errx(1, "crypto: setup failed");
		bzero(env->sc_queue_crypto_cipher, strlen(env->sc_queue_crypto_cipher));
		bzero(env->sc_queue_crypto_digest, strlen(env->sc_queue_crypto_digest));
		bzero(env->sc_queue_crypto_key, strlen(env->sc_queue_crypto_key));
		free(env->sc_queue_crypto_cipher);
		free(env->sc_queue_crypto_digest);
		free(env->sc_queue_crypto_key);

		env->sc_queue_crypto_cipher = NULL;
		env->sc_queue_crypto_digest = NULL;
		env->sc_queue_crypto_key = NULL;
	}

@


1.166
log
@correctly check compress_backend_lookup() to avoid a NULL deref
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.165 2012/08/26 11:52:48 gilles Exp $	*/
d530 2
d535 18
a554 1

@


1.165
log
@- define ZLIB_BUFFER_SIZE instead of hardcoding 8192
- check gzdopen() failure
- call gzclose() whenever a failure occurs after gzdopen()
- simplify slightly some checks in compress/uncompress
- create PATH_TEMPORARY in /var/spool/smtpd, chmod 700, owned by _smtpd
- compress_zlib should use PATH_TEMPORARY instread of /tmp as we're
	chrooted and this will otherwise lead to a fatal()

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.164 2012/08/25 23:35:09 chl Exp $	*/
d583 1
a583 1
		if (env->sc_queue == NULL)
d585 1
a585 1
			     env->sc_queue_compress_algo);
@


1.164
log
@Add compress_backend, allowing compression of messages and envelopes in the queue.
To use it, just add "queue compress" in smtpd.conf. For now, only zlib is used.

lots of feedback from eric@@ and gilles@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.163 2012/08/25 15:39:11 gilles Exp $	*/
d556 2
@


1.163
log
@- offline enqueue does not need to use the user_backend API, it relies on
	system users ... use getpwuid() instead of ub->getbyuid()
- since that was the only caller, get rid of user_backend->getbyuid()

this is the first step towards removing the user_backend API and making
user lookups available through the maps API (yes, virtual user support ;)

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.162 2012/08/25 11:38:18 gilles Exp $	*/
d577 8
@


1.162
log
@- introduce TRACE_PROFILING
- when smtpd starts with -T profiling it will log_trace() some prof. info
- when smtpd starts with -T profstat, it will push them to stats API with
	type STAT_TIMESPEC under key profiling.imsg.*

with this diff we can get live profiling of events with a very minimal
overhead :-)

ok chl@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.161 2012/08/21 13:13:17 eric Exp $	*/
a949 2
	struct user_backend *ub;
	struct mta_user	 u;
d953 1
d991 2
a992 4
		ub = user_backend_lookup(USER_PWD);
		bzero(&u, sizeof (u));
		errno = 0;
		if (! ub->getbyuid(&u, sb.st_uid)) {
d997 1
d1005 3
a1007 3
		if (setgroups(1, &u.gid) ||
		    setresgid(u.gid, u.gid, u.gid) ||
		    setresuid(u.uid, u.uid, u.uid) ||
d1014 1
a1014 1
		if (chdir(u.directory) == -1 && chdir("/") == -1)
@


1.161
log
@Re-enable loop detection, but in mta and mda this time.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.160 2012/08/19 14:16:58 chl Exp $	*/
d98 3
d497 6
d1140 1
d1163 4
d1168 29
@


1.160
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.159 2012/08/19 08:47:41 chl Exp $	*/
d1250 1
@


1.159
log
@add missing IMSG_* in imsg_to_str()

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.158 2012/08/18 18:18:23 gilles Exp $	*/
d57 1
a57 1
static void forkmda(struct imsgev *, u_int32_t, struct deliver *);
d734 2
a735 2
imsg_compose_event(struct imsgev *iev, u_int16_t type, u_int32_t peerid,
    pid_t pid, int fd, void *data, u_int16_t datalen)
d791 1
a791 1
forkmda(struct imsgev *iev, u_int32_t id,
@


1.158
log
@- introduce stat_backend, an API for pluggable statistic backends
  > statistics are no longer static structures in shared memory
  > statistics are only set, smtpd never uses them in its logic
  > each statistic is a key/value where key can be any (dynamic) string
- convert all uses of the former API to use the new one
- implement stat_ramstat that keeps non-persistent stats in ram structure

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.157 2012/08/09 09:48:02 eric Exp $	*/
a1268 1
	CASE(IMSG_STATS);
d1277 7
@


1.157
log
@Improve the message flows to completely isolate operations on the
queue backend within the queue process.

The scheduler sends envelope ids to the queue process which loads
the envelope and forward the request to the agent responsible for
the delivery.  The result is sent by the agent to the queue which
updates the storage before notifying the scheduler.

Bounces are created and enqueued (from the client side) by the
queue process, rather than the scheduler.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.156 2012/08/08 17:28:36 eric Exp $	*/
d96 1
d458 2
d492 2
d556 1
d565 4
d580 1
a580 9

	env->stats = mmap(NULL, sizeof(struct stats), PROT_WRITE|PROT_READ,
	    MAP_ANON|MAP_SHARED, -1, (off_t)0);
	if (env->stats == MAP_FAILED)
		fatal("mmap");
	bzero(env->stats, sizeof(struct stats));
	stat_init(env->stats->counters, STATS_MAX);

	env->stats->parent.start = time(NULL);
@


1.156
log
@log received fd in log_imsg() if any

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.155 2012/07/09 17:57:54 gilles Exp $	*/
a1250 1
	CASE(IMSG_QUEUE_SCHEDULE);
d1252 1
a1259 1
	CASE(IMSG_BATCH_DONE);
@


1.155
log
@- introduce log_trace(TRACE_SCHEDULER, ...)
- simplify a tiny tiny bit the scheduler loop
- no functional change (yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.154 2012/07/09 09:57:53 gilles Exp $	*/
d1162 13
a1174 5
	log_trace(TRACE_IMSG, "imsg: %s <- %s: %s (len=%zu)",
	    proc_to_str(to),
	    proc_to_str(from),
	    imsg_to_str(imsg->hdr.type),
	    imsg->hdr.len - IMSG_HEADER_SIZE);
@


1.154
log
@- runner is the terminology we used back when we had runqueues, we no
  longer have them and runner is actually a scheduler so rename.
- introduce scheduler_backend which does the same to scheduler than
  queue_backend does to queue and map_backend does to maps
- remove all occurences of RUNNER and runner, replace them with SCHEDULER
  and scheduler

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.153 2012/07/08 18:13:08 chl Exp $	*/
d487 2
@


1.153
log
@remove enum queue_kind from queue_fsqueue.c.
incoming messages are now always stored in /incoming, whatever the queue_backend is.
remove QOP_FD_RW and fsqueue_message_fd_rw().
while there check return value of generated paths before calling rmtree()

with advice from gilles@@ and eric@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.152 2012/07/02 17:00:05 eric Exp $	*/
d645 1
a645 1
	env->sc_instances[PROC_RUNNER] = 1;
d656 1
a656 1
	env->sc_title[PROC_RUNNER] = "runner";
d665 1
a665 1
	child_add(runner(), CHILD_DAEMON, PROC_RUNNER);
d1181 1
a1181 1
	CASE(PROC_RUNNER);
d1244 2
a1245 2
	CASE(IMSG_RUNNER_REMOVE);
	CASE(IMSG_RUNNER_SCHEDULE);
@


1.152
log
@Lookup queue and scheduler backends by name, rather than enum.
Add a command-line option to specify the backend to use at runtime.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.151 2012/06/01 14:55:09 eric Exp $	*/
d541 5
@


1.151
log
@allow to pause some subsystems at startup.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.150 2012/01/28 16:52:24 gilles Exp $	*/
d94 3
d450 1
a450 1
	while ((c = getopt(argc, argv, "dD:nP:f:T:v")) != -1) {
d452 8
d542 4
a545 1
	env->sc_queue = queue_backend_lookup(QT_FS);
d547 1
a547 1
		errx(1, "could not find queue backend");
@


1.150
log
@smtpd no longer needs to tell us that it forks a purge process ever few
seconds, we've seen it works and it has become irritating :p
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.149 2012/01/24 12:20:18 eric Exp $	*/
d418 1
a418 1
	int		 opts;
d438 1
d447 1
a447 1
	while ((c = getopt(argc, argv, "dD:nf:T:v")) != -1) {
d481 8
d514 2
@


1.149
log
@Add a parameter to the queue backend init() call to specify wether the
call is issued by smtpd or smtpctl.  In the latter case, only perform
sanity checks and do not touch directories.  A running server no
longer lose its "incoming/" directory each time smtpctl is called...

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.148 2012/01/18 13:41:54 chl Exp $	*/
a728 1
			log_debug("smtpd: forking purge process");
@


1.148
log
@Add new filters callbacks for:
- network events (CONNECT/CLOSE)
- commands (QUIT/RSET)

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.147 2012/01/13 14:01:58 eric Exp $	*/
d524 1
a524 1
	if (!env->sc_queue->init())
@


1.147
log
@Stop using envelope->status to report delivery outcome to the
runner/queue.  Instead, replace IMSG_QUEUE_MESSAGE_UPDATE with three
messages:

- IMSG_QUEUE_DELIVERY_OK
- IMSG_QUEUE_DELIVERY_TEMPFAIL
- IMSG_QUEUE_DELIVERY_PERMFAIL

1) it's less confusing as status is also used by smtp
2) it's easier to see what happens just looking at imsg traces
3) it makes the code path generally easier to follow
4) it's safer because it enforces clear semantics and intent, whereas
   the status field is loosely defined and could carry bogus values.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.146 2012/01/12 18:06:18 eric Exp $	*/
d1186 1
d1191 3
@


1.146
log
@Remove dead code for config reloading for now. It is not functionnal
and confusing.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.145 2012/01/12 12:52:11 eric Exp $	*/
d1202 4
a1205 1
	CASE(IMSG_QUEUE_MESSAGE_UPDATE);
@


1.145
log
@use absolute path as fts may chdir() during traversal.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.144 2012/01/11 17:46:36 eric Exp $	*/
d1178 1
a1178 1
	CASE(IMSG_CONF_RELOAD);
@


1.144
log
@Simplify runner/queue by getting rid of Q_PURGE.  Instead, let smtpd
periodically clear the purge/ directory.  At init time, the fsqueue
backend simply moves the existing incoming/ dir in purge/ to discard
aborted sessions.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.143 2011/12/13 23:55:00 gilles Exp $	*/
d745 1
a745 1
				rmtree(".", 1);
@


1.143
log
@*finally* make use of certificate authority file if available !

bits from relayd, ok chl@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.142 2011/12/13 22:04:35 eric Exp $	*/
d69 3
d85 3
a345 4
			child = child_lookup(pid);
			if (child == NULL)
				fatalx("unexpected SIGCHLD");

d360 7
d401 1
d517 2
d576 6
d706 49
@


1.142
log
@split user_backend.c into user.c and user_pwd.c to be consistent with the
backend scheme. Also rename USER_GETPWNAM to USER_PWD.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.141 2011/12/13 21:44:47 gilles Exp $	*/
d208 1
a208 1
	struct iovec		 iov[4];
d227 2
d255 1
a255 1
	struct iovec		 iov[4];
a270 2
		iov[3].iov_base = s->ssl_dhparams;
		iov[3].iov_len = s->ssl_dhparams_len;
@


1.141
log
@- introduce delivery backend API (delivery.c)
- move each delivery method to it's own delivery backend
- simplify smtpd.c accordingly
- rename A_EXT -> A_MDA since that's what we really do

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.140 2011/12/12 17:20:36 eric Exp $	*/
d705 1
a705 1
	ub = user_backend_lookup(USER_GETPWNAM);
d883 1
a883 1
		ub = user_backend_lookup(USER_GETPWNAM);
d989 1
a989 1
	ub = user_backend_lookup(USER_GETPWNAM);
@


1.140
log
@add a session_enter_state() function to change the state of an smtp
session and allow those state changes to be traced (add traces flags
for upcoming changes while there).

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.139 2011/12/08 17:00:28 todd Exp $	*/
d695 2
a696 1
	struct user_backend *ub;
d714 4
d796 1
a796 98
	if (deliver->mode == A_EXT) {
		char	*environ_new[2];

		environ_new[0] = "PATH=" _PATH_DEFPATH;
		environ_new[1] = (char *)NULL;
		environ = environ_new;
		execle("/bin/sh", "/bin/sh", "-c", deliver->to, (char *)NULL,
		    environ_new);
		error("execle");
	}

	if (deliver->mode == A_MAILDIR) {
		char	 tmp[PATH_MAX], new[PATH_MAX];
		int	 ch, fd;
		FILE	*fp;

#define error2(m) { n = errno; unlink(tmp); errno = n; error(m); }
		setproctitle("maildir delivery");
		if (mkdir(deliver->to, 0700) < 0 && errno != EEXIST)
			error("cannot mkdir maildir");
		if (chdir(deliver->to) < 0)
			error("cannot cd to maildir");
		if (mkdir("cur", 0700) < 0 && errno != EEXIST)
			error("mkdir cur failed");
		if (mkdir("tmp", 0700) < 0 && errno != EEXIST)
			error("mkdir tmp failed");
		if (mkdir("new", 0700) < 0 && errno != EEXIST)
			error("mkdir new failed");
		snprintf(tmp, sizeof tmp, "tmp/%lld.%d.%s",
		    (long long int) time(NULL),
		    getpid(), env->sc_hostname);
		fd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0600);
		if (fd < 0)
			error("cannot open tmp file");
		fp = fdopen(fd, "w");
		if (fp == NULL)
			error2("fdopen");
		while ((ch = getc(stdin)) != EOF)
			if (putc(ch, fp) == EOF)
				break;
		if (ferror(stdin))
			error2("read error");
		if (fflush(fp) == EOF || ferror(fp))
			error2("write error");
		if (fsync(fd) < 0)
			error2("fsync");
		if (fclose(fp) == EOF)
			error2("fclose");
		snprintf(new, sizeof new, "new/%s", tmp + 4);
		if (rename(tmp, new) < 0)
			error2("cannot rename tmp->new");
		_exit(0);
	}
#undef error2

	if (deliver->mode == A_FILENAME) {
		struct stat 	 sb;
		time_t		 now;
		size_t		 len;
		int		 fd;
		FILE		*fp;
		char		*ln;

#define error2(m) { n = errno; ftruncate(fd, sb.st_size); errno = n; error(m); }
		setproctitle("file delivery");
		fd = open(deliver->to, O_CREAT | O_APPEND | O_WRONLY, 0600);
		if (fd < 0)
			error("open");
		if (fstat(fd, &sb) < 0)
			error("fstat");
		if (S_ISREG(sb.st_mode) && flock(fd, LOCK_EX) < 0)
			error("flock");
		fp = fdopen(fd, "a");
		if (fp == NULL)
			error("fdopen");
		time(&now);
		fprintf(fp, "From %s@@%s %s", SMTPD_USER, env->sc_hostname,
		    ctime(&now));
		while ((ln = fgetln(stdin, &len)) != NULL) {
			if (ln[len - 1] == '\n')
				len--;
			if (len >= 5 && memcmp(ln, "From ", 5) == 0)
				putc('>', fp);
			fprintf(fp, "%.*s\n", (int)len, ln);
			if (ferror(fp))
				break;
		}
		if (ferror(stdin))
			error2("read error");
		putc('\n', fp);
		if (fflush(fp) == EOF || ferror(fp))
			error2("write error");
		if (fsync(fd) < 0)
			error2("fsync");
		if (fclose(fp) == EOF)
			error2("fclose");
		_exit(0);
	}
a800 1
#undef error2
@


1.139
log
@rename struct user to struct mta_user to avoid namespace conflict elsewhere
ok chl@@ & gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.138 2011/11/16 11:18:54 eric Exp $	*/
d457 10
@


1.138
log
@Do not unlink an offline message until it has been correctly enqueued.
While there, simplify the offline_enqueue() function by doing all the
sanity checks in the forked process,  and remove all fatal(): on error,
the offline message is left untouched in the directory.  Also, get rid
of the path_starts_with() check since all paths to offline messages are
now constructed internally.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.137 2011/11/14 19:23:41 chl Exp $	*/
d686 1
a686 1
	struct user u;
d925 1
a925 1
	struct user	 u;
d1067 1
a1067 1
	struct user u;
@


1.137
log
@when receiving an unexpected imsg, print its name.

with help and ideas from eric@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.136 2011/11/14 11:53:10 eric Exp $	*/
a58 1
static int path_starts_with(char *, char *);
d380 4
a383 1
					    "message; smtpctl %s", cause);
d902 4
a905 1
		offline_add(d->d_name);
d923 1
a923 1
	char			path[MAXPATHLEN];
d928 1
d930 4
a933 3
	strlcpy(path, PATH_SPOOL PATH_OFFLINE "/", sizeof path);
	if (strlcat(path, name, sizeof path) >= sizeof path)
		fatalx("smtpd: path name too long");
d935 4
a938 2
	if (! path_starts_with(path, PATH_SPOOL PATH_OFFLINE))
		fatalx("smtpd: path outside offline dir");
d942 4
a945 6
	if (lstat(path, &sb) == -1) {
		if (errno == ENOENT) {
			log_warn("smtpd: lstat: %s", path);
			return (0);
		}
		fatal("lstat");
a947 30
	if (chflags(path, 0) == -1) {
		if (errno == ENOENT) {
			log_warn("smtpd: chflags: %s", path);
			return (0);
		}
		fatal("chflags");
	}

	ub = user_backend_lookup(USER_GETPWNAM);
	bzero(&u, sizeof (u));
	errno = 0;
	if (! ub->getbyuid(&u, sb.st_uid)) {
		log_warn("smtpd: getpwuid for uid %d failed",
		    sb.st_uid);
		unlink(path);
		return (0);
	}

	if (! S_ISREG(sb.st_mode)) {
		log_warnx("smtpd: file %s (uid %d) not regular, removing", path, sb.st_uid);
		if (S_ISDIR(sb.st_mode))
			rmdir(path);
		else
			unlink(path);
		return (0);
	}

	if ((pid = fork()) == -1)
		fatal("offline_enqueue: fork");

d956 25
d984 1
a984 2
		    closefrom(STDERR_FILENO + 1) == -1) {
			unlink(path);
a985 1
		}
d987 1
a987 2
		if ((fp = fopen(path, "r")) == NULL) {
			unlink(path);
a988 2
		}
		unlink(path);
d1022 2
a1023 1
	child_add(pid, CHILD_ENQUEUE_OFFLINE, -1);
d1025 1
a1025 1
	return (1);
d1044 1
a1044 1
	return (1);
a1093 12
}

int
path_starts_with(char *file, char *prefix)
{
	char	 rprefix[MAXPATHLEN];
	char	 rfile[MAXPATHLEN];

	if (realpath(file, rfile) == NULL || realpath(prefix, rprefix) == NULL)
		return (-1);

	return (strncmp(rfile, rprefix, strlen(rprefix)) == 0);
@


1.136
log
@The spool and offline directories are backend-independent, so they
must be created early by smtpd, rather than in fsqueue.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.135 2011/11/07 11:14:10 eric Exp $	*/
d164 1
a164 1
	fatalx("parent_imsg: unexpected imsg");
a1157 3
const char * proc_to_str(int);
const char * imsg_to_str(int);

d1191 2
d1262 3
a1264 1
		return "IMSG_???";
@


1.135
log
@Let the smtpd process handle the enqueueing of offline messages at
startup, rather than playing tricks with the runner. This will allow
further simplifications and improvements in the runner/queue.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.134 2011/10/26 20:47:31 gilles Exp $	*/
d491 5
d501 1
a501 1
		errx(1, "invalid directory permissions");
@


1.134
log
@- fix smtpctl pause/resume so the ramqueue scheduling is done correctly
- rename IMSG and smtpctl pause/resume parameters
- update man page

tested by me, ok chl@@, eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.133 2011/10/22 06:42:44 jmc Exp $	*/
d31 1
a57 1
static int parent_enqueue_offline(char *);
d65 4
a68 2
static int	queueing_add(char *);
static void	queueing_done(void);
d70 2
a71 2
struct queueing {
	TAILQ_ENTRY(queueing)	 entry;
d75 8
a82 3
#define QUEUEING_MAX 5
static size_t			queueing_running = 0;
TAILQ_HEAD(, queueing)		queueing_q;
a88 2
int __b64_pton(char const *, unsigned char *, size_t);

a133 11
	if (iev->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_PARENT_ENQUEUE_OFFLINE:
			if (! queueing_add(imsg->data))
				imsg_compose_event(iev,
				    IMSG_PARENT_ENQUEUE_OFFLINE, 0, 0, -1,
				    NULL, 0);
			return;
		}
	}

d380 1
a380 1
					log_warnx("couldn't enqueue offline "
d382 1
a382 6
				else
					log_debug("offline message enqueued");
				imsg_compose_event(env->sc_ievs[PROC_QUEUE],
				    IMSG_PARENT_ENQUEUE_OFFLINE, 0, 0, -1,
				    NULL, 0);
				queueing_done();
d432 1
a432 1
	TAILQ_INIT(&queueing_q);
d541 6
d878 32
d911 1
a911 1
parent_enqueue_offline(char *runner_path)
d913 1
a913 1
	char		 path[MAXPATHLEN];
d919 3
a921 1
	log_debug("parent_enqueue_offline: path %s", runner_path);
d923 2
a924 2
	if (! bsnprintf(path, sizeof(path), "%s%s", PATH_SPOOL, runner_path))
		fatalx("parent_enqueue_offline: filename too long");
d926 1
a926 2
	if (! path_starts_with(path, PATH_SPOOL PATH_OFFLINE))
		fatalx("parent_enqueue_offline: path outside offline dir");
d930 1
a930 1
			log_warn("parent_enqueue_offline: %s", path);
d933 1
a933 1
		fatal("parent_enqueue_offline: lstat");
d938 1
a938 1
			log_warn("parent_enqueue_offline: %s", path);
d941 1
a941 1
		fatal("parent_enqueue_offline: chflags");
d948 1
a948 1
		log_warn("parent_enqueue_offline: getpwuid for uid %d failed",
d955 1
a955 1
		log_warnx("file %s (uid %d) not regular, removing", path, sb.st_uid);
d964 1
a964 1
		fatal("parent_enqueue_offline: fork");
d1019 1
a1019 1
	queueing_running++;
d1026 1
a1026 1
queueing_add(char *path)
d1028 1
a1028 1
	struct queueing	*q;
d1030 1
a1030 1
	if (queueing_running < QUEUEING_MAX)
d1032 1
a1032 1
		return parent_enqueue_offline(path);
d1039 1
a1039 1
	TAILQ_INSERT_TAIL(&queueing_q, q, entry);
d1045 1
a1045 1
queueing_done(void)
d1047 1
a1047 1
	struct queueing	*q;
d1049 1
a1049 1
	queueing_running--;
d1051 2
a1052 2
	while(queueing_running < QUEUEING_MAX) {
		if ((q = TAILQ_FIRST(&queueing_q)) == NULL)
d1054 2
a1055 2
		TAILQ_REMOVE(&queueing_q, q, entry);
		parent_enqueue_offline(q->path);
a1241 1
	CASE(IMSG_PARENT_ENQUEUE_OFFLINE);
@


1.133
log
@tweak previous;
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.132 2011/10/22 00:16:33 eric Exp $	*/
d1195 4
a1198 4
	CASE(IMSG_QUEUE_PAUSE_LOCAL);
	CASE(IMSG_QUEUE_PAUSE_OUTGOING);
	CASE(IMSG_QUEUE_RESUME_LOCAL);
	CASE(IMSG_QUEUE_RESUME_OUTGOING);
@


1.132
log
@Add a log_trace() call to toggle logging of specific debugging info in
verbose mode, and an associated -T command line option.  Use it for
the imsg traces.

Requested by gilles@@ who doesn't like verbose to be too verbose.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.131 2011/10/09 18:39:54 eric Exp $	*/
d179 1
a179 1
	    "[-f file]\n", __progname);
@


1.131
log
@show messages sent between processes in debug mode

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.130 2011/09/01 19:56:49 eric Exp $	*/
d445 1
a445 1
	while ((c = getopt(argc, argv, "dD:nf:v")) != -1) {
d449 1
a449 1
			verbose = 1;
d463 6
d470 1
a470 2
			verbose = 1;
			opts |= SMTPD_OPT_VERBOSE;
d477 3
d1131 5
a1135 5
	log_debug("imsg: %s <- %s: %s (len=%zu)",
		proc_to_str(to),
		proc_to_str(from),
		imsg_to_str(imsg->hdr.type),
		imsg->hdr.len - IMSG_HEADER_SIZE);
@


1.130
log
@Introduce a small set of functions to manage stat counters in a
simpler and hopefully saner way.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.129 2011/08/29 21:43:09 chl Exp $	*/
d92 2
d1116 110
@


1.129
log
@cast all printed time_t to long long int, and change format string accordingly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.128 2011/08/27 22:32:41 gilles Exp $	*/
d516 1
@


1.128
log
@initial support for a session-time filtering API

currently only HELO/EHLO, MAIL, RCPT are supported, however ... I have
voluntarily disabled filters at smtpd.conf level so people don't play with
it until the API has stabilized a bit

discussed with several people in private, no one opposed the feature
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.127 2011/08/26 14:39:47 chl Exp $	*/
d796 2
a797 1
		snprintf(tmp, sizeof tmp, "tmp/%d.%d.%s", time(NULL),
@


1.127
log
@add missing header needed by time()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.126 2011/05/17 18:54:32 gilles Exp $	*/
a86 1
	struct smtpd		 newenv, *saveenv;
a87 1
	struct reload		*reload;
d90 1
a90 1
	int			 fd, r;
a147 27
		case IMSG_CONF_RELOAD:
			reload = imsg->data;
			reload->ret = 0;
			saveenv = env;
			env = &newenv;
			r = parse_config(&newenv, saveenv->sc_conffile, 0);
			env = saveenv;
			if (r == 0) {
				strlcpy(env->sc_hostname, newenv.sc_hostname,
				    sizeof env->sc_hostname);
				env->sc_listeners = newenv.sc_listeners;
				env->sc_maps = newenv.sc_maps;
				env->sc_rules = newenv.sc_rules;
				env->sc_rules = newenv.sc_rules;
				env->sc_ssl = newenv.sc_ssl;
				
				parent_send_config_client_certs();
				parent_send_config_ruleset(PROC_MFA);
				parent_send_config_ruleset(PROC_LKA);
				imsg_compose_event(env->sc_ievs[PROC_SMTP],
				    IMSG_CONF_RELOAD, 0, 0, -1, NULL, 0);
				reload->ret = 1;
			}
			imsg_compose_event(iev, IMSG_CONF_RELOAD, 0, 0, -1,
			    reload, sizeof *reload);
			return;

d204 1
d292 1
d297 12
a308 5
	
	TAILQ_FOREACH(m, env->sc_maps, m_entry) {
		imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_MAP,
		    0, 0, -1, m, sizeof(*m));
		TAILQ_FOREACH(mapel, &m->m_contents, me_entry) {
d311 1
a312 1
	}
d314 6
a319 5
	TAILQ_FOREACH(r, env->sc_rules, r_entry) {
		imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_RULE,
		    0, 0, -1, r, sizeof(*r));
		imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_RULE_SOURCE,
		    0, 0, -1, &r->r_sources->m_name, sizeof(r->r_sources->m_name));
@


1.126
log
@introduce new user_backend API for smtpd to lookup the users it wants to
deliver mail to. the only backend supported for now is USER_GETPWNAM and
it is not yet possible to switch to an alternate backend.

yes this means that we're very close from smtpd being able to handle fully
virtual accounts for both incoming and outgoing messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.125 2011/05/17 16:42:06 gilles Exp $	*/
d42 1
@


1.125
log
@smtpd now uses an auth_backend API to authenticate users that are allowed
to send mail so they do not necessarily need a local system account.

two backends are provided by default, bsd_auth(3) and getpwnam(3), however
smtpd will only select bsd_auth(3) for the moment and not provide a way to
chose any other backend (that's on purpose ;p).

bye bye authenticate() !
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.124 2011/05/16 21:05:52 gilles Exp $	*/
d690 2
a691 1
	struct passwd	*pw;
d698 2
d701 1
a701 2
	pw = getpwnam(deliver->user);
	if (pw == NULL) {
d709 1
a709 1
	if (seteuid(pw->pw_uid) < 0)
d762 1
a762 1
	if (chdir(pw->pw_dir) < 0 && chdir("/") < 0)
d770 3
a772 3
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
d893 2
a894 1
	struct passwd	*pw;
d922 2
d925 1
a925 1
	if ((pw = getpwuid(sb.st_uid)) == NULL) {
d952 3
a954 3
		if (setgroups(1, &pw->pw_gid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) ||
d966 1
a966 1
		if (chdir(pw->pw_dir) == -1 && chdir("/") == -1)
d1041 2
a1042 1
	struct passwd *pw;
d1046 3
a1048 2
	pw = getpwnam(username);
	if (pw == NULL)
d1051 1
a1051 1
	if (! bsnprintf(pathname, sizeof (pathname), "%s/.forward", pw->pw_dir))
d1062 1
a1062 1
	if (! secure_file(fd, pathname, pw, 1)) {
@


1.124
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.123 2011/05/04 20:45:30 eric Exp $	*/
d90 1
d100 1
d102 1
a102 1
			auth->success = authenticate_user(auth->user,
@


1.123
log
@When enqueueing offline mail, use a wait list to keep the number of
forked processes below a reasonnable limit.  This prevents smtpd from
fork-bombing on startup when there are lots of mails in the offline
queue.

ok todd@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.122 2011/05/01 12:57:11 eric Exp $	*/
d112 1
a112 1
			fd = parent_forward_open(fwreq->pw_name);
@


1.122
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.121 2011/04/17 13:36:07 gilles Exp $	*/
d64 12
d129 1
a129 1
			if (! parent_enqueue_offline(imsg->data))
d407 1
d457 2
d990 1
d994 35
@


1.121
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.120 2011/04/14 22:46:38 gilles Exp $	*/
d47 1
a47 1
static void parent_imsg(struct smtpd *, struct imsgev *, struct imsg *);
d49 1
a49 1
static void parent_shutdown(struct smtpd *);
d51 3
a53 3
static void parent_send_config_listeners(struct smtpd *);
static void parent_send_config_client_certs(struct smtpd *);
static void parent_send_config_ruleset(struct smtpd *, int);
d55 2
a56 3
static void forkmda(struct smtpd *, struct imsgev *, u_int32_t,
    struct deliver *);
static int parent_enqueue_offline(struct smtpd *, char *);
d59 4
a62 4
static void fork_peers(struct smtpd *);
static struct child *child_lookup(struct smtpd *, pid_t);
static struct child *child_add(struct smtpd *, pid_t, int, int);
static void child_del(struct smtpd *, pid_t);
d65 3
a67 1
void		(*imsg_callback)(struct smtpd *, struct imsgev *, struct imsg *);
d72 1
a72 1
parent_imsg(struct smtpd *env, struct imsgev *iev, struct imsg *imsg)
d74 1
a74 1
	struct smtpd		 newenv;
d78 1
a78 1
	int			 fd;
d83 1
a83 1
			parent_send_config_listeners(env);
d117 1
a117 1
			if (! parent_enqueue_offline(env, imsg->data))
d128 1
a128 1
			forkmda(env, iev, imsg->hdr.peerid, imsg->data);
d138 5
a142 1
			if (parse_config(&newenv, env->sc_conffile, 0) == 0) {
d151 3
a153 3
				parent_send_config_client_certs(env);
				parent_send_config_ruleset(env, PROC_MFA);
				parent_send_config_ruleset(env, PROC_LKA);
d196 1
a196 1
parent_shutdown(struct smtpd *env)
d216 3
a218 3
	parent_send_config_listeners(p);
	parent_send_config_client_certs(p);
	parent_send_config_ruleset(p, PROC_LKA);
d222 1
a222 1
parent_send_config_listeners(struct smtpd *env)
d268 1
a268 1
parent_send_config_client_certs(struct smtpd *env)
d300 1
a300 1
parent_send_config_ruleset(struct smtpd *env, int proc)
a332 1
	struct smtpd	*env = p;
d349 1
a349 1
			child = child_lookup(env, pid);
d401 1
a401 1
			child_del(env, child->pid);
d406 1
a406 1
			parent_shutdown(env);
d420 1
a420 1
	struct smtpd	 env;
d436 2
d474 1
a474 1
	if (parse_config(&env, conffile, opts))
d477 1
a477 1
	if (strlcpy(env.sc_conffile, conffile, MAXPATHLEN) >= MAXPATHLEN)
d481 1
a481 1
	if (env.sc_opts & SMTPD_OPT_NOACTION) {
d490 1
a490 1
	if ((env.sc_pw =  getpwnam(SMTPD_USER)) == NULL)
d493 2
a494 2
	env.sc_queue = queue_backend_lookup(QT_FS);
	if (env.sc_queue == NULL)
d497 1
a497 1
	if (!env.sc_queue->init(&env))
d509 1
a509 1
	if (env.sc_hostname[0] == '\0')
d512 1
a512 1
	env.stats = mmap(NULL, sizeof(struct stats), PROT_WRITE|PROT_READ,
d514 1
a514 1
	if (env.stats == MAP_FAILED)
d516 1
a516 1
	bzero(env.stats, sizeof(struct stats));
d518 1
a518 1
	env.stats->parent.start = time(NULL);
d520 1
a520 1
	fork_peers(&env);
d525 4
a528 4
	signal_set(&ev_sigint, SIGINT, parent_sig_handler, &env);
	signal_set(&ev_sigterm, SIGTERM, parent_sig_handler, &env);
	signal_set(&ev_sigchld, SIGCHLD, parent_sig_handler, &env);
	signal_set(&ev_sighup, SIGHUP, parent_sig_handler, &env);
d535 2
a536 2
	config_pipes(&env, peers, nitems(peers));
	config_peers(&env, peers, nitems(peers));
d538 1
a538 1
	evtimer_set(&env.sc_ev, parent_send_config, &env);
d540 1
a540 1
	evtimer_add(&env.sc_ev, &tv);
d549 1
a549 1
fork_peers(struct smtpd *env)
d578 1
a578 1
	init_pipes(env);
d589 8
a596 8
	child_add(env, control(env), CHILD_DAEMON, PROC_CONTROL);
	child_add(env, lka(env), CHILD_DAEMON, PROC_LKA);
	child_add(env, mda(env), CHILD_DAEMON, PROC_MDA);
	child_add(env, mfa(env), CHILD_DAEMON, PROC_MFA);
	child_add(env, mta(env), CHILD_DAEMON, PROC_MTA);
	child_add(env, queue(env), CHILD_DAEMON, PROC_QUEUE);
	child_add(env, runner(env), CHILD_DAEMON, PROC_RUNNER);
	child_add(env, smtp(env), CHILD_DAEMON, PROC_SMTP);
d602 1
a602 1
child_add(struct smtpd *env, pid_t pid, int type, int title)
d620 1
a620 1
child_del(struct smtpd *env, pid_t pid)
d624 1
a624 1
	p = child_lookup(env, pid);
d634 1
a634 1
child_lookup(struct smtpd *env, pid_t pid)
d669 1
a669 1
forkmda(struct smtpd *env, struct imsgev *iev, u_int32_t id,
d731 1
a731 1
		child = child_add(env, pid, CHILD_MDA, -1);
d871 1
a871 1
parent_enqueue_offline(struct smtpd *env, char *runner_path)
d975 1
a975 1
	child_add(env, pid, CHILD_ENQUEUE_OFFLINE, -1);
d1063 1
a1063 1
		imsg_callback(iev->env, iev, &imsg);
@


1.120
log
@no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.119 2011/04/14 20:11:08 gilles Exp $	*/
d47 17
a63 20
void		 parent_imsg(struct smtpd *, struct imsgev *, struct imsg *);
__dead void	 usage(void);
void		 parent_shutdown(struct smtpd *);
void		 parent_send_config(int, short, void *);
void		 parent_send_config_listeners(struct smtpd *);
void		 parent_send_config_client_certs(struct smtpd *);
void		 parent_send_config_ruleset(struct smtpd *, int);
void		 parent_sig_handler(int, short, void *);

void		 forkmda(struct smtpd *, struct imsgev *, u_int32_t,
		     struct deliver *);
int		 parent_enqueue_offline(struct smtpd *, char *);
int		 parent_forward_open(char *);
int		 path_starts_with(char *, char *);

void		 fork_peers(struct smtpd *);

struct child	*child_add(struct smtpd *, pid_t, int, int);
void		 child_del(struct smtpd *, pid_t);
struct child	*child_lookup(struct smtpd *, pid_t);
d70 1
a70 1
void
d180 1
a180 1
__dead void
d190 1
a190 1
void
d208 1
a208 1
void
d216 1
a216 1
void
d262 1
a262 1
void
d325 1
a325 1
void
d542 1
a542 1
void
d613 1
a613 1
void
d627 1
a627 1
struct child *
d662 1
a662 1
void
d864 1
a864 1
int
d974 1
a974 1
int
@


1.119
log
@fsqueue queue backend will implement a filesystem queue:
- fsqueue->setup() performs the queue initialization;
- fsqueue->message() controls messages;
- fsqueue->envelope() controls envelopes;

This commit brings the following to fsbackend:
fsqueue_setup(), fsqueue_message_delete(), fsqueue_envelope_load(),
fsqueue_envelope_update(), fsqueue_envelope_delete().

It also makes smtpd use the queue_backend API for these operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.118 2011/04/14 17:06:43 gilles Exp $	*/
a59 1
int		 setup_spool(uid_t, gid_t);
d494 1
a494 1
	if (!env.sc_queue->setup(&env))
@


1.118
log
@smtpd makes too many assumptions about the structure and layout of its
disk-based queue, it makes it near impossible to make changes to it without
editing twenty files... how am i going to implement mongodb support ? :-)

bring a new queue_backend API which hides the details of the disk-based
queue to smtpd. it is not "plugged in" yet and I'm filling the holes.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.117 2011/04/13 20:53:18 gilles Exp $	*/
a490 3
	if (!setup_spool(env.sc_pw->pw_uid, 0))
		errx(1, "invalid directory permissions");

d495 3
a637 129
}

int
setup_spool(uid_t uid, gid_t gid)
{
	unsigned int	 n;
	char		*paths[] = { PATH_INCOMING, PATH_ENQUEUE, PATH_QUEUE,
				     PATH_PURGE, PATH_OFFLINE, PATH_BOUNCE };
	char		 pathname[MAXPATHLEN];
	struct stat	 sb;
	int		 ret;

	if (! bsnprintf(pathname, sizeof(pathname), "%s", PATH_SPOOL))
		fatal("snprintf");

	if (stat(pathname, &sb) == -1) {
		if (errno != ENOENT) {
			warn("stat: %s", pathname);
			return 0;
		}

		if (mkdir(pathname, 0711) == -1) {
			warn("mkdir: %s", pathname);
			return 0;
		}

		if (chown(pathname, 0, 0) == -1) {
			warn("chown: %s", pathname);
			return 0;
		}

		if (stat(pathname, &sb) == -1)
			err(1, "stat: %s", pathname);
	}

	/* check if it's a directory */
	if (!S_ISDIR(sb.st_mode)) {
		warnx("%s is not a directory", pathname);
		return 0;
	}

	/* check that it is owned by uid/gid */
	if (sb.st_uid != 0 || sb.st_gid != 0) {
		warnx("%s must be owned by root:wheel", pathname);
		return 0;
	}

	/* check permission */
	if ((sb.st_mode & (S_IRUSR|S_IWUSR|S_IXUSR)) != (S_IRUSR|S_IWUSR|S_IXUSR) ||
	    (sb.st_mode & (S_IRGRP|S_IWGRP|S_IXGRP)) != S_IXGRP ||
	    (sb.st_mode & (S_IROTH|S_IWOTH|S_IXOTH)) != S_IXOTH) {
		warnx("%s must be rwx--x--x (0711)", pathname);
		return 0;
	}

	ret = 1;
	for (n = 0; n < nitems(paths); n++) {
		mode_t	mode;
		uid_t	owner;
		gid_t	group;

		if (!strcmp(paths[n], PATH_OFFLINE)) {
			mode = 01777;
			owner = 0;
			group = 0;
		} else {
			mode = 0700;
			owner = uid;
			group = gid;
		}

		if (! bsnprintf(pathname, sizeof(pathname), "%s%s", PATH_SPOOL,
			paths[n]))
			fatal("snprintf");

		if (stat(pathname, &sb) == -1) {
			if (errno != ENOENT) {
				warn("stat: %s", pathname);
				ret = 0;
				continue;
			}

			/* chmod is deffered to avoid umask effect */
			if (mkdir(pathname, 0) == -1) {
				ret = 0;
				warn("mkdir: %s", pathname);
			}

			if (chown(pathname, owner, group) == -1) {
				ret = 0;
				warn("chown: %s", pathname);
			}

			if (chmod(pathname, mode) == -1) {
				ret = 0;
				warn("chmod: %s", pathname);
			}

			if (stat(pathname, &sb) == -1)
				err(1, "stat: %s", pathname);
		}

		/* check if it's a directory */
		if (!S_ISDIR(sb.st_mode)) {
			ret = 0;
			warnx("%s is not a directory", pathname);
		}

		/* check that it is owned by owner/group */
		if (sb.st_uid != owner) {
			ret = 0;
			warnx("%s is not owned by uid %d", pathname, owner);
		}
		if (sb.st_gid != group) {
			ret = 0;
			warnx("%s is not owned by gid %d", pathname, group);
		}

		/* check permission */
		if ((sb.st_mode & 07777) != mode) {
			char mode_str[12];

			ret = 0;
			strmode(mode, mode_str);
			mode_str[10] = '\0';
			warnx("%s must be %s (%o)", pathname, mode_str + 1, mode);
		}
	}
	return ret;
@


1.117
log
@following an idea from jacekm@@, smtpd now uses a ram-queue instead of doing
a continuous walk on the disk-queue. the implementation differs from what
jacekm@@ commited (and I backed out) a while ago in that it uses a queue and
a host tree required for upcoming features.

code will be improved in tree, it requires changes to be done in queue and
bounce API, I just wanted to commit a working version first ...

tested by todd@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.116 2011/03/15 19:24:55 gilles Exp $	*/
d493 4
@


1.116
log
@let smtpd use user-provided Diffie-Hellman parameters for ephemeral key
exchange. if no DH parameters are found, fallback to builtin parameters
as was done until now.

since we now accept user-provided DH parameters, make smtpd more strict
and fatal() if the parameters are bogus.

bump the key size of the DH parameters from 512bits to 1024bits, it might
be bumped further after some more research.

thanks to mikeb@@ for his suggestions

diff ok mikeb@@ , man ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.115 2010/11/28 14:35:58 gilles Exp $	*/
d641 1
a641 2
				     PATH_RUNQUEUE, PATH_PURGE,
				     PATH_OFFLINE, PATH_BOUNCE };
@


1.115
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.114 2010/11/28 13:56:43 gilles Exp $	*/
d225 1
a225 1
	struct iovec		 iov[3];
d242 2
d270 1
a270 1
	struct iovec		 iov[3];
d286 2
@


1.114
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.113 2010/10/09 22:05:35 gilles Exp $	*/
d33 1
a34 1
#include <fcntl.h>
a35 1
#include <login_cap.h>
a37 1
#include <regex.h>
a41 2
#include <sysexits.h>
#include <time.h>
@


1.113
log
@backout the "new" queue code commited 4 months ago. it has many good ideas,
is way more optimized than what we had earlier and there's definitely stuff
we want to keep, however it is early optimization that doesn't account for
many features and makes them hard (if not impossible) to write without
ugly workarounds that ruin the purpose of the optimizations.

the backout goes to 30 May's right before the commit and catches up on all
the non-queue related commits that happened since then.

i'll work on reintroducing the ideas from this queue when the basic
features we expect from a MTA are implemented.

suggested on tech@@ about a week ago, no objections, several "please make
smtpd move forward" mails from hackers and tech readers.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.107 2010/05/27 15:36:04 gilles Exp $	*/
d35 1
d49 1
@


1.112
log
@check event_dispatch() return value

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.111 2010/06/01 23:06:25 jacekm Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009-2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
a30 1
#include <dirent.h>
a47 1
#include "queue_backend.h"
d60 1
a60 1
void		 parent_enqueue_offline(struct smtpd *);
d62 2
a70 2
void		 setup_spool(struct passwd *);

d74 2
d119 11
a182 1
	log_warnx("parent got imsg %d from %d", imsg->hdr.type, iev->proc);
d387 1
a387 1
					    "message; child %s", cause);
d390 3
a392 1
				parent_enqueue_offline(env);
d486 1
a486 1
	if ((env.sc_pw = getpwnam(SMTPD_USER)) == NULL)
d489 3
a491 2
	setup_spool(env.sc_pw);
	
a533 2
	parent_enqueue_offline(&env);

d567 1
d578 1
d587 1
d634 130
a786 1

d805 2
a806 5
		if (errno)
			n = snprintf(ebuf, sizeof ebuf, "getpwnam: %s",
			    strerror(errno));
		else
			n = snprintf(ebuf, sizeof ebuf, "user not found");
d889 1
a889 2
	/* external mda */
	if (deliver->mode == 'P') {
d900 1
a900 2
	/* internal mda: maildir */
	if (deliver->mode == 'D') {
d930 4
d943 1
a943 2
	/* internal mda: file */
	if (deliver->mode == 'F') {
d978 4
d992 2
a993 2
void
parent_enqueue_offline(struct smtpd *env)
d995 2
a996 1
	char		 path[MAXPATHLEN], *line, charstr[2], *envp[2], *tmp;
a997 3
	struct dirent	*de;
	struct passwd	*pw;
	DIR		*dir;
a998 2
	arglist		 args;
	int		 fd, line_sz;
d1000 1
a1000 2
	fd = -1;
	pw = NULL;
d1002 2
a1003 3
	dir = opendir(PATH_SPOOL PATH_OFFLINE);
	if (dir == NULL)
		fatal("opendir");
d1005 15
a1019 14
	while ((de = readdir(dir))) {
		if (de->d_name[0] == '.')
			continue;
		snprintf(path, sizeof path, "%s%s/%s", PATH_SPOOL,
		    PATH_OFFLINE, de->d_name);
		log_debug("%s: file %s", __func__, path);
		fd = open(path, O_RDONLY);
		if (fd < 0)
			continue;
		if (fchflags(fd, 0) < 0 || fstat(fd, &sb) < 0 ||
		    unlink(path) < 0 || !S_ISREG(sb.st_mode) ||
		    (pw = getpwuid(sb.st_uid)) == NULL) {
			close(fd);
			continue;
d1021 18
a1038 1
		break;
d1041 8
a1048 1
	closedir(dir);
d1050 15
a1064 2
	if (de == NULL)
		return;
d1066 2
a1067 3
	pid = fork();
	if (pid < 0)
		fatal("fork");
d1069 4
a1072 4
	if (pid) {
		child_add(env, pid, CHILD_ENQUEUE_OFFLINE, -1);
		return;
	}
d1074 2
a1075 18
	if (chdir(pw->pw_dir) < 0 && chdir("/") < 0)
		_exit(1);
	if (dup2(fd, STDIN_FILENO) < 0)
		_exit(1);
	if (closefrom(STDERR_FILENO + 1) < 0)
		_exit(1);
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		_exit(1);
	if (setsid() < 0)
		_exit(1);
	if (signal(SIGPIPE, SIG_DFL) == SIG_ERR ||
	    signal(SIGINT, SIG_DFL) == SIG_ERR ||
	    signal(SIGTERM, SIG_DFL) == SIG_ERR ||
	    signal(SIGCHLD, SIG_DFL) == SIG_ERR ||
	    signal(SIGHUP, SIG_DFL) == SIG_ERR)
		_exit(1);
d1077 1
a1077 7
	line = malloc(1);
	if (line == NULL)
		_exit(1);
	line_sz = 1;
	line[0] = '\0';
	do {
		if (read(STDIN_FILENO, charstr, 1) <= 0)
d1079 8
a1086 3
		charstr[1] = '\0';
		line = realloc(line, ++line_sz);
		if (line == NULL)
d1088 12
a1099 15
		strlcat(line, charstr, line_sz);
	} while (charstr[0] != '\n');
	line[strcspn(line, "\n")] = '\0';

	bzero(&args, sizeof args);
	addargs(&args, "%s", "sendmail");
	while ((tmp = strsep(&line, "|"))) {
		log_debug("%s: arg %s", __func__, tmp);
		addargs(&args, "%s", tmp);
	}
	envp[0] = "PATH=" _PATH_DEFPATH;
	envp[1] = (char *)NULL;
	environ = envp;
	execvp(PATH_SMTPCTL, args.list);
	_exit(1);
d1134 12
a1188 21
}

void
setup_spool(struct passwd *pw)
{
	if (mkdir(PATH_SPOOL, 0711) < 0 && errno != EEXIST)
		err(1, "mkdir: %s", PATH_SPOOL);
	if (chmod(PATH_SPOOL, 0711) < 0)
		err(1, "chmod: %s", PATH_SPOOL);
	if (chown(PATH_SPOOL, 0, 0) < 0)
		err(1, "chown: %s", PATH_SPOOL);

	if (queue_be_init(PATH_SPOOL, pw->pw_uid, pw->pw_gid) < 0)
		err(1, "backend init failed");

	if (mkdir(PATH_SPOOL PATH_OFFLINE, 01777) < 0 && errno != EEXIST)
		err(1, "mkdir: %s", PATH_SPOOL PATH_OFFLINE);
	if (chmod(PATH_SPOOL PATH_OFFLINE, 01777) < 0)
		err(1, "chmod: %s", PATH_SPOOL PATH_OFFLINE);
	if (chown(PATH_SPOOL PATH_OFFLINE, 0, 0) < 0)
		err(1, "chmod: %s", PATH_SPOOL PATH_OFFLINE);
@


1.111
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.109 2010/05/31 23:38:56 jacekm Exp $	*/
d523 2
a524 1
	event_dispatch();
@


1.110
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.108 2010/05/31 22:25:26 chl Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d31 1
d49 1
d62 1
a62 1
int		 parent_enqueue_offline(struct smtpd *, char *);
a63 2
int		 setup_spool(uid_t, gid_t);
int		 path_starts_with(char *, char *);
d71 2
a75 2
int __b64_pton(char const *, unsigned char *, size_t);

a118 11
	if (iev->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_PARENT_ENQUEUE_OFFLINE:
			if (! parent_enqueue_offline(env, imsg->data))
				imsg_compose_event(iev,
				    IMSG_PARENT_ENQUEUE_OFFLINE, 0, 0, -1,
				    NULL, 0);
			return;
		}
	}

d172 1
d377 1
a377 1
					    "message; smtpctl %s", cause);
d380 1
a380 3
				imsg_compose_event(env->sc_ievs[PROC_QUEUE],
				    IMSG_PARENT_ENQUEUE_OFFLINE, 0, 0, -1,
				    NULL, 0);
d474 1
a474 1
	if ((env.sc_pw =  getpwnam(SMTPD_USER)) == NULL)
d477 2
a478 3
	if (!setup_spool(env.sc_pw->pw_uid, 0))
		errx(1, "invalid directory permissions");

d521 2
a554 1
	env->sc_instances[PROC_RUNNER] = 1;
a564 1
	env->sc_title[PROC_RUNNER] = "runner";
a572 1
	child_add(env, runner(env), CHILD_DAEMON, PROC_RUNNER);
a618 130
int
setup_spool(uid_t uid, gid_t gid)
{
	unsigned int	 n;
	char		*paths[] = { PATH_INCOMING, PATH_ENQUEUE, PATH_QUEUE,
				     PATH_RUNQUEUE, PATH_PURGE,
				     PATH_OFFLINE, PATH_BOUNCE };
	char		 pathname[MAXPATHLEN];
	struct stat	 sb;
	int		 ret;

	if (! bsnprintf(pathname, sizeof(pathname), "%s", PATH_SPOOL))
		fatal("snprintf");

	if (stat(pathname, &sb) == -1) {
		if (errno != ENOENT) {
			warn("stat: %s", pathname);
			return 0;
		}

		if (mkdir(pathname, 0711) == -1) {
			warn("mkdir: %s", pathname);
			return 0;
		}

		if (chown(pathname, 0, 0) == -1) {
			warn("chown: %s", pathname);
			return 0;
		}

		if (stat(pathname, &sb) == -1)
			err(1, "stat: %s", pathname);
	}

	/* check if it's a directory */
	if (!S_ISDIR(sb.st_mode)) {
		warnx("%s is not a directory", pathname);
		return 0;
	}

	/* check that it is owned by uid/gid */
	if (sb.st_uid != 0 || sb.st_gid != 0) {
		warnx("%s must be owned by root:wheel", pathname);
		return 0;
	}

	/* check permission */
	if ((sb.st_mode & (S_IRUSR|S_IWUSR|S_IXUSR)) != (S_IRUSR|S_IWUSR|S_IXUSR) ||
	    (sb.st_mode & (S_IRGRP|S_IWGRP|S_IXGRP)) != S_IXGRP ||
	    (sb.st_mode & (S_IROTH|S_IWOTH|S_IXOTH)) != S_IXOTH) {
		warnx("%s must be rwx--x--x (0711)", pathname);
		return 0;
	}

	ret = 1;
	for (n = 0; n < nitems(paths); n++) {
		mode_t	mode;
		uid_t	owner;
		gid_t	group;

		if (!strcmp(paths[n], PATH_OFFLINE)) {
			mode = 01777;
			owner = 0;
			group = 0;
		} else {
			mode = 0700;
			owner = uid;
			group = gid;
		}

		if (! bsnprintf(pathname, sizeof(pathname), "%s%s", PATH_SPOOL,
			paths[n]))
			fatal("snprintf");

		if (stat(pathname, &sb) == -1) {
			if (errno != ENOENT) {
				warn("stat: %s", pathname);
				ret = 0;
				continue;
			}

			/* chmod is deffered to avoid umask effect */
			if (mkdir(pathname, 0) == -1) {
				ret = 0;
				warn("mkdir: %s", pathname);
			}

			if (chown(pathname, owner, group) == -1) {
				ret = 0;
				warn("chown: %s", pathname);
			}

			if (chmod(pathname, mode) == -1) {
				ret = 0;
				warn("chmod: %s", pathname);
			}

			if (stat(pathname, &sb) == -1)
				err(1, "stat: %s", pathname);
		}

		/* check if it's a directory */
		if (!S_ISDIR(sb.st_mode)) {
			ret = 0;
			warnx("%s is not a directory", pathname);
		}

		/* check that it is owned by owner/group */
		if (sb.st_uid != owner) {
			ret = 0;
			warnx("%s is not owned by uid %d", pathname, owner);
		}
		if (sb.st_gid != group) {
			ret = 0;
			warnx("%s is not owned by gid %d", pathname, group);
		}

		/* check permission */
		if ((sb.st_mode & 07777) != mode) {
			char mode_str[12];

			ret = 0;
			strmode(mode, mode_str);
			mode_str[10] = '\0';
			warnx("%s must be %s (%o)", pathname, mode_str + 1, mode);
		}
	}
	return ret;
}

d661 5
a665 2
		n = snprintf(ebuf, sizeof ebuf, "getpwnam: %s",
		    errno ? strerror(errno) : "no such user");
d748 2
a749 1
	if (deliver->mode == A_EXT) {
d760 2
a761 1
	if (deliver->mode == A_MAILDIR) {
a790 4
		if (fflush(fp) == EOF || ferror(fp))
			error2("write error");
		if (fsync(fd) < 0)
			error2("fsync");
d800 2
a801 1
	if (deliver->mode == A_FILENAME) {
a835 4
		if (fflush(fp) == EOF || ferror(fp))
			error2("write error");
		if (fsync(fd) < 0)
			error2("fsync");
d846 2
a847 2
int
parent_enqueue_offline(struct smtpd *env, char *runner_path)
d849 3
a851 1
	char		 path[MAXPATHLEN];
d853 1
a853 1
	struct stat	 sb;
d855 2
d858 2
a859 1
	log_debug("parent_enqueue_offline: path %s", runner_path);
d861 3
a863 2
	if (! bsnprintf(path, sizeof(path), "%s%s", PATH_SPOOL, runner_path))
		fatalx("parent_enqueue_offline: filename too long");
d865 14
a878 7
	if (! path_starts_with(path, PATH_SPOOL PATH_OFFLINE))
		fatalx("parent_enqueue_offline: path outside offline dir");

	if (lstat(path, &sb) == -1) {
		if (errno == ENOENT) {
			log_warn("parent_enqueue_offline: %s", path);
			return (0);
d880 1
a880 1
		fatal("parent_enqueue_offline: lstat");
d883 4
a886 7
	if (chflags(path, 0) == -1) {
		if (errno == ENOENT) {
			log_warn("parent_enqueue_offline: %s", path);
			return (0);
		}
		fatal("parent_enqueue_offline: chflags");
	}
d888 3
a890 7
	errno = 0;
	if ((pw = getpwuid(sb.st_uid)) == NULL) {
		log_warn("parent_enqueue_offline: getpwuid for uid %d failed",
		    sb.st_uid);
		unlink(path);
		return (0);
	}
d892 3
a894 7
	if (! S_ISREG(sb.st_mode)) {
		log_warnx("file %s (uid %d) not regular, removing", path, sb.st_uid);
		if (S_ISDIR(sb.st_mode))
			rmdir(path);
		else
			unlink(path);
		return (0);
d897 18
a914 2
	if ((pid = fork()) == -1)
		fatal("parent_enqueue_offline: fork");
d916 7
a922 23
	if (pid == 0) {
		char	*envp[2], *p, *tmp;
		FILE	*fp;
		size_t	 len;
		arglist	 args;

		bzero(&args, sizeof(args));

		if (setgroups(1, &pw->pw_gid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) ||
		    closefrom(STDERR_FILENO + 1) == -1) {
			unlink(path);
			_exit(1);
		}

		if ((fp = fopen(path, "r")) == NULL) {
			unlink(path);
			_exit(1);
		}
		unlink(path);

		if (chdir(pw->pw_dir) == -1 && chdir("/") == -1)
d924 3
a926 7

		if (setsid() == -1 ||
		    signal(SIGPIPE, SIG_DFL) == SIG_ERR ||
		    dup2(fileno(fp), STDIN_FILENO) == -1)
			_exit(1);

		if ((p = fgetln(fp, &len)) == NULL)
d928 15
a942 24

		if (p[len - 1] != '\n')
			_exit(1);
		p[len - 1] = '\0';

		addargs(&args, "%s", "sendmail");

		while ((tmp = strsep(&p, "|")) != NULL)
			addargs(&args, "%s", tmp);

		if (lseek(fileno(fp), len, SEEK_SET) == -1)
			_exit(1);

		envp[0] = "PATH=" _PATH_DEFPATH;
		envp[1] = (char *)NULL;
		environ = envp;

		execvp(PATH_SMTPCTL, args.list);
		_exit(1);
	}

	child_add(env, pid, CHILD_ENQUEUE_OFFLINE, -1);

	return (1);
a976 12
path_starts_with(char *file, char *prefix)
{
	char	 rprefix[MAXPATHLEN];
	char	 rfile[MAXPATHLEN];

	if (realpath(file, rfile) == NULL || realpath(prefix, rprefix) == NULL)
		return (-1);

	return (strncmp(rfile, rprefix, strlen(rprefix)) == 0);
}

int
d1020 21
@


1.109
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d6 1
a6 1
 * Copyright (c) 2009-2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
a30 1
#include <dirent.h>
a47 1
#include "queue_backend.h"
d60 1
a60 1
void		 parent_enqueue_offline(struct smtpd *);
d62 2
a70 2
void		 setup_spool(struct passwd *);

d74 2
d119 11
a182 1
	log_warnx("parent got imsg %d from %d", imsg->hdr.type, iev->proc);
d387 1
a387 1
					    "message; child %s", cause);
d390 3
a392 1
				parent_enqueue_offline(env);
d486 1
a486 1
	if ((env.sc_pw = getpwnam(SMTPD_USER)) == NULL)
d489 3
a491 2
	setup_spool(env.sc_pw);
	
a533 2
	parent_enqueue_offline(&env);

d566 1
d577 1
d586 1
d633 130
d805 2
a806 5
		if (errno)
			n = snprintf(ebuf, sizeof ebuf, "getpwnam: %s",
			    strerror(errno));
		else
			n = snprintf(ebuf, sizeof ebuf, "user not found");
d889 1
a889 2
	/* external mda */
	if (deliver->mode == 'P') {
d900 1
a900 2
	/* internal mda: maildir */
	if (deliver->mode == 'D') {
d930 4
d943 1
a943 2
	/* internal mda: file */
	if (deliver->mode == 'F') {
d978 4
d992 2
a993 2
void
parent_enqueue_offline(struct smtpd *env)
d995 2
a996 1
	char		 path[MAXPATHLEN], *line, charstr[2], *envp[2], *tmp;
a997 3
	struct dirent	*de;
	struct passwd	*pw;
	DIR		*dir;
a998 2
	arglist		 args;
	int		 fd, line_sz;
d1000 1
a1000 2
	fd = -1;
	pw = NULL;
d1002 2
a1003 3
	dir = opendir(PATH_SPOOL PATH_OFFLINE);
	if (dir == NULL)
		fatal("opendir");
d1005 15
a1019 14
	while ((de = readdir(dir))) {
		if (de->d_name[0] == '.')
			continue;
		snprintf(path, sizeof path, "%s%s/%s", PATH_SPOOL,
		    PATH_OFFLINE, de->d_name);
		log_debug("%s: file %s", __func__, path);
		fd = open(path, O_RDONLY);
		if (fd < 0)
			continue;
		if (fchflags(fd, 0) < 0 || fstat(fd, &sb) < 0 ||
		    unlink(path) < 0 || !S_ISREG(sb.st_mode) ||
		    (pw = getpwuid(sb.st_uid)) == NULL) {
			close(fd);
			continue;
d1021 18
a1038 1
		break;
d1041 8
a1048 1
	closedir(dir);
d1050 15
a1064 2
	if (de == NULL)
		return;
d1066 2
a1067 3
	pid = fork();
	if (pid < 0)
		fatal("fork");
d1069 4
a1072 4
	if (pid) {
		child_add(env, pid, CHILD_ENQUEUE_OFFLINE, -1);
		return;
	}
d1074 2
a1075 18
	if (chdir(pw->pw_dir) < 0 && chdir("/") < 0)
		_exit(1);
	if (dup2(fd, STDIN_FILENO) < 0)
		_exit(1);
	if (closefrom(STDERR_FILENO + 1) < 0)
		_exit(1);
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		_exit(1);
	if (setsid() < 0)
		_exit(1);
	if (signal(SIGPIPE, SIG_DFL) == SIG_ERR ||
	    signal(SIGINT, SIG_DFL) == SIG_ERR ||
	    signal(SIGTERM, SIG_DFL) == SIG_ERR ||
	    signal(SIGCHLD, SIG_DFL) == SIG_ERR ||
	    signal(SIGHUP, SIG_DFL) == SIG_ERR)
		_exit(1);
d1077 1
a1077 7
	line = malloc(1);
	if (line == NULL)
		_exit(1);
	line_sz = 1;
	line[0] = '\0';
	do {
		if (read(STDIN_FILENO, charstr, 1) <= 0)
d1079 8
a1086 3
		charstr[1] = '\0';
		line = realloc(line, ++line_sz);
		if (line == NULL)
d1088 12
a1099 15
		strlcat(line, charstr, line_sz);
	} while (charstr[0] != '\n');
	line[strcspn(line, "\n")] = '\0';

	bzero(&args, sizeof args);
	addargs(&args, "%s", "sendmail");
	while ((tmp = strsep(&line, "|"))) {
		log_debug("%s: arg %s", __func__, tmp);
		addargs(&args, "%s", tmp);
	}
	envp[0] = "PATH=" _PATH_DEFPATH;
	envp[1] = (char *)NULL;
	environ = envp;
	execvp(PATH_SMTPCTL, args.list);
	_exit(1);
d1134 12
a1188 21
}

void
setup_spool(struct passwd *pw)
{
	if (mkdir(PATH_SPOOL, 0711) < 0 && errno != EEXIST)
		err(1, "mkdir: %s", PATH_SPOOL);
	if (chmod(PATH_SPOOL, 0711) < 0)
		err(1, "chmod: %s", PATH_SPOOL);
	if (chown(PATH_SPOOL, 0, 0) < 0)
		err(1, "chown: %s", PATH_SPOOL);

	if (queue_be_init(PATH_SPOOL, pw->pw_uid, pw->pw_gid) < 0)
		err(1, "backend init failed");

	if (mkdir(PATH_SPOOL PATH_OFFLINE, 01777) < 0 && errno != EEXIST)
		err(1, "mkdir: %s", PATH_SPOOL PATH_OFFLINE);
	if (chmod(PATH_SPOOL PATH_OFFLINE, 01777) < 0)
		err(1, "chmod: %s", PATH_SPOOL PATH_OFFLINE);
	if (chown(PATH_SPOOL PATH_OFFLINE, 0, 0) < 0)
		err(1, "chmod: %s", PATH_SPOOL PATH_OFFLINE);
@


1.108
log
@imsg_compose_event() return value was never checked. Make it fatal() if needed.

ok jacekm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.107 2010/05/27 15:36:04 gilles Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d31 1
d49 1
d62 1
a62 1
int		 parent_enqueue_offline(struct smtpd *, char *);
a63 2
int		 setup_spool(uid_t, gid_t);
int		 path_starts_with(char *, char *);
d71 2
a75 2
int __b64_pton(char const *, unsigned char *, size_t);

a118 11
	if (iev->proc == PROC_QUEUE) {
		switch (imsg->hdr.type) {
		case IMSG_PARENT_ENQUEUE_OFFLINE:
			if (! parent_enqueue_offline(env, imsg->data))
				imsg_compose_event(iev,
				    IMSG_PARENT_ENQUEUE_OFFLINE, 0, 0, -1,
				    NULL, 0);
			return;
		}
	}

d172 1
d377 1
a377 1
					    "message; smtpctl %s", cause);
d380 1
a380 3
				imsg_compose_event(env->sc_ievs[PROC_QUEUE],
				    IMSG_PARENT_ENQUEUE_OFFLINE, 0, 0, -1,
				    NULL, 0);
d474 1
a474 1
	if ((env.sc_pw =  getpwnam(SMTPD_USER)) == NULL)
d477 2
a478 3
	if (!setup_spool(env.sc_pw->pw_uid, 0))
		errx(1, "invalid directory permissions");

d521 2
a554 1
	env->sc_instances[PROC_RUNNER] = 1;
a564 1
	env->sc_title[PROC_RUNNER] = "runner";
a572 1
	child_add(env, runner(env), CHILD_DAEMON, PROC_RUNNER);
a618 130
int
setup_spool(uid_t uid, gid_t gid)
{
	unsigned int	 n;
	char		*paths[] = { PATH_INCOMING, PATH_ENQUEUE, PATH_QUEUE,
				     PATH_RUNQUEUE, PATH_PURGE,
				     PATH_OFFLINE, PATH_BOUNCE };
	char		 pathname[MAXPATHLEN];
	struct stat	 sb;
	int		 ret;

	if (! bsnprintf(pathname, sizeof(pathname), "%s", PATH_SPOOL))
		fatal("snprintf");

	if (stat(pathname, &sb) == -1) {
		if (errno != ENOENT) {
			warn("stat: %s", pathname);
			return 0;
		}

		if (mkdir(pathname, 0711) == -1) {
			warn("mkdir: %s", pathname);
			return 0;
		}

		if (chown(pathname, 0, 0) == -1) {
			warn("chown: %s", pathname);
			return 0;
		}

		if (stat(pathname, &sb) == -1)
			err(1, "stat: %s", pathname);
	}

	/* check if it's a directory */
	if (!S_ISDIR(sb.st_mode)) {
		warnx("%s is not a directory", pathname);
		return 0;
	}

	/* check that it is owned by uid/gid */
	if (sb.st_uid != 0 || sb.st_gid != 0) {
		warnx("%s must be owned by root:wheel", pathname);
		return 0;
	}

	/* check permission */
	if ((sb.st_mode & (S_IRUSR|S_IWUSR|S_IXUSR)) != (S_IRUSR|S_IWUSR|S_IXUSR) ||
	    (sb.st_mode & (S_IRGRP|S_IWGRP|S_IXGRP)) != S_IXGRP ||
	    (sb.st_mode & (S_IROTH|S_IWOTH|S_IXOTH)) != S_IXOTH) {
		warnx("%s must be rwx--x--x (0711)", pathname);
		return 0;
	}

	ret = 1;
	for (n = 0; n < nitems(paths); n++) {
		mode_t	mode;
		uid_t	owner;
		gid_t	group;

		if (!strcmp(paths[n], PATH_OFFLINE)) {
			mode = 01777;
			owner = 0;
			group = 0;
		} else {
			mode = 0700;
			owner = uid;
			group = gid;
		}

		if (! bsnprintf(pathname, sizeof(pathname), "%s%s", PATH_SPOOL,
			paths[n]))
			fatal("snprintf");

		if (stat(pathname, &sb) == -1) {
			if (errno != ENOENT) {
				warn("stat: %s", pathname);
				ret = 0;
				continue;
			}

			/* chmod is deffered to avoid umask effect */
			if (mkdir(pathname, 0) == -1) {
				ret = 0;
				warn("mkdir: %s", pathname);
			}

			if (chown(pathname, owner, group) == -1) {
				ret = 0;
				warn("chown: %s", pathname);
			}

			if (chmod(pathname, mode) == -1) {
				ret = 0;
				warn("chmod: %s", pathname);
			}

			if (stat(pathname, &sb) == -1)
				err(1, "stat: %s", pathname);
		}

		/* check if it's a directory */
		if (!S_ISDIR(sb.st_mode)) {
			ret = 0;
			warnx("%s is not a directory", pathname);
		}

		/* check that it is owned by owner/group */
		if (sb.st_uid != owner) {
			ret = 0;
			warnx("%s is not owned by uid %d", pathname, owner);
		}
		if (sb.st_gid != group) {
			ret = 0;
			warnx("%s is not owned by gid %d", pathname, group);
		}

		/* check permission */
		if ((sb.st_mode & 07777) != mode) {
			char mode_str[12];

			ret = 0;
			strmode(mode, mode_str);
			mode_str[10] = '\0';
			warnx("%s must be %s (%o)", pathname, mode_str + 1, mode);
		}
	}
	return ret;
}

d661 5
a665 2
		n = snprintf(ebuf, sizeof ebuf, "getpwnam: %s",
		    errno ? strerror(errno) : "no such user");
d748 2
a749 1
	if (deliver->mode == A_EXT) {
d760 2
a761 1
	if (deliver->mode == A_MAILDIR) {
a790 4
		if (fflush(fp) == EOF || ferror(fp))
			error2("write error");
		if (fsync(fd) < 0)
			error2("fsync");
d800 2
a801 1
	if (deliver->mode == A_FILENAME) {
a835 4
		if (fflush(fp) == EOF || ferror(fp))
			error2("write error");
		if (fsync(fd) < 0)
			error2("fsync");
d846 2
a847 2
int
parent_enqueue_offline(struct smtpd *env, char *runner_path)
d849 3
a851 1
	char		 path[MAXPATHLEN];
d853 1
a853 1
	struct stat	 sb;
d855 2
d858 2
a859 1
	log_debug("parent_enqueue_offline: path %s", runner_path);
d861 3
a863 2
	if (! bsnprintf(path, sizeof(path), "%s%s", PATH_SPOOL, runner_path))
		fatalx("parent_enqueue_offline: filename too long");
d865 14
a878 7
	if (! path_starts_with(path, PATH_SPOOL PATH_OFFLINE))
		fatalx("parent_enqueue_offline: path outside offline dir");

	if (lstat(path, &sb) == -1) {
		if (errno == ENOENT) {
			log_warn("parent_enqueue_offline: %s", path);
			return (0);
d880 1
a880 1
		fatal("parent_enqueue_offline: lstat");
d883 4
a886 7
	if (chflags(path, 0) == -1) {
		if (errno == ENOENT) {
			log_warn("parent_enqueue_offline: %s", path);
			return (0);
		}
		fatal("parent_enqueue_offline: chflags");
	}
d888 3
a890 7
	errno = 0;
	if ((pw = getpwuid(sb.st_uid)) == NULL) {
		log_warn("parent_enqueue_offline: getpwuid for uid %d failed",
		    sb.st_uid);
		unlink(path);
		return (0);
	}
d892 3
a894 7
	if (! S_ISREG(sb.st_mode)) {
		log_warnx("file %s (uid %d) not regular, removing", path, sb.st_uid);
		if (S_ISDIR(sb.st_mode))
			rmdir(path);
		else
			unlink(path);
		return (0);
d897 18
a914 2
	if ((pid = fork()) == -1)
		fatal("parent_enqueue_offline: fork");
d916 7
a922 23
	if (pid == 0) {
		char	*envp[2], *p, *tmp;
		FILE	*fp;
		size_t	 len;
		arglist	 args;

		bzero(&args, sizeof(args));

		if (setgroups(1, &pw->pw_gid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) ||
		    closefrom(STDERR_FILENO + 1) == -1) {
			unlink(path);
			_exit(1);
		}

		if ((fp = fopen(path, "r")) == NULL) {
			unlink(path);
			_exit(1);
		}
		unlink(path);

		if (chdir(pw->pw_dir) == -1 && chdir("/") == -1)
d924 3
a926 7

		if (setsid() == -1 ||
		    signal(SIGPIPE, SIG_DFL) == SIG_ERR ||
		    dup2(fileno(fp), STDIN_FILENO) == -1)
			_exit(1);

		if ((p = fgetln(fp, &len)) == NULL)
d928 15
a942 24

		if (p[len - 1] != '\n')
			_exit(1);
		p[len - 1] = '\0';

		addargs(&args, "%s", "sendmail");

		while ((tmp = strsep(&p, "|")) != NULL)
			addargs(&args, "%s", tmp);

		if (lseek(fileno(fp), len, SEEK_SET) == -1)
			_exit(1);

		envp[0] = "PATH=" _PATH_DEFPATH;
		envp[1] = (char *)NULL;
		environ = envp;

		execvp(PATH_SMTPCTL, args.list);
		_exit(1);
	}

	child_add(env, pid, CHILD_ENQUEUE_OFFLINE, -1);

	return (1);
a976 12
path_starts_with(char *file, char *prefix)
{
	char	 rprefix[MAXPATHLEN];
	char	 rfile[MAXPATHLEN];

	if (realpath(file, rfile) == NULL || realpath(prefix, rprefix) == NULL)
		return (-1);

	return (strncmp(rfile, rprefix, strlen(rprefix)) == 0);
}

int
d1020 21
@


1.107
log
@when a rule has two conditions (ie: accept for { domain foo, domain bar } )
expand to two rules each having its own condition rather than one rule
with a tail queue of conditions. this simplifies code a bit and removes a
couple hacks.

basic testing by oga and me
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.106 2010/05/23 18:44:14 jacekm Exp $	*/
d780 1
a780 1
int
d784 2
a785 1
	int	ret;
d787 1
a787 4
	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) != -1)
		imsg_event_add(iev);
	return (ret);
@


1.106
log
@When executing external mda, call dup2, closefrom, and chdir before
setresuid because after dropping superuser privileges the process
cannot be trusted to call these.

Thanks to oga@@, kettenis@@, and nicm@@ for confirming my paranoia.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.105 2010/05/21 08:45:02 jacekm Exp $	*/
a299 1
	struct cond		*cond;
a320 4
		TAILQ_FOREACH(cond, &r->r_conditions, c_entry) {
			imsg_compose_event(env->sc_ievs[proc], IMSG_CONF_CONDITION,
			    0, 0, -1, cond, sizeof(*cond));
		}
@


1.105
log
@Use _exit(2) in mda helper child process.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.104 2010/05/20 18:35:33 gilles Exp $	*/
d871 9
a879 1
		fatal("forkmda: cannot restore privileges");
d883 1
a883 5
		fatal("forkmda: cannot drop privileges");
	if (dup2(pipefd[0], STDIN_FILENO) < 0 ||
	    dup2(allout, STDOUT_FILENO) < 0 ||
	    dup2(allout, STDERR_FILENO) < 0)
		fatal("forkmda: dup2");
a891 4
	if (chdir(pw->pw_dir) < 0 && chdir("/") < 0)
		error("chdir");
	if (closefrom(STDERR_FILENO + 1) < 0)
		error("closefrom");
@


1.104
log
@S_ISREG() should be called on st.st_mode not st.st_flags
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.103 2010/05/09 15:24:49 gilles Exp $	*/
d994 1
a994 1
	fatalx("forkmda: unknown mode");
@


1.103
log
@in recent change, an assignation was removed which would cause a bogus
pointer deref if we actually went through this code path (reload, does
not work yet so it is disabled)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.102 2010/04/21 18:54:43 jacekm Exp $	*/
d965 1
a965 1
		if (S_ISREG(sb.st_flags) && flock(fd, LOCK_EX) < 0)
@


1.102
log
@Runner process is just a helper for queue, so tear down its imsg
channels to parent, mda, mta, lka, smtp, and control.  This leaves
just the channel to queue, which forwards imsgs on runner's behalf
and redirects any replies back to it.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.101 2010/04/20 15:34:56 jacekm Exp $	*/
d141 1
@


1.101
log
@Kill *2400* lines of code by abstracting common bits of the imsg handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.100 2010/04/20 01:01:43 jacekm Exp $	*/
d119 1
a119 1
	if (iev->proc == PROC_RUNNER) {
a175 2
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, imsg->data, sizeof(int));
d394 1
a394 1
				imsg_compose_event(env->sc_ievs[PROC_RUNNER],
d435 1
a435 2
		{ PROC_QUEUE,	imsg_dispatch },
		{ PROC_RUNNER,	imsg_dispatch }
@


1.100
log
@setproctitle(3) the parent process to "[priv]" to match other OpenBSD
daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.99 2010/04/20 00:57:22 jacekm Exp $	*/
d49 1
a55 8
void		 parent_dispatch_lka(int, short, void *);
void		 parent_dispatch_mda(int, short, void *);
void		 parent_dispatch_mfa(int, short, void *);
void		 parent_dispatch_mta(int, short, void *);
void		 parent_dispatch_smtp(int, short, void *);
void		 parent_dispatch_runner(int, short, void *);
void		 parent_dispatch_queue(int, short, void *);
void		 parent_dispatch_control(int, short, void *);
d72 1
d76 111
a333 452
parent_dispatch_lka(int imsgfd, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_LKA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("parent_dispatch_lka: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_PARENT_FORWARD_OPEN: {
			struct forward_req *fwreq = imsg.data;
			int fd;

			IMSG_SIZE_CHECK(fwreq);

			fd = parent_forward_open(fwreq->pw_name);
			fwreq->status = 0;
			if (fd == -2) {
				/* user has no ~/.forward.  it is optional, so
				 * set status to ok. */
				fwreq->status = 1;
				fd = -1;
			} else if (fd != -1)
				fwreq->status = 1;
			imsg_compose_event(iev, IMSG_PARENT_FORWARD_OPEN, 0, 0, fd, fwreq, sizeof(*fwreq));
			break;
		}
		default:
			log_warnx("parent_dispatch_lka: got imsg %d",
			    imsg.hdr.type);
			fatalx("parent_dispatch_lka: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
parent_dispatch_mfa(int fd, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_MFA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("parent_dispatch_mfa: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("parent_dispatch_mfa: got imsg %d",
			    imsg.hdr.type);
			fatalx("parent_dispatch_mfa: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
parent_dispatch_mta(int fd, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_MTA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("parent_dispatch_mta: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("parent_dispatch_mta: got imsg %d",
			    imsg.hdr.type);
			fatalx("parent_dispatch_mta: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
parent_dispatch_mda(int imsgfd, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_MDA];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("parent_dispatch_mda: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_PARENT_FORK_MDA:
			forkmda(env, iev, imsg.hdr.peerid, imsg.data);
			break;

		default:
			log_warnx("parent_dispatch_mda: got imsg %d",
			    imsg.hdr.type);
			fatalx("parent_dispatch_mda: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
parent_dispatch_smtp(int fd, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_SMTP];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("parent_dispatch_smtp: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_PARENT_SEND_CONFIG: {
			parent_send_config_listeners(env);
			break;
		}
		case IMSG_PARENT_AUTHENTICATE: {
			struct auth	*req = imsg.data;

			IMSG_SIZE_CHECK(req);

			req->success = authenticate_user(req->user, req->pass);

			imsg_compose_event(iev, IMSG_PARENT_AUTHENTICATE, 0, 0,
			    -1, req, sizeof(*req));
			break;
		}
		default:
			log_warnx("parent_dispatch_smtp: got imsg %d",
			    imsg.hdr.type);
			fatalx("parent_dispatch_smtp: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
parent_dispatch_queue(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_QUEUE];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("parent_dispatch_queue: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_warnx("parent_dispatch_queue: got imsg %d",
			    imsg.hdr.type);
			fatalx("parent_dispatch_queue: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
parent_dispatch_runner(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_RUNNER];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("parent_dispatch_runner: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_PARENT_ENQUEUE_OFFLINE:
			if (! parent_enqueue_offline(env, imsg.data))
				imsg_compose_event(iev, IMSG_PARENT_ENQUEUE_OFFLINE,
				    0, 0, -1, NULL, 0);
			break;
		default:
			log_warnx("parent_dispatch_runner: got imsg %d",
			    imsg.hdr.type);
			fatalx("parent_dispatch_runner: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
parent_dispatch_control(int sig, short event, void *p)
{
	struct smtpd		*env = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = env->sc_ievs[PROC_CONTROL];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("parent_dispatch_control: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CONF_RELOAD: {
			struct reload *r = imsg.data;
			struct smtpd newenv;
			
			r->ret = 0;
			if (parse_config(&newenv, env->sc_conffile, 0) == 0) {
				
				(void)strlcpy(env->sc_hostname, newenv.sc_hostname,
				    sizeof(env->sc_hostname));
				env->sc_listeners = newenv.sc_listeners;
				env->sc_maps = newenv.sc_maps;
				env->sc_rules = newenv.sc_rules;
				env->sc_rules = newenv.sc_rules;
				env->sc_ssl = newenv.sc_ssl;
				
				parent_send_config_client_certs(env);
				parent_send_config_ruleset(env, PROC_MFA);
				parent_send_config_ruleset(env, PROC_LKA);
				imsg_compose_event(env->sc_ievs[PROC_SMTP],
				    IMSG_CONF_RELOAD, 0, 0, -1, NULL, 0);
				r->ret = 1;
			}
			imsg_compose_event(iev, IMSG_CONF_RELOAD, 0, 0, -1, r, sizeof(*r));
			break;
		}
		case IMSG_CTL_VERBOSE: {
			int verbose;

			IMSG_SIZE_CHECK(&verbose);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);

			/* forward to other processes */
			imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, &verbose, sizeof(verbose));
			imsg_compose_event(env->sc_ievs[PROC_MDA], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, &verbose, sizeof(verbose));
			imsg_compose_event(env->sc_ievs[PROC_MFA], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, &verbose, sizeof(verbose));
			imsg_compose_event(env->sc_ievs[PROC_MTA], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, &verbose, sizeof(verbose));
			imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, &verbose, sizeof(verbose));
			imsg_compose_event(env->sc_ievs[PROC_RUNNER], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, &verbose, sizeof(verbose));
			imsg_compose_event(env->sc_ievs[PROC_SMTP], IMSG_CTL_VERBOSE,
	    		    0, 0, -1, &verbose, sizeof(verbose));
			break;
		}
		default:
			log_warnx("parent_dispatch_control: got imsg %d",
			    imsg.hdr.type);
			fatalx("parent_dispatch_control: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

void
d431 8
a438 8
		{ PROC_CONTROL,	parent_dispatch_control },
		{ PROC_LKA,	parent_dispatch_lka },
		{ PROC_MDA,	parent_dispatch_mda },
		{ PROC_MFA,	parent_dispatch_mfa },
		{ PROC_MTA,	parent_dispatch_mta },
		{ PROC_SMTP,	parent_dispatch_smtp },
		{ PROC_QUEUE,	parent_dispatch_queue },
		{ PROC_RUNNER,	parent_dispatch_runner }
d521 1
d1164 34
@


1.99
log
@Make smtpd -d produce verbose output, ie. restore behaviour from before
rev. 1.94.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.98 2010/04/19 20:09:58 jacekm Exp $	*/
d941 2
@


1.98
log
@- use perror(3)
- call _exit(2) instead of exit(3) in forked processes
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.97 2010/04/19 08:14:07 jacekm Exp $	*/
d798 1
@


1.97
log
@Simplify local delivery codepath:
- replace uses of struct batch in the parent with simpler struct delivery.
- replace IMSG_BATCH_* dance with single IMSG_MDA_SESS_NEW.
- make mda assume it delivers to external program over a pipe.
- fork helper process when delivering to maildir or a file.

New feature: upon external mda failure use last line of its output
as an error message.

With input and tests from nicm@@.

OK nicm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.96 2010/03/01 13:04:03 gilles Exp $	*/
d1214 1
a1214 1
#define error(m) { printf("%s: %s\n", m, strerror(errno)); exit(1); }
d1291 1
a1291 1
		exit(0);
d1336 1
a1336 1
		exit(0);
@


1.96
log
@typo in warning log

spotted by Seth Wright <seth@@crosse.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.95 2010/01/10 08:59:19 gilles Exp $	*/
d64 3
a66 6
int		 parent_open_message_file(struct batch *);
int		 parent_mailbox_open(char *, struct passwd *, struct batch *);
int		 parent_filename_open(char *, struct passwd *, struct batch *);
int		 parent_maildir_open(char *, struct passwd *, struct batch *);
int		 parent_maildir_init(struct passwd *, char *);
int		 parent_external_mda(char *, struct passwd *, struct batch *);
a77 4
void		 parent_mda_permfail(struct smtpd *, struct batch *);
void		 parent_mda_tempfail(struct smtpd *, struct batch *);
void		 parent_mda_success(struct smtpd *, struct batch *);

d416 2
a417 88
		case IMSG_PARENT_MAILBOX_OPEN: {
			struct batch *batchp = imsg.data;
			struct path *path;
			struct passwd *pw;
			char *pw_name;
			char *file;
			u_int8_t i;
			int fd;
			struct action_handler {
				enum action_type action;
				int (*handler)(char *, struct passwd *, struct batch *);
			} action_hdl_table[] = {
				{ A_MBOX,	parent_mailbox_open },
				{ A_MAILDIR,	parent_maildir_open },
				{ A_EXT,	parent_external_mda },
				{ A_FILENAME,	parent_filename_open }
			};

			IMSG_SIZE_CHECK(batchp);

			batchp->env = env;
			path = &batchp->message.recipient;
			if (batchp->type & T_BOUNCE_BATCH) {
				path = &batchp->message.sender;
			}
			
			for (i = 0; i < nitems(action_hdl_table); ++i)
				if (action_hdl_table[i].action == path->rule.r_action)
					break;
			if (i == nitems(action_hdl_table))
				fatalx("parent_dispatch_mda: unknown action");

			file = path->rule.r_value.path;

			if (path->rule.r_action == A_FILENAME) {
				file = path->u.filename;
				pw_name = SMTPD_USER;
			}
			else if (path->rule.r_user != NULL)
				pw_name = path->rule.r_user;
			else
				pw_name = path->pw_name;

			errno = 0;
			pw = getpwnam(pw_name);
			if (pw == NULL) {
				if (errno) {
					log_warn("%s: getpwnam: %s",
					    batchp->message.message_id,
					    pw_name);
					parent_mda_tempfail(env, batchp);
				} else {
					log_warnx("%s: getpwnam: %s: user does not exist",
					    batchp->message.message_id,
					    pw_name);
					parent_mda_permfail(env, batchp);
				}
				break;
			}

			if (setegid(pw->pw_gid) || seteuid(pw->pw_uid))
				fatal("privdrop failed");

			fd = action_hdl_table[i].handler(file, pw, batchp);

			if (setegid(0) || seteuid(0))
				fatal("privraise failed");

			if (fd == -1) {
				log_warnx("%s: could not init delivery for %s",
				     batchp->message.message_id, pw_name);
				parent_mda_tempfail(env, batchp);
			} else
				imsg_compose_event(iev,
				    IMSG_PARENT_MAILBOX_OPEN, 0, 0, fd, batchp,
				    sizeof(*batchp));
			break;
		}
		case IMSG_PARENT_MESSAGE_OPEN: {
			struct batch *batchp = imsg.data;
			int fd;

			IMSG_SIZE_CHECK(batchp);

			fd = parent_open_message_file(batchp);
			imsg_compose_event(iev, IMSG_PARENT_MESSAGE_OPEN,
			    0, 0, fd, batchp, sizeof(struct batch));

a418 45
		}
		case IMSG_PARENT_MAILDIR_FAIL:
		case IMSG_PARENT_MAILDIR_RENAME: {
			char		 tmp[MAXPATHLEN], new[MAXPATHLEN];
			struct batch	*batchp = imsg.data;
			struct path	*path;
			struct passwd	*pw;
			int		 ret;
			char		*pw_name;

			IMSG_SIZE_CHECK(batchp);

			path = &batchp->message.recipient;
			if (batchp->type & T_BOUNCE_BATCH) {
				path = &batchp->message.sender;
			}

			if (path->rule.r_user != NULL)
				pw_name = path->rule.r_user;
			else
				pw_name = path->pw_name;

			errno = 0;
			pw = getpwnam(pw_name);
			if (pw == NULL) {
				if (errno) {
					log_warn("%s: getpwnam: %s",
					    batchp->message.message_id,
					    pw_name);
					parent_mda_tempfail(env, batchp);
				} else {
					log_warnx("%s: getpwnam: %s: user does not exist",
					    batchp->message.message_id,
					    pw_name);
					parent_mda_permfail(env, batchp);
				}
				break;
			}

			if (! bsnprintf(tmp, sizeof(tmp), "%s/tmp/%s",
				path->rule.r_value.path, batchp->message.message_uid))
				fatal("parent_dispatch_mda: snprintf");
			if (! bsnprintf(new, sizeof(new), "%s/new/%s",
				path->rule.r_value.path, batchp->message.message_uid))
				fatal("parent_dispatch_mda: snprintf");
a419 21
			if (seteuid(pw->pw_uid) == -1)
				fatal("privdrop failed");

			if (imsg.hdr.type == IMSG_PARENT_MAILDIR_FAIL) {
				unlink(tmp);
				ret = 0;
			} else
				ret = rename(tmp, new);

			if (seteuid(0) == -1)
				fatal("privraise failed");

			if (ret < 0) {
				log_warn("%s: %s: cannot rename to the 'new' directory",
				    batchp->message.message_id, tmp);
				parent_mda_tempfail(env, batchp);
				unlink(tmp);
			} else
				parent_mda_success(env, batchp);
			break;
		}
d732 3
a734 7
				if (fail) {
					log_warnx("external mda %s", cause);
					parent_mda_tempfail(env, &child->mda_batch);
				} else {
					log_debug("external mda %s", cause);
					parent_mda_success(env, &child->mda_batch);
				}
d1142 3
a1144 2
int
parent_open_message_file(struct batch *batchp)
d1146 5
a1150 4
	int fd;
	char pathname[MAXPATHLEN];
	u_int16_t hval;
	struct message *messagep;
d1152 1
a1152 2
	messagep = &batchp->message;
	hval = queue_hash(messagep->message_id);
d1154 8
a1161 3
	if (! bsnprintf(pathname, sizeof(pathname), "%s%s/%d/%s/message",
		PATH_SPOOL, PATH_QUEUE, hval, batchp->message_id))
		fatal("parent_open_message_file: snprintf");
d1163 11
a1173 3
	fd = open(pathname, O_RDONLY);
	return fd;
}
d1175 13
a1187 23
int
parent_mailbox_open(char *path, struct passwd *pw, struct batch *batchp)
{
	pid_t pid;
	int pipefd[2];
	struct child *child;
	char sender[MAX_PATH_SIZE];

	/* This can never happen, but better safe than sorry. */
	if (! bsnprintf(sender, MAX_PATH_SIZE, "%s@@%s",
		batchp->message.sender.user,
		batchp->message.sender.domain))
		fatal("parent_mailbox_open: bogus email length");

	log_debug("executing mail.local");
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pipefd) == -1)
		return -1;

	/* raise privileges because mail.local needs root to
	 * deliver to user mailboxes.
	 */
	if (seteuid(0) == -1)
		fatal("privraise failed");
d1190 5
a1194 1
	if (pid == -1) {
d1197 2
a1198 1
		return -1;
d1201 7
a1207 1
	if (pid == 0) {
d1209 3
a1211 10
		close(STDOUT_FILENO);
		close(STDERR_FILENO);
		dup2(pipefd[1], 0);

		/* avoid hangs by setting a 5m timeout */
		alarm(300);

		execlp(PATH_MAILLOCAL, "mail.local", "-f", sender, pw->pw_name,
		    (void *)NULL);
		_exit(1);
d1214 42
a1255 2
	if (seteuid(pw->pw_uid) == -1)
		fatal("privdrop failed");
d1257 35
a1291 23
	child = child_add(batchp->env, pid, CHILD_MDA, -1);

	/* Each child relates to a batch; record this relationship. */
	child->mda_batch = *batchp;

	close(pipefd[1]);
	return pipefd[0];
}

int
parent_maildir_init(struct passwd *pw, char *root)
{
	u_int8_t i;
	char pathname[MAXPATHLEN];
	char *subdir[] = { "/", "/tmp", "/cur", "/new" };

	for (i = 0; i < nitems(subdir); ++i) {
		if (! bsnprintf(pathname, sizeof(pathname), "%s%s", root,
			subdir[i]))
			return 0;
		if (mkdir(pathname, 0700) == -1)
			if (errno != EEXIST)
				return 0;
d1293 1
d1295 31
a1325 35
	return 1;
}

int
parent_maildir_open(char *path, struct passwd *pw, struct batch *batchp)
{
	char tmp[MAXPATHLEN];
	int mode = O_CREAT|O_RDWR|O_TRUNC|O_SYNC;

	if (! parent_maildir_init(pw, path))
		return -1;

	if (! bsnprintf(tmp, sizeof(tmp), "%s/tmp/%s", path,
		batchp->message.message_uid))
		return -1;

	return open(tmp, mode, 0600);
}

int
parent_external_mda(char *path, struct passwd *pw, struct batch *batchp)
{
	struct child *child;
	pid_t pid;
	int pipefd[2];
	arglist args;
	char *word;
	char *envp[2];

	log_debug("executing filter as user: %s", pw->pw_name);

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pipefd) == -1) {
		if (errno == ENFILE) {
			log_warn("parent_external_mda: socketpair");
			return -1;
d1327 10
a1336 1
		fatal("parent_external_mda: socketpair");
d1339 1
a1339 54
	pid = fork();
	if (pid == -1) {
		log_warn("parent_external_mda: fork");
		close(pipefd[0]);
		close(pipefd[1]);
		return -1;
	}

	if (pid == 0) {
		if (seteuid(0) == -1)
			fatal("privraise failed");
		if (setgroups(1, &pw->pw_gid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
			fatal("cannot drop privileges");

		bzero(&args, sizeof(args));
		while ((word = strsep(&path, " \t")) != NULL)
			if (*word != '\0')
				addargs(&args, "%s", word);

		if (setsid() == -1)
			fatal("setsid");

		if (signal(SIGPIPE, SIG_DFL) == SIG_ERR)
			fatal("signal");

		if (dup2(pipefd[0], STDIN_FILENO) == -1)
			fatal("dup2");

		if (chdir(pw->pw_dir) == -1 && chdir("/") == -1)
			fatal("chdir");

		if (closefrom(STDERR_FILENO + 1) == -1)
			fatal("closefrom");

		/* avoid hangs by setting a 5m timeout */
		alarm(300);

		envp[0] = "PATH=" _PATH_DEFPATH;
		envp[1] = (char *)NULL;
		environ = envp;

		execvp(args.list[0], args.list);
		_exit(1);
	}

	child = child_add(batchp->env, pid, CHILD_MDA, -1);

	/* Each child relates to a batch; record this relationship. */
	child->mda_batch = *batchp;

	close(pipefd[0]);
	return pipefd[1];
d1341 2
a1454 29
parent_filename_open(char *path, struct passwd *pw, struct batch *batchp)
{
	int fd;
	int mode = O_CREAT|O_APPEND|O_RDWR|O_SYNC|O_NONBLOCK;

	fd = open(path, mode, 0600);
	if (fd == -1) {
		if (errno == EWOULDBLOCK)
			goto lockfail;
		return -1;
	}

	if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
		if (errno == EWOULDBLOCK)
			goto lockfail;
		fatal("flock");
	}

	return fd;

lockfail:
	if (fd != -1)
		close(fd);

	batchp->message.status |= S_MESSAGE_LOCKFAILURE;
	return -1;
}

int
a1506 23
}

void
parent_mda_permfail(struct smtpd *env, struct batch *b)
{
	b->message.status |= S_MESSAGE_PERMFAILURE;
	imsg_compose_event(env->sc_ievs[PROC_MDA], IMSG_MDA_FINALIZE,
	    0, 0, -1, b, sizeof(*b));
}

void
parent_mda_tempfail(struct smtpd *env, struct batch *b)
{
	imsg_compose_event(env->sc_ievs[PROC_MDA], IMSG_MDA_FINALIZE,
	    0, 0, -1, b, sizeof(*b));
}

void
parent_mda_success(struct smtpd *env, struct batch *b)
{
	b->message.status &= ~S_MESSAGE_TEMPFAILURE;
	imsg_compose_event(env->sc_ievs[PROC_MDA], IMSG_MDA_FINALIZE,
	    0, 0, -1, b, sizeof(*b));
@


1.95
log
@have smtpd errx() at startup if no hostname could be detected either from
a gethostname() call or from a hostname directive in smtpd.conf

discussed with jacekm@@, i initially intended to only warn but errx seems to
be a better solution for now
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.94 2010/01/03 14:37:37 chl Exp $	*/
d580 1
a580 1
			log_warnx("parent_dispatch_mfa: got imsg %d",
@


1.94
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging on runtime.

Based on claudio@@'s work on ripd, ospfd, ospf6d, dvmrpd, ldpd, bgpd.

With help/ideas/testing from gilles@@ jacekm@@ todd@@

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.93 2009/12/24 14:19:46 gilles Exp $	*/
d1016 3
@


1.93
log
@kill PATH_RUNQUEUEHIGH and PATH_RUNQUEUELOW, i had great plans for them but
they're still unused months later and there's many ways to achieve having a
set of priorities on envelopes without needing additionnal queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.92 2009/12/14 19:56:55 jacekm Exp $	*/
d61 1
d650 45
d804 25
d931 1
a931 1
	int		 debug;
d947 1
d953 1
d975 1
d1009 1
@


1.92
log
@Tweak the logic behind setting the fd limits so that smtpd is less likely
to get upset by custom soft/hard ulimit settings.

Suggested by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.91 2009/12/14 13:17:51 jacekm Exp $	*/
d1073 1
a1073 2
				     PATH_RUNQUEUE, PATH_RUNQUEUELOW,
				     PATH_RUNQUEUEHIGH, PATH_PURGE,
@


1.91
log
@Do non-blocking I/O when delivering locally over a pipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.90 2009/12/13 22:02:55 jacekm Exp $	*/
d982 11
a992 5
	 * Each process has fd soft limit doubled.  This is done with smtp,
	 * mta and mda in mind, because all of them require 2 fds per one
	 * session.  Additionally, processes such as queue may bump it even
	 * further as in the worst case scenarios they could hold many more
	 * fds open.
d994 1
a994 1
	fdlimit(getdtablesize() * 2);
@


1.90
log
@Use safe fd limits in smtp, lka, queue, and control.  Removes a
possibility for fd-starvation fatal when under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.89 2009/11/14 18:48:05 chl Exp $	*/
d1345 1
a1345 1
	if (pipe(pipefd) == -1) {
d1347 1
a1347 1
			log_warn("parent_external_mda: pipe");
d1350 1
a1350 1
		fatal("parent_external_mda: pipe");
@


1.89
log
@remove duplicate header include

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.88 2009/11/03 11:10:43 jacekm Exp $	*/
a28 1
#include <sys/resource.h>
a868 1
	struct rlimit	 rl;
a949 16
	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("smtpd: failed to get resource limit");

	log_debug("smtpd: max open files %lld", rl.rlim_max);

	/*
	 * Allow the maximum number of open file descriptors for this
	 * login class (which should be the class "daemon" by default).
	 */
	rl.rlim_cur = rl.rlim_max;
	if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("smtpd: failed to set resource limit");

	env.sc_maxconn = (rl.rlim_cur / 4) * 3;
	log_debug("smtpd: will accept at most %d clients", env.sc_maxconn);

d980 9
@


1.88
log
@Improve error logging.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.87 2009/10/19 20:00:46 gilles Exp $	*/
a36 1
#include <paths.h>
@


1.87
log
@users within virtual domains do not necessarily map to a real user account,
teach smtpd how to deliver using specific user permissions:

	accept for virtual map "foo" deliver to maildir "/m/%d/%u" user foo

will deliver mail under /m/domain/user as user foo

idea and initial diff discussed with jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.86 2009/10/07 18:19:39 gilles Exp $	*/
d470 4
a473 1
				if (errno)
d475 4
a478 1
				else
d480 1
d492 3
a494 1
			if (fd == -1)
d496 1
a496 1
			else
a529 1

d538 4
a541 1
				if (errno)
d543 4
a546 1
				else
d548 1
d562 4
a565 3
			if (imsg.hdr.type == IMSG_PARENT_MAILDIR_FAIL)
				ret = -1;
			else
d572 3
a575 1
				parent_mda_tempfail(env, batchp);
@


1.86
log
@now that mfa no longer does ruleset matching, parent no longer needs to
send it the ruleset configuration, and mfa no longer needs to interpret
it and load it in memory. kill kill kill. as an added bonus: removes 88
lines of code :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.85 2009/09/04 11:49:23 jacekm Exp $	*/
d457 1
a457 1
			pw_name = path->pw_name;
d462 4
a499 1

d512 1
d521 6
d528 1
a528 1
			pw = getpwnam(path->pw_name);
@


1.85
log
@Major mda update:
- Fix: check external mda / mail.local exit code.
- Fix: check maildir rename(2) return code.
- Fix: check read(2) and write(2) return codes.
- Fix: in parent, batchp->env was not set to the env of the current process.
- Fix: clean file in tmp if maildir delivery fails.
- Fix: mark message as temporarily failed upon start, unmark upon sucessful
delivery. (safe default)
- Fix: kill all message drops, aka. PERMFAILUREs, with one exception: when the
local user no longer exists.
- Cleanup: store.c is merged with its only user, mda.c
- Feature: in parent, child_add now returns pointer to the new child struct.
This is used to store and later access child->mda_batch member in order to
associate children with their batches.
- Feature: in parent, external mda / mail.local will timeout after 5 minutes.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.84 2009/09/03 08:19:13 jacekm Exp $	*/
a122 1
	parent_send_config_ruleset(p, PROC_MFA);
@


1.84
log
@imsg_get sets errno so use fatal instead of fatalx.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.83 2009/08/27 09:21:28 jacekm Exp $	*/
a67 1
int		 parent_mailfile_rename(struct batch *, struct path *);
d78 1
a78 1
void		 child_add(struct smtpd *, pid_t, int, int);
d82 4
d391 1
a391 1
parent_dispatch_mda(int fd, short event, void *p)
d432 1
a432 1
			int desc;
d445 1
d468 1
a468 1
					batchp->message.status |= S_MESSAGE_TEMPFAILURE;
d470 1
a470 3
					batchp->message.status |= S_MESSAGE_PERMFAILURE;
				imsg_compose_event(iev, IMSG_MDA_MAILBOX_FILE, 0, 0,
				    -1, batchp, sizeof(struct batch));
d477 1
a477 3
			desc = action_hdl_table[i].handler(file, pw, batchp);
			imsg_compose_event(iev, IMSG_MDA_MAILBOX_FILE, 0, 0,
			    desc, batchp, sizeof(struct batch));
d480 1
a480 1
				fatal("privdrop failed");
d482 6
d492 1
a492 1
			int desc;
d496 1
a496 1
			desc = parent_open_message_file(batchp);
d498 2
a499 2
			imsg_compose_event(iev, IMSG_MDA_MESSAGE_FILE, 0, 0,
			    desc, batchp, sizeof(struct batch));
d503 7
a509 4
		case IMSG_PARENT_MAILBOX_RENAME: {
			struct batch *batchp = imsg.data;
			struct path *path;
			struct passwd *pw;
d518 1
d520 14
a533 2
			if (pw == NULL)
				break;			
d538 4
a541 1
			parent_mailfile_rename(batchp, path);
d546 5
d790 6
a795 1
				if (fail)
d797 2
a798 1
				else
d800 2
a819 1

d1004 1
a1004 1
void
d1018 2
d1217 2
a1218 4
		PATH_SPOOL, PATH_QUEUE, hval, batchp->message_id)) {
		batchp->message.status |= S_MESSAGE_PERMFAILURE;
		return -1;
	}
d1229 1
d1235 2
a1236 4
		batchp->message.sender.domain)) {
		batchp->message.status |= S_MESSAGE_PERMFAILURE;
		return -1;
	}
d1239 1
a1239 2
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pipefd) == -1) {
		batchp->message.status |= S_MESSAGE_PERMFAILURE;
a1240 1
	}
a1251 1
		batchp->message.status |= S_MESSAGE_PERMFAILURE;
d1261 3
d1272 4
a1275 1
	child_add(batchp->env, pid, CHILD_MDA, -1);
a1302 1
	int fd;
d1306 1
a1306 2
	if (! parent_maildir_init(pw, path)) {
		batchp->message.status |= S_MESSAGE_TEMPFAILURE;
a1307 1
	}
d1310 1
a1310 8
		batchp->message.message_uid)) {
		batchp->message.status |= S_MESSAGE_TEMPFAILURE;
		return -1;
	}

	fd = open(tmp, mode, 0600);
	if (fd == -1) {
		batchp->message.status |= S_MESSAGE_TEMPFAILURE;
a1311 1
	}
d1313 1
a1313 23
	return fd;
}

int
parent_mailfile_rename(struct batch *batchp, struct path *path)
{
	char srcpath[MAXPATHLEN];
	char dstpath[MAXPATHLEN];

	if (! bsnprintf(srcpath, sizeof(srcpath), "%s/tmp/%s",
		path->rule.r_value.path, batchp->message.message_uid) ||
	    ! bsnprintf(dstpath, sizeof(dstpath), "%s/new/%s",
		path->rule.r_value.path, batchp->message.message_uid))
		return 0;

	if (rename(srcpath, dstpath) == -1) {
		if (unlink(srcpath) == -1)
			fatal("unlink");
		batchp->message.status |= S_MESSAGE_TEMPFAILURE;
		return 0;
	}

	return 1;
d1319 1
a1330 1
			batchp->message.status |= S_MESSAGE_TEMPFAILURE;
a1340 1
		batchp->message.status |= S_MESSAGE_TEMPFAILURE;
d1372 3
d1383 4
a1386 1
	child_add(batchp->env, pid, CHILD_MDA, -1);
d1510 1
a1510 16
		/* XXX - this needs to be discussed ... */
		switch (errno) {
		case ENOTDIR:
		case ENOENT:
		case EACCES:
		case ELOOP:
		case EROFS:
		case EDQUOT:
		case EINTR:
		case EIO:
		case EMFILE:
		case ENFILE:
		case ENOSPC:
			batchp->message.status |= S_MESSAGE_TEMPFAILURE;
			break;
		case EWOULDBLOCK:
a1511 3
		default:
			batchp->message.status |= S_MESSAGE_PERMFAILURE;
		}
d1527 1
a1527 1
	batchp->message.status |= S_MESSAGE_TEMPFAILURE|S_MESSAGE_LOCKFAILURE;
d1584 23
@


1.83
log
@getpwnam failure that results in setting errno could confuse the
check for non-existent ~/.forward, so make the check more robust;
fix a fd leak under rare circumstances; use secure_file for
testing .forward file security.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.82 2009/08/07 20:21:48 gilles Exp $	*/
d264 1
a264 1
			fatalx("parent_dispatch_lka: imsg_get error");
d327 1
a327 1
			fatalx("parent_dispatch_mfa: imsg_get error");
d372 1
a372 1
			fatalx("parent_dispatch_mta: imsg_get error");
d417 1
a417 1
			fatalx("parent_dispatch_mda: imsg_get error");
d563 1
a563 1
			fatalx("parent_dispatch_smtp: imsg_get error");
d623 1
a623 1
			fatalx("parent_dispatch_runner: imsg_get error");
d673 1
a673 1
			fatalx("parent_dispatch_control: imsg_get error");
@


1.82
log
@we were linking to libkeynote to use kn_base64_encode/decode, but honestly
this was a ugly hack, and i'd rather include resolv.h and use __b64_encode
and __b64_decode as openssh does. this commit kills all references to
libkeynote in smtpd, should help a bit with porting ... no functionnal
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.81 2009/08/07 19:02:55 gilles Exp $	*/
d235 1
a235 1
parent_dispatch_lka(int fd, short event, void *p)
d271 1
a271 1
			int ret;
d275 1
a275 1
			ret = parent_forward_open(fwreq->pw_name);
d277 8
a284 5
			if (ret == -1) {
				if (errno == ENOENT)
					fwreq->status = 1;
			}
			imsg_compose_event(iev, IMSG_PARENT_FORWARD_OPEN, 0, 0, ret, fwreq, sizeof(*fwreq));
a1541 1
	struct stat sb;
d1550 1
a1550 1
		return -1;
d1555 2
a1556 1
			goto err;
d1560 5
a1564 13
	/* make sure ~/ is not writable by anyone but owner */
	if (stat(pw->pw_dir, &sb) == -1)
		goto errlog;

	if (sb.st_uid != pw->pw_uid || sb.st_mode & (S_IWGRP|S_IWOTH))
		goto errlog;

	/* make sure ~/.forward is not writable by anyone but owner */
	if (fstat(fd, &sb) == -1)
		goto errlog;

	if (sb.st_uid != pw->pw_uid || sb.st_mode & (S_IWGRP|S_IWOTH))
		goto errlog;
a1566 6

errlog:
	log_info("cannot process forward file for user %s due to wrong permissions", username);

err:
	return -1;
@


1.81
log
@wrap auth_userokay in a new function authenticate_user() and make sure
that only authenticate.c knows about bsd_auth, no functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.80 2009/08/06 16:46:57 gilles Exp $	*/
a47 2

#include <keynote.h>
@


1.80
log
@- change all occurences of T_DAEMON_BATCH,MESSAGE to T_BOUNCE_BATCH/MESSAGE
- make sure T_BOUNCE_MESSAGE is no longer OR-ed to T_MDA/MTA_MESSAGE
- define F_MESSAGE_BOUNCE flag and make sure bounce sessions set it
- teach smtpctl show queue how to recognize a bounce message
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.79 2009/08/06 13:40:45 gilles Exp $	*/
a31 1
#include <bsd_auth.h>
d576 1
a576 2
			req->success = auth_userokay(req->user, NULL,
			    "auth-smtp", req->pass);
@


1.79
log
@This commit reworks the entire mailer daemon support to actually make it
work for real. As an added bonus, it simplifies it, makes it follow the
same code path as regular messages and kills quite some code from mta,
mda and store. There's still some work needed but the most painful part
is behind us now ;)

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.78 2009/07/28 22:03:55 gilles Exp $	*/
d443 1
a443 1
			if (batchp->type & T_DAEMON_BATCH) {
d505 1
a505 1
			if (batchp->type & T_DAEMON_BATCH) {
@


1.78
log
@introduce daemon_record_message() and needed glue in queue_shared.c to
atomically create a mailer daemon out of a message. it is unreferenced
for now, this commit makes no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.77 2009/07/28 21:12:26 jsg Exp $	*/
d1014 1
a1014 1
				     PATH_OFFLINE, PATH_DAEMON };
@


1.77
log
@Use strcmp() for string comparison not ==
ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.76 2009/07/28 13:54:35 gilles Exp $	*/
d1014 1
a1014 1
				     PATH_OFFLINE };
@


1.76
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.75 2009/06/06 04:14:21 pyr Exp $	*/
d1068 1
a1068 1
		if (paths[n] == PATH_OFFLINE) {
@


1.75
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.74 2009/06/05 20:43:57 pyr Exp $	*/
d1229 2
a1230 1
		execlp(PATH_MAILLOCAL, "mail.local", "-f", sender, pw->pw_name, (void *)NULL);
@


1.74
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.73 2009/06/03 18:16:29 gilles Exp $	*/
d136 1
a136 1
	imsg_compose_event(env->sc_ibufs[PROC_SMTP], IMSG_CONF_START,
d150 3
a152 2
		imsg_composev(env->sc_ibufs[PROC_SMTP], IMSG_CONF_SSL, 0, 0, -1,
		    iov, nitems(iov));
d163 1
a163 1
		imsg_compose_event(env->sc_ibufs[PROC_SMTP], IMSG_CONF_LISTENER,
d167 1
a167 1
	imsg_compose_event(env->sc_ibufs[PROC_SMTP], IMSG_CONF_END,
d178 1
a178 1
	imsg_compose_event(env->sc_ibufs[PROC_MTA], IMSG_CONF_START,
d192 3
a194 2
		imsg_composev(env->sc_ibufs[PROC_MTA], IMSG_CONF_SSL, 0, 0, -1,
		    iov, nitems(iov));
d197 1
a197 1
	imsg_compose_event(env->sc_ibufs[PROC_MTA], IMSG_CONF_END,
d210 1
a210 1
	imsg_compose_event(env->sc_ibufs[proc], IMSG_CONF_START,
d214 1
a214 1
		imsg_compose_event(env->sc_ibufs[proc], IMSG_CONF_MAP,
d217 1
a217 1
			imsg_compose_event(env->sc_ibufs[proc], IMSG_CONF_MAP_CONTENT,
d223 1
a223 1
		imsg_compose_event(env->sc_ibufs[proc], IMSG_CONF_RULE,
d225 1
a225 1
		imsg_compose_event(env->sc_ibufs[proc], IMSG_CONF_RULE_SOURCE,
d228 1
a228 1
			imsg_compose_event(env->sc_ibufs[proc], IMSG_CONF_CONDITION,
d233 1
a233 1
	imsg_compose_event(env->sc_ibufs[proc], IMSG_CONF_END,
d241 1
d246 2
a247 1
	ibuf = env->sc_ibufs[PROC_LKA];
d254 1
a254 1
			event_del(&ibuf->ev);
d284 1
a284 1
			imsg_compose_event(ibuf, IMSG_PARENT_FORWARD_OPEN, 0, 0, ret, fwreq, sizeof(*fwreq));
d294 1
a294 1
	imsg_event_add(ibuf);
d301 1
d306 2
a307 1
	ibuf = env->sc_ibufs[PROC_MFA];
d314 1
a314 1
			event_del(&ibuf->ev);
d339 1
a339 1
	imsg_event_add(ibuf);
d346 1
d351 2
a352 1
	ibuf = env->sc_ibufs[PROC_MTA];
d359 1
a359 1
			event_del(&ibuf->ev);
d384 1
a384 1
	imsg_event_add(ibuf);
d391 1
d396 2
a397 1
	ibuf = env->sc_ibufs[PROC_MDA];
d404 1
a404 1
			event_del(&ibuf->ev);
d467 1
a467 1
				imsg_compose_event(ibuf, IMSG_MDA_MAILBOX_FILE, 0, 0,
d476 1
a476 1
			imsg_compose_event(ibuf, IMSG_MDA_MAILBOX_FILE, 0, 0,
d492 1
a492 1
			imsg_compose_event(ibuf, IMSG_MDA_MESSAGE_FILE, 0, 0,
d530 1
a530 1
	imsg_event_add(ibuf);
d537 1
d542 2
a543 1
	ibuf = env->sc_ibufs[PROC_SMTP];
d550 1
a550 1
			event_del(&ibuf->ev);
d580 1
a580 1
			imsg_compose_event(ibuf, IMSG_PARENT_AUTHENTICATE, 0, 0,
d591 1
a591 1
	imsg_event_add(ibuf);
d598 1
d603 2
a604 1
	ibuf = env->sc_ibufs[PROC_RUNNER];
d611 1
a611 1
			event_del(&ibuf->ev);
d631 1
a631 1
				imsg_compose_event(ibuf, IMSG_PARENT_ENQUEUE_OFFLINE,
d641 1
a641 1
	imsg_event_add(ibuf);
d648 1
d653 2
a654 1
	ibuf = env->sc_ibufs[PROC_CONTROL];
d661 1
a661 1
			event_del(&ibuf->ev);
d697 1
a697 1
				imsg_compose_event(env->sc_ibufs[PROC_SMTP],
d701 1
a701 1
			imsg_compose_event(ibuf, IMSG_CONF_RELOAD, 0, 0, -1, r, sizeof(*r));
d711 1
a711 1
	imsg_event_add(ibuf);
d773 1
a773 1
				imsg_compose_event(env->sc_ibufs[PROC_RUNNER],
d1139 1
a1139 1
imsg_event_add(struct imsgbuf *ibuf)
d1141 2
a1142 2
	if (ibuf->handler == NULL) {
		imsg_flush(ibuf);
d1146 7
a1152 7
	ibuf->events = EV_READ;
	if (ibuf->w.queued)
		ibuf->events |= EV_WRITE;

	event_del(&ibuf->ev);
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf->data);
	event_add(&ibuf->ev, NULL);
d1156 1
a1156 1
imsg_compose_event(struct imsgbuf *ibuf, u_int16_t type, u_int32_t peerid,
d1161 1
a1161 1
	if ((ret = imsg_compose(ibuf, type, peerid,
d1163 1
a1163 1
		imsg_event_add(ibuf);
@


1.73
log
@rename sc_config to sc_conffile since that's what this field is about, it
will prevent a confusion with sc_config which will be a pointer to the
actual configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.72 2009/06/02 22:23:36 gilles Exp $	*/
d136 1
a136 1
	imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_CONF_START,
d162 1
a162 1
		imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_CONF_LISTENER,
d166 1
a166 1
	imsg_compose(env->sc_ibufs[PROC_SMTP], IMSG_CONF_END,
d177 1
a177 1
	imsg_compose(env->sc_ibufs[PROC_MTA], IMSG_CONF_START,
d195 1
a195 1
	imsg_compose(env->sc_ibufs[PROC_MTA], IMSG_CONF_END,
d208 1
a208 1
	imsg_compose(env->sc_ibufs[proc], IMSG_CONF_START,
d212 1
a212 1
		imsg_compose(env->sc_ibufs[proc], IMSG_CONF_MAP,
d215 1
a215 1
			imsg_compose(env->sc_ibufs[proc], IMSG_CONF_MAP_CONTENT,
d221 1
a221 1
		imsg_compose(env->sc_ibufs[proc], IMSG_CONF_RULE,
d223 1
a223 1
		imsg_compose(env->sc_ibufs[proc], IMSG_CONF_RULE_SOURCE,
d226 1
a226 1
			imsg_compose(env->sc_ibufs[proc], IMSG_CONF_CONDITION,
d231 1
a231 1
	imsg_compose(env->sc_ibufs[proc], IMSG_CONF_END,
d280 1
a280 1
			imsg_compose(ibuf, IMSG_PARENT_FORWARD_OPEN, 0, 0, ret, fwreq, sizeof(*fwreq));
d457 1
a457 1
				imsg_compose(ibuf, IMSG_MDA_MAILBOX_FILE, 0, 0,
d466 1
a466 1
			imsg_compose(ibuf, IMSG_MDA_MAILBOX_FILE, 0, 0,
d482 1
a482 1
			imsg_compose(ibuf, IMSG_MDA_MESSAGE_FILE, 0, 0,
d568 1
a568 1
			imsg_compose(ibuf, IMSG_PARENT_AUTHENTICATE, 0, 0,
d617 1
a617 1
				imsg_compose(ibuf, IMSG_PARENT_ENQUEUE_OFFLINE,
d681 1
a681 1
				imsg_compose(env->sc_ibufs[PROC_SMTP],
d685 1
a685 1
			imsg_compose(ibuf, IMSG_CONF_RELOAD, 0, 0, -1, r, sizeof(*r));
d757 1
a757 1
				imsg_compose(env->sc_ibufs[PROC_RUNNER],
d1137 12
@


1.72
log
@make env->sc_listeners and env->sc_ssl pointers, one step further toward
configuration reloading without killing active sessions; ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.71 2009/06/01 18:24:01 deraadt Exp $	*/
d668 1
a668 1
			if (parse_config(&newenv, env->sc_config, 0) == 0) {
d839 1
a839 1
	if (strlcpy(env.sc_config, conffile, MAXPATHLEN) >= MAXPATHLEN)
@


1.71
log
@No need for save_getpwuid and such functions which call endpwent.
endpwent is not needed unless setpwent (with stayopen = 1) or getpwent
was used.  getpwuid/getpwnam do not use getpwent; i think people must
be assuming this.  we are going to improve the man pages for this.
ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.70 2009/06/01 13:20:56 jacekm Exp $	*/
d139 1
a139 1
	SPLAY_FOREACH(s, ssltree, &env->sc_ssl) {
d154 1
a154 1
	TAILQ_FOREACH(l, &env->sc_listeners, entry) {
d180 1
a180 1
	SPLAY_FOREACH(s, ssltree, &env->sc_ssl) {
@


1.70
log
@Fix EV_READ/EV_WRITE testing inside IMSG handlers. Based on similar change
to the routing daemons by claudio@@; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.69 2009/05/30 23:53:41 gilles Exp $	*/
d451 1
a451 1
			pw = safe_getpwnam(pw_name);
d499 1
a499 1
			pw = safe_getpwnam(path->pw_name);
a853 1
	endpwent();
d1386 1
a1386 1
	if ((pw = safe_getpwuid(sb.st_uid)) == NULL) {
d1518 1
a1518 1
	pw = safe_getpwnam(username);
@


1.69
log
@It is now possible to specify a certificate to use when relaying to another
host which requests client certificates:

	accept [...] relay via [...] ssl certificate "mycert"

diff from Josh Elsasser <josh@@elsasser.org>, tested and okayed by me with
no change but the addition of status 554 to the state machine to deal with
remote host telling us it doesn't like our certificate.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.68 2009/05/30 23:28:52 gilles Exp $	*/
d244 2
a245 2
	switch (event) {
	case EV_READ:
d254 3
a256 2
		break;
	case EV_WRITE:
a258 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d302 2
a303 2
	switch (event) {
	case EV_READ:
d312 3
a314 2
		break;
	case EV_WRITE:
a316 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d345 2
a346 2
	switch (event) {
	case EV_READ:
d355 3
a357 2
		break;
	case EV_WRITE:
a359 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d388 2
a389 2
	switch (event) {
	case EV_READ:
d398 3
a400 2
		break;
	case EV_WRITE:
a402 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d532 2
a533 2
	switch (event) {
	case EV_READ:
d542 3
a544 2
		break;
	case EV_WRITE:
a546 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d591 2
a592 2
	switch (event) {
	case EV_READ:
d601 3
a603 2
		break;
	case EV_WRITE:
a605 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d639 2
a640 2
	switch (event) {
	case EV_READ:
d649 3
a651 2
		break;
	case EV_WRITE:
a653 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
@


1.68
log
@fatal on setsockopt() failures
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.67 2009/05/25 14:00:36 jacekm Exp $	*/
d58 1
d63 1
d122 1
d140 3
d171 29
d343 46
d699 1
d819 1
@


1.67
log
@merge smtp_listener_setup into its only caller; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.66 2009/05/24 15:47:31 jacekm Exp $	*/
d152 2
a153 1
		setsockopt(l->fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
@


1.66
log
@Parent process shouldn't be base64-decoding untrusted strings, move
this code to privsep smtp process; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.65 2009/05/24 14:38:56 jacekm Exp $	*/
d130 1
d149 6
a154 1
		smtp_listener_setup(env, l);
d158 1
@


1.65
log
@Parent process forks 3 types of processes, track them all in a single tree
using newly introduced child struct.

Manage process titles centrally in struct smtpd.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.64 2009/05/24 14:22:24 jacekm Exp $	*/
d487 1
a487 6
			struct session_auth_req *req = imsg.data;
			struct session_auth_reply reply;
			char buf[1024];
			char *user;
			char *pass;
			int len;
d491 2
a492 2
			reply.session_id = req->session_id;
			reply.value = 0;
a493 24
			/* String is not NUL terminated, leave room. */
			if ((len = kn_decode_base64(req->buffer, buf,
			    sizeof(buf) - 1)) == -1)
				goto out;
			/* buf is a byte string, NUL terminate. */
			buf[len] = '\0';

			/*
			 * Skip "foo" in "foo\0user\0pass", if present.
			 */
			user = memchr(buf, '\0', len);
			if (user == NULL || user >= buf + len - 2)
				goto out;
			user++; /* skip NUL */

			pass = memchr(user, '\0', len - (user - buf));
			if (pass == NULL || pass >= buf + len - 2)
				goto out;
			pass++; /* skip NUL */

			if (auth_userokay(user, NULL, "auth-smtp", pass))
				reply.value = 1;

out:
d495 1
a495 2
			    -1, &reply, sizeof(reply));

@


1.64
log
@Instead of keeping stats private to each process, and querying every
process individually whenever stats need to be fetched, keep stats
in MAP_ANON shared memory allocated by parent.

This means control has direct access to stats and can respond very
quickly without troubling any other daemon processes.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.63 2009/05/20 16:07:26 gilles Exp $	*/
d54 29
a82 24
__dead void	usage(void);
void		parent_shutdown(void);
void		parent_send_config(int, short, void *);
void		parent_send_config_listeners(struct smtpd *);
void		parent_send_config_ruleset(struct smtpd *, int);
void		parent_dispatch_lka(int, short, void *);
void		parent_dispatch_mda(int, short, void *);
void		parent_dispatch_mfa(int, short, void *);
void		parent_dispatch_smtp(int, short, void *);
void		parent_dispatch_runner(int, short, void *);
void		parent_dispatch_control(int, short, void *);
void		parent_sig_handler(int, short, void *);
int		parent_open_message_file(struct batch *);
int		parent_mailbox_open(char *, struct passwd *, struct batch *);
int		parent_filename_open(char *, struct passwd *, struct batch *);
int		parent_mailfile_rename(struct batch *, struct path *);
int		parent_maildir_open(char *, struct passwd *, struct batch *);
int		parent_maildir_init(struct passwd *, char *);
int		parent_external_mda(char *, struct passwd *, struct batch *);
int		parent_enqueue_offline(struct smtpd *, char *);
int		parent_forward_open(char *);
int		check_child(pid_t, const char *);
int		setup_spool(uid_t, gid_t);
int		path_starts_with(char *, char *);
a85 9
pid_t	lka_pid = 0;
pid_t	mfa_pid = 0;
pid_t	queue_pid = 0;
pid_t	mda_pid = 0;
pid_t	mta_pid = 0;
pid_t	control_pid = 0;
pid_t	smtp_pid = 0;
pid_t	runner_pid = 0;

d99 1
a99 1
parent_shutdown(void)
d101 2
a102 12
	u_int		i;
	pid_t		pid;
	pid_t		pids[] = {
		lka_pid,
		mfa_pid,
		queue_pid,
		mda_pid,
		mta_pid,
		control_pid,
		smtp_pid,
		runner_pid
	};
d104 3
a106 3
	for (i = 0; i < nitems(pids); i++)
		if (pids[i])
			kill(pids[i], SIGTERM);
d109 1
a109 3
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
d112 1
a112 1
	log_info("terminating");
d662 5
a666 17
	int					 i;
	int					 die = 0;
	pid_t					 pid;
	struct mdaproc				*mdaproc;
	struct mdaproc				 lookup;
	struct smtpd				*env = p;
	struct { pid_t p; const char *s; }	 procs[] = {
		{ lka_pid,	"lookup agent" },
		{ mfa_pid,	"mail filter agent" },
		{ queue_pid,	"mail queue" },
		{ mda_pid,	"mail delivery agent" },
		{ mta_pid,	"mail transfer agent" },
		{ control_pid,	"control process" },
		{ smtp_pid,	"smtp server" },
		{ runner_pid,	"runner" },
		{ 0,		NULL },
	};
d674 25
a698 3
		for (i = 0; procs[i].s != NULL; i++)
			if (check_child(procs[i].p, procs[i].s)) {
				procs[i].p = 0;
d700 25
a725 2
		if (die)
			parent_shutdown();
d727 1
a727 2
		do {
			int status;
d729 1
a729 48
			pid = waitpid(-1, &status, WNOHANG);
			if (pid > 0) {
				lookup.pid = pid;
				mdaproc = SPLAY_FIND(mdaproctree, &env->mdaproc_queue, &lookup);
				if (mdaproc == NULL)
					fatalx("unexpected SIGCHLD");

				if (WIFEXITED(status) && !WIFSIGNALED(status)) {
					switch (mdaproc->type) {
					case CHILD_ENQUEUE_OFFLINE:
						if (WEXITSTATUS(status) == 0)
							log_debug("offline enqueue was successful");
						else
							log_debug("offline enqueue failed");
						imsg_compose(env->sc_ibufs[PROC_RUNNER],
						    IMSG_PARENT_ENQUEUE_OFFLINE, 0, 0, -1,
						    NULL, 0);
						break;
					case CHILD_MDA:
						if (WEXITSTATUS(status) == EX_OK)
							log_debug("DEBUG: external mda reported success");
						else if (WEXITSTATUS(status) == EX_TEMPFAIL)
							log_debug("DEBUG: external mda reported temporary failure");
						else
							log_warnx("external mda returned %d", WEXITSTATUS(status));
						break;
					default:
						fatalx("invalid child type");
						break;
					}
				} else {
					switch (mdaproc->type) {
					case CHILD_ENQUEUE_OFFLINE:
						log_warnx("offline enqueue terminated abnormally");
						break;
					case CHILD_MDA:
						log_warnx("external mda terminated abnormally");
						break;
					default:
						fatalx("invalid child type");
						break;
					}
				}

				SPLAY_REMOVE(mdaproctree, &env->mdaproc_queue,
				    mdaproc);
				free(mdaproc);
			}
d732 2
d851 1
a851 23
	env.sc_instances[PROC_PARENT] = 1;
	env.sc_instances[PROC_LKA] = 1;
	env.sc_instances[PROC_MFA] = 1;
	env.sc_instances[PROC_QUEUE] = 1;
	env.sc_instances[PROC_MDA] = 1;
	env.sc_instances[PROC_MTA] = 1;
	env.sc_instances[PROC_SMTP] = 1;
	env.sc_instances[PROC_CONTROL] = 1;
	env.sc_instances[PROC_RUNNER] = 1;

	init_peers(&env);

	/* start subprocesses */
	lka_pid = lka(&env);
	mfa_pid = mfa(&env);
	queue_pid = queue(&env);
	mda_pid = mda(&env);
	mta_pid = mta(&env);
	smtp_pid = smtp(&env);
	control_pid = control(&env);
	runner_pid = runner(&env);

	SPLAY_INIT(&env.mdaproc_queue);
d877 40
d918 13
a930 2
int
check_child(pid_t pid, const char *pname)
d932 1
a932 1
	int	status;
d934 13
a946 11
	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("check_child: lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("check_child: lost child: %s terminated; "
			    "signal %d", pname, WTERMSIG(status));
			return (1);
		}
	}
d948 2
a949 1
	return (0);
a1125 1
	struct mdaproc *mdaproc;
a1156 2
		setproctitle("mail.local");

d1169 1
a1169 7
	mdaproc = calloc(1, sizeof (struct mdaproc));
	if (mdaproc == NULL)
		fatal("calloc");
	mdaproc->pid = pid;
	mdaproc->type = CHILD_MDA;

	SPLAY_INSERT(mdaproctree, &batchp->env->mdaproc_queue, mdaproc);
a1249 1
	struct mdaproc *mdaproc;
a1272 2
		setproctitle("external MDA");

d1308 1
a1308 7
	mdaproc = calloc(1, sizeof (struct mdaproc));
	if (mdaproc == NULL)
		fatal("calloc");
	mdaproc->pid = pid;
	mdaproc->type = CHILD_MDA;

	SPLAY_INSERT(mdaproctree, &batchp->env->mdaproc_queue, mdaproc);
a1318 1
	struct mdaproc	*mdaproc;
d1419 1
a1419 7
	mdaproc = calloc(1, sizeof (struct mdaproc));
	if (mdaproc == NULL)
		fatal("calloc");
	mdaproc->pid = pid;
	mdaproc->type = CHILD_ENQUEUE_OFFLINE;

	SPLAY_INSERT(mdaproctree, &env->mdaproc_queue, mdaproc);
d1529 1
a1529 1
mdaproc_cmp(struct mdaproc *s1, struct mdaproc *s2)
d1531 1
a1531 1
	if (s1->pid < s2->pid)
d1534 1
a1534 1
	if (s1->pid > s2->pid)
d1540 1
a1540 1
SPLAY_GENERATE(mdaproctree, mdaproc, mdaproc_nodes, mdaproc_cmp);
@


1.63
log
@previous commit to add reload support was missing some code, this diffs
contains the missing parts + a memleak plug
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.62 2009/05/20 14:29:44 gilles Exp $	*/
d30 1
a89 2
struct s_parent	s_parent;

a664 9
		case IMSG_STATS: {
			struct stats *s = imsg.data;

			IMSG_SIZE_CHECK(s);

			s->u.parent = s_parent;
			imsg_compose(ibuf, IMSG_STATS, 0, 0, -1, s, sizeof(*s));
			break;
		}
d856 8
a902 2

	s_parent.start = time(NULL);
@


1.62
log
@first step towards configuration reload in smtpd, smtpctl reload will parse
the configuration file again and replace current configuration with new one
in all processes. what we don't support yet is graceful restart, clients in
sessions at the moment of the reload will have a temp failure thrown at 'em
which is ok RFC-wise but which we will try to improve anyway.

tested with various setups, "diff reads good" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.61 2009/05/19 22:54:46 gilles Exp $	*/
d179 2
a180 1

d184 10
a193 1

d197 2
d204 1
a204 6

	TAILQ_FOREACH(m, env->sc_maps, m_entry) {
		imsg_compose(env->sc_ibufs[proc], IMSG_CONF_MAP,
		    0, 0, -1, m, sizeof(*m));
	}

d643 21
a663 5
			parent_send_config_ruleset(env, PROC_MFA);
			parent_send_config_ruleset(env, PROC_LKA);
			imsg_compose(env->sc_ibufs[PROC_SMTP],
			    IMSG_CONF_RELOAD, 0, 0, -1, NULL, 0);
			imsg_compose(ibuf, IMSG_CONF_RELOAD, 0, 0, -1, NULL, 0);
d837 4
@


1.61
log
@ever since we switched from delivering to mboxes ourselves to using the
mail.local(8) utility, parent_mailbox_init() has become useless, do not
call it from parent_mailbox_open() anymore, and kill it.

this fixes a bug which we were many to spot and which would cause smtpd
to create a file /var/mail/%u upon first delivery to a mbox, then leave
it there forever untouched.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.60 2009/05/19 11:37:44 jacekm Exp $	*/
d56 2
d136 8
a143 2
	struct smtpd		*env = p;
	struct iovec		iov[3];
d146 1
d174 29
d493 1
a493 1
			parent_send_config(-1, -1, env);
d635 8
@


1.60
log
@Do not ever run /usr/sbin/sendmail, it could link to sendmail
interface for a different MTA. Use the binary in /usr/libexec
directly instead.

Based on remark claudio@@ made in passing.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.59 2009/05/19 11:24:24 jacekm Exp $	*/
a63 1
int		parent_mailbox_init(struct passwd *, char *);
a1049 31
parent_mailbox_init(struct passwd *pw, char *pathname)
{
	int fd;
	int ret = 1;
	int mode = O_CREAT|O_EXCL;

	/* user cannot create mailbox */
	if (seteuid(0) == -1)
		fatal("privraise failed");

	errno = 0;
	fd = open(pathname, mode, 0600);

	if (fd == -1) {
		if (errno != EEXIST)
			ret = 0;
	}

	if (fd != -1) {
		if (fchown(fd, pw->pw_uid, 0) == -1)
			fatal("fchown");
		close(fd);
	}

	if (seteuid(pw->pw_uid) == -1)
		fatal("privdropfailed");
		
	return ret;
}

int
a1064 5
	if (! parent_mailbox_init(pw, path)) {
		batchp->message.status |= S_MESSAGE_TEMPFAILURE;
		return -1;
	}

a1065 1

@


1.59
log
@Verify the amount of IMSG payload is exactly as expected; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.58 2009/05/14 15:05:12 eric Exp $	*/
d1388 1
a1388 1
		addargs(&args, "%s", _PATH_SENDMAIL);
d1400 1
a1400 1
		execvp(args.list[0], args.list);
@


1.58
log
@use the nitems() macro where appropriate

ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.57 2009/05/10 11:29:40 jacekm Exp $	*/
d202 1
a203 1
			struct forward_req *fwreq;
d205 2
a206 1
			fwreq = imsg.data;
d309 1
a309 1
			struct batch *batchp;
d326 2
a327 1
			batchp = imsg.data;
d371 1
a371 1
			struct batch *batchp;
d374 2
a375 1
			batchp = imsg.data;
d384 1
a384 1
			struct batch *batchp;
d388 2
a389 1
			batchp = imsg.data;
d460 1
a460 1
			struct session_auth_req *req;
d467 1
a467 1
			req = (struct session_auth_req *)imsg.data;
d599 3
a601 1
			struct stats *s;
a602 1
			s = imsg.data;
@


1.57
log
@assert copyright; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.56 2009/04/21 18:39:00 jacekm Exp $	*/
d118 1
a118 1
	for (i = 0; i < sizeof(pids) / sizeof(pid); i++)
d153 1
a153 1
		    iov, sizeof(iov)/sizeof(iov[0]));
d331 1
a331 1
			for (i = 0; i < sizeof(action_hdl_table) / sizeof(struct action_handler); ++i)
d334 1
a334 1
			if (i == sizeof(action_hdl_table) / sizeof(struct action_handler))
d843 2
a844 2
	config_pipes(&env, peers, 6);
	config_peers(&env, peers, 6);
d932 1
a932 1
	for (n = 0; n < sizeof(paths)/sizeof(paths[0]); n++) {
d1152 1
a1152 1
	for (i = 0; i < sizeof (subdir) / sizeof (char *); ++i) {
@


1.56
log
@small corrections to log_warns and fatals
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.55 2009/04/21 18:12:05 jacekm Exp $	*/
d6 1
@


1.55
log
@Make /usr/sbin/sendmail not fail due to smtpd being down.

The approach is to save cmdline + stdin in a file under a newly
added directory /var/spool/smtpd/offline (uid 0 gid 0 mode 1777).
Next time daemon starts, it uses information in that directory
to replay sendmail on user's behalf.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.54 2009/04/21 14:37:32 eric Exp $	*/
d537 1
a537 1
			fatal("parent_dispatch_runner: imsg_read error");
d1327 1
a1327 1
		log_warn("parent_enqueue_offline: getpwuid for %d failed",
@


1.54
log
@correct some fatal(x) calls and error strings

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.53 2009/04/15 20:36:48 jacekm Exp $	*/
d59 1
d70 1
d74 1
d507 51
d657 9
a665 3
					switch (WEXITSTATUS(status)) {
					case EX_OK:
						log_debug("DEBUG: external mda reported success");
d667 7
a673 2
					case EX_TEMPFAIL:
						log_debug("DEBUG: external mda reported temporary failure");
d676 14
a689 1
						log_warnx("external mda returned %d", WEXITSTATUS(status));
a691 3
				else {
					log_warnx("external mda terminated abnormally");
				}
d725 1
d842 2
a843 2
	config_pipes(&env, peers, 5);
	config_peers(&env, peers, 5);
d881 2
a882 1
				     PATH_RUNQUEUEHIGH, PATH_PURGE };
d932 14
d957 2
a958 1
			if (mkdir(pathname, 0700) == -1) {
d963 1
a963 1
			if (chown(pathname, uid, gid) == -1) {
d968 5
d983 2
a984 2
		/* check that it is owned by uid/gid */
		if (sb.st_uid != uid) {
d986 1
a986 1
			warnx("%s is not owned by uid %d", pathname, uid);
d988 1
a988 1
		if (sb.st_gid != gid) {
d990 1
a990 1
			warnx("%s is not owned by gid %d", pathname, gid);
d994 3
a996 3
		if ((sb.st_mode & (S_IRUSR|S_IWUSR|S_IXUSR)) != (S_IRUSR|S_IWUSR|S_IXUSR) ||
		    (sb.st_mode & (S_IRGRP|S_IWGRP|S_IXGRP)) ||
		    (sb.st_mode & (S_IROTH|S_IWOTH|S_IXOTH))) {
d998 3
a1000 1
			warnx("%s must be rwx------ (0700)", pathname);
d1136 1
d1284 1
d1293 117
d1499 12
@


1.53
log
@don't call setproctitle for parent, at least one process should
display cmdline arguments the daemon was started with; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.52 2009/04/03 05:20:17 oga Exp $	*/
d192 1
a192 1
			fatal("parent_dispatch_lka: imsg_read error");
d252 1
a252 1
			fatal("parent_dispatch_lka: imsg_read error");
d298 1
a298 1
			fatal("parent_dispatch_mda: imsg_read error");
d442 1
a442 1
			fatal("parent_dispatch_smtp: imsg_read error");
d534 1
a534 1
			fatal("parent_dispatch_control: imsg_read error");
@


1.52
log
@The smtp auth PLAIN specification is weird. It's valid (apparently for
imap, mostly) to provide "username1\0real_username\0password" as your
base64 encoded string for authentication. We currently don't handle
that, instead expecting the first byte to be a NUL.  So fix that up by
scanning for the first string, and ignoring it if it's there. The string
is also stupid in that the last bit (password) may not be NUL
terminated, so pay attention to that in our decoding and make sure that
it's always terminated correctly.

It's been discussed, and this decoding really should happen in the
unauthenticated process, not in the privileged one, but that is another
diff.

Problem found by todd@@, who kindly helped me debug this and confirmed
that it now works with kmail, mutt and thunderbird.

"if it makes more stuff work, please commit" jacekm@@.

-0- - not a smtpd hacker and I resent your implication.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.51 2009/03/29 14:18:20 jacekm Exp $	*/
a749 1
	setproctitle("parent");
@


1.51
log
@turn some log_debugs into log_warns or even fatals; "looks ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.50 2009/03/22 22:53:47 gilles Exp $	*/
d454 4
a457 3
			u_int8_t buffer[1024];
			char *pw_name;
			char *pw_passwd;
d464 22
a485 3
			if (kn_decode_base64(req->buffer, buffer, sizeof(buffer)) != -1) {
				pw_name = buffer+1;
				pw_passwd = pw_name+strlen(pw_name)+1;
d487 1
a487 3
				if (auth_userokay(pw_name, NULL, "auth-smtp", pw_passwd))
					reply.value = 1;
			}
@


1.50
log
@fix a bug in the resolution of forward files which would cause usernames
not to be taken into account if they had no ~/.forward file AND were the
result of an alias expansion that expanded to more than one username.

while at it, I spotted another bug where I would check T_MDA_MESSAGE on
the flags field instead of the type field. the bug could cause two MDA
message to end up in the same batch which is no longer valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.49 2009/03/10 21:14:21 jacekm Exp $	*/
d212 1
a212 1
			log_debug("parent_dispatch_lka: unexpected imsg %d",
d214 1
a214 1
			break;
d258 1
a258 1
			log_debug("parent_dispatch_lka: unexpected imsg %d",
d260 1
a260 1
			break;
d402 1
a402 1
			log_debug("parent_dispatch_mda: unexpected imsg %d",
d404 1
a404 1
			break;
d476 1
a476 1
			log_debug("parent_dispatch_smtp: unexpected imsg %d",
d478 1
a478 1
			break;
d530 1
a530 1
			log_debug("parent_dispatch_control: unexpected imsg %d",
d532 1
a532 1
			break;
d582 1
a582 1
					errx(1, "received SIGCHLD but no known child for that pid (#%d)", pid);
d593 1
a593 1
						log_debug("DEBUG: external mda reported permanent failure");
d597 1
a597 1
					log_debug("DEBUG: external mda process has terminated in a baaaad way");
a605 1
		/**/
@


1.49
log
@when calling external mda, use restricted environment; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.48 2009/03/10 19:13:28 jacekm Exp $	*/
d203 2
a204 1
			if (ret == -1)
d206 2
a207 1
					fwreq->pw_name[0] = '\0';
d1240 1
a1240 1
			goto clear;
d1246 1
a1246 1
		goto clearlog;
d1249 1
a1249 1
		goto clearlog;
d1253 1
a1253 1
		goto clearlog;
d1256 1
a1256 1
		goto clearlog;
d1260 1
a1260 1
clearlog:
d1263 1
a1263 2
clear:
	username[0] = '\0';
@


1.48
log
@run external mda with cwd set to $HOME or /; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.47 2009/03/10 19:09:29 jacekm Exp $	*/
d37 1
d73 2
d1102 1
d1153 4
@


1.47
log
@kill few lines, saving one seteuid(2) call; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.46 2009/03/10 18:44:28 jacekm Exp $	*/
d1143 3
@


1.46
log
@- Use setsid(2) to create new process group for external mda.
- Unignore SIGPIPE, otherwise it remains ignored in forked mda.
- Use closefrom(2) to close all descriptors apart from stdin/stdout/stderr.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.45 2009/03/10 13:05:05 jacekm Exp $	*/
a1110 7
	/* raise privileges before fork so that the child can
	 * revoke them permanently instead of inheriting the
	 * saved uid.
	 */
	if (seteuid(0) == -1)
		fatal("privraise failed");

d1123 2
a1149 3

	if (seteuid(pw->pw_uid) == -1)
		fatal("privdrop failed");
@


1.45
log
@it's simpler to use pipe(2) than socketpair(2) to communicate with
external mda; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.44 2009/03/10 10:01:39 jacekm Exp $	*/
d1140 6
d1148 3
a1150 1
		close(pipefd[1]);
@


1.44
log
@fork(2) or socketpair(2) failures are temporary, delivery attempt should be
retried later; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.43 2009/03/09 23:35:04 jacekm Exp $	*/
d1102 1
a1102 1
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pipefd) == -1) {
d1104 1
a1104 1
			log_warn("parent_external_mda: socketpair");
d1108 1
a1108 1
		fatal("parent_external_mda: socketpair");
d1133 1
a1133 1
			fatal("mta: cannot drop privileges");
d1140 3
a1142 4
		close(pipefd[0]);
		close(STDOUT_FILENO);
		close(STDERR_FILENO);
		dup2(pipefd[1], 0);
d1158 2
a1159 2
	close(pipefd[1]);
	return pipefd[0];
@


1.43
log
@run external mda directly, not via sh -c; this steals addargs() API
from OpenSSH; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.42 2009/03/08 17:54:20 gilles Exp $	*/
d1103 6
a1108 2
		batchp->message.status |= S_MESSAGE_PERMFAILURE;
		return -1;
d1120 1
d1123 1
a1123 1
		batchp->message.status |= S_MESSAGE_PERMFAILURE;
@


1.42
log
@~/.forward files handling was fixed recently so that it is the privileged
process that does the opening, this commit does some cleanup, and fixes a
bug I experienced today which was caused by a use-after-free.

I did some testing to make sure a user cannot cause smtpd to deadlock, or
loop, with broken setups (self-referencing forwards/aliases, empty files,
broken files...), but if you are playing with aliases/forwards PLEASE let
me know of any bug you run into.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.41 2009/03/04 00:00:40 gilles Exp $	*/
d1096 2
d1130 5
d1140 1
a1140 1
		execlp(_PATH_BSHELL, "sh", "-c", path, (void *)NULL);
@


1.41
log
@plug a memory leak, remove lka session from the the lka session tree when
we are done expanding aliases/forwards, and cleanup a bit the expansion
code so that I can soon remove some of the duplication.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.40 2009/03/03 23:23:52 gilles Exp $	*/
a202 1
			log_debug("parent will return fd %d", ret);
@


1.40
log
@Fix a long standing issue where ~/.forward files were opened by user _smtpd
causing them not to be handled when a user's homedir is set to mode 0700. I
still need to do some cleanup and make sure it works as it should, but this
diff provides better behavior than what we had.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.39 2009/03/03 15:47:27 gilles Exp $	*/
d203 1
a203 1
			log_debug("parent will return fd %d", fd);
@


1.39
log
@fix mbox locking by having it done by mail.local(8) which in turns uses
lockspool(1). this means our mbox delivery follows a code path that has
become almost identical to external mda deliveries. this is the first
of a serie of diffs actually...

lockspool(1) suggestion by deraadt@@, mail.local(8) idea by jacekm@@, and
fix and testing by me
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.38 2009/03/01 21:58:53 jacekm Exp $	*/
d68 1
d194 13
d1196 46
@


1.38
log
@- Refuse delivery to mbox that is a symlink, pipe, chardev, etc. etc.
- Introduce secure_file, based on secure_filename from OpenSSH, it
checks that mbox has right perms, and that path components are
trustworthy, too.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.37 2009/03/01 21:36:50 jacekm Exp $	*/
d945 12
a956 2
	int fd;
	int mode = O_CREAT|O_APPEND|O_RDWR|O_EXLOCK|O_NONBLOCK|O_NOFOLLOW;
d963 18
a980 22
	fd = open(path, mode, 0600);
	if (fd == -1) {
		/* XXX - this needs to be discussed ... */
		switch (errno) {
		case ENOTDIR:
		case ENOENT:
		case EACCES:
		case ELOOP:
		case EROFS:
		case EDQUOT:
		case EINTR:
		case EIO:
		case EMFILE:
		case ENFILE:
		case ENOSPC:
			goto tempfail;
		case EWOULDBLOCK:
			batchp->message.status |= S_MESSAGE_LOCKFAILURE;
			goto tempfail;
		default:
			batchp->message.status |= S_MESSAGE_PERMFAILURE;
		}
d984 10
a993 3
	if (! secure_file(fd, path, pw)) {
		log_warnx("refusing delivery to unsecure path: %s", path);
		goto tempfail;
d996 7
a1002 1
	return fd;
d1004 1
a1004 3
tempfail:
	if (fd != -1)
		close(fd);
d1006 2
a1007 2
	batchp->message.status |= S_MESSAGE_TEMPFAILURE;
	return -1;
@


1.37
log
@open mbox with O_EXLOCK (better than open+flock), and without O_SYNC,
since fsync is done in final safe_fclose; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.36 2009/03/01 15:06:23 jacekm Exp $	*/
d946 1
a946 1
	int mode = O_CREAT|O_APPEND|O_RDWR|O_EXLOCK|O_NONBLOCK;
d968 1
a968 2
			batchp->message.status |= S_MESSAGE_TEMPFAILURE;
			break;
d970 2
a971 1
			goto lockfail;
d978 5
d985 1
a985 1
lockfail:
d989 1
a989 1
	batchp->message.status |= S_MESSAGE_TEMPFAILURE|S_MESSAGE_LOCKFAILURE;
@


1.36
log
@fix possible NULL dereference when getpwnam fails; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.35 2009/03/01 13:08:47 jacekm Exp $	*/
d946 1
a946 1
	int mode = O_CREAT|O_APPEND|O_RDWR|O_SYNC|O_NONBLOCK;
a975 6
	}

	if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
		if (errno == EWOULDBLOCK)
			goto lockfail;
		fatal("flock");
@


1.35
log
@make the condition under which delivery is made by SMTPD_USER more
explicit; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.34 2009/03/01 13:07:52 jacekm Exp $	*/
d322 1
d324 9
a332 2
			if (pw == NULL)
				batchp->message.status |= S_MESSAGE_PERMFAILURE;
@


1.34
log
@simplify *_open functions by passing them char * instead of struct
path *; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.33 2009/02/25 09:08:34 jacekm Exp $	*/
d317 1
a317 1
			if (*pw_name == '\0') {
@


1.33
log
@remove chown's called when running with user privs, ie. basically noops;
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.32 2009/02/23 00:51:32 chl Exp $	*/
d62 2
a63 2
int		parent_mailbox_open(struct passwd *, struct batch *, struct path *);
int		parent_filename_open(struct passwd *, struct batch *, struct path *);
d65 1
a65 1
int		parent_maildir_open(struct passwd *, struct batch *, struct path *);
d67 1
a67 1
int		parent_external_mda(struct passwd *, struct batch *, struct path *);
d290 1
d295 1
a295 1
				int (*handler)(struct passwd *, struct batch *, struct path *);
d313 1
a313 1
				errx(1, "%s: unknown action.", __func__);
d315 1
d317 2
a318 1
			if (*pw_name == '\0')
d320 1
d329 1
a329 1
			desc = action_hdl_table[i].handler(pw, batchp, path);
d935 1
a935 1
parent_mailbox_open(struct passwd *pw, struct batch *batchp, struct path *path)
a937 1
	char pathname[MAXPATHLEN];
d940 1
a940 5
	if (! bsnprintf(pathname, sizeof(pathname), "%s",
		path->rule.r_value.path))
		return -1;

	if (! parent_mailbox_init(pw, pathname)) {
d945 1
a945 1
	fd = open(pathname, mode, 0600);
d1006 1
a1006 1
parent_maildir_open(struct passwd *pw, struct batch *batchp, struct path *path)
d1009 1
a1009 1
	char pathname[MAXPATHLEN];
d1012 1
a1012 5
	if (! bsnprintf(pathname, sizeof(pathname), "%s",
		path->rule.r_value.path))
		return -1;

	if (! parent_maildir_init(pw, pathname)) {
d1017 2
a1018 2
	if (! bsnprintf(pathname, sizeof(pathname), "%s/tmp/%s",
		pathname, batchp->message.message_uid)) {
d1023 1
a1023 1
	fd = open(pathname, mode, 0600);
d1055 1
a1055 1
parent_external_mda(struct passwd *pw, struct batch *batchp, struct path *path)
d1096 1
a1096 1
		execlp(_PATH_BSHELL, "sh", "-c", path->rule.r_value.path, (void *)NULL);
d1115 1
a1115 1
parent_filename_open(struct passwd *pw, struct batch *batchp, struct path *path)
a1117 1
	char pathname[MAXPATHLEN];
d1120 1
a1120 4
	if (! bsnprintf(pathname, sizeof(pathname), "%s", path->u.filename))
		return -1;

	fd = open(pathname, mode, 0600);
@


1.32
log
@add missing headers needed by time()

ok jacekm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.31 2009/02/22 11:44:29 form Exp $	*/
a1000 1
		chown(pathname, pw->pw_uid, pw->pw_gid);
a1032 2

	fchown(fd, pw->pw_uid, pw->pw_gid);
@


1.31
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.30 2009/02/15 10:32:23 jacekm Exp $	*/
d44 1
@


1.30
log
@New config.c that allows for process cloning. Done by pyr@@ for
relayd at n2k9, and adapted to smtpd; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.29 2009/01/30 17:34:58 gilles Exp $	*/
d763 1
a763 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s", PATH_SPOOL))
d808 1
a808 1
		if (! bsnprintf(pathname, MAXPATHLEN, "%s%s", PATH_SPOOL,
d888 1
a888 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s%s/%d/%s/message",
d936 2
a937 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s", path->rule.r_value.path))
d994 2
a995 1
		if (! bsnprintf(pathname, MAXPATHLEN, "%s%s", root, subdir[i]))
d1013 2
a1014 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s", path->rule.r_value.path))
d1022 1
a1022 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s/tmp/%s",
d1045 1
a1045 1
	if (! bsnprintf(srcpath, MAXPATHLEN, "%s/tmp/%s",
d1047 1
a1047 1
	    ! bsnprintf(dstpath, MAXPATHLEN, "%s/new/%s",
d1128 1
a1128 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s", path->u.filename))
@


1.29
log
@bump descriptors limit to the max and set the maximum connections count to
three quarters of that limit (a session typically has 3 descriptors). when
we hit that limit, we stop accepting connections, and when client closes a
session, we start accepting connections again. this prevents us from going
into a session that is likely to fail because of scarce resources.

idea discussed with jacekm@@, code mostly ripped from relayd
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.28 2009/01/30 10:03:29 form Exp $	*/
d680 10
d719 1
@


1.28
log
@fix debug message

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.27 2009/01/29 21:59:15 jacekm Exp $	*/
d28 1
d595 1
d663 16
@


1.27
log
@Implement "smtpctl show stats"; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.26 2009/01/28 19:38:46 gilles Exp $	*/
a1034 1
	char *pw_name;
d1036 1
a1036 1
	log_debug("executing filter as user: %s", pw_name);
@


1.26
log
@when pausing listeners, do not simply disable their events as new
clients would still be able to connect. instead, at pause time we
close and remove the listeners, and at resume time we request the
parent to reconfigure all listeners.

discussed with pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.25 2009/01/27 11:42:30 gilles Exp $	*/
d56 1
d78 1
d454 54
d595 1
d677 2
d691 1
a691 1
	config_peers(&env, peers, 4);
@


1.25
log
@temporarily drop privileges to the final user before each delivery attempt,
wether it is maildir, mbox or external mda. rearrange a bit of code to also
simplify most delivery methods by moving their common code to common place.

while at it change some mode_t to int where it was wrongly used and unlink
temporary maildir file if we fail to deliver for some reason.

discussed with and ok jacek@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.24 2009/01/21 00:00:30 jacekm Exp $	*/
d413 4
@


1.24
log
@temporary quick fix to an issue that needs more thinking; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.23 2009/01/10 23:54:15 gilles Exp $	*/
d58 5
a62 4
int		parent_open_mailbox(struct batch *, struct path *);
int		parent_open_filename(struct batch *, struct path *);
int		parent_rename_mailfile(struct batch *);
int		parent_open_maildir(struct batch *, struct path *);
d64 1
a64 1
int		parent_external_mda(struct batch *, struct path *);
d284 2
d290 1
a290 1
				int (*handler)(struct batch *, struct path *);
d292 2
a293 2
				{ A_MBOX,	parent_open_mailbox },
				{ A_MAILDIR,	parent_open_maildir },
d295 1
a295 1
				{ A_FILENAME,	parent_open_filename }
d303 3
a305 6

			for (i = 0; i < sizeof(action_hdl_table) / sizeof(struct action_handler); ++i) {
				if (action_hdl_table[i].action == path->rule.r_action) {
					desc = action_hdl_table[i].handler(batchp, path);
					imsg_compose(ibuf, IMSG_MDA_MAILBOX_FILE, 0, 0,
					    desc, batchp, sizeof(struct batch));
a306 2
				}
			}
d310 18
d344 2
d348 16
a363 1
			parent_rename_mailfile(batchp);
d664 1
a664 1
	char		*paths[] = { PATH_INCOMING, PATH_QUEUE, PATH_PURGE,
d666 1
a666 1
				     PATH_RUNQUEUEHIGH };
d807 32
a838 1
parent_open_mailbox(struct batch *batchp, struct path *path)
a840 1
	struct passwd *pw;
d842 1
a842 1
	mode_t mode = O_CREAT|O_APPEND|O_RDWR|O_SYNC|O_NONBLOCK;
d844 1
a844 3
	pw = safe_getpwnam(path->pw_name);
	if (pw == NULL) {
		batchp->message.status |= S_MESSAGE_PERMFAILURE;
a845 1
	}
d847 2
a848 1
	if (! bsnprintf(pathname, MAXPATHLEN, "%s", path->rule.r_value.path))
d850 1
a882 2
	fchown(fd, pw->pw_uid, 0);

d893 18
d913 1
a913 1
parent_open_maildir(struct batch *batchp, struct path *path)
a915 1
	struct passwd *pw;
d917 1
a917 7
	mode_t mode = O_CREAT|O_RDWR|O_TRUNC|O_SYNC;

	pw = safe_getpwnam(path->pw_name);
	if (pw == NULL) {
		batchp->message.status |= S_MESSAGE_PERMFAILURE;
		return -1;
	}
d945 1
a945 1
parent_maildir_init(struct passwd *pw, char *root)
a946 20
	u_int8_t i;
	char pathname[MAXPATHLEN];
	char *subdir[] = { "/", "/tmp", "/cur", "/new" };

	for (i = 0; i < sizeof (subdir) / sizeof (char *); ++i) {
		if (! bsnprintf(pathname, MAXPATHLEN, "%s%s", root, subdir[i]))
			return 0;
		if (mkdir(pathname, 0700) == -1)
			if (errno != EEXIST)
				return 0;
		chown(pathname, pw->pw_uid, pw->pw_gid);
	}

	return 1;
}

int
parent_rename_mailfile(struct batch *batchp)
{
	struct passwd *pw;
a948 15
	struct path *path;
	int ret;

	if (batchp->type & T_DAEMON_BATCH) {
		path = &batchp->message.sender;
	}
	else {
		path = &batchp->message.recipient;
	}

	pw = safe_getpwnam(path->pw_name);
	if (pw == NULL) {
		batchp->message.status |= S_MESSAGE_PERMFAILURE;
		return 0;
	}
a955 3
	ret = 1;
	if (setegid(pw->pw_gid) || seteuid(pw->pw_uid))
		fatal("privdrop failed");
d957 2
a958 1
		ret = 0;
d960 1
a961 2
	if (setegid(0) || seteuid(0))
		fatal("privdrop failed");
d963 1
a963 1
	return ret;
d967 1
a967 1
parent_external_mda(struct batch *batchp, struct path *path)
a968 1
	struct passwd *pw;
a973 4
	pw_name = path->pw_name;
	if (pw_name[0] == '\0')
		pw_name = SMTPD_USER;

a974 5
	pw = safe_getpwnam(pw_name);
	if (pw == NULL) {
		batchp->message.status |= S_MESSAGE_PERMFAILURE;
		return -1;
	}
d981 7
d1013 3
d1028 1
a1028 1
parent_open_filename(struct batch *batchp, struct path *path)
d1032 1
a1032 1
	mode_t mode = O_CREAT|O_APPEND|O_RDWR|O_SYNC|O_NONBLOCK;
@


1.23
log
@- remove a comment that was no longer relevant
- when authenticating user, instead of doing a getpwnam() and checking the
	passwd field, issue a call to auth_userokay(), this will allow the
	use of login scripts to implement custom authentications without
	bloating smtpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.22 2009/01/08 19:17:31 jacekm Exp $	*/
d899 1
d920 3
d924 1
a925 1
		return 0;
d927 2
d930 1
a930 1
	return 1;
@


1.22
log
@ensure getpwnam is always followed by endpwent; ok gilles@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.21 2009/01/01 16:15:47 jacekm Exp $	*/
d29 1
d34 1
a379 1
			/* XXX - NOT ADVERTISED YET */
a385 1
			struct passwd *pw;
d395 3
a397 5
				pw = safe_getpwnam(pw_name);
				if (pw != NULL)
					if (strcmp(pw->pw_passwd, crypt(pw_passwd,
						    pw->pw_passwd)) == 0)
						reply.value = 1;
@


1.21
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.20 2008/12/27 17:03:29 jacekm Exp $	*/
d395 1
a395 1
				pw = getpwnam(pw_name);
d783 1
a783 1
	pw = getpwnam(path->pw_name);
d844 1
a844 1
	pw = getpwnam(path->pw_name);
d909 1
a909 1
	pw = getpwnam(path->pw_name);
d943 1
a943 1
	pw = getpwnam(pw_name);
@


1.20
log
@Merge hash() and queue_message_hash() into one func, queue_hash(). Fix callers
to use this interface consistently; ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.19 2008/12/22 12:56:21 jacekm Exp $	*/
a36 1
#include <stdarg.h>
@


1.19
log
@Remove entry from mdaproctree after reaping mda child; ok gilles@@
From: Nicholas Marriott <nicholas.marriott@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.18 2008/12/21 02:18:46 gilles Exp $	*/
a64 1
u_int16_t	queue_message_hash(struct message *);
d764 1
a764 1
	hval = queue_message_hash(messagep);
@


1.18
log
@- AUTH PLAIN may receive credentials as a parameter to AUTH or on a
	following line, this commit brings support for the latter which was
	not supported yet.
- AUTH LOGIN is now supported, allowing smtp auth support on clients that
	do not support AUTH PLAIN (ie: my mobile phone for instance ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.17 2008/12/19 00:44:40 gilles Exp $	*/
d479 2
@


1.17
log
@- fatal() if flock() has failed for any reason that's not EWOULDBLOCK, this
	is not supposed to happen but better safe than sorry.
	suggested by jacekm@@
- while at it, remove the locking of delivery file we create when doing a
	Maildir delivery. the purpose of Maildir is to prevent the need
	for locking in the first place ... I must have been tired that day.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.16 2008/12/19 00:39:05 gilles Exp $	*/
d35 1
d44 2
d394 1
a394 1
			if (__b64_pton(req->buffer, buffer, 1024) >= 0) {
@


1.16
log
@- smtpd handled mbox locking failures as "regular" temporary failures which
	is not good at all. As a result, under heavy load messages would be
	kept in queue, and delayed for hours just because we failed locking
	a few times. This commit makes smtpd distinguish between lock fails
	and "regular" temporary fails.
- delivery scheduler will reschedule immediately a message that couldn't be
	delivered because of a lock fail. If we fail to lock too many times
	we fallback to previous "delay increase" logic.

	"looks sane" jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.15 2008/12/17 18:47:37 jacekm Exp $	*/
d814 5
a818 2
	if (flock(fd, LOCK_EX|LOCK_NB) == -1)
		goto lockfail;
a866 6
	if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
		close(fd);
		batchp->message.status |= S_MESSAGE_TEMPFAILURE;
		return -1;
	}

d1022 5
a1026 2
	if (flock(fd, LOCK_EX|LOCK_NB) == -1)
		goto lockfail;
@


1.15
log
@Introduce /purge, where all msgs scheduled for deletion are put by
queue, and removed from disk by runner.

On startup, clean /incoming by moving msgs within it to /purge.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.14 2008/12/11 23:10:28 gilles Exp $	*/
a803 1
		case EWOULDBLOCK:
d806 2
a810 1

d814 2
a815 5
	if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
		close(fd);
		batchp->message.status |= S_MESSAGE_TEMPFAILURE;
		return -1;
	}
d820 7
a1014 1
		case EWOULDBLOCK:
d1017 2
d1025 7
a1031 1
	if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
a1032 3
		batchp->message.status |= S_MESSAGE_TEMPFAILURE;
		return -1;
	}
d1034 2
a1035 1
	return fd;
@


1.14
log
@- snprintf -> bsnprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.13 2008/12/05 02:51:32 gilles Exp $	*/
d630 1
a630 1
	char		*paths[] = { PATH_INCOMING, PATH_QUEUE,
@


1.13
log
@- last part of the new queue code: the runner process (unprivileged and
	chrooted) is now in charge of doing the scheduling of deliveries,
	and the dispatching of messages to MDA and MTA. queue process only
	does inserts/updates/removals from the queue and can no longer be
	so busy that it delays answers to imsg from smtp server.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.12 2008/12/03 17:58:00 gilles Exp $	*/
a635 1
	int spret;
d637 1
a637 2
	spret = snprintf(pathname, MAXPATHLEN, "%s", PATH_SPOOL);
	if (spret == -1 || spret >= MAXPATHLEN)
d682 2
a683 3
		spret = snprintf(pathname, MAXPATHLEN, "%s%s", PATH_SPOOL,
		    paths[n]);
		if (spret == -1 || spret >= MAXPATHLEN)
a755 1
	int spret;
d762 2
a763 3
	spret = snprintf(pathname, MAXPATHLEN, "%s%s/%d/%s/message",
	    PATH_SPOOL, PATH_QUEUE, hval, batchp->message_id);
	if (spret == -1 || spret >= MAXPATHLEN) {
a777 1
	int spret;
d786 1
a786 2
	spret = snprintf(pathname, MAXPATHLEN, "%s", path->rule.r_value.path);
	if (spret == -1 || spret >= MAXPATHLEN)
a831 1
	int spret;
d840 1
a840 2
	spret = snprintf(pathname, MAXPATHLEN, "%s", path->rule.r_value.path);
	if (spret == -1 || spret >= MAXPATHLEN)
d848 2
a849 4
	spret = snprintf(pathname, MAXPATHLEN, "%s/tmp/%s",
	    pathname, batchp->message.message_uid);

	if (spret == -1 || spret >= MAXPATHLEN) {
a876 1
	int spret;
d879 1
a879 2
		spret = snprintf(pathname, MAXPATHLEN, "%s%s", root, subdir[i]);
		if (spret == -1 || spret >= MAXPATHLEN)
a896 1
	int spret;
d911 4
a914 8
	spret = snprintf(srcpath, MAXPATHLEN, "%s/tmp/%s",
	    path->rule.r_value.path, batchp->message.message_uid);
	if (spret == -1 || spret >= MAXPATHLEN)
		return 0;

	spret = snprintf(dstpath, MAXPATHLEN, "%s/new/%s",
	    path->rule.r_value.path, batchp->message.message_uid);
	if (spret == -1 || spret >= MAXPATHLEN)
a990 1
	int spret;
d993 1
a993 2
	spret = snprintf(pathname, MAXPATHLEN, "%s", path->u.filename);
	if (spret == -1 || spret >= MAXPATHLEN)
@


1.12
log
@- fix event masking issues in smtp process which could lead to a fatal() if
	queue process did not answer fast enough to an imsg. spotted by
	Jacek Masiulaniec <jacekm@@dobremiasto.net>
- queue layout was mostly to bootstrap the project, it does not behave good
	under load, it does complex things to stay in a recoverable state
	and it probably didnt do it too well. New queue code is simpler,
	smaller and allows for atomic submissions (a mail can never be in a
	state where it needs to be recovered). It still needs some work but
	works better than previous code, no regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.11 2008/11/22 22:22:05 gilles Exp $	*/
d71 1
d98 2
a99 1
		smtp_pid
d432 1
d577 1
@


1.11
log
@- do not set nochdir in daemon() call, we want parent and lka to have their
	wd reset to / rather than current working directory.
	From Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.10 2008/11/17 20:37:48 gilles Exp $	*/
d62 1
d626 3
a628 2
	char		*paths[] = { PATH_MESSAGES, PATH_LOCAL, PATH_RELAY,
				     PATH_DAEMON, PATH_ENVELOPES };
d756 2
d759 5
a763 2
	spret = snprintf(pathname, MAXPATHLEN, "%s%s/%s",
	    PATH_SPOOL, PATH_MESSAGES, batchp->message_id);
@


1.10
log
@- replace uses of O_EXLOCK and O_EXLOCK|O_NONBLOCK with the corresponding
	open()/flock() constructs as chl@@ says it prevents him from doing
	a portable build.

discussed with chl@@, diff is common work from him and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.9 2008/11/17 20:14:23 gilles Exp $	*/
d557 2
a558 2
	if (!debug) {
		if (daemon(1, 0) == -1)
a559 1
	}
@


1.9
log
@- exit() -> _exit()
- err()  -> fatal()

Both by Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.8 2008/11/11 21:02:20 gilles Exp $	*/
d774 1
d786 1
a786 1
	fd = open(pathname, O_CREAT|O_APPEND|O_RDWR|O_SYNC|O_NONBLOCK|O_EXLOCK, 0600);
d807 1
d810 2
a811 2
/*
	if (flock(fd, LOCK_EX) == -1) {
d816 1
a816 1
*/
d830 1
d855 1
a855 1
	fd = open(pathname, O_CREAT|O_RDWR|O_TRUNC|O_SYNC|O_EXLOCK, 0600);
d860 2
a861 2
/*
	if (flock(fd, LOCK_EX) == -1) {
d866 1
a866 1
*/
d1000 1
d1006 1
a1006 1
	fd = open(pathname, O_CREAT|O_APPEND|O_RDWR|O_SYNC|O_NONBLOCK|O_EXLOCK, 0600);
d1029 2
a1030 2
/*
	if (flock(fd, LOCK_EX) == -1) {
d1035 1
a1035 1
*/
@


1.8
log
@- temporarily comment chl@@'s O_EXLOCK -> fcntl() change until we understand
	what causes the mailbox lock bug i'm observing under heavy load.
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.7 2008/11/11 01:01:39 chl Exp $	*/
d977 1
a977 1
		exit(1);
d982 1
a982 1
		err(1, "calloc");
@


1.7
log
@remove the use of O_EXLOCK, when open()ing a file, and use flock() instead.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.6 2008/11/10 17:24:24 deraadt Exp $	*/
d314 1
d785 1
a785 1
	fd = open(pathname, O_CREAT|O_APPEND|O_RDWR|O_SYNC|O_NONBLOCK, 0600);
d808 1
a808 1

d814 1
a814 1

d852 1
a852 1
	fd = open(pathname, O_CREAT|O_RDWR|O_TRUNC|O_SYNC, 0600);
d857 1
a857 1

d863 1
a863 1

d1002 1
a1002 1
	fd = open(pathname, O_CREAT|O_APPEND|O_RDWR|O_SYNC|O_NONBLOCK, 0600);
d1025 1
a1025 1

d1031 1
a1031 1

@


1.6
log
@spaces fixed while reading code
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.5 2008/11/10 03:41:53 gilles Exp $	*/
d784 1
a784 1
	fd = open(pathname, O_CREAT|O_APPEND|O_RDWR|O_EXLOCK|O_SYNC|O_NONBLOCK, 0600);
d808 6
d851 1
a851 1
	fd = open(pathname, O_CREAT|O_RDWR|O_TRUNC|O_EXLOCK|O_SYNC, 0600);
d857 6
d1001 1
a1001 1
	fd = open(pathname, O_CREAT|O_APPEND|O_RDWR|O_EXLOCK|O_SYNC|O_NONBLOCK, 0600);
d1022 6
@


1.5
log
@- simplify the passing of ssl cert/key during ssl configuration,
	from Jacek Masiulaniec <jacekm@@dobremiasto.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.4 2008/11/10 00:57:35 gilles Exp $	*/
d475 1
a475 1
		/**/		
@


1.4
log
@- snprintf() can return -1, make sure every call is checked properly
@
text
@d1 1
a1 1
/*	$OpenBSD: smtpd.c,v 1.3 2008/11/05 12:14:45 sobrado Exp $	*/
d27 1
d117 1
a117 1
	struct buf		*b;
d126 9
a134 13
		b = imsg_create(env->sc_ibufs[PROC_SMTP], IMSG_CONF_SSL, 0, 0,
		    sizeof(*s) + s->ssl_cert_len + s->ssl_key_len);
		if (b == NULL)
			fatal("imsg_create");
		if (imsg_add(b, s, sizeof(*s)) == -1)
			fatal("imsg_add: ssl");
		if (imsg_add(b, s->ssl_cert, s->ssl_cert_len) == -1)
			fatal("imsg_add: ssl_cert");
		if (imsg_add(b, s->ssl_key, s->ssl_key_len) == -1)
			fatal("imsg_add: ssl_key");
		b->fd = -1;
		if (imsg_close(env->sc_ibufs[PROC_SMTP], b) == -1)
			fatal("imsg_close");
@


1.3
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d633 1
d635 2
a636 1
	if (snprintf(pathname, MAXPATHLEN, "%s", PATH_SPOOL) >= MAXPATHLEN)
d681 3
a683 2
		if (snprintf(pathname, MAXPATHLEN, "%s%s", PATH_SPOOL,
			paths[n]) >= MAXPATHLEN)
d756 1
d758 3
a760 3
	if (snprintf(pathname, MAXPATHLEN, "%s%s/%s",
	    PATH_SPOOL, PATH_MESSAGES, batchp->message_id)
	    >= MAXPATHLEN) {
d775 1
d783 3
a785 1
	(void)snprintf(pathname, MAXPATHLEN, "%s", path->rule.r_value.path);
d823 1
d831 4
a834 2
	snprintf(pathname, MAXPATHLEN, "%s", path->rule.r_value.path);
	log_debug("PATH: %s", pathname);
d840 4
a843 2
	if (snprintf(pathname, MAXPATHLEN, "%s/tmp/%s",
		pathname, batchp->message.message_uid) >= MAXPATHLEN) {
d865 1
d868 2
a869 2
		if (snprintf(pathname, MAXPATHLEN, "%s%s", root, subdir[i])
		    >= MAXPATHLEN)
d887 1
d902 1
a902 1
	(void)snprintf(srcpath, MAXPATHLEN, "%s/tmp/%s",
d904 4
a907 1
	(void)snprintf(dstpath, MAXPATHLEN, "%s/new/%s",
d909 2
d986 5
a991 1
	(void)snprintf(pathname, MAXPATHLEN, "%s", path->u.filename);
@


1.2
log
@various minor tweaks, including spelling fixes from Brian Keefer
and Jim Razmus;
@
text
@d1 2
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d76 2
a77 1
	fprintf(stderr, "usage: %s [-n] [-f config]\n", __progname);
@

