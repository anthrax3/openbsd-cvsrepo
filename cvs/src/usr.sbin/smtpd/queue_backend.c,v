head	1.62;
access;
symbols
	OPENBSD_6_2:1.62.0.4
	OPENBSD_6_2_BASE:1.62
	OPENBSD_6_1:1.62.0.8
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.62.0.6
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.55.0.6
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.47.0.2
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.42.0.2
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.62
date	2016.02.04.12.46.28;	author eric;	state Exp;
branches;
next	1.61;
commitid	nqGvDOI09GvQuEfF;

1.61
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.60;
commitid	ZxnqOQqX6IeYI9jW;

1.60
date	2015.12.14.10.22.12;	author jung;	state Exp;
branches;
next	1.59;
commitid	HRAnniyhGW9Sadln;

1.59
date	2015.11.05.09.14.31;	author sunil;	state Exp;
branches;
next	1.58;
commitid	3vo6L6sIqhuEjLcD;

1.58
date	2015.11.05.08.59.23;	author sunil;	state Exp;
branches;
next	1.57;
commitid	XYVkrzjbL9Y8yA7Z;

1.57
date	2015.10.29.10.25.36;	author sunil;	state Exp;
branches;
next	1.56;
commitid	TXZugvtal96cI6ec;

1.56
date	2015.10.09.14.37.38;	author gilles;	state Exp;
branches;
next	1.55;
commitid	Av5gnXBLeZb6m0W2;

1.55
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	ZBTFreARDSMmzOIV;

1.54
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	Uu5nFG3wCl0LACBb;

1.53
date	2014.12.08.08.19.36;	author gilles;	state Exp;
branches;
next	1.52;
commitid	oheizDps8JTG0gIn;

1.52
date	2014.07.08.15.45.32;	author eric;	state Exp;
branches;
next	1.51;
commitid	BLF7pkUK3dHr6Hox;

1.51
date	2014.07.07.09.11.24;	author eric;	state Exp;
branches;
next	1.50;
commitid	i5e19t9Ki1zvGnyP;

1.50
date	2014.04.11.02.58.08;	author jsg;	state Exp;
branches;
next	1.49;

1.49
date	2014.03.14.05.27.00;	author halex;	state Exp;
branches;
next	1.48;

1.48
date	2014.03.13.20.39.27;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.46;

1.46
date	2013.07.19.20.37.07;	author eric;	state Exp;
branches;
next	1.45;

1.45
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.44;

1.44
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.43;

1.43
date	2013.04.17.15.02.38;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.41;

1.41
date	2012.11.23.09.25.44;	author eric;	state Exp;
branches;
next	1.40;

1.40
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.39;

1.39
date	2012.10.09.13.39.00;	author eric;	state Exp;
branches;
next	1.38;

1.38
date	2012.09.01.16.09.14;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2012.08.30.19.33.25;	author chl;	state Exp;
branches;
next	1.36;

1.36
date	2012.08.30.19.28.40;	author chl;	state Exp;
branches;
next	1.35;

1.35
date	2012.08.29.16.26.17;	author gilles;	state Exp;
branches;
next	1.34;

1.34
date	2012.08.26.11.21.28;	author gilles;	state Exp;
branches;
next	1.33;

1.33
date	2012.08.25.23.35.09;	author chl;	state Exp;
branches;
next	1.32;

1.32
date	2012.08.24.19.51.48;	author eric;	state Exp;
branches;
next	1.31;

1.31
date	2012.08.24.13.21.56;	author chl;	state Exp;
branches;
next	1.30;

1.30
date	2012.08.24.13.13.13;	author chl;	state Exp;
branches;
next	1.29;

1.29
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.10.23.21.34;	author chl;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.09.08.08.29;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.08.18.13.08;	author chl;	state Exp;
branches;
next	1.25;

1.25
date	2012.07.02.17.00.05;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2012.06.20.20.45.23;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2012.06.08.11.34.23;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2012.06.03.19.52.56;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2012.06.01.11.42.34;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2012.01.14.15.13.14;	author chl;	state Exp;
branches;
next	1.19;

1.19
date	2012.01.13.21.58.35;	author eric;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.23.12.10.06;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2011.12.19.19.57.25;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2011.12.16.17.35.00;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2011.12.14.17.55.55;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.15.23.06.39;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2011.10.23.13.03.04;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2011.10.23.09.30.07;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.16.21.05.52;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.17.11.39.22;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.15.17.01.05;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.14.23.26.16;	author gilles;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.14.20.11.08;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.14.17.06.43;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.09.22.07.56;	author gilles;	state dead;
branches;
next	1.3;

1.3
date	2010.06.01.23.06.23;	author jacekm;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.01.19.47.09;	author jacekm;	state dead;
branches;
next	1.1;

1.1
date	2010.05.31.23.38.56;	author jacekm;	state Exp;
branches;
next	;


desc
@@


1.62
log
@When deleting a message, remove associated envelopes from the cache,
if any (it happens when a message transaction is cancelled).

ok gilles@@ sunil@@
@
text
@/*	$OpenBSD: queue_backend.c,v 1.61 2015/12/28 22:08:30 jung Exp $	*/

/*
 * Copyright (c) 2011 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <grp.h>
#include <imsg.h>
#include <limits.h>
#include <inttypes.h>
#include <libgen.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "smtpd.h"
#include "log.h"

static const char* envelope_validate(struct envelope *);

extern struct queue_backend	queue_backend_fs;
extern struct queue_backend	queue_backend_null;
extern struct queue_backend	queue_backend_proc;
extern struct queue_backend	queue_backend_ram;

static void queue_envelope_cache_add(struct envelope *);
static void queue_envelope_cache_update(struct envelope *);
static void queue_envelope_cache_del(uint64_t evpid);

TAILQ_HEAD(evplst, envelope);

static struct tree		evpcache_tree;
static struct evplst		evpcache_list;
static struct queue_backend	*backend;

static int (*handler_close)(void);
static int (*handler_message_create)(uint32_t *);
static int (*handler_message_commit)(uint32_t, const char*);
static int (*handler_message_delete)(uint32_t);
static int (*handler_message_fd_r)(uint32_t);
static int (*handler_message_corrupt)(uint32_t);
static int (*handler_message_uncorrupt)(uint32_t);
static int (*handler_envelope_create)(uint32_t, const char *, size_t, uint64_t *);
static int (*handler_envelope_delete)(uint64_t);
static int (*handler_envelope_update)(uint64_t, const char *, size_t);
static int (*handler_envelope_load)(uint64_t, char *, size_t);
static int (*handler_envelope_walk)(uint64_t *, char *, size_t);
static int (*handler_message_walk)(uint64_t *, char *, size_t,
    uint32_t, int *, void **);

#ifdef QUEUE_PROFILING

static struct {
	struct timespec	 t0;
	const char	*name;
} profile;

static inline void profile_enter(const char *name)
{
	if ((profiling & PROFILE_QUEUE) == 0)
		return;

	profile.name = name;
	clock_gettime(CLOCK_MONOTONIC, &profile.t0);
}

static inline void profile_leave(void)
{
	struct timespec	 t1, dt;

	if ((profiling & PROFILE_QUEUE) == 0)
		return;

	clock_gettime(CLOCK_MONOTONIC, &t1);
	timespecsub(&t1, &profile.t0, &dt);
	log_debug("profile-queue: %s %lld.%09ld", profile.name,
	    (long long)dt.tv_sec, dt.tv_nsec);
}
#else
#define profile_enter(x)	do {} while (0)
#define profile_leave()		do {} while (0)
#endif

static int
queue_message_path(uint32_t msgid, char *buf, size_t len)
{
	return bsnprintf(buf, len, "%s/%08"PRIx32, PATH_TEMPORARY, msgid);
}

int
queue_init(const char *name, int server)
{
	struct passwd	*pwq;
	struct group	*gr;
	int		 r;

	pwq = getpwnam(SMTPD_QUEUE_USER);
	if (pwq == NULL)
		errx(1, "unknown user %s", SMTPD_QUEUE_USER);

	gr = getgrnam(SMTPD_QUEUE_GROUP);
	if (gr == NULL)
		errx(1, "unknown group %s", SMTPD_QUEUE_GROUP);

	tree_init(&evpcache_tree);
	TAILQ_INIT(&evpcache_list);

	if (!strcmp(name, "fs"))
		backend = &queue_backend_fs;
	else if (!strcmp(name, "null"))
		backend = &queue_backend_null;
	else if (!strcmp(name, "ram"))
		backend = &queue_backend_ram;
	else
		backend = &queue_backend_proc;

	if (server) {
		if (ckdir(PATH_SPOOL, 0711, 0, 0, 1) == 0)
			errx(1, "error in spool directory setup");
		if (ckdir(PATH_SPOOL PATH_OFFLINE, 0770, 0, gr->gr_gid, 1) == 0)
			errx(1, "error in offline directory setup");
		if (ckdir(PATH_SPOOL PATH_PURGE, 0700, pwq->pw_uid, 0, 1) == 0)
			errx(1, "error in purge directory setup");

		mvpurge(PATH_SPOOL PATH_TEMPORARY, PATH_SPOOL PATH_PURGE);

		if (ckdir(PATH_SPOOL PATH_TEMPORARY, 0700, pwq->pw_uid, 0, 1) == 0)
			errx(1, "error in purge directory setup");
	}

	r = backend->init(pwq, server, name);

	log_trace(TRACE_QUEUE, "queue-backend: queue_init(%d) -> %d", server, r);

	return (r);
}

int
queue_close(void)
{
	if (handler_close)
		return (handler_close());

	return (1);
}

int
queue_message_create(uint32_t *msgid)
{
	int	r;

	profile_enter("queue_message_create");
	r = handler_message_create(msgid);
	profile_leave();

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_message_create() -> %d (%08"PRIx32")",
	    r, *msgid);

	return (r);
}

int
queue_message_delete(uint32_t msgid)
{
	char	msgpath[PATH_MAX];
	uint64_t evpid;
	void   *iter;
	int	r;

	profile_enter("queue_message_delete");
	r = handler_message_delete(msgid);
	profile_leave();

	/* in case the message is incoming */
	queue_message_path(msgid, msgpath, sizeof(msgpath));
	unlink(msgpath);

	/* remove remaining envelopes from the cache if any (on rollback) */
	evpid = msgid_to_evpid(msgid);
	for (;;) {
		iter = NULL;
		if (!tree_iterfrom(&evpcache_tree, &iter, evpid, &evpid, NULL))
			break;
		if (evpid_to_msgid(evpid) != msgid)
			break;
		queue_envelope_cache_del(evpid);
	}

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_message_delete(%08"PRIx32") -> %d", msgid, r);

	return (r);
}

int
queue_message_commit(uint32_t msgid)
{
	int	r;
	char	msgpath[PATH_MAX];
	char	tmppath[PATH_MAX];
	FILE	*ifp = NULL;
	FILE	*ofp = NULL;

	profile_enter("queue_message_commit");

	queue_message_path(msgid, msgpath, sizeof(msgpath));

	if (env->sc_queue_flags & QUEUE_COMPRESSION) {
		bsnprintf(tmppath, sizeof tmppath, "%s.comp", msgpath);
		ifp = fopen(msgpath, "r");
		ofp = fopen(tmppath, "w+");
		if (ifp == NULL || ofp == NULL)
			goto err;
		if (!compress_file(ifp, ofp))
			goto err;
		fclose(ifp);
		fclose(ofp);
		ifp = NULL;
		ofp = NULL;

		if (rename(tmppath, msgpath) == -1) {
			if (errno == ENOSPC)
				return (0);
			unlink(tmppath);
			log_warn("rename");
			return (0);
		}
	}

	if (env->sc_queue_flags & QUEUE_ENCRYPTION) {
		bsnprintf(tmppath, sizeof tmppath, "%s.enc", msgpath);
		ifp = fopen(msgpath, "r");
		ofp = fopen(tmppath, "w+");
		if (ifp == NULL || ofp == NULL)
			goto err;
		if (!crypto_encrypt_file(ifp, ofp))
			goto err;
		fclose(ifp);
		fclose(ofp);
		ifp = NULL;
		ofp = NULL;

		if (rename(tmppath, msgpath) == -1) {
			if (errno == ENOSPC)
				return (0);
			unlink(tmppath);
			log_warn("rename");
			return (0);
		}
	}

	r = handler_message_commit(msgid, msgpath);
	profile_leave();

	/* in case it's not done by the backend */
	unlink(msgpath);

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_message_commit(%08"PRIx32") -> %d",
	    msgid, r);

	return (r);

err:
	if (ifp)
		fclose(ifp);
	if (ofp)
		fclose(ofp);
	return 0;
}

int
queue_message_corrupt(uint32_t msgid)
{
	int	r;

	profile_enter("queue_message_corrupt");
	r = handler_message_corrupt(msgid);
	profile_leave();

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_message_corrupt(%08"PRIx32") -> %d", msgid, r);

	return (r);
}

int
queue_message_uncorrupt(uint32_t msgid)
{
	return handler_message_uncorrupt(msgid);
}

int
queue_message_fd_r(uint32_t msgid)
{
	int	fdin = -1, fdout = -1, fd = -1;
	FILE	*ifp = NULL;
	FILE	*ofp = NULL;

	profile_enter("queue_message_fd_r");
	fdin = handler_message_fd_r(msgid);
	profile_leave();

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_message_fd_r(%08"PRIx32") -> %d", msgid, fdin);

	if (fdin == -1)
		return (-1);

	if (env->sc_queue_flags & QUEUE_ENCRYPTION) {
		if ((fdout = mktmpfile()) == -1)
			goto err;
		if ((fd = dup(fdout)) == -1)
			goto err;
		if ((ifp = fdopen(fdin, "r")) == NULL)
			goto err;
		fdin = fd;
		fd = -1;
		if ((ofp = fdopen(fdout, "w+")) == NULL)
			goto err;

		if (!crypto_decrypt_file(ifp, ofp))
			goto err;

		fclose(ifp);
		ifp = NULL;
		fclose(ofp);
		ofp = NULL;
		lseek(fdin, SEEK_SET, 0);
	}

	if (env->sc_queue_flags & QUEUE_COMPRESSION) {
		if ((fdout = mktmpfile()) == -1)
			goto err;
		if ((fd = dup(fdout)) == -1)
			goto err;
		if ((ifp = fdopen(fdin, "r")) == NULL)
			goto err;
		fdin = fd;
		fd = -1;
		if ((ofp = fdopen(fdout, "w+")) == NULL)
			goto err;

		if (!uncompress_file(ifp, ofp))
			goto err;

		fclose(ifp);
		ifp = NULL;
		fclose(ofp);
		ofp = NULL;
		lseek(fdin, SEEK_SET, 0);
	}

	return (fdin);

err:
	if (fd != -1)
		close(fd);
	if (fdin != -1)
		close(fdin);
	if (fdout != -1)
		close(fdout);
	if (ifp)
		fclose(ifp);
	if (ofp)
		fclose(ofp);
	return -1;
}

int
queue_message_fd_rw(uint32_t msgid)
{
	char buf[PATH_MAX];

	queue_message_path(msgid, buf, sizeof(buf));

	return open(buf, O_RDWR | O_CREAT | O_EXCL, 0600);
}

static int
queue_envelope_dump_buffer(struct envelope *ep, char *evpbuf, size_t evpbufsize)
{
	char   *evp;
	size_t	evplen;
	size_t	complen;
	char	compbuf[sizeof(struct envelope)];
	size_t	enclen;
	char	encbuf[sizeof(struct envelope)];

	evp = evpbuf;
	evplen = envelope_dump_buffer(ep, evpbuf, evpbufsize);
	if (evplen == 0)
		return (0);

	if (env->sc_queue_flags & QUEUE_COMPRESSION) {
		complen = compress_chunk(evp, evplen, compbuf, sizeof compbuf);
		if (complen == 0)
			return (0);
		evp = compbuf;
		evplen = complen;
	}

	if (env->sc_queue_flags & QUEUE_ENCRYPTION) {
		enclen = crypto_encrypt_buffer(evp, evplen, encbuf, sizeof encbuf);
		if (enclen == 0)
			return (0);
		evp = encbuf;
		evplen = enclen;
	}

	memmove(evpbuf, evp, evplen);

	return (evplen);
}

static int
queue_envelope_load_buffer(struct envelope *ep, char *evpbuf, size_t evpbufsize)
{
	char		*evp;
	size_t		 evplen;
	char		 compbuf[sizeof(struct envelope)];
	size_t		 complen;
	char		 encbuf[sizeof(struct envelope)];
	size_t		 enclen;

	evp = evpbuf;
	evplen = evpbufsize;

	if (env->sc_queue_flags & QUEUE_ENCRYPTION) {
		enclen = crypto_decrypt_buffer(evp, evplen, encbuf, sizeof encbuf);
		if (enclen == 0)
			return (0);
		evp = encbuf;
		evplen = enclen;
	}

	if (env->sc_queue_flags & QUEUE_COMPRESSION) {
		complen = uncompress_chunk(evp, evplen, compbuf, sizeof compbuf);
		if (complen == 0)
			return (0);
		evp = compbuf;
		evplen = complen;
	}

	return (envelope_load_buffer(ep, evp, evplen));
}

static void
queue_envelope_cache_add(struct envelope *e)
{
	struct envelope *cached;

	while (tree_count(&evpcache_tree) >= env->sc_queue_evpcache_size)
		queue_envelope_cache_del(TAILQ_LAST(&evpcache_list, evplst)->id);

	cached = xcalloc(1, sizeof *cached, "queue_envelope_cache_add");
	*cached = *e;
	TAILQ_INSERT_HEAD(&evpcache_list, cached, entry);
	tree_xset(&evpcache_tree, e->id, cached);
	stat_increment("queue.evpcache.size", 1);
}

static void
queue_envelope_cache_update(struct envelope *e)
{
	struct envelope *cached;

	if ((cached = tree_get(&evpcache_tree, e->id)) == NULL) {
		queue_envelope_cache_add(e);
		stat_increment("queue.evpcache.update.missed", 1);
	} else {
		TAILQ_REMOVE(&evpcache_list, cached, entry);
		*cached = *e;
		TAILQ_INSERT_HEAD(&evpcache_list, cached, entry);
		stat_increment("queue.evpcache.update.hit", 1);
	}
}

static void
queue_envelope_cache_del(uint64_t evpid)
{
	struct envelope *cached;

	if ((cached = tree_pop(&evpcache_tree, evpid)) == NULL)
		return;

	TAILQ_REMOVE(&evpcache_list, cached, entry);
	free(cached);
	stat_decrement("queue.evpcache.size", 1);
}

int
queue_envelope_create(struct envelope *ep)
{
	int		 r;
	char		 evpbuf[sizeof(struct envelope)];
	size_t		 evplen;
	uint64_t	 evpid;
	uint32_t	 msgid;

	ep->creation = time(NULL);
	evplen = queue_envelope_dump_buffer(ep, evpbuf, sizeof evpbuf);
	if (evplen == 0)
		return (0);

	evpid = ep->id;
	msgid = evpid_to_msgid(evpid);

	profile_enter("queue_envelope_create");
	r = handler_envelope_create(msgid, evpbuf, evplen, &ep->id);
	profile_leave();

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_envelope_create(%016"PRIx64", %zu) -> %d (%016"PRIx64")",
	    evpid, evplen, r, ep->id);

	if (!r) {
		ep->creation = 0;
		ep->id = 0;
	}

	if (r && env->sc_queue_flags & QUEUE_EVPCACHE)
		queue_envelope_cache_add(ep);

	return (r);
}

int
queue_envelope_delete(uint64_t evpid)
{
	int	r;

	if (env->sc_queue_flags & QUEUE_EVPCACHE)
		queue_envelope_cache_del(evpid);

	profile_enter("queue_envelope_delete");
	r = handler_envelope_delete(evpid);
	profile_leave();

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_envelope_delete(%016"PRIx64") -> %d",
	    evpid, r);

	return (r);
}

int
queue_envelope_load(uint64_t evpid, struct envelope *ep)
{
	const char	*e;
	char		 evpbuf[sizeof(struct envelope)];
	size_t		 evplen;
	struct envelope	*cached;

	if ((env->sc_queue_flags & QUEUE_EVPCACHE) &&
	    (cached = tree_get(&evpcache_tree, evpid))) {
		*ep = *cached;
		stat_increment("queue.evpcache.load.hit", 1);
		return (1);
	}

	ep->id = evpid;
	profile_enter("queue_envelope_load");
	evplen = handler_envelope_load(ep->id, evpbuf, sizeof evpbuf);
	profile_leave();

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_envelope_load(%016"PRIx64") -> %zu",
	    evpid, evplen);

	if (evplen == 0)
		return (0);

	if (queue_envelope_load_buffer(ep, evpbuf, evplen)) {
		if ((e = envelope_validate(ep)) == NULL) {
			ep->id = evpid;
			if (env->sc_queue_flags & QUEUE_EVPCACHE) {
				queue_envelope_cache_add(ep);
				stat_increment("queue.evpcache.load.missed", 1);
			}
			return (1);
		}
		log_debug("debug: invalid envelope %016" PRIx64 ": %s",
		    ep->id, e);
	}

	(void)queue_message_corrupt(evpid_to_msgid(evpid));
	return (0);
}

int
queue_envelope_update(struct envelope *ep)
{
	char	evpbuf[sizeof(struct envelope)];
	size_t	evplen;
	int	r;

	evplen = queue_envelope_dump_buffer(ep, evpbuf, sizeof evpbuf);
	if (evplen == 0)
		return (0);

	profile_enter("queue_envelope_update");
	r = handler_envelope_update(ep->id, evpbuf, evplen);
	profile_leave();

	if (r && env->sc_queue_flags & QUEUE_EVPCACHE)
		queue_envelope_cache_update(ep);

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_envelope_update(%016"PRIx64") -> %d",
	    ep->id, r);

	return (r);
}

int
queue_message_walk(struct envelope *ep, uint32_t msgid, int *done, void **data)
{
	char		 evpbuf[sizeof(struct envelope)];
	uint64_t	 evpid;
	int		 r;
	const char	*e;

	profile_enter("queue_message_walk");
	r = handler_message_walk(&evpid, evpbuf, sizeof evpbuf,
	    msgid, done, data);
	profile_leave();

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_message_walk() -> %d (%016"PRIx64")",
	    r, evpid);

	if (r == -1)
		return (r);

	if (r && queue_envelope_load_buffer(ep, evpbuf, (size_t)r)) {
		if ((e = envelope_validate(ep)) == NULL) {
			ep->id = evpid;
			/*
			 * do not cache the envelope here, while discovering
			 * envelopes one could re-run discover on already
			 * scheduled envelopes which leads to triggering of
			 * strict checks in caching. Envelopes could anyway
			 * be loaded from backend if it isn't cached.
			 */
			return (1);
		}
		log_debug("debug: invalid envelope %016" PRIx64 ": %s",
		    ep->id, e);
		(void)queue_message_corrupt(evpid_to_msgid(evpid));
	}

	return (0);
}

int
queue_envelope_walk(struct envelope *ep)
{
	const char	*e;
	uint64_t	 evpid;
	char		 evpbuf[sizeof(struct envelope)];
	int		 r;

	profile_enter("queue_envelope_walk");
	r = handler_envelope_walk(&evpid, evpbuf, sizeof evpbuf);
	profile_leave();

	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_envelope_walk() -> %d (%016"PRIx64")",
	    r, evpid);

	if (r == -1)
		return (r);

	if (r && queue_envelope_load_buffer(ep, evpbuf, (size_t)r)) {
		if ((e = envelope_validate(ep)) == NULL) {
			ep->id = evpid;
			if (env->sc_queue_flags & QUEUE_EVPCACHE)
				queue_envelope_cache_add(ep);
			return (1);
		}
		log_debug("debug: invalid envelope %016" PRIx64 ": %s",
		    ep->id, e);
		(void)queue_message_corrupt(evpid_to_msgid(evpid));
	}

	return (0);
}

uint32_t
queue_generate_msgid(void)
{
	uint32_t msgid;

	while ((msgid = arc4random()) == 0)
		;

	return msgid;
}

uint64_t
queue_generate_evpid(uint32_t msgid)
{
	uint32_t rnd;
	uint64_t evpid;

	while ((rnd = arc4random()) == 0)
		;

	evpid = msgid;
	evpid <<= 32;
	evpid |= rnd;

	return evpid;
}

static const char*
envelope_validate(struct envelope *ep)
{
	if (ep->version != SMTPD_ENVELOPE_VERSION)
		return "version mismatch";

	if (memchr(ep->helo, '\0', sizeof(ep->helo)) == NULL)
		return "invalid helo";
	if (ep->helo[0] == '\0')
		return "empty helo";

	if (memchr(ep->hostname, '\0', sizeof(ep->hostname)) == NULL)
		return "invalid hostname";
	if (ep->hostname[0] == '\0')
		return "empty hostname";

	if (memchr(ep->errorline, '\0', sizeof(ep->errorline)) == NULL)
		return "invalid error line";

	return NULL;
}

void
queue_api_on_close(int(*cb)(void))
{
	handler_close = cb;
}

void
queue_api_on_message_create(int(*cb)(uint32_t *))
{
	handler_message_create = cb;
}

void
queue_api_on_message_commit(int(*cb)(uint32_t, const char *))
{
	handler_message_commit = cb;
}

void
queue_api_on_message_delete(int(*cb)(uint32_t))
{
	handler_message_delete = cb;
}

void
queue_api_on_message_fd_r(int(*cb)(uint32_t))
{
	handler_message_fd_r = cb;
}

void
queue_api_on_message_corrupt(int(*cb)(uint32_t))
{
	handler_message_corrupt = cb;
}

void
queue_api_on_message_uncorrupt(int(*cb)(uint32_t))
{
	handler_message_uncorrupt = cb;
}

void
queue_api_on_envelope_create(int(*cb)(uint32_t, const char *, size_t, uint64_t *))
{
	handler_envelope_create = cb;
}

void
queue_api_on_envelope_delete(int(*cb)(uint64_t))
{
	handler_envelope_delete = cb;
}

void
queue_api_on_envelope_update(int(*cb)(uint64_t, const char *, size_t))
{
	handler_envelope_update = cb;
}

void
queue_api_on_envelope_load(int(*cb)(uint64_t, char *, size_t))
{
	handler_envelope_load = cb;
}

void
queue_api_on_envelope_walk(int(*cb)(uint64_t *, char *, size_t))
{
	handler_envelope_walk = cb;
}

void
queue_api_on_message_walk(int(*cb)(uint64_t *, char *, size_t,
    uint32_t, int *, void **))
{
	handler_message_walk = cb;
}
@


1.61
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.60 2015/12/14 10:22:12 jung Exp $	*/
d193 2
d204 11
@


1.60
log
@remove trailing whitespace

ok sunil gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.59 2015/11/05 09:14:31 sunil Exp $	*/
d228 1
a228 1
		if (! compress_file(ifp, ofp))
d250 1
a250 1
		if (! crypto_encrypt_file(ifp, ofp))
d336 1
a336 1
		if (! crypto_decrypt_file(ifp, ofp))
d358 1
a358 1
		if (! uncompress_file(ifp, ofp))
@


1.59
log
@Implement smtpctl uncorrupt <msgid>

"uncorrupt" moves envelopes from corrupt bucket back to the queue
for further discovery by the daemon.

After correcting the corrupt envelopes, admin could now...

# smtpctl uncorrupt msgid
# smtpctl discover msgid

to schedule the messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.58 2015/11/05 08:59:23 sunil Exp $	*/
d130 1
a130 1
	
d656 1
a656 1
			 * scheduled envelopes which leads to triggering of 
@


1.58
log
@Do not terminate message walk on a corrupt envelope.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.57 2015/10/29 10:25:36 sunil Exp $	*/
d68 1
d302 6
d787 6
@


1.57
log
@Implement smtpctl discover <evpid|msgid>.

discover subcommand schedules envelopes manually moved to the queue.
It triggers a queue walk searching for envelopes with the given id,
schedules them and informs the user number of envelopes scheduled.
Admins no longer would need to restart the daemon to discover
manually moved messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.56 2015/10/09 14:37:38 gilles Exp $	*/
d660 1
a660 1
	return (-1);
@


1.56
log
@turn our local enqueuer setgid _smtpq and restrict access to offline queue,
the enqueuer will revoke group and regain real gid right after mkstemp.

this would have prevented the symlink/hardlink attacks against offline, and
it will avoid having to deal with new ways users can mess with it.

ok eric@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.55 2015/01/20 17:37:54 deraadt Exp $	*/
d73 2
d624 40
d810 7
@


1.55
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.54 2015/01/16 06:40:21 deraadt Exp $	*/
d30 1
d117 1
d124 4
d143 1
a143 1
		if (ckdir(PATH_SPOOL PATH_OFFLINE, 01777, 0, 0, 1) == 0)
@


1.54
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.53 2014/12/08 08:19:36 gilles Exp $	*/
d372 1
a372 1
	char buf[SMTPD_MAXPATHLEN];
@


1.53
log
@no need for arc4random_uniform() here, arc4random() does the job

spotted by deraadt@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.52 2014/07/08 15:45:32 eric Exp $	*/
d31 1
d183 1
a183 1
	char	msgpath[MAXPATHLEN];
d204 2
a205 2
	char	msgpath[MAXPATHLEN];
	char	tmppath[MAXPATHLEN];
@


1.52
log
@various queue improvements:

- add a "close" hook to the backend API.
- improve the sync() pattern in queue_fs: only sync at commit
  time and not for every envelope creation
- various fixes to the experimental external queue API.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d653 1
a653 1
	while ((msgid = arc4random_uniform(0xffffffff)) == 0)
d665 1
a665 1
	while ((rnd = arc4random_uniform(0xffffffff)) == 0)
@


1.51
log
@Allow to enable profiling at runtime and fix timings output.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.50 2014/04/11 02:58:08 jsg Exp $	*/
d60 1
d126 1
a126 1
	if (!strcmp(name, "null"))
d128 3
a130 1
	if (!strcmp(name, "proc"))
a131 7
	if (!strcmp(name, "ram"))
		backend = &queue_backend_ram;

	if (backend == NULL) {
		log_warn("could not find queue backend \"%s\"", name);
		return (0);
	}
d147 1
a147 1
	r = backend->init(pwq, server);
d155 9
d642 1
a644 1
	(void)queue_message_corrupt(evpid_to_msgid(evpid));
d695 6
@


1.50
log
@fix a use after free in an error path
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.49 2014/03/14 05:27:00 halex Exp $	*/
d96 2
a97 3
	log_debug("profile-queue: %s %lld.%06ld", profile.name,
	    (long long)dt.tv_sec * 1000000 + dt.tv_nsec / 1000000,
	    dt.tv_nsec % 1000000);
@


1.49
log
@print the correct user name if SMTPD_QUEUE_USER is missing

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.48 2014/03/13 20:39:27 deraadt Exp $	*/
d320 1
d322 1
d342 1
d344 1
@


1.48
log
@When failing to find the required privsep user entry, it is not cool at
all to fall back to a different user entry.  It is decidedly unsafe.
ok tedu.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.47 2013/10/26 12:27:59 eric Exp $	*/
d119 1
a119 1
		errx(1, "unknown user %s", SMTPD_USER);
@


1.47
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.46 2013/07/19 20:37:07 eric Exp $	*/
a117 2
	if (pwq == NULL)
		pwq = getpwnam(SMTPD_USER);
@


1.46
log
@Assorted queue improvements:
- cleanup the internal queue backend API and get rid of the QOP_* thing.
- implement a queue_proc backend
- rename queue_fsqueue.c to queue_fs
- enable support for queue encryption
- add an envelope cache
- better logging and error reporting
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 1
a96 1
	log_debug("profile-queue: %s %lld.%06li", profile.name,
d156 1
a156 1
	log_trace(TRACE_QUEUE, "queue-backend: queue_init(%i) -> %i", server, r);
d171 1
a171 1
	    "queue-backend: queue_message_create() -> %i (%08"PRIx32")",
d192 1
a192 1
	    "queue-backend: queue_message_delete(%08"PRIx32") -> %i", msgid, r);
d261 1
a261 1
	    "queue-backend: queue_message_commit(%08"PRIx32") -> %i",
d284 1
a284 1
	    "queue-backend: queue_message_corrupt(%08"PRIx32") -> %i", msgid, r);
d301 1
a301 1
	    "queue-backend: queue_message_fd_r(%08"PRIx32") -> %i", msgid, fdin);
d506 1
a506 1
	    "queue-backend: queue_envelope_create(%016"PRIx64", %zu) -> %i (%016"PRIx64")",
d533 1
a533 1
	    "queue-backend: queue_envelope_delete(%016"PRIx64") -> %i",
d602 1
a602 1
	    "queue-backend: queue_envelope_update(%016"PRIx64") -> %i",
d621 1
a621 1
	    "queue-backend: queue_envelope_walk() -> %i (%016"PRIx64")",
@


1.45
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.44 2013/05/24 17:03:14 eric Exp $	*/
d47 1
d50 8
d60 11
d96 2
a97 2
	log_debug("profile-queue: %s %li.%06li", profile.name,
	    dt.tv_sec * 1000000 + dt.tv_nsec / 1000000,
d105 2
a106 2
int
queue_message_incoming_path(uint32_t msgid, char *buf, size_t len)
d108 1
a108 3
	return bsnprintf(buf, len, "%s/%08x",
	    PATH_INCOMING,
	    msgid);
d123 3
d130 2
d167 1
a167 1
	r = backend->message(QOP_CREATE, msgid);
d180 1
d184 1
a184 1
	r = backend->message(QOP_DELETE, &msgid);
d187 4
d207 2
a208 2
	queue_message_incoming_path(msgid, msgpath, sizeof msgpath);
	strlcat(msgpath, PATH_MESSAGE, sizeof(msgpath));
a210 1

d226 3
a228 1
			fatal("queue_message_commit: rename");
d232 23
a254 1
	r = backend->message(QOP_COMMIT, &msgid);
d257 3
d280 1
a280 1
	r = backend->message(QOP_CORRUPT, &msgid);
d297 1
a297 1
	fdin = backend->message(QOP_FD_R, &msgid);
d306 20
d365 1
a365 5
	int	r;

	profile_enter("queue_message_fd_rw");
	r = backend->message(QOP_FD_RW, &msgid);
	profile_leave();
d367 1
a367 2
	log_trace(TRACE_QUEUE,
	    "queue-backend: queue_message_fd_rw(%08"PRIx32") -> %i", msgid, r);
d369 1
a369 1
	return (r);
d379 2
d395 8
d415 2
d421 8
d440 44
d491 1
d499 1
d502 1
a502 1
	r = backend->envelope(QOP_CREATE, &ep->id, evpbuf, evplen);
d514 3
d525 3
d529 1
a529 1
	r = backend->envelope(QOP_DELETE, &evpid, NULL, 0);
d545 8
d556 1
a556 1
	evplen = backend->envelope(QOP_LOAD, &ep->id, evpbuf, sizeof evpbuf);
d569 4
d595 1
a595 1
	r = backend->envelope(QOP_UPDATE, &ep->id, evpbuf, evplen);
d598 3
d617 1
a617 1
	r = backend->envelope(QOP_WALK, &evpid, evpbuf, sizeof evpbuf);
d630 2
d689 60
@


1.44
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.42 2013/01/26 09:37:23 gilles Exp $	*/
d26 1
d96 8
a103 1
	int	r;
d117 15
a131 1
	r = backend->init(server);
@


1.43
log
@large time_t problems
ok gilles
@
text
@a21 1
#include <sys/param.h>
d75 2
a76 2
	log_debug("profile-queue: %s %lld.%06li", profile.name,
	    (long long)dt.tv_sec * 1000000 + dt.tv_nsec / 1000000,
d95 2
d109 5
a113 1
	return backend->init(server);
d125 4
d141 3
d151 4
d157 24
d184 4
d189 7
d207 3
d224 3
d230 1
a230 1
	if (env->sc_queue_flags & QUEUE_COMPRESS) {
d241 1
d244 1
d275 3
d284 4
a287 3
	char		 evpbufcom[sizeof(struct envelope)];
	char		*evp;
	size_t		 evplen;
d294 3
a296 4
	if (env->sc_queue_flags & QUEUE_COMPRESS) {
		evplen = compress_buffer(evp, evplen, evpbufcom,
		    sizeof evpbufcom);
		if (evplen == 0)
d298 2
a299 1
		evp = evpbufcom;
a309 1
	char		 evpbufcom[sizeof(struct envelope)];
d312 2
d318 3
a320 4
	if (env->sc_queue_flags & QUEUE_COMPRESS) {
		evplen = uncompress_buffer(evp, evplen, evpbufcom,
		    sizeof evpbufcom);
		if (evplen == 0)
d322 2
a323 1
		evp = evpbufcom;
d335 1
d342 2
d347 5
d356 1
d369 4
d387 5
d403 2
d423 4
d441 6
a446 1
	if (r == -1 || r == 0)
d449 1
a449 1
	if (queue_envelope_load_buffer(ep, evpbuf, (size_t)r)) {
d457 2
@


1.42
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.40 2012/11/12 14:58:53 eric Exp $	*/
d76 2
a77 2
	log_debug("profile-queue: %s %li.%06li", profile.name,
	    dt.tv_sec * 1000000 + dt.tv_nsec / 1000000,
@


1.41
log
@Replace the qwalk API (to retreive on disk envelopes at runtime) with
a simple QOP_WALK queue operation. Some knf and formating fixes while
there.

ok gilles@@
@
text
@d4 1
a4 1
 * Copyright (c) 2011 Gilles Chehade <gilles@@openbsd.org>
d46 1
d49 10
a58 2
int
queue_message_incoming_path(uint32_t msgid, char *buf, size_t len)
d60 5
a64 3
	return bsnprintf(buf, len, "%s/%08x",
	    PATH_INCOMING,
	    msgid);
d67 1
a67 2
int
queue_envelope_incoming_path(uint64_t evpid, char *buf, size_t len)
d69 10
a78 5
	return bsnprintf(buf, len, "%s/%08x%s/%016" PRIx64,
	    PATH_INCOMING,
	    evpid_to_msgid(evpid),
	    PATH_ENVELOPES,
	    evpid);
d80 4
d86 1
a86 1
queue_message_incoming_delete(uint32_t msgid)
d88 3
a90 9
	char rootdir[MAXPATHLEN];

	if (! queue_message_incoming_path(msgid, rootdir, sizeof(rootdir)))
		fatal("queue_message_incoming_delete: snprintf");

	if (rmtree(rootdir, 0) == -1)
		fatal("queue_message_incoming_delete: rmtree");

	return 1;
d93 2
a94 2
struct queue_backend *
queue_backend_lookup(const char *name)
d97 5
a101 1
		return &queue_backend_fs;
d103 6
a108 1
	return (NULL);
d114 7
a120 1
	return env->sc_queue->message(QOP_CREATE, msgid);
d126 7
a132 1
	return env->sc_queue->message(QOP_DELETE, &msgid);
d138 1
a138 4
	char	msgpath[MAXPATHLEN];
	char	tmppath[MAXPATHLEN];
	FILE	*ifp = NULL;
	FILE	*ofp = NULL;
d140 3
a142 2
	queue_message_incoming_path(msgid, msgpath, sizeof msgpath);
	strlcat(msgpath, PATH_MESSAGE, sizeof(msgpath));
d144 1
a144 29
	if (env->sc_queue_flags & QUEUE_COMPRESS) {

		bsnprintf(tmppath, sizeof tmppath, "%s.comp", msgpath);
		ifp = fopen(msgpath, "r");
		ofp = fopen(tmppath, "w+");
		if (ifp == NULL || ofp == NULL)
			goto err;
		if (! compress_file(ifp, ofp))
			goto err;
		fclose(ifp);
		fclose(ofp);
		ifp = NULL;
		ofp = NULL;

		if (rename(tmppath, msgpath) == -1) {
			if (errno == ENOSPC)
				return (0);
			fatal("queue_message_commit: rename");
		}
	}

	return env->sc_queue->message(QOP_COMMIT, &msgid);

err:
	if (ifp)
		fclose(ifp);
	if (ofp)
		fclose(ofp);
	return 0;
d150 7
a156 1
	return env->sc_queue->message(QOP_CORRUPT, &msgid);
d166 5
a170 1
	if ((fdin = env->sc_queue->message(QOP_FD_R, &msgid)) == -1)
d210 1
a210 1
	char msgpath[MAXPATHLEN];
d212 3
a214 2
	queue_message_incoming_path(msgid, msgpath, sizeof msgpath);
	strlcat(msgpath, PATH_MESSAGE, sizeof(msgpath));
d216 1
a216 1
	return open(msgpath, O_RDWR | O_CREAT | O_EXCL, 0600);
d277 3
a279 1
	r = env->sc_queue->envelope(QOP_CREATE, &ep->id, evpbuf, evplen);
d288 1
a288 1
queue_envelope_delete(struct envelope *ep)
d290 7
a296 1
	return env->sc_queue->envelope(QOP_DELETE, &ep->id, NULL, 0);
d307 3
a309 2
	evplen = env->sc_queue->envelope(QOP_LOAD, &ep->id, evpbuf,
	    sizeof evpbuf);
d327 3
a329 2
	char	 evpbuf[sizeof(struct envelope)];
	size_t	 evplen;
d335 5
a339 1
	return env->sc_queue->envelope(QOP_UPDATE, &ep->id, evpbuf, evplen);
d350 3
a352 1
	r = env->sc_queue->envelope(QOP_WALK, &evpid, evpbuf, sizeof evpbuf);
@


1.40
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.39 2012/10/09 13:39:00 eric Exp $	*/
d46 1
d217 2
a218 1
		evplen = compress_buffer(evp, evplen, evpbufcom, sizeof evpbufcom);
d240 2
a241 1
		evplen = uncompress_buffer(evp, evplen, evpbufcom, sizeof evpbufcom);
d284 2
a285 1
	evplen = env->sc_queue->envelope(QOP_LOAD, &ep->id, evpbuf, sizeof evpbuf);
d288 1
a288 1
		
d294 2
a295 1
		log_debug("debug: invalid envelope %016" PRIx64 ": %s", ep->id, e);
d313 2
a314 2
void *
qwalk_new(uint32_t msgid)
d316 4
a319 2
	return env->sc_queue->qwalk_new(msgid);
}
d321 3
a323 5
int
qwalk(void *hdl, uint64_t *evpid)
{
	return env->sc_queue->qwalk(hdl, evpid);
}
d325 9
a333 4
void
qwalk_close(void *hdl)
{
	return env->sc_queue->qwalk_close(hdl);
d341 1
a341 1
	while((msgid = arc4random_uniform(0xffffffff)) == 0)
d353 1
a353 1
	while((rnd = arc4random_uniform(0xffffffff)) == 0)
a362 2

/**/
@


1.39
log
@fix a FILE* leak when using compression.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.38 2012/09/01 16:09:14 gilles Exp $	*/
d290 1
a290 1
		log_debug("invalid envelope %016" PRIx64 ": %s", ep->id, e);
@


1.38
log
@- remove crypto_backend
- remove support for encrypted queue, it will be reintroduced later after
  pouring more thinking into it

if you had it enabled, flush your queue before updating
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.37 2012/08/30 19:33:25 chl Exp $	*/
d151 1
a151 1
	int	fdin = -1, fdout = -1;
d155 2
a156 1
	fdin = env->sc_queue->message(QOP_FD_R, &msgid);
d159 9
a167 4
		fdout = mktmpfile();
		ifp = fdopen(fdin, "r");
		ofp = fdopen(fdout, "w+");
		if (ifp == NULL || ofp == NULL)
a170 2
		fseek(ofp, SEEK_SET, 0);
		fdin = fileno(ofp);
d172 2
a173 2
		ifp = NULL;
		ofp = NULL;
d179 2
@


1.37
log
@switch compress_backend to use FILE * instead of file descriptors, like
crypto_backend

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.36 2012/08/30 19:28:40 chl Exp $	*/
a131 22
	if (env->sc_queue_flags & QUEUE_ENCRYPT) {

		bsnprintf(tmppath, sizeof tmppath, "%s.crypt", msgpath);
		ifp = fopen(msgpath, "r");
		ofp = fopen(tmppath, "w+");
		if (ifp == NULL || ofp == NULL)
			goto err;
		if (! crypto_encrypt_file(ifp, ofp))
			goto err;
		fclose(ifp);
		fclose(ofp);
		ifp = NULL;
		ofp = NULL;

		log_debug("tmppath=%s, msgpath=%s", tmppath, msgpath);
		if (rename(tmppath, msgpath) == -1) {
			if (errno == ENOSPC)
				return (0);
			fatal("queue_message_commit: rename");
		}
	}

a156 15
	if (env->sc_queue_flags & QUEUE_ENCRYPT) {
		fdout = mktmpfile();
		ifp = fdopen(fdin, "r");
		ofp = fdopen(fdout, "w+");
		if (ifp == NULL || ofp == NULL)
			goto err;
		if (! crypto_decrypt_file(ifp, ofp))
			goto err;
		fseek(ofp, SEEK_SET, 0);
		fdin = fileno(ofp);
		fclose(ifp);
		ifp = NULL;
		ofp = NULL;
	}

a200 1
	char		 evpbufenc[sizeof(struct envelope)];
d215 1
a215 7
	if (env->sc_queue_flags & QUEUE_ENCRYPT) {
		evplen = crypto_encrypt_buffer(evp, evplen, evpbufenc,
		    sizeof evpbufenc);
		if (evplen == 0)
			return (0);
		evp = evpbufenc;
	}
a224 1
	char		 evpbufenc[sizeof(struct envelope)];
a229 8

	if (env->sc_queue_flags & QUEUE_ENCRYPT) {
		evplen = crypto_decrypt_buffer(evp, evplen, evpbufenc,
		    sizeof evpbufenc);
		if (evplen == 0)
			return (0);
		evp = evpbufenc;
	}
@


1.36
log
@fix uninitialized variable which can be reach in case of failure.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.35 2012/08/29 16:26:17 gilles Exp $	*/
a104 1
	int	fdin = -1, fdout = -1;
d114 3
a116 3
		fdin = open(msgpath, O_RDONLY);
		fdout = open(tmppath, O_RDWR | O_CREAT | O_EXCL, 0600);
		if (fdin == -1 || fdout == -1)
d118 1
a118 1
		if (! compress_file(fdin, fdout))
d120 4
a123 2
		close(fdin);
		close(fdout);
a156 4
	if (fdin != -1)
		close(fdin);
	if (fdout != -1)
		close(fdout);
d196 3
a198 1
		if (! uncompress_file(fdin, fdout))
d200 7
a206 2
		close(fdin);
		fdin = fdout;
@


1.35
log
@Introduce the crypto_backend API and provide support for... encrypted queue
using the new API. By default, OpenSMTPD does not provide queue encryption,
but it can be enabled with "queue encryption [args]" and will transparently
encrypt/decrypt envelopes/messages as they hit the queue.

By default, it will use Blowfish in CBC mode with a different random IV for
each envelope and message. User provided key is expanded using sha256 but a
different cipher and digest may be specified in smtpd.conf

Queue encryption is compatible with compression and if both options are set
it will do them in correct order and transparently.

tested by chl@@, a few users and myself
ok chl@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.34 2012/08/26 11:21:28 gilles Exp $	*/
d176 1
a176 1
	int	fdin, fdout;
@


1.34
log
@- remove unused variable
- comment variables unused at this time
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.33 2012/08/25 23:35:09 chl Exp $	*/
d106 2
a130 1
#if 0
d134 3
a136 3
		fdin = open(msgpath, O_RDONLY);
		fdout = open(tmppath, O_RDWR | O_CREAT | O_EXCL, 0600);
		if (fdin == -1 || fdout == -1)
d138 1
a138 1
		if (! encrypt_file(fdin, fdout))
d140 4
a143 2
		close(fdin);
		close(fdout);
d145 1
a151 1
#endif
d160 4
d177 2
a181 1
#if 0
d184 3
a186 1
		if (! decrypt_file(fdin, fdout))
d188 7
a194 2
		close(fdin);
		fdin = fdout;
a195 1
#endif
d212 4
d234 1
a234 1
/*	char		 evpbufenc[sizeof(struct envelope)];*/
a248 2

#if 0
d250 2
a251 1
		evplen = encrypt_buffer(evp, evplen, evpbufenc, sizeof evpbufenc);
a255 2
#endif

d265 1
a265 1
/*	char		 evpbufenc[sizeof(struct envelope)];*/
a271 1
#if 0
d273 2
a274 1
		evplen = decrypt_buffer(evp, evplen, evpbufenc, sizeof evpbufenc);
a278 1
#endif
@


1.33
log
@Add compress_backend, allowing compression of messages and envelopes in the queue.
To use it, just add "queue compress" in smtpd.conf. For now, only zlib is used.

lots of feedback from eric@@ and gilles@@

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.32 2012/08/24 19:51:48 eric Exp $	*/
d216 1
a216 1
	char		 evpbufenc[sizeof(struct envelope)];
d250 1
a250 1
	char		 evpbufenc[sizeof(struct envelope)];
@


1.32
log
@envelope_validate() don't take the evpid anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.31 2012/08/24 13:21:56 chl Exp $	*/
d27 1
d103 47
d151 7
d169 30
a198 1
	return env->sc_queue->message(QOP_FD_R, &msgid);
d215 29
a243 1
	return (envelope_dump_buffer(ep, evpbuf, evpbufsize));
d249 25
a273 1
	return (envelope_load_buffer(ep, evpbuf, evpbufsize));
a274 1

@


1.31
log
@In envelope ascii dump/load:
- remove loading of evpid.
- don't dump the msgid
- ignore msgid at load
- remove now unused functions ascii_{dump,load}_uint{32,64}_hex()

With inputs from eric@@ and gilles@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.30 2012/08/24 13:13:13 chl Exp $	*/
d180 1
a180 1
		if ((e = envelope_validate(ep, evpid)) == NULL) {
@


1.30
log
@Don't pass struct envelope pointer in queue backend API, instead use envelope id and
an envelope ascii buffer.

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.29 2012/08/19 14:16:58 chl Exp $	*/
d42 1
a42 1
static const char* envelope_validate(struct envelope *, uint64_t);
d250 1
a250 1
envelope_validate(struct envelope *ep, uint64_t id)
a253 3

	if (evpid_to_msgid(ep->id) != (evpid_to_msgid(id)))
		return "msgid mismatch";
@


1.29
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.28 2012/07/10 23:21:34 chl Exp $	*/
d128 13
d144 3
a146 1
	int r;
d149 5
a153 1
	r = env->sc_queue->envelope(QOP_CREATE, ep);
d164 1
a164 1
	return env->sc_queue->envelope(QOP_DELETE, ep);
d171 2
d175 5
a179 1
	if (env->sc_queue->envelope(QOP_LOAD, ep)) {
d192 8
a199 1
	return env->sc_queue->envelope(QOP_UPDATE, ep);
@


1.28
log
@backout the:
- remove the /envelopes subdirectory, envelopes are at the same level than
  the message file
- kill PATH_ENVELOPES define

but keep the:
- reduce the number of buckets from 0xfff to 0xff, this avoid performances
  of the queue to decrease when we start having tons of buckets

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.27 2012/07/09 08:08:29 gilles Exp $	*/
d47 1
a47 1
queue_message_incoming_path(u_int32_t msgid, char *buf, size_t len)
d55 1
a55 1
queue_envelope_incoming_path(u_int64_t evpid, char *buf, size_t len)
d65 1
a65 1
queue_message_incoming_delete(u_int32_t msgid)
d88 1
a88 1
queue_message_create(u_int32_t *msgid)
d94 1
a94 1
queue_message_delete(u_int32_t msgid)
d100 1
a100 1
queue_message_commit(u_int32_t msgid)
d106 1
a106 1
queue_message_corrupt(u_int32_t msgid)
d112 1
a112 1
queue_message_fd_r(u_int32_t msgid)
d118 1
a118 1
queue_message_fd_rw(u_int32_t msgid)
d149 1
a149 1
queue_envelope_load(u_int64_t evpid, struct envelope *ep)
d171 1
a171 1
qwalk_new(u_int32_t msgid)
d177 1
a177 1
qwalk(void *hdl, u_int64_t *evpid)
d188 1
a188 1
u_int32_t
d191 1
a191 1
	u_int32_t msgid;
d199 2
a200 2
u_int64_t
queue_generate_evpid(u_int32_t msgid)
d202 2
a203 2
	u_int32_t rnd;
	u_int64_t evpid;
@


1.27
log
@first step of simplifying fsqueue:

- remove the /envelopes subdirectory, envelopes are at the same level than
  the message file
- kill PATH_ENVELOPES define
- reduce the number of buckets from 0xfff to 0xff, this avoid performances
  of the queue to decrease when we start having tons of buckets

this diff introduces a change to the queue layout, you will want to empty
your queue before updating. more cleanup to come

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.26 2012/07/08 18:13:08 chl Exp $	*/
d57 1
a57 1
	return bsnprintf(buf, len, "%s/%08x/%016" PRIx64,
d60 1
@


1.26
log
@remove enum queue_kind from queue_fsqueue.c.
incoming messages are now always stored in /incoming, whatever the queue_backend is.
remove QOP_FD_RW and fsqueue_message_fd_rw().
while there check return value of generated paths before calling rmtree()

with advice from gilles@@ and eric@@

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.25 2012/07/02 17:00:05 eric Exp $	*/
d57 1
a57 1
	return bsnprintf(buf, len, "%s/%08x%s/%016" PRIx64,
a59 1
	    PATH_ENVELOPES,
@


1.25
log
@Lookup queue and scheduler backends by name, rather than enum.
Add a command-line option to specify the backend to use at runtime.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.24 2012/06/20 20:45:23 eric Exp $	*/
d28 1
d46 31
d120 6
a125 1
	return env->sc_queue->message(QOP_FD_RW, &msgid);
@


1.24
log
@Finally get rid of the queue_kind enum in the queue API. Keep that
internally in fsqueue backend for now, and let the fsqueue_message()
and fsqueue_envelope() dispatchers do the right thing.

Based on a diff by chl@@

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.23 2012/06/08 11:34:23 chl Exp $	*/
a42 1
/* fsqueue backend */
d47 1
a47 1
queue_backend_lookup(enum queue_type type)
d49 1
a49 2
	switch (type) {
	case QT_FS:
a50 4

	default:
		fatalx("invalid queue type");
	}
@


1.23
log
@add missing header needed by time()

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.22 2012/06/03 19:52:56 eric Exp $	*/
d62 1
a62 1
queue_message_create(enum queue_kind qkind, u_int32_t *msgid)
d64 1
a64 1
	return env->sc_queue->message(qkind, QOP_CREATE, msgid);
d68 1
a68 1
queue_message_delete(enum queue_kind qkind, u_int32_t msgid)
d70 1
a70 1
	return env->sc_queue->message(qkind, QOP_DELETE, &msgid);
d74 1
a74 1
queue_message_commit(enum queue_kind qkind, u_int32_t msgid)
d76 1
a76 1
	return env->sc_queue->message(qkind, QOP_COMMIT, &msgid);
d80 1
a80 1
queue_message_corrupt(enum queue_kind qkind, u_int32_t msgid)
d82 1
a82 1
	return env->sc_queue->message(qkind, QOP_CORRUPT, &msgid);
d86 1
a86 1
queue_message_fd_r(enum queue_kind qkind, u_int32_t msgid)
d88 1
a88 1
	return env->sc_queue->message(qkind, QOP_FD_R, &msgid);
d92 1
a92 1
queue_message_fd_rw(enum queue_kind qkind, u_int32_t msgid)
d94 1
a94 1
	return env->sc_queue->message(qkind, QOP_FD_RW, &msgid);
d98 1
a98 1
queue_envelope_create(enum queue_kind qkind, struct envelope *ep)
d103 1
a103 1
	r = env->sc_queue->envelope(qkind, QOP_CREATE, ep);
d112 1
a112 1
queue_envelope_delete(enum queue_kind qkind, struct envelope *ep)
d114 1
a114 1
	return env->sc_queue->envelope(qkind, QOP_DELETE, ep);
d118 1
a118 1
queue_envelope_load(enum queue_kind qkind, u_int64_t evpid, struct envelope *ep)
d123 1
a123 1
	if (env->sc_queue->envelope(qkind, QOP_LOAD, ep)) {
d134 1
a134 1
queue_envelope_update(enum queue_kind qkind, struct envelope *ep)
d136 1
a136 1
	return env->sc_queue->envelope(qkind, QOP_UPDATE, ep);
d140 1
a140 1
qwalk_new(enum queue_kind kind, u_int32_t msgid)
d142 1
a142 1
	return env->sc_queue->qwalk_new(kind, msgid);
@


1.22
log
@Do not store the envelope id within the envelope, only the message id.
Make sure existing envelopes can be properly loaded.

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.21 2012/06/01 11:42:34 eric Exp $	*/
d35 1
@


1.21
log
@on envelope creation, setup and reset the relevant envelope fields in
the wrapper function rather than in individual backends.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.20 2012/01/14 15:13:14 chl Exp $	*/
d123 4
a126 2
		if ((e = envelope_validate(ep, evpid)) == NULL)
			return 1;
d129 1
a129 1
	return 0;
d191 2
a192 5
	if ((ep->id & 0xffffffff) == 0 || ((ep->id >> 32) & 0xffffffff) == 0)
		return "invalid id";

	if (ep->id != id)
		return "id mismatch";
@


1.20
log
@Add missing header needed by PRI format string

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.19 2012/01/13 21:58:35 eric Exp $	*/
d99 9
a107 1
	return env->sc_queue->envelope(qkind, QOP_CREATE, ep);
@


1.19
log
@queue_message_purge() and queue_message_delete() are actually the same
thing. Remove queue_message_purge() in favor of queue_message_delete
and simplify fsqueue_message_delete() implementation to move the
message dir to purge/

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.18 2011/12/23 12:10:06 eric Exp $	*/
d29 1
@


1.18
log
@On envelope creation, get the message id in a saner way than the
current confusing hack.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.17 2011/12/19 19:57:25 eric Exp $	*/
a74 6
}

int
queue_message_purge(enum queue_kind qkind, u_int32_t msgid)
{
	return env->sc_queue->message(qkind, QOP_PURGE, &msgid);
@


1.17
log
@fix/improve envelope_validate():
- return an informative error string if the envelope is invalid.
- take the envelope id as a parameter and make sure it matches.
- do not expect the errorline to start with an SMTP response code,
  as this is not always the case: a temporary failure with mda would
  cause the envelope to be marked as corrupted. Instead, just make sure
  that all string fields are actual strings to prevent overflows later.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.16 2011/12/16 17:35:00 eric Exp $	*/
a103 1
	ep->id >>= 32;
@


1.16
log
@simplify

ok chl@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.15 2011/12/14 17:55:55 eric Exp $	*/
d39 1
a39 1
static int envelope_validate(struct envelope *);
d117 2
d120 5
a124 2
	if (env->sc_queue->envelope(qkind, QOP_LOAD, ep))
		return envelope_validate(ep);
d181 2
a182 2
static int
envelope_validate(struct envelope *ep)
d185 1
a185 1
		return 0;
d187 2
a188 3
	if ((ep->id & 0xffffffff) == 0 ||
	    ((ep->id >> 32) & 0xffffffff) == 0)
		return 0;
d190 5
d196 1
a196 1
		return 0;
d198 2
d201 1
a201 1
		return 0;
d203 2
a204 7
	if (ep->errorline[0] != '\0') {
		if (! isdigit(ep->errorline[0]) ||
		    ! isdigit(ep->errorline[1]) ||
		    ! isdigit(ep->errorline[2]) ||
		    ep->errorline[3] != ' ')
			return 0;
	}
d206 1
a206 1
	return 1;
@


1.15
log
@make queue_fsqueue backend consistent with the backend scheme.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.14 2011/11/15 23:06:39 gilles Exp $	*/
d152 2
a153 4
again:
	msgid = arc4random_uniform(0xffffffff);
	if (msgid == 0)
		goto again;
d164 2
a165 4
again:
	rnd = arc4random_uniform(0xffffffff);
	if (rnd == 0)
		goto again;
@


1.14
log
@Qwalk, our API to linearly walk over the persistent queue, did not take the
queue_backend into account and assumed a filesystem with a specific layout.

This commit does plenty of things:

- make qwalk an abstraction in the queue_backend API, and impose queue
  drivers to implement qwalk_open(), qwalk() and qwalk_close();

- move previous qwalk_open(), qwalk() and qwalk_close() to the fsqueue
  driver since they were fsqueue specific ...

- make qwalk API work with msgid/evpid instead of pathnames since we're
  going to use the queue_backend API to load envelopes by evpid anyway;

- makes smtpd use *solely* the queue_backend API when manipulating the
  queue. pathnames were removed from smtpd.h and moved into the fsqueue
  which means we can now store a queue anywhere ... as long as we write
  the ten functions or so required for a queue driver ;-)

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.13 2011/10/23 13:03:04 gilles Exp $	*/
d42 2
a43 17
int	fsqueue_init(void);
int	fsqueue_message(enum queue_kind, enum queue_op, u_int32_t *);
int	fsqueue_envelope(enum queue_kind, enum queue_op , struct envelope *);
void   *fsqueue_qwalk_new(enum queue_kind, u_int32_t);
int	fsqueue_qwalk(void *, u_int64_t *);
void	fsqueue_qwalk_close(void *);


struct queue_backend queue_backends[] = {
	{ QT_FS,
	  fsqueue_init,
	  fsqueue_message,
	  fsqueue_envelope,
	  fsqueue_qwalk_new,
	  fsqueue_qwalk,
	  fsqueue_qwalk_close }
};
d48 3
a50 5
	u_int8_t i;

	for (i = 0; i < nitems(queue_backends); ++i)
		if (queue_backends[i].type == type)
			break;
d52 1
a52 1
	if (i == nitems(queue_backends))
d54 1
d56 1
a56 1
	return &queue_backends[i];
@


1.13
log
@introduce Q_CORRUPT and queue_backend operation to move a message from
schedule queue to corrupt queue upon envelope loading failure.

tested by me, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.12 2011/10/23 09:30:07 gilles Exp $	*/
d45 4
d54 4
a57 1
	  fsqueue_envelope }
d120 1
d145 51
@


1.12
log
@fsqueue no longer stores envelopes by dumping the structure, instead use a
couple of load/dump functions to convert to and from a human readable fmt.
while at it kill struct delivery and merge back its fields to the envelope.

this basically means we shouldn't require users to flush their queues every
time we make a change to struct envelope.

work is not done, but we're at a better state than the binary fsqueue so
we'll improve it in-tree.

has been running on my own box for the last 12 hours or so
ok eric@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.11 2011/05/16 21:05:52 gilles Exp $	*/
d90 6
@


1.11
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.10 2011/05/01 12:57:11 eric Exp $	*/
d26 1
d39 2
a45 1

d119 4
a122 2
	ep->delivery.id = evpid;
	return env->sc_queue->envelope(qkind, QOP_LOAD, ep);
d129 27
@


1.10
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.9 2011/04/17 11:39:22 gilles Exp $	*/
d103 1
a103 1
queue_envelope_create(enum queue_kind qkind, struct envelope *m)
d105 1
a105 1
	return env->sc_queue->envelope(qkind, QOP_CREATE, m);
d109 1
a109 1
queue_envelope_delete(enum queue_kind qkind, struct envelope *m)
d111 1
a111 1
	return env->sc_queue->envelope(qkind, QOP_DELETE, m);
d115 1
a115 1
queue_envelope_load(enum queue_kind qkind, u_int64_t evpid, struct envelope *m)
d117 2
a118 2
	m->evpid = evpid;
	return env->sc_queue->envelope(qkind, QOP_LOAD, m);
d122 1
a122 1
queue_envelope_update(enum queue_kind qkind, struct envelope *m)
d124 1
a124 1
	return env->sc_queue->envelope(qkind, QOP_UPDATE, m);
@


1.9
log
@a structure describing an envelope should be called struct envelope, not
struct message ...
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.8 2011/04/15 17:01:05 gilles Exp $	*/
d39 3
a41 5
int	fsqueue_init(struct smtpd *);
int	fsqueue_message(struct smtpd *, enum queue_kind,
    enum queue_op, u_int32_t *);
int	fsqueue_envelope(struct smtpd *, enum queue_kind,
    enum queue_op , struct envelope *);
d67 1
a67 1
queue_message_create(struct smtpd *env, enum queue_kind qkind, u_int32_t *msgid)
d69 1
a69 1
	return env->sc_queue->message(env, qkind, QOP_CREATE, msgid);
d73 1
a73 1
queue_message_delete(struct smtpd *env, enum queue_kind qkind, u_int32_t msgid)
d75 1
a75 1
	return env->sc_queue->message(env, qkind, QOP_DELETE, &msgid);
d79 1
a79 1
queue_message_commit(struct smtpd *env, enum queue_kind qkind, u_int32_t msgid)
d81 1
a81 1
	return env->sc_queue->message(env, qkind, QOP_COMMIT, &msgid);
d85 1
a85 1
queue_message_purge(struct smtpd *env, enum queue_kind qkind, u_int32_t msgid)
d87 1
a87 1
	return env->sc_queue->message(env, qkind, QOP_PURGE, &msgid);
d91 1
a91 1
queue_message_fd_r(struct smtpd *env, enum queue_kind qkind, u_int32_t msgid)
d93 1
a93 1
	return env->sc_queue->message(env, qkind, QOP_FD_R, &msgid);
d97 1
a97 1
queue_message_fd_rw(struct smtpd *env, enum queue_kind qkind, u_int32_t msgid)
d99 1
a99 1
	return env->sc_queue->message(env, qkind, QOP_FD_RW, &msgid);
d103 1
a103 2
queue_envelope_create(struct smtpd *env, enum queue_kind qkind,
    struct envelope *m)
d105 1
a105 1
	return env->sc_queue->envelope(env, qkind, QOP_CREATE, m);
d109 1
a109 2
queue_envelope_delete(struct smtpd *env, enum queue_kind qkind,
    struct envelope *m)
d111 1
a111 1
	return env->sc_queue->envelope(env, qkind, QOP_DELETE, m);
d115 1
a115 2
queue_envelope_load(struct smtpd *env, enum queue_kind qkind,
    u_int64_t evpid, struct envelope *m)
d118 1
a118 1
	return env->sc_queue->envelope(env, qkind, QOP_LOAD, m);
d122 1
a122 2
queue_envelope_update(struct smtpd *env, enum queue_kind qkind,
    struct envelope *m)
d124 1
a124 1
	return env->sc_queue->envelope(env, qkind, QOP_UPDATE, m);
@


1.8
log
@kill message_id and message_uid

smtpd now has an evpid associated to each delivery message, the evpid is an
u_int64_t where the upper 32 bits are the msgid, and the 32 bits are the
envelope unique identifier for that message. this results in lots of space
saved in both disk-based and ram-based queues, but also simplifies a lot of
code.

change has been stressed on my desktop, and has ran on my MX for the entire
afternoon without a regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.7 2011/04/14 23:26:16 gilles Exp $	*/
d43 1
a43 1
    enum queue_op , struct message *);
d106 1
a106 1
    struct message *envelope)
d108 1
a108 1
	return env->sc_queue->envelope(env, qkind, QOP_CREATE, envelope);
d113 1
a113 1
    struct message *envelope)
d115 1
a115 1
	return env->sc_queue->envelope(env, qkind, QOP_DELETE, envelope);
d120 1
a120 1
    u_int64_t evpid, struct message *envelope)
d122 2
a123 2
	envelope->evpid = evpid;
	return env->sc_queue->envelope(env, qkind, QOP_LOAD, envelope);
d128 1
a128 1
    struct message *envelope)
d130 1
a130 1
	return env->sc_queue->envelope(env, qkind, QOP_UPDATE, envelope);
@


1.7
log
@- implement missing operations for fsqueue:
	fsqueue_envelope_create(), fsqueue_message_purge()
- kill deprecated functions in queue_shared.c

At this point fsqueue backend is almost complete, all that is left to do is
to move the qwalk() API inside the queue_backend API, then make sure smtpd
is no longer calling anything queue related directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.6 2011/04/14 20:11:08 gilles Exp $	*/
d41 1
a41 1
    enum queue_op, char *);
d69 1
a69 1
queue_message_create(struct smtpd *env, enum queue_kind qkind, char *msgid)
d75 1
a75 1
queue_message_delete(struct smtpd *env, enum queue_kind qkind, char *msgid)
d77 1
a77 1
	return env->sc_queue->message(env, qkind, QOP_DELETE, msgid);
d81 1
a81 1
queue_message_commit(struct smtpd *env, enum queue_kind qkind, char *msgid)
d83 1
a83 1
	return env->sc_queue->message(env, qkind, QOP_COMMIT, msgid);
d87 1
a87 1
queue_message_purge(struct smtpd *env, enum queue_kind qkind, char *msgid)
d89 1
a89 1
	return env->sc_queue->message(env, qkind, QOP_PURGE, msgid);
d93 1
a93 1
queue_message_fd_r(struct smtpd *env, enum queue_kind qkind, char *msgid)
d95 1
a95 1
	return env->sc_queue->message(env, qkind, QOP_FD_R, msgid);
d99 1
a99 1
queue_message_fd_rw(struct smtpd *env, enum queue_kind qkind, char *msgid)
d101 1
a101 1
	return env->sc_queue->message(env, qkind, QOP_FD_RW, msgid);
d120 1
a120 1
    char *evpid, struct message *envelope)
d122 1
a122 3
	if (strlcpy(envelope->message_uid, evpid, sizeof(envelope->message_uid))
	    >= sizeof(envelope->message_uid))
		fatalx("queue_envelope_load: envelope ID truncation.");
@


1.6
log
@fsqueue queue backend will implement a filesystem queue:
- fsqueue->setup() performs the queue initialization;
- fsqueue->message() controls messages;
- fsqueue->envelope() controls envelopes;

This commit brings the following to fsbackend:
fsqueue_setup(), fsqueue_message_delete(), fsqueue_envelope_load(),
fsqueue_envelope_update(), fsqueue_envelope_delete().

It also makes smtpd use the queue_backend API for these operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.5 2011/04/14 17:06:43 gilles Exp $	*/
d84 6
@


1.5
log
@smtpd makes too many assumptions about the structure and layout of its
disk-based queue, it makes it near impossible to make changes to it without
editing twenty files... how am i going to implement mongodb support ? :-)

bring a new queue_backend API which hides the details of the disk-based
queue to smtpd. it is not "plugged in" yet and I'm filling the holes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 3
a40 1
int	queue_fsqueue_message(struct smtpd *, enum queue_kind,
d42 1
a42 1
int	queue_fsqueue_envelope(struct smtpd *, enum queue_kind,
d45 1
d48 3
a50 2
	  queue_fsqueue_message,
	  queue_fsqueue_envelope }
@


1.4
log
@no longer compiled, i will reintroduce them later, lots of stuff needs to
be done before we can write queue backends anyway ...
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.3 2010/06/01 23:06:23 jacekm Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Jacek Masiulaniec <jacekm@@dobremiasto.net>
d20 4
d26 2
a27 4
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <fts.h>
d29 1
a29 1
#include <limits.h>
d35 2
a36 1
#include "queue_backend.h"
d38 10
a47 1
static char path[PATH_MAX];
d49 2
a50 4
static char *idchars = "ABCDEFGHIJKLMNOPQRSTUVWYZabcdefghijklmnopqrstuvwxyz0123456789";

int
queue_be_content_create(u_int64_t *content_id)
d52 1
a52 1
	int c, fd;
d54 3
a56 16
	c = idchars[arc4random_uniform(61)];
	snprintf(path, sizeof path, "content/%c/%cXXXXXXX", c, c);
	fd = mkstemp(path);
	if (fd < 0) {
		if (errno != ENOENT)
			return -1;
		if (mkdir(dirname(path), 0700) < 0)
			return -1;
		fd = mkstemp(path);
		if (fd < 0)
			return -1;
	}
	close(fd);
	*content_id = queue_be_encode(path + 10);
	return 0;
}
d58 2
a59 4
int
queue_be_content_open(u_int64_t content_id, int wr)
{
	char *id;
d61 1
a61 3
	id = queue_be_decode(content_id);
	snprintf(path, sizeof path, "content/%c/%s", id[0], id);
	return open(path, wr ? O_RDWR|O_APPEND|O_EXLOCK : O_RDONLY|O_SHLOCK);
d64 2
a65 2
void
queue_be_content_delete(u_int64_t content_id)
d67 1
a67 5
	char *id;

	id = queue_be_decode(content_id);
	snprintf(path, sizeof path, "content/%c/%s", id[0], id);
	unlink(path);
d71 1
a71 1
queue_be_action_new(u_int64_t content_id, u_int64_t *action_id, char *aux)
d73 1
a73 28
	FILE *fp;
	char *id;
	int fd;

	id = queue_be_decode(content_id);
	snprintf(path, sizeof path, "action/%c/%s,XXXXXXXX", id[0], id);
	fd = mkstemp(path);
	if (fd < 0) {
		if (errno != ENOENT)
			return -1;
		if (mkdir(dirname(path), 0700) < 0)
			return -1;
		fd = mkstemp(path);
		if (fd < 0)
			return -1;
	}
	fp = fdopen(fd, "w+");
	if (fp == NULL) {
		unlink(path);
		return -1;
	}
	fprintf(fp, "%s\n", aux);
	if (fclose(fp) == EOF) {
		unlink(path);
		return -1;
	}
	*action_id = queue_be_encode(path + 18);
	return 0;
d77 1
a77 1
queue_be_action_read(struct action_be *a, u_int64_t content_id, u_int64_t action_id)
d79 1
a79 66
	static char status[2048];
	static char aux[2048];
	struct stat sb_status, sb_content;
	char *id;
	FILE *fp;

	bzero(a, sizeof *a);
	a->content_id = content_id;
	a->action_id = action_id;

	/*
	 * Auxillary params for mta and mda.
	 */
	id = queue_be_decode(content_id);
	snprintf(path, sizeof path, "action/%c/%s,", id[0], id);
	strlcat(path, queue_be_decode(action_id), sizeof path);
	fp = fopen(path, "r");
	if (fp == NULL)
		return -1;
	if (fgets(aux, sizeof aux, fp) == NULL) {
		fclose(fp);
		return -1;
	}
	fclose(fp);
	aux[strcspn(aux, "\n")] = '\0';
	a->aux = aux;

	/*
	 * Error status message.
	 */
	id = queue_be_decode(content_id);
	snprintf(path, sizeof path, "status/%c/%s,", id[0], id);
	strlcat(path, queue_be_decode(action_id), sizeof path);
	fp = fopen(path, "r");
	if (fp) {
		if (fgets(status, sizeof status, fp) != NULL)
			status[strcspn(status, "\n")] = '\0';
		else
			status[0] = '\0';
		if (fstat(fileno(fp), &sb_status) < 0) {
			fclose(fp);
			return -1;
		}
		fclose(fp);
	} else
		status[0] = '\0';
	a->status = status;

	/*
	 * Message birth time.
	 *
	 * For bounces, use mtime of the status file.
	 * For non-bounces, use mtime of the content file.
	 */
	id = queue_be_decode(content_id);
	snprintf(path, sizeof path, "content/%c/%s", id[0], id);
	if (stat(path, &sb_content) < 0)
		return -1;
	if (sb_content.st_mode & S_IWUSR)
		a->birth = 0;
	else if (status[0] == '5' || status[0] == '6')
		a->birth = sb_status.st_mtime;
	else
		a->birth = sb_content.st_mtime;

	return 0;
d83 1
a83 1
queue_be_action_status(u_int64_t content_id, u_int64_t action_id, char *status)
d85 1
a85 22
	FILE *fp;
	char *id;

	id = queue_be_decode(content_id);
	snprintf(path, sizeof path, "status/%c/%s,", id[0], id);
	strlcat(path, queue_be_decode(action_id), sizeof path);
	fp = fopen(path, "w+");
	if (fp == NULL) {
		if (errno != ENOENT)
			return -1;
		mkdir(dirname(path), 0700);
		fp = fopen(path, "w+");
		if (fp == NULL)
			return -1;
	}
	if (fprintf(fp, "%s\n", status) == -1) {
		fclose(fp);
		return -1;
	}
	if (fclose(fp) == EOF)
		return -1;
	return 0;
d88 2
a89 2
void
queue_be_action_delete(u_int64_t content_id, u_int64_t action_id)
d91 1
a91 10
	char *id, *dir[] = { "action", "status" };
	u_int i;

	for (i = 0; i < 2; i++) {
		id = queue_be_decode(content_id);
		snprintf(path, sizeof path, "%s/%c/%s,", dir[i], id[0], id);
		id = queue_be_decode(action_id);
		strlcat(path, id, sizeof path);
		unlink(path);
	}
d95 2
a96 1
queue_be_commit(u_int64_t content_id)
d98 1
a98 7
	char *id;

	id = queue_be_decode(content_id);
	snprintf(path, sizeof path, "content/%c/%s", id[0], id);
	if (utimes(path, NULL) < 0 || chmod(path, 0400) < 0)
		return -1;
	return 0;
d102 2
a103 1
queue_be_getnext(struct action_be *a)
d105 1
a105 47
	static FTS	*fts;
	static FTSENT	*fe;
	char		*dir[] = { "action", NULL };

	if (fts == NULL) {
		fts = fts_open(dir, FTS_PHYSICAL|FTS_NOCHDIR, NULL);
		if (fts == NULL)
			return -1;
	}

	for (;;) {
		fe = fts_read(fts);
		if (fe == NULL) {
			if (errno) {
				fts_close(fts);
				return -1;
			} else {
				if (fts_close(fts) < 0)
					return -1;
				a->content_id = 0;
				a->action_id = 0;
				return 0;
			}
		}
		switch (fe->fts_info) {
		case FTS_F:
			break;
		case FTS_D:
		case FTS_DP:
			continue;
		default:
			fts_close(fts);
			return -1;
		}
		break;
	}

	if (fe->fts_namelen != 17 || fe->fts_name[8] != ',') {
		fts_close(fts);
		return -1;
	}
	a->content_id = queue_be_encode(fe->fts_name);
	a->action_id = queue_be_encode(fe->fts_name + 9);
	if (queue_be_action_read(a, a->content_id, a->action_id) < 0)
		return -2;

	return 0;
d108 3
a110 2
char *
queue_be_decode(u_int64_t id)
d112 4
a115 18
        static char txt[9];

	memcpy(txt, &id, sizeof id);
	txt[8] = '\0';
	return txt;
}

u_int64_t
queue_be_encode(const char *txt)
{
        u_int64_t id;

	if (strlen(txt) < sizeof id)
		id = INVALID_ID;
	else
		memcpy(&id, txt, sizeof id);

        return id;
d119 2
a120 1
queue_be_init(char *prefix, uid_t uid, gid_t gid)
d122 1
a122 13
	char *dir[] = { "action", "content", "status" };
	int i;

	for (i = 0; i < 3; i++) {
		snprintf(path, sizeof path, "%s/%s", prefix, dir[i]);
		if (mkdir(path, 0700) < 0 && errno != EEXIST)
			return -1;
		if (chmod(path, 0700) < 0)
			return -1;
		if (chown(path, uid, gid) < 0)
			return -1;
	}
	return 0;
@


1.3
log
@new queue, again; gcc2 compile tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: queue_backend.c,v 1.1 2010/05/31 23:38:56 jacekm Exp $	*/
@


1.2
log
@New queue doesn't compile on gcc2, back out.  Spotted by deraadt@@
@
text
@@


1.1
log
@Rewrite entire queue code.

Major goals:

1) Fix bad performance caused by the runner process doing full queue
read in 1s intervals.  My Soekris can now happily accept >50 msg/s
while having multi-thousand queue; before, one hundred queue would
bring the system to its knees.

2) Introduce Qmail-like scheduler that doesn't write as much to the
disk so that it needs less code for servicing error conditions,
which in some places can be tricky to get right.

3) Introduce separation between the scheduler and the backend; these
two queue aspects shouldn't be too tied too each other.  This means
that eg. storing queue in SQL requires rewrite of just queue_backend.c.

4) Make on-disk queue format architecture independent, and more
easily extensible, to reduce number of flag days in the future.

Minor goals:

ENOSPC no longer prevents delivery attempts, fixed session limiting
for relayed mail, improved batching of "relay via" mails, human-readable
mailq output, "show queue raw" command, clearer logging, sending
of single bounce about multiple recipients, exact delay= computation,
zero delay between deliveries while within session limit (currently
1s delay between re-scheduling is enforced), mta no longer requests
content fd, corrected session limit for bounce submissions, tiny
<100B queue files instead of multi-KB, detect loops before accepting
mail, reduce traffic on imsg channels by killing enormous struct
submit_status.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

