head	1.56;
access;
symbols
	OPENBSD_6_0:1.52.0.4
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.48.0.6
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.42.0.2
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@ * @;


1.56
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.55;
commitid	eA8b246voAapPTkX;

1.55
date	2016.09.08.12.06.43;	author eric;	state Exp;
branches;
next	1.54;
commitid	LkfnyKFoItZAAepX;

1.54
date	2016.09.04.16.10.31;	author eric;	state Exp;
branches;
next	1.53;
commitid	I2r1xe6emhZl6xPg;

1.53
date	2016.09.01.10.54.25;	author eric;	state Exp;
branches;
next	1.52;
commitid	fYsbH2IujjKSME9c;

1.52
date	2016.05.28.21.21.20;	author eric;	state Exp;
branches;
next	1.51;
commitid	KhU4hSodVCiVoZ62;

1.51
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.50;
commitid	ZxnqOQqX6IeYI9jW;

1.50
date	2015.10.29.10.25.36;	author sunil;	state Exp;
branches;
next	1.49;
commitid	TXZugvtal96cI6ec;

1.49
date	2015.10.13.08.09.25;	author gilles;	state Exp;
branches;
next	1.48;
commitid	XbY40Byw0w3pBvxR;

1.48
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	ZBTFreARDSMmzOIV;

1.47
date	2014.07.10.14.45.02;	author eric;	state Exp;
branches;
next	1.46;
commitid	dolePHRcgnf1dDVL;

1.46
date	2014.07.08.07.59.31;	author sobrado;	state Exp;
branches;
next	1.45;
commitid	QejPnWBk7nSpcYUN;

1.45
date	2014.05.20.18.47.01;	author eric;	state Exp;
branches;
next	1.44;

1.44
date	2014.04.08.15.25.43;	author eric;	state Exp;
branches;
next	1.43;

1.43
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.42;

1.42
date	2014.02.04.14.56.03;	author eric;	state Exp;
branches;
next	1.41;

1.41
date	2014.02.04.09.05.06;	author eric;	state Exp;
branches;
next	1.40;

1.40
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.39;

1.39
date	2013.12.05.09.26.47;	author eric;	state Exp;
branches;
next	1.38;

1.38
date	2013.11.30.10.11.57;	author eric;	state Exp;
branches;
next	1.37;

1.37
date	2013.11.20.09.22.42;	author eric;	state Exp;
branches;
next	1.36;

1.36
date	2013.11.19.10.01.20;	author eric;	state Exp;
branches;
next	1.35;

1.35
date	2013.10.27.17.47.53;	author eric;	state Exp;
branches;
next	1.34;

1.34
date	2013.10.27.07.56.25;	author eric;	state Exp;
branches;
next	1.33;

1.33
date	2013.10.25.18.58.10;	author eric;	state Exp;
branches;
next	1.32;

1.32
date	2013.07.19.21.14.52;	author eric;	state Exp;
branches;
next	1.31;

1.31
date	2013.07.19.15.14.23;	author eric;	state Exp;
branches;
next	1.30;

1.30
date	2013.07.19.11.14.08;	author eric;	state Exp;
branches;
next	1.29;

1.29
date	2013.07.19.07.49.08;	author eric;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.27;

1.27
date	2013.02.10.15.01.16;	author eric;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2012.11.20.09.47.45;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2012.11.02.14.46.43;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2012.09.16.16.43.29;	author chl;	state Exp;
branches;
next	1.20;

1.20
date	2012.09.11.08.37.52;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2012.08.25.22.03.26;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2012.08.25.10.23.12;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2012.08.24.18.46.46;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2012.08.24.18.21.06;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2012.08.21.13.13.17;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2012.08.20.09.34.53;	author chl;	state Exp;
branches;
next	1.13;

1.13
date	2012.08.19.15.06.36;	author chl;	state Exp;
branches;
next	1.12;

1.12
date	2012.08.18.18.18.23;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2012.08.09.19.16.26;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2012.08.09.12.19.33;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.09.09.48.02;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.08.08.50.42;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2012.07.18.22.04.49;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.07.10.11.13.40;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.09.17.57.54;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.09.09.57.53;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2012.07.02.17.00.05;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.06.17.15.17.08;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2012.01.28.11.33.07;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@/*	$OpenBSD: scheduler.c,v 1.55 2016/09/08 12:06:43 eric Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2008-2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <inttypes.h>
#include <libgen.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

#include "smtpd.h"
#include "log.h"

static void scheduler_imsg(struct mproc *, struct imsg *);
static void scheduler_shutdown(void);
static void scheduler_reset_events(void);
static void scheduler_timeout(int, short, void *);

static struct scheduler_backend *backend = NULL;
static struct event		 ev;
static size_t			 ninflight = 0;
static int			*types;
static uint64_t			*evpids;
static uint32_t			*msgids;
static struct evpstate		*state;

extern const char *backend_scheduler;

void
scheduler_imsg(struct mproc *p, struct imsg *imsg)
{
	struct bounce_req_msg	 req;
	struct envelope		 evp;
	struct scheduler_info	 si;
	struct msg		 m;
	uint64_t		 evpid, id, holdq;
	uint32_t		 msgid;
	uint32_t       		 inflight;
	size_t			 n, i;
	time_t			 timestamp;
	int			 v, r, type;

	if (imsg == NULL)
		scheduler_shutdown();

	switch (imsg->hdr.type) {

	case IMSG_QUEUE_ENVELOPE_SUBMIT:
		m_msg(&m, imsg);
		m_get_envelope(&m, &evp);
		m_end(&m);
		log_trace(TRACE_SCHEDULER,
		    "scheduler: inserting evp:%016" PRIx64, evp.id);
		scheduler_info(&si, &evp);
		stat_increment("scheduler.envelope.incoming", 1);
		backend->insert(&si);
		return;

	case IMSG_QUEUE_MESSAGE_COMMIT:
		m_msg(&m, imsg);
		m_get_msgid(&m, &msgid);
		m_end(&m);
		log_trace(TRACE_SCHEDULER,
		    "scheduler: committing msg:%08" PRIx32, msgid);
		n = backend->commit(msgid);
		stat_decrement("scheduler.envelope.incoming", n);
		stat_increment("scheduler.envelope", n);
		scheduler_reset_events();
		return;

	case IMSG_QUEUE_DISCOVER_EVPID:
		m_msg(&m, imsg);
		m_get_envelope(&m, &evp);
		m_end(&m);
		r = backend->query(evp.id);
		if (r) {
			log_debug("debug: scheduler: evp:%016" PRIx64
			    " already scheduled", evp.id);
			return;
		}
		log_trace(TRACE_SCHEDULER,
		    "scheduler: discovering evp:%016" PRIx64, evp.id);
		scheduler_info(&si, &evp);
		stat_increment("scheduler.envelope.incoming", 1);
		backend->insert(&si);
		return;

	case IMSG_QUEUE_DISCOVER_MSGID:
		m_msg(&m, imsg);
		m_get_msgid(&m, &msgid);
		m_end(&m);
		r = backend->query(msgid);
		if (r) {
			log_debug("debug: scheduler: msgid:%08" PRIx32
			    " already scheduled", msgid);
			return;
		}
		log_trace(TRACE_SCHEDULER,
		    "scheduler: committing msg:%08" PRIx32, msgid);
		n = backend->commit(msgid);
		stat_decrement("scheduler.envelope.incoming", n);
		stat_increment("scheduler.envelope", n);
		scheduler_reset_events();
		return;

	case IMSG_QUEUE_MESSAGE_ROLLBACK:
		m_msg(&m, imsg);
		m_get_msgid(&m, &msgid);
		m_end(&m);
		log_trace(TRACE_SCHEDULER, "scheduler: aborting msg:%08" PRIx32,
		    msgid);
		n = backend->rollback(msgid);
		stat_decrement("scheduler.envelope.incoming", n);
		scheduler_reset_events();
		return;

	case IMSG_QUEUE_ENVELOPE_REMOVE:
		m_msg(&m, imsg);
		m_get_evpid(&m, &evpid);
		m_get_u32(&m, &inflight);
		m_end(&m);
		log_trace(TRACE_SCHEDULER,
		    "scheduler: queue requested removal of evp:%016" PRIx64,
		    evpid);
		stat_decrement("scheduler.envelope", 1);
		if (!inflight)
			backend->remove(evpid);
		else {
			backend->delete(evpid);
			ninflight -= 1;
			stat_decrement("scheduler.envelope.inflight", 1);
		}

		scheduler_reset_events();
		return;

	case IMSG_QUEUE_ENVELOPE_ACK:
		m_msg(&m, imsg);
		m_get_evpid(&m, &evpid);
		m_end(&m);
		log_trace(TRACE_SCHEDULER,
		    "scheduler: queue ack removal of evp:%016" PRIx64,
		    evpid);
		ninflight -= 1;
		stat_decrement("scheduler.envelope.inflight", 1);
		scheduler_reset_events();
		return;

	case IMSG_QUEUE_DELIVERY_OK:
		m_msg(&m, imsg);
		m_get_evpid(&m, &evpid);
		m_end(&m);
		log_trace(TRACE_SCHEDULER,
		    "scheduler: deleting evp:%016" PRIx64 " (ok)", evpid);
		backend->delete(evpid);
		ninflight -= 1;
		stat_increment("scheduler.delivery.ok", 1);
		stat_decrement("scheduler.envelope.inflight", 1);
		stat_decrement("scheduler.envelope", 1);
		scheduler_reset_events();
		return;

	case IMSG_QUEUE_DELIVERY_TEMPFAIL:
		m_msg(&m, imsg);
		m_get_envelope(&m, &evp);
		m_end(&m);
		log_trace(TRACE_SCHEDULER,
		    "scheduler: updating evp:%016" PRIx64, evp.id);
		scheduler_info(&si, &evp);
		backend->update(&si);
		ninflight -= 1;
		stat_increment("scheduler.delivery.tempfail", 1);
		stat_decrement("scheduler.envelope.inflight", 1);

		for (i = 0; i < MAX_BOUNCE_WARN; i++) {
			if (env->sc_bounce_warn[i] == 0)
				break;
			timestamp = si.creation + env->sc_bounce_warn[i];
			if (si.nexttry >= timestamp &&
			    si.lastbounce < timestamp) {
	    			req.evpid = evp.id;
				req.timestamp = timestamp;
				req.bounce.type = B_WARNING;
				req.bounce.delay = env->sc_bounce_warn[i];
				req.bounce.expire = si.expire;
				m_compose(p, IMSG_SCHED_ENVELOPE_BOUNCE, 0, 0, -1,
				    &req, sizeof req);
				break;
			}
		}
		scheduler_reset_events();
		return;

	case IMSG_QUEUE_DELIVERY_PERMFAIL:
		m_msg(&m, imsg);
		m_get_evpid(&m, &evpid);
		m_end(&m);
		log_trace(TRACE_SCHEDULER,
		    "scheduler: deleting evp:%016" PRIx64 " (fail)", evpid);
		backend->delete(evpid);
		ninflight -= 1;
		stat_increment("scheduler.delivery.permfail", 1);
		stat_decrement("scheduler.envelope.inflight", 1);
		stat_decrement("scheduler.envelope", 1);
		scheduler_reset_events();
		return;

	case IMSG_QUEUE_DELIVERY_LOOP:
		m_msg(&m, imsg);
		m_get_evpid(&m, &evpid);
		m_end(&m);
		log_trace(TRACE_SCHEDULER,
		    "scheduler: deleting evp:%016" PRIx64 " (loop)", evpid);
		backend->delete(evpid);
		ninflight -= 1;
		stat_increment("scheduler.delivery.loop", 1);
		stat_decrement("scheduler.envelope.inflight", 1);
		stat_decrement("scheduler.envelope", 1);
		scheduler_reset_events();
		return;

	case IMSG_QUEUE_HOLDQ_HOLD:
		m_msg(&m, imsg);
		m_get_evpid(&m, &evpid);
		m_get_id(&m, &holdq);
		m_end(&m);
		log_trace(TRACE_SCHEDULER,
		    "scheduler: holding evp:%016" PRIx64 " on %016" PRIx64,
		    evpid, holdq);
		backend->hold(evpid, holdq);
		ninflight -= 1;
		stat_decrement("scheduler.envelope.inflight", 1);
		scheduler_reset_events();
		return;

	case IMSG_QUEUE_HOLDQ_RELEASE:
		m_msg(&m, imsg);
		m_get_int(&m, &type);
		m_get_id(&m, &holdq);
		m_get_int(&m, &r);
		m_end(&m);
		log_trace(TRACE_SCHEDULER,
		    "scheduler: releasing %d on holdq (%d, %016" PRIx64 ")",
		    r, type, holdq);
		backend->release(type, holdq, r);
		scheduler_reset_events();
		return;

	case IMSG_CTL_PAUSE_MDA:
		log_trace(TRACE_SCHEDULER, "scheduler: pausing mda");
		env->sc_flags |= SMTPD_MDA_PAUSED;
		return;

	case IMSG_CTL_RESUME_MDA:
		log_trace(TRACE_SCHEDULER, "scheduler: resuming mda");
		env->sc_flags &= ~SMTPD_MDA_PAUSED;
		scheduler_reset_events();
		return;

	case IMSG_CTL_PAUSE_MTA:
		log_trace(TRACE_SCHEDULER, "scheduler: pausing mta");
		env->sc_flags |= SMTPD_MTA_PAUSED;
		return;

	case IMSG_CTL_RESUME_MTA:
		log_trace(TRACE_SCHEDULER, "scheduler: resuming mta");
		env->sc_flags &= ~SMTPD_MTA_PAUSED;
		scheduler_reset_events();
		return;

	case IMSG_CTL_VERBOSE:
		m_msg(&m, imsg);
		m_get_int(&m, &v);
		m_end(&m);
		log_setverbose(v);
		return;

	case IMSG_CTL_PROFILE:
		m_msg(&m, imsg);
		m_get_int(&m, &v);
		m_end(&m);
		profiling = v;
		return;

	case IMSG_CTL_LIST_MESSAGES:
		msgid = *(uint32_t *)(imsg->data);
		n = backend->messages(msgid, msgids, env->sc_scheduler_max_msg_batch_size);
		m_compose(p, IMSG_CTL_LIST_MESSAGES, imsg->hdr.peerid, 0, -1,
		    msgids, n * sizeof (*msgids));
		return;

	case IMSG_CTL_LIST_ENVELOPES:
		id = *(uint64_t *)(imsg->data);
		n = backend->envelopes(id, state, env->sc_scheduler_max_evp_batch_size);
		for (i = 0; i < n; i++) {
			m_create(p_queue, IMSG_CTL_LIST_ENVELOPES,
			    imsg->hdr.peerid, 0, -1);
			m_add_evpid(p_queue, state[i].evpid);
			m_add_int(p_queue, state[i].flags);
			m_add_time(p_queue, state[i].time);
			m_close(p_queue);
		}
		m_compose(p_queue, IMSG_CTL_LIST_ENVELOPES,
		    imsg->hdr.peerid, 0, -1, NULL, 0);
		return;

	case IMSG_CTL_SCHEDULE:
		id = *(uint64_t *)(imsg->data);
		if (id <= 0xffffffffL)
			log_debug("debug: scheduler: "
			    "scheduling msg:%08" PRIx64, id);
		else
			log_debug("debug: scheduler: "
			    "scheduling evp:%016" PRIx64, id);
		r = backend->schedule(id);
		scheduler_reset_events();
		m_compose(p, r ? IMSG_CTL_OK : IMSG_CTL_FAIL, imsg->hdr.peerid,
		    0, -1, NULL, 0);
		return;

	case IMSG_QUEUE_ENVELOPE_SCHEDULE:
		id = *(uint64_t *)(imsg->data);
		backend->schedule(id);
		scheduler_reset_events();
		return;

	case IMSG_CTL_REMOVE:
		id = *(uint64_t *)(imsg->data);
		if (id <= 0xffffffffL)
			log_debug("debug: scheduler: "
			    "removing msg:%08" PRIx64, id);
		else
			log_debug("debug: scheduler: "
			    "removing evp:%016" PRIx64, id);
		r = backend->remove(id);
		scheduler_reset_events();
		m_compose(p, r ? IMSG_CTL_OK : IMSG_CTL_FAIL, imsg->hdr.peerid,
		    0, -1, NULL, 0);
		return;

	case IMSG_CTL_PAUSE_EVP:
		id = *(uint64_t *)(imsg->data);
		if (id <= 0xffffffffL)
			log_debug("debug: scheduler: "
			    "suspending msg:%08" PRIx64, id);
		else
			log_debug("debug: scheduler: "
			    "suspending evp:%016" PRIx64, id);
		r = backend->suspend(id);
		scheduler_reset_events();
		m_compose(p, r ? IMSG_CTL_OK : IMSG_CTL_FAIL, imsg->hdr.peerid,
		    0, -1, NULL, 0);
		return;

	case IMSG_CTL_RESUME_EVP:
		id = *(uint64_t *)(imsg->data);
		if (id <= 0xffffffffL)
			log_debug("debug: scheduler: "
			    "resuming msg:%08" PRIx64, id);
		else
			log_debug("debug: scheduler: "
			    "resuming evp:%016" PRIx64, id);
		r = backend->resume(id);
		scheduler_reset_events();
		m_compose(p, r ? IMSG_CTL_OK : IMSG_CTL_FAIL, imsg->hdr.peerid,
		    0, -1, NULL, 0);
		return;
	}

	errx(1, "scheduler_imsg: unexpected %s imsg",
	    imsg_to_str(imsg->hdr.type));
}

static void
scheduler_shutdown(void)
{
	log_debug("debug: scheduler agent exiting");
	_exit(0);
}

static void
scheduler_reset_events(void)
{
	struct timeval	 tv;

	evtimer_del(&ev);
	tv.tv_sec = 0;
	tv.tv_usec = 0;
	evtimer_add(&ev, &tv);
}

int
scheduler(void)
{
	struct passwd	*pw;

	backend = scheduler_backend_lookup(backend_scheduler);
	if (backend == NULL)
		errx(1, "cannot find scheduler backend \"%s\"",
		    backend_scheduler);

	purge_config(PURGE_EVERYTHING);

	if ((pw = getpwnam(SMTPD_USER)) == NULL)
		fatalx("unknown user " SMTPD_USER);

	config_process(PROC_SCHEDULER);

	backend->init(backend_scheduler);

	if (chroot(PATH_CHROOT) == -1)
		fatal("scheduler: chroot");
	if (chdir("/") == -1)
		fatal("scheduler: chdir(\"/\")");

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("scheduler: cannot drop privileges");

	evpids = xcalloc(env->sc_scheduler_max_schedule, sizeof *evpids, "scheduler: init evpids");
	types = xcalloc(env->sc_scheduler_max_schedule, sizeof *types, "scheduler: init types");
	msgids = xcalloc(env->sc_scheduler_max_msg_batch_size, sizeof *msgids, "scheduler: list msg");
	state = xcalloc(env->sc_scheduler_max_evp_batch_size, sizeof *state, "scheduler: list evp");

	imsg_callback = scheduler_imsg;
	event_init();

	signal(SIGINT, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	config_peer(PROC_CONTROL);
	config_peer(PROC_QUEUE);

	evtimer_set(&ev, scheduler_timeout, NULL);
	scheduler_reset_events();

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	event_dispatch();
	fatalx("exited event loop");

	return (0);
}

static void
scheduler_timeout(int fd, short event, void *p)
{
	struct timeval		tv;
	size_t			i;
	size_t			d_inflight;
	size_t			d_envelope;
	size_t			d_removed;
	size_t			d_expired;
	size_t			d_updated;
	size_t			count;
	int			mask, r, delay;

	tv.tv_sec = 0;
	tv.tv_usec = 0;

	mask = SCHED_UPDATE;

	if (ninflight <  env->sc_scheduler_max_inflight) {
		mask |= SCHED_EXPIRE | SCHED_REMOVE | SCHED_BOUNCE;
		if (!(env->sc_flags & SMTPD_MDA_PAUSED))
			mask |= SCHED_MDA;
		if (!(env->sc_flags & SMTPD_MTA_PAUSED))
			mask |= SCHED_MTA;
	}

	count = env->sc_scheduler_max_schedule;

	log_trace(TRACE_SCHEDULER, "scheduler: getting batch: mask=0x%x, count=%zu", mask, count);

	r = backend->batch(mask, &delay, &count, evpids, types);

	log_trace(TRACE_SCHEDULER, "scheduler: got r=%i, delay=%i, count=%zu", r, delay, count);

	if (r < 0)
		fatalx("scheduler: error in batch handler");

	if (r == 0) {

		if (delay < -1)
			fatalx("scheduler: invalid delay %d", delay);

		if (delay == -1) {
			log_trace(TRACE_SCHEDULER, "scheduler: sleeping");
			return;
		}

		tv.tv_sec = delay;
		tv.tv_usec = 0;
		log_trace(TRACE_SCHEDULER,
		    "scheduler: waiting for %s", duration_to_text(tv.tv_sec));
		evtimer_add(&ev, &tv);
		return;
	}

	d_inflight = 0;
	d_envelope = 0;
	d_removed = 0;
	d_expired = 0;
	d_updated = 0;

	for (i = 0; i < count; i++) {
		switch(types[i]) {
		case SCHED_REMOVE:
			log_debug("debug: scheduler: evp:%016" PRIx64
			    " removed", evpids[i]);
			m_create(p_queue, IMSG_SCHED_ENVELOPE_REMOVE, 0, 0, -1);
			m_add_evpid(p_queue, evpids[i]);
			m_close(p_queue);
			d_envelope += 1;
			d_removed += 1;
			d_inflight += 1;
			break;

		case SCHED_EXPIRE:
			log_debug("debug: scheduler: evp:%016" PRIx64
			    " expired", evpids[i]);
			m_create(p_queue, IMSG_SCHED_ENVELOPE_EXPIRE, 0, 0, -1);
			m_add_evpid(p_queue, evpids[i]);
			m_close(p_queue);
			d_envelope += 1;
			d_expired += 1;
			d_inflight += 1;
			break;

		case SCHED_UPDATE:
			log_debug("debug: scheduler: evp:%016" PRIx64
			    " scheduled (update)", evpids[i]);
			d_updated += 1;
			break;

		case SCHED_BOUNCE:
			log_debug("debug: scheduler: evp:%016" PRIx64
			    " scheduled (bounce)", evpids[i]);
			m_create(p_queue, IMSG_SCHED_ENVELOPE_INJECT, 0, 0, -1);
			m_add_evpid(p_queue, evpids[i]);
			m_close(p_queue);
			d_inflight += 1;
			break;

		case SCHED_MDA:
			log_debug("debug: scheduler: evp:%016" PRIx64
			    " scheduled (mda)", evpids[i]);
			m_create(p_queue, IMSG_SCHED_ENVELOPE_DELIVER, 0, 0, -1);
			m_add_evpid(p_queue, evpids[i]);
			m_close(p_queue);
			d_inflight += 1;
			break;

		case SCHED_MTA:
			log_debug("debug: scheduler: evp:%016" PRIx64
			    " scheduled (mta)", evpids[i]);
			m_create(p_queue, IMSG_SCHED_ENVELOPE_TRANSFER, 0, 0, -1);
			m_add_evpid(p_queue, evpids[i]);
			m_close(p_queue);
			d_inflight += 1;
			break;
		}
	}

	stat_decrement("scheduler.envelope", d_envelope);
	stat_increment("scheduler.envelope.inflight", d_inflight);
	stat_increment("scheduler.envelope.expired", d_expired);
	stat_increment("scheduler.envelope.removed", d_removed);
	stat_increment("scheduler.envelope.updated", d_updated);

	ninflight += d_inflight;

	tv.tv_sec = 0;
	tv.tv_usec = 0;
	evtimer_add(&ev, &tv);
}
@


1.55
log
@Streamline the daemon shutdown sequence.

Only the parent process handles SIGTERM and SIGINT.  Upon receiving one
of those, it closes all imsg sockets and waitpid() for the children. It
fatal()s if one of the sockets is closed unexpectedly.  Other processes
exit() "normally" when one of the imsg sockets is closed.

ok gilles@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.54 2016/09/04 16:10:31 eric Exp $	*/
d309 1
a309 1
		log_verbose(v);
@


1.54
log
@The smtpd processes are not expected to ever leave their event loop.
So stop pretending that the *_shutdown() functions could ever be called
in this context, and just fatal() if event_dispatch() returns.

ok gilles@@ sunil@@ giovanni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.53 2016/09/01 10:54:25 eric Exp $	*/
a49 1
static void scheduler_sig_handler(int, short, void *);
d77 3
a408 13
scheduler_sig_handler(int sig, short event, void *p)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		scheduler_shutdown();
		break;
	default:
		fatalx("scheduler_sig_handler: unexpected signal");
	}
}

static void
d411 1
a411 1
	log_info("info: scheduler handler exiting");
a429 2
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
d463 2
a464 4
	signal_set(&ev_sigint, SIGINT, scheduler_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, scheduler_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
@


1.53
log
@remove noop function

ok sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.52 2016/05/28 21:21:20 eric Exp $	*/
d492 2
a493 3
	if (event_dispatch() < 0)
		fatal("event_dispatch");
	scheduler_shutdown();
@


1.52
log
@Implement the fork+exec pattern in smtpd.

The parent process forks child processes and re-exec each of them with
an additional "-x <proc>" argument.  During the early setup phase, the
parent process sends ipc socket pairs to interconnect the child
processes as needed, and it passes the queue encryption key to the
queue if necessary. When this is done, all processes have their
environment set as in the fork-only case, and they can start doing
their work as before.

ok gilles@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.51 2015/12/28 22:08:30 jung Exp $	*/
a484 1
	config_done();
@


1.51
log
@remove spaces after '!'

no binary change

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.50 2015/10/29 10:25:36 sunil Exp $	*/
d437 1
a437 1
pid_t
a439 1
	pid_t		 pid;
a447 10

	switch (pid = fork()) {
	case -1:
		fatal("scheduler: cannot fork");
	case 0:
		post_fork(PROC_SCHEDULER);
		break;
	default:
		return (pid);
	}
@


1.50
log
@Implement smtpctl discover <evpid|msgid>.

discover subcommand schedules envelopes manually moved to the queue.
It triggers a queue walk searching for envelopes with the given id,
schedules them and informs the user number of envelopes scheduled.
Admins no longer would need to restart the daemon to discover
manually moved messages.

Ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.49 2015/10/13 08:09:25 gilles Exp $	*/
d158 1
a158 1
		if (! inflight)
@


1.49
log
@pledge("stdio") the scheduler process
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.48 2015/01/20 17:37:54 deraadt Exp $	*/
d95 35
@


1.48
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.47 2014/07/10 14:45:02 eric Exp $	*/
d465 4
@


1.47
log
@Improve the scheduler, better and simpler.

- Get rid of the scheduler_batch structure. The scheduler can now return
  envelopes of different types in a single run, interlacing them to avoid
  batch effects.

- Ask for an acknowledgement from the queue when removing or expiring
  an envelope to benefit from the inflight envelope limitation mechanism.
  This ensures that the scheduler always keeps sending envelopes at a rate
  that the queue can sustain in all cases.

- Limit the number of envelopes in a holdq.  When a holdq is full,
  new envelopes are put back in the pending queue instead, with a
  shorter retry time.

- Plumbing for proc-ified schedulers.

imsg version bump. smtpctl stop before updating.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
@


1.46
log
@fix typos.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.45 2014/05/20 18:47:01 eric Exp $	*/
a51 6
static void scheduler_process_remove(struct scheduler_batch *);
static void scheduler_process_expire(struct scheduler_batch *);
static void scheduler_process_update(struct scheduler_batch *);
static void scheduler_process_bounce(struct scheduler_batch *);
static void scheduler_process_mda(struct scheduler_batch *);
static void scheduler_process_mta(struct scheduler_batch *);
d55 2
a56 1
static size_t			 ninflight;
d133 12
d274 7
d431 1
a431 1
	backend->init();
d444 1
d475 8
a482 4
	struct scheduler_batch	batch;
	int			typemask, left;

	log_trace(TRACE_SCHEDULER, "scheduler: getting next batch");
d487 1
a487 25
	typemask = SCHED_REMOVE | SCHED_EXPIRE | SCHED_UPDATE | SCHED_BOUNCE;
	if (ninflight < env->sc_scheduler_max_inflight &&
	    !(env->sc_flags & SMTPD_MDA_PAUSED))
		typemask |= SCHED_MDA;
	if (ninflight < env->sc_scheduler_max_inflight &&
	    !(env->sc_flags & SMTPD_MTA_PAUSED))
		typemask |= SCHED_MTA;

	left = typemask;

    again:

	log_trace(TRACE_SCHEDULER, "scheduler: typemask=0x%x", left);

	memset(&batch, 0, sizeof (batch));
	batch.evpids = evpids;
	batch.evpcount = env->sc_scheduler_max_schedule;
	backend->batch(left, &batch);

	switch (batch.type) {
	case SCHED_REMOVE:
		log_trace(TRACE_SCHEDULER, "scheduler: SCHED_REMOVE %zu",
		    batch.evpcount);
		scheduler_process_remove(&batch);
		break;
d489 7
a495 5
	case SCHED_EXPIRE:
		log_trace(TRACE_SCHEDULER, "scheduler: SCHED_EXPIRE %zu",
		    batch.evpcount);
		scheduler_process_expire(&batch);
		break;
d497 1
a497 5
	case SCHED_UPDATE:
		log_trace(TRACE_SCHEDULER, "scheduler: SCHED_UPDATE %zu",
		    batch.evpcount);
		scheduler_process_update(&batch);
		break;
d499 1
a499 5
	case SCHED_BOUNCE:
		log_trace(TRACE_SCHEDULER, "scheduler: SCHED_BOUNCE %zu",
		    batch.evpcount);
		scheduler_process_bounce(&batch);
		break;
d501 1
a501 5
	case SCHED_MDA:
		log_trace(TRACE_SCHEDULER, "scheduler: SCHED_MDA %zu",
		    batch.evpcount);
		scheduler_process_mda(&batch);
		break;
d503 1
a503 5
	case SCHED_MTA:
		log_trace(TRACE_SCHEDULER, "scheduler: SCHED_MTA %zu",
		    batch.evpcount);
		scheduler_process_mta(&batch);
		break;
d505 2
a506 3
	default:
		break;
	}
d508 1
a508 1
	log_trace(TRACE_SCHEDULER, "scheduler: mask=0x%x", batch.mask);
d510 2
a511 2
	left &= batch.mask;
	left &= ~batch.type;
d513 4
a516 12
	/* We can still schedule something immediately. */
	if (left)
		goto again;

	/* We can schedule in the next event frame */
	if (batch.mask & typemask ||
	    (batch.mask & SCHED_DELAY && batch.type != SCHED_DELAY)) {
		tv.tv_sec = 0;
		tv.tv_usec = 0;
		evtimer_add(&ev, &tv);
		return;
	}
d518 1
a518 2
	if (batch.type == SCHED_DELAY) {
		tv.tv_sec = batch.delay;
d521 1
a521 1
		    "scheduler: SCHED_DELAY %s", duration_to_text(tv.tv_sec));
d526 44
a569 2
	log_trace(TRACE_SCHEDULER, "scheduler: SCHED_NONE");
}
d571 8
a578 4
static void
scheduler_process_remove(struct scheduler_batch *batch)
{
	size_t	i;
d580 9
a588 6
	for (i = 0; i < batch->evpcount; i++) {
		log_debug("debug: scheduler: evp:%016" PRIx64 " removed",
		    batch->evpids[i]);
		m_create(p_queue, IMSG_SCHED_ENVELOPE_REMOVE, 0, 0, -1);
		m_add_evpid(p_queue, batch->evpids[i]);
		m_close(p_queue);
d591 5
a595 8
	stat_decrement("scheduler.envelope", batch->evpcount);
	stat_increment("scheduler.envelope.removed", batch->evpcount);
}

static void
scheduler_process_expire(struct scheduler_batch *batch)
{
	size_t	i;
d597 1
a597 7
	for (i = 0; i < batch->evpcount; i++) {
		log_debug("debug: scheduler: evp:%016" PRIx64 " expired",
		    batch->evpids[i]);
		m_create(p_queue, IMSG_SCHED_ENVELOPE_EXPIRE, 0, 0, -1);
		m_add_evpid(p_queue, batch->evpids[i]);
		m_close(p_queue);
	}
d599 3
a601 66
	stat_decrement("scheduler.envelope", batch->evpcount);
	stat_increment("scheduler.envelope.expired", batch->evpcount);
}

static void
scheduler_process_update(struct scheduler_batch *batch)
{
	size_t	i;

	for (i = 0; i < batch->evpcount; i++) {
		log_debug("debug: scheduler: evp:%016" PRIx64
		    " scheduled (update)", batch->evpids[i]);
	}

	stat_increment("scheduler.envelope.update", batch->evpcount);
}

static void
scheduler_process_bounce(struct scheduler_batch *batch)
{
	size_t	i;

	for (i = 0; i < batch->evpcount; i++) {
		log_debug("debug: scheduler: evp:%016" PRIx64
		    " scheduled (bounce)", batch->evpids[i]);
		m_create(p_queue, IMSG_SCHED_ENVELOPE_INJECT, 0, 0, -1);
		m_add_evpid(p_queue, batch->evpids[i]);
		m_close(p_queue);
	}

	ninflight += batch->evpcount;
	stat_increment("scheduler.envelope.inflight", batch->evpcount);
}

static void
scheduler_process_mda(struct scheduler_batch *batch)
{
	size_t	i;

	for (i = 0; i < batch->evpcount; i++) {
		log_debug("debug: scheduler: evp:%016" PRIx64
		    " scheduled (mda)", batch->evpids[i]);
		m_create(p_queue, IMSG_SCHED_ENVELOPE_DELIVER, 0, 0, -1);
		m_add_evpid(p_queue, batch->evpids[i]);
		m_close(p_queue);
	}

	ninflight += batch->evpcount;
	stat_increment("scheduler.envelope.inflight", batch->evpcount);
}

static void
scheduler_process_mta(struct scheduler_batch *batch)
{
	size_t	i;

	for (i = 0; i < batch->evpcount; i++) {
		log_debug("debug: scheduler: evp:%016" PRIx64
		    " scheduled (mta)", batch->evpids[i]);
		m_create(p_queue, IMSG_SCHED_ENVELOPE_TRANSFER, 0, 0, -1);
		m_add_evpid(p_queue, batch->evpids[i]);
		m_close(p_queue);
	}

	ninflight += batch->evpcount;
	stat_increment("scheduler.envelope.inflight", batch->evpcount);
@


1.45
log
@format string cleanup: change "%i" to "%d" and fix a few typos
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.44 2014/04/08 15:25:43 eric Exp $	*/
d533 1
a533 1
	/* We can still schedule something immediatly. */
@


1.44
log
@use correct imsg

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.43 2014/04/04 16:10:42 eric Exp $	*/
d232 1
a232 1
		    "scheduler: releasing %d on holdq (%i, %016" PRIx64 ")",
@


1.43
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d303 1
a303 1
	case IMSG_MTA_SCHEDULE:
@


1.42
log
@internal improvements and cleanups

- get rid of the whole penalty thing for failed envelopes in the mta and scheduler.
- do not disable routes on smtp errors
- try to schedule all types of envelopes on each scheduler frame.
@
text
@d84 1
a84 1
	case IMSG_QUEUE_SUBMIT_ENVELOPE:
d95 1
a95 1
	case IMSG_QUEUE_COMMIT_MESSAGE:
d107 1
a107 1
	case IMSG_QUEUE_REMOVE_MESSAGE:
d118 1
a118 1
	case IMSG_QUEUE_REMOVE:
d138 1
a138 1
	case IMSG_DELIVERY_OK:
d152 1
a152 1
	case IMSG_DELIVERY_TEMPFAIL:
d175 1
a175 1
				m_compose(p, IMSG_QUEUE_BOUNCE, 0, 0, -1,
d183 1
a183 1
	case IMSG_DELIVERY_PERMFAIL:
d197 1
a197 1
	case IMSG_DELIVERY_LOOP:
d211 1
a211 1
	case IMSG_DELIVERY_HOLD:
d225 1
a225 1
	case IMSG_DELIVERY_RELEASE:
d566 1
a566 1
		m_create(p_queue, IMSG_QUEUE_REMOVE, 0, 0, -1);
d583 1
a583 1
		m_create(p_queue, IMSG_QUEUE_EXPIRE, 0, 0, -1);
d613 1
a613 1
		m_create(p_queue, IMSG_BOUNCE_INJECT, 0, 0, -1);
d630 1
a630 1
		m_create(p_queue, IMSG_MDA_DELIVER, 0, 0, -1);
d647 1
a647 1
		m_create(p_queue, IMSG_MTA_TRANSFER, 0, 0, -1);
@


1.41
log
@get rid of fdlimit()
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.40 2013/12/26 17:25:32 eric Exp $	*/
a77 1
	uint32_t       		 penalty;
d90 1
a90 1
		scheduler_info(&si, &evp, 0);
a154 1
		m_get_u32(&m, &penalty);
d158 1
a158 1
		scheduler_info(&si, &evp, penalty);
d461 1
a461 1
	int			typemask;
d476 6
d485 1
a485 1
	backend->batch(typemask, &batch);
a487 10
	case SCHED_NONE:
		log_trace(TRACE_SCHEDULER, "scheduler: SCHED_NONE");
		return;

	case SCHED_DELAY:
		tv.tv_sec = batch.delay;
		log_trace(TRACE_SCHEDULER,
		    "scheduler: SCHED_DELAY %s", duration_to_text(tv.tv_sec));
		break;

d525 28
a552 1
		fatalx("scheduler_timeout: unknown batch type");
d554 2
a555 1
	evtimer_add(&ev, &tv);
@


1.40
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.39 2013/12/05 09:26:47 eric Exp $	*/
a417 2

	fdlimit(1.0);
@


1.39
log
@When a relay fails, let the scheduler update all envelopes in the
holdq as if they tempfailed.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d480 1
a480 1
	bzero(&batch, sizeof (batch));
@


1.38
log
@do not hardcode scheduler batch size, and reduce default limit to avoid
hammering effects.
@
text
@d54 1
d472 1
a472 1
	typemask = SCHED_REMOVE | SCHED_EXPIRE | SCHED_BOUNCE;
d508 6
d570 13
@


1.37
log
@Rework the mda and scheduler to use the holdq mechanism instead of
tempfail for limiting the number of pending deliveries to the same
user.  This allows to reach optimal delivery time even in case of
burst, while keeping the number of inflight envelopes low.
@
text
@d61 3
a66 5
#define	MSGBATCHSIZE	1024
#define	EVPBATCHSIZE	256

#define SCHEDULE_MAX	1024

a70 1
	struct evpstate		 state[EVPBATCHSIZE];
d75 1
a75 1
	uint32_t		 msgid, msgids[MSGBATCHSIZE];
d270 1
a270 1
		n = backend->messages(msgid, msgids, MSGBATCHSIZE);
d277 1
a277 1
		n = backend->envelopes(id, state, EVPBATCHSIZE);
d432 4
a464 1
	uint64_t		evpids[SCHEDULE_MAX];
d481 1
a481 2
	batch.evpcount = SCHEDULE_MAX;

a527 1

@


1.36
log
@Add a limit on the number of inflight envelopes.  The scheduler suspends
scheduling of mta/mda envelopes until the number of inflight envelopes
falls below that line.
@
text
@d83 1
a83 1
	int			 v, r;
d231 1
d236 3
a238 2
		    "scheduler: releasing %d on holdq %016" PRIx64, r, holdq);
		backend->release(holdq, r);
@


1.35
log
@Implement a feedback mechanism which allows the mta to "hold" envelopes
in the scheduler when it has too many tasks for a given relay.  The
envelopes are put on a wait queue, and are not scheduled again until
the mta "releases" some envelopes from that queue.

It prevents from having too many inflight envelopes, which are out of reach
for the admin.
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.34 2013/10/27 07:56:25 eric Exp $	*/
d60 1
d132 1
a132 1
		else
d134 3
d148 1
d164 1
d194 1
d208 1
d224 1
d470 2
a471 1
	if (!(env->sc_flags & SMTPD_MDA_PAUSED))
d473 2
a474 1
	if (!(env->sc_flags & SMTPD_MTA_PAUSED))
d578 1
d595 1
d612 1
@


1.34
log
@Create the control socket in the parent process to abort early if
another smtpd instance is running.  Close the inherited socket in
every forked process but control.
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.33 2013/10/25 18:58:10 eric Exp $	*/
d76 1
a76 1
	uint64_t		 evpid, id;
d204 24
@


1.33
log
@Improve reporting in smtpctl and a few fixes.

When sending a request to the scheduler, wait for the success/failure
report from the scheduler.  Simplify the code by introducing generic
functions for interruptible iteration over envelopes.  Report the total
number of affected envelopes for schedule, pause, resume and remove
envelope operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.32 2013/07/19 21:14:52 eric Exp $	*/
d373 1
@


1.32
log
@Many MTA improvements:

- Better transient error handling logic: failing destinations are
  automatically disabled for a while.  When a destination is active
  again, ask the scheduler to retry previous envelopes immediatly.
- More informative error report when all routes fail for a mail.
- Implement a "smtpctl show hoststats" command to get the latest stat
  message per MX domain.
- Implement a "smtpctl show routes" command to show the state the
  currently known routes to remote MXs.
- Implement a "smtpctl resume route" command to re-enable a route that
  has been disabled.
- Do not hardcode limits
- Minor code improvements
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 1
a82 1
	int			 v;
d266 1
a266 1
		backend->schedule(id);
d268 2
d286 1
a286 1
		backend->remove(id);
d288 2
d300 1
a300 1
		backend->suspend(id);
d302 2
d314 1
a314 1
		backend->resume(id);
d316 2
@


1.31
log
@scheduler improvements:
- implement suspend/resume scheduling for individual envelopes or message,
  with the associated smtpctl commands.
- allow the mta to request immediate scheduling of an envelope.
- on temporary failures a penalty can be given to further delay the next try.
@
text
@a557 2
	m_compose(p_queue, IMSG_MTA_BATCH, 0, 0, -1, NULL, 0);

d561 1
a561 1
		m_create(p_queue, IMSG_MTA_BATCH_ADD, 0, 0, -1);
a564 2

	m_compose(p_queue, IMSG_MTA_BATCH_END, 0, 0, -1, NULL, 0);
@


1.30
log
@Get rid of env->sc_pw and env->sc_pwqueue.  Early queue initialization
now happens in queue_init(), and backends take the queue passwd as
parameter in their init function.

Remove useless SMTPD_FILTER_USER while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.29 2013/07/19 07:49:08 eric Exp $	*/
d79 1
d92 1
a92 1
		scheduler_info(&si, &evp);
d102 1
a102 1
		    "scheduler: commiting msg:%08" PRIx32, msgid);
d153 1
d157 1
a157 1
		scheduler_info(&si, &evp);
d270 6
d285 24
@


1.29
log
@Remove useless sc_pid from struct smtpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.28 2013/05/24 17:03:14 eric Exp $	*/
d340 3
d349 1
a349 2
	pw = env->sc_pw;
	if (chroot(pw->pw_dir) == -1)
@


1.28
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.27 2013/02/10 15:01:16 eric Exp $	*/
a332 1
		env->sc_pid = getpid();
@


1.27
log
@When getting the next batch of envelope to schedule, use an array to
store envelope ids, rather than a dynamic list.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.26 2013/01/31 18:34:43 eric Exp $	*/
a24 1
#include <sys/param.h>
d59 1
d78 1
d119 17
d246 1
a246 1
			    imsg->hdr.peerid, 0, -1, 32);
d310 1
a310 1
	evtimer_del(&env->sc_ev);
d313 1
a313 1
	evtimer_add(&env->sc_ev, &tv);
d324 5
d341 6
a352 2
	config_process(PROC_SCHEDULER);

a357 10
	fdlimit(1.0);

	env->sc_scheduler = scheduler_backend_lookup(backend_scheduler);
	if (env->sc_scheduler == NULL)
		errx(1, "cannot find scheduler backend \"%s\"",
		    backend_scheduler);
	backend = env->sc_scheduler;

	backend->init();

d372 1
a372 1
	evtimer_set(&env->sc_ev, scheduler_timeout, NULL);
d451 1
a451 1
	evtimer_add(&env->sc_ev, &tv);
d462 1
a462 1
		m_create(p_queue, IMSG_QUEUE_REMOVE, 0, 0, -1, 9);
d479 1
a479 1
		m_create(p_queue, IMSG_QUEUE_EXPIRE, 0, 0, -1, 9);
d496 1
a496 1
		m_create(p_queue, IMSG_BOUNCE_INJECT, 0, 0, -1, 9);
d512 1
a512 1
		m_create(p_queue, IMSG_MDA_DELIVER, 0, 0, -1, 9);
d530 1
a530 1
		m_create(p_queue, IMSG_MTA_BATCH_ADD, 0, 0, -1, 9);
@


1.26
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.25 2013/01/26 09:37:23 gilles Exp $	*/
d66 2
d370 1
d383 4
d388 1
d391 1
a391 1
		log_trace(TRACE_SCHEDULER, "scheduler: sleeping");
d397 1
a397 1
		    "scheduler: pausing for %s", duration_to_text(tv.tv_sec));
d401 2
d407 2
d413 2
d419 2
d425 2
d440 1
a440 1
	struct id_list	*e;
d442 1
a442 2
	while ((e = batch->evpids)) {
		batch->evpids = e->next;
d444 1
a444 1
		    e->id);
d446 1
a446 1
		m_add_evpid(p_queue, e->id);
a447 1
		free(e);
d457 1
a457 1
	struct id_list	*e;
d459 1
a459 2
	while ((e = batch->evpids)) {
		batch->evpids = e->next;
d461 1
a461 1
		    e->id);
d463 1
a463 1
		m_add_evpid(p_queue, e->id);
a464 1
		free(e);
d474 1
a474 1
	struct id_list	*e;
d476 1
a476 2
	while ((e = batch->evpids)) {
		batch->evpids = e->next;
d478 1
a478 1
		    " scheduled (bounce)", e->id);
d480 1
a480 1
		m_add_evpid(p_queue, e->id);
a481 1
		free(e);
d490 1
a490 1
	struct id_list	*e;
d492 1
a492 2
	while ((e = batch->evpids)) {
		batch->evpids = e->next;
d494 1
a494 1
		    " scheduled (mda)", e->id);
d496 1
a496 1
		m_add_evpid(p_queue, e->id);
a497 1
		free(e);
d506 1
a506 1
	struct id_list	*e;
d510 1
a510 2
	while ((e = batch->evpids)) {
		batch->evpids = e->next;
d512 1
a512 1
		    " scheduled (mta)", e->id);
d514 1
a514 1
		m_add_evpid(p_queue, e->id);
a515 1
		free(e);
d518 2
a520 2

	m_compose(p_queue, IMSG_MTA_BATCH_END, 0, 0, -1, NULL, 0);
@


1.25
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.23 2012/11/12 14:58:53 eric Exp $	*/
d355 2
a356 1
	event_dispatch();
@


1.24
log
@Allow "smtpctl show queue" to run in "online" mode if the smtpd server
is running.  The scheduler sends the runtime state of each envelope to
the queue process which loads the envelope, fills the runtime bits and
sends the envelope back to the client. Iteration over the envelope set
happens in small chunks to make the request interruptible and to allow
the server to keep doing its job in the meantime.

Adpat "smtpctl schedule-all" to schedule the messages one by one using
the same iteration mechanism.

Document "smtpctl monitor" and "smtpctl show queue".

ok gilles@@
@
text
@d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d48 1
a48 1
static void scheduler_imsg(struct imsgev *, struct imsg *);
d67 1
a67 1
scheduler_imsg(struct imsgev *iev, struct imsg *imsg)
d69 1
d71 1
a71 1
	struct envelope		*e;
d73 2
a74 1
	uint64_t		 id;
d77 2
d83 3
a85 1
		e = imsg->data;
d87 2
a88 2
		    "scheduler: inserting evp:%016" PRIx64, e->id);
		scheduler_info(&si, e);
d94 3
a96 1
		msgid = *(uint32_t *)(imsg->data);
d106 3
a108 1
		msgid = *(uint32_t *)(imsg->data);
d116 4
a119 2
	case IMSG_QUEUE_DELIVERY_OK:
		id = *(uint64_t *)(imsg->data);
d121 2
a122 2
		    "scheduler: deleting evp:%016" PRIx64 " (ok)", id);
		backend->delete(id);
d129 4
a132 2
	case IMSG_QUEUE_DELIVERY_TEMPFAIL:
		e = imsg->data;
d134 2
a135 2
		    "scheduler: updating evp:%016" PRIx64, e->id);
		scheduler_info(&si, e);
d139 17
d159 4
a162 2
	case IMSG_QUEUE_DELIVERY_PERMFAIL:
		id = *(uint64_t *)(imsg->data);
d164 2
a165 2
		    "scheduler: deleting evp:%016" PRIx64 " (fail)", id);
		backend->delete(id);
d172 4
a175 2
	case IMSG_QUEUE_DELIVERY_LOOP:
		id = *(uint64_t *)(imsg->data);
d177 2
a178 2
		    "scheduler: deleting evp:%016" PRIx64 " (loop)", id);
		backend->delete(id);
d185 1
a185 1
	case IMSG_QUEUE_PAUSE_MDA:
d190 1
a190 1
	case IMSG_QUEUE_RESUME_MDA:
d196 1
a196 1
	case IMSG_QUEUE_PAUSE_MTA:
d201 1
a201 1
	case IMSG_QUEUE_RESUME_MTA:
d208 4
a211 1
		log_verbose(*(int *)imsg->data);
d214 1
a214 1
	case IMSG_SCHEDULER_MESSAGES:
d217 2
a218 2
		imsg_compose_event(iev, IMSG_SCHEDULER_MESSAGES,
		    imsg->hdr.peerid, 0, -1, msgids, n * sizeof (*msgids));
d221 1
a221 1
	case IMSG_SCHEDULER_ENVELOPES:
d225 6
a230 3
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_SCHEDULER_ENVELOPES, imsg->hdr.peerid, 0, -1,
			    &state[i], sizeof state[i]);
d232 2
a233 2
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_SCHEDULER_ENVELOPES, imsg->hdr.peerid, 0, -1, NULL, 0);
d236 1
a236 1
	case IMSG_SCHEDULER_SCHEDULE:
d248 1
a248 1
	case IMSG_SCHEDULER_REMOVE:
d290 1
d292 1
a292 1
	tv.tv_usec = 10;
a300 1

a303 5
	struct peer peers[] = {
		{ PROC_CONTROL,	imsg_dispatch },
		{ PROC_QUEUE,	imsg_dispatch }
	};

d308 1
d322 1
a322 2
	smtpd_process = PROC_SCHEDULER;
	setproctitle("%s", env->sc_title[smtpd_process]);
d349 3
a351 2
	config_pipes(peers, nitems(peers));
	config_peers(peers, nitems(peers));
d427 3
a429 2
		imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_REMOVE,
		    0, 0, -1, &e->id, sizeof e->id);
d446 3
a448 2
		imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_QUEUE_EXPIRE,
		    0, 0, -1, &e->id, sizeof e->id);
d465 3
a467 2
		imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_SMTP_ENQUEUE,
		    0, 0, -1, &e->id, sizeof e->id);
d483 3
a485 2
		imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_MDA_SESS_NEW,
		    0, 0, -1, &e->id, sizeof e->id);
d497 1
a497 2
	imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_BATCH_CREATE,
	    0, 0, -1, NULL, 0);
d503 3
a505 2
		imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_BATCH_APPEND,
		    0, 0, -1, &e->id, sizeof e->id);
d511 1
a511 2
	imsg_compose_event(env->sc_ievs[PROC_QUEUE], IMSG_BATCH_CLOSE,
	    0, 0, -1, NULL, 0);
@


1.23
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.21 2012/09/16 16:43:29 chl Exp $	*/
d63 3
d69 1
d73 2
a74 2
	uint32_t		 msgid;
	size_t			 n;
d176 19
d197 3
a199 4
		if (id == 0)
			log_debug("debug: scheduler: scheduling all envelopes");
		else if (id <= 0xffffffffL)
			log_debug("debug: scheduler: scheduling msg:%08" PRIx64, id);
d201 2
a202 1
			log_debug("debug: scheduler: scheduling evp:%016" PRIx64, id);
d210 2
a211 1
			log_debug("debug: scheduler: removing msg:%08" PRIx64, id);
d213 2
a214 1
			log_debug("debug: scheduler: removing evp:%016" PRIx64, id);
d220 2
a221 1
	errx(1, "scheduler_imsg: unexpected %s imsg", imsg_to_str(imsg->hdr.type));
d378 1
a378 1
	evtimer_add(&env->sc_ev, &tv);	
d424 2
a425 2
		log_debug("debug: scheduler: evp:%016" PRIx64 " scheduled (bounce)",
		    e->id);
d441 2
a442 2
		log_debug("debug: scheduler: evp:%016" PRIx64 " scheduled (mda)",
		    e->id);
d454 1
a454 1
	struct id_list		*e;
d461 2
a462 2
		log_debug("debug: scheduler: evp:%016" PRIx64 " scheduled (mta)",
		    e->id);
@


1.22
log
@Make counters more informative in the scheduler:

- Change the scheduler backend API a bit: commit() and rollback()
  API calls return the number of envelopes added or canceled; put
  the number of envelopes in the structure returned by batch().

- Properly report the number of incoming, registered, removed and
  expired envelopes, as well as the outcome of deliveries.

ok gilles@@
@
text
@d175 1
a175 1
			log_debug("scheduler: scheduling all envelopes");
d177 1
a177 1
			log_debug("scheduler: scheduling msg:%08" PRIx64, id);
d179 1
a179 1
			log_debug("scheduler: scheduling evp:%016" PRIx64, id);
d187 1
a187 1
			log_debug("scheduler: removing msg:%08" PRIx64, id);
d189 1
a189 1
			log_debug("scheduler: removing evp:%016" PRIx64, id);
d214 1
a214 1
	log_info("scheduler handler exiting");
d362 1
a362 1
		log_debug("scheduler: evp:%016" PRIx64 " removed",
d380 1
a380 1
		log_debug("scheduler: evp:%016" PRIx64 " expired",
d398 1
a398 1
		log_debug("scheduler: evp:%016" PRIx64 " scheduled (bounce)",
d415 1
a415 1
		log_debug("scheduler: evp:%016" PRIx64 " scheduled (mda)",
d435 1
a435 1
		log_debug("scheduler: evp:%016" PRIx64 " scheduled (mta)",
@


1.21
log
@Factorize log_imsg() in imsg_dispatch() instead of in each imsg_callback()'s
and put it out of profiling, so it's not accounted.

While there, for PROC_PARENT:
- set smtpd_process for PROC_PARENT
- use setproctitle() like other processes

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.20 2012/09/11 08:37:52 eric Exp $	*/
d70 1
d79 1
d87 3
a89 1
		backend->commit(msgid);
d97 2
a98 1
		backend->rollback(msgid);
d107 3
a109 1
		stat_decrement("scheduler.inflight", 1);
d119 2
a120 1
		stat_decrement("scheduler.inflight", 1);
d129 3
a131 1
		stat_decrement("scheduler.inflight", 1);
d140 3
a142 1
		stat_decrement("scheduler.inflight", 1);
d271 2
a272 1
		errx(1, "cannot find scheduler backend \"%s\"", backend_scheduler);
a365 1
		stat_increment("scheduler.removed", 1);
d368 3
a383 1
		stat_increment("scheduler.expired", 1);
d386 3
a401 1
		stat_increment("scheduler.inflight", 1);
d404 2
a418 1
		stat_increment("scheduler.inflight", 1);
d421 2
a438 1
		stat_increment("scheduler.inflight", 1);
d441 2
@


1.20
log
@Rework the scheduler internals.  Fix some scheduling loop issues and
handle envelope scheduling/expiration better.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.19 2012/08/25 22:03:26 gilles Exp $	*/
a69 2

	log_imsg(PROC_SCHEDULER, iev->proc, imsg);
@


1.19
log
@- add myself to the copyright in control.c, i've done quite a few changes
there in the last few years ;-)
- get rid of availdesc(): getdtablecount() is so much more reliable
- get rid of env->sc_maxconn, we can be much smarter with getdtablecount()
	and getdtablesize()
- disable accept when we hit the control process fd reserve
- disable accept when we fail
- enable accept when we're back below the limit

this is not the full fd exhaustion diff, i'll merge changes from relayd
tomorrow, this was only required to get rid of the env->sc_maxconn and
availdesc() mess

"reads alright" eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.18 2012/08/25 10:23:12 gilles Exp $	*/
d305 1
a305 1
	backend->batch(typemask, time(NULL), &batch);
d314 1
a314 1
		    "scheduler: pausing for %li seconds", tv.tv_sec);
a368 1
		backend->delete(e->id);
@


1.18
log
@- introduce struct stat_value
- statistics can now have a type (counter, timestamp, timeval, timespec and
  possibly others in the future)
- stat_increment() / stat_decrement() now take an increment/decrement value
  and are at the moment only of type counter
- stat_set() now takes a stat_value
- provide helpers to convert raw values to stat_value

ok eric@@, ok chl@@

while at it fix a rq_queue_dump() call using a bogus timestamp in scheduler
ramqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.17 2012/08/24 18:46:46 eric Exp $	*/
a256 1
	/* see fdlimit()-related comment in queue.c */
a257 2
	if ((env->sc_maxconn = availdesc() / 4) < 1)
		fatalx("scheduler: fd starvation");
@


1.17
log
@When an smtp session fails and IMSG_QUEUE_REMOVE_MESSAGE is sent to the
queue, also notify the scheduler so it can rollback the current update.
Send only the msgid while there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.16 2012/08/24 18:21:06 eric Exp $	*/
d104 1
a104 1
		stat_decrement("scheduler.inflight");
d114 1
a114 1
		stat_decrement("scheduler.inflight");
d123 1
a123 1
		stat_decrement("scheduler.inflight");
d132 1
a132 1
		stat_decrement("scheduler.inflight");
d358 1
a358 1
		stat_increment("scheduler.removed");
d375 1
a375 1
		stat_increment("scheduler.expired");
d391 1
a391 1
		stat_increment("scheduler.inflight");
d407 1
a407 1
		stat_increment("scheduler.inflight");
d426 1
a426 1
		stat_increment("scheduler.inflight");
@


1.16
log
@add stat counter for the number of envelopes inflight.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.15 2012/08/21 13:13:17 eric Exp $	*/
d91 1
a91 1
	case IMSG_QUEUE_TEMPFAIL:
@


1.15
log
@Re-enable loop detection, but in mta and mda this time.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.14 2012/08/20 09:34:53 chl Exp $	*/
d104 1
d114 1
d123 1
d132 1
d358 1
d375 1
d391 1
d407 1
d426 1
@


1.14
log
@chroot scheduler in /var/empty instead of /var/spool/smtpd now that eric@@ fixed the initialization layer violation

committing on behalf of gilles@@

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.13 2012/08/19 15:06:36 chl Exp $	*/
d120 8
@


1.13
log
@fix smtpctl schedule-all and schedule-id <msgid>

with help from eric@@

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.12 2012/08/18 18:18:23 gilles Exp $	*/
d232 1
a232 2

	if (chroot(PATH_SPOOL) == -1)
@


1.12
log
@- introduce stat_backend, an API for pluggable statistic backends
  > statistics are no longer static structures in shared memory
  > statistics are only set, smtpd never uses them in its logic
  > each statistic is a key/value where key can be any (dynamic) string
- convert all uses of the former API to use the new one
- implement stat_ramstat that keeps non-persistent stats in ram structure

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.11 2012/08/09 19:16:26 eric Exp $	*/
d152 6
a157 1
		log_debug("scheduler: scheduling evp:%016" PRIx64, id);
@


1.11
log
@Envelopes scheduled as "removed" are already deleted from the scheduler.
Do not delete them twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.10 2012/08/09 12:19:33 eric Exp $	*/
a410 2

	stat_increment(STATS_MTA_SESSION);
@


1.10
log
@dead prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.9 2012/08/09 09:48:02 eric Exp $	*/
a339 1
		backend->delete(e->id);
@


1.9
log
@Improve the message flows to completely isolate operations on the
queue backend within the queue process.

The scheduler sends envelope ids to the queue process which loads
the envelope and forward the request to the agent responsible for
the delivery.  The result is sent by the agent to the queue which
updates the storage before notifying the scheduler.

Bounces are created and enqueued (from the client side) by the
queue process, rather than the scheduler.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.8 2012/08/08 08:50:42 eric Exp $	*/
a57 1
static int scheduler_load_message(u_int32_t);
@


1.8
log
@Improve the scheduler backend API.

New envelopes are pushed into the scheduler through the insert()
commit() rollback() transactional interface functions.

Worklists are pulled from the scheduler through a single batch()
interface function, which returns a list of envelope ids and the
type of processing. Envelopes returned in this batch are said to
be "in-flight", as opposed to "pending". They are supposed to be
processed in some way, and either updated() or deleted() at some
point.

The schedule()/remove() functions are used to alter the internal
state of "pending" envelopes to make them schedulable.  The enve-
lopes will be part of a worklist on the next call to batch().

Rewrite the scheduler_ramqueue backend.

The initial queue loading in now done by the queue.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.7 2012/07/18 22:04:49 eric Exp $	*/
a59 3
void scheduler_envelope_update(struct envelope *);
void scheduler_envelope_delete(struct envelope *);

d67 4
a70 2
	struct envelope	*e, bounce;
	struct scheduler_info	si;
d75 9
d85 1
a85 1
		e = imsg->data;
d87 10
a96 2
		    "scheduler: IMSG_QUEUE_COMMIT_MESSAGE: %016"PRIx64, e->id);
		scheduler_load_message(evpid_to_msgid(e->id));
d101 1
a101 2
		stat_decrement(STATS_SCHEDULER);
		e = imsg->data;
d103 2
a104 3
		    "scheduler: IMSG_QUEUE_DELIVERY_OK: %016"PRIx64, e->id);
		backend->delete(e->id);
		queue_envelope_delete(e);
a108 1
		stat_decrement(STATS_SCHEDULER);
d111 1
a111 3
		    "scheduler: IMSG_QUEUE_DELIVERY_TEMPFAIL: %016"PRIx64, e->id);
		e->retry++;
		queue_envelope_update(e);
d118 1
a118 2
		stat_decrement(STATS_SCHEDULER);
		e = imsg->data;
d120 2
a121 25
		    "scheduler: IMSG_QUEUE_DELIVERY_PERMFAIL: %016"PRIx64, e->id);
		if (e->type != D_BOUNCE && e->sender.user[0] != '\0') {
			bounce_record_message(e, &bounce);
			scheduler_info(&si, &bounce);
			backend->insert(&si);
			backend->commit(evpid_to_msgid(bounce.id));
		}
		backend->delete(e->id);
		queue_envelope_delete(e);
		scheduler_reset_events();
		return;

	case IMSG_MDA_SESS_NEW:
		log_trace(TRACE_SCHEDULER, "scheduler: IMSG_MDA_SESS_NEW");
		stat_decrement(STATS_MDA_SESSION);
		if (env->sc_maxconn - stat_get(STATS_MDA_SESSION, STAT_ACTIVE))
			env->sc_flags &= ~SMTPD_MDA_BUSY;
		scheduler_reset_events();
		return;

	case IMSG_BATCH_DONE:
		log_trace(TRACE_SCHEDULER, "scheduler: IMSG_BATCH_DONE");
		stat_decrement(STATS_MTA_SESSION);
		if (env->sc_maxconn - stat_get(STATS_MTA_SESSION, STAT_ACTIVE))
			env->sc_flags &= ~SMTPD_MTA_BUSY;
a124 13
	case IMSG_SMTP_ENQUEUE:
		e = imsg->data;
		log_trace(TRACE_SCHEDULER,
		    "scheduler: IMSG_SMTP_ENQUEUE: %016"PRIx64, e->id);
		if (imsg->fd < 0 || !bounce_session(imsg->fd, e)) {
			queue_envelope_update(e);
			scheduler_info(&si, e);
			backend->update(&si);
			scheduler_reset_events();
			return;
		}
		return;

d126 1
a126 1
		log_trace(TRACE_SCHEDULER, "scheduler: IMSG_QUEUE_PAUSE_MDA");
d131 1
a131 1
		log_trace(TRACE_SCHEDULER, "scheduler: IMSG_QUEUE_RESUME_MDA");
d137 1
a137 1
		log_trace(TRACE_SCHEDULER, "scheduler: IMSG_QUEUE_PAUSE_MTA");
d142 1
a142 1
		log_trace(TRACE_SCHEDULER, "scheduler: IMSG_QUEUE_RESUME_MTA");
a147 1
		log_trace(TRACE_SCHEDULER, "scheduler: IMSG_CTL_VERBOSE");
d152 3
a154 4
		log_trace(TRACE_SCHEDULER,
		    "scheduler: IMSG_SCHEDULER_SCHEDULE: %016"PRIx64,
		    *(u_int64_t *)imsg->data);
		backend->schedule(*(u_int64_t *)imsg->data);
d159 6
a164 4
		log_trace(TRACE_SCHEDULER,
		    "scheduler: IMSG_SCHEDULER_REMOVE: %016"PRIx64,
		    *(u_int64_t *)imsg->data);
		backend->remove(*(u_int64_t *)imsg->data);
a334 1
	struct envelope evp;
d339 1
a339 1
		log_debug("scheduler: deleting evp:%016" PRIx64 " (removed)",
d341 3
a343 2
		evp.id = e->id;
		queue_envelope_delete(&evp);
a350 1
	struct envelope evp;
d355 1
a355 1
		log_debug("scheduler: deleting evp:%016" PRIx64 " (expire)",
d357 3
a359 2
		evp.id = e->id;
		queue_envelope_delete(&evp);
a366 1
	struct envelope	 evp;
d371 1
a371 1
		log_debug("scheduler: scheduling evp:%016" PRIx64 " (bounce)",
d373 2
a374 7
		queue_envelope_load(e->id, &evp);
		evp.lasttry = time(NULL);
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_SMTP_ENQUEUE, PROC_SMTP, 0, -1, &evp,
		    sizeof evp);
		stat_increment(STATS_SCHEDULER);
		stat_increment(STATS_SCHEDULER_BOUNCES);
a381 1
	struct envelope	 evp;
a382 1
	int		 fd;
d386 1
a386 1
		log_debug("scheduler: scheduling evp:%016" PRIx64 " (mda)",
d388 2
a389 8
		queue_envelope_load(e->id, &evp);
		evp.lasttry = time(NULL);
		fd = queue_message_fd_r(evpid_to_msgid(evp.id));
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_MDA_SESS_NEW, PROC_MDA, 0, fd, &evp,
		    sizeof evp);
		stat_increment(STATS_SCHEDULER);
		stat_increment(STATS_MDA_SESSION);
a396 2
	struct envelope		 evp;
	struct mta_batch	 mta_batch;
d399 2
a400 9
	queue_envelope_load(batch->evpids->id, &evp);

	bzero(&mta_batch, sizeof mta_batch);
	mta_batch.id    = arc4random();
	mta_batch.relay = evp.agent.mta.relay;

	imsg_compose_event(env->sc_ievs[PROC_QUEUE],
	    IMSG_BATCH_CREATE, PROC_MTA, 0, -1, &mta_batch,
	    sizeof mta_batch);
d404 1
a404 1
		log_debug("scheduler: scheduling evp:%016" PRIx64 " (mta)",
a405 3
		queue_envelope_load(e->id, &evp);
		evp.lasttry = time(NULL);
		evp.batch_id = mta_batch.id;
d407 1
a407 1
		    PROC_MTA, 0, -1, &evp, sizeof evp);
a408 1
		stat_increment(STATS_SCHEDULER);
d412 1
a412 1
	    PROC_MTA, 0, -1, &mta_batch, sizeof mta_batch);
a414 38
}

void
scheduler_envelope_update(struct envelope *e)
{
	struct scheduler_info si;

	scheduler_info(&si, e);
	backend->update(&si);
	scheduler_reset_events();
}

void
scheduler_envelope_delete(struct envelope *e)
{
	backend->delete(e->id);
	scheduler_reset_events();
}

static int
scheduler_load_message(u_int32_t msgid)
{
	struct qwalk	*q;
	u_int64_t	 evpid;
	struct envelope	 envelope;
	struct scheduler_info   si;

	q = qwalk_new(msgid);
	while (qwalk(q, &evpid)) {
		if (! queue_envelope_load(evpid, &envelope))
			continue;
		scheduler_info(&si, &envelope);
		backend->insert(&si);
	}
	qwalk_close(q);
	backend->commit(msgid);

	return 1;
@


1.7
log
@make the scheduler less verbose by default.

suggested by Percy Piper.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.6 2012/07/10 11:13:40 gilles Exp $	*/
d7 1
a50 1
static void scheduler_setup_events(void);
a51 1
static void scheduler_disable_events(void);
d53 5
a57 5
static void scheduler_remove(u_int64_t);
static void scheduler_remove_envelope(u_int64_t);
static int scheduler_process_envelope(u_int64_t);
static int scheduler_process_batch(enum delivery_type, u_int64_t);
static int scheduler_check_loop(struct envelope *);
d60 3
d89 1
a89 1
		backend->remove(e->id);
d91 1
d102 1
a102 1
		backend->insert(&si);
d115 1
a115 1
			scheduler_reset_events();
d117 1
a117 1
		backend->remove(e->id);
d119 1
d145 1
a145 1
			backend->insert(&si);
d182 2
a183 2
		backend->force(*(u_int64_t *)imsg->data);
		scheduler_reset_events();		
d190 1
a190 1
		scheduler_remove(*(u_int64_t *)imsg->data);
a192 1

d198 1
a198 1
void
d211 1
a211 1
void
d218 1
a218 12
void
scheduler_setup_events(void)
{
	struct timeval	 tv;

	evtimer_set(&env->sc_ev, scheduler_timeout, NULL);
	tv.tv_sec = 0;
	tv.tv_usec = 10;
	evtimer_add(&env->sc_ev, &tv);
}

void
a227 6
void
scheduler_disable_events(void)
{
	evtimer_del(&env->sc_ev);
}

d293 2
a294 1
	scheduler_setup_events();
a295 1
	scheduler_disable_events();
d301 1
a301 1
void
d304 5
a308 31
	time_t		nsched;
	time_t		curtm;
	u_int64_t	evpid;
	static int	setup = 0;
	int		delay = 0;
	struct timeval	tv;

	log_trace(TRACE_SCHEDULER, "scheduler: entering scheduler_timeout");

	/* if we're not done setting up the scheduler, do it some more */
	if (! setup)
		setup = backend->setup();

	/* we don't have a schedulable envelope ... sleep */
	if (! backend->next(&evpid, &nsched))
		goto scheduler_sleep;

	/* is the envelope schedulable right away ? */
	curtm = time(NULL);
	if (nsched <= curtm) {
		/* yup */
		scheduler_process_envelope(evpid);
	}
	else {
		/* nope, so we can either keep the timeout delay to 0 if we
		 * are not done setting up the scheduler, or sleep until it
		 * is time to schedule that envelope otherwise.
		 */
		if (setup)
			delay = nsched - curtm;
	}
d310 1
a310 4
	if (delay)
		log_trace(TRACE_SCHEDULER, "scheduler: pausing for %d seconds",
		    delay);
	tv.tv_sec = delay;
a311 2
	evtimer_add(&env->sc_ev, &tv);
	return;
d313 21
a333 4
scheduler_sleep:
	log_trace(TRACE_SCHEDULER, "scheduler: sleeping");
	return;
}
d335 3
a337 6
static int
scheduler_process_envelope(u_int64_t evpid)
{
	struct envelope	 envelope;
	size_t		 mta_av, mda_av, bnc_av;
	struct scheduler_info	si;
d339 3
a341 12
	mta_av = env->sc_maxconn - stat_get(STATS_MTA_SESSION, STAT_ACTIVE);
	mda_av = env->sc_maxconn - stat_get(STATS_MDA_SESSION, STAT_ACTIVE);
	bnc_av = env->sc_maxconn - stat_get(STATS_SCHEDULER_BOUNCES, STAT_ACTIVE);

	if (! queue_envelope_load(evpid, &envelope))
		return 0;

	if (envelope.type == D_MDA)
		if (mda_av == 0) {
			env->sc_flags |= SMTPD_MDA_BUSY;
			return 0;
		}
d343 3
a345 5
	if (envelope.type == D_MTA)
		if (mta_av == 0) {
			env->sc_flags |= SMTPD_MTA_BUSY;
			return 0;
		}
d347 3
a349 5
	if (envelope.type == D_BOUNCE)
		if (bnc_av == 0) {
			env->sc_flags |= SMTPD_BOUNCE_BUSY;
			return 0;
		}
d351 3
a353 2
	if (scheduler_check_loop(&envelope)) {
		struct envelope bounce;
d355 2
a356 7
		envelope_set_errormsg(&envelope, "loop has been detected");
		if (bounce_record_message(&envelope, &bounce)) {
			scheduler_info(&si, &bounce);
			backend->insert(&si);
		}
		backend->remove(evpid);
		queue_envelope_delete(&envelope);
d358 5
a362 1
		scheduler_reset_events();
d364 7
a370 1
		return 0;
d372 1
d374 5
d380 8
a387 1
	return scheduler_process_batch(envelope.type, evpid);
d390 2
a391 2
static int
scheduler_process_batch(enum delivery_type type, u_int64_t evpid)
d393 2
a394 3
	struct envelope evp;
	void *batch;
	int fd;
d396 9
a404 13
	batch = backend->batch(evpid);
	switch (type) {
	case D_BOUNCE:
		while (backend->fetch(batch, &evpid)) {
			if (! queue_envelope_load(evpid, &evp))
				goto end;

			evp.lasttry = time(NULL);
			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_SMTP_ENQUEUE, PROC_SMTP, 0, -1, &evp,
			    sizeof evp);
			backend->schedule(evpid);
		}
d407 16
a422 7
		break;
		
	case D_MDA:
		backend->fetch(batch, &evpid);
		if (! queue_envelope_load(evpid, &evp))
			goto end;
		
d424 1
a424 1
		fd = queue_message_fd_r(evpid_to_msgid(evpid));
a427 2
		backend->schedule(evpid);

d430 3
a432 1
		break;
d434 29
a462 2
	case D_MTA: {
		struct mta_batch mta_batch;
d464 2
a465 9
		/* FIXME */
		if (! backend->fetch(batch, &evpid))
			goto end;
		if (! queue_envelope_load(evpid, &evp))
			goto end;

		bzero(&mta_batch, sizeof mta_batch);
		mta_batch.id    = arc4random();
		mta_batch.relay = evp.agent.mta.relay;
d467 2
a468 3
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_BATCH_CREATE, PROC_MTA, 0, -1, &mta_batch,
		    sizeof mta_batch);
d470 4
a473 9
		while (backend->fetch(batch, &evpid)) {
			if (! queue_envelope_load(evpid, &evp))
				goto end;
			evp.lasttry = time(NULL); /* FIXME */
			evp.batch_id = mta_batch.id;

			imsg_compose_event(env->sc_ievs[PROC_QUEUE],
			    IMSG_BATCH_APPEND, PROC_MTA, 0, -1, &evp,
			    sizeof evp);
d475 4
a478 3
			backend->schedule(evpid);
			stat_increment(STATS_SCHEDULER);
		}
d480 5
a484 15
		imsg_compose_event(env->sc_ievs[PROC_QUEUE],
		    IMSG_BATCH_CLOSE, PROC_MTA, 0, -1, &mta_batch,
		    sizeof mta_batch);

		stat_increment(STATS_MTA_SESSION);
		break;
	}
		
	default:
		fatalx("scheduler_process_batchqueue: unknown type");
	}

end:
	backend->close(batch);
	return 1;
d493 1
a493 1
	struct scheduler_info	si;
d502 2
a503 1
 	qwalk_close(q);
a505 91
}

static int
scheduler_check_loop(struct envelope *ep)
{
	int fd;
	FILE *fp;
	char *buf, *lbuf;
	size_t len;
	struct mailaddr maddr;
	int ret = 0;
	int rcvcount = 0;

	fd = queue_message_fd_r(evpid_to_msgid(ep->id));
	if ((fp = fdopen(fd, "r")) == NULL)
		fatal("fdopen");

	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			/* EOF without EOL, copy and add the NUL */
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}

		if (strchr(buf, ':') == NULL && !isspace((int)*buf))
			break;

		if (strncasecmp("Received: ", buf, 10) == 0) {
			rcvcount++;
			if (rcvcount == MAX_HOPS_COUNT) {
				ret = 1;
				break;
			}
		}

		else if (strncasecmp("Delivered-To: ", buf, 14) == 0) {
			struct mailaddr dest;

			bzero(&maddr, sizeof (struct mailaddr));
			if (! email_to_mailaddr(&maddr, buf + 14))
				continue;
			
			dest = ep->dest;
			if (ep->type == D_BOUNCE)
				dest = ep->sender;

			if (strcasecmp(maddr.user, dest.user) == 0 &&
			    strcasecmp(maddr.domain, dest.domain) == 0) {
				ret = 1;
				break;
			}
		}
	}
	free(lbuf);

	fclose(fp);
	return ret;
}

static void
scheduler_remove(u_int64_t id)
{
	void	*msg;

	/* removing by evpid */
	if (id > 0xffffffffL) {
		scheduler_remove_envelope(id);
		return;
	}

	/* removing by msgid */
	msg = backend->message(id);
	while (backend->fetch(msg, &id))
		scheduler_remove_envelope(id);
	backend->close(msg);
}

static void
scheduler_remove_envelope(u_int64_t evpid)
{
	struct envelope evp;

	evp.id = evpid;
	queue_envelope_delete(&evp);
	backend->remove(evpid);
@


1.6
log
@- simplify the scheduler loop logic further, it is ridiculously simple now
  and I don't think we can do much better (at that level) :-p
- always break out of the handler after processing an envelope, this will
  avoid a busy scheduler from not getting a chance to handle SIGTERM/SIGINT
  YES we can now ctrl-c a maaaaad scheduler !

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.5 2012/07/09 17:57:54 gilles Exp $	*/
d351 2
a352 1
		log_info("scheduler: pausing for %d seconds", delay);
d359 1
a359 1
	log_info("scheduler: sleeping");
@


1.5
log
@- introduce log_trace(TRACE_SCHEDULER, ...)
- simplify a tiny tiny bit the scheduler loop
- no functional change (yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.4 2012/07/09 09:57:53 gilles Exp $	*/
a319 1
	int		schedulable;
d322 1
a325 7
again:
	log_trace(TRACE_SCHEDULER, "scheduler: entering scheduler_timeout loop");

	/* do we have something to schedule at some point in the future ? */
	schedulable = 0;
	if (backend->next(NULL, &nsched))
		schedulable = 1;
a327 1
	curtm = time(NULL);
d329 1
a329 1
		setup = backend->setup(curtm, nsched);
d331 2
a332 2
	/* we have nothing to schedule and we're done setting up the scheduler */
	if (! schedulable && setup)
d335 4
a338 9
	/* we have something to schedule, just not now, pause a little */
	if (nsched > curtm)
		goto scheduler_pause;

	/* pop envelopes as long as they are schedulable */
	while (backend->next(&evpid, &nsched)) {
		if (nsched > curtm)
			goto scheduler_pause;

d341 8
d350 3
a352 8
	/* nothing left to schedule, but we're not done setting scheduler */
	if (! setup)
		goto again;

scheduler_pause:
	log_info("scheduler: pausing for %lld seconds",
	    (long long int)nsched - curtm);
	tv.tv_sec = nsched - curtm;
@


1.4
log
@- runner is the terminology we used back when we had runqueues, we no
  longer have them and runner is actually a scheduler so rename.
- introduce scheduler_backend which does the same to scheduler than
  queue_backend does to queue and map_backend does to maps
- remove all occurences of RUNNER and runner, replace them with SCHEDULER
  and scheduler

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: runner.c,v 1.144 2012/07/09 08:08:29 gilles Exp $	*/
d59 1
a59 1
static int scheduler_message_to_scheduler(u_int32_t);
d76 3
a78 1
		scheduler_message_to_scheduler(evpid_to_msgid(e->id));
d85 2
a86 1
		log_debug("queue_delivery_ok: %016"PRIx64, e->id);
d94 2
a97 1
		log_debug("queue_delivery_tempfail: %016"PRIx64, e->id);
d106 2
a109 2
			log_debug("queue_delivery_permfail: %016"PRIx64,
			    bounce.id);
d119 1
d127 1
d136 2
a139 1
			log_debug("smtp_enqueue: %016"PRIx64, e->id);
d148 1
d153 1
d159 1
d164 1
d170 1
d175 3
d182 4
a185 1
	case IMSG_SCHEDULER_REMOVE: {
d189 1
a189 1
	}
d318 6
a323 5
	struct timeval		 tv;
	static int		 rq_done = 0;
	time_t			 nsched;
	time_t			 curtm;
	u_int64_t		 evpid;
d325 3
a327 1
	nsched = 0;
d329 4
a332 5
again:
/*
	if (scheduler->display)
		scheduler->display();
*/
d334 1
d336 2
d339 3
a341 2
	/* set nsched to the time() of next schedulable envelope */
	backend->next(NULL, &nsched);
d343 3
a345 12
	/* load as many envelopes as possible from disk-queue to
	 * ram-queue until a schedulable envelope is found.
	 */
	if (! rq_done)
		rq_done = backend->setup(curtm, nsched);

	if (rq_done) {
		if (! backend->next(NULL, &nsched))
			goto scheduler_sleep;
		if (curtm < nsched)
			goto scheduler_pause;
	}
d347 1
a347 1
	/* let's do the schedule dance baby ! */
d349 1
a349 1
		if (curtm < nsched)
d355 3
a357 5
	if (rq_done)
		goto scheduler_sleep;

	goto again;

d360 3
a362 6
	nsched = nsched - curtm;

	log_debug("scheduler: nothing to do for the next %lld seconds, zZzZzZ",
	    (long long int) nsched);

	tv.tv_sec = nsched;
a366 1

d368 1
a368 1
	log_debug("scheduler: nothing to schedule, wake me up. zZzZzZ");
d513 1
a513 1
scheduler_message_to_scheduler(u_int32_t msgid)
@


1.3
log
@Lookup queue and scheduler backends by name, rather than enum.
Add a command-line option to specify the backend to use at runtime.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.2 2012/06/17 15:17:08 gilles Exp $	*/
d4 3
a6 1
 * Copyright (c) 2012 Gilles Chehade <gilles@@openbsd.org>
d26 1
d29 1
d31 1
a32 1
#include <fcntl.h>
d34 4
d41 2
d47 13
a59 1
extern struct scheduler_backend scheduler_backend_ramqueue;
d61 6
a66 2
struct scheduler_backend *
scheduler_backend_lookup(const char *name)
d68 98
a165 2
	if (!strcmp(name, "ramqueue"))
		return &scheduler_backend_ramqueue;
d167 39
a205 1
	return NULL;
d209 397
a605 1
scheduler_info(struct scheduler_info *sched, struct envelope *evp)
d607 1
a607 1
	strlcpy(sched->destination, evp->dest.domain, sizeof sched->destination);
d609 3
a611 5
	sched->evpid = evp->id;
	sched->creation = evp->creation;
	sched->lasttry  = evp->lasttry;
	sched->expire   = evp->expire;
	sched->retry    = evp->retry;
@


1.2
log
@- introduce struct scheduler_info and the scheduler_info() function to fill
  a struct scheduler_info given a struct envelope
- adapt the scheduler API and the scheduler_ramqueue backend to use the new
  struct scheduler_info instead of a struct envelope

idea discussed with eric@@ and chl@@, mechanical diff, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: scheduler.c,v 1.1 2012/01/28 11:33:07 gilles Exp $	*/
d40 1
a40 1
scheduler_backend_lookup(enum scheduler_type type)
d42 1
a42 2
	switch (type) {
	case SCHED_RAMQUEUE:
a43 3
	default:
		fatal("unsupported scheduler_backend type");
	}
@


1.1
log
@- introduce the scheduler_backend API
- introduce the scheduler_ramqueue backend
- remove all occurences of ramqueue outside of the ramqueue backend
- teach runner how to use the new API

it is now possible to write custom schedulers !

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 12
@

