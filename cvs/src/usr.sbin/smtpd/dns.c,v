head	1.83;
access;
symbols
	OPENBSD_6_1:1.83.0.8
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.83.0.6
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.81.0.6
	OPENBSD_5_8_BASE:1.81
	OPENBSD_5_7:1.81.0.2
	OPENBSD_5_7_BASE:1.81
	OPENBSD_5_6:1.78.0.4
	OPENBSD_5_6_BASE:1.78
	OPENBSD_5_5:1.70.0.2
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.67.0.2
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.64.0.2
	OPENBSD_5_3_BASE:1.64
	OPENBSD_5_2:1.49.0.2
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.2
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10;
locks; strict;
comment	@ * @;


1.83
date	2015.10.28.07.28.13;	author gilles;	state Exp;
branches;
next	1.82;
commitid	GzciEiSm9Ttr9CU2;

1.82
date	2015.10.17.13.30.47;	author gilles;	state Exp;
branches;
next	1.81;
commitid	ZK0dtk6HFPjEkL9T;

1.81
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	ZBTFreARDSMmzOIV;

1.80
date	2015.01.06.09.32.13;	author gilles;	state Exp;
branches;
next	1.79;
commitid	iPlVTLA0xn5kxpHj;

1.79
date	2014.10.08.07.23.39;	author eric;	state Exp;
branches;
next	1.78;
commitid	gSEliOdfRKO3Ywon;

1.78
date	2014.04.19.12.26.15;	author gilles;	state Exp;
branches;
next	1.77;

1.77
date	2014.04.19.11.41.49;	author gilles;	state Exp;
branches;
next	1.76;

1.76
date	2014.04.04.16.10.42;	author eric;	state Exp;
branches;
next	1.75;

1.75
date	2014.04.03.11.32.02;	author eric;	state Exp;
branches;
next	1.74;

1.74
date	2014.03.26.18.14.22;	author eric;	state Exp;
branches;
next	1.73;

1.73
date	2014.03.25.19.50.17;	author eric;	state Exp;
branches;
next	1.72;

1.72
date	2014.03.25.09.01.11;	author eric;	state Exp;
branches;
next	1.71;

1.71
date	2014.03.14.11.09.45;	author eric;	state Exp;
branches;
next	1.70;

1.70
date	2013.12.26.17.25.32;	author eric;	state Exp;
branches;
next	1.69;

1.69
date	2013.11.18.11.55.41;	author eric;	state Exp;
branches;
next	1.68;

1.68
date	2013.10.26.12.27.59;	author eric;	state Exp;
branches;
next	1.67;

1.67
date	2013.07.12.14.38.34;	author eric;	state Exp;
branches;
next	1.66;

1.66
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.65;

1.65
date	2013.04.30.12.07.21;	author eric;	state Exp;
branches;
next	1.64;

1.64
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.63;

1.63
date	2012.11.24.14.01.51;	author eric;	state Exp;
branches;
next	1.62;

1.62
date	2012.11.23.10.55.25;	author eric;	state Exp;
branches;
next	1.61;

1.61
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.60;

1.60
date	2012.10.08.08.46.24;	author eric;	state Exp;
branches;
next	1.59;

1.59
date	2012.10.03.21.44.35;	author gilles;	state Exp;
branches;
next	1.58;

1.58
date	2012.09.27.17.47.49;	author chl;	state Exp;
branches;
next	1.57;

1.57
date	2012.08.25.10.23.11;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2012.08.21.20.19.46;	author eric;	state Exp;
branches;
next	1.55;

1.55
date	2012.08.21.15.14.40;	author eric;	state Exp;
branches;
next	1.54;

1.54
date	2012.08.21.14.00.59;	author eric;	state Exp;
branches;
next	1.53;

1.53
date	2012.08.19.14.16.58;	author chl;	state Exp;
branches;
next	1.52;

1.52
date	2012.08.18.18.18.23;	author gilles;	state Exp;
branches;
next	1.51;

1.51
date	2012.08.08.17.31.55;	author eric;	state Exp;
branches;
next	1.50;

1.50
date	2012.07.29.17.33.55;	author eric;	state Exp;
branches;
next	1.49;

1.49
date	2012.07.09.12.16.24;	author eric;	state Exp;
branches;
next	1.48;

1.48
date	2012.04.14.13.31.46;	author eric;	state Exp;
branches;
next	1.47;

1.47
date	2012.01.11.21.22.26;	author eric;	state Exp;
branches;
next	1.46;

1.46
date	2012.01.11.17.20.56;	author eric;	state Exp;
branches;
next	1.45;

1.45
date	2011.09.01.19.56.49;	author eric;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.20.10.22.54;	author eric;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.03.17.48.40;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2011.05.06.19.21.43;	author eric;	state Exp;
branches;
next	1.41;

1.41
date	2011.05.01.12.57.11;	author eric;	state Exp;
branches;
next	1.40;

1.40
date	2011.04.17.13.36.07;	author gilles;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.02.16.40.19;	author eric;	state Exp;
branches;
next	1.38;

1.38
date	2011.03.31.10.40.59;	author eric;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.29.20.43.51;	author eric;	state Exp;
branches;
next	1.36;

1.36
date	2011.03.29.08.14.12;	author eric;	state Exp;
branches;
next	1.35;

1.35
date	2011.03.27.18.08.21;	author eric;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.26.21.40.14;	author eric;	state Exp;
branches;
next	1.33;

1.33
date	2011.03.26.14.38.14;	author eric;	state Exp;
branches;
next	1.32;

1.32
date	2011.03.26.10.54.22;	author eric;	state Exp;
branches;
next	1.31;

1.31
date	2011.03.23.20.38.56;	author eric;	state Exp;
branches;
next	1.30;

1.30
date	2011.03.09.00.35.42;	author todd;	state Exp;
branches;
next	1.29;

1.29
date	2011.03.09.00.34.01;	author todd;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.19.11.24.17;	author gilles;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.12.22.29.39;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2010.11.29.15.25.55;	author gilles;	state Exp;
branches;
next	1.25;

1.25
date	2010.11.28.14.02.46;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.08.13.32.13;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.29.03.47.24;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.02.19.16.53;	author chl;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.14.18.49.25;	author chl;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.11.16.55.18;	author jacekm;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.05.12.11.53;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.05.12.05.47;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.03.08.19.13;	author jacekm;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.08.00.02.22;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.06.04.14.21;	author pyr;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.05.20.43.57;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.01.13.20.56;	author jacekm;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.09.17.04.55;	author jacekm;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.15.13.12.19;	author jacekm;	state Exp;
branches;
next	1.8;

1.8
date	2009.02.15.09.58.31;	author jacekm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.05.19.09.59;	author gilles;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.01.22.54.08;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.25.23.03.24;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.10.03.54.08;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.83
log
@dns_lookup_host() needs to remove brackets and IPv6: prefix when receiving
a text representation otherwise getaddrinfo_async() will choke

ok eric@@
@
text
@/*	$OpenBSD: dns.c,v 1.82 2015/10/17 13:30:47 gilles Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 * Copyright (c) 2009 Jacek Masiulaniec <jacekm@@dobremiasto.net>
 * Copyright (c) 2011-2014 Eric Faurot <eric@@faurot.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/tree.h>
#include <sys/queue.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>

#include <asr.h>
#include <event.h>
#include <imsg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "smtpd.h"
#include "log.h"

struct dns_lookup {
	struct dns_session	*session;
	int			 preference;
};

struct dns_session {
	struct mproc		*p;
	uint64_t		 reqid;
	int			 type;
	char			 name[HOST_NAME_MAX+1];
	size_t			 mxfound;
	int			 error;
	int			 refcount;
};

static void dns_lookup_host(struct dns_session *, const char *, int);
static void dns_dispatch_host(struct asr_result *, void *);
static void dns_dispatch_ptr(struct asr_result *, void *);
static void dns_dispatch_mx(struct asr_result *, void *);
static void dns_dispatch_mx_preference(struct asr_result *, void *);

struct unpack {
	const char	*buf;
	size_t		 len;
	size_t		 offset;
	const char	*err;
};

struct dns_header {
	uint16_t	id;
	uint16_t	flags;
	uint16_t	qdcount;
	uint16_t	ancount;
	uint16_t	nscount;
	uint16_t	arcount;
};

struct dns_query {
	char		q_dname[MAXDNAME];
	uint16_t	q_type;
	uint16_t	q_class;
};

struct dns_rr {
	char		rr_dname[MAXDNAME];
	uint16_t	rr_type;
	uint16_t	rr_class;
	uint32_t	rr_ttl;
	union {
		struct {
			char	cname[MAXDNAME];
		} cname;
		struct {
			uint16_t	preference;
			char		exchange[MAXDNAME];
		} mx;
		struct {
			char	nsname[MAXDNAME];
		} ns;
		struct {
			char	ptrname[MAXDNAME];
		} ptr;
		struct {
			char		mname[MAXDNAME];
			char		rname[MAXDNAME];
			uint32_t	serial;
			uint32_t	refresh;
			uint32_t	retry;
			uint32_t	expire;
			uint32_t	minimum;
		} soa;
		struct {
			struct in_addr	addr;
		} in_a;
		struct {
			struct in6_addr	addr6;
		} in_aaaa;
		struct {
			uint16_t	 rdlen;
			const void	*rdata;
		} other;
	} rr;
};

static char *print_dname(const char *, char *, size_t);
static ssize_t dname_expand(const unsigned char *, size_t, size_t, size_t *,
    char *, size_t);
static int unpack_data(struct unpack *, void *, size_t);
static int unpack_u16(struct unpack *, uint16_t *);
static int unpack_u32(struct unpack *, uint32_t *);
static int unpack_inaddr(struct unpack *, struct in_addr *);
static int unpack_in6addr(struct unpack *, struct in6_addr *);
static int unpack_dname(struct unpack *, char *, size_t);
static void unpack_init(struct unpack *, const char *, size_t);
static int unpack_header(struct unpack *, struct dns_header *);
static int unpack_query(struct unpack *, struct dns_query *);
static int unpack_rr(struct unpack *, struct dns_rr *);


static int
domainname_is_addr(const char *s, struct sockaddr *sa, socklen_t *sl)
{
	struct addrinfo	hints, *res;
	socklen_t	sl2;
	size_t		l;
	char		buf[SMTPD_MAXDOMAINPARTSIZE];
	int		i6, error;

	if (*s != '[')
		return (0);

	i6 = (strncasecmp("[IPv6:", s, 6) == 0);
	s += i6 ? 6 : 1;

	l = strlcpy(buf, s, sizeof(buf));
	if (l >= sizeof(buf) || l == 0 || buf[l - 1] != ']')
		return (0);

	buf[l - 1] = '\0';
	memset(&hints, 0, sizeof(hints));
	hints.ai_flags = AI_NUMERICHOST;
	hints.ai_socktype = SOCK_STREAM;
	if (i6)
		hints.ai_family = AF_INET6;

	res = NULL;
	if ((error = getaddrinfo(buf, NULL, &hints, &res))) {
		log_warnx("getaddrinfo: %s", gai_strerror(error));
	}

	if (!res)
		return (0);

	if (sa && sl) {
		sl2 = *sl;
		if (sl2 > res->ai_addrlen)
			sl2 = res->ai_addrlen;
		memmove(sa, res->ai_addr, sl2);
		*sl = res->ai_addrlen;
	}

	freeaddrinfo(res);
	return (1);
}

void
dns_imsg(struct mproc *p, struct imsg *imsg)
{
	struct sockaddr_storage	 ss;
	struct dns_session	*s;
	struct sockaddr		*sa;
	struct asr_query	*as;
	struct msg		 m;
	const char		*domain, *mx, *host;
	socklen_t		 sl;

	s = xcalloc(1, sizeof *s, "dns_imsg");
	s->type = imsg->hdr.type;
	s->p = p;

	m_msg(&m, imsg);
	m_get_id(&m, &s->reqid);

	switch (s->type) {

	case IMSG_MTA_DNS_HOST:
		m_get_string(&m, &host);
		m_end(&m);
		dns_lookup_host(s, host, -1);
		return;

	case IMSG_MTA_DNS_PTR:
	case IMSG_SMTP_DNS_PTR:
		sa = (struct sockaddr *)&ss;
		m_get_sockaddr(&m, sa);
		m_end(&m);
		as = getnameinfo_async(sa, sa->sa_len, s->name, sizeof(s->name),
		    NULL, 0, 0, NULL);
		event_asr_run(as, dns_dispatch_ptr, s);
		return;

	case IMSG_MTA_DNS_MX:
		m_get_string(&m, &domain);
		m_end(&m);
		(void)strlcpy(s->name, domain, sizeof(s->name));

		sa = (struct sockaddr *)&ss;
		sl = sizeof(ss);

		if (domainname_is_addr(domain, sa, &sl)) {
			m_create(s->p, IMSG_MTA_DNS_HOST, 0, 0, -1);
			m_add_id(s->p, s->reqid);
			m_add_sockaddr(s->p, sa);
			m_add_int(s->p, -1);
			m_close(s->p);

			m_create(s->p, IMSG_MTA_DNS_HOST_END, 0, 0, -1);
			m_add_id(s->p, s->reqid);
			m_add_int(s->p, DNS_OK);
			m_close(s->p);
			free(s);
			return;
		}

		as = res_query_async(s->name, C_IN, T_MX, NULL);
		if (as == NULL) {
			log_warn("warn: req_query_async: %s", s->name);
			m_create(s->p, IMSG_MTA_DNS_HOST_END, 0, 0, -1);
			m_add_id(s->p, s->reqid);
			m_add_int(s->p, DNS_EINVAL);
			m_close(s->p);
			free(s);
			return;
		}

		event_asr_run(as, dns_dispatch_mx, s);
		return;

	case IMSG_MTA_DNS_MX_PREFERENCE:
		m_get_string(&m, &domain);
		m_get_string(&m, &mx);
		m_end(&m);
		(void)strlcpy(s->name, mx, sizeof(s->name));

		as = res_query_async(domain, C_IN, T_MX, NULL);
		if (as == NULL) {
			m_create(s->p, IMSG_MTA_DNS_MX_PREFERENCE, 0, 0, -1);
			m_add_id(s->p, s->reqid);
			m_add_int(s->p, DNS_ENOTFOUND);
			m_close(s->p);
			free(s);
			return;
		}

		event_asr_run(as, dns_dispatch_mx_preference, s);
		return;

	default:
		log_warnx("warn: bad dns request %d", s->type);
		fatal(NULL);
	}
}

static void
dns_dispatch_host(struct asr_result *ar, void *arg)
{
	struct dns_session	*s;
	struct dns_lookup	*lookup = arg;
	struct addrinfo		*ai;

	s = lookup->session;

	for (ai = ar->ar_addrinfo; ai; ai = ai->ai_next) {
		s->mxfound++;
		m_create(s->p, IMSG_MTA_DNS_HOST, 0, 0, -1);
		m_add_id(s->p, s->reqid);
		m_add_sockaddr(s->p, ai->ai_addr);
		m_add_int(s->p, lookup->preference);
		m_close(s->p);
	}
	free(lookup);
	if (ar->ar_addrinfo)
		freeaddrinfo(ar->ar_addrinfo);

	if (ar->ar_gai_errno)
		s->error = ar->ar_gai_errno;

	if (--s->refcount)
		return;

	m_create(s->p, IMSG_MTA_DNS_HOST_END, 0, 0, -1);
	m_add_id(s->p, s->reqid);
	m_add_int(s->p, s->mxfound ? DNS_OK : DNS_ENOTFOUND);
	m_close(s->p);
	free(s);
}

static void
dns_dispatch_ptr(struct asr_result *ar, void *arg)
{
	struct dns_session	*s = arg;

	/* The error code could be more precise, but we don't currently care */
	m_create(s->p,  s->type, 0, 0, -1);
	m_add_id(s->p, s->reqid);
	m_add_int(s->p, ar->ar_gai_errno ? DNS_ENOTFOUND : DNS_OK);
	if (ar->ar_gai_errno == 0)
		m_add_string(s->p, s->name);
	m_close(s->p);
	free(s);
}

static void
dns_dispatch_mx(struct asr_result *ar, void *arg)
{
	struct dns_session	*s = arg;
	struct unpack		 pack;
	struct dns_header	 h;
	struct dns_query	 q;
	struct dns_rr		 rr;
	char			 buf[512];
	size_t			 found;

	if (ar->ar_h_errno && ar->ar_h_errno != NO_DATA) {

		m_create(s->p,  IMSG_MTA_DNS_HOST_END, 0, 0, -1);
		m_add_id(s->p, s->reqid);
		if (ar->ar_rcode == NXDOMAIN)
			m_add_int(s->p, DNS_ENONAME);
		else if (ar->ar_h_errno == NO_RECOVERY)
			m_add_int(s->p, DNS_EINVAL);
		else
			m_add_int(s->p, DNS_RETRY);
		m_close(s->p);
		free(s);
		free(ar->ar_data);
		return;
	}

	unpack_init(&pack, ar->ar_data, ar->ar_datalen);
	unpack_header(&pack, &h);
	unpack_query(&pack, &q);

	found = 0;
	for (; h.ancount; h.ancount--) {
		unpack_rr(&pack, &rr);
		if (rr.rr_type != T_MX)
			continue;
		print_dname(rr.rr.mx.exchange, buf, sizeof(buf));
		buf[strlen(buf) - 1] = '\0';
		dns_lookup_host(s, buf, rr.rr.mx.preference);
		found++;
	}
	free(ar->ar_data);

	/* fallback to host if no MX is found. */
	if (found == 0)
		dns_lookup_host(s, s->name, 0);
}

static void
dns_dispatch_mx_preference(struct asr_result *ar, void *arg)
{
	struct dns_session	*s = arg;
	struct unpack		 pack;
	struct dns_header	 h;
	struct dns_query	 q;
	struct dns_rr		 rr;
	char			 buf[512];
	int			 error;

	if (ar->ar_h_errno) {
		if (ar->ar_rcode == NXDOMAIN)
			error = DNS_ENONAME;
		else if (ar->ar_h_errno == NO_RECOVERY
		    || ar->ar_h_errno == NO_DATA)
			error = DNS_EINVAL;
		else
			error = DNS_RETRY;
	}
	else {
		error = DNS_ENOTFOUND;
		unpack_init(&pack, ar->ar_data, ar->ar_datalen);
		unpack_header(&pack, &h);
		unpack_query(&pack, &q);
		for (; h.ancount; h.ancount--) {
			unpack_rr(&pack, &rr);
			if (rr.rr_type != T_MX)
				continue;
			print_dname(rr.rr.mx.exchange, buf, sizeof(buf));
			buf[strlen(buf) - 1] = '\0';
			if (!strcasecmp(s->name, buf)) {
				error = DNS_OK;
				break;
			}
		}
	}

	free(ar->ar_data);

	m_create(s->p, IMSG_MTA_DNS_MX_PREFERENCE, 0, 0, -1);
	m_add_id(s->p, s->reqid);
	m_add_int(s->p, error);
	if (error == DNS_OK)
		m_add_int(s->p, rr.rr.mx.preference);
	m_close(s->p);
	free(s);
}

static void
dns_lookup_host(struct dns_session *s, const char *host, int preference)
{
	struct dns_lookup	*lookup;
	struct addrinfo		 hints;
	char			 hostcopy[HOST_NAME_MAX+1];
	char			*p;
	void			*as;

	lookup = xcalloc(1, sizeof *lookup, "dns_lookup_host");
	lookup->preference = preference;
	lookup->session = s;
	s->refcount++;

	if (*host == '[') {
		if (strncasecmp("[IPv6:", host, 6) == 0)
			host += 6;
		else
			host += 1;
		(void)strlcpy(hostcopy, host, sizeof hostcopy);
		p = strchr(hostcopy, ']');
		if (p)
			*p = 0;
		host = hostcopy;
	}

	memset(&hints, 0, sizeof(hints));
	hints.ai_flags = AI_ADDRCONFIG;
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	as = getaddrinfo_async(host, NULL, &hints, NULL);
	event_asr_run(as, dns_dispatch_host, lookup);
}

static char *
print_dname(const char *_dname, char *buf, size_t max)
{
	const unsigned char *dname = _dname;
	char    *res;
	size_t   left, n, count;

	if (_dname[0] == 0) {
		(void)strlcpy(buf, ".", max);
		return buf;
	}

	res = buf;
	left = max - 1;
	for (n = 0; dname[0] && left; n += dname[0]) {
		count = (dname[0] < (left - 1)) ? dname[0] : (left - 1);
		memmove(buf, dname + 1, count);
		dname += dname[0] + 1;
		left -= count;
		buf += count;
		if (left) {
			left -= 1;
			*buf++ = '.';
		}
	}
	buf[0] = 0;

	return (res);
}

static ssize_t
dname_expand(const unsigned char *data, size_t len, size_t offset,
    size_t *newoffset, char *dst, size_t max)
{
	size_t		 n, count, end, ptr, start;
	ssize_t		 res;

	if (offset >= len)
		return (-1);

	res = 0;
	end = start = offset;

	for (; (n = data[offset]); ) {
		if ((n & 0xc0) == 0xc0) {
			if (offset + 2 > len)
				return (-1);
			ptr = 256 * (n & ~0xc0) + data[offset + 1];
			if (ptr >= start)
				return (-1);
			if (end < offset + 2)
				end = offset + 2;
			offset = start = ptr;
			continue;
		}
		if (offset + n + 1 > len)
			return (-1);

		/* copy n + at offset+1 */
		if (dst != NULL && max != 0) {
			count = (max < n + 1) ? (max) : (n + 1);
			memmove(dst, data + offset, count);
			dst += count;
			max -= count;
		}
		res += n + 1;
		offset += n + 1;
		if (end < offset)
			end = offset;
	}
	if (end < offset + 1)
		end = offset + 1;

	if (dst != NULL && max != 0)
		dst[0] = 0;
	if (newoffset)
		*newoffset = end;
	return (res + 1);
}

void
unpack_init(struct unpack *unpack, const char *buf, size_t len)
{
	unpack->buf = buf;
	unpack->len = len;
	unpack->offset = 0;
	unpack->err = NULL;
}

static int
unpack_data(struct unpack *p, void *data, size_t len)
{
	if (p->err)
		return (-1);

	if (p->len - p->offset < len) {
		p->err = "too short";
		return (-1);
	}

	memmove(data, p->buf + p->offset, len);
	p->offset += len;

	return (0);
}

static int
unpack_u16(struct unpack *p, uint16_t *u16)
{
	if (unpack_data(p, u16, 2) == -1)
		return (-1);

	*u16 = ntohs(*u16);

	return (0);
}

static int
unpack_u32(struct unpack *p, uint32_t *u32)
{
	if (unpack_data(p, u32, 4) == -1)
		return (-1);

	*u32 = ntohl(*u32);

	return (0);
}

static int
unpack_inaddr(struct unpack *p, struct in_addr *a)
{
	return (unpack_data(p, a, 4));
}

static int
unpack_in6addr(struct unpack *p, struct in6_addr *a6)
{
	return (unpack_data(p, a6, 16));
}

static int
unpack_dname(struct unpack *p, char *dst, size_t max)
{
	ssize_t e;

	if (p->err)
		return (-1);

	e = dname_expand(p->buf, p->len, p->offset, &p->offset, dst, max);
	if (e == -1) {
		p->err = "bad domain name";
		return (-1);
	}
	if (e < 0 || e > MAXDNAME) {
		p->err = "domain name too long";
		return (-1);
	}

	return (0);
}

static int
unpack_header(struct unpack *p, struct dns_header *h)
{
	if (unpack_data(p, h, HFIXEDSZ) == -1)
		return (-1);

	h->flags = ntohs(h->flags);
	h->qdcount = ntohs(h->qdcount);
	h->ancount = ntohs(h->ancount);
	h->nscount = ntohs(h->nscount);
	h->arcount = ntohs(h->arcount);

	return (0);
}

static int
unpack_query(struct unpack *p, struct dns_query *q)
{
	unpack_dname(p, q->q_dname, sizeof(q->q_dname));
	unpack_u16(p, &q->q_type);
	unpack_u16(p, &q->q_class);

	return (p->err) ? (-1) : (0);
}

static int
unpack_rr(struct unpack *p, struct dns_rr *rr)
{
	uint16_t	rdlen;
	size_t		save_offset;

	unpack_dname(p, rr->rr_dname, sizeof(rr->rr_dname));
	unpack_u16(p, &rr->rr_type);
	unpack_u16(p, &rr->rr_class);
	unpack_u32(p, &rr->rr_ttl);
	unpack_u16(p, &rdlen);

	if (p->err)
		return (-1);

	if (p->len - p->offset < rdlen) {
		p->err = "too short";
		return (-1);
	}

	save_offset = p->offset;

	switch (rr->rr_type) {

	case T_CNAME:
		unpack_dname(p, rr->rr.cname.cname, sizeof(rr->rr.cname.cname));
		break;

	case T_MX:
		unpack_u16(p, &rr->rr.mx.preference);
		unpack_dname(p, rr->rr.mx.exchange, sizeof(rr->rr.mx.exchange));
		break;

	case T_NS:
		unpack_dname(p, rr->rr.ns.nsname, sizeof(rr->rr.ns.nsname));
		break;

	case T_PTR:
		unpack_dname(p, rr->rr.ptr.ptrname, sizeof(rr->rr.ptr.ptrname));
		break;

	case T_SOA:
		unpack_dname(p, rr->rr.soa.mname, sizeof(rr->rr.soa.mname));
		unpack_dname(p, rr->rr.soa.rname, sizeof(rr->rr.soa.rname));
		unpack_u32(p, &rr->rr.soa.serial);
		unpack_u32(p, &rr->rr.soa.refresh);
		unpack_u32(p, &rr->rr.soa.retry);
		unpack_u32(p, &rr->rr.soa.expire);
		unpack_u32(p, &rr->rr.soa.minimum);
		break;

	case T_A:
		if (rr->rr_class != C_IN)
			goto other;
		unpack_inaddr(p, &rr->rr.in_a.addr);
		break;

	case T_AAAA:
		if (rr->rr_class != C_IN)
			goto other;
		unpack_in6addr(p, &rr->rr.in_aaaa.addr6);
		break;
	default:
	other:
		rr->rr.other.rdata = p->buf + p->offset;
		rr->rr.other.rdlen = rdlen;
		p->offset += rdlen;
	}

	if (p->err)
		return (-1);

	/* make sure that the advertised rdlen is really ok */
	if (p->offset - save_offset != rdlen)
		p->err = "bad dlen";

	return (p->err) ? (-1) : (0);
}
@


1.82
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.81 2015/01/20 17:37:54 deraadt Exp $	*/
d437 2
d445 12
@


1.81
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.80 2015/01/06 09:32:13 gilles Exp $	*/
a265 3

		sa = (struct sockaddr *)&ss;
		sl = sizeof(ss);
@


1.80
log
@fix whitespace and indentation, by Kyle Milz
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.79 2014/10/08 07:23:39 eric Exp $	*/
d38 1
d52 1
a52 1
	char			 name[SMTPD_MAXHOSTNAMELEN];
@


1.79
log
@restrict address lookups to configured address families.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.78 2014/04/19 12:26:15 gilles Exp $	*/
d247 1
a247 1
		if (as ==  NULL) {
d344 1
a344 1
	struct dns_rr	 rr;
@


1.78
log
@(void) cast this strlcpy(), it cannot truncate
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.77 2014/04/19 11:41:49 gilles Exp $	*/
d447 1
@


1.77
log
@these strlcpy can't truncate, the copy is from a buffer to a buffer of same
size and the first buffer handles the truncation already
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.76 2014/04/04 16:10:42 eric Exp $	*/
d461 1
a461 1
		strlcpy(buf, ".", max);
@


1.76
log
@Merge the mda, mta and smtp processes into a single unprivileged
process managing message reception, delivery and transfer.  Mostly
mechanical, but very intrusive as it required to rewamp all IMSG to
fix ambiguities.

with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d226 1
a226 1
		strlcpy(s->name, domain, sizeof(s->name));
d264 1
a264 1
		strlcpy(s->name, mx, sizeof(s->name));
@


1.75
log
@use asr helpers after libevent update.
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.74 2014/03/26 18:14:22 eric Exp $	*/
a140 37
void
dns_query_host(uint64_t id, const char *host)
{
	m_create(p_lka,  IMSG_DNS_HOST, 0, 0, -1);
	m_add_id(p_lka, id);
	m_add_string(p_lka, host);
	m_close(p_lka);
}

void
dns_query_ptr(uint64_t id, const struct sockaddr *sa)
{
	m_create(p_lka,  IMSG_DNS_PTR, 0, 0, -1);
	m_add_id(p_lka, id);
	m_add_sockaddr(p_lka, sa);
	m_close(p_lka);
}

void
dns_query_mx(uint64_t id, const char *domain)
{
	m_create(p_lka,  IMSG_DNS_MX, 0, 0, -1);
	m_add_id(p_lka, id);
	m_add_string(p_lka, domain);
	m_close(p_lka);
}

void
dns_query_mx_preference(uint64_t id, const char *domain, const char *mx)
{
	m_create(p_lka,  IMSG_DNS_MX_PREFERENCE, 0, 0, -1);
	m_add_id(p_lka, id);
	m_add_string(p_lka, domain);
	m_add_string(p_lka, mx);
	m_close(p_lka);
}

d207 1
a207 1
	case IMSG_DNS_HOST:
d213 2
a214 1
	case IMSG_DNS_PTR:
d223 1
a223 1
	case IMSG_DNS_MX:
d232 1
a232 1
			m_create(s->p, IMSG_DNS_HOST, 0, 0, -1);
d238 1
a238 1
			m_create(s->p, IMSG_DNS_HOST_END, 0, 0, -1);
d249 1
a249 1
			m_create(s->p, IMSG_DNS_HOST_END, 0, 0, -1);
d260 1
a260 1
	case IMSG_DNS_MX_PREFERENCE:
d271 1
a271 1
			m_create(s->p, IMSG_DNS_MX_PREFERENCE, 0, 0, -1);
d299 1
a299 1
		m_create(s->p, IMSG_DNS_HOST, 0, 0, -1);
d315 1
a315 1
	m_create(s->p, IMSG_DNS_HOST_END, 0, 0, -1);
d328 1
a328 1
	m_create(s->p,  IMSG_DNS_PTR, 0, 0, -1);
d350 1
a350 1
		m_create(s->p,  IMSG_DNS_HOST_END, 0, 0, -1);
d425 1
a425 1
	m_create(s->p, IMSG_DNS_MX_PREFERENCE, 0, 0, -1);
@


1.74
log
@asr API is now public
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.73 2014/03/25 19:50:17 eric Exp $	*/
a56 4
struct async_event;
struct async_event * async_run_event(struct asr_query *,
	void (*)(struct asr_result *, void *), void *);

d256 1
a256 1
		async_run_event(as, dns_dispatch_ptr, s);
d293 1
a293 1
		async_run_event(as, dns_dispatch_mx, s);
d315 1
a315 1
		async_run_event(as, dns_dispatch_mx_preference, s);
d486 1
a486 54
	async_run_event(as, dns_dispatch_host, lookup);
}

/* Generic libevent glue for asr */

struct async_event {
	struct asr_query *async;
	struct event	 ev;
	void		(*callback)(struct asr_result *, void *);
	void		*arg;
};

static void async_event_dispatch(int, short, void *);

struct async_event *
async_run_event(struct asr_query * async,
    void (*cb)(struct asr_result *, void *), void *arg)
{
	struct async_event	*aev;
	struct timeval		 tv;

	aev = calloc(1, sizeof *aev);
	if (aev == NULL)
		return (NULL);
	aev->async = async;
	aev->callback = cb;
	aev->arg = arg;
	tv.tv_sec = 0;
	tv.tv_usec = 1;
	evtimer_set(&aev->ev, async_event_dispatch, aev);
	evtimer_add(&aev->ev, &tv);
	return (aev);
}

static void
async_event_dispatch(int fd, short ev, void *arg)
{
	struct async_event	*aev = arg;
	struct asr_result	 ar;
	struct timeval		 tv;

	event_del(&aev->ev);

	if (asr_run(aev->async, &ar) == 0) {
		event_set(&aev->ev, ar.ar_fd,
		  ar.ar_cond == ASR_WANT_READ ? EV_READ : EV_WRITE,
		  async_event_dispatch, aev);
		tv.tv_sec = ar.ar_timeout / 1000;
		tv.tv_usec = (ar.ar_timeout % 1000) * 1000;
		event_add(&aev->ev, &tv);
	} else {
		aev->callback(&ar, aev->arg);
		free(aev);
	}
@


1.73
log
@update after asr API update
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.72 2014/03/25 09:01:11 eric Exp $	*/
d30 1
d32 1
a38 1
#include "asr.h"
@


1.72
log
@Integrate necessary dns packet parsing helpers from asr.
They are not supposed to be exposed.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.71 2014/03/14 11:09:45 eric Exp $	*/
d57 2
a58 2
struct async_event * async_run_event(struct async *,
	void (*)(int, struct async_res *, void *), void *);
d61 4
a64 4
static void dns_dispatch_host(int, struct async_res *, void *);
static void dns_dispatch_ptr(int, struct async_res *, void *);
static void dns_dispatch_mx(int, struct async_res *, void *);
static void dns_dispatch_mx_preference(int, struct async_res *, void *);
d233 1
a233 1
	struct async		*as;
d328 1
a328 1
dns_dispatch_host(int ev, struct async_res *ar, void *arg)
d362 1
a362 1
dns_dispatch_ptr(int ev, struct async_res *ar, void *arg)
d377 1
a377 1
dns_dispatch_mx(int ev, struct async_res *ar, void *arg)
d380 1
a380 1
	struct unpack	 pack;
d425 1
a425 1
dns_dispatch_mx_preference(int ev, struct async_res *ar, void *arg)
d478 1
a478 1
	struct async		*as;
d495 1
a495 1
	struct async	*async;
d497 1
a497 1
	void		(*callback)(int, struct async_res *, void *);
d504 2
a505 2
async_run_event(struct async * async,
    void (*cb)(int, struct async_res *, void *), void *arg)
d527 1
a527 2
	struct async_res	 ar;
	int			 r;
d530 1
a530 2
	while ((r = asr_async_run(aev->async, &ar)) == ASYNC_YIELD)
		aev->callback(r, &ar, aev->arg);
d532 1
a532 2
	event_del(&aev->ev);
	if (r == ASYNC_COND) {
d534 2
a535 2
			  ar.ar_cond == ASYNC_READ ? EV_READ : EV_WRITE,
			  async_event_dispatch, aev);
d539 2
a540 2
	} else { /* ASYNC_DONE */
		aev->callback(r, &ar, aev->arg);
@


1.71
log
@field rename
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.70 2013/12/26 17:25:32 eric Exp $	*/
d6 1
a6 1
 * Copyright (c) 2011-2012 Eric Faurot <eric@@faurot.net>
a37 1
#include "asr_private.h"
d66 77
a142 1
#define print_dname(a,b,c) asr_strdname(a, b, c)
d380 4
a383 4
	struct asr_unpack	 pack;
	struct asr_dns_header	 h;
	struct asr_dns_query	 q;
	struct asr_dns_rr	 rr;
d403 3
a405 3
	asr_unpack_init(&pack, ar->ar_data, ar->ar_datalen);
	asr_unpack_header(&pack, &h);
	asr_unpack_query(&pack, &q);
d409 1
a409 1
		asr_unpack_rr(&pack, &rr);
d428 4
a431 4
	struct asr_unpack	 pack;
	struct asr_dns_header	 h;
	struct asr_dns_query	 q;
	struct asr_dns_rr	 rr;
d446 3
a448 3
		asr_unpack_init(&pack, ar->ar_data, ar->ar_datalen);
		asr_unpack_header(&pack, &h);
		asr_unpack_query(&pack, &q);
d450 1
a450 1
			asr_unpack_rr(&pack, &rr);
d546 265
@


1.70
log
@bcopy -> memmove
bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d305 4
a308 4
	struct unpack		 pack;
	struct header		 h;
	struct query		 q;
	struct rr		 rr;
d353 4
a356 4
	struct unpack		 pack;
	struct header		 h;
	struct query		 q;
	struct rr		 rr;
@


1.69
log
@When looking up a MX, parse the address if the domain is a "[ipaddr]" string.
@
text
@d126 1
a126 1
	bzero(&hints, sizeof(hints));
@


1.68
log
@%i -> %d in format strings
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.67 2013/07/12 14:38:34 eric Exp $	*/
d106 46
d161 1
d191 19
d211 10
d229 4
d234 9
@


1.67
log
@update after asr changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.66 2013/05/24 17:03:14 eric Exp $	*/
d158 1
a158 1
		log_warnx("warn: bad dns request %i", s->type);
@


1.66
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.64 2013/01/26 09:37:23 gilles Exp $	*/
d239 3
a241 3
	unpack_init(&pack, ar->ar_data, ar->ar_datalen);
	unpack_header(&pack, &h);
	unpack_query(&pack, &q);
d245 1
a245 1
		unpack_rr(&pack, &rr);
d282 3
a284 3
		unpack_init(&pack, ar->ar_data, ar->ar_datalen);
		unpack_header(&pack, &h);
		unpack_query(&pack, &q);
d286 1
a286 1
			unpack_rr(&pack, &rr);
d367 1
a367 1
	while ((r = async_run(aev->async, &ar)) == ASYNC_YIELD)
@


1.65
log
@remove params after API change.
@
text
@d51 1
a51 1
	char			 name[MAXHOSTNAMELEN];
d72 1
a72 1
	m_create(p_lka,  IMSG_DNS_HOST, 0, 0, -1, 128);
d81 1
a81 1
	m_create(p_lka,  IMSG_DNS_PTR, 0, 0, -1, 128);
d90 1
a90 1
	m_create(p_lka,  IMSG_DNS_MX, 0, 0, -1, 128);
d99 1
a99 1
	m_create(p_lka,  IMSG_DNS_MX_PREFERENCE, 0, 0, -1, 128);
d174 1
a174 1
		m_create(s->p, IMSG_DNS_HOST, 0, 0, -1, 128);
d190 1
a190 1
	m_create(s->p, IMSG_DNS_HOST_END, 0, 0, -1, 24);
d203 1
a203 1
	m_create(s->p,  IMSG_DNS_PTR, 0, 0, -1, 512);
d225 1
a225 1
		m_create(s->p,  IMSG_DNS_HOST_END, 0, 0, -1, 24);
d300 1
a300 1
	m_create(s->p, IMSG_DNS_MX_PREFERENCE, 0, 0, -1, 36);
@


1.64
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.61 2012/11/12 14:58:53 eric Exp $	*/
d144 1
a144 1
		as = res_query_async(s->name, C_IN, T_MX, NULL, 0, NULL);
d153 1
a153 1
		as = res_query_async(domain, C_IN, T_MX, NULL, 0, NULL);
@


1.63
log
@fix after asr update
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.62 2012/11/23 10:55:25 eric Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d6 1
a6 1
 * Copyright (c) 2011 Eric Faurot <eric@@faurot.net>
d42 3
a44 5

struct mx {
	TAILQ_ENTRY(mx)	 entry;
	char		*host;
	int		 preference;
d47 8
a54 8
struct dnssession {
	uint64_t			 id;
	struct dns			 query;
	struct event			 ev;
	struct async			*as;
	int				 preference;
	size_t				 mxfound;
	TAILQ_HEAD(, mx)		 mx;
d57 9
a65 10
static struct dnssession *dnssession_init(struct dns *);
static void dnssession_destroy(struct dnssession *);
static void dnssession_mx_insert(struct dnssession *, const char *, int);
static void dns_asr_event_set(struct dnssession *, struct async_res *);
static void dns_asr_handler(int, short, void *);
static int  dns_asr_error(int);
static void dns_asr_dispatch_host(struct dnssession *);
static void dns_asr_dispatch_mx(struct dnssession *);
static void dns_asr_dispatch_cname(struct dnssession *);
static void dns_reply(struct dns *, int);
d69 8
a76 3
/*
 * User interface.
 */
d79 1
a79 1
dns_query_host(char *host, int port, uint64_t id)
d81 4
a84 9
	struct dns	 query;

	bzero(&query, sizeof(query));
	strlcpy(query.host, host, sizeof(query.host));
	query.port = port;
	query.id = id;

	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_DNS_HOST, 0, 0, -1,
	    &query, sizeof(query));
d88 1
a88 1
dns_query_mx(char *host, char *backup, int port, uint64_t id)
d90 4
a93 11
	struct dns	 query;

	bzero(&query, sizeof(query));
	strlcpy(query.host, host, sizeof(query.host));
	if (backup)
		strlcpy(query.backup, backup, sizeof(query.backup));
	query.port = port;
	query.id = id;

	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_DNS_MX, 0, 0, -1,
	    &query, sizeof(query));
d97 1
a97 1
dns_query_ptr(struct sockaddr_storage *ss, uint64_t id)
d99 5
a103 8
	struct dns	 query;

	bzero(&query, sizeof(query));
	query.ss = *ss;
	query.id = id;

	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_DNS_PTR, 0, 0, -1,
	    &query, sizeof(query));
a105 1
/* LKA interface */
d107 1
a107 1
dns_async(struct imsgev *asker, int type, struct dns *query)
d109 13
a121 1
	struct dnssession *s;
d123 1
a123 3
	query->type  = type;
	query->asker = asker;
	s = dnssession_init(query);
a124 1
	switch (type) {
d126 3
a128 15
		log_debug("debug: dns: lookup host \"%s\"", query->host);
		if (sockaddr_from_str((struct sockaddr*)&query->ss, PF_UNSPEC,
		    query->host) == 0) {
			log_debug("debug: dns:  \"%s\" is an IP address",
			    query->host);
			query->error = DNS_OK;
			dns_reply(query, IMSG_DNS_HOST);
			dns_reply(query, IMSG_DNS_HOST_END);
			dnssession_destroy(s);
			return;
		}
		dnssession_mx_insert(s, query->host, 0);
		stat_increment("lka.session.host", 1);
		query->error = DNS_ENOTFOUND; /* override later */
		dns_asr_dispatch_host(s);
d130 1
d132 6
a137 9
		s->as = getnameinfo_async((struct sockaddr*)&query->ss,
		    query->ss.ss_len,
		    s->query.host, sizeof(s->query.host), NULL, 0, 0, NULL);
		stat_increment("lka.session.cname", 1);
		if (s->as == NULL) {
			log_debug("debug: dns_async: asr_query_cname error");
			break;
		}
		dns_asr_dispatch_cname(s);
d139 1
d141 14
a154 8
		log_debug("debug: dns: lookup mx \"%s\"", query->host);
		s->as = res_query_async(query->host, C_IN, T_MX, NULL, 0, NULL);
		stat_increment("lka.session.mx", 1);
		if (s->as == NULL) {
			log_debug("debug: dns_async: asr_query_dns error");
			break;
		}
		dns_asr_dispatch_mx(s);
d156 1
d158 2
a159 2
		log_debug("debug: dns_async: bad request");
		break;
a160 3

	stat_increment("lka.failure", 1);
	dnssession_destroy(s);
d164 1
a164 1
dns_reply(struct dns *query, int type)
d166 20
a185 2
	imsg_compose_event(query->asker, type, 0, 0, -1, query, sizeof(*query));
}
d187 2
a188 4
static void
dns_asr_event_set(struct dnssession *s, struct async_res *ar)
{
	struct timeval tv = { 0, 0 };
d190 5
a194 4
	tv.tv_usec = ar->ar_timeout * 1000;
	event_set(&s->ev, ar->ar_fd,
	    ar->ar_cond == ASYNC_READ ? EV_READ : EV_WRITE, dns_asr_handler, s);
	event_add(&s->ev, &tv);
d198 1
a198 1
dns_asr_handler(int fd, short event, void *arg)
d200 1
a200 1
	struct dnssession *s = arg;
d202 8
a209 28
	switch (s->query.type) {
	case IMSG_DNS_HOST:
		dns_asr_dispatch_host(s);
		break;
	case IMSG_DNS_PTR:
		dns_asr_dispatch_cname(s);
		break;
	case IMSG_DNS_MX:
		dns_asr_dispatch_mx(s);
		break;
	default:
		fatalx("bad query type");
	}
}

static int
dns_asr_error(int ar_err)
{
	switch (ar_err) {
	case 0:
		return DNS_OK;
	case NO_DATA:
	case NO_RECOVERY:
		stat_increment("lka.failure", 1);
		return DNS_EINVAL;
	default:
		return DNS_RETRY;
	}
d213 1
a213 1
dns_asr_dispatch_mx(struct dnssession *s)
d215 1
a215 2
	struct dns		*query = &s->query;
	struct async_res	 ar;
d221 1
d223 1
a223 4
	if (async_run(s->as, &ar) == ASYNC_COND) {
		dns_asr_event_set(s, &ar);
		return;
	}
d225 11
a235 6
	if (ar.ar_h_errno && ar.ar_h_errno != NO_DATA) {
		query->error = ar.ar_rcode == NXDOMAIN ? \
			DNS_ENONAME : dns_asr_error(ar.ar_h_errno);
		dns_reply(query, IMSG_DNS_HOST_END);
		dnssession_destroy(s);
		free(ar.ar_data);
d239 1
a239 1
	unpack_init(&pack, ar.ar_data, ar.ar_datalen);
d243 1
d250 2
a251 1
		dnssession_mx_insert(s, buf, rr.rr.mx.preference);
d253 1
a253 2

	free(ar.ar_data);
d256 2
a257 10
	if (TAILQ_EMPTY(&s->mx))
		dnssession_mx_insert(s, query->host, 0);

	/* Now we have a sorted list of MX to resolve. Simply "turn" this
	 * MX session into a regular host session.
	 */
	s->as = NULL;
	s->query.type = IMSG_DNS_HOST;
	s->query.error = DNS_ENOTFOUND; /* override later */
	dns_asr_dispatch_host(s);
d261 1
a261 1
dns_asr_dispatch_host(struct dnssession *s)
d263 7
a269 4
	struct dns		*query = &s->query;
	struct mx		*mx;
	struct async_res	 ar;
	struct addrinfo		 hints, *ai;
d271 24
a294 14
next:
	/* query all listed hosts in turn */
	while (s->as == NULL) {

		mx = TAILQ_FIRST(&s->mx);
		if (mx == NULL || (s->preference != -1
		    && s->preference <= mx->preference)) {
			if (mx)
				log_debug("debug: dns: ignoring mx with < pri");
			if (s->mxfound)
				query->error = DNS_OK;
			dns_reply(query, IMSG_DNS_HOST_END);
			dnssession_destroy(s);
			return;
a295 10

		log_debug("debug: dns: resolving address for \"%s\"", mx->host);

		memset(&hints, 0, sizeof(hints));
		hints.ai_family = PF_UNSPEC;
		hints.ai_socktype = SOCK_STREAM;
		s->as = getaddrinfo_async(mx->host, NULL, &hints, NULL);
		TAILQ_REMOVE(&s->mx, mx, entry);
		free(mx->host);
		free(mx);
d298 1
a298 4
	if (async_run(s->as, &ar) == ASYNC_COND) {
		dns_asr_event_set(s, &ar);
		return;
	}
d300 7
a306 13
	if (ar.ar_gai_errno == 0) {
		for (ai = ar.ar_addrinfo; ai; ai = ai->ai_next) {
			memcpy(&query->ss, ai->ai_addr, ai->ai_addrlen);
			log_debug("debug: dns: got address %s",
			    ss_to_text(&query->ss));
			dns_reply(query, IMSG_DNS_HOST);
			s->mxfound++;
		}
		freeaddrinfo(ar.ar_addrinfo);
	}

	s->as = NULL;
	goto next;
d310 1
a310 1
dns_asr_dispatch_cname(struct dnssession *s)
d312 24
a335 26
	struct dns		*query = &s->query;
	struct async_res	 ar;

	if (async_run(s->as, &ar) == ASYNC_COND) {
		dns_asr_event_set(s, &ar);
		return;
	}

	/* the error code could be more precise, but we don't currently care */
	query->error = ar.ar_gai_errno ? DNS_ENOTFOUND : DNS_OK;
	dns_reply(query, IMSG_DNS_PTR);
	dnssession_destroy(s);
}

static struct dnssession *
dnssession_init(struct dns *query)
{
	struct dnssession *s;

	s = xcalloc(1, sizeof(struct dnssession), "dnssession_init");

	stat_increment("lka.session", 1);

	s->id = query->id;
	s->query = *query;
	s->preference = -1;
d337 1
a337 1
	TAILQ_INIT(&s->mx);
d339 18
a356 1
	return (s);
d360 1
a360 1
dnssession_destroy(struct dnssession *s)
d362 4
a365 32
	struct mx	*mx;

	stat_decrement("lka.session", 1);
	event_del(&s->ev);

	while ((mx = TAILQ_FIRST(&s->mx))) {
		TAILQ_REMOVE(&s->mx, mx, entry);
		free(mx->host);
		free(mx);
	}

	free(s);
}

static void
dnssession_mx_insert(struct dnssession *s, const char *host, int preference)
{
	struct mx	*mx, *e;

	mx = xcalloc(1, sizeof *mx, "dnssession_mx_insert");
	mx->host = xstrdup(host, "dnssession_mx_insert");
	mx->preference = preference;

	log_debug("debug: dns: found mx \"%s\" with preference %i",
	    host, preference);

	TAILQ_FOREACH(e, &s->mx, entry) {
		if (mx->preference <= e->preference) {
			TAILQ_INSERT_BEFORE(e, mx, entry);
			goto end;
		}
	}
d367 2
a368 1
	TAILQ_INSERT_TAIL(&s->mx, mx, entry);
d370 11
a380 5
end:
	if (s->preference == -1 && s->query.backup[0]
	    && !strcasecmp(host, s->query.backup)) {
		log_debug("debug: dns: found our backup preference");
		s->preference = preference;
@


1.62
log
@knf

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.61 2012/11/12 14:58:53 eric Exp $	*/
d234 1
a234 1
	struct packed		 pack;
d254 1
a254 1
	packed_init(&pack, ar.ar_data, ar.ar_datalen);
@


1.61
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.60 2012/10/08 08:46:24 eric Exp $	*/
d102 2
a103 2
	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_DNS_MX, 0, 0, -1, &query,
	    sizeof(query));
d115 2
a116 2
	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_DNS_PTR, 0, 0, -1, &query,
	    sizeof(query));
d134 2
a135 1
			log_debug("debug: dns:  \"%s\" is an IP address", query->host);
d187 1
a187 1
	
d199 1
a199 1
	switch(s->query.type) {
d298 1
a298 1
				log_debug("debug: dns: ignoring mx with lower preference");
d325 2
a326 1
			log_debug("debug: dns: got address %s", ss_to_text(&query->ss));
d380 1
a380 1
	while((mx = TAILQ_FIRST(&s->mx))) {
d398 2
a399 1
	log_debug("debug: dns: found mx \"%s\" with preference %i", host, preference);
@


1.60
log
@skip RR if type is not MX.  Use hostname if the list of MX is empty
after the loop.

spotted by huku at grhack.net

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.59 2012/10/03 21:44:35 gilles Exp $	*/
d131 1
a131 1
		log_debug("dns: lookup host \"%s\"", query->host);
d134 1
a134 1
			log_debug("dns:  \"%s\" is an IP address", query->host);
d152 1
a152 1
			log_debug("dns_async: asr_query_cname error");
d158 1
a158 1
		log_debug("dns: lookup mx \"%s\"", query->host);
d162 1
a162 1
			log_debug("dns_async: asr_query_dns error");
d168 1
a168 1
		log_debug("dns_async: bad request");
d297 1
a297 1
				log_debug("dns: ignoring mx with lower preference");
d305 1
a305 1
		log_debug("dns: resolving address for \"%s\"", mx->host);
d324 1
a324 1
			log_debug("dns: got address %s", ss_to_text(&query->ss));
d396 1
a396 1
	log_debug("dns: found mx \"%s\" with preference %i", host, preference);
d410 1
a410 1
		log_debug("dns: found our backup preference");
@


1.59
log
@when requesting MX entries, the result can be appear in random orders.

the logic for inserting them in a lka session when acting as backup MX did
not take account for one specific case that could lead to an early exit
without smtpd getting a chance to detect the entry corrsponds to itself.

in such case, a backup MX woud try to connect to itself and bounce in the
loop detection code ... or it would sometimes work.
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.58 2012/09/27 17:47:49 chl Exp $	*/
a256 4
	if (h.ancount == 0)
		/* fallback to host if no MX is found. */
		dnssession_mx_insert(s, query->host, 0);

d259 2
d267 4
@


1.58
log
@use xmalloc()/xcalloc() helpers

while there unify usage of log_trace() in ramstat_set()

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.57 2012/08/25 10:23:11 gilles Exp $	*/
d399 1
a399 1
			return;
d405 1
@


1.57
log
@- introduce struct stat_value
- statistics can now have a type (counter, timestamp, timeval, timespec and
  possibly others in the future)
- stat_increment() / stat_decrement() now take an increment/decrement value
  and are at the moment only of type counter
- stat_set() now takes a stat_value
- provide helpers to convert raw values to stat_value

ok eric@@, ok chl@@

while at it fix a rq_queue_dump() call using a bogus timestamp in scheduler
ramqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.56 2012/08/21 20:19:46 eric Exp $	*/
d355 1
a355 3
	s = calloc(1, sizeof(struct dnssession));
	if (s == NULL)
		fatal("dnssession_init: calloc");
@


1.56
log
@Allow smtpd to work as a backup MX, relaying only to MXs with higher
priority in the DNS record. For example:

   accept for domain "foo.org" relay backup "mx3.foo.org"

will relay mails for "foo.org" using only hosts with higher priority
(i.e. lower value) than "mx3.foo.org", which is supposed to be the
current server.

If the specified backup MX is not found in the DNS record, relaying
works as normal.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.55 2012/08/21 15:14:40 eric Exp $	*/
d142 1
a142 1
		stat_increment("lka.session.host");
d150 1
a150 1
		stat_increment("lka.session.cname");
d160 1
a160 1
		stat_increment("lka.session.mx");
d172 1
a172 1
	stat_increment("lka.failure");
d221 1
a221 1
		stat_increment("lka.failure");
d359 1
a359 1
	stat_increment("lka.session");
d375 1
a375 1
	stat_decrement("lka.session");
@


1.55
log
@Use TAILQ rather than array for mx list.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.54 2012/08/21 14:00:59 eric Exp $	*/
d54 1
a54 1

d91 1
a91 1
dns_query_mx(char *host, int port, uint64_t id)
d97 2
d292 4
a295 1
		if (mx == NULL) {
d363 1
d406 6
@


1.54
log
@dns sessions don't use lookup. no need to store them in a tree.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.53 2012/08/19 14:16:58 chl Exp $	*/
d44 3
a46 2
	char	host[MAXHOSTNAMELEN];
	int	prio;
d54 1
a54 3
	struct mx			 mxarray[MAX_MX_COUNT];
	size_t				 mxarraysz;
	size_t				 mxcurrent;
d56 1
d141 1
d273 1
a284 4
	/* default to notfound, override with retry or ok later */
	if (s->mxcurrent == 0)
		query->error = DNS_ENOTFOUND;

d288 3
a290 1
		if (s->mxcurrent == s->mxarraysz) {
d298 2
a299 1
		mx = s->mxarray + s->mxcurrent++;
d301 2
a302 2
           	hints.ai_family = PF_UNSPEC;
           	hints.ai_socktype = SOCK_STREAM;
d304 3
d317 1
d358 3
d367 2
d371 7
d382 1
a382 1
dnssession_mx_insert(struct dnssession *s, const char *host, int prio)
d384 1
a384 5
	size_t i, j;

	for (i = 0; i < s->mxarraysz; i++)
		if (prio < s->mxarray[i].prio)
			break;
d386 3
a388 2
	if (i == MAX_MX_COUNT)
		return;
d390 1
a390 2
	if (s->mxarraysz < MAX_MX_COUNT)
		s->mxarraysz++;
d392 6
a397 2
	for (j = s->mxarraysz - 1; j > i; j--)
		s->mxarray[j] = s->mxarray[j - 1];
d399 1
a399 3
        s->mxarray[i].prio = prio;
	strlcpy(s->mxarray[i].host, host,
	    sizeof (s->mxarray[i].host));
@


1.53
log
@coding style: replace all occurences of u_int* with uint*

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.52 2012/08/18 18:18:23 gilles Exp $	*/
a48 1
	SPLAY_ENTRY(dnssession)		 nodes;
a58 7
static int  dnssession_cmp(struct dnssession *, struct dnssession *);

SPLAY_HEAD(dnstree, dnssession) dns_sessions = SPLAY_INITIALIZER(&dns_sessions);

SPLAY_PROTOTYPE(dnstree, dnssession, nodes, dnssession_cmp);


a352 1
	SPLAY_INSERT(dnstree, &dns_sessions, s);
a359 1
	SPLAY_REMOVE(dnstree, &dns_sessions, s);
a385 17

static int
dnssession_cmp(struct dnssession *s1, struct dnssession *s2)
{
	/*
	 * do not return uint64_t's
	 */
	if (s1->id < s2->id)
		return (-1);

	if (s1->id > s2->id)
		return (1);

	return (0);
}

SPLAY_GENERATE(dnstree, dnssession, nodes, dnssession_cmp);
@


1.52
log
@- introduce stat_backend, an API for pluggable statistic backends
  > statistics are no longer static structures in shared memory
  > statistics are only set, smtpd never uses them in its logic
  > each statistic is a key/value where key can be any (dynamic) string
- convert all uses of the former API to use the new one
- implement stat_ramstat that keeps non-persistent stats in ram structure

ok eric@@, ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.51 2012/08/08 17:31:55 eric Exp $	*/
d50 1
a50 1
	u_int64_t			 id;
d85 1
a85 1
dns_query_host(char *host, int port, u_int64_t id)
d99 1
a99 1
dns_query_mx(char *host, int port, u_int64_t id)
d113 1
a113 1
dns_query_ptr(struct sockaddr_storage *ss, u_int64_t id)
d401 1
a401 1
	 * do not return u_int64_t's
@


1.51
log
@cleanup some old debug traces

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.50 2012/07/29 17:33:55 eric Exp $	*/
d148 1
a148 1
		stat_increment(STATS_LKA_SESSION_HOST);
d155 1
a155 1
		stat_increment(STATS_LKA_SESSION_CNAME);
d165 1
a165 1
		stat_increment(STATS_LKA_SESSION_MX);
d177 1
a177 1
	stat_increment(STATS_LKA_FAILURE);
d226 1
a226 1
		stat_increment(STATS_LKA_FAILURE);
d357 1
a357 1
	stat_increment(STATS_LKA_SESSION);
d368 1
a368 1
	stat_decrement(STATS_LKA_SESSION);
@


1.50
log
@fix bogus permfail when no MX is defined on a valid domain.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.49 2012/07/09 12:16:24 eric Exp $	*/
a148 1
		log_debug("dns: ready?");
@


1.49
log
@move to the new resolver implementation, with temporary glue to use
the relevant files from asr directly.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.48 2012/04/14 13:31:46 eric Exp $	*/
d250 1
a250 1
	if (ar.ar_errno || ar.ar_h_errno || ar.ar_rcode == NXDOMAIN) {
@


1.48
log
@improve readability

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.47 2012/01/11 21:22:26 eric Exp $	*/
d29 1
d38 1
a38 2
#include "dnsdefs.h"
#include "dnsutil.h"
d53 1
a53 1
	struct asr_query		*aq;
d70 1
a70 1
static void dns_asr_event_set(struct dnssession *, struct asr_result *);
d78 1
a78 1
struct asr *asr = NULL;
a130 5
	if (asr == NULL && (asr = asr_resolver(NULL)) == NULL) {
		log_warnx("dns_async: cannot create resolver");
		goto noasr;
	}

d149 1
d153 3
a155 2
		s->aq = asr_query_cname(asr, (struct sockaddr*)&query->ss,
		    query->ss.ss_len);
d157 1
a157 1
		if (s->aq == NULL) {
d165 1
a165 1
		s->aq = asr_query_dns(asr, T_MX, C_IN, query->host, 0);
d167 1
a167 1
		if (s->aq == NULL) {
a179 3
noasr:
	query->error = DNS_RETRY;
	dns_reply(query, type != IMSG_DNS_PTR ? IMSG_DNS_HOST_END : type);
d189 1
a189 1
dns_asr_event_set(struct dnssession *s, struct asr_result *ar)
d195 1
a195 1
	    ar->ar_cond == ASR_READ ? EV_READ : EV_WRITE, dns_asr_handler, s);
d223 1
a223 1
	case ASR_OK:
d225 2
a226 2
	case EASR_FAMILY:
	case EASR_NAME:
d238 1
a238 1
	struct asr_result	 ar;
d245 1
a245 1
	if (asr_run(s->aq, &ar) == ASR_COND) {
d250 3
a252 2
	if (ar.ar_err) {
		query->error = dns_asr_error(ar.ar_err);
d255 1
a262 9
	/* check if the domain name exists */
	/* XXX what about other DNS error codes? */
	if (RCODE(h.flags) == ERR_NAME) {
		query->error = DNS_ENONAME;
		dns_reply(query, IMSG_DNS_HOST_END);
		dnssession_destroy(s);
		return;
	}

a274 1
	ar.ar_data = NULL;
d279 1
a279 1
	s->aq = NULL;
d289 2
a290 2
	struct asr_result	 ar;
	int			 ret;
d298 1
a298 1
	while (s->aq == NULL) {
d306 1
d308 4
a311 1
		s->aq = asr_query_host(asr, mx->host, AF_UNSPEC);
d314 1
a314 8
	while ((ret = asr_run(s->aq, &ar)) == ASR_YIELD) {
		free(ar.ar_cname);
		memcpy(&query->ss, &ar.ar_sa.sa, ar.ar_sa.sa.sa_len);
		dns_reply(query, IMSG_DNS_HOST);
		s->mxfound++;
	}

	if (ret == ASR_COND) {
d319 8
a326 2
	if (dns_asr_error(ar.ar_err) == DNS_RETRY)
		query->error = DNS_RETRY;
d328 1
a328 1
	s->aq  = NULL;
d336 1
a336 1
	struct asr_result	 ar;
d338 1
a338 2
	switch (asr_run(s->aq, &ar)) {
	case ASR_COND:
a340 10
	case ASR_YIELD:
		/* Only return the first answer */
		query->error = DNS_OK;
		strlcpy(query->host, ar.ar_cname, sizeof (query->host));
		asr_abort(s->aq);
		free(ar.ar_cname);
		break;
	case ASR_DONE:
		query->error = dns_asr_error(ar.ar_err);
		break;
d342 3
@


1.47
log
@Try to parse hostnames as IP addresses before resolving.  This allows
relays to be given as IP address in the config file.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.46 2012/01/11 17:20:56 eric Exp $	*/
d129 1
a129 1
	struct dnssession *dnssession;
d138 1
a138 1
	dnssession = dnssession_init(query);
d149 1
a149 1
			dnssession_destroy(dnssession);
d152 1
a152 1
		dnssession_mx_insert(dnssession, query->host, 0);
d154 1
a154 1
		dns_asr_dispatch_host(dnssession);
d157 2
a158 2
		dnssession->aq = asr_query_cname(asr,
		    (struct sockaddr*)&query->ss, query->ss.ss_len);
d160 1
a160 1
		if (dnssession->aq == NULL) {
d164 1
a164 1
		dns_asr_dispatch_cname(dnssession);
d168 1
a168 1
		dnssession->aq = asr_query_dns(asr, T_MX, C_IN, query->host, 0);
d170 1
a170 1
		if (dnssession->aq == NULL) {
d174 1
a174 1
		dns_asr_dispatch_mx(dnssession);
d182 1
a182 1
	dnssession_destroy(dnssession);
d195 1
a195 1
dns_asr_event_set(struct dnssession *dnssession, struct asr_result *ar)
d200 3
a202 4
	event_set(&dnssession->ev, ar->ar_fd,
	    ar->ar_cond == ASR_READ ? EV_READ : EV_WRITE,
	    dns_asr_handler, dnssession);
	event_add(&dnssession->ev, &tv);
d208 1
a208 1
	struct dnssession *dnssession = arg;
d210 1
a210 1
	switch(dnssession->query.type) {
d212 1
a212 1
		dns_asr_dispatch_host(dnssession);
d215 1
a215 1
		dns_asr_dispatch_cname(dnssession);
d218 1
a218 1
		dns_asr_dispatch_mx(dnssession);
d241 1
a241 1
dns_asr_dispatch_mx(struct dnssession *dnssession)
d243 1
a243 1
	struct dns		*query = &dnssession->query;
d251 2
a252 2
	if (asr_run(dnssession->aq, &ar) == ASR_COND) {
		dns_asr_event_set(dnssession, &ar);
d259 1
a259 1
		dnssession_destroy(dnssession);
d272 1
a272 1
		dnssession_destroy(dnssession);
d278 1
a278 1
		dnssession_mx_insert(dnssession, query->host, 0);
d284 1
a284 1
		dnssession_mx_insert(dnssession, buf, rr.rr.mx.preference);
d293 3
a295 3
	dnssession->aq = NULL;
	dnssession->query.type = IMSG_DNS_HOST;
	dns_asr_dispatch_host(dnssession);
d299 1
a299 1
dns_asr_dispatch_host(struct dnssession *dnssession)
d301 1
a301 1
	struct dns		*query = &dnssession->query;
d307 1
a307 1
	if (dnssession->mxcurrent == 0)
d312 3
a314 3
	while (dnssession->aq == NULL) {
		if (dnssession->mxcurrent == dnssession->mxarraysz) {
			if (dnssession->mxfound)
d317 1
a317 1
			dnssession_destroy(dnssession);
d320 2
a321 2
		mx = dnssession->mxarray + dnssession->mxcurrent++;
		dnssession->aq = asr_query_host(asr, mx->host, AF_UNSPEC);
d324 1
a324 1
	while ((ret = asr_run(dnssession->aq, &ar)) == ASR_YIELD) {
d328 1
a328 1
		dnssession->mxfound++;
d332 1
a332 1
		dns_asr_event_set(dnssession, &ar);
d339 1
a339 1
	dnssession->aq  = NULL;
d344 1
a344 1
dns_asr_dispatch_cname(struct dnssession *dnssession)
d346 1
a346 1
	struct dns		*query = &dnssession->query;
d349 1
a349 1
	switch (asr_run(dnssession->aq, &ar)) {
d351 1
a351 1
		dns_asr_event_set(dnssession, &ar);
d357 1
a357 1
		asr_abort(dnssession->aq);
d365 1
a365 1
	dnssession_destroy(dnssession);
d371 1
a371 1
	struct dnssession *dnssession;
d373 2
a374 2
	dnssession = calloc(1, sizeof(struct dnssession));
	if (dnssession == NULL)
d379 4
a382 4
	dnssession->id = query->id;
	dnssession->query = *query;
	SPLAY_INSERT(dnstree, &dns_sessions, dnssession);
	return dnssession;
d386 1
a386 1
dnssession_destroy(struct dnssession *dnssession)
d389 3
a391 3
	SPLAY_REMOVE(dnstree, &dns_sessions, dnssession);
	event_del(&dnssession->ev);
	free(dnssession);
d395 1
a395 1
dnssession_mx_insert(struct dnssession *dnssession, const char *host, int prio)
d399 2
a400 2
	for (i = 0; i < dnssession->mxarraysz; i++)
		if (prio < dnssession->mxarray[i].prio)
d406 2
a407 2
	if (dnssession->mxarraysz < MAX_MX_COUNT)
		dnssession->mxarraysz++;
d409 2
a410 2
	for (j = dnssession->mxarraysz - 1; j > i; j--)
		dnssession->mxarray[j] = dnssession->mxarray[j - 1];
d412 3
a414 3
        dnssession->mxarray[i].prio = prio;
	strlcpy(dnssession->mxarray[i].host, host,
	    sizeof (dnssession->mxarray[i].host));
@


1.46
log
@Improve error reporting.  Most errors during hostname lookup are
now correctly reported as temporary failures.

from Nathanael Rensen, tweaks by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.45 2011/09/01 19:56:49 eric Exp $	*/
d142 10
d167 1
@


1.45
log
@Introduce a small set of functions to manage stat counters in a
simpler and hopefully saner way.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.44 2011/07/20 10:22:54 eric Exp $	*/
d72 1
d215 15
d247 1
a247 2
		/* temporary internal error, except for invalid name */
		query->error = (ar.ar_err == EASR_NAME) ? DNS_EINVAL : DNS_RETRY;
d296 4
d304 2
a305 4
			/* XXX although not likely, this can still be temporary */
			query->error = (dnssession->mxfound) ? DNS_OK : DNS_ENOTFOUND;
			if (query->error)
				stat_increment(STATS_LKA_FAILURE);
a316 1
		query->error = 0;
d326 3
d345 1
a345 1
		query->error = 0;
d351 1
a351 3
		/* This is necessarily an error */
		stat_increment(STATS_LKA_FAILURE);
		query->error = ar.ar_err;
@


1.44
log
@Fix reporting of permanent/temporary failures for MX lookups.
Simplify code a bit while there.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.43 2011/07/03 17:48:40 nicm Exp $	*/
d142 1
a142 1
		env->stats->lka.queries_host++;
d148 1
a148 1
		env->stats->lka.queries_cname++;
d157 1
a157 1
		env->stats->lka.queries_mx++;
d169 1
a169 1
	env->stats->lka.queries_failure++;
d288 1
a288 1
				env->stats->lka.queries_failure++;
d333 1
a333 1
		env->stats->lka.queries_failure++;
d350 1
a350 5
	env->stats->lka.queries++;
	env->stats->lka.queries_active++;
	if (env->stats->lka.queries_active > env->stats->lka.queries_maxactive)
		env->stats->lka.queries_maxactive = \
		    env->stats->lka.queries_active;
d361 1
a361 1
	env->stats->lka.queries_active--;
@


1.43
log
@imsg.h requires sys/queue.h and sys/uio.h.

ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.42 2011/05/06 19:21:43 eric Exp $	*/
d75 1
d172 8
a179 4
	query->error = EAI_AGAIN;
	if (type != IMSG_DNS_PTR)
		type = IMSG_DNS_HOST_END;
	imsg_compose_event(asker, type, 0, 0, -1, query, sizeof(*query));
d230 7
a236 2
	if (ar.ar_err)
		goto hosts;  /* empty list */
d242 9
a264 1
hosts:
d285 2
a286 1
			query->error = (dnssession->mxfound) ? 0 : EAI_NONAME;
d289 1
a289 2
			imsg_compose_event(query->asker, IMSG_DNS_HOST_END, 0,
			    0, -1, query, sizeof(*query));
d301 1
a301 2
		imsg_compose_event(query->asker, IMSG_DNS_HOST, 0, 0, -1, query,
		    sizeof(*query));
d337 1
a337 2
	imsg_compose_event(query->asker, IMSG_DNS_PTR, 0, 0, -1, query,
	    sizeof(*query));
@


1.42
log
@move dns session specific structs and prototypes out of smtpd.h.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.41 2011/05/01 12:57:11 eric Exp $	*/
d24 2
@


1.41
log
@the smtpd env is meant to be global, so do not pass it all around.

discussed with and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.40 2011/04/17 13:36:07 gilles Exp $	*/
d40 25
d340 1
a340 1
	SPLAY_INSERT(dnstree, &env->dns_sessions, dnssession);
d348 1
a348 1
	SPLAY_REMOVE(dnstree, &env->dns_sessions, dnssession);
d376 1
a376 1
int
@


1.40
log
@cleanups, cosmethic changes, functions that should be static are now static
no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.39 2011/04/02 16:40:19 eric Exp $	*/
d40 2
a41 2
static struct dnssession *dnssession_init(struct smtpd *, struct dns *);
static void dnssession_destroy(struct smtpd *, struct dnssession *);
d56 1
a56 1
dns_query_host(struct smtpd *env, char *host, int port, u_int64_t id)
d70 1
a70 1
dns_query_mx(struct smtpd *env, char *host, int port, u_int64_t id)
d84 1
a84 1
dns_query_ptr(struct smtpd *env, struct sockaddr_storage *ss, u_int64_t id)
d98 1
a98 1
dns_async(struct smtpd *env, struct imsgev *asker, int type, struct dns *query)
a106 1
	query->env   = env;
d109 1
a109 1
	dnssession = dnssession_init(env, query);
d142 1
a142 1
	dnssession_destroy(env, dnssession);
d242 1
a242 1
				query->env->stats->lka.queries_failure++;
d245 1
a245 1
			dnssession_destroy(query->env, dnssession);
d289 1
a289 1
		query->env->stats->lka.queries_failure++;
d295 1
a295 1
	dnssession_destroy(query->env, dnssession);
d299 1
a299 1
dnssession_init(struct smtpd *env, struct dns *query)
d320 1
a320 1
dnssession_destroy(struct smtpd *env, struct dnssession *dnssession)
@


1.39
log
@add stat counters for the lookup agent

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.38 2011/03/31 10:40:59 eric Exp $	*/
d40 8
a47 8
struct dnssession *dnssession_init(struct smtpd *, struct dns *);
void	dnssession_destroy(struct smtpd *, struct dnssession *);
void	dnssession_mx_insert(struct dnssession *, const char *, int);
void	dns_asr_event_set(struct dnssession *, struct asr_result *);
void	dns_asr_handler(int, short, void *);
void	dns_asr_dispatch_host(struct dnssession *);
void	dns_asr_dispatch_mx(struct dnssession *);
void	dns_asr_dispatch_cname(struct dnssession *);
d151 1
a151 1
void
d163 1
a163 1
void
d183 1
a183 1
void
d229 1
a229 1
void
d271 1
a271 1
void
d299 1
a299 1
struct dnssession *
d320 1
a320 1
void
d329 1
a329 1
void
@


1.38
log
@cleanup and simplification following the asr update.

- use a specific dispatch function for each type of query
- make the host handler work on a list of hosts by default (single host
  queries are just a particular case) and use that to resolve the MX list
- various other code cleanup
- remove unused headers
- remove orphaned prototypes
- update copyright

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.34 2011/03/26 21:40:14 eric Exp $	*/
d115 1
d121 1
d130 1
d142 1
d242 2
d290 1
d308 6
d323 1
@


1.37
log
@remove unused code now that reverse lookups are done through asr.

ok gilles@@
@
text
@d6 1
a22 1
#include <sys/queue.h>
a23 1
#include <sys/stat.h>
a26 1
#include <arpa/nameser.h>
a29 2
#include <netdb.h>
#include <resolv.h>
a32 1
#include <unistd.h>
d42 2
a43 2
void	dnssession_mx_insert(struct dnssession *, struct mx *);
void	dns_asr_event_set(struct dnssession *, struct asr_result *, void(*)(int, short, void*));
d45 2
a46 1
void	dns_asr_mx_handler(int, short, void *);
a47 3
void	lookup_host(struct imsgev *, struct dns *, int, int);
void	lookup_mx(struct imsgev *, struct dns *);
void	lookup_ptr(struct imsgev *, struct dns *);
d111 1
a111 1
	
d114 3
a116 2
		dnssession->aq = asr_query_host(asr, query->host, AF_UNSPEC);
		break;
d120 6
a125 1
		break;
d128 8
a136 2
	default:
		goto err;
a138 9
	/* query and set up event to handle answer */
	if (dnssession->aq == NULL)
		goto err;
	dns_asr_handler(-1, -1, dnssession);
	return;

err:
	log_debug("dns_async: ASR error while attempting to resolve `%s'",
	    query->host);
a139 1

d148 1
a148 2
dns_asr_event_set(struct dnssession *dnssession, struct asr_result *ar,
		  void (*handler)(int, short, void*))
d155 1
a155 1
	    handler, dnssession);
a162 10
	struct dns *query = &dnssession->query;
	struct smtpd *env = query->env;
	struct packed pack;
	struct header	h;
	struct query	q;
	struct rr rr;
	struct mx mx;
	struct asr_result ar;
	char *p;
	int ret;
d164 5
a168 1
	if (dnssession->query.type == IMSG_DNS_PTR) {
a169 10
		return;
	}

	switch ((ret = asr_run(dnssession->aq, &ar))) {
	case ASR_COND:
		dns_asr_event_set(dnssession, &ar, dns_asr_handler);
		return;

	case ASR_YIELD:
	case ASR_DONE:
d171 5
d177 1
d179 10
a188 1
	query->error = EAI_AGAIN;
d190 2
a191 7
	if (ret == ASR_YIELD) {
		free(ar.ar_cname);
		memcpy(&query->ss, &ar.ar_sa.sa, ar.ar_sa.sa.sa_len);
		query->error = 0;
		imsg_compose_event(query->asker, IMSG_DNS_HOST, 0, 0, -1, query,
		    sizeof(*query));
		dns_asr_handler(-1, -1, dnssession);
d195 2
a196 13
	/* ASR_DONE */
	if (ar.ar_err) {
		query->error = ar.ar_err;
		goto err;
	}

	if (query->type == IMSG_DNS_HOST) {
		query->error = 0;
		imsg_compose_event(query->asker, IMSG_DNS_HOST_END, 0, 0, -1,
		    query, sizeof(*query));
		dnssession_destroy(env, dnssession);
		return;
	}
a197 1
	/* MX */
d199 2
a200 2
	if (unpack_header(&pack, &h) < 0 || unpack_query(&pack, &q) < 0)
		goto err;
d202 3
a204 12
	if (h.ancount == 0) {
		/* we were looking for MX and got no answer,
		 * fallback to host.
		 */
		query->type = IMSG_DNS_HOST;
		dnssession->aq = asr_query_host(asr, query->host,
		    AF_UNSPEC);
		if (dnssession->aq == NULL)
			goto err;
		dns_asr_handler(-1, -1, dnssession);
		return;
	}
d207 5
a211 2
		if (unpack_rr(&pack, &rr) < 0)
			goto err;
a212 8
		print_dname(rr.rr.mx.exchange, mx.host, sizeof (mx.host));
		if ((p = strrchr(mx.host, '.')) != NULL)
			*p = '\0';
		mx.prio =  rr.rr.mx.preference;

		/* sorted insert that will not overflow MAX_MX_COUNT */
		dnssession_mx_insert(dnssession, &mx);
	}
d216 3
a218 10
	/* The T_MX scenario is a bit tricky.
	 * Rather than forwarding the answers to the process that queried,
	 * we retrieve a set of MX hosts ... that need to be resolved. The
	 * loop above sorts them by priority, all we have left to do is to
	 * perform T_A lookups on all of them sequentially and provide the
	 * process that queried with the answers.
	 *
	 * To make it easier, we do this in another handler.
	 *
	 * -- gilles@@
d220 3
a222 16
	dnssession->mxfound = 0;
	dnssession->mxcurrent = 0;
	dnssession->aq = asr_query_host(asr,
	    dnssession->mxarray[dnssession->mxcurrent].host, AF_UNSPEC);
	if (dnssession->aq == NULL)
		goto err;

	dns_asr_mx_handler(-1, -1, dnssession);
	return;

err:
	free(ar.ar_data);
	query->type = IMSG_DNS_HOST_END;
	imsg_compose_event(query->asker, query->type, 0, 0, -1, query,
	    sizeof(*query));
	dnssession_destroy(env, dnssession);
a224 1
/* only handle MX requests */
d226 1
a226 1
dns_asr_mx_handler(int fd, short event, void *arg)
d228 4
a231 5
	struct dnssession *dnssession = arg;
	struct dns *query = &dnssession->query;
	struct smtpd *env = query->env;
	struct asr_result ar;
	int ret;
d233 13
a245 4
	switch ((ret = asr_run(dnssession->aq, &ar))) {
	case ASR_COND:
		dns_asr_event_set(dnssession, &ar, dns_asr_mx_handler);
		return;
d247 1
a247 1
	case ASR_YIELD:
d254 4
a257 1
		dns_asr_mx_handler(-1, -1, dnssession);
a258 3

	case ASR_DONE:
		break;
d261 2
a262 19
	if (++dnssession->mxcurrent == dnssession->mxarraysz)
		goto end;

	dnssession->aq = asr_query_host(asr,
	    dnssession->mxarray[dnssession->mxcurrent].host, AF_UNSPEC);
	if (dnssession->aq == NULL)
		goto end;
	dns_asr_mx_handler(-1, -1, dnssession);
	return;

end:
	if (dnssession->mxfound == 0)
		query->error = EAI_NONAME;
	else
		query->error = 0;
	imsg_compose_event(query->asker, IMSG_DNS_HOST_END, 0, 0, -1, query,
	    sizeof(*query));
	dnssession_destroy(env, dnssession);
	return;
d273 1
a273 1
		dns_asr_event_set(dnssession, &ar, dns_asr_handler);
d316 1
a316 1
dnssession_mx_insert(struct dnssession *dnssession, struct mx *mx)
d321 1
a321 1
		if (mx->prio < dnssession->mxarray[i].prio)
d333 3
a335 1
        dnssession->mxarray[i] = *mx;
@


1.36
log
@make use the cname query interface from asr for reverse lookups

ok gilles@@
@
text
@d175 1
a177 1
	int cnt;
d221 1
d227 10
a236 14
		if (query->type == IMSG_DNS_MX) {
			/* we were looking for MX and got no answer,
			 * fallback to host.
			 */
			query->type = IMSG_DNS_HOST;
			dnssession->aq = asr_query_host(asr, query->host,
			    AF_UNSPEC);
			if (dnssession->aq == NULL)
				goto err;
			dns_asr_handler(-1, -1, dnssession);
			return;
		}
		query->error = EAI_NONAME;
		goto err;
d239 1
a239 5
	if (query->type == IMSG_DNS_PTR) {
		if (h.ancount > 1) {
			log_debug("dns_asr_handler: PTR query returned several answers.");
			log_debug("dns_asr_handler: keeping only first result.");
		}
d243 2
a244 2
		print_dname(rr.rr.ptr.ptrname, query->host, sizeof (query->host));
		if ((p = strrchr(query->host, '.')) != NULL)
d246 4
a249 7
		free(ar.ar_data);
		
		query->error = 0;
		imsg_compose_event(query->asker, IMSG_DNS_PTR, 0, 0, -1, query,
		    sizeof(*query));
		dnssession_destroy(env, dnssession);
		return;
d251 2
d254 17
a270 36
	if (query->type == IMSG_DNS_MX) {
		struct mx mx;
		
		cnt = h.ancount;
		for (; cnt; cnt--) {
			if (unpack_rr(&pack, &rr) < 0)
				goto err;

			print_dname(rr.rr.mx.exchange, mx.host, sizeof (mx.host));
			if ((p = strrchr(mx.host, '.')) != NULL)
				*p = '\0';
			mx.prio =  rr.rr.mx.preference;

			/* sorted insert that will not overflow MAX_MX_COUNT */
			dnssession_mx_insert(dnssession, &mx);
		}
		free(ar.ar_data);
		ar.ar_data = NULL;

		/* The T_MX scenario is a bit trickier than T_PTR and T_A lookups.
		 * Rather than forwarding the answers to the process that queried,
		 * we retrieve a set of MX hosts ... that need to be resolved. The
		 * loop above sorts them by priority, all we have left to do is to
		 * perform T_A lookups on all of them sequentially and provide the
		 * process that queried with the answers.
		 *
		 * To make it easier, we do this in another handler.
		 *
		 * -- gilles@@
		 */
		dnssession->mxfound = 0;
		dnssession->mxcurrent = 0;
		dnssession->aq = asr_query_host(asr,
		    dnssession->mxarray[dnssession->mxcurrent].host, AF_UNSPEC);
		if (dnssession->aq == NULL)
			goto err;
d272 1
a272 3
		dns_asr_mx_handler(-1, -1, dnssession);
		return;
	}
d277 1
a277 2
	if (query->type != IMSG_DNS_PTR)
		query->type = IMSG_DNS_HOST_END;
a281 1

@


1.35
log
@add a function to factorize resetting of dnssession events.

ok gilles@@
@
text
@d51 1
a98 4
	if (strlcpy(query.host, ss_to_ptr(ss), sizeof (query.host))
	    >= sizeof (query.host))
		fatalx("dns_query_ptr");

d124 2
a125 1
		dnssession->aq = asr_query_dns(asr, T_PTR, C_IN, query->host, 0);
d180 4
a183 1
	bzero(&ar, sizeof (ar));
d362 27
@


1.34
log
@Fix the MX lookup process:

- the MX records were not always properly inserted into the sorted
  array, which led to some MX being silently dropped.
- if an MX address could not be resolved, mail delivery would fail,
  even though other valid MX exist for that domain. Now only report
  the failure if no server address can be found at all.

grrrreeat gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.33 2011/03/26 14:38:14 eric Exp $	*/
d48 1
d155 13
a177 1
	struct timeval tv = { 0, 0 };
d186 1
a186 5
		tv.tv_usec = ar.ar_timeout * 1000;
		event_set(&dnssession->ev, ar.ar_fd,
		    ar.ar_cond == ASR_READ ? EV_READ : EV_WRITE,
		    dns_asr_handler, dnssession);
		event_add(&dnssession->ev, &tv);
a320 1
	struct timeval tv = { 0, 0 };
d325 1
a325 5
		tv.tv_usec = ar.ar_timeout * 1000;
		event_set(&dnssession->ev, ar.ar_fd,
		    ar.ar_cond == ASR_READ ? EV_READ : EV_WRITE,
		    dns_asr_mx_handler, dnssession);
		event_add(&dnssession->ev, &tv);
@


1.33
log
@Tweak the asr API to make things a bit smoother on the user side.
Then asr_run() call now returns ASR_COND when a condition on a FD is
expected.  The exact condition (readable or writeable) is specified in
the asr_result structure, along with the fd and timeout.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.32 2011/03/26 10:54:22 eric Exp $	*/
d282 1
a324 7
	case ASR_DONE:
		break;
	}

	query->error = EAI_AGAIN;

	if (ret == ASR_YIELD) {
d330 1
d333 3
d338 1
a338 3
	/* ASR_DONE */
	if (ar.ar_err) {
		query->error = ar.ar_err;
a339 1
	}
a340 4
	if (++dnssession->mxcurrent == dnssession->mxarraysz) {
		query->error = 0;
		goto end;
	}
d349 4
d385 1
a385 2
        size_t i;
        size_t j;
d387 3
a389 2
	if (dnssession->mxarraysz > MAX_MX_COUNT)
		dnssession->mxarraysz = MAX_MX_COUNT;
d391 4
a394 2
        if (dnssession->mxarraysz == 0) {
                dnssession->mxarray[0] = *mx;
a395 2
                return;
        }
d397 3
a399 12
        for (i = 0; i < dnssession->mxarraysz; ++i)
                if (mx->prio < dnssession->mxarray[i].prio)
                        goto insert;

        if (i < MAX_MX_COUNT)
                dnssession->mxarray[i] = *mx;
	dnssession->mxarraysz++;
        return;

insert:
        for (j = dnssession->mxarraysz; j > i; --j)
                dnssession->mxarray[j] = dnssession->mxarray[j - 1];
@


1.32
log
@use an index for iterating into the mx list.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.31 2011/03/23 20:38:56 eric Exp $	*/
d172 1
a172 1
	case ASR_NEED_READ:
d174 2
a175 8
		event_set(&dnssession->ev, ar.ar_fd, EV_READ,
		    dns_asr_handler, dnssession);
		event_add(&dnssession->ev, &tv);
		return;

	case ASR_NEED_WRITE:
		tv.tv_usec = ar.ar_timeout * 1000;
		event_set(&dnssession->ev, ar.ar_fd, EV_WRITE,
d315 1
a315 8
	case ASR_NEED_READ:
		tv.tv_usec = ar.ar_timeout * 1000;
		event_set(&dnssession->ev, ar.ar_fd, EV_READ,
		    dns_asr_mx_handler, dnssession);
		event_add(&dnssession->ev, &tv);
		return;

	case ASR_NEED_WRITE:
d317 2
a318 1
		event_set(&dnssession->ev, ar.ar_fd, EV_WRITE,
@


1.31
log
@Simplify resolver initialization. This is done only once
since resolv.conf reloading is handled automatically by asr.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.30 2011/03/09 00:35:42 todd Exp $	*/
d288 1
a288 1
		dnssession->mxcurrent = &dnssession->mxarray[0];
d290 1
a290 1
		    dnssession->mxcurrent->host, AF_UNSPEC);
a317 1
	struct mx *lastmx;
d358 1
a358 2
	lastmx = &dnssession->mxarray[dnssession->mxarraysz - 1];
	if (dnssession->mxcurrent == lastmx) {
d362 2
a363 4

	dnssession->mxcurrent++;
	dnssession->aq = asr_query_host(asr, dnssession->mxcurrent->host,
	    AF_UNSPEC);
@


1.30
log
@make similar code .. more similar
ok gilles@@

previous commit should have read:

when copying 'struct sockaddr' data, use sa_len not sizeof(struct sockaddr_in)
this fixes truncation of IPv6 addresses in the mail delivery path
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.29 2011/03/09 00:34:01 todd Exp $	*/
a44 2
void	dns_setup(void);
int	dns_resolver_updated(void);
a105 37
int
dns_resolver_updated(void)
{
	struct stat sb;
	static time_t mtime = 0;

	/* first run, we need a resolver context */
	if (mtime == 0)
		return 1;

	if (stat(_PATH_RESCONF, &sb) < 0) {
		log_warnx("dns_resolver_updated: please check %s",
			_PATH_RESCONF);
		return 0;
	}

	/* no change since last time */
	if (mtime == sb.st_mtime)
		return 0;

	/* resolv.conf has been updated */
	mtime = sb.st_mtime;
	return 1;
}

void
dns_setup(void)
{
	if (asr)
		asr_done(asr);

	asr = asr_resolver(NULL);
	if (asr == NULL)
		log_warnx("dns_setup: unable to initialize resolver, "
		    "please check /etc/resolv.conf");
}

d111 2
a112 6
	if (dns_resolver_updated())
		dns_setup();

	if (asr == NULL) {
		log_warnx("dns_async: resolver is disabled, please check %s",
		    _PATH_RESCONF);
@


1.29
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.28 2010/12/19 11:24:17 gilles Exp $	*/
d238 1
a239 1
		memcpy(&query->ss, &ar.ar_sa.sa, ar.ar_sa.sa.sa_len);
@


1.28
log
@If MX lookup fails, fallback to using the host itself. This has always been
the behavior but I introduced a regression when switching to ASR.

bug reported by jmc@@, bugfix tested by jmc@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.27 2010/12/12 22:29:39 jsg Exp $	*/
d239 1
a239 1
		memcpy(&query->ss, &ar.ar_sa.sa, sizeof(ar.ar_sa.sa));
d388 1
a388 1
		memcpy(&query->ss, &ar.ar_sa.sa, sizeof(ar.ar_sa.sa));
@


1.27
log
@use memcpy instead of a cast/deref dance that was reading past
the end of the buffer.

tested by and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.26 2010/11/29 15:25:55 gilles Exp $	*/
d265 12
@


1.26
log
@replace the fork-based-non-blocking-resolver-hack by shiny async resolver
written by eric@@. it is still experimental but still better than what we
had earlier so ... we'll improve in tree :)

diff by me with *lots* of help from eric@@, tested by todd and I (and a
few people out there)
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.25 2010/11/28 14:02:46 gilles Exp $	*/
d239 1
a239 1
		query->ss = *(struct sockaddr_storage *)&ar.ar_sa.sa;
d376 1
a376 1
		query->ss = *(struct sockaddr_storage *)&ar.ar_sa.sa;
@


1.25
log
@remove unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.24 2010/11/28 13:56:43 gilles Exp $	*/
d24 1
d39 3
d45 12
a56 20
struct resdata {
	struct imsgev	 iev;
	struct imsgev	*asker;
};

struct mx {
	char	host[MAXHOSTNAMELEN];
	double	prio;
};

void		 parent_dispatch_dns(int, short, void *);

int		 dns(void);
void		 dns_dispatch_parent(int, short, void *);
void		 lookup_a(struct imsgev *, struct dns *, int, int);
void		 lookup_mx(struct imsgev *, struct dns *);
int		 get_mxlist(char *, char *, struct dns **);
void		 free_mxlist(struct dns *);
int		 mxcmp(const void *, const void *);
void		 lookup_ptr(struct imsgev *, struct dns *);
d63 1
a63 1
dns_query_a(struct smtpd *env, char *host, int port, u_int64_t id)
d72 2
a73 2
	imsg_compose_event(env->sc_ievs[PROC_LKA], IMSG_DNS_A, 0, 0, -1, &query,
	    sizeof(query));
d99 4
d107 3
a109 6
/*
 * Parent resolver process interface.
 */

void
dns_async(struct smtpd *env, struct imsgev *asker, int type, struct dns *query)
d111 2
a112 2
	struct resdata	*rd;
	int		 fd;
d114 3
a116 2
	if ((rd = calloc(1, sizeof(*rd))) == NULL)
		fatal(NULL);
d118 4
a121 8
	rd->asker = asker;
	query->env = env;

	/* dns() will fail if we are scarce on resources or processes */
	if ((fd = dns()) == -1) {
		query->error = EAI_AGAIN;
		imsg_compose_event(rd->asker, type, 0, 0, -1, query, sizeof(*query));
		return;
d124 3
a126 7
	imsg_init(&rd->iev.ibuf, fd);
	rd->iev.handler = parent_dispatch_dns;
	rd->iev.events = EV_READ;
	rd->iev.data = rd;
	event_set(&rd->iev.ev, rd->iev.ibuf.fd, rd->iev.events, rd->iev.handler,
	    rd->iev.data);
	event_add(&rd->iev.ev, NULL);
d128 3
a130 1
	imsg_compose_event(&rd->iev, type, 0, 0, -1, query, sizeof(*query));
d134 1
a134 1
parent_dispatch_dns(int sig, short event, void *p)
d136 21
a156 49
	struct resdata		*rd = p;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = &rd->iev;
	ibuf = &rd->iev.ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0)
			fatal("parent_dispatch_dns: pipe closed");
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("parent_dispatch_dns: msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("parent_dispatch_dns: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_DNS_A:
			imsg_compose_event(rd->asker, IMSG_DNS_A, 0, 0, -1, imsg.data,
			    sizeof(struct dns));
			break;

		case IMSG_DNS_A_END:
		case IMSG_DNS_PTR:
			imsg_compose_event(rd->asker, imsg.hdr.type, 0, 0, -1,
			    imsg.data, sizeof(struct dns));
			close(ibuf->fd);
			event_del(&iev->ev);
			free(rd);
			imsg_free(&imsg);
			return;

		default:
			log_warnx("parent_dispatch_dns: got imsg %d",
			    imsg.hdr.type);
			fatalx("parent_dispatch_dns: unexpected imsg");
		}
		imsg_free(&imsg);
d158 36
a193 1
	imsg_event_add(iev);
d196 25
a220 3
/*
 * Helper resolver process.
 */
d222 6
a227 6
int
dns(void)
{
	int		 fd[2];
	pid_t		 pid;
	struct imsgev	*iev;
d229 3
a231 3
	if (socketpair(AF_UNIX, SOCK_STREAM, AF_UNSPEC, fd) == -1) {
		log_warn("socketpair");
		return -1;
d234 11
a244 2
	session_socket_blockmode(fd[0], BM_NONBLOCK);
	session_socket_blockmode(fd[1], BM_NONBLOCK);
d246 4
a249 5
	if ((pid = fork()) == -1) {
		log_warn("fork");
		close(fd[0]);
		close(fd[1]);
		return -1;
d252 6
a257 3
	if (pid > 0) {
		close(fd[1]);
		return (fd[0]);
a258 1
	close(fd[0]);
d260 8
a267 2
	event_base_free(NULL);
	event_init();
d269 7
a275 2
	signal(SIGINT, SIG_DFL);
	signal(SIGTERM, SIG_DFL);
d277 11
a287 8
	if ((iev = calloc(1, sizeof(*iev))) == NULL)
		fatal(NULL);
	imsg_init(&iev->ibuf, fd[1]);
	iev->handler = dns_dispatch_parent;
	iev->events = EV_READ;
	iev->data = iev;
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev->data);
	event_add(&iev->ev, NULL);
d289 12
a300 4
	if (event_dispatch() < 0)
		fatal("event_dispatch");
	_exit(0);
}
d302 2
a303 16
void
dns_dispatch_parent(int sig, short event, void *p)
{
	struct imsgev		*iev = p;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
d305 22
d328 1
d330 7
a336 32
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("dns_dispatch_parent: msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("dns_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_DNS_A:
			lookup_a(iev, imsg.data, 0, 1);
			break;

		case IMSG_DNS_MX:
			lookup_mx(iev, imsg.data);
			break;

		case IMSG_DNS_PTR:
			lookup_ptr(iev, imsg.data);
			break;

		default:
			log_warnx("dns_dispatch_parent: got imsg %d",
			    imsg.hdr.type);
			fatalx("dns_dispatch_parent: unexpected imsg");
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d339 2
d342 1
a342 1
lookup_a(struct imsgev *iev, struct dns *query, int numeric, int finalize)
d344 15
a358 2
	struct addrinfo	*res0, *res, hints;
	char		*port = NULL;
d360 6
a365 2
	log_debug("lookup_a %s:%d%s", query->host, query->port,
	    numeric ? " (numeric)" : "");
d367 4
a370 8
	if (query->port && asprintf(&port, "%u", query->port) == -1)
		fatal(NULL);
	
	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	if (numeric)
		hints.ai_flags = AI_NUMERICHOST;
d372 10
a381 7
	query->error = getaddrinfo(query->host, port, &hints, &res0);
	if (query->error)
		goto end;

	for (res = res0; res; res = res->ai_next) {
		memcpy(&query->ss, res->ai_addr, res->ai_addr->sa_len);
		imsg_compose_event(iev, IMSG_DNS_A, 0, 0, -1, query, sizeof(*query));
a382 8
	freeaddrinfo(res0);
end:
	free(port);
	log_debug("lookup_a %s", query->error ? "failed" : "success");
	if (finalize)
		imsg_compose_event(iev, IMSG_DNS_A_END, 0, 0, -1, query,
		    sizeof(*query));
}
d384 3
a386 12
void
lookup_mx(struct imsgev *iev, struct dns *query)
{
	struct dns	*mx0, *mx;
	int		 success = 0;

	log_debug("lookup_mx %s", query->host);

	/* if ip address, skip MX lookup */
	/* XXX: maybe do it just once in parse.y? */
	lookup_a(iev, query, 1, 0);
	if (!query->error)
d388 1
d390 3
a392 2
	query->error = get_mxlist(query->host, query->env->sc_hostname, &mx0);
	if (query->error)
a393 14

	if (mx0 == NULL) {
		log_debug("implicit mx");
		if ((mx0 = calloc(1, sizeof(*mx0))) == NULL)
			fatal(NULL);
		strlcpy(mx0->host, query->host, sizeof(mx0->host));
	}

	for (mx = mx0; mx; mx = mx->next) {
		mx->port = query->port;
		mx->id = query->id;
		lookup_a(iev, mx, 0, 0);
		if (!mx->error)
			success++;
a394 1
	free_mxlist(mx0);
d396 7
a402 2
	if (success == 0)
		query->error = EAI_NODATA;
d405 4
a408 2
	log_debug("lookup_mx %s", query->error ? "failed" : "success");
	imsg_compose_event(iev, IMSG_DNS_A_END, 0, 0, -1, query, sizeof(*query));
d411 2
a412 2
int
get_mxlist(char *host, char *self, struct dns **res)
d414 1
a414 26
	struct mx	 tab[MAX_MX_COUNT];
	unsigned char	 *p, *endp;
	int		 ntab, i, ret, type, n, maxprio, cname_ok = 3;
	int		 qdcount, ancount;
	union {
		HEADER	 hdr;
		char	 buf[PACKETSZ];
	} answer;
again:
	ntab = 0;
	maxprio = 16384;
	ret = res_query(host, C_IN, T_MX, answer.buf, sizeof(answer.buf));
	if (ret < 0) {
		switch (h_errno) {
		case TRY_AGAIN:
			return (EAI_AGAIN);
		case HOST_NOT_FOUND:
			return (EAI_NONAME);
		case NO_RECOVERY:
			return (EAI_FAIL);
		case NO_DATA:
			*res = NULL;
			return (0);
		}
		fatal("get_mxlist: res_query");
	}
d416 3
a418 34
	p = answer.buf + HFIXEDSZ;
	endp = answer.buf + ret;
	qdcount = ntohs(((HEADER *)answer.buf)->qdcount);
	ancount = ntohs(((HEADER *)answer.buf)->ancount);

	if (qdcount < 1)
		return (EAI_FAIL);
	for (i = 0; i < qdcount; i++) {
		ret = dn_skipname(p, endp);
		if (ret < 0)
			return (EAI_FAIL);
		p += ret + QFIXEDSZ;
	}

	while (p < endp && ntab < ancount && ntab < MAX_MX_COUNT) {
		ret = dn_skipname(p, endp);
		if (ret < 0)
			return (EAI_FAIL);
		p += ret;

		GETSHORT(type, p);
		p += sizeof(u_int16_t) + sizeof(u_int32_t);
		GETSHORT(n, p);

		if (type == T_CNAME) {
			if (cname_ok-- == 0)
				return (EAI_FAIL);
			ret = dn_expand(answer.buf, endp, p, tab[0].host,
			    sizeof(tab[0].host));
			if (ret < 0)
				return (EAI_FAIL);
			host = tab[0].host;
			goto again;
		}
d420 5
a424 5
		if (type != T_MX) {
			log_warnx("get_mxlist: %s: bad rr type %d", host, type);
			p += n;
			continue;
		}
d426 6
a431 40
		GETSHORT(tab[ntab].prio, p);

		ret = dn_expand(answer.buf, endp, p, tab[ntab].host,
		    sizeof(tab[ntab].host));
		if (ret < 0)
			return (EAI_FAIL);
		p += ret;

		/*
		 * In case our name is listed as MX, prevent loops by excluding
		 * all hosts of our or greater preference number.
		 */
		if (strcmp(self, tab[ntab].host) == 0)
			maxprio = tab[ntab].prio;

		ntab++;
	}

	/*
	 * Randomize equal preference hosts using the fractional part.
	 */
	for (i = 0; i < ntab; i++)
		tab[i].prio += (double)arc4random_uniform(ntab) / ntab;

	qsort(tab, ntab, sizeof(struct mx), mxcmp);

	for (i = 0; i < ntab; i++) {
		log_debug("mx %s prio %f", tab[i].host, tab[i].prio);
		if (tab[i].prio >= maxprio)
			break;
		if ((*res = calloc(1, sizeof(struct dns))) == NULL)
			fatal(NULL);
		strlcpy((*res)->host, tab[i].host, sizeof((*res)->host));
		res = &(*res)->next;
	}

	if (i == 0)
		return (EAI_FAIL);

	return (0);
d435 1
a435 1
free_mxlist(struct dns *first)
d437 5
a441 1
	struct dns	*mx, *next;
d443 19
a461 4
	for (mx = first; mx; mx = next) {
		next = mx->next;
		free(mx);
	}
d465 1
a465 1
mxcmp(const void *va, const void *vb)
d467 5
a471 2
	const struct mx	*a = va;
	const struct mx	*b = vb;
d473 1
a473 1
	if (a->prio > b->prio)
d475 2
a476 4
	else if (a->prio < b->prio)
		return (-1);
	else
		return (0);
d479 1
a479 26
void
lookup_ptr(struct imsgev *iev, struct dns *query)
{
	struct addrinfo	*res, hints;

	log_debug("lookup_ptr %s", ss_to_text(&query->ss));

	query->error = getnameinfo((struct sockaddr *)&query->ss,
	    query->ss.ss_len, query->host, sizeof(query->host), NULL, 0,
	    NI_NAMEREQD);
	if (query->error)
		goto end;

	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_NUMERICHOST;

	if (getaddrinfo(query->host, NULL, &hints, &res) == 0) {
		query->error = EAI_NODATA;
		freeaddrinfo(res);
	}
end:
	log_debug("lookup_ptr %s", query->error ? "failed" : "success");
	imsg_compose_event(iev, IMSG_DNS_PTR, 0, 0, -1, query, sizeof(*query));
}
@


1.24
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.23 2010/09/08 13:32:13 gilles Exp $	*/
d33 1
a33 1
#include <signal.h>
@


1.23
log
@we do dns resolutions in a separate process because we don't have an async
resolver. if we run scarce on resources and we cannot fork a separate dns
process or we cannot socketpair() tell the caller that we have a temporary
failure rather than issueing a fatal(). message will stay in queue and be
rescheduled later ...

bug reported and bugfix tested by Sacha El Masry <lists@@devilray.eu>
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.22 2010/06/29 03:47:24 deraadt Exp $	*/
d30 1
d39 1
@


1.22
log
@force the dns buffers to be aligned using a union, until the retarded
"misalign strings on the stack" bug in gcc4 is fixed (even when that
is fixed this idiom is safer and quite common)
ok jacekm
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.21 2010/06/02 19:16:53 chl Exp $	*/
d121 7
a127 1
	fd = dns();
d206 4
a209 2
	if (socketpair(AF_UNIX, SOCK_STREAM, AF_UNSPEC, fd) == -1)
		fatal("socketpair");
d214 7
a220 2
	if ((pid = fork()) == -1)
		fatal("dns: fork");
@


1.21
log
@check event_dispatch() return value

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.20 2009/11/14 18:49:25 chl Exp $	*/
d368 1
a368 1
	unsigned char	 buf[PACKETSZ], *p, *endp;
d371 4
a374 1

d378 1
a378 1
	ret = res_query(host, C_IN, T_MX, buf, sizeof(buf));
d394 4
a397 4
	p = buf + HFIXEDSZ;
	endp = buf + ret;
	qdcount = ntohs(((HEADER *)buf)->qdcount);
	ancount = ntohs(((HEADER *)buf)->ancount);
d421 1
a421 1
			ret = dn_expand(buf, endp, p, tab[0].host,
d437 1
a437 1
		ret = dn_expand(buf, endp, p, tab[ntab].host,
@


1.20
log
@add missing header needed by signal()

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.19 2009/11/11 16:55:18 jacekm Exp $	*/
d229 2
a230 1
	event_dispatch();
@


1.19
log
@Fix previous.  When configured to relay via IP address, MX lookup would fail
(NXDOMAIN), leading to a bounce.  Precede the MX lookup with an attempt to
parse the relay as numeric string.

"reads ok" gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.18 2009/11/05 12:11:53 jsing Exp $	*/
d32 1
@


1.18
log
@Consider DNS lookups that result in NXDOMAIN to be a permanent failure.

ok gilles@@ jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.15 2009/08/08 00:02:22 gilles Exp $	*/
d52 1
a52 1
void		 lookup_a(struct imsgev *, struct dns *, int);
d264 1
a264 1
			lookup_a(iev, imsg.data, 1);
d286 1
a286 1
lookup_a(struct imsgev *iev, struct dns *query, int finalize)
d291 2
a292 1
	log_debug("lookup_a %s:%d", query->host, query->port);
d300 2
d314 2
a315 2
	if (finalize) {
		log_debug("lookup_a %s", query->error ? "failed" : "success");
a317 1
	}
d328 6
d348 1
a348 1
		lookup_a(iev, mx, 0);
@


1.17
log
@Introduce a 6yz status code, used internally to report permanent errors.
The 1yz and 6yz status codes are now removed prior to reporting the status
message in bounce messages, which provides an easy way to distinguish
between local and remote status messages. Initial diff from jacekm@@

ok gilles@@ jacekm@@
@
text
@d370 2
a373 1
		case HOST_NOT_FOUND:
@


1.16
log
@imsg_get sets errno so use fatal instead of fatalx.
@
text
@@


1.15
log
@import some changes from portable smtpd to reduce the delta between both.
this commit contains mostly missing casts and cosmethic changes, do not
expect to build this anywhere but on OpenBSD, it does not contain any of
the portable glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.14 2009/06/06 04:14:21 pyr Exp $	*/
d158 1
a158 1
			fatalx("parent_dispatch_dns: imsg_get error");
d258 1
a258 1
			fatalx("dns_dispatch_parent: imsg_get error");
@


1.14
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in smtpctl.
ok jaceckm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.13 2009/06/05 20:43:57 pyr Exp $	*/
d358 1
a358 1
	char		 buf[PACKETSZ], *p, *endp;
@


1.13
log
@make smtpd's imsg lib ready, just like relayd and ospfd.
ok gilles@@, jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.12 2009/06/01 13:20:56 jacekm Exp $	*/
d39 2
a40 2
	struct imsgbuf	 ibuf;
	struct imsgbuf	*asker;
d52 2
a53 2
void		 lookup_a(struct imsgbuf *, struct dns *, int);
void		 lookup_mx(struct imsgbuf *, struct dns *);
d57 1
a57 1
void		 lookup_ptr(struct imsgbuf *, struct dns *);
d73 1
a73 1
	imsg_compose_event(env->sc_ibufs[PROC_LKA], IMSG_DNS_A, 0, 0, -1, &query,
d87 1
a87 1
	imsg_compose_event(env->sc_ibufs[PROC_LKA], IMSG_DNS_MX, 0, 0, -1, &query,
d100 1
a100 1
	imsg_compose_event(env->sc_ibufs[PROC_LKA], IMSG_DNS_PTR, 0, 0, -1, &query,
d109 1
a109 1
dns_async(struct smtpd *env, struct imsgbuf *asker, int type, struct dns *query)
d121 7
a127 6
	imsg_init(&rd->ibuf, fd, parent_dispatch_dns);
	rd->ibuf.events = EV_READ;
	rd->ibuf.data = rd;
	event_set(&rd->ibuf.ev, rd->ibuf.fd, rd->ibuf.events, rd->ibuf.handler,
	    rd->ibuf.data);
	event_add(&rd->ibuf.ev, NULL);
d129 1
a129 1
	imsg_compose_event(&rd->ibuf, type, 0, 0, -1, query, sizeof(*query));
d136 1
d141 2
a142 1
	ibuf = &rd->ibuf;
d172 2
a173 2
			close(rd->ibuf.fd);
			event_del(&ibuf->ev);
d185 1
a185 1
	imsg_event_add(ibuf);
d197 1
a197 1
	struct imsgbuf	*ibuf;
d219 1
a219 1
	if ((ibuf = calloc(1, sizeof(*ibuf))) == NULL)
d221 6
a226 5
	imsg_init(ibuf, fd[1], dns_dispatch_parent);
	ibuf->events = EV_READ;
	ibuf->data = ibuf;
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf->data);
	event_add(&ibuf->ev, NULL);
d235 2
a236 1
	struct imsgbuf		*ibuf = p;
d245 1
a245 1
			event_del(&ibuf->ev);
d264 1
a264 1
			lookup_a(ibuf, imsg.data, 1);
d268 1
a268 1
			lookup_mx(ibuf, imsg.data);
d272 1
a272 1
			lookup_ptr(ibuf, imsg.data);
d282 1
a282 1
	imsg_event_add(ibuf);
d286 1
a286 1
lookup_a(struct imsgbuf *ibuf, struct dns *query, int finalize)
d306 1
a306 1
		imsg_compose_event(ibuf, IMSG_DNS_A, 0, 0, -1, query, sizeof(*query));
d313 1
a313 1
		imsg_compose_event(ibuf, IMSG_DNS_A_END, 0, 0, -1, query,
d319 1
a319 1
lookup_mx(struct imsgbuf *ibuf, struct dns *query)
d340 1
a340 1
		lookup_a(ibuf, mx, 0);
d351 1
a351 1
	imsg_compose_event(ibuf, IMSG_DNS_A_END, 0, 0, -1, query, sizeof(*query));
d489 1
a489 1
lookup_ptr(struct imsgbuf *ibuf, struct dns *query)
d512 1
a512 1
	imsg_compose_event(ibuf, IMSG_DNS_PTR, 0, 0, -1, query, sizeof(*query));
@


1.12
log
@Fix EV_READ/EV_WRITE testing inside IMSG handlers. Based on similar change
to the routing daemons by claudio@@; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.11 2009/05/09 17:04:55 jacekm Exp $	*/
d73 1
a73 1
	imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_DNS_A, 0, 0, -1, &query,
d87 1
a87 1
	imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_DNS_MX, 0, 0, -1, &query,
d100 1
a100 1
	imsg_compose(env->sc_ibufs[PROC_LKA], IMSG_DNS_PTR, 0, 0, -1, &query,
d128 1
a128 1
	imsg_compose(&rd->ibuf, type, 0, 0, -1, query, sizeof(*query));
d161 1
a161 1
			imsg_compose(rd->asker, IMSG_DNS_A, 0, 0, -1, imsg.data,
d167 1
a167 1
			imsg_compose(rd->asker, imsg.hdr.type, 0, 0, -1,
d301 1
a301 1
		imsg_compose(ibuf, IMSG_DNS_A, 0, 0, -1, query, sizeof(*query));
d308 1
a308 1
		imsg_compose(ibuf, IMSG_DNS_A_END, 0, 0, -1, query,
d346 1
a346 1
	imsg_compose(ibuf, IMSG_DNS_A_END, 0, 0, -1, query, sizeof(*query));
d507 1
a507 1
	imsg_compose(ibuf, IMSG_DNS_PTR, 0, 0, -1, query, sizeof(*query));
@


1.11
log
@- New API to handle all DNS query types (A, MX, PTR) asynchronously.

- Improve RFC compliance: CNAMEs are resolved, equal preference MXs
are randomized, relaying via MX that has equal/lower preference
than local server is prevented, decision on when to treat domain
name as implicit MX is better.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.10 2009/02/22 11:44:29 form Exp $	*/
d140 2
a141 2
	switch (event) {
	case EV_READ:
d146 3
a148 2
		break;
	case EV_WRITE:
a150 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
d235 1
a235 2
	switch (event) {
	case EV_READ:
d244 3
a246 2
		break;
	case EV_WRITE:
a248 4
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
@


1.10
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.9 2009/02/15 13:12:19 jacekm Exp $	*/
d5 1
a31 1
#include <stdio.h>
d34 1
d38 3
a40 3
struct mxrecord {
	char hostname[MAXHOSTNAMELEN];
	u_int16_t priority;
d43 19
a61 1
static void mxsort(struct mxrecord *, size_t);
d63 2
a64 2
static void
mxsort(struct mxrecord *array, size_t len)
d66 215
a280 9
	u_int32_t i;
	int32_t j;
	struct mxrecord store;

	for (i = 1; i < len; i++) {
		store = array[i];
		for (j = i - 1; j >= 0 && array[j].priority > store.priority;
		    j--) {
			array[j + 1] = array[j];
d282 35
a316 1
		array[j + 1] = store;
d320 36
d357 1
a357 1
getmxbyname(char *name, char ***result)
d359 10
a368 21
	union {
		u_int8_t bytes[PACKETSZ];
		HEADER header;
	} answer;
	u_int32_t i, j;
	int ret;
	u_int8_t *sp;
	u_int8_t *endp;
	u_int8_t *ptr;
	u_int16_t qdcount;
	u_int8_t expbuf[PACKETSZ];
	u_int16_t type;
	u_int16_t n;
	u_int16_t priority;
	size_t mxnb;
	struct mxrecord mxarray[MXARRAYSIZE];
	size_t chunklen;

	ret = res_query(name, C_IN, T_MX, (u_int8_t *)&answer.bytes,
		sizeof answer);
	if (ret == -1) {
a374 1
			return (EAI_NONAME);
d376 1
d379 1
a379 1
		fatal("getmxbyname: res_query");
d382 13
a394 5
	/* sp stores start of dns packet,
	 * endp stores end of dns packet,
	 */
	sp = (u_int8_t *)&answer.bytes;
	endp = sp + ret;
d396 5
a400 2
	/* skip header */
	ptr = sp + HFIXEDSZ;
d402 14
a415 19
	for (qdcount = ntohs(answer.header.qdcount);
	     qdcount--;
	     ptr += ret + QFIXEDSZ) {
		ret = dn_skipname(ptr, endp);
		if (ret == -1)
			return 0;
	}

	mxnb = 0;
	for (; ptr < endp;) {
		memset(expbuf, 0, sizeof expbuf);
		ret = dn_expand(sp, endp, ptr, expbuf, sizeof expbuf);
		if (ret == -1)
			break;
		ptr += ret;

		GETSHORT(type, ptr);
		ptr += sizeof(u_int16_t) + sizeof(u_int32_t);
		GETSHORT(n, ptr);
d418 2
a419 1
			ptr += n;
d423 50
a472 60
		GETSHORT(priority, ptr);
		ret = dn_expand(sp, endp, ptr, expbuf, sizeof expbuf);
		if (ret == -1)
			return 0;
		ptr += ret;

		if (mxnb < sizeof(mxarray) / sizeof(struct mxrecord)) {
			if (strlcpy(mxarray[mxnb].hostname, expbuf,
			    sizeof(mxarray[mxnb].hostname)) >=
			    sizeof(mxarray[mxnb].hostname))
				return 0;
			mxarray[mxnb].priority = priority;
		}
		else {
			int tprio = 0;

			for (i = j = 0;
				i < sizeof(mxarray) / sizeof(struct mxrecord);
				++i) {
				if (tprio < mxarray[i].priority) {
					tprio = mxarray[i].priority;
					j = i;
				}
			}

			if (mxarray[j].priority > priority) {
				if (strlcpy(mxarray[j].hostname, expbuf,
				    sizeof(mxarray[j].hostname)) >=
				    sizeof(mxarray[j].hostname))
					return 0;
				mxarray[j].priority = priority;
			}
		}
		++mxnb;
	}

	if (mxnb == 0)
		return 0;

	if (mxnb > sizeof(mxarray) / sizeof(struct mxrecord))
		mxnb = sizeof(mxarray) / sizeof(struct mxrecord);

	/* Rearrange MX records by priority */
	mxsort(mxarray, mxnb);

	chunklen = 0;
	for (i = 0; i < mxnb; ++i)
		chunklen += strlen(mxarray[i].hostname) + 1;
	chunklen += ((mxnb + 1) * sizeof(char *));

	*result = calloc(1, chunklen);
	if (*result == NULL)
		fatal("getmxbyname: calloc");

	ptr = (u_int8_t *)*result + (mxnb + 1) * sizeof(char *);
	for (i = 0; i < mxnb; ++i) {
		strlcpy(ptr, mxarray[i].hostname,
		    strlen(mxarray[i].hostname) + 1);
		(*result)[i] = ptr;
		ptr += strlen(mxarray[i].hostname) + 1;
d474 15
a488 1
	(*result)[i] = NULL;
d490 25
a514 1
	return mxnb;
@


1.9
log
@If MX query fails due to DNS error, do not attempt more queries; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.8 2009/02/15 09:58:31 jacekm Exp $	*/
d140 2
a141 1
				MAXHOSTNAMELEN) >= MAXHOSTNAMELEN)
d159 2
a160 1
					MAXHOSTNAMELEN) >= MAXHOSTNAMELEN)
d188 2
a189 1
		strlcpy(ptr, mxarray[i].hostname, MAXHOSTNAMELEN);
@


1.8
log
@Fix a bug where list of 6 MXs or more was not handled correctly.
Pointed out by & ok sthen@@, ok gilles@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.7 2009/01/01 16:15:47 jacekm Exp $	*/
d29 1
d61 1
a61 1
size_t
d84 13
a96 2
	if (ret == -1)
		return 0;
@


1.7
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.6 2008/12/05 19:09:59 gilles Exp $	*/
d76 1
a76 1
	u_int16_t priority, tprio;
a130 2
			if (tprio < priority)
				tprio = priority;
d133 2
@


1.6
log
@- more err/errx -> fatal/fatalx, warn/warnx -> log_warn/log_warnx
	contains bits based on an old diff from Jacek Masiulaniec and
	other bits from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.5 2008/12/01 22:54:08 gilles Exp $	*/
a22 1
#include <sys/time.h>
a28 1
#include <netdb.h>
a32 2
#include <sysexits.h>
#include <unistd.h>
@


1.5
log
@- in mxsort, fix type of loop counter, it will never be < 0 if it is
	unsigned and when running out of luck it will cause the lookup
	process to crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.4 2008/11/25 23:03:24 gilles Exp $	*/
a28 1
#include <err.h>
d173 2
a174 3
	if (*result == NULL) {
		err(1, "calloc");
	}
@


1.4
log
@- move prototype to smtpd.h
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.3 2008/11/10 03:54:08 tedu Exp $	*/
d52 1
a52 1
	u_int32_t j;
@


1.3
log
@insertion sort is faster than bubble sort.  ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
a46 2
size_t getmxbyname(char *, char ***);

@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 1
/* bubble sort MX records by priority */
d57 5
a61 7
	for (i = j = 0; i < len - 1; ++i) {
		for (j = i + 1; j < len; ++j) {
			if (array[i].priority > array[j].priority) {
				store = array[i];
				array[i] = array[j];
				array[j] = store;
			}
d63 1
d168 1
a168 1
	mxsort((struct mxrecord *)&mxarray, mxnb);
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

