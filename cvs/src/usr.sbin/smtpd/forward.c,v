head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.4
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.8
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.6
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.8
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12;
locks; strict;
comment	@ * @;


1.39
date	2015.12.28.22.08.30;	author jung;	state Exp;
branches;
next	1.38;
commitid	ZxnqOQqX6IeYI9jW;

1.38
date	2015.12.05.21.27.42;	author mmcc;	state Exp;
branches;
next	1.37;
commitid	u7cKDttUUhTVcGIY;

1.37
date	2015.10.14.21.04.37;	author gilles;	state Exp;
branches;
next	1.36;
commitid	nDksvKraUkKk0YAP;

1.36
date	2015.01.20.17.37.54;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	ZBTFreARDSMmzOIV;

1.35
date	2013.05.24.17.03.14;	author eric;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.31.18.34.43;	author eric;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.26.09.37.23;	author gilles;	state Exp;
branches;
next	1.32;

1.32
date	2012.11.12.14.58.53;	author eric;	state Exp;
branches;
next	1.31;

1.31
date	2012.09.27.17.47.49;	author chl;	state Exp;
branches;
next	1.30;

1.30
date	2012.09.21.19.37.08;	author eric;	state Exp;
branches;
next	1.29;

1.29
date	2012.09.21.16.40.20;	author eric;	state Exp;
branches;
next	1.28;

1.28
date	2012.09.20.14.28.57;	author eric;	state Exp;
branches;
next	1.27;

1.27
date	2012.09.19.12.59.59;	author eric;	state Exp;
branches;
next	1.26;

1.26
date	2012.09.19.12.45.04;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2012.09.19.09.06.35;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.16.21.05.51;	author gilles;	state Exp;
branches;
next	1.23;

1.23
date	2010.11.28.14.35.58;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2010.11.28.13.56.43;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.27.09.49.23;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.09.23.54.08;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.09.23.49.34;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.08.23.25.44;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.08.23.08.56;	author gilles;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.08.21.40.05;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.08.19.38.26;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.08.00.02.22;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.03.23.23.52;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.22.11.44.29;	author form;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.29.21.50.10;	author form;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.08.19.17.31;	author jacekm;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.07.00.26.30;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.04.00.58.59;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.01.16.15.47;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.13.13.15.38;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.06.14.30.51;	author jacekm;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.25.23.06.15;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.17.21.32.23;	author gilles;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.05.12.14.45;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.01.21.35.28;	author gilles;	state Exp;
branches;
next	;


desc
@@


1.39
log
@remove spaces after '!'

no binary change

ok millert
@
text
@/*	$OpenBSD: forward.c,v 1.38 2015/12/05 21:27:42 mmcc Exp $	*/

/*
 * Copyright (c) 2008 Gilles Chehade <gilles@@poolp.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <ctype.h>
#include <event.h>
#include <imsg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <util.h>
#include <unistd.h>
#include <limits.h>

#include "smtpd.h"
#include "log.h"

#define	MAX_FORWARD_SIZE	(4 * 1024)
#define	MAX_EXPAND_NODES	(100)

int
forwards_get(int fd, struct expand *expand)
{
	FILE	       *fp = NULL;
	char	       *line = NULL;
	size_t		len;
	size_t		lineno;
	size_t		save;
	int		ret;
	struct stat	sb;

	ret = -1;
	if (fstat(fd, &sb) == -1)
		goto end;

	/* if it's empty just pretend that no expansion took place */
	if (sb.st_size == 0) {
		log_info("info: forward file is empty");
		ret = 0;
		goto end;
	}

	/* over MAX_FORWARD_SIZE, temporarily fail */
	if (sb.st_size >= MAX_FORWARD_SIZE) {
		log_info("info: forward file exceeds max size");
		goto end;
	}

	if ((fp = fdopen(fd, "r")) == NULL) {
		log_warn("warn: fdopen failure in forwards_get()");
		goto end;
	}

	lineno = 0;
	save = expand->nb_nodes;
	while ((line = fparseln(fp, &len, &lineno, NULL, 0)) != NULL) {
		if (!expand_line(expand, line, 0)) {
			log_info("info: parse error in forward file");
			goto end;
		}
		if (expand->nb_nodes > MAX_EXPAND_NODES) {
			log_info("info: forward file expanded too many nodes");
			goto end;
		}
		free(line);
	}

	ret = expand->nb_nodes > save ? 1 : 0;

end:
	free(line);
	if (fp)
		fclose(fp);
	else
		close(fd);
	return ret;
}
@


1.38
log
@Remove a few NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.37 2015/10/14 21:04:37 gilles Exp $	*/
d77 1
a77 1
		if (! expand_line(expand, line, 0)) {
@


1.37
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.36 2015/01/20 17:37:54 deraadt Exp $	*/
d91 1
a91 2
	if (line)
		free(line);
@


1.36
log
@use <limits.h> comprehensively.  For now try to push <> includes to
each .c file, and out of the .h files.  To avoid overinclude.
ok gilles, in principle.  If this has been done right, -portable should
become easier to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.35 2013/05/24 17:03:14 eric Exp $	*/
d87 1
a87 1
	       
@


1.35
log
@sync with OpenSMTPD 5.3.2

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.34 2013/01/31 18:34:43 eric Exp $	*/
d33 1
@


1.34
log
@assorted fixes spotted by Coverity.
some log message updates.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.33 2013/01/26 09:37:23 gilles Exp $	*/
a21 1
#include <sys/param.h>
d47 1
d51 1
a51 1
	ret = 0;
d55 1
a55 1
	/* empty or over MAX_FORWARD_SIZE, temporarily fail */
d58 1
d61 2
d74 1
d87 1
a87 1
	ret = 1;
@


1.33
log
@Sync with our smtpd repo:

* first bricks of ldap and sqlite support (not finished but both working)
* new table API to replace map API, all lookups are done through tables
* improved handling of temporary errors throughout the daemon
* improved scheduler and mta logic: connection reuse, optimizes batches
* improved queue: more tolerant to admin errors, new layout, less disk-IO
* improved memory usage under high load
* SSL certs/keys isolated to lookup process to avoid facing network
* VIRTUAL support improved, fully virtual setups possible now
* runtime tracing of processes through smtpctl trace
* ssl_privsep.c sync-ed with relayd
* ssl.c no longer contains smtpd specific interfaces
* smtpd-specific ssl bits moved to ssl_smtpd.c
* update mail address in copyright

FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE. FLUSH YOUR QUEUE.

smtpd.conf(5) simplified, it will require adaptations

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.32 2012/11/12 14:58:53 eric Exp $	*/
d70 1
@


1.32
log
@Cleanups and improvements:

* Log more events (especially client session) and use a better scheme
  for that: each messages is prefixed with a token to easily identify
  its class:
    - info/warn/debug: general server messages
    - smtp-in: smtp client connections
    - relay: status update for relayed messages
    - delivery: status update for local deliveries

* Implement "smtpctl monitor" to display updates of selected internal
  counters.

* When reloading the on-disk queue at startup do not commit a message
  if no envelope was submitted for that message.

* Remove unused stuff in the config parser.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.31 2012/09/27 17:47:49 chl Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
d32 2
d38 3
d44 34
a77 21
	FILE *fp;
	char *buf, *lbuf, *p, *cp;
	size_t len;
	size_t nbaliases = 0;
	int quoted;
	struct expandnode xn;

	fp = fdopen(fd, "r");
	if (fp == NULL)
		return 0;

	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			/* EOF without EOL, copy and add the NUL */
			lbuf = xmalloc(len + 1, "forwards_get");
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
d79 4
d84 8
a91 40
		/* ignore empty lines and comments */
		if (buf[0] == '#' || buf[0] == '\0')
			continue;

		quoted = 0;
		cp = buf;
		do {
			/* skip whitespace */
			while (isspace((int)*cp))
				cp++;

			/* parse line */
			for (p = cp; *p != '\0'; p++) {
				if (*p == ',' && !quoted) {
					*p++ = '\0';
					break;
				} else if (*p == '"')
					quoted = !quoted;
			}
			buf = cp;
			cp = p;

			if (! alias_parse(&xn, buf)) {
				log_debug("debug: bad entry in ~/.forward");
				continue;
			}

			if (xn.type == EXPAND_INCLUDE) {
				log_debug(
				    "includes are forbidden in ~/.forward");
				continue;
			}

			expand_insert(expand, &xn);
			nbaliases++;
		} while (*cp != '\0');
	}
	free(lbuf);
	fclose(fp);
	return (nbaliases);
@


1.31
log
@use xmalloc()/xcalloc() helpers

while there unify usage of log_trace() in ramstat_set()

ok gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.30 2012/09/21 19:37:08 eric Exp $	*/
d85 1
a85 1
				log_debug("bad entry in ~/.forward");
@


1.30
log
@Do not pass the username to forwards_get() which does not have to care about
this.  Instead, set the username on the expand context, and copy it on the
expand nodes as they are inserted.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.29 2012/09/21 16:40:20 eric Exp $	*/
d56 1
a56 2
			if ((lbuf = malloc(len + 1)) == NULL)
				fatal("malloc");
@


1.29
log
@wrap expandtree into a "struct expand".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.28 2012/09/20 14:28:57 eric Exp $	*/
d37 1
a37 1
forwards_get(int fd, struct expand *expand, const char *as_user)
a94 2

			(void)strlcpy(xn.as_user, as_user, sizeof(xn.as_user));
@


1.28
log
@constify parameters that are supposed to be const.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.27 2012/09/19 12:59:59 eric Exp $	*/
d37 1
a37 1
forwards_get(int fd, struct expandtree *expandtree, const char *as_user)
d98 1
a98 1
			expand_insert(expandtree, &xn);
@


1.27
log
@expandnodes must be bzero()'d before parsing to be sure there is no bogus
data left on return, since the RB compare functions uses memcmp().  While
there, remove all calls to bzero() before alias_parse().

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.26 2012/09/19 12:45:04 eric Exp $	*/
d37 1
a37 1
forwards_get(int fd, struct expandtree *expandtree, char *as_user)
@


1.26
log
@rename variables for consistency

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.25 2012/09/19 09:06:35 eric Exp $	*/
a84 1
			bzero(&xn, sizeof (struct expandnode));
@


1.25
log
@start cleaning the expansion code:

- change expandtree_* prefix to expand_ for better readability and
  because the structure might change at some point
- rename <>_free_nodes() to <>_free()
- remove unused <>_remove_node()
- refcounting has no purpose at all; just remove it as well as the
  decrement/increment functions, and replace the latter with <>_insert
- expandnode flags is only used to know if it's been processed or not,
  don't make it a flag but a simple field with clear name.

ok gilles@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.24 2011/05/16 21:05:51 gilles Exp $	*/
d44 1
a44 1
	struct expandnode expnode;
d85 2
a86 2
			bzero(&expnode, sizeof (struct expandnode));
			if (! alias_parse(&expnode, buf)) {
d91 1
a91 1
			if (expnode.type == EXPAND_INCLUDE) {
d97 1
a97 1
			(void)strlcpy(expnode.as_user, as_user, sizeof(expnode.as_user));
d99 1
a99 1
			expand_insert(expandtree, &expnode);
@


1.24
log
@murder struct path and make sure smtpd uses simpler structures that do not
bring a shitload of unnecessary information everywhere. this required many
parts of smtpd to be refactored and more specifically envelope expansion.

in the process lots of code got simplified, and the envelope expansion code
has been isolated to lka_session.c with some longstanding bugs fixed.

Diff has been tested by many with no major regression reported.
armani@@ spotted a bug in a setup where a domain is listed a both primary
and virtual, I will fix that in-tree as it's becoming painful to maintain
this diff out.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.23 2010/11/28 14:35:58 gilles Exp $	*/
d99 1
a99 1
			expandtree_increment_node(expandtree, &expnode);
@


1.23
log
@remove all unused headers
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.22 2010/11/28 13:56:43 gilles Exp $	*/
d37 1
a37 1
forwards_get(int fd, struct expandtree *expandtree)
d96 2
@


1.22
log
@a bit of .h cleanups, no functionnal change
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.21 2010/04/27 09:49:23 gilles Exp $	*/
a26 1
#include <errno.h>
a28 1
#include <pwd.h>
a31 1
#include <unistd.h>
@


1.21
log
@initial work at fixing aliases support:
- kill struct alias, struct expandnode is used instead
- introduce map_parse_alias() and map_parse_virtual()
- aliases and virtual code no longer assume db(3) but use the map API which
  lets them become backend agnostic AND value-checked. this actually makes
  the code simpler by removing all values parsing from aliases.c
- rename K_SECRETS -> K_SECRET, K_ALIASES -> K_ALIAS for consistency the
  enum has singular names.
- aliases, virtual and forward now work with an expandtree and deal with
  multiple levels of resolving by merging expandtree's

more coming soon ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.20 2009/11/09 23:54:08 gilles Exp $	*/
d29 1
d37 1
@


1.20
log
@now that we don't keep an expand_node in memory for each expansion result,
we don't need to calloc them as they won't be saved in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.19 2009/11/09 23:49:34 gilles Exp $	*/
a40 1
	struct alias alias;
d45 1
a45 1
	struct expand_node expnode;
d86 2
a87 1
			if (! alias_parse(&alias, buf)) {
d92 1
a92 1
			if (alias.type == EXPAND_INCLUDE) {
a97 2
			bzero(&expnode, sizeof(struct expand_node));
			alias_to_expand_node(&expnode, &alias);
@


1.19
log
@- add a reference count and flags to struct expand_node
- during expansion, no longer create a new node for each result but try to
  lookup for an existing equivalent node and increment its reference count
  so that: a) we save on memory, b) we don't need to expand the same users
  again and again just because they keep appearing in expansion results.
- while expanding, flag nodes as F_EXPAND_DONE so that we know which nodes
  we already processed
- be smarter when expanding, if we have a clue that an iteration has not
  brought any new result (because no new nodes were added and all existing
  nodes have F_EXPAND_DONE), end expansion and proceed to delivery.
- various small cleanups

discussed with jacekm@@ yesterday, rebuild aliases db, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.18 2009/11/08 23:25:44 gilles Exp $	*/
d46 1
a46 1
	struct expand_node *expnode;
d98 3
a100 5
			expnode = calloc(sizeof(struct expand_node), 1);
			if (expnode == NULL)
				fatal("calloc");
			alias_to_expand_node(expnode, &alias);
			expandtree_increment_node(expandtree, expnode);
@


1.18
log
@forwards_get() also calls alias_to_expand_node()
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.17 2009/11/08 23:08:56 gilles Exp $	*/
d102 1
a102 1
			expandtree_insert(expandtree, expnode);
@


1.17
log
@rework a bit expansion and data structures involved in the expansion so we
no longer have a direct mapping between structures saved in aliases/virtual
db and structures used at runtime during expansion.

side effects ? struct alias is smaller, databases are smaller and it is no
longer necessary to rebuild aliases/virtual databases each time jacekm@@ or
I make changes to some obscure structure used indirectely during expansion

rebuild databases, flush queues, make clean
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.16 2009/11/08 21:40:05 gilles Exp $	*/
d101 1
a101 2
			expnode->type = alias.type;
			expnode->u = alias.u;
@


1.16
log
@- make aliases expansion use a rb tree instead of a tail queue, the code
  doesn't take advantage of the new structure yet, but this was a needed
  change for upcoming improvements.
- introduce aliasestree_{lookup,insert,remove} to the aliases api
- rename queue_generate_id() to generate_uid() and move it to utils.c as
  it is used all over the place and not only in queue

tree idea discussed with jacekm@@, if you update rebuild aliases db, make
clean and flush queue
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.15 2009/11/08 19:38:26 gilles Exp $	*/
d38 1
a38 1
forwards_get(int fd, struct aliasestree *aliases)
a41 1
	struct alias *aliasp;
d46 1
d92 1
a92 1
			if (alias.type == ALIAS_INCLUDE) {
d98 2
a99 2
			aliasp = calloc(1, sizeof(struct alias));
			if (aliasp == NULL)
d101 3
a103 2
			*aliasp = alias;
			aliasestree_insert(aliases, aliasp);
@


1.15
log
@first commit of a serie to cleanup, simplify and improve aliases resolution
which is probably the most complex code in smtpd right now. no longer use a
single list to hold aliases to be resolved and resolved aliases, and do not
use struct alias to hold resolved aliases. instead use a delivery list that
is a list of struct path, and populate it with resolved aliases.

idea discussed with jacekm@@, this needs some testing to make sure it does
not introduce a regression with aliases. flush your queue and make clean.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.14 2009/08/08 00:02:22 gilles Exp $	*/
d38 1
a38 1
forwards_get(int fd, struct aliaseslist *aliases)
d102 1
a102 1
			TAILQ_INSERT_HEAD(aliases, aliasp, entry);
@


1.14
log
@import some changes from portable smtpd to reduce the delta between both.
this commit contains mostly missing casts and cosmethic changes, do not
expect to build this anywhere but on OpenBSD, it does not contain any of
the portable glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.13 2009/03/03 23:23:52 gilles Exp $	*/
a86 1
			log_debug("\tforward: %s", buf);
@


1.13
log
@Fix a long standing issue where ~/.forward files were opened by user _smtpd
causing them not to be handled when a user's homedir is set to mode 0700. I
still need to do some cleanup and make sure it works as it should, but this
diff provides better behavior than what we had.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.12 2009/02/22 11:44:29 form Exp $	*/
d73 1
a73 1
			while (isspace(*cp))
@


1.12
log
@replace MAX* constants by sizeof where possible

ok jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.11 2009/01/29 21:50:10 form Exp $	*/
d38 1
a38 1
forwards_get(struct aliaseslist *aliases, char *username)
a42 1
	char pathname[MAXPATHLEN];
a44 2
	struct stat sb;
	struct passwd *pw;
d48 1
a48 8
	pw = safe_getpwnam(username);
	if (pw == NULL)
		return 0;

	if (! bsnprintf(pathname, sizeof(pathname), "%s/.forward", pw->pw_dir))
		return 0;

	fp = fopen(pathname, "r");
a51 13
	log_debug("+ opening forward file %s", pathname);
	/* make sure ~/ is not writable by anyone but owner */
	if (stat(pw->pw_dir, &sb) == -1)
		goto bad;
	if (sb.st_uid != pw->pw_uid || sb.st_mode & (S_IWGRP|S_IWOTH))
		goto bad;

	/* make sure ~/.forward is not writable by anyone but owner */
	if (fstat(fileno(fp), &sb) == -1)
		goto bad;
	if (sb.st_uid != pw->pw_uid || sb.st_mode & (S_IWGRP|S_IWOTH))
		goto bad;

a109 6

bad:
	log_debug("+ forward file error, probably bad perms/mode");
	if (fp != NULL)
		fclose(fp);
	return (0);
@


1.11
log
@better parsing of .forward files

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.10 2009/01/08 19:17:31 jacekm Exp $	*/
d55 1
a55 2
	if (snprintf(pathname, MAXPATHLEN, "%s/.forward", pw->pw_dir)
	    >= MAXPATHLEN)
@


1.10
log
@ensure getpwnam is always followed by endpwent; ok gilles@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.9 2009/01/07 00:26:30 gilles Exp $	*/
d43 2
a44 2
	char	pathname[MAXPATHLEN];
	char *buf, *lbuf;
d49 1
d89 2
a90 3
		log_debug("\tforward: %s", buf);
		if (! alias_parse(&alias, buf)) {
			log_debug("bad entry in ~/.forward");
a91 12
		}

		if (alias.type == ALIAS_INCLUDE) {
			log_debug("includes are forbidden in ~/.forward");
			continue;
		}
		aliasp = calloc(1, sizeof(struct alias));
		if (aliasp == NULL)
			fatal("calloc");
		*aliasp = alias;
		TAILQ_INSERT_HEAD(aliases, aliasp, entry);
		nbaliases++;
d93 37
d133 1
a133 1
	return nbaliases;
d139 1
a139 1
	return 0;
@


1.9
log
@- when performing aliases expansion, do not forget to set an action to each
expanded envelope, orelse they will use the default action and be passed to
MTA no matter if recipient is local or not.
	bug reported by Nicholas Marriott <nicholas.marriott@@gmail.com>,
	fixed by me and okayd by jacekm@@, collaborative work ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.8 2009/01/04 00:58:59 gilles Exp $	*/
d50 1
a50 1
	pw = getpwnam(username);
@


1.8
log
@aliases/forwards expansion was not done correctly and a race could
cause delivery to happen before expansion is over, causing some of
the recipients to never receive the mail. change how the mfa, lka,
queue and smtp processes communicate to ensure smtp never receives
an acknowledgment before ALL expanded envelopes are on disk. While
at it, lka was doing work which belongs in mfa, fix that also.

this is based on an idea from a talk with jacekm@@, change not over
but already better than what we had.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.7 2009/01/01 16:15:47 jacekm Exp $	*/
d48 1
d103 1
d108 1
a108 1
	return 1;
@


1.7
log
@remove unnecessary includes; ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.6 2008/12/13 13:15:38 jacekm Exp $	*/
d33 1
a43 1
	struct passwd *pw;
d47 1
@


1.6
log
@Declare alias_parse in smtpd.h, and fix callers that pass it wrong
number of arguments.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.5 2008/12/06 14:30:51 jacekm Exp $	*/
a26 1
#include <db.h>
a28 2
#include <fcntl.h>
#include <paths.h>
a29 2
#include <signal.h>
#include <stdarg.h>
a32 2
#include <unistd.h>
#include <util.h>
@


1.5
log
@Don't include <err.h> where log.c API must be used.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.4 2008/11/25 23:06:15 gilles Exp $	*/
a41 2

int alias_parse(struct alias *, char *);
@


1.4
log
@- more prototype moving to smtpd.h
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.3 2008/11/17 21:32:23 gilles Exp $	*/
a27 1
#include <err.h>
@


1.3
log
@- err() -> fatal()
- printf() -> log_debug()
- be more verbose in debug mode
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.2 2008/11/05 12:14:45 sobrado Exp $	*/
d44 1
a44 2
int	alias_parse(struct alias *, char *);
int	forwards_get(struct aliaseslist *, char *);
@


1.2
log
@add a few missing id tags; there are a bunch of files, and developers
will probably miss this change when working on more important matters,
so it is probably better to sort them now.  there is a risk of losing
the tags if a change needs to be reverted too.

written with excellent advice from jmc@@

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
d91 1
a91 1
				err(1, NULL);
d96 2
a97 1
		printf("%s\n", buf);
d109 1
a109 1
			err(1, "calloc");
d119 1
@


1.1
log
@smtpd is a smtp server implementation for OpenBSD. It is a work in progress
which still lacks many features. bringing it in tree will help working on it
more easily.

"at this stage it should go in" henning@@, "move ahead" deraadt@@
@
text
@d1 2
@

