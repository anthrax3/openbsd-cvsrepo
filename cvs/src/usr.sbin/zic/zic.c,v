head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.8
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17;
locks; strict;
comment	@ * @;


1.22
date	2016.03.15.19.50.47;	author millert;	state Exp;
branches;
next	1.21;
commitid	mm1knr3PswneRoCo;

1.21
date	2015.10.16.22.53.32;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	inVOpcr6YY7WNIex;

1.20
date	2015.04.23.05.26.33;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	OxktfeiY94FaOLO0;

1.19
date	2015.03.13.17.23.37;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	rzt00JpJWCZGbg5Q;

1.18
date	2015.03.11.22.26.03;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	7VbelVw4d1c7Sptu;

1.17
date	2015.02.11.01.07.37;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	hSkOsfNmA5SY5Ztx;

1.16
date	2015.02.10.09.17.02;	author tedu;	state Exp;
branches;
next	1.15;
commitid	5Wj31s2z2RBfIFrR;

1.15
date	2015.02.10.05.45.46;	author tedu;	state Exp;
branches;
next	1.14;
commitid	tzJ9ZCPvCk1OjI94;

1.14
date	2015.02.10.05.44.50;	author tedu;	state Exp;
branches;
next	1.13;
commitid	cfVEtDCW9pIcWSA2;

1.13
date	2015.02.10.03.35.46;	author tedu;	state Exp;
branches;
next	1.12;
commitid	PQ0JcZY7Bromq0rc;

1.12
date	2015.02.10.03.07.17;	author tedu;	state Exp;
branches;
next	1.11;
commitid	ruQpukRXHPQ11IYI;

1.11
date	2015.02.09.23.34.46;	author tedu;	state Exp;
branches;
next	1.10;
commitid	GH30qFck5kcrUbO7;

1.10
date	2015.02.09.23.14.32;	author tedu;	state Exp;
branches;
next	1.9;
commitid	paJaQZBH3wrcxI7u;

1.9
date	2015.02.09.14.34.44;	author tedu;	state Exp;
branches;
next	1.8;
commitid	3QLEGUqLC2vd7rkI;

1.8
date	2015.02.09.14.15.38;	author tedu;	state Exp;
branches;
next	1.7;
commitid	T5lDw5R7BjFC2tjY;

1.7
date	2015.02.09.13.46.22;	author tedu;	state Exp;
branches;
next	1.6;
commitid	lqdxXphiTozivn2t;

1.6
date	2015.02.09.13.42.03;	author tedu;	state Exp;
branches;
next	1.5;
commitid	tEJYsctuW7dx3cGd;

1.5
date	2015.02.09.13.39.16;	author tedu;	state Exp;
branches;
next	1.4;
commitid	dfCzFltGsoBkcZKk;

1.4
date	2015.02.09.13.21.42;	author tedu;	state Exp;
branches;
next	1.3;
commitid	IJEoWRjCUpcUQE7j;

1.3
date	2015.02.09.12.52.45;	author tedu;	state Exp;
branches;
next	1.2;
commitid	a3S1e4zjb6hnLJHe;

1.2
date	2015.02.09.12.45.33;	author tedu;	state Exp;
branches;
next	1.1;
commitid	q3ipNnWcQGeq6oGG;

1.1
date	2015.02.09.12.37.47;	author tedu;	state Exp;
branches;
next	;
commitid	IrOn8khkOGvoGgaT;


desc
@@


1.22
log
@Don't warn about valid time zone abbreviations.  POSIX through 2000
says that an abbreviation cannot start with ':', and cannot contain
',', '-', '+', NUL, or a digit.  POSIX from 2001 on changes this
rule to say that an abbreviation can contain only '-', '+', and
alphanumeric characters from the portable character set in the
current locale.  To be portable to both sets of rules, an abbreviation
must therefore use only ASCII letters."  Adapted from tzcode2015f.
OK deraadt@@ mestre@@
@
text
@/*	$OpenBSD: zic.c,v 1.21 2015/10/16 22:53:32 deraadt Exp $	*/
/*
** This file is in the public domain, so clarified as of
** 2006-07-17 by Arthur David Olson.
*/

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <time.h>

#include "tzfile.h"

#define TRUE	1
#define FALSE	0

#define TYPE_SIGNED(type) (((type) -1) < 0)

#define YEARSPERREPEAT	400	/* years before a Gregorian repeat */

#define GRANDPARENTED   "Local time zone must be set--see zic manual page"

#define	ZIC_VERSION	'2'

typedef int_fast64_t	zic_t;

#ifndef ZIC_MAX_ABBR_LEN_WO_WARN
#define ZIC_MAX_ABBR_LEN_WO_WARN	6
#endif /* !defined ZIC_MAX_ABBR_LEN_WO_WARN */

#define MKDIR_UMASK (S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)

#define OFFSET_STRLEN_MAXIMUM	(7 + INT_STRLEN_MAXIMUM(long))
#define RULE_STRLEN_MAXIMUM	8	/* "Mdd.dd.d" */

#define end(cp, n)	(memchr((cp), '\0', (n)))

struct rule {
	const char 	*r_filename;
	int		r_linenum;
	const char 	*r_name;

	int		r_loyear;	/* for example, 1986 */
	int		r_hiyear;	/* for example, 1986 */
	const char 	*r_yrtype;
	int		r_lowasnum;
	int		r_hiwasnum;

	int		r_month;	/* 0..11 */

	int		r_dycode;	/* see below */
	int		r_dayofmonth;
	int		r_wday;

	long		r_tod;		/* time from midnight */
	int		r_todisstd;	/* above is standard time if TRUE */
					/* or wall clock time if FALSE */
	int		r_todisgmt;	/* above is GMT if TRUE */
					/* or local time if FALSE */
	long		r_stdoff;	/* offset from standard time */
	const char 	*r_abbrvar;	/* variable part of abbreviation */

	int		r_todo;		/* a rule to do (used in outzone) */
	zic_t		r_temp;		/* used in outzone */
};

/*
**	r_dycode		r_dayofmonth	r_wday
*/

#define DC_DOM		0	/* 1..31 */	/* unused */
#define DC_DOWGEQ	1	/* 1..31 */	/* 0..6 (Sun..Sat) */
#define DC_DOWLEQ	2	/* 1..31 */	/* 0..6 (Sun..Sat) */

struct zone {
	const char 	*z_filename;
	int		z_linenum;

	const char 	*z_name;
	long		z_gmtoff;
	const char 	*z_rule;
	const char 	*z_format;

	long		z_stdoff;

	struct rule 	*z_rules;
	int		z_nrules;

	struct rule	z_untilrule;
	zic_t		z_untiltime;
};

static void	addtt(zic_t starttime, int type);
static int	addtype(long gmtoff, const char *abbr, int isdst,
	    int ttisstd, int ttisgmt);
static void	leapadd(zic_t t, int positive, int rolling, int count);
static void	adjleap(void);
static void	associate(void);
static void	convert(long val, char *buf);
static void	convert64(zic_t val, char *buf);
static void	dolink(const char *fromfield, const char *tofield);
static void	doabbr(char *abbr, size_t size, const char *format,
	    const char *letters, int isdst, int doquotes);
static void	eat(const char *name, int num);
static void	eats(const char *name, int num, const char *rname, int rnum);
static long	eitol(int i);
static void	error(const char *message);
static char	**getfields(char *buf);
static long	gethms(const char *string, const char *errstrng, int signable);
static void	infile(const char *filename);
static void	inleap(char **fields, int nfields);
static void	inlink(char **fields, int nfields);
static void	inrule(char **fields, int nfields);
static int	inzcont(char **fields, int nfields);
static int	inzone(char **fields, int nfields);
static int	inzsub(char **fields, int nfields, int iscont);
static int	is32(zic_t x);
static int	itsabbr(const char *abbr, const char *word);
static int	itsdir(const char *name);
static int	mkdirs(char *filename);
static void	newabbr(const char *abbr);
static long	oadd(long t1, long t2);
static void	outzone(const struct zone *zp, int ntzones);
static void	puttzcode(long code, FILE *fp);
static void	puttzcode64(zic_t code, FILE *fp);
static int	rcomp(const void *leftp, const void *rightp);
static zic_t	rpytime(const struct rule *rp, int wantedy);
static void	rulesub(struct rule *rp, const char *loyearp, const char *hiyearp,
	    const char *typep, const char *monthp,
	    const char *dayp, const char *timep);
static int 	stringoffset(char *result, size_t size, long offset);
static int	stringrule(char *result, size_t size, const struct rule *rp,
	    long dstoff, long gmtoff);
static void 	stringzone(char *result, size_t size,
	    const struct zone *zp, int ntzones);
static void	setboundaries(void);
static zic_t	tadd(zic_t t1, long t2);
static void	usage(void);
static void	writezone(const char *name, const char *string);
static int	yearistype(int year, const char *type);

extern char 	*__progname;

static int		charcnt;
static int		errors;
static const char 	*filename;
static int		leapcnt;
static int		leapseen;
static int		leapminyear;
static int		leapmaxyear;
static int		linenum;
static int		max_abbrvar_len;
static int		max_format_len;
static zic_t		max_time;
static int		max_year;
static zic_t		min_time;
static int		min_year;
static int		noise;
static const char 	*rfilename;
static int		rlinenum;
static int		timecnt;
static int		typecnt;

/*
** Line codes.
*/

#define LC_RULE		0
#define LC_ZONE		1
#define LC_LINK		2
#define LC_LEAP		3

/*
** Which fields are which on a Zone line.
*/

#define ZF_NAME		1
#define ZF_GMTOFF	2
#define ZF_RULE		3
#define ZF_FORMAT	4
#define ZF_TILYEAR	5
#define ZF_TILMONTH	6
#define ZF_TILDAY	7
#define ZF_TILTIME	8
#define ZONE_MINFIELDS	5
#define ZONE_MAXFIELDS	9

/*
** Which fields are which on a Zone continuation line.
*/

#define ZFC_GMTOFF	0
#define ZFC_RULE	1
#define ZFC_FORMAT	2
#define ZFC_TILYEAR	3
#define ZFC_TILMONTH	4
#define ZFC_TILDAY	5
#define ZFC_TILTIME	6
#define ZONEC_MINFIELDS	3
#define ZONEC_MAXFIELDS	7

/*
** Which files are which on a Rule line.
*/

#define RF_NAME		1
#define RF_LOYEAR	2
#define RF_HIYEAR	3
#define RF_COMMAND	4
#define RF_MONTH	5
#define RF_DAY		6
#define RF_TOD		7
#define RF_STDOFF	8
#define RF_ABBRVAR	9
#define RULE_FIELDS	10

/*
** Which fields are which on a Link line.
*/

#define LF_FROM		1
#define LF_TO		2
#define LINK_FIELDS	3

/*
** Which fields are which on a Leap line.
*/

#define LP_YEAR		1
#define LP_MONTH	2
#define LP_DAY		3
#define LP_TIME		4
#define LP_CORR		5
#define LP_ROLL		6
#define LEAP_FIELDS	7

/*
** Year synonyms.
*/

#define YR_MINIMUM	0
#define YR_MAXIMUM	1
#define YR_ONLY		2

static struct rule 	*rules;
static int		nrules;	/* number of rules */

static struct zone 	*zones;
static int		nzones;	/* number of zones */

struct link {
	const char 	*l_filename;
	int		l_linenum;
	const char 	*l_from;
	const char 	*l_to;
};

static struct link 	*links;
static int		nlinks;

struct lookup {
	const char 	*l_word;
	const int	l_value;
};

static struct lookup const 	*byword(const char *string, const struct lookup *lp);

static struct lookup const	line_codes[] = {
	{ "Rule",	LC_RULE },
	{ "Zone",	LC_ZONE },
	{ "Link",	LC_LINK },
	{ "Leap",	LC_LEAP },
	{ NULL,		0}
};

static struct lookup const	mon_names[] = {
	{ "January",	TM_JANUARY },
	{ "February",	TM_FEBRUARY },
	{ "March",	TM_MARCH },
	{ "April",	TM_APRIL },
	{ "May",	TM_MAY },
	{ "June",	TM_JUNE },
	{ "July",	TM_JULY },
	{ "August",	TM_AUGUST },
	{ "September",	TM_SEPTEMBER },
	{ "October",	TM_OCTOBER },
	{ "November",	TM_NOVEMBER },
	{ "December",	TM_DECEMBER },
	{ NULL,		0 }
};

static struct lookup const	wday_names[] = {
	{ "Sunday",	TM_SUNDAY },
	{ "Monday",	TM_MONDAY },
	{ "Tuesday",	TM_TUESDAY },
	{ "Wednesday",	TM_WEDNESDAY },
	{ "Thursday",	TM_THURSDAY },
	{ "Friday",	TM_FRIDAY },
	{ "Saturday",	TM_SATURDAY },
	{ NULL,		0 }
};

static struct lookup const	lasts[] = {
	{ "last-Sunday",	TM_SUNDAY },
	{ "last-Monday",	TM_MONDAY },
	{ "last-Tuesday",	TM_TUESDAY },
	{ "last-Wednesday",	TM_WEDNESDAY },
	{ "last-Thursday",	TM_THURSDAY },
	{ "last-Friday",	TM_FRIDAY },
	{ "last-Saturday",	TM_SATURDAY },
	{ NULL,			0 }
};

static struct lookup const	begin_years[] = {
	{ "minimum",	YR_MINIMUM },
	{ "maximum",	YR_MAXIMUM },
	{ NULL,		0 }
};

static struct lookup const	end_years[] = {
	{ "minimum",	YR_MINIMUM },
	{ "maximum",	YR_MAXIMUM },
	{ "only",	YR_ONLY },
	{ NULL,		0 }
};

static struct lookup const	leap_types[] = {
	{ "Rolling",	TRUE },
	{ "Stationary",	FALSE },
	{ NULL,		0 }
};

static const int	len_months[2][MONSPERYEAR] = {
	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
};

static const int	len_years[2] = {
	DAYSPERNYEAR, DAYSPERLYEAR
};

static struct attype {
	zic_t		at;
	unsigned char	type;
}			attypes[TZ_MAX_TIMES];

static long		gmtoffs[TZ_MAX_TYPES];
static char		isdsts[TZ_MAX_TYPES];
static unsigned char	abbrinds[TZ_MAX_TYPES];
static char		ttisstds[TZ_MAX_TYPES];
static char		ttisgmts[TZ_MAX_TYPES];
static char		chars[TZ_MAX_CHARS];
static zic_t		trans[TZ_MAX_LEAPS];
static long		corr[TZ_MAX_LEAPS];
static char		roll[TZ_MAX_LEAPS];

/*
** Memory allocation.
*/

static void *
memcheck(void *ptr)
{
	if (ptr == NULL)
		err(1, "Memory exhausted");
	return ptr;
}

static char *
ecatalloc(char *start, const char *tail)
{
	size_t len;
	char *str;

	len = strlen(start) + strlen(tail) + 1;
	str = memcheck(realloc(start, len));
	strlcat(str, tail, len);
	return str;
}

#define emalloc(size)		memcheck(malloc(size))
#define ereallocarray(ptr, nmemb, size)		memcheck(reallocarray(ptr, nmemb, size))
#define erealloc(ptr, size)	memcheck(realloc((ptr), (size)))
#define ecpyalloc(ptr)		memcheck(strdup(ptr))

/*
** Error handling.
*/

static void
eats(const char *name, int num, const char *rname, int rnum)
{
	filename = name;
	linenum = num;
	rfilename = rname;
	rlinenum = rnum;
}

static void
eat(const char *name, int num)
{
	eats(name, num, NULL, -1);
}

static void
error(const char *string)
{
	/*
	** Match the format of "cc" to allow sh users to
	**	zic ... 2>&1 | error -t "*" -v
	** on BSD systems.
	*/
	fprintf(stderr, "\"%s\", line %d: %s",
		filename, linenum, string);
	if (rfilename != NULL)
		fprintf(stderr, " (rule from \"%s\", line %d)",
			rfilename, rlinenum);
	fprintf(stderr, "\n");
	++errors;
}

static void
warning(const char *string)
{
	char 	*cp;

	cp = ecpyalloc("warning: ");
	cp = ecatalloc(cp, string);
	error(cp);
	free(cp);
	--errors;
}


static const char *
scheck(const char *string, const char *format)
{
	const char 	*fp, *result;
	char 		*fbuf, *tp, dummy;
	int		c;

	result = "";
	if (string == NULL || format == NULL)
		return result;
	fbuf = reallocarray(NULL, strlen(format) + 2, 2);
	if (fbuf == NULL)
		return result;
	fp = format;
	tp = fbuf;
	while ((*tp++ = c = *fp++) != '\0') {
		if (c != '%')
			continue;
		if (*fp == '%') {
			*tp++ = *fp++;
			continue;
		}
		*tp++ = '*';
		if (*fp == '*')
			++fp;
		while (isdigit((unsigned char)*fp))
			*tp++ = *fp++;
		if (*fp == 'l' || *fp == 'h')
			*tp++ = *fp++;
		else if (*fp == '[')
			do {
				*tp++ = *fp++;
			} while (*fp != '\0' && *fp != ']');
		if ((*tp++ = *fp++) == '\0')
			break;
	}
	*(tp - 1) = '%';
	*tp++ = 'c';
	*tp = '\0';
	if (sscanf(string, fbuf, &dummy) != 1)
		result = format;
	free(fbuf);
	return result;
}

static void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-v] [-d directory] [-L leapsecondfilename] [-l timezone]\n"
	    "\t\t[-p timezone] [-y command] [filename ...]\n",
		__progname);
	exit(EXIT_FAILURE);
}

static const char 	*psxrules;
static const char 	*lcltime;
static const char 	*directory;
static const char 	*leapsec;
static const char 	*yitcommand;

int
main(int argc, char **argv)
{
	int	i, j, c;

	if (pledge("stdio rpath wpath cpath proc exec", NULL) == -1)
		err(1, "pledge");

	umask(umask(S_IWGRP | S_IWOTH) | (S_IWGRP | S_IWOTH));
	while ((c = getopt(argc, argv, "d:l:p:L:vy:")) != -1)
		switch (c) {
			default:
				usage();
			case 'd':
				if (directory == NULL)
					directory = optarg;
				else
					errx(1, "More than one -d option specified");
				break;
			case 'l':
				if (lcltime == NULL)
					lcltime = optarg;
				else
					errx(1, "More than one -l option specified");
				break;
			case 'p':
				if (psxrules == NULL)
					psxrules = optarg;
				else
					errx(1, "More than one -p option specified");
				break;
			case 'y':
				if (yitcommand == NULL)
					yitcommand = optarg;
				else
					errx(1, "More than one -y option specified");
				break;
			case 'L':
				if (leapsec == NULL)
					leapsec = optarg;
				else
					errx(1, "More than one -L option specified");
				break;
			case 'v':
				noise = TRUE;
				break;
		}
	if (optind == argc - 1 && strcmp(argv[optind], "=") == 0)
		usage();	/* usage message by request */
	if (directory == NULL)
		directory = TZDIR;
	if (yitcommand == NULL)
		yitcommand = "yearistype";

	setboundaries();

	if (optind < argc && leapsec != NULL) {
		infile(leapsec);
		adjleap();
	}

	for (i = optind; i < argc; ++i)
		infile(argv[i]);
	if (errors)
		exit(EXIT_FAILURE);
	associate();
	for (i = 0; i < nzones; i = j) {
		/*
		** Find the next non-continuation zone entry.
		*/
		for (j = i + 1; j < nzones && zones[j].z_name == NULL; ++j)
			continue;
		outzone(&zones[i], j - i);
	}
	/*
	** Make links.
	*/
	for (i = 0; i < nlinks; ++i) {
		eat(links[i].l_filename, links[i].l_linenum);
		dolink(links[i].l_from, links[i].l_to);
		if (noise)
			for (j = 0; j < nlinks; ++j)
				if (strcmp(links[i].l_to,
					links[j].l_from) == 0)
						warning("link to link");
	}
	if (lcltime != NULL) {
		eat("command line", 1);
		dolink(lcltime, TZDEFAULT);
	}
	if (psxrules != NULL) {
		eat("command line", 1);
		dolink(psxrules, TZDEFRULES);
	}
	return (errors == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}

static void
dolink(const char *fromfield, const char *tofield)
{
	char 	*fromname, *toname;

	if (fromfield[0] == '/')
		fromname = ecpyalloc(fromfield);
	else {
		fromname = ecpyalloc(directory);
		fromname = ecatalloc(fromname, "/");
		fromname = ecatalloc(fromname, fromfield);
	}
	if (tofield[0] == '/')
		toname = ecpyalloc(tofield);
	else {
		toname = ecpyalloc(directory);
		toname = ecatalloc(toname, "/");
		toname = ecatalloc(toname, tofield);
	}
	/*
	** We get to be careful here since
	** there's a fair chance of root running us.
	*/
	if (!itsdir(toname))
		remove(toname);
	if (link(fromname, toname) != 0) {
		int	result;

		if (mkdirs(toname) != 0)
			exit(EXIT_FAILURE);

		result = link(fromname, toname);
		if (result != 0 && errno == EXDEV)
			result = symlink(fromname, toname);
		if (result != 0)
			err(1, "Can't link from %s to %s", fromname, toname);
	}
	free(fromname);
	free(toname);
}

#define TIME_T_BITS_IN_FILE	64

static void
setboundaries(void)
{
	int	i;

	min_time = -1;
	for (i = 0; i < TIME_T_BITS_IN_FILE - 1; ++i)
		min_time *= 2;
	max_time = -(min_time + 1);
}

static int
itsdir(const char *name)
{
	char 	*myname;
	int	accres;

	myname = ecpyalloc(name);
	myname = ecatalloc(myname, "/.");
	accres = access(myname, F_OK);
	free(myname);
	return accres == 0;
}

/*
** Associate sets of rules with zones.
*/

/*
** Sort by rule name.
*/

static int
rcomp(const void *cp1, const void *cp2)
{
	return strcmp(((const struct rule *) cp1)->r_name,
		((const struct rule *) cp2)->r_name);
}

static void
associate(void)
{
	struct zone 	*zp;
	struct rule 	*rp;
	int		base, out, i, j;

	if (nrules != 0) {
		qsort(rules, nrules, sizeof *rules, rcomp);
		for (i = 0; i < nrules - 1; ++i) {
			if (strcmp(rules[i].r_name,
				rules[i + 1].r_name) != 0)
					continue;
			if (strcmp(rules[i].r_filename,
				rules[i + 1].r_filename) == 0)
					continue;
			eat(rules[i].r_filename, rules[i].r_linenum);
			warning("same rule name in multiple files");
			eat(rules[i + 1].r_filename, rules[i + 1].r_linenum);
			warning("same rule name in multiple files");
			for (j = i + 2; j < nrules; ++j) {
				if (strcmp(rules[i].r_name,
					rules[j].r_name) != 0)
						break;
				if (strcmp(rules[i].r_filename,
					rules[j].r_filename) == 0)
						continue;
				if (strcmp(rules[i + 1].r_filename,
					rules[j].r_filename) == 0)
						continue;
				break;
			}
			i = j - 1;
		}
	}
	for (i = 0; i < nzones; ++i) {
		zp = &zones[i];
		zp->z_rules = NULL;
		zp->z_nrules = 0;
	}
	for (base = 0; base < nrules; base = out) {
		rp = &rules[base];
		for (out = base + 1; out < nrules; ++out)
			if (strcmp(rp->r_name, rules[out].r_name) != 0)
				break;
		for (i = 0; i < nzones; ++i) {
			zp = &zones[i];
			if (strcmp(zp->z_rule, rp->r_name) != 0)
				continue;
			zp->z_rules = rp;
			zp->z_nrules = out - base;
		}
	}
	for (i = 0; i < nzones; ++i) {
		zp = &zones[i];
		if (zp->z_nrules == 0) {
			/*
			** Maybe we have a local standard time offset.
			*/
			eat(zp->z_filename, zp->z_linenum);
			zp->z_stdoff = gethms(zp->z_rule, "unruly zone",
				TRUE);
			/*
			** Note, though, that if there's no rule,
			** a '%s' in the format is a bad thing.
			*/
			if (strchr(zp->z_format, '%') != 0)
				error("%s in ruleless zone");
		}
	}
	if (errors)
		exit(EXIT_FAILURE);
}

static void
infile(const char *name)
{
	FILE 			*fp;
	char			**fields, *cp;
	const struct lookup 	*lp;
	int			nfields, wantcont, num;
	char			buf[BUFSIZ];

	if (strcmp(name, "-") == 0) {
		name = "standard input";
		fp = stdin;
	} else if ((fp = fopen(name, "r")) == NULL)
		err(1, "Can't open %s", name);
	wantcont = FALSE;
	for (num = 1; ; ++num) {
		eat(name, num);
		if (fgets(buf, sizeof buf, fp) != buf)
			break;
		cp = strchr(buf, '\n');
		if (cp == NULL) {
			error("line too long");
			exit(EXIT_FAILURE);
		}
		*cp = '\0';
		fields = getfields(buf);
		nfields = 0;
		while (fields[nfields] != NULL) {
			static char	nada;

			if (strcmp(fields[nfields], "-") == 0)
				fields[nfields] = &nada;
			++nfields;
		}
		if (nfields == 0) {
			/* nothing to do */
		} else if (wantcont) {
			wantcont = inzcont(fields, nfields);
		} else {
			lp = byword(fields[0], line_codes);
			if (lp == NULL)
				error("input line of unknown type");
			else switch ((int) (lp->l_value)) {
				case LC_RULE:
					inrule(fields, nfields);
					wantcont = FALSE;
					break;
				case LC_ZONE:
					wantcont = inzone(fields, nfields);
					break;
				case LC_LINK:
					inlink(fields, nfields);
					wantcont = FALSE;
					break;
				case LC_LEAP:
					if (name != leapsec)
						fprintf(stderr,
						    "%s: Leap line in non leap seconds file %s\n",
							__progname, name);
						/* no exit? */
					else
						inleap(fields, nfields);
					wantcont = FALSE;
					break;
				default:	/* "cannot happen" */
					errx(1, "panic: Invalid l_value %d", lp->l_value);
			}
		}
		free(fields);
	}
	if (ferror(fp))
		errx(1, "Error reading %s", filename);
	if (fp != stdin && fclose(fp))
		err(1, "Error closing %s", filename);
	if (wantcont)
		error("expected continuation line not found");
}

/*
** Convert a string of one of the forms
**	h	-h	hh:mm	-hh:mm	hh:mm:ss	-hh:mm:ss
** into a number of seconds.
** A null string maps to zero.
** Call error with errstring and return zero on errors.
*/

static long
gethms(const char *string, const char *errstring, int signable)
{
	long	hh;
	int	mm, ss, sign;

	if (string == NULL || *string == '\0')
		return 0;
	if (!signable)
		sign = 1;
	else if (*string == '-') {
		sign = -1;
		++string;
	} else
		sign = 1;
	if (sscanf(string, scheck(string, "%ld"), &hh) == 1)
		mm = ss = 0;
	else if (sscanf(string, scheck(string, "%ld:%d"), &hh, &mm) == 2)
		ss = 0;
	else if (sscanf(string, scheck(string, "%ld:%d:%d"),
	    &hh, &mm, &ss) != 3) {
		error(errstring);
		return 0;
	}
	if (hh < 0 ||
	    mm < 0 || mm >= MINSPERHOUR ||
	    ss < 0 || ss > SECSPERMIN) {
		error(errstring);
		return 0;
	}
	if (LONG_MAX / SECSPERHOUR < hh) {
		error("time overflow");
		return 0;
	}
	return oadd(eitol(sign) * hh * eitol(SECSPERHOUR),
	    eitol(sign) * (eitol(mm) * eitol(SECSPERMIN) + eitol(ss)));
}

static void
inrule(char **fields, int nfields)
{
	static struct rule	r;

	if (nfields != RULE_FIELDS) {
		error("wrong number of fields on Rule line");
		return;
	}
	if (*fields[RF_NAME] == '\0') {
		error("nameless rule");
		return;
	}
	r.r_filename = filename;
	r.r_linenum = linenum;
	r.r_stdoff = gethms(fields[RF_STDOFF], "invalid saved time", TRUE);
	rulesub(&r, fields[RF_LOYEAR], fields[RF_HIYEAR], fields[RF_COMMAND],
		fields[RF_MONTH], fields[RF_DAY], fields[RF_TOD]);
	r.r_name = ecpyalloc(fields[RF_NAME]);
	r.r_abbrvar = ecpyalloc(fields[RF_ABBRVAR]);
	if (max_abbrvar_len < strlen(r.r_abbrvar))
		max_abbrvar_len = strlen(r.r_abbrvar);
	rules = ereallocarray(rules, nrules + 1, sizeof *rules);
	rules[nrules++] = r;
}

static int
inzone(char **fields, int nfields)
{
	int	i;
	static char 	*buf;
	size_t		len;

	if (nfields < ZONE_MINFIELDS || nfields > ZONE_MAXFIELDS) {
		error("wrong number of fields on Zone line");
		return FALSE;
	}
	if (strcmp(fields[ZF_NAME], TZDEFAULT) == 0 && lcltime != NULL) {
		len = 132 + strlen(TZDEFAULT);
		buf = erealloc(buf, len);
		snprintf(buf, len,
		    "\"Zone %s\" line and -l option are mutually exclusive",
		    TZDEFAULT);
		error(buf);
		return FALSE;
	}
	if (strcmp(fields[ZF_NAME], TZDEFRULES) == 0 && psxrules != NULL) {
		len = 132 + strlen(TZDEFRULES);
		buf = erealloc(buf, len);
		snprintf(buf, len,
		    "\"Zone %s\" line and -p option are mutually exclusive",
		    TZDEFRULES);
		error(buf);
		return FALSE;
	}
	for (i = 0; i < nzones; ++i)
		if (zones[i].z_name != NULL &&
		    strcmp(zones[i].z_name, fields[ZF_NAME]) == 0) {
			len = 132 + strlen(fields[ZF_NAME]) +
			    strlen(zones[i].z_filename);
			buf = erealloc(buf, len);
			snprintf(buf, len,
			    "duplicate zone name %s (file \"%s\", line %d)",
			    fields[ZF_NAME],
			    zones[i].z_filename,
			    zones[i].z_linenum);
			error(buf);
			return FALSE;
		}
	return inzsub(fields, nfields, FALSE);
}

static int
inzcont(char **fields, int nfields)
{
	if (nfields < ZONEC_MINFIELDS || nfields > ZONEC_MAXFIELDS) {
		error("wrong number of fields on Zone continuation line");
		return FALSE;
	}
	return inzsub(fields, nfields, TRUE);
}

static int
inzsub(char **fields, int nfields, int iscont)
{
	char 		*cp;
	static struct zone	z;
	int		i_gmtoff, i_rule, i_format;
	int		i_untilyear, i_untilmonth;
	int		i_untilday, i_untiltime;
	int		hasuntil;

	if (iscont) {
		i_gmtoff = ZFC_GMTOFF;
		i_rule = ZFC_RULE;
		i_format = ZFC_FORMAT;
		i_untilyear = ZFC_TILYEAR;
		i_untilmonth = ZFC_TILMONTH;
		i_untilday = ZFC_TILDAY;
		i_untiltime = ZFC_TILTIME;
		z.z_name = NULL;
	} else {
		i_gmtoff = ZF_GMTOFF;
		i_rule = ZF_RULE;
		i_format = ZF_FORMAT;
		i_untilyear = ZF_TILYEAR;
		i_untilmonth = ZF_TILMONTH;
		i_untilday = ZF_TILDAY;
		i_untiltime = ZF_TILTIME;
		z.z_name = ecpyalloc(fields[ZF_NAME]);
	}
	z.z_filename = filename;
	z.z_linenum = linenum;
	z.z_gmtoff = gethms(fields[i_gmtoff], "invalid UTC offset", TRUE);
	if ((cp = strchr(fields[i_format], '%')) != 0) {
		if (*++cp != 's' || strchr(cp, '%') != 0) {
			error("invalid abbreviation format");
			return FALSE;
		}
	}
	z.z_rule = ecpyalloc(fields[i_rule]);
	z.z_format = ecpyalloc(fields[i_format]);
	if (max_format_len < strlen(z.z_format))
		max_format_len = strlen(z.z_format);
	hasuntil = nfields > i_untilyear;
	if (hasuntil) {
		z.z_untilrule.r_filename = filename;
		z.z_untilrule.r_linenum = linenum;
		rulesub(&z.z_untilrule,
			fields[i_untilyear],
			"only",
			"",
			(nfields > i_untilmonth) ?
			fields[i_untilmonth] : "Jan",
			(nfields > i_untilday) ? fields[i_untilday] : "1",
			(nfields > i_untiltime) ? fields[i_untiltime] : "0");
		z.z_untiltime = rpytime(&z.z_untilrule,
			z.z_untilrule.r_loyear);
		if (iscont && nzones > 0 &&
		    z.z_untiltime > min_time &&
		    z.z_untiltime < max_time &&
		    zones[nzones - 1].z_untiltime > min_time &&
		    zones[nzones - 1].z_untiltime < max_time &&
		    zones[nzones - 1].z_untiltime >= z.z_untiltime) {
			error("Zone continuation line end time is not after end time of previous line");
			return FALSE;
		}
	}
	zones = ereallocarray(zones, nzones + 1, sizeof *zones);
	zones[nzones++] = z;
	/*
	** If there was an UNTIL field on this line,
	** there's more information about the zone on the next line.
	*/
	return hasuntil;
}

static void
inleap(char **fields, int nfields)
{
	const char 		*cp;
	const struct lookup 	*lp;
	int			i, j;
	int			year, month, day;
	long			dayoff, tod;
	zic_t			t;

	if (nfields != LEAP_FIELDS) {
		error("wrong number of fields on Leap line");
		return;
	}
	dayoff = 0;
	cp = fields[LP_YEAR];
	if (sscanf(cp, scheck(cp, "%d"), &year) != 1) {
		/*
		** Leapin' Lizards!
		*/
		error("invalid leaping year");
		return;
	}
	if (!leapseen || leapmaxyear < year)
		leapmaxyear = year;
	if (!leapseen || leapminyear > year)
		leapminyear = year;
	leapseen = TRUE;
	j = EPOCH_YEAR;
	while (j != year) {
		if (year > j) {
			i = len_years[isleap(j)];
			++j;
		} else {
			--j;
			i = -len_years[isleap(j)];
		}
		dayoff = oadd(dayoff, eitol(i));
	}
	if ((lp = byword(fields[LP_MONTH], mon_names)) == NULL) {
		error("invalid month name");
		return;
	}
	month = lp->l_value;
	j = TM_JANUARY;
	while (j != month) {
		i = len_months[isleap(year)][j];
		dayoff = oadd(dayoff, eitol(i));
		++j;
	}
	cp = fields[LP_DAY];
	if (sscanf(cp, scheck(cp, "%d"), &day) != 1 ||
	    day <= 0 || day > len_months[isleap(year)][month]) {
		error("invalid day of month");
		return;
	}
	dayoff = oadd(dayoff, eitol(day - 1));
	if (dayoff < 0 && !TYPE_SIGNED(zic_t)) {
		error("time before zero");
		return;
	}
	if (dayoff < min_time / SECSPERDAY) {
		error("time too small");
		return;
	}
	if (dayoff > max_time / SECSPERDAY) {
		error("time too large");
		return;
	}
	t = (zic_t) dayoff * SECSPERDAY;
	tod = gethms(fields[LP_TIME], "invalid time of day", FALSE);
	cp = fields[LP_CORR];
	{
		int	positive;
		int		count;

		if (strcmp(cp, "") == 0) { /* infile() turns "-" into "" */
			positive = FALSE;
			count = 1;
		} else if (strcmp(cp, "--") == 0) {
			positive = FALSE;
			count = 2;
		} else if (strcmp(cp, "+") == 0) {
			positive = TRUE;
			count = 1;
		} else if (strcmp(cp, "++") == 0) {
			positive = TRUE;
			count = 2;
		} else {
			error("illegal CORRECTION field on Leap line");
			return;
		}
		if ((lp = byword(fields[LP_ROLL], leap_types)) == NULL) {
			error("illegal Rolling/Stationary field on Leap line");
			return;
		}
		leapadd(tadd(t, tod), positive, lp->l_value, count);
	}
}

static void
inlink(char **fields, int nfields)
{
	struct link	l;

	if (nfields != LINK_FIELDS) {
		error("wrong number of fields on Link line");
		return;
	}
	if (*fields[LF_FROM] == '\0') {
		error("blank FROM field on Link line");
		return;
	}
	if (*fields[LF_TO] == '\0') {
		error("blank TO field on Link line");
		return;
	}
	l.l_filename = filename;
	l.l_linenum = linenum;
	l.l_from = ecpyalloc(fields[LF_FROM]);
	l.l_to = ecpyalloc(fields[LF_TO]);
	links = ereallocarray(links, nlinks + 1, sizeof *links);
	links[nlinks++] = l;
}

static void
rulesub(struct rule * const rp, const char * const loyearp,
    const char * const hiyearp, const char * const typep,
    const char * const monthp, const char * const dayp,
    const char * const timep)
{
	const struct lookup 	*lp;
	const char 		*cp;
	char 			*dp, *ep;

	if ((lp = byword(monthp, mon_names)) == NULL) {
		error("invalid month name");
		return;
	}
	rp->r_month = lp->l_value;
	rp->r_todisstd = FALSE;
	rp->r_todisgmt = FALSE;
	dp = ecpyalloc(timep);
	if (*dp != '\0') {
		ep = dp + strlen(dp) - 1;
		switch (tolower((unsigned char)*ep)) {
		case 's':	/* Standard */
			rp->r_todisstd = TRUE;
			rp->r_todisgmt = FALSE;
			*ep = '\0';
			break;
		case 'w':	/* Wall */
			rp->r_todisstd = FALSE;
			rp->r_todisgmt = FALSE;
			*ep = '\0';
			break;
		case 'g':	/* Greenwich */
		case 'u':	/* Universal */
		case 'z':	/* Zulu */
			rp->r_todisstd = TRUE;
			rp->r_todisgmt = TRUE;
			*ep = '\0';
			break;
		}
	}
	rp->r_tod = gethms(dp, "invalid time of day", FALSE);
	free(dp);
	/*
	** Year work.
	*/
	cp = loyearp;
	lp = byword(cp, begin_years);
	rp->r_lowasnum = lp == NULL;
	if (!rp->r_lowasnum) switch ((int) lp->l_value) {
		case YR_MINIMUM:
			rp->r_loyear = INT_MIN;
			break;
		case YR_MAXIMUM:
			rp->r_loyear = INT_MAX;
			break;
		default:	/* "cannot happen" */
			errx(1, "panic: Invalid l_value %d", lp->l_value);
	} else if (sscanf(cp, scheck(cp, "%d"), &rp->r_loyear) != 1) {
		error("invalid starting year");
		return;
	}
	cp = hiyearp;
	lp = byword(cp, end_years);
	rp->r_hiwasnum = lp == NULL;
	if (!rp->r_hiwasnum) switch ((int) lp->l_value) {
		case YR_MINIMUM:
			rp->r_hiyear = INT_MIN;
			break;
		case YR_MAXIMUM:
			rp->r_hiyear = INT_MAX;
			break;
		case YR_ONLY:
			rp->r_hiyear = rp->r_loyear;
			break;
		default:	/* "cannot happen" */
			errx(1, "panic: Invalid l_value %d", lp->l_value);
	} else if (sscanf(cp, scheck(cp, "%d"), &rp->r_hiyear) != 1) {
		error("invalid ending year");
		return;
	}
	if (rp->r_loyear > rp->r_hiyear) {
		error("starting year greater than ending year");
		return;
	}
	if (*typep == '\0')
		rp->r_yrtype = NULL;
	else {
		if (rp->r_loyear == rp->r_hiyear) {
			error("typed single year");
			return;
		}
		rp->r_yrtype = ecpyalloc(typep);
	}
	/*
	** Day work.
	** Accept things such as:
	**	1
	**	last-Sunday
	**	Sun<=20
	**	Sun>=7
	*/
	dp = ecpyalloc(dayp);
	if ((lp = byword(dp, lasts)) != NULL) {
		rp->r_dycode = DC_DOWLEQ;
		rp->r_wday = lp->l_value;
		rp->r_dayofmonth = len_months[1][rp->r_month];
	} else {
		if ((ep = strchr(dp, '<')) != 0)
			rp->r_dycode = DC_DOWLEQ;
		else if ((ep = strchr(dp, '>')) != 0)
			rp->r_dycode = DC_DOWGEQ;
		else {
			ep = dp;
			rp->r_dycode = DC_DOM;
		}
		if (rp->r_dycode != DC_DOM) {
			*ep++ = 0;
			if (*ep++ != '=') {
				error("invalid day of month");
				free(dp);
				return;
			}
			if ((lp = byword(dp, wday_names)) == NULL) {
				error("invalid weekday name");
				free(dp);
				return;
			}
			rp->r_wday = lp->l_value;
		}
		if (sscanf(ep, scheck(ep, "%d"), &rp->r_dayofmonth) != 1 ||
		    rp->r_dayofmonth <= 0 ||
		    (rp->r_dayofmonth > len_months[1][rp->r_month])) {
			error("invalid day of month");
			free(dp);
			return;
		}
	}
	free(dp);
}

static void
convert(long val, char *buf)
{
	int	i;
	int	shift;

	for (i = 0, shift = 24; i < 4; ++i, shift -= 8)
		buf[i] = val >> shift;
}

static void
convert64(zic_t val, char *buf)
{
	int	i;
	int	shift;

	for (i = 0, shift = 56; i < 8; ++i, shift -= 8)
		buf[i] = val >> shift;
}

static void
puttzcode(long val, FILE *fp)
{
	char	buf[4];

	convert(val, buf);
	fwrite(buf, sizeof buf, 1, fp);
}

static void
puttzcode64(zic_t val, FILE *fp)
{
	char	buf[8];

	convert64(val, buf);
	fwrite(buf, sizeof buf, 1, fp);
}

static int
atcomp(const void *avp, const void *bvp)
{
	const zic_t	a = ((const struct attype *) avp)->at;
	const zic_t	b = ((const struct attype *) bvp)->at;

	return (a < b) ? -1 : (a > b);
}

static int
is32(zic_t x)
{
	return INT32_MIN <= x && x <= INT32_MAX;
}

static void
writezone(const char *name, const char *string)
{
	FILE 			*fp;
	int			i, j;
	int			leapcnt32, leapi32;
	int			timecnt32, timei32;
	int			pass;
	static char 		*fullname;
	static const struct tzhead	tzh0;
	static struct tzhead	tzh;
	zic_t			ats[TZ_MAX_TIMES];
	unsigned char		types[TZ_MAX_TIMES];
	size_t			len;

	/*
	** Sort.
	*/
	if (timecnt > 1)
		qsort(attypes, timecnt, sizeof *attypes, atcomp);
	/*
	** Optimize.
	*/
	{
		int	fromi;
		int	toi;

		toi = 0;
		fromi = 0;
		while (fromi < timecnt && attypes[fromi].at < min_time)
			++fromi;
		if (isdsts[0] == 0)
			while (fromi < timecnt && attypes[fromi].type == 0)
				++fromi;	/* handled by default rule */
		for ( ; fromi < timecnt; ++fromi) {
			if (toi != 0 && ((attypes[fromi].at +
			    gmtoffs[attypes[toi - 1].type]) <=
			    (attypes[toi - 1].at + gmtoffs[toi == 1 ? 0 :
			    attypes[toi - 2].type]))) {
				attypes[toi - 1].type = attypes[fromi].type;
				continue;
			}
			if (toi == 0 ||
			    attypes[toi - 1].type != attypes[fromi].type)
				attypes[toi++] = attypes[fromi];
		}
		timecnt = toi;
	}
	/*
	** Transfer.
	*/
	for (i = 0; i < timecnt; ++i) {
		ats[i] = attypes[i].at;
		types[i] = attypes[i].type;
	}
	/*
	** Correct for leap seconds.
	*/
	for (i = 0; i < timecnt; ++i) {
		j = leapcnt;
		while (--j >= 0)
			if (ats[i] > trans[j] - corr[j]) {
				ats[i] = tadd(ats[i], corr[j]);
				break;
			}
	}
	/*
	** Figure out 32-bit-limited starts and counts.
	*/
	timecnt32 = timecnt;
	timei32 = 0;
	leapcnt32 = leapcnt;
	leapi32 = 0;
	while (timecnt32 > 0 && !is32(ats[timecnt32 - 1]))
		--timecnt32;
	while (timecnt32 > 0 && !is32(ats[timei32])) {
		--timecnt32;
		++timei32;
	}
	while (leapcnt32 > 0 && !is32(trans[leapcnt32 - 1]))
		--leapcnt32;
	while (leapcnt32 > 0 && !is32(trans[leapi32])) {
		--leapcnt32;
		++leapi32;
	}
	len = strlen(directory) + 1 + strlen(name) + 1;
	fullname = erealloc(fullname, len);
	snprintf(fullname, len, "%s/%s", directory, name);
	/*
	** Remove old file, if any, to snap links.
	*/
	if (!itsdir(fullname) && remove(fullname) != 0 && errno != ENOENT)
		err(1, "Can't remove %s", fullname);
	if ((fp = fopen(fullname, "wb")) == NULL) {
		if (mkdirs(fullname) != 0)
			exit(EXIT_FAILURE);
		if ((fp = fopen(fullname, "wb")) == NULL)
			err(1, "Can't create %s", fullname);
	}
	for (pass = 1; pass <= 2; ++pass) {
		int	thistimei, thistimecnt;
		int	thisleapi, thisleapcnt;
		int	thistimelim, thisleaplim;
		int	writetype[TZ_MAX_TIMES];
		int	typemap[TZ_MAX_TYPES];
		int	thistypecnt;
		char	thischars[TZ_MAX_CHARS];
		char	thischarcnt;
		int 	indmap[TZ_MAX_CHARS];

		if (pass == 1) {
			thistimei = timei32;
			thistimecnt = timecnt32;
			thisleapi = leapi32;
			thisleapcnt = leapcnt32;
		} else {
			thistimei = 0;
			thistimecnt = timecnt;
			thisleapi = 0;
			thisleapcnt = leapcnt;
		}
		thistimelim = thistimei + thistimecnt;
		thisleaplim = thisleapi + thisleapcnt;
		for (i = 0; i < typecnt; ++i)
			writetype[i] = thistimecnt == timecnt;
		if (thistimecnt == 0) {
			/*
			** No transition times fall in the current
			** (32- or 64-bit) window.
			*/
			if (typecnt != 0)
				writetype[typecnt - 1] = TRUE;
		} else {
			for (i = thistimei - 1; i < thistimelim; ++i)
				if (i >= 0)
					writetype[types[i]] = TRUE;
			/*
			** For America/Godthab and Antarctica/Palmer
			*/
			if (thistimei == 0)
				writetype[0] = TRUE;
		}
#ifndef LEAVE_SOME_PRE_2011_SYSTEMS_IN_THE_LURCH
		/*
		** For some pre-2011 systems: if the last-to-be-written
		** standard (or daylight) type has an offset different from the
		** most recently used offset,
		** append an (unused) copy of the most recently used type
		** (to help get global "altzone" and "timezone" variables
		** set correctly).
		*/
		{
			int	mrudst, mrustd, hidst, histd, type;

			hidst = histd = mrudst = mrustd = -1;
			for (i = thistimei; i < thistimelim; ++i)
				if (isdsts[types[i]])
					mrudst = types[i];
				else
					mrustd = types[i];
			for (i = 0; i < typecnt; ++i)
				if (writetype[i]) {
					if (isdsts[i])
						hidst = i;
					else
						histd = i;
				}
			if (hidst >= 0 && mrudst >= 0 && hidst != mrudst &&
			    gmtoffs[hidst] != gmtoffs[mrudst]) {
				isdsts[mrudst] = -1;
				type = addtype(gmtoffs[mrudst],
				    &chars[abbrinds[mrudst]],
				    TRUE, ttisstds[mrudst],
				    ttisgmts[mrudst]);
				isdsts[mrudst] = TRUE;
				writetype[type] = TRUE;
			}
			if (histd >= 0 && mrustd >= 0 && histd != mrustd &&
			    gmtoffs[histd] != gmtoffs[mrustd]) {
				isdsts[mrustd] = -1;
				type = addtype(gmtoffs[mrustd],
				    &chars[abbrinds[mrustd]],
				    FALSE, ttisstds[mrustd],
				    ttisgmts[mrustd]);
				isdsts[mrustd] = FALSE;
				writetype[type] = TRUE;
			}
		}
#endif /* !defined LEAVE_SOME_PRE_2011_SYSTEMS_IN_THE_LURCH */
		thistypecnt = 0;
		for (i = 0; i < typecnt; ++i)
			typemap[i] = writetype[i] ?  thistypecnt++ : -1;
		for (i = 0; i < sizeof indmap / sizeof indmap[0]; ++i)
			indmap[i] = -1;
		thischarcnt = 0;
		for (i = 0; i < typecnt; ++i) {
			char 	*thisabbr;

			if (!writetype[i])
				continue;
			if (indmap[abbrinds[i]] >= 0)
				continue;
			thisabbr = &chars[abbrinds[i]];
			for (j = 0; j < thischarcnt; ++j)
				if (strcmp(&thischars[j], thisabbr) == 0)
					break;
			if (j == thischarcnt) {
				strlcpy(&thischars[(int) thischarcnt],
				    thisabbr, sizeof(thischars) - thischarcnt);
				thischarcnt += strlen(thisabbr) + 1;
			}
			indmap[abbrinds[i]] = j;
		}
#define DO(field)	fwrite(tzh.field, sizeof tzh.field, 1, fp)
		tzh = tzh0;
		strncpy(tzh.tzh_magic, TZ_MAGIC, sizeof tzh.tzh_magic);
		tzh.tzh_version[0] = ZIC_VERSION;
		convert(eitol(thistypecnt), tzh.tzh_ttisgmtcnt);
		convert(eitol(thistypecnt), tzh.tzh_ttisstdcnt);
		convert(eitol(thisleapcnt), tzh.tzh_leapcnt);
		convert(eitol(thistimecnt), tzh.tzh_timecnt);
		convert(eitol(thistypecnt), tzh.tzh_typecnt);
		convert(eitol(thischarcnt), tzh.tzh_charcnt);
		DO(tzh_magic);
		DO(tzh_version);
		DO(tzh_reserved);
		DO(tzh_ttisgmtcnt);
		DO(tzh_ttisstdcnt);
		DO(tzh_leapcnt);
		DO(tzh_timecnt);
		DO(tzh_typecnt);
		DO(tzh_charcnt);
#undef DO
		for (i = thistimei; i < thistimelim; ++i)
			if (pass == 1)
				puttzcode((long) ats[i], fp);
			else
				puttzcode64(ats[i], fp);
		for (i = thistimei; i < thistimelim; ++i) {
			unsigned char	uc;

			uc = typemap[types[i]];
			fwrite(&uc, sizeof uc, 1, fp);
		}
		for (i = 0; i < typecnt; ++i)
			if (writetype[i]) {
				puttzcode(gmtoffs[i], fp);
				putc(isdsts[i], fp);
				putc((unsigned char)indmap[abbrinds[i]], fp);
			}
		if (thischarcnt != 0)
			fwrite(thischars, sizeof thischars[0], thischarcnt, fp);
		for (i = thisleapi; i < thisleaplim; ++i) {
			zic_t	todo;

			if (roll[i]) {
				if (timecnt == 0 || trans[i] < ats[0]) {
					j = 0;
					while (isdsts[j])
						if (++j >= typecnt) {
							j = 0;
							break;
						}
				} else {
					j = 1;
					while (j < timecnt &&
					    trans[i] >= ats[j])
						++j;
					j = types[j - 1];
				}
				todo = tadd(trans[i], -gmtoffs[j]);
			} else
				todo = trans[i];
			if (pass == 1)
				puttzcode((long) todo, fp);
			else
				puttzcode64(todo, fp);
			puttzcode(corr[i], fp);
		}
		for (i = 0; i < typecnt; ++i)
			if (writetype[i])
				putc(ttisstds[i], fp);
		for (i = 0; i < typecnt; ++i)
			if (writetype[i])
				putc(ttisgmts[i], fp);
	}
	fprintf(fp, "\n%s\n", string);
	if (ferror(fp) || fclose(fp))
		errx(1, "Error writing %s", fullname);
}

static void
doabbr(char *abbr, size_t size, const char *format, const char *letters,
    int isdst, int doquotes)
{
	char 	*cp, *slashp;
	int	len;

	slashp = strchr(format, '/');
	if (slashp == NULL) {
		if (letters == NULL)
			strlcpy(abbr, format, size);
		else
			snprintf(abbr, size, format, letters);
	} else if (isdst) {
		strlcpy(abbr, slashp + 1, size);
	} else {
		if (slashp - format + 1 < size)
			size = slashp - format + 1;
		strlcpy(abbr, format, size);
	}
	if (!doquotes)
		return;
	for (cp = abbr; *cp != '\0'; ++cp)
		if (strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", *cp) == NULL &&
			strchr("abcdefghijklmnopqrstuvwxyz", *cp) == NULL)
				break;
	len = strlen(abbr);
	if (len > 0 && *cp == '\0')
		return;
	abbr[len + 2] = '\0';
	abbr[len + 1] = '>';
	for ( ; len > 0; --len)
		abbr[len] = abbr[len - 1];
	abbr[0] = '<';
}

static void
updateminmax(int x)
{
	if (min_year > x)
		min_year = x;
	if (max_year < x)
		max_year = x;
}

static int
stringoffset(char *result, size_t size, long offset)
{
	int	hours, minutes, seconds;
	char 	*ep;

	result[0] = '\0';
	if (offset < 0) {
		strlcpy(result, "-", size);
		offset = -offset;
	}
	seconds = offset % SECSPERMIN;
	offset /= SECSPERMIN;
	minutes = offset % MINSPERHOUR;
	offset /= MINSPERHOUR;
	hours = offset;
	if (hours >= HOURSPERDAY) {
		result[0] = '\0';
		return -1;
	}
	ep = end(result, size);
	snprintf(ep, size - (ep - result), "%d", hours);
	if (minutes != 0 || seconds != 0) {
		ep = end(result, size);
		snprintf(ep, size - (ep - result), ":%02d", minutes);
		if (seconds != 0) {
			ep = end(result, size);
			snprintf(ep, size - (ep - result), ":%02d", seconds);
		}
	}
	return 0;
}

static int
stringrule(char *result, size_t size, const struct rule *rp, long dstoff, long gmtoff)
{
	long	tod;
	char 	*ep;

	ep = end(result, size);
	size -= ep - result;
	result = ep;
	if (rp->r_dycode == DC_DOM) {
		int	month, total;

		if (rp->r_dayofmonth == 29 && rp->r_month == TM_FEBRUARY)
			return -1;
		total = 0;
		for (month = 0; month < rp->r_month; ++month)
			total += len_months[0][month];
		snprintf(result, size, "J%d", total + rp->r_dayofmonth);
	} else {
		int	week;

		if (rp->r_dycode == DC_DOWGEQ) {
			if ((rp->r_dayofmonth % DAYSPERWEEK) != 1)
				return -1;
			week = 1 + rp->r_dayofmonth / DAYSPERWEEK;
		} else if (rp->r_dycode == DC_DOWLEQ) {
			if (rp->r_dayofmonth == len_months[1][rp->r_month])
				week = 5;
			else {
				if ((rp->r_dayofmonth % DAYSPERWEEK) != 0)
					return -1;
				week = rp->r_dayofmonth / DAYSPERWEEK;
			}
		} else
			return -1;	/* "cannot happen" */
		snprintf(result, size, "M%d.%d.%d",
			rp->r_month + 1, week, rp->r_wday);
	}
	tod = rp->r_tod;
	if (rp->r_todisgmt)
		tod += gmtoff;
	if (rp->r_todisstd && rp->r_stdoff == 0)
		tod += dstoff;
	if (tod < 0) {
		result[0] = '\0';
		return -1;
	}
	if (tod != 2 * SECSPERMIN * MINSPERHOUR) {
		strlcat(result, "/", size);
		ep = end(result, size);
		if (stringoffset(ep, size - (ep - result), tod) != 0)
			return -1;
	}
	return 0;
}

static void
stringzone(char *result, size_t size, const struct zone *zpfirst, int zonecount)
{
	const struct zone 	*zp;
	struct rule 		*rp, *stdrp, *dstrp;
	int			i;
	const char 		*abbrvar;
	char 			*ep;

	result[0] = '\0';
	zp = zpfirst + zonecount - 1;
	stdrp = dstrp = NULL;
	for (i = 0; i < zp->z_nrules; ++i) {
		rp = &zp->z_rules[i];
		if (rp->r_hiwasnum || rp->r_hiyear != INT_MAX)
			continue;
		if (rp->r_yrtype != NULL)
			continue;
		if (rp->r_stdoff == 0) {
			if (stdrp == NULL)
				stdrp = rp;
			else
				return;
		} else {
			if (dstrp == NULL)
				dstrp = rp;
			else
				return;
		}
	}
	if (stdrp == NULL && dstrp == NULL) {
		/*
		** There are no rules running through "max".
		** Let's find the latest rule.
		*/
		for (i = 0; i < zp->z_nrules; ++i) {
			rp = &zp->z_rules[i];
			if (stdrp == NULL || rp->r_hiyear > stdrp->r_hiyear ||
				(rp->r_hiyear == stdrp->r_hiyear &&
				rp->r_month > stdrp->r_month))
					stdrp = rp;
		}
		if (stdrp != NULL && stdrp->r_stdoff != 0)
			return;	/* We end up in DST (a POSIX no-no). */
		/*
		** Horrid special case: if year is 2037,
		** presume this is a zone handled on a year-by-year basis;
		** do not try to apply a rule to the zone.
		*/
		if (stdrp != NULL && stdrp->r_hiyear == 2037)
			return;
	}
	if (stdrp == NULL && (zp->z_nrules != 0 || zp->z_stdoff != 0))
		return;
	abbrvar = (stdrp == NULL) ? "" : stdrp->r_abbrvar;
	doabbr(result, size, zp->z_format, abbrvar, FALSE, TRUE);
	ep = end(result, size);
	if (stringoffset(ep, size - (ep - result), -zp->z_gmtoff) != 0) {
		result[0] = '\0';
		return;
	}
	if (dstrp == NULL)
		return;
	ep = end(result, size);
	doabbr(ep, size - (ep - result), zp->z_format, dstrp->r_abbrvar, TRUE, TRUE);
	if (dstrp->r_stdoff != SECSPERMIN * MINSPERHOUR) {
		ep = end(result, size);
		if (stringoffset(ep, size - (ep - result),
			-(zp->z_gmtoff + dstrp->r_stdoff)) != 0) {
				result[0] = '\0';
				return;
		}
	}
	strlcat(result, ",", size);
	if (stringrule(result, size, dstrp, dstrp->r_stdoff, zp->z_gmtoff) != 0) {
		result[0] = '\0';
		return;
	}
	strlcat(result, ",", size);
	if (stringrule(result, size, stdrp, dstrp->r_stdoff, zp->z_gmtoff) != 0) {
		result[0] = '\0';
		return;
	}
}

static void
outzone(const struct zone *zpfirst, int zonecount)
{
	const struct zone 	*zp;
	struct rule 		*rp;
	int			i, j, usestart, useuntil, type;
	zic_t			starttime = 0, untiltime = 0;
	long			gmtoff, stdoff, startoff;
	int			year, startttisstd = FALSE, startttisgmt = FALSE;
	char 			*startbuf, *ab, *envvar;
	int			max_abbr_len, max_envvar_len;
	int			prodstic; /* all rules are min to max */

	max_abbr_len = 2 + max_format_len + max_abbrvar_len;
	max_envvar_len = 2 * max_abbr_len + 5 * 9;
	startbuf = emalloc(max_abbr_len + 1);
	ab = emalloc(max_abbr_len + 1);
	envvar = emalloc(max_envvar_len + 1);
	/*
	** Now. . .finally. . .generate some useful data!
	*/
	timecnt = 0;
	typecnt = 0;
	charcnt = 0;
	prodstic = zonecount == 1;
	/*
	** Thanks to Earl Chew
	** for noting the need to unconditionally initialize startttisstd.
	*/
	min_year = max_year = EPOCH_YEAR;
	if (leapseen) {
		updateminmax(leapminyear);
		updateminmax(leapmaxyear + (leapmaxyear < INT_MAX));
	}
	for (i = 0; i < zonecount; ++i) {
		zp = &zpfirst[i];
		if (i < zonecount - 1)
			updateminmax(zp->z_untilrule.r_loyear);
		for (j = 0; j < zp->z_nrules; ++j) {
			rp = &zp->z_rules[j];
			if (rp->r_lowasnum)
				updateminmax(rp->r_loyear);
			if (rp->r_hiwasnum)
				updateminmax(rp->r_hiyear);
			if (rp->r_lowasnum || rp->r_hiwasnum)
				prodstic = FALSE;
		}
	}
	/*
	** Generate lots of data if a rule can't cover all future times.
	*/
	stringzone(envvar, max_envvar_len + 1, zpfirst, zonecount);
	if (noise && envvar[0] == '\0') {
		char *	wp;

		wp = ecpyalloc("no POSIX environment variable for zone");
		wp = ecatalloc(wp, " ");
		wp = ecatalloc(wp, zpfirst->z_name);
		warning(wp);
		free(wp);
	}
	if (envvar[0] == '\0') {
		if (min_year >= INT_MIN + YEARSPERREPEAT)
			min_year -= YEARSPERREPEAT;
		else
			min_year = INT_MIN;
		if (max_year <= INT_MAX - YEARSPERREPEAT)
			max_year += YEARSPERREPEAT;
		else
			max_year = INT_MAX;
		/*
		** Regardless of any of the above,
		** for a "proDSTic" zone which specifies that its rules
		** always have and always will be in effect,
		** we only need one cycle to define the zone.
		*/
		if (prodstic) {
			min_year = 1900;
			max_year = min_year + YEARSPERREPEAT;
		}
	}
	/*
	** For the benefit of older systems,
	** generate data from 1900 through 2037.
	*/
	if (min_year > 1900)
		min_year = 1900;
	if (max_year < 2037)
		max_year = 2037;
	for (i = 0; i < zonecount; ++i) {
		/*
		** A guess that may well be corrected later.
		*/
		stdoff = 0;
		zp = &zpfirst[i];
		usestart = i > 0 && (zp - 1)->z_untiltime > min_time;
		useuntil = i < (zonecount - 1);
		if (useuntil && zp->z_untiltime <= min_time)
			continue;
		gmtoff = zp->z_gmtoff;
		eat(zp->z_filename, zp->z_linenum);
		*startbuf = '\0';
		startoff = zp->z_gmtoff;
		if (zp->z_nrules == 0) {
			stdoff = zp->z_stdoff;
			doabbr(startbuf, max_abbr_len + 1, zp->z_format,
				NULL, stdoff != 0, FALSE);
			type = addtype(oadd(zp->z_gmtoff, stdoff),
				startbuf, stdoff != 0, startttisstd,
				startttisgmt);
			if (usestart) {
				addtt(starttime, type);
				usestart = FALSE;
			} else if (stdoff != 0)
				addtt(min_time, type);
		} else for (year = min_year; year <= max_year; ++year) {
			if (useuntil && year > zp->z_untilrule.r_hiyear)
				break;
			/*
			** Mark which rules to do in the current year.
			** For those to do, calculate rpytime(rp, year);
			*/
			for (j = 0; j < zp->z_nrules; ++j) {
				rp = &zp->z_rules[j];
				eats(zp->z_filename, zp->z_linenum,
					rp->r_filename, rp->r_linenum);
				rp->r_todo = year >= rp->r_loyear &&
				    year <= rp->r_hiyear &&
				    yearistype(year, rp->r_yrtype);
				if (rp->r_todo)
					rp->r_temp = rpytime(rp, year);
			}
			for ( ; ; ) {
				int	k;
				zic_t	jtime, ktime = 0;
				long	offset;

				if (useuntil) {
					/*
					** Turn untiltime into UTC
					** assuming the current gmtoff and
					** stdoff values.
					*/
					untiltime = zp->z_untiltime;
					if (!zp->z_untilrule.r_todisgmt)
						untiltime = tadd(untiltime,
							-gmtoff);
					if (!zp->z_untilrule.r_todisstd)
						untiltime = tadd(untiltime,
							-stdoff);
				}
				/*
				** Find the rule (of those to do, if any)
				** that takes effect earliest in the year.
				*/
				k = -1;
				for (j = 0; j < zp->z_nrules; ++j) {
					rp = &zp->z_rules[j];
					if (!rp->r_todo)
						continue;
					eats(zp->z_filename, zp->z_linenum,
						rp->r_filename, rp->r_linenum);
					offset = rp->r_todisgmt ? 0 : gmtoff;
					if (!rp->r_todisstd)
						offset = oadd(offset, stdoff);
					jtime = rp->r_temp;
					if (jtime == min_time ||
						jtime == max_time)
							continue;
					jtime = tadd(jtime, -offset);
					if (k < 0 || jtime < ktime) {
						k = j;
						ktime = jtime;
					}
				}
				if (k < 0)
					break;	/* go on to next year */
				rp = &zp->z_rules[k];
				rp->r_todo = FALSE;
				if (useuntil && ktime >= untiltime)
					break;
				stdoff = rp->r_stdoff;
				if (usestart && ktime == starttime)
					usestart = FALSE;
				if (usestart) {
					if (ktime < starttime) {
						startoff = oadd(zp->z_gmtoff,
						    stdoff);
						doabbr(startbuf,
						    max_abbr_len + 1,
						    zp->z_format,
						    rp->r_abbrvar,
						    rp->r_stdoff != 0,
						    FALSE);
						continue;
					}
					if (*startbuf == '\0' &&
					    startoff == oadd(zp->z_gmtoff,
					    stdoff)) {
						doabbr(startbuf,
						    max_abbr_len + 1,
						    zp->z_format,
						    rp->r_abbrvar,
						    rp->r_stdoff != 0,
						    FALSE);
					}
				}
				eats(zp->z_filename, zp->z_linenum,
				    rp->r_filename, rp->r_linenum);
				doabbr(ab, max_abbr_len + 1, zp->z_format,
				    rp->r_abbrvar, rp->r_stdoff != 0, FALSE);
				offset = oadd(zp->z_gmtoff, rp->r_stdoff);
				type = addtype(offset, ab, rp->r_stdoff != 0,
				    rp->r_todisstd, rp->r_todisgmt);
				addtt(ktime, type);
			}
		}
		if (usestart) {
			if (*startbuf == '\0' &&
			    zp->z_format != NULL &&
			    strchr(zp->z_format, '%') == NULL &&
			    strchr(zp->z_format, '/') == NULL)
				strlcpy(startbuf, zp->z_format, max_abbr_len + 1);
			eat(zp->z_filename, zp->z_linenum);
			if (*startbuf == '\0')
				error("can't determine time zone abbreviation to use just after until time");
			else
				addtt(starttime,
				    addtype(startoff, startbuf,
				    startoff != zp->z_gmtoff,
				    startttisstd, startttisgmt));
		}
		/*
		** Now we may get to set starttime for the next zone line.
		*/
		if (useuntil) {
			startttisstd = zp->z_untilrule.r_todisstd;
			startttisgmt = zp->z_untilrule.r_todisgmt;
			starttime = zp->z_untiltime;
			if (!startttisstd)
				starttime = tadd(starttime, -stdoff);
			if (!startttisgmt)
				starttime = tadd(starttime, -gmtoff);
		}
	}
	writezone(zpfirst->z_name, envvar);
	free(startbuf);
	free(ab);
	free(envvar);
}

static void
addtt(const zic_t starttime, int type)
{
	size_t len;

	if (starttime <= min_time ||
	    (timecnt == 1 && attypes[0].at < min_time)) {
		gmtoffs[0] = gmtoffs[type];
		isdsts[0] = isdsts[type];
		ttisstds[0] = ttisstds[type];
		ttisgmts[0] = ttisgmts[type];
		if (abbrinds[type] != 0) {
			len = strlen(&chars[abbrinds[type]]) + 1;
			memmove(chars, &chars[abbrinds[type]], len);
		}
		abbrinds[0] = 0;
		charcnt = strlen(chars) + 1;
		typecnt = 1;
		timecnt = 0;
		type = 0;
	}
	if (timecnt >= TZ_MAX_TIMES) {
		error("too many transitions?!");
		exit(EXIT_FAILURE);
	}
	attypes[timecnt].at = starttime;
	attypes[timecnt].type = type;
	++timecnt;
}

static int
addtype(long gmtoff, const char *abbr, int isdst, int ttisstd, int ttisgmt)
{
	int	i, j;

	if (isdst != TRUE && isdst != FALSE) {
		error("internal error - addtype called with bad isdst");
		exit(EXIT_FAILURE);
	}
	if (ttisstd != TRUE && ttisstd != FALSE) {
		error("internal error - addtype called with bad ttisstd");
		exit(EXIT_FAILURE);
	}
	if (ttisgmt != TRUE && ttisgmt != FALSE) {
		error("internal error - addtype called with bad ttisgmt");
		exit(EXIT_FAILURE);
	}
	/*
	** See if there's already an entry for this zone type.
	** If so, just return its index.
	*/
	for (i = 0; i < typecnt; ++i) {
		if (gmtoff == gmtoffs[i] && isdst == isdsts[i] &&
		    strcmp(abbr, &chars[abbrinds[i]]) == 0 &&
		    ttisstd == ttisstds[i] &&
		    ttisgmt == ttisgmts[i])
			return i;
	}
	/*
	** There isn't one; add a new one, unless there are already too
	** many.
	*/
	if (typecnt >= TZ_MAX_TYPES) {
		error("too many local time types");
		exit(EXIT_FAILURE);
	}
	if (! (-1L - 2147483647L <= gmtoff && gmtoff <= 2147483647L)) {
		error("UTC offset out of range");
		exit(EXIT_FAILURE);
	}
	gmtoffs[i] = gmtoff;
	isdsts[i] = isdst;
	ttisstds[i] = ttisstd;
	ttisgmts[i] = ttisgmt;

	for (j = 0; j < charcnt; ++j)
		if (strcmp(&chars[j], abbr) == 0)
			break;
	if (j == charcnt)
		newabbr(abbr);
	abbrinds[i] = j;
	++typecnt;
	return i;
}

static void
leapadd(zic_t t, int positive, int rolling, int count)
{
	int	i, j;

	if (leapcnt + (positive ? count : 1) > TZ_MAX_LEAPS) {
		error("too many leap seconds");
		exit(EXIT_FAILURE);
	}
	for (i = 0; i < leapcnt; ++i)
		if (t <= trans[i]) {
			if (t == trans[i]) {
				error("repeated leap second moment");
				exit(EXIT_FAILURE);
			}
			break;
		}
	do {
		for (j = leapcnt; j > i; --j) {
			trans[j] = trans[j - 1];
			corr[j] = corr[j - 1];
			roll[j] = roll[j - 1];
		}
		trans[i] = t;
		corr[i] = positive ? 1L : eitol(-count);
		roll[i] = rolling;
		++leapcnt;
	} while (positive && --count != 0);
}

static void
adjleap(void)
{
	int	i;
	long	last = 0;

	/*
	** propagate leap seconds forward
	*/
	for (i = 0; i < leapcnt; ++i) {
		trans[i] = tadd(trans[i], last);
		last = corr[i] += last;
	}
}

static int
yearistype(int year, const char *type)
{
	static char 	*buf;
	int		result;
	size_t		len;

	if (type == NULL || *type == '\0')
		return TRUE;
	len = 132 + strlen(yitcommand) + strlen(type);
	buf = erealloc(buf, len);
	snprintf(buf, len, "%s %d %s", yitcommand, year, type);
	result = system(buf);
	if (WIFEXITED(result))
		switch (WEXITSTATUS(result)) {
		case 0:
			return TRUE;
		case 1:
			return FALSE;
		}
	error("Wild result from command execution");
	errx(1, "command was '%s', result was %d", buf, result);
}

/* this function is not strncasecmp */
static int
itsabbr(const char *sabbr, const char *sword)
{
	const unsigned char *abbr = sabbr;
	const unsigned char *word = sword;

	if (tolower(*abbr) != tolower(*word))
		return FALSE;
	while (*++abbr != '\0')
		do {
			++word;
			if (*word == '\0')
				return FALSE;
		} while (tolower(*word) != tolower(*abbr));
	return TRUE;
}

static const struct lookup *
byword(const char *word, const struct lookup *table)
{
	const struct lookup 	*foundlp;
	const struct lookup 	*lp;

	if (word == NULL || table == NULL)
		return NULL;
	/*
	** Look for exact match.
	*/
	for (lp = table; lp->l_word != NULL; ++lp)
		if (strcasecmp(word, lp->l_word) == 0)
			return lp;
	/*
	** Look for inexact match.
	*/
	foundlp = NULL;
	for (lp = table; lp->l_word != NULL; ++lp)
		if (itsabbr(word, lp->l_word)) {
			if (foundlp == NULL)
				foundlp = lp;
			else
				return NULL;	/* multiple inexact matches */
		}
	return foundlp;
}

static char **
getfields(char *cp)
{
	char		*dp;
	char		**array;
	int		nsubs;

	if (cp == NULL)
		return NULL;
	array = ereallocarray(NULL, strlen(cp) + 1, sizeof *array);
	nsubs = 0;
	for ( ; ; ) {
		while (isascii((unsigned char)*cp) &&
		    isspace((unsigned char)*cp))
			++cp;
		if (*cp == '\0' || *cp == '#')
			break;
		array[nsubs++] = dp = cp;
		do {
			if ((*dp = *cp++) != '"') {
				++dp;
			} else {
				while ((*dp = *cp++) != '"') {
					if (*dp != '\0')
						++dp;
					else {
						error("Odd number of quotation marks");
						exit(EXIT_FAILURE);
					}
				}
			}
		} while (*cp != '\0' && *cp != '#' &&
		    (!isascii((unsigned char)*cp) || !isspace((unsigned char)*cp)));
		if (isascii((unsigned char)*cp) && isspace((unsigned char)*cp))
			++cp;
		*dp = '\0';
	}
	array[nsubs] = NULL;
	return array;
}

static long
oadd(long t1, long t2)
{
	long	t = t1 + t2;

	if ((t2 > 0 && t <= t1) || (t2 < 0 && t >= t1)) {
		error("time overflow");
		exit(EXIT_FAILURE);
	}
	return t;
}

static zic_t
tadd(zic_t t1, long t2)
{
	zic_t	t;

	if (t1 == max_time && t2 > 0)
		return max_time;
	if (t1 == min_time && t2 < 0)
		return min_time;
	t = t1 + t2;
	if ((t2 > 0 && t <= t1) || (t2 < 0 && t >= t1)) {
		error("time overflow");
		exit(EXIT_FAILURE);
	}
	return t;
}

/*
** Given a rule, and a year, compute the date - in seconds since January 1,
** 1970, 00:00 LOCAL time - in that year that the rule refers to.
*/
static zic_t
rpytime(const struct rule *rp, int wantedy)
{
	int	y, m, i;
	long	dayoff;			/* with a nod to Margaret O. */
	zic_t	t;

	if (wantedy == INT_MIN)
		return min_time;
	if (wantedy == INT_MAX)
		return max_time;
	dayoff = 0;
	m = TM_JANUARY;
	y = EPOCH_YEAR;
	while (wantedy != y) {
		if (wantedy > y) {
			i = len_years[isleap(y)];
			++y;
		} else {
			--y;
			i = -len_years[isleap(y)];
		}
		dayoff = oadd(dayoff, eitol(i));
	}
	while (m != rp->r_month) {
		i = len_months[isleap(y)][m];
		dayoff = oadd(dayoff, eitol(i));
		++m;
	}
	i = rp->r_dayofmonth;
	if (m == TM_FEBRUARY && i == 29 && !isleap(y)) {
		if (rp->r_dycode == DC_DOWLEQ)
			--i;
		else {
			error("use of 2/29 in non leap-year");
			exit(EXIT_FAILURE);
		}
	}
	--i;
	dayoff = oadd(dayoff, eitol(i));
	if (rp->r_dycode == DC_DOWGEQ || rp->r_dycode == DC_DOWLEQ) {
		long	wday;

#define LDAYSPERWEEK	((long) DAYSPERWEEK)
		wday = eitol(EPOCH_WDAY);
		/*
		** Don't trust mod of negative numbers.
		*/
		if (dayoff >= 0)
			wday = (wday + dayoff) % LDAYSPERWEEK;
		else {
			wday -= ((-dayoff) % LDAYSPERWEEK);
			if (wday < 0)
				wday += LDAYSPERWEEK;
		}
		while (wday != eitol(rp->r_wday))
			if (rp->r_dycode == DC_DOWGEQ) {
				dayoff = oadd(dayoff, 1);
				if (++wday >= LDAYSPERWEEK)
					wday = 0;
				++i;
			} else {
				dayoff = oadd(dayoff, -1);
				if (--wday < 0)
					wday = LDAYSPERWEEK - 1;
				--i;
			}
	}
	if (dayoff < min_time / SECSPERDAY)
		return min_time;
	if (dayoff > max_time / SECSPERDAY)
		return max_time;
	t = (zic_t) dayoff * SECSPERDAY;
	return tadd(t, rp->r_tod);
}

static void
newabbr(const char *string)
{
	int	i;

	if (strcmp(string, GRANDPARENTED) != 0) {
		const char *	cp;
		char *		wp;

		cp = string;
		wp = NULL;
		while (isascii((unsigned char)*cp) &&
		    (isalnum((unsigned char)*cp) || *cp == '-' || *cp == '+'))
			++cp;
		if (noise && cp - string > 3)
			wp = "time zone abbreviation has more than 3 characters";
		if (cp - string > ZIC_MAX_ABBR_LEN_WO_WARN)
			wp = "time zone abbreviation has too many characters";
		if (*cp != '\0')
			wp = "time zone abbreviation differs from POSIX standard";
		if (wp != NULL) {
			wp = ecpyalloc(wp);
			wp = ecatalloc(wp, " (");
			wp = ecatalloc(wp, string);
			wp = ecatalloc(wp, ")");
			warning(wp);
			free(wp);
		}
	}
	i = strlen(string) + 1;
	if (charcnt + i > TZ_MAX_CHARS) {
		error("too many, or too long, time zone abbreviations");
		exit(EXIT_FAILURE);
	}
	strlcpy(&chars[charcnt], string, sizeof(chars) - charcnt);
	charcnt += eitol(i);
}

static int
mkdirs(char *argname)
{
	char *	name;
	char *	cp;

	if (argname == NULL || *argname == '\0')
		return 0;
	cp = name = ecpyalloc(argname);
	while ((cp = strchr(cp + 1, '/')) != 0) {
		*cp = '\0';
		if (!itsdir(name)) {
			/*
			** It doesn't seem to exist, so we try to create it.
			** Creation may fail because of the directory being
			** created by some other multiprocessor, so we get
			** to do extra checking.
			*/
			if (mkdir(name, MKDIR_UMASK) != 0) {
				const char *e = strerror(errno);

				if (errno != EEXIST || !itsdir(name)) {
					fprintf(stderr,
					    "%s: Can't create directory %s: %s\n",
					    __progname, name, e);
					free(name);
					return -1;
				}
			}
		}
		*cp = '/';
	}
	free(name);
	return 0;
}

static long
eitol(int i)
{
	long	l = i;

	if ((i < 0 && l >= 0) || (i == 0 && l != 0) || (i > 0 && l <= 0))
		errx(1, "%d did not sign extend correctly", i);
	return l;
}
@


1.21
log
@pledge "stdio rpath wpath cpath proc exec".
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.20 2015/04/23 05:26:33 deraadt Exp $	*/
a2477 4
		/*
		** Want one to ZIC_MAX_ABBR_LEN_WO_WARN alphabetics
		** optionally followed by a + or - and a number from 1 to 14.
		*/
d2481 1
a2481 1
		    isalpha((unsigned char)*cp))
a2482 2
		if (cp - string == 0)
			wp = "time zone abbreviation lacks alphabetic at start";
d2484 1
a2484 1
			wp = "time zone abbreviation has more than 3 alphabetics";
d2486 1
a2486 8
			wp = "time zone abbreviation has too many alphabetics";
		if (wp == NULL && (*cp == '+' || *cp == '-')) {
			++cp;
			if (isascii((unsigned char)*cp) &&
			    isdigit((unsigned char)*cp))
				if (*cp++ == '1' && *cp >= '0' && *cp <= '4')
					++cp;
		}
@


1.20
log
@KNF and other style adjustments to make this more scrutible.
reviewed by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.19 2015/03/13 17:23:37 deraadt Exp $	*/
d510 3
@


1.19
log
@delete useless comment about Open Group
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.18 2015/03/11 22:26:03 deraadt Exp $	*/
d7 2
d12 2
d15 6
d23 9
a31 1
#include "private.h"
d49 1
a49 1
	const char *	r_filename;
d51 1
a51 1
	const char *	r_name;
d55 1
a55 1
	const char *	r_yrtype;
d71 1
a71 1
	const char *	r_abbrvar;	/* variable part of abbreviation */
d86 1
a86 1
	const char *	z_filename;
d89 1
a89 1
	const char *	z_name;
d91 2
a92 2
	const char *	z_rule;
	const char *	z_format;
d96 1
a96 1
	struct rule *	z_rules;
d104 2
a105 2
static int	addtype(long gmtoff, const char * abbr, int isdst,
				int ttisstd, int ttisgmt);
d109 7
a115 8
static void	convert(long val, char * buf);
static void	convert64(zic_t val, char * buf);
static void	dolink(const char * fromfield, const char * tofield);
static void	doabbr(char * abbr, size_t size, const char * format,
			const char * letters, int isdst, int doquotes);
static void	eat(const char * name, int num);
static void	eats(const char * name, int num,
			const char * rname, int rnum);
d117 10
a126 11
static void	error(const char * message);
static char **	getfields(char * buf);
static long	gethms(const char * string, const char * errstrng,
			int signable);
static void	infile(const char * filename);
static void	inleap(char ** fields, int nfields);
static void	inlink(char ** fields, int nfields);
static void	inrule(char ** fields, int nfields);
static int	inzcont(char ** fields, int nfields);
static int	inzone(char ** fields, int nfields);
static int	inzsub(char ** fields, int nfields, int iscont);
d128 4
a131 4
static int	itsabbr(const char * abbr, const char * word);
static int	itsdir(const char * name);
static int	mkdirs(char * filename);
static void	newabbr(const char * abbr);
d133 13
a145 14
static void	outzone(const struct zone * zp, int ntzones);
static void	puttzcode(long code, FILE * fp);
static void	puttzcode64(zic_t code, FILE * fp);
static int	rcomp(const void * leftp, const void * rightp);
static zic_t	rpytime(const struct rule * rp, int wantedy);
static void	rulesub(struct rule * rp,
			const char * loyearp, const char * hiyearp,
			const char * typep, const char * monthp,
			const char * dayp, const char * timep);
static int 	stringoffset(char * result, size_t size, long offset);
static int	stringrule(char * result, size_t size, const struct rule * rp,
			long dstoff, long gmtoff);
static void 	stringzone(char * result, size_t size,
			const struct zone * zp, int ntzones);
d149 4
a152 2
static void	writezone(const char * name, const char * string);
static int	yearistype(int year, const char * type);
d156 1
a156 1
static const char *	filename;
d169 1
a169 1
static const char *	rfilename;
a170 1
static const char *	progname;
d255 1
a255 1
static struct rule *	rules;
d258 1
a258 1
static struct zone *	zones;
d262 1
a262 1
	const char *	l_filename;
d264 2
a265 2
	const char *	l_from;
	const char *	l_to;
d268 1
a268 1
static struct link *	links;
d272 1
a272 1
	const char *	l_word;
d276 1
a276 2
static struct lookup const *	byword(const char * string,
					const struct lookup * lp);
d356 1
d374 1
a374 1
	if (ptr == NULL) {
a375 1
	}
d423 1
a423 1
	fprintf(stderr, _("\"%s\", line %d: %s"),
d426 1
a426 1
		fprintf(stderr, _(" (rule from \"%s\", line %d)"),
d435 1
a435 1
	char *	cp;
d437 1
a437 1
	cp = ecpyalloc(_("warning: "));
d448 2
a449 3
	char *		fbuf;
	const char *	fp;
	char *		tp;
a450 2
	const char *	result;
	char			dummy;
d475 3
a477 2
			do *tp++ = *fp++;
				while (*fp != '\0' && *fp != ']');
d493 4
a496 2
	fprintf(stderr, _("usage: %s [-v] [-d directory] [-L leapsecondfilename] [-l timezone]\n\t[-p timezone] [-y command] [filename ...]\n"),
		progname);
d500 5
a504 5
static const char *	psxrules;
static const char *	lcltime;
static const char *	directory;
static const char *	leapsec;
static const char *	yitcommand;
d509 1
a509 3
	int	i;
	int	j;
	int	c;
a511 1
	progname = argv[0];
d519 1
a519 1
				else {
a520 1
				}
d525 1
a525 1
				else {
a526 1
				}
d531 1
a531 1
				else {
a532 1
				}
d537 1
a537 1
				else {
a538 1
				}
d543 1
a543 1
				else {
a544 1
				}
d587 1
a587 1
						warning(_("link to link"));
d603 1
a603 2
	char *	fromname;
	char *	toname;
d634 1
a634 1
		if (result != 0) {
a635 1
		}
d657 1
a657 1
	char *	myname;
d685 3
a687 4
	struct zone *	zp;
	struct rule *	rp;
	int		base, out;
	int		i, j;
d699 1
a699 1
			warning(_("same rule name in multiple files"));
d701 1
a701 1
			warning(_("same rule name in multiple files"));
d742 1
a742 1
			zp->z_stdoff = gethms(zp->z_rule, _("unruly zone"),
d749 1
a749 1
				error(_("%s in ruleless zone"));
d759 5
a763 8
	FILE *			fp;
	char **		fields;
	char *			cp;
	const struct lookup *	lp;
	int			nfields;
	int			wantcont;
	int			num;
	char				buf[BUFSIZ];
d766 1
a766 1
		name = _("standard input");
d768 1
a768 1
	} else if ((fp = fopen(name, "r")) == NULL) {
a769 1
	}
d777 1
a777 1
			error(_("line too long"));
d797 1
a797 1
				error(_("input line of unknown type"));
d813 2
a814 2
							_("%s: Leap line in non leap seconds file %s\n"),
							progname, name);
d826 1
a826 1
	if (ferror(fp)) {
d828 1
a828 2
	}
	if (fp != stdin && fclose(fp)) {
a829 1
	}
d831 1
a831 1
		error(_("expected continuation line not found"));
d855 2
a856 1
	} else	sign = 1;
d862 3
a864 3
		&hh, &mm, &ss) != 3) {
			error(errstring);
			return 0;
d867 4
a870 4
		mm < 0 || mm >= MINSPERHOUR ||
		ss < 0 || ss > SECSPERMIN) {
			error(errstring);
			return 0;
d873 1
a873 1
		error(_("time overflow"));
d877 1
a877 1
		    eitol(sign) * (eitol(mm) * eitol(SECSPERMIN) + eitol(ss)));
d886 1
a886 1
		error(_("wrong number of fields on Rule line"));
d890 1
a890 1
		error(_("nameless rule"));
d895 1
a895 1
	r.r_stdoff = gethms(fields[RF_STDOFF], _("invalid saved time"), TRUE);
d910 1
a910 1
	static char *	buf;
d914 1
a914 1
		error(_("wrong number of fields on Zone line"));
d920 3
a922 2
		snprintf(buf, len, _("\"Zone %s\" line and -l option are mutually exclusive"),
			TZDEFAULT);
d929 3
a931 2
		snprintf(buf, len, _("\"Zone %s\" line and -p option are mutually exclusive"),
			TZDEFRULES);
d937 11
a947 11
			strcmp(zones[i].z_name, fields[ZF_NAME]) == 0) {
				len = 132 + strlen(fields[ZF_NAME]) +
					strlen(zones[i].z_filename);
				buf = erealloc(buf, len);
				snprintf(buf, len,
					_("duplicate zone name %s (file \"%s\", line %d)"),
					fields[ZF_NAME],
					zones[i].z_filename,
					zones[i].z_linenum);
				error(buf);
				return FALSE;
d956 1
a956 1
		error(_("wrong number of fields on Zone continuation line"));
d965 1
a965 1
	char *		cp;
d993 1
a993 1
	z.z_gmtoff = gethms(fields[i_gmtoff], _("invalid UTC offset"), TRUE);
d996 1
a996 1
			error(_("invalid abbreviation format"));
d1019 7
a1025 7
			z.z_untiltime > min_time &&
			z.z_untiltime < max_time &&
			zones[nzones - 1].z_untiltime > min_time &&
			zones[nzones - 1].z_untiltime < max_time &&
			zones[nzones - 1].z_untiltime >= z.z_untiltime) {
				error(_( "Zone continuation line end time is not after end time of previous line"));
				return FALSE;
d1040 2
a1041 2
	const char *		cp;
	const struct lookup *	lp;
d1043 3
a1045 3
	int				year, month, day;
	long				dayoff, tod;
	zic_t				t;
d1048 1
a1048 1
		error(_("wrong number of fields on Leap line"));
d1057 1
a1057 1
		error(_("invalid leaping year"));
d1077 1
a1077 1
		error(_("invalid month name"));
d1089 3
a1091 3
		day <= 0 || day > len_months[isleap(year)][month]) {
			error(_("invalid day of month"));
			return;
d1095 1
a1095 1
		error(_("time before zero"));
d1099 1
a1099 1
		error(_("time too small"));
d1103 1
a1103 1
		error(_("time too large"));
d1107 1
a1107 1
	tod = gethms(fields[LP_TIME], _("invalid time of day"), FALSE);
d1126 1
a1126 1
			error(_("illegal CORRECTION field on Leap line"));
d1130 1
a1130 1
			error(_( "illegal Rolling/Stationary field on Leap line"));
d1143 1
a1143 1
		error(_("wrong number of fields on Link line"));
d1147 1
a1147 1
		error(_("blank FROM field on Link line"));
d1151 1
a1151 1
		error(_("blank TO field on Link line"));
d1163 8
a1170 13
rulesub(rp, loyearp, hiyearp, typep, monthp, dayp, timep)
struct rule * const	rp;
const char * const		loyearp;
const char * const		hiyearp;
const char * const		typep;
const char * const		monthp;
const char * const		dayp;
const char * const		timep;
{
	const struct lookup *	lp;
	const char *		cp;
	char *			dp;
	char *			ep;
d1173 1
a1173 1
		error(_("invalid month name"));
d1183 17
a1199 17
			case 's':	/* Standard */
				rp->r_todisstd = TRUE;
				rp->r_todisgmt = FALSE;
				*ep = '\0';
				break;
			case 'w':	/* Wall */
				rp->r_todisstd = FALSE;
				rp->r_todisgmt = FALSE;
				*ep = '\0';
				break;
			case 'g':	/* Greenwich */
			case 'u':	/* Universal */
			case 'z':	/* Zulu */
				rp->r_todisstd = TRUE;
				rp->r_todisgmt = TRUE;
				*ep = '\0';
				break;
d1202 1
a1202 1
	rp->r_tod = gethms(dp, _("invalid time of day"), FALSE);
d1220 1
a1220 1
		error(_("invalid starting year"));
d1239 1
a1239 1
		error(_("invalid ending year"));
d1243 1
a1243 1
		error(_("starting year greater than ending year"));
d1250 1
a1250 1
			error(_("typed single year"));
d1280 1
a1280 1
				error(_("invalid day of month"));
d1285 1
a1285 1
				error(_("invalid weekday name"));
d1292 5
a1296 5
			rp->r_dayofmonth <= 0 ||
			(rp->r_dayofmonth > len_months[1][rp->r_month])) {
				error(_("invalid day of month"));
				free(dp);
				return;
d1358 1
a1358 1
	FILE *			fp;
d1363 1
a1363 1
	static char *			fullname;
d1365 4
a1368 4
	static struct tzhead		tzh;
	zic_t				ats[TZ_MAX_TIMES];
	unsigned char			types[TZ_MAX_TIMES];
	size_t				len;
d1391 5
a1395 6
				gmtoffs[attypes[toi - 1].type]) <=
				(attypes[toi - 1].at + gmtoffs[toi == 1 ? 0
				: attypes[toi - 2].type]))) {
					attypes[toi - 1].type =
						attypes[fromi].type;
					continue;
d1398 2
a1399 2
				attypes[toi - 1].type != attypes[fromi].type)
					attypes[toi++] = attypes[fromi];
d1446 1
a1446 1
	if (!itsdir(fullname) && remove(fullname) != 0 && errno != ENOENT) {
a1447 1
	}
d1451 1
a1451 1
		if ((fp = fopen(fullname, "wb")) == NULL) {
a1452 1
		}
d1458 2
a1459 2
		int		writetype[TZ_MAX_TIMES];
		int		typemap[TZ_MAX_TYPES];
d1461 3
a1463 3
		char		thischars[TZ_MAX_CHARS];
		char		thischarcnt;
		int 		indmap[TZ_MAX_CHARS];
d1513 2
a1514 1
				else	mrustd = types[i];
d1519 2
a1520 1
					else	histd = i;
d1523 8
a1530 9
				gmtoffs[hidst] != gmtoffs[mrudst]) {
					isdsts[mrudst] = -1;
					type = addtype(gmtoffs[mrudst],
						&chars[abbrinds[mrudst]],
						TRUE,
						ttisstds[mrudst],
						ttisgmts[mrudst]);
					isdsts[mrudst] = TRUE;
					writetype[type] = TRUE;
d1533 8
a1540 9
				gmtoffs[histd] != gmtoffs[mrustd]) {
					isdsts[mrustd] = -1;
					type = addtype(gmtoffs[mrustd],
						&chars[abbrinds[mrustd]],
						FALSE,
						ttisstds[mrustd],
						ttisgmts[mrustd]);
					isdsts[mrustd] = FALSE;
					writetype[type] = TRUE;
d1551 1
a1551 1
			char *	thisabbr;
d1563 1
a1563 1
					thisabbr, sizeof(thischars) - thischarcnt);
d1591 2
a1592 1
			else	puttzcode64(ats[i], fp);
d1603 1
a1603 1
				putc((unsigned char) indmap[abbrinds[i]], fp);
d1621 2
a1622 2
						trans[i] >= ats[j])
							++j;
d1626 2
a1627 1
			} else	todo = trans[i];
d1630 2
a1631 1
			else	puttzcode64(todo, fp);
d1642 1
a1642 1
	if (ferror(fp) || fclose(fp)) {
a1643 1
	}
d1647 2
a1648 1
doabbr(char *abbr, size_t size, const char *format, const char *letters, int isdst, int doquotes)
d1650 1
a1650 2
	char *	cp;
	char *	slashp;
d1657 2
a1658 1
		else	snprintf(abbr, size, format, letters);
d1694 2
a1695 4
	int	hours;
	int	minutes;
	int	seconds;
	char *	ep;
d1728 1
a1728 1
	char *	ep;
d1757 2
a1758 1
		} else	return -1;	/* "cannot happen" */
d1783 2
a1784 4
	const struct zone *	zp;
	struct rule *		rp;
	struct rule *		stdrp;
	struct rule *		dstrp;
d1786 2
a1787 2
	const char *		abbrvar;
	char *			ep;
d1801 2
a1802 1
			else	return;
d1806 2
a1807 1
			else	return;
d1868 8
a1875 17
	const struct zone *	zp;
	struct rule *		rp;
	int			i, j;
	int			usestart, useuntil;
	zic_t			starttime, untiltime;
	long			gmtoff;
	long			stdoff;
	int			year;
	long			startoff;
	int			startttisstd;
	int			startttisgmt;
	int			type;
	char *			startbuf;
	char *			ab;
	char *			envvar;
	int			max_abbr_len;
	int			max_envvar_len;
a1882 2
	untiltime = 0;
	starttime = 0;
a1893 2
	startttisstd = FALSE;
	startttisgmt = FALSE;
d1920 1
a1920 1
		wp = ecpyalloc(_("no POSIX environment variable for zone"));
d1929 2
a1930 1
		else	min_year = INT_MIN;
d1933 2
a1934 1
		else	max_year = INT_MAX;
d1992 2
a1993 2
						year <= rp->r_hiyear &&
						yearistype(year, rp->r_yrtype);
d1999 1
a1999 1
				zic_t	jtime, ktime;
a2001 1
				ktime = 0;
d2052 1
a2052 1
							stdoff);
d2054 5
a2058 5
							max_abbr_len + 1,
							zp->z_format,
							rp->r_abbrvar,
							rp->r_stdoff != 0,
							FALSE);
d2062 8
a2069 9
						startoff == oadd(zp->z_gmtoff,
						stdoff)) {
							doabbr(startbuf,
								max_abbr_len + 1,
								zp->z_format,
								rp->r_abbrvar,
								rp->r_stdoff !=
								0,
								FALSE);
d2073 1
a2073 1
					rp->r_filename, rp->r_linenum);
d2075 1
a2075 2
					rp->r_abbrvar,
					rp->r_stdoff != 0, FALSE);
d2078 1
a2078 1
					rp->r_todisstd, rp->r_todisgmt);
d2084 4
a2087 5
				zp->z_format != NULL &&
				strchr(zp->z_format, '%') == NULL &&
				strchr(zp->z_format, '/') == NULL)
					strlcpy(startbuf, zp->z_format,
					    	       max_abbr_len + 1);
d2090 6
a2095 6
				error(_("can't determine time zone abbreviation to use just after until time"));
			else	addtt(starttime,
					addtype(startoff, startbuf,
						startoff != zp->z_gmtoff,
						startttisstd,
						startttisgmt));
d2117 1
a2117 3
addtt(starttime, type)
const zic_t	starttime;
int		type;
d2122 1
a2122 1
		(timecnt == 1 && attypes[0].at < min_time)) {
d2138 1
a2138 1
		error(_("too many transitions?!"));
d2152 1
a2152 1
		error(_("internal error - addtype called with bad isdst"));
d2156 1
a2156 1
		error(_("internal error - addtype called with bad ttisstd"));
d2160 1
a2160 1
		error(_("internal error - addtype called with bad ttisgmt"));
d2169 4
a2172 4
			strcmp(abbr, &chars[abbrinds[i]]) == 0 &&
			ttisstd == ttisstds[i] &&
			ttisgmt == ttisgmts[i])
				return i;
d2179 1
a2179 1
		error(_("too many local time types"));
d2183 1
a2183 1
		error(_("UTC offset out of range"));
d2207 1
a2207 1
		error(_("too many leap seconds"));
d2213 1
a2213 1
				error(_("repeated leap second moment"));
d2249 1
a2249 1
	static char *	buf;
d2259 2
a2260 1
	if (WIFEXITED(result)) switch (WEXITSTATUS(result)) {
d2265 2
a2266 2
	}
	error(_("Wild result from command execution"));
d2291 2
a2292 2
	const struct lookup *	foundlp;
	const struct lookup *	lp;
d2319 2
a2320 2
	char *		dp;
	char **	array;
d2328 3
a2330 3
		while (isascii((unsigned char) *cp) &&
			isspace((unsigned char) *cp))
				++cp;
d2335 1
a2335 1
			if ((*dp = *cp++) != '"')
d2337 8
a2344 6
			else while ((*dp = *cp++) != '"')
				if (*dp != '\0')
					++dp;
				else {
					error(_( "Odd number of quotation marks"));
					exit(EXIT_FAILURE);
d2346 1
d2348 2
a2349 2
			(!isascii((unsigned char)*cp) || !isspace((unsigned char) *cp)));
		if (isascii((unsigned char) *cp) && isspace((unsigned char) *cp))
d2360 1
a2360 1
	long	t;
a2361 1
	t = t1 + t2;
d2363 1
a2363 1
		error(_("time overflow"));
d2380 1
a2380 1
		error(_("time overflow"));
a2389 1

d2424 1
a2424 1
			error(_("use of 2/29 in non leap-year"));
d2481 3
a2483 3
		while (isascii((unsigned char) *cp) &&
			isalpha((unsigned char) *cp))
				++cp;
d2485 1
a2485 1
wp = _("time zone abbreviation lacks alphabetic at start");
d2487 1
a2487 1
wp = _("time zone abbreviation has more than 3 alphabetics");
d2489 1
a2489 1
wp = _("time zone abbreviation has too many alphabetics");
d2492 4
a2495 5
			if (isascii((unsigned char) *cp) &&
				isdigit((unsigned char) *cp))
					if (*cp++ == '1' &&
						*cp >= '0' && *cp <= '4')
							++cp;
d2498 1
a2498 1
			wp = _("time zone abbreviation differs from POSIX standard");
d2510 1
a2510 1
		error(_("too many, or too long, time zone abbreviations"));
d2540 2
a2541 2
						_("%s: Can't create directory %s: %s\n"),
						progname, name, e);
d2556 1
a2556 1
	long	l;
d2558 1
a2558 2
	l = i;
	if ((i < 0 && l >= 0) || (i == 0 && l != 0) || (i > 0 && l <= 0)) {
a2559 1
	}
@


1.18
log
@do not handcraft protos that already come from unistd.h
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.17 2015/02/11 01:07:37 deraadt Exp $	*/
a2584 4

/*
** UNIX was a registered trademark of The Open Group in 2003.
*/
@


1.17
log
@use reallocarray; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.16 2015/02/10 09:17:02 tedu Exp $	*/
a83 6

extern int	getopt(int argc, char * const argv[],
			const char * options);
extern int	link(const char * fromname, const char * toname);
extern char *	optarg;
extern int	optind;
@


1.16
log
@redo the tolower/string conversion, but retain itsabbr which is strangely
not quite the same as strncasecmp
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.15 2015/02/10 05:45:46 tedu Exp $	*/
d383 1
d449 1
a449 1
	fbuf = malloc(2 * strlen(format) + 4);
d909 1
a909 1
	rules = erealloc(rules, (nrules + 1) * sizeof *rules);
d1033 1
a1033 1
	zones = erealloc(zones, (nzones + 1) * sizeof *zones);
d1163 1
a1163 1
	links = erealloc(links, (nlinks + 1) * sizeof *links);
d2352 1
a2352 1
	array = emalloc((strlen(cp) + 1) * sizeof *array);
@


1.15
log
@revert rev 1.12 (tolower conversion). didn't get it quite right.
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.14 2015/02/10 05:44:50 tedu Exp $	*/
a96 1
static int	ciequal(const char * ap, const char * bp);
a119 1
static int	lowerit(int c);
d1191 1
a1191 1
		switch (lowerit(*ep)) {
d2296 1
d2298 1
a2298 2
lowerit(a)
int	a;
d2300 2
a2301 14
	a = (unsigned char) a;
	return (isascii(a) && isupper(a)) ? tolower(a) : a;
}

static int
ciequal(ap, bp)		/* case-insensitive equality */
const char *	ap;
const char *	bp;
{
	while (lowerit(*ap) == lowerit(*bp++))
		if (*ap++ == '\0')
			return TRUE;
	return FALSE;
}
d2303 1
a2303 6
static int
itsabbr(abbr, word)
const char *	abbr;
const char *	word;
{
	if (lowerit(*abbr) != lowerit(*word))
a2304 1
	++word;
d2307 1
d2310 1
a2310 1
		} while (lowerit(*word++) != lowerit(*abbr));
d2326 1
a2326 1
		if (ciequal(word, lp->l_word))
d2336 2
a2337 1
			else	return NULL;	/* multiple inexact matches */
@


1.14
log
@move scheck.c into zic.c
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.12 2015/02/10 03:07:17 tedu Exp $	*/
d97 1
d119 1
d121 1
d1193 1
a1193 1
		switch (tolower((unsigned char)*ep)) {
d2298 35
d2339 1
a2339 1
	if (word == NULL || *word == '\0' || table == NULL)
d2345 1
a2345 1
		if (strcasecmp(word, lp->l_word) == 0)
d2352 1
a2352 1
		if (strncasecmp(word, lp->l_word, strlen(word)) == 0) {
d2355 1
a2355 2
			else
				return NULL;	/* multiple inexact matches */
@


1.13
log
@seems ansi c is here to stay. update definitions, but drop useless const.
@
text
@d433 48
@


1.12
log
@lowerit -> tolower
ciequal -> strcasecmp
itsabbr -> strncasecmp
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.11 2015/02/09 23:34:46 tedu Exp $	*/
d361 1
a361 2
memcheck(ptr)
void * const	ptr;
d390 1
a390 5
eats(name, num, rname, rnum)
const char * const	name;
const int		num;
const char * const	rname;
const int		rnum;
d399 1
a399 3
eat(name, num)
const char * const	name;
const int		num;
d405 1
a405 2
error(string)
const char * const	string;
d422 1
a422 2
warning(string)
const char * const	string;
d448 1
a448 3
main(argc, argv)
int	argc;
char *	argv[];
d550 1
a550 3
dolink(fromfield, tofield)
const char * const	fromfield;
const char * const	tofield;
d606 1
a606 2
itsdir(name)
const char * const	name;
d627 1
a627 3
rcomp(cp1, cp2)
const void *	cp1;
const void *	cp2;
d709 1
a709 2
infile(name)
const char *	name;
d801 1
a801 4
gethms(string, errstring, signable)
const char *		string;
const char * const	errstring;
const int		signable;
d838 1
a838 3
inrule(fields, nfields)
char ** const	fields;
const int		nfields;
d864 1
a864 3
inzone(fields, nfields)
char ** const	fields;
const int		nfields;
d908 1
a908 3
inzcont(fields, nfields)
char ** const	fields;
const int		nfields;
d918 1
a918 4
inzsub(fields, nfields, iscont)
char ** const	fields;
const int		nfields;
const int		iscont;
d993 1
a993 3
inleap(fields, nfields)
char ** const	fields;
const int		nfields;
d1093 1
a1093 3
inlink(fields, nfields)
char ** const	fields;
const int		nfields;
d1263 1
a1263 3
convert(val, buf)
const long	val;
char * const	buf;
d1273 1
a1273 3
convert64(val, buf)
const zic_t	val;
char * const	buf;
d1283 1
a1283 3
puttzcode(val, fp)
const long	val;
FILE * const	fp;
d1292 1
a1292 3
puttzcode64(val, fp)
const zic_t	val;
FILE * const	fp;
d1301 1
a1301 3
atcomp(avp, bvp)
const void *	avp;
const void *	bvp;
d1310 1
a1310 2
is32(x)
const zic_t	x;
d1316 1
a1316 3
writezone(name, string)
const char * const	name;
const char * const	string;
d1608 1
a1608 7
doabbr(abbr, size, format, letters, isdst, doquotes)
char * const		abbr;
size_t			size;
const char * const	format;
const char * const	letters;
const int		isdst;
const int		doquotes;
d1643 1
a1643 2
updateminmax(x)
const int	x;
d1652 1
a1652 4
stringoffset(result, size, offset)
char *	result;
size_t	size;
long	offset;
d1687 1
a1687 6
stringrule(result, size, rp, dstoff, gmtoff)
char *				result;
size_t				size;
const struct rule * const	rp;
const long			dstoff;
const long			gmtoff;
d1742 1
a1742 5
stringzone(result, size, zpfirst, zonecount)
char *				result;
size_t				size;
const struct zone * const	zpfirst;
const int			zonecount;
d1827 1
a1827 3
outzone(zpfirst, zonecount)
const struct zone * const	zpfirst;
const int			zonecount;
d2125 1
a2125 6
addtype(gmtoff, abbr, isdst, ttisstd, ttisgmt)
const long		gmtoff;
const char * const	abbr;
const int		isdst;
const int		ttisstd;
const int		ttisgmt;
d2180 1
a2180 5
leapadd(t, positive, rolling, count)
const zic_t	t;
const int	positive;
const int	rolling;
int		count;
d2225 1
a2225 3
yearistype(year, type)
const int		year;
const char * const	type;
d2248 1
a2248 3
byword(word, table)
const char * const		word;
const struct lookup * const	table;
d2276 1
a2276 2
getfields(cp)
char *	cp;
d2314 1
a2314 3
oadd(t1, t2)
const long	t1;
const long	t2;
d2327 1
a2327 3
tadd(t1, t2)
const zic_t	t1;
const long	t2;
d2349 1
a2349 3
rpytime(rp, wantedy)
const struct rule * const	rp;
const int			wantedy;
d2425 1
a2425 2
newabbr(string)
const char * const	string;
d2477 1
a2477 2
mkdirs(argname)
char *		argname;
d2513 1
a2513 2
eitol(i)
const int	i;
@


1.11
log
@convert a dozen fprintf/exit pairs to use err().
leave a comment where the original code forgot to call exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.10 2015/02/09 23:14:32 tedu Exp $	*/
a96 1
static int	ciequal(const char * ap, const char * bp);
a117 1
static int	itsabbr(const char * abbr, const char * word);
a118 1
static int	lowerit(int c);
d1175 1
a1175 1
		switch (lowerit(*ep)) {
a2324 35
static int
lowerit(a)
int	a;
{
	a = (unsigned char) a;
	return (isascii(a) && isupper(a)) ? tolower(a) : a;
}

static int
ciequal(ap, bp)		/* case-insensitive equality */
const char *	ap;
const char *	bp;
{
	while (lowerit(*ap) == lowerit(*bp++))
		if (*ap++ == '\0')
			return TRUE;
	return FALSE;
}

static int
itsabbr(abbr, word)
const char *	abbr;
const char *	word;
{
	if (lowerit(*abbr) != lowerit(*word))
		return FALSE;
	++word;
	while (*++abbr != '\0')
		do {
			if (*word == '\0')
				return FALSE;
		} while (lowerit(*word++) != lowerit(*abbr));
	return TRUE;
}

d2333 1
a2333 1
	if (word == NULL || table == NULL)
d2339 1
a2339 1
		if (ciequal(word, lp->l_word))
d2346 1
a2346 1
		if (itsabbr(word, lp->l_word)) {
d2349 2
a2350 1
			else	return NULL;	/* multiple inexact matches */
@


1.10
log
@exit() cleanup. don't have to call it in a loop.
usage() always takes the same stream and status arguments (despite a
comment indicating perhaps it shouldn't), so make it void
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.9 2015/02/09 14:34:44 tedu Exp $	*/
d9 1
d368 1
a368 5
		const char *e = strerror(errno);

		fprintf(stderr, _("%s: Memory exhausted: %s\n"),
			progname, e);
		exit(EXIT_FAILURE);
a469 5
	if (TYPE_BIT(zic_t) < 64) {
		fprintf(stderr, "%s: %s\n", progname,
			_("wild compilation-time specification of zic_t"));
		exit(EXIT_FAILURE);
	}
d478 1
a478 4
					fprintf(stderr,
						_("%s: More than one -d option specified\n"),
						progname);
					exit(EXIT_FAILURE);
d485 1
a485 4
					fprintf(stderr,
						_("%s: More than one -l option specified\n"),
						progname);
					exit(EXIT_FAILURE);
d492 1
a492 4
					fprintf(stderr,
						_("%s: More than one -p option specified\n"),
						progname);
					exit(EXIT_FAILURE);
d499 1
a499 4
					fprintf(stderr,
						_("%s: More than one -y option specified\n"),
						progname);
					exit(EXIT_FAILURE);
d506 1
a506 4
					fprintf(stderr,
						_("%s: More than one -L option specified\n"),
						progname);
					exit(EXIT_FAILURE);
d601 1
a601 6
			const char *e = strerror(errno);

			fprintf(stderr,
				_("%s: Can't link from %s to %s: %s\n"),
				progname, fromname, toname, e);
			exit(EXIT_FAILURE);
d744 1
a744 5
		const char *e = strerror(errno);

		fprintf(stderr, _("%s: Can't open %s: %s\n"),
			progname, name, e);
		exit(EXIT_FAILURE);
d791 3
a793 1
					else	inleap(fields, nfields);
d797 1
a797 4
					fprintf(stderr,
						_("%s: panic: Invalid l_value %d\n"),
						progname, lp->l_value);
					exit(EXIT_FAILURE);
d803 1
a803 3
		fprintf(stderr, _("%s: Error reading %s\n"),
			progname, filename);
		exit(EXIT_FAILURE);
d806 1
a806 5
		const char *e = strerror(errno);

		fprintf(stderr, _("%s: Error closing %s: %s\n"),
			progname, filename, e);
		exit(EXIT_FAILURE);
d1214 1
a1214 4
			fprintf(stderr,
				_("%s: panic: Invalid l_value %d\n"),
				progname, lp->l_value);
			exit(EXIT_FAILURE);
d1233 1
a1233 4
			fprintf(stderr,
				_("%s: panic: Invalid l_value %d\n"),
				progname, lp->l_value);
			exit(EXIT_FAILURE);
d1457 1
a1457 5
		const char *e = strerror(errno);

		fprintf(stderr, _("%s: Can't remove %s: %s\n"),
			progname, fullname, e);
		exit(EXIT_FAILURE);
d1463 1
a1463 5
			const char *e = strerror(errno);

			fprintf(stderr, _("%s: Can't create %s: %s\n"),
				progname, fullname, e);
			exit(EXIT_FAILURE);
d1652 1
a1652 3
		fprintf(stderr, _("%s: Error writing %s\n"),
			progname, fullname);
		exit(EXIT_FAILURE);
d2325 1
a2325 3
	fprintf(stderr, _("%s: command was '%s', result was %d\n"),
		progname, buf, result);
	exit(EXIT_FAILURE);
d2646 1
a2646 4
		fprintf(stderr,
			_("%s: %d did not sign extend correctly\n"),
			progname, i);
		exit(EXIT_FAILURE);
@


1.9
log
@delete lots of unnecessary or incorrect casts, including among other minor
atrocities casting qsort() to void.
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.8 2015/02/09 14:15:38 tedu Exp $	*/
d140 1
a140 1
static void	usage(FILE *stream, int status);
d449 1
a449 1
usage(FILE *stream, int status)
d451 1
a451 1
	(void) fprintf(stream, _("usage: %s [-v] [-d directory] [-L leapsecondfilename] [-l timezone]\n\t[-p timezone] [-y command] [filename ...]\n"),
d453 1
a453 1
	exit(status);
d481 1
a481 1
				usage(stderr, EXIT_FAILURE);
d537 1
a537 1
		usage(stderr, EXIT_FAILURE);	/* usage message by request */
d2382 1
a2382 2
	for ( ; ; )
		exit(EXIT_FAILURE);
d2476 1
a2476 1
					exit(1);
@


1.8
log
@we are not interested in warnings about what pre-1998 zic could not handle
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.7 2015/02/09 13:46:22 tedu Exp $	*/
a120 1
static char *	memcheck(char * tocheck);
d362 1
a362 1
static char *
d364 1
a364 1
char * const	ptr;
d369 1
a369 1
		(void) fprintf(stderr, _("%s: Memory exhausted: %s\n"),
d414 1
a414 1
	eats(name, num, (char *) NULL, -1);
d426 1
a426 1
	(void) fprintf(stderr, _("\"%s\", line %d: %s"),
d429 1
a429 1
		(void) fprintf(stderr, _(" (rule from \"%s\", line %d)"),
d431 1
a431 1
	(void) fprintf(stderr, "\n");
d471 1
a471 1
	(void) umask(umask(S_IWGRP | S_IWOTH) | (S_IWGRP | S_IWOTH));
d474 1
a474 1
		(void) fprintf(stderr, "%s: %s\n", progname,
d486 1
a486 1
					(void) fprintf(stderr,
d496 1
a496 1
					(void) fprintf(stderr,
d506 1
a506 1
					(void) fprintf(stderr,
d516 1
a516 1
					(void) fprintf(stderr,
d526 1
a526 1
					(void) fprintf(stderr,
d613 1
a613 1
		(void) remove(toname);
d626 1
a626 1
			(void) fprintf(stderr,
d689 1
a689 2
		(void) qsort((void *) rules, (size_t) nrules,
			(size_t) sizeof *rules, rcomp);
d774 1
a774 1
		(void) fprintf(stderr, _("%s: Can't open %s: %s\n"),
d781 1
a781 1
		if (fgets(buf, (int) sizeof buf, fp) != buf)
d820 1
a820 1
						(void) fprintf(stderr,
d827 1
a827 1
					(void) fprintf(stderr,
d833 1
a833 1
		free((char *) fields);
d836 1
a836 1
		(void) fprintf(stderr, _("%s: Error reading %s\n"),
d843 1
a843 1
		(void) fprintf(stderr, _("%s: Error closing %s: %s\n"),
d923 1
a923 2
	rules = (struct rule *) (void *) erealloc((char *) rules,
		(int) ((nrules + 1) * sizeof *rules));
d943 1
a943 1
		(void) snprintf(buf, len, _("\"Zone %s\" line and -l option are mutually exclusive"),
d951 1
a951 1
		(void) snprintf(buf, len, _("\"Zone %s\" line and -p option are mutually exclusive"),
d962 1
a962 1
				(void) snprintf(buf, len,
d1054 1
a1054 2
	zones = (struct zone *) (void *) erealloc((char *) zones,
		(int) ((nzones + 1) * sizeof *zones));
d1188 1
a1188 2
	links = (struct link *) (void *) erealloc((char *) links,
		(int) ((nlinks + 1) * sizeof *links));
d1253 1
a1253 1
			(void) fprintf(stderr,
d1275 1
a1275 1
			(void) fprintf(stderr,
d1375 1
a1375 1
	(void) fwrite((void *) buf, (size_t) sizeof buf, (size_t) 1, fp);
d1386 1
a1386 1
	(void) fwrite((void *) buf, (size_t) sizeof buf, (size_t) 1, fp);
d1428 1
a1428 2
		(void) qsort((void *) attypes, (size_t) timecnt,
			(size_t) sizeof *attypes, atcomp);
d1497 1
a1497 1
	(void) snprintf(fullname, len, "%s/%s", directory, name);
d1504 1
a1504 1
		(void) fprintf(stderr, _("%s: Can't remove %s: %s\n"),
d1514 1
a1514 1
			(void) fprintf(stderr, _("%s: Can't create %s: %s\n"),
d1627 1
a1627 1
				(void) strlcpy(&thischars[(int) thischarcnt],
d1633 1
a1633 2
#define DO(field)	(void) fwrite((void *) tzh.field, \
				(size_t) sizeof tzh.field, (size_t) 1, fp)
d1635 1
a1635 1
		(void) strncpy(tzh.tzh_magic, TZ_MAGIC, sizeof tzh.tzh_magic);
d1661 1
a1661 4
			(void) fwrite((void *) &uc,
				(size_t) sizeof uc,
				(size_t) 1,
				fp);
d1666 2
a1667 2
				(void) putc(isdsts[i], fp);
				(void) putc((unsigned char) indmap[abbrinds[i]], fp);
d1670 1
a1670 3
			(void) fwrite((void *) thischars,
				(size_t) sizeof thischars[0],
				(size_t) thischarcnt, fp);
d1698 1
a1698 1
				(void) putc(ttisstds[i], fp);
d1701 1
a1701 1
				(void) putc(ttisgmts[i], fp);
d1703 1
a1703 1
	(void) fprintf(fp, "\n%s\n", string);
d1705 1
a1705 1
		(void) fprintf(stderr, _("%s: Error writing %s\n"),
d1727 2
a1728 2
			(void) strlcpy(abbr, format, size);
		else	(void) snprintf(abbr, size, format, letters);
d1730 1
a1730 1
		(void) strlcpy(abbr, slashp + 1, size);
d1734 1
a1734 1
		(void) strlcpy(abbr, format, size);
d1775 1
a1775 1
		(void) strlcpy(result, "-", size);
d1788 1
a1788 1
	(void) snprintf(ep, size - (ep - result), "%d", hours);
d1791 1
a1791 1
		(void) snprintf(ep, size - (ep - result), ":%02d", minutes);
d1794 1
a1794 1
			(void) snprintf(ep, size - (ep - result), ":%02d", seconds);
d1822 1
a1822 1
		(void) snprintf(result, size, "J%d", total + rp->r_dayofmonth);
d1839 1
a1839 1
		(void) snprintf(result, size, "M%d.%d.%d",
d1852 1
a1852 1
		(void) strlcat(result, "/", size);
d1937 1
a1937 1
	(void) strlcat(result, ",", size);
d1942 1
a1942 1
	(void) strlcat(result, ",", size);
d2068 1
a2068 1
				(char *) NULL, stdoff != 0, FALSE);
d2187 1
a2187 1
					(void) strlcpy(startbuf, zp->z_format,
d2232 1
a2232 1
			(void) memmove(chars, &chars[abbrinds[type]], len);
d2371 1
a2371 1
	(void) snprintf(buf, len, "%s %d %s", yitcommand, year, type);
d2380 1
a2380 1
	(void) fprintf(stderr, _("%s: command was '%s', result was %d\n"),
d2460 1
a2460 2
	array = (char **) (void *)
		emalloc((int) ((strlen(cp) + 1) * sizeof *array));
d2587 1
a2587 1
				dayoff = oadd(dayoff, (long) 1);
d2592 1
a2592 1
				dayoff = oadd(dayoff, (long) -1);
d2655 1
a2655 1
	(void) strlcpy(&chars[charcnt], string, sizeof(chars) - charcnt);
d2682 1
a2682 1
					(void) fprintf(stderr,
d2704 1
a2704 1
		(void) fprintf(stderr,
@


1.7
log
@remove INITIALIZE macro and do it the hard way.
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.6 2015/02/09 13:42:03 tedu Exp $	*/
d488 1
a488 1
_("%s: More than one -d option specified\n"),
d498 1
a498 1
_("%s: More than one -l option specified\n"),
d508 1
a508 1
_("%s: More than one -p option specified\n"),
d518 1
a518 1
_("%s: More than one -y option specified\n"),
d528 1
a528 1
_("%s: More than one -L option specified\n"),
d823 1
a823 1
_("%s: Leap line in non leap seconds file %s\n"),
d830 1
a830 1
_("%s: panic: Invalid l_value %d\n"),
a896 5
	if (noise && hh == HOURSPERDAY && mm == 0 && ss == 0)
		warning(_("24:00 not handled by pre-1998 versions of zic"));
	if (noise && (hh > HOURSPERDAY ||
		(hh == HOURSPERDAY && (mm != 0 || ss != 0))))
warning(_("values over 24 hours not handled by pre-2007 versions of zic"));
d946 1
a946 2
		(void) snprintf(buf, len,
_("\"Zone %s\" line and -l option are mutually exclusive"),
d954 1
a954 2
		(void) snprintf(buf, len,
_("\"Zone %s\" line and -p option are mutually exclusive"),
d966 1
a966 1
_("duplicate zone name %s (file \"%s\", line %d)"),
d1053 1
a1053 3
				error(_(
"Zone continuation line end time is not after end time of previous line"
					));
d1162 1
a1162 3
			error(_(
				"illegal Rolling/Stationary field on Leap line"
				));
d2031 1
a2031 1
wp = ecpyalloc(_("no POSIX environment variable for zone"));
d2203 1
a2203 1
error(_("can't determine time zone abbreviation to use just after until time"));
d2489 1
a2489 3
					error(_(
						"Odd number of quotation marks"
						));
a2609 5
		if (i < 0 || i >= len_months[isleap(y)][m]) {
			if (noise)
				warning(_("rule goes past start/end of month--\
will not work with pre-2004 versions of zic"));
		}
d2653 1
a2653 1
wp = _("time zone abbreviation differs from POSIX standard");
d2696 1
a2696 1
_("%s: Can't create directory %s: %s\n"),
@


1.6
log
@unifdef the rest of the HAVEs and HAVE nots
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.5 2015/02/09 13:39:16 tedu Exp $	*/
d2001 2
a2002 2
	INITIALIZE(untiltime);
	INITIALIZE(starttime);
d2122 1
a2122 1
				INITIALIZE(ktime);
@


1.5
log
@unifdef have gettext. don't have it, won't have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.4 2015/02/09 13:21:42 tedu Exp $	*/
a621 1
#if HAVE_SYMLINK
a623 1
#endif /* HAVE_SYMLINK */
@


1.4
log
@be clear that we want the secret libc tzfile.h, not the usual /usr/include
one
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.3 2015/02/09 12:52:45 tedu Exp $	*/
a472 7
#if HAVE_GETTEXT
	(void) setlocale(LC_ALL, "");
#ifdef TZ_DOMAINDIR
	(void) bindtextdomain(TZ_DOMAIN, TZ_DOMAINDIR);
#endif /* defined TEXTDOMAINDIR */
	(void) textdomain(TZ_DOMAIN);
#endif /* HAVE_GETTEXT */
@


1.3
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.2 2015/02/09 12:45:33 tedu Exp $	*/
a9 1
#include <tzfile.h>
d11 1
@


1.2
log
@sort | uniq includes, and use <> instead of quotes
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.1 2015/02/09 12:37:47 tedu Exp $	*/
d468 3
a470 3
	register int	i;
	register int	j;
	register int	c;
d599 2
a600 2
	register char *	fromname;
	register char *	toname;
d651 1
a651 1
	register int	i;
d663 2
a664 2
	register char *	myname;
	register int	accres;
d693 4
a696 4
	register struct zone *	zp;
	register struct rule *	rp;
	register int		base, out;
	register int		i, j;
d770 7
a776 7
	register FILE *			fp;
	register char **		fields;
	register char *			cp;
	register const struct lookup *	lp;
	register int			nfields;
	register int			wantcont;
	register int			num;
d917 1
a917 1
register char ** const	fields;
d946 1
a946 1
register char ** const	fields;
d949 1
a949 1
	register int	i;
d994 1
a994 1
register char ** const	fields;
d1006 1
a1006 1
register char ** const	fields;
d1010 1
a1010 1
	register char *		cp;
d1012 4
a1015 4
	register int		i_gmtoff, i_rule, i_format;
	register int		i_untilyear, i_untilmonth;
	register int		i_untilday, i_untiltime;
	register int		hasuntil;
d1087 1
a1087 1
register char ** const	fields;
d1090 3
a1092 3
	register const char *		cp;
	register const struct lookup *	lp;
	register int			i, j;
d1160 1
a1160 1
		register int	positive;
d1191 1
a1191 1
register char ** const	fields;
d1219 1
a1219 1
register struct rule * const	rp;
d1227 4
a1230 4
	register const struct lookup *	lp;
	register const char *		cp;
	register char *			dp;
	register char *			ep;
d1373 2
a1374 2
	register int	i;
	register int	shift;
d1385 2
a1386 2
	register int	i;
	register int	shift;
d1437 5
a1441 5
	register FILE *			fp;
	register int			i, j;
	register int			leapcnt32, leapi32;
	register int			timecnt32, timei32;
	register int			pass;
d1546 3
a1548 3
		register int	thistimei, thistimecnt;
		register int	thisleapi, thisleapcnt;
		register int	thistimelim, thisleaplim;
d1551 1
a1551 1
		register int	thistypecnt;
d1598 1
a1598 1
			register int	mrudst, mrustd, hidst, histd, type;
d1642 1
a1642 1
			register char *	thisabbr;
d1704 1
a1704 1
			register zic_t	todo;
d1752 3
a1754 3
	register char *	cp;
	register char *	slashp;
	register int	len;
d1800 4
a1803 4
	register int	hours;
	register int	minutes;
	register int	seconds;
	register char *	ep;
d1840 2
a1841 2
	register long	tod;
	register char *	ep;
d1847 1
a1847 1
		register int	month, total;
d1856 1
a1856 1
		register int	week;
d1899 7
a1905 7
	register const struct zone *	zp;
	register struct rule *		rp;
	register struct rule *		stdrp;
	register struct rule *		dstrp;
	register int			i;
	register const char *		abbrvar;
	register char *			ep;
d1986 18
a2003 18
	register const struct zone *	zp;
	register struct rule *		rp;
	register int			i, j;
	register int			usestart, useuntil;
	register zic_t			starttime, untiltime;
	register long			gmtoff;
	register long			stdoff;
	register int			year;
	register long			startoff;
	register int			startttisstd;
	register int			startttisgmt;
	register int			type;
	register char *			startbuf;
	register char *			ab;
	register char *			envvar;
	register int			max_abbr_len;
	register int			max_envvar_len;
	register int			prodstic; /* all rules are min to max */
d2049 1
a2049 1
		register char *	wp;
d2127 3
a2129 3
				register int	k;
				register zic_t	jtime, ktime;
				register long	offset;
d2289 1
a2289 1
	register int	i, j;
d2348 1
a2348 1
	register int	i, j;
d2378 2
a2379 2
	register int	i;
	register long	last = 0;
d2428 2
a2429 2
register const char *	ap;
register const char *	bp;
d2439 2
a2440 2
register const char *	abbr;
register const char *	word;
d2455 2
a2456 2
register const char * const		word;
register const struct lookup * const	table;
d2458 2
a2459 2
	register const struct lookup *	foundlp;
	register const struct lookup *	lp;
d2484 1
a2484 1
register char *	cp;
d2486 3
a2488 3
	register char *		dp;
	register char **	array;
	register int		nsubs;
d2529 1
a2529 1
	register long	t;
d2544 1
a2544 1
	register zic_t	t;
d2565 2
a2566 2
register const struct rule * const	rp;
register const int			wantedy;
d2568 3
a2570 3
	register int	y, m, i;
	register long	dayoff;			/* with a nod to Margaret O. */
	register zic_t	t;
d2606 1
a2606 1
		register long	wday;
d2650 1
a2650 1
	register int	i;
d2653 2
a2654 2
		register const char *	cp;
		register char *		wp;
d2703 2
a2704 2
	register char *	name;
	register char *	cp;
@


1.1
log
@move zic and zdump source to appropriate directories
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.37 2015/02/09 11:29:19 tedu Exp $	*/
d7 5
a12 2
#include "locale.h"
#include "tzfile.h"
a21 1
#include <sys/stat.h>
a22 10

/*
** On some ancient hosts, predicates like `isspace(C)' are defined
** only if isascii(C) || C == EOF. Modern hosts obey the C Standard,
** which says they are defined only if C == ((unsigned char) C) || C == EOF.
** Neither the C Standard nor Posix require that `isascii' exist.
** For portability, we check both ancient and modern requirements.
** If isascii is not defined, the isascii check succeeds trivially.
*/
#include "ctype.h"
@

