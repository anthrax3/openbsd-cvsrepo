head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.2
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.4.0.12
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.8
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.10
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.3.0.12
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.10
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.8
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.1.0.2
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2017.03.21.12.06.55;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	6uuBMurt3Uh42fgX;

1.7
date	2017.01.20.12.08.24;	author benno;	state Exp;
branches;
next	1.6;
commitid	DASoN3lhBpShZo7I;

1.6
date	2017.01.20.11.55.08;	author benno;	state Exp;
branches;
next	1.5;
commitid	amLxRcKegr7GUlIs;

1.5
date	2017.01.17.22.10.55;	author krw;	state Exp;
branches;
next	1.4;
commitid	nf3UdaW8au6U0a03;

1.4
date	2013.11.02.13.31.51;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.10.08.00.54;	author martinh;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.10.07.32.50;	author martinh;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.31.17.36.31;	author martinh;	state Exp;
branches;
next	;


desc
@@


1.8
log
@From a syslog perspective it does not make sense to log fatal and
warn with the same severity.  Switch log_warn() to LOG_ERR and keep
fatal() at LOG_CRIT.
OK reyk@@ florian@@
@
text
@/*	$OpenBSD: log.c,v 1.7 2017/01/20 12:08:24 benno Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/time.h>
#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "log.h"

int	 	 debug;
int	 	 verbose;

void
log_init(int n_debug)
{
	extern char	*__progname;

	debug = n_debug;

	if (!debug)
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);

	tzset();
}

void
log_verbose(int v)
{
	verbose = v;
}

void
logit(int pri, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vlog(pri, fmt, ap);
	va_end(ap);
}

void
vlog(int pri, const char *fmt, va_list ap)
{
	char		 datebuf[24];
	struct timeval	 tv;
	struct tm	*tm;
	char		*nfmt;
	size_t		 rc;
	time_t		 now;

	if (debug) {
		gettimeofday(&tv, NULL);
		now = tv.tv_sec;
		tm = localtime(&now);
		rc = strftime(datebuf, sizeof(datebuf), "%b %e %H:%M:%S", tm);
		if (rc == 0)
			datebuf[0] = 0;
		fprintf(stderr, "%s.%03ld [%d] ", datebuf,
		    tv.tv_usec / 1000, getpid());

		/* best effort in out of mem situations */
		if (asprintf(&nfmt, "%s\n", fmt) == -1) {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		} else {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
		}
		fflush(stderr);
	} else
		vsyslog(pri, fmt, ap);
}

void
log_warn(const char *emsg, ...)
{
	char	*nfmt;
	va_list	 ap;

	/* best effort to even work in out of memory situations */
	if (emsg == NULL)
		logit(LOG_ERR, "%s", strerror(errno));
	else {
		va_start(ap, emsg);

		if (asprintf(&nfmt, "%s: %s", emsg, strerror(errno)) == -1) {
			/* we tried it... */
			vlog(LOG_ERR, emsg, ap);
			logit(LOG_ERR, "%s", strerror(errno));
		} else {
			vlog(LOG_ERR, nfmt, ap);
			free(nfmt);
		}
		va_end(ap);
	}
}

void
log_warnx(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_ERR, emsg, ap);
	va_end(ap);
}

void
log_info(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_INFO, emsg, ap);
	va_end(ap);
}

void
log_debug(const char *emsg, ...)
{
	va_list	 ap;

	if (verbose) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

void
fatal(const char *emsg)
{
	if (emsg == NULL)
		logit(LOG_CRIT, "fatal: %s", strerror(errno));
	else
		if (errno)
			logit(LOG_CRIT, "fatal: %s: %s",
			    emsg, strerror(errno));
		else
			logit(LOG_CRIT, "fatal: %s", emsg);

	exit(1);
}

void
fatalx(const char *emsg)
{
	errno = 0;
	fatal(emsg);
}
@


1.7
log
@unbreak tree
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2017/01/20 11:55:08 benno Exp $	*/
d104 1
a104 1
		logit(LOG_CRIT, "%s", strerror(errno));
d110 2
a111 2
			vlog(LOG_CRIT, emsg, ap);
			logit(LOG_CRIT, "%s", strerror(errno));
d113 1
a113 1
			vlog(LOG_CRIT, nfmt, ap);
d126 1
a126 1
	vlog(LOG_CRIT, emsg, ap);
@


1.6
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok krw@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2017/01/17 22:10:55 krw Exp $	*/
d19 1
@


1.5
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.4 2013/11/02 13:31:51 deraadt Exp $	*/
d14 3
a16 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
a18 5
#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/time.h>

a19 1
#include <netdb.h>
a26 1
#include <vis.h>
d28 1
a28 1
#include "ldapd.h"
d30 2
a31 2
int	 debug;
int	 verbose;
a171 286

const char *
print_host(struct sockaddr_storage *ss, char *buf, size_t len)
{
	if (getnameinfo((struct sockaddr *)ss, ss->ss_len,
	    buf, len, NULL, 0, NI_NUMERICHOST) != 0) {
		buf[0] = '\0';
		return (NULL);
	}
	return (buf);
}

void
hexdump(void *data, size_t len, const char *fmt, ...)
{
	uint8_t *p = data;
	va_list ap;

	if (verbose < 2 || !debug)
		return;

	va_start(ap, fmt);
	vlog(LOG_DEBUG, fmt, ap);
	va_end(ap);

	while (len--) {
		size_t ofs = p - (uint8_t *)data;
		if (ofs % 16 == 0)
			fprintf(stderr, "%s%04lx:", ofs == 0 ? "" : "\n", ofs);
		else if (ofs % 8 == 0)
			fprintf(stderr, " ");
		fprintf(stderr, " %02x", *p++);
	}
	fprintf(stderr, "\n");
}

/*
 * Display a list of ber elements.
 *
 */
void
ldap_debug_elements(struct ber_element *root, int context, const char *fmt, ...)
{
	va_list		 ap;
	static int	 indent = 0;
	long long	 v;
	int		 d;
	char		*buf, *visbuf;
	size_t		 len;
	u_int		 i;
	int		 constructed;
	struct ber_oid	 o;

	if (verbose < 2 || !debug)
		return;

	if (fmt != NULL) {
		va_start(ap, fmt);
		vlog(LOG_DEBUG, fmt, ap);
		va_end(ap);
	}

	/* calculate lengths */
	ber_calc_len(root);

	switch (root->be_encoding) {
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
		constructed = root->be_encoding;
		break;
	default:
		constructed = 0;
		break;
	}

	fprintf(stderr, "%*slen %lu ", indent, "", root->be_len);
	switch (root->be_class) {
	case BER_CLASS_UNIVERSAL:
		fprintf(stderr, "class: universal(%u) type: ", root->be_class);
		switch (root->be_type) {
		case BER_TYPE_EOC:
			fprintf(stderr, "end-of-content");
			break;
		case BER_TYPE_BOOLEAN:
			fprintf(stderr, "boolean");
			break;
		case BER_TYPE_INTEGER:
			fprintf(stderr, "integer");
			break;
		case BER_TYPE_BITSTRING:
			fprintf(stderr, "bit-string");
			break;
		case BER_TYPE_OCTETSTRING:
			fprintf(stderr, "octet-string");
			break;
		case BER_TYPE_NULL:
			fprintf(stderr, "null");
			break;
		case BER_TYPE_OBJECT:
			fprintf(stderr, "object");
			break;
		case BER_TYPE_ENUMERATED:
			fprintf(stderr, "enumerated");
			break;
		case BER_TYPE_SEQUENCE:
			fprintf(stderr, "sequence");
			break;
		case BER_TYPE_SET:
			fprintf(stderr, "set");
			break;
		}
		break;
	case BER_CLASS_APPLICATION:
		fprintf(stderr, "class: application(%u) type: ",
		    root->be_class);
		switch (root->be_type) {
		case LDAP_REQ_BIND:
		case LDAP_RES_BIND:
			fprintf(stderr, "bind");
			break;
		case LDAP_REQ_UNBIND_30:
			fprintf(stderr, "unbind");
			break;
		case LDAP_REQ_SEARCH:
			fprintf(stderr, "search");
			break;
		case LDAP_RES_SEARCH_ENTRY:
			fprintf(stderr, "search entry");
			break;
		case LDAP_RES_SEARCH_RESULT:
			fprintf(stderr, "search result");
			break;
		case LDAP_REQ_MODIFY:
		case LDAP_RES_MODIFY:
			fprintf(stderr, "modify");
			break;
		case LDAP_REQ_ADD:
		case LDAP_RES_ADD:
			fprintf(stderr, "add");
			break;
		case LDAP_REQ_DELETE_30:
		case LDAP_RES_DELETE:
			fprintf(stderr, "delete");
			break;
		case LDAP_REQ_MODRDN:
		case LDAP_RES_MODRDN:
			fprintf(stderr, "modrdn");
			break;
		case LDAP_REQ_COMPARE:
		case LDAP_RES_COMPARE:
			fprintf(stderr, "compare");
			break;
		case LDAP_REQ_ABANDON_30:
			fprintf(stderr, "abandon");
			break;
		case LDAP_REQ_EXTENDED:
		case LDAP_RES_EXTENDED:
			fprintf(stderr, "extended");
			break;
		}
		break;
	case BER_CLASS_PRIVATE:
		fprintf(stderr, "class: private(%u) type: ", root->be_class);
		fprintf(stderr, "encoding (%lu) type: ", root->be_encoding);
		break;
	case BER_CLASS_CONTEXT:
		fprintf(stderr, "class: context(%u) type: ", root->be_class);
		switch (context) {
		case LDAP_REQ_BIND:
			switch(root->be_type) {
			case LDAP_AUTH_SIMPLE:
				fprintf(stderr, "auth simple");
				break;
			}
			break;
		case LDAP_REQ_SEARCH:
			switch(root->be_type) {
			case LDAP_FILT_AND:
				fprintf(stderr, "and");
				break;
			case LDAP_FILT_OR:
				fprintf(stderr, "or");
				break;
			case LDAP_FILT_NOT:
				fprintf(stderr, "not");
				break;
			case LDAP_FILT_EQ:
				fprintf(stderr, "equal");
				break;
			case LDAP_FILT_SUBS:
				fprintf(stderr, "substring");
				break;
			case LDAP_FILT_GE:
				fprintf(stderr, "greater-or-equal");
				break;
			case LDAP_FILT_LE:
				fprintf(stderr, "less-or-equal");
				break;
			case LDAP_FILT_PRES:
				fprintf(stderr, "presence");
				break;
			case LDAP_FILT_APPR:
				fprintf(stderr, "approximate");
				break;
			}
			break;
		}
		break;
	default:
		fprintf(stderr, "class: <INVALID>(%u) type: ", root->be_class);
		break;
	}
	fprintf(stderr, "(%lu) encoding %lu ",
	    root->be_type, root->be_encoding);

	if (constructed)
		root->be_encoding = constructed;

	switch (root->be_encoding) {
	case BER_TYPE_BOOLEAN:
		if (ber_get_boolean(root, &d) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "%s(%d)\n", d ? "true" : "false", d);
		break;
	case BER_TYPE_INTEGER:
		if (ber_get_integer(root, &v) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "value %lld\n", v);
		break;
	case BER_TYPE_ENUMERATED:
		if (ber_get_enumerated(root, &v) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "value %lld\n", v);
		break;
	case BER_TYPE_BITSTRING:
		if (ber_get_bitstring(root, (void *)&buf, &len) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "hexdump ");
		for (i = 0; i < len; i++)
			fprintf(stderr, "%02x", buf[i]);
		fprintf(stderr, "\n");
		break;
	case BER_TYPE_OBJECT:
		if (ber_get_oid(root, &o) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "\n");
		break;
	case BER_TYPE_OCTETSTRING:
		if (ber_get_nstring(root, (void *)&buf, &len) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		if ((visbuf = malloc(len * 4 + 1)) != NULL) {
			strvisx(visbuf, buf, len, 0);
			fprintf(stderr, "string \"%s\"\n",  visbuf);
			free(visbuf);
		}
		break;
	case BER_TYPE_NULL:	/* no payload */
	case BER_TYPE_EOC:
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
	default:
		fprintf(stderr, "\n");
		break;
	}

	if (constructed && root->be_sub) {
		indent += 2;
		ldap_debug_elements(root->be_sub, context, NULL);
		indent -= 2;
	}
	if (root->be_next)
		ldap_debug_elements(root->be_next, context, NULL);
}

@


1.4
log
@bunch of format string cleanups, removing %i, signed vs unsigned, and even
a few long long's
ok jmatthew
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2010/11/10 08:00:54 martinh Exp $	*/
d80 1
a80 1
		gettimeofday(&tv, NULL); 
@


1.3
log
@Make -dvv flags produce debug traces of decoded BER messages on stderr.
Also shows a hexdump of the input buffer if BER decoding fails.
Useful when debugging protocol issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2010/11/10 07:32:50 martinh Exp $	*/
d86 2
a87 1
		fprintf(stderr, "%s.%03li [%i] ", datebuf, tv.tv_usec / 1000, getpid());
@


1.2
log
@Prefix debug logging on stderr with time and pid, like syslog.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.1 2010/05/31 17:36:31 martinh Exp $	*/
d33 1
d189 275
@


1.1
log
@Initial import of ldapd, a small LDAP daemon. Work in progress.

ok deraadt@@ jacekm@@ gilles@@ back@@ henning@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2008/07/18 12:30:06 reyk Exp $	*/
d22 1
d32 1
d71 6
a76 1
	char	*nfmt;
d79 8
@

