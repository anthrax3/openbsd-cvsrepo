head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.2
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.6
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.15
date	2017.01.20.11.55.08;	author benno;	state Exp;
branches;
next	1.14;
commitid	amLxRcKegr7GUlIs;

1.14
date	2017.01.09.14.04.31;	author krw;	state Exp;
branches;
next	1.13;
commitid	KJkQGNLsnMxWc9MG;

1.13
date	2016.01.17.08.13.34;	author landry;	state Exp;
branches;
next	1.12;
commitid	mhJTGdZ8jCoBbnRX;

1.12
date	2015.12.24.17.47.57;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	ZJPTqgdVcu8wUk8G;

1.11
date	2015.11.02.06.32.51;	author jmatthew;	state Exp;
branches;
next	1.10;
commitid	Gxv6LrGmzNUGQSrd;

1.10
date	2015.01.16.16.04.38;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	6T6qhOmTPOtl2ps3;

1.9
date	2013.11.02.13.31.51;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.16.00.08.32;	author jmatthew;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.11.08.31.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.01.17.34.15;	author martinh;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.06.20.10.57;	author martinh;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.30.17.16.09;	author martinh;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.27.16.24.17;	author martinh;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.23.12.40.19;	author martinh;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.31.17.36.31;	author martinh;	state Exp;
branches;
next	;


desc
@@


1.15
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok krw@@ jmatthew@@
@
text
@/*	$OpenBSD: control.c,v 1.14 2017/01/09 14:04:31 krw Exp $	*/

/*
 * Copyright (c) 2010 Martin Hedenfalk <martin@@bzero.se>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/tree.h>

#include <net/if.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ldapd.h"
#include "log.h"

#define	CONTROL_BACKLOG	5

struct ctl_connlist ctl_conns;

struct ctl_conn	*control_connbyfd(int);
void		 control_close(int, struct control_sock *);
static void	 control_imsgev(struct imsgev *iev, int code, struct imsg *imsg);
static void	 control_needfd(struct imsgev *iev);

void
control_init(struct control_sock *cs)
{
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask, mode;

	if (cs->cs_name == NULL)
		return;

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, 0)) == -1)
		fatal("control_init: socket");

	memset(&sun, 0, sizeof(sun));
	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, cs->cs_name,
	    sizeof(sun.sun_path)) >= sizeof(sun.sun_path))
		fatalx("control_init: name too long");

	if (connect(fd, (struct sockaddr *)&sun, sizeof(sun)) == 0)
		fatalx("control socket already listening");

	if (unlink(cs->cs_name) == -1 && errno != ENOENT)
		fatal("control_init: unlink");

	if (cs->cs_restricted) {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH;
	} else {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP;
	}

	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		(void)umask(old_umask);
		fatal("control_init: bind");
	}
	(void)umask(old_umask);

	if (chmod(cs->cs_name, mode) == -1) {
		(void)unlink(cs->cs_name);
		fatal("control_init: chmod");
	}

	cs->cs_fd = fd;
}

void
control_listen(struct control_sock *cs)
{
	if (cs->cs_name == NULL)
		return;

	if (listen(cs->cs_fd, CONTROL_BACKLOG) == -1)
		fatal("control_listen: listen");

	event_set(&cs->cs_ev, cs->cs_fd, EV_READ,
	    control_accept, cs);
	event_add(&cs->cs_ev, NULL);
	evtimer_set(&cs->cs_evt, control_accept, cs);
}

void
control_cleanup(struct control_sock *cs)
{
	if (cs->cs_name == NULL)
		return;
	event_del(&cs->cs_ev);
	event_del(&cs->cs_evt);
}

/* ARGSUSED */
void
control_accept(int listenfd, short event, void *arg)
{
	struct control_sock	*cs = arg;
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*c;

	event_add(&cs->cs_ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	len = sizeof(sun);
	if ((connfd = accept_reserve(listenfd,
	    (struct sockaddr *)&sun, &len, FD_RESERVE)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&cs->cs_ev);
			evtimer_add(&cs->cs_evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR)
			log_warn("control_accept");
		return;
	}

	if ((c = calloc(1, sizeof(*c))) == NULL) {
		log_warn("control_accept");
		close(connfd);
		return;
	}

	log_debug("accepted control fd %d", connfd);
	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
	imsgev_init(&c->iev, connfd, cs, control_imsgev, control_needfd);
}

struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.fd == fd)
			break;
	}

	return (c);
}

void
control_close(int fd, struct control_sock *cs)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warnx("control_close: fd %d: not found", fd);
		return;
	}

	log_debug("close control fd %d", c->iev.ibuf.fd);
	TAILQ_REMOVE(&ctl_conns, c, entry);
	imsgev_clear(&c->iev);

	/* Some file descriptors are available again. */
	if (evtimer_pending(&cs->cs_evt, NULL)) {
		evtimer_del(&cs->cs_evt);
		event_add(&cs->cs_ev, NULL);
	}

	free(c);
}

static int
send_stats(struct imsgev *iev)
{
	struct namespace	*ns;
	const struct btree_stat	*st;
	struct ns_stat		 nss;

	imsgev_compose(iev, IMSG_CTL_STATS, 0, iev->ibuf.pid, -1,
	    &stats, sizeof(stats));

	TAILQ_FOREACH(ns, &conf->namespaces, next) {
		if (namespace_has_referrals(ns))
			continue;
		memset(&nss, 0, sizeof(nss));
		strlcpy(nss.suffix, ns->suffix, sizeof(nss.suffix));
		if ((st = btree_stat(ns->data_db)) != NULL)
			bcopy(st, &nss.data_stat, sizeof(nss.data_stat));

		if ((st = btree_stat(ns->indx_db)) != NULL)
			bcopy(st, &nss.indx_stat, sizeof(nss.indx_stat));

		imsgev_compose(iev, IMSG_CTL_NSSTATS, 0, iev->ibuf.pid, -1,
		    &nss, sizeof(nss));
	}

	imsgev_compose(iev, IMSG_CTL_END, 0, iev->ibuf.pid, -1, NULL, 0);

	return 0;
}

static void
control_imsgev(struct imsgev *iev, int code, struct imsg *imsg)
{
	struct control_sock	*cs;
	struct ctl_conn		*c;
	int			 fd, verbose;

	cs = iev->data;
	fd = iev->ibuf.fd;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warnx("%s: fd %d: not found", __func__, fd);
		return;
	}

	if (code != IMSGEV_IMSG) {
		control_close(fd, cs);
		return;
	}

	log_debug("%s: got imsg %d on fd %d", __func__, imsg->hdr.type, fd);
	switch (imsg->hdr.type) {
	case IMSG_CTL_STATS:
		if (send_stats(iev) == -1) {
			log_debug("%s: failed to send statistics", __func__);
			control_close(fd, cs);
		}
		break;
	case IMSG_CTL_LOG_VERBOSE:
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(verbose))
			break;

		bcopy(imsg->data, &verbose, sizeof(verbose));
		imsgev_compose(iev_ldapd, IMSG_CTL_LOG_VERBOSE, 0, 0, -1,
		    &verbose, sizeof(verbose));

		log_verbose(verbose);
		break;
	default:
		log_warnx("%s: unexpected imsg %d", __func__, imsg->hdr.type);
		break;
	}
}

void
control_needfd(struct imsgev *iev)
{
	fatal("should never need an fd for control messages");
}

int
control_close_any(struct control_sock *cs)
{
	struct ctl_conn		*c;

	c = TAILQ_FIRST(&ctl_conns);
	if (c != NULL) {
		log_warn("closing oldest control connection");
		control_close(c->iev.ibuf.fd, cs);
		return (0);
	}
	log_warn("no control connections to close");
	return (-1);
}
@


1.14
log
@Replace hand-rolled for(;;) traversal of ctl_conns TAILQ with
TAILQ_FOREACH().

No intentional functional change.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2016/01/17 08:13:34 landry Exp $	*/
d38 1
@


1.13
log
@Properly remove unix sockets (control & listening) upon exit of the
parent process.

Child process was killed by pledge because it tried to remove the
control socket and didnt have cpath - anyway it couldnt remove it since
it had chrooted..

ok jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2015/12/24 17:47:57 mmcc Exp $	*/
d166 4
a169 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
@


1.12
log
@bzero -> memset. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2015/11/02 06:32:51 jmatthew Exp $	*/
a116 1
	(void)unlink(cs->cs_name);
@


1.11
log
@use SOCK_NONBLOCK instead of fcntl

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2015/01/16 16:04:38 deraadt Exp $	*/
d61 1
a61 1
	bzero(&sun, sizeof(sun));
d210 1
a210 1
		bzero(&nss, sizeof(nss));
@


1.10
log
@change to <limits.h> universe.  The only changes in the binary are due
to the heavy use of assert.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2013/11/02 13:31:51 deraadt Exp $	*/
d58 1
a58 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
a91 1
	fd_nonblock(fd);
a149 2

	fd_nonblock(connfd);
@


1.9
log
@bunch of format string cleanups, removing %i, signed vs unsigned, and even
a few long long's
ok jmatthew
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2012/06/16 00:08:32 jmatthew Exp $	*/
a20 1
#include <sys/param.h>
@


1.8
log
@Protect against fd exhaustion when reopening database files.  Only accept
client or control connections when there are at least 8 fds available,
and close a connection before calling imsg_read if it would be unable to
accept an fd from the parent process.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2012/04/11 08:31:37 deraadt Exp $	*/
d161 1
a161 1
	log_debug("accepted control fd %i", connfd);
d188 1
a188 1
	log_debug("close control fd %i", c->iev.ibuf.fd);
d251 1
a251 1
	log_debug("%s: got imsg %i on fd %i", __func__, imsg->hdr.type, fd);
@


1.7
log
@rate limiting of accept() in various cases.  Testing by jmatthew.  there
maybe still be a corner case where it needs one more file descriptor
beyond the limit..
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2010/09/01 17:34:15 martinh Exp $	*/
d47 1
d137 2
a138 2
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
d163 1
a163 1
	imsgev_init(&c->iev, connfd, cs, control_imsgev);
d275 20
@


1.6
log
@Move generic imsg/libevent glue to a separate file.

with eric@@ at c2k10
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2010/07/06 20:10:57 martinh Exp $	*/
d45 1
a45 1
void		 control_close(int);
d105 1
a105 1
	event_set(&cs->cs_ev, cs->cs_fd, EV_READ | EV_PERSIST,
d108 1
d116 2
d131 4
d138 10
a147 1
		if (errno != EWOULDBLOCK && errno != EINTR)
d178 1
a178 1
control_close(int fd)
d190 7
d246 1
a246 1
		control_close(fd);
d255 1
a255 1
			control_close(fd);
@


1.5
log
@Send empty statistics rather than segfault if "ldapctl stats" is run when a
database is being reopened due to compaction.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2010/06/30 17:16:09 martinh Exp $	*/
d46 1
d144 1
a144 7
	imsg_init(&c->iev.ibuf, connfd);
	c->iev.handler = control_dispatch_imsg;
	c->iev.events = EV_READ;
	event_set(&c->iev.ev, c->iev.ibuf.fd, c->iev.events,
	    c->iev.handler, cs);
	event_add(&c->iev.ev, NULL);

d146 1
d171 1
a171 1
	msgbuf_clear(&c->iev.ibuf.w);
d173 1
a173 3

	event_del(&c->iev.ev);
	close(c->iev.ibuf.fd);
d184 1
a184 1
	imsg_compose(&iev->ibuf, IMSG_CTL_STATS, 0, iev->ibuf.pid, -1,
d198 1
a198 1
		imsg_compose(&iev->ibuf, IMSG_CTL_NSSTATS, 0, iev->ibuf.pid, -1,
d202 1
a202 1
	imsg_compose(&iev->ibuf, IMSG_CTL_END, 0, iev->ibuf.pid, -1, NULL, 0);
d207 2
a208 3
/* ARGSUSED */
void
control_dispatch_imsg(int fd, short event, void *arg)
d210 1
a210 2
	int			 n, verbose;
	struct control_sock	*cs = arg;
d212 4
a215 1
	struct imsg		 imsg;
d218 1
a218 1
		log_warnx("control_dispatch_imsg: fd %d: not found", fd);
d222 3
a224 6
	if (event & EV_WRITE) {
		if (msgbuf_write(&c->iev.ibuf.w) < 0) {
			control_close(fd);
			return;
		}
		imsg_event_add(&c->iev);
d227 5
a231 2
	if (event & EV_READ) {
		if ((n = imsg_read(&c->iev.ibuf)) == -1 || n == 0) {
a232 1
			return;
d234 3
a236 10
	} else
		return;

	for (;;) {
		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
			control_close(fd);
			return;
		}

		if (n == 0)
d239 9
a247 41
		log_debug("control_dispatch_imsg: imsg type %u", imsg.hdr.type);

		if (cs->cs_restricted || (c->flags & CTL_CONN_LOCKED)) {
			switch (imsg.hdr.type) {
			case IMSG_CTL_STATS:
				break;
			default:
				log_debug("control_dispatch_imsg: "
				    "client requested restricted command");
				imsg_free(&imsg);
				control_close(fd);
				return;
			}
		}

		switch (imsg.hdr.type) {
		case IMSG_CTL_STATS:
			if (send_stats(&c->iev) == -1) {
				log_debug("control_dispatch_imsg: "
				    "failed to send statistics");
				imsg_free(&imsg);
				control_close(fd);
				return;
			}
			break;
		case IMSG_CTL_LOG_VERBOSE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(verbose))
				break;

			bcopy(imsg.data, &verbose, sizeof(verbose));
			imsg_compose_event(iev_ldapd, IMSG_CTL_LOG_VERBOSE,
			    0, 0, -1, &verbose, sizeof(verbose));

			log_verbose(verbose);
			break;
		default:
			log_debug("control_dispatch_imsg: "
			    "error handling imsg %d", imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
a248 2

	imsg_event_add(&c->iev);
@


1.4
log
@Don't send statistics for referral namespaces. This unbreaks ldapctl stats.
Avoid null pointer dereference when reopening a namespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2010/06/27 16:24:17 martinh Exp $	*/
d196 1
d198 2
a199 2
		st = btree_stat(ns->data_db);
		bcopy(st, &nss.data_stat, sizeof(nss.data_stat));
d201 2
a202 2
		st = btree_stat(ns->indx_db);
		bcopy(st, &nss.indx_stat, sizeof(nss.indx_stat));
@


1.3
log
@Remove unused code.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2010/06/23 12:40:19 martinh Exp $	*/
d194 2
@


1.2
log
@Remove compaction and indexing from ldapd. It is better done by a separate
process now that the btree can pick up the changes automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2010/05/31 17:36:31 martinh Exp $	*/
a44 1
struct ctl_conn	*control_connbypid(pid_t);
d278 1
a278 2
			memcpy(&verbose, imsg.data, sizeof(verbose));

a280 2
			memcpy(imsg.data, &verbose, sizeof(verbose));
			control_imsg_forward(&imsg);
a291 20
	imsg_event_add(&c->iev);
}

void
control_imsg_forward(struct imsg *imsg)
{
	struct ctl_conn *c;

	TAILQ_FOREACH(c, &ctl_conns, entry)
		if (c->flags & CTL_CONN_NOTIFY)
			imsg_compose(&c->iev.ibuf, imsg->hdr.type, 0,
			    imsg->hdr.pid, -1, imsg->data,
			    imsg->hdr.len - IMSG_HEADER_SIZE);
}

void
control_end(struct ctl_conn *c)
{
	imsg_compose(&c->iev.ibuf, IMSG_CTL_END, 0, c->iev.ibuf.pid,
	    -1, NULL, 0);
@


1.1
log
@Initial import of ldapd, a small LDAP daemon. Work in progress.

ok deraadt@@ jacekm@@ gilles@@ back@@ henning@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2009/06/06 05:52:01 pyr Exp $	*/
a165 12
struct ctl_conn *
control_connbypid(pid_t pid)
{
	struct ctl_conn	*c;

	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->pid != pid;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */

	return (c);
}

a178 3
	if (c->closecb)
		c->closecb(c);

a287 6
		case IMSG_CTL_COMPACT:
			run_compaction(c, NULL);
			break;
		case IMSG_CTL_INDEX:
			run_indexer(c, NULL);
			break;
a315 40
	imsg_event_add(&c->iev);
}

void
control_report_compaction(struct ctl_conn *c, int status)
{
	struct compaction_status	 cs;

	/* Report compaction status to the requesting control conn.
	 */
	bzero(&cs, sizeof(cs));
	strlcpy(cs.suffix, c->ns->suffix, sizeof(cs.suffix));
	cs.db = c->state;
	cs.status = status;
	imsg_compose(&c->iev.ibuf, IMSG_CTL_COMPACT_STATUS, 0,
	    c->iev.ibuf.pid, -1, &cs, sizeof(cs));

	imsg_event_add(&c->iev);
}


void
control_report_indexer(struct ctl_conn *c, int status)
{
	const struct btree_stat	*st;
	struct indexer_status	 is;

	/* Report indexer status to the requesting control conn.
	 */
	bzero(&is, sizeof(is));
	strlcpy(is.suffix, c->ns->suffix, sizeof(is.suffix));
	st = btree_stat(c->ns->data_db);
	is.entries = st->entries;
	is.ncomplete = c->ncomplete;
	is.status = status;
	log_debug("reporting indexer status %ju/%ju for ns %s",
	    (intmax_t)is.ncomplete, (intmax_t)is.entries, c->ns->suffix);
	imsg_compose(&c->iev.ibuf, IMSG_CTL_INDEX_STATUS, 0,
	    c->iev.ibuf.pid, -1, &is, sizeof(is));

@

