head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.6
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.12
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.10
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.6
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17;
locks; strict;
comment	@ * @;


1.28
date	2017.02.24.14.28.31;	author gsoares;	state Exp;
branches;
next	1.27;
commitid	gP8L5uaH17MdCR8a;

1.27
date	2017.01.20.11.55.08;	author benno;	state Exp;
branches;
next	1.26;
commitid	amLxRcKegr7GUlIs;

1.26
date	2016.05.01.00.32.37;	author jmatthew;	state Exp;
branches;
next	1.25;
commitid	uX93IkNwEDxO7hQ6;

1.25
date	2015.11.02.06.32.51;	author jmatthew;	state Exp;
branches;
next	1.24;
commitid	Gxv6LrGmzNUGQSrd;

1.24
date	2015.01.16.16.04.38;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	6T6qhOmTPOtl2ps3;

1.23
date	2012.06.16.00.08.32;	author jmatthew;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.11.08.31.37;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.10.08.00.54;	author martinh;	state Exp;
branches;
next	1.20;

1.20
date	2010.11.03.10.33.17;	author martinh;	state Exp;
branches;
next	1.19;

1.19
date	2010.10.19.09.10.12;	author martinh;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.01.17.34.15;	author martinh;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.10.14.27.15;	author martinh;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.01.20.09.34;	author martinh;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.30.19.26.39;	author martinh;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.29.21.54.38;	author martinh;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.29.21.00.34;	author martinh;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.29.02.45.46;	author martinh;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.27.18.31.12;	author martinh;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.27.16.24.17;	author martinh;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.27.16.01.08;	author martinh;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.23.13.34.53;	author martinh;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.23.12.40.19;	author martinh;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.15.19.30.26;	author martinh;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.15.15.47.56;	author martinh;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.15.15.12.54;	author martinh;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.11.12.02.03;	author martinh;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.03.17.29.54;	author martinh;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.31.17.36.31;	author martinh;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Implement fork+exec model

OK jmatthew@@
@
text
@/*	$OpenBSD: ldapd.h,v 1.27 2017/01/20 11:55:08 benno Exp $ */

/*
 * Copyright (c) 2009, 2010 Martin Hedenfalk <martin@@bzero.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _LDAPD_H
#define _LDAPD_H

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/tree.h>
#include <sys/types.h>
#include <sys/uio.h>

#include <event.h>
#include <imsg.h>
#include <limits.h>
#include <pwd.h>
#include <stdarg.h>
#include <tls.h>

#include "aldap.h"
#include "schema.h"
#include "btree.h"
#include "imsgev.h"
#include "evbuffer_tls.h"

#define CONFFILE		 "/etc/ldapd.conf"
#define LDAPD_USER		 "_ldapd"
#define LDAPD_SOCKET		 "/var/run/ldapd.sock"
#define DATADIR			 "/var/db/ldap"
#define LDAP_PORT		 389
#define LDAPS_PORT		 636
#define LDAPD_SESSION_TIMEOUT	 30
#define MAX_LISTEN		 64
#define FD_RESERVE		 8 /* 5 overhead, 2 for db, 1 accept */

#define F_STARTTLS		 0x01
#define F_LDAPS			 0x02
#define F_SSL			(F_LDAPS|F_STARTTLS)

#define F_SECURE		 0x04

#define F_SCERT			 0x01

struct conn;

struct aci {
	SIMPLEQ_ENTRY(aci)	 entry;
#define ACI_DENY		 0
#define ACI_ALLOW		 1
	int			 type;
#define ACI_READ		 0x01
#define ACI_WRITE		 0x02
#define ACI_COMPARE		 0x04
#define ACI_CREATE		 0x08
#define ACI_BIND		 0x10
#define ACI_ALL			 0x1F
	int			 rights;
	enum scope		 scope;		/* base, onelevel or subtree */
	char			*attribute;
	char			*target;
	char			*subject;
	char			*filter;
};
SIMPLEQ_HEAD(acl, aci);

/* An LDAP request.
 */
struct request {
	TAILQ_ENTRY(request)	 next;
	unsigned long		 type;
	long long		 msgid;
	struct ber_element	*root;
	struct ber_element	*op;
	struct conn		*conn;
	int			 replayed;	/* true if replayed request */
};
TAILQ_HEAD(request_queue, request);

enum index_type {
	INDEX_NONE,
	INDEX_EQUAL	= 1,
	INDEX_APPROX	= 1,
	INDEX_PRESENCE	= 1,
	INDEX_SUBSTR
};

struct attr_index {
	TAILQ_ENTRY(attr_index)	 next;
	char			*attr;
	enum index_type		 type;
};
TAILQ_HEAD(attr_index_list, attr_index);

struct referral {
	SLIST_ENTRY(referral)	 next;
	char			*url;
};
SLIST_HEAD(referrals, referral);

struct namespace {
	TAILQ_ENTRY(namespace)	 next;
	char			*suffix;
	struct referrals	 referrals;
	char			*rootdn;
	char			*rootpw;
	char			*data_path;
	char			*indx_path;
	struct btree		*data_db;
	struct btree		*indx_db;
	struct btree_txn	*data_txn;
	struct btree_txn	*indx_txn;
	int			 sync;		/* 1 = fsync after commit */
	struct attr_index_list	 indices;
	unsigned int		 cache_size;
	unsigned int		 index_cache_size;
	struct request_queue	 request_queue;
	struct event		 ev_queue;
	unsigned int		 queued_requests;
	struct acl		 acl;
	int			 relax;		/* relax schema validation */
	int			 compression_level;	/* 0-9, 0 = disabled */
};

TAILQ_HEAD(namespace_list, namespace);

struct index
{
	TAILQ_ENTRY(index)	 next;
	char			*prefix;
};

/* A query plan.
 */
struct plan
{
	TAILQ_ENTRY(plan)	 next;
	TAILQ_HEAD(, plan)	 args;
	TAILQ_HEAD(, index)	 indices;
	struct attr_type	*at;
	char			*adesc;
	union {
		char			*value;
		struct ber_element	*substring;
	} assert;
	int			 op;
	int			 indexed;
	int			 undefined;
};

/* For OR filters using multiple indices, matches are not unique. Remember
 * all DNs sent to the client to make them unique.
 */
struct uniqdn {
	RB_ENTRY(uniqdn)	 link;
	struct btval		 key;
};
RB_HEAD(dn_tree, uniqdn);
RB_PROTOTYPE(dn_tree, uniqdn, link, uniqdn_cmp);

/* An LDAP search request.
 */
struct search {
	TAILQ_ENTRY(search)	 next;
	int			 init;		/* 1 if cursor initiated */
	struct conn		*conn;
	struct request		*req;
	struct namespace	*ns;
	struct btree_txn	*data_txn;
	struct btree_txn	*indx_txn;
	struct cursor		*cursor;
	unsigned int		 nscanned, nmatched, ndups;
	time_t			 started_at;
	long long		 szlim, tmlim;	/* size and time limits */
	int			 typesonly;	/* not implemented */
	long long		 scope;
	long long		 deref;		/* not implemented */
	char			*basedn;
	struct ber_element	*filter, *attrlist;
	struct plan		*plan;
	struct index		*cindx;		/* current index */
	struct dn_tree		 uniqdns;
};

struct listener {
	unsigned int		 flags;		/* F_STARTTLS or F_LDAPS */
	struct sockaddr_storage	 ss;
	int			 port;
	int			 fd;
	struct event		 ev;
	struct event		 evt;
	char			 ssl_cert_name[PATH_MAX];
	struct ssl		*ssl;
	struct tls		*tls;
	TAILQ_ENTRY(listener)	 entry;
};
TAILQ_HEAD(listenerlist, listener);

/* An LDAP client connection.
 */
struct conn {
	TAILQ_ENTRY(conn)	 next;
	int			 fd;
	struct bufferevent	*bev;
	struct ber		 ber;
	int			 disconnect;
	struct request		*bind_req;	/* ongoing bind request */
	char			*binddn;
	char			*pending_binddn;
	TAILQ_HEAD(, search)	 searches;
	struct listener		*listener;	/* where it connected from */

	/* SSL support */
	struct tls		*tls;
	struct buffertls	 buftls;
	unsigned int		 s_flags;
};
TAILQ_HEAD(conn_list, conn)	 conn_list;

struct ssl {
	SPLAY_ENTRY(ssl)	 ssl_nodes;
	char			 ssl_name[PATH_MAX];
	uint8_t			*ssl_cert;
	size_t			 ssl_cert_len;
	uint8_t			*ssl_key;
	size_t			 ssl_key_len;
	uint8_t			 flags;
	struct tls_config	*config;
};

struct ldapd_config
{
	struct namespace_list		 namespaces;
	struct listenerlist		 listeners;
	SPLAY_HEAD(ssltree, ssl)	*sc_ssl;
	struct referrals		 referrals;
	struct acl			 acl;
	struct schema			*schema;
	char				*rootdn;
	char				*rootpw;
};

struct ldapd_stats
{
	time_t			 started_at;	/* time of daemon startup */
	unsigned long long	 requests;	/* total number of requests */
	unsigned long long	 req_search;	/* search requests */
	unsigned long long	 req_bind;	/* bind requests */
	unsigned long long	 req_mod;	/* add/mod/del requests */
	unsigned long long	 timeouts;	/* search timeouts */
	unsigned long long	 unindexed;	/* unindexed searches */
	unsigned int		 conns;		/* active connections */
	unsigned int		 searches;	/* active searches */
};

struct auth_req
{
	int			 fd;
	long long		 msgid;
	char			 name[128];
	char			 password[128];
};

struct auth_res
{
	int			 ok;
	int			 fd;
	long long		 msgid;
};

struct open_req {
	char			 path[PATH_MAX+1];
	unsigned int		 rdonly;
};

enum imsg_type {
	IMSG_NONE,
	IMSG_CTL_OK,
	IMSG_CTL_FAIL,
	IMSG_CTL_END,
	IMSG_CTL_STATS,
	IMSG_CTL_NSSTATS,
	IMSG_CTL_LOG_VERBOSE,

	IMSG_LDAPD_AUTH,
	IMSG_LDAPD_AUTH_RESULT,
	IMSG_LDAPD_OPEN,
	IMSG_LDAPD_OPEN_RESULT,
};

struct ns_stat {
	char			 suffix[256];
	struct btree_stat	 data_stat;
	struct btree_stat	 indx_stat;
};

struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	 entry;
	u_int8_t		 flags;
#define CTL_CONN_NOTIFY		 0x01
#define CTL_CONN_LOCKED		 0x02		/* restricted mode */
	struct imsgev		 iev;
};
TAILQ_HEAD(ctl_connlist, ctl_conn);
extern  struct ctl_connlist ctl_conns;


struct control_sock {
	const char		*cs_name;
	struct event		 cs_ev;
	struct event		 cs_evt;
	int			 cs_fd;
	int			 cs_restricted;
};

enum ldapd_process {
	PROC_MAIN_AUTH,
	PROC_LDAP_SERVER
};

#define PROC_PARENT_SOCK_FILENO	 3

/* ldapd.c */
extern struct ldapd_stats	 stats;
extern struct ldapd_config	*conf;

void			 imsg_event_add(struct imsgev *iev);
int			 imsg_compose_event(struct imsgev *iev, u_int16_t type,
			    u_int32_t peerid, pid_t pid, int fd, void *data,
			    u_int16_t datalen);
int			 imsg_event_handle(struct imsgev *iev, short event);

/* conn.c */
extern struct conn_list	 conn_list;
struct conn		*conn_by_fd(int fd);
void			 conn_read(struct bufferevent *bev, void *data);
void			 conn_write(struct bufferevent *bev, void *data);
void			 conn_err(struct bufferevent *bev, short w, void *data);
void			 conn_accept(int fd, short why, void *data);
void			 conn_close(struct conn *conn);
int			 conn_close_any(void);
void			 conn_disconnect(struct conn *conn);
void			 request_dispatch(struct request *req);
void			 request_free(struct request *req);

/* ldape.c */
void			 ldape(int, int, char *);
int			 ldap_abandon(struct request *req);
int			 ldap_unbind(struct request *req);
int			 ldap_compare(struct request *req);
int			 ldap_extended(struct request *req);

void			 send_ldap_result(struct conn *conn, int msgid,
				unsigned long type, long long result_code);
int			 ldap_respond(struct request *req, int code);
int			 ldap_refer(struct request *req, const char *basedn,
			     struct search *search, struct referrals *refs);

/* namespace.c
 */
struct namespace	*namespace_new(const char *suffix);
int			 namespace_open(struct namespace *ns);
int			 namespace_reopen_data(struct namespace *ns);
int			 namespace_reopen_indx(struct namespace *ns);
int			 namespace_set_data_fd(struct namespace *ns, int fd);
int			 namespace_set_indx_fd(struct namespace *ns, int fd);
struct namespace	*namespace_init(const char *suffix, const char *dir);
void			 namespace_close(struct namespace *ns);
void			 namespace_remove(struct namespace *ns);
struct ber_element	*namespace_get(struct namespace *ns, char *dn);
int			 namespace_exists(struct namespace *ns, char *dn);
int			 namespace_add(struct namespace *ns, char *dn,
				struct ber_element *root);
int			 namespace_update(struct namespace *ns, char *dn,
				struct ber_element *root);
int			 namespace_del(struct namespace *ns, char *dn);
struct namespace	*namespace_lookup_base(const char *basedn,
				int include_referrals);
struct namespace	*namespace_for_base(const char *basedn);
int			 namespace_has_referrals(struct namespace *ns);
struct referrals	*namespace_referrals(const char *basedn);
int			 namespace_has_index(struct namespace *ns,
				const char *attr, enum index_type type);
int			 namespace_begin_txn(struct namespace *ns,
				struct btree_txn **data_txn,
				struct btree_txn **indx_txn, int rdonly);
int			 namespace_begin(struct namespace *ns);
int			 namespace_commit(struct namespace *ns);
void			 namespace_abort(struct namespace *ns);
int			 namespace_queue_request(struct namespace *ns,
				struct request *req);
void			 namespace_queue_schedule(struct namespace *ns,
				unsigned int usec);
void			 namespace_cancel_conn(struct conn *conn);
int			 namespace_conn_queue_count(struct conn *conn);

int			 namespace_ber2db(struct namespace *ns,
				struct ber_element *root, struct btval *val);
struct ber_element	*namespace_db2ber(struct namespace *ns,
				struct btval *val);

/* attributes.c */
struct ber_element	*ldap_get_attribute(struct ber_element *root,
				const char *attr);
struct ber_element	*ldap_find_attribute(struct ber_element *entry,
				struct attr_type *at);
struct ber_element	*ldap_find_value(struct ber_element *elm,
				const char *value);
struct ber_element	*ldap_add_attribute(struct ber_element *root,
				const char *attr, struct ber_element *vals);
int			 ldap_set_values(struct ber_element *elm,
				struct ber_element *vals);
int			 ldap_merge_values(struct ber_element *elm,
				struct ber_element *vals);
int			 ldap_del_attribute(struct ber_element *entry,
				const char *attrdesc);
int			 ldap_del_values(struct ber_element *elm,
				struct ber_element *vals);
char			*ldap_strftime(time_t tm);
char			*ldap_now(void);

/* control.c */
void			 control_init(struct control_sock *);
void			 control_listen(struct control_sock *);
void			 control_accept(int, short, void *);
void			 control_dispatch_imsg(int, short, void *);
void			 control_cleanup(struct control_sock *);
int			 control_close_any(struct control_sock *);

/* filter.c */
int			 ldap_matches_filter(struct ber_element *root,
				struct plan *plan);

/* search.c */
int			 ldap_search(struct request *req);
void			 conn_search(struct search *search);
void			 search_close(struct search *search);
int			 is_child_of(struct btval *key, const char *base);

/* modify.c */
int			 ldap_add(struct request *req);
int			 ldap_delete(struct request *req);
int			 ldap_modify(struct request *req);

/* auth.c */
extern struct imsgev	*iev_ldapd;
int			 ldap_bind(struct request *req);
void			 ldap_bind_continue(struct conn *conn, int ok);
int			 authorized(struct conn *conn, struct namespace *ns,
				int rights, char *dn, int scope);

/* parse.y */
int			 parse_config(char *filename);
int			 cmdline_symset(char *s);
int			 ssl_cmp(struct ssl *, struct ssl *);
SPLAY_PROTOTYPE(ssltree, ssl, ssl_nodes, ssl_cmp);


/* logmsg.c */
const char		*print_host(struct sockaddr_storage *ss, char *buf,
				size_t len);
void			 hexdump(void *data, size_t len, const char *fmt, ...);
void			 ldap_debug_elements(struct ber_element *root,
			    int context, const char *fmt, ...);
/* util.c */
int			 bsnprintf(char *str, size_t size,
				const char *format, ...);
int			 has_suffix(struct btval *key, const char *suffix);
int			 has_prefix(struct btval *key, const char *prefix);
void			 normalize_dn(char *dn);
int			 ber2db(struct ber_element *root, struct btval *val,
			    int compression_level);
struct ber_element	*db2ber(struct btval *val, int compression_level);
int			 accept_reserve(int sockfd, struct sockaddr *addr,
			    socklen_t *addrlen, int reserve);

/* index.c */
int			 index_entry(struct namespace *ns, struct btval *dn,
				struct ber_element *elm);
int			 unindex_entry(struct namespace *ns, struct btval *dn,
				struct ber_element *elm);
int			 index_to_dn(struct namespace *ns, struct btval *indx,
				struct btval *dn);

/* validate.c */
int	validate_entry(const char *dn, struct ber_element *entry, int relax);

#endif /* _LDAPD_H */

@


1.27
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok krw@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.26 2016/05/01 00:32:37 jmatthew Exp $ */
d330 7
d361 1
a361 2
pid_t			 ldape(struct passwd *pw, char *csockpath,
				int pipe_parent2ldap[2]);
@


1.26
log
@convert ldapd to use the libtls api, bringing in a copy of the evbuffer_tls
code from syslogd.

ok beck@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.25 2015/11/02 06:32:51 jmatthew Exp $ */
d467 1
a467 11
/* log.c */
void			 log_init(int);
void			 log_verbose(int v);
void			 vlog(int, const char *, va_list);
void			 logit(int pri, const char *fmt, ...);
void			 log_warn(const char *, ...);
void			 log_warnx(const char *, ...);
void			 log_info(const char *, ...);
void			 log_debug(const char *, ...);
__dead void		 fatal(const char *);
__dead void		 fatalx(const char *);
a472 1

@


1.25
log
@use SOCK_NONBLOCK instead of fcntl

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.24 2015/01/16 16:04:38 deraadt Exp $ */
d33 1
d39 1
d208 1
a208 1
	void			*ssl_ctx;
d228 2
a229 6
	struct event		 s_ev;
	struct timeval		 s_tv;
	struct listener		*s_l;
	void			*s_ssl;
	unsigned char		*s_buf;
	int			 s_buflen;
d237 4
a240 4
	char			*ssl_cert;
	off_t			 ssl_cert_len;
	char			*ssl_key;
	off_t			 ssl_key_len;
d242 1
d463 3
a502 15

/* ssl.c */
void	 ssl_init(void);
void	 ssl_transaction(struct conn *);

void	 ssl_session_init(struct conn *);
void	 ssl_session_destroy(struct conn *);
int	 ssl_load_certfile(struct ldapd_config *, const char *, u_int8_t);
void	 ssl_setup(struct ldapd_config *, struct listener *);
int	 ssl_cmp(struct ssl *, struct ssl *);
SPLAY_PROTOTYPE(ssltree, ssl, ssl_nodes, ssl_cmp);

/* ssl_privsep.c */
int	 ssl_ctx_use_private_key(void *, char *, off_t);
int	 ssl_ctx_use_certificate_chain(void *, char *, off_t);
@


1.24
log
@change to <limits.h> universe.  The only changes in the binary are due
to the heavy use of assert.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.23 2012/06/16 00:08:32 jmatthew Exp $ */
a334 1
void			 fd_nonblock(int fd);
@


1.23
log
@Protect against fd exhaustion when reopening database files.  Only accept
client or control connections when there are at least 8 fds available,
and close a connection before calling imsg_read if it would be unable to
accept an fd from the parent process.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.22 2012/04/11 08:31:37 deraadt Exp $ */
a26 1
#include <sys/param.h>
d287 1
a287 1
	char			 path[MAXPATHLEN+1];
@


1.22
log
@rate limiting of accept() in various cases.  Testing by jmatthew.  there
maybe still be a corner case where it needs one more file descriptor
beyond the limit..
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.21 2010/11/10 08:00:54 martinh Exp $ */
d48 1
d351 1
d406 1
d439 1
d493 2
@


1.21
log
@Make -dvv flags produce debug traces of decoded BER messages on stderr.
Also shows a hexdump of the input buffer if BER decoding fails.
Useful when debugging protocol issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.20 2010/11/03 10:33:17 martinh Exp $ */
d203 1
d213 1
a213 2
struct conn
{
d326 1
@


1.20
log
@Evaluate filters according to the three-valued logic of X.511, as required
by RFC 4511. A filter term can now be evaluated as undefined if the
attribute description is not recognized, the attribute type doesn't define
the appropriate matching rule, or the filtering is not implemented.

This also implements the NOT filter in the query planner.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.19 2010/10/19 09:10:12 martinh Exp $ */
d475 3
@


1.19
log
@Remember the bind DN after BSD authentication. This makes access control
work for SASL and BSDAUTH binds as it does for simple binds.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.18 2010/09/01 17:34:15 martinh Exp $ */
d96 2
a97 2
	INDEX_SUBSTR,
	INDEX_PRESENCE
d152 7
d160 1
d438 1
a438 1
				struct ber_element *filter);
@


1.18
log
@Move generic imsg/libevent glue to a separate file.

with eric@@ at c2k10
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.17 2010/07/10 14:27:15 martinh Exp $ */
d213 1
@


1.17
log
@Retry requests when the btree is busy. Without this, clients will just hang
waiting for a response if the btree was being reopened when the request was
received.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.16 2010/07/01 20:09:34 martinh Exp $ */
d38 1
a300 8
};

struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	void			*data;
	short			 events;
@


1.16
log
@Implement the LDAP compare operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.15 2010/06/30 19:26:39 martinh Exp $ */
d398 2
a399 1
void			 namespace_queue_schedule(struct namespace *ns);
@


1.15
log
@Add a global root user that is allowed to read/write entries in all local
namespaces. Useful for dump/restore of all namespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.14 2010/06/29 21:54:38 martinh Exp $ */
d356 1
@


1.14
log
@Add support for referrals. Referrals are configured in the config file,
either in the global context or in a namespace. The latter can be used to
delegate requests to different servers for specific parts of the DIT. The
former is a global catch-all referral.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.13 2010/06/29 21:00:34 martinh Exp $ */
d244 2
@


1.13
log
@Remember on what listener a connection got from, and return protocol error
if trying to use starttls without a configured certificate, instead of just
blocking the client.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.12 2010/06/29 02:45:46 martinh Exp $ */
d106 6
d115 1
d241 1
d359 2
d380 2
d383 2
@


1.12
log
@Rewrite the schema parser, as it's not a context-free grammar.
This also brings the config parser more in line with other parse.y in the
tree. The new schema parser also supports symbolic OID names.

You need to update your /etc/ldapd.conf. Schema files are no longer
included with the 'include' keyword, you have to use 'schema' for that.

Moves schema-related structures to a separate include file to ease reuse.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.11 2010/06/27 18:31:12 martinh Exp $ */
d206 1
@


1.11
log
@return value unused, found by lint
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.10 2010/06/27 16:24:17 martinh Exp $ */
d36 1
a217 78
enum usage {
	USAGE_USER_APP,
	USAGE_DIR_OP,		/* operational attribute */
	USAGE_DIST_OP,		/* operational attribute */
	USAGE_DSA_OP		/* operational attribute */
};

struct name {
	SLIST_ENTRY(name)	 next;
	const char		*name;
};
SLIST_HEAD(name_list, name);

struct attr_type {
	RB_ENTRY(attr_type)	 link;
	const char		*oid;
	struct name_list	*names;
	char			*desc;
	int			 obsolete;
	struct attr_type	*sup;
	char			*equality;
	char			*ordering;
	char			*substr;
	char			*syntax;
	int			 single;
	int			 collective;
	int			 immutable;	/* no-user-modification */
	enum usage		 usage;
};
RB_HEAD(attr_type_tree, attr_type);
RB_PROTOTYPE(attr_type_tree, attr_type, link, attr_oid_cmp);

struct attr_ptr {
	SLIST_ENTRY(attr_ptr)	 next;
	struct attr_type	*attr_type;
};
SLIST_HEAD(attr_list, attr_ptr);

enum object_kind {
	KIND_ABSTRACT,
	KIND_STRUCTURAL,
	KIND_AUXILIARY
};

struct object;
struct obj_ptr {
	SLIST_ENTRY(obj_ptr)	 next;
	struct object		*object;
};
SLIST_HEAD(obj_list, obj_ptr);

struct object {
	RB_ENTRY(object)	 link;
	const char		*oid;
	struct name_list	*names;
	char			*desc;
	int			 obsolete;
	struct obj_list		*sup;
	enum object_kind	 kind;
	struct attr_list	*must;
	struct attr_list	*may;
};
RB_HEAD(object_tree, object);
RB_PROTOTYPE(object_tree, object, link, obj_oid_cmp);

struct oidname {
	RB_ENTRY(oidname)	 link;
	const char		*on_name;
#define	on_attr_type		 on_ptr.ou_attr_type
#define	on_object		 on_ptr.ou_object
	union	{
		struct attr_type	*ou_attr_type;
		struct object		*ou_object;
	} on_ptr;
};
RB_HEAD(oidname_tree, oidname);
RB_PROTOTYPE(oidname_tree, oidname, link, oidname_cmp);

a230 4
	struct attr_type_tree		 attr_types;
	struct oidname_tree		 attr_names;
	struct object_tree		 objects;
	struct oidname_tree		 object_names;
d234 1
a438 6
struct attr_type	*lookup_attribute_by_oid(const char *oid);
struct attr_type	*lookup_attribute_by_name(const char *name);
struct attr_type	*lookup_attribute(const char *oid_or_name);
struct object		*lookup_object_by_oid(const char *oid);
struct object		*lookup_object_by_name(const char *name);
struct object		*lookup_object(const char *oid_or_name);
@


1.10
log
@Remove unused code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.9 2010/06/27 16:01:08 martinh Exp $ */
d417 1
a417 1
int			 request_dispatch(struct request *req);
@


1.9
log
@remove an unused typedef
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.8 2010/06/23 13:34:53 martinh Exp $ */
a492 1
void			 control_imsg_forward(struct imsg *);
a493 1
void			 control_end(struct ctl_conn *c);
@


1.8
log
@remove leftovers from old compaction code
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.7 2010/06/23 12:40:19 martinh Exp $ */
a377 3

struct ctl_conn;
typedef void (*ctl_close_func)(struct ctl_conn *);
@


1.7
log
@Remove compaction and indexing from ldapd. It is better done by a separate
process now that the btree can pick up the changes automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.6 2010/06/15 19:30:26 martinh Exp $ */
a357 4
	IMSG_CTL_COMPACT,
	IMSG_CTL_COMPACT_STATUS,
	IMSG_CTL_INDEX,
	IMSG_CTL_INDEX_STATUS,
a368 19
};

enum comp_state {
	COMPACT_DATA,
	COMPACT_INDX,
	COMPACT_DONE
};

struct compaction_status {
	char			 suffix[256];
	int			 db;
	int			 status;
};

struct indexer_status {
	char			 suffix[256];
	uint64_t		 entries;
	uint64_t		 ncomplete;
	int			 status;
@


1.6
log
@Move around some functions to ease re-use from ldapctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.5 2010/06/15 15:47:56 martinh Exp $ */
a119 2
	int			 compacting;	/* true if being compacted */
	int			 indexing;	/* true if being indexed */
a410 10

	ctl_close_func		 closecb;

	enum comp_state		 state;
	pid_t			 pid;		/* compaction process */
	struct namespace	*ns;		/* compacted or indexed */
	uint64_t		 ncomplete;	/* completed entries */
	int			 all;		/* 1: traverse all namespaces */
	struct cursor		*cursor;
	struct event		 ev;
a433 5
/* compact.c */
int			 run_compaction(struct ctl_conn *c,
				struct namespace *ns);
void			 check_compaction(pid_t pid, int status);

a515 1
struct ctl_conn		*control_connbypid(pid_t);
a521 4
void			 control_report_compaction(struct ctl_conn *c,
				int status);
void			 control_report_indexer( struct ctl_conn *c,
				int status);
a579 1
int			 index_namespace(struct namespace *ns);
a583 4
int			 index_attribute(struct namespace *ns, char *attr,
				struct btval *dn, struct ber_element *a);
int			 unindex_attribute(struct namespace *ns, char *attr,
				struct btval *dn, struct ber_element *a);
a585 1
int			 run_indexer(struct ctl_conn *c, struct namespace *ns);
@


1.5
log
@Make modify and simple auth requests open their own transactions, as search
already does. Trigger a reopen imsg request if either the data or index
databases are compacted. Queue the failed request and try again when the
file is reopened.

Compaction can now be done by a separate process, and ldapd will pick up
the change and reopen the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.4 2010/06/15 15:12:54 martinh Exp $ */
d597 3
@


1.4
log
@Implement support in the parent to (re-)open database files on behalf of
the unprivileged child over imsg. Part of a larger change that will fix
database compaction.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.3 2010/06/11 12:02:03 martinh Exp $ */
d495 3
a503 2
int			 namespace_should_queue(struct namespace *ns,
				struct request *req);
@


1.3
log
@Wrap searches in a read-only transaction so it is guaranteed to see a
consistent snapshot of the database.

Also fixes a couple of format string errors for long long ints.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.2 2010/06/03 17:29:54 martinh Exp $ */
d27 1
d347 5
d367 2
d480 2
@


1.2
log
@Open database files before chrooting, and use an absolute path to
the database files, instead of relying on the chrooted-to path.

This breaks compaction as the ldape process can't re-open the
database files. This is being worked on.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldapd.h,v 1.1 2010/05/31 17:36:31 martinh Exp $ */
d165 2
@


1.1
log
@Initial import of ldapd, a small LDAP daemon. Work in progress.

ok deraadt@@ jacekm@@ gilles@@ back@@ henning@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d40 1
@

