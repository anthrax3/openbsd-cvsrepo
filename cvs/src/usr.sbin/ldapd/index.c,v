head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.14
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.18
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.16
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.12
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7;
locks; strict;
comment	@ * @;


1.11
date	2017.01.20.11.55.08;	author benno;	state Exp;
branches;
next	1.10;
commitid	amLxRcKegr7GUlIs;

1.10
date	2015.12.24.17.47.57;	author mmcc;	state Exp;
branches;
next	1.9;
commitid	ZJPTqgdVcu8wUk8G;

1.9
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.8;
commitid	GouatFiJVxwlAVIQ;

1.8
date	2010.11.26.14.44.01;	author martinh;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.26.23.19.42;	author martinh;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.23.13.10.14;	author martinh;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.23.12.40.19;	author martinh;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.11.08.45.06;	author martinh;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.03.17.32.25;	author martinh;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.31.18.29.04;	author martinh;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.31.17.36.31;	author martinh;	state Exp;
branches;
next	;


desc
@@


1.11
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok krw@@ jmatthew@@
@
text
@/*	$OpenBSD: index.c,v 1.10 2015/12/24 17:47:57 mmcc Exp $ */

/*
 * Copyright (c) 2009 Martin Hedenfalk <martin@@bzero.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Indices are stored as unique keys in a btree. No data is stored.
 * The keys are made up of the attribute being indexed, concatenated
 * with the distinguished name of the entry. The namespace suffix is
 * stripped, however.
 *
 * Below, the namespace suffix dc=example,dc=com is stripped.
 *
 * Index b-tree sorts with plain strcmp:
 * ...
 * cn=Chunky Bacon,cn=chunky bacon,ou=people,
 * cn=Chunky Bacon,uid=cbacon,ou=accounts,
 * cn=Chunky Beans,cn=chunky beans,ou=people,
 * cn=Chunky Beans,uid=cbeans,ou=accounts,
 * cn=Crispy Bacon,cn=crispy bacon,ou=people,
 * ...
 * sn=Bacon,cn=chunky bacon,ou=people,
 * sn=Bacon,cn=crispy bacon,ou=people,
 * sn=Beans,cn=chunky beans,ou=people,
 * ...
 * This index can be used for equality, prefix and range searches.
 *
 * If an indexed attribute sorts numerically (integer), we might be able
 * to just pad it with zeros... otherwise this needs to be refined.
 *
 * Multiple attributes can be indexed in the same database.
 *
 * Presence index can be stored as:
 * !mail,cn=chunky bacon,ou=people,
 * !mail,cn=chunky beans,ou=people,
 * !mail,cn=crispy bacon,ou=people,
 *
 * Substring index could probably be stored like a suffix tree:
 * sn>Bacon,cn=chunky bacon,ou=people,
 * sn>acon,cn=chunky bacon,ou=people,
 * sn>con,cn=chunky bacon,ou=people,
 * sn>on,cn=chunky bacon,ou=people,
 * sn>n,cn=chunky bacon,ou=people,
 *
 * This facilitates both substring and suffix search.
 *
 * Approximate index:
 * sn~[soundex(bacon)],cn=chunky bacon,ou=people,
 *
 * One level searches can be indexed as follows:
 * @@<parent-rdn>,<rdn>
 * example:
 * @@ou=accounts,uid=cbacon
 * @@ou=accounts,uid=cbeans
 * @@ou=people,cn=chunky bacon
 * @@ou=people,cn=chunky beans
 * @@ou=people,cn=crispy bacon
 *
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <assert.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include "ldapd.h"
#include "log.h"

static int
index_attribute(struct namespace *ns, char *attr, struct btval *dn,
    struct ber_element *a)
{
	int			 dnsz, rc;
	char			*s, *t;
	struct ber_element	*v;
	struct btval		 key, val;

	assert(ns);
	assert(ns->indx_txn);
	assert(attr);
	assert(dn);
	assert(a);
	assert(a->be_next);
	memset(&val, 0, sizeof(val));

	log_debug("indexing %.*s on %s", (int)dn->size, (char *)dn->data, attr);

	dnsz = dn->size - strlen(ns->suffix);

	for (v = a->be_next->be_sub; v; v = v->be_next) {
		if (ber_get_string(v, &s) != 0)
			continue;
		memset(&key, 0, sizeof(key));
		key.size = asprintf(&t, "%s=%s,%.*s", attr, s, dnsz,
		    (char *)dn->data);
		if (key.size == (size_t)-1)
			return -1;
		key.data = t;
		normalize_dn(key.data);
		rc = btree_txn_put(NULL, ns->indx_txn, &key, &val,
		    BT_NOOVERWRITE);
		free(t);
		if (rc == -1 && errno != EEXIST)
			return -1;
	}

	return 0;
}

static int
index_rdn_key(struct namespace *ns, struct btval *dn, struct btval *key)
{
	int		 dnsz, rdnsz, pdnsz;
	char		*t, *parent_dn;

	memset(key, 0, sizeof(*key));

	dnsz = dn->size - strlen(ns->suffix);
	if (dnsz-- == 0)
		return -1;

	parent_dn = memchr(dn->data, ',', dnsz);
	if (parent_dn == NULL) {
		rdnsz = dnsz;
		pdnsz = 0;
	} else {
		rdnsz = parent_dn - (char *)dn->data;
		pdnsz = dnsz - rdnsz - 1;
		++parent_dn;
	}

	if (asprintf(&t, "@@%.*s,%.*s", pdnsz, parent_dn, rdnsz,
	    (char *)dn->data) == -1)
		return -1;

	normalize_dn(t);
	key->data = t;
	key->size = strlen(t);
	key->free_data = 1;

	return 0;
}

static int
index_rdn(struct namespace *ns, struct btval *dn)
{
	struct btval	 key, val;
	int		 rc;

	memset(&val, 0, sizeof(val));

	assert(ns);
	assert(ns->indx_txn);
	assert(dn);

	if (index_rdn_key(ns, dn, &key) < 0)
		return 0;

	log_debug("indexing rdn on %.*s", (int)key.size, (char *)key.data);
	rc = btree_txn_put(NULL, ns->indx_txn, &key, &val, BT_NOOVERWRITE);
	btval_reset(&key);
	if (rc == -1 && errno != EEXIST)
		return -1;
	return 0;
}

static int
unindex_attribute(struct namespace *ns, char *attr, struct btval *dn,
    struct ber_element *a)
{
	int			 dnsz, rc;
	char			*s, *t;
	struct ber_element	*v;
	struct btval		 key;

	assert(ns);
	assert(ns->indx_txn);
	assert(attr);
	assert(dn);
	assert(a);
	assert(a->be_next);

	log_debug("unindexing %.*s on %s",
	    (int)dn->size, (char *)dn->data, attr);

	dnsz = dn->size - strlen(ns->suffix);

	for (v = a->be_next->be_sub; v; v = v->be_next) {
		if (ber_get_string(v, &s) != 0)
			continue;
		memset(&key, 0, sizeof(key));
		key.size = asprintf(&t, "%s=%s,%.*s", attr, s, dnsz,
		    (char *)dn->data);
		key.data = t;
		normalize_dn(key.data);
		rc = btree_txn_del(NULL, ns->indx_txn, &key, NULL);
		free(t);
		if (rc == BT_FAIL && errno != ENOENT)
			return -1;
	}

	return 0;
}

int
index_entry(struct namespace *ns, struct btval *dn, struct ber_element *elm)
{
	struct ber_element	*a;
	struct attr_index	*ai;

	assert(ns);
	assert(dn);
	assert(elm);
	TAILQ_FOREACH(ai, &ns->indices, next) {
		a = ldap_get_attribute(elm, ai->attr);
		if (a && index_attribute(ns, ai->attr, dn, a) < 0)
			return -1;
	}

	return index_rdn(ns, dn);
}

static int
unindex_rdn(struct namespace *ns, struct btval *dn)
{
	int		 rc;
	struct btval	 key;

	assert(ns);
	assert(ns->indx_txn);
	assert(dn);

	if (index_rdn_key(ns, dn, &key) < 0)
		return 0;

	log_debug("unindexing rdn on %.*s", (int)key.size, (char *)key.data);
	rc = btree_txn_del(NULL, ns->indx_txn, &key, NULL);
	btval_reset(&key);
	if (rc == BT_FAIL && errno != ENOENT)
		return -1;
	return 0;
}

int
unindex_entry(struct namespace *ns, struct btval *dn, struct ber_element *elm)
{
	struct ber_element	*a;
	struct attr_index	*ai;

	assert(ns);
	assert(dn);
	assert(elm);
	TAILQ_FOREACH(ai, &ns->indices, next) {
		a = ldap_get_attribute(elm, ai->attr);
		if (a && unindex_attribute(ns, ai->attr, dn, a) < 0)
			return -1;
	}

	return unindex_rdn(ns, dn);
}

/* Reconstruct the full dn from the index key and the namespace suffix.
 *
 * Examples:
 *
 * index key:
 *   sn=Bacon,cn=chunky bacon,ou=people,
 * full dn:
 *   cn=chunky bacon,ou=people,dc=example,dc=com
 *
 * index key:
 *   @@ou=people,cn=chunky bacon
 * full dn:
 *   cn=chunky bacon,ou=people,dc=example,dc=com
 *
 * index key:
 *   @@,ou=people
 * full dn:
 *   ou=people,dc=example,dc=com
 *
 * index key:
 *   @@ou=staff,ou=people,cn=chunky bacon
 * full dn:
 *   cn=chunky bacon,ou=staff,ou=people,dc=example,dc=com
 *
 * Filled in dn must be freed with btval_reset().
 */
int
index_to_dn(struct namespace *ns, struct btval *indx, struct btval *dn)
{
	char		*rdn, *parent_rdn, indxtype, *dst;
	int		 rdn_sz, prdn_sz;

	/* Skip past first index part to get the RDN.
	 */

	indxtype = ((char *)indx->data)[0];
	if (indxtype == '@@') {
		/* One-level index.
		 * Full DN is made up of rdn + parent rdn + namespace suffix.
		 */
		rdn = memrchr(indx->data, ',', indx->size);
		if (rdn++ == NULL)
			return -1;
		rdn_sz = indx->size - (rdn - (char *)indx->data);

		parent_rdn = (char *)indx->data + 1;
		prdn_sz = rdn - parent_rdn - 1;
		dn->size = indx->size + strlen(ns->suffix);
		if (prdn_sz == 0)
			dn->size--;
		if ((dn->data = malloc(dn->size)) == NULL) {
			log_warn("conn_search: malloc");
			return -1;
		}
		dst = dn->data;
		bcopy(rdn, dst, rdn_sz);
		dst += rdn_sz;
		*dst++ = ',';
		bcopy(parent_rdn, dst, prdn_sz);
		dst += prdn_sz;
		if (prdn_sz > 0)
			*dst++ = ',';
		bcopy(ns->suffix, dst, strlen(ns->suffix));
	} else {
		/* Construct the full DN by appending namespace suffix.
		 */
		rdn = memchr(indx->data, ',', indx->size);
		if (rdn++ == NULL)
			return -1;
		rdn_sz = indx->size - (rdn - (char *)indx->data);
		dn->size = rdn_sz + strlen(ns->suffix);
		if ((dn->data = malloc(dn->size)) == NULL) {
			log_warn("index_to_dn: malloc");
			return -1;
		}
		bcopy(rdn, dn->data, rdn_sz);
		bcopy(ns->suffix, (char *)dn->data + rdn_sz,
		    strlen(ns->suffix));
	}

	dn->free_data = 1;

	return 0;
}

@


1.10
log
@bzero -> memset. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: index.c,v 1.9 2015/06/03 02:24:36 millert Exp $ */
d82 1
@


1.9
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: index.c,v 1.8 2010/11/26 14:44:01 martinh Exp $ */
d98 1
a98 1
	bzero(&val, sizeof(val));
d107 1
a107 1
		bzero(&key, sizeof(key));
d130 1
a130 1
	bzero(key, sizeof(*key));
d164 1
a164 1
	bzero(&val, sizeof(val));
d205 1
a205 1
		bzero(&key, sizeof(key));
@


1.8
log
@Unbreak re-indexing by checking if an index entry already exists.
@
text
@d1 1
a1 1
/*	$OpenBSD: index.c,v 1.7 2010/06/26 23:19:42 martinh Exp $ */
d110 2
d146 3
a148 1
	asprintf(&t, "@@%.*s,%.*s", pdnsz, parent_dn, rdnsz, (char *)dn->data);
@


1.7
log
@Unbreak removal of one-level search index.
@
text
@d1 1
a1 1
/*	$OpenBSD: index.c,v 1.6 2010/06/23 13:10:14 martinh Exp $ */
d115 1
a115 1
		if (rc == BT_FAIL)
d172 1
a172 1
	if (rc == BT_FAIL)
@


1.6
log
@Set errno to appropriate values when returning failure in btree. Make btree
functions only return success or failure (-1 or NULL). Update callers to
check errno.
@
text
@d1 1
a1 1
/*	$OpenBSD: index.c,v 1.5 2010/06/23 12:40:19 martinh Exp $ */
d123 1
a123 1
index_rdn(struct namespace *ns, struct btval *dn)
d125 1
a125 1
	int		 dnsz, rdnsz, pdnsz, rc;
a126 1
	struct btval	 key, val;
d128 1
a128 5
	bzero(&val, sizeof(val));

	assert(ns);
	assert(ns->indx_txn);
	assert(dn);
d132 1
a132 1
		return 0;
d144 25
a168 3
	key.size = asprintf(&t, "@@%.*s,%.*s", pdnsz, parent_dn,
	    rdnsz, (char *)dn->data);
	key.data = t;
a169 1
	normalize_dn(key.data);
d171 1
a171 1
	free(t);
d236 2
a237 5
	int		 dnsz, rdnsz, rc;
	char		*t, *parent_dn;
	struct btval	 key, val;

	bzero(&val, sizeof(val));
d243 2
a244 1
	dnsz = dn->size - strlen(ns->suffix);
a245 8
	parent_dn = memchr(dn->data, ',', dn->size);
	if (parent_dn++ == NULL)
		parent_dn = (char *)dn->data + dn->size;
	rdnsz = parent_dn - (char *)dn->data;

	key.size = asprintf(&t, "@@%.*s,%.*s", (dnsz - rdnsz), parent_dn,
	    rdnsz, (char *)dn->data);
	key.data = t;
a246 1
	normalize_dn(key.data);
d248 1
a248 1
	free(t);
@


1.5
log
@Remove compaction and indexing from ldapd. It is better done by a separate
process now that the btree can pick up the changes automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: index.c,v 1.4 2010/06/11 08:45:06 martinh Exp $ */
d77 1
d192 1
a192 1
		if (rc == BT_FAIL)
d244 1
a244 1
	if (rc == BT_FAIL)
@


1.4
log
@Track changes in btree_txn_* API, pass a NULL btree when also passing a
transaction.
@
text
@d1 1
a1 1
/*	$OpenBSD: index.c,v 1.3 2010/06/03 17:32:25 martinh Exp $ */
d82 1
a82 4
static void	 continue_indexer(int fd, short why, void *arg);
static void	 stop_indexer(struct ctl_conn *c);

int
d160 1
a160 1
int
a348 139
}

/* Return the next namespace that isn't already being indexed or compacted.
 */
static struct namespace *
next_namespace(struct namespace *ns)
{
	if (ns == NULL)
		ns = TAILQ_FIRST(&conf->namespaces);
	else
		ns = TAILQ_NEXT(ns, next);

	do {
		if (ns == NULL || (!ns->indexing && !ns->compacting))
			break;
	} while ((ns = TAILQ_NEXT(ns, next)) != NULL);

	return ns;
}

static void
continue_indexer(int fd, short why, void *arg)
{
	struct ctl_conn		*c = arg;
	struct ber_element	*elm;
	struct btval		 key, val;
	struct timeval		 tv;
	int			 i, rc = BT_FAIL;

	if (c->cursor == NULL) {
		log_info("begin indexing namespace %s", c->ns->suffix);
		c->ncomplete = 0;
		c->ns->indexing = 1;
		c->cursor = btree_cursor_open(c->ns->data_db);
		if (c->cursor == NULL) {
			log_warn("failed to open cursor");
			goto fail;
		}
	}

	bzero(&key, sizeof(key));
	bzero(&val, sizeof(val));

	tv.tv_sec = 0;
	tv.tv_usec = 0;

	if (namespace_begin(c->ns) != 0) {
		tv.tv_usec = 50000;
		evtimer_add(&c->ev, &tv);
		return;
	}

	for (i = 0; i < 40; i++) {
		rc = btree_cursor_get(c->cursor, &key, &val, BT_NEXT);
		if (rc != BT_SUCCESS)
			break;
		if ((elm = namespace_db2ber(c->ns, &val)) == NULL)
			continue;
		rc = index_entry(c->ns, &key, elm);
		ber_free_elements(elm);
		btval_reset(&key);
		btval_reset(&val);
		if (rc != 0)
			goto fail;
		++c->ncomplete;
	}

	if (namespace_commit(c->ns) != 0)
		goto fail;

	control_report_indexer(c, 0);

	if (rc == BT_NOTFOUND) {
		log_info("done indexing namespace %s", c->ns->suffix);
		btree_cursor_close(c->cursor);
		c->cursor = NULL;
		c->ns->indexing = 0;
		control_report_indexer(c, 1);

		if (c->all)
			c->ns = next_namespace(c->ns);
		else
			c->ns = NULL;

		if (c->ns == NULL) {
			log_info("done indexing all namespaces");
			return;
		}
	} else if (rc != BT_SUCCESS)
		goto fail;

	evtimer_add(&c->ev, &tv);
	return;

fail:
	if (c->ns != NULL)
		control_report_indexer(c, -1);
	control_end(c);
	stop_indexer(c);
}

/* Run indexing for the given namespace, or all namespaces if ns is NULL.
 *
 * Returns 0 on success, or -1 on error.
 */
int
run_indexer(struct ctl_conn *c, struct namespace *ns)
{
	if (ns == NULL) {
		c->all = 1;
		c->ns = next_namespace(NULL);
	} else {
		c->all = 0;
		c->ns = ns;
	}

	if (c->ns == NULL) {
		control_end(c);
	} else {
		c->closecb = stop_indexer;
		evtimer_set(&c->ev, continue_indexer, c);
		continue_indexer(0, 0, c);
	}

	return 0;
}

static void
stop_indexer(struct ctl_conn *c)
{
	if (c->ns != NULL) {
		log_info("stopped indexing namespace %s", c->ns->suffix);
		c->ns->indexing = 0;
	}
	btree_cursor_close(c->cursor);
	c->cursor = NULL;
	c->ns = NULL;
	c->closecb = NULL;
	evtimer_del(&c->ev);
@


1.3
log
@Fix compilation on gcc2. Check a return value from malloc while at it.

"that compiles!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: index.c,v 1.2 2010/05/31 18:29:04 martinh Exp $ */
d114 2
a115 1
		rc = btree_txn_put(ns->indx_db, ns->indx_txn, &key, &val, BT_NOOVERWRITE);
d156 1
a156 1
	rc = btree_txn_put(ns->indx_db, ns->indx_txn, &key, &val, BT_NOOVERWRITE);
d192 1
a192 1
		rc = btree_txn_del(ns->indx_db, ns->indx_txn, &key, NULL);
d244 1
a244 1
	rc = btree_txn_del(ns->indx_db, ns->indx_txn, &key, NULL);
@


1.2
log
@Remove trailing whitespace and spaces before tabs.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: index.c,v 1.1 2010/05/31 17:36:31 martinh Exp $ */
d378 1
a378 1
	int			 i, rc;
@


1.1
log
@Initial import of ldapd, a small LDAP daemon. Work in progress.

ok deraadt@@ jacekm@@ gilles@@ back@@ henning@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d70 1
a70 1
 * 
@

