head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.2
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.12
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.10
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.6
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10;
locks; strict;
comment	@ * @;


1.17
date	2017.01.20.11.55.08;	author benno;	state Exp;
branches;
next	1.16;
commitid	amLxRcKegr7GUlIs;

1.16
date	2016.02.04.12.48.06;	author jca;	state Exp;
branches;
next	1.15;
commitid	hrTUQUsDKYDAjLPb;

1.15
date	2016.02.01.20.00.18;	author landry;	state Exp;
branches;
next	1.14;
commitid	DHpO2e5k3smQyFDY;

1.14
date	2015.12.24.17.47.57;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	ZJPTqgdVcu8wUk8G;

1.13
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.12;
commitid	jdBY2kKXhfcoQitp;

1.12
date	2012.06.16.00.08.32;	author jmatthew;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.01.17.34.15;	author martinh;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.10.14.27.15;	author martinh;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.29.21.54.38;	author martinh;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.23.13.10.14;	author martinh;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.15.19.30.26;	author martinh;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.15.15.47.56;	author martinh;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.15.15.12.54;	author martinh;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.11.08.45.06;	author martinh;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.03.17.29.54;	author martinh;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.01.15.10.04;	author martinh;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.31.17.36.31;	author martinh;	state Exp;
branches;
next	;


desc
@@


1.17
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok krw@@ jmatthew@@
@
text
@/*	$OpenBSD: namespace.c,v 1.16 2016/02/04 12:48:06 jca Exp $ */

/*
 * Copyright (c) 2009, 2010 Martin Hedenfalk <martin@@bzero.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <zlib.h>

#include "ldapd.h"
#include "log.h"

extern const char	*datadir;

/* Maximum number of requests to queue per namespace during compaction.
 * After this many requests, we return LDAP_BUSY.
 */
#define MAX_REQUEST_QUEUE	 10000

static struct btval	*namespace_find(struct namespace *ns, char *dn);
static void		 namespace_queue_replay(int fd, short event, void *arg);
static int		 namespace_set_fd(struct namespace *ns,
			    struct btree **bt, int fd, unsigned int flags);

int
namespace_begin_txn(struct namespace *ns, struct btree_txn **data_txn,
    struct btree_txn **indx_txn, int rdonly)
{
	if (ns->data_db == NULL || ns->indx_db == NULL) {
		errno = EBUSY;	/* namespace is being reopened */
		return -1;
	}

	if ((*data_txn = btree_txn_begin(ns->data_db, rdonly)) == NULL ||
	    (*indx_txn = btree_txn_begin(ns->indx_db, rdonly)) == NULL) {
		if (errno == ESTALE) {
			if (*data_txn == NULL)
				namespace_reopen_data(ns);
			else
				namespace_reopen_indx(ns);
			errno = EBUSY;
		}
		log_warn("failed to open transaction");
		btree_txn_abort(*data_txn);
		*data_txn = NULL;
		return -1;
	}

	return 0;
}

int
namespace_begin(struct namespace *ns)
{
	return namespace_begin_txn(ns, &ns->data_txn, &ns->indx_txn, 0);
}

int
namespace_commit(struct namespace *ns)
{
	if (ns->indx_txn != NULL &&
	    btree_txn_commit(ns->indx_txn) != BT_SUCCESS) {
		log_warn("%s(indx): commit failed", ns->suffix);
		btree_txn_abort(ns->data_txn);
		ns->indx_txn = ns->data_txn = NULL;
		return -1;
	}
	ns->indx_txn = NULL;

	if (ns->data_txn != NULL &&
	    btree_txn_commit(ns->data_txn) != BT_SUCCESS) {
		log_warn("%s(data): commit failed", ns->suffix);
		ns->data_txn = NULL;
		return -1;
	}
	ns->data_txn = NULL;

	return 0;
}

void
namespace_abort(struct namespace *ns)
{
	btree_txn_abort(ns->data_txn);
	ns->data_txn = NULL;

	btree_txn_abort(ns->indx_txn);
	ns->indx_txn = NULL;
}

int
namespace_open(struct namespace *ns)
{
	unsigned int	 db_flags = 0;

	assert(ns);
	assert(ns->suffix);

	if (ns->sync == 0)
		db_flags |= BT_NOSYNC;

	if (asprintf(&ns->data_path, "%s/%s_data.db", datadir, ns->suffix) < 0)
		return -1;
	log_info("opening namespace %s", ns->suffix);
	ns->data_db = btree_open(ns->data_path, db_flags | BT_REVERSEKEY, 0644);
	if (ns->data_db == NULL)
		return -1;

	btree_set_cache_size(ns->data_db, ns->cache_size);

	if (asprintf(&ns->indx_path, "%s/%s_indx.db", datadir, ns->suffix) < 0)
		return -1;
	ns->indx_db = btree_open(ns->indx_path, db_flags, 0644);
	if (ns->indx_db == NULL)
		return -1;

	btree_set_cache_size(ns->indx_db, ns->index_cache_size);

	/* prepare request queue scheduler */
	evtimer_set(&ns->ev_queue, namespace_queue_replay, ns);

	return 0;
}

static int
namespace_reopen(const char *path)
{
	struct open_req		 req;

	log_debug("asking parent to open %s", path);

	memset(&req, 0, sizeof(req));
	if (strlcpy(req.path, path, sizeof(req.path)) >= sizeof(req.path)) {
		log_warnx("%s: path truncated", __func__);
		return -1;
	}

	return imsgev_compose(iev_ldapd, IMSG_LDAPD_OPEN, 0, 0, -1, &req,
	    sizeof(req));
}

int
namespace_reopen_data(struct namespace *ns)
{
	if (ns->data_db != NULL) {
		btree_close(ns->data_db);
		ns->data_db = NULL;
		return namespace_reopen(ns->data_path);
	}
	return 1;
}

int
namespace_reopen_indx(struct namespace *ns)
{
	if (ns->indx_db != NULL) {
		btree_close(ns->indx_db);
		ns->indx_db = NULL;
		return namespace_reopen(ns->indx_path);
	}
	return 1;
}

static int
namespace_set_fd(struct namespace *ns, struct btree **bt, int fd,
    unsigned int flags)
{
	log_info("reopening namespace %s (entries)", ns->suffix);
	btree_close(*bt);
	if (ns->sync == 0)
		flags |= BT_NOSYNC;
	*bt = btree_open_fd(fd, flags);
	if (*bt == NULL)
		return -1;
	return 0;
}

int
namespace_set_data_fd(struct namespace *ns, int fd)
{
	return namespace_set_fd(ns, &ns->data_db, fd, BT_REVERSEKEY);
}

int
namespace_set_indx_fd(struct namespace *ns, int fd)
{
	return namespace_set_fd(ns, &ns->indx_db, fd, 0);
}

void
namespace_close(struct namespace *ns)
{
	struct conn		*conn;
	struct search		*search, *next;
	struct request		*req;

	/* Cancel any queued requests for this namespace.
	 */
	if (ns->queued_requests > 0) {
		log_warnx("cancelling %u queued requests on namespace %s",
		    ns->queued_requests, ns->suffix);
		while ((req = TAILQ_FIRST(&ns->request_queue)) != NULL) {
			TAILQ_REMOVE(&ns->request_queue, req, next);
			ldap_respond(req, LDAP_UNAVAILABLE);
		}
	}

	/* Cancel any searches on this namespace.
	 */
	TAILQ_FOREACH(conn, &conn_list, next) {
		for (search = TAILQ_FIRST(&conn->searches); search != NULL;
		    search = next) {
			next = TAILQ_NEXT(search, next);
			if (search->ns == ns)
				search_close(search);
		}
	}

	free(ns->suffix);
	btree_close(ns->data_db);
	btree_close(ns->indx_db);
	if (evtimer_pending(&ns->ev_queue, NULL))
		evtimer_del(&ns->ev_queue);
	free(ns->data_path);
	free(ns->indx_path);
	free(ns);
}

void
namespace_remove(struct namespace *ns)
{
	TAILQ_REMOVE(&conf->namespaces, ns, next);
	namespace_close(ns);
}

static struct btval *
namespace_find(struct namespace *ns, char *dn)
{
	struct btval		 key;
	static struct btval	 val;

	if (ns->data_db == NULL) {
		errno = EBUSY;	/* namespace is being reopened */
		return NULL;
	}

	memset(&key, 0, sizeof(key));
	memset(&val, 0, sizeof(val));

	key.data = dn;
	key.size = strlen(dn);

	if (btree_txn_get(ns->data_db, ns->data_txn, &key, &val) != 0) {
		if (errno == ENOENT)
			log_debug("%s: dn not found", dn);
		else
			log_warn("%s", dn);

		if (errno == ESTALE)
			namespace_reopen_data(ns);

		return NULL;
	}

	return &val;
}

struct ber_element *
namespace_get(struct namespace *ns, char *dn)
{
	struct ber_element	*elm;
	struct btval		*val;

	if ((val = namespace_find(ns, dn)) == NULL)
		return NULL;

	elm = namespace_db2ber(ns, val);
	btval_reset(val);
	return elm;
}

int
namespace_exists(struct namespace *ns, char *dn)
{
	struct btval		*val;

	if ((val = namespace_find(ns, dn)) == NULL)
		return 0;
	btval_reset(val);
	return 1;
}

int
namespace_ber2db(struct namespace *ns, struct ber_element *root,
    struct btval *val)
{
	return ber2db(root, val, ns->compression_level);
}

struct ber_element *
namespace_db2ber(struct namespace *ns, struct btval *val)
{
	return db2ber(val, ns->compression_level);
}

static int
namespace_put(struct namespace *ns, char *dn, struct ber_element *root,
    int update)
{
	int			 rc;
	struct btval		 key, val;

	assert(ns != NULL);
	assert(ns->data_txn != NULL);
	assert(ns->indx_txn != NULL);

	memset(&key, 0, sizeof(key));
	key.data = dn;
	key.size = strlen(dn);

	if (namespace_ber2db(ns, root, &val) != 0)
		return BT_FAIL;

	rc = btree_txn_put(NULL, ns->data_txn, &key, &val,
	    update ? 0 : BT_NOOVERWRITE);
	if (rc != BT_SUCCESS) {
		if (errno == EEXIST)
			log_debug("%s: already exists", dn);
		else
			log_warn("%s", dn);
		goto done;
	}

	/* FIXME: if updating, try harder to just update changed indices.
	 */
	if (update && (rc = unindex_entry(ns, &key, root)) != BT_SUCCESS)
		goto done;

	rc = index_entry(ns, &key, root);

done:
	btval_reset(&val);
	return rc;
}

int
namespace_add(struct namespace *ns, char *dn, struct ber_element *root)
{
	return namespace_put(ns, dn, root, 0);
}

int
namespace_update(struct namespace *ns, char *dn, struct ber_element *root)
{
	return namespace_put(ns, dn, root, 1);
}

int
namespace_del(struct namespace *ns, char *dn)
{
	int			 rc;
	struct ber_element	*root;
	struct btval		 key, data;

	assert(ns != NULL);
	assert(ns->indx_txn != NULL);
	assert(ns->data_txn != NULL);

	memset(&key, 0, sizeof(key));
	memset(&data, 0, sizeof(data));

	key.data = dn;
	key.size = strlen(key.data);

	rc = btree_txn_del(NULL, ns->data_txn, &key, &data);
	if (rc == BT_SUCCESS && (root = namespace_db2ber(ns, &data)) != NULL)
		rc = unindex_entry(ns, &key, root);

	btval_reset(&data);
	return rc;
}

int
namespace_has_referrals(struct namespace *ns)
{
	return !SLIST_EMPTY(&ns->referrals);
}

struct namespace *
namespace_lookup_base(const char *basedn, int include_referrals)
{
	size_t			 blen, slen;
	struct namespace	*ns, *matched_ns = NULL;

	assert(basedn);
	blen = strlen(basedn);

	TAILQ_FOREACH(ns, &conf->namespaces, next) {
		slen = strlen(ns->suffix);
		if ((include_referrals || !namespace_has_referrals(ns)) &&
		    blen >= slen &&
		    bcmp(basedn + blen - slen, ns->suffix, slen) == 0) {
			/* Match the longest namespace suffix. */
			if (matched_ns == NULL ||
			    strlen(ns->suffix) > strlen(matched_ns->suffix))
				matched_ns = ns;
		}
	}

	return matched_ns;
}

struct namespace *
namespace_for_base(const char *basedn)
{
	return namespace_lookup_base(basedn, 0);
}

struct referrals *
namespace_referrals(const char *basedn)
{
	struct namespace	*ns;

	if ((ns = namespace_lookup_base(basedn, 1)) != NULL &&
	    namespace_has_referrals(ns))
		return &ns->referrals;

	if (!SLIST_EMPTY(&conf->referrals))
		return &conf->referrals;

	return NULL;
}

int
namespace_has_index(struct namespace *ns, const char *attr,
    enum index_type type)
{
	struct attr_index	*ai;

	assert(ns);
	assert(attr);
	TAILQ_FOREACH(ai, &ns->indices, next) {
		if (strcasecmp(attr, ai->attr) == 0 && ai->type == type)
			return 1;
	}

	return 0;
}

/* Queues modification requests while the namespace is being reopened.
 */
int
namespace_queue_request(struct namespace *ns, struct request *req)
{
	if (ns->queued_requests > MAX_REQUEST_QUEUE) {
		log_warn("%u requests alreay queued, sorry");
		return -1;
	}

	TAILQ_INSERT_TAIL(&ns->request_queue, req, next);
	ns->queued_requests++;

	if (!evtimer_pending(&ns->ev_queue, NULL))
		namespace_queue_schedule(ns, 250000);

	return 0;
}

static void
namespace_queue_replay(int fd, short event, void *data)
{
	struct namespace	*ns = data;
	struct request		*req;

	if (ns->data_db == NULL || ns->indx_db == NULL) {
		log_debug("%s: database is being reopened", ns->suffix);
		return;		/* Database is being reopened. */
	}

	if ((req = TAILQ_FIRST(&ns->request_queue)) == NULL)
		return;
	TAILQ_REMOVE(&ns->request_queue, req, next);

	log_debug("replaying queued request");
	req->replayed = 1;
	request_dispatch(req);
	ns->queued_requests--;

	if (!evtimer_pending(&ns->ev_queue, NULL))
		namespace_queue_schedule(ns, 0);
}

void
namespace_queue_schedule(struct namespace *ns, unsigned int usec)
{
	struct timeval	 tv;

	tv.tv_sec = 0;
	tv.tv_usec = usec;
	evtimer_add(&ns->ev_queue, &tv);
}

/* Cancel all queued requests from the given connection. Drops matching
 * requests from all namespaces without sending a response.
 */
void
namespace_cancel_conn(struct conn *conn)
{
	struct namespace	*ns;
	struct request		*req, *next;

	TAILQ_FOREACH(ns, &conf->namespaces, next) {
		for (req = TAILQ_FIRST(&ns->request_queue); req != NULL;
		    req = next) {
			next = TAILQ_NEXT(req, next);

			if (req->conn == conn) {
				TAILQ_REMOVE(&ns->request_queue, req, next);
				request_free(req);
			}
		}
	}
}

int
namespace_conn_queue_count(struct conn *conn)
{
	struct namespace	*ns;
	struct request		*req;
	int			 count = 0;

	TAILQ_FOREACH(ns, &conf->namespaces, next) {
		TAILQ_FOREACH(req, &ns->request_queue, next) {
			if (req->conn == conn)
				count++;
		}
	}

	return count;
}
@


1.16
log
@Minor ldapd -r tweaks

- fix style
- the string pointed to by datadir shouldn't be modified, use const
- initialize datadir at compile time
- in namespace.c, move the extern datadir decl above local decls
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.15 2016/02/01 20:00:18 landry Exp $ */
d30 1
@


1.15
log
@Add -r argument to ldapd, to specify an alternative directory to
store/read the database, still defaulting to /var/db/ldap.

This will allow running totally separate instances, to be used by an
upcoming regress suite for example.

With a tweak from gsoares@@ to check that the directory exists.
ok dlg@@ semarie@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.14 2015/12/24 17:47:57 mmcc Exp $ */
d31 2
a42 1
extern char		*datadir;
@


1.14
log
@bzero -> memset. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.13 2014/09/13 16:06:37 doug Exp $ */
d41 1
d119 1
a119 1
	if (asprintf(&ns->data_path, "%s/%s_data.db", DATADIR, ns->suffix) < 0)
d128 1
a128 1
	if (asprintf(&ns->indx_path, "%s/%s_indx.db", DATADIR, ns->suffix) < 0)
@


1.13
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.12 2012/06/16 00:08:32 jmatthew Exp $ */
d148 1
a148 1
	bzero(&req, sizeof(req));
d263 2
a264 2
	bzero(&key, sizeof(key));
	bzero(&val, sizeof(val));
d333 1
a333 1
	bzero(&key, sizeof(key));
d385 2
a386 2
	bzero(&key, sizeof(key));
	bzero(&data, sizeof(data));
@


1.12
log
@Protect against fd exhaustion when reopening database files.  Only accept
client or control connections when there are at least 8 fds available,
and close a connection before calling imsg_read if it would be unable to
accept an fd from the parent process.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.11 2010/09/01 17:34:15 martinh Exp $ */
d529 2
a530 2
		for (req = TAILQ_FIRST(&ns->request_queue);
		    req != TAILQ_END(&ns->request_queue); req = next) {
@


1.11
log
@Move generic imsg/libevent glue to a separate file.

with eric@@ at c2k10
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.10 2010/07/10 14:27:15 martinh Exp $ */
d541 16
@


1.10
log
@Retry requests when the btree is busy. Without this, clients will just hang
waiting for a response if the btree was being reopened when the request was
received.
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.9 2010/06/29 21:54:38 martinh Exp $ */
d154 1
a154 1
	return imsg_compose_event(iev_ldapd, IMSG_LDAPD_OPEN, 0, 0, -1, &req,
@


1.9
log
@Add support for referrals. Referrals are configured in the config file,
either in the global context or in a namespace. The latter can be used to
delegate requests to different servers for specific parts of the DIT. The
former is a global catch-all referral.
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.8 2010/06/23 13:10:14 martinh Exp $ */
d478 4
d504 3
d510 1
a510 1
namespace_queue_schedule(struct namespace *ns)
d514 3
a516 5
	if (!evtimer_pending(&ns->ev_queue, NULL)) {
		tv.tv_sec = 0;
		tv.tv_usec = 0;
		evtimer_add(&ns->ev_queue, &tv);
	}
@


1.8
log
@Set errno to appropriate values when returning failure in btree. Make btree
functions only return success or failure (-1 or NULL). Update callers to
check errno.
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.7 2010/06/15 19:30:26 martinh Exp $ */
d399 6
d406 1
a406 1
namespace_for_base(const char *basedn)
d409 1
a409 1
	struct namespace	*ns;
d416 8
a423 3
		if (blen >= slen &&
		    bcmp(basedn + blen - slen, ns->suffix, slen) == 0)
			return ns;
d425 21
@


1.7
log
@Move around some functions to ease re-use from ldapctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.6 2010/06/15 15:47:56 martinh Exp $ */
d45 4
a48 4
	int	rc = BT_FAIL;

	if (ns->data_db == NULL || ns->indx_db == NULL)
		return BT_DEAD;
d52 1
a52 1
		if (errno == EAGAIN) {
d57 1
a57 1
			rc = BT_DEAD;
d62 1
a62 1
		return rc;
d65 1
a65 1
	return BT_SUCCESS;
d258 5
d269 9
a277 10
	switch (btree_txn_get(ns->data_db, ns->data_txn, &key, &val)) {
	case BT_FAIL:
		log_warn("%s", dn);
		return NULL;
	case BT_DEAD:
		log_warn("%s", dn);
		namespace_reopen_data(ns);
		return NULL;
	case BT_NOTFOUND:
		log_debug("%s: dn not found", dn);
d343 1
a343 1
		if (rc == BT_EXISTS)
d352 1
a352 1
	if (update && unindex_entry(ns, &key, root) != BT_SUCCESS)
@


1.6
log
@Make modify and simple auth requests open their own transactions, as search
already does. Trigger a reopen imsg request if either the data or index
databases are compacted. Queue the failed request and try again when the
file is reopened.

Compaction can now be done by a separate process, and ldapd will pick up
the change and reopen the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.5 2010/06/15 15:12:54 martinh Exp $ */
a40 21
struct namespace *
namespace_new(const char *suffix)
{
	struct namespace		*ns;

	if ((ns = calloc(1, sizeof(*ns))) == NULL)
		return NULL;
	ns->suffix = strdup(suffix);
	ns->sync = 1;
	if (ns->suffix == NULL) {
		free(ns->suffix);
		free(ns);
		return NULL;
	}
	TAILQ_INIT(&ns->indices);
	TAILQ_INIT(&ns->request_queue);
	SIMPLEQ_INIT(&ns->acl);

	return ns;
}

d309 1
a309 49
	int			 rc;
	ssize_t			 len;
	uLongf			 destlen;
	Bytef			*dest;
	void			*buf;
	struct ber		 ber;

	bzero(val, sizeof(*val));

	bzero(&ber, sizeof(ber));
	ber.fd = -1;
	ber_write_elements(&ber, root);

	if ((len = ber_get_writebuf(&ber, &buf)) == -1)
		return -1;

	if (ns->compression_level > 0) {
		val->size = compressBound(len);
		val->data = malloc(val->size + sizeof(uint32_t));
		if (val->data == NULL) {
			log_warn("malloc(%u)", val->size + sizeof(uint32_t));
			ber_free(&ber);
			return -1;
		}
		dest = (char *)val->data + sizeof(uint32_t);
		destlen = val->size - sizeof(uint32_t);
		if ((rc = compress2(dest, &destlen, buf, len,
		    ns->compression_level)) != Z_OK) {
			log_warn("compress returned %i", rc);
			free(val->data);
			ber_free(&ber);
			return -1;
		}
		log_debug("compressed entry from %u -> %u byte",
		    len, destlen + sizeof(uint32_t));

		*(uint32_t *)val->data = len;
		val->size = destlen + sizeof(uint32_t);
		val->free_data = 1;
	} else {
		val->data = buf;
		val->size = len;
		val->free_data = 1;	/* XXX: take over internal br_wbuf */
		ber.br_wbuf = NULL;
	}

	ber_free(&ber);

	return 0;
d315 1
a315 44
	int			 rc;
	uLongf			 len;
	void			*buf;
	Bytef			*src;
	uLong			 srclen;
	struct ber_element	*elm;
	struct ber		 ber;

	assert(ns != NULL);
	assert(val != NULL);

	bzero(&ber, sizeof(ber));
	ber.fd = -1;

	if (ns->compression_level > 0) {
		if (val->size < sizeof(uint32_t))
			return NULL;

		len = *(uint32_t *)val->data;
		if ((buf = malloc(len)) == NULL) {
			log_warn("malloc(%u)", len);
			return NULL;
		}

		src = (char *)val->data + sizeof(uint32_t);
		srclen = val->size - sizeof(uint32_t);
		rc = uncompress(buf, &len, src, srclen);
		if (rc != Z_OK) {
			log_warnx("dbt_to_ber: uncompress returned %i", rc);
			free(buf);
			return NULL;
		}

		log_debug("uncompressed entry from %u -> %u byte",
		    val->size, len);

		ber_set_readbuf(&ber, buf, len);
		elm = ber_read_elements(&ber, NULL);
		free(buf);
		return elm;
	} else {
		ber_set_readbuf(&ber, val->data, val->size);
		return ber_read_elements(&ber, NULL);
	}
@


1.5
log
@Implement support in the parent to (re-)open database files on behalf of
the unprivileged child over imsg. Part of a larger change that will fix
database compaction.
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.4 2010/06/11 08:45:06 martinh Exp $ */
d23 1
d63 2
a64 1
namespace_begin(struct namespace *ns)
d66 4
a69 2
	if (ns->data_txn != NULL)
		return -1;
d71 13
a83 5
	if ((ns->data_txn = btree_txn_begin(ns->data_db, 0)) == NULL ||
	    (ns->indx_txn = btree_txn_begin(ns->indx_db, 0)) == NULL) {
		btree_txn_abort(ns->data_txn);
		ns->data_txn = NULL;
		return -1;
d86 7
a92 1
	return 0;
d162 2
a163 2
int
namespace_reopen_data(struct namespace *ns)
d165 3
a167 1
	uint32_t	 old_flags;
d169 3
a171 5
	log_info("reopening namespace %s (entries)", ns->suffix);
	old_flags = btree_get_flags(ns->data_db);
	btree_close(ns->data_db);
	ns->data_db = btree_open(ns->data_path, old_flags, 0644);
	if (ns->data_db == NULL)
d173 1
d175 13
a187 1
	return 0;
d193 6
a198 10
	uint32_t	 old_flags;

	log_info("reopening namespace %s (index)", ns->suffix);
	old_flags = btree_get_flags(ns->indx_db);
	btree_close(ns->indx_db);
	ns->indx_db = btree_open(ns->indx_path, old_flags, 0644);
	if (ns->indx_db == NULL)
		return -1;

	return 0;
d285 1
a285 1
	switch (btree_get(ns->data_db, &key, &val)) {
d289 4
d438 2
a439 2
	assert(ns->data_txn == NULL);
	assert(ns->indx_txn == NULL);
a447 3
	if (namespace_begin(ns) != 0)
		return BT_FAIL;

d455 1
a455 1
		goto fail;
d461 1
a461 1
		goto fail;
d463 1
a463 5
	if (index_entry(ns, &key, root) != 0)
		goto fail;

	if (namespace_commit(ns) != BT_SUCCESS)
		goto fail;
d465 1
a466 6
	return 0;

fail:
	namespace_abort(ns);
	btval_reset(&val);

d490 2
a491 2
	assert(ns->indx_txn == NULL);
	assert(ns->data_txn == NULL);
a498 3
	if (namespace_begin(ns) != 0)
		return BT_FAIL;

d500 2
a501 6
	if (rc != BT_SUCCESS)
		goto fail;

	if ((root = namespace_db2ber(ns, &data)) == NULL ||
	    (rc = unindex_entry(ns, &key, root)) != 0)
		goto fail;
a502 12
	if (btree_txn_commit(ns->data_txn) != BT_SUCCESS)
		goto fail;
	ns->data_txn = NULL;
	if (btree_txn_commit(ns->indx_txn) != BT_SUCCESS)
		goto fail;
	ns->indx_txn = NULL;

	btval_reset(&data);
	return 0;

fail:
	namespace_abort(ns);
a503 1

d542 1
a542 1
/* Queues modification requests while the namespace is being compacted.
d563 5
d572 1
a575 3

	if (!ns->compacting)
		namespace_queue_schedule(ns);
d583 4
a586 11
	tv.tv_sec = 0;
	tv.tv_usec = 0;
	evtimer_add(&ns->ev_queue, &tv);
}

int
namespace_should_queue(struct namespace *ns, struct request *req)
{
	if (ns->compacting) {
		log_debug("namespace %s is being compacted", ns->suffix);
		return 1;
a587 7

	if (ns->queued_requests > 0 && !req->replayed) {
		log_debug("namespace %s is being replayed", ns->suffix);
		return 1;
	}

	return 0;
@


1.4
log
@Track changes in btree_txn_* API, pass a NULL btree when also passing a
transaction.
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.3 2010/06/03 17:29:54 martinh Exp $ */
d37 2
d172 26
@


1.3
log
@Open database files before chrooting, and use an absolute path to
the database files, instead of relying on the chrooted-to path.

This breaks compaction as the ldape process can't re-open the
database files. This is being worked on.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.2 2010/06/01 15:10:04 martinh Exp $ */
d392 1
a392 1
	rc = btree_txn_put(ns->data_db, ns->data_txn, &key, &val,
d455 1
a455 1
	rc = btree_txn_del(ns->data_db, ns->data_txn, &key, &data);
@


1.2
log
@namespace_new() leaks `ns' on error path.
from zinovik@@
@
text
@d1 1
a1 1
/*	$OpenBSD: namespace.c,v 1.1 2010/05/31 17:36:31 martinh Exp $ */
d119 1
a119 1
	if (asprintf(&ns->data_path, "%s_data.db", ns->suffix) < 0)
d128 1
a128 1
	if (asprintf(&ns->indx_path, "%s_indx.db", ns->suffix) < 0)
@


1.1
log
@Initial import of ldapd, a small LDAP daemon. Work in progress.

ok deraadt@@ jacekm@@ gilles@@ back@@ henning@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d49 1
@

