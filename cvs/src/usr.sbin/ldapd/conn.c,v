head	1.14;
access;
symbols
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.10
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.14
date	2017.01.20.11.55.08;	author benno;	state Exp;
branches;
next	1.13;
commitid	amLxRcKegr7GUlIs;

1.13
date	2016.05.01.00.32.37;	author jmatthew;	state Exp;
branches;
next	1.12;
commitid	uX93IkNwEDxO7hQ6;

1.12
date	2015.11.02.06.32.51;	author jmatthew;	state Exp;
branches;
next	1.11;
commitid	Gxv6LrGmzNUGQSrd;

1.11
date	2013.11.02.13.31.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.16.00.08.32;	author jmatthew;	state Exp;
branches;
next	1.9;

1.9
date	2012.04.11.08.31.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.11.10.08.00.54;	author martinh;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.05.07.49.03;	author martinh;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.19.09.10.12;	author martinh;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.01.20.09.34;	author martinh;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.29.21.00.34;	author martinh;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.27.18.31.13;	author martinh;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.31.18.29.04;	author martinh;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.31.17.36.31;	author martinh;	state Exp;
branches;
next	;


desc
@@


1.14
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok krw@@ jmatthew@@
@
text
@/*	$OpenBSD: conn.c,v 1.13 2016/05/01 00:32:37 jmatthew Exp $ */

/*
 * Copyright (c) 2009, 2010 Martin Hedenfalk <martin@@bzero.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/types.h>

#include <stdlib.h>
#include <errno.h>
#include <unistd.h>

#include "ldapd.h"
#include "log.h"

int			 conn_dispatch(struct conn *conn);
int			 conn_tls_init(struct conn *);
unsigned long		 ldap_application(struct ber_element *elm);

struct conn_list	 conn_list;

unsigned long
ldap_application(struct ber_element *elm)
{
	return BER_TYPE_OCTETSTRING;
}

void
request_free(struct request *req)
{
	if (req->root != NULL)
		ber_free_elements(req->root);
	free(req);
}

void
conn_close(struct conn *conn)
{
	struct search	*search, *next;
	struct listener *l = conn->listener;

	log_debug("closing connection %d", conn->fd);

	/* Cancel any ongoing searches on this connection. */
	for (search = TAILQ_FIRST(&conn->searches); search; search = next) {
		next = TAILQ_NEXT(search, next);
		search_close(search);
	}

	/* Cancel any queued requests on this connection. */
	namespace_cancel_conn(conn);

	tls_free(conn->tls);

	TAILQ_REMOVE(&conn_list, conn, next);
	ber_free(&conn->ber);
	if (conn->bev != NULL)
		bufferevent_free(conn->bev);
	close(conn->fd);

	/* Some file descriptors are available again. */
	if (evtimer_pending(&l->evt, NULL)) {
		evtimer_del(&l->evt);
		event_add(&l->ev, NULL);
	}

	free(conn->binddn);
	free(conn->pending_binddn);
	free(conn);

	--stats.conns;
}

/* Marks a connection for disconnect. The connection will be closed when
 * any remaining data has been flushed to the socket.
 */
void
conn_disconnect(struct conn *conn)
{
	conn->disconnect = 1;
	bufferevent_enable(conn->bev, EV_WRITE);
}

void
request_dispatch(struct request *req)
{
	unsigned long		 i;
	struct {
		unsigned long	 type;
		int (*fn)(struct request *);
	} requests[] = {
		{ LDAP_REQ_SEARCH,	ldap_search },
		{ LDAP_REQ_BIND,	ldap_bind },
		{ LDAP_REQ_COMPARE,	ldap_compare },
		{ LDAP_REQ_ADD,		ldap_add },
		{ LDAP_REQ_UNBIND_30,	ldap_unbind },
		{ LDAP_REQ_MODIFY,	ldap_modify },
		{ LDAP_REQ_ABANDON_30,	ldap_abandon },
		{ LDAP_REQ_DELETE_30,	ldap_delete },
		{ LDAP_REQ_EXTENDED,	ldap_extended },
		{ 0,			NULL }
	};

	/* RFC4511, section 4.2.1 says we shouldn't process other requests
	 * while binding. A bind operation can, however, be aborted by sending
	 * another bind operation.
	 */
	if (req->conn->bind_req != NULL && req->type != LDAP_REQ_BIND) {
		log_warnx("got request while bind in progress");
		ldap_respond(req, LDAP_SASL_BIND_IN_PROGRESS);
		return;
	}

	for (i = 0; requests[i].fn != NULL; i++) {
		if (requests[i].type == req->type) {
			requests[i].fn(req);
			break;
		}
	}

	if (requests[i].fn == NULL) {
		log_warnx("unhandled request %d (not implemented)", req->type);
		ldap_respond(req, LDAP_PROTOCOL_ERROR);
	}
}

int
conn_dispatch(struct conn *conn)
{
	int			 class;
	struct request		*req;
	u_char			*rptr;

	++stats.requests;

	if ((req = calloc(1, sizeof(*req))) == NULL) {
		log_warn("calloc");
		conn_disconnect(conn);
		return -1;
	}

	req->conn = conn;
	rptr = conn->ber.br_rptr;	/* save where we start reading */

	if ((req->root = ber_read_elements(&conn->ber, NULL)) == NULL) {
		if (errno != ECANCELED) {
			log_warnx("protocol error");
			hexdump(rptr, conn->ber.br_rend - rptr,
			    "failed to parse request from %zi bytes:",
			    conn->ber.br_rend - rptr);
			conn_disconnect(conn);
		}
		request_free(req);
		return -1;
	}
	log_debug("consumed %d bytes", conn->ber.br_rptr - rptr);

	/* Read message id and request type.
	 */
	if (ber_scanf_elements(req->root, "{ite",
	    &req->msgid, &class, &req->type, &req->op) != 0) {
		log_warnx("protocol error");
		ldap_debug_elements(req->root, -1,
		    "received invalid request on fd %d", conn->fd);
		conn_disconnect(conn);
		request_free(req);
		return -1;
	}

	ldap_debug_elements(req->root, req->type,
	    "received request on fd %d", conn->fd);

	log_debug("got request type %d, id %lld", req->type, req->msgid);
	request_dispatch(req);
	return 0;
}

void
conn_read(struct bufferevent *bev, void *data)
{
	size_t			 nused = 0;
	struct conn		*conn = data;
	struct evbuffer		*input;

	input = EVBUFFER_INPUT(bev);
	ber_set_readbuf(&conn->ber,
	    EVBUFFER_DATA(input), EVBUFFER_LENGTH(input));

	while (conn->ber.br_rend - conn->ber.br_rptr > 0) {
		if (conn_dispatch(conn) == 0)
			nused = conn->ber.br_rptr - conn->ber.br_rbuf;
		else
			break;
	}

	evbuffer_drain(input, nused);
}

void
conn_write(struct bufferevent *bev, void *data)
{
	struct search	*search, *next;
	struct conn	*conn = data;

	/* Continue any ongoing searches.
	 * Note that the search may be unlinked and freed by conn_search.
	 */
	for (search = TAILQ_FIRST(&conn->searches); search; search = next) {
		next = TAILQ_NEXT(search, next);
		conn_search(search);
	}

	if (conn->disconnect)
		conn_close(conn);
	else if (conn->s_flags & F_STARTTLS) {
		conn->s_flags &= ~F_STARTTLS;
		if (conn_tls_init(conn) == -1)
			conn_close(conn);
	}
}

void
conn_err(struct bufferevent *bev, short why, void *data)
{
	struct conn	*conn = data;

	if ((why & EVBUFFER_EOF) == EVBUFFER_EOF)
		log_debug("end-of-file on connection %d", conn->fd);
	else if ((why & EVBUFFER_TIMEOUT) == EVBUFFER_TIMEOUT)
		log_debug("timeout on connection %d", conn->fd);
	else
		log_warnx("error 0x%02X on connection %d", why, conn->fd);

	conn_close(conn);
}

void
conn_accept(int fd, short event, void *data)
{
	int			 afd;
	socklen_t		 addrlen;
	struct conn		*conn;
	struct listener		*l = data;
	struct sockaddr_storage	 remote_addr;
	char			 host[128];

	event_add(&l->ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	addrlen = sizeof(remote_addr);
	afd = accept_reserve(fd, (struct sockaddr *)&remote_addr, &addrlen,
	    FD_RESERVE);
	if (afd == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&l->ev);
			evtimer_add(&l->evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR)
			log_warn("conn_accept");
		return;
	}

	if (l->ss.ss_family == AF_UNIX) {
		uid_t		 euid;
		gid_t		 egid;

		if (getpeereid(afd, &euid, &egid) == -1)
			log_warnx("conn_accept: getpeereid");
		else
			log_debug("accepted local connection by uid %d", euid);
	} else {
		print_host(&remote_addr, host, sizeof(host));
		log_debug("accepted connection from %s on fd %d", host, afd);
	}

	if ((conn = calloc(1, sizeof(*conn))) == NULL) {
		log_warn("malloc");
		goto giveup;
	}
	conn->ber.fd = -1;
	ber_set_application(&conn->ber, ldap_application);
	conn->fd = afd;
	conn->listener = l;

	conn->bev = bufferevent_new(afd, conn_read, conn_write,
	    conn_err, conn);
	if (conn->bev == NULL) {
		log_warn("conn_accept: bufferevent_new");
		free(conn);
		goto giveup;
	}
	bufferevent_enable(conn->bev, EV_READ);
	bufferevent_settimeout(conn->bev, 0, 60);
	if (l->flags & F_LDAPS)
		if (conn_tls_init(conn) == -1)
			conn_close(conn);

	TAILQ_INIT(&conn->searches);
	TAILQ_INSERT_HEAD(&conn_list, conn, next);

	if (l->flags & F_SECURE)
		conn->s_flags |= F_SECURE;

	++stats.conns;
	return;
giveup:
	close(afd);
	/* Some file descriptors are available again. */
	if (evtimer_pending(&l->evt, NULL)) {
		evtimer_del(&l->evt);
		event_add(&l->ev, NULL);
	}
}

struct conn *
conn_by_fd(int fd)
{
	struct conn		*conn;

	TAILQ_FOREACH(conn, &conn_list, next) {
		if (conn->fd == fd)
			return conn;
	}
	return NULL;
}

int
conn_close_any()
{
	struct conn		*conn;

	/* Close oldest idle connection */
	TAILQ_FOREACH_REVERSE(conn, &conn_list, conn_list, next) {
		if (namespace_conn_queue_count(conn) == 0) {
			conn_close(conn);
			return 0;
		}
	}

	/* Close oldest connection */
	conn = TAILQ_LAST(&conn_list, conn_list);
	if (conn != NULL) {
		conn_close(conn);
		return 0;
	}

	return -1;
}

int
conn_tls_init(struct conn *conn)
{
	struct listener *l = conn->listener;

	if (!(l->flags & F_SSL))
		return 0;

	log_debug("conn_tls_init: switching to TLS");

	if (tls_accept_socket(l->tls, &conn->tls, conn->fd) < 0) {
		log_debug("tls_accept_socket failed");
		return -1;
	}
	
	conn->s_flags |= F_SECURE;
	buffertls_set(&conn->buftls, conn->bev, conn->tls, conn->fd);
	buffertls_accept(&conn->buftls, conn->fd);
	return 0;
}
@


1.13
log
@convert ldapd to use the libtls api, bringing in a copy of the evbuffer_tls
code from syslogd.

ok beck@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.12 2015/11/02 06:32:51 jmatthew Exp $ */
d27 1
@


1.12
log
@use SOCK_NONBLOCK instead of fcntl

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.11 2013/11/02 13:31:51 deraadt Exp $ */
d29 1
d65 1
a65 1
	ssl_session_destroy(conn);
d229 2
a230 3
		bufferevent_free(conn->bev);
		conn->bev = NULL;
		ssl_session_init(conn);
a298 1
	conn->s_l = l;
d303 6
a308 12
	if (l->flags & F_LDAPS) {
		ssl_session_init(conn);
	} else {
		conn->bev = bufferevent_new(afd, conn_read, conn_write,
		    conn_err, conn);
		if (conn->bev == NULL) {
			log_warn("conn_accept: bufferevent_new");
			free(conn);
			goto giveup;
		}
		bufferevent_enable(conn->bev, EV_READ);
		bufferevent_settimeout(conn->bev, 0, 60);
d310 5
d366 21
@


1.11
log
@bunch of format string cleanups, removing %i, signed vs unsigned, and even
a few long long's
ok jmatthew
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.10 2012/06/16 00:08:32 jmatthew Exp $ */
a292 2

	fd_nonblock(afd);
@


1.10
log
@Protect against fd exhaustion when reopening database files.  Only accept
client or control connections when there are at least 8 fds available,
and close a connection before calling imsg_read if it would be unable to
accept an fd from the parent process.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.9 2012/04/11 08:31:37 deraadt Exp $ */
d240 1
a240 1
		log_debug("end-of-file on connection %i", conn->fd);
d242 1
a242 1
		log_debug("timeout on connection %i", conn->fd);
d244 1
a244 1
		log_warnx("error 0x%02X on connection %i", why, conn->fd);
@


1.9
log
@rate limiting of accept() in various cases.  Testing by jmatthew.  there
maybe still be a corner case where it needs one more file descriptor
beyond the limit..
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.8 2010/11/10 08:00:54 martinh Exp $ */
d264 2
a265 1
	afd = accept(fd, (struct sockaddr *)&remote_addr, &addrlen);
d349 22
@


1.8
log
@Make -dvv flags produce debug traces of decoded BER messages on stderr.
Also shows a hexdump of the input buffer if BER decoding fails.
Useful when debugging protocol issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.7 2010/11/05 07:49:03 martinh Exp $ */
d51 1
d71 7
d250 1
a250 1
conn_accept(int fd, short why, void *data)
d259 4
d266 11
a276 1
		log_warn("accept");
d297 1
a297 2
		close(afd);
		return;
a311 1
			close(afd);
d313 1
a313 1
			return;
d326 8
@


1.7
log
@When draining the input buffer of more than two complete requests, an
additional incomplete request would be truncated. This fixes the number of
bytes consumed from the input buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.6 2010/10/19 09:10:12 martinh Exp $ */
d135 1
d146 1
d151 3
d159 1
d166 2
d172 3
@


1.6
log
@Remember the bind DN after BSD authentication. This makes access control
work for SASL and BSDAUTH binds as it does for simple binds.
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.5 2010/07/01 20:09:34 martinh Exp $ */
d183 1
a183 1
			nused += conn->ber.br_rptr - conn->ber.br_rbuf;
@


1.5
log
@Implement the LDAP compare operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.4 2010/06/29 21:00:34 martinh Exp $ */
d71 1
@


1.4
log
@Remember on what listener a connection got from, and return protocol error
if trying to use starttls without a configured certificate, instead of just
blocking the client.
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.3 2010/06/27 18:31:13 martinh Exp $ */
d96 1
@


1.3
log
@return value unused, found by lint
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.2 2010/05/31 18:29:04 martinh Exp $ */
d269 1
@


1.2
log
@Remove trailing whitespace and spaces before tabs.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conn.c,v 1.1 2010/05/31 17:36:31 martinh Exp $ */
d86 1
a86 1
int
d112 1
a112 1
		return 0;
a125 2

	return 0;
@


1.1
log
@Initial import of ldapd, a small LDAP daemon. Work in progress.

ok deraadt@@ jacekm@@ gilles@@ back@@ henning@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d240 1
a240 1
 	addrlen = sizeof(remote_addr);
@

