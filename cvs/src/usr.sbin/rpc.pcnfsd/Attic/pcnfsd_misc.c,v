head	1.10;
access;
symbols
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.14
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2003.07.07.21.37.07;	author deraadt;	state dead;
branches;
next	1.9;

1.9
date	2003.04.04.22.37.47;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.16.01.53.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.15.12.15.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.15.11.53.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.26.09.25.22;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.19.19.16.12;	author ericj;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches;
next	1.2;

1.2
date	98.01.03.21.57.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.06;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@bye bye piece of crud
@
text
@/*	$OpenBSD: pcnfsd_misc.c,v 1.9 2003/04/04 22:37:47 avsm Exp $	*/
/*	$NetBSD: pcnfsd_misc.c,v 1.2 1995/07/25 22:20:42 gwr Exp $	*/

/*
 *=====================================================================
 * Copyright (c) 1986,1987,1988,1989,1990,1991 by Sun Microsystems, Inc.
 *	@@(#)pcnfsd_misc.c	1.5	1/24/92
 *
 * pcnfsd is copyrighted software, but is freely licensed. This
 * means that you are free to redistribute it, modify it, ship it
 * in binary with your system, whatever, provided:
 *
 * - you leave the Sun copyright notice in the source code
 * - you make clear what changes you have introduced and do
 *   not represent them as being supported by Sun.
 *
 * If you make changes to this software, we ask that you do so in
 * a way which allows you to build either the "standard" version or
 * your custom version from a single source file. Test it, lint
 * it (it won't lint 100%, very little does, and there are bugs in
 * some versions of lint :-), and send it back to Sun via email
 * so that we can roll it into the source base and redistribute
 * it. We'll try to make sure your contributions are acknowledged
 * in the source, but after all these years it's getting hard to
 * remember who did what.
 *=====================================================================
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <pwd.h>
#include <sys/file.h>
#include <signal.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <netdb.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <utmp.h>

#include "pcnfsd.h"

#define	zchar		0x5b

char            tempstr[256];
extern char	sp_name[1024]; /* in pcnfsd_print.c */

void
scramble(s1, s2)
	char *s1, *s2;
{
	while (*s1) {
		*s2++ = (*s1 ^ zchar) & 0x7f;
		s1++;
	}
	*s2 = 0;
}

struct passwd *
get_password(user)
	char *user;
{
	struct passwd *pwd;
	static struct passwd lpwd;
	char *pass, *ushell;
	int ok = 0;

	if ((pwd = getpwnam(user)) == NULL)
		return (NULL);

	pass = pwd->pw_passwd;

	lpwd = *pwd;
	lpwd.pw_passwd = pass;

	/*
	 * ensure that the shell ends in "sh" - probobly not worth it.
	 */
	ushell = lpwd.pw_shell;
	if (strlen(ushell) < 2)
		return ((struct passwd *)NULL);
	ushell += strlen(ushell) - 2;
	if (strcmp(ushell, "sh"))
		return ((struct passwd *)NULL);

	return (&lpwd);
}

/*
 *---------------------------------------------------------------------
 *                      Print support procedures 
 *---------------------------------------------------------------------
 */

char           *
mapfont(f, i, b)
	char f, i, b;
{
	static char fontname[64];

	fontname[0] = 0;	/* clear it out */

	switch (f) {
	case 'c':
		(void)strlcpy(fontname, "Courier", sizeof fontname);
		break;
	case 'h':
		(void)strlcpy(fontname, "Helvetica", sizeof fontname);
		break;
	case 't':
		(void)strlcpy(fontname, "Times", sizeof fontname);
		break;
	default:
		(void)strlcpy(fontname, "Times-Roman", sizeof fontname);
		goto finis ;
	}
	if (i != 'o' && b != 'b') {	/* no bold or oblique */
		if (f == 't')	/* special case Times */
			(void)strlcat(fontname, "-Roman", sizeof fontname);
		goto finis;
	}
	(void)strlcat(fontname, "-", sizeof fontname);
	if (b == 'b')
		(void)strlcat(fontname, "Bold", sizeof fontname);
	if (i == 'o')		/* o-blique */
		(void)strlcat(fontname, f == 't' ? "Italic" : "Oblique",
		    sizeof fontname);

finis:
	return (&fontname[0]);
}

void
wlogin(name, req)
	char *name;
	struct svc_req *req;
{
	struct sockaddr_in *who;
	struct hostent *hp;
	char *host;
	struct utmp ut;
	int fd;

	/* Get network address of client. */
	who = &req->rq_xprt->xp_raddr;

	/* Get name of connected client */
	hp = gethostbyaddr((char *)&who->sin_addr, sizeof(struct in_addr),
			   who->sin_family);

	if (hp && (strlen(hp->h_name) <= sizeof(ut.ut_host))) {
		host = hp->h_name;
	} else {
		host = inet_ntoa(who->sin_addr);
	}

	(void)strncpy(ut.ut_line, "PC-NFS", UT_LINESIZE);
	(void)strncpy(ut.ut_name, name, sizeof(ut.ut_name));
	(void)strncpy(ut.ut_host, host, sizeof(ut.ut_host));
	(void)time(&ut.ut_time);

	if ((fd = open(_PATH_WTMP, O_WRONLY|O_APPEND, 0)) >= 0) {
		(void)write(fd, (char *)&ut, sizeof(struct utmp));
		(void)close(fd);
	}
}

/*
 *---------------------------------------------------------------------
 *                      Run-process-as-user procedures 
 *---------------------------------------------------------------------
 */


#define	READER_FD	0
#define	WRITER_FD	1

static pid_t    child_pid;

static char     cached_user[64] = "";
static uid_t    cached_uid;
static gid_t    cached_gid;

static	struct sigaction old_action;
static	struct sigaction new_action;
static	struct itimerval timer;

int interrupted = 0;
static	FILE *pipe_handle;

static void
myhandler()
{
	interrupted = 1;
	(void)fclose(pipe_handle);
	kill(child_pid, SIGKILL);
}

void
start_watchdog(n)
	int n;
{
	/*
	 * Setup SIGALRM handler, force interrupt of ongoing syscall
	 */

	new_action.sa_handler = myhandler;
	sigemptyset(&(new_action.sa_mask));
	new_action.sa_flags = 0;
#ifdef SA_INTERRUPT
	new_action.sa_flags |= SA_INTERRUPT;
#endif
	sigaction(SIGALRM, &new_action, &old_action);

	/*
	 * Set interval timer for n seconds
	 */
	timer.it_interval.tv_sec = 0;
	timer.it_interval.tv_usec = 0;
	timer.it_value.tv_sec = n;
	timer.it_value.tv_usec = 0;
	setitimer(ITIMER_REAL, &timer, NULL);
	interrupted = 0;
}

void stop_watchdog()
{
	/*
	 * Cancel timer
	 */

	timer.it_interval.tv_sec = 0;
	timer.it_interval.tv_usec = 0;
	timer.it_value.tv_sec = 0;
	timer.it_value.tv_usec = 0;
	setitimer(ITIMER_REAL, &timer, NULL);

	/*
 	 * restore old signal handling
	 */
	sigaction(SIGALRM, &old_action, NULL);
}



FILE *
su_popen(user, cmd, maxtime)
	char           *user;
	char           *cmd;
	int		maxtime;
{
	int             p[2];
	int             parent_fd, child_fd;
	pid_t		pid;
	struct passwd *pw;

	if (strcmp(cached_user, user)) {
		pw = getpwnam(user);
		if (!pw)
			pw = getpwnam("nobody");
		if (pw) {
			cached_uid = pw->pw_uid;
			cached_gid = pw->pw_gid;
			strlcpy(cached_user, user, sizeof(cached_user));
		} else {
			cached_uid = (uid_t) (-2);
			cached_gid = (gid_t) (-2);
			cached_user[0] = '\0';
		}
	}
	if (pipe(p) < 0) {
		msg_out("rpc.pcnfsd: unable to create pipe in su_popen");
		return (NULL);
	}
	parent_fd = p[READER_FD];
	child_fd = p[WRITER_FD];
	if ((pid = fork()) == 0) {
		int             i;

		for (i = 0; i < 10; i++)
			if (i != child_fd)
				(void) close(i);
		if (child_fd != 1) {
			(void) dup2(child_fd, 1);
			(void) close(child_fd);
		}
		dup2(1, 2);	/* let's get stderr as well */

		(void) setgid(cached_gid);
		(void) setuid(cached_uid);

		(void) execl("/bin/sh", "sh", "-c", cmd, (char *) NULL);
		_exit(255);
	}
	if (pid == -1) {
		msg_out("rpc.pcnfsd: fork failed");
		close(parent_fd);
		close(child_fd);
		return (NULL);
	}
	child_pid = pid;
	close(child_fd);
	start_watchdog(maxtime);
	pipe_handle = fdopen(parent_fd, "r");
	return (pipe_handle);
}

int
su_pclose(ptr)
	FILE           *ptr;
{
	int             status;
	pid_t		pid;

	stop_watchdog();

	fclose(ptr);
	if (child_pid == -1)
		return (-1);
	while ((pid = wait(&status)) != child_pid && pid != -1)
		;
	return (pid == -1 ? -1 : status);
}

/*
 * strembedded - returns true if s1 is embedded (in any case) in s2
 */
int
strembedded(s1, s2)
	char *s1, *s2;
{
	while (*s2) {
		if (!strcasecmp(s1, s2))
			return (1);
		s2++;
	}
	return (0);
}
@


1.9
log
@strcpy->strlcpy, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcnfsd_misc.c,v 1.8 2003/02/16 01:53:28 deraadt Exp $	*/
@


1.8
log
@strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: pcnfsd_misc.c,v 1.7 2003/02/15 12:15:04 deraadt Exp $	*/
d163 1
a163 1
	(void)strcpy(ut.ut_line, "PC-NFS");
d270 1
a270 1
			strcpy(cached_user, user);
@


1.7
log
@oops; i forgot to delete the block he said i could delete
@
text
@d1 1
a1 1
/*	$OpenBSD: pcnfsd_misc.c,v 1.6 2003/02/15 11:53:45 deraadt Exp $	*/
d111 1
a111 1
		(void)strcpy(fontname, "Courier");
d114 1
a114 1
		(void)strcpy(fontname, "Helvetica");
d117 1
a117 1
		(void)strcpy(fontname, "Times");
d120 1
a120 1
		(void)strcpy(fontname, "Times-Roman");
d125 1
a125 1
			(void)strcat(fontname, "-Roman");
d128 1
a128 1
	(void)strcat(fontname, "-");
d130 1
a130 1
		(void)strcat(fontname, "Bold");
d132 2
a133 1
		(void)strcat(fontname, f == 't' ? "Italic" : "Oblique");
@


1.6
log
@copyright blob from geoff.arnold@@sun.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pcnfsd_misc.c,v 1.5 2002/05/26 09:25:22 deraadt Exp $	*/
a15 2
 * - you do not charge money for the source code (unlikely, given
 *   its free availability)
@


1.5
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pcnfsd_misc.c,v 1.4 2001/08/19 19:16:12 ericj Exp $	*/
a3 1
/* RE_SID: @@(%)/usr/dosnfs/shades_SCCS/unix/pcnfsd/v2/src/SCCS/s.pcnfsd_misc.c 1.5 92/01/24 19:59:13 SMI */
d8 20
@


1.4
log
@
first pass at some cleanup here
- use standard functions,, dont roll our own (strdup, strcasecmp, etc)
- style(9)
- share common headers.. more readable.
doesnt address some of the other problems (cacheing), yet
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d166 1
a166 1
static int      child_pid;
d241 2
a242 1
	int             parent_fd, child_fd, pid;
d300 2
a301 1
	int             pid, status;
d308 2
a309 1
	while ((pid = wait(&status)) != child_pid && pid != -1);
@


1.3
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
d6 10
a15 16
**=====================================================================
** Copyright (c) 1986,1987,1988,1989,1990,1991 by Sun Microsystems, Inc.
**	@@(#)pcnfsd_misc.c	1.5	1/24/92
**=====================================================================
*/
#include "common.h"
/*
**=====================================================================
**             I N C L U D E   F I L E   S E C T I O N                *
**                                                                    *
** If your port requires different include files, add a suitable      *
** #define in the customization section, and make the inclusion or    *
** exclusion of the files conditional on this.                        *
**=====================================================================
*/
#include "pcnfsd.h"
d28 1
d30 1
a30 21
#ifdef ISC_2_0
#include <sys/fcntl.h>
#endif

#ifdef SHADOW_SUPPORT
#include <shadow.h>
#endif

#ifdef WTMP
int wtmp_enabled = 1;
#endif

#ifdef USE_GETUSERSHELL
extern char *getusershell();
#endif

/*
**---------------------------------------------------------------------
** Other #define's 
**---------------------------------------------------------------------
*/
a36 11
/*
**=====================================================================
**                      C O D E   S E C T I O N                       *                    **=====================================================================
*/
/*
**---------------------------------------------------------------------
**                          Support procedures 
**---------------------------------------------------------------------
*/


d39 1
a39 2
char           *s1;
char           *s2;
d41 4
a44 5
	while (*s1) 
	      {
	      *s2++ = (*s1 ^ zchar) & 0x7f;
	      s1++;
	      }
d48 8
d57 2
d60 1
a60 9
struct passwd  *
get_password(usrnam)
char           *usrnam;
{
struct passwd  *p;
static struct passwd localp;
char           *pswd;
char           *ushell;
int		ok = 0;
d62 2
a64 6
#ifdef SHADOW_SUPPORT
struct spwd    *sp;
int             shadowfile;
#endif

#ifdef SHADOW_SUPPORT
d66 4
a69 68
        **--------------------------------------------------------------
	** Check the existence of SHADOW.  If it is there, then we are
	** running a two-password-file system.
        **--------------------------------------------------------------
	*/
	if (access(SHADOW, 0))
	   shadowfile = 0;	/* SHADOW is not there */
	else
	   shadowfile = 1;

	setpwent();
	if (shadowfile)
	   (void) setspent();	/* Setting the shadow password
					 * file */
	if ((p = getpwnam(usrnam)) == (struct passwd *)NULL ||
	   (shadowfile && (sp = getspnam(usrnam)) == (struct spwd *)NULL))
	return ((struct passwd *)NULL);

	if (shadowfile) 
           {
	   pswd = sp->sp_pwdp;
	   (void) endspent();
	   } 
        else
	   pswd = p->pw_passwd;

#else
	p = getpwnam(usrnam);
	if (p == (struct passwd *)NULL)
		return ((struct passwd *)NULL);
	pswd = p->pw_passwd;
#endif

#ifdef ISC_2_0
	/* 
        **-----------------------------------------------------------
	** We may have an 'x' in which case look in /etc/shadow ..
        **-----------------------------------------------------------
        */
	if (((strlen(pswd)) == 1) && pswd[0] == 'x') 
	   {
	   struct spwd    *shadow = getspnam(usrnam);

	   if (!shadow)
	      return ((struct passwd *)NULL);
	   pswd = shadow->sp_pwdp;
	   }
#endif
	localp = *p;
	localp.pw_passwd = pswd;
#ifdef USE_GETUSERSHELL

	setusershell();
	while(ushell = getusershell()){
		if(!strcmp(ushell, localp.pw_shell)) {
			ok = 1;
			break;
		}
	}
	endusershell();
	if(!ok)
		return ((struct passwd *)NULL);
#else
/*
 * the best we can do is to ensure that the shell ends in "sh"
 */
	ushell = localp.pw_shell;
	if(strlen(ushell) < 2)
d72 1
a72 1
	if(strcmp(ushell, "sh"))
d75 1
a75 2
#endif
	return (&localp);
a77 1

d79 4
a82 4
**---------------------------------------------------------------------
**                      Print support procedures 
**---------------------------------------------------------------------
*/
d86 1
a86 3
	char            f;
	char            i;
	char            b;
d88 1
a88 1
	static char     fontname[64];
d117 2
a118 1
finis:	return (&fontname[0]);
a120 71
/*
 * run_ps630 performs the Diablo 630 emulation filtering process. ps630
 * was broken in certain Sun releases: it would not accept point size or
 * font changes. If your version is fixed, undefine the symbol
 * PS630_IS_BROKEN and rebuild pc-nfsd.
 */
/* #define PS630_IS_BROKEN 1 */

void
run_ps630(f, opts)
	char           *f;
	char           *opts;
{
	char            temp_file[256];
	char            commbuf[256];
	int             i;

	(void)strcpy(temp_file, f);
	(void)strcat(temp_file, "X");	/* intermediate file name */

#ifndef PS630_IS_BROKEN
	(void)snprintf(commbuf, sizeof commbuf, "ps630 -s %c%c -p %s -f ",
		opts[2], opts[3], temp_file);
	(void)strcat(commbuf, mapfont(opts[4], opts[5], opts[6]));
	(void)strcat(commbuf, " -F ");
	(void)strcat(commbuf, mapfont(opts[7], opts[8], opts[9]));
	(void)strcat(commbuf, "  ");
	(void)strcat(commbuf, f);
#else	/* PS630_IS_BROKEN */
	/*
	 * The pitch and font features of ps630 appear to be broken at
	 * this time.
	 */
	(void)snprintf(commbuf, sizeof commbuf, "ps630 -p %s %s", temp_file, f);
#endif	/* PS630_IS_BROKEN */


	if (i = system(commbuf)) {
		/*
		 * Under (un)certain conditions, ps630 may return -1 even
		 * if it worked. Hence the commenting out of this error
		 * report.
		 */
		 /* (void)fprintf(stderr, "\n\nrun_ps630 rc = %d\n", i) */ ;
		/* exit(1); */
	}
	if (rename(temp_file, f)) {
		perror("run_ps630: rename");
		exit(1);
	}
	return;
}




/*
**---------------------------------------------------------------------
**                      WTMP update support 
**---------------------------------------------------------------------
*/


#ifdef WTMP

#include <utmp.h>

#ifndef	_PATH_WTMP
#define _PATH_WTMP "/usr/adm/wtmp"
#endif

a125 1
	extern char *inet_ntoa();
a131 3
	if(!wtmp_enabled)
		return;

d136 1
a136 2
	hp = gethostbyaddr((char *)&who->sin_addr,
			   sizeof (struct in_addr),
d145 4
a148 4
	(void) strcpy(ut.ut_line, "PC-NFS");
	(void) strncpy(ut.ut_name,name,sizeof ut.ut_name);
	(void) strncpy(ut.ut_host, host, sizeof ut.ut_host);
	ut.ut_time = time( (time_t *) 0);
d155 1
a155 2
#endif /* WTMP */

d157 4
a160 4
**---------------------------------------------------------------------
**                      Run-process-as-user procedures 
**---------------------------------------------------------------------
*/
d179 2
a180 1
static	void myhandler()
d182 3
a184 4
 interrupted = 1;
 fclose(pipe_handle);
 kill(child_pid, SIGKILL);
 msg_out("rpc.pcnfsd: su_popen timeout - killed child process");
d187 3
a189 2
void start_watchdog(n)
int n;
a211 1

d234 1
a234 1
FILE           *
a309 1

d311 4
a314 75
** The following routine reads a file "/etc/pcnfsd.conf" if present,
** and uses it to replace certain builtin elements, like the
** name of the print spool directory. The configuration file
** Is the usual kind: Comments begin with '#', blank lines are ignored,
** and valid lines are of the form
**
**	<keyword><whitespace><value>
**
** The following keywords are recognized:
**
**	spooldir
**	printer name alias-for command
**	wtmp yes|no
*/
void
config_from_file()
{
FILE *fd;
char buff[1024];
char *cp;
char *kw;
char *val;
char *arg1;
char *arg2;

	if((fd = fopen("/etc/pcnfsd.conf", "r")) == NULL)
		return;
	while(fgets(buff, 1024, fd)) {
		cp = strchr(buff, '\n');
		*cp = '\0';
		cp = strchr(buff, '#');
		if(cp)
			*cp = '\0';
		kw = strtok(buff, " \t");
		if(kw == NULL)
			continue;
		val = strtok(NULL, " \t");
		if(val == NULL)
			continue;
		if(!mystrcasecmp(kw, "spooldir")) {
			strcpy(sp_name, val);
			continue;
		}
#ifdef WTMP
		if(!mystrcasecmp(kw, "wtmp")) {
			/* assume default is YES, just look for negatives */
			if(!mystrcasecmp(val, "no") ||
			   !mystrcasecmp(val, "off") ||
			   !mystrcasecmp(val, "disable") ||
			   !strcmp(val, "0"))
				wtmp_enabled = 0;;
			continue;
		}
#endif	
		if(!mystrcasecmp(kw, "printer")) {
			arg1 = strtok(NULL, " \t");
			arg2 = strtok(NULL, "");
			(void)add_printer_alias(val, arg1, arg2);
			continue;
		}
/*
** Add new cases here
*/
	}
	fclose(fd);
}


/*
** The following are replacements for the SunOS library
** routines strcasecmp and strncasecmp, which SVR4 doesn't
** include.
*/

mystrcasecmp(s1, s2)
d317 3
a319 30

	while (toupper(*s1) == toupper(*s2++))
		if (*s1++ == '\0')
			return(0);
	return(toupper(*s1) - toupper(*--s2));
}

mystrncasecmp(s1, s2, n)
	char *s1, *s2;
	int n;
{

	while (--n >= 0 && toupper(*s1) == toupper(*s2++))
		if (*s1++ == '\0')
			return(0);
	return(n < 0 ? 0 : toupper(*s1) - toupper(*--s2));
}


/*
** strembedded - returns true if s1 is embedded (in any case) in s2
*/

int strembedded(s1, s2)
char *s1;
char *s2;
{
	while(*s2) {
		if(!mystrcasecmp(s1, s2))
			return 1;
d322 1
a322 1
	return 0;
@


1.2
log
@more oflows; we should just delete this thing
@
text
@d337 1
a337 1
#endif WTMP
@


1.1
log
@Initial revision
@
text
@d248 1
a248 1
	(void)sprintf(commbuf, "ps630 -s %c%c -p %s -f ",
d260 1
a260 1
	(void)sprintf(commbuf, "ps630 -p %s %s", temp_file, f);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
