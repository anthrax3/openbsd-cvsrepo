head	1.4;
access;
symbols
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.2
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.4.0.2
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	UNBOUND_1_5_4:1.1.1.4
	OPENBSD_5_7:1.1.1.3.0.6
	OPENBSD_5_7_BASE:1.1.1.3
	UNBOUND_1_5_2RC1:1.1.1.3
	UNBOUND_1_5_1:1.1.1.3
	UNBOUND_1_5_0:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	UNBOUND_1_4_22:1.1.1.3
	OPENBSD_5_5:1.1.1.2.0.8
	OPENBSD_5_5_BASE:1.1.1.2
	UNBOUND_1_4_21:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.4
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.2
	OPENBSD_5_3_BASE:1.1.1.2
	UNBOUND_1_4_18:1.1.1.2
	UNBOUND_1_4_17:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.2
	OPENBSD_5_2_BASE:1.1.1.1
	UNBOUND_1_4_16:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2017.08.12.11.22.46;	author sthen;	state Exp;
branches;
next	1.3;
commitid	jku4foGr2J38bu5W;

1.3
date	2017.02.17.18.53.32;	author sthen;	state Exp;
branches;
next	1.2;
commitid	R6rMbeA8TNhmzWB4;

1.2
date	2016.06.22.20.05.41;	author sthen;	state Exp;
branches;
next	1.1;
commitid	EnU0HAX1qep1MppE;

1.1
date	2012.03.26.18.05.43;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.03.26.18.05.43;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.08.23.22.56.29;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.16.11.38.24;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2015.07.16.01.42.20;	author sthen;	state Exp;
branches;
next	;
commitid	kEVXcRu8XDMmCd6c;


desc
@@


1.4
log
@update to unbound 1.6.4, ok florian@@
@
text
@/* 
 * util/data/msgparse.c - parse wireformat DNS messages.
 * 
 * Copyright (c) 2007, NLnet Labs. All rights reserved.
 * 
 * This software is open source.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * Neither the name of the NLNET LABS nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * \file
 * Routines for message parsing a packet buffer to a descriptive structure.
 */
#include "config.h"
#include "util/data/msgparse.h"
#include "util/data/msgreply.h"
#include "util/data/dname.h"
#include "util/data/packed_rrset.h"
#include "util/storage/lookup3.h"
#include "util/regional.h"
#include "sldns/rrdef.h"
#include "sldns/sbuffer.h"
#include "sldns/parseutil.h"
#include "sldns/wire2str.h"

/** smart comparison of (compressed, valid) dnames from packet */
static int
smart_compare(sldns_buffer* pkt, uint8_t* dnow, 
	uint8_t* dprfirst, uint8_t* dprlast)
{
	if(LABEL_IS_PTR(*dnow)) {
		/* ptr points to a previous dname */
		uint8_t* p = sldns_buffer_at(pkt, PTR_OFFSET(dnow[0], dnow[1]));
		if( p == dprfirst || p == dprlast )
			return 0;
		/* prev dname is also a ptr, both ptrs are the same. */
		if(LABEL_IS_PTR(*dprlast) &&
			dprlast[0] == dnow[0] && dprlast[1] == dnow[1])
			return 0;
	}
	return dname_pkt_compare(pkt, dnow, dprlast);
}

/**
 * Allocate new rrset in region, fill with data.
 */
static struct rrset_parse* 
new_rrset(struct msg_parse* msg, uint8_t* dname, size_t dnamelen, 
	uint16_t type, uint16_t dclass, hashvalue_type hash, 
	uint32_t rrset_flags, sldns_pkt_section section, 
	struct regional* region)
{
	struct rrset_parse* p = regional_alloc(region, sizeof(*p));
	if(!p) return NULL;
	p->rrset_bucket_next = msg->hashtable[hash & (PARSE_TABLE_SIZE-1)];
	msg->hashtable[hash & (PARSE_TABLE_SIZE-1)] = p;
	p->rrset_all_next = 0;
	if(msg->rrset_last)
		msg->rrset_last->rrset_all_next = p;
	else 	msg->rrset_first = p;
	msg->rrset_last = p;
	p->hash = hash;
	p->section = section;
	p->dname = dname;
	p->dname_len = dnamelen;
	p->type = type;
	p->rrset_class = dclass;
	p->flags = rrset_flags;
	p->rr_count = 0;
	p->size = 0;
	p->rr_first = 0;
	p->rr_last = 0;
	p->rrsig_count = 0;
	p->rrsig_first = 0;
	p->rrsig_last = 0;
	return p;
}

/** See if next rrset is nsec at zone apex */
static int
nsec_at_apex(sldns_buffer* pkt)
{
	/* we are at ttl position in packet. */
	size_t pos = sldns_buffer_position(pkt);
	uint16_t rdatalen;
	if(sldns_buffer_remaining(pkt) < 7) /* ttl+len+root */
		return 0; /* eek! */
	sldns_buffer_skip(pkt, 4); /* ttl */;
	rdatalen = sldns_buffer_read_u16(pkt);
	if(sldns_buffer_remaining(pkt) < rdatalen) {
		sldns_buffer_set_position(pkt, pos);
		return 0; /* parse error happens later */
	}
	/* must validate the nsec next domain name format */
	if(pkt_dname_len(pkt) == 0) {
		sldns_buffer_set_position(pkt, pos);
		return 0; /* parse error */
	}

	/* see if SOA bit is set. */
	if(sldns_buffer_position(pkt) < pos+4+rdatalen) {
		/* nsec type bitmap contains items */
		uint8_t win, blen, bits;
		/* need: windownum, bitmap len, firstbyte */
		if(sldns_buffer_position(pkt)+3 > pos+4+rdatalen) {
			sldns_buffer_set_position(pkt, pos);
			return 0; /* malformed nsec */
		}
		win = sldns_buffer_read_u8(pkt);
		blen = sldns_buffer_read_u8(pkt);
		bits = sldns_buffer_read_u8(pkt);
		/* 0window always first window. bitlen >=1 or parse
		   error really. bit 0x2 is SOA. */
		if(win == 0 && blen >= 1 && (bits & 0x02)) {
			sldns_buffer_set_position(pkt, pos);
			return 1;
		}
	}

	sldns_buffer_set_position(pkt, pos);
	return 0;
}

/** Calculate rrset flags */
static uint32_t
pkt_rrset_flags(sldns_buffer* pkt, uint16_t type, sldns_pkt_section sec)
{
	uint32_t f = 0;
	if(type == LDNS_RR_TYPE_NSEC && nsec_at_apex(pkt)) {
		f |= PACKED_RRSET_NSEC_AT_APEX;
	} else if(type == LDNS_RR_TYPE_SOA && sec == LDNS_SECTION_AUTHORITY) {
		f |= PACKED_RRSET_SOA_NEG;
	}
	return f;
}

hashvalue_type
pkt_hash_rrset(sldns_buffer* pkt, uint8_t* dname, uint16_t type, 
	uint16_t dclass, uint32_t rrset_flags)
{
	/* note this MUST be identical to rrset_key_hash in packed_rrset.c */
	/* this routine handles compressed names */
	hashvalue_type h = 0xab;
	h = dname_pkt_hash(pkt, dname, h);
	h = hashlittle(&type, sizeof(type), h);		/* host order */
	h = hashlittle(&dclass, sizeof(dclass), h);	/* netw order */
	h = hashlittle(&rrset_flags, sizeof(uint32_t), h);
	return h;
}

/** create partial dname hash for rrset hash */
static hashvalue_type
pkt_hash_rrset_first(sldns_buffer* pkt, uint8_t* dname)
{
	/* works together with pkt_hash_rrset_rest */
	/* note this MUST be identical to rrset_key_hash in packed_rrset.c */
	/* this routine handles compressed names */
	hashvalue_type h = 0xab;
	h = dname_pkt_hash(pkt, dname, h);
	return h;
}

/** create a rrset hash from a partial dname hash */
static hashvalue_type
pkt_hash_rrset_rest(hashvalue_type dname_h, uint16_t type, uint16_t dclass, 
	uint32_t rrset_flags)
{
	/* works together with pkt_hash_rrset_first */
	/* note this MUST be identical to rrset_key_hash in packed_rrset.c */
	hashvalue_type h;
	h = hashlittle(&type, sizeof(type), dname_h);	/* host order */
	h = hashlittle(&dclass, sizeof(dclass), h);	/* netw order */
	h = hashlittle(&rrset_flags, sizeof(uint32_t), h);
	return h;
}

/** compare rrset_parse with data */
static int
rrset_parse_equals(struct rrset_parse* p, sldns_buffer* pkt, hashvalue_type h, 
	uint32_t rrset_flags, uint8_t* dname, size_t dnamelen, 
	uint16_t type, uint16_t dclass)
{
	if(p->hash == h && p->dname_len == dnamelen && p->type == type &&
		p->rrset_class == dclass && p->flags == rrset_flags &&
		dname_pkt_compare(pkt, dname, p->dname) == 0)
		return 1;
	return 0;
}


struct rrset_parse*
msgparse_hashtable_lookup(struct msg_parse* msg, sldns_buffer* pkt, 
	hashvalue_type h, uint32_t rrset_flags, uint8_t* dname,
	size_t dnamelen, uint16_t type, uint16_t dclass)
{
	struct rrset_parse* p = msg->hashtable[h & (PARSE_TABLE_SIZE-1)];
	while(p) {
		if(rrset_parse_equals(p, pkt, h, rrset_flags, dname, dnamelen,
			type, dclass))
			return p;
		p = p->rrset_bucket_next;
	}
	return NULL;
}

/** return type networkformat that rrsig in packet covers */
static int
pkt_rrsig_covered(sldns_buffer* pkt, uint8_t* here, uint16_t* type)
{
	size_t pos = sldns_buffer_position(pkt);
	sldns_buffer_set_position(pkt, (size_t)(here-sldns_buffer_begin(pkt)));
	/* ttl + len + size of small rrsig(rootlabel, no signature) */
	if(sldns_buffer_remaining(pkt) < 4+2+19)
		return 0;
	sldns_buffer_skip(pkt, 4); /* ttl */
	if(sldns_buffer_read_u16(pkt) < 19) /* too short */ {
		sldns_buffer_set_position(pkt, pos);
		return 0;
	}
	*type = sldns_buffer_read_u16(pkt);
	sldns_buffer_set_position(pkt, pos);
	return 1;
}

/** true if covered type equals prevtype */
static int
pkt_rrsig_covered_equals(sldns_buffer* pkt, uint8_t* here, uint16_t type)
{
	uint16_t t;
	if(pkt_rrsig_covered(pkt, here, &t) && t == type)
		return 1;
	return 0;
}

void
msgparse_bucket_remove(struct msg_parse* msg, struct rrset_parse* rrset)
{
	struct rrset_parse** p;
	p = &msg->hashtable[ rrset->hash & (PARSE_TABLE_SIZE-1) ];
	while(*p) {
		if(*p == rrset) {
			*p = rrset->rrset_bucket_next;
			return;
		}
		p = &( (*p)->rrset_bucket_next );
	}
}

/** change section of rrset from previous to current section */
static void
change_section(struct msg_parse* msg, struct rrset_parse* rrset,
	sldns_pkt_section section)
{
	struct rrset_parse *p, *prev;
	/* remove from list */
	if(section == rrset->section)
		return;
	p = msg->rrset_first;
	prev = 0;
	while(p) {
		if(p == rrset) {
			if(prev) prev->rrset_all_next = p->rrset_all_next;
			else	msg->rrset_first = p->rrset_all_next;
			if(msg->rrset_last == rrset)
				msg->rrset_last = prev;
			break;
		}
		prev = p;
		p = p->rrset_all_next;
	}
	/* remove from count */
	switch(rrset->section) {
		case LDNS_SECTION_ANSWER: msg->an_rrsets--; break;
		case LDNS_SECTION_AUTHORITY: msg->ns_rrsets--; break;
		case LDNS_SECTION_ADDITIONAL: msg->ar_rrsets--; break;
		default: log_assert(0);
	}
	/* insert at end of list */
	rrset->rrset_all_next = 0;
	if(msg->rrset_last)
		msg->rrset_last->rrset_all_next = rrset;
	else	msg->rrset_first = rrset;
	msg->rrset_last = rrset;
	/* up count of new section */
	switch(section) {
		case LDNS_SECTION_AUTHORITY: msg->ns_rrsets++; break;
		case LDNS_SECTION_ADDITIONAL: msg->ar_rrsets++; break;
		default: log_assert(0);
	}
	rrset->section = section;
}

/** see if rrset of type RRSIG contains sig over given type */
static int
rrset_has_sigover(sldns_buffer* pkt, struct rrset_parse* rrset, uint16_t type,
	int* hasother)
{
	int res = 0;
	struct rr_parse* rr = rrset->rr_first;
	log_assert( rrset->type == LDNS_RR_TYPE_RRSIG );
	while(rr) {
		if(pkt_rrsig_covered_equals(pkt, rr->ttl_data, type))
			res = 1;
		else	*hasother = 1;
		rr = rr->next;
	}
	return res;
}

/** move rrsigs from sigset to dataset */
static int
moveover_rrsigs(sldns_buffer* pkt, struct regional* region, 
	struct rrset_parse* sigset, struct rrset_parse* dataset, int duplicate)
{
	struct rr_parse* sig = sigset->rr_first;
	struct rr_parse* prev = NULL;
	struct rr_parse* insert;
	struct rr_parse* nextsig;
	while(sig) {
		nextsig = sig->next;
		if(pkt_rrsig_covered_equals(pkt, sig->ttl_data, 
			dataset->type)) {
			if(duplicate) {
				/* new */
				insert = (struct rr_parse*)regional_alloc(
					region, sizeof(struct rr_parse));
				if(!insert) return 0;
				insert->outside_packet = 0;
				insert->ttl_data = sig->ttl_data;
				insert->size = sig->size;
				/* prev not used */
			} else {
				/* remove from sigset */
				if(prev) prev->next = sig->next;
				else	sigset->rr_first = sig->next;
				if(sigset->rr_last == sig)
					sigset->rr_last = prev;
				sigset->rr_count--;
				sigset->size -= sig->size;
				insert = sig;
				/* prev not changed */
			}
			/* add to dataset */
			dataset->rrsig_count++;
			insert->next = 0;
			if(dataset->rrsig_last) 
				dataset->rrsig_last->next = insert;
			else	dataset->rrsig_first = insert;
			dataset->rrsig_last = insert;
			dataset->size += insert->size;
		} else  {
			prev = sig;
		}
		sig = nextsig;
	}
	return 1;
}

/** change an rrsig rrset for use as data rrset */
static struct rrset_parse*
change_rrsig_rrset(struct rrset_parse* sigset, struct msg_parse* msg, 
	sldns_buffer* pkt, uint16_t datatype, uint32_t rrset_flags,
	int hasother, sldns_pkt_section section, struct regional* region)
{
	struct rrset_parse* dataset = sigset;
	hashvalue_type hash = pkt_hash_rrset(pkt, sigset->dname, datatype, 
		sigset->rrset_class, rrset_flags);
	log_assert( sigset->type == LDNS_RR_TYPE_RRSIG );
	log_assert( datatype != LDNS_RR_TYPE_RRSIG );
	if(hasother) {
		/* need to make new rrset to hold data type */
		dataset = new_rrset(msg, sigset->dname, sigset->dname_len, 
			datatype, sigset->rrset_class, hash, rrset_flags, 
			section, region);
		if(!dataset) 
			return NULL;
		switch(section) {
			case LDNS_SECTION_ANSWER: msg->an_rrsets++; break;
			case LDNS_SECTION_AUTHORITY: msg->ns_rrsets++; break;
			case LDNS_SECTION_ADDITIONAL: msg->ar_rrsets++; break;
			default: log_assert(0);
		}
		if(!moveover_rrsigs(pkt, region, sigset, dataset, 
			msg->qtype == LDNS_RR_TYPE_RRSIG ||
			(msg->qtype == LDNS_RR_TYPE_ANY &&
			section != LDNS_SECTION_ANSWER) ))
			return NULL;
		return dataset;
	}
	/* changeover the type of the rrset to data set */
	msgparse_bucket_remove(msg, dataset);
	/* insert into new hash bucket */
	dataset->rrset_bucket_next = msg->hashtable[hash&(PARSE_TABLE_SIZE-1)];
	msg->hashtable[hash&(PARSE_TABLE_SIZE-1)] = dataset;
	dataset->hash = hash;
	/* use section of data item for result */
	change_section(msg, dataset, section);
	dataset->type = datatype;
	dataset->flags = rrset_flags;
	dataset->rrsig_count += dataset->rr_count;
	dataset->rr_count = 0;
	/* move sigs to end of siglist */
	if(dataset->rrsig_last)
		dataset->rrsig_last->next = dataset->rr_first;
	else	dataset->rrsig_first = dataset->rr_first;
	dataset->rrsig_last = dataset->rr_last;
	dataset->rr_first = 0;
	dataset->rr_last = 0;
	return dataset;
}

/** Find rrset. If equal to previous it is fast. hash if not so.
 * @@param msg: the message with hash table.
 * @@param pkt: the packet in wireformat (needed for compression ptrs).
 * @@param dname: pointer to start of dname (compressed) in packet.
 * @@param dnamelen: uncompressed wirefmt length of dname.
 * @@param type: type of current rr.
 * @@param dclass: class of current rr.
 * @@param hash: hash value is returned if the rrset could not be found.
 * @@param rrset_flags: is returned if the rrset could not be found.
 * @@param prev_dname_first: dname of last seen RR. First seen dname.
 * @@param prev_dname_last: dname of last seen RR. Last seen dname.
 * @@param prev_dnamelen: dname len of last seen RR.
 * @@param prev_type: type of last seen RR.
 * @@param prev_dclass: class of last seen RR.
 * @@param rrset_prev: last seen RRset.
 * @@param section: the current section in the packet.
 * @@param region: used to allocate temporary parsing data.
 * @@return 0 on out of memory.
 */
static int
find_rrset(struct msg_parse* msg, sldns_buffer* pkt, uint8_t* dname, 
	size_t dnamelen, uint16_t type, uint16_t dclass, hashvalue_type* hash, 
	uint32_t* rrset_flags,
	uint8_t** prev_dname_first, uint8_t** prev_dname_last,
	size_t* prev_dnamelen, uint16_t* prev_type,
	uint16_t* prev_dclass, struct rrset_parse** rrset_prev,
	sldns_pkt_section section, struct regional* region)
{
	hashvalue_type dname_h = pkt_hash_rrset_first(pkt, dname);
	uint16_t covtype;
	if(*rrset_prev) {
		/* check if equal to previous item */
		if(type == *prev_type && dclass == *prev_dclass &&
			dnamelen == *prev_dnamelen &&
			smart_compare(pkt, dname, *prev_dname_first, 
				*prev_dname_last) == 0 &&
			type != LDNS_RR_TYPE_RRSIG) {
			/* same as previous */
			*prev_dname_last = dname;
			return 1;
		}
		/* check if rrsig over previous item */
		if(type == LDNS_RR_TYPE_RRSIG && dclass == *prev_dclass &&
			pkt_rrsig_covered_equals(pkt, sldns_buffer_current(pkt),
				*prev_type) &&
			smart_compare(pkt, dname, *prev_dname_first,
				*prev_dname_last) == 0) {
			/* covers previous */
			*prev_dname_last = dname;
			return 1;
		}
	}
	/* find by hashing and lookup in hashtable */
	*rrset_flags = pkt_rrset_flags(pkt, type, section);
	
	/* if rrsig - try to lookup matching data set first */
	if(type == LDNS_RR_TYPE_RRSIG && pkt_rrsig_covered(pkt, 
		sldns_buffer_current(pkt), &covtype)) {
		*hash = pkt_hash_rrset_rest(dname_h, covtype, dclass, 
			*rrset_flags);
		*rrset_prev = msgparse_hashtable_lookup(msg, pkt, *hash, 
			*rrset_flags, dname, dnamelen, covtype, dclass);
		if(!*rrset_prev && covtype == LDNS_RR_TYPE_NSEC) {
			/* if NSEC try with NSEC apex bit twiddled */
			*rrset_flags ^= PACKED_RRSET_NSEC_AT_APEX;
			*hash = pkt_hash_rrset_rest(dname_h, covtype, dclass, 
				*rrset_flags);
			*rrset_prev = msgparse_hashtable_lookup(msg, pkt, 
				*hash, *rrset_flags, dname, dnamelen, covtype, 
				dclass);
			if(!*rrset_prev) /* untwiddle if not found */
				*rrset_flags ^= PACKED_RRSET_NSEC_AT_APEX;
		}
		if(!*rrset_prev && covtype == LDNS_RR_TYPE_SOA) {
			/* if SOA try with SOA neg flag twiddled */
			*rrset_flags ^= PACKED_RRSET_SOA_NEG;
			*hash = pkt_hash_rrset_rest(dname_h, covtype, dclass, 
				*rrset_flags);
			*rrset_prev = msgparse_hashtable_lookup(msg, pkt, 
				*hash, *rrset_flags, dname, dnamelen, covtype, 
				dclass);
			if(!*rrset_prev) /* untwiddle if not found */
				*rrset_flags ^= PACKED_RRSET_SOA_NEG;
		}
		if(*rrset_prev) {
			*prev_dname_first = (*rrset_prev)->dname;
			*prev_dname_last = dname;
			*prev_dnamelen = dnamelen;
			*prev_type = covtype;
			*prev_dclass = dclass;
			return 1;
		}
	}
	if(type != LDNS_RR_TYPE_RRSIG) {
		int hasother = 0;
		/* find matching rrsig */
		*hash = pkt_hash_rrset_rest(dname_h, LDNS_RR_TYPE_RRSIG, 
			dclass, 0);
		*rrset_prev = msgparse_hashtable_lookup(msg, pkt, *hash, 
			0, dname, dnamelen, LDNS_RR_TYPE_RRSIG, 
			dclass);
		if(*rrset_prev && rrset_has_sigover(pkt, *rrset_prev, type,
			&hasother)) {
			/* yes! */
			*prev_dname_first = (*rrset_prev)->dname;
			*prev_dname_last = dname;
			*prev_dnamelen = dnamelen;
			*prev_type = type;
			*prev_dclass = dclass;
			*rrset_prev = change_rrsig_rrset(*rrset_prev, msg, 
				pkt, type, *rrset_flags, hasother, section, 
				region);
			if(!*rrset_prev) return 0;
			return 1;
		}
	}

	*hash = pkt_hash_rrset_rest(dname_h, type, dclass, *rrset_flags);
	*rrset_prev = msgparse_hashtable_lookup(msg, pkt, *hash, *rrset_flags, 
		dname, dnamelen, type, dclass);
	if(*rrset_prev)
		*prev_dname_first = (*rrset_prev)->dname;
	else 	*prev_dname_first = dname;
	*prev_dname_last = dname;
	*prev_dnamelen = dnamelen;
	*prev_type = type;
	*prev_dclass = dclass;
	return 1;
}

/**
 * Parse query section. 
 * @@param pkt: packet, position at call must be at start of query section.
 *	at end position is after query section.
 * @@param msg: store results here.
 * @@return: 0 if OK, or rcode on error.
 */
static int
parse_query_section(sldns_buffer* pkt, struct msg_parse* msg)
{
	if(msg->qdcount == 0)
		return 0;
	if(msg->qdcount > 1)
		return LDNS_RCODE_FORMERR;
	log_assert(msg->qdcount == 1);
	if(sldns_buffer_remaining(pkt) <= 0)
		return LDNS_RCODE_FORMERR;
	msg->qname = sldns_buffer_current(pkt);
	if((msg->qname_len = pkt_dname_len(pkt)) == 0)
		return LDNS_RCODE_FORMERR;
	if(sldns_buffer_remaining(pkt) < sizeof(uint16_t)*2)
		return LDNS_RCODE_FORMERR;
	msg->qtype = sldns_buffer_read_u16(pkt);
	msg->qclass = sldns_buffer_read_u16(pkt);
	return 0;
}

size_t
get_rdf_size(sldns_rdf_type rdf)
{
	switch(rdf) {
		case LDNS_RDF_TYPE_CLASS:
		case LDNS_RDF_TYPE_ALG:
		case LDNS_RDF_TYPE_INT8:
			return 1;
			break;
		case LDNS_RDF_TYPE_INT16:
		case LDNS_RDF_TYPE_TYPE:
		case LDNS_RDF_TYPE_CERT_ALG:
			return 2;
			break;
		case LDNS_RDF_TYPE_INT32:
		case LDNS_RDF_TYPE_TIME:
		case LDNS_RDF_TYPE_A:
		case LDNS_RDF_TYPE_PERIOD:
			return 4;
			break;
		case LDNS_RDF_TYPE_TSIGTIME:
			return 6;
			break;
		case LDNS_RDF_TYPE_AAAA:
			return 16;
			break;
		default:
			log_assert(0); /* add type above */
			/* only types that appear before a domain  *
			 * name are needed. rest is simply copied. */
	}
	return 0;
}

/** calculate the size of one rr */
static int
calc_size(sldns_buffer* pkt, uint16_t type, struct rr_parse* rr)
{
	const sldns_rr_descriptor* desc;
	uint16_t pkt_len; /* length of rr inside the packet */
	rr->size = sizeof(uint16_t); /* the rdatalen */
	sldns_buffer_skip(pkt, 4); /* skip ttl */
	pkt_len = sldns_buffer_read_u16(pkt);
	if(sldns_buffer_remaining(pkt) < pkt_len)
		return 0;
	desc = sldns_rr_descript(type);
	if(pkt_len > 0 && desc && desc->_dname_count > 0) {
		int count = (int)desc->_dname_count;
		int rdf = 0;
		size_t len;
		size_t oldpos;
		/* skip first part. */
		while(pkt_len > 0 && count) {
			switch(desc->_wireformat[rdf]) {
			case LDNS_RDF_TYPE_DNAME:
				/* decompress every domain name */
				oldpos = sldns_buffer_position(pkt);
				if((len = pkt_dname_len(pkt)) == 0)
					return 0; /* malformed dname */
				if(sldns_buffer_position(pkt)-oldpos > pkt_len)
					return 0; /* dname exceeds rdata */
				pkt_len -= sldns_buffer_position(pkt)-oldpos;
				rr->size += len;
				count--;
				len = 0;
				break;
			case LDNS_RDF_TYPE_STR:
				if(pkt_len < 1) {
					/* NOTREACHED, due to 'while(>0)' */
					return 0; /* len byte exceeds rdata */
				}
				len = sldns_buffer_current(pkt)[0] + 1;
				break;
			default:
				len = get_rdf_size(desc->_wireformat[rdf]);
			}
			if(len) {
				if(pkt_len < len)
					return 0; /* exceeds rdata */
				pkt_len -= len;
				sldns_buffer_skip(pkt, (ssize_t)len);
				rr->size += len;
			}
			rdf++;
		}
	}
	/* remaining rdata */
	rr->size += pkt_len;
	sldns_buffer_skip(pkt, (ssize_t)pkt_len);
	return 1;
}

/** skip rr ttl and rdata */
static int
skip_ttl_rdata(sldns_buffer* pkt) 
{
	uint16_t rdatalen;
	if(sldns_buffer_remaining(pkt) < 6) /* ttl + rdatalen */
		return 0;
	sldns_buffer_skip(pkt, 4); /* ttl */
	rdatalen = sldns_buffer_read_u16(pkt);
	if(sldns_buffer_remaining(pkt) < rdatalen)
		return 0;
	sldns_buffer_skip(pkt, (ssize_t)rdatalen);
	return 1;
}

/** see if RRSIG is a duplicate of another */
static int
sig_is_double(sldns_buffer* pkt, struct rrset_parse* rrset, uint8_t* ttldata)
{
	uint16_t rlen, siglen;
	size_t pos = sldns_buffer_position(pkt);
	struct rr_parse* sig;
	if(sldns_buffer_remaining(pkt) < 6) 
		return 0;
	sldns_buffer_skip(pkt, 4); /* ttl */
	rlen = sldns_buffer_read_u16(pkt);
	if(sldns_buffer_remaining(pkt) < rlen) {
		sldns_buffer_set_position(pkt, pos);
		return 0;
	}
	sldns_buffer_set_position(pkt, pos);

	sig = rrset->rrsig_first;
	while(sig) {
		/* check if rdatalen is same */
		memmove(&siglen, sig->ttl_data+4, sizeof(siglen));
		siglen = ntohs(siglen);
		/* checks if data in packet is exactly the same, this means
		 * also dname in rdata is the same, but rrsig is not allowed
		 * to have compressed dnames anyway. If it is compressed anyway
		 * it will lead to duplicate rrs for qtype=RRSIG. (or ANY).
		 *
		 * Cannot use sig->size because size of the other one is not 
		 * calculated yet.
		 */
		if(siglen == rlen) {
			if(siglen>0 && memcmp(sig->ttl_data+6, ttldata+6, 
				siglen) == 0) {
				/* same! */
				return 1;
			}
		}
		sig = sig->next;
	}
	return 0;
}

/** Add rr (from packet here) to rrset, skips rr */
static int
add_rr_to_rrset(struct rrset_parse* rrset, sldns_buffer* pkt, 
	struct msg_parse* msg, struct regional* region, 
	sldns_pkt_section section, uint16_t type)
{
	struct rr_parse* rr;
	/* check section of rrset. */
	if(rrset->section != section && type != LDNS_RR_TYPE_RRSIG &&
		rrset->type != LDNS_RR_TYPE_RRSIG) {
		/* silently drop it - we drop the last part, since
		 * trust in rr data depends on the section it is in. 
		 * the less trustworthy part is discarded. 
		 * also the last part is more likely to be incomplete.
		 * RFC 2181: must put RRset only once in response. */
		/*
		verbose(VERB_QUERY, "Packet contains rrset data in "
			"multiple sections, dropped last part.");
		log_buf(VERB_QUERY, "packet was", pkt);
		*/
		/* forwards */
		if(!skip_ttl_rdata(pkt))
			return LDNS_RCODE_FORMERR;
		return 0;
	} 

	if( (msg->qtype == LDNS_RR_TYPE_RRSIG ||
	     msg->qtype == LDNS_RR_TYPE_ANY) 
	    && sig_is_double(pkt, rrset, sldns_buffer_current(pkt))) {
		if(!skip_ttl_rdata(pkt))
			return LDNS_RCODE_FORMERR;
		return 0;
	}
	
	/* create rr */
	if(!(rr = (struct rr_parse*)regional_alloc(region, sizeof(*rr))))
		return LDNS_RCODE_SERVFAIL;
	rr->outside_packet = 0;
	rr->ttl_data = sldns_buffer_current(pkt);
	rr->next = 0;
	if(type == LDNS_RR_TYPE_RRSIG && rrset->type != LDNS_RR_TYPE_RRSIG) {
		if(rrset->rrsig_last) 
			rrset->rrsig_last->next = rr;
		else	rrset->rrsig_first = rr;
		rrset->rrsig_last = rr;
		rrset->rrsig_count++;
	} else {
		if(rrset->rr_last)
			rrset->rr_last->next = rr;
		else	rrset->rr_first = rr;
		rrset->rr_last = rr;
		rrset->rr_count++;
	}

	/* calc decompressed size */
	if(!calc_size(pkt, type, rr))
		return LDNS_RCODE_FORMERR;
	rrset->size += rr->size;

	return 0;
}

/**
 * Parse packet RR section, for answer, authority and additional sections. 
 * @@param pkt: packet, position at call must be at start of section.
 *	at end position is after section.
 * @@param msg: store results here.
 * @@param region: how to alloc results.
 * @@param section: section enum.
 * @@param num_rrs: how many rrs are in the section.
 * @@param num_rrsets: returns number of rrsets in the section.
 * @@return: 0 if OK, or rcode on error.
 */
static int
parse_section(sldns_buffer* pkt, struct msg_parse* msg, 
	struct regional* region, sldns_pkt_section section, 
	uint16_t num_rrs, size_t* num_rrsets)
{
	uint16_t i;
	uint8_t* dname, *prev_dname_f = NULL, *prev_dname_l = NULL;
	size_t dnamelen, prev_dnamelen = 0;
	uint16_t type, prev_type = 0;
	uint16_t dclass, prev_dclass = 0;
	uint32_t rrset_flags = 0;
	hashvalue_type hash = 0;
	struct rrset_parse* rrset = NULL;
	int r;

	if(num_rrs == 0)
		return 0;
	if(sldns_buffer_remaining(pkt) <= 0)
		return LDNS_RCODE_FORMERR;
	for(i=0; i<num_rrs; i++) {
		/* parse this RR. */
		dname = sldns_buffer_current(pkt);
		if((dnamelen = pkt_dname_len(pkt)) == 0)
			return LDNS_RCODE_FORMERR;
		if(sldns_buffer_remaining(pkt) < 10) /* type, class, ttl, len */
			return LDNS_RCODE_FORMERR;
		type = sldns_buffer_read_u16(pkt);
		sldns_buffer_read(pkt, &dclass, sizeof(dclass));

		if(0) { /* debug show what is being parsed. */
			if(type == LDNS_RR_TYPE_RRSIG) {
				uint16_t t;
				if(pkt_rrsig_covered(pkt, 
					sldns_buffer_current(pkt), &t))
					fprintf(stderr, "parse of %s(%d) [%s(%d)]",
					sldns_rr_descript(type)?
					sldns_rr_descript(type)->_name: "??",
					(int)type,
					sldns_rr_descript(t)?
					sldns_rr_descript(t)->_name: "??",
					(int)t);
			} else
			  fprintf(stderr, "parse of %s(%d)",
				sldns_rr_descript(type)?
				sldns_rr_descript(type)->_name: "??",
				(int)type);
			fprintf(stderr, " %s(%d) ",
				sldns_lookup_by_id(sldns_rr_classes, 
				(int)ntohs(dclass))?sldns_lookup_by_id(
				sldns_rr_classes, (int)ntohs(dclass))->name: 
				"??", (int)ntohs(dclass));
			dname_print(stderr, pkt, dname);
			fprintf(stderr, "\n");
		}

		/* see if it is part of an existing RR set */
		if(!find_rrset(msg, pkt, dname, dnamelen, type, dclass, &hash, 
			&rrset_flags, &prev_dname_f, &prev_dname_l, 
			&prev_dnamelen, &prev_type, &prev_dclass, &rrset, 
			section, region))
			return LDNS_RCODE_SERVFAIL;
		if(!rrset) {
			/* it is a new RR set. hash&flags already calculated.*/
			(*num_rrsets)++;
			rrset = new_rrset(msg, dname, dnamelen, type, dclass,
				hash, rrset_flags, section, region);
			if(!rrset) 
				return LDNS_RCODE_SERVFAIL;
		}
		else if(0)	{ 
			fprintf(stderr, "is part of existing: ");
			dname_print(stderr, pkt, rrset->dname);
			fprintf(stderr, " type %s(%d)\n",
				sldns_rr_descript(rrset->type)?
				sldns_rr_descript(rrset->type)->_name: "??",
				(int)rrset->type);
		}
		/* add to rrset. */
		if((r=add_rr_to_rrset(rrset, pkt, msg, region, section, 
			type)) != 0)
			return r;
	}
	return 0;
}

int
parse_packet(sldns_buffer* pkt, struct msg_parse* msg, struct regional* region)
{
	int ret;
	if(sldns_buffer_remaining(pkt) < LDNS_HEADER_SIZE)
		return LDNS_RCODE_FORMERR;
	/* read the header */
	sldns_buffer_read(pkt, &msg->id, sizeof(uint16_t));
	msg->flags = sldns_buffer_read_u16(pkt);
	msg->qdcount = sldns_buffer_read_u16(pkt);
	msg->ancount = sldns_buffer_read_u16(pkt);
	msg->nscount = sldns_buffer_read_u16(pkt);
	msg->arcount = sldns_buffer_read_u16(pkt);
	if(msg->qdcount > 1)
		return LDNS_RCODE_FORMERR;
	if((ret = parse_query_section(pkt, msg)) != 0)
		return ret;
	if((ret = parse_section(pkt, msg, region, LDNS_SECTION_ANSWER,
		msg->ancount, &msg->an_rrsets)) != 0)
		return ret;
	if((ret = parse_section(pkt, msg, region, LDNS_SECTION_AUTHORITY,
		msg->nscount, &msg->ns_rrsets)) != 0)
		return ret;
	if(sldns_buffer_remaining(pkt) == 0 && msg->arcount == 1) {
		/* BIND accepts leniently that an EDNS record is missing.
		 * so, we do too. */
	} else if((ret = parse_section(pkt, msg, region,
		LDNS_SECTION_ADDITIONAL, msg->arcount, &msg->ar_rrsets)) != 0)
		return ret;
	/* if(sldns_buffer_remaining(pkt) > 0) { */
		/* there is spurious data at end of packet. ignore */
	/* } */
	msg->rrset_count = msg->an_rrsets + msg->ns_rrsets + msg->ar_rrsets;
	return 0;
}

/** parse EDNS options from EDNS wireformat rdata */
static int
parse_edns_options(uint8_t* rdata_ptr, size_t rdata_len,
	struct edns_data* edns, struct regional* region)
{
	/* while still more options, and have code+len to read */
	/* ignores partial content (i.e. rdata len 3) */
	while(rdata_len >= 4) {
		uint16_t opt_code = sldns_read_uint16(rdata_ptr);
		uint16_t opt_len = sldns_read_uint16(rdata_ptr+2);
		rdata_ptr += 4;
		rdata_len -= 4;
		if(opt_len > rdata_len)
			break; /* option code partial */
		if(!edns_opt_append(edns, region, opt_code, opt_len,
			rdata_ptr)) {
			log_err("out of memory");
			return 0;
		}
		rdata_ptr += opt_len;
		rdata_len -= opt_len;
	}
	return 1;
}

int 
parse_extract_edns(struct msg_parse* msg, struct edns_data* edns,
	struct regional* region)
{
	struct rrset_parse* rrset = msg->rrset_first;
	struct rrset_parse* prev = 0;
	struct rrset_parse* found = 0;
	struct rrset_parse* found_prev = 0;
	size_t rdata_len;
	uint8_t* rdata_ptr;
	/* since the class encodes the UDP size, we cannot use hash table to
	 * find the EDNS OPT record. Scan the packet. */
	while(rrset) {
		if(rrset->type == LDNS_RR_TYPE_OPT) {
			/* only one OPT RR allowed. */
			if(found) return LDNS_RCODE_FORMERR;
			/* found it! */
			found_prev = prev;
			found = rrset;
		}
		prev = rrset;
		rrset = rrset->rrset_all_next;
	}
	if(!found) {
		memset(edns, 0, sizeof(*edns));
		edns->udp_size = 512;
		return 0;
	}
	/* check the found RRset */
	/* most lenient check possible. ignore dname, use last opt */
	if(found->section != LDNS_SECTION_ADDITIONAL)
		return LDNS_RCODE_FORMERR; 
	if(found->rr_count == 0)
		return LDNS_RCODE_FORMERR;
	if(0) { /* strict checking of dname and RRcount */
		if(found->dname_len != 1 || !found->dname 
			|| found->dname[0] != 0) return LDNS_RCODE_FORMERR; 
		if(found->rr_count != 1) return LDNS_RCODE_FORMERR; 
	}
	log_assert(found->rr_first && found->rr_last);

	/* remove from packet */
	if(found_prev)	found_prev->rrset_all_next = found->rrset_all_next;
	else	msg->rrset_first = found->rrset_all_next;
	if(found == msg->rrset_last)
		msg->rrset_last = found_prev;
	msg->arcount --;
	msg->ar_rrsets --;
	msg->rrset_count --;
	
	/* take the data ! */
	edns->edns_present = 1;
	edns->ext_rcode = found->rr_last->ttl_data[0];
	edns->edns_version = found->rr_last->ttl_data[1];
	edns->bits = sldns_read_uint16(&found->rr_last->ttl_data[2]);
	edns->udp_size = ntohs(found->rrset_class);
	edns->opt_list = NULL;

	/* take the options */
	rdata_len = found->rr_first->size-2;
	rdata_ptr = found->rr_first->ttl_data+6;
	if(!parse_edns_options(rdata_ptr, rdata_len, edns, region))
		return 0;

	/* ignore rrsigs */

	return 0;
}

int 
parse_edns_from_pkt(sldns_buffer* pkt, struct edns_data* edns,
	struct regional* region)
{
	size_t rdata_len;
	uint8_t* rdata_ptr;
	log_assert(LDNS_QDCOUNT(sldns_buffer_begin(pkt)) == 1);
	log_assert(LDNS_ANCOUNT(sldns_buffer_begin(pkt)) == 0);
	log_assert(LDNS_NSCOUNT(sldns_buffer_begin(pkt)) == 0);
	/* check edns section is present */
	if(LDNS_ARCOUNT(sldns_buffer_begin(pkt)) > 1) {
		return LDNS_RCODE_FORMERR;
	}
	if(LDNS_ARCOUNT(sldns_buffer_begin(pkt)) == 0) {
		memset(edns, 0, sizeof(*edns));
		edns->udp_size = 512;
		return 0;
	}
	/* domain name must be the root of length 1. */
	if(pkt_dname_len(pkt) != 1)
		return LDNS_RCODE_FORMERR;
	if(sldns_buffer_remaining(pkt) < 10) /* type, class, ttl, rdatalen */
		return LDNS_RCODE_FORMERR;
	if(sldns_buffer_read_u16(pkt) != LDNS_RR_TYPE_OPT)
		return LDNS_RCODE_FORMERR;
	edns->edns_present = 1;
	edns->udp_size = sldns_buffer_read_u16(pkt); /* class is udp size */
	edns->ext_rcode = sldns_buffer_read_u8(pkt); /* ttl used for bits */
	edns->edns_version = sldns_buffer_read_u8(pkt);
	edns->bits = sldns_buffer_read_u16(pkt);
	edns->opt_list = NULL;

	/* take the options */
	rdata_len = sldns_buffer_read_u16(pkt);
	if(sldns_buffer_remaining(pkt) < rdata_len)
		return LDNS_RCODE_FORMERR;
	rdata_ptr = sldns_buffer_current(pkt);
	if(!parse_edns_options(rdata_ptr, rdata_len, edns, region))
		return LDNS_RCODE_SERVFAIL;

	/* ignore rrsigs */

	return 0;
}

void
log_edns_opt_list(enum verbosity_value level, const char* info_str,
	struct edns_option* list)
{
	if(verbosity >= level && list) {
		char str[128], *s;
		size_t slen;
		verbose(level, "%s", info_str);
		while(list) {
			s = str;
			slen = sizeof(str);
			(void)sldns_wire2str_edns_option_print(&s, &slen, list->opt_code,
				list->opt_data, list->opt_len);
			verbose(level, "  %s", str);
			list = list->next;
		}
	}
}
@


1.3
log
@Update to unbound-1.6.1rc3 - thanks millert@@ and Brad for tests.
@
text
@d1021 1
a1021 1
	rdata_len = found->rr_first->size;
@


1.2
log
@update to unbound-1.5.9. (there will be a follow-up commit to cherrypick a
couple of post-1.5.9 patches).

tests from Mark Patruck, danj, matthieu, millert. reads ok to jung, ok florian.
@
text
@d74 1
a74 1
	uint16_t type, uint16_t dclass, hashvalue_t hash, 
d162 1
a162 1
hashvalue_t
d168 1
a168 1
	hashvalue_t h = 0xab;
d177 1
a177 1
static hashvalue_t
d183 1
a183 1
	hashvalue_t h = 0xab;
d189 2
a190 2
static hashvalue_t
pkt_hash_rrset_rest(hashvalue_t dname_h, uint16_t type, uint16_t dclass, 
d195 1
a195 1
	hashvalue_t h;
d204 1
a204 1
rrset_parse_equals(struct rrset_parse* p, sldns_buffer* pkt, hashvalue_t h, 
d218 2
a219 2
	hashvalue_t h, uint32_t rrset_flags, uint8_t* dname, size_t dnamelen, 
	uint16_t type, uint16_t dclass)
d391 1
a391 1
	hashvalue_t hash = pkt_hash_rrset(pkt, sigset->dname, datatype, 
d458 1
a458 1
	size_t dnamelen, uint16_t type, uint16_t dclass, hashvalue_t* hash, 
d465 1
a465 1
	hashvalue_t dname_h = pkt_hash_rrset_first(pkt, dname);
d827 1
a827 1
	hashvalue_t hash = 0;
d1074 19
@


1.1
log
@Initial revision
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
a39 1
#include <ldns/ldns.h>
d41 1
a41 1
#include "util/net_help.h"
d46 4
d53 1
a53 1
smart_compare(ldns_buffer* pkt, uint8_t* dnow, 
d58 1
a58 1
		uint8_t* p = ldns_buffer_at(pkt, PTR_OFFSET(dnow[0], dnow[1]));
d75 1
a75 1
	uint32_t rrset_flags, ldns_pkt_section section, 
d106 1
a106 1
nsec_at_apex(ldns_buffer* pkt)
d109 1
a109 1
	size_t pos = ldns_buffer_position(pkt);
d111 1
a111 1
	if(ldns_buffer_remaining(pkt) < 7) /* ttl+len+root */
d113 4
a116 4
	ldns_buffer_skip(pkt, 4); /* ttl */;
	rdatalen = ldns_buffer_read_u16(pkt);
	if(ldns_buffer_remaining(pkt) < rdatalen) {
		ldns_buffer_set_position(pkt, pos);
d121 1
a121 1
		ldns_buffer_set_position(pkt, pos);
d126 1
a126 1
	if(ldns_buffer_position(pkt) < pos+4+rdatalen) {
d130 2
a131 2
		if(ldns_buffer_position(pkt)+3 > pos+4+rdatalen) {
			ldns_buffer_set_position(pkt, pos);
d134 3
a136 3
		win = ldns_buffer_read_u8(pkt);
		blen = ldns_buffer_read_u8(pkt);
		bits = ldns_buffer_read_u8(pkt);
d140 1
a140 1
			ldns_buffer_set_position(pkt, pos);
d145 1
a145 1
	ldns_buffer_set_position(pkt, pos);
d151 1
a151 1
pkt_rrset_flags(ldns_buffer* pkt, uint16_t type, ldns_pkt_section sec)
d163 1
a163 1
pkt_hash_rrset(ldns_buffer* pkt, uint8_t* dname, uint16_t type, 
d178 1
a178 1
pkt_hash_rrset_first(ldns_buffer* pkt, uint8_t* dname)
d204 1
a204 1
rrset_parse_equals(struct rrset_parse* p, ldns_buffer* pkt, hashvalue_t h, 
d217 1
a217 1
msgparse_hashtable_lookup(struct msg_parse* msg, ldns_buffer* pkt, 
d233 1
a233 1
pkt_rrsig_covered(ldns_buffer* pkt, uint8_t* here, uint16_t* type)
d235 2
a236 2
	size_t pos = ldns_buffer_position(pkt);
	ldns_buffer_set_position(pkt, (size_t)(here-ldns_buffer_begin(pkt)));
d238 1
a238 1
	if(ldns_buffer_remaining(pkt) < 4+2+19)
d240 3
a242 3
	ldns_buffer_skip(pkt, 4); /* ttl */
	if(ldns_buffer_read_u16(pkt) < 19) /* too short */ {
		ldns_buffer_set_position(pkt, pos);
d245 2
a246 2
	*type = ldns_buffer_read_u16(pkt);
	ldns_buffer_set_position(pkt, pos);
d252 1
a252 1
pkt_rrsig_covered_equals(ldns_buffer* pkt, uint8_t* here, uint16_t type)
d277 1
a277 1
	ldns_pkt_section section)
d320 1
a320 1
rrset_has_sigover(ldns_buffer* pkt, struct rrset_parse* rrset, uint16_t type,
d337 1
a337 1
moveover_rrsigs(ldns_buffer* pkt, struct regional* region, 
d387 2
a388 2
	ldns_buffer* pkt, uint16_t datatype, uint32_t rrset_flags,
	int hasother, ldns_pkt_section section, struct regional* region)
d457 1
a457 1
find_rrset(struct msg_parse* msg, ldns_buffer* pkt, uint8_t* dname, 
d463 1
a463 1
	ldns_pkt_section section, struct regional* region)
d480 1
a480 1
			pkt_rrsig_covered_equals(pkt, ldns_buffer_current(pkt),
d494 1
a494 1
		ldns_buffer_current(pkt), &covtype)) {
d575 1
a575 1
parse_query_section(ldns_buffer* pkt, struct msg_parse* msg)
d582 1
a582 1
	if(ldns_buffer_remaining(pkt) <= 0)
d584 1
a584 1
	msg->qname = ldns_buffer_current(pkt);
d587 1
a587 1
	if(ldns_buffer_remaining(pkt) < sizeof(uint16_t)*2)
d589 2
a590 2
	msg->qtype = ldns_buffer_read_u16(pkt);
	msg->qclass = ldns_buffer_read_u16(pkt);
d595 1
a595 1
get_rdf_size(ldns_rdf_type rdf)
d621 1
a621 1
			log_assert(false); /* add type above */
d630 1
a630 1
calc_size(ldns_buffer* pkt, uint16_t type, struct rr_parse* rr)
d632 1
a632 1
	const ldns_rr_descriptor* desc;
d635 3
a637 3
	ldns_buffer_skip(pkt, 4); /* skip ttl */
	pkt_len = ldns_buffer_read_u16(pkt);
	if(ldns_buffer_remaining(pkt) < pkt_len)
d639 1
a639 1
	desc = ldns_rr_descript(type);
d650 1
a650 1
				oldpos = ldns_buffer_position(pkt);
d653 1
a653 1
				if(ldns_buffer_position(pkt)-oldpos > pkt_len)
d655 1
a655 1
				pkt_len -= ldns_buffer_position(pkt)-oldpos;
d661 2
a662 1
				if(pkt_len < 1)
d664 2
a665 1
				len = ldns_buffer_current(pkt)[0] + 1;
d674 1
a674 1
				ldns_buffer_skip(pkt, (ssize_t)len);
d682 1
a682 1
	ldns_buffer_skip(pkt, (ssize_t)pkt_len);
d688 1
a688 1
skip_ttl_rdata(ldns_buffer* pkt) 
d691 1
a691 1
	if(ldns_buffer_remaining(pkt) < 6) /* ttl + rdatalen */
d693 3
a695 3
	ldns_buffer_skip(pkt, 4); /* ttl */
	rdatalen = ldns_buffer_read_u16(pkt);
	if(ldns_buffer_remaining(pkt) < rdatalen)
d697 1
a697 1
	ldns_buffer_skip(pkt, (ssize_t)rdatalen);
d703 1
a703 1
sig_is_double(ldns_buffer* pkt, struct rrset_parse* rrset, uint8_t* ttldata)
d706 1
a706 1
	size_t pos = ldns_buffer_position(pkt);
d708 1
a708 1
	if(ldns_buffer_remaining(pkt) < 6) 
d710 4
a713 4
	ldns_buffer_skip(pkt, 4); /* ttl */
	rlen = ldns_buffer_read_u16(pkt);
	if(ldns_buffer_remaining(pkt) < rlen) {
		ldns_buffer_set_position(pkt, pos);
d716 1
a716 1
	ldns_buffer_set_position(pkt, pos);
d745 1
a745 1
add_rr_to_rrset(struct rrset_parse* rrset, ldns_buffer* pkt, 
d747 1
a747 1
	ldns_pkt_section section, uint16_t type)
d771 1
a771 1
	    && sig_is_double(pkt, rrset, ldns_buffer_current(pkt))) {
d781 1
a781 1
	rr->ttl_data = ldns_buffer_current(pkt);
d817 2
a818 2
parse_section(ldns_buffer* pkt, struct msg_parse* msg, 
	struct regional* region, ldns_pkt_section section, 
d833 1
a833 1
	if(ldns_buffer_remaining(pkt) <= 0)
d837 1
a837 1
		dname = ldns_buffer_current(pkt);
d840 1
a840 1
		if(ldns_buffer_remaining(pkt) < 10) /* type, class, ttl, len */
d842 2
a843 2
		type = ldns_buffer_read_u16(pkt);
		ldns_buffer_read(pkt, &dclass, sizeof(dclass));
d849 1
a849 1
					ldns_buffer_current(pkt), &t))
d851 2
a852 2
					ldns_rr_descript(type)?
					ldns_rr_descript(type)->_name: "??",
d854 2
a855 2
					ldns_rr_descript(t)?
					ldns_rr_descript(t)->_name: "??",
d859 2
a860 2
				ldns_rr_descript(type)?
				ldns_rr_descript(type)->_name: "??",
d863 3
a865 3
				ldns_lookup_by_id(ldns_rr_classes, 
				(int)ntohs(dclass))?ldns_lookup_by_id(
				ldns_rr_classes, (int)ntohs(dclass))->name: 
d889 2
a890 2
				ldns_rr_descript(rrset->type)?
				ldns_rr_descript(rrset->type)->_name: "??",
d902 1
a902 1
parse_packet(ldns_buffer* pkt, struct msg_parse* msg, struct regional* region)
d905 1
a905 1
	if(ldns_buffer_remaining(pkt) < LDNS_HEADER_SIZE)
d908 6
a913 6
	ldns_buffer_read(pkt, &msg->id, sizeof(uint16_t));
	msg->flags = ldns_buffer_read_u16(pkt);
	msg->qdcount = ldns_buffer_read_u16(pkt);
	msg->ancount = ldns_buffer_read_u16(pkt);
	msg->nscount = ldns_buffer_read_u16(pkt);
	msg->arcount = ldns_buffer_read_u16(pkt);
d924 1
a924 1
	if(ldns_buffer_remaining(pkt) == 0 && msg->arcount == 1) {
d930 1
a930 1
	/* if(ldns_buffer_remaining(pkt) > 0) { */
d937 25
d963 2
a964 1
parse_extract_edns(struct msg_parse* msg, struct edns_data* edns)
d970 2
d1016 1
a1016 1
	edns->bits = ldns_read_uint16(&found->rr_last->ttl_data[2]);
d1018 10
a1027 1
	/* ignore rdata and rrsigs */
d1032 2
a1033 1
parse_edns_from_pkt(ldns_buffer* pkt, struct edns_data* edns)
d1035 5
a1039 3
	log_assert(LDNS_QDCOUNT(ldns_buffer_begin(pkt)) == 1);
	log_assert(LDNS_ANCOUNT(ldns_buffer_begin(pkt)) == 0);
	log_assert(LDNS_NSCOUNT(ldns_buffer_begin(pkt)) == 0);
d1041 1
a1041 1
	if(LDNS_ARCOUNT(ldns_buffer_begin(pkt)) > 1) {
d1044 1
a1044 1
	if(LDNS_ARCOUNT(ldns_buffer_begin(pkt)) == 0) {
d1052 1
a1052 1
	if(ldns_buffer_remaining(pkt) < 10) /* type, class, ttl, rdatalen */
d1054 1
a1054 1
	if(ldns_buffer_read_u16(pkt) != LDNS_RR_TYPE_OPT)
d1057 16
a1072 5
	edns->udp_size = ldns_buffer_read_u16(pkt); /* class is udp size */
	edns->ext_rcode = ldns_buffer_read_u8(pkt); /* ttl used for bits */
	edns->edns_version = ldns_buffer_read_u8(pkt);
	edns->bits = ldns_buffer_read_u16(pkt);
	/* ignore rdata and rrsigs */
@


1.1.1.1
log
@Import Unbound 1.4.16 to work on in-tree (not yet linked to the build).

These are the direct sources from NLnet Labs upstream, minus these:
compat contrib libunbound/python pythonmod testcode testdata winrc

ok deraadt@@ jakob@@
@
text
@@


1.1.1.2
log
@update to unbound 1.4.18
@
text
@d42 1
d658 1
a658 2
				if(pkt_len < 1) {
					/* NOTREACHED, due to 'while(>0)' */
a659 1
				}
@


1.1.1.3
log
@import unbound 1.4.22 upstream sources, ok brad@@
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d40 1
a45 4
#include "ldns/rrdef.h"
#include "ldns/sbuffer.h"
#include "ldns/parseutil.h"
#include "ldns/wire2str.h"
d49 1
a49 1
smart_compare(sldns_buffer* pkt, uint8_t* dnow, 
d54 1
a54 1
		uint8_t* p = sldns_buffer_at(pkt, PTR_OFFSET(dnow[0], dnow[1]));
d71 1
a71 1
	uint32_t rrset_flags, sldns_pkt_section section, 
d102 1
a102 1
nsec_at_apex(sldns_buffer* pkt)
d105 1
a105 1
	size_t pos = sldns_buffer_position(pkt);
d107 1
a107 1
	if(sldns_buffer_remaining(pkt) < 7) /* ttl+len+root */
d109 4
a112 4
	sldns_buffer_skip(pkt, 4); /* ttl */;
	rdatalen = sldns_buffer_read_u16(pkt);
	if(sldns_buffer_remaining(pkt) < rdatalen) {
		sldns_buffer_set_position(pkt, pos);
d117 1
a117 1
		sldns_buffer_set_position(pkt, pos);
d122 1
a122 1
	if(sldns_buffer_position(pkt) < pos+4+rdatalen) {
d126 2
a127 2
		if(sldns_buffer_position(pkt)+3 > pos+4+rdatalen) {
			sldns_buffer_set_position(pkt, pos);
d130 3
a132 3
		win = sldns_buffer_read_u8(pkt);
		blen = sldns_buffer_read_u8(pkt);
		bits = sldns_buffer_read_u8(pkt);
d136 1
a136 1
			sldns_buffer_set_position(pkt, pos);
d141 1
a141 1
	sldns_buffer_set_position(pkt, pos);
d147 1
a147 1
pkt_rrset_flags(sldns_buffer* pkt, uint16_t type, sldns_pkt_section sec)
d159 1
a159 1
pkt_hash_rrset(sldns_buffer* pkt, uint8_t* dname, uint16_t type, 
d174 1
a174 1
pkt_hash_rrset_first(sldns_buffer* pkt, uint8_t* dname)
d200 1
a200 1
rrset_parse_equals(struct rrset_parse* p, sldns_buffer* pkt, hashvalue_t h, 
d213 1
a213 1
msgparse_hashtable_lookup(struct msg_parse* msg, sldns_buffer* pkt, 
d229 1
a229 1
pkt_rrsig_covered(sldns_buffer* pkt, uint8_t* here, uint16_t* type)
d231 2
a232 2
	size_t pos = sldns_buffer_position(pkt);
	sldns_buffer_set_position(pkt, (size_t)(here-sldns_buffer_begin(pkt)));
d234 1
a234 1
	if(sldns_buffer_remaining(pkt) < 4+2+19)
d236 3
a238 3
	sldns_buffer_skip(pkt, 4); /* ttl */
	if(sldns_buffer_read_u16(pkt) < 19) /* too short */ {
		sldns_buffer_set_position(pkt, pos);
d241 2
a242 2
	*type = sldns_buffer_read_u16(pkt);
	sldns_buffer_set_position(pkt, pos);
d248 1
a248 1
pkt_rrsig_covered_equals(sldns_buffer* pkt, uint8_t* here, uint16_t type)
d273 1
a273 1
	sldns_pkt_section section)
d316 1
a316 1
rrset_has_sigover(sldns_buffer* pkt, struct rrset_parse* rrset, uint16_t type,
d333 1
a333 1
moveover_rrsigs(sldns_buffer* pkt, struct regional* region, 
d383 2
a384 2
	sldns_buffer* pkt, uint16_t datatype, uint32_t rrset_flags,
	int hasother, sldns_pkt_section section, struct regional* region)
d453 1
a453 1
find_rrset(struct msg_parse* msg, sldns_buffer* pkt, uint8_t* dname, 
d459 1
a459 1
	sldns_pkt_section section, struct regional* region)
d476 1
a476 1
			pkt_rrsig_covered_equals(pkt, sldns_buffer_current(pkt),
d490 1
a490 1
		sldns_buffer_current(pkt), &covtype)) {
d571 1
a571 1
parse_query_section(sldns_buffer* pkt, struct msg_parse* msg)
d578 1
a578 1
	if(sldns_buffer_remaining(pkt) <= 0)
d580 1
a580 1
	msg->qname = sldns_buffer_current(pkt);
d583 1
a583 1
	if(sldns_buffer_remaining(pkt) < sizeof(uint16_t)*2)
d585 2
a586 2
	msg->qtype = sldns_buffer_read_u16(pkt);
	msg->qclass = sldns_buffer_read_u16(pkt);
d591 1
a591 1
get_rdf_size(sldns_rdf_type rdf)
d617 1
a617 1
			log_assert(0); /* add type above */
d626 1
a626 1
calc_size(sldns_buffer* pkt, uint16_t type, struct rr_parse* rr)
d628 1
a628 1
	const sldns_rr_descriptor* desc;
d631 3
a633 3
	sldns_buffer_skip(pkt, 4); /* skip ttl */
	pkt_len = sldns_buffer_read_u16(pkt);
	if(sldns_buffer_remaining(pkt) < pkt_len)
d635 1
a635 1
	desc = sldns_rr_descript(type);
d646 1
a646 1
				oldpos = sldns_buffer_position(pkt);
d649 1
a649 1
				if(sldns_buffer_position(pkt)-oldpos > pkt_len)
d651 1
a651 1
				pkt_len -= sldns_buffer_position(pkt)-oldpos;
d661 1
a661 1
				len = sldns_buffer_current(pkt)[0] + 1;
d670 1
a670 1
				sldns_buffer_skip(pkt, (ssize_t)len);
d678 1
a678 1
	sldns_buffer_skip(pkt, (ssize_t)pkt_len);
d684 1
a684 1
skip_ttl_rdata(sldns_buffer* pkt) 
d687 1
a687 1
	if(sldns_buffer_remaining(pkt) < 6) /* ttl + rdatalen */
d689 3
a691 3
	sldns_buffer_skip(pkt, 4); /* ttl */
	rdatalen = sldns_buffer_read_u16(pkt);
	if(sldns_buffer_remaining(pkt) < rdatalen)
d693 1
a693 1
	sldns_buffer_skip(pkt, (ssize_t)rdatalen);
d699 1
a699 1
sig_is_double(sldns_buffer* pkt, struct rrset_parse* rrset, uint8_t* ttldata)
d702 1
a702 1
	size_t pos = sldns_buffer_position(pkt);
d704 1
a704 1
	if(sldns_buffer_remaining(pkt) < 6) 
d706 4
a709 4
	sldns_buffer_skip(pkt, 4); /* ttl */
	rlen = sldns_buffer_read_u16(pkt);
	if(sldns_buffer_remaining(pkt) < rlen) {
		sldns_buffer_set_position(pkt, pos);
d712 1
a712 1
	sldns_buffer_set_position(pkt, pos);
d741 1
a741 1
add_rr_to_rrset(struct rrset_parse* rrset, sldns_buffer* pkt, 
d743 1
a743 1
	sldns_pkt_section section, uint16_t type)
d767 1
a767 1
	    && sig_is_double(pkt, rrset, sldns_buffer_current(pkt))) {
d777 1
a777 1
	rr->ttl_data = sldns_buffer_current(pkt);
d813 2
a814 2
parse_section(sldns_buffer* pkt, struct msg_parse* msg, 
	struct regional* region, sldns_pkt_section section, 
d829 1
a829 1
	if(sldns_buffer_remaining(pkt) <= 0)
d833 1
a833 1
		dname = sldns_buffer_current(pkt);
d836 1
a836 1
		if(sldns_buffer_remaining(pkt) < 10) /* type, class, ttl, len */
d838 2
a839 2
		type = sldns_buffer_read_u16(pkt);
		sldns_buffer_read(pkt, &dclass, sizeof(dclass));
d845 1
a845 1
					sldns_buffer_current(pkt), &t))
d847 2
a848 2
					sldns_rr_descript(type)?
					sldns_rr_descript(type)->_name: "??",
d850 2
a851 2
					sldns_rr_descript(t)?
					sldns_rr_descript(t)->_name: "??",
d855 2
a856 2
				sldns_rr_descript(type)?
				sldns_rr_descript(type)->_name: "??",
d859 3
a861 3
				sldns_lookup_by_id(sldns_rr_classes, 
				(int)ntohs(dclass))?sldns_lookup_by_id(
				sldns_rr_classes, (int)ntohs(dclass))->name: 
d885 2
a886 2
				sldns_rr_descript(rrset->type)?
				sldns_rr_descript(rrset->type)->_name: "??",
d898 1
a898 1
parse_packet(sldns_buffer* pkt, struct msg_parse* msg, struct regional* region)
d901 1
a901 1
	if(sldns_buffer_remaining(pkt) < LDNS_HEADER_SIZE)
d904 6
a909 6
	sldns_buffer_read(pkt, &msg->id, sizeof(uint16_t));
	msg->flags = sldns_buffer_read_u16(pkt);
	msg->qdcount = sldns_buffer_read_u16(pkt);
	msg->ancount = sldns_buffer_read_u16(pkt);
	msg->nscount = sldns_buffer_read_u16(pkt);
	msg->arcount = sldns_buffer_read_u16(pkt);
d920 1
a920 1
	if(sldns_buffer_remaining(pkt) == 0 && msg->arcount == 1) {
d926 1
a926 1
	/* if(sldns_buffer_remaining(pkt) > 0) { */
d984 1
a984 1
	edns->bits = sldns_read_uint16(&found->rr_last->ttl_data[2]);
d991 1
a991 1
parse_edns_from_pkt(sldns_buffer* pkt, struct edns_data* edns)
d993 3
a995 3
	log_assert(LDNS_QDCOUNT(sldns_buffer_begin(pkt)) == 1);
	log_assert(LDNS_ANCOUNT(sldns_buffer_begin(pkt)) == 0);
	log_assert(LDNS_NSCOUNT(sldns_buffer_begin(pkt)) == 0);
d997 1
a997 1
	if(LDNS_ARCOUNT(sldns_buffer_begin(pkt)) > 1) {
d1000 1
a1000 1
	if(LDNS_ARCOUNT(sldns_buffer_begin(pkt)) == 0) {
d1008 1
a1008 1
	if(sldns_buffer_remaining(pkt) < 10) /* type, class, ttl, rdatalen */
d1010 1
a1010 1
	if(sldns_buffer_read_u16(pkt) != LDNS_RR_TYPE_OPT)
d1013 4
a1016 4
	edns->udp_size = sldns_buffer_read_u16(pkt); /* class is udp size */
	edns->ext_rcode = sldns_buffer_read_u8(pkt); /* ttl used for bits */
	edns->edns_version = sldns_buffer_read_u8(pkt);
	edns->bits = sldns_buffer_read_u16(pkt);
@


1.1.1.4
log
@update to Unbound 1.5.4, ok florian@@, looks sane deraadt@@
@
text
@d45 4
a48 4
#include "sldns/rrdef.h"
#include "sldns/sbuffer.h"
#include "sldns/parseutil.h"
#include "sldns/wire2str.h"
@


