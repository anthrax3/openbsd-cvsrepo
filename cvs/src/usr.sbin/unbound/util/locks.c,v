head	1.3;
access;
symbols
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.1.1.2.0.8
	OPENBSD_5_8_BASE:1.1.1.2
	UNBOUND_1_5_4:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.6
	OPENBSD_5_7_BASE:1.1.1.2
	UNBOUND_1_5_2RC1:1.1.1.2
	UNBOUND_1_5_1:1.1.1.2
	UNBOUND_1_5_0:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	UNBOUND_1_4_22:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.10
	OPENBSD_5_5_BASE:1.1.1.1
	UNBOUND_1_4_21:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.6
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.4
	OPENBSD_5_3_BASE:1.1.1.1
	UNBOUND_1_4_18:1.1.1.1
	UNBOUND_1_4_17:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.2
	OPENBSD_5_2_BASE:1.1.1.1
	UNBOUND_1_4_16:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2017.02.17.18.53.32;	author sthen;	state Exp;
branches;
next	1.2;
commitid	R6rMbeA8TNhmzWB4;

1.2
date	2015.12.09.00.59.02;	author sthen;	state Exp;
branches;
next	1.1;
commitid	4BoxseP0g2mXBLfD;

1.1
date	2012.03.26.18.05.42;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.03.26.18.05.42;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.16.11.38.22;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to unbound-1.6.1rc3 - thanks millert@@ and Brad for tests.
@
text
@/**
 * util/locks.c - unbound locking primitives
 *
 * Copyright (c) 2007, NLnet Labs. All rights reserved.
 * 
 * This software is open source.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * Neither the name of the NLNET LABS nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * \file
 * Implementation of locking and threading support.
 * A place for locking debug code since most locking functions are macros.
 */

#include "config.h"
#include "util/locks.h"
#include <signal.h>
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

/** block all signals, masks them away. */
void 
ub_thread_blocksigs(void)
{
#if defined(HAVE_PTHREAD) || defined(HAVE_SOLARIS_THREADS) || defined(HAVE_SIGPROCMASK)
#  if defined(HAVE_PTHREAD) || defined(HAVE_SOLARIS_THREADS)
	int err;
#  endif
	sigset_t sigset;
	sigfillset(&sigset);
#ifdef HAVE_PTHREAD
	if((err=pthread_sigmask(SIG_SETMASK, &sigset, NULL)))
		fatal_exit("pthread_sigmask: %s", strerror(err));
#else
#  ifdef HAVE_SOLARIS_THREADS
	if((err=thr_sigsetmask(SIG_SETMASK, &sigset, NULL)))
		fatal_exit("thr_sigsetmask: %s", strerror(err));
#  else 
	/* have nothing, do single process signal mask */
	if(sigprocmask(SIG_SETMASK, &sigset, NULL))
		fatal_exit("sigprocmask: %s", strerror(errno));
#  endif /* HAVE_SOLARIS_THREADS */
#endif /* HAVE_PTHREAD */
#endif /* have signal stuff */
}

/** unblock one signal, so we can catch it */
void ub_thread_sig_unblock(int sig)
{
#if defined(HAVE_PTHREAD) || defined(HAVE_SOLARIS_THREADS) || defined(HAVE_SIGPROCMASK)
#  if defined(HAVE_PTHREAD) || defined(HAVE_SOLARIS_THREADS)
	int err;
#  endif
	sigset_t sigset;
	sigemptyset(&sigset);
	sigaddset(&sigset, sig);
#ifdef HAVE_PTHREAD
	if((err=pthread_sigmask(SIG_UNBLOCK, &sigset, NULL)))
		fatal_exit("pthread_sigmask: %s", strerror(err));
#else
#  ifdef HAVE_SOLARIS_THREADS
	if((err=thr_sigsetmask(SIG_UNBLOCK, &sigset, NULL)))
		fatal_exit("thr_sigsetmask: %s", strerror(err));
#  else 
	/* have nothing, do single thread case */
	if(sigprocmask(SIG_UNBLOCK, &sigset, NULL))
		fatal_exit("sigprocmask: %s", strerror(errno));
#  endif /* HAVE_SOLARIS_THREADS */
#endif /* HAVE_PTHREAD */
#else
	(void)sig;
#endif /* have signal stuff */
}

#if !defined(HAVE_PTHREAD) && !defined(HAVE_SOLARIS_THREADS) && !defined(HAVE_WINDOWS_THREADS)
/**
 * No threading available: fork a new process.
 * This means no shared data structure, and no locking.
 * Only the main thread ever returns. Exits on errors.
 * @@param thr: the location where to store the thread-id.
 * @@param func: function body of the thread. Return value of func is lost.
 * @@param arg: user argument to func.
 */
void 
ub_thr_fork_create(ub_thread_type* thr, void* (*func)(void*), void* arg)
{
	pid_t pid = fork();
	switch(pid) {
	default:	/* main */
			*thr = (ub_thread_type)pid;
			return;
	case 0: 	/* child */
			*thr = (ub_thread_type)getpid();
			(void)(*func)(arg);
			exit(0);
	case -1:	/* error */
			fatal_exit("could not fork: %s", strerror(errno));
	}
}

/**
 * There is no threading. Wait for a process to terminate.
 * Note that ub_thread_type is defined as pid_t.
 * @@param thread: the process id to wait for.
 */
void ub_thr_fork_wait(ub_thread_type thread)
{
	int status = 0;
	if(waitpid((pid_t)thread, &status, 0) == -1)
		log_err("waitpid(%d): %s", (int)thread, strerror(errno));
	if(status != 0)
		log_warn("process %d abnormal exit with status %d",
			(int)thread, status);
}
#endif /* !defined(HAVE_PTHREAD) && !defined(HAVE_SOLARIS_THREADS) && !defined(HAVE_WINDOWS_THREADS) */

#ifdef HAVE_SOLARIS_THREADS
void* ub_thread_key_get(ub_thread_key_type key)
{
	void* ret=NULL;
	LOCKRET(thr_getspecific(key, &ret));
	return ret;
}
#endif

#ifdef HAVE_WINDOWS_THREADS
/** log a windows GetLastError message */
static void log_win_err(const char* str, DWORD err)
{
	LPTSTR buf;
	if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER, 
		NULL, err, 0, (LPTSTR)&buf, 0, NULL) == 0) {
		/* could not format error message */
		log_err("%s, GetLastError=%d", str, (int)err);
		return;
	}
	log_err("%s, (err=%d): %s", str, (int)err, buf);
	LocalFree(buf);
}

void lock_basic_init(lock_basic_type* lock)
{
	/* implement own lock, because windows HANDLE as Mutex usage
	 * uses too many handles and would bog down the whole system. */
	(void)InterlockedExchange(lock, 0);
}

void lock_basic_destroy(lock_basic_type* lock)
{
	(void)InterlockedExchange(lock, 0);
}

void lock_basic_lock(lock_basic_type* lock)
{
	LONG wait = 1; /* wait 1 msec at first */

	while(InterlockedExchange(lock, 1)) {
		/* if the old value was 1 then if was already locked */
		Sleep(wait); /* wait with sleep */
		wait *= 2;   /* exponential backoff for waiting */
	}
	/* the old value was 0, but we inserted 1, we locked it! */
}

void lock_basic_unlock(lock_basic_type* lock)
{
	/* unlock it by inserting the value of 0. xchg for cache coherency. */
	(void)InterlockedExchange(lock, 0);
}

void ub_thread_key_create(ub_thread_key_type* key, void* f)
{
	*key = TlsAlloc();
	if(*key == TLS_OUT_OF_INDEXES) {
		*key = 0;
		log_win_err("TlsAlloc Failed(OUT_OF_INDEXES)", GetLastError());
	}
	else ub_thread_key_set(*key, f);
}

void ub_thread_key_set(ub_thread_key_type key, void* v)
{
	if(!TlsSetValue(key, v)) {
		log_win_err("TlsSetValue failed", GetLastError());
	}
}

void* ub_thread_key_get(ub_thread_key_type key)
{
	void* ret = (void*)TlsGetValue(key);
	if(ret == NULL && GetLastError() != ERROR_SUCCESS) {
		log_win_err("TlsGetValue failed", GetLastError());
	}
	return ret;
}

void ub_thread_create(ub_thread_type* thr, void* (*func)(void*), void* arg)
{
#ifndef HAVE__BEGINTHREADEX
	*thr = CreateThread(NULL, /* default security (no inherit handle) */
		0, /* default stack size */
		(LPTHREAD_START_ROUTINE)func, arg,
		0, /* default flags, run immediately */
		NULL); /* do not store thread identifier anywhere */
#else
	/* the beginthreadex routine setups for the C lib; aligns stack */
	*thr=(ub_thread_type)_beginthreadex(NULL, 0, (void*)func, arg, 0, NULL);
#endif
	if(*thr == NULL) {
		log_win_err("CreateThread failed", GetLastError());
		fatal_exit("thread create failed");
	}
}

ub_thread_type ub_thread_self(void)
{
	return GetCurrentThread();
}

void ub_thread_join(ub_thread_type thr)
{
	DWORD ret = WaitForSingleObject(thr, INFINITE);
	if(ret == WAIT_FAILED) {
		log_win_err("WaitForSingleObject(Thread):WAIT_FAILED", 
			GetLastError());
	} else if(ret == WAIT_TIMEOUT) {
		log_win_err("WaitForSingleObject(Thread):WAIT_TIMEOUT", 
			GetLastError());
	}
	/* and close the handle to the thread */
	if(!CloseHandle(thr)) {
		log_win_err("CloseHandle(Thread) failed", GetLastError());
	}
}
#endif /* HAVE_WINDOWS_THREADS */
@


1.2
log
@typo fixes from unbound-1.5.7rc1
@
text
@d113 1
a113 1
ub_thr_fork_create(ub_thread_t* thr, void* (*func)(void*), void* arg)
d118 1
a118 1
			*thr = (ub_thread_t)pid;
d121 1
a121 1
			*thr = (ub_thread_t)getpid();
d131 1
a131 1
 * Note that ub_thread_t is defined as pid_t.
d134 1
a134 1
void ub_thr_fork_wait(ub_thread_t thread)
d146 1
a146 1
void* ub_thread_key_get(ub_thread_key_t key)
d170 1
a170 1
void lock_basic_init(lock_basic_t* lock)
d177 1
a177 1
void lock_basic_destroy(lock_basic_t* lock)
d182 1
a182 1
void lock_basic_lock(lock_basic_t* lock)
d194 1
a194 1
void lock_basic_unlock(lock_basic_t* lock)
d200 1
a200 1
void ub_thread_key_create(ub_thread_key_t* key, void* f)
d210 1
a210 1
void ub_thread_key_set(ub_thread_key_t key, void* v)
d217 1
a217 1
void* ub_thread_key_get(ub_thread_key_t key)
d226 1
a226 1
void ub_thread_create(ub_thread_t* thr, void* (*func)(void*), void* arg)
d236 1
a236 1
	*thr=(ub_thread_t)_beginthreadex(NULL, 0, (void*)func, arg, 0, NULL);
d244 1
a244 1
ub_thread_t ub_thread_self(void)
d249 1
a249 1
void ub_thread_join(ub_thread_t thr)
@


1.1
log
@Initial revision
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d235 1
a235 1
	/* the begintheadex routine setups for the C lib; aligns stack */
@


1.1.1.1
log
@Import Unbound 1.4.16 to work on in-tree (not yet linked to the build).

These are the direct sources from NLnet Labs upstream, minus these:
compat contrib libunbound/python pythonmod testcode testdata winrc

ok deraadt@@ jakob@@
@
text
@@


1.1.1.2
log
@import unbound 1.4.22 upstream sources, ok brad@@
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@

