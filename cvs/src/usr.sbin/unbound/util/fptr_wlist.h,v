head	1.8;
access;
symbols
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.6.0.2
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	UNBOUND_1_5_4:1.1.1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	UNBOUND_1_5_2RC1:1.1.1.5
	UNBOUND_1_5_1:1.1.1.5
	UNBOUND_1_5_0:1.1.1.4
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	UNBOUND_1_4_22:1.1.1.3
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	UNBOUND_1_4_21:1.1.1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	UNBOUND_1_4_18:1.1.1.2
	UNBOUND_1_4_17:1.1.1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	UNBOUND_1_4_16:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2017.08.12.11.22.46;	author sthen;	state Exp;
branches;
next	1.7;
commitid	jku4foGr2J38bu5W;

1.7
date	2017.02.17.18.53.32;	author sthen;	state Exp;
branches;
next	1.6;
commitid	R6rMbeA8TNhmzWB4;

1.6
date	2016.06.22.20.05.40;	author sthen;	state Exp;
branches;
next	1.5;
commitid	EnU0HAX1qep1MppE;

1.5
date	2014.11.20.01.15.19;	author brad;	state Exp;
branches;
next	1.4;
commitid	5B1rQYSaYoW2Vhmb;

1.4
date	2014.11.20.00.11.14;	author brad;	state Exp;
branches;
next	1.3;
commitid	8oTbeW6BGSPxqQCQ;

1.3
date	2014.03.16.11.43.29;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2012.05.16.08.57.21;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2012.03.26.18.05.43;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.03.26.18.05.43;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.08.23.22.36.32;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.16.11.38.23;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.20.00.00.29;	author brad;	state Exp;
branches;
next	1.1.1.5;
commitid	bB36RwIVwTq8fGsI;

1.1.1.5
date	2014.12.11.16.18.06;	author brad;	state Exp;
branches;
next	;
commitid	fGLTsCVGImGBxGUi;


desc
@@


1.8
log
@update to unbound 1.6.4, ok florian@@
@
text
@/*
 * util/fptr_wlist.h - function pointer whitelists.
 *
 * Copyright (c) 2007, NLnet Labs. All rights reserved.
 *
 * This software is open source.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * Neither the name of the NLNET LABS nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * \file
 *
 * This file contains functions that check function pointers.
 * The functions contain a whitelist of known good callback values.
 * Any other values lead to an error. 
 * 
 * This prevent heap overflow based exploits, where the callback pointer
 * is overwritten by a buffer overflow (apart from this defense, buffer 
 * overflows should be fixed of course).
 *
 * Function pointers are used in
 * 	o network code callbacks.
 * 	o rbtree, lruhash, region data manipulation
 *		in lruhash, the assertions are before the critical regions.
 *		in other places, assertions are before the callback.
 * 	o module operations.
 */

#ifndef UTIL_FPTR_WLIST_H
#define UTIL_FPTR_WLIST_H
#include "util/netevent.h"
#include "util/storage/lruhash.h"
#include "util/module.h"
#include "util/tube.h"
#include "services/mesh.h"

/**
 * Macro to perform an assertion check for fptr wlist checks.
 * Does not get disabled in optimize mode. Check adds security by layers.
 */
#if defined(EXPORT_ALL_SYMBOLS)
#define fptr_ok(x) /* nothing, dll-exe memory layout on win disables it */
#else
#define fptr_ok(x) \
	do { if(!(x)) \
		fatal_exit("%s:%d: %s: pointer whitelist %s failed", \
		__FILE__, __LINE__, __func__, #x); \
	} while(0);
#endif

/**
 * Check function pointer whitelist for comm_point callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_comm_point(comm_point_callback_type *fptr);

/**
 * Check function pointer whitelist for raw comm_point callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_comm_point_raw(comm_point_callback_type *fptr);

/**
 * Check function pointer whitelist for comm_timer callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_comm_timer(void (*fptr)(void*));

/**
 * Check function pointer whitelist for comm_signal callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_comm_signal(void (*fptr)(int, void*));

/**
 * Check function pointer whitelist for start_accept callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_start_accept(void (*fptr)(void*));

/**
 * Check function pointer whitelist for stop_accept callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_stop_accept(void (*fptr)(void*));

/**
 * Check function pointer whitelist for event structure callback values.
 * This is not called by libevent itself, but checked by netevent.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_event(void (*fptr)(int, short, void *));

/**
 * Check function pointer whitelist for pending udp callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_pending_udp(comm_point_callback_type *fptr);

/**
 * Check function pointer whitelist for pending tcp callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_pending_tcp(comm_point_callback_type *fptr);

/**
 * Check function pointer whitelist for serviced query callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_serviced_query(comm_point_callback_type *fptr);

/**
 * Check function pointer whitelist for rbtree cmp callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_rbtree_cmp(int (*fptr) (const void *, const void *));

/**
 * Check function pointer whitelist for lruhash sizefunc callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_hash_sizefunc(lruhash_sizefunc_type fptr);

/**
 * Check function pointer whitelist for lruhash compfunc callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_hash_compfunc(lruhash_compfunc_type fptr);

/**
 * Check function pointer whitelist for lruhash delkeyfunc callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_hash_delkeyfunc(lruhash_delkeyfunc_type fptr);

/**
 * Check function pointer whitelist for lruhash deldata callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_hash_deldatafunc(lruhash_deldatafunc_type fptr);

/**
 * Check function pointer whitelist for lruhash markdel callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_hash_markdelfunc(lruhash_markdelfunc_type fptr);

/**
 * Check function pointer whitelist for module_env send_query callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_modenv_send_query(struct outbound_entry* (*fptr)(
	struct query_info* qinfo, uint16_t flags, int dnssec, int want_dnssec,
	int nocaps, struct sockaddr_storage* addr, socklen_t addrlen,
	uint8_t* zone, size_t zonelen, int ssl_upstream, struct module_qstate* q));

/**
 * Check function pointer whitelist for module_env detach_subs callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_modenv_detach_subs(void (*fptr)(
	struct module_qstate* qstate));

/**
 * Check function pointer whitelist for module_env attach_sub callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_modenv_attach_sub(int (*fptr)(
	struct module_qstate* qstate, struct query_info* qinfo, 
	uint16_t qflags, int prime, int valrec, struct module_qstate** newq));

/**
 * Check function pointer whitelist for module_env add_sub callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_modenv_add_sub(int (*fptr)(struct module_qstate* qstate,
	struct query_info* qinfo, uint16_t qflags, int prime, int valrec,
	struct module_qstate** newq, struct mesh_state** sub));
/**
 * Check function pointer whitelist for module_env kill_sub callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_modenv_kill_sub(void (*fptr)(struct module_qstate* newq));

/**
 * Check function pointer whitelist for module_env detect_cycle callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_modenv_detect_cycle(int (*fptr)(
	struct module_qstate* qstate, struct query_info* qinfo, 
	uint16_t flags, int prime, int valrec));

/**
 * Check function pointer whitelist for module init call values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_mod_init(int (*fptr)(struct module_env* env, int id));

/**
 * Check function pointer whitelist for module deinit call values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_mod_deinit(void (*fptr)(struct module_env* env, int id));

/**
 * Check function pointer whitelist for module operate call values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_mod_operate(void (*fptr)(struct module_qstate* qstate, 
	enum module_ev event, int id, struct outbound_entry* outbound));

/**
 * Check function pointer whitelist for module inform_super call values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_mod_inform_super(void (*fptr)(
	struct module_qstate* qstate, int id, struct module_qstate* super));

/**
 * Check function pointer whitelist for module clear call values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_mod_clear(void (*fptr)(struct module_qstate* qstate, 
	int id));

/**
 * Check function pointer whitelist for module get_mem call values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_mod_get_mem(size_t (*fptr)(struct module_env* env, int id));

/**
 * Check function pointer whitelist for alloc clear on id overflow call values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_alloc_cleanup(void (*fptr)(void*));

/**
 * Check function pointer whitelist for tube listen handler values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_tube_listen(tube_callback_type* fptr);

/**
 * Check function pointer whitelist for mesh state callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_mesh_cb(mesh_cb_func_type fptr);

/**
 * Check function pointer whitelist for config_get_option func values.
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_print_func(void (*fptr)(char*,void*));

/**
 * Check function pointer whitelist for inplace_cb_reply,
 * inplace_cb_reply_cache, inplace_cb_reply_local and inplace_cb_reply_servfail
 * func values.
 * @@param fptr: function pointer to check.
 * @@param type: the type of the callback function.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_inplace_cb_reply_generic(inplace_cb_reply_func_type* fptr,
	enum inplace_cb_list_type type);

/**
 * Check function pointer whitelist for inplace_cb_query func values.
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_inplace_cb_query(inplace_cb_query_func_type* fptr);

/**
 * Check function pointer whitelist for inplace_cb_edns_back_parsed func values.
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_inplace_cb_edns_back_parsed(
	inplace_cb_edns_back_parsed_func_type* fptr);

/**
 * Check function pointer whitelist for inplace_cb_query_response func values.
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_inplace_cb_query_response(
	inplace_cb_query_response_func_type* fptr);

/** Due to module breakage by fptr wlist, these test app declarations
 * are presented here */
/** 
 * compare two order_ids from lock-verify test app 
 * @@param e1: first order_id
 * @@param e2: second order_id
 * @@return compare code -1, 0, +1 (like memcmp).
 */
int order_lock_cmp(const void* e1, const void* e2);

/** 
 * compare two codeline structs for rbtree from memstats test app 
 * @@param a: codeline
 * @@param b: codeline
 * @@return compare code -1, 0, +1 (like memcmp).
 */
int codeline_cmp(const void* a, const void* b);

/** compare two replay_vars */
int replay_var_compare(const void* a, const void* b);

#endif /* UTIL_FPTR_WLIST_H */
@


1.7
log
@Update to unbound-1.6.1rc3 - thanks millert@@ and Brad for tests.
@
text
@d237 9
d362 16
@


1.6
log
@update to unbound-1.5.9. (there will be a follow-up commit to cherrypick a
couple of post-1.5.9 patches).

tests from Mark Patruck, danj, matthieu, millert. reads ok to jung, ok florian.
@
text
@d83 1
a83 1
int fptr_whitelist_comm_point(comm_point_callback_t *fptr);
d91 1
a91 1
int fptr_whitelist_comm_point_raw(comm_point_callback_t *fptr);
d140 1
a140 1
int fptr_whitelist_pending_udp(comm_point_callback_t *fptr);
d148 1
a148 1
int fptr_whitelist_pending_tcp(comm_point_callback_t *fptr);
d156 1
a156 1
int fptr_whitelist_serviced_query(comm_point_callback_t *fptr);
d172 1
a172 1
int fptr_whitelist_hash_sizefunc(lruhash_sizefunc_t fptr);
d180 1
a180 1
int fptr_whitelist_hash_compfunc(lruhash_compfunc_t fptr);
d188 1
a188 1
int fptr_whitelist_hash_delkeyfunc(lruhash_delkeyfunc_t fptr);
d196 1
a196 1
int fptr_whitelist_hash_deldatafunc(lruhash_deldatafunc_t fptr);
d204 1
a204 1
int fptr_whitelist_hash_markdelfunc(lruhash_markdelfunc_t fptr);
d213 3
a215 5
	uint8_t* qname, size_t qnamelen, uint16_t qtype, uint16_t qclass, 
	uint16_t flags, int dnssec, int want_dnssec, int nocaps,
	struct edns_option*, struct sockaddr_storage* addr, socklen_t addrlen, 
	uint8_t* zone, size_t zonelen,
	struct module_qstate* q));
d319 1
a319 1
int fptr_whitelist_tube_listen(tube_callback_t* fptr);
d327 1
a327 1
int fptr_whitelist_mesh_cb(mesh_cb_func_t fptr);
d335 18
@


1.5
log
@Merge in some commits from upstream..

- Removed 'increased limit open files' log message that is written
  to console.  It is only written on verbosity 4 and higher.
  This keeps system bootup console cleaner.
- Fix #627: SSL_CTX_load_verify_locations return code not properly
  checked.
- Fix that CD flag disables DNS64 processing, returning the DNSSEC
  signed AAAA denial.
- Fix cdflag dns64 processing.

ok sthen@@
@
text
@d215 1
a215 1
	struct sockaddr_storage* addr, socklen_t addrlen, 
@


1.4
log
@merge conflicts
@
text
@d236 1
a236 1
	uint16_t qflags, int prime, struct module_qstate** newq));
d254 1
a254 1
	uint16_t flags, int prime));
@


1.3
log
@merge conflicts, remove old libldns files
@
text
@d214 1
a214 1
	uint16_t flags, int dnssec, int want_dnssec,
@


1.2
log
@Don't spin accept() when hitting ENFILE/EMFILE. Upstream r2663.
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
@


1.1
log
@Initial revision
@
text
@d110 16
@


1.1.1.1
log
@Import Unbound 1.4.16 to work on in-tree (not yet linked to the build).

These are the direct sources from NLnet Labs upstream, minus these:
compat contrib libunbound/python pythonmod testcode testdata winrc

ok deraadt@@ jakob@@
@
text
@@


1.1.1.2
log
@update to unbound 1.4.17, testing by okan@@ (not yet linked to build;
1.4.18 to follow later).
@
text
@a109 16
 * Check function pointer whitelist for start_accept callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_start_accept(void (*fptr)(void*));

/**
 * Check function pointer whitelist for stop_accept callback values.
 *
 * @@param fptr: function pointer to check.
 * @@return false if not in whitelist.
 */
int fptr_whitelist_stop_accept(void (*fptr)(void*));

/**
@


1.1.1.3
log
@import unbound 1.4.22 upstream sources, ok brad@@
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.1.1.4
log
@update to Unbound 1.5.0, ok sthen@@
@
text
@d214 1
a214 1
	uint16_t flags, int dnssec, int want_dnssec, int nocaps,
@


1.1.1.5
log
@update to Unbound 1.5.1, ok sthen@@
@
text
@d236 1
a236 1
	uint16_t qflags, int prime, int valrec, struct module_qstate** newq));
d254 1
a254 1
	uint16_t flags, int prime, int valrec));
@


