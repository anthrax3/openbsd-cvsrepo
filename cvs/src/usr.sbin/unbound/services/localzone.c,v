head	1.6;
access;
symbols
	OPENBSD_6_1:1.4.0.4
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.1.1.6.0.2
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.4
	OPENBSD_5_8_BASE:1.1.1.6
	UNBOUND_1_5_4:1.1.1.6
	OPENBSD_5_7:1.1.1.5.0.4
	OPENBSD_5_7_BASE:1.1.1.5
	UNBOUND_1_5_2RC1:1.1.1.5
	UNBOUND_1_5_1:1.1.1.4
	UNBOUND_1_5_0:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	UNBOUND_1_4_22:1.1.1.3
	OPENBSD_5_5:1.1.1.2.0.4
	OPENBSD_5_5_BASE:1.1.1.2
	UNBOUND_1_4_21:1.1.1.2
	OPENBSD_5_4:1.1.1.1.0.6
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.4
	OPENBSD_5_3_BASE:1.1.1.1
	UNBOUND_1_4_18:1.1.1.1
	UNBOUND_1_4_17:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.2
	OPENBSD_5_2_BASE:1.1.1.1
	UNBOUND_1_4_16:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2017.09.29.16.27.14;	author sthen;	state Exp;
branches;
next	1.5;
commitid	z5mbOZJLAmaMe3NV;

1.5
date	2017.08.12.11.22.46;	author sthen;	state Exp;
branches;
next	1.4;
commitid	jku4foGr2J38bu5W;

1.4
date	2017.02.17.18.53.32;	author sthen;	state Exp;
branches;
next	1.3;
commitid	R6rMbeA8TNhmzWB4;

1.3
date	2016.06.22.20.05.40;	author sthen;	state Exp;
branches;
next	1.2;
commitid	EnU0HAX1qep1MppE;

1.2
date	2016.03.05.14.40.35;	author sthen;	state Exp;
branches;
next	1.1;
commitid	ueBpCw2SxWSX3ZZI;

1.1
date	2012.03.26.18.05.43;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.03.26.18.05.43;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.22.11.31.13;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.16.11.38.25;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.20.00.00.32;	author brad;	state Exp;
branches;
next	1.1.1.5;
commitid	bB36RwIVwTq8fGsI;

1.1.1.5
date	2015.02.17.10.01.53;	author sthen;	state Exp;
branches;
next	1.1.1.6;
commitid	HIel2ZueDMYXVbaV;

1.1.1.6
date	2015.07.16.01.42.20;	author sthen;	state Exp;
branches;
next	;
commitid	kEVXcRu8XDMmCd6c;


desc
@@


1.6
log
@update to unbound-1.6.6, ok florian
@
text
@/*
 * services/localzone.c - local zones authority service.
 *
 * Copyright (c) 2007, NLnet Labs. All rights reserved.
 *
 * This software is open source.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * Neither the name of the NLNET LABS nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * \file
 *
 * This file contains functions to enable local zone authority service.
 */
#include "config.h"
#include "services/localzone.h"
#include "sldns/str2wire.h"
#include "sldns/sbuffer.h"
#include "util/regional.h"
#include "util/config_file.h"
#include "util/data/dname.h"
#include "util/data/packed_rrset.h"
#include "util/data/msgencode.h"
#include "util/net_help.h"
#include "util/netevent.h"
#include "util/data/msgreply.h"
#include "util/data/msgparse.h"
#include "util/as112.h"
#include "util/config_file.h"

/* maximum RRs in an RRset, to cap possible 'endless' list RRs.
 * with 16 bytes for an A record, a 64K packet has about 4000 max */
#define LOCALZONE_RRSET_COUNT_MAX 4096

struct local_zones* 
local_zones_create(void)
{
	struct local_zones* zones = (struct local_zones*)calloc(1, 
		sizeof(*zones));
	if(!zones)
		return NULL;
	rbtree_init(&zones->ztree, &local_zone_cmp);
	lock_rw_init(&zones->lock);
	lock_protect(&zones->lock, &zones->ztree, sizeof(zones->ztree));
	/* also lock protects the rbnode's in struct local_zone */
	return zones;
}

/** helper traverse to delete zones */
static void 
lzdel(rbnode_type* n, void* ATTR_UNUSED(arg))
{
	struct local_zone* z = (struct local_zone*)n->key;
	local_zone_delete(z);
}

void 
local_zones_delete(struct local_zones* zones)
{
	if(!zones)
		return;
	lock_rw_destroy(&zones->lock);
	/* walk through zones and delete them all */
	traverse_postorder(&zones->ztree, lzdel, NULL);
	free(zones);
}

void 
local_zone_delete(struct local_zone* z)
{
	if(!z)
		return;
	lock_rw_destroy(&z->lock);
	regional_destroy(z->region);
	free(z->name);
	free(z->taglist);
	free(z);
}

int 
local_zone_cmp(const void* z1, const void* z2)
{
	/* first sort on class, so that hierarchy can be maintained within
	 * a class */
	struct local_zone* a = (struct local_zone*)z1;
	struct local_zone* b = (struct local_zone*)z2;
	int m;
	if(a->dclass != b->dclass) {
		if(a->dclass < b->dclass)
			return -1;
		return 1;
	}
	return dname_lab_cmp(a->name, a->namelabs, b->name, b->namelabs, &m);
}

int 
local_data_cmp(const void* d1, const void* d2)
{
	struct local_data* a = (struct local_data*)d1;
	struct local_data* b = (struct local_data*)d2;
	int m;
	return dname_canon_lab_cmp(a->name, a->namelabs, b->name, 
		b->namelabs, &m);
}

/* form wireformat from text format domain name */
int
parse_dname(const char* str, uint8_t** res, size_t* len, int* labs)
{
	*res = sldns_str2wire_dname(str, len);
	*labs = 0;
	if(!*res) {
		log_err("cannot parse name %s", str);
		return 0;
	}
	*labs = dname_count_size_labels(*res, len);
	return 1;
}

/** create a new localzone */
static struct local_zone*
local_zone_create(uint8_t* nm, size_t len, int labs, 
	enum localzone_type t, uint16_t dclass)
{
	struct local_zone* z = (struct local_zone*)calloc(1, sizeof(*z));
	if(!z) {
		return NULL;
	}
	z->node.key = z;
	z->dclass = dclass;
	z->type = t;
	z->name = nm;
	z->namelen = len;
	z->namelabs = labs;
	lock_rw_init(&z->lock);
	z->region = regional_create_custom(sizeof(struct regional));
	if(!z->region) {
		free(z);
		return NULL;
	}
	rbtree_init(&z->data, &local_data_cmp);
	lock_protect(&z->lock, &z->parent, sizeof(*z)-sizeof(rbnode_type));
	/* also the zones->lock protects node, parent, name*, class */
	return z;
}

/** enter a new zone with allocated dname returns with WRlock */
static struct local_zone*
lz_enter_zone_dname(struct local_zones* zones, uint8_t* nm, size_t len, 
	int labs, enum localzone_type t, uint16_t c)
{
	struct local_zone* z = local_zone_create(nm, len, labs, t, c);
	if(!z) {
		free(nm);
		log_err("out of memory");
		return NULL;
	}

	/* add to rbtree */
	lock_rw_wrlock(&zones->lock);
	lock_rw_wrlock(&z->lock);
	if(!rbtree_insert(&zones->ztree, &z->node)) {
		struct local_zone* oldz;
		char str[256];
		dname_str(nm, str);
		log_warn("duplicate local-zone %s", str);
		lock_rw_unlock(&z->lock);
		/* save zone name locally before deallocation,
		 * otherwise, nm is gone if we zone_delete now. */
		oldz = z;
		/* find the correct zone, so not an error for duplicate */
		z = local_zones_find(zones, nm, len, labs, c);
		lock_rw_wrlock(&z->lock);
		lock_rw_unlock(&zones->lock);
		local_zone_delete(oldz);
		return z;
	}
	lock_rw_unlock(&zones->lock);
	return z;
}

/** enter a new zone */
static struct local_zone*
lz_enter_zone(struct local_zones* zones, const char* name, const char* type,
	uint16_t dclass)
{
	struct local_zone* z;
	enum localzone_type t;
	uint8_t* nm;
	size_t len;
	int labs;
	if(!parse_dname(name, &nm, &len, &labs)) {
		log_err("bad zone name %s %s", name, type);
		return NULL;
	}
	if(!local_zone_str2type(type, &t)) {
		log_err("bad lz_enter_zone type %s %s", name, type);
		free(nm);
		return NULL;
	}
	if(!(z=lz_enter_zone_dname(zones, nm, len, labs, t, dclass))) {
		log_err("could not enter zone %s %s", name, type);
		return NULL;
	}
	return z;
}

int
rrstr_get_rr_content(const char* str, uint8_t** nm, uint16_t* type,
	uint16_t* dclass, time_t* ttl, uint8_t* rr, size_t len,
	uint8_t** rdata, size_t* rdata_len)
{
	size_t dname_len = 0;
	int e = sldns_str2wire_rr_buf(str, rr, &len, &dname_len, 3600,
		NULL, 0, NULL, 0);
	if(e) {
		log_err("error parsing local-data at %d: '%s': %s",
			LDNS_WIREPARSE_OFFSET(e), str,
			sldns_get_errorstr_parse(e));
		return 0;
	}
	*nm = memdup(rr, dname_len);
	if(!*nm) {
		log_err("out of memory");
		return 0;
	}
	*dclass = sldns_wirerr_get_class(rr, len, dname_len);
	*type = sldns_wirerr_get_type(rr, len, dname_len);
	*ttl = (time_t)sldns_wirerr_get_ttl(rr, len, dname_len);
	*rdata = sldns_wirerr_get_rdatawl(rr, len, dname_len);
	*rdata_len = sldns_wirerr_get_rdatalen(rr, len, dname_len)+2;
	return 1;
}

/** return name and class of rr; parses string */
static int
get_rr_nameclass(const char* str, uint8_t** nm, uint16_t* dclass,
	uint16_t* dtype)
{
	uint8_t rr[LDNS_RR_BUF_SIZE];
	size_t len = sizeof(rr), dname_len = 0;
	int s = sldns_str2wire_rr_buf(str, rr, &len, &dname_len, 3600,
		NULL, 0, NULL, 0);
	if(s != 0) {
		log_err("error parsing local-data at %d '%s': %s",
			LDNS_WIREPARSE_OFFSET(s), str,
			sldns_get_errorstr_parse(s));
		return 0;
	}
	*nm = memdup(rr, dname_len);
	*dclass = sldns_wirerr_get_class(rr, len, dname_len);
	*dtype = sldns_wirerr_get_type(rr, len, dname_len);
	if(!*nm) {
		log_err("out of memory");
		return 0;
	}
	return 1;
}

/**
 * Find an rrset in local data structure.
 * @@param data: local data domain name structure.
 * @@param type: type to look for (host order).
 * @@param alias_ok: 1 if matching a non-exact, alias type such as CNAME is
 * allowed.  otherwise 0.
 * @@return rrset pointer or NULL if not found.
 */
static struct local_rrset*
local_data_find_type(struct local_data* data, uint16_t type, int alias_ok)
{
	struct local_rrset* p;
	type = htons(type);
	for(p = data->rrsets; p; p = p->next) {
		if(p->rrset->rk.type == type)
			return p;
		if(alias_ok && p->rrset->rk.type == htons(LDNS_RR_TYPE_CNAME))
			return p;
	}
	return NULL;
}

/** check for RR duplicates */
static int
rr_is_duplicate(struct packed_rrset_data* pd, uint8_t* rdata, size_t rdata_len)
{
	size_t i;
	for(i=0; i<pd->count; i++) {
		if(pd->rr_len[i] == rdata_len &&
			memcmp(pd->rr_data[i], rdata, rdata_len) == 0)
			return 1;
	}
	return 0;
}

/** new local_rrset */
static struct local_rrset*
new_local_rrset(struct regional* region, struct local_data* node,
	uint16_t rrtype, uint16_t rrclass)
{
	struct packed_rrset_data* pd;
	struct local_rrset* rrset = (struct local_rrset*)
		regional_alloc_zero(region, sizeof(*rrset));
	if(!rrset) {
		log_err("out of memory");
		return NULL;
	}
	rrset->next = node->rrsets;
	node->rrsets = rrset;
	rrset->rrset = (struct ub_packed_rrset_key*)
		regional_alloc_zero(region, sizeof(*rrset->rrset));
	if(!rrset->rrset) {
		log_err("out of memory");
		return NULL;
	}
	rrset->rrset->entry.key = rrset->rrset;
	pd = (struct packed_rrset_data*)regional_alloc_zero(region,
		sizeof(*pd));
	if(!pd) {
		log_err("out of memory");
		return NULL;
	}
	pd->trust = rrset_trust_prim_noglue;
	pd->security = sec_status_insecure;
	rrset->rrset->entry.data = pd;
	rrset->rrset->rk.dname = node->name;
	rrset->rrset->rk.dname_len = node->namelen;
	rrset->rrset->rk.type = htons(rrtype);
	rrset->rrset->rk.rrset_class = htons(rrclass);
	return rrset;
}

/** insert RR into RRset data structure; Wastes a couple of bytes */
int
rrset_insert_rr(struct regional* region, struct packed_rrset_data* pd,
	uint8_t* rdata, size_t rdata_len, time_t ttl, const char* rrstr)
{
	size_t* oldlen = pd->rr_len;
	time_t* oldttl = pd->rr_ttl;
	uint8_t** olddata = pd->rr_data;

	/* add RR to rrset */
	if(pd->count > LOCALZONE_RRSET_COUNT_MAX) {
		log_warn("RRset '%s' has more than %d records, record ignored",
			rrstr, LOCALZONE_RRSET_COUNT_MAX);
		return 1;
	}
	pd->count++;
	pd->rr_len = regional_alloc(region, sizeof(*pd->rr_len)*pd->count);
	pd->rr_ttl = regional_alloc(region, sizeof(*pd->rr_ttl)*pd->count);
	pd->rr_data = regional_alloc(region, sizeof(*pd->rr_data)*pd->count);
	if(!pd->rr_len || !pd->rr_ttl || !pd->rr_data) {
		log_err("out of memory");
		return 0;
	}
	if(pd->count > 1) {
		memcpy(pd->rr_len+1, oldlen, 
			sizeof(*pd->rr_len)*(pd->count-1));
		memcpy(pd->rr_ttl+1, oldttl, 
			sizeof(*pd->rr_ttl)*(pd->count-1));
		memcpy(pd->rr_data+1, olddata, 
			sizeof(*pd->rr_data)*(pd->count-1));
	}
	pd->rr_len[0] = rdata_len;
	pd->rr_ttl[0] = ttl;
	pd->rr_data[0] = regional_alloc_init(region, rdata, rdata_len);
	if(!pd->rr_data[0]) {
		log_err("out of memory");
		return 0;
	}
	return 1;
}

/** find a data node by exact name */
static struct local_data* 
lz_find_node(struct local_zone* z, uint8_t* nm, size_t nmlen, int nmlabs)
{
	struct local_data key;
	key.node.key = &key;
	key.name = nm;
	key.namelen = nmlen;
	key.namelabs = nmlabs;
	return (struct local_data*)rbtree_search(&z->data, &key.node);
}

/** find a node, create it if not and all its empty nonterminal parents */
static int
lz_find_create_node(struct local_zone* z, uint8_t* nm, size_t nmlen, 
	int nmlabs, struct local_data** res)
{
	struct local_data* ld = lz_find_node(z, nm, nmlen, nmlabs);
	if(!ld) {
		/* create a domain name to store rr. */
		ld = (struct local_data*)regional_alloc_zero(z->region,
			sizeof(*ld));
		if(!ld) {
			log_err("out of memory adding local data");
			return 0;
		}
		ld->node.key = ld;
		ld->name = regional_alloc_init(z->region, nm, nmlen);
		if(!ld->name) {
			log_err("out of memory");
			return 0;
		}
		ld->namelen = nmlen;
		ld->namelabs = nmlabs;
		if(!rbtree_insert(&z->data, &ld->node)) {
			log_assert(0); /* duplicate name */
		}
		/* see if empty nonterminals need to be created */
		if(nmlabs > z->namelabs) {
			dname_remove_label(&nm, &nmlen);
			if(!lz_find_create_node(z, nm, nmlen, nmlabs-1, res))
				return 0;
		}
	}
	*res = ld;
	return 1;
}

/** enter data RR into auth zone */
static int
lz_enter_rr_into_zone(struct local_zone* z, const char* rrstr)
{
	uint8_t* nm;
	size_t nmlen;
	int nmlabs;
	struct local_data* node;
	struct local_rrset* rrset;
	struct packed_rrset_data* pd;
	uint16_t rrtype = 0, rrclass = 0;
	time_t ttl = 0;
	uint8_t rr[LDNS_RR_BUF_SIZE];
	uint8_t* rdata;
	size_t rdata_len;
	if(!rrstr_get_rr_content(rrstr, &nm, &rrtype, &rrclass, &ttl, rr,
		sizeof(rr), &rdata, &rdata_len)) {
		log_err("bad local-data: %s", rrstr);
		return 0;
	}
	log_assert(z->dclass == rrclass);
	if(z->type == local_zone_redirect &&
		query_dname_compare(z->name, nm) != 0) {
		log_err("local-data in redirect zone must reside at top of zone"
			", not at %s", rrstr);
		free(nm);
		return 0;
	}
	nmlabs = dname_count_size_labels(nm, &nmlen);
	if(!lz_find_create_node(z, nm, nmlen, nmlabs, &node)) {
		free(nm);
		return 0;
	}
	log_assert(node);
	free(nm);

	/* Reject it if we would end up having CNAME and other data (including
	 * another CNAME) for a redirect zone. */
	if(z->type == local_zone_redirect && node->rrsets) {
		const char* othertype = NULL;
		if (rrtype == LDNS_RR_TYPE_CNAME)
			othertype = "other";
		else if (node->rrsets->rrset->rk.type ==
			 htons(LDNS_RR_TYPE_CNAME)) {
			othertype = "CNAME";
		}
		if(othertype) {
			log_err("local-data '%s' in redirect zone must not "
				"coexist with %s local-data", rrstr, othertype);
			return 0;
		}
	}
	rrset = local_data_find_type(node, rrtype, 0);
	if(!rrset) {
		rrset = new_local_rrset(z->region, node, rrtype, rrclass);
		if(!rrset)
			return 0;
		if(query_dname_compare(node->name, z->name) == 0) {
			if(rrtype == LDNS_RR_TYPE_NSEC)
			  rrset->rrset->rk.flags = PACKED_RRSET_NSEC_AT_APEX;
			if(rrtype == LDNS_RR_TYPE_SOA)
				z->soa = rrset->rrset;
		}
	} 
	pd = (struct packed_rrset_data*)rrset->rrset->entry.data;
	log_assert(rrset && pd);

	/* check for duplicate RR */
	if(rr_is_duplicate(pd, rdata, rdata_len)) {
		verbose(VERB_ALGO, "ignoring duplicate RR: %s", rrstr);
		return 1;
	} 
	return rrset_insert_rr(z->region, pd, rdata, rdata_len, ttl, rrstr);
}

/** enter a data RR into auth data; a zone for it must exist */
static int
lz_enter_rr_str(struct local_zones* zones, const char* rr)
{
	uint8_t* rr_name;
	uint16_t rr_class, rr_type;
	size_t len;
	int labs;
	struct local_zone* z;
	int r;
	if(!get_rr_nameclass(rr, &rr_name, &rr_class, &rr_type)) {
		log_err("bad rr %s", rr);
		return 0;
	}
	labs = dname_count_size_labels(rr_name, &len);
	lock_rw_rdlock(&zones->lock);
	z = local_zones_lookup(zones, rr_name, len, labs, rr_class, rr_type);
	if(!z) {
		lock_rw_unlock(&zones->lock);
		fatal_exit("internal error: no zone for rr %s", rr);
	}
	lock_rw_wrlock(&z->lock);
	lock_rw_unlock(&zones->lock);
	free(rr_name);
	r = lz_enter_rr_into_zone(z, rr);
	lock_rw_unlock(&z->lock);
	return r;
}

/** enter tagstring into zone */
static int
lz_enter_zone_tag(struct local_zones* zones, char* zname, uint8_t* list,
	size_t len, uint16_t rr_class)
{
	uint8_t dname[LDNS_MAX_DOMAINLEN+1];
	size_t dname_len = sizeof(dname);
	int dname_labs, r = 0;
	struct local_zone* z;

	if(sldns_str2wire_dname_buf(zname, dname, &dname_len) != 0) {
		log_err("cannot parse zone name in local-zone-tag: %s", zname);
		return 0;
	}
	dname_labs = dname_count_labels(dname);
	
	lock_rw_rdlock(&zones->lock);
	z = local_zones_find(zones, dname, dname_len, dname_labs, rr_class);
	if(!z) {
		lock_rw_unlock(&zones->lock);
		log_err("no local-zone for tag %s", zname);
		return 0;
	}
	lock_rw_wrlock(&z->lock);
	lock_rw_unlock(&zones->lock);
	free(z->taglist);
	z->taglist = memdup(list, len);
	z->taglen = len;
	if(z->taglist)
		r = 1;
	lock_rw_unlock(&z->lock);
	return r;
}

/** enter override into zone */
static int
lz_enter_override(struct local_zones* zones, char* zname, char* netblock,
	char* type, uint16_t rr_class)
{
	uint8_t dname[LDNS_MAX_DOMAINLEN+1];
	size_t dname_len = sizeof(dname);
	int dname_labs;
	struct sockaddr_storage addr;
	int net;
	socklen_t addrlen;
	struct local_zone* z;
	enum localzone_type t;

	/* parse zone name */
	if(sldns_str2wire_dname_buf(zname, dname, &dname_len) != 0) {
		log_err("cannot parse zone name in local-zone-override: %s %s",
			zname, netblock);
		return 0;
	}
	dname_labs = dname_count_labels(dname);

	/* parse netblock */
	if(!netblockstrtoaddr(netblock, UNBOUND_DNS_PORT, &addr, &addrlen,
		&net)) {
		log_err("cannot parse netblock in local-zone-override: %s %s",
			zname, netblock);
		return 0;
	}

	/* parse zone type */
	if(!local_zone_str2type(type, &t)) {
		log_err("cannot parse type in local-zone-override: %s %s %s",
			zname, netblock, type);
		return 0;
	}

	/* find localzone entry */
	lock_rw_rdlock(&zones->lock);
	z = local_zones_find(zones, dname, dname_len, dname_labs, rr_class);
	if(!z) {
		lock_rw_unlock(&zones->lock);
		log_err("no local-zone for local-zone-override %s", zname);
		return 0;
	}
	lock_rw_wrlock(&z->lock);
	lock_rw_unlock(&zones->lock);

	/* create netblock addr_tree if not present yet */
	if(!z->override_tree) {
		z->override_tree = (struct rbtree_type*)regional_alloc_zero(
			z->region, sizeof(*z->override_tree));
		if(!z->override_tree) {
			lock_rw_unlock(&z->lock);
			log_err("out of memory");
			return 0;
		}
		addr_tree_init(z->override_tree);
	}
	/* add new elem to tree */
	if(z->override_tree) {
		struct local_zone_override* n;
		n = (struct local_zone_override*)regional_alloc_zero(
			z->region, sizeof(*n));
		if(!n) {
			lock_rw_unlock(&z->lock);
			log_err("out of memory");
			return 0;
		}
		n->type = t;
		if(!addr_tree_insert(z->override_tree,
			(struct addr_tree_node*)n, &addr, addrlen, net)) {
			lock_rw_unlock(&z->lock);
			log_err("duplicate local-zone-override %s %s",
				zname, netblock);
			return 1;
		}
	}

	lock_rw_unlock(&z->lock);
	return 1;
}

/** parse local-zone: statements */
static int
lz_enter_zones(struct local_zones* zones, struct config_file* cfg)
{
	struct config_str2list* p;
	struct local_zone* z;
	for(p = cfg->local_zones; p; p = p->next) {
		if(!(z=lz_enter_zone(zones, p->str, p->str2, 
			LDNS_RR_CLASS_IN)))
			return 0;
		lock_rw_unlock(&z->lock);
	}
	return 1;
}

/** lookup a zone in rbtree; exact match only; SLOW due to parse */
static int
lz_exists(struct local_zones* zones, const char* name)
{
	struct local_zone z;
	z.node.key = &z;
	z.dclass = LDNS_RR_CLASS_IN;
	if(!parse_dname(name, &z.name, &z.namelen, &z.namelabs)) {
		log_err("bad name %s", name);
		return 0;
	}
	lock_rw_rdlock(&zones->lock);
	if(rbtree_search(&zones->ztree, &z.node)) {
		lock_rw_unlock(&zones->lock);
		free(z.name);
		return 1;
	}
	lock_rw_unlock(&zones->lock);
	free(z.name);
	return 0;
}

/** lookup a zone in cfg->nodefault list */
static int
lz_nodefault(struct config_file* cfg, const char* name)
{
	struct config_strlist* p;
	size_t len = strlen(name);
	if(len == 0) return 0;
	if(name[len-1] == '.') len--;

	for(p = cfg->local_zones_nodefault; p; p = p->next) {
		/* compare zone name, lowercase, compare without ending . */
		if(strncasecmp(p->str, name, len) == 0 && 
			(strlen(p->str) == len || (strlen(p->str)==len+1 &&
			p->str[len] == '.')))
			return 1;
	}
	return 0;
}

/** enter (AS112) empty default zone */
static int
add_empty_default(struct local_zones* zones, struct config_file* cfg,
        const char* name)
{
	struct local_zone* z;
	char str[1024]; /* known long enough */
	if(lz_exists(zones, name) || lz_nodefault(cfg, name))
		return 1; /* do not enter default content */
	if(!(z=lz_enter_zone(zones, name, "static", LDNS_RR_CLASS_IN)))
		return 0;
	snprintf(str, sizeof(str), "%s 10800 IN SOA localhost. "
		"nobody.invalid. 1 3600 1200 604800 10800", name);
	if(!lz_enter_rr_into_zone(z, str)) {
		lock_rw_unlock(&z->lock);
		return 0;
	}
	snprintf(str, sizeof(str), "%s 10800 IN NS localhost. ", name);
	if(!lz_enter_rr_into_zone(z, str)) {
		lock_rw_unlock(&z->lock);
		return 0;
	}
	lock_rw_unlock(&z->lock);
	return 1;
}

/** enter default zones */
int local_zone_enter_defaults(struct local_zones* zones, struct config_file* cfg)
{
	struct local_zone* z;
	const char** zstr;

	/* Do not add any default */
	if(cfg->local_zones_disable_default)
		return 1;

	/* this list of zones is from RFC 6303 and RFC 7686 */

	/* block localhost level zones first, then onion and later the LAN zones */

	/* localhost. zone */
	if(!lz_exists(zones, "localhost.") &&
		!lz_nodefault(cfg, "localhost.")) {
		if(!(z=lz_enter_zone(zones, "localhost.", "redirect", 
			LDNS_RR_CLASS_IN)) ||
		   !lz_enter_rr_into_zone(z,
			"localhost. 10800 IN NS localhost.") ||
		   !lz_enter_rr_into_zone(z,
			"localhost. 10800 IN SOA localhost. nobody.invalid. "
			"1 3600 1200 604800 10800") ||
		   !lz_enter_rr_into_zone(z,
			"localhost. 10800 IN A 127.0.0.1") ||
		   !lz_enter_rr_into_zone(z,
			"localhost. 10800 IN AAAA ::1")) {
			log_err("out of memory adding default zone");
			if(z) { lock_rw_unlock(&z->lock); }
			return 0;
		}
		lock_rw_unlock(&z->lock);
	}
	/* reverse ip4 zone */
	if(!lz_exists(zones, "127.in-addr.arpa.") &&
		!lz_nodefault(cfg, "127.in-addr.arpa.")) {
		if(!(z=lz_enter_zone(zones, "127.in-addr.arpa.", "static", 
			LDNS_RR_CLASS_IN)) ||
		   !lz_enter_rr_into_zone(z,
			"127.in-addr.arpa. 10800 IN NS localhost.") ||
		   !lz_enter_rr_into_zone(z,
			"127.in-addr.arpa. 10800 IN SOA localhost. "
			"nobody.invalid. 1 3600 1200 604800 10800") ||
		   !lz_enter_rr_into_zone(z,
			"1.0.0.127.in-addr.arpa. 10800 IN PTR localhost.")) {
			log_err("out of memory adding default zone");
			if(z) { lock_rw_unlock(&z->lock); }
			return 0;
		}
		lock_rw_unlock(&z->lock);
	}
	/* reverse ip6 zone */
	if(!lz_exists(zones, "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.") &&
		!lz_nodefault(cfg, "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.")) {
		if(!(z=lz_enter_zone(zones, "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.", "static", 
			LDNS_RR_CLASS_IN)) ||
		   !lz_enter_rr_into_zone(z,
			"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa. 10800 IN NS localhost.") ||
		   !lz_enter_rr_into_zone(z,
			"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa. 10800 IN SOA localhost. "
			"nobody.invalid. 1 3600 1200 604800 10800") ||
		   !lz_enter_rr_into_zone(z,
			"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa. 10800 IN PTR localhost.")) {
			log_err("out of memory adding default zone");
			if(z) { lock_rw_unlock(&z->lock); }
			return 0;
		}
		lock_rw_unlock(&z->lock);
	}
	/* onion. zone (RFC 7686) */
	if(!add_empty_default(zones, cfg, "onion.")) {
		log_err("out of memory adding default zone");
		return 0;
	}
	/* test. zone (RFC 7686) */
	if(!add_empty_default(zones, cfg, "test.")) {
		log_err("out of memory adding default zone");
		return 0;
	}
	/* invalid. zone (RFC 7686) */
	if(!add_empty_default(zones, cfg, "invalid.")) {
		log_err("out of memory adding default zone");
		return 0;
	}
	/* block AS112 zones, unless asked not to */
	if(!cfg->unblock_lan_zones) {
		for(zstr = as112_zones; *zstr; zstr++) {
			if(!add_empty_default(zones, cfg, *zstr)) {
				log_err("out of memory adding default zone");
				return 0;
			}
		}
	}
	return 1;
}

/** parse local-zone-override: statements */
static int
lz_enter_overrides(struct local_zones* zones, struct config_file* cfg)
{
	struct config_str3list* p;
	for(p = cfg->local_zone_overrides; p; p = p->next) {
		if(!lz_enter_override(zones, p->str, p->str2, p->str3,
			LDNS_RR_CLASS_IN))
			return 0;
	}
	return 1;
}

/** setup parent pointers, so that a lookup can be done for closest match */
static void
init_parents(struct local_zones* zones)
{
        struct local_zone* node, *prev = NULL, *p;
        int m;
	lock_rw_wrlock(&zones->lock);
        RBTREE_FOR(node, struct local_zone*, &zones->ztree) {
		lock_rw_wrlock(&node->lock);
                node->parent = NULL;
                if(!prev || prev->dclass != node->dclass) {
                        prev = node;
			lock_rw_unlock(&node->lock);
                        continue;
                }
                (void)dname_lab_cmp(prev->name, prev->namelabs, node->name,
                        node->namelabs, &m); /* we know prev is smaller */
                /* sort order like: . com. bla.com. zwb.com. net. */
                /* find the previous, or parent-parent-parent */
                for(p = prev; p; p = p->parent)
                        /* looking for name with few labels, a parent */
                        if(p->namelabs <= m) {
                                /* ==: since prev matched m, this is closest*/
                                /* <: prev matches more, but is not a parent,
                                 * this one is a (grand)parent */
                                node->parent = p;
                                break;
                        }
                prev = node;

		if(node->override_tree)
			addr_tree_init_parents(node->override_tree);
		lock_rw_unlock(&node->lock);
        }
	lock_rw_unlock(&zones->lock);
}

/** enter implicit transparent zone for local-data: without local-zone: */
static int
lz_setup_implicit(struct local_zones* zones, struct config_file* cfg)
{
	/* walk over all items that have no parent zone and find
	 * the name that covers them all (could be the root) and
	 * add that as a transparent zone */
	struct config_strlist* p;
	int have_name = 0;
	int have_other_classes = 0;
	uint16_t dclass = 0;
	uint8_t* nm = 0;
	size_t nmlen = 0;
	int nmlabs = 0;
	int match = 0; /* number of labels match count */

	init_parents(zones); /* to enable local_zones_lookup() */
	for(p = cfg->local_data; p; p = p->next) {
		uint8_t* rr_name;
		uint16_t rr_class, rr_type;
		size_t len;
		int labs;
		if(!get_rr_nameclass(p->str, &rr_name, &rr_class, &rr_type)) {
			log_err("Bad local-data RR %s", p->str);
			return 0;
		}
		labs = dname_count_size_labels(rr_name, &len);
		lock_rw_rdlock(&zones->lock);
		if(!local_zones_lookup(zones, rr_name, len, labs, rr_class,
			rr_type)) {
			if(!have_name) {
				dclass = rr_class;
				nm = rr_name;
				nmlen = len;
				nmlabs = labs;
				match = labs;
				have_name = 1;
			} else {
				int m;
				if(rr_class != dclass) {
					/* process other classes later */
					free(rr_name);
					have_other_classes = 1;
					lock_rw_unlock(&zones->lock);
					continue;
				}
				/* find smallest shared topdomain */
				(void)dname_lab_cmp(nm, nmlabs, 
					rr_name, labs, &m);
				free(rr_name);
				if(m < match)
					match = m;
			}
		} else free(rr_name);
		lock_rw_unlock(&zones->lock);
	}
	if(have_name) {
		uint8_t* n2;
		struct local_zone* z;
		/* allocate zone of smallest shared topdomain to contain em */
		n2 = nm;
		dname_remove_labels(&n2, &nmlen, nmlabs - match);
		n2 = memdup(n2, nmlen);
		free(nm);
		if(!n2) {
			log_err("out of memory");
			return 0;
		}
		log_nametypeclass(VERB_ALGO, "implicit transparent local-zone", 
			n2, 0, dclass);
		if(!(z=lz_enter_zone_dname(zones, n2, nmlen, match, 
			local_zone_transparent, dclass))) {
			return 0;
		}
		lock_rw_unlock(&z->lock);
	}
	if(have_other_classes) { 
		/* restart to setup other class */
		return lz_setup_implicit(zones, cfg);
	}
	return 1;
}

/** enter local-zone-tag info */
static int
lz_enter_zone_tags(struct local_zones* zones, struct config_file* cfg)
{
	struct config_strbytelist* p;
	int c = 0;
	for(p = cfg->local_zone_tags; p; p = p->next) {
		if(!lz_enter_zone_tag(zones, p->str, p->str2, p->str2len,
			LDNS_RR_CLASS_IN))
			return 0;
		c++;
	}
	if(c) verbose(VERB_ALGO, "applied tags to %d local zones", c);
	return 1;
}
	
/** enter auth data */
static int
lz_enter_data(struct local_zones* zones, struct config_file* cfg)
{
	struct config_strlist* p;
	for(p = cfg->local_data; p; p = p->next) {
		if(!lz_enter_rr_str(zones, p->str))
			return 0;
	}
	return 1;
}

/** free memory from config */
static void
lz_freeup_cfg(struct config_file* cfg)
{
	config_deldblstrlist(cfg->local_zones);
	cfg->local_zones = NULL;
	config_delstrlist(cfg->local_zones_nodefault);
	cfg->local_zones_nodefault = NULL;
	config_delstrlist(cfg->local_data);
	cfg->local_data = NULL;
}

int 
local_zones_apply_cfg(struct local_zones* zones, struct config_file* cfg)
{
	/* create zones from zone statements. */
	if(!lz_enter_zones(zones, cfg)) {
		return 0;
	}
	/* apply default zones+content (unless disabled, or overridden) */
	if(!local_zone_enter_defaults(zones, cfg)) {
		return 0;
	}
	/* enter local zone overrides */
	if(!lz_enter_overrides(zones, cfg)) {
		return 0;
	}
	/* create implicit transparent zone from data. */
	if(!lz_setup_implicit(zones, cfg)) {
		return 0;
	}

	/* setup parent ptrs for lookup during data entry */
	init_parents(zones);
	/* insert local zone tags */
	if(!lz_enter_zone_tags(zones, cfg)) {
		return 0;
	}
	/* insert local data */
	if(!lz_enter_data(zones, cfg)) {
		return 0;
	}
	/* freeup memory from cfg struct. */
	lz_freeup_cfg(cfg);
	return 1;
}

struct local_zone* 
local_zones_lookup(struct local_zones* zones,
        uint8_t* name, size_t len, int labs, uint16_t dclass, uint16_t dtype)
{
	return local_zones_tags_lookup(zones, name, len, labs,
		dclass, dtype, NULL, 0, 1);
}

struct local_zone* 
local_zones_tags_lookup(struct local_zones* zones,
        uint8_t* name, size_t len, int labs, uint16_t dclass, uint16_t dtype,
	uint8_t* taglist, size_t taglen, int ignoretags)
{
	rbnode_type* res = NULL;
	struct local_zone *result;
	struct local_zone key;
	int m;
	/* for type DS use a zone higher when on a zonecut */
	if(dtype == LDNS_RR_TYPE_DS && !dname_is_root(name)) {
		dname_remove_label(&name, &len);
		labs--;
	}
	key.node.key = &key;
	key.dclass = dclass;
	key.name = name;
	key.namelen = len;
	key.namelabs = labs;
	rbtree_find_less_equal(&zones->ztree, &key, &res);
	result = (struct local_zone*)res;
	/* exact or smaller element (or no element) */
	if(!result || result->dclass != dclass)
		return NULL;
	/* count number of labels matched */
	(void)dname_lab_cmp(result->name, result->namelabs, key.name,
		key.namelabs, &m);
	while(result) { /* go up until qname is zone or subdomain of zone */
		if(result->namelabs <= m)
			if(ignoretags || !result->taglist ||
				taglist_intersect(result->taglist, 
				result->taglen, taglist, taglen))
				break;
		result = result->parent;
	}
	return result;
}

struct local_zone* 
local_zones_find(struct local_zones* zones,
        uint8_t* name, size_t len, int labs, uint16_t dclass)
{
	struct local_zone key;
	key.node.key = &key;
	key.dclass = dclass;
	key.name = name;
	key.namelen = len;
	key.namelabs = labs;
	/* exact */
	return (struct local_zone*)rbtree_search(&zones->ztree, &key);
}

/** print all RRsets in local zone */
static void 
local_zone_out(struct local_zone* z)
{
	struct local_data* d;
	struct local_rrset* p;
	RBTREE_FOR(d, struct local_data*, &z->data) {
		for(p = d->rrsets; p; p = p->next) {
			log_nametypeclass(0, "rrset", d->name, 
				ntohs(p->rrset->rk.type),
				ntohs(p->rrset->rk.rrset_class));
		}
	}
}

void local_zones_print(struct local_zones* zones)
{
	struct local_zone* z;
	lock_rw_rdlock(&zones->lock);
	log_info("number of auth zones %u", (unsigned)zones->ztree.count);
	RBTREE_FOR(z, struct local_zone*, &zones->ztree) {
		lock_rw_rdlock(&z->lock);
		switch(z->type) {
		case local_zone_deny:
			log_nametypeclass(0, "deny zone", 
				z->name, 0, z->dclass);
			break;
		case local_zone_refuse:
			log_nametypeclass(0, "refuse zone", 
				z->name, 0, z->dclass);
			break;
		case local_zone_redirect:
			log_nametypeclass(0, "redirect zone", 
				z->name, 0, z->dclass);
			break;
		case local_zone_transparent:
			log_nametypeclass(0, "transparent zone", 
				z->name, 0, z->dclass);
			break;
		case local_zone_typetransparent:
			log_nametypeclass(0, "typetransparent zone", 
				z->name, 0, z->dclass);
			break;
		case local_zone_static:
			log_nametypeclass(0, "static zone", 
				z->name, 0, z->dclass);
			break;
		case local_zone_inform:
			log_nametypeclass(0, "inform zone", 
				z->name, 0, z->dclass);
			break;
		case local_zone_inform_deny:
			log_nametypeclass(0, "inform_deny zone", 
				z->name, 0, z->dclass);
			break;
		case local_zone_always_transparent:
			log_nametypeclass(0, "always_transparent zone", 
				z->name, 0, z->dclass);
			break;
		case local_zone_always_refuse:
			log_nametypeclass(0, "always_refuse zone", 
				z->name, 0, z->dclass);
			break;
		case local_zone_always_nxdomain:
			log_nametypeclass(0, "always_nxdomain zone", 
				z->name, 0, z->dclass);
			break;
		default:
			log_nametypeclass(0, "badtyped zone", 
				z->name, 0, z->dclass);
			break;
		}
		local_zone_out(z);
		lock_rw_unlock(&z->lock);
	}
	lock_rw_unlock(&zones->lock);
}

/** encode answer consisting of 1 rrset */
static int
local_encode(struct query_info* qinfo, struct module_env* env,
	struct edns_data* edns, sldns_buffer* buf, struct regional* temp,
	struct ub_packed_rrset_key* rrset, int ansec, int rcode)
{
	struct reply_info rep;
	uint16_t udpsize;
	/* make answer with time=0 for fixed TTL values */
	memset(&rep, 0, sizeof(rep));
	rep.flags = (uint16_t)((BIT_QR | BIT_AA | BIT_RA) | rcode);
	rep.qdcount = 1;
	if(ansec)
		rep.an_numrrsets = 1;
	else	rep.ns_numrrsets = 1;
	rep.rrset_count = 1;
	rep.rrsets = &rrset;
	udpsize = edns->udp_size;
	edns->edns_version = EDNS_ADVERTISED_VERSION;
	edns->udp_size = EDNS_ADVERTISED_SIZE;
	edns->ext_rcode = 0;
	edns->bits &= EDNS_DO;
	if(!inplace_cb_reply_local_call(env, qinfo, NULL, &rep, rcode, edns, temp)
		|| !reply_info_answer_encode(qinfo, &rep,
		*(uint16_t*)sldns_buffer_begin(buf),
		sldns_buffer_read_u16_at(buf, 2),
		buf, 0, 0, temp, udpsize, edns,
		(int)(edns->bits&EDNS_DO), 0))
		error_encode(buf, (LDNS_RCODE_SERVFAIL|BIT_AA), qinfo,
			*(uint16_t*)sldns_buffer_begin(buf),
			sldns_buffer_read_u16_at(buf, 2), edns);
	return 1;
}

/** encode local error answer */
static void
local_error_encode(struct query_info* qinfo, struct module_env* env,
	struct edns_data* edns, sldns_buffer* buf, struct regional* temp,
	int rcode, int r)
{
	edns->edns_version = EDNS_ADVERTISED_VERSION;
	edns->udp_size = EDNS_ADVERTISED_SIZE;
	edns->ext_rcode = 0;
	edns->bits &= EDNS_DO;

	if(!inplace_cb_reply_local_call(env, qinfo, NULL, NULL,
		rcode, edns, temp))
		edns->opt_list = NULL;
	error_encode(buf, r, qinfo, *(uint16_t*)sldns_buffer_begin(buf),
		sldns_buffer_read_u16_at(buf, 2), edns);
}

/** find local data tag string match for the given type in the list */
int
local_data_find_tag_datas(const struct query_info* qinfo,
	struct config_strlist* list, struct ub_packed_rrset_key* r,
	struct regional* temp)
{
	struct config_strlist* p;
	char buf[65536];
	uint8_t rr[LDNS_RR_BUF_SIZE];
	size_t len;
	int res;
	struct packed_rrset_data* d;
	for(p=list; p; p=p->next) {
		uint16_t rdr_type;

		len = sizeof(rr);
		/* does this element match the type? */
		snprintf(buf, sizeof(buf), ". %s", p->str);
		res = sldns_str2wire_rr_buf(buf, rr, &len, NULL, 3600,
			NULL, 0, NULL, 0);
		if(res != 0)
			/* parse errors are already checked before, in
			 * acllist check_data, skip this for robustness */
			continue;
		if(len < 1 /* . */ + 8 /* typeclassttl*/ + 2 /*rdatalen*/)
			continue;
		rdr_type = sldns_wirerr_get_type(rr, len, 1);
		if(rdr_type != qinfo->qtype && rdr_type != LDNS_RR_TYPE_CNAME)
			continue;
		
		/* do we have entries already? if not setup key */
		if(r->rk.dname == NULL) {
			r->entry.key = r;
			r->rk.dname = qinfo->qname;
			r->rk.dname_len = qinfo->qname_len;
			r->rk.type = htons(rdr_type);
			r->rk.rrset_class = htons(qinfo->qclass);
			r->rk.flags = 0;
			d = (struct packed_rrset_data*)regional_alloc_zero(
				temp, sizeof(struct packed_rrset_data)
				+ sizeof(size_t) + sizeof(uint8_t*) +
				sizeof(time_t));
			if(!d) return 0; /* out of memory */
			r->entry.data = d;
			d->ttl = sldns_wirerr_get_ttl(rr, len, 1);
			d->rr_len = (size_t*)((uint8_t*)d +
				sizeof(struct packed_rrset_data));
			d->rr_data = (uint8_t**)&(d->rr_len[1]);
			d->rr_ttl = (time_t*)&(d->rr_data[1]);
		}
		d = (struct packed_rrset_data*)r->entry.data;
		/* add entry to the data */
		if(d->count != 0) {
			size_t* oldlen = d->rr_len;
			uint8_t** olddata = d->rr_data;
			time_t* oldttl = d->rr_ttl;
			/* increase arrays for lookup */
			/* this is of course slow for very many records,
			 * but most redirects are expected with few records */
			d->rr_len = (size_t*)regional_alloc_zero(temp,
				(d->count+1)*sizeof(size_t));
			d->rr_data = (uint8_t**)regional_alloc_zero(temp,
				(d->count+1)*sizeof(uint8_t*));
			d->rr_ttl = (time_t*)regional_alloc_zero(temp,
				(d->count+1)*sizeof(time_t));
			if(!d->rr_len || !d->rr_data || !d->rr_ttl)
				return 0; /* out of memory */
			/* first one was allocated after struct d, but new
			 * ones get their own array increment alloc, so
			 * copy old content */
			memmove(d->rr_len, oldlen, d->count*sizeof(size_t));
			memmove(d->rr_data, olddata, d->count*sizeof(uint8_t*));
			memmove(d->rr_ttl, oldttl, d->count*sizeof(time_t));
		}

		d->rr_len[d->count] = sldns_wirerr_get_rdatalen(rr, len, 1)+2;
		d->rr_ttl[d->count] = sldns_wirerr_get_ttl(rr, len, 1);
		d->rr_data[d->count] = regional_alloc_init(temp,
			sldns_wirerr_get_rdatawl(rr, len, 1),
			d->rr_len[d->count]);
		if(!d->rr_data[d->count])
			return 0; /* out of memory */
		d->count++;
	}
	if(r->rk.dname)
		return 1;
	return 0;
}

static int
find_tag_datas(struct query_info* qinfo, struct config_strlist* list,
	struct ub_packed_rrset_key* r, struct regional* temp)
{
	int result = local_data_find_tag_datas(qinfo, list, r, temp);

	/* If we've found a non-exact alias type of local data, make a shallow
	 * copy of the RRset and remember it in qinfo to complete the alias
	 * chain later. */
	if(result && qinfo->qtype != LDNS_RR_TYPE_CNAME &&
		r->rk.type == htons(LDNS_RR_TYPE_CNAME)) {
		qinfo->local_alias =
			regional_alloc_zero(temp, sizeof(struct local_rrset));
		if(!qinfo->local_alias)
			return 0; /* out of memory */
		qinfo->local_alias->rrset =
			regional_alloc_init(temp, r, sizeof(*r));
		if(!qinfo->local_alias->rrset)
			return 0; /* out of memory */
	}
	return result;
}

/** answer local data match */
static int
local_data_answer(struct local_zone* z, struct module_env* env,
	struct query_info* qinfo, struct edns_data* edns, sldns_buffer* buf,
	struct regional* temp, int labs, struct local_data** ldp,
	enum localzone_type lz_type, int tag, struct config_strlist** tag_datas,
	size_t tag_datas_size, char** tagname, int num_tags)
{
	struct local_data key;
	struct local_data* ld;
	struct local_rrset* lr;
	key.node.key = &key;
	key.name = qinfo->qname;
	key.namelen = qinfo->qname_len;
	key.namelabs = labs;
	if(lz_type == local_zone_redirect) {
		key.name = z->name;
		key.namelen = z->namelen;
		key.namelabs = z->namelabs;
		if(tag != -1 && (size_t)tag<tag_datas_size && tag_datas[tag]) {
			struct ub_packed_rrset_key r;
			memset(&r, 0, sizeof(r));
			if(find_tag_datas(qinfo, tag_datas[tag], &r, temp)) {
				verbose(VERB_ALGO, "redirect with tag data [%d] %s",
					tag, (tag<num_tags?tagname[tag]:"null"));

				/* If we found a matching alias, we should
				 * use it as part of the answer, but we can't
				 * encode it until we complete the alias
				 * chain. */
				if(qinfo->local_alias)
					return 1;
				return local_encode(qinfo, env, edns, buf, temp,
					&r, 1, LDNS_RCODE_NOERROR);
			}
		}
	}
	ld = (struct local_data*)rbtree_search(&z->data, &key.node);
	*ldp = ld;
	if(!ld) {
		return 0;
	}
	lr = local_data_find_type(ld, qinfo->qtype, 1);
	if(!lr)
		return 0;

	/* Special case for alias matching.  See local_data_answer(). */
	if(lz_type == local_zone_redirect &&
		qinfo->qtype != LDNS_RR_TYPE_CNAME &&
		lr->rrset->rk.type == htons(LDNS_RR_TYPE_CNAME)) {
		qinfo->local_alias =
			regional_alloc_zero(temp, sizeof(struct local_rrset));
		if(!qinfo->local_alias)
			return 0; /* out of memory */
		qinfo->local_alias->rrset =
			regional_alloc_init(temp, lr->rrset, sizeof(*lr->rrset));
		if(!qinfo->local_alias->rrset)
			return 0; /* out of memory */
		qinfo->local_alias->rrset->rk.dname = qinfo->qname;
		qinfo->local_alias->rrset->rk.dname_len = qinfo->qname_len;
		return 1;
	}
	if(lz_type == local_zone_redirect) {
		/* convert rrset name to query name; like a wildcard */
		struct ub_packed_rrset_key r = *lr->rrset;
		r.rk.dname = qinfo->qname;
		r.rk.dname_len = qinfo->qname_len;
		return local_encode(qinfo, env, edns, buf, temp, &r, 1, 
			LDNS_RCODE_NOERROR);
	}
	return local_encode(qinfo, env, edns, buf, temp, lr->rrset, 1, 
		LDNS_RCODE_NOERROR);
}

/** 
 * answer in case where no exact match is found 
 * @@param z: zone for query
 * @@param env: module environment
 * @@param qinfo: query
 * @@param edns: edns from query
 * @@param buf: buffer for answer.
 * @@param temp: temp region for encoding
 * @@param ld: local data, if NULL, no such name exists in localdata.
 * @@param lz_type: type of the local zone
 * @@return 1 if a reply is to be sent, 0 if not.
 */
static int
lz_zone_answer(struct local_zone* z, struct module_env* env,
	struct query_info* qinfo, struct edns_data* edns, sldns_buffer* buf,
	struct regional* temp, struct local_data* ld, enum localzone_type lz_type)
{
	if(lz_type == local_zone_deny || lz_type == local_zone_inform_deny) {
		/** no reply at all, signal caller by clearing buffer. */
		sldns_buffer_clear(buf);
		sldns_buffer_flip(buf);
		return 1;
	} else if(lz_type == local_zone_refuse
		|| lz_type == local_zone_always_refuse) {
		local_error_encode(qinfo, env, edns, buf, temp,
			LDNS_RCODE_REFUSED, (LDNS_RCODE_REFUSED|BIT_AA));
		return 1;
	} else if(lz_type == local_zone_static ||
		lz_type == local_zone_redirect ||
		lz_type == local_zone_always_nxdomain) {
		/* for static, reply nodata or nxdomain
		 * for redirect, reply nodata */
		/* no additional section processing,
		 * cname, dname or wildcard processing,
		 * or using closest match for NSEC.
		 * or using closest match for returning delegation downwards
		 */
		int rcode = (ld || lz_type == local_zone_redirect)?
			LDNS_RCODE_NOERROR:LDNS_RCODE_NXDOMAIN;
		if(z->soa)
			return local_encode(qinfo, env, edns, buf, temp, 
				z->soa, 0, rcode);
		local_error_encode(qinfo, env, edns, buf, temp, rcode,
			(rcode|BIT_AA));
		return 1;
	} else if(lz_type == local_zone_typetransparent
		|| lz_type == local_zone_always_transparent) {
		/* no NODATA or NXDOMAINS for this zone type */
		return 0;
	}
	/* else lz_type == local_zone_transparent */

	/* if the zone is transparent and the name exists, but the type
	 * does not, then we should make this noerror/nodata */
	if(ld && ld->rrsets) {
		int rcode = LDNS_RCODE_NOERROR;
		if(z->soa)
			return local_encode(qinfo, env, edns, buf, temp, 
				z->soa, 0, rcode);
		local_error_encode(qinfo, env, edns, buf, temp, rcode,
			(rcode|BIT_AA));
		return 1;
	}

	/* stop here, and resolve further on */
	return 0;
}

/** print log information for an inform zone query */
static void
lz_inform_print(struct local_zone* z, struct query_info* qinfo,
	struct comm_reply* repinfo)
{
	char ip[128], txt[512];
	char zname[LDNS_MAX_DOMAINLEN+1];
	uint16_t port = ntohs(((struct sockaddr_in*)&repinfo->addr)->sin_port);
	dname_str(z->name, zname);
	addr_to_str(&repinfo->addr, repinfo->addrlen, ip, sizeof(ip));
	snprintf(txt, sizeof(txt), "%s inform %s@@%u", zname, ip,
		(unsigned)port);
	log_nametypeclass(0, txt, qinfo->qname, qinfo->qtype, qinfo->qclass);
}

static enum localzone_type
lz_type(uint8_t *taglist, size_t taglen, uint8_t *taglist2, size_t taglen2,
	uint8_t *tagactions, size_t tagactionssize, enum localzone_type lzt,
	struct comm_reply* repinfo, struct rbtree_type* override_tree,
	int* tag, char** tagname, int num_tags)
{
	struct local_zone_override* lzo;	
	if(repinfo && override_tree) {
		lzo = (struct local_zone_override*)addr_tree_lookup(
			override_tree, &repinfo->addr, repinfo->addrlen);
		if(lzo && lzo->type) {
			verbose(VERB_ALGO, "local zone override to type %s",
				local_zone_type2str(lzo->type));
			return lzo->type;
		}
	}
	if(!taglist || !taglist2)
		return lzt;
	return local_data_find_tag_action(taglist, taglen, taglist2, taglen2,
		tagactions, tagactionssize, lzt, tag, tagname, num_tags);
}

enum localzone_type
local_data_find_tag_action(const uint8_t* taglist, size_t taglen,
	const uint8_t* taglist2, size_t taglen2, const uint8_t* tagactions,
	size_t tagactionssize, enum localzone_type lzt, int* tag,
	char* const* tagname, int num_tags)
{
	size_t i, j;
	uint8_t tagmatch;

	for(i=0; i<taglen && i<taglen2; i++) {
		tagmatch = (taglist[i] & taglist2[i]);
		for(j=0; j<8 && tagmatch>0; j++) {
			if((tagmatch & 0x1)) {
				*tag = (int)(i*8+j);
				verbose(VERB_ALGO, "matched tag [%d] %s",
					*tag, (*tag<num_tags?tagname[*tag]:"null"));
				/* does this tag have a tag action? */
				if(i*8+j < tagactionssize && tagactions
				   && tagactions[i*8+j] != 0) {
				  verbose(VERB_ALGO, "tag action [%d] %s to type %s",
					*tag, (*tag<num_tags?tagname[*tag]:"null"),
				  	local_zone_type2str(
					(enum localzone_type)
					tagactions[i*8+j]));
				  return (enum localzone_type)tagactions[i*8+j];
				}
				return lzt;
			}
			tagmatch >>= 1;	
		}
	}
	return lzt;
}

int 
local_zones_answer(struct local_zones* zones, struct module_env* env,
	struct query_info* qinfo, struct edns_data* edns, sldns_buffer* buf,
	struct regional* temp, struct comm_reply* repinfo, uint8_t* taglist,
	size_t taglen, uint8_t* tagactions, size_t tagactionssize,
	struct config_strlist** tag_datas, size_t tag_datas_size,
	char** tagname, int num_tags, struct view* view)
{
	/* see if query is covered by a zone,
	 * 	if so:	- try to match (exact) local data 
	 * 		- look at zone type for negative response. */
	int labs = dname_count_labels(qinfo->qname);
	struct local_data* ld = NULL;
	struct local_zone* z = NULL;
	enum localzone_type lzt = local_zone_transparent;
	int r, tag = -1;

	if(view) {
		lock_rw_rdlock(&view->lock);
		if(view->local_zones &&
			(z = local_zones_lookup(view->local_zones,
			qinfo->qname, qinfo->qname_len, labs,
			qinfo->qclass, qinfo->qtype))) {
			verbose(VERB_ALGO, 
				"using localzone from view: %s", 
				view->name);
			lock_rw_rdlock(&z->lock);
			lzt = z->type;
		}
		if(view->local_zones && !z && !view->isfirst){
			lock_rw_unlock(&view->lock);
			return 0;
		}
		lock_rw_unlock(&view->lock);
	}
	if(!z) {
		/* try global local_zones tree */
		lock_rw_rdlock(&zones->lock);
		if(!(z = local_zones_tags_lookup(zones, qinfo->qname,
			qinfo->qname_len, labs, qinfo->qclass, qinfo->qtype,
			taglist, taglen, 0))) {
			lock_rw_unlock(&zones->lock);
			return 0;
		}
		lock_rw_rdlock(&z->lock);

		lzt = lz_type(taglist, taglen, z->taglist, z->taglen,
			tagactions, tagactionssize, z->type, repinfo,
			z->override_tree, &tag, tagname, num_tags);
		lock_rw_unlock(&zones->lock);
	}
	if((lzt == local_zone_inform || lzt == local_zone_inform_deny)
		&& repinfo)
		lz_inform_print(z, qinfo, repinfo);

	if(lzt != local_zone_always_refuse
		&& lzt != local_zone_always_transparent
		&& lzt != local_zone_always_nxdomain
		&& local_data_answer(z, env, qinfo, edns, buf, temp, labs, &ld, lzt,
			tag, tag_datas, tag_datas_size, tagname, num_tags)) {
		lock_rw_unlock(&z->lock);
		/* We should tell the caller that encode is deferred if we found
		 * a local alias. */
		return !qinfo->local_alias;
	}
	r = lz_zone_answer(z, env, qinfo, edns, buf, temp, ld, lzt);
	lock_rw_unlock(&z->lock);
	return r && !qinfo->local_alias; /* see above */
}

const char* local_zone_type2str(enum localzone_type t)
{
	switch(t) {
		case local_zone_unset: return "unset";
		case local_zone_deny: return "deny";
		case local_zone_refuse: return "refuse";
		case local_zone_redirect: return "redirect";
		case local_zone_transparent: return "transparent";
		case local_zone_typetransparent: return "typetransparent";
		case local_zone_static: return "static";
		case local_zone_nodefault: return "nodefault";
		case local_zone_inform: return "inform";
		case local_zone_inform_deny: return "inform_deny";
		case local_zone_always_transparent: return "always_transparent";
		case local_zone_always_refuse: return "always_refuse";
		case local_zone_always_nxdomain: return "always_nxdomain";
	}
	return "badtyped"; 
}

int local_zone_str2type(const char* type, enum localzone_type* t)
{
	if(strcmp(type, "deny") == 0)
		*t = local_zone_deny;
	else if(strcmp(type, "refuse") == 0)
		*t = local_zone_refuse;
	else if(strcmp(type, "static") == 0)
		*t = local_zone_static;
	else if(strcmp(type, "transparent") == 0)
		*t = local_zone_transparent;
	else if(strcmp(type, "typetransparent") == 0)
		*t = local_zone_typetransparent;
	else if(strcmp(type, "redirect") == 0)
		*t = local_zone_redirect;
	else if(strcmp(type, "inform") == 0)
		*t = local_zone_inform;
	else if(strcmp(type, "inform_deny") == 0)
		*t = local_zone_inform_deny;
	else if(strcmp(type, "always_transparent") == 0)
		*t = local_zone_always_transparent;
	else if(strcmp(type, "always_refuse") == 0)
		*t = local_zone_always_refuse;
	else if(strcmp(type, "always_nxdomain") == 0)
		*t = local_zone_always_nxdomain;
	else if(strcmp(type, "nodefault") == 0)
		*t = local_zone_nodefault;
	else return 0;
	return 1;
}

/** iterate over the kiddies of the given name and set their parent ptr */
static void
set_kiddo_parents(struct local_zone* z, struct local_zone* match, 
	struct local_zone* newp)
{
	/* both zones and z are locked already */
	/* in the sorted rbtree, the kiddies of z are located after z */
	/* z must be present in the tree */
	struct local_zone* p = z;
	p = (struct local_zone*)rbtree_next(&p->node);
	while(p!=(struct local_zone*)RBTREE_NULL &&
		p->dclass == z->dclass && dname_strict_subdomain(p->name,
		p->namelabs, z->name, z->namelabs)) {
		/* update parent ptr */
		/* only when matches with existing parent pointer, so that
		 * deeper child structures are not touched, i.e.
		 * update of x, and a.x, b.x, f.b.x, g.b.x, c.x, y
		 * gets to update a.x, b.x and c.x */
		lock_rw_wrlock(&p->lock);
		if(p->parent == match)
			p->parent = newp;
		lock_rw_unlock(&p->lock);
		p = (struct local_zone*)rbtree_next(&p->node);
	}
}

struct local_zone* local_zones_add_zone(struct local_zones* zones,
	uint8_t* name, size_t len, int labs, uint16_t dclass,
	enum localzone_type tp)
{
	/* create */
	struct local_zone* z = local_zone_create(name, len, labs, tp, dclass);
	if(!z) {
		free(name);
		return NULL;
	}
	lock_rw_wrlock(&z->lock);

	/* find the closest parent */
	z->parent = local_zones_find(zones, name, len, labs, dclass);

	/* insert into the tree */
	if(!rbtree_insert(&zones->ztree, &z->node)) {
		/* duplicate entry! */
		lock_rw_unlock(&z->lock);
		local_zone_delete(z);
		log_err("internal: duplicate entry in local_zones_add_zone");
		return NULL;
	}

	/* set parent pointers right */
	set_kiddo_parents(z, z->parent, z);

	lock_rw_unlock(&z->lock);
	return z;
}

void local_zones_del_zone(struct local_zones* zones, struct local_zone* z)
{
	/* fix up parents in tree */
	lock_rw_wrlock(&z->lock);
	set_kiddo_parents(z, z, z->parent);

	/* remove from tree */
	(void)rbtree_delete(&zones->ztree, z);

	/* delete the zone */
	lock_rw_unlock(&z->lock);
	local_zone_delete(z);
}

int
local_zones_add_RR(struct local_zones* zones, const char* rr)
{
	uint8_t* rr_name;
	uint16_t rr_class, rr_type;
	size_t len;
	int labs;
	struct local_zone* z;
	int r;
	if(!get_rr_nameclass(rr, &rr_name, &rr_class, &rr_type)) {
		return 0;
	}
	labs = dname_count_size_labels(rr_name, &len);
	/* could first try readlock then get writelock if zone does not exist,
	 * but we do not add enough RRs (from multiple threads) to optimize */
	lock_rw_wrlock(&zones->lock);
	z = local_zones_lookup(zones, rr_name, len, labs, rr_class, rr_type);
	if(!z) {
		z = local_zones_add_zone(zones, rr_name, len, labs, rr_class,
			local_zone_transparent);
		if(!z) {
			lock_rw_unlock(&zones->lock);
			return 0;
		}
	} else {
		free(rr_name);
	}
	lock_rw_wrlock(&z->lock);
	lock_rw_unlock(&zones->lock);
	r = lz_enter_rr_into_zone(z, rr);
	lock_rw_unlock(&z->lock);
	return r;
}

/** returns true if the node is terminal so no deeper domain names exist */
static int
is_terminal(struct local_data* d)
{
	/* for empty nonterminals, the deeper domain names are sorted
	 * right after them, so simply check the next name in the tree 
	 */
	struct local_data* n = (struct local_data*)rbtree_next(&d->node);
	if(n == (struct local_data*)RBTREE_NULL)
		return 1; /* last in tree, no deeper node */
	if(dname_strict_subdomain(n->name, n->namelabs, d->name, d->namelabs))
		return 0; /* there is a deeper node */
	return 1;
}

/** delete empty terminals from tree when final data is deleted */
static void 
del_empty_term(struct local_zone* z, struct local_data* d, 
	uint8_t* name, size_t len, int labs)
{
	while(d && d->rrsets == NULL && is_terminal(d)) {
		/* is this empty nonterminal? delete */
		/* note, no memory recycling in zone region */
		(void)rbtree_delete(&z->data, d);

		/* go up and to the next label */
		if(dname_is_root(name))
			return;
		dname_remove_label(&name, &len);
		labs--;
		d = lz_find_node(z, name, len, labs);
	}
}

/** find and remove type from list in domain struct */
static void
del_local_rrset(struct local_data* d, uint16_t dtype)
{
	struct local_rrset* prev=NULL, *p=d->rrsets;
	while(p && ntohs(p->rrset->rk.type) != dtype) {
		prev = p;
		p = p->next;
	}
	if(!p) 
		return; /* rrset type not found */
	/* unlink it */
	if(prev) prev->next = p->next;
	else d->rrsets = p->next;
	/* no memory recycling for zone deletions ... */
}

void local_zones_del_data(struct local_zones* zones, 
	uint8_t* name, size_t len, int labs, uint16_t dclass)
{
	/* find zone */
	struct local_zone* z;
	struct local_data* d;

	/* remove DS */
	lock_rw_rdlock(&zones->lock);
	z = local_zones_lookup(zones, name, len, labs, dclass, LDNS_RR_TYPE_DS);
	if(z) {
		lock_rw_wrlock(&z->lock);
		d = lz_find_node(z, name, len, labs);
		if(d) {
			del_local_rrset(d, LDNS_RR_TYPE_DS);
			del_empty_term(z, d, name, len, labs);
		}
		lock_rw_unlock(&z->lock);
	}
	lock_rw_unlock(&zones->lock);

	/* remove other types */
	lock_rw_rdlock(&zones->lock);
	z = local_zones_lookup(zones, name, len, labs, dclass, 0);
	if(!z) {
		/* no such zone, we're done */
		lock_rw_unlock(&zones->lock);
		return;
	}
	lock_rw_wrlock(&z->lock);
	lock_rw_unlock(&zones->lock);

	/* find the domain */
	d = lz_find_node(z, name, len, labs);
	if(d) {
		/* no memory recycling for zone deletions ... */
		d->rrsets = NULL;
		/* did we delete the soa record ? */
		if(query_dname_compare(d->name, z->name) == 0)
			z->soa = NULL;

		/* cleanup the empty nonterminals for this name */
		del_empty_term(z, d, name, len, labs);
	}

	lock_rw_unlock(&z->lock);
}
@


1.5
log
@update to unbound 1.6.4, ok florian@@
@
text
@d263 2
a264 1
get_rr_nameclass(const char* str, uint8_t** nm, uint16_t* dclass)
d278 1
d527 1
a527 1
	uint16_t rr_class;
d532 1
a532 1
	if(!get_rr_nameclass(rr, &rr_name, &rr_class)) {
d538 1
a538 1
	z = local_zones_lookup(zones, rr_name, len, labs, rr_class);
d724 1
a724 1
/** enter AS112 default zone */
d726 1
a726 1
add_as112_default(struct local_zones* zones, struct config_file* cfg,
d767 1
a767 1
		if(!(z=lz_enter_zone(zones, "localhost.", "static", 
d821 13
a833 14
	if(!lz_exists(zones, "onion.") &&
		!lz_nodefault(cfg, "onion.")) {
		if(!(z=lz_enter_zone(zones, "onion.", "static", 
			LDNS_RR_CLASS_IN)) ||
		   !lz_enter_rr_into_zone(z,
			"onion. 10800 IN NS localhost.") ||
		   !lz_enter_rr_into_zone(z,
			"onion. 10800 IN SOA localhost. nobody.invalid. "
			"1 3600 1200 604800 10800")) {
			log_err("out of memory adding default zone");
			if(z) { lock_rw_unlock(&z->lock); }
			return 0;
		}
		lock_rw_unlock(&z->lock);
a834 1

d838 1
a838 1
			if(!add_as112_default(zones, cfg, *zstr)) {
d916 1
a916 1
		uint16_t rr_class;
d919 1
a919 1
		if(!get_rr_nameclass(p->str, &rr_name, &rr_class)) {
d925 2
a926 1
		if(!local_zones_lookup(zones, rr_name, len, labs, rr_class)) {
d1057 1
a1057 1
        uint8_t* name, size_t len, int labs, uint16_t dclass)
d1060 1
a1060 1
		dclass, NULL, 0, 1);
d1065 1
a1065 1
        uint8_t* name, size_t len, int labs, uint16_t dclass,
d1072 5
d1592 1
a1592 1
			qinfo->qclass))) {
d1609 2
a1610 2
			qinfo->qname_len, labs, qinfo->qclass, taglist,
			taglen, 0))) {
d1765 1
a1765 1
	uint16_t rr_class;
d1770 1
a1770 1
	if(!get_rr_nameclass(rr, &rr_name, &rr_class)) {
d1777 1
a1777 1
	z = local_zones_lookup(zones, rr_name, len, labs, rr_class);
d1829 17
d1852 16
d1869 1
a1869 1
	z = local_zones_lookup(zones, name, len, labs, dclass);
@


1.4
log
@Update to unbound-1.6.1rc3 - thanks millert@@ and Brad for tests.
@
text
@d190 3
a192 1
		log_warn("duplicate local-zone");
d234 2
a235 3
/** return name and class and rdata of rr; parses string */
static int
get_rr_content(const char* str, uint8_t** nm, uint16_t* type,
d357 2
a358 2
static int
insert_rr(struct regional* region, struct packed_rrset_data* pd,
d460 2
a461 2
	if(!get_rr_content(rrstr, &nm, &rrtype, &rrclass, &ttl, rr, sizeof(rr),
		&rdata, &rdata_len)) {
d517 1
a517 1
	return insert_rr(z->region, pd, rdata, rdata_len, ttl, rrstr);
d749 1
a749 2
static int
lz_enter_defaults(struct local_zones* zones, struct config_file* cfg)
d754 4
d1027 1
a1027 1
	if(!lz_enter_defaults(zones, cfg)) {
d1240 4
a1243 3
static int
find_tag_datas(struct query_info* qinfo, struct config_strlist* list,
	struct ub_packed_rrset_key* r, struct regional* temp)
d1320 1
a1320 1
			if(!d) return 0; /* out of memory */
d1323 11
d1337 1
a1337 1
	if(r->rk.dname && qinfo->qtype != LDNS_RR_TYPE_CNAME &&
d1348 1
a1348 3
	if(r->rk.dname)
		return 1;
	return 0;
a1513 2
	size_t i, j;
	uint8_t tagmatch;
d1526 13
d1593 1
a1593 1
		if(!z && !view->isfirst){
d1678 2
@


1.3
log
@update to unbound-1.5.9. (there will be a follow-up commit to cherrypick a
couple of post-1.5.9 patches).

tests from Mark Patruck, danj, matthieu, millert. reads ok to jung, ok florian.
@
text
@d55 5
d77 1
a77 1
lzdel(rbnode_t* n, void* ATTR_UNUSED(arg))
d162 1
a162 1
	z->region = regional_create();
d168 1
a168 1
	lock_protect(&z->lock, &z->parent, sizeof(*z)-sizeof(rbnode_t));
d189 1
d192 6
a197 1
		local_zone_delete(z);
d199 2
a200 1
		return NULL;
d287 2
d292 1
a292 1
local_data_find_type(struct local_data* data, uint16_t type)
d299 2
d358 1
a358 1
	uint8_t* rdata, size_t rdata_len, time_t ttl)
d365 5
d480 17
a496 1
	rrset = local_data_find_type(node, rrtype);
d516 1
a516 1
	return insert_rr(z->region, pd, rdata, rdata_len, ttl);
d565 1
a565 1
	z = local_zones_lookup(zones, dname, dname_len, dname_labs, rr_class);
d582 83
d843 13
d885 3
d1026 4
d1054 10
a1063 1
	rbnode_t* res = NULL;
d1066 1
d1072 15
a1086 18
	if(rbtree_find_less_equal(&zones->ztree, &key, &res)) {
		/* exact */
		return (struct local_zone*)res;
	} else {
	        /* smaller element (or no element) */
                int m;
                result = (struct local_zone*)res;
                if(!result || result->dclass != dclass)
                        return NULL;
                /* count number of labels matched */
                (void)dname_lab_cmp(result->name, result->namelabs, key.name,
                        key.namelabs, &m);
                while(result) { /* go up until qname is subdomain of zone */
                        if(result->namelabs <= m)
                                break;
                        result = result->parent;
                }
		return result;
d1088 1
d1160 12
d1185 2
a1186 2
local_encode(struct query_info* qinfo, struct edns_data* edns, 
	sldns_buffer* buf, struct regional* temp, 
d1205 2
a1206 2
	if(!edns_opt_inplace_reply(edns, temp) ||
	   !reply_info_answer_encode(qinfo, &rep, 
d1209 1
a1209 1
		buf, 0, 0, temp, udpsize, edns, 
d1213 1
a1213 1
		       sldns_buffer_read_u16_at(buf, 2), edns);
d1217 120
d1339 5
a1343 3
local_data_answer(struct local_zone* z, struct query_info* qinfo,
	struct edns_data* edns, sldns_buffer* buf, struct regional* temp,
	int labs, struct local_data** ldp)
d1352 1
a1352 1
	if(z->type == local_zone_redirect) {
d1356 17
d1379 1
a1379 1
	lr = local_data_find_type(ld, qinfo->qtype);
d1382 18
a1399 1
	if(z->type == local_zone_redirect) {
d1404 1
a1404 1
		return local_encode(qinfo, edns, buf, temp, &r, 1, 
d1407 1
a1407 1
	return local_encode(qinfo, edns, buf, temp, lr->rrset, 1, 
d1414 1
d1420 1
d1424 3
a1426 3
lz_zone_answer(struct local_zone* z, struct query_info* qinfo,
	struct edns_data* edns, sldns_buffer* buf, struct regional* temp,
	struct local_data* ld)
d1428 1
a1428 1
	if(z->type == local_zone_deny || z->type == local_zone_inform_deny) {
d1433 4
a1436 4
	} else if(z->type == local_zone_refuse) {
		error_encode(buf, (LDNS_RCODE_REFUSED|BIT_AA), qinfo,
			*(uint16_t*)sldns_buffer_begin(buf),
		       sldns_buffer_read_u16_at(buf, 2), edns);
d1438 3
a1440 2
	} else if(z->type == local_zone_static ||
		z->type == local_zone_redirect) {
d1448 2
a1449 1
		int rcode = ld?LDNS_RCODE_NOERROR:LDNS_RCODE_NXDOMAIN;
d1451 1
a1451 1
			return local_encode(qinfo, edns, buf, temp, 
d1453 2
a1454 3
		error_encode(buf, (rcode|BIT_AA), qinfo, 
			*(uint16_t*)sldns_buffer_begin(buf), 
			sldns_buffer_read_u16_at(buf, 2), edns);
d1456 2
a1457 1
	} else if(z->type == local_zone_typetransparent) {
d1461 1
a1461 1
	/* else z->type == local_zone_transparent */
d1468 1
a1468 1
			return local_encode(qinfo, edns, buf, temp, 
d1470 2
a1471 3
		error_encode(buf, (rcode|BIT_AA), qinfo, 
			*(uint16_t*)sldns_buffer_begin(buf), 
			sldns_buffer_read_u16_at(buf, 2), edns);
d1494 45
d1540 6
a1545 3
local_zones_answer(struct local_zones* zones, struct query_info* qinfo,
	struct edns_data* edns, sldns_buffer* buf, struct regional* temp,
	struct comm_reply* repinfo)
d1551 23
a1573 6
	struct local_data* ld;
	struct local_zone* z;
	int r;
	lock_rw_rdlock(&zones->lock);
	z = local_zones_lookup(zones, qinfo->qname,
		qinfo->qname_len, labs, qinfo->qclass);
d1575 13
a1588 1
		return 0;
d1590 1
a1590 4
	lock_rw_rdlock(&z->lock);
	lock_rw_unlock(&zones->lock);

	if((z->type == local_zone_inform || z->type == local_zone_inform_deny)
d1594 5
a1598 1
	if(local_data_answer(z, qinfo, edns, buf, temp, labs, &ld)) {
d1600 3
a1602 1
		return 1;
d1604 1
a1604 1
	r = lz_zone_answer(z, qinfo, edns, buf, temp, ld);
d1606 1
a1606 1
	return r;
d1612 1
d1622 3
d1647 6
@


1.2
log
@update to unbound 1.5.8, ok florian@@ jung@@
@
text
@d97 1
d175 1
d511 34
d839 16
d897 4
d1045 2
a1046 1
	if(!reply_info_answer_encode(qinfo, &rep, 
d1280 4
a1283 1
	if(!z) return NULL;
@


1.1
log
@Initial revision
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
a41 2
#include <ldns/dname.h>
#include <ldns/host2wire.h>
d43 2
d51 1
d54 1
d64 1
a64 1
	lock_quick_init(&zones->lock);
d83 1
a83 1
	lock_quick_destroy(&zones->lock);
d130 1
a130 3
	ldns_rdf* rdf;
	*res = NULL;
	*len = 0;
d132 1
a132 2
	rdf = ldns_dname_new_frm_str(str);
	if(!rdf) {
a135 6
	*res = memdup(ldns_rdf_data(rdf), ldns_rdf_size(rdf));
	ldns_rdf_deep_free(rdf);
	if(!*res) {
		log_err("out of memory");
		return 0;
	}
d179 1
a179 1
	lock_quick_lock(&zones->lock);
d185 1
a185 1
		lock_quick_unlock(&zones->lock);
d188 1
a188 1
	lock_quick_unlock(&zones->lock);
d221 2
a222 1
	uint16_t* dclass, uint32_t* ttl, ldns_buffer* rdata)
d224 7
a230 6
	ldns_rr* rr = NULL;
	ldns_status status = ldns_rr_new_frm_str(&rr, str, 3600, NULL, NULL);
	if(status != LDNS_STATUS_OK) {
		log_err("error parsing local-data '%s': %s",
			str, ldns_get_errorstr_by_id(status));
		ldns_rr_free(rr);
d233 1
a233 2
	*nm = memdup(ldns_rdf_data(ldns_rr_owner(rr)), 
		ldns_rdf_size(ldns_rr_owner(rr)));
a235 1
		ldns_rr_free(rr);
d238 5
a242 16
	*dclass = ldns_rr_get_class(rr);
	*type = ldns_rr_get_type(rr);
	*ttl = (uint32_t)ldns_rr_ttl(rr);
	ldns_buffer_clear(rdata);
	ldns_buffer_skip(rdata, 2);
	status = ldns_rr_rdata2buffer_wire(rdata, rr);
	ldns_rr_free(rr);
        if(status != LDNS_STATUS_OK) {
                log_err("error converting RR '%s' to wireformat: %s",
                        str, ldns_get_errorstr_by_id(status));
		free(*nm);
		*nm = NULL;
                return 0;
        }
        ldns_buffer_flip(rdata);
        ldns_buffer_write_u16_at(rdata, 0, ldns_buffer_limit(rdata) - 2);
d250 8
a257 6
	ldns_rr* rr = NULL;
	ldns_status status = ldns_rr_new_frm_str(&rr, str, 3600, NULL, NULL);
	if(status != LDNS_STATUS_OK) {
		log_err("error parsing local-data '%s': %s",
			str, ldns_get_errorstr_by_id(status));
		ldns_rr_free(rr);
d260 2
a261 4
	*nm = memdup(ldns_rdf_data(ldns_rr_owner(rr)), 
		ldns_rdf_size(ldns_rr_owner(rr)));
	*dclass = ldns_rr_get_class(rr);
	ldns_rr_free(rr);
d289 1
a289 1
rr_is_duplicate(struct packed_rrset_data* pd, ldns_buffer* buf)
d293 2
a294 3
		if(ldns_buffer_limit(buf) == pd->rr_len[i] &&
			memcmp(ldns_buffer_begin(buf), pd->rr_data[i],
				ldns_buffer_limit(buf)) == 0) 
d340 1
a340 1
	ldns_buffer* buf, uint32_t ttl)
d343 1
a343 1
	uint32_t* oldttl = pd->rr_ttl;
d363 1
a363 1
	pd->rr_len[0] = ldns_buffer_limit(buf);
d365 1
a365 2
	pd->rr_data[0] = regional_alloc_init(region,
		ldns_buffer_begin(buf), ldns_buffer_limit(buf));
d423 1
a423 2
lz_enter_rr_into_zone(struct local_zone* z, ldns_buffer* buf,
	const char* rrstr)
d431 7
a437 3
	uint16_t rrtype, rrclass;
	uint32_t ttl;
	if(!get_rr_content(rrstr, &nm, &rrtype, &rrclass, &ttl, buf)) {
d473 1
a473 1
	if(rr_is_duplicate(pd, buf)) {
d477 1
a477 1
	return insert_rr(z->region, pd, buf, ttl);
d482 1
a482 1
lz_enter_rr_str(struct local_zones* zones, const char* rr, ldns_buffer* buf)
d495 1
a495 1
	lock_quick_lock(&zones->lock);
d498 1
a498 1
		lock_quick_unlock(&zones->lock);
d502 1
a502 1
	lock_quick_unlock(&zones->lock);
d504 1
a504 1
	r = lz_enter_rr_into_zone(z, buf, rr);
d535 1
a535 1
	lock_quick_lock(&zones->lock);
d537 1
a537 1
		lock_quick_unlock(&zones->lock);
d541 1
a541 1
	lock_quick_unlock(&zones->lock);
d568 1
a568 1
        ldns_buffer* buf, const char* name)
d578 1
a578 1
	if(!lz_enter_rr_into_zone(z, buf, str)) {
d583 1
a583 1
	if(!lz_enter_rr_into_zone(z, buf, str)) {
d593 1
a593 2
lz_enter_defaults(struct local_zones* zones, struct config_file* cfg,
	ldns_buffer* buf)
d596 1
d598 3
a600 1
	/* this list of zones is from RFC 6303 */
d607 1
a607 1
		   !lz_enter_rr_into_zone(z, buf,
d609 1
a609 1
		   !lz_enter_rr_into_zone(z, buf,
d612 1
a612 1
		   !lz_enter_rr_into_zone(z, buf,
d614 1
a614 1
		   !lz_enter_rr_into_zone(z, buf,
d627 1
a627 1
		   !lz_enter_rr_into_zone(z, buf,
d629 1
a629 1
		   !lz_enter_rr_into_zone(z, buf,
d632 1
a632 1
		   !lz_enter_rr_into_zone(z, buf,
d645 1
a645 1
		   !lz_enter_rr_into_zone(z, buf,
d647 1
a647 1
		   !lz_enter_rr_into_zone(z, buf,
d650 1
a650 1
		   !lz_enter_rr_into_zone(z, buf,
d658 25
a682 33
	if (	!add_as112_default(zones, cfg, buf, "10.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "16.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "17.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "18.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "19.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "20.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "21.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "22.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "23.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "24.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "25.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "26.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "27.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "28.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "29.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "30.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "31.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "168.192.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "0.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "254.169.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "2.0.192.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "100.51.198.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "113.0.203.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "255.255.255.255.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, buf, "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.") ||
		!add_as112_default(zones, cfg, buf, "d.f.ip6.arpa.") ||
		!add_as112_default(zones, cfg, buf, "8.e.f.ip6.arpa.") ||
		!add_as112_default(zones, cfg, buf, "9.e.f.ip6.arpa.") ||
		!add_as112_default(zones, cfg, buf, "a.e.f.ip6.arpa.") ||
		!add_as112_default(zones, cfg, buf, "b.e.f.ip6.arpa.") ||
		!add_as112_default(zones, cfg, buf, "8.b.d.0.1.0.0.2.ip6.arpa.")) {
		log_err("out of memory adding default zone");
		return 0;
d693 1
a693 1
	lock_quick_lock(&zones->lock);
d718 1
a718 1
	lock_quick_unlock(&zones->lock);
d748 1
a748 1
		lock_quick_lock(&zones->lock);
d763 1
a763 1
					lock_quick_unlock(&zones->lock);
d774 1
a774 1
		lock_quick_unlock(&zones->lock);
d805 1
a805 2
lz_enter_data(struct local_zones* zones, struct config_file* cfg,
	ldns_buffer* buf)
d809 1
a809 1
		if(!lz_enter_rr_str(zones, p->str, buf))
a829 3
	ldns_buffer* buf = ldns_buffer_new(65535);
	if(!buf) fatal_exit("cannot create temporary buffer");

a831 1
		ldns_buffer_free(buf);
d835 1
a835 2
	if(!lz_enter_defaults(zones, cfg, buf)) {
		ldns_buffer_free(buf);
a839 1
		ldns_buffer_free(buf);
d846 1
a846 2
	if(!lz_enter_data(zones, cfg, buf)) {
		ldns_buffer_free(buf);
a850 1
	ldns_buffer_free(buf);
d919 1
a919 1
	lock_quick_lock(&zones->lock);
d948 8
d964 1
a964 1
	lock_quick_unlock(&zones->lock);
d970 1
a970 1
	ldns_buffer* buf, struct regional* temp, 
d990 2
a991 2
		*(uint16_t*)ldns_buffer_begin(buf),
		ldns_buffer_read_u16_at(buf, 2),
d995 2
a996 2
			*(uint16_t*)ldns_buffer_begin(buf),
		       ldns_buffer_read_u16_at(buf, 2), edns);
d1003 1
a1003 1
	struct edns_data* edns, ldns_buffer* buf, struct regional* temp,
d1050 1
a1050 1
	struct edns_data* edns, ldns_buffer* buf, struct regional* temp,
d1053 1
a1053 1
	if(z->type == local_zone_deny) {
d1055 2
a1056 2
		ldns_buffer_clear(buf);
		ldns_buffer_flip(buf);
d1060 2
a1061 2
			*(uint16_t*)ldns_buffer_begin(buf),
		       ldns_buffer_read_u16_at(buf, 2), edns);
d1077 2
a1078 2
			*(uint16_t*)ldns_buffer_begin(buf), 
			ldns_buffer_read_u16_at(buf, 2), edns);
d1094 2
a1095 2
			*(uint16_t*)ldns_buffer_begin(buf), 
			ldns_buffer_read_u16_at(buf, 2), edns);
d1103 15
d1120 2
a1121 1
	struct edns_data* edns, ldns_buffer* buf, struct regional* temp)
d1130 1
a1130 1
	lock_quick_lock(&zones->lock);
d1134 1
a1134 1
		lock_quick_unlock(&zones->lock);
d1138 5
a1142 1
	lock_quick_unlock(&zones->lock);
d1163 2
d1183 4
d1260 1
a1260 1
local_zones_add_RR(struct local_zones* zones, const char* rr, ldns_buffer* buf)
d1272 3
a1274 1
	lock_quick_lock(&zones->lock);
d1280 1
a1280 1
			lock_quick_unlock(&zones->lock);
d1287 2
a1288 2
	lock_quick_unlock(&zones->lock);
	r = lz_enter_rr_into_zone(z, buf, rr);
d1333 1
a1333 1
	lock_quick_lock(&zones->lock);
d1337 1
a1337 1
		lock_quick_unlock(&zones->lock);
d1341 1
a1341 1
	lock_quick_unlock(&zones->lock);
@


1.1.1.1
log
@Import Unbound 1.4.16 to work on in-tree (not yet linked to the build).

These are the direct sources from NLnet Labs upstream, minus these:
compat contrib libunbound/python pythonmod testcode testdata winrc

ok deraadt@@ jakob@@
@
text
@@


1.1.1.2
log
@update to Unbound 1.4.21, ok brad@@
@
text
@d228 1
a228 1
	uint16_t* dclass, time_t* ttl, ldns_buffer* rdata)
d247 1
a247 1
	*ttl = (time_t)ldns_rr_ttl(rr);
d359 1
a359 1
	ldns_buffer* buf, time_t ttl)
d362 1
a362 1
	time_t* oldttl = pd->rr_ttl;
d452 2
a453 2
	uint16_t rrtype = 0, rrclass = 0;
	time_t ttl = 0;
@


1.1.1.3
log
@import unbound 1.4.22 upstream sources, ok brad@@
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d42 2
a44 2
#include "ldns/str2wire.h"
#include "ldns/sbuffer.h"
d62 1
a62 1
	lock_rw_init(&zones->lock);
d81 1
a81 1
	lock_rw_destroy(&zones->lock);
d128 3
a130 1
	*res = sldns_str2wire_dname(str, len);
d132 7
d140 1
a140 1
		log_err("cannot parse name %s", str);
d186 1
a186 1
	lock_rw_wrlock(&zones->lock);
d192 1
a192 1
		lock_rw_unlock(&zones->lock);
d195 1
a195 1
	lock_rw_unlock(&zones->lock);
d228 1
a228 2
	uint16_t* dclass, time_t* ttl, uint8_t* rr, size_t len,
	uint8_t** rdata, size_t* rdata_len)
d230 6
a235 7
	size_t dname_len = 0;
	int e = sldns_str2wire_rr_buf(str, rr, &len, &dname_len, 3600,
		NULL, 0, NULL, 0);
	if(e) {
		log_err("error parsing local-data at %d: '%s': %s",
			LDNS_WIREPARSE_OFFSET(e), str,
			sldns_get_errorstr_parse(e));
d238 2
a239 1
	*nm = memdup(rr, dname_len);
d242 1
d245 16
a260 5
	*dclass = sldns_wirerr_get_class(rr, len, dname_len);
	*type = sldns_wirerr_get_type(rr, len, dname_len);
	*ttl = (time_t)sldns_wirerr_get_ttl(rr, len, dname_len);
	*rdata = sldns_wirerr_get_rdatawl(rr, len, dname_len);
	*rdata_len = sldns_wirerr_get_rdatalen(rr, len, dname_len)+2;
d268 6
a273 8
	uint8_t rr[LDNS_RR_BUF_SIZE];
	size_t len = sizeof(rr), dname_len = 0;
	int s = sldns_str2wire_rr_buf(str, rr, &len, &dname_len, 3600,
		NULL, 0, NULL, 0);
	if(s != 0) {
		log_err("error parsing local-data at %d '%s': %s",
			LDNS_WIREPARSE_OFFSET(s), str,
			sldns_get_errorstr_parse(s));
d276 4
a279 2
	*nm = memdup(rr, dname_len);
	*dclass = sldns_wirerr_get_class(rr, len, dname_len);
d307 1
a307 1
rr_is_duplicate(struct packed_rrset_data* pd, uint8_t* rdata, size_t rdata_len)
d311 3
a313 2
		if(pd->rr_len[i] == rdata_len &&
			memcmp(pd->rr_data[i], rdata, rdata_len) == 0)
d359 1
a359 1
	uint8_t* rdata, size_t rdata_len, time_t ttl)
d382 1
a382 1
	pd->rr_len[0] = rdata_len;
d384 2
a385 1
	pd->rr_data[0] = regional_alloc_init(region, rdata, rdata_len);
d443 2
a444 1
lz_enter_rr_into_zone(struct local_zone* z, const char* rrstr)
d454 1
a454 5
	uint8_t rr[LDNS_RR_BUF_SIZE];
	uint8_t* rdata;
	size_t rdata_len;
	if(!get_rr_content(rrstr, &nm, &rrtype, &rrclass, &ttl, rr, sizeof(rr),
		&rdata, &rdata_len)) {
d490 1
a490 1
	if(rr_is_duplicate(pd, rdata, rdata_len)) {
d494 1
a494 1
	return insert_rr(z->region, pd, rdata, rdata_len, ttl);
d499 1
a499 1
lz_enter_rr_str(struct local_zones* zones, const char* rr)
d512 1
a512 1
	lock_rw_rdlock(&zones->lock);
d515 1
a515 1
		lock_rw_unlock(&zones->lock);
d519 1
a519 1
	lock_rw_unlock(&zones->lock);
d521 1
a521 1
	r = lz_enter_rr_into_zone(z, rr);
d552 1
a552 1
	lock_rw_rdlock(&zones->lock);
d554 1
a554 1
		lock_rw_unlock(&zones->lock);
d558 1
a558 1
	lock_rw_unlock(&zones->lock);
d585 1
a585 1
        const char* name)
d595 1
a595 1
	if(!lz_enter_rr_into_zone(z, str)) {
d600 1
a600 1
	if(!lz_enter_rr_into_zone(z, str)) {
d610 2
a611 1
lz_enter_defaults(struct local_zones* zones, struct config_file* cfg)
d622 1
a622 1
		   !lz_enter_rr_into_zone(z,
d624 1
a624 1
		   !lz_enter_rr_into_zone(z,
d627 1
a627 1
		   !lz_enter_rr_into_zone(z,
d629 1
a629 1
		   !lz_enter_rr_into_zone(z,
d642 1
a642 1
		   !lz_enter_rr_into_zone(z,
d644 1
a644 1
		   !lz_enter_rr_into_zone(z,
d647 1
a647 1
		   !lz_enter_rr_into_zone(z,
d660 1
a660 1
		   !lz_enter_rr_into_zone(z,
d662 1
a662 1
		   !lz_enter_rr_into_zone(z,
d665 1
a665 1
		   !lz_enter_rr_into_zone(z,
d673 31
a703 31
	if (	!add_as112_default(zones, cfg, "10.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "16.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "17.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "18.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "19.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "20.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "21.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "22.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "23.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "24.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "25.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "26.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "27.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "28.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "29.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "30.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "31.172.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "168.192.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "0.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "254.169.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "2.0.192.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "100.51.198.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "113.0.203.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "255.255.255.255.in-addr.arpa.") ||
		!add_as112_default(zones, cfg, "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.") ||
		!add_as112_default(zones, cfg, "d.f.ip6.arpa.") ||
		!add_as112_default(zones, cfg, "8.e.f.ip6.arpa.") ||
		!add_as112_default(zones, cfg, "9.e.f.ip6.arpa.") ||
		!add_as112_default(zones, cfg, "a.e.f.ip6.arpa.") ||
		!add_as112_default(zones, cfg, "b.e.f.ip6.arpa.") ||
		!add_as112_default(zones, cfg, "8.b.d.0.1.0.0.2.ip6.arpa.")) {
d716 1
a716 1
	lock_rw_wrlock(&zones->lock);
d741 1
a741 1
	lock_rw_unlock(&zones->lock);
d771 1
a771 1
		lock_rw_rdlock(&zones->lock);
d786 1
a786 1
					lock_rw_unlock(&zones->lock);
d797 1
a797 1
		lock_rw_unlock(&zones->lock);
d828 2
a829 1
lz_enter_data(struct local_zones* zones, struct config_file* cfg)
d833 1
a833 1
		if(!lz_enter_rr_str(zones, p->str))
d854 3
d859 1
d863 2
a864 1
	if(!lz_enter_defaults(zones, cfg)) {
d869 1
d876 2
a877 1
	if(!lz_enter_data(zones, cfg)) {
d882 1
d951 1
a951 1
	lock_rw_rdlock(&zones->lock);
d988 1
a988 1
	lock_rw_unlock(&zones->lock);
d994 1
a994 1
	sldns_buffer* buf, struct regional* temp, 
d1014 2
a1015 2
		*(uint16_t*)sldns_buffer_begin(buf),
		sldns_buffer_read_u16_at(buf, 2),
d1019 2
a1020 2
			*(uint16_t*)sldns_buffer_begin(buf),
		       sldns_buffer_read_u16_at(buf, 2), edns);
d1027 1
a1027 1
	struct edns_data* edns, sldns_buffer* buf, struct regional* temp,
d1074 1
a1074 1
	struct edns_data* edns, sldns_buffer* buf, struct regional* temp,
d1079 2
a1080 2
		sldns_buffer_clear(buf);
		sldns_buffer_flip(buf);
d1084 2
a1085 2
			*(uint16_t*)sldns_buffer_begin(buf),
		       sldns_buffer_read_u16_at(buf, 2), edns);
d1101 2
a1102 2
			*(uint16_t*)sldns_buffer_begin(buf), 
			sldns_buffer_read_u16_at(buf, 2), edns);
d1118 2
a1119 2
			*(uint16_t*)sldns_buffer_begin(buf), 
			sldns_buffer_read_u16_at(buf, 2), edns);
d1129 1
a1129 1
	struct edns_data* edns, sldns_buffer* buf, struct regional* temp)
d1138 1
a1138 1
	lock_rw_rdlock(&zones->lock);
d1142 1
a1142 1
		lock_rw_unlock(&zones->lock);
d1146 1
a1146 1
	lock_rw_unlock(&zones->lock);
d1258 1
a1258 1
local_zones_add_RR(struct local_zones* zones, const char* rr)
d1270 1
a1270 3
	/* could first try readlock then get writelock if zone does not exist,
	 * but we do not add enough RRs (from multiple threads) to optimize */
	lock_rw_wrlock(&zones->lock);
d1276 1
a1276 1
			lock_rw_unlock(&zones->lock);
d1283 2
a1284 2
	lock_rw_unlock(&zones->lock);
	r = lz_enter_rr_into_zone(z, rr);
d1329 1
a1329 1
	lock_rw_rdlock(&zones->lock);
d1333 1
a1333 1
		lock_rw_unlock(&zones->lock);
d1337 1
a1337 1
	lock_rw_unlock(&zones->lock);
@


1.1.1.4
log
@update to Unbound 1.5.0, ok sthen@@
@
text
@a596 2
	/* block localhost level zones, first, later the LAN zones */

a652 8

	/* if unblock lan-zones, then do not add the zones below.
	 * we do add the zones above, about 127.0.0.1, because localhost is
	 * not on the lan. */
	if(cfg->unblock_lan_zones)
		return 1;

	/* block LAN level zones */
a671 64
		!add_as112_default(zones, cfg, "64.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "65.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "66.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "67.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "68.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "69.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "70.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "71.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "72.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "73.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "74.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "75.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "76.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "77.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "78.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "79.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "80.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "81.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "82.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "83.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "84.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "85.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "86.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "87.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "88.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "89.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "90.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "91.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "92.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "93.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "94.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "95.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "96.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "97.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "98.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "99.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "100.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "101.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "102.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "103.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "104.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "105.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "106.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "107.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "108.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "109.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "110.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "111.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "112.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "113.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "114.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "115.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "116.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "117.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "118.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "119.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "120.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "121.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "122.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "123.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "124.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "125.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "126.100.in-addr.arpa.") ||
      		!add_as112_default(zones, cfg, "127.100.in-addr.arpa.") ||
@


1.1.1.5
log
@Update to unbound 1.5.2rc1, ok brad@@
@
text
@a50 1
#include "util/netevent.h"
a1024 4
		case local_zone_inform:
			log_nametypeclass(0, "inform zone", 
				z->name, 0, z->dclass);
			break;
a1171 15
/** print log information for an inform zone query */
static void
lz_inform_print(struct local_zone* z, struct query_info* qinfo,
	struct comm_reply* repinfo)
{
	char ip[128], txt[512];
	char zname[LDNS_MAX_DOMAINLEN+1];
	uint16_t port = ntohs(((struct sockaddr_in*)&repinfo->addr)->sin_port);
	dname_str(z->name, zname);
	addr_to_str(&repinfo->addr, repinfo->addrlen, ip, sizeof(ip));
	snprintf(txt, sizeof(txt), "%s inform %s@@%u", zname, ip,
		(unsigned)port);
	log_nametypeclass(0, txt, qinfo->qname, qinfo->qtype, qinfo->qclass);
}

d1174 1
a1174 2
	struct edns_data* edns, sldns_buffer* buf, struct regional* temp,
	struct comm_reply* repinfo)
a1192 3
	if(z->type == local_zone_inform && repinfo)
		lz_inform_print(z, qinfo, repinfo);

a1211 1
		case local_zone_inform: return "inform";
a1229 2
	else if(strcmp(type, "inform") == 0)
		*t = local_zone_inform;
@


1.1.1.6
log
@update to Unbound 1.5.4, ok florian@@, looks sane deraadt@@
@
text
@d43 2
a44 2
#include "sldns/str2wire.h"
#include "sldns/sbuffer.h"
a1029 4
		case local_zone_inform_deny:
			log_nametypeclass(0, "inform_deny zone", 
				z->name, 0, z->dclass);
			break;
d1127 1
a1127 1
	if(z->type == local_zone_deny || z->type == local_zone_inform_deny) {
d1214 1
a1214 2
	if((z->type == local_zone_inform || z->type == local_zone_inform_deny)
		&& repinfo)
a1236 1
		case local_zone_inform_deny: return "inform_deny";
a1256 2
	else if(strcmp(type, "inform_deny") == 0)
		*t = local_zone_inform_deny;
@


