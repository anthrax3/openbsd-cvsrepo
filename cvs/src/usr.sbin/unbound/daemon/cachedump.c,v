head	1.4;
access;
symbols
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.4
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.3.0.6
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3
	UNBOUND_1_5_4:1.1.1.8
	OPENBSD_5_7:1.2.0.4
	OPENBSD_5_7_BASE:1.2
	UNBOUND_1_5_2RC1:1.1.1.7
	UNBOUND_1_5_1:1.1.1.7
	UNBOUND_1_5_0:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	UNBOUND_1_4_22:1.1.1.5
	OPENBSD_5_5:1.1.1.4.0.4
	OPENBSD_5_5_BASE:1.1.1.4
	UNBOUND_1_4_21:1.1.1.4
	OPENBSD_5_4:1.1.1.3.0.4
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.2
	OPENBSD_5_3_BASE:1.1.1.3
	UNBOUND_1_4_18:1.1.1.3
	UNBOUND_1_4_17:1.1.1.2
	OPENBSD_5_2:1.1.1.1.0.2
	OPENBSD_5_2_BASE:1.1.1.1
	UNBOUND_1_4_16:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2017.02.17.18.53.32;	author sthen;	state Exp;
branches;
next	1.3;
commitid	R6rMbeA8TNhmzWB4;

1.3
date	2015.07.16.01.44.00;	author sthen;	state Exp;
branches;
next	1.2;
commitid	kSPbvR6QMA7Gz7zd;

1.2
date	2014.11.20.01.15.19;	author brad;	state Exp;
branches;
next	1.1;
commitid	5B1rQYSaYoW2Vhmb;

1.1
date	2012.03.26.18.05.44;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.03.26.18.05.44;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.08.23.22.36.17;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.08.23.22.56.33;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.22.11.31.20;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.16.11.38.28;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.20.00.00.38;	author brad;	state Exp;
branches;
next	1.1.1.7;
commitid	bB36RwIVwTq8fGsI;

1.1.1.7
date	2014.12.11.16.18.15;	author brad;	state Exp;
branches;
next	1.1.1.8;
commitid	fGLTsCVGImGBxGUi;

1.1.1.8
date	2015.07.16.01.42.20;	author sthen;	state Exp;
branches;
next	;
commitid	kEVXcRu8XDMmCd6c;


desc
@@


1.4
log
@Update to unbound-1.6.1rc3 - thanks millert@@ and Brad for tests.
@
text
@/*
 * daemon/cachedump.c - dump the cache to text format.
 *
 * Copyright (c) 2008, NLnet Labs. All rights reserved.
 *
 * This software is open source.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * Neither the name of the NLNET LABS nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * \file
 *
 * This file contains functions to read and write the cache(s)
 * to text format.
 */
#include "config.h"
#include <openssl/ssl.h>
#include "daemon/cachedump.h"
#include "daemon/remote.h"
#include "daemon/worker.h"
#include "services/cache/rrset.h"
#include "services/cache/dns.h"
#include "services/cache/infra.h"
#include "util/data/msgreply.h"
#include "util/regional.h"
#include "util/net_help.h"
#include "util/data/dname.h"
#include "iterator/iterator.h"
#include "iterator/iter_delegpt.h"
#include "iterator/iter_utils.h"
#include "iterator/iter_fwd.h"
#include "iterator/iter_hints.h"
#include "sldns/sbuffer.h"
#include "sldns/wire2str.h"
#include "sldns/str2wire.h"

/** dump one rrset zonefile line */
static int
dump_rrset_line(SSL* ssl, struct ub_packed_rrset_key* k, time_t now, size_t i)
{
	char s[65535];
	if(!packed_rr_to_string(k, i, now, s, sizeof(s))) {
		return ssl_printf(ssl, "BADRR\n");
	}
	return ssl_printf(ssl, "%s", s);
}

/** dump rrset key and data info */
static int
dump_rrset(SSL* ssl, struct ub_packed_rrset_key* k, 
	struct packed_rrset_data* d, time_t now)
{
	size_t i;
	/* rd lock held by caller */
	if(!k || !d) return 1;
	if(d->ttl < now) return 1; /* expired */

	/* meta line */
	if(!ssl_printf(ssl, ";rrset%s " ARG_LL "d %u %u %d %d\n",
		(k->rk.flags & PACKED_RRSET_NSEC_AT_APEX)?" nsec_apex":"",
		(long long)(d->ttl - now),
		(unsigned)d->count, (unsigned)d->rrsig_count,
		(int)d->trust, (int)d->security
		)) 
		return 0;
	for(i=0; i<d->count + d->rrsig_count; i++) {
		if(!dump_rrset_line(ssl, k, now, i))
			return 0;
	}
	return 1;
}

/** dump lruhash rrset cache */
static int
dump_rrset_lruhash(SSL* ssl, struct lruhash* h, time_t now)
{
	struct lruhash_entry* e;
	/* lruhash already locked by caller */
	/* walk in order of lru; best first */
	for(e=h->lru_start; e; e = e->lru_next) {
		lock_rw_rdlock(&e->lock);
		if(!dump_rrset(ssl, (struct ub_packed_rrset_key*)e->key,
			(struct packed_rrset_data*)e->data, now)) {
			lock_rw_unlock(&e->lock);
			return 0;
		}
		lock_rw_unlock(&e->lock);
	}
	return 1;
}

/** dump rrset cache */
static int
dump_rrset_cache(SSL* ssl, struct worker* worker)
{
	struct rrset_cache* r = worker->env.rrset_cache;
	size_t slab;
	if(!ssl_printf(ssl, "START_RRSET_CACHE\n")) return 0;
	for(slab=0; slab<r->table.size; slab++) {
		lock_quick_lock(&r->table.array[slab]->lock);
		if(!dump_rrset_lruhash(ssl, r->table.array[slab],
			*worker->env.now)) {
			lock_quick_unlock(&r->table.array[slab]->lock);
			return 0;
		}
		lock_quick_unlock(&r->table.array[slab]->lock);
	}
	return ssl_printf(ssl, "END_RRSET_CACHE\n");
}

/** dump message to rrset reference */
static int
dump_msg_ref(SSL* ssl, struct ub_packed_rrset_key* k)
{
	char* nm, *tp, *cl;
	nm = sldns_wire2str_dname(k->rk.dname, k->rk.dname_len);
	tp = sldns_wire2str_type(ntohs(k->rk.type));
	cl = sldns_wire2str_class(ntohs(k->rk.rrset_class));
	if(!nm || !cl || !tp) {
		free(nm);
		free(tp);
		free(cl);
		return ssl_printf(ssl, "BADREF\n");
	}
	if(!ssl_printf(ssl, "%s %s %s %d\n", nm, cl, tp, (int)k->rk.flags)) {
		free(nm);
		free(tp);
		free(cl);
		return 0;
	}
	free(nm);
	free(tp);
	free(cl);

	return 1;
}

/** dump message entry */
static int
dump_msg(SSL* ssl, struct query_info* k, struct reply_info* d, 
	time_t now)
{
	size_t i;
	char* nm, *tp, *cl;
	if(!k || !d) return 1;
	if(d->ttl < now) return 1; /* expired */
	
	nm = sldns_wire2str_dname(k->qname, k->qname_len);
	tp = sldns_wire2str_type(k->qtype);
	cl = sldns_wire2str_class(k->qclass);
	if(!nm || !tp || !cl) {
		free(nm);
		free(tp);
		free(cl);
		return 1; /* skip this entry */
	}
	if(!rrset_array_lock(d->ref, d->rrset_count, now)) {
		/* rrsets have timed out or do not exist */
		free(nm);
		free(tp);
		free(cl);
		return 1; /* skip this entry */
	}
	
	/* meta line */
	if(!ssl_printf(ssl, "msg %s %s %s %d %d " ARG_LL "d %d %u %u %u\n",
			nm, cl, tp,
			(int)d->flags, (int)d->qdcount, 
			(long long)(d->ttl-now), (int)d->security,
			(unsigned)d->an_numrrsets, 
			(unsigned)d->ns_numrrsets,
			(unsigned)d->ar_numrrsets)) {
		free(nm);
		free(tp);
		free(cl);
		rrset_array_unlock(d->ref, d->rrset_count);
		return 0;
	}
	free(nm);
	free(tp);
	free(cl);
	
	for(i=0; i<d->rrset_count; i++) {
		if(!dump_msg_ref(ssl, d->rrsets[i])) {
			rrset_array_unlock(d->ref, d->rrset_count);
			return 0;
		}
	}
	rrset_array_unlock(d->ref, d->rrset_count);

	return 1;
}

/** copy msg to worker pad */
static int
copy_msg(struct regional* region, struct lruhash_entry* e, 
	struct query_info** k, struct reply_info** d)
{
	struct reply_info* rep = (struct reply_info*)e->data;
	if(rep->rrset_count > RR_COUNT_MAX)
		return 0; /* to protect against integer overflow */
	*d = (struct reply_info*)regional_alloc_init(region, e->data,
		sizeof(struct reply_info) + 
		sizeof(struct rrset_ref) * (rep->rrset_count-1) +
		sizeof(struct ub_packed_rrset_key*) * rep->rrset_count);
	if(!*d)
		return 0;
	(*d)->rrsets = (struct ub_packed_rrset_key**)(void *)(
		(uint8_t*)(&((*d)->ref[0])) + 
		sizeof(struct rrset_ref) * rep->rrset_count);
	*k = (struct query_info*)regional_alloc_init(region, 
		e->key, sizeof(struct query_info));
	if(!*k)
		return 0;
	(*k)->qname = regional_alloc_init(region, 
		(*k)->qname, (*k)->qname_len);
	return (*k)->qname != NULL;
}

/** dump lruhash msg cache */
static int
dump_msg_lruhash(SSL* ssl, struct worker* worker, struct lruhash* h)
{
	struct lruhash_entry* e;
	struct query_info* k;
	struct reply_info* d;

	/* lruhash already locked by caller */
	/* walk in order of lru; best first */
	for(e=h->lru_start; e; e = e->lru_next) {
		regional_free_all(worker->scratchpad);
		lock_rw_rdlock(&e->lock);
		/* make copy of rrset in worker buffer */
		if(!copy_msg(worker->scratchpad, e, &k, &d)) {
			lock_rw_unlock(&e->lock);
			return 0;
		}
		lock_rw_unlock(&e->lock);
		/* release lock so we can lookup the rrset references 
		 * in the rrset cache */
		if(!dump_msg(ssl, k, d, *worker->env.now)) {
			return 0;
		}
	}
	return 1;
}

/** dump msg cache */
static int
dump_msg_cache(SSL* ssl, struct worker* worker)
{
	struct slabhash* sh = worker->env.msg_cache;
	size_t slab;
	if(!ssl_printf(ssl, "START_MSG_CACHE\n")) return 0;
	for(slab=0; slab<sh->size; slab++) {
		lock_quick_lock(&sh->array[slab]->lock);
		if(!dump_msg_lruhash(ssl, worker, sh->array[slab])) {
			lock_quick_unlock(&sh->array[slab]->lock);
			return 0;
		}
		lock_quick_unlock(&sh->array[slab]->lock);
	}
	return ssl_printf(ssl, "END_MSG_CACHE\n");
}

int
dump_cache(SSL* ssl, struct worker* worker)
{
	if(!dump_rrset_cache(ssl, worker))
		return 0;
	if(!dump_msg_cache(ssl, worker))
		return 0;
	return ssl_printf(ssl, "EOF\n");
}

/** read a line from ssl into buffer */
static int
ssl_read_buf(SSL* ssl, sldns_buffer* buf)
{
	return ssl_read_line(ssl, (char*)sldns_buffer_begin(buf), 
		sldns_buffer_capacity(buf));
}

/** check fixed text on line */
static int
read_fixed(SSL* ssl, sldns_buffer* buf, const char* str)
{
	if(!ssl_read_buf(ssl, buf)) return 0;
	return (strcmp((char*)sldns_buffer_begin(buf), str) == 0);
}

/** load an RR into rrset */
static int
load_rr(SSL* ssl, sldns_buffer* buf, struct regional* region,
	struct ub_packed_rrset_key* rk, struct packed_rrset_data* d,
	unsigned int i, int is_rrsig, int* go_on, time_t now)
{
	uint8_t rr[LDNS_RR_BUF_SIZE];
	size_t rr_len = sizeof(rr), dname_len = 0;
	int status;

	/* read the line */
	if(!ssl_read_buf(ssl, buf))
		return 0;
	if(strncmp((char*)sldns_buffer_begin(buf), "BADRR\n", 6) == 0) {
		*go_on = 0;
		return 1;
	}
	status = sldns_str2wire_rr_buf((char*)sldns_buffer_begin(buf), rr,
		&rr_len, &dname_len, 3600, NULL, 0, NULL, 0);
	if(status != 0) {
		log_warn("error cannot parse rr: %s: %s",
			sldns_get_errorstr_parse(status),
			(char*)sldns_buffer_begin(buf));
		return 0;
	}
	if(is_rrsig && sldns_wirerr_get_type(rr, rr_len, dname_len)
		!= LDNS_RR_TYPE_RRSIG) {
		log_warn("error expected rrsig but got %s",
			(char*)sldns_buffer_begin(buf));
		return 0;
	}

	/* convert ldns rr into packed_rr */
	d->rr_ttl[i] = (time_t)sldns_wirerr_get_ttl(rr, rr_len, dname_len) + now;
	sldns_buffer_clear(buf);
	d->rr_len[i] = sldns_wirerr_get_rdatalen(rr, rr_len, dname_len)+2;
	d->rr_data[i] = (uint8_t*)regional_alloc_init(region, 
		sldns_wirerr_get_rdatawl(rr, rr_len, dname_len), d->rr_len[i]);
	if(!d->rr_data[i]) {
		log_warn("error out of memory");
		return 0;
	}

	/* if first entry, fill the key structure */
	if(i==0) {
		rk->rk.type = htons(sldns_wirerr_get_type(rr, rr_len, dname_len));
		rk->rk.rrset_class = htons(sldns_wirerr_get_class(rr, rr_len, dname_len));
		rk->rk.dname_len = dname_len;
		rk->rk.dname = regional_alloc_init(region, rr, dname_len);
		if(!rk->rk.dname) {
			log_warn("error out of memory");
			return 0;
		}
	}

	return 1;
}

/** move entry into cache */
static int
move_into_cache(struct ub_packed_rrset_key* k, 
	struct packed_rrset_data* d, struct worker* worker)
{
	struct ub_packed_rrset_key* ak;
	struct packed_rrset_data* ad;
	size_t s, i, num = d->count + d->rrsig_count;
	struct rrset_ref ref;
	uint8_t* p;

	ak = alloc_special_obtain(&worker->alloc);
	if(!ak) {
		log_warn("error out of memory");
		return 0;
	}
	ak->entry.data = NULL;
	ak->rk = k->rk;
	ak->entry.hash = rrset_key_hash(&k->rk);
	ak->rk.dname = (uint8_t*)memdup(k->rk.dname, k->rk.dname_len);
	if(!ak->rk.dname) {
		log_warn("error out of memory");
		ub_packed_rrset_parsedelete(ak, &worker->alloc);
		return 0;
	}
	s = sizeof(*ad) + (sizeof(size_t) + sizeof(uint8_t*) + 
		sizeof(time_t))* num;
	for(i=0; i<num; i++)
		s += d->rr_len[i];
	ad = (struct packed_rrset_data*)malloc(s);
	if(!ad) {
		log_warn("error out of memory");
		ub_packed_rrset_parsedelete(ak, &worker->alloc);
		return 0;
	}
	p = (uint8_t*)ad;
	memmove(p, d, sizeof(*ad));
	p += sizeof(*ad);
	memmove(p, &d->rr_len[0], sizeof(size_t)*num);
	p += sizeof(size_t)*num;
	memmove(p, &d->rr_data[0], sizeof(uint8_t*)*num);
	p += sizeof(uint8_t*)*num;
	memmove(p, &d->rr_ttl[0], sizeof(time_t)*num);
	p += sizeof(time_t)*num;
	for(i=0; i<num; i++) {
		memmove(p, d->rr_data[i], d->rr_len[i]);
		p += d->rr_len[i];
	}
	packed_rrset_ptr_fixup(ad);

	ak->entry.data = ad;

	ref.key = ak;
	ref.id = ak->id;
	(void)rrset_cache_update(worker->env.rrset_cache, &ref,
		&worker->alloc, *worker->env.now);
	return 1;
}

/** load an rrset entry */
static int
load_rrset(SSL* ssl, sldns_buffer* buf, struct worker* worker)
{
	char* s = (char*)sldns_buffer_begin(buf);
	struct regional* region = worker->scratchpad;
	struct ub_packed_rrset_key* rk;
	struct packed_rrset_data* d;
	unsigned int rr_count, rrsig_count, trust, security;
	long long ttl;
	unsigned int i;
	int go_on = 1;
	regional_free_all(region);

	rk = (struct ub_packed_rrset_key*)regional_alloc_zero(region, 
		sizeof(*rk));
	d = (struct packed_rrset_data*)regional_alloc_zero(region, sizeof(*d));
	if(!rk || !d) {
		log_warn("error out of memory");
		return 0;
	}

	if(strncmp(s, ";rrset", 6) != 0) {
		log_warn("error expected ';rrset' but got %s", s);
		return 0;
	}
	s += 6;
	if(strncmp(s, " nsec_apex", 10) == 0) {
		s += 10;
		rk->rk.flags |= PACKED_RRSET_NSEC_AT_APEX;
	}
	if(sscanf(s, " " ARG_LL "d %u %u %u %u", &ttl, &rr_count, &rrsig_count,
		&trust, &security) != 5) {
		log_warn("error bad rrset spec %s", s);
		return 0;
	}
	if(rr_count == 0 && rrsig_count == 0) {
		log_warn("bad rrset without contents");
		return 0;
	}
	if(rr_count > RR_COUNT_MAX || rrsig_count > RR_COUNT_MAX) {
		log_warn("bad rrset with too many rrs");
		return 0;
	}
	d->count = (size_t)rr_count;
	d->rrsig_count = (size_t)rrsig_count;
	d->security = (enum sec_status)security;
	d->trust = (enum rrset_trust)trust;
	d->ttl = (time_t)ttl + *worker->env.now;

	d->rr_len = regional_alloc_zero(region, 
		sizeof(size_t)*(d->count+d->rrsig_count));
	d->rr_ttl = regional_alloc_zero(region, 
		sizeof(time_t)*(d->count+d->rrsig_count));
	d->rr_data = regional_alloc_zero(region, 
		sizeof(uint8_t*)*(d->count+d->rrsig_count));
	if(!d->rr_len || !d->rr_ttl || !d->rr_data) {
		log_warn("error out of memory");
		return 0;
	}
	
	/* read the rr's themselves */
	for(i=0; i<rr_count; i++) {
		if(!load_rr(ssl, buf, region, rk, d, i, 0, 
			&go_on, *worker->env.now)) {
			log_warn("could not read rr %u", i);
			return 0;
		}
	}
	for(i=0; i<rrsig_count; i++) {
		if(!load_rr(ssl, buf, region, rk, d, i+rr_count, 1, 
			&go_on, *worker->env.now)) {
			log_warn("could not read rrsig %u", i);
			return 0;
		}
	}
	if(!go_on) {
		/* skip this entry */
		return 1;
	}

	return move_into_cache(rk, d, worker);
}

/** load rrset cache */
static int
load_rrset_cache(SSL* ssl, struct worker* worker)
{
	sldns_buffer* buf = worker->env.scratch_buffer;
	if(!read_fixed(ssl, buf, "START_RRSET_CACHE")) return 0;
	while(ssl_read_buf(ssl, buf) && 
		strcmp((char*)sldns_buffer_begin(buf), "END_RRSET_CACHE")!=0) {
		if(!load_rrset(ssl, buf, worker))
			return 0;
	}
	return 1;
}

/** read qinfo from next three words */
static char*
load_qinfo(char* str, struct query_info* qinfo, struct regional* region)
{
	/* s is part of the buf */
	char* s = str;
	uint8_t rr[LDNS_RR_BUF_SIZE];
	size_t rr_len = sizeof(rr), dname_len = 0;
	int status;

	/* skip three words */
	s = strchr(str, ' ');
	if(s) s = strchr(s+1, ' ');
	if(s) s = strchr(s+1, ' ');
	if(!s) {
		log_warn("error line too short, %s", str);
		return NULL;
	}
	s[0] = 0;
	s++;

	/* parse them */
	status = sldns_str2wire_rr_question_buf(str, rr, &rr_len, &dname_len,
		NULL, 0, NULL, 0);
	if(status != 0) {
		log_warn("error cannot parse: %s %s",
			sldns_get_errorstr_parse(status), str);
		return NULL;
	}
	qinfo->qtype = sldns_wirerr_get_type(rr, rr_len, dname_len);
	qinfo->qclass = sldns_wirerr_get_class(rr, rr_len, dname_len);
	qinfo->qname_len = dname_len;
	qinfo->qname = (uint8_t*)regional_alloc_init(region, rr, dname_len);
	qinfo->local_alias = NULL;
	if(!qinfo->qname) {
		log_warn("error out of memory");
		return NULL;
	}

	return s;
}

/** load a msg rrset reference */
static int
load_ref(SSL* ssl, sldns_buffer* buf, struct worker* worker, 
	struct regional *region, struct ub_packed_rrset_key** rrset, 
	int* go_on)
{
	char* s = (char*)sldns_buffer_begin(buf);
	struct query_info qinfo;
	unsigned int flags;
	struct ub_packed_rrset_key* k;

	/* read line */
	if(!ssl_read_buf(ssl, buf))
		return 0;
	if(strncmp(s, "BADREF", 6) == 0) {
		*go_on = 0; /* its bad, skip it and skip message */
		return 1;
	}

	s = load_qinfo(s, &qinfo, region);
	if(!s) {
		return 0;
	}
	if(sscanf(s, " %u", &flags) != 1) {
		log_warn("error cannot parse flags: %s", s);
		return 0;
	}

	/* lookup in cache */
	k = rrset_cache_lookup(worker->env.rrset_cache, qinfo.qname,
		qinfo.qname_len, qinfo.qtype, qinfo.qclass,
		(uint32_t)flags, *worker->env.now, 0);
	if(!k) {
		/* not found or expired */
		*go_on = 0;
		return 1;
	}

	/* store in result */
	*rrset = packed_rrset_copy_region(k, region, *worker->env.now);
	lock_rw_unlock(&k->entry.lock);

	return (*rrset != NULL);
}

/** load a msg entry */
static int
load_msg(SSL* ssl, sldns_buffer* buf, struct worker* worker)
{
	struct regional* region = worker->scratchpad;
	struct query_info qinf;
	struct reply_info rep;
	char* s = (char*)sldns_buffer_begin(buf);
	unsigned int flags, qdcount, security, an, ns, ar;
	long long ttl;
	size_t i;
	int go_on = 1;

	regional_free_all(region);

	if(strncmp(s, "msg ", 4) != 0) {
		log_warn("error expected msg but got %s", s);
		return 0;
	}
	s += 4;
	s = load_qinfo(s, &qinf, region);
	if(!s) {
		return 0;
	}

	/* read remainder of line */
	if(sscanf(s, " %u %u " ARG_LL "d %u %u %u %u", &flags, &qdcount, &ttl, 
		&security, &an, &ns, &ar) != 7) {
		log_warn("error cannot parse numbers: %s", s);
		return 0;
	}
	rep.flags = (uint16_t)flags;
	rep.qdcount = (uint16_t)qdcount;
	rep.ttl = (time_t)ttl;
	rep.prefetch_ttl = PREFETCH_TTL_CALC(rep.ttl);
	rep.security = (enum sec_status)security;
	if(an > RR_COUNT_MAX || ns > RR_COUNT_MAX || ar > RR_COUNT_MAX) {
		log_warn("error too many rrsets");
		return 0; /* protect against integer overflow in alloc */
	}
	rep.an_numrrsets = (size_t)an;
	rep.ns_numrrsets = (size_t)ns;
	rep.ar_numrrsets = (size_t)ar;
	rep.rrset_count = (size_t)an+(size_t)ns+(size_t)ar;
	rep.rrsets = (struct ub_packed_rrset_key**)regional_alloc_zero(
		region, sizeof(struct ub_packed_rrset_key*)*rep.rrset_count);

	/* fill repinfo with references */
	for(i=0; i<rep.rrset_count; i++) {
		if(!load_ref(ssl, buf, worker, region, &rep.rrsets[i], 
			&go_on)) {
			return 0;
		}
	}

	if(!go_on) 
		return 1; /* skip this one, not all references satisfied */

	if(!dns_cache_store(&worker->env, &qinf, &rep, 0, 0, 0, NULL, flags)) {
		log_warn("error out of memory");
		return 0;
	}
	return 1;
}

/** load msg cache */
static int
load_msg_cache(SSL* ssl, struct worker* worker)
{
	sldns_buffer* buf = worker->env.scratch_buffer;
	if(!read_fixed(ssl, buf, "START_MSG_CACHE")) return 0;
	while(ssl_read_buf(ssl, buf) && 
		strcmp((char*)sldns_buffer_begin(buf), "END_MSG_CACHE")!=0) {
		if(!load_msg(ssl, buf, worker))
			return 0;
	}
	return 1;
}

int
load_cache(SSL* ssl, struct worker* worker)
{
	if(!load_rrset_cache(ssl, worker))
		return 0;
	if(!load_msg_cache(ssl, worker))
		return 0;
	return read_fixed(ssl, worker->env.scratch_buffer, "EOF");
}

/** print details on a delegation point */
static void
print_dp_details(SSL* ssl, struct worker* worker, struct delegpt* dp)
{
	char buf[257];
	struct delegpt_addr* a;
	int lame, dlame, rlame, rto, edns_vs, to, delay,
		tA = 0, tAAAA = 0, tother = 0;
	long long entry_ttl;
	struct rtt_info ri;
	uint8_t edns_lame_known;
	for(a = dp->target_list; a; a = a->next_target) {
		addr_to_str(&a->addr, a->addrlen, buf, sizeof(buf));
		if(!ssl_printf(ssl, "%-16s\t", buf))
			return;
		if(a->bogus) {
			if(!ssl_printf(ssl, "Address is BOGUS. ")) 
				return;
		}
		/* lookup in infra cache */
		delay=0;
		entry_ttl = infra_get_host_rto(worker->env.infra_cache,
			&a->addr, a->addrlen, dp->name, dp->namelen,
			&ri, &delay, *worker->env.now, &tA, &tAAAA, &tother);
		if(entry_ttl == -2 && ri.rto >= USEFUL_SERVER_TOP_TIMEOUT) {
			if(!ssl_printf(ssl, "expired, rto %d msec, tA %d "
				"tAAAA %d tother %d.\n", ri.rto, tA, tAAAA,
				tother))
				return;
			continue;
		}
		if(entry_ttl == -1 || entry_ttl == -2) {
			if(!ssl_printf(ssl, "not in infra cache.\n"))
				return;
			continue; /* skip stuff not in infra cache */
		}

		/* uses type_A because most often looked up, but other
		 * lameness won't be reported then */
		if(!infra_get_lame_rtt(worker->env.infra_cache, 
			&a->addr, a->addrlen, dp->name, dp->namelen,
			LDNS_RR_TYPE_A, &lame, &dlame, &rlame, &rto,
			*worker->env.now)) {
			if(!ssl_printf(ssl, "not in infra cache.\n"))
				return;
			continue; /* skip stuff not in infra cache */
		}
		if(!ssl_printf(ssl, "%s%s%s%srto %d msec, ttl " ARG_LL "d, "
			"ping %d var %d rtt %d, tA %d, tAAAA %d, tother %d",
			lame?"LAME ":"", dlame?"NoDNSSEC ":"",
			a->lame?"AddrWasParentSide ":"",
			rlame?"NoAuthButRecursive ":"", rto, entry_ttl,
			ri.srtt, ri.rttvar, rtt_notimeout(&ri),
			tA, tAAAA, tother))
			return;
		if(delay)
			if(!ssl_printf(ssl, ", probedelay %d", delay))
				return;
		if(infra_host(worker->env.infra_cache, &a->addr, a->addrlen,
			dp->name, dp->namelen, *worker->env.now, &edns_vs,
			&edns_lame_known, &to)) {
			if(edns_vs == -1) {
				if(!ssl_printf(ssl, ", noEDNS%s.",
					edns_lame_known?" probed":" assumed"))
					return;
			} else {
				if(!ssl_printf(ssl, ", EDNS %d%s.", edns_vs,
					edns_lame_known?" probed":" assumed"))
					return;
			}
		}
		if(!ssl_printf(ssl, "\n"))
			return;
	}
}

/** print main dp info */
static void
print_dp_main(SSL* ssl, struct delegpt* dp, struct dns_msg* msg)
{
	size_t i, n_ns, n_miss, n_addr, n_res, n_avail;

	/* print the dp */
	if(msg)
	    for(i=0; i<msg->rep->rrset_count; i++) {
		struct ub_packed_rrset_key* k = msg->rep->rrsets[i];
		struct packed_rrset_data* d = 
			(struct packed_rrset_data*)k->entry.data;
		if(d->security == sec_status_bogus) {
			if(!ssl_printf(ssl, "Address is BOGUS:\n"))
				return;
		}
		if(!dump_rrset(ssl, k, d, 0))
			return;
	    }
	delegpt_count_ns(dp, &n_ns, &n_miss);
	delegpt_count_addr(dp, &n_addr, &n_res, &n_avail);
	/* since dp has not been used by iterator, all are available*/
	if(!ssl_printf(ssl, "Delegation with %d names, of which %d "
		"can be examined to query further addresses.\n"
		"%sIt provides %d IP addresses.\n", 
		(int)n_ns, (int)n_miss, (dp->bogus?"It is BOGUS. ":""),
		(int)n_addr))
		return;
}

int print_deleg_lookup(SSL* ssl, struct worker* worker, uint8_t* nm,
	size_t nmlen, int ATTR_UNUSED(nmlabs))
{
	/* deep links into the iterator module */
	struct delegpt* dp;
	struct dns_msg* msg;
	struct regional* region = worker->scratchpad;
	char b[260];
	struct query_info qinfo;
	struct iter_hints_stub* stub;
	regional_free_all(region);
	qinfo.qname = nm;
	qinfo.qname_len = nmlen;
	qinfo.qtype = LDNS_RR_TYPE_A;
	qinfo.qclass = LDNS_RR_CLASS_IN;
	qinfo.local_alias = NULL;

	dname_str(nm, b);
	if(!ssl_printf(ssl, "The following name servers are used for lookup "
		"of %s\n", b)) 
		return 0;
	
	dp = forwards_lookup(worker->env.fwds, nm, qinfo.qclass);
	if(dp) {
		if(!ssl_printf(ssl, "forwarding request:\n"))
			return 0;
		print_dp_main(ssl, dp, NULL);
		print_dp_details(ssl, worker, dp);
		return 1;
	}
	
	while(1) {
		dp = dns_cache_find_delegation(&worker->env, nm, nmlen, 
			qinfo.qtype, qinfo.qclass, region, &msg, 
			*worker->env.now);
		if(!dp) {
			return ssl_printf(ssl, "no delegation from "
				"cache; goes to configured roots\n");
		}
		/* go up? */
		if(iter_dp_is_useless(&qinfo, BIT_RD, dp)) {
			print_dp_main(ssl, dp, msg);
			print_dp_details(ssl, worker, dp);
			if(!ssl_printf(ssl, "cache delegation was "
				"useless (no IP addresses)\n"))
				return 0;
			if(dname_is_root(nm)) {
				/* goes to root config */
				return ssl_printf(ssl, "no delegation from "
					"cache; goes to configured roots\n");
			} else {
				/* useless, goes up */
				nm = dp->name;
				nmlen = dp->namelen;
				dname_remove_label(&nm, &nmlen);
				dname_str(nm, b);
				if(!ssl_printf(ssl, "going up, lookup %s\n", b))
					return 0;
				continue;
			}
		} 
		stub = hints_lookup_stub(worker->env.hints, nm, qinfo.qclass,
			dp);
		if(stub) {
			if(stub->noprime) {
				if(!ssl_printf(ssl, "The noprime stub servers "
					"are used:\n"))
					return 0;
			} else {
				if(!ssl_printf(ssl, "The stub is primed "
						"with servers:\n"))
					return 0;
			}
			print_dp_main(ssl, stub->dp, NULL);
			print_dp_details(ssl, worker, stub->dp);
		} else {
			print_dp_main(ssl, dp, msg);
			print_dp_details(ssl, worker, dp);
		}
		break;
	}

	return 1;
}
@


1.3
log
@merge
@
text
@d566 1
d830 1
@


1.2
log
@Merge in some commits from upstream..

- Removed 'increased limit open files' log message that is written
  to console.  It is only written on verbosity 4 and higher.
  This keeps system bootup console cleaner.
- Fix #627: SSL_CTX_load_verify_locations return code not properly
  checked.
- Fix that CD flag disables DNS64 processing, returning the DNSSEC
  signed AAAA denial.
- Fix cdflag dns64 processing.

ok sthen@@
@
text
@d59 3
a61 3
#include "ldns/sbuffer.h"
#include "ldns/wire2str.h"
#include "ldns/str2wire.h"
d226 2
d475 4
d655 4
@


1.1
log
@Initial revision
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d43 1
a43 1
#include <ldns/ldns.h>
a46 1
#include "daemon/daemon.h"
a49 1
#include "services/modstack.h"
d59 3
a61 36

/** convert to ldns rr */
static ldns_rr*
to_rr(struct ub_packed_rrset_key* k, struct packed_rrset_data* d, 
	uint32_t now, size_t i, uint16_t type)
{
	ldns_rr* rr = ldns_rr_new();
	ldns_rdf* rdf;
	ldns_status status;
	size_t pos;
	log_assert(i < d->count + d->rrsig_count);
	if(!rr) {
		return NULL;
	}
	ldns_rr_set_type(rr, type);
	ldns_rr_set_class(rr, ntohs(k->rk.rrset_class));
	if(d->rr_ttl[i] < now)
		ldns_rr_set_ttl(rr, 0);
	else	ldns_rr_set_ttl(rr, d->rr_ttl[i] - now);
	pos = 0;
	status = ldns_wire2dname(&rdf, k->rk.dname, k->rk.dname_len, &pos);
	if(status != LDNS_STATUS_OK) {
		/* we drop detailed error in status */
		ldns_rr_free(rr);
		return NULL;
	}
	ldns_rr_set_owner(rr, rdf);
	pos = 0;
	status = ldns_wire2rdf(rr, d->rr_data[i], d->rr_len[i], &pos);
	if(status != LDNS_STATUS_OK) {
		/* we drop detailed error in status */
		ldns_rr_free(rr);
		return NULL;
	}
	return rr;
}
d65 1
a65 2
dump_rrset_line(SSL* ssl, struct ub_packed_rrset_key* k,
        struct packed_rrset_data* d, uint32_t now, size_t i, uint16_t type)
d67 2
a68 3
	char* s;
	ldns_rr* rr = to_rr(k, d, now, i, type);
	if(!rr) {
d71 1
a71 11
	s = ldns_rr2str(rr);
	ldns_rr_free(rr);
	if(!s) {
		return ssl_printf(ssl, "BADRR\n");
	}
	if(!ssl_printf(ssl, "%s", s)) {
		free(s);
		return 0;
	}
	free(s);
	return 1;
d77 1
a77 1
	struct packed_rrset_data* d, uint32_t now)
d85 1
a85 1
	if(!ssl_printf(ssl, ";rrset%s %u %u %u %d %d\n",
d87 1
a87 1
		(unsigned)(d->ttl - now),
d92 2
a93 7
	for(i=0; i<d->count; i++) {
		if(!dump_rrset_line(ssl, k, d, now, i, ntohs(k->rk.type)))
			return 0;
	}
	for(i=0; i<d->rrsig_count; i++) {
		if(!dump_rrset_line(ssl, k, d, now, i+d->count, 
			LDNS_RR_TYPE_RRSIG))
a95 1
	
d101 1
a101 1
dump_rrset_lruhash(SSL* ssl, struct lruhash* h, uint32_t now)
a140 3
	ldns_rdf* rdf;
	ldns_status status;
	size_t pos;
d142 3
a144 10

	pos = 0;
	status = ldns_wire2dname(&rdf, k->rk.dname, k->rk.dname_len, &pos);
	if(status != LDNS_STATUS_OK) {
		return ssl_printf(ssl, "BADREF\n");
	}
	nm = ldns_rdf2str(rdf);
	ldns_rdf_deep_free(rdf);
	tp = ldns_rr_type2str(ntohs(k->rk.type));
	cl = ldns_rr_class2str(ntohs(k->rk.rrset_class));
d167 1
a167 1
	uint32_t now)
a170 3
	ldns_rdf* rdf;
	ldns_status status;
	size_t pos;
d174 3
a176 9
	pos = 0;
	status = ldns_wire2dname(&rdf, k->qname, k->qname_len, &pos);
	if(status != LDNS_STATUS_OK) {
		return 1; /* skip this entry */
	}
	nm = ldns_rdf2str(rdf);
	ldns_rdf_deep_free(rdf);
	tp = ldns_rr_type2str(k->qtype);
	cl = ldns_rr_class2str(k->qclass);
d192 1
a192 1
	if(!ssl_printf(ssl, "msg %s %s %s %d %d %u %d %u %u %u\n",
d195 1
a195 1
			(unsigned)(d->ttl-now), (int)d->security,
d232 1
a232 1
	(*d)->rrsets = (struct ub_packed_rrset_key**)(
d302 1
a302 1
ssl_read_buf(SSL* ssl, ldns_buffer* buf)
d304 2
a305 2
	return ssl_read_line(ssl, (char*)ldns_buffer_begin(buf), 
		ldns_buffer_capacity(buf));
d310 1
a310 1
read_fixed(SSL* ssl, ldns_buffer* buf, const char* str)
d313 1
a313 1
	return (strcmp((char*)ldns_buffer_begin(buf), str) == 0);
d318 1
a318 1
load_rr(SSL* ssl, ldns_buffer* buf, struct regional* region,
d320 1
a320 1
	unsigned int i, int is_rrsig, int* go_on, uint32_t now)
d322 3
a324 2
	ldns_rr* rr;
	ldns_status status;
d329 1
a329 1
	if(strncmp((char*)ldns_buffer_begin(buf), "BADRR\n", 6) == 0) {
d333 3
a335 3
	status = ldns_rr_new_frm_str(&rr, (char*)ldns_buffer_begin(buf),
		LDNS_DEFAULT_TTL, NULL, NULL);
	if(status != LDNS_STATUS_OK) {
d337 2
a338 2
			ldns_get_errorstr_by_id(status),
			(char*)ldns_buffer_begin(buf));
d341 2
a342 1
	if(is_rrsig && ldns_rr_get_type(rr) != LDNS_RR_TYPE_RRSIG) {
d344 1
a344 1
			(char*)ldns_buffer_begin(buf));
d349 3
a351 14
	d->rr_ttl[i] = ldns_rr_ttl(rr) + now;
	ldns_buffer_clear(buf);
	ldns_buffer_skip(buf, 2);
	status = ldns_rr_rdata2buffer_wire(buf, rr);
	if(status != LDNS_STATUS_OK) {
		log_warn("error cannot rr2wire: %s",
			ldns_get_errorstr_by_id(status));
		ldns_rr_free(rr);
		return 0;
	}
	ldns_buffer_flip(buf);
	ldns_buffer_write_u16_at(buf, 0, ldns_buffer_limit(buf) - 2);

	d->rr_len[i] = ldns_buffer_limit(buf);
d353 1
a353 1
		ldns_buffer_begin(buf), ldns_buffer_limit(buf));
a354 1
		ldns_rr_free(rr);
d361 4
a364 14
		rk->rk.type = htons(ldns_rr_get_type(rr));
		rk->rk.rrset_class = htons(ldns_rr_get_class(rr));
		ldns_buffer_clear(buf);
		status = ldns_dname2buffer_wire(buf, ldns_rr_owner(rr));
		if(status != LDNS_STATUS_OK) {
			log_warn("error cannot dname2buffer: %s",
				ldns_get_errorstr_by_id(status));
			ldns_rr_free(rr);
			return 0;
		}
		ldns_buffer_flip(buf);
		rk->rk.dname_len = ldns_buffer_limit(buf);
		rk->rk.dname = regional_alloc_init(region, 
			ldns_buffer_begin(buf), ldns_buffer_limit(buf));
a366 1
			ldns_rr_free(rr);
a369 1
	ldns_rr_free(rr);
d400 1
a400 1
		sizeof(uint32_t))* num;
d416 2
a417 2
	memmove(p, &d->rr_ttl[0], sizeof(uint32_t)*num);
	p += sizeof(uint32_t)*num;
d435 1
a435 1
load_rrset(SSL* ssl, ldns_buffer* buf, struct worker* worker)
d437 1
a437 1
	char* s = (char*)ldns_buffer_begin(buf);
d441 2
a442 1
	unsigned int ttl, rr_count, rrsig_count, trust, security;
d464 1
a464 1
	if(sscanf(s, " %u %u %u %u %u", &ttl, &rr_count, &rrsig_count,
d477 1
a477 1
	d->ttl = (uint32_t)ttl + *worker->env.now;
d482 1
a482 1
		sizeof(uint32_t)*(d->count+d->rrsig_count));
d517 1
a517 1
	ldns_buffer* buf = worker->env.scratch_buffer;
d520 1
a520 1
		strcmp((char*)ldns_buffer_begin(buf), "END_RRSET_CACHE")!=0) {
d529 1
a529 2
load_qinfo(char* str, struct query_info* qinfo, ldns_buffer* buf, 
	struct regional* region)
d533 3
a535 2
	ldns_rr* rr;
	ldns_status status;
d549 3
a551 2
	status = ldns_rr_new_question_frm_str(&rr, str, NULL, NULL);
	if(status != LDNS_STATUS_OK) {
d553 1
a553 1
			ldns_get_errorstr_by_id(status), str);
d556 4
a559 14
	qinfo->qtype = ldns_rr_get_type(rr);
	qinfo->qclass = ldns_rr_get_class(rr);
	ldns_buffer_clear(buf);
	status = ldns_dname2buffer_wire(buf, ldns_rr_owner(rr));
	ldns_rr_free(rr);
	if(status != LDNS_STATUS_OK) {
		log_warn("error cannot dname2wire: %s", 
			ldns_get_errorstr_by_id(status));
		return NULL;
	}
	ldns_buffer_flip(buf);
	qinfo->qname_len = ldns_buffer_limit(buf);
	qinfo->qname = (uint8_t*)regional_alloc_init(region, 
		ldns_buffer_begin(buf), ldns_buffer_limit(buf));
d570 1
a570 1
load_ref(SSL* ssl, ldns_buffer* buf, struct worker* worker, 
d574 1
a574 1
	char* s = (char*)ldns_buffer_begin(buf);
d587 1
a587 1
	s = load_qinfo(s, &qinfo, buf, region);
d615 1
a615 1
load_msg(SSL* ssl, ldns_buffer* buf, struct worker* worker)
d620 3
a622 2
	char* s = (char*)ldns_buffer_begin(buf);
	unsigned int flags, qdcount, ttl, security, an, ns, ar;
d633 1
a633 1
	s = load_qinfo(s, &qinf, buf, region);
d639 1
a639 1
	if(sscanf(s, " %u %u %u %u %u %u %u", &flags, &qdcount, &ttl, 
d646 1
a646 1
	rep.ttl = (uint32_t)ttl;
d667 1
a667 1
	if(!dns_cache_store(&worker->env, &qinf, &rep, 0, 0, NULL)) {
d678 1
a678 1
	ldns_buffer* buf = worker->env.scratch_buffer;
d681 1
a681 1
		strcmp((char*)ldns_buffer_begin(buf), "END_MSG_CACHE")!=0) {
d704 3
a706 1
	int lame, dlame, rlame, rto, edns_vs, to, delay, entry_ttl;
d721 1
a721 1
			&ri, &delay, *worker->env.now);
d723 3
a725 1
			if(!ssl_printf(ssl, "expired, rto %d msec.\n", ri.rto))
d745 2
a746 2
		if(!ssl_printf(ssl, "%s%s%s%srto %d msec, ttl %d, ping %d "
			"var %d rtt %d",
d750 2
a751 1
			ri.srtt, ri.rttvar, rtt_notimeout(&ri)))
a813 1
	struct iter_env* ie;
a819 6
	if(modstack_find(&worker->daemon->mods, "iterator") == -1) {
		return ssl_printf(ssl, "error: no iterator module\n");
	}
	ie = (struct iter_env*)worker->env.modinfo[modstack_find(&worker->
		daemon->mods, "iterator")];

d864 2
a865 1
		stub = hints_lookup_stub(ie->hints, nm, qinfo.qclass, dp);
@


1.1.1.1
log
@Import Unbound 1.4.16 to work on in-tree (not yet linked to the build).

These are the direct sources from NLnet Labs upstream, minus these:
compat contrib libunbound/python pythonmod testcode testdata winrc

ok deraadt@@ jakob@@
@
text
@@


1.1.1.2
log
@update to unbound 1.4.17, testing by okan@@ (not yet linked to build;
1.4.18 to follow later).
@
text
@d768 1
a768 1
	if(!dns_cache_store(&worker->env, &qinf, &rep, 0, 0, 0, NULL)) {
d805 1
a805 2
	int lame, dlame, rlame, rto, edns_vs, to, delay, entry_ttl,
		tA = 0, tAAAA = 0, tother = 0;
d820 1
a820 1
			&ri, &delay, *worker->env.now, &tA, &tAAAA, &tother);
d822 1
a822 3
			if(!ssl_printf(ssl, "expired, rto %d msec, tA %d "
				"tAAAA %d tother %d.\n", ri.rto, tA, tAAAA,
				tother))
d843 1
a843 1
			"var %d rtt %d, tA %d, tAAAA %d, tother %d",
d847 1
a847 2
			ri.srtt, ri.rttvar, rtt_notimeout(&ri),
			tA, tAAAA, tother))
d910 1
d917 6
d967 1
a967 2
		stub = hints_lookup_stub(worker->env.hints, nm, qinfo.qclass,
			dp);
@


1.1.1.3
log
@update to unbound 1.4.18
@
text
@d47 1
d51 1
@


1.1.1.4
log
@update to Unbound 1.4.21, ok brad@@
@
text
@d63 1
a63 1
	time_t now, size_t i, uint16_t type)
d99 1
a99 1
        struct packed_rrset_data* d, time_t now, size_t i, uint16_t type)
d122 1
a122 1
	struct packed_rrset_data* d, time_t now)
d130 1
a130 1
	if(!ssl_printf(ssl, ";rrset%s %lld %u %u %d %d\n",
d132 1
a132 1
		(long long)(d->ttl - now),
d152 1
a152 1
dump_rrset_lruhash(SSL* ssl, struct lruhash* h, time_t now)
d228 1
a228 1
	time_t now)
d262 1
a262 1
	if(!ssl_printf(ssl, "msg %s %s %s %d %d %lld %d %u %u %u\n",
d265 1
a265 1
			(long long)(d->ttl-now), (int)d->security,
d390 1
a390 1
	unsigned int i, int is_rrsig, int* go_on, time_t now)
d492 1
a492 1
		sizeof(time_t))* num;
d508 2
a509 2
	memmove(p, &d->rr_ttl[0], sizeof(time_t)*num);
	p += sizeof(time_t)*num;
d533 1
a533 2
	unsigned int rr_count, rrsig_count, trust, security;
	long long ttl;
d555 1
a555 1
	if(sscanf(s, " %lld %u %u %u %u", &ttl, &rr_count, &rrsig_count,
d568 1
a568 1
	d->ttl = (time_t)ttl + *worker->env.now;
d573 1
a573 1
		sizeof(time_t)*(d->count+d->rrsig_count));
d721 1
a721 2
	unsigned int flags, qdcount, security, an, ns, ar;
	long long ttl;
d738 1
a738 1
	if(sscanf(s, " %u %u %lld %u %u %u %u", &flags, &qdcount, &ttl, 
d745 1
a745 1
	rep.ttl = (time_t)ttl;
d803 1
a803 1
	int lame, dlame, rlame, rto, edns_vs, to, delay,
a804 1
	long long entry_ttl;
d843 1
a843 1
		if(!ssl_printf(ssl, "%s%s%s%srto %d msec, ttl %lld, ping %d "
@


1.1.1.5
log
@import unbound 1.4.22 upstream sources, ok brad@@
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d43 1
a43 1
#include <openssl/ssl.h>
d59 36
a94 3
#include "ldns/sbuffer.h"
#include "ldns/wire2str.h"
#include "ldns/str2wire.h"
d98 2
a99 1
dump_rrset_line(SSL* ssl, struct ub_packed_rrset_key* k, time_t now, size_t i)
d101 3
a103 2
	char s[65535];
	if(!packed_rr_to_string(k, i, now, s, sizeof(s))) {
d106 11
a116 1
	return ssl_printf(ssl, "%s", s);
d130 1
a130 1
	if(!ssl_printf(ssl, ";rrset%s " ARG_LL "d %u %u %d %d\n",
d137 2
a138 2
	for(i=0; i<d->count + d->rrsig_count; i++) {
		if(!dump_rrset_line(ssl, k, now, i))
d141 6
d192 3
d196 10
a205 3
	nm = sldns_wire2str_dname(k->rk.dname, k->rk.dname_len);
	tp = sldns_wire2str_type(ntohs(k->rk.type));
	cl = sldns_wire2str_class(ntohs(k->rk.rrset_class));
d232 3
d238 9
a246 3
	nm = sldns_wire2str_dname(k->qname, k->qname_len);
	tp = sldns_wire2str_type(k->qtype);
	cl = sldns_wire2str_class(k->qclass);
d262 1
a262 1
	if(!ssl_printf(ssl, "msg %s %s %s %d %d " ARG_LL "d %d %u %u %u\n",
d372 1
a372 1
ssl_read_buf(SSL* ssl, sldns_buffer* buf)
d374 2
a375 2
	return ssl_read_line(ssl, (char*)sldns_buffer_begin(buf), 
		sldns_buffer_capacity(buf));
d380 1
a380 1
read_fixed(SSL* ssl, sldns_buffer* buf, const char* str)
d383 1
a383 1
	return (strcmp((char*)sldns_buffer_begin(buf), str) == 0);
d388 1
a388 1
load_rr(SSL* ssl, sldns_buffer* buf, struct regional* region,
d392 2
a393 3
	uint8_t rr[LDNS_RR_BUF_SIZE];
	size_t rr_len = sizeof(rr), dname_len = 0;
	int status;
d398 1
a398 1
	if(strncmp((char*)sldns_buffer_begin(buf), "BADRR\n", 6) == 0) {
d402 3
a404 3
	status = sldns_str2wire_rr_buf((char*)sldns_buffer_begin(buf), rr,
		&rr_len, &dname_len, 3600, NULL, 0, NULL, 0);
	if(status != 0) {
d406 2
a407 2
			sldns_get_errorstr_parse(status),
			(char*)sldns_buffer_begin(buf));
d410 1
a410 2
	if(is_rrsig && sldns_wirerr_get_type(rr, rr_len, dname_len)
		!= LDNS_RR_TYPE_RRSIG) {
d412 1
a412 1
			(char*)sldns_buffer_begin(buf));
d417 14
a430 3
	d->rr_ttl[i] = (time_t)sldns_wirerr_get_ttl(rr, rr_len, dname_len) + now;
	sldns_buffer_clear(buf);
	d->rr_len[i] = sldns_wirerr_get_rdatalen(rr, rr_len, dname_len)+2;
d432 1
a432 1
		sldns_wirerr_get_rdatawl(rr, rr_len, dname_len), d->rr_len[i]);
d434 1
d441 14
a454 4
		rk->rk.type = htons(sldns_wirerr_get_type(rr, rr_len, dname_len));
		rk->rk.rrset_class = htons(sldns_wirerr_get_class(rr, rr_len, dname_len));
		rk->rk.dname_len = dname_len;
		rk->rk.dname = regional_alloc_init(region, rr, dname_len);
d457 1
d461 1
d527 1
a527 1
load_rrset(SSL* ssl, sldns_buffer* buf, struct worker* worker)
d529 1
a529 1
	char* s = (char*)sldns_buffer_begin(buf);
d556 1
a556 1
	if(sscanf(s, " " ARG_LL "d %u %u %u %u", &ttl, &rr_count, &rrsig_count,
d609 1
a609 1
	sldns_buffer* buf = worker->env.scratch_buffer;
d612 1
a612 1
		strcmp((char*)sldns_buffer_begin(buf), "END_RRSET_CACHE")!=0) {
d621 2
a622 1
load_qinfo(char* str, struct query_info* qinfo, struct regional* region)
d626 2
a627 3
	uint8_t rr[LDNS_RR_BUF_SIZE];
	size_t rr_len = sizeof(rr), dname_len = 0;
	int status;
d641 2
a642 3
	status = sldns_str2wire_rr_question_buf(str, rr, &rr_len, &dname_len,
		NULL, 0, NULL, 0);
	if(status != 0) {
d644 11
a654 1
			sldns_get_errorstr_parse(status), str);
d657 4
a660 4
	qinfo->qtype = sldns_wirerr_get_type(rr, rr_len, dname_len);
	qinfo->qclass = sldns_wirerr_get_class(rr, rr_len, dname_len);
	qinfo->qname_len = dname_len;
	qinfo->qname = (uint8_t*)regional_alloc_init(region, rr, dname_len);
d671 1
a671 1
load_ref(SSL* ssl, sldns_buffer* buf, struct worker* worker, 
d675 1
a675 1
	char* s = (char*)sldns_buffer_begin(buf);
d688 1
a688 1
	s = load_qinfo(s, &qinfo, region);
d716 1
a716 1
load_msg(SSL* ssl, sldns_buffer* buf, struct worker* worker)
d721 1
a721 1
	char* s = (char*)sldns_buffer_begin(buf);
d734 1
a734 1
	s = load_qinfo(s, &qinf, region);
d740 1
a740 1
	if(sscanf(s, " %u %u " ARG_LL "d %u %u %u %u", &flags, &qdcount, &ttl, 
d779 1
a779 1
	sldns_buffer* buf = worker->env.scratch_buffer;
d782 1
a782 1
		strcmp((char*)sldns_buffer_begin(buf), "END_MSG_CACHE")!=0) {
d846 2
a847 2
		if(!ssl_printf(ssl, "%s%s%s%srto %d msec, ttl " ARG_LL "d, "
			"ping %d var %d rtt %d, tA %d, tAAAA %d, tother %d",
@


1.1.1.6
log
@update to Unbound 1.5.0, ok sthen@@
@
text
@d232 1
a232 1
	(*d)->rrsets = (struct ub_packed_rrset_key**)(void *)(
@


1.1.1.7
log
@update to Unbound 1.5.1, ok sthen@@
@
text
@d667 1
a667 1
	if(!dns_cache_store(&worker->env, &qinf, &rep, 0, 0, 0, NULL, flags)) {
@


1.1.1.8
log
@update to Unbound 1.5.4, ok florian@@, looks sane deraadt@@
@
text
@d59 3
a61 3
#include "sldns/sbuffer.h"
#include "sldns/wire2str.h"
#include "sldns/str2wire.h"
a225 2
	if(rep->rrset_count > RR_COUNT_MAX)
		return 0; /* to protect against integer overflow */
a472 4
	if(rr_count > RR_COUNT_MAX || rrsig_count > RR_COUNT_MAX) {
		log_warn("bad rrset with too many rrs");
		return 0;
	}
a648 4
	if(an > RR_COUNT_MAX || ns > RR_COUNT_MAX || ar > RR_COUNT_MAX) {
		log_warn("error too many rrsets");
		return 0; /* protect against integer overflow in alloc */
	}
@


