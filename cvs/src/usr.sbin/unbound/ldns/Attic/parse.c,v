head	1.2;
access;
symbols
	OPENBSD_5_7:1.1.1.6.0.4
	OPENBSD_5_7_BASE:1.1.1.6
	UNBOUND_1_5_2RC1:1.1.1.6
	UNBOUND_1_5_1:1.1.1.6
	UNBOUND_1_5_0:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	UNBOUND_1_4_22:1.1.1.5
	OPENBSD_5_5:1.1.1.4.0.4
	OPENBSD_5_5_BASE:1.1.1.4
	LDNS_1_6_17:1.1.1.4
	LDNS_1_6_16:1.1.1.3
	OPENBSD_5_4:1.1.1.2.0.4
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.2
	OPENBSD_5_3_BASE:1.1.1.2
	LDNS_1_6_13:1.1.1.2
	OPENBSD_5_2:1.1.1.1.0.2
	OPENBSD_5_2_BASE:1.1.1.1
	LDNS_1_6_12:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2015.07.16.01.44.46;	author sthen;	state dead;
branches;
next	1.1;
commitid	t9pxoh9ifGMVZPce;

1.1
date	2012.03.26.18.08.21;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.03.26.18.08.21;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.08.23.22.28.43;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.22.11.58.37;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.02.04.03.47.52;	author brad;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.16.11.38.26;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.20.00.00.34;	author brad;	state Exp;
branches;
next	;
commitid	bB36RwIVwTq8fGsI;


desc
@@


1.2
log
@remove dead files (moved from unbound/ldns/ to unbound/sldns/)
@
text
@/*
 * a generic (simple) parser. Use to parse rr's, private key
 * information and /etc/resolv.conf files
 *
 * a Net::DNS like library for C
 * LibDNS Team @@ NLnet Labs
 * (c) NLnet Labs, 2005-2006
 * See the file LICENSE for the license
 */
#include <ldns/config.h>
#include <ldns/ldns.h>

#include <limits.h>
#include <strings.h>

ldns_lookup_table ldns_directive_types[] = {
        { LDNS_DIR_TTL, "$TTL" },
        { LDNS_DIR_ORIGIN, "$ORIGIN" },
        { LDNS_DIR_INCLUDE, "$INCLUDE" },
        { 0, NULL }
};

/* add max_limit here? */
ssize_t
ldns_fget_token(FILE *f, char *token, const char *delim, size_t limit)
{
	return ldns_fget_token_l(f, token, delim, limit, NULL);
}

ssize_t
ldns_fget_token_l(FILE *f, char *token, const char *delim, size_t limit, int *line_nr)
{
	int c, prev_c;
	int p; /* 0 -> no parenthese seen, >0 nr of ( seen */
	int com, quoted;
	char *t;
	size_t i;
	const char *d;
	const char *del;

	/* standard delimeters */
	if (!delim) {
		/* from isspace(3) */
		del = LDNS_PARSE_NORMAL;
	} else {
		del = delim;
	}

	p = 0;
	i = 0;
	com = 0;
	quoted = 0;
	prev_c = 0;
	t = token;
	if (del[0] == '"') {
		quoted = 1;
	}
	while ((c = getc(f)) != EOF) {
		if (c == '\r') /* carriage return */
			c = ' ';
		if (c == '(' && prev_c != '\\' && !quoted) {
			/* this only counts for non-comments */
			if (com == 0) {
				p++;
			}
			prev_c = c;
			continue;
		}

		if (c == ')' && prev_c != '\\' && !quoted) {
			/* this only counts for non-comments */
			if (com == 0) {
				p--;
			}
			prev_c = c;
			continue;
		}

		if (p < 0) {
			/* more ) then ( - close off the string */
			*t = '\0';
			return 0;
		}

		/* do something with comments ; */
		if (c == ';' && quoted == 0) {
			if (prev_c != '\\') {
				com = 1;
			}
		}
		if (c == '\"' && com == 0 && prev_c != '\\') {
			quoted = 1 - quoted;
		}

		if (c == '\n' && com != 0) {
			/* comments */
			com = 0;
			*t = ' ';
			if (line_nr) {
				*line_nr = *line_nr + 1;
			}
			if (p == 0 && i > 0) {
				goto tokenread;
			} else {
				prev_c = c;
				continue;
			}
		}

		if (com == 1) {
			*t = ' ';
			prev_c = c;
			continue;
		}

		if (c == '\n' && p != 0 && t > token) {
			/* in parentheses */
			if (line_nr) {
				*line_nr = *line_nr + 1;
			}
			*t++ = ' ';
			prev_c = c;
			continue;
		}

		/* check if we hit the delim */
		for (d = del; *d; d++) {
			if (c == *d && i > 0 && prev_c != '\\' && p == 0) {
				if (c == '\n' && line_nr) {
					*line_nr = *line_nr + 1;
				}
				goto tokenread;
			}
		}
		if (c != '\0' && c != '\n') {
			i++;
		}
		if (limit > 0 && i >= limit) {
			*t = '\0';
			return -1;
		}
		if (c != '\0' && c != '\n') {
			*t++ = c;
		}
		if (c == '\\' && prev_c == '\\')
			prev_c = 0;
		else	prev_c = c;
	}
	*t = '\0';
	if (c == EOF) {
		return (ssize_t)i;
	}

	if (i == 0) {
		/* nothing read */
		return -1;
	}
	if (p != 0) {
		return -1;
	}
	return (ssize_t)i;

tokenread:
	ldns_fskipcs_l(f, delim, line_nr);
	*t = '\0';
	if (p != 0) {
		return -1;
	}

	return (ssize_t)i;
}

ssize_t
ldns_fget_keyword_data(FILE *f, const char *keyword, const char *k_del, char *data,
               const char *d_del, size_t data_limit)
{
       return ldns_fget_keyword_data_l(f, keyword, k_del, data, d_del,
		       data_limit, NULL);
}

ssize_t
ldns_fget_keyword_data_l(FILE *f, const char *keyword, const char *k_del, char *data,
               const char *d_del, size_t data_limit, int *line_nr)
{
       /* we assume: keyword|sep|data */
       char *fkeyword;
       ssize_t i;

       if(strlen(keyword) >= LDNS_MAX_KEYWORDLEN)
               return -1;
       fkeyword = LDNS_XMALLOC(char, LDNS_MAX_KEYWORDLEN);
       if(!fkeyword)
               return -1;

       i = ldns_fget_token(f, fkeyword, k_del, LDNS_MAX_KEYWORDLEN);
       if(i==0 || i==-1) {
               LDNS_FREE(fkeyword);
               return -1;
       }

       /* case??? i instead of strlen? */
       if (strncmp(fkeyword, keyword, LDNS_MAX_KEYWORDLEN - 1) == 0) {
               /* whee! */
               /* printf("%s\n%s\n", "Matching keyword", fkeyword); */
               i = ldns_fget_token_l(f, data, d_del, data_limit, line_nr);
               LDNS_FREE(fkeyword);
               return i;
       } else {
               /*printf("no match for %s (read: %s)\n", keyword, fkeyword);*/
               LDNS_FREE(fkeyword);
               return -1;
       }
}


ssize_t
ldns_bget_token(ldns_buffer *b, char *token, const char *delim, size_t limit)
{
	int c, lc;
	int p; /* 0 -> no parenthese seen, >0 nr of ( seen */
	int com, quoted;
	char *t;
	size_t i;
	const char *d;
	const char *del;

	/* standard delimiters */
	if (!delim) {
		/* from isspace(3) */
		del = LDNS_PARSE_NORMAL;
	} else {
		del = delim;
	}

	p = 0;
	i = 0;
	com = 0;
	quoted = 0;
	t = token;
	lc = 0;
	if (del[0] == '"') {
		quoted = 1;
	}

	while ((c = ldns_bgetc(b)) != EOF) {
		if (c == '\r') /* carriage return */
			c = ' ';
		if (c == '(' && lc != '\\' && !quoted) {
			/* this only counts for non-comments */
			if (com == 0) {
				p++;
			}
			lc = c;
			continue;
		}

		if (c == ')' && lc != '\\' && !quoted) {
			/* this only counts for non-comments */
			if (com == 0) {
				p--;
			}
			lc = c;
			continue;
		}

		if (p < 0) {
			/* more ) then ( */
			*t = '\0';
			return 0;
		}

		/* do something with comments ; */
		if (c == ';' && quoted == 0) {
			if (lc != '\\') {
				com = 1;
			}
		}
		if (c == '"' && com == 0 && lc != '\\') {
			quoted = 1 - quoted;
		}

		if (c == '\n' && com != 0) {
			/* comments */
			com = 0;
			*t = ' ';
			lc = c;
			continue;
		}

		if (com == 1) {
			*t = ' ';
			lc = c;
			continue;
		}

		if (c == '\n' && p != 0) {
			/* in parentheses */
			*t++ = ' ';
			lc = c;
			continue;
		}

		/* check if we hit the delim */
		for (d = del; *d; d++) {
                        if (c == *d && lc != '\\' && p == 0) {
				goto tokenread;
                        }
		}

		i++;
		if (limit > 0 && i >= limit) {
			*t = '\0';
			return -1;
		}
		*t++ = c;

		if (c == '\\' && lc == '\\') {
			lc = 0;
		} else {
			lc = c;
		}
	}
	*t = '\0';
	if (i == 0) {
		/* nothing read */
		return -1;
	}
	if (p != 0) {
		return -1;
	}
	return (ssize_t)i;

tokenread:
	ldns_bskipcs(b, delim);
	*t = '\0';

	if (p != 0) {
		return -1;
	}
	return (ssize_t)i;
}

void
ldns_bskipc(ldns_buffer *buffer, char c)
{
        while (c == (char) ldns_buffer_read_u8_at(buffer, ldns_buffer_position(buffer))) {
                if (ldns_buffer_available_at(buffer,
					buffer->_position + sizeof(char), sizeof(char))) {
                        buffer->_position += sizeof(char);
                } else {
                        return;
                }
        }
}

void
ldns_bskipcs(ldns_buffer *buffer, const char *s)
{
        bool found;
        char c;
        const char *d;

        while(ldns_buffer_available_at(buffer, buffer->_position, sizeof(char))) {
                c = (char) ldns_buffer_read_u8_at(buffer, buffer->_position);
                found = false;
                for (d = s; *d; d++) {
                        if (*d == c) {
                                found = true;
                        }
                }
                if (found && buffer->_limit > buffer->_position) {
                        buffer->_position += sizeof(char);
                } else {
                        return;
                }
        }
}

void
ldns_fskipc(FILE *fp, char c)
{
	fp = fp;
	c = c;
}


void
ldns_fskipcs(FILE *fp, const char *s)
{
	ldns_fskipcs_l(fp, s, NULL);
}

void
ldns_fskipcs_l(FILE *fp, const char *s, int *line_nr)
{
        bool found;
        int c;
        const char *d;

	while ((c = fgetc(fp)) != EOF) {
		if (line_nr && c == '\n') {
			*line_nr = *line_nr + 1;
		}
                found = false;
                for (d = s; *d; d++) {
                        if (*d == c) {
                                found = true;
                        }
                }
		if (!found) {
			/* with getc, we've read too far */
			ungetc(c, fp);
			return;
		}
	}
}

ssize_t
ldns_bget_keyword_data(ldns_buffer *b, const char *keyword, const char *k_del, char
*data, const char *d_del, size_t data_limit)
{
       /* we assume: keyword|sep|data */
       char *fkeyword;
       ssize_t i;

       if(strlen(keyword) >= LDNS_MAX_KEYWORDLEN)
               return -1;
       fkeyword = LDNS_XMALLOC(char, LDNS_MAX_KEYWORDLEN);
       if(!fkeyword)
               return -1; /* out of memory */

       i = ldns_bget_token(b, fkeyword, k_del, data_limit);
       if(i==0 || i==-1) {
               LDNS_FREE(fkeyword);
               return -1; /* nothing read */
       }

       /* case??? */
       if (strncmp(fkeyword, keyword, strlen(keyword)) == 0) {
               LDNS_FREE(fkeyword);
               /* whee, the match! */
               /* retrieve it's data */
               i = ldns_bget_token(b, data, d_del, 0);
               return i;
       } else {
               LDNS_FREE(fkeyword);
               return -1;
       }
}

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import ldns 1.6.12, needed for Unbound, to work on in-tree.

These are the direct sources from NLnet Labs upstream, minus these:
contrib doc/images examples packaging/fedora

ok deraadt@@ jakob@@
@
text
@@


1.1.1.2
log
@update to ldns 1.6.13, tested by okan@@, thanks (not yet linked to build).
@
text
@d380 1
a380 1
ldns_fskipc(ATTR_UNUSED(FILE *fp), ATTR_UNUSED(char c))
d382 2
@


1.1.1.3
log
@update to ldns 1.6.16
@
text
@d164 1
a164 1
	ldns_fskipcs_l(f, del, line_nr);
d334 1
a334 1
	ldns_bskipcs(b, del);
@


1.1.1.4
log
@update to ldns 1.6.17, ok sthen@@
@
text
@d138 1
a138 1
		if (limit > 0 && (i >= limit || (size_t)(t-token) >= limit)) {
d311 1
a311 1
		if (limit > 0 && (i >= limit || (size_t)(t-token) >= limit)) {
d343 12
d378 6
@


1.1.1.5
log
@import unbound 1.4.22 upstream sources, ok brad@@
@
text
@d10 2
a11 4
#include "config.h"
#include "ldns/parse.h"
#include "ldns/parseutil.h"
#include "ldns/sbuffer.h"
d16 1
a16 1
sldns_lookup_table sldns_directive_types[] = {
d25 1
a25 1
sldns_fget_token(FILE *f, char *token, const char *delim, size_t limit)
d27 1
a27 1
	return sldns_fget_token_l(f, token, delim, limit, NULL);
d31 1
a31 1
sldns_fget_token_l(FILE *f, char *token, const char *delim, size_t limit, int *line_nr)
d164 1
a164 5
	if(*del == '"')
		/* do not skip over quotes after the string, they are part
		 * of the next string.  But skip over whitespace (if needed)*/
		sldns_fskipcs_l(f, del+1, line_nr);
	else	sldns_fskipcs_l(f, del, line_nr);
d174 1
a174 1
sldns_fget_keyword_data(FILE *f, const char *keyword, const char *k_del, char *data,
d177 1
a177 1
       return sldns_fget_keyword_data_l(f, keyword, k_del, data, d_del,
d182 1
a182 1
sldns_fget_keyword_data_l(FILE *f, const char *keyword, const char *k_del, char *data,
d191 1
a191 1
       fkeyword = (char*)malloc(LDNS_MAX_KEYWORDLEN);
d195 1
a195 1
       i = sldns_fget_token(f, fkeyword, k_del, LDNS_MAX_KEYWORDLEN);
d197 1
a197 1
               free(fkeyword);
d205 2
a206 2
               i = sldns_fget_token_l(f, data, d_del, data_limit, line_nr);
               free(fkeyword);
d210 1
a210 1
               free(fkeyword);
a214 5
ssize_t
sldns_bget_token(sldns_buffer *b, char *token, const char *delim, size_t limit)
{
	return sldns_bget_token_par(b, token, delim, limit, NULL, NULL);
}
d217 1
a217 2
sldns_bget_token_par(sldns_buffer *b, char *token, const char *delim,
	size_t limit, int* par, const char* skipw)
d235 1
a235 1
	p = (par?*par:0);
d245 1
a245 1
	while ((c = sldns_bgetc(b)) != EOF) {
a250 1
				if(par) (*par)++;
a259 1
				if(par) (*par)--;
d298 1
a298 3
			/* do not write ' ' if we want to skip spaces */
			if(!(skipw && (strchr(skipw, c)||strchr(skipw, ' '))))
				*t++ = ' ';
a302 8
		/* check to skip whitespace at start, but also after ( */
		if(skipw && i==0 && !com && !quoted && lc != '\\') {
			if(strchr(skipw, c)) {
				lc = c;
				continue;
			}
		}

d305 1
a305 2
			/* we can only exit if no parens or user tracks them */
                        if (c == *d && lc != '\\' && (p == 0 || par)) {
d328 1
a328 1
	if (!par && p != 0) {
d334 1
a334 5
	if(*del == '"')
		/* do not skip over quotes after the string, they are part
		 * of the next string.  But skip over whitespace (if needed)*/
		sldns_bskipcs(b, del+1);
	else 	sldns_bskipcs(b, del);
d337 1
a337 1
	if (!par && p != 0) {
d345 1
a345 1
sldns_bskipcs(sldns_buffer *buffer, const char *s)
d347 1
a347 1
        int found;
d351 3
a353 3
        while(sldns_buffer_available_at(buffer, buffer->_position, sizeof(char))) {
                c = (char) sldns_buffer_read_u8_at(buffer, buffer->_position);
                found = 0;
d356 1
a356 1
                                found = 1;
d368 1
a368 1
sldns_fskipcs(FILE *fp, const char *s)
d370 1
a370 1
	sldns_fskipcs_l(fp, s, NULL);
d374 1
a374 1
sldns_fskipcs_l(FILE *fp, const char *s, int *line_nr)
d376 1
a376 1
        int found;
d384 1
a384 1
                found = 0;
d387 1
a387 1
                                found = 1;
d399 1
a399 1
sldns_bget_keyword_data(sldns_buffer *b, const char *keyword, const char *k_del, char
d408 1
a408 1
       fkeyword = (char*)malloc(LDNS_MAX_KEYWORDLEN);
d412 1
a412 1
       i = sldns_bget_token(b, fkeyword, k_del, data_limit);
d414 1
a414 1
               free(fkeyword);
d420 1
a420 1
               free(fkeyword);
d423 1
a423 1
               i = sldns_bget_token(b, data, d_del, 0);
d426 1
a426 1
               free(fkeyword);
@


1.1.1.6
log
@update to Unbound 1.5.0, ok sthen@@
@
text
@a220 11
int
sldns_bgetc(sldns_buffer *buffer)
{
	if (!sldns_buffer_available_at(buffer, buffer->_position, sizeof(uint8_t))) {
		sldns_buffer_set_position(buffer, sldns_buffer_limit(buffer));
		/* sldns_buffer_rewind(buffer);*/
		return EOF;
	}
	return (int)sldns_buffer_read_u8(buffer);
}

@


