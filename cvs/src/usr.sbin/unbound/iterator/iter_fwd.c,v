head	1.3;
access;
symbols
	OPENBSD_6_0:1.2.0.2
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.6.0.2
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.4
	OPENBSD_5_8_BASE:1.1.1.6
	UNBOUND_1_5_4:1.1.1.6
	OPENBSD_5_7:1.1.1.5.0.6
	OPENBSD_5_7_BASE:1.1.1.5
	UNBOUND_1_5_2RC1:1.1.1.5
	UNBOUND_1_5_1:1.1.1.5
	UNBOUND_1_5_0:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	UNBOUND_1_4_22:1.1.1.5
	OPENBSD_5_5:1.1.1.4.0.4
	OPENBSD_5_5_BASE:1.1.1.4
	UNBOUND_1_4_21:1.1.1.4
	OPENBSD_5_4:1.1.1.3.0.4
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.2
	OPENBSD_5_3_BASE:1.1.1.3
	UNBOUND_1_4_18:1.1.1.3
	UNBOUND_1_4_17:1.1.1.2
	OPENBSD_5_2:1.1.1.1.0.2
	OPENBSD_5_2_BASE:1.1.1.1
	UNBOUND_1_4_16:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2017.02.17.18.53.32;	author sthen;	state Exp;
branches;
next	1.2;
commitid	R6rMbeA8TNhmzWB4;

1.2
date	2016.06.22.20.05.40;	author sthen;	state Exp;
branches;
next	1.1;
commitid	EnU0HAX1qep1MppE;

1.1
date	2012.03.26.18.05.43;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.03.26.18.05.43;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.08.23.22.36.30;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.08.23.22.56.30;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.22.11.31.12;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.16.11.38.25;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2015.07.16.01.42.20;	author sthen;	state Exp;
branches;
next	;
commitid	kEVXcRu8XDMmCd6c;


desc
@@


1.3
log
@Update to unbound-1.6.1rc3 - thanks millert@@ and Brad for tests.
@
text
@/*
 * iterator/iter_fwd.c - iterative resolver module forward zones.
 *
 * Copyright (c) 2007, NLnet Labs. All rights reserved.
 *
 * This software is open source.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * Neither the name of the NLNET LABS nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * \file
 *
 * This file contains functions to assist the iterator module.
 * Keep track of forward zones and config settings.
 */
#include "config.h"
#include "iterator/iter_fwd.h"
#include "iterator/iter_delegpt.h"
#include "util/log.h"
#include "util/config_file.h"
#include "util/net_help.h"
#include "util/data/dname.h"
#include "sldns/rrdef.h"
#include "sldns/str2wire.h"

int
fwd_cmp(const void* k1, const void* k2)
{
	int m;
	struct iter_forward_zone* n1 = (struct iter_forward_zone*)k1;
	struct iter_forward_zone* n2 = (struct iter_forward_zone*)k2;
	if(n1->dclass != n2->dclass) {
		if(n1->dclass < n2->dclass)
			return -1;
		return 1;
	}
	return dname_lab_cmp(n1->name, n1->namelabs, n2->name, n2->namelabs, 
		&m);
}

struct iter_forwards* 
forwards_create(void)
{
	struct iter_forwards* fwd = (struct iter_forwards*)calloc(1,
		sizeof(struct iter_forwards));
	if(!fwd)
		return NULL;
	return fwd;
}

static void fwd_zone_free(struct iter_forward_zone* n)
{
	if(!n) return;
	delegpt_free_mlc(n->dp);
	free(n->name);
	free(n);
}

static void delfwdnode(rbnode_type* n, void* ATTR_UNUSED(arg))
{
	struct iter_forward_zone* node = (struct iter_forward_zone*)n;
	fwd_zone_free(node);
}

static void fwd_del_tree(struct iter_forwards* fwd)
{
	if(fwd->tree)
		traverse_postorder(fwd->tree, &delfwdnode, NULL);
	free(fwd->tree);
}

void 
forwards_delete(struct iter_forwards* fwd)
{
	if(!fwd) 
		return;
	fwd_del_tree(fwd);
	free(fwd);
}

/** insert info into forward structure */
static int
forwards_insert_data(struct iter_forwards* fwd, uint16_t c, uint8_t* nm, 
	size_t nmlen, int nmlabs, struct delegpt* dp)
{
	struct iter_forward_zone* node = (struct iter_forward_zone*)malloc(
		sizeof(struct iter_forward_zone));
	if(!node) {
		delegpt_free_mlc(dp);
		return 0;
	}
	node->node.key = node;
	node->dclass = c;
	node->name = memdup(nm, nmlen);
	if(!node->name) {
		delegpt_free_mlc(dp);
		free(node);
		return 0;
	}
	node->namelen = nmlen;
	node->namelabs = nmlabs;
	node->dp = dp;
	if(!rbtree_insert(fwd->tree, &node->node)) {
		char buf[257];
		dname_str(nm, buf);
		log_err("duplicate forward zone %s ignored.", buf);
		delegpt_free_mlc(dp);
		free(node->name);
		free(node);
	}
	return 1;
}

/** insert new info into forward structure given dp */
static int
forwards_insert(struct iter_forwards* fwd, uint16_t c, struct delegpt* dp)
{
	return forwards_insert_data(fwd, c, dp->name, dp->namelen,
		dp->namelabs, dp);
}

/** initialise parent pointers in the tree */
static void
fwd_init_parents(struct iter_forwards* fwd)
{
	struct iter_forward_zone* node, *prev = NULL, *p;
	int m;
	RBTREE_FOR(node, struct iter_forward_zone*, fwd->tree) {
		node->parent = NULL;
		if(!prev || prev->dclass != node->dclass) {
			prev = node;
			continue;
		}
		(void)dname_lab_cmp(prev->name, prev->namelabs, node->name,
			node->namelabs, &m); /* we know prev is smaller */
		/* sort order like: . com. bla.com. zwb.com. net. */
		/* find the previous, or parent-parent-parent */
		for(p = prev; p; p = p->parent)
			/* looking for name with few labels, a parent */
			if(p->namelabs <= m) {
				/* ==: since prev matched m, this is closest*/
				/* <: prev matches more, but is not a parent,
				 * this one is a (grand)parent */
				node->parent = p;
				break;
			}
		prev = node;
	}
}

/** set zone name */
static struct delegpt* 
read_fwds_name(struct config_stub* s)
{
	struct delegpt* dp;
	uint8_t* dname;
	size_t dname_len;
	if(!s->name) {
		log_err("forward zone without a name (use name \".\" to forward everything)");
		return NULL;
	}
	dname = sldns_str2wire_dname(s->name, &dname_len);
	if(!dname) {
		log_err("cannot parse forward zone name %s", s->name);
		return NULL;
	}
	if(!(dp=delegpt_create_mlc(dname))) {
		free(dname);
		log_err("out of memory");
		return NULL;
	}
	free(dname);
	return dp;
}

/** set fwd host names */
static int 
read_fwds_host(struct config_stub* s, struct delegpt* dp)
{
	struct config_strlist* p;
	uint8_t* dname;
	size_t dname_len;
	for(p = s->hosts; p; p = p->next) {
		log_assert(p->str);
		dname = sldns_str2wire_dname(p->str, &dname_len);
		if(!dname) {
			log_err("cannot parse forward %s server name: '%s'", 
				s->name, p->str);
			return 0;
		}
		if(!delegpt_add_ns_mlc(dp, dname, 0)) {
			free(dname);
			log_err("out of memory");
			return 0;
		}
		free(dname);
	}
	return 1;
}

/** set fwd server addresses */
static int 
read_fwds_addr(struct config_stub* s, struct delegpt* dp)
{
	struct config_strlist* p;
	struct sockaddr_storage addr;
	socklen_t addrlen;
	for(p = s->addrs; p; p = p->next) {
		log_assert(p->str);
		if(!extstrtoaddr(p->str, &addr, &addrlen)) {
			log_err("cannot parse forward %s ip address: '%s'", 
				s->name, p->str);
			return 0;
		}
		if(!delegpt_add_addr_mlc(dp, &addr, addrlen, 0, 0)) {
			log_err("out of memory");
			return 0;
		}
	}
	return 1;
}

/** read forwards config */
static int 
read_forwards(struct iter_forwards* fwd, struct config_file* cfg)
{
	struct config_stub* s;
	for(s = cfg->forwards; s; s = s->next) {
		struct delegpt* dp;
		if(!(dp=read_fwds_name(s)))
			return 0;
		if(!read_fwds_host(s, dp) || !read_fwds_addr(s, dp)) {
			delegpt_free_mlc(dp);
			return 0;
		}
		/* set flag that parent side NS information is included.
		 * Asking a (higher up) server on the internet is not useful */
		/* the flag is turned off for 'forward-first' so that the
		 * last resort will ask for parent-side NS record and thus
		 * fallback to the internet name servers on a failure */
		dp->has_parent_side_NS = (uint8_t)!s->isfirst;
		/* use SSL for queries to this forwarder */
		dp->ssl_upstream = (uint8_t)s->ssl_upstream;
		verbose(VERB_QUERY, "Forward zone server list:");
		delegpt_log(VERB_QUERY, dp);
		if(!forwards_insert(fwd, LDNS_RR_CLASS_IN, dp))
			return 0;
	}
	return 1;
}

/** insert a stub hole (if necessary) for stub name */
static int
fwd_add_stub_hole(struct iter_forwards* fwd, uint16_t c, uint8_t* nm)
{
	struct iter_forward_zone key;
	key.node.key = &key;
	key.dclass = c;
	key.name = nm;
	key.namelabs = dname_count_size_labels(key.name, &key.namelen);
	return forwards_insert_data(fwd, key.dclass, key.name,
		key.namelen, key.namelabs, NULL);
}

/** make NULL entries for stubs */
static int
make_stub_holes(struct iter_forwards* fwd, struct config_file* cfg)
{
	struct config_stub* s;
	uint8_t* dname;
	size_t dname_len;
	for(s = cfg->stubs; s; s = s->next) {
		if(!s->name) continue;
		dname = sldns_str2wire_dname(s->name, &dname_len);
		if(!dname) {
			log_err("cannot parse stub name '%s'", s->name);
			return 0;
		}
		if(!fwd_add_stub_hole(fwd, LDNS_RR_CLASS_IN, dname)) {
			free(dname);
			log_err("out of memory");
			return 0;
		}
		free(dname);
	}
	return 1;
}

int 
forwards_apply_cfg(struct iter_forwards* fwd, struct config_file* cfg)
{
	fwd_del_tree(fwd);
	fwd->tree = rbtree_create(fwd_cmp);
	if(!fwd->tree)
		return 0;

	/* read forward zones */
	if(!read_forwards(fwd, cfg))
		return 0;
	if(!make_stub_holes(fwd, cfg))
		return 0;
	fwd_init_parents(fwd);
	return 1;
}

struct delegpt* 
forwards_find(struct iter_forwards* fwd, uint8_t* qname, uint16_t qclass)
{
	rbnode_type* res = NULL;
	struct iter_forward_zone key;
	key.node.key = &key;
	key.dclass = qclass;
	key.name = qname;
	key.namelabs = dname_count_size_labels(qname, &key.namelen);
	res = rbtree_search(fwd->tree, &key);
	if(res) return ((struct iter_forward_zone*)res)->dp;
	return NULL;
}

struct delegpt* 
forwards_lookup(struct iter_forwards* fwd, uint8_t* qname, uint16_t qclass)
{
	/* lookup the forward zone in the tree */
	rbnode_type* res = NULL;
	struct iter_forward_zone *result;
	struct iter_forward_zone key;
	key.node.key = &key;
	key.dclass = qclass;
	key.name = qname;
	key.namelabs = dname_count_size_labels(qname, &key.namelen);
	if(rbtree_find_less_equal(fwd->tree, &key, &res)) {
		/* exact */
		result = (struct iter_forward_zone*)res;
	} else {
		/* smaller element (or no element) */
		int m;
		result = (struct iter_forward_zone*)res;
		if(!result || result->dclass != qclass)
			return NULL;
		/* count number of labels matched */
		(void)dname_lab_cmp(result->name, result->namelabs, key.name,
			key.namelabs, &m);
		while(result) { /* go up until qname is subdomain of stub */
			if(result->namelabs <= m)
				break;
			result = result->parent;
		}
	}
	if(result)
		return result->dp;
	return NULL;
}

struct delegpt* 
forwards_lookup_root(struct iter_forwards* fwd, uint16_t qclass)
{
	uint8_t root = 0;
	return forwards_lookup(fwd, &root, qclass);
}

int
forwards_next_root(struct iter_forwards* fwd, uint16_t* dclass)
{
	struct iter_forward_zone key;
	rbnode_type* n;
	struct iter_forward_zone* p;
	if(*dclass == 0) {
		/* first root item is first item in tree */
		n = rbtree_first(fwd->tree);
		if(n == RBTREE_NULL)
			return 0;
		p = (struct iter_forward_zone*)n;
		if(dname_is_root(p->name)) {
			*dclass = p->dclass;
			return 1;
		}
		/* root not first item? search for higher items */
		*dclass = p->dclass + 1;
		return forwards_next_root(fwd, dclass);
	}
	/* find class n in tree, we may get a direct hit, or if we don't
	 * this is the last item of the previous class so rbtree_next() takes
	 * us to the next root (if any) */
	key.node.key = &key;
	key.name = (uint8_t*)"\000";
	key.namelen = 1;
	key.namelabs = 0;
	key.dclass = *dclass;
	n = NULL;
	if(rbtree_find_less_equal(fwd->tree, &key, &n)) {
		/* exact */
		return 1;
	} else {
		/* smaller element */
		if(!n || n == RBTREE_NULL)
			return 0; /* nothing found */
		n = rbtree_next(n);
		if(n == RBTREE_NULL)
			return 0; /* no higher */
		p = (struct iter_forward_zone*)n;
		if(dname_is_root(p->name)) {
			*dclass = p->dclass;
			return 1;
		}
		/* not a root node, return next higher item */
		*dclass = p->dclass+1;
		return forwards_next_root(fwd, dclass);
	}
}

size_t 
forwards_get_mem(struct iter_forwards* fwd)
{
	struct iter_forward_zone* p;
	size_t s;
	if(!fwd)
		return 0;
	s = sizeof(*fwd) + sizeof(*fwd->tree);
	RBTREE_FOR(p, struct iter_forward_zone*, fwd->tree) {
		s += sizeof(*p) + p->namelen + delegpt_get_mem(p->dp);
	}
	return s;
}

static struct iter_forward_zone*
fwd_zone_find(struct iter_forwards* fwd, uint16_t c, uint8_t* nm)
{
	struct iter_forward_zone key;
	key.node.key = &key;
	key.dclass = c;
	key.name = nm;
	key.namelabs = dname_count_size_labels(nm, &key.namelen);
	return (struct iter_forward_zone*)rbtree_search(fwd->tree, &key);
}

int 
forwards_add_zone(struct iter_forwards* fwd, uint16_t c, struct delegpt* dp)
{
	struct iter_forward_zone *z;
	if((z=fwd_zone_find(fwd, c, dp->name)) != NULL) {
		(void)rbtree_delete(fwd->tree, &z->node);
		fwd_zone_free(z);
	}
	if(!forwards_insert(fwd, c, dp))
		return 0;
	fwd_init_parents(fwd);
	return 1;
}

void 
forwards_delete_zone(struct iter_forwards* fwd, uint16_t c, uint8_t* nm)
{
	struct iter_forward_zone *z;
	if(!(z=fwd_zone_find(fwd, c, nm)))
		return; /* nothing to do */
	(void)rbtree_delete(fwd->tree, &z->node);
	fwd_zone_free(z);
	fwd_init_parents(fwd);
}

int
forwards_add_stub_hole(struct iter_forwards* fwd, uint16_t c, uint8_t* nm)
{
	if(!fwd_add_stub_hole(fwd, c, nm)) {
		return 0;
	}
	fwd_init_parents(fwd);
	return 1;
}

void
forwards_delete_stub_hole(struct iter_forwards* fwd, uint16_t c, uint8_t* nm)
{
	struct iter_forward_zone *z;
	if(!(z=fwd_zone_find(fwd, c, nm)))
		return; /* nothing to do */
	if(z->dp != NULL)
		return; /* not a stub hole */
	(void)rbtree_delete(fwd->tree, &z->node);
	fwd_zone_free(z);
	fwd_init_parents(fwd);
}

@


1.2
log
@update to unbound-1.5.9. (there will be a follow-up commit to cherrypick a
couple of post-1.5.9 patches).

tests from Mark Patruck, danj, matthieu, millert. reads ok to jung, ok florian.
@
text
@d85 1
a85 1
static void delfwdnode(rbnode_t* n, void* ATTR_UNUSED(arg))
d268 2
d335 1
a335 1
	rbnode_t* res = NULL;
d350 1
a350 1
	rbnode_t* res = NULL;
d391 1
a391 1
	rbnode_t* n;
@


1.1
log
@Initial revision
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
a42 3
#include <ldns/rdata.h>
#include <ldns/dname.h>
#include <ldns/rr.h>
a44 1
#include "util/regional.h"
d49 2
a73 5
	fwd->region = regional_create();
	if(!fwd->region) {
		forwards_delete(fwd);
		return NULL;
	}
d77 21
d103 1
a103 2
	regional_destroy(fwd->region);
	free(fwd->tree);
d112 1
a112 1
	struct iter_forward_zone* node = regional_alloc(fwd->region,
d114 2
a115 1
	if(!node)
d117 1
d120 4
a123 2
	node->name = regional_alloc_init(fwd->region, nm, nmlen);
	if(!node->name)
d125 1
d130 6
a135 1
		log_err("duplicate forward zone ignored.");
d178 2
a179 3
static int 
read_fwds_name(struct iter_forwards* fwd, struct config_stub* s, 
	struct delegpt* dp)
d181 3
a183 1
	ldns_rdf* rdf;
d186 1
a186 1
		return 0;
d188 2
a189 2
	rdf = ldns_dname_new_frm_str(s->name);
	if(!rdf) {
d191 1
a191 1
		return 0;
d193 2
a194 2
	if(!delegpt_set_name(dp, fwd->region, ldns_rdf_data(rdf))) {
		ldns_rdf_deep_free(rdf);
d196 1
a196 1
		return 0;
d198 2
a199 2
	ldns_rdf_deep_free(rdf);
	return 1;
d204 1
a204 2
read_fwds_host(struct iter_forwards* fwd, struct config_stub* s, 
	struct delegpt* dp)
d207 2
a208 1
	ldns_rdf* rdf;
d211 2
a212 2
		rdf = ldns_dname_new_frm_str(p->str);
		if(!rdf) {
d217 2
a218 2
		if(!delegpt_add_ns(dp, fwd->region, ldns_rdf_data(rdf), 0)) {
			ldns_rdf_deep_free(rdf);
d222 1
a222 1
		ldns_rdf_deep_free(rdf);
d229 1
a229 2
read_fwds_addr(struct iter_forwards* fwd, struct config_stub* s, 
	struct delegpt* dp)
d241 1
a241 1
		if(!delegpt_add_addr(dp, fwd->region, &addr, addrlen, 0, 0)) {
d255 5
a259 3
		struct delegpt* dp = delegpt_create(fwd->region);
		if(!dp) {
			log_err("out of memory");
d264 6
a269 5
		dp->has_parent_side_NS = 1;
		if(!read_fwds_name(fwd, s, dp) ||
			!read_fwds_host(fwd, s, dp) ||
			!read_fwds_addr(fwd, s, dp))
			return 0;
a271 2
		verbose(VERB_QUERY, "Forward zone server list:");
		delegpt_log(VERB_QUERY, dp);
d276 1
a276 1
/** see if zone needs to have a hole inserted */
d278 1
a278 1
need_hole_insert(rbtree_t* tree, struct iter_forward_zone* zone)
d280 7
a286 13
	struct iter_forward_zone k;
	if(rbtree_search(tree, zone))
		return 0; /* exact match exists */
	k = *zone;
	k.node.key = &k;
	/* search up the tree */
	do {
		dname_remove_label(&k.name, &k.namelen);
		k.namelabs --;
		if(rbtree_search(tree, &k))
			return 1; /* found an upper forward zone, need hole */
	} while(k.namelabs > 1);
	return 0; /* no forwards above, no holes needed */
d294 2
a295 3
	struct iter_forward_zone key;
	key.node.key = &key;
	key.dclass = LDNS_RR_CLASS_IN;
d297 3
a299 2
		ldns_rdf* rdf = ldns_dname_new_frm_str(s->name);
		if(!rdf) {
d303 2
a304 9
		key.name = ldns_rdf_data(rdf);
		key.namelabs = dname_count_size_labels(key.name, &key.namelen);
		if(!need_hole_insert(fwd->tree, &key)) {
			ldns_rdf_deep_free(rdf);
			continue;
		}
		if(!forwards_insert_data(fwd, key.dclass, key.name, 
			key.namelen, key.namelabs, NULL)) {
			ldns_rdf_deep_free(rdf);
d308 1
a308 1
		ldns_rdf_deep_free(rdf);
d316 1
a316 2
	free(fwd->tree);
	regional_free_all(fwd->region);
d331 14
d438 2
d442 16
a457 2
	return sizeof(*fwd) + sizeof(*fwd->tree) + 
		regional_get_mem(fwd->region);
d463 5
d477 23
a499 6
	struct iter_forward_zone key;
	key.node.key = &key;
	key.dclass = c;
	key.name = nm;
	key.namelabs = dname_count_size_labels(nm, &key.namelen);
	if(!rbtree_search(fwd->tree, &key))
d501 4
a504 1
	(void)rbtree_delete(fwd->tree, &key);
@


1.1.1.1
log
@Import Unbound 1.4.16 to work on in-tree (not yet linked to the build).

These are the direct sources from NLnet Labs upstream, minus these:
compat contrib libunbound/python pythonmod testcode testdata winrc

ok deraadt@@ jakob@@
@
text
@@


1.1.1.2
log
@update to unbound 1.4.17, testing by okan@@ (not yet linked to build;
1.4.18 to follow later).
@
text
@d48 1
d76 5
a83 21
static void fwd_zone_free(struct iter_forward_zone* n)
{
	if(!n) return;
	delegpt_free_mlc(n->dp);
	free(n->name);
	free(n);
}

static void delfwdnode(rbnode_t* n, void* ATTR_UNUSED(arg))
{
	struct iter_forward_zone* node = (struct iter_forward_zone*)n;
	fwd_zone_free(node);
}

static void fwd_del_tree(struct iter_forwards* fwd)
{
	if(fwd->tree)
		traverse_postorder(fwd->tree, &delfwdnode, NULL);
	free(fwd->tree);
}

d89 2
a90 1
	fwd_del_tree(fwd);
d99 1
a99 1
	struct iter_forward_zone* node = (struct iter_forward_zone*)malloc(
d101 1
a101 2
	if(!node) {
		delegpt_free_mlc(dp);
a102 1
	}
d105 2
a106 4
	node->name = memdup(nm, nmlen);
	if(!node->name) {
		delegpt_free_mlc(dp);
		free(node);
a107 1
	}
a112 3
		delegpt_free_mlc(dp);
		free(node->name);
		free(node);
d155 3
a157 2
static struct delegpt* 
read_fwds_name(struct config_stub* s)
a158 1
	struct delegpt* dp;
d162 1
a162 1
		return NULL;
d167 1
a167 1
		return NULL;
d169 1
a169 1
	if(!(dp=delegpt_create_mlc(ldns_rdf_data(rdf)))) {
d172 1
a172 1
		return NULL;
d175 1
a175 1
	return dp;
d180 2
a181 1
read_fwds_host(struct config_stub* s, struct delegpt* dp)
d193 1
a193 1
		if(!delegpt_add_ns_mlc(dp, ldns_rdf_data(rdf), 0)) {
d205 2
a206 1
read_fwds_addr(struct config_stub* s, struct delegpt* dp)
d218 1
a218 1
		if(!delegpt_add_addr_mlc(dp, &addr, addrlen, 0, 0)) {
d232 3
a234 4
		struct delegpt* dp;
		if(!(dp=read_fwds_name(s)) ||
			!read_fwds_host(s, dp) ||
			!read_fwds_addr(s, dp))
d236 1
d239 5
a243 4
		/* the flag is turned off for 'forward-first' so that the
		 * last resort will ask for parent-side NS record and thus
		 * fallback to the internet name servers on a failure */
		dp->has_parent_side_NS = (uint8_t)!s->isfirst;
a270 16
/** insert a stub hole (if necessary) for stub name */
static int
fwd_add_stub_hole(struct iter_forwards* fwd, uint16_t c, uint8_t* nm)
{
	struct iter_forward_zone key;
	key.node.key = &key;
	key.dclass = c;
	key.name = nm;
	key.namelabs = dname_count_size_labels(key.name, &key.namelen);
	if(need_hole_insert(fwd->tree, &key)) {
		return forwards_insert_data(fwd, key.dclass, key.name,
			key.namelen, key.namelabs, NULL);
	}
	return 1;
}

d276 3
d285 8
a292 2
		if(!fwd_add_stub_hole(fwd, LDNS_RR_CLASS_IN,
				ldns_rdf_data(rdf))) {
d305 2
a306 1
	fwd_del_tree(fwd);
a413 2
	struct iter_forward_zone* p;
	size_t s;
d416 2
a417 16
	s = sizeof(*fwd) + sizeof(*fwd->tree);
	RBTREE_FOR(p, struct iter_forward_zone*, fwd->tree) {
		s += sizeof(*p) + p->namelen + delegpt_get_mem(p->dp);
	}
	return s;
}

static struct iter_forward_zone*
fwd_zone_find(struct iter_forwards* fwd, uint16_t c, uint8_t* nm)
{
	struct iter_forward_zone key;
	key.node.key = &key;
	key.dclass = c;
	key.name = nm;
	key.namelabs = dname_count_size_labels(nm, &key.namelen);
	return (struct iter_forward_zone*)rbtree_search(fwd->tree, &key);
a422 5
	struct iter_forward_zone *z;
	if((z=fwd_zone_find(fwd, c, dp->name)) != NULL) {
		(void)rbtree_delete(fwd->tree, &z->node);
		fwd_zone_free(z);
	}
d432 6
a437 23
	struct iter_forward_zone *z;
	if(!(z=fwd_zone_find(fwd, c, nm)))
		return; /* nothing to do */
	(void)rbtree_delete(fwd->tree, &z->node);
	fwd_zone_free(z);
	fwd_init_parents(fwd);
}

int
forwards_add_stub_hole(struct iter_forwards* fwd, uint16_t c, uint8_t* nm)
{
	if(!fwd_add_stub_hole(fwd, c, nm)) {
		return 0;
	}
	fwd_init_parents(fwd);
	return 1;
}

void
forwards_delete_stub_hole(struct iter_forwards* fwd, uint16_t c, uint8_t* nm)
{
	struct iter_forward_zone *z;
	if(!(z=fwd_zone_find(fwd, c, nm)))
d439 1
a439 4
	if(z->dp != NULL)
		return; /* not a stub hole */
	(void)rbtree_delete(fwd->tree, &z->node);
	fwd_zone_free(z);
@


1.1.1.3
log
@update to unbound 1.4.18
@
text
@d253 3
a255 1
		if(!(dp=read_fwds_name(s)))
a256 4
		if(!read_fwds_host(s, dp) || !read_fwds_addr(s, dp)) {
			delegpt_free_mlc(dp);
			return 0;
		}
d263 2
a266 2
		if(!forwards_insert(fwd, LDNS_RR_CLASS_IN, dp))
			return 0;
@


1.1.1.4
log
@update to Unbound 1.4.21, ok brad@@
@
text
@d131 1
a131 3
		char buf[257];
		dname_str(nm, buf);
		log_err("duplicate forward zone %s ignored.", buf);
d273 19
d301 5
a305 2
	return forwards_insert_data(fwd, key.dclass, key.name,
		key.namelen, key.namelabs, NULL);
a344 14
}

struct delegpt* 
forwards_find(struct iter_forwards* fwd, uint8_t* qname, uint16_t qclass)
{
	rbnode_t* res = NULL;
	struct iter_forward_zone key;
	key.node.key = &key;
	key.dclass = qclass;
	key.name = qname;
	key.namelabs = dname_count_size_labels(qname, &key.namelen);
	res = rbtree_search(fwd->tree, &key);
	if(res) return ((struct iter_forward_zone*)res)->dp;
	return NULL;
@


1.1.1.5
log
@import unbound 1.4.22 upstream sources, ok brad@@
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d43 3
a51 2
#include "ldns/rrdef.h"
#include "ldns/str2wire.h"
d183 1
a183 2
	uint8_t* dname;
	size_t dname_len;
d188 2
a189 2
	dname = sldns_str2wire_dname(s->name, &dname_len);
	if(!dname) {
d193 2
a194 2
	if(!(dp=delegpt_create_mlc(dname))) {
		free(dname);
d198 1
a198 1
	free(dname);
d207 1
a207 2
	uint8_t* dname;
	size_t dname_len;
d210 2
a211 2
		dname = sldns_str2wire_dname(p->str, &dname_len);
		if(!dname) {
d216 2
a217 2
		if(!delegpt_add_ns_mlc(dp, dname, 0)) {
			free(dname);
d221 1
a221 1
		free(dname);
a292 2
	uint8_t* dname;
	size_t dname_len;
d294 2
a295 2
		dname = sldns_str2wire_dname(s->name, &dname_len);
		if(!dname) {
d299 3
a301 2
		if(!fwd_add_stub_hole(fwd, LDNS_RR_CLASS_IN, dname)) {
			free(dname);
d305 1
a305 1
		free(dname);
@


1.1.1.6
log
@update to Unbound 1.5.4, ok florian@@, looks sane deraadt@@
@
text
@d49 2
a50 2
#include "sldns/rrdef.h"
#include "sldns/str2wire.h"
@


