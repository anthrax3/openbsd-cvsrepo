head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.4.0.8
	OPENBSD_6_2_BASE:1.1.1.4
	OPENBSD_6_1:1.1.1.4.0.10
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.6
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.2
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	UNBOUND_1_5_4:1.1.1.4
	OPENBSD_5_7:1.1.1.3.0.6
	OPENBSD_5_7_BASE:1.1.1.3
	UNBOUND_1_5_2RC1:1.1.1.3
	UNBOUND_1_5_1:1.1.1.3
	UNBOUND_1_5_0:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	UNBOUND_1_4_22:1.1.1.3
	OPENBSD_5_5:1.1.1.2.0.4
	OPENBSD_5_5_BASE:1.1.1.2
	UNBOUND_1_4_21:1.1.1.2
	OPENBSD_5_4:1.1.1.1.0.6
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.4
	OPENBSD_5_3_BASE:1.1.1.1
	UNBOUND_1_4_18:1.1.1.1
	UNBOUND_1_4_17:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.2
	OPENBSD_5_2_BASE:1.1.1.1
	UNBOUND_1_4_16:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2012.03.26.18.05.43;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.03.26.18.05.43;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.22.11.31.10;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.16.11.38.24;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2015.07.16.01.42.20;	author sthen;	state Exp;
branches;
next	;
commitid	kEVXcRu8XDMmCd6c;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * iterator/iter_priv.c - iterative resolver private address and domain store
 *
 * Copyright (c) 2008, NLnet Labs. All rights reserved.
 *
 * This software is open source.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * Neither the name of the NLNET LABS nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * \file
 *
 * This file contains functions to assist the iterator module.
 * Keep track of the private addresses and lookup fast.
 */

#include "config.h"
#include <ldns/dname.h>
#include "iterator/iter_priv.h"
#include "util/regional.h"
#include "util/log.h"
#include "util/config_file.h"
#include "util/data/dname.h"
#include "util/data/msgparse.h"
#include "util/net_help.h"
#include "util/storage/dnstree.h"

struct iter_priv* priv_create(void)
{
	struct iter_priv* priv = (struct iter_priv*)calloc(1, sizeof(*priv));
	if(!priv)
		return NULL;
	priv->region = regional_create();
	if(!priv->region) {
		priv_delete(priv);
		return NULL;
	}
	addr_tree_init(&priv->a);
	name_tree_init(&priv->n);
	return priv;
}

void priv_delete(struct iter_priv* priv)
{
	if(!priv) return;
	regional_destroy(priv->region);
	free(priv);
}

/** Read private-addr declarations from config */
static int read_addrs(struct iter_priv* priv, struct config_file* cfg)
{
	/* parse addresses, report errors, insert into tree */
	struct config_strlist* p;
	struct addr_tree_node* n;
	struct sockaddr_storage addr;
	int net;
	socklen_t addrlen;

	for(p = cfg->private_address; p; p = p->next) {
		log_assert(p->str);
		if(!netblockstrtoaddr(p->str, UNBOUND_DNS_PORT, &addr, 
			&addrlen, &net)) {
			log_err("cannot parse private-address: %s", p->str);
			return 0;
		}
		n = (struct addr_tree_node*)regional_alloc(priv->region,
			sizeof(*n));
		if(!n) {
			log_err("out of memory");
			return 0;
		}
		if(!addr_tree_insert(&priv->a, n, &addr, addrlen, net)) {
			verbose(VERB_QUERY, "ignoring duplicate "
				"private-address: %s", p->str);
		}
	}
	return 1;
}

/** Read private-domain declarations from config */
static int read_names(struct iter_priv* priv, struct config_file* cfg)
{
	/* parse names, report errors, insert into tree */
	struct config_strlist* p;
	struct name_tree_node* n;
	uint8_t* nm;
	size_t nm_len;
	int nm_labs;
	ldns_rdf* rdf;

	for(p = cfg->private_domain; p; p = p->next) {
		log_assert(p->str);
		rdf = ldns_dname_new_frm_str(p->str);
		if(!rdf) {
			log_err("cannot parse private-domain: %s", p->str);
			return 0;
		}
		nm = ldns_rdf_data(rdf);
		nm_labs = dname_count_size_labels(nm, &nm_len);
		nm = (uint8_t*)regional_alloc_init(priv->region, nm, nm_len);
		ldns_rdf_deep_free(rdf);
		if(!nm) {
			log_err("out of memory");
			return 0;
		}
		n = (struct name_tree_node*)regional_alloc(priv->region,
			sizeof(*n));
		if(!n) {
			log_err("out of memory");
			return 0;
		}
		if(!name_tree_insert(&priv->n, n, nm, nm_len, nm_labs,
			LDNS_RR_CLASS_IN)) {
			verbose(VERB_QUERY, "ignoring duplicate "
				"private-domain: %s", p->str);
		}
	}
	return 1;
}

int priv_apply_cfg(struct iter_priv* priv, struct config_file* cfg)
{
	/* empty the current contents */
	regional_free_all(priv->region);
	addr_tree_init(&priv->a);
	name_tree_init(&priv->n);

	/* read new contents */
	if(!read_addrs(priv, cfg))
		return 0;
	if(!read_names(priv, cfg))
		return 0;

	/* prepare for lookups */
	addr_tree_init_parents(&priv->a);
	name_tree_init_parents(&priv->n);
	return 1;
}

/**
 * See if an address is blocked.
 * @@param priv: structure for address storage.
 * @@param addr: address to check
 * @@param addrlen: length of addr.
 * @@return: true if the address must not be queried. false if unlisted.
 */
static int 
priv_lookup_addr(struct iter_priv* priv, struct sockaddr_storage* addr,
	socklen_t addrlen)
{
	return addr_tree_lookup(&priv->a, addr, addrlen) != NULL;
}

/**
 * See if a name is whitelisted.
 * @@param priv: structure for address storage.
 * @@param pkt: the packet (for compression ptrs).
 * @@param name: name to check.
 * @@param name_len: uncompressed length of the name to check.
 * @@param dclass: class to check.
 * @@return: true if the name is OK. false if unlisted.
 */
static int 
priv_lookup_name(struct iter_priv* priv, ldns_buffer* pkt,
	uint8_t* name, size_t name_len, uint16_t dclass)
{
	size_t len;
	uint8_t decomp[256];
	int labs;
	if(name_len >= sizeof(decomp))
		return 0;
	dname_pkt_copy(pkt, decomp, name);
	labs = dname_count_size_labels(decomp, &len);
	log_assert(name_len == len);
	return name_tree_lookup(&priv->n, decomp, len, labs, dclass) != NULL;
}

size_t priv_get_mem(struct iter_priv* priv)
{
	if(!priv) return 0;
	return sizeof(*priv) + regional_get_mem(priv->region);
}

int priv_rrset_bad(struct iter_priv* priv, ldns_buffer* pkt,
	struct rrset_parse* rrset)
{
	if(priv->a.count == 0) 
		return 0; /* there are no blocked addresses */

	/* see if it is a private name, that is allowed to have any */
	if(priv_lookup_name(priv, pkt, rrset->dname, rrset->dname_len,
		ntohs(rrset->rrset_class))) {
		return 0;
	} else {
		/* so its a public name, check the address */
		socklen_t len;
		struct rr_parse* rr;
		if(rrset->type == LDNS_RR_TYPE_A) {
			struct sockaddr_storage addr;
			struct sockaddr_in sa;

			len = (socklen_t)sizeof(sa);
			memset(&sa, 0, len);
			sa.sin_family = AF_INET;
			sa.sin_port = (in_port_t)htons(UNBOUND_DNS_PORT);
			for(rr = rrset->rr_first; rr; rr = rr->next) {
				if(ldns_read_uint16(rr->ttl_data+4) 
					!= INET_SIZE)
					continue;
				memmove(&sa.sin_addr, rr->ttl_data+4+2, 
					INET_SIZE);
				memmove(&addr, &sa, len);
				if(priv_lookup_addr(priv, &addr, len))
					return 1;
			}
		} else if(rrset->type == LDNS_RR_TYPE_AAAA) {
			struct sockaddr_storage addr;
			struct sockaddr_in6 sa;
			len = (socklen_t)sizeof(sa);
			memset(&sa, 0, len);
			sa.sin6_family = AF_INET6;
			sa.sin6_port = (in_port_t)htons(UNBOUND_DNS_PORT);
			for(rr = rrset->rr_first; rr; rr = rr->next) {
				if(ldns_read_uint16(rr->ttl_data+4) 
					!= INET6_SIZE)
					continue;
				memmove(&sa.sin6_addr, rr->ttl_data+4+2, 
					INET6_SIZE);
				memmove(&addr, &sa, len);
				if(priv_lookup_addr(priv, &addr, len)) 
					return 1;
			}
		} 
	}
	return 0;
}
@


1.1.1.1
log
@Import Unbound 1.4.16 to work on in-tree (not yet linked to the build).

These are the direct sources from NLnet Labs upstream, minus these:
compat contrib libunbound/python pythonmod testcode testdata winrc

ok deraadt@@ jakob@@
@
text
@@


1.1.1.2
log
@update to Unbound 1.4.21, ok brad@@
@
text
@a210 22
/** remove RR from msgparse RRset, return true if rrset is entirely bad */
static int
remove_rr(const char* str, ldns_buffer* pkt, struct rrset_parse* rrset,
	struct rr_parse* prev, struct rr_parse** rr, struct sockaddr_storage* addr, socklen_t addrlen)
{
	if(verbosity >= VERB_QUERY && rrset->dname_len <= LDNS_MAX_DOMAINLEN && str) {
		uint8_t buf[LDNS_MAX_DOMAINLEN+1];
		dname_pkt_copy(pkt, buf, rrset->dname);
		log_name_addr(VERB_QUERY, str, buf, addr, addrlen);
	}
	if(prev)
		prev->next = (*rr)->next;
	else	rrset->rr_first = (*rr)->next;
	if(rrset->rr_last == *rr)
		rrset->rr_last = prev;
	rrset->rr_count --;
	rrset->size -= (*rr)->size;
	/* rr struct still exists, but is unlinked, so that in the for loop
	 * the rr->next works fine to continue. */
	return rrset->rr_count == 0;
}

d224 1
a224 1
		struct rr_parse* rr, *prev = NULL;
d235 1
a235 2
					!= INET_SIZE) {
					prev = rr;
a236 1
				}
d240 2
a241 6
				if(priv_lookup_addr(priv, &addr, len)) {
					if(remove_rr("sanitize: removing public name with private address", pkt, rrset, prev, &rr, &addr, len))
						return 1;
					continue;
				}
				prev = rr;
d252 1
a252 2
					!= INET6_SIZE) {
					prev = rr;
a253 1
				}
d257 2
a258 6
				if(priv_lookup_addr(priv, &addr, len)) {
					if(remove_rr("sanitize: removing public name with private address", pkt, rrset, prev, &rr, &addr, len))
						return 1;
					continue;
				}
				prev = rr;
@


1.1.1.3
log
@import unbound 1.4.22 upstream sources, ok brad@@
@
text
@d24 10
a33 10
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d44 1
a52 2
#include "ldns/str2wire.h"
#include "ldns/sbuffer.h"
d113 1
a113 1
	uint8_t* nm, *nmr;
d116 1
d120 2
a121 2
		nm = sldns_str2wire_dname(p->str, &nm_len);
		if(!nm) {
d125 1
d127 3
a129 3
		nmr = (uint8_t*)regional_alloc_init(priv->region, nm, nm_len);
		free(nm);
		if(!nmr) {
d139 1
a139 1
		if(!name_tree_insert(&priv->n, n, nmr, nm_len, nm_labs,
d191 1
a191 1
priv_lookup_name(struct iter_priv* priv, sldns_buffer* pkt,
d213 1
a213 1
remove_rr(const char* str, sldns_buffer* pkt, struct rrset_parse* rrset,
d233 1
a233 1
int priv_rrset_bad(struct iter_priv* priv, sldns_buffer* pkt,
d256 1
a256 1
				if(sldns_read_uint16(rr->ttl_data+4) 
d279 1
a279 1
				if(sldns_read_uint16(rr->ttl_data+4) 
@


1.1.1.4
log
@update to Unbound 1.5.4, ok florian@@, looks sane deraadt@@
@
text
@d52 2
a53 2
#include "sldns/str2wire.h"
#include "sldns/sbuffer.h"
@


