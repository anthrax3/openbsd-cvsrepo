head	1.78;
access;
symbols
	OPENBSD_6_1:1.77.0.4
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.75.0.2
	OPENBSD_6_0_BASE:1.75
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.64.0.4
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.56.0.4
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.53.0.2
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.50.0.8
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.6
	OPENBSD_5_0:1.50.0.4
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.39.0.4
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.38.0.2
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.36.0.4
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.30.0.6
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.30.0.4
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.14.0.4
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.78
date	2017.04.15.11.50.24;	author bluhm;	state Exp;
branches;
next	1.77;
commitid	ygW0Z733VhPrB9qS;

1.77
date	2016.11.29.08.55.06;	author mpi;	state Exp;
branches;
next	1.76;
commitid	awzig7PvB0qy9Fec;

1.76
date	2016.08.27.04.15.52;	author guenther;	state Exp;
branches;
next	1.75;
commitid	Zg3MbxXm6xOP2dww;

1.75
date	2016.05.28.07.00.18;	author natano;	state Exp;
branches;
next	1.74;
commitid	V3qpA476A18HvhDy;

1.74
date	2016.03.23.08.28.31;	author mpi;	state Exp;
branches;
next	1.73;
commitid	qeMQonNDvbMi7hhb;

1.73
date	2016.03.23.08.19.58;	author mpi;	state Exp;
branches;
next	1.72;
commitid	fOo5LBAaExSHmr2w;

1.72
date	2016.03.23.08.17.35;	author mpi;	state Exp;
branches;
next	1.71;
commitid	ggJ0O4NVSCngtoVB;

1.71
date	2016.01.26.18.26.19;	author mmcc;	state Exp;
branches;
next	1.70;
commitid	W1L20xeSwlpa0n3G;

1.70
date	2015.12.08.14.20.24;	author tedu;	state Exp;
branches;
next	1.69;
commitid	fJqOuqUDX9Gekkfv;

1.69
date	2015.10.14.04.03.01;	author deraadt;	state Exp;
branches;
next	1.68;
commitid	j6oA0vXFCf4XeMWd;

1.68
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	sbrB3Q5CNxcwZpfU;

1.67
date	2015.10.07.20.25.40;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	g2CbzA7PYrR0l6KO;

1.66
date	2015.10.05.14.58.37;	author semarie;	state Exp;
branches;
next	1.65;
commitid	vrlDlnMnrxzqnFLW;

1.65
date	2015.10.03.02.25.59;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	6N4K8Wpvfidm1eM1;

1.64
date	2015.06.03.08.10.53;	author mpi;	state Exp;
branches;
next	1.63;
commitid	E9xoXPx8h6lAYIn5;

1.63
date	2015.01.16.06.40.15;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	Uu5nFG3wCl0LACBb;

1.62
date	2014.09.07.22.40.30;	author bluhm;	state Exp;
branches;
next	1.61;
commitid	NdR4d7j03xj7THfp;

1.61
date	2014.09.03.10.39.41;	author mpi;	state Exp;
branches;
next	1.60;
commitid	tx59KIWMEk8nbHq7;

1.60
date	2014.08.22.22.14.53;	author sthen;	state Exp;
branches;
next	1.59;
commitid	odmil3BlRrGVzOzj;

1.59
date	2014.08.21.10.23.47;	author mpi;	state Exp;
branches;
next	1.58;
commitid	C104FxnkFkT1bTMB;

1.58
date	2014.08.19.12.39.36;	author mpi;	state Exp;
branches;
next	1.57;
commitid	fCh9nGSviO7kTgAQ;

1.57
date	2014.08.11.09.47.56;	author mpi;	state Exp;
branches;
next	1.56;
commitid	UIxLUweL387FY4Lo;

1.56
date	2014.03.18.14.18.22;	author mikeb;	state Exp;
branches;
next	1.55;

1.55
date	2014.02.26.20.50.17;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2013.08.15.13.43.33;	author bluhm;	state Exp;
branches;
next	1.53;

1.53
date	2013.07.20.18.21.11;	author bluhm;	state Exp;
branches;
next	1.52;

1.52
date	2013.03.21.04.43.17;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2012.11.08.11.05.41;	author phessler;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.11.16.34.20;	author jasper;	state Exp;
branches;
next	1.49;

1.49
date	2009.09.27.12.07.15;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.25.15.43.18;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.05.03.54.42;	author chris;	state Exp;
branches;
next	1.46;

1.46
date	2009.06.05.00.13.35;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2008.12.12.20.23.20;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2008.03.12.23.18.59;	author sobrado;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.14.09.28.02;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.07.16.53.58;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.07.15.57.07;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2007.08.24.13.12.16;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.18.23.50.47;	author ray;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.26.09.00.57;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.18.22.11.49;	author moritz;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.04.16.14.45;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.04.09.03.07;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.29.23.55.18;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.29.22.24.48;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.29.21.59.59;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.04.10.57.23;	author pascoe;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.27.22.11.39;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.27.22.11.22;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.11.23.33.25;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.17.23.26.21;	author henric;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.03.22.33.50;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.06.18.33.16;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.26.09.25.21;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.06.51.42;	author mpech;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.16.21.28.00;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.10.17.46.20;	author dugsong;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.07.19.31.58;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.23.14.55.12;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.24.22.12.25;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	99.05.16.00.43.44;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	98.09.29.02.22.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.05.14.21.16.42;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.05.11.01.34.50;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.11.28.05.34.41;	author art;	state Exp;
branches;
next	1.9;

1.9
date	97.11.21.22.42.55;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.09.12.04.07.16;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.06.23.09.32.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.03.00.12.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.43.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.12.10.15.15.39;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.29.03.32.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.07.06.06.52.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.24;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.78
log
@Name global variable for routing socket rtsock like in ndp(8).
OK florian@@
@
text
@/*	$OpenBSD: arp.c,v 1.77 2016/11/29 08:55:06 mpi Exp $ */
/*	$NetBSD: arp.c,v 1.12 1995/04/24 13:25:18 cgd Exp $ */

/*
 * Copyright (c) 1984, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Sun Microsystems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * arp - display, set, delete arp table entries and wake up hosts.
 */

#include <sys/file.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <net/bpf.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

#include <netdb.h>
#include <errno.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>
#include <unistd.h>
#include <limits.h>
#include <ifaddrs.h>

void dump(void);
int delete(const char *);
void search(in_addr_t addr, void (*action)(struct sockaddr_dl *sdl,
	struct sockaddr_inarp *sin, struct rt_msghdr *rtm));
void print_entry(struct sockaddr_dl *sdl,
	struct sockaddr_inarp *sin, struct rt_msghdr *rtm);
void nuke_entry(struct sockaddr_dl *sdl,
	struct sockaddr_inarp *sin, struct rt_msghdr *rtm);
static char *ether_str(struct sockaddr_dl *);
int wake(const char *ether_addr, const char *iface);
int file(char *);
int get(const char *);
int getinetaddr(const char *, struct in_addr *);
void getsocket(void);
int rtget(struct sockaddr_inarp **, struct sockaddr_dl **);
int rtmsg(int);
int set(int, char **);
void usage(void);
static char *sec2str(time_t);

static pid_t pid;
static int replace;	/* replace entries when adding */
static int nflag;	/* no reverse dns lookups */
static int aflag;	/* do it for all entries */
static int rtsock = -1;
static int rdomain;

extern int h_errno;

/* ROUNDUP() is nasty, but it is identical to what's in the kernel. */
#define ROUNDUP(a)					\
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

/* which function we're supposed to do */
#define F_GET		1
#define F_SET		2
#define F_FILESET	3
#define F_DELETE	4
#define F_WAKE		5

int
main(int argc, char *argv[])
{
	int		 ch, func = 0, error = 0;
	const char	*errstr;

	pid = getpid();
	opterr = 0;
	rdomain = getrtable();
	while ((ch = getopt(argc, argv, "andsFfV:W")) != -1) {
		switch (ch) {
		case 'a':
			aflag = 1;
			break;
		case 'n':
			nflag = 1;
			break;
		case 'd':
			if (func)
				usage();
			func = F_DELETE;
			break;
		case 's':
			if (func)
				usage();
			func = F_SET;
			break;
		case 'F':
			replace = 1;
			break;
		case 'f':
			if (func)
				usage();
			func = F_FILESET;
			break;
		case 'V':
			rdomain = strtonum(optarg, 0, RT_TABLEID_MAX, &errstr);
			if (errstr != NULL) {
				warn("bad rdomain: %s", errstr);
				usage();
			}
			break;
		case 'W':
			if (func)
				usage();
			func = F_WAKE;
			break;
		default:
			usage();
			break;
		}
	}
	argc -= optind;
	argv += optind;

	if (!func)
		func = F_GET;

	switch (func) {
	case F_GET:
		if (aflag && argc == 0)
			dump();
		else if (!aflag && argc == 1)
			error = get(argv[0]);
		else
			usage();
		break;
	case F_SET:
		if (argc < 2 || argc > 5)
			usage();
		if (replace)
			delete(argv[0]);
		error = set(argc, argv) ? 1 : 0;
		break;
	case F_DELETE:
		if (aflag && argc == 0)
			search(0, nuke_entry);
		else if (!aflag && argc == 1)
			error = delete(argv[0]);
		else
			usage();
		break;
	case F_FILESET:
		if (argc != 1)
			usage();
		error = file(argv[0]);
		break;
	case F_WAKE:
		if (aflag || nflag || replace || rdomain > 0)
			usage();
		if (argc == 1)
			error = wake(argv[0], NULL);
		else if (argc == 2)
			error = wake(argv[0], argv[1]);
		else
			usage();
		break;
	}
	return (error);
}

/*
 * Process a file to set standard arp entries
 */
int
file(char *name)
{
	char	 line[100], arg[5][50], *args[5];
	int	 i, retval;
	FILE	*fp;

	if ((fp = fopen(name, "r")) == NULL)
		err(1, "cannot open %s", name);
	args[0] = &arg[0][0];
	args[1] = &arg[1][0];
	args[2] = &arg[2][0];
	args[3] = &arg[3][0];
	args[4] = &arg[4][0];
	retval = 0;
	while (fgets(line, sizeof(line), fp) != NULL) {
		i = sscanf(line, "%49s %49s %49s %49s %49s", arg[0], arg[1],
		    arg[2], arg[3], arg[4]);
		if (i < 2) {
			warnx("bad line: %s", line);
			retval = 1;
			continue;
		}
		if (replace)
			delete(arg[0]);
		if (set(i, args))
			retval = 1;
	}
	fclose(fp);
	return (retval);
}

void
getsocket(void)
{
	socklen_t len = sizeof(rdomain);

	if (rtsock >= 0)
		return;
	rtsock = socket(PF_ROUTE, SOCK_RAW, 0);
	if (rtsock < 0)
		err(1, "routing socket");
	if (setsockopt(rtsock, PF_ROUTE, ROUTE_TABLEFILTER, &rdomain, len) < 0)
		err(1, "ROUTE_TABLEFILTER");

	if (pledge("stdio dns", NULL) == -1)
		err(1, "pledge");
}

struct sockaddr_in	so_mask = { 8, 0, 0, { 0xffffffff } };
struct sockaddr_inarp	blank_sin = { sizeof(blank_sin), AF_INET }, sin_m;
struct sockaddr_dl	blank_sdl = { sizeof(blank_sdl), AF_LINK }, sdl_m;
struct sockaddr_dl	ifp_m = { sizeof(&ifp_m), AF_LINK };
time_t			expire_time;
int			flags, export_only, doing_proxy, found_entry;
struct	{
	struct rt_msghdr	m_rtm;
	char			m_space[512];
}	m_rtmsg;

/*
 * Set an individual arp entry
 */
int
set(int argc, char *argv[])
{
	struct sockaddr_inarp *sin;
	struct sockaddr_dl *sdl;
	struct rt_msghdr *rtm;
	char *eaddr = argv[1], *host = argv[0];
	struct ether_addr *ea;

	sin = &sin_m;
	rtm = &(m_rtmsg.m_rtm);

	getsocket();
	argc -= 2;
	argv += 2;
	sdl_m = blank_sdl;		/* struct copy */
	sin_m = blank_sin;		/* struct copy */
	if (getinetaddr(host, &sin->sin_addr) == -1)
		return (1);
	ea = ether_aton(eaddr);
	if (ea == NULL)
		errx(1, "invalid ethernet address: %s", eaddr);
	memcpy(LLADDR(&sdl_m), ea, sizeof(*ea));
	sdl_m.sdl_alen = 6;
	expire_time = 0;
	doing_proxy = flags = export_only = 0;
	while (argc-- > 0) {
		if (strncmp(argv[0], "temp", 4) == 0) {
			struct timeval now;

			gettimeofday(&now, 0);
			expire_time = now.tv_sec + 20 * 60;
			if (flags & RTF_PERMANENT_ARP) {
				/* temp or permanent, not both */
				usage();
				return (0);
			}
		} else if (strncmp(argv[0], "pub", 3) == 0) {
			flags |= RTF_ANNOUNCE;
			doing_proxy = SIN_PROXY;
		} else if (strncmp(argv[0], "permanent", 9) == 0) {
			flags |= RTF_PERMANENT_ARP;
			if (expire_time != 0) {
				/* temp or permanent, not both */
				usage();
				return (0);
			}
		}

		argv++;
	}

tryagain:
	if (rtget(&sin, &sdl)) {
		warn("%s", host);
		return (1);
	}

	if (sin->sin_addr.s_addr == sin_m.sin_addr.s_addr) {
		if (sdl->sdl_family == AF_LINK &&
		    (rtm->rtm_flags & RTF_LLINFO) &&
		    !(rtm->rtm_flags & RTF_GATEWAY))
			switch (sdl->sdl_type) {
			case IFT_ETHER:
			case IFT_FDDI:
			case IFT_ISO88023:
			case IFT_ISO88024:
			case IFT_ISO88025:
			case IFT_CARP:
				goto overwrite;
			}

		if (doing_proxy == 0) {
			printf("set: can only proxy for %s\n", host);
			return (1);
		}
		if (sin_m.sin_other & SIN_PROXY) {
			printf("set: proxy entry exists for non 802 device\n");
			return (1);
		}
		sin_m.sin_other = SIN_PROXY;
		export_only = 1;
		goto tryagain;
	}

overwrite:
	if (sdl->sdl_family != AF_LINK) {
		printf("cannot intuit interface index and type for %s\n", host);
		return (1);
	}
	sdl_m.sdl_type = sdl->sdl_type;
	sdl_m.sdl_index = sdl->sdl_index;
	return (rtmsg(RTM_ADD));
}

#define W_ADDR	36
#define W_LL	17
#define W_IF	7

/*
 * Display an individual arp entry
 */
int
get(const char *host)
{
	struct sockaddr_inarp *sin;

	sin = &sin_m;
	sin_m = blank_sin;		/* struct copy */
	if (getinetaddr(host, &sin->sin_addr) == -1)
		exit(1);

	printf("%-*.*s %-*.*s %*.*s %-9.9s %5s\n",
	    W_ADDR, W_ADDR, "Host", W_LL, W_LL, "Ethernet Address",
	    W_IF, W_IF, "Netif", "Expire", "Flags");

	search(sin->sin_addr.s_addr, print_entry);
	if (found_entry == 0) {
		printf("%-*.*s no entry\n", W_ADDR, W_ADDR,
		    inet_ntoa(sin->sin_addr));
		return (1);
	}
	return (0);
}

/*
 * Delete an arp entry
 */
int
delete(const char *host)
{
	struct sockaddr_inarp *sin;
	struct rt_msghdr *rtm;
	struct sockaddr_dl *sdl;

	sin = &sin_m;
	rtm = &m_rtmsg.m_rtm;

	getsocket();
	sin_m = blank_sin;		/* struct copy */
	if (getinetaddr(host, &sin->sin_addr) == -1)
		return (1);
tryagain:
	if (rtget(&sin, &sdl)) {
		warn("%s", host);
		return (1);
	}
	if (sin->sin_addr.s_addr == sin_m.sin_addr.s_addr) {
		if (sdl->sdl_family == AF_LINK && rtm->rtm_flags & RTF_LLINFO) {
			if (rtm->rtm_flags & RTF_LOCAL)
				return (0);
		    	if (!(rtm->rtm_flags & RTF_GATEWAY))
				switch (sdl->sdl_type) {
				case IFT_ETHER:
				case IFT_FDDI:
				case IFT_ISO88023:
				case IFT_ISO88024:
				case IFT_ISO88025:
				case IFT_CARP:
					goto delete;
				}
		}
	}

	if (sin_m.sin_other & SIN_PROXY) {
		warnx("delete: can't locate %s", host);
		return (1);
	} else {
		sin_m.sin_other = SIN_PROXY;
		goto tryagain;
	}
delete:
	if (sdl->sdl_family != AF_LINK) {
		printf("cannot locate %s\n", host);
		return (1);
	}
	if (rtmsg(RTM_DELETE))
		return (1);
	printf("%s (%s) deleted\n", host, inet_ntoa(sin->sin_addr));
	return (0);
}

/*
 * Search the entire arp table, and do some action on matching entries.
 */
void
search(in_addr_t addr, void (*action)(struct sockaddr_dl *sdl,
    struct sockaddr_inarp *sin, struct rt_msghdr *rtm))
{
	int mib[7];
	size_t needed;
	char *lim, *buf = NULL, *next;
	struct rt_msghdr *rtm;
	struct sockaddr_inarp *sin;
	struct sockaddr_dl *sdl;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_FLAGS;
	mib[5] = RTF_LLINFO;
	mib[6] = rdomain;
	while (1) {
		if (sysctl(mib, 7, NULL, &needed, NULL, 0) == -1)
			err(1, "route-sysctl-estimate");
		if (needed == 0)
			return;
		if ((buf = realloc(buf, needed)) == NULL)
			err(1, "malloc");
		if (sysctl(mib, 7, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			err(1, "actual retrieval of routing table");
		}
		lim = buf + needed;
		break;
	}
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		sin = (struct sockaddr_inarp *)(next + rtm->rtm_hdrlen);
		sdl = (struct sockaddr_dl *)(sin + 1);
		if (addr) {
			if (addr != sin->sin_addr.s_addr)
				continue;
			found_entry = 1;
		}
		(*action)(sdl, sin, rtm);
	}
	free(buf);
}

/*
 * Dump the entire ARP table
 */
void
dump(void)
{
	printf("%-*.*s %-*.*s %*.*s %-9.9s %5s\n",
	    W_ADDR, W_ADDR, "Host", W_LL, W_LL, "Ethernet Address",
	    W_IF, W_IF, "Netif", "Expire", "Flags");

	search(0, print_entry);
}

/*
 * Display an arp entry
 */
void
print_entry(struct sockaddr_dl *sdl, struct sockaddr_inarp *sin,
    struct rt_msghdr *rtm)
{
	char ifix_buf[IFNAMSIZ], *ifname, *host;
	struct hostent *hp = NULL;
	int addrwidth, llwidth, ifwidth ;
	struct timeval now;

	gettimeofday(&now, 0);

	if (nflag == 0)
		hp = gethostbyaddr((caddr_t)&(sin->sin_addr),
		    sizeof(sin->sin_addr), AF_INET);
	if (hp)
		host = hp->h_name;
	else
		host = inet_ntoa(sin->sin_addr);

	addrwidth = strlen(host);
	if (addrwidth < W_ADDR)
		addrwidth = W_ADDR;
	llwidth = strlen(ether_str(sdl));
	if (W_ADDR + W_LL - addrwidth > llwidth)
		llwidth = W_ADDR + W_LL - addrwidth;
	ifname = if_indextoname(sdl->sdl_index, ifix_buf);
	if (!ifname)
		ifname = "?";
	ifwidth = strlen(ifname);
	if (W_ADDR + W_LL + W_IF - addrwidth - llwidth > ifwidth)
		ifwidth = W_ADDR + W_LL + W_IF - addrwidth - llwidth;

	printf("%-*.*s %-*.*s %*.*s", addrwidth, addrwidth, host,
	    llwidth, llwidth, ether_str(sdl), ifwidth, ifwidth, ifname);

	if (rtm->rtm_flags & (RTF_PERMANENT_ARP|RTF_LOCAL))
		printf(" %-9.9s", "permanent");
	else if (rtm->rtm_rmx.rmx_expire == 0)
		printf(" %-9.9s", "static");
	else if (rtm->rtm_rmx.rmx_expire > now.tv_sec)
		printf(" %-9.9s",
		    sec2str(rtm->rtm_rmx.rmx_expire - now.tv_sec));
	else
		printf(" %-9.9s", "expired");

	printf(" %s%s\n",
	    (rtm->rtm_flags & RTF_LOCAL) ? "l" : "",
	    (rtm->rtm_flags & RTF_ANNOUNCE) ? "p" : "");
}

/*
 * Nuke an arp entry
 */
void
nuke_entry(struct sockaddr_dl *sdl, struct sockaddr_inarp *sin,
    struct rt_msghdr *rtm)
{
	char ip[20];

	strlcpy(ip, inet_ntoa(sin->sin_addr), sizeof(ip));
	delete(ip);
}

static char *
ether_str(struct sockaddr_dl *sdl)
{
	static char hbuf[NI_MAXHOST];
	u_char *cp;

	if (sdl->sdl_alen) {
		cp = (u_char *)LLADDR(sdl);
		snprintf(hbuf, sizeof(hbuf), "%02x:%02x:%02x:%02x:%02x:%02x",
		    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
	} else
		snprintf(hbuf, sizeof(hbuf), "(incomplete)");

	return(hbuf);
}

void
usage(void)
{
	fprintf(stderr, "usage: arp [-adn] [-V rdomain] hostname\n");
	fprintf(stderr, "       arp [-F] [-f file] [-V rdomain] "
	    "-s hostname ether_addr\n"
	    "           [temp | permanent] [pub]\n");
	fprintf(stderr, "       arp -W ether_addr [iface]\n");
	exit(1);
}

int
rtmsg(int cmd)
{
	static int seq;
	struct rt_msghdr *rtm;
	char *cp;
	int l;

	rtm = &m_rtmsg.m_rtm;
	cp = m_rtmsg.m_space;
	errno = 0;

	if (cmd == RTM_DELETE)
		goto doit;
	memset(&m_rtmsg, 0, sizeof(m_rtmsg));
	rtm->rtm_flags = flags;
	rtm->rtm_version = RTM_VERSION;
	rtm->rtm_hdrlen = sizeof(*rtm);
	rtm->rtm_tableid = rdomain;

	switch (cmd) {
	default:
		errx(1, "internal wrong cmd");
		/*NOTREACHED*/
	case RTM_ADD:
		rtm->rtm_addrs |= RTA_GATEWAY;
		rtm->rtm_rmx.rmx_expire = expire_time;
		rtm->rtm_inits = RTV_EXPIRE;
		rtm->rtm_flags |= (RTF_HOST | RTF_STATIC);
		sin_m.sin_other = 0;
		if (doing_proxy) {
			if (export_only)
				sin_m.sin_other = SIN_PROXY;
			else {
				rtm->rtm_addrs |= RTA_NETMASK;
				rtm->rtm_flags &= ~RTF_HOST;
			}
		}
		/* FALLTHROUGH */
	case RTM_GET:
		rtm->rtm_addrs |= (RTA_DST | RTA_IFP);
	}

#define NEXTADDR(w, s)					\
	if (rtm->rtm_addrs & (w)) {			\
		memcpy(cp, &s, sizeof(s));		\
		cp += ROUNDUP(sizeof(s));		\
	}

	NEXTADDR(RTA_DST, sin_m);
	NEXTADDR(RTA_GATEWAY, sdl_m);
	NEXTADDR(RTA_NETMASK, so_mask);
	NEXTADDR(RTA_IFP, ifp_m);

	rtm->rtm_msglen = cp - (char *)&m_rtmsg;
doit:
	l = rtm->rtm_msglen;
	rtm->rtm_seq = ++seq;
	rtm->rtm_type = cmd;
	if (write(rtsock, (char *)&m_rtmsg, l) < 0)
		if (errno != ESRCH || cmd != RTM_DELETE) {
			warn("writing to routing socket");
			return (-1);
		}

	do {
		l = read(rtsock, (char *)&m_rtmsg, sizeof(m_rtmsg));
	} while (l > 0 && (rtm->rtm_version != RTM_VERSION ||
	    rtm->rtm_seq != seq || rtm->rtm_pid != pid));

	if (l < 0)
		warn("read from routing socket");
	return (0);
}

int
rtget(struct sockaddr_inarp **sinp, struct sockaddr_dl **sdlp)
{
	struct rt_msghdr *rtm = &(m_rtmsg.m_rtm);
	struct sockaddr_inarp *sin = NULL;
	struct sockaddr_dl *sdl = NULL;
	struct sockaddr *sa;
	char *cp;
	unsigned int i;

	if (rtmsg(RTM_GET) < 0)
		return (1);

	if (rtm->rtm_addrs) {
		cp = ((char *)rtm + rtm->rtm_hdrlen);
		for (i = 1; i; i <<= 1) {
			if (i & rtm->rtm_addrs) {
				sa = (struct sockaddr *)cp;
				switch (i) {
				case RTA_DST:
					sin = (struct sockaddr_inarp *)sa;
					break;
				case RTA_IFP:
					sdl = (struct sockaddr_dl *)sa;
					break;
				default:
					break;
				}
				cp += ROUNDUP(sa->sa_len);
			}
		}
	}

	if (sin == NULL || sdl == NULL)
		return (1);

	*sinp = sin;
	*sdlp = sdl;

	return (0);
}

int
getinetaddr(const char *host, struct in_addr *inap)
{
	struct hostent *hp;

	if (inet_aton(host, inap) == 1)
		return (0);
	if ((hp = gethostbyname(host)) == NULL) {
		warnx("%s: %s", host, hstrerror(h_errno));
		return (-1);
	}
	memcpy(inap, hp->h_addr, sizeof(*inap));
	return (0);
}

static char *
sec2str(time_t total)
{
	static char result[256];
	int days, hours, mins, secs;
	int first = 1;
	char *p = result;
	char *ep = &result[sizeof(result)];
	int n;

	days = total / 3600 / 24;
	hours = (total / 3600) % 24;
	mins = (total / 60) % 60;
	secs = total % 60;

	if (days) {
		first = 0;
		n = snprintf(p, ep - p, "%dd", days);
		if (n < 0 || n >= ep - p)
			return "?";
		p += n;
	}
	if (!first || hours) {
		first = 0;
		n = snprintf(p, ep - p, "%dh", hours);
		if (n < 0 || n >= ep - p)
			return "?";
		p += n;
	}
	if (!first || mins) {
		first = 0;
		n = snprintf(p, ep - p, "%dm", mins);
		if (n < 0 || n >= ep - p)
			return "?";
		p += n;
	}
	snprintf(p, ep - p, "%ds", secs);

	return(result);
}

/*
 * Copyright (c) 2011 Jasper Lievisse Adriaanse <jasper@@openbsd.org>
 * Copyright (C) 2006,2007,2008,2009 Marc Balmer <mbalmer@@openbsd.org>
 * Copyright (C) 2000 Eugene M. Kim.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Author's name may not be used endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

int	do_wakeup(const char *, const char *, int);
int	bind_if_to_bpf(const char *, int);
int	get_ether(const char *, struct ether_addr *);
int	send_frame(int, const struct ether_addr *);

int
wake(const char *ether_addr, const char *iface)
{
	struct ifaddrs		*ifa, *ifap;
	char			*pname = NULL;
	int			 bpf;

	if ((bpf = open("/dev/bpf0", O_RDWR)) == -1)
		err(1, "Failed to bind to bpf");

	if (iface == NULL) {
		if (getifaddrs(&ifa) == -1)
			errx(1, "Could not get interface addresses.");

		for (ifap = ifa; ifap != NULL; ifap = ifap->ifa_next){
			if (pname && !strcmp(pname, ifap->ifa_name))
				continue;
			pname = ifap->ifa_name;

			/*
			 * We're only interested in sending the WoL frame on
			 * certain interfaces. So skip the loopback interface,
			 * as well as point-to-point and down interfaces.
			 */
			if ((ifap->ifa_flags & IFF_LOOPBACK) ||
			    (ifap->ifa_flags & IFF_POINTOPOINT) ||
			    (!(ifap->ifa_flags & IFF_UP)) ||
			    (!(ifap->ifa_flags & IFF_BROADCAST)))
				continue;

			do_wakeup(ether_addr, ifap->ifa_name, bpf);
		}
		freeifaddrs(ifa);
	} else {
		do_wakeup(ether_addr, iface, bpf);
	}

	(void)close(bpf);

	return 0;
}

int
do_wakeup(const char *eaddr, const char *iface, int bpf)
{
	struct ether_addr	 macaddr;

	if (get_ether(eaddr, &macaddr) != 0)
		errx(1, "Invalid Ethernet address: %s", eaddr);
	if (bind_if_to_bpf(iface, bpf) != 0)
		errx(1, "Failed to bind %s to bpf.", iface);
	if (send_frame(bpf, &macaddr) != 0)
		errx(1, "Failed to send WoL frame on %s", iface);
	return 0;
}

int
bind_if_to_bpf(const char *ifname, int bpf)
{
	struct ifreq ifr;
	u_int dlt;

	if (strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name)) >=
	    sizeof(ifr.ifr_name))
		return -1;
	if (ioctl(bpf, BIOCSETIF, &ifr) == -1)
		return -1;
	if (ioctl(bpf, BIOCGDLT, &dlt) == -1)
		return -1;
	if (dlt != DLT_EN10MB)
		return -1;
	return 0;
}

int
get_ether(const char *text, struct ether_addr *addr)
{
	struct ether_addr *eaddr;

	eaddr = ether_aton(text);

	if (eaddr == NULL) {
		if (ether_hostton(text, addr))
			return -1;
	} else {
		*addr = *eaddr;
		return 0;
	}

	return 0;
}

#define SYNC_LEN 6
#define DESTADDR_COUNT 16

int
send_frame(int bpf, const struct ether_addr *addr)
{
	struct {
		struct ether_header hdr;
		u_char sync[SYNC_LEN];
		u_char dest[ETHER_ADDR_LEN * DESTADDR_COUNT];
	} __packed pkt;
	u_char *p;
	int i;

	(void)memset(&pkt, 0, sizeof(pkt));
	(void)memset(&pkt.hdr.ether_dhost, 0xff, sizeof(pkt.hdr.ether_dhost));
	pkt.hdr.ether_type = htons(0);
	(void)memset(pkt.sync, 0xff, SYNC_LEN);
	for (p = pkt.dest, i = 0; i < DESTADDR_COUNT; p += ETHER_ADDR_LEN, i++)
		bcopy(addr->ether_addr_octet, p, ETHER_ADDR_LEN);
	if (write(bpf, &pkt, sizeof(pkt)) != sizeof(pkt))
		return (errno);
	return (0);
}
@


1.77
log
@Tweak output to keep it aligned when interfaces with big names, like
vether0 are used.

ok jca@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.76 2016/08/27 04:15:52 guenther Exp $ */
d89 1
a89 1
static int s = -1;
d246 1
a246 1
	if (s >= 0)
d248 4
a251 4
	s = socket(PF_ROUTE, SOCK_RAW, 0);
	if (s < 0)
		err(1, "socket");
	if (setsockopt(s, PF_ROUTE, ROUTE_TABLEFILTER, &rdomain, len) < 0)
d671 1
a671 1
	if (write(s, (char *)&m_rtmsg, l) < 0)
d678 1
a678 1
		l = read(s, (char *)&m_rtmsg, sizeof(m_rtmsg));
@


1.76
log
@Pull in <sys/time.h> for gettimeofday()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.75 2016/05/28 07:00:18 natano Exp $ */
d369 1
a369 1
#define W_IF	6
d384 1
a384 1
	printf("%-*.*s %-*.*s %*.*s %-10.10s %5s\n",
d512 1
a512 1
	printf("%-*.*s %-*.*s %*.*s %-10.10s %5s\n",
d558 1
a558 1
		printf(" %-10.10s", "permanent");
d560 1
a560 1
		printf(" %-10.10s", "static");
d562 1
a562 1
		printf(" %-10.10s",
d565 1
a565 1
		printf(" %-10.10s", "expired");
@


1.75
log
@Replace the /dev/bpf* open loop with a plain open("/dev/bpf0", ...).
ok deraadt jca
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.74 2016/03/23 08:28:31 mpi Exp $ */
d43 1
@


1.74
log
@Kill undocumented "pro" command.  It's a no-op since the 90s!
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.73 2016/03/23 08:19:58 mpi Exp $ */
a810 4
#ifndef BPF_PATH_FORMAT
#define BPF_PATH_FORMAT "/dev/bpf%u"
#endif

a811 1
int	get_bpf(void);
d823 2
a824 3
	bpf = get_bpf();
	if (bpf == -1)
		errx(1, "Failed to bind to bpf.");
a869 19
}

int
get_bpf(void)
{
	char path[PATH_MAX];
	int i, fd;

	for (i = 0; ; i++) {
		if (snprintf(path, sizeof(path), BPF_PATH_FORMAT, i) == -1)
			return -1;
		fd = open(path, O_RDWR);
		if (fd != -1)
			return fd;
		if (errno == EBUSY)
			continue;
		break;
	}
	return -1;
@


1.73
log
@Rename 'rtn' to 'error' for coherency.
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.72 2016/03/23 08:17:35 mpi Exp $ */
d65 1
a65 1
int delete(const char *, const char *);
d175 1
a175 1
			delete(argv[0], NULL);
d182 1
a182 1
			error = delete(argv[0], argv[1]);
d232 1
a232 1
			delete(arg[0], NULL);
d400 1
a400 1
delete(const char *host, const char *info)
a408 2
	if (info && strncmp(info, "pro", 3) )
		export_only = 1;
d581 1
a581 1
	delete(ip, NULL);
@


1.72
log
@Remove code to print the never set SIN_PROXY bit.  This flag is only used
to set the 33rd bit of a 32bit address in the routing table.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.71 2016/01/26 18:26:19 mmcc Exp $ */
d107 1
a107 1
	int		 ch, func = 0, rtn;
a160 1
	rtn = 0;
d167 1
a167 1
			rtn = get(argv[0]);
d176 1
a176 1
		rtn = set(argc, argv) ? 1 : 0;
d182 1
a182 1
			rtn = delete(argv[0], argv[1]);
d189 1
a189 1
		rtn = file(argv[0]);
d195 1
a195 1
			rtn = wake(argv[0], NULL);
d197 1
a197 1
			rtn = wake(argv[0], argv[1]);
d202 1
a202 1
	return (rtn);
d568 1
a568 1
	printf(" %s%s%s\n",
@


1.71
log
@Use an unsigned int rather than an int when iterating through all 32
bits in the form:

for (i = 1; i; i <<= 1)

This avoids undefined operations when shifting into and out of the
highest-order bit.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.70 2015/12/08 14:20:24 tedu Exp $ */
a570 1
	    (sin->sin_other & SIN_PROXY) ? "P" : "",
@


1.70
log
@remove undocumented message about trailers
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.69 2015/10/14 04:03:01 deraadt Exp $ */
d698 1
a698 1
	int i;
@


1.69
log
@I messed up reading the call graph.  -d delete does use search, so a
late pledge is not possible in this way.
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.68 2015/10/09 01:37:09 deraadt Exp $ */
d319 1
a319 3
		} else if (strncmp(argv[0], "trail", 5) == 0)
			printf("%s: Sending trailers is no longer supported\n",
			    host);
@


1.68
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.67 2015/10/07 20:25:40 deraadt Exp $ */
a470 3

	if (pledge("stdio dns route", NULL) == -1)
		err(1, "pledge");
@


1.67
log
@use new tame "route" feature when possible
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.64 2015/06/03 08:10:53 mpi Exp $ */
d254 2
a255 2
	if (tame("stdio dns", NULL) == -1)
		err(1, "tame");
d472 2
a473 2
	if (tame("stdio dns route", NULL) == -1)
		err(1, "tame");
@


1.66
log
@correct a rtget() error check
this function could only return 0 or 1, and 1 on error.

avoid to deref an uninitialised variable if rtget() return an error.

ok millert@@ benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.65 2015/10/03 02:25:59 deraadt Exp $ */
a162 2
	getsocket();

a164 2
		if (tame("stdio dns inet", NULL) == -1)
			err(1, "tame");
a179 2
		if (tame("stdio dns inet", NULL) == -1)
			err(1, "tame");
d253 3
d284 1
d414 1
d471 3
@


1.65
log
@arp uses a non-privileged sockraw to look at the kernel arp tables.
the function to do that is called a number of times, but as needed.
hoist it upwards into initization, then tame "stdio dns inet" is
possible in most code paths.  (there may be further work to do here here)
i believe florian helped me with this.
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.64 2015/06/03 08:10:53 mpi Exp $ */
d420 1
a420 1
	if (rtget(&sin, &sdl) < 0) {
@


1.64
log
@Explicitly request the sockaddr_dl when doing a RTM_GET rather than
assuming that it will be in the gateway sa.

Fixes a regression introduced with the support of multiple connected
routes, found the hardway by deraadt@@.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.63 2015/01/16 06:40:15 deraadt Exp $ */
d163 2
d167 2
d184 2
a286 1
	getsocket();
a415 1
	getsocket();
@


1.63
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.62 2014/09/07 22:40:30 bluhm Exp $ */
d78 1
d258 1
d324 1
a324 1
	if (rtmsg(RTM_GET) < 0) {
d328 1
a328 2
	sin = (struct sockaddr_inarp *)((char *)rtm + rtm->rtm_hdrlen);
	sdl = (struct sockaddr_dl *)(ROUNDUP(sin->sin_len) + (char *)sin);
d416 1
a416 1
	if (rtmsg(RTM_GET) < 0) {
a419 2
	sin = (struct sockaddr_inarp *)((char *)rtm + rtm->rtm_hdrlen);
	sdl = (struct sockaddr_dl *)(ROUNDUP(sin->sin_len) + (char *)sin);
d422 1
a422 1
			if (rtm->rtm_flags & (RTF_LOCAL|RTF_BROADCAST))
a494 2
		if (rtm->rtm_flags & RTF_BROADCAST)
			continue;
d558 1
a558 1
	if (rtm->rtm_flags & (RTF_PERMANENT_ARP|RTF_LOCAL|RTF_BROADCAST))
d654 1
a654 1
		rtm->rtm_addrs |= RTA_DST;
d666 1
d686 42
@


1.62
log
@Remove useless comment, snprintf and if/else.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.61 2014/09/03 10:39:41 mpi Exp $ */
a39 1
#include <sys/param.h>
d61 1
d844 1
a844 1
	char path[MAXPATHLEN];
@


1.61
log
@Be coherent in the way arp(8) and ndp(8) display local entries and
use a new flag `l' to ditinguish them.

Also skip broadcast entries, they are not reall ARP entries and will
never be resolved to anything, requested by deraadt@@.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.60 2014/08/22 22:14:53 sthen Exp $ */
a533 1
	char flgbuf[8];
d571 1
a571 1
	snprintf(flgbuf, sizeof(flgbuf), "%s%s%s",
a574 2

	printf(" %s\n", flgbuf);
@


1.60
log
@print leading 0's in MAC addresses again, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.59 2014/08/21 10:23:47 mpi Exp $ */
d496 2
d562 1
a562 1
	if (rtm->rtm_flags & RTF_PERMANENT_ARP)
d572 2
a573 1
	snprintf(flgbuf, sizeof(flgbuf), "%s%s",
@


1.59
log
@Change the output of arp(8) to match what ndp(8) does and include the
expire timer.

This will makes it easier to add further information in a coherent way
between these tools for local and broadcast entries.

This new view displays either symbolic names (by default) or numerical
addresses (with "-n") for hosts but not both at the same time, just
like ndp(8), route(8) or netstat(1) do.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.58 2014/08/19 12:39:36 mpi Exp $ */
d598 1
a598 1
		snprintf(hbuf, sizeof(hbuf), "%x:%x:%x:%x:%x:%x",
@


1.58
log
@Entries for broadcast addresses should also be ignored, just like local
entries.

ok florian@@, mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.57 2014/08/11 09:47:56 mpi Exp $ */
d64 1
d72 1
a73 1
void ether_print(const char *);
d81 1
d165 1
a165 1
			search(0, print_entry);
d365 4
d381 5
d388 2
a389 1
		printf("%s (%s) -- no entry\n", host, inet_ntoa(sin->sin_addr));
d509 13
d528 7
a534 2
	char ifname[IFNAMSIZ], *host;
	struct hostent *hp;
a538 2
	else
		hp = 0;
a540 8
	else {
		host = "?";
		if (h_errno == TRY_AGAIN)
			nflag = 1;
	}
	printf("%s (%s) at ", host, inet_ntoa(sin->sin_addr));
	if (sdl->sdl_alen)
		ether_print(LLADDR(sdl));
d542 18
a559 3
		printf("(incomplete)");
	if (if_indextoname(sdl->sdl_index, ifname) != NULL)
		printf(" on %s", ifname);
d561 14
a574 14
		printf(" permanent");
	if (rtm->rtm_rmx.rmx_expire == 0)
		printf(" static");
	if (sin->sin_other & SIN_PROXY)
		printf(" published (proxy only)");
	if (rtm->rtm_addrs & RTA_NETMASK) {
		sin = (struct sockaddr_inarp *)
		    (ROUNDUP(sdl->sdl_len) + (char *)sdl);
		if (sin->sin_addr.s_addr == 0xffffffff)
			printf(" published");
		if (sin->sin_len != 8)
			printf("(weird %d)", sin->sin_len);
	}
	printf("\n");
d590 2
a591 2
void
ether_print(const char *scp)
d593 9
a601 1
	const u_char *cp = (u_char *)scp;
d603 1
a603 2
	printf("%02x:%02x:%02x:%02x:%02x:%02x",
	    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
d704 41
@


1.57
log
@Do not try to delete RTF_LOCAL entries.  Such routes are automatically
created /deleted by the kernel when an IP address is added/removed
on/from an interface and should not be manipulated by userland tools.

ok henning@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.56 2014/03/18 14:18:22 mikeb Exp $ */
d411 1
a411 1
			if (rtm->rtm_flags & RTF_LOCAL)
@


1.56
log
@Put AF_ROUTE socket that arp(8) operates on into the appropriate rdomain.

Previously "arp -V 1 -d 10.0.0.1" would hang forever since while the
target rdomain was passed in the rtm, the AF_ROUTE socket was always
created in the rdomain 0.  Due to the logic in route_input (rtsock.c)
route socket's rdomain is compared against the target rdomain of the
request and reply is generated only when they match.  In our case
rdomains were different which cased arp(8) to hang waiting for the
reply that would never be sent.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.55 2014/02/26 20:50:17 claudio Exp $ */
d409 16
a424 13
	if (sin->sin_addr.s_addr == sin_m.sin_addr.s_addr)
		if (sdl->sdl_family == AF_LINK &&
		    (rtm->rtm_flags & RTF_LLINFO) &&
		    !(rtm->rtm_flags & RTF_GATEWAY))
			switch (sdl->sdl_type) {
			case IFT_ETHER:
			case IFT_FDDI:
			case IFT_ISO88023:
			case IFT_ISO88024:
			case IFT_ISO88025:
			case IFT_CARP:
				goto delete;
			}
@


1.55
log
@There is no need to init a global to 0
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.54 2013/08/15 13:43:33 bluhm Exp $ */
d241 2
d248 2
@


1.54
log
@Reduce the warnings when arp, rarp, ndp are compiled with WARNINGS=yes.
warning: declaration of 'time' shadows a global declaration
No binary change; OK lteo@@ florian@@ henning@@ mikeb@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.53 2013/07/20 18:21:11 bluhm Exp $ */
d86 1
a86 1
static int rdomain = 0;
@


1.53
log
@arp and rarpd used an int expire_time for time calculation.  Convert
this into time_t.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.52 2013/03/21 04:43:17 deraadt Exp $ */
d289 1
a289 1
			struct timeval time;
d291 2
a292 2
			gettimeofday(&time, 0);
			expire_time = time.tv_sec + 20 * 60;
@


1.52
log
@create realloc() loops around sysctl for array-based mibs, in programs
which want a "full" dump
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.51 2012/11/08 11:05:41 phessler Exp $ */
d251 2
a252 2
int			expire_time, flags, export_only, doing_proxy,
			    found_entry;
d285 2
a286 1
	doing_proxy = flags = export_only = expire_time = 0;
@


1.51
log
@When running route -Tx exec arp -an, arp would always use the default
routing domain.  Fix it so we use the process rdomain, but still allow
command line overrides.

noticed by, and OK, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.50 2011/01/11 16:34:20 jasper Exp $ */
d445 1
a445 1
	char *lim, *buf, *next;
d457 15
a471 9
	if (sysctl(mib, 7, NULL, &needed, NULL, 0) < 0)
		err(1, "route-sysctl-estimate");
	if (needed == 0)
		return;
	if ((buf = malloc(needed)) == NULL)
		err(1, "malloc");
	if (sysctl(mib, 7, buf, &needed, NULL, 0) < 0)
		err(1, "actual retrieval of routing table");
	lim = buf + needed;
@


1.50
log
@  Add Wake on Lan support to arp(8). This is partly based on the original
    wake(8) program. One can specify an interface to send on, or simply
      broadcast on all available interfaces.

	Initial input from stsp@@, further help from claudio@@ and deraadt@@.
	  ok claudio@@ deraadt@@
	    manpage bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.49 2009/09/27 12:07:15 deraadt Exp $ */
d109 1
@


1.49
log
@a usage line got too long; ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.48 2009/06/25 15:43:18 claudio Exp $ */
d37 1
a37 1
 * arp - display, set, and delete arp table entries
d44 2
a45 1

d62 1
d71 1
d99 1
d109 1
a109 1
	while ((ch = getopt(argc, argv, "andsFfV:")) != -1) {
d142 5
d188 10
d556 1
d646 174
@


1.48
log
@Same code as in route(8) same RTM_VERSION check missing.
Tested and OK sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.47 2009/06/05 03:54:42 chris Exp $ */
d535 2
a536 2
	    "-s hostname ether_addr "
	    "[temp | permanent] [pub]\n");
@


1.47
log
@more rtm->rtm_hdrlen conversion

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.46 2009/06/05 00:13:35 claudio Exp $ */
d606 2
a607 1
	} while (l > 0 && (rtm->rtm_seq != seq || rtm->rtm_pid != pid));
@


1.46
log
@One more tool that knows about other domains via -V
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.45 2008/12/12 20:23:20 claudio Exp $ */
d299 1
a299 1
	sin = (struct sockaddr_inarp *)(rtm + 1);
@


1.45
log
@Use rtm_hdrlen to jump over the message header and to the beginning of the
sockaddrs included in the message. This makes the code more robust when
kernel and userland are out of sync. put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.44 2008/03/12 23:18:59 sobrado Exp $ */
d83 1
d100 2
a101 1
	int	ch, func = 0, rtn;
d105 1
a105 1
	while ((ch = getopt(argc, argv, "andsFf")) != -1) {
d131 7
d423 1
a423 1
	int mib[6];
d436 2
a437 1
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
d443 1
a443 1
	if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
d533 3
a535 2
	fprintf(stderr, "usage: arp [-adn] hostname\n");
	fprintf(stderr, "       arp [-F] [-f file] -s hostname ether_addr "
d558 1
@


1.44
log
@"usage:" should precede the first statement only

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.43 2008/02/14 09:28:02 thib Exp $ */
d373 1
a373 1
	sin = (struct sockaddr_inarp *)(rtm + 1);
d440 1
a440 1
		sin = (struct sockaddr_inarp *)(rtm + 1);
d546 1
@


1.43
log
@backout the change to make arp(8) default to -an;
Remove that blurp from the man page also.

requested by deraadt@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.42 2008/02/07 16:53:58 thib Exp $ */
d524 1
a524 1
	fprintf(stderr, "usage: arp [-F] [-f file] -s hostname ether_addr "
@


1.42
log
@Oops. Better diff to enable -an by default without breaking
the other options too badly;

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.41 2008/02/07 15:57:07 thib Exp $ */
a133 3
	if (argc == 1)
		aflag = nflag = 1;

@


1.41
log
@make arp(8) default to -na when called with no arguments;

man page bit from jmc@@

ok millert@@, oga@@, laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.40 2007/08/24 13:12:16 claudio Exp $ */
d134 3
a138 3

	if (argc == 0)
		aflag = nflag = 1;
@


1.40
log
@Yet another application that does not check if the RTM_VERSION is the expected
one. Luckily it seems that only show is affected. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.39 2007/02/18 23:50:47 ray Exp $ */
d136 3
@


1.39
log
@Use sizeof(buf) instead of hard coded numbers.

From Charles Longeau <chl at tuxfamily dot org> long ago.

OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.38 2006/05/26 09:00:57 jmc Exp $ */
d438 2
@


1.38
log
@simplify synopsis; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.37 2006/04/18 22:11:49 moritz Exp $ */
d192 1
a192 1
	while (fgets(line, 100, fp) != NULL) {
@


1.37
log
@Remove "S" from getopt(3) string, which was added in 1.32 by mistake.
From Steffen Wendzel. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.36 2005/04/04 16:14:45 deraadt Exp $ */
d521 2
a522 5
	fprintf(stderr, "usage: arp [-n] hostname\n");
	fprintf(stderr, "usage: arp [-n] -a\n");
	fprintf(stderr, "usage: arp -d hostname\n");
	fprintf(stderr, "usage: arp -d -a\n");
	fprintf(stderr, "usage: arp [-F] -s hostname ether_addr "
a523 1
	fprintf(stderr, "usage: arp [-F] -f filename\n");
@


1.36
log
@shrink
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.35 2005/04/04 09:03:07 deraadt Exp $ */
d103 1
a103 1
	while ((ch = getopt(argc, argv, "andSsFf")) != -1) {
@


1.35
log
@nlist.h not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.34 2005/03/29 23:55:18 henning Exp $ */
d99 1
a99 1
	int	ch, func, rtn;
a102 2
	func = 0;

d238 1
a238 1
	char *eaddr;
a239 1
	char *host = argv[0];
a242 1
	eaddr = argv[1];
d260 1
d268 1
a268 2
		}
		else if (strncmp(argv[0], "pub", 3) == 0) {
d271 1
a271 2
		}
		else if (strncmp(argv[0], "permanent", 9) == 0) {
d457 1
a457 1
	char *host;
a458 1
	char ifname[IFNAMSIZ];
@


1.34
log
@
clean further, theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.33 2005/03/29 22:24:48 henning Exp $ */
a55 1
#include <nlist.h>
@


1.33
log
@make this a bit more readable
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.32 2005/03/29 21:59:59 henning Exp $ */
a34 11

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1984, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)arp.c	8.2 (Berkeley) 1/2/94";*/
static char *rcsid = "$OpenBSD: arp.c,v 1.32 2005/03/29 21:59:59 henning Exp $";
#endif /* not lint */
@


1.32
log
@add -F to force replacement of entries with -s and -f
inspired by a diff from Mike Belopuhov <mkb@@cvs.hnet.spb.ru>,
these semantics with theo, manpage jaredy jmc and bob, ok bob
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.31 2005/01/04 10:57:23 pascoe Exp $ */
d44 1
a44 1
static char *rcsid = "$OpenBSD: arp.c,v 1.31 2005/01/04 10:57:23 pascoe Exp $";
d111 1
a111 1
	int ch, func, rtn;
d118 1
a118 1
		switch ((char)ch) {
d168 1
a168 1
			(void)delete(argv[0], NULL);
d194 3
a196 3
	char line[100], arg[5][50], *args[5];
	int i, retval;
	FILE *fp;
d207 2
a208 2
		i = sscanf(line, "%49s %49s %49s %49s %49s", arg[0], arg[1], arg[2],
		    arg[3], arg[4]);
d215 1
a215 1
			(void)delete(arg[0], NULL);
d233 5
a237 4
struct	sockaddr_in so_mask = {8, 0, 0, { 0xffffffff}};
struct	sockaddr_inarp blank_sin = {sizeof(blank_sin), AF_INET }, sin_m;
struct	sockaddr_dl blank_sdl = {sizeof(blank_sdl), AF_LINK }, sdl_m;
int	expire_time, flags, export_only, doing_proxy, found_entry;
d239 2
a240 2
	struct	rt_msghdr m_rtm;
	char	m_space[512];
d268 1
a268 1
	if (ea == NULL) 
d276 1
a276 1
			(void)gettimeofday(&time, 0);
d295 4
a298 5
		} else if (strncmp(argv[0], "trail", 5) == 0) {
			(void)printf(
			    "%s: Sending trailers is no longer supported\n",
			     host);
		}
d301 1
d312 1
a312 1
		    !(rtm->rtm_flags & RTF_GATEWAY)) {
d314 6
a319 2
			case IFT_ETHER: case IFT_FDDI: case IFT_ISO88023:
			case IFT_ISO88024: case IFT_ISO88025: case IFT_CARP:
d322 1
a322 1
		}
d324 1
a324 1
			(void)printf("set: can only proxy for %s\n", host);
d328 1
a328 2
			(void)printf(
			    "set: proxy entry exists for non 802 device\n");
d335 1
d338 1
a338 2
		(void)printf("cannot intuit interface index and type for %s\n",
		    host);
d360 1
a360 2
		(void)printf("%s (%s) -- no entry\n", host,
		    inet_ntoa(sin->sin_addr));
d392 1
a392 1
	if (sin->sin_addr.s_addr == sin_m.sin_addr.s_addr) {
d395 1
a395 1
		    !(rtm->rtm_flags & RTF_GATEWAY)) {
d397 6
a402 2
			case IFT_ETHER: case IFT_FDDI: case IFT_ISO88023:
			case IFT_ISO88024: case IFT_ISO88025: case IFT_CARP:
d405 1
a405 2
		}
	}
d415 1
a415 1
		(void)printf("cannot locate %s\n", host);
d420 1
a420 1
	(void)printf("%s (%s) deleted\n", host, inet_ntoa(sin->sin_addr));
d490 1
a490 1
	(void)printf("%s (%s) at ", host, inet_ntoa(sin->sin_addr));
d494 1
a494 1
		(void)printf("(incomplete)");
d498 1
a498 1
		(void)printf(" permanent");
d500 1
a500 1
		(void)printf(" static");
d502 1
a502 1
		(void)printf(" published (proxy only)");
d505 1
a505 1
			(ROUNDUP(sdl->sdl_len) + (char *)sdl);
d507 1
a507 1
			(void)printf(" published");
d509 1
a509 1
			(void)printf("(weird %d)", sin->sin_len);
d532 1
a532 1
	(void)printf("%02x:%02x:%02x:%02x:%02x:%02x",
d539 7
a545 7
	(void)fprintf(stderr, "usage: arp [-n] hostname\n");
	(void)fprintf(stderr, "usage: arp [-n] -a\n");
	(void)fprintf(stderr, "usage: arp -d hostname\n");
	(void)fprintf(stderr, "usage: arp -d -a\n");
	(void)fprintf(stderr,
	    "usage: arp [-F] -s hostname ether_addr [temp | permanent] [pub]\n");
	(void)fprintf(stderr, "usage: arp [-F] -f filename\n");
d563 1
a563 1
	(void)memset(&m_rtmsg, 0, sizeof(m_rtmsg));
d592 1
a592 1
		(void)memcpy(cp, &s, sizeof(s));	\
d605 1
a605 1
	if (write(s, (char *)&m_rtmsg, l) < 0) {
d610 1
a610 1
	}
d614 1
d631 1
a631 1
	(void)memcpy(inap, hp->h_addr, sizeof(*inap));
@


1.31
log
@Enable ARP table manipulation on CARP interfaces.

ok niklas@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.30 2003/06/27 22:11:39 deraadt Exp $ */
d44 1
a44 1
static char *rcsid = "$OpenBSD: arp.c,v 1.30 2003/06/27 22:11:39 deraadt Exp $";
d91 1
d117 1
a117 1
	while ((ch = getopt(argc, argv, "andsf")) != -1) {
d135 3
d167 2
d214 2
d470 1
a470 1
	char ifname[IF_NAMESIZE];
d538 2
a539 2
	    "usage: arp -s hostname ether_addr [temp | permanent] [pub]\n");
	(void)fprintf(stderr, "usage: arp -f filename\n");
@


1.30
log
@memory leak; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.29 2003/06/27 22:11:22 deraadt Exp $ */
d44 1
a44 1
static char *rcsid = "$OpenBSD: arp.c,v 1.29 2003/06/27 22:11:22 deraadt Exp $";
d306 1
a306 1
			case IFT_ISO88024: case IFT_ISO88025:
d387 1
a387 1
			case IFT_ISO88024: case IFT_ISO88025:
@


1.29
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.28 2003/06/11 23:33:25 deraadt Exp $ */
d44 1
a44 1
static char *rcsid = "$OpenBSD: arp.c,v 1.28 2003/06/11 23:33:25 deraadt Exp $";
d450 1
@


1.28
log
@some ansification, some de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.27 2003/06/02 23:36:52 millert Exp $ */
d44 1
a44 1
static char *rcsid = "$OpenBSD: arp.c,v 1.27 2003/06/02 23:36:52 millert Exp $";
d95 2
a422 1
	extern int h_errno;
a459 1
	extern int h_errno;
a537 1
	int rlen;
d590 1
a590 1
	if ((rlen = write(s, (char *)&m_rtmsg, l)) < 0) {
@


1.27
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.26 2003/03/17 23:26:21 henric Exp $ */
d44 1
a44 1
static char *rcsid = "$OpenBSD: arp.c,v 1.26 2003/03/17 23:26:21 henric Exp $";
d106 1
a106 3
main(argc, argv)
	int argc;
	char **argv;
d184 1
a184 2
file(name)
	char *name;
d214 1
a214 1
getsocket()
d236 1
a236 3
set(argc, argv)
	int argc;
	char **argv;
d336 1
a336 2
get(host)
	const char *host;
d357 1
a357 3
delete(host, info)
	const char *host;
	const char *info;
d412 2
a413 5
search(addr, action)
	in_addr_t addr;
	void (*action)(struct sockaddr_dl *sdl,
		       struct sockaddr_inarp *sin,
		       struct rt_msghdr *rtm);
d455 2
a456 4
print_entry(sdl, sin, rtm)
	struct sockaddr_dl *sdl;
	struct sockaddr_inarp *sin;
	struct rt_msghdr *rtm;
d503 2
a504 4
nuke_entry(sdl, sin, rtm)
	struct sockaddr_dl *sdl;
	struct sockaddr_inarp *sin;
	struct rt_msghdr *rtm;
d522 1
a522 1
usage()
d535 1
a535 2
rtmsg(cmd)
	int cmd;
d606 1
a606 3
getinetaddr(host, inap)
	const char *host;
	struct in_addr *inap;
@


1.26
log
@arp did not long-align sockaddrs in routing messages.  This led to
garbage being sent to the kernel on sparc64.

Problem reported and fix tested by Doug Winter (thanks).

ok jason@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.25 2002/12/03 22:33:50 fgsch Exp $ */
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d44 1
a44 1
static char *rcsid = "$OpenBSD: arp.c,v 1.25 2002/12/03 22:33:50 fgsch Exp $";
@


1.25
log
@print the interface related to the arp entry; several ppl ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.23 2002/05/30 19:09:05 deraadt Exp $ */
d48 1
a48 1
static char *rcsid = "$OpenBSD: arp.c,v 1.23 2002/05/30 19:09:05 deraadt Exp $";
d99 4
d306 1
a306 1
	sdl = (struct sockaddr_dl *)(sin->sin_len + (char *)sin);
d390 1
a390 1
	sdl = (struct sockaddr_dl *)(sin->sin_len + (char *)sin);
d507 1
a507 1
			(sdl->sdl_len + (char *)sdl);
d511 1
a511 1
			(void)printf("(weird)");
d595 6
a600 3
#define NEXTADDR(w, s) \
	if (rtm->rtm_addrs & (w)) { \
		(void)memcpy(cp, &s, sizeof(s)); cp += sizeof(s);}
@


1.24
log
@undo signed vs unsigned confusion
@
text
@d474 1
d493 2
@


1.23
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.22 2002/05/26 09:25:21 deraadt Exp $ */
d48 1
a48 1
static char *rcsid = "$OpenBSD: arp.c,v 1.22 2002/05/26 09:25:21 deraadt Exp $";
d85 1
a85 1
void ether_print(const u_char *);
d246 1
a246 1
	u_char *eaddr;
d525 1
a525 2
ether_print(cp)
	const u_char *cp;
d527 2
@


1.22
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.21 2002/03/14 16:44:24 mpech Exp $ */
d48 1
a48 1
static char *rcsid = "$OpenBSD: arp.c,v 1.21 2002/03/14 16:44:24 mpech Exp $";
d115 1
a115 1
	
d150 1
a150 1
	
d236 1
a236 1
 * Set an individual arp entry 
d263 1
a263 1
	  errx(1, "invalid ethernet address: %s", eaddr);
d273 1
a273 1
			        /* temp or permanent, not both */
d281 1
a281 1
		}	
d285 1
a285 1
			        /* temp or permanent, not both */
d306 6
a311 4
		    !(rtm->rtm_flags & RTF_GATEWAY)) switch (sdl->sdl_type) {
		case IFT_ETHER: case IFT_FDDI: case IFT_ISO88023:
		case IFT_ISO88024: case IFT_ISO88025:
			goto overwrite;
d360 1
a360 1
 * Delete an arp entry 
d390 6
a395 4
		    !(rtm->rtm_flags & RTF_GATEWAY)) switch (sdl->sdl_type) {
		case IFT_ETHER: case IFT_FDDI: case IFT_ISO88023:
		case IFT_ISO88024: case IFT_ISO88025:
			goto delete;
d410 1
a410 1
	if (rtmsg(RTM_DELETE)) 
d474 1
a474 1
	
d505 1
a505 1
 	}
d519 1
a519 1
	
@


1.21
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.20 2002/03/14 06:51:42 mpech Exp $ */
d48 1
a48 1
static char *rcsid = "$OpenBSD: arp.c,v 1.20 2002/03/14 06:51:42 mpech Exp $";
d94 1
a94 1
static int pid;
@


1.20
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.19 2002/02/16 21:28:00 millert Exp $ */
d48 1
a48 1
static char *rcsid = "$OpenBSD: arp.c,v 1.19 2002/02/16 21:28:00 millert Exp $";
d243 3
a245 3
	register struct sockaddr_inarp *sin;
	register struct sockaddr_dl *sdl;
	register struct rt_msghdr *rtm;
d365 2
a366 2
	register struct sockaddr_inarp *sin;
	register struct rt_msghdr *rtm;
d547 3
a549 3
	register struct rt_msghdr *rtm;
	register char *cp;
	register int l;
@


1.19
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.18 2001/06/10 17:46:20 dugsong Exp $ */
d48 1
a48 1
static char *rcsid = "$OpenBSD: arp.c,v 1.18 2001/06/10 17:46:20 dugsong Exp $";
d263 1
a263 1
	  errx(1, "invalid ethernet address: %s\n", eaddr);
@


1.18
log
@implement arp -d -a, to delete all arp entries at once. mostly from FreeBSD. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.17 2001/03/07 19:31:58 deraadt Exp $ */
d48 1
a48 1
static char *rcsid = "$OpenBSD$";
d78 1
a78 1
int delete __P((const char *, const char *));
d85 8
a92 8
void ether_print __P((const u_char *));
int file __P((char *));
int get __P((const char *));
int getinetaddr __P((const char *, struct in_addr *));
void getsocket __P((void));
int rtmsg __P((int));
int set __P((int, char **));
void usage __P((void));
@


1.17
log
@print ether_ntoa() compatible
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.16 2000/10/23 14:55:12 aaron Exp $ */
d48 1
a48 1
static char *rcsid = "$NetBSD: arp.c,v 1.12 1995/04/24 13:25:18 cgd Exp $";
d79 6
a84 1
void dump __P((in_addr_t));
d87 1
a87 1
void get __P((const char *));
d95 2
a96 1
static int nflag;
d99 6
d110 1
a110 1
	int ch, argstart;
d114 8
a121 2
	while ((ch = getopt(argc, argv, "andsf")) != -1)
		if (ch == 'n')
d123 1
a123 10

	argstart = optind;
	optind = 1;
	optreset = 1;
	opterr = 1;
	while ((ch = getopt(argc, argv, "andsf")) != -1)
		switch((char)ch) {
		case 'a':
			dump(0);
			return (0);
d125 1
a125 1
			if (argc < (argstart + 1) || argc > (argstart +2))
d127 1
a127 3
			(void)delete(argv[argstart], argv[argstart + 1]);
			return (0);
		case 'n':
d130 1
a130 1
			if (argc < 4 || argc > 7)
d132 2
a133 1
			return (set(argc-2, &argv[2]) ? 1 : 0);
d135 1
a135 1
			if (argc != 3)
d137 2
a138 2
			return (file(argv[2]));
		case '?':
d141 1
d143 37
a179 5
	if (argc == 2 || (argc == 3 && nflag))
		get(argv[argc - 1]);
	else
		usage();
	return (0);
d264 1
a264 1
	memcpy(LLADDR(&sdl_m), ea, sizeof (*ea));
d338 1
a338 1
void
d348 1
a348 1
	dump(sin->sin_addr.s_addr);
d352 1
a352 1
		exit(1);
d354 1
d413 1
a413 1
 * Dump the entire arp table
d416 1
a416 1
dump(addr)
d418 3
d424 1
a424 1
	char *host, *lim, *buf, *next;
a428 1
	struct hostent *hp;
d454 28
a481 32
		if (nflag == 0)
			hp = gethostbyaddr((caddr_t)&(sin->sin_addr),
			    sizeof sin->sin_addr, AF_INET);
		else
			hp = 0;
		if (hp)
			host = hp->h_name;
		else {
			host = "?";
			if (h_errno == TRY_AGAIN)
				nflag = 1;
		}
		(void)printf("%s (%s) at ", host, inet_ntoa(sin->sin_addr));
		if (sdl->sdl_alen)
			ether_print(LLADDR(sdl));
		else
			(void)printf("(incomplete)");
		if (rtm->rtm_flags & RTF_PERMANENT_ARP)
		        (void)printf(" permanent");
		if (rtm->rtm_rmx.rmx_expire == 0)
			(void)printf(" static");
		if (sin->sin_other & SIN_PROXY)
			(void)printf(" published (proxy only)");
		if (rtm->rtm_addrs & RTA_NETMASK) {
			sin = (struct sockaddr_inarp *)
				(sdl->sdl_len + (char *)sdl);
			if (sin->sin_addr.s_addr == 0xffffffff)
				(void)printf(" published");
			if (sin->sin_len != 8)
				(void)printf("(weird)");
		}
		(void)printf("\n");
d483 35
d534 1
@


1.16
log
@Spelling: wierd -> weird
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.15 2000/09/24 22:12:25 miod Exp $ */
d449 2
a450 2
	(void)printf("%x:%x:%x:%x:%x:%x", cp[0], cp[1], cp[2], cp[3], cp[4],
	    cp[5]);
@


1.15
log
@Correctly ignore -n flag with -d when both options are separate (i.e.
arp -n -d, not arp -nd), millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.14 1999/05/16 00:43:44 ho Exp $ */
d439 1
a439 1
				(void)printf("(wierd)");
@


1.14
log
@Added 'permanent' keyword for non-overwritable static ARP entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.13 1998/09/29 02:22:14 millert Exp $ */
d98 1
a98 1
	int ch;
d106 1
d116 1
a116 1
			if (argc < 3 || argc > 4)
d118 1
a118 1
			(void)delete(argv[2], argv[3]);
@


1.13
log
@only spew 'illegal option' once  if they give an unsupported optino
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.12 1998/05/14 21:16:42 deraadt Exp $ */
d230 5
d239 8
d426 2
d429 1
a429 1
			(void)printf(" permanent");
d459 1
a459 1
	    "usage: arp -s hostname ether_addr [temp] [pub]\n");
@


1.12
log
@more careful scanf
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.11 1998/05/11 01:34:50 deraadt Exp $ */
d101 1
d108 1
@


1.11
log
@set max field width of %s correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.10 1997/11/28 05:34:41 art Exp $ */
d158 1
a158 1
		i = sscanf(line, "%50s %50s %50s %50s %50s", arg[0], arg[1], arg[2],
@


1.10
log
@I'm amazed that noone has ever misspelled the ethernet address when
doing an arp -s. Well I was the first. ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.9 1997/11/21 22:42:55 deraadt Exp $ */
d158 1
a158 1
		i = sscanf(line, "%s %s %s %s %s", arg[0], arg[1], arg[2],
@


1.9
log
@bail if no arp entries
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.8 1997/09/12 04:07:16 millert Exp $ */
d218 2
@


1.8
log
@Kill extra newline in err()/warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: arp.c,v 1.12 1995/04/24 13:25:18 cgd Exp $ */
d376 2
@


1.7
log
@int vs in_addr_t
@
text
@d1 1
d522 1
a522 1
		warnx("%s: %s\n", host, hstrerror(h_errno));
@


1.6
log
@make "arp -na" and "arp -an" do the same thing; paul@@wit387304.student.utwente.nl
@
text
@d78 1
a78 1
void dump __P((u_long));
d356 1
a356 1
	u_long addr;
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d101 6
a116 1
			nflag = 1;
@


1.4
log
@warnx, from netbsd
@
text
@d100 1
a100 1
	while ((ch = getopt(argc, argv, "andsf")) != EOF)
@


1.3
log
@fix warnings
@
text
@a510 1
	extern char *__progname;	/* Program name, from crt0. */
d516 1
a516 2
		(void)fprintf(stderr, "%s: %s: ", __progname, host);
		herror(NULL);
@


1.2
log
@not very well tested ether_aton() cleanup
@
text
@d75 1
a277 1
	u_char *ea;
a301 2
	u_char *ea;
	char *eaddr;
a512 1
	u_long addr;
@


1.1
log
@Initial revision
@
text
@a77 1
int ether_aton __P((const char *, u_char *));
d195 3
a197 2
	u_char *ea;
	char *host = argv[0], *eaddr;
d210 3
a212 3
	ea = (u_char *)LLADDR(&sdl_m);
	if (ether_aton(eaddr, ea) == 0)
		sdl_m.sdl_alen = 6;
a424 18
}

int
ether_aton(a, n)
	const char *a;
	u_char *n;
{
	int i, o[6];

	i = sscanf(a, "%x:%x:%x:%x:%x:%x", &o[0], &o[1], &o[2], &o[3], &o[4],
	    &o[5]);
	if (i != 6) {
		warnx("invalid Ethernet address '%s'", a);
		return (1);
	}
	for (i=0; i<6; i++)
		n[i] = o[i];
	return (0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
