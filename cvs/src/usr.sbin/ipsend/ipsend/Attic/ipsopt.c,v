head	1.4;
access;
symbols
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2001.05.30.02.12.54;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2001.01.17.06.01.27;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	98.01.26.04.17.06;	author dgregor;	state Exp;
branches;
next	1.1;

1.1
date	96.05.10.21.40.59;	author dm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ipsopt.c,v 1.3 2001/01/17 06:01:27 fgsch Exp $	*/

/*
 * Copyright (C) 1995-1998 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#if !defined(lint)
static const char sccsid[] = "@@(#)ipsopt.c	1.2 1/11/96 (C)1995 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ipsopt.c,v 2.1 1999/08/04 17:31:07 darrenr Exp $";
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#ifndef	linux
#include <netinet/ip_var.h>
#endif
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include "ipsend.h"


#ifndef	__P
# ifdef	__STDC__
#  define	__P(x)	x
# else
#  define	__P(x)	()
# endif
#endif


struct ipopt_names ionames[] = {
	{ IPOPT_EOL,	0x01,	1, "eol" },
	{ IPOPT_NOP,	0x02,	1, "nop" },
	{ IPOPT_RR,	0x04,	3, "rr" },	/* 1 route */
	{ IPOPT_TS,	0x08,	8, "ts" },	/* 1 TS */
	{ IPOPT_SECURITY, 0x08,	11, "sec-level" },
	{ IPOPT_LSRR,	0x10,	7, "lsrr" },	/* 1 route */
	{ IPOPT_SATID,	0x20,	4, "satid" },
	{ IPOPT_SSRR,	0x40,	7, "ssrr" },	/* 1 route */
	{ 0, 0, 0, NULL }	/* must be last */
};

struct	ipopt_names secnames[] = {
	{ IPOPT_SECUR_UNCLASS,	0x0100,	0, "unclass" },
	{ IPOPT_SECUR_CONFID,	0x0200,	0, "confid" },
	{ IPOPT_SECUR_EFTO,	0x0400,	0, "efto" },
	{ IPOPT_SECUR_MMMM,	0x0800,	0, "mmmm" },
	{ IPOPT_SECUR_RESTR,	0x1000,	0, "restr" },
	{ IPOPT_SECUR_SECRET,	0x2000,	0, "secret" },
	{ IPOPT_SECUR_TOPSECRET, 0x4000,0, "topsecret" },
	{ 0, 0, 0, NULL }	/* must be last */
};


u_short seclevel(slevel)
char *slevel;
{
	struct ipopt_names *so;

	for (so = secnames; so->on_name; so++)
		if (!strcasecmp(slevel, so->on_name))
			break;

	if (!so->on_name) {
		fprintf(stderr, "no such security level: %s\n", slevel);
		return 0;
	}
	return so->on_value;
}


int addipopt(op, io, len, class)
char *op;
struct ipopt_names *io;
int len;
char *class;
{
	struct in_addr ipadr;
	int olen = len, srr = 0;
	u_short val;
	u_char lvl;
	char *s = op, *t;

	if ((len + io->on_siz) > 48) {
		fprintf(stderr, "options too long\n");
		return 0;
	}
	len += io->on_siz;
	*op++ = io->on_value;
	if (io->on_siz > 1) {
		/*
		 * Allow option to specify RR buffer length in bytes.
		 */
		if (io->on_value == IPOPT_RR) {
			val = (class && *class) ? atoi(class) : 4;
			*op++ = val + io->on_siz;
			len += val;
		} else
			*op++ = io->on_siz;
		*op++ = IPOPT_MINOFF;

		while (class && *class) {
			t = NULL;
			switch (io->on_value)
			{
			case IPOPT_SECURITY :
				lvl = seclevel(class);
				*(op - 1) = lvl;
				break;
			case IPOPT_LSRR :
			case IPOPT_SSRR :
				if ((t = strchr(class, ',')))
					*t = '\0';
				ipadr.s_addr = inet_addr(class);
				srr++;
				bcopy((char *)&ipadr, op, sizeof(ipadr));
				op += sizeof(ipadr);
				break;
			case IPOPT_SATID :
				val = atoi(class);
				bcopy((char *)&val, op, 2);
				break;
			}

			if (t)
				*t++ = ',';
			class = t;
		}
		if (srr)
			s[IPOPT_OLEN] = IPOPT_MINOFF - 1 + 4 * srr;
		if (io->on_value == IPOPT_RR)
			op += val;
		else
			op += io->on_siz - 3;
	}
	return len - olen;
}


u_32_t buildopts(cp, op, len)
char *cp, *op;
int len;
{
	struct ipopt_names *io;
	u_32_t msk = 0;
	char *s, *t;
	int inc, lastop = -1;

	for (s = strtok(cp, ","); s; s = strtok(NULL, ",")) {
		if ((t = strchr(s, '=')))
			*t++ = '\0';
		for (io = ionames; io->on_name; io++) {
			if (strcasecmp(s, io->on_name) || (msk & io->on_bit))
				continue;
			lastop = io->on_value;
			if ((inc = addipopt(op, io, len, t))) {
				op += inc;
				len += inc;
			}
			msk |= io->on_bit;
			break;
		}
		if (!io->on_name) {
			fprintf(stderr, "unknown IP option name %s\n", s);
			return 0;
		}
	}

	if (len & 3) {
		while (len & 3) {
			*op++ = ((len & 3) == 3) ? IPOPT_EOL : IPOPT_NOP;
			len++;
		}
	} else {
		if (lastop != IPOPT_EOL) {
			if (lastop == IPOPT_NOP)
				*(op - 1) = IPOPT_EOL;
			else {
				*op++ = IPOPT_NOP;
				*op++ = IPOPT_NOP;
				*op++ = IPOPT_NOP;
				*op = IPOPT_EOL;
				len += 4;
			}
		}
	}
	return len;
}
@


1.3
log
@2nd part of the ipf code; need more testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@IPF 3.2.3
@
text
@d1 2
a2 1
/*      $OpenBSD$      */
d4 1
a4 1
 * Copyright (C) 1995-1997 by Darren Reed.
d12 1
a12 1
static const char rcsid[] = "@@(#)$Id: ipsopt.c,v 2.0.2.10 1997/09/28 07:13:28 darrenr Exp $";
@


1.1
log
@ipfilter 3.0.4
@
text
@d1 1
d3 1
a3 1
 * (C)opyright 1995 by Darren Reed.
d5 3
a7 3
 * This code may be freely distributed as long as it retains this notice
 * and is not changed in any way.  The author accepts no responsibility
 * for the use of this software.  I hate legaleese, don't you ?
d9 3
a11 2
#ifndef	lint
static	char	sccsid[] = "@@(#)ipsopt.c	1.2 1/11/96 (C)1995 Darren Reed";
d15 1
d22 15
a36 1
#include "ip_compat.h"
a37 6
struct ipopt_names {
	int	on_value;
	int	on_bit;
	int	on_siz;
	char	*on_name;
};
d42 1
a42 1
	{ IPOPT_RR,	0x04,	7, "rr" },	/* 1 route */
a66 1
	u_short level = 0;
d80 69
a148 1
u_long optname(cp, op)
d150 1
d152 4
a155 5
	struct ipopt_names *io, *so;
	u_short lvl;
	u_long msk = 0;
	char *s, *sec, *t;
	int len = 0;
d163 4
a166 15
			if ((len + io->on_siz) > 48) {
				fprintf(stderr, "options too long\n");
				return 0;
			}
			len += io->on_siz;
			*op++ = io->on_value;
			if (io->on_siz > 1) {
				*op++ = io->on_siz;
				*op++ = IPOPT_MINOFF;

				if (t && !strcasecmp(s, "sec-level")) {
					lvl = seclevel(t);
					bcopy(&lvl, op, sizeof(lvl));
				}
				op += io->on_siz - 3;
d176 19
a194 2
	*op++ = IPOPT_EOL;
	len++;
@
