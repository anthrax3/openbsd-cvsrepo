head	1.5;
access;
symbols
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2001.05.30.02.12.50;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2001.01.17.06.01.25;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	98.01.26.04.16.54;	author dgregor;	state Exp;
branches;
next	1.2;

1.2
date	97.04.06.20.16.30;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.05.10.21.40.56;	author dm;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: sock.c,v 1.4 2001/01/17 06:01:25 fgsch Exp $	*/

/*
 * sock.c (C) 1995-1998 Darren Reed
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#if !defined(lint)
static const char sccsid[] = "@@(#)sock.c	1.2 1/11/96 (C)1995 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: sock.c,v 2.1.4.1 2000/12/16 21:05:44 darrenr Exp $";
#endif
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <stddef.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/param.h>
#include <sys/stat.h>
#ifndef	ultrix
#include <fcntl.h>
#endif
#if (__FreeBSD_version >= 300000)
# include <sys/dirent.h>
#else
# include <sys/dir.h>
#endif
#define _KERNEL
#define	KERNEL
#ifdef	ultrix
# undef	LOCORE
# include <sys/smp_lock.h>
#endif
#include <sys/file.h>
#undef  _KERNEL
#undef  KERNEL
#include <nlist.h>
#include <sys/user.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/proc.h>
#if !defined(ultrix) && !defined(hpux)
# include <kvm.h>
#endif
#ifdef sun
#include <sys/systm.h>
#include <sys/session.h>
#endif
#if BSD >= 199103
#include <sys/sysctl.h>
#include <sys/filedesc.h>
#include <paths.h>
#endif
#include <math.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <net/if.h>
#include <net/route.h>
#include <netinet/ip_var.h>
#include <netinet/in_pcb.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include "ipsend.h"

int	nproc;
struct	proc	*proc;

#ifndef	KMEM
# ifdef	_PATH_KMEM
#  define	KMEM	_PATH_KMEM
# endif
#endif
#ifndef	KERNEL
# ifdef	_PATH_UNIX
#  define	KERNEL	_PATH_UNIX
# endif
#endif
#ifndef	KMEM
# define	KMEM	"/dev/kmem"
#endif
#ifndef	KERNEL
# define	KERNEL	"/vmunix"
#endif


#if BSD < 199103
static	struct	proc	*getproc __P((void));
#else
static	struct	kinfo_proc	*getproc __P((void));
#endif


int	kmemcpy(buf, pos, n)
char	*buf;
void	*pos;
int	n;
{
	static	int	kfd = -1;
	off_t	offset = (u_long)pos;

	if (kfd == -1)
		kfd = open(KMEM, O_RDONLY);

	if (lseek(kfd, offset, SEEK_SET) == -1)
	    {
		perror("lseek");
		return -1;
	    }
	if (read(kfd, buf, n) == -1)
	    {
		perror("read");
		return -1;
	    }
	return n;
}

struct	nlist	names[4] = {
	{ "_proc" },
	{ "_nproc" },
#ifdef	ultrix
	{ "_u" },
#else
	{ NULL },
#endif
	{ NULL }
	};

#if BSD < 199103
static struct proc *getproc()
{
	struct	proc	*p;
	pid_t	pid = getpid();
	int	siz, n;

	n = nlist(KERNEL, names);
	if (n != 0)
	    {
		fprintf(stderr, "nlist(%#x) == %d\n", names, n);
		return NULL;
	    }
	if (KMCPY(&nproc, names[1].n_value, sizeof(nproc)) == -1)
	    {
		fprintf(stderr, "read nproc (%#x)\n", names[1].n_value);
		return NULL;
	    }
	siz = nproc * sizeof(struct proc);
	if (KMCPY(&p, names[0].n_value, sizeof(p)) == -1)
	    {
		fprintf(stderr, "read(%#x,%#x,%d) proc\n",
			names[0].n_value, &p, sizeof(p));
		return NULL;
	    }
	proc = (struct proc *)malloc(siz);
	if (KMCPY(proc, p, siz) == -1)
	    {
		fprintf(stderr, "read(%#x,%#x,%d) proc\n",
			p, proc, siz);
		return NULL;
	    }

	p = proc;

	for (n = nproc; n; n--, p++)
		if (p->p_pid == pid)
			break;
	if (!n)
		return NULL;

	return p;
}


struct	tcpcb	*find_tcp(fd, ti)
int	fd;
struct	tcpiphdr *ti;
{
	struct	tcpcb	*t;
	struct	inpcb	*i;
	struct	socket	*s;
	struct	user	*up;
	struct	proc	*p;
	struct	file	*f, **o;

	if (!(p = getproc()))
		return NULL;
printf("fl %x ty %x cn %d mc %d\n",
f->f_flag, f->f_type, f->f_count, f->f_msgcount);
	up = (struct user *)malloc(sizeof(*up));
#ifndef	ultrix
	if (KMCPY(up, p->p_uarea, sizeof(*up)) == -1)
	    {
		fprintf(stderr, "read(%#x,%#x) failed\n", p, p->p_uarea);
		return NULL;
	    }
#else
	if (KMCPY(up, names[2].n_value, sizeof(*up)) == -1)
	    {
		fprintf(stderr, "read(%#x,%#x) failed\n", p, names[2].n_value);
		return NULL;
	    }
#endif

	o = (struct file **)calloc(1, sizeof(*o) * (up->u_lastfile + 1));
	if (KMCPY(o, up->u_ofile, (up->u_lastfile + 1) * sizeof(*o)) == -1)
	    {
		fprintf(stderr, "read(%#x,%#x,%d) - u_ofile - failed\n",
			up->u_ofile, o, sizeof(*o));
		return NULL;
	    }
	f = (struct file *)calloc(1, sizeof(*f));
	if (KMCPY(f, o[fd], sizeof(*f)) == -1)
	    {
		fprintf(stderr, "read(%#x,%#x,%d) - o[fd] - failed\n",
			up->u_ofile[fd], f, sizeof(*f));
		return NULL;
	    }

	s = (struct socket *)calloc(1, sizeof(*s));
	if (KMCPY(s, f->f_data, sizeof(*s)) == -1)
	    {
		fprintf(stderr, "read(%#x,%#x,%d) - f_data - failed\n",
			o[fd], s, sizeof(*s));
		return NULL;
	    }

	i = (struct inpcb *)calloc(1, sizeof(*i));
	if (KMCPY(i, s->so_pcb, sizeof(*i)) == -1)
	    {
		fprintf(stderr, "kvm_read(%#x,%#x,%d) - so_pcb - failed\n",
			s->so_pcb, i, sizeof(*i));
		return NULL;
	    }

	t = (struct tcpcb *)calloc(1, sizeof(*t));
	if (KMCPY(t, i->inp_ppcb, sizeof(*t)) == -1)
	    {
		fprintf(stderr, "read(%#x,%#x,%d) - inp_ppcb - failed\n",
			i->inp_ppcb, t, sizeof(*t));
		return NULL;
	    }
	return (struct tcpcb *)i->inp_ppcb;
}
#else
static struct kinfo_proc *getproc()
{
	static	struct	kinfo_proc kp;
	pid_t	pid = getpid();
	int	mib[4];
	size_t	n;

	mib[0] = CTL_KERN;
	mib[1] = KERN_PROC;
	mib[2] = KERN_PROC_PID;
	mib[3] = pid;

	n = sizeof(kp);
	if (sysctl(mib, 4, &kp, &n, NULL, 0) == -1)
	    {
		perror("sysctl");
		return NULL;
	    }
	return &kp;
}


struct	tcpcb	*find_tcp(tfd, ti)
int	tfd;
struct	tcpiphdr *ti;
{
	struct	tcpcb	*t;
	struct	inpcb	*i;
	struct	socket	*s;
	struct	filedesc	*fd;
	struct	kinfo_proc	*p;
	struct	file	*f, **o;

	if (!(p = getproc()))
		return NULL;

	fd = (struct filedesc *)malloc(sizeof(*fd));
#if defined( __FreeBSD_version) && __FreeBSD_version >= 500013
	if (KMCPY(fd, p->ki_fd, sizeof(*fd)) == -1)
	    {
		fprintf(stderr, "read(%#lx,%#lx) failed\n",
			(u_long)p, (u_long)p->ki_fd);
		return NULL;
	    }
#else
	if (KMCPY(fd, p->kp_proc.p_fd, sizeof(*fd)) == -1)
	    {
		fprintf(stderr, "read(%#lx,%#lx) failed\n",
			(u_long)p, (u_long)p->kp_proc.p_fd);
		return NULL;
	    }
#endif

	o = (struct file **)calloc(1, sizeof(*o) * (fd->fd_lastfile + 1));
	if (KMCPY(o, fd->fd_ofiles, (fd->fd_lastfile + 1) * sizeof(*o)) == -1)
	    {
		fprintf(stderr, "read(%#lx,%#lx,%lu) - u_ofile - failed\n",
			(u_long)fd->fd_ofiles, (u_long)o, (u_long)sizeof(*o));
		return NULL;
	    }
	f = (struct file *)calloc(1, sizeof(*f));
	if (KMCPY(f, o[tfd], sizeof(*f)) == -1)
	    {
		fprintf(stderr, "read(%#lx,%#lx,%lu) - o[tfd] - failed\n",
			(u_long)o[tfd], (u_long)f, (u_long)sizeof(*f));
		return NULL;
	    }

	s = (struct socket *)calloc(1, sizeof(*s));
	if (KMCPY(s, f->f_data, sizeof(*s)) == -1)
	    {
		fprintf(stderr, "read(%#lx,%#lx,%lu) - f_data - failed\n",
			(u_long)f->f_data, (u_long)s, (u_long)sizeof(*s));
		return NULL;
	    }

	i = (struct inpcb *)calloc(1, sizeof(*i));
	if (KMCPY(i, s->so_pcb, sizeof(*i)) == -1)
	    {
		fprintf(stderr, "kvm_read(%#lx,%#lx,%lu) - so_pcb - failed\n",
			(u_long)s->so_pcb, (u_long)i, (u_long)sizeof(*i));
		return NULL;
	    }

	t = (struct tcpcb *)calloc(1, sizeof(*t));
	if (KMCPY(t, i->inp_ppcb, sizeof(*t)) == -1)
	    {
		fprintf(stderr, "read(%#lx,%#lx,%lu) - inp_ppcb - failed\n",
			(u_long)i->inp_ppcb, (u_long)t, (u_long)sizeof(*t));
		return NULL;
	    }
	return (struct tcpcb *)i->inp_ppcb;
}
#endif /* BSD < 199301 */

int	do_socket(dev, mtu, ti, gwip)
char	*dev;
int	mtu;
struct	tcpiphdr *ti;
struct	in_addr	gwip;
{
	struct	sockaddr_in	rsin, lsin;
	struct	tcpcb	*t, tcb;
	int	fd, nfd, len;

	printf("Dest. Port: %d\n", ti->ti_dport);

	fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd == -1)
	    {
		perror("socket");
		return -1;
	    }

	if (fcntl(fd, F_SETFL, FNDELAY) == -1)
	    {
		perror("fcntl");
		return -1;
	    }

	bzero((char *)&lsin, sizeof(lsin));
	lsin.sin_family = AF_INET;
	bcopy((char *)&ti->ti_src, (char *)&lsin.sin_addr,
	      sizeof(struct in_addr));
	if (bind(fd, (struct sockaddr *)&lsin, sizeof(lsin)) == -1)
	    {
		perror("bind");
		return -1;
	    }
	len = sizeof(lsin);
	(void) getsockname(fd, (struct sockaddr *)&lsin, &len);
	ti->ti_sport = lsin.sin_port;
	printf("sport %d\n", ntohs(lsin.sin_port));
	nfd = initdevice(dev, ntohs(lsin.sin_port), 1);

	if (!(t = find_tcp(fd, ti)))
		return -1;

	bzero((char *)&rsin, sizeof(rsin));
	rsin.sin_family = AF_INET;
	bcopy((char *)&ti->ti_dst, (char *)&rsin.sin_addr,
	      sizeof(struct in_addr));
	rsin.sin_port = ti->ti_dport;
	if (connect(fd, (struct sockaddr *)&rsin, sizeof(rsin)) == -1 &&
	    errno != EINPROGRESS)
	    {
		perror("connect");
		return -1;
	    }
	KMCPY(&tcb, t, sizeof(tcb));
	ti->ti_win = tcb.rcv_adv;
	ti->ti_seq = tcb.snd_nxt - 1;
	ti->ti_ack = tcb.rcv_nxt;

	if (send_tcp(nfd, mtu, (ip_t *)ti, gwip) == -1)
		return -1;
	(void)write(fd, "Hello World\n", 12);
	sleep(2);
	close(fd);
	return 0;
}
@


1.4
log
@2nd part of the ipf code; need more testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3
log
@IPF 3.2.3
@
text
@d1 2
d4 1
a4 1
 * sock.c (C) 1995-1997 Darren Reed
d12 1
a12 1
static const char rcsid[] = "@@(#)$Id: sock.c,v 2.0.2.9.2.1 1997/11/28 03:36:01 darrenr Exp $";
d27 5
a31 1
#include <sys/dir.h>
d287 8
d301 1
@


1.2
log
@Use a size_t when necesary.
@
text
@d2 1
a2 1
 * sock.c (C) 1995 Darren Reed
d4 3
a6 5
 * The author provides this program as-is, with no gaurantee for its
 * suitability for any specific purpose.  The author takes no responsibility
 * for the misuse/abuse of this program and provides it for the sole purpose
 * of testing packet filter policies.  This file maybe distributed freely
 * providing it is not modified and that this notice remains in tact.
d8 3
a10 2
#ifndef	lint
static	char	sccsid[] = "@@(#)sock.c	1.2 1/11/96 (C)1995 Darren Reed";
d22 1
d24 1
d28 4
d40 3
a42 1
#include <kvm.h>
d63 1
a63 1
#include <netinet/tcpip.h>
d85 8
d99 1
d104 1
a104 1
	if (lseek(kfd, (off_t)(u_long)pos, SEEK_SET) == -1)
d117 1
a117 1
struct	nlist	names[3] = {
d120 5
d129 1
a129 1
struct	proc	*getproc()
d141 1
a141 2
	if (kmemcpy((char *)&nproc, (void *)names[1].n_value,
		    sizeof(nproc)) == -1)
d147 1
a147 1
	if (kmemcpy((char *)&p, (void *)names[0].n_value, sizeof(p)) == -1)
d154 1
a154 1
	if (kmemcpy((char *)proc, (void *)p, siz) == -1)
d186 2
a187 1

d189 2
a190 1
	if (kmemcpy((char *)up, (void *)p->p_uarea, sizeof(*up)) == -1)
d195 7
d204 1
a204 2
	if (kmemcpy((char *)o, (void *)up->u_ofile,
		    (up->u_lastfile + 1) * sizeof(*o)) == -1)
d207 1
a207 1
			up->u_ofile_arr, o, sizeof(*o));
d211 1
a211 1
	if (kmemcpy((char *)f, (void *)o[fd], sizeof(*f)) == -1)
d214 1
a214 1
			up->u_ofile_arr[fd], f, sizeof(*f));
d219 1
a219 1
	if (kmemcpy((char *)s, (void *)f->f_data, sizeof(*s)) == -1)
d227 1
a227 1
	if (kmemcpy((char *)i, (void *)s->so_pcb, sizeof(*i)) == -1)
d235 1
a235 1
	if (kmemcpy((char *)t, (void *)i->inp_ppcb, sizeof(*t)) == -1)
d244 1
a244 1
struct	kinfo_proc	*getproc()
d256 1
a256 1
	n = 1;
d281 1
a281 1
	if (kmemcpy((char *)fd, (void *)p->kp_proc.p_fd, sizeof(*fd)) == -1)
d283 2
a284 1
		fprintf(stderr, "read(%#x,%#x) failed\n", p, p->kp_proc.p_fd);
d289 1
a289 2
	if (kmemcpy((char *)o, (void *)fd->fd_ofiles,
		    (fd->fd_lastfile + 1) * sizeof(*o)) == -1)
d291 2
a292 2
		fprintf(stderr, "read(%#x,%#x,%d) - u_ofile - failed\n",
			fd->fd_ofiles, o, sizeof(*o));
d296 1
a296 1
	if (kmemcpy((char *)f, (void *)o[tfd], sizeof(*f)) == -1)
d298 2
a299 2
		fprintf(stderr, "read(%#x,%#x,%d) - o[tfd] - failed\n",
			o[tfd], f, sizeof(*f));
d304 1
a304 1
	if (kmemcpy((char *)s, (void *)f->f_data, sizeof(*s)) == -1)
d306 2
a307 2
		fprintf(stderr, "read(%#x,%#x,%d) - f_data - failed\n",
			f->f_data, s, sizeof(*s));
d312 1
a312 1
	if (kmemcpy((char *)i, (void *)s->so_pcb, sizeof(*i)) == -1)
d314 2
a315 2
		fprintf(stderr, "kvm_read(%#x,%#x,%d) - so_pcb - failed\n",
			s->so_pcb, i, sizeof(*i));
d320 1
a320 1
	if (kmemcpy((char *)t, (void *)i->inp_ppcb, sizeof(*t)) == -1)
d322 2
a323 2
		fprintf(stderr, "read(%#x,%#x,%d) - inp_ppcb - failed\n",
			i->inp_ppcb, t, sizeof(*t));
d330 1
a330 1
int	do_socket(dev, mtu, ti, gwip, flags)
a334 1
int	flags;
d368 1
a368 1
	nfd = initdevice(dev, ntohs(lsin.sin_port));
d384 1
a384 1
	kmemcpy((char*)&tcb, (void *)t, sizeof(tcb));
d389 1
a389 1
	if (send_tcp(nfd, mtu, ti, gwip, TH_SYN) == -1)
@


1.1
log
@ipfilter 3.0.4
@
text
@d220 2
a221 1
	int	siz, n, mib[4];
@
