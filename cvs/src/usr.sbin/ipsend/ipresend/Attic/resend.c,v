head	1.5;
access;
symbols
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2001.05.30.02.12.52;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2001.01.17.06.01.26;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	98.01.26.04.16.59;	author dgregor;	state Exp;
branches;
next	1.2;

1.2
date	97.04.06.20.15.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.05.10.21.40.57;	author dm;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: resend.c,v 1.4 2001/01/17 06:01:26 fgsch Exp $	*/

/*
 * resend.c (C) 1995-1998 Darren Reed
 *
 * This was written to test what size TCP fragments would get through
 * various TCP/IP packet filters, as used in IP firewalls.  In certain
 * conditions, enough of the TCP header is missing for unpredictable
 * results unless the filter is aware that this can happen.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#if !defined(lint)
static const char sccsid[] = "@@(#)resend.c	1.3 1/11/96 (C)1995 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: resend.c,v 2.1 1999/08/04 17:31:12 darrenr Exp $";
#endif
#include <stdio.h>
#include <netdb.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/ip_icmp.h>
#ifndef	linux
# include <netinet/ip_var.h>
# include <netinet/if_ether.h>
# if __FreeBSD_version >= 300000
#  include <net/if_var.h>
# endif
#endif
#include "ipsend.h"

extern	int	opts;

static	u_char	pbuf[65536];	/* 1 big packet */
void	printpacket __P((ip_t *));


void printpacket(ip)
ip_t	*ip;
{
	tcphdr_t *t;
	int i, j;

	t = (tcphdr_t *)((char *)ip + (ip->ip_hl << 2));
	if (ip->ip_tos)
		printf("tos %#x ", ip->ip_tos);
	if (ip->ip_off & 0x3fff)
		printf("frag @@%#x ", (ip->ip_off & 0x1fff) << 3);
	printf("len %d id %d ", ip->ip_len, ip->ip_id);
	printf("ttl %d p %d src %s", ip->ip_ttl, ip->ip_p,
		inet_ntoa(ip->ip_src));
	if (ip->ip_p == IPPROTO_TCP || ip->ip_p == IPPROTO_UDP)
		printf(",%d", t->th_sport);
	printf(" dst %s", inet_ntoa(ip->ip_dst));
	if (ip->ip_p == IPPROTO_TCP || ip->ip_p == IPPROTO_UDP)
		printf(",%d", t->th_dport);
	if (ip->ip_p == IPPROTO_TCP) {
		printf(" seq %lu:%lu flags ",
			(u_long)t->th_seq, (u_long)t->th_ack);
		for (j = 0, i = 1; i < 256; i *= 2, j++)
			if (t->th_flags & i)
				printf("%c", "FSRPAU--"[j]);
	}
	putchar('\n');
}


int	ip_resend(dev, mtu, r, gwip, datain)
char	*dev;
int	mtu;
struct	in_addr	gwip;
struct	ipread	*r;
char	*datain;
{
	ether_header_t	*eh;
	char	dhost[6];
	ip_t	*ip;
	int	fd, wfd = initdevice(dev, 0, 5), len, i;

	if (datain)
		fd = (*r->r_open)(datain);
	else
		fd = (*r->r_open)("-");
 
	if (fd < 0)
		exit(-1);

	ip = (struct ip *)pbuf;
	eh = (ether_header_t *)malloc(sizeof(*eh));

	bzero((char *)A_A eh->ether_shost, sizeof(eh->ether_shost));
	if (gwip.s_addr && (arp((char *)&gwip, dhost) == -1))
	    {
		perror("arp");
		return -2;
	    }

	while ((i = (*r->r_readip)((char *)pbuf, sizeof(pbuf), NULL, NULL)) > 0)
	    {
		if (!(opts & OPT_RAW)) {
			len = ntohs(ip->ip_len);
			eh = (ether_header_t *)realloc((char *)eh, sizeof(*eh) + len);
			eh->ether_type = htons((u_short)ETHERTYPE_IP);
			if (!gwip.s_addr) {
				if (arp((char *)&gwip,
					(char *)A_A eh->ether_dhost) == -1) {
					perror("arp");
					continue;
				}
			} else
				bcopy(dhost, (char *)A_A eh->ether_dhost,
				      sizeof(dhost));
			if (!ip->ip_sum)
				ip->ip_sum = chksum((u_short *)ip,
						    ip->ip_hl << 2);
			bcopy(ip, (char *)(eh + 1), len);
			len += sizeof(*eh);
			printpacket(ip);
		} else {
			eh = (ether_header_t *)pbuf;
			len = i;
		}

		if (sendip(wfd, (char *)eh, len) == -1)
		    {
			perror("send_packet");
			break;
		    }
	    }
	(*r->r_close)();
	return 0;
}
@


1.4
log
@2nd part of the ipf code; need more testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3
log
@IPF 3.2.3
@
text
@d1 2
a2 1
/*     $OpenBSD$      */
d4 1
a4 1
 * resend.c (C) 1995-1997 Darren Reed
d17 1
a17 1
static const char rcsid[] = "@@(#)$Id: resend.c,v 2.0.2.12 1997/10/23 11:42:46 darrenr Exp $";
d46 1
a46 1
static	u_char	buf[65536];	/* 1 big packet */
d100 1
a100 1
	ip = (struct ip *)buf;
d110 1
a110 1
	while ((i = (*r->r_readip)(buf, sizeof(buf), NULL, NULL)) > 0)
d132 1
a132 1
			eh = (ether_header_t *)buf;
@


1.2
log
@#include stdlib.h to get malloc(3) and calloc(3) definitions.
Fixes compiler warnings.
@
text
@d1 1
d3 1
a3 1
 * resend.c (C) 1995 Darren Reed
d10 3
d14 3
a16 2
#ifndef	lint
static	char	sccsid[] = "@@(#)resend.c	1.3 1/11/96 (C)1995 Darren Reed";
a18 1
#include <stdlib.h>
d21 2
d28 1
d35 5
a39 3
#include <netinet/ip_var.h>
#include <netinet/tcpip.h>
#include <netinet/if_ether.h>
d41 1
a41 6
#include "ip_compat.h"
#ifdef	linux
#include <linux/sockios.h>
#include "tcpip.h"
#endif
#include "ipt.h"
d43 1
d46 1
d49 1
a49 1
printpacket(ip)
d67 1
a67 1
		printf(",%d", t->th_sport);
d69 2
a70 1
		printf(" seq %u:%u flags ", t->th_seq, t->th_ack);
d81 1
d102 1
a102 1
	bzero(&eh->ether_shost, sizeof(eh->ether_shost));
d111 23
a133 13
		len = ntohs(ip->ip_len);
		eh = (ether_header_t *)realloc((char *)eh, sizeof(*eh) + len);
		eh->ether_type = htons((u_short)ETHERTYPE_IP);
		if (!gwip.s_addr) {
			if (arp((char *)&gwip,
				(char *)&eh->ether_dhost) == -1) {
				perror("arp");
				continue;
			}
		} else
			bcopy(dhost, (char *)&eh->ether_dhost, sizeof(dhost));
		bcopy(ip, (char *)(eh + 1), len);
		printpacket(ip);
d135 1
a135 1
		if (sendip(wfd, eh, sizeof(*eh) + len) == -1)
@


1.1
log
@ipfilter 3.0.4
@
text
@d14 1
@
