head	1.113;
access;
symbols
	OPENBSD_6_1_BASE:1.113
	OPENBSD_6_0:1.107.0.2
	OPENBSD_6_0_BASE:1.107
	OPENBSD_5_9:1.106.0.2
	OPENBSD_5_9_BASE:1.106
	OPENBSD_5_8:1.94.0.4
	OPENBSD_5_8_BASE:1.94
	OPENBSD_5_7:1.92.0.2
	OPENBSD_5_7_BASE:1.92
	OPENBSD_5_6:1.79.0.6
	OPENBSD_5_6_BASE:1.79
	OPENBSD_5_5:1.79.0.4
	OPENBSD_5_5_BASE:1.79
	OPENBSD_5_4:1.69.0.10
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.69.0.8
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.69.0.6
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.4
	OPENBSD_5_0:1.69.0.2
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.68.0.4
	OPENBSD_4_9_BASE:1.68
	OPENBSD_4_8:1.68.0.2
	OPENBSD_4_8_BASE:1.68
	OPENBSD_4_7:1.66.0.2
	OPENBSD_4_7_BASE:1.66
	OPENBSD_4_6:1.66.0.4
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.64.0.2
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.61.0.2
	OPENBSD_4_4_BASE:1.61
	OPENBSD_4_3:1.58.0.2
	OPENBSD_4_3_BASE:1.58
	OPENBSD_4_2:1.49.0.4
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.49.0.2
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14;
locks; strict;
comment	@ * @;


1.113
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.112;
commitid	eA8b246voAapPTkX;

1.112
date	2016.12.01.16.24.48;	author mestre;	state Exp;
branches;
next	1.111;
commitid	dQx5Z849JAGEMknd;

1.111
date	2016.09.26.17.17.01;	author rzalamena;	state Exp;
branches;
next	1.110;
commitid	BmpOnKpM0apagYju;

1.110
date	2016.09.26.16.55.02;	author rzalamena;	state Exp;
branches;
next	1.109;
commitid	CSM07eEL9yrHalR4;

1.109
date	2016.09.14.13.20.16;	author rzalamena;	state Exp;
branches;
next	1.108;
commitid	FUtuYlECIdeLHfjN;

1.108
date	2016.09.03.11.52.06;	author reyk;	state Exp;
branches;
next	1.107;
commitid	NAWlzXnfvHaWyDX5;

1.107
date	2016.05.02.06.25.29;	author semarie;	state Exp;
branches;
next	1.106;
commitid	JvT5tqLfnlV03u6C;

1.106
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.105;
commitid	LQHdRRMF0nq0fugE;

1.105
date	2016.01.27.21.48.34;	author reyk;	state Exp;
branches;
next	1.104;
commitid	KTDuqL1fW4bPtfRB;

1.104
date	2016.01.27.21.36.25;	author bcook;	state Exp;
branches;
next	1.103;
commitid	GFS3CWizsSk76UNf;

1.103
date	2016.01.11.15.30.56;	author deraadt;	state Exp;
branches;
next	1.102;
commitid	f27iWtMrqwPyvy8A;

1.102
date	2015.12.29.18.23.28;	author millert;	state Exp;
branches;
next	1.101;
commitid	S3pN9NyR5WrA1TLG;

1.101
date	2015.12.19.17.55.29;	author reyk;	state Exp;
branches;
next	1.100;
commitid	xe8YS3ftA7mmBwbB;

1.100
date	2015.12.05.13.12.16;	author claudio;	state Exp;
branches;
next	1.99;
commitid	1u4z6EiD1xQ1Wwbx;

1.99
date	2015.11.24.01.03.25;	author deraadt;	state Exp;
branches;
next	1.98;
commitid	w82qmLlikEZFzR4v;

1.98
date	2015.10.23.16.39.13;	author deraadt;	state Exp;
branches;
next	1.97;
commitid	1XU164ibtLjy6HU5;

1.97
date	2015.10.12.06.50.08;	author reyk;	state Exp;
branches;
next	1.96;
commitid	to5fPpeGvAbrgkr0;

1.96
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	sbrB3Q5CNxcwZpfU;

1.95
date	2015.10.03.02.47.15;	author deraadt;	state Exp;
branches;
next	1.94;
commitid	rxFLiUMaEGvkSpmi;

1.94
date	2015.07.18.00.53.44;	author bcook;	state Exp;
branches;
next	1.93;
commitid	X2stLxrcDblnYkzc;

1.93
date	2015.03.11.19.38.48;	author jmc;	state Exp;
branches;
next	1.92;
commitid	idfRkC5LcPgxlodv;

1.92
date	2015.02.11.03.16.57;	author reyk;	state Exp;
branches;
next	1.91;
commitid	taIadPYhd9KF76Zf;

1.91
date	2015.02.10.11.46.39;	author reyk;	state Exp;
branches;
next	1.90;
commitid	azl2PYCfRcxq0H2y;

1.90
date	2015.02.10.11.16.47;	author reyk;	state Exp;
branches;
next	1.89;
commitid	36LOhhZwz69ve7Un;

1.89
date	2015.02.10.06.40.08;	author reyk;	state Exp;
branches;
next	1.88;
commitid	pXoTR74Ztt0R3SV0;

1.88
date	2015.01.21.03.14.10;	author bcook;	state Exp;
branches;
next	1.87;
commitid	Y0dDbtaeevmLLVjt;

1.87
date	2015.01.19.20.47.03;	author bcook;	state Exp;
branches;
next	1.86;
commitid	keCX09bmkXTcMfIX;

1.86
date	2015.01.14.21.14.27;	author naddy;	state Exp;
branches;
next	1.85;
commitid	LtgwgDNkx39mhArh;

1.85
date	2015.01.13.14.52.47;	author bcook;	state Exp;
branches;
next	1.84;
commitid	Or61MUwT6EzTkoKm;

1.84
date	2015.01.13.02.28.56;	author bcook;	state Exp;
branches;
next	1.83;
commitid	h77ELH1lDWjNCTWO;

1.83
date	2015.01.09.07.35.37;	author deraadt;	state Exp;
branches;
next	1.82;
commitid	X9qvCMjSyjyh2fK9;

1.82
date	2015.01.08.00.30.08;	author bcook;	state Exp;
branches;
next	1.81;
commitid	KDtICkil0jI83gxu;

1.81
date	2015.01.04.01.24.43;	author bcook;	state Exp;
branches;
next	1.80;
commitid	0mLKLwEPo7XcKuWK;

1.80
date	2015.01.04.01.11.24;	author bcook;	state Exp;
branches;
next	1.79;
commitid	UXnNOdv82uPjplnj;

1.79
date	2014.02.10.09.12.34;	author dtucker;	state Exp;
branches;
next	1.78;

1.78
date	2014.01.28.22.57.37;	author sthen;	state Exp;
branches;
next	1.77;

1.77
date	2014.01.22.02.55.15;	author benno;	state Exp;
branches;
next	1.76;

1.76
date	2014.01.10.22.54.12;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2013.11.13.20.44.39;	author benno;	state Exp;
branches;
next	1.74;

1.74
date	2013.10.16.21.23.59;	author jmc;	state Exp;
branches;
next	1.73;

1.73
date	2013.10.11.19.33.20;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2013.10.09.12.34.12;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2013.10.04.20.30.38;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2013.10.04.14.28.16;	author phessler;	state Exp;
branches;
next	1.69;

1.69
date	2011.03.19.23.40.11;	author okan;	state Exp;
branches;
next	1.68;

1.68
date	2010.07.01.22.16.20;	author eric;	state Exp;
branches;
next	1.67;

1.67
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2009.06.06.18.14.25;	author pyr;	state Exp;
branches;
next	1.65;

1.65
date	2009.06.01.23.21.09;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2009.02.10.16.52.09;	author stevesk;	state Exp;
branches;
next	1.63;

1.63
date	2009.02.06.21.48.00;	author stevesk;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.29.00.06.04;	author stevesk;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.19.21.31.39;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.16.06.13.25;	author ckuethe;	state Exp;
branches;
next	1.59;

1.59
date	2008.05.14.09.32.18;	author pyr;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.31.17.21.35;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.23.22.40.00;	author stevesk;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.22.18.26.21;	author stevesk;	state Exp;
branches;
next	1.55;

1.55
date	2007.12.04.14.52.54;	author fgsch;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.04.11.06.49;	author fgsch;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.22.10.22.30;	author otto;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.13.20.34.12;	author jmc;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.13.14.34.36;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.22.21.04.30;	author ckuethe;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.15.08.19.11;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2006.06.30.16.52.13;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.30.06.39.00;	author otto;	state Exp;
branches;
next	1.46;

1.46
date	2006.06.26.08.10.45;	author otto;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.22.11.11.25;	author otto;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.21.07.42.00;	author otto;	state Exp;
branches;
next	1.43;

1.43
date	2006.06.17.18.40.42;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.07.06.29.03;	author otto;	state Exp;
branches;
next	1.41;

1.41
date	2006.02.21.23.47.00;	author stevesk;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.06.21.27.10;	author wvdputte;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.11.08.08.06;	author dtucker;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.19.17.11.13;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.19.16.42.57;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.26.09.13.06;	author dtucker;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.18.20.46.02;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.31.17.02.43;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.24.10.56.22;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.13.10.06.27;	author dtucker;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.09.20.31.11;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.08.14.28.55;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2005.02.02.18.52.32;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.28.12.32.24;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.22.16.04.11;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.20.15.10.05;	author moritz;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.06.20.57.17;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.10.11.27.54;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.04.23.04.22;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.23.01.53.07;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.09.18.23.21.35;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.18.20.37.12;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.18.20.27.57;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.18.20.01.38;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.15.19.21.25;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.15.19.14.11;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.15.00.08.06;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.12.16.33.59;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.13.11.16.22;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.12.09.38.57;	author dtucker;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.12.09.22.38;	author dtucker;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.09.15.08.54;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.09.11.34.11;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.08.15.06.43;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.07.06.57.13;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.05.07.46.16;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.17.19.17.48;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.01.21.58.08;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.01.16.27.09;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.31.13.55.31;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.31.13.46.16;	author henning;	state Exp;
branches;
next	;


desc
@@


1.113
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@/*	$OpenBSD: ntpd.c,v 1.112 2016/12/01 16:24:48 mestre Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2012 Mike Miller <mmiller@@mgm51.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <errno.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>

#include "ntpd.h"

void		sighdlr(int);
__dead void	usage(void);
int		main(int, char *[]);
void		check_child(void);
int		dispatch_imsg(struct ntpd_conf *, int, char **);
int		dispatch_imsg_ctl(struct ntpd_conf *);
void		reset_adjtime(void);
int		ntpd_adjtime(double);
void		ntpd_adjfreq(double, int);
void		ntpd_settime(double);
void		readfreq(void);
int		writefreq(double);
void		ctl_main(int, char*[]);
const char     *ctl_lookup_option(char *, const char **);
void		show_status_msg(struct imsg *);
void		show_peer_msg(struct imsg *, int);
void		show_sensor_msg(struct imsg *, int);

volatile sig_atomic_t	 quit = 0;
volatile sig_atomic_t	 reconfig = 0;
volatile sig_atomic_t	 sigchld = 0;
struct imsgbuf		*ibuf;
int			 timeout = INFTIM;

extern u_int		 constraint_cnt;

const char		*showopt;

static const char *ctl_showopt_list[] = {
	"peers", "Sensors", "status", "all", NULL
};

void
sighdlr(int sig)
{
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		quit = 1;
		break;
	case SIGCHLD:
		sigchld = 1;
		break;
	case SIGHUP:
		reconfig = 1;
		break;
	}
}

__dead void
usage(void)
{
	extern char *__progname;

	if (strcmp(__progname, "ntpctl") == 0)
		fprintf(stderr,
		    "usage: ntpctl -s all | peers | Sensors | status\n");
	else
		fprintf(stderr, "usage: %s [-dnSsv] [-f file]\n",
		    __progname);
	exit(1);
}

#define POLL_MAX		8
#define PFD_PIPE		0
#define PFD_MAX			1

int
main(int argc, char *argv[])
{
	struct ntpd_conf	 lconf;
	struct pollfd		*pfd = NULL;
	pid_t			 pid;
	const char		*conffile;
	int			 ch, nfds, i, j;
	int			 pipe_chld[2];
	extern char		*__progname;
	u_int			 pfd_elms = 0, new_cnt;
	struct constraint	*cstr;
	struct passwd		*pw;
	void			*newp;
	int			argc0 = argc;
	char			**argv0 = argv;
	char			*pname = NULL;

	if (strcmp(__progname, "ntpctl") == 0) {
		ctl_main(argc, argv);
		/* NOTREACHED */
	}

	conffile = CONFFILE;

	memset(&lconf, 0, sizeof(lconf));

	while ((ch = getopt(argc, argv, "df:nP:sSv")) != -1) {
		switch (ch) {
		case 'd':
			lconf.debug = 2;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'n':
			lconf.debug = 2;
			lconf.noaction = 1;
			break;
		case 'P':
			pname = optarg;
			break;
		case 's':
			lconf.settime = 1;
			break;
		case 'S':
			lconf.settime = 0;
			break;
		case 'v':
			lconf.verbose++;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	/* log to stderr until daemonized */
	log_init(lconf.debug ? lconf.debug : 1, LOG_DAEMON);

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	if (parse_config(conffile, &lconf))
		exit(1);

	if (lconf.noaction) {
		fprintf(stderr, "configuration OK\n");
		exit(0);
	}

	if (geteuid())
		errx(1, "need root privileges");

	if ((pw = getpwnam(NTPD_USER)) == NULL)
		errx(1, "unknown user %s", NTPD_USER);

	if (pname != NULL) {
		/* Remove our proc arguments, so child doesn't need to. */
		if (sanitize_argv(&argc0, &argv0) == -1)
			fatalx("sanitize_argv");

		if (strcmp(NTP_PROC_NAME, pname) == 0)
			ntp_main(&lconf, pw, argc0, argv0);
		else if (strcmp(NTPDNS_PROC_NAME, pname) == 0)
			ntp_dns(&lconf, pw);
		else if (strcmp(CONSTRAINT_PROC_NAME, pname) == 0)
			priv_constraint_child(pw->pw_dir, pw->pw_uid,
			    pw->pw_gid);
		else
			fatalx("%s: invalid process name '%s'", __func__,
			    pname);

		fatalx("%s: process '%s' failed", __func__, pname);
	}

	if (setpriority(PRIO_PROCESS, 0, -20) == -1)
		warn("can't set priority");

	reset_adjtime();
	if (!lconf.settime) {
		log_init(lconf.debug, LOG_DAEMON);
		log_setverbose(lconf.verbose);
		if (!lconf.debug)
			if (daemon(1, 0))
				fatal("daemon");
	} else
		timeout = SETTIME_TIMEOUT * 1000;

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, PF_UNSPEC,
	    pipe_chld) == -1)
		fatal("socketpair");

	signal(SIGCHLD, sighdlr);

	/* fork child process */
	start_child(NTP_PROC_NAME, pipe_chld[1], argc0, argv0);

	log_procinit("[priv]");
	readfreq();

	signal(SIGTERM, sighdlr);
	signal(SIGINT, sighdlr);
	signal(SIGHUP, sighdlr);

	constraint_purge();

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		fatal(NULL);
	imsg_init(ibuf, pipe_chld[0]);

	constraint_cnt = 0;

	/*
	 * Constraint processes are forked with certificates in memory,
	 * then privdrop into chroot before speaking to the outside world.
	 */
	if (pledge("stdio rpath inet settime proc exec id", NULL) == -1)
		err(1, "pledge");

	while (quit == 0) {
		new_cnt = PFD_MAX + constraint_cnt;
		if (new_cnt > pfd_elms) {
			if ((newp = reallocarray(pfd, new_cnt,
			    sizeof(*pfd))) == NULL) {
				/* panic for now */
				log_warn("could not resize pfd from %u -> "
				    "%u entries", pfd_elms, new_cnt);
				fatalx("exiting");
			}
			pfd = newp;
			pfd_elms = new_cnt;
		}

		memset(pfd, 0, sizeof(*pfd) * pfd_elms);
		pfd[PFD_PIPE].fd = ibuf->fd;
		pfd[PFD_PIPE].events = POLLIN;
		if (ibuf->w.queued)
			pfd[PFD_PIPE].events |= POLLOUT;

		i = PFD_MAX;
		TAILQ_FOREACH(cstr, &conf->constraints, entry) {
			pfd[i].fd = cstr->fd;
			pfd[i].events = POLLIN;
			i++;
		}

		if ((nfds = poll(pfd, i, timeout)) == -1)
			if (errno != EINTR) {
				log_warn("poll error");
				quit = 1;
			}

		if (nfds == 0 && lconf.settime) {
			lconf.settime = 0;
			timeout = INFTIM;
			log_init(lconf.debug, LOG_DAEMON);
			log_setverbose(lconf.verbose);
			log_warnx("no reply received in time, skipping initial "
			    "time setting");
			if (!lconf.debug)
				if (daemon(1, 0))
					fatal("daemon");
		}

		if (nfds > 0 && (pfd[PFD_PIPE].revents & POLLOUT))
			if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN) {
				log_warn("pipe write error (to child)");
				quit = 1;
			}

		if (nfds > 0 && pfd[PFD_PIPE].revents & POLLIN) {
			nfds--;
			if (dispatch_imsg(&lconf, argc0, argv0) == -1)
				quit = 1;
		}

		for (j = PFD_MAX; nfds > 0 && j < i; j++) {
			nfds -= priv_constraint_dispatch(&pfd[j]);
		}

		if (sigchld) {
			check_child();
			sigchld = 0;
		}
	}

	signal(SIGCHLD, SIG_DFL);

	/* Close socket and start shutdown. */
	close(ibuf->fd);

	do {
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	msgbuf_clear(&ibuf->w);
	free(ibuf);
	log_info("Terminating");
	return (0);
}

void
check_child(void)
{
	int	 status;
	pid_t	 pid;

	do {
		pid = waitpid(WAIT_ANY, &status, WNOHANG);
		if (pid <= 0)
			continue;

		priv_constraint_check_child(pid, status);
	} while (pid > 0 || (pid == -1 && errno == EINTR));
}

int
dispatch_imsg(struct ntpd_conf *lconf, int argc, char **argv)
{
	struct imsg		 imsg;
	int			 n;
	double			 d;

	if (((n = imsg_read(ibuf)) == -1 && errno != EAGAIN) || n == 0)
		return (-1);

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			return (-1);

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_ADJTIME:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(d))
				fatalx("invalid IMSG_ADJTIME received");
			memcpy(&d, imsg.data, sizeof(d));
			n = ntpd_adjtime(d);
			imsg_compose(ibuf, IMSG_ADJTIME, 0, 0, -1,
			     &n, sizeof(n));
			break;
		case IMSG_ADJFREQ:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(d))
				fatalx("invalid IMSG_ADJFREQ received");
			memcpy(&d, imsg.data, sizeof(d));
			ntpd_adjfreq(d, 1);
			break;
		case IMSG_SETTIME:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(d))
				fatalx("invalid IMSG_SETTIME received");
			if (!lconf->settime)
				break;
			log_init(lconf->debug, LOG_DAEMON);
			log_setverbose(lconf->verbose);
			memcpy(&d, imsg.data, sizeof(d));
			ntpd_settime(d);
			/* daemonize now */
			if (!lconf->debug)
				if (daemon(1, 0))
					fatal("daemon");
			lconf->settime = 0;
			timeout = INFTIM;
			break;
		case IMSG_CONSTRAINT_QUERY:
			priv_constraint_msg(imsg.hdr.peerid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE,
			    argc, argv);
			break;
		case IMSG_CONSTRAINT_KILL:
			priv_constraint_kill(imsg.hdr.peerid);
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}
	return (0);
}

void
reset_adjtime(void)
{
	struct timeval	tv;

	timerclear(&tv);
	if (adjtime(&tv, NULL) == -1)
		log_warn("reset adjtime failed");
}

int
ntpd_adjtime(double d)
{
	struct timeval	tv, olddelta;
	int		synced = 0;
	static int	firstadj = 1;

	d += getoffset();
	if (d >= (double)LOG_NEGLIGIBLE_ADJTIME / 1000 ||
	    d <= -1 * (double)LOG_NEGLIGIBLE_ADJTIME / 1000)
		log_info("adjusting local clock by %fs", d);
	else
		log_debug("adjusting local clock by %fs", d);
	d_to_tv(d, &tv);
	if (adjtime(&tv, &olddelta) == -1)
		log_warn("adjtime failed");
	else if (!firstadj && olddelta.tv_sec == 0 && olddelta.tv_usec == 0)
		synced = 1;
	firstadj = 0;
	return (synced);
}

void
ntpd_adjfreq(double relfreq, int wrlog)
{
	int64_t curfreq;
	double ppmfreq;
	int r;

	if (adjfreq(NULL, &curfreq) == -1) {
		log_warn("adjfreq failed");
		return;
	}

	/*
	 * adjfreq's unit is ns/s shifted left 32; convert relfreq to
	 * that unit before adding. We log values in part per million.
	 */
	curfreq += relfreq * 1e9 * (1LL << 32);
	r = writefreq(curfreq / 1e9 / (1LL << 32));
	ppmfreq = relfreq * 1e6;
	if (wrlog) {
		if (ppmfreq >= LOG_NEGLIGIBLE_ADJFREQ ||
		    ppmfreq <= -LOG_NEGLIGIBLE_ADJFREQ)
			log_info("adjusting clock frequency by %f to %fppm%s",
			    ppmfreq, curfreq / 1e3 / (1LL << 32),
			    r ? "" : " (no drift file)");
		else
			log_debug("adjusting clock frequency by %f to %fppm%s",
			    ppmfreq, curfreq / 1e3 / (1LL << 32),
			    r ? "" : " (no drift file)");
	}

	if (adjfreq(&curfreq, NULL) == -1)
		log_warn("adjfreq failed");
}

void
ntpd_settime(double d)
{
	struct timeval	tv, curtime;
	char		buf[80];
	time_t		tval;

	if (gettimeofday(&curtime, NULL) == -1) {
		log_warn("gettimeofday");
		return;
	}
	d_to_tv(d, &tv);
	curtime.tv_usec += tv.tv_usec + 1000000;
	curtime.tv_sec += tv.tv_sec - 1 + (curtime.tv_usec / 1000000);
	curtime.tv_usec %= 1000000;

	if (settimeofday(&curtime, NULL) == -1) {
		log_warn("settimeofday");
		return;
	}
	tval = curtime.tv_sec;
	strftime(buf, sizeof(buf), "%a %b %e %H:%M:%S %Z %Y",
	    localtime(&tval));
	log_info("set local clock to %s (offset %fs)", buf, d);
}

static FILE *freqfp;

void
readfreq(void)
{
	int64_t current;
	int fd;
	double d;

	fd = open(DRIFTFILE, O_RDWR);
	if (fd == -1) {
		log_warnx("creating new %s", DRIFTFILE);
		current = 0;
		if (adjfreq(&current, NULL) == -1)
			log_warn("adjfreq reset failed");
		freqfp = fopen(DRIFTFILE, "w");
		return;
	}

	freqfp = fdopen(fd, "r+");

	/* if we're adjusting frequency already, don't override */
	if (adjfreq(NULL, &current) == -1)
		log_warn("adjfreq failed");
	else if (current == 0 && freqfp) {
		if (fscanf(freqfp, "%lf", &d) == 1) {
			d /= 1e6;	/* scale from ppm */
			ntpd_adjfreq(d, 0);
		} else
			log_warnx("%s is empty", DRIFTFILE);
	}
}

int
writefreq(double d)
{
	int r;
	static int warnonce = 1;

	if (freqfp == NULL)
		return 0;
	rewind(freqfp);
	r = fprintf(freqfp, "%.3f\n", d * 1e6);	/* scale to ppm */
	if (r < 0 || fflush(freqfp) != 0) {
		if (warnonce) {
			log_warnx("can't write %s", DRIFTFILE);
			warnonce = 0;
		}
		clearerr(freqfp);
		return 0;
	}
	ftruncate(fileno(freqfp), ftello(freqfp));
	fsync(fileno(freqfp));
	return 1;
}

void
ctl_main(int argc, char *argv[])
{
	struct sockaddr_un	 sa;
	struct imsg		 imsg;
	struct imsgbuf		*ibuf_ctl;
	int			 fd, n, done, ch, action;
	char			*sockname;

	sockname = CTLSOCKET;

	if (argc < 2) {
		usage();
		/* NOTREACHED */
	}

	while ((ch = getopt(argc, argv, "s:")) != -1) {
		switch (ch) {
		case 's':
			showopt = ctl_lookup_option(optarg, ctl_showopt_list);
			if (showopt == NULL) {
				warnx("Unknown show modifier '%s'", optarg);
				usage();
			}
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	action = -1;
	if (showopt != NULL) {
		switch (*showopt) {
		case 'p':
			action = CTL_SHOW_PEERS;
			break;
		case 's':
			action = CTL_SHOW_STATUS;
			break;
		case 'S':
			action = CTL_SHOW_SENSORS;
			break;
		case 'a':
			action = CTL_SHOW_ALL;
			break;
		}
	}
	if (action == -1)
		usage();
		/* NOTREACHED */

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "ntpctl: socket");

	memset(&sa, 0, sizeof(sa));
	sa.sun_family = AF_UNIX;
	if (strlcpy(sa.sun_path, sockname, sizeof(sa.sun_path)) >=
	    sizeof(sa.sun_path))
		errx(1, "ctl socket name too long");
	if (connect(fd, (struct sockaddr *)&sa, sizeof(sa)) == -1)
		err(1, "connect: %s", sockname);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if ((ibuf_ctl = malloc(sizeof(struct imsgbuf))) == NULL)
		err(1, NULL);
	imsg_init(ibuf_ctl, fd);

	switch (action) {
	case CTL_SHOW_STATUS:
		imsg_compose(ibuf_ctl, IMSG_CTL_SHOW_STATUS,
		    0, 0, -1, NULL, 0);
		break;
	case CTL_SHOW_PEERS:
		imsg_compose(ibuf_ctl, IMSG_CTL_SHOW_PEERS,
		    0, 0, -1, NULL, 0);
		break;
	case CTL_SHOW_SENSORS:
		imsg_compose(ibuf_ctl, IMSG_CTL_SHOW_SENSORS,
		    0, 0, -1, NULL, 0);
		break;
	case CTL_SHOW_ALL:
		imsg_compose(ibuf_ctl, IMSG_CTL_SHOW_ALL,
		    0, 0, -1, NULL, 0);
		break;
	default:
		errx(1, "invalid action");
		break; /* NOTREACHED */
	}

	while (ibuf_ctl->w.queued)
		if (msgbuf_write(&ibuf_ctl->w) <= 0 && errno != EAGAIN)
			err(1, "ibuf_ctl: msgbuf_write error");

	done = 0;
	while (!done) {
		if ((n = imsg_read(ibuf_ctl)) == -1 && errno != EAGAIN)
			err(1, "ibuf_ctl: imsg_read error");
		if (n == 0)
			errx(1, "ntpctl: pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf_ctl, &imsg)) == -1)
				err(1, "ibuf_ctl: imsg_get error");
			if (n == 0)
				break;

			switch (action) {
			case CTL_SHOW_STATUS:
				show_status_msg(&imsg);
				done = 1;
				break;
			case CTL_SHOW_PEERS:
				show_peer_msg(&imsg, 0);
				if (imsg.hdr.type ==
				    IMSG_CTL_SHOW_PEERS_END)
					done = 1;
				break;
			case CTL_SHOW_SENSORS:
				show_sensor_msg(&imsg, 0);
				if (imsg.hdr.type ==
				    IMSG_CTL_SHOW_SENSORS_END)
					done = 1;
				break;
			case CTL_SHOW_ALL:
				switch (imsg.hdr.type) {
				case IMSG_CTL_SHOW_STATUS:
					show_status_msg(&imsg);
					break;
				case IMSG_CTL_SHOW_PEERS:
					show_peer_msg(&imsg, 1);
					break;
				case IMSG_CTL_SHOW_SENSORS:
					show_sensor_msg(&imsg, 1);
					break;
				case IMSG_CTL_SHOW_PEERS_END:
				case IMSG_CTL_SHOW_SENSORS_END:
					/* do nothing */
					break;
				case IMSG_CTL_SHOW_ALL_END:
					done=1;
					break;
				default:
					/* no action taken */
					break;
				}
			default:
				/* no action taken */
				break;
			}
			imsg_free(&imsg);
		}
	}
	close(fd);
	free(ibuf_ctl);
	exit(0);
}

const char *
ctl_lookup_option(char *cmd, const char **list)
{
	const char *item = NULL;
	if (cmd != NULL && *cmd)
		for (; *list; list++)
			if (!strncmp(cmd, *list, strlen(cmd))) {
				if (item == NULL)
					item = *list;
				else
					errx(1, "%s is ambiguous", cmd);
			}
	return (item);
}

void
show_status_msg(struct imsg *imsg)
{
	struct ctl_show_status	*cstatus;
	double			 clock_offset;
	struct timeval		 tv;

	if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(struct ctl_show_status))
		fatalx("invalid IMSG_CTL_SHOW_STATUS received");

	cstatus = (struct ctl_show_status *)imsg->data;

	if (cstatus->peercnt > 0)
		printf("%d/%d peers valid, ",
		    cstatus->valid_peers, cstatus->peercnt);

	if (cstatus->sensorcnt > 0)
		printf("%d/%d sensors valid, ",
		    cstatus->valid_sensors, cstatus->sensorcnt);

	if (cstatus->constraint_median) {
		tv.tv_sec = cstatus->constraint_median +
		    (getmonotime() - cstatus->constraint_last);
		tv.tv_usec = 0;
		d_to_tv(gettime_from_timeval(&tv) - gettime(), &tv);
		printf("constraint offset %llds", (long long)tv.tv_sec);
		if (cstatus->constraint_errors)
			printf(" (%d errors)",
			    cstatus->constraint_errors);
		printf(", ");
	}

	if (cstatus->peercnt + cstatus->sensorcnt == 0)
		printf("no peers and no sensors configured\n");

	if (cstatus->synced == 1)
		printf("clock synced, stratum %u\n", cstatus->stratum);
	else {
		printf("clock unsynced");
		clock_offset = cstatus->clock_offset < 0 ?
		    -1.0 * cstatus->clock_offset : cstatus->clock_offset;
		if (clock_offset > 5e-7)
			printf(", clock offset is %.3fms\n",
			    cstatus->clock_offset);
		else
			printf("\n");
	}
}

void
show_peer_msg(struct imsg *imsg, int calledfromshowall)
{
	struct ctl_show_peer	*cpeer;
	int			 cnt;
	char			 stratum[3];
	static int		 firsttime = 1;

	if (imsg->hdr.type == IMSG_CTL_SHOW_PEERS_END) {
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(cnt))
			fatalx("invalid IMSG_CTL_SHOW_PEERS_END received");
		memcpy(&cnt, imsg->data, sizeof(cnt));
		if (cnt == 0)
			printf("no peers configured\n");
		return;
	}

	if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(struct ctl_show_peer))
		fatalx("invalid IMSG_CTL_SHOW_PEERS received");

	cpeer = (struct ctl_show_peer *)imsg->data;

	if (strlen(cpeer->peer_desc) > MAX_DISPLAY_WIDTH - 1)
		fatalx("peer_desc is too long");

	if (firsttime) {
		firsttime = 0;
		if (calledfromshowall)
			printf("\n");
		printf("peer\n   wt tl st  next  poll          "
		    "offset       delay      jitter\n");
	}

	if (cpeer->stratum > 0)
		snprintf(stratum, sizeof(stratum), "%2u", cpeer->stratum);
	else
		strlcpy(stratum, " -", sizeof (stratum));

	printf("%s\n %1s %2u %2u %2s %4llds %4llds",
	    cpeer->peer_desc, cpeer->syncedto == 1 ? "*" : " ",
	    cpeer->weight, cpeer->trustlevel, stratum,
	    (long long)cpeer->next, (long long)cpeer->poll);

	if (cpeer->trustlevel >= TRUSTLEVEL_BADPEER)
		printf("  %12.3fms %9.3fms  %8.3fms\n", cpeer->offset,
		    cpeer->delay, cpeer->jitter);
	else
		printf("             ---- peer not valid ----\n");

}

void
show_sensor_msg(struct imsg *imsg, int calledfromshowall)
{
	struct ctl_show_sensor	*csensor;
	int			 cnt;
	static int		 firsttime = 1;

	if (imsg->hdr.type == IMSG_CTL_SHOW_SENSORS_END) {
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(cnt))
			fatalx("invalid IMSG_CTL_SHOW_SENSORS_END received");
		memcpy(&cnt, imsg->data, sizeof(cnt));
		if (cnt == 0)
			printf("no sensors configured\n");
		return;
	}

	if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(struct ctl_show_sensor))
		fatalx("invalid IMSG_CTL_SHOW_SENSORS received");

	csensor = (struct ctl_show_sensor *)imsg->data;

	if (strlen(csensor->sensor_desc) > MAX_DISPLAY_WIDTH - 1)
		fatalx("sensor_desc is too long");

	if (firsttime) {
		firsttime = 0;
		if (calledfromshowall)
			printf("\n");
		printf("sensor\n   wt gd st  next  poll          "
		    "offset  correction\n");
	}

	printf("%s\n %1s %2u %2u %2u %4llds %4llds",
	    csensor->sensor_desc, csensor->syncedto == 1 ? "*" : " ",
	    csensor->weight, csensor->good, csensor->stratum,
	    (long long)csensor->next, (long long)csensor->poll);

	if (csensor->good == 1)
		printf("   %11.3fms %9.3fms\n",
		    csensor->offset, csensor->correction);
	else
		printf("         - sensor not valid -\n");

}
@


1.112
log
@Remove unused variable which was leaking memory, and while here remove 2 other
variables that were also never used

OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.111 2016/09/26 17:17:01 rzalamena Exp $ */
d212 1
a212 1
		log_verbose(lconf.verbose);
d287 1
a287 1
			log_verbose(lconf.verbose);
d387 1
a387 1
			log_verbose(lconf->verbose);
@


1.111
log
@Teach ntpd(8) constraint process to use exec*() instead of just forking,
with this change we get the pledge() ability back to the parent process.

some tweaks from and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.110 2016/09/26 16:55:02 rzalamena Exp $ */
a120 3
	const char		*pw_dir;
	uid_t			pw_uid;
	gid_t			pw_gid;
a204 4

	pw_dir = strdup(pw->pw_dir);
	pw_uid = pw->pw_uid;
	pw_gid = pw->pw_gid;
@


1.110
log
@Teach ntpd(8) how to use socket status to shutdown the daemon. While at
it, remove some verbose shutdown messages that we had before with pipe
close.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.109 2016/09/14 13:20:16 rzalamena Exp $ */
d45 1
a45 1
int		dispatch_imsg(struct ntpd_conf *, const char *, uid_t, gid_t);
d199 3
d254 1
a254 2
#if 0	
	if (pledge("stdio rpath inet settime proc id", NULL) == -1)
a255 1
#endif
d310 1
a310 1
			if (dispatch_imsg(&lconf, pw_dir, pw_uid, pw_gid) == -1)
d357 1
a357 2
dispatch_imsg(struct ntpd_conf *lconf, const char *pw_dir,
    uid_t pw_uid, gid_t pw_gid)
d407 1
a407 1
			    pw_dir, pw_uid, pw_gid);
@


1.109
log
@Teach ntpd(8) how to fork+exec.

ok reyk@@, bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.108 2016/09/03 11:52:06 reyk Exp $ */
d44 1
a44 1
int		check_child(pid_t, const char *);
d113 1
a113 1
	pid_t			 chld_pid = 0, pid;
d230 1
a230 1
	chld_pid = start_child(NTP_PROC_NAME, pipe_chld[1], argc0, argv0);
d318 1
a318 4
			if (check_child(chld_pid, "child")) {
				quit = 1;
				chld_pid = 0;
			}
a320 1

d325 2
a326 2
	if (chld_pid)
		kill(chld_pid, SIGTERM);
d340 2
a341 2
int
check_child(pid_t chld_pid, const char *pname)
d343 1
a343 2
	int	 status, sig;
	char	*signame;
d348 1
a348 1
		if (pid <= 0) {
d350 2
a351 16
		} else if (pid == chld_pid) {
			if (WIFEXITED(status)) {
				log_warnx("Lost child: %s exited", pname);
				return (1);
			}
			if (WIFSIGNALED(status)) {
				sig = WTERMSIG(status);
				signame = strsignal(sig) ?
				    strsignal(sig) : "unknown";
				log_warnx("Lost child: %s terminated; "
				    "signal %d (%s)", pname, sig, signame);
				return (1);
			}
		} else {
			priv_constraint_check_child(pid, status);
		}
a352 2

	return (0);
d363 1
a363 1
	if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
a364 5

	if (n == 0) {	/* connection closed */
		log_warnx("dispatch_imsg in main: pipe closed");
		return (-1);
	}
@


1.108
log
@Remove the oh so funny "LOSS OF MIND" from the diclaimer that was not
part of the original ISC license that we use in OpenBSD.  Done for
files were Henning is the original author.

OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.107 2016/05/02 06:25:29 semarie Exp $ */
d115 1
a115 1
	int			 fd_ctl, ch, nfds, i, j;
d125 3
d138 1
a138 1
	while ((ch = getopt(argc, argv, "df:nsSv")) != -1) {
d150 3
d190 16
d223 2
a224 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_chld) == -1)
d227 1
a227 4
	if ((fd_ctl = control_init(CTLSOCKET)) == -1)
		fatalx("control socket init failed");
	if (control_listen(fd_ctl) == -1)
		fatalx("control socket listen failed");
a228 1
	signal(SIGCHLD, sighdlr);
d230 1
a230 1
	chld_pid = ntp_main(pipe_chld, fd_ctl, &lconf, pw);
a238 1
	close(pipe_chld[1]);
@


1.107
log
@prepare userland for removing chroot(2) from allowed syscalls under pledge(2).

for ntpd(8), removing the pledge call is a first step: futher redesign will occurs later.

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.106 2016/02/02 17:51:11 sthen Exp $ */
d15 3
a17 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.106
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.105 2016/01/27 21:48:34 reyk Exp $ */
d233 1
d236 1
@


1.105
log
@Don't attempt to kill() the constraint in the wrong process.  The
process management of the contraint processes has been moved from ntp
to the parent, for better privsep and pledge, but the ntp process
still attempted to kill the constraints on timeout directly.  Fix this
regression by introducing a new imsg from ntp to the parent and the
related logic to kill a constraint at the right place.

Reported & tested by bcook@@
Ok bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.104 2016/01/27 21:36:25 bcook Exp $ */
a212 1
	setproctitle("[priv]");
@


1.104
log
@update ntpd log initialization to work like relayd, fix debug log levels

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.103 2016/01/11 15:30:56 deraadt Exp $ */
d415 3
@


1.103
log
@sneaky whitespace snuck in again
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.102 2015/12/29 18:23:28 millert Exp $ */
a134 2
	log_init(1, LOG_DAEMON);	/* log to stderr until daemonized */

d138 1
a138 2
			lconf.debug = 1;
			log_verbose(1);
d144 1
d154 1
a154 1
			log_verbose(1);
d162 3
d194 1
d274 1
d401 1
@


1.102
log
@Don't assume fprintf() will set the FILE * error condition.
Instead, check the return value of fprintf() and fflush()
and call clearerr() before returning on error.  OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.101 2015/12/19 17:55:29 reyk Exp $ */
d531 1
a531 1
	
@


1.101
log
@Switch and sync to the log.c variant from httpd/relayd/iked/snmpd/vmd.

OK bcook@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.100 2015/12/05 13:12:16 claudio Exp $ */
d555 2
a556 3
	fprintf(freqfp, "%.3f\n", d * 1e6);	/* scale to ppm */
	r = ferror(freqfp);
	if (r != 0) {
d561 1
@


1.100
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.99 2015/11/24 01:03:25 deraadt Exp $ */
d33 1
d135 1
a135 1
	log_init(1);		/* log to stderr until daemonized */
d192 1
a192 1
		log_init(lconf.debug);
d212 1
d271 1
a271 1
			log_init(lconf.debug);
d397 1
a397 1
			log_init(lconf->debug);
@


1.99
log
@Cache values from getpwnam() done at initialization, which need to be
used by the constraint processes setup later (chroot, setuid...)
[late getpwnam discovered during a further audit]
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.98 2015/10/23 16:39:13 deraadt Exp $ */
d360 1
a360 1
	if ((n = imsg_read(ibuf)) == -1)
d665 1
a665 1
		if ((n = imsg_read(ibuf_ctl)) == -1)
@


1.98
log
@Rather than re-opening the driftfile to write, keep it open; rewinding
and coping with error conditions... that lets us avoid a pledge "wpath".

Putting it all together, this lets the master ntpd pledge "stdio rpath
inet settime proc id".  It works like this: "rpath" to load the
certificates, "proc" to create constraint processes, "id" to chroot
and lock the constraint processes into a jail, then "inet" to open a
https session.  "settime" is used by the master to manage the system
time when the ntp-speaking engine instructs the master.

with help from naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.97 2015/10/12 06:50:08 reyk Exp $ */
d44 1
a44 1
int		dispatch_imsg(struct ntpd_conf *);
a115 1
	struct passwd		*pw;
d119 4
d182 4
d285 1
a285 1
			if (dispatch_imsg(&lconf) == -1)
d353 2
a354 1
dispatch_imsg(struct ntpd_conf *lconf)
d407 2
a408 1
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
@


1.97
log
@Move execution of the constraints from the ntp to the parent process.
This helps the ntp process to a) give a better pledge(2) and to b)
keep the promise of "saving the world again... on time" by removing
the delays that have been introduced by expensive constraint forks.
The new design offers better privsep but introduces a few more imsgs
and runs a little bit more code in the privileged parent.  The
privileged code is minimal, carefully checked, and does not attempt to
"parse" any contents; the forked constraints instantly drop all
privileges and pledge to "stdio inet".

OK beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.96 2015/10/09 01:37:09 deraadt Exp $ */
d35 1
d219 7
d502 2
a506 1
	FILE *fp;
d508 1
d511 3
a513 3
	fp = fopen(DRIFTFILE, "r");
	if (fp == NULL) {
		/* if the drift file has been deleted by the user, reset */
d517 1
d520 2
d526 2
a527 2
	else if (current == 0) {
		if (fscanf(fp, "%lf", &d) == 1) {
d531 1
a531 1
			log_warnx("can't read %s", DRIFTFILE);
a532 1
	fclose(fp);
a538 1
	FILE *fp;
d541 1
a541 6
	fp = fopen(DRIFTFILE, "w");
	if (fp == NULL) {
		if (warnonce) {
			log_warn("can't open %s", DRIFTFILE);
			warnonce = 0;
		}
d543 4
a546 5
	}

	fprintf(fp, "%.3f\n", d * 1e6);		/* scale to ppm */
	r = ferror(fp);
	if (fclose(fp) != 0 || r != 0) {
a550 1
		unlink(DRIFTFILE);
d553 2
@


1.96
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.95 2015/10/03 02:47:15 deraadt Exp $ */
d63 2
d104 1
d110 1
a110 1
	struct pollfd		 pfd[POLL_MAX];
d113 1
a113 1
	int			 fd_ctl, ch, nfds;
d117 3
d210 1
d216 2
d219 14
d238 8
a245 1
		if ((nfds = poll(pfd, 1, timeout)) == -1)
d274 4
d306 1
a306 1
check_child(pid_t pid, const char *pname)
d310 1
d312 19
a330 4
	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("Lost child: %s exited", pname);
			return (1);
d332 1
a332 8
		if (WIFSIGNALED(status)) {
			sig = WTERMSIG(status);
			signame = strsignal(sig) ? strsignal(sig) : "unknown";
			log_warnx("Lost child: %s terminated; signal %d (%s)",
			    pname, sig, signame);
			return (1);
		}
	}
d388 4
@


1.95
log
@In the ntpctl(1) case, after it has connect()'d to ntpd we can tame "stdio"
since that is all it will do till termination.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.94 2015/07/18 00:53:44 bcook Exp $ */
d568 2
a569 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.94
log
@replace bzero with memset

ok phessler@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.93 2015/03/11 19:38:48 jmc Exp $ */
d567 3
@


1.93
log
@-s is not optional, sadly;
while here i've reformatted the page to stop kidding that -s is 4 options;

original issue kind of spotted by adam thompson, though note i am not fixing the
issue he complained about (i'll address that mail in a minute);
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.92 2015/02/11 03:16:57 reyk Exp $ */
d122 1
a122 1
	bzero(&lconf, sizeof(lconf));
d560 1
a560 1
	bzero(&sa, sizeof(sa));
@


1.92
log
@Remove dead code (IMSG_HOST_DNS has been moved from the parent to
ntp_dns some years ago).

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.91 2015/02/10 11:46:39 reyk Exp $ */
d93 1
a93 1
		    "usage: ntpctl [-s all | peers | Sensors | status]\n");
@


1.91
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.90 2015/02/10 11:16:47 reyk Exp $ */
d298 1
a298 1
	int			 n, cnt;
a299 3
	char			*name;
	struct ntp_addr		*h, *hn;
	struct ibuf		*buf;
a344 28
			break;
		case IMSG_HOST_DNS:
			name = imsg.data;
			if (imsg.hdr.len < 1 + IMSG_HEADER_SIZE)
				fatalx("invalid IMSG_HOST_DNS received");
			imsg.hdr.len -= 1 + IMSG_HEADER_SIZE;
			if (name[imsg.hdr.len] != '\0' ||
			    strlen(name) != imsg.hdr.len)
				fatalx("invalid IMSG_HOST_DNS received");
			if ((cnt = host_dns(name, &hn)) == -1)
				break;
			buf = imsg_create(ibuf, IMSG_HOST_DNS,
			    imsg.hdr.peerid, 0,
			    cnt * sizeof(struct sockaddr_storage));
			if (cnt > 0) {
				if (buf) {
					for (h = hn; h != NULL; h = h->next)
						if (imsg_add(buf, &h->ss,
						    sizeof(h->ss)) == -1) {
							buf = NULL;
							break;
						}
				}
				host_dns_free(hn);
				hn = NULL;
			}
			if (buf)
				imsg_close(ibuf, buf);
@


1.90
log
@Don't show the subseconds when displaying the constraint offset.

OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.89 2015/02/10 06:40:08 reyk Exp $ */
d92 2
a93 1
		fprintf(stderr, "usage: ntpctl [-s all | peers | Sensors | status]\n");
d116 1
a116 1
		ctl_main (argc, argv);
d584 1
a584 1
	if (action == -1) 
d690 1
a690 1
	exit (0);
d730 1
a730 1
                    (getmonotime() - cstatus->constraint_last);
d793 1
a793 1
		strlcpy (stratum, " -", sizeof (stratum));
@


1.89
log
@Add support for "constraints": when configured, ntpd(8) will query the
time from HTTPS servers, by parsing the Date: header, and use the
median constraint time as a boundary to verify NTP responses.  This
adds some level of authentication and protection against MITM attacks
while preserving the accuracy of the NTP protocol; without relying on
authentication options for NTP that are basically unavailable at
present.  This is an initial implementation and the semantics will be
improved once it is in the tree.

Discussed with deraadt@@ and henning@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.88 2015/01/21 03:14:10 bcook Exp $ */
d731 2
a732 2
		printf("constraint offset %f",
		    gettime_from_timeval(&tv) - gettime());
@


1.88
log
@Fix deferred host DNS lookups.

If the network is unreachable when ntpd starts and host_dns fails, be sure
that we still close the HOST_DNS imsg.

Thanks to Paul de Weerd <weerd at weirdnet dot nl> for reporting this.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.87 2015/01/19 20:47:03 bcook Exp $ */
d712 1
d726 12
@


1.87
log
@Use initial assignment of action to check for errors.

This simplifies things and make action = -1 no longer a dead store.

Also, spell FALLTHROUGH consistently.

reported by fritjof@@alokat.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.86 2015/01/14 21:14:27 naddy Exp $ */
a368 2
					if (buf)
						imsg_close(ibuf, buf);
d373 2
@


1.86
log
@Switch drift file format to ppm for compatibility with the ntp.org
daemon.

Old drift files will be interpreted as a minuscule adjustment and
ntpd will proceed to rediscover the drift, like starting from zero
on a newly installed machine.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.85 2015/01/13 14:52:47 bcook Exp $ */
a580 3
		default:
			usage();
			/* NOTREACHED */
d582 2
a583 1
	} else
d585 1
@


1.85
log
@bump failure to set the initial time from debug to warning

from Paul B. Henson, ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.84 2015/01/13 02:28:56 bcook Exp $ */
d497 2
a498 1
		if (fscanf(fp, "%le", &d) == 1)
d500 1
a500 1
		else
d522 1
a522 1
	fprintf(fp, "%e\n", d);
@


1.84
log
@fix some memory leaks in dns handling.

 - Nothing seems to free the result of host_dns(), so add host_dns_free() and
   call after each query.
 - If imsg_add() fails, it frees buf. Avoid subsequently dereferencing the
   freed buf in imsg_close().

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.83 2015/01/09 07:35:37 deraadt Exp $ */
d224 1
a224 1
			log_debug("no reply received in time, skipping initial "
@


1.83
log
@remove excessive/wrong use of sys/param.h
peanuts -- but all work has to start somewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.82 2015/01/08 00:30:08 bcook Exp $ */
d361 14
a374 7
			if (buf == NULL)
				break;
			if (cnt > 0)
				for (h = hn; h != NULL; h = h->next)
					imsg_add(buf, &h->ss, sizeof(h->ss));

			imsg_close(ibuf, buf);
@


1.82
log
@sync log.c from smtpd.

Reduces the number of log.c snowflakes by a little, and gives ntpd a
variadic fatal() function to be used later.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.81 2015/01/04 01:24:43 bcook Exp $ */
d112 1
a112 1
	extern char 		*__progname;
@


1.81
log
@rename sockaddr_un variables from 'sun' to the more common 'sa'.

This avoids a namespace conflict with Solaris build environments.

discussed with deraadt@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.80 2015/01/04 01:11:24 bcook Exp $ */
a60 1
int			 debugsyslog = 0;
d129 1
d144 1
a144 1
			debugsyslog = 1;
@


1.80
log
@Add a missing include for time.h to get the definitions of clock_gettime and strftime.

ok jsing@@ phessler@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.79 2014/02/10 09:12:34 dtucker Exp $ */
d530 1
a530 1
	struct sockaddr_un	 sun;
d583 4
a586 4
	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, sockname, sizeof(sun.sun_path)) >=
	    sizeof(sun.sun_path))
d588 1
a588 1
	if (connect(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1)
@


1.79
log
@Run the serving and privileged ntpd processes at high priority and the
dns process at normal priority.  Should improve latency on loaded machines.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.78 2014/01/28 22:57:37 sthen Exp $ */
d33 1
@


1.78
log
@typo in errx() string
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.77 2014/01/22 02:55:15 benno Exp $ */
d21 1
d169 3
@


1.77
log
@allow -s<abrev> in addition to -s <word> in ntpctl commandline, like
all the other tools do. changes option 'sensors' to 'Sensors'.
ok henning@@, and grudgingly phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.76 2014/01/10 22:54:12 deraadt Exp $ */
d690 1
a690 1
					errx(1, "%s is ambigious", cmd);
@


1.76
log
@improve ntpctl usage so that the manual page does not need to be read
every time
ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.75 2013/11/13 20:44:39 benno Exp $ */
d50 1
d62 6
d91 1
a91 1
		fprintf(stderr, "usage: ntpctl [-s all | peers | sensors | status]\n");
d528 2
a529 3
	int			 fd, n, done, ch;
	int			 do_what, action;
	char			*sockname, *show_what;
a537 1
	do_what = -1;
d541 5
a545 1
			do_what = CTL_SHOW;
d554 3
a556 3
	if (do_what == CTL_SHOW) {
		show_what = argv[argc - 1];
		if (strcmp(show_what, "peers") == 0)
d558 5
a562 1
		else if (strcmp(show_what, "sensors") == 0)
d564 2
a565 3
		else if (strcmp(show_what, "status") == 0)
			action = CTL_SHOW_STATUS;
		else if (strcmp(show_what, "all") == 0)
d567 2
a568 1
		else {
d678 15
@


1.75
log
@from sthen: handle msgbuf_write() returning EAGAIN

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.74 2013/10/16 21:23:59 jmc Exp $ */
d84 1
a84 1
		fprintf(stderr, "usage: ntpctl [-s modifier]\n");
@


1.74
log
@tidy up the "modifier" list a little and sync usage();

NB: this utility has only one option, and it's not optional! i haven;t
marked -s as being mandatory, since hopefully someone will make
ntpctl run without arguments do something useful;
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.73 2013/10/11 19:33:20 deraadt Exp $ */
d220 1
a220 1
			if (msgbuf_write(&ibuf->w) < 0) {
d600 1
a600 1
		if (msgbuf_write(&ibuf_ctl->w) < 0)
@


1.73
log
@improve ntpctl argv parsing
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.72 2013/10/09 12:34:12 deraadt Exp $ */
d84 1
a84 1
		fprintf(stderr, "usage: ntpctl [-s all|peers|sensors|status]\n");
@


1.72
log
@shorten output; ok henning phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.71 2013/10/04 20:30:38 schwarze Exp $ */
d84 1
a84 1
		fprintf(stderr, "usage: ntpctl [-s modifier]\n");
d559 2
a560 3
	}
	else
		errx (1, "invalid do_what");
@


1.71
log
@Tweak previous:
* For time_t values, use the printf("%lld", (long long)t) idiom.
* Don't print "Invalid program name" in usage() when main() just runs ntpd.
* Make "Show/Shows" consistent in the manual, sort .Xr and correct .Ox.
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.70 2013/10/04 14:28:16 phessler Exp $ */
d680 1
a680 1
		printf("%d of %d peers valid\n",
d684 1
a684 1
		printf("%d of %d sensors valid\n",
d691 1
a691 1
		printf("clock is synced, stratum %u\n", cstatus->stratum);
d693 1
a693 1
		printf("clock is unsynced");
@


1.70
log
@Add ntpctl(8), which allows us to query the locally running ntpd(8) process

diff from Mike Miller <mmiller mgm51 com> (many thanks!)

OK phessler@@, henning@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.69 2011/03/19 23:40:11 okan Exp $ */
d83 3
a85 1
	if (strcmp(__progname, "ntpd") == 0)
a87 4
	else if (strcmp(__progname, "ntpctl") == 0)
		fprintf(stderr, "usage: %s [-s modifier]\n", __progname);
	else
		fprintf(stderr, "Invalid program name: %s\n", __progname);
d742 1
a742 1
	printf("%s\n %1s %2u %2u %2s %4ds %4ds",
d744 2
a745 2
	    cpeer->weight, cpeer->trustlevel, stratum, cpeer->next,
	    cpeer->poll);
d787 4
a790 3
	printf("%s\n %1s %2u %2u %2u %4ds %4ds", csensor->sensor_desc,
	    csensor->syncedto == 1 ? "*" : " ", csensor->weight, csensor->good,
	    csensor->stratum, csensor->next, csensor->poll);
@


1.69
log
@use timerclear macro

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.68 2010/07/01 22:16:20 eric Exp $ */
d5 1
d23 1
d42 1
d49 4
d83 7
a89 1
	fprintf(stderr, "usage: %s [-dnSsv] [-f file]\n", __progname);
d103 1
a103 1
	int			 ch, nfds;
d106 6
d176 5
d183 1
a183 1
	chld_pid = ntp_main(pipe_chld, &lconf, pw);
d515 284
@


1.68
log
@don't need to setup the resolver early now that dns lookups are done
by the dns engine.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.67 2010/05/26 13:56:08 nicm Exp $ */
d348 1
a348 2
	tv.tv_sec = 0;
	tv.tv_usec = 0;
@


1.67
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.66 2009/06/06 18:14:25 pyr Exp $ */
a25 1
#include <resolv.h>
a98 1
	res_init();		/* XXX */
@


1.66
log
@make ntpd imsg-in-a-lib ready as well. extensive testing done, no
behavior change.
ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.65 2009/06/01 23:21:09 henning Exp $ */
d269 1
a269 1
	struct buf		*buf;
@


1.65
log
@no we don't need endpwent
i remember we already had the confusion and bgpd doesn't have the endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.64 2009/02/10 16:52:09 stevesk Exp $ */
d292 2
a293 1
			imsg_compose(ibuf, IMSG_ADJTIME, 0, 0, &n, sizeof(n));
@


1.64
log
@log tiny frequency adjustments at debug only.
ok henning@@, 'I think I agree' otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.63 2009/02/06 21:48:00 stevesk Exp $ */
a145 2

	endpwent();
@


1.63
log
@rename a #define to be clearer; no binary change
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.62 2009/01/29 00:06:04 stevesk Exp $ */
d383 1
d397 12
a408 4
	if (wrlog)
		log_info("adjusting clock frequency by %f to %fppm%s",
		    relfreq * 1e6, curfreq / 1e3 / (1LL << 32),
		    r ? "" : " (no drift file)");
@


1.62
log
@log warning when can't read drift file; allows detection of
corrupt contents. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.61 2008/07/19 21:31:39 claudio Exp $ */
d365 2
a366 2
	if (d >= (double)LOG_NEGLIGEE / 1000 ||
	    d <= -1 * (double)LOG_NEGLIGEE / 1000)
@


1.61
log
@Use errx instead of fprintf, exit combo.
Diff from Gleydson Soares gsoares (at) gmail (dot) com
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.60 2008/05/16 06:13:25 ckuethe Exp $ */
d453 2
@


1.60
log
@Allow ntpd to step the time at startup, now matter how large or small the
offset. The 180s limit doesn't help very much these days.
ok otto@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.59 2008/05/14 09:32:18 pyr Exp $ */
d32 1
d141 5
a145 4
	if (geteuid()) {
		fprintf(stderr, "ntpd: need root privileges\n");
		exit(1);
	}
a146 4
	if ((pw = getpwnam(NTPD_USER)) == NULL) {
		fprintf(stderr, "ntpd: unknown user %s\n", NTPD_USER);
		exit(1);
	}
@


1.59
log
@ntpd missed the argument check sweep.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.58 2007/12/31 17:21:35 henning Exp $ */
a412 4

	/* if the offset is small, don't call settimeofday */
	if (d < SETTIME_MIN_OFFSET && d > -SETTIME_MIN_OFFSET)
		return;
@


1.58
log
@we must reset the poll timeout to INFTIM when receiving the IMSG_SETTIME
because otherwise the poll timeout will stay at SETTIME_TIMEOUT (15s)
forever unless we time out waiting for the first reply with -s
spotted by Aaron Riekenberg <aaron.riekenberg@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.57 2007/12/23 22:40:00 stevesk Exp $ */
d126 5
@


1.57
log
@log a warning one time when we can't open or write the drift file;
also add "(no drift file)" to the adjfreq log message on failure;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.56 2007/12/22 18:26:21 stevesk Exp $ */
d52 1
d90 1
a90 1
	int			 ch, nfds, timeout = INFTIM;
d312 1
@


1.56
log
@just call getpwnam(NTPD_USER) once; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.55 2007/12/04 14:52:54 fgsch Exp $ */
d45 1
a45 1
void		writefreq(double);
d378 1
d390 1
d392 3
a394 2
		log_info("adjusting clock frequency by %f to %fppm",
		    relfreq * 1e6, curfreq / 1e3 / (1LL << 32));
a397 1
	writefreq(curfreq / 1e9 / (1LL << 32));
d456 1
a456 1
void
d461 1
d464 7
a470 2
	if (fp == NULL)
		return;
d474 5
a478 1
	if (fclose(fp) != 0 || r != 0)
d480 3
@


1.55
log
@revert SIGQUIT catching; requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.53 2007/11/22 10:22:30 otto Exp $ */
d91 1
d139 1
a139 1
	if (getpwnam(NTPD_USER) == NULL) {
d159 1
a159 1
	chld_pid = ntp_main(pipe_chld, &lconf);
@


1.54
log
@catch SIGQUIT too. ckuethe@@ and henning@@ ok.
@
text
@a58 1
	case SIGQUIT:
a164 1
	signal(SIGQUIT, sighdlr);
@


1.53
log
@if the drift file is missing, reset adjfreq to zero; iirc diff from Glaser
from a long time ago. ok ckuethe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.52 2007/09/13 20:34:12 jmc Exp $ */
d59 1
d166 1
@


1.52
log
@add -n to usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.51 2007/09/13 14:34:36 pyr Exp $ */
d434 9
d444 1
a444 1
	if (adjfreq(NULL, &current) == -1) {
d446 3
a448 1
		return;
a449 9
	if (current != 0)
		return;

	fp = fopen(DRIFTFILE, "r");
	if (fp == NULL)
		return;

	if (fscanf(fp, "%le", &d) == 1)
		ntpd_adjfreq(d, 0);
@


1.51
log
@Provide the -n switch like in the other imsg daemons for testing
the configuration file.
"yes please, ok" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.50 2007/08/22 21:04:30 ckuethe Exp $ */
d75 1
a75 1
	fprintf(stderr, "usage: %s [-dSsv] [-f file]\n", __progname);
@


1.50
log
@Allow ntpd to log sensor offsets and adjtime calls to syslog at LOG_DEBUG
priority.
ok gwk, mbalmer, weingart
"explicit non-ok from" henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.49 2007/01/15 08:19:11 otto Exp $ */
d99 1
a99 1
	while ((ch = getopt(argc, argv, "df:sSv")) != -1) {
d107 3
d127 5
@


1.49
log
@Although Unix compilers accept more than one definition of a global
symbol, follow the guidelines from K&R: only one definition of a
global symbol (and possibly more declarations).  Rename some vars
here and there to avoid shadowing. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.48 2006/06/30 16:52:13 deraadt Exp $ */
d51 1
d75 1
a75 1
	fprintf(stderr, "usage: %s [-dSs] [-f file]\n", __progname);
d99 1
a99 1
	while ((ch = getopt(argc, argv, "df:sS")) != -1) {
d112 3
@


1.48
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.47 2006/06/30 06:39:00 otto Exp $ */
d84 1
a84 1
	struct ntpd_conf	 conf;
d93 1
a93 1
	bzero(&conf, sizeof(conf));
d101 1
a101 1
			conf.debug = 1;
d107 1
a107 1
			conf.settime = 1;
d110 1
a110 1
			conf.settime = 0;
d118 1
a118 1
	if (parse_config(conffile, &conf))
d133 3
a135 3
	if (!conf.settime) {
		log_init(conf.debug);
		if (!conf.debug)
d146 1
a146 1
	chld_pid = ntp_main(pipe_chld, &conf);
d173 2
a174 2
		if (nfds == 0 && conf.settime) {
			conf.settime = 0;
d176 1
a176 1
			log_init(conf.debug);
d179 1
a179 1
			if (!conf.debug)
d192 1
a192 1
			if (dispatch_imsg(&conf) == -1)
d247 1
a247 1
dispatch_imsg(struct ntpd_conf *conf)
d288 1
a288 1
			if (!conf->settime)
d290 1
a290 1
			log_init(conf->debug);
d294 1
a294 1
			if (!conf->debug)
d297 1
a297 1
			conf->settime = 0;
@


1.47
log
@don't write anything to log until we are daemonized. spotted by
david@@; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.46 2006/06/26 08:10:45 otto Exp $ */
d227 1
a227 1
	char 	*signame;
d365 1
a365 1
	
d380 1
a380 1
	if (adjfreq(&curfreq, NULL) == -1) 
@


1.46
log
@Reset adjtime() on startup; having an adjtime() active while starting
up causes overcompensation and confusing debug log entries; noticed
by dtucker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.45 2006/06/22 11:11:25 otto Exp $ */
d42 1
a42 1
void		ntpd_adjfreq(double);
d283 1
a283 1
			ntpd_adjfreq(d);
d362 1
a362 1
ntpd_adjfreq(double relfreq)
d376 3
a378 2
	log_info("adjusting clock frequency by %f to %fppm", relfreq * 1e6,
	    curfreq / 1e3 / (1LL << 32));
d435 1
a435 1
		ntpd_adjfreq(d);
@


1.45
log
@Save the computed clock drift and use it on startup. ok deraadt@@
henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.44 2006/06/21 07:42:00 otto Exp $ */
d40 1
d132 1
d326 11
@


1.44
log
@avoid a race by installing SIGCHLD handler before fork() is called.
ok henning@@ ckuethe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.43 2006/06/17 18:40:42 otto Exp $ */
d43 2
d147 1
d368 1
d399 40
@


1.43
log
@Import frequency conrrection code from dragonfly, whith some changes:
only do frequency compensation if the clock is synced, and a slightly
diffent way of computing the linear regression.
You'll need a recent kernel and libc to use this.
Testing by naddy@@ and ckuethe@@ and others, thanks!
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.42 2006/06/07 06:29:03 otto Exp $ */
d140 1
a147 1
	signal(SIGCHLD, sighdlr);
@


1.42
log
@Compensate old offsets with the amount of adjustment done, avoiding
overcompensating. From DragonFly, uses recent adjtime(2) changes,
so you'll need a recent kernel. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.41 2006/02/21 23:47:00 stevesk Exp $ */
d41 1
d274 6
d343 22
@


1.41
log
@handle -1 return from host_dns(); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.40 2005/09/06 21:27:10 wvdputte Exp $ */
d323 1
@


1.40
log
@when running ntpd with "-s" as it's argument from /etc/rc.conf, make sure the
output goes to syslog and not console by moving around log_init

OK henning@@, markus@@ and mblamer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.39 2005/07/11 08:08:06 dtucker Exp $ */
d295 2
a296 1
			cnt = host_dns(name, &hn);
@


1.39
log
@More descriptive error if a signal causes the child to exit; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.38 2005/06/19 17:11:13 henning Exp $ */
d278 1
a281 1
			log_init(conf->debug);
@


1.38
log
@use a #define for the time to wait on -s and clarify a log msg
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.37 2005/06/19 16:42:57 henning Exp $ */
d220 2
a221 1
	int	status;
d229 4
a232 2
			log_warnx("Lost child: %s terminated; signal %d",
			    pname, WTERMSIG(status));
@


1.37
log
@use a little state engine to keep track of delayed dns lookups and such,
eases things
tested by Jason Ackley <jason@@ackley.net> Matthias Kilian
<kili@@outback.escape.de> Stephen Marley <stephen@@marley.org.uk> sturm@@
theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.36 2005/05/26 09:13:06 dtucker Exp $ */
d134 1
a134 1
		timeout = 15 * 1000;
d171 2
a172 2
			log_debug("no reply received, skipping initial time "
			    "setting");
@


1.36
log
@Ensure previous adjust has completed before clearing alarm flag; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.35 2005/04/18 20:46:02 henning Exp $ */
d292 8
a299 7
			if ((cnt = host_dns(name, &hn)) > 0) {
				buf = imsg_create(ibuf, IMSG_HOST_DNS,
				    imsg.hdr.peerid, 0,
				    cnt * sizeof(struct sockaddr_storage));
				if (buf == NULL)
					break;
				for (h = hn; h != NULL; h = h->next) {
d301 2
a302 3
				}
				imsg_close(ibuf, buf);
			}
@


1.35
log
@extra paranoia, from a discussion with joerg
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.34 2005/03/31 17:02:43 henning Exp $ */
d40 1
a40 1
void		ntpd_adjtime(double);
d267 2
a268 1
			ntpd_adjtime(d);
d312 1
a312 1
void
d315 3
a317 1
	struct timeval	tv;
d325 1
a325 1
	if (adjtime(&tv, NULL) == -1)
d327 4
@


1.34
log
@zap includes, grunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.33 2005/03/24 10:56:22 henning Exp $ */
d285 5
a289 1
			if (imsg.hdr.len != strlen(name) + 1 + IMSG_HEADER_SIZE)
@


1.33
log
@fatal vs fatalx, Alexander von Gernler
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.32 2005/03/13 10:06:27 dtucker Exp $ */
a22 1
#include <arpa/inet.h>
a23 1
#include <fcntl.h>
@


1.32
log
@Fixes in ntpd_settime (ie ntpd -s):
- Handle errors from syscalls better
- Prevent curtime.tv_usec from being negative for negative offsets.
- Don't claim to have done settimeofday if it fails.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.31 2005/03/09 20:31:11 henning Exp $ */
d267 1
a267 1
				fatal("invalid IMSG_ADJTIME received");
d273 1
a273 1
				fatal("invalid IMSG_SETTIME received");
d288 1
a288 1
				fatal("invalid IMSG_HOST_DNS received");
@


1.31
log
@nasty: host_dns used to run before forking and chrooting etc, so it was
guaranteed that its res_init() call was done once before fork etc...
that is no longer the case. call res_init() in main() early.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.30 2005/03/08 14:28:55 henning Exp $ */
d335 1
a335 2
	d_to_tv(d, &tv);
	if (gettimeofday(&curtime, NULL) == -1)
d337 1
a337 5
	curtime.tv_sec += tv.tv_sec;
	curtime.tv_usec += tv.tv_usec;
	if (curtime.tv_usec > 1000000) {
		curtime.tv_sec++;
		curtime.tv_usec -= 1000000;
d339 6
a344 1
	if (settimeofday(&curtime, NULL) == -1)
d346 2
@


1.30
log
@from the "shut the fuck up, ntpd" department:
move log_debug call to tell about skipping the settime due to lack of
answers down slightly below the 2nd (and final) log_init call so it becomes
a -d only thing. tested by dlg and me
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.29 2005/02/02 18:52:32 henning Exp $ */
d28 1
d94 1
@


1.29
log
@usage() is __dead
pt out by Alexander v Gernler
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.28 2005/01/28 12:32:24 henning Exp $ */
a167 2
			log_debug("no reply received, skipping initial time "
			    "setting");
d171 2
@


1.28
log
@fatal() if daemon() fails, Alexander von Gernler <grunk@@pestilenz.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.27 2004/12/22 16:04:11 henning Exp $ */
d36 7
a42 7
void	sighdlr(int);
void	usage(void);
int	main(int, char *[]);
int	check_child(pid_t, const char *);
int	dispatch_imsg(struct ntpd_conf *);
void	ntpd_adjtime(double);
void	ntpd_settime(double);
d66 1
a66 1
void
@


1.27
log
@d can be negative, take that into account when comparing to the logging
threshold. spotted by Constantine Murenin <mureninc@@gmail.com>, mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.26 2004/12/20 15:10:05 moritz Exp $ */
d131 2
a132 1
			daemon(1, 0);
d139 1
a139 1
	/* fork children */
d174 2
a175 1
				daemon(1, 0);
d279 2
a280 1
				daemon(1, 0);
@


1.26
log
@some typos in log messages.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.25 2004/12/06 20:57:17 mickey Exp $ */
d309 2
a310 1
	if (d >= (double)LOG_NEGLIGEE / 1000)
@


1.25
log
@do not log tiny local clock drifts; w/ help from Joerg Sonnenberger <joerg@@britannica.bec.de>; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.24 2004/11/10 11:27:54 henning Exp $ */
d167 1
a167 1
			log_debug("no reply received, skipping initial time"
d178 1
a178 1
				log_warn("pipe write error (to child");
@


1.24
log
@const'ify conffile
From: Joerg Sonnenberger <joerg@@britannica.bec.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.23 2004/11/04 23:04:22 henning Exp $ */
d309 4
a313 1
	log_info("adjusting local clock by %fs", d);
@


1.23
log
@use SIG_DFL instead of SIG_IGN when we are not interested in SIG_CHILD
anymore, same thing for us and it makes darren's life easier for the
portable
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.22 2004/09/23 01:53:07 henning Exp $ */
d84 1
a84 1
	char			*conffile;
@


1.22
log
@reset chld_pid to 0 when acting upon a SIGCHLD so we don't try to send it
a kill then - tiny possible race there
pointed out by Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.21 2004/09/18 23:21:35 henning Exp $ */
d198 1
a198 1
	signal(SIGCHLD, SIG_IGN);
@


1.21
log
@jmc says S before s and not s before S, sssssssso we do.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.20 2004/09/18 20:37:12 henning Exp $ */
d189 1
a189 1
			if (check_child(chld_pid, "child"))
d191 2
@


1.20
log
@implement -S to override earlier -s, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.19 2004/09/18 20:27:57 henning Exp $ */
d71 1
a71 1
	fprintf(stderr, "usage: %s [-dsS] [-f file]\n", __progname);
@


1.19
log
@don't call settimeofday() when the offset is smaller than 180 seconds,
adjtime() will fix that fast enough, from discussion in theo's living room
ok mcbride beck
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.18 2004/09/18 20:01:38 henning Exp $ */
d71 1
a71 1
	fprintf(stderr, "usage: %s [-d] [-f file] [-s]\n", __progname);
d94 1
a94 1
	while ((ch = getopt(argc, argv, "df:s")) != -1) {
d104 3
@


1.18
log
@add a new -s option, that tells ntpd to set the time using settimeofday()
once at startup. ntpd delays daemonizing until it has done the intial
time setting (or ran into the timeout) in this mode to make sure stuff started
later in rc is not subject to time jumps.
this eleminates the need to run rdate -n beforehands.
with some input from & ok ryan and bob, march music from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.17 2004/09/15 19:21:25 henning Exp $ */
d316 4
@


1.17
log
@imsg framework cleanup:
-kill the _pid flavors of imsg_create and imsg_compose, and just add pid as
argument to those
-use imsg_create in imsg_compose instead of duplicating code
-check for datalen overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.16 2004/09/15 19:14:11 henning Exp $ */
d40 1
a40 1
int	dispatch_imsg(void);
d42 1
d71 1
a71 1
	fprintf(stderr, "usage: %s [-d] [-f file]\n", __progname);
d85 1
a85 2
	int			 debug = 0;
	int			 ch, nfds;
d94 1
a94 1
	while ((ch = getopt(argc, argv, "df:")) != -1) {
d97 1
a97 1
			debug = 1;
d102 3
d125 6
a130 4
	log_init(debug);

	if (!debug)
		daemon(1, 0);
d157 1
a157 1
		if ((nfds = poll(pfd, 1, INFTIM)) == -1)
d163 10
d181 1
a181 1
			if (dispatch_imsg() == -1)
d231 1
a231 1
dispatch_imsg(void)
d262 13
d308 24
@


1.16
log
@malloc the imsg buffers instead of having them statically, suggested by
micsky some time ago, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.15 2004/09/15 00:08:06 henning Exp $ */
d253 1
a253 1
				    imsg.hdr.peerid,
@


1.15
log
@unused variables, theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.14 2004/08/12 16:33:59 henning Exp $ */
d43 4
a46 4
volatile sig_atomic_t	quit = 0;
volatile sig_atomic_t	reconfig = 0;
volatile sig_atomic_t	sigchld = 0;
struct imsgbuf		ibuf;
d142 3
a144 1
	imsg_init(&ibuf, pipe_chld[0]);
d147 1
a147 1
		pfd[PFD_PIPE].fd = ibuf.fd;
d149 1
a149 1
		if (ibuf.w.queued)
d159 1
a159 1
			if (msgbuf_write(&ibuf.w) < 0) {
d189 2
d225 1
a225 1
	if ((n = imsg_read(&ibuf)) == -1)
d234 1
a234 1
		if ((n = imsg_get(&ibuf, &imsg)) == -1)
d252 1
a252 1
				buf = imsg_create(&ibuf, IMSG_HOST_DNS,
d260 1
a260 1
				imsg_close(&ibuf, buf);
@


1.14
log
@do not try to getaddrinfo() in the unprivileged process, send an imsg
asking the privileged one to do it. sends back an imsg with the
resulting addresses in a bunch of struct sockaddr_storage in the data
part.
this should fix all remaining issues with dns (non-)availability at
ntpd startup, be it due to named on localhost or something else.
tested by marco@@ and Chris Paul <chris.paul@@sentinare.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.13 2004/07/13 11:16:22 henning Exp $ */
a42 1
int			rfd = -1;
@


1.13
log
@liek bgpd, use a socketpair(2) instead of a pipe(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.12 2004/07/12 09:38:57 dtucker Exp $ */
d216 1
a216 1
	int			 n;
d218 3
d243 17
@


1.12
log
@Add missing newlines
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.11 2004/07/12 09:22:38 dtucker Exp $ */
d128 2
a129 2
	if (pipe(pipe_chld) == -1)
		fatal("pipe");
@


1.11
log
@Replace errx with equivalent fprintf+exit to make porting easier; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.10 2004/07/09 15:08:54 deraadt Exp $ */
d113 1
a113 1
		fprintf(stderr, "ntpd: need root privileges");
d118 1
a118 1
		fprintf(stderr, "ntpd: unknown user %s", NTPD_USER);
@


1.10
log
@too chatty; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.9 2004/07/09 11:34:11 henning Exp $ */
a23 1
#include <err.h>
d112 4
a115 2
	if (geteuid())
		errx(1, "need root privileges");
d117 4
a120 2
	if (getpwnam(NTPD_USER) == NULL)
		errx(1, "unknown user %s", NTPD_USER);
@


1.9
log
@remove leftover pieces of on-the-fly reconfig shitz that made ntpd exit on
SIGHUP, noticed by otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.8 2004/07/08 15:06:43 henning Exp $ */
a123 2

	log_info("startup");
@


1.8
log
@kill traces of on-the-fly reconfigure (from bgpd), not needed in ntpd
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.7 2004/07/07 06:57:13 henning Exp $ */
a40 1
int	reconfigure(char *);
a167 6
		if (reconfig) {
			log_info("rereading config");
			reconfigure(conffile);
			reconfig = 0;
		}

a208 6
}

int
reconfigure(char *conffile)
{
	return (-1);
@


1.7
log
@don't log every single reply we receive and log local clock adjustemt nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.6 2004/07/05 07:46:16 henning Exp $ */
a93 2
	TAILQ_INIT(&conf.listen_addrs);
	TAILQ_INIT(&conf.ntp_peers);
@


1.6
log
@calculate the median offset from all servers we sync to and call
adjtime() when necessary to keep the local clock in sync
yes, that means ntpd syncs the local clock now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.5 2004/06/17 19:17:48 henning Exp $ */
d268 1
a268 1
	log_debug("calling adjtime, offset=%fs", d);
@


1.5
log
@provide most of the client functionality.
hook the descriptors into the main poll and such.
we're not doing anything with the reply we recive yet, tho.

mostly hacked on the Frankfurt->Montreal flight, as batteries and those
horrible air canada seats permitted...
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.4 2004/06/01 21:58:08 henning Exp $ */
d43 1
d231 1
d249 5
d260 11
@


1.4
log
@first cut at config file parser
for now, one can set the addresses to listen on
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.3 2004/06/01 16:27:09 henning Exp $ */
d94 1
@


1.3
log
@allow ntpd to listen on nearly arbitary number of sockets (OPEN_MAX - 1 atm).
default to one IPv4 wildcard and one IPv6 wildcard one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.2 2004/05/31 13:55:31 henning Exp $ */
d110 3
@


1.2
log
@fix usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.1 2004/05/31 13:46:16 henning Exp $ */
d82 1
d92 3
d129 1
a129 1
	chld_pid = ntp_main(pipe_chld);
@


1.1
log
@initial cut at ntpd.
it is just capable of answering (s)ntp4 requests with the local time
for now.
imsg/buffer and logging framework from bgpd, ntp protocol hackery
with Alexander Guy
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d72 1
a72 1
	fprintf(stderr, "usage: %s [-d] [-f file]", __progname);
@

