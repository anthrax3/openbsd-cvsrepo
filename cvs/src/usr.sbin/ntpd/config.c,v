head	1.28;
access;
symbols
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.19.0.36
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.34
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.30
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.28
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.26
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.24
	OPENBSD_5_0:1.19.0.22
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.20
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.18
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.14
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.16
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.12
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.10
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14;
locks; strict;
comment	@ * @;


1.28
date	2015.10.12.06.50.08;	author reyk;	state Exp;
branches;
next	1.27;
commitid	to5fPpeGvAbrgkr0;

1.27
date	2015.07.18.00.53.44;	author bcook;	state Exp;
branches;
next	1.26;
commitid	X2stLxrcDblnYkzc;

1.26
date	2015.02.10.06.40.08;	author reyk;	state Exp;
branches;
next	1.25;
commitid	pXoTR74Ztt0R3SV0;

1.25
date	2015.02.08.04.54.15;	author reyk;	state Exp;
branches;
next	1.24;
commitid	twMejuTQP3MHvSnB;

1.24
date	2015.01.19.11.44.08;	author bcook;	state Exp;
branches;
next	1.23;
commitid	0c0NxhvuM7P4XhdW;

1.23
date	2015.01.13.02.28.56;	author bcook;	state Exp;
branches;
next	1.22;
commitid	h77ELH1lDWjNCTWO;

1.22
date	2015.01.10.13.47.05;	author tedu;	state Exp;
branches;
next	1.21;
commitid	d03DIVk9MVCSKQBu;

1.21
date	2015.01.10.01.56.52;	author bcook;	state Exp;
branches;
next	1.20;
commitid	LKHBbaSUrPKUUpDf;

1.20
date	2015.01.09.23.48.21;	author bcook;	state Exp;
branches;
next	1.19;
commitid	wwfyZSgvY78WEhrX;

1.19
date	2006.05.27.17.01.07;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.11.15.12.35;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.09.20.31.11;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.08.14.59.36;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.16.00.38.59;	author dtucker;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.30.12.02.59;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.30.11.52.04;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.24.15.23.19;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.12.16.33.59;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.10.12.41.15;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.28.16.38.43;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.25.18.27.58;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.08.01.22.57;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.07.05.47.57;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.07.03.53.14;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.07.03.15.37;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.06.18.03.07;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.02.10.08.59;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.01.21.58.08;	author henning;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Move execution of the constraints from the ntp to the parent process.
This helps the ntp process to a) give a better pledge(2) and to b)
keep the promise of "saving the world again... on time" by removing
the delays that have been introduced by expensive constraint forks.
The new design offers better privsep but introduces a few more imsgs
and runs a little bit more code in the privileged parent.  The
privileged code is minimal, carefully checked, and does not attempt to
"parse" any contents; the forked constraints instantly drop all
privileges and pledge to "stdio inet".

OK beck@@ deraadt@@
@
text
@/*	$OpenBSD: config.c,v 1.27 2015/07/18 00:53:44 bcook Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <netinet/in.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ntpd.h"

struct ntp_addr	*host_v4(const char *);
struct ntp_addr	*host_v6(const char *);

static u_int32_t		 maxid = 0;
static u_int32_t		 constraint_maxid = 0;

void
host(const char *s, struct ntp_addr **hn)
{
	struct ntp_addr	*h = NULL;

	if (!strcmp(s, "*"))
		if ((h = calloc(1, sizeof(struct ntp_addr))) == NULL)
			fatal(NULL);

	/* IPv4 address? */
	if (h == NULL)
		h = host_v4(s);

	/* IPv6 address? */
	if (h == NULL)
		h = host_v6(s);

	if (h == NULL)
		return;

	*hn = h;
}

struct ntp_addr	*
host_v4(const char *s)
{
	struct in_addr		 ina;
	struct sockaddr_in	*sa_in;
	struct ntp_addr		*h;

	memset(&ina, 0, sizeof(struct in_addr));
	if (inet_pton(AF_INET, s, &ina) != 1)
		return (NULL);

	if ((h = calloc(1, sizeof(struct ntp_addr))) == NULL)
		fatal(NULL);
	sa_in = (struct sockaddr_in *)&h->ss;
	sa_in->sin_len = sizeof(struct sockaddr_in);
	sa_in->sin_family = AF_INET;
	sa_in->sin_addr.s_addr = ina.s_addr;

	return (h);
}

struct ntp_addr	*
host_v6(const char *s)
{
	struct addrinfo		 hints, *res;
	struct sockaddr_in6	*sa_in6;
	struct ntp_addr		*h = NULL;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, "0", &hints, &res) == 0) {
		if ((h = calloc(1, sizeof(struct ntp_addr))) == NULL)
			fatal(NULL);
		sa_in6 = (struct sockaddr_in6 *)&h->ss;
		sa_in6->sin6_len = sizeof(struct sockaddr_in6);
		sa_in6->sin6_family = AF_INET6;
		memcpy(&sa_in6->sin6_addr,
		    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
		    sizeof(sa_in6->sin6_addr));
		sa_in6->sin6_scope_id =
		    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;

		freeaddrinfo(res);
	}

	return (h);
}

void
host_dns_free(struct ntp_addr *hn)
{
	struct ntp_addr	*h = hn, *tmp;
	while (h) {
		tmp = h;
		h = h->next;
		free(tmp);
	}
}

int
host_dns(const char *s, struct ntp_addr **hn)
{
	struct addrinfo		 hints, *res0, *res;
	int			 error, cnt = 0;
	struct sockaddr_in	*sa_in;
	struct sockaddr_in6	*sa_in6;
	struct ntp_addr		*h, *hh = NULL;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM; /* DUMMY */
	/* ntpd MUST NOT use AI_ADDRCONFIG here */
	error = getaddrinfo(s, NULL, &hints, &res0);
	if (error == EAI_AGAIN || error == EAI_NODATA || error == EAI_NONAME)
			return (0);
	if (error) {
		log_warnx("could not parse \"%s\": %s", s,
		    gai_strerror(error));
		return (-1);
	}

	for (res = res0; res && cnt < MAX_SERVERS_DNS; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		if ((h = calloc(1, sizeof(struct ntp_addr))) == NULL)
			fatal(NULL);
		h->ss.ss_family = res->ai_family;
		if (res->ai_family == AF_INET) {
			sa_in = (struct sockaddr_in *)&h->ss;
			sa_in->sin_len = sizeof(struct sockaddr_in);
			sa_in->sin_addr.s_addr = ((struct sockaddr_in *)
			    res->ai_addr)->sin_addr.s_addr;
		} else {
			sa_in6 = (struct sockaddr_in6 *)&h->ss;
			sa_in6->sin6_len = sizeof(struct sockaddr_in6);
			memcpy(&sa_in6->sin6_addr, &((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_addr, sizeof(struct in6_addr));
		}

		h->next = hh;
		hh = h;
		cnt++;
	}
	freeaddrinfo(res0);

	*hn = hh;
	return (cnt);
}

struct ntp_peer *
new_peer(void)
{
	struct ntp_peer	*p;

	if ((p = calloc(1, sizeof(struct ntp_peer))) == NULL)
		fatal("new_peer calloc");
	p->id = ++maxid;

	return (p);
}

struct ntp_conf_sensor *
new_sensor(char *device)
{
	struct ntp_conf_sensor	*s;

	if ((s = calloc(1, sizeof(struct ntp_conf_sensor))) == NULL)
		fatal("new_sensor calloc");
	if ((s->device = strdup(device)) == NULL)
		fatal("new_sensor strdup");

	return (s);
}

struct constraint *
new_constraint(void)
{
	struct constraint	*p;

	if ((p = calloc(1, sizeof(struct constraint))) == NULL)
		fatal("new_constraint calloc");
	p->id = ++constraint_maxid;
	p->fd = -1;

	return (p);
}

@


1.27
log
@replace bzero with memset

ok phessler@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.26 2015/02/10 06:40:08 reyk Exp $ */
d206 1
@


1.26
log
@Add support for "constraints": when configured, ntpd(8) will query the
time from HTTPS servers, by parsing the Date: header, and use the
median constraint time as a boundary to verify NTP responses.  This
adds some level of authentication and protection against MITM attacks
while preserving the accuracy of the NTP protocol; without relying on
authentication options for NTP that are basically unavailable at
present.  This is an initial implementation and the semantics will be
improved once it is in the tree.

Discussed with deraadt@@ and henning@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.25 2015/02/08 04:54:15 reyk Exp $ */
d68 1
a68 1
	bzero(&ina, sizeof(struct in_addr));
d89 1
a89 1
	bzero(&hints, sizeof(hints));
d131 1
a131 1
	bzero(&hints, sizeof(hints));
@


1.25
log
@Add a comment that ntpd MUST NOT use AI_ADDRCONFIG in host_dns()

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.24 2015/01/19 11:44:08 bcook Exp $ */
d36 1
d197 13
@


1.24
log
@remove a couple of unused headers.

reported by Jonas 'Sortie' Termansen
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.23 2015/01/13 02:28:56 bcook Exp $ */
d133 1
@


1.23
log
@fix some memory leaks in dns handling.

 - Nothing seems to free the result of host_dns(), so add host_dns_free() and
   call after each query.
 - If imsg_add() fails, it frees buf. Avoid subsequently dereferencing the
   freed buf in imsg_close().

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.22 2015/01/10 13:47:05 tedu Exp $ */
a23 1
#include <arpa/nameser.h>
a25 1
#include <resolv.h>
@


1.22
log
@don't check for a return value that host() doesn't return, so future
generations don't try to change any of the values and break the code.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.21 2015/01/10 01:56:52 bcook Exp $ */
d110 11
@


1.21
log
@revert host() back to correct behavior.

unbreak config file address parsing
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.20 2015/01/09 23:48:21 bcook Exp $ */
d39 1
a39 1
int
d57 1
a57 1
		return (0);
a59 2

	return (1);
@


1.20
log
@return -1 on host() address parsing failure, not 1.

Match what parse.y expects it to return.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.19 2006/05/27 17:01:07 henning Exp $ */
d61 1
a61 1
	return (-1);
@


1.19
log
@config file bits for timedelta sensors, so one can specify which devices
to use. "sensors *" just uses all. untested due to lack of hardware.
hacked on the road somewhere between vancouver and calgary
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.18 2005/05/11 15:12:35 henning Exp $ */
d61 1
a61 1
	return (1);
@


1.18
log
@don't touch *hn in failure case. no real change due to the way we use it
but more correct.
from  Michael Knudsen <e@@molioner.dk>
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.17 2005/03/09 20:31:11 henning Exp $ */
d170 1
a170 1
		fatal("conf_main server calloc");
d174 13
@


1.17
log
@nasty: host_dns used to run before forking and chrooting etc, so it was
guaranteed that its res_init() call was done once before fork etc...
that is no longer the case. call res_init() in main() early.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.16 2005/03/08 14:59:36 henning Exp $ */
a55 1
	*hn = h;
d58 3
@


1.16
log
@from the "shut the fuck up, ntpd" department:
don't whine about temporary dns errors
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.15 2004/12/16 00:38:59 dtucker Exp $ */
a123 1
	res_init();	/* XXX */
@


1.15
log
@Limit the number of addresses used by the 'servers' directive to 8; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.14 2004/08/30 12:02:59 henning Exp $ */
d126 2
d131 1
a131 5
		if (error == EAI_AGAIN || error == EAI_NODATA ||
		    error == EAI_NONAME)
			return (0);
		else
			return (-1);
@


1.14
log
@don't forget to set *hn... theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.13 2004/08/30 11:52:04 deraadt Exp $ */
d136 1
a136 1
	for (res = res0; res; res = res->ai_next) {
@


1.13
log
@skip early DNS lookups -- they are deferred to later; ok otto ho henning
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.12 2004/08/24 15:23:19 henning Exp $ */
d56 1
@


1.12
log
@don't fatal() if getaddrinfo() returns EAI_NONAME
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.11 2004/08/12 16:33:59 henning Exp $ */
a42 1
	int		 cnt = 1;
a55 1
	/* Hostname? */
d57 2
a58 4
		cnt = host_dns(s, &h);

	*hn = h;
	return (cnt);
@


1.11
log
@do not try to getaddrinfo() in the unprivileged process, send an imsg
asking the privileged one to do it. sends back an imsg with the
resulting addresses in a bunch of struct sockaddr_storage in the data
part.
this should fix all remaining issues with dns (non-)availability at
ntpd startup, be it due to named on localhost or something else.
tested by marco@@ and Chris Paul <chris.paul@@sentinare.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.10 2004/08/10 12:41:15 henning Exp $ */
d132 2
a133 1
		if (error == EAI_AGAIN || error == EAI_NODATA)
@


1.10
log
@move memory allocation for new peers into a new function, makes ID allocation
easier
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.9 2004/07/28 16:38:43 henning Exp $ */
d127 1
@


1.9
log
@when a dns lookup fails at parse time, do not abort but try again
to resolve the hostname every 60 seconds
fixes ntpd invocations before e. g. a dialup link is established and such.
as we want ntpd to be a "fire and forget" background daemon it should
cope with such situations.
tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.8 2004/07/25 18:27:58 henning Exp $ */
d23 3
d27 1
d37 2
d124 1
a124 1
	memset(&hints, 0, sizeof(hints));
d126 1
a126 1
	hints.ai_socktype = SOCK_STREAM; /* DUMMY */
d164 12
@


1.8
log
@remove unused function
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.7 2004/07/08 01:22:57 henning Exp $ */
a31 1
struct ntp_addr	*host_dns(const char *);
d33 2
a34 2
struct ntp_addr	*
host(const char *s)
d36 2
a37 1
	struct ntp_addr		*h = NULL;
d53 1
a53 1
		h = host_dns(s);
d55 2
a56 1
	return (h);
d109 2
a110 2
struct ntp_addr	*
host_dns(const char *s)
d113 1
a113 1
	int			 error;
d122 8
a129 2
	if (error)
		return (NULL);
d152 1
d156 2
a157 1
	return (hh);
@


1.7
log
@remove all handling of netmasks/prefix lengths - we don't need that in ntpd.
fixes the dns resolves to v4 and v6 addresses bug found by phessler
hacked on the Calgary->Montreal flight that proved that Air Canada _does_
have some modern aircrafts with good seats
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.6 2004/07/07 05:47:57 henning Exp $ */
a32 23

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}

	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}

	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
		return (-1);
	}

	return (0);
}
@


1.6
log
@do not listen anywhere by default.
listen on *
listens, well, everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.5 2004/07/07 03:53:14 henning Exp $ */
d30 1
a30 1
struct ntp_addr	*host_v4(const char *, u_int8_t *);
d32 1
a32 1
struct ntp_addr	*host_dns(const char *, u_int8_t *);
d58 1
a58 1
host(const char *s, u_int8_t *len)
a59 2
	int			 mask;
	char			*p, *q, *ps;
a61 16
	if ((p = strrchr(s, '/')) != NULL) {
		errno = 0;
		mask = strtol(p+1, &q, 0);
		if (errno == ERANGE || !q || *q || mask > 128 || q == (p+1)) {
			log_warnx("invalid netmask");
			return (NULL);
		}
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			fatal("host: malloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
	} else {
		if ((ps = strdup(s)) == NULL)
			fatal("host: strdup");
		mask = 128;
	}

d68 1
a68 1
		h = host_v4(s, len);
d71 2
a72 4
	if (h == NULL) {
		h = host_v6(ps);
		*len = mask;
	}
d76 1
a76 3
		h = host_dns(ps, len);

	free(ps);
d82 1
a82 1
host_v4(const char *s, u_int8_t *len)
a86 1
	int			 bits = 32;
d89 2
a90 7
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (NULL);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (NULL);
	}
a97 1
	*len = bits;
d132 1
a132 1
host_dns(const char *s, u_int8_t *len)
a158 1
			*len = 32;
a163 1
			*len = 128;
@


1.5
log
@host_* now returns pointers, so the error return is NULL and not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.4 2004/07/07 03:15:37 henning Exp $ */
d79 4
@


1.4
log
@swicth all the host_* functions to work on a newly invented
struct ntp_addr, which just wraps a sockaddr_storage and a next pointer,
so that host_dns can return more than one entry.
let host_dns do exactly that, return a list of all IPs for that hostname
adjust all callers in the grammar to cope with that
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.3 2004/07/06 18:03:07 henning Exp $ */
d69 1
a69 1
			return (0);
d110 1
a110 1
			return (0);
d113 1
a113 1
			return (0);
d170 1
a170 1
		return (0);
@


1.3
log
@allow hostnames and resolve them in the config file
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.2 2004/06/02 10:08:59 henning Exp $ */
d30 3
a32 3
int	host_v4(const char *, struct sockaddr *, u_int8_t *);
int	host_v6(const char *, struct sockaddr *);
int	host_dns(const char *, struct sockaddr *, u_int8_t *);
d57 2
a58 2
int
host(const char *s, struct sockaddr *sa, u_int8_t *len)
a59 1
	int			 done = 0;
d62 1
d81 2
a82 2
	if (!done)
		done = host_v4(s, sa, len);
d85 2
a86 2
	if (!done) {
		done = host_v6(ps, sa);
d91 2
a92 2
	if (!done)
		done = host_dns(ps, sa, len);
d96 1
a96 1
	return (done);
d99 2
a100 2
int
host_v4(const char *s, struct sockaddr *sa, u_int8_t *len)
d104 1
d116 3
a118 1
	sa_in = (struct sockaddr_in *)sa;
d124 1
a124 1
	return (1);
d127 2
a128 2
int
host_v6(const char *s, struct sockaddr *sa)
d132 1
a133 2
	sa_in6 = (struct sockaddr_in6 *)sa;
	sa_in6->sin6_len = sizeof(struct sockaddr_in6);
d139 4
a150 1
		return (1);
d153 1
a153 1
	return (0);
d156 2
a157 2
int
host_dns(const char *s, struct sockaddr *sa, u_int8_t *len)
a160 1
	int			 got = 0;
d163 1
d176 3
a178 1
		sa->sa_family = res->ai_family;
d180 1
a180 1
			sa_in = (struct sockaddr_in *)sa;
d186 1
a186 1
			sa_in6 = (struct sockaddr_in6 *)sa;
d193 2
a194 2
		got++;
		break;	/* XXX should expand to all results... */
d198 1
a198 1
	return (got);
@


1.2
log
@prepare for client functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.1 2004/06/01 21:58:08 henning Exp $ */
d30 3
a32 2
int		host_v4(const char *, struct sockaddr *, u_int8_t *);
int		host_v6(const char *, struct sockaddr *);
d90 4
d149 43
@


1.1
log
@first cut at config file parser
for now, one can set the addresses to listen on
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.37 2004/05/21 15:36:40 claudio Exp $ */
a21 1
#include <sys/mman.h>
a23 2
#include <ifaddrs.h>
#include <netdb.h>
@

