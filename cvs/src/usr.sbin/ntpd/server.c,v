head	1.44;
access;
symbols
	OPENBSD_6_0:1.43.0.6
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.36.0.6
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.4
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.2
	OPENBSD_5_0:1.35.0.10
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.8
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.6
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.6
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.4
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13;
locks; strict;
comment	@ * @;


1.44
date	2016.09.03.11.52.06;	author reyk;	state Exp;
branches;
next	1.43;
commitid	NAWlzXnfvHaWyDX5;

1.43
date	2015.07.18.00.53.44;	author bcook;	state Exp;
branches;
next	1.42;
commitid	X2stLxrcDblnYkzc;

1.42
date	2015.05.19.16.07.38;	author reyk;	state Exp;
branches;
next	1.41;
commitid	tYJkDADHBbvjIABU;

1.41
date	2015.02.10.11.46.39;	author reyk;	state Exp;
branches;
next	1.40;
commitid	azl2PYCfRcxq0H2y;

1.40
date	2015.01.09.07.35.37;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	X9qvCMjSyjyh2fK9;

1.39
date	2014.06.03.18.42.29;	author chl;	state Exp;
branches;
next	1.38;
commitid	83mYnVvzxZlhvz7I;

1.38
date	2013.10.21.08.48.22;	author phessler;	state Exp;
branches;
next	1.37;

1.37
date	2013.04.30.11.42.56;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2011.09.21.15.41.30;	author phessler;	state Exp;
branches;
next	1.35;

1.35
date	2009.05.20.14.55.59;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2008.11.10.17.55.36;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2008.11.10.16.59.33;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.10.03.46.09;	author naddy;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.15.08.19.11;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.01.18.52.46;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.07.06.29.03;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.19.11.20.23;	author dtucker;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.19.06.40.16;	author dtucker;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.24.00.32.03;	author dtucker;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.10.13.48.36;	author dtucker;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.22.08.58.56;	author dtucker;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.05.10.09.12;	author dtucker;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.24.20.10.50;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.28.12.01.32;	author dtucker;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.22.05.36.11;	author dtucker;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.08.15.47.38;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.22.21.17.37;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.15.01.58.04;	author dtucker;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.14.09.35.48;	author dtucker;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.13.14.02.50;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.13.12.22.39;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.07.22.43.07;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.18.13.26.53;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.14.20.16.31;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.13.19.41.26;	author alexander;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.13.17.27.57;	author alexander;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.11.03.05.50;	author dtucker;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.07.07.32.05;	author alexander;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.07.07.05.35;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.07.05.47.57;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.04.18.07.15;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.29.18.34.00;	author alexander;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.18.04.51.31;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.02.10.08.59;	author henning;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Remove the oh so funny "LOSS OF MIND" from the diclaimer that was not
part of the original ISC license that we use in OpenBSD.  Done for
files were Henning is the original author.

OK henning@@ deraadt@@
@
text
@/*	$OpenBSD: server.c,v 1.43 2015/07/18 00:53:44 bcook Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2004 Alexander Guy <alexander@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <net/if.h>
#include <errno.h>
#include <ifaddrs.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ntpd.h"

int
setup_listeners(struct servent *se, struct ntpd_conf *lconf, u_int *cnt)
{
	struct listen_addr	*la, *nla, *lap;
	struct ifaddrs		*ifa, *ifap;
	struct sockaddr		*sa;
	struct if_data		*ifd;
	u_int8_t		*a6;
	size_t			 sa6len = sizeof(struct in6_addr);
	u_int			 new_cnt = 0;
	int			 tos = IPTOS_LOWDELAY, rdomain = 0;

	TAILQ_FOREACH(lap, &lconf->listen_addrs, entry) {
		switch (lap->sa.ss_family) {
		case AF_UNSPEC:
			if (getifaddrs(&ifa) == -1)
				fatal("getifaddrs");

			for (ifap = ifa; ifap != NULL; ifap = ifap->ifa_next) {
				sa = ifap->ifa_addr;
				if (sa == NULL || SA_LEN(sa) == 0)
					continue;
				if (sa->sa_family == AF_LINK) {
					ifd = ifap->ifa_data;
					rdomain = ifd->ifi_rdomain;
				}
				if (sa->sa_family != AF_INET &&
				    sa->sa_family != AF_INET6)
					continue;
				if (lap->rtable != -1 && rdomain != lap->rtable)
					continue;

				if (sa->sa_family == AF_INET &&
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr ==
				    INADDR_ANY)
					continue;

				if (sa->sa_family == AF_INET6) {
					a6 = ((struct sockaddr_in6 *)sa)->
					    sin6_addr.s6_addr;
					if (memcmp(a6, &in6addr_any, sa6len) == 0)
						continue;
				}

				if ((la = calloc(1, sizeof(struct listen_addr))) ==
				    NULL)
					fatal("setup_listeners calloc");

				memcpy(&la->sa, sa, SA_LEN(sa));
				la->rtable = rdomain;

				TAILQ_INSERT_TAIL(&lconf->listen_addrs, la, entry);
			}

			freeifaddrs(ifa);
		default:
			continue;
		}
	}


	for (la = TAILQ_FIRST(&lconf->listen_addrs); la; ) {
		switch (la->sa.ss_family) {
		case AF_INET:
			if (((struct sockaddr_in *)&la->sa)->sin_port == 0)
				((struct sockaddr_in *)&la->sa)->sin_port =
				    se->s_port;
			break;
		case AF_INET6:
			if (((struct sockaddr_in6 *)&la->sa)->sin6_port == 0)
				((struct sockaddr_in6 *)&la->sa)->sin6_port =
				    se->s_port;
			break;
		case AF_UNSPEC:
			nla = TAILQ_NEXT(la, entry);
			TAILQ_REMOVE(&lconf->listen_addrs, la, entry);
			free(la);
			la = nla;
			continue;
		default:
			fatalx("king bula sez: af borked");
		}

		log_info("listening on %s %s",
		    log_sockaddr((struct sockaddr *)&la->sa),
		    print_rtable(la->rtable));

		if ((la->fd = socket(la->sa.ss_family, SOCK_DGRAM, 0)) == -1)
			fatal("socket");

		if (la->sa.ss_family == AF_INET && setsockopt(la->fd,
		    IPPROTO_IP, IP_TOS, &tos, sizeof(tos)) == -1)
			log_warn("setsockopt IPTOS_LOWDELAY");

		if (la->rtable != -1 &&
		    setsockopt(la->fd, SOL_SOCKET, SO_RTABLE, &la->rtable,
		    sizeof(la->rtable)) == -1)
			fatal("setup_listeners setsockopt SO_RTABLE");

		if (bind(la->fd, (struct sockaddr *)&la->sa,
		    SA_LEN((struct sockaddr *)&la->sa)) == -1) {
			log_warn("bind on %s failed, skipping",
			    log_sockaddr((struct sockaddr *)&la->sa));
			close(la->fd);
			nla = TAILQ_NEXT(la, entry);
			TAILQ_REMOVE(&lconf->listen_addrs, la, entry);
			free(la);
			la = nla;
			continue;
		}
		new_cnt++;
		la = TAILQ_NEXT(la, entry);
	}

	*cnt = new_cnt;

	return (0);
}

int
server_dispatch(int fd, struct ntpd_conf *lconf)
{
	ssize_t			 size;
	double			 rectime;
	struct sockaddr_storage	 fsa;
	socklen_t		 fsa_len;
	struct ntp_msg		 query, reply;
	char			 buf[NTP_MSGSIZE];

	fsa_len = sizeof(fsa);
	if ((size = recvfrom(fd, &buf, sizeof(buf), 0,
	    (struct sockaddr *)&fsa, &fsa_len)) == -1) {
		if (errno == EHOSTUNREACH || errno == EHOSTDOWN ||
		    errno == ENETUNREACH || errno == ENETDOWN) {
			log_warn("recvfrom %s",
			    log_sockaddr((struct sockaddr *)&fsa));
			return (0);
		} else
			fatal("recvfrom");
	}

	rectime = gettime_corrected();

	if (ntp_getmsg((struct sockaddr *)&fsa, buf, size, &query) == -1)
		return (0);

	memset(&reply, 0, sizeof(reply));
	if (lconf->status.synced)
		reply.status = lconf->status.leap;
	else
		reply.status = LI_ALARM;
	reply.status |= (query.status & VERSIONMASK);
	if ((query.status & MODEMASK) == MODE_CLIENT)
		reply.status |= MODE_SERVER;
	else if ((query.status & MODEMASK) == MODE_SYM_ACT)
		reply.status |= MODE_SYM_PAS;
	else /* ignore packets of different type (e.g. bcast) */
		return (0);

	reply.stratum =	lconf->status.stratum;
	reply.ppoll = query.ppoll;
	reply.precision = lconf->status.precision;
	reply.rectime = d_to_lfp(rectime);
	reply.reftime = d_to_lfp(lconf->status.reftime);
	reply.xmttime = d_to_lfp(gettime_corrected());
	reply.orgtime = query.xmttime;
	reply.rootdelay = d_to_sfp(lconf->status.rootdelay);
	reply.refid = lconf->status.refid;

	ntp_sendmsg(fd, (struct sockaddr *)&fsa, &reply);
	return (0);
}
@


1.43
log
@replace bzero with memset

ok phessler@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.42 2015/05/19 16:07:38 reyk Exp $ */
d15 3
a17 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.42
log
@Get the rdomain from the newly exposed ifi_rdomain field in if_data
instead of calling the SIOCGIFRDOMAIN ioctl for every single address.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.41 2015/02/10 11:46:39 reyk Exp $ */
d178 1
a178 1
	bzero(&reply, sizeof(reply));
@


1.41
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.40 2015/01/09 07:35:37 deraadt Exp $ */
d38 1
a38 1
	struct ifreq		 ifr;
d42 1
a42 1
	int			 tos = IPTOS_LOWDELAY, rdomain, fd;
d52 1
a52 3
				if (sa == NULL ||
				    (sa->sa_family != AF_INET &&
				    sa->sa_family != AF_INET6))
d54 6
a59 1
				if (SA_LEN(sa) == 0)
a60 12

				strlcpy(ifr.ifr_name, ifap->ifa_name,
				    sizeof(ifr.ifr_name));

				fd = socket(AF_INET, SOCK_DGRAM, 0);
				if (ioctl(fd, SIOCGIFRDOMAIN,
				    (caddr_t)&ifr) == -1)
					rdomain = 0;
				else
					rdomain = ifr.ifr_rdomainid;
				close(fd);

@


1.40
log
@remove excessive/wrong use of sys/param.h
peanuts -- but all work has to start somewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.39 2014/06/03 18:42:29 chl Exp $ */
d65 3
a67 3
			                rdomain = 0;
			        else
			                rdomain = ifr.ifr_rdomainid;
@


1.39
log
@remove set but not used variable

found while building portable OpenNTPD

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.38 2013/10/21 08:48:22 phessler Exp $ */
d20 1
a21 1
#include <sys/types.h>
@


1.38
log
@remove the IPv4-only check for rdomains, allows IPv6 to use them

OK claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.37 2013/04/30 11:42:56 mglocker Exp $ */
a163 1
	u_int8_t		 version;
a185 2

	version = (query.status & VERSIONMASK) >> 3;
@


1.37
log
@Remove unused function argument variables 'len' and 'auth' from
ntp_sendmsg().  They have been removed from the function body in the past
but not from the argument list.

From Maxime Villard
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.36 2011/09/21 15:41:30 phessler Exp $ */
d135 2
a136 2
		if (la->sa.ss_family == AF_INET && la->rtable != -1 &&
		    setsockopt(la->fd, IPPROTO_IP, SO_RTABLE, &la->rtable,
@


1.36
log
@Add rdomain support to NTPd.

This basically adds the "rtable %d" keyword to "listen on", "server",
"servers" keywords, to specify which routing table to use.

OK henning@@ claudio@@ sthen@@
manpage reviewed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.35 2009/05/20 14:55:59 henning Exp $ */
d213 1
a213 1
	ntp_sendmsg(fd, (struct sockaddr *)&fsa, &reply, size, 0);
@


1.35
log
@fix looking at the mode bits so that we do not reply to broadcast and other
junk. from thorsten glaser.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.34 2008/11/10 17:55:36 deraadt Exp $ */
d20 1
d23 1
d35 1
a35 1
	struct listen_addr	*la;
d38 1
d42 1
a42 1
	int			 tos = IPTOS_LOWDELAY;
d44 11
a54 23
	if (lconf->listen_all) {
		if (getifaddrs(&ifa) == -1)
			fatal("getifaddrs");

		for (ifap = ifa; ifap != NULL; ifap = ifap->ifa_next) {
			sa = ifap->ifa_addr;

			if (sa == NULL ||
			    (sa->sa_family != AF_INET &&
			    sa->sa_family != AF_INET6))
				continue;
			if (SA_LEN(sa) == 0)
				continue;

			if (sa->sa_family == AF_INET &&
			    ((struct sockaddr_in *)sa)->sin_addr.s_addr ==
			    INADDR_ANY)
				continue;

			if (sa->sa_family == AF_INET6) {
				a6 = ((struct sockaddr_in6 *)sa)->
				    sin6_addr.s6_addr;
				if (memcmp(a6, &in6addr_any, sa6len) == 0)
d56 37
d95 3
a97 6
			if ((la = calloc(1, sizeof(struct listen_addr))) ==
			    NULL)
				fatal("setup_listeners calloc");

			memcpy(&la->sa, sa, SA_LEN(sa));
			TAILQ_INSERT_TAIL(&lconf->listen_addrs, la, entry);
d99 1
a100 2
		freeifaddrs(ifa);
	}
d114 6
d124 3
a126 2
		log_info("listening on %s",
		    log_sockaddr((struct sockaddr *)&la->sa));
d135 5
a141 2
			struct listen_addr	*nla;

@


1.34
log
@delete operation not needed; from naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.33 2008/11/10 16:59:33 deraadt Exp $ */
d164 1
a164 1
	else
d166 2
@


1.33
log
@If a bind() spuriously fails (as appears to happen once in a blue moon due
to some stupid ipv6 bug in particular), remove that 'listen' from the list
and continue operation.  issue spotted by naddy
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.32 2008/06/10 03:46:09 naddy Exp $ */
a110 1
			la->fd = -1;
@


1.32
log
@According to the latest SNTPv4 spec in RFC4330, secondary servers
return the address of the synchronization source as reference
identification.  Remove the obsolete special casing specified in RFC2030.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.31 2007/01/15 08:19:11 otto Exp $ */
d78 1
a78 3
	TAILQ_FOREACH(la, &lconf->listen_addrs, entry) {
		new_cnt++;

d105 15
a119 2
		    SA_LEN((struct sockaddr *)&la->sa)) == -1)
			fatal("bind");
@


1.31
log
@Although Unix compilers accept more than one definition of a global
symbol, follow the guidelines from K&R: only one definition of a
global symbol (and possibly more declarations).  Rename some vars
here and there to avoid shadowing. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.30 2006/07/01 18:52:46 otto Exp $ */
d165 1
a165 5

	if (version > 3)
		reply.refid = lconf->status.refid4;
	else
		reply.refid = lconf->status.refid;
@


1.30
log
@remove some unneeded includes; one found by vetinari
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.29 2006/06/07 06:29:03 otto Exp $ */
d31 1
a31 1
setup_listeners(struct servent *se, struct ntpd_conf *conf, u_int *cnt)
d41 1
a41 1
	if (conf->listen_all) {
d72 1
a72 1
			TAILQ_INSERT_TAIL(&conf->listen_addrs, la, entry);
d78 1
a78 1
	TAILQ_FOREACH(la, &conf->listen_addrs, entry) {
d117 1
a117 1
server_dispatch(int fd, struct ntpd_conf *conf)
d147 2
a148 2
	if (conf->status.synced)
		reply.status = conf->status.leap;
d157 1
a157 1
	reply.stratum =	conf->status.stratum;
d159 1
a159 1
	reply.precision = conf->status.precision;
d161 1
a161 1
	reply.reftime = d_to_lfp(conf->status.reftime);
d164 1
a164 1
	reply.rootdelay = d_to_sfp(conf->status.rootdelay);
d167 1
a167 1
		reply.refid = conf->status.refid4;
d169 1
a169 1
		reply.refid = conf->status.refid;
@


1.29
log
@Compensate old offsets with the amount of adjustment done, avoiding
overcompensating. From DragonFly, uses recent adjtime(2) changes,
so you'll need a recent kernel. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.28 2006/01/19 11:20:23 dtucker Exp $ */
a28 1
#include "ntp.h"
@


1.28
log
@Do not attempt to listen on interfaces with a wildcard address; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.27 2006/01/19 06:40:16 dtucker Exp $ */
d140 1
a140 1
	rectime = gettime();
d163 1
a163 1
	reply.xmttime = d_to_lfp(gettime());
@


1.27
log
@Check SA_LEN(sa) after sa is checked for NULL.  Pointed out by solar at
openwall.com, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.26 2005/09/24 00:32:03 dtucker Exp $ */
d37 2
d55 12
@


1.26
log
@Log source address for 'malformed packet' errors.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.25 2005/08/10 13:48:36 dtucker Exp $ */
a46 2
			if (SA_LEN(sa) == 0)
				continue;
d50 2
@


1.25
log
@Propogate server's leap indicator flags to clients; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.24 2005/07/22 08:58:56 dtucker Exp $ */
d128 1
a128 1
	if (ntp_getmsg(buf, size, &query) == -1)
@


1.24
log
@Skip invalid interfaces during 'listen on *'; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.23 2005/07/05 10:09:12 dtucker Exp $ */
d134 5
a138 1
	reply.status = conf->status.leap | (query.status & VERSIONMASK);
@


1.23
log
@Save transmit time for each peer for later use as refid for SNTPv4
replies.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.22 2005/05/24 20:10:50 henning Exp $ */
d47 2
@


1.22
log
@ifa->ifa_addr can be NULL in some cases, pt out by Kurt Roeckx
<kurt@@roeckx.be> / bugs.debian.org/310586
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.21 2005/01/28 12:01:32 dtucker Exp $ */
d148 1
a148 1
		reply.refid = reply.xmttime.fractionl;
@


1.21
log
@Make network unreachable errors non-fatal; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.20 2004/12/22 05:36:11 dtucker Exp $ */
d47 3
a49 2
			if (sa->sa_family != AF_INET &&
			    sa->sa_family != AF_INET6)
@


1.20
log
@Save original value returned by getifaddrs to free later; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.19 2004/12/08 15:47:38 mickey Exp $ */
d115 1
a115 1
		    errno == ENETDOWN) {
@


1.19
log
@uniquely name members of s_fixedpt and l_fixedpt; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.18 2004/10/22 21:17:37 henning Exp $ */
d35 1
a35 1
	struct ifaddrs		*ifap;
d41 1
a41 1
		if (getifaddrs(&ifap) == -1)
d44 1
a44 1
		for (; ifap != NULL; ifap = ifap->ifa_next) {
d59 1
a59 1
		freeifaddrs(ifap);
@


1.18
log
@in server mode reply with stratum from the peer that we currently prefer
plus one
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.17 2004/10/15 01:58:04 dtucker Exp $ */
d147 1
a147 1
		reply.refid = reply.xmttime.fraction;
@


1.17
log
@Only set IPTOS_LOWDELAY on IPv4 interfaces; pointed out by phessler, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.16 2004/10/14 09:35:48 dtucker Exp $ */
d137 1
a137 1
	reply.stratum =	2;
@


1.16
log
@Have ntpd use IPTOS_LOWDELAY; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.15 2004/10/13 14:02:50 henning Exp $ */
d86 2
a87 2
		if (setsockopt(la->fd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos))
		    == -1)
@


1.15
log
@set rootdelay in replies.
inherit rootdelay from the delay from the last client update from the peer
that we picked last time to adjust the local clock.
in some cases we use the average offset between two peers' client updates,
then use the average delay between the two as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.14 2004/10/13 12:22:39 henning Exp $ */
d38 1
d85 4
@


1.14
log
@correctly set refid in replies with NTP protocol versions < 4.
code path for NTP4 remains unchanged, we already set refid correctly there.
NTP3 and older uses an IPv4 address as refid.
use the IP of the server we last synced to if it was a IPv4 one.
sometimes we use the average offset between two, in that case just pick
one for the IP.
this scheme naturally fails when we query IPv6 servers and have to reply
to IPv4 NTP3 (or even older NTP versions) clients - refid stays at 0 then.
this is a protocol limitation, nothing we can do about it.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.13 2004/09/07 22:43:07 henning Exp $ */
d139 1
@


1.13
log
@ignore ntp_sendmsg()s return value in server_dispatch. could result in
ntpd exiting on sendmsg() failures, which is not desired.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.12 2004/07/18 13:26:53 henning Exp $ */
d143 1
a143 1
		reply.refid = 0;	/* XXX */
@


1.12
log
@there are a few recvfrom(2) errors we do not want to panic on
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.11 2004/07/14 20:16:31 henning Exp $ */
d145 2
a146 1
	return (ntp_sendmsg(fd, (struct sockaddr *)&fsa, &reply, size, 0));
@


1.11
log
@do not do the stratum guessing dance.
stratum is pretty much pointless anyway these days, and we certainly
do not want to send out illegal packets (stratum=0) until synced...
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.10 2004/07/13 19:41:26 alexander Exp $ */
d108 9
a116 2
	    (struct sockaddr *)&fsa, &fsa_len)) == -1)
		fatal("recvfrom");
@


1.10
log
@Respond to client queries with better server statistics.  We now output
a close-to-reality stratum, a real reference time, and a leap indicator
that will indicate if the local clock isn't synchronized.

This also means that until the server feels it's synchronized, it will
tell the clients it isn't.  This is normal, and correct.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.9 2004/07/13 17:27:57 alexander Exp $ */
d125 1
a125 1
	reply.stratum =	conf->status.stratum;
@


1.9
log
@ignore obviously malformed queries; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.8 2004/07/11 03:05:50 dtucker Exp $ */
d5 1
d96 1
a96 1
server_dispatch(int fd)
d99 1
d116 2
d119 1
a119 1
	reply.status = 0 | (query.status & VERSIONMASK);
d125 1
a125 1
	reply.stratum =	2;			/* XXX */
d127 1
a127 1
	reply.precision = 0;			/* XXX */
d129 1
a129 1
	reply.reftime = reply.rectime;		/* XXX */
d132 5
a136 1
	reply.refid = reply.xmttime.fraction;	/* XXX */
@


1.8
log
@Use SA_LEN(sa) instead of sa->sa_len; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.7 2004/07/07 07:32:05 alexander Exp $ */
d111 2
a112 1
	ntp_getmsg(buf, size, &query);
@


1.7
log
@* Convert to use the new double-based time handling functions.
* Respond to the query with a reasonable received time (which
  will help clients get better accuracy).
* Consolidate the server response code in preparation for a
  completely 'proper' response to the client.

tips and ok from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.6 2004/07/07 07:05:35 henning Exp $ */
d84 2
a85 2
		if (bind(la->fd, (struct sockaddr *)&la->sa, la->sa.ss_len) ==
		    -1)
@


1.6
log
@ease code and tweak logging
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.5 2004/07/07 05:47:57 henning Exp $ */
d95 1
a95 1
ntp_reply(int fd, struct sockaddr *sa, struct ntp_msg *query, int auth)
d97 11
a107 3
	ssize_t			 len;
	struct l_fixedpt	 t;
	struct ntp_msg		 reply;
d109 3
a111 4
	if (auth)
		len = NTP_MSGSIZE;
	else
		len = NTP_MSGSIZE_NOAUTH;
d114 2
a115 2
	reply.status = 0 | (query->status & VERSIONMASK);
	if ((query->status & MODEMASK) == MODE_CLIENT)
d120 2
a121 2
	reply.stratum =	2;
	reply.ppoll = query->ppoll;
d123 5
a127 10
	reply.refid = htonl(t.fraction);	/* XXX */
	get_ts(&t);
	reply.reftime.int_part = htonl(t.int_part);	/* XXX */
	reply.reftime.fraction = htonl(t.fraction);	/* XXX */
	reply.rectime.int_part = htonl(t.int_part);
	reply.rectime.fraction = htonl(t.fraction);
	reply.xmttime.int_part = htonl(t.int_part);
	reply.xmttime.fraction = htonl(t.fraction);
	reply.orgtime.int_part = query->xmttime.int_part;
	reply.orgtime.fraction = query->xmttime.fraction;
d129 1
a129 1
	return (ntp_sendmsg(fd, sa, &reply, len, auth));
@


1.5
log
@do not listen anywhere by default.
listen on *
listens, well, everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.4 2004/07/04 18:07:15 henning Exp $ */
a32 1
	char			 ntopbuf[INET6_ADDRSTRLEN];
d35 1
a35 1
	struct sockaddr		*sap;
d43 1
a43 1
			sap = ifap->ifa_addr;
d45 2
a46 2
			if (sap->sa_family != AF_INET &&
			    sap->sa_family != AF_INET6)
d53 1
a53 1
			memcpy(&la->sa, sap, SA_LEN(sap));
a60 1
		sap = (struct sockaddr *)&la->sa;
d65 2
a66 2
			if (((struct sockaddr_in *)sap)->sin_port == 0)
				((struct sockaddr_in *)sap)->sin_port =
a67 3
			inet_ntop(AF_INET,
			    &((struct sockaddr_in *)sap)->sin_addr,
			    ntopbuf, sizeof(ntopbuf));
d70 2
a71 2
			if (((struct sockaddr_in6 *)sap)->sin6_port == 0)
				((struct sockaddr_in6 *)sap)->sin6_port =
a72 3
			inet_ntop(AF_INET6,
			    &((struct sockaddr_in6 *)sap)->sin6_addr,
			    ntopbuf, sizeof(ntopbuf));
d78 2
a79 1
		log_debug("adding listener on %s", ntopbuf);
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.3 2004/06/29 18:34:00 alexander Exp $ */
d39 1
a39 1
	if (TAILQ_EMPTY(&conf->listen_addrs)) {
@


1.3
log
@When no listener is specified, create a listener on every IP.  Problem
reported by Peter Hessler.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.2 2004/06/18 04:51:31 henning Exp $ */
d33 1
a33 1
	char 			 ntopbuf[INET6_ADDRSTRLEN];
a66 1

a69 1

d71 2
a72 3
				  &((struct sockaddr_in *)sap)->sin_addr,
				  ntopbuf, sizeof(ntopbuf));

a74 1

a77 1

d79 2
a80 2
		       		  &((struct sockaddr_in6 *)sap)->sin6_addr,
				  ntopbuf, sizeof(ntopbuf));
a83 1

@


1.2
log
@size struct pollfd and idx2peer dynamically instead of imposing an arbitary
limit on OPEN_MAX, modeled after bgpd
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.1 2004/06/02 10:08:59 henning Exp $ */
d19 2
a20 1
#include <sys/param.h>
d22 1
d33 1
d35 2
d40 19
a58 15
		if ((la = calloc(1, sizeof(struct listen_addr))) == NULL)
			fatal("setup_listeners calloc");
		la->sa.ss_len = sizeof(struct sockaddr_in);
		((struct sockaddr_in *)&la->sa)->sin_family = AF_INET;
		((struct sockaddr_in *)&la->sa)->sin_addr.s_addr =
		    htonl(INADDR_ANY);
		((struct sockaddr_in *)&la->sa)->sin_port = se->s_port;
		TAILQ_INSERT_TAIL(&conf->listen_addrs, la, entry);

		if ((la = calloc(1, sizeof(struct listen_addr))) == NULL)
			fatal("setup_listeners calloc");
		la->sa.ss_len = sizeof(struct sockaddr_in6);
		((struct sockaddr_in6 *)&la->sa)->sin6_family = AF_INET6;
		((struct sockaddr_in6 *)&la->sa)->sin6_port = se->s_port;
		TAILQ_INSERT_TAIL(&conf->listen_addrs, la, entry);
d62 1
d67 3
a69 2
			if (((struct sockaddr_in *)&la->sa)->sin_port == 0)
				((struct sockaddr_in *)&la->sa)->sin_port =
d71 5
d78 3
a80 2
			if (((struct sockaddr_in6 *)&la->sa)->sin6_port == 0)
				((struct sockaddr_in6 *)&la->sa)->sin6_port =
d82 4
d91 2
@


1.1
log
@prepare for client functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.5 2004/06/01 21:58:08 henning Exp $ */
d29 1
a29 1
setup_listeners(struct servent *se, struct ntpd_conf *conf)
d32 1
d53 2
d78 2
@

