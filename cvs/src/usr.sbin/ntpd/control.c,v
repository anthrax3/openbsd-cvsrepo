head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.2
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.12
date	2017.01.09.14.04.31;	author krw;	state Exp;
branches;
next	1.11;
commitid	KJkQGNLsnMxWc9MG;

1.11
date	2016.09.14.13.20.16;	author rzalamena;	state Exp;
branches;
next	1.10;
commitid	FUtuYlECIdeLHfjN;

1.10
date	2016.03.27.11.16.12;	author krw;	state Exp;
branches;
next	1.9;
commitid	syOeQHSeA2wvpEwB;

1.9
date	2015.12.05.13.12.16;	author claudio;	state Exp;
branches;
next	1.8;
commitid	1u4z6EiD1xQ1Wwbx;

1.8
date	2015.11.20.18.53.42;	author tedu;	state Exp;
branches;
next	1.7;
commitid	SFNKvezZfDhL1PAj;

1.7
date	2015.10.23.14.52.20;	author phessler;	state Exp;
branches;
next	1.6;
commitid	37dFIvtgNCa7AEy2;

1.6
date	2015.07.18.00.53.44;	author bcook;	state Exp;
branches;
next	1.5;
commitid	X2stLxrcDblnYkzc;

1.5
date	2015.02.10.06.40.08;	author reyk;	state Exp;
branches;
next	1.4;
commitid	pXoTR74Ztt0R3SV0;

1.4
date	2015.01.09.07.35.37;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	X9qvCMjSyjyh2fK9;

1.3
date	2015.01.04.01.24.43;	author bcook;	state Exp;
branches;
next	1.2;
commitid	0mLKLwEPo7XcKuWK;

1.2
date	2013.11.13.20.44.39;	author benno;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.04.14.28.16;	author phessler;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Replace hand-rolled for(;;) traversal of ctl_conns TAILQ with
TAILQ_FOREACH().

No intentional functional change.

ok reyk@@
@
text
@/*	$OpenBSD: control.c,v 1.11 2016/09/14 13:20:16 rzalamena Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2012 Mike Miller <mmiller@@mgm51.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>

#include "ntpd.h"

#define	CONTROL_BACKLOG	5

#define square(x) ((x) * (x))

int
control_init(char *path)
{
	struct sockaddr_un	 sa;
	int			 fd;
	mode_t			 old_umask;

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0)) == -1) {
		log_warn("control_init: socket");
		return (-1);
	}

	memset(&sa, 0, sizeof(sa));
	sa.sun_family = AF_UNIX;
	if (strlcpy(sa.sun_path, path, sizeof(sa.sun_path)) >=
	    sizeof(sa.sun_path))
		errx(1, "ctl socket name too long");

	if (unlink(path) == -1)
		if (errno != ENOENT) {
			log_warn("control_init: unlink %s", path);
			close(fd);
			return (-1);
		}

	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
	if (bind(fd, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
		log_warn("control_init: bind: %s", path);
		close(fd);
		umask(old_umask);
		return (-1);
	}
	umask(old_umask);

	if (chmod(path, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
		log_warn("control_init: chmod");
		close(fd);
		(void)unlink(path);
		return (-1);
	}

	session_socket_nonblockmode(fd);

	return (fd);
}

int
control_listen(int fd)
{
	if (fd != -1 && listen(fd, CONTROL_BACKLOG) == -1) {
		log_warn("control_listen: listen");
		return (-1);
	}

	return (0);
}

void
control_shutdown(int fd)
{
	close(fd);
}

void
control_cleanup(const char *path)
{
	if (path)
		unlink(path);
}

int
control_accept(int listenfd)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sa;
	struct ctl_conn		*ctl_conn;

	len = sizeof(sa);
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sa, &len)) == -1) {
		if (errno != EWOULDBLOCK && errno != EINTR)
			log_warn("control_accept: accept");
		return (0);
	}

	session_socket_nonblockmode(connfd);

	if ((ctl_conn = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		log_warn("control_accept");
		close(connfd);
		return (0);
	}

	imsg_init(&ctl_conn->ibuf, connfd);

	TAILQ_INSERT_TAIL(&ctl_conns, ctl_conn, entry);

	return (1);
}

struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->ibuf.fd == fd)
			break;
	}

	return (c);
}

int
control_close(int fd)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("control_close: fd %d: not found", fd);
		return (0);
	}

	msgbuf_clear(&c->ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	close(c->ibuf.fd);
	free(c);

	return (1);
}

int
control_dispatch_msg(struct pollfd *pfd, u_int *ctl_cnt)
{
	struct imsg		 imsg;
	struct ctl_conn		*c;
	struct ntp_peer		*p;
	struct ntp_sensor	*s;
	struct ctl_show_status	 c_status;
	struct ctl_show_peer	 c_peer;
	struct ctl_show_sensor	 c_sensor;
	int			 cnt;
	ssize_t			 n;

	if ((c = control_connbyfd(pfd->fd)) == NULL) {
		log_warn("control_dispatch_msg: fd %d: not found", pfd->fd);
		return (0);
	}

	if (pfd->revents & POLLOUT)
		if (msgbuf_write(&c->ibuf.w) <= 0 && errno != EAGAIN) {
			*ctl_cnt -= control_close(pfd->fd);
			return (1);
		}

	if (!(pfd->revents & POLLIN))
		return (0);

	if (((n = imsg_read(&c->ibuf)) == -1 && errno != EAGAIN) || n == 0) {
		*ctl_cnt -= control_close(pfd->fd);
		return (1);
	}

	for (;;) {
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1) {
			*ctl_cnt -= control_close(pfd->fd);
			return (1);
		}
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_SHOW_STATUS:
			build_show_status(&c_status);
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_STATUS, 0, 0, -1,
			    &c_status, sizeof (c_status));
			break;
		case IMSG_CTL_SHOW_PEERS:
			cnt = 0;
			TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
				build_show_peer(&c_peer, p);
				imsg_compose(&c->ibuf, IMSG_CTL_SHOW_PEERS,
				    0, 0, -1, &c_peer, sizeof(c_peer));
				cnt++;
			}
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_PEERS_END,
			    0, 0, -1, &cnt, sizeof(cnt));
			break;
		case IMSG_CTL_SHOW_SENSORS:
			cnt = 0;
			TAILQ_FOREACH(s, &conf->ntp_sensors, entry) {
				build_show_sensor(&c_sensor, s);
				imsg_compose(&c->ibuf, IMSG_CTL_SHOW_SENSORS,
				    0, 0, -1, &c_sensor, sizeof(c_sensor));
			cnt++;
			}
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_SENSORS_END,
			    0, 0, -1, &cnt, sizeof(cnt));
			break;
		case IMSG_CTL_SHOW_ALL:
			build_show_status(&c_status);
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_STATUS, 0, 0, -1,
			    &c_status, sizeof (c_status));

			cnt = 0;
			TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
				build_show_peer(&c_peer, p);
				imsg_compose(&c->ibuf, IMSG_CTL_SHOW_PEERS,
				    0, 0, -1, &c_peer, sizeof(c_peer));
				cnt++;
			}
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_PEERS_END,
			    0, 0, -1, &cnt, sizeof(cnt));

			cnt = 0;
			TAILQ_FOREACH(s, &conf->ntp_sensors, entry) {
				build_show_sensor(&c_sensor, s);
				imsg_compose(&c->ibuf, IMSG_CTL_SHOW_SENSORS,
				    0, 0, -1, &c_sensor, sizeof(c_sensor));
			cnt++;
			}
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_SENSORS_END,
			    0, 0, -1, &cnt, sizeof(cnt));

			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_ALL_END,
			    0, 0, -1, NULL, 0);
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}
	return (0);
}

void
session_socket_nonblockmode(int fd)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL)) == -1)
		fatal("fcntl F_GETFL");

	flags |= O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
}

void
build_show_status(struct ctl_show_status *cs)
{
	struct ntp_peer		*p;
	struct ntp_sensor	*s;

	cs->peercnt = cs->valid_peers = 0;
	cs->sensorcnt = cs->valid_sensors = 0;

	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		cs->peercnt++;
		if (p->trustlevel >= TRUSTLEVEL_BADPEER)
			cs->valid_peers++;
	}
	TAILQ_FOREACH(s, &conf->ntp_sensors, entry) {
		cs->sensorcnt++;
		if (s->update.good)
			cs->valid_sensors++;
	}

	cs->synced = conf->status.synced;
	cs->stratum = conf->status.stratum;
	cs->clock_offset = getoffset() * 1000.0;
	cs->constraint_median = conf->constraint_median;
	cs->constraint_last = conf->constraint_last;
	cs->constraint_errors = conf->constraint_errors;
}

void
build_show_peer(struct ctl_show_peer *cp, struct ntp_peer *p)
{
	const char	*a = "not resolved";
	const char	*pool = "", *addr_head_name = "";
	u_int8_t	 shift, best, validdelaycnt, jittercnt;
	time_t		 now;

	now = getmonotime();

	if (p->addr)
		a = log_sockaddr((struct sockaddr *)&p->addr->ss);
	if (p->addr_head.pool)
		pool = "from pool ";

	if (0 != strcmp(a, p->addr_head.name))
		addr_head_name = p->addr_head.name;

	snprintf(cp->peer_desc, sizeof(cp->peer_desc),
	    "%s %s%s", a, pool, addr_head_name);

	validdelaycnt = best = 0;
	cp->offset = cp->delay = 0.0;
	for (shift = 0; shift < OFFSET_ARRAY_SIZE; shift++) {
		if (p->reply[shift].delay > 0.0) {
			cp->offset += p->reply[shift].offset;
			cp->delay += p->reply[shift].delay;

			if (p->reply[shift].delay < p->reply[best].delay)
				best = shift;

			validdelaycnt++;
		}
	}

	if (validdelaycnt > 1) {
		cp->offset /= validdelaycnt;
		cp->delay /= validdelaycnt;
	}

	jittercnt = 0;
	cp->jitter = 0.0;
	for (shift = 0; shift < OFFSET_ARRAY_SIZE; shift++) {
		if (p->reply[shift].delay > 0.0 && shift != best) {
			cp->jitter += square(p->reply[shift].delay -
			    p->reply[best].delay);
			jittercnt++;
		}
	}
	if (jittercnt > 1)
		cp->jitter /= jittercnt;
	cp->jitter = sqrt(cp->jitter);

	if (p->shift == 0)
		shift = OFFSET_ARRAY_SIZE - 1;
	else
		shift = p->shift - 1;

	if (conf->status.synced == 1 &&
	    p->reply[shift].status.send_refid == conf->status.refid)
		cp->syncedto = 1;
	else
		cp->syncedto = 0;

	/* milliseconds to reduce number of leading zeroes */
	cp->offset *= 1000.0;
	cp->delay *= 1000.0;
	cp->jitter *= 1000.0;

	cp->weight = p->weight;
	cp->trustlevel = p->trustlevel;
	cp->stratum = p->reply[shift].status.stratum;
	cp->next = p->next - now < 0 ? 0 : p->next - now;
	cp->poll = p->poll;
}

void
build_show_sensor(struct ctl_show_sensor *cs, struct ntp_sensor *s)
{
	time_t		 now;
	u_int8_t	 shift;
	u_int32_t	 refid;

	now = getmonotime();

	memcpy(&refid, SENSOR_DEFAULT_REFID, sizeof(refid));
	refid = refid == s->refid ? 0 : s->refid;

	snprintf(cs->sensor_desc, sizeof(cs->sensor_desc),
	    "%s  %.4s", s->device, (char *)&refid);

	if (s->shift == 0)
		shift = SENSOR_OFFSETS - 1;
	else
		shift = s->shift - 1;

	if (conf->status.synced == 1 &&
	    s->offsets[shift].status.send_refid == conf->status.refid)
		cs->syncedto = 1;
	else
		cs->syncedto = 0;

	cs->weight = s->weight;
	cs->good = s->update.good;
	cs->stratum = s->offsets[shift].status.stratum;
	cs->next = s->next - now < 0 ? 0 : s->next - now;
	cs->poll = SENSOR_QUERY_INTERVAL;
	cs->offset = s->offsets[shift].offset * 1000.0;
	cs->correction = (double)s->correction / 1000.0;
}
@


1.11
log
@Teach ntpd(8) how to fork+exec.

ok reyk@@, bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2016/03/27 11:16:12 krw Exp $ */
d145 4
a148 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
@


1.10
log
@Rename session_socket_blockmode() to session_socket_nonblockmode(),
removing its second parameter and the enum() that provided the
values for said parameter.

The function was only called with the second parameter set to one
value (BM_NONBLOCKING) from the enum(). So just do the right thing.
Similar to changes made in smtpd.

While here remove the pointless third parameter from the fcntl(F_GETFL)
call.

No functional change.

ok guenther@@ bcook@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2015/12/05 13:12:16 claudio Exp $ */
d46 1
a46 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
@


1.9
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2015/11/20 18:53:42 tedu Exp $ */
d80 1
a80 1
	session_socket_blockmode(fd, BM_NONBLOCK);
d125 1
a125 1
	session_socket_blockmode(connfd, BM_NONBLOCK);
d276 1
a276 1
session_socket_blockmode(int fd, enum blockmodes bm)
d280 1
a280 1
	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
d283 1
a283 4
	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;
@


1.8
log
@use RMS for jitter. we're linking with enough libraries that libm is tiny.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2015/10/23 14:52:20 phessler Exp $ */
d198 1
a198 1
	if ((n = imsg_read(&c->ibuf)) == -1 || n == 0) {
@


1.7
log
@Allowing upstream servers of ntp being in multiple routing tables is
non-sensical.  The dns lookups happened in the process routing table
(usually '0'), which is very likely to have different results from the
other routing domains.  If you do depend on having this behaviour,
you'll need to use pf to cross the rtable boundary.

"listen on * rtable X" is still supported.

Users of "server * rtable X" will need to switch to launching ntpd with
"route -T X exec /usr/sbin/ntpd"

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2015/07/18 00:53:44 bcook Exp $ */
d25 1
d37 2
a359 4
	/*
	 *  use simple average for jitter calculation, as the
	 *  RFC5905-recommended RMS average needs the math library
	 */
d364 2
a365 2
			cp->jitter += p->reply[shift].delay -
			    p->reply[best].delay;
d371 1
@


1.6
log
@replace bzero with memset

ok phessler@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2015/02/10 06:40:08 reyk Exp $ */
d336 1
a336 2
	    "%s %s%s %s", a, pool, addr_head_name,
	    print_rtable(p->rtable) );
@


1.5
log
@Add support for "constraints": when configured, ntpd(8) will query the
time from HTTPS servers, by parsing the Date: header, and use the
median constraint time as a boundary to verify NTP responses.  This
adds some level of authentication and protection against MITM attacks
while preserving the accuracy of the NTP protocol; without relying on
authentication options for NTP that are basically unavailable at
present.  This is an initial implementation and the semantics will be
improved once it is in the tree.

Discussed with deraadt@@ and henning@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2015/01/09 07:35:37 deraadt Exp $ */
d48 1
a48 1
	bzero(&sa, sizeof(sa));
@


1.4
log
@remove excessive/wrong use of sys/param.h
peanuts -- but all work has to start somewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2015/01/04 01:24:43 bcook Exp $ */
d312 3
@


1.3
log
@rename sockaddr_un variables from 'sun' to the more common 'sa'.

This avoids a namespace conflict with Solaris build environments.

discussed with deraadt@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2013/11/13 20:44:39 benno Exp $ */
d173 2
a174 2
	struct ntp_peer 	*p;
	struct ntp_sensor 	*s;
d292 2
a293 2
	struct ntp_peer 	*p;
	struct ntp_sensor 	*s;
d317 3
a319 3
	const char 	*a = "not resolved";
	const char 	*pool = "", *addr_head_name = "";
	u_int8_t 	 shift, best, validdelaycnt, jittercnt;
d398 1
a398 1
	u_int8_t 	 shift;
@


1.2
log
@from sthen: handle msgbuf_write() returning EAGAIN

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2013/10/04 14:28:16 phessler Exp $ */
d39 1
a39 1
	struct sockaddr_un	 sun;
d48 4
a51 4
	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, path, sizeof(sun.sun_path)) >=
	    sizeof(sun.sun_path))
d62 1
a62 1
	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
d111 1
a111 1
	struct sockaddr_un	 sun;
d114 1
a114 1
	len = sizeof(sun);
d116 1
a116 1
	    (struct sockaddr *)&sun, &len)) == -1) {
@


1.1
log
@Add ntpctl(8), which allows us to query the locally running ntpd(8) process

diff from Mike Miller <mmiller mgm51 com> (many thanks!)

OK phessler@@, henning@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.70 2010/10/29 12:51:53 henning Exp $ */
d187 1
a187 1
		if (msgbuf_write(&c->ibuf.w) < 0) {
@

