head	1.35;
access;
symbols
	OPENBSD_6_1:1.35.0.2
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.35
date	2016.12.05.10.41.33;	author rzalamena;	state Exp;
branches;
next	1.34;
commitid	o7qzMC1dBaqVkNqw;

1.34
date	2016.10.18.22.05.47;	author rzalamena;	state Exp;
branches;
next	1.33;
commitid	zKFzriY8JP5LHjbQ;

1.33
date	2016.10.18.21.57.19;	author rzalamena;	state Exp;
branches;
next	1.32;
commitid	tsEcAetLRYCJYjj4;

1.32
date	2016.09.26.17.17.01;	author rzalamena;	state Exp;
branches;
next	1.31;
commitid	BmpOnKpM0apagYju;

1.31
date	2016.09.14.09.26.10;	author reyk;	state Exp;
branches;
next	1.30;
commitid	laVgtK8SKgBmwNLX;

1.30
date	2016.07.13.16.35.47;	author jsing;	state Exp;
branches;
next	1.29;
commitid	02rKn2WBJ6A1ygkh;

1.29
date	2016.06.01.16.35.58;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	QPS7FNk0dKs9wtjO;

1.28
date	2016.05.21.13.46.10;	author jsing;	state Exp;
branches;
next	1.27;
commitid	EtZnbMSVngMVarTE;

1.27
date	2016.05.06.16.49.46;	author jsing;	state Exp;
branches;
next	1.26;
commitid	RY9ZD29SKjUhqQDA;

1.26
date	2016.03.05.16.09.20;	author naddy;	state Exp;
branches;
next	1.25;
commitid	9XBF1WK8MS7uyOLR;

1.25
date	2016.01.27.21.48.34;	author reyk;	state Exp;
branches;
next	1.24;
commitid	KTDuqL1fW4bPtfRB;

1.24
date	2015.12.19.17.55.29;	author reyk;	state Exp;
branches;
next	1.23;
commitid	xe8YS3ftA7mmBwbB;

1.23
date	2015.12.05.13.12.16;	author claudio;	state Exp;
branches;
next	1.22;
commitid	1u4z6EiD1xQ1Wwbx;

1.22
date	2015.11.24.01.03.25;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	w82qmLlikEZFzR4v;

1.21
date	2015.11.19.21.32.53;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	5eZwzlxhGA7nTpwJ;

1.20
date	2015.11.17.15.34.36;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	MwMDdrKLXrv3gKVb;

1.19
date	2015.10.12.06.50.08;	author reyk;	state Exp;
branches;
next	1.18;
commitid	to5fPpeGvAbrgkr0;

1.18
date	2015.10.09.03.50.40;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Vycbd8YM757pFEWU;

1.17
date	2015.09.10.13.49.48;	author beck;	state Exp;
branches;
next	1.16;
commitid	7ggJj8HvN1GDoB6O;

1.16
date	2015.09.10.10.34.19;	author beck;	state Exp;
branches;
next	1.15;
commitid	YSQm0Ngyp6KUrbM2;

1.15
date	2015.09.09.15.05.58;	author millert;	state Exp;
branches;
next	1.14;
commitid	9lNaAs0rHIIHE3va;

1.14
date	2015.07.18.21.50.47;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	XU2CN0CcxASWQp5F;

1.13
date	2015.07.18.20.32.38;	author bcook;	state Exp;
branches;
next	1.12;
commitid	LoNifX0LSHJeGOZO;

1.12
date	2015.05.28.21.34.36;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	QmomnssoMjXb5jD3;

1.11
date	2015.05.21.14.24.43;	author reyk;	state Exp;
branches;
next	1.10;
commitid	RwaJvF34s7PWSzxt;

1.10
date	2015.05.18.14.19.23;	author reyk;	state Exp;
branches;
next	1.9;
commitid	3wCmhYbs1i10QWHm;

1.9
date	2015.05.17.18.31.32;	author reyk;	state Exp;
branches;
next	1.8;
commitid	aCSIV6rNWhdw3L8D;

1.8
date	2015.04.21.01.49.19;	author jsg;	state Exp;
branches;
next	1.7;
commitid	IKG9cz7NX4JtGNqA;

1.7
date	2015.03.14.05.10.11;	author bcook;	state Exp;
branches;
next	1.6;
commitid	ymOQivc2QkWU5VRu;

1.6
date	2015.02.22.15.09.54;	author jsing;	state Exp;
branches;
next	1.5;
commitid	lRyL0pnPfoLbeA76;

1.5
date	2015.02.22.14.55.41;	author jsing;	state Exp;
branches;
next	1.4;
commitid	qDSb6EAJHuZKbiwf;

1.4
date	2015.02.12.01.54.57;	author reyk;	state Exp;
branches;
next	1.3;
commitid	eJZFYJXXt9fmfGXk;

1.3
date	2015.02.10.23.52.41;	author reyk;	state Exp;
branches;
next	1.2;
commitid	cyGnApG7mGLcc3PN;

1.2
date	2015.02.10.11.36.37;	author reyk;	state Exp;
branches;
next	1.1;
commitid	2z3GeEhM6jXQJBzY;

1.1
date	2015.02.10.06.40.08;	author reyk;	state Exp;
branches;
next	;
commitid	pXoTR74Ztt0R3SV0;


desc
@@


1.35
log
@Use the stack to hold the constraint child process variables instead of
using the heap.

ok bcook@@
@
text
@/*	$OpenBSD: constraint.c,v 1.34 2016/10/18 22:05:47 rzalamena Exp $	*/

/*
 * Copyright (c) 2015 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <imsg.h>
#include <netdb.h>
#include <poll.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <ctype.h>
#include <tls.h>
#include <pwd.h>

#include "ntpd.h"

int	 constraint_addr_init(struct constraint *);
struct constraint *
	 constraint_byid(u_int32_t);
struct constraint *
	 constraint_byfd(int);
struct constraint *
	 constraint_bypid(pid_t);
int	 constraint_close(u_int32_t);
void	 constraint_update(void);
void	 constraint_reset(void);
int	 constraint_cmp(const void *, const void *);

void	 priv_constraint_close(int, int);
void	 priv_constraint_readquery(struct constraint *, struct ntp_addr_msg *,
	    uint8_t **);

struct httpsdate *
	 httpsdate_init(const char *, const char *, const char *,
	    const char *, const u_int8_t *, size_t);
void	 httpsdate_free(void *);
int	 httpsdate_request(struct httpsdate *, struct timeval *);
void	*httpsdate_query(const char *, const char *, const char *,
	    const char *, const u_int8_t *, size_t,
	    struct timeval *, struct timeval *);

char	*tls_readline(struct tls *, size_t *, size_t *, struct timeval *);

u_int constraint_cnt;
extern u_int peer_cnt;
extern struct imsgbuf *ibuf;		/* priv */
extern struct imsgbuf *ibuf_main;	/* chld */

struct httpsdate {
	char			*tls_addr;
	char			*tls_port;
	char			*tls_hostname;
	char			*tls_path;
	char			*tls_request;
	struct tls_config	*tls_config;
	struct tls		*tls_ctx;
	struct tm		 tls_tm;
};

int
constraint_init(struct constraint *cstr)
{
	cstr->state = STATE_NONE;
	cstr->fd = -1;
	cstr->last = getmonotime();
	cstr->constraint = 0;
	cstr->senderrors = 0;

	return (constraint_addr_init(cstr));
}

int
constraint_addr_init(struct constraint *cstr)
{
	struct sockaddr_in	*sa_in;
	struct sockaddr_in6	*sa_in6;
	struct ntp_addr		*h;

	if (cstr->state == STATE_DNS_INPROGRESS)
		return (0);

	if (cstr->addr_head.a == NULL) {
		priv_dns(IMSG_CONSTRAINT_DNS, cstr->addr_head.name, cstr->id);
		cstr->state = STATE_DNS_INPROGRESS;
		return (0);
	}

	h = cstr->addr;
	switch (h->ss.ss_family) {
	case AF_INET:
		sa_in = (struct sockaddr_in *)&h->ss;
		if (ntohs(sa_in->sin_port) == 0)
			sa_in->sin_port = htons(443);
		cstr->state = STATE_DNS_DONE;
		break;
	case AF_INET6:
		sa_in6 = (struct sockaddr_in6 *)&h->ss;
		if (ntohs(sa_in6->sin6_port) == 0)
			sa_in6->sin6_port = htons(443);
		cstr->state = STATE_DNS_DONE;
		break;
	default:
		/* XXX king bula sez it? */
		fatalx("wrong AF in constraint_addr_init");
		/* NOTREACHED */
	}

	return (1);
}

int
constraint_query(struct constraint *cstr)
{
	time_t			 now;
	struct ntp_addr_msg	 am;
	struct iovec		 iov[3];
	int			 iov_cnt = 0;

	now = getmonotime();

	switch (cstr->state) {
	case STATE_DNS_DONE:
		/* Proceed and query the time */
		break;
	case STATE_DNS_TEMPFAIL:
		/* Retry resolving the address */
		constraint_init(cstr);
		return (-1);
	case STATE_QUERY_SENT:
		if (cstr->last + CONSTRAINT_SCAN_TIMEOUT > now) {
			/* The caller should expect a reply */
			return (0);
		}

		/* Timeout, just kill the process to reset it. */
		imsg_compose(ibuf_main, IMSG_CONSTRAINT_KILL,
		    cstr->id, 0, -1, NULL, 0);

		cstr->state = STATE_TIMEOUT;
		return (-1);
	case STATE_INVALID:
		if (cstr->last + CONSTRAINT_SCAN_INTERVAL > now) {
			/* Nothing to do */
			return (-1);
		}

		/* Reset and retry */
		cstr->senderrors = 0;
		constraint_close(cstr->id);
		break;
	case STATE_REPLY_RECEIVED:
	default:
		/* Nothing to do */
		return (-1);
	}

	cstr->last = now;
	cstr->state = STATE_QUERY_SENT;

	memset(&am, 0, sizeof(am));
	memcpy(&am.a, cstr->addr, sizeof(am.a));

	iov[iov_cnt].iov_base = &am;
	iov[iov_cnt++].iov_len = sizeof(am);
	if (cstr->addr_head.name) {
		am.namelen = strlen(cstr->addr_head.name) + 1;
		iov[iov_cnt].iov_base = cstr->addr_head.name;
		iov[iov_cnt++].iov_len = am.namelen;
	}
	if (cstr->addr_head.path) {
		am.pathlen = strlen(cstr->addr_head.path) + 1;
		iov[iov_cnt].iov_base = cstr->addr_head.path;
		iov[iov_cnt++].iov_len = am.pathlen;
	}

	imsg_composev(ibuf_main, IMSG_CONSTRAINT_QUERY,
	    cstr->id, 0, -1, iov, iov_cnt);

	return (0);
}

void
priv_constraint_msg(u_int32_t id, u_int8_t *data, size_t len, int argc,
    char **argv)
{
	struct ntp_addr_msg	 am;
	struct ntp_addr		*h;
	struct constraint	*cstr;
	int			 pipes[2];
	int			 rv;

	if ((cstr = constraint_byid(id)) != NULL) {
		log_warnx("IMSG_CONSTRAINT_QUERY repeated for id %d", id);
		return;
	}

	if (len < sizeof(am)) {
		log_warnx("invalid IMSG_CONSTRAINT_QUERY received");
		return;
	}
	memcpy(&am, data, sizeof(am));
	if (len != (sizeof(am) + am.namelen + am.pathlen)) {
		log_warnx("invalid IMSG_CONSTRAINT_QUERY received");
		return;
	}
	/* Additional imsg data is obtained in the unpriv child */

	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal("calloc ntp_addr");
	memcpy(h, &am.a, sizeof(*h));
	h->next = NULL;

	cstr = new_constraint();
	cstr->id = id;
	cstr->addr = h;
	cstr->addr_head.a = h;
	constraint_add(cstr);
	constraint_cnt++;

	if (socketpair(AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, AF_UNSPEC,
	    pipes) == -1)
		fatal("%s pipes", __func__);

	/* Prepare and send constraint data to child. */
	cstr->fd = pipes[0];
	imsg_init(&cstr->ibuf, cstr->fd);
	if (imsg_compose(&cstr->ibuf, IMSG_CONSTRAINT_QUERY, id, 0, -1,
	    data, len) == -1)
		fatal("%s: imsg_compose", __func__);
	do {
		rv = imsg_flush(&cstr->ibuf);
	} while (rv == -1 && errno == EAGAIN);
	if (rv == -1)
		fatal("imsg_flush");

	/*
	 * Fork child handlers and make sure to do any sensitive work in the
	 * the (unprivileged) child.  The parent should not do any parsing,
	 * certificate loading etc.
	 */
	cstr->pid = start_child(CONSTRAINT_PROC_NAME, pipes[1], argc, argv);
}

void
priv_constraint_readquery(struct constraint *cstr, struct ntp_addr_msg *am,
    uint8_t **data)
{
	struct ntp_addr		*h;
	uint8_t			*dptr;
	int			 n;
	struct imsg		 imsg;
	size_t			 mlen;

	/* Read the message our parent left us. */
	if (((n = imsg_read(&cstr->ibuf)) == -1 && errno != EAGAIN) || n == 0)
		fatal("%s: imsg_read", __func__);
	if (((n = imsg_get(&cstr->ibuf, &imsg)) == -1) || n == 0)
		fatal("%s: imsg_get", __func__);
	if (imsg.hdr.type != IMSG_CONSTRAINT_QUERY)
		fatalx("%s: invalid message type", __func__);

	/*
	 * Copy the message contents just like our father:
	 * priv_constraint_msg().
	 */
	mlen = imsg.hdr.len - IMSG_HEADER_SIZE;
	if (mlen < sizeof(*am))
		fatalx("%s: mlen < sizeof(*am)", __func__);

	memcpy(am, imsg.data, sizeof(*am));
	if (mlen != (sizeof(*am) + am->namelen + am->pathlen))
		fatalx("%s: mlen < sizeof(*am) + am->namelen + am->pathlen",
		    __func__);

	if ((h = calloc(1, sizeof(*h))) == NULL ||
	    (*data = calloc(1, mlen)) == NULL)
		fatal("%s: calloc", __func__);

	memcpy(h, &am->a, sizeof(*h));
	h->next = NULL;

	cstr->id = imsg.hdr.peerid;
	cstr->addr = h;
	cstr->addr_head.a = h;

	dptr = imsg.data;
	memcpy(*data, dptr + sizeof(*am), mlen - sizeof(*am));
	imsg_free(&imsg);
}

void
priv_constraint_child(const char *pw_dir, uid_t pw_uid, gid_t pw_gid)
{
	struct constraint	 cstr;
	struct ntp_addr_msg	 am;
	uint8_t			*data;
	static char		 addr[NI_MAXHOST];
	struct timeval		 rectv, xmttv;
	struct sigaction	 sa;
	void			*ctx;
	struct iovec		 iov[2];
	int			 i, rv;

	log_procinit("constraint");

	if (setpriority(PRIO_PROCESS, 0, 0) == -1)
		log_warn("could not set priority");

	/* Init TLS and load CA certs before chroot() */
	if (tls_init() == -1)
		fatalx("tls_init");
	if ((conf->ca = tls_load_file(CONSTRAINT_CA,
	    &conf->ca_len, NULL)) == NULL)
		fatalx("failed to load constraint ca");

	if (chroot(pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	if (setgroups(1, &pw_gid) ||
	    setresgid(pw_gid, pw_gid, pw_gid) ||
	    setresuid(pw_uid, pw_uid, pw_uid))
		fatal("can't drop privileges");

	/* Reset all signal handlers */
	memset(&sa, 0, sizeof(sa));
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	for (i = 1; i < _NSIG; i++)
		sigaction(i, &sa, NULL);

	if (pledge("stdio inet", NULL) == -1)
		fatal("pledge");

	cstr.fd = CONSTRAINT_PASSFD;
	imsg_init(&cstr.ibuf, cstr.fd);
	priv_constraint_readquery(&cstr, &am, &data);

	/*
	 * Get the IP address as name and set the process title accordingly.
	 * This only converts an address into a string and does not trigger
	 * any DNS operation, so it is safe to be called without the dns
	 * pledge.
	 */
	if (getnameinfo((struct sockaddr *)&cstr.addr->ss,
	    SA_LEN((struct sockaddr *)&cstr.addr->ss),
	    addr, sizeof(addr), NULL, 0,
	    NI_NUMERICHOST) != 0)
		fatalx("%s getnameinfo", __func__);

	log_debug("constraint request to %s", addr);
	setproctitle("constraint from %s", addr);
	(void)closefrom(CONSTRAINT_PASSFD + 1);

	/*
	 * Set the close-on-exec flag to prevent leaking the communication
	 * channel to any exec'ed child.  In theory this could never happen,
	 * constraints don't exec children and pledge() prevents it,
	 * but we keep it as a safety belt; especially for portability.
	 */
	if (fcntl(CONSTRAINT_PASSFD, F_SETFD, FD_CLOEXEC) == -1)
		fatal("%s fcntl F_SETFD", __func__);

	/* Get remaining data from imsg in the unpriv child */
	if (am.namelen) {
		if ((cstr.addr_head.name =
		    get_string(data, am.namelen)) == NULL)
			fatalx("invalid IMSG_CONSTRAINT_QUERY name");
		data += am.namelen;
	}
	if (am.pathlen) {
		if ((cstr.addr_head.path =
		    get_string(data, am.pathlen)) == NULL)
			fatalx("invalid IMSG_CONSTRAINT_QUERY path");
	}

	/* Run! */
	if ((ctx = httpsdate_query(addr,
	    CONSTRAINT_PORT, cstr.addr_head.name, cstr.addr_head.path,
	    conf->ca, conf->ca_len, &rectv, &xmttv)) == NULL) {
		/* Abort with failure but without warning */
		exit(1);
	}

	iov[0].iov_base = &rectv;
	iov[0].iov_len = sizeof(rectv);
	iov[1].iov_base = &xmttv;
	iov[1].iov_len = sizeof(xmttv);
	imsg_composev(&cstr.ibuf,
	    IMSG_CONSTRAINT_RESULT, 0, 0, -1, iov, 2);
	do {
		rv = imsg_flush(&cstr.ibuf);
	} while (rv == -1 && errno == EAGAIN);

	/* Tear down the TLS connection after sending the result */
	httpsdate_free(ctx);

	exit(0);
}

void
priv_constraint_check_child(pid_t pid, int status)
{
	struct constraint	*cstr;
	int			 fail, sig;
	char			*signame;

	fail = sig = 0;
	if (WIFSIGNALED(status)) {
		sig = WTERMSIG(status);
	} else if (WIFEXITED(status)) {
		if (WEXITSTATUS(status) != 0)
			fail = 1;
	} else
		fatalx("unexpected cause of SIGCHLD");

	if ((cstr = constraint_bypid(pid)) != NULL) {
		if (sig) {
			if (sig != SIGTERM) {
				signame = strsignal(sig) ?
				    strsignal(sig) : "unknown";
				log_warnx("constraint %s; "
				    "terminated with signal %d (%s)",
				    log_sockaddr((struct sockaddr *)
				    &cstr->addr->ss), sig, signame);
			}
			fail = 1;
		}

		priv_constraint_close(cstr->fd, fail);
	}
}

void
priv_constraint_kill(u_int32_t id)
{
	struct constraint	*cstr;

	if ((cstr = constraint_byid(id)) == NULL) {
		log_warnx("IMSG_CONSTRAINT_KILL for invalid id %d", id);
		return;
	}

	kill(cstr->pid, SIGTERM);
}

struct constraint *
constraint_byid(u_int32_t id)
{
	struct constraint	*cstr;

	TAILQ_FOREACH(cstr, &conf->constraints, entry) {
		if (cstr->id == id)
			return (cstr);
	}

	return (NULL);
}

struct constraint *
constraint_byfd(int fd)
{
	struct constraint	*cstr;

	TAILQ_FOREACH(cstr, &conf->constraints, entry) {
		if (cstr->fd == fd)
			return (cstr);
	}

	return (NULL);
}

struct constraint *
constraint_bypid(pid_t pid)
{
	struct constraint	*cstr;

	TAILQ_FOREACH(cstr, &conf->constraints, entry) {
		if (cstr->pid == pid)
			return (cstr);
	}

	return (NULL);
}

int
constraint_close(u_int32_t id)
{
	struct constraint	*cstr;

	if ((cstr = constraint_byid(id)) == NULL) {
		log_warn("%s: id %d: not found", __func__, id);
		return (0);
	}

	cstr->last = getmonotime();

	if (cstr->addr == NULL || (cstr->addr = cstr->addr->next) == NULL) {
		/* Either a pool or all addresses have been tried */
		cstr->addr = cstr->addr_head.a;
		if (cstr->senderrors)
			cstr->state = STATE_INVALID;
		else if (cstr->state >= STATE_QUERY_SENT)
			cstr->state = STATE_DNS_DONE;

		return (1);
	}

	/* Go on and try the next resolved address for this constraint */
	return (constraint_init(cstr));
}

void
priv_constraint_close(int fd, int fail)
{
	struct constraint	*cstr;
	u_int32_t		 id;

	if ((cstr = constraint_byfd(fd)) == NULL) {
		log_warn("%s: fd %d: not found", __func__, fd);
		return;
	}

	id = cstr->id;
	constraint_remove(cstr);
	constraint_cnt--;

	imsg_compose(ibuf, IMSG_CONSTRAINT_CLOSE, id, 0, -1,
	    &fail, sizeof(fail));
}

void
constraint_add(struct constraint *cstr)
{
	TAILQ_INSERT_TAIL(&conf->constraints, cstr, entry);
}

void
constraint_remove(struct constraint *cstr)
{
	TAILQ_REMOVE(&conf->constraints, cstr, entry);

	msgbuf_clear(&cstr->ibuf.w);
	if (cstr->fd != -1)
		close(cstr->fd);
	free(cstr->addr_head.name);
	free(cstr->addr_head.path);
	free(cstr->addr);
	free(cstr);
}

void
constraint_purge(void)
{
	struct constraint	*cstr, *ncstr;

	TAILQ_FOREACH_SAFE(cstr, &conf->constraints, entry, ncstr)
		constraint_remove(cstr);
}

int
priv_constraint_dispatch(struct pollfd *pfd)
{
	struct imsg		 imsg;
	struct constraint	*cstr;
	ssize_t			 n;
	struct timeval		 tv[2];

	if ((cstr = constraint_byfd(pfd->fd)) == NULL)
		return (0);

	if (!(pfd->revents & POLLIN))
		return (0);

	if (((n = imsg_read(&cstr->ibuf)) == -1 && errno != EAGAIN) || n == 0) {
		priv_constraint_close(pfd->fd, 1);
		return (1);
	}

	for (;;) {
		if ((n = imsg_get(&cstr->ibuf, &imsg)) == -1) {
			priv_constraint_close(pfd->fd, 1);
			return (1);
		}
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CONSTRAINT_RESULT:
			 if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(tv))
				fatalx("invalid IMSG_CONSTRAINT received");

			/* forward imsg to ntp child, don't parse it here */
			imsg_compose(ibuf, imsg.hdr.type,
			    cstr->id, 0, -1, imsg.data, sizeof(tv));
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}

	return (0);
}

void
constraint_msg_result(u_int32_t id, u_int8_t *data, size_t len)
{
	struct constraint	*cstr;
	struct timeval		 tv[2];
	double			 offset;

	if ((cstr = constraint_byid(id)) == NULL) {
		log_warnx("IMSG_CONSTRAINT_CLOSE with invalid constraint id");
		return;
	}

	if (len != sizeof(tv)) {
		log_warnx("invalid IMSG_CONSTRAINT received");
		return;
	}

	memcpy(tv, data, len);

	offset = gettime_from_timeval(&tv[0]) -
	    gettime_from_timeval(&tv[1]);

	log_info("constraint reply from %s: offset %f",
	    log_sockaddr((struct sockaddr *)&cstr->addr->ss),
	    offset);

	cstr->state = STATE_REPLY_RECEIVED;
	cstr->last = getmonotime();
	cstr->constraint = tv[0].tv_sec;

	constraint_update();
}

void
constraint_msg_close(u_int32_t id, u_int8_t *data, size_t len)
{
	struct constraint	*cstr;
	int			 fail;

	if ((cstr = constraint_byid(id)) == NULL) {
		log_warnx("IMSG_CONSTRAINT_CLOSE with invalid constraint id");
		return;
	}

	if (len != sizeof(int)) {
		log_warnx("invalid IMSG_CONSTRAINT_CLOSE received");
		return;
	}

	memcpy(&fail, data, len);

	if (fail) {
		log_debug("no constraint reply from %s"
		    " received in time, next query %ds",
		    log_sockaddr((struct sockaddr *)
		    &cstr->addr->ss), CONSTRAINT_SCAN_INTERVAL);
	}

	if (fail || cstr->state < STATE_QUERY_SENT) {
		cstr->senderrors++;
		constraint_close(cstr->id);
	}
}

void
constraint_msg_dns(u_int32_t id, u_int8_t *data, size_t len)
{
	struct constraint	*cstr, *ncstr = NULL;
	u_int8_t		*p;
	struct ntp_addr		*h;

	if ((cstr = constraint_byid(id)) == NULL) {
		log_warnx("IMSG_CONSTRAINT_DNS with invalid constraint id");
		return;
	}
	if (cstr->addr != NULL) {
		log_warnx("IMSG_CONSTRAINT_DNS but addr != NULL!");
		return;
	}
	if (len == 0) {
		log_debug("%s FAILED", __func__);
		cstr->state = STATE_DNS_TEMPFAIL;
		return;
	}

	if ((len % sizeof(struct sockaddr_storage)) != 0)
		fatalx("IMSG_CONSTRAINT_DNS len");

	p = data;
	do {
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal("calloc ntp_addr");
		memcpy(&h->ss, p, sizeof(h->ss));
		p += sizeof(h->ss);
		len -= sizeof(h->ss);

		if (ncstr == NULL || cstr->addr_head.pool) {
			ncstr = new_constraint();
			ncstr->addr = h;
			ncstr->addr_head.a = h;
			ncstr->addr_head.name = strdup(cstr->addr_head.name);
			ncstr->addr_head.path = strdup(cstr->addr_head.path);
			if (ncstr->addr_head.name == NULL ||
			    ncstr->addr_head.path == NULL)
				fatal("calloc name");
			ncstr->addr_head.pool = cstr->addr_head.pool;
			ncstr->state = STATE_DNS_DONE;
			constraint_add(ncstr);
			constraint_cnt += constraint_init(ncstr);
		} else {
			h->next = ncstr->addr;
			ncstr->addr = h;
			ncstr->addr_head.a = h;
		}
	} while (len);

	constraint_remove(cstr);
}

int
constraint_cmp(const void *a, const void *b)
{
	return (*(const time_t *)a - *(const time_t *)b);
}

void
constraint_update(void)
{
	struct constraint *cstr;
	int	 cnt, i;
	time_t	*sum;
	time_t	 now;

	now = getmonotime();

	cnt = 0;
	TAILQ_FOREACH(cstr, &conf->constraints, entry) {
		if (cstr->state != STATE_REPLY_RECEIVED)
			continue;
		cnt++;
	}

	if ((sum = calloc(cnt, sizeof(time_t))) == NULL)
		fatal("calloc");

	i = 0;
	TAILQ_FOREACH(cstr, &conf->constraints, entry) {
		if (cstr->state != STATE_REPLY_RECEIVED)
			continue;
		sum[i++] = cstr->constraint + (now - cstr->last);
	}

	qsort(sum, cnt, sizeof(time_t), constraint_cmp);

	/* calculate median */
	i = cnt / 2;
	if (cnt % 2 == 0)
		if (sum[i - 1] < sum[i])
			i -= 1;

	conf->constraint_last = now;
	conf->constraint_median = sum[i];

	free(sum);
}

void
constraint_reset(void)
{
	struct constraint *cstr;

	TAILQ_FOREACH(cstr, &conf->constraints, entry) {
		if (cstr->state == STATE_QUERY_SENT)
			continue;
		constraint_close(cstr->id);
	}
	conf->constraint_errors = 0;
}

int
constraint_check(double val)
{
	struct timeval	tv;
	double		constraint;
	time_t		now;

	if (conf->constraint_median == 0)
		return (0);

	/* Calculate the constraint with the current offset */
	now = getmonotime();
	tv.tv_sec = conf->constraint_median + (now - conf->constraint_last);
	tv.tv_usec = 0;
	constraint = gettime_from_timeval(&tv);

	if (((val - constraint) > CONSTRAINT_MARGIN) ||
	    ((constraint - val) > CONSTRAINT_MARGIN)) {
		/* XXX get new constraint if too many errors happened */
		if (conf->constraint_errors++ >
		    (CONSTRAINT_ERROR_MARGIN * peer_cnt)) {
			constraint_reset();
		}

		return (-1);
	}

	return (0);
}

struct httpsdate *
httpsdate_init(const char *addr, const char *port, const char *hostname,
    const char *path, const u_int8_t *ca, size_t ca_len)
{
	struct httpsdate	*httpsdate = NULL;

	if ((httpsdate = calloc(1, sizeof(*httpsdate))) == NULL)
		goto fail;

	if (hostname == NULL)
		hostname = addr;

	if ((httpsdate->tls_addr = strdup(addr)) == NULL ||
	    (httpsdate->tls_port = strdup(port)) == NULL ||
	    (httpsdate->tls_hostname = strdup(hostname)) == NULL ||
	    (httpsdate->tls_path = strdup(path)) == NULL)
		goto fail;

	if (asprintf(&httpsdate->tls_request,
	    "HEAD %s HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n",
	    httpsdate->tls_path, httpsdate->tls_hostname) == -1)
		goto fail;

	if ((httpsdate->tls_config = tls_config_new()) == NULL)
		goto fail;

	if (tls_config_set_ciphers(httpsdate->tls_config, "all") != 0)
		goto fail;

	if (ca == NULL || ca_len == 0)
		tls_config_insecure_noverifycert(httpsdate->tls_config);
	else
		tls_config_set_ca_mem(httpsdate->tls_config, ca, ca_len);

	return (httpsdate);

 fail:
	httpsdate_free(httpsdate);
	return (NULL);
}

void
httpsdate_free(void *arg)
{
	struct httpsdate *httpsdate = arg;
	if (httpsdate == NULL)
		return;
	if (httpsdate->tls_ctx)
		tls_close(httpsdate->tls_ctx);
	tls_free(httpsdate->tls_ctx);
	tls_config_free(httpsdate->tls_config);
	free(httpsdate->tls_addr);
	free(httpsdate->tls_port);
	free(httpsdate->tls_hostname);
	free(httpsdate->tls_path);
	free(httpsdate->tls_request);
	free(httpsdate);
}

int
httpsdate_request(struct httpsdate *httpsdate, struct timeval *when)
{
	size_t	 outlen = 0, maxlength = CONSTRAINT_MAXHEADERLENGTH, len;
	char	*line, *p, *buf;
	ssize_t	 ret;

	if ((httpsdate->tls_ctx = tls_client()) == NULL)
		goto fail;

	if (tls_configure(httpsdate->tls_ctx, httpsdate->tls_config) == -1)
		goto fail;

	/*
	 * libtls expects an address string, which can also be a DNS name,
	 * but we pass a pre-resolved IP address string in tls_addr so it
	 * does not trigger any DNS operation and is safe to be called
	 * without the dns pledge.
	 */
	if (tls_connect_servername(httpsdate->tls_ctx, httpsdate->tls_addr,
	    httpsdate->tls_port, httpsdate->tls_hostname) == -1) {
		log_debug("tls connect failed: %s (%s): %s",
		    httpsdate->tls_addr, httpsdate->tls_hostname,
		    tls_error(httpsdate->tls_ctx));
		goto fail;
	}

	buf = httpsdate->tls_request;
	len = strlen(httpsdate->tls_request);
	while (len > 0) {
		ret = tls_write(httpsdate->tls_ctx, buf, len);
		if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT)
			continue;
		if (ret < 0) {
			log_warnx("tls write failed: %s (%s): %s",
			    httpsdate->tls_addr, httpsdate->tls_hostname,
			    tls_error(httpsdate->tls_ctx));
			goto fail;
		}
		buf += ret;
		len -= ret;
	}

	while ((line = tls_readline(httpsdate->tls_ctx, &outlen,
	    &maxlength, when)) != NULL) {
		line[strcspn(line, "\r\n")] = '\0';

		if ((p = strchr(line, ' ')) == NULL || *p == '\0')
			goto next;
		*p++ = '\0';
		if (strcasecmp("Date:", line) != 0)
			goto next;

		/*
		 * Expect the date/time format as IMF-fixdate which is
		 * mandated by HTTP/1.1 in the new RFC 7231 and was
		 * preferred by RFC 2616.  Other formats would be RFC 850
		 * or ANSI C's asctime() - the latter doesn't include
		 * the timezone which is required here.
		 */
		if (strptime(p, "%a, %d %h %Y %T GMT",
		    &httpsdate->tls_tm) == NULL) {
			log_warnx("unsupported date format");
			free(line);
			return (-1);
		}

		free(line);
		break;
 next:
		free(line);
	}

	return (0);

 fail:
	httpsdate_free(httpsdate);
	return (-1);
}

void *
httpsdate_query(const char *addr, const char *port, const char *hostname,
    const char *path, const u_int8_t *ca, size_t ca_len,
    struct timeval *rectv, struct timeval *xmttv)
{
	struct httpsdate	*httpsdate;
	struct timeval		 when;
	time_t			 t;

	if ((httpsdate = httpsdate_init(addr, port, hostname, path,
	    ca, ca_len)) == NULL)
		return (NULL);

	if (httpsdate_request(httpsdate, &when) == -1)
		return (NULL);

	/* Return parsed date as local time */
	t = timegm(&httpsdate->tls_tm);

	/* Report parsed Date: as "received time" */
	rectv->tv_sec = t;
	rectv->tv_usec = 0;

	/* And add delay as "transmit time" */
	xmttv->tv_sec = when.tv_sec;
	xmttv->tv_usec = when.tv_usec;

	return (httpsdate);
}

/* Based on SSL_readline in ftp/fetch.c */
char *
tls_readline(struct tls *tls, size_t *lenp, size_t *maxlength,
    struct timeval *when)
{
	size_t i, len;
	char *buf, *q, c;
	ssize_t ret;

	len = 128;
	if ((buf = malloc(len)) == NULL)
		fatal("Can't allocate memory for transfer buffer");
	for (i = 0; ; i++) {
		if (i >= len - 1) {
			if ((q = reallocarray(buf, len, 2)) == NULL)
				fatal("Can't expand transfer buffer");
			buf = q;
			len *= 2;
		}
 again:
		ret = tls_read(tls, &c, 1);
		if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT)
			goto again;
		if (ret < 0) {
			/* SSL read error, ignore */
			free(buf);
			return (NULL);
		}

		if (maxlength != NULL && (*maxlength)-- == 0) {
			log_warnx("maximum length exceeded");
			free(buf);
			return (NULL);
		}

		buf[i] = c;
		if (c == '\n')
			break;
	}
	*lenp = i;
	if (gettimeofday(when, NULL) == -1)
		fatal("gettimeofday");
	return (buf);
}

char *
get_string(u_int8_t *ptr, size_t len)
{
	size_t	 i;

	for (i = 0; i < len; i++)
		if (!(isprint(ptr[i]) || isspace(ptr[i])))
			break;

	return strndup(ptr, i);
}
@


1.34
log
@Check for EAGAIN on imsg_flush() return otherwise we might be failing
to send message to the child process. Do like we learned in httpd(8).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.33 2016/10/18 21:57:19 rzalamena Exp $	*/
d324 2
a325 2
	struct constraint	*cstr;
	struct ntp_addr_msg	*am;
a338 4
	if ((cstr = calloc(1, sizeof(*cstr))) == NULL ||
	    (am = calloc(1, sizeof(*am))) == NULL)
		fatal("%s: calloc", __func__);

d367 3
a369 3
	cstr->fd = CONSTRAINT_PASSFD;
	imsg_init(&cstr->ibuf, cstr->fd);
	priv_constraint_readquery(cstr, am, &data);
d377 2
a378 2
	if (getnameinfo((struct sockaddr *)&cstr->addr->ss,
	    SA_LEN((struct sockaddr *)&cstr->addr->ss),
d397 3
a399 3
	if (am->namelen) {
		if ((cstr->addr_head.name =
		    get_string(data, am->namelen)) == NULL)
d401 1
a401 1
		data += am->namelen;
d403 3
a405 3
	if (am->pathlen) {
		if ((cstr->addr_head.path =
		    get_string(data, am->pathlen)) == NULL)
d411 1
a411 1
	    CONSTRAINT_PORT, cstr->addr_head.name, cstr->addr_head.path,
d421 1
a421 1
	imsg_composev(&cstr->ibuf,
d424 1
a424 1
		rv = imsg_flush(&cstr->ibuf);
@


1.33
log
@Save the constraint process pid by getting the start_child() return value,
this should fix the problem with random ntpd(8) deaths.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.32 2016/09/26 17:17:01 rzalamena Exp $	*/
d220 1
d260 5
a264 2
	if (imsg_flush(&cstr->ibuf) == -1)
		fatal("%s: imsg_flush", __func__);
d332 1
a332 1
	int			 i;
d427 3
a429 1
	imsg_flush(&cstr->ibuf);
@


1.32
log
@Teach ntpd(8) constraint process to use exec*() instead of just forking,
with this change we get the pledge() ability back to the parent process.

some tweaks from and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.31 2016/09/14 09:26:10 reyk Exp $	*/
d267 1
a267 1
	start_child(CONSTRAINT_PROC_NAME, pipes[1], argc, argv);
@


1.31
log
@Add clarifications ("comments") to three places where it wasn't
obvious why it is implemented this way.  The whole idea of constraints
is to isolate them as much as possible, in a semi-paranoid way.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.30 2016/07/13 16:35:47 jsing Exp $	*/
d60 2
a61 2
void	 priv_constraint_child(struct constraint *, struct ntp_addr_msg *,
	    u_int8_t *, int[2], const char *, uid_t, gid_t);
d213 2
a214 2
priv_constraint_msg(u_int32_t id, u_int8_t *data, size_t len,
    const char *pw_dir, uid_t pw_uid, gid_t pw_gid)
d249 2
a250 1
	if (socketpair(AF_UNIX, SOCK_DGRAM, AF_UNSPEC, pipes) == -1)
d253 9
d267 40
a306 9
	switch (cstr->pid = fork()) {
	case -1:
		cstr->senderrors++;
		close(pipes[0]);
		close(pipes[1]);
		return;
	case 0:
		priv_constraint_child(cstr, &am, data + sizeof(am), pipes,
		    pw_dir, pw_uid, pw_gid);
d308 3
a310 6
		_exit(0);
		/* NOTREACHED */
	default:
		/* Parent */
		close(pipes[1]);
		cstr->fd = pipes[0];
d312 3
a314 3
		imsg_init(&cstr->ibuf, cstr->fd);
		break;
	}
d318 1
a318 2
priv_constraint_child(struct constraint *cstr, struct ntp_addr_msg *am,
    u_int8_t *data, int pipes[2], const char *pw_dir, uid_t pw_uid, gid_t pw_gid)
d320 3
d335 4
d367 4
a384 8

	/* Set file descriptors */
	if (dup2(pipes[1], CONSTRAINT_PASSFD) == -1)
		fatal("%s dup2 CONSTRAINT_PASSFD", __func__);
	if (pipes[0] != CONSTRAINT_PASSFD)
		close(pipes[0]);
	if (pipes[1] != CONSTRAINT_PASSFD)
		close(pipes[1]);
a395 3
	cstr->fd = CONSTRAINT_PASSFD;
	imsg_init(&cstr->ibuf, cstr->fd);

d427 2
@


1.30
log
@Adjust existing tls_config_set_cipher() callers for TLS cipher group
changes - map the previous configuration to the equivalent in the new
groups. This will be revisited post release.

Discussed with beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.29 2016/06/01 16:35:58 deraadt Exp $	*/
d323 6
a328 1
	/* Get name and set process title */
d347 6
d878 6
@


1.29
log
@ntpd is too aggressive about retrying constraint connections.  This
became more visible recently because a log_debug was changed to
log_warnx.  Change it back for now.
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.28 2016/05/21 13:46:10 jsing Exp $	*/
d821 1
a821 1
	if (tls_config_set_ciphers(httpsdate->tls_config, "compat") != 0)
@


1.28
log
@Harden TLS for ntpd constraints - stop disabling server name verification,
ensure that we load the CA certificates and use tls_connect_servername()
so that we can verify the server we are connecting to (even though we've
already resolved the hostname). Also add additional warnings for TLS
connect and TLS write failures so that we know what is happening and why.

Lack of server name verification also reported by Luis M. Merino
<luismiguelmerino at gmail dot com> - thanks!

ok deraadt@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.26 2016/03/05 16:09:20 naddy Exp $	*/
d869 1
a869 1
		log_warnx("tls connect failed: %s (%s): %s",
@


1.27
log
@Unconfuse things by renaming variables to match their contents.

ok deraadt@@ reyk@@
@
text
@d295 1
a295 1
	/* Init TLS and load cert before chroot() */
d300 1
a300 1
		log_warnx("constraint certificate verification turned off");
a823 3
	/* XXX we have to pre-resolve, so name and host are not equal */
	tls_config_insecure_noverifyname(httpsdate->tls_config);

d867 4
a870 3
	if (tls_connect(httpsdate->tls_ctx,
	    httpsdate->tls_addr, httpsdate->tls_port) == -1) {
		log_debug("tls failed: %s: %s", httpsdate->tls_addr,
d881 4
a884 1
		if (ret < 0)
d886 1
d921 1
a922 1
	return (0);
@


1.26
log
@According to RFC7231, section 7.1.1.1, the HTTP date header supports
no other timezone than the fixed string "GMT".  Avoid using strptime %Z,
which is nonstandard and can give surprising results on other operating
systems.  ok deraadt@@ giovanni@@ bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.25 2016/01/27 21:48:34 reyk Exp $	*/
d80 1
a80 1
	char			*tls_host;
d82 1
a82 1
	char			*tls_name;
d283 1
a283 1
	static char		 hname[NI_MAXHOST];
d326 1
a326 1
	    hname, sizeof(hname), NULL, 0,
d330 2
a331 2
	log_debug("constraint request to %s", hname);
	setproctitle("constraint from %s", hname);
d362 1
a362 1
	if ((ctx = httpsdate_query(hname,
d796 1
a796 1
httpsdate_init(const char *hname, const char *port, const char *name,
d804 2
a805 2
	if (name == NULL)
		name = hname;
d807 1
a807 1
	if ((httpsdate->tls_host = strdup(hname)) == NULL ||
d809 1
a809 1
	    (httpsdate->tls_name = strdup(name)) == NULL ||
d815 1
a815 1
	    httpsdate->tls_path, httpsdate->tls_name) == -1)
d849 1
a849 1
	free(httpsdate->tls_host);
d851 1
a851 1
	free(httpsdate->tls_name);
d871 2
a872 2
	    httpsdate->tls_host, httpsdate->tls_port) == -1) {
		log_debug("tls failed: %s: %s", httpsdate->tls_host,
d927 1
a927 1
httpsdate_query(const char *hname, const char *port, const char *name,
d935 1
a935 1
	if ((httpsdate = httpsdate_init(hname, port, name, path,
@


1.25
log
@Don't attempt to kill() the constraint in the wrong process.  The
process management of the contraint processes has been moved from ntp
to the parent, for better privsep and pledge, but the ntp process
still attempted to kill the constraints on timeout directly.  Fix this
regression by introducing a new imsg from ntp to the parent and the
related logic to kill a constraint at the right place.

Reported & tested by bcook@@
Ok bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.24 2015/12/19 17:55:29 reyk Exp $	*/
d906 1
a906 1
		if (strptime(p, "%a, %d %h %Y %T %Z",
@


1.24
log
@Switch and sync to the log.c variant from httpd/relayd/iked/snmpd/vmd.

OK bcook@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.23 2015/12/05 13:12:16 claudio Exp $	*/
d166 4
a169 1
		kill(cstr->pid, SIGTERM);
d386 1
d398 11
a408 4
		if (sig)
			fatalx("constraint %s, signal %d",
			    log_sockaddr((struct sockaddr *)
			    &cstr->addr->ss), sig);
d412 13
@


1.23
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.22 2015/11/24 01:03:25 deraadt Exp $	*/
a44 1
#include "log.h"
d286 2
@


1.22
log
@Cache values from getpwnam() done at initialization, which need to be
used by the constraint processes setup later (chroot, setuid...)
[late getpwnam discovered during a further audit]
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.21 2015/11/19 21:32:53 mmcc Exp $	*/
d30 1
d530 1
a530 1
	if ((n = imsg_read(&cstr->ibuf)) == -1 || n == 0) {
@


1.21
log
@Simplify all instances of get_string() and get_data() using malloc() and
strndup().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.20 2015/11/17 15:34:36 deraadt Exp $	*/
d61 1
a61 1
	    u_int8_t *, int[2]);
d210 2
a211 1
priv_constraint_msg(u_int32_t id, u_int8_t *data, size_t len)
d261 2
a262 1
		priv_constraint_child(cstr, &am, data + sizeof(am), pipes);
d278 1
a278 1
    u_int8_t *data, int pipes[2])
a282 1
	struct passwd		*pw;
d297 1
a297 5
	/* Drop privileges */
	if ((pw = getpwnam(NTPD_USER)) == NULL)
		fatalx("unknown user %s", NTPD_USER);

	if (chroot(pw->pw_dir) == -1)
d302 3
a304 3
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
@


1.20
log
@fix memory leak; from David CARLIER
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.19 2015/10/12 06:50:08 reyk Exp $	*/
a981 1
	char	*str;
d987 1
a987 5
	if ((str = calloc(1, i + 1)) == NULL)
		return (NULL);
	memcpy(str, ptr, i);

	return (str);
@


1.19
log
@Move execution of the constraints from the ntp to the parent process.
This helps the ntp process to a) give a better pledge(2) and to b)
keep the promise of "saving the world again... on time" by removing
the delays that have been introduced by expensive constraint forks.
The new design offers better privsep but introduces a few more imsgs
and runs a little bit more code in the privileged parent.  The
privileged code is minimal, carefully checked, and does not attempt to
"parse" any contents; the forked constraints instantly drop all
privileges and pledge to "stdio inet".

OK beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.18 2015/10/09 03:50:40 deraadt Exp $	*/
d505 1
@


1.18
log
@Once the constraint engine process is running, it only needs
"stdio inet".  It took weeks to get to this point...
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.17 2015/09/10 13:49:48 beck Exp $	*/
d24 1
a31 1
#include <errno.h>
d40 1
d42 1
a42 1
#include <err.h>
d54 1
a54 1
int	 constraint_close(int);
d59 4
d74 1
a74 1
extern u_int constraint_cnt;
d76 2
d144 4
a147 6
	int		 pipes[2];
	struct timeval	 rectv, xmttv;
	void		*ctx;
	static char	 hname[NI_MAXHOST];
	time_t		 now;
	struct iovec	 iov[2];
d176 1
a176 1
		constraint_close(cstr->fd);
d185 47
a231 5
	if (getnameinfo((struct sockaddr *)&cstr->addr->ss,
	    SA_LEN((struct sockaddr *)&cstr->addr->ss),
	    hname, sizeof(hname), NULL, 0,
	    NI_NUMERICHOST) != 0)
		fatalx("%s getnameinfo %s", __func__, cstr->addr_head.name);
d233 11
a243 1
	log_debug("constraint request to %s", hname);
d248 5
a252 1
	/* Fork child handlers */
d258 1
a258 1
		return (-1);
d260 1
a260 36
		setproctitle("constraint from %s", hname);

		if (pledge("stdio inet", NULL) == -1)
			err(1, "pledge");

		/* Child process */
		if (dup2(pipes[1], CONSTRAINT_PASSFD) == -1)
			fatal("%s dup2 CONSTRAINT_PASSFD", __func__);
		if (pipes[0] != CONSTRAINT_PASSFD)
			close(pipes[0]);
		if (pipes[1] != CONSTRAINT_PASSFD)
			close(pipes[1]);
		(void)closefrom(CONSTRAINT_PASSFD + 1);

		if (fcntl(CONSTRAINT_PASSFD, F_SETFD, FD_CLOEXEC) == -1)
			fatal("%s fcntl F_SETFD", __func__);

		cstr->fd = CONSTRAINT_PASSFD;
		imsg_init(&cstr->ibuf, cstr->fd);

		if ((ctx = httpsdate_query(hname,
		    CONSTRAINT_PORT, cstr->addr_head.name, cstr->addr_head.path,
		    conf->ca, conf->ca_len, &rectv, &xmttv)) == NULL) {
			/* Abort with failure but without warning */
			exit(1);
		}

		iov[0].iov_base = &rectv;
		iov[0].iov_len = sizeof(rectv);
		iov[1].iov_base = &xmttv;
		iov[1].iov_len = sizeof(xmttv);
		imsg_composev(&cstr->ibuf, IMSG_CONSTRAINT, 0, 0, -1, iov, 2);
		imsg_flush(&cstr->ibuf);

		/* Tear down the TLS connection after sending the result */
		httpsdate_free(ctx);
a267 1
		cstr->state = STATE_QUERY_SENT;
d272 48
d321 18
d340 37
a376 1
	return (0);
d380 1
a380 1
constraint_check_child(void)
a382 1
	int			 status;
a383 1
	pid_t			 pid;
d385 14
a398 4
	do {
		pid = waitpid(WAIT_ANY, &status, WNOHANG);
		if (pid <= 0)
			continue;
d400 2
a401 27
		fail = sig = 0;
		if (WIFSIGNALED(status)) {
			sig = WTERMSIG(status);
		} else if (WIFEXITED(status)) {
			if (WEXITSTATUS(status) != 0)
				fail = 1;
		} else
			fatalx("unexpected cause of SIGCHLD");

		if ((cstr = constraint_bypid(pid)) != NULL) {
			if (sig)
				fatalx("constraint %s, signal %d",
				    log_sockaddr((struct sockaddr *)
				    &cstr->addr->ss), sig);
			if (fail) {
				log_debug("no constraint reply from %s"
				    " received in time, next query %ds",
				    log_sockaddr((struct sockaddr *)
				    &cstr->addr->ss), CONSTRAINT_SCAN_INTERVAL);
			}

			if (fail || cstr->state < STATE_QUERY_SENT) {
				cstr->senderrors++;
				constraint_close(cstr->fd);
			}
		}
	} while (pid > 0 || (pid == -1 && errno == EINTR));
d444 1
a444 1
constraint_close(int fd)
d448 2
a449 2
	if ((cstr = constraint_byfd(fd)) == NULL) {
		log_warn("%s: fd %d: not found", __func__, fd);
a452 3
	msgbuf_clear(&cstr->ibuf.w);
	close(cstr->fd);
	cstr->fd = -1;
d471 19
d499 4
d508 9
d518 1
a518 1
constraint_dispatch_msg(struct pollfd *pfd)
a523 1
	double			 offset;
d532 1
a532 1
		constraint_close(pfd->fd);
d538 1
a538 1
			constraint_close(pfd->fd);
d545 1
a545 1
		case IMSG_CONSTRAINT:
d549 3
a551 14
			memcpy(tv, imsg.data, sizeof(tv));

			offset = gettime_from_timeval(&tv[0]) -
			    gettime_from_timeval(&tv[1]);

			log_info("constraint reply from %s: offset %f",
			    log_sockaddr((struct sockaddr *)&cstr->addr->ss),
			    offset);

			cstr->state = STATE_REPLY_RECEIVED;
			cstr->last = getmonotime();
			cstr->constraint = tv[0].tv_sec;

			constraint_update();
d563 65
a627 1
constraint_dns(u_int32_t id, u_int8_t *data, size_t len)
d736 1
a736 1
		constraint_close(cstr->fd);
a776 3
	if (tls_init() == -1)
		return (NULL);

d975 17
@


1.17
log
@fix type and return check for tls_read/write.

jontly with jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.16 2015/09/10 10:34:19 beck Exp $	*/
d41 1
d200 3
@


1.16
log
@fix after libtls api changes
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.15 2015/09/09 15:05:58 millert Exp $	*/
d646 1
a646 1
	int	 ret;
d747 1
a747 1
	int ret;
d763 1
a763 1
		if (ret != 0) {
@


1.15
log
@Fix memory leak in error path when max length exceeded.
From Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.14 2015/07/18 21:50:47 bluhm Exp $	*/
d664 2
a665 2
		ret = tls_write(httpsdate->tls_ctx, buf, len, &outlen);
		if (ret == TLS_READ_AGAIN || ret == TLS_WRITE_AGAIN)
d669 2
a670 2
		buf += outlen;
		len -= outlen;
d745 1
a745 1
	size_t i, len, nr;
d760 2
a761 2
		ret = tls_read(tls, &c, 1, &nr);
		if (ret == TLS_READ_AGAIN)
@


1.14
log
@Handle short writes and TLS_{READ,WRITE}_AGAIN around tls_write().
input doug@@; OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.13 2015/07/18 20:32:38 bcook Exp $	*/
d771 1
@


1.13
log
@prevent the tls constraint state machine from getting hung on STATE_INVALID

patch from Mikolaj Kucharski
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.12 2015/05/28 21:34:36 deraadt Exp $	*/
d644 3
a646 2
	size_t	 outlen = 0, maxlength = CONSTRAINT_MAXHEADERLENGTH;
	char	*line, *p;
d661 11
a671 4
	if (tls_write(httpsdate->tls_ctx,
	    httpsdate->tls_request, strlen(httpsdate->tls_request),
	    &outlen) == -1)
		goto fail;
@


1.12
log
@detect crashes from constraint sub-processes, instead of ignoring them.
if this happens, we want to tear down all of ntpd, so that people will
report it, any such bug can be found, and fixed.
ok bcook
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.11 2015/05/21 14:24:43 reyk Exp $	*/
d272 1
a272 1
				fatalx("constraint %s, signal %d", 
d282 1
a282 1
			if (fail || cstr->state < STATE_REPLY_RECEIVED) {
@


1.11
log
@No need to call tzset() and log_init() in the forked constraint
handler.  It is run in a chroot, so tzset() wouldn't even succeed to
open the zone file.  Found with tame.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.10 2015/05/18 14:19:23 reyk Exp $	*/
d253 1
a253 1
	int			 fail;
d261 1
a261 1
		fail = 0;
d263 1
a263 1
			fail = 1;
d271 4
@


1.10
log
@Currently, after 4 failed constraint checks, we suspect the constraint
of being wrong, not the NTP responses, reset it and query it from all
the constraint servers all over again.  This is turned out to be a bit
aggressive because it could get triggered with just a few bad NTP
peers in a larger pool.  To avoid constant reconnections, scale the
error margin with the number of resolved NTP peers using peer_cnt * 4.
This way a single or a few outliers in a NTP pool cannot trigger
reconnecting to the constraint servers immediately.  More NTP peers,
less reason to mistrust the constraint.

Found by dtucker@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.9 2015/05/17 18:31:32 reyk Exp $	*/
a197 3
		tzset();
		log_init(conf->debug);

@


1.9
log
@When resolving the "constraint" (singular), store all returned IP
addresses and try one after another until the connection succeeded -
based on the existing mechanism of "server".  "constraint" previously
only tried to connect to the first returned address, aborted and
skipped the constraint on failure.  In difference to "constraints"
(plural), it still only connects to one address at a time and not to
all of them at once.

Pointed out by rpe@@
OK rpe@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.8 2015/04/21 01:49:19 jsg Exp $	*/
d69 1
d564 2
a565 1
		if (conf->constraint_errors++ > CONSTRAINT_ERROR_MARGIN) {
@


1.8
log
@fix a memory leak if tls_read() fails.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.7 2015/03/14 05:10:11 bcook Exp $	*/
a55 2
void	 constraint_add(struct constraint *);
void	 constraint_remove(struct constraint *);
d88 1
d340 9
a348 4
	if (cstr->senderrors)
		cstr->state = STATE_INVALID;
	else if (cstr->state >= STATE_QUERY_SENT)
		cstr->state = STATE_DNS_DONE;
d350 2
a351 1
	cstr->last = getmonotime();
d353 2
a354 1
	return (1);
a360 1
	constraint_cnt += constraint_init(cstr);
a369 1
	constraint_cnt--;
d432 1
a432 1
	struct constraint	*cstr, *ncstr;
d461 19
a479 12
		ncstr = new_constraint();
		ncstr->addr = h;
		ncstr->addr_head.a = h;
		ncstr->addr_head.name = strdup(cstr->addr_head.name);
		ncstr->addr_head.path = strdup(cstr->addr_head.path);
		if (ncstr->addr_head.name == NULL ||
		    ncstr->addr_head.path == NULL)
			fatal("calloc name");
		ncstr->addr_head.pool = cstr->addr_head.pool;

		constraint_add(ncstr);
	} while (len && cstr->addr_head.pool);
@


1.7
log
@remove unused 'cause' string when checking child status

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.6 2015/02/22 15:09:54 jsing Exp $	*/
d743 1
@


1.6
log
@Rename tls_config_insecure_noverifyhost() to
tls_config_insecure_noverifyname(), so that it is more accurate and keeps
inline with the distinction between DNS hostname and server name.

Requested by tedu@@ during s2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.5 2015/02/22 14:55:41 jsing Exp $	*/
d151 1
a151 1
		constraint_init(cstr);		
a256 1
	char			*cause;
a266 2
			asprintf(&cause, "terminated; signal %d",
			    WTERMSIG(status));
d268 1
a268 1
			if (WEXITSTATUS(status) != 0) {
a269 3
				asprintf(&cause, "exited abnormally");
			} else
				asprintf(&cause, "exited okay");
a285 1
		free(cause);
@


1.5
log
@Set the TLS ciphers to "compat" mode, restoring the previous behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.4 2015/02/12 01:54:57 reyk Exp $	*/
d602 1
a602 1
	tls_config_insecure_noverifyhost(httpsdate->tls_config);
@


1.4
log
@Use ntpd's deferred DNS resolving for constraints as well.  This
allows to get constraint addresses even if network/DNS is not
available at startup (or system boot).

thumbs up & OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.3 2015/02/10 23:52:41 reyk Exp $	*/
d596 3
@


1.3
log
@Be less chatty on constraint errors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.2 2015/02/10 11:36:37 reyk Exp $	*/
d47 2
d56 2
d70 2
a99 1
	int			 cnt = 0;
d101 27
a127 20
	for (h = cstr->addr; h != NULL; h = h->next) {
		switch (h->ss.ss_family) {
		case AF_INET:
			sa_in = (struct sockaddr_in *)&h->ss;
			if (ntohs(sa_in->sin_port) == 0)
				sa_in->sin_port = htons(443);
			cstr->state = STATE_DNS_DONE;
			break;
		case AF_INET6:
			sa_in6 = (struct sockaddr_in6 *)&h->ss;
			if (ntohs(sa_in6->sin6_port) == 0)
				sa_in6->sin6_port = htons(443);
			cstr->state = STATE_DNS_DONE;
			break;
		default:
			/* XXX king bula sez it? */
			fatalx("wrong AF in constraint_addr_init");
			/* NOTREACHED */
		}
		cnt++;
d130 1
a130 1
	return (cnt);
d149 4
d297 13
d358 17
d430 48
@


1.2
log
@After successfully getting a constraint from an HTTPS server, there is
no need to request it ever again.  The only exception is the
escalation of failed constraint checks that might lead into
re-requesting the constraint time from all servers.  Adjust the states
accordingly.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: constraint.c,v 1.1 2015/02/10 06:40:08 reyk Exp $	*/
d265 1
a265 1
				log_info("no constraint reply from %s"
d551 1
a551 1
		log_warnx("tls failed: %s: %s", httpsdate->tls_host,
@


1.1
log
@Add support for "constraints": when configured, ntpd(8) will query the
time from HTTPS servers, by parsing the Date: header, and use the
median constraint time as a boundary to verify NTP responses.  This
adds some level of authentication and protection against MITM attacks
while preserving the accuracy of the NTP protocol; without relying on
authentication options for NTP that are basically unavailable at
present.  This is an initial implementation and the semantics will be
improved once it is in the tree.

Discussed with deraadt@@ and henning@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 15
a146 1
	if (cstr->state >= STATE_REPLY_RECEIVED) {
d152 1
a152 1
		/* Reset */
d155 4
a158 8
	} else if (cstr->state == STATE_QUERY_SENT) {
		if (cstr->last + CONSTRAINT_SCAN_TIMEOUT > now) {
			/* The caller should expect a reply */
			return (0);
		}

		/* Timeout, just kill the process to reset it */
		kill(cstr->pid, SIGTERM);
@

