head	1.135;
access;
symbols
	OPENBSD_6_2_BASE:1.135
	OPENBSD_6_1:1.134.0.4
	OPENBSD_6_1_BASE:1.134
	OPENBSD_6_0:1.130.0.2
	OPENBSD_6_0_BASE:1.130
	OPENBSD_5_9:1.129.0.2
	OPENBSD_5_9_BASE:1.129
	OPENBSD_5_8:1.121.0.4
	OPENBSD_5_8_BASE:1.121
	OPENBSD_5_7:1.119.0.2
	OPENBSD_5_7_BASE:1.119
	OPENBSD_5_6:1.109.0.6
	OPENBSD_5_6_BASE:1.109
	OPENBSD_5_5:1.109.0.4
	OPENBSD_5_5_BASE:1.109
	OPENBSD_5_4:1.107.0.2
	OPENBSD_5_4_BASE:1.107
	OPENBSD_5_3:1.106.0.2
	OPENBSD_5_3_BASE:1.106
	OPENBSD_5_2:1.105.0.4
	OPENBSD_5_2_BASE:1.105
	OPENBSD_5_1_BASE:1.105
	OPENBSD_5_1:1.105.0.2
	OPENBSD_5_0:1.103.0.10
	OPENBSD_5_0_BASE:1.103
	OPENBSD_4_9:1.103.0.8
	OPENBSD_4_9_BASE:1.103
	OPENBSD_4_8:1.103.0.6
	OPENBSD_4_8_BASE:1.103
	OPENBSD_4_7:1.103.0.2
	OPENBSD_4_7_BASE:1.103
	OPENBSD_4_6:1.103.0.4
	OPENBSD_4_6_BASE:1.103
	OPENBSD_4_5:1.99.0.2
	OPENBSD_4_5_BASE:1.99
	OPENBSD_4_4:1.95.0.2
	OPENBSD_4_4_BASE:1.95
	OPENBSD_4_3:1.91.0.2
	OPENBSD_4_3_BASE:1.91
	OPENBSD_4_2:1.85.0.2
	OPENBSD_4_2_BASE:1.85
	OPENBSD_4_1:1.82.0.2
	OPENBSD_4_1_BASE:1.82
	OPENBSD_4_0:1.76.0.2
	OPENBSD_4_0_BASE:1.76
	OPENBSD_3_9:1.61.0.2
	OPENBSD_3_9_BASE:1.61
	OPENBSD_3_8:1.60.0.2
	OPENBSD_3_8_BASE:1.60
	OPENBSD_3_7:1.53.0.2
	OPENBSD_3_7_BASE:1.53
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33;
locks; strict;
comment	@ * @;


1.135
date	2017.05.30.23.30.48;	author benno;	state Exp;
branches;
next	1.134;
commitid	QAWRWuyNn05Y7pSZ;

1.134
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.133;
commitid	eA8b246voAapPTkX;

1.133
date	2016.09.26.17.17.01;	author rzalamena;	state Exp;
branches;
next	1.132;
commitid	BmpOnKpM0apagYju;

1.132
date	2016.09.14.13.20.16;	author rzalamena;	state Exp;
branches;
next	1.131;
commitid	FUtuYlECIdeLHfjN;

1.131
date	2016.09.03.11.52.06;	author reyk;	state Exp;
branches;
next	1.130;
commitid	NAWlzXnfvHaWyDX5;

1.130
date	2016.03.27.11.16.12;	author krw;	state Exp;
branches;
next	1.129;
commitid	syOeQHSeA2wvpEwB;

1.129
date	2016.01.27.21.48.34;	author reyk;	state Exp;
branches;
next	1.128;
commitid	KTDuqL1fW4bPtfRB;

1.128
date	2016.01.27.21.36.25;	author bcook;	state Exp;
branches;
next	1.127;
commitid	GFS3CWizsSk76UNf;

1.127
date	2015.12.19.20.44.35;	author reyk;	state Exp;
branches;
next	1.126;
commitid	yMsnemUVmfyHzTAL;

1.126
date	2015.12.19.13.58.08;	author reyk;	state Exp;
branches;
next	1.125;
commitid	de21MufW7eCZF1cc;

1.125
date	2015.11.24.01.03.25;	author deraadt;	state Exp;
branches;
next	1.124;
commitid	w82qmLlikEZFzR4v;

1.124
date	2015.10.30.17.59.56;	author naddy;	state Exp;
branches;
next	1.123;
commitid	U152A9Sulw642yBK;

1.123
date	2015.10.23.14.52.20;	author phessler;	state Exp;
branches;
next	1.122;
commitid	37dFIvtgNCa7AEy2;

1.122
date	2015.10.12.06.50.08;	author reyk;	state Exp;
branches;
next	1.121;
commitid	to5fPpeGvAbrgkr0;

1.121
date	2015.05.20.13.32.39;	author reyk;	state Exp;
branches;
next	1.120;
commitid	wTGf2eC247IaKa6e;

1.120
date	2015.05.17.18.31.32;	author reyk;	state Exp;
branches;
next	1.119;
commitid	aCSIV6rNWhdw3L8D;

1.119
date	2015.02.12.01.54.57;	author reyk;	state Exp;
branches;
next	1.118;
commitid	eJZFYJXXt9fmfGXk;

1.118
date	2015.02.10.06.40.08;	author reyk;	state Exp;
branches;
next	1.117;
commitid	pXoTR74Ztt0R3SV0;

1.117
date	2015.01.13.02.28.56;	author bcook;	state Exp;
branches;
next	1.116;
commitid	h77ELH1lDWjNCTWO;

1.116
date	2015.01.10.13.47.05;	author tedu;	state Exp;
branches;
next	1.115;
commitid	d03DIVk9MVCSKQBu;

1.115
date	2015.01.09.07.35.37;	author deraadt;	state Exp;
branches;
next	1.114;
commitid	X9qvCMjSyjyh2fK9;

1.114
date	2015.01.08.00.30.08;	author bcook;	state Exp;
branches;
next	1.113;
commitid	KDtICkil0jI83gxu;

1.113
date	2015.01.04.01.48.49;	author bcook;	state Exp;
branches;
next	1.112;
commitid	SqfYJN9THyGArOhK;

1.112
date	2015.01.04.01.13.10;	author bcook;	state Exp;
branches;
next	1.111;
commitid	m35uENzv7J0WF01N;

1.111
date	2014.11.03.20.15.30;	author bluhm;	state Exp;
branches;
next	1.110;
commitid	ziMZlrkCPhUaYhzj;

1.110
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.109;
commitid	2uw1UTO4k6erpWzK;

1.109
date	2014.01.22.02.55.15;	author benno;	state Exp;
branches;
next	1.108;

1.108
date	2013.10.04.14.28.16;	author phessler;	state Exp;
branches;
next	1.107;

1.107
date	2013.04.30.11.42.56;	author mglocker;	state Exp;
branches;
next	1.106;

1.106
date	2012.09.20.12.43.16;	author patrick;	state Exp;
branches;
next	1.105;

1.105
date	2011.09.21.16.38.05;	author phessler;	state Exp;
branches;
next	1.104;

1.104
date	2011.09.21.15.41.30;	author phessler;	state Exp;
branches;
next	1.103;

1.103
date	2009.06.06.18.45.01;	author ckuethe;	state Exp;
branches;
next	1.102;

1.102
date	2009.06.06.18.14.25;	author pyr;	state Exp;
branches;
next	1.101;

1.101
date	2009.06.04.23.39.46;	author ckuethe;	state Exp;
branches;
next	1.100;

1.100
date	2009.05.13.15.08.10;	author stevesk;	state Exp;
branches;
next	1.99;

1.99
date	2009.02.11.01.00.10;	author stevesk;	state Exp;
branches;
next	1.98;

1.98
date	2009.02.10.16.52.09;	author stevesk;	state Exp;
branches;
next	1.97;

1.97
date	2009.02.06.21.48.00;	author stevesk;	state Exp;
branches;
next	1.96;

1.96
date	2008.09.12.10.46.09;	author henning;	state Exp;
branches;
next	1.95;

1.95
date	2008.06.10.03.46.09;	author naddy;	state Exp;
branches;
next	1.94;

1.94
date	2008.06.09.18.30.48;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2008.06.09.16.37.35;	author ckuethe;	state Exp;
branches;
next	1.92;

1.92
date	2008.05.16.06.13.25;	author ckuethe;	state Exp;
branches;
next	1.91;

1.91
date	2008.01.28.11.45.59;	author mpf;	state Exp;
branches;
next	1.90;

1.90
date	2007.12.23.18.39.50;	author stevesk;	state Exp;
branches;
next	1.89;

1.89
date	2007.12.22.18.26.21;	author stevesk;	state Exp;
branches;
next	1.88;

1.88
date	2007.10.15.06.59.32;	author otto;	state Exp;
branches;
next	1.87;

1.87
date	2007.09.13.14.34.36;	author pyr;	state Exp;
branches;
next	1.86;

1.86
date	2007.09.12.21.08.46;	author ckuethe;	state Exp;
branches;
next	1.85;

1.85
date	2007.08.04.02.58.02;	author ckuethe;	state Exp;
branches;
next	1.84;

1.84
date	2007.04.30.01.33.33;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2007.03.23.14.22.40;	author ckuethe;	state Exp;
branches;
next	1.82;

1.82
date	2007.03.01.17.50.42;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2007.01.15.08.19.11;	author otto;	state Exp;
branches;
next	1.80;

1.80
date	2006.12.23.17.49.53;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2006.11.20.20.58.47;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2006.10.27.12.22.41;	author henning;	state Exp;
branches;
next	1.77;

1.77
date	2006.10.24.12.23.39;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2006.06.30.16.52.13;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2006.06.26.09.43.06;	author otto;	state Exp;
branches;
next	1.74;

1.74
date	2006.06.22.11.11.25;	author otto;	state Exp;
branches;
next	1.73;

1.73
date	2006.06.18.19.38.11;	author otto;	state Exp;
branches;
next	1.72;

1.72
date	2006.06.17.18.40.42;	author otto;	state Exp;
branches;
next	1.71;

1.71
date	2006.06.07.06.29.03;	author otto;	state Exp;
branches;
next	1.70;

1.70
date	2006.06.04.18.58.13;	author otto;	state Exp;
branches;
next	1.69;

1.69
date	2006.05.28.20.39.16;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.28.18.47.25;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.27.22.22.47;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.27.21.27.34;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.27.18.32.00;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.27.17.01.07;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.26.00.33.16;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.25.19.25.46;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2005.09.24.00.32.03;	author dtucker;	state Exp;
branches;
next	1.60;

1.60
date	2005.08.10.13.48.36;	author dtucker;	state Exp;
branches;
next	1.59;

1.59
date	2005.07.15.03.37.15;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2005.07.05.10.09.12;	author dtucker;	state Exp;
branches;
next	1.57;

1.57
date	2005.06.19.17.11.13;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2005.06.19.16.42.57;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2005.04.26.15.18.22;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.23.10.42.04;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.03.10.53.33;	author dtucker;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.02.18.57.09;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2005.01.28.12.37.20;	author dtucker;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.27.14.44.00;	author dtucker;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.27.10.32.29;	author dtucker;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.16.00.38.59;	author dtucker;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.09.20.24.46;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.06.20.57.17;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.06.16.52.33;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2004.11.12.17.24.52;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.10.11.47.28;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.10.11.27.54;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2004.10.22.21.17.37;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.10.14.09.35.48;	author dtucker;	state Exp;
branches;
next	1.39;

1.39
date	2004.09.18.20.27.57;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.09.18.20.01.38;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2004.09.18.07.33.14;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.16.01.13.42;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.15.19.21.25;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.15.00.18.12;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.08.12.16.33.59;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.10.12.41.15;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.07.29.11.01.48;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2004.07.28.16.38.43;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.25.18.27.58;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.20.16.47.55;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.18.12.59.41;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.14.20.16.31;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.13.19.41.26;	author alexander;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.11.00.15.10;	author alexander;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.10.23.12.57;	author alexander;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.10.22.24.20;	author alexander;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.10.18.42.51;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.09.19.44.18;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.09.10.53.33;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.08.01.22.57;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.07.07.32.05;	author alexander;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.07.05.47.57;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.07.03.15.37;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.07.01.01.27;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.06.23.26.38;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.05.22.12.53;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.05.20.41.35;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.05.07.46.16;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.04.22.24.20;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.04.11.01.49;	author alexander;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.18.04.51.31;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.17.19.17.48;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.05.12.29.15;	author alexander;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.02.10.08.59;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.01.21.58.09;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.01.16.27.09;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.31.13.46.16;	author henning;	state Exp;
branches;
next	;


desc
@@


1.135
log
@add option "query from <ip>" to ntpd.conf, to specify a local IP
address for outgoing ntp queries.
From Job Snijders, thanks!
with feedback and ok henning@@
@
text
@/*	$OpenBSD: ntpd.h,v 1.134 2017/01/09 14:49:22 reyk Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2012 Mike Miller <mmiller@@mgm51.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/uio.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pwd.h>
#include <stdarg.h>
#include <poll.h>
#include <imsg.h>

#include "ntp.h"

#define MAXIMUM(a, b)	((a) > (b) ? (a) : (b))

#define	NTPD_USER	"_ntp"
#define	CONFFILE	"/etc/ntpd.conf"
#define DRIFTFILE	"/var/db/ntpd.drift"
#define	CTLSOCKET	"/var/run/ntpd.sock"

#define	INTERVAL_QUERY_NORMAL		30	/* sync to peers every n secs */
#define	INTERVAL_QUERY_PATHETIC		60
#define	INTERVAL_QUERY_AGGRESSIVE	5

#define	TRUSTLEVEL_BADPEER		6
#define	TRUSTLEVEL_PATHETIC		2
#define	TRUSTLEVEL_AGGRESSIVE		8
#define	TRUSTLEVEL_MAX			10

#define	MAX_SERVERS_DNS			8

#define	QSCALE_OFF_MIN			0.001
#define	QSCALE_OFF_MAX			0.050

#define	QUERYTIME_MAX		15	/* single query might take n secs max */
#define	OFFSET_ARRAY_SIZE	8
#define	SENSOR_OFFSETS		6
#define	SETTIME_TIMEOUT		15	/* max seconds to wait with -s */
#define	LOG_NEGLIGIBLE_ADJTIME	32	/* negligible drift to not log (ms) */
#define	LOG_NEGLIGIBLE_ADJFREQ	0.05	/* negligible rate to not log (ppm) */
#define	FREQUENCY_SAMPLES	8	/* samples for est. of permanent drift */
#define	MAX_FREQUENCY_ADJUST	128e-5	/* max correction per iteration */
#define MAX_SEND_ERRORS		3	/* max send errors before reconnect */
#define	MAX_DISPLAY_WIDTH	80	/* max chars in ctl_show report line */

#define FILTER_ADJFREQ		0x01	/* set after doing adjfreq */

#define	SENSOR_DATA_MAXAGE		(15*60)
#define	SENSOR_QUERY_INTERVAL		15
#define	SENSOR_QUERY_INTERVAL_SETTIME	(SETTIME_TIMEOUT/3)
#define	SENSOR_SCAN_INTERVAL		(1*60)
#define	SENSOR_DEFAULT_REFID		"HARD"

#define CONSTRAINT_ERROR_MARGIN		(4)
#define CONSTRAINT_SCAN_INTERVAL	(15*60)
#define CONSTRAINT_SCAN_TIMEOUT		(10)
#define CONSTRAINT_MARGIN		(2.0*60)
#define CONSTRAINT_PORT			"443"	/* HTTPS port */
#define	CONSTRAINT_MAXHEADERLENGTH	8192
#define CONSTRAINT_PASSFD		(STDERR_FILENO + 1)
#define CONSTRAINT_CA			"/etc/ssl/cert.pem"

#define PARENT_SOCK_FILENO		CONSTRAINT_PASSFD

#define NTP_PROC_NAME			"ntp_main"
#define NTPDNS_PROC_NAME		"ntp_dns"
#define CONSTRAINT_PROC_NAME		"constraint"

enum client_state {
	STATE_NONE,
	STATE_DNS_INPROGRESS,
	STATE_DNS_TEMPFAIL,
	STATE_DNS_DONE,
	STATE_QUERY_SENT,
	STATE_REPLY_RECEIVED,
	STATE_TIMEOUT,
	STATE_INVALID
};

struct listen_addr {
	TAILQ_ENTRY(listen_addr)	 entry;
	struct sockaddr_storage		 sa;
	int				 fd;
	int				 rtable;
};

struct ntp_addr {
	struct ntp_addr		*next;
	struct sockaddr_storage	 ss;
};

struct ntp_addr_wrap {
	char			*name;
	char			*path;
	struct ntp_addr		*a;
	u_int8_t		 pool;
};

struct ntp_addr_msg {
	struct ntp_addr		 a;
	size_t			 namelen;
	size_t			 pathlen;
};

struct ntp_status {
	double		rootdelay;
	double		rootdispersion;
	double		reftime;
	u_int32_t	refid;
	u_int32_t	send_refid;
	u_int8_t	synced;
	u_int8_t	leap;
	int8_t		precision;
	u_int8_t	poll;
	u_int8_t	stratum;
};

struct ntp_offset {
	struct ntp_status	status;
	double			offset;
	double			delay;
	double			error;
	time_t			rcvd;
	u_int8_t		good;
};

struct ntp_peer {
	TAILQ_ENTRY(ntp_peer)		 entry;
	struct ntp_addr_wrap		 addr_head;
	struct ntp_addr			*addr;
	struct ntp_query		*query;
	struct ntp_offset		 reply[OFFSET_ARRAY_SIZE];
	struct ntp_offset		 update;
	struct sockaddr_in		 query_addr4;
	struct sockaddr_in6		 query_addr6;
	enum client_state		 state;
	time_t				 next;
	time_t				 deadline;
	time_t				 poll;
	u_int32_t			 id;
	u_int8_t			 shift;
	u_int8_t			 trustlevel;
	u_int8_t			 weight;
	int				 lasterror;
	int				 senderrors;
};

struct ntp_sensor {
	TAILQ_ENTRY(ntp_sensor)		 entry;
	struct ntp_offset		 offsets[SENSOR_OFFSETS];
	struct ntp_offset		 update;
	time_t				 next;
	time_t				 last;
	char				*device;
	u_int32_t			 refid;
	int				 sensordevid;
	int				 correction;
	u_int8_t			 stratum;
	u_int8_t			 weight;
	u_int8_t			 shift;
};

struct constraint {
	TAILQ_ENTRY(constraint)		 entry;
	struct ntp_addr_wrap		 addr_head;
	struct ntp_addr			*addr;
	int				 senderrors;
	enum client_state		 state;
	u_int32_t			 id;
	int				 fd;
	pid_t				 pid;
	struct imsgbuf			 ibuf;
	time_t				 last;
	time_t				 constraint;
};

struct ntp_conf_sensor {
	TAILQ_ENTRY(ntp_conf_sensor)		 entry;
	char					*device;
	char					*refstr;
	int					 correction;
	u_int8_t				 stratum;
	u_int8_t				 weight;
};

struct ntp_freq {
	double				overall_offset;
	double				x, y;
	double				xx, xy;
	int				samples;
	u_int				num;
};

struct ntpd_conf {
	TAILQ_HEAD(listen_addrs, listen_addr)		listen_addrs;
	TAILQ_HEAD(ntp_peers, ntp_peer)			ntp_peers;
	TAILQ_HEAD(ntp_sensors, ntp_sensor)		ntp_sensors;
	TAILQ_HEAD(ntp_conf_sensors, ntp_conf_sensor)	ntp_conf_sensors;
	TAILQ_HEAD(constraints, constraint)		constraints;
	struct ntp_status				status;
	struct ntp_freq					freq;
	struct sockaddr_in				query_addr4;
	struct sockaddr_in6				query_addr6;
	u_int32_t					scale;
	int				        	debug;
	int				        	verbose;
	u_int8_t					listen_all;
	u_int8_t					settime;
	u_int8_t					noaction;
	u_int8_t					filters;
	time_t						constraint_last;
	time_t						constraint_median;
	u_int						constraint_errors;
	u_int8_t					*ca;
	size_t						ca_len;
};

struct ctl_show_status {
	u_int		 peercnt;
	u_int		 sensorcnt;
	u_int		 valid_peers;
	u_int		 valid_sensors;
	u_int8_t	 synced;
	u_int8_t	 stratum;
	double		 clock_offset;
	time_t		 constraint_median;
	time_t		 constraint_last;
	u_int		 constraint_errors;
};

struct ctl_show_peer {
	char		 peer_desc[MAX_DISPLAY_WIDTH];
	u_int8_t	 syncedto;
	u_int8_t	 weight;
	u_int8_t	 trustlevel;
	u_int8_t	 stratum;
	time_t		 next;
	time_t		 poll;
	double		 offset;
	double		 delay;
	double		 jitter;
};

struct ctl_show_sensor {
	char		 sensor_desc[MAX_DISPLAY_WIDTH];
	u_int8_t	 syncedto;
	u_int8_t	 weight;
	u_int8_t	 good;
	u_int8_t	 stratum;
	time_t		 next;
	time_t		 poll;
	double		 offset;
	double		 correction;
};

struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	entry;
	struct imsgbuf		ibuf;
};

TAILQ_HEAD(ctl_conns, ctl_conn)	;

enum imsg_type {
	IMSG_NONE,
	IMSG_ADJTIME,
	IMSG_ADJFREQ,
	IMSG_SETTIME,
	IMSG_HOST_DNS,
	IMSG_CONSTRAINT_DNS,
	IMSG_CONSTRAINT_QUERY,
	IMSG_CONSTRAINT_RESULT,
	IMSG_CONSTRAINT_CLOSE,
	IMSG_CONSTRAINT_KILL,
	IMSG_CTL_SHOW_STATUS,
	IMSG_CTL_SHOW_PEERS,
	IMSG_CTL_SHOW_PEERS_END,
	IMSG_CTL_SHOW_SENSORS,
	IMSG_CTL_SHOW_SENSORS_END,
	IMSG_CTL_SHOW_ALL,
	IMSG_CTL_SHOW_ALL_END
};

enum ctl_actions {
	CTL_SHOW_STATUS,
	CTL_SHOW_PEERS,
	CTL_SHOW_SENSORS,
	CTL_SHOW_ALL
};

/* prototypes */

/* ntp.c */
void	 ntp_main(struct ntpd_conf *, struct passwd *, int, char **);
int	 priv_adjtime(void);
void	 priv_settime(double);
void	 priv_dns(int, char *, u_int32_t);
int	 offset_compare(const void *, const void *);
void	 update_scale(double);
time_t	 scale_interval(time_t);
time_t	 error_interval(void);
extern struct ntpd_conf *conf;
extern struct ctl_conns  ctl_conns;

/* parse.y */
int	 parse_config(const char *, struct ntpd_conf *);

/* config.c */
void			 host(const char *, struct ntp_addr **);
int			 host_dns(const char *, struct ntp_addr **);
void			 host_dns_free(struct ntp_addr *);
struct ntp_peer		*new_peer(void);
struct ntp_conf_sensor	*new_sensor(char *);
struct constraint	*new_constraint(void);

/* ntp_msg.c */
int	ntp_getmsg(struct sockaddr *, char *, ssize_t, struct ntp_msg *);
int	ntp_sendmsg(int, struct sockaddr *, struct ntp_msg *);

/* server.c */
int	setup_listeners(struct servent *, struct ntpd_conf *, u_int *);
int	ntp_reply(int, struct sockaddr *, struct ntp_msg *, int);
int	server_dispatch(int, struct ntpd_conf *);

/* client.c */
int	client_peer_init(struct ntp_peer *);
int	client_addr_init(struct ntp_peer *);
int	client_nextaddr(struct ntp_peer *);
int	client_query(struct ntp_peer *);
int	client_dispatch(struct ntp_peer *, u_int8_t);
void	client_log_error(struct ntp_peer *, const char *, int);
void	set_next(struct ntp_peer *, time_t);

/* constraint.c */
void	 constraint_add(struct constraint *);
void	 constraint_remove(struct constraint *);
void	 constraint_purge(void);
int	 constraint_init(struct constraint *);
int	 constraint_query(struct constraint *);
int	 constraint_check(double);
void	 constraint_msg_dns(u_int32_t, u_int8_t *, size_t);
void	 constraint_msg_result(u_int32_t, u_int8_t *, size_t);
void	 constraint_msg_close(u_int32_t, u_int8_t *, size_t);
void	 priv_constraint_msg(u_int32_t, u_int8_t *, size_t, int, char **);
void	 priv_constraint_child(const char *, uid_t, gid_t);
void	 priv_constraint_kill(u_int32_t);
int	 priv_constraint_dispatch(struct pollfd *);
void	 priv_constraint_check_child(pid_t, int);
char	*get_string(u_int8_t *, size_t);

/* util.c */
double			 gettime_corrected(void);
double			 gettime_from_timeval(struct timeval *);
double			 getoffset(void);
double			 gettime(void);
time_t			 getmonotime(void);
void			 d_to_tv(double, struct timeval *);
double			 lfp_to_d(struct l_fixedpt);
struct l_fixedpt	 d_to_lfp(double);
double			 sfp_to_d(struct s_fixedpt);
struct s_fixedpt	 d_to_sfp(double);
char			*print_rtable(int);
const char		*log_sockaddr(struct sockaddr *);
pid_t			 start_child(char *, int, int, char **);
int			 sanitize_argv(int *, char ***);

/* sensors.c */
void			sensor_init(void);
int			sensor_scan(void);
void			sensor_query(struct ntp_sensor *);

/* ntp_dns.c */
void			ntp_dns(struct ntpd_conf *, struct passwd *);

/* control.c */
int			 control_init(char *);
int			 control_listen(int);
void			 control_shutdown(int);
void			 control_cleanup(const char *);
int			 control_accept(int);
struct ctl_conn		*control_connbyfd(int);
int			 control_close(int);
int			 control_dispatch_msg(struct pollfd *, u_int *);
void			 session_socket_nonblockmode(int);
void			 build_show_status(struct ctl_show_status *);
void			 build_show_peer(struct ctl_show_peer *,
			     struct ntp_peer *);
void			 build_show_sensor(struct ctl_show_sensor *,
			     struct ntp_sensor *);

/* log.c */
void	log_init(int, int);
void	log_procinit(const char *);
void	log_setverbose(int);
int	log_getverbose(void);
void	log_warn(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list)
	    __attribute__((__format__ (printf, 2, 0)));
__dead void fatal(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
@


1.134
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.133 2016/09/26 17:17:01 rzalamena Exp $ */
d156 2
d224 2
@


1.133
log
@Teach ntpd(8) constraint process to use exec*() instead of just forking,
with this change we get the pledge() ability back to the parent process.

some tweaks from and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.132 2016/09/14 13:20:16 rzalamena Exp $ */
d411 2
a412 1
void	log_verbose(int);
@


1.132
log
@Teach ntpd(8) how to fork+exec.

ok reyk@@, bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.131 2016/09/03 11:52:06 reyk Exp $ */
d85 1
a85 1
#define PARENT_SOCK_FILENO		3
d89 1
d361 2
a362 2
void	 priv_constraint_msg(u_int32_t, u_int8_t *, size_t,
	    const char *, uid_t, gid_t);
@


1.131
log
@Remove the oh so funny "LOSS OF MIND" from the diclaimer that was not
part of the original ISC license that we use in OpenBSD.  Done for
files were Henning is the original author.

OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.130 2016/03/27 11:16:12 krw Exp $ */
d85 5
d310 1
a310 1
pid_t	 ntp_main(int[2], int, struct ntpd_conf *, struct passwd *);
d380 2
d389 1
a389 1
pid_t	ntp_dns(int[2], struct ntpd_conf *, struct passwd *);
@


1.130
log
@Rename session_socket_blockmode() to session_socket_nonblockmode(),
removing its second parameter and the enum() that provided the
values for said parameter.

The function was only called with the second parameter set to one
value (BM_NONBLOCKING) from the enum(). So just do the right thing.
Similar to changes made in smtpd.

While here remove the pointless third parameter from the fcntl(F_GETFL)
call.

No functional change.

ok guenther@@ bcook@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.129 2016/01/27 21:48:34 reyk Exp $ */
d15 3
a17 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.129
log
@Don't attempt to kill() the constraint in the wrong process.  The
process management of the contraint processes has been moved from ntp
to the parent, for better privsep and pledge, but the ntp process
still attempted to kill the constraints on timeout directly.  Fix this
regression by introducing a new imsg from ntp to the parent and the
related logic to kill a constraint at the right place.

Reported & tested by bcook@@
Ok bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.128 2016/01/27 21:36:25 bcook Exp $ */
a267 5
enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK
};

d393 1
a393 1
void			 session_socket_blockmode(int, enum blockmodes);
@


1.128
log
@update ntpd log initialization to work like relayd, fix debug log levels

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.127 2015/12/19 20:44:35 reyk Exp $ */
d92 1
d290 1
d362 1
@


1.127
log
@No need for an extra log.h

OK bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.126 2015/12/19 13:58:08 reyk Exp $ */
d216 2
a219 1
	u_int8_t					debug;
@


1.126
log
@Move log_sockaddr() to from log.c to util.c as it is a local addition
and actually not a "logging" function.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.125 2015/11/24 01:03:25 deraadt Exp $ */
d32 1
a33 1
#include "log.h"
a34 1
#include <imsg.h>
d400 21
@


1.125
log
@Cache values from getpwnam() done at initialization, which need to be
used by the constraint processes setup later (chroot, setuid...)
[late getpwnam discovered during a further audit]
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.124 2015/10/30 17:59:56 naddy Exp $ */
d376 1
@


1.124
log
@drop unused define; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.123 2015/10/23 14:52:20 phessler Exp $ */
d358 2
a359 1
void	 priv_constraint_msg(u_int32_t, u_int8_t *, size_t);
@


1.123
log
@Allowing upstream servers of ntp being in multiple routing tables is
non-sensical.  The dns lookups happened in the process routing table
(usually '0'), which is very likely to have different results from the
other routing domains.  If you do depend on having this behaviour,
you'll need to use pf to cross the rtable boundary.

"listen on * rtable X" is still supported.

Users of "server * rtable X" will need to switch to launching ntpd with
"route -T X exec /usr/sbin/ntpd"

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.122 2015/10/12 06:50:08 reyk Exp $ */
a65 1
#define REPORT_INTERVAL		(24*60*60) /* interval between status reports */
@


1.122
log
@Move execution of the constraints from the ntp to the parent process.
This helps the ntp process to a) give a better pledge(2) and to b)
keep the promise of "saving the world again... on time" by removing
the delays that have been introduced by expensive constraint forks.
The new design offers better privsep but introduces a few more imsgs
and runs a little bit more code in the privileged parent.  The
privileged code is minimal, carefully checked, and does not attempt to
"parse" any contents; the forked constraints instantly drop all
privileges and pledge to "stdio inet".

OK beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.121 2015/05/20 13:32:39 reyk Exp $ */
a106 1
	int			 rtable;
a160 1
	int				 rtable;
@


1.121
log
@Remove hotplug(4) sensor support: the code has been disabled by
henning@@ 9 years ago because of an issue with the /dev/hotplug device
- it does not support multiple readers opening it.  Nobody ever cared
enough to fix it so it is time to sent the dead code to the Attic.

OK henning@@ (feeling sad about it), mpi@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.120 2015/05/17 18:31:32 reyk Exp $ */
d117 6
a287 1
	IMSG_CONSTRAINT,
d289 3
d354 1
a356 2
int	 constraint_dispatch_msg(struct pollfd *);
void	 constraint_check_child(void);
d358 7
a364 1
void	 constraint_dns(u_int32_t, u_int8_t *, size_t);
@


1.120
log
@When resolving the "constraint" (singular), store all returned IP
addresses and try one after another until the connection succeeded -
based on the existing mechanism of "server".  "constraint" previously
only tried to connect to the first returned address, aborted and
skipped the constraint on failure.  In difference to "constraints"
(plural), it still only connects to one address at a time and not to
all of them at once.

Pointed out by rpe@@
OK rpe@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.119 2015/02/12 01:54:57 reyk Exp $ */
a369 2
int			sensor_hotplugfd(void);
void			sensor_hotplugevent(int);
@


1.119
log
@Use ntpd's deferred DNS resolving for constraints as well.  This
allows to get constraint addresses even if network/DNS is not
available at startup (or system boot).

thumbs up & OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.118 2015/02/10 06:40:08 reyk Exp $ */
d344 2
@


1.118
log
@Add support for "constraints": when configured, ntpd(8) will query the
time from HTTPS servers, by parsing the Date: header, and use the
median constraint time as a boundary to verify NTP responses.  This
adds some level of authentication and protection against MITM attacks
while preserving the accuracy of the NTP protocol; without relying on
authentication options for NTP that are basically unavailable at
present.  This is an initial implementation and the semantics will be
improved once it is in the tree.

Discussed with deraadt@@ and henning@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.117 2015/01/13 02:28:56 bcook Exp $ */
d283 1
d306 1
a306 1
void	 priv_host_dns(char *, u_int32_t);
d349 1
@


1.117
log
@fix some memory leaks in dns handling.

 - Nothing seems to free the result of host_dns(), so add host_dns_free() and
   call after each query.
 - If imsg_add() fails, it frees buf. Avoid subsequently dereferencing the
   freed buf in imsg_close().

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.116 2015/01/10 13:47:05 tedu Exp $ */
d75 1
a75 1
#define	SENSOR_SCAN_INTERVAL		(5*60)
d78 9
d93 2
a94 1
	STATE_REPLY_RECEIVED
d112 1
d174 14
d210 1
d219 5
d234 3
d282 1
d322 1
d342 7
d351 1
@


1.116
log
@don't check for a return value that host() doesn't return, so future
generations don't try to change any of the values and break the code.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.115 2015/01/09 07:35:37 deraadt Exp $ */
d284 1
@


1.115
log
@remove excessive/wrong use of sys/param.h
peanuts -- but all work has to start somewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.114 2015/01/08 00:30:08 bcook Exp $ */
d282 1
a282 1
int			 host(const char *, struct ntp_addr **);
@


1.114
log
@sync log.c from smtpd.

Reduces the number of log.c snowflakes by a little, and gives ntpd a
variadic fatal() function to be used later.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.113 2015/01/04 01:48:49 bcook Exp $ */
d68 1
a68 1
#define	MAX_DISPLAY_WIDTH	80 	/* max chars in ctl_show report line */
d206 1
a206 1
	char 		 peer_desc[MAX_DISPLAY_WIDTH];
d333 1
a333 1
struct ctl_conn 	*control_connbyfd(int);
@


1.113
log
@use MAXIMUM as the canonical local MAX macro.

suggested by deraadt@@ re: more general MIN/MAX cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.112 2015/01/04 01:13:10 bcook Exp $ */
d33 1
a264 11
/* log.c */
void		 log_init(int);
void		 logit(int, const char *, ...);
void		 vlog(int, const char *, va_list);
void		 log_warn(const char *, ...);
void		 log_warnx(const char *, ...);
void		 log_info(const char *, ...);
void		 log_debug(const char *, ...);
void		 fatal(const char *);
void		 fatalx(const char *);
const char	*log_sockaddr(struct sockaddr *);
@


1.112
log
@removed unused libevent header and structures in ntpd.h

ok deraadt@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.111 2014/11/03 20:15:30 bluhm Exp $ */
d35 2
@


1.111
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.110 2014/10/25 03:23:49 lteo Exp $ */
a30 1
#include <event.h>
a191 8
struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	void			*data;
	short			 events;
};

a233 1
	struct imsgev		iev;
@


1.110
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.109 2014/01/22 02:55:15 benno Exp $ */
d274 1
@


1.109
log
@allow -s<abrev> in addition to -s <word> in ntpctl commandline, like
all the other tools do. changes option 'sensors' to 'Sensors'.
ok henning@@, and grudgingly phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.108 2013/10/04 14:28:16 phessler Exp $ */
a25 1
#include <netinet/in_systm.h>
@


1.108
log
@Add ntpctl(8), which allows us to query the locally running ntpd(8) process

diff from Mike Miller <mmiller mgm51 com> (many thanks!)

OK phessler@@, henning@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.107 2013/04/30 11:42:56 mglocker Exp $ */
a265 1
	CTL_SHOW,
@


1.107
log
@Remove unused function argument variables 'len' and 'auth' from
ntp_sendmsg().  They have been removed from the function body in the past
but not from the argument list.

From Maxime Villard
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.106 2012/09/20 12:43:16 patrick Exp $ */
d5 1
d32 2
d41 1
d67 1
d75 1
d137 1
d194 56
d255 16
a270 1
	IMSG_HOST_DNS
d286 1
a286 1
pid_t	 ntp_main(int[2], struct ntpd_conf *, struct passwd *);
d295 1
d345 16
@


1.106
log
@Allow ntpd.conf to assign a stratum to a sensor with the syntax stratum <level>.

OK markus@@ henning@@ phessler@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.105 2011/09/21 16:38:05 phessler Exp $ */
d229 1
a229 1
int	ntp_sendmsg(int, struct sockaddr *, struct ntp_msg *, ssize_t, int);
@


1.105
log
@fix the two most offensive indentation violations in here.

pointed out by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.104 2011/09/21 15:41:30 phessler Exp $ */
d150 1
d160 1
@


1.104
log
@Add rdomain support to NTPd.

This basically adds the "rtable %d" keyword to "listen on", "server",
"servers" keywords, to specify which routing table to use.

OK henning@@ claudio@@ sthen@@
manpage reviewed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.103 2009/06/06 18:45:01 ckuethe Exp $ */
d203 1
a203 1
const char *	 log_sockaddr(struct sockaddr *);
d244 9
a252 9
double			gettime_corrected(void);
double			getoffset(void);
double			gettime(void);
time_t			getmonotime(void);
void			d_to_tv(double, struct timeval *);
double			lfp_to_d(struct l_fixedpt);
struct l_fixedpt	d_to_lfp(double);
double			sfp_to_d(struct s_fixedpt);
struct s_fixedpt	d_to_sfp(double);
@


1.103
log
@Turns up the polling rate of sensors and makes ntpd calculate frequency
corrections more often. Due to physical effects crystal oscillators aren't
really stable beyond 1000s or so - at least not the kind found in pc's.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.102 2009/06/06 18:14:25 pyr Exp $ */
d84 1
d90 1
d137 1
d253 1
@


1.102
log
@make ntpd imsg-in-a-lib ready as well. extensive testing done, no
behavior change.
ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.101 2009/06/04 23:39:46 ckuethe Exp $ */
d55 1
a55 1
#define	SENSOR_OFFSETS		7
d67 1
a67 1
#define	SENSOR_QUERY_INTERVAL		30
@


1.101
log
@After calling adjfreq to correct the clock's rate, measure and fix the clock
offset. This avoids future frequency adjustments based on measurements of a
clock that was being adjusted. End result: more stable clock and better
frequency convergence.

Also, fix a mis-ordered structure member while I'm here.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.100 2009/05/13 15:08:10 stevesk Exp $ */
d33 1
a38 2
#define	READ_BUF_SIZE		8192

a181 32
struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 wpos;
	size_t			 rpos;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

struct buf_read {
	size_t			 wpos;
	u_char			 buf[READ_BUF_SIZE];
	u_char			*rptr;
};

/* ipc messages */

#define	IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
#define	MAX_IMSGSIZE		8192

struct imsgbuf {
	int			fd;
	pid_t			pid;
	struct buf_read		r;
	struct msgbuf		w;
};

a189 12
struct imsg_hdr {
	enum imsg_type	type;
	u_int32_t	peerid;
	pid_t		pid;
	u_int16_t	len;
};

struct imsg {
	struct imsg_hdr	 hdr;
	void		*data;
};

a200 21

/* buffer.c */
struct buf	*buf_open(size_t);
int		 buf_add(struct buf *, void *, size_t);
int		 buf_close(struct msgbuf *, struct buf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);

/* imsg.c */
void	 imsg_init(struct imsgbuf *, int);
int	 imsg_read(struct imsgbuf *);
int	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    void *, u_int16_t);
struct buf	*imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
		    u_int16_t);
int	 imsg_add(struct buf *, void *, u_int16_t);
int	 imsg_close(struct imsgbuf *, struct buf *);
void	 imsg_free(struct imsg *);
@


1.100
log
@when using a timedelta sensor for -s, if the sensor is invalid during
the first query we will never do the settime because
SENSOR_QUERY_INTERVAL (30s) is greater than SETTIME_TIMEOUT (15s).  so
during the settime period only, be more aggressive and use
SETTIME_TIMEOUT/3 for the query interval.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.99 2009/02/11 01:00:10 stevesk Exp $ */
d65 1
d175 1
a178 1
	u_int32_t					scale;
d180 1
@


1.99
log
@move prototypes that are really in ntp.c; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.98 2009/02/10 16:52:09 stevesk Exp $ */
d66 4
a69 3
#define	SENSOR_DATA_MAXAGE	(15*60)
#define	SENSOR_QUERY_INTERVAL	30
#define	SENSOR_SCAN_INTERVAL	(5*60)
@


1.98
log
@log tiny frequency adjustments at debug only.
ok henning@@, 'I think I agree' otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.97 2009/02/06 21:48:00 stevesk Exp $ */
d271 3
a300 3
void	update_scale(double);
time_t	scale_interval(time_t);
time_t	error_interval(void);
@


1.97
log
@rename a #define to be clearer; no binary change
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.96 2008/09/12 10:46:09 henning Exp $ */
d59 1
@


1.96
log
@move dns lookups to its own (privilege revoking, not chrooting) process.
reason: the parent process must never ever block, but the dns routines can.
last not least this fixes ntpd -s 'hanging' for a long time.
tested by a couple of people
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.95 2008/06/10 03:46:09 naddy Exp $ */
d58 1
a58 1
#define	LOG_NEGLIGEE		32	/* negligible drift to not log (ms) */
@


1.95
log
@According to the latest SNTPv4 spec in RFC4330, secondary servers
return the address of the synchronization source as reference
identification.  Remove the obsolete special casing specified in RFC2030.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.94 2008/06/09 18:30:48 deraadt Exp $ */
d319 3
@


1.94
log
@rename refstr to refid since it is an int32; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.93 2008/06/09 16:37:35 ckuethe Exp $ */
a99 1
	u_int32_t	refid4;
@


1.93
log
@Allow outgoing replies from sensor-driven servers to have a
user-configurable reference ID, eg. "GPS" or "DCF"...
ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.92 2008/05/16 06:13:25 ckuethe Exp $ */
d143 1
a143 1
	u_int32_t			 refstr;
@


1.92
log
@Allow ntpd to step the time at startup, now matter how large or small the
offset. The 180s limit doesn't help very much these days.
ok otto@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.91 2008/01/28 11:45:59 mpf Exp $ */
d143 1
d153 1
@


1.91
log
@Reconnect a client socket after three consecutive send failures.
This allows recovery after an IP address change (e.g. on dialup links).
Also move the update of "nextaction" timeout below the deadline check.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.90 2007/12/23 18:39:50 stevesk Exp $ */
a56 1
#define	SETTIME_MIN_OFFSET	180	/* min offset for settime at start */
@


1.90
log
@remove some unused #defines; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.89 2007/12/22 18:26:21 stevesk Exp $ */
d63 1
d134 1
@


1.89
log
@just call getpwnam(NTPD_USER) once; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.88 2007/10/15 06:59:32 otto Exp $ */
a38 3

#define	NTPD_OPT_VERBOSE	0x0001
#define	NTPD_OPT_VERBOSE2	0x0002
@


1.88
log
@Allow ntpd to report the status of peers and sensors to syslog. This
happens when a SIGINFO is received, or when the majority of peers or
sensors is bad. The latter with a maximum of once per 24 hour.
ok henning@@ ckuethe@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.87 2007/09/13 14:34:36 pyr Exp $ */
d29 1
d266 1
a266 1
pid_t	 ntp_main(int[2], struct ntpd_conf *);
@


1.87
log
@Provide the -n switch like in the other imsg daemons for testing
the configuration file.
"yes please, ok" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.86 2007/09/12 21:08:46 ckuethe Exp $ */
d64 1
@


1.86
log
@
Add a knob to compensate for a refclock that is early or late. Based on a
diff from Maurice Janssen. Manpage help from jmc and Maurice, other nits
from deraadt and otto.
ok deraadt, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.85 2007/08/04 02:58:02 ckuethe Exp $ */
d175 1
@


1.85
log
@This diff makes ntpd poll for sensors more aggressively when the use of
sensors is requested, but no sensors are found.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.84 2007/04/30 01:33:33 deraadt Exp $ */
d144 1
d152 1
@


1.84
log
@aggressive spelling fix, spotted by jbg
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.83 2007/03/23 14:22:40 ckuethe Exp $ */
d311 1
a311 1
void			sensor_scan(void);
@


1.83
log
@Increase sensor polling interval to 30s, just like ntp polls. This
improves sensor timekeeping significantly.

Before this patch my test system's frequency adjustment would range
between -350 and +250, with timedelta rarely getting close to 0. After,
frequency adjustmens is on the order of +/- 0.05ppm, with time +/- a
few microseconds away from 0

ok henning, mbalmer, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.82 2007/03/01 17:50:42 henning Exp $ */
d44 1
a44 1
#define	INTERVAL_QUERY_AGRESSIVE	5
d48 1
a48 1
#define	TRUSTLEVEL_AGRESSIVE		8
@


1.82
log
@read buffer size must be >= max imsg size.
after release we should revisit this issue, we can probably safely shrink
the max imsg size.
Valentin Kozamernik in PR5401
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.81 2007/01/15 08:19:11 otto Exp $ */
d67 1
a67 1
#define	SENSOR_QUERY_INTERVAL	5
@


1.81
log
@Although Unix compilers accept more than one definition of a global
symbol, follow the guidelines from K&R: only one definition of a
global symbol (and possibly more declarations).  Rename some vars
here and there to avoid shadowing. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.80 2006/12/23 17:49:53 deraadt Exp $ */
d37 1
a37 1
#define	READ_BUF_SIZE		4096
@


1.80
log
@adapt to new two-level sensor sysctl framework; by Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.79 2006/11/20 20:58:47 henning Exp $ */
d266 1
d310 1
a310 1
void			sensor_init(struct ntpd_conf *);
@


1.79
log
@with usig the meadian offset froma number of measurements the recording
of the last sensor update time got broken, doesn't show up with gps since
it updates often (more often than we read), but naddy ran into it with dcf.
record time of last sensor datum seperately. ok naddy balmer
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.78 2006/10/27 12:22:41 henning Exp $ */
d143 1
a143 1
	int				 sensorid;
@


1.78
log
@use clock_gettime(CLOCK_MONOTONIC, ..) to get a monotonically increasing
time, and make ntpd use that to send the next uery to an ntp peer and the
like. this has the advantage that changes to the clock do not interfere
with the intervals. for example, when we start on machines without an
RTC and the initial settime (-s) kicks in, intervals were strange.
idea from amandal@@entrisphere.com, this implementation by me
tested ckuethe, phessler, mbalmer, ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.77 2006/10/24 12:23:39 henning Exp $ */
d141 1
@


1.77
log
@timedelta sensors are usually updated very often, but we used to query
them only every 30 seconds. now query them every 5,and take the median
value from 7 queries as sensor value. this takes outliers out of the
equation and makes the overall result much better, especially for
sensors with heavy jitter (like nmea for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.76 2006/06/30 16:52:13 deraadt Exp $ */
d300 1
@


1.76
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.75 2006/06/26 09:43:06 otto Exp $ */
d58 1
d67 1
a67 1
#define	SENSOR_QUERY_INTERVAL	30
d138 1
d144 1
d264 1
@


1.75
log
@increase polling intervbal, but only after we are synced and have done
a few frequency adjustments. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.74 2006/06/22 11:11:25 otto Exp $ */
d162 1
a162 1
	TAILQ_HEAD(ntp_conf_sensors, ntp_conf_sensor)	ntp_conf_sensors;	
@


1.74
log
@Save the computed clock drift and use it on startup. ok deraadt@@
henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.73 2006/06/18 19:38:11 otto Exp $ */
d53 2
a54 2
#define	QSCALE_OFF_MIN			0.05
#define	QSCALE_OFF_MAX			0.50
d155 1
@


1.73
log
@tsk, tsk, tsk... the rule is simple: any define consisting of
more than one token MUST be put in parentheses!
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.72 2006/06/17 18:40:42 otto Exp $ */
d35 1
@


1.72
log
@Import frequency conrrection code from dragonfly, whith some changes:
only do frequency compensation if the clock is synced, and a slightly
diffent way of computing the linear regression.
You'll need a recent kernel and libc to use this.
Testing by naddy@@ and ckuethe@@ and others, thanks!
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.71 2006/06/07 06:29:03 otto Exp $ */
d64 1
a64 1
#define	SENSOR_DATA_MAXAGE	15*60
d66 1
a66 1
#define	SENSOR_SCAN_INTERVAL	5*60
@


1.71
log
@Compensate old offsets with the amount of adjustment done, avoiding
overcompensating. From DragonFly, uses recent adjtime(2) changes,
so you'll need a recent kernel. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.70 2006/06/04 18:58:13 otto Exp $ */
d59 4
a62 1
#define	LOG_NEGLIGEE		128	/* negligible drift to not log (ms) */
d149 7
d162 1
d204 1
@


1.70
log
@Only invalidate stored replies if an adjustment was really made.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.69 2006/05/28 20:39:16 henning Exp $ */
d279 2
@


1.69
log
@allow for weight to be added to sensors or servers, so that one can
weight timedelta sensors higher than ntp peers, for example
ok deraadt mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.68 2006/05/28 18:47:25 henning Exp $ */
d244 1
a244 1
void	 priv_adjtime(void);
@


1.68
log
@let sensor_query handle removals itself
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.67 2006/05/27 22:22:47 henning Exp $ */
d127 1
d137 1
d143 1
@


1.67
log
@stop passing the config around all time, just store one copy
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.66 2006/05/27 21:27:34 henning Exp $ */
d286 1
a286 2
void			sensor_remove(struct ntp_sensor *);
int			sensor_query(struct ntp_sensor *);
@


1.66
log
@make ntpd listen on the hotplug socket and decode yadda yadda, because
new sensors showing up will be announced that way when slacking ml comes
back from food
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.65 2006/05/27 18:32:00 henning Exp $ */
d285 2
a286 2
void			sensor_scan(struct ntpd_conf *);
void			sensor_remove(struct ntpd_conf *, struct ntp_sensor *);
@


1.65
log
@scan for new timedelta sensors every five minutes for now, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.63 2006/05/26 00:33:16 henning Exp $ */
d288 2
@


1.64
log
@config file bits for timedelta sensors, so one can specify which devices
to use. "sensors *" just uses all. untested due to lack of hardware.
hacked on the road somewhere between vancouver and calgary
@
text
@d63 1
@


1.63
log
@add support for timedelta sensors, which pretty much means udcf(4) right
now. untested due to lack of hardware, and it wouldn't have worked in the
plane anyways. work in progress, currently picks up and uses all sensors
it finds, config file bits to be added soon. theo fine with this going in
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.62 2006/05/25 19:25:46 henning Exp $ */
d137 5
d143 9
a151 8
	TAILQ_HEAD(listen_addrs, listen_addr)	listen_addrs;
	TAILQ_HEAD(ntp_peers, ntp_peer)		ntp_peers;
	TAILQ_HEAD(ntp_sensors, ntp_sensor)	ntp_sensors;
	struct ntp_status			status;
	u_int8_t				listen_all;
	u_int8_t				settime;
	u_int8_t				debug;
	u_int32_t				scale;
d248 4
a251 3
int		 host(const char *, struct ntp_addr **);
int		 host_dns(const char *, struct ntp_addr **);
struct ntp_peer	*new_peer(void);
@


1.62
log
@figure out the refid to send to NTP v3 clients early and store it
first bits from a way to long flight
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.61 2005/09/24 00:32:03 dtucker Exp $ */
d61 3
d129 8
d140 1
d274 6
@


1.61
log
@Log source address for 'malformed packet' errors.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.60 2005/08/10 13:48:36 dtucker Exp $ */
d93 1
@


1.60
log
@Propogate server's leap indicator flags to clients; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.59 2005/07/15 03:37:15 henning Exp $ */
d234 1
a234 1
int	ntp_getmsg(char *, ssize_t, struct ntp_msg *);
@


1.59
log
@shrink read buffer size from 64k to 4k, this is not bgpd and we're dealing
with way less data
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.58 2005/07/05 10:09:12 dtucker Exp $ */
d93 1
@


1.58
log
@Save transmit time for each peer for later use as refid for SNTPv4
replies.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.57 2005/06/19 17:11:13 henning Exp $ */
d36 1
a36 1
#define	READ_BUF_SIZE		65535
@


1.57
log
@use a #define for the time to wait on -s and clarify a log msg
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.56 2005/06/19 16:42:57 henning Exp $ */
d92 1
@


1.56
log
@use a little state engine to keep track of delayed dns lookups and such,
eases things
tested by Jason Ackley <jason@@ackley.net> Matthias Kilian
<kili@@outback.escape.de> Stephen Marley <stephen@@marley.org.uk> sturm@@
theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.55 2005/04/26 15:18:22 henning Exp $ */
d58 1
@


1.55
log
@unify shared code a bit again to make future syncs easier
From: Alexander von Gernler <grunk@@pestilenz.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.54 2005/03/23 10:42:04 henning Exp $ */
d62 3
@


1.54
log
@wpos in struct buf_read and datalen in imsg_get should be size_t and not
ssize_t
From: Alexander von Gernler <grunk@@pestilenz.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.53 2005/02/03 10:53:33 dtucker Exp $ */
d130 1
a130 1
	TAILQ_ENTRY(buf)	 entries;
d138 1
a138 1
	TAILQ_HEAD(bufs, buf)	 bufs;
@


1.53
log
@Implement simple duplicate suppression of peer errors; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.52 2005/02/02 18:57:09 henning Exp $ */
d144 1
a144 1
	ssize_t			 wpos;
@


1.52
log
@buffer structs and API ssize_t -> size_t; from bgpd
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.51 2005/01/28 12:37:20 dtucker Exp $ */
d116 1
d242 1
@


1.51
log
@Simplify interval scaling and randomize query intervals; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.50 2005/01/27 14:44:00 dtucker Exp $ */
d131 3
a133 3
	ssize_t			 size;
	ssize_t			 wpos;
	ssize_t			 rpos;
d192 2
a193 2
struct buf	*buf_open(ssize_t);
int		 buf_add(struct buf *, void *, ssize_t);
@


1.50
log
@Scale query interval by the overall offset not per-peer offset, so we
don't query outliers more often than any other server.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.49 2005/01/27 10:32:29 dtucker Exp $ */
a53 1
#define	QSCALE_FACTOR			1000
@


1.49
log
@Delay before retrying a query on timeout; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.48 2004/12/16 00:38:59 dtucker Exp $ */
d54 1
d126 1
d242 3
a244 1
time_t	scale_interval(time_t, double);
@


1.48
log
@Limit the number of addresses used by the 'servers' directive to 8; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.47 2004/12/09 20:24:46 mickey Exp $ */
d240 2
@


1.47
log
@define TRUSTLEVEL_MAX for the trustedlevel value of 10; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.46 2004/12/06 20:57:17 mickey Exp $ */
d49 2
@


1.46
log
@do not log tiny local clock drifts; w/ help from Joerg Sonnenberger <joerg@@britannica.bec.de>; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.45 2004/12/06 16:52:33 mickey Exp $ */
d48 1
@


1.45
log
@ensure the most excellent alignment in the structs; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.44 2004/11/12 17:24:52 henning Exp $ */
d55 1
@


1.44
log
@some missing includes, from Joerg Sonnenberger <joerg@@britannica.bec.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.43 2004/11/10 11:47:28 henning Exp $ */
d75 1
a76 1
	struct ntp_addr		*a;
a79 2
	u_int8_t	leap;
	int8_t		precision;
d82 1
d84 2
a85 1
	double		reftime;
d91 1
a91 1
	u_int8_t		good;
d96 1
a96 1
	struct ntp_status	status;
a100 1
	u_int32_t			 id;
d104 2
d109 1
a109 2
	struct ntp_offset		 reply[OFFSET_ARRAY_SIZE];
	struct ntp_offset		 update;
d117 1
a120 1
	struct ntp_status			status;
d132 1
a134 1
	TAILQ_HEAD(bufs, buf)	 bufs;
d138 1
a140 1
	ssize_t			 wpos;
a163 1
	u_int16_t	len;
d166 1
@


1.43
log
@ntp_adjtime() -> priv_adjtime()
ntp_settime() -> priv_settime()
ntp_host_dns() -> priv_host_dns()
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.42 2004/11/10 11:27:54 henning Exp $ */
d23 1
@


1.42
log
@const'ify conffile
From: Joerg Sonnenberger <joerg@@britannica.bec.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.41 2004/10/22 21:17:37 henning Exp $ */
d208 3
a210 3
void	 ntp_adjtime(void);
void	 ntp_settime(double);
void	 ntp_host_dns(char *, u_int32_t);
@


1.41
log
@in server mode reply with stratum from the peer that we currently prefer
plus one
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.40 2004/10/14 09:35:48 dtucker Exp $ */
d213 1
a213 1
int	 parse_config(char *, struct ntpd_conf *);
@


1.40
log
@Have ntpd use IPTOS_LOWDELAY; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.39 2004/09/18 20:27:57 henning Exp $ */
d86 1
@


1.39
log
@don't call settimeofday() when the offset is smaller than 180 seconds,
adjtime() will fix that fast enough, from discussion in theo's living room
ok mcbride beck
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.38 2004/09/18 20:01:38 henning Exp $ */
d24 2
@


1.38
log
@add a new -s option, that tells ntpd to set the time using settimeofday()
once at startup. ntpd delays daemonizing until it has done the intial
time setting (or ran into the timeout) in this mode to make sure stuff started
later in rc is not subject to time jumps.
this eleminates the need to run rdate -n beforehands.
with some input from & ok ryan and bob, march music from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.37 2004/09/18 07:33:14 henning Exp $ */
d51 1
@


1.37
log
@do not bother overallocating and shrinking the pfd and idx2peer arrays,
doesn't by us anything. discussed with ryan during dinner at original joe's
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.36 2004/09/16 01:13:42 henning Exp $ */
a111 1
	u_int8_t				opts;
d113 2
d153 1
d205 1
d230 1
a230 1
int	client_dispatch(struct ntp_peer *);
@


1.36
log
@the "type" param to imsg_compose and imsg_create is really an
enum imsg_type and not an int
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.35 2004/09/15 19:21:25 henning Exp $ */
a33 2
#define	IDX2PEER_RESERVE	5
#define	PFD_RESERVE		10
@


1.35
log
@imsg framework cleanup:
-kill the _pid flavors of imsg_create and imsg_compose, and just add pid as
argument to those
-use imsg_create in imsg_compose instead of duplicating code
-check for datalen overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.34 2004/09/15 00:18:12 henning Exp $ */
d194 3
a196 3
int	 imsg_compose(struct imsgbuf *, int, u_int32_t, pid_t, void *,
	    u_int16_t);
struct buf	*imsg_create(struct imsgbuf *, int, u_int32_t, pid_t,
@


1.34
log
@remove the unused variable/macro code, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.33 2004/08/12 16:33:59 henning Exp $ */
d194 4
a197 4
int	 imsg_compose(struct imsgbuf *, int, u_int32_t, void *, u_int16_t);
int	 imsg_compose_pid(struct imsgbuf *, int, pid_t, void *, u_int16_t);
struct buf *imsg_create(struct imsgbuf *, int, u_int32_t, u_int16_t);
struct buf *imsg_create_pid(struct imsgbuf *, int, pid_t, u_int16_t);
@


1.33
log
@do not try to getaddrinfo() in the unprivileged process, send an imsg
asking the privileged one to do it. sends back an imsg with the
resulting addresses in a bunch of struct sockaddr_storage in the data
part.
this should fix all remaining issues with dns (non-)availability at
ntpd startup, be it due to named on localhost or something else.
tested by marco@@ and Chris Paul <chris.paul@@sentinare.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.32 2004/08/10 12:41:15 henning Exp $ */
a208 1
int	 cmdline_symset(char *);
@


1.32
log
@move memory allocation for new peers into a new function, makes ID allocation
easier
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.31 2004/07/29 11:01:48 henning Exp $ */
d153 2
a154 1
	IMSG_ADJTIME
d205 1
d227 1
@


1.31
log
@keep an ID per server we talk to
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.30 2004/07/28 16:38:43 henning Exp $ */
d210 3
a212 2
int	 host(const char *, struct ntp_addr **);
int	 host_dns(const char *, struct ntp_addr **);
@


1.30
log
@when a dns lookup fails at parse time, do not abort but try again
to resolve the hostname every 60 seconds
fixes ntpd invocations before e. g. a dialup link is established and such.
as we want ntpd to be a "fire and forget" background daemon it should
cope with such situations.
tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.29 2004/07/25 18:27:58 henning Exp $ */
d98 1
@


1.29
log
@remove unused function
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.28 2004/07/20 16:47:55 henning Exp $ */
d209 2
a210 1
struct ntp_addr	*host(const char *);
@


1.28
log
@wrap the heads for the linked list of addresses into a new ntp_addr_wrap
which, besides the head pointer for the list of course, stores the original
address as specified (i. e. as hostname instead of resolved IPs) and flags
and such.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.27 2004/07/18 12:59:41 henning Exp $ */
a208 1
int		 check_file_secrecy(int, const char *);
@


1.27
log
@query interval scaling, episode II
1) base the interval calculation on the offset from the last reply, not
   from the last peer update.
   Allows us to send more queries again faster when the local clock
   diverges too much
2) every time we form a peer update (for which we need 8 replies)
   check wether we have a ready peer update for all peers that are
   currently trusted, and if so, calculate the total offset and call
   adjtime().
   that means that adjtime is no longer called in fixed intervals
   but whenever we have enough data to reliably calculate the local
   clock offset.
   In practice, that means we call adjtime() less often, but with
   probably better data.
3) invalidate peer updates after beeing used. no point in re-using them
   - this resulted in calling adjtime() multiple times with the same
   offset, which doesn't make sense
tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.26 2004/07/14 20:16:31 henning Exp $ */
d71 6
d98 1
a98 1
	struct ntp_addr			*addr_head;
@


1.26
log
@do not do the stratum guessing dance.
stratum is pretty much pointless anyway these days, and we certainly
do not want to send out illegal packets (stratum=0) until synced...
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.25 2004/07/13 19:41:26 alexander Exp $ */
a39 1
#define	INTERVAL_ADJTIME		240	/* call adjtime every n secs */
d49 1
a49 1
#define	QSCALE_OFF_MAX			1
a51 1
#define	REPLY_MAXAGE		720
d196 1
@


1.25
log
@Respond to client queries with better server statistics.  We now output
a close-to-reality stratum, a real reference time, and a leap indicator
that will indicate if the local clock isn't synchronized.

This also means that until the server feels it's synchronized, it will
tell the clients it isn't.  This is normal, and correct.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.24 2004/07/11 00:15:10 alexander Exp $ */
a74 1
	u_int8_t	stratum;
@


1.24
log
@Start collecting the remote server state along with the calculated
offsets, in preparation for having correct server statistics in
responses to client queries.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.23 2004/07/10 23:12:57 alexander Exp $ */
d112 1
d215 1
a215 1
int	server_dispatch(int);
@


1.23
log
@KNF; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.22 2004/07/10 22:24:20 alexander Exp $ */
d73 11
d85 6
a90 5
	u_int8_t	good;
	double		offset;
	double		delay;
	double		error;
	time_t		rcvd;
@


1.22
log
@short fixed point <-> double conversion routines; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.21 2004/07/10 18:42:51 henning Exp $ */
d202 1
a202 1
int	server_dispatch(int fd);
d211 6
a216 6
double	gettime(void);
void	d_to_tv(double, struct timeval *);
double	lfp_to_d(struct l_fixedpt);
struct	l_fixedpt d_to_lfp(double);
double	sfp_to_d(struct s_fixedpt);
struct	s_fixedpt d_to_sfp(double);
@


1.21
log
@scale query interval based on local clock offset. tested by many
not as efficient as I want it to be yet, but more is coming
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.20 2004/07/09 19:44:18 deraadt Exp $ */
d215 2
@


1.20
log
@make lint a wee bit happier
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.19 2004/07/09 10:53:33 henning Exp $ */
d49 3
d53 1
a53 1
#define	REPLY_MAXAGE		300
d90 1
@


1.19
log
@rework dns handling with all its cosequences...
we know have both a "server" and "servers" keyword. they differ when the
hostname resolves to more than one IP, server picks one and servers expands
to all.
that means no longer stuffing a sockaddr_storage into ntp_peer but a pointer
to a linked list of ntp_addr structs.
in the "servers" case the list of n addresses returned by host() is expanded
into n ntp_peer structs and thus n individual peers.
in the "server" case the whole list is attached to ntp_peer, and whenever we
do not receive a reply in time we traverse the list one further, so that
hosts with both AAAA and A records are first tried with the AAAA one but
we gracefully fall back to the A one.
semantics with theo; hacked up on the Montreal->Frankfurt flight.
again Air Canada surprised me, that older 767 hat pretty decent seats.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.18 2004/07/08 01:22:57 henning Exp $ */
d20 1
@


1.18
log
@remove all handling of netmasks/prefix lengths - we don't need that in ntpd.
fixes the dns resolves to v4 and v6 addresses bug found by phessler
hacked on the Calgary->Montreal flight that proved that Air Canada _does_
have some modern aircrafts with good seats
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.17 2004/07/07 07:32:05 alexander Exp $ */
d79 2
a80 1
	struct sockaddr_storage		 ss;
d201 1
@


1.17
log
@* Convert to use the new double-based time handling functions.
* Respond to the query with a reasonable received time (which
  will help clients get better accuracy).
* Consolidate the server response code in preparation for a
  completely 'proper' response to the client.

tips and ok from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.16 2004/07/07 05:47:57 henning Exp $ */
d187 1
a187 1
struct ntp_addr	*host(const char *, u_int8_t *);
@


1.16
log
@do not listen anywhere by default.
listen on *
listens, well, everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.15 2004/07/07 03:15:37 henning Exp $ */
a189 1
void	get_ts(struct l_fixedpt *);
d196 1
@


1.15
log
@swicth all the host_* functions to work on a newly invented
struct ntp_addr, which just wraps a sockaddr_storage and a next pointer,
so that host_dns can return more than one entry.
let host_dns do exactly that, return a list of all IPs for that hostname
adjust all callers in the grammar to cope with that
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.14 2004/07/07 01:01:27 henning Exp $ */
d93 1
@


1.14
log
@keep a "trustlevel" per peer. loose credit for loosing a packet, loose
a lot of credit for not having supplied us with enough data within an
adjtime run interval, and get a little credit each time we get a good
reply packet. if a peer is below 20%, only send a packet occasionally to
see wether it is back. send out queries much more often between 20 and 80%
to (re-)sync quickly, and above 80% usethe regular interval.
do not use peers < 60% for calculating teh local clock offset.
designed with theo at the pho, alexander ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.13 2004/07/06 23:26:38 henning Exp $ */
d64 5
d185 2
a186 2
int	 check_file_secrecy(int, const char *);
int	 host(const char *, struct sockaddr *, u_int8_t *);
@


1.13
log
@Implement the clock filter as descirbed by David Mills:
form the last 8 replied received from a peer, find the one with the lowest
delay. Use that as the peer's update taken into account for calculating
the local clock's offset.
Invalidate that reply and all ones received earlier than it so that they do
not get used again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.12 2004/07/05 22:12:53 henning Exp $ */
d39 9
a47 2
#define	INTERVAL_ADJTIME	240	/* call adjtime every n seconds */
#define	INTERVAL_QUERY		30	/* sync with peers every n seconds */
d49 1
d81 1
a81 1
	u_int8_t			 valid;
@


1.12
log
@keep last 8 offset,delay pairs - we'll need them for the clock filters later.
for now, average over those to adjust the local clock.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.11 2004/07/05 20:41:35 henning Exp $ */
d39 1
a39 1
#define	INTERVAL_ADJTIME	120	/* call adjtime every n seconds */
d56 8
d71 1
a71 2
	double				 offset[OFFSET_ARRAY_SIZE];
	double				 delay[OFFSET_ARRAY_SIZE];
@


1.11
log
@delay, not error
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.10 2004/07/05 07:46:16 henning Exp $ */
d40 3
a42 2
#define	INTERVAL_QUERY		60	/* sync with peers every n seconds */
#define	QUERYTIME_MAX		30	/* single query might take n secs max */
d63 4
a66 2
	double				 offset;
	double				 delay;
@


1.10
log
@calculate the median offset from all servers we sync to and call
adjtime() when necessary to keep the local clock in sync
yes, that means ntpd syncs the local clock now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.9 2004/07/04 22:24:20 henning Exp $ */
d63 1
a63 1
	double				 error;
@


1.9
log
@put interval defines in ntpd.h and name them consistently
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.8 2004/07/04 11:01:49 alexander Exp $ */
d39 1
d105 2
a106 1
	IMSG_NONE
d181 1
@


1.8
log
@Compute the local clock offset from the server's response.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.7 2004/06/18 04:51:31 henning Exp $ */
d36 5
a40 2
#define	NTPD_OPT_VERBOSE		0x0001
#define	NTPD_OPT_VERBOSE2		0x0002
@


1.7
log
@size struct pollfd and idx2peer dynamically instead of imposing an arbitary
limit on OPEN_MAX, modeled after bgpd
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.6 2004/06/17 19:17:48 henning Exp $ */
d58 2
d173 5
@


1.6
log
@provide most of the client functionality.
hook the descriptors into the main poll and such.
we're not doing anything with the reply we recive yet, tho.

mostly hacked on the Frankfurt->Montreal flight, as batteries and those
horrible air canada seats permitted...
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.5 2004/06/05 12:29:15 alexander Exp $ */
d32 3
a34 1
#define	READ_BUF_SIZE	65535
d164 1
a164 1
int	setup_listeners(struct servent *, struct ntpd_conf *);
@


1.5
log
@Move prototype definitions.  Add multi-include protection to header.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.4 2004/06/02 10:08:59 henning Exp $ */
d37 6
d49 9
d60 1
d122 1
d164 5
@


1.4
log
@prepare for client functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.3 2004/06/01 21:58:09 henning Exp $ */
d27 2
d139 8
@


1.3
log
@first cut at config file parser
for now, one can set the addresses to listen on
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.2 2004/06/01 16:27:09 henning Exp $ */
d24 1
d136 1
@


1.2
log
@allow ntpd to listen on nearly arbitary number of sockets (OPEN_MAX - 1 atm).
default to one IPv4 wildcard and one IPv6 wildcard one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.1 2004/05/31 13:46:16 henning Exp $ */
d31 3
d42 1
d127 8
@


1.1
log
@initial cut at ntpd.
it is just capable of answering (s)ntp4 requests with the local time
for now.
imsg/buffer and logging framework from bgpd, ntp protocol hackery
with Alexander Guy
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.93 2004/05/07 10:06:15 djm Exp $ */
d31 10
d122 1
a122 1
pid_t	 ntp_main(int[2]);
@

