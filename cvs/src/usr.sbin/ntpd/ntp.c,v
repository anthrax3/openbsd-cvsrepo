head	1.145;
access;
symbols
	OPENBSD_6_1_BASE:1.145
	OPENBSD_6_0:1.141.0.4
	OPENBSD_6_0_BASE:1.141
	OPENBSD_5_9:1.141.0.2
	OPENBSD_5_9_BASE:1.141
	OPENBSD_5_8:1.135.0.2
	OPENBSD_5_8_BASE:1.135
	OPENBSD_5_7:1.130.0.2
	OPENBSD_5_7_BASE:1.130
	OPENBSD_5_6:1.120.0.6
	OPENBSD_5_6_BASE:1.120
	OPENBSD_5_5:1.120.0.4
	OPENBSD_5_5_BASE:1.120
	OPENBSD_5_4:1.117.0.8
	OPENBSD_5_4_BASE:1.117
	OPENBSD_5_3:1.117.0.6
	OPENBSD_5_3_BASE:1.117
	OPENBSD_5_2:1.117.0.4
	OPENBSD_5_2_BASE:1.117
	OPENBSD_5_1_BASE:1.117
	OPENBSD_5_1:1.117.0.2
	OPENBSD_5_0:1.116.0.2
	OPENBSD_5_0_BASE:1.116
	OPENBSD_4_9:1.114.0.8
	OPENBSD_4_9_BASE:1.114
	OPENBSD_4_8:1.114.0.6
	OPENBSD_4_8_BASE:1.114
	OPENBSD_4_7:1.114.0.2
	OPENBSD_4_7_BASE:1.114
	OPENBSD_4_6:1.114.0.4
	OPENBSD_4_6_BASE:1.114
	OPENBSD_4_5:1.110.0.2
	OPENBSD_4_5_BASE:1.110
	OPENBSD_4_4:1.106.0.2
	OPENBSD_4_4_BASE:1.106
	OPENBSD_4_3:1.103.0.2
	OPENBSD_4_3_BASE:1.103
	OPENBSD_4_2:1.99.0.2
	OPENBSD_4_2_BASE:1.99
	OPENBSD_4_1:1.98.0.2
	OPENBSD_4_1_BASE:1.98
	OPENBSD_4_0:1.91.0.2
	OPENBSD_4_0_BASE:1.91
	OPENBSD_3_9:1.67.0.4
	OPENBSD_3_9_BASE:1.67
	OPENBSD_3_8:1.67.0.2
	OPENBSD_3_8_BASE:1.67
	OPENBSD_3_7:1.54.0.2
	OPENBSD_3_7_BASE:1.54
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27;
locks; strict;
comment	@ * @;


1.145
date	2017.01.20.01.21.18;	author phessler;	state Exp;
branches;
next	1.144;
commitid	TwMypQIIWpRTJfG1;

1.144
date	2016.09.26.16.55.02;	author rzalamena;	state Exp;
branches;
next	1.143;
commitid	CSM07eEL9yrHalR4;

1.143
date	2016.09.14.13.20.16;	author rzalamena;	state Exp;
branches;
next	1.142;
commitid	FUtuYlECIdeLHfjN;

1.142
date	2016.09.03.11.52.06;	author reyk;	state Exp;
branches;
next	1.141;
commitid	NAWlzXnfvHaWyDX5;

1.141
date	2015.12.19.17.55.29;	author reyk;	state Exp;
branches;
next	1.140;
commitid	xe8YS3ftA7mmBwbB;

1.140
date	2015.12.05.13.12.16;	author claudio;	state Exp;
branches;
next	1.139;
commitid	1u4z6EiD1xQ1Wwbx;

1.139
date	2015.10.30.16.41.53;	author reyk;	state Exp;
branches;
next	1.138;
commitid	NJCsmGWpwJSjPe6u;

1.138
date	2015.10.23.14.52.20;	author phessler;	state Exp;
branches;
next	1.137;
commitid	37dFIvtgNCa7AEy2;

1.137
date	2015.10.12.06.50.08;	author reyk;	state Exp;
branches;
next	1.136;
commitid	to5fPpeGvAbrgkr0;

1.136
date	2015.10.09.03.54.53;	author deraadt;	state Exp;
branches;
next	1.135;
commitid	0oyjJJbjjQV085dC;

1.135
date	2015.08.14.02.00.18;	author millert;	state Exp;
branches;
next	1.134;
commitid	NERZU0I6e1qTkYdS;

1.134
date	2015.07.18.00.59.00;	author bcook;	state Exp;
branches;
next	1.133;
commitid	37L7ZhcN7kBZQQwR;

1.133
date	2015.07.18.00.53.44;	author bcook;	state Exp;
branches;
next	1.132;
commitid	X2stLxrcDblnYkzc;

1.132
date	2015.05.25.14.58.34;	author deraadt;	state Exp;
branches;
next	1.131;
commitid	4ocx9u3g8rcDPcgi;

1.131
date	2015.05.20.13.32.39;	author reyk;	state Exp;
branches;
next	1.130;
commitid	wTGf2eC247IaKa6e;

1.130
date	2015.03.02.10.31.17;	author bcook;	state Exp;
branches;
next	1.129;
commitid	n4dc2XEuwBAqiNU6;

1.129
date	2015.02.12.01.54.57;	author reyk;	state Exp;
branches;
next	1.128;
commitid	eJZFYJXXt9fmfGXk;

1.128
date	2015.02.10.06.40.08;	author reyk;	state Exp;
branches;
next	1.127;
commitid	pXoTR74Ztt0R3SV0;

1.127
date	2015.02.10.06.03.43;	author bcook;	state Exp;
branches;
next	1.126;
commitid	ArzQYdafRPMBULRK;

1.126
date	2015.01.13.02.23.33;	author bcook;	state Exp;
branches;
next	1.125;
commitid	R60n8D7Kc9OWQ6Do;

1.125
date	2015.01.09.07.35.37;	author deraadt;	state Exp;
branches;
next	1.124;
commitid	X9qvCMjSyjyh2fK9;

1.124
date	2015.01.04.01.48.49;	author bcook;	state Exp;
branches;
next	1.123;
commitid	SqfYJN9THyGArOhK;

1.123
date	2015.01.04.01.19.46;	author bcook;	state Exp;
branches;
next	1.122;
commitid	D90dwugO1YW1tdEs;

1.122
date	2015.01.04.01.16.10;	author bcook;	state Exp;
branches;
next	1.121;
commitid	6VFPRdNARX8wRB7d;

1.121
date	2014.10.08.04.57.29;	author deraadt;	state Exp;
branches;
next	1.120;
commitid	c7bqjkQ9YOTJywkK;

1.120
date	2013.11.13.20.44.39;	author benno;	state Exp;
branches;
next	1.119;

1.119
date	2013.10.04.14.28.16;	author phessler;	state Exp;
branches;
next	1.118;

1.118
date	2013.09.28.12.18.05;	author phessler;	state Exp;
branches;
next	1.117;

1.117
date	2011.09.21.15.41.30;	author phessler;	state Exp;
branches;
next	1.116;

1.116
date	2011.06.17.18.12.05;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2011.06.16.11.46.55;	author henning;	state Exp;
branches;
next	1.114;

1.114
date	2009.06.11.17.36.53;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2009.06.06.18.47.19;	author ckuethe;	state Exp;
branches;
next	1.112;

1.112
date	2009.06.06.18.14.25;	author pyr;	state Exp;
branches;
next	1.111;

1.111
date	2009.06.04.23.39.45;	author ckuethe;	state Exp;
branches;
next	1.110;

1.110
date	2009.01.26.11.51.50;	author henning;	state Exp;
branches;
next	1.109;

1.109
date	2008.12.10.09.03.30;	author claudio;	state Exp;
branches;
next	1.108;

1.108
date	2008.10.02.14.00.21;	author henning;	state Exp;
branches;
next	1.107;

1.107
date	2008.09.12.10.46.09;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2008.06.10.03.46.09;	author naddy;	state Exp;
branches;
next	1.105;

1.105
date	2008.06.08.19.14.40;	author ckuethe;	state Exp;
branches;
next	1.104;

1.104
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.103;

1.103
date	2008.01.28.11.45.59;	author mpf;	state Exp;
branches;
next	1.102;

1.102
date	2007.12.27.01.46.50;	author stevesk;	state Exp;
branches;
next	1.101;

1.101
date	2007.12.22.18.26.21;	author stevesk;	state Exp;
branches;
next	1.100;

1.100
date	2007.10.15.06.59.31;	author otto;	state Exp;
branches;
next	1.99;

1.99
date	2007.08.04.02.58.02;	author ckuethe;	state Exp;
branches;
next	1.98;

1.98
date	2007.01.15.08.19.11;	author otto;	state Exp;
branches;
next	1.97;

1.97
date	2007.01.14.19.20.09;	author otto;	state Exp;
branches;
next	1.96;

1.96
date	2006.12.20.16.50.13;	author henning;	state Exp;
branches;
next	1.95;

1.95
date	2006.11.30.18.42.41;	author ckuethe;	state Exp;
branches;
next	1.94;

1.94
date	2006.10.27.12.22.41;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2006.10.24.12.23.39;	author henning;	state Exp;
branches;
next	1.92;

1.92
date	2006.10.21.07.30.58;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2006.07.01.18.52.46;	author otto;	state Exp;
branches;
next	1.90;

1.90
date	2006.06.30.16.52.13;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2006.06.26.09.43.06;	author otto;	state Exp;
branches;
next	1.88;

1.88
date	2006.06.21.07.42.00;	author otto;	state Exp;
branches;
next	1.87;

1.87
date	2006.06.17.18.40.42;	author otto;	state Exp;
branches;
next	1.86;

1.86
date	2006.06.09.07.42.08;	author otto;	state Exp;
branches;
next	1.85;

1.85
date	2006.06.08.06.03.07;	author otto;	state Exp;
branches;
next	1.84;

1.84
date	2006.06.07.06.29.03;	author otto;	state Exp;
branches;
next	1.83;

1.83
date	2006.06.04.18.58.13;	author otto;	state Exp;
branches;
next	1.82;

1.82
date	2006.06.02.20.45.34;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2006.06.01.06.04.15;	author otto;	state Exp;
branches;
next	1.80;

1.80
date	2006.06.01.05.44.35;	author henning;	state Exp;
branches;
next	1.79;

1.79
date	2006.06.01.04.42.23;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.31.01.27.21;	author henning;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.28.20.39.16;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2006.05.28.18.47.25;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2006.05.28.03.23.08;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2006.05.27.22.22.47;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.27.21.27.34;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.27.18.32.00;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.26.00.33.16;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2006.05.25.19.30.45;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2006.05.25.19.25.46;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.14.22.33.51;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2005.08.10.13.48.36;	author dtucker;	state Exp;
branches;
next	1.66;

1.66
date	2005.08.08.14.42.32;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2005.07.15.03.36.10;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2005.07.15.03.34.52;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2005.07.11.08.05.34;	author dtucker;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.05.10.09.12;	author dtucker;	state Exp;
branches;
next	1.61;

1.61
date	2005.06.19.16.42.57;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2005.05.26.09.13.06;	author dtucker;	state Exp;
branches;
next	1.59;

1.59
date	2005.05.23.22.46.43;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2005.05.03.05.44.35;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2005.04.18.14.12.50;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2005.04.18.11.07.55;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.24.14.50.07;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.08.16.33.43;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.08.16.27.14;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.08.14.37.16;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.22.12.03.24;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2005.02.02.19.03.52;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.28.12.37.20;	author dtucker;	state Exp;
branches;
next	1.48;

1.48
date	2005.01.27.14.44.00;	author dtucker;	state Exp;
branches;
next	1.47;

1.47
date	2005.01.27.10.32.29;	author dtucker;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.23.16.10.10;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.22.05.34.52;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.13.12.39.15;	author dtucker;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.13.12.36.02;	author dtucker;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.12.17.24.52;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.10.11.47.28;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.10.27.14.19.12;	author dtucker;	state Exp;
branches;
next	1.39;

1.39
date	2004.10.27.10.55.27;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.10.22.21.17.37;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.13.14.02.50;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2004.10.13.12.22.39;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.13.09.20.41;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2004.10.04.11.12.58;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.18.20.01.38;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.09.18.07.33.14;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.09.15.19.21.25;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.15.19.14.11;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2004.09.15.00.08.06;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2004.09.15.00.07.20;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.09.09.21.50.33;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.08.12.16.33.59;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.18.12.59.41;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.14.20.16.31;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.13.19.41.26;	author alexander;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.10.18.42.51;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.09.15.00.43;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.09.12.21.09;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.09.10.53.33;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.09.10.22.07;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.08.15.06.13;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.08.01.21.09;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.07.07.32.05;	author alexander;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.07.03.57.28;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.07.01.01.27;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.06.23.26.38;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.05.22.12.53;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.05.07.46.16;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.22.07.59.48;	author alexander;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.18.04.51.31;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.17.19.17.48;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.02.10.08.59;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.01.21.58.08;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.01.16.27.09;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.31.21.43.23;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.31.15.11.56;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.31.13.46.16;	author henning;	state Exp;
branches;
next	;


desc
@@


1.145
log
@add logging messages to distinguish which safty check failed
@
text
@/*	$OpenBSD: ntp.c,v 1.144 2016/09/26 16:55:02 rzalamena Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2004 Alexander Guy <alexander.guy@@andern.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <err.h>

#include "ntpd.h"

#define	PFD_PIPE_MAIN	0
#define	PFD_PIPE_DNS	1
#define	PFD_SOCK_CTL	2
#define	PFD_MAX		3

volatile sig_atomic_t	 ntp_quit = 0;
struct imsgbuf		*ibuf_main;
struct imsgbuf		*ibuf_dns;
struct ntpd_conf	*conf;
struct ctl_conns	 ctl_conns;
u_int			 peer_cnt;
u_int			 sensors_cnt;
extern u_int		 constraint_cnt;

void	ntp_sighdlr(int);
int	ntp_dispatch_imsg(void);
int	ntp_dispatch_imsg_dns(void);
void	peer_add(struct ntp_peer *);
void	peer_remove(struct ntp_peer *);

void
ntp_sighdlr(int sig)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		ntp_quit = 1;
		break;
	}
}

void
ntp_main(struct ntpd_conf *nconf, struct passwd *pw, int argc, char **argv)
{
	int			 a, b, nfds, i, j, idx_peers, timeout;
	int			 nullfd, pipe_dns[2], idx_clients;
	int			 ctls;
	int			 fd_ctl;
	u_int			 pfd_elms = 0, idx2peer_elms = 0;
	u_int			 listener_cnt, new_cnt, sent_cnt, trial_cnt;
	u_int			 ctl_cnt;
	struct pollfd		*pfd = NULL;
	struct servent		*se;
	struct listen_addr	*la;
	struct ntp_peer		*p;
	struct ntp_peer		**idx2peer = NULL;
	struct ntp_sensor	*s, *next_s;
	struct constraint	*cstr;
	struct timespec		 tp;
	struct stat		 stb;
	struct ctl_conn		*cc;
	time_t			 nextaction, last_sensor_scan = 0, now;
	void			*newp;

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, PF_UNSPEC,
	    pipe_dns) == -1)
		fatal("socketpair");

	start_child(NTPDNS_PROC_NAME, pipe_dns[1], argc, argv);

	/* in this case the parent didn't init logging and didn't daemonize */
	if (nconf->settime && !nconf->debug) {
		log_init(nconf->debug, LOG_DAEMON);
		if (setsid() == -1)
			fatal("setsid");
	}
	log_procinit("ntp");

	if ((se = getservbyname("ntp", "udp")) == NULL)
		fatal("getservbyname");

	/* Start control socket. */
	if ((fd_ctl = control_init(CTLSOCKET)) == -1)
		fatalx("control socket init failed");
	if (control_listen(fd_ctl) == -1)
		fatalx("control socket listen failed");
	if ((nullfd = open("/dev/null", O_RDWR, 0)) == -1)
		fatal(NULL);

	if (stat(pw->pw_dir, &stb) == -1) {
		fatal("privsep dir %s could not be opened", pw->pw_dir);
	}
	if (stb.st_uid != 0 || (stb.st_mode & (S_IWGRP|S_IWOTH)) != 0) {
		fatalx("bad privsep dir %s permissions: %o",
		    pw->pw_dir, stb.st_mode);
	}
	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	if (!nconf->debug) {
		dup2(nullfd, STDIN_FILENO);
		dup2(nullfd, STDOUT_FILENO);
		dup2(nullfd, STDERR_FILENO);
	}
	close(nullfd);

	setproctitle("ntp engine");

	conf = nconf;
	setup_listeners(se, conf, &listener_cnt);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	endservent();

	/* The ntp process will want to open NTP client sockets -> "inet" */
	if (pledge("stdio inet", NULL) == -1)
		err(1, "pledge");

	signal(SIGTERM, ntp_sighdlr);
	signal(SIGINT, ntp_sighdlr);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
	signal(SIGCHLD, SIG_DFL);

	if ((ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
		fatal(NULL);
	imsg_init(ibuf_main, PARENT_SOCK_FILENO);
	if ((ibuf_dns = malloc(sizeof(struct imsgbuf))) == NULL)
		fatal(NULL);
	imsg_init(ibuf_dns, pipe_dns[0]);

	constraint_cnt = 0;
	conf->constraint_median = 0;
	conf->constraint_last = getmonotime();
	TAILQ_FOREACH(cstr, &conf->constraints, entry)
		constraint_cnt += constraint_init(cstr);

	TAILQ_FOREACH(p, &conf->ntp_peers, entry)
		client_peer_init(p);

	memset(&conf->status, 0, sizeof(conf->status));

	conf->freq.num = 0;
	conf->freq.samples = 0;
	conf->freq.x = 0.0;
	conf->freq.xx = 0.0;
	conf->freq.xy = 0.0;
	conf->freq.y = 0.0;
	conf->freq.overall_offset = 0.0;

	conf->status.synced = 0;
	clock_getres(CLOCK_REALTIME, &tp);
	b = 1000000000 / tp.tv_nsec;	/* convert to Hz */
	for (a = 0; b > 1; a--, b >>= 1)
		;
	conf->status.precision = a;
	conf->scale = 1;

	TAILQ_INIT(&ctl_conns);
	sensor_init();

	log_info("ntp engine ready");

	ctl_cnt = 0;
	peer_cnt = 0;
	TAILQ_FOREACH(p, &conf->ntp_peers, entry)
		peer_cnt++;

	while (ntp_quit == 0) {
		if (peer_cnt > idx2peer_elms) {
			if ((newp = reallocarray(idx2peer, peer_cnt,
			    sizeof(*idx2peer))) == NULL) {
				/* panic for now */
				log_warn("could not resize idx2peer from %u -> "
				    "%u entries", idx2peer_elms, peer_cnt);
				fatalx("exiting");
			}
			idx2peer = newp;
			idx2peer_elms = peer_cnt;
		}

		new_cnt = PFD_MAX +
		    peer_cnt + listener_cnt + ctl_cnt;
		if (new_cnt > pfd_elms) {
			if ((newp = reallocarray(pfd, new_cnt,
			    sizeof(*pfd))) == NULL) {
				/* panic for now */
				log_warn("could not resize pfd from %u -> "
				    "%u entries", pfd_elms, new_cnt);
				fatalx("exiting");
			}
			pfd = newp;
			pfd_elms = new_cnt;
		}

		memset(pfd, 0, sizeof(*pfd) * pfd_elms);
		memset(idx2peer, 0, sizeof(*idx2peer) * idx2peer_elms);
		nextaction = getmonotime() + 3600;
		pfd[PFD_PIPE_MAIN].fd = ibuf_main->fd;
		pfd[PFD_PIPE_MAIN].events = POLLIN;
		pfd[PFD_PIPE_DNS].fd = ibuf_dns->fd;
		pfd[PFD_PIPE_DNS].events = POLLIN;
		pfd[PFD_SOCK_CTL].fd = fd_ctl;
		pfd[PFD_SOCK_CTL].events = POLLIN;

		i = PFD_MAX;
		TAILQ_FOREACH(la, &conf->listen_addrs, entry) {
			pfd[i].fd = la->fd;
			pfd[i].events = POLLIN;
			i++;
		}

		idx_peers = i;
		sent_cnt = trial_cnt = 0;
		TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
			if (constraint_cnt && conf->constraint_median == 0)
				continue;

			if (p->next > 0 && p->next <= getmonotime()) {
				if (p->state > STATE_DNS_INPROGRESS)
					trial_cnt++;
				if (client_query(p) == 0)
					sent_cnt++;
			}
			if (p->deadline > 0 && p->deadline <= getmonotime()) {
				timeout = 300;
				log_debug("no reply from %s received in time, "
				    "next query %ds", log_sockaddr(
				    (struct sockaddr *)&p->addr->ss), timeout);
				if (p->trustlevel >= TRUSTLEVEL_BADPEER &&
				    (p->trustlevel /= 2) < TRUSTLEVEL_BADPEER)
					log_info("peer %s now invalid",
					    log_sockaddr(
					    (struct sockaddr *)&p->addr->ss));
				client_nextaddr(p);
				set_next(p, timeout);
			}
			if (p->senderrors > MAX_SEND_ERRORS) {
				log_debug("failed to send query to %s, "
				    "next query %ds", log_sockaddr(
				    (struct sockaddr *)&p->addr->ss),
				    INTERVAL_QUERY_PATHETIC);
				p->senderrors = 0;
				client_nextaddr(p);
				set_next(p, INTERVAL_QUERY_PATHETIC);
			}
			if (p->next > 0 && p->next < nextaction)
				nextaction = p->next;
			if (p->deadline > 0 && p->deadline < nextaction)
				nextaction = p->deadline;

			if (p->state == STATE_QUERY_SENT &&
			    p->query->fd != -1) {
				pfd[i].fd = p->query->fd;
				pfd[i].events = POLLIN;
				idx2peer[i - idx_peers] = p;
				i++;
			}
		}
		idx_clients = i;

		if (!TAILQ_EMPTY(&conf->ntp_conf_sensors)) {
			if (last_sensor_scan == 0 ||
			    last_sensor_scan + SENSOR_SCAN_INTERVAL <= getmonotime()) {
				sensors_cnt = sensor_scan();
				last_sensor_scan = getmonotime();
			}
			if (sensors_cnt == 0 &&
			    nextaction > last_sensor_scan + SENSOR_SCAN_INTERVAL)
				nextaction = last_sensor_scan + SENSOR_SCAN_INTERVAL;
			sensors_cnt = 0;
			TAILQ_FOREACH(s, &conf->ntp_sensors, entry) {
				if (conf->settime && s->offsets[0].offset)
					priv_settime(s->offsets[0].offset);
				sensors_cnt++;
				if (s->next > 0 && s->next < nextaction)
					nextaction = s->next;
			}
		}

		if (conf->settime &&
		    ((trial_cnt > 0 && sent_cnt == 0) ||
		    (peer_cnt == 0 && sensors_cnt == 0)))
			priv_settime(0);	/* no good peers, don't wait */

		if (ibuf_main->w.queued > 0)
			pfd[PFD_PIPE_MAIN].events |= POLLOUT;
		if (ibuf_dns->w.queued > 0)
			pfd[PFD_PIPE_DNS].events |= POLLOUT;

		TAILQ_FOREACH(cc, &ctl_conns, entry) {
			pfd[i].fd = cc->ibuf.fd;
			pfd[i].events = POLLIN;
			if (cc->ibuf.w.queued > 0)
				pfd[i].events |= POLLOUT;
			i++;
		}
		ctls = i;

		TAILQ_FOREACH(cstr, &conf->constraints, entry) {
			if (constraint_query(cstr) == -1)
				continue;
		}

		now = getmonotime();
		if (constraint_cnt)
			nextaction = now + 1;

		timeout = nextaction - now;
		if (timeout < 0)
			timeout = 0;

		if ((nfds = poll(pfd, i, timeout * 1000)) == -1)
			if (errno != EINTR) {
				log_warn("poll error");
				ntp_quit = 1;
			}

		if (nfds > 0 && (pfd[PFD_PIPE_MAIN].revents & POLLOUT))
			if (msgbuf_write(&ibuf_main->w) <= 0 &&
			    errno != EAGAIN) {
				log_warn("pipe write error (to parent)");
				ntp_quit = 1;
			}

		if (nfds > 0 && pfd[PFD_PIPE_MAIN].revents & (POLLIN|POLLERR)) {
			nfds--;
			if (ntp_dispatch_imsg() == -1) {
				log_warn("pipe write error (from main)");
				ntp_quit = 1;
			}
		}

		if (nfds > 0 && (pfd[PFD_PIPE_DNS].revents & POLLOUT))
			if (msgbuf_write(&ibuf_dns->w) <= 0 &&
			    errno != EAGAIN) {
				log_warn("pipe write error (to dns engine)");
				ntp_quit = 1;
			}

		if (nfds > 0 && pfd[PFD_PIPE_DNS].revents & (POLLIN|POLLERR)) {
			nfds--;
			if (ntp_dispatch_imsg_dns() == -1) {
				log_warn("pipe write error (from dns engine)");
				ntp_quit = 1;
			}
		}

		if (nfds > 0 && pfd[PFD_SOCK_CTL].revents & (POLLIN|POLLERR)) {
			nfds--;
			ctl_cnt += control_accept(fd_ctl);
		}

		for (j = PFD_MAX; nfds > 0 && j < idx_peers; j++)
			if (pfd[j].revents & (POLLIN|POLLERR)) {
				nfds--;
				if (server_dispatch(pfd[j].fd, conf) == -1) {
					log_warn("pipe write error (conf)");
					ntp_quit = 1;
				}
			}

		for (; nfds > 0 && j < idx_clients; j++) {
			if (pfd[j].revents & (POLLIN|POLLERR)) {
				nfds--;
				if (client_dispatch(idx2peer[j - idx_peers],
				    conf->settime) == -1) {
					log_warn("pipe write error (settime)");
					ntp_quit = 1;
				}
			}
		}

		for (; nfds > 0 && j < ctls; j++) {
			nfds -= control_dispatch_msg(&pfd[j], &ctl_cnt);
		}

		for (s = TAILQ_FIRST(&conf->ntp_sensors); s != NULL;
		    s = next_s) {
			next_s = TAILQ_NEXT(s, entry);
			if (s->next <= getmonotime())
				sensor_query(s);
		}
	}

	msgbuf_write(&ibuf_main->w);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
	msgbuf_write(&ibuf_dns->w);
	msgbuf_clear(&ibuf_dns->w);
	free(ibuf_dns);

	log_info("ntp engine exiting");
	exit(0);
}

int
ntp_dispatch_imsg(void)
{
	struct imsg		 imsg;
	int			 n;

	if (((n = imsg_read(ibuf_main)) == -1 && errno != EAGAIN) || n == 0)
		return (-1);

	for (;;) {
		if ((n = imsg_get(ibuf_main, &imsg)) == -1)
			return (-1);

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_ADJTIME:
			memcpy(&n, imsg.data, sizeof(n));
			if (n == 1 && !conf->status.synced) {
				log_info("clock is now synced");
				conf->status.synced = 1;
			} else if (n == 0 && conf->status.synced) {
				log_info("clock is now unsynced");
				conf->status.synced = 0;
			}
			break;
		case IMSG_CONSTRAINT_RESULT:
			constraint_msg_result(imsg.hdr.peerid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_CONSTRAINT_CLOSE:
			constraint_msg_close(imsg.hdr.peerid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}
	return (0);
}

int
ntp_dispatch_imsg_dns(void)
{
	struct imsg		 imsg;
	struct ntp_peer		*peer, *npeer;
	u_int16_t		 dlen;
	u_char			*p;
	struct ntp_addr		*h;
	int			 n;

	if (((n = imsg_read(ibuf_dns)) == -1 && errno != EAGAIN) || n == 0)
		return (-1);

	for (;;) {
		if ((n = imsg_get(ibuf_dns, &imsg)) == -1)
			return (-1);

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_HOST_DNS:
			TAILQ_FOREACH(peer, &conf->ntp_peers, entry)
				if (peer->id == imsg.hdr.peerid)
					break;
			if (peer == NULL) {
				log_warnx("IMSG_HOST_DNS with invalid peerID");
				break;
			}
			if (peer->addr != NULL) {
				log_warnx("IMSG_HOST_DNS but addr != NULL!");
				break;
			}

			dlen = imsg.hdr.len - IMSG_HEADER_SIZE;
			if (dlen == 0) {	/* no data -> temp error */
				peer->state = STATE_DNS_TEMPFAIL;
				break;
			}

			p = (u_char *)imsg.data;
			while (dlen >= sizeof(struct sockaddr_storage)) {
				if ((h = calloc(1, sizeof(struct ntp_addr))) ==
				    NULL)
					fatal(NULL);
				memcpy(&h->ss, p, sizeof(h->ss));
				p += sizeof(h->ss);
				dlen -= sizeof(h->ss);
				if (peer->addr_head.pool) {
					npeer = new_peer();
					npeer->weight = peer->weight;
					h->next = NULL;
					npeer->addr = h;
					npeer->addr_head.a = h;
					npeer->addr_head.name =
					    peer->addr_head.name;
					npeer->addr_head.pool = 1;
					client_peer_init(npeer);
					npeer->state = STATE_DNS_DONE;
					peer_add(npeer);
				} else {
					h->next = peer->addr;
					peer->addr = h;
					peer->addr_head.a = peer->addr;
					peer->state = STATE_DNS_DONE;
				}
			}
			if (dlen != 0)
				fatalx("IMSG_HOST_DNS: dlen != 0");
			if (peer->addr_head.pool)
				peer_remove(peer);
			else
				client_addr_init(peer);
			break;
		case IMSG_CONSTRAINT_DNS:
			constraint_msg_dns(imsg.hdr.peerid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}
	return (0);
}

void
peer_add(struct ntp_peer *p)
{
	TAILQ_INSERT_TAIL(&conf->ntp_peers, p, entry);
	peer_cnt++;
}

void
peer_remove(struct ntp_peer *p)
{
	TAILQ_REMOVE(&conf->ntp_peers, p, entry);
	free(p);
	peer_cnt--;
}

static void
priv_adjfreq(double offset)
{
	double curtime, freq;

	if (!conf->status.synced){
		conf->freq.samples = 0;
		return;
	}

	conf->freq.samples++;

	if (conf->freq.samples <= 0)
		return;

	conf->freq.overall_offset += offset;
	offset = conf->freq.overall_offset;

	curtime = gettime_corrected();
	conf->freq.xy += offset * curtime;
	conf->freq.x += curtime;
	conf->freq.y += offset;
	conf->freq.xx += curtime * curtime;

	if (conf->freq.samples % FREQUENCY_SAMPLES != 0)
		return;

	freq =
	    (conf->freq.xy - conf->freq.x * conf->freq.y / conf->freq.samples)
	    /
	    (conf->freq.xx - conf->freq.x * conf->freq.x / conf->freq.samples);

	if (freq > MAX_FREQUENCY_ADJUST)
		freq = MAX_FREQUENCY_ADJUST;
	else if (freq < -MAX_FREQUENCY_ADJUST)
		freq = -MAX_FREQUENCY_ADJUST;

	imsg_compose(ibuf_main, IMSG_ADJFREQ, 0, 0, -1, &freq, sizeof(freq));
	conf->filters |= FILTER_ADJFREQ;
	conf->freq.xy = 0.0;
	conf->freq.x = 0.0;
	conf->freq.y = 0.0;
	conf->freq.xx = 0.0;
	conf->freq.samples = 0;
	conf->freq.overall_offset = 0.0;
	conf->freq.num++;
}

int
priv_adjtime(void)
{
	struct ntp_peer		 *p;
	struct ntp_sensor	 *s;
	int			  offset_cnt = 0, i = 0, j;
	struct ntp_offset	**offsets;
	double			  offset_median;

	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		if (p->trustlevel < TRUSTLEVEL_BADPEER)
			continue;
		if (!p->update.good)
			return (1);
		offset_cnt += p->weight;
	}

	TAILQ_FOREACH(s, &conf->ntp_sensors, entry) {
		if (!s->update.good)
			continue;
		offset_cnt += s->weight;
	}

	if (offset_cnt == 0)
		return (1);

	if ((offsets = calloc(offset_cnt, sizeof(struct ntp_offset *))) == NULL)
		fatal("calloc priv_adjtime");

	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		if (p->trustlevel < TRUSTLEVEL_BADPEER)
			continue;
		for (j = 0; j < p->weight; j++)
			offsets[i++] = &p->update;
	}

	TAILQ_FOREACH(s, &conf->ntp_sensors, entry) {
		if (!s->update.good)
			continue;
		for (j = 0; j < s->weight; j++)
			offsets[i++] = &s->update;
	}

	qsort(offsets, offset_cnt, sizeof(struct ntp_offset *), offset_compare);

	i = offset_cnt / 2;
	if (offset_cnt % 2 == 0)
		if (offsets[i - 1]->delay < offsets[i]->delay)
			i -= 1;
	offset_median = offsets[i]->offset;
	conf->status.rootdelay = offsets[i]->delay;
	conf->status.stratum = offsets[i]->status.stratum;
	conf->status.leap = offsets[i]->status.leap;

	imsg_compose(ibuf_main, IMSG_ADJTIME, 0, 0, -1,
	    &offset_median, sizeof(offset_median));

	priv_adjfreq(offset_median);

	conf->status.reftime = gettime();
	conf->status.stratum++;	/* one more than selected peer */
	if (conf->status.stratum > NTP_MAXSTRATUM)
		conf->status.stratum = NTP_MAXSTRATUM;
	update_scale(offset_median);

	conf->status.refid = offsets[i]->status.send_refid;

	free(offsets);

	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		for (i = 0; i < OFFSET_ARRAY_SIZE; i++)
			p->reply[i].offset -= offset_median;
		p->update.good = 0;
	}
	TAILQ_FOREACH(s, &conf->ntp_sensors, entry) {
		for (i = 0; i < SENSOR_OFFSETS; i++)
			s->offsets[i].offset -= offset_median;
		s->update.offset -= offset_median;
	}

	return (0);
}

int
offset_compare(const void *aa, const void *bb)
{
	const struct ntp_offset * const *a;
	const struct ntp_offset * const *b;

	a = aa;
	b = bb;

	if ((*a)->offset < (*b)->offset)
		return (-1);
	else if ((*a)->offset > (*b)->offset)
		return (1);
	else
		return (0);
}

void
priv_settime(double offset)
{
	imsg_compose(ibuf_main, IMSG_SETTIME, 0, 0, -1,
	    &offset, sizeof(offset));
	conf->settime = 0;
}

void
priv_dns(int cmd, char *name, u_int32_t peerid)
{
	u_int16_t	dlen;

	dlen = strlen(name) + 1;
	imsg_compose(ibuf_dns, cmd, peerid, 0, -1, name, dlen);
}

void
update_scale(double offset)
{
	offset += getoffset();
	if (offset < 0)
		offset = -offset;

	if (offset > QSCALE_OFF_MAX || !conf->status.synced ||
	    conf->freq.num < 3)
		conf->scale = 1;
	else if (offset < QSCALE_OFF_MIN)
		conf->scale = QSCALE_OFF_MAX / QSCALE_OFF_MIN;
	else
		conf->scale = QSCALE_OFF_MAX / offset;
}

time_t
scale_interval(time_t requested)
{
	time_t interval, r;

	interval = requested * conf->scale;
	r = arc4random_uniform(MAXIMUM(5, interval / 10));
	return (interval + r);
}

time_t
error_interval(void)
{
	time_t interval, r;

	interval = INTERVAL_QUERY_PATHETIC * QSCALE_OFF_MAX / QSCALE_OFF_MIN;
	r = arc4random_uniform(interval / 10);
	return (interval + r);
}
@


1.144
log
@Teach ntpd(8) how to use socket status to shutdown the daemon. While at
it, remove some verbose shutdown messages that we had before with pipe
close.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.143 2016/09/14 13:20:16 rzalamena Exp $ */
d361 2
a362 1
			if (ntp_dispatch_imsg() == -1)
d364 1
d376 2
a377 1
			if (ntp_dispatch_imsg_dns() == -1)
d379 1
d390 2
a391 1
				if (server_dispatch(pfd[j].fd, conf) == -1)
d393 1
d400 2
a401 1
				    conf->settime) == -1)
d403 1
@


1.143
log
@Teach ntpd(8) how to fork+exec.

ok reyk@@, bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.142 2016/09/03 11:52:06 reyk Exp $ */
d428 1
a428 1
	if ((n = imsg_read(ibuf_main)) == -1 && errno != EAGAIN)
a430 5
	if (n == 0) {	/* connection closed */
		log_warnx("ntp_dispatch_imsg in ntp engine: pipe closed");
		return (-1);
	}

d475 1
a475 1
	if ((n = imsg_read(ibuf_dns)) == -1)
a476 5

	if (n == 0) {	/* connection closed */
		log_warnx("ntp_dispatch_imsg_dns in ntp engine: pipe closed");
		return (-1);
	}
@


1.142
log
@Remove the oh so funny "LOSS OF MIND" from the diclaimer that was not
part of the original ISC license that we use in OpenBSD.  Done for
files were Henning is the original author.

OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.141 2015/12/19 17:55:29 reyk Exp $ */
d69 2
a70 3
pid_t
ntp_main(int pipe_prnt[2], int fd_ctl, struct ntpd_conf *nconf,
    struct passwd *pw)
d75 1
a78 1
	pid_t			 pid;
d92 5
a96 9
	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
		break;
	case 0:
		break;
	default:
		return (pid);
	}
d109 5
a116 6
	close(pipe_prnt[0]);
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_dns) == -1)
		fatal("socketpair");
	ntp_dns(pipe_dns, nconf, pw);
	close(pipe_dns[1]);

d160 1
a160 1
	imsg_init(ibuf_main, pipe_prnt[1]);
d419 1
a419 1
	_exit(0);
@


1.141
log
@Switch and sync to the log.c variant from httpd/relayd/iked/snmpd/vmd.

OK bcook@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.140 2015/12/05 13:12:16 claudio Exp $ */
d15 3
a17 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.140
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.139 2015/10/30 16:41:53 reyk Exp $ */
d31 1
d105 1
a105 1
		log_init(nconf->debug);
d109 2
@


1.139
log
@Remove support for sending status reports to syslog on SIGINFO;
we have ntpctl now and ntpd doesn't need redundant/obsolete features.

Pointed out by naddy@@, with input from zhuk@@ (SIGINFO doesn't need SIG_IGN)
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.138 2015/10/23 14:52:20 phessler Exp $ */
d431 1
a431 1
	if ((n = imsg_read(ibuf_main)) == -1)
@


1.138
log
@Allowing upstream servers of ntp being in multiple routing tables is
non-sensical.  The dns lookups happened in the process routing table
(usually '0'), which is very likely to have different results from the
other routing domains.  If you do depend on having this behaviour,
you'll need to use pf to cross the rtable boundary.

"listen on * rtable X" is still supported.

Users of "server * rtable X" will need to switch to launching ntpd with
"route -T X exec /usr/sbin/ntpd"

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.137 2015/10/12 06:50:08 reyk Exp $ */
a42 1
volatile sig_atomic_t	 ntp_report = 0;
a49 1
time_t			 lastreport;
a55 1
void	report_peers(int);
a64 3
	case SIGINFO:
		ntp_report = 1;
		break;
a156 1
	signal(SIGINFO, ntp_sighdlr);
a204 3
	/* wait 5 min before reporting first status to let things settle down */
	lastreport = getmonotime() + (5 * 60) - REPORT_INTERVAL;

a411 2
		report_peers(ntp_report);
		ntp_report = 0;
a777 56
}

void
report_peers(int always)
{
	time_t now;
	u_int badpeers = 0;
	u_int badsensors = 0;
	struct ntp_peer *p;
	struct ntp_sensor *s;

	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		if (p->trustlevel < TRUSTLEVEL_BADPEER)
			badpeers++;
	}
	TAILQ_FOREACH(s, &conf->ntp_sensors, entry) {
		if (!s->update.good)
			badsensors++;
	}

	now = getmonotime();
	if (!always) {
		if ((peer_cnt == 0 || badpeers == 0 || badpeers < peer_cnt / 2)
		    && (sensors_cnt == 0 || badsensors == 0 ||
		    badsensors < sensors_cnt / 2))
			return;

		if (lastreport + REPORT_INTERVAL > now)
			return;
	}
	lastreport = now;
	if (peer_cnt > 0) {
		log_warnx("%u out of %u peers valid", peer_cnt - badpeers,
		    peer_cnt);
		TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
			if (p->trustlevel < TRUSTLEVEL_BADPEER) {
				const char *a = "not resolved";
				const char *pool = "";
				if (p->addr)
					a = log_sockaddr(
					    (struct sockaddr *)&p->addr->ss);
				if (p->addr_head.pool)
					pool = "from pool ";
				log_warnx("bad peer %s%s (%s)",
				    pool, p->addr_head.name, a);
			}
		}
	}
	if (sensors_cnt > 0) {
		log_warnx("%u out of %u sensors valid",
		    sensors_cnt - badsensors, sensors_cnt);
		TAILQ_FOREACH(s, &conf->ntp_sensors, entry) {
			if (!s->update.good)
				log_warnx("bad sensor %s", s->device);
		}
	}
@


1.137
log
@Move execution of the constraints from the ntp to the parent process.
This helps the ntp process to a) give a better pledge(2) and to b)
keep the promise of "saving the world again... on time" by removing
the delays that have been introduced by expensive constraint forks.
The new design offers better privsep but introduces a few more imsgs
and runs a little bit more code in the privileged parent.  The
privileged code is minimal, carefully checked, and does not attempt to
"parse" any contents; the forked constraints instantly drop all
privileges and pledge to "stdio inet".

OK beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.136 2015/10/09 03:54:53 deraadt Exp $ */
d274 2
a275 3
				    "next query %ds %s", log_sockaddr(
				    (struct sockaddr *)&p->addr->ss), timeout,
				    print_rtable(p->rtable));
a546 1
					npeer->rtable = peer->rtable;
d833 2
a834 3
				log_warnx("bad peer %s%s (%s) %s",
				    pool, p->addr_head.name, a,
				    print_rtable(p->rtable));
@


1.136
log
@the ntp engine can run with "stdio inet proc".  For many reasons,
including fork/exec cost, it would be better if constraints were
forked from the master process, which would then tell the ntp
engine.  That would increase accuracy and security.
Lots of conversations with reyk and bcook
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.135 2015/08/14 02:00:18 millert Exp $ */
a33 1
#include <tls.h>
a43 1
volatile sig_atomic_t	 ntp_sigchld = 0;
d50 1
a50 1
u_int			 constraint_cnt;
a70 3
	case SIGCHLD:
		ntp_sigchld = 1;
		break;
a107 7
	tls_init();

	/* Verification will be turned off if CA is not found */
	if ((conf->ca = tls_load_file(CONSTRAINT_CA,
	    &conf->ca_len, NULL)) == NULL)
		log_warnx("constraint certificate verification turned off");

d157 2
a158 12
	/*
	 * XXX
	 * Unfortunately, the "contraint" processes are forked
	 * below the "ntp engine".  Hence the ntp engine needs
	 * to be able to fork -> "proc", and the "constraint"
	 * process will want to open sockets -> "inet".
	 *
	 * For many reasons, including fork/exec cost, it would
	 * be better if constraints were forked from the master
	 * process, which would then tell the ntp engine.
	 */
	if (pledge("stdio inet proc", NULL) == -1)
d166 1
a166 1
	signal(SIGCHLD, ntp_sighdlr);
d229 1
a229 1
		    peer_cnt + listener_cnt + ctl_cnt + constraint_cnt;
a349 3
			pfd[i].fd = cstr->fd;
			pfd[i].events = POLLIN;
			i++;
a416 4
		for (; nfds > 0 && j < i; j++) {
			nfds -= constraint_dispatch_msg(&pfd[j]);
		}

a424 5

		if (ntp_sigchld) {
			constraint_check_child();
			ntp_sigchld = 0;
		}
d470 8
d567 1
a567 1
			constraint_dns(imsg.hdr.peerid,
@


1.135
log
@When checking whether we should scan the sensors again use <= rather
than < for the comparison.  Otherwise, if we don't do enough work
in the loop to advance the clock (for instance if the network is
down) we may end up calling poll() multiple times with no timeout,
racking up CPU time for no real reason.  OK bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.134 2015/07/18 00:59:00 bcook Exp $ */
d33 1
d168 14
@


1.134
log
@replace _PATH_DEVNULL with "/dev/null", assume it will not move

ok deraadt@@ phessler@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.133 2015/07/18 00:53:44 bcook Exp $ */
d318 1
a318 1
			    last_sensor_scan + SENSOR_SCAN_INTERVAL < getmonotime()) {
@


1.133
log
@replace bzero with memset

ok phessler@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.132 2015/05/25 14:58:34 deraadt Exp $ */
d128 1
a128 1
	if ((nullfd = open(_PATH_DEVNULL, O_RDWR, 0)) == -1)
@


1.132
log
@only scan sensors if they are configured
ok bcook
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.131 2015/05/20 13:32:39 reyk Exp $ */
d191 1
a191 1
	bzero(&conf->status, sizeof(conf->status));
d249 2
a250 2
		bzero(pfd, sizeof(*pfd) * pfd_elms);
		bzero(idx2peer, sizeof(*idx2peer) * idx2peer_elms);
@


1.131
log
@Remove hotplug(4) sensor support: the code has been disabled by
henning@@ 9 years ago because of an issue with the /dev/hotplug device
- it does not support multiple readers opening it.  Nobody ever cared
enough to fix it so it is time to sent the dead code to the Attic.

OK henning@@ (feeling sad about it), mpi@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.130 2015/03/02 10:31:17 bcook Exp $ */
d316 17
a332 15
		if (last_sensor_scan == 0 ||
		    last_sensor_scan + SENSOR_SCAN_INTERVAL < getmonotime()) {
			sensors_cnt = sensor_scan();
			last_sensor_scan = getmonotime();
		}
		if (!TAILQ_EMPTY(&conf->ntp_conf_sensors) && sensors_cnt == 0 &&
		    nextaction > last_sensor_scan + SENSOR_SCAN_INTERVAL)
			nextaction = last_sensor_scan + SENSOR_SCAN_INTERVAL;
		sensors_cnt = 0;
		TAILQ_FOREACH(s, &conf->ntp_sensors, entry) {
			if (conf->settime && s->offsets[0].offset)
				priv_settime(s->offsets[0].offset);
			sensors_cnt++;
			if (s->next > 0 && s->next < nextaction)
				nextaction = s->next;
@


1.130
log
@remove unused variable

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.129 2015/02/12 01:54:57 reyk Exp $ */
d38 3
a40 4
#define	PFD_HOTPLUG	1
#define	PFD_PIPE_DNS	2
#define	PFD_SOCK_CTL	3
#define	PFD_MAX		4
d83 1
a83 1
	int			 hotplugfd, nullfd, pipe_dns[2], idx_clients;
a129 1
	hotplugfd = sensor_hotplugfd();
a253 2
		pfd[PFD_HOTPLUG].fd = hotplugfd;
		pfd[PFD_HOTPLUG].events = POLLIN;
a402 5
		}

		if (nfds > 0 && pfd[PFD_HOTPLUG].revents & (POLLIN|POLLERR)) {
			nfds--;
			sensor_hotplugevent(hotplugfd);
@


1.129
log
@Use ntpd's deferred DNS resolving for constraints as well.  This
allows to get constraint addresses even if network/DNS is not
available at startup (or system boot).

thumbs up & OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.128 2015/02/10 06:40:08 reyk Exp $ */
d85 1
a85 1
	int			 ctls, boundaries;
a355 1
		boundaries = 0;
a362 1
		boundaries = i;
@


1.128
log
@Add support for "constraints": when configured, ntpd(8) will query the
time from HTTPS servers, by parsing the Date: header, and use the
median constraint time as a boundary to verify NTP responses.  This
adds some level of authentication and protection against MITM attacks
while preserving the accuracy of the NTP protocol; without relying on
authentication options for NTP that are basically unavailable at
present.  This is an initial implementation and the semantics will be
improved once it is in the tree.

Discussed with deraadt@@ and henning@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.127 2015/02/10 06:03:43 bcook Exp $ */
d52 1
d88 1
a88 1
	u_int			 ctl_cnt, constraint_cnt;
d586 4
d770 1
a770 1
priv_host_dns(char *name, u_int32_t peerid)
d775 1
a775 1
	imsg_compose(ibuf_dns, IMSG_HOST_DNS, peerid, 0, -1, name, dlen);
@


1.127
log
@be more verbose when logging privsep errors.

ok phessler@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.126 2015/01/13 02:23:33 bcook Exp $ */
d33 1
d45 1
d72 3
d84 1
d87 1
a87 1
	u_int			 ctl_cnt;
d95 1
d99 1
a99 1
	time_t			 nextaction, last_sensor_scan = 0;
d112 7
d174 1
a174 1
	signal(SIGCHLD, SIG_DFL);
d183 6
d236 2
a237 1
		new_cnt = PFD_MAX + peer_cnt + listener_cnt + ctl_cnt;
d272 3
d353 1
d355 15
a369 1
		timeout = nextaction - getmonotime();
d431 1
a431 1
		for (; nfds > 0 && j < i; j++)
d433 5
d447 5
@


1.126
log
@prefer sizeof(thing) to sizeof(type)

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.125 2015/01/09 07:35:37 deraadt Exp $ */
d124 7
a130 4
	if (stat(pw->pw_dir, &stb) == -1)
		fatal("stat");
	if (stb.st_uid != 0 || (stb.st_mode & (S_IWGRP|S_IWOTH)) != 0)
		fatalx("bad privsep dir permissions");
@


1.125
log
@remove excessive/wrong use of sys/param.h
peanuts -- but all work has to start somewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.124 2015/01/04 01:48:49 bcook Exp $ */
d203 1
a203 1
			    sizeof(void *))) == NULL) {
d216 1
a216 1
			    sizeof(struct pollfd))) == NULL) {
d226 2
a227 2
		bzero(pfd, sizeof(struct pollfd) * pfd_elms);
		bzero(idx2peer, sizeof(void *) * idx2peer_elms);
@


1.124
log
@use MAXIMUM as the canonical local MAX macro.

suggested by deraadt@@ re: more general MIN/MAX cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.123 2015/01/04 01:19:46 bcook Exp $ */
d20 1
a20 1
#include <sys/param.h>
@


1.123
log
@don't rely on sys/param.h having a MAX macro.

Switch to local definitions where MAX is needed.

discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.122 2015/01/04 01:16:10 bcook Exp $ */
a736 2
#define SCALE_MAX(a, b) ((a) > (b) ? (a) : (b))

d743 1
a743 1
	r = arc4random_uniform(SCALE_MAX(5, interval / 10));
@


1.122
log
@Remove the unused dns_pid variable.

Nothing is done with the return value from ntp_dns, and it already calls
fatal() on failure.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.121 2014/10/08 04:57:29 deraadt Exp $ */
d737 2
d745 1
a745 1
	r = arc4random_uniform(MAX(5, interval / 10));
@


1.121
log
@easy realloc() -> reallocarray() which gives us mult int overflow checking
for free, FREE, FREEEEE
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.120 2013/11/13 20:44:39 benno Exp $ */
d82 1
a82 1
	pid_t			 pid, dns_pid;
d121 1
a121 1
	dns_pid = ntp_dns(pipe_dns, nconf, pw);
@


1.120
log
@from sthen: handle msgbuf_write() returning EAGAIN

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.119 2013/10/04 14:28:16 phessler Exp $ */
d202 2
a203 2
			if ((newp = realloc(idx2peer, sizeof(void *) *
			    peer_cnt)) == NULL) {
d215 2
a216 2
			if ((newp = realloc(pfd, sizeof(struct pollfd) *
			    new_cnt)) == NULL) {
@


1.119
log
@Add ntpctl(8), which allows us to query the locally running ntpd(8) process

diff from Mike Miller <mmiller mgm51 com> (many thanks!)

OK phessler@@, henning@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.118 2013/09/28 12:18:05 phessler Exp $ */
d338 2
a339 1
			if (msgbuf_write(&ibuf_main->w) < 0) {
d351 2
a352 1
			if (msgbuf_write(&ibuf_dns->w) < 0) {
@


1.118
log
@Resolve the uncertainty in the REFID assignment.

Previously, when there is an even number of offsets, we did the average
of the two middle offets but would set the REFID from one of them.
Instead, we simply select the middle offset with the lowest delay.

diff from Mike Miller <mmiller mgm51 com> (many thanks!)

OK phessler@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.117 2011/09/21 15:41:30 phessler Exp $ */
d39 2
a40 1
#define	PFD_MAX		3
d47 1
d74 2
a75 1
ntp_main(int pipe_prnt[2], struct ntpd_conf *nconf, struct passwd *pw)
d78 1
a78 1
	int			 hotplugfd, nullfd, pipe_dns[2];
d81 1
d91 1
d187 1
d192 1
d213 1
a213 1
		new_cnt = PFD_MAX + peer_cnt + listener_cnt;
d235 2
d290 1
d319 8
d361 5
d378 1
a378 1
		for (; nfds > 0 && j < i; j++)
d385 4
@


1.117
log
@Add rdomain support to NTPd.

This basically adds the "rtable %d" keyword to "listen on", "server",
"servers" keywords, to specify which routing table to use.

OK henning@@ claudio@@ sthen@@
manpage reviewed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.116 2011/06/17 18:12:05 henning Exp $ */
d621 6
a626 12
	if (offset_cnt % 2 == 0) {
		offset_median =
		    (offsets[i - 1]->offset + offsets[i]->offset) / 2;
		conf->status.rootdelay =
		    (offsets[i - 1]->delay + offsets[i]->delay) / 2;
		conf->status.stratum = MAX(
		    offsets[i - 1]->status.stratum, offsets[i]->status.stratum);
	} else {
		offset_median = offsets[i]->offset;
		conf->status.rootdelay = offsets[i]->delay;
		conf->status.stratum = offsets[i]->status.stratum;
	}
@


1.116
log
@close pipe_prnt[0] earlier, foremost before forking the dns process
pointed out by Running Razor <runningrazor at web dot de>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.115 2011/06/16 11:46:55 henning Exp $ */
d248 3
a250 2
				    "next query %ds", log_sockaddr(
				    (struct sockaddr *)&p->addr->ss), timeout);
d486 1
d775 3
a777 2
				log_warnx("bad peer %s%s (%s)",  pool,
				    p->addr_head.name, a);
@


1.115
log
@clamp stratum to NTP_MAXSTRATUM. lingering in my tree for ages. someone likely
deserves to get credited for this, but I have no idea where that came from
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.114 2009/06/11 17:36:53 henning Exp $ */
d113 1
a153 1
	close(pipe_prnt[0]);
@


1.114
log
@effectively un-do r1.111, it fucks machines with bad clocks royally.
spotted the hard way by theo on armish, pinned to this changed by me.
no cookie for ckuethe for not testing on machines with bad clocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.110 2009/01/26 11:51:50 henning Exp $ */
d640 2
@


1.113
log
@If ntpd decides the clock has become unsynced, reset the number of saved
time corrections. Once the clock is synced again, start computing a fresh
frequency correction.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.112 2009/06/06 18:14:25 pyr Exp $ */
a531 5
		return;
	}

	if (conf->filters & FILTER_ADJFREQ){
		conf->filters &= ~FILTER_ADJFREQ;
@


1.112
log
@make ntpd imsg-in-a-lib ready as well. extensive testing done, no
behavior change.
ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.111 2009/06/04 23:39:45 ckuethe Exp $ */
d530 2
a531 1
	if (!conf->status.synced)
d533 1
@


1.111
log
@After calling adjfreq to correct the clock's rate, measure and fix the clock
offset. This avoids future frequency adjustments based on measurements of a
clock that was being adjusted. End result: more stable clock and better
frequency convergence.

Also, fix a mis-ordered structure member while I'm here.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.110 2009/01/26 11:51:50 henning Exp $ */
d565 1
a565 1
	imsg_compose(ibuf_main, IMSG_ADJFREQ, 0, 0, &freq, sizeof(freq));
d636 1
a636 1
	imsg_compose(ibuf_main, IMSG_ADJTIME, 0, 0,
d683 2
a684 1
	imsg_compose(ibuf_main, IMSG_SETTIME, 0, 0, &offset, sizeof(offset));
d694 1
a694 1
	imsg_compose(ibuf_dns, IMSG_HOST_DNS, peerid, 0, name, dlen);
@


1.110
log
@use monotime instead of wallclock for the report thing as well
found on this laptops harddisk, probably from stockholm
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.109 2008/12/10 09:03:30 claudio Exp $ */
d533 5
d566 1
@


1.109
log
@Correctly skip the internal fd when checking the server sockets. Use PFD_MAX
to start the for loop and not 1 which was correct long long time ago.
OK otto@@ found by Anirban Sinha ASinha(at)zeugmasystems.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.108 2008/10/02 14:00:21 henning Exp $ */
d191 1
a191 1
	lastreport = time(NULL) + (5 * 60) - REPORT_INTERVAL;
d744 1
a744 1
	now = time(NULL);
@


1.108
log
@in priv_settime(), we must not adjust the 'next' timestamps on their for
the offset since we use monotime for these for some time now, and monotime
is not affected by system time changes (like, duh, that was the reason for
the change). PR5927
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.107 2008/09/12 10:46:09 henning Exp $ */
d347 1
a347 1
		for (j = 1; nfds > 0 && j < idx_peers; j++)
@


1.107
log
@move dns lookups to its own (privilege revoking, not chrooting) process.
reason: the parent process must never ever block, but the dns routines can.
last not least this fixes ntpd -s 'hanging' for a long time.
tested by a couple of people
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.106 2008/06/10 03:46:09 naddy Exp $ */
a676 2
	struct ntp_peer *p;

a678 7

	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		if (p->next)
			p->next -= offset;
		if (p->deadline)
			p->deadline -= offset;
	}
@


1.106
log
@According to the latest SNTPv4 spec in RFC4330, secondary servers
return the address of the synchronization source as reference
identification.  Remove the obsolete special casing specified in RFC2030.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.105 2008/06/08 19:14:40 ckuethe Exp $ */
d38 2
a39 1
#define	PFD_MAX		2
d44 1
d52 1
d75 1
a75 1
	int			 hotplugfd, nullfd;
d78 1
a78 1
	pid_t			 pid;
d113 5
d157 3
d226 2
d305 2
d330 12
d375 3
a387 4
	struct ntp_peer		*peer, *npeer;
	u_int16_t		 dlen;
	u_char			*p;
	struct ntp_addr		*h;
d415 34
d696 1
a696 1
	imsg_compose(ibuf_main, IMSG_HOST_DNS, peerid, 0, name, dlen);
a789 1

@


1.105
log
@Don't ignore a slightly unresponsive server for an hour, 5 minutes is enough.
comments & ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.104 2008/04/13 00:22:17 djm Exp $ */
a578 1
	conf->status.refid4 = offsets[i]->status.refid4;
@


1.104
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.103 2008/01/28 11:45:59 mpf Exp $ */
d233 1
a233 1
				timeout = error_interval();
@


1.103
log
@Reconnect a client socket after three consecutive send failures.
This allows recovery after an IP address change (e.g. on dialup links).
Also move the update of "nextaction" timeout below the deadline check.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.102 2007/12/27 01:46:50 stevesk Exp $ */
d662 1
a662 1
	r = arc4random() % MAX(5, interval / 10);
d672 1
a672 1
	r = arc4random() % (interval / 10);
@


1.102
log
@some fatal() calls that should be fatalx(); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.101 2007/12/22 18:26:21 stevesk Exp $ */
a231 5
			if (p->next > 0 && p->next < nextaction)
				nextaction = p->next;

			if (p->deadline > 0 && p->deadline < nextaction)
				nextaction = p->deadline;
d245 13
@


1.101
log
@just call getpwnam(NTPD_USER) once; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.100 2007/10/15 06:59:31 otto Exp $ */
d113 1
a113 1
		fatal("bad privsep dir permissions");
@


1.100
log
@Allow ntpd to report the status of peers and sensors to syslog. This
happens when a SIGINFO is received, or when the majority of peers or
sensors is bad. The latter with a maximum of once per 24 hour.
ok henning@@ ckuethe@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.99 2007/08/04 02:58:02 ckuethe Exp $ */
d69 1
a69 1
ntp_main(int pipe_prnt[2], struct ntpd_conf *nconf)
a76 1
	struct passwd		*pw;
a104 3

	if ((pw = getpwnam(NTPD_USER)) == NULL)
		fatal("getpwnam");
@


1.99
log
@This diff makes ntpd poll for sensors more aggressively when the use of
sensors is requested, but no sensors are found.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.98 2007/01/15 08:19:11 otto Exp $ */
d41 1
d45 2
d52 1
d62 3
a74 1
	u_int			 sensors_cnt = 0;
d144 1
d183 3
d337 2
d418 3
d670 56
@


1.98
log
@Although Unix compilers accept more than one definition of a global
symbol, follow the guidelines from K&R: only one definition of a
global symbol (and possibly more declarations).  Rename some vars
here and there to avoid shadowing. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.97 2007/01/14 19:20:09 otto Exp $ */
d256 1
a256 1
			sensor_scan();
d259 3
@


1.97
log
@Esape from the Mouth of Madness by adjusting stored sensor offsets
when we adjust time. This prevents ntpd from going wild when using
sensor time sources; ok henning@@ (on an earlier version) and a LOT
of testing by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.96 2006/12/20 16:50:13 henning Exp $ */
d168 1
a168 1
	sensor_init(conf);
@


1.96
log
@let ntpd use sensors immediately after system boot by special casing
last_sensor_scan == 0. monotime might be very close to 0 after boot.
source unknown, maybe from naddy, rediscovered & ok mblamer
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.95 2006/11/30 18:42:41 ckuethe Exp $ */
d566 5
@


1.95
log
@Allow sensors in a sensors-only configuration to set the time at startup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.94 2006/10/27 12:22:41 henning Exp $ */
d254 2
a255 1
		if (last_sensor_scan + SENSOR_SCAN_INTERVAL < getmonotime()) {
@


1.94
log
@use clock_gettime(CLOCK_MONOTONIC, ..) to get a monotonically increasing
time, and make ntpd use that to send the next uery to an ntp peer and the
like. this has the advantage that changes to the clock do not interfere
with the intervals. for example, when we start on machines without an
RTC and the initial settime (-s) kicks in, intervals were strange.
idea from amandal@@entrisphere.com, this implementation by me
tested ckuethe, phessler, mbalmer, ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.93 2006/10/24 12:23:39 henning Exp $ */
d260 2
@


1.93
log
@timedelta sensors are usually updated very often, but we used to query
them only every 30 seconds. now query them every 5,and take the median
value from 7 queries as sensor value. this takes outliers out of the
equation and makes the overall result much better, especially for
sensors with heavy jitter (like nmea for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.92 2006/10/21 07:30:58 henning Exp $ */
d204 1
a204 1
		nextaction = time(NULL) + 3600;
d220 1
a220 1
			if (p->next > 0 && p->next <= time(NULL)) {
d231 1
a231 1
			if (p->deadline > 0 && p->deadline <= time(NULL)) {
d254 1
a254 1
		if (last_sensor_scan + SENSOR_SCAN_INTERVAL < time(NULL)) {
d256 1
a256 1
			last_sensor_scan = time(NULL);
d273 1
a273 1
		timeout = nextaction - time(NULL);
d318 1
a318 1
			if (s->next <= time(NULL))
@


1.92
log
@        Found that even if client fd (i.e to NTP source) is set to
        -1 because of error, it may still participate in poll()
        causing poll() to repeatedly wake up on error fd.
so make sure w edon't add -1 fds to pollevents to avoid unnecessary wakeups
From: amandal@@entrisphere.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.91 2006/07/01 18:52:46 otto Exp $ */
a48 1
int	offset_compare(const void *, const void *);
@


1.91
log
@remove some unneeded includes; one found by vetinari
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.90 2006/06/30 16:52:13 deraadt Exp $ */
d246 2
a247 1
			if (p->state == STATE_QUERY_SENT) {
@


1.90
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.89 2006/06/26 09:43:06 otto Exp $ */
a34 1
#include "ntp.h"
@


1.89
log
@increase polling intervbal, but only after we are synced and have done
a few frequency adjustments. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.88 2006/06/21 07:42:00 otto Exp $ */
d455 1
a455 1
	offset = conf->freq.overall_offset;	
@


1.88
log
@avoid a race by installing SIGCHLD handler before fork() is called.
ok henning@@ ckuethe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.87 2006/06/17 18:40:42 otto Exp $ */
d154 1
d483 1
d618 2
a619 1
	if (offset > QSCALE_OFF_MAX)
@


1.87
log
@Import frequency conrrection code from dragonfly, whith some changes:
only do frequency compensation if the clock is synced, and a slightly
diffent way of computing the linear regression.
You'll need a recent kernel and libc to use this.
Testing by naddy@@ and ckuethe@@ and others, thanks!
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.86 2006/06/09 07:42:08 otto Exp $ */
d142 1
@


1.86
log
@set session id and init logging in -s mode. tested by david@@ and matthieu@@;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.85 2006/06/08 06:03:07 otto Exp $ */
d152 8
d439 44
d545 2
@


1.85
log
@simplify; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.84 2006/06/07 06:29:03 otto Exp $ */
d94 6
@


1.84
log
@Compensate old offsets with the amount of adjustment done, avoiding
overcompensating. From DragonFly, uses recent adjtime(2) changes,
so you'll need a recent kernel. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.83 2006/06/04 18:58:13 otto Exp $ */
d470 2
a471 1
	if (offset_cnt > 1 && offset_cnt % 2 == 0) {
d473 1
a473 2
		    (offsets[offset_cnt / 2 - 1]->offset +
		    offsets[offset_cnt / 2]->offset) / 2;
d475 1
a475 2
		    (offsets[offset_cnt / 2 - 1]->delay +
		    offsets[offset_cnt / 2]->delay) / 2;
d477 1
a477 2
		    offsets[offset_cnt / 2 - 1]->status.stratum,
		    offsets[offset_cnt / 2]->status.stratum);
d479 3
a481 5
		offset_median = offsets[offset_cnt / 2]->offset;
		conf->status.rootdelay =
		    offsets[offset_cnt / 2]->delay;
		conf->status.stratum =
		    offsets[offset_cnt / 2]->status.stratum;
d483 1
a483 1
	conf->status.leap = offsets[offset_cnt / 2]->status.leap;
d492 2
a493 4
	conf->status.refid4 =
	    offsets[offset_cnt / 2]->status.refid4;
	conf->status.refid =
	    offsets[offset_cnt / 2]->status.send_refid;
@


1.83
log
@Only invalidate stored replies if an adjustment was really made.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.82 2006/06/02 20:45:34 henning Exp $ */
d503 3
a505 1
	TAILQ_FOREACH(p, &conf->ntp_peers, entry)
d507 1
d557 1
@


1.82
log
@incredibly stupid typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.81 2006/06/01 06:04:15 otto Exp $ */
d425 1
a425 1
void
d438 1
a438 1
			return;
d448 3
d470 30
a499 32
	if (offset_cnt > 0) {
		if (offset_cnt > 1 && offset_cnt % 2 == 0) {
			offset_median =
			    (offsets[offset_cnt / 2 - 1]->offset +
			    offsets[offset_cnt / 2]->offset) / 2;
			conf->status.rootdelay =
			    (offsets[offset_cnt / 2 - 1]->delay +
			    offsets[offset_cnt / 2]->delay) / 2;
			conf->status.stratum = MAX(
			    offsets[offset_cnt / 2 - 1]->status.stratum,
			    offsets[offset_cnt / 2]->status.stratum);
		} else {
			offset_median = offsets[offset_cnt / 2]->offset;
			conf->status.rootdelay =
			    offsets[offset_cnt / 2]->delay;
			conf->status.stratum =
			    offsets[offset_cnt / 2]->status.stratum;
		}
		conf->status.leap = offsets[offset_cnt / 2]->status.leap;

		imsg_compose(ibuf_main, IMSG_ADJTIME, 0, 0,
		    &offset_median, sizeof(offset_median));

		conf->status.reftime = gettime();
		conf->status.stratum++;	/* one more than selected peer */
		update_scale(offset_median);

		conf->status.refid4 =
		    offsets[offset_cnt / 2]->status.refid4;
		conf->status.refid =
		    offsets[offset_cnt / 2]->status.send_refid;
	}
d505 2
@


1.81
log
@When expanding servers, do not forget to copy weight. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.80 2006/06/01 05:44:35 henning Exp $ */
d445 1
a445 1
		offset_cnt += p->weight;
@


1.80
log
@urgs, other stuff snuck in
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.79 2006/06/01 04:42:23 henning Exp $ */
d381 1
@


1.79
log
@put back regular sensors scanning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.72 2006/05/27 18:32:00 henning Exp $ */
a431 1
	u_int8_t		  priority = 0;
a437 4
		if (p->priority > priority) {
			priority = p->priority;
			offset_cnt = 0;
		}
a443 4
		if (s->priority > priority) {
			priority = s->priority;
			offset_cnt = 0;
		}
a452 2
		if (p->priority < priority)
			continue;
a458 2
			continue;
		if (s->priority < priority)
@


1.78
log
@only actually run sensor_query when it is due, not every time poll returns
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.77 2006/05/28 20:39:16 henning Exp $ */
d81 1
a81 1
	time_t			 nextaction;
a154 1
	sensor_scan();
d239 4
d432 1
d439 4
d449 4
d462 2
d470 2
@


1.77
log
@allow for weight to be added to sensors or servers, so that one can
weight timedelta sensors higher than ntp peers, for example
ok deraadt mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.76 2006/05/28 18:47:25 henning Exp $ */
d300 2
a301 1
			sensor_query(s);
@


1.76
log
@let sensor_query handle removals itself
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.75 2006/05/28 03:23:08 henning Exp $ */
d425 1
a425 1
	int			  offset_cnt = 0, i = 0;
d434 1
a434 1
		offset_cnt++;
d440 1
a440 1
		offset_cnt++;
d449 2
a450 1
		offsets[i++] = &p->update;
d456 2
a457 1
		offsets[i++] = &s->update;
@


1.75
log
@DV_SENSORS is no more, plug workaround for the time to the real solution
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.74 2006/05/27 22:22:47 henning Exp $ */
d300 1
a300 2
			if (sensor_query(s) == -1)
				sensor_remove(s);
@


1.74
log
@stop passing the config around all time, just store one copy
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.73 2006/05/27 21:27:34 henning Exp $ */
d81 1
a81 1
	time_t			 nextaction, last_sensor_scan = 0;
d155 1
a239 4
		if (last_sensor_scan + SENSOR_SCAN_INTERVAL < time(NULL)) {
			sensor_scan();
			last_sensor_scan = time(NULL);
		}
@


1.73
log
@make ntpd listen on the hotplug socket and decode yadda yadda, because
new sensors showing up will be announced that way when slacking ml comes
back from food
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.72 2006/05/27 18:32:00 henning Exp $ */
d240 1
a240 1
			sensor_scan(conf);
d304 1
a304 1
				sensor_remove(conf, s);
@


1.72
log
@scan for new timedelta sensors every five minutes for now, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.71 2006/05/26 00:33:16 henning Exp $ */
d38 2
a39 1
#define	PFD_MAX		1
d66 2
a67 1
	int			 a, b, nfds, i, j, idx_peers, timeout, nullfd;
d102 1
d193 2
d278 5
@


1.71
log
@add support for timedelta sensors, which pretty much means udcf(4) right
now. untested due to lack of hardware, and it wouldn't have worked in the
plane anyways. work in progress, currently picks up and uses all sensors
it finds, config file bits to be added soon. theo fine with this going in
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.70 2006/05/25 19:30:45 henning Exp $ */
d79 1
a79 1
	time_t			 nextaction;
a151 1
	sensor_scan(conf);
d234 4
@


1.70
log
@more bits from transatlanic flight:
make priv_adjtime() deal with offsets, not peers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.69 2006/05/25 19:25:46 henning Exp $ */
d68 1
d76 1
d151 3
d235 7
d243 2
a244 1
		    ((trial_cnt > 0 && sent_cnt == 0) || peer_cnt == 0))
d286 7
d415 1
d428 6
d441 6
@


1.69
log
@figure out the refid to send to NTP v3 clients early and store it
first bits from a way to long flight
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.68 2006/05/14 22:33:51 henning Exp $ */
d394 4
a397 4
	struct ntp_peer	 *p;
	int		  offset_cnt = 0, i = 0;
	struct ntp_peer	**peers;
	double		  offset_median;
d407 1
a407 1
	if ((peers = calloc(offset_cnt, sizeof(struct ntp_peer *))) == NULL)
d413 1
a413 1
		peers[i++] = p;
d416 1
a416 1
	qsort(peers, offset_cnt, sizeof(struct ntp_peer *), offset_compare);
d421 2
a422 2
			    (peers[offset_cnt / 2 - 1]->update.offset +
			    peers[offset_cnt / 2]->update.offset) / 2;
d424 2
a425 2
			    (peers[offset_cnt / 2 - 1]->update.delay +
			    peers[offset_cnt / 2]->update.delay) / 2;
d427 2
a428 2
			    peers[offset_cnt / 2 - 1]->update.status.stratum,
			    peers[offset_cnt / 2]->update.status.stratum);
d430 1
a430 1
			offset_median = peers[offset_cnt / 2]->update.offset;
d432 1
a432 1
			    peers[offset_cnt / 2]->update.delay;
d434 1
a434 1
			    peers[offset_cnt / 2]->update.status.stratum;
d436 1
a436 1
		conf->status.leap = peers[offset_cnt / 2]->update.status.leap;
d446 1
a446 1
		    peers[offset_cnt / 2]->update.status.refid4;
d448 1
a448 1
		    peers[offset_cnt / 2]->update.status.send_refid;
d451 1
a451 1
	free(peers);
d460 2
a461 2
	const struct ntp_peer * const *a;
	const struct ntp_peer * const *b;
d466 1
a466 1
	if ((*a)->update.offset < (*b)->update.offset)
d468 1
a468 1
	else if ((*a)->update.offset > (*b)->update.offset)
@


1.68
log
@PFD_MAX betterer than harcoded 1
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.67 2005/08/10 13:48:36 dtucker Exp $ */
d447 2
a448 5
		if (peers[offset_cnt / 2]->addr->ss.ss_family == AF_INET)
			conf->status.refid = ((struct sockaddr_in *)
			    &peers[offset_cnt / 2]->addr->ss)->sin_addr.s_addr;
		else
			conf->status.refid = conf->status.refid4;
@


1.67
log
@Propogate server's leap indicator flags to clients; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.66 2005/08/08 14:42:32 henning Exp $ */
d187 1
a187 1
		i = 1;
@


1.66
log
@with -s, do not wait if we don't have any peers at all.
From: Thomas Jarosch <thomas.jarosch@@intra2net.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.65 2005/07/15 03:36:10 henning Exp $ */
d141 1
a141 1
	conf->status.leap = LI_ALARM;
d311 1
a311 1
			if (n == 1 && conf->status.leap == LI_ALARM) {
d313 2
a314 2
				conf->status.leap = LI_NOWARNING;
			} else if (n == 0 && conf->status.leap != LI_ALARM) {
d316 1
a316 1
				conf->status.leap = LI_ALARM;
d436 1
@


1.65
log
@remove recently added "using privsep user X" message, spams console in -s
mode, noticed by kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.64 2005/07/15 03:34:52 henning Exp $ */
d230 2
a231 1
		if (trial_cnt > 0 && sent_cnt == 0 && conf->settime)
@


1.64
log
@fix a function name in an error message
why this was rotting in my tree for so long, I dunno - and I dunno where it
came from
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.63 2005/07/11 08:05:34 dtucker Exp $ */
a98 1
	log_debug("using privsep user '%s' dir '%s'", pw->pw_name, pw->pw_dir);
@


1.63
log
@Print privsep user and dir when in debug mode; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.62 2005/07/05 10:09:12 dtucker Exp $ */
d408 1
a408 1
		fatal("calloc ntp_adjtime");
@


1.62
log
@Save transmit time for each peer for later use as refid for SNTPv4
replies.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.61 2005/06/19 16:42:57 henning Exp $ */
d99 1
@


1.61
log
@use a little state engine to keep track of delayed dns lookups and such,
eases things
tested by Jason Ackley <jason@@ackley.net> Matthias Kilian
<kili@@outback.escape.de> Stephen Marley <stephen@@marley.org.uk> sturm@@
theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.60 2005/05/26 09:13:06 dtucker Exp $ */
d443 2
d448 2
@


1.60
log
@Ensure previous adjust has completed before clearing alarm flag; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.59 2005/05/23 22:46:43 henning Exp $ */
a196 2
			if (p->next > 0 && p->next < nextaction)
				nextaction = p->next;
d198 2
a199 1
				trial_cnt++;
d203 2
d330 1
d332 5
d351 1
d357 1
@


1.59
log
@no need for endpwent(0 here either
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.58 2005/05/03 05:44:35 djm Exp $ */
d307 10
a430 1
		conf->status.leap = LI_NOWARNING;
@


1.58
log
@setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.57 2005/04/18 14:12:50 henning Exp $ */
a124 1
	endpwent();
@


1.57
log
@correctness: only account for offset after settime in next and deadline
when those timers are actually running. due to the way ntpd's logic works
this does not really make a difference, but correctness is good.
spotted by me, joerg agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.56 2005/04/18 11:07:55 henning Exp $ */
d121 2
a122 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid))
@


1.56
log
@after setting the clock hard correct the "next" and "deadline" timestamps
by the offset
From: Joerg Sonnenberger <joerg@@britannica.bec.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.55 2005/03/24 14:50:07 henning Exp $ */
d463 4
a466 2
		p->next -= (time_t)offset;
		p->deadline -= (time_t) offset;
@


1.55
log
@one more fatal/fatalx, alexander
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.54 2005/03/08 16:33:43 henning Exp $ */
d457 2
d461 5
@


1.54
log
@when trying short-circuit the wait for the first reply for -s, only
do so when
-we tried to send at least one query (that is the change)
-we could not send ou a single one without failure (this was already in
 place but catched too much)
problem independently noticed by nick and danh, ok mickey danh, testing by
many
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.53 2005/03/08 16:27:14 deraadt Exp $ */
d343 1
a343 1
				fatal("IMSG_HOST_DNS: dlen != 0");
@


1.53
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.52 2005/03/08 14:37:16 deraadt Exp $ */
d67 1
a67 1
	u_int			 listener_cnt, new_cnt, sent_cnt;
d196 1
a196 1
		sent_cnt = 0;
d200 2
a201 1
			if (p->next > 0 && p->next <= time(NULL))
d204 1
d230 1
a230 1
		if (sent_cnt == 0 && conf->settime)
@


1.52
log
@missing break spotted by lint
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.51 2005/02/22 12:03:24 henning Exp $ */
d145 2
a146 1
	for (a = 0; b > 1; a--, b >>= 1);
@


1.51
log
@when sending a query already returns a failure, we're not going to see
a reply to that query.
if we get errors for all queries and the initial settime() is still due
and thus the parent process still waits (not yet daemonized!), send an
IMSG_SETTIME with offset 0.
shortens the delay dramatically when you boot without network
idea from a discussion with theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.50 2005/02/02 19:03:52 henning Exp $ */
d83 1
@


1.50
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.49 2005/01/28 12:37:20 dtucker Exp $ */
d67 1
a67 1
	u_int			 listener_cnt, new_cnt;
d194 1
d199 2
a200 1
				client_query(p);
d225 3
@


1.49
log
@Simplify interval scaling and randomize query intervals; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.48 2005/01/27 14:44:00 dtucker Exp $ */
d464 9
a472 9
        if (offset < 0)
                offset = -offset;
  
        if (offset > QSCALE_OFF_MAX)
                conf->scale = 1;
        else if (offset < QSCALE_OFF_MIN)
                conf->scale = QSCALE_OFF_MAX / QSCALE_OFF_MIN;
        else
                conf->scale = QSCALE_OFF_MAX / offset;
@


1.48
log
@Scale query interval by the overall offset not per-peer offset, so we
don't query outliers more often than any other server.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.47 2005/01/27 10:32:29 dtucker Exp $ */
d146 1
a146 1
	conf->scale = QSCALE_FACTOR;
d468 1
a468 1
                conf->scale = QSCALE_FACTOR;
d470 1
a470 1
                conf->scale = QSCALE_FACTOR * QSCALE_OFF_MAX / QSCALE_OFF_MIN;
d472 1
a472 1
                conf->scale = QSCALE_FACTOR * QSCALE_OFF_MAX / offset;
d478 5
a482 1
        return (requested * conf->scale / QSCALE_FACTOR);
d484 1
a484 1
   
d486 1
a486 1
error_interval(void)  
d488 5
a492 1
        return (INTERVAL_QUERY_PATHETIC * QSCALE_OFF_MAX / QSCALE_OFF_MIN);
@


1.47
log
@Delay before retrying a query on timeout; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.46 2004/12/23 16:10:10 henning Exp $ */
d146 1
d203 1
a203 2
				timeout = scale_interval(
				    INTERVAL_QUERY_PATHETIC, 0.0);
d415 1
d460 27
@


1.46
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.45 2004/12/22 05:34:52 henning Exp $ */
d202 5
a206 3
				log_debug("no reply from %s received in time",
				    log_sockaddr(
				    (struct sockaddr *)&p->addr->ss));
d213 1
a213 1
				client_query(p);
@


1.45
log
@if our first getpwnam(), testing for NTPD_USER, succeeded, but the second
returns NULL, we don't need loooong explanations, but at least some indicator
what went wrong, From: Michael Knudsen <e@@molioner.dk>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.44 2004/12/13 12:39:15 dtucker Exp $ */
a145 1
	
@


1.44
log
@Sanity check owner and permissions of privsep directory, like sshd does;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.43 2004/12/13 12:36:02 dtucker Exp $ */
d93 1
a93 1
		fatal(NULL);
@


1.43
log
@Check for error status from poll() too; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.42 2004/11/12 17:24:52 henning Exp $ */
d22 1
d76 1
d98 4
@


1.42
log
@some missing includes, from Joerg Sonnenberger <joerg@@britannica.bec.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.41 2004/11/10 11:47:28 henning Exp $ */
d236 1
a236 1
		if (nfds > 0 && pfd[PFD_PIPE_MAIN].revents & POLLIN) {
d243 1
a243 1
			if (pfd[j].revents & POLLIN) {
d250 1
a250 1
			if (pfd[j].revents & POLLIN) {
@


1.41
log
@ntp_adjtime() -> priv_adjtime()
ntp_settime() -> priv_settime()
ntp_host_dns() -> priv_host_dns()
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.40 2004/10/27 14:19:12 dtucker Exp $ */
d30 1
@


1.40
log
@Calculate Hz and round up; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.39 2004/10/27 10:55:27 henning Exp $ */
d356 1
a356 1
ntp_adjtime(void)
d437 1
a437 1
ntp_settime(double offset)
d444 1
a444 1
ntp_host_dns(char *name, u_int32_t peerid)
@


1.39
log
@use clock_getres(3) and calculate precision from that, and fill the
precision field when we reply in server mode accordingly. from phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.38 2004/10/22 21:17:37 henning Exp $ */
d136 2
a137 1
	for (a = 0, b = tp.tv_nsec; b > 0; a--, b >>= 1);
@


1.38
log
@in server mode reply with stratum from the peer that we currently prefer
plus one
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.37 2004/10/13 14:02:50 henning Exp $ */
d21 1
d63 1
a63 1
	int			 nfds, i, j, idx_peers, timeout, nullfd;
d73 1
d135 4
@


1.37
log
@set rootdelay in replies.
inherit rootdelay from the delay from the last client update from the peer
that we picked last time to adjust the local clock.
in some cases we use the average offset between two peers' client updates,
then use the average delay between the two as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.36 2004/10/13 12:22:39 henning Exp $ */
d383 3
d390 2
d398 2
a399 1
		conf->status.leap = LI_NOWARNING;		/* XXX */
@


1.36
log
@correctly set refid in replies with NTP protocol versions < 4.
code path for NTP4 remains unchanged, we already set refid correctly there.
NTP3 and older uses an IPv4 address as refid.
use the IP of the server we last synced to if it was a IPv4 one.
sometimes we use the average offset between two, in that case just pick
one for the IP.
this scheme naturally fails when we query IPv6 servers and have to reply
to IPv4 NTP3 (or even older NTP versions) clients - refid stays at 0 then.
this is a protocol limitation, nothing we can do about it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.35 2004/10/13 09:20:41 henning Exp $ */
d376 1
a376 1
		if (offset_cnt > 1 && offset_cnt % 2 == 0)
d380 4
a383 1
		else
d385 3
@


1.35
log
@when we get back a IMSG_HOST_DNS message from the parent the peer ID within
might have become invalid (because the peer showed up, dns request sent to
parent, peer vanishes, and then the reply comes back), so do not fatal() in
that case but just log_warnx(). provoked by brad
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.34 2004/10/04 11:12:58 henning Exp $ */
d388 4
@


1.34
log
@do not take the average offset from all peers when calculating the total
offset to correct the local clock, but use the median.
given a reasonable sized set of servers this makes us nearly immune against
outliers or flasetickers, without the need for a horribly complicated outliers
detection which does not yield to better results anyway.
test & ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.33 2004/09/18 20:01:38 henning Exp $ */
d288 4
a291 2
			if (peer == NULL)
				fatal("IMSG_HOST_DNS with invalid peerID");
@


1.33
log
@add a new -s option, that tells ntpd to set the time using settimeofday()
once at startup. ntpd delays daemonizing until it has done the intial
time setting (or ran into the timeout) in this mode to make sure stuff started
later in rc is not subject to time jumps.
this eleminates the need to run rdate -n beforehands.
with some input from & ok ryan and bob, march music from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.32 2004/09/18 07:33:14 henning Exp $ */
d46 1
d349 4
a352 3
	struct ntp_peer	*p;
	double		 offset_median = 0;
	int		 offset_cnt = 0;
a356 1

d359 2
d362 7
a368 2
		offset_median += p->update.offset;
		offset_cnt++;
d371 2
d374 7
a380 1
		offset_median /= offset_cnt;
d388 2
d392 17
@


1.32
log
@do not bother overallocating and shrinking the pfd and idx2peer arrays,
doesn't by us anything. discussed with ryan during dinner at original joe's
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.31 2004/09/15 19:21:25 henning Exp $ */
d22 2
d61 1
a61 1
	int			 nfds, i, j, idx_peers, timeout;
d89 3
d97 7
d243 2
a244 2
				if (client_dispatch(idx2peer[j - idx_peers]) ==
				     -1)
d374 7
@


1.31
log
@imsg framework cleanup:
-kill the _pid flavors of imsg_create and imsg_compose, and just add pid as
argument to those
-use imsg_create in imsg_compose instead of duplicating code
-check for datalen overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.30 2004/09/15 19:14:11 henning Exp $ */
d128 1
a128 2
		if (peer_cnt > idx2peer_elms ||
		    peer_cnt + IDX2PEER_RESERVE < idx2peer_elms) {
d130 1
a130 1
			    (peer_cnt + IDX2PEER_RESERVE))) == NULL) {
d133 1
a133 2
				    "%u entries", idx2peer_elms,
				    peer_cnt + IDX2PEER_RESERVE);
d137 1
a137 1
			idx2peer_elms = peer_cnt + IDX2PEER_RESERVE;
d141 1
a141 2
		if (new_cnt > pfd_elms ||
		    new_cnt + PFD_RESERVE < pfd_elms) {
d143 1
a143 1
			    (new_cnt + PFD_RESERVE))) == NULL) {
d146 1
a146 2
				    "%u entries", pfd_elms,
				    new_cnt + PFD_RESERVE);
d150 1
a150 1
			pfd_elms = new_cnt + PFD_RESERVE;
@


1.30
log
@malloc the imsg buffers instead of having them statically, suggested by
micsky some time ago, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.29 2004/09/15 00:08:06 henning Exp $ */
d357 1
a357 1
		imsg_compose(ibuf_main, IMSG_ADJTIME, 0,
d374 1
a374 1
	imsg_compose(ibuf_main, IMSG_HOST_DNS, peerid, name, dlen);
@


1.29
log
@unused variables, theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.28 2004/09/15 00:07:20 henning Exp $ */
d36 1
a36 1
struct imsgbuf		 ibuf_main;
d111 3
a113 1
	imsg_init(&ibuf_main, pipe_prnt[1]);
d160 1
a160 1
		pfd[PFD_PIPE_MAIN].fd = ibuf_main.fd;
d200 1
a200 1
		if (ibuf_main.w.queued > 0)
d214 1
a214 1
			if (msgbuf_write(&ibuf_main.w) < 0) {
d241 3
a243 2
	msgbuf_write(&ibuf_main.w);
	msgbuf_clear(&ibuf_main.w);
d259 1
a259 1
	if ((n = imsg_read(&ibuf_main)) == -1)
d268 1
a268 1
		if ((n = imsg_get(&ibuf_main, &imsg)) == -1)
d357 1
a357 1
		imsg_compose(&ibuf_main, IMSG_ADJTIME, 0,
d374 1
a374 1
	imsg_compose(&ibuf_main, IMSG_HOST_DNS, peerid, name, dlen);
@


1.28
log
@missing include, from theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.27 2004/09/09 21:50:33 henning Exp $ */
a36 1
struct l_fixedpt	 ref_ts;
@


1.27
log
@correctly track peer count. fixes a memory corruption.
with & ok otto millert claudio, ok deraadt canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.26 2004/08/12 16:33:59 henning Exp $ */
d24 1
@


1.26
log
@do not try to getaddrinfo() in the unprivileged process, send an imsg
asking the privileged one to do it. sends back an imsg with the
resulting addresses in a bunch of struct sockaddr_storage in the data
part.
this should fix all remaining issues with dns (non-)availability at
ntpd startup, be it due to named on localhost or something else.
tested by marco@@ and Chris Paul <chris.paul@@sentinare.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.25 2004/07/18 12:59:41 henning Exp $ */
d38 1
d42 2
d61 1
a61 1
	u_int			 listener_cnt, peer_cnt, new_cnt;
d297 1
a297 2
					TAILQ_INSERT_TAIL(&conf->ntp_peers,
					    npeer, entry);
d306 3
a308 4
			if (peer->addr_head.pool) {
				TAILQ_REMOVE(&conf->ntp_peers, peer, entry);
				free(peer);
			} else
d317 15
@


1.25
log
@query interval scaling, episode II
1) base the interval calculation on the offset from the last reply, not
   from the last peer update.
   Allows us to send more queries again faster when the local clock
   diverges too much
2) every time we form a peer update (for which we need 8 replies)
   check wether we have a ready peer update for all peers that are
   currently trusted, and if so, calculate the total offset and call
   adjtime().
   that means that adjtime is no longer called in fixed intervals
   but whenever we have enough data to reliably calculate the local
   clock offset.
   In practice, that means we call adjtime() less often, but with
   probably better data.
3) invalidate peer updates after beeing used. no point in re-using them
   - this resulted in calling adjtime() multiple times with the same
   offset, which doesn't make sense
tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.24 2004/07/14 20:16:31 henning Exp $ */
d248 4
d269 41
d347 9
@


1.24
log
@do not do the stratum guessing dance.
stratum is pretty much pointless anyway these days, and we certainly
do not want to send out illegal packets (stratum=0) until synced...
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.23 2004/07/13 19:41:26 alexander Exp $ */
d37 1
a40 1
void	ntp_adjtime(struct ntpd_conf *);
d54 1
a54 1
ntp_main(int pipe_prnt[2], struct ntpd_conf *conf)
d66 1
a66 1
	time_t			 nextaction, next_adjtime;
d91 1
a121 2
	next_adjtime = time(NULL) + INTERVAL_ADJTIME;

d154 1
a154 1
		nextaction = next_adjtime;
a194 5
		if (next_adjtime <= time(NULL)) {
			next_adjtime = time(NULL) + INTERVAL_ADJTIME;
			ntp_adjtime(conf);
		}

d274 1
a274 1
ntp_adjtime(struct ntpd_conf *conf)
d281 1
a281 1
		if (!p->update.good)
d284 2
a285 7
		if (p->update.rcvd + REPLY_MAXAGE < time(NULL)) {
			p->update.good = 0;
			continue;
		}

		if (p->trustlevel < TRUSTLEVEL_BADPEER)
			continue;
d299 3
@


1.23
log
@Respond to client queries with better server statistics.  We now output
a close-to-reality stratum, a real reference time, and a leap indicator
that will indicate if the local clock isn't synchronized.

This also means that until the server feels it's synchronized, it will
tell the clients it isn't.  This is normal, and correct.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.22 2004/07/10 18:42:51 henning Exp $ */
d284 1
a284 1
	int		 offset_cnt = 0, stratum = 254;
a299 3

		if (p->update.status.stratum < stratum)
			stratum = p->update.status.stratum;	/* XXX */
a307 1
		conf->status.stratum = stratum + 1;
@


1.22
log
@scale query interval based on local clock offset. tested by many
not as efficient as I want it to be yet, but more is coming
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.21 2004/07/09 15:00:43 henning Exp $ */
d112 3
d229 1
a229 1
				if (server_dispatch(pfd[j].fd) == -1)
d284 1
a284 1
	int		 offset_cnt = 0;
d286 7
a292 9
	TAILQ_FOREACH(p, &conf->ntp_peers, entry)
		if (p->update.good) {
			if (p->update.rcvd + REPLY_MAXAGE < time(NULL))
				p->update.good = 0;
			else
				if (p->trustlevel >= TRUSTLEVEL_BADPEER) {
					offset_median += p->update.offset;
					offset_cnt++;
				}
d295 10
d309 4
@


1.21
log
@don't try to update the clock when we have no data
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.20 2004/07/09 12:21:09 henning Exp $ */
a40 1
int	get_peer_update(struct ntp_peer *, double *);
d177 1
a177 1
				    --p->trustlevel < TRUSTLEVEL_BADPEER)
d280 1
a280 1
	double		 offset, offset_median = 0;
d284 8
a291 3
		if (get_peer_update(p, &offset) == 0) {
			offset_median += offset;
			offset_cnt++;
a298 48
}

int
get_peer_update(struct ntp_peer *p, double *offset)
{
	int	i, best = 0, good = 0;

	/*
	 * clock filter
	 * find the offset which arrived with the lowest delay
	 * use that as the peer update
	 * invalidate it and all older ones
	 */

	for (i = 0; good == 0 && i < OFFSET_ARRAY_SIZE; i++)
		if (p->reply[i].good) {
			good++;
			best = i;
		}

	for (; i < OFFSET_ARRAY_SIZE; i++) {
		if (p->reply[i].good &&
		    p->reply[i].rcvd + REPLY_MAXAGE < time(NULL))
			p->reply[i].good = 0;

		if (p->reply[i].good)
			good++;
			if (p->reply[i].delay < p->reply[best].delay)
				best = i;
	}

	/* lower trust in the peer when too few good replies received */
	if (good < 8 && p->trustlevel > 0) {
		if (p->trustlevel >= TRUSTLEVEL_BADPEER)
			log_info("peer %s now invalid",
			    log_sockaddr((struct sockaddr *)&p->addr->ss));
		p->trustlevel /= 2;
	}

	if (good == 0 || p->trustlevel < TRUSTLEVEL_BADPEER)
		return (-1);

	for (i = 0; i < OFFSET_ARRAY_SIZE; i++)
		if (p->reply[i].rcvd <= p->reply[best].rcvd)
			p->reply[i].good = 0;

	*offset = p->reply[best].offset;
	return (0);
@


1.20
log
@the child process needs to ignore SIGHUP for now, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.19 2004/07/09 10:53:33 henning Exp $ */
d290 3
a292 3
	offset_median /= offset_cnt;

	imsg_compose(&ibuf_main, IMSG_ADJTIME, 0,
d294 1
@


1.19
log
@rework dns handling with all its cosequences...
we know have both a "server" and "servers" keyword. they differ when the
hostname resolves to more than one IP, server picks one and servers expands
to all.
that means no longer stuffing a sockaddr_storage into ntp_peer but a pointer
to a linked list of ntp_addr structs.
in the "servers" case the list of n addresses returned by host() is expanded
into n ntp_peer structs and thus n individual peers.
in the "server" case the whole list is attached to ntp_peer, and whenever we
do not receive a reply in time we traverse the list one further, so that
hosts with both AAAA and A records are first tried with the AAAA one but
we gracefully fall back to the A one.
semantics with theo; hacked up on the Montreal->Frankfurt flight.
again Air Canada surprised me, that older 767 hat pretty decent seats.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.18 2004/07/09 10:22:07 henning Exp $ */
d105 1
@


1.18
log
@when calculating the timeout for poll() we need to take the deadlines for
the outstanding queries into account
just-before-meal from the Montreal->Frankfurt flight
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.17 2004/07/08 15:06:13 henning Exp $ */
a166 1

d174 2
a175 1
				    log_sockaddr((struct sockaddr *)&p->ss));
d180 2
a181 1
					    (struct sockaddr *)&p->ss));
d328 1
a328 1
			    log_sockaddr((struct sockaddr *)&p->ss));
@


1.17
log
@remove a bogus always-true test before adjtime()
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.16 2004/07/08 01:21:09 henning Exp $ */
d171 3
a173 1
			if  (p->deadline > 0 && p->deadline <= time(NULL)) {
@


1.16
log
@log_debug() when a peer doesn't answer in time
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.15 2004/07/07 07:32:05 alexander Exp $ */
d288 2
a289 3
	if (offset_median >= 0.001 || offset_median <= 0.001)
		imsg_compose(&ibuf_main, IMSG_ADJTIME, 0,
			    &offset_median, sizeof(offset_median));
@


1.15
log
@* Convert to use the new double-based time handling functions.
* Respond to the query with a reasonable received time (which
  will help clients get better accuracy).
* Consolidate the server response code in preparation for a
  completely 'proper' response to the client.

tips and ok from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.14 2004/07/07 03:57:28 henning Exp $ */
d172 2
@


1.14
log
@yuck, another bad sizeof(). again in code hacked on the Frankfurt->Montreal
flight. should we draw concludions from that? I'd like to blame the
Air Canada seats...
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.13 2004/07/07 01:01:27 henning Exp $ */
a39 1
int	ntp_dispatch(int fd);
d221 1
a221 1
				if (ntp_dispatch(pfd[j].fd) == -1)
a267 20
	return (0);
}

int
ntp_dispatch(int fd)
{
	struct sockaddr_storage	 fsa;
	socklen_t		 fsa_len;
	char			 buf[NTP_MSGSIZE];
	ssize_t			 size;
	struct ntp_msg		 msg;

	fsa_len = sizeof(fsa);
	if ((size = recvfrom(fd, &buf, sizeof(buf), 0,
	    (struct sockaddr *)&fsa, &fsa_len)) == -1)
		fatal("recvfrom");

	ntp_getmsg(buf, size, &msg);
	ntp_reply(fd, (struct sockaddr *)&fsa, &msg, 0);

@


1.13
log
@keep a "trustlevel" per peer. loose credit for loosing a packet, loose
a lot of credit for not having supplied us with enough data within an
adjtime run interval, and get a little credit each time we get a good
reply packet. if a peer is below 20%, only send a packet occasionally to
see wether it is back. send out queries much more often between 20 and 80%
to (re-)sync quickly, and above 80% usethe regular interval.
do not use peers < 60% for calculating teh local clock offset.
designed with theo at the pho, alexander ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.12 2004/07/06 23:26:38 henning Exp $ */
d152 1
a152 1
		bzero(idx2peer, sizeof(struct ntp_peer) * idx2peer_elms);
@


1.12
log
@Implement the clock filter as descirbed by David Mills:
form the last 8 replied received from a peer, find the one with the lowest
delay. Use that as the peer's update taken into account for calculating
the local clock's offset.
Invalidate that reply and all ones received earlier than it so that they do
not get used again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.11 2004/07/05 22:12:53 henning Exp $ */
d168 10
a177 2
			if ((p->next > 0 && p->next <= time(NULL)) ||
			    (p->deadline > 0 && p->deadline <= time(NULL)))
d179 1
d299 1
a299 4
	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		if (!p->valid)
			continue;

a303 1
	}
d330 6
a335 2
	for (; i < OFFSET_ARRAY_SIZE; i++)
		if (p->reply[i].good) {
d339 1
a339 1
		}
d341 7
a347 1
	/* XXX lower trust in the peer when too few good replies received */
d349 1
a349 1
	if (good == 0)
@


1.11
log
@keep last 8 offset,delay pairs - we'll need them for the clock filters later.
for now, average over those to adjust the local clock.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.10 2004/07/05 07:46:16 henning Exp $ */
d42 1
d287 1
a287 1
	double		 offset_median = 0;
a288 1
	u_int8_t	 idx;
d294 2
a295 2
		for (idx = 0; idx < OFFSET_ARRAY_SIZE; idx++) {
			offset_median += p->offset[idx];
d305 38
@


1.10
log
@calculate the median offset from all servers we sync to and call
adjtime() when necessary to keep the local clock in sync
yes, that means ntpd syncs the local clock now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.9 2004/06/22 07:59:48 alexander Exp $ */
d288 1
d291 1
a291 1
		if (p->state == STATE_NONE)
d294 4
a297 2
		offset_median += p->offset;
		offset_cnt++;
d302 1
a302 1
	if (offset_median >= 0.001 || offset_median <= 0.001) {
a304 3
		TAILQ_FOREACH(p, &conf->ntp_peers, entry)
			p->offset = 0;
	}
@


1.9
log
@Precedence and type fix; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.8 2004/06/18 04:51:31 henning Exp $ */
d41 1
d67 1
a67 1
	time_t			 nextaction;
d118 2
d152 1
a152 1
		nextaction = time(NULL) + 240;
a154 2
		if (ibuf_main.w.queued > 0)
			pfd[PFD_PIPE_MAIN].events |= POLLOUT;
a162 1

d179 8
d196 1
d280 25
@


1.8
log
@size struct pollfd and idx2peer dynamically instead of imposing an arbitary
limit on OPEN_MAX, modeled after bgpd
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.7 2004/06/17 19:17:48 henning Exp $ */
d121 1
a121 1
			    peer_cnt + IDX2PEER_RESERVE)) == NULL) {
d135 2
a136 2
			if ((newp = realloc(pfd, sizeof(void *) *
			    new_cnt + PFD_RESERVE)) == NULL) {
@


1.7
log
@provide most of the client functionality.
hook the descriptors into the main poll and such.
we're not doing anything with the reply we recive yet, tho.

mostly hacked on the Frankfurt->Montreal flight, as batteries and those
horrible air canada seats permitted...
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.6 2004/06/02 10:08:59 henning Exp $ */
d32 1
d57 2
d60 1
a60 1
	struct pollfd		 pfd[OPEN_MAX];
d65 1
a65 1
	struct ntp_peer		*idx2peer[OPEN_MAX];
d67 1
d91 1
a91 1
	setup_listeners(se, conf);
d113 4
d118 31
a148 2
		bzero(&pfd, sizeof(pfd));
		bzero(idx2peer, sizeof(idx2peer));
a159 2
			if (i > OPEN_MAX)
				fatal("i > OPEN_MAX");
a175 2
				if (i > OPEN_MAX)
					fatal("i > OPEN_MAX");
@


1.6
log
@prepare for client functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.5 2004/06/01 21:58:08 henning Exp $ */
d55 1
a55 1
	int			 nfds, i, j;
d61 3
d104 3
d111 2
d123 21
d146 5
a150 1
		if ((nfds = poll(pfd, i, INFTIM)) == -1)
a154 1

d167 1
a167 1
		for (j = 1; nfds > 0 && j < i; j++)
d171 8
@


1.5
log
@first cut at config file parser
for now, one can set the addresses to listen on
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.4 2004/06/01 16:27:09 henning Exp $ */
a21 1
#include <netdb.h>
a37 1
int	setup_listeners(struct servent *, struct ntpd_conf *);
a39 4
int	ntp_getmsg(char *, ssize_t, struct ntp_msg *);
int	ntp_reply(int, struct sockaddr *, struct ntp_msg *, int);
int	ntp_sendmsg(int, struct sockaddr *, struct ntp_msg *, ssize_t, int);
void	get_ts(struct l_fixedpt *);
a103 1
		get_ts(&ref_ts);	/* XXX */
a150 51
setup_listeners(struct servent *se, struct ntpd_conf *conf)
{
	struct listen_addr	*la;

	if (TAILQ_EMPTY(&conf->listen_addrs)) {
		if ((la = calloc(1, sizeof(struct listen_addr))) == NULL)
			fatal("setup_listeners calloc");
		la->sa.ss_len = sizeof(struct sockaddr_in);
		((struct sockaddr_in *)&la->sa)->sin_family = AF_INET;
		((struct sockaddr_in *)&la->sa)->sin_addr.s_addr =
		    htonl(INADDR_ANY);
		((struct sockaddr_in *)&la->sa)->sin_port = se->s_port;
		TAILQ_INSERT_TAIL(&conf->listen_addrs, la, entry);

		if ((la = calloc(1, sizeof(struct listen_addr))) == NULL)
			fatal("setup_listeners calloc");
		la->sa.ss_len = sizeof(struct sockaddr_in6);
		((struct sockaddr_in6 *)&la->sa)->sin6_family = AF_INET6;
		((struct sockaddr_in6 *)&la->sa)->sin6_port = se->s_port;
		TAILQ_INSERT_TAIL(&conf->listen_addrs, la, entry);
	}

	TAILQ_FOREACH(la, &conf->listen_addrs, entry) {
		switch (la->sa.ss_family) {
		case AF_INET:
			if (((struct sockaddr_in *)&la->sa)->sin_port == 0)
				((struct sockaddr_in *)&la->sa)->sin_port =
				    se->s_port;
			break;
		case AF_INET6:
			if (((struct sockaddr_in6 *)&la->sa)->sin6_port == 0)
				((struct sockaddr_in6 *)&la->sa)->sin6_port =
				    se->s_port;
			break;
		default:
			fatalx("king bula sez: af borked");

		}

		if ((la->fd = socket(la->sa.ss_family, SOCK_DGRAM, 0)) == -1)
			fatal("socket");

		if (bind(la->fd, (struct sockaddr *)&la->sa, la->sa.ss_len) ==
		    -1)
			fatal("bind");
	}

	return (0);
}

int
a198 162

int
ntp_getmsg(char *p, ssize_t len, struct ntp_msg *msg)
{
	int		 auth, i;

	if (len == NTP_MSGSIZE)
		auth = 1;
	else if (len == NTP_MSGSIZE_NOAUTH)
		auth = 0;
	else {
		log_warnx("malformed packet received");
		return (-1);
	}

	memcpy(&msg->status, p, sizeof(msg->status));
	p += sizeof(msg->status);
	memcpy(&msg->stratum, p, sizeof(msg->stratum));
	p += sizeof(msg->stratum);
	memcpy(&msg->ppoll, p, sizeof(msg->ppoll));
	p += sizeof(msg->ppoll);
	memcpy(&msg->precision, p, sizeof(msg->precision));
	p += sizeof(msg->precision);
	memcpy(&msg->distance.int_part, p, sizeof(msg->distance.int_part));
	p += sizeof(msg->distance.int_part);
	memcpy(&msg->distance.fraction, p, sizeof(msg->distance.fraction));
	p += sizeof(msg->distance.fraction);
	memcpy(&msg->dispersion.int_part, p, sizeof(msg->dispersion.int_part));
	p += sizeof(msg->dispersion.int_part);
	memcpy(&msg->dispersion.fraction, p, sizeof(msg->dispersion.fraction));
	p += sizeof(msg->dispersion.fraction);
	memcpy(&msg->refid, p, sizeof(msg->refid));
	p += sizeof(msg->refid);
	memcpy(&msg->reftime.int_part, p, sizeof(msg->reftime.int_part));
	p += sizeof(msg->reftime.int_part);
	memcpy(&msg->reftime.fraction, p, sizeof(msg->reftime.fraction));
	p += sizeof(msg->reftime.fraction);
	memcpy(&msg->orgtime.int_part, p, sizeof(msg->orgtime.int_part));
	p += sizeof(msg->orgtime.int_part);
	memcpy(&msg->orgtime.fraction, p, sizeof(msg->orgtime.fraction));
	p += sizeof(msg->orgtime.fraction);
	memcpy(&msg->rectime.int_part, p, sizeof(msg->rectime.int_part));
	p += sizeof(msg->rectime.int_part);
	memcpy(&msg->rectime.fraction, p, sizeof(msg->rectime.fraction));
	p += sizeof(msg->rectime.fraction);
	memcpy(&msg->xmttime.int_part, p, sizeof(msg->xmttime.int_part));
	p += sizeof(msg->xmttime.int_part);
	memcpy(&msg->xmttime.fraction, p, sizeof(msg->xmttime.fraction));
	p += sizeof(msg->xmttime.fraction);

	if (auth) {
		memcpy(&msg->keyid, p, sizeof(msg->keyid));
		p += sizeof(msg->refid);
		for (i = 0; i < NTP_DIGESTSIZE; i++) {
			memcpy(&msg->digest[i], p, sizeof(msg->digest[i]));
			p += sizeof(msg->digest[i]);
		}

		/* XXX check auth */
	}

	return (0);
}

int
ntp_reply(int fd, struct sockaddr *sa, struct ntp_msg *query, int auth)
{
	ssize_t			 len;
	struct l_fixedpt	 t;
	struct ntp_msg		 reply;

	if (auth)
		len = NTP_MSGSIZE;
	else
		len = NTP_MSGSIZE_NOAUTH;

	bzero(&reply, sizeof(reply));
	reply.status = 0 | (query->status & VERSIONMASK);
	if ((query->status & MODEMASK) == MODE_CLIENT)
		reply.status |= MODE_SERVER;
	else
		reply.status |= MODE_SYM_PAS;

	reply.stratum =	2;
	reply.ppoll = query->ppoll;
	reply.precision = 0;			/* XXX */
	reply.refid = htonl(t.fraction);	/* XXX */
	reply.reftime.int_part = htonl(ref_ts.int_part);
	reply.reftime.fraction = htonl(ref_ts.fraction);
	get_ts(&t);
	reply.rectime.int_part = htonl(t.int_part);
	reply.rectime.fraction = htonl(t.fraction);
	reply.xmttime.int_part = htonl(t.int_part);
	reply.xmttime.fraction = htonl(t.fraction);
	reply.orgtime.int_part = query->xmttime.int_part;
	reply.orgtime.fraction = query->xmttime.fraction;

	return (ntp_sendmsg(fd, sa, &reply, len, auth));
}

int
ntp_sendmsg(int fd, struct sockaddr *sa, struct ntp_msg *msg, ssize_t len,
    int auth)
{
	char	 buf[NTP_MSGSIZE];
	char	*p;

	p = buf;
	memcpy(p, &msg->status, sizeof(msg->status));
	p += sizeof(msg->status);
	memcpy(p, &msg->stratum, sizeof(msg->stratum));
	p += sizeof(msg->stratum);
	memcpy(p, &msg->ppoll, sizeof(msg->ppoll));
	p += sizeof(msg->ppoll);
	memcpy(p, &msg->precision, sizeof(msg->precision));
	p += sizeof(msg->precision);
	memcpy(p, &msg->distance.int_part, sizeof(msg->distance.int_part));
	p += sizeof(msg->distance.int_part);
	memcpy(p, &msg->distance.fraction, sizeof(msg->distance.fraction));
	p += sizeof(msg->distance.fraction);
	memcpy(p, &msg->dispersion.int_part, sizeof(msg->dispersion.int_part));
	p += sizeof(msg->dispersion.int_part);
	memcpy(p, &msg->dispersion.fraction, sizeof(msg->dispersion.fraction));
	p += sizeof(msg->dispersion.fraction);
	memcpy(p, &msg->refid, sizeof(msg->refid));
	p += sizeof(msg->refid);
	memcpy(p, &msg->reftime.int_part, sizeof(msg->reftime.int_part));
	p += sizeof(msg->reftime.int_part);
	memcpy(p, &msg->reftime.fraction, sizeof(msg->reftime.fraction));
	p += sizeof(msg->reftime.fraction);
	memcpy(p, &msg->orgtime.int_part, sizeof(msg->orgtime.int_part));
	p += sizeof(msg->orgtime.int_part);
	memcpy(p, &msg->orgtime.fraction, sizeof(msg->orgtime.fraction));
	p += sizeof(msg->orgtime.fraction);
	memcpy(p, &msg->rectime.int_part, sizeof(msg->rectime.int_part));
	p += sizeof(msg->rectime.int_part);
	memcpy(p, &msg->rectime.fraction, sizeof(msg->rectime.fraction));
	p += sizeof(msg->rectime.fraction);
	memcpy(p, &msg->xmttime.int_part, sizeof(msg->xmttime.int_part));
	p += sizeof(msg->xmttime.int_part);
	memcpy(p, &msg->xmttime.fraction, sizeof(msg->xmttime.fraction));
	p += sizeof(msg->xmttime.fraction);

	if (auth) {
		/* XXX */
	}

	if (sendto(fd, &buf, len, 0, sa, sa->sa_len) != len)
		fatal("sendto");

	return (0);
}

void
get_ts(struct l_fixedpt *t)
{
	struct timeval		 tv;

	gettimeofday(&tv, NULL);
	t->int_part = tv.tv_sec + JAN_1970;
	t->fraction = ((float)tv.tv_usec)/1000000 * UINT_MAX;
}@


1.4
log
@allow ntpd to listen on nearly arbitary number of sockets (OPEN_MAX - 1 atm).
default to one IPv4 wildcard and one IPv6 wildcard one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.3 2004/05/31 21:43:23 henning Exp $ */
d181 16
@


1.3
log
@naming consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.2 2004/05/31 15:11:56 henning Exp $ */
d32 1
a32 4
#define	PFD_LISTEN	0
#define	PFD_LISTEN6	1
#define	PFD_PIPE_MAIN	2
#define	PFD_MAX		3
d39 1
a39 2
int	setup_listener(struct servent *);
int	setup_listener6(struct servent *);
d59 1
a59 1
ntp_main(int pipe_prnt[2])
d61 1
a61 3
	int			 nfds;
	int			 sock = -1;
	int			 sock6 = -1;
d63 1
a63 1
	struct pollfd		 pfd[PFD_MAX];
d66 1
d90 1
a90 2
	sock = setup_listener(se);
	sock6 = setup_listener6(se);
a111 4
		pfd[PFD_LISTEN].fd = sock;
		pfd[PFD_LISTEN].events = POLLIN;
		pfd[PFD_LISTEN6].fd = sock6;
		pfd[PFD_LISTEN6].events = POLLIN;
d117 8
a124 1
		if ((nfds = poll(pfd, PFD_MAX, INFTIM)) == -1)
d142 6
a147 11
		if (nfds > 0 && pfd[PFD_LISTEN].revents & POLLIN) {
			nfds--;
			if (ntp_dispatch(sock) == -1)
				ntp_quit = 1;
		}

		if (nfds > 0 && pfd[PFD_LISTEN6].revents & POLLIN) {
			nfds--;
			if (ntp_dispatch(sock6) == -1)
				ntp_quit = 1;
		}
d158 1
a158 1
setup_listener(struct servent *se)
d160 1
a160 2
	struct sockaddr_in	 sa_in;
	int			 fd;
d162 17
a178 2
	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatal("socket");
d180 8
a187 28
	bzero(&sa_in, sizeof(sa_in));
	sa_in.sin_len = sizeof(sa_in);
	sa_in.sin_family = AF_INET;
	sa_in.sin_addr.s_addr = htonl(INADDR_ANY);
	sa_in.sin_port = se->s_port;

	if (bind(fd, (struct sockaddr *)&sa_in, sizeof(sa_in)) == -1)
		fatal("bind");

	return (fd);
}

int
setup_listener6(struct servent *se)
{
	struct sockaddr_in6	 sa_in6;
	int			 fd;

	if ((fd = socket(AF_INET6, SOCK_DGRAM, 0)) == -1)
		fatal("socket");

	bzero(&sa_in6, sizeof(sa_in6));
	sa_in6.sin6_len = sizeof(sa_in6);
	sa_in6.sin6_family = AF_INET6;
	sa_in6.sin6_port = se->s_port;

	if (bind(fd, (struct sockaddr *)&sa_in6, sizeof(sa_in6)) == -1)
		fatal("bind");
d189 1
a189 1
	return (fd);
@


1.2
log
@make my japanese friends happy by supporting IPv6 as well
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.1 2004/05/31 13:46:16 henning Exp $ */
d46 1
a46 1
int	parse_ntp_msg(char *, ssize_t, struct ntp_msg *);
d48 1
a48 1
int	ntp_send(int, struct sockaddr *, struct ntp_msg *, ssize_t, int);
d250 1
a250 1
	parse_ntp_msg(buf, size, &msg);
d257 1
a257 1
parse_ntp_msg(char *p, ssize_t len, struct ntp_msg *msg)
d352 1
a352 1
	return (ntp_send(fd, sa, &reply, len, auth));
d356 1
a356 1
ntp_send(int fd, struct sockaddr *sa, struct ntp_msg *reply, ssize_t len,
d363 34
a396 36
	memcpy(p, &reply->status, sizeof(reply->status));
	p += sizeof(reply->status);
	memcpy(p, &reply->stratum, sizeof(reply->stratum));
	p += sizeof(reply->stratum);
	memcpy(p, &reply->ppoll, sizeof(reply->ppoll));
	p += sizeof(reply->ppoll);
	memcpy(p, &reply->precision, sizeof(reply->precision));
	p += sizeof(reply->precision);
	memcpy(p, &reply->distance.int_part, sizeof(reply->distance.int_part));
	p += sizeof(reply->distance.int_part);
	memcpy(p, &reply->distance.fraction, sizeof(reply->distance.fraction));
	p += sizeof(reply->distance.fraction);
	memcpy(p, &reply->dispersion.int_part,
	    sizeof(reply->dispersion.int_part));
	p += sizeof(reply->dispersion.int_part);
	memcpy(p, &reply->dispersion.fraction,
	    sizeof(reply->dispersion.fraction));
	p += sizeof(reply->dispersion.fraction);
	memcpy(p, &reply->refid, sizeof(reply->refid));
	p += sizeof(reply->refid);
	memcpy(p, &reply->reftime.int_part, sizeof(reply->reftime.int_part));
	p += sizeof(reply->reftime.int_part);
	memcpy(p, &reply->reftime.fraction, sizeof(reply->reftime.fraction));
	p += sizeof(reply->reftime.fraction);
	memcpy(p, &reply->orgtime.int_part, sizeof(reply->orgtime.int_part));
	p += sizeof(reply->orgtime.int_part);
	memcpy(p, &reply->orgtime.fraction, sizeof(reply->orgtime.fraction));
	p += sizeof(reply->orgtime.fraction);
	memcpy(p, &reply->rectime.int_part, sizeof(reply->rectime.int_part));
	p += sizeof(reply->rectime.int_part);
	memcpy(p, &reply->rectime.fraction, sizeof(reply->rectime.fraction));
	p += sizeof(reply->rectime.fraction);
	memcpy(p, &reply->xmttime.int_part, sizeof(reply->xmttime.int_part));
	p += sizeof(reply->xmttime.int_part);
	memcpy(p, &reply->xmttime.fraction, sizeof(reply->xmttime.fraction));
	p += sizeof(reply->xmttime.fraction);
@


1.1
log
@initial cut at ntpd.
it is just capable of answering (s)ntp4 requests with the local time
for now.
imsg/buffer and logging framework from bgpd, ntp protocol hackery
with Alexander Guy
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d33 3
a35 2
#define PFD_PIPE_MAIN	1
#define PFD_MAX		2
d43 1
d67 1
d96 1
d120 2
d127 1
a127 1
		if ((nfds = poll(pfd, 2, INFTIM)) == -1)
d150 6
d175 1
a175 1

d187 20
d239 5
a243 5
	struct sockaddr	 fsa;
	socklen_t	 fsa_len;
	char		 buf[NTP_MSGSIZE];
	ssize_t		 size;
	struct ntp_msg	 msg;
d246 2
a247 1
	if ((size = recvfrom(fd, &buf, sizeof(buf), 0, &fsa, &fsa_len)) == -1)
d251 1
a251 1
	ntp_reply(fd, &fsa, &msg, 0);
@

