head	1.105;
access;
symbols
	OPENBSD_6_2_BASE:1.105
	OPENBSD_6_1:1.104.0.4
	OPENBSD_6_1_BASE:1.104
	OPENBSD_6_0:1.103.0.4
	OPENBSD_6_0_BASE:1.103
	OPENBSD_5_9:1.103.0.2
	OPENBSD_5_9_BASE:1.103
	OPENBSD_5_8:1.102.0.4
	OPENBSD_5_8_BASE:1.102
	OPENBSD_5_7:1.100.0.2
	OPENBSD_5_7_BASE:1.100
	OPENBSD_5_6:1.93.0.4
	OPENBSD_5_6_BASE:1.93
	OPENBSD_5_5:1.92.0.4
	OPENBSD_5_5_BASE:1.92
	OPENBSD_5_4:1.90.0.2
	OPENBSD_5_4_BASE:1.90
	OPENBSD_5_3:1.89.0.6
	OPENBSD_5_3_BASE:1.89
	OPENBSD_5_2:1.89.0.4
	OPENBSD_5_2_BASE:1.89
	OPENBSD_5_1_BASE:1.89
	OPENBSD_5_1:1.89.0.2
	OPENBSD_5_0:1.88.0.10
	OPENBSD_5_0_BASE:1.88
	OPENBSD_4_9:1.88.0.8
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.88.0.6
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.88.0.2
	OPENBSD_4_7_BASE:1.88
	OPENBSD_4_6:1.88.0.4
	OPENBSD_4_6_BASE:1.88
	OPENBSD_4_5:1.81.0.4
	OPENBSD_4_5_BASE:1.81
	OPENBSD_4_4:1.81.0.2
	OPENBSD_4_4_BASE:1.81
	OPENBSD_4_3:1.79.0.2
	OPENBSD_4_3_BASE:1.79
	OPENBSD_4_2:1.76.0.2
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.74.0.2
	OPENBSD_4_1_BASE:1.74
	OPENBSD_4_0:1.70.0.2
	OPENBSD_4_0_BASE:1.70
	OPENBSD_3_9:1.66.0.2
	OPENBSD_3_9_BASE:1.66
	OPENBSD_3_8:1.65.0.2
	OPENBSD_3_8_BASE:1.65
	OPENBSD_3_7:1.58.0.2
	OPENBSD_3_7_BASE:1.58
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32;
locks; strict;
comment	@ * @;


1.105
date	2017.05.30.23.30.48;	author benno;	state Exp;
branches;
next	1.104;
commitid	QAWRWuyNn05Y7pSZ;

1.104
date	2016.09.03.11.52.06;	author reyk;	state Exp;
branches;
next	1.103;
commitid	NAWlzXnfvHaWyDX5;

1.103
date	2015.10.23.14.52.20;	author phessler;	state Exp;
branches;
next	1.102;
commitid	37dFIvtgNCa7AEy2;

1.102
date	2015.07.18.00.53.44;	author bcook;	state Exp;
branches;
next	1.101;
commitid	X2stLxrcDblnYkzc;

1.101
date	2015.03.28.03.49.01;	author bcook;	state Exp;
branches;
next	1.100;
commitid	3NpX3c9h4xWJikII;

1.100
date	2015.02.12.01.54.57;	author reyk;	state Exp;
branches;
next	1.99;
commitid	eJZFYJXXt9fmfGXk;

1.99
date	2015.02.10.06.40.08;	author reyk;	state Exp;
branches;
next	1.98;
commitid	pXoTR74Ztt0R3SV0;

1.98
date	2015.01.19.20.47.03;	author bcook;	state Exp;
branches;
next	1.97;
commitid	keCX09bmkXTcMfIX;

1.97
date	2015.01.09.23.44.07;	author bcook;	state Exp;
branches;
next	1.96;
commitid	fXQGgfshUc98Cs1g;

1.96
date	2015.01.09.07.35.37;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	X9qvCMjSyjyh2fK9;

1.95
date	2015.01.04.01.48.49;	author bcook;	state Exp;
branches;
next	1.94;
commitid	SqfYJN9THyGArOhK;

1.94
date	2015.01.04.01.19.46;	author bcook;	state Exp;
branches;
next	1.93;
commitid	D90dwugO1YW1tdEs;

1.93
date	2014.05.12.20.50.46;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2013.10.21.08.48.22;	author phessler;	state Exp;
branches;
next	1.91;

1.91
date	2013.10.04.14.28.16;	author phessler;	state Exp;
branches;
next	1.90;

1.90
date	2013.04.30.11.42.56;	author mglocker;	state Exp;
branches;
next	1.89;

1.89
date	2011.09.21.15.41.30;	author phessler;	state Exp;
branches;
next	1.88;

1.88
date	2009.06.24.17.34.32;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2009.06.17.11.52.54;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.31.01.27.30;	author henning;	state Exp;
branches;
next	1.85;

1.85
date	2009.04.22.07.42.17;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2009.03.04.19.17.36;	author stevesk;	state Exp;
branches;
next	1.83;

1.83
date	2009.03.04.18.49.07;	author stevesk;	state Exp;
branches;
next	1.82;

1.82
date	2009.03.04.18.46.44;	author stevesk;	state Exp;
branches;
next	1.81;

1.81
date	2008.06.10.03.51.53;	author naddy;	state Exp;
branches;
next	1.80;

1.80
date	2008.06.10.03.46.09;	author naddy;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.28.11.45.59;	author mpf;	state Exp;
branches;
next	1.78;

1.78
date	2007.12.27.01.46.50;	author stevesk;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.22.10.24.25;	author otto;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.01.07.40.45;	author otto;	state Exp;
branches;
next	1.75;

1.75
date	2007.04.30.01.33.33;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2006.10.27.12.22.41;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2006.10.21.07.32.46;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2006.10.21.07.28.06;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2006.10.21.07.18.57;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2006.06.07.06.29.03;	author otto;	state Exp;
branches;
next	1.69;

1.69
date	2006.06.04.18.58.13;	author otto;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.29.20.51.54;	author ckuethe;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.25.19.25.46;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2005.09.24.00.32.03;	author dtucker;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.10.13.48.36;	author dtucker;	state Exp;
branches;
next	1.64;

1.64
date	2005.07.11.08.04.28;	author dtucker;	state Exp;
branches;
next	1.63;

1.63
date	2005.07.06.09.54.24;	author dtucker;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.05.10.09.12;	author dtucker;	state Exp;
branches;
next	1.61;

1.61
date	2005.06.19.16.42.57;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2005.04.19.11.08.41;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2005.04.18.11.06.35;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.08.12.31.40;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2005.02.21.17.58.43;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2005.02.03.10.53.33;	author dtucker;	state Exp;
branches;
next	1.55;

1.55
date	2005.01.28.12.37.20;	author dtucker;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.28.12.01.32;	author dtucker;	state Exp;
branches;
next	1.53;

1.53
date	2005.01.27.14.44.00;	author dtucker;	state Exp;
branches;
next	1.52;

1.52
date	2005.01.27.10.32.29;	author dtucker;	state Exp;
branches;
next	1.51;

1.51
date	2004.12.15.12.29.25;	author dtucker;	state Exp;
branches;
next	1.50;

1.50
date	2004.12.15.12.24.21;	author dtucker;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.14.23.44.20;	author dtucker;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.13.12.22.52;	author dtucker;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.09.20.24.46;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.08.15.47.38;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2004.11.10.11.47.28;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2004.11.05.23.39.46;	author dtucker;	state Exp;
branches;
next	1.43;

1.43
date	2004.10.22.21.17.37;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2004.10.15.01.58.04;	author dtucker;	state Exp;
branches;
next	1.41;

1.41
date	2004.10.14.09.35.48;	author dtucker;	state Exp;
branches;
next	1.40;

1.40
date	2004.10.13.13.35.19;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2004.10.13.13.19.44;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.10.08.12.42.25;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.05.11.23.28;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.30.10.19.43;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.24.14.51.16;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.18.20.01.38;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.14.22.01.28;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.16.11.14.15;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2004.08.13.12.26.13;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.12.16.33.59;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.28.16.38.43;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.20.16.47.55;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.18.13.26.53;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.18.12.59.41;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.14.20.16.31;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.11.00.15.10;	author alexander;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.10.19.16.06;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.10.19.09.13;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.10.18.47.49;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.10.18.42.51;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.09.15.02.15;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.09.10.53.33;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.08.01.20.21;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.07.08.07.02;	author alexander;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.07.06.57.13;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.07.06.51.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.07.06.50.40;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.07.01.01.27;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.06.23.26.38;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.06.19.06.43;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.06.18.45.29;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.06.17.40.32;	author naddy;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.05.22.12.53;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.05.20.41.34;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.04.22.24.20;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.04.19.52.24;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.04.11.01.49;	author alexander;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.03.21.11.29;	author alexander;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.17.19.17.48;	author henning;	state Exp;
branches;
next	;


desc
@@


1.105
log
@add option "query from <ip>" to ntpd.conf, to specify a local IP
address for outgoing ntp queries.
From Job Snijders, thanks!
with feedback and ok henning@@
@
text
@/*	$OpenBSD: client.c,v 1.104 2016/09/03 11:52:06 reyk Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2004 Alexander Guy <alexander.guy@@andern.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <errno.h>
#include <md5.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "ntpd.h"

int	client_update(struct ntp_peer *);
void	set_deadline(struct ntp_peer *, time_t);

void
set_next(struct ntp_peer *p, time_t t)
{
	p->next = getmonotime() + t;
	p->deadline = 0;
	p->poll = t;
}

void
set_deadline(struct ntp_peer *p, time_t t)
{
	p->deadline = getmonotime() + t;
	p->next = 0;
}

int
client_peer_init(struct ntp_peer *p)
{
	if ((p->query = calloc(1, sizeof(struct ntp_query))) == NULL)
		fatal("client_peer_init calloc");
	p->query->fd = -1;
	p->query->msg.status = MODE_CLIENT | (NTP_VERSION << 3);
	p->state = STATE_NONE;
	p->shift = 0;
	p->trustlevel = TRUSTLEVEL_PATHETIC;
	p->lasterror = 0;
	p->senderrors = 0;

	return (client_addr_init(p));
}

int
client_addr_init(struct ntp_peer *p)
{
	struct sockaddr_in	*sa_in;
	struct sockaddr_in6	*sa_in6;
	struct ntp_addr		*h;

	for (h = p->addr; h != NULL; h = h->next) {
		switch (h->ss.ss_family) {
		case AF_INET:
			sa_in = (struct sockaddr_in *)&h->ss;
			if (ntohs(sa_in->sin_port) == 0)
				sa_in->sin_port = htons(123);
			p->state = STATE_DNS_DONE;
			break;
		case AF_INET6:
			sa_in6 = (struct sockaddr_in6 *)&h->ss;
			if (ntohs(sa_in6->sin6_port) == 0)
				sa_in6->sin6_port = htons(123);
			p->state = STATE_DNS_DONE;
			break;
		default:
			fatalx("king bula sez: wrong AF in client_addr_init");
			/* NOTREACHED */
		}
	}

	p->query->fd = -1;
	set_next(p, 0);

	return (0);
}

int
client_nextaddr(struct ntp_peer *p)
{
	if (p->query->fd != -1) {
		close(p->query->fd);
		p->query->fd = -1;
	}

	if (p->state == STATE_DNS_INPROGRESS)
		return (-1);

	if (p->addr_head.a == NULL) {
		priv_dns(IMSG_HOST_DNS, p->addr_head.name, p->id);
		p->state = STATE_DNS_INPROGRESS;
		return (-1);
	}

	if (p->addr == NULL || (p->addr = p->addr->next) == NULL)
		p->addr = p->addr_head.a;

	p->shift = 0;
	p->trustlevel = TRUSTLEVEL_PATHETIC;

	return (0);
}

int
client_query(struct ntp_peer *p)
{
	int	val;

	if (p->addr == NULL && client_nextaddr(p) == -1) {
		set_next(p, MAXIMUM(SETTIME_TIMEOUT,
		    scale_interval(INTERVAL_QUERY_AGGRESSIVE)));
		return (0);
	}

	if (p->state < STATE_DNS_DONE || p->addr == NULL)
		return (-1);

	if (p->query->fd == -1) {
		struct sockaddr *sa = (struct sockaddr *)&p->addr->ss;
		struct sockaddr *qa4 = (struct sockaddr *)&p->query_addr4;
		struct sockaddr *qa6 = (struct sockaddr *)&p->query_addr6;

		if ((p->query->fd = socket(p->addr->ss.ss_family, SOCK_DGRAM,
		    0)) == -1)
			fatal("client_query socket");

		if (p->addr->ss.ss_family == qa4->sa_family) {
			if (bind(p->query->fd, qa4, SA_LEN(qa4)) == -1)
				fatal("couldn't bind to IPv4 query address: %s",
				    log_sockaddr(qa4));
		} else if (p->addr->ss.ss_family == qa6->sa_family) {
			if (bind(p->query->fd, qa6, SA_LEN(qa6)) == -1)
				fatal("couldn't bind to IPv6 query address: %s",
				    log_sockaddr(qa6));
		}

		if (connect(p->query->fd, sa, SA_LEN(sa)) == -1) {
			if (errno == ECONNREFUSED || errno == ENETUNREACH ||
			    errno == EHOSTUNREACH || errno == EADDRNOTAVAIL) {
				client_nextaddr(p);
				set_next(p, MAXIMUM(SETTIME_TIMEOUT,
				    scale_interval(INTERVAL_QUERY_AGGRESSIVE)));
				return (-1);
			} else
				fatal("client_query connect");
		}
		val = IPTOS_LOWDELAY;
		if (p->addr->ss.ss_family == AF_INET && setsockopt(p->query->fd,
		    IPPROTO_IP, IP_TOS, &val, sizeof(val)) == -1)
			log_warn("setsockopt IPTOS_LOWDELAY");
		val = 1;
		if (setsockopt(p->query->fd, SOL_SOCKET, SO_TIMESTAMP,
		    &val, sizeof(val)) == -1)
			fatal("setsockopt SO_TIMESTAMP");
	}

	/*
	 * Send out a random 64-bit number as our transmit time.  The NTP
	 * server will copy said number into the originate field on the
	 * response that it sends us.  This is totally legal per the SNTP spec.
	 *
	 * The impact of this is two fold: we no longer send out the current
	 * system time for the world to see (which may aid an attacker), and
	 * it gives us a (not very secure) way of knowing that we're not
	 * getting spoofed by an attacker that can't capture our traffic
	 * but can spoof packets from the NTP server we're communicating with.
	 *
	 * Save the real transmit timestamp locally.
	 */

	p->query->msg.xmttime.int_partl = arc4random();
	p->query->msg.xmttime.fractionl = arc4random();
	p->query->xmttime = gettime_corrected();

	if (ntp_sendmsg(p->query->fd, NULL, &p->query->msg) == -1) {
		p->senderrors++;
		set_next(p, INTERVAL_QUERY_PATHETIC);
		p->trustlevel = TRUSTLEVEL_PATHETIC;
		return (-1);
	}

	p->senderrors = 0;
	p->state = STATE_QUERY_SENT;
	set_deadline(p, QUERYTIME_MAX);

	return (0);
}

int
client_dispatch(struct ntp_peer *p, u_int8_t settime)
{
	struct ntp_msg		 msg;
	struct msghdr		 somsg;
	struct iovec		 iov[1];
	struct timeval		 tv;
	char			 buf[NTP_MSGSIZE];
	union {
		struct cmsghdr	hdr;
		char		buf[CMSG_SPACE(sizeof(tv))];
	} cmsgbuf;
	struct cmsghdr		*cmsg;
	ssize_t			 size;
	double			 T1, T2, T3, T4;
	time_t			 interval;

	memset(&somsg, 0, sizeof(somsg));
	iov[0].iov_base = buf;
	iov[0].iov_len = sizeof(buf);
	somsg.msg_iov = iov;
	somsg.msg_iovlen = 1;
	somsg.msg_control = cmsgbuf.buf;
	somsg.msg_controllen = sizeof(cmsgbuf.buf);

	T4 = getoffset();
	if ((size = recvmsg(p->query->fd, &somsg, 0)) == -1) {
		if (errno == EHOSTUNREACH || errno == EHOSTDOWN ||
		    errno == ENETUNREACH || errno == ENETDOWN ||
		    errno == ECONNREFUSED || errno == EADDRNOTAVAIL ||
		    errno == ENOPROTOOPT || errno == ENOENT) {
			client_log_error(p, "recvmsg", errno);
			set_next(p, error_interval());
			return (0);
		} else
			fatal("recvfrom");
	}

	if (somsg.msg_flags & MSG_TRUNC) {
		client_log_error(p, "recvmsg packet", EMSGSIZE);
		set_next(p, error_interval());
		return (0);
	}

	if (somsg.msg_flags & MSG_CTRUNC) {
		client_log_error(p, "recvmsg control data", E2BIG);
		set_next(p, error_interval());
		return (0);
	}

	for (cmsg = CMSG_FIRSTHDR(&somsg); cmsg != NULL;
	    cmsg = CMSG_NXTHDR(&somsg, cmsg)) {
		if (cmsg->cmsg_level == SOL_SOCKET &&
		    cmsg->cmsg_type == SCM_TIMESTAMP) {
			memcpy(&tv, CMSG_DATA(cmsg), sizeof(tv));
			T4 += gettime_from_timeval(&tv);
			break;
		}
	}

	if (T4 < JAN_1970) {
		client_log_error(p, "recvmsg control format", EBADF);
		set_next(p, error_interval());
		return (0);
	}

	ntp_getmsg((struct sockaddr *)&p->addr->ss, buf, size, &msg);

	if (msg.orgtime.int_partl != p->query->msg.xmttime.int_partl ||
	    msg.orgtime.fractionl != p->query->msg.xmttime.fractionl)
		return (0);

	if ((msg.status & LI_ALARM) == LI_ALARM || msg.stratum == 0 ||
	    msg.stratum > NTP_MAXSTRATUM) {
		char s[16];

		if ((msg.status & LI_ALARM) == LI_ALARM) {
			strlcpy(s, "alarm", sizeof(s));
		} else if (msg.stratum == 0) {
			/* Kiss-o'-Death (KoD) packet */
			strlcpy(s, "KoD", sizeof(s));
		} else if (msg.stratum > NTP_MAXSTRATUM) {
			snprintf(s, sizeof(s), "stratum %d", msg.stratum);
		}
		interval = error_interval();
		set_next(p, interval);
		log_info("reply from %s: not synced (%s), next query %llds",
		    log_sockaddr((struct sockaddr *)&p->addr->ss), s,
			(long long)interval);
		return (0);
	}

	/*
	 * From RFC 2030 (with a correction to the delay math):
	 *
	 *     Timestamp Name          ID   When Generated
	 *     ------------------------------------------------------------
	 *     Originate Timestamp     T1   time request sent by client
	 *     Receive Timestamp       T2   time request received by server
	 *     Transmit Timestamp      T3   time reply sent by server
	 *     Destination Timestamp   T4   time reply received by client
	 *
	 *  The roundtrip delay d and local clock offset t are defined as
	 *
	 *    d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2.
	 */

	T1 = p->query->xmttime;
	T2 = lfp_to_d(msg.rectime);
	T3 = lfp_to_d(msg.xmttime);

	/*
	 * XXX workaround: time_t / tv_sec must never wrap.
	 * around 2020 we will need a solution (64bit time_t / tv_sec).
	 * consider every answer with a timestamp beyond january 2030 bogus.
	 */
	if (T2 > JAN_2030 || T3 > JAN_2030) {
		set_next(p, error_interval());
		return (0);
	}

	/* Detect liars */
	if (conf->constraint_median != 0 &&
	    (constraint_check(T2) != 0 || constraint_check(T3) != 0)) {
		log_info("reply from %s: constraint check failed",
		    log_sockaddr((struct sockaddr *)&p->addr->ss));
		set_next(p, error_interval());
		return (0);
	}

	p->reply[p->shift].offset = ((T2 - T1) + (T3 - T4)) / 2;
	p->reply[p->shift].delay = (T4 - T1) - (T3 - T2);
	p->reply[p->shift].status.stratum = msg.stratum;
	if (p->reply[p->shift].delay < 0) {
		interval = error_interval();
		set_next(p, interval);
		log_info("reply from %s: negative delay %fs, "
		    "next query %llds",
		    log_sockaddr((struct sockaddr *)&p->addr->ss),
		    p->reply[p->shift].delay, (long long)interval);
		return (0);
	}
	p->reply[p->shift].error = (T2 - T1) - (T3 - T4);
	p->reply[p->shift].rcvd = getmonotime();
	p->reply[p->shift].good = 1;

	p->reply[p->shift].status.leap = (msg.status & LIMASK);
	p->reply[p->shift].status.precision = msg.precision;
	p->reply[p->shift].status.rootdelay = sfp_to_d(msg.rootdelay);
	p->reply[p->shift].status.rootdispersion = sfp_to_d(msg.dispersion);
	p->reply[p->shift].status.refid = msg.refid;
	p->reply[p->shift].status.reftime = lfp_to_d(msg.reftime);
	p->reply[p->shift].status.poll = msg.ppoll;

	if (p->addr->ss.ss_family == AF_INET) {
		p->reply[p->shift].status.send_refid =
		    ((struct sockaddr_in *)&p->addr->ss)->sin_addr.s_addr;
	} else if (p->addr->ss.ss_family == AF_INET6) {
		MD5_CTX		context;
		u_int8_t	digest[MD5_DIGEST_LENGTH];

		MD5Init(&context);
		MD5Update(&context, ((struct sockaddr_in6 *)&p->addr->ss)->
		    sin6_addr.s6_addr, sizeof(struct in6_addr));
		MD5Final(digest, &context);
		memcpy((char *)&p->reply[p->shift].status.send_refid, digest,
		    sizeof(u_int32_t));
	} else
		p->reply[p->shift].status.send_refid = msg.xmttime.fractionl;

	if (p->trustlevel < TRUSTLEVEL_PATHETIC)
		interval = scale_interval(INTERVAL_QUERY_PATHETIC);
	else if (p->trustlevel < TRUSTLEVEL_AGGRESSIVE)
		interval = scale_interval(INTERVAL_QUERY_AGGRESSIVE);
	else
		interval = scale_interval(INTERVAL_QUERY_NORMAL);

	set_next(p, interval);
	p->state = STATE_REPLY_RECEIVED;

	/* every received reply which we do not discard increases trust */
	if (p->trustlevel < TRUSTLEVEL_MAX) {
		if (p->trustlevel < TRUSTLEVEL_BADPEER &&
		    p->trustlevel + 1 >= TRUSTLEVEL_BADPEER)
			log_info("peer %s now valid",
			    log_sockaddr((struct sockaddr *)&p->addr->ss));
		p->trustlevel++;
	}

	log_debug("reply from %s: offset %f delay %f, "
	    "next query %llds",
	    log_sockaddr((struct sockaddr *)&p->addr->ss),
	    p->reply[p->shift].offset, p->reply[p->shift].delay,
	    (long long)interval);

	client_update(p);
	if (settime)
		priv_settime(p->reply[p->shift].offset);

	if (++p->shift >= OFFSET_ARRAY_SIZE)
		p->shift = 0;

	return (0);
}

int
client_update(struct ntp_peer *p)
{
	int	i, best = 0, good = 0;

	/*
	 * clock filter
	 * find the offset which arrived with the lowest delay
	 * use that as the peer update
	 * invalidate it and all older ones
	 */

	for (i = 0; good == 0 && i < OFFSET_ARRAY_SIZE; i++)
		if (p->reply[i].good) {
			good++;
			best = i;
		}

	for (; i < OFFSET_ARRAY_SIZE; i++)
		if (p->reply[i].good) {
			good++;
			if (p->reply[i].delay < p->reply[best].delay)
				best = i;
		}

	if (good < 8)
		return (-1);

	memcpy(&p->update, &p->reply[best], sizeof(p->update));
	if (priv_adjtime() == 0) {
		for (i = 0; i < OFFSET_ARRAY_SIZE; i++)
			if (p->reply[i].rcvd <= p->reply[best].rcvd)
				p->reply[i].good = 0;
	}
	return (0);
}

void
client_log_error(struct ntp_peer *peer, const char *operation, int error)
{
	const char *address;

	address = log_sockaddr((struct sockaddr *)&peer->addr->ss);
	if (peer->lasterror == error) {
		log_debug("%s %s: %s", operation, address, strerror(error));
		return;
	}
	peer->lasterror = error;
	log_warn("%s %s", operation, address);
}
@


1.104
log
@Remove the oh so funny "LOSS OF MIND" from the diclaimer that was not
part of the original ISC license that we use in OpenBSD.  Done for
files were Henning is the original author.

OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.103 2015/10/23 14:52:20 phessler Exp $ */
d140 2
d146 10
@


1.103
log
@Allowing upstream servers of ntp being in multiple routing tables is
non-sensical.  The dns lookups happened in the process routing table
(usually '0'), which is very likely to have different results from the
other routing domains.  If you do depend on having this behaviour,
you'll need to use pf to cross the rtable boundary.

"listen on * rtable X" is still supported.

Users of "server * rtable X" will need to switch to launching ntpd with
"route -T X exec /usr/sbin/ntpd"

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.102 2015/07/18 00:53:44 bcook Exp $ */
d15 3
a17 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.102
log
@replace bzero with memset

ok phessler@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.101 2015/03/28 03:49:01 bcook Exp $ */
a144 4
		if (p->rtable != -1 &&
		    setsockopt(p->query->fd, SOL_SOCKET, SO_RTABLE,
		    &p->rtable, sizeof(p->rtable)) == -1)
			fatal("client_query setsockopt SO_RTABLE");
a246 5
	if (p->rtable != -1 &&
	    setsockopt(p->query->fd, SOL_SOCKET, SO_RTABLE, &p->rtable,
	    sizeof(p->rtable)) == -1)
		fatal("client_dispatch setsockopt SO_RTABLE");

d387 1
a387 1
	    "next query %llds %s",
d390 1
a390 1
	    (long long)interval, print_rtable(p->rtable));
@


1.101
log
@Avoid overflow on 32-bit time_t systems converting timeval to NTP time.

Original fix from Romuald Delavergne. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.100 2015/02/12 01:54:57 reyk Exp $ */
d218 1
a218 1
	bzero(&somsg, sizeof(somsg));
@


1.100
log
@Use ntpd's deferred DNS resolving for constraints as well.  This
allows to get constraint addresses even if network/DNS is not
available at startup (or system boot).

thumbs up & OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.99 2015/02/10 06:40:08 reyk Exp $ */
d261 1
a261 1
			T4 += tv.tv_sec + JAN_1970 + 1.0e-6 * tv.tv_usec;
@


1.99
log
@Add support for "constraints": when configured, ntpd(8) will query the
time from HTTPS servers, by parsing the Date: header, and use the
median constraint time as a boundary to verify NTP responses.  This
adds some level of authentication and protection against MITM attacks
while preserving the accuracy of the NTP protocol; without relying on
authentication options for NTP that are basically unavailable at
present.  This is an initial implementation and the semantics will be
improved once it is in the tree.

Discussed with deraadt@@ and henning@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.98 2015/01/19 20:47:03 bcook Exp $ */
d110 1
a110 1
		priv_host_dns(p->addr_head.name, p->id);
@


1.98
log
@Use initial assignment of action to check for errors.

This simplifies things and make action = -1 no longer a dead store.

Also, spell FALLTHROUGH consistently.

reported by fritjof@@alokat.org
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.97 2015/01/09 23:44:07 bcook Exp $ */
d323 9
@


1.97
log
@return -1 on host() address parsing failure, not 1.

Match what parse.y expects it to return.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.96 2015/01/09 07:35:37 deraadt Exp $ */
d88 1
a88 1
			/* not reached */
@


1.96
log
@remove excessive/wrong use of sys/param.h
peanuts -- but all work has to start somewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.95 2015/01/04 01:48:49 bcook Exp $ */
d115 1
a115 1
	if ((p->addr = p->addr->next) == NULL)
@


1.95
log
@use MAXIMUM as the canonical local MAX macro.

suggested by deraadt@@ re: more general MIN/MAX cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.94 2015/01/04 01:19:46 bcook Exp $ */
d20 1
a20 1
#include <sys/param.h>
@


1.94
log
@don't rely on sys/param.h having a MAX macro.

Switch to local definitions where MAX is needed.

discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.93 2014/05/12 20:50:46 miod Exp $ */
a123 2
#define SCALE_MAX(a, b) ((a) > (b) ? (a) : (b))

d130 1
a130 1
		set_next(p, SCALE_MAX(SETTIME_TIMEOUT,
d153 1
a153 1
				set_next(p, SCALE_MAX(SETTIME_TIMEOUT,
@


1.93
log
@Fix format strings involving time_t arguments, fixes `ntpd -d' on sparc (and
probably more 32-bit platforms).

Problem noticed by tobiasu@@; ok tobiasu@@ dtucker@@ sthen@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.92 2013/10/21 08:48:22 phessler Exp $ */
d124 2
d132 1
a132 1
		set_next(p, MAX(SETTIME_TIMEOUT,
d155 1
a155 1
				set_next(p, MAX(SETTIME_TIMEOUT,
@


1.92
log
@remove the IPv4-only check for rdomains, allows IPv6 to use them

OK claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.91 2013/10/04 14:28:16 phessler Exp $ */
d292 1
a292 1
		log_info("reply from %s: not synced (%s), next query %ds",
d294 1
a294 1
			interval);
d334 1
a334 1
		    "next query %ds",
d336 1
a336 1
		    p->reply[p->shift].delay, interval);
d387 1
a387 1
	    "next query %ds %s",
d389 2
a390 2
	    p->reply[p->shift].offset, p->reply[p->shift].delay, interval,
	    print_rtable(p->rtable));
@


1.91
log
@Add ntpctl(8), which allows us to query the locally running ntpd(8) process

diff from Mike Miller <mmiller mgm51 com> (many thanks!)

OK phessler@@, henning@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.90 2013/04/30 11:42:56 mglocker Exp $ */
a137 3
	if (p->addr->ss.ss_family != AF_INET && p->rtable != -1)
		return (-1);

d145 2
a146 2
		if (p->addr->ss.ss_family == AF_INET && p->rtable != -1 &&
		    setsockopt(p->query->fd, IPPROTO_IP, SO_RTABLE,
d252 1
a252 1
	    setsockopt(p->query->fd, IPPROTO_IP, SO_RTABLE, &p->rtable,
@


1.90
log
@Remove unused function argument variables 'len' and 'auth' from
ntp_sendmsg().  They have been removed from the function body in the past
but not from the argument list.

From Maxime Villard
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.89 2011/09/21 15:41:30 phessler Exp $ */
d39 1
d332 1
a352 1
	p->reply[p->shift].status.stratum = msg.stratum;
@


1.89
log
@Add rdomain support to NTPd.

This basically adds the "rtable %d" keyword to "listen on", "server",
"servers" keywords, to specify which routing table to use.

OK henning@@ claudio@@ sthen@@
manpage reviewed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.88 2009/06/24 17:34:32 henning Exp $ */
d189 1
a189 2
	if (ntp_sendmsg(p->query->fd, NULL, &p->query->msg,
	    NTP_MSGSIZE_NOAUTH, 0) == -1) {
@


1.88
log
@recvmsg ENOENT noncritical too
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.87 2009/06/17 11:52:54 henning Exp $ */
d137 3
d146 5
d254 5
d390 4
a393 2
	    "next query %ds", log_sockaddr((struct sockaddr *)&p->addr->ss),
	    p->reply[p->shift].offset, p->reply[p->shift].delay, interval);
@


1.87
log
@ENOPROTOOPT is non-fatal on recvfrom, can apparently happen with ipvshit
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.86 2009/05/31 01:27:30 henning Exp $ */
d226 1
a226 1
		    errno == ENOPROTOOPT) {
@


1.86
log
@use the SCM_TIMESTAMP socket option to get the time we received the
reply instead of doing it in ntpd itself by getting the time we read
from the socket. based on a diff from mickey hacked in shape by me,
lots of testing and review from ckuethe and sthen, theo and claudio like it
too
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.85 2009/04/22 07:42:17 henning Exp $ */
d225 2
a226 1
		    errno == ECONNREFUSED || errno == EADDRNOTAVAIL) {
@


1.85
log
@ignore replies with timestamps after 2030 to prevent time_t / tv_sec wraps
input & ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.84 2009/03/04 19:17:36 stevesk Exp $ */
d126 1
a126 1
	int	tos = IPTOS_LOWDELAY;
d153 1
d155 1
a155 1
		    IPPROTO_IP, IP_TOS, &tos, sizeof(tos)) == -1)
d157 4
d199 4
d204 5
a209 1
	struct ntp_msg		 msg;
d213 10
a222 2
	if ((size = recvfrom(p->query->fd, &buf, sizeof(buf), 0,
	    NULL, NULL)) == -1) {
d226 1
a226 1
			client_log_error(p, "recvfrom", errno);
d233 27
a259 1
	T4 = gettime_corrected();
@


1.84
log
@I should know outside data must be vis(3)'d.
Don't log kiss code for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.83 2009/03/04 18:49:07 stevesk Exp $ */
d258 10
@


1.83
log
@received refid should not be converted to host byte order; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.82 2009/03/04 18:46:44 stevesk Exp $ */
d228 1
a228 5
			if (msg.refid != 0)
				snprintf(s, sizeof(s), "KoD %.4s",
				    (char *)&msg.refid);
			else
				strlcpy(s, "KoD", sizeof(s));
@


1.82
log
@log reason when not synced; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.81 2008/06/10 03:51:53 naddy Exp $ */
d282 1
a282 1
	p->reply[p->shift].status.refid = ntohl(msg.refid);
@


1.81
log
@For IPv6 addresses, return the first 32 bits of the MD5 hash of the
address as ref ID (RFC4330).  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.80 2008/06/10 03:46:09 naddy Exp $ */
d23 1
d222 14
d238 3
a240 2
		log_info("reply from %s: not synced, next query %ds",
		    log_sockaddr((struct sockaddr *)&p->addr->ss), interval);
@


1.80
log
@According to the latest SNTPv4 spec in RFC4330, secondary servers
return the address of the synchronization source as reference
identification.  Remove the obsolete special casing specified in RFC2030.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.79 2008/01/28 11:45:59 mpf Exp $ */
d22 1
d271 1
a271 1
	if (p->addr->ss.ss_family == AF_INET)
d274 11
a284 1
	else
@


1.79
log
@Reconnect a client socket after three consecutive send failures.
This allows recovery after an IP address change (e.g. on dialup links).
Also move the update of "nextaction" timeout below the deadline check.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.78 2007/12/27 01:46:50 stevesk Exp $ */
a265 1
	p->reply[p->shift].status.refid4 = msg.xmttime.fractionl;
@


1.78
log
@some fatal() calls that should be fatalx(); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.77 2007/11/22 10:24:25 otto Exp $ */
d57 1
d176 1
d182 1
@


1.77
log
@be a bit less aggressive retrying; this keeps the message queue
empty while in the -s period, so the poll timeout actually times out
if there are no interfaces available. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.76 2007/05/01 07:40:45 otto Exp $ */
d83 1
a83 1
			fatal("king bula sez: wrong AF in client_addr_init");
@


1.76
log
@if resolving a name fails, be more aggressive retrying, but with care:
do not have more than one dns request outstanding per peer. resolves
slow recovery when resolving fails initially, without clogging the
pipe with lots of dns requests; tested by Jason George; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.75 2007/04/30 01:33:33 deraadt Exp $ */
d126 2
a127 1
		set_next(p, scale_interval(INTERVAL_QUERY_AGGRESSIVE));
d144 2
a145 2
				set_next(p,
				    scale_interval(INTERVAL_QUERY_AGGRESSIVE));
@


1.75
log
@aggressive spelling fix, spotted by jbg
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.74 2006/10/27 12:22:41 henning Exp $ */
d102 3
d126 1
a126 1
		set_next(p, error_interval());
d143 2
a144 1
				set_next(p, error_interval());
@


1.74
log
@use clock_gettime(CLOCK_MONOTONIC, ..) to get a monotonically increasing
time, and make ntpd use that to send the next uery to an ntp peer and the
like. this has the advantage that changes to the clock do not interfere
with the intervals. for example, when we start on machines without an
RTC and the initial settime (-s) kicks in, intervals were strange.
idea from amandal@@entrisphere.com, this implementation by me
tested ckuethe, phessler, mbalmer, ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.73 2006/10/21 07:32:46 henning Exp $ */
d271 2
a272 2
	else if (p->trustlevel < TRUSTLEVEL_AGRESSIVE)
		interval = scale_interval(INTERVAL_QUERY_AGRESSIVE);
@


1.73
log
@in client_nextaddr, check fd != -1 before close, just nicer this way
From: amandal@@entrisphere.com
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.72 2006/10/21 07:28:06 henning Exp $ */
d35 1
a35 1
	p->next = time(NULL) + t;
d42 1
a42 1
	p->deadline = time(NULL) + t;
d250 1
a250 1
	p->reply[p->shift].rcvd = time(NULL);
@


1.72
log
@when ntp_sendmsg fails, reset trustlevel to TRUSTLEVEL_PATHETIC
From: amandal@@entrisphere.com
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.71 2006/10/21 07:18:57 henning Exp $ */
d97 4
a100 2
	close(p->query->fd);
	p->query->fd = -1;
@


1.71
log
@EADDRNOTAVAIL after connect is one of the soft errors where we don't abort
too. from amandal@@entrisphere.com
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.70 2006/06/07 06:29:03 otto Exp $ */
d169 1
@


1.70
log
@Compensate old offsets with the amount of adjustment done, avoiding
overcompensating. From DragonFly, uses recent adjtime(2) changes,
so you'll need a recent kernel. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.69 2006/06/04 18:58:13 otto Exp $ */
d136 1
a136 1
			    errno == EHOSTUNREACH) {
@


1.69
log
@Only invalidate stored replies if an adjustment was really made.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.68 2006/05/29 20:51:54 ckuethe Exp $ */
d164 1
a164 1
	p->query->xmttime = gettime();
d199 1
a199 1
	T4 = gettime();
@


1.68
log
@When ntpd backs off polling due to a negative delay, tell the user how long
it will wait until the next poll.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.67 2006/05/25 19:25:46 henning Exp $ */
d328 5
a332 6
	priv_adjtime();

	for (i = 0; i < OFFSET_ARRAY_SIZE; i++)
		if (p->reply[i].rcvd <= p->reply[best].rcvd)
			p->reply[i].good = 0;

@


1.67
log
@figure out the refid to send to NTP v3 clients early and store it
first bits from a way to long flight
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.66 2005/09/24 00:32:03 dtucker Exp $ */
d240 2
a241 1
		log_info("reply from %s: negative delay %f",
d243 1
a243 1
		    p->reply[p->shift].delay);
@


1.66
log
@Log source address for 'malformed packet' errors.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.65 2005/08/10 13:48:36 dtucker Exp $ */
d258 6
@


1.65
log
@Propogate server's leap indicator flags to clients; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.64 2005/07/11 08:04:28 dtucker Exp $ */
d201 1
a201 1
	ntp_getmsg(buf, size, &msg);
@


1.64
log
@Print actual error when in debug mode; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.63 2005/07/06 09:54:24 dtucker Exp $ */
d249 1
a249 1
	p->reply[p->shift].status.leap = (msg.status & LIMASK) >> 6;
@


1.63
log
@add another non-fatal error for recvfrom; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.62 2005/07/05 10:09:12 dtucker Exp $ */
d337 1
a337 1
		log_debug("%s %s", operation, address);
@


1.62
log
@Save transmit time for each peer for later use as refid for SNTPv4
replies.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.61 2005/06/19 16:42:57 henning Exp $ */
d191 1
a191 1
		    errno == ECONNREFUSED) {
@


1.61
log
@use a little state engine to keep track of delayed dns lookups and such,
eases things
tested by Jason Ackley <jason@@ackley.net> Matthias Kilian
<kili@@outback.escape.de> Stephen Marley <stephen@@marley.org.uk> sturm@@
theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.60 2005/04/19 11:08:41 henning Exp $ */
d254 1
@


1.60
log
@move the "reply from ... " log msg in -d mdoe uop a bit so it actually
comes before the "adjusting local clock by..." one, joerg
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.59 2005/04/18 11:06:35 henning Exp $ */
d74 1
d80 1
d102 1
d124 3
@


1.59
log
@prevent replies with negative delay from being used, could happen with -s
From: Joerg Sonnenberger <joerg@@britannica.bec.de> of dragonfly
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.58 2005/03/08 12:31:40 henning Exp $ */
d271 4
a277 4

	log_debug("reply from %s: offset %f delay %f, "
	    "next query %ds", log_sockaddr((struct sockaddr *)&p->addr->ss),
	    p->reply[p->shift].offset, p->reply[p->shift].delay, interval);
@


1.58
log
@let client_query return 0 if it requested dns resolution
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.57 2005/02/21 17:58:43 henning Exp $ */
d231 8
@


1.57
log
@fix an error message
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.56 2005/02/03 10:53:33 dtucker Exp $ */
d119 1
a119 1
		return (-1);
@


1.56
log
@Implement simple duplicate suppression of peer errors; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.55 2005/01/28 12:37:20 dtucker Exp $ */
d50 1
a50 1
		fatal("client_query calloc");
@


1.55
log
@Simplify interval scaling and randomize query intervals; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.54 2005/01/28 12:01:32 dtucker Exp $ */
d56 1
d186 1
a186 2
			log_warn("recvfrom %s",
			    log_sockaddr((struct sockaddr *)&p->addr->ss));
d313 14
@


1.54
log
@Make network unreachable errors non-fatal; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.53 2005/01/27 14:44:00 dtucker Exp $ */
d245 1
a245 1
		interval = INTERVAL_QUERY_PATHETIC;
d247 1
a247 1
		interval = INTERVAL_QUERY_AGRESSIVE;
@


1.53
log
@Scale query interval by the overall offset not per-peer offset, so we
don't query outliers more often than any other server.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.52 2005/01/27 10:32:29 dtucker Exp $ */
d183 2
a184 1
		    errno == ENETDOWN || errno == ECONNREFUSED) {
@


1.52
log
@Delay before retrying a query on timeout; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.51 2004/12/15 12:29:25 dtucker Exp $ */
a45 14
time_t
scale_interval(time_t requested, double offset)
{
	if (offset < 0)
		offset = -offset;

	if (offset > QSCALE_OFF_MAX)
		return (requested);
	else if (offset < QSCALE_OFF_MIN)
		return (requested * (QSCALE_OFF_MAX / QSCALE_OFF_MIN));
	else
		return (requested * (QSCALE_OFF_MAX / offset));
}

d117 1
a117 1
		set_next(p, INTERVAL_QUERY_PATHETIC);
d131 1
a131 1
				set_next(p, INTERVAL_QUERY_PATHETIC);
d186 1
a186 2
			interval = scale_interval(INTERVAL_QUERY_PATHETIC, 0.0);
			set_next(p, interval);
d202 1
a202 1
		interval = scale_interval(INTERVAL_QUERY_PATHETIC, 0.0);
d248 1
a248 2
		interval = scale_interval(INTERVAL_QUERY_NORMAL,
		    p->reply[p->shift].offset);
@


1.51
log
@Poll unsynchronized servers at the maximum interval and log a message about
them when in debug mode; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.50 2004/12/15 12:24:21 dtucker Exp $ */
a29 1
void	set_next(struct ntp_peer *, time_t);
a30 1
time_t	scale_interval(time_t, double);
@


1.50
log
@Factor out interval scaling code; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.49 2004/12/14 23:44:20 dtucker Exp $ */
d218 5
a222 1
	    msg.stratum > NTP_MAXSTRATUM)
d224 1
@


1.49
log
@If polling a server results in an error, drop that server to the maximum
poll interval;  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.48 2004/12/13 12:22:52 dtucker Exp $ */
d32 1
d48 14
a193 1
	double			 abs_offset;
d202 1
a202 2
			interval = INTERVAL_QUERY_PATHETIC *
			    (QSCALE_OFF_MAX / QSCALE_OFF_MIN);
d259 3
a261 15
	else {
		if (p->reply[p->shift].offset < 0)
			abs_offset = -p->reply[p->shift].offset;
		else
			abs_offset = p->reply[p->shift].offset;

		if (abs_offset > QSCALE_OFF_MAX)
			interval = INTERVAL_QUERY_NORMAL;
		else if (abs_offset < QSCALE_OFF_MIN)
			interval = INTERVAL_QUERY_NORMAL *
			    (QSCALE_OFF_MAX / QSCALE_OFF_MIN);
		else
			interval = INTERVAL_QUERY_NORMAL *
			    (QSCALE_OFF_MAX / abs_offset);
	}
@


1.48
log
@Discard replies with alarm flag set or invalid stratum; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.47 2004/12/09 20:24:46 mickey Exp $ */
d188 3
@


1.47
log
@define TRUSTLEVEL_MAX for the trustedlevel value of 10; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.46 2004/12/08 15:47:38 mickey Exp $ */
d199 4
@


1.46
log
@uniquely name members of s_fixedpt and l_fixedpt; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.45 2004/11/10 11:47:28 henning Exp $ */
d259 1
a259 1
	if (p->trustlevel < 10) {
@


1.45
log
@ntp_adjtime() -> priv_adjtime()
ntp_settime() -> priv_settime()
ntp_host_dns() -> priv_host_dns()
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.44 2004/11/05 23:39:46 dtucker Exp $ */
d156 2
a157 2
	p->query->msg.xmttime.int_part = arc4random();
	p->query->msg.xmttime.fraction = arc4random();
d197 2
a198 2
	if (msg.orgtime.int_part != p->query->msg.xmttime.int_part ||
	    msg.orgtime.fraction != p->query->msg.xmttime.fraction)
@


1.44
log
@Use SA_LEN() instead of ss.ss_len.  Evaluates to the same result but it's
easier on portable.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.43 2004/10/22 21:17:37 henning Exp $ */
d99 1
a99 1
		ntp_host_dns(p->addr_head.name, p->id);
d269 1
a269 1
		ntp_settime(p->reply[p->shift].offset);
d310 1
a310 1
	ntp_adjtime();
@


1.43
log
@in server mode reply with stratum from the peer that we currently prefer
plus one
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.42 2004/10/15 01:58:04 dtucker Exp $ */
d123 2
d128 1
a128 2
		if (connect(p->query->fd, (struct sockaddr *)&p->addr->ss,
		    p->addr->ss.ss_len) == -1) {
@


1.42
log
@Only set IPTOS_LOWDELAY on IPv4 interfaces; pointed out by phessler, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.41 2004/10/14 09:35:48 dtucker Exp $ */
d232 1
@


1.41
log
@Have ntpd use IPTOS_LOWDELAY; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.40 2004/10/13 13:35:19 henning Exp $ */
d136 2
a137 2
		if (setsockopt(p->query->fd, IPPROTO_IP, IP_TOS, &tos,
		    sizeof(tos)) == -1)
@


1.40
log
@in struct ntp_msg, rename "distance" to "rootdelay" to closer match RFCs
and such
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.39 2004/10/13 13:19:44 henning Exp $ */
d115 2
d136 3
@


1.39
log
@thinko, htonl() -> ntohl(). as we don't use the value in question effect zero
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.38 2004/10/08 12:42:25 henning Exp $ */
d222 1
a222 1
	p->reply[p->shift].status.rootdelay = sfp_to_d(msg.distance);
@


1.38
log
@whitespace both in comment; from bernd
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.37 2004/10/05 11:23:28 henning Exp $ */
d224 1
a224 1
	p->reply[p->shift].status.refid = htonl(msg.refid);
@


1.37
log
@in client_addr_init() and client_nextaddr(), do not set up the socket and
connect it, instead leave it at -1.
in client_query, set up and connect the socket if it is -1.
and, the real reason for this change: handle connect failures gracefully
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.36 2004/09/30 10:19:43 henning Exp $ */
d198 1
a198 1
	 *      Timestamp Name          ID   When Generated
@


1.36
log
@now that we connect() the client sockets we need to handle ECONNREFUSED as
non-fatal too, from camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.35 2004/09/24 14:51:16 henning Exp $ */
d86 1
a86 9
	if (p->addr != NULL) {
		if ((p->query->fd = socket(p->addr->ss.ss_family,
		    SOCK_DGRAM, 0)) == -1)
			fatal("client_query socket");
		if (connect(p->query->fd, (struct sockaddr *)&p->addr->ss,
		    p->addr->ss.ss_len) == -1)
			fatal("client_query connect");
	}

a105 6
	if ((p->query->fd = socket(p->addr->ss.ss_family, SOCK_DGRAM, 0)) == -1)
		fatal("client_query socket");
	if (connect(p->query->fd, (struct sockaddr *)&p->addr->ss,
	    p->addr->ss.ss_len) == -1)
		fatal("client_query connect");

d118 16
@


1.35
log
@connect() the client-side sockets. idea & test & ok camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.34 2004/09/18 20:01:38 henning Exp $ */
d177 1
a177 1
		    errno == ENETDOWN) {
@


1.34
log
@add a new -s option, that tells ntpd to set the time using settimeofday()
once at startup. ntpd delays daemonizing until it has done the intial
time setting (or ran into the timeout) in this mode to make sure stuff started
later in rc is not subject to time jumps.
this eleminates the need to run rdate -n beforehands.
with some input from & ok ryan and bob, march music from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.33 2004/09/14 22:01:28 henning Exp $ */
d86 8
a93 3
	if (p->addr != NULL &&
	    (p->query->fd = socket(p->addr->ss.ss_family, SOCK_DGRAM, 0)) == -1)
		fatal("client_query socket");
d116 3
d152 2
a153 2
	if (ntp_sendmsg(p->query->fd, (struct sockaddr *)&p->addr->ss,
	    &p->query->msg, NTP_MSGSIZE_NOAUTH, 0) == -1) {
a166 2
	struct sockaddr_storage	 fsa;
	socklen_t		 fsa_len;
a173 1
	fsa_len = sizeof(fsa);
d175 1
a175 1
	    (struct sockaddr *)&fsa, &fsa_len)) == -1) {
d179 1
a179 1
			    log_sockaddr((struct sockaddr *)&fsa));
d254 1
a254 1
			    log_sockaddr((struct sockaddr *)&fsa));
d263 1
a263 1
	    "next query %ds", log_sockaddr((struct sockaddr *)&fsa),
@


1.33
log
@paranoia: reset query->fd to -1 after close, from canacar some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.32 2004/08/16 11:14:15 otto Exp $ */
d157 1
a157 1
client_dispatch(struct ntp_peer *p)
d254 2
@


1.32
log
@Be more careful setting next and deadline, they should not both be != 0
at the same time.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.31 2004/08/13 12:26:13 otto Exp $ */
d99 1
@


1.31
log
@Reset deadline on failed transmit. Avoids a spinning process if
all sends fail. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.30 2004/08/12 16:33:59 henning Exp $ */
d30 16
d90 1
a90 1
	p->next = time(NULL);
d121 1
a121 1
		p->next = time(NULL) + INTERVAL_QUERY_PATHETIC;
d145 1
a145 2
		p->next = time(NULL) + INTERVAL_QUERY_PATHETIC;
		p->deadline = 0;
d150 1
a150 2
	p->next = 0;
	p->deadline = time(NULL) + QUERYTIME_MAX;
d240 1
a240 2
	p->next = time(NULL) + interval;
	p->deadline = 0;
@


1.30
log
@do not try to getaddrinfo() in the unprivileged process, send an imsg
asking the privileged one to do it. sends back an imsg with the
resulting addresses in a bunch of struct sockaddr_storage in the data
part.
this should fix all remaining issues with dns (non-)availability at
ntpd startup, be it due to named on localhost or something else.
tested by marco@@ and Chris Paul <chris.paul@@sentinare.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.29 2004/07/28 16:38:43 henning Exp $ */
d130 1
@


1.29
log
@when a dns lookup fails at parse time, do not abort but try again
to resolve the hostname every 60 seconds
fixes ntpd invocations before e. g. a dialup link is established and such.
as we want ntpd to be a "fire and forget" background daemon it should
cope with such situations.
tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.28 2004/07/20 16:47:55 henning Exp $ */
d34 14
a51 3
	if ((p->query = calloc(1, sizeof(struct ntp_query))) == NULL)
		fatal("client_query calloc");

d65 1
a65 1
			fatal("king bula sez: wrong AF in client_peer_init");
a73 2
	p->query->msg.status = MODE_CLIENT | (NTP_VERSION << 3);
	p->state = STATE_NONE;
a74 2
	p->shift = 0;
	p->trustlevel = TRUSTLEVEL_PATHETIC;
d85 2
a86 6
		if (host_dns(p->addr_head.name, &p->addr_head.a) > 0) {
			p->addr = p->addr_head.a;
			p->shift = 0;
			p->trustlevel = TRUSTLEVEL_PATHETIC;
		} else
			return (-1);
@


1.28
log
@wrap the heads for the linked list of addresses into a new ntp_addr_wrap
which, besides the head pointer for the list of course, stores the original
address as specified (i. e. as hostname instead of resolved IPs) and flags
and such.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.27 2004/07/18 13:26:53 henning Exp $ */
d59 2
a60 1
	if ((p->query->fd = socket(p->addr->ss.ss_family, SOCK_DGRAM, 0)) == -1)
d77 9
d101 5
@


1.27
log
@there are a few recvfrom(2) errors we do not want to panic on
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.26 2004/07/18 12:59:41 henning Exp $ */
d77 1
a77 1
		p->addr = p->addr_head;
@


1.26
log
@query interval scaling, episode II
1) base the interval calculation on the offset from the last reply, not
   from the last peer update.
   Allows us to send more queries again faster when the local clock
   diverges too much
2) every time we form a peer update (for which we need 8 replies)
   check wether we have a ready peer update for all peers that are
   currently trusted, and if so, calculate the total offset and call
   adjtime().
   that means that adjtime is no longer called in fixed intervals
   but whenever we have enough data to reliably calculate the local
   clock offset.
   In practice, that means we call adjtime() less often, but with
   probably better data.
3) invalidate peer updates after beeing used. no point in re-using them
   - this resulted in calling adjtime() multiple times with the same
   offset, which doesn't make sense
tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.25 2004/07/14 20:16:31 henning Exp $ */
d136 9
a144 2
	    (struct sockaddr *)&fsa, &fsa_len)) == -1)
		fatal("recvfrom");
@


1.25
log
@do not do the stratum guessing dance.
stratum is pretty much pointless anyway these days, and we certainly
do not want to send out illegal packets (stratum=0) until synced...
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.24 2004/07/11 00:15:10 alexander Exp $ */
d185 2
a186 2
		if (p->update.offset < 0)
			abs_offset = p->update.offset * -1;
d188 1
a188 1
			abs_offset = p->update.offset;
d190 1
a190 3
		if (!p->update.good)
			interval = INTERVAL_QUERY_NORMAL;
		else if (abs_offset > QSCALE_OFF_MAX)
d193 2
a194 1
			interval = INTERVAL_QUERY_NORMAL * (1 / QSCALE_OFF_MIN);
d196 2
a197 1
			interval = INTERVAL_QUERY_NORMAL * (1 / abs_offset);
d243 1
a243 5
	for (; i < OFFSET_ARRAY_SIZE; i++) {
		if (p->reply[i].good &&
		    p->reply[i].rcvd + REPLY_MAXAGE < time(NULL))
			p->reply[i].good = 0;

a248 1
	}
d254 1
@


1.24
log
@Start collecting the remote server state along with the calculated
offsets, in preparation for having correct server statistics in
responses to client queries.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.23 2004/07/10 19:16:06 henning Exp $ */
a172 1
	p->reply[p->shift].status.stratum = msg.stratum;
@


1.23
log
@missing {}
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.22 2004/07/10 19:09:13 henning Exp $ */
d171 9
@


1.22
log
@check wether we have enough data to form a peer update on receiption
of each packet, not only after each 8th (where we have enough for sure)
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.21 2004/07/10 18:47:49 henning Exp $ */
d240 1
a240 1
		if (p->reply[i].good)
d244 1
@


1.21
log
@oups
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.20 2004/07/10 18:42:51 henning Exp $ */
d205 2
d211 1
a211 1
	if (++p->shift >= OFFSET_ARRAY_SIZE) {
a212 2
		client_update(p);
	}
d246 1
a246 1
	if (good == 0)
@


1.20
log
@scale query interval based on local clock offset. tested by many
not as efficient as I want it to be yet, but more is coming
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.19 2004/07/09 15:02:15 henning Exp $ */
d181 1
a181 1
log_debug("offset %f, abs_offset %f", p->update.offset, abs_offset);
@


1.19
log
@don't panic when sendto() fails; for the client part just re-schedule
noticed & fix tested by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.18 2004/07/09 10:53:33 henning Exp $ */
d29 2
d131 2
d173 1
a173 1
		p->next = time(NULL) + INTERVAL_QUERY_PATHETIC;
d175 16
a190 3
		p->next = time(NULL) + INTERVAL_QUERY_AGRESSIVE;
	else
		p->next = time(NULL) + INTERVAL_QUERY_NORMAL;
d192 1
d205 3
a207 3
	log_debug("received reply from %s: offset %f delay %f",
	    log_sockaddr((struct sockaddr *)&fsa), p->reply[p->shift].offset,
	    p->reply[p->shift].delay);
d209 1
a209 1
	if (++p->shift >= OFFSET_ARRAY_SIZE)
d211 43
@


1.18
log
@rework dns handling with all its cosequences...
we know have both a "server" and "servers" keyword. they differ when the
hostname resolves to more than one IP, server picks one and servers expands
to all.
that means no longer stuffing a sockaddr_storage into ntp_peer but a pointer
to a linked list of ntp_addr structs.
in the "servers" case the list of n addresses returned by host() is expanded
into n ntp_peer structs and thus n individual peers.
in the "server" case the whole list is attached to ntp_peer, and whenever we
do not receive a reply in time we traverse the list one further, so that
hosts with both AAAA and A records are first tried with the AAAA one but
we gracefully fall back to the A one.
semantics with theo; hacked up on the Montreal->Frankfurt flight.
again Air Canada surprised me, that older 767 hat pretty decent seats.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.17 2004/07/08 01:20:21 henning Exp $ */
d107 6
a112 2
	ntp_sendmsg(p->query->fd, (struct sockaddr *)&p->addr->ss,
	    &p->query->msg, NTP_MSGSIZE_NOAUTH, 0);
@


1.17
log
@lof replies with log_debug so one gets increased verbosity when in
foreground/debug mode
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.16 2004/07/07 08:07:02 alexander Exp $ */
d34 1
d39 16
a54 14
	switch (p->ss.ss_family) {
	case AF_INET:
		sa_in = (struct sockaddr_in *)&p->ss;
		if (ntohs(sa_in->sin_port) == 0)
			sa_in->sin_port = htons(123);
		break;
	case AF_INET6:
		sa_in6 = (struct sockaddr_in6 *)&p->ss;
		if (ntohs(sa_in6->sin6_port) == 0)
			sa_in6->sin6_port = htons(123);
		break;
	default:
		fatal("king bula sez: wrong AF in client_peer_init");
		/* not reached */
d57 1
a57 1
	if ((p->query->fd = socket(p->ss.ss_family, SOCK_DGRAM, 0)) == -1)
d70 17
d107 2
a108 2
	ntp_sendmsg(p->query->fd, (struct sockaddr *)&p->ss, &p->query->msg,
	    NTP_MSGSIZE_NOAUTH, 0);
@


1.16
log
@RFC 2030 is incorrect with regards to the computation of the delay value
for NTP queries/replies.  RFC 1305 and some of Mills' other papers have
the correct formula.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.15 2004/07/07 06:57:13 henning Exp $ */
d162 4
@


1.15
log
@don't log every single reply we receive and log local clock adjustemt nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.14 2004/07/07 06:51:16 deraadt Exp $ */
d120 1
a120 1
	 * From RFC 2030:
d131 1
a131 1
	 *    d = (T4 - T1) - (T2 - T3)     t = ((T2 - T1) + (T3 - T4)) / 2.
d139 1
a139 1
	p->reply[p->shift].delay = (T4 - T1) - (T2 - T3);
@


1.14
log
@knf!
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.13 2004/07/07 06:50:40 henning Exp $ */
a152 4

	log_debug("reply received from %s: offset %f delay %f",
	    log_sockaddr((struct sockaddr *)&fsa), p->reply[p->shift].offset,
	    p->reply[p->shift].delay);
@


1.13
log
@if the cookie in the received packet doesn't match discard it silently;
the logging was useful for development but is a bad idea in production
use as a remote attacker could flood your logs
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.12 2004/07/07 01:01:27 henning Exp $ */
d119 1
a119 1
	/* 
@


1.12
log
@keep a "trustlevel" per peer. loose credit for loosing a packet, loose
a lot of credit for not having supplied us with enough data within an
adjtime run interval, and get a little credit each time we get a good
reply packet. if a peer is below 20%, only send a packet occasionally to
see wether it is back. send out queries much more often between 20 and 80%
to (re-)sync quickly, and above 80% usethe regular interval.
do not use peers < 60% for calculating teh local clock offset.
designed with theo at the pho, alexander ok
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.11 2004/07/06 23:26:38 henning Exp $ */
d116 1
a116 3
	    msg.orgtime.fraction != p->query->msg.xmttime.fraction) {
		log_warnx("received packet from %s without correct cookie, "
		    "discarding", log_sockaddr((struct sockaddr *)&fsa));
a117 1
	}
@


1.11
log
@Implement the clock filter as descirbed by David Mills:
form the last 8 replied received from a peer, find the one with the lowest
delay. Use that as the peer's update taken into account for calculating
the local clock's offset.
Invalidate that reply and all ones received earlier than it so that they do
not get used again.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.10 2004/07/06 19:06:43 henning Exp $ */
d61 1
a61 1
	p->valid = 0;
d147 8
a155 2
	p->next = time(NULL) + INTERVAL_QUERY;
	p->deadline = 0;
d161 10
a170 1
	if (++p->shift >= OFFSET_ARRAY_SIZE) {
a171 2
		p->valid = 1;
	}
@


1.10
log
@when we received a apcket with incorrect cookie log from whom as well
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.9 2004/07/06 18:45:29 jason Exp $ */
d141 5
a145 2
	p->offset[p->shift] = ((T2 - T1) + (T3 - T4)) / 2;
	p->delay[p->shift] = (T2 - T1) - (T3 - T4);
d152 2
a153 2
	    log_sockaddr((struct sockaddr *)&fsa), p->offset[p->shift],
	    p->delay[p->shift]);
@


1.9
log
@log host packet was received from (originally using a long convoluted
function until henning showed me the light... log_sockaddr... nifty);
this diff is from henning and should be henning ok =)
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.8 2004/07/06 17:40:32 naddy Exp $ */
d117 2
a118 1
		log_warn("received packet without correct cookie, discarding");
@


1.8
log
@initialize the variables that track the offset array; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.7 2004/07/05 22:12:53 henning Exp $ */
d147 2
a148 1
	log_debug("reply received: offset %f delay %f", p->offset[p->shift],
@


1.7
log
@keep last 8 offset,delay pairs - we'll need them for the clock filters later.
for now, average over those to adjust the local clock.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.6 2004/07/05 20:41:34 henning Exp $ */
d60 2
@


1.6
log
@delay, not error
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.5 2004/07/04 22:24:20 henning Exp $ */
d138 2
a139 2
	p->offset = ((T2 - T1) + (T3 - T4)) / 2;
	p->delay = (T2 - T1) - (T3 - T4);
d145 7
a151 1
	log_debug("reply received: offset %f delay %f", p->offset, p->delay);
@


1.5
log
@put interval defines in ntpd.h and name them consistently
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.4 2004/07/04 19:52:24 henning Exp $ */
d139 1
a139 1
	p->error = (T2 - T1) - (T3 - T4);
d145 1
a145 1
	log_debug("reply received: offset %f error %f", p->offset, p->error);
@


1.4
log
@simplify slightly
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.3 2004/07/04 11:01:49 alexander Exp $ */
d89 1
a89 1
	p->deadline = time(NULL) + MAX_QUERYTIME;
d142 1
a142 1
	p->next = time(NULL) + QUERY_INTERVAL;
@


1.3
log
@Compute the local clock offset from the server's response.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.2 2004/07/03 21:11:29 alexander Exp $ */
a102 1
	double			 offset, error;
d138 2
a139 2
	offset = ((T2 - T1) + (T3 - T4)) / 2;
	error = (T2 - T1) - (T3 - T4);
a143 2
	p->offset = offset;
	p->error = error;
d145 1
a145 1
	log_debug("reply received: offset %f error %f", offset, error);
@


1.2
log
@wrong struct calloc'ed; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.1 2004/06/17 19:17:48 henning Exp $ */
d83 1
a83 1
	get_ts(&p->query->xmttime);
d102 2
a103 1
	struct l_fixedpt	 rtt, t;
d110 2
d120 18
a137 1
log_debug("reply received");
d139 2
a140 4
	/* XXX parse */
	get_ts(&t);
	rtt.int_part = (t.int_part - p->query->xmttime.int_part) -
	    (msg.rectime.int_part - msg.xmttime.int_part);
d145 4
@


1.1
log
@provide most of the client functionality.
hook the descriptors into the main poll and such.
we're not doing anything with the reply we recive yet, tho.

mostly hacked on the Frankfurt->Montreal flight, as batteries and those
horrible air canada seats permitted...
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.1 2004/06/02 10:08:59 henning Exp $ */
d35 1
a35 1
	if ((p->query = calloc(1, sizeof(struct ntp_msg))) == NULL)
@

