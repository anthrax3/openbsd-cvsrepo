head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.2
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.8
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.6
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.4
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.18
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.16
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.14
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.10
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.12
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.8
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.24
date	2017.03.01.00.56.30;	author gsoares;	state Exp;
branches;
next	1.23;
commitid	GSwReWFlsPYM3nbM;

1.23
date	2016.10.03.12.30.43;	author rzalamena;	state Exp;
branches;
next	1.22;
commitid	YDVnZphoxroFk6P8;

1.22
date	2016.09.14.13.20.16;	author rzalamena;	state Exp;
branches;
next	1.21;
commitid	FUtuYlECIdeLHfjN;

1.21
date	2016.09.14.08.24.08;	author reyk;	state Exp;
branches;
next	1.20;
commitid	cz8BQ0pGG6ezIolM;

1.20
date	2015.12.19.13.58.08;	author reyk;	state Exp;
branches;
next	1.19;
commitid	de21MufW7eCZF1cc;

1.19
date	2015.03.28.03.49.01;	author bcook;	state Exp;
branches;
next	1.18;
commitid	3NpX3c9h4xWJikII;

1.18
date	2015.02.10.11.46.39;	author reyk;	state Exp;
branches;
next	1.17;
commitid	azl2PYCfRcxq0H2y;

1.17
date	2015.02.10.06.40.08;	author reyk;	state Exp;
branches;
next	1.16;
commitid	pXoTR74Ztt0R3SV0;

1.16
date	2015.01.04.01.11.24;	author bcook;	state Exp;
branches;
next	1.15;
commitid	UXnNOdv82uPjplnj;

1.15
date	2013.10.15.20.35.55;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.21.15.41.30;	author phessler;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.27.18.22.02;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.27.12.22.41;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.07.06.29.03;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.08.15.47.38;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.12.17.24.52;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.10.22.24.20;	author alexander;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.07.07.38.21;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.07.07.32.05;	author alexander;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.07.07.16.16;	author alexander;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.05.19.53.21;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.05.07.46.16;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.04.18.07.15;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.04.11.01.49;	author alexander;	state Exp;
branches;
next	;


desc
@@


1.24
log
@*nargv[] holds an array of pointers, so it should be
terminated by a null pointer.

ok rzalamena@@ reyk@@
@
text
@/*	$OpenBSD: util.c,v 1.23 2016/10/03 12:30:43 rzalamena Exp $ */

/*
 * Copyright (c) 2004 Alexander Guy <alexander.guy@@andern.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#include "ntpd.h"

double
gettime_corrected(void)
{
	return (gettime() + getoffset());
}

double
getoffset(void)
{
	struct timeval	tv;
	if (adjtime(NULL, &tv) == -1)
		return (0.0);
	return (tv.tv_sec + 1.0e-6 * tv.tv_usec);
}

double
gettime(void)
{
	struct timeval	tv;

	if (gettimeofday(&tv, NULL) == -1)
		fatal("gettimeofday");

	return (gettime_from_timeval(&tv));
}

double
gettime_from_timeval(struct timeval *tv)
{
	/*
	 * Account for overflow on OSes that have a 32-bit time_t.
	 */
	return ((uint64_t)tv->tv_sec + JAN_1970 + 1.0e-6 * tv->tv_usec);
}

time_t
getmonotime(void)
{
	struct timespec	ts;

	if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0)
		fatal("clock_gettime");

	return (ts.tv_sec);
}


void
d_to_tv(double d, struct timeval *tv)
{
	tv->tv_sec = d;
	tv->tv_usec = (d - tv->tv_sec) * 1000000;
	while (tv->tv_usec < 0) {
		tv->tv_usec += 1000000;
		tv->tv_sec -= 1;
	}
}

double
lfp_to_d(struct l_fixedpt lfp)
{
	double	ret;

	lfp.int_partl = ntohl(lfp.int_partl);
	lfp.fractionl = ntohl(lfp.fractionl);

	ret = (double)(lfp.int_partl) + ((double)lfp.fractionl / UINT_MAX);

	return (ret);
}

struct l_fixedpt
d_to_lfp(double d)
{
	struct l_fixedpt	lfp;

	lfp.int_partl = htonl((u_int32_t)d);
	lfp.fractionl = htonl((u_int32_t)((d - (u_int32_t)d) * UINT_MAX));

	return (lfp);
}

double
sfp_to_d(struct s_fixedpt sfp)
{
	double	ret;

	sfp.int_parts = ntohs(sfp.int_parts);
	sfp.fractions = ntohs(sfp.fractions);

	ret = (double)(sfp.int_parts) + ((double)sfp.fractions / USHRT_MAX);

	return (ret);
}

struct s_fixedpt
d_to_sfp(double d)
{
	struct s_fixedpt	sfp;

	sfp.int_parts = htons((u_int16_t)d);
	sfp.fractions = htons((u_int16_t)((d - (u_int16_t)d) * USHRT_MAX));

	return (sfp);
}

char *
print_rtable(int r)
{
	static char b[11];

	b[0] = 0;
	if (r > 0)
		snprintf(b, sizeof(b), "rtable %d", r);

	return (b);
}

const char *
log_sockaddr(struct sockaddr *sa)
{
	static char	buf[NI_MAXHOST];

	if (getnameinfo(sa, SA_LEN(sa), buf, sizeof(buf), NULL, 0,
	    NI_NUMERICHOST))
		return ("(unknown)");
	else
		return (buf);
}

pid_t
start_child(char *pname, int cfd, int argc, char **argv)
{
	char		**nargv;
	int		  nargc, i;
	pid_t		  pid;

	/* Prepare the child process new argv. */
	nargv = calloc(argc + 3, sizeof(char *));
	if (nargv == NULL)
		fatal("%s: calloc", __func__);

	/* Copy the program name first. */
	nargc = 0;
	nargv[nargc++] = argv[0];

	/* Set the process name and copy the original args. */
	nargv[nargc++] = "-P";
	nargv[nargc++] = pname;
	for (i = 1; i < argc; i++)
		nargv[nargc++] = argv[i];

	nargv[nargc] = NULL;

	switch (pid = fork()) {
	case -1:
		fatal("%s: fork", __func__);
		break;
	case 0:
		/* Prepare the parent socket and execute. */
		if (cfd != PARENT_SOCK_FILENO) {
			if (dup2(cfd, PARENT_SOCK_FILENO) == -1)
				fatal("dup2");
		} else if (fcntl(cfd, F_SETFD, 0) == -1)
			fatal("fcntl");

		execvp(argv[0], nargv);
		fatal("%s: execvp", __func__);
		break;

	default:
		/* Close child's socket end. */
		close(cfd);
		break;
	}

	free(nargv);
	return (pid);
}

int
sanitize_argv(int *argc, char ***argv)
{
	char		**nargv;
	int		  nargc;
	int		  i;

	/*
	 * We need at least three arguments:
	 * Example: '/usr/sbin/ntpd' '-P' 'foobar'.
	 */
	if (*argc < 3)
		return (-1);

	*argc -= 2;

	/* Allocate new arguments vector and copy pointers. */
	nargv = calloc((*argc) + 1, sizeof(char *));
	if (nargv == NULL)
		return (-1);

	nargc = 0;
	nargv[nargc++] = (*argv)[0];
	for (i = 1; i < *argc; i++)
		nargv[nargc++] = (*argv)[i + 2];

	nargv[nargc] = NULL;
	*argv = nargv;
	return (0);
}
@


1.23
log
@Fix a possible bug that will happen with dup2() when oldd == newd. In that
case the dup2() would fail silently and the descriptor would remain with
the CLOEXEC flag causing the exec*()d child process to have unexpected
behavior.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2016/09/14 13:20:16 rzalamena Exp $ */
d180 1
a180 1
	nargv[nargc] = 0;
@


1.22
log
@Teach ntpd(8) how to fork+exec.

ok reyk@@, bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2016/09/14 08:24:08 reyk Exp $ */
d19 1
d188 5
a192 1
		dup2(cfd, PARENT_SOCK_FILENO);
@


1.21
log
@Fix copyright disclaimer in util.c.

OK from the original author Alexander Guy
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2015/12/19 13:58:08 reyk Exp $ */
d21 1
d23 1
d155 77
@


1.20
log
@Move log_sockaddr() to from log.c to util.c as it is a local addition
and actually not a "logging" function.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2015/03/28 03:49:01 bcook Exp $ */
d14 3
a16 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.19
log
@Avoid overflow on 32-bit time_t systems converting timeval to NTP time.

Original fix from Romuald Delavergne. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2015/02/10 11:46:39 reyk Exp $ */
d141 12
@


1.18
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2015/02/10 06:40:08 reyk Exp $ */
d48 1
a48 1
	return (tv.tv_sec + JAN_1970 + 1.0e-6 * tv.tv_usec);
d54 4
a57 1
	return (tv->tv_sec + JAN_1970 + 1.0e-6 * tv->tv_usec);
@


1.17
log
@Add support for "constraints": when configured, ntpd(8) will query the
time from HTTPS servers, by parsing the Date: header, and use the
median constraint time as a boundary to verify NTP responses.  This
adds some level of authentication and protection against MITM attacks
while preserving the accuracy of the NTP protocol; without relying on
authentication options for NTP that are basically unavailable at
present.  This is an initial implementation and the semantics will be
improved once it is in the tree.

Discussed with deraadt@@ and henning@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2015/01/04 01:11:24 bcook Exp $ */
d137 1
a137 1
	return(b);
@


1.16
log
@Add a missing include for time.h to get the definitions of clock_gettime and strftime.

ok jsing@@ phessler@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2013/10/15 20:35:55 krw Exp $ */
d49 6
@


1.15
log
@Remove stray (long) cast of value being assigned to tv_secs.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 2011/09/21 15:41:30 phessler Exp $ */
a18 1
#include <sys/time.h>
d21 1
@


1.14
log
@Add rdomain support to NTPd.

This basically adds the "rtable %d" keyword to "listen on", "server",
"servers" keywords, to specify which routing table to use.

OK henning@@ claudio@@ sthen@@
manpage reviewed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.13 2007/03/27 18:22:02 otto Exp $ */
d66 1
a66 1
	tv->tv_sec = (long)d;
@


1.13
log
@Normalize tv so that tv_usec is positive. The kernel also normalizes,
but this might increase portability since some other systems do not
grok negative tv_usec well. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2006/10/27 12:22:41 henning Exp $ */
d21 1
d120 12
@


1.12
log
@use clock_gettime(CLOCK_MONOTONIC, ..) to get a monotonically increasing
time, and make ntpd use that to send the next uery to an ntp peer and the
like. this has the advantage that changes to the clock do not interfere
with the intervals. for example, when we start on machines without an
RTC and the initial settime (-s) kicks in, intervals were strange.
idea from amandal@@entrisphere.com, this implementation by me
tested ckuethe, phessler, mbalmer, ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2006/06/07 06:29:03 otto Exp $ */
d67 4
@


1.11
log
@Compensate old offsets with the amount of adjustment done, avoiding
overcompensating. From DragonFly, uses recent adjtime(2) changes,
so you'll need a recent kernel. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 2004/12/08 15:47:38 mickey Exp $ */
d48 11
@


1.10
log
@uniquely name members of s_fixedpt and l_fixedpt; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 2004/11/12 17:24:52 henning Exp $ */
d23 15
@


1.9
log
@some missing includes, from Joerg Sonnenberger <joerg@@britannica.bec.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.8 2004/07/10 22:24:20 alexander Exp $ */
d48 2
a49 2
	lfp.int_part = ntohl(lfp.int_part);
	lfp.fraction = ntohl(lfp.fraction);
d51 1
a51 1
	ret = (double)(lfp.int_part) + ((double)lfp.fraction / UINT_MAX);
d61 2
a62 2
	lfp.int_part = htonl((u_int32_t)d);
	lfp.fraction = htonl((u_int32_t)((d - (u_int32_t)d) * UINT_MAX));
d72 2
a73 2
	sfp.int_part = ntohs(sfp.int_part);
	sfp.fraction = ntohs(sfp.fraction);
d75 1
a75 1
	ret = (double)(sfp.int_part) + ((double)sfp.fraction / USHRT_MAX);
d85 2
a86 2
	sfp.int_part = htons((u_int16_t)d);
	sfp.fraction = htons((u_int16_t)((d - (u_int16_t)d) * USHRT_MAX));
@


1.8
log
@short fixed point <-> double conversion routines; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 2004/07/07 07:38:21 henning Exp $ */
d20 1
@


1.7
log
@help the compiler a bit with a cast, spotted by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 2004/07/07 07:32:05 alexander Exp $ */
d64 24
@


1.6
log
@* Convert to use the new double-based time handling functions.
* Respond to the query with a reasonable received time (which
  will help clients get better accuracy).
* Consolidate the server response code in preparation for a
  completely 'proper' response to the client.

tips and ok from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 2004/07/07 07:16:16 alexander Exp $ */
d60 1
a60 1
	lfp.int_part = htonl(d);
@


1.5
log
@Endian conversion mistakenly done before fraction math; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 2004/07/05 19:53:21 otto Exp $ */
d61 1
a61 1
	lfp.fraction = htonl((d - (u_int32_t)d) * UINT_MAX);
@


1.4
log
@use correct multiplier for us -> s conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.3 2004/07/05 07:46:16 henning Exp $ */
d61 1
a61 1
	lfp.fraction = htonl((d - lfp.int_part) * UINT_MAX);
@


1.3
log
@calculate the median offset from all servers we sync to and call
adjtime() when necessary to keep the local clock in sync
yes, that means ntpd syncs the local clock now.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.2 2004/07/04 18:07:15 henning Exp $ */
d39 1
a39 1
	tv->tv_usec = (d - tv->tv_sec) * 1000;
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.1 2004/07/04 11:01:49 alexander Exp $ */
d32 8
@


1.1
log
@Compute the local clock offset from the server's response.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d26 1
a26 2
	struct timeval tv;
	double ret;
d31 1
a31 3
	ret = tv.tv_sec + JAN_1970 + 1.0e-6 * tv.tv_usec;

	return (ret);
d37 1
a37 1
	double ret;
d50 2
a51 2
	struct l_fixedpt lfp;
	
@

