head	1.52;
access;
symbols
	OPENBSD_6_1:1.52.0.4
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.50.0.6
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.47.0.6
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.46.0.4
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.45.0.10
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.8
	OPENBSD_5_0:1.45.0.6
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.4
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.40.0.2
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21;
locks; strict;
comment	@ * @;


1.52
date	2016.09.03.11.52.06;	author reyk;	state Exp;
branches;
next	1.51;
commitid	NAWlzXnfvHaWyDX5;

1.51
date	2016.08.27.01.50.07;	author guenther;	state Exp;
branches;
next	1.50;
commitid	ikVlcUgcgDzn9GW3;

1.50
date	2015.05.20.13.32.39;	author reyk;	state Exp;
branches;
next	1.49;
commitid	wTGf2eC247IaKa6e;

1.49
date	2015.01.09.07.35.37;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	X9qvCMjSyjyh2fK9;

1.48
date	2015.01.08.00.25.47;	author bcook;	state Exp;
branches;
next	1.47;
commitid	vW7gPb9nMNYPFJmT;

1.47
date	2013.10.04.14.28.16;	author phessler;	state Exp;
branches;
next	1.46;

1.46
date	2012.09.20.12.43.16;	author patrick;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.20.20.49.36;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2009.05.13.15.08.10;	author stevesk;	state Exp;
branches;
next	1.43;

1.43
date	2009.02.08.23.57.08;	author stevesk;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.27.15.21.20;	author stevesk;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.26.21.45.11;	author naddy;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.10.03.46.09;	author naddy;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.09.18.30.48;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.09.18.30.03;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.09.16.52.04;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.09.16.37.35;	author ckuethe;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.02.20.36.42;	author ckuethe;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.12.21.08.46;	author ckuethe;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.04.02.58.02;	author ckuethe;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.23.17.44.38;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.15.19.58.49;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.15.08.19.11;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.14.19.18.12;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2006.12.28.00.24.27;	author naddy;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.23.17.49.53;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.20.20.58.47;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2006.10.27.12.22.41;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2006.10.24.12.23.39;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.12.10.41.51;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.12.10.40.45;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.19.16.56.54;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.30.16.52.13;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.02.21.17.01;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.01.05.44.35;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.01.04.44.23;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.29.05.20.42;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.28.20.39.16;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.28.19.04.37;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.28.18.48.20;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.28.18.47.25;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.28.16.41.40;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.28.16.40.07;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.28.16.39.12;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.28.03.23.08;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.28.02.06.46;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.27.22.23.49;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.27.22.22.47;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.27.21.33.47;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.27.21.27.34;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.27.17.01.07;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.26.00.33.16;	author henning;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Remove the oh so funny "LOSS OF MIND" from the diclaimer that was not
part of the original ISC license that we use in OpenBSD.  Done for
files were Henning is the original author.

OK henning@@ deraadt@@
@
text
@/*	$OpenBSD: sensors.c,v 1.51 2016/08/27 01:50:07 guenther Exp $ */

/*
 * Copyright (c) 2006 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/sensors.h>
#include <sys/sysctl.h>
#include <sys/device.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ntpd.h"

#define MAXDEVNAMLEN		16

int	sensor_probe(int, char *, struct sensor *);
void	sensor_add(int, char *);
void	sensor_remove(struct ntp_sensor *);
void	sensor_update(struct ntp_sensor *);

void
sensor_init(void)
{
	TAILQ_INIT(&conf->ntp_sensors);
}

int
sensor_scan(void)
{
	int		i, n, err;
	char		d[MAXDEVNAMLEN];
	struct sensor	s;

	n = 0;
	for (i = 0; ; i++)
		if ((err = sensor_probe(i, d, &s))) {
			if (err == 0)
				continue;
			if (err == -1)	/* no further sensors */
				break;
			sensor_add(i, d);
			n++;
		}

	return n;
}

/*
 * 1 = time sensor!
 * 0 = sensor exists... but is not a time sensor
 * -1: no sensor here, and no further sensors after this
 */
int
sensor_probe(int devid, char *dxname, struct sensor *sensor)
{
	int			mib[5];
	size_t			slen, sdlen;
	struct sensordev	sensordev;

	mib[0] = CTL_HW;
	mib[1] = HW_SENSORS;
	mib[2] = devid;
	mib[3] = SENSOR_TIMEDELTA;
	mib[4] = 0;

	sdlen = sizeof(sensordev);
	if (sysctl(mib, 3, &sensordev, &sdlen, NULL, 0) == -1) {
		if (errno == ENXIO)
			return (0);
		if (errno == ENOENT)
			return (-1);
		log_warn("sensor_probe sysctl");
	}

	if (sensordev.maxnumt[SENSOR_TIMEDELTA] == 0)
		return (0);

	strlcpy(dxname, sensordev.xname, MAXDEVNAMLEN);

	slen = sizeof(*sensor);
	if (sysctl(mib, 5, sensor, &slen, NULL, 0) == -1) {
		if (errno != ENOENT)
			log_warn("sensor_probe sysctl");
		return (0);
	}

	return (1);
}

void
sensor_add(int sensordev, char *dxname)
{
	struct ntp_sensor	*s;
	struct ntp_conf_sensor	*cs;

	/* check whether it is already there */
	TAILQ_FOREACH(s, &conf->ntp_sensors, entry)
		if (!strcmp(s->device, dxname))
			return;

	/* check whether it is requested in the config file */
	for (cs = TAILQ_FIRST(&conf->ntp_conf_sensors); cs != NULL &&
	    strcmp(cs->device, dxname) && strcmp(cs->device, "*");
	    cs = TAILQ_NEXT(cs, entry))
		; /* nothing */
	if (cs == NULL)
		return;

	if ((s = calloc(1, sizeof(*s))) == NULL)
		fatal("sensor_add calloc");

	s->next = getmonotime();
	s->weight = cs->weight;
	s->correction = cs->correction;
	s->stratum = cs->stratum - 1;
	if ((s->device = strdup(dxname)) == NULL)
		fatal("sensor_add strdup");
	s->sensordevid = sensordev;

	if (cs->refstr == NULL)
		memcpy(&s->refid, SENSOR_DEFAULT_REFID, sizeof(s->refid));
	else {
		s->refid = 0;
		strncpy((char *)&s->refid, cs->refstr, sizeof(s->refid));
	}

	TAILQ_INSERT_TAIL(&conf->ntp_sensors, s, entry);

	log_debug("sensor %s added (weight %d, correction %.6f, refstr %.4u, "
	     "stratum %d)", s->device, s->weight, s->correction / 1e6,
	     s->refid, s->stratum);
}

void
sensor_remove(struct ntp_sensor *s)
{
	TAILQ_REMOVE(&conf->ntp_sensors, s, entry);
	free(s->device);
	free(s);
}

void
sensor_query(struct ntp_sensor *s)
{
	char		 dxname[MAXDEVNAMLEN];
	struct sensor	 sensor;

	if (conf->settime)
		s->next = getmonotime() + SENSOR_QUERY_INTERVAL_SETTIME;
	else
		s->next = getmonotime() + SENSOR_QUERY_INTERVAL;

	/* rcvd is walltime here, monotime in client.c. not used elsewhere */
	if (s->update.rcvd < time(NULL) - SENSOR_DATA_MAXAGE)
		s->update.good = 0;

	if (!sensor_probe(s->sensordevid, dxname, &sensor)) {
		sensor_remove(s);
		return;
	}

	if (sensor.flags & SENSOR_FINVALID ||
	    sensor.status != SENSOR_S_OK)
		return;

	if (strcmp(dxname, s->device)) {
		sensor_remove(s);
		return;
	}

	if (sensor.tv.tv_sec == s->last)	/* already seen */
		return;

	s->last = sensor.tv.tv_sec;
	/*
	 * TD = device time
	 * TS = system time
	 * sensor.value = TS - TD in ns
	 * if value is positive, system time is ahead
	 */
	s->offsets[s->shift].offset = (sensor.value / -1e9) - getoffset() +
	    (s->correction / 1e6);
	s->offsets[s->shift].rcvd = sensor.tv.tv_sec;
	s->offsets[s->shift].good = 1;

	s->offsets[s->shift].status.send_refid = s->refid;
	/* stratum increased when sent out */
	s->offsets[s->shift].status.stratum = s->stratum;
	s->offsets[s->shift].status.rootdelay = 0;
	s->offsets[s->shift].status.rootdispersion = 0;
	s->offsets[s->shift].status.reftime = sensor.tv.tv_sec;
	s->offsets[s->shift].status.synced = 1;

	log_debug("sensor %s: offset %f", s->device,
	    s->offsets[s->shift].offset);

	if (++s->shift >= SENSOR_OFFSETS) {
		s->shift = 0;
		sensor_update(s);
	}

}

void
sensor_update(struct ntp_sensor *s)
{
	struct ntp_offset	**offsets;
	int			  i;

	if ((offsets = calloc(SENSOR_OFFSETS, sizeof(struct ntp_offset *))) ==
	    NULL)
		fatal("calloc sensor_update");

	for (i = 0; i < SENSOR_OFFSETS; i++)
		offsets[i] = &s->offsets[i];

	qsort(offsets, SENSOR_OFFSETS, sizeof(struct ntp_offset *),
	    offset_compare);

	i = SENSOR_OFFSETS / 2;
	memcpy(&s->update, offsets[i], sizeof(s->update));
	if (SENSOR_OFFSETS % 2 == 0) {
		s->update.offset =
		    (offsets[i - 1]->offset + offsets[i]->offset) / 2;
	}
	free(offsets);

	log_debug("sensor update %s: offset %f", s->device, s->update.offset);
	priv_adjtime();
}
@


1.51
log
@Pull in <sys/time.h> for struct timespec, timeval, or clockrate

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.50 2015/05/20 13:32:39 reyk Exp $ */
d14 3
a16 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.50
log
@Remove hotplug(4) sensor support: the code has been disabled by
henning@@ 9 years ago because of an issue with the /dev/hotplug device
- it does not support multiple readers opening it.  Nobody ever cared
enough to fix it so it is time to sent the dead code to the Attic.

OK henning@@ (feeling sad about it), mpi@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.49 2015/01/09 07:35:37 deraadt Exp $ */
d21 1
@


1.49
log
@remove excessive/wrong use of sys/param.h
peanuts -- but all work has to start somewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.48 2015/01/08 00:25:47 bcook Exp $ */
a23 1
#include <sys/hotplug.h>
a34 1
#define	_PATH_DEV_HOTPLUG	"/dev/hotplug"
a249 49
}

int
sensor_hotplugfd(void)
{
#ifdef notyet
	int	fd, flags;

	if ((fd = open(_PATH_DEV_HOTPLUG, O_RDONLY, 0)) == -1) {
		log_warn("open %s", _PATH_DEV_HOTPLUG);
		return (-1);
	}

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");
	flags |= O_NONBLOCK;
	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");

	return (fd);
#else
	return (-1);
#endif
}

void
sensor_hotplugevent(int fd)
{
	struct hotplug_event	he;
	ssize_t			n;

	do {
		if ((n = read(fd, &he, sizeof(he))) == -1 &&
		    errno != EINTR && errno != EAGAIN)
			fatal("sensor_hotplugevent read");

		if (n == sizeof(he))
			switch (he.he_type) {
			case HOTPLUG_DEVAT:
				if (he.he_devclass == DV_DULL &&
				    !strcmp(he.he_devname, "sensordev"))
					sensor_scan();
				break;
			default:		/* ignore */
				break;
			}
		else if (n > 0)
			fatal("sensor_hotplugevent: short read");
	} while (n > 0 || (n == -1 && errno == EINTR));
@


1.48
log
@use the correct format string for refid

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.47 2013/10/04 14:28:16 phessler Exp $ */
d19 1
a19 1
#include <sys/param.h>
@


1.47
log
@Add ntpctl(8), which allows us to query the locally running ntpd(8) process

diff from Mike Miller <mmiller mgm51 com> (many thanks!)

OK phessler@@, henning@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.46 2012/09/20 12:43:16 patrick Exp $ */
d151 1
a151 1
	log_debug("sensor %s added (weight %d, correction %.6f, refstr %.4s, "
d153 1
a153 1
	     &s->refid, s->stratum);
@


1.46
log
@Allow ntpd.conf to assign a stratum to a sensor with the syntax stratum <level>.

OK markus@@ henning@@ phessler@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.45 2010/04/20 20:49:36 deraadt Exp $ */
d143 1
a143 1
		memcpy(&s->refid, "HARD", sizeof(s->refid));
@


1.45
log
@Get rid of MAXSENSORDEVICES.  Gaps in sensordev lists are now handled
by returning ENXIO instead of ENOENT, to essentially indicate hotplug
sensor that has gone away.  Accessing beyond the end of the sensordev
list still returns ENOENT, so that you can see there are no further devices.
ok kettenis oga
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.44 2009/05/13 15:08:10 stevesk Exp $ */
d137 1
d151 3
a153 2
	log_debug("sensor %s added (weight %d, correction %.6f, refstr %.4s)",
	    s->device, s->weight, s->correction / 1e6, &s->refid);
d209 2
a210 1
	s->offsets[s->shift].status.stratum = 0;	/* increased when sent out */
@


1.44
log
@when using a timedelta sensor for -s, if the sensor is invalid during
the first query we will never do the settime because
SENSOR_QUERY_INTERVAL (30s) is greater than SETTIME_TIMEOUT (15s).  so
during the settime period only, be more aggressive and use
SETTIME_TIMEOUT/3 for the query interval.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.43 2009/02/08 23:57:08 stevesk Exp $ */
d52 1
a52 1
	int		i, n;
d57 6
a62 2
	for (i = 0; i < MAXSENSORDEVICES; i++)
		if (sensor_probe(i, d, &s)) {
d70 5
d90 5
a94 3
		if (errno != ENOENT)
			log_warn("sensor_probe sysctl");
		return (0);
@


1.43
log
@spelling in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.42 2009/01/27 15:21:20 stevesk Exp $ */
d157 4
a160 1
	s->next = getmonotime() + SENSOR_QUERY_INTERVAL;
@


1.42
log
@fix printf format specification to print max len 4 for refid,
which may not be null terminated; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.41 2009/01/26 21:45:11 naddy Exp $ */
d107 1
a107 1
	/* check wether it is already there */
@


1.41
log
@return the correct refid for a sensor; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.40 2008/06/10 03:46:09 naddy Exp $ */
d139 1
a139 1
	log_debug("sensor %s added (weight %d, correction %.6f, refstr %-4s)",
@


1.40
log
@According to the latest SNTPv4 spec in RFC4330, secondary servers
return the address of the synchronization source as reference
identification.  Remove the obsolete special casing specified in RFC2030.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.39 2008/06/09 18:30:48 deraadt Exp $ */
a140 1
	s->refid = htonl(s->refid);
d192 1
a192 1
	s->offsets[s->shift].status.refid = s->refid;
@


1.39
log
@rename refstr to refid since it is an int32; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.37 2008/06/09 16:52:04 deraadt Exp $ */
a193 1
	s->offsets[s->shift].status.refid4 = s->refid;
@


1.38
log
@do not copy up to two garbage characters from a 1 char string into a 4 char
output buffer; ok henning
@
text
@d131 1
a131 1
		memcpy(&s->refstr, "HARD", sizeof(s->refstr));
d133 2
a134 2
		s->refstr = 0;
		strncpy((char *)&s->refstr, cs->refstr, sizeof(s->refstr));
d140 2
a141 2
	    s->device, s->weight, s->correction / 1e6, &s->refstr);
	s->refstr = htonl(s->refstr);
d193 2
a194 2
	s->offsets[s->shift].status.refid = s->refstr;
	s->offsets[s->shift].status.refid4 = s->refstr;
@


1.37
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.36 2008/06/09 16:37:35 ckuethe Exp $ */
d132 4
a135 2
	else
		memcpy(&s->refstr, cs->refstr, sizeof(s->refstr));
@


1.36
log
@Allow outgoing replies from sensor-driven servers to have a
user-configurable reference ID, eg. "GPS" or "DCF"...
ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.35 2008/03/02 20:36:42 ckuethe Exp $ */
d138 1
a138 1
		  s->device, s->weight, s->correction / 1e6, &s->refstr);
@


1.35
log
@set the refid for v4 queries too. this allows sensor-driven ntpd to says its
reference is "HARD" (or "GPS", "UMBG", "UDCF" ... in theory) rather than
"^@@^@@^@@^@@"
"why not" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.34 2007/09/12 21:08:46 ckuethe Exp $ */
d28 1
d112 1
a112 1
	/* check wether it is requested in the config file */
d130 5
d137 3
a139 2
	log_debug("sensor %s added (weight %d, correction %.6f)",
	    s->device, s->weight, s->correction / 1e6);
a154 1
	u_int32_t	 refid;
a179 1
	memcpy(&refid, "HARD", sizeof(refid));
d191 2
a192 2
	s->offsets[s->shift].status.refid = htonl(refid);
	s->offsets[s->shift].status.refid4 = htonl(refid);
@


1.34
log
@
Add a knob to compensate for a refclock that is early or late. Based on a
diff from Maurice Janssen. Manpage help from jmc and Maurice, other nits
from deraadt and otto.
ok deraadt, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.33 2007/08/04 02:58:02 ckuethe Exp $ */
d187 1
@


1.33
log
@This diff makes ntpd poll for sensors more aggressively when the use of
sensors is requested, but no sensors are found.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.32 2007/01/23 17:44:38 claudio Exp $ */
d124 1
d131 2
a132 1
	log_debug("sensor %s added", s->device);
d181 2
a182 1
	s->offsets[s->shift].offset = (sensor.value / -1e9) - getoffset();
@


1.32
log
@Typo in fatal() message found by dunceor @@ gmail dot com
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.31 2007/01/15 19:58:49 henning Exp $ */
d48 1
a48 1
void
d51 1
a51 1
	int		i;
d55 1
d57 1
a57 1
		if (sensor_probe(i, d, &s))
d59 4
@


1.31
log
@the new sensors tre can give us the number of sensors per type.
With this patch, we give up without bothering sysctl
kern_sensors.c::sensor_find() unless we know for sure that timedelta
sensor is present.
From: "Constantine A. Murenin" <cnst+openbsd@@bugmail.mojo.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.30 2007/01/15 08:19:11 otto Exp $ */
d235 1
a235 1
		fatal("fnctl F_GETFL");
d238 1
a238 1
		fatal("fnctl F_SETFL");
@


1.30
log
@Although Unix compilers accept more than one definition of a global
symbol, follow the guidelines from K&R: only one definition of a
global symbol (and possibly more declarations).  Rename some vars
here and there to avoid shadowing. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.29 2007/01/14 19:18:12 otto Exp $ */
d79 4
@


1.29
log
@Add some comments on the expresssion which converts sensor timedeltas
to ntp offsets; also, rewrite the expression to make it more clear
with no change in semantics.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.28 2006/12/28 00:24:27 naddy Exp $ */
a41 2
struct ntpd_conf *conf;

d43 1
a43 1
sensor_init(struct ntpd_conf *c)
a44 1
	conf = c;
@


1.28
log
@forgot a dereference in the previous conversion; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.27 2006/12/23 17:49:53 deraadt Exp $ */
d167 7
a173 2
	s->offsets[s->shift].offset = (0 - (float)sensor.value / 1000000000.0) -
	    getoffset();
@


1.27
log
@adapt to new two-level sensor sysctl framework; by Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.26 2006/11/20 20:58:47 henning Exp $ */
d84 1
a84 1
	slen = sizeof(sensor);
@


1.26
log
@with usig the meadian offset froma number of measurements the recording
of the last sensor update time got broken, doesn't show up with gps since
it updates often (more often than we read), but naddy ran into it with dcf.
record time of last sensor datum seperately. ok naddy balmer
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.25 2006/10/27 12:22:41 henning Exp $ */
d34 1
a34 1
#define SENSORS_MAX		255
d37 2
a38 2
void	sensor_probe(int);
void	sensor_add(struct sensor *);
d55 2
d58 3
a60 2
	for (i = 0; i < SENSORS_MAX; i++)
		sensor_probe(i);
d63 2
a64 2
void
sensor_probe(int id)
d66 3
a68 3
	int		mib[3];
	size_t		len;
	struct sensor	sensor;
d72 11
a82 1
	mib[2] = id;
d84 2
a85 2
	len = sizeof(sensor);
	if (sysctl(mib, 3, &sensor, &len, NULL, 0) == -1) {
d88 1
a88 1
		return;
d91 1
a91 2
	if (sensor.type == SENSOR_TIMEDELTA)
		sensor_add(&sensor);
d95 1
a95 1
sensor_add(struct sensor *sensor)
d102 1
a102 1
		if (!strcmp(s->device, sensor->device))
d107 1
a107 1
	    strcmp(cs->device, sensor->device) && strcmp(cs->device, "*");
d118 1
a118 1
	if ((s->device = strdup(sensor->device)) == NULL)
d120 1
a120 1
	s->sensorid = sensor->num;
d138 1
a140 2
	int		 mib[3];
	size_t		 len;
d148 2
a149 9
	mib[0] = CTL_HW;
	mib[1] = HW_SENSORS;
	mib[2] = s->sensorid;
	len = sizeof(sensor);
	if (sysctl(mib, 3, &sensor, &len, NULL, 0) == -1) {
		if (errno == ENOENT)
			sensor_remove(s);
		else
			log_warn("sensor_query sysctl");
d157 1
a157 2
	if (sensor.type != SENSOR_TIMEDELTA ||
	    strcmp(sensor.device, s->device)) {
d255 1
a255 1
				    !strcmp(he.he_devname, "sensor"))
@


1.25
log
@use clock_gettime(CLOCK_MONOTONIC, ..) to get a monotonically increasing
time, and make ntpd use that to send the next uery to an ntp peer and the
like. this has the advantage that changes to the clock do not interfere
with the intervals. for example, when we start on machines without an
RTC and the initial settime (-s) kicks in, intervals were strange.
idea from amandal@@entrisphere.com, this implementation by me
tested ckuethe, phessler, mbalmer, ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.24 2006/10/24 12:23:39 henning Exp $ */
d159 1
a159 1
	if (sensor.tv.tv_sec == s->update.rcvd)	/* already seen */
d162 1
@


1.24
log
@timedelta sensors are usually updated very often, but we used to query
them only every 30 seconds. now query them every 5,and take the median
value from 7 queries as sensor value. this takes outliers out of the
equation and makes the overall result much better, especially for
sensors with heavy jitter (like nmea for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.23 2006/10/12 10:41:51 henning Exp $ */
d104 1
a104 1
	s->next = time(NULL);
d131 3
a133 1
	s->next = time(NULL) + SENSOR_QUERY_INTERVAL;
@


1.23
log
@need to call adjtime once in a while here too, otherwise sensor-only
servers never update the system clock
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.21 2006/08/19 16:56:54 henning Exp $ */
d40 1
d161 1
a161 1
	s->update.offset = (0 - (float)sensor.value / 1000000000.0) -
d163 2
a164 2
	s->update.rcvd = sensor.tv.tv_sec;
	s->update.good = 1;
d166 16
a181 6
	s->update.status.refid = htonl(refid);
	s->update.status.stratum = 0;	/* increased when sent out */
	s->update.status.rootdelay = 0;
	s->update.status.rootdispersion = 0;
	s->update.status.reftime = sensor.tv.tv_sec;
	s->update.status.synced = 1;
d183 25
a208 2

	log_debug("sensor %s: offset %f", s->device, s->update.offset);
@


1.22
log
@internally, ntpd doesn't work with absolute offsets to system time, but
takes the offset it  adjtime() is already correcting for into account
when taking the offset from a sensor, we need to correct it by the
offset between system time and ntpd view.
@
text
@d172 2
@


1.21
log
@make sure updates from sensors have the "synced" flag set
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.20 2006/06/30 16:52:13 deraadt Exp $ */
d160 2
a161 1
	s->update.offset = 0 - (float)sensor.value / 1000000000.0;
@


1.20
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.19 2006/06/02 21:17:01 henning Exp $ */
d160 4
a164 1
	s->update.offset = 0 - (float)sensor.value / 1000000000.0;
d169 1
a169 2
	s->update.rcvd = sensor.tv.tv_sec;
	s->update.good = 1;
@


1.19
log
@just ise "HARD" as refid with sensors for v3 clients
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.18 2006/06/01 05:44:35 henning Exp $ */
d34 2
a35 2
#define SENSORS_MAX	255
#define	_PATH_DEV_HOTPLUG               "/dev/hotplug"
@


1.18
log
@urgs, other stuff snuck in
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.17 2006/06/01 04:44:23 henning Exp $ */
d126 1
d159 2
a160 4
	/* 1st 4 bytes of the desc are required to be the clock src code */
	bcopy(sensor.desc, &s->update.status.refid,
	    sizeof(s->update.status.refid));

@


1.17
log
@do not use /dev/hotplug for now, only one reader supported yet
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.16 2006/05/29 05:20:42 henning Exp $ */
a104 1
	s->priority = cs->priority;
@


1.16
log
@when we cannot open /dev/hotplug, donn't bail, just work without
with ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.15 2006/05/28 20:39:16 henning Exp $ */
d105 1
d177 1
d192 3
@


1.15
log
@allow for weight to be added to sensors or servers, so that one can
weight timedelta sensors higher than ntp peers, for example
ok deraadt mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.14 2006/05/28 19:04:37 henning Exp $ */
d178 4
a181 2
	if ((fd = open(_PATH_DEV_HOTPLUG, O_RDONLY, 0)) == -1)
		fatal(NULL);
@


1.14
log
@get clock src id from the timedelta sensor desc.
unfortunately I still don't have any hardware to test this ;(
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.13 2006/05/28 18:48:20 henning Exp $ */
d104 1
@


1.13
log
@if sysctl gives ENOENT the sensor is gone and we remove it
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.12 2006/05/28 18:47:25 henning Exp $ */
d157 4
a165 3

	/* XXX 4 char, 'DCF ', 'GPS ', 'PPS ' and the like */
	s->update.status.refid = 0;
@


1.12
log
@let sensor_query handle removals itself
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.11 2006/05/28 16:41:40 henning Exp $ */
d137 4
a140 1
		log_warn("sensor_query sysctl");
@


1.11
log
@sensor_byid not needed any more
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.10 2006/05/28 16:40:07 henning Exp $ */
d37 3
a39 2
void			 sensor_probe(int);
void			 sensor_add(struct sensor *);
d121 1
a121 1
int
d138 1
a138 1
		return (0);
d143 1
a143 1
		return (0);
d146 4
a149 2
	    strcmp(sensor.device, s->device))
		return (-1);	/* causes sensor removal */
d152 1
a152 1
		return (0);
a165 2

	return (0);
@


1.10
log
@hotplug devid will go away in a minute, so don't use it here any longer
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.9 2006/05/28 16:39:12 henning Exp $ */
a38 1
struct ntp_sensor	*sensor_byid(int);
a117 12
}

struct ntp_sensor *
sensor_byid(int id)
{
	struct ntp_sensor	*s;

	TAILQ_FOREACH(s, &conf->ntp_sensors, entry)
		if (s->sensorid == id)
			return(s);

	return (NULL);
@


1.9
log
@do not bother with rmeoval events, we remove sensors whoch vanished or
are not a timedelta sensor any more on query on the fly anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.8 2006/05/28 03:23:08 henning Exp $ */
d212 2
a213 2
				    he.he_devid > 0)
					sensor_probe(he.he_devid);
@


1.8
log
@DV_SENSORS is no more, plug workaround for the time to the real solution
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.7 2006/05/28 02:06:46 henning Exp $ */
a213 10
				break;
			case HOTPLUG_DEVDT:
				if (he.he_devclass == DV_DULL &&
				    he.he_devid > 0) {
					struct ntp_sensor	*s;

					s = sensor_byid(he.he_devid);
					if (s != NULL)
						sensor_remove(s);
				}
@


1.7
log
@make use of the new hotplug events for sensors showing up or vanishing
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.6 2006/05/27 22:23:49 henning Exp $ */
d211 2
a212 1
				if (he.he_devclass == DV_SENSOR)
d216 2
a217 1
				if (he.he_devclass == DV_SENSOR) {
@


1.6
log
@add sensor_byid(), return sensor by its id
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.4 2006/05/27 21:33:47 henning Exp $ */
d210 13
@


1.5
log
@stop passing the config around all time, just store one copy
@
text
@d37 3
a39 2
void	sensor_probe(int);
void	sensor_add(struct sensor *);
d119 12
@


1.4
log
@factor out sensor_probe from sensor_scan so we can probe a sensors when
we know its idea without scanning all again
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.3 2006/05/27 21:27:34 henning Exp $ */
d37 4
a40 2
void	sensor_probe(struct ntpd_conf *, int);
void	sensor_add(struct ntpd_conf *, struct sensor *);
d43 1
a43 1
sensor_init(struct ntpd_conf *conf)
d45 1
d50 1
a50 1
sensor_scan(struct ntpd_conf *conf)
d55 1
a55 1
		sensor_probe(conf, i);
d59 1
a59 1
sensor_probe(struct ntpd_conf *conf, int id)
d77 1
a77 1
		sensor_add(conf, &sensor);
d81 1
a81 1
sensor_add(struct ntpd_conf *conf, struct sensor *sensor)
d113 1
a113 1
sensor_remove(struct ntpd_conf *conf, struct ntp_sensor *s)
@


1.3
log
@make ntpd listen on the hotplug socket and decode yadda yadda, because
new sensors showing up will be announced that way when slacking ml comes
back from food
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.2 2006/05/27 17:01:07 henning Exp $ */
d37 1
a48 1
	struct sensor	sensor;
d50 8
d60 1
d64 1
d66 6
a71 8
	for (i = 0; i < SENSORS_MAX; i++) {
		mib[2] = i;
		len = sizeof(sensor);
		if (sysctl(mib, 3, &sensor, &len, NULL, 0) == -1) {
			if (errno != ENOENT)
				log_warn("sensor_scan sysctl");
			break;
		}
d73 2
a74 3
		if (sensor.type == SENSOR_TIMEDELTA)
			sensor_add(conf, &sensor);
	}
@


1.2
log
@config file bits for timedelta sensors, so one can specify which devices
to use. "sensors *" just uses all. untested due to lack of hardware.
hacked on the road somewhere between vancouver and calgary
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.1 2006/05/26 00:33:16 henning Exp $ */
d23 2
d35 1
d155 38
@


1.1
log
@add support for timedelta sensors, which pretty much means udcf(4) right
now. untested due to lack of hardware, and it wouldn't have worked in the
plane anyways. work in progress, currently picks up and uses all sensors
it finds, config file bits to be added soon. theo fine with this going in
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.41 2006/02/21 23:47:00 stevesk Exp $ */
d71 1
d77 8
@

