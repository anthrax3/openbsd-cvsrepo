head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.2
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.8
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.4
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.8
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.22
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.20
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.18
	OPENBSD_5_0:1.18.0.16
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.14
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.12
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.8
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.22
date	2016.09.03.11.52.06;	author reyk;	state Exp;
branches;
next	1.21;
commitid	NAWlzXnfvHaWyDX5;

1.21
date	2015.02.10.06.01.01;	author bcook;	state Exp;
branches;
next	1.20;
commitid	x7EYXst1zEkWRILz;

1.20
date	2015.01.09.07.35.37;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	X9qvCMjSyjyh2fK9;

1.19
date	2013.04.30.11.42.56;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.19.15.53.57;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.26.21.20.35;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.01.18.52.46;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.24.00.32.03;	author dtucker;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.14.06.27.13;	author dtucker;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.08.17.35.16;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.08.15.47.38;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.22.21.24.20;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.22.21.17.37;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.13.13.35.19;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.13.12.37.47;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.24.14.51.16;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.30.11.50.56;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.10.19.17.10;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.11.03.05.50;	author dtucker;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.09.15.02.15;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.07.07.32.05;	author alexander;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.02.10.08.59;	author henning;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Remove the oh so funny "LOSS OF MIND" from the diclaimer that was not
part of the original ISC license that we use in OpenBSD.  Done for
files were Henning is the original author.

OK henning@@ deraadt@@
@
text
@/*	$OpenBSD: ntp_msg.c,v 1.21 2015/02/10 06:01:01 bcook Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2004 Alexander Guy <alexander.guy@@andern.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include "ntpd.h"

int
ntp_getmsg(struct sockaddr *sa, char *p, ssize_t len, struct ntp_msg *msg)
{
	if (len != NTP_MSGSIZE_NOAUTH && len != NTP_MSGSIZE) {
		log_debug("malformed packet received from %s",
		    log_sockaddr(sa));
		return (-1);
	}

	memcpy(msg, p, sizeof(*msg));

	return (0);
}

int
ntp_sendmsg(int fd, struct sockaddr *sa, struct ntp_msg *msg)
{
	socklen_t	sa_len;
	ssize_t		n;

	if (sa != NULL)
		sa_len = SA_LEN(sa);
	else
		sa_len = 0;

	n = sendto(fd, msg, sizeof(*msg), 0, sa, sa_len);
	if (n == -1) {
		if (errno == ENOBUFS || errno == EHOSTUNREACH ||
		    errno == ENETDOWN || errno == EHOSTDOWN) {
			/* logging is futile */
			return (-1);
		}
		log_warn("sendto");
		return (-1);
	}

	if (n != sizeof(*msg)) {
		log_warnx("ntp_sendmsg: only %zd of %zu bytes sent", n,
		    sizeof(*msg));
		return (-1);
	}

	return (0);
}
@


1.21
log
@use correct formatters for s/size_t data types.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.20 2015/01/09 07:35:37 deraadt Exp $ */
d15 3
a17 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.20
log
@remove excessive/wrong use of sys/param.h
peanuts -- but all work has to start somewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.19 2013/04/30 11:42:56 mglocker Exp $ */
d65 1
a65 1
		log_warnx("ntp_sendmsg: only %ld of %ld bytes sent", n,
@


1.19
log
@Remove unused function argument variables 'len' and 'auth' from
ntp_sendmsg().  They have been removed from the function body in the past
but not from the argument list.

From Maxime Villard
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.18 2007/10/19 15:53:57 otto Exp $ */
d20 1
a20 1
#include <sys/param.h>
@


1.18
log
@don't fill the logs; spotted by deraadt@@ ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.17 2007/05/26 21:20:35 henning Exp $ */
d43 1
a43 2
ntp_sendmsg(int fd, struct sockaddr *sa, struct ntp_msg *msg, ssize_t len,
    int auth)
@


1.17
log
@use __packed structs for the on-the-wire packets and just memcpy at once
instead of kind-of manual copyin/out. increases accuracy in server mode.
collecting dust in my tree for some time, result of a conversation with
somebody i really want to give credit to, but I can't find the mails now :(
okey dokey sez theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.16 2006/07/01 18:52:46 otto Exp $ */
d32 1
a32 1
		log_warnx("malformed packet received from %s",
@


1.16
log
@remove some unneeded includes; one found by vetinari
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.15 2005/09/24 00:32:03 dtucker Exp $ */
d37 1
a37 19
#define	copyin(f,p)	memcpy(&(f), (p), sizeof(f)); (p) += sizeof(f)

	copyin(msg->status, p);
	copyin(msg->stratum, p);
	copyin(msg->ppoll, p);
	copyin(msg->precision, p);
	copyin(msg->rootdelay.int_parts, p);
	copyin(msg->rootdelay.fractions, p);
	copyin(msg->dispersion.int_parts, p);
	copyin(msg->dispersion.fractions, p);
	copyin(msg->refid, p);
	copyin(msg->reftime.int_partl, p);
	copyin(msg->reftime.fractionl, p);
	copyin(msg->orgtime.int_partl, p);
	copyin(msg->orgtime.fractionl, p);
	copyin(msg->rectime.int_partl, p);
	copyin(msg->rectime.fractionl, p);
	copyin(msg->xmttime.int_partl, p);
	copyin(msg->xmttime.fractionl, p);
a45 2
	char		 buf[NTP_MSGSIZE];
	char		*p = buf;
d47 1
a47 20

#define	copyout(p,f)	memcpy((p), &(f), sizeof(f)); p += sizeof(f)

	copyout(p, msg->status);
	copyout(p, msg->stratum);
	copyout(p, msg->ppoll);
	copyout(p, msg->precision);
	copyout(p, msg->rootdelay.int_parts);
	copyout(p, msg->rootdelay.fractions);
	copyout(p, msg->dispersion.int_parts);
	copyout(p, msg->dispersion.fractions);
	copyout(p, msg->refid);
	copyout(p, msg->reftime.int_partl);
	copyout(p, msg->reftime.fractionl);
	copyout(p, msg->orgtime.int_partl);
	copyout(p, msg->orgtime.fractionl);
	copyout(p, msg->rectime.int_partl);
	copyout(p, msg->rectime.fractionl);
	copyout(p, msg->xmttime.int_partl);
	copyout(p, msg->xmttime.fractionl);
d54 2
a55 1
	if (sendto(fd, &buf, len, 0, sa, sa_len) != len) {
d62 6
@


1.15
log
@Log source address for 'malformed packet' errors.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.14 2004/12/14 06:27:13 dtucker Exp $ */
a26 1
#include "ntp.h"
@


1.14
log
@sendto() takes socklen_t as an argument; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.13 2004/12/08 17:35:16 mickey Exp $ */
d30 1
a30 1
ntp_getmsg(char *p, ssize_t len, struct ntp_msg *msg)
d33 2
a34 1
		log_warnx("malformed packet received");
@


1.13
log
@use two tiny macros for copying fields out to simplify reading; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.12 2004/12/08 15:47:38 mickey Exp $ */
d66 1
a66 1
	u_int8_t	sa_len;
@


1.12
log
@uniquely name members of s_fixedpt and l_fixedpt; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.11 2004/10/22 21:24:20 henning Exp $ */
d37 19
a55 34
	memcpy(&msg->status, p, sizeof(msg->status));
	p += sizeof(msg->status);
	memcpy(&msg->stratum, p, sizeof(msg->stratum));
	p += sizeof(msg->stratum);
	memcpy(&msg->ppoll, p, sizeof(msg->ppoll));
	p += sizeof(msg->ppoll);
	memcpy(&msg->precision, p, sizeof(msg->precision));
	p += sizeof(msg->precision);
	memcpy(&msg->rootdelay.int_parts, p, sizeof(msg->rootdelay.int_parts));
	p += sizeof(msg->rootdelay.int_parts);
	memcpy(&msg->rootdelay.fractions, p, sizeof(msg->rootdelay.fractions));
	p += sizeof(msg->rootdelay.fractions);
	memcpy(&msg->dispersion.int_parts, p, sizeof(msg->dispersion.int_parts));
	p += sizeof(msg->dispersion.int_parts);
	memcpy(&msg->dispersion.fractions, p, sizeof(msg->dispersion.fractions));
	p += sizeof(msg->dispersion.fractions);
	memcpy(&msg->refid, p, sizeof(msg->refid));
	p += sizeof(msg->refid);
	memcpy(&msg->reftime.int_partl, p, sizeof(msg->reftime.int_partl));
	p += sizeof(msg->reftime.int_partl);
	memcpy(&msg->reftime.fractionl, p, sizeof(msg->reftime.fractionl));
	p += sizeof(msg->reftime.fractionl);
	memcpy(&msg->orgtime.int_partl, p, sizeof(msg->orgtime.int_partl));
	p += sizeof(msg->orgtime.int_partl);
	memcpy(&msg->orgtime.fractionl, p, sizeof(msg->orgtime.fractionl));
	p += sizeof(msg->orgtime.fractionl);
	memcpy(&msg->rectime.int_partl, p, sizeof(msg->rectime.int_partl));
	p += sizeof(msg->rectime.int_partl);
	memcpy(&msg->rectime.fractionl, p, sizeof(msg->rectime.fractionl));
	p += sizeof(msg->rectime.fractionl);
	memcpy(&msg->xmttime.int_partl, p, sizeof(msg->xmttime.int_partl));
	p += sizeof(msg->xmttime.int_partl);
	memcpy(&msg->xmttime.fractionl, p, sizeof(msg->xmttime.fractionl));
	p += sizeof(msg->xmttime.fractionl);
d65 1
a65 1
	char		*p;
d68 19
a86 35
	p = buf;
	memcpy(p, &msg->status, sizeof(msg->status));
	p += sizeof(msg->status);
	memcpy(p, &msg->stratum, sizeof(msg->stratum));
	p += sizeof(msg->stratum);
	memcpy(p, &msg->ppoll, sizeof(msg->ppoll));
	p += sizeof(msg->ppoll);
	memcpy(p, &msg->precision, sizeof(msg->precision));
	p += sizeof(msg->precision);
	memcpy(p, &msg->rootdelay.int_parts, sizeof(msg->rootdelay.int_parts));
	p += sizeof(msg->rootdelay.int_parts);
	memcpy(p, &msg->rootdelay.fractions, sizeof(msg->rootdelay.fractions));
	p += sizeof(msg->rootdelay.fractions);
	memcpy(p, &msg->dispersion.int_parts, sizeof(msg->dispersion.int_parts));
	p += sizeof(msg->dispersion.int_parts);
	memcpy(p, &msg->dispersion.fractions, sizeof(msg->dispersion.fractions));
	p += sizeof(msg->dispersion.fractions);
	memcpy(p, &msg->refid, sizeof(msg->refid));
	p += sizeof(msg->refid);
	memcpy(p, &msg->reftime.int_partl, sizeof(msg->reftime.int_partl));
	p += sizeof(msg->reftime.int_partl);
	memcpy(p, &msg->reftime.fractionl, sizeof(msg->reftime.fractionl));
	p += sizeof(msg->reftime.fractionl);
	memcpy(p, &msg->orgtime.int_partl, sizeof(msg->orgtime.int_partl));
	p += sizeof(msg->orgtime.int_partl);
	memcpy(p, &msg->orgtime.fractionl, sizeof(msg->orgtime.fractionl));
	p += sizeof(msg->orgtime.fractionl);
	memcpy(p, &msg->rectime.int_partl, sizeof(msg->rectime.int_partl));
	p += sizeof(msg->rectime.int_partl);
	memcpy(p, &msg->rectime.fractionl, sizeof(msg->rectime.fractionl));
	p += sizeof(msg->rectime.fractionl);
	memcpy(p, &msg->xmttime.int_partl, sizeof(msg->xmttime.int_partl));
	p += sizeof(msg->xmttime.int_partl);
	memcpy(p, &msg->xmttime.fractionl, sizeof(msg->xmttime.fractionl));
	p += sizeof(msg->xmttime.fractionl);
@


1.11
log
@oups
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.9 2004/10/13 13:35:19 henning Exp $ */
d45 8
a52 8
	memcpy(&msg->rootdelay.int_part, p, sizeof(msg->rootdelay.int_part));
	p += sizeof(msg->rootdelay.int_part);
	memcpy(&msg->rootdelay.fraction, p, sizeof(msg->rootdelay.fraction));
	p += sizeof(msg->rootdelay.fraction);
	memcpy(&msg->dispersion.int_part, p, sizeof(msg->dispersion.int_part));
	p += sizeof(msg->dispersion.int_part);
	memcpy(&msg->dispersion.fraction, p, sizeof(msg->dispersion.fraction));
	p += sizeof(msg->dispersion.fraction);
d55 16
a70 16
	memcpy(&msg->reftime.int_part, p, sizeof(msg->reftime.int_part));
	p += sizeof(msg->reftime.int_part);
	memcpy(&msg->reftime.fraction, p, sizeof(msg->reftime.fraction));
	p += sizeof(msg->reftime.fraction);
	memcpy(&msg->orgtime.int_part, p, sizeof(msg->orgtime.int_part));
	p += sizeof(msg->orgtime.int_part);
	memcpy(&msg->orgtime.fraction, p, sizeof(msg->orgtime.fraction));
	p += sizeof(msg->orgtime.fraction);
	memcpy(&msg->rectime.int_part, p, sizeof(msg->rectime.int_part));
	p += sizeof(msg->rectime.int_part);
	memcpy(&msg->rectime.fraction, p, sizeof(msg->rectime.fraction));
	p += sizeof(msg->rectime.fraction);
	memcpy(&msg->xmttime.int_part, p, sizeof(msg->xmttime.int_part));
	p += sizeof(msg->xmttime.int_part);
	memcpy(&msg->xmttime.fraction, p, sizeof(msg->xmttime.fraction));
	p += sizeof(msg->xmttime.fraction);
d92 8
a99 8
	memcpy(p, &msg->rootdelay.int_part, sizeof(msg->rootdelay.int_part));
	p += sizeof(msg->rootdelay.int_part);
	memcpy(p, &msg->rootdelay.fraction, sizeof(msg->rootdelay.fraction));
	p += sizeof(msg->rootdelay.fraction);
	memcpy(p, &msg->dispersion.int_part, sizeof(msg->dispersion.int_part));
	p += sizeof(msg->dispersion.int_part);
	memcpy(p, &msg->dispersion.fraction, sizeof(msg->dispersion.fraction));
	p += sizeof(msg->dispersion.fraction);
d102 16
a117 16
	memcpy(p, &msg->reftime.int_part, sizeof(msg->reftime.int_part));
	p += sizeof(msg->reftime.int_part);
	memcpy(p, &msg->reftime.fraction, sizeof(msg->reftime.fraction));
	p += sizeof(msg->reftime.fraction);
	memcpy(p, &msg->orgtime.int_part, sizeof(msg->orgtime.int_part));
	p += sizeof(msg->orgtime.int_part);
	memcpy(p, &msg->orgtime.fraction, sizeof(msg->orgtime.fraction));
	p += sizeof(msg->orgtime.fraction);
	memcpy(p, &msg->rectime.int_part, sizeof(msg->rectime.int_part));
	p += sizeof(msg->rectime.int_part);
	memcpy(p, &msg->rectime.fraction, sizeof(msg->rectime.fraction));
	p += sizeof(msg->rectime.fraction);
	memcpy(p, &msg->xmttime.int_part, sizeof(msg->xmttime.int_part));
	p += sizeof(msg->xmttime.int_part);
	memcpy(p, &msg->xmttime.fraction, sizeof(msg->xmttime.fraction));
	p += sizeof(msg->xmttime.fraction);
@


1.10
log
@in server mode reply with stratum from the peer that we currently prefer
plus one
@
text
@d33 1
a33 2
		log_warnx("malformed packet received: len is %d should be %d "
		    "or with auth %d", len, NTP_MSGSIZE_NOAUTH, NTP_MSGSIZE);
@


1.9
log
@in struct ntp_msg, rename "distance" to "rootdelay" to closer match RFCs
and such
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.8 2004/10/13 12:37:47 henning Exp $ */
d33 2
a34 1
		log_warnx("malformed packet received");
@


1.8
log
@fall cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.7 2004/09/24 14:51:16 henning Exp $ */
d45 4
a48 4
	memcpy(&msg->distance.int_part, p, sizeof(msg->distance.int_part));
	p += sizeof(msg->distance.int_part);
	memcpy(&msg->distance.fraction, p, sizeof(msg->distance.fraction));
	p += sizeof(msg->distance.fraction);
d92 4
a95 4
	memcpy(p, &msg->distance.int_part, sizeof(msg->distance.int_part));
	p += sizeof(msg->distance.int_part);
	memcpy(p, &msg->distance.fraction, sizeof(msg->distance.fraction));
	p += sizeof(msg->distance.fraction);
@


1.7
log
@connect() the client-side sockets. idea & test & ok camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.6 2004/08/30 11:50:56 deraadt Exp $ */
d32 1
a32 7
	int		 auth, i;

	if (len == NTP_MSGSIZE)
		auth = 1;
	else if (len == NTP_MSGSIZE_NOAUTH)
		auth = 0;
	else {
a71 11
	if (auth) {
		memcpy(&msg->keyid, p, sizeof(msg->keyid));
		p += sizeof(msg->keyid);
		for (i = 0; i < NTP_DIGESTSIZE; i++) {
			memcpy(&msg->digest[i], p, sizeof(msg->digest[i]));
			p += sizeof(msg->digest[i]);
		}

		/* XXX check auth */
	}

a117 4

	if (auth) {
		/* XXX */
	}
@


1.6
log
@ENOBUFS, EHOSTUNREACH, ENETDOWN and EHOSTDOWN are bad reasons to log; ok otto henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.5 2004/08/10 19:17:10 henning Exp $ */
d96 3
a98 2
	char	 buf[NTP_MSGSIZE];
	char	*p;
d140 6
a145 1
	if (sendto(fd, &buf, len, 0, sa, SA_LEN(sa)) != len) {
@


1.5
log
@wrong sizeof; Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.4 2004/07/11 03:05:50 dtucker Exp $ */
d24 1
d140 5
@


1.4
log
@Use SA_LEN(sa) instead of sa->sa_len; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.3 2004/07/09 15:02:15 henning Exp $ */
d79 1
a79 1
		p += sizeof(msg->refid);
@


1.3
log
@don't panic when sendto() fails; for the client part just re-schedule
noticed & fix tested by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.2 2004/07/07 07:32:05 alexander Exp $ */
d138 1
a138 1
	if (sendto(fd, &buf, len, 0, sa, sa->sa_len) != len) {
@


1.2
log
@* Convert to use the new double-based time handling functions.
* Respond to the query with a reasonable received time (which
  will help clients get better accuracy).
* Consolidate the server response code in preparation for a
  completely 'proper' response to the client.

tips and ok from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_msg.c,v 1.1 2004/06/02 10:08:59 henning Exp $ */
d138 4
a141 2
	if (sendto(fd, &buf, len, 0, sa, sa->sa_len) != len)
		fatal("sendto");
@


1.1
log
@prepare for client functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.5 2004/06/01 21:58:08 henning Exp $ */
a141 10
}

void
get_ts(struct l_fixedpt *t)
{
	struct timeval		 tv;

	gettimeofday(&tv, NULL);
	t->int_part = tv.tv_sec + JAN_1970;
	t->fraction = ((float)tv.tv_usec)/1000000 * UINT_MAX;
@

