head	1.19;
access;
symbols
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.3.0.14
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.12
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.10
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2016.09.26.16.55.02;	author rzalamena;	state Exp;
branches;
next	1.18;
commitid	CSM07eEL9yrHalR4;

1.18
date	2016.09.14.13.20.16;	author rzalamena;	state Exp;
branches;
next	1.17;
commitid	FUtuYlECIdeLHfjN;

1.17
date	2016.09.03.11.52.06;	author reyk;	state Exp;
branches;
next	1.16;
commitid	NAWlzXnfvHaWyDX5;

1.16
date	2015.12.19.17.55.29;	author reyk;	state Exp;
branches;
next	1.15;
commitid	xe8YS3ftA7mmBwbB;

1.15
date	2015.12.05.13.12.16;	author claudio;	state Exp;
branches;
next	1.14;
commitid	1u4z6EiD1xQ1Wwbx;

1.14
date	2015.10.25.10.52.48;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	tpIBjyPvysWWgc1M;

1.13
date	2015.10.10.20.10.14;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	YcdU9OrG7l85EzMx;

1.12
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	sbrB3Q5CNxcwZpfU;

1.11
date	2015.10.03.02.48.54;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	cFnEFU704CJYx9Sv;

1.10
date	2015.03.24.18.25.27;	author henning;	state Exp;
branches;
next	1.9;
commitid	4DGiXKfYMcHkygns;

1.9
date	2015.02.12.01.54.57;	author reyk;	state Exp;
branches;
next	1.8;
commitid	eJZFYJXXt9fmfGXk;

1.8
date	2015.01.21.03.14.10;	author bcook;	state Exp;
branches;
next	1.7;
commitid	Y0dDbtaeevmLLVjt;

1.7
date	2015.01.13.02.28.56;	author bcook;	state Exp;
branches;
next	1.6;
commitid	h77ELH1lDWjNCTWO;

1.6
date	2015.01.09.07.35.37;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	X9qvCMjSyjyh2fK9;

1.5
date	2014.02.10.09.12.34;	author dtucker;	state Exp;
branches;
next	1.4;

1.4
date	2013.11.13.20.44.39;	author benno;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2009.02.10.16.41.39;	author stevesk;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.12.10.46.09;	author henning;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Teach ntpd(8) how to use socket status to shutdown the daemon. While at
it, remove some verbose shutdown messages that we had before with pipe
close.

ok reyk@@
@
text
@/*	$OpenBSD: ntp_dns.c,v 1.18 2016/09/14 13:20:16 rzalamena Exp $ */

/*
 * Copyright (c) 2003-2008 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/resource.h>
#include <sys/time.h>

#include <err.h>
#include <errno.h>
#include <poll.h>
#include <fcntl.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "ntpd.h"

volatile sig_atomic_t	 quit_dns = 0;
struct imsgbuf		*ibuf_dns;

void	sighdlr_dns(int);
int	dns_dispatch_imsg(void);

void
sighdlr_dns(int sig)
{
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		quit_dns = 1;
		break;
	}
}

void
ntp_dns(struct ntpd_conf *nconf, struct passwd *pw)
{
	struct pollfd		 pfd[1];
	int			 nfds, nullfd;

	if (setpriority(PRIO_PROCESS, 0, 0) == -1)
		log_warn("could not set priority");

	/* in this case the parent didn't init logging and didn't daemonize */
	if (nconf->settime && !nconf->debug) {
		log_init(nconf->debug, LOG_DAEMON);
		if (setsid() == -1)
			fatal("setsid");
	}
	log_procinit("dns");

	if ((nullfd = open("/dev/null", O_RDWR, 0)) == -1)
		fatal(NULL);

	if (!nconf->debug) {
		dup2(nullfd, STDIN_FILENO);
		dup2(nullfd, STDOUT_FILENO);
		dup2(nullfd, STDERR_FILENO);
	}
	close(nullfd);

	setproctitle("dns engine");

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	signal(SIGTERM, sighdlr_dns);
	signal(SIGINT, sighdlr_dns);
	signal(SIGHUP, SIG_IGN);

	if ((ibuf_dns = malloc(sizeof(struct imsgbuf))) == NULL)
		fatal(NULL);
	imsg_init(ibuf_dns, PARENT_SOCK_FILENO);

	if (pledge("stdio dns", NULL) == -1)
		err(1, "pledge");

	while (quit_dns == 0) {
		pfd[0].fd = ibuf_dns->fd;
		pfd[0].events = POLLIN;
		if (ibuf_dns->w.queued)
			pfd[0].events |= POLLOUT;

		if ((nfds = poll(pfd, 1, INFTIM)) == -1)
			if (errno != EINTR) {
				log_warn("poll error");
				quit_dns = 1;
			}

		if (nfds > 0 && (pfd[0].revents & POLLOUT))
			if (msgbuf_write(&ibuf_dns->w) <= 0 &&
			    errno != EAGAIN) {
				log_warn("pipe write error (to ntp engine)");
				quit_dns = 1;
			}

		if (nfds > 0 && pfd[0].revents & POLLIN) {
			nfds--;
			if (dns_dispatch_imsg() == -1)
				quit_dns = 1;
		}
	}

	msgbuf_clear(&ibuf_dns->w);
	free(ibuf_dns);
	exit(0);
}

int
dns_dispatch_imsg(void)
{
	struct imsg		 imsg;
	int			 n, cnt;
	char			*name;
	struct ntp_addr		*h, *hn;
	struct ibuf		*buf;
	const char		*str;

	if (((n = imsg_read(ibuf_dns)) == -1 && errno != EAGAIN) || n == 0)
		return (-1);

	for (;;) {
		if ((n = imsg_get(ibuf_dns, &imsg)) == -1)
			return (-1);

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_HOST_DNS:
		case IMSG_CONSTRAINT_DNS:
			if (imsg.hdr.type == IMSG_HOST_DNS)
				str = "IMSG_HOST_DNS";
			else
				str = "IMSG_CONSTRAINT_DNS";
			name = imsg.data;
			if (imsg.hdr.len < 1 + IMSG_HEADER_SIZE)
				fatalx("invalid %s received", str);
			imsg.hdr.len -= 1 + IMSG_HEADER_SIZE;
			if (name[imsg.hdr.len] != '\0' ||
			    strlen(name) != imsg.hdr.len)
				fatalx("invalid %s received", str);
			if ((cnt = host_dns(name, &hn)) == -1)
				break;
			buf = imsg_create(ibuf_dns, imsg.hdr.type,
			    imsg.hdr.peerid, 0,
			    cnt * sizeof(struct sockaddr_storage));
			if (cnt > 0) {
				if (buf) {
					for (h = hn; h != NULL; h = h->next)
						if (imsg_add(buf, &h->ss,
						    sizeof(h->ss)) == -1) {
							buf = NULL;
							break;
						}
				}
				host_dns_free(hn);
				hn = NULL;
			}
			if (buf)
				imsg_close(ibuf_dns, buf);
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}
	return (0);
}
@


1.18
log
@Teach ntpd(8) how to fork+exec.

ok reyk@@, bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.17 2016/09/03 11:52:06 reyk Exp $ */
d138 1
a138 1
	if ((n = imsg_read(ibuf_dns)) == -1 && errno != EAGAIN)
a139 5

	if (n == 0) {	/* connection closed */
		log_warnx("dispatch_imsg in main: pipe closed");
		return (-1);
	}
@


1.17
log
@Remove the oh so funny "LOSS OF MIND" from the diclaimer that was not
part of the original ISC license that we use in OpenBSD.  Done for
files were Henning is the original author.

OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.16 2015/12/19 17:55:29 reyk Exp $ */
d52 2
a53 2
pid_t
ntp_dns(int pipe_ntp[2], struct ntpd_conf *nconf, struct passwd *pw)
a54 1
	pid_t			 pid;
a57 10
	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
		break;
	case 0:
		break;
	default:
		return (pid);
	}

a80 2
	close(pipe_ntp[0]);

d92 1
a92 1
	imsg_init(ibuf_dns, pipe_ntp[1]);
d125 1
a125 1
	_exit(0);
@


1.16
log
@Switch and sync to the log.c variant from httpd/relayd/iked/snmpd/vmd.

OK bcook@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.15 2015/12/05 13:12:16 claudio Exp $ */
d14 3
a16 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.15
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.14 2015/10/25 10:52:48 deraadt Exp $ */
d30 1
d70 1
a70 1
		warn("could not set priority");
d74 1
a74 1
		log_init(nconf->debug);
d78 1
d91 1
@


1.14
log
@the DNS process was not discarding & redirecting stdin/out/err to
/dev/null.  copy the code from the ntp engine.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.13 2015/10/10 20:10:14 deraadt Exp $ */
d148 1
a148 1
	if ((n = imsg_read(ibuf_dns)) == -1)
@


1.13
log
@pledge "dns rw" is not a reliable pattern.  This means malloc() and other
types of functions (perhaps required by 'stdio' or 'libevent' will not
become available unless DNS suceeds.  Replace it with "stdio dns".
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.12 2015/10/09 01:37:09 deraadt Exp $ */
d26 1
d56 1
a56 1
	int			 nfds;
d77 10
@


1.12
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.11 2015/10/03 02:48:54 deraadt Exp $ */
d93 1
a93 1
	if (pledge("dns rw", NULL) == -1)
@


1.11
log
@the ntp dns process only needs tame "dns rw" to operate.  at least,
that's the case after kernel code got fixed to handle inet6 for dns...
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.10 2015/03/24 18:25:27 henning Exp $ */
d93 2
a94 2
	if (tame("dns rw", NULL) == -1)
		err(1, "tame");
@


1.10
log
@instead of routing SIGHUP thru sighdlr_dns() which then ignores it,
ignore it directly. no functional change. Rafael Neves rafaelneves at gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.9 2015/02/12 01:54:57 reyk Exp $ */
d92 3
@


1.9
log
@Use ntpd's deferred DNS resolving for constraints as well.  This
allows to get constraint addresses even if network/DNS is not
available at startup (or system boot).

thumbs up & OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.8 2015/01/21 03:14:10 bcook Exp $ */
d87 1
a87 1
	signal(SIGHUP, sighdlr_dns);
@


1.8
log
@Fix deferred host DNS lookups.

If the network is unreachable when ntpd starts and host_dns fails, be sure
that we still close the HOST_DNS imsg.

Thanks to Paul de Weerd <weerd at weirdnet dot nl> for reporting this.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.7 2015/01/13 02:28:56 bcook Exp $ */
d132 1
d151 5
d158 1
a158 1
				fatalx("invalid IMSG_HOST_DNS received");
d162 1
a162 1
				fatalx("invalid IMSG_HOST_DNS received");
d165 1
a165 1
			buf = imsg_create(ibuf_dns, IMSG_HOST_DNS,
@


1.7
log
@fix some memory leaks in dns handling.

 - Nothing seems to free the result of host_dns(), so add host_dns_free() and
   call after each query.
 - If imsg_add() fails, it frees buf. Avoid subsequently dereferencing the
   freed buf in imsg_close().

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.6 2015/01/09 07:35:37 deraadt Exp $ */
a169 2
					if (buf)
						imsg_close(ibuf_dns, buf);
d174 2
@


1.6
log
@remove excessive/wrong use of sys/param.h
peanuts -- but all work has to start somewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.5 2014/02/10 09:12:34 dtucker Exp $ */
d162 14
a175 7
			if (buf == NULL)
				break;
			if (cnt > 0)
				for (h = hn; h != NULL; h = h->next)
					imsg_add(buf, &h->ss, sizeof(h->ss));

			imsg_close(ibuf_dns, buf);
@


1.5
log
@Run the serving and privileged ntpd processes at high priority and the
dns process at normal priority.  Should improve latency on loaded machines.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.4 2013/11/13 20:44:39 benno Exp $ */
d19 1
a19 1
#include <sys/param.h>
@


1.4
log
@from sthen: handle msgbuf_write() returning EAGAIN

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.3 2010/05/26 13:56:08 nicm Exp $ */
d20 1
d22 2
d66 3
@


1.3
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.2 2009/02/10 16:41:39 stevesk Exp $ */
d100 2
a101 1
			if (msgbuf_write(&ibuf_dns->w) < 0) {
@


1.2
log
@endservent() not needed here; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp_dns.c,v 1.1 2008/09/12 10:46:09 henning Exp $ */
d124 1
a124 1
	struct buf		*buf;
@


1.1
log
@move dns lookups to its own (privilege revoking, not chrooting) process.
reason: the parent process must never ever block, but the dns routines can.
last not least this fixes ntpd -s 'hanging' for a long time.
tested by a couple of people
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.103 2008/01/28 11:45:59 mpf Exp $ */
a77 1
	endservent();
@

