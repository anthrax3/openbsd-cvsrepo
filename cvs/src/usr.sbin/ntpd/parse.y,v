head	1.66;
access;
symbols
	OPENBSD_6_1:1.65.0.8
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.65.0.4
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.63.0.4
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.52.0.6
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.50.0.4
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.50.0.2
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.49.0.4
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.2
	OPENBSD_5_0:1.47.0.6
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.47.0.4
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.46.0.4
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.42.0.2
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.30.0.4
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19;
locks; strict;
comment	@ * @;


1.66
date	2017.05.30.23.30.48;	author benno;	state Exp;
branches;
next	1.65;
commitid	QAWRWuyNn05Y7pSZ;

1.65
date	2015.10.31.19.32.18;	author naddy;	state Exp;
branches;
next	1.64;
commitid	xb9UXTbqMxqHtuL4;

1.64
date	2015.10.23.14.52.20;	author phessler;	state Exp;
branches;
next	1.63;
commitid	37dFIvtgNCa7AEy2;

1.63
date	2015.07.18.00.53.44;	author bcook;	state Exp;
branches;
next	1.62;
commitid	X2stLxrcDblnYkzc;

1.62
date	2015.05.17.18.31.32;	author reyk;	state Exp;
branches;
next	1.61;
commitid	aCSIV6rNWhdw3L8D;

1.61
date	2015.02.12.23.07.52;	author reyk;	state Exp;
branches;
next	1.60;
commitid	XU5MZGq7XKzYNDoa;

1.60
date	2015.02.12.01.54.57;	author reyk;	state Exp;
branches;
next	1.59;
commitid	eJZFYJXXt9fmfGXk;

1.59
date	2015.02.10.11.46.39;	author reyk;	state Exp;
branches;
next	1.58;
commitid	azl2PYCfRcxq0H2y;

1.58
date	2015.02.10.06.40.08;	author reyk;	state Exp;
branches;
next	1.57;
commitid	pXoTR74Ztt0R3SV0;

1.57
date	2015.01.10.13.47.05;	author tedu;	state Exp;
branches;
next	1.56;
commitid	d03DIVk9MVCSKQBu;

1.56
date	2015.01.08.00.30.08;	author bcook;	state Exp;
branches;
next	1.55;
commitid	KDtICkil0jI83gxu;

1.55
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.54;
commitid	3Z7yItGpFsmshk0c;

1.54
date	2014.11.14.03.20.37;	author doug;	state Exp;
branches;
next	1.53;
commitid	M08zdkdK3z1pxKwF;

1.53
date	2014.11.03.20.15.31;	author bluhm;	state Exp;
branches;
next	1.52;
commitid	ziMZlrkCPhUaYhzj;

1.52
date	2013.11.25.12.58.42;	author benno;	state Exp;
branches;
next	1.51;

1.51
date	2013.10.21.08.48.22;	author phessler;	state Exp;
branches;
next	1.50;

1.50
date	2012.09.20.12.43.16;	author patrick;	state Exp;
branches;
next	1.49;

1.49
date	2011.12.28.19.32.34;	author phessler;	state Exp;
branches;
next	1.48;

1.48
date	2011.09.21.15.41.30;	author phessler;	state Exp;
branches;
next	1.47;

1.47
date	2010.08.03.18.42.40;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2009.03.31.21.03.48;	author tobias;	state Exp;
branches;
next	1.45;

1.45
date	2008.10.17.14.32.47;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.09.18.26.35;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.09.16.37.35;	author ckuethe;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.26.10.09.58;	author mpf;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.20.14.24.02;	author pyr;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.16.20.01.23;	author mpf;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.13.16.35.21;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.11.14.39.17;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.14.06.29.54;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.14.03.07.11;	author ckuethe;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.12.21.08.46;	author ckuethe;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.12.18.32.54;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.11.23.33.37;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.03.00.49.09;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.01.06.06.59;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.28.20.39.16;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.27.17.01.07;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.26.01.06.12;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.19.16.42.57;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.25.06.27.41;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.10.11.27.54;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.05.14.28.29;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.09.15.00.23.08;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.15.00.18.12;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.10.12.45.27;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.10.12.41.15;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.29.11.01.48;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.28.16.56.21;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.28.16.38.43;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.21.09.40.55;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.20.16.47.55;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.12.09.22.38;	author dtucker;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.09.19.28.03;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.09.10.53.33;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.08.15.06.43;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.08.01.22.57;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.07.06.51.16;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.07.05.47.57;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.07.03.15.37;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.06.23.08.26;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.05.07.57.52;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.17.19.17.48;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.01.21.58.09;	author henning;	state Exp;
branches;
next	;


desc
@@


1.66
log
@add option "query from <ip>" to ntpd.conf, to specify a local IP
address for outgoing ntp queries.
From Job Snijders, thanks!
with feedback and ok henning@@
@
text
@/*	$OpenBSD: parse.y,v 1.65 2015/10/31 19:32:18 naddy Exp $ */

/*
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>

#include "ntpd.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *);
int		 popfile(void);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

struct ntpd_conf		*conf;
struct sockaddr_in		 query_addr4;
struct sockaddr_in6		 query_addr6;

struct opts {
	int		weight;
	int		correction;
	int		stratum;
	int		rtable;
	char		*refstr;
} opts;
void		opts_default(void);

typedef struct {
	union {
		int64_t			 number;
		char			*string;
		struct ntp_addr_wrap	*addr;
		struct opts		 opts;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	LISTEN ON CONSTRAINT CONSTRAINTS FROM QUERY
%token	SERVER SERVERS SENSOR CORRECTION RTABLE REFID STRATUM WEIGHT
%token	ERROR
%token	<v.string>		STRING
%token	<v.number>		NUMBER
%type	<v.addr>		address url
%type	<v.opts>		listen_opts listen_opts_l listen_opt
%type	<v.opts>		server_opts server_opts_l server_opt
%type	<v.opts>		sensor_opts sensor_opts_l sensor_opt
%type	<v.opts>		correction
%type	<v.opts>		rtable
%type	<v.opts>		refid
%type	<v.opts>		stratum
%type	<v.opts>		weight
%%

grammar		: /* empty */
		| grammar '\n'
		| grammar main '\n'
		| grammar error '\n'		{ file->errors++; }
		;

main		: LISTEN ON address listen_opts	{
			struct listen_addr	*la;
			struct ntp_addr		*h, *next;

			if ((h = $3->a) == NULL &&
			    (host_dns($3->name, &h) == -1 || !h)) {
				yyerror("could not resolve \"%s\"", $3->name);
				free($3->name);
				free($3);
				YYERROR;
			}

			for (; h != NULL; h = next) {
				next = h->next;
				la = calloc(1, sizeof(struct listen_addr));
				if (la == NULL)
					fatal("listen on calloc");
				la->fd = -1;
				la->rtable = $4.rtable;
				memcpy(&la->sa, &h->ss,
				    sizeof(struct sockaddr_storage));
				TAILQ_INSERT_TAIL(&conf->listen_addrs, la,
				    entry);
				free(h);
			}
			free($3->name);
			free($3);
		}
		| QUERY FROM STRING {
			struct sockaddr_in sin4;
			struct sockaddr_in6 sin6;

			sin4.sin_family = AF_INET;
			sin4.sin_len = sizeof(struct sockaddr_in);
			sin6.sin6_family = AF_INET6;
			sin6.sin6_len = sizeof(struct sockaddr_in6);

			if (inet_pton(AF_INET, $3, &sin4.sin_addr) == 1)
				memcpy(&query_addr4, &sin4, sin4.sin_len);
			else if (inet_pton(AF_INET6, $3, &sin6.sin6_addr) == 1)
				memcpy(&query_addr6, &sin6, sin6.sin6_len);
			else {
				yyerror("invalid IPv4 or IPv6 address: %s\n",
				    $3);
				free($3);
				YYERROR;
			}

			free($3);
		}
		| SERVERS address server_opts	{
			struct ntp_peer		*p;
			struct ntp_addr		*h, *next;

			h = $2->a;
			do {
				if (h != NULL) {
					next = h->next;
					if (h->ss.ss_family != AF_INET &&
					    h->ss.ss_family != AF_INET6) {
						yyerror("IPv4 or IPv6 address "
						    "or hostname expected");
						free(h);
						free($2->name);
						free($2);
						YYERROR;
					}
					h->next = NULL;
				} else
					next = NULL;

				p = new_peer();
				p->weight = $3.weight;
				p->query_addr4 = query_addr4;
				p->query_addr6 = query_addr6;
				p->addr = h;
				p->addr_head.a = h;
				p->addr_head.pool = 1;
				p->addr_head.name = strdup($2->name);
				if (p->addr_head.name == NULL)
					fatal(NULL);
				if (p->addr != NULL)
					p->state = STATE_DNS_DONE;
				TAILQ_INSERT_TAIL(&conf->ntp_peers, p, entry);
				h = next;
			} while (h != NULL);

			free($2->name);
			free($2);
		}
		| SERVER address server_opts {
			struct ntp_peer		*p;
			struct ntp_addr		*h, *next;

			p = new_peer();
			for (h = $2->a; h != NULL; h = next) {
				next = h->next;
				if (h->ss.ss_family != AF_INET &&
				    h->ss.ss_family != AF_INET6) {
					yyerror("IPv4 or IPv6 address "
					    "or hostname expected");
					free(h);
					free(p);
					free($2->name);
					free($2);
					YYERROR;
				}
				h->next = p->addr;
				p->addr = h;
			}

			p->weight = $3.weight;
			p->query_addr4 = query_addr4;
			p->query_addr6 = query_addr6;
			p->addr_head.a = p->addr;
			p->addr_head.pool = 0;
			p->addr_head.name = strdup($2->name);
			if (p->addr_head.name == NULL)
				fatal(NULL);
			if (p->addr != NULL)
				p->state = STATE_DNS_DONE;
			TAILQ_INSERT_TAIL(&conf->ntp_peers, p, entry);
			free($2->name);
			free($2);
		}
		| CONSTRAINTS FROM url		{
			struct constraint	*p;
			struct ntp_addr		*h, *next;

			h = $3->a;
			do {
				if (h != NULL) {
					next = h->next;
					if (h->ss.ss_family != AF_INET &&
					    h->ss.ss_family != AF_INET6) {
						yyerror("IPv4 or IPv6 address "
						    "or hostname expected");
						free(h);
						free($3->name);
						free($3->path);
						free($3);
						YYERROR;
					}
					h->next = NULL;
				} else
					next = NULL;

				p = new_constraint();
				p->addr = h;
				p->addr_head.a = h;
				p->addr_head.pool = 1;
				p->addr_head.name = strdup($3->name);
				p->addr_head.path = strdup($3->path);
				if (p->addr_head.name == NULL ||
				    p->addr_head.path == NULL)
					fatal(NULL);
				if (p->addr != NULL)
					p->state = STATE_DNS_DONE;
				constraint_add(p);
				h = next;
			} while (h != NULL);

			free($3->name);
			free($3);
		}
		| CONSTRAINT FROM url		{
			struct constraint	*p;
			struct ntp_addr		*h, *next;

			p = new_constraint();
			for (h = $3->a; h != NULL; h = next) {
				next = h->next;
				if (h->ss.ss_family != AF_INET &&
				    h->ss.ss_family != AF_INET6) {
					yyerror("IPv4 or IPv6 address "
					    "or hostname expected");
					free(h);
					free(p);
					free($3->name);
					free($3->path);
					free($3);
					YYERROR;
				}
				h->next = p->addr;
				p->addr = h;
			}

			p->addr_head.a = p->addr;
			p->addr_head.pool = 0;
			p->addr_head.name = strdup($3->name);
			p->addr_head.path = strdup($3->path);
			if (p->addr_head.name == NULL ||
			    p->addr_head.path == NULL)
				fatal(NULL);
			if (p->addr != NULL)
				p->state = STATE_DNS_DONE;
			constraint_add(p);
			free($3->name);
			free($3);
		}
		| SENSOR STRING	sensor_opts {
			struct ntp_conf_sensor	*s;

			s = new_sensor($2);
			s->weight = $3.weight;
			s->correction = $3.correction;
			s->refstr = $3.refstr;
			s->stratum = $3.stratum;
			free($2);
			TAILQ_INSERT_TAIL(&conf->ntp_conf_sensors, s, entry);
		}
		;

address		: STRING		{
			if (($$ = calloc(1, sizeof(struct ntp_addr_wrap))) ==
			    NULL)
				fatal(NULL);
			host($1, &$$->a);
			$$->name = $1;
		}
		;

url		: STRING		{
			char	*hname, *path;

			if (($$ = calloc(1, sizeof(struct ntp_addr_wrap))) ==
			    NULL)
				fatal("calloc");

			if (strncmp("https://", $1,
			    strlen("https://")) != 0) {
				host($1, &$$->a);
				$$->name = $1;
			} else {
				hname = $1 + strlen("https://");

				path = hname + strcspn(hname, "/\\");
				if (*path != '\0') {
					if (($$->path = strdup(path)) == NULL)
						fatal("strdup");
					*path = '\0';
				}
				host(hname, &$$->a);
				if (($$->name = strdup(hname)) == NULL)
					fatal("strdup");
			}
			if ($$->path == NULL &&
			    ($$->path = strdup("/")) == NULL)
				fatal("strdup");
		}
		;

listen_opts	:	{ opts_default(); }
		  listen_opts_l
			{ $$ = opts; }
		|	{ opts_default(); $$ = opts; }
		;
listen_opts_l	: listen_opts_l listen_opt
		| listen_opt
		;
listen_opt	: rtable
		;

server_opts	:	{ opts_default(); }
		  server_opts_l
			{ $$ = opts; }
		|	{ opts_default(); $$ = opts; }
		;
server_opts_l	: server_opts_l server_opt
		| server_opt
		;
server_opt	: weight
		;

sensor_opts	:	{ opts_default(); }
		  sensor_opts_l
			{ $$ = opts; }
		|	{ opts_default(); $$ = opts; }
		;
sensor_opts_l	: sensor_opts_l sensor_opt
		| sensor_opt
		;
sensor_opt	: correction
		| refid
		| stratum
		| weight
		;

correction	: CORRECTION NUMBER {
			if ($2 < -127000000 || $2 > 127000000) {
				yyerror("correction must be between "
				    "-127000000 and 127000000 microseconds");
				YYERROR;
			}
			opts.correction = $2;
		}
		;

refid		: REFID STRING {
			size_t l = strlen($2);

			if (l < 1 || l > 4) {
				yyerror("refid must be 1 to 4 characters");
				free($2);
				YYERROR;
			}
			opts.refstr = $2;
		}
		;

stratum		: STRATUM NUMBER {
			if ($2 < 1 || $2 > 15) {
				yyerror("stratum must be between "
				    "1 and 15");
				YYERROR;
			}
			opts.stratum = $2;
		}
		;

weight		: WEIGHT NUMBER	{
			if ($2 < 1 || $2 > 10) {
				yyerror("weight must be between 1 and 10");
				YYERROR;
			}
			opts.weight = $2;
		}
rtable		: RTABLE NUMBER {
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("rtable must be between 1"
				    " and RT_TABLEID_MAX");
				YYERROR;
			}
			opts.rtable = $2;
		}
		;

%%

void
opts_default(void)
{
	memset(&opts, 0, sizeof opts);
	opts.weight = 1;
	opts.stratum = 1;
}

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	log_warnx("%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "constraint",		CONSTRAINT},
		{ "constraints",	CONSTRAINTS},
		{ "correction",		CORRECTION},
		{ "from",		FROM},
		{ "listen",		LISTEN},
		{ "on",			ON},
		{ "query",		QUERY},
		{ "refid",		REFID},
		{ "rtable",		RTABLE},
		{ "sensor",		SENSOR},
		{ "server",		SERVER},
		{ "servers",		SERVERS},
		{ "stratum",		STRATUM},
		{ "weight",		WEIGHT}
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p;
	int	 quotec, next, c;
	int	 token;

	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			fatal("yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '/' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_' || c == '*') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				fatal("yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

struct file *
pushfile(const char *name)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("malloc");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

int
parse_config(const char *filename, struct ntpd_conf *xconf)
{
	int		 errors = 0;

	conf = xconf;
	TAILQ_INIT(&conf->listen_addrs);
	TAILQ_INIT(&conf->ntp_peers);
	TAILQ_INIT(&conf->ntp_conf_sensors);
	TAILQ_INIT(&conf->constraints);

	if ((file = pushfile(filename)) == NULL) {
		return (-1);
	}
	topfile = file;

	yyparse();
	errors = file->errors;
	popfile();

	return (errors ? -1 : 0);
}
@


1.65
log
@fully revert some parts introduced with the original server rtable support,
so servers with numeric IP addresses won't be skipped; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.64 2015/10/23 14:52:20 phessler Exp $ */
d61 2
d85 1
a85 1
%token	LISTEN ON CONSTRAINT CONSTRAINTS FROM
d135 22
d180 2
d219 2
d492 1
@


1.64
log
@Allowing upstream servers of ntp being in multiple routing tables is
non-sensical.  The dns lookups happened in the process routing table
(usually '0'), which is very likely to have different results from the
other routing domains.  If you do depend on having this behaviour,
you'll need to use pf to cross the rtable boundary.

"listen on * rtable X" is still supported.

Users of "server * rtable X" will need to switch to launching ntpd with
"route -T X exec /usr/sbin/ntpd"

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.63 2015/07/18 00:53:44 bcook Exp $ */
d164 1
a164 3
				if (!(p->addr))
					TAILQ_INSERT_TAIL(&conf->ntp_peers,
					    p, entry);
d200 1
a200 2
			if (!(p->addr))
				TAILQ_INSERT_TAIL(&conf->ntp_peers, p, entry);
@


1.63
log
@replace bzero with memset

ok phessler@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2015/05/17 18:31:32 reyk Exp $ */
a108 2
			if ($3->a)
				$3->a->rtable = $4.rtable;
a155 1
				p->rtable = $3.rtable;
d164 1
a164 1
				if (!(p->rtable > 0 && p->addr))
a194 1
			p->rtable = $3.rtable;
d202 1
a202 1
			if (!(p->rtable > 0 && p->addr))
a353 1
		| rtable
a425 1
	opts.rtable = -1;
@


1.62
log
@When resolving the "constraint" (singular), store all returned IP
addresses and try one after another until the connection succeeded -
based on the existing mechanism of "server".  "constraint" previously
only tried to connect to the first returned address, aborted and
skipped the constraint on failure.  In difference to "constraints"
(plural), it still only connects to one address at a time and not to
all of them at once.

Pointed out by rpe@@
OK rpe@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.61 2015/02/12 23:07:52 reyk Exp $ */
d429 1
a429 1
	bzero(&opts, sizeof opts);
@


1.61
log
@Allow constraints URL without leading path (eg. "https://www.openbsd.org").
Fixes segfault on configuration load time, as reported by Donovan Watteau.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2015/02/12 01:54:57 reyk Exp $ */
d244 1
a244 2
				TAILQ_INSERT_TAIL(&conf->constraints,
				    p, entry);
d253 1
a253 1
			struct ntp_addr		*h;
d256 2
a257 1
			if ((h = $3->a) != NULL) {
d269 1
a270 1
				host_dns_free(h->next);
d282 1
a282 1
			TAILQ_INSERT_TAIL(&conf->constraints, p, entry);
@


1.60
log
@Use ntpd's deferred DNS resolving for constraints as well.  This
allows to get constraint addresses even if network/DNS is not
available at startup (or system boot).

thumbs up & OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2015/02/10 11:46:39 reyk Exp $ */
a318 2
				if (($$->path = strdup("/")) == NULL)
					fatal("strdup");
d323 5
a327 5
				if (*path == '\0')
					path = "/";
				if (($$->path = strdup(path)) == NULL)
					fatal("strdup");
				*path = '\0';
d332 3
@


1.59
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2015/02/10 06:40:08 reyk Exp $ */
d254 1
a254 1
			struct ntp_addr		*h, *next;
d257 1
a257 2
			for (h = $3->a; h != NULL; h = next) {
				next = h->next;
a268 1
				h->next = p->addr;
d270 1
a332 10
			}

			if ($$->a == NULL &&
			    (host_dns($$->name, &$$->a) == -1 ||
			    $$->a == NULL)) {
				yyerror("could not resolve \"%s\"", $$->name);
				free($$->name);
				free($$->path);
				free($$);
				YYERROR;
@


1.58
log
@Add support for "constraints": when configured, ntpd(8) will query the
time from HTTPS servers, by parsing the Date: header, and use the
median constraint time as a boundary to verify NTP responses.  This
adds some level of authentication and protection against MITM attacks
while preserving the accuracy of the NTP protocol; without relying on
authentication options for NTP that are basically unavailable at
present.  This is an initial implementation and the semantics will be
improved once it is in the tree.

Discussed with deraadt@@ and henning@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2015/01/10 13:47:05 tedu Exp $ */
d426 2
a427 1
				yyerror("rtable must be between 1 and RT_TABLEID_MAX");
@


1.57
log
@don't check for a return value that host() doesn't return, so future
generations don't try to change any of the values and break the code.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2015/01/08 00:30:08 bcook Exp $ */
d83 1
a83 1
%token	LISTEN ON
d88 1
a88 1
%type	<v.addr>		address
d211 76
d309 39
d476 2
d479 1
d767 1
@


1.56
log
@sync log.c from smtpd.

Reduces the number of log.c snowflakes by a little, and gives ntpd a
variadic fatal() function to be used later.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2014/11/20 05:51:20 jsg Exp $ */
d228 1
a228 7
			if (host($1, &$$->a) == -1) {
				yyerror("could not parse address spec \"%s\"",
				    $1);
				free($1);
				free($$);
				YYERROR;
			}
@


1.55
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2014/11/14 03:20:37 doug Exp $ */
d351 1
a351 1
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
@


1.54
log
@Add gcc printf format attributes to yyerror() in parse.y files.
No yyerror() calls needed to be changed.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2014/11/03 20:15:31 bluhm Exp $ */
d523 3
@


1.53
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2013/11/25 12:58:42 benno Exp $ */
d51 3
a53 1
int		 yyerror(const char *, ...);
@


1.52
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2013/10/21 08:48:22 phessler Exp $ */
d342 1
a342 1
	char		*nfmt;
d346 2
a347 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d349 2
a350 1
	free(nfmt);
@


1.51
log
@remove the IPv4-only check for rdomains, allows IPv6 to use them

OK claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2012/09/20 12:43:16 patrick Exp $ */
d389 1
a389 1
char	*parsebuf;
d391 1
a391 1
char	 pushback_buffer[MAXPUSHBACK];
d484 2
a485 2
	char	 buf[8096];
	char	*p;
d526 1
a526 1
			*p++ = (char)c;
@


1.50
log
@Allow ntpd.conf to assign a stratum to a sensor with the syntax stratum <level>.

OK markus@@ henning@@ phessler@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2011/12/28 19:32:34 phessler Exp $ */
d165 1
a165 2
				if (!(p->rtable > 0 && p->addr &&
				    p->addr->ss.ss_family != AF_INET))
d204 1
a204 2
			if (!(p->rtable > 0 && p->addr &&
			    p->addr->ss.ss_family != AF_INET))
@


1.49
log
@only add the rdomain for hostname lookups, when we have a hostname to lookup.

noticed by zepard at gmail

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2011/09/21 15:41:30 phessler Exp $ */
d63 1
d82 1
a82 1
%token	SERVER SERVERS SENSOR CORRECTION RTABLE REFID WEIGHT
d93 1
d218 1
d272 1
d298 10
d332 1
d375 1
@


1.48
log
@Add rdomain support to NTPd.

This basically adds the "rtable %d" keyword to "listen on", "server",
"servers" keywords, to specify which routing table to use.

OK henning@@ claudio@@ sthen@@
manpage reviewed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2010/08/03 18:42:40 henning Exp $ */
d105 3
a107 1
			if ((h = $3->a) == NULL && (h->rtable = $4.rtable) &&
@


1.47
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2009/03/31 21:03:48 tobias Exp $ */
d63 1
d81 1
a81 1
%token	SERVER SERVERS SENSOR CORRECTION REFID WEIGHT
d86 1
d90 1
d101 1
a101 1
main		: LISTEN ON address	{
d105 1
a105 1
			if ((h = $3->a) == NULL &&
a114 5
				if (h->ss.ss_family == AF_UNSPEC) {
					conf->listen_all = 1;
					free(h);
					continue;
				}
d119 1
d152 1
d161 4
a164 2
				TAILQ_INSERT_TAIL(&conf->ntp_peers, p, entry);

d193 1
d201 3
a203 1
			TAILQ_INSERT_TAIL(&conf->ntp_peers, p, entry);
d234 11
d254 1
d299 7
d315 1
d354 1
@


1.46
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2008/10/17 14:32:47 henning Exp $ */
d471 2
a472 1
				else if (next == '\n')
d474 1
a474 1
				else
@


1.45
log
@bring in findeol() fix from pfctl
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2008/06/09 18:26:35 deraadt Exp $ */
d562 1
a562 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d564 5
@


1.44
log
@do not leak memory on failure in refid production; ok ckuethe henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2008/06/09 16:37:35 ckuethe Exp $ */
a421 1
	pushback_index = 0;
d425 4
a428 1
		c = lgetc(0);
@


1.43
log
@Allow outgoing replies from sensor-driven servers to have a
user-configurable reference ID, eg. "GPS" or "DCF"...
ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2008/02/26 10:09:58 mpf Exp $ */
d264 2
a265 2
			size_t l;
			l = strlen($2);
d267 2
a268 2
				yyerror("refid must be a string of 1 to 4 "
					"characters");
@


1.42
log
@Have popfile() also close the main config file,
but only do the final popfile call after yyparse() is done.
This also fixes config reload on SIGHUP for some daemons.

Spotted by otto@@. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2007/11/12 23:59:41 mpf Exp $ */
d63 1
d80 1
a80 1
%token	SERVER SERVERS SENSOR CORRECTION WEIGHT
d88 1
d208 1
d249 1
d263 12
d328 1
@


1.41
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2007/10/20 14:24:02 pyr Exp $ */
d46 1
a46 1
} *file;
d356 3
a358 2
			yyerror("reached end of file while parsing quoted string");
			if (popfile() == EOF)
d376 1
a376 1
		if (popfile() == EOF)
d564 1
a564 1
	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
d566 7
a572 8
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
d588 1
@


1.40
log
@ntpd and bgpd's turn to behave like the others.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2007/10/16 20:01:23 mpf Exp $ */
a372 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d428 1
a428 1
	while ((c = lgetc(0)) == ' ')
@


1.39
log
@Allow '=' to end a number in all lexers.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2007/10/16 06:06:49 deraadt Exp $ */
d551 2
a552 1
	    (nfile->name = strdup(name)) == NULL)
d554 1
d556 1
a593 1
		log_warn("%s", filename);
@


1.38
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2007/10/13 16:35:21 deraadt Exp $ */
d480 1
a480 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.37
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2007/09/14 06:29:54 deraadt Exp $ */
d457 1
a457 1
				if (next == quotec)
d459 2
@


1.36
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d39 20
a58 14
static struct ntpd_conf		*conf;
static FILE			*fin = NULL;
static int			 lineno = 1;
static int			 errors = 0;
const char			*infile;

int	 yyerror(const char *, ...);
int	 yyparse(void);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(int);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);
d68 1
a68 1
		int64_t		 	number;
d71 1
a71 1
		struct opts		opts;
d92 2
a93 2
		| grammar conf_main '\n'
		| grammar error '\n'		{ errors++; }
d96 1
a96 1
conf_main	: LISTEN ON address	{
d288 1
a288 1
	errors = 1;
d290 1
a290 1
	if (asprintf(&nfmt, "%s:%d: %s", infile, yylval.lineno, fmt) == -1)
d336 1
a336 1
lgetc(int inquot)
d338 1
a338 2
	int	c, next;
	FILE *f = fin;
d354 7
a360 2
	if (inquot) {
		c = getc(f);
d364 2
a365 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d370 2
a371 2
		yylval.lineno = lineno;
		lineno++;
d376 1
a376 1
			c = getc(f);
d378 1
a378 1
		ungetc(c, f);
d382 5
d418 1
a418 1
			lineno++;
d432 1
a432 1
	int	 endc, next, c;
d439 1
a439 1
	yylval.lineno = lineno;
d447 1
a447 1
		endc = c;
d449 1
a449 1
			if ((c = lgetc(1)) == EOF)
d452 1
a452 1
				lineno++;
d455 1
a455 1
				if ((next = lgetc(1)) == EOF)
d457 1
a457 1
				if (next == endc)
d461 1
a461 1
			} else if (c == endc) {
d535 2
a536 2
		yylval.lineno = lineno;
		lineno++;
d543 35
d581 2
a583 2
	lineno = 1;
	errors = 0;
d588 1
a588 1
	if ((fin = fopen(filename, "r")) == NULL) {
a591 1
	infile = filename;
d594 2
a595 2

	fclose(fin);
@


1.35
log
@use a setup function for options, cleaner; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2007/09/14 03:07:11 ckuethe Exp $ */
d49 1
a49 1
int	 lgetc(FILE *);
d330 1
a330 1
lgetc(FILE *f)
d333 1
d349 5
d401 1
a401 1
		c = lgetc(fin);
d417 1
a417 1
	int	 endc, c;
d421 1
a421 1
	while ((c = lgetc(fin)) == ' ')
d426 1
a426 1
		while ((c = lgetc(fin)) != '\n' && c != EOF)
d434 1
a434 1
			if ((c = lgetc(fin)) == EOF)
a435 4
			if (c == endc) {
				*p = '\0';
				break;
			}
d439 10
d472 1
a472 1
		} while ((c = lgetc(fin)) != EOF && isdigit(c));
d511 1
a511 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
@


1.34
log
@Correctly assign a default weight of 1 to sensors and servers.
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2007/09/12 21:08:46 ckuethe Exp $ */
d58 1
d220 1
a220 1
server_opts	:	{ bzero(&opts, sizeof opts); opts.weight = 1; }
d223 1
a223 1
		|	{ bzero(&opts, sizeof opts); opts.weight = 1; $$ = opts; }
d231 1
a231 1
sensor_opts	:	{ bzero(&opts, sizeof opts); opts.weight = 1; }
d234 1
a234 1
		|	{ bzero(&opts, sizeof opts); opts.weight = 1; $$ = opts; }
d263 7
@


1.33
log
@
Add a knob to compensate for a refclock that is early or late. Based on a
diff from Maurice Janssen. Manpage help from jmc and Maurice, other nits
from deraadt and otto.
ok deraadt, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2007/09/12 18:32:54 deraadt Exp $ */
d222 1
a222 1
		|	{ bzero(&opts, sizeof opts); $$ = opts; }
d233 1
a233 1
		|	{ bzero(&opts, sizeof opts); $$ = opts; }
@


1.32
log
@default weight has to remain 1; seen by Maurice Janssen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2007/09/11 23:33:37 deraadt Exp $ */
d56 1
d72 1
a72 1
%token	SERVER SERVERS SENSOR WEIGHT
d79 1
d198 1
d238 12
a249 1
sensor_opt	: weight
d295 1
@


1.31
log
@this is where it all started, since future ntpd.conf commands will require
negative parameters.  extend lex to spot numbers in the stream.  as well,
make it easier to add parameters on command line in any order later
ok otto ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2006/10/03 00:49:09 deraadt Exp $ */
d216 1
a216 1
server_opts	:	{ bzero(&opts, sizeof opts); }
d227 1
a227 1
sensor_opts	:	{ bzero(&opts, sizeof opts); }
@


1.30
log
@strtonum() with INT_MAX intead of LONG_MAX, problem pointed out by pierre-yves@@spootnik.org
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2006/06/01 06:06:59 otto Exp $ */
d54 4
d60 1
a60 1
		u_int32_t		 number;
d63 1
d74 1
d76 3
a78 1
%type	<v.number>		number weight
d119 1
a119 1
		| SERVERS address weight	{
d141 1
a141 1
				p->weight = $3;
d158 1
a158 1
		| SERVER address weight	{
d179 1
a179 1
			p->weight = $3;
d191 1
a191 1
		| SENSOR STRING	weight {
d195 1
a195 1
			s->weight = $3;
d216 10
a225 3
number		: STRING			{
			u_long		 ulval;
			const char	*errstr;
d227 9
a235 9
			ulval = strtonum($1, 0, INT_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid: %s", $1, errstr);
				free($1);
				YYERROR;
			} else
				$$ = ulval;
			free($1);
		}
d238 1
a238 2
weight		: /* empty */	{ $$ = 1; }
		| WEIGHT number	{
d243 1
a243 1
			$$ = $2;
d425 36
@


1.29
log
@even though the bounds are long long having an upper bound of
ULONG_MAX does not work; the max upper bound is LONG_MAX,
since LONG_MAX == LLONG_MAX on 64bit archs. ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2006/05/28 20:39:16 henning Exp $ */
d212 1
a212 1
			ulval = strtonum($1, 0, LONG_MAX, &errstr);
@


1.28
log
@allow for weight to be added to sensors or servers, so that one can
weight timedelta sensors higher than ntp peers, for example
ok deraadt mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2006/05/27 17:01:07 henning Exp $ */
d33 1
d212 1
a212 1
			ulval = strtonum($1, 0, ULONG_MAX, &errstr);
@


1.27
log
@config file bits for timedelta sensors, so one can specify which devices
to use. "sensors *" just uses all. untested due to lack of hardware.
hacked on the road somewhere between vancouver and calgary
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2006/05/26 01:06:12 deraadt Exp $ */
d65 1
a65 1
%token	SERVER SERVERS SENSOR
d69 1
d110 1
a110 1
		| SERVERS address	{
d132 1
d149 1
a149 1
		| SERVER address	{
d170 1
d182 1
a182 1
		| SENSOR STRING	{
d186 1
d207 25
d270 2
a271 1
		{ "servers",		SERVERS}
@


1.26
log
@\<char> is <char> except for \<newline> -- no exceptions.  much like how
other things work.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2005/06/19 16:42:57 henning Exp $ */
d65 1
a65 1
%token	SERVER SERVERS
d179 7
d239 1
d420 1
@


1.25
log
@use a little state engine to keep track of delayed dns lookups and such,
eases things
tested by Jason Ackley <jason@@ackley.net> Matthias Kilian
<kili@@outback.escape.de> Stephen Marley <stephen@@marley.org.uk> sturm@@
theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2004/11/25 06:27:41 henning Exp $ */
d275 1
a275 3
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, f);
@


1.24
log
@fix "listen on hostname"
fallout from the deferred dns lookups
noticed by dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2004/11/10 11:27:54 henning Exp $ */
d137 2
d173 2
@


1.23
log
@const'ify conffile
From: Joerg Sonnenberger <joerg@@britannica.bec.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2004/11/05 14:28:29 henning Exp $ */
d81 3
a83 2
			if ($3->a == NULL) {
				yyerror("cannot resolve \"%s\"", $3->name);
d89 1
a89 1
			for (h = $3->a; h != NULL; h = next) {
@


1.22
log
@memleaks in error pathes, patrick latifi, Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2004/09/15 00:23:08 henning Exp $ */
d42 1
a42 1
char				*infile;
d402 1
a402 1
parse_config(char *filename, struct ntpd_conf *xconf)
@


1.21
log
@kill another unused function and two debugging printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2004/09/15 00:18:12 henning Exp $ */
d120 1
d155 2
d184 1
@


1.20
log
@remove the unused variable/macro code, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2004/08/10 12:45:27 henning Exp $ */
a41 1
static int			 pdebug = 1;
a51 1
int	 atoul(char *, u_long *);
d231 1
a231 3
	if (p) {
		if (pdebug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
d233 1
a233 3
	} else {
		if (pdebug > 1)
			fprintf(stderr, "string: %s\n", s);
a234 1
	}
a416 16
}

int
atoul(char *s, u_long *ulvalp)
{
	u_long	 ulval;
	char	*ep;

	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
		return (-1);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (-1);
	*ulvalp = ulval;
	return (0);
@


1.19
log
@in the pool case ("servers somepool.somewhere"), we add new peers while
looping over the addresses returned by the dns lookup, as each address
is one new peer.
however, if the lookup fails with a temporary error, we will try to lookup
later again. for that, we obviously need to insert one peer with the
hostname in addr_head... change one for() loop into a do { } while() one
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2004/08/10 12:41:15 henning Exp $ */
a52 12

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entries;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};

int	 symset(const char *, const char *, int);
char	*symget(const char *);
a69 2
%type	<v.number>		number
%type	<v.string>		string
a75 1
		| grammar varset '\n'
a78 32
number		: STRING			{
			u_long	ulval;

			if (atoul($1, &ulval) == -1) {
				yyerror("\"%s\" is not a number", $1);
				free($1);
				YYERROR;
			} else
				$$ = ulval;
			free($1);
		}
		;

string		: string STRING				{
			if (asprintf(&$$, "%s %s", $1, $2) == -1)
				fatal("string: asprintf");
			free($1);
			free($2);
		}
		| STRING
		;

varset		: STRING '=' string		{
			if (conf->opts & NTPD_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

d334 1
a334 1
	char	*p, *val;
a337 1
top:
a345 26
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(fin)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = (char)c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro \"%s\" not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}
a406 2
	struct sym		*sym, *next;

a422 14
	/* Free macros and check which have not been used. */
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entries);
		if ((conf->opts & NTPD_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro \"%s\" not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entries);
			free(sym);
		}
	}

a423 74
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entries))
		;	/* nothing */

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entries);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		fatal("cmdline_symset: malloc");

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entries)
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	return (NULL);
@


1.18
log
@move memory allocation for new peers into a new function, makes ID allocation
easier
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2004/07/29 11:01:48 henning Exp $ */
d161 16
a176 10
			for (h = $2->a; h != NULL; h = next) {
				next = h->next;
				if (h->ss.ss_family != AF_INET &&
				    h->ss.ss_family != AF_INET6) {
					yyerror("IPv4 or IPv6 address "
					    "or hostname expected");
					free($2->name);
					free($2);
					YYERROR;
				}
a177 1
				h->next = NULL;
d185 4
a188 1
			}
@


1.17
log
@keep an ID per server we talk to
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2004/07/28 16:56:21 henning Exp $ */
a43 1
static u_int32_t		 maxid;
d171 1
a171 4
				p = calloc(1, sizeof(struct ntp_peer));
				if (p == NULL)
					fatal("conf_main server calloc");
				p->id = ++maxid;
d188 1
a188 3
			if ((p = calloc(1, sizeof(struct ntp_peer))) == NULL)
				fatal("conf_main server calloc");
			p->id = ++maxid;
a477 1
	maxid = 0;
@


1.16
log
@prevent unresolvable hostnames in "listen on" statements
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2004/07/28 16:38:43 henning Exp $ */
d44 1
d175 1
d194 1
d484 1
@


1.15
log
@when a dns lookup fails at parse time, do not abort but try again
to resolve the hostname every 60 seconds
fixes ntpd invocations before e. g. a dialup link is established and such.
as we want ntpd to be a "fire and forget" background daemon it should
cope with such situations.
tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2004/07/21 09:40:55 henning Exp $ */
d129 7
@


1.14
log
@no multiple free(); "John L. Scarfone" <j0@@cox.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2004/07/20 16:47:55 henning Exp $ */
d214 1
a214 1
			if (($$->a = host($1)) == NULL) {
@


1.13
log
@wrap the heads for the linked list of addresses into a new ntp_addr_wrap
which, besides the head pointer for the list of course, stores the original
address as specified (i. e. as hostname instead of resolved IPs) and flags
and such.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2004/07/12 09:22:38 dtucker Exp $ */
a174 2
				free($2->name);
				free($2);
d176 2
@


1.12
log
@Replace errx with equivalent fprintf+exit to make porting easier; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2004/07/09 19:28:03 otto Exp $ */
d71 1
a71 1
		struct ntp_addr		*addr;
d130 1
a130 1
			for (h = $3; h != NULL; h = next) {
d147 2
d154 1
a154 1
			for (h = $2; h != NULL; h = next) {
d160 2
d169 5
a173 1
				p->addr_head = h;
d175 2
d185 1
a185 1
			for (h = $2; h != NULL; h = next) {
d191 2
d199 5
a203 1
			p->addr_head = p->addr;
d205 2
d211 4
a214 1
			if (($$ = host($1)) == NULL) {
d220 1
a220 1
			free($1);
@


1.11
log
@Do not forget to initialize head. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2004/07/09 10:53:33 henning Exp $ */
a28 1
#include <err.h>
@


1.10
log
@rework dns handling with all its cosequences...
we know have both a "server" and "servers" keyword. they differ when the
hostname resolves to more than one IP, server picks one and servers expands
to all.
that means no longer stuffing a sockaddr_storage into ntp_peer but a pointer
to a linked list of ntp_addr structs.
in the "servers" case the list of n addresses returned by host() is expanded
into n ntp_peer structs and thus n individual peers.
in the "server" case the whole list is attached to ntp_peer, and whenever we
do not receive a reply in time we traverse the list one further, so that
hosts with both AAAA and A records are first tried with the AAAA one but
we gracefully fall back to the A one.
semantics with theo; hacked up on the Montreal->Frankfurt flight.
again Air Canada surprised me, that older 767 hat pretty decent seats.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2004/07/08 15:06:43 henning Exp $ */
d166 1
@


1.9
log
@kill traces of on-the-fly reconfigure (from bgpd), not needed in ntpd
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2004/07/08 01:22:57 henning Exp $ */
d80 1
a80 1
%token	SERVER
d149 1
a149 1
		| SERVER address	{
d164 2
a165 2
				memcpy(&p->ss, &h->ss,
				    sizeof(struct sockaddr_storage));
a166 1
				free(h);
d169 21
d239 2
a240 1
		{ "server",		SERVER}
a457 1
		free(conf);
@


1.8
log
@remove all handling of netmasks/prefix lengths - we don't need that in ntpd.
fixes the dns resolves to v4 and v6 addresses bug found by phessler
hacked on the Calgary->Montreal flight that proved that Air Canada _does_
have some modern aircrafts with good seats
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2004/07/07 06:51:16 deraadt Exp $ */
a427 2
	struct listen_addr	*la;
	struct ntp_peer		*p;
d429 1
a429 2
	if ((conf = calloc(1, sizeof(struct ntpd_conf))) == NULL)
		fatal(NULL);
a458 24

	while ((la = TAILQ_FIRST(&xconf->listen_addrs)) != NULL) {
		TAILQ_REMOVE(&xconf->listen_addrs, la, entry);
		free(la);
	}

	while ((la = TAILQ_FIRST(&conf->listen_addrs)) != NULL) {
		TAILQ_REMOVE(&conf->listen_addrs, la, entry);
		TAILQ_INSERT_TAIL(&xconf->listen_addrs, la, entry);
	}

	while ((p = TAILQ_FIRST(&xconf->ntp_peers)) != NULL) {
		TAILQ_REMOVE(&xconf->ntp_peers, p, entry);
		free(p);
	}

	while ((p = TAILQ_FIRST(&conf->ntp_peers)) != NULL) {
		TAILQ_REMOVE(&conf->ntp_peers, p, entry);
		TAILQ_INSERT_TAIL(&xconf->ntp_peers, p, entry);
	}

	xconf->listen_all = conf->listen_all;

	free(conf);
@


1.7
log
@knf!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2004/07/07 05:47:57 henning Exp $ */
d173 1
a173 4
			u_int8_t	 len;
			struct ntp_addr	*h;

			if (($$ = host($1, &len)) == NULL) {
a179 11

			for (h = $$; h != NULL; h = h->next)
				if ((h->ss.ss_family == AF_INET && len != 32) ||
				    (h->ss.ss_family == AF_INET6 && len != 128))
				    {
					/* unreachable */
					yyerror("got prefixlen %u, expected %u",
					    len, h->ss.ss_family ==
					    AF_INET ? 32 : 128);
					YYERROR;
				}
@


1.6
log
@do not listen anywhere by default.
listen on *
listens, well, everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2004/07/07 03:15:37 henning Exp $ */
d152 1
a152 1
			
@


1.5
log
@swicth all the host_* functions to work on a newly invented
struct ntp_addr, which just wraps a sockaddr_storage and a next pointer,
so that host_dns can return more than one entry.
let host_dns do exactly that, return a list of all IPs for that hostname
adjust all callers in the grammar to cope with that
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2004/07/06 23:08:26 henning Exp $ */
d127 1
a127 1
conf_main	:  LISTEN ON address	{
d133 5
d152 2
a153 2

			for (h = $2; h != NULL; h = next) {			
d155 6
d496 2
@


1.4
log
@sizeof(wrong struct) in calloc == bad. ^$&(#^$%&#*)!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2004/07/05 07:57:52 henning Exp $ */
d72 1
a72 1
		struct sockaddr_storage	 ss;
d85 1
a85 1
%type	<v.ss>			address
d129 1
d131 12
a142 7
			if ((la = calloc(1, sizeof(struct listen_addr))) ==
			    NULL)
				fatal("parse conf_main listen on calloc");

			la->fd = -1;
			memcpy(&la->sa, &$3, sizeof(struct sockaddr_storage));
			TAILQ_INSERT_TAIL(&conf->listen_addrs, la, entry);
d146 1
d148 10
a157 4
			if ((p = calloc(1, sizeof(struct ntp_peer))) == NULL)
				fatal("parse conf_main server on calloc");
			memcpy(&p->ss, &$2, sizeof(struct sockaddr_storage));
			TAILQ_INSERT_TAIL(&conf->ntp_peers, p, entry);
d162 2
a163 1
			u_int8_t	len;
d165 1
a165 2
			bzero(&$$, sizeof($$));
			if (!host($1, (struct sockaddr *)&$$, &len)) {
d173 10
a182 7
			if (($$.ss_family == AF_INET && len != 32) ||
			    ($$.ss_family == AF_INET6 && len != 128)) {
				/* unreachable */
				yyerror("got prefixlen %u, expected %u",
				    len, $$.ss_family == AF_INET ? 32 : 128);
				YYERROR;
			}
@


1.3
log
@don't limit to one remote server any more
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2004/06/17 19:17:48 henning Exp $ */
d141 2
a142 2
			if ((p = calloc(1, sizeof(struct listen_addr))) == NULL)
				fatal("parse conf_mail server on calloc");
@


1.2
log
@provide most of the client functionality.
hook the descriptors into the main poll and such.
we're not doing anything with the reply we recive yet, tho.

mostly hacked on the Frankfurt->Montreal flight, as batteries and those
horrible air canada seats permitted...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2004/06/01 21:58:09 henning Exp $ */
a140 5
			if (!TAILQ_EMPTY(&conf->ntp_peers)) {
				yyerror("king bula sez: only on remote server "
				    "supported for now");
				YYERROR;
			}
@


1.1
log
@first cut at config file parser
for now, one can set the addresses to listen on
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.112 2004/05/21 15:36:40 claudio Exp $ */
d80 1
d134 1
d138 13
d210 2
a211 1
		{ "on",			ON}
d421 1
d428 1
d463 10
@

