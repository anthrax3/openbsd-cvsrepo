head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.2
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.20
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.16
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.14
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.12
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.10
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.12
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.10
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.08.14.22.29.01;	author krw;	state Exp;
branches;
next	1.15;
commitid	chIZqPw4f7B1HyFB;

1.15
date	2015.11.17.17.15.33;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	dmuoyMzIXhF1nb8D;

1.14
date	2015.07.26.22.16.43;	author chl;	state Exp;
branches;
next	1.13;
commitid	683pq1Pn0vUCnLJB;

1.13
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	6b2lLILbgCR1fvia;

1.12
date	2013.11.24.01.06.19;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.04.09.02.54;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.30.18.47.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.30.18.43.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.28.09;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.27.20.34.36;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.10.15.33.15;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	99.05.24.21.24.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.12.18.20.47.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.41.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Flip 'u_quad_t' fields & variables to uint64_t, and %qu to %llu.

ok guenther@@
@
text
@/*	$OpenBSD: main.c,v 1.15 2015/11/17 17:15:33 deraadt Exp $	*/
/*
 * Copyright (c) 1994 Christopher G. Demetriou
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * sa:	system accounting
 */

#include <sys/types.h>
#include <sys/acct.h>
#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "extern.h"
#include "pathnames.h"

static int	acct_load(char *, int);
static uint64_t	decode_comp_t(comp_t);
static int	cmp_comm(const char *, const char *);
static int	cmp_usrsys(const DBT *, const DBT *);
static int	cmp_avgusrsys(const DBT *, const DBT *);
static int	cmp_dkio(const DBT *, const DBT *);
static int	cmp_avgdkio(const DBT *, const DBT *);
static int	cmp_cpumem(const DBT *, const DBT *);
static int	cmp_avgcpumem(const DBT *, const DBT *);
static int	cmp_calls(const DBT *, const DBT *);

int aflag, bflag, cflag, dflag, Dflag, fflag, iflag, jflag, kflag;
int Kflag, lflag, mflag, qflag, rflag, sflag, tflag, uflag, vflag;
int cutoff = 1;

static char	*dfltargv[] = { _PATH_ACCT };
static int	dfltargc = (sizeof(dfltargv)/sizeof(char *));

/* default to comparing by sum of user + system time */
cmpf_t   sa_cmp = cmp_usrsys;

int
main(int argc, char **argv)
{
	int ch;
	int error = 0;
	const char *errstr;
	extern char *__progname;

	if (pledge("stdio rpath wpath cpath getpw flock", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "abcdDfijkKlmnqrstuv:")) != -1)
		switch (ch) {
		case 'a':
			/* print all commands */
			aflag = 1;
			break;
		case 'b':
			/* sort by per-call user/system time average */
			bflag = 1;
			sa_cmp = cmp_avgusrsys;
			break;
		case 'c':
			/* print percentage total time */
			cflag = 1;
			break;
		case 'd':
			/* sort by averge number of disk I/O ops */
			dflag = 1;
			sa_cmp = cmp_avgdkio;
			break;
		case 'D':
			/* print and sort by total disk I/O ops */
			Dflag = 1;
			sa_cmp = cmp_dkio;
			break;
		case 'f':
			/* force no interactive threshold comprison */
			fflag = 1;
			break;
		case 'i':
			/* do not read in summary file */
			iflag = 1;
			break;
		case 'j':
			/* instead of total minutes, give sec/call */
			jflag = 1;
			break;
		case 'k':
			/* sort by cpu-time average memory usage */
			kflag = 1;
			sa_cmp = cmp_avgcpumem;
			break;
		case 'K':
			/* print and sort by cpu-storage integral */
			sa_cmp = cmp_cpumem;
			Kflag = 1;
			break;
		case 'l':
			/* separate system and user time */
			lflag = 1;
			break;
		case 'm':
			/* print procs and time per-user */
			mflag = 1;
			break;
		case 'n':
			/* sort by number of calls */
			sa_cmp = cmp_calls;
			break;
		case 'q':
			/* quiet; error messages only */
			qflag = 1;
			break;
		case 'r':
			/* reverse order of sort */
			rflag = 1;
			break;
		case 's':
			/* merge accounting file into summaries */
			sflag = 1;
			break;
		case 't':
			/* report ratio of user and system times */
			tflag = 1;
			break;
		case 'u':
			/* first, print uid and command name */
			uflag = 1;
			break;
		case 'v':
			/* cull junk */
			vflag = 1;
			cutoff = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-v %s: %s", optarg, errstr);
			break;
		case '?':
		default:
			(void)fprintf(stderr,
			    "usage: %s [-abcDdfijKklmnqrstu] [-v cutoff]"
			    " [file ...]\n", __progname);
			exit(1);
		}

	argc -= optind;
	argv += optind;

	/* various argument checking */
	if (fflag && !vflag)
		errx(1, "only one of -f requires -v");
	if (fflag && aflag)
		errx(1, "only one of -a and -v may be specified");
	/* XXX need more argument checking */

	if (!uflag) {
		/* initialize tables */
		if ((sflag || (!mflag && !qflag)) && pacct_init() != 0)
			errx(1, "process accounting initialization failed");
		if ((sflag || (mflag && !qflag)) && usracct_init() != 0)
			errx(1, "user accounting initialization failed");
	}

	if (argc == 0) {
		argc = dfltargc;
		argv = dfltargv;
	}

	/* for each file specified */
	for (; argc > 0; argc--, argv++) {
		int	fd;

		/*
		 * load the accounting data from the file.
		 * if it fails, go on to the next file.
		 */
		fd = acct_load(argv[0], sflag);
		if (fd < 0)
			continue;

		if (!uflag && sflag) {
#ifndef DEBUG
			sigset_t nmask, omask;
			int unmask = 1;

			/*
			 * block most signals so we aren't interrupted during
			 * the update.
			 */
			if (sigfillset(&nmask) == -1) {
				warn("sigfillset");
				unmask = 0;
				error = 1;
			}
			if (unmask &&
			    (sigprocmask(SIG_BLOCK, &nmask, &omask) == -1)) {
				warn("couldn't set signal mask ");
				unmask = 0;
				error = 1;
			}
#endif /* DEBUG */

			/*
			 * truncate the accounting data file ASAP, to avoid
			 * losing data.  don't worry about errors in updating
			 * the saved stats; better to underbill than overbill,
			 * but we want every accounting record intact.
			 */
			if (ftruncate(fd, 0) == -1) {
				warn("couldn't truncate %s", *argv);
				error = 1;
			}

			/*
			 * update saved user and process accounting data.
			 * note errors for later.
			 */
			if (pacct_update() != 0 || usracct_update() != 0)
				error = 1;

#ifndef DEBUG
			/*
			 * restore signals
			 */
			if (unmask &&
			    (sigprocmask(SIG_SETMASK, &omask, NULL) == -1)) {
				warn("couldn't restore signal mask");
				error = 1;
			}
#endif /* DEBUG */
		}

		/*
		 * close the opened accounting file
		 */
		if (close(fd) == -1) {
			warn("close %s", *argv);
			error = 1;
		}
	}

	if (!uflag && !qflag) {
		/* print any results we may have obtained. */
		if (!mflag)
			pacct_print();
		else
			usracct_print();
	}

	if (!uflag) {
		/* finally, deallocate databases */
		if (sflag || (!mflag && !qflag))
			pacct_destroy();
		if (sflag || (mflag && !qflag))
			usracct_destroy();
	}

	exit(error);
}

static int
acct_load(char *pn, int wr)
{
	struct acct ac;
	struct cmdinfo ci;
	ssize_t rv;
	int fd, i;

	/*
	 * open the file
	 */
	fd = open(pn, wr ? O_RDWR : O_RDONLY, 0);
	if (fd == -1) {
		warn("open %s %s", pn, wr ? "for read/write" : "read-only");
		return (-1);
	}

	/*
	 * read all we can; don't stat and open because more processes
	 * could exit, and we'd miss them
	 */
	while (1) {
		/* get one accounting entry and punt if there's an error */
		rv = read(fd, &ac, sizeof(struct acct));
		if (rv == -1)
			warn("error reading %s", pn);
		else if (rv > 0 && rv < sizeof(struct acct))
			warnx("short read of accounting data in %s", pn);
		if (rv != sizeof(struct acct))
			break;

		/* decode it */
		ci.ci_calls = 1;
		for (i = 0; i < sizeof(ac.ac_comm) && ac.ac_comm[i] != '\0';
		    i++) {
			unsigned char c = ac.ac_comm[i];

			if (!isascii(c) || iscntrl(c)) {
				ci.ci_comm[i] = '?';
				ci.ci_flags |= CI_UNPRINTABLE;
			} else
				ci.ci_comm[i] = c;
		}
		if (ac.ac_flag & AFORK)
			ci.ci_comm[i++] = '*';
		ci.ci_comm[i++] = '\0';
		ci.ci_etime = decode_comp_t(ac.ac_etime);
		ci.ci_utime = decode_comp_t(ac.ac_utime);
		ci.ci_stime = decode_comp_t(ac.ac_stime);
		ci.ci_uid = ac.ac_uid;
		ci.ci_mem = ac.ac_mem;
		ci.ci_io = decode_comp_t(ac.ac_io) / AHZ;

		if (!uflag) {
			/* and enter it into the usracct and pacct databases */
			if (sflag || (!mflag && !qflag))
				pacct_add(&ci);
			if (sflag || (mflag && !qflag))
				usracct_add(&ci);
		} else if (!qflag)
			printf("%6u %12.2f cpu %12lluk mem %12llu io %s\n",
			    ci.ci_uid,
			    (ci.ci_utime + ci.ci_stime) / (double) AHZ,
			    ci.ci_mem, ci.ci_io, ci.ci_comm);
	}

	/* finally, return the file descriptor for possible truncation */
	return (fd);
}

static uint64_t
decode_comp_t(comp_t comp)
{
	uint64_t rv;

	/*
	 * for more info on the comp_t format, see:
	 *	/usr/src/sys/kern/kern_acct.c
	 *	/usr/src/sys/sys/acct.h
	 *	/usr/src/usr.bin/lastcomm/lastcomm.c
	 */
	rv = comp & 0x1fff;	/* 13 bit fraction */
	comp >>= 13;		/* 3 bit base-8 exponent */
	while (comp--)
		rv <<= 3;

	return (rv);
}

/* sort commands, doing the right thing in terms of reversals */
static int
cmp_comm(const char *s1, const char *s2)
{
	int rv;

	rv = strcmp(s1, s2);
	if (rv == 0)
		rv = -1;
	return (rflag ? rv : -rv);
}

/* sort by total user and system time */
static int
cmp_usrsys(const DBT *d1, const DBT *d2)
{
	struct cmdinfo c1, c2;
	uint64_t t1, t2;

	memcpy(&c1, d1->data, sizeof(c1));
	memcpy(&c2, d2->data, sizeof(c2));

	t1 = c1.ci_utime + c1.ci_stime;
	t2 = c2.ci_utime + c2.ci_stime;

	if (t1 < t2)
		return -1;
	else if (t1 == t2)
		return (cmp_comm(c1.ci_comm, c2.ci_comm));
	else
		return 1;
}

/* sort by average user and system time */
static int
cmp_avgusrsys(const DBT *d1, const DBT *d2)
{
	struct cmdinfo c1, c2;
	double t1, t2;

	memcpy(&c1, d1->data, sizeof(c1));
	memcpy(&c2, d2->data, sizeof(c2));

	t1 = c1.ci_utime + c1.ci_stime;
	t1 /= (double) (c1.ci_calls ? c1.ci_calls : 1);

	t2 = c2.ci_utime + c2.ci_stime;
	t2 /= (double) (c2.ci_calls ? c2.ci_calls : 1);

	if (t1 < t2)
		return -1;
	else if (t1 == t2)
		return (cmp_comm(c1.ci_comm, c2.ci_comm));
	else
		return 1;
}

/* sort by total number of disk I/O operations */
static int
cmp_dkio(const DBT *d1, const DBT *d2)
{
	struct cmdinfo c1, c2;

	memcpy(&c1, d1->data, sizeof(c1));
	memcpy(&c2, d2->data, sizeof(c2));

	if (c1.ci_io < c2.ci_io)
		return -1;
	else if (c1.ci_io == c2.ci_io)
		return (cmp_comm(c1.ci_comm, c2.ci_comm));
	else
		return 1;
}

/* sort by average number of disk I/O operations */
static int
cmp_avgdkio(const DBT *d1, const DBT *d2)
{
	struct cmdinfo c1, c2;
	double n1, n2;

	memcpy(&c1, d1->data, sizeof(c1));
	memcpy(&c2, d2->data, sizeof(c2));

	n1 = (double) c1.ci_io / (double) (c1.ci_calls ? c1.ci_calls : 1);
	n2 = (double) c2.ci_io / (double) (c2.ci_calls ? c2.ci_calls : 1);

	if (n1 < n2)
		return -1;
	else if (n1 == n2)
		return (cmp_comm(c1.ci_comm, c2.ci_comm));
	else
		return 1;
}

/* sort by the cpu-storage integral */
static int
cmp_cpumem(const DBT *d1, const DBT *d2)
{
	struct cmdinfo c1, c2;

	memcpy(&c1, d1->data, sizeof(c1));
	memcpy(&c2, d2->data, sizeof(c2));

	if (c1.ci_mem < c2.ci_mem)
		return -1;
	else if (c1.ci_mem == c2.ci_mem)
		return (cmp_comm(c1.ci_comm, c2.ci_comm));
	else
		return 1;
}

/* sort by the cpu-time average memory usage */
static int
cmp_avgcpumem(const DBT *d1, const DBT *d2)
{
	struct cmdinfo c1, c2;
	uint64_t t1, t2;
	double n1, n2;

	memcpy(&c1, d1->data, sizeof(c1));
	memcpy(&c2, d2->data, sizeof(c2));

	t1 = c1.ci_utime + c1.ci_stime;
	t2 = c2.ci_utime + c2.ci_stime;

	n1 = (double) c1.ci_mem / (double) (t1 ? t1 : 1);
	n2 = (double) c2.ci_mem / (double) (t2 ? t2 : 1);

	if (n1 < n2)
		return -1;
	else if (n1 == n2)
		return (cmp_comm(c1.ci_comm, c2.ci_comm));
	else
		return 1;
}

/* sort by the number of invocations */
static int
cmp_calls(const DBT *d1, const DBT *d2)
{
	struct cmdinfo c1, c2;

	memcpy(&c1, d1->data, sizeof(c1));
	memcpy(&c2, d2->data, sizeof(c2));

	if (c1.ci_calls < c2.ci_calls)
		return -1;
	else if (c1.ci_calls == c2.ci_calls)
		return (cmp_comm(c1.ci_comm, c2.ci_comm));
	else
		return 1;
}
@


1.15
log
@pledge "stdio rpath wpath cpath getpw flock".
"getpw" for user_from_uid, spotted by benno
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2015/07/26 22:16:43 chl Exp $	*/
d50 1
a50 1
static u_quad_t	decode_comp_t(comp_t);
a162 1
			/* XXX cutoff could be converted to quad_t? */
d360 1
a360 1
static u_quad_t
d363 1
a363 1
	u_quad_t rv;
d396 1
a396 1
	u_quad_t t1, t2;
d496 1
a496 1
	u_quad_t t1, t2;
@


1.14
log
@fix format string

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2015/04/18 18:28:38 deraadt Exp $	*/
d77 3
@


1.13
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2013/11/24 01:06:19 deraadt Exp $	*/
d163 1
a163 1
				errx(1, "-v $s: %s", optarg, errstr);
@


1.12
log
@more unsigned char casts for ctype
ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2009/10/27 23:59:54 deraadt Exp $	*/
d75 1
d160 4
a163 1
			cutoff = atoi(optarg);
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2005/05/04 09:02:54 jmc Exp $	*/
d319 1
a319 1
			char c = ac.ac_comm[i];
@


1.10
log
@sort options + sync usage;
add a bit of indent whilst here;
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2002/05/30 18:47:44 deraadt Exp $	*/
a30 8

#ifndef LINT
static char copright[] =
"@@(#) Copyright (c) 1994 Christopher G. Demetriou\n\
 All rights reserved.\n";

static char rcsid[] = "$Id: main.c,v 1.9 2002/05/30 18:47:44 deraadt Exp $";
#endif
@


1.9
log
@minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2002/05/30 18:43:40 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$Id: main.c,v 1.8 2002/05/30 18:43:40 deraadt Exp $";
d172 1
a172 1
			    "usage: %s [-abcdDfijkKlmnqrstu] [-v cutoff]"
@


1.8
log
@various repairs; jason@@ackley.net
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
a33 1
static char copright[] = 
d37 1
a37 1
static char rcsid[] = "$Id: main.c,v 1.7 2002/02/16 21:28:09 millert Exp $";
d171 1
a171 1
			(void)fprintf(stderr,   
d226 1
a226 1
			if (unmask && 
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
d37 1
a37 1
static char rcsid[] = "$Id: main.c,v 1.6 2001/07/27 20:34:36 pvalchev Exp $";
d79 1
a79 3
main(argc, argv)
	int argc;
	char **argv;
d83 1
d172 2
a173 1
			    "usage: sa [-abcdDfijkKlmnqrstu] [-v cutoff] [file ...]\n");
d241 1
a241 1
				warn("couldn't truncate %s", argv);
d268 1
a268 1
			warn("close %s", argv);
d293 1
a293 3
acct_load(pn, wr)
	char *pn;
	int wr;
d363 1
a363 2
decode_comp_t(comp)
	comp_t comp;
d383 1
a383 2
cmp_comm(s1, s2)
	const char *s1, *s2;
d395 1
a395 2
cmp_usrsys(d1, d2)
	const DBT *d1, *d2;
d416 1
a416 2
cmp_avgusrsys(d1, d2)
	const DBT *d1, *d2;
d440 1
a440 2
cmp_dkio(d1, d2)
	const DBT *d1, *d2;
d457 1
a457 2
cmp_avgdkio(d1, d2)
	const DBT *d1, *d2;
d478 1
a478 2
cmp_cpumem(d1, d2)
	const DBT *d1, *d2;
d495 1
a495 2
cmp_avgcpumem(d1, d2)
	const DBT *d1, *d2;
d520 1
a520 2
cmp_calls(d1, d2)
	const DBT *d1, *d2;
@


1.6
log
@Wall cleanup
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: main.c,v 1.5 2000/11/10 15:33:15 provos Exp $";
d56 10
a65 10
static int	acct_load	__P((char *, int));
static u_quad_t	decode_comp_t	__P((comp_t));
static int	cmp_comm	__P((const char *, const char *));
static int	cmp_usrsys	__P((const DBT *, const DBT *));
static int	cmp_avgusrsys	__P((const DBT *, const DBT *));
static int	cmp_dkio	__P((const DBT *, const DBT *));
static int	cmp_avgdkio	__P((const DBT *, const DBT *));
static int	cmp_cpumem	__P((const DBT *, const DBT *));
static int	cmp_avgcpumem	__P((const DBT *, const DBT *));
static int	cmp_calls	__P((const DBT *, const DBT *));
@


1.5
log
@seperate -> separate, okay aaron@@
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: main.c,v 1.4 1999/05/24 21:24:00 deraadt Exp $";
d353 1
a353 1
			printf("%6u %12.2lf cpu %12quk mem %12qu io %s\n",
@


1.4
log
@init exit code; ben@@scientia.demon.co.uk
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: main.c,v 1.3 1998/12/18 20:47:19 deraadt Exp $";
d133 1
a133 1
			/* seperate system and user time */
@


1.3
log
@indent
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: main.c,v 1.2 1996/04/21 23:41:57 deraadt Exp $";
d83 1
a83 1
	int error;
@


1.2
log
@sync to netbsd 960418
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: main.c,v 1.1.1.1 1995/10/18 08:48:07 deraadt Exp $";
d87 87
a173 87
			case 'a':
				/* print all commands */
				aflag = 1;
				break;
			case 'b':
				/* sort by per-call user/system time average */
				bflag = 1;
				sa_cmp = cmp_avgusrsys;
				break;
			case 'c':
				/* print percentage total time */
				cflag = 1;
				break;
			case 'd':
				/* sort by averge number of disk I/O ops */
				dflag = 1;
				sa_cmp = cmp_avgdkio;
				break;
			case 'D':
				/* print and sort by total disk I/O ops */
				Dflag = 1;
				sa_cmp = cmp_dkio;
				break;
			case 'f':
				/* force no interactive threshold comprison */
				fflag = 1;
				break;
			case 'i':
				/* do not read in summary file */
				iflag = 1;
				break;
			case 'j':
				/* instead of total minutes, give sec/call */
				jflag = 1;
				break;
			case 'k':
				/* sort by cpu-time average memory usage */
				kflag = 1;
				sa_cmp = cmp_avgcpumem;
				break;
			case 'K':
				/* print and sort by cpu-storage integral */
				sa_cmp = cmp_cpumem;
				Kflag = 1;
				break;
			case 'l':
				/* seperate system and user time */
				lflag = 1;
				break;
			case 'm':
				/* print procs and time per-user */
				mflag = 1;
				break;
			case 'n':
				/* sort by number of calls */
				sa_cmp = cmp_calls;
				break;
			case 'q':
				/* quiet; error messages only */
				qflag = 1;
				break;
			case 'r':
				/* reverse order of sort */
				rflag = 1;
				break;
			case 's':
				/* merge accounting file into summaries */
				sflag = 1;
				break;
			case 't':
				/* report ratio of user and system times */
				tflag = 1;
				break;
			case 'u':
				/* first, print uid and command name */
				uflag = 1;
				break;
			case 'v':
				/* cull junk */
				vflag = 1;
				cutoff = atoi(optarg);
				break;
			case '?':
	                default:
				(void)fprintf(stderr,   
				    "usage: sa [-abcdDfijkKlmnqrstu] [-v cutoff] [file ...]\n");
				exit(1);
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: main.c,v 1.5 1995/04/24 13:26:25 cgd Exp $";
d82 1
a82 1
	char ch;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
