head	1.125;
access;
symbols
	OPENBSD_6_0:1.125.0.2
	OPENBSD_6_0_BASE:1.125
	OPENBSD_5_9:1.124.0.2
	OPENBSD_5_9_BASE:1.124
	OPENBSD_5_8:1.123.0.6
	OPENBSD_5_8_BASE:1.123
	OPENBSD_5_7:1.123.0.2
	OPENBSD_5_7_BASE:1.123
	OPENBSD_5_6:1.120.0.4
	OPENBSD_5_6_BASE:1.120
	OPENBSD_5_5:1.119.0.6
	OPENBSD_5_5_BASE:1.119
	OPENBSD_5_4:1.119.0.2
	OPENBSD_5_4_BASE:1.119
	OPENBSD_5_3:1.118.0.2
	OPENBSD_5_3_BASE:1.118
	OPENBSD_5_2:1.116.0.2
	OPENBSD_5_2_BASE:1.116
	OPENBSD_5_1_BASE:1.115
	OPENBSD_5_1:1.115.0.6
	OPENBSD_5_0:1.115.0.4
	OPENBSD_5_0_BASE:1.115
	OPENBSD_4_9:1.115.0.2
	OPENBSD_4_9_BASE:1.115
	OPENBSD_4_8:1.114.0.4
	OPENBSD_4_8_BASE:1.114
	OPENBSD_4_7:1.114.0.2
	OPENBSD_4_7_BASE:1.114
	OPENBSD_4_6:1.112.0.6
	OPENBSD_4_6_BASE:1.112
	OPENBSD_4_5:1.112.0.2
	OPENBSD_4_5_BASE:1.112
	OPENBSD_4_4:1.107.0.4
	OPENBSD_4_4_BASE:1.107
	OPENBSD_4_3:1.107.0.2
	OPENBSD_4_3_BASE:1.107
	OPENBSD_4_2:1.104.0.4
	OPENBSD_4_2_BASE:1.104
	OPENBSD_4_1:1.104.0.2
	OPENBSD_4_1_BASE:1.104
	OPENBSD_4_0:1.99.0.2
	OPENBSD_4_0_BASE:1.99
	OPENBSD_3_9:1.96.0.2
	OPENBSD_3_9_BASE:1.96
	OPENBSD_3_8:1.91.0.2
	OPENBSD_3_8_BASE:1.91
	OPENBSD_3_7:1.89.0.2
	OPENBSD_3_7_BASE:1.89
	OPENBSD_3_6:1.85.0.2
	OPENBSD_3_6_BASE:1.85
	OPENBSD_3_5:1.75.0.2
	OPENBSD_3_5_BASE:1.75
	OPENBSD_3_4:1.68.0.2
	OPENBSD_3_4_BASE:1.68
	OPENBSD_3_3:1.53.0.2
	OPENBSD_3_3_BASE:1.53
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.125
date	2016.03.29.14.53.27;	author mestre;	state Exp;
branches;
next	1.124;
commitid	oWt6IEXRYRqitNgd;

1.124
date	2015.12.08.07.11.53;	author mmcc;	state Exp;
branches;
next	1.123;
commitid	wKvRsIRSy2u886mb;

1.123
date	2015.01.21.21.50.32;	author deraadt;	state Exp;
branches;
next	1.122;
commitid	3o2AkhiRPQXvG94X;

1.122
date	2015.01.15.23.59.28;	author deraadt;	state Exp;
branches;
next	1.121;
commitid	yiz4tBW7LfZuRPcq;

1.121
date	2014.10.08.02.11.54;	author deraadt;	state Exp;
branches;
next	1.120;
commitid	ImhsAN32EXVBIj5T;

1.120
date	2014.04.02.02.12.24;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2013.04.02.06.04.50;	author guenther;	state Exp;
branches;
next	1.118;

1.118
date	2013.01.19.16.58.16;	author miod;	state Exp;
branches;
next	1.117;

1.117
date	2013.01.15.23.03.37;	author beck;	state Exp;
branches;
next	1.116;

1.116
date	2012.07.07.12.55.29;	author claudio;	state Exp;
branches;
next	1.115;

1.115
date	2010.09.02.14.01.04;	author sobrado;	state Exp;
branches;
next	1.114;

1.114
date	2010.01.27.15.36.17;	author todd;	state Exp;
branches;
next	1.113;

1.113
date	2009.11.23.00.47.56;	author claudio;	state Exp;
branches;
next	1.112;

1.112
date	2009.01.10.19.08.53;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2009.01.10.17.17.32;	author todd;	state Exp;
branches;
next	1.110;

1.110
date	2009.01.06.03.11.50;	author mcbride;	state Exp;
branches;
next	1.109;

1.109
date	2008.10.07.17.27.17;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2008.10.05.21.10.14;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2008.02.14.01.49.17;	author mcbride;	state Exp;
branches;
next	1.106;

1.106
date	2008.02.01.07.08.03;	author mcbride;	state Exp;
branches;
next	1.105;

1.105
date	2007.09.25.11.20.34;	author chl;	state Exp;
branches;
next	1.104;

1.104
date	2007.02.24.17.35.08;	author beck;	state Exp;
branches;
next	1.103;

1.103
date	2007.02.24.17.21.04;	author beck;	state Exp;
branches;
next	1.102;

1.102
date	2007.02.24.17.14.26;	author beck;	state Exp;
branches;
next	1.101;

1.101
date	2007.02.22.21.54.23;	author beck;	state Exp;
branches;
next	1.100;

1.100
date	2007.02.22.21.15.41;	author beck;	state Exp;
branches;
next	1.99;

1.99
date	2006.08.09.16.21.39;	author dhartmei;	state Exp;
branches;
next	1.98;

1.98
date	2006.03.17.22.00.27;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2006.03.14.21.45.14;	author beck;	state Exp;
branches;
next	1.96;

1.96
date	2005.12.12.16.06.01;	author beck;	state Exp;
branches;
next	1.95;

1.95
date	2005.12.12.16.02.32;	author beck;	state Exp;
branches;
next	1.94;

1.94
date	2005.12.09.23.51.21;	author beck;	state Exp;
branches;
next	1.93;

1.93
date	2005.12.09.23.41.57;	author beck;	state Exp;
branches;
next	1.92;

1.92
date	2005.12.08.23.03.11;	author beck;	state Exp;
branches;
next	1.91;

1.91
date	2005.05.23.22.50.23;	author henning;	state Exp;
branches
	1.91.2.1;
next	1.90;

1.90
date	2005.05.02.02.29.26;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2005.02.10.04.24.15;	author joel;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2005.01.31.15.08.50;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2005.01.31.15.06.31;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2004.09.16.18.34.05;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2004.08.08.00.05.09;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2004.06.14.20.38.19;	author cedric;	state Exp;
branches;
next	1.83;

1.83
date	2004.05.21.23.10.49;	author dhartmei;	state Exp;
branches;
next	1.82;

1.82
date	2004.05.19.17.50.52;	author dhartmei;	state Exp;
branches;
next	1.81;

1.81
date	2004.05.13.17.14.55;	author henning;	state Exp;
branches;
next	1.80;

1.80
date	2004.04.28.05.06.13;	author cedric;	state Exp;
branches;
next	1.79;

1.79
date	2004.04.28.00.22.39;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2004.04.25.19.24.52;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2004.04.25.18.40.42;	author beck;	state Exp;
branches;
next	1.76;

1.76
date	2004.04.09.12.42.06;	author cedric;	state Exp;
branches;
next	1.75;

1.75
date	2004.01.29.01.55.10;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.13.17.31.15;	author dhartmei;	state Exp;
branches;
next	1.73;

1.73
date	2003.12.15.07.11.31;	author mcbride;	state Exp;
branches;
next	1.72;

1.72
date	2003.12.10.04.10.37;	author beck;	state Exp;
branches;
next	1.71;

1.71
date	2003.11.14.15.31.07;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2003.09.26.21.44.09;	author cedric;	state Exp;
branches;
next	1.69;

1.69
date	2003.09.26.07.24.10;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2003.08.21.19.13.23;	author frantzen;	state Exp;
branches;
next	1.67;

1.67
date	2003.08.01.05.29.36;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2003.07.11.08.29.34;	author cedric;	state Exp;
branches;
next	1.65;

1.65
date	2003.07.08.11.31.27;	author dhartmei;	state Exp;
branches;
next	1.64;

1.64
date	2003.07.03.21.09.13;	author cedric;	state Exp;
branches;
next	1.63;

1.63
date	2003.07.03.09.13.05;	author cedric;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.28.20.37.29;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.27.09.50.07;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.24.20.45.54;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.24.20.44.54;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.03.20.38.59;	author beck;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.10.06.14.29;	author cloder;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.10.00.51.53;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2003.04.30.12.30.27;	author cedric;	state Exp;
branches;
next	1.54;

1.54
date	2003.04.20.02.37.00;	author beck;	state Exp;
branches;
next	1.53;

1.53
date	2003.02.19.00.03.22;	author deraadt;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2003.02.11.20.15.59;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2003.02.03.09.59.19;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2003.02.02.23.31.24;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2003.01.29.10.13.10;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2003.01.27.00.59.20;	author dhartmei;	state Exp;
branches;
next	1.47;

1.47
date	2003.01.26.02.49.59;	author dhartmei;	state Exp;
branches;
next	1.46;

1.46
date	2003.01.25.16.33.19;	author cedric;	state Exp;
branches;
next	1.45;

1.45
date	2003.01.09.10.40.44;	author cedric;	state Exp;
branches;
next	1.44;

1.44
date	2003.01.07.03.32.15;	author dhartmei;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.06.18.43.02;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.05.22.14.23;	author dhartmei;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.01.02.28.26;	author dhartmei;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.29.22.00.37;	author dhartmei;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.22.16.19.32;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.22.14.19.30;	author dhartmei;	state Exp;
branches;
next	1.37;

1.37
date	2002.12.19.14.04.03;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.19.14.03.06;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2002.12.18.22.07.31;	author mcbride;	state Exp;
branches;
next	1.34;

1.34
date	2002.12.17.12.42.22;	author mcbride;	state Exp;
branches;
next	1.33;

1.33
date	2002.12.06.00.47.32;	author dhartmei;	state Exp;
branches;
next	1.32;

1.32
date	2002.12.04.08.06.58;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.12.01.20.01.35;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2002.12.01.19.59.45;	author mcbride;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.23.07.54.45;	author mcbride;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.23.05.27.19;	author mcbride;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.22.18.06.48;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.19.02.18.50;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.19.02.14.56;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.25.18.33.13;	author camield;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.25.08.14.38;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.12.20.09.43;	author vincent;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.11.17.13.55;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.11.04.45.32;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.08.04.57.34;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.07.08.51.44;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.07.08.36.56;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.30.09.11.59;	author form;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.21.19.48.04;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.16.09.18.55;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.24.23.03.56;	author dhartmei;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.09.23.19.01;	author frantzen;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.09.20.07.16;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.09.17.40.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.08.16.12.49;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.07.16.31.27;	author frantzen;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.05.20.35.52;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.05.03.06.52;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.01.18.57.35;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.01.18.56.01;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.01.18.54.33;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.01.18.26.04;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.01.17.43.42;	author beck;	state Exp;
branches;
next	;

1.53.2.1
date	2003.07.08.22.19.56;	author margarida;	state Exp;
branches;
next	;

1.89.2.1
date	2005.12.18.04.18.25;	author brad;	state Exp;
branches;
next	;

1.91.2.1
date	2005.12.18.04.16.58;	author brad;	state Exp;
branches;
next	;


desc
@@


1.125
log
@- Add missing goto in order to avoid a dereference of a null object
- While here remove lint comment

OK millert@@
@
text
@/*	$OpenBSD: authpf.c,v 1.124 2015/12/08 07:11:53 mmcc Exp $	*/

/*
 * Copyright (C) 1998 - 2007 Bob Beck (beck@@openbsd.org).
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/pfvar.h>

#include <err.h>
#include <errno.h>
#include <login_cap.h>
#include <pwd.h>
#include <grp.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "pathnames.h"

static int	read_config(FILE *);
static void	print_message(char *);
static int	allowed_luser(struct passwd *);
static int	check_luser(char *, char *);
static int	remove_stale_rulesets(void);
static int	recursive_ruleset_purge(char *, char *);
static int	change_filter(int, const char *, const char *);
static int	change_table(int, const char *);
static void	authpf_kill_states(void);

int	dev;			/* pf device */
char	anchorname[PF_ANCHOR_NAME_SIZE] = "authpf";
char	rulesetname[PATH_MAX - PF_ANCHOR_NAME_SIZE - 2];
char	tablename[PF_TABLE_NAME_SIZE] = "authpf_users";
int	user_ip = 1;	/* controls whether $user_ip is set */

FILE	*pidfp;
int	pidfd = -1;
char	 luser[LOGIN_NAME_MAX];	/* username */
char	 ipsrc[256];		/* ip as a string */
char	 pidfile[PATH_MAX];	/* we save pid in this file. */

struct timeval	Tstart, Tend;	/* start and end times of session */

volatile sig_atomic_t	want_death;
static void		need_death(int signo);
static __dead void	do_death(int);
extern char *__progname;	/* program name */

/*
 * User shell for authenticating gateways. Sole purpose is to allow
 * a user to ssh to a gateway, and have the gateway modify packet
 * filters to allow access, then remove access when the user finishes
 * up. Meant to be used only from ssh(1) connections.
 */
int
main(int argc, char *argv[])
{
	int		 lockcnt = 0, n;
	FILE		*config;
	struct in6_addr	 ina;
	struct passwd	*pw;
	char		*cp;
	gid_t		 gid;
	uid_t		 uid;
	char		*shell;
	login_cap_t	*lc;

	if (strcmp(__progname, "-authpf-noip") == 0)
                user_ip = 0;

	config = fopen(PATH_CONFFILE, "r");
	if (config == NULL) {
		syslog(LOG_ERR, "cannot open %s (%m)", PATH_CONFFILE);
		exit(1);
	}

	if ((cp = getenv("SSH_TTY")) == NULL) {
		syslog(LOG_ERR, "non-interactive session connection for authpf");
		exit(1);
	}

	if ((cp = getenv("SSH_CLIENT")) == NULL) {
		syslog(LOG_ERR, "cannot determine connection source");
		exit(1);
	}

	if (strlcpy(ipsrc, cp, sizeof(ipsrc)) >= sizeof(ipsrc)) {
		syslog(LOG_ERR, "SSH_CLIENT variable too long");
		exit(1);
	}
	cp = strchr(ipsrc, ' ');
	if (!cp) {
		syslog(LOG_ERR, "corrupt SSH_CLIENT variable %s", ipsrc);
		exit(1);
	}
	*cp = '\0';
	if (inet_pton(AF_INET, ipsrc, &ina) != 1 &&
	    inet_pton(AF_INET6, ipsrc, &ina) != 1) {
		syslog(LOG_ERR,
		    "cannot determine IP from SSH_CLIENT %s", ipsrc);
		exit(1);
	}
	/* open the pf device */
	dev = open(PATH_DEVFILE, O_RDWR);
	if (dev == -1) {
		syslog(LOG_ERR, "cannot open packet filter device (%m)");
		goto die;
	}

	uid = getuid();
	pw = getpwuid(uid);
	if (pw == NULL) {
		syslog(LOG_ERR, "cannot find user for uid %u", uid);
		goto die;
	}

	if ((lc = login_getclass(pw->pw_class)) != NULL)
		shell = login_getcapstr(lc, "shell", pw->pw_shell,
		    pw->pw_shell);
	else
		shell = pw->pw_shell;

	login_close(lc);

	if (strcmp(shell, PATH_AUTHPF_SHELL) &&
	    strcmp(shell, PATH_AUTHPF_SHELL_NOIP)) {
		syslog(LOG_ERR, "wrong shell for user %s, uid %u",
		    pw->pw_name, pw->pw_uid);
		if (shell != pw->pw_shell)
			free(shell);
		goto die;
	}

	if (shell != pw->pw_shell)
		free(shell);

	/*
	 * Paranoia, but this data _does_ come from outside authpf, and
	 * truncation would be bad.
	 */
	if (strlcpy(luser, pw->pw_name, sizeof(luser)) >= sizeof(luser)) {
		syslog(LOG_ERR, "username too long: %s", pw->pw_name);
		goto die;
	}

	if ((n = snprintf(rulesetname, sizeof(rulesetname), "%s(%ld)",
	    luser, (long)getpid())) < 0 || (u_int)n >= sizeof(rulesetname)) {
		syslog(LOG_INFO, "%s(%ld) too large, ruleset name will be %ld",
		    luser, (long)getpid(), (long)getpid());
		if ((n = snprintf(rulesetname, sizeof(rulesetname), "%ld",
		    (long)getpid())) < 0 || (u_int)n >= sizeof(rulesetname)) {
			syslog(LOG_ERR, "pid too large for ruleset name");
			goto die;
		}
	}


	/* Make our entry in /var/authpf as ipaddr or username */
	n = snprintf(pidfile, sizeof(pidfile), "%s/%s",
	    PATH_PIDFILE, user_ip ? ipsrc : luser);
	if (n < 0 || (u_int)n >= sizeof(pidfile)) {
		syslog(LOG_ERR, "path to pidfile too long");
		goto die;
	}

	signal(SIGTERM, need_death);
	signal(SIGINT, need_death);
	signal(SIGALRM, need_death);
	signal(SIGPIPE, need_death);
	signal(SIGHUP, need_death);
	signal(SIGQUIT, need_death);
	signal(SIGTSTP, need_death);

	/*
	 * If someone else is already using this ip, then this person
	 * wants to switch users - so kill the old process and exit
	 * as well.
	 *
	 * Note, we could print a message and tell them to log out, but the
	 * usual case of this is that someone has left themselves logged in,
	 * with the authenticated connection iconized and someone else walks
	 * up to use and automatically logs in before using. If this just
	 * gets rid of the old one silently, the new user never knows they
	 * could have used someone else's old authentication. If we
	 * tell them to log out before switching users it is an invitation
	 * for abuse.
	 */

	do {
		int	save_errno, otherpid = -1;
		char	otherluser[LOGIN_NAME_MAX];

		if ((pidfd = open(pidfile, O_RDWR|O_CREAT, 0644)) == -1 ||
		    (pidfp = fdopen(pidfd, "r+")) == NULL) {
			if (pidfd != -1)
				close(pidfd);
			syslog(LOG_ERR, "cannot open or create %s: %s", pidfile,
			    strerror(errno));
			goto die;
		}

		if (flock(fileno(pidfp), LOCK_EX|LOCK_NB) == 0)
			break;
		save_errno = errno;

		/* Mark our pid, and username to our file. */

		rewind(pidfp);
		/* 31 == MAXLOGNAME - 1 */
		if (fscanf(pidfp, "%d\n%31s\n", &otherpid, otherluser) != 2)
			otherpid = -1;
		syslog(LOG_DEBUG, "tried to lock %s, in use by pid %d: %s",
		    pidfile, otherpid, strerror(save_errno));

		if (otherpid > 0) {
			syslog(LOG_INFO,
			    "killing prior auth (pid %d) of %s by user %s",
			    otherpid, ipsrc, otherluser);
			if (kill((pid_t) otherpid, SIGTERM) == -1) {
				syslog(LOG_INFO,
				    "could not kill process %d: (%m)",
				    otherpid);
			}
		}

		/*
		 * We try to kill the previous process and acquire the lock
		 * for 10 seconds, trying once a second. if we can't after
		 * 10 attempts we log an error and give up.
		 */
		if (want_death || ++lockcnt > 10) {
			if (!want_death)
				syslog(LOG_ERR, "cannot kill previous authpf (pid %d)",
				    otherpid);
			fclose(pidfp);
			pidfp = NULL;
			pidfd = -1;
			goto dogdeath;
		}
		sleep(1);

		/* re-open, and try again. The previous authpf process
		 * we killed above should unlink the file and release
		 * it's lock, giving us a chance to get it now
		 */
		fclose(pidfp);
		pidfp = NULL;
		pidfd = -1;
	} while (1);

	/* whack the group list */
	gid = getegid();
	if (setgroups(1, &gid) == -1) {
		syslog(LOG_INFO, "setgroups: %s", strerror(errno));
		do_death(0);
	}

	/* revoke privs */
	uid = getuid();
	if (setresuid(uid, uid, uid) == -1) {
		syslog(LOG_INFO, "setresuid: %s", strerror(errno));
		do_death(0);
	}
	openlog("authpf", LOG_PID | LOG_NDELAY, LOG_DAEMON);

	if (!check_luser(PATH_BAN_DIR, luser) || !allowed_luser(pw)) {
		syslog(LOG_INFO, "user %s prohibited", luser);
		do_death(0);
	}

	if (read_config(config)) {
		syslog(LOG_ERR, "invalid config file %s", PATH_CONFFILE);
		do_death(0);
	}

	if (remove_stale_rulesets()) {
		syslog(LOG_INFO, "error removing stale rulesets");
		do_death(0);
	}

	/* We appear to be making headway, so actually mark our pid */
	rewind(pidfp);
	fprintf(pidfp, "%ld\n%s\n", (long)getpid(), luser);
	fflush(pidfp);
	(void) ftruncate(fileno(pidfp), ftello(pidfp));

	if (change_filter(1, luser, ipsrc) == -1) {
		printf("Unable to modify filters\r\n");
		do_death(0);
	}
	if (user_ip && change_table(1, ipsrc) == -1) {
		printf("Unable to modify table\r\n");
		change_filter(0, luser, ipsrc);
		do_death(0);
	}

	while (1) {
		struct stat sb;
		char *path_message;
		printf("\r\nHello %s. ", luser);
		printf("You are authenticated from host \"%s\"\r\n", ipsrc);
		setproctitle("%s@@%s", luser, ipsrc);
		if (asprintf(&path_message, "%s/%s/authpf.message",
		    PATH_USER_DIR, luser) == -1)
			do_death(1);
		if (stat(path_message, &sb) == -1 || ! S_ISREG(sb.st_mode)) {
			free(path_message);
			if ((path_message = strdup(PATH_MESSAGE)) == NULL)
				do_death(1);
		}
		print_message(path_message);
		while (1) {
			sleep(10);
			if (want_death)
				do_death(1);
		}
	}

dogdeath:
	printf("\r\n\r\nSorry, this service is currently unavailable due to ");
	printf("technical difficulties\r\n\r\n");
	print_message(PATH_PROBLEM);
	printf("\r\nYour authentication process (pid %ld) was unable to run\n",
	    (long)getpid());
	sleep(180); /* them lusers read reaaaaal slow */
die:
	do_death(0);
}

/*
 * reads config file in PATH_CONFFILE to set optional behaviours up
 */
static int
read_config(FILE *f)
{
	char	buf[1024];
	int	i = 0;

	do {
		char	**ap;
		char	 *pair[4], *cp, *tp;
		int	  len;

		if (fgets(buf, sizeof(buf), f) == NULL) {
			fclose(f);
			return (0);
		}
		i++;
		len = strlen(buf);
		if (len == 0)
			continue;
		if (buf[len - 1] != '\n' && !feof(f)) {
			syslog(LOG_ERR, "line %d too long in %s", i,
			    PATH_CONFFILE);
			return (1);
		}
		buf[len - 1] = '\0';

		for (cp = buf; *cp == ' ' || *cp == '\t'; cp++)
			; /* nothing */

		if (!*cp || *cp == '#' || *cp == '\n')
			continue;

		for (ap = pair; ap < &pair[3] &&
		    (*ap = strsep(&cp, "=")) != NULL; ) {
			if (**ap != '\0')
				ap++;
		}
		if (ap != &pair[2])
			goto parse_error;

		tp = pair[1] + strlen(pair[1]);
		while ((*tp == ' ' || *tp == '\t') && tp >= pair[1])
			*tp-- = '\0';

		if (strcasecmp(pair[0], "anchor") == 0) {
			if (!pair[1][0] || strlcpy(anchorname, pair[1],
			    sizeof(anchorname)) >= sizeof(anchorname))
				goto parse_error;
		}
		if (strcasecmp(pair[0], "table") == 0) {
			if (!pair[1][0] || strlcpy(tablename, pair[1],
			    sizeof(tablename)) >= sizeof(tablename))
				goto parse_error;
		}
	} while (!feof(f) && !ferror(f));
	fclose(f);
	return (0);

parse_error:
	fclose(f);
	syslog(LOG_ERR, "parse error, line %d of %s", i, PATH_CONFFILE);
	return (1);
}


/*
 * splatter a file to stdout - max line length of 1024,
 * used for spitting message files at users to tell them
 * they've been bad or we're unavailable.
 */
static void
print_message(char *filename)
{
	char	 buf[1024];
	FILE	*f;

	if ((f = fopen(filename, "r")) == NULL)
		return; /* fail silently, we don't care if it isn't there */

	do {
		if (fgets(buf, sizeof(buf), f) == NULL) {
			fflush(stdout);
			fclose(f);
			return;
		}
	} while (fputs(buf, stdout) != EOF && !feof(f));
	fflush(stdout);
	fclose(f);
}

/*
 * allowed_luser checks to see if user "luser" is allowed to
 * use this gateway by virtue of being listed in an allowed
 * users file, namely /etc/authpf/authpf.allow .
 * Users may be listed by <username>, %<group>, or @@<login_class>.
 *
 * If /etc/authpf/authpf.allow does not exist, then we assume that
 * all users who are allowed in by sshd(8) are permitted to
 * use this gateway. If /etc/authpf/authpf.allow does exist, then a
 * user must be listed if the connection is to continue, else
 * the session terminates in the same manner as being banned.
 */
static int
allowed_luser(struct passwd *pw)
{
	char	*buf, *lbuf;
	int	 matched;
	size_t	 len;
	FILE	*f;

	if ((f = fopen(PATH_ALLOWFILE, "r")) == NULL) {
		if (errno == ENOENT) {
			/*
			 * allowfile doesn't exist, thus this gateway
			 * isn't restricted to certain users...
			 */
			return (1);
		}

		/*
		 * luser may in fact be allowed, but we can't open
		 * the file even though it's there. probably a config
		 * problem.
		 */
		syslog(LOG_ERR, "cannot open allowed users file %s (%s)",
		    PATH_ALLOWFILE, strerror(errno));
		return (0);
	} else {
		/*
		 * /etc/authpf/authpf.allow exists, thus we do a linear
		 * search to see if they are allowed.
		 * also, if username "*" exists, then this is a
		 * "public" gateway, such as it is, so let
		 * everyone use it.
		 */
		int gl_init = 0, ngroups = NGROUPS_MAX + 1;
		gid_t groups[NGROUPS_MAX + 1];

		lbuf = NULL;
		matched = 0;

		while ((buf = fgetln(f, &len))) {

			if (buf[len - 1] == '\n')
				buf[len - 1] = '\0';
			else {
				if ((lbuf = malloc(len + 1)) == NULL)
					err(1, NULL);
				memcpy(lbuf, buf, len);
				lbuf[len] = '\0';
				buf = lbuf;
			}

			if (buf[0] == '@@') {
				/* check login class */
				if (strcmp(pw->pw_class, buf + 1) == 0)
					matched++;
			} else if (buf[0] == '%') {
				/* check group membership */
				int cnt;
				struct group *group;

				if ((group = getgrnam(buf + 1)) == NULL) {
					syslog(LOG_ERR,
					    "invalid group '%s' in %s (%s)",
					    buf + 1, PATH_ALLOWFILE,
				 	    strerror(errno));
					fclose(f);
					return (0);
				}

				if (!gl_init) {
					(void) getgrouplist(pw->pw_name,
					    pw->pw_gid, groups, &ngroups);
					gl_init++;
				}

				for ( cnt = 0; cnt < ngroups; cnt++) {
					if (group->gr_gid == groups[cnt]) {
						matched++;
						break;
					}
				}
			} else {
				/* check username and wildcard */
				matched = strcmp(pw->pw_name, buf) == 0 ||
				    strcmp("*", buf) == 0;
			}

			free(lbuf);
			lbuf = NULL;

			if (matched) {
				fclose(f);
				return (1); /* matched an allowed user/group */
			}
		}
		syslog(LOG_INFO, "denied access to %s: not listed in %s",
		    pw->pw_name, PATH_ALLOWFILE);

		/* reuse buf */
		buf = "\n\nSorry, you are not allowed to use this facility!\n";
		fputs(buf, stdout);
	}
	fflush(stdout);
	fclose(f);
	return (0);
}

/*
 * check_luser checks to see if user "luser" has been banned
 * from using us by virtue of having an file of the same name
 * in the "luserdir" directory.
 *
 * If the user has been banned, we copy the contents of the file
 * to the user's screen. (useful for telling the user what to
 * do to get un-banned, or just to tell them they aren't
 * going to be un-banned.)
 */
static int
check_luser(char *luserdir, char *luser)
{
	FILE	*f;
	int	 n;
	char	 tmp[PATH_MAX];

	n = snprintf(tmp, sizeof(tmp), "%s/%s", luserdir, luser);
	if (n < 0 || (u_int)n >= sizeof(tmp)) {
		syslog(LOG_ERR, "provided banned directory line too long (%s)",
		    luserdir);
		return (0);
	}
	if ((f = fopen(tmp, "r")) == NULL) {
		if (errno == ENOENT) {
			/*
			 * file or dir doesn't exist, so therefore
			 * this luser isn't banned..  all is well
			 */
			return (1);
		} else {
			/*
			 * luser may in fact be banned, but we can't open the
			 * file even though it's there. probably a config
			 * problem.
			 */
			syslog(LOG_ERR, "cannot open banned file %s (%s)",
			    tmp, strerror(errno));
			return (0);
		}
	} else {
		/*
		 * luser is banned - spit the file at them to
		 * tell what they can do and where they can go.
		 */
		syslog(LOG_INFO, "denied access to %s: %s exists",
		    luser, tmp);

		/* reuse tmp */
		strlcpy(tmp, "\n\n-**- Sorry, you have been banned! -**-\n\n",
		    sizeof(tmp));
		while (fputs(tmp, stdout) != EOF && !feof(f)) {
			if (fgets(tmp, sizeof(tmp), f) == NULL) {
				fflush(stdout);
				fclose(f);
				return (0);
			}
		}
		fclose(f);
	}
	fflush(stdout);
	return (0);
}

/*
 * Search for rulesets left by other authpf processes (either because they
 * died ungracefully or were terminated) and remove them.
 */
static int
remove_stale_rulesets(void)
{
	struct pfioc_ruleset	 prs;
	u_int32_t		 nr;

	memset(&prs, 0, sizeof(prs));
	strlcpy(prs.path, anchorname, sizeof(prs.path));
	if (ioctl(dev, DIOCGETRULESETS, &prs)) {
		if (errno == EINVAL)
			return (0);
		else
			return (1);
	}

	nr = prs.nr;
	while (nr) {
		char	*s, *t;
		pid_t	 pid;

		prs.nr = nr - 1;
		if (ioctl(dev, DIOCGETRULESET, &prs))
			return (1);
		errno = 0;
		if ((t = strchr(prs.name, '(')) == NULL)
			t = prs.name;
		else
			t++;
		pid = strtoul(t, &s, 10);
		if (!prs.name[0] || errno ||
		    (*s && (t == prs.name || *s != ')')))
			return (1);
		if ((kill(pid, 0) && errno != EPERM) || pid == getpid()) {
			if (recursive_ruleset_purge(anchorname, prs.name))
				return (1);
		}
		nr--;
	}
	return (0);
}

static int
recursive_ruleset_purge(char *an, char *rs)
{
	struct pfioc_trans_e     *t_e = NULL;
	struct pfioc_trans	 *t = NULL;
	struct pfioc_ruleset	 *prs = NULL;

	/* purge rules */
	errno = 0;
	if ((t = calloc(1, sizeof(struct pfioc_trans))) == NULL)
		goto no_mem;
	if ((t_e = calloc(2, sizeof(struct pfioc_trans_e))) == NULL)
		goto no_mem;
	t->size = 2;
	t->esize = sizeof(struct pfioc_trans_e);
	t->array = t_e;
	t_e[0].type = PF_TRANS_RULESET;
	snprintf(t_e[0].anchor, sizeof(t_e[0].anchor), "%s/%s", an, rs);
	t_e[1].type = PF_TRANS_TABLE;

	if ((ioctl(dev, DIOCXBEGIN, t) ||
	    ioctl(dev, DIOCXCOMMIT, t)) &&
	    errno != EINVAL)
		goto cleanup;

	/* purge any children */
	if ((prs = calloc(1, sizeof(struct pfioc_ruleset))) == NULL)
		goto no_mem;
	snprintf(prs->path, sizeof(prs->path), "%s/%s", an, rs);
	if (ioctl(dev, DIOCGETRULESETS, prs)) {
		if (errno != EINVAL)
			goto cleanup;
		errno = 0;
	} else {
		int nr = prs->nr;

		while (nr) {
			prs->nr = 0;
			if (ioctl(dev, DIOCGETRULESET, prs))
				goto cleanup;

			if (recursive_ruleset_purge(prs->path, prs->name))
				goto cleanup;
			nr--;
		}
	}

no_mem:
	if (errno == ENOMEM)
		syslog(LOG_ERR, "calloc failed");

cleanup:
	free(t);
	free(t_e);
	free(prs);
	return (errno);
}

/*
 * Add/remove filter entries for user "luser" from ip "ipsrc"
 */
static int
change_filter(int add, const char *luser, const char *ipsrc)
{
	char	*fdpath = NULL, *userstr = NULL, *ipstr = NULL;
	char	*rsn = NULL, *fn = NULL;
	pid_t	pid;
	gid_t   gid;
	int	s;

	if (add) {
		struct stat sb;
		struct group *grent;
		char	*pargv[13] = {
			"pfctl", "-p", "/dev/pf", "-q", "-a", "anchor/ruleset",
			"-D", "user_id=X", "-D", "user_ip=X", "-f", "file", NULL
		};

		if((grent = getgrgid(getgid())) == NULL) {
			syslog(LOG_ERR, "Group not found user %s, gid %d",
			    luser, getgid());
			goto error;
		}

		if (luser == NULL || !luser[0] || ipsrc == NULL || !ipsrc[0]) {
			syslog(LOG_ERR, "invalid luser/ipsrc");
			goto error;
		}

		if (asprintf(&rsn, "%s/%s", anchorname, rulesetname) == -1)
			goto no_mem;
		if (asprintf(&fdpath, "/dev/fd/%d", dev) == -1)
			goto no_mem;
		if (asprintf(&ipstr, "user_ip=%s", ipsrc) == -1)
			goto no_mem;
		if (asprintf(&userstr, "user_id=%s", luser) == -1)
			goto no_mem;
		if (asprintf(&fn, "%s/%s/authpf.rules",
		    PATH_USER_DIR, luser) == -1)
			goto no_mem;
		if (stat(fn, &sb) == -1) {
			free(fn);
			if(asprintf(&fn, "%s/%s/authpf.rules", PATH_GROUP_DIR,
				grent->gr_name) == -1)
				goto no_mem;
			if(stat(fn, &sb) == -1) {
				free(fn);
				if ((fn = strdup(PATH_PFRULES)) == NULL)
					goto no_mem;
			}
		}
		pargv[2] = fdpath;
		pargv[5] = rsn;
		pargv[7] = userstr;
		if (user_ip) {
			pargv[9] = ipstr;
			pargv[11] = fn;
		} else {
			pargv[8] = "-f";
			pargv[9] = fn;
			pargv[10] = NULL;
		}

		switch (pid = fork()) {
		case -1:
			syslog(LOG_ERR, "fork failed");
			goto error;
		case 0:
			/* revoke group privs before exec */
			gid = getgid();
			if (setresgid(gid, gid, gid) == -1) {
				err(1, "setregid");
			}
			execvp(PATH_PFCTL, pargv);
			warn("exec of %s failed", PATH_PFCTL);
			_exit(1);
		}

		/* parent */
		waitpid(pid, &s, 0);
		if (s != 0) {
			syslog(LOG_ERR, "pfctl exited abnormally");
			goto error;
		}

		gettimeofday(&Tstart, NULL);
		syslog(LOG_INFO, "allowing %s, user %s", ipsrc, luser);
	} else {
		remove_stale_rulesets();

		gettimeofday(&Tend, NULL);
		syslog(LOG_INFO, "removed %s, user %s - duration %d seconds",
		    ipsrc, luser, (int)(Tend.tv_sec - Tstart.tv_sec));
	}
	return (0);
no_mem:
	syslog(LOG_ERR, "malloc failed");
error:
	free(fdpath);
	free(rsn);
	free(userstr);
	free(ipstr);
	free(fn);
	return (-1);
}

/*
 * Add/remove this IP from the "authpf_users" table.
 */
static int
change_table(int add, const char *ipsrc)
{
	struct pfioc_table	io;
	struct pfr_addr		addr;

	bzero(&io, sizeof(io));
	strlcpy(io.pfrio_table.pfrt_name, tablename,
	    sizeof(io.pfrio_table.pfrt_name));
	io.pfrio_buffer = &addr;
	io.pfrio_esize = sizeof(addr);
	io.pfrio_size = 1;

	bzero(&addr, sizeof(addr));
	if (ipsrc == NULL || !ipsrc[0])
		return (-1);
	if (inet_pton(AF_INET, ipsrc, &addr.pfra_ip4addr) == 1) {
		addr.pfra_af = AF_INET;
		addr.pfra_net = 32;
	} else if (inet_pton(AF_INET6, ipsrc, &addr.pfra_ip6addr) == 1) {
		addr.pfra_af = AF_INET6;
		addr.pfra_net = 128;
	} else {
		syslog(LOG_ERR, "invalid ipsrc");
		return (-1);
	}

	if (ioctl(dev, add ? DIOCRADDADDRS : DIOCRDELADDRS, &io) &&
	    errno != ESRCH) {
		syslog(LOG_ERR, "cannot %s %s from table %s: %s",
		    add ? "add" : "remove", ipsrc, tablename,
		    strerror(errno));
		return (-1);
	}
	return (0);
}

/*
 * This is to kill off states that would otherwise be left behind stateful
 * rules. This means we don't need to allow in more traffic than we really
 * want to, since we don't have to worry about any luser sessions lasting
 * longer than their ssh session. This function is based on
 * pfctl_kill_states from pfctl.
 */
static void
authpf_kill_states(void)
{
	struct pfioc_state_kill	psk;
	struct pf_addr target;

	memset(&psk, 0, sizeof(psk));
	memset(&target, 0, sizeof(target));

	if (inet_pton(AF_INET, ipsrc, &target.v4) == 1)
		psk.psk_af = AF_INET;
	else if (inet_pton(AF_INET6, ipsrc, &target.v6) == 1)
		psk.psk_af = AF_INET6;
	else {
		syslog(LOG_ERR, "inet_pton(%s) failed", ipsrc);
		return;
	}

	/* Kill all states from ipsrc */
	memcpy(&psk.psk_src.addr.v.a.addr, &target,
	    sizeof(psk.psk_src.addr.v.a.addr));
	memset(&psk.psk_src.addr.v.a.mask, 0xff,
	    sizeof(psk.psk_src.addr.v.a.mask));
	if (ioctl(dev, DIOCKILLSTATES, &psk))
		syslog(LOG_ERR, "DIOCKILLSTATES failed (%m)");

	/* Kill all states to ipsrc */
	memset(&psk.psk_src, 0, sizeof(psk.psk_src));
	memcpy(&psk.psk_dst.addr.v.a.addr, &target,
	    sizeof(psk.psk_dst.addr.v.a.addr));
	memset(&psk.psk_dst.addr.v.a.mask, 0xff,
	    sizeof(psk.psk_dst.addr.v.a.mask));
	if (ioctl(dev, DIOCKILLSTATES, &psk))
		syslog(LOG_ERR, "DIOCKILLSTATES failed (%m)");
}

/* signal handler that makes us go away properly */
static void
need_death(int signo)
{
	want_death = 1;
}

/*
 * function that removes our stuff when we go away.
 */
static __dead void
do_death(int active)
{
	int	ret = 0;

	if (active) {
		change_filter(0, luser, ipsrc);
		if (user_ip) {
			change_table(0, ipsrc);
			authpf_kill_states();
		}
	}
	if (pidfile[0] && pidfd != -1)
		if (unlink(pidfile) == -1)
			syslog(LOG_ERR, "cannot unlink %s (%m)", pidfile);
	exit(ret);
}
@


1.124
log
@Remove a NULL-check before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.123 2015/01/21 21:50:32 deraadt Exp $	*/
a344 1
	/* NOTREACHED */
d758 1
@


1.123
log
@Include <netinet/in.h> before <net/pfvar.h>.  In a future change when
ports is ready, <net/pfvar.h> will stop including a pile of balony.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.122 2015/01/15 23:59:28 deraadt Exp $	*/
d549 2
a550 4
			if (lbuf != NULL) {
				free(lbuf);
				lbuf = NULL;
			}
@


1.122
log
@switch to PATH_MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.121 2014/10/08 02:11:54 deraadt Exp $	*/
d27 2
a30 1
#include <arpa/inet.h>
@


1.121
log
@remove stupid cast
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.120 2014/04/02 02:12:24 deraadt Exp $	*/
d57 1
a57 1
char	rulesetname[MAXPATHLEN - PF_ANCHOR_NAME_SIZE - 2];
d63 1
a63 1
char	 luser[MAXLOGNAME];	/* username */
d65 1
a65 1
char	 pidfile[MAXPATHLEN];	/* we save pid in this file. */
d216 1
a216 1
		char	otherluser[MAXLOGNAME];
d494 2
a495 2
		int gl_init = 0, ngroups = NGROUPS + 1;
		gid_t groups[NGROUPS + 1];
d585 1
a585 1
	char	 tmp[MAXPATHLEN];
@


1.120
log
@use setresgid()
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.119 2013/04/02 06:04:50 guenther Exp $	*/
d505 1
a505 1
				if ((lbuf = (char *)malloc(len + 1)) == NULL)
@


1.119
log
@Handle big time_t

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.118 2013/01/19 16:58:16 miod Exp $	*/
d808 1
a808 1
			if (setregid(gid, gid) == -1) {
@


1.118
log
@fix build with gcc 2
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.117 2013/01/15 23:03:37 beck Exp $	*/
d829 2
a830 2
		syslog(LOG_INFO, "removed %s, user %s - duration %ld seconds",
		    ipsrc, luser, Tend.tv_sec - Tstart.tv_sec);
@


1.117
log
@Per group support for authpf rules files in /etc/authpf/groups.
largely by Frank Timmers <frankt@@smurfnet.eu> with fixups by me
and jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.116 2012/07/07 12:55:29 claudio Exp $	*/
d752 5
a760 5

		char	*pargv[13] = {
			"pfctl", "-p", "/dev/pf", "-q", "-a", "anchor/ruleset",
			"-D", "user_id=X", "-D", "user_ip=X", "-f", "file", NULL
		};
@


1.116
log
@Fix file descriptor leak reported by someone on the mailing list long time
ago. OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.115 2010/09/02 14:01:04 sobrado Exp $	*/
d751 6
d780 2
a781 1
			if ((fn = strdup(PATH_PFRULES)) == NULL)
d783 5
@


1.115
log
@remove trailing spaces and tabs; no binary change.

written with help from henning@@, who suggested ensuring that there
are no changes in the digests for object files, thanks!

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.114 2010/01/27 15:36:17 todd Exp $	*/
d526 1
d553 2
a554 1
			if (matched)
d556 1
d566 1
@


1.114
log
@search for authpf.message in $USER dirs also
from Rafal Bisingier ravbc at man dot pozman dot pl, ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.113 2009/11/23 00:47:56 claudio Exp $	*/
d150 1
a150 1
	if (strcmp(shell, PATH_AUTHPF_SHELL) && 
d275 1
a275 1
	
d501 1
a501 1
			
d518 1
a518 1
				int cnt; 
d534 1
a534 1
			
@


1.113
log
@Make the tree compile again. Henning and I are both quite sure this is
correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.112 2009/01/10 19:08:53 miod Exp $	*/
d323 2
d328 9
a336 1
		print_message(PATH_MESSAGE);
@


1.112
log
@Uninitialized variable introduced in 1.110.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.111 2009/01/10 17:17:32 todd Exp $	*/
a670 2
	int			  i;

d676 1
a676 2
	if ((t_e = calloc(PF_RULESET_MAX+1,
	    sizeof(struct pfioc_trans_e))) == NULL)
d678 1
a678 1
	t->size = PF_RULESET_MAX+1;
d681 4
a684 5
	for (i = 0; i < PF_RULESET_MAX+1; ++i) {
		t_e[i].rs_num = i;
		snprintf(t_e[i].anchor, sizeof(t_e[i].anchor), "%s/%s", an, rs);
	}
	t_e[PF_RULESET_MAX].rs_num = PF_RULESET_TABLE;
@


1.111
log
@variable declaration before use, found by vax, no cookie
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.110 2009/01/06 03:11:50 mcbride Exp $	*/
d486 1
d488 1
@


1.110
log
@Support group and login class in authpf.allow (%<group>, @@<class>)

ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.109 2008/10/07 17:27:17 deraadt Exp $	*/
a483 1
		lbuf = NULL;
d486 1
@


1.109
log
@protect better against races from incoming signals; slightly changed
from 5394 by tracking the fd instead of the fp.
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.108 2008/10/05 21:10:14 deraadt Exp $	*/
d35 1
d47 1
a47 1
static int	allowed_luser(char *);
d291 1
a291 1
	if (!check_luser(PATH_BAN_DIR, luser) || !allowed_luser(luser)) {
d443 1
d452 1
a452 1
allowed_luser(char *luser)
d485 3
d489 1
d500 34
a533 1
			matched = strcmp(luser, buf) == 0 || strcmp("*", buf) == 0;
d541 1
a541 1
				return (1); /* matched an allowed username */
d544 1
a544 1
		    luser, PATH_ALLOWFILE);
@


1.108
log
@grammar; PR 5394
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.107 2008/02/14 01:49:17 mcbride Exp $	*/
d61 1
d82 1
a82 1
	int		 lockcnt = 0, n, pidfd;
d190 8
d251 1
a251 1
		 * we try to kill the previous process and acquire the lock
d253 1
a253 1
		 * 10 attempts we log an error and give up
d255 4
a258 3
		if (++lockcnt > 10) {
			syslog(LOG_ERR, "cannot kill previous authpf (pid %d)",
			    otherpid);
d261 1
d272 1
a320 7
	signal(SIGTERM, need_death);
	signal(SIGINT, need_death);
	signal(SIGALRM, need_death);
	signal(SIGPIPE, need_death);
	signal(SIGHUP, need_death);
	signal(SIGQUIT, need_death);
	signal(SIGTSTP, need_death);
d886 1
a886 1
	if (pidfile[0] && (pidfp != NULL))
@


1.107
log
@Add authpf-noip, which allows multiple users to connect from a single IP;
forces users to write sane rulesets for this by not providing $user_ip or
updating the authpf table.

testing and prodding by mtu, manpage heavily worked over by jmc
ok beck dhartmei henning
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.106 2008/02/01 07:08:03 mcbride Exp $	*/
d96 1
a96 1
		syslog(LOG_ERR, "can not open %s (%m)", PATH_CONFFILE);
@


1.106
log
@Clean anchors recursively and directly via ioctls rather than using pfctl
with '-f /dev/null'.  Properly clears the user's anchor even when anchors
are nested inside it (And avoids having to fork() on exit to run pfctl)

ok beck@@, with testing by mtu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.105 2007/09/25 11:20:34 chl Exp $	*/
d58 1
d70 1
d91 3
d148 2
a149 1
	if (strcmp(shell, PATH_AUTHPF_SHELL)) {
d181 3
a183 2
	/* Make our entry in /var/authpf as /var/authpf/ipaddr */
	n = snprintf(pidfile, sizeof(pidfile), "%s/%s", PATH_PIDFILE, ipsrc);
d303 1
a303 1
	if (change_table(1, ipsrc) == -1) {
a686 5
	char	*pargv[13] = {
		"pfctl", "-p", "/dev/pf", "-q", "-a", "anchor/ruleset",
		"-D", "user_ip=X", "-D", "user_id=X", "-f",
		"file", NULL
	};
d695 4
d724 8
a731 2
		pargv[9] = ipstr;
		pargv[11] = fn;
d876 4
a879 2
		change_table(0, ipsrc);
		authpf_kill_states();
@


1.105
log
@handle empty strings returned by fgets

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.104 2007/02/24 17:35:08 beck Exp $	*/
d49 1
d575 1
a575 1
	u_int32_t		 nr, mnr;
d586 2
a587 3
	mnr = prs.nr;
	nr = 0;
	while (nr < mnr) {
d591 1
a591 1
		prs.nr = nr;
d603 2
a604 19
		if (kill(pid, 0) && errno != EPERM) {
			int			i;
			struct pfioc_trans_e	t_e[PF_RULESET_MAX+1];
			struct pfioc_trans	t;

			bzero(&t, sizeof(t));
			bzero(t_e, sizeof(t_e));
			t.size = PF_RULESET_MAX+1;
			t.esize = sizeof(t_e[0]);
			t.array = t_e;
			for (i = 0; i < PF_RULESET_MAX+1; ++i) {
				t_e[i].rs_num = i;
				snprintf(t_e[i].anchor, sizeof(t_e[i].anchor),
				    "%s/%s", anchorname, prs.name);
			}
			t_e[PF_RULESET_MAX].rs_num = PF_RULESET_TABLE;
			if ((ioctl(dev, DIOCXBEGIN, &t) ||
			    ioctl(dev, DIOCXCOMMIT, &t)) &&
			    errno != EINVAL)
d606 2
a607 3
			mnr--;
		} else
			nr++;
d612 62
a690 14
	if (luser == NULL || !luser[0] || ipsrc == NULL || !ipsrc[0]) {
		syslog(LOG_ERR, "invalid luser/ipsrc");
		goto error;
	}

	if (asprintf(&rsn, "%s/%s", anchorname, rulesetname) == -1)
		goto no_mem;
	if (asprintf(&fdpath, "/dev/fd/%d", dev) == -1)
		goto no_mem;
	if (asprintf(&ipstr, "user_ip=%s", ipsrc) == -1)
		goto no_mem;
	if (asprintf(&userstr, "user_id=%s", luser) == -1)
		goto no_mem;

d694 15
a708 2
		if (asprintf(&fn, "%s/%s/authpf.rules", PATH_USER_DIR, luser)
		    == -1)
d715 4
a718 8
	}
	pargv[2] = fdpath;
	pargv[5] = rsn;
	pargv[7] = userstr;
	pargv[9] = ipstr;
	if (!add)
		pargv[11] = "/dev/null";
	else
d721 21
a741 21
	switch (pid = fork()) {
	case -1:
		syslog(LOG_ERR, "fork failed");
		goto error;
	case 0:
		/* revoke group privs before exec */
		gid = getgid();
		if (setregid(gid, gid) == -1) {
			err(1, "setregid");
		}
		execvp(PATH_PFCTL, pargv);
		warn("exec of %s failed", PATH_PFCTL);
		_exit(1);
	}

	/* parent */
	waitpid(pid, &s, 0);
	if (s != 0) {
		syslog(LOG_ERR, "pfctl exited abnormally");
		goto error;
	}
a742 1
	if (add) {
d746 2
a865 1
		remove_stale_rulesets();
@


1.104
log
@exit right away if the config file isn't there, rather than
doing a whole bunch of needless screwing around
noticed by Stefan Krah <stefan-usenet@@bytereef.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.103 2007/02/24 17:21:04 beck Exp $	*/
d352 2
@


1.103
log
@license + copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.102 2007/02/24 17:14:26 beck Exp $	*/
d89 4
d275 2
a276 2
	if (config == NULL || read_config(config)) {
		syslog(LOG_INFO, "bad or nonexistent %s", PATH_CONFFILE);
@


1.102
log
@Pr 5395 from Stefan Krah <stefan-usenet@@bytereef.org>
cleanup:
remove unused arg
no need to clear locals
return -1 to allow pid cleanup to happen if fork fails
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.101 2007/02/22 21:54:23 beck Exp $	*/
d4 1
a4 1
 * Copyright (C) 1998 - 2002 Bob Beck (beck@@openbsd.org).
d6 3
a8 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d10 7
a16 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.101
log
@this ftruncate is really not needed now, if we're just unlinking.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.100 2007/02/22 21:15:41 beck Exp $	*/
d59 1
a59 1
static int	change_table(int, const char *, const char *);
d300 1
a300 1
	if (change_table(1, luser, ipsrc) == -1) {
d687 2
a688 1
		err(1, "fork failed");
d703 2
a704 4
		if (WIFEXITED(s)) {
			syslog(LOG_ERR, "pfctl exited abnormally");
			goto error;
		}
a719 1
	fdpath = NULL;
a720 1
	rsn = NULL;
a721 1
	userstr = NULL;
a722 1
	ipstr = NULL;
a723 1
	fn = NULL;
d731 1
a731 1
change_table(int add, const char *luser, const char *ipsrc)
d827 1
a827 1
		change_table(0, luser, ipsrc);
@


1.100
log
@close 5389 and 5390,
unused variable and a chance to unlink the pidfile without lock
if we couldn't kill a preexisting authpf process.
spotted by Stefan Krah <sfk1@@bigfoot.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.99 2006/08/09 16:21:39 dhartmei Exp $	*/
a836 2
	if (pidfp != NULL) 
		ftruncate(fileno(pidfp), 0);
@


1.99
log
@handle SIGQUIT instead of SIGSTOP, from Stefan Krah
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.98 2006/03/17 22:00:27 deraadt Exp $	*/
a52 2
extern int	symset(const char *, const char *, int);

a67 1
char	*infile;		/* file name printed by yyerror() in parse.y */
d246 2
d257 1
a729 1
	infile = NULL;
d837 1
a837 1
	if (pidfp)
d839 1
a839 1
	if (pidfile[0])
@


1.98
log
@FILE * leak
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.97 2006/03/14 21:45:14 beck Exp $	*/
d311 1
a311 1
	signal(SIGSTOP, need_death);
@


1.97
log
@fix incorrect sizeof(), spotted by ckuethe
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.96 2005/12/12 16:06:01 beck Exp $	*/
d559 1
d563 1
@


1.96
log
@correct err() usage and remove the do_death which is unneeded in
the child proceess, (as noticed by <evol@@online.ptt.ru>)
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.95 2005/12/12 16:02:32 beck Exp $	*/
d742 2
a743 1
	strlcpy(io.pfrio_table.pfrt_name, tablename, sizeof(io.pfrio_table));
@


1.95
log
@Backout previous change back to 1.92 - My fault, committed diff
from unclean tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.92 2005/12/08 23:03:11 beck Exp $	*/
d690 1
a690 2
			err(1, "setregid: %s", strerror(errno));
			do_death(0);
@


1.94
log
@Mine, so modernize license
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.93 2005/12/09 23:41:57 beck Exp $	*/
d4 1
a4 1
 * Copyright (C) 1998 - 2005 Bob Beck (beck@@openbsd.org).
d6 8
a13 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d15 11
a25 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d443 1
a443 1
	int	 matched = 0;
d492 1
a492 1
				goto done; /* matched an allowed username */
a500 2
done:
	fclose(f);
d502 1
a502 1
	return (matched);
d507 1
a507 1
 * from using us by virtue of having a file of the same name
a562 1
	fclose(f);
a643 1
	int 	ret = -1;
d650 1
a650 1
		goto done;
d690 2
a691 1
			err(1, "setregid failed:");
d703 1
a703 1
			goto done;
d715 1
a715 2
	ret = 0;
	goto done;
d718 1
a718 1
done:
d730 1
a730 1
	return (ret);
@


1.93
log
@calling do_death() after err makes us exit is not smart, and is in
fact unnecessary, my usage of err() here also repeated the formatted
error message twice. - We don't need do_death() here, and fix err
to print the message a bit more sanely.
Noticed by Andrey Matveev <evol@@online.ptt.ru> - Thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.92 2005/12/08 23:03:11 beck Exp $	*/
d4 1
a4 1
 * Copyright (C) 1998 - 2002 Bob Beck (beck@@openbsd.org).
d6 3
a8 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d10 7
a16 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.92
log
@make authpf give up group privs before exec'ing pfctl - makes it
so the new taint enforcement for /dev/fd/X opens don't kill it
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.91 2005/05/23 22:50:23 henning Exp $	*/
d443 1
a443 1
	int	 matched;
d492 1
a492 1
				return (1); /* matched an allowed username */
d501 2
d504 1
a504 1
	return (0);
d509 1
a509 1
 * from using us by virtue of having an file of the same name
d565 1
d647 1
d654 1
a654 1
		goto error;
d694 1
a694 2
			err(1, "setregid: %s", strerror(errno));
			do_death(0);
d706 1
a706 1
			goto error;
d718 2
a719 1
	return (0);
d722 1
a722 1
error:
d734 1
a734 1
	return (-1);
@


1.91
log
@useless endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.90 2005/05/02 02:29:26 djm Exp $	*/
d95 1
d259 7
a272 1

d645 1
d687 6
@


1.91.2.1
log
@MFC:
Fix by beck@@

make authpf give up group privs before exec'ing pfctl - makes it
so the new taint enforcement for /dev/fd/X opens don't kill it

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.91 2005/05/23 22:50:23 henning Exp $	*/
a94 1
	gid_t		 gid;
a258 7
	/* whack the group list */
	gid = getegid();
	if (setgroups(1, &gid) == -1) {
		syslog(LOG_INFO, "setgroups: %s", strerror(errno));
		do_death(0);
	}

d265 1
a637 1
	gid_t	gid;
a678 5
		/* revoke group privs before exec */
		gid = getgid();
		if (setregid(gid, gid) == -1) {
			err(1, "setregid");
		}
@


1.90
log
@more setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.89 2005/02/10 04:24:15 joel Exp $	*/
a135 1
	endpwent();
@


1.89
log
@Minor punctuation nit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.88 2005/01/31 15:08:50 henning Exp $	*/
d261 5
a265 2
	seteuid(getuid());
	setuid(getuid());
@


1.89.2.1
log
@MFC:
Fix by beck@@

make authpf give up group privs before exec'ing pfctl - makes it
so the new taint enforcement for /dev/fd/X opens don't kill it

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.89 2005/02/10 04:24:15 joel Exp $	*/
a94 1
	gid_t		 gid;
a259 7
	/* whack the group list */
	gid = getegid();
	if (setgroups(1, &gid) == -1) {
		syslog(LOG_INFO, "setgroups: %s", strerror(errno));
		do_death(0);
	}

d263 1
a635 1
	gid_t	gid;
a676 5
		/* revoke group privs before exec */
		gid = getgid();
		if (setregid(gid, gid) == -1) {
			err(1, "setregid");
		}
@


1.88
log
@warn(3) + _exit(2) instead of err(3) in the forked child
From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.87 2005/01/31 15:06:31 henning Exp $	*/
d305 1
a305 1
		printf("\r\nHello %s, ", luser);
@


1.87
log
@-Wsign-compare clean, Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.86 2004/09/16 18:34:05 deraadt Exp $	*/
d678 2
a679 1
		err(1, "exec of %s failed", PATH_PFCTL);
@


1.86
log
@ftruncate() with ftello() instead of ftell(); ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.85 2004/08/08 00:05:09 deraadt Exp $	*/
d171 1
a171 1
	    luser, (long)getpid())) < 0 || n >= sizeof(rulesetname)) {
d175 1
a175 1
		    (long)getpid())) < 0 || n >= sizeof(rulesetname)) {
@


1.85
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.84 2004/06/14 20:38:19 cedric Exp $	*/
d285 1
a285 1
	(void) ftruncate(fileno(pidfp), ftell(pidfp));
@


1.84
log
@Use new ioctls. ok beck@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.83 2004/05/21 23:10:49 dhartmei Exp $	*/
d149 1
a149 1
	
@


1.83
log
@Use '/' instead of ':' as separator for anchor path components. Note that
the parser now needs quotes around paths containing separators.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.82 2004/05/19 17:50:52 dhartmei Exp $	*/
a565 2
	const int		 action[PF_RULESET_MAX] = { PF_SCRUB,
				    PF_PASS, PF_NAT, PF_BINAT, PF_RDR };
d596 12
a607 7
			int i;

			for (i = 0; i < PF_RULESET_MAX; ++i) {
				struct pfioc_rule pr;

				memset(&pr, 0, sizeof(pr));
				snprintf(pr.anchor, sizeof(pr.anchor),
a608 5
				pr.rule.action = action[i];
				if ((ioctl(dev, DIOCBEGINRULES, &pr) ||
				    ioctl(dev, DIOCCOMMITRULES, &pr)) &&
				    errno != EINVAL)
					return (1);
d610 5
@


1.82
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.81 2004/05/13 17:14:55 henning Exp $	*/
d605 1
a605 1
				    "%s:%s", anchorname, prs.name);
d626 1
a626 1
		"pfctl", "-p", "/dev/pf", "-q", "-a", "anchor:ruleset",
d640 1
a640 1
	if (asprintf(&rsn, "%s:%s", anchorname, rulesetname) == -1)
@


1.81
log
@as the authpf manpage describes, the connecting user's shell can be
overloaded via login.conf. When verifying that the user's login shell is
indeed authpf it is not sufficient to look at (struct passwd)->pw_shell,
we also have to use login_getclass etc to check wether the shell gets
overloaded.
ok millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.80 2004/04/28 05:06:13 cedric Exp $	*/
d66 1
a67 1
char	rulesetname[PF_RULESET_NAME_SIZE];
d571 1
a571 1
	strlcpy(prs.anchor, anchorname, sizeof(prs.anchor));
d604 2
a605 2
				memcpy(pr.anchor, prs.anchor, sizeof(pr.anchor));
				memcpy(pr.ruleset, prs.name, sizeof(pr.ruleset));
@


1.80
log
@Put authpf user's IP addresses in the <authpf_users> table.
ok deraadt@@ dhartmei@@ markus@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.79 2004/04/28 00:22:39 djm Exp $	*/
d42 1
d96 2
d136 1
d141 10
a150 1
	if (strcmp(pw->pw_shell, PATH_AUTHPF_SHELL)) {
d153 2
d157 3
@


1.79
log
@IPv6 support; ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.78 2004/04/25 19:24:52 deraadt Exp $	*/
d60 1
d65 1
d273 5
d360 5
d696 39
d794 1
@


1.78
log
@clean; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.77 2004/04/25 18:40:42 beck Exp $	*/
d89 1
a89 1
	struct in_addr	 ina;
d116 2
a117 1
	if (inet_pton(AF_INET, ipsrc, &ina) != 1) {
d694 1
a694 1
	struct in_addr		target;
d697 1
a697 1
	psk.psk_af = AF_INET;
d699 8
a706 1
	inet_pton(AF_INET, ipsrc, &target);
d709 2
a710 1
	psk.psk_src.addr.v.a.addr.v4 = target;
a716 1
	psk.psk_af = AF_INET;
d718 2
a719 1
	psk.psk_dst.addr.v.a.addr.v4 = target;
@


1.77
log
@Make authpf exec pfctl instead of sucking in code from pfctl
ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.76 2004/04/09 12:42:06 cedric Exp $	*/
d594 1
a594 1
	char	*pargv[13]= {
d599 4
a602 6
	char	*fdpath = NULL;
	char	*userstr= NULL;
	char	*ipstr = NULL;
	char	*rsn = NULL;
	char	*fn = NULL;
	int	pid, s;
d620 1
d634 5
a638 5
	if (!add) {
		pargv[11]="/dev/null";
	} else {
		pargv[11]=fn;
	}
d646 1
d655 1
a655 1
		
@


1.76
log
@Do not try to load directories. found+ok mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.75 2004/01/29 01:55:10 deraadt Exp $	*/
d32 1
d34 1
a49 3
#include <pfctl_parser.h>
#include <pfctl.h>

d594 11
a604 5
	char			 fn[MAXPATHLEN];
	FILE			*f = NULL;
	struct pfctl		 pf;
	struct pfr_buffer	 t;
	int			 i;
d611 9
d621 18
a638 20
		if ((i = snprintf(fn, sizeof(fn), "%s/%s/authpf.rules",
		    PATH_USER_DIR, luser)) < 0 || i >= sizeof(fn)) {
			syslog(LOG_ERR, "user rule path too long");
			goto error;
		}
		if ((f = fopen(fn, "r")) == NULL && errno != ENOENT) {
			syslog(LOG_ERR, "cannot open %s (%m)", fn);
			goto error;
		}
		if (f == NULL) {
			if (strlcpy(fn, PATH_PFRULES, sizeof(fn)) >=
			    sizeof(fn)) {
				syslog(LOG_ERR, "rule path too long");
				goto error;
			}
			if ((f = fopen(fn, "r")) == NULL) {
				syslog(LOG_ERR, "cannot open %s (%m)", fn);
				goto error;
			}
		}
d640 12
a651 11

	if (pfctl_load_fingerprints(dev, 0)) {
		syslog(LOG_ERR, "unable to load kernel's OS fingerprints");
		goto error;
	}
	bzero(&t, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	memset(&pf, 0, sizeof(pf));
	for (i = 0; i < PF_RULESET_MAX; ++i) {
		if (pfctl_add_trans(&t, i, anchorname, rulesetname)) {
			syslog(LOG_ERR, "pfctl_add_trans %m");
d655 1
a655 34
	if (pfctl_trans(dev, &t, DIOCXBEGIN, 0)) {
		syslog(LOG_ERR, "DIOCXBEGIN (%s) %m", add?"add":"remove");
		goto error;
	}

	if (add) {
		if (symset("user_ip", ipsrc, 0) ||
		    symset("user_id", luser, 0)) {
			syslog(LOG_ERR, "symset");
			goto error;
		}

		pf.dev = dev;
		pf.trans = &t;
		pf.anchor = anchorname;
		pf.ruleset = rulesetname;

		infile = fn;
		if (parse_rules(f, &pf) < 0) {
			syslog(LOG_ERR, "syntax error in rule file: "
			    "authpf rules not loaded");
			goto error;
		}

		infile = NULL;
		fclose(f);
		f = NULL;
	}

	if (pfctl_trans(dev, &t, DIOCXCOMMIT, 0)) {
		syslog(LOG_ERR, "DIOCXCOMMIT (%s) %m", add?"add":"remove");
		goto error;
	}

d665 2
a666 1

d668 10
a677 5
	if (f != NULL)
		fclose(f);
	if (pfctl_trans(dev, &t, DIOCXROLLBACK, 0))
		syslog(LOG_ERR, "DIOCXROLLBACK (%s) %m", add?"add":"remove");

a742 160
}

/*
 * callbacks for parse_rules(void)
 */

int
pfctl_add_rule(struct pfctl *pf, struct pf_rule *r)
{
	u_int8_t		rs_num;
	struct pfioc_rule	pr;

	switch (r->action) {
	case PF_PASS:
	case PF_DROP:
		rs_num = PF_RULESET_FILTER;
		break;
	case PF_SCRUB:
		rs_num = PF_RULESET_SCRUB;
		break;
	case PF_NAT:
	case PF_NONAT:
		rs_num = PF_RULESET_NAT;
		break;
	case PF_RDR:
	case PF_NORDR:
		rs_num = PF_RULESET_RDR;
		break;
	case PF_BINAT:
	case PF_NOBINAT:
		rs_num = PF_RULESET_BINAT;
		break;
	default:
		syslog(LOG_ERR, "invalid rule action %d", r->action);
		return (1);
	}

	bzero(&pr, sizeof(pr));
	strlcpy(pr.anchor, pf->anchor, sizeof(pr.anchor));
	strlcpy(pr.ruleset, pf->ruleset, sizeof(pr.ruleset));
	if (pfctl_add_pool(pf, &r->rpool, r->af))
		return (1);
	pr.ticket = pfctl_get_ticket(pf->trans, rs_num, pf->anchor,
	    pf->ruleset);
	pr.pool_ticket = pf->paddr.ticket;
	memcpy(&pr.rule, r, sizeof(pr.rule));
	if (ioctl(pf->dev, DIOCADDRULE, &pr)) {
		syslog(LOG_ERR, "DIOCADDRULE %m");
		return (1);
	}
	pfctl_clear_pool(&r->rpool);
	return (0);
}

int
pfctl_add_pool(struct pfctl *pf, struct pf_pool *p, sa_family_t af)
{
	struct pf_pooladdr	*pa;

	if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr)) {
		syslog(LOG_ERR, "DIOCBEGINADDRS %m");
		return (1);
	}
	pf->paddr.af = af;
	TAILQ_FOREACH(pa, &p->list, entries) {
		memcpy(&pf->paddr.addr, pa, sizeof(struct pf_pooladdr));
		if (ioctl(pf->dev, DIOCADDADDR, &pf->paddr)) {
			syslog(LOG_ERR, "DIOCADDADDR %m");
			return (1);
		}
	}
	return (0);
}

void
pfctl_clear_pool(struct pf_pool *pool)
{
	struct pf_pooladdr	*pa;

	while ((pa = TAILQ_FIRST(&pool->list)) != NULL) {
		TAILQ_REMOVE(&pool->list, pa, entries);
		free(pa);
	}
}

int
pfctl_add_altq(struct pfctl *pf, struct pf_altq *a)
{
	fprintf(stderr, "altq rules not supported in authpf\n");
	return (1);
}

int
pfctl_set_optimization(struct pfctl *pf, const char *opt)
{
	fprintf(stderr, "set optimization not supported in authpf\n");
	return (1);
}

int
pfctl_set_logif(struct pfctl *pf, char *ifname)
{
	fprintf(stderr, "set loginterface not supported in authpf\n");
	return (1);
}

int
pfctl_set_hostid(struct pfctl *pf, u_int32_t hostid)
{
	fprintf(stderr, "set hostid not supported in authpf\n");
	return (1);
}

int
pfctl_set_timeout(struct pfctl *pf, const char *opt, int seconds, int quiet)
{
	fprintf(stderr, "set timeout not supported in authpf\n");
	return (1);
}

int
pfctl_set_limit(struct pfctl *pf, const char *opt, unsigned int limit)
{
	fprintf(stderr, "set limit not supported in authpf\n");
	return (1);
}

int
pfctl_set_debug(struct pfctl *pf, char *d)
{
	fprintf(stderr, "set debug not supported in authpf\n");
	return (1);
}

int
pfctl_define_table(char *name, int flags, int addrs, const char *anchor,
    const char *ruleset, struct pfr_buffer *ab, u_int32_t ticket)
{
	fprintf(stderr, "table definitions not yet supported in authpf\n");
	return (1);
}

int
pfctl_rules(int dev, char *filename, int opts, char *anchorname,
    char *rulesetname, struct pfr_buffer *t)
{
	/* never called, no anchors inside anchors, but we need the stub */
	fprintf(stderr, "load anchor not supported from authpf\n");
	return (1);
}

void
pfctl_print_title(char *title)
{
}

FILE *
pfctl_fopen(const char *name, const char *mode)
{
	return fopen(name, mode);
@


1.75
log
@MORE BULLSHIT BECAUSE THIS PIECE OF SHIT IS INTERTWINED WITH PFCTL
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.74 2004/01/13 17:31:15 dhartmei Exp $	*/
d911 6
@


1.74
log
@handle ruleset names containing usernames, fixes PR 3627, ok Bob
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.73 2003/12/15 07:11:31 mcbride Exp $	*/
d908 4
@


1.73
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.72 2003/12/10 04:10:37 beck Exp $	*/
d552 1
a552 1
		char	*s;
d559 7
a565 2
		pid = strtoul(prs.name, &s, 10);
		if (!prs.name[0] || errno || *s)
@


1.72
log
@- fix a few exit cases that would exit with no log
- add username to added ruleset names when possible
- add much needed example to man page showing how to use NAT with tagging
  to track NATed authpfed connections.
ok henning@@ dhartmei@@, man page cleanup by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.71 2003/11/14 15:31:07 henning Exp $	*/
d855 7
@


1.71
log
@catch up with pfctl changes
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.70 2003/09/26 21:44:09 cedric Exp $	*/
a94 6
	if ((n = snprintf(rulesetname, sizeof(rulesetname), "%ld",
	    (long)getpid())) < 0 || n >= sizeof(rulesetname)) {
		syslog(LOG_ERR, "pid too large for ruleset name");
		exit(1);
	}

a121 1

d150 12
d244 4
a247 1
	if (!check_luser(PATH_BAN_DIR, luser) || !allowed_luser(luser))
d249 1
d251 2
a252 2
	openlog("authpf", LOG_PID | LOG_NDELAY, LOG_DAEMON);
	if (config == NULL || read_config(config))
d254 1
d256 2
a257 1
	if (remove_stale_rulesets())
d259 1
@


1.70
log
@Rearchitecture of the userland/kernel IOCTL interface for transactions.
This brings us close to 100% atomicity for a "pfctl -f pf.conf" command.
(some splxxx work remain in the kernel). Basically, improvements are:

   - Anchors/Rulesets cannot disappear unexpectedly anymore.
   - No more leftover in the kernel if "pfctl -f" fail.
   - Commit is now done in a single atomic IOCTL.

WARNING: The kernel code is fully backward compatible, but the new
pfctl/authpf userland utilities will only run on a new kernel.

The following ioctls are deprecated (i.e. will be deleted sooner or
later, depending on how many 3rd party utilities use them and how soon
they can be upgraded):

   - DIOCBEGINRULES
   - DIOCCOMMITRULES
   - DIOCBEGINALTQS
   - DIOCCOMMITALTQS
   - DIOCRINABEGIN
   - DIOCRINADEFINE

They are replaced by the following ioctls (yes, PF(4) will follow)
which operate on a vector of rulesets:

   - DIOCXBEGIN
   - DIOCXCOMMIT
   - DIOCXROLLBACK

Ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.69 2003/09/26 07:24:10 henning Exp $	*/
d857 7
@


1.69
log
@erm, committing to teh right repository helps sometimes.
don't reject usernames > 15 chars; username is not used as ruleset name any
more, thus, this restriction is gone.
PR3491, fix from dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.68 2003/08/21 19:13:23 frantzen Exp $	*/
d49 1
d257 1
a257 1
		do_death(1);
a579 2
	const int		 action[PF_RULESET_MAX] = { PF_SCRUB,
				    PF_PASS, PF_NAT, PF_BINAT, PF_RDR };
d581 1
a581 1
	struct pfioc_rule	 pr[PF_RULESET_MAX];
d616 2
a617 1

d620 2
a621 6
		memset(&pr[i], 0, sizeof(pr[i]));
		pr[i].rule.action = action[i];
		strlcpy(pr[i].anchor, anchorname, sizeof(pr[i].anchor));
		strlcpy(pr[i].ruleset, rulesetname, sizeof(pr[i].ruleset));
		if (ioctl(dev, DIOCBEGINRULES, &pr[i])) {
			syslog(LOG_ERR, "DIOCBEGINRULES %m");
d624 4
a627 1
		pf.prule[i] = &pr[i];
d638 4
d654 4
a657 10
	for (i = 0; i < PF_RULESET_MAX; ++i)
		/*
		 * ignore EINVAL on removal, it means the anchor was
		 * already automatically removed by the kernel.
		 */
		if (ioctl(dev, DIOCCOMMITRULES, &pr[i]) &&
		    (add || errno != EINVAL)) {
			syslog(LOG_ERR, "DIOCCOMMITRULES %m");
			goto error;
		}
d672 2
d749 2
a750 1
	struct pfioc_rule	*pr;
d755 1
a755 1
		pr = pf->prule[PF_RULESET_FILTER];
d758 1
a758 1
		pr = pf->prule[PF_RULESET_SCRUB];
d762 1
a762 1
		pr = pf->prule[PF_RULESET_NAT];
d766 1
a766 1
		pr = pf->prule[PF_RULESET_RDR];
d770 1
a770 1
		pr = pf->prule[PF_RULESET_BINAT];
d776 4
d782 5
a786 3
	pr->pool_ticket = pf->paddr.ticket;
	memcpy(&pr->rule, r, sizeof(pr->rule));
	if (ioctl(pf->dev, DIOCADDRULE, pr)) {
d870 1
a870 1
    char *rulesetname)
@


1.68
log
@stuff needed for passive OS fingerprinting PF rules
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.67 2003/08/01 05:29:36 millert Exp $	*/
d585 1
a585 2
	if (luser == NULL || !luser[0] || strlen(luser) >=
	    PF_RULESET_NAME_SIZE || ipsrc == NULL || !ipsrc[0]) {
@


1.67
log
@tickets are now u_int32_t, not int, fixes tree breakage; from Andrey Smagin
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.66 2003/07/11 08:29:34 cedric Exp $	*/
d614 5
d871 1
@


1.66
log
@Better parsing and -v support for tables:

  - remove the tableaddrs and tableaddr yacc production and reuse
    host_list instead.
  - produce better error messages.
  - do not load addresses from external file when it is not
    required (like with -R option).
  - store initializers in a new node_tinit linked list before
    putting them into the address buffer (see next point).
  - add a new print_tabledef() function, which makes "pfctl -nvf"
    print something useful for table definitions, which in turn
    makes it possible to write better regress tests (see first chunk
    of the diff) and bring table definition consistant with other
    parsed rules.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.65 2003/07/08 11:31:27 dhartmei Exp $	*/
d852 1
a852 1
    const char *ruleset, struct pfr_buffer *ab, int ticket)
@


1.65
log
@Fix a bug that caused removal of previous users' rules when more then one
user loggged in concurrently. And fix a smaller bug which prevented
complete removal of a user's state entries on logout. Bug report and
testing by Ed Powers.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.64 2003/07/03 21:09:13 cedric Exp $	*/
d851 2
a852 3
pfctl_define_table(char *name, int flags, int addrs, int noaction,
    const char *anchor, const char *ruleset, struct pfr_buffer *ab,
    int ticket)
@


1.64
log
@Bye bye atexit(), bye bye globals...
The pfctl.c part will probably need some further improvements.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.63 2003/07/03 09:13:05 cedric Exp $	*/
d549 1
a549 1
		if (kill(pid, 0)) {
d702 1
@


1.63
log
@This patch finally cleanup pfctl_table.c. No more global buffer,
and a couple of parsing functions moved to parse.y or pfctl_parser
where they belong.

I also took the opportunity to replace "void" functions with exit(1)
or err() inside by "int" functions, with the caller checking the
return value for errors (much cleaner and an old request from Theo)

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.62 2003/06/28 20:37:29 deraadt Exp $	*/
d851 2
a852 1
    const char *anchor, const char *ruleset, struct pfr_buffer *ab)
@


1.62
log
@() to (void)
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.61 2003/06/27 09:50:07 henning Exp $	*/
d849 1
a849 13
void
pfctl_append_addr(char *addr, int net, int neg)
{
	/* appropriate message will be printed by following function */
}

void
pfctl_append_file(char *file)
{
	/* appropriate message will be printed by following function */
}

void
d851 1
a851 1
    const char *anchor, const char *ruleset)
d854 1
@


1.61
log
@/etc/authpf.allow -> /etc/authpf/authpf.allow in comments
spotted by Joel Knight again
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.60 2003/06/24 20:45:54 deraadt Exp $	*/
d520 1
a520 1
remove_stale_rulesets()
d684 1
a684 1
authpf_kill_states()
d739 1
a739 1
 * callbacks for parse_rules()
@


1.60
log
@clean
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.59 2003/06/24 20:44:54 deraadt Exp $	*/
d379 1
a379 1
 * users file, namely /etc/authpf.allow .
d381 1
a381 1
 * If /etc/authpf.allow does not exist, then we assume that
d383 1
a383 1
 * use this gateway. If /etc/authpf.allow does exist, then a
d414 1
a414 1
		 * /etc/authpf.allow exists, thus we do a linear
@


1.59
log
@(long)getpid(); andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.58 2003/06/03 20:38:59 beck Exp $	*/
d504 1
a504 1
		while ((fputs(tmp, stdout) != EOF) && !feof(f)) {
@


1.58
log
@remove term 3, with permission from Chris Kuethe for pathnames.h
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.57 2003/05/10 06:14:29 cloder Exp $	*/
d283 2
a284 2
	printf("\r\nYour authentication process (pid %d) was unable to run\n",
	    getpid());
@


1.57
log
@Be polite about leaving invalid data around in globals, just in case
someone comes along later, modifies the code, and runs into a problem.
OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.56 2003/05/10 00:51:53 henning Exp $	*/
a13 3
 * 3. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d875 1
a875 1
}@


1.56
log
@catch up with pfctl changes
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.55 2003/04/30 12:30:27 cedric Exp $	*/
d645 1
d674 2
@


1.55
log
@Allow tables to be loaded into anchors.
Most pfctl table commands (excluding 'show' and 'flush') support the "-a"
modifier.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.54 2003/04/20 02:37:00 beck Exp $	*/
d867 9
@


1.54
log
@authpf is supposed to die if the /etc/authpf/authpf.conf is not present.
pr # 3217, patch from frisco@@blackant.net
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.53 2003/02/19 00:03:22 deraadt Exp $	*/
d862 2
a863 1
pfctl_define_table(char *name, int flags, int addrs, int noaction)
@


1.53
log
@sync to pfctl; BAD HENNING BAD BAD BAD NO COOKIE
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.52 2003/02/11 20:15:59 henning Exp $	*/
d245 1
a245 1
	if (config != NULL && read_config(config))
@


1.53.2.1
log
@Pull patch from -current:
Fixed by dhartmei@@.
Fix a bug that caused removal of previous users' rules when more then
one user loggged in concurrently. And fix a smaller bug which prevented
complete removal of a user's state entries on logout. Bug report and
testing by Ed Powers.

Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.53 2003/02/19 00:03:22 deraadt Exp $	*/
d552 1
a552 1
		if (kill(pid, 0) && errno != EPERM) {
a701 1
	psk.psk_af = AF_INET;
@


1.52
log
@adjust after pfctl changes
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.51 2003/02/03 09:59:19 henning Exp $	*/
d836 1
a836 1
pfctl_set_timeout(struct pfctl *pf, const char *opt, int seconds)
@


1.51
log
@typos and minor KNF; from andrushock, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.50 2003/02/02 23:31:24 henning Exp $	*/
d55 1
a55 1
extern int	symset(const char *, const char *);
d631 2
a632 1
		if (symset("user_ip", ipsrc) || symset("user_id", luser)) {
@


1.50
log
@adjust after pfctl change; parse_rules doesn't take opts seperately any more
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.49 2003/01/29 10:13:10 deraadt Exp $	*/
d82 1
a82 1
 * User shell for authenticating gateways. sole purpose is to allow
d134 1
a134 1
		syslog(LOG_ERR, "cannot open filter device (%m)");
d334 1
a334 1
		tp = pair[1]+strlen(pair[1]);
@


1.49
log
@do setprocticle; ok camield
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.48 2003/01/27 00:59:20 dhartmei Exp $	*/
d638 1
a638 1
		if (parse_rules(f, &pf, 0) < 0) {
@


1.48
log
@remove some unused includes, from Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.47 2003/01/26 02:49:59 dhartmei Exp $	*/
d272 1
@


1.47
log
@mop up, from krw
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.46 2003/01/25 16:33:19 cedric Exp $	*/
a34 1
#include <sys/stat.h>
a37 1
#include <netinet/in.h>
a38 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a39 1
#include <arpa/nameser.h>
a42 4
#include <fcntl.h>
#include <libgen.h>
#include <login_cap.h>
#include <netdb.h>
a46 1
#include <stddef.h>
a47 1
#include <strings.h>
a49 1
#include <resolv.h>
@


1.46
log
@Permit initialisation of a table content from a file in pf.conf.
Cleaning up of the table options parsing, more flexible.
idea+cleanup deraadt@@, ok dhartmei@@, pass all regress tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.45 2003/01/09 10:40:44 cedric Exp $	*/
d872 1
a872 1
pfctl_define_table(char *name, int flags, int addrs)
@


1.45
log
@Add support for active/inactive tablesets in the kernel.
Add table definition/initialisation construct in pfctl parser.
Add and fix documentation for pf.4 and pf.conf.5.
Tested on i386 and sparc64 by myself, macppc by Daniel.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.44 2003/01/07 03:32:15 dhartmei Exp $	*/
d859 2
a860 1
void    pfctl_append_addr(char *addr, int net, int neg)
d865 8
a872 1
void    pfctl_define_table(char *name, int flags, int addrs)
@


1.44
log
@Add function to search for and remove stale rulesets from other authpf
processes which have terminated unexpectedly. ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.43 2003/01/06 18:43:02 deraadt Exp $	*/
d857 10
@


1.43
log
@nicer syslog
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.42 2003/01/05 22:14:23 dhartmei Exp $	*/
d73 1
d260 3
d529 55
d738 1
@


1.42
log
@Move ifname from pf_addr to pf_addr_wrap, prepare pf_addr_wrap for table
name. ok henning@@, mcbride@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.41 2003/01/01 02:28:26 dhartmei Exp $	*/
d110 1
a110 1
		syslog(LOG_ERR, "PID too large for ruleset name");
d117 1
a117 1
		syslog(LOG_ERR, "Non-interactive session connection for authpf");
d122 1
a122 1
		syslog(LOG_ERR, "Can't determine connection source");
d132 1
a132 1
		syslog(LOG_ERR, "Corrupt SSH_CLIENT variable %s", ipsrc);
d138 1
a138 1
		    "Cannot determine IP from SSH_CLIENT %s", ipsrc);
d145 1
a145 1
		syslog(LOG_ERR, "Can't open filter device (%m)");
d152 1
a152 1
		syslog(LOG_ERR, "can't find user for uid %u", uid);
d200 1
a200 1
			syslog(LOG_ERR, "can't open or create %s: %s", pidfile,
d215 1
a215 1
		syslog(LOG_DEBUG, "Tried to lock %s, in use by pid %d: %s",
d224 1
a224 1
				    "Couldn't kill process %d: (%m)",
d235 1
a235 1
			syslog(LOG_ERR, "Can't kill previous authpf (pid %d)",
d419 1
a419 1
		syslog(LOG_ERR, "Can't open allowed users file %s (%s)",
d452 1
a452 1
		syslog(LOG_INFO, "Denied access to %s: not listed in %s",
d456 1
a456 1
		buf = "\n\nSorry, you aren't allowed to use this facility!\n";
d482 1
a482 1
		syslog(LOG_ERR, "Provided banned directory line too long (%s)",
d499 1
a499 1
			syslog(LOG_ERR, "Can't open banned file %s (%s)",
d508 1
a508 1
		syslog(LOG_INFO, "Denied access to %s: %s exists",
d553 1
a553 1
			syslog(LOG_ERR, "can't open %s (%m)", fn);
d563 1
a563 1
				syslog(LOG_ERR, "can't open %s (%m)", fn);
d613 1
a613 1
		syslog(LOG_INFO, "Allowing %s, user %s", ipsrc, luser);
d616 1
a616 1
		syslog(LOG_INFO, "Removed %s, user %s - duration %ld seconds",
d684 1
a684 1
			syslog(LOG_ERR, "can't unlink %s (%m)", pidfile);
@


1.41
log
@Scrub and filter rules are separated now, adjust authpf accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.40 2002/12/29 22:00:37 dhartmei Exp $	*/
d646 3
a648 2
	psk.psk_src.addr.addr.v4 = target;
	memset(&psk.psk_src.addr.mask, 0xff, sizeof(psk.psk_src.addr.mask));
d654 3
a656 2
	psk.psk_dst.addr.addr.v4 = target;
	memset(&psk.psk_dst.addr.mask, 0xff, sizeof(psk.psk_dst.addr.mask));
@


1.40
log
@Set a macro $user_id to the user name, just like $user_ip is already set
to the IP address. From discussion with Michael Lucas. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.39 2002/12/22 16:19:32 henning Exp $	*/
d534 2
a535 2
	const int		 action[PF_RULESET_MAX] = { PF_PASS,
				    PF_NAT, PF_BINAT, PF_RDR };
d696 7
d716 2
a717 1
		pr = pf->prule[PF_RULESET_RULE];
@


1.39
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.38 2002/12/22 14:19:30 dhartmei Exp $	*/
d583 1
a583 1
		if (symset("user_ip", ipsrc)) {
@


1.38
log
@Instead of inserting and removing rules at the top/bottom of the main
ruleset, make authpf manage its rules inside anchors.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.37 2002/12/19 14:04:03 henning Exp $	*/
d603 1
a603 1
                 * already automatically removed by the kernel.
d693 1
a693 1
	struct pfioc_rule *pr;
d726 1
a726 1
	struct pf_pooladdr *pa;
d746 1
a746 1
	struct pf_pooladdr *pa;
@


1.37
log
@redundant memset
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.36 2002/12/19 14:03:06 henning Exp $	*/
d67 9
a75 3
int	Rule_Action = PF_CHANGE_ADD_TAIL;
int	Nat_Action = PF_CHANGE_ADD_HEAD;
int	Rdr_Action = PF_CHANGE_ADD_HEAD;
d77 2
a78 1
int	Delete_Rules;		/* for parse_rules callbacks */
d81 1
a81 1
char	*infile;		/* infile name needed by parse_[rules|nat] */
a87 17
int	pfctl_add_pool(struct pfctl *, struct pf_pool *, sa_family_t);
int	pfctl_add_rule(struct pfctl *, struct pf_rule *);

int	pfctl_compare_addr_wraps(struct pf_addr_wrap *,
	    struct pf_addr_wrap *, sa_family_t);
int	pfctl_compare_pooladdrs(struct pf_pooladdr *,
	    struct pf_pooladdr *, sa_family_t);
int	pfctl_compare_pools(struct pf_pool *, struct pf_pool *, sa_family_t);
int	pfctl_compare_rules(struct pf_rule *, struct pf_rule *);

static int	read_config(FILE *);
static void	print_message(char *);
static int	allowed_luser(char *);
static int	check_luser(char *, char *);
static int	changefilter(int, char *, char *);
static void	authpf_kill_states(void);

d108 6
a114 2
	if (config == NULL)
		exit(1);
d255 2
a256 1
	if (read_config(config))
d265 1
a265 1
	if (changefilter(1, luser, ipsrc) == -1) {
a308 2
	openlog("authpf", LOG_PID | LOG_NDELAY, LOG_DAEMON);

d345 3
a347 20
		if (strcasecmp(pair[0], "rule_action") == 0) {
			if (strcasecmp(pair[1], "head") == 0)
				Rule_Action = PF_CHANGE_ADD_HEAD;
			else if (strcasecmp(pair[1], "tail") == 0)
				Rule_Action = PF_CHANGE_ADD_TAIL;
			else
				goto parse_error;
		} else if (strcasecmp(pair[0], "nat_action") == 0) {
			if (strcasecmp(pair[1], "head") == 0)
				Nat_Action = PF_CHANGE_ADD_HEAD;
			else if (strcasecmp(pair[1], "tail") == 0)
				Nat_Action = PF_CHANGE_ADD_TAIL;
			else
				goto parse_error;
		} else if (strcasecmp(pair[0], "rdr_action") == 0)  {
			if (strcasecmp(pair[1], "head") == 0)
				Rdr_Action = PF_CHANGE_ADD_HEAD;
			else if (strcasecmp(pair[1], "tail") == 0)
				Rdr_Action = PF_CHANGE_ADD_TAIL;
			else
d530 1
a530 1
changefilter(int add, char *luser, char *ipsrc)
d532 4
a535 4
	char			 rulesfile[MAXPATHLEN], buf[1024];
	char			 template[] = "/tmp/authpfrules.XXXXXXX";
	int			 tmpfile = -1, from_fd = -1, ret = -1;
	struct pfioc_rule	 pr;
d537 2
a538 8
	int			 n, rcount, wcount;
	FILE			*fin = NULL;

	memset(&pf, 0, sizeof(pf));
	memset(&pr, 0, sizeof(pr));

	syslog(LOG_DEBUG, "%s filter for ip=%s, user %s",
	    add ? "Adding" : "Removing", ipsrc, luser);
d540 3
a542 10
	/* add filter rules */
	if (add)
		Delete_Rules = 0;
	else
		Delete_Rules = 1;

	tmpfile = mkstemp(template);
	if (tmpfile == -1) {
		syslog(LOG_ERR, "Can't open temp file %s (%m)",
		    template);
d546 21
a566 4
	fin = fdopen(tmpfile, "r+");
	if (fin == NULL) {
		syslog(LOG_ERR, "can't open %s (%m)", template);
		goto error;
d569 8
a576 17
	/* write the variable to the start of the file */
	fprintf(fin, "user_ip = \"%s\"\n", ipsrc);

	fflush(fin);

	n = snprintf(rulesfile, sizeof(rulesfile), "%s/%s/authpf.rules",
	    PATH_USER_DIR, luser);
	if (n < 0 || (u_int)n >= sizeof(rulesfile)) {
		syslog(LOG_ERR, "user path too long, exiting");
		goto error;
	}
	if ((from_fd = open(rulesfile, O_RDONLY, 0)) == -1) {
		/* if user dir rules do not exist, we try PATH_PFRULES */
		if (errno != ENOENT) {
			syslog(LOG_ERR, "can't open %s (%m)", rulesfile);
			if (unlink(template) == -1)
				syslog(LOG_ERR, "can't unlink %s", template);
d579 1
d581 4
a584 6
	if (from_fd == -1) {
		snprintf(rulesfile, sizeof(rulesfile), PATH_PFRULES);
		if  ((from_fd = open(rulesfile, O_RDONLY, 0)) == -1) {
			syslog(LOG_ERR, "can't open %s (%m)", rulesfile);
			if (unlink(template) == -1)
				syslog(LOG_ERR, "can't unlink %s", template);
a586 1
	}
d588 5
a592 6
	while ((rcount = read(from_fd, buf, sizeof(buf))) > 0) {
		wcount = write(tmpfile, buf, rcount);
		if (rcount != wcount || wcount == -1) {
			syslog(LOG_ERR, "rules template copy failed");
			if (unlink(template) == -1)
				syslog(LOG_ERR, "can't unlink %s", template);
a594 7
	}
	if (rcount == -1) {
		syslog(LOG_ERR, "read of rules template failed");
		if (unlink(template) == -1)
			syslog(LOG_ERR, "can't unlink %s", template);
		goto error;
	}
d596 2
a597 13
	fclose(fin);
	fin = NULL;
	close(tmpfile);
	tmpfile = -1;
	close(from_fd);
	from_fd = -1;

	fin = fopen(template, "r");
	if (fin == NULL) {
		syslog(LOG_ERR, "can't open %s (%m)", template);
		if (unlink(template) == -1)
			syslog(LOG_ERR, "can't unlink %s", template);
		goto error;
d600 10
a609 6
	infile = template;

	if (unlink(template) == -1) {
		syslog(LOG_ERR, "can't unlink %s", template);
		goto error;
	}
a610 19
	/* add/delete rules, using parse_rule */
	pf.dev = dev;
	pf.prule[PF_RULESET_RULE] = &pr;
	if (parse_rules(fin, &pf, 0) < 0) {
		syslog(LOG_ERR,
		    "syntax error in rule file: authpf rules not loaded");
		goto error;
	}
	ret = 0;
	goto out;
 error:
	ret = -1;
 out:
	if (fin != NULL)
		fclose(fin);
	if (tmpfile != -1)
		close(tmpfile);
	if (from_fd != -1)
		close(from_fd);
d612 1
a612 1
		(void)gettimeofday(&Tstart, NULL);
d615 1
a615 1
		(void)gettimeofday(&Tend, NULL);
d619 6
a624 1
	return (ret);
d675 1
a675 1
		changefilter(0, luser, ipsrc);
a685 125
int
pfctl_add_pool(struct pfctl *pf, struct pf_pool *p, sa_family_t af)
{
	struct pf_pooladdr	*pa;

	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr))
			err(1, "DIOCBEGINADDRS");
	}

	pf->paddr.af = af;
	TAILQ_FOREACH(pa, &p->list, entries) {
		memcpy(&pf->paddr.addr, pa, sizeof(struct pf_pooladdr));
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			if (ioctl(pf->dev, DIOCADDADDR, &pf->paddr))
				err(1, "DIOCADDADDR");
		}
	}
	return (0);
}

int
pfctl_compare_addr_wraps(struct pf_addr_wrap *a, struct pf_addr_wrap *b,
    sa_family_t af)
{
	if (a->addr_dyn != NULL && b->addr_dyn != NULL) {
		if (strcmp(a->addr_dyn->ifname, b->addr_dyn->ifname))
			return (1);
	} else {
		if (a->addr_dyn != NULL || b->addr_dyn != NULL)
			return (1);
		if (PF_ANEQ(&a->addr, &b->addr, af))
			return (1);
	}
	if (PF_ANEQ(&a->mask, &b->mask, af))
		return (1);
	return (0);
}

int
pfctl_compare_pooladdrs(struct pf_pooladdr *a, struct pf_pooladdr *b,
    sa_family_t af)
{
	if (pfctl_compare_addr_wraps(&a->addr.addr, &b->addr.addr, af))
		return (1);
	if (a->addr.port[0] != b->addr.port[0] ||
	    a->addr.port[1] != b->addr.port[1] ||
	    a->addr.not != b->addr.not ||
	    a->addr.port_op != b->addr.port_op)
		return (1);
	if (strcmp(a->ifname, b->ifname))
		return (1);
	return (0);
}

int
pfctl_compare_pools(struct pf_pool *a, struct pf_pool *b, sa_family_t af)
{
	struct pf_pooladdr	*pa_a, *pa_b;

	if (a->key.key32[0] != b->key.key32[0] ||
	    a->key.key32[1] != b->key.key32[1] ||
	    a->key.key32[2] != b->key.key32[2] ||
	    a->key.key32[3] != b->key.key32[3] ||
	    a->proxy_port[0] != b->proxy_port[0] ||
	    a->proxy_port[1] != b->proxy_port[1] ||
	    a->port_op != b->port_op ||
	    a->opts != b->opts)
		return (1);
	pa_a = TAILQ_FIRST(&a->list);
	pa_b = TAILQ_FIRST(&b->list);
	while (pa_a != NULL && pa_b != NULL) {
		pfctl_compare_pooladdrs(pa_a, pa_b, af);
		pa_a = TAILQ_NEXT(pa_a, entries);
		pa_b = TAILQ_NEXT(pa_b, entries);
	}
	return (0);
}

int
pfctl_compare_rules(struct pf_rule *a, struct pf_rule *b)
{
	if (a->return_icmp != b->return_icmp ||
	    a->return_icmp6 != b->return_icmp6 ||
	    a->action != b->action ||
	    a->direction != b->direction ||
	    a->log != b->log ||
	    a->quick != b->quick ||
	    a->keep_state != b->keep_state ||
	    a->af != b->af ||
	    a->proto != b->proto ||
	    a->type != b->type ||
	    a->code != b->code ||
	    a->flags != b->flags ||
	    a->flagset != b->flagset ||
	    a->rule_flag != b->rule_flag ||
	    a->min_ttl != b->min_ttl ||
	    a->tos != b->tos ||
	    a->allow_opts != b->allow_opts ||
	    a->ifnot != b->ifnot)
		return (1);
	if (pfctl_compare_addr_wraps(&a->src.addr, &b->src.addr, a->af))
		return (1);
	if (a->src.port[0] != b->src.port[0] ||
	    a->src.port[1] != b->src.port[1] ||
	    a->src.not != b->src.not ||
	    a->src.port_op != b->src.port_op)
		return (1);
	if (pfctl_compare_addr_wraps(&a->dst.addr, &b->dst.addr, a->af))
		return (1);
	if (a->dst.port[0] != b->dst.port[0] ||
	    a->dst.port[1] != b->dst.port[1] ||
	    a->dst.not != b->dst.not ||
	    a->dst.port_op != b->dst.port_op)
		return (1);
	if (pfctl_compare_pools(&a->rpool, &b->rpool, a->af))
		return (1);
	if (strcmp(a->ifname, b->ifname) ||
	    strcmp(a->anchorname, b->anchorname) ||
	    strcmp(a->label, b->label))
		return (1);
	return (0);
}


d687 1
a687 1
 * callback for rule add, used by parser in parse_rules
d689 1
d693 1
a693 2
	struct pfioc_rule	pcr;
	u_int32_t		mnr, nr, match = 0;
d695 1
a695 13
	memset(&pcr, 0, sizeof(pcr));
	pcr.rule.action = r->action;
	pcr.action = PF_CHANGE_GET_TICKET;
	if (ioctl(pf->dev, DIOCCHANGERULE, &pcr))
		syslog(LOG_INFO, "DIOCCHANGERULE %m");

	switch(r->action) {
	case PF_SCRUB:
	case PF_DROP:
	case PF_PASS:
	default:
		pcr.action = Rule_Action;
		break;
d698 1
a698 1
		pcr.action = Nat_Action;
d702 1
a702 1
		pcr.action = Rdr_Action;
d706 1
a706 2
		/* binat is not supported */
		return (0);
d708 2
d711 11
d723 14
a736 27
	if (Delete_Rules) {
		pcr.rule.action = r->action;
		if (ioctl(pf->dev, DIOCGETRULES, &pcr))
			syslog(LOG_INFO, "DIOCGETRULES %m");
		mnr = pcr.nr;
		for (nr = 0; nr < mnr; ++nr) {
			if (pcr.action == PF_CHANGE_ADD_HEAD)
				pcr.nr = nr;
			else
				pcr.nr = (mnr - 1) - nr;
			if (ioctl(dev, DIOCGETRULE, &pcr)) {
				syslog(LOG_INFO, "DIOCGETRULE %m");
				return (-1);
			}
			if (! pfctl_compare_rules(&pcr.rule, r)) {
				match++;
				break;
			}
		}
		if (match && ((pf->opts & PF_OPT_NOACTION) == 0)) {
			pcr.action = PF_CHANGE_REMOVE;
			if (ioctl(pf->dev, DIOCCHANGERULE, &pcr))
				syslog(LOG_INFO, "DIOCCHANGERULE %m");
		}
	} else {
		memcpy(&pcr.rule, r, sizeof(pcr.rule));
		if (pfctl_add_pool(pf, &r->rpool, r->af))
a737 4
		pcr.pool_ticket = pf->paddr.ticket;
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			if (ioctl(pf->dev, DIOCCHANGERULE, &pcr))
				syslog(LOG_INFO, "DIOCCHANGERULE %m");
d740 7
d748 4
a751 1
	return (0);
d755 1
a755 1
pfctl_set_timeout(struct pfctl *pf, const char *opt, int seconds)
d757 1
a757 1
	fprintf(stderr, "set timeout not supported in authpf\n");
d769 1
a769 1
pfctl_set_limit(struct pfctl *pf, const char *opt, unsigned int limit)
d771 1
a771 1
	fprintf(stderr, "set limit not supported in authpf\n");
d776 1
a776 1
pfctl_set_logif(struct pfctl *pf, char *ifname)
d778 1
a778 1
	fprintf(stderr, "set loginterface not supported in authpf\n");
d783 1
a783 1
pfctl_add_altq(struct pfctl *pf, struct pf_altq *a)
d785 1
a785 1
	fprintf(stderr, "altq and queue not supported in authpf\n");
@


1.36
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.35 2002/12/18 22:07:31 mcbride Exp $	*/
a657 1
	memset(&pf, 0, sizeof(pf));
@


1.35
log
@Fix tree breakage; match changes to struct pfctl (now contains an array
of pointers to pfioc_rule).

Fix from henning@@

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.34 2002/12/17 12:42:22 mcbride Exp $	*/
d67 11
a77 11
int Rule_Action = PF_CHANGE_ADD_TAIL;
int Nat_Action = PF_CHANGE_ADD_HEAD;
int Rdr_Action = PF_CHANGE_ADD_HEAD;
int dev;			/* pf device */
int Delete_Rules;		/* for parse_rules callbacks */

FILE *pidfp;
char *infile;			/* infile name needed by parse_[rules|nat] */
char luser[MAXLOGNAME];		/* username */
char ipsrc[256];		/* ip as a string */
char pidfile[MAXPATHLEN];	/* we save pid in this file. */
d79 1
a79 1
struct timeval Tstart, Tend;	/* start and end times of session */
d98 3
a100 3
volatile sig_atomic_t want_death;
static void	need_death(int signo);
static __dead void do_death(int);
d111 6
a116 6
	int lockcnt = 0, n, pidfd;
	FILE *config;
	struct in_addr ina;
	struct passwd *pw;
	char *cp;
	uid_t uid;
d199 2
a200 2
		int save_errno, otherpid = -1;
		char otherluser[MAXLOGNAME];
d311 2
a312 2
	char buf[1024];
	int i = 0;
d317 3
a319 2
		char **ap, *pair[4], *cp, *tp;
		int len;
d335 1
a335 1
			;
a365 1

d377 1
d393 2
a394 2
	char buf[1024];
	FILE *f;
d424 4
a427 4
	char *buf, *lbuf;
	int matched;
	size_t len;
	FILE *f;
d435 1
a435 1
			return(1);
d445 1
a445 1
		return(0);
d474 1
a474 1
				return(1); /* matched an allowed username */
d484 1
a484 1
	return(0);
d500 3
a502 3
	FILE *f;
	int n;
	char tmp[MAXPATHLEN];
d508 1
a508 1
		return(0);
d516 1
a516 1
			return(1);
d525 1
a525 1
			return(0);
d541 1
a541 1
				return(0);
d546 1
a546 1
	return(0);
d556 7
a562 7
	char rulesfile[MAXPATHLEN], buf[1024];
	char template[] = "/tmp/authpfrules.XXXXXXX";
	int tmpfile = -1, from_fd = -1, ret = -1;
	struct pfioc_rule	pr;
	struct pfctl		pf;
	int n, rcount, wcount;
	FILE *fin = NULL;
d685 1
a685 1
	return(ret);
d698 2
a699 2
	struct pfioc_state_kill psk;
	struct in_addr target;
d733 1
a733 1
	int ret = 0;
d750 1
a750 1
	struct pf_pooladdr *pa;
d805 1
a805 1
	struct pf_pooladdr *pa_a, *pa_b;
d815 1
a815 1
		return(1);
d878 2
a879 2
	struct pfioc_rule pcr;
	u_int32_t mnr, nr, match = 0;
d944 1
a944 1
	return 0;
@


1.34
log
@Match merge of pf_nat/pf_binat/pf_rdr structs into pf_rule
- Move pf_compare* functions here
- fix ioctls.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.33 2002/12/06 00:47:32 dhartmei Exp $	*/
d659 1
a659 1
	pf.prule = &pr;
@


1.33
log
@Introduce anchors and named rule sets, allowing to load additional rule
sets with pfctl and evaluate them from the main rule set using a new type
of rule (which will support conditional evaluation soon). Makes
maintenance of sub-rulesets simpler for pfctl and daemons.

Idea and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.32 2002/12/04 08:06:58 deraadt Exp $	*/
d83 7
a89 3
int	pfctl_add_nat(struct pfctl *, struct pf_nat *);
int	pfctl_add_rdr(struct pfctl *, struct pf_rdr *);
int	pfctl_add_binat(struct pfctl *, struct pf_binat *);
a557 3
	struct pfioc_nat	pn;
	struct pfioc_binat	pb;
	struct pfioc_rdr	pd;
a658 3
	pf.pnat = &pn;
	pf.pbinat = &pb;
	pf.prdr = &pd;
a766 3
/*
 * callback for rule add, used by parser in parse_rules
 */
d768 2
a769 1
pfctl_add_rule(struct pfctl *pf, struct pf_rule *r)
d771 3
a773 6
	struct pfioc_changerule pcr;

	memset(&pcr, 0, sizeof(pcr));
	if (Delete_Rules) {
		pcr.action = PF_CHANGE_REMOVE;
		memcpy(&pcr.oldrule, r, sizeof(pcr.oldrule));
d775 4
a778 2
		pcr.action = Rule_Action;
		memcpy(&pcr.newrule, r, sizeof(pcr.newrule));
d780 1
a780 1
	if (pfctl_add_pool(pf, &r->rt_pool, r->af))
d782 2
a783 9
	if (Delete_Rules) {
		if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr.ticket))
			err(1, "DIOCBEGINADDRS");
	}
	pcr.pool_ticket = pf->paddr.ticket;
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCCHANGERULE, &pcr))
			syslog(LOG_INFO, "DIOCCHANGERULE %m");
	}
d785 14
a798 1
	return 0;
a800 3
/*
 * callback for nat add, used by parser in parse_rules
 */
d802 1
a802 1
pfctl_add_nat(struct pfctl *pf, struct pf_nat *n)
d804 1
a804 1
	struct pfioc_changenat pcr;
d806 15
a820 7
	memset(&pcr, 0, sizeof(pcr));
	if (Delete_Rules) {
		pcr.action = PF_CHANGE_REMOVE;
		memcpy(&pcr.oldnat, n, sizeof(pcr.oldnat));
	} else {
		pcr.action = Nat_Action;
		memcpy(&pcr.newnat, n, sizeof(pcr.newnat));
d822 33
a854 1
	if (pfctl_add_pool(pf, &n->rpool, n->af))
d856 12
a867 10
	if (Delete_Rules) {
		if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr.ticket))
			err(1, "DIOCBEGINADDRS");
	}
	pcr.pool_ticket = pf->paddr.ticket;
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCCHANGENAT, &pcr))
			syslog(LOG_INFO, "DIOCCHANGENAT %m");
	}
	return 0;
d870 1
d872 1
a872 1
 * callback for rdr add, used by parser in parse_rules
d875 1
a875 1
pfctl_add_rdr(struct pfctl *pf, struct pf_rdr *r)
d877 2
a878 1
	struct pfioc_changerdr pcr;
d881 18
a898 4
	if (Delete_Rules) {
		pcr.action = PF_CHANGE_REMOVE;
		memcpy(&pcr.oldrdr, r, sizeof(pcr.oldrdr));
	} else {
d900 6
a905 1
		memcpy(&pcr.newrdr, r, sizeof(pcr.newrdr));
d907 1
a907 2
	if (pfctl_add_pool(pf, &r->rpool, r->af))
		return (1);
d909 32
a940 7
		if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr.ticket))
			err(1, "DIOCBEGINADDRS");
	}
	pcr.pool_ticket = pf->paddr.ticket;
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCCHANGERDR, &pcr))
			syslog(LOG_INFO, "DIOCCHANGERDR %m");
d942 1
a943 12
}

/*
 * We don't support adding binat's, since pf doesn't,
 * and I can't for the life of me think of a sane situation where it
 * might be useful.  This is here only because the pfctl parse
 * routines need this defined.
 */
int
pfctl_add_binat(struct pfctl *pf, struct pf_binat *b)
{
	return (0);
@


1.32
log
@catch up to -v -v change in pfctl(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.31 2002/12/01 20:01:35 henning Exp $	*/
d754 1
a754 1
		if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr.ticket))
@


1.31
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.30 2002/12/01 19:59:45 mcbride Exp $	*/
d662 1
a662 1
	if (parse_rules(fin, &pf) < 0) {
@


1.30
log
@Match pf_ioctl.c cleanup; if we're doing a DIOCCHANGE* operation which uses
old*, we need to call DIOCBEGINADDRS twice: once for the old rule/rdr/nat,
and once for the new one.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.29 2002/11/23 07:54:45 mcbride Exp $	*/
d178 1
a178 2
		
	
d210 2
a211 2
		
		/* Mark our pid, and username to our file. */   
@


1.29
log
@don't try to do ioctl with PF_OPT_NOACTION

does not impact fuction of authpf, but make it consistent with the rest of
the add_* family

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.28 2002/11/23 05:27:19 mcbride Exp $	*/
d788 5
d819 5
d849 5
@


1.28
log
@add code to load lists of redirection addresses for nat/rdr/route-to/etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.27 2002/11/22 18:06:48 beck Exp $	*/
d754 4
a757 2
	if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr.ticket))
		err(1, "DIOCBEGINADDRS");
@


1.27
log
@Disallow non-interactive sessions, to avoid problem of users scp'ing
to authpf gateway - noticed by Devan Reade <gdr@@gno.org>, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.26 2002/11/19 02:18:50 deraadt Exp $	*/
d81 1
d710 1
a710 1
	memset(&psk.psk_src.mask, 0xff, sizeof(psk.psk_src.mask));
d717 1
a717 1
	memset(&psk.psk_dst.mask, 0xff, sizeof(psk.psk_dst.mask));
d749 19
d784 2
d810 2
d835 2
@


1.26
log
@be more precise
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.25 2002/11/19 02:14:56 deraadt Exp $	*/
d116 5
@


1.25
log
@hacks to make the tree build; henning gets a carrot up the nose next time i meet him
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.24 2002/10/25 18:33:13 camield Exp $	*/
d856 1
a856 1
	fprintf(stderr, "altq not supported in authpf\n");
@


1.24
log
@- be even more careful with data supplied from outside
- check explicitly for negative values from snprintf (-pedantic)
- use MAXLOGNAME
- use parentheses with all sizeof's for consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.23 2002/06/25 08:14:38 henning Exp $	*/
d853 6
@


1.23
log
@hooks for options.
we don't support setting pf options via authpf, but need the hooks here, too.
ok dhartmei@@, kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.22 2002/06/12 20:09:43 vincent Exp $	*/
d106 1
a106 1
	int lockcnt = 0, pidfd;
d122 4
a125 1
	strlcpy(ipsrc, cp, sizeof(ipsrc));
d157 8
a164 1
	strlcpy(luser, pw->pw_name, sizeof(luser));
d166 7
a172 2
        /* Make our entry in /var/run as /var/run/authpf-ipaddr */
        snprintf(pidfile, sizeof pidfile, "%s/%s", PATH_PIDFILE, ipsrc);
d191 1
a191 1
		char otherluser[33];
d209 2
a210 1
		if (fscanf(pidfp, "%d\n%32s\n", &otherpid, otherluser) != 2) 
d212 1
a212 2
		syslog(LOG_DEBUG,
		    "Tried to lock %s, in use by pid %d: %s",
a489 1
	char tmp[1024];
d491 2
d494 2
a495 2
	if (snprintf(tmp, sizeof(tmp), "%s/%s", luserdir, luser) >=
	    sizeof(tmp)) {
d554 1
a554 1
	int rcount, wcount;
d587 3
a589 2
	if (snprintf(rulesfile, sizeof rulesfile, "%s/%s/authpf.rules",
	    PATH_USER_DIR, luser) >= sizeof rulesfile) {
d603 1
a603 1
		snprintf(rulesfile, sizeof rulesfile, PATH_PFRULES);
@


1.22
log
@fix a typo that could create a fd leak

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.21 2002/06/11 17:13:55 beck Exp $	*/
d805 29
a833 1
	return 0;
d835 1
@


1.21
log
@fix breakage from the stupid way theo and I commited that last big pile of
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.20 2002/06/11 04:45:32 kjell Exp $	*/
d180 1
a180 1
			if (pidfd == -1)
@


1.20
log
@I broke this. Remove separate (optional) nat calls
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.19 2002/06/08 04:57:34 beck Exp $	*/
d156 3
@


1.19
log
@comment and error message cleanup, from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.18 2002/06/07 08:51:44 beck Exp $	*/
d527 1
a527 1
	char rulesfile[MAXPATHLEN], natfile[MAXPATHLEN], buf[1024];
a528 1
	char template2[] = "/tmp/authpfnat.XXXXXXX";
d633 3
a641 94

	if (snprintf(natfile, sizeof natfile, "%s/%s/authpf.nat",
	    PATH_USER_DIR, luser) >= sizeof natfile) {
		syslog(LOG_ERR, "user dir path too long, exiting");
		goto error;
	}
	if ((from_fd = open(natfile, O_RDONLY, 0)) == -1) {
		/* if it doesn't exist, we try /etc */
		if (errno != ENOENT) {
			syslog(LOG_ERR, "can't open %s (%m)", natfile);
			if (unlink(template) == -1)
				syslog(LOG_ERR, "can't unlink %s", template);
			goto error;
		}
	}
	if (from_fd == -1) {
		snprintf(natfile, sizeof natfile, PATH_NATRULES);
		if ((from_fd = open(natfile, O_RDONLY, 0)) == -1) {
			if (errno == ENOENT) {
				ret = 0;
				goto out; /* NAT is optional */
			}
			else {
				syslog(LOG_ERR, "can't open %s (%m)", natfile);
				if (unlink(template) == -1)
					syslog(LOG_ERR, "can't unlink %s",
					    template);
				goto error;
			}
		}
	}

	tmpfile = mkstemp(template2);
	if (tmpfile == -1) {
		syslog(LOG_ERR, "Can't open temp file %s (%m)",
		    template2);
		goto error;
	}

	fin = fdopen(tmpfile, "r+");
	if (fin == NULL) {
		syslog(LOG_ERR, "Can't open %s (%m)", template2);
		goto error;
	}

	/* write the variable to the start of the file */
	fprintf(fin, "user_ip = \"%s\"\n", ipsrc);
	fflush(fin);

	while ((rcount = read(from_fd, buf, sizeof(buf))) > 0) {
		wcount = write(tmpfile, buf, rcount);
		if (rcount != wcount || wcount == -1) {
			syslog(LOG_INFO, "nat copy failed");
			goto error;
		}
	}

	if (rcount == -1) {
		syslog(LOG_INFO, "read for nat copy failed");
		goto error;
	}

	fclose(fin);
	fin = NULL;
	close(tmpfile);
	tmpfile = -1;
	close(from_fd);
	from_fd = -1;

	fin = fopen(template2, "r");

	if (fin == NULL) {
		syslog(LOG_INFO, "can't open %s (%m)", template2);
		goto error;
	}

	infile = template;

	if (unlink(template2) == -1) {
		syslog(LOG_INFO, "can't unlink %s (%m)", template2);
		goto error;
	}

	/* add/delete rules, using parse_nat */
	memset(&pf, 0, sizeof(pf));
	pf.dev = dev;
	pf.pnat = &pn;
	pf.pbinat = &pb;
	pf.prdr = &pd;
	if (parse_nat(fin, &pf) < 0) {
		syslog(LOG_INFO,
		    "syntax error in nat file: nat rules not loaded");
		goto error;
	}
d748 1
a748 1
 * callback for nat add, used by parser in parse_nat
d771 1
a771 1
 * callback for rdr add, used by parser in parse_nat
@


1.18
log
@fix a few nits in theo's commit, make this install and run setgid authpf
so that it can remove the files it creates in /var/authpf
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.17 2002/06/07 08:36:56 deraadt Exp $	*/
d79 1
a79 1
struct timeval Tstart, Tend;		/* start and end times of session */
d404 1
a404 1
			 * allowfile doesn't exist, this this gateway
d571 1
a571 1
		syslog(LOG_ERR, "homedir path too long, exiting");
d575 1
a575 1
		/* if home dir rules do not exist, we try PATH_PFRULES */
d643 1
a643 1
		syslog(LOG_ERR, "homedir path too long, exiting");
@


1.17
log
@twist time, space, and other aspects of reality so that we can revoke privs,
and... as early as possible.  (this does not work, beck has the next half
of this coming in a few minutes)
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.14 2002/05/16 09:18:55 deraadt Exp $	*/
a73 1
int ufd = -1;
a77 1
char userfile[MAXPATHLEN];	/* we save username in this file */
d153 1
a155 3
	/* Make our entry in /var/run as /var/run/authpf-ipaddr */
	snprintf(pidfile, sizeof pidfile, "%s-%s", PATH_PIDFILE, ipsrc);

d170 1
d173 1
d187 2
d191 1
a191 1
		if (fscanf(pidfp, "%d", &otherpid) != 1)
d200 1
a200 1
			    otherpid, ipsrc, luser);
a226 12
	/*
	 * Make an entry in file /var/authpf/ipaddr, containing the username.
	 * this lets external applications check for authentication by looking
	 * for the ipaddress in that directory, and retrieving the username
	 * from it.
	 */
	snprintf(userfile, sizeof(userfile), "%s/%s", PATH_USERFILE, ipsrc);
	if ((ufd = open(userfile, O_CREAT|O_WRONLY, 0640)) == -1) {
		syslog(LOG_ERR, "Can't open \"%s\" ! (%m)", userfile);
		goto dogdeath;
	}

a230 5
	/*
	 * Now we are unable to unlink /var/authpf/$ipsec and /var/run/$pid
	 * and instead have to settle for only truncating them.
	 */

d239 1
a239 1
	fprintf(pidfp, "%ld\n", (long)getpid());
a242 3
	write(ufd, luser, strlen(luser));
	write(ufd, "\n", 1);

d658 2
a659 1
			if (errno == ENOENT)
d661 1
d810 2
a811 5
		unlink(pidfile);
	if (ufd)
		ftruncate(ufd, 0);
	if (userfile[0])
		unlink(userfile);
@


1.16
log
@Do not allow user to run authpf if user's shell is not /usr/sbin/authpf to
prevent users from playing with $SSH_CLIENT.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.15 2002/05/21 19:48:04 deraadt Exp $	*/
d73 2
d76 2
a77 2
char luser[MAXLOGNAME] = "";	/* username */
char ipsrc[256] = "";		/* ip as a string */
a81 1
static volatile sig_atomic_t want_death;
d88 1
a88 1
static void	read_config(void);
d94 4
a97 2
static void	need_death(int s);
static __dead void	do_death(void);
d108 9
a116 19
	int pidfd, ufd, namelen;
	int lockcnt = 0;
	char *foo, *cp;
	FILE *fp = NULL;
	struct passwd *pwp;
	struct sockaddr *namep;
	struct sockaddr_in peer;
	char bannedir[] = PATH_BAN_DIR;

	namep = (struct sockaddr *)&peer;
	namelen = sizeof(peer);

	read_config();

	memset(namep, 0, namelen);

	pwp = getpwuid(getuid());
	if (pwp == NULL) {
		syslog(LOG_ERR, "can't find user for uid %d", getuid());
a117 1
	}
d119 2
a120 3
	if (strcmp(pwp->pw_shell, PATH_AUTHPF_SHELL)) {
		syslog(LOG_ERR, "wrong shell for user %s, uid %u",
		    pwp->pw_name, pwp->pw_uid);
d124 4
a127 20
	strlcpy(luser, pwp->pw_name, sizeof(luser));

	if ((foo = getenv("SSH_CLIENT")) != NULL) {
		struct in_addr jnk;
		strlcpy(ipsrc, foo, sizeof(ipsrc));
		cp = ipsrc;
		while (*cp != '\0') {
			if (*cp == ' ')
				*cp = '\0';
			else
				cp++;
		}
		if (inet_pton(AF_INET, ipsrc, &jnk) != 1) {
			syslog(LOG_ERR, "Can't get IP from SSH_CLIENT %s",
			    ipsrc);
			exit(1);
		}

	} else {
		syslog(LOG_ERR, "Can't determine connection source");
d130 4
a133 3
	if (!check_luser(bannedir, luser) || !allowed_luser(luser)) {
		/* give the luser time to read our nastygram on the screen */
		sleep(180);
d137 5
a141 9
	/*
	 * make ourselves an entry in /var/run as /var/run/authpf-ipaddr,
	 * so that things may find us easily to kill us if necessary.
	 */
	if (snprintf(pidfile, sizeof pidfile, "%s-%s", PATH_PIDFILE, ipsrc) >=
	    sizeof pidfile) {
		fprintf(stderr, "Sorry, host too long for me to handle..\n");
		syslog(LOG_ERR, "snprintf pidfile bogosity  - exiting");
		goto dogdeath;
d144 10
a153 5
	if ((pidfd = open(pidfile, O_RDWR|O_CREAT, 0644)) == -1 ||
	    (fp = fdopen(pidfd, "r+")) == NULL) {
		syslog(LOG_ERR, "can't open or create %s: %s",
		    pidfile, strerror(errno));
		goto dogdeath;
d155 4
d162 2
a163 3
	 * wants to switch users - so kill the old process and we
	 * exit as well. Of course, this will only work if we are
	 * running with priviledge.
d174 21
a194 7
	while (flock(pidfd, LOCK_EX|LOCK_NB) == -1 && errno != EBADF) {
		int otherpid = -1;
		int save_errno = errno;

		lockcnt++;
		fscanf(fp, "%d", &otherpid);
		syslog(LOG_DEBUG, "Tried to lock %s, in use by pid %d: %s",
a195 1
		fclose(fp);
a196 1
		close(pidfd);
d209 1
a209 1
		 * we try to kill the previous process and aquire the lock
d213 1
a213 1
		if (lockcnt > 10) {
a218 1
	}
d220 6
a225 12
	fp = fopen(pidfile, "w+");
	rewind(fp);
	fprintf(fp, "%d\n", getpid());
	fflush(fp);
	(void) ftruncate(fileno(fp), ftell(fp));

	/* open the pf device */
	dev = open (PATH_DEVFILE, O_RDWR);
	if (dev == -1) {
		syslog(LOG_ERR, "Can't open filter device (%m)");
		goto dogdeath;
	}
d228 1
a228 1
	 * make an entry in file /var/authpf/ipaddr, containing the username.
d239 21
a261 1
	close(ufd);
d264 2
a265 1
		/* XXX */
d282 1
a282 1
				do_death();
d285 1
d287 1
a287 1
 dogdeath:
d294 2
a295 5
	if (pidfile[0] != '\0')
		unlink(pidfile); /* fail silently */
	if (userfile[0] != '\0')
		unlink(userfile); /* fail silently */
	exit(1);
d301 2
a302 2
static void
read_config(void)
a305 5
	FILE *f;

	f = fopen(PATH_CONFFILE, "r");
	if (f == NULL) 
		exit(1); /* exit silently if we have no config file */
d315 1
a315 1
			return;
d322 1
a322 1
			exit(1);
d369 2
a370 2
	return;
 parse_error:
d373 1
a373 1
	exit(1);
a411 1
 *
d417 1
a419 1
	int matched;
d424 1
a424 1
			 * PATH_ALLOWFILE doesn't exist, this this gateway
d427 1
a427 1
			return (1);
d437 1
a437 1
		return (0);
d466 1
a466 1
				return (1); /* matched an allowed username */
d476 1
a476 1
	return (0);
d499 1
a499 1
		return (0);
d507 1
a507 1
			return (1);
d516 1
a516 1
			return (0);
d532 1
a532 1
				return (0);
d537 1
a537 1
	return (0);
d771 1
a771 1
	return (ret);
d808 1
a808 1
need_death(int s)
d817 1
a817 1
do_death(void)
d821 12
a832 10
	changefilter(0, luser, ipsrc);
	authpf_kill_states();
	if (unlink(pidfile) != 0) {
		syslog(LOG_ERR, "Couldn't unlink %s! (%m)", pidfile);
		ret = 1;
	}
	if (unlink(userfile) != 0) {
		syslog(LOG_ERR, "Couldn't unlink %s! (%m)", userfile);
		ret = 1;
	}
@


1.15
log
@KNF before more major hacking
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.14 2002/05/16 09:18:55 deraadt Exp $	*/
d124 6
@


1.14
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.13 2002/04/24 23:03:56 dhartmei Exp $	*/
a28 1
 *
a77 2
char configfile[] = PATH_CONFFILE;
char allowfile[] = PATH_ALLOWFILE;
d80 1
a80 1
static volatile sig_atomic_t hasta_la_vista;
d93 2
a94 2
static void	terminator(int s);
static __dead void	go_away(void);
d123 1
a123 1
		syslog (LOG_ERR, "can't find user for uid %d", getuid());
d140 1
a140 1
			syslog (LOG_ERR, "Can't get IP from SSH_CLIENT %s",
d194 1
a194 1
		syslog (LOG_DEBUG, "Tried to lock %s, in use by pid %d: %s",
d202 1
a202 1
			    otherpid,  ipsrc, luser);
d204 1
a204 1
				syslog (LOG_INFO,
d256 8
a263 8
	signal(SIGTERM, terminator);
	signal(SIGINT, terminator);
	signal(SIGALRM, terminator);
	signal(SIGPIPE, terminator);
	signal(SIGHUP, terminator);
	signal(SIGSTOP, terminator);
	signal(SIGTSTP, terminator);
	while(1) {
d269 2
a270 2
			if (hasta_la_vista)
				go_away();
d298 1
a298 1
	f = fopen(configfile, "r");
d316 1
a316 1
			    configfile);
d367 1
a367 1
	syslog(LOG_ERR, "parse error, line %d of %s", i, configfile);
d417 1
a417 1
	if ((f = fopen(allowfile, "r")) == NULL) {
d420 1
a420 1
			 * allowfile doesn't exist, this this gateway
d423 1
a423 1
			return(1);
d432 2
a433 2
		    allowfile, strerror(errno));
		return(0);
d462 1
a462 1
				return(1); /* matched an allowed username */
d465 1
a465 1
		    luser, allowfile);
d472 1
a472 1
	return(0);
d495 1
a495 1
		return(0);
d503 1
a503 1
			return(1);
d510 1
a510 1
			syslog (LOG_ERR, "Can't open banned file %s (%s)",
d512 1
a512 1
			return(0);
d525 1
a525 1
		while((fputs(tmp, stdout) != EOF) && !feof(f)) {
d528 1
a528 1
				return(0);
d533 1
a533 1
	return(0);
d555 2
a556 2
	memset (&pf, 0, sizeof(pf));
	memset (&pr, 0, sizeof(pr));
d558 1
a558 1
	syslog (LOG_DEBUG, "%s filter for ip=%s, user %s",
d761 1
a761 1
		syslog (LOG_INFO, "Allowing %s, user %s", ipsrc, luser);
d764 1
a764 1
		syslog (LOG_INFO, "Removed %s, user %s - duration %ld seconds",
d767 1
a767 1
	return(ret);
d804 1
a804 1
terminator(int s)
d806 1
a806 1
	hasta_la_vista = 1;
d813 1
a813 1
go_away(void)
@


1.13
log
@Unbreak from pfvar.h change.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.12 2002/04/09 23:19:01 frantzen Exp $	*/
a99 1
 * authpf:
d131 1
a131 1
	
a161 1

a190 1

d213 2
a214 1
		/* we try to kill the previous process and aquire the lock
a217 1

a232 1

a244 1

d291 1
a291 1
/* read_config:
a293 1

d306 1
a306 1
	
a375 1
 * print_message:
a400 1
 * allowed_luser:
a444 1

a478 1
 * check_luser:
a521 1

a540 1
 * changefilter:
a564 1

a583 1

d600 1
a600 1
		}			
d739 1
a740 1

a773 1
 * authpf_kill_states:
a812 1
 * go_away:
a833 1
 * pfctl_add_rules:
a857 1
 * pfctl_add_nat:
a880 1
 * pfctl_add_rdr:
a903 1
 * pfctl_add_binat:
@


1.12
log
@make sure we fflush() after a sending a message and fix a typo in a comment
ok beck@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.11 2002/04/09 20:07:16 beck Exp $	*/
d807 1
a807 1
	psk.psk_src.addr.v4 = target;
d814 1
a814 1
	psk.psk_dst.addr.v4 = target;
@


1.11
log
@don't trust USER from the environment - bad, allows users to see files
they shouldn't
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.10 2002/04/09 17:40:40 deraadt Exp $	*/
d403 1
d789 1
a789 1
 * This is to kill off states that would otherwide be left behind stateful
@


1.10
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.9 2002/04/08 16:12:49 mpech Exp $	*/
d53 1
d113 1
d125 3
a127 6
	if ((foo = getenv("LOGNAME")) != NULL)
		strlcpy(luser, foo, sizeof(luser));
	else if ((foo = getenv("USER")) != NULL)
		strlcpy(luser, foo, sizeof(luser));
	else {
		syslog(LOG_ERR, "No user given!");
d131 2
d134 1
d143 6
@


1.9
log
@Free memory. Patch from millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.8 2002/04/07 16:31:27 frantzen Exp $	*/
d417 1
a417 1
       int matched;
d457 1
a457 1
                       matched = strcmp(luser, buf) == 0 || strcmp("*", buf) == 0;
d464 2
a465 2
                       if (matched)
                               return(1); /* matched an allowed username */
@


1.8
log
@fix authpf_kill_states()
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.7 2002/04/05 20:35:52 deraadt Exp $	*/
d417 1
d457 1
a457 2
			if (strcmp(luser, buf) == 0 || strcmp("*", buf) == 0)
				return(1); /* matched an allowed username */
d463 3
@


1.7
log
@move location of per-user config files; beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d787 1
a787 1
	struct in_addr target, temp;
d790 1
a790 3
	memset(&psk.psk_src.mask, 0xff, sizeof(psk.psk_src.mask));
	memset(&target, 0xff, sizeof(target));
	memset(&temp, 0xff, sizeof(temp));
a791 1
	inet_pton(AF_INET, "255.255.255.255", &temp);
d794 1
d796 1
a796 1
	psk.psk_dst.addr.v4 = temp;
d800 2
d803 1
a803 1
	psk.psk_src.addr.v4 = temp;
@


1.6
log
@ensure that rules files are owned and writable only by root,
along their entire path, change docs accordingly. This ensures
that people don't accidentally use the $HOME config files to
override real settings unless root meant to do it.
@
text
@d1 2
a96 1
static int	secure_fullpath(char *);
a302 4
	if (secure_fullpath(configfile) != 0)
		/* config file exists, but is not secure */
		exit(1);

a556 1
	char *cp;
d590 2
a591 6
	if ((cp = getenv("HOME")) == NULL) {
		syslog(LOG_ERR, "No Home Directory!");
		goto error;
	}
	if (snprintf(rulesfile, sizeof rulesfile, "%s/.authpf/authpf.rules",
	    cp) >= sizeof rulesfile) {
a613 4
	if (secure_fullpath(rulesfile) != 0)
		/* rules file exists, but is not secure */
		goto error;
	
d662 2
a663 7
	/* now, for NAT, if we have some */
	if ((cp = getenv("HOME")) == NULL) {
		syslog(LOG_ERR, "No Home Directory!");
		goto error;
	}
	if (snprintf(natfile, sizeof natfile, "%s/.authpf/authpf.nat", cp) >=
	    sizeof natfile) {
d690 1
a690 4
	if (from_fd != -1 && secure_fullpath(natfile) != 0) 
		/* nat file exists, but is not secure */
		goto error;
	
a834 41
}

/*
 * secure_fullpath:
 * akin to secure_path, but for a directory - needed to ensure
 * users can't get something they aren't supposed to by moveing
 * files aside or linking other directories, such as the default
 * one.
 */
static int
secure_fullpath(char *path)
{
	struct stat sb;
	char *cp;

	if (secure_path(path) < 0)
		return(-1);

	cp = path;

	do {
		cp = dirname(cp);
		memset(&sb, 0, sizeof(sb)); 
		/*
		 * if it's owned or writable by someone
		 * other than root, it's bad. since these are directories,
		 * not the end path, they are allowed to be symbolic links
		 * and other such things (unlike the file itself). 
		 */
		if (lstat(cp, &sb) < 0) {
			syslog(LOG_ERR, "cannot stat %s: %m", cp);
			return (-1);
		} else if (sb.st_uid != 0) {
			syslog(LOG_ERR, "%s: not owned by root", cp);
			return (-1);
		} else if (sb.st_mode & (S_IWGRP | S_IWOTH)) {
			syslog(LOG_ERR, "%s: writeable by non-root", cp);
			return (-1);
		}
	} while (strlen(cp) > 1);
        return (0);
@


1.5
log
@don't need this anymore
@
text
@d48 2
d95 1
d302 4
d610 9
d621 3
a623 6
	snprintf(rulesfile, sizeof rulesfile, PATH_PFRULES);
	if (from_fd == -1 &&
	    (from_fd = open(rulesfile, O_RDONLY, 0)) == -1) {
		syslog(LOG_ERR, "can't open %s (%m)", rulesfile);
		if (unlink(template) == -1)
			syslog(LOG_ERR, "can't unlink %s", template);
d625 1
a625 2
	}

a674 1

d693 12
a704 10
	snprintf(natfile, sizeof natfile, PATH_NATRULES);
	if (from_fd == -1 &&
	    (from_fd = open(natfile, O_RDONLY, 0)) == -1) {
		if (errno == ENOENT)
			goto out; /* NAT is optional */
		else {
			syslog(LOG_ERR, "can't open %s (%m)", natfile);
			if (unlink(template) == -1)
				syslog(LOG_ERR, "can't unlink %s", template);
			goto error;
d707 4
d855 41
@


1.4
log
@typo in comment
@
text
@a54 1
#include <sysexits.h>
@


1.3
log
@-Tattling is bad, users should be allowed to run anything on the system
without it generating logs
-exit with 0 and 1 instead of EX_FOO
-make read_config (with the test and exit) the first thing that
happens in main, no openlog or memset first.
@
text
@d286 1
a286 1
 * reads config file in PATH_CONFILE to set optional behaviours up
@


1.2
log
@-Make the /etc/authpf/authpf.conf config file required.
-Change authpf to install setuid by default, and exit with a tattling
syslog message if a user runs it without a config file present.
-Change man page to reflect this.
@
text
@a114 1
	memset(namep, 0, namelen);
d116 1
a116 1
	openlog("authpf", LOG_PID | LOG_NDELAY, LOG_DAEMON);
d118 1
a118 1
	read_config();
d126 1
a126 1
		exit(EX_CONFIG);
d140 1
a140 1
		exit(EX_CONFIG);
d145 1
a145 1
		exit(EX_NOPERM);
d282 1
a282 1
	exit(EX_CONFIG);
d297 2
a298 9
	if (f == NULL) {
		if (errno == ENOTDIR || errno == ENOENT)
			/* if the config file is not present, refuse to run */
			syslog(LOG_INFO, "run by uid %d but no %s file exits",
			    getuid(), configfile);
		else 
			syslog(LOG_INFO, "can't open %s (%m)", configfile);
		exit(EX_CONFIG);
	}
d300 2
d315 1
a315 1
			exit(EX_CONFIG);
d366 1
a366 1
	exit(EX_CONFIG);
d826 1
a826 1
	int ret = EX_OK;
d832 1
a832 1
		ret = EX_OSERR;
d836 1
a836 1
		ret = EX_OSERR;
@


1.1
log
@authpf - authenticating gateway shell for use with ssh(1) to make
authenticating gateway type firewalls.

caveats - needs to be setuid to opertate (but does not install that way)
consult the man page for configuration issues.
@
text
@d298 9
a306 2
	if (f == NULL)
		return; /* fail silently, run with defaults */
@

