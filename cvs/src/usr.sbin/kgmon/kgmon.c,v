head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.10
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.6
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.10
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.10
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.08.27.01.50.07;	author guenther;	state Exp;
branches;
next	1.23;
commitid	ikVlcUgcgDzn9GW3;

1.23
date	2015.11.16.17.29.43;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	pZ93SAY9RDhLPT1l;

1.22
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	z3HrihslRYb4HqW9;

1.21
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2013.11.27.13.32.02;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.12.13.09.22;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.17;

1.17
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.16;

1.16
date	2013.02.11.17.08.53;	author mpi;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.26.09.28.34;	author martynas;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.04.04.06.06;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.18.20.51.46;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.01.18.32.19;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.06.51.42;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.28.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.17.13.42.35;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.05.07.32.39;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	98.12.20.23.59.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.44.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.05.01.22.15.24;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Pull in <sys/time.h> for struct timespec, timeval, or clockrate

ok deraadt@@
@
text
@/*	$OpenBSD: kgmon.c,v 1.23 2015/11/16 17:29:43 deraadt Exp $	*/

/*
 * Copyright (c) 1983, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/file.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/gmon.h>
#include <errno.h>
#include <err.h>
#include <kvm.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <nlist.h>
#include <ctype.h>
#include <paths.h>

struct nlist nl[] = {
#define	N_GMONPARAM	0
	{ "__gmonparam" },
#define	N_PROFHZ	1
	{ "_profhz" },
	{ NULL }
};

struct kvmvars {
	kvm_t	*kd;
	struct gmonparam gpm;
};

extern char *__progname;

int	bflag, cflag, hflag, kflag, rflag, pflag;
int	debug = 0;
void	kgmon(char *, char *, struct kvmvars *, int);
void	setprof(struct kvmvars *, int, int);
void	dumpstate(struct kvmvars *, int);
void	reset(struct kvmvars *, int);
void	kern_readonly(int);
int	getprof(struct kvmvars *, int);
int	getprofhz(struct kvmvars *);
int	openfiles(char *, char *, struct kvmvars *, int);
int	getncpu(void);

int
main(int argc, char **argv)
{
	int ch, ncpu, cpuid = -1;
	struct kvmvars kvmvars;
	char *sys, *kmemf;
	const char *p;

	kmemf = NULL;
	sys = NULL;
	while ((ch = getopt(argc, argv, "M:N:bc:hpr")) != -1) {
		switch(ch) {

		case 'M':
			kmemf = optarg;
			kflag = 1;
			break;

		case 'N':
			sys = optarg;
			break;

		case 'b':
			bflag = 1;
			break;

		case 'c':
			cflag = 1;
			cpuid = strtonum(optarg, 0, 1024, &p);
			if (p)
				errx(1, "illegal CPU id %s: %s", optarg, p);
			break;

		case 'h':
			hflag = 1;
			break;

		case 'p':
			pflag = 1;
			break;

		case 'r':
			rflag = 1;
			break;

		default:
			fprintf(stderr, "usage: %s [-bhpr] "
			    "[-c cpuid] [-M core] [-N system]\n", __progname);
			exit(1);
		}
	}
	argc -= optind;
	argv += optind;

#define BACKWARD_COMPATIBILITY
#ifdef	BACKWARD_COMPATIBILITY
	if (*argv) {
		sys = *argv;
		if (*++argv) {
			kmemf = *argv;
			++kflag;
		}
	}
#endif

	if (cflag) {
		kgmon(sys, kmemf, &kvmvars, cpuid);
	} else {
		ncpu = getncpu();
		for (cpuid = 0; cpuid < ncpu; cpuid++)
			kgmon(sys, kmemf, &kvmvars, cpuid);
	}

	return (0);
}

void
kgmon(char *sys, char *kmemf, struct kvmvars *kvp, int cpuid)
{
	int mode, disp, accessmode;

	accessmode = openfiles(sys, kmemf, kvp, cpuid);
	mode = getprof(kvp, cpuid);
	if (hflag)
		disp = GMON_PROF_OFF;
	else if (bflag)
		disp = GMON_PROF_ON;
	else
		disp = mode;
	if (pflag)
		dumpstate(kvp, cpuid);
	if (rflag)
		reset(kvp, cpuid);
	if (accessmode == O_RDWR)
		setprof(kvp, cpuid, disp);
	printf("%s: kernel profiling is %s for cpu %d.\n", __progname,
	    disp == GMON_PROF_OFF ? "off" : "running", cpuid);
}

/*
 * Check that profiling is enabled and open any ncessary files.
 */
int
openfiles(char *sys, char *kmemf, struct kvmvars *kvp, int cpuid)
{
	int mib[4], state, openmode;
	size_t size;
	char errbuf[_POSIX2_LINE_MAX];

	if (!kflag) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROF;
		mib[2] = GPROF_STATE;
		mib[3] = cpuid;
		size = sizeof state;
		if (sysctl(mib, 4, &state, &size, NULL, 0) < 0)
			errx(20, "profiling not defined in kernel.");
		if (!(bflag || hflag || rflag ||
		    (pflag && state == GMON_PROF_ON)))
			return (O_RDONLY);
		if (sysctl(mib, 4, NULL, NULL, &state, size) >= 0)
			return (O_RDWR);
		kern_readonly(state);
		return (O_RDONLY);
	}
	openmode = (bflag || hflag || pflag || rflag) ? O_RDWR : O_RDONLY;
	kvp->kd = kvm_openfiles(sys, kmemf, NULL, openmode, errbuf);
	if (kvp->kd == NULL) {
		if (openmode == O_RDWR) {
			openmode = O_RDONLY;
			kvp->kd = kvm_openfiles(sys, kmemf, NULL, O_RDONLY,
			    errbuf);
		}
		if (kvp->kd == NULL)
			errx(2, "kvm_openfiles: %s", errbuf);
		kern_readonly(GMON_PROF_ON);
	}
	if (kvm_nlist(kvp->kd, nl) < 0)
		errx(3, "%s: no namelist", sys ? sys : _PATH_UNIX);
	if (!nl[N_GMONPARAM].n_value)
		errx(20, "profiling not defined in kernel.");
	return (openmode);
}

/*
 * Suppress options that require a writable kernel.
 */
void
kern_readonly(int mode)
{
	extern char *__progname;

	(void)fprintf(stderr, "%s: kernel read-only: ", __progname);
	if (pflag && mode == GMON_PROF_ON)
		(void)fprintf(stderr, "data may be inconsistent\n");
	if (rflag)
		(void)fprintf(stderr, "-r suppressed\n");
	if (bflag)
		(void)fprintf(stderr, "-b suppressed\n");
	if (hflag)
		(void)fprintf(stderr, "-h suppressed\n");
	rflag = bflag = hflag = 0;
}

/*
 * Get the state of kernel profiling.
 */
int
getprof(struct kvmvars *kvp, int cpuid)
{
	int mib[4];
	size_t size;

	if (kflag) {
		size = kvm_read(kvp->kd, nl[N_GMONPARAM].n_value, &kvp->gpm,
		    sizeof kvp->gpm);
	} else {
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROF;
		mib[2] = GPROF_GMONPARAM;
		mib[3] = cpuid;
		size = sizeof kvp->gpm;
		if (sysctl(mib, 4, &kvp->gpm, &size, NULL, 0) < 0)
			size = 0;
	}
	if (size != sizeof kvp->gpm)
		errx(4, "cannot get gmonparam: %s",
		    kflag ? kvm_geterr(kvp->kd) : strerror(errno));
	return (kvp->gpm.state);
}

/*
 * Enable or disable kernel profiling according to the state variable.
 */
void
setprof(struct kvmvars *kvp, int cpuid, int state)
{
	struct gmonparam *p = (struct gmonparam *)nl[N_GMONPARAM].n_value;
	int mib[4], oldstate;
	size_t sz;

	sz = sizeof(state);
	if (!kflag) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROF;
		mib[2] = GPROF_STATE;
		mib[3] = cpuid;
		if (sysctl(mib, 4, &oldstate, &sz, NULL, 0) < 0)
			goto bad;
		if (oldstate == state)
			return;
		if (sysctl(mib, 4, NULL, NULL, &state, sz) >= 0)
			return;
	} else if (kvm_write(kvp->kd, (u_long)&p->state, (void *)&state, sz)
	    == sz)
		return;
bad:
	warnx("warning: cannot turn profiling %s",
	    state == GMON_PROF_OFF ? "off" : "on");
}

/*
 * Build the gmon.out file.
 */
void
dumpstate(struct kvmvars *kvp, int cpuid)
{
	FILE *fp;
	struct rawarc rawarc;
	struct tostruct *tos;
	u_long frompc;
	u_short *froms, *tickbuf;
	int mib[4];
	size_t i;
	struct gmonhdr h;
	int fromindex, endfrom, toindex;
	char buf[16];

	snprintf(buf, sizeof(buf), "gmon-%02d.out", cpuid);

	setprof(kvp, cpuid, GMON_PROF_OFF);
	fp = fopen(buf, "w");
	if (fp == 0) {
		perror(buf);
		return;
	}

	/*
	 * Build the gmon header and write it to a file.
	 */
	bzero(&h, sizeof(h));
	h.lpc = kvp->gpm.lowpc;
	h.hpc = kvp->gpm.highpc;
	h.ncnt = kvp->gpm.kcountsize + sizeof(h);
	h.version = GMONVERSION;
	h.profrate = getprofhz(kvp);
	fwrite((char *)&h, sizeof(h), 1, fp);

	/*
	 * Write out the tick buffer.
	 */
	mib[0] = CTL_KERN;
	mib[1] = KERN_PROF;
	if ((tickbuf = malloc(kvp->gpm.kcountsize)) == NULL)
		errx(5, "cannot allocate kcount space");
	if (kflag) {
		i = kvm_read(kvp->kd, (u_long)kvp->gpm.kcount, (void *)tickbuf,
		    kvp->gpm.kcountsize);
	} else {
		mib[2] = GPROF_COUNT;
		mib[3] = cpuid;
		i = kvp->gpm.kcountsize;
		if (sysctl(mib, 4, tickbuf, &i, NULL, 0) < 0)
			i = 0;
	}
	if (i != kvp->gpm.kcountsize)
		errx(6, "read ticks: read %lu, got %zu: %s",
		    kvp->gpm.kcountsize, i,
		    kflag ? kvm_geterr(kvp->kd) : strerror(errno));
	if ((fwrite(tickbuf, kvp->gpm.kcountsize, 1, fp)) != 1)
		err(7, "writing tocks to gmon.out");
	free(tickbuf);

	/*
	 * Write out the arc info.
	 */
	if ((froms = malloc(kvp->gpm.fromssize)) == NULL)
		errx(8, "cannot allocate froms space");
	if (kflag) {
		i = kvm_read(kvp->kd, (u_long)kvp->gpm.froms, (void *)froms,
		    kvp->gpm.fromssize);
	} else {
		mib[2] = GPROF_FROMS;
		mib[3] = cpuid;
		i = kvp->gpm.fromssize;
		if (sysctl(mib, 4, froms, &i, NULL, 0) < 0)
			i = 0;
	}
	if (i != kvp->gpm.fromssize)
		errx(9, "read froms: read %lu, got %zu: %s",
		    kvp->gpm.fromssize, i,
		    kflag ? kvm_geterr(kvp->kd) : strerror(errno));
	if ((tos = malloc(kvp->gpm.tossize)) == NULL)
		errx(10, "cannot allocate tos space");
	if (kflag) {
		i = kvm_read(kvp->kd, (u_long)kvp->gpm.tos, (void *)tos,
		    kvp->gpm.tossize);
	} else {
		mib[2] = GPROF_TOS;
		mib[3] = cpuid;
		i = kvp->gpm.tossize;
		if (sysctl(mib, 4, tos, &i, NULL, 0) < 0)
			i = 0;
	}
	if (i != kvp->gpm.tossize)
		errx(11, "read tos: read %lu, got %zu: %s",
		    kvp->gpm.tossize, i,
		    kflag ? kvm_geterr(kvp->kd) : strerror(errno));
	if (debug)
		warnx("lowpc 0x%lx, textsize 0x%lx",
		    kvp->gpm.lowpc, kvp->gpm.textsize);
	endfrom = kvp->gpm.fromssize / sizeof(*froms);
	for (fromindex = 0; fromindex < endfrom; ++fromindex) {
		if (froms[fromindex] == 0)
			continue;
		frompc = (u_long)kvp->gpm.lowpc +
		    (fromindex * kvp->gpm.hashfraction * sizeof(*froms));
		for (toindex = froms[fromindex]; toindex != 0;
		   toindex = tos[toindex].link) {
			if (debug)
			  warnx("[mcleanup] frompc 0x%lx selfpc 0x%lx count %ld",
			    frompc, tos[toindex].selfpc, tos[toindex].count);
			rawarc.raw_frompc = frompc;
			rawarc.raw_selfpc = (u_long)tos[toindex].selfpc;
			rawarc.raw_count = tos[toindex].count;
			fwrite((char *)&rawarc, sizeof(rawarc), 1, fp);
		}
	}
	fclose(fp);
}

/*
 * Get the profiling rate.
 */
int
getprofhz(struct kvmvars *kvp)
{
	int mib[2], profrate;
	size_t size;
	struct clockinfo clockrate;

	if (kflag) {
		profrate = 1;
		if (kvm_read(kvp->kd, nl[N_PROFHZ].n_value, &profrate,
		    sizeof profrate) != sizeof profrate)
			warnx("get clockrate: %s", kvm_geterr(kvp->kd));
		return (profrate);
	}
	mib[0] = CTL_KERN;
	mib[1] = KERN_CLOCKRATE;
	clockrate.profhz = 1;
	size = sizeof clockrate;
	if (sysctl(mib, 2, &clockrate, &size, NULL, 0) < 0)
		warn("get clockrate");
	return (clockrate.profhz);
}

/*
 * Reset the kernel profiling date structures.
 */
void
reset(struct kvmvars *kvp, int cpuid)
{
	char *zbuf;
	u_long biggest;
	int mib[4];

	setprof(kvp, cpuid, GMON_PROF_OFF);

	biggest = kvp->gpm.kcountsize;
	if (kvp->gpm.fromssize > biggest)
		biggest = kvp->gpm.fromssize;
	if (kvp->gpm.tossize > biggest)
		biggest = kvp->gpm.tossize;
	if ((zbuf = malloc(biggest)) == NULL)
		errx(12, "cannot allocate zbuf space");
	bzero(zbuf, biggest);
	if (kflag) {
		if (kvm_write(kvp->kd, (u_long)kvp->gpm.kcount, zbuf,
		    kvp->gpm.kcountsize) != kvp->gpm.kcountsize)
			errx(13, "tickbuf zero: %s", kvm_geterr(kvp->kd));
		if (kvm_write(kvp->kd, (u_long)kvp->gpm.froms, zbuf,
		    kvp->gpm.fromssize) != kvp->gpm.fromssize)
			errx(14, "froms zero: %s", kvm_geterr(kvp->kd));
		if (kvm_write(kvp->kd, (u_long)kvp->gpm.tos, zbuf,
		    kvp->gpm.tossize) != kvp->gpm.tossize)
			errx(15, "tos zero: %s", kvm_geterr(kvp->kd));
		return;
	}
	mib[0] = CTL_KERN;
	mib[1] = KERN_PROF;
	mib[2] = GPROF_COUNT;
	mib[3] = cpuid;
	if (sysctl(mib, 4, NULL, NULL, zbuf, kvp->gpm.kcountsize) < 0)
		err(13, "tickbuf zero");
	mib[2] = GPROF_FROMS;
	if (sysctl(mib, 4, NULL, NULL, zbuf, kvp->gpm.fromssize) < 0)
		err(14, "froms zero");
	mib[2] = GPROF_TOS;
	if (sysctl(mib, 4, NULL, NULL, zbuf, kvp->gpm.tossize) < 0)
		err(15, "tos zero");
	free(zbuf);
}

int
getncpu(void)
{
	int mib[2] = { CTL_HW, HW_NCPU };
	size_t size;
	int ncpu;

	size = sizeof(ncpu);
	if (sysctl(mib, 2, &ncpu, &size, NULL, 0) < 0) {
		warnx("cannot read hw.ncpu");
		return (1);
	}

	return (ncpu);
}
@


1.23
log
@delete setuid code (which we disabled in 2002)
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.22 2015/08/20 22:39:29 deraadt Exp $	*/
d34 1
@


1.22
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.21 2015/01/16 06:40:17 deraadt Exp $	*/
a81 1
	seteuid(getuid());
a193 1
		(void)seteuid(0);
a195 1
		(void)seteuid(getuid());
d285 1
a285 3
		(void)seteuid(0);
		if (sysctl(mib, 4, NULL, NULL, &state, sz) >= 0) {
			(void)seteuid(getuid());
a286 2
		}
		(void)seteuid(getuid());
a472 1
	(void)seteuid(0);
a484 1
	(void)seteuid(getuid());
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.20 2013/11/27 13:32:02 okan Exp $	*/
d344 1
a344 1
	if ((tickbuf = (u_short *)malloc(kvp->gpm.kcountsize)) == NULL)
d367 1
a367 1
	if ((froms = (u_short *)malloc(kvp->gpm.fromssize)) == NULL)
d383 1
a383 1
	if ((tos = (struct tostruct *)malloc(kvp->gpm.tossize)) == NULL)
d465 1
a465 1
	if ((zbuf = (char *)malloc(biggest)) == NULL)
@


1.20
log
@remove erroneous char cast to switch expression processing getopt(3);
not used in any cases.

ok deraadt@@, guenther@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.19 2013/11/12 13:09:22 deraadt Exp $	*/
a31 1
#include <sys/param.h>
@


1.19
log
@unused variable in the shadows
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.18 2013/03/12 09:37:16 mpi Exp $	*/
d87 1
a87 1
		switch((char)ch) {
@


1.18
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.17 2013/02/12 08:06:22 mpi Exp $	*/
d78 1
a78 1
	int ch, err, ncpu, cpuid = -1;
@


1.17
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.16 2013/02/11 17:08:53 mpi Exp $	*/
d61 3
a63 1
int	bflag, hflag, kflag, rflag, pflag;
d65 4
a68 3
void	setprof(struct kvmvars *, int);
void	dumpstate(struct kvmvars *);
void	reset(struct kvmvars *);
d70 1
a70 1
int	getprof(struct kvmvars *);
d72 2
a73 1
int	openfiles(char *, char *, struct kvmvars *);
d78 1
a78 2
	extern char *__progname;
	int ch, mode, disp, accessmode;
d81 1
d86 1
a86 1
	while ((ch = getopt(argc, argv, "M:N:bhpr")) != -1) {
d102 7
d122 2
a123 3
			fprintf(stderr,
			    "usage: %s [-bhpr] [-M core] [-N system]\n",
			    __progname);
d140 19
a158 2
	accessmode = openfiles(sys, kmemf, &kvmvars);
	mode = getprof(&kvmvars);
d166 1
a166 1
		dumpstate(&kvmvars);
d168 1
a168 1
		reset(&kvmvars);
d170 3
a172 4
		setprof(&kvmvars, disp);
	printf("%s: kernel profiling is %s.\n", __progname,
	    disp == GMON_PROF_OFF ? "off" : "running");
	return (0);
d179 1
a179 1
openfiles(char *sys, char *kmemf, struct kvmvars *kvp)
d181 1
a181 1
	int mib[3], state, openmode;
d189 1
d191 1
a191 1
		if (sysctl(mib, 3, &state, &size, NULL, 0) < 0)
d197 1
a197 1
		if (sysctl(mib, 3, NULL, NULL, &state, size) >= 0)
d246 1
a246 1
getprof(struct kvmvars *kvp)
d248 1
a248 1
	int mib[3];
d258 1
d260 1
a260 1
		if (sysctl(mib, 3, &kvp->gpm, &size, NULL, 0) < 0)
d273 1
a273 1
setprof(struct kvmvars *kvp, int state)
d276 1
a276 1
	int mib[3], oldstate;
d284 2
a285 1
		if (sysctl(mib, 3, &oldstate, &sz, NULL, 0) < 0)
d290 1
a290 1
		if (sysctl(mib, 3, NULL, NULL, &state, sz) >= 0) {
d307 1
a307 1
dumpstate(struct kvmvars *kvp)
d314 1
a314 1
	int mib[3];
d318 1
d320 4
a323 2
	setprof(kvp, GMON_PROF_OFF);
	fp = fopen("gmon.out", "w");
d325 1
a325 1
		perror("gmon.out");
d352 1
d354 1
a354 1
		if (sysctl(mib, 3, tickbuf, &i, NULL, 0) < 0)
d375 1
d377 1
a377 1
		if (sysctl(mib, 3, froms, &i, NULL, 0) < 0)
d391 1
d393 1
a393 1
		if (sysctl(mib, 3, tos, &i, NULL, 0) < 0)
d453 1
a453 1
reset(struct kvmvars *kvp)
d457 1
a457 1
	int mib[3];
d459 1
a459 1
	setprof(kvp, GMON_PROF_OFF);
d485 2
a486 1
	if (sysctl(mib, 3, NULL, NULL, zbuf, kvp->gpm.kcountsize) < 0)
d489 1
a489 1
	if (sysctl(mib, 3, NULL, NULL, zbuf, kvp->gpm.fromssize) < 0)
d492 1
a492 1
	if (sysctl(mib, 3, NULL, NULL, zbuf, kvp->gpm.tossize) < 0)
d496 16
@


1.16
log
@Teach kgmon(8) to deal with per-CPU kernel profiling.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.15 2009/10/27 23:59:51 deraadt Exp $	*/
d61 1
a61 3
extern char *__progname;

int	bflag, cflag, hflag, kflag, rflag, pflag;
d63 3
a65 4
void	kgmon(char *, char *, struct kvmvars *, int);
void	setprof(struct kvmvars *, int, int);
void	dumpstate(struct kvmvars *, int);
void	reset(struct kvmvars *, int);
d67 1
a67 1
int	getprof(struct kvmvars *, int);
d69 1
a69 2
int	openfiles(char *, char *, struct kvmvars *, int);
int	getncpu(void);
d74 2
a75 1
	int ch, err, ncpu, cpuid = -1;
a77 1
	const char *p;
d82 1
a82 1
	while ((ch = getopt(argc, argv, "M:N:bc:hpr")) != -1) {
a97 7
		case 'c':
			cflag = 1;
			cpuid = strtonum(optarg, 0, 1024, &p);
			if (p)
				errx(1, "illegal CPU id %s: %s", optarg, p);
			break;

d111 3
a113 2
			fprintf(stderr, "usage: %s [-bhpr] "
			    "[-c cpuid] [-M core] [-N system]\n", __progname);
d130 2
a131 19

	if (cflag) {
		kgmon(sys, kmemf, &kvmvars, cpuid);
	} else {
		ncpu = getncpu();
		for (cpuid = 0; cpuid < ncpu; cpuid++)
			kgmon(sys, kmemf, &kvmvars, cpuid);
	}

	return (0);
}

void
kgmon(char *sys, char *kmemf, struct kvmvars *kvp, int cpuid)
{
	int mode, disp, accessmode;

	accessmode = openfiles(sys, kmemf, kvp, cpuid);
	mode = getprof(kvp, cpuid);
d139 1
a139 1
		dumpstate(kvp, cpuid);
d141 1
a141 1
		reset(kvp, cpuid);
d143 4
a146 3
		setprof(kvp, cpuid, disp);
	printf("%s: kernel profiling is %s for cpu %d.\n", __progname,
	    disp == GMON_PROF_OFF ? "off" : "running", cpuid);
d153 1
a153 1
openfiles(char *sys, char *kmemf, struct kvmvars *kvp, int cpuid)
d155 1
a155 1
	int mib[4], state, openmode;
a162 1
		mib[3] = cpuid;
d164 1
a164 1
		if (sysctl(mib, 4, &state, &size, NULL, 0) < 0)
d170 1
a170 1
		if (sysctl(mib, 4, NULL, NULL, &state, size) >= 0)
d219 1
a219 1
getprof(struct kvmvars *kvp, int cpuid)
d221 1
a221 1
	int mib[4];
a230 1
		mib[3] = cpuid;
d232 1
a232 1
		if (sysctl(mib, 4, &kvp->gpm, &size, NULL, 0) < 0)
d245 1
a245 1
setprof(struct kvmvars *kvp, int cpuid, int state)
d248 1
a248 1
	int mib[4], oldstate;
d256 1
a256 2
		mib[3] = cpuid;
		if (sysctl(mib, 4, &oldstate, &sz, NULL, 0) < 0)
d261 1
a261 1
		if (sysctl(mib, 4, NULL, NULL, &state, sz) >= 0) {
d278 1
a278 1
dumpstate(struct kvmvars *kvp, int cpuid)
d285 1
a285 1
	int mib[4];
a288 1
	char buf[16];
d290 2
a291 4
	snprintf(buf, sizeof(buf), "gmon-%02d.out", cpuid);

	setprof(kvp, cpuid, GMON_PROF_OFF);
	fp = fopen(buf, "w");
d293 1
a293 1
		perror(buf);
a319 1
		mib[3] = cpuid;
d321 1
a321 1
		if (sysctl(mib, 4, tickbuf, &i, NULL, 0) < 0)
a341 1
		mib[3] = cpuid;
d343 1
a343 1
		if (sysctl(mib, 4, froms, &i, NULL, 0) < 0)
a356 1
		mib[3] = cpuid;
d358 1
a358 1
		if (sysctl(mib, 4, tos, &i, NULL, 0) < 0)
d418 1
a418 1
reset(struct kvmvars *kvp, int cpuid)
d422 1
a422 1
	int mib[4];
d424 1
a424 1
	setprof(kvp, cpuid, GMON_PROF_OFF);
d450 1
a450 2
	mib[3] = cpuid;
	if (sysctl(mib, 4, NULL, NULL, zbuf, kvp->gpm.kcountsize) < 0)
d453 1
a453 1
	if (sysctl(mib, 4, NULL, NULL, zbuf, kvp->gpm.fromssize) < 0)
d456 1
a456 1
	if (sysctl(mib, 4, NULL, NULL, zbuf, kvp->gpm.tossize) < 0)
a459 16
}

int
getncpu(void)
{
	int mib[2] = { CTL_HW, HW_NCPU };
	size_t size;
	int ncpu;

	size = sizeof(ncpu);
	if (sysctl(mib, 2, &ncpu, &size, NULL, 0) < 0) {
		warnx("cannot read hw.ncpu");
		return (1);
	}

	return (ncpu);
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.14 2007/11/26 09:28:34 martynas Exp $	*/
d61 3
a63 1
int	bflag, hflag, kflag, rflag, pflag;
d65 4
a68 3
void	setprof(struct kvmvars *, int);
void	dumpstate(struct kvmvars *);
void	reset(struct kvmvars *);
d70 1
a70 1
int	getprof(struct kvmvars *);
d72 2
a73 1
int	openfiles(char *, char *, struct kvmvars *);
d78 1
a78 2
	extern char *__progname;
	int ch, mode, disp, accessmode;
d81 1
d86 1
a86 1
	while ((ch = getopt(argc, argv, "M:N:bhpr")) != -1) {
d102 7
d122 2
a123 3
			fprintf(stderr,
			    "usage: %s [-bhpr] [-M core] [-N system]\n",
			    __progname);
d140 19
a158 2
	accessmode = openfiles(sys, kmemf, &kvmvars);
	mode = getprof(&kvmvars);
d166 1
a166 1
		dumpstate(&kvmvars);
d168 1
a168 1
		reset(&kvmvars);
d170 3
a172 4
		setprof(&kvmvars, disp);
	printf("%s: kernel profiling is %s.\n", __progname,
	    disp == GMON_PROF_OFF ? "off" : "running");
	return (0);
d179 1
a179 1
openfiles(char *sys, char *kmemf, struct kvmvars *kvp)
d181 1
a181 1
	int mib[3], state, openmode;
d189 1
d191 1
a191 1
		if (sysctl(mib, 3, &state, &size, NULL, 0) < 0)
d197 1
a197 1
		if (sysctl(mib, 3, NULL, NULL, &state, size) >= 0)
d246 1
a246 1
getprof(struct kvmvars *kvp)
d248 1
a248 1
	int mib[3];
d258 1
d260 1
a260 1
		if (sysctl(mib, 3, &kvp->gpm, &size, NULL, 0) < 0)
d273 1
a273 1
setprof(struct kvmvars *kvp, int state)
d276 1
a276 1
	int mib[3], oldstate;
d284 2
a285 1
		if (sysctl(mib, 3, &oldstate, &sz, NULL, 0) < 0)
d290 1
a290 1
		if (sysctl(mib, 3, NULL, NULL, &state, sz) >= 0) {
d307 1
a307 1
dumpstate(struct kvmvars *kvp)
d314 1
a314 1
	int mib[3];
d318 1
d320 4
a323 2
	setprof(kvp, GMON_PROF_OFF);
	fp = fopen("gmon.out", "w");
d325 1
a325 1
		perror("gmon.out");
d352 1
d354 1
a354 1
		if (sysctl(mib, 3, tickbuf, &i, NULL, 0) < 0)
d375 1
d377 1
a377 1
		if (sysctl(mib, 3, froms, &i, NULL, 0) < 0)
d391 1
d393 1
a393 1
		if (sysctl(mib, 3, tos, &i, NULL, 0) < 0)
d453 1
a453 1
reset(struct kvmvars *kvp)
d457 1
a457 1
	int mib[3];
d459 1
a459 1
	setprof(kvp, GMON_PROF_OFF);
d485 2
a486 1
	if (sysctl(mib, 3, NULL, NULL, zbuf, kvp->gpm.kcountsize) < 0)
d489 1
a489 1
	if (sysctl(mib, 3, NULL, NULL, zbuf, kvp->gpm.fromssize) < 0)
d492 1
a492 1
	if (sysctl(mib, 3, NULL, NULL, zbuf, kvp->gpm.tossize) < 0)
d496 16
@


1.14
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.13 2007/05/04 04:06:06 ray Exp $	*/
a30 11

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1983, 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)kgmon.c	8.1 (Berkeley) 6/6/93";*/
static char *rcsid = "$OpenBSD: kgmon.c,v 1.13 2007/05/04 04:06:06 ray Exp $";
#endif /* not lint */
@


1.13
log
@From dhill@@ last year:
- rename system to sys to stop shadowing the system() call.
- remove variable names in function declarations
- remove extern optarg and optind since it's defined in unistd.h
- use %zu instead of %d to print size_t's

OK jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.12 2007/02/18 20:51:46 jmc Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.12 2007/02/18 20:51:46 jmc Exp $";
d218 1
a218 1
		(void)fprintf(stderr, "-r supressed\n");
d220 1
a220 1
		(void)fprintf(stderr, "-b supressed\n");
d222 1
a222 1
		(void)fprintf(stderr, "-h supressed\n");
@


1.12
log
@order options and usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.11 2004/08/01 18:32:19 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.11 2004/08/01 18:32:19 deraadt Exp $";
d74 3
a76 3
void	setprof(struct kvmvars *kvp, int state);
void	dumpstate(struct kvmvars *kvp);
void	reset(struct kvmvars *kvp);
d78 3
a80 3
int	getprof(struct kvmvars *kvp);
int	getprofhz(struct kvmvars *kvp);
int	openfiles(char *system, char *kmemf, struct kvmvars *kvp);
a85 2
	extern char *optarg;
	extern int optind;
d88 1
a88 1
	char *system, *kmemf;
d92 1
a92 1
	system = NULL;
d102 1
a102 1
			system = optarg;
d134 1
a134 1
		system = *argv;
d141 1
a141 1
	accessmode = openfiles(system, kmemf, &kvmvars);
d164 1
a164 1
openfiles(char *system, char *kmemf, struct kvmvars *kvp)
d188 1
a188 1
	kvp->kd = kvm_openfiles(system, kmemf, NULL, openmode, errbuf);
d192 1
a192 1
			kvp->kd = kvm_openfiles(system, kmemf, NULL, O_RDONLY,
d200 1
a200 1
		errx(3, "%s: no namelist", system ? system : _PATH_UNIX);
d336 1
a336 1
		errx(6, "read ticks: read %lu, got %d: %s",
d358 1
a358 1
		errx(9, "read froms: read %lu, got %d: %s",
d373 1
a373 1
		errx(11, "read tos: read %lu, got %d: %s",
@


1.11
log
@ansi cleanup; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.10 2003/06/02 23:36:53 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.10 2003/06/02 23:36:53 millert Exp $";
d125 1
a125 1
			    "usage: %s [-bhrp] [-M core] [-N system]\n",
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.9 2002/03/14 16:44:25 mpech Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.9 2002/03/14 16:44:25 mpech Exp $";
d166 1
a166 4
openfiles(system, kmemf, kvp)
	char *system;
	char *kmemf;
	struct kvmvars *kvp;
d212 1
a212 2
kern_readonly(mode)
	int mode;
d232 1
a232 2
getprof(kvp)
	struct kvmvars *kvp;
d258 1
a258 3
setprof(kvp, state)
	struct kvmvars *kvp;
	int state;
d291 1
a291 2
dumpstate(kvp)
	struct kvmvars *kvp;
d405 1
a405 2
getprofhz(kvp)
	struct kvmvars *kvp;
d431 1
a431 2
reset(kvp)
	struct kvmvars *kvp;
@


1.9
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.8 2002/03/14 06:51:42 mpech Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.8 2002/03/14 06:51:42 mpech Exp $";
@


1.8
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.7 2002/02/16 21:28:03 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.7 2002/02/16 21:28:03 millert Exp $";
d305 1
a305 1
	register FILE *fp;
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.6 2001/09/17 13:42:35 art Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.6 2001/09/17 13:42:35 art Exp $";
d402 1
a402 1
			  warnx("[mcleanup] frompc 0x%lx selfpc 0x%lx count %ld\n",
d467 1
a467 1
			errx(14, "froms zero: %s\n", kvm_geterr(kvp->kd));
@


1.6
log
@I'm sure that it's not supposed to say:
'off: kernel profiling is kgmon.'
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.5 2001/05/05 07:32:39 mickey Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.5 2001/05/05 07:32:39 mickey Exp $";
d78 7
a84 7
void	setprof __P((struct kvmvars *kvp, int state));
void	dumpstate __P((struct kvmvars *kvp));
void	reset __P((struct kvmvars *kvp));
void	kern_readonly __P((int));
int	getprof __P((struct kvmvars *kvp));
int	getprofhz __P((struct kvmvars *kvp));
int	openfiles __P((char *system, char *kmemf, struct kvmvars *kvp));
@


1.5
log
@use err/warn, -Wall, trailing spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.4 1998/12/20 23:59:18 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.4 1998/12/20 23:59:18 millert Exp $";
d161 2
a162 2
	printf("%s: kernel profiling is %s.\n",
	    disp == GMON_PROF_OFF ? "off" : "running", __progname);
@


1.4
log
@Don't assume /bsd if no system given, let the kvm routines pick a default (and thus use kvm_bsd.db if possible).  Also minor manpage fixup.
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.3 1997/01/15 23:44:02 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.3 1997/01/15 23:44:02 millert Exp $";
d52 1
d57 1
d68 1
a68 1
	0,
d81 4
d89 1
d128 3
a130 2
			(void)fprintf(stderr,
			    "usage: kgmon [-bhrp] [-M core] [-N system]\n");
d161 2
a162 2
	(void)fprintf(stdout, "kgmon: kernel profiling is %s.\n",
		      disp == GMON_PROF_OFF ? "off" : "running");
d169 1
d184 2
a185 5
		if (sysctl(mib, 3, &state, &size, NULL, 0) < 0) {
			(void)fprintf(stderr,
			    "kgmon: profiling not defined in kernel.\n");
			exit(20);
		}
d204 2
a205 5
		if (kvp->kd == NULL) {
			(void)fprintf(stderr, "kgmon: kvm_openfiles: %s\n",
			    errbuf);
			exit(2);
		}
d208 4
a211 10
	if (kvm_nlist(kvp->kd, nl) < 0) {
		(void)fprintf(stderr, "kgmon: %s: no namelist\n",
		    system ? system : _PATH_UNIX);
		exit(3);
	}
	if (!nl[N_GMONPARAM].n_value) {
		(void)fprintf(stderr,
		    "kgmon: profiling not defined in kernel.\n");
		exit(20);
	}
d218 1
d222 1
d224 1
a224 1
	(void)fprintf(stderr, "kgmon: kernel read-only: ");
d239 1
d257 2
a258 2
	if (size != sizeof kvp->gpm) {
		(void)fprintf(stderr, "kgmon: cannot get gmonparam: %s\n",
a259 2
		exit (4);
	}
d290 1
a290 1
	} else if (kvm_write(kvp->kd, (u_long)&p->state, (void *)&state, sz) 
d294 1
a294 1
	(void)fprintf(stderr, "kgmon: warning: cannot turn profiling %s\n",
d308 1
a308 1
	u_long frompc, addr;
d338 2
a339 4
	if ((tickbuf = (u_short *)malloc(kvp->gpm.kcountsize)) == NULL) {
		fprintf(stderr, "kgmon: cannot allocate kcount space\n");
		exit (5);
	}
d349 2
a350 2
	if (i != kvp->gpm.kcountsize) {
		(void)fprintf(stderr, "kgmon: read ticks: read %u, got %d: %s",
d353 2
a354 6
		exit(6);
	}
	if ((fwrite(tickbuf, kvp->gpm.kcountsize, 1, fp)) != 1) {
		perror("kgmon: writing tocks to gmon.out");
		exit(7);
	}
d360 2
a361 4
	if ((froms = (u_short *)malloc(kvp->gpm.fromssize)) == NULL) {
		fprintf(stderr, "kgmon: cannot allocate froms space\n");
		exit (8);
	}
d371 2
a372 2
	if (i != kvp->gpm.fromssize) {
		(void)fprintf(stderr, "kgmon: read froms: read %u, got %d: %s",
d375 2
a376 6
		exit(9);
	}
	if ((tos = (struct tostruct *)malloc(kvp->gpm.tossize)) == NULL) {
		fprintf(stderr, "kgmon: cannot allocate tos space\n");
		exit(10);
	}
d386 2
a387 2
	if (i != kvp->gpm.tossize) {
		(void)fprintf(stderr, "kgmon: read tos: read %u, got %d: %s",
a389 2
		exit(11);
	}
d391 2
a392 2
		(void)fprintf(stderr, "kgmon: lowpc 0x%x, textsize 0x%x\n",
			      kvp->gpm.lowpc, kvp->gpm.textsize);
d402 2
a403 4
			    (void)fprintf(stderr,
			    "%s: [mcleanup] frompc 0x%x selfpc 0x%x count %d\n",
			    "kgmon", frompc, tos[toindex].selfpc,
			    tos[toindex].count);
d428 1
a428 2
			(void)fprintf(stderr, "kgmon: get clockrate: %s\n",
				kvm_geterr(kvp->kd));
d436 1
a436 2
		(void)fprintf(stderr, "kgmon: get clockrate: %s\n",
			strerror(errno));
d458 2
a459 4
	if ((zbuf = (char *)malloc(biggest)) == NULL) {
		fprintf(stderr, "kgmon: cannot allocate zbuf space\n");
		exit(12);
	}
d463 2
a464 5
		    kvp->gpm.kcountsize) != kvp->gpm.kcountsize) {
			(void)fprintf(stderr, "kgmon: tickbuf zero: %s\n",
			    kvm_geterr(kvp->kd));
			exit(13);
		}
d466 2
a467 5
		    kvp->gpm.fromssize) != kvp->gpm.fromssize) {
			(void)fprintf(stderr, "kgmon: froms zero: %s\n",
			    kvm_geterr(kvp->kd));
			exit(14);
		}
d469 2
a470 5
		    kvp->gpm.tossize) != kvp->gpm.tossize) {
			(void)fprintf(stderr, "kgmon: tos zero: %s\n",
			    kvm_geterr(kvp->kd));
			exit(15);
		}
d477 2
a478 5
	if (sysctl(mib, 3, NULL, NULL, zbuf, kvp->gpm.kcountsize) < 0) {
		(void)fprintf(stderr, "kgmon: tickbuf zero: %s\n",
		    strerror(errno));
		exit(13);
	}
d480 2
a481 5
	if (sysctl(mib, 3, NULL, NULL, zbuf, kvp->gpm.fromssize) < 0) {
		(void)fprintf(stderr, "kgmon: froms zero: %s\n",
		    strerror(errno));
		exit(14);
	}
d483 2
a484 5
	if (sysctl(mib, 3, NULL, NULL, zbuf, kvp->gpm.tossize) < 0) {
		(void)fprintf(stderr, "kgmon: tos zero: %s\n",
		    strerror(errno));
		exit(15);
	}
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: kgmon.c,v 1.2 1996/05/01 22:15:24 niklas Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: kgmon.c,v 1.2 1996/05/01 22:15:24 niklas Exp $";
a138 2
	if (system == NULL)
		system = _PATH_UNIX;
d206 2
a207 1
		(void)fprintf(stderr, "kgmon: %s: no namelist\n", system);
@


1.2
log
@Our kernel is named /bsd, and we use $OpenBSD$ RCS IDs
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD$";
d92 1
a92 1
	while ((ch = getopt(argc, argv, "M:N:bhpr")) != EOF) {
@


1.1
log
@Initial revision
@
text
@d1 2
d44 1
a44 1
static char *rcsid = "$Id: kgmon.c,v 1.6 1994/12/23 16:45:33 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
