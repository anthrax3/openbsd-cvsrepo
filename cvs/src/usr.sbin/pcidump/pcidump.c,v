head	1.43;
access;
symbols
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.4
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.2
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.6
	OPENBSD_5_0:1.29.0.4
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12;
locks; strict;
comment	@ * @;


1.43
date	2017.03.25.07.33.46;	author mlarkin;	state Exp;
branches;
next	1.42;
commitid	uiM2dGM4qcsBpBwN;

1.42
date	2017.03.16.22.05.46;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	2tVi7fpPLbHkccrD;

1.41
date	2017.01.04.03.35.29;	author dlg;	state Exp;
branches;
next	1.40;
commitid	7ZXOzyM9U03gcISe;

1.40
date	2016.08.27.04.38.48;	author guenther;	state Exp;
branches;
next	1.39;
commitid	BMLcCzXodrhQXEsZ;

1.39
date	2015.12.01.19.10.09;	author kettenis;	state Exp;
branches;
next	1.38;
commitid	OvZaUz9mAlp00Ndk;

1.38
date	2015.11.21.17.52.10;	author kettenis;	state Exp;
branches;
next	1.37;
commitid	bCvVOyWgjXGYq3HV;

1.37
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2014.05.20.01.25.24;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2013.11.12.19.48.53;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2013.08.30.06.46.39;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2013.06.15.19.45.03;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2012.07.03.13.09.25;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2012.05.16.13.01.50;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2012.05.16.12.58.39;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.13.14.29.26;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.13.14.17.21;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.12.20.17.56;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.19.23.23.21;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.19.23.06.10;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2010.09.05.18.14.33;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.02.10.17.10;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2010.03.01.19.00.47;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.06.23.59.14;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.05.20.32.49;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.07.21.48.16;	author sobrado;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.07.09.50.52;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.05.19.19.02;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.07.09.23.32;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.23.15.39.52;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.07.12.12.48;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2008.03.15.14.46.13;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.02.17.59.10;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.20.13.56.36;	author chl;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.18.00.33.45;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.17.18.32.21;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.25.10.27.21;	author tobias;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.23.06.57.28;	author chl;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.22.20.54.52;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.22.09.26.16;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.22.01.22.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.22.01.21.30;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.22.01.13.27;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.22.01.12.28;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.43
log
@More PCI extended capabilities handling in pcidump.

From  Simon Mages

ok deraadt@@
@
text
@/*	$OpenBSD: pcidump.c,v 1.42 2017/03/16 22:05:46 deraadt Exp $	*/

/*
 * Copyright (c) 2006, 2007 David Gwynne <loki@@animata.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/pciio.h>

#include <stdio.h>	/* need NULL for <dev/pci/*.h> */

#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/pcidevs_data.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#define PCIDEV	"/dev/pci"

#ifndef nitems
#define nitems(_a)	(sizeof((_a)) / sizeof((_a)[0]))
#endif

__dead void usage(void);
void scanpcidomain(void);
int probe(int, int, int);
void dump(int, int, int);
void hexdump(int, int, int, int);
const char *str2busdevfunc(const char *, int *, int *, int *);
int pci_nfuncs(int, int);
int pci_read(int, int, int, u_int32_t, u_int32_t *);
int pci_readmask(int, int, int, u_int32_t, u_int32_t *);
void dump_caplist(int, int, int, u_int8_t);
void dump_pci_powerstate(int, int, int, uint8_t);
void dump_pcie_linkspeed(int, int, int, uint8_t);
void print_pcie_ls(uint8_t);
int dump_rom(int, int, int);
int dump_vga_bios(void);

void	dump_type0(int bus, int dev, int func);
void	dump_type1(int bus, int dev, int func);
void	dump_type2(int bus, int dev, int func);

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-v] [-x | -xx | -xxx] [-d pcidev] [bus:dev:func]\n"
	    "       %s -r file [-d pcidev] bus:dev:func\n",
	    __progname, __progname);
	exit(1);
}

int pcifd;
int romfd;
int verbose = 0;
int hex = 0;
int size = 64;

const char *pci_capnames[] = {
	"Reserved",
	"Power Management",
	"AGP",
	"Vital Product Data (VPD)",
	"Slot Identification",
	"Message Signalled Interrupts (MSI)",
	"CompactPCI Hot Swap",
	"PCI-X",
	"AMD LDT/HT",
	"Vendor Specific",
	"Debug Port",
	"CompactPCI Central Resource Control",
	"PCI Hot-Plug",
	"PCI-PCI",
	"AGP8",
	"Secure",
	"PCI Express",
	"Extended Message Signalled Interrupts (MSI-X)",
	"SATA",
	"PCI Advanced Features"
};

const char *pci_enhanced_capnames[] = {
	"Unknown",
	"Advanced Error Reporting",
	"Virtual Channel Capability",
	"Device Serial Number",
	"Power Budgeting",
	"Root Complex Link Declaration",
	"Root Complex Internal Link Control",
	"Root Complex Event Collector",
	"Multi-Function VC Capability",
	"Virtual Channel Capability",
	"Root Complex/Root Bridge",
	"Vendor-Specific",
	"Config Access",
	"Access Control Services",
	"Alternate Routing ID",
	"Address Translation Services",
	"Single Root I/O Virtualization",
	"Multi Root I/O Virtualization",
	"Multicast",
	"Page Request Interface",
	"Reserved for AMD",
	"Resizable BAR",
	"Dynamic Power Allocation",
	"TPH Requester",
	"Latency Tolerance Reporting",
	"Secondary PCIe Capability",
	"Protocol Multiplexing",
	"Process Address Space ID",
	"Downstream Port Containment",
	"Precision Time Measurement",
};

int
main(int argc, char *argv[])
{
	int nfuncs;
	int bus, dev, func;
	char pcidev[PATH_MAX] = PCIDEV;
	char *romfile = NULL;
	const char *errstr;
	int c, error = 0, dumpall = 1, domid = 0;

	while ((c = getopt(argc, argv, "d:r:vx")) != -1) {
		switch (c) {
		case 'd':
			strlcpy(pcidev, optarg, sizeof(pcidev));
			dumpall = 0;
			break;
		case 'r':
			romfile = optarg;
			dumpall = 0;
			break;
		case 'v':
			verbose = 1;
			break;
		case 'x':
			hex++;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc > 1 || (romfile && argc != 1))
		usage();

	if (romfile) {
		romfd = open(romfile, O_WRONLY|O_CREAT|O_TRUNC, 0777);
		if (romfd == -1)
			err(1, "%s", romfile);
	}

	if (hex > 1)
		size = 256;
	if (hex > 2)
		size = 4096;

	if (argc == 1)
		dumpall = 0;

	if (dumpall == 0) {
		pcifd = open(pcidev, O_RDONLY, 0777);
		if (pcifd == -1)
			err(1, "%s", pcidev);
	} else {
		for (;;) {
			snprintf(pcidev, 16, "/dev/pci%d", domid++);
			pcifd = open(pcidev, O_RDONLY, 0777);
			if (pcifd == -1) {
				if (errno == ENXIO || errno == ENOENT) {
					return 0;
				} else {
					err(1, "%s", pcidev);
				}
			}
			printf("Domain %s:\n", pcidev);
			scanpcidomain();
			close(pcifd);
		}
	}

	if (argc == 1) {
		errstr = str2busdevfunc(argv[0], &bus, &dev, &func);
		if (errstr != NULL)
			errx(1, "\"%s\": %s", argv[0], errstr);

		nfuncs = pci_nfuncs(bus, dev);
		if (nfuncs == -1 || func > nfuncs)
			error = ENXIO;
		else if (romfile)
			error = dump_rom(bus, dev, func);
		else
			error = probe(bus, dev, func);

		if (error != 0)
			errc(1, error, "\"%s\"", argv[0]);
	} else {
		printf("Domain %s:\n", pcidev);
		scanpcidomain();
	}

	return (0);
}

void
scanpcidomain(void)
{
	int nfuncs;
	int bus, dev, func;

	for (bus = 0; bus < 256; bus++) {
		for (dev = 0; dev < 32; dev++) {
			nfuncs = pci_nfuncs(bus, dev);
			for (func = 0; func < nfuncs; func++) {
				probe(bus, dev, func);
			}
		}
	}
}

const char *
str2busdevfunc(const char *string, int *bus, int *dev, int *func)
{
	const char *errstr;
	char b[80], *d, *f;

	strlcpy(b, string, sizeof(b));

	d = strchr(b, ':');
	if (d == NULL)
		return("device not specified");
	*d++ = '\0';

	f = strchr(d, ':');
	if (f == NULL)
		return("function not specified");
	*f++ = '\0';

	*bus = strtonum(b, 0, 255, &errstr);
	if (errstr != NULL)
		return (errstr);
	*dev = strtonum(d, 0, 31, &errstr);
	if (errstr != NULL)
		return (errstr);
	*func = strtonum(f, 0, 7, &errstr);
	if (errstr != NULL)
		return (errstr);

	return (NULL);
}

int
probe(int bus, int dev, int func)
{
	u_int32_t id_reg;
	const struct pci_known_vendor *pkv;
	const struct pci_known_product *pkp;
	const char *vendor = NULL, *product = NULL;

	if (pci_read(bus, dev, func, PCI_ID_REG, &id_reg) != 0)
		return (errno);

	if (PCI_VENDOR(id_reg) == PCI_VENDOR_INVALID ||
	    PCI_VENDOR(id_reg) == 0)
		return (ENXIO);

	for (pkv = pci_known_vendors; pkv->vendorname != NULL; pkv++) {
		if (pkv->vendor == PCI_VENDOR(id_reg)) {
			vendor = pkv->vendorname;
			break;
		}
	}

	if (vendor != NULL) {
		for (pkp = pci_known_products; pkp->productname != NULL; pkp++)
		if (pkp->vendor == PCI_VENDOR(id_reg) &&
		    pkp->product == PCI_PRODUCT(id_reg)) {
			product = pkp->productname;
			break;
		}
	}

	printf(" %d:%d:%d: %s %s\n", bus, dev, func,
	    (vendor == NULL) ? "unknown" : vendor,
	    (product == NULL) ? "unknown" : product);

	if (verbose)
		dump(bus, dev, func);
	if (hex > 0)
		hexdump(bus, dev, func, size);

	return (0);
}

void
dump_pci_powerstate(int bus, int dev, int func, uint8_t ptr)
{
	u_int32_t pmcsr;

	if (pci_read(bus, dev, func, ptr + PCI_PMCSR, &pmcsr) != 0)
		return;

	printf("\t	State: D%d", pmcsr & PCI_PMCSR_STATE_MASK);
	if (pmcsr & PCI_PMCSR_PME_EN)
		printf(" PME# enabled");
	if (pmcsr & PCI_PMCSR_PME_STATUS)
		printf(" PME# asserted");
	printf("\n");
}

void
print_pcie_ls(uint8_t speed)
{
	if (speed & 4)
		printf("8.0");
	else if (speed & 2)
		printf("5.0");
	else if (speed & 1)
		printf("2.5");
	else
		printf("unknown (%d)", speed);
}

void
dump_pcie_linkspeed(int bus, int dev, int func, uint8_t ptr)
{
	u_int32_t lcap, sreg, lcap2 = 0, xcap;
	u_int8_t cwidth, cspeed, swidth, sspeed;

	if (pci_read(bus, dev, func, ptr + PCI_PCIE_XCAP, &xcap) != 0)
		return;

	if (PCI_PCIE_XCAP_VER(xcap) >= 2) {
		if (pci_read(bus, dev, func, ptr + PCI_PCIE_LCAP2, &lcap2) != 0)
			lcap2 = 0;
		else
			cspeed = (lcap2 & 0x0e) >> 1;
	}

	if (pci_read(bus, dev, func, ptr + PCI_PCIE_LCAP, &lcap) != 0)
		return;
	if (lcap2 == 0)
		cspeed = lcap & 0x0f;

	if (pci_read(bus, dev, func, ptr + PCI_PCIE_LCSR, &sreg) != 0)
		return;
	sreg = sreg >> 16;

	cwidth = (lcap >> 4) & 0x3f;
	if (cwidth == 0)
		return;

	swidth = (sreg >> 4) & 0x3f;
	sspeed = sreg & 0x0f;

	printf("\t        Link Speed: ");
	print_pcie_ls(sspeed);
	printf(" / ");
	print_pcie_ls(cspeed);

	printf(" GT/s Link Width: x%d / x%d\n", swidth, cwidth);
}

void
dump_pcie_enhanced_caplist(int bus, int dev, int func)
{
	u_int32_t reg;
	u_int32_t capidx;
	u_int16_t ptr;
	u_int16_t ecap;

	ptr = PCI_PCIE_ECAP;

	do {
		if (pci_read(bus, dev, func, ptr, &reg) != 0)
			return;

		if (PCI_PCIE_ECAP_ID(reg) == 0xffff &&
		    PCI_PCIE_ECAP_NEXT(reg) == PCI_PCIE_ECAP_LAST)
			return;

		ecap = PCI_PCIE_ECAP_ID(reg);
		if (ecap >= nitems(pci_enhanced_capnames))
			capidx = 0;
		else
			capidx = ecap;

		printf("\t0x%04x: Enhanced Capability 0x%02x: ", ptr, ecap);
		printf("%s\n", pci_enhanced_capnames[capidx]);

		ptr = PCI_PCIE_ECAP_NEXT(reg);

	} while (ptr != PCI_PCIE_ECAP_LAST);
}

void
dump_caplist(int bus, int dev, int func, u_int8_t ptr)
{
	u_int32_t reg;
	u_int8_t cap;

	if (pci_read(bus, dev, func, PCI_COMMAND_STATUS_REG, &reg) != 0)
		return;
	if (!(reg & PCI_STATUS_CAPLIST_SUPPORT))
		return;

	if (pci_read(bus, dev, func, ptr, &reg) != 0)
		return;
	ptr = PCI_CAPLIST_PTR(reg);
	while (ptr != 0) {
		if (pci_read(bus, dev, func, ptr, &reg) != 0)
			return;
		cap = PCI_CAPLIST_CAP(reg);
		printf("\t0x%04x: Capability 0x%02x: ", ptr, cap);
		if (cap >= nitems(pci_capnames))
			cap = 0;
		printf("%s\n", pci_capnames[cap]);
		if (cap == PCI_CAP_PWRMGMT)
			dump_pci_powerstate(bus, dev, func, ptr);
		if (cap == PCI_CAP_PCIEXPRESS) {
			dump_pcie_linkspeed(bus, dev, func, ptr);
			dump_pcie_enhanced_caplist(bus, dev, func);
		}
		ptr = PCI_CAPLIST_NEXT(reg);
	}
}

void
dump_type0(int bus, int dev, int func)
{
	const char *memtype;
	u_int64_t mem;
	u_int64_t mask;
	u_int32_t reg, reg1;
	int bar;

	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END; bar += 0x4) {
		if (pci_read(bus, dev, func, bar, &reg) != 0 ||
		    pci_readmask(bus, dev, func, bar, &reg1) != 0)
			warn("unable to read PCI_MAPREG 0x%02x", bar);

		printf("\t0x%04x: BAR ", bar);

		if (reg == 0 && reg1 == 0) {
			printf("empty (%08x)\n", reg);
			continue;
		}

		switch (PCI_MAPREG_TYPE(reg)) {
		case PCI_MAPREG_TYPE_MEM:
			printf("mem ");
			if (PCI_MAPREG_MEM_PREFETCHABLE(reg))
				printf("prefetchable ");

			memtype = "32bit 1m";
			switch (PCI_MAPREG_MEM_TYPE(reg)) {
			case PCI_MAPREG_MEM_TYPE_32BIT:
				memtype = "32bit";
			case PCI_MAPREG_MEM_TYPE_32BIT_1M:
				printf("%s ", memtype);

				printf("addr: 0x%08x/0x%08x\n",
				    PCI_MAPREG_MEM_ADDR(reg),
				    PCI_MAPREG_MEM_SIZE(reg1));

				break;
			case PCI_MAPREG_MEM_TYPE_64BIT:
				mem = reg;
				mask = reg1;
				bar += 0x04;
				if (pci_read(bus, dev, func, bar, &reg) != 0 ||
				    pci_readmask(bus, dev, func, bar, &reg1) != 0)
					warn("unable to read 0x%02x", bar);

				mem |= (u_int64_t)reg << 32;
				mask |= (u_int64_t)reg1 << 32;

				printf("64bit addr: 0x%016llx/0x%08llx\n",
				    PCI_MAPREG_MEM64_ADDR(mem),
				    PCI_MAPREG_MEM64_SIZE(mask));

				break;
			}
			break;

		case PCI_MAPREG_TYPE_IO:
			printf("io addr: 0x%08x/0x%04x\n",
			    PCI_MAPREG_IO_ADDR(reg),
			    PCI_MAPREG_IO_SIZE(reg1));
			break;
		}
	}

	if (pci_read(bus, dev, func, PCI_CARDBUS_CIS_REG, &reg) != 0)
		warn("unable to read PCI_CARDBUS_CIS_REG");
	printf("\t0x%04x: Cardbus CIS: %08x\n", PCI_CARDBUS_CIS_REG, reg);

	if (pci_read(bus, dev, func, PCI_SUBSYS_ID_REG, &reg) != 0)
		warn("unable to read PCI_SUBSYS_ID_REG");
	printf("\t0x%04x: Subsystem Vendor ID: %04x Product ID: %04x\n",
	    PCI_SUBSYS_ID_REG, PCI_VENDOR(reg), PCI_PRODUCT(reg));

	if (pci_read(bus, dev, func, PCI_ROM_REG, &reg) != 0)
		warn("unable to read PCI_ROM_REG");
	printf("\t0x%04x: Expansion ROM Base Address: %08x\n",
	    PCI_ROM_REG, reg);

	if (pci_read(bus, dev, func, 0x38, &reg) != 0)
		warn("unable to read 0x38 (reserved)");
	printf("\t0x%04x: %08x\n", 0x38, reg);

	if (pci_read(bus, dev, func, PCI_INTERRUPT_REG, &reg) != 0)
		warn("unable to read PCI_INTERRUPT_REG");
	printf("\t0x%04x: Interrupt Pin: %02x Line: %02x Min Gnt: %02x"
	    " Max Lat: %02x\n", PCI_INTERRUPT_REG, PCI_INTERRUPT_PIN(reg),
	    PCI_INTERRUPT_LINE(reg), PCI_MIN_GNT(reg), PCI_MAX_LAT(reg));
}

void
dump_type1(int bus, int dev, int func)
{
	u_int32_t reg;
	int bar;

	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_PPB_END; bar += 0x4) {
		if (pci_read(bus, dev, func, bar, &reg) != 0)
			warn("unable to read PCI_MAPREG 0x%02x", bar);
		printf("\t0x%04x: %08x\n", bar, reg);
	}

	if (pci_read(bus, dev, func, PCI_PRIBUS_1, &reg) != 0)
		warn("unable to read PCI_PRIBUS_1");
	printf("\t0x%04x: Primary Bus: %d Secondary Bus: %d "
	    "Subordinate Bus: %d \n\t        Secondary Latency Timer: %02x\n",
	    PCI_PRIBUS_1, (reg >> 0) & 0xff, (reg >> 8) & 0xff,
	    (reg >> 16) & 0xff, (reg >> 24) & 0xff);

	if (pci_read(bus, dev, func, PCI_IOBASEL_1, &reg) != 0)
		warn("unable to read PCI_IOBASEL_1");
	printf("\t0x%04x: I/O Base: %02x I/O Limit: %02x "
	    "Secondary Status: %04x\n", PCI_IOBASEL_1, (reg >> 0 ) & 0xff,
	    (reg >> 8) & 0xff, (reg >> 16) & 0xffff);

	if (pci_read(bus, dev, func, PCI_MEMBASE_1, &reg) != 0)
		warn("unable to read PCI_MEMBASE_1");
	printf("\t0x%04x: Memory Base: %04x Memory Limit: %04x\n",
	    PCI_MEMBASE_1, (reg >> 0) & 0xffff, (reg >> 16) & 0xffff);

	if (pci_read(bus, dev, func, PCI_PMBASEL_1, &reg) != 0)
		warn("unable to read PCI_PMBASEL_1");
	printf("\t0x%04x: Prefetch Memory Base: %04x "
	    "Prefetch Memory Limit: %04x\n", PCI_PMBASEL_1,
	    (reg >> 0) & 0xffff, (reg >> 16) & 0xffff);

#undef PCI_PMBASEH_1
#define PCI_PMBASEH_1	0x28
	if (pci_read(bus, dev, func, PCI_PMBASEH_1, &reg) != 0)
		warn("unable to read PCI_PMBASEH_1");
	printf("\t0x%04x: Prefetch Memory Base Upper 32 Bits: %08x\n",
	    PCI_PMBASEH_1, reg);

#undef PCI_PMLIMITH_1
#define PCI_PMLIMITH_1	0x2c
	if (pci_read(bus, dev, func, PCI_PMLIMITH_1, &reg) != 0)
		warn("unable to read PCI_PMLIMITH_1");
	printf("\t0x%04x: Prefetch Memory Limit Upper 32 Bits: %08x\n",
	    PCI_PMLIMITH_1, reg);

#undef PCI_IOBASEH_1
#define PCI_IOBASEH_1	0x30
	if (pci_read(bus, dev, func, PCI_IOBASEH_1, &reg) != 0)
		warn("unable to read PCI_IOBASEH_1");
	printf("\t0x%04x: I/O Base Upper 16 Bits: %04x "
	    "I/O Limit Upper 16 Bits: %04x\n", PCI_IOBASEH_1,
	    (reg >> 0) & 0xffff, (reg >> 16) & 0xffff);

#define PCI_PPB_ROM_REG		0x38
	if (pci_read(bus, dev, func, PCI_PPB_ROM_REG, &reg) != 0)
		warn("unable to read PCI_PPB_ROM_REG");
	printf("\t0x%04x: Expansion ROM Base Address: %08x\n",
	    PCI_PPB_ROM_REG, reg);

	if (pci_read(bus, dev, func, PCI_INTERRUPT_REG, &reg) != 0)
		warn("unable to read PCI_INTERRUPT_REG");
	printf("\t0x%04x: Interrupt Pin: %02x Line: %02x "
	    "Bridge Control: %04x\n",
	    PCI_INTERRUPT_REG, PCI_INTERRUPT_PIN(reg),
	    PCI_INTERRUPT_LINE(reg), reg >> 16);
}

void
dump_type2(int bus, int dev, int func)
{
	u_int32_t reg;

	if (pci_read(bus, dev, func, PCI_MAPREG_START, &reg) != 0)
		warn("unable to read PCI_MAPREG\n");
	printf("\t0x%04x: Cardbus Control Registers Base Address: %08x\n",
	    PCI_MAPREG_START, reg);

	if (pci_read(bus, dev, func, PCI_PRIBUS_2, &reg) != 0)
		warn("unable to read PCI_PRIBUS_2");
	printf("\t0x%04x: Primary Bus: %d Cardbus Bus: %d "
	    "Subordinate Bus: %d \n\t        Cardbus Latency Timer: %02x\n",
	    PCI_PRIBUS_2, (reg >> 0) & 0xff, (reg >> 8) & 0xff,
	    (reg >> 16) & 0xff, (reg >> 24) & 0xff);

	if (pci_read(bus, dev, func, PCI_MEMBASE0_2, &reg) != 0)
		warn("unable to read PCI_MEMBASE0_2\n");
	printf("\t0x%04x: Memory Base 0: %08x\n", PCI_MEMBASE0_2, reg);

	if (pci_read(bus, dev, func, PCI_MEMLIMIT0_2, &reg) != 0)
		warn("unable to read PCI_MEMLIMIT0_2\n");
	printf("\t0x%04x: Memory Limit 0: %08x\n", PCI_MEMLIMIT0_2, reg);

	if (pci_read(bus, dev, func, PCI_MEMBASE1_2, &reg) != 0)
		warn("unable to read PCI_MEMBASE1_2\n");
	printf("\t0x%04x: Memory Base 1: %08x\n", PCI_MEMBASE1_2, reg);

	if (pci_read(bus, dev, func, PCI_MEMLIMIT1_2, &reg) != 0)
		warn("unable to read PCI_MEMLIMIT1_2\n");
	printf("\t0x%04x: Memory Limit 1: %08x\n", PCI_MEMLIMIT1_2, reg);

	if (pci_read(bus, dev, func, PCI_IOBASE0_2, &reg) != 0)
		warn("unable to read PCI_IOBASE0_2\n");
	printf("\t0x%04x: I/O Base 0: %08x\n", PCI_IOBASE0_2, reg);

	if (pci_read(bus, dev, func, PCI_IOLIMIT0_2, &reg) != 0)
		warn("unable to read PCI_IOLIMIT0_2\n");
	printf("\t0x%04x: I/O Limit 0: %08x\n", PCI_IOLIMIT0_2, reg);

	if (pci_read(bus, dev, func, PCI_IOBASE1_2, &reg) != 0)
		warn("unable to read PCI_IOBASE1_2\n");
	printf("\t0x%04x: I/O Base 1: %08x\n", PCI_IOBASE1_2, reg);

	if (pci_read(bus, dev, func, PCI_IOLIMIT1_2, &reg) != 0)
		warn("unable to read PCI_IOLIMIT1_2\n");
	printf("\t0x%04x: I/O Limit 1: %08x\n", PCI_IOLIMIT1_2, reg);

	if (pci_read(bus, dev, func, PCI_INTERRUPT_REG, &reg) != 0)
		warn("unable to read PCI_INTERRUPT_REG");
	printf("\t0x%04x: Interrupt Pin: %02x Line: %02x "
	    "Bridge Control: %04x\n",
	    PCI_INTERRUPT_REG, PCI_INTERRUPT_PIN(reg),
	    PCI_INTERRUPT_LINE(reg), reg >> 16);

	if (pci_read(bus, dev, func, PCI_SUBVEND_2, &reg) != 0)
		warn("unable to read PCI_SUBVEND_2");
	printf("\t0x%04x: Subsystem Vendor ID: %04x Product ID: %04x\n",
	    PCI_SUBVEND_2, PCI_VENDOR(reg), PCI_PRODUCT(reg));

	if (pci_read(bus, dev, func, PCI_PCCARDIF_2, &reg) != 0)
		warn("unable to read PCI_PCCARDIF_2\n");
	printf("\t0x%04x: 16-bit Legacy Mode Base Address: %08x\n",
	    PCI_PCCARDIF_2, reg);
}

void
dump(int bus, int dev, int func)
{
	u_int32_t reg;
	u_int8_t capptr = PCI_CAPLISTPTR_REG;

	if (pci_read(bus, dev, func, PCI_ID_REG, &reg) != 0)
		warn("unable to read PCI_ID_REG");
	printf("\t0x%04x: Vendor ID: %04x Product ID: %04x\n", PCI_ID_REG,
	    PCI_VENDOR(reg), PCI_PRODUCT(reg));

	if (pci_read(bus, dev, func, PCI_COMMAND_STATUS_REG, &reg) != 0)
		warn("unable to read PCI_COMMAND_STATUS_REG");
	printf("\t0x%04x: Command: %04x Status: %04x\n",
	    PCI_COMMAND_STATUS_REG, reg & 0xffff, (reg  >> 16) & 0xffff);

	if (pci_read(bus, dev, func, PCI_CLASS_REG, &reg) != 0)
		warn("unable to read PCI_CLASS_REG");
	printf("\t0x%04x: Class: %02x Subclass: %02x Interface: %02x "
	    "Revision: %02x\n", PCI_CLASS_REG, PCI_CLASS(reg),
	    PCI_SUBCLASS(reg), PCI_INTERFACE(reg), PCI_REVISION(reg));

	if (pci_read(bus, dev, func, PCI_BHLC_REG, &reg) != 0)
		warn("unable to read PCI_BHLC_REG");
	printf("\t0x%04x: BIST: %02x Header Type: %02x Latency Timer: %02x "
	    "Cache Line Size: %02x\n", PCI_BHLC_REG, PCI_BIST(reg),
	    PCI_HDRTYPE(reg), PCI_LATTIMER(reg), PCI_CACHELINE(reg));

	switch (PCI_HDRTYPE_TYPE(reg)) {
	case 2:
		dump_type2(bus, dev, func);
		capptr = PCI_CARDBUS_CAPLISTPTR_REG;
		break;
	case 1:
		dump_type1(bus, dev, func);
		break;
	case 0:
		dump_type0(bus, dev, func);
		break;
	default:
		break;
	}
	dump_caplist(bus, dev, func, capptr);
}

void
hexdump(int bus, int dev, int func, int size)
{
	u_int32_t reg;
	int i;

	for (i = 0; i < size; i += 4) {
		if (pci_read(bus, dev, func, i, &reg) != 0) {
			if (errno == EINVAL)
				return;
			warn("unable to read 0x%02x", i);
		}

		if ((i % 16) == 0)
			printf("\t0x%04x:", i);
		printf(" %08x", reg);

		if ((i % 16) == 12)
			printf("\n");
	}
}

int
pci_nfuncs(int bus, int dev)
{
	u_int32_t hdr;

	if (pci_read(bus, dev, 0, PCI_BHLC_REG, &hdr) != 0)
		return (-1);

	return (PCI_HDRTYPE_MULTIFN(hdr) ? 8 : 1);
}

int
pci_read(int bus, int dev, int func, u_int32_t reg, u_int32_t *val)
{
	struct pci_io io;
	int rv;

	bzero(&io, sizeof(io));
	io.pi_sel.pc_bus = bus;
	io.pi_sel.pc_dev = dev;
	io.pi_sel.pc_func = func;
	io.pi_reg = reg;
	io.pi_width = 4;

	rv = ioctl(pcifd, PCIOCREAD, &io);
	if (rv != 0)
		return (rv);

	*val = io.pi_data;

	return (0);
}

int
pci_readmask(int bus, int dev, int func, u_int32_t reg, u_int32_t *val)
{
	struct pci_io io;
	int rv;

	bzero(&io, sizeof(io));
	io.pi_sel.pc_bus = bus;
	io.pi_sel.pc_dev = dev;
	io.pi_sel.pc_func = func;
	io.pi_reg = reg;
	io.pi_width = 4;

	rv = ioctl(pcifd, PCIOCREADMASK, &io);
	if (rv != 0)
		return (rv);

	*val = io.pi_data;

	return (0);
}

int
dump_rom(int bus, int dev, int func)
{
	struct pci_rom rom;
	u_int32_t cr, addr;

	if (pci_read(bus, dev, func, PCI_ROM_REG, &addr) != 0 ||
	    pci_read(bus, dev, func, PCI_CLASS_REG, &cr) != 0)
		return (errno);

	if (addr == 0 && PCI_CLASS(cr) == PCI_CLASS_DISPLAY &&
	    PCI_SUBCLASS(cr) == PCI_SUBCLASS_DISPLAY_VGA)
		return dump_vga_bios();

	bzero(&rom, sizeof(rom));
	rom.pr_sel.pc_bus = bus;
	rom.pr_sel.pc_dev = dev;
	rom.pr_sel.pc_func = func;
	if (ioctl(pcifd, PCIOCGETROMLEN, &rom))
		return (errno);

	rom.pr_rom = malloc(rom.pr_romlen);
	if (rom.pr_rom == NULL)
		return (ENOMEM);

	if (ioctl(pcifd, PCIOCGETROM, &rom))
		return (errno);

	if (write(romfd, rom.pr_rom, rom.pr_romlen) == -1)
		return (errno);

	return (0);
}

#define VGA_BIOS_ADDR	0xc0000
#define VGA_BIOS_LEN	0x10000

int
dump_vga_bios(void)
{
#if defined(__amd64__) || defined(__i386__)
	void *bios;
	int fd;

	fd = open(_PATH_MEM, O_RDONLY, 0777);
	if (fd == -1)
		err(1, "%s", _PATH_MEM);

	bios = malloc(VGA_BIOS_LEN);
	if (bios == NULL)
		return (ENOMEM);

	if (pread(fd, bios, VGA_BIOS_LEN, VGA_BIOS_ADDR) == -1)
		err(1, "%s", _PATH_MEM);

	if (write(romfd, bios, VGA_BIOS_LEN) == -1) {
		free(bios);
		return (errno);
	}

	free(bios);

	return (0);
#else
	return (ENODEV);
#endif
}
@


1.42
log
@Print PCIe Extended Capabilities, from Simon Mages
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.41 2017/01/04 03:35:29 dlg Exp $	*/
d395 1
d411 3
a413 1
			ecap = 0;
d416 1
a416 1
		printf("%s\n", pci_enhanced_capnames[ecap]);
@


1.41
log
@s/Signaled/Signalled/
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.40 2016/08/27 04:38:48 guenther Exp $	*/
d105 33
d392 29
d444 1
a444 1
		if (cap == PCI_CAP_PCIEXPRESS)
d446 2
@


1.40
log
@Move up the <stdio.h> include so <dev/pci/*.h> have NULL

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.39 2015/12/01 19:10:09 kettenis Exp $	*/
d88 1
a88 1
	"Message Signaled Interrupts (MSI)",
d100 1
a100 1
	"Extended Message Signaled Interrupts (MSI-X)",
@


1.39
log
@Print PME# state together with the PCI power state when enabled/asserted.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.38 2015/11/21 17:52:10 kettenis Exp $	*/
d23 2
a32 1
#include <stdio.h>
@


1.38
log
@Print PCI power state when the -v option is given.

ok deraadt@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.37 2015/01/16 06:40:19 deraadt Exp $	*/
d296 6
a301 1
	printf("\t	State: D%d\n", pmcsr & PCI_PMCSR_STATE_MASK);
@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.36 2014/05/20 01:25:24 guenther Exp $	*/
d53 1
d289 11
d374 2
@


1.36
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.35 2013/11/12 19:48:53 deraadt Exp $	*/
d19 1
a20 1
#include <sys/param.h>
d35 1
d108 1
a108 1
	char pcidev[MAXPATHLEN] = PCIDEV;
@


1.35
log
@missing protos and an unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.34 2013/08/30 06:46:39 jsg Exp $	*/
d187 1
a187 1
			errx(1, "\"%s\": %s", argv[0], strerror(error));
@


1.34
log
@use version two of the PCIe capability when displaying link speeds
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.33 2013/06/15 19:45:03 kettenis Exp $	*/
d57 4
d303 1
a303 1
	u_int8_t cap, cwidth, cspeed, swidth, sspeed;
@


1.33
log
@Fix typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.32 2012/07/03 13:09:25 jsg Exp $	*/
d285 5
a289 2
	switch (speed) {
	case 1:
d291 1
a291 8
		break;
	case 2:
		printf("5.0");
		break;
	case 3:
		printf("8.0");
		break;
	default:
a292 1
	}
d298 1
a298 1
	u_int32_t creg, sreg;
d301 1
a301 1
	if (pci_read(bus, dev, func, ptr + PCI_PCIE_LCAP, &creg) != 0)
d304 12
d320 4
a323 1
	cwidth = (creg >> 4) & 0x3f;
a324 1
	cspeed = creg & 0x0f;
a325 3
	
	if (cwidth == 0)
		return;
@


1.32
log
@avoid what would be a leak if reused elsewhere but isn't in this
case as the memory is freed on exit.

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.31 2012/05/16 13:01:50 jsg Exp $	*/
d600 1
a600 1
	printf("\t0x%04x: Command: %04x Status ID: %04x\n",
@


1.31
log
@The PCIe link speed values are printed in GT/s not Gb/s.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.30 2012/05/16 12:58:39 jsg Exp $	*/
d764 2
a765 1
	if (write(romfd, bios, VGA_BIOS_LEN) == -1)
d767 3
@


1.30
log
@recognise 8.0 GT/s link speed for PCI Express 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.29 2011/01/13 14:29:26 jsg Exp $	*/
d326 1
a326 1
	printf(" Gb/s Link Width: x%d / x%d\n", swidth, cwidth);
@


1.29
log
@Add an entry for "Advanced Capabilities for Conventional PCI"
to the list of capabilities, present in recent Intel chipsets.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.28 2011/01/13 14:17:21 jsg Exp $	*/
d291 3
@


1.28
log
@fix an off by one
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.27 2011/01/12 20:17:56 kettenis Exp $	*/
d94 2
a95 1
	"SATA"
@


1.27
log
@Add SATA capability.  Use nitems() to decide if a capability is known or not.

ok krw@@, deraadt@@, dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.26 2010/12/19 23:23:21 jmc Exp $	*/
d344 1
a344 1
		if (cap > nitems(pci_capnames))
@


1.26
log
@add -xxx to usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.25 2010/12/19 23:06:10 kettenis Exp $	*/
d38 4
d93 2
a94 1
	"Extended Message Signaled Interrupts (MSI-X)"
a95 1
#define PCI_CAPNAMES_MAX	PCI_CAP_MSIX
d344 1
a344 1
		if (cap > PCI_CAPNAMES_MAX)
@


1.25
log
@Add -xxx option that print PCIe extended config space.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.24 2010/09/05 18:14:33 kettenis Exp $	*/
d59 1
a59 1
	    "usage: %s [-v] [-x | -xx] [-d pcidev] [bus:dev:func]\n"
@


1.24
log
@Add an ioctl to figure out the non-sticky bits in PCI BARs used for determining
the size of those BARs.  Make pcidump use this new ioctl to print the size
of PCI BARs.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.23 2010/08/02 10:17:10 jsg Exp $	*/
d69 1
d135 5
d272 1
a272 1
		hexdump(bus, dev, func, hex > 1);
d625 1
a625 1
hexdump(int bus, int dev, int func, int full)
d630 7
a636 1
	for (i = 0; i < (full ? 256 : 64); i += 4) {
a638 3

		if (pci_read(bus, dev, func, i, &reg) != 0)
			warn("unable to read 0x%02x", i);
@


1.23
log
@Show PCIe link speed/width, earlier version ok miod@@/kettenis@@ then
tweaked to show both negotiated and capable as well as fixing a mask
after comments from damien@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.22 2010/03/01 19:00:47 kettenis Exp $	*/
d46 1
d348 2
a349 1
	u_int32_t reg;
d353 2
a354 1
		if (pci_read(bus, dev, func, bar, &reg) != 0)
d359 1
a359 1
		if (reg == 0x0) {
d377 3
a379 2
				printf("addr: 0x%08x\n",
				    PCI_MAPREG_MEM_ADDR(reg));
d384 1
d386 2
a387 1
				if (pci_read(bus, dev, func, bar, &reg) != 0)
d391 1
d393 3
a395 2
				printf("64bit addr: 0x%016llx\n",
				    PCI_MAPREG_MEM64_ADDR(mem));
d402 3
a404 2
			printf("io addr: 0x%08x\n",
			    PCI_MAPREG_IO_ADDR(reg));
d662 22
@


1.22
log
@On amd64 and i386, dump the VGA BIOS found at the canonical address 0xc0000
if a VGA device doesn't have its expansion ROM base address register set.

ok oga@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.21 2009/11/06 23:59:14 kettenis Exp $	*/
d47 2
d271 44
d336 2
@


1.21
log
@Sync output of usage() with man page SYNOPSIS.

requested by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.20 2009/11/05 20:32:49 kettenis Exp $	*/
a18 8
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <err.h>

d22 1
d27 9
d48 1
d617 9
d645 30
@


1.20
log
@Implement -r option that dunps the contents of a PCI ROM to file.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.19 2009/06/07 21:48:16 sobrado Exp $	*/
d53 3
a55 2
	    "usage: %s [-v] [-x | -xx] [-d pcidev] [-r file] [bus:dev:func]\n",
	    __progname);
@


1.19
log
@improve spacing in usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.18 2009/06/07 09:50:52 jmc Exp $	*/
d45 1
d53 1
a53 1
	    "usage: %s [-v] [-x | -xx] [-d pcidev] [bus:dev:func]\n",
d59 1
d91 1
d95 1
a95 1
	while ((c = getopt(argc, argv, "d:vx")) != -1) {
d101 4
d118 1
a118 1
	if (argc > 1)
d121 6
a133 1
		printf("Domain %s:\n", pcidev);
d159 2
d167 1
d605 25
@


1.18
log
@sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.17 2009/06/05 19:19:02 deraadt Exp $	*/
d51 2
a52 1
	fprintf(stderr, "usage: %s [-v] [-x|-xx] [-d pcidev] [bus:dev:func]\n",
@


1.17
log
@Allow pcidump -xxv to work (show all the info)
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.16 2008/10/07 09:23:32 dlg Exp $	*/
d51 1
a51 1
	fprintf(stderr, "usage: %s [-v|-x|-xx] [-d pcidev] [bus:dev:func]\n",
@


1.16
log
@dump pci devices from all the domains available in the system. this gives
a proper view of what is plugged into the box, previously only the first
domain was displayed.

from Paul de Weerd <weerd@@weirdnet.nl> with help and feedback from
kettenis@@. thanks paul :)
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.14 2008/04/07 12:12:48 dlg Exp $	*/
d110 1
a110 1
	if (argc > 1 || (verbose && hex))
@


1.15
log
@Stop printing the size of BARs; the way the code calculates it is wrong.
We'll need kernel support to do it properly.

ok dlg@@
@
text
@d28 1
d37 1
d87 1
a87 1
	char *pcidev = PCIDEV;
d89 1
a89 1
	int c, error = 0;
d94 2
a95 1
			pcidev = optarg;
d113 24
a136 3
	pcifd = open(pcidev, O_RDONLY, 0777);
	if (pcifd == -1)
		err(1, "%s", pcidev);
d152 17
a168 6
		for (bus = 0; bus < 256; bus++) {
			for (dev = 0; dev < 32; dev++) {
				nfuncs = pci_nfuncs(bus, dev);
				for (func = 0; func < nfuncs; func++) {
					probe(bus, dev, func);
				}
a171 2

	return (0);
d236 1
a236 1
	printf("%d:%d:%d: %s %s\n", bus, dev, func,
@


1.14
log
@pretty print the BARs
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.12 2008/03/02 17:59:10 kettenis Exp $	*/
d273 2
a274 3
				printf("addr: 0x%08x len: %d\n",
				    PCI_MAPREG_MEM_ADDR(reg),
				    PCI_MAPREG_MEM_SIZE(reg));
d285 2
a286 3
				printf("64bit addr: 0x%016llx size: %lld\n",
				    PCI_MAPREG_MEM64_ADDR(mem),
				    PCI_MAPREG_MEM64_SIZE(mem));
d293 2
a294 2
			printf("io addr: 0x%08x size: %d\n",
			    PCI_MAPREG_IO_ADDR(reg), PCI_MAPREG_IO_SIZE(reg));
@


1.13
log
@if the device supports the PCI capabilities list and the verbose flag
is specified, print all PCI capabilities by name instead of just the
initial capabilities pointer.

ok dlg@@ kettenis@@
@
text
@d244 2
d252 47
a298 1
		printf("\t0x%04x: %08x\n", bar, reg);
@


1.12
log
@PCI devices are specified by bus:dev:func, not dev:bus:func.  Adjust usage
and man page.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.11 2007/11/20 13:56:36 chl Exp $	*/
d42 1
d58 22
d216 26
a256 1

a266 5
	if (pci_read(bus, dev, func, PCI_CAPLISTPTR_REG, &reg) != 0)
		warn("unable to read PCI_CAPLISTPTR_REG");
	printf("\t0x%04x: Capabilities Pointer: %02x\n",
	    PCI_CAPLISTPTR_REG, PCI_CAPLIST_PTR(reg));

a335 5
	if (pci_read(bus, dev, func, PCI_CAPLISTPTR_REG, &reg) != 0)
		warn("unable to read PCI_CAPLISTPTR_REG");
	printf("\t0x%04x: Capabilities Pointer: %02x\n",
	    PCI_CAPLISTPTR_REG, PCI_CAPLIST_PTR(reg));

a359 5
	if (pci_read(bus, dev, func, PCI_CARDBUS_CAPLISTPTR_REG, &reg) != 0)
		warn("unable to read PCI_CARDBUS_CAPLISTPTR_REG");
	printf("\t0x%04x: Capabilities Pointer: %02x Cardbus Status: %04x\n",
	    PCI_CARDBUS_CAPLISTPTR_REG, PCI_CAPLIST_PTR(reg), reg >> 16);

d421 1
d448 1
d459 1
a459 1

@


1.11
log
@remove "unused variable" warning

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.10 2007/11/18 00:33:45 kettenis Exp $	*/
d48 1
a48 1
	fprintf(stderr, "usage: %s [-v|-x|-xx] [-d pcidev] [dev:bus:func]\n",
@


1.10
log
@Add support for dumping PCI config space in hex.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.9 2007/11/17 18:32:21 kettenis Exp $	*/
a387 1
	int bar;
@


1.9
log
@Add code to print type 1 (PCI-PCI bridge) and type 2 (CardBus bridge) devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.8 2007/10/25 10:27:21 tobias Exp $	*/
d38 1
d48 1
a48 1
	fprintf(stderr, "usage: %s [-v] [-d pcidev] [dev:bus:func]\n",
d55 1
d66 1
a66 1
	while ((c = getopt(argc, argv, "d:v")) != -1) {
d74 3
d84 1
a84 1
	if (argc > 1)
d186 2
d426 19
@


1.8
log
@Max values are 255:31:7 not 256:32:8.

OK dlg@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.7 2007/10/23 06:57:28 chl Exp $	*/
d186 1
a186 1
dump(int bus, int dev, int func)
a190 22
	if (pci_read(bus, dev, func, PCI_ID_REG, &reg) != 0)
		warn("unable to read PCI_ID_REG");
	printf("\t0x%04x: Vendor ID: %04x Product ID: %04x\n", PCI_ID_REG,
	    PCI_VENDOR(reg), PCI_PRODUCT(reg));

	if (pci_read(bus, dev, func, PCI_COMMAND_STATUS_REG, &reg) != 0)
		warn("unable to read PCI_COMMAND_STATUS_REG");
	printf("\t0x%04x: Command: %04x Status ID: %04x\n",
	    PCI_COMMAND_STATUS_REG, reg & 0xffff, (reg  >> 16) & 0xffff);

	if (pci_read(bus, dev, func, PCI_CLASS_REG, &reg) != 0)
		warn("unable to read PCI_CLASS_REG");
	printf("\t0x%04x: Class: %02x Subclass: %02x Interface: %02x "
	    "Revision: %02x\n", PCI_CLASS_REG, PCI_CLASS(reg),
	    PCI_SUBCLASS(reg), PCI_INTERFACE(reg), PCI_REVISION(reg));

	if (pci_read(bus, dev, func, PCI_BHLC_REG, &reg) != 0)
		warn("unable to read PCI_BHLC_REG");
	printf("\t0x%04x: BIST: %02x Header Type: %02x Latency Timer: %02x "
	    "Cache Line Size: %02x\n", PCI_BHLC_REG, PCI_BIST(reg),
	    PCI_HDRTYPE(reg), PCI_LATTIMER(reg), PCI_CACHELINE(reg));

d201 1
d226 193
@


1.7
log
@add missing header to avoid warning

"commit!" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.6 2007/10/22 20:54:52 deraadt Exp $	*/
d101 1
a101 1
			for (dev = 0; dev <= 32; dev++) {
d103 1
a103 1
				for (func = 0; func <= nfuncs; func++) {
d131 1
a131 1
	*bus = strtonum(b, 0, 256, &errstr);
d134 1
a134 1
	*dev = strtonum(d, 0, 32, &errstr);
d137 1
a137 1
	*func = strtonum(f, 0, 8, &errstr);
@


1.6
log
@variable does not need init; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pcidump.c,v 1.5 2007/10/22 09:26:16 jasper Exp $	*/
d27 1
@


1.5
log
@add RCS id

"free commit!" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
a51 1
int pcifd = -1;
@


1.4
log
@lint says __progname is not const
@
text
@d1 2
@


1.3
log
@dmesg prints bus/dev/func locations in decimal, and the command line param
to pcidump takes decimals, so print the locations as decimals too. less
confusing, but maybe a bit uglier. ugliness can be fixed later though.
@
text
@d42 2
a43 1
	extern const char *__progname;
@


1.2
log
@i wrote most of the code this year, so fix copyright.
@
text
@d171 1
a171 1
	printf("%02x:%02x:%02x: %s %s\n", bus, dev, func,
@


1.1
log
@put pcidump in the tree, a little tool for reading the pci configuration
spaces.

requested by kettenis@@ ok kettenis@@ deraadt@@ marco@@ and lots of others
@
text
@d2 1
a2 1
 * Copyright (c) 2006 David Gwynne <loki@@animata.net>
@

