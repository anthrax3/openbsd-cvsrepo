head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.10
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.8
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.12
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.10
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.6
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.8
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.10.13.15.12.53;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	8ODzM2draqAdHg2g;

1.19
date	2015.09.10.18.59.34;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	6O6HanUgBazjFluC;

1.18
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	z3HrihslRYb4HqW9;

1.17
date	2015.01.16.15.40.16;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	zc8vlWAvtfmEj9Hn;

1.16
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.05.20.29.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.16.03.12.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.26.21.36.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.17.19.42.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.28.06;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.30.16.00.26;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.09.12.04.07.17;	author millert;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.06.18.00.00.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.02.03.00.13.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.02.23.32.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.44.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.05.01.13.32.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.57;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.57;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2000.10.06.21.24.21;	author jason;	state Exp;
branches;
next	;


desc
@@


1.20
log
@pledge "stdio rpath wpath cpath", full path handling to satisfy dbopen()
@
text
@/*	$OpenBSD: netgroup_mkdb.c,v 1.19 2015/09/10 18:59:34 deraadt Exp $	*/

/*
 * Copyright (c) 1994 Christos Zoulas
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christos Zoulas.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>
#include <fcntl.h>
#include <db.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <netgroup.h>
#include <assert.h>

#include "str.h"
#include "stringlist.h"
#include "util.h"

#define DEBUG_NG

struct nentry {
	int             n_type;
	size_t          n_size;	/* Buffer size required for printing */
	union {
		char            *_name;
		struct netgroup *_group;
	} _n;
#define n_name	_n._name
#define n_group _n._group
	struct nentry  *n_next;
};


static DB       *ng_insert(DB *, const char *);
static void	 ng_reventry(DB *, DB *, struct nentry *, char *,
		    size_t, struct stringlist *);

static void	 ng_print(struct nentry *, struct string *);
static void	 ng_rprint(DB *, struct string *);
static DB	*ng_reverse(DB *, size_t);
static DB	*ng_load(const char *);
static void	 ng_write(DB *, DB *, int);
static void	 ng_rwrite(DB *, DB *, int);
static void	 usage(void);
static void	 cleanup(void);

#ifdef DEBUG_NG
static int 	 debug = 0;
static void	 ng_dump(DB *);
static void	 ng_rdump(DB *);
#endif /* DEBUG_NG */


static const char ng_empty[] = "";
#define NG_EMPTY(a)	((a) ? (a) : ng_empty)

static char    *dbname = _PATH_NETGROUP_DB;

int
main(int argc, char *argv[])
{
	char		  buf[PATH_MAX], *fname = _PATH_NETGROUP;
	DB		 *db, *ndb, *hdb, *udb;
	int               ch;

	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "do:")) != -1)
		switch (ch) {
#ifdef DEBUG_NG
		case 'd':
			debug++;
			break;
#endif
		case 'o':
			dbname = optarg;
			break;

		case '?':
		default:
			usage();
		}

	argc -= optind;
	argv += optind;

	if (argc == 1)
		fname = *argv;
	else if (argc > 1)
		usage();

	if (atexit(cleanup))
		err(1, "Cannot install exit handler");

	/* Read and parse the netgroup file */
	ndb = ng_load(fname);
#ifdef DEBUG_NG
	if (debug) {
		(void) fprintf(stderr, "#### Database\n");
		ng_dump(ndb);
	}
#endif

	/* Reverse the database by host */
	hdb = ng_reverse(ndb, offsetof(struct netgroup, ng_host));
#ifdef DEBUG_NG
	if (debug) {
		(void) fprintf(stderr, "#### Reverse by host\n");
		ng_rdump(hdb);
	}
#endif

	/* Reverse the database by user */
	udb = ng_reverse(ndb, offsetof(struct netgroup, ng_user));
#ifdef DEBUG_NG
	if (debug) {
		(void) fprintf(stderr, "#### Reverse by user\n");
		ng_rdump(udb);
	}
#endif

	(void) snprintf(buf, sizeof(buf), "%s.tmp", dbname);

	db = dbopen(buf, O_RDWR | O_CREAT | O_EXCL,
	    (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH), DB_HASH, NULL);
	if (!db)
		err(1, "%s", buf);

	ng_write(db, ndb, _NG_KEYBYNAME);
	ng_rwrite(db, udb, _NG_KEYBYUSER);
	ng_rwrite(db, hdb, _NG_KEYBYHOST);

	if ((db->close)(db))
		err(1, "Error closing database");

	if (rename(buf, dbname) == -1)
		err(1, "Cannot rename `%s' to `%s'", buf, dbname);

	return 0;
}


/*
 * cleanup(): Remove temporary files upon exit
 */
static void
cleanup(void)
{
	char buf[PATH_MAX];

	(void) snprintf(buf, sizeof(buf), "%s.tmp", dbname);
	(void) unlink(buf);
}



/*
 * ng_load(): Load the netgroup database from a file
 */
static DB *
ng_load(const char *fname)
{
	FILE           *fp;
	DB             *db;
	char           *buf, *p, *name;
	size_t          size;
	struct nentry  *tail, *head, *e;
	struct netgroup *ng;
	DBT             data, key;

	/* Open the netgroup file */
	if ((fp = fopen(fname, "r")) == NULL)
		err(1, "%s", fname);

	db = dbopen(NULL, O_RDWR | O_CREAT | O_EXCL, 0, DB_HASH, NULL);

	if (db == NULL)
		err(1, "dbopen");

	while ((buf = get_line(fp, &size)) != NULL) {
		tail = head = NULL;
		p = buf;

		while (p != NULL) {
			switch (_ng_parse(&p, &name, &ng)) {
			case _NG_NONE:
				/* done with this one */
				p = NULL;
				free(buf);
				if (head == NULL)
					break;

				key.data = (u_char *) head->n_name;
				key.size = strlen(head->n_name) + 1;
				data.data = (u_char *) & head;
				data.size = sizeof(head);
				switch ((db->put)(db, &key, &data, 
						  R_NOOVERWRITE)) {
				case 0:
					break;

				case 1:
					warnx("Duplicate entry netgroup `%s'",
					    head->n_name);
					break;

				case -1:
					err(1, "put");
					break;

				default:
					abort();
					break;
				}
				break;

			case _NG_NAME:
				e = emalloc(sizeof(struct nentry));
				e->n_type = _NG_NAME;
				e->n_name = name;
				e->n_next = NULL;
				e->n_size = size;
				if (tail == NULL)
					head = tail = e;
				else {
					tail->n_next = e;
					tail = e;
				}
				break;

			case _NG_GROUP:
				if (tail == NULL) {
					char fmt[BUFSIZ];
					_ng_print(fmt, sizeof(fmt), ng);
					errx(1, "no netgroup key for %s", fmt);
				} else {
					e = emalloc(sizeof(struct nentry));
					e->n_type = _NG_GROUP;
					e->n_group = ng;
					e->n_next = NULL;
					e->n_size = size;
					tail->n_next = e;
					tail = e;
				}
				break;

			default:
				abort();
				break;
			}
		}
	}
	(void) fclose(fp);
	return db;
}


/*
 * ng_insert(): Insert named key into the database, and return its associated
 * string database
 */
static DB *
ng_insert(DB *db, const char *name)
{
	DB             *xdb = NULL;
	DBT             key, data;

	key.data = (u_char *) name;
	key.size = strlen(name) + 1;

	switch ((db->get)(db, &key, &data, 0)) {
	case 0:
		memcpy(&xdb, data.data, sizeof(xdb));
		break;

	case 1:
		xdb = dbopen(NULL, O_RDWR | O_CREAT | O_EXCL, 0, DB_HASH, NULL);
		if (xdb == NULL)
			err(1, "dbopen");

		data.data = (u_char *) & xdb;
		data.size = sizeof(xdb);
		switch ((db->put)(db, &key, &data, R_NOOVERWRITE)) {
		case 0:
			break;

		case -1:
			err(1, "db put `%s'", name);
			break;

		case 1:
		default:
			abort();
		}
		break;

	case -1:
		err(1, "db get `%s'", name);
		break;

	default:
		abort();
		break;
	}

	return xdb;
}


/*
 * ng_reventry(): Recursively add all the netgroups to the group entry.
 */
static void
ng_reventry(DB *db, DB *udb, struct nentry *fe, char *name, size_t s,
    struct stringlist *ss)
{
	DBT             key, data;
	struct nentry  *e;
	struct netgroup *ng;
	struct nentry *rfe;
	char           *p;
	DB             *xdb;

	if (_ng_sl_find(ss, fe->n_name) != NULL) {
		warnx("Cycle in netgroup `%s'", name);
		return;
	}
	if (_ng_sl_add(ss, fe->n_name) == -1) {
		warn(NULL);
		return;
	}

	for (e = fe->n_next; e != NULL; e = e->n_next)
		switch (e->n_type) {
		case _NG_GROUP:
			ng = e->n_group;
			p = _ng_makekey(*((char **)(((char *) ng) + s)),
			    ng->ng_domain, e->n_size);
			xdb = ng_insert(udb, p);
			key.data = (u_char *) name;
			key.size = strlen(name) + 1;
			data.data = NULL;
			data.size = 0;
			switch ((xdb->put)(xdb, &key, &data, R_NOOVERWRITE)) {
			case 0:
			case 1:
				break;

			case -1:
				err(1, "db put `%s'", name);
				return;

			default:
				abort();
				break;
			}
			free(p);
			break;

		case _NG_NAME:
			key.data = (u_char *) e->n_name;
			key.size = strlen(e->n_name) + 1;
			switch ((db->get)(db, &key, &data, 0)) {
			case 0:
				(void) memcpy(&rfe, data.data, sizeof(rfe));
				ng_reventry(db, udb, rfe, name, s, ss);
				break;

			case 1:
				break;

			case -1:
				err(1, "db get `%s'", e->n_name);
				return;

			default:
				abort();
				return;
			}
			break;

		default:
			abort();
			break;
		}
}


/*
 * ng_reverse(): Reverse the database
 */
static DB *
ng_reverse(DB *db, size_t s)
{
	int             pos;
	struct stringlist *sl;
	DBT             key, data;
	struct nentry  *fe;
	DB             *udb;

	udb = dbopen(NULL, O_RDWR | O_CREAT | O_EXCL, 0, DB_HASH, NULL);

	if (udb == NULL)
		err(1, "dbopen");

	for (pos = R_FIRST;; pos = R_NEXT)
		switch ((db->seq)(db, &key, &data, pos)) {
		case 0:
			sl = _ng_sl_init();
			memcpy(&fe, data.data, sizeof(fe));
			ng_reventry(db, udb, fe, (char *) key.data, s, sl);
			_ng_sl_free(sl, 0);
			break;

		case 1:
			return udb;

		case -1:
			err(1, "seq");
			return udb;
		}

	return udb;
}


/*
 * ng_print(): Pretty print a netgroup entry
 */
static void
ng_print(struct nentry *e, struct string *str)
{
	char           *ptr = emalloc(e->n_size);

	if (e->n_next == NULL) {
		str_append(str, "", ' ');
		return;
	}

	for (e = e->n_next; e != NULL; e = e->n_next) {
		switch (e->n_type) {
		case _NG_NAME:
			(void) snprintf(ptr, e->n_size, "%s", e->n_name);
			break;

		case _NG_GROUP:
			(void) snprintf(ptr, e->n_size, "(%s,%s,%s)",
			    NG_EMPTY(e->n_group->ng_host),
			    NG_EMPTY(e->n_group->ng_user),
			    NG_EMPTY(e->n_group->ng_domain));
			break;

		default:
			errx(1, "Internal error: Bad netgroup type");
			break;
		}
		str_append(str, ptr, ' ');
	}
	free(ptr);
}


/*
 * ng_rprint(): Pretty print all reverse netgroup mappings in the given entry
 */
static void
ng_rprint(DB *db, struct string *str)
{
	int             pos;
	DBT             key, data;

	for (pos = R_FIRST;; pos = R_NEXT)
		switch ((db->seq)(db, &key, &data, pos)) {
		case 0:
			str_append(str, (char *) key.data, ',');
			break;

		case 1:
			return;

		default:
			err(1, "seq");
			break;
		}
}


#ifdef DEBUG_NG
/*
 * ng_dump(): Pretty print all netgroups in the given database
 */
static void
ng_dump(DB *db)
{
	int             pos;
	DBT             key, data;
	struct nentry  *e;
	struct string   buf;

	for (pos = R_FIRST;; pos = R_NEXT)
		switch ((db->seq)(db, &key, &data, pos)) {
		case 0:
			memcpy(&e, data.data, sizeof(e));
			str_init(&buf);
			assert(e->n_type == _NG_NAME);

			ng_print(e, &buf);
			(void) fprintf(stderr, "%s\t%s\n", e->n_name,
			    buf.s_str ? buf.s_str : "");
			str_free(&buf);
			break;

		case 1:
			return;

		default:
			err(1, "seq");
			return;
		}
}


/*
 * ng_rdump(): Pretty print all reverse mappings in the given database
 */
static void
ng_rdump(DB *db)
{
	int             pos;
	DBT             key, data;
	DB             *xdb;
	struct string   buf;

	for (pos = R_FIRST;; pos = R_NEXT)
		switch ((db->seq)(db, &key, &data, pos)) {
		case 0:
			memcpy(&xdb, data.data, sizeof(xdb));
			str_init(&buf);
			ng_rprint(xdb, &buf);
			(void) fprintf(stderr, "%s\t%s\n",
			    (char *) key.data, buf.s_str ? buf.s_str : "");
			str_free(&buf);
			break;

		case 1:
			return;

		default:
			err(1, "seq");
			return;
		}
}
#endif /* DEBUG_NG */


/*
 * ng_write(): Dump the database into a file.
 */
static void
ng_write(DB *odb, DB *idb, int k)
{
	int             pos;
	DBT             key, data;
	struct nentry  *e;
	struct string   skey, sdata;

	for (pos = R_FIRST;; pos = R_NEXT)
		switch ((idb->seq)(idb, &key, &data, pos)) {
		case 0:
			memcpy(&e, data.data, sizeof(e));
			str_init(&skey);
			str_init(&sdata);
			assert(e->n_type == _NG_NAME);

			str_prepend(&skey, e->n_name, k);
			ng_print(e, &sdata);
			key.data = (u_char *) skey.s_str;
			key.size = skey.s_len + 1;
			data.data = (u_char *) sdata.s_str;
			data.size = sdata.s_len + 1;

			switch ((odb->put)(odb, &key, &data, R_NOOVERWRITE)) {
			case 0:
				break;

			case -1:
				err(1, "put");
				break;

			case 1:
			default:
				abort();
				break;
			}

			str_free(&skey);
			str_free(&sdata);
			break;

		case 1:
			return;

		default:
			err(1, "seq");
			return;
		}
}


/*
 * ng_rwrite(): Write the database
 */
static void
ng_rwrite(DB *odb, DB *idb, int k)
{
	int             pos;
	DBT             key, data;
	DB             *xdb;
	struct string   skey, sdata;

	for (pos = R_FIRST;; pos = R_NEXT)
		switch ((idb->seq)(idb, &key, &data, pos)) {
		case 0:
			memcpy(&xdb, data.data, sizeof(xdb));
			str_init(&skey);
			str_init(&sdata);

			str_prepend(&skey, (char *) key.data, k);
			ng_rprint(xdb, &sdata);
			key.data = (u_char *) skey.s_str;
			key.size = skey.s_len + 1;
			data.data = (u_char *) sdata.s_str;
			data.size = sdata.s_len + 1;

			switch ((odb->put)(odb, &key, &data, R_NOOVERWRITE)) {
			case 0:
				break;

			case -1:
				err(1, "put");
				break;

			case 1:
			default:
				abort();
				break;
			}

			str_free(&skey);
			str_free(&sdata);
			break;

		case 1:
			return;

		default:
			err(1, "seq");
			return;
		}
}


/*
 * usage(): Print usage message and exit
 */
static void
usage(void)
{
	extern const char *__progname;

	fprintf(stderr, "usage: %s [-o database] file\n", __progname);
	exit(1);
}
@


1.19
log
@Hide netgroup internals inside libc.  The parts that netgroup_mkdb
wants to use, well.... copy them there.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.18 2015/08/20 22:39:29 deraadt Exp $	*/
d99 2
@


1.18
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.17 2015/01/16 15:40:16 deraadt Exp $	*/
a44 1
#define _NETGROUP_PRIVATE
d49 1
@


1.17
log
@Move from <sys/param.h>.  (The binary change is due to a line number
passed to assert, found by doug)
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.16 2012/03/04 04:05:15 fgsch Exp $	*/
a53 2
#define NEW(a)	(a *) emalloc(sizeof(a))

d250 1
a250 1
				e = NEW(struct nentry);
d269 1
a269 1
					e = NEW(struct nentry);
@


1.16
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.15 2009/10/27 23:59:53 deraadt Exp $	*/
a34 1
#include <sys/param.h>
d97 1
a97 1
	char		  buf[MAXPATHLEN], *fname = _PATH_NETGROUP;
d183 1
a183 1
	char buf[MAXPATHLEN];
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.14 2008/05/17 23:31:52 sobrado Exp $	*/
d215 1
a215 1
	while ((buf = getline(fp, &size)) != NULL) {
@


1.14
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.13 2007/03/05 20:29:14 millert Exp $	*/
a32 3
#ifndef lint
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.13 2007/03/05 20:29:14 millert Exp $";
#endif
@


1.13
log
@Remove _err() calls from getnetgrent.c.  This is a minor API change
as _ng_sl_add() now returns a value. The only consumer of that
interface is netgroup_mkdb(8).  Adapted from NetBSD.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.12 2005/05/16 03:12:59 deraadt Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.12 2005/05/16 03:12:59 deraadt Exp $";
d709 1
a709 1
	fprintf(stderr, "usage: %s [-o db] file\n", __progname);
@


1.12
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.11 2003/06/26 21:36:39 deraadt Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.11 2003/06/26 21:36:39 deraadt Exp $";
d366 4
a369 1
	_ng_sl_add(ss, fe->n_name);
@


1.11
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.10 2002/02/17 19:42:38 millert Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.10 2002/02/17 19:42:38 millert Exp $";
d101 1
a103 2
	char		  buf[MAXPATHLEN];
	char		 *fname = _PATH_NETGROUP;
d163 1
a163 1
		    (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH), DB_HASH, NULL);
d203 1
a203 1
	char           *buf;
a205 1
	char           *p, *name;
d242 1
a242 1
					      head->n_name);
d274 1
a274 2
				}
				else {
d373 1
a373 1
					ng->ng_domain, e->n_size);
d434 3
a436 2
	DB             *udb = dbopen(NULL, O_RDWR | O_CREAT | O_EXCL, 0,
				     DB_HASH, NULL);
d483 3
a485 3
					NG_EMPTY(e->n_group->ng_host),
					NG_EMPTY(e->n_group->ng_user),
					NG_EMPTY(e->n_group->ng_domain));
d544 1
a544 1
				       buf.s_str ? buf.s_str : "");
d576 1
a576 2
				       (char *) key.data,
				       buf.s_str ? buf.s_str : "");
d705 1
@


1.10
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.9 2002/02/16 21:28:06 millert Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.9 2002/02/16 21:28:06 millert Exp $";
d99 1
a99 3
main(argc, argv)
	int		  argc;
	char		**argv;
d186 1
a186 1
cleanup()
d189 1
d200 1
a200 2
ng_load(fname)
	const char     *fname;
d304 1
a304 3
ng_insert(db, name)
	DB             *db;
	const char     *name;
d355 2
a356 6
ng_reventry(db, udb, fe, name, s, ss)
	DB             *db, *udb;
	struct nentry  *fe;
	char           *name;
	size_t          s;
	struct stringlist *ss;
d431 1
a431 3
ng_reverse(db, s)
	DB             *db;
	size_t          s;
d468 1
a468 3
ng_print(e, str)
	struct nentry  *e;
	struct string  *str;
d504 1
a504 3
ng_rprint(db, str)
	DB             *db;
	struct string  *str;
d530 1
a530 2
ng_dump(db)
	DB             *db;
d564 1
a564 2
ng_rdump(db)
	DB             *db;
d598 1
a598 3
ng_write(odb, idb, k)
	DB             *odb, *idb;
	int             k;
d652 1
a652 4
ng_rwrite(odb, idb, k)
	DB             *odb;
	DB             *idb;
	int             k;
d705 1
a705 1
usage()
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.8 2000/06/30 16:00:26 millert Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.8 2000/06/30 16:00:26 millert Exp $";
d74 2
a75 2
static void	 ng_reventry __P((DB *, DB *, struct nentry *, char *,
				  size_t, struct stringlist *));
@


1.8
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.7 1997/09/12 04:07:17 millert Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.7 1997/09/12 04:07:17 millert Exp $";
d73 1
a73 1
static DB       *ng_insert __P((DB *, const char *));
d77 8
a84 8
static void	 ng_print __P((struct nentry *, struct string *));
static void	 ng_rprint __P((DB *, struct string *));
static DB	*ng_reverse __P((DB *, size_t));
static DB	*ng_load __P((const char *));
static void	 ng_write __P((DB *, DB *, int));
static void	 ng_rwrite __P((DB *, DB *, int));
static void	 usage __P((void));
static void	 cleanup __P((void));
d88 2
a89 2
static void	 ng_dump __P((DB *));
static void	 ng_rdump __P((DB *));
@


1.7
log
@Kill extra newline in err()/warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.6 1997/06/18 00:00:45 deraadt Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.6 1997/06/18 00:00:45 deraadt Exp $";
d168 1
a168 1
		err(1, buf);
d215 1
a215 1
		err(1, fname);
@


1.7.12.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.8 2000/06/30 16:00:26 millert Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.8 2000/06/30 16:00:26 millert Exp $";
d168 1
a168 1
		err(1, "%s", buf);
d215 1
a215 1
		err(1, "%s", fname);
@


1.6
log
@repair recursive map entry thingy; christos
@
text
@d1 1
a1 1
/*	$OpenBSD: netgroup_mkdb.c,v 1.5 1997/02/03 00:13:04 millert Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.5 1997/02/03 00:13:04 millert Exp $";
d245 1
a245 1
					warnx("Duplicate entry netgroup `%s'\n",
d503 1
a503 1
			errx(1, "Internal error: Bad netgroup type\n");
@


1.5
log
@back out stringlist changes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.3 1997/01/15 23:44:08 millert Exp $";
d369 1
d373 1
a373 1
	if (_ng_sl_find(ss, name) != NULL) {
d377 1
a377 1
	_ng_sl_add(ss, name);
d411 2
a412 2
				memcpy(&fe, data.data, sizeof(fe));
				ng_reventry(db, udb, fe, e->n_name, s, ss);
@


1.4
log
@Use public stringlist (in libc)
@
text
@d1 1
a1 2
/*	$OpenBSD: netgroup_mkdb.c,v 1.6 1997/01/19 03:30:14 lukem Exp $	*/
/*	$NetBSD: netgroup_mkdb.c,v 1.6 1997/01/19 03:30:14 lukem Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: netgroup_mkdb.c,v 1.6 1997/01/19 03:30:14 lukem Exp $";
a48 1
#include <stringlist.h>
d75 1
a75 1
				  size_t, StringList *));
d364 1
a364 1
	StringList	*ss;
d372 1
a372 1
	if (sl_find(ss, name) != NULL) {
d376 1
a376 1
	sl_add(ss, name);
d443 1
a443 1
	StringList	*sl;
d455 1
a455 1
			sl = sl_init();
d458 1
a458 1
			sl_free(sl, 0);
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 3
d35 1
a35 1
static char *rcsid = "$Id: netgroup_mkdb.c,v 1.2 1996/05/01 13:32:21 deraadt Exp $";
d50 1
d77 1
a77 1
				  size_t, struct stringlist *));
d366 1
a366 1
	struct stringlist *ss;
d374 1
a374 1
	if (_ng_sl_find(ss, name) != NULL) {
d378 1
a378 1
	_ng_sl_add(ss, name);
d445 1
a445 1
	struct stringlist *sl;
d457 1
a457 1
			sl = _ng_sl_init();
d460 1
a460 1
			_ng_sl_free(sl, 0);
@


1.2
log
@from netbsd:
- Fixed core-dump when key has no netgroups
- added -d flag for debugging.
- moved external functions to netgroup.h
@
text
@d32 1
a32 1
static char *rcsid = "$Id: netgroup_mkdb.c,v 1.1.1.1 1995/10/18 08:47:57 deraadt Exp $";
d107 1
a107 1
	while ((ch = getopt(argc, argv, "do:")) != EOF)
@


1.1
log
@Initial revision
@
text
@d32 1
a32 1
static char *rcsid = "$Id: netgroup_mkdb.c,v 1.3 1995/06/02 21:40:51 christos Exp $";
d47 1
d54 2
a70 11
struct stringlist;

extern struct stringlist
		*_ng_sl_init __P((void));
extern void      _ng_sl_add __P((struct stringlist *, char *));
extern void    	 _ng_sl_free __P((struct stringlist *, int));
extern char    	*_ng_sl_find __P((struct stringlist *, char *));

extern char     *_ng_makekey __P((const char *, const char *, size_t));
extern int       _ng_parse __P((char **, char **, struct netgroup **));

d85 1
d90 1
d107 1
a107 1
	while ((ch = getopt(argc, argv, "o:")) != EOF)
d109 5
d137 4
a140 2
	(void) fprintf(stderr, "#### Database\n");
	ng_dump(ndb);
d146 4
a149 2
	(void) fprintf(stderr, "#### Reverse by host\n");
	ng_rdump(hdb);
d155 4
a158 2
	(void) fprintf(stderr, "#### Reverse by user\n");
	ng_rdump(udb);
d272 5
a276 2
				if (tail == NULL)
					errx(1, "no netgroup key");
d480 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
