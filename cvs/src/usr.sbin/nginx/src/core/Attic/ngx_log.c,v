head	1.10;
access;
symbols
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2;
locks; strict;
comment	@ * @;


1.10
date	2014.08.26.19.35.33;	author robert;	state dead;
branches;
next	1.9;
commitid	sO1mMs3aGJWmnMM1;

1.9
date	2014.06.12.15.27.08;	author robert;	state Exp;
branches;
next	1.8;
commitid	diSa3BSte1X8Lp04;

1.8
date	2013.03.21.20.16.48;	author robert;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.17.16.05.30;	author robert;	state Exp;
branches;
next	1.6;

1.6
date	2012.10.28.18.34.53;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.28.10.33.52;	author robert;	state Exp;
branches;
next	1.4;

1.4
date	2012.10.25.13.02.46;	author robert;	state Exp;
branches;
next	1.3;

1.3
date	2012.02.18.11.20.21;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.12.11.09.00;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.22.23.38.25;	author robert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove nginx from the base system in favor of OpenBSD's own httpd(8)
@
text
@
/*
 * Copyright (C) Igor Sysoev
 * Copyright (C) Nginx, Inc.
 */


#include <ngx_config.h>
#include <ngx_core.h>


static char *ngx_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
static char *ngx_log_set_levels(ngx_conf_t *cf, ngx_log_t *log);
static void ngx_log_insert(ngx_log_t *log, ngx_log_t *new_log);


static ngx_command_t  ngx_errlog_commands[] = {

    {ngx_string("error_log"),
     NGX_MAIN_CONF|NGX_CONF_1MORE,
     ngx_error_log,
     0,
     0,
     NULL},

    ngx_null_command
};


static ngx_core_module_t  ngx_errlog_module_ctx = {
    ngx_string("errlog"),
    NULL,
    NULL
};


ngx_module_t  ngx_errlog_module = {
    NGX_MODULE_V1,
    &ngx_errlog_module_ctx,                /* module context */
    ngx_errlog_commands,                   /* module directives */
    NGX_CORE_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


static ngx_log_t        ngx_log;
static ngx_open_file_t  ngx_log_file;
ngx_uint_t              ngx_use_stderr = 1;


static ngx_str_t err_levels[] = {
    ngx_null_string,
    ngx_string("emerg"),
    ngx_string("alert"),
    ngx_string("crit"),
    ngx_string("error"),
    ngx_string("warn"),
    ngx_string("notice"),
    ngx_string("info"),
    ngx_string("debug")
};

static const char *debug_levels[] = {
    "debug_core", "debug_alloc", "debug_mutex", "debug_event",
    "debug_http", "debug_mail", "debug_mysql"
};


#if (NGX_HAVE_VARIADIC_MACROS)

void
ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
    const char *fmt, ...)

#else

void
ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
    const char *fmt, va_list args)

#endif
{
#if (NGX_HAVE_VARIADIC_MACROS)
    va_list      args;
#endif
    u_char      *p, *last, *msg;
    u_char       errstr[NGX_MAX_ERROR_STR];
    ngx_uint_t   wrote_stderr, debug_connection;

    last = errstr + NGX_MAX_ERROR_STR;

    ngx_memcpy(errstr, ngx_cached_err_log_time.data,
               ngx_cached_err_log_time.len);

    p = errstr + ngx_cached_err_log_time.len;

    p = ngx_slprintf(p, last, " [%V] ", &err_levels[level]);

    /* pid#tid */
    p = ngx_slprintf(p, last, "%P#" NGX_TID_T_FMT ": ",
                    ngx_log_pid, ngx_log_tid);

    if (log->connection) {
        p = ngx_slprintf(p, last, "*%uA ", log->connection);
    }

    msg = p;

#if (NGX_HAVE_VARIADIC_MACROS)

    va_start(args, fmt);
    p = ngx_vslprintf(p, last, fmt, args);
    va_end(args);

#else

    p = ngx_vslprintf(p, last, fmt, args);

#endif

    if (err) {
        p = ngx_log_errno(p, last, err);
    }

    if (level != NGX_LOG_DEBUG && log->handler) {
        p = log->handler(log, p, last - p);
    }

    if (p > last - NGX_LINEFEED_SIZE) {
        p = last - NGX_LINEFEED_SIZE;
    }

    ngx_linefeed(p);

    wrote_stderr = 0;
    debug_connection = (log->log_level & NGX_LOG_DEBUG_CONNECTION) != 0;

    while (log) {

        if (log->log_level < level && !debug_connection) {
            break;
        }

        if (log->writer) {
            log->writer(log, level, errstr, p - errstr);
            log = log->next;
            continue;
        }

        (void) ngx_write_fd(log->file->fd, errstr, p - errstr);

        if (log->file->fd == ngx_stderr) {
            wrote_stderr = 1;
        }

        log = log->next;
    }

    if (!ngx_use_stderr
        || level > NGX_LOG_WARN
        || wrote_stderr)
    {
        return;
    }

    msg -= (7 + err_levels[level].len + 3);

    (void) ngx_sprintf(msg, "nginx: [%V] ", &err_levels[level]);

    (void) ngx_write_console(ngx_stderr, msg, p - msg);
}


#if !(NGX_HAVE_VARIADIC_MACROS)

void ngx_cdecl
ngx_log_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
    const char *fmt, ...)
{
    va_list  args;

    if (log->log_level >= level) {
        va_start(args, fmt);
        ngx_log_error_core(level, log, err, fmt, args);
        va_end(args);
    }
}


void ngx_cdecl
ngx_log_debug_core(ngx_log_t *log, ngx_err_t err, const char *fmt, ...)
{
    va_list  args;

    va_start(args, fmt);
    ngx_log_error_core(NGX_LOG_DEBUG, log, err, fmt, args);
    va_end(args);
}

#endif


void ngx_cdecl
ngx_log_abort(ngx_err_t err, const char *fmt, ...)
{
    u_char   *p;
    va_list   args;
    u_char    errstr[NGX_MAX_CONF_ERRSTR];

    va_start(args, fmt);
    p = ngx_vsnprintf(errstr, sizeof(errstr) - 1, fmt, args);
    va_end(args);

    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, err,
                  "%*s", p - errstr, errstr);
}


void ngx_cdecl
ngx_log_stderr(ngx_err_t err, const char *fmt, ...)
{
    u_char   *p, *last;
    va_list   args;
    u_char    errstr[NGX_MAX_ERROR_STR];

    last = errstr + NGX_MAX_ERROR_STR;
    p = errstr + 7;

    ngx_memcpy(errstr, "nginx: ", 7);

    va_start(args, fmt);
    p = ngx_vslprintf(p, last, fmt, args);
    va_end(args);

    if (err) {
        p = ngx_log_errno(p, last, err);
    }

    if (p > last - NGX_LINEFEED_SIZE) {
        p = last - NGX_LINEFEED_SIZE;
    }

    ngx_linefeed(p);

    (void) ngx_write_console(ngx_stderr, errstr, p - errstr);
}


u_char *
ngx_log_errno(u_char *buf, u_char *last, ngx_err_t err)
{
    if (buf > last - 50) {

        /* leave a space for an error code */

        buf = last - 50;
        *buf++ = '.';
        *buf++ = '.';
        *buf++ = '.';
    }

#if (NGX_WIN32)
    buf = ngx_slprintf(buf, last, ((unsigned) err < 0x80000000)
                                       ? " (%d: " : " (%Xd: ", err);
#else
    buf = ngx_slprintf(buf, last, " (%d: ", err);
#endif

    buf = ngx_strerror(err, buf, last - buf);

    if (buf < last) {
        *buf++ = ')';
    }

    return buf;
}


ngx_log_t *
ngx_log_init(u_char *prefix)
{
    u_char  *p, *name;
    size_t   nlen, plen;

    ngx_log.file = &ngx_log_file;
    ngx_log.log_level = NGX_LOG_NOTICE;

    name = (u_char *) NGX_ERROR_LOG_PATH;

    /*
     * we use ngx_strlen() here since BCC warns about
     * condition is always false and unreachable code
     */

    nlen = ngx_strlen(name);

    if (nlen == 0) {
        ngx_log_file.fd = ngx_stderr;
        return &ngx_log;
    }

    p = NULL;

#if (NGX_WIN32)
    if (name[1] != ':') {
#else
    if (name[0] != '/') {
#endif

        if (prefix) {
            plen = ngx_strlen(prefix);

        } else {
#ifdef NGX_PREFIX
            prefix = (u_char *) NGX_PREFIX;
            plen = ngx_strlen(prefix);
#else
            plen = 0;
#endif
        }

        if (plen) {
            name = malloc(plen + nlen + 2);
            if (name == NULL) {
                return NULL;
            }

            p = ngx_cpymem(name, prefix, plen);

            if (!ngx_path_separator(*(p - 1))) {
                *p++ = '/';
            }

            ngx_cpystrn(p, (u_char *) NGX_ERROR_LOG_PATH, nlen + 1);

            p = name;
        }
    }

    ngx_log_file.fd = ngx_open_file(name, NGX_FILE_APPEND,
                                    NGX_FILE_CREATE_OR_OPEN,
                                    NGX_FILE_DEFAULT_ACCESS);

    if (ngx_log_file.fd == NGX_INVALID_FILE) {
        ngx_log_stderr(ngx_errno,
                       "[alert] could not open error log file: "
                       ngx_open_file_n " \"%s\" failed", name);
#if (NGX_WIN32)
        ngx_event_log(ngx_errno,
                       "could not open error log file: "
                       ngx_open_file_n " \"%s\" failed", name);
#endif

        ngx_log_file.fd = ngx_stderr;
    }

    if (p) {
        ngx_free(p);
    }

    return &ngx_log;
}


ngx_int_t
ngx_log_open_default(ngx_cycle_t *cycle)
{
    ngx_log_t         *log;
    static ngx_str_t   error_log = ngx_string(NGX_ERROR_LOG_PATH);

    if (ngx_log_get_file_log(&cycle->new_log) != NULL) {
        return NGX_OK;
    }

    if (cycle->new_log.log_level != 0) {
        /* there are some error logs, but no files */

        log = ngx_pcalloc(cycle->pool, sizeof(ngx_log_t));
        if (log == NULL) {
            return NGX_ERROR;
        }

        log->log_level = NGX_LOG_ERR;
        ngx_log_insert(&cycle->new_log, log);

    } else {
        /* no error logs at all */
        log = &cycle->new_log;
        log->log_level = NGX_LOG_ERR;
    }

    log->file = ngx_conf_open_file(cycle, &error_log);
    if (log->file == NULL) {
        return NGX_ERROR;
    }

    return NGX_OK;
}


ngx_int_t
ngx_log_redirect_stderr(ngx_cycle_t *cycle)
{
    ngx_fd_t  fd;

    if (cycle->log_use_stderr) {
        return NGX_OK;
    }

    /* file log always exists when we are called */
    fd = ngx_log_get_file_log(cycle->log)->file->fd;

    if (fd != ngx_stderr) {
        if (ngx_set_stderr(fd) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          ngx_set_stderr_n " failed");

            return NGX_ERROR;
        }
    }

    return NGX_OK;
}


ngx_log_t *
ngx_log_get_file_log(ngx_log_t *head)
{
    ngx_log_t  *log;

    for (log = head; log; log = log->next) {
        if (log->file != NULL) {
            return log;
        }
    }

    return NULL;
}


static char *
ngx_log_set_levels(ngx_conf_t *cf, ngx_log_t *log)
{
    ngx_uint_t   i, n, d, found;
    ngx_str_t   *value;

    if (cf->args->nelts == 2) {
        log->log_level = NGX_LOG_ERR;
        return NGX_CONF_OK;
    }

    value = cf->args->elts;

    for (i = 2; i < cf->args->nelts; i++) {
        found = 0;

        for (n = 1; n <= NGX_LOG_DEBUG; n++) {
            if (ngx_strcmp(value[i].data, err_levels[n].data) == 0) {

                if (log->log_level != 0) {
                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                       "duplicate log level \"%V\"",
                                       &value[i]);
                    return NGX_CONF_ERROR;
                }

                log->log_level = n;
                found = 1;
                break;
            }
        }

        for (n = 0, d = NGX_LOG_DEBUG_FIRST; d <= NGX_LOG_DEBUG_LAST; d <<= 1) {
            if (ngx_strcmp(value[i].data, debug_levels[n++]) == 0) {
                if (log->log_level & ~NGX_LOG_DEBUG_ALL) {
                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                       "invalid log level \"%V\"",
                                       &value[i]);
                    return NGX_CONF_ERROR;
                }

                log->log_level |= d;
                found = 1;
                break;
            }
        }


        if (!found) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               "invalid log level \"%V\"", &value[i]);
            return NGX_CONF_ERROR;
        }
    }

    if (log->log_level == NGX_LOG_DEBUG) {
        log->log_level = NGX_LOG_DEBUG_ALL;
    }

    return NGX_CONF_OK;
}


static char *
ngx_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_log_t  *dummy;

    dummy = &cf->cycle->new_log;

    return ngx_log_set_log(cf, &dummy);
}


char *
ngx_log_set_log(ngx_conf_t *cf, ngx_log_t **head)
{
    ngx_log_t          *new_log;
    ngx_str_t          *value, name;
    ngx_syslog_peer_t  *peer;

    if (*head != NULL && (*head)->log_level == 0) {
        new_log = *head;

    } else {

        new_log = ngx_pcalloc(cf->pool, sizeof(ngx_log_t));
        if (new_log == NULL) {
            return NGX_CONF_ERROR;
        }

        if (*head == NULL) {
            *head = new_log;
        }
    }

    value = cf->args->elts;

    if (ngx_strcmp(value[1].data, "stderr") == 0) {
        ngx_str_null(&name);
        cf->cycle->log_use_stderr = 1;

        new_log->file = ngx_conf_open_file(cf->cycle, &name);
        if (new_log->file == NULL) {
            return NGX_CONF_ERROR;
        }


     } else if (ngx_strncmp(value[1].data, "syslog:", 7) == 0) {
        peer = ngx_pcalloc(cf->pool, sizeof(ngx_syslog_peer_t));
        if (peer == NULL) {
            return NGX_CONF_ERROR;
        }

        if (ngx_syslog_process_conf(cf, peer) != NGX_CONF_OK) {
            return NGX_CONF_ERROR;
        }

        new_log->writer = ngx_syslog_writer;
        new_log->wdata = peer;

    } else {
        new_log->file = ngx_conf_open_file(cf->cycle, &value[1]);
        if (new_log->file == NULL) {
            return NGX_CONF_ERROR;
        }
    }

    if (ngx_log_set_levels(cf, new_log) != NGX_CONF_OK) {
        return NGX_CONF_ERROR;
    }

    if (*head != new_log) {
        ngx_log_insert(*head, new_log);
    }

    return NGX_CONF_OK;
}


static void
ngx_log_insert(ngx_log_t *log, ngx_log_t *new_log)
{
    ngx_log_t  tmp;

    if (new_log->log_level > log->log_level) {

        /*
         * list head address is permanent, insert new log after
         * head and swap its contents with head
         */

        tmp = *log;
        *log = *new_log;
        *new_log = tmp;

        log->next = new_log;
        return;
    }

    while (log->next) {
        if (new_log->log_level > log->next->log_level) {
            new_log->next = log->next;
            log->next = new_log;
            return;
        }

        log = log->next;
    }

    log->next = new_log;
}
@


1.9
log
@update to 1.6.0 with official syslog support backported from the 1.7 branch

tested by several, ok sthen@@
@
text
@@


1.8
log
@re-add a build fix for vax that was overwritten by the update
@
text
@d13 2
a14 9
#if (NGX_ENABLE_SYSLOG)
static char *ngx_set_syslog(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
void log_exit(ngx_cycle_t *cycle);

typedef struct{
    ngx_str_t     name;
    ngx_int_t     macro;
} ngx_string_to_macro_t;
#endif
a25 9
#if (NGX_ENABLE_SYSLOG)
    {ngx_string("syslog"),
     NGX_MAIN_CONF|NGX_CONF_TAKE12,
     ngx_set_syslog,
     0,
     0,
     NULL},
#endif

d48 1
a48 5
#if (NGX_ENABLE_SYSLOG)
    log_exit,                              /* exit master */
#else
    NULL,
#endif
a56 42
#if (NGX_ENABLE_SYSLOG)
static ngx_string_to_macro_t ngx_syslog_facilities[] = {
    {ngx_string("auth"),     LOG_AUTH},
#if !(NGX_SOLARIS)
    {ngx_string("authpriv"), LOG_AUTHPRIV},
#endif
    {ngx_string("cron"),     LOG_CRON},
    {ngx_string("daemon"),   LOG_DAEMON},
#if !(NGX_SOLARIS)
    {ngx_string("ftp"),      LOG_FTP},
#endif
    {ngx_string("kern"),     LOG_KERN},
    {ngx_string("local0"),   LOG_LOCAL0},
    {ngx_string("local1"),   LOG_LOCAL1},
    {ngx_string("local2"),   LOG_LOCAL2},
    {ngx_string("local3"),   LOG_LOCAL3},
    {ngx_string("local4"),   LOG_LOCAL4},
    {ngx_string("local5"),   LOG_LOCAL5},
    {ngx_string("local6"),   LOG_LOCAL6},
    {ngx_string("local7"),   LOG_LOCAL7},
    {ngx_string("lpr"),      LOG_LPR},
    {ngx_string("mail"),     LOG_MAIL},
    {ngx_string("news"),     LOG_NEWS},
    {ngx_string("syslog"),   LOG_SYSLOG},
    {ngx_string("user"),     LOG_USER},
    {ngx_string("uucp"),     LOG_UUCP},
    { ngx_null_string, 0}
};

static ngx_string_to_macro_t ngx_syslog_priorities[] = {
    {ngx_string("emerg"), LOG_EMERG},
    {ngx_string("alert"), LOG_ALERT},
    {ngx_string("crit"),  LOG_CRIT},
    {ngx_string("error"), LOG_ERR},
    {ngx_string("err"),   LOG_ERR},
    {ngx_string("warn"),  LOG_WARNING},
    {ngx_string("notice"),LOG_NOTICE},
    {ngx_string("info"),  LOG_INFO},
    {ngx_string("debug"), LOG_DEBUG},
    { ngx_null_string, 0}
};
#endif
d91 1
a91 12
    va_list  args;
#endif
    u_char  *p, *last, *msg;
#if (NGX_ENABLE_SYSLOG)
    u_char *errstr_syslog;
#endif
    u_char   errstr[NGX_MAX_ERROR_STR];

#if !(NGX_ENABLE_SYSLOG)
    if (log->file->fd == NGX_INVALID_FILE) {
        return;
    }
d93 3
a103 4
#if (NGX_ENABLE_SYSLOG)
    errstr_syslog = p;
#endif

d142 20
a161 4
#if (NGX_ENABLE_SYSLOG)
    if (log->file != NULL && log->file->name.len != 0) {
    (void) ngx_write_fd(log->file->fd, errstr, p - errstr);
    }
d163 1
a163 4
    /* Don't send the debug level info to syslog */
    if (log->syslog_on && level < NGX_LOG_DEBUG) {
        /* write to syslog */
        syslog(log->priority, "%.*s", (int)(p - errstr_syslog), errstr_syslog);
a164 3
#else
    (void) ngx_write_fd(log->file->fd, errstr, p - errstr);
#endif
d168 1
a168 5
#if (NGX_ENABLE_SYSLOG)
        || (log->file != NULL && log->file->fd == ngx_stderr))
#else
        || log->file->fd == ngx_stderr)
#endif
d372 2
a373 2
ngx_log_t *
ngx_log_create(ngx_cycle_t *cycle, ngx_str_t *name)
d375 17
a391 1
    ngx_log_t  *log;
d393 4
a396 3
    log = ngx_pcalloc(cycle->pool, sizeof(ngx_log_t));
    if (log == NULL) {
        return NULL;
d399 1
a399 1
    log->file = ngx_conf_open_file(cycle, name);
d401 1
a401 1
        return NULL;
d404 1
a404 1
    return log;
a407 1
#if (NGX_ENABLE_SYSLOG)
d409 1
a409 1
ngx_log_get_priority(ngx_conf_t *cf, ngx_str_t *priority)
d411 1
a411 2
    ngx_int_t  p = 0;
    ngx_uint_t n, match = 0;
d413 2
a414 6
    for (n = 0; ngx_syslog_priorities[n].name.len != 0; n++) {
        if (ngx_strncmp(priority->data, ngx_syslog_priorities[n].name.data, 
                    ngx_syslog_priorities[n].name.len) == 0) {
            p = ngx_syslog_priorities[n].macro;
            match = 1;
        }
d417 10
a426 4
    if (!match) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                "invalid syslog priority \"%V\"", priority);
        return -1;
d429 1
a429 1
    return p;
d433 2
a434 2
char *
ngx_log_set_priority(ngx_conf_t *cf, ngx_str_t *priority, ngx_log_t *log)
d436 1
a436 1
    log->priority = ERR_SYSLOG_PRIORITY;
d438 4
a441 2
    if (priority->len == 0) {
        return NGX_CONF_OK;
d444 1
a444 6
    log->priority = ngx_log_get_priority(cf, priority);
    if (log->priority == (-1)) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
a445 1
#endif
d448 1
a448 1
char *
d454 5
d514 19
a532 4
    ngx_str_t  *value, name;
#if (NGX_ENABLE_SYSLOG)
    u_char     *off = NULL;
    ngx_str_t  priority;
d534 4
a537 3
    ngx_str_null(&name);
    ngx_str_null(&priority);
#endif
d539 3
a541 2
    if (cf->cycle->new_log.file) {
        return "is duplicate";
d546 6
a551 5
#if (NGX_ENABLE_SYSLOG)
    if (ngx_strncmp(value[1].data, "syslog", sizeof("syslog") - 1) == 0) {
        if (!cf->cycle->new_log.syslog_set) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                    "You must set the syslog directive and enable it first.");
a554 1
        cf->cycle->new_log.syslog_on = 1;
d556 4
a559 18
        if (value[1].data[sizeof("syslog") - 1] == ':') {
            priority.len = value[1].len - sizeof("syslog");
            priority.data = value[1].data + sizeof("syslog");

            off = (u_char *)ngx_strchr(priority.data, (int) '|');
            if (off != NULL) {
                priority.len = off - priority.data;

                off++;
                name.len = value[1].data + value[1].len - off;
                name.data = off;
            }
        }
        else {
            if (value[1].len > sizeof("syslog")) {
                name.len = value[1].len - sizeof("syslog");
                name.data = value[1].data + sizeof("syslog");
            }
d562 1
a562 1
        if (ngx_log_set_priority(cf, &priority, &cf->cycle->new_log) == NGX_CONF_ERROR) {
d565 3
a567 6
    }
    else if (ngx_strcmp(value[1].data, "stderr") == 0) {
#else
    if (ngx_strcmp(value[1].data, "stderr") == 0) {
#endif
        ngx_str_null(&name);
d570 4
a573 1
        name = value[1];
d576 2
a577 3
    cf->cycle->new_log.file = ngx_conf_open_file(cf->cycle, &name);
    if (cf->cycle->new_log.file == NULL) {
        return NULL;
d580 2
a581 3
    if (cf->args->nelts == 2) {
        cf->cycle->new_log.log_level = NGX_LOG_ERR;
        return NGX_CONF_OK;
d584 1
a584 3
    cf->cycle->new_log.log_level = 0;

    return ngx_log_set_levels(cf, &cf->cycle->new_log);
d588 4
a591 1
#if (NGX_ENABLE_SYSLOG)
d593 1
a593 1
#define SYSLOG_IDENT_NAME "nginx"
d595 4
a598 7
static char *
ngx_set_syslog(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char       *program;
    ngx_str_t  *value;
    ngx_int_t   facility = SYSLOG_FACILITY, match = 0;
    ngx_uint_t  n;
d600 3
a602 1
    value = cf->args->elts;
d604 2
a605 2
    if (cf->cycle->new_log.syslog_set) {
        return "is duplicate";
d608 5
a612 8
    cf->cycle->new_log.syslog_set = 1;

    for (n = 0; ngx_syslog_facilities[n].name.len != 0; n++) {
        if (ngx_strncmp(value[1].data, ngx_syslog_facilities[n].name.data, 
                    ngx_syslog_facilities[n].name.len) == 0) {
            facility = ngx_syslog_facilities[n].macro;
            match = 1;
            break;
a613 11
    }

    if (match) {
        cf->cycle->new_log.facility = facility;
        cf->cycle->new_log.priority = ERR_SYSLOG_PRIORITY;
    }
    else {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                "invalid syslog facility \"%V\"", &value[1]);
        return NGX_CONF_ERROR;
    }
d615 1
a615 3
    program = SYSLOG_IDENT_NAME; 
    if (cf->args->nelts > 2) {
        program = (char *) value[2].data;
d618 1
a618 3
    openlog(program, LOG_ODELAY, facility);

    return NGX_CONF_OK;
a619 10


void log_exit(ngx_cycle_t *cycle)
{
    if (cycle->new_log.syslog_set) {
        closelog();
    }
}
#endif

@


1.7
log
@update to 1.2.7
@
text
@d648 1
a648 1
    ngx_int_t   facility, match = 0;
@


1.6
log
@use the default SYSLOG_FACILITY definition which is LOCAL5
noted by ajacoutot@@
@
text
@d218 1
a218 1
        (void) ngx_write_fd(log->file->fd, errstr, p - errstr);
d467 1
a467 1
        if (ngx_strncmp(priority->data, ngx_syslog_priorities[n].name.data,
d648 1
a648 1
    ngx_int_t   facility = SYSLOG_FACILITY, match = 0;
d660 1
a660 1
        if (ngx_strncmp(value[1].data, ngx_syslog_facilities[n].name.data,
d678 1
a678 1
    program = SYSLOG_IDENT_NAME;
@


1.5
log
@unbreak build on vax by initializing a variable
@
text
@d648 1
a648 1
    ngx_int_t   facility = LOG_LOCAL6, match = 0;
@


1.4
log
@add syslog support to nginx
@
text
@d457 1
a457 1
 
d467 1
a467 1
        if (ngx_strncmp(priority->data, ngx_syslog_priorities[n].name.data, 
d648 1
a648 1
    ngx_int_t   facility, match = 0;
d660 1
a660 1
        if (ngx_strncmp(value[1].data, ngx_syslog_facilities[n].name.data, 
d678 1
a678 1
    program = SYSLOG_IDENT_NAME; 
@


1.3
log
@update to 1.0.12
@
text
@d13 9
d33 9
d64 5
a68 1
    NULL,                                  /* exit master */
d77 42
d156 3
d161 1
d165 1
d174 4
d216 11
d228 1
d232 3
d236 1
d457 44
d565 7
d579 36
d616 1
d637 60
@


1.2
log
@update to 1.0.9
@
text
@d4 1
@


1.1
log
@thank you CVS for missing the "core" directory
@
text
@d372 1
a372 1
    ngx_uint_t   i, n, d;
d378 1
d391 2
a392 1
                continue;
d406 2
d412 1
a412 1
        if (log->log_level == 0) {
@

