head	1.4;
access;
symbols
	OPENBSD_5_6:1.3.0.12
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.10
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2;
locks; strict;
comment	@ * @;


1.4
date	2014.08.26.19.35.33;	author robert;	state dead;
branches;
next	1.3;
commitid	sO1mMs3aGJWmnMM1;

1.3
date	2012.02.18.11.20.21;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.12.11.09.00;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.22.23.38.25;	author robert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove nginx from the base system in favor of OpenBSD's own httpd(8)
@
text
@
/*
 * Copyright (C) Igor Sysoev
 * Copyright (C) Nginx, Inc.
 */


#include <ngx_config.h>
#include <ngx_core.h>


ssize_t
ngx_parse_size(ngx_str_t *line)
{
    u_char     unit;
    size_t     len;
    ssize_t    size;
    ngx_int_t  scale;

    len = line->len;
    unit = line->data[len - 1];

    switch (unit) {
    case 'K':
    case 'k':
        len--;
        scale = 1024;
        break;

    case 'M':
    case 'm':
        len--;
        scale = 1024 * 1024;
        break;

    default:
        scale = 1;
    }

    size = ngx_atosz(line->data, len);
    if (size == NGX_ERROR) {
        return NGX_ERROR;
    }

    size *= scale;

    return size;
}


off_t
ngx_parse_offset(ngx_str_t *line)
{
    u_char     unit;
    off_t      offset;
    size_t     len;
    ngx_int_t  scale;

    len = line->len;
    unit = line->data[len - 1];

    switch (unit) {
    case 'K':
    case 'k':
        len--;
        scale = 1024;
        break;

    case 'M':
    case 'm':
        len--;
        scale = 1024 * 1024;
        break;

    case 'G':
    case 'g':
        len--;
        scale = 1024 * 1024 * 1024;
        break;

    default:
        scale = 1;
    }

    offset = ngx_atoof(line->data, len);
    if (offset == NGX_ERROR) {
        return NGX_ERROR;
    }

    offset *= scale;

    return offset;
}


ngx_int_t
ngx_parse_time(ngx_str_t *line, ngx_uint_t is_sec)
{
    u_char      *p, *last;
    ngx_int_t    value, total, scale;
    ngx_uint_t   max, valid;
    enum {
        st_start = 0,
        st_year,
        st_month,
        st_week,
        st_day,
        st_hour,
        st_min,
        st_sec,
        st_msec,
        st_last
    } step;

    valid = 0;
    value = 0;
    total = 0;
    step = is_sec ? st_start : st_month;
    scale = is_sec ? 1 : 1000;

    p = line->data;
    last = p + line->len;

    while (p < last) {

        if (*p >= '0' && *p <= '9') {
            value = value * 10 + (*p++ - '0');
            valid = 1;
            continue;
        }

        switch (*p++) {

        case 'y':
            if (step > st_start) {
                return NGX_ERROR;
            }
            step = st_year;
            max = NGX_MAX_INT32_VALUE / (60 * 60 * 24 * 365);
            scale = 60 * 60 * 24 * 365;
            break;

        case 'M':
            if (step >= st_month) {
                return NGX_ERROR;
            }
            step = st_month;
            max = NGX_MAX_INT32_VALUE / (60 * 60 * 24 * 30);
            scale = 60 * 60 * 24 * 30;
            break;

        case 'w':
            if (step >= st_week) {
                return NGX_ERROR;
            }
            step = st_week;
            max = NGX_MAX_INT32_VALUE / (60 * 60 * 24 * 7);
            scale = 60 * 60 * 24 * 7;
            break;

        case 'd':
            if (step >= st_day) {
                return NGX_ERROR;
            }
            step = st_day;
            max = NGX_MAX_INT32_VALUE / (60 * 60 * 24);
            scale = 60 * 60 * 24;
            break;

        case 'h':
            if (step >= st_hour) {
                return NGX_ERROR;
            }
            step = st_hour;
            max = NGX_MAX_INT32_VALUE / (60 * 60);
            scale = 60 * 60;
            break;

        case 'm':
            if (*p == 's') {
                if (is_sec || step >= st_msec) {
                    return NGX_ERROR;
                }
                p++;
                step = st_msec;
                max = NGX_MAX_INT32_VALUE;
                scale = 1;
                break;
            }

            if (step >= st_min) {
                return NGX_ERROR;
            }
            step = st_min;
            max = NGX_MAX_INT32_VALUE / 60;
            scale = 60;
            break;

        case 's':
            if (step >= st_sec) {
                return NGX_ERROR;
            }
            step = st_sec;
            max = NGX_MAX_INT32_VALUE;
            scale = 1;
            break;

        case ' ':
            if (step >= st_sec) {
                return NGX_ERROR;
            }
            step = st_last;
            max = NGX_MAX_INT32_VALUE;
            scale = 1;
            break;

        default:
            return NGX_ERROR;
        }

        if (step != st_msec && !is_sec) {
            scale *= 1000;
            max /= 1000;
        }

        if ((ngx_uint_t) value > max) {
            return NGX_ERROR;
        }

        total += value * scale;

        if ((ngx_uint_t) total > NGX_MAX_INT32_VALUE) {
            return NGX_ERROR;
        }

        value = 0;
        scale = is_sec ? 1 : 1000;

        while (p < last && *p == ' ') {
            p++;
        }
    }

    if (valid) {
        return total + value * scale;
    }

    return NGX_ERROR;
}
@


1.3
log
@update to 1.0.12
@
text
@@


1.2
log
@update to 1.0.9
@
text
@d4 1
@


1.1
log
@thank you CVS for missing the "core" directory
@
text
@d96 1
a96 1
ngx_parse_time(ngx_str_t *line, ngx_uint_t sec)
d117 2
a118 2
    step = sec ? st_start : st_month;
    scale = sec ? 1 : 1000;
d138 1
a138 1
            max = 68;
d143 1
a143 1
            if (step > st_year) {
d147 1
a147 1
            max = 828;
d152 1
a152 1
            if (step > st_month) {
d156 1
a156 1
            max = 3550;
d161 1
a161 1
            if (step > st_week) {
d165 1
a165 1
            max = 24855;
d170 1
a170 1
            if (step > st_day) {
d174 1
a174 1
            max = 596523;
d180 1
a180 1
                if (sec || step > st_sec) {
d185 1
a185 1
                max = 2147483647;
d190 1
a190 1
            if (step > st_hour) {
d194 1
a194 1
            max = 35791394;
d199 1
a199 1
            if (step > st_min) {
d203 1
a203 1
            max = 2147483647;
d208 1
a208 1
            if (step > st_min) {
d212 1
a212 1
            max = 2147483647;
d220 1
a220 1
        if (step != st_msec && !sec) {
d231 1
a231 1
        if ((ngx_uint_t) total > 2147483647) {
d236 1
a236 1
        scale = sec ? 1 : 1000;
@

