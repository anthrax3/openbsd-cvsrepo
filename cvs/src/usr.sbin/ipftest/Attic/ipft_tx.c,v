head	1.20;
access;
symbols
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_8:1.16.0.4
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.20
date	2001.05.30.02.12.43;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2001.01.30.04.31.02;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.17.07.26.58;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.17.06.01.22;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.13.23.40.20;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.16.22.34.24;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.01.19.30.01;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	99.12.15.05.20.26;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	99.02.05.05.58.46;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.09.15.10.05.51;	author pattonme;	state Exp;
branches;
next	1.10;

1.10
date	98.01.26.04.16.38;	author dgregor;	state Exp;
branches;
next	1.9;

1.9
date	97.06.23.01.37.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.26.14.59.30;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.02.26.14.58.34;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.02.11.22.23.55;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.17.07.14.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.18.04.59.24;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.21.40.26;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.25.05.41.35;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.02.34.27;	author dm;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ipft_tx.c,v 1.19 2001/01/30 04:31:02 kjell Exp $	*/

/*
 * Copyright (C) 1995-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#include <stdio.h>
#include <ctype.h>
#include <assert.h>
#include <string.h>
#include <sys/types.h>
#if !defined(__SVR4) && !defined(__svr4__)
#include <strings.h>
#else
#include <sys/byteorder.h>
#endif
#include <sys/param.h>
#include <sys/time.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#ifndef	linux
#include <netinet/ip_var.h>
#endif
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <netinet/ip_icmp.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <netdb.h>
#include <arpa/nameser.h>
#include <resolv.h>
#include <netinet/ip_fil_compat.h>
#include <netinet/tcpip.h>
#include "ipf.h"
#include "ipt.h"

#if !defined(lint)
static const char sccsid[] = "@@(#)ipft_tx.c	1.7 6/5/96 (C) 1993 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ipft_tx.c,v 2.3.2.1 2001/01/10 06:19:53 darrenr Exp $";
#endif

extern	int	opts;

static	char	*tx_proto = "";

static	int	text_open __P((char *)), text_close __P((void));
static	int	text_readip __P((char *, int, char **, int *));
static	int	parseline __P((char *, ip_t *, char **, int *));

static	char	_tcp_flagset[] = "FSRPAUEC";
static	u_char	_tcp_flags[] = { TH_FIN, TH_SYN, TH_RST, TH_PUSH,
				TH_ACK, TH_URG, TH_ECN, TH_CWR };

struct	ipread	iptext = { text_open, text_close, text_readip };
static	FILE	*tfp = NULL;
static	int	tfd = -1;

static	u_32_t	tx_hostnum __P((char *, int *));
static	u_short	tx_portnum __P((char *));


/*
 * returns an ip address as a long var as a result of either a DNS lookup or
 * straight inet_addr() call
 */
static	u_32_t	tx_hostnum(host, resolved)
char	*host;
int	*resolved;
{
	struct	hostent	*hp;
	struct	netent	*np;

	*resolved = 0;
	if (!strcasecmp("any",host))
		return 0L;
	if (isdigit(*host))
		return inet_addr(host);

	if (!(hp = gethostbyname(host))) {
		if (!(np = getnetbyname(host))) {
			*resolved = -1;
			fprintf(stderr, "can't resolve hostname: %s\n", host);
			return 0;
		}
		return htonl(np->n_net);
	}
	return *(u_32_t *)hp->h_addr;
}


/*
 * find the port number given by the name, either from getservbyname() or
 * straight atoi()
 */
static	u_short	tx_portnum(name)
char	*name;
{
	struct	servent	*sp, *sp2;
	u_short	p1 = 0;

	if (isdigit(*name))
		return (u_short)atoi(name);
	if (!tx_proto)
		tx_proto = "tcp/udp";
	if (strcasecmp(tx_proto, "tcp/udp")) {
		sp = getservbyname(name, tx_proto);
		if (sp)
			return ntohs(sp->s_port);
		(void) fprintf(stderr, "unknown service \"%s\".\n", name);
		return 0;
	}
	sp = getservbyname(name, "tcp");
	if (sp)
		p1 = sp->s_port;
	sp2 = getservbyname(name, "udp");
	if (!sp || !sp2) {
		(void) fprintf(stderr, "unknown tcp/udp service \"%s\".\n",
			name);
		return 0;
	}
	if (p1 != sp2->s_port) {
		(void) fprintf(stderr, "%s %d/tcp is a different port to ",
			name, p1);
		(void) fprintf(stderr, "%s %d/udp\n", name, sp->s_port);
		return 0;
	}
	return ntohs(p1);
}


char	*tx_icmptypes[] = {
	"echorep", (char *)NULL, (char *)NULL, "unreach", "squench",
	"redir", (char *)NULL, (char *)NULL, "echo", "routerad",
	"routersol", "timex", "paramprob", "timest", "timestrep",
	"inforeq", "inforep", "maskreq", "maskrep", "END"
};

static	int	text_open(fname)
char	*fname;
{
	if (tfp && tfd != -1) {
		rewind(tfp);
		return tfd;
	}

	if (!strcmp(fname, "-")) {
		tfd = 0;
		tfp = stdin;
	} else {
		tfd = open(fname, O_RDONLY);
		if (tfd != -1)
			tfp = fdopen(tfd, "r");
	}
	return tfd;
}


static	int	text_close()
{
	int	cfd = tfd;

	tfd = -1;
	return close(cfd);
}


static	int	text_readip(buf, cnt, ifn, dir)
char	*buf, **ifn;
int	cnt, *dir;
{
	register char *s;
	ip_t *ip;
	char	line[513];

 	ip = (ip_t *)buf;
	*ifn = NULL;
	while (fgets(line, sizeof(line)-1, tfp)) {
		if ((s = index(line, '\n')))
			*s = '\0';
		if ((s = index(line, '\r')))
			*s = '\0';
		if ((s = index(line, '#')))
			*s = '\0';
		if (!*line)
			continue;
		if (!(opts & OPT_BRIEF))
			printf("input: %s\n", line);
		*ifn = NULL;
		*dir = 0;
		if (!parseline(line, (ip_t *)buf, ifn, dir))
#if 0
			return sizeof(*ip) + sizeof(tcphdr_t);
#else
			return sizeof(ip_t);
#endif
	}
	return -1;
}

static	int	parseline(line, ip, ifn, out)
char	*line;
ip_t	*ip;
char	**ifn;
int	*out;
{
	tcphdr_t	th, *tcp = &th;
	struct	icmp	icmp, *ic = &icmp;
	char	*cps[20], **cpp, c, ipopts[68];
	int	i, r;

	if (*ifn)
		free(*ifn);
	bzero((char *)ip, MAX(sizeof(*tcp), sizeof(*ic)) + sizeof(*ip));
	bzero((char *)tcp, sizeof(*tcp));
	bzero((char *)ic, sizeof(*ic));
	bzero(ipopts, sizeof(ipopts));
	ip->ip_hl = sizeof(*ip) >> 2;
	ip->ip_v = IPVERSION;
	for (i = 0, cps[0] = strtok(line, " \b\t\r\n"); cps[i] && i < 19; )
		cps[++i] = strtok(NULL, " \b\t\r\n");
	if (i < 2)
		return 1;

	cpp = cps;

	c = **cpp;
	if (!isalpha(c) || (tolower(c) != 'o' && tolower(c) != 'i')) {
		fprintf(stderr, "bad direction \"%s\"\n", *cpp);
		return 1;
	}
	*out = (tolower(c) == 'o') ? 1 : 0;
	cpp++;

	if (!strcasecmp(*cpp, "on")) {
		cpp++;
		if (!*cpp)
			return 1;
		*ifn = strdup(*cpp++);
	}

	c = **cpp;
	ip->ip_len = sizeof(ip_t);
	if (!strcasecmp(*cpp, "tcp") || !strcasecmp(*cpp, "udp") ||
	    !strcasecmp(*cpp, "icmp")) {
		if (c == 't') {
			ip->ip_p = IPPROTO_TCP;
			ip->ip_len += sizeof(struct tcphdr);
			tx_proto = "tcp";
		} else if (c == 'u') {
			ip->ip_p = IPPROTO_UDP;
			ip->ip_len += sizeof(struct udphdr);
			tx_proto = "udp";
		} else {
			ip->ip_p = IPPROTO_ICMP;
			ip->ip_len += sizeof(struct icmp);
			tx_proto = "icmp";
		}
		cpp++;
	} else if (isdigit(**cpp) && !index(*cpp, '.')) {
		ip->ip_p = atoi(*cpp);
		cpp++;
	} else
		ip->ip_p = IPPROTO_IP;

	if (!*cpp)
		return 1;
	if (ip->ip_p == IPPROTO_TCP || ip->ip_p == IPPROTO_UDP) {
		char	*last;

		last = index(*cpp, ',');
		if (!last) {
			fprintf(stderr, "tcp/udp with no source port\n");
			return 1;
		}
		*last++ = '\0';
		tcp->th_sport = htons(tx_portnum(last));
	}
	ip->ip_src.s_addr = tx_hostnum(*cpp, &r);
	cpp++;
	if (!*cpp)
		return 1;

	if (ip->ip_p == IPPROTO_TCP || ip->ip_p == IPPROTO_UDP) {
		char	*last;

		last = index(*cpp, ',');
		if (!last) {
			fprintf(stderr, "tcp/udp with no destination port\n");
			return 1;
		}
		*last++ = '\0';
		tcp->th_dport = htons(tx_portnum(last));
	}
	ip->ip_dst.s_addr = tx_hostnum(*cpp, &r);
	cpp++;
	if (*cpp && ip->ip_p == IPPROTO_TCP) {
		extern	char	_tcp_flagset[];
		extern	u_char	_tcp_flags[];
		char	*s, *t;

		for (s = *cpp; *s; s++)
			if ((t  = index(_tcp_flagset, *s)))
				tcp->th_flags |= _tcp_flags[t - _tcp_flagset];
		if (tcp->th_flags)
			cpp++;
		assert(tcp->th_flags != 0);
		tcp->th_win = htons(4096);
		tcp->th_off = sizeof(*tcp) >> 2;
	} else if (*cpp && ip->ip_p == IPPROTO_ICMP) {
		extern	char	*tx_icmptypes[];
		char	**s, *t;
		int	i;

		for (s = tx_icmptypes, i = 0; !*s || strcmp(*s, "END");
		     s++, i++)
			if (*s && !strncasecmp(*cpp, *s, strlen(*s))) {
				ic->icmp_type = i;
				if ((t = index(*cpp, ',')))
					ic->icmp_code = atoi(t+1);
				cpp++;
				break;
			}
	}

	if (*cpp && !strcasecmp(*cpp, "opt")) {
		u_long	olen;

		cpp++;
		olen = buildopts(*cpp, ipopts, (ip->ip_hl - 5) << 2);
		if (olen) {
			bcopy(ipopts, (char *)(ip + 1), olen);
			ip->ip_hl += olen >> 2;
		}
	}
	if (ip->ip_p == IPPROTO_TCP || ip->ip_p == IPPROTO_UDP)
		bcopy((char *)tcp, ((char *)ip) + (ip->ip_hl << 2),
			sizeof(*tcp));
	else if (ip->ip_p == IPPROTO_ICMP)
		bcopy((char *)ic, ((char *)ip) + (ip->ip_hl << 2),
			sizeof(*ic));
	ip->ip_len = htons(ip->ip_len);
	return 0;
}
@


1.19
log
@reimplement whacked changes. ip_compat.h to ip_fil_compat.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ipft_tx.c,v 1.18 2001/01/17 07:26:58 fgsch Exp $	*/
@


1.18
log
@IPF 3.4.16 userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipft_tx.c,v 1.17 2001/01/17 06:01:22 fgsch Exp $	*/
d41 1
a41 1
#include <netinet/ip_compat.h>
@


1.17
log
@2nd part of the ipf code; need more testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
static const char rcsid[] = "@@(#)$IPFilter: ipft_tx.c,v 2.3 2000/03/13 22:10:24 darrenr Exp $";
d59 1
a59 1
static	char	_tcp_flagset[] = "FSRPAU";
d61 1
a61 1
				TH_ACK, TH_URG };
@


1.16
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d4 1
a4 1
 * Copyright (C) 1995-1998 by Darren Reed.
d41 1
a41 1
#include <netinet/ip_fil_compat.h>
d48 1
a48 1
static const char rcsid[] = "@@(#)$IPFilter: ipft_tx.c,v 2.1 1999/08/04 17:30:05 darrenr Exp $";
d59 2
a60 2
static	char	tcp_flagset[] = "FSRPAU";
static	u_char	tcp_flags[] = { TH_FIN, TH_SYN, TH_RST, TH_PUSH,
d306 2
a307 2
		extern	char	tcp_flagset[];
		extern	u_char	tcp_flags[];
d311 2
a312 2
			if ((t  = index(tcp_flagset, *s)))
				tcp->th_flags |= tcp_flags[t - tcp_flagset];
@


1.15
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@@


1.14
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.13
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d48 1
a48 1
static const char rcsid[] = "@@(#)$Id: ipft_tx.c,v 2.1 1999/08/04 17:30:05 darrenr Exp $";
@


1.12
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*    $OpenBSD: ipft_tx.c,v 1.11 1998/09/15 10:05:51 pattonme Exp $     */
d40 1
a40 5
#if defined(__OpenBSD__)
# include <netinet/ip_fil_compat.h>
#else
# include <netinet/ip_compat.h>
#endif
d47 1
a47 1
static const char rcsid[] = "@@(#)$Id: ipft_tx.c,v 1.11 1998/09/15 10:05:51 pattonme Exp $";
d200 1
a200 1
			return sizeof(struct tcpiphdr);
d267 3
d316 1
d349 1
@


1.11
log
@updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*    $OpenBSD: ipft_tx.c,v 1.10 1998/01/26 04:16:38 dgregor Exp $     */
d3 1
a3 1
 * Copyright (C) 1995-1997 by Darren Reed.
d51 1
a51 1
static const char rcsid[] = "@@(#)$Id$";
d316 1
@


1.10
log
@IPF 3.2.3
@
text
@d1 1
a1 1
/*    $OpenBSD$     */
d40 5
a44 1
#include "ip_fil_compat.h"
d51 1
a51 1
static const char rcsid[] = "@@(#)$Id: ipft_tx.c,v 2.0.2.11.2.1 1997/11/12 10:56:11 darrenr Exp $";
d70 1
a70 1
static	u_long	tx_hostnum __P((char *, int *));
d78 1
a78 1
static	u_long	tx_hostnum(host, resolved)
d97 1
a97 1
		return np->n_net;
@


1.9
log
@in_addr_t and in_port_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ipft_tx.c,v 1.8 1997/02/26 14:59:30 kstailey Exp $	*/
d3 1
a3 1
 * (C)opyright 1995 by Darren Reed.
d13 1
a18 1
#include <sys/types.h>
d20 1
d28 1
d30 1
a34 1
#include <netinet/tcpip.h>
d41 1
d45 3
a47 3
#if !defined(lint) && defined(LIBC_SCCS)
static	char	sccsid[] = "@@(#)ipft_tx.c	1.7 6/5/96 (C) 1993 Darren Reed";
static  char    rcsid[] = "$DRId: ipft_tx.c,v 2.0.1.3 1997/02/20 09:47:47 darrenr Exp $"
a50 1
extern	u_long	buildopts();
d54 3
a56 1
static	int	text_open(), text_close(), text_readip(), parseline();
d66 2
a67 2
static	in_addr_t	tx_hostnum();
static	in_port_t	tx_portnum();
d74 1
a74 1
static	in_addr_t	tx_hostnum(host, resolved)
d95 1
a95 1
	return *(in_addr_t *)hp->h_addr;
d103 1
a103 1
static	in_port_t	tx_portnum(name)
d141 2
a142 2
	"redir", (char *)NULL, (char *)NULL, "echo", (char *)NULL,
	(char *)NULL, "timex", "paramprob", "timest", "timestrep",
d180 1
a180 1
	struct	ip *ip;
d183 1
a183 1
 	ip = (struct ip *)buf;
d198 1
a198 1
		if (!parseline(line, buf, ifn, dir))
d202 1
a202 1
			return sizeof(struct ip);
d210 1
a210 1
struct	ip	*ip;
d250 1
a250 1
	ip->ip_len = sizeof(struct ip);
d332 1
a332 1
		olen = buildopts(*cpp, ipopts);
@


1.8
log
@add tag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 2
a63 2
static	u_long	tx_hostnum();
static	u_short	tx_portnum();
d70 1
a70 1
static	u_long	tx_hostnum(host, resolved)
d91 1
a91 1
	return *(u_long *)hp->h_addr;
d99 1
a99 1
static	u_short	tx_portnum(name)
@


1.7
log
@ipf 1.3.8 + patches
@
text
@d1 1
@


1.6
log
@IPF 1.3.7
@
text
@d43 1
a43 1
static	char	rcsid[] = "$Id: ipft_tx.c,v 2.0.1.2 1997/01/19 04:52:25 darrenr Exp $";
d214 2
d241 1
a241 1
		*ifn = *cpp++;
@


1.5
log
@r?index -> strr?chr
@
text
@d32 1
a33 1
#include "ip_fil_compat.h"
d37 1
d41 1
a41 1
#ifndef	lint
d43 1
a43 1
static	char	rcsid[] = "$Id: ipft_tx.c,v 1.4 1996/07/18 04:59:24 dm Exp $";
d69 1
a69 1
u_long	tx_hostnum(host, resolved)
d98 1
a98 1
u_short	tx_portnum(name)
d181 1
a181 1
		if ((s = strchr(line, '\n')))
d183 1
a183 1
		if ((s = strchr(line, '\r')))
d185 1
a185 1
		if ((s = strchr(line, '#')))
d268 1
a268 1
		last = strchr(*cpp, ',');
d284 1
a284 1
		last = strchr(*cpp, ',');
d300 1
a300 1
			if ((t  = strchr(tcp_flagset, *s)))
d314 1
a314 1
				if ((t = strchr(*cpp, ',')))
@


1.4
log
@ipfilter 3.1.0
@
text
@d42 1
a42 1
static	char	rcsid[] = "$Id: ipft_tx.c,v 1.1.1.1 1996/06/23 07:27:16 darrenr Exp $";
d180 1
a180 1
		if ((s = index(line, '\n')))
d182 1
a182 1
		if ((s = index(line, '\r')))
d184 1
a184 1
		if ((s = index(line, '#')))
d267 1
a267 1
		last = index(*cpp, ',');
d283 1
a283 1
		last = index(*cpp, ',');
d299 1
a299 1
			if ((t  = index(tcp_flagset, *s)))
d313 1
a313 1
				if ((t = index(*cpp, ',')))
@


1.3
log
@ipfilter 3.0.4
@
text
@d33 1
a36 1
#include "ip_fil.h"
d41 2
a42 1
static	char	sccsid[] = "@@(#)ipft_tx.c	1.6 2/4/96 (C) 1993 Darren Reed";
a45 1
extern	u_short	portnum();
d48 2
d52 4
d60 80
a207 1
	extern	char	*proto;
d210 1
a210 1
	char	*cps[20], **cpp, c, opts[68];
d216 1
a216 1
	bzero(opts, sizeof(opts));
d248 1
a248 1
			proto = "tcp";
d252 1
a252 1
			proto = "udp";
d256 1
a256 1
			proto = "icmp";
d273 1
a273 1
		tcp->th_sport = htons(portnum(last));
d275 1
a275 1
	ip->ip_src.s_addr = hostnum(*cpp, &r);
d289 1
a289 1
		tcp->th_dport = htons(portnum(last));
d291 1
a291 1
	ip->ip_dst.s_addr = hostnum(*cpp, &r);
d294 2
a295 2
		extern	char	flagset[];
		extern	u_char	flags[];
d299 2
a300 2
			if ((t  = index(flagset, *s)))
				tcp->th_flags |= flags[t - flagset];
d305 1
a305 1
		extern	char	*icmptypes[];
d309 2
a310 1
		for (s = icmptypes, i = 0; !*s || strcmp(*s, "END"); s++, i++)
d324 1
a324 1
		olen = buildopts(*cpp, opts);
d326 1
a326 1
			bcopy(opts, (char *)(ip + 1), olen);
@


1.2
log
@IP filter 3.0.1
@
text
@a32 1
#include "ip_fil.h"
d36 1
d41 1
a41 1
static	char	sccsid[] = "@@(#)ipft_tx.c	1.5 1/12/96 (C) 1993 Darren Reed";
d188 1
a188 1
		tcp->th_sport = portnum(last);
d204 1
a204 1
		tcp->th_dport = portnum(last);
@


1.1
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d9 1
d33 1
a33 1
#include <netinet/ip_fil.h>
d41 1
a41 1
static	char	sccsid[] = "@@(#)ipft_tx.c	1.2 10/17/95 (C) 1993 Darren Reed";
d45 2
d126 1
a126 1
	int	i;
d190 1
a190 1
	ip->ip_src.s_addr = hostnum(*cpp);
d206 1
a206 1
	ip->ip_dst.s_addr = hostnum(*cpp);
@
