head	1.4;
access;
symbols
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	GRAICHEN_961030:1.1.1.1
	GRAICHEN:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	99.12.02.04.00.57;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	99.07.13.23.02.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.01.15.23.44.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.10.30.17.32.59;	author graichen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.10.30.17.32.59;	author graichen;	state Exp;
branches;
next	;


desc
@@


1.4
log
@bye bye ctm (soon in ports tree)
@
text
@/* $OpenBSD: mkctm.c,v 1.3 1999/07/13 23:02:07 deraadt Exp $ */
/* Still missing:
 *
 * mkctm 
 *	-B regex	Bogus
 *	-I regex	Ignore
 *      -D int		Damage
 *	-q		decrease verbosity
 *	-v		increase verbosity
 *      -l file		logfile
 *	name		cvs-cur
 *	prefix		src/secure
 *	dir1		"Soll"
 *	dir2		"Ist"
 *
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <dirent.h>
#include <regex.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <md5.h>
#include <err.h>
#include <signal.h>

#define DEFAULT_IGNORE	"/CVS$|/\\.#|00_TRANS\\.TBL$"
#define DEFAULT_BOGUS	"\\.core$|\\.orig$|\\.rej$|\\.o$"
regex_t reg_ignore,  reg_bogus;
int	flag_ignore, flag_bogus;

int	verbose;
int	damage, damage_limit;
int	change;

FILE	*logf;

u_long s1_ignored,	s2_ignored;
u_long s1_bogus,	s2_bogus;
u_long s1_wrong,	s2_wrong;
u_long s_new_dirs,	s_new_files,	s_new_bytes;
u_long s_del_dirs,	s_del_files,	                s_del_bytes;
u_long 			s_files_chg,	s_bytes_add,	s_bytes_del;
u_long s_same_dirs,	s_same_files,	s_same_bytes;
u_long 			s_edit_files,	s_edit_bytes,	s_edit_saves;
u_long 			s_sub_files,	s_sub_bytes;

void
Usage(void)
{
	fprintf(stderr,
		"usage: mkctm [-options] name number timestamp prefix dir1 dir2\n");
	fprintf(stderr, "options:\n");
	fprintf(stderr, "\t\t-B bogus_regexp\n");
	fprintf(stderr, "\t\t-D damage_limit\n");
	fprintf(stderr, "\t\t-I ignore_regexp\n");
	fprintf(stderr, "\t\t-q\n");
	fprintf(stderr, "\t\t-v\n");
}

void
print_stat(FILE *fd, char *pre)
{
    fprintf(fd, "%sNames:\n", pre);
    fprintf(fd, "%s  ignore:  %5lu ref   %5lu target\n",
	    pre, s1_ignored, s2_ignored);
    fprintf(fd, "%s  bogus:   %5lu ref   %5lu target\n",
	    pre, s1_bogus, s2_bogus);
    fprintf(fd, "%s  wrong:   %5lu ref   %5lu target\n", 
	    pre, s1_wrong, s2_wrong);
    fprintf(fd, "%sDelta:\n", pre);
    fprintf(fd, "%s  new:     %5lu dirs  %5lu files  %9lu plus\n", 
	    pre, s_new_dirs, s_new_files, s_new_bytes);
    fprintf(fd, "%s  del:     %5lu dirs  %5lu files                   %9lu minus\n", 
	    pre, s_del_dirs, s_del_files, s_del_bytes);
    fprintf(fd, "%s  chg:                 %5lu files  %9lu plus   %9lu minus\n",
	    pre, s_files_chg, s_bytes_add, s_bytes_del);
    fprintf(fd, "%s  same:    %5lu dirs  %5lu files  %9lu bytes\n", 
	    pre, s_same_dirs, s_same_files, s_same_bytes);
    fprintf(fd, "%sMethod:\n", pre);
    fprintf(fd, "%s  edit:                %5lu files  %9lu bytes  %9lu saved\n", 
	    pre, s_edit_files, s_edit_bytes, s_edit_saves);
    fprintf(fd, "%s  sub:                 %5lu files  %9lu bytes\n", 
	    pre, s_sub_files, s_sub_bytes);

}

void
stat_info(int foo)
{
	signal(SIGINFO, stat_info);
	print_stat(stderr, "INFO: ");
}

void DoDir(const char *dir1, const char *dir2, const char *name);

static struct stat st;
static __inline struct stat *
StatFile(char *name)
{
	if (lstat(name, &st) < 0) 
		err(1, "couldn't stat %s", name);
	return &st;
}

int
dirselect(struct dirent *de)
{
	if (!strcmp(de->d_name, "."))	return 0;
	if (!strcmp(de->d_name, ".."))	return 0;
	return 1;
}

void
name_stat(const char *pfx, const char *dir, const char *name, struct dirent *de)
{
	char *buf = alloca(strlen(dir) + strlen(name) + 
		strlen(de->d_name) + 3);
	struct stat *st;

	strcpy(buf, dir);
		strcat(buf, "/"); strcat(buf, name);
		strcat(buf, "/"); strcat(buf, de->d_name);
	st = StatFile(buf);
	printf("%s %s%s %u %u %o",
	    pfx, name, de->d_name, 
	    st->st_uid, st->st_gid, st->st_mode & ~S_IFMT);
	fprintf(logf, "%s %s%s\n", pfx, name, de->d_name);
	if (verbose > 1) {
		fprintf(stderr, "%s %s%s\n", pfx, name, de->d_name);
	}
}

void
Equ(const char *dir1, const char *dir2, const char *name, struct dirent *de)
{
	if (de->d_type == DT_DIR) {
		char *p = alloca(strlen(name)+strlen(de->d_name)+2);

		strcpy(p, name);  strcat(p, de->d_name); strcat(p, "/");
		DoDir(dir1, dir2, p);
		s_same_dirs++;
	} else {
		char *buf1 = alloca(strlen(dir1) + strlen(name) + 
			strlen(de->d_name) + 3);
		char *buf2 = alloca(strlen(dir2) + strlen(name) + 
			strlen(de->d_name) + 3);
		char *m1, md5_1[33], *m2, md5_2[33];
		u_char *p1, *p2;
		int fd1, fd2;
		struct stat s1, s2;

		strcpy(buf1, dir1); 
			strcat(buf1, "/"); strcat(buf1, name);
			strcat(buf1, "/"); strcat(buf1, de->d_name);
		fd1 = open(buf1, O_RDONLY);
		if(fd1 < 0) { err(3, "%s", buf1); }
		fstat(fd1, &s1);
		strcpy(buf2, dir2); 
			strcat(buf2, "/"); strcat(buf2, name);
			strcat(buf2, "/"); strcat(buf2, de->d_name);
		fd2 = open(buf2, O_RDONLY);
		if(fd2 < 0) { err(3, "%s", buf2); }
		fstat(fd2, &s2);
#if 0
		/* XXX if we could just trust the size to change... */
		if (s1.st_size == s2.st_size) {
			s_same_files++;
			s_same_bytes += s1.st_size;
			close(fd1);
			close(fd2);
			goto finish;
		}
#endif
		p1=mmap(0, s1.st_size, PROT_READ, MAP_PRIVATE, fd1, 0);
		if (p1 == (u_char *)MAP_FAILED) { err(3, "%s", buf1); }
		close(fd1);

		p2=mmap(0, s2.st_size, PROT_READ, MAP_PRIVATE, fd2, 0);
		if (p2 == (u_char *)MAP_FAILED) { err(3, "%s", buf2); }
		close(fd2);

		/* If identical, we're done. */
		if((s1.st_size == s2.st_size) && !memcmp(p1, p2, s1.st_size)) {
			s_same_files++;
			s_same_bytes += s1.st_size;
			goto finish;
		}

		s_files_chg++;
		change++;
		if (s1.st_size > s2.st_size)
			s_bytes_del += (s1.st_size - s2.st_size);
		else
			s_bytes_add += (s2.st_size - s1.st_size);

		m1 = MD5Data(p1, s1.st_size, md5_1);
		m2 = MD5Data(p2, s2.st_size, md5_2);
		
		/* Just a curiosity... */
		if(!strcmp(m1, m2)) {
			if (s1.st_size != s2.st_size) 
				fprintf(stderr,
		"Notice: MD5 same for files of diffent size:\n\t%s\n\t%s\n",
					buf1, buf2);
			goto finish;
		}

		{
			u_long l = s2.st_size + 2;
			u_char *cmd = alloca(strlen(buf1)+strlen(buf2)+100);
			u_char *ob = alloca(l), *p;
			int j;
			FILE *F;
			
			if (s1.st_size && p1[s1.st_size-1] != '\n') {
				if (verbose > 0) 
					fprintf(stderr,
					    "last char != \\n in %s\n",
					     buf1);
				goto subst;
			}

			if (s2.st_size && p2[s2.st_size-1] != '\n') {
				if (verbose > 0) 
					fprintf(stderr,
					    "last char != \\n in %s\n",
					     buf2);
				goto subst;
			}

			for (p=p1; p<p1+s1.st_size; p++)
				if (!*p) {
					if (verbose > 0) 
						fprintf(stderr,
						    "NULL char in %s\n",
						     buf1);
					goto subst;
				}

			for (p=p2; p<p2+s2.st_size; p++)
				if (!*p) {
					if (verbose > 0) 
						fprintf(stderr,
						    "NULL char in %s\n",
						     buf2);
					goto subst;
				}

			strcpy(cmd, "diff -n ");
			strcat(cmd, buf1);
			strcat(cmd, " ");
			strcat(cmd, buf2);
			F = popen(cmd, "r");
			for (j = 1, l = 0; l < s2.st_size; ) {
				j = fread(ob+l, 1, s2.st_size - l, F);
				if (j < 1) 
					break;
				l += j;
				continue;
			}
			if (j) {
				l = 0;
				while (EOF != fgetc(F))
					continue;
			}
			pclose(F);
			
			if (l && l < s2.st_size) {
				name_stat("CTMFN", dir2, name, de);
				printf(" %s %s %d\n", m1, m2, (unsigned)l);
				fwrite(ob, 1, l, stdout);
				putchar('\n');
				s_edit_files++;
				s_edit_bytes += l;
				s_edit_saves += (s2.st_size - l);
			} else {
			subst:
				name_stat("CTMFS", dir2, name, de);
				printf(" %s %s %u\n", m1, m2, (unsigned)s2.st_size);
				fwrite(p2, 1, s2.st_size, stdout);
				putchar('\n');
				s_sub_files++;
				s_sub_bytes += s2.st_size;
			}
		}
	    finish:
		munmap(p1, s1.st_size);
		munmap(p2, s2.st_size);
	}
}

void
Add(const char *dir1, const char *dir2, const char *name, struct dirent *de)
{
	change++;
	if (de->d_type == DT_DIR) {
		char *p = alloca(strlen(name)+strlen(de->d_name)+2);
		strcpy(p, name);  strcat(p, de->d_name); strcat(p, "/");
		name_stat("CTMDM", dir2, name, de);
		putchar('\n');
		s_new_dirs++;
		DoDir(dir1, dir2, p);
	} else if (de->d_type == DT_REG) {
		char *buf2 = alloca(strlen(dir2) + strlen(name) + 
			strlen(de->d_name) + 3);
		char *m2, md5_2[33];
		u_char *p1;
		struct stat st;
		int fd1;

		strcpy(buf2, dir2); 
			strcat(buf2, "/"); strcat(buf2, name);
			strcat(buf2, "/"); strcat(buf2, de->d_name);
		fd1 = open(buf2, O_RDONLY);
		if (fd1 < 0) { err(3, "%s", buf2); }
		fstat(fd1, &st);
		p1=mmap(0, st.st_size, PROT_READ, MAP_PRIVATE, fd1, 0);
		if (p1 == (u_char *)MAP_FAILED) { err(3, "%s", buf2); }
		close(fd1);
		m2 = MD5Data(p1, st.st_size, md5_2);
		name_stat("CTMFM", dir2, name, de);
		printf(" %s %u\n", m2, (unsigned)st.st_size);
		fwrite(p1, 1, st.st_size, stdout);
		putchar('\n');
		munmap(p1, st.st_size);
		s_new_files++;
		s_new_bytes += st.st_size;
	}
}

void
Del (const char *dir1, const char *dir2, const char *name, struct dirent *de)
{
	damage++;
	change++;
	if (de->d_type == DT_DIR) {
		char *p = alloca(strlen(name)+strlen(de->d_name)+2);
		strcpy(p, name);  strcat(p, de->d_name); strcat(p, "/");
		DoDir(dir1, dir2, p);
		printf("CTMDR %s%s\n", name, de->d_name);
		fprintf(logf, "CTMDR %s%s\n", name, de->d_name);
		if (verbose > 1) {
			fprintf(stderr, "CTMDR %s%s\n", name, de->d_name);
		}
		s_del_dirs++;
	} else if (de->d_type == DT_REG) {
		char *buf1 = alloca(strlen(dir1) + strlen(name) + 
			strlen(de->d_name) + 3);
		char *m1, md5_1[33];
		strcpy(buf1, dir1); 
			strcat(buf1, "/"); strcat(buf1, name);
			strcat(buf1, "/"); strcat(buf1, de->d_name);
		m1 = MD5File(buf1, md5_1);
		printf("CTMFR %s%s %s\n", name, de->d_name, m1);
		fprintf(logf, "CTMFR %s%s %s\n", name, de->d_name, m1);
		if (verbose > 1) {
			fprintf(stderr, "CTMFR %s%s\n", name, de->d_name);
		}
		s_del_files++;
		s_del_bytes += StatFile(buf1)->st_size;
	}
}

void
GetNext(int *i, int *n, struct dirent **nl, const char *dir, const char *name, u_long *ignored, u_long *bogus, u_long *wrong)
{
	char buf[BUFSIZ];
	char buf1[BUFSIZ];

	for (;;) {
		for (;;) {
			(*i)++;
			if (*i >= *n)
				return;
			strcpy(buf1, name);
			if (buf1[strlen(buf1)-1] != '/')
				strcat(buf1, "/"); 
			strcat(buf1, nl[*i]->d_name);
			if (flag_ignore && 
			    !regexec(&reg_ignore, buf1, 0, 0, 0)) {
				(*ignored)++;
				fprintf(logf, "Ignore %s\n", buf1);
				if (verbose > 2) {
					fprintf(stderr, "Ignore %s\n", buf1);
				}
			} else if (flag_bogus && 
			    !regexec(&reg_bogus, buf1, 0, 0, 0)) {
				(*bogus)++;
				fprintf(logf, "Bogus %s\n", buf1);
				fprintf(stderr, "Bogus %s\n", buf1);
				damage++;
			} else {
				*buf = 0;
				if (*dir != '/')
					strcat(buf, "/");
				strcat(buf, dir); 
				if (buf[strlen(buf)-1] != '/')
					strcat(buf, "/"); 
				strcat(buf, buf1);
				break;
			}
			free(nl[*i]); nl[*i] = 0;
		}
		/* If the filesystem didn't tell us, find type */
		if (nl[*i]->d_type == DT_UNKNOWN) 
			nl[*i]->d_type = IFTODT(StatFile(buf)->st_mode);
		if (nl[*i]->d_type == DT_REG || nl[*i]->d_type == DT_DIR)
			break;
		(*wrong)++;
		if (verbose > 0)
			fprintf(stderr, "Wrong %s\n", buf);
		free(nl[*i]); nl[*i] = 0;
	}
}

void
DoDir(const char *dir1, const char *dir2, const char *name)
{
	int i1, i2, n1, n2, i;
	struct dirent **nl1, **nl2;
	char *buf1 = alloca(strlen(dir1) + strlen(name) + 4);
	char *buf2 = alloca(strlen(dir2) + strlen(name) + 4);

	strcpy(buf1, dir1); strcat(buf1, "/"); strcat(buf1, name);
	strcpy(buf2, dir2); strcat(buf2, "/"); strcat(buf2, name);
	n1 = scandir(buf1, &nl1, dirselect, alphasort);
	n2 = scandir(buf2, &nl2, dirselect, alphasort);
	i1 = i2 = -1;
	GetNext(&i1, &n1, nl1, dir1, name, &s1_ignored, &s1_bogus, &s1_wrong);
	GetNext(&i2, &n2, nl2, dir2, name, &s2_ignored, &s2_bogus, &s2_wrong);
	for (;i1 < n1 || i2 < n2;) {

		if (damage_limit && damage > damage_limit)
			break;

		/* Get next item from list 1 */
		if (i1 < n1 && !nl1[i1]) 
			GetNext(&i1, &n1, nl1, dir1, name, 
				&s1_ignored, &s1_bogus, &s1_wrong);

		/* Get next item from list 2 */
		if (i2 < n2 && !nl2[i2]) 
			GetNext(&i2, &n2, nl2, dir2, name, 
				&s2_ignored, &s2_bogus, &s2_wrong);

		if (i1 >= n1 && i2 >= n2) {
			/* Done */
			break;
		} else if (i1 >= n1 && i2 < n2) {
			/* end of list 1, add anything left on list 2 */
			Add(dir1, dir2, name, nl2[i2]);
			free(nl2[i2]); nl2[i2] = 0;
		} else if (i1 < n1 && i2 >= n2) {
			/* end of list 2, delete anything left on list 1 */
			Del(dir1, dir2, name, nl1[i1]);
			free(nl1[i1]); nl1[i1] = 0;
		} else if (!(i = strcmp(nl1[i1]->d_name, nl2[i2]->d_name))) {
			/* Identical names */
			if (nl1[i1]->d_type == nl2[i2]->d_type) {
				/* same type */
				Equ(dir1, dir2, name, nl1[i1]);
			} else {
				/* different types */
				Del(dir1, dir2, name, nl1[i1]);
				Add(dir1, dir2, name, nl2[i2]);
			}
			free(nl1[i1]); nl1[i1] = 0;
			free(nl2[i2]); nl2[i2] = 0;
		} else if (i < 0) {
			/* Something extra in list 1, delete it */
			Del(dir1, dir2, name, nl1[i1]);
			free(nl1[i1]); nl1[i1] = 0;
		} else {
			/* Something extra in list 2, add it */
			Add(dir1, dir2, name, nl2[i2]);
			free(nl2[i2]); nl2[i2] = 0;
		}
	}
	if (n1 >= 0)
		free(nl1);
	if (n2 >= 0)
		free(nl2);
}

int
main(int argc, char **argv)
{
	int i;
	extern char *optarg;
	extern int optind;

	setbuf(stderr, NULL);

#if 0
	if (regcomp(&reg_bogus, DEFAULT_BOGUS, REG_EXTENDED | REG_NEWLINE))
		/* XXX use regerror to explain it */
		errx(1, "default regular expression argument to -B is botched");
	flag_bogus = 1;

	if (regcomp(&reg_ignore, DEFAULT_IGNORE, REG_EXTENDED | REG_NEWLINE))
		/* XXX use regerror to explain it */
		errx(1, "default regular expression argument to -I is botched");
	flag_ignore = 1;
#endif

	while ((i = getopt(argc, argv, "D:I:B:l:qv")) != -1)
		switch (i) {
		case 'D':
			damage_limit = strtol(optarg, 0, 0);
			if (damage_limit < 0)
				errx(1, "damage limit must be positive");
			break;
		case 'I':
			if (flag_ignore)
				regfree(&reg_ignore);
			flag_ignore = 0;
			if (!*optarg)
				break;
			if (regcomp(&reg_ignore, optarg,
			    REG_EXTENDED | REG_NEWLINE))
				/* XXX use regerror to explain it */
				errx(1, "regular expression argument to -I is botched");
			flag_ignore = 1;
			break;
		case 'B':
			if (flag_bogus)
				regfree(&reg_bogus);
			flag_bogus = 0;
			if (!*optarg)
				break;
			if (regcomp(&reg_bogus, optarg,
			    REG_EXTENDED | REG_NEWLINE))
				/* XXX use regerror to explain it */
				errx(1, "regular expression argument to -B is botched");
			flag_bogus = 1;
			break;
		case 'l':
			logf = fopen(optarg, "w");
			if (!logf)
				err(1, "%s", optarg);
			break;
		case 'q':
			verbose--;
			break;
		case 'v':
			verbose++;
			break;
		case '?':
		default:
			Usage();
			return (1);
		}
	argc -= optind;
	argv += optind;

	if (!logf)
		logf = fopen("/dev/null", "w");

	setbuf(stdout, 0);

	if (argc != 6) {
		Usage();
		return (1);
	}
	
	signal(SIGINFO, stat_info);

	fprintf(stderr, "CTM_BEGIN 2.0 %s %s %s %s\n",
		argv[0], argv[1], argv[2], argv[3]);
	fprintf(logf, "CTM_BEGIN 2.0 %s %s %s %s\n",
		argv[0], argv[1], argv[2], argv[3]);
	printf("CTM_BEGIN 2.0 %s %s %s %s\n",
		argv[0], argv[1], argv[2], argv[3]);
	DoDir(argv[4], argv[5], "");
	if (damage_limit && damage > damage_limit) {
		print_stat(stderr, "DAMAGE: ");
		errx(1, "damage of %d would exceed %d files", 
			damage, damage_limit);
	} else if (change < 2) {
		errx(4, "no changes");
	} else {
		printf("CTM_END ");
		fprintf(logf, "CTM_END\n");
		print_stat(stderr, "END: ");
	}
	exit(0);
}
@


1.3
log
@Merge with FreeBSD 3.2, while keeping OpenBSD mktemp/mkstemp fixes.
Some minor man page enhancements.
Brings better man pages, new features, more error checking, and improved
performance; some FreeBSD examples for creating ctm deltas
merged by hgweigand@@wiesbaden.netsurf.de
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.2
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a3 8
 * Damage counter
 * Change counter
 * Time stamp
 * prefix
 * cmd-line args
 * %100 deltas
 * delta and Add are different. delta -> Equ.
 *
d10 1
a10 1
 *     (-l str		control logging.)
d34 1
a34 1
#define DEFAULT_BOGUS	"\\.core$|\\.orig$|\\.rej$"
d42 2
d57 3
a59 4
	fprintf(stderr, "Usage:\n");
	fprintf(stderr, "\tmkctm [-options] name number timestamp prefix");
	fprintf(stderr, " dir1 dir2");
	fprintf(stderr, "Options:\n");
d70 2
a71 2
    fprintf(fd,"%sAvoided:\n",pre);
    fprintf(fd,"%s  ignore:  %5lu old   %5lu new\n",
d73 1
a73 1
    fprintf(fd,"%s  bogus:   %5lu old   %5lu new\n",
d75 1
a75 1
    fprintf(fd,"%s  wrong:   %5lu old   %5lu new\n", 
d77 2
a78 2
    fprintf(fd,"%sDelta:\n",pre);
    fprintf(fd,"%s  new:     %5lu dirs  %5lu files  %9lu plus\n", 
d80 1
a80 1
    fprintf(fd,"%s  del:     %5lu dirs  %5lu files                   %9lu minus\n", 
d82 1
a82 1
    fprintf(fd,"%s  chg:                 %5lu files  %9lu plus   %9lu minus\n",
d84 1
a84 1
    fprintf(fd,"%s  same:    %5lu dirs  %5lu files  %9lu bytes\n", 
d86 2
a87 2
    fprintf(fd,"%sMethod:\n",pre);
    fprintf(fd,"%s  edit:                %5lu files  %9lu bytes  %9lu saved\n", 
d89 1
a89 1
    fprintf(fd,"%s  sub:                 %5lu files  %9lu bytes\n", 
d91 1
d97 2
a98 2
	signal(SIGINFO,stat_info);
	print_stat(stderr,"INFO: ");
d107 2
a108 2
	if (lstat(name,&st) < 0) 
		err(1,"Couldn't stat %s\n",name);
d115 2
a116 2
	if (!strcmp(de->d_name,"."))	return 0;
	if (!strcmp(de->d_name,".."))	return 0;
d127 3
a129 3
	strcpy(buf,dir); 
		strcat(buf,"/"); strcat(buf,name);
		strcat(buf,"/"); strcat(buf,de->d_name);
d131 1
a131 1
	printf("%s %s%s %lu %lu %o", 
d134 1
d136 1
a136 1
		fprintf(stderr,"%s %s%s\n", pfx, name, de->d_name);
d146 2
a147 2
		strcpy(p,name);  strcat(p,de->d_name); strcat(p, "/");
		DoDir(dir1,dir2,p);
d154 17
a170 17
		char *m1,md5_1[33],*m2, md5_2[33];
		u_char *p1,*p2;
		int fd1,fd2;
		struct stat s1,s2;

		strcpy(buf1,dir1); 
			strcat(buf1,"/"); strcat(buf1,name);
			strcat(buf1,"/"); strcat(buf1,de->d_name);
		fd1 = open(buf1,O_RDONLY);
		if(fd1 < 0) { perror(buf1); exit(3); }
		fstat(fd1,&s1);
		strcpy(buf2,dir2); 
			strcat(buf2,"/"); strcat(buf2,name);
			strcat(buf2,"/"); strcat(buf2,de->d_name);
		fd2 = open(buf2,O_RDONLY);
		if(fd2 < 0) { perror(buf2); exit(3); }
		fstat(fd2,&s2);
d181 2
a182 2
		p1=mmap(0,s1.st_size,PROT_READ,MAP_PRIVATE,fd1,0);
		if ((int)p1 == -1) { perror(buf1); exit(3); }
d185 2
a186 2
		p2=mmap(0,s2.st_size,PROT_READ,MAP_PRIVATE,fd2,0);
		if ((int)p2 == -1) { perror(buf2); exit(3); }
d190 1
a190 1
		if((s1.st_size == s2.st_size) && !memcmp(p1,p2,s1.st_size)) {
a196 1
		damage++;
d207 1
a207 1
		if(!strcmp(m1,m2)) {
d211 1
a211 1
					buf1,buf2);
d222 1
a222 1
			if (p1[s1.st_size-1] != '\n') {
d230 1
a230 1
			if (p2[s2.st_size-1] != '\n') {
d260 1
a260 1
			F = popen(cmd,"r");
d276 3
a278 3
				name_stat("CTMFN",dir2,name,de);
				printf(" %s %s %d\n",m1,m2,(unsigned)l);
				fwrite(ob,1,l,stdout);
d285 3
a287 3
				name_stat("CTMFS",dir2,name,de);
				printf(" %s %s %u\n",m1,m2,(unsigned)s2.st_size);
				fwrite(p2,1,s2.st_size,stdout);
d294 2
a295 2
		munmap(p1,s1.st_size);
		munmap(p2,s2.st_size);
d305 2
a306 2
		strcpy(p,name);  strcat(p,de->d_name); strcat(p, "/");
		name_stat("CTMDM",dir2,name,de);
d309 1
a309 1
		DoDir(dir1,dir2,p);
d318 8
a325 8
		strcpy(buf2,dir2); 
			strcat(buf2,"/"); strcat(buf2,name);
			strcat(buf2,"/"); strcat(buf2,de->d_name);
		fd1 = open(buf2,O_RDONLY);
		if (fd1 < 0) {perror(buf2); exit (3); }
		fstat(fd1,&st);
		p1=mmap(0,st.st_size,PROT_READ,MAP_PRIVATE,fd1,0);
		if ((int)p1 == -1) { perror(buf2); exit(3); }
d328 3
a330 3
		name_stat("CTMFM",dir2,name,de);
		printf(" %s %u\n",m2,(unsigned)st.st_size);
		fwrite(p1,1,st.st_size,stdout);
d332 1
a332 1
		munmap(p1,st.st_size);
d345 7
a351 3
		strcpy(p,name);  strcat(p,de->d_name); strcat(p, "/");
		DoDir(dir1,dir2,p);
		printf("CTMDR %s%s\n",name,de->d_name);
d357 3
a359 3
		strcpy(buf1,dir1); 
			strcat(buf1,"/"); strcat(buf1,name);
			strcat(buf1,"/"); strcat(buf1,de->d_name);
d361 5
a365 1
		printf("CTMFR %s%s %s\n",name,de->d_name,m1);
d375 1
d382 4
a385 10
			*buf = 0;
			if (*dir != '/')
				strcat(buf,"/");
			strcat(buf,dir); 
			if (buf[strlen(buf)-1] != '/')
				strcat(buf,"/"); 
			strcat(buf,name);
			if (buf[strlen(buf)-1] != '/')
				strcat(buf,"/"); 
			strcat(buf,nl[*i]->d_name);
d387 1
a387 1
			    !regexec(&reg_ignore,buf,0,0,0)) {
d389 1
d391 1
a391 1
					fprintf(stderr,"Ignore %s\n",buf);
d394 1
a394 1
			    !regexec(&reg_bogus,buf,0,0,0)) {
d396 3
a398 3
				if (verbose > 0) {
					fprintf(stderr,"Bogus %s\n",buf);
				}
d400 7
d418 1
a418 1
			fprintf(stderr,"Wrong %s\n",buf);
d426 2
a427 2
	int i1,i2,n1,n2,i;
	struct dirent **nl1,**nl2;
d431 2
a432 2
	strcpy(buf1,dir1); strcat(buf1,"/"); strcat(buf1,name);
	strcpy(buf2,dir2); strcat(buf2,"/"); strcat(buf2,name);
d458 1
a458 1
			Add(dir1,dir2,name,nl2[i2]);
d462 1
a462 1
			Del(dir1,dir2,name,nl1[i1]);
d468 1
a468 1
				Equ(dir1,dir2,name,nl1[i1]);
d471 2
a472 2
				Del(dir1,dir2,name,nl1[i1]);
				Add(dir1,dir2,name,nl2[i2]);
d478 1
a478 1
			Del(dir1,dir2,name,nl1[i1]);
d482 1
a482 1
			Add(dir1,dir2,name,nl2[i2]);
d501 2
a502 1
	if (regcomp(&reg_bogus,DEFAULT_BOGUS, REG_EXTENDED | REG_NEWLINE))
d504 1
a504 1
		err(1,"Default regular expression argument to -B is botched");
d507 1
a507 1
	if (regcomp(&reg_ignore,DEFAULT_IGNORE, REG_EXTENDED | REG_NEWLINE))
d509 1
a509 1
		err(1,"Default regular expression argument to -I is botched");
d511 1
d513 1
a513 1
	while ((i = getopt(argc,argv,"D:I:B:qv")) != -1)
d516 1
a516 1
			damage_limit = strtol(optarg,0,0);
d518 1
a518 1
				err(1,"Damage limit must be positive");
d526 1
a526 1
			if (regcomp(&reg_ignore,optarg,
d529 1
a529 1
				err(1,"Regular expression argument to -I is botched");
d538 1
a538 1
			if (regcomp(&reg_bogus,optarg,
d541 1
a541 1
				err(1,"Regular expression argument to -B is botched");
d544 5
d563 4
a566 1
	setbuf(stdout,0);
d573 1
a573 1
	signal(SIGINFO,stat_info);
d575 4
d581 1
a581 1
	DoDir(argv[4],argv[5],"");
d583 5
a587 4
		print_stat(stderr,"");
		err(1,"Damage would exceede %d files", damage_limit);
	} else if (!change) {
		err(1,"No changes");
d590 2
a591 1
		print_stat(stderr,"");
@


1.1
log
@Initial revision
@
text
@d505 1
a505 1
	while ((i = getopt(argc,argv,"D:I:B:qv")) != EOF)
@


1.1.1.1
log
@import ctm (current through mail)
for more see http://www.openbsd.org/ctm.html - it's basicaly the FreeBSD
version adapted to OpenBSD - i'll bring in the latest FreeBSD changes in the
next days
@
text
@@
