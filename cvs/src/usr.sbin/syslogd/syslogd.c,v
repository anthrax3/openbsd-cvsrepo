head	1.247;
access;
symbols
	OPENBSD_6_1:1.233.0.4
	OPENBSD_6_1_BASE:1.233
	OPENBSD_6_0:1.210.0.2
	OPENBSD_6_0_BASE:1.210
	OPENBSD_5_9:1.204.0.2
	OPENBSD_5_9_BASE:1.204
	OPENBSD_5_8:1.177.0.4
	OPENBSD_5_8_BASE:1.177
	OPENBSD_5_7:1.160.0.2
	OPENBSD_5_7_BASE:1.160
	OPENBSD_5_6:1.111.0.4
	OPENBSD_5_6_BASE:1.111
	OPENBSD_5_5:1.110.0.4
	OPENBSD_5_5_BASE:1.110
	OPENBSD_5_4:1.107.0.2
	OPENBSD_5_4_BASE:1.107
	OPENBSD_5_3:1.105.0.2
	OPENBSD_5_3_BASE:1.105
	OPENBSD_5_2:1.104.0.6
	OPENBSD_5_2_BASE:1.104
	OPENBSD_5_1_BASE:1.104
	OPENBSD_5_1:1.104.0.4
	OPENBSD_5_0:1.104.0.2
	OPENBSD_5_0_BASE:1.104
	OPENBSD_4_9:1.103.0.6
	OPENBSD_4_9_BASE:1.103
	OPENBSD_4_8:1.103.0.4
	OPENBSD_4_8_BASE:1.103
	OPENBSD_4_7:1.103.0.2
	OPENBSD_4_7_BASE:1.103
	OPENBSD_4_6:1.102.0.6
	OPENBSD_4_6_BASE:1.102
	OPENBSD_4_5:1.102.0.2
	OPENBSD_4_5_BASE:1.102
	OPENBSD_4_4:1.101.0.2
	OPENBSD_4_4_BASE:1.101
	OPENBSD_4_3:1.100.0.2
	OPENBSD_4_3_BASE:1.100
	OPENBSD_4_2:1.98.0.2
	OPENBSD_4_2_BASE:1.98
	OPENBSD_4_1:1.96.0.2
	OPENBSD_4_1_BASE:1.96
	OPENBSD_4_0:1.92.0.6
	OPENBSD_4_0_BASE:1.92
	OPENBSD_3_9:1.92.0.4
	OPENBSD_3_9_BASE:1.92
	OPENBSD_3_8:1.92.0.2
	OPENBSD_3_8_BASE:1.92
	OPENBSD_3_7:1.89.0.2
	OPENBSD_3_7_BASE:1.89
	OPENBSD_3_6:1.82.0.2
	OPENBSD_3_6_BASE:1.82
	OPENBSD_3_5:1.74.0.2
	OPENBSD_3_5_BASE:1.74
	OPENBSD_3_4:1.66.0.2
	OPENBSD_3_4_BASE:1.66
	OPENBSD_3_3:1.60.0.2
	OPENBSD_3_3_BASE:1.60
	OPENBSD_3_2:1.57.0.2
	OPENBSD_3_2_BASE:1.57
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9_BASE:1.40
	OPENBSD_2_9:1.40.0.2
	OPENBSD_2_8:1.36.0.2
	OPENBSD_2_8_BASE:1.36
	OPENBSD_2_7:1.34.0.2
	OPENBSD_2_7_BASE:1.34
	OPENBSD_2_6:1.33.0.2
	OPENBSD_2_6_BASE:1.33
	OPENBSD_2_5:1.32.0.2
	OPENBSD_2_5_BASE:1.32
	OPENBSD_2_4:1.30.0.2
	OPENBSD_2_4_BASE:1.30
	OPENBSD_2_3:1.25.0.2
	OPENBSD_2_3_BASE:1.25
	OPENBSD_2_2:1.18.0.2
	OPENBSD_2_2_BASE:1.18
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.247
date	2017.09.17.22.25.21;	author bluhm;	state Exp;
branches;
next	1.246;
commitid	XojGZXSFVvcfiB6h;

1.246
date	2017.09.12.15.17.20;	author bluhm;	state Exp;
branches;
next	1.245;
commitid	VmmotRTTGO0SDAt7;

1.245
date	2017.08.08.14.23.23;	author bluhm;	state Exp;
branches;
next	1.244;
commitid	mLHelEDyH1jZRa58;

1.244
date	2017.04.28.14.52.13;	author bluhm;	state Exp;
branches;
next	1.243;
commitid	8RoyOPawfFwQBkZb;

1.243
date	2017.04.25.17.45.50;	author bluhm;	state Exp;
branches;
next	1.242;
commitid	hzP8oSrMMFTYEtQc;

1.242
date	2017.04.17.14.18.44;	author bluhm;	state Exp;
branches;
next	1.241;
commitid	2xBS0pNtTszNKd2I;

1.241
date	2017.04.07.15.36.16;	author bluhm;	state Exp;
branches;
next	1.240;
commitid	n6YD9F971L8c0dwh;

1.240
date	2017.04.05.22.15.35;	author bluhm;	state Exp;
branches;
next	1.239;
commitid	fTGT1uB8rudZU6Oa;

1.239
date	2017.04.05.21.55.31;	author bluhm;	state Exp;
branches;
next	1.238;
commitid	flr3ijis68GFyMYo;

1.238
date	2017.04.05.21.30.04;	author bluhm;	state Exp;
branches;
next	1.237;
commitid	RlroTKzPEyOFaCM2;

1.237
date	2017.04.05.19.34.49;	author bluhm;	state Exp;
branches;
next	1.236;
commitid	KjFSKw651wwCyCo8;

1.236
date	2017.04.05.15.16.12;	author bluhm;	state Exp;
branches;
next	1.235;
commitid	bBC0po63egmGHP1A;

1.235
date	2017.04.05.11.31.45;	author bluhm;	state Exp;
branches;
next	1.234;
commitid	TF7j2iQD9pdWhJEf;

1.234
date	2017.04.05.00.35.02;	author bluhm;	state Exp;
branches;
next	1.233;
commitid	pETQueJVY5pzqcDt;

1.233
date	2017.03.28.00.04.43;	author jsg;	state Exp;
branches;
next	1.232;
commitid	Q6N0HNysC8JpO5ja;

1.232
date	2017.03.26.18.38.16;	author bluhm;	state Exp;
branches;
next	1.231;
commitid	d8MFIyStQHq8S8N2;

1.231
date	2017.03.24.22.13.00;	author bluhm;	state Exp;
branches;
next	1.230;
commitid	QanIDfS15EK6b2Zx;

1.230
date	2017.03.16.23.55.19;	author bluhm;	state Exp;
branches;
next	1.229;
commitid	mPxHeEPvGtNx5V0a;

1.229
date	2017.03.16.17.55.22;	author bluhm;	state Exp;
branches;
next	1.228;
commitid	lCzTdeDXWfqlgNjL;

1.228
date	2017.03.14.15.35.48;	author deraadt;	state Exp;
branches;
next	1.227;
commitid	B0DlARLrf8tKlqMU;

1.227
date	2017.01.02.15.58.02;	author bluhm;	state Exp;
branches;
next	1.226;
commitid	t1Y67IRsoE20izgW;

1.226
date	2016.12.30.23.21.26;	author bluhm;	state Exp;
branches;
next	1.225;
commitid	eenFpv77Suf1MCUq;

1.225
date	2016.12.27.19.16.24;	author bluhm;	state Exp;
branches;
next	1.224;
commitid	UcY5hLOJcK9FUk4A;

1.224
date	2016.12.23.23.01.48;	author bluhm;	state Exp;
branches;
next	1.223;
commitid	w1Lk2X3NeYAcgbMN;

1.223
date	2016.11.30.07.59.04;	author mestre;	state Exp;
branches;
next	1.222;
commitid	UDOazeee6NejSmz6;

1.222
date	2016.11.21.16.36.10;	author mestre;	state Exp;
branches;
next	1.221;
commitid	j5arnpSaSwiMApk3;

1.221
date	2016.10.17.11.19.55;	author bluhm;	state Exp;
branches;
next	1.220;
commitid	yoeynjilxfuZwQte;

1.220
date	2016.10.16.22.12.50;	author bluhm;	state Exp;
branches;
next	1.219;
commitid	Upi8egpBgqWfAtF0;

1.219
date	2016.10.16.22.00.14;	author bluhm;	state Exp;
branches;
next	1.218;
commitid	ElNa2cXQB0SPdrJ2;

1.218
date	2016.10.06.13.03.47;	author bluhm;	state Exp;
branches;
next	1.217;
commitid	Topwmtp5NL4LwDP6;

1.217
date	2016.10.06.11.24.04;	author bluhm;	state Exp;
branches;
next	1.216;
commitid	2BTPzQXgLRIcYzFd;

1.216
date	2016.10.04.22.09.21;	author bluhm;	state Exp;
branches;
next	1.215;
commitid	725PbGhv3Csdcx8f;

1.215
date	2016.09.23.15.46.39;	author bluhm;	state Exp;
branches;
next	1.214;
commitid	BsK1o1gnlxoV4poE;

1.214
date	2016.09.23.13.13.13;	author bluhm;	state Exp;
branches;
next	1.213;
commitid	86e9yGPMy0jqAjHM;

1.213
date	2016.09.21.11.54.57;	author bluhm;	state Exp;
branches;
next	1.212;
commitid	ARdk8JLFaffOFxtQ;

1.212
date	2016.08.29.20.31.56;	author bluhm;	state Exp;
branches;
next	1.211;
commitid	CcZc2GMjydfYECLO;

1.211
date	2016.08.17.12.18.29;	author bluhm;	state Exp;
branches;
next	1.210;
commitid	VOPoLyQigyOJImSr;

1.210
date	2016.07.13.16.35.47;	author jsing;	state Exp;
branches;
next	1.209;
commitid	02rKn2WBJ6A1ygkh;

1.209
date	2016.07.12.09.47.25;	author bluhm;	state Exp;
branches;
next	1.208;
commitid	mzm4qhzHBbegj47E;

1.208
date	2016.07.06.19.29.13;	author millert;	state Exp;
branches;
next	1.207;
commitid	LHQFGmOoEfqRlvRa;

1.207
date	2016.07.01.15.47.15;	author millert;	state Exp;
branches;
next	1.206;
commitid	8OCTkuakFde0cPjZ;

1.206
date	2016.07.01.15.00.48;	author millert;	state Exp;
branches;
next	1.205;
commitid	L5dhGRJcS5jDYmbf;

1.205
date	2016.04.02.19.55.10;	author krw;	state Exp;
branches;
next	1.204;
commitid	uFCdPoth1U2KDjGH;

1.204
date	2016.02.17.18.31.28;	author bluhm;	state Exp;
branches;
next	1.203;
commitid	6BMn6NFaOn13gnjv;

1.203
date	2015.12.29.17.51.56;	author bluhm;	state Exp;
branches;
next	1.202;
commitid	cFQVb3CdObqNxryR;

1.202
date	2015.12.16.13.38.39;	author bluhm;	state Exp;
branches;
next	1.201;
commitid	NVTAthQ2fFJYXRoY;

1.201
date	2015.10.24.12.49.37;	author bluhm;	state Exp;
branches;
next	1.200;
commitid	PsCxnKD3lJlBaKhT;

1.200
date	2015.10.23.16.28.52;	author bluhm;	state Exp;
branches;
next	1.199;
commitid	eBs6rrorZWMEEvct;

1.199
date	2015.10.21.14.03.07;	author bluhm;	state Exp;
branches;
next	1.198;
commitid	TmKVn9eOlSCpK5iI;

1.198
date	2015.10.15.20.26.47;	author bluhm;	state Exp;
branches;
next	1.197;
commitid	q4QZhB2FFsrsOMtz;

1.197
date	2015.10.11.23.51.26;	author bluhm;	state Exp;
branches;
next	1.196;
commitid	u2ll8L0SvQGkY60R;

1.196
date	2015.10.11.20.23.49;	author guenther;	state Exp;
branches;
next	1.195;
commitid	i6P7pBlCuLlhNqfW;

1.195
date	2015.10.10.20.35.01;	author deraadt;	state Exp;
branches;
next	1.194;
commitid	m38BXhkh3XknrpM6;

1.194
date	2015.10.09.16.58.25;	author bluhm;	state Exp;
branches;
next	1.193;
commitid	5A0tNEXnHGGgWpGX;

1.193
date	2015.10.09.16.44.55;	author bluhm;	state Exp;
branches;
next	1.192;
commitid	jitrAfJG3bng1kXo;

1.192
date	2015.10.09.16.29.17;	author deraadt;	state Exp;
branches;
next	1.191;
commitid	yoUsFmnH2DbOIsYs;

1.191
date	2015.10.09.12.07.32;	author bluhm;	state Exp;
branches;
next	1.190;
commitid	tY4MuQRdaEHvV3SM;

1.190
date	2015.09.29.03.19.23;	author guenther;	state Exp;
branches;
next	1.189;
commitid	yKdJafwKaYfM4gkS;

1.189
date	2015.09.12.13.50.29;	author bluhm;	state Exp;
branches;
next	1.188;
commitid	3pylUfz8wnKLDyUy;

1.188
date	2015.09.11.21.33.16;	author bluhm;	state Exp;
branches;
next	1.187;
commitid	fgvNJY2SQlH6bbP0;

1.187
date	2015.09.11.12.42.12;	author bluhm;	state Exp;
branches;
next	1.186;
commitid	EuPpIE1ZWb40RGri;

1.186
date	2015.09.10.19.02.09;	author bluhm;	state Exp;
branches;
next	1.185;
commitid	UQPC4CkqOuRPIbkI;

1.185
date	2015.09.10.18.32.06;	author bluhm;	state Exp;
branches;
next	1.184;
commitid	LgKbuvsrCAHwACYR;

1.184
date	2015.09.09.08.12.46;	author bluhm;	state Exp;
branches;
next	1.183;
commitid	FvyC9YHbVPPvcVm2;

1.183
date	2015.09.03.20.50.48;	author bluhm;	state Exp;
branches;
next	1.182;
commitid	aJxyWHUxs7YWX9rF;

1.182
date	2015.09.03.14.50.53;	author bluhm;	state Exp;
branches;
next	1.181;
commitid	EMHByj73PCiwMRl3;

1.181
date	2015.09.01.17.53.14;	author bluhm;	state Exp;
branches;
next	1.180;
commitid	8axEw959Z2PMBVlg;

1.180
date	2015.08.31.20.44.47;	author bluhm;	state Exp;
branches;
next	1.179;
commitid	IMTcxn6xE53VdR5K;

1.179
date	2015.08.27.17.53.35;	author bluhm;	state Exp;
branches;
next	1.178;
commitid	CLkHCJTcscLbpejL;

1.178
date	2015.08.25.17.14.16;	author bluhm;	state Exp;
branches;
next	1.177;
commitid	DjuYZ3SoDeaFItgR;

1.177
date	2015.07.20.19.49.33;	author bluhm;	state Exp;
branches;
next	1.176;
commitid	cDumbL5HfX8mFDS6;

1.176
date	2015.07.20.17.47.38;	author bluhm;	state Exp;
branches;
next	1.175;
commitid	773qbPpFn1wWWVRW;

1.175
date	2015.07.19.20.10.46;	author bluhm;	state Exp;
branches;
next	1.174;
commitid	a94FbKoxJ4cb4rIv;

1.174
date	2015.07.18.22.33.46;	author bluhm;	state Exp;
branches;
next	1.173;
commitid	hfkOPlRIC2r9WCxe;

1.173
date	2015.07.16.23.29.14;	author bluhm;	state Exp;
branches;
next	1.172;
commitid	blWyfsN48J6kpKpU;

1.172
date	2015.07.09.16.01.48;	author bluhm;	state Exp;
branches;
next	1.171;
commitid	nzoU7oxkquBSCRYR;

1.171
date	2015.07.07.17.53.04;	author bluhm;	state Exp;
branches;
next	1.170;
commitid	Ygwih79fAl6T0IdE;

1.170
date	2015.07.06.16.12.16;	author millert;	state Exp;
branches;
next	1.169;
commitid	MZymOysCDJJlr2xr;

1.169
date	2015.07.05.22.05.12;	author bluhm;	state Exp;
branches;
next	1.168;
commitid	IZoeB3vRaUQ5EIfQ;

1.168
date	2015.07.02.16.24.48;	author bluhm;	state Exp;
branches;
next	1.167;
commitid	9xUFYpE6Pa34w4jN;

1.167
date	2015.06.30.18.41.24;	author bluhm;	state Exp;
branches;
next	1.166;
commitid	o036yHFdQc8J4IhP;

1.166
date	2015.06.30.12.03.32;	author bluhm;	state Exp;
branches;
next	1.165;
commitid	Zc7oLXwqGtUJdHot;

1.165
date	2015.06.29.11.04.28;	author bluhm;	state Exp;
branches;
next	1.164;
commitid	ZD9L1ucJwlxkPOA9;

1.164
date	2015.06.15.21.42.15;	author bluhm;	state Exp;
branches;
next	1.163;
commitid	YANAvbNvMccX42N2;

1.163
date	2015.06.12.19.20.43;	author bluhm;	state Exp;
branches;
next	1.162;
commitid	aS211ob62Syl6l81;

1.162
date	2015.06.12.00.54.28;	author bluhm;	state Exp;
branches;
next	1.161;
commitid	BXfEem7AE6xuouod;

1.161
date	2015.03.30.09.21.42;	author tobias;	state Exp;
branches;
next	1.160;
commitid	N1K9gTUcronoFVzd;

1.160
date	2015.02.24.01.29.49;	author bluhm;	state Exp;
branches;
next	1.159;
commitid	QRduygzLPf7npsVp;

1.159
date	2015.02.22.15.09.54;	author jsing;	state Exp;
branches;
next	1.158;
commitid	lRyL0pnPfoLbeA76;

1.158
date	2015.02.22.14.55.41;	author jsing;	state Exp;
branches;
next	1.157;
commitid	qDSb6EAJHuZKbiwf;

1.157
date	2015.02.20.00.56.32;	author bluhm;	state Exp;
branches;
next	1.156;
commitid	vP1CrASY5DRsLXb7;

1.156
date	2015.02.14.09.02.15;	author bluhm;	state Exp;
branches;
next	1.155;
commitid	G6v7u37hP7t8HWpU;

1.155
date	2015.02.13.21.09.38;	author bluhm;	state Exp;
branches;
next	1.154;
commitid	DyTYx5MIlNsiEGNe;

1.154
date	2015.02.12.04.23.17;	author jsing;	state Exp;
branches;
next	1.153;
commitid	YIftjrdQsRMjeEvV;

1.153
date	2015.02.10.18.30.20;	author bluhm;	state Exp;
branches;
next	1.152;
commitid	6Utpg6b8ndWv1VxI;

1.152
date	2015.02.09.09.28.56;	author bluhm;	state Exp;
branches;
next	1.151;
commitid	6sxdjQyZDDaOq7oN;

1.151
date	2015.02.08.15.17.30;	author bluhm;	state Exp;
branches;
next	1.150;
commitid	DK2dFbr0zIVY2ckE;

1.150
date	2015.02.08.01.30.09;	author reyk;	state Exp;
branches;
next	1.149;
commitid	liKJlZtzCZniQpc5;

1.149
date	2015.02.07.22.19.01;	author deraadt;	state Exp;
branches;
next	1.148;
commitid	Dov9umYU9R8EppwH;

1.148
date	2015.02.06.00.17.58;	author bluhm;	state Exp;
branches;
next	1.147;
commitid	uze9Cv3cY4kXc9n6;

1.147
date	2015.02.02.17.27.43;	author bluhm;	state Exp;
branches;
next	1.146;
commitid	XbSQY18KN3B1mujU;

1.146
date	2015.01.31.00.58.35;	author bluhm;	state Exp;
branches;
next	1.145;
commitid	TR1SKahAjCZwD5D1;

1.145
date	2015.01.28.19.14.05;	author bluhm;	state Exp;
branches;
next	1.144;
commitid	IhVQzpoGuxZ8FrBP;

1.144
date	2015.01.19.16.40.49;	author bluhm;	state Exp;
branches;
next	1.143;
commitid	ye1aJeTlbYgpyeiK;

1.143
date	2015.01.18.19.37.59;	author bluhm;	state Exp;
branches;
next	1.142;
commitid	cVnX55hA2Of6ako2;

1.142
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.141;
commitid	Uu5nFG3wCl0LACBb;

1.141
date	2015.01.15.11.49.59;	author bluhm;	state Exp;
branches;
next	1.140;
commitid	G0i7KJRrsFMKLPmi;

1.140
date	2015.01.08.20.22.47;	author bluhm;	state Exp;
branches;
next	1.139;
commitid	Wn1iro8d0IKPrgMj;

1.139
date	2015.01.02.12.41.08;	author bluhm;	state Exp;
branches;
next	1.138;
commitid	f7TSJeRVNzOZDUOF;

1.138
date	2015.01.02.12.30.45;	author bluhm;	state Exp;
branches;
next	1.137;
commitid	W3Lc9mb31OP3REim;

1.137
date	2014.12.31.13.55.57;	author bluhm;	state Exp;
branches;
next	1.136;
commitid	NVMWLaTDuO6woUW6;

1.136
date	2014.12.10.19.42.14;	author tobias;	state Exp;
branches;
next	1.135;
commitid	80WrULv4WjFuuEzg;

1.135
date	2014.12.10.19.40.21;	author tobias;	state Exp;
branches;
next	1.134;
commitid	H8JitAAM8jGpE4ap;

1.134
date	2014.12.07.13.59.55;	author tobias;	state Exp;
branches;
next	1.133;
commitid	s7TZW0l7qBQBRO1a;

1.133
date	2014.12.06.12.18.32;	author tobias;	state Exp;
branches;
next	1.132;
commitid	BrS0JNuD3AEWue1g;

1.132
date	2014.12.03.17.00.15;	author millert;	state Exp;
branches;
next	1.131;
commitid	VcbYgKOBPVb4bfpZ;

1.131
date	2014.11.26.18.34.52;	author millert;	state Exp;
branches;
next	1.130;
commitid	9QOFSShUOtA0kQLF;

1.130
date	2014.11.01.12.07.41;	author bluhm;	state Exp;
branches;
next	1.129;
commitid	Mbrqnz7Ia49v9adI;

1.129
date	2014.10.06.19.36.34;	author bluhm;	state Exp;
branches;
next	1.128;
commitid	7sESeQeW5YZjMe5k;

1.128
date	2014.10.05.18.14.01;	author bluhm;	state Exp;
branches;
next	1.127;
commitid	F9a5EGI6b8V6fn1r;

1.127
date	2014.10.03.21.55.22;	author bluhm;	state Exp;
branches;
next	1.126;
commitid	iEB47IzucBg1qJLP;

1.126
date	2014.10.01.15.47.33;	author guenther;	state Exp;
branches;
next	1.125;
commitid	EIcX3L1To4HkQ0O8;

1.125
date	2014.09.27.11.28.37;	author bluhm;	state Exp;
branches;
next	1.124;
commitid	l9YBaEBKt3Vrkmsx;

1.124
date	2014.09.10.13.16.20;	author doug;	state Exp;
branches;
next	1.123;
commitid	FKg512MOeVlGwll8;

1.123
date	2014.09.08.00.43.42;	author doug;	state Exp;
branches;
next	1.122;
commitid	gbKO3ZNYXDnVBGv2;

1.122
date	2014.09.04.15.19.05;	author bluhm;	state Exp;
branches;
next	1.121;
commitid	SX5jF0U1eYENTHSX;

1.121
date	2014.08.31.22.11.43;	author bluhm;	state Exp;
branches;
next	1.120;
commitid	Pa87XHLRnZapbb2c;

1.120
date	2014.08.31.20.51.31;	author bluhm;	state Exp;
branches;
next	1.119;
commitid	eUCtTxEJ5boTrH3H;

1.119
date	2014.08.25.18.19.18;	author bluhm;	state Exp;
branches;
next	1.118;
commitid	5y3omv4nlYdpVnPL;

1.118
date	2014.08.25.18.05.30;	author bluhm;	state Exp;
branches;
next	1.117;
commitid	V6d93DJvIyTMzMa3;

1.117
date	2014.08.22.16.14.11;	author bluhm;	state Exp;
branches;
next	1.116;
commitid	wB95IKhNOfYJMJSn;

1.116
date	2014.08.21.17.00.34;	author bluhm;	state Exp;
branches;
next	1.115;
commitid	FklVDocMUu0Wjxix;

1.115
date	2014.08.21.00.04.58;	author bluhm;	state Exp;
branches;
next	1.114;
commitid	OdNcvuzm1SE1FBI6;

1.114
date	2014.08.20.20.10.17;	author bluhm;	state Exp;
branches;
next	1.113;
commitid	yQfrceogzjafLaIV;

1.113
date	2014.08.20.19.16.27;	author bluhm;	state Exp;
branches;
next	1.112;
commitid	fM55SSGsY8U1QNTd;

1.112
date	2014.08.19.00.24.00;	author bluhm;	state Exp;
branches;
next	1.111;
commitid	8wwbwytBkQCc5yBy;

1.111
date	2014.07.14.04.02.33;	author deraadt;	state Exp;
branches;
next	1.110;
commitid	1WGgU9mZKNT3OQUV;

1.110
date	2014.02.04.23.28.05;	author bluhm;	state Exp;
branches;
next	1.109;

1.109
date	2013.11.24.01.06.18;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2013.10.09.16.33.05;	author millert;	state Exp;
branches;
next	1.107;

1.107
date	2013.04.16.19.24.55;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2013.02.10.10.47.08;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2011.07.12.11.28.31;	author sthen;	state Exp;
branches;
next	1.103;

1.103
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2008.09.29.18.42.54;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2008.04.21.22.09.51;	author mpf;	state Exp;
branches;
next	1.100;

1.100
date	2007.10.17.20.10.44;	author chl;	state Exp;
branches;
next	1.99;

1.99
date	2007.09.07.20.55.26;	author bluhm;	state Exp;
branches;
next	1.98;

1.98
date	2007.05.02.15.17.11;	author jason;	state Exp;
branches;
next	1.97;

1.97
date	2007.03.30.18.25.44;	author canacar;	state Exp;
branches;
next	1.96;

1.96
date	2007.02.21.18.10.31;	author mpf;	state Exp;
branches;
next	1.95;

1.95
date	2007.02.20.11.24.32;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2007.01.03.13.25.20;	author mpf;	state Exp;
branches;
next	1.93;

1.93
date	2006.09.17.18.28.34;	author djm;	state Exp;
branches;
next	1.92;

1.92
date	2005.06.10.01.41.43;	author millert;	state Exp;
branches;
next	1.91;

1.91
date	2005.06.06.23.22.04;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2005.04.21.16.15.50;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2005.03.12.08.05.58;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2004.12.22.17.42.00;	author danh;	state Exp;
branches;
next	1.87;

1.87
date	2004.12.21.23.09.32;	author danh;	state Exp;
branches;
next	1.86;

1.86
date	2004.12.20.20.59.19;	author otto;	state Exp;
branches;
next	1.85;

1.85
date	2004.11.11.20.14.53;	author otto;	state Exp;
branches;
next	1.84;

1.84
date	2004.09.14.23.37.06;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2004.09.14.23.25.34;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2004.07.03.23.40.44;	author djm;	state Exp;
branches;
next	1.81;

1.81
date	2004.07.03.05.32.18;	author djm;	state Exp;
branches;
next	1.80;

1.80
date	2004.06.25.19.10.54;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2004.06.03.12.21.08;	author dhartmei;	state Exp;
branches;
next	1.78;

1.78
date	2004.06.03.08.21.40;	author otto;	state Exp;
branches;
next	1.77;

1.77
date	2004.05.25.23.51.30;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2004.04.15.18.13.07;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	2004.04.13.12.07.06;	author djm;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.19.16.06.05;	author millert;	state Exp;
branches;
next	1.73;

1.73
date	2004.01.13.04.08.27;	author djm;	state Exp;
branches;
next	1.72;

1.72
date	2004.01.05.09.45.49;	author jmc;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.04.18.29.33;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.04.08.28.49;	author djm;	state Exp;
branches;
next	1.69;

1.69
date	2003.12.29.22.08.44;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2003.12.29.22.05.11;	author djm;	state Exp;
branches;
next	1.67;

1.67
date	2003.09.19.08.15.55;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2003.08.18.16.56.31;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2003.07.31.18.20.07;	author avsm;	state Exp;
branches;
next	1.64;

1.64
date	2003.07.08.01.28.11;	author avsm;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2003.05.17.19.44.06;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.17.17.49.28;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2003.03.21.19.28.58;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2002.12.22.17.19.42;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2002.11.21.07.46.48;	author cloder;	state Exp;
branches;
next	1.57;

1.57
date	2002.09.06.19.46.52;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2002.08.08.23.07.12;	author aaron;	state Exp;
branches;
next	1.55;

1.55
date	2002.07.24.22.10.23;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2002.07.20.18.02.03;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2002.06.14.21.35.01;	author todd;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.05.17.12.52;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.05.26.09.25.22;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2002.05.25.13.54.03;	author fgsch;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.16.21.28.09;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.02.02.23.45;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.17.19.49.41;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2001.11.17.13.33.42;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.17.13.32.57;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.16.19.57.33;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.03.20.24.16;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.03.19.09.26;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.27.20.34.36;	author pvalchev;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.07.06.15.46;	author fgsch;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.19.17.53.19;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.16.23.58.00;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.11.23.39.12;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.13.23.10.25;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2000.08.17.22.00.32;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.22.19.28.06;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	99.07.06.10.07.03;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	99.02.03.04.36.07;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	99.01.05.08.51.57;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.06.26.01.58.00;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	98.06.23.22.40.38;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	98.06.11.20.51.16;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.05.18.19.06.56;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.05.05.03.29.49;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	98.03.01.09.38.40;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.02.11.02.28.34;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.02.03.19.07.59;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.11.07.20.56.02;	author bri;	state Exp;
branches;
next	1.21;

1.21
date	97.11.06.20.26.22;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.11.06.20.21.08;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.11.06.20.14.27;	author bri;	state Exp;
branches;
next	1.18;

1.18
date	97.09.15.09.37.24;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.09.13.12.20.27;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.09.08.17.50.51;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	97.08.04.19.26.22;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.07.21.19.05.29;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.06.18.09.53.38;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.04.04.16.57.01;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.01.15.23.44.24;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	96.12.03.07.34.36;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.07.30.16.28.27;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.07.30.16.24.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.07.27.01.38.08;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.26.05.26.22;	author joshd;	state Exp;
branches;
next	1.5;

1.5
date	96.07.26.05.22.11;	author joshd;	state Exp;
branches;
next	1.4;

1.4
date	96.01.10.22.15.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.05.14.00.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.18.19.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.22;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.247
log
@When writing local output, syslogd ignores EAGAIN.  Unfortunately
it has closed the file descriptor before checking the errno.  So
f_file contained a bad file descriptor that could be reused at the
next open.  Keep the file open if errno is EAGAIN.  Move the close(2)
down where the old file descriptor in f_file is overwritten in all
cases.
OK deraadt@@ jca@@
@
text
@/*	$OpenBSD: syslogd.c,v 1.246 2017/09/12 15:17:20 bluhm Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 *  syslogd -- log system messages
 *
 * This program implements a system log. It takes a series of lines.
 * Each line may have a priority, signified as "<n>" as
 * the first characters of the line.  If this is
 * not present, a default priority is used.
 *
 * To kill syslogd, send a signal 15 (terminate).  A signal 1 (hup) will
 * cause it to reread its configuration file.
 *
 * Defined Constants:
 *
 * MAXLINE -- the maximum line length that can be handled.
 * DEFUPRI -- the default priority for user messages
 * DEFSPRI -- the default priority for kernel messages
 *
 * Author: Eric Allman
 * extensive changes by Ralph Campbell
 * more extensive changes by Eric Allman (again)
 * memory buffer logging by Damien Miller
 * IPv6, libevent, syslog over TCP and TLS by Alexander Bluhm
 */

#define MAX_UDPMSG	1180		/* maximum UDP send size */
#define MIN_MEMBUF	(LOG_MAXLINE * 4) /* Minimum memory buffer size */
#define MAX_MEMBUF	(256 * 1024)	/* Maximum memory buffer size */
#define MAX_MEMBUF_NAME	64		/* Max length of membuf log name */
#define MAX_TCPBUF	(256 * 1024)	/* Maximum tcp event buffer size */
#define	MAXSVLINE	120		/* maximum saved line length */
#define FD_RESERVE	5		/* file descriptors not accepted */
#define DEFUPRI		(LOG_USER|LOG_NOTICE)
#define DEFSPRI		(LOG_KERN|LOG_CRIT)
#define TIMERINTVL	30		/* interval for checking flush, mark */

#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/msgbuf.h>
#include <sys/queue.h>
#include <sys/sysctl.h>
#include <sys/un.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <limits.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tls.h>
#include <unistd.h>
#include <utmp.h>
#include <vis.h>

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))
#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

#define SYSLOG_NAMES
#include <sys/syslog.h>

#include "log.h"
#include "syslogd.h"
#include "evbuffer_tls.h"

char *ConfFile = _PATH_LOGCONF;
const char ctty[] = _PATH_CONSOLE;

#define MAXUNAMES	20	/* maximum number of user names */


/*
 * Flags to logline().
 */

#define IGN_CONS	0x001	/* don't print on console */
#define SYNC_FILE	0x002	/* do fsync on file after printing */
#define ADDDATE		0x004	/* add a date to the message */
#define MARK		0x008	/* this message is a mark */

/*
 * This structure represents the files that will have log
 * copies printed.
 */

struct filed {
	SIMPLEQ_ENTRY(filed) f_next;	/* next in linked list */
	int	f_type;			/* entry type, see below */
	int	f_file;			/* file descriptor */
	time_t	f_time;			/* time this was last written */
	u_char	f_pmask[LOG_NFACILITIES+1];	/* priority mask */
	char	*f_program;		/* program this applies to */
	char	*f_hostname;		/* host this applies to */
	union {
		char	f_uname[MAXUNAMES][UT_NAMESIZE+1];
		struct {
			char	f_loghost[1+4+3+1+NI_MAXHOST+1+NI_MAXSERV];
				/* @@proto46://[hostname]:servname\0 */
			struct sockaddr_storage	 f_addr;
			struct buffertls	 f_buftls;
			struct bufferevent	*f_bufev;
			struct tls		*f_ctx;
			char			*f_host;
			int			 f_reconnectwait;
			int			 f_dropped;
		} f_forw;		/* forwarding address */
		char	f_fname[PATH_MAX];
		struct {
			char	f_mname[MAX_MEMBUF_NAME];
			struct ringbuf *f_rb;
			int	f_overflow;
			int	f_attached;
			size_t	f_len;
		} f_mb;		/* Memory buffer */
	} f_un;
	char	f_prevline[MAXSVLINE];		/* last message logged */
	char	f_lasttime[33];			/* time of last occurrence */
	char	f_prevhost[HOST_NAME_MAX+1];	/* host from which recd. */
	int	f_prevpri;			/* pri of f_prevline */
	int	f_prevlen;			/* length of f_prevline */
	int	f_prevcount;			/* repetition cnt of prevline */
	unsigned int f_repeatcount;		/* number of "repeated" msgs */
	int	f_quick;			/* abort when matched */
	time_t	f_lasterrtime;			/* last error was reported */
};

/*
 * Intervals at which we flush out "message repeated" messages,
 * in seconds after previous message is logged.  After each flush,
 * we move to the next interval until we reach the largest.
 */
int	repeatinterval[] = { 30, 120, 600 };	/* # of secs before flush */
#define	MAXREPEAT ((sizeof(repeatinterval) / sizeof(repeatinterval[0])) - 1)
#define	REPEATTIME(f)	((f)->f_time + repeatinterval[(f)->f_repeatcount])
#define	BACKOFF(f)	{ if (++(f)->f_repeatcount > MAXREPEAT) \
				(f)->f_repeatcount = MAXREPEAT; \
			}

/* values for f_type */
#define F_UNUSED	0		/* unused entry */
#define F_FILE		1		/* regular file */
#define F_TTY		2		/* terminal */
#define F_CONSOLE	3		/* console terminal */
#define F_FORWUDP	4		/* remote machine via UDP */
#define F_USERS		5		/* list of users */
#define F_WALL		6		/* everyone logged on */
#define F_MEMBUF	7		/* memory buffer */
#define F_PIPE		8		/* pipe to external program */
#define F_FORWTCP	9		/* remote machine via TCP */
#define F_FORWTLS	10		/* remote machine via TLS */

char	*TypeNames[] = {
	"UNUSED",	"FILE",		"TTY",		"CONSOLE",
	"FORWUDP",	"USERS",	"WALL",		"MEMBUF",
	"PIPE",		"FORWTCP",	"FORWTLS",
};

SIMPLEQ_HEAD(filed_list, filed) Files;
struct	filed consfile;

int	nunix;			/* Number of Unix domain sockets requested */
char	**path_unix;		/* Paths to Unix domain sockets */
int	Debug;			/* debug flag */
int	Foreground;		/* run in foreground, instead of daemonizing */
char	LocalHostName[HOST_NAME_MAX+1];	/* our hostname */
char	*LocalDomain;		/* our local domain name */
int	Started = 0;		/* set after privsep */
int	Initialized = 0;	/* set when we have initialized ourselves */

int	MarkInterval = 20 * 60;	/* interval between marks in seconds */
int	MarkSeq = 0;		/* mark sequence number */
int	PrivChild = 0;		/* Exec the privileged parent process */
int	Repeat = 0;		/* 0 msg repeated, 1 in files only, 2 never */
int	SecureMode = 1;		/* when true, speak only unix domain socks */
int	NoDNS = 0;		/* when true, refrain from doing DNS lookups */
int	ZuluTime = 0;		/* display date and time in UTC ISO format */
int	IncludeHostname = 0;	/* include RFC 3164 hostnames when forwarding */
int	Family = PF_UNSPEC;	/* protocol family, may disable IPv4 or IPv6 */
char	*path_ctlsock = NULL;	/* Path to control socket */

struct	tls *server_ctx;
struct	tls_config *client_config, *server_config;
const char *CAfile = "/etc/ssl/cert.pem"; /* file containing CA certificates */
int	NoVerify = 0;		/* do not verify TLS server x509 certificate */
const char *ClientCertfile = NULL;
const char *ClientKeyfile = NULL;
const char *ServerCAfile = NULL;
int	tcpbuf_dropped = 0;	/* count messages dropped from TCP or TLS */

#define CTL_READING_CMD		1
#define CTL_WRITING_REPLY	2
#define CTL_WRITING_CONT_REPLY	3
int	ctl_state = 0;		/* What the control socket is up to */
int	membuf_drop = 0;	/* logs dropped in continuous membuf read */

/*
 * Client protocol NB. all numeric fields in network byte order
 */
#define CTL_VERSION		2

/* Request */
struct	{
	u_int32_t	version;
#define CMD_READ	1	/* Read out log */
#define CMD_READ_CLEAR	2	/* Read and clear log */
#define CMD_CLEAR	3	/* Clear log */
#define CMD_LIST	4	/* List available logs */
#define CMD_FLAGS	5	/* Query flags only */
#define CMD_READ_CONT	6	/* Read out log continuously */
	u_int32_t	cmd;
	u_int32_t	lines;
	char		logname[MAX_MEMBUF_NAME];
}	ctl_cmd;

size_t	ctl_cmd_bytes = 0;	/* number of bytes of ctl_cmd read */

/* Reply */
struct ctl_reply_hdr {
	u_int32_t	version;
#define CTL_HDR_FLAG_OVERFLOW	0x01
	u_int32_t	flags;
	/* Reply text follows, up to MAX_MEMBUF long */
};

#define CTL_HDR_LEN		(sizeof(struct ctl_reply_hdr))
#define CTL_REPLY_MAXSIZE	(CTL_HDR_LEN + MAX_MEMBUF)
#define CTL_REPLY_SIZE		(strlen(reply_text) + CTL_HDR_LEN)

char	*ctl_reply = NULL;	/* Buffer for control connection reply */
char	*reply_text;		/* Start of reply text in buffer */
size_t	ctl_reply_size = 0;	/* Number of bytes used in reply */
size_t	ctl_reply_offset = 0;	/* Number of bytes of reply written so far */

char	*linebuf;
int	 linesize;

int		 fd_ctlconn, fd_udp, fd_udp6, send_udp, send_udp6;
struct event	*ev_ctlaccept, *ev_ctlread, *ev_ctlwrite;

struct peer {
	struct buffertls	 p_buftls;
	struct bufferevent	*p_bufev;
	struct tls		*p_ctx;
	char			*p_peername;
	char			*p_hostname;
	int			 p_fd;
};
char hostname_unknown[] = "???";

void	 klog_readcb(int, short, void *);
void	 udp_readcb(int, short, void *);
void	 unix_readcb(int, short, void *);
int	 reserve_accept4(int, int, struct event *,
    void (*)(int, short, void *), struct sockaddr *, socklen_t *, int);
void	 tcp_acceptcb(int, short, void *);
void	 tls_acceptcb(int, short, void *);
void	 acceptcb(int, short, void *, int);
int	 octet_counting(struct evbuffer *, char **, int);
int	 non_transparent_framing(struct evbuffer *, char **);
void	 tcp_readcb(struct bufferevent *, void *);
void	 tcp_closecb(struct bufferevent *, short, void *);
int	 tcp_socket(struct filed *);
void	 tcp_dropcb(struct bufferevent *, void *);
void	 tcp_writecb(struct bufferevent *, void *);
void	 tcp_errorcb(struct bufferevent *, short, void *);
void	 tcp_connectcb(int, short, void *);
void	 tcp_connect_retry(struct bufferevent *, struct filed *);
int	 tcpbuf_countmsg(struct bufferevent *bufev);
void	 die_signalcb(int, short, void *);
void	 mark_timercb(int, short, void *);
void	 init_signalcb(int, short, void *);
void	 ctlsock_acceptcb(int, short, void *);
void	 ctlconn_readcb(int, short, void *);
void	 ctlconn_writecb(int, short, void *);
void	 ctlconn_logto(char *);
void	 ctlconn_cleanup(void);

struct filed *cfline(char *, char *, char *);
void	cvthname(struct sockaddr *, char *, size_t);
int	decode(const char *, const CODE *);
void	markit(void);
void	fprintlog(struct filed *, int, char *);
void	init(void);
void	logevent(int, const char *);
void	logline(int, int, char *, char *);
struct filed *find_dup(struct filed *);
size_t	parsepriority(const char *, int *);
void	printline(char *, char *);
void	printsys(char *);
void	usage(void);
void	wallmsg(struct filed *, struct iovec *);
int	loghost_parse(char *, char **, char **, char **);
int	getmsgbufsize(void);
void	address_alloc(const char *, const char *, char ***, char ***, int *);
int	socket_bind(const char *, const char *, const char *, int,
    int *, int *);
int	unix_socket(char *, int, mode_t);
void	double_sockbuf(int, int);
void	set_sockbuf(int);
void	tailify_replytext(char *, int);

int
main(int argc, char *argv[])
{
	struct timeval	 to;
	struct event	*ev_klog, *ev_sendsys, *ev_udp, *ev_udp6,
			*ev_bind, *ev_listen, *ev_tls, *ev_unix,
			*ev_hup, *ev_int, *ev_quit, *ev_term, *ev_mark;
	sigset_t	 sigmask;
	const char	*errstr;
	char		*p;
	int		 ch, i;
	int		 lockpipe[2] = { -1, -1}, pair[2], nullfd, fd;
	int		 fd_ctlsock, fd_klog, fd_sendsys, *fd_bind, *fd_listen;
	int		*fd_tls, *fd_unix, nbind, nlisten, ntls;
	char		**bind_host, **bind_port, **listen_host, **listen_port;
	char		*tls_hostport, **tls_host, **tls_port;

	/* block signal until handler is set up */
	sigemptyset(&sigmask);
	sigaddset(&sigmask, SIGHUP);
	if (sigprocmask(SIG_SETMASK, &sigmask, NULL) == -1)
		err(1, "sigprocmask block");

	if ((path_unix = malloc(sizeof(*path_unix))) == NULL)
		err(1, "malloc %s", _PATH_LOG);
	path_unix[0] = _PATH_LOG;
	nunix = 1;

	bind_host = listen_host = tls_host = NULL;
	bind_port = listen_port = tls_port = NULL;
	tls_hostport = NULL;
	nbind = nlisten = ntls = 0;

	while ((ch = getopt(argc, argv,
	    "46a:C:c:dFf:hK:k:m:nP:p:rS:s:T:U:uVZ")) != -1) {
		switch (ch) {
		case '4':		/* disable IPv6 */
			Family = PF_INET;
			break;
		case '6':		/* disable IPv4 */
			Family = PF_INET6;
			break;
		case 'a':
			if ((path_unix = reallocarray(path_unix, nunix + 1,
			    sizeof(*path_unix))) == NULL)
				err(1, "unix path %s", optarg);
			path_unix[nunix++] = optarg;
			break;
		case 'C':		/* file containing CA certificates */
			CAfile = optarg;
			break;
		case 'c':		/* file containing client certificate */
			ClientCertfile = optarg;
			break;
		case 'd':		/* debug */
			Debug++;
			break;
		case 'F':		/* foreground */
			Foreground = 1;
			break;
		case 'f':		/* configuration file */
			ConfFile = optarg;
			break;
		case 'h':		/* RFC 3164 hostnames */
			IncludeHostname = 1;
			break;
		case 'K':		/* verify client with CA file */
			ServerCAfile = optarg;
			break;
		case 'k':		/* file containing client key */
			ClientKeyfile = optarg;
			break;
		case 'm':		/* mark interval */
			MarkInterval = strtonum(optarg, 0, 365*24*60, &errstr);
			if (errstr)
				errx(1, "mark_interval %s: %s", errstr, optarg);
			MarkInterval *= 60;
			break;
		case 'n':		/* don't do DNS lookups */
			NoDNS = 1;
			break;
		case 'P':		/* used internally, exec the parent */
			PrivChild = strtonum(optarg, 2, INT_MAX, &errstr);
			if (errstr)
				errx(1, "priv child %s: %s", errstr, optarg);
			break;
		case 'p':		/* path */
			path_unix[0] = optarg;
			break;
		case 'r':
			Repeat++;
			break;
		case 'S':		/* allow tls and listen on address */
			if (tls_hostport == NULL)
				tls_hostport = optarg;
			address_alloc("tls", optarg, &tls_host, &tls_port,
			    &ntls);
			break;
		case 's':
			path_ctlsock = optarg;
			break;
		case 'T':		/* allow tcp and listen on address */
			address_alloc("listen", optarg, &listen_host,
			    &listen_port, &nlisten);
			break;
		case 'U':		/* allow udp only from address */
			address_alloc("bind", optarg, &bind_host, &bind_port,
			    &nbind);
			break;
		case 'u':		/* allow udp input port */
			SecureMode = 0;
			break;
		case 'V':		/* do not verify certificates */
			NoVerify = 1;
			break;
		case 'Z':		/* time stamps in UTC ISO format */
			ZuluTime = 1;
			break;
		default:
			usage();
		}
	}
	if (argc != optind)
		usage();

	log_init(Debug, LOG_SYSLOG);
	log_procinit("syslogd");
	if (Debug)
		setvbuf(stdout, NULL, _IOLBF, 0);

	if ((nullfd = open(_PATH_DEVNULL, O_RDWR)) == -1)
		fatal("open %s", _PATH_DEVNULL);
	for (fd = nullfd + 1; fd <= STDERR_FILENO; fd++) {
		if (fcntl(fd, F_GETFL) == -1 && errno == EBADF)
			if (dup2(nullfd, fd) == -1)
				fatal("dup2 null");
	}

	if (PrivChild > 1)
		priv_exec(ConfFile, NoDNS, PrivChild, argc, argv);

	consfile.f_type = F_CONSOLE;
	(void)strlcpy(consfile.f_un.f_fname, ctty,
	    sizeof(consfile.f_un.f_fname));
	(void)gethostname(LocalHostName, sizeof(LocalHostName));
	if ((p = strchr(LocalHostName, '.')) != NULL) {
		*p++ = '\0';
		LocalDomain = p;
	} else
		LocalDomain = "";

	/* Reserve space for kernel message buffer plus buffer full message. */
	linesize = getmsgbufsize() + 64;
	if (linesize < LOG_MAXLINE)
		linesize = LOG_MAXLINE;
	linesize++;
	if ((linebuf = malloc(linesize)) == NULL)
		fatal("allocate line buffer");

	if (socket_bind("udp", NULL, "syslog", SecureMode,
	    &fd_udp, &fd_udp6) == -1)
		log_warnx("socket bind * failed");
	if ((fd_bind = reallocarray(NULL, nbind, sizeof(*fd_bind))) == NULL)
		fatal("allocate bind fd");
	for (i = 0; i < nbind; i++) {
		if (socket_bind("udp", bind_host[i], bind_port[i], 0,
		    &fd_bind[i], &fd_bind[i]) == -1)
			log_warnx("socket bind udp failed");
	}
	if ((fd_listen = reallocarray(NULL, nlisten, sizeof(*fd_listen)))
	    == NULL)
		fatal("allocate listen fd");
	for (i = 0; i < nlisten; i++) {
		if (socket_bind("tcp", listen_host[i], listen_port[i], 0,
		    &fd_listen[i], &fd_listen[i]) == -1)
			log_warnx("socket listen tcp failed");
	}
	if ((fd_tls = reallocarray(NULL, ntls, sizeof(*fd_tls))) == NULL)
		fatal("allocate tls fd");
	for (i = 0; i < ntls; i++) {
		if (socket_bind("tls", tls_host[i], tls_port[i], 0,
		    &fd_tls[i], &fd_tls[i]) == -1)
			log_warnx("socket listen tls failed");
	}

	if ((fd_unix = reallocarray(NULL, nunix, sizeof(*fd_unix))) == NULL)
		fatal("allocate unix fd");
	for (i = 0; i < nunix; i++) {
		fd_unix[i] = unix_socket(path_unix[i], SOCK_DGRAM, 0666);
		if (fd_unix[i] == -1) {
			if (i == 0)
				log_warnx("log socket %s failed", path_unix[i]);
			continue;
		}
		double_sockbuf(fd_unix[i], SO_RCVBUF);
	}

	if (socketpair(AF_UNIX, SOCK_DGRAM, PF_UNSPEC, pair) == -1) {
		log_warn("socketpair sendsyslog");
		fd_sendsys = -1;
	} else {
		double_sockbuf(pair[0], SO_RCVBUF);
		double_sockbuf(pair[1], SO_SNDBUF);
		fd_sendsys = pair[0];
	}

	fd_ctlsock = fd_ctlconn = -1;
	if (path_ctlsock != NULL) {
		fd_ctlsock = unix_socket(path_ctlsock, SOCK_STREAM, 0600);
		if (fd_ctlsock == -1) {
			log_warnx("control socket %s failed", path_ctlsock);
		} else {
			if (listen(fd_ctlsock, 5) == -1) {
				log_warn("listen control socket");
				close(fd_ctlsock);
				fd_ctlsock = -1;
			}
		}
	}

	if ((fd_klog = open(_PATH_KLOG, O_RDONLY, 0)) == -1) {
		log_warn("open %s", _PATH_KLOG);
	} else if (fd_sendsys != -1) {
		if (ioctl(fd_klog, LIOCSFD, &pair[1]) == -1)
			log_warn("ioctl klog LIOCSFD sendsyslog");
	}
	if (fd_sendsys != -1)
		close(pair[1]);

	if (tls_init() == -1) {
		log_warn("tls_init");
	} else {
		if ((client_config = tls_config_new()) == NULL)
			log_warn("tls_config_new client");
		if (tls_hostport) {
			if ((server_config = tls_config_new()) == NULL)
				log_warn("tls_config_new server");
			if ((server_ctx = tls_server()) == NULL) {
				log_warn("tls_server");
				for (i = 0; i < ntls; i++)
					close(fd_tls[i]);
				free(fd_tls);
				fd_tls = NULL;
				free(tls_host);
				free(tls_port);
				tls_host = tls_port = NULL;
				ntls = 0;
			}
		}
	}
	if (client_config) {
		if (NoVerify) {
			tls_config_insecure_noverifycert(client_config);
			tls_config_insecure_noverifyname(client_config);
		} else {
			if (tls_config_set_ca_file(client_config,
			    CAfile) == -1) {
				log_warnx("load client TLS CA: %s",
				    tls_config_error(client_config));
				/* avoid reading default certs in chroot */
				tls_config_set_ca_mem(client_config, "", 0);
			} else
				log_debug("CAfile %s", CAfile);
		}
		if (ClientCertfile && ClientKeyfile) {
			if (tls_config_set_cert_file(client_config,
			    ClientCertfile) == -1)
				log_warnx("load client TLS cert: %s",
				    tls_config_error(client_config));
			else
				log_debug("ClientCertfile %s", ClientCertfile);

			if (tls_config_set_key_file(client_config,
			    ClientKeyfile) == -1)
				log_warnx("load client TLS key: %s",
				    tls_config_error(client_config));
			else
				log_debug("ClientKeyfile %s", ClientKeyfile);
		} else if (ClientCertfile || ClientKeyfile) {
			log_warnx("options -c and -k must be used together");
		}
		if (tls_config_set_protocols(client_config,
		    TLS_PROTOCOLS_ALL) != 0)
			log_warnx("set client TLS protocols: %s",
			    tls_config_error(client_config));
		if (tls_config_set_ciphers(client_config, "all") != 0)
			log_warnx("set client TLS ciphers: %s",
			    tls_config_error(client_config));
	}
	if (server_config && server_ctx) {
		const char *names[2];

		names[0] = tls_hostport;
		names[1] = tls_host[0];

		for (i = 0; i < 2; i++) {
			if (asprintf(&p, "/etc/ssl/private/%s.key", names[i])
			    == -1)
				continue;
			if (tls_config_set_key_file(server_config, p) == -1) {
				log_warnx("load server TLS key: %s",
				    tls_config_error(server_config));
				free(p);
				continue;
			}
			log_debug("Keyfile %s", p);
			free(p);
			if (asprintf(&p, "/etc/ssl/%s.crt", names[i]) == -1)
				continue;
			if (tls_config_set_cert_file(server_config, p) == -1) {
				log_warnx("load server TLS cert: %s",
				    tls_config_error(server_config));
				free(p);
				continue;
			}
			log_debug("Certfile %s", p);
			free(p);
			break;
		}

		if (ServerCAfile) {
			if (tls_config_set_ca_file(server_config,
			    ServerCAfile) == -1) {
				log_warnx("load server TLS CA: %s",
				    tls_config_error(server_config));
				/* avoid reading default certs in chroot */
				tls_config_set_ca_mem(server_config, "", 0);
			} else
				log_debug("Server CAfile %s", ServerCAfile);
			tls_config_verify_client(server_config);
		}
		if (tls_config_set_protocols(server_config,
		    TLS_PROTOCOLS_ALL) != 0)
			log_warnx("set server TLS protocols: %s",
			    tls_config_error(server_config));
		if (tls_config_set_ciphers(server_config, "compat") != 0)
			log_warnx("Set server TLS ciphers: %s",
			    tls_config_error(server_config));
		if (tls_configure(server_ctx, server_config) != 0) {
			log_warnx("tls_configure server: %s",
			    tls_error(server_ctx));
			tls_free(server_ctx);
			server_ctx = NULL;
			for (i = 0; i < ntls; i++)
				close(fd_tls[i]);
			free(fd_tls);
			fd_tls = NULL;
			free(tls_host);
			free(tls_port);
			tls_host = tls_port = NULL;
			ntls = 0;
		}
	}

	log_debug("off & running....");

	if (!Debug && !Foreground) {
		char c;

		pipe(lockpipe);

		switch(fork()) {
		case -1:
			err(1, "fork");
		case 0:
			setsid();
			close(lockpipe[0]);
			break;
		default:
			close(lockpipe[1]);
			read(lockpipe[0], &c, 1);
			_exit(0);
		}
	}

	/* tuck my process id away */
	if (!Debug) {
		FILE *fp;

		fp = fopen(_PATH_LOGPID, "w");
		if (fp != NULL) {
			fprintf(fp, "%ld\n", (long)getpid());
			(void) fclose(fp);
		}
	}

	/* Privilege separation begins here */
	priv_init(lockpipe[1], nullfd, argc, argv);

	if (pledge("stdio unix inet recvfd", NULL) == -1)
		err(1, "pledge");

	Started = 1;

	/* Process is now unprivileged and inside a chroot */
	if (Debug)
		event_set_log_callback(logevent);
	event_init();

	if ((ev_ctlaccept = malloc(sizeof(struct event))) == NULL ||
	    (ev_ctlread = malloc(sizeof(struct event))) == NULL ||
	    (ev_ctlwrite = malloc(sizeof(struct event))) == NULL ||
	    (ev_klog = malloc(sizeof(struct event))) == NULL ||
	    (ev_sendsys = malloc(sizeof(struct event))) == NULL ||
	    (ev_udp = malloc(sizeof(struct event))) == NULL ||
	    (ev_udp6 = malloc(sizeof(struct event))) == NULL ||
	    (ev_bind = reallocarray(NULL, nbind, sizeof(struct event)))
		== NULL ||
	    (ev_listen = reallocarray(NULL, nlisten, sizeof(struct event)))
		== NULL ||
	    (ev_tls = reallocarray(NULL, ntls, sizeof(struct event)))
		== NULL ||
	    (ev_unix = reallocarray(NULL, nunix, sizeof(struct event)))
		== NULL ||
	    (ev_hup = malloc(sizeof(struct event))) == NULL ||
	    (ev_int = malloc(sizeof(struct event))) == NULL ||
	    (ev_quit = malloc(sizeof(struct event))) == NULL ||
	    (ev_term = malloc(sizeof(struct event))) == NULL ||
	    (ev_mark = malloc(sizeof(struct event))) == NULL)
		err(1, "malloc");

	event_set(ev_ctlaccept, fd_ctlsock, EV_READ|EV_PERSIST,
	    ctlsock_acceptcb, ev_ctlaccept);
	event_set(ev_ctlread, fd_ctlconn, EV_READ|EV_PERSIST,
	    ctlconn_readcb, ev_ctlread);
	event_set(ev_ctlwrite, fd_ctlconn, EV_WRITE|EV_PERSIST,
	    ctlconn_writecb, ev_ctlwrite);
	event_set(ev_klog, fd_klog, EV_READ|EV_PERSIST, klog_readcb, ev_klog);
	event_set(ev_sendsys, fd_sendsys, EV_READ|EV_PERSIST, unix_readcb,
	    ev_sendsys);
	event_set(ev_udp, fd_udp, EV_READ|EV_PERSIST, udp_readcb, ev_udp);
	event_set(ev_udp6, fd_udp6, EV_READ|EV_PERSIST, udp_readcb, ev_udp6);
	for (i = 0; i < nbind; i++)
		event_set(&ev_bind[i], fd_bind[i], EV_READ|EV_PERSIST,
		    udp_readcb, &ev_bind[i]);
	for (i = 0; i < nlisten; i++)
		event_set(&ev_listen[i], fd_listen[i], EV_READ|EV_PERSIST,
		    tcp_acceptcb, &ev_listen[i]);
	for (i = 0; i < ntls; i++)
		event_set(&ev_tls[i], fd_tls[i], EV_READ|EV_PERSIST,
		    tls_acceptcb, &ev_tls[i]);
	for (i = 0; i < nunix; i++)
		event_set(&ev_unix[i], fd_unix[i], EV_READ|EV_PERSIST,
		    unix_readcb, &ev_unix[i]);

	signal_set(ev_hup, SIGHUP, init_signalcb, ev_hup);
	signal_set(ev_int, SIGINT, die_signalcb, ev_int);
	signal_set(ev_quit, SIGQUIT, die_signalcb, ev_quit);
	signal_set(ev_term, SIGTERM, die_signalcb, ev_term);

	evtimer_set(ev_mark, mark_timercb, ev_mark);

	init();

	/* Allocate ctl socket reply buffer if we have a ctl socket */
	if (fd_ctlsock != -1 &&
	    (ctl_reply = malloc(CTL_REPLY_MAXSIZE)) == NULL)
		fatal("allocate control socket reply buffer");
	reply_text = ctl_reply + CTL_HDR_LEN;

	if (!Debug) {
		close(lockpipe[1]);
		dup2(nullfd, STDIN_FILENO);
		dup2(nullfd, STDOUT_FILENO);
		dup2(nullfd, STDERR_FILENO);
	}
	if (nullfd > 2)
		close(nullfd);

	/*
	 * Signal to the priv process that the initial config parsing is done
	 * so that it will reject any future attempts to open more files
	 */
	priv_config_parse_done();

	if (fd_ctlsock != -1)
		event_add(ev_ctlaccept, NULL);
	if (fd_klog != -1)
		event_add(ev_klog, NULL);
	if (fd_sendsys != -1)
		event_add(ev_sendsys, NULL);
	if (!SecureMode) {
		if (fd_udp != -1)
			event_add(ev_udp, NULL);
		if (fd_udp6 != -1)
			event_add(ev_udp6, NULL);
	} else {
		/*
		 * If generic UDP file descriptors are used neither
		 * for receiving nor for sending, close them.  Then
		 * there is no useless *.514 in netstat.
		 */
		if (fd_udp != -1 && !send_udp) {
			close(fd_udp);
			fd_udp = -1;
		}
		if (fd_udp6 != -1 && !send_udp6) {
			close(fd_udp6);
			fd_udp6 = -1;
		}
	}
	for (i = 0; i < nbind; i++)
		if (fd_bind[i] != -1)
			event_add(&ev_bind[i], NULL);
	for (i = 0; i < nlisten; i++)
		if (fd_listen[i] != -1)
			event_add(&ev_listen[i], NULL);
	for (i = 0; i < ntls; i++)
		if (fd_tls[i] != -1)
			event_add(&ev_tls[i], NULL);
	for (i = 0; i < nunix; i++)
		if (fd_unix[i] != -1)
			event_add(&ev_unix[i], NULL);

	signal_add(ev_hup, NULL);
	signal_add(ev_term, NULL);
	if (Debug) {
		signal_add(ev_int, NULL);
		signal_add(ev_quit, NULL);
	} else {
		(void)signal(SIGINT, SIG_IGN);
		(void)signal(SIGQUIT, SIG_IGN);
	}
	(void)signal(SIGCHLD, SIG_IGN);
	(void)signal(SIGPIPE, SIG_IGN);

	to.tv_sec = TIMERINTVL;
	to.tv_usec = 0;
	evtimer_add(ev_mark, &to);

	log_info(LOG_INFO, "start");
	log_debug("syslogd: started");

	sigemptyset(&sigmask);
	if (sigprocmask(SIG_SETMASK, &sigmask, NULL) == -1)
		err(1, "sigprocmask unblock");

	event_dispatch();
	/* NOTREACHED */
	return (0);
}

void
address_alloc(const char *name, const char *address, char ***host,
    char ***port, int *num)
{
	char *p;

	/* do not care about memory leak, argv has to be preserved */
	if ((p = strdup(address)) == NULL)
		err(1, "%s address %s", name, address);
	if ((*host = reallocarray(*host, *num + 1, sizeof(**host))) == NULL)
		err(1, "%s host %s", name, address);
	if ((*port = reallocarray(*port, *num + 1, sizeof(**port))) == NULL)
		err(1, "%s port %s", name, address);
	if (loghost_parse(p, NULL, *host + *num, *port + *num) == -1)
		errx(1, "bad %s address: %s", name, address);
	(*num)++;
}

int
socket_bind(const char *proto, const char *host, const char *port,
    int shutread, int *fd, int *fd6)
{
	struct addrinfo	 hints, *res, *res0;
	char		 hostname[NI_MAXHOST], servname[NI_MAXSERV];
	int		*fdp, error, reuseaddr;

	*fd = *fd6 = -1;
	if (proto == NULL)
		proto = "udp";
	if (port == NULL)
		port = strcmp(proto, "tls") == 0 ? "syslog-tls" : "syslog";

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = Family;
	if (strcmp(proto, "udp") == 0) {
		hints.ai_socktype = SOCK_DGRAM;
		hints.ai_protocol = IPPROTO_UDP;
	} else {
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_protocol = IPPROTO_TCP;
	}
	hints.ai_flags = AI_PASSIVE;

	if ((error = getaddrinfo(host, port, &hints, &res0))) {
		log_warnx("getaddrinfo proto %s, host %s, port %s: %s",
		    proto, host ? host : "*", port, gai_strerror(error));
		return (-1);
	}

	for (res = res0; res; res = res->ai_next) {
		switch (res->ai_family) {
		case AF_INET:
			fdp = fd;
			break;
		case AF_INET6:
			fdp = fd6;
			break;
		default:
			continue;
		}
		if (*fdp >= 0)
			continue;

		if ((*fdp = socket(res->ai_family,
		    res->ai_socktype | SOCK_NONBLOCK, res->ai_protocol)) == -1)
			continue;

		if (getnameinfo(res->ai_addr, res->ai_addrlen, hostname,
		    sizeof(hostname), servname, sizeof(servname),
		    NI_NUMERICHOST | NI_NUMERICSERV |
		    (res->ai_socktype == SOCK_DGRAM ? NI_DGRAM : 0)) != 0) {
			log_debug("Malformed bind address");
			hostname[0] = servname[0] = '\0';
		}
		if (shutread && shutdown(*fdp, SHUT_RD) == -1) {
			log_warn("shutdown SHUT_RD "
			    "protocol %d, address %s, portnum %s",
			    res->ai_protocol, hostname, servname);
			close(*fdp);
			*fdp = -1;
			continue;
		}
		if (!shutread && res->ai_protocol == IPPROTO_UDP)
			double_sockbuf(*fdp, SO_RCVBUF);
		else if (res->ai_protocol == IPPROTO_TCP)
			set_sockbuf(*fdp);
		reuseaddr = 1;
		if (setsockopt(*fdp, SOL_SOCKET, SO_REUSEADDR, &reuseaddr,
		    sizeof(reuseaddr)) == -1) {
			log_warn("setsockopt SO_REUSEADDR "
			    "protocol %d, address %s, portnum %s",
			    res->ai_protocol, hostname, servname);
			close(*fdp);
			*fdp = -1;
			continue;
		}
		if (bind(*fdp, res->ai_addr, res->ai_addrlen) == -1) {
			log_warn("bind protocol %d, address %s, portnum %s",
			    res->ai_protocol, hostname, servname);
			close(*fdp);
			*fdp = -1;
			continue;
		}
		if (!shutread && res->ai_protocol == IPPROTO_TCP &&
		    listen(*fdp, 10) == -1) {
			log_warn("listen protocol %d, address %s, portnum %s",
			    res->ai_protocol, hostname, servname);
			close(*fdp);
			*fdp = -1;
			continue;
		}
	}

	freeaddrinfo(res0);

	if (*fd == -1 && *fd6 == -1)
		return (-1);
	return (0);
}

void
klog_readcb(int fd, short event, void *arg)
{
	struct event		*ev = arg;
	ssize_t			 n;

	n = read(fd, linebuf, linesize - 1);
	if (n > 0) {
		linebuf[n] = '\0';
		printsys(linebuf);
	} else if (n < 0 && errno != EINTR) {
		log_warn("read klog");
		event_del(ev);
	}
}

void
udp_readcb(int fd, short event, void *arg)
{
	struct sockaddr_storage	 sa;
	socklen_t		 salen;
	ssize_t			 n;

	salen = sizeof(sa);
	n = recvfrom(fd, linebuf, LOG_MAXLINE, 0, (struct sockaddr *)&sa,
	    &salen);
	if (n > 0) {
		char	 resolve[NI_MAXHOST];

		linebuf[n] = '\0';
		cvthname((struct sockaddr *)&sa, resolve, sizeof(resolve));
		log_debug("cvthname res: %s", resolve);
		printline(resolve, linebuf);
	} else if (n < 0 && errno != EINTR && errno != EWOULDBLOCK)
		log_warn("recvfrom udp");
}

void
unix_readcb(int fd, short event, void *arg)
{
	struct sockaddr_un	 sa;
	socklen_t		 salen;
	ssize_t			 n;

	salen = sizeof(sa);
	n = recvfrom(fd, linebuf, LOG_MAXLINE, 0, (struct sockaddr *)&sa,
	    &salen);
	if (n > 0) {
		linebuf[n] = '\0';
		printline(LocalHostName, linebuf);
	} else if (n < 0 && errno != EINTR && errno != EWOULDBLOCK)
		log_warn("recvfrom unix");
}

int
reserve_accept4(int lfd, int event, struct event *ev,
    void (*cb)(int, short, void *),
    struct sockaddr *sa, socklen_t *salen, int flags)
{
	struct timeval	 to = { 1, 0 };
	int		 afd;

	if (event & EV_TIMEOUT) {
		log_debug("Listen again");
		/* Enable the listen event, there is no timeout anymore. */
		event_set(ev, lfd, EV_READ|EV_PERSIST, cb, ev);
		event_add(ev, NULL);
		errno = EWOULDBLOCK;
		return (-1);
	}

	if (getdtablecount() + FD_RESERVE >= getdtablesize()) {
		afd = -1;
		errno = EMFILE;
	} else
		afd = accept4(lfd, sa, salen, flags);

	if (afd == -1 && (errno == ENFILE || errno == EMFILE)) {
		log_info(LOG_WARNING, "accept deferred: %s", strerror(errno));
		/*
		 * Disable the listen event and convert it to a timeout.
		 * Pass the listen file descriptor to the callback.
		 */
		event_del(ev);
		event_set(ev, lfd, 0, cb, ev);
		event_add(ev, &to);
		return (-1);
	}

	return (afd);
}

void
tcp_acceptcb(int lfd, short event, void *arg)
{
	acceptcb(lfd, event, arg, 0);
}

void
tls_acceptcb(int lfd, short event, void *arg)
{
	acceptcb(lfd, event, arg, 1);
}

void
acceptcb(int lfd, short event, void *arg, int usetls)
{
	struct event		*ev = arg;
	struct peer		*p;
	struct sockaddr_storage	 ss;
	socklen_t		 sslen;
	char			 hostname[NI_MAXHOST], servname[NI_MAXSERV];
	char			*peername;
	int			 fd;

	sslen = sizeof(ss);
	if ((fd = reserve_accept4(lfd, event, ev, tcp_acceptcb,
	    (struct sockaddr *)&ss, &sslen, SOCK_NONBLOCK)) == -1) {
		if (errno != ENFILE && errno != EMFILE &&
		    errno != EINTR && errno != EWOULDBLOCK &&
		    errno != ECONNABORTED)
			log_warn("accept tcp socket");
		return;
	}
	log_debug("Accepting tcp connection");

	if (getnameinfo((struct sockaddr *)&ss, sslen, hostname,
	    sizeof(hostname), servname, sizeof(servname),
	    NI_NUMERICHOST | NI_NUMERICSERV) != 0 ||
	    asprintf(&peername, ss.ss_family == AF_INET6 ?
	    "[%s]:%s" : "%s:%s", hostname, servname) == -1) {
		log_debug("Malformed accept address");
		peername = hostname_unknown;
	}
	log_debug("Peer addresss and port %s", peername);
	if ((p = malloc(sizeof(*p))) == NULL) {
		log_warn("allocate \"%s\"", peername);
		close(fd);
		return;
	}
	p->p_fd = fd;
	if ((p->p_bufev = bufferevent_new(fd, tcp_readcb, NULL, tcp_closecb,
	    p)) == NULL) {
		log_warn("bufferevent \"%s\"", peername);
		free(p);
		close(fd);
		return;
	}
	p->p_ctx = NULL;
	if (usetls) {
		if (tls_accept_socket(server_ctx, &p->p_ctx, fd) < 0) {
			log_warnx("tls_accept_socket \"%s\": %s",
			    peername, tls_error(server_ctx));
			bufferevent_free(p->p_bufev);
			free(p);
			close(fd);
			return;
		}
		buffertls_set(&p->p_buftls, p->p_bufev, p->p_ctx, fd);
		buffertls_accept(&p->p_buftls, fd);
		log_debug("tcp accept callback: tls context success");
	}
	if (!NoDNS && peername != hostname_unknown &&
	    priv_getnameinfo((struct sockaddr *)&ss, ss.ss_len, hostname,
	    sizeof(hostname)) != 0) {
		log_debug("Host name for accept address (%s) unknown",
		    hostname);
	}
	if (peername == hostname_unknown ||
	    (p->p_hostname = strdup(hostname)) == NULL)
		p->p_hostname = hostname_unknown;
	log_debug("Peer hostname %s", hostname);
	p->p_peername = peername;
	bufferevent_enable(p->p_bufev, EV_READ);

	log_info(LOG_DEBUG, "%s logger \"%s\" accepted",
	    p->p_ctx ? "tls" : "tcp", peername);
}

/*
 * Syslog over TCP  RFC 6587  3.4.1. Octet Counting
 */
int
octet_counting(struct evbuffer *evbuf, char **msg, int drain)
{
	char	*p, *buf, *end;
	int	 len;

	buf = EVBUFFER_DATA(evbuf);
	end = buf + EVBUFFER_LENGTH(evbuf);
	/*
	 * It can be assumed that octet-counting framing is used if a syslog
	 * frame starts with a digit.
	 */
	if (buf >= end || !isdigit((unsigned char)*buf))
		return (-1);
	/*
	 * SYSLOG-FRAME = MSG-LEN SP SYSLOG-MSG
	 * MSG-LEN is the octet count of the SYSLOG-MSG in the SYSLOG-FRAME.
	 * We support up to 5 digits in MSG-LEN, so the maximum is 99999.
	 */
	for (p = buf; p < end && p < buf + 5; p++) {
		if (!isdigit((unsigned char)*p))
			break;
	}
	if (buf >= p || p >= end || *p != ' ')
		return (-1);
	p++;
	/* Using atoi() is safe as buf starts with 1 to 5 digits and a space. */
	len = atoi(buf);
	if (drain)
		log_debugadd(" octet counting %d", len);
	if (p + len > end)
		return (0);
	if (drain)
		evbuffer_drain(evbuf, p - buf);
	if (msg)
		*msg = p;
	return (len);
}

/*
 * Syslog over TCP  RFC 6587  3.4.2. Non-Transparent-Framing
 */
int
non_transparent_framing(struct evbuffer *evbuf, char **msg)
{
	char	*p, *buf, *end;

	buf = EVBUFFER_DATA(evbuf);
	end = buf + EVBUFFER_LENGTH(evbuf);
	/*
	 * The TRAILER has usually been a single character and most often
	 * is ASCII LF (%d10).  However, other characters have also been
	 * seen, with ASCII NUL (%d00) being a prominent example.
	 */
	for (p = buf; p < end; p++) {
		if (*p == '\0' || *p == '\n')
			break;
	}
	if (p + 1 - buf >= INT_MAX)
		return (-1);
	log_debugadd(" non transparent framing");
	if (p >= end)
		return (0);
	/*
	 * Some devices have also been seen to emit a two-character
	 * TRAILER, which is usually CR and LF.
	 */
	if (buf < p && p[0] == '\n' && p[-1] == '\r')
		p[-1] = '\0';
	if (msg)
		*msg = buf;
	return (p + 1 - buf);
}

void
tcp_readcb(struct bufferevent *bufev, void *arg)
{
	struct peer		*p = arg;
	char			*msg;
	int			 len;

	while (EVBUFFER_LENGTH(bufev->input) > 0) {
		log_debugadd("%s logger \"%s\"", p->p_ctx ? "tls" : "tcp",
		    p->p_peername);
		msg = NULL;
		len = octet_counting(bufev->input, &msg, 1);
		if (len < 0)
			len = non_transparent_framing(bufev->input, &msg);
		if (len < 0)
			log_debugadd("unknown method");
		if (msg == NULL) {
			log_debugadd(", incomplete frame");
			break;
		}
		log_debug(", use %d bytes", len);
		if (len > 0 && msg[len-1] == '\n')
			msg[len-1] = '\0';
		if (len == 0 || msg[len-1] != '\0') {
			memcpy(linebuf, msg, MINIMUM(len, LOG_MAXLINE));
			linebuf[MINIMUM(len, LOG_MAXLINE)] = '\0';
			msg = linebuf;
		}
		printline(p->p_hostname, msg);
		evbuffer_drain(bufev->input, len);
	}
	/* Maximum frame has 5 digits, 1 space, MAXLINE chars, 1 new line. */
	if (EVBUFFER_LENGTH(bufev->input) >= 5 + 1 + LOG_MAXLINE + 1) {
		log_debug(", use %zu bytes", EVBUFFER_LENGTH(bufev->input));
		printline(p->p_hostname, EVBUFFER_DATA(bufev->input));
		evbuffer_drain(bufev->input, -1);
	} else if (EVBUFFER_LENGTH(bufev->input) > 0)
		log_debug(", buffer %zu bytes", EVBUFFER_LENGTH(bufev->input));
}

void
tcp_closecb(struct bufferevent *bufev, short event, void *arg)
{
	struct peer		*p = arg;

	if (event & EVBUFFER_EOF) {
		log_info(LOG_DEBUG, "%s logger \"%s\" connection close",
		    p->p_ctx ? "tls" : "tcp", p->p_peername);
	} else {
		log_info(LOG_NOTICE, "%s logger \"%s\" connection error: %s",
		    p->p_ctx ? "tls" : "tcp", p->p_peername,
		    p->p_ctx ? tls_error(p->p_ctx) : strerror(errno));
	}

	if (p->p_peername != hostname_unknown)
		free(p->p_peername);
	if (p->p_hostname != hostname_unknown)
		free(p->p_hostname);
	bufferevent_free(p->p_bufev);
	close(p->p_fd);
	free(p);
}

int
tcp_socket(struct filed *f)
{
	int	 s;

	if ((s = socket(f->f_un.f_forw.f_addr.ss_family,
	    SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP)) == -1) {
		log_warn("socket \"%s\"", f->f_un.f_forw.f_loghost);
		return (-1);
	}
	set_sockbuf(s);
	if (connect(s, (struct sockaddr *)&f->f_un.f_forw.f_addr,
	    f->f_un.f_forw.f_addr.ss_len) == -1 && errno != EINPROGRESS) {
		log_warn("connect \"%s\"", f->f_un.f_forw.f_loghost);
		close(s);
		return (-1);
	}
	return (s);
}

void
tcp_dropcb(struct bufferevent *bufev, void *arg)
{
	struct filed	*f = arg;

	/*
	 * Drop data received from the forward log server.
	 */
	log_debug("loghost \"%s\" did send %zu bytes back",
	    f->f_un.f_forw.f_loghost, EVBUFFER_LENGTH(bufev->input));
	evbuffer_drain(bufev->input, -1);
}

void
tcp_writecb(struct bufferevent *bufev, void *arg)
{
	struct filed	*f = arg;

	/*
	 * Successful write, connection to server is good, reset wait time.
	 */
	log_debug("loghost \"%s\" successful write", f->f_un.f_forw.f_loghost);
	f->f_un.f_forw.f_reconnectwait = 0;

	if (f->f_un.f_forw.f_dropped > 0 &&
	    EVBUFFER_LENGTH(f->f_un.f_forw.f_bufev->output) < MAX_TCPBUF) {
		log_info(LOG_WARNING, "dropped %d message%s to loghost \"%s\"",
		    f->f_un.f_forw.f_dropped,
		    f->f_un.f_forw.f_dropped == 1 ? "" : "s",
		    f->f_un.f_forw.f_loghost);
		f->f_un.f_forw.f_dropped = 0;
	}
}

void
tcp_errorcb(struct bufferevent *bufev, short event, void *arg)
{
	struct filed	*f = arg;
	char		*p, *buf, *end;
	int		 l;
	char		 ebuf[ERRBUFSIZE];

	if (event & EVBUFFER_EOF)
		snprintf(ebuf, sizeof(ebuf), "loghost \"%s\" connection close",
		    f->f_un.f_forw.f_loghost);
	else
		snprintf(ebuf, sizeof(ebuf),
		    "loghost \"%s\" connection error: %s",
		    f->f_un.f_forw.f_loghost, f->f_un.f_forw.f_ctx ?
		    tls_error(f->f_un.f_forw.f_ctx) : strerror(errno));
	log_debug("%s", ebuf);

	/* The SIGHUP handler may also close the socket, so invalidate it. */
	if (f->f_un.f_forw.f_ctx) {
		tls_close(f->f_un.f_forw.f_ctx);
		tls_free(f->f_un.f_forw.f_ctx);
		f->f_un.f_forw.f_ctx = NULL;
	}
	close(f->f_file);
	f->f_file = -1;

	/*
	 * The messages in the output buffer may be out of sync.
	 * Check that the buffer starts with "1234 <1234 octets>\n".
	 * Otherwise remove the partial message from the beginning.
	 */
	buf = EVBUFFER_DATA(bufev->output);
	end = buf + EVBUFFER_LENGTH(bufev->output);
	if (buf < end && !((l = octet_counting(bufev->output, &p, 0)) > 0 &&
	    p[l-1] == '\n')) {
		for (p = buf; p < end; p++) {
			if (*p == '\n') {
				evbuffer_drain(bufev->output, p - buf + 1);
				break;
			}
		}
		/* Without '\n' discard everything. */
		if (p == end)
			evbuffer_drain(bufev->output, -1);
		log_debug("loghost \"%s\" dropped partial message",
		    f->f_un.f_forw.f_loghost);
		f->f_un.f_forw.f_dropped++;
	}

	tcp_connect_retry(bufev, f);

	/* Log the connection error to the fresh buffer after reconnecting. */
	log_info(LOG_WARNING, "%s", ebuf);
}

void
tcp_connectcb(int fd, short event, void *arg)
{
	struct filed		*f = arg;
	struct bufferevent	*bufev = f->f_un.f_forw.f_bufev;
	int			 s;

	if ((s = tcp_socket(f)) == -1) {
		tcp_connect_retry(bufev, f);
		return;
	}
	log_debug("tcp connect callback: socket success, event %#x", event);
	f->f_file = s;

	bufferevent_setfd(bufev, s);
	bufferevent_setcb(bufev, tcp_dropcb, tcp_writecb, tcp_errorcb, f);
	/*
	 * Although syslog is a write only protocol, enable reading from
	 * the socket to detect connection close and errors.
	 */
	bufferevent_enable(bufev, EV_READ|EV_WRITE);

	if (f->f_type == F_FORWTLS) {
		if ((f->f_un.f_forw.f_ctx = tls_client()) == NULL) {
			log_warn("tls_client \"%s\"", f->f_un.f_forw.f_loghost);
			goto error;
		}
		if (client_config &&
		    tls_configure(f->f_un.f_forw.f_ctx, client_config) == -1) {
			log_warnx("tls_configure \"%s\": %s",
			    f->f_un.f_forw.f_loghost,
			    tls_error(f->f_un.f_forw.f_ctx));
			goto error;
		}
		if (tls_connect_socket(f->f_un.f_forw.f_ctx, s,
		    f->f_un.f_forw.f_host) == -1) {
			log_warnx("tls_connect_socket \"%s\": %s",
			    f->f_un.f_forw.f_loghost,
			    tls_error(f->f_un.f_forw.f_ctx));
			goto error;
		}
		log_debug("tcp connect callback: tls context success");

		buffertls_set(&f->f_un.f_forw.f_buftls, bufev,
		    f->f_un.f_forw.f_ctx, s);
		buffertls_connect(&f->f_un.f_forw.f_buftls, s);
	}

	return;

 error:
	if (f->f_un.f_forw.f_ctx) {
		tls_free(f->f_un.f_forw.f_ctx);
		f->f_un.f_forw.f_ctx = NULL;
	}
	close(f->f_file);
	f->f_file = -1;
	tcp_connect_retry(bufev, f);
}

void
tcp_connect_retry(struct bufferevent *bufev, struct filed *f)
{
	struct timeval		 to;

	if (f->f_un.f_forw.f_reconnectwait == 0)
		f->f_un.f_forw.f_reconnectwait = 1;
	else
		f->f_un.f_forw.f_reconnectwait <<= 1;
	if (f->f_un.f_forw.f_reconnectwait > 600)
		f->f_un.f_forw.f_reconnectwait = 600;
	to.tv_sec = f->f_un.f_forw.f_reconnectwait;
	to.tv_usec = 0;

	log_debug("tcp connect retry: wait %d",
	    f->f_un.f_forw.f_reconnectwait);
	bufferevent_setfd(bufev, -1);
	/* We can reuse the write event as bufferevent is disabled. */
	evtimer_set(&bufev->ev_write, tcp_connectcb, f);
	evtimer_add(&bufev->ev_write, &to);
}

int
tcpbuf_countmsg(struct bufferevent *bufev)
{
	char	*p, *buf, *end;
	int	 i = 0;

	buf = EVBUFFER_DATA(bufev->output);
	end = buf + EVBUFFER_LENGTH(bufev->output);
	for (p = buf; p < end; p++) {
		if (*p == '\n')
			i++;
	}
	return (i);
}

void
usage(void)
{

	(void)fprintf(stderr,
	    "usage: syslogd [-46dFhnruVZ] [-a path] [-C CAfile]\n"
	    "\t[-c cert_file] [-f config_file] [-K CAfile] [-k key_file]\n"
	    "\t[-m mark_interval] [-p log_socket] [-S listen_address]\n"
	    "\t[-s reporting_socket] [-T listen_address] [-U bind_address]\n");
	exit(1);
}

/*
 * Parse a priority code of the form "<123>" into pri, and return the
 * length of the priority code including the surrounding angle brackets.
 */
size_t
parsepriority(const char *msg, int *pri)
{
	size_t nlen;
	char buf[11];
	const char *errstr;
	int maybepri;

	if (*msg++ == '<') {
		nlen = strspn(msg, "1234567890");
		if (nlen > 0 && nlen < sizeof(buf) && msg[nlen] == '>') {
			strlcpy(buf, msg, nlen + 1);
			maybepri = strtonum(buf, 0, INT_MAX, &errstr);
			if (errstr == NULL) {
				*pri = maybepri;
				return nlen + 2;
			}
		}
	}

	return 0;
}

/*
 * Take a raw input line, decode the message, and print the message
 * on the appropriate log files.
 */
void
printline(char *hname, char *msg)
{
	int pri;
	char *p, *q, line[LOG_MAXLINE + 4 + 1];  /* message, encoding, NUL */

	/* test for special codes */
	pri = DEFUPRI;
	p = msg;
	p += parsepriority(p, &pri);
	if (pri &~ (LOG_FACMASK|LOG_PRIMASK))
		pri = DEFUPRI;

	/*
	 * Don't allow users to log kernel messages.
	 * NOTE: since LOG_KERN == 0 this will also match
	 * messages with no facility specified.
	 */
	if (LOG_FAC(pri) == LOG_KERN)
		pri = LOG_USER | LOG_PRI(pri);

	for (q = line; *p && q < &line[LOG_MAXLINE]; p++) {
		if (*p == '\n')
			*q++ = ' ';
		else
			q = vis(q, *p, 0, 0);
	}
	line[LOG_MAXLINE] = *q = '\0';

	logline(pri, 0, hname, line);
}

/*
 * Take a raw input line from /dev/klog, split and format similar to syslog().
 */
void
printsys(char *msg)
{
	int c, pri, flags;
	char *lp, *p, *q, line[LOG_MAXLINE + 1];
	size_t prilen;

	(void)snprintf(line, sizeof line, "%s: ", _PATH_UNIX);
	lp = line + strlen(line);
	for (p = msg; *p != '\0'; ) {
		flags = SYNC_FILE | ADDDATE;	/* fsync file after write */
		pri = DEFSPRI;
		prilen = parsepriority(p, &pri);
		p += prilen;
		if (prilen == 0) {
			/* kernel printf's come out on console */
			flags |= IGN_CONS;
		}
		if (pri &~ (LOG_FACMASK|LOG_PRIMASK))
			pri = DEFSPRI;

		q = lp;
		while (*p && (c = *p++) != '\n' && q < &line[sizeof(line) - 4])
			q = vis(q, c, 0, 0);

		logline(pri, flags, LocalHostName, line);
	}
}

void
vlogmsg(int pri, const char *proc, const char *fmt, va_list ap)
{
	char	msg[ERRBUFSIZE];
	size_t	l;

	l = snprintf(msg, sizeof(msg), "%s[%d]: ", proc, getpid());
	if (l < sizeof(msg))
		vsnprintf(msg + l, sizeof(msg) - l, fmt, ap);
	if (!Started) {
		fprintf(stderr, "%s\n", msg);
		return;
	}
	logline(pri, ADDDATE, LocalHostName, msg);
}

struct timeval	now;

/*
 * Log a message to the appropriate log files, users, etc. based on
 * the priority.
 */
void
logline(int pri, int flags, char *from, char *msg)
{
	struct filed *f;
	int fac, msglen, prilev, i;
	char timestamp[33];
	char prog[NAME_MAX+1];

	log_debug("logline: pri 0%o, flags 0x%x, from %s, msg %s",
	    pri, flags, from, msg);

	/*
	 * Check to see if msg looks non-standard.
	 */
	timestamp[0] = '\0';
	msglen = strlen(msg);
	if ((flags & ADDDATE) == 0) {
		if (msglen >= 16 && msg[3] == ' ' && msg[6] == ' ' &&
		    msg[9] == ':' && msg[12] == ':' && msg[15] == ' ') {
			/* BSD syslog TIMESTAMP, RFC 3164 */
			strlcpy(timestamp, msg, 16);
			msg += 16;
			msglen -= 16;
			if (ZuluTime)
				flags |= ADDDATE;
		} else if (msglen >= 20 &&
		    isdigit(msg[0]) && isdigit(msg[1]) && isdigit(msg[2]) &&
		    isdigit(msg[3]) && msg[4] == '-' &&
		    isdigit(msg[5]) && isdigit(msg[6]) && msg[7] == '-' &&
		    isdigit(msg[8]) && isdigit(msg[9]) && msg[10] == 'T' &&
		    isdigit(msg[11]) && isdigit(msg[12]) && msg[13] == ':' &&
		    isdigit(msg[14]) && isdigit(msg[15]) && msg[16] == ':' &&
		    isdigit(msg[17]) && isdigit(msg[18]) && (msg[19] == '.' ||
		    msg[19] == 'Z' || msg[19] == '+' || msg[19] == '-')) {
			/* FULL-DATE "T" FULL-TIME, RFC 5424 */
			strlcpy(timestamp, msg, sizeof(timestamp));
			msg += 19;
			msglen -= 19;
			i = 0;
			if (msglen >= 3 && msg[0] == '.' && isdigit(msg[1])) {
				/* TIME-SECFRAC */
				msg += 2;
				msglen -= 2;
				i += 2;
				while(i < 7 && msglen >= 1 && isdigit(msg[0])) {
					msg++;
					msglen--;
					i++;
				}
			}
			if (msglen >= 2 && msg[0] == 'Z' && msg[1] == ' ') {
				/* "Z" */
				timestamp[20+i] = '\0';
				msg += 2;
				msglen -= 2;
			} else if (msglen >= 7 &&
			    (msg[0] == '+' || msg[0] == '-') &&
			    isdigit(msg[1]) && isdigit(msg[2]) &&
			    msg[3] == ':' &&
			    isdigit(msg[4]) && isdigit(msg[5]) &&
			    msg[6] == ' ') {
				/* TIME-NUMOFFSET */
				timestamp[25+i] = '\0';
				msg += 7;
				msglen -= 7;
			} else {
				/* invalid time format, roll back */
				timestamp[0] = '\0';
				msg -= 19 + i;
				msglen += 19 + i;
				flags |= ADDDATE;
			}
		} else if (msglen >= 2 && msg[0] == '-' && msg[1] == ' ') {
			/* NILVALUE, RFC 5424 */
			msg += 2;
			msglen -= 2;
			flags |= ADDDATE;
		} else
			flags |= ADDDATE;
	}

	(void)gettimeofday(&now, NULL);
	if (flags & ADDDATE) {
		if (ZuluTime) {
			struct tm *tm;
			size_t l;

			tm = gmtime(&now.tv_sec);
			l = strftime(timestamp, sizeof(timestamp), "%FT%T", tm);
			/*
			 * Use only millisecond precision as some time has
			 * passed since syslog(3) was called.
			 */
			snprintf(timestamp + l, sizeof(timestamp) - l,
			    ".%03ldZ", now.tv_usec / 1000);
		} else
			strlcpy(timestamp, ctime(&now.tv_sec) + 4, 16);
	}

	/* extract facility and priority level */
	if (flags & MARK)
		fac = LOG_NFACILITIES;
	else {
		fac = LOG_FAC(pri);
		if (fac >= LOG_NFACILITIES || fac < 0)
			fac = LOG_USER;
	}
	prilev = LOG_PRI(pri);

	/* extract program name */
	while (isspace((unsigned char)*msg)) {
		msg++;
		msglen--;
	}
	for (i = 0; i < NAME_MAX; i++) {
		if (!isalnum((unsigned char)msg[i]) && msg[i] != '-')
			break;
		prog[i] = msg[i];
	}
	prog[i] = 0;

	/* log the message to the particular outputs */
	if (!Initialized) {
		f = &consfile;
		f->f_file = priv_open_tty(ctty);

		if (f->f_file >= 0) {
			strlcpy(f->f_lasttime, timestamp,
			    sizeof(f->f_lasttime));
			strlcpy(f->f_prevhost, from,
			    sizeof(f->f_prevhost));
			fprintlog(f, flags, msg);
			(void)close(f->f_file);
			f->f_file = -1;
		}
		return;
	}
	SIMPLEQ_FOREACH(f, &Files, f_next) {
		/* skip messages that are incorrect priority */
		if (f->f_pmask[fac] < prilev ||
		    f->f_pmask[fac] == INTERNAL_NOPRI)
			continue;

		/* skip messages with the incorrect program or hostname */
		if (f->f_program && strcmp(prog, f->f_program) != 0)
			continue;
		if (f->f_hostname && strcmp(from, f->f_hostname) != 0)
			continue;

		if (f->f_type == F_CONSOLE && (flags & IGN_CONS))
			continue;

		/* don't output marks to recently written files */
		if ((flags & MARK) &&
		    (now.tv_sec - f->f_time) < MarkInterval / 2)
			continue;

		/*
		 * suppress duplicate lines to this file
		 */
		if ((Repeat == 0 || (Repeat == 1 &&
		    (f->f_type != F_PIPE && f->f_type != F_FORWUDP &&
		    f->f_type != F_FORWTCP && f->f_type != F_FORWTLS))) &&
		    (flags & MARK) == 0 && msglen == f->f_prevlen &&
		    !strcmp(msg, f->f_prevline) &&
		    !strcmp(from, f->f_prevhost)) {
			strlcpy(f->f_lasttime, timestamp,
			    sizeof(f->f_lasttime));
			f->f_prevcount++;
			log_debug("msg repeated %d times, %ld sec of %d",
			    f->f_prevcount, (long)(now.tv_sec - f->f_time),
			    repeatinterval[f->f_repeatcount]);
			/*
			 * If domark would have logged this by now,
			 * flush it now (so we don't hold isolated messages),
			 * but back off so we'll flush less often
			 * in the future.
			 */
			if (now.tv_sec > REPEATTIME(f)) {
				fprintlog(f, flags, (char *)NULL);
				BACKOFF(f);
			}
		} else {
			/* new line, save it */
			if (f->f_prevcount)
				fprintlog(f, 0, (char *)NULL);
			f->f_repeatcount = 0;
			f->f_prevpri = pri;
			strlcpy(f->f_lasttime, timestamp,
			    sizeof(f->f_lasttime));
			strlcpy(f->f_prevhost, from,
			    sizeof(f->f_prevhost));
			if (msglen < MAXSVLINE) {
				f->f_prevlen = msglen;
				strlcpy(f->f_prevline, msg,
				    sizeof(f->f_prevline));
				fprintlog(f, flags, (char *)NULL);
			} else {
				f->f_prevline[0] = 0;
				f->f_prevlen = 0;
				fprintlog(f, flags, msg);
			}
		}

		if (f->f_quick)
			break;
	}
}

void
fprintlog(struct filed *f, int flags, char *msg)
{
	struct iovec iov[6];
	struct iovec *v;
	int l, retryonce;
	char line[LOG_MAXLINE + 1], repbuf[80], greetings[500];

	v = iov;
	if (f->f_type == F_WALL) {
		l = snprintf(greetings, sizeof(greetings),
		    "\r\n\7Message from syslogd@@%s at %.24s ...\r\n",
		    f->f_prevhost, ctime(&now.tv_sec));
		if (l < 0 || (size_t)l >= sizeof(greetings))
			l = strlen(greetings);
		v->iov_base = greetings;
		v->iov_len = l;
		v++;
		v->iov_base = "";
		v->iov_len = 0;
		v++;
	} else if (f->f_lasttime[0] != '\0') {
		v->iov_base = f->f_lasttime;
		v->iov_len = strlen(f->f_lasttime);
		v++;
		v->iov_base = " ";
		v->iov_len = 1;
		v++;
	} else {
		v->iov_base = "";
		v->iov_len = 0;
		v++;
		v->iov_base = "";
		v->iov_len = 0;
		v++;
	}
	if (f->f_prevhost[0] != '\0') {
		v->iov_base = f->f_prevhost;
		v->iov_len = strlen(v->iov_base);
		v++;
		v->iov_base = " ";
		v->iov_len = 1;
		v++;
	} else {
		v->iov_base = "";
		v->iov_len = 0;
		v++;
		v->iov_base = "";
		v->iov_len = 0;
		v++;
	}

	if (msg) {
		v->iov_base = msg;
		v->iov_len = strlen(msg);
	} else if (f->f_prevcount > 1) {
		l = snprintf(repbuf, sizeof(repbuf),
		    "last message repeated %d times", f->f_prevcount);
		if (l < 0 || (size_t)l >= sizeof(repbuf))
			l = strlen(repbuf);
		v->iov_base = repbuf;
		v->iov_len = l;
	} else {
		v->iov_base = f->f_prevline;
		v->iov_len = f->f_prevlen;
	}
	v++;

	log_debugadd("Logging to %s", TypeNames[f->f_type]);
	f->f_time = now.tv_sec;

	switch (f->f_type) {
	case F_UNUSED:
		log_debug("%s", "");
		break;

	case F_FORWUDP:
		log_debug(" %s", f->f_un.f_forw.f_loghost);
		l = snprintf(line, MINIMUM(MAX_UDPMSG + 1, sizeof(line)),
		    "<%d>%.32s %s%s%s", f->f_prevpri, (char *)iov[0].iov_base,
		    IncludeHostname ? LocalHostName : "",
		    IncludeHostname ? " " : "",
		    (char *)iov[4].iov_base);
		if (l < 0 || (size_t)l > MINIMUM(MAX_UDPMSG, sizeof(line)))
			l = MINIMUM(MAX_UDPMSG, sizeof(line));
		if (sendto(f->f_file, line, l, 0,
		    (struct sockaddr *)&f->f_un.f_forw.f_addr,
		    f->f_un.f_forw.f_addr.ss_len) != l) {
			switch (errno) {
			case EHOSTDOWN:
			case EHOSTUNREACH:
			case ENETDOWN:
			case ENETUNREACH:
			case ENOBUFS:
			case EWOULDBLOCK:
				/* silently dropped */
				break;
			default:
				f->f_type = F_UNUSED;
				log_warn("sendto \"%s\"",
				    f->f_un.f_forw.f_loghost);
				break;
			}
		}
		break;

	case F_FORWTCP:
	case F_FORWTLS:
		log_debugadd(" %s", f->f_un.f_forw.f_loghost);
		if (EVBUFFER_LENGTH(f->f_un.f_forw.f_bufev->output) >=
		    MAX_TCPBUF) {
			log_debug(" (dropped)");
			f->f_un.f_forw.f_dropped++;
			break;
		}
		/*
		 * Syslog over TLS  RFC 5425  4.3.  Sending Data
		 * Syslog over TCP  RFC 6587  3.4.1.  Octet Counting
		 * Use an additional '\n' to split messages.  This allows
		 * buffer synchronisation, helps legacy implementations,
		 * and makes line based testing easier.
		 */
		l = snprintf(line, sizeof(line), "<%d>%.32s %s%s\n",
		    f->f_prevpri, (char *)iov[0].iov_base,
		    IncludeHostname ? LocalHostName : "",
		    IncludeHostname ? " " : "");
		if (l < 0) {
			log_debug(" (dropped snprintf)");
			f->f_un.f_forw.f_dropped++;
			break;
		}
		l = evbuffer_add_printf(f->f_un.f_forw.f_bufev->output,
		    "%zu <%d>%.32s %s%s%s\n",
		    (size_t)l + strlen(iov[4].iov_base),
		    f->f_prevpri, (char *)iov[0].iov_base,
		    IncludeHostname ? LocalHostName : "",
		    IncludeHostname ? " " : "",
		    (char *)iov[4].iov_base);
		if (l < 0) {
			log_debug(" (dropped evbuffer_add_printf)");
			f->f_un.f_forw.f_dropped++;
			break;
		}
		bufferevent_enable(f->f_un.f_forw.f_bufev, EV_WRITE);
		log_debug("%s", "");
		break;

	case F_CONSOLE:
		if (flags & IGN_CONS) {
			log_debug(" (ignored)");
			break;
		}
		/* FALLTHROUGH */

	case F_TTY:
	case F_FILE:
	case F_PIPE:
		log_debug(" %s", f->f_un.f_fname);
		if (f->f_type != F_FILE && f->f_type != F_PIPE) {
			v->iov_base = "\r\n";
			v->iov_len = 2;
		} else {
			v->iov_base = "\n";
			v->iov_len = 1;
		}
		retryonce = 0;
	again:
		if (writev(f->f_file, iov, 6) < 0) {
			int e = errno;

			/* pipe is non-blocking. log and drop message if full */
			if (e == EAGAIN && f->f_type == F_PIPE) {
				if (now.tv_sec - f->f_lasterrtime > 120) {
					f->f_lasterrtime = now.tv_sec;
					log_warn("writev \"%s\"",
					    f->f_un.f_fname);
				}
				break;
			}

			/*
			 * Check for errors on TTY's or program pipes.
			 * Errors happen due to loss of tty or died programs.
			 */
			if (e == EAGAIN) {
				/*
				 * Silently drop messages on blocked write.
				 * This can happen when logging to a locked tty.
				 */
				break;
			}

			(void)close(f->f_file);
			if ((e == EIO || e == EBADF) &&
			    f->f_type != F_FILE && f->f_type != F_PIPE &&
			    !retryonce) {
				f->f_file = priv_open_tty(f->f_un.f_fname);
				retryonce = 1;
				if (f->f_file < 0) {
					f->f_type = F_UNUSED;
					log_warn("priv_open_tty \"%s\"",
					    f->f_un.f_fname);
				} else
					goto again;
			} else if ((e == EPIPE || e == EBADF) &&
			    f->f_type == F_PIPE && !retryonce) {
				f->f_file = priv_open_log(f->f_un.f_fname);
				retryonce = 1;
				if (f->f_file < 0) {
					f->f_type = F_UNUSED;
					log_warn("priv_open_log \"%s\"",
					    f->f_un.f_fname);
				} else
					goto again;
			} else {
				f->f_type = F_UNUSED;
				f->f_file = -1;
				errno = e;
				log_warn("writev \"%s\"", f->f_un.f_fname);
			}
		} else if (flags & SYNC_FILE)
			(void)fsync(f->f_file);
		break;

	case F_USERS:
	case F_WALL:
		log_debug("%s", "");
		v->iov_base = "\r\n";
		v->iov_len = 2;
		wallmsg(f, iov);
		break;

	case F_MEMBUF:
		log_debug("%s", "");
		snprintf(line, sizeof(line), "%.32s %s %s",
		    (char *)iov[0].iov_base, (char *)iov[2].iov_base,
		    (char *)iov[4].iov_base);
		if (ringbuf_append_line(f->f_un.f_mb.f_rb, line) == 1)
			f->f_un.f_mb.f_overflow = 1;
		if (f->f_un.f_mb.f_attached)
			ctlconn_logto(line);
		break;
	}
	f->f_prevcount = 0;
}

/*
 *  WALLMSG -- Write a message to the world at large
 *
 *	Write the specified message to either the entire
 *	world, or a list of approved users.
 */
void
wallmsg(struct filed *f, struct iovec *iov)
{
	struct utmp ut;
	char utline[sizeof(ut.ut_line) + 1];
	static int reenter;			/* avoid calling ourselves */
	FILE *uf;
	int i;

	if (reenter++)
		return;
	if ((uf = priv_open_utmp()) == NULL) {
		log_warn("priv_open_utmp");
		reenter = 0;
		return;
	}
	while (fread(&ut, sizeof(ut), 1, uf) == 1) {
		if (ut.ut_name[0] == '\0')
			continue;
		/* must use strncpy since ut_* may not be NUL terminated */
		strncpy(utline, ut.ut_line, sizeof(utline) - 1);
		utline[sizeof(utline) - 1] = '\0';
		if (f->f_type == F_WALL) {
			ttymsg(iov, 6, utline);
			continue;
		}
		/* should we send the message to this user? */
		for (i = 0; i < MAXUNAMES; i++) {
			if (!f->f_un.f_uname[i][0])
				break;
			if (!strncmp(f->f_un.f_uname[i], ut.ut_name,
			    UT_NAMESIZE)) {
				ttymsg(iov, 6, utline);
				break;
			}
		}
	}
	(void)fclose(uf);
	reenter = 0;
}

/*
 * Return a printable representation of a host address.
 */
void
cvthname(struct sockaddr *f, char *result, size_t res_len)
{
	if (getnameinfo(f, f->sa_len, result, res_len, NULL, 0,
	    NI_NUMERICHOST|NI_NUMERICSERV|NI_DGRAM) != 0) {
		log_debug("Malformed from address");
		strlcpy(result, hostname_unknown, res_len);
		return;
	}
	log_debug("cvthname(%s)", result);
	if (NoDNS)
		return;

	if (priv_getnameinfo(f, f->sa_len, result, res_len) != 0)
		log_debug("Host name for from address (%s) unknown", result);
}

void
die_signalcb(int signum, short event, void *arg)
{
	die(signum);
}

void
mark_timercb(int unused, short event, void *arg)
{
	struct event		*ev = arg;
	struct timeval		 to;

	markit();

	to.tv_sec = TIMERINTVL;
	to.tv_usec = 0;
	evtimer_add(ev, &to);
}

void
init_signalcb(int signum, short event, void *arg)
{
	init();
	log_info(LOG_INFO, "restart");

	if (tcpbuf_dropped > 0) {
		log_info(LOG_WARNING, "dropped %d message%s to remote loghost",
		    tcpbuf_dropped, tcpbuf_dropped == 1 ? "" : "s");
		tcpbuf_dropped = 0;
	}
	log_debug("syslogd: restarted");
}

void
logevent(int severity, const char *msg)
{
	log_debug("libevent: [%d] %s", severity, msg);
}

__dead void
die(int signo)
{
	struct filed *f;
	int was_initialized = Initialized;

	Initialized = 0;		/* Don't log SIGCHLDs */
	SIMPLEQ_FOREACH(f, &Files, f_next) {
		/* flush any pending output */
		if (f->f_prevcount)
			fprintlog(f, 0, (char *)NULL);
		if (f->f_type == F_FORWTLS || f->f_type == F_FORWTCP) {
			tcpbuf_dropped += f->f_un.f_forw.f_dropped +
			    tcpbuf_countmsg(f->f_un.f_forw.f_bufev);
			f->f_un.f_forw.f_dropped = 0;
		}
	}
	Initialized = was_initialized;

	if (tcpbuf_dropped > 0) {
		log_info(LOG_WARNING, "dropped %d message%s to remote loghost",
		    tcpbuf_dropped, tcpbuf_dropped == 1 ? "" : "s");
		tcpbuf_dropped = 0;
	}

	if (signo)
		log_info(LOG_ERR, "exiting on signal %d", signo);
	log_debug("syslogd: exited");
	exit(0);
}

/*
 *  INIT -- Initialize syslogd from configuration table
 */
void
init(void)
{
	char progblock[NAME_MAX+1], hostblock[NAME_MAX+1], *cline, *p, *q;
	struct filed_list mb;
	struct filed *f, *m;
	FILE *cf;
	int i;
	size_t s;

	log_debug("init");

	/* If config file has been modified, then just die to restart */
	if (priv_config_modified()) {
		log_debug("config file changed: dying");
		die(0);
	}

	/*
	 *  Close all open log files.
	 */
	Initialized = 0;
	SIMPLEQ_INIT(&mb);
	while (!SIMPLEQ_EMPTY(&Files)) {
		f = SIMPLEQ_FIRST(&Files);
		SIMPLEQ_REMOVE_HEAD(&Files, f_next);
		/* flush any pending output */
		if (f->f_prevcount)
			fprintlog(f, 0, (char *)NULL);

		switch (f->f_type) {
		case F_FORWTLS:
			if (f->f_un.f_forw.f_ctx) {
				tls_close(f->f_un.f_forw.f_ctx);
				tls_free(f->f_un.f_forw.f_ctx);
			}
			free(f->f_un.f_forw.f_host);
			/* FALLTHROUGH */
		case F_FORWTCP:
			tcpbuf_dropped += f->f_un.f_forw.f_dropped +
			     tcpbuf_countmsg(f->f_un.f_forw.f_bufev);
			bufferevent_free(f->f_un.f_forw.f_bufev);
			/* FALLTHROUGH */
		case F_FILE:
		case F_TTY:
		case F_CONSOLE:
		case F_PIPE:
			(void)close(f->f_file);
			break;
		}
		free(f->f_program);
		free(f->f_hostname);
		if (f->f_type == F_MEMBUF) {
			f->f_program = NULL;
			f->f_hostname = NULL;
			log_debug("add %p to mb", f);
			SIMPLEQ_INSERT_HEAD(&mb, f, f_next);
		} else
			free(f);
	}
	SIMPLEQ_INIT(&Files);

	/* open the configuration file */
	if ((cf = priv_open_config()) == NULL) {
		log_debug("cannot open %s", ConfFile);
		SIMPLEQ_INSERT_TAIL(&Files,
		    cfline("*.ERR\t/dev/console", "*", "*"), f_next);
		SIMPLEQ_INSERT_TAIL(&Files,
		    cfline("*.PANIC\t*", "*", "*"), f_next);
		Initialized = 1;
		return;
	}

	/*
	 *  Foreach line in the conf table, open that file.
	 */
	cline = NULL;
	s = 0;
	strlcpy(progblock, "*", sizeof(progblock));
	strlcpy(hostblock, "*", sizeof(hostblock));
	while (getline(&cline, &s, cf) != -1) {
		/*
		 * check for end-of-section, comments, strip off trailing
		 * spaces and newline character. !progblock and +hostblock
		 * are treated specially: the following lines apply only to
		 * that program.
		 */
		for (p = cline; isspace((unsigned char)*p); ++p)
			continue;
		if (*p == '\0' || *p == '#')
			continue;
		if (*p == '!' || *p == '+') {
			q = (*p == '!') ? progblock : hostblock;
			p++;
			while (isspace((unsigned char)*p))
				p++;
			if (*p == '\0' || (*p == '*' && (p[1] == '\0' ||
			    isspace((unsigned char)p[1])))) {
				strlcpy(q, "*", NAME_MAX+1);
				continue;
			}
			for (i = 0; i < NAME_MAX; i++) {
				if (*p == '\0' || isspace((unsigned char)*p))
					break;
				*q++ = *p++;
			}
			*q = '\0';
			continue;
		}

		p = cline + strlen(cline);
		while (p > cline)
			if (!isspace((unsigned char)*--p)) {
				p++;
				break;
			}
		*p = '\0';
		f = cfline(cline, progblock, hostblock);
		if (f != NULL)
			SIMPLEQ_INSERT_TAIL(&Files, f, f_next);
	}
	free(cline);
	if (!feof(cf))
		fatal("read config file");

	/* Match and initialize the memory buffers */
	SIMPLEQ_FOREACH(f, &Files, f_next) {
		if (f->f_type != F_MEMBUF)
			continue;
		log_debug("Initialize membuf %s at %p",
		    f->f_un.f_mb.f_mname, f);

		SIMPLEQ_FOREACH(m, &mb, f_next) {
			if (m->f_un.f_mb.f_rb == NULL)
				continue;
			if (strcmp(m->f_un.f_mb.f_mname,
			    f->f_un.f_mb.f_mname) == 0)
				break;
		}
		if (m == NULL) {
			log_debug("Membuf no match");
			f->f_un.f_mb.f_rb = ringbuf_init(f->f_un.f_mb.f_len);
			if (f->f_un.f_mb.f_rb == NULL) {
				f->f_type = F_UNUSED;
				log_warn("allocate membuf");
			}
		} else {
			log_debug("Membuf match f:%p, m:%p", f, m);
			f->f_un = m->f_un;
			m->f_un.f_mb.f_rb = NULL;
		}
	}

	/* make sure remaining buffers are freed */
	while (!SIMPLEQ_EMPTY(&mb)) {
		m = SIMPLEQ_FIRST(&mb);
		SIMPLEQ_REMOVE_HEAD(&mb, f_next);
		if (m->f_un.f_mb.f_rb != NULL) {
			log_warnx("mismatched membuf");
			ringbuf_free(m->f_un.f_mb.f_rb);
		}
		log_debug("Freeing membuf %p", m);

		free(m);
	}

	/* close the configuration file */
	(void)fclose(cf);

	Initialized = 1;

	if (Debug) {
		SIMPLEQ_FOREACH(f, &Files, f_next) {
			for (i = 0; i <= LOG_NFACILITIES; i++)
				if (f->f_pmask[i] == INTERNAL_NOPRI)
					printf("X ");
				else
					printf("%d ", f->f_pmask[i]);
			printf("%s: ", TypeNames[f->f_type]);
			switch (f->f_type) {
			case F_FILE:
			case F_TTY:
			case F_CONSOLE:
			case F_PIPE:
				printf("%s", f->f_un.f_fname);
				break;

			case F_FORWUDP:
			case F_FORWTCP:
			case F_FORWTLS:
				printf("%s", f->f_un.f_forw.f_loghost);
				break;

			case F_USERS:
				for (i = 0; i < MAXUNAMES &&
				    *f->f_un.f_uname[i]; i++)
					printf("%s, ", f->f_un.f_uname[i]);
				break;

			case F_MEMBUF:
				printf("%s", f->f_un.f_mb.f_mname);
				break;

			}
			if (f->f_program || f->f_hostname)
				printf(" (%s, %s)",
				    f->f_program ? f->f_program : "*",
				    f->f_hostname ? f->f_hostname : "*");
			printf("\n");
		}
	}
}

#define progmatches(p1, p2) \
	(p1 == p2 || (p1 != NULL && p2 != NULL && strcmp(p1, p2) == 0))

/*
 * Spot a line with a duplicate file, pipe, console, tty, or membuf target.
 */
struct filed *
find_dup(struct filed *f)
{
	struct filed *list;

	SIMPLEQ_FOREACH(list, &Files, f_next) {
		if (list->f_quick || f->f_quick)
			continue;
		switch (list->f_type) {
		case F_FILE:
		case F_TTY:
		case F_CONSOLE:
		case F_PIPE:
			if (strcmp(list->f_un.f_fname, f->f_un.f_fname) == 0 &&
			    progmatches(list->f_program, f->f_program) &&
			    progmatches(list->f_hostname, f->f_hostname)) {
				log_debug("duplicate %s", f->f_un.f_fname);
				return (list);
			}
			break;
		case F_MEMBUF:
			if (strcmp(list->f_un.f_mb.f_mname,
			    f->f_un.f_mb.f_mname) == 0 &&
			    progmatches(list->f_program, f->f_program) &&
			    progmatches(list->f_hostname, f->f_hostname)) {
				log_debug("duplicate membuf %s",
				    f->f_un.f_mb.f_mname);
				return (list);
			}
			break;
		}
	}
	return (NULL);
}

/*
 * Crack a configuration file line
 */
struct filed *
cfline(char *line, char *progblock, char *hostblock)
{
	int i, pri;
	size_t rb_len;
	char *bp, *p, *q, *proto, *host, *port, *ipproto;
	char buf[LOG_MAXLINE];
	struct filed *xf, *f, *d;
	struct timeval to;

	log_debug("cfline(\"%s\", f, \"%s\", \"%s\")",
	    line, progblock, hostblock);

	if ((f = calloc(1, sizeof(*f))) == NULL)
		fatal("allocate struct filed");
	for (i = 0; i <= LOG_NFACILITIES; i++)
		f->f_pmask[i] = INTERNAL_NOPRI;

	/* save program name if any */
	f->f_quick = 0;
	if (*progblock == '!') {
		progblock++;
		f->f_quick = 1;
	}
	if (*hostblock == '+') {
		hostblock++;
		f->f_quick = 1;
	}
	if (strcmp(progblock, "*") != 0)
		f->f_program = strdup(progblock);
	if (strcmp(hostblock, "*") != 0)
		f->f_hostname = strdup(hostblock);

	/* scan through the list of selectors */
	for (p = line; *p && *p != '\t' && *p != ' ';) {

		/* find the end of this facility name list */
		for (q = p; *q && *q != '\t' && *q != ' ' && *q++ != '.'; )
			continue;

		/* collect priority name */
		for (bp = buf; *q && !strchr("\t,; ", *q); )
			*bp++ = *q++;
		*bp = '\0';

		/* skip cruft */
		while (*q && strchr(",;", *q))
			q++;

		/* decode priority name */
		if (*buf == '*')
			pri = LOG_PRIMASK + 1;
		else {
			/* ignore trailing spaces */
			for (i=strlen(buf)-1; i >= 0 && buf[i] == ' '; i--) {
				buf[i]='\0';
			}

			pri = decode(buf, prioritynames);
			if (pri < 0) {
				log_warnx("unknown priority name \"%s\"", buf);
				free(f);
				return (NULL);
			}
		}

		/* scan facilities */
		while (*p && !strchr("\t.; ", *p)) {
			for (bp = buf; *p && !strchr("\t,;. ", *p); )
				*bp++ = *p++;
			*bp = '\0';
			if (*buf == '*')
				for (i = 0; i < LOG_NFACILITIES; i++)
					f->f_pmask[i] = pri;
			else {
				i = decode(buf, facilitynames);
				if (i < 0) {
					log_warnx("unknown facility name "
					    "\"%s\"", buf);
					free(f);
					return (NULL);
				}
				f->f_pmask[i >> 3] = pri;
			}
			while (*p == ',' || *p == ' ')
				p++;
		}

		p = q;
	}

	/* skip to action part */
	while (*p == '\t' || *p == ' ')
		p++;

	switch (*p) {
	case '@@':
		if ((strlcpy(f->f_un.f_forw.f_loghost, p,
		    sizeof(f->f_un.f_forw.f_loghost)) >=
		    sizeof(f->f_un.f_forw.f_loghost))) {
			log_warnx("loghost too long \"%s\"", p);
			break;
		}
		if (loghost_parse(++p, &proto, &host, &port) == -1) {
			log_warnx("bad loghost \"%s\"",
			    f->f_un.f_forw.f_loghost);
			break;
		}
		if (proto == NULL)
			proto = "udp";
		ipproto = proto;
		if (strcmp(proto, "udp") == 0) {
			if (fd_udp == -1)
				proto = "udp6";
			if (fd_udp6 == -1)
				proto = "udp4";
			ipproto = proto;
		} else if (strcmp(proto, "udp4") == 0) {
			if (fd_udp == -1) {
				log_warnx("no udp4 \"%s\"",
				    f->f_un.f_forw.f_loghost);
				break;
			}
		} else if (strcmp(proto, "udp6") == 0) {
			if (fd_udp6 == -1) {
				log_warnx("no udp6 \"%s\"",
				    f->f_un.f_forw.f_loghost);
				break;
			}
		} else if (strcmp(proto, "tcp") == 0 ||
		    strcmp(proto, "tcp4") == 0 || strcmp(proto, "tcp6") == 0) {
			;
		} else if (strcmp(proto, "tls") == 0) {
			ipproto = "tcp";
		} else if (strcmp(proto, "tls4") == 0) {
			ipproto = "tcp4";
		} else if (strcmp(proto, "tls6") == 0) {
			ipproto = "tcp6";
		} else {
			log_warnx("bad protocol \"%s\"",
			    f->f_un.f_forw.f_loghost);
			break;
		}
		if (strlen(host) >= NI_MAXHOST) {
			log_warnx("host too long \"%s\"",
			    f->f_un.f_forw.f_loghost);
			break;
		}
		if (port == NULL)
			port = strncmp(proto, "tls", 3) == 0 ?
			    "syslog-tls" : "syslog";
		if (strlen(port) >= NI_MAXSERV) {
			log_warnx("port too long \"%s\"",
			    f->f_un.f_forw.f_loghost);
			break;
		}
		if (priv_getaddrinfo(ipproto, host, port,
		    (struct sockaddr*)&f->f_un.f_forw.f_addr,
		    sizeof(f->f_un.f_forw.f_addr)) != 0) {
			log_warnx("bad hostname \"%s\"",
			    f->f_un.f_forw.f_loghost);
			break;
		}
		f->f_file = -1;
		if (strncmp(proto, "udp", 3) == 0) {
			switch (f->f_un.f_forw.f_addr.ss_family) {
			case AF_INET:
				send_udp = 1;
				f->f_file = fd_udp;
				break;
			case AF_INET6:
				send_udp6 = 1;
				f->f_file = fd_udp6;
				break;
			}
			f->f_type = F_FORWUDP;
		} else if (strncmp(ipproto, "tcp", 3) == 0) {
			if ((f->f_un.f_forw.f_bufev = bufferevent_new(-1,
			    tcp_dropcb, tcp_writecb, tcp_errorcb, f)) == NULL) {
				log_warn("bufferevent \"%s\"",
				    f->f_un.f_forw.f_loghost);
				break;
			}
			if (strncmp(proto, "tls", 3) == 0) {
				f->f_un.f_forw.f_host = strdup(host);
				f->f_type = F_FORWTLS;
			} else {
				f->f_type = F_FORWTCP;
			}
			/*
			 * If we try to connect to a TLS server immediately
			 * syslogd gets an SIGPIPE as the signal handlers have
			 * not been set up.  Delay the connection until the
			 * event loop is started.  We can reuse the write event
			 * for that as bufferevent is still disabled.
			 */
			to.tv_sec = 0;
			to.tv_usec = 1;
			evtimer_set(&f->f_un.f_forw.f_bufev->ev_write,
			    tcp_connectcb, f);
			evtimer_add(&f->f_un.f_forw.f_bufev->ev_write, &to);
		}
		break;

	case '/':
	case '|':
		(void)strlcpy(f->f_un.f_fname, p, sizeof(f->f_un.f_fname));
		d = find_dup(f);
		if (d != NULL) {
			for (i = 0; i <= LOG_NFACILITIES; i++)
				if (f->f_pmask[i] != INTERNAL_NOPRI)
					d->f_pmask[i] = f->f_pmask[i];
			free(f);
			return (NULL);
		}
		if (strcmp(p, ctty) == 0) {
			f->f_file = priv_open_tty(p);
			if (f->f_file < 0)
				log_warn("priv_open_tty \"%s\"", p);
		} else {
			f->f_file = priv_open_log(p);
			if (f->f_file < 0)
				log_warn("priv_open_log \"%s\"", p);
		}
		if (f->f_file < 0) {
			f->f_type = F_UNUSED;
			break;
		}
		if (isatty(f->f_file)) {
			if (strcmp(p, ctty) == 0)
				f->f_type = F_CONSOLE;
			else
				f->f_type = F_TTY;
		} else {
			if (*p == '|')
				f->f_type = F_PIPE;
			else {
				f->f_type = F_FILE;

				/* Clear O_NONBLOCK flag on f->f_file */
				if ((i = fcntl(f->f_file, F_GETFL)) != -1) {
					i &= ~O_NONBLOCK;
					fcntl(f->f_file, F_SETFL, i);
				}
			}
		}
		break;

	case '*':
		f->f_type = F_WALL;
		break;

	case ':':
		f->f_type = F_MEMBUF;

		/* Parse buffer size (in kb) */
		errno = 0;
		rb_len = strtoul(++p, &q, 0);
		if (*p == '\0' || (errno == ERANGE && rb_len == ULONG_MAX) ||
		    *q != ':' || rb_len == 0) {
			f->f_type = F_UNUSED;
			log_warnx("strtoul \"%s\"", p);
			break;
		}
		q++;
		rb_len *= 1024;

		/* Copy buffer name */
		for(i = 0; (size_t)i < sizeof(f->f_un.f_mb.f_mname) - 1; i++) {
			if (!isalnum((unsigned char)q[i]))
				break;
			f->f_un.f_mb.f_mname[i] = q[i];
		}

		/* Make sure buffer name is unique */
		xf = find_dup(f);

		/* Error on missing or non-unique name, or bad buffer length */
		if (i == 0 || rb_len > MAX_MEMBUF || xf != NULL) {
			f->f_type = F_UNUSED;
			log_warnx("find_dup \"%s\"", p);
			break;
		}

		/* Set buffer length */
		rb_len = MAXIMUM(rb_len, MIN_MEMBUF);
		f->f_un.f_mb.f_len = rb_len;
		f->f_un.f_mb.f_overflow = 0;
		f->f_un.f_mb.f_attached = 0;
		break;

	default:
		for (i = 0; i < MAXUNAMES && *p; i++) {
			for (q = p; *q && *q != ','; )
				q++;
			(void)strncpy(f->f_un.f_uname[i], p, UT_NAMESIZE);
			if ((q - p) > UT_NAMESIZE)
				f->f_un.f_uname[i][UT_NAMESIZE] = '\0';
			else
				f->f_un.f_uname[i][q - p] = '\0';
			while (*q == ',' || *q == ' ')
				q++;
			p = q;
		}
		f->f_type = F_USERS;
		break;
	}
	return (f);
}

/*
 * Parse the host and port parts from a loghost string.
 */
int
loghost_parse(char *str, char **proto, char **host, char **port)
{
	char *prefix = NULL;

	if ((*host = strchr(str, ':')) &&
	    (*host)[1] == '/' && (*host)[2] == '/') {
		prefix = str;
		**host = '\0';
		str = *host + 3;
	}
	if (proto)
		*proto = prefix;
	else if (prefix)
		return (-1);

	*host = str;
	if (**host == '[') {
		(*host)++;
		str = strchr(*host, ']');
		if (str == NULL)
			return (-1);
		*str++ = '\0';
	}
	*port = strrchr(str, ':');
	if (*port != NULL)
		*(*port)++ = '\0';

	return (0);
}

/*
 * Retrieve the size of the kernel message buffer, via sysctl.
 */
int
getmsgbufsize(void)
{
	int msgbufsize, mib[2];
	size_t size;

	mib[0] = CTL_KERN;
	mib[1] = KERN_MSGBUFSIZE;
	size = sizeof msgbufsize;
	if (sysctl(mib, 2, &msgbufsize, &size, NULL, 0) == -1) {
		log_debug("couldn't get kern.msgbufsize");
		return (0);
	}
	return (msgbufsize);
}

/*
 *  Decode a symbolic name to a numeric value
 */
int
decode(const char *name, const CODE *codetab)
{
	const CODE *c;
	char *p, buf[40];

	for (p = buf; *name && p < &buf[sizeof(buf) - 1]; p++, name++) {
		if (isupper((unsigned char)*name))
			*p = tolower((unsigned char)*name);
		else
			*p = *name;
	}
	*p = '\0';
	for (c = codetab; c->c_name; c++)
		if (!strcmp(buf, c->c_name))
			return (c->c_val);

	return (-1);
}

void
markit(void)
{
	struct filed *f;

	(void)gettimeofday(&now, NULL);
	MarkSeq += TIMERINTVL;
	if (MarkSeq >= MarkInterval) {
		logline(LOG_INFO, ADDDATE|MARK, LocalHostName, "-- MARK --");
		MarkSeq = 0;
	}

	SIMPLEQ_FOREACH(f, &Files, f_next) {
		if (f->f_prevcount && now.tv_sec >= REPEATTIME(f)) {
			log_debug("flush %s: repeated %d times, %d sec",
			    TypeNames[f->f_type], f->f_prevcount,
			    repeatinterval[f->f_repeatcount]);
			fprintlog(f, 0, (char *)NULL);
			BACKOFF(f);
		}
	}
}

int
unix_socket(char *path, int type, mode_t mode)
{
	struct sockaddr_un s_un;
	int fd, optval;
	mode_t old_umask;

	memset(&s_un, 0, sizeof(s_un));
	s_un.sun_family = AF_UNIX;
	if (strlcpy(s_un.sun_path, path, sizeof(s_un.sun_path)) >=
	    sizeof(s_un.sun_path)) {
		log_warnx("socket path too long \"%s\"", path);
		return (-1);
	}

	if ((fd = socket(AF_UNIX, type, 0)) == -1) {
		log_warn("socket unix \"%s\"", path);
		return (-1);
	}

	if (Debug) {
		if (connect(fd, (struct sockaddr *)&s_un, sizeof(s_un)) == 0 ||
		    errno == EPROTOTYPE) {
			close(fd);
			errno = EISCONN;
			log_warn("connect unix \"%s\"", path);
			return (-1);
		}
	}

	old_umask = umask(0177);

	unlink(path);
	if (bind(fd, (struct sockaddr *)&s_un, sizeof(s_un)) == -1) {
		log_warn("bind unix \"%s\"", path);
		umask(old_umask);
		close(fd);
		return (-1);
	}

	umask(old_umask);

	if (chmod(path, mode) == -1) {
		log_warn("chmod unix \"%s\"", path);
		close(fd);
		unlink(path);
		return (-1);
	}

	optval = LOG_MAXLINE + PATH_MAX;
	if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &optval, sizeof(optval))
	    == -1)
		log_warn("setsockopt unix \"%s\"", path);

	return (fd);
}

void
double_sockbuf(int fd, int optname)
{
	socklen_t len;
	int i, newsize, oldsize = 0;

	len = sizeof(oldsize);
	if (getsockopt(fd, SOL_SOCKET, optname, &oldsize, &len) == -1)
		log_warn("getsockopt bufsize");
	len = sizeof(newsize);
	newsize =  LOG_MAXLINE + 128;  /* data + control */
	/* allow 8 full length messages */
	for (i = 0; i < 4; i++, newsize *= 2) {
		if (newsize <= oldsize)
			continue;
		if (setsockopt(fd, SOL_SOCKET, optname, &newsize, len) == -1)
			log_warn("setsockopt bufsize %d", newsize);
	}
}

void
set_sockbuf(int fd)
{
	int size = 65536;

	if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size)) == -1)
		log_warn("setsockopt sndbufsize %d", size);
	if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &size, sizeof(size)) == -1)
		log_warn("setsockopt rcvbufsize %d", size);
}

void
ctlconn_cleanup(void)
{
	struct filed *f;

	close(fd_ctlconn);
	fd_ctlconn = -1;
	event_del(ev_ctlread);
	event_del(ev_ctlwrite);
	event_add(ev_ctlaccept, NULL);

	if (ctl_state == CTL_WRITING_CONT_REPLY)
		SIMPLEQ_FOREACH(f, &Files, f_next)
			if (f->f_type == F_MEMBUF)
				f->f_un.f_mb.f_attached = 0;

	ctl_state = ctl_cmd_bytes = ctl_reply_offset = ctl_reply_size = 0;
}

void
ctlsock_acceptcb(int fd, short event, void *arg)
{
	struct event		*ev = arg;

	if ((fd = reserve_accept4(fd, event, ev, ctlsock_acceptcb,
	    NULL, NULL, SOCK_NONBLOCK)) == -1) {
		if (errno != ENFILE && errno != EMFILE &&
		    errno != EINTR && errno != EWOULDBLOCK &&
		    errno != ECONNABORTED)
			log_warn("accept control socket");
		return;
	}
	log_debug("Accepting control connection");

	if (fd_ctlconn != -1)
		ctlconn_cleanup();

	/* Only one connection at a time */
	event_del(ev);

	fd_ctlconn = fd;
	/* file descriptor has changed, reset event */
	event_set(ev_ctlread, fd_ctlconn, EV_READ|EV_PERSIST,
	    ctlconn_readcb, ev_ctlread);
	event_set(ev_ctlwrite, fd_ctlconn, EV_WRITE|EV_PERSIST,
	    ctlconn_writecb, ev_ctlwrite);
	event_add(ev_ctlread, NULL);
	ctl_state = CTL_READING_CMD;
	ctl_cmd_bytes = 0;
}

static struct filed
*find_membuf_log(const char *name)
{
	struct filed *f;

	SIMPLEQ_FOREACH(f, &Files, f_next) {
		if (f->f_type == F_MEMBUF &&
		    strcmp(f->f_un.f_mb.f_mname, name) == 0)
			break;
	}
	return (f);
}

void
ctlconn_readcb(int fd, short event, void *arg)
{
	struct filed		*f;
	struct ctl_reply_hdr	*reply_hdr = (struct ctl_reply_hdr *)ctl_reply;
	ssize_t			 n;
	u_int32_t		 flags = 0;

	if (ctl_state == CTL_WRITING_REPLY ||
	    ctl_state == CTL_WRITING_CONT_REPLY) {
		/* client has closed the connection */
		ctlconn_cleanup();
		return;
	}

 retry:
	n = read(fd, (char*)&ctl_cmd + ctl_cmd_bytes,
	    sizeof(ctl_cmd) - ctl_cmd_bytes);
	switch (n) {
	case -1:
		if (errno == EINTR)
			goto retry;
		if (errno == EWOULDBLOCK)
			return;
		log_warn("read control socket");
		/* FALLTHROUGH */
	case 0:
		ctlconn_cleanup();
		return;
	default:
		ctl_cmd_bytes += n;
	}
	if (ctl_cmd_bytes < sizeof(ctl_cmd))
		return;

	if (ntohl(ctl_cmd.version) != CTL_VERSION) {
		log_warnx("unknown client protocol version");
		ctlconn_cleanup();
		return;
	}

	/* Ensure that logname is \0 terminated */
	if (memchr(ctl_cmd.logname, '\0', sizeof(ctl_cmd.logname)) == NULL) {
		log_warnx("corrupt control socket command");
		ctlconn_cleanup();
		return;
	}

	*reply_text = '\0';

	ctl_reply_size = ctl_reply_offset = 0;
	memset(reply_hdr, '\0', sizeof(*reply_hdr));

	ctl_cmd.cmd = ntohl(ctl_cmd.cmd);
	log_debug("ctlcmd %x logname \"%s\"", ctl_cmd.cmd, ctl_cmd.logname);

	switch (ctl_cmd.cmd) {
	case CMD_READ:
	case CMD_READ_CLEAR:
	case CMD_READ_CONT:
	case CMD_FLAGS:
		f = find_membuf_log(ctl_cmd.logname);
		if (f == NULL) {
			strlcpy(reply_text, "No such log\n", MAX_MEMBUF);
		} else {
			if (ctl_cmd.cmd != CMD_FLAGS) {
				ringbuf_to_string(reply_text, MAX_MEMBUF,
				    f->f_un.f_mb.f_rb);
			}
			if (f->f_un.f_mb.f_overflow)
				flags |= CTL_HDR_FLAG_OVERFLOW;
			if (ctl_cmd.cmd == CMD_READ_CLEAR) {
				ringbuf_clear(f->f_un.f_mb.f_rb);
				f->f_un.f_mb.f_overflow = 0;
			}
			if (ctl_cmd.cmd == CMD_READ_CONT) {
				f->f_un.f_mb.f_attached = 1;
				tailify_replytext(reply_text,
				    ctl_cmd.lines > 0 ? ctl_cmd.lines : 10);
			} else if (ctl_cmd.lines > 0) {
				tailify_replytext(reply_text, ctl_cmd.lines);
			}
		}
		break;
	case CMD_CLEAR:
		f = find_membuf_log(ctl_cmd.logname);
		if (f == NULL) {
			strlcpy(reply_text, "No such log\n", MAX_MEMBUF);
		} else {
			ringbuf_clear(f->f_un.f_mb.f_rb);
			if (f->f_un.f_mb.f_overflow)
				flags |= CTL_HDR_FLAG_OVERFLOW;
			f->f_un.f_mb.f_overflow = 0;
			strlcpy(reply_text, "Log cleared\n", MAX_MEMBUF);
		}
		break;
	case CMD_LIST:
		SIMPLEQ_FOREACH(f, &Files, f_next) {
			if (f->f_type == F_MEMBUF) {
				strlcat(reply_text, f->f_un.f_mb.f_mname,
				    MAX_MEMBUF);
				if (f->f_un.f_mb.f_overflow) {
					strlcat(reply_text, "*", MAX_MEMBUF);
					flags |= CTL_HDR_FLAG_OVERFLOW;
				}
				strlcat(reply_text, " ", MAX_MEMBUF);
			}
		}
		strlcat(reply_text, "\n", MAX_MEMBUF);
		break;
	default:
		log_warnx("unsupported control socket command");
		ctlconn_cleanup();
		return;
	}
	reply_hdr->version = htonl(CTL_VERSION);
	reply_hdr->flags = htonl(flags);

	ctl_reply_size = CTL_REPLY_SIZE;
	log_debug("ctlcmd reply length %lu", (u_long)ctl_reply_size);

	/* Otherwise, set up to write out reply */
	ctl_state = (ctl_cmd.cmd == CMD_READ_CONT) ?
	    CTL_WRITING_CONT_REPLY : CTL_WRITING_REPLY;

	event_add(ev_ctlwrite, NULL);

	/* another syslogc can kick us out */
	if (ctl_state == CTL_WRITING_CONT_REPLY)
		event_add(ev_ctlaccept, NULL);
}

void
ctlconn_writecb(int fd, short event, void *arg)
{
	struct event		*ev = arg;
	ssize_t			 n;

	if (!(ctl_state == CTL_WRITING_REPLY ||
	    ctl_state == CTL_WRITING_CONT_REPLY)) {
		/* Shouldn't be here! */
		log_warnx("control socket write with bad state");
		ctlconn_cleanup();
		return;
	}

 retry:
	n = write(fd, ctl_reply + ctl_reply_offset,
	    ctl_reply_size - ctl_reply_offset);
	switch (n) {
	case -1:
		if (errno == EINTR)
			goto retry;
		if (errno == EWOULDBLOCK)
			return;
		if (errno != EPIPE)
			log_warn("write control socket");
		/* FALLTHROUGH */
	case 0:
		ctlconn_cleanup();
		return;
	default:
		ctl_reply_offset += n;
	}
	if (ctl_reply_offset < ctl_reply_size)
		return;

	if (ctl_state != CTL_WRITING_CONT_REPLY) {
		ctlconn_cleanup();
		return;
	}

	/*
	 * Make space in the buffer for continous writes.
	 * Set offset behind reply header to skip it
	 */
	*reply_text = '\0';
	ctl_reply_offset = ctl_reply_size = CTL_REPLY_SIZE;

	/* Now is a good time to report dropped lines */
	if (membuf_drop) {
		strlcat(reply_text, "<ENOBUFS>\n", MAX_MEMBUF);
		ctl_reply_size = CTL_REPLY_SIZE;
		membuf_drop = 0;
	} else {
		/* Nothing left to write */
		event_del(ev);
	}
}

/* Shorten replytext to number of lines */
void
tailify_replytext(char *replytext, int lines)
{
	char *start, *nl;
	int count = 0;
	start = nl = replytext;

	while ((nl = strchr(nl, '\n')) != NULL) {
		nl++;
		if (++count > lines) {
			start = strchr(start, '\n');
			start++;
		}
	}
	if (start != replytext) {
		int len = strlen(start);
		memmove(replytext, start, len);
		*(replytext + len) = '\0';
	}
}

void
ctlconn_logto(char *line)
{
	size_t l;

	if (membuf_drop)
		return;

	l = strlen(line);
	if (l + 2 > (CTL_REPLY_MAXSIZE - ctl_reply_size)) {
		/* remember line drops for later report */
		membuf_drop = 1;
		return;
	}
	memcpy(ctl_reply + ctl_reply_size, line, l);
	memcpy(ctl_reply + ctl_reply_size + l, "\n", 2);
	ctl_reply_size += l + 1;
	event_add(ev_ctlwrite, NULL);
}
@


1.246
log
@In the default configuration syslogd(8) kept two *:514 UDP sockets
open.  These sockets are used for sending UDP packets if there is
a UDP loghost in syslog.conf(5).  If syslogd is started with -u,
they can receive packets, otherwise they are disabled with
shutdown(SHUT_RD).  In case syslogd does neither send nor receive,
close the sockets after reading the configuration file.  This gives
us a cleaner netstat output, and the ports are not reported by port
scanners.  This has no security implication.
OK benno@@ jca@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.245 2017/08/08 14:23:23 bluhm Exp $	*/
a2047 1
			(void)close(f->f_file);
d2058 4
a2061 1
			} else if ((e == EIO || e == EBADF) &&
@


1.245
log
@Kernel sendsyslog(2), libc syslog(3), and syslogd(8) restrict and
truncate the length of a syslog message to 8192 bytes.  Use one
global define LOG_MAXLINE for all of them.
OK deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.244 2017/04/28 14:52:13 bluhm Exp $	*/
d277 1
a277 1
int		 fd_ctlconn, fd_udp, fd_udp6;
d828 14
d2676 1
d2680 1
@


1.244
log
@When syslogd(8) failed to open a logfile, the error message could
get lost.  Remove log_setdebug() as it adds too much abstraction,
use the global variable Started instead.  Set the Started value
before the init() function.  Then errors during config file processing
will be logged to the console as Initialize is still 0.  This is
better than stderr as the latter may be redirected to /dev/null.
Print the timestamp and hostname also for direct messages to console,
so that they look like all others.
bug report jung@@; OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.243 2017/04/25 17:45:50 bluhm Exp $	*/
d57 1
a57 1
#define MIN_MEMBUF	(MAXLINE * 4)	/* Minimum memory buffer size */
d495 2
a496 2
	if (linesize < MAXLINE)
		linesize = MAXLINE;
d1014 2
a1015 1
	n = recvfrom(fd, linebuf, MAXLINE, 0, (struct sockaddr *)&sa, &salen);
d1035 2
a1036 1
	n = recvfrom(fd, linebuf, MAXLINE, 0, (struct sockaddr *)&sa, &salen);
d1270 2
a1271 2
			memcpy(linebuf, msg, MINIMUM(len, MAXLINE));
			linebuf[MINIMUM(len, MAXLINE)] = '\0';
d1278 1
a1278 1
	if (EVBUFFER_LENGTH(bufev->input) >= 5 + 1 + MAXLINE + 1) {
d1563 1
a1563 1
	char *p, *q, line[MAXLINE + 4 + 1];  /* message, encoding, NUL */
d1580 1
a1580 1
	for (q = line; *p && q < &line[MAXLINE]; p++) {
d1586 1
a1586 1
	line[MAXLINE] = *q = '\0';
d1598 1
a1598 1
	char *lp, *p, *q, line[MAXLINE + 1];
d1860 1
a1860 1
	char line[MAXLINE + 1], repbuf[80], greetings[500];
d2501 1
a2501 1
	char buf[MAXLINE];
d2951 1
a2951 1
	optval = MAXLINE + PATH_MAX;
d2969 1
a2969 1
	newsize =  MAXLINE + 128;  /* data + control */
@


1.243
log
@Allow syslogd(8) to listen on multiple addresses for incomming TLS
connections.  This expands the feature from UDP and TCP to syslog
over TLS.
input jmc@@; OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.242 2017/04/17 14:18:44 bluhm Exp $	*/
d207 1
a468 1
	log_setdebug(1);
d734 2
a795 2
	log_setdebug(0);

d1630 4
d1770 4
@


1.242
log
@Add syslogd(8) option -r to suppress the summary line for pipe and
remote loghost as they are most commonly used for automated log
processing.  With -rr the "last message repeated" feature can be
disabled completely.
OK sthen@@ deraadt@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.241 2017/04/07 15:36:16 bluhm Exp $	*/
d354 1
a354 1
	int		 fd_tls, *fd_unix, nbind, nlisten;
d356 1
a356 1
	char		*tls_hostport, *tls_host, *tls_port;
d369 4
a372 3
	bind_host = bind_port = listen_host = listen_port = NULL;
	tls_hostport = tls_host = NULL;
	nbind = nlisten = 0;
d434 4
a437 5
			tls_hostport = optarg;
			if ((p = strdup(optarg)) == NULL)
				err(1, "strdup tls address");
			if (loghost_parse(p, NULL, &tls_host, &tls_port) == -1)
				errx(1, "bad tls address: %s", optarg);
d519 7
a525 4
	fd_tls = -1;
	if (tls_host && socket_bind("tls", tls_host, tls_port, 0,
	    &fd_tls, &fd_tls) == -1)
		log_warnx("socket listen tls failed");
d581 8
a588 2
				close(fd_tls);
				fd_tls = -1;
d635 1
a635 1
		names[1] = tls_host;
d685 8
a692 2
			close(fd_tls);
			fd_tls = -1;
d746 2
a747 1
	    (ev_bind = reallocarray(NULL, nbind, sizeof(struct event))) == NULL ||
d750 4
a753 2
	    (ev_tls = malloc(sizeof(struct event))) == NULL ||
	    (ev_unix = reallocarray(NULL, nunix, sizeof(struct event))) == NULL ||
d778 3
a780 1
	event_set(ev_tls, fd_tls, EV_READ|EV_PERSIST, tls_acceptcb, ev_tls);
d835 3
a837 2
	if (fd_tls != -1)
		event_add(ev_tls, NULL);
@


1.241
log
@Incoming TCP connections from clients fill the files of a log server.
A log client reconnects at every SIGHUP.  Write these accept and
close messages with debug priority, then they can be turned on in
syslog.conf.  Default is off.
While there, move a debug message and set the priority of the exit
message explicitly to error.
OK mpf@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.240 2017/04/05 22:15:35 bluhm Exp $	*/
d212 1
d373 2
a374 2
	while ((ch = getopt(argc, argv, "46a:C:c:dFf:hK:k:m:nP:p:S:s:T:U:uVZ"))
	    != -1)
d429 3
d462 1
d1498 4
a1501 4
	    "usage: syslogd [-46dFhnuVZ] [-a path] [-C CAfile] [-c cert_file]\n"
	    "\t[-f config_file] [-K CAfile] [-k key_file] [-m mark_interval]\n"
	    "\t[-p log_socket] [-S listen_address] [-s reporting_socket]\n"
	    "\t[-T listen_address] [-U bind_address]\n");
d1774 4
a1777 1
		if ((flags & MARK) == 0 && msglen == f->f_prevlen &&
@


1.240
log
@The global variable Startup is not used anymore and can be deleted.
The functionality has moved into log_setdebug().
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.239 2017/04/05 21:55:31 bluhm Exp $	*/
d1137 1
a1137 1
	log_info(LOG_INFO, "%s logger \"%s\" accepted",
d1264 1
a1264 1
		log_info(LOG_INFO, "%s logger \"%s\" connection close",
a2148 1

a2149 1
	log_debug("syslogd: restarted");
d2156 1
d2191 1
a2191 1
		log_warnx("exiting on signal %d", signo);
@


1.239
log
@As we did not have nice log functions before, ttymsg() had to return
the error string.  Log the message when the error happens and make
the function void.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.238 2017/04/05 21:30:04 bluhm Exp $	*/
a204 1
int	Startup = 1;		/* startup flag */
a769 1
	Startup = 0;
@


1.238
log
@The function logmsg() was used to generate local messages and to
process incoming messages.  Split this functionality into log_info()
and logline().  Sort the parameters like they appear in the syslog
line.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.237 2017/04/05 19:34:49 bluhm Exp $	*/
d2071 1
a2071 1
	char utline[sizeof(ut.ut_line) + 1], *p;
d2090 1
a2090 2
			if ((p = ttymsg(iov, 6, utline)) != NULL)
				log_warnx("%s", p);
d2099 1
a2099 2
				if ((p = ttymsg(iov, 6, utline)) != NULL)
					log_warnx("%s", p);
@


1.237
log
@Replace logerror() functions with generic log_warn() from log.c.
Make messages a bit more consistent.  Note that the new function
supports format strings.  Replace some log_debug() with log_warn().
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.236 2017/04/05 15:16:12 bluhm Exp $	*/
d113 1
a113 1
 * Flags to logmsg().
d324 1
a324 1
void	logmsg(int, char *, char *, int);
d834 1
a834 1
	logmsg(LOG_SYSLOG|LOG_INFO, "syslogd: start", LocalHostName, ADDDATE);
a1023 1
	char		 ebuf[ERRBUFSIZE];
d1042 1
a1042 3
		snprintf(ebuf, sizeof(ebuf), "syslogd: accept deferred: %s",
		    strerror(errno));
		logmsg(LOG_SYSLOG|LOG_WARNING, ebuf, LocalHostName, ADDDATE);
d1076 1
a1076 1
	char			*peername, ebuf[ERRBUFSIZE];
d1139 1
a1139 1
	snprintf(ebuf, sizeof(ebuf), "syslogd: %s logger \"%s\" accepted",
a1140 1
	logmsg(LOG_SYSLOG|LOG_INFO, ebuf, LocalHostName, ADDDATE);
a1263 1
	char			 ebuf[ERRBUFSIZE];
d1266 2
a1267 4
		snprintf(ebuf, sizeof(ebuf), "syslogd: %s logger \"%s\" "
		    "connection close", p->p_ctx ? "tls" : "tcp",
		    p->p_peername);
		logmsg(LOG_SYSLOG|LOG_INFO, ebuf, LocalHostName, ADDDATE);
d1269 2
a1270 3
		snprintf(ebuf, sizeof(ebuf), "syslogd: %s logger \"%s\" "
		    "connection error: %s", p->p_ctx ? "tls" : "tcp",
		    p->p_peername,
a1271 1
		logmsg(LOG_SYSLOG|LOG_NOTICE, ebuf, LocalHostName, ADDDATE);
a1319 1
	char		 ebuf[ERRBUFSIZE];
d1329 1
a1329 2
		snprintf(ebuf, sizeof(ebuf),
		    "syslogd: dropped %d message%s to loghost \"%s\"",
a1333 1
		logmsg(LOG_SYSLOG|LOG_WARNING, ebuf, LocalHostName, ADDDATE);
d1346 1
a1346 2
		snprintf(ebuf, sizeof(ebuf),
		    "syslogd: loghost \"%s\" connection close",
d1350 1
a1350 1
		    "syslogd: loghost \"%s\" connection error: %s",
d1390 1
a1390 1
	logmsg(LOG_SYSLOG|LOG_WARNING, ebuf, LocalHostName, ADDDATE);
d1562 1
a1562 1
	logmsg(pri, line, hname, 0);
d1593 1
a1593 1
		logmsg(pri, line, LocalHostName, flags);
d1606 1
a1606 1
	logmsg(pri, msg, LocalHostName, ADDDATE);
d1616 1
a1616 1
logmsg(int pri, char *msg, char *from, int flags)
d1623 1
a1623 1
	log_debug("logmsg: pri 0%o, flags 0x%x, from %s, msg %s",
a2151 2
	char	 ebuf[ERRBUFSIZE];

d2154 1
a2154 2
	logmsg(LOG_SYSLOG|LOG_INFO, "syslogd: restart",
	    LocalHostName, ADDDATE);
d2158 1
a2158 2
		snprintf(ebuf, sizeof(ebuf),
		    "syslogd: dropped %d message%s to remote loghost",
a2160 1
		logmsg(LOG_SYSLOG|LOG_WARNING, ebuf, LocalHostName, ADDDATE);
a2174 1
	char ebuf[ERRBUFSIZE];
d2190 1
a2190 2
		snprintf(ebuf, sizeof(ebuf),
		    "syslogd: dropped %d message%s to remote loghost",
a2192 1
		logmsg(LOG_SYSLOG|LOG_WARNING, ebuf, LocalHostName, ADDDATE);
d2853 1
a2853 2
		logmsg(LOG_INFO, "-- MARK --",
		    LocalHostName, ADDDATE|MARK);
@


1.236
log
@Replace all combinations of logerror() and die() with log.c fatal().
Internally syslogd's fatal() calls die() to do cleanup if necessary.
Also replace all err(3) after log_init() with fatal().
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.235 2017/04/05 11:31:45 bluhm Exp $	*/
a323 5
void	logerror(const char *);
void	logerrorx(const char *);
void	logerrorctx(const char *, struct tls *);
void	logerrortlsconf(const char *, struct tls_config *);
void	logerror_reason(const char *, const char *);
d499 1
a499 1
		logerrorx("socket bind *");
d505 1
a505 1
			logerrorx("socket bind udp");
d513 1
a513 1
			logerrorx("socket listen tcp");
d518 1
a518 1
		logerrorx("socket listen tls");
d526 1
a526 1
				logerrorx("log socket failed");
d533 1
a533 1
		logerror("socketpair");
d545 1
a545 1
			log_debug("can't open %s (%d)", path_ctlsock, errno);
d548 1
a548 1
				logerror("ctlsock listen");
d556 1
a556 1
		log_debug("can't open %s (%d)", _PATH_KLOG, errno);
d559 1
a559 1
			log_debug("LIOCSFD errno %d", errno);
d565 1
a565 1
		logerrorx("tls_init");
d568 1
a568 1
			logerror("tls_config_new client");
d571 1
a571 1
				logerror("tls_config_new server");
d573 1
a573 1
				logerror("tls_server");
d586 2
a587 2
				logerrortlsconf("Load client TLS CA failed",
				    client_config);
d596 2
a597 2
				logerrortlsconf("Load client TLS cert failed",
				    client_config);
d603 2
a604 2
				logerrortlsconf("Load client TLS key failed",
				    client_config);
d608 1
a608 1
			logerrorx("options -c and -k must be used together");
d612 2
a613 2
			logerrortlsconf("Set client TLS protocols failed",
			    client_config);
d615 2
a616 2
			logerrortlsconf("Set client TLS ciphers failed",
			    client_config);
d629 2
a630 2
				logerrortlsconf("Load server TLS key failed",
				    server_config);
d639 2
a640 2
				logerrortlsconf("Load server TLS cert failed",
				    server_config);
d652 2
a653 2
				logerrortlsconf("Load server TLS CA failed",
				    server_config);
d662 2
a663 2
			logerrortlsconf("Set server TLS protocols failed",
			    server_config);
d665 2
a666 2
			logerrortlsconf("Set server TLS ciphers failed",
			    server_config);
d668 2
a669 1
			logerrorctx("tls_configure server", server_ctx);
a869 1
	char		 ebuf[ERRBUFSIZE];
d890 1
a890 2
		snprintf(ebuf, sizeof(ebuf), "getaddrinfo "
		    "proto %s, host %s, port %s: %s",
a891 1
		logerrorx(ebuf);
d921 1
a921 1
			snprintf(ebuf, sizeof(ebuf), "shutdown SHUT_RD "
a923 1
			logerror(ebuf);
d935 1
a935 1
			snprintf(ebuf, sizeof(ebuf), "setsockopt SO_REUSEADDR "
a937 1
			logerror(ebuf);
d943 1
a943 2
			snprintf(ebuf, sizeof(ebuf), "bind "
			    "protocol %d, address %s, portnum %s",
a944 1
			logerror(ebuf);
d951 1
a951 2
			snprintf(ebuf, sizeof(ebuf), "listen "
			    "protocol %d, address %s, portnum %s",
a952 1
			logerror(ebuf);
d977 1
a977 1
		logerror("klog");
d999 1
a999 1
		logerror("recvfrom udp");
d1015 1
a1015 1
		logerror("recvfrom unix");
d1088 1
a1088 1
			logerror("accept tcp socket");
d1103 1
a1103 2
		snprintf(ebuf, sizeof(ebuf), "malloc \"%s\"", peername);
		logerror(ebuf);
d1110 1
a1110 2
		snprintf(ebuf, sizeof(ebuf), "bufferevent \"%s\"", peername);
		logerror(ebuf);
d1118 2
a1119 3
			snprintf(ebuf, sizeof(ebuf), "tls_accept_socket \"%s\"",
			    peername);
			logerrorctx(ebuf, server_ctx);
a1295 1
	char	 ebuf[ERRBUFSIZE];
d1299 1
a1299 3
		snprintf(ebuf, sizeof(ebuf), "socket \"%s\"",
		    f->f_un.f_forw.f_loghost);
		logerror(ebuf);
d1305 1
a1305 3
		snprintf(ebuf, sizeof(ebuf), "connect \"%s\"",
		    f->f_un.f_forw.f_loghost);
		logerror(ebuf);
a1410 1
	char			 ebuf[ERRBUFSIZE];
d1430 1
a1430 3
			snprintf(ebuf, sizeof(ebuf), "tls_client \"%s\"",
			    f->f_un.f_forw.f_loghost);
			logerror(ebuf);
d1435 3
a1437 3
			snprintf(ebuf, sizeof(ebuf), "tls_configure \"%s\"",
			    f->f_un.f_forw.f_loghost);
			logerrorctx(ebuf, f->f_un.f_forw.f_ctx);
d1442 3
a1444 3
			snprintf(ebuf, sizeof(ebuf), "tls_connect_socket "
			    "\"%s\"", f->f_un.f_forw.f_loghost);
			logerrorctx(ebuf, f->f_un.f_forw.f_ctx);
d1929 2
a1930 1
				logerror("sendto");
d2004 2
a2005 1
					logerror(f->f_un.f_fname);
d2028 2
a2029 1
					logerror(f->f_un.f_fname);
d2038 2
a2039 1
					logerror(f->f_un.f_fname);
d2046 1
a2046 1
				logerror(f->f_un.f_fname);
d2092 1
a2092 1
		logerror(_PATH_UTMP);
d2104 1
a2104 1
				logerrorx(p);
d2114 1
a2114 1
					logerrorx(p);
a2187 42
void
logerror(const char *message)
{
	logerror_reason(message, errno ? strerror(errno) : NULL);
}

void
logerrorx(const char *message)
{
	logerror_reason(message, NULL);
}

void
logerrorctx(const char *message, struct tls *ctx)
{
	logerror_reason(message, ctx ? tls_error(ctx) : NULL);
}

void
logerrortlsconf(const char *message, struct tls_config *config)
{
	logerror_reason(message, config ? tls_config_error(config) : NULL);
}

void
logerror_reason(const char *message, const char *reason)
{
	char ebuf[ERRBUFSIZE];

	if (reason)
		(void)snprintf(ebuf, sizeof(ebuf), "syslogd: %s: %s",
		    message, reason);
	else
		(void)snprintf(ebuf, sizeof(ebuf), "syslogd: %s", message);
	errno = 0;
	log_debug("%s", ebuf);
	if (Startup)
		fprintf(stderr, "%s\n", ebuf);
	else
		logmsg(LOG_SYSLOG|LOG_ERR, ebuf, LocalHostName, ADDDATE);
}

d2216 3
a2218 7
	if (signo) {
		log_debug("syslogd: exiting on signal %d", signo);
		(void)snprintf(ebuf, sizeof(ebuf), "exiting on signal %d",
		    signo);
		logerrorx(ebuf);
	}
	log_debug("[unpriv] syslogd child about to exit");
d2369 1
a2369 1
				logerror("Failed to allocate membuf");
d2383 1
a2383 1
			logerrorx("Mismatched membuf");
d2488 1
a2488 1
	char buf[MAXLINE], ebuf[ERRBUFSIZE];
d2542 1
a2542 3
				(void)snprintf(ebuf, sizeof ebuf,
				    "unknown priority name \"%s\"", buf);
				logerrorx(ebuf);
d2559 2
a2560 4
					(void)snprintf(ebuf, sizeof(ebuf),
					    "unknown facility name \"%s\"",
					    buf);
					logerrorx(ebuf);
d2582 1
a2582 3
			snprintf(ebuf, sizeof(ebuf), "loghost too long \"%s\"",
			    p);
			logerrorx(ebuf);
d2586 1
a2586 1
			snprintf(ebuf, sizeof(ebuf), "bad loghost \"%s\"",
a2587 1
			logerrorx(ebuf);
d2601 1
a2601 1
				snprintf(ebuf, sizeof(ebuf), "no udp4 \"%s\"",
a2602 1
				logerrorx(ebuf);
d2607 1
a2607 1
				snprintf(ebuf, sizeof(ebuf), "no udp6 \"%s\"",
a2608 1
				logerrorx(ebuf);
d2621 1
a2621 1
			snprintf(ebuf, sizeof(ebuf), "bad protocol \"%s\"",
a2622 1
			logerrorx(ebuf);
d2626 1
a2626 1
			snprintf(ebuf, sizeof(ebuf), "host too long \"%s\"",
a2627 1
			logerrorx(ebuf);
d2634 1
a2634 1
			snprintf(ebuf, sizeof(ebuf), "port too long \"%s\"",
a2635 1
			logerrorx(ebuf);
d2641 1
a2641 1
			snprintf(ebuf, sizeof(ebuf), "bad hostname \"%s\"",
a2642 1
			logerrorx(ebuf);
d2659 1
a2659 2
				snprintf(ebuf, sizeof(ebuf),
				    "bufferevent \"%s\"",
a2660 1
				logerror(ebuf);
d2695 1
a2695 1
		if (strcmp(p, ctty) == 0)
d2697 3
a2699 1
		else
d2701 3
a2705 1
			logerror(p);
d2741 1
a2741 1
			logerror(p);
d2760 1
a2760 1
			logerrorx(p);
a2893 1
	char ebuf[512];
d2901 1
a2901 2
		snprintf(ebuf, sizeof(ebuf), "socket path too long: %s", path);
		logerrorx(ebuf);
d2906 1
a2906 1
		logerror("socket");
d2915 1
a2915 1
			logerror("connect");
d2924 1
a2924 2
		snprintf(ebuf, sizeof(ebuf), "cannot bind %s", path);
		logerror(ebuf);
d2933 1
a2933 2
		snprintf(ebuf, sizeof(ebuf), "cannot chmod %s", path);
		logerror(ebuf);
d2942 1
a2942 1
		logerror("setsockopt unix");
d2955 1
a2955 1
		logerror("getsockopt bufsize");
d2963 1
a2963 1
			logerror("setsockopt bufsize");
d2973 1
a2973 1
		logerror("setsockopt sndbufsize");
d2975 1
a2975 1
		logerror("setsockopt rcvbufsize");
d3007 1
a3007 1
			logerror("accept ctlsock");
d3066 1
a3066 1
		logerror("ctlconn read");
d3078 1
a3078 1
		logerrorx("Unknown client protocol version");
d3085 1
a3085 1
		logerrorx("Corrupt ctlsock command");
d3153 1
a3153 1
		logerrorx("Unsupported ctlsock command");
d3183 1
a3183 1
		logerrorx("ctlconn_write with bad ctl_state");
d3198 1
a3198 1
			logerror("ctlconn write");
@


1.235
log
@Replace logdebug() with generic log_debug() from log.c.  Implement
log_debugadd() to construct debug message incrementally.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.234 2017/04/05 00:35:02 bluhm Exp $	*/
d473 2
a474 4
	if ((nullfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
		logerror("Couldn't open /dev/null");
		die(0);
	}
d477 2
a478 4
			if (dup2(nullfd, fd) == -1) {
				logerror("dup2");
				die(0);
			}
d499 2
a500 4
	if ((linebuf = malloc(linesize)) == NULL) {
		logerror("Couldn't allocate line buffer");
		die(0);
	}
d506 1
a506 1
		err(1, "bind fd");
d514 1
a514 1
		err(1, "listen fd");
d526 1
a526 1
		err(1, "malloc unix");
d779 2
a780 4
	    (ctl_reply = malloc(CTL_REPLY_MAXSIZE)) == NULL) {
		logerror("Couldn't allocate ctlsock reply buffer");
		die(0);
	}
d2413 2
a2414 4
	if (!feof(cf)) {
		logerror("Unable to read config file");
		die(0);
	}
d2561 2
a2562 4
	if ((f = calloc(1, sizeof(*f))) == NULL) {
		logerror("Couldn't allocate struct filed");
		die(0);
	}
@


1.234
log
@Do not print a warning if closing the control socket fails.  It
cannot happen and there is nothing that could be done about it.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.233 2017/03/28 00:04:43 jsg Exp $	*/
d556 1
a556 1
			logdebug("can't open %s (%d)\n", path_ctlsock, errno);
d567 1
a567 1
		logdebug("can't open %s (%d)\n", _PATH_KLOG, errno);
d570 1
a570 1
			logdebug("LIOCSFD errno %d\n", errno);
d602 1
a602 1
				logdebug("CAfile %s\n", CAfile);
d610 1
a610 1
				logdebug("ClientCertfile %s\n", ClientCertfile);
d617 1
a617 1
				logdebug("ClientKeyfile %s\n", ClientKeyfile);
d645 1
a645 1
			logdebug("Keyfile %s\n", p);
d655 1
a655 1
			logdebug("Certfile %s\n", p);
d668 1
a668 1
				logdebug("Server CAfile %s\n", ServerCAfile);
d687 1
a687 1
	logdebug("off & running....\n");
d847 1
a847 1
	logdebug("syslogd: started\n");
d932 1
a932 1
			logdebug("Malformed bind address\n");
d1017 1
a1017 1
		logdebug("cvthname res: %s\n", resolve);
d1049 1
a1049 1
		logdebug("Listen again\n");
d1112 1
a1112 1
	logdebug("Accepting tcp connection\n");
d1119 1
a1119 1
		logdebug("Malformed accept address\n");
d1122 1
a1122 1
	logdebug("Peer addresss and port %s\n", peername);
d1151 1
a1151 1
		logdebug("tcp accept callback: tls context success\n");
d1156 1
a1156 1
		logdebug("Host name for accept address (%s) unknown\n",
d1162 1
a1162 1
	logdebug("Peer hostname %s\n", hostname);
d1203 1
a1203 1
		logdebug(" octet counting %d", len);
d1234 1
a1234 1
	logdebug(" non transparent framing");
d1256 1
a1256 1
		logdebug("%s logger \"%s\"", p->p_ctx ? "tls" : "tcp",
d1263 1
a1263 1
			logdebug("unknown method");
d1265 1
a1265 1
			logdebug(", incomplete frame");
d1268 1
a1268 1
		logdebug(", use %d bytes\n", len);
d1281 1
a1281 1
		logdebug(", use %zu bytes\n", EVBUFFER_LENGTH(bufev->input));
d1285 1
a1285 1
		logdebug(", buffer %zu bytes\n", EVBUFFER_LENGTH(bufev->input));
d1349 1
a1349 1
	logdebug("loghost \"%s\" did send %zu bytes back\n",
d1363 1
a1363 1
	logdebug("loghost \"%s\" successful write\n", f->f_un.f_forw.f_loghost);
d1395 1
a1395 1
	logdebug("%s\n", ebuf);
d1424 1
a1424 1
		logdebug("loghost \"%s\" dropped partial message\n",
d1447 1
a1447 1
	logdebug("tcp connect callback: socket success, event %#x\n", event);
d1479 1
a1479 1
		logdebug("tcp connect callback: tls context success\n");
d1512 1
a1512 1
	logdebug("tcp connect retry: wait %d\n",
d1668 1
a1668 1
	logdebug("logmsg: pri 0%o, flags 0x%x, from %s, msg %s\n",
d1822 1
a1822 1
			logdebug("msg repeated %d times, %ld sec of %d\n",
d1930 1
a1930 1
	logdebug("Logging to %s", TypeNames[f->f_type]);
d1935 1
a1935 1
		logdebug("\n");
d1939 1
a1939 1
		logdebug(" %s\n", f->f_un.f_forw.f_loghost);
d1969 1
a1969 1
		logdebug(" %s", f->f_un.f_forw.f_loghost);
d1972 1
a1972 1
			logdebug(" (dropped)\n");
d1988 1
a1988 1
			logdebug(" (dropped snprintf)\n");
d2000 1
a2000 1
			logdebug(" (dropped evbuffer_add_printf)\n");
d2005 1
a2005 1
		logdebug("\n");
d2010 1
a2010 1
			logdebug(" (ignored)\n");
d2018 1
a2018 1
		logdebug(" %s\n", f->f_un.f_fname);
d2082 1
a2082 1
		logdebug("\n");
d2089 1
a2089 1
		logdebug("\n");
d2159 1
a2159 1
		logdebug("Malformed from address\n");
d2163 1
a2163 1
	logdebug("cvthname(%s)\n", result);
d2168 1
a2168 1
		logdebug("Host name for from address (%s) unknown\n", result);
d2199 1
a2199 1
	logdebug("syslogd: restarted\n");
d2213 1
a2213 13
	logdebug("libevent: [%d] %s\n", severity, msg);
}

void
logdebug(const char *fmt, ...)
{
	va_list ap;

	if (Debug) {
		va_start(ap, fmt);
		vprintf(fmt, ap);
		va_end(ap);
	}
d2251 1
a2251 1
	logdebug("%s\n", ebuf);
d2287 1
a2287 1
		logdebug("syslogd: exiting on signal %d\n", signo);
d2292 1
a2292 1
	logdebug("[unpriv] syslogd child about to exit\n");
d2309 1
a2309 1
	logdebug("init\n");
d2313 1
a2313 1
		logdebug("config file changed: dying\n");
d2354 1
a2354 1
			logdebug("add %p to mb\n", f);
d2363 1
a2363 1
		logdebug("cannot open %s\n", ConfFile);
d2430 1
a2430 1
		logdebug("Initialize membuf %s at %p\n",
d2441 1
a2441 1
			logdebug("Membuf no match\n");
d2448 1
a2448 1
			logdebug("Membuf match f:%p, m:%p\n", f, m);
d2462 1
a2462 1
		logdebug("Freeing membuf %p\n", m);
d2536 1
a2536 1
				logdebug("duplicate %s\n", f->f_un.f_fname);
d2545 1
a2545 1
				logdebug("duplicate membuf %s\n",
d2568 1
a2568 1
	logdebug("cfline(\"%s\", f, \"%s\", \"%s\")\n",
d2926 1
a2926 1
		logdebug("couldn't get kern.msgbufsize\n");
d2970 1
a2970 1
			logdebug("flush %s: repeated %d times, %d sec.\n",
d3103 1
a3103 1
	logdebug("Accepting control connection\n");
d3189 1
a3189 1
	logdebug("ctlcmd %x logname \"%s\"\n", ctl_cmd.cmd, ctl_cmd.logname);
d3254 1
a3254 1
	logdebug("ctlcmd reply length %lu\n", (u_long)ctl_reply_size);
@


1.233
log
@fix semicolon after if statement in currently uncalled code
ok bluhm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.232 2017/03/26 18:38:16 bluhm Exp $	*/
d3088 1
a3088 2
	if (close(fd_ctlconn) == -1)
		logerror("close ctlconn");
@


1.232
log
@After my previous commit, file descriptor fd_sendsys may be -1 if
socketpair(2) has failed.  Do not call ioctl(LIOCSFD) in this case.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.231 2017/03/24 22:13:00 bluhm Exp $	*/
d1649 1
a1649 1
	if (l < sizeof(msg));
@


1.231
log
@Keep syslogd(8) running as long as possible.  Regular programs
should terminate early in case of an error.  But if syslogd dies,
no messages can be seen at all.  Except from command line parsing
and memory shortage during statup, report errors and run all working
subsystems, but do not die.
OK millert@@ dreaadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.230 2017/03/16 23:55:19 bluhm Exp $	*/
d568 1
a568 1
	} else {
d572 2
a573 1
	close(pair[1]);
@


1.230
log
@Start to replace the home grown syslogd(8) internal debug and logging
functions with a more common log.c implementation.  Of course
openlog(3) cannot be used, so adapt the log.[ch] initially copied
from ospfd(8) to syslogd's special needs.  As the messages are
limited to ERRBUFSIZE anyway, malloc(3) in the error logging code
can be avoided.  Changing all log calls to the new API will be done
in a separate step.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.229 2017/03/16 17:55:22 bluhm Exp $	*/
d509 1
a509 1
	    &fd_udp, &fd_udp6) == -1) {
a510 3
		if (!Debug)
			die(0);
	}
d515 1
a515 1
		    &fd_bind[i], &fd_bind[i]) == -1) {
a516 3
			if (!Debug)
				die(0);
		}
d523 1
a523 1
		    &fd_listen[i], &fd_listen[i]) == -1) {
a524 3
			if (!Debug)
				die(0);
		}
d528 1
a528 1
	    &fd_tls, &fd_tls) == -1) {
a529 3
		if (!Debug)
			die(0);
	}
d536 2
a537 2
			if (i == 0 && !Debug)
				die(0);
d545 5
a549 1
		die(0);
a550 3
	double_sockbuf(pair[0], SO_RCVBUF);
	double_sockbuf(pair[1], SO_SNDBUF);
	fd_sendsys = pair[0];
a556 2
			if (!Debug)
				die(0);
d560 2
a561 1
				die(0);
d566 1
a566 2
	fd_klog = open(_PATH_KLOG, O_RDONLY, 0);
	if (fd_klog == -1) {
d906 1
a906 1
		die(0);
d3004 1
a3004 1
		die(0);
@


1.229
log
@Convert the global variable fd_tls to a local one.  Use separate
callbacks for TCP and TLS accept(2) instead of looking at the value
of the listen file descriptor.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.228 2017/03/14 15:35:48 deraadt Exp $	*/
d102 1
a319 1
void	die(int);
d467 3
a700 2
	tzset();

d792 1
d1654 12
d2282 1
a2282 1
void
@


1.228
log
@KNF spacing is more important than long lines
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.227 2017/01/02 15:58:02 bluhm Exp $	*/
d275 1
a275 1
int		 fd_ctlconn, fd_udp, fd_udp6, fd_tls;
d294 2
d359 1
a359 1
	int		*fd_unix, nbind, nlisten;
d777 1
a777 1
	event_set(ev_tls, fd_tls, EV_READ|EV_PERSIST, tcp_acceptcb, ev_tls);
d1093 12
d1149 1
a1149 1
	if (lfd == fd_tls) {
@


1.227
log
@Syslogd accepted network input only for either IPv4 or IPv6.  To
overcome this limitation, allow to specify more than one listen
address for UDP and TCP.
input jmc@@; OK deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.226 2016/12/30 23:21:26 bluhm Exp $	*/
d746 2
a747 2
	    (ev_bind = reallocarray(NULL,nbind,sizeof(struct event))) == NULL ||
	    (ev_listen = reallocarray(NULL,nlisten,sizeof(struct event)))
d750 1
a750 1
	    (ev_unix = reallocarray(NULL,nunix,sizeof(struct event))) == NULL ||
@


1.226
log
@When syslogd received a SIGHUP during startup, it died instead of
reloading its config.  This could happen when multiple signals were
sent during a short interval.  So block SIGHUP until signal handlers
are installed.
OK deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.225 2016/12/27 19:16:24 bluhm Exp $	*/
a216 7
char	*bind_host = NULL;	/* bind UDP receive socket */
char	*bind_port = NULL;
char	*listen_host = NULL;	/* listen on TCP receive socket */
char	*listen_port = NULL;
char	*tls_hostport = NULL;	/* listen on TLS receive socket */
char	*tls_host = NULL;
char	*tls_port = NULL;
d336 1
d356 4
a359 2
	int		 fd_ctlsock, fd_klog, fd_sendsys, fd_bind, fd_listen;
	int		*fd_unix;
d372 4
d388 1
a388 1
				err(1, "malloc %s", optarg);
d443 2
a444 5
			if ((p = strdup(optarg)) == NULL)
				err(1, "strdup listen address");
			if (loghost_parse(p, NULL, &listen_host, &listen_port)
			    == -1)
				errx(1, "bad listen address: %s", optarg);
d447 2
a448 5
			if ((p = strdup(optarg)) == NULL)
				err(1, "strdup bind address");
			if (loghost_parse(p, NULL, &bind_host, &bind_port)
			    == -1)
				errx(1, "bad bind address: %s", optarg);
d509 9
a517 6
	fd_bind = -1;
	if (bind_host && socket_bind("udp", bind_host, bind_port, 0,
	    &fd_bind, &fd_bind) == -1) {
		logerrorx("socket bind udp");
		if (!Debug)
			die(0);
d519 10
a528 6
	fd_listen = -1;
	if (listen_host && socket_bind("tcp", listen_host, listen_port, 0,
	    &fd_listen, &fd_listen) == -1) {
		logerrorx("socket listen tcp");
		if (!Debug)
			die(0);
d746 3
a748 2
	    (ev_bind = malloc(sizeof(struct event))) == NULL ||
	    (ev_listen = malloc(sizeof(struct event))) == NULL ||
d769 6
a774 3
	event_set(ev_bind, fd_bind, EV_READ|EV_PERSIST, udp_readcb, ev_bind);
	event_set(ev_listen, fd_listen, EV_READ|EV_PERSIST, tcp_acceptcb,
	    ev_listen);
d826 6
a831 4
	if (fd_bind != -1)
		event_add(ev_bind, NULL);
	if (fd_listen != -1)
		event_add(ev_listen, NULL);
d864 18
@


1.225
log
@If syslogd was started with a relative path, the program could not
re-exec itself.  This exec is done during startup of the privsep
parent or when syslogd restarts after a SIGHUP.  Convert a relative
path in argv[0] to an absolute one with realpath(3) before chdir(2).
Do all the path handling in priv_init().
suggested by millert@@; OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.224 2016/12/23 23:01:48 bluhm Exp $	*/
d357 1
d365 6
d849 4
@


1.224
log
@When the kernel message buffer overflows, a message is printed by
syslogd(8) and the buffer is overwritten.  But after a complete
message buffer was read, we got a split line.  This happened as
syslogd did a partial read which ended within a line.  To avoid the
latter, syslogd has to reserve space for the kernel message buffer
plus 64 chars for the buffer full message.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.223 2016/11/30 07:59:04 mestre Exp $	*/
a686 2

	chdir("/");
@


1.223
log
@Wrap lines earlier on tls_config_set_protocols(3)

Feedback and OK jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.222 2016/11/21 16:36:10 mestre Exp $	*/
d492 2
a493 1
	linesize = getmsgbufsize();
@


1.222
log
@Check return value of tls_config_set_protocols(3) and log if it fails

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.221 2016/10/17 11:19:55 bluhm Exp $	*/
d619 2
a620 2
		if (tls_config_set_protocols(client_config, TLS_PROTOCOLS_ALL)
		    != 0)
d669 2
a670 2
		if (tls_config_set_protocols(server_config, TLS_PROTOCOLS_ALL)
		    != 0)
@


1.221
log
@Remove the artificial maximum number of unix domain sockets in
syslogd(8).  Just malloc(3) them dynamically which also gives a
more random address space layout.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.220 2016/10/16 22:12:50 bluhm Exp $	*/
d619 4
a622 1
		tls_config_set_protocols(client_config, TLS_PROTOCOLS_ALL);
d669 4
a672 1
		tls_config_set_protocols(server_config, TLS_PROTOCOLS_ALL);
@


1.220
log
@Fix trailing whitespace and shorten long lines.
No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.219 2016/10/16 22:00:14 bluhm Exp $	*/
d200 2
a201 2
int	nunix = 1;		/* Number of Unix domain sockets requested */
char	*path_unix[MAXUNIX] = { _PATH_LOG }; /* Paths to Unix domain sockets */
d362 6
a367 1
	int		 fd_unix[MAXUNIX];
d379 3
a381 2
			if (nunix >= MAXUNIX)
				errx(1, "out of descriptors: %s", optarg);
d529 2
@


1.219
log
@Use closefrom(4) in privsep parent and avoid some global file
descriptor variables in syslogd(8) this way.
OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.218 2016/10/06 13:03:47 bluhm Exp $	*/
d213 1
a213 1
int	NoDNS = 0;		/* when true, will refrain from doing DNS lookups */
d215 1
a215 1
int	IncludeHostname = 0;	/* include RFC 3164 style hostnames when forwarding */
d239 1
a239 1
int	membuf_drop = 0;	/* logs were dropped in continuous membuf read */
d1621 1
a1621 1
		    isdigit(msg[0]) && isdigit(msg[1]) && isdigit(msg[2]) && 
d1641 1
a1641 1
					msglen--; 
d1782 2
a1783 1
				strlcpy(f->f_prevline, msg, sizeof(f->f_prevline));
d2442 2
a2443 1
				for (i = 0; i < MAXUNAMES && *f->f_un.f_uname[i]; i++)
@


1.218
log
@Do an exec on itself in the privileged syslogd(8) parent process
to reshuffle its memory layout.
Input rzalamena@@; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.217 2016/10/06 11:24:04 bluhm Exp $	*/
d282 2
a283 3
int		 fd_ctlsock, fd_ctlconn, fd_klog, fd_sendsys, fd_udp, fd_udp6,
		 fd_bind, fd_listen, fd_tls, fd_unix[MAXUNIX];
struct event	 *ev_ctlaccept, *ev_ctlread, *ev_ctlwrite;
d361 2
@


1.217
log
@Syslog RFC 5424 says you should add 1 to 6 digits with fractions
of a second to each syslog timestamp.  As we do not measure the
time in syslog(3), use only 3 digits with millisecond precision.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.216 2016/10/04 22:09:21 bluhm Exp $	*/
d211 1
d363 1
a363 1
	while ((ch = getopt(argc, argv, "46a:C:c:dFf:hK:k:m:np:S:s:T:U:uVZ"))
d410 5
d454 1
a454 1
	if ((argc -= optind) != 0)
d472 3
d707 1
a707 2
	if (priv_init(ConfFile, NoDNS, lockpipe[1], nullfd, argv) < 0)
		errx(1, "unable to privsep");
@


1.216
log
@When doing global remote logging and archiving, it is inconvenient
that the syslog timestamp does not contain the year and the timezone,
but has local time with daylight saving time.
Now with -Z syslogd(8) switches to RFC 5424 ISO format for timestamps.
Then all logging is also done in UTC.  Default is to keep local
time and BSD syslog RFC 3164 format.
BIG BIG BIG OK for the feature ajacoutot@@; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.215 2016/09/23 15:46:39 bluhm Exp $	*/
d1580 1
a1580 1
time_t	now;
a1589 1
	struct tm *tm;
d1667 1
a1667 1
	(void)time(&now);
d1670 11
a1680 2
			tm = gmtime(&now);
			strftime(timestamp, sizeof(timestamp), "%FT%TZ", tm);
d1682 1
a1682 1
			strlcpy(timestamp, ctime(&now) + 4, 16);
d1735 2
a1736 1
		if ((flags & MARK) && (now - f->f_time) < MarkInterval / 2)
d1749 1
a1749 1
			    f->f_prevcount, (long)(now - f->f_time),
d1757 1
a1757 1
			if (now > REPEATTIME(f)) {
d1799 1
a1799 1
		    f->f_prevhost, ctime(&now));
d1856 1
a1856 1
	f->f_time = now;
d1958 2
a1959 2
				if (now - f->f_lasterrtime > 120) {
					f->f_lasterrtime = now;
d2896 1
a2896 1
	now = time(NULL);
d2905 1
a2905 1
		if (f->f_prevcount && now >= REPEATTIME(f)) {
@


1.215
log
@Document certificate handling in syslogd(8) man page.
Written together with jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.214 2016/09/23 13:13:13 bluhm Exp $	*/
d156 1
a156 1
	char	f_lasttime[16];			/* time of last occurrence */
d213 1
d362 1
a362 1
	while ((ch = getopt(argc, argv, "46a:C:c:dFf:hK:k:m:np:S:s:T:U:uV"))
d442 3
d1478 1
a1478 1
	    "usage: syslogd [-46dFhnuV] [-a path] [-C CAfile] [-c cert_file]\n"
d1590 1
d1592 1
a1592 1
	char *timestamp;
d1601 1
d1603 64
a1666 3
	if (msglen < 16 || msg[3] != ' ' || msg[6] != ' ' ||
	    msg[9] != ':' || msg[12] != ':' || msg[15] != ' ')
		flags |= ADDDATE;
d1669 6
a1674 6
	if (flags & ADDDATE)
		timestamp = ctime(&now) + 4;
	else {
		timestamp = msg;
		msg += 16;
		msglen -= 16;
d1736 2
a1737 1
			strlcpy(f->f_lasttime, timestamp, 16);
d1758 2
a1759 1
			strlcpy(f->f_lasttime, timestamp, 16);
d1801 1
a1801 1
		v->iov_len = 15;
d1857 1
a1857 1
		    "<%d>%.15s %s%s%s", f->f_prevpri, (char *)iov[0].iov_base,
d1899 1
a1899 1
		l = snprintf(line, sizeof(line), "<%d>%.15s %s%s\n",
d1909 1
a1909 1
		    "%zu <%d>%.15s %s%s%s\n",
d2006 1
a2006 1
		snprintf(line, sizeof(line), "%.15s %s %s",
@


1.214
log
@With the new large socket buffer sizes, syslogd could use more mbufs
for TCP or TLS connections than before.  It makes no sense to buffer
messages in kernel, the dynamic limit there makes testing the dropped
message statistics unreliable.  Syslog has no high performance
requirements, so limit all TCP socket buffers to 64 KB.
OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.213 2016/09/21 11:54:57 bluhm Exp $	*/
d1475 3
a1477 3
	    "\t[-f config_file] [-K server_CAfile] [-k key_file]\n"
	    "\t[-m mark_interval] [-p log_socket] [-S listen_address]\n"
	    "\t[-s reporting_socket] [-T listen_address] [-U bind_address]\n");
@


1.213
log
@Add an option to give syslogd a server CA that is used to validate
client certificates.  This prevent that malicious clients can send
fake messages.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.212 2016/08/29 20:31:56 bluhm Exp $	*/
d346 1
d890 4
a923 2
		if (!shutread && res->ai_protocol == IPPROTO_UDP)
			double_sockbuf(*fdp, SO_RCVBUF);
d1263 1
d2916 11
@


1.212
log
@Add more information to syslogd tls config error messages.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.211 2016/08/17 12:18:29 bluhm Exp $	*/
d228 3
a230 2
char	*ClientCertfile = NULL;
char	*ClientKeyfile = NULL;
d360 1
a360 1
	while ((ch = getopt(argc, argv, "46a:C:c:dFf:hk:m:np:S:s:T:U:uV"))
d392 3
d632 11
d1471 3
a1473 3
	    "\t[-f config_file] [-k key_file] [-m mark_interval]\n"
	    "\t[-p log_socket] [-S listen_address] [-s reporting_socket]\n"
	    "\t[-T listen_address] [-U bind_address]\n");
@


1.211
log
@By using the new tls_config_load_file() feature, syslogd(8) certificate
and key loading can be simplified.
OK jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.210 2016/07/13 16:35:47 jsing Exp $	*/
d330 1
d568 2
a571 1
				logerror("load client TLS CA failed");
d578 2
a579 1
				logerror("load client TLS cert failed");
d585 2
a586 1
				logerror("load client TLS key failed");
d594 2
a595 1
			logerror("tls set client ciphers");
d608 2
a610 1
				logerrorx("tls_config_set_key_file");
d618 2
a620 1
				logerrorx("tls_config_set_cert_file");
d630 2
a631 1
			logerror("tls set server ciphers");
d633 1
a633 1
			logerrorx("tls_configure server");
d2072 6
@


1.210
log
@Adjust existing tls_config_set_cipher() callers for TLS cipher group
changes - map the previous configuration to the equivalent in the new
groups. This will be revisited post release.

Discussed with beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.209 2016/07/12 09:47:25 bluhm Exp $	*/
d565 3
a567 25
			struct stat sb;
			int fail = 1;

			fd = -1;
			p = NULL;
			if ((fd = open(CAfile, O_RDONLY)) == -1) {
				logerror("open CAfile");
			} else if (fstat(fd, &sb) == -1) {
				logerror("fstat CAfile");
			} else if (sb.st_size > 50*1024*1024) {
				logerrorx("CAfile larger than 50MB");
			} else if ((p = calloc(sb.st_size, 1)) == NULL) {
				logerror("calloc CAfile");
			} else if (read(fd, p, sb.st_size) != sb.st_size) {
				logerror("read CAfile");
			} else if (tls_config_set_ca_mem(client_config, p,
			    sb.st_size) == -1) {
				logerrorx("tls_config_set_ca_mem");
			} else {
				fail = 0;
				logdebug("CAfile %s, size %lld\n",
				    CAfile, sb.st_size);
			}
			/* avoid reading default certs in chroot */
			if (fail)
d569 3
a571 2
			free(p);
			close(fd);
d574 2
a575 5
			uint8_t *cert, *key;
			size_t certlen, keylen;

			cert = tls_load_file(ClientCertfile, &certlen, NULL);
			if (cert == NULL) {
d577 1
a577 4
			} else if (tls_config_set_cert_mem(client_config, cert,
			    certlen) == -1) {
				logerror("set client TLS cert failed");
			} else {
d579 3
a581 3
			}
			key = tls_load_file(ClientKeyfile, &keylen, NULL);
			if (key == NULL) {
d583 1
a583 4
			} else if (tls_config_set_key_mem(client_config, key,
			    keylen) == -1) {
				logerror("set client TLS key failed");
			} else {
a584 1
			}
d593 1
a593 2
		struct stat sb;
		char *path;
d595 11
a605 11
		fd = -1;
		p = NULL;
		path = NULL;
		if (asprintf(&path, "/etc/ssl/private/%s.key", tls_hostport)
		    == -1 || (fd = open(path, O_RDONLY)) == -1) {
			free(path);
			path = NULL;
			if (asprintf(&path, "/etc/ssl/private/%s.key", tls_host)
			    == -1 || (fd = open(path, O_RDONLY)) == -1) {
				free(path);
				path = NULL;
d607 8
a614 32
		}
		if (fd == -1) {
			logerror("open keyfile");
		} else if (fstat(fd, &sb) == -1) {
			logerror("fstat keyfile");
		} else if (sb.st_size > 50*1024) {
			logerrorx("keyfile larger than 50KB");
		} else if ((p = calloc(sb.st_size, 1)) == NULL) {
			logerror("calloc keyfile");
		} else if (read(fd, p, sb.st_size) != sb.st_size) {
			logerror("read keyfile");
		} else if (tls_config_set_key_mem(server_config, p,
		    sb.st_size) == -1) {
			logerrorx("tls_config_set_key_mem");
		} else {
			logdebug("Keyfile %s, size %lld\n", path, sb.st_size);
		}
		free(p);
		close(fd);
		free(path);

		fd = -1;
		p = NULL;
		path = NULL;
		if (asprintf(&path, "/etc/ssl/%s.crt", tls_hostport)
		    == -1 || (fd = open(path, O_RDONLY)) == -1) {
			free(path);
			path = NULL;
			if (asprintf(&path, "/etc/ssl/%s.crt", tls_host)
			    == -1 || (fd = open(path, O_RDONLY)) == -1) {
				free(path);
				path = NULL;
d616 3
a619 20
		if (fd == -1) {
			logerror("open certfile");
		} else if (fstat(fd, &sb) == -1) {
			logerror("fstat certfile");
		} else if (sb.st_size > 50*1024) {
			logerrorx("certfile larger than 50KB");
		} else if ((p = calloc(sb.st_size, 1)) == NULL) {
			logerror("calloc certfile");
		} else if (read(fd, p, sb.st_size) != sb.st_size) {
			logerror("read certfile");
		} else if (tls_config_set_cert_mem(server_config, p,
		    sb.st_size) == -1) {
			logerrorx("tls_config_set_cert_mem");
		} else {
			logdebug("Certfile %s, size %lld\n",
			    path, sb.st_size);
		}
		free(p);
		close(fd);
		free(path);
@


1.209
log
@Add support for TLS client certificates in syslogd.  This allows a
remote server to verify that the log messages from our syslogd are
authentic.
From Kapetanakis Giannis; man page input jmc@@; OK jung@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.208 2016/07/06 19:29:13 millert Exp $	*/
d620 1
a620 1
		if (tls_config_set_ciphers(client_config, "compat") != 0)
@


1.208
log
@Allow space-deliminated fields in syslog.conf in addition to
traditional tabs-deliminated fields.  This is consistent with what
FreeBSD, NetBSD and Linux do.  Adapted from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.207 2016/07/01 15:47:15 millert Exp $	*/
d228 2
d358 2
a359 1
	while ((ch = getopt(argc, argv, "46a:C:dFf:hm:np:S:s:T:U:uV")) != -1)
d375 3
d390 3
d594 25
d1520 4
a1523 3
	    "usage: syslogd [-46dFhnuV] [-a path] [-C CAfile] [-f config_file]\n"
	    "               [-m mark_interval] [-p log_socket] [-S listen_address]\n"
	    "               [-s reporting_socket] [-T listen_address] [-U bind_address]\n");
@


1.207
log
@Avoid printing f->f_lasttime and/or f->f_prevhost if they are empty.
This fixes a long-standing issue where syslogd would print 15 NUL
bytes followed by two blank spaces before the log message for
warnings generated while parsing syslog.conf.  OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.206 2016/07/01 15:00:48 millert Exp $	*/
d2457 1
a2457 1
	for (p = line; *p && *p != '\t';) {
d2460 1
a2460 1
		for (q = p; *q && *q != '\t' && *q++ != '.'; )
d2464 1
a2464 1
		for (bp = buf; *q && !strchr("\t,;", *q); )
d2469 1
a2469 1
		while (*q && strchr(", ;", *q))
d2492 2
a2493 2
		while (*p && !strchr("\t.;", *p)) {
			for (bp = buf; *p && !strchr("\t,;.", *p); )
d2519 1
a2519 1
	while (*p == '\t')
@


1.206
log
@Include errno string in log message when we fail to open a file.
The privileged process sends the errno value back when it cannot
open a file.  OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.205 2016/04/02 19:55:10 krw Exp $	*/
d1741 1
a1741 1
	} else {
d1748 22
a1770 6
	v->iov_base = f->f_prevhost;
	v->iov_len = strlen(v->iov_base);
	v++;
	v->iov_base = " ";
	v->iov_len = 1;
	v++;
@


1.205
log
@Eliminate superfluous 3rd params in fcntl(F_GETFL) calls.

ttymsg.c doesn't need to include fcntl.h.

Tweak standard fd sanitising to be more like the sanitise_stdfd()
used elsewhere, though other uses of 'nullfd' make importing
sanitise_stdfd() itself unappetizing.

Add a die(0) if dup2() fails.

suggestions & ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.204 2016/02/17 18:31:28 bluhm Exp $	*/
d1900 1
a1900 1
					logerrorx(f->f_un.f_fname);
d1909 1
a1909 1
					logerrorx(f->f_un.f_fname);
d1962 1
a1962 1
		logerrorx(_PATH_UTMP);
d2641 1
a2641 1
			logerrorx(p);
@


1.204
log
@Prevent an integer overflow in syslogd when parsing the priority.
From Michael Savage; input and OK mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.203 2015/12/29 17:51:56 bluhm Exp $	*/
d439 3
a441 3
	for (fd = nullfd + 1; fd <= 2; fd++) {
		if (fcntl(fd, F_GETFL, 0) == -1)
			if (dup2(nullfd, fd) == -1)
d443 2
d2656 1
a2656 1
				if ((i = fcntl(f->f_file, F_GETFL, 0)) != -1) {
@


1.203
log
@When running syslogd in debug mode, use a callback to print the
libevent messages.  Before the code was removed from libevent, the
library itself printed that to stderr.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.202 2015/12/16 13:38:39 bluhm Exp $	*/
d331 1
d1491 27
d1530 1
a1530 7
	if (*p == '<') {
		pri = 0;
		while (isdigit((unsigned char)*++p))
			pri = 10 * pri + (*p - '0');
		if (*p == '>')
			++p;
	}
d1561 1
d1568 3
a1570 7
		if (*p == '<') {
			pri = 0;
			while (isdigit((unsigned char)*++p))
				pri = 10 * pri + (*p - '0');
			if (*p == '>')
				++p;
		} else {
@


1.202
log
@Adding mark messages to log files was broken since OpenBSD 5.7.
The mark timeout event is not persistent, add the timer intervall
everytime it fires.
Bug report, analysis and fix from Einfach Jemand rru.142 at gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.201 2015/10/24 12:49:37 bluhm Exp $	*/
d324 1
d713 2
d2029 6
@


1.201
log
@If loading the CA certificates at startup had failed, the syslogd
child tried to load the default CA file when it was connecting to
a TLS server.  The latter has never worked as the child is chrooted
to /var/empty.  Set the CA storage to an empty string to avoid this
behavior.  As a benefit pledge "rpath" can be removed.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.200 2015/10/23 16:28:52 bluhm Exp $	*/
d1998 3
d2002 4
@


1.200
log
@If writing to a tty blocks, syslogd forked and tried to write again
in a background process.  A potential fork(2) at every message is
bad, so replace this with an event.  As a bonus the syslogd child
process does not need to pledge "proc" anymore.  Also limit the
number of delayed write events.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.199 2015/10/21 14:03:07 bluhm Exp $	*/
d553 1
d571 1
d575 3
d708 1
a708 1
	if (pledge("stdio rpath unix inet recvfd", NULL) == -1)
@


1.199
log
@Do some cleanup in syslogd ttymsg().  Add a debug message when the
syslogd child calls fork(2) to delay blocked output.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.198 2015/10/15 20:26:47 bluhm Exp $	*/
a55 1
#define MAXLINE		8192		/* maximum line length */
d703 1
a703 1
	if (pledge("stdio rpath unix inet proc recvfd", NULL) == -1)
d1954 1
a1954 2
				if ((p = ttymsg(iov, 6, utline))
				    != NULL)
@


1.198
log
@In syslogd replace the dprintf() macro with a logdebug() function
as dprintf(3) is in libc now and does something different.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.197 2015/10/11 23:51:26 bluhm Exp $	*/
a66 2
#define TTYMSGTIME	1		/* timeout passed to ttymsg */
#define ERRBUFSIZE	256
a332 1
char   *ttymsg(struct iovec *, int, char *, int);
d1926 1
a1926 1
	char line[sizeof(ut.ut_line) + 1], *p;
d1942 2
a1943 2
		strncpy(line, ut.ut_line, sizeof(line) - 1);
		line[sizeof(line) - 1] = '\0';
d1945 1
a1945 1
			if ((p = ttymsg(iov, 6, line, TTYMSGTIME)) != NULL)
d1955 1
a1955 1
				if ((p = ttymsg(iov, 6, line, TTYMSGTIME))
@


1.197
log
@Pass unsigned char to isdigit(3).
From Michael McConville; OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.196 2015/10/11 20:23:49 guenther Exp $	*/
d516 1
a516 1
			dprintf("can't open %s (%d)\n", path_ctlsock, errno);
d529 1
a529 1
		dprintf("can't open %s (%d)\n", _PATH_KLOG, errno);
d532 1
a532 1
			dprintf("LIOCSFD errno %d\n", errno);
d574 1
a574 1
				dprintf("CAfile %s, size %lld\n",
d615 1
a615 1
			dprintf("Keyfile %s, size %lld\n", path, sb.st_size);
d648 1
a648 1
			dprintf("Certfile %s, size %lld\n",
d667 1
a667 1
	dprintf("off & running....\n");
d823 1
a823 1
	dprintf("syslogd: started\n");
d886 1
a886 1
			dprintf("Malformed bind address\n");
d969 1
a969 1
		dprintf("cvthname res: %s\n", resolve);
d1001 1
a1001 1
		dprintf("Listen again\n");
d1052 1
a1052 1
	dprintf("Accepting tcp connection\n");
d1059 1
a1059 1
		dprintf("Malformed accept address\n");
d1062 1
a1062 1
	dprintf("Peer addresss and port %s\n", peername);
d1091 1
a1091 1
		dprintf("tcp accept callback: tls context success\n");
d1096 1
a1096 1
		dprintf("Host name for accept address (%s) unknown\n",
d1102 1
a1102 1
	dprintf("Peer hostname %s\n", hostname);
d1143 1
a1143 1
		dprintf(" octet counting %d", len);
d1174 1
a1174 1
	dprintf(" non transparent framing");
d1196 1
a1196 1
		dprintf("%s logger \"%s\"", p->p_ctx ? "tls" : "tcp",
d1203 1
a1203 1
			dprintf("unknown method");
d1205 1
a1205 1
			dprintf(", incomplete frame");
d1208 1
a1208 1
		dprintf(", use %d bytes\n", len);
d1221 1
a1221 1
		dprintf(", use %zu bytes\n", EVBUFFER_LENGTH(bufev->input));
d1225 1
a1225 1
		dprintf(", buffer %zu bytes\n", EVBUFFER_LENGTH(bufev->input));
d1288 1
a1288 1
	dprintf("loghost \"%s\" did send %zu bytes back\n",
d1302 1
a1302 1
	dprintf("loghost \"%s\" successful write\n", f->f_un.f_forw.f_loghost);
d1334 1
a1334 1
	dprintf("%s\n", ebuf);
d1363 1
a1363 1
		dprintf("loghost \"%s\" dropped partial message\n",
d1386 1
a1386 1
	dprintf("tcp connect callback: socket success, event %#x\n", event);
d1418 1
a1418 1
		dprintf("tcp connect callback: tls context success\n");
d1451 2
a1452 1
	dprintf("tcp connect retry: wait %d\n", f->f_un.f_forw.f_reconnectwait);
d1576 1
a1576 1
	dprintf("logmsg: pri 0%o, flags 0x%x, from %s, msg %s\n",
d1657 1
a1657 1
			dprintf("msg repeated %d times, %ld sec of %d\n",
d1747 1
a1747 1
	dprintf("Logging to %s", TypeNames[f->f_type]);
d1752 1
a1752 1
		dprintf("\n");
d1756 1
a1756 1
		dprintf(" %s\n", f->f_un.f_forw.f_loghost);
d1786 1
a1786 1
		dprintf(" %s", f->f_un.f_forw.f_loghost);
d1789 1
a1789 1
			dprintf(" (dropped)\n");
d1805 1
a1805 1
			dprintf(" (dropped snprintf)\n");
d1817 1
a1817 1
			dprintf(" (dropped evbuffer_add_printf)\n");
d1822 1
a1822 1
		dprintf("\n");
d1827 1
a1827 1
			dprintf(" (ignored)\n");
d1835 1
a1835 1
		dprintf(" %s\n", f->f_un.f_fname);
d1899 1
a1899 1
		dprintf("\n");
d1906 1
a1906 1
		dprintf("\n");
d1977 1
a1977 1
		dprintf("Malformed from address\n");
d1981 1
a1981 1
	dprintf("cvthname(%s)\n", result);
d1986 1
a1986 1
		dprintf("Host name for from address (%s) unknown\n", result);
d2010 1
a2010 1
	dprintf("syslogd: restarted\n");
d2021 12
a2032 3
/*
 * Print syslogd errors some place.
 */
d2062 1
a2062 1
	dprintf("%s\n", ebuf);
d2098 1
a2098 1
		dprintf("syslogd: exiting on signal %d\n", signo);
d2103 1
a2103 1
	dprintf("[unpriv] syslogd child about to exit\n");
d2120 1
a2120 1
	dprintf("init\n");
d2124 1
a2124 1
		dprintf("config file changed: dying\n");
d2165 1
a2165 1
			dprintf("add %p to mb\n", f);
d2174 1
a2174 1
		dprintf("cannot open %s\n", ConfFile);
d2241 2
a2242 1
		dprintf("Initialize membuf %s at %p\n", f->f_un.f_mb.f_mname, f);
d2252 1
a2252 1
			dprintf("Membuf no match\n");
d2259 1
a2259 1
			dprintf("Membuf match f:%p, m:%p\n", f, m);
d2273 1
a2273 1
		dprintf("Freeing membuf %p\n", m);
d2346 1
a2346 1
				dprintf("duplicate %s\n", f->f_un.f_fname);
d2355 1
a2355 1
				dprintf("duplicate membuf %s\n",
d2378 1
a2378 1
	dprintf("cfline(\"%s\", f, \"%s\", \"%s\")\n",
d2736 1
a2736 1
		dprintf("couldn't get kern.msgbufsize\n");
d2780 1
a2780 1
			dprintf("flush %s: repeated %d times, %d sec.\n",
d2903 1
a2903 1
	dprintf("Accepting control connection\n");
d2989 1
a2989 1
	dprintf("ctlcmd %x logname \"%s\"\n", ctl_cmd.cmd, ctl_cmd.logname);
d3054 1
a3054 1
	dprintf("ctlcmd reply length %lu\n", (u_long)ctl_reply_size);
@


1.196
log
@Userspace doesn't need to use SUN_LEN(): connect() and bind() must accept
sizeof(struct sockaddr_un), so do the simple, portable thing.
Also convert some strncpy() to strlcpy()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.195 2015/10/10 20:35:01 deraadt Exp $	*/
d1126 1
a1126 1
	if (buf >= end || !isdigit(*buf))
d1134 1
a1134 1
		if (!isdigit(*p))
@


1.195
log
@normalize a few more tame request orderings, to help review
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.194 2015/10/09 16:58:25 bluhm Exp $	*/
a493 3
#ifndef SUN_LEN
#define SUN_LEN(unp) (strlen((unp)->sun_path) + 2)
#endif
d2813 1
a2813 1
	if (bind(fd, (struct sockaddr *)&s_un, SUN_LEN(&s_un)) == -1) {
@


1.194
log
@If syslogd is started with -S, it accepts TLS connections to receive
encrypted messages.  The server certificates are taken from /etc/ssl
like relayd does.
OK benno@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.193 2015/10/09 16:44:55 bluhm Exp $	*/
d710 1
a710 1
	if (pledge("stdio rpath unix inet recvfd proc", NULL) == -1)
@


1.193
log
@A fork(2) is used in ttymsg() to delay the message to a tty if it
blocks.  Fix the potential syslogd's death, add "proc" to pledge.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.192 2015/10/09 16:29:17 deraadt Exp $	*/
d53 1
a53 1
 * IPv6, libevent, sending over TCP and TLS by Alexander Bluhm
d222 3
d227 2
a228 1
struct	tls_config *tlsconfig = NULL;
d280 2
a281 2
int		 fd_ctlsock, fd_ctlconn, fd_klog, fd_sendsys,
		 fd_udp, fd_udp6, fd_bind, fd_listen, fd_unix[MAXUNIX];
d285 1
d287 1
d350 2
a351 2
	struct event	*ev_klog, *ev_sendsys,
			*ev_udp, *ev_udp6, *ev_bind, *ev_listen, *ev_unix,
d358 1
a358 1
	while ((ch = getopt(argc, argv, "46a:C:dFf:hm:np:s:T:U:uV")) != -1)
d398 7
d486 7
a540 5
	} else if ((tlsconfig = tls_config_new()) == NULL) {
		logerror("tls_config_new");
	} else if (NoVerify) {
		tls_config_insecure_noverifycert(tlsconfig);
		tls_config_insecure_noverifyname(tlsconfig);
d542 46
d589 34
d626 13
a638 2
		if ((fd = open(CAfile, O_RDONLY)) == -1) {
			logerror("open CAfile");
d640 3
a642 3
			logerror("fstat CAfile");
		} else if (sb.st_size > 50*1024*1024) {
			logerrorx("CAfile larger than 50MB");
d644 1
a644 1
			logerror("calloc CAfile");
d646 4
a649 4
			logerror("read CAfile");
		} else if (tls_config_set_ca_mem(tlsconfig, p, sb.st_size)
		    == -1) {
			logerrorx("tls_config_set_ca_mem");
d651 2
a652 1
			dprintf("CAfile %s, size %lld\n", CAfile, sb.st_size);
d656 12
a667 5
	}
	if (tlsconfig) {
		tls_config_set_protocols(tlsconfig, TLS_PROTOCOLS_ALL);
		if (tls_config_set_ciphers(tlsconfig, "compat") != 0)
			logerror("tls set ciphers");
d725 1
d748 1
d803 2
d846 1
a846 1
		port = "syslog";
d1036 1
a1036 1
tcp_acceptcb(int fd, short event, void *arg)
d1044 1
d1047 1
a1047 1
	if ((fd = reserve_accept4(fd, event, ev, tcp_acceptcb,
d1081 15
d1109 2
a1110 2
	snprintf(ebuf, sizeof(ebuf), "syslogd: tcp logger \"%s\" accepted",
	    peername);
d1199 2
a1200 1
		dprintf("tcp logger \"%s\"", p->p_peername);
d1238 3
a1240 2
		snprintf(ebuf, sizeof(ebuf), "syslogd: tcp logger \"%s\" "
		    "connection close", p->p_peername);
d1243 4
a1246 2
		snprintf(ebuf, sizeof(ebuf), "syslogd: tcp logger \"%s\" "
		    "connection error: %s", p->p_peername, strerror(errno));
d1407 2
a1408 2
		if (tlsconfig &&
		    tls_configure(f->f_un.f_forw.f_ctx, tlsconfig) == -1) {
d1482 2
a1483 2
	    "               [-m mark_interval] [-p log_socket] [-s reporting_socket]\n"
	    "               [-T listen_address] [-U bind_address]\n");
@


1.192
log
@catch up to tame() -> pledge() rename
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.191 2015/10/09 12:07:32 bluhm Exp $	*/
d596 1
a596 1
	if (pledge("stdio rpath unix inet recvfd", NULL) == -1)
@


1.191
log
@Tame syslogd privsep child with "stdio rpath unix inet recvfd".
With and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.190 2015/09/29 03:19:23 guenther Exp $	*/
d596 2
a597 2
	if (tame("stdio rpath unix inet recvfd", NULL) == -1)
		err(1, "tame");
@


1.190
log
@Delete the final, inscrutable NOSTRICT and VARARGS lint comments

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.189 2015/09/12 13:50:29 bluhm Exp $	*/
d595 3
@


1.189
log
@It is not necessary to reset errno to 0 since we use logerrorx().
Spotted by jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.188 2015/09/11 21:33:16 bluhm Exp $	*/
d1802 1
a1802 2
	/* NOSTRICT */
	while (fread((char *)&ut, sizeof(ut), 1, uf) == 1) {
@


1.188
log
@Instead of printing errno strings here and there, add a logerrorx()
to syslogd that does not do that.  Use it for anything that does
not look like a system call or library call around it.
Also add logerrorctx() that prints the TLS error instead.
Reduce the maximum CAfile limit to 50MB, requested by Bob.
OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.187 2015/09/11 12:42:12 bluhm Exp $	*/
a454 1
		errno = 0;
a461 1
		errno = 0;
a468 1
		errno = 0;
a530 1
		errno = 0;
@


1.187
log
@Syslog does not need the global list of TCP clients, libevent handles
everything.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.186 2015/09/10 19:02:09 bluhm Exp $	*/
d322 3
d456 1
a456 1
		logerror("socket bind *");
d464 1
a464 1
		logerror("socket bind udp");
d472 1
a472 1
		logerror("socket listen tcp");
d523 1
a523 1
		logerror("tls_init");
d539 2
a540 2
		} else if (sb.st_size > 1024*1024*1024) {
			logerror("CAfile larger than 1GB");
d547 1
a547 1
			logerror("tls_config_set_ca_mem");
d746 1
a746 1
		logerror(ebuf);
d1267 1
d1272 3
a1274 3
			snprintf(ebuf, sizeof(ebuf), "tls_configure "
			    "\"%s\": %s", f->f_un.f_forw.f_loghost,
			    tls_error(f->f_un.f_forw.f_ctx));
d1280 2
a1281 2
			    "\"%s\": %s", f->f_un.f_forw.f_loghost,
			    tls_error(f->f_un.f_forw.f_ctx));
a1293 1
	logerror(ebuf);
d1740 1
a1740 1
					logerror(f->f_un.f_fname);
d1749 1
a1749 1
					logerror(f->f_un.f_fname);
d1802 1
a1802 1
		logerror(_PATH_UTMP);
d1814 2
a1815 4
			if ((p = ttymsg(iov, 6, line, TTYMSGTIME)) != NULL) {
				errno = 0;	/* already in msg */
				logerror(p);
			}
d1825 2
a1826 4
								!= NULL) {
					errno = 0;	/* already in msg */
					logerror(p);
				}
d1891 19
a1909 1
logerror(const char *type)
d1913 1
a1913 1
	if (errno)
d1915 1
a1915 1
		    type, strerror(errno));
d1917 1
a1917 1
		(void)snprintf(ebuf, sizeof(ebuf), "syslogd: %s", type);
d1958 1
a1958 2
		errno = 0;
		logerror(ebuf);
d2126 1
a2126 1
			logerror("Mismatched membuf");
a2236 2
	errno = 0;	/* keep strerror() stuff out of logerror messages */

d2288 1
a2288 1
				logerror(ebuf);
d2308 1
a2308 1
					logerror(ebuf);
d2332 1
a2332 1
			logerror(ebuf);
d2338 1
a2338 1
			logerror(ebuf);
d2354 1
a2354 1
				logerror(ebuf);
d2361 1
a2361 1
				logerror(ebuf);
d2376 1
a2376 1
			logerror(ebuf);
d2382 1
a2382 1
			logerror(ebuf);
d2391 1
a2391 1
			logerror(ebuf);
d2399 1
a2399 1
			logerror(ebuf);
d2460 1
a2460 1
			logerror(p);
d2515 1
a2515 1
			logerror(p);
d2658 1
a2658 1
		logerror(ebuf);
d2827 1
a2827 1
		logerror("Unknown client protocol version");
d2834 1
a2834 1
		logerror("Corrupt ctlsock command");
d2902 1
a2902 1
		logerror("Unsupported ctlsock command");
d2932 1
a2932 1
		logerror("ctlconn_write with bad ctl_state");
@


1.186
log
@Instead of having global variables containing the libevent structures,
allocate them with malloc.  This makes the address space layout
more random.
OK deraadt@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.185 2015/09/10 18:32:06 bluhm Exp $	*/
a279 1
LIST_HEAD(peer_list, peer) peers;
a280 1
	LIST_ENTRY(peer)	 p_entry;
a285 1
int peernum = 0;
a970 2
	LIST_INSERT_HEAD(&peers, p, p_entry);
	peernum++;
a1109 2
	peernum--;
	LIST_REMOVE(p, p_entry);
@


1.185
log
@Convert syslogd TLS connect to use handshake callback.  The bt_hostname
can go away as the callback does not need the hostname anymore.
Call tls_handshake() until successful.  Remove the function
tls_socket() as it has a bad prefix.  Just call tls_client(),
tls_configure() and tls_connect_socket() after the TCP socket has
been created.  There is no need to wait until TCP connect has
finished.
OK beck@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.184 2015/09/09 08:12:46 bluhm Exp $	*/
d278 1
a278 3
struct event	 ev_ctlaccept, ev_ctlread, ev_ctlwrite, ev_klog, ev_sendsys,
		 ev_udp, ev_udp6, ev_bind, ev_listen, ev_unix[MAXUNIX],
		 ev_hup, ev_int, ev_quit, ev_term, ev_mark;
d344 3
d603 31
a633 14
	event_set(&ev_ctlaccept, fd_ctlsock, EV_READ|EV_PERSIST,
	    ctlsock_acceptcb, &ev_ctlaccept);
	event_set(&ev_ctlread, fd_ctlconn, EV_READ|EV_PERSIST,
	    ctlconn_readcb, &ev_ctlread);
	event_set(&ev_ctlwrite, fd_ctlconn, EV_WRITE|EV_PERSIST,
	    ctlconn_writecb, &ev_ctlwrite);
	event_set(&ev_klog, fd_klog, EV_READ|EV_PERSIST, klog_readcb, &ev_klog);
	event_set(&ev_sendsys, fd_sendsys, EV_READ|EV_PERSIST, unix_readcb,
	    &ev_sendsys);
	event_set(&ev_udp, fd_udp, EV_READ|EV_PERSIST, udp_readcb, &ev_udp);
	event_set(&ev_udp6, fd_udp6, EV_READ|EV_PERSIST, udp_readcb, &ev_udp6);
	event_set(&ev_bind, fd_bind, EV_READ|EV_PERSIST, udp_readcb, &ev_bind);
	event_set(&ev_listen, fd_listen, EV_READ|EV_PERSIST, tcp_acceptcb,
	    &ev_listen);
d638 4
a641 4
	signal_set(&ev_hup, SIGHUP, init_signalcb, &ev_hup);
	signal_set(&ev_int, SIGINT, die_signalcb, &ev_int);
	signal_set(&ev_quit, SIGQUIT, die_signalcb, &ev_quit);
	signal_set(&ev_term, SIGTERM, die_signalcb, &ev_term);
d643 1
a643 1
	evtimer_set(&ev_mark, mark_timercb, &ev_mark);
d673 1
a673 1
		event_add(&ev_ctlaccept, NULL);
d675 1
a675 1
		event_add(&ev_klog, NULL);
d677 1
a677 1
		event_add(&ev_sendsys, NULL);
d680 1
a680 1
			event_add(&ev_udp, NULL);
d682 1
a682 1
			event_add(&ev_udp6, NULL);
d685 1
a685 1
		event_add(&ev_bind, NULL);
d687 1
a687 1
		event_add(&ev_listen, NULL);
d692 2
a693 2
	signal_add(&ev_hup, NULL);
	signal_add(&ev_term, NULL);
d695 2
a696 2
		signal_add(&ev_int, NULL);
		signal_add(&ev_quit, NULL);
d706 1
a706 1
	evtimer_add(&ev_mark, &to);
d2727 3
a2729 3
	event_del(&ev_ctlread);
	event_del(&ev_ctlwrite);
	event_add(&ev_ctlaccept, NULL);
d2762 5
a2766 5
	event_set(&ev_ctlread, fd_ctlconn, EV_READ|EV_PERSIST,
	    ctlconn_readcb, &ev_ctlread);
	event_set(&ev_ctlwrite, fd_ctlconn, EV_WRITE|EV_PERSIST,
	    ctlconn_writecb, &ev_ctlwrite);
	event_add(&ev_ctlread, NULL);
d2909 1
a2909 1
	event_add(&ev_ctlwrite, NULL);
d2913 1
a2913 1
		event_add(&ev_ctlaccept, NULL);
d3013 1
a3013 1
	event_add(&ev_ctlwrite, NULL);
@


1.184
log
@To double the receive buffer of a socketpair does not help as sending
checks the send buffer size.  So double both buffer sizes.
Moreover the default for sending is 2048 and for receiving is 4096.
This makes the existing double buffer algorithm inconsistent.  It
is better to make the buffers large enough to hold 8 full length
messages.  Just make sure that it does not shrink.
Keep the approach that doubles the buffer sizes.  When we are low
on buffers and cannot reach the full size, increase it as much as
possible.
While there, add consistent error messages.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.183 2015/09/03 20:50:48 bluhm Exp $	*/
a308 1
struct tls *tls_socket(struct filed *);
d1231 1
a1231 1
	struct tls		*ctx;
d1250 18
a1267 5
		if ((ctx = tls_socket(f)) == NULL) {
			close(f->f_file);
			f->f_file = -1;
			tcp_connect_retry(bufev, f);
			return;
d1269 8
a1276 2
		dprintf("tcp connect callback: TLS context success\n");
		f->f_un.f_forw.f_ctx = ctx;
d1278 5
a1282 3
		buffertls_set(&f->f_un.f_forw.f_buftls, bufev, ctx, s);
		buffertls_connect(&f->f_un.f_forw.f_buftls, s,
		    f->f_un.f_forw.f_host);
d1284 3
a1307 24
}

struct tls *
tls_socket(struct filed *f)
{
	struct tls	*ctx;
	char		 ebuf[ERRBUFSIZE];

	if ((ctx = tls_client()) == NULL) {
		snprintf(ebuf, sizeof(ebuf), "tls_client \"%s\"",
		    f->f_un.f_forw.f_loghost);
		logerror(ebuf);
		return (NULL);
	}
	if (tlsconfig) {
		if (tls_configure(ctx, tlsconfig) < 0) {
			snprintf(ebuf, sizeof(ebuf), "tls_configure \"%s\": %s",
			    f->f_un.f_forw.f_loghost, tls_error(ctx));
			logerror(ebuf);
			tls_free(ctx);
			return (NULL);
		}
	}
	return (ctx);
@


1.183
log
@In sendsyslog(2) I got the plural s of messages right.  The messages
of syslogd(8) should be alike.  syslogd: dropped 1 message
OK lteo@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.182 2015/09/03 14:50:53 bluhm Exp $	*/
d340 1
a340 1
void	double_rbuf(int);
d487 1
a487 1
		double_rbuf(fd_unix[i]);
d490 2
a491 1
	if (socketpair(AF_UNIX, SOCK_DGRAM, PF_UNSPEC, pair) == -1)
d493 3
a496 1
	double_rbuf(fd_sendsys);
d798 1
a798 1
			double_rbuf(*fdp);
d2677 1
a2677 1
		logerror("cannot setsockopt unix");
d2683 1
a2683 1
double_rbuf(int fd)
d2685 2
a2686 1
	socklen_t slen, len;
d2688 11
a2698 4
	slen = sizeof(len);
	if (getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len, &slen) == 0) {
		len *= 2;
		setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len, slen);
@


1.182
log
@Instead of creating a line buffer on the stack, tcp_readcb() can
use the global linebuf like the other libevent read callbacks.
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.181 2015/09/01 17:53:14 bluhm Exp $	*/
d1158 4
a1161 2
		    "syslogd: dropped %d messages to loghost \"%s\"",
		    f->f_un.f_forw.f_dropped, f->f_un.f_forw.f_loghost);
d1868 2
a1869 2
		    "syslogd: dropped %d messages to remote loghost",
		    tcpbuf_dropped);
d1918 2
a1919 2
		    "syslogd: dropped %d messages to remote loghost",
		    tcpbuf_dropped);
@


1.181
log
@Bind the *:514 UDP socket of syslogd with SO_REUSEADDR.  This avoids
conflicts with other processes bound to a specific address with the
same port.  Syslogd uses this socket basically for outgoing traffic
to remote UDP log servers, so increase the chance that it works.
OK jung@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.180 2015/08/31 20:44:47 bluhm Exp $	*/
d1044 1
a1044 2
	char			*msg, line[MAXLINE + 1];
	size_t			 linelen;
d1063 3
a1065 4
			linelen = MINIMUM((size_t)len, sizeof(line)-1);
			memcpy(line, msg, linelen);
			line[linelen] = '\0';
			msg = line;
@


1.180
log
@The !prog and +host features allow to select log messages from a
specific programm or host.  It does not make sense to truncate the
string from the config at some character from a list.  Just take
whatever the user specified as progname or hostname.  If it contains
funky charactes it will not match and the action is not taken.  This
fixes matching with IP addresses if syslogd is started with -n.
OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.179 2015/08/27 17:53:35 bluhm Exp $	*/
d337 1
a337 1
int	socket_bind(const char *, const char *, const char *, int, int,
d453 1
a453 1
	if (socket_bind("udp", NULL, "syslog", 0, SecureMode,
d461 1
a461 1
	if (bind_host && socket_bind("udp", bind_host, bind_port, 1, 0,
d469 1
a469 1
	if (listen_host && socket_bind("tcp", listen_host, listen_port, 1, 0,
d698 1
a698 1
    int reuseaddr, int shutread, int *fd, int *fd6)
d703 1
a703 1
	int		*fdp, error;
d764 1
@


1.179
log
@When syslogd is reloading a modified config, it does a reexec on
itself.  For this it uses the original arguments of main().  The
function loghost_parse() modifies the optarg memory it is operating
on.  To prevent that the exec arguments have been tampered, pass a
copy of optarg to loghost_parse().
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.178 2015/08/25 17:14:16 bluhm Exp $	*/
d1940 1
a1940 1
	char progblock[NAME_MAX+1], hostblock[NAME_MAX+1], *cline, *p;
d2028 2
a2029 1
		if (*p == '!') {
d2033 1
a2033 1
			if (!*p || (*p == '*' && (!p[1] ||
d2035 1
a2035 1
				strlcpy(progblock, "*", sizeof(progblock));
d2039 1
a2039 2
				if (!isalnum((unsigned char)p[i]) &&
				    p[i] != '-' && p[i] != '!')
d2041 1
a2041 1
				progblock[i] = p[i];
d2043 1
a2043 19
			progblock[i] = 0;
			continue;
		}
		if (*p == '+') {
			p++;
			while (isspace((unsigned char)*p))
				p++;
			if (!*p || (*p == '*' && (!p[1] ||
			    isspace((unsigned char)p[1])))) {
				strlcpy(hostblock, "*", sizeof(hostblock));
				continue;
			}
			for (i = 0; i < NAME_MAX; i++) {
				if (!isalnum((unsigned char)p[i]) &&
				    p[i] != '-' && p[i] != '+')
					break;
				hostblock[i] = p[i];
			}
			hostblock[i] = 0;
@


1.178
log
@strlcpy() accesses the source string until it finds NUL, even if
it is behind the size limit.  As msg is not NUL-terminated in this
case, it depended on memory content wether syslogd will crash.  So
using memcpy() and setting the NUL explicitly is the correct way.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.177 2015/07/20 19:49:33 bluhm Exp $	*/
d396 4
a399 2
			if (loghost_parse(optarg, NULL, &listen_host,
			    &listen_port) == -1)
d403 3
a405 1
			if (loghost_parse(optarg, NULL, &bind_host, &bind_port)
@


1.177
log
@Do not reconnect outgoing TCP connections too aggressively.  In
case the receiver closes the connection, wait for a second to give
him a chance to recover.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.176 2015/07/20 17:47:38 bluhm Exp $	*/
d1040 1
d1059 3
a1061 2
			strlcpy(line, msg,
			    MINIMUM((size_t)len+1, sizeof(line)));
@


1.176
log
@Do not accept sockets when syslogd reaches the file descriptor
limit.  Instead disable the listen event and wait for a second.
Keep a reserve of 5 file descriptors.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.175 2015/07/19 20:10:46 bluhm Exp $	*/
d308 1
d1211 1
a1211 1
	tcp_connectcb(-1, 0, f);
a1222 1
	struct timeval		 to;
d1225 4
a1228 9
	if ((event & EV_TIMEOUT) == 0 && f->f_un.f_forw.f_reconnectwait > 0)
		goto retry;

	/* Avoid busy reconnect loop, delay until successful write. */
	if (f->f_un.f_forw.f_reconnectwait == 0)
		f->f_un.f_forw.f_reconnectwait = 1;

	if ((s = tcp_socket(f)) == -1)
		goto retry;
d1244 2
a1245 1
			goto retry;
d1254 1
d1256 4
a1259 1
	return;
d1261 4
a1264 2
 retry:
	f->f_un.f_forw.f_reconnectwait <<= 1;
d1270 1
a1270 2
	dprintf("tcp connect callback: retry, event %#x, wait %d\n",
	    event, f->f_un.f_forw.f_reconnectwait);
@


1.175
log
@For incoming TCP message streams autodetect wether the method is
octet counting or non transparent framing.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.174 2015/07/18 22:33:46 bluhm Exp $	*/
d63 1
a63 1
#define MAXTCP		20		/* maximum incomming connections */
d296 2
d498 1
a498 1
			if (listen(fd_ctlsock, 16) == -1) {
d779 1
a779 1
		    listen(*fdp, MAXTCP) == -1) {
d851 41
d895 1
a901 1
	dprintf("Accepting tcp connection\n");
d903 4
a906 3
	fd = accept4(fd, (struct sockaddr *)&ss, &sslen, SOCK_NONBLOCK);
	if (fd == -1) {
		if (errno != EINTR && errno != EWOULDBLOCK &&
d911 1
a921 7
	if (peernum >= MAXTCP) {
		snprintf(ebuf, sizeof(ebuf), "syslogd: tcp logger \"%s\" "
		    "denied: maximum %d reached", peername, MAXTCP);
		logmsg(LOG_SYSLOG|LOG_WARNING, ebuf, LocalHostName, ADDDATE);
		close(fd);
		return;
	}
d2726 4
a2729 4
	dprintf("Accepting control connection\n");
	fd = accept4(fd, NULL, NULL, SOCK_NONBLOCK);
	if (fd == -1) {
		if (errno != EINTR && errno != EWOULDBLOCK &&
d2734 1
@


1.174
log
@As libtls previously did not set SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER,
syslogd had to drop messages after tls_write() returned
TLS_{READ,WRITE}_AGAIN.  Now after libtls has been fixed, remove
the workaround.  Messages are stored in the libevent write buffer
as we can safely do a realloc(3) now.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.173 2015/07/16 23:29:14 bluhm Exp $	*/
d297 2
d919 77
d1000 2
a1001 1
	char			*line;
d1003 26
a1028 12
	/*
	 * Syslog over TCP  RFC 6587  3.4.2.  Non-Transparent-Framing
	 * XXX Incompatible to ourself, should do:  3.4.1.  Octet Counting
	 */
	while ((line = evbuffer_readline(bufev->input))) {
		dprintf("tcp logger \"%s\" complete line\n", p->p_peername);
		printline(p->p_hostname, line);
		free(line);
	}
	if (EVBUFFER_LENGTH(bufev->input) >= MAXLINE) {
		dprintf("tcp logger \"%s\" incomplete line, use %zu bytes\n",
		    p->p_peername, EVBUFFER_LENGTH(bufev->input));
d1031 2
a1032 5
	}
	if (EVBUFFER_LENGTH(bufev->input) > 0) {
		dprintf("tcp logger \"%s\" buffer %zu bytes\n",
		    p->p_peername, EVBUFFER_LENGTH(bufev->input));
	}
d1156 2
a1157 7
	for (p = buf; p < end && p < buf + 4; p++) {
		if (!isdigit(*p))
			break;
	}
	/* Using atoi() is safe as buf starts with 1 to 4 digits and a space. */
	if (buf < end && !(buf + 1 <= p && p < end && *p == ' ' &&
	    (l = atoi(buf)) > 0 && buf + l < end && buf[l] == '\n')) {
d1166 1
a1166 1
			evbuffer_drain(bufev->output, p - buf);
@


1.173
log
@When incrementing msg, decrement msglen.  Otherwise too much data
could be written into the log file.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.172 2015/07/09 16:01:48 bluhm Exp $	*/
d1501 1
a1502 15
		if (f->f_un.f_forw.f_buftls.bt_flags & BT_WRITE_AGAIN) {
			/*
			 * After an OpenSSL SSL_ERROR_WANT_WRITE you must not
			 * modify the buffer pointer or length until the next
			 * successful write.  Otherwise there will be an
			 * error SSL3_WRITE_PENDING:bad write retry.
			 * XXX This should be handled in the buffertls layer.
			 */
			dprintf(" %s (dropped tls write again)\n",
			    f->f_un.f_forw.f_loghost);
			f->f_un.f_forw.f_dropped++;
			break;
		}
		/* FALLTHROUGH */
	case F_FORWTCP:
@


1.172
log
@Set f_hostname to NULL after free() to avoid a double free when
both !host and memory buffer are used.
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.171 2015/07/07 17:53:04 bluhm Exp $	*/
d1324 1
a1324 1
	while (isspace((unsigned char)*msg))
d1326 2
@


1.171
log
@When syslogd is invoked with -T listen_address, it creates a TCP
socket and accepts incomming messages.  At the moment, only RFC
6587 3.4.2. Non-Transparent-Framing format with new-line separator
is supprted for incomming messsages.  Outgoing messages are encoded
as 3.4.1. Octet Counting.  Autodetection of incomming format will
be implemented later.
OK deraadt@@ jmc@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.170 2015/07/06 16:12:16 millert Exp $	*/
d1872 1
@


1.170
log
@Remove some unneeded includes.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.169 2015/07/05 22:05:12 bluhm Exp $	*/
d63 1
d220 2
a221 1

d277 1
a277 1
		 fd_udp, fd_udp6, fd_bind, fd_unix[MAXUNIX];
d279 1
a279 1
		 ev_udp, ev_udp6, ev_bind, ev_unix[MAXUNIX],
d282 11
d296 3
d300 1
a300 1
void	 tcp_readcb(struct bufferevent *, void *);
d347 1
a347 1
	while ((ch = getopt(argc, argv, "46a:C:dFf:hm:np:s:U:uV")) != -1)
d390 5
d459 8
d603 2
d657 2
d743 1
d774 10
d847 124
d996 1
a996 1
tcp_readcb(struct bufferevent *bufev, void *arg)
d1114 1
a1114 1
	bufferevent_setcb(bufev, tcp_readcb, tcp_writecb, tcp_errorcb, f);
d1198 1
a1198 1
	    "               [-U bind_address]\n");
d1712 1
a1712 1
		strlcpy(result, "???", res_len);
d1720 1
a1720 1
		dprintf("Host name for your address (%s) unknown\n", result);
d2285 1
a2285 1
			    tcp_readcb, tcp_writecb, tcp_errorcb, f)) == NULL) {
@


1.169
log
@Let syslogd run with non-blocking sockets.  Replace the existing
fcntl(O_NONBLOCK) with the simpler SOCK_NONBLOCK and add this flag
to the UDP sockets.  React to EWOULDBLOCK although it should not
happen.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.168 2015/07/02 16:24:48 bluhm Exp $	*/
a70 2
#include <sys/wait.h>
#include <sys/socket.h>
a72 1
#include <sys/uio.h>
a88 1
#include <poll.h>
@


1.168
log
@To avoid copying the socket creation code for upcoming TCP listen
again, move it to the common function socket_bind().
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.167 2015/06/30 18:41:24 bluhm Exp $	*/
d706 2
a707 2
		if ((*fdp = socket(res->ai_family, res->ai_socktype,
		    res->ai_protocol)) == -1)
d787 1
a787 1
	} else if (n < 0 && errno != EINTR)
d803 1
a803 1
	} else if (n < 0 && errno != EINTR)
d810 1
a810 1
	int	 s, flags;
d813 2
a814 2
	if ((s = socket(f->f_un.f_forw.f_addr.ss_family, SOCK_STREAM,
	    IPPROTO_TCP)) == -1) {
a819 9
	/* Connect must not block the process. */
	if ((flags = fcntl(s, F_GETFL)) == -1 ||
	    fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1) {
		snprintf(ebuf, sizeof(ebuf), "fcntl \"%s\" O_NONBLOCK",
		    f->f_un.f_forw.f_loghost);
		logerror(ebuf);
		close(s);
		return (-1);
	}
d1324 1
a2447 1
	int			 flags;
d2450 1
a2450 1
	fd = accept(fd, NULL, NULL);
a2463 7
	if ((flags = fcntl(fd, F_GETFL)) == -1 ||
	    fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
		logerror("fcntl ctlconn O_NONBLOCK");
		close(fd);
		return;
	}

d2510 2
d2641 2
@


1.167
log
@Sort the syslogd getopt string and switch cases according to the
man page.  This makes it easier to check wether both are consistent.
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.166 2015/06/30 12:03:32 bluhm Exp $	*/
a218 2
int	IPv4Only = 0;		/* when true, disable IPv6 */
int	IPv6Only = 0;		/* when true, disable IPv4 */
d220 2
a221 1
char	*bind_host = NULL;
d320 2
a328 1
	struct addrinfo	 hints, *res, *res0;
d338 1
a338 2
			IPv4Only = 1;
			IPv6Only = 0;
d341 1
a341 2
			IPv6Only = 1;
			IPv4Only = 0;
d427 2
a428 7
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_protocol = IPPROTO_UDP;
	hints.ai_flags = AI_PASSIVE;

	if (getaddrinfo(NULL, "syslog", &hints, &res0)) {
d430 3
a432 44
		logerror("syslog/udp: unknown service");
		die(0);
	}

	fd_udp = fd_udp6 = -1;
	for (res = res0; res; res = res->ai_next) {
		int *fdp;

		switch (res->ai_family) {
		case AF_INET:
			if (IPv6Only)
				continue;
			fdp = &fd_udp;
			break;
		case AF_INET6:
			if (IPv4Only)
				continue;
			fdp = &fd_udp6;
			break;
		default:
			continue;
		}

		if (*fdp >= 0)
			continue;

		*fdp = socket(res->ai_family, res->ai_socktype,
		    res->ai_protocol);
		if (*fdp == -1)
			continue;

		if (bind(*fdp, res->ai_addr, res->ai_addrlen) < 0) {
			logerror("bind");
			close(*fdp);
			*fdp = -1;
			if (!Debug)
				die(0);
			continue;
		}

		if (SecureMode)
			shutdown(*fdp, SHUT_RD);
		else
			double_rbuf(*fdp);
a433 3

	freeaddrinfo(res0);

d435 5
a439 6
	if (bind_host) {
		if (bind_port == NULL)
			bind_port = "syslog";
		if (getaddrinfo(bind_host, bind_port, &hints, &res0)) {
			errno = 0;
			logerror("syslog/udp: unknown bind address");
a440 48
		}

		for (res = res0; res; res = res->ai_next) {
			switch (res->ai_family) {
			case AF_INET:
				if (IPv6Only)
					continue;
				break;
			case AF_INET6:
				if (IPv4Only)
					continue;
				break;
			default:
				continue;
			}

			fd_bind = socket(res->ai_family, res->ai_socktype,
			    res->ai_protocol);
			if (fd_bind == -1)
				continue;

			i = 1;
			if (setsockopt(fd_bind, SOL_SOCKET, SO_REUSEADDR,
			    &i, sizeof(i)) == -1) {
				logerror("setsockopt udp");
				close(fd_bind);
				fd_bind = -1;
				if (!Debug)
					die(0);
				continue;
			}
			if (bind(fd_bind, res->ai_addr, res->ai_addrlen) < 0) {
				logerror("bind udp");
				close(fd_bind);
				fd_bind = -1;
				if (!Debug)
					die(0);
				continue;
			}
			double_rbuf(fd_bind);
			break;
		}
		if (fd_bind == -1) {
			logerror("socket udp");
			die(0);
		}

		freeaddrinfo(res0);
d655 97
@


1.166
log
@Add a -U command line switch for syslogd to specify an explict bind
address to receive UDP packets.  One advantge over -u and the *
sockets is that you can bind to localhost and divert the packets
with pf.  It is also possible to use a non standard port.
OK jung@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.165 2015/06/29 11:04:28 bluhm Exp $	*/
d335 1
a335 1
	while ((ch = getopt(argc, argv, "46C:dhnuf:Fm:p:a:s:U:V")) != -1)
d345 5
d356 3
a361 3
		case 'F':		/* foreground */
			Foreground = 1;
			break;
d377 3
a386 8
			break;
		case 'a':
			if (nunix >= MAXUNIX)
				errx(1, "out of descriptors: %s", optarg);
			path_unix[nunix++] = optarg;
			break;
		case 's':
			path_ctlsock = optarg;
@


1.165
log
@Add the possiblity to store all syslog messages received from a
specific host into a single log file.  For programs this is already
implemented for !prog blocks.  So do the same with +host for
hostnames.
Based on a diff from Gregory Edigarov;  OK jung@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.164 2015/06/15 21:42:15 bluhm Exp $	*/
d222 2
d280 1
a280 1
		 fd_udp, fd_udp6, fd_unix[MAXUNIX];
d282 1
a282 1
		 ev_udp, ev_udp6, ev_unix[MAXUNIX],
d319 1
a319 1
int	loghost(char *, char **, char **, char **);
d335 1
a335 1
	while ((ch = getopt(argc, argv, "46C:dhnuf:Fm:p:a:s:V")) != -1)
d372 5
d435 1
a435 2
	i = getaddrinfo(NULL, "syslog", &hints, &res0);
	if (i) {
d485 58
d677 1
d728 2
d1045 2
a1046 1
	    "               [-m mark_interval] [-p log_socket] [-s reporting_socket]\n");
d2052 1
a2052 1
		if (loghost(++p, &proto, &host, &port) == -1) {
d2266 1
a2266 1
loghost(char *str, char **proto, char **host, char **port)
d2268 2
a2269 1
	*proto = NULL;
d2272 1
a2272 1
		*proto = str;
d2276 5
@


1.164
log
@Implement a -F switch, that tells syslogd to stay in foreground.
OK benno@@; input millert@@; no objections deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.163 2015/06/12 19:20:43 bluhm Exp $	*/
d138 1
d302 1
a302 1
struct filed *cfline(char *, char *);
d1131 5
a1135 4
		/* skip messages with the incorrect program name */
		if (f->f_program)
			if (strcmp(prog, f->f_program) != 0)
				continue;
d1600 1
a1600 1
	char prog[NAME_MAX+1], *cline, *p;
d1647 2
a1648 2
		if (f->f_program)
			free(f->f_program);
d1661 4
a1664 3
		SIMPLEQ_INSERT_TAIL(&Files, cfline("*.ERR\t/dev/console", "*"),
		    f_next);
		SIMPLEQ_INSERT_TAIL(&Files, cfline("*.PANIC\t*", "*"), f_next);
d1674 2
a1675 1
	strlcpy(prog, "*", sizeof(prog));
d1679 3
a1681 2
		 * spaces and newline character. !prog is treated
		 * specially: the following lines apply only to that program.
d1693 1
a1693 1
				strlcpy(prog, "*", sizeof(prog));
d1700 19
a1718 1
				prog[i] = p[i];
d1720 1
a1720 1
			prog[i] = 0;
d1723 1
d1731 1
a1731 1
		f = cfline(cline, prog);
d1818 4
a1821 2
			if (f->f_program)
				printf(" (%s)", f->f_program);
d1847 3
a1849 1
			    progmatches(list->f_program, f->f_program))
d1851 1
d1856 4
a1859 1
			    progmatches(list->f_program, f->f_program))
d1861 1
d1872 1
a1872 1
cfline(char *line, char *prog)
d1881 2
a1882 1
	dprintf("cfline(\"%s\", f, \"%s\")\n", line, prog);
d1894 7
a1900 1
	if (*prog == '!') {
d1902 5
a1906 7
		prog++;
	} else
		f->f_quick = 0;
	if (!strcmp(prog, "*"))
		prog = NULL;
	else
		f->f_program = strdup(prog);
@


1.163
log
@Close the lock pipe before dupping /dev/null to stdio.
This works even if the file descriptor is 0 or 1 or 2.
input and OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.162 2015/06/12 00:54:28 bluhm Exp $	*/
d208 1
d332 1
a332 1
	while ((ch = getopt(argc, argv, "46C:dhnuf:m:p:a:s:V")) != -1)
d351 3
d564 1
a564 1
	if (!Debug) {
d976 1
a976 1
	    "usage: syslogd [-46dhnuV] [-a path] [-C CAfile] [-f config_file]\n"
@


1.162
log
@If fork fails, print an error message before exit.
OK doug@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.161 2015/03/30 09:21:42 tobias Exp $	*/
d632 1
a635 1
		close(lockpipe[1]);
@


1.161
log
@Use getline instead of fgets to allow arbitrary line length in
configuration file. Also make sure that we fully parsed it.
If not, avoid to start a half-baked syslogd.

with input by and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.160 2015/02/24 01:29:49 bluhm Exp $	*/
d567 1
a567 1
			exit(1);
@


1.160
log
@Explain in a comment that atoi() is safe here.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.159 2015/02/22 15:09:54 jsing Exp $	*/
d1594 1
a1594 1
	char cline[LINE_MAX], prog[NAME_MAX+1], *p;
d1599 1
d1665 2
a1666 1
	f = NULL;
d1668 1
a1668 1
	while (fgets(cline, sizeof(cline), cf) != NULL) {
d1706 5
@


1.159
log
@Rename tls_config_insecure_noverifyhost() to
tls_config_insecure_noverifyname(), so that it is more accurate and keeps
inline with the distinction between DNS hostname and server name.

Requested by tedu@@ during s2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.158 2015/02/22 14:55:41 jsing Exp $	*/
d845 1
@


1.158
log
@Set the TLS ciphers to "compat" mode, restoring the previous behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.157 2015/02/20 00:56:32 bluhm Exp $	*/
a520 1
		tls_config_insecure_noverifyhost(tlsconfig);
d522 1
@


1.157
log
@When syslogd is writing over TLS, the error "SSL3_WRITE_PENDING:bad
write retry" may occur.  Unfortunately libtls tls_write() has
inherited the strange semantics regarding partial writes and buffer
movement from SSL_write().  This will be investigated after unlock,
the goal is to have the behavior of write(2) in libtls.

For now add a workaround in syslogd.  If tls_write() indicates that
it needs a read or write again, stop modifying the output buffer.
Instead drop and count the syslog messages.  After writing over TLS
was successful, continue to queue the messages.  This solution has
minimum inpact and will be improved after 5.7 release.

discussed with tedu@@ reyk@@ jsing@@;  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.156 2015/02/14 09:02:15 bluhm Exp $	*/
d548 1
a548 1
	if (tlsconfig)
d550 3
@


1.156
log
@Call tls_config_set_protocols(TLS_PROTOCOLS_ALL) also if the hostname
and certificate are not verified.
OK jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.155 2015/02/13 21:09:38 bluhm Exp $	*/
d1268 15
a1283 1
	case F_FORWTLS:
@


1.155
log
@When too many -a requests on the syslogd command line cannot be
fulfilled, it is better to fail hard.  Then the user can adjust
rc.conf.local or the #define MAXUNIX.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.154 2015/02/12 04:23:17 jsing Exp $	*/
d223 1
a223 1
struct	tls_config *tlsconfig;
a525 2
		tls_config_set_protocols(tlsconfig, TLS_PROTOCOLS_ALL);

d548 2
@


1.154
log
@Change TLS_PROTOCOLS_DEFAULT to be TLSv1.2 only. Add a TLS_PROTOCOLS_ALL
that includes all currently supported protocols (TLSv1.0, TLSv1.1 and
TLSv1.2). Change all users of libtls to use TLS_PROTOCOLS_ALL so that they
maintain existing behaviour.

Discussed with tedu@@ and reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.153 2015/02/10 18:30:20 bluhm Exp $	*/
d370 2
a371 5
				fprintf(stderr, "syslogd: "
				    "out of descriptors, ignoring %s\n",
				    optarg);
			else
				path_unix[nunix++] = optarg;
@


1.153
log
@Make error check consistent in all recvfrom(2) callbacks.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.152 2015/02/09 09:28:56 bluhm Exp $	*/
d528 2
@


1.152
log
@Fix format string of -m error message.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.151 2015/02/08 15:17:30 bluhm Exp $	*/
d732 1
a732 1
	} else if (n == -1 && errno != EINTR)
@


1.151
log
@Implement octet counting for sending syslog over TCP and TLS streams.
For TCP the standard recommends it, but TLS must use this framing.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.150 2015/02/08 01:30:09 reyk Exp $	*/
d356 1
a356 1
				errx(1, "mark_interval: %s", errstr, optarg);
@


1.150
log
@Use ebuf[ERRBUFSIZE] instead of ebuf[256] everywhere.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.149 2015/02/07 22:19:01 deraadt Exp $	*/
d808 2
d833 3
a835 3
	 * XXX The messages in the output buffer may be out of sync.
	 * Here we should clear the buffer or at least remove partial
	 * messages from the beginning.
d837 22
d1279 5
a1283 3
		 * RFC 6587  3.4.2.  Non-Transparent-Framing
		 * Use \n to split messages for now.
		 * 3.4.1.  Octet Counting might be implemented later.
d1285 9
d1295 3
a1297 1
		    "<%d>%.15s %s%s%s\n", f->f_prevpri, (char *)iov[0].iov_base,
d1302 1
a1302 1
			dprintf(" (dropped)\n");
@


1.149
log
@use strtonum() instead of atoi(); ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.148 2015/02/06 00:17:58 bluhm Exp $	*/
d67 1
d740 1
a740 1
	char	 ebuf[256];
d786 1
a786 1
	char		 ebuf[256];
d808 1
a808 1
	char		 ebuf[256];
d905 1
a905 1
	char		 ebuf[256];
d1457 1
a1457 1
	char	 ebuf[256];
d1480 1
a1480 1
	char ebuf[256];
d1500 1
a1500 1
	char ebuf[256];
d1779 1
a1779 1
	char buf[MAXLINE], ebuf[256];
@


1.148
log
@To get reliable TCP and TLS logging, report when messages get lost.
If the log server refuses to receive messages and the buffer gets
full, count the dropped messages.  Log the counter when the server
accepts messages again.  If there are messages in the buffer when
a signal is received, count and log them.
tested sthen@@;  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.147 2015/02/02 17:27:43 bluhm Exp $	*/
d325 1
d353 4
a356 1
			MarkInterval = atoi(optarg) * 60;
@


1.147
log
@As a result of the recommendations in RFC 5424, 5425, 5426 set the
maximum syslog message size to 8192 octets.  Restrict UDP sending
to 1180 octets payload to avoid fragmentation.  This is more than
the 1024 we supported before.
Also truncate the line in printline() to exactly 8192 bytes regardless
of visual encoding.  That is a more predictable behavior and makes
testing easier.
Although syslog(3) does not support long messages yet, make sure
that /dev/log can receive them.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.146 2015/01/31 00:58:35 bluhm Exp $	*/
d148 1
d225 1
d289 1
d781 1
d788 9
d920 15
d1242 1
a1242 1
		dprintf(" %s\n", f->f_un.f_forw.f_loghost);
d1244 5
a1248 2
		    MAX_TCPBUF)
			break;  /* XXX log error message */
d1259 5
a1263 2
		if (l < 0)
			break;  /* XXX log error message */
d1265 1
d1452 2
d1459 8
d1502 5
d1509 9
d1570 2
a1571 1
			/* XXX Save messages in output buffer for reconnect. */
@


1.146
log
@The error buffer in syslogd might be too small for the TLS errors.
Increase it to 256 bytes and call it ebuf everywhere.
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.145 2015/01/28 19:14:05 bluhm Exp $	*/
d56 2
a57 1
#define	MAXLINE		1024		/* maximum line length */
d102 1
d925 1
a925 1
	char *p, *q, line[MAXLINE + 1];
d948 1
a948 1
	for (q = line; *p && q < &line[sizeof(line) - 4]; p++) {
d954 1
a954 1
	*q = '\0';
d1186 2
a1187 2
		l = snprintf(line, sizeof(line), "<%d>%.15s %s%s%s",
		    f->f_prevpri, (char *)iov[0].iov_base,
d1191 2
a1192 2
		if (l < 0 || (size_t)l >= sizeof(line))
			l = strlen(line);
d2125 1
a2125 1
	int fd;
d2172 5
@


1.145
log
@If not explicitly disabled, syslogd verifies the x509 certificate
and hostname of the TLS server before sending any messages to it.
Per default /etc/ssl/cert.pem is used as CA file.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.144 2015/01/19 16:40:49 bluhm Exp $	*/
d730 1
a730 1
	char	 ebuf[100];
d788 1
a788 1
	char		 ebuf[100];
d885 1
a885 1
	char		 ebuf[100];
d1428 1
a1428 1
	char buf[100];
d1431 1
a1431 1
		(void)snprintf(buf, sizeof(buf), "syslogd: %s: %s",
d1434 1
a1434 1
		(void)snprintf(buf, sizeof(buf), "syslogd: %s", type);
d1436 1
a1436 1
	dprintf("%s\n", buf);
d1438 1
a1438 1
		fprintf(stderr, "%s\n", buf);
d1440 1
a1440 1
		logmsg(LOG_SYSLOG|LOG_ERR, buf, LocalHostName, ADDDATE);
d1448 1
a1448 1
	char buf[100];
d1459 2
a1460 1
		(void)snprintf(buf, sizeof buf, "exiting on signal %d", signo);
d1462 1
a1462 1
		logerror(buf);
d1712 1
a1712 1
	char buf[MAXLINE], ebuf[100];
d2122 1
a2122 1
	char errbuf[512];
d2130 2
a2131 3
		snprintf(errbuf, sizeof(errbuf), "socket path too long: %s",
		    path);
		logerror(errbuf);
d2154 2
a2155 2
		snprintf(errbuf, sizeof(errbuf), "cannot bind %s", path);
		logerror(errbuf);
d2164 2
a2165 2
		snprintf(errbuf, sizeof(errbuf), "cannot chmod %s", path);
		logerror(errbuf);
@


1.144
log
@Replace HOST_NAME_MAX+1 with NI_MAXHOST when the hostname is used
with getaddrinfo() or getnameinfo(), but keep HOST_NAME_MAX+1 when
the hostname comes from gethostname().
No binary change;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.143 2015/01/18 19:37:59 bluhm Exp $	*/
d144 1
d219 4
d324 1
a324 1
	while ((ch = getopt(argc, argv, "46dhnuf:m:p:a:s:")) != -1)
d334 3
d369 3
d509 33
d860 2
a861 2
		/* XXX no host given */
		buffertls_connect(&f->f_un.f_forw.f_buftls, s, NULL);
a883 1
	static struct tls_config *config;
a886 17
	if (config == NULL) {
		if (tls_init() < 0) {
			snprintf(ebuf, sizeof(ebuf), "tls_init \"%s\"",
			    f->f_un.f_forw.f_loghost);
			logerror(ebuf);
			return (NULL);
		}
		if ((config = tls_config_new()) == NULL) {
			snprintf(ebuf, sizeof(ebuf), "tls_config_new \"%s\"",
			    f->f_un.f_forw.f_loghost);
			logerror(ebuf);
			return (NULL);
		}
		/* XXX No verify for now, ca certs are outside of privsep. */
		tls_config_insecure_noverifyhost(config);
		tls_config_insecure_noverifycert(config);
	}
d893 8
a900 6
	if (tls_configure(ctx, config) < 0) {
		snprintf(ebuf, sizeof(ebuf), "tls_configure \"%s\": %s",
		    f->f_un.f_forw.f_loghost, tls_error(ctx));
		logerror(ebuf);
		tls_free(ctx);
		return (NULL);
d910 2
a911 2
	    "usage: syslogd [-46dhnu] [-a path] [-f config_file] [-m mark_interval]\n"
	    "               [-p log_socket] [-s reporting_socket]\n");
d1505 1
d1901 1
@


1.143
log
@Implement sending syslog messages over TLS.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.142 2015/01/16 06:40:21 deraadt Exp $	*/
d84 1
a85 1
#include <err.h>
d88 1
a96 1
#include <limits.h>
d138 1
a138 1
			char	f_loghost[1+4+3+1+HOST_NAME_MAX+1+1+NI_MAXSERV];
d656 1
a656 1
		char	 resolve[HOST_NAME_MAX+1];
d1828 1
a1828 1
		if (strlen(host) >= HOST_NAME_MAX+1) {
@


1.142
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.141 2015/01/15 11:49:59 bluhm Exp $	*/
d53 1
a53 1
 * IPv6, libevent, sending via TCP by Alexander Bluhm
d94 1
d106 1
d140 2
a141 1
			struct sockaddr_storage	f_addr;
d143 2
a144 1
			int	f_reconnectwait;
d189 1
d194 1
a194 1
	"PIPE",		"FORWTCP",
d279 1
d724 1
a724 2
	    f->f_un.f_forw.f_loghost,
	    EVBUFFER_LENGTH(f->f_un.f_forw.f_bufev->input));
d753 2
a754 1
		    f->f_un.f_forw.f_loghost, strerror(errno));
d758 5
d782 1
d795 2
a797 1
	dprintf("tcp connect callback: success, event %#x\n", event);
d805 14
a818 1
	f->f_file = s;
d837 40
d1183 1
d1472 6
d1618 1
d1681 1
a1681 1
	char *bp, *p, *q, *proto, *host, *port;
d1684 1
d1792 1
d1798 1
d1816 6
d1835 2
a1836 1
			port = "syslog";
d1843 1
a1843 1
		if (priv_getaddrinfo(proto, host, port,
d1862 1
a1862 1
		} else if (strncmp(proto, "tcp", 3) == 0) {
d1871 17
a1887 2
			f->f_type = F_FORWTCP;
			tcp_connectcb(-1, 0, f);
@


1.141
log
@When the connection to a TCP syslog server fails or the TCP connection
terminates, try to reconnect after an increasing timeout.
test and OK jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.140 2015/01/08 20:22:47 bluhm Exp $	*/
a66 1
#include <sys/param.h>
d95 1
d99 2
d136 1
a136 1
			char	f_loghost[1+4+3+1+MAXHOSTNAMELEN+1+NI_MAXSERV];
d142 1
a142 1
		char	f_fname[MAXPATHLEN];
d153 1
a153 1
	char	f_prevhost[MAXHOSTNAMELEN];	/* host from which recd. */
d199 1
a199 1
char	LocalHostName[MAXHOSTNAMELEN];	/* our hostname */
d650 1
a650 1
		char	 resolve[MAXHOSTNAMELEN];
d1745 1
a1745 1
		if (strlen(host) >= MAXHOSTNAMELEN) {
d1869 1
a1869 1
		rb_len = MAX(rb_len, MIN_MEMBUF);
@


1.140
log
@Use the field f_file also for the forwarding file descriptor.  Remove
the special f_fd field.  Also remove an useless F_FORWUDP case.
test and OK jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.139 2015/01/02 12:41:08 bluhm Exp $	*/
d138 1
d269 1
d271 1
d722 12
d749 1
d751 10
a760 9
	if ((f->f_file = tcp_socket(f)) == -1) {
		/* XXX reconnect later */
		bufferevent_free(bufev);
		f->f_type = F_UNUSED;
	} else {
		/* XXX The messages in the output buffer may be out of sync. */
		bufferevent_setfd(bufev, f->f_file);
		bufferevent_enable(f->f_un.f_forw.f_bufev, EV_READ);
	}
d765 45
d1777 2
a1778 6
			int s;

			if ((s = tcp_socket(f)) == -1)
				break;
			if ((f->f_un.f_forw.f_bufev = bufferevent_new(s,
			    tcp_readcb, NULL, tcp_errorcb, f)) == NULL) {
a1782 1
				close(s);
a1784 2
			bufferevent_enable(f->f_un.f_forw.f_bufev, EV_READ);
			f->f_file = s;
d1786 1
@


1.139
log
@Use SIMPLEQ for syslogd filed list instead of manual list operations.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.138 2015/01/02 12:30:45 bluhm Exp $	*/
a137 1
			int	f_fd;
d734 2
a735 2
	close(f->f_un.f_forw.f_fd);
	if ((f->f_un.f_forw.f_fd = tcp_socket(f)) == -1) {
d741 1
a741 1
		bufferevent_setfd(bufev, f->f_un.f_forw.f_fd);
d1033 1
a1033 1
		if (sendto(f->f_un.f_forw.f_fd, line, l, 0,
d1341 4
a1350 7
		case F_FORWUDP:
			break;
		case F_FORWTCP:
			/* XXX save messages in output buffer for reconnect */
			bufferevent_free(f->f_un.f_forw.f_bufev);
			close(f->f_un.f_forw.f_fd);
			break;
d1703 1
a1703 1
		f->f_un.f_forw.f_fd = -1;
d1707 1
a1707 1
				f->f_un.f_forw.f_fd = fd_udp;
d1710 1
a1710 1
				f->f_un.f_forw.f_fd = fd_udp6;
d1729 1
a1729 1
			f->f_un.f_forw.f_fd = s;
@


1.138
log
@When syslogd was sending via TCP, there was file descriptor leak
and a use after free if it received a SIGHUP.  Call bufferevent_free()
to deactivate the callbacks and close the TCP socket.
OK jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.137 2014/12/31 13:55:57 bluhm Exp $	*/
d73 1
d125 1
a125 1
	struct	filed *f_next;		/* next in linked list */
d190 1
a190 1
struct	filed *Files;
d901 1
a901 1
	for (f = Files; f; f = f->f_next) {
d1293 1
a1293 1
	for (f = Files; f != NULL; f = f->f_next) {
d1316 2
a1317 1
	struct filed *f, *next, **nextp, *mb, *m;
d1333 4
a1336 2
	mb = NULL;
	for (f = Files; f != NULL; f = next) {
a1355 1
		next = f->f_next;
a1358 1
			f->f_next = mb;
d1360 2
a1361 2
			dprintf("add %p to mb: %p\n", f, mb);
			mb = f;
d1363 1
a1363 1
			free((char *)f);
d1365 1
a1365 2
	Files = NULL;
	nextp = &Files;
d1370 3
a1372 2
		*nextp = cfline("*.ERR\t/dev/console", "*");
		(*nextp)->f_next = cfline("*.PANIC\t*", "*");
d1418 2
a1419 4
		if (f != NULL) {
			*nextp = f;
			nextp = &f->f_next;
		}
d1423 1
a1423 1
	for (f = Files; f != NULL; f = f->f_next) {
d1428 1
a1428 1
		for (m = mb; m != NULL; m = m->f_next) {
d1450 3
a1452 2
	while (mb != NULL) {
		m = mb;
a1458 1
		mb = m->f_next;
d1468 1
a1468 1
		for (f = Files; f; f = f->f_next) {
d1516 1
a1516 1
	for (list = Files; list; list = list->f_next) {
d1923 1
a1923 1
	for (f = Files; f; f = f->f_next) {
d2016 1
a2016 1
		for (f = Files; f != NULL; f = f->f_next)
d2067 1
a2067 1
	for (f = Files; f != NULL; f = f->f_next) {
d2170 1
a2170 1
		for (f = Files; f != NULL; f = f->f_next) {
@


1.137
log
@Implement sending syslog messages over TCP streams.
test and OK jasper@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.136 2014/12/10 19:42:14 tobias Exp $	*/
d1345 5
a1349 1
		case F_FORWTCP:  /* XXX close and reconnect? */
@


1.136
log
@If default file descriptors (0, 1, 2) have to be assigned to /dev/null,
don't accidentally assign 3, too.

ok millert, with input by and ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.135 2014/12/10 19:40:21 tobias Exp $	*/
d53 1
a53 1
 * IPv6, libevent by Alexander Bluhm
d60 1
d136 2
d176 1
a176 1
#define F_FORW		4		/* remote machine */
d181 1
d183 1
a183 1
char	*TypeNames[9] = {
d185 2
a186 2
	"FORW",		"USERS",	"WALL",		"MEMBUF",
	"PIPE"
d266 3
d671 76
d969 1
a969 1
	int fd, l, retryonce;
d1024 1
a1024 1
	case F_FORW:
a1025 11
		switch (f->f_un.f_forw.f_addr.ss_family) {
		case AF_INET:
			fd = fd_udp;
			break;
		case AF_INET6:
			fd = fd_udp6;
			break;
		default:
			fd = -1;
			break;
		}
d1033 1
a1033 1
		if (sendto(fd, line, l, 0,
d1052 20
d1344 2
a1345 1
		case F_FORW:
d1479 2
a1480 1
			case F_FORW:
d1672 3
d1703 29
a1731 1
		f->f_type = F_FORW;
d2042 1
a2042 1
		logerror("fcntl ctlconn");
@


1.135
log
@File descriptors are of type int, not short.  While at it, adjust remaining
short to int too -- there are no space savings anymore, as stated by millert.

ok bluhm, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.134 2014/12/07 13:59:55 tobias Exp $	*/
d352 1
a352 1
	if ((fd = nullfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
d356 1
a356 1
	while (fd++ <= 2) {
@


1.134
log
@Fix regression for priority "none" (spotted by doug) of last commit by not
parsing numbers at all -- syslog.conf(5) explicitly states that keywords
have to be used.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.133 2014/12/06 12:18:32 tobias Exp $	*/
d124 2
a125 2
	short	f_type;			/* entry type, see below */
	short	f_file;			/* file descriptor */
@


1.133
log
@Verify that facility and priority numbers are in valid ranges.

ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.132 2014/12/03 17:00:15 millert Exp $	*/
d1501 1
a1501 1
			if (pri < 0 || pri > LOG_PRIMASK) {
d1520 1
a1520 1
				if (i < 0 || (i >> 3) > LOG_NFACILITIES) {
a1765 3

	if (isdigit((unsigned char)*name))
		return (atoi(name));
@


1.132
log
@Fix off by one in check for socket path too long.  From Nicolas Bedos.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.131 2014/11/26 18:34:52 millert Exp $	*/
d1501 1
a1501 1
			if (pri < 0) {
d1520 1
a1520 1
				if (i < 0) {
@


1.131
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.130 2014/11/01 12:07:41 bluhm Exp $	*/
d1818 1
a1818 1
	if (strlcpy(s_un.sun_path, path, sizeof(s_un.sun_path)) >
@


1.130
log
@Replace the combination of strlen(), calloc(), strlen(), strlcpy()
with a simple strdup().
Found by brad@@ with LLVM;  OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.129 2014/10/06 19:36:34 bluhm Exp $	*/
d350 1
a350 1
		setlinebuf(stdout);
@


1.129
log
@As libevent provides safe signal callbacks instead of signal handlers,
the sigprocmask(2) protection is not necessary and can be removed.
OK nicm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.128 2014/10/05 18:14:01 bluhm Exp $	*/
d1472 2
a1473 5
	else {
		f->f_program = calloc(1, strlen(prog)+1);
		if (f->f_program)
			strlcpy(f->f_program, prog, strlen(prog)+1);
	}
@


1.128
log
@Switch syslogd from using poll(2) to libevent.
test and OK nicm@@; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.127 2014/10/03 21:55:22 bluhm Exp $	*/
a761 1
	sigset_t mask, omask;
a767 5
	sigemptyset(&mask);
	sigaddset(&mask, SIGALRM);
	sigaddset(&mask, SIGHUP);
	sigprocmask(SIG_BLOCK, &mask, &omask);

a814 1
		(void)sigprocmask(SIG_SETMASK, &omask, NULL);
a878 1
	(void)sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.127
log
@Cleanup the reporting socket code in syslogd.
- Name variable path_ctlsock consistently.
- Name function ctlconn_logto() consistently.
- Replace the nested if/else logic in ctlconn_write_handler()
  with if/return.
- Call ctlconn_cleanup() only if there is a control connection.
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.126 2014/10/01 15:47:33 guenther Exp $	*/
d53 1
d85 1
d253 17
a269 9
void	 klog_read_handler(int);
void	 udp_read_handler(int);
void	 unix_read_handler(int);

struct pollfd pfd[N_PFD];

volatile sig_atomic_t MarkSet;
volatile sig_atomic_t WantDie;
volatile sig_atomic_t DoInit;
a273 2
void	dodie(int);
void	doinit(int);
a274 1
void	domark(int);
a289 3
void	ctlsock_accept_handler(void);
void	ctlconn_read_handler(void);
void	ctlconn_write_handler(void);
a290 1
void	ctlconn_logto(char *);
d295 5
a299 5
	int ch, i, fd;
	char *p;
	int lockpipe[2] = { -1, -1}, pair[2], nullfd;
	struct addrinfo hints, *res, *res0;
	FILE *fp;
a380 6
	/* Clear poll array, set all fds to ignore */
	for (i = 0; i < N_PFD; i++) {
		pfd[i].fd = -1;
		pfd[i].events = 0;
	}

d394 1
d396 1
a396 1
		struct pollfd *pfdp;
d402 1
a402 1
			pfdp = &pfd[PFD_INET];
d407 1
a407 1
			pfdp = &pfd[PFD_INET6];
d413 1
a413 1
		if (pfdp->fd >= 0)
d416 3
a418 2
		fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (fd < 0)
d421 1
a421 1
		if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {
d423 2
a424 1
			close(fd);
a426 1
			fd = -1;
a429 1
		pfdp->fd = fd;
d431 3
a433 5
			shutdown(pfdp->fd, SHUT_RD);
		else {
			double_rbuf(pfdp->fd);
			pfdp->events = POLLIN;
		}
d442 2
a443 1
		if ((fd = unix_socket(path_unix[i], SOCK_DGRAM, 0666)) == -1) {
d448 1
a448 3
		double_rbuf(fd);
		pfd[PFD_UNIX_0 + i].fd = fd;
		pfd[PFD_UNIX_0 + i].events = POLLIN;
d453 2
a454 4
	fd = pair[0];
	double_rbuf(fd);
	pfd[PFD_SENDSYS].fd = fd;
	pfd[PFD_SENDSYS].events = POLLIN;
d456 1
d458 7
a464 3
		fd = unix_socket(path_ctlsock, SOCK_STREAM, 0600);
		if (fd != -1) {
			if (listen(fd, 16) == -1) {
d468 1
a468 4
			pfd[PFD_CTLSOCK].fd = fd;
			pfd[PFD_CTLSOCK].events = POLLIN;
		} else if (!Debug)
			die(0);
d471 2
a472 1
	if ((fd = open(_PATH_KLOG, O_RDONLY, 0)) == -1) {
d475 2
a476 2
		pfd[PFD_KLOG].fd = fd;
		pfd[PFD_KLOG].events = POLLIN;
a477 3

	if (ioctl(fd, LIOCSFD, &pair[1]) == -1)
		dprintf("LIOCSFD errno %d\n", errno);
d507 2
d521 24
d550 1
a550 1
	if (pfd[PFD_CTLSOCK].fd != -1 &&
d572 25
a596 4
	(void)signal(SIGHUP, doinit);
	(void)signal(SIGTERM, dodie);
	(void)signal(SIGINT, Debug ? dodie : SIG_IGN);
	(void)signal(SIGQUIT, Debug ? dodie : SIG_IGN);
a597 1
	(void)signal(SIGALRM, domark);
d599 4
a602 1
	(void)alarm(TIMERINTVL);
d607 1
a607 48
	for (;;) {
		if (MarkSet)
			markit();
		if (WantDie)
			die(WantDie);

		if (DoInit) {
			init();
			DoInit = 0;

			logmsg(LOG_SYSLOG|LOG_INFO, "syslogd: restart",
			    LocalHostName, ADDDATE);
			dprintf("syslogd: restarted\n");
		}

		switch (poll(pfd, PFD_UNIX_0 + nunix, -1)) {
		case 0:
			continue;
		case -1:
			if (errno != EINTR)
				logerror("poll");
			continue;
		}

		if ((pfd[PFD_KLOG].revents & POLLIN) != 0) {
			klog_read_handler(pfd[PFD_KLOG].fd);
		}
		if ((pfd[PFD_INET].revents & POLLIN) != 0) {
			udp_read_handler(pfd[PFD_INET].fd);
		}
		if ((pfd[PFD_INET6].revents & POLLIN) != 0) {
			udp_read_handler(pfd[PFD_INET6].fd);
		}
		if ((pfd[PFD_CTLSOCK].revents & POLLIN) != 0)
			ctlsock_accept_handler();
		if ((pfd[PFD_CTLCONN].revents & POLLIN) != 0)
			ctlconn_read_handler();
		if ((pfd[PFD_CTLCONN].revents & POLLOUT) != 0)
			ctlconn_write_handler();

		for (i = 0; i < nunix; i++) {
			if ((pfd[PFD_UNIX_0 + i].revents & POLLIN) != 0) {
				unix_read_handler(pfd[PFD_UNIX_0 + i].fd);
			}
		}
		if ((pfd[PFD_SENDSYS].revents & POLLIN) != 0)
			unix_read_handler(pfd[PFD_SENDSYS].fd);
	}
d613 1
a613 1
klog_read_handler(int fd)
d615 2
a616 1
	ssize_t	 n;
d624 1
a624 2
		pfd[PFD_KLOG].fd = -1;
		pfd[PFD_KLOG].events = 0;
d629 1
a629 1
udp_read_handler(int fd)
d649 1
a649 1
unix_read_handler(int fd)
d953 1
a953 1
			fd = pfd[PFD_INET].fd;
d956 1
a956 1
			fd = pfd[PFD_INET6].fd;
d1158 1
a1158 1
dodie(int signo)
d1160 1
a1160 1
	WantDie = signo;
a1162 1
/* ARGSUSED */
d1164 1
a1164 1
domark(int signo)
d1166 1
a1166 1
	MarkSet = 1;
a1168 1
/* ARGSUSED */
d1170 1
a1170 1
doinit(int signo)
d1172 5
a1176 1
	DoInit = 1;
a1207 1
	alarm(0);
d1571 1
a1571 1
			if (pfd[PFD_INET].fd == -1)
d1573 1
a1573 1
			if (pfd[PFD_INET6].fd == -1)
d1576 1
a1576 1
			if (pfd[PFD_INET].fd == -1) {
d1583 1
a1583 1
			if (pfd[PFD_INET6].fd == -1) {
a1816 2
	MarkSet = 0;
	(void)alarm(TIMERINTVL);
d1888 1
a1888 1
static void
d1893 1
a1893 1
	if (close(pfd[PFD_CTLCONN].fd) == -1)
d1895 4
a1898 5

	pfd[PFD_CTLCONN].fd = -1;
	pfd[PFD_CTLCONN].events = pfd[PFD_CTLCONN].revents = 0;

	pfd[PFD_CTLSOCK].events = POLLIN;
d1909 1
a1909 1
ctlsock_accept_handler(void)
d1911 2
a1912 1
	int fd, flags;
d1915 1
a1915 1
	fd = accept(pfd[PFD_CTLSOCK].fd, NULL, NULL);
d1923 1
a1923 1
	if (pfd[PFD_CTLCONN].fd != -1)
d1927 1
a1927 1
	pfd[PFD_CTLSOCK].events = pfd[PFD_CTLSOCK].revents = 0;
d1936 7
a1942 2
	pfd[PFD_CTLCONN].fd = fd;
	pfd[PFD_CTLCONN].events = POLLIN;
d1961 1
a1961 1
ctlconn_read_handler(void)
d1963 4
a1966 4
	ssize_t n;
	struct filed *f;
	u_int32_t flags = 0;
	struct ctl_reply_hdr *reply_hdr = (struct ctl_reply_hdr *)ctl_reply;
d1976 1
a1976 1
	n = read(pfd[PFD_CTLCONN].fd, (char*)&ctl_cmd + ctl_cmd_bytes,
d2083 1
a2083 4
	pfd[PFD_CTLCONN].events = POLLOUT;

	/* monitor terminating syslogc */
	pfd[PFD_CTLCONN].events |= POLLIN;
d2087 1
a2087 1
		pfd[PFD_CTLSOCK].events = POLLIN;
d2091 1
a2091 1
ctlconn_write_handler(void)
d2093 2
a2094 1
	ssize_t n;
d2105 1
a2105 1
	n = write(pfd[PFD_CTLCONN].fd, ctl_reply + ctl_reply_offset,
d2142 1
a2142 1
		pfd[PFD_CTLCONN].events = POLLIN;
d2185 1
a2185 1
	pfd[PFD_CTLCONN].events |= POLLOUT;
@


1.126
log
@Map out-of-range facility values to LOG_USER to avoid array over-read.
Prompted by similar rsyslog issue fixed by Rainer Gerhards (rgerhards
(at) adiscon.com)

ok deraadt@@ blambert@@ sthen@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.125 2014/09/27 11:28:37 bluhm Exp $	*/
d202 1
a202 1
char	*ctlsock_path = NULL;	/* Path to control socket */
d287 1
a287 1
void	logto_ctlconn(char *);
d338 1
a338 1
			ctlsock_path = optarg;
d463 2
a464 2
	if (ctlsock_path != NULL) {
		fd = unix_socket(ctlsock_path, SOCK_STREAM, 0600);
d1081 1
a1081 1
			logto_ctlconn(line);
d1899 2
a1900 2
	if (pfd[PFD_CTLCONN].fd != -1)
		close(pfd[PFD_CTLCONN].fd);
d1929 2
a1930 1
	ctlconn_cleanup();
a1990 1

a2091 1

d2106 1
d2123 23
a2145 20
	if (ctl_reply_offset >= ctl_reply_size) {
		/*
		 * Make space in the buffer for continous writes.
		 * Set offset behind reply header to skip it
		 */
		if (ctl_state == CTL_WRITING_CONT_REPLY) {
			*reply_text = '\0';
			ctl_reply_offset = ctl_reply_size = CTL_REPLY_SIZE;

			/* Now is a good time to report dropped lines */
			if (membuf_drop) {
				strlcat(reply_text, "<ENOBUFS>\n", MAX_MEMBUF);
				ctl_reply_size = CTL_REPLY_SIZE;
				membuf_drop = 0;
			} else {
				/* Nothing left to write */
				pfd[PFD_CTLCONN].events = POLLIN;
			}
		} else
			ctlconn_cleanup();
d2172 1
a2172 1
logto_ctlconn(char *line)
@


1.125
log
@Also in debug mode, close nullfd when it is not needed anymore.
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.124 2014/09/10 13:16:20 doug Exp $	*/
d799 1
a799 1
	else
d801 3
@


1.124
log
@Remove redundant null check and rename vars consistently in syslogd

Merge in more functionality from bluhm's patch.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.123 2014/09/08 00:43:42 doug Exp $	*/
a541 2
		if (nullfd > 2)
			close(nullfd);
d544 2
@


1.123
log
@Fix a syslogd regression when specifying all 20 additional log paths

bluhm@@ found and fixed this bug.  This is a modified version of his
patch which makes the intention a little clearer.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.122 2014/09/04 15:19:05 bluhm Exp $	*/
d186 2
a187 2
int	nfunix = 1;		/* Number of Unix domain sockets requested */
char	*funixn[MAXFUNIX] = { _PATH_LOG }; /* Paths to Unix domain sockets */
d324 1
a324 1
			funixn[0] = optarg;
d330 1
a330 1
			if (nfunix >= MAXFUNIX)
d335 1
a335 1
				funixn[nfunix++] = optarg;
d445 2
a446 2
	for (i = 0; i < nfunix; i++) {
		if ((fd = unix_socket(funixn[i], SOCK_DGRAM, 0666)) == -1) {
d580 1
a580 1
		switch (poll(pfd, PFD_UNIX_0 + nfunix, -1)) {
d605 1
a605 1
		for (i = 0; i < nfunix; i++) {
@


1.122
log
@Move the handlers for the poll events into separate functions.  They
will become the libevent callbacks later.
input and OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.121 2014/08/31 22:11:43 bluhm Exp $	*/
a455 1
	nfunix++;
d460 2
a461 2
	pfd[PFD_UNIX_0 + i].fd = fd;
	pfd[PFD_UNIX_0 + i].events = POLLIN;
d610 2
@


1.121
log
@The reapchild() signal handler collects all children.  This can be
done easier by ignoring SIGCHLD.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.120 2014/08/31 20:51:31 bluhm Exp $	*/
d248 7
d292 2
a293 6
	int ch, i, linesize, fd;
	struct sockaddr_un fromunix;
	struct sockaddr_storage from;
	socklen_t len;
	char *p, *line;
	char resolve[MAXHOSTNAMELEN];
d373 1
a373 1
	if ((line = malloc(linesize)) == NULL) {
d591 1
a591 9
			i = read(pfd[PFD_KLOG].fd, line, linesize - 1);
			if (i > 0) {
				line[i] = '\0';
				printsys(line);
			} else if (i < 0 && errno != EINTR) {
				logerror("klog");
				pfd[PFD_KLOG].fd = -1;
				pfd[PFD_KLOG].events = 0;
			}
d594 1
a594 11
			len = sizeof(from);
			i = recvfrom(pfd[PFD_INET].fd, line, MAXLINE, 0,
			    (struct sockaddr *)&from, &len);
			if (i > 0) {
				line[i] = '\0';
				cvthname((struct sockaddr *)&from, resolve,
				    sizeof(resolve));
				dprintf("cvthname res: %s\n", resolve);
				printline(resolve, line);
			} else if (i < 0 && errno != EINTR)
				logerror("recvfrom inet");
d597 1
a597 11
			len = sizeof(from);
			i = recvfrom(pfd[PFD_INET6].fd, line, MAXLINE, 0,
			    (struct sockaddr *)&from, &len);
			if (i > 0) {
				line[i] = '\0';
				cvthname((struct sockaddr *)&from, resolve,
				    sizeof(resolve));
				dprintf("cvthname res: %s\n", resolve);
				printline(resolve, line);
			} else if (i < 0 && errno != EINTR)
				logerror("recvfrom inet6");
d608 1
a608 11
				ssize_t rlen;

				len = sizeof(fromunix);
				rlen = recvfrom(pfd[PFD_UNIX_0 + i].fd, line,
				    MAXLINE, 0, (struct sockaddr *)&fromunix,
				    &len);
				if (rlen > 0) {
					line[rlen] = '\0';
					printline(LocalHostName, line);
				} else if (rlen == -1 && errno != EINTR)
					logerror("recvfrom unix");
d614 52
@


1.120
log
@Do not call free() on an array in the data section.  Fortunately
the code was not reached.  No binary change.
OK miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.119 2014/08/25 18:19:18 bluhm Exp $	*/
a268 1
void	reapchild(int);
d555 1
a555 1
	(void)signal(SIGCHLD, reapchild);
a1118 12
}

/* ARGSUSED */
void
reapchild(int signo)
{
	int save_errno = errno;
	int status;

	while (waitpid(-1, &status, WNOHANG) > 0)
		;
	errno = save_errno;
@


1.119
log
@Allow to restrict syslogd to a protocol family with -4 and -6 command
line switches.  If the log server is an FQDN, DNS chooses wether
to take the IPv4 or IPv6 route.  Allow to prefix the log host with
udp4:// or udp6:// to choose a protocol.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.118 2014/08/25 18:05:30 bluhm Exp $	*/
a648 1
	free(pfd);
@


1.118
log
@Fix the gcc compiler warnings "comparison between signed and
unsigned".  Some checks got stricter.  The (size_t) cast is only
done, if the argument is not negative.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.117 2014/08/22 16:14:11 bluhm Exp $	*/
d130 2
a131 2
			char	f_loghost[1+1+MAXHOSTNAMELEN+1+NI_MAXSERV];
				/* @@[hostname]:servname\0 */
d198 2
d273 1
a273 1
int	loghost(char *, char **, char **);
d296 1
a296 1
	while ((ch = getopt(argc, argv, "dhnuf:m:p:a:s:")) != -1)
d298 8
d400 2
d405 2
d658 1
a658 1
	    "usage: syslogd [-dhnu] [-a path] [-f config_file] [-m mark_interval]\n"
d1454 1
a1454 1
	char *bp, *p, *q, *host, *port;
d1559 1
a1559 1
		if (loghost(++p, &host, &port) == -1) {
d1565 27
d1606 1
a1606 1
		if (priv_getaddrinfo(host, port,
d1723 1
a1723 1
loghost(char *str, char **host, char **port)
d1725 7
@


1.117
log
@Instead of getting a nasty error message from privsep
"syslogd: priv_getaddrinfo: overflow attempt in hostname"
check the host and port length when parsing the config.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.116 2014/08/21 17:00:34 bluhm Exp $	*/
d871 1
a871 1
		if ((l = snprintf(greetings, sizeof(greetings),
d873 2
a874 2
		    f->f_prevhost, ctime(&now))) >= sizeof(greetings) ||
		    l == -1)
d901 3
a903 3
		if ((l = snprintf(repbuf, sizeof(repbuf),
		    "last message repeated %d times", f->f_prevcount)) >=
		    sizeof(repbuf) || l == -1)
d934 1
a934 1
		if ((l = snprintf(line, sizeof(line), "<%d>%.15s %s%s%s",
d938 2
a939 1
		    (char *)iov[4].iov_base)) >= sizeof(line) || l == -1)
d1636 1
a1636 1
		for(i = 0; i < sizeof(f->f_un.f_mb.f_mname) - 1; i++) {
@


1.116
log
@Send and receive UDP syslog packets on the IPv6 socket.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.115 2014/08/21 00:04:58 bluhm Exp $	*/
d1550 15
a1564 2
		if (priv_getaddrinfo(host,
		    port == NULL ? "syslog" : port,
@


1.115
log
@Parse loghost in a separate function.  Allow [] around hostname,
needed for IPv6 addresses.  Print full loghost specifier in case
of error or debug.  Make string sizes more precise.
input henning@@; input and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.114 2014/08/20 20:10:17 bluhm Exp $	*/
a191 1
int	InetInuse = 0;		/* non-zero if INET sockets are being used */
d286 1
a286 1
	struct sockaddr_in frominet;
d373 1
a373 1
	hints.ai_family = AF_INET;
d388 2
a389 1
		if (res->ai_family == AF_INET)
d391 5
a395 5
		else {
			/*
			 * XXX AF_INET6 is skipped on purpose, need to
			 * fix '@@' handling first.
			 */
a414 1
		InetInuse = 1;
d586 1
a586 1
			len = sizeof(frominet);
d588 1
a588 1
			    (struct sockaddr *)&frominet, &len);
d591 2
a592 2
				cvthname((struct sockaddr *)&frominet, resolve,
				    sizeof resolve);
d598 13
d866 1
a866 1
	int l, retryonce;
d923 11
d940 1
a940 1
		if (sendto(pfd[PFD_INET].fd, line, l, 0,
a1535 2
		if (!InetInuse)
			break;
@


1.114
log
@Replace gethostbyaddr(3) with getnameinfo(3).  Remove the sigprocmask()
that was necessary for gethostbyaddr() because the latter is not
signal safe.  Change the return code semantics of priv_getnameinfo()
to match getnameinfo(3).
input and OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.113 2014/08/20 19:16:27 bluhm Exp $	*/
d130 2
a131 1
			char	f_hname[MAXHOSTNAMELEN];
d272 1
d910 1
a910 1
		dprintf(" %s\n", f->f_un.f_forw.f_hname);
d1354 1
a1354 1
				printf("%s", f->f_un.f_forw.f_hname);
d1416 1
a1416 1
	char *bp, *p, *q, *cp;
d1515 4
a1518 6
		if ((cp = strrchr(++p, ':')) != NULL)
			*cp++ = '\0';
		if ((strlcpy(f->f_un.f_forw.f_hname, p,
		    sizeof(f->f_un.f_forw.f_hname)) >=
		    sizeof(f->f_un.f_forw.f_hname))) {
			snprintf(ebuf, sizeof(ebuf), "hostname too long \"%s\"",
d1523 9
a1531 3
		if (priv_getaddrinfo(f->f_un.f_forw.f_hname,
		    cp == NULL ? "syslog" : cp,
		    (struct sockaddr *)&f->f_un.f_forw.f_addr,
d1533 2
a1534 1
			snprintf(ebuf, sizeof(ebuf), "bad hostname \"%s\"", p);
d1643 20
@


1.113
log
@Rename priv_gethostserv() to priv_getaddrinfo() as this is what the
function does.  Change the return code semantics to match getaddrinfo(3).
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.112 2014/08/19 00:24:00 bluhm Exp $	*/
d253 1
a253 1
void    cvthname(struct sockaddr_in *, char *, size_t);
d590 1
a590 1
				cvthname(&frominet, resolve,
d1099 1
a1099 1
cvthname(struct sockaddr_in *f, char *result, size_t res_len)
d1101 2
a1102 5
	sigset_t omask, nmask;
	char *p, *ip;
	int ret_len;

	if (f->sin_family != AF_INET) {
d1107 2
a1108 5

	ip = inet_ntoa(f->sin_addr);
	dprintf("cvthname(%s)\n", ip);
	if (NoDNS) {
		strlcpy(result, ip, res_len);
a1109 1
	}
d1111 2
a1112 13
	sigemptyset(&nmask);
	sigaddset(&nmask, SIGHUP);
	sigprocmask(SIG_BLOCK, &nmask, &omask);

	ret_len = priv_gethostbyaddr((char *)&f->sin_addr,
		sizeof(struct in_addr), f->sin_family, result, res_len);

	sigprocmask(SIG_SETMASK, &omask, NULL);
	if (ret_len == 0) {
		dprintf("Host name for your address (%s) unknown\n", ip);
		strlcpy(result, ip, res_len);
	} else if ((p = strchr(result, '.')) && strcmp(p + 1, LocalDomain) == 0)
		*p = '\0';
@


1.112
log
@Fix trailing white spaces.
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.111 2014/07/14 04:02:33 deraadt Exp $	*/
d1430 1
a1430 1
	int i, pri, addr_len;
d1541 1
a1541 1
		addr_len = priv_gethostserv(f->f_un.f_forw.f_hname,
d1543 2
a1544 3
		    (struct sockaddr*)&f->f_un.f_forw.f_addr,
		    sizeof(f->f_un.f_forw.f_addr));
		if (addr_len < 1) {
@


1.111
log
@Create a socketpair() and tie one end to /dev/klog using ioctl LIOCSFD.
This allows us to receive messages direct from programs using the
fd-safe sendsyslog(2), aka. syslog_r(3).  Thanks to guenther for this part
of the solution.
ok beck tedu miod guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.110 2014/02/04 23:28:05 bluhm Exp $	*/
d1017 1
a1017 1
		    (char *)iov[0].iov_base, (char *)iov[2].iov_base, 
d1541 3
a1543 3
		addr_len = priv_gethostserv(f->f_un.f_forw.f_hname, 
		    cp == NULL ? "syslog" : cp, 
		    (struct sockaddr*)&f->f_un.f_forw.f_addr, 
@


1.110
log
@Remote logging could get stuck after a "network is unreachable"
error occured.  Put ENETUNREACH into the list of ignored errors.
OK markus@@ sthen@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.109 2013/11/24 01:06:18 deraadt Exp $	*/
d289 1
a289 1
	int lockpipe[2] = { -1, -1}, nullfd;
d439 8
d466 4
@


1.109
log
@more unsigned char casts for ctype
ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.108 2013/10/09 16:33:05 millert Exp $	*/
d910 1
@


1.108
log
@Trim leading white space from the message before trying to extract
the program name.  Works around a problem with the ObiHai 202's
syslog client (and possibly others) where an extra space is added
to the message before the program name.  OK krw@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.107 2013/04/16 19:24:55 deraadt Exp $	*/
d638 1
a638 1
		while (isdigit(*++p))
d681 1
a681 1
			while (isdigit(*++p))
d748 1
a748 1
	while (isspace(*msg))
d751 1
a751 1
		if (!isalnum(msg[i]) && msg[i] != '-')
d1259 1
a1259 1
		for (p = cline; isspace(*p); ++p)
d1265 1
a1265 1
			while (isspace(*p))
d1267 2
a1268 1
			if (!*p || (*p == '*' && (!p[1] || isspace(p[1])))) {
d1273 2
a1274 1
				if (!isalnum(p[i]) && p[i] != '-' && p[i] != '!')
d1283 1
a1283 1
			if (!isspace(*--p)) {
d1601 1
a1601 1
			if (!isalnum(q[i]))
d1671 1
a1671 1
	if (isdigit(*name))
d1675 2
a1676 2
		if (isupper(*name))
			*p = tolower(*name);
@


1.107
log
@remove casts to time_t * which are not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.106 2013/03/11 17:40:11 deraadt Exp $	*/
d748 3
a750 1
	for(i = 0; i < NAME_MAX; i++) {
@


1.106
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.105 2013/02/10 10:47:08 markus Exp $	*/
d1689 1
a1689 1
	now = time((time_t *)NULL);
@


1.105
log
@-h includes RFC 3164 style hostnames when forwarding;
feedback and ok sthen@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.104 2011/07/12 11:28:31 sthen Exp $	*/
d1808 2
a1809 1
		if (errno != EINTR && errno != ECONNABORTED)
@


1.104
log
@Allow syslogc -n XX to display less than the whole file, and -n XX -f to
display more/less than the default of 10.  ok mpf@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.103 2009/10/27 23:59:54 deraadt Exp $	*/
d198 1
d293 1
a293 1
	while ((ch = getopt(argc, argv, "dnuf:m:p:a:s:")) != -1)
d301 3
d618 1
a618 1
	    "usage: syslogd [-dnu] [-a path] [-f config_file] [-m mark_interval]\n"
d895 1
a895 1
		if ((l = snprintf(line, sizeof(line), "<%d>%.15s %s",
d897 2
@


1.103
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.102 2008/09/29 18:42:54 deraadt Exp $	*/
d210 1
a210 1
#define CTL_VERSION		1
d222 1
d1914 4
a1917 1
				tailify_replytext(reply_text, 10);
@


1.102
log
@initialize both sides of the lockpipe (only used in debug mode) to -1 to
have averted the bug found in pr 5938
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.101 2008/04/21 22:09:51 mpf Exp $	*/
a30 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1988, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)syslogd.c	8.3 (Berkeley) 4/4/94";
#else
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.101 2008/04/21 22:09:51 mpf Exp $";
#endif
#endif /* not lint */
@


1.101
log
@If a |program is too slow to process the input,
drop messages rather than to kill and restart it.
Also log this error, but limited at a 2 minute rate.
Discussed with henning.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.100 2007/10/17 20:10:44 chl Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.100 2007/10/17 20:10:44 chl Exp $";
d301 1
a301 1
	int lockpipe[2], nullfd;
@


1.100
log
@remove "unused variable" warnings

tested by deraadt@@ on a gcc2 arch

looks ok ray@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.99 2007/09/07 20:55:26 bluhm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.99 2007/09/07 20:55:26 bluhm Exp $";
d164 1
d948 10
d960 2
a961 1
			 * Check for errors on TTY's due to loss of tty
@


1.99
log
@Initialize length variable slen properly to avoid possible EINVAL
errors from setsockopt(2) in function double_rbuf().
ok markus@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.98 2007/05/02 15:17:11 jason Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.98 2007/05/02 15:17:11 jason Exp $";
a204 1
int	LogPort;		/* port number for INET connections */
d296 1
a296 1
	struct sockaddr_in s_in, frominet;
@


1.98
log
@- use getaddrinfo() instead of gethostbyname/getservbyname
- reserve a poll descriptor entry for INET6 (not used yet)
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.97 2007/03/30 18:25:44 canacar Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.97 2007/03/30 18:25:44 canacar Exp $";
d1768 1
@


1.97
log
@Preserve the contents of the memory buffers when syslogd reinitializes
logs in response to a HUP signal, as long as /etc/syslog.conf remains
unchanged. ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.96 2007/02/21 18:10:31 mpf Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.96 2007/02/21 18:10:31 mpf Exp $";
d302 1
d380 15
a394 2
	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) != -1) {
		struct servent *sp;
d396 8
a403 6
		/* XXX use getaddrinfo */
		sp = getservbyname("syslog", "udp");
		if (sp == NULL) {
			errno = 0;
			logerror("syslog/udp: unknown service");
			die(0);
d405 9
a413 5
		memset(&s_in, 0, sizeof(s_in));
		s_in.sin_len = sizeof(s_in);
		s_in.sin_family = AF_INET;
		s_in.sin_port = LogPort = sp->s_port;
		if (bind(fd, (struct sockaddr *)&s_in, sizeof(s_in)) < 0) {
d415 1
d418 11
a428 9
		} else {
			InetInuse = 1;
			pfd[PFD_INET].fd = fd;
			if (SecureMode) {
				shutdown(fd, SHUT_RD);
			} else {
				double_rbuf(fd);
				pfd[PFD_INET].events = POLLIN;
			}
d431 2
@


1.96
log
@Create "syslogd: restart" message after the setup of signal
handlers. This prevents a race where syslogd could die
on SIGPIPE at startup. Also distinguish between start and restart.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.95 2007/02/20 11:24:32 henning Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.95 2007/02/20 11:24:32 henning Exp $";
d153 1
d1162 1
a1162 1
	struct filed *f, *next, **nextp;
d1178 1
a1192 3
		case F_MEMBUF:
			ringbuf_free(f->f_un.f_mb.f_rb);
			break;
d1197 7
a1203 1
		free((char *)f);
d1262 40
d1583 1
a1583 1
		/* Allocate buffer */
d1585 1
a1585 5
		if ((f->f_un.f_mb.f_rb = ringbuf_init(rb_len)) == NULL) {
			f->f_type = F_UNUSED;
			logerror(p);
			break;
		}
@


1.95
log
@implement logging to other program's stdin.
if the target is like "| /path/to/program", syslogd forks and execs program
and sends the selected log messages to program's stdin.
uses a socketpair, grows the receive buffer on the reader side and has the
socket nonblocking on syslog'd side to prevent syslogd blocking.
I'm using that here to feed logsurfer from ports for automated log analysis,
werks beautifully.
lots of input & help mpf, ok mpf djm "no objections" millert
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.94 2007/01/03 13:25:20 mpf Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.94 2007/01/03 13:25:20 mpf Exp $";
d517 3
d529 4
a1296 4

	logmsg(LOG_SYSLOG|LOG_INFO, "syslogd: restart", LocalHostName,
	    ADDDATE);
	dprintf("syslogd: restarted\n");
@


1.94
log
@Support for continuous reading of syslog memory buffers.
Works like ``tail -f'' on a log file.
OK markus@@, djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.93 2006/09/17 18:28:34 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.93 2006/09/17 18:28:34 djm Exp $";
d186 1
d188 1
a188 1
char	*TypeNames[8] = {
d190 2
a191 1
	"FORW",		"USERS",	"WALL",		"MEMBUF"
d902 1
d904 1
a904 1
		if (f->f_type != F_FILE) {
d926 2
a927 1
			    f->f_type != F_FILE && !retryonce) {
d935 9
d1179 1
d1267 1
d1300 1
a1300 1
 * Spot a line with a duplicate file, console, tty, or membuf target.
d1314 1
d1460 1
d1485 10
a1494 5
			f->f_type = F_FILE;
			/* Clear O_NONBLOCK flag on f->f_file */
			if ((i = fcntl(f->f_file, F_GETFL, 0)) != -1) {
				i &= ~O_NONBLOCK;
				fcntl(f->f_file, F_SETFL, i);
@


1.93
log
@check that stdio file descriptors are actually closed before clobbering
them, following an identical change in openssh
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.92 2005/06/10 01:41:43 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.92 2005/06/10 01:41:43 millert Exp $";
d152 1
d214 1
d216 1
d221 1
a221 1
#define CTL_VERSION		0
d231 1
d248 1
d251 1
d286 2
d489 1
d956 2
d1521 1
d1686 2
d1696 5
a1753 1
	size_t reply_text_size;
a1754 1
	char *reply_text = ctl_reply + CTL_HDR_LEN;
d1756 3
a1758 3
	if (ctl_state != CTL_READING_CMD) {
		/* Shouldn't be here! */
		logerror("ctlconn_read with bad ctl_state");
d1797 1
a1797 1
	ctl_reply_size = reply_text_size = ctl_reply_offset = 0;
d1806 1
d1822 4
a1826 1
		reply_text_size = strlen(reply_text);
a1838 1
		reply_text_size = strlen(reply_text);
a1852 1
		reply_text_size = strlen(reply_text);
d1862 1
a1862 1
	ctl_reply_size = reply_text_size + CTL_HDR_LEN;
d1866 3
a1868 1
	ctl_state = CTL_WRITING_REPLY;
d1870 8
a1877 1
	pfd[PFD_CTLCONN].revents = 0;
d1885 2
a1886 1
	if (ctl_state != CTL_WRITING_REPLY) {
d1908 52
d1961 10
a1970 2
	if (ctl_reply_offset >= ctl_reply_size)
		ctlconn_cleanup();
@


1.92
log
@If any of fds 0-2 are not open, dup them to our /dev/null fd.
Prevents the socket from being closed in this case.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.91 2005/06/06 23:22:04 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.91 2005/06/06 23:22:04 djm Exp $";
d333 1
a333 1
	if ((nullfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
d337 4
a340 3
	while (nullfd < 2) {
		dup2(nullfd, nullfd + 1);
		nullfd++;
@


1.91
log
@memory leak on SIGHUP for memory buffer logs, based on fix by Stephen Marley;
ok avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.90 2005/04/21 16:15:50 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.90 2005/04/21 16:15:50 djm Exp $";
d290 1
a290 1
	int lockpipe[2], nullfd = -1;
d333 9
a446 1
			nullfd = open(_PATH_DEVNULL, O_RDWR);
@


1.90
log
@avoid looping on failed tty or /dev/console writes and just drop the message
noticed by newell AT cei.net; ok avsm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.89 2005/03/12 08:05:58 markus Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.89 2005/03/12 08:05:58 markus Exp $";
d1149 3
@


1.89
log
@shutdown the inetd socket for reading if secure; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.88 2004/12/22 17:42:00 danh Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.88 2004/12/22 17:42:00 danh Exp $";
d794 1
a794 1
	int l;
d890 1
d905 1
a905 1
			    f->f_type != F_FILE) {
d907 1
@


1.88
log
@avoid a null dereference when using membufs.

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.87 2004/12/21 23:09:32 danh Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.87 2004/12/21 23:09:32 danh Exp $";
a377 1
			double_rbuf(fd);
d379 6
a384 1
			pfd[PFD_INET].events = POLLIN;
d532 8
a539 12
			if (SecureMode) {
				/* silently drop it */
			} else {
				if (i > 0) {
					line[i] = '\0';
					cvthname(&frominet, resolve,
					    sizeof resolve);
					dprintf("cvthname res: %s\n", resolve);
					printline(resolve, line);
				} else if (i < 0 && errno != EINTR)
					logerror("recvfrom inet");
			}
@


1.87
log
@silently ignore some cases when sendto(2) fails rather than disabling
logging to a remote host.

Similar patch sent by Marc Huber <Marc.Huber@@web.de> in PR4044.

ok deraadt@@ henning@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.86 2004/12/20 20:59:19 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.86 2004/12/20 20:59:19 otto Exp $";
d1260 1
a1260 1
 * Spot a line with a duplicate file, console or tty target.
d1278 6
d1479 1
a1479 6
		for (xf = Files; i != 0 && xf != f; xf = xf->f_next) {
			if (xf->f_type == F_MEMBUF &&
			    strcmp(xf->f_un.f_mb.f_mname,
			    f->f_un.f_mb.f_mname) == 0)
				break;
		}
d1482 1
a1482 1
		if (i == 0 || rb_len > MAX_MEMBUF || xf != f) {
@


1.86
log
@Fix one case of broken duplicate supression, which happens if two lines
in syslog.conf contain the same target file, and log entries
matching both the first and second line get written.

This changes behaviour: e.g. previously repeating a line caused a log
entry to be written twice, but not any more. Also, if a later line with
the same target has a different priority for a facility, the last one will
be used.

Noted by camield@@; help from millert@@.

ok camield@@ millert@@ hshoexer@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.85 2004/11/11 20:14:53 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.85 2004/11/11 20:14:53 otto Exp $";
d858 12
a869 2
			f->f_type = F_UNUSED;
			logerror("sendto");
@


1.85
log
@strchr("whatever", 0) returns non NULL. From Patrick Latifi.
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.84 2004/09/14 23:37:06 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.84 2004/09/14 23:37:06 deraadt Exp $";
d255 1
a255 1
void	cfline(char *, struct filed *, char *);
d267 1
d1150 2
a1151 4
		*nextp = (struct filed *)calloc(1, sizeof(*f));
		cfline("*.ERR\t/dev/console", *nextp, "*");
		(*nextp)->f_next = (struct filed *)calloc(1, sizeof(*f));
		cfline("*.PANIC\t*", (*nextp)->f_next, "*");
d1194 5
a1198 4
		f = (struct filed *)calloc(1, sizeof(*f));
		*nextp = f;
		nextp = &f->f_next;
		cfline(cline, f, prog);
d1246 27
d1276 2
a1277 2
void
cfline(char *line, struct filed *f, char *prog)
d1283 1
a1283 1
	struct filed *xf;
d1289 4
a1292 2
	/* clear out file entry */
	memset(f, 0, sizeof(*f));
d1340 2
a1341 1
				return;
d1360 2
a1361 1
					return;
d1404 8
d1503 1
@


1.84
log
@size_t vs ssize_t confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.83 2004/09/14 23:25:34 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.83 2004/09/14 23:25:34 deraadt Exp $";
d1294 1
a1294 1
		while (strchr(", ;", *q))
@


1.83
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.82 2004/07/03 23:40:44 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.82 2004/07/03 23:40:44 djm Exp $";
d549 2
d552 1
a552 1
				len = recvfrom(pfd[PFD_UNIX_0 + i].fd, line,
d555 2
a556 2
				if (len > 0) {
					line[len] = '\0';
d558 1
a558 1
				} else if (len < 0 && errno != EINTR)
@


1.82
log
@-Wall,-Wshadow cleanup with avsm@@; ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.81 2004/07/03 05:32:18 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.81 2004/07/03 05:32:18 djm Exp $";
d983 1
d1039 1
d1046 1
@


1.81
log
@support @@hostname:port syntax in syslog.conf, prompted by msf@@ at c2k4;
ok henning@@ anil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.80 2004/06/25 19:10:54 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.80 2004/06/25 19:10:54 djm Exp $";
d160 1
a160 1
	int	f_repeatcount;			/* number of "repeated" msgs */
d285 1
a285 1
	struct sockaddr_in sin, frominet;
d367 5
a371 5
		memset(&sin, 0, sizeof(sin));
		sin.sin_len = sizeof(sin);
		sin.sin_family = AF_INET;
		sin.sin_port = LogPort = sp->s_port;
		if (bind(fd, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
a1249 1
	const char *errstr;
a1250 1
	char addr[MAXHOSTNAMELEN];
a1296 1
			int i;
d1774 1
a1774 1
	dprintf("ctlcmd reply length %d\n", ctl_reply_size);
@


1.80
log
@extend memory buffer control protocol to support transmission of flags,
starting with one to indicate whether the memory ringbuffers have overflowed;
idea & ok markus@@

NB if you are using memory buffered logging make sure you update both syslogd
and syslogc _and_ restart syslogd because the protocol has changed
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.79 2004/06/03 12:21:08 dhartmei Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.79 2004/06/03 12:21:08 dhartmei Exp $";
d145 1
a145 1
			struct sockaddr_in	f_addr;
d265 1
a265 1
void	logerror(char *);
d854 1
a854 1
		    sizeof(f->f_un.f_forw.f_addr)) != l) {
d1054 1
a1054 1
logerror(char *type)
d1249 2
a1250 1
	char *bp, *p, *q;
d1347 14
a1360 4
		(void)strlcpy(f->f_un.f_forw.f_hname, ++p,
		    sizeof(f->f_un.f_forw.f_hname));
		addr_len = priv_gethostbyname(f->f_un.f_forw.f_hname,
		    addr, sizeof addr);
d1362 2
a1363 1
			logerror((char *)hstrerror(h_errno));
a1365 6
		memset(&f->f_un.f_forw.f_addr, 0,
		    sizeof(f->f_un.f_forw.f_addr));
		f->f_un.f_forw.f_addr.sin_len = sizeof(f->f_un.f_forw.f_addr);
		f->f_un.f_forw.f_addr.sin_family = AF_INET;
		f->f_un.f_forw.f_addr.sin_port = LogPort;
		memmove(&f->f_un.f_forw.f_addr.sin_addr, addr, addr_len);
@


1.79
log
@allow '!!prog', where the second '!' means messages from prog should only
be logged by the subsequent block, aborting evaluation when matching.
Useful to log some daemons to dedicated files only (not polluting standard
files with their messages). ok beck@@, henning@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.78 2004/06/03 08:21:40 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.78 2004/06/03 08:21:40 otto Exp $";
d151 1
d215 6
a220 1
size_t	ctl_cmd_bytes = 0;	/* number of bytes of ctl_cmd read */
d222 1
d227 3
a229 2
	int	cmd;
	char	logname[MAX_MEMBUF_NAME];
d232 13
d463 1
a463 1
	    (ctl_reply = malloc(MAX_MEMBUF)) == NULL) {
d921 2
a922 1
		ringbuf_append_line(f->f_un.f_mb.f_rb, line);
d1437 1
d1661 4
d1672 1
d1692 6
d1705 1
a1705 2
	ctl_reply_size = ctl_reply_offset = 0;
	*ctl_reply = '\0';
d1707 4
d1716 1
d1719 1
a1719 1
			strlcpy(ctl_reply, "No such log\n", MAX_MEMBUF);
d1721 7
a1727 3
			ringbuf_to_string(ctl_reply, MAX_MEMBUF,
			    f->f_un.f_mb.f_rb);
			if (ctl_cmd.cmd == CMD_READ_CLEAR)
d1729 2
d1732 1
a1732 1
		ctl_reply_size = strlen(ctl_reply);
d1737 1
a1737 1
			strlcpy(ctl_reply, "No such log\n", MAX_MEMBUF);
d1740 4
a1743 1
			strlcpy(ctl_reply, "Log cleared\n", MAX_MEMBUF);
d1745 1
a1745 1
		ctl_reply_size = strlen(ctl_reply);
d1750 1
a1750 1
				strlcat(ctl_reply, f->f_un.f_mb.f_mname,
d1752 5
a1756 1
				strlcat(ctl_reply, " ", MAX_MEMBUF);
d1759 2
a1760 2
		strlcat(ctl_reply, "\n", MAX_MEMBUF);
		ctl_reply_size = strlen(ctl_reply);
d1767 2
d1770 1
a1771 6

	/* If there is no reply, close the connection now */
	if (ctl_reply_size == 0) {
		ctlconn_cleanup();
		return;
	}
@


1.78
log
@Interpret !* correcly. ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.77 2004/05/25 23:51:30 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.77 2004/05/25 23:51:30 djm Exp $";
d160 1
d681 1
a681 1
		if (!isalnum(msg[i]))
d758 3
d1154 1
a1154 1
				if (!isalnum(p[i]))
d1242 5
@


1.77
log
@include hostname in memory buffered logs, spotted by
ssurdock AT engineered-net.com; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.76 2004/04/15 18:13:07 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.76 2004/04/15 18:13:07 millert Exp $";
d1145 1
a1145 1
			if (!*p) {
@


1.76
log
@Prevent another instance of syslogd from unlinking log sockets that
are already in use.  Found by mpech@@, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.75 2004/04/13 12:07:06 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.75 2004/04/13 12:07:06 djm Exp $";
d893 3
a895 2
		snprintf(line, sizeof(line), "%.15s %s",
		    (char *)iov[0].iov_base, (char *)iov[4].iov_base);
@


1.75
log
@fix null pointer dereference when trying to read+clear non-existent memory
log; spotted by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.74 2004/01/19 16:06:05 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.74 2004/01/19 16:06:05 millert Exp $";
a334 14
#ifndef SUN_LEN
#define SUN_LEN(unp) (strlen((unp)->sun_path) + 2)
#endif
	for (i = 0; i < nfunix; i++) {
		if ((fd = unix_socket(funixn[i], SOCK_DGRAM, 0666)) == -1) {
			if (i == 0)
				die(0);
			continue;
		}
		double_rbuf(fd);
		pfd[PFD_UNIX_0 + i].fd = fd;
		pfd[PFD_UNIX_0 + i].events = POLLIN;
	}

d361 14
d376 9
a384 1
		if ((fd = unix_socket(ctlsock_path, SOCK_STREAM, 0600)) == -1)
a385 6
		if (listen(fd, 16) == -1) {
			logerror("ctlsock listen");
			die(0);
		}
		pfd[PFD_CTLSOCK].fd = fd;
		pfd[PFD_CTLSOCK].events = POLLIN;
d1518 10
@


1.74
log
@Check malloc() return value.  Pointed out by mpech@@.  Ok mpech@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.73 2004/01/13 04:08:27 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.73 2004/01/13 04:08:27 djm Exp $";
d1663 2
a1666 3

		if (ctl_cmd.cmd == CMD_READ_CLEAR)
			ringbuf_clear(f->f_un.f_mb.f_rb);
@


1.73
log
@buffer size should be unsigned, report mpech@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.72 2004/01/05 09:45:49 jmc Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.72 2004/01/05 09:45:49 jmc Exp $";
d324 4
a327 1
	line = malloc(linesize);
@


1.72
log
@sort options and SYNOPSIS;
sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.71 2004/01/04 18:29:33 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.71 2004/01/04 18:29:33 deraadt Exp $";
d1215 2
a1216 1
	int i, pri, addr_len, rb_len;
@


1.71
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.70 2004/01/04 08:28:49 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.70 2004/01/04 08:28:49 djm Exp $";
d544 2
a545 2
	    "usage: syslogd [-dnu] [-f config_file] [-m mark_interval] "
	    "[-a path] [-p log_socket]\n");
@


1.70
log
@Buffered logging for syslogd. Logs may be stored in memory buffers and
extracted using a small client. Useful for diskless systems.
much feedback from deraadt@@, canacar@@, jmc@@, jakob@@ ; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.69 2003/12/29 22:08:44 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.69 2003/12/29 22:08:44 deraadt Exp $";
d1361 1
a1361 1
		if (*p == '\0' || (errno == ERANGE && rb_len == ULONG_MAX) || 
@


1.69
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.68 2003/12/29 22:05:11 djm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.68 2003/12/29 22:05:11 djm Exp $";
d66 1
d70 3
d148 4
d182 1
d184 1
a184 1
char	*TypeNames[7] = {
d186 1
a186 1
	"FORW",		"USERS",	"WALL"
d207 20
d252 5
d262 1
a262 1
	struct sockaddr_un sunx, fromunix;
d264 1
a264 1
	socklen_t slen, len;
d270 1
a270 1
	while ((ch = getopt(argc, argv, "dnuf:m:p:a:")) != -1)
d285 1
a285 6
			if (strlen(optarg) >= sizeof(sunx.sun_path)) {
				fprintf(stderr,
				    "syslogd: socket path too long, exiting\n");
				exit(1);
			} else
				funixn[0] = optarg;
a294 4
			else if (strlen(optarg) >= sizeof(sunx.sun_path))
				fprintf(stderr,
				    "syslogd: path too long, ignoring %s\n",
				    optarg);
d298 3
d336 1
a336 11
		(void)unlink(funixn[i]);
		memset(&sunx, 0, sizeof(sunx));
		sunx.sun_family = AF_UNIX;
		(void)strlcpy(sunx.sun_path, funixn[i], sizeof(sunx.sun_path));
		if ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1 ||
		    bind(fd, (struct sockaddr *)&sunx, SUN_LEN(&sunx)) == -1 ||
		    chmod(funixn[i], 0666) < 0) {
			(void)snprintf(line, linesize, "cannot create %s",
			    funixn[i]);
			logerror(line);
			dprintf("cannot create %s (%d)\n", funixn[i], errno);
d339 1
a339 9
		} else {
			/* double socket receive buffer size */
			if (getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len,
			    &slen) == 0) {
				len *= 2;
				(void)setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len, slen);
			}
			pfd[PFD_UNIX_0 + i].fd = fd;
			pfd[PFD_UNIX_0 + i].events = POLLIN;
d341 3
d366 1
a366 7
			/* double socket receive buffer size */
			if (getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len,
			    &slen) == 0) {
				len *= 2;
				(void)setsockopt(fd, SOL_SOCKET,
				    SO_RCVBUF, &len, slen);
			}
d371 12
d434 7
d462 1
d484 1
d513 6
d885 7
d1192 5
d1215 1
a1215 1
	int i, pri, addr_len;
d1219 1
d1355 46
d1491 246
@


1.68
log
@convert from select() to poll() for main event loop; tested millert@@, deraadt@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.67 2003/09/19 08:15:55 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.67 2003/09/19 08:15:55 deraadt Exp $";
d323 1
a323 1
			if (getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len, 
d489 2
a490 2
				len = recvfrom(pfd[PFD_UNIX_0 + i].fd, line, 
				    MAXLINE, 0, (struct sockaddr *)&fromunix, 
@


1.67
log
@whack getopt ? matching; jeffi@@rcn.com
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.66 2003/08/18 16:56:31 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.66 2003/08/18 16:56:31 millert Exp $";
d96 1
d183 2
a189 2
int	finet = -1;		/* Internet datagram socket */
int	fklog = -1;		/* Kernel log device socket */
d198 2
a223 6
#define MAXFUNIX	21

int nfunix = 1;
char *funixn[MAXFUNIX] = { _PATH_LOG };
int funix[MAXFUNIX];

d227 1
a227 1
	int ch, i, linesize, fdsrmax = 0;
a230 1
	fd_set *fdsr = NULL;
d263 2
a264 2
				fprintf(stderr,
				    "syslogd: out of descriptors, ignoring %s\n",
d298 6
a308 1

d312 2
a313 4
		funix[i] = socket(AF_UNIX, SOCK_DGRAM, 0);
		if (funix[i] < 0 ||
		    bind(funix[i], (struct sockaddr *)&sunx,
		    SUN_LEN(&sunx)) < 0 ||
d321 9
a329 7
		}
		/* double socket receive buffer size */
		if (getsockopt(funix[i], SOL_SOCKET, SO_RCVBUF, &len,
		    &slen) == 0) {
			len *= 2;
			(void)setsockopt(funix[i], SOL_SOCKET, SO_RCVBUF, &len,
			    slen);
d332 2
a333 2
	finet = socket(AF_INET, SOCK_DGRAM, 0);
	if (finet >= 0) {
d336 1
d347 1
a347 1
		if (bind(finet, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
d354 1
a354 1
			if (getsockopt(finet, SOL_SOCKET, SO_RCVBUF, &len,
d357 1
a357 1
				(void)setsockopt(finet, SOL_SOCKET,
d360 2
d364 1
a364 1
	if ((fklog = open(_PATH_KLOG, O_RDONLY, 0)) < 0)
d366 4
a437 14
	if (fklog != -1 && fklog > fdsrmax)
		fdsrmax = fklog;
	if (finet != -1 && finet > fdsrmax)
		fdsrmax = finet;
	for (i = 0; i < nfunix; i++) {
		if (funix[i] != -1 && funix[i] > fdsrmax)
			fdsrmax = funix[i];
	}

	fdsr = (fd_set *)calloc(howmany(fdsrmax+1, NFDBITS),
	    sizeof(fd_mask));
	if (fdsr == NULL)
		errx(1, "calloc fd_set");

d449 1
a449 13
		bzero(fdsr, howmany(fdsrmax+1, NFDBITS) *
		    sizeof(fd_mask));

		if (fklog != -1)
			FD_SET(fklog, fdsr);
		if (finet != -1)
			FD_SET(finet, fdsr);
		for (i = 0; i < nfunix; i++) {
			if (funix[i] != -1)
				FD_SET(funix[i], fdsr);
		}

		switch (select(fdsrmax+1, fdsr, NULL, NULL, NULL)) {
d454 1
a454 1
				logerror("select");
d457 2
a458 3

		if (fklog != -1 && FD_ISSET(fklog, fdsr)) {
			i = read(fklog, line, linesize - 1);
d464 2
a465 1
				fklog = -1;
d468 1
a468 1
		if (finet != -1 && FD_ISSET(finet, fdsr)) {
d470 1
a470 1
			i = recvfrom(finet, line, MAXLINE, 0,
d477 2
a478 1
					cvthname(&frominet, resolve, sizeof resolve);
d487 1
a487 1
			if (funix[i] != -1 && FD_ISSET(funix[i], fdsr)) {
d489 3
a491 2
				len = recvfrom(funix[i], line, MAXLINE, 0,
				    (struct sockaddr *)&fromunix, &len);
d500 3
a502 2
	if (fdsr)
		free(fdsr);
d788 1
a788 1
		if (sendto(finet, line, l, 0,
d1397 1
@


1.66
log
@Call tzset() to stash the current timezone before we chroot.
OK deraadt@@ and avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.65 2003/07/31 18:20:07 avsm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.65 2003/07/31 18:20:07 avsm Exp $";
a276 1
		case '?':
@


1.65
log
@Privilege separated syslog daemon.  The child listening to log requests drops
to user _syslogd and chroots itself, while the privileged parent grants it
access to open logfiles and other calls it needs.

The only difference from existing behaviour is that if syslog.conf changes
and syslogd receives a HUP, it will re-exec itself and have two new PIDs.
A HUP with an unchanged config will make syslogd reopen logfiles as before.

Lots of help and code from deraadt@@ , and advice from millert@@

Various versions tested by todd, cloder, mpech, markus, tdeval and others
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.64 2003/07/08 01:28:11 avsm Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.64 2003/07/08 01:28:11 avsm Exp $";
d367 2
@


1.64
log
@dont silently truncate a domain socket specified via the -p argument;
error out instead if its too long.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.63 2003/06/02 23:36:54 millert Exp $	*/
d33 1
a33 1
static char copyright[] =
d40 1
a40 1
static char sccsid[] = "@@(#)syslogd.c	8.3 (Berkeley) 4/4/94";
d42 1
a42 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.63 2003/06/02 23:36:54 millert Exp $";
d107 1
a107 3
char	*ConfFile = _PATH_LOGCONF;
char	*PidFile = _PATH_LOGPID;
char	ctty[] = _PATH_CONSOLE;
d109 2
a110 1
#define	dprintf		if (Debug) printf
d114 1
d162 1
a162 1
				 (f)->f_repeatcount = MAXREPEAT; \
d183 1
d187 2
a188 1
int	finet;			/* Internet datagram socket */
d202 2
a203 2
char   *cvthname(struct sockaddr_in *);
int	decode(const char *, CODE *);
d230 1
a230 1
	int ch, i, fklog, linesize, fdsrmax = 0;
d236 2
d284 1
a284 3
	if (!Debug)
		(void)daemon(0, 0);
	else
a302 8
	(void)signal(SIGHUP, doinit);
	(void)signal(SIGTERM, dodie);
	(void)signal(SIGINT, Debug ? dodie : SIG_IGN);
	(void)signal(SIGQUIT, Debug ? dodie : SIG_IGN);
	(void)signal(SIGCHLD, reapchild);
	(void)signal(SIGALRM, domark);
	(void)alarm(TIMERINTVL);

d364 24
d390 1
a390 1
		fp = fopen(PidFile, "w");
d397 3
a399 1
	dprintf("off & running....\n");
d401 1
d404 25
d494 3
a496 1
					printline(cvthname(&frominet), line);
d555 1
a555 1
	 *       messages with no facility specified.
d664 1
a664 1
		f->f_file = open(ctty, O_WRONLY|O_NONBLOCK, 0);
d842 1
a842 2
				f->f_file = open(f->f_un.f_fname,
				    O_WRONLY|O_APPEND|O_NONBLOCK, 0);
d886 1
a886 1
	if ((uf = fopen(_PATH_UTMP, "r")) == NULL) {
d938 2
a939 2
char *
cvthname(struct sockaddr_in *f)
a940 1
	struct hostent *hp;
d942 2
a943 2
	char *p;
	char *ip;
d947 2
a948 1
		return ("???");
d953 4
a956 2
	if (NoDNS)
		return (ip);
d961 4
a964 2
	hp = gethostbyaddr((char *)&f->sin_addr,
	    sizeof(struct in_addr), f->sin_family);
d966 1
a966 1
	if (hp == 0) {
d968 2
a969 3
		return (ip);
	}
	if ((p = strchr(hp->h_name, '.')) && strcmp(p + 1, LocalDomain) == 0)
a970 1
	return (hp->h_name);
d1006 4
a1009 1
	logmsg(LOG_SYSLOG|LOG_ERR, buf, LocalHostName, ADDDATE);
a1017 1
	int i;
d1033 1
a1033 3
	for (i = 0; i < nfunix; i++)
		if (funixn[i] && funix[i] != -1)
			(void)unlink(funixn[i]);
d1050 6
d1083 1
a1083 1
	if ((cf = fopen(ConfFile, "r")) == NULL) {
d1183 1
a1183 2
	struct hostent *hp;
	int i, pri;
d1186 1
d1277 3
a1279 4
		hp = gethostbyname(f->f_un.f_forw.f_hname);
		if (hp == NULL) {
			extern int h_errno;

d1288 1
a1288 2
		memmove(&f->f_un.f_forw.f_addr.sin_addr, hp->h_addr,
		    hp->h_length);
d1294 4
a1297 1
		f->f_file = open(p, O_WRONLY|O_APPEND|O_NONBLOCK, 0);
d1364 1
a1364 1
decode(const char *name, CODE *codetab)
d1366 1
a1366 1
	CODE *c;
@


1.63
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.62 2003/05/17 19:44:06 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.62 2003/05/17 19:44:06 millert Exp $";
d251 6
a256 1
			funixn[0] = optarg;
@


1.62
log
@Fix typo in last commit, spotted by Brian Poole.  That'll teach me
to commit on an empty stomach.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.61 2003/05/17 17:49:28 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.61 2003/05/17 17:49:28 millert Exp $";
@


1.61
log
@Cannot use strlcpy() for strings in struct utmp since they are not guaranteed
to be NUL-terminated.  Fixes a bug introduced in rev 1.37; noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.60 2003/03/21 19:28:58 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.60 2003/03/21 19:28:58 millert Exp $";
d849 1
a849 1
		line[sizeof(line) - 1];
@


1.60
log
@Fix default facility when none is specified (should be LOG_USER,
was LOG_UUCP due to a bug); Javier Kohen
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.59 2002/12/22 17:19:42 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.59 2002/12/22 17:19:42 mickey Exp $";
d847 3
a849 1
		strlcpy(line, ut.ut_line, sizeof(line));
@


1.59
log
@fix cutnpaste; from hunter@@comsys.com.ua
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.58 2002/11/21 07:46:48 cloder Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.58 2002/11/21 07:46:48 cloder Exp $";
d503 5
a507 1
	/* don't allow users to log kernel messages */
d509 1
a509 1
		pri = LOG_MAKEPRI(LOG_USER, LOG_PRI(pri));
@


1.58
log
@Add -n option to print message source addresses numerically rather than
symbolically.  This saves address->name lookups, which is nice on log
servers without a DNS cache.

millert@@, jakob@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.57 2002/09/06 19:46:52 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.57 2002/09/06 19:46:52 deraadt Exp $";
d361 1
a361 1
				(void)setsockopt(funix[i], SOL_SOCKET,
@


1.57
log
@use more socklen_t; pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.56 2002/08/08 23:07:12 aaron Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.56 2002/08/08 23:07:12 aaron Exp $";
d196 2
a202 2
int	SecureMode = 1;		/* when true, speak only unix domain socks */

d240 1
a240 1
	while ((ch = getopt(argc, argv, "duf:m:p:a:")) != -1)
d251 3
d475 1
a475 1
	    "usage: syslogd [-du] [-f config_file] [-m mark_interval] "
d890 1
a890 2

	dprintf("cvthname(%s)\n", inet_ntoa(f->sin_addr));
d896 6
d909 2
a910 3
		dprintf("Host name for your address (%s) unknown\n",
			inet_ntoa(f->sin_addr));
		return (inet_ntoa(f->sin_addr));
@


1.56
log
@Pass correct buffer length to snprintf on error condition; ericj@@, fgsch@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.55 2002/07/24 22:10:23 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.55 2002/07/24 22:10:23 millert Exp $";
d232 1
a232 1
	int ch, i, fklog, len, linesize, fdsrmax = 0;
d235 1
a235 1
	socklen_t slen;
@


1.55
log
@Sanity check snprintf() return values before using them.  It is legal for
snprintf(3) to return -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.54 2002/07/20 18:02:03 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.54 2002/07/20 18:02:03 deraadt Exp $";
d319 1
a319 1
			(void)snprintf(line, sizeof line, "cannot create %s",
@


1.54
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.53 2002/06/14 21:35:01 todd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.53 2002/06/14 21:35:01 todd Exp $";
d319 1
a319 1
			(void) snprintf(line, sizeof line, "cannot create %s",
d524 1
a524 1
	snprintf(line, sizeof line, "%s: ", _PATH_UNIX);
d690 5
d696 1
a696 5
		v->iov_len = snprintf(greetings, sizeof(greetings),
		    "\r\n\7Message from syslogd@@%s at %.24s ...\r\n",
		    f->f_prevhost, ctime(&now));
		if (v->iov_len >= sizeof(greetings))
			v->iov_len = sizeof(greetings) - 1;
d720 4
d725 1
a725 2
		v->iov_len = snprintf(repbuf, sizeof repbuf,
		    "last message repeated %d times", f->f_prevcount);
d742 4
a745 4
		l = snprintf(line, sizeof(line) - 1, "<%d>%.15s %s", f->f_prevpri,
		    (char *)iov[0].iov_base, (char *)iov[4].iov_base);
		if (l > MAXLINE)
			l = MAXLINE;
@


1.53
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.52 2002/06/05 17:12:52 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.52 2002/06/05 17:12:52 millert Exp $";
d230 1
a230 3
main(argc, argv)
	int argc;
	char *argv[];
d448 2
a449 1
		} 
d468 1
a468 1
usage()
d482 1
a482 3
printline(hname, msg)
	char *hname;
	char *msg;
d519 1
a519 2
printsys(msg)
	char *msg;
d557 1
a557 4
logmsg(pri, msg, from, flags)
	int pri;
	char *msg, *from;
	int flags;
d563 1
a563 1
 	char prog[NAME_MAX+1];
d681 1
a681 4
fprintlog(f, flags, msg)
	struct filed *f;
	int flags;
	char *msg;
d817 1
a817 3
wallmsg(f, iov)
	struct filed *f;
	struct iovec *iov;
d819 2
a822 1
	struct utmp ut;
a823 2
	char *p;
	char line[sizeof(ut.ut_line) + 1];
d864 1
a864 2
reapchild(signo)
	int signo;
d878 1
a878 2
cvthname(f)
	struct sockaddr_in *f;
d907 1
a907 2
dodie(signo)
	int signo;
d913 1
a913 2
domark(signo)
	int signo;
d919 1
a919 2
doinit(signo)
	int signo;
d928 1
a928 2
logerror(type)
	char *type;
d943 1
a943 2
die(signo)
	int signo;
d974 1
a974 1
init()
d976 3
a979 5
	FILE *cf;
	struct filed *f, *next, **nextp;
	char *p;
	char cline[LINE_MAX];
 	char prog[NAME_MAX+1];
d1108 1
a1108 4
cfline(line, f, prog)
	char *line;
	struct filed *f;
	char *prog;
d1271 1
a1271 1
getmsgbufsize()
d1290 1
a1290 3
decode(name, codetab)
	const char *name;
	CODE *codetab;
@


1.52
log
@Double socket receive buffer size; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.51 2002/05/26 09:25:22 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.51 2002/05/26 09:25:22 deraadt Exp $";
d63 1
a63 1
 * MAXLINE -- the maximimum line length that can be handled.
@


1.51
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.50 2002/05/25 13:54:03 fgsch Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.50 2002/05/25 13:54:03 fgsch Exp $";
d237 1
d328 7
d356 7
@


1.50
log
@fix usage; from Sam Smith <S@@mSmith.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.49 2002/02/16 21:28:09 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.49 2002/02/16 21:28:09 millert Exp $";
d357 1
a357 1
			fprintf(fp, "%d\n", getpid());
@


1.49
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.48 2001/12/02 02:23:45 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.48 2001/12/02 02:23:45 deraadt Exp $";
d458 2
a459 1
	    "usage: syslogd [-u] [-f conffile] [-m markinterval] [-p logpath] [-a logpath]\n");
@


1.48
log
@KNF, and remove unneccessary signal blocking and errno saving, since not signal handlers anymore; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.47 2001/11/17 19:49:41 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.47 2001/11/17 19:49:41 deraadt Exp $";
d203 19
a221 19
void	cfline __P((char *, struct filed *, char *));
char   *cvthname __P((struct sockaddr_in *));
int	decode __P((const char *, CODE *));
void	dodie __P((int));
void	doinit __P((int));
void	die __P((int));
void	domark __P((int));
void	markit __P((void));
void	fprintlog __P((struct filed *, int, char *));
void	init __P((void));
void	logerror __P((char *));
void	logmsg __P((int, char *, char *, int));
void	printline __P((char *, char *));
void	printsys __P((char *));
void	reapchild __P((int));
char   *ttymsg __P((struct iovec *, int, char *, int));
void	usage __P((void));
void	wallmsg __P((struct filed *, struct iovec *));
int	getmsgbufsize __P((void));
@


1.47
log
@use volatile sig_atomic_t where possible; simply volatile i other places
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.46 2001/11/17 13:33:42 markus Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.46 2001/11/17 13:33:42 markus Exp $";
a236 1
	sigset_t blockmask;
a297 2
	sigemptyset(&blockmask);
	sigaddset(&blockmask, SIGHUP);
a385 1
		sigprocmask(SIG_BLOCK, &blockmask, NULL);
a389 1
		sigprocmask(SIG_UNBLOCK, &blockmask, NULL);
d864 1
a865 1
	int save_errno = errno;
a985 1
	int save_errno = errno;
a1022 1
		errno = save_errno;
a1107 1
	errno = save_errno;
d1207 1
a1207 2
	switch (*p)
	{
@


1.46
log
@missing prototype (getmsgbufsize).
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.45 2001/11/17 13:32:57 markus Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.45 2001/11/17 13:32:57 markus Exp $";
d197 3
a199 3
sig_atomic_t MarkSet;
sig_atomic_t WantDie;
sig_atomic_t DoInit;
@


1.45
log
@reread config from main loop instead of signal hander; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.44 2001/11/16 19:57:33 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.44 2001/11/16 19:57:33 deraadt Exp $";
d221 1
@


1.44
log
@no need for setjmp.h
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.43 2001/08/03 20:24:16 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.43 2001/08/03 20:24:16 millert Exp $";
d199 1
d207 1
d212 1
a212 1
void	init __P((int));
d236 1
d298 3
d366 1
a366 2
	init(0);
	(void)signal(SIGHUP, init);
d388 7
d923 7
d982 1
a982 2
init(signo)
	int signo;
@


1.43
log
@Open files with O_NONBLOCK but turn off non-blocking mode for
non-ttys.  If write(2) returns EAGAIN just ignore the error and
move on.  This prevents a locked terminal from causing syslogd
grief.  If we ever want to support logging to a fifo this will
probably have to be revisited.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.42 2001/08/03 19:09:26 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.42 2001/08/03 19:09:26 deraadt Exp $";
a99 1
#include <setjmp.h>
@


1.42
log
@fix typo; jcs@@rt.fm
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.41 2001/07/27 20:34:36 pvalchev Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.41 2001/07/27 20:34:36 pvalchev Exp $";
d592 1
a592 1
		f->f_file = open(ctty, O_WRONLY, 0);
d761 8
a768 1
			if ((e == EIO || e == EBADF) && f->f_type != F_FILE) {
d770 1
a770 1
				    O_WRONLY|O_APPEND, 0);
d1223 2
a1224 1
		if ((f->f_file = open(p, O_WRONLY|O_APPEND, 0)) < 0) {
d1229 6
a1234 3
		if (isatty(f->f_file))
			f->f_type = F_TTY;
		else
d1236 6
a1241 2
		if (strcmp(p, ctty) == 0)
			f->f_type = F_CONSOLE;
@


1.41
log
@Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.40 2001/02/07 06:15:46 fgsch Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.40 2001/02/07 06:15:46 fgsch Exp $";
d263 1
a263 1
				    "syslogd: path to long, ignoring %s\n",
@


1.40
log
@Remove support for #!. It's not intuitive and if you happen to add
lines as the end of a stock syslog.conf you're going to spend some time
figuring why is not working as it should; problem found by
riq@@core-sdi.com, millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.39 2001/01/19 17:53:19 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.39 2001/01/19 17:53:19 deraadt Exp $";
d97 1
d726 1
a726 1
		    iov[0].iov_base, iov[4].iov_base);
@


1.39
log
@mark remaining signal races which are difficult to fix
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.38 2001/01/16 23:58:00 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.38 2001/01/16 23:58:00 deraadt Exp $";
d1015 1
a1015 1
		 * spaces and newline character. #!prog  and !prog are treated
d1020 1
a1020 1
		if (*p == '\0')
a1021 5
		if (*p == '#') {
			p++;
			if (*p != '!')
				continue;
		}
@


1.38
log
@fix another signal race, and check signal flags even in non-EINTR from select case
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.37 2001/01/11 23:39:12 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.37 2001/01/11 23:39:12 deraadt Exp $";
d196 3
a198 2
volatile int MarkSet;
volatile int WantDie;
@


1.37
log
@fd_set overflows, move races out of signal handlers, and fd_set repairs;
some conversations with alejo@@core-sdi.com, not sure yet if this is 100%
perfect, but i have tested it and it works..
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.36 2000/09/13 23:10:25 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.36 2000/09/13 23:10:25 millert Exp $";
d197 1
d204 1
d294 3
a296 3
	(void)signal(SIGTERM, die);
	(void)signal(SIGINT, Debug ? die : SIG_IGN);
	(void)signal(SIGQUIT, Debug ? die : SIG_IGN);
d377 5
a399 2
			if (MarkSet)
				markit();
d887 7
@


1.36
log
@Use vis(3) when escaping non-printable characters instead of doing it
(poorly) by hand.  Also fixes a potential one byte overflow noted
by Solar Designer.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.35 2000/08/17 22:00:32 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.35 2000/08/17 22:00:32 deraadt Exp $";
d193 1
d196 2
d205 1
d228 1
a228 1
	int ch, i, fklog, len, linesize;
d231 2
a233 1
	char *p, *line;
d277 2
a278 1
	(void)strcpy(consfile.f_un.f_fname, ctty);
d307 1
a307 1
		(void)strncpy(sunx.sun_path, funixn[i], sizeof(sunx.sun_path));
d310 2
a311 1
		    bind(funix[i], (struct sockaddr *)&sunx, SUN_LEN(&sunx)) < 0 ||
d360 14
d375 2
a376 2
		fd_set readfds;
		int nfds = 0;
d378 4
a381 11
		FD_ZERO(&readfds);
		if (fklog != -1) {
			FD_SET(fklog, &readfds);
			if (fklog > nfds)
				nfds = fklog;
		}
		if (finet != -1) {
			FD_SET(finet, &readfds);
			if (finet > nfds)
				nfds = finet;
		}
d383 2
a384 5
			if (funix[i] != -1) {
				FD_SET(funix[i], &readfds);
				if (funix[i] > nfds)
					nfds = funix[i];
			}
d387 2
a388 4
		/*dprintf("readfds = %#x\n", readfds);*/
		nfds = select(nfds+1, &readfds, (fd_set *)NULL,
		    (fd_set *)NULL, (struct timeval *)NULL);
		if (nfds == 0)
d390 1
a390 1
		if (nfds < 0) {
d393 2
d397 2
a398 2
		/*dprintf("got a message (%d, %#x)\n", nfds, readfds);*/
		if (fklog != -1 && FD_ISSET(fklog, &readfds)) {
d408 1
a408 1
		if (finet != -1 && FD_ISSET(finet, &readfds)) {
d423 1
a423 1
			if (funix[i] != -1 && FD_ISSET(funix[i], &readfds)) {
d435 2
d498 1
a498 2
	(void)strcpy(line, _PATH_UNIX);
	(void)strcat(line, ": ");
d619 1
a619 1
			(void)strncpy(f->f_lasttime, timestamp, 15);
d640 3
a642 4
			(void)strncpy(f->f_lasttime, timestamp, 15);
			(void)strncpy(f->f_prevhost, from,
					sizeof(f->f_prevhost)-1);
			f->f_prevhost[sizeof(f->f_prevhost)-1] = '\0';
d645 1
a645 1
				(void)strcpy(f->f_prevline, msg);
d700 2
a701 2
		v->iov_len = sprintf(repbuf, "last message repeated %d times",
		    f->f_prevcount);
d812 1
a812 2
		strncpy(line, ut.ut_line, sizeof(ut.ut_line));
		line[sizeof(ut.ut_line)] = '\0';
d888 1
a888 21
	struct filed *f;
	int save_errno = errno;

	now = time((time_t *)NULL);
	MarkSeq += TIMERINTVL;
	if (MarkSeq >= MarkInterval) {
		logmsg(LOG_INFO, "-- MARK --", LocalHostName, ADDDATE|MARK);
		MarkSeq = 0;
	}

	for (f = Files; f; f = f->f_next) {
		if (f->f_prevcount && now >= REPEATTIME(f)) {
			dprintf("flush %s: repeated %d times, %d sec.\n",
			    TypeNames[f->f_type], f->f_prevcount,
			    repeatinterval[f->f_repeatcount]);
			fprintlog(f, 0, (char *)NULL);
			BACKOFF(f);
		}
	}
	(void)alarm(TIMERINTVL);
	errno = save_errno;
d920 1
d929 1
a929 1
		(void)sprintf(buf, "exiting on signal %d", signo);
d998 1
a998 1
	strcpy(prog, "*");
d1019 1
a1019 1
				strcpy(prog, "*");
d1113 1
a1113 1
			strcpy(f->f_program, prog);
d1186 2
a1187 3
		(void)strncpy(f->f_un.f_forw.f_hname, ++p,
		    sizeof(f->f_un.f_forw.f_hname)-1);
		f->f_un.f_forw.f_hname[sizeof(f->f_un.f_forw.f_hname)-1] = '\0';
d1206 1
a1206 1
		(void)strcpy(f->f_un.f_fname, p);
d1288 26
@


1.35
log
@do the save_errno thing, but other races still exist in here
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.34 2000/02/22 19:28:06 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.34 2000/02/22 19:28:06 deraadt Exp $";
d98 1
d106 1
a106 1
#include <paths.h>
d444 1
a444 1
	int c, pri;
d464 3
a466 13
	q = line;

	while ((c = *p++ & 0177) != '\0' &&
	    q < &line[sizeof(line) - 1])
		if (iscntrl(c))
			if (c == '\n')
				*q++ = ' ';
			else if (c == '\t')
				*q++ = '\t';
			else {
				*q++ = '^';
				*q++ = c ^ 0100;
			}
d468 2
a469 1
			*q++ = c;
d503 1
d505 3
a507 4
		while (*p != '\0' && (c = *p++) != '\n' &&
		    q < &line[MAXLINE])
			*q++ = c;
		*q = '\0';
@


1.34
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.33 1999/07/06 10:07:03 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.33 1999/07/06 10:07:03 millert Exp $";
d887 1
d906 1
d969 1
d1007 1
d1095 2
a1096 1
	logmsg(LOG_SYSLOG|LOG_INFO, "syslogd: restart", LocalHostName, ADDDATE);
d1098 1
@


1.33
log
@union wait -> int
wait3 -> waitpid (for portability)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.5 1996/01/02 17:48:41 perry Exp $";
d86 1
d223 1
a223 1
	int ch, i, fklog, len;
d227 1
a227 1
	char *p, line[MSG_BSIZE + 1];
d278 7
d387 1
a387 1
			i = read(fklog, line, sizeof(line) - 1);
d1254 19
@


1.32
log
@The necessary defs are in paths.h now.
@
text
@d1 2
d43 5
a47 2
/*static char sccsid[] = "@@(#)syslogd.c	8.3 (Berkeley) 4/4/94";*/
static char rcsid[] = "$NetBSD: syslogd.c,v 1.5 1996/01/02 17:48:41 perry Exp $";
d833 1
a833 1
	union wait status;
d836 1
a836 1
	while (wait3((int *)&status, WNOHANG, (struct rusage *)NULL) > 0)
@


1.31
log
@careful about sunx.sun_path termination; matter@@research.suspicious.org
@
text
@d99 1
a99 1
#include "pathnames.h"
@


1.30
log
@make it 21 total log devs
@
text
@d241 1
a241 3
			if (nfunix < MAXFUNIX)
				funixn[nfunix++] = optarg;
			else
d245 6
@


1.29
log
@Fix snprintf return value usage.
@
text
@d206 1
a206 1
#define MAXFUNIX	20
@


1.28
log
@bogus use of variable for two purposes; guido@@gvr.org
@
text
@d654 2
@


1.27
log
@MAXHOSTNAMELEN not MAXHOSTNAMELEN+1
@
text
@d396 1
a396 1
				i = recvfrom(funix[i], line, MAXLINE, 0,
d398 2
a399 2
				if (i > 0) {
					line[i] = '\0';
d401 1
a401 1
				} else if (i < 0 && errno != EINTR)
@


1.26
log
@select on nfds+1, not nfds.  ficus@@openbsd.org
@
text
@d136 1
a136 1
			char	f_hname[MAXHOSTNAMELEN+1];
d143 1
a143 1
	char	f_prevhost[MAXHOSTNAMELEN+1];	/* host from which recd. */
d180 1
a180 1
char	LocalHostName[MAXHOSTNAMELEN+1];	/* our hostname */
d621 2
a622 1
					sizeof(f->f_prevhost));
d1178 4
a1181 2
		(void)strcpy(f->f_un.f_forw.f_hname, ++p);
		hp = gethostbyname(p);
@


1.25
log
@use sigset_t all over the place
@
text
@d359 1
a359 1
		nfds = select(nfds, &readfds, (fd_set *)NULL,
@


1.24
log
@syslogd gets a new -a argument: specify additional AF_UNIX log devices
syslogd should create & listen to. As in "syslogd -a /chroot/dev/log",
I'm sure you get the idea.
@
text
@d516 2
a517 1
	int fac, msglen, omask, prilev, i;
d524 4
a527 1
	omask = sigblock(sigmask(SIGHUP)|sigmask(SIGALRM));
d571 1
a571 1
		(void)sigsetmask(omask);
d633 1
a633 1
	(void)sigsetmask(omask);
@


1.23
log
@workaround gethostbyaddr() race in signal handler; more correct fix would
change SIGHUP handler to only set a flag that the main loop catches. But
I'm lazy, and starting to believe noone gives a damn...
@
text
@a103 1
char	*LogName = _PATH_LOG;
a107 2
#define FDMASK(fd)	(1 << (fd))

d206 6
d217 1
a217 1
	int ch, funix, i, inetm = 0, fklog, klogm, len;
d223 1
a223 1
	while ((ch = getopt(argc, argv, "duf:m:p:")) != -1)
d235 1
a235 1
			LogName = optarg;
d240 8
a273 1
	(void)unlink(LogName);
d278 17
a294 11
	memset(&sunx, 0, sizeof(sunx));
	sunx.sun_family = AF_UNIX;
	(void)strncpy(sunx.sun_path, LogName, sizeof(sunx.sun_path));
	funix = socket(AF_UNIX, SOCK_DGRAM, 0);
	if (funix < 0 ||
	    bind(funix, (struct sockaddr *)&sunx, SUN_LEN(&sunx)) < 0 ||
	    chmod(LogName, 0666) < 0) {
		(void) snprintf(line, sizeof line, "cannot create %s", LogName);
		logerror(line);
		dprintf("cannot create %s (%d)\n", LogName, errno);
		die(0);
a314 1
			inetm = FDMASK(finet);
d318 1
a318 3
	if ((fklog = open(_PATH_KLOG, O_RDONLY, 0)) >= 0)
		klogm = FDMASK(fklog);
	else {
a319 2
		klogm = 0;
	}
d336 2
a337 1
		int nfds, readfds = FDMASK(funix) | inetm | klogm;
d339 21
a359 2
		dprintf("readfds = %#x\n", readfds);
		nfds = select(20, (fd_set *)&readfds, (fd_set *)NULL,
d368 2
a369 2
		dprintf("got a message (%d, %#x)\n", nfds, readfds);
		if (readfds & klogm) {
a376 1
				klogm = 0;
d379 1
a379 11
		if (readfds & FDMASK(funix)) {
			len = sizeof(fromunix);
			i = recvfrom(funix, line, MAXLINE, 0,
			    (struct sockaddr *)&fromunix, &len);
			if (i > 0) {
				line[i] = '\0';
				printline(LocalHostName, line);
			} else if (i < 0 && errno != EINTR)
				logerror("recvfrom unix");
		}
		if (readfds & inetm) {
d393 12
d413 1
a413 1
	    "usage: syslogd [-u] [-f conffile] [-m markinterval] [-p logpath]\n");
d909 1
d924 3
a926 1
	(void)unlink(LogName);
@


1.22
log
@Rewrite bad code.
Suggested by: Theo
@
text
@d801 1
d810 3
d815 1
@


1.21
log
@indent
@
text
@d956 1
a956 1
		if (*p == NULL)
d979 7
a985 3
		for (p = strchr(cline, '\0'); isspace(*--p);)
			continue;
		*++p = '\0';
@


1.20
log
@indent
@
text
@d952 1
a952 1
                 * specially: the following lines apply only to that program.
@


1.19
log
@Understand sections in syslog.conf.
Current syslog.conf files are still understood  andtreated the same.
@
text
@d221 1
a221 1
		switch(ch) {
d519 1
a519 1
		if(!isalnum(msg[i]))
d545 2
a546 2
		if(f->f_program)
			if(strcmp(prog, f->f_program) != 0)
d925 1
a925 1
		if(f->f_program)
d958 1
a958 1
		if(*p == '#') {
d960 1
a960 1
			if(*p != '!')
d963 1
a963 1
		if(*p == '!') {
d965 3
a967 2
			while(isspace(*p)) p++;
			if(!*p) {
d971 2
a972 2
			for(i = 0; i < NAME_MAX; i++) {
				if(!isalnum(p[i]))
d1017 1
a1017 1
			if(f->f_program)
d1055 1
a1055 1
		if(f->f_program)
@


1.18
log
@F_FORW has no associated fd; init sin_len too
@
text
@d135 1
d193 1
a193 1
void	cfline __P((char *, struct filed *));
d484 1
a484 1
	int fac, msglen, omask, prilev;
d486 1
d517 8
d544 5
d902 1
d925 2
d936 1
a936 1
		cfline("*.ERR\t/dev/console", *nextp);
d938 1
a938 1
		cfline("*.PANIC\t*", (*nextp)->f_next);
d947 1
d951 2
a952 1
		 * spaces and newline character.
d956 1
a956 1
		if (*p == NULL || *p == '#')
d958 20
d984 1
a984 1
		cfline(cline, f);
d1016 2
d1030 1
a1030 1
cfline(line, f)
d1033 1
d1040 1
a1040 1
	dprintf("cfline(%s)\n", line);
d1048 9
@


1.17
log
@be more careful about f_file handling throughout
@
text
@d290 1
a650 5
			int e = errno;
			if (f->f_file >= 0) {
				(void)close(f->f_file);
				f->f_file = -1;
			}
a651 1
			errno = e;
d903 2
a905 1
			(void)close(f->f_file);
d1085 2
a1086 1
			 sizeof(f->f_un.f_forw.f_addr));
d1089 2
a1090 1
		memmove(&f->f_un.f_forw.f_addr.sin_addr, hp->h_addr, hp->h_length);
@


1.16
log
@Ignore trailing spaces on priority in /etc/syslogd.conf
@
text
@d522 1
d651 4
a654 1
			(void)close(f->f_file);
d695 1
d1099 1
a1099 1
			f->f_file = F_UNUSED;
@


1.15
log
@save errno in sigchld handlers
@
text
@d1025 6
@


1.14
log
@Wall
@
text
@d771 1
d775 1
@


1.13
log
@act in-Initialized inside part of die(); avoids printing mangled log entry; joerg
@
text
@d213 1
a213 1
	int ch, funix, i, inetm, fklog, klogm, len;
d548 1
a548 1
			    f->f_prevcount, now - f->f_time,
@


1.12
log
@do not whack pid file if run -d; hwr@@pilhuhn.de
@
text
@d853 1
d856 1
d862 1
@


1.11
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d309 6
a314 4
	fp = fopen(PidFile, "w");
	if (fp != NULL) {
		fprintf(fp, "%d\n", getpid());
		(void) fclose(fp);
@


1.10
log
@cleanup debug; pointed out by darcy@@druid.com
@
text
@d219 1
a219 1
	while ((ch = getopt(argc, argv, "duf:m:p:")) != EOF)
@


1.9
log
@bzzt, need finet for outgoing as well
@
text
@d483 1
a483 1
	dprintf("logmsg: pri %o, flags %x, from %s, msg %s\n",
@


1.8
log
@fix usage message
@
text
@d279 1
a279 6
	if (!SecureMode)
		finet = socket(AF_INET, SOCK_DGRAM, 0);
	else {
		finet = -1;
		inetm = 0;
	}
d359 9
a367 5
			if (i > 0) {
				line[i] = '\0';
				printline(cvthname(&frominet), line);
			} else if (i < 0 && errno != EINTR)
				logerror("recvfrom inet");
@


1.7
log
@snprintf some more; also change -s to -u (-u is insecure mode, opens udp port)
@
text
@d378 1
a378 1
	    "usage: syslogd [-f conffile] [-m markinterval] [-p logpath]\n");
@


1.6
log
@Same as last commit, use snprintf, not sprintf
@
text
@d190 1
a190 1
int	SecureMode = 0;		/* when true, speak only unix domain socks */
d219 1
a219 1
	while ((ch = getopt(argc, argv, "dsf:m:p:")) != EOF)
d233 2
a234 2
		case 's':		/* no network mode */
			SecureMode++;
d274 1
a274 1
		(void) sprintf(line, "cannot create %s", LogName);
d596 1
a596 1
		v->iov_len = snprintf(greetings, 500,
d641 1
a641 1
		l = snprintf(line, MAXLINE, "<%d>%.15s %s", f->f_prevpri,
d838 2
a839 2
		(void)snprintf(buf,
		    sizeof(buf), "syslogd: %s: %s", type, strerror(errno));
d1021 1
a1021 1
				(void)sprintf(ebuf,
d1039 1
a1039 1
					(void)sprintf(ebuf,
d1068 1
a1068 1
			logerror(hstrerror(h_errno));
@


1.5
log
@should not use sprintf unless input strings are of known value
Doesn't look to be exploitable.
@
text
@d641 1
a641 1
		l = sprintf(line, "<%d>%.15s %s", f->f_prevpri,
@


1.4
log
@merge error
@
text
@d591 1
a591 1
	char line[MAXLINE + 1], repbuf[80], greetings[200];
d596 1
a596 1
		v->iov_len = sprintf(greetings,
@


1.3
log
@sync with 4.4lite2 version, as well as netbsd changes merged by perry.
retain openbsd changes too.
@
text
@a286 3
	inetm = 0;
	if (finet >= 0) {
		struct servent *sp;
@


1.2
log
@-s option prevents opening of UDP port; from perry@@piermont.com; netbsd pr#1761
@
text
@d2 2
a3 2
 * Copyright (c) 1983, 1988 Regents of the University of California.
 * All rights reserved.
d35 3
a37 3
char copyright[] =
"@@(#) Copyright (c) 1983, 1988 Regents of the University of California.\n\
 All rights reserved.\n";
d41 2
a42 2
/*static char sccsid[] = "from: @@(#)syslogd.c	5.45 (Berkeley) 3/2/91";*/
static char rcsid[] = "$Id: syslogd.c,v 1.1.1.1 1995/10/18 08:48:22 deraadt Exp $";
d72 1
a74 1
#include <sys/errno.h>
a78 1
#include <sys/file.h>
a83 1
#include <sys/signal.h>
d87 1
d89 3
a91 1
#include <utmp.h>
d93 1
d95 1
a95 1
#include <ctype.h>
d98 1
d192 15
a206 2
extern	int errno;
extern	char *ctime(), *index(), *calloc();
d208 1
d211 1
a211 1
	char **argv;
d213 1
a213 3
	register int i;
	register char *p;
	int funix, inetm, fklog, klogm, len;
d217 1
a217 5
	int ch;
	char line[MSG_BSIZE + 1];
	extern int optind;
	extern char *optarg;
	void die(), domark(), init(), reapchild();
d220 1
a220 1
		switch((char)ch) {
d240 1
a240 1
	if (argc -= optind)
d244 1
a244 1
		daemon(0, 0);
d249 3
a251 3
	(void) strcpy(consfile.f_un.f_fname, ctty);
	(void) gethostname(LocalHostName, sizeof LocalHostName);
	if (p = index(LocalHostName, '.')) {
d254 1
a254 2
	}
	else
d256 12
a267 9
	(void) signal(SIGTERM, die);
	(void) signal(SIGINT, Debug ? die : SIG_IGN);
	(void) signal(SIGQUIT, Debug ? die : SIG_IGN);
	(void) signal(SIGCHLD, reapchild);
	(void) signal(SIGALRM, domark);
	(void) alarm(TIMERINTVL);
	(void) unlink(LogName);

	bzero((char *)&sunx, sizeof(sunx));
d269 1
a269 1
	(void) strncpy(sunx.sun_path, LogName, sizeof sunx.sun_path);
d271 2
a272 3
	if (funix < 0 || bind(funix, (struct sockaddr *) &sunx,
	    sizeof(sunx.sun_family)+sizeof(sunx.sun_len)+
	    strlen(sunx.sun_path)) < 0 ||
d287 3
d297 1
a297 1
		bzero((char *)&sin, sizeof(sin));
d325 2
a326 2
	init();
	(void) signal(SIGHUP, init);
a330 1
		errno = 0;
d332 2
a333 2
		nfds = select(20, (fd_set *) &readfds, (fd_set *) NULL,
		    (fd_set *) NULL, (struct timeval *) NULL);
d354 1
a354 1
			len = sizeof fromunix;
d356 1
a356 1
			    (struct sockaddr *) &fromunix, &len);
d364 1
a364 1
			len = sizeof frominet;
d366 1
a366 1
			    (struct sockaddr *) &frominet, &len);
a367 2
				extern char *cvthname();

d376 1
d379 2
a380 1
	(void) fprintf(stderr,
d389 1
a389 1

d394 2
a395 4
	register char *p, *q;
	register int c;
	char line[MAXLINE + 1];
	int pri;
d437 1
a437 1

d441 2
a442 5
	register char *p, *q;
	register int c;
	char line[MAXLINE + 1];
	int pri, flags;
	char *lp;
d444 2
a445 2
	(void) strcpy(line, _PATH_UNIX);
	(void) strcat(line, ": ");
d477 1
a477 1

d483 2
a484 3
	register struct filed *f;
	int fac, prilev;
	int omask, msglen;
a485 1
	time_t time();
d500 1
a500 1
	(void) time(&now);
d523 1
a523 1
			(void) close(f->f_file);
d525 1
a525 1
		(void) sigsetmask(omask);
d547 1
a547 1
			(void) strncpy(f->f_lasttime, timestamp, 15);
d568 2
a569 2
			(void) strncpy(f->f_lasttime, timestamp, 15);
			(void) strncpy(f->f_prevhost, from,
d573 1
a573 1
				(void) strcpy(f->f_prevline, msg);
d582 1
a582 1
	(void) sigsetmask(omask);
d585 1
d587 1
a587 1
	register struct filed *f;
d592 2
a593 2
	register struct iovec *v;
	register int l;
d650 1
a650 1
		    sizeof f->f_un.f_forw.f_addr) != l) {
d652 1
a652 1
			(void) close(f->f_file);
d679 1
a679 1
			(void) close(f->f_file);
d697 1
a697 1
			(void) fsync(f->f_file);
d717 1
a717 1

d719 1
a719 1
	register struct filed *f;
d723 1
a723 2
	register FILE *uf;
	register int i;
d725 3
a727 1
	char *p, *ttymsg();
d737 1
a737 1
	while (fread((char *) &ut, sizeof ut, 1, uf) == 1) {
d740 2
d743 1
a743 1
			if (p = ttymsg(iov, 6, ut.ut_line, 1)) {
d755 2
a756 1
				if (p = ttymsg(iov, 6, ut.ut_line, 1)) {
d764 1
a764 1
	(void) fclose(uf);
d769 2
a770 1
reapchild()
d774 1
a774 1
	while (wait3((int *)&status, WNOHANG, (struct rusage *) NULL) > 0)
d786 1
a786 2
	register char *p;
	extern char *inet_ntoa();
d801 1
a801 1
	if ((p = index(hp->h_name, '.')) && strcmp(p + 1, LocalDomain) == 0)
d807 2
a808 1
domark()
d810 1
a810 2
	register struct filed *f;
	time_t time();
d828 1
a828 1
	(void) alarm(TIMERINTVL);
d834 1
d838 1
a838 1
	char buf[100], *strerror();
d841 2
a842 1
		(void) sprintf(buf, "syslogd: %s: %s", type, strerror(errno));
d844 1
a844 1
		(void) sprintf(buf, "syslogd: %s", type);
d851 2
a852 1
die(sig)
d854 1
a854 1
	register struct filed *f;
d862 3
a864 3
	if (sig) {
		dprintf("syslogd: exiting on signal %d\n", sig);
		(void) sprintf(buf, "exiting on signal %d", sig);
d868 1
a868 1
	(void) unlink(LogName);
a874 1

d876 2
a877 1
init()
d879 5
a883 5
	register int i;
	register FILE *cf;
	register struct filed *f, *next, **nextp;
	register char *p;
	char cline[BUFSIZ];
d897 5
a901 5
		  case F_FILE:
		  case F_TTY:
		  case F_CONSOLE:
		  case F_FORW:
			(void) close(f->f_file);
d905 1
a905 1
		free((char *) f);
d925 1
a925 1
	while (fgets(cline, sizeof cline, cf) != NULL) {
d930 2
a931 1
		for (p = cline; isspace(*p); ++p);
d934 2
a935 1
		for (p = index(cline, '\0'); isspace(*--p););
d944 1
a944 1
	(void) fclose(cf);
d983 1
a983 1

d986 1
a986 1
	register struct filed *f;
a987 5
	register char *p;
	register char *q;
	register int i;
	char *bp;
	int pri;
d989 2
d998 1
a998 1
	bzero((char *) f, sizeof *f);
d1010 1
a1010 1
		for (bp = buf; *q && !index("\t,;", *q); )
d1015 1
a1015 1
		while (index(", ;", *q))
d1024 1
a1024 1
				(void) sprintf(ebuf,
d1032 2
a1033 2
		while (*p && !index("\t.;", *p)) {
			for (bp = buf; *p && !index("\t,;.", *p); )
d1042 1
a1042 1
					(void) sprintf(ebuf,
d1066 1
a1066 1
		(void) strcpy(f->f_un.f_forw.f_hname, ++p);
d1074 2
a1075 2
		bzero((char *) &f->f_un.f_forw.f_addr,
			 sizeof f->f_un.f_forw.f_addr);
d1078 1
a1078 1
		bcopy(hp->h_addr, (char *) &f->f_un.f_forw.f_addr.sin_addr, hp->h_length);
d1083 1
a1083 1
		(void) strcpy(f->f_un.f_fname, p);
d1105 1
a1105 1
			(void) strncpy(f->f_un.f_uname[i], p, UT_NAMESIZE);
d1123 1
a1123 1

d1125 1
a1125 1
	char *name;
d1128 2
a1129 3
	register CODE *c;
	register char *p;
	char buf[40];
d1134 7
a1140 4
	(void) strcpy(buf, name);
	for (p = buf; *p; p++)
		if (isupper(*p))
			*p = tolower(*p);
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: syslogd.c,v 1.4 1995/06/11 20:22:58 mycroft Exp $";
d187 1
d208 1
a208 1
	while ((ch = getopt(argc, argv, "df:m:p:")) != EOF)
d222 3
d267 6
a272 1
	finet = socket(AF_INET, SOCK_DGRAM, 0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

