head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.2
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.10
date	2017.03.03.20.26.23;	author bluhm;	state Exp;
branches;
next	1.9;
commitid	ACebg3jJ12vJCncK;

1.9
date	2015.10.09.16.58.25;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	5A0tNEXnHGGgWpGX;

1.8
date	2015.09.20.21.49.54;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	oo3owYTR1ZBouPUq;

1.7
date	2015.09.10.18.32.06;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	LgKbuvsrCAHwACYR;

1.6
date	2015.09.10.10.58.48;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	qmVlCJYHig4dErGJ;

1.5
date	2015.07.18.22.33.46;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	hfkOPlRIC2r9WCxe;

1.4
date	2015.07.06.16.12.16;	author millert;	state Exp;
branches;
next	1.3;
commitid	MZymOysCDJJlr2xr;

1.3
date	2015.02.20.00.56.32;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	vP1CrASY5DRsLXb7;

1.2
date	2015.01.30.14.00.55;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	9DpTxDgo9lU13OqH;

1.1
date	2015.01.18.19.37.59;	author bluhm;	state Exp;
branches;
next	;
commitid	cVnX55hA2Of6ako2;


desc
@@


1.10
log
@Internally libssl uses 16k buffer, the libevent TLS wrapper uses
4k read buffer.  This can hang ldapd(8).  Setting both to 16k
improves the situation.
report Seiya Kawashima; feedback Robert Klein; test and OK gsoares@@
@
text
@/*	$OpenBSD: evbuffer_tls.c,v 1.9 2015/10/09 16:58:25 bluhm Exp $ */

/*
 * Copyright (c) 2002-2004 Niels Provos <provos@@citi.umich.edu>
 * Copyright (c) 2014-2015 Alexander Bluhm <bluhm@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/ioctl.h>

#include <errno.h>
#include <event.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tls.h>

#include "evbuffer_tls.h"

/* prototypes */

void bufferevent_read_pressure_cb(struct evbuffer *, size_t, size_t, void *);
static void buffertls_readcb(int, short, void *);
static void buffertls_writecb(int, short, void *);
static void buffertls_handshakecb(int, short, void *);
int evtls_read(struct evbuffer *, int, int, struct tls *);
int evtls_write(struct evbuffer *, int, struct tls *);

static int
bufferevent_add(struct event *ev, int timeout)
{
	struct timeval tv, *ptv = NULL;

	if (timeout) {
		timerclear(&tv);
		tv.tv_sec = timeout;
		ptv = &tv;
	}

	return (event_add(ev, ptv));
}

static void
buffertls_readcb(int fd, short event, void *arg)
{
	struct buffertls *buftls = arg;
	struct bufferevent *bufev = buftls->bt_bufev;
	struct tls *ctx = buftls->bt_ctx;
	int res = 0;
	short what = EVBUFFER_READ;
	size_t len;
	int howmuch = -1;

	if (event == EV_TIMEOUT) {
		what |= EVBUFFER_TIMEOUT;
		goto error;
	}

	/*
	 * If we have a high watermark configured then we don't want to
	 * read more data than would make us reach the watermark.
	 */
	if (bufev->wm_read.high != 0) {
		howmuch = bufev->wm_read.high - EVBUFFER_LENGTH(bufev->input);
		/* we might have lowered the watermark, stop reading */
		if (howmuch <= 0) {
			struct evbuffer *buf = bufev->input;
			event_del(&bufev->ev_read);
			evbuffer_setcb(buf,
			    bufferevent_read_pressure_cb, bufev);
			return;
		}
	}

	res = evtls_read(bufev->input, fd, howmuch, ctx);
	switch (res) {
	case TLS_WANT_POLLIN:
		bufferevent_add(&bufev->ev_read, bufev->timeout_read);
		return;
	case TLS_WANT_POLLOUT:
		event_del(&bufev->ev_write);
		event_set(&bufev->ev_write, fd, EV_WRITE, buffertls_readcb,
		    buftls);
		bufferevent_add(&bufev->ev_write, bufev->timeout_write);
		return;
	case -1:
		what |= EVBUFFER_ERROR;
		break;
	case 0:
		what |= EVBUFFER_EOF;
		break;
	}
	if (res <= 0)
		goto error;

	event_del(&bufev->ev_write);
	event_set(&bufev->ev_write, fd, EV_WRITE, buffertls_writecb, buftls);
	if (bufev->enabled & EV_READ)
		bufferevent_add(&bufev->ev_read, bufev->timeout_read);
	if (EVBUFFER_LENGTH(bufev->output) != 0 && bufev->enabled & EV_WRITE)
		bufferevent_add(&bufev->ev_write, bufev->timeout_write);

	/* See if this callbacks meets the water marks */
	len = EVBUFFER_LENGTH(bufev->input);
	if (bufev->wm_read.low != 0 && len < bufev->wm_read.low)
		return;
	if (bufev->wm_read.high != 0 && len >= bufev->wm_read.high) {
		struct evbuffer *buf = bufev->input;
		event_del(&bufev->ev_read);

		/* Now schedule a callback for us when the buffer changes */
		evbuffer_setcb(buf, bufferevent_read_pressure_cb, bufev);
	}

	/* Invoke the user callback - must always be called last */
	if (bufev->readcb != NULL)
		(*bufev->readcb)(bufev, bufev->cbarg);
	return;

 error:
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}

static void
buffertls_writecb(int fd, short event, void *arg)
{
	struct buffertls *buftls = arg;
	struct bufferevent *bufev = buftls->bt_bufev;
	struct tls *ctx = buftls->bt_ctx;
	int res = 0;
	short what = EVBUFFER_WRITE;

	if (event == EV_TIMEOUT) {
		what |= EVBUFFER_TIMEOUT;
		goto error;
	}

	if (EVBUFFER_LENGTH(bufev->output) != 0) {
		res = evtls_write(bufev->output, fd, ctx);
		switch (res) {
		case TLS_WANT_POLLIN:
			event_del(&bufev->ev_read);
			event_set(&bufev->ev_read, fd, EV_READ,
			    buffertls_writecb, buftls);
			bufferevent_add(&bufev->ev_read, bufev->timeout_read);
			return;
		case TLS_WANT_POLLOUT:
			bufferevent_add(&bufev->ev_write, bufev->timeout_write);
			return;
		case -1:
			what |= EVBUFFER_ERROR;
			break;
		case 0:
			what |= EVBUFFER_EOF;
			break;
		}
		if (res <= 0)
			goto error;
	}

	event_del(&bufev->ev_read);
	event_set(&bufev->ev_read, fd, EV_READ, buffertls_readcb, buftls);
	if (bufev->enabled & EV_READ)
		bufferevent_add(&bufev->ev_read, bufev->timeout_read);
	if (EVBUFFER_LENGTH(bufev->output) != 0 && bufev->enabled & EV_WRITE)
		bufferevent_add(&bufev->ev_write, bufev->timeout_write);

	/*
	 * Invoke the user callback if our buffer is drained or below the
	 * low watermark.
	 */
	if (bufev->writecb != NULL &&
	    EVBUFFER_LENGTH(bufev->output) <= bufev->wm_write.low)
		(*bufev->writecb)(bufev, bufev->cbarg);

	return;

 error:
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}

static void
buffertls_handshakecb(int fd, short event, void *arg)
{
	struct buffertls *buftls = arg;
	struct bufferevent *bufev = buftls->bt_bufev;
	struct tls *ctx = buftls->bt_ctx;
	int res = 0;
	short what = EVBUFFER_HANDSHAKE;

	if (event == EV_TIMEOUT) {
		what |= EVBUFFER_TIMEOUT;
		goto error;
	}

	res = tls_handshake(ctx);
	switch (res) {
	case TLS_WANT_POLLIN:
		bufferevent_add(&bufev->ev_read, bufev->timeout_read);
		return;
	case TLS_WANT_POLLOUT:
		bufferevent_add(&bufev->ev_write, bufev->timeout_write);
		return;
	case -1:
		what |= EVBUFFER_ERROR;
		break;
	}
	if (res < 0)
		goto error;

	/* Handshake was successful, change to read and write callback. */
	event_del(&bufev->ev_read);
	event_del(&bufev->ev_write);
	event_set(&bufev->ev_read, fd, EV_READ, buffertls_readcb, buftls);
	event_set(&bufev->ev_write, fd, EV_WRITE, buffertls_writecb, buftls);
	if (bufev->enabled & EV_READ)
		bufferevent_add(&bufev->ev_read, bufev->timeout_read);
	if (EVBUFFER_LENGTH(bufev->output) != 0 && bufev->enabled & EV_WRITE)
		bufferevent_add(&bufev->ev_write, bufev->timeout_write);

	return;

 error:
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}

void
buffertls_set(struct buffertls *buftls, struct bufferevent *bufev,
    struct tls *ctx, int fd)
{
	bufferevent_setfd(bufev, fd);
	event_set(&bufev->ev_read, fd, EV_READ, buffertls_readcb, buftls);
	event_set(&bufev->ev_write, fd, EV_WRITE, buffertls_writecb, buftls);
	buftls->bt_bufev = bufev;
	buftls->bt_ctx = ctx;
}

void
buffertls_accept(struct buffertls *buftls, int fd)
{
	struct bufferevent *bufev = buftls->bt_bufev;

	event_del(&bufev->ev_read);
	event_del(&bufev->ev_write);
	event_set(&bufev->ev_read, fd, EV_READ, buffertls_handshakecb, buftls);
	event_set(&bufev->ev_write, fd, EV_WRITE, buffertls_handshakecb,
	    buftls);
	bufferevent_add(&bufev->ev_read, bufev->timeout_read);
}

void
buffertls_connect(struct buffertls *buftls, int fd)
{
	struct bufferevent *bufev = buftls->bt_bufev;

	event_del(&bufev->ev_read);
	event_del(&bufev->ev_write);
	event_set(&bufev->ev_read, fd, EV_READ, buffertls_handshakecb, buftls);
	event_set(&bufev->ev_write, fd, EV_WRITE, buffertls_handshakecb,
	    buftls);
	bufferevent_add(&bufev->ev_write, bufev->timeout_write);
}

/*
 * Reads data from a file descriptor into a buffer.
 */

#define EVBUFFER_MAX_READ	16384

int
evtls_read(struct evbuffer *buf, int fd, int howmuch, struct tls *ctx)
{
	u_char *p;
	size_t oldoff = buf->off;
	int n = EVBUFFER_MAX_READ;

	if (ioctl(fd, FIONREAD, &n) == -1 || n <= 0) {
		n = EVBUFFER_MAX_READ;
	} else if (n > EVBUFFER_MAX_READ && n > howmuch) {
		/*
		 * It's possible that a lot of data is available for
		 * reading.  We do not want to exhaust resources
		 * before the reader has a chance to do something
		 * about it.  If the reader does not tell us how much
		 * data we should read, we artifically limit it.
		 */
		if ((size_t)n > buf->totallen << 2)
			n = buf->totallen << 2;
		if (n < EVBUFFER_MAX_READ)
			n = EVBUFFER_MAX_READ;
	}
	if (howmuch < 0 || howmuch > n)
		howmuch = n;

	/* If we don't have FIONREAD, we might waste some space here */
	if (evbuffer_expand(buf, howmuch) == -1)
		return (-1);

	/* We can append new data at this point */
	p = buf->buffer + buf->off;

	n = tls_read(ctx, p, howmuch);
	if (n <= 0)
		return (n);

	buf->off += n;

	/* Tell someone about changes in this buffer */
	if (buf->off != oldoff && buf->cb != NULL)
		(*buf->cb)(buf, oldoff, buf->off, buf->cbarg);

	return (n);
}

int
evtls_write(struct evbuffer *buffer, int fd, struct tls *ctx)
{
	int n;

	n = tls_write(ctx, buffer->buffer, buffer->off);
	if (n <= 0)
		return (n);
	evbuffer_drain(buffer, n);

	return (n);
}
@


1.9
log
@If syslogd is started with -S, it accepts TLS connections to receive
encrypted messages.  The server certificates are taken from /etc/ssl
like relayd does.
OK benno@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: evbuffer_tls.c,v 1.8 2015/09/20 21:49:54 bluhm Exp $ */
d292 1
a292 1
#define EVBUFFER_MAX_READ	4096
@


1.8
log
@Misuse of libevent in TLS read and write might have caused strange
event loss in syslogd.  The ev_read and ev_write event structures
were used for both EV_READ and EV_WRITE events intermixedly.  The
correct way is to use each event for its read and write purpose and
instead switch the handler.  Then libevent is no longer confused.

When doing TLS read and a TLS_WANT_POLLOUT occures, call event_set()
for the write event to change the callback to read.  As there might
be an event scheduled on the event, call event_del() before
event_set().  After a successful TLS read, change back the write
event.  Add analog code for TLS write and handshake.

OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: evbuffer_tls.c,v 1.7 2015/09/10 18:32:06 bluhm Exp $ */
d260 13
@


1.7
log
@Convert syslogd TLS connect to use handshake callback.  The bt_hostname
can go away as the callback does not need the hostname anymore.
Call tls_handshake() until successful.  Remove the function
tls_socket() as it has a bad prefix.  Just call tls_client(),
tls_configure() and tls_connect_socket() after the TCP socket has
been created.  There is no need to wait until TCP connect has
finished.
OK beck@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: evbuffer_tls.c,v 1.6 2015/09/10 10:58:48 bluhm Exp $ */
d47 3
d102 2
a103 3
		event_set(&bufev->ev_read, fd, EV_READ, buffertls_readcb,
		    buftls);
		goto reschedule;
d105 2
a106 1
		event_set(&bufev->ev_read, fd, EV_WRITE, buffertls_readcb,
d108 2
a109 1
		goto reschedule;
a110 3
		if (errno == EAGAIN || errno == EINTR)
			goto reschedule;
		/* error case */
a113 1
		/* eof case */
d120 6
a125 2
	event_set(&bufev->ev_read, fd, EV_READ, buffertls_readcb, buftls);
	bufferevent_add(&bufev->ev_read, bufev->timeout_read);
a143 4
 reschedule:
	bufferevent_add(&bufev->ev_read, bufev->timeout_read);
	return;

d166 2
a167 1
			event_set(&bufev->ev_write, fd, EV_READ,
d169 2
a170 1
			goto reschedule;
d172 2
a173 3
			event_set(&bufev->ev_write, fd, EV_WRITE,
			    buffertls_writecb, buftls);
			goto reschedule;
a174 4
			if (errno == EAGAIN || errno == EINTR ||
			    errno == EINPROGRESS)
				goto reschedule;
			/* error case */
a177 1
			/* eof case */
d185 5
a189 2
	event_set(&bufev->ev_write, fd, EV_WRITE, buffertls_writecb, buftls);
	if (EVBUFFER_LENGTH(bufev->output) != 0)
a201 5
 reschedule:
	if (EVBUFFER_LENGTH(bufev->output) != 0)
		bufferevent_add(&bufev->ev_write, bufev->timeout_write);
	return;

d223 2
a224 3
		event_set(&bufev->ev_write, fd, EV_READ,
		    buffertls_handshakecb, buftls);
		goto reschedule;
d226 2
a227 3
		event_set(&bufev->ev_write, fd, EV_WRITE,
		    buffertls_handshakecb, buftls);
		goto reschedule;
a228 4
		if (errno == EAGAIN || errno == EINTR ||
		    errno == EINPROGRESS)
			goto reschedule;
		/* error case */
d235 4
a238 6
	/*
	 * There might be data available in the tls layer.  Try
	 * an read operation and setup the callbacks.  Call the read
	 * callback after enabling the write callback to give the
	 * read error handler a chance to disable the write event.
	 */
d240 3
a242 1
	if (EVBUFFER_LENGTH(bufev->output) != 0)
a243 1
	buffertls_readcb(fd, 0, buftls);
a246 4
 reschedule:
	bufferevent_add(&bufev->ev_write, bufev->timeout_write);
	return;

d269 1
a269 1

@


1.6
log
@Make syslogd compile again after recent libtls changes.  Adapt to
new tls_read() and tls_write() calling semantics, adapt to
TLS_WANT_POLLIN and TLS_WANT_POLLOUT renaming.
OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: evbuffer_tls.c,v 1.5 2015/07/18 22:33:46 bluhm Exp $ */
d213 1
a213 1
buffertls_connectcb(int fd, short event, void *arg)
a217 1
	const char *hostname = buftls->bt_hostname;
d219 1
a219 1
	short what = EVBUFFER_CONNECT;
d226 1
a226 1
	res = tls_connect_socket(ctx, fd, hostname);
d230 1
a230 1
		    buffertls_connectcb, buftls);
d234 1
a234 1
		    buffertls_connectcb, buftls);
d280 1
a280 1
buffertls_connect(struct buffertls *buftls, int fd, const char *hostname)
d287 2
a288 2
	buftls->bt_hostname = hostname;
	event_set(&bufev->ev_write, fd, EV_WRITE, buffertls_connectcb, buftls);
@


1.5
log
@As libtls previously did not set SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER,
syslogd had to drop messages after tls_write() returned
TLS_{READ,WRITE}_AGAIN.  Now after libtls has been fixed, remove
the workaround.  Messages are stored in the libevent write buffer
as we can safely do a realloc(3) now.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: evbuffer_tls.c,v 1.4 2015/07/06 16:12:16 millert Exp $ */
d98 1
a98 1
	case TLS_READ_AGAIN:
d102 1
a102 1
	case TLS_WRITE_AGAIN:
d165 1
a165 1
		case TLS_READ_AGAIN:
d169 1
a169 1
		case TLS_WRITE_AGAIN:
d229 1
a229 1
	case TLS_READ_AGAIN:
d233 1
a233 1
	case TLS_WRITE_AGAIN:
d303 1
a303 1
	size_t len, oldoff = buf->off;
d331 2
a332 2
	n = tls_read(ctx, p, howmuch, &len);
	if (n < 0 || len == 0)
d335 1
a335 1
	buf->off += len;
d341 1
a341 1
	return (len);
a346 1
	size_t len;
d349 2
a350 2
	n = tls_write(ctx, buffer->buffer, buffer->off, &len);
	if (n < 0 || len == 0)
d352 1
d354 1
a354 3
	evbuffer_drain(buffer, len);

	return (len);
@


1.4
log
@Remove some unneeded includes.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: evbuffer_tls.c,v 1.3 2015/02/20 00:56:32 bluhm Exp $ */
a187 1
	buftls->bt_flags &= ~BT_WRITE_AGAIN;
a203 1
	buftls->bt_flags |= BT_WRITE_AGAIN;
a277 1
	buftls->bt_flags = 0;
@


1.3
log
@When syslogd is writing over TLS, the error "SSL3_WRITE_PENDING:bad
write retry" may occur.  Unfortunately libtls tls_write() has
inherited the strange semantics regarding partial writes and buffer
movement from SSL_write().  This will be investigated after unlock,
the goal is to have the behavior of write(2) in libtls.

For now add a workaround in syslogd.  If tls_write() indicates that
it needs a read or write again, stop modifying the output buffer.
Instead drop and count the syslog messages.  After writing over TLS
was successful, continue to queue the messages.  This solution has
minimum inpact and will be improved after 5.7 release.

discussed with tedu@@ reyk@@ jsing@@;  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: evbuffer_tls.c,v 1.2 2015/01/30 14:00:55 bluhm Exp $ */
a39 1
#include <stdarg.h>
@


1.2
log
@Start TLS after the TCP connect has finished.  Call the TLS connect
callback when the connected socket is writable.  This avoids calling
a NULL error callback.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: evbuffer_tls.c,v 1.1 2015/01/18 19:37:59 bluhm Exp $ */
d189 1
d206 1
d281 1
@


1.1
log
@Implement sending syslog messages over TLS.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d290 2
a291 1
	buffertls_connectcb(fd, 0, buftls);
@

