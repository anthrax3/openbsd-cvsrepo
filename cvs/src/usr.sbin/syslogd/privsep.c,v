head	1.66;
access;
symbols
	OPENBSD_6_1:1.66.0.4
	OPENBSD_6_1_BASE:1.66
	OPENBSD_6_0:1.61.0.2
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.54.0.4
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.34.0.26
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.24
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.20
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.18
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.16
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.14
	OPENBSD_5_0:1.34.0.12
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.10
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.8
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.4
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.6
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5;
locks; strict;
comment	@ * @;


1.66
date	2016.12.30.23.21.26;	author bluhm;	state Exp;
branches;
next	1.65;
commitid	eenFpv77Suf1MCUq;

1.65
date	2016.12.27.19.16.24;	author bluhm;	state Exp;
branches;
next	1.64;
commitid	UcY5hLOJcK9FUk4A;

1.64
date	2016.10.16.22.12.50;	author bluhm;	state Exp;
branches;
next	1.63;
commitid	Upi8egpBgqWfAtF0;

1.63
date	2016.10.16.22.00.14;	author bluhm;	state Exp;
branches;
next	1.62;
commitid	ElNa2cXQB0SPdrJ2;

1.62
date	2016.10.06.13.03.47;	author bluhm;	state Exp;
branches;
next	1.61;
commitid	Topwmtp5NL4LwDP6;

1.61
date	2016.06.28.18.22.50;	author jca;	state Exp;
branches;
next	1.60;
commitid	aGTk8lgsaKgOvM0x;

1.60
date	2016.04.02.19.55.10;	author krw;	state Exp;
branches;
next	1.59;
commitid	uFCdPoth1U2KDjGH;

1.59
date	2015.10.20.12.40.19;	author bluhm;	state Exp;
branches;
next	1.58;
commitid	e1xp9jF7RiwiglZm;

1.58
date	2015.10.18.16.35.06;	author bluhm;	state Exp;
branches;
next	1.57;
commitid	UYMx3HJqDejmd4H0;

1.57
date	2015.10.16.16.10.10;	author bluhm;	state Exp;
branches;
next	1.56;
commitid	Gs3GCzUa08OWIpkp;

1.56
date	2015.10.15.20.26.47;	author bluhm;	state Exp;
branches;
next	1.55;
commitid	q4QZhB2FFsrsOMtz;

1.55
date	2015.10.09.16.58.25;	author bluhm;	state Exp;
branches;
next	1.54;
commitid	5A0tNEXnHGGgWpGX;

1.54
date	2015.07.07.17.53.04;	author bluhm;	state Exp;
branches;
next	1.53;
commitid	Ygwih79fAl6T0IdE;

1.53
date	2015.07.06.16.12.16;	author millert;	state Exp;
branches;
next	1.52;
commitid	MZymOysCDJJlr2xr;

1.52
date	2015.06.30.12.03.32;	author bluhm;	state Exp;
branches;
next	1.51;
commitid	Zc7oLXwqGtUJdHot;

1.51
date	2015.01.19.16.40.49;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	ye1aJeTlbYgpyeiK;

1.50
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	Uu5nFG3wCl0LACBb;

1.49
date	2014.12.31.13.55.57;	author bluhm;	state Exp;
branches;
next	1.48;
commitid	NVMWLaTDuO6woUW6;

1.48
date	2014.10.05.18.14.01;	author bluhm;	state Exp;
branches;
next	1.47;
commitid	F9a5EGI6b8V6fn1r;

1.47
date	2014.10.03.21.55.22;	author bluhm;	state Exp;
branches;
next	1.46;
commitid	iEB47IzucBg1qJLP;

1.46
date	2014.09.27.11.28.37;	author bluhm;	state Exp;
branches;
next	1.45;
commitid	l9YBaEBKt3Vrkmsx;

1.45
date	2014.09.10.13.16.20;	author doug;	state Exp;
branches;
next	1.44;
commitid	FKg512MOeVlGwll8;

1.44
date	2014.09.08.00.43.42;	author doug;	state Exp;
branches;
next	1.43;
commitid	gbKO3ZNYXDnVBGv2;

1.43
date	2014.08.25.20.19.14;	author bluhm;	state Exp;
branches;
next	1.42;
commitid	NnQ57p5mmEfc1IdV;

1.42
date	2014.08.25.18.19.18;	author bluhm;	state Exp;
branches;
next	1.41;
commitid	5y3omv4nlYdpVnPL;

1.41
date	2014.08.25.18.05.30;	author bluhm;	state Exp;
branches;
next	1.40;
commitid	V6d93DJvIyTMzMa3;

1.40
date	2014.08.21.17.00.34;	author bluhm;	state Exp;
branches;
next	1.39;
commitid	FklVDocMUu0Wjxix;

1.39
date	2014.08.21.00.04.58;	author bluhm;	state Exp;
branches;
next	1.38;
commitid	OdNcvuzm1SE1FBI6;

1.38
date	2014.08.20.20.10.17;	author bluhm;	state Exp;
branches;
next	1.37;
commitid	yQfrceogzjafLaIV;

1.37
date	2014.08.20.19.16.27;	author bluhm;	state Exp;
branches;
next	1.36;
commitid	fM55SSGsY8U1QNTd;

1.36
date	2014.08.19.00.53.01;	author bluhm;	state Exp;
branches;
next	1.35;
commitid	022EZGImFZzV7mh4;

1.35
date	2014.08.19.00.28.48;	author bluhm;	state Exp;
branches;
next	1.34;
commitid	ev1RTYeI16eoJFNj;

1.34
date	2008.11.23.04.29.42;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2008.09.29.18.41.56;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2008.03.16.16.55.29;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2008.03.16.15.44.18;	author mpf;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.15.05.18.32;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.20.11.24.32;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.09.14.42.27;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.02.16.50.11;	author moritz;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.06.23.20.44;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.23.20.12.28;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.03.05.44.35;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.14.23.41.29;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.14.23.26.41;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.09.16.22.04;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.03.23.40.44;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.03.05.32.18;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.09.20.13.25;	author canacar;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.02.21.44.50;	author avsm;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.14.19.17.05;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.06.19.42.38;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.26.11.04.15;	author avsm;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.04.08.28.49;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.29.22.09.36;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.29.22.08.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.29.22.05.10;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.26.18.21.49;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.24.21.21.27;	author canacar;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.22.19.37.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.24.23.35.45;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.15.23.13.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.01.14.04.35;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.31.21.28.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.31.18.25.58;	author avsm;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.31.18.20.07;	author avsm;	state Exp;
branches;
next	;


desc
@@


1.66
log
@When syslogd received a SIGHUP during startup, it died instead of
reloading its config.  This could happen when multiple signals were
sent during a short interval.  So block SIGHUP until signal handlers
are installed.
OK deraadt@@ jca@@
@
text
@/*	$OpenBSD: privsep.c,v 1.65 2016/12/27 19:16:24 bluhm Exp $	*/

/*
 * Copyright (c) 2003 Anil Madhavapeddy <anil@@recoil.org>
 * Copyright (c) 2016 Alexander Bluhm <bluhm@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <utmp.h>

#include "syslogd.h"

/*
 * syslogd can only go forward in these states; each state should represent
 * less privilege.   After STATE_INIT, the child is allowed to parse its
 * config file once, and communicate the information regarding what logfiles
 * it needs access to back to the parent.  When that is done, it sends a
 * message to the priv parent revoking this access, moving to STATE_RUNNING.
 * In this state, any log-files not in the access list are rejected.
 *
 * This allows a HUP signal to the child to reopen its log files, and
 * the config file to be parsed if it hasn't been changed (this is still
 * useful to force resolution of remote syslog servers again).
 * If the config file has been modified, then the child dies, and
 * the priv parent restarts itself.
 */
enum priv_state {
	STATE_INIT,		/* just started up */
	STATE_CONFIG,		/* parsing config file for first time */
	STATE_RUNNING,		/* running and accepting network traffic */
	STATE_QUIT		/* shutting down */
};

enum cmd_types {
	PRIV_OPEN_TTY,		/* open terminal or console device */
	PRIV_OPEN_LOG,		/* open logfile for appending */
	PRIV_OPEN_PIPE,		/* fork & exec child that gets logs on stdin */
	PRIV_OPEN_UTMP,		/* open utmp for reading only */
	PRIV_OPEN_CONFIG,	/* open config file for reading only */
	PRIV_CONFIG_MODIFIED,	/* check if config file has been modified */
	PRIV_GETADDRINFO,	/* resolve host/service names */
	PRIV_GETNAMEINFO,	/* resolve numeric address into hostname */
	PRIV_DONE_CONFIG_PARSE	/* signal that initial config parse is done */
};

static int priv_fd = -1;
static volatile pid_t child_pid = -1;
static volatile sig_atomic_t cur_state = STATE_INIT;

/* Queue for the allowed logfiles */
struct logname {
	char path[PATH_MAX];
	TAILQ_ENTRY(logname) next;
};
static TAILQ_HEAD(, logname) lognames;

static void check_log_name(char *, size_t);
static int open_file(char *);
static int open_pipe(char *);
static void check_tty_name(char *, size_t);
static void increase_state(int);
static void sig_pass_to_chld(int);
static void sig_got_chld(int);
static void must_read(int, void *, size_t);
static void must_write(int, void *, size_t);
static int  may_read(int, void *, size_t);

void
priv_init(int lockfd, int nullfd, int argc, char *argv[])
{
	int i, socks[2];
	struct passwd *pw;
	char *execpath, childnum[11], **privargv;

	/* Create sockets */
	if (socketpair(AF_LOCAL, SOCK_STREAM, PF_UNSPEC, socks) == -1)
		err(1, "socketpair() failed");

	pw = getpwnam("_syslogd");
	if (pw == NULL)
		errx(1, "unknown user _syslogd");

	child_pid = fork();
	if (child_pid < 0)
		err(1, "fork() failed");

	if (!child_pid) {
		/* Child - drop privileges and return */
		if (chroot(pw->pw_dir) != 0)
			err(1, "chroot %s", pw->pw_dir);
		if (chdir("/") != 0)
			err(1, "chdir %s", pw->pw_dir);

		if (setgroups(1, &pw->pw_gid) == -1)
			err(1, "setgroups() failed");
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
			err(1, "setresgid() failed");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
			err(1, "setresuid() failed");
		close(socks[0]);
		priv_fd = socks[1];
		return;
	}
	close(socks[1]);

	if (strchr(argv[0], '/') == NULL)
		execpath = argv[0];
	else if ((execpath = realpath(argv[0], NULL)) == NULL)
		err(1, "realpath %s", argv[0]);
	if (chdir("/") != 0)
		err(1, "chdir /");

	if (!Debug) {
		close(lockfd);
		dup2(nullfd, STDIN_FILENO);
		dup2(nullfd, STDOUT_FILENO);
		dup2(nullfd, STDERR_FILENO);
	}
	if (nullfd > 2)
		close(nullfd);

	if (dup3(socks[0], 3, 0) == -1)
		err(1, "dup3 priv sock failed");
	if (closefrom(4) == -1)
		err(1, "closefrom 4 failed");

	snprintf(childnum, sizeof(childnum), "%d", child_pid);
	if ((privargv = reallocarray(NULL, argc + 3, sizeof(char *))) == NULL)
		err(1, "alloc priv argv failed");
	privargv[0] = execpath;
	for (i = 1; i < argc; i++)
		privargv[i] = argv[i];
	privargv[i++] = "-P";
	privargv[i++] = childnum;
	privargv[i++] = NULL;
	execvp(privargv[0], privargv);
	err(1, "exec priv '%s' failed", privargv[0]);
}

__dead void
priv_exec(char *conf, int numeric, int child, int argc, char *argv[])
{
	int i, fd, sock, cmd, addr_len, result, restart;
	size_t path_len, protoname_len, hostname_len, servname_len;
	char path[PATH_MAX], protoname[5];
	char hostname[NI_MAXHOST], servname[NI_MAXSERV];
	struct sockaddr_storage addr;
	struct stat cf_info, cf_stat;
	struct addrinfo hints, *res0;
	struct sigaction sa;
	sigset_t sigmask;

	if (pledge("stdio rpath wpath cpath dns getpw sendfd id proc exec",
	    NULL) == -1)
		err(1, "pledge priv");

	if (argc <= 2 || strcmp("-P", argv[argc - 2]) != 0)
		errx(1, "exec without priv");
	argv[argc -= 2] = NULL;

	sock = 3;
	closefrom(4);

	child_pid = child;

	memset(&sa, 0, sizeof(sa));
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	for (i = 1; i < _NSIG; i++)
		sigaction(i, &sa, NULL);

	/* Pass TERM/HUP/INT/QUIT through to child, and accept CHLD */
	sa.sa_handler = sig_pass_to_chld;
	sigaction(SIGTERM, &sa, NULL);
	sigaction(SIGHUP, &sa, NULL);
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGQUIT, &sa, NULL);
	sa.sa_handler = sig_got_chld;
	sa.sa_flags |= SA_NOCLDSTOP;
	sigaction(SIGCHLD, &sa, NULL);

	setproctitle("[priv]");
	logdebug("[priv]: fork+exec done\n");

	sigemptyset(&sigmask);
	if (sigprocmask(SIG_SETMASK, &sigmask, NULL) == -1)
		err(1, "sigprocmask priv");

	if (stat(conf, &cf_info) < 0)
		err(1, "stat config file failed");

	TAILQ_INIT(&lognames);
	increase_state(STATE_CONFIG);
	restart = 0;

	while (cur_state < STATE_QUIT) {
		if (may_read(sock, &cmd, sizeof(int)))
			break;
		switch (cmd) {
		case PRIV_OPEN_TTY:
			logdebug("[priv]: msg PRIV_OPEN_TTY received\n");
			/* Expecting: length, path */
			must_read(sock, &path_len, sizeof(size_t));
			if (path_len == 0 || path_len > sizeof(path))
				_exit(1);
			must_read(sock, &path, path_len);
			path[path_len - 1] = '\0';
			check_tty_name(path, sizeof(path));
			fd = open(path, O_WRONLY|O_NONBLOCK, 0);
			send_fd(sock, fd);
			if (fd < 0)
				warnx("priv_open_tty failed");
			else
				close(fd);
			break;

		case PRIV_OPEN_LOG:
		case PRIV_OPEN_PIPE:
			logdebug("[priv]: msg PRIV_OPEN_%s received\n",
			    cmd == PRIV_OPEN_PIPE ? "PIPE" : "LOG");
			/* Expecting: length, path */
			must_read(sock, &path_len, sizeof(size_t));
			if (path_len == 0 || path_len > sizeof(path))
				_exit(1);
			must_read(sock, &path, path_len);
			path[path_len - 1] = '\0';
			check_log_name(path, sizeof(path));

			if (cmd == PRIV_OPEN_LOG)
				fd = open_file(path);
			else if (cmd == PRIV_OPEN_PIPE)
				fd = open_pipe(path);
			else
				errx(1, "invalid cmd");

			send_fd(sock, fd);
			if (fd < 0)
				warnx("priv_open_log failed");
			else
				close(fd);
			break;

		case PRIV_OPEN_UTMP:
			logdebug("[priv]: msg PRIV_OPEN_UTMP received\n");
			fd = open(_PATH_UTMP, O_RDONLY|O_NONBLOCK, 0);
			send_fd(sock, fd);
			if (fd < 0)
				warnx("priv_open_utmp failed");
			else
				close(fd);
			break;

		case PRIV_OPEN_CONFIG:
			logdebug("[priv]: msg PRIV_OPEN_CONFIG received\n");
			stat(conf, &cf_info);
			fd = open(conf, O_RDONLY|O_NONBLOCK, 0);
			send_fd(sock, fd);
			if (fd < 0)
				warnx("priv_open_config failed");
			else
				close(fd);
			break;

		case PRIV_CONFIG_MODIFIED:
			logdebug("[priv]: msg PRIV_CONFIG_MODIFIED received\n");
			if (stat(conf, &cf_stat) < 0 ||
			    timespeccmp(&cf_info.st_mtimespec,
			    &cf_stat.st_mtimespec, <) ||
			    cf_info.st_size != cf_stat.st_size) {
				logdebug("config file modified: restarting\n");
				restart = result = 1;
				must_write(sock, &result, sizeof(int));
			} else {
				result = 0;
				must_write(sock, &result, sizeof(int));
			}
			break;

		case PRIV_DONE_CONFIG_PARSE:
			logdebug("[priv]: msg PRIV_DONE_CONFIG_PARSE "
			    "received\n");
			increase_state(STATE_RUNNING);
			break;

		case PRIV_GETADDRINFO:
			logdebug("[priv]: msg PRIV_GETADDRINFO received\n");
			/* Expecting: len, proto, len, host, len, serv */
			must_read(sock, &protoname_len, sizeof(size_t));
			if (protoname_len == 0 ||
			    protoname_len > sizeof(protoname))
				_exit(1);
			must_read(sock, &protoname, protoname_len);
			protoname[protoname_len - 1] = '\0';

			must_read(sock, &hostname_len, sizeof(size_t));
			if (hostname_len == 0 ||
			    hostname_len > sizeof(hostname))
				_exit(1);
			must_read(sock, &hostname, hostname_len);
			hostname[hostname_len - 1] = '\0';

			must_read(sock, &servname_len, sizeof(size_t));
			if (servname_len == 0 ||
			    servname_len > sizeof(servname))
				_exit(1);
			must_read(sock, &servname, servname_len);
			servname[servname_len - 1] = '\0';

			memset(&hints, 0, sizeof(hints));
			switch (strlen(protoname)) {
			case 3:
				hints.ai_family = AF_UNSPEC;
				break;
			case 4:
				switch (protoname[3]) {
				case '4':
					hints.ai_family = AF_INET;
					break;
				case '6':
					hints.ai_family = AF_INET6;
					break;
				default:
					errx(1, "bad ip version %s", protoname);
				}
				break;
			default:
				errx(1, "bad protocol length %s", protoname);
			}
			if (strncmp(protoname, "udp", 3) == 0) {
				hints.ai_socktype = SOCK_DGRAM;
				hints.ai_protocol = IPPROTO_UDP;
			} else if (strncmp(protoname, "tcp", 3) == 0) {
				hints.ai_socktype = SOCK_STREAM;
				hints.ai_protocol = IPPROTO_TCP;
			} else {
				errx(1, "unknown protocol %s", protoname);
			}
			i = getaddrinfo(hostname, servname, &hints, &res0);
			if (i != 0 || res0 == NULL) {
				addr_len = 0;
				must_write(sock, &addr_len, sizeof(int));
			} else {
				/* Just send the first address */
				i = res0->ai_addrlen;
				must_write(sock, &i, sizeof(int));
				must_write(sock, res0->ai_addr, i);
				freeaddrinfo(res0);
			}
			break;

		case PRIV_GETNAMEINFO:
			logdebug("[priv]: msg PRIV_GETNAMEINFO received\n");
			if (numeric)
				errx(1, "rejected attempt to getnameinfo");
			/* Expecting: length, sockaddr */
			must_read(sock, &addr_len, sizeof(int));
			if (addr_len <= 0 || (size_t)addr_len > sizeof(addr))
				_exit(1);
			must_read(sock, &addr, addr_len);
			if (getnameinfo((struct sockaddr *)&addr, addr_len,
			    hostname, sizeof(hostname), NULL, 0,
			    NI_NOFQDN|NI_NAMEREQD|NI_DGRAM) != 0) {
				addr_len = 0;
				must_write(sock, &addr_len, sizeof(int));
			} else {
				addr_len = strlen(hostname) + 1;
				must_write(sock, &addr_len, sizeof(int));
				must_write(sock, hostname, addr_len);
			}
			break;
		default:
			errx(1, "unknown command %d", cmd);
			break;
		}
	}

	close(sock);

	/* Unlink any domain sockets that have been opened */
	for (i = 0; i < nunix; i++)
		(void)unlink(path_unix[i]);
	if (path_ctlsock != NULL)
		(void)unlink(path_ctlsock);

	if (restart) {
		int status;

		waitpid(child_pid, &status, 0);
		sigemptyset(&sigmask);
		sigaddset(&sigmask, SIGHUP);
		if (sigprocmask(SIG_SETMASK, &sigmask, NULL) == -1)
			err(1, "sigprocmask exec");
		execvp(argv[0], argv);
		err(1, "exec restart '%s' failed", argv[0]);
	}
	unlink(_PATH_LOGPID);
	exit(0);
}

static int
open_file(char *path)
{
	/* must not start with | */
	if (path[0] == '|')
		return (-1);

	return (open(path, O_WRONLY|O_APPEND|O_NONBLOCK, 0));
}

static int
open_pipe(char *cmd)
{
	char *argp[] = {"sh", "-c", NULL, NULL};
	struct passwd *pw;
	int fd[2];
	int bsize, flags;
	pid_t pid;

	/* skip over leading | and whitespace */
	if (cmd[0] != '|')
		return (-1);
	for (cmd++; *cmd && *cmd == ' '; cmd++)
		; /* nothing */
	if (!*cmd)
		return (-1);

	argp[2] = cmd;

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, fd) == -1) {
		warnx("open_pipe");
		return (-1);
	}

	/* make the fd on syslogd's side nonblocking */
	if ((flags = fcntl(fd[1], F_GETFL)) == -1) {
		warnx("fcntl");
		return (-1);
	}
	flags |= O_NONBLOCK;
	if ((flags = fcntl(fd[1], F_SETFL, flags)) == -1) {
		warnx("fcntl");
		return (-1);
	}

	switch (pid = fork()) {
	case -1:
		warnx("fork error");
		return (-1);
	case 0:
		break;
	default:
		close(fd[0]);
		return (fd[1]);
	}

	close(fd[1]);

	/* grow receive buffer */
	bsize = 65535;
	while (bsize > 0 && setsockopt(fd[0], SOL_SOCKET, SO_RCVBUF,
	    &bsize, sizeof(bsize)) == -1)
		bsize /= 2;

	if ((pw = getpwnam("_syslogd")) == NULL)
		errx(1, "unknown user _syslogd");
	if (setgroups(1, &pw->pw_gid) == -1 ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1 ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
		err(1, "failure dropping privs");
	endpwent();

	if (dup2(fd[0], STDIN_FILENO) == -1)
		err(1, "dup2 failed");
	if (execv("/bin/sh", argp) == -1)
		err(1, "execv %s", cmd);
	/* NOTREACHED */
	return (-1);
}

/* Check that the terminal device is ok, and if not, rewrite to /dev/null.
 * Either /dev/console or /dev/tty* are allowed.
 */
static void
check_tty_name(char *tty, size_t ttysize)
{
	const char ttypre[] = "/dev/tty";
	char *p;

	/* Any path containing '..' is invalid.  */
	for (p = tty; p + 1 < tty + ttysize && *p; p++)
		if (*p == '.' && *(p + 1) == '.')
			goto bad_path;

	if (strcmp(_PATH_CONSOLE, tty) && strncmp(tty, ttypre, strlen(ttypre)))
		goto bad_path;
	return;

bad_path:
	warnx ("%s: invalid attempt to open %s: rewriting to /dev/null",
	    "check_tty_name", tty);
	strlcpy(tty, "/dev/null", ttysize);
}

/* If we are in the initial configuration state, accept a logname and add
 * it to the list of acceptable logfiles.  Otherwise, check against this list
 * and rewrite to /dev/null if it's a bad path.
 */
static void
check_log_name(char *lognam, size_t logsize)
{
	struct logname *lg;
	char *p;

	/* Any path containing '..' is invalid.  */
	for (p = lognam; p + 1 < lognam + logsize && *p; p++)
		if (*p == '.' && *(p + 1) == '.')
			goto bad_path;

	switch (cur_state) {
	case STATE_CONFIG:
		lg = malloc(sizeof(struct logname));
		if (!lg)
			err(1, "check_log_name() malloc");
		strlcpy(lg->path, lognam, PATH_MAX);
		TAILQ_INSERT_TAIL(&lognames, lg, next);
		break;
	case STATE_RUNNING:
		TAILQ_FOREACH(lg, &lognames, next)
			if (!strcmp(lg->path, lognam))
				return;
		goto bad_path;
		break;
	default:
		/* Any other state should just refuse the request */
		goto bad_path;
		break;
	}
	return;

bad_path:
	warnx("%s: invalid attempt to open %s: rewriting to /dev/null",
	    "check_log_name", lognam);
	strlcpy(lognam, "/dev/null", logsize);
}

/* Crank our state into less permissive modes */
static void
increase_state(int state)
{
	if (state <= cur_state)
		errx(1, "attempt to decrease or match current state");
	if (state < STATE_INIT || state > STATE_QUIT)
		errx(1, "attempt to switch to invalid state");
	cur_state = state;
}

/* Open console or a terminal device for writing */
int
priv_open_tty(const char *tty)
{
	char path[PATH_MAX];
	int cmd, fd;
	size_t path_len;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	if (strlcpy(path, tty, sizeof path) >= sizeof(path))
		return -1;
	path_len = strlen(path) + 1;

	cmd = PRIV_OPEN_TTY;
	must_write(priv_fd, &cmd, sizeof(int));
	must_write(priv_fd, &path_len, sizeof(size_t));
	must_write(priv_fd, path, path_len);
	fd = receive_fd(priv_fd);
	return fd;
}

/* Open log-file */
int
priv_open_log(const char *lognam)
{
	char path[PATH_MAX];
	int cmd, fd;
	size_t path_len;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged child", __func__);

	if (strlcpy(path, lognam, sizeof path) >= sizeof(path))
		return -1;
	path_len = strlen(path) + 1;

	if (lognam[0] == '|')
		cmd = PRIV_OPEN_PIPE;
	else
		cmd = PRIV_OPEN_LOG;
	must_write(priv_fd, &cmd, sizeof(int));
	must_write(priv_fd, &path_len, sizeof(size_t));
	must_write(priv_fd, path, path_len);
	fd = receive_fd(priv_fd);
	return fd;
}

/* Open utmp for reading */
FILE *
priv_open_utmp(void)
{
	int cmd, fd;
	FILE *fp;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_OPEN_UTMP;
	must_write(priv_fd, &cmd, sizeof(int));
	fd = receive_fd(priv_fd);
	if (fd < 0)
		return NULL;

	fp = fdopen(fd, "r");
	if (!fp) {
		warn("priv_open_utmp: fdopen() failed");
		close(fd);
		return NULL;
	}

	return fp;
}

/* Open syslog config file for reading */
FILE *
priv_open_config(void)
{
	int cmd, fd;
	FILE *fp;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_OPEN_CONFIG;
	must_write(priv_fd, &cmd, sizeof(int));
	fd = receive_fd(priv_fd);
	if (fd < 0)
		return NULL;

	fp = fdopen(fd, "r");
	if (!fp) {
		warn("priv_open_config: fdopen() failed");
		close(fd);
		return NULL;
	}

	return fp;
}

/* Ask if config file has been modified since last attempt to read it */
int
priv_config_modified(void)
{
	int cmd, res;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_CONFIG_MODIFIED;
	must_write(priv_fd, &cmd, sizeof(int));

	/* Expect back integer signalling 1 for modification */
	must_read(priv_fd, &res, sizeof(int));
	return res;
}

/* Child can signal that its initial parsing is done, so that parent
 * can revoke further logfile permissions.  This call only works once. */
void
priv_config_parse_done(void)
{
	int cmd;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_DONE_CONFIG_PARSE;
	must_write(priv_fd, &cmd, sizeof(int));
}

/* Name/service to address translation.  Response is placed into addr.
 * Return 0 for success or < 0 for error like getaddrinfo(3) */
int
priv_getaddrinfo(char *proto, char *host, char *serv, struct sockaddr *addr,
    size_t addr_len)
{
	char protocpy[5], hostcpy[NI_MAXHOST], servcpy[NI_MAXSERV];
	int cmd, ret_len;
	size_t protoname_len, hostname_len, servname_len;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	if (strlcpy(protocpy, proto, sizeof(protocpy)) >= sizeof(protocpy))
		errx(1, "%s: overflow attempt in protoname", __func__);
	protoname_len = strlen(protocpy) + 1;
	if (strlcpy(hostcpy, host, sizeof(hostcpy)) >= sizeof(hostcpy))
		errx(1, "%s: overflow attempt in hostname", __func__);
	hostname_len = strlen(hostcpy) + 1;
	if (strlcpy(servcpy, serv, sizeof(servcpy)) >= sizeof(servcpy))
		errx(1, "%s: overflow attempt in servname", __func__);
	servname_len = strlen(servcpy) + 1;

	cmd = PRIV_GETADDRINFO;
	must_write(priv_fd, &cmd, sizeof(int));
	must_write(priv_fd, &protoname_len, sizeof(size_t));
	must_write(priv_fd, protocpy, protoname_len);
	must_write(priv_fd, &hostname_len, sizeof(size_t));
	must_write(priv_fd, hostcpy, hostname_len);
	must_write(priv_fd, &servname_len, sizeof(size_t));
	must_write(priv_fd, servcpy, servname_len);

	/* Expect back an integer size, and then a string of that length */
	must_read(priv_fd, &ret_len, sizeof(int));

	/* Check there was no error (indicated by a return of 0) */
	if (!ret_len)
		return (-1);

	/* Make sure we aren't overflowing the passed in buffer */
	if (ret_len < 0 || (size_t)ret_len > addr_len)
		errx(1, "%s: overflow attempt in return", __func__);

	/* Read the resolved address and make sure we got all of it */
	memset(addr, '\0', addr_len);
	must_read(priv_fd, addr, ret_len);

	return (0);
}

/* Reverse address resolution; response is placed into host.
 * Return 0 for success or < 0 for error like getnameinfo(3) */
int
priv_getnameinfo(struct sockaddr *sa, socklen_t salen, char *host,
    size_t hostlen)
{
	int cmd, ret_len;

	if (priv_fd < 0)
		errx(1, "%s called from privileged portion", __func__);

	cmd = PRIV_GETNAMEINFO;
	must_write(priv_fd, &cmd, sizeof(int));
	must_write(priv_fd, &salen, sizeof(int));
	must_write(priv_fd, sa, salen);

	/* Expect back an integer size, and then a string of that length */
	must_read(priv_fd, &ret_len, sizeof(int));

	/* Check there was no error (indicated by a return of 0) */
	if (!ret_len)
		return (-1);

	/* Check we don't overflow the passed in buffer */
	if (ret_len < 0 || (size_t)ret_len > hostlen)
		errx(1, "%s: overflow attempt in return", __func__);

	/* Read the resolved hostname */
	must_read(priv_fd, host, ret_len);
	return (0);
}

/* Pass the signal through to child */
static void
sig_pass_to_chld(int sig)
{
	int save_errno = errno;

	if (child_pid != -1)
		kill(child_pid, sig);
	errno = save_errno;
}

/* When child dies, move into the shutdown state */
/* ARGSUSED */
static void
sig_got_chld(int sig)
{
	int save_errno = errno;
	pid_t	pid;

	do {
		pid = waitpid(WAIT_ANY, NULL, WNOHANG);
		if (pid == child_pid && cur_state < STATE_QUIT)
			cur_state = STATE_QUIT;
	} while (pid > 0 || (pid == -1 && errno == EINTR));
	errno = save_errno;
}

/* Read all data or return 1 for error.  */
static int
may_read(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res;
	size_t pos = 0;

	while (n > pos) {
		res = read(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
		case 0:
			return (1);
		default:
			pos += res;
		}
	}
	return (0);
}

/* Read data with the assertion that it all must come through, or
 * else abort the process.  Based on atomicio() from openssh. */
static void
must_read(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res;
	size_t pos = 0;

	while (n > pos) {
		res = read(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
		case 0:
			_exit(1);
		default:
			pos += res;
		}
	}
}

/* Write data with the assertion that it all has to be written, or
 * else abort the process.  Based on atomicio() from openssh. */
static void
must_write(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res;
	size_t pos = 0;

	while (n > pos) {
		res = write(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
		case 0:
			_exit(1);
		default:
			pos += res;
		}
	}
}
@


1.65
log
@If syslogd was started with a relative path, the program could not
re-exec itself.  This exec is done during startup of the privsep
parent or when syslogd restarts after a SIGHUP.  Convert a relative
path in argv[0] to an absolute one with realpath(3) before chdir(2).
Do all the path handling in priv_init().
suggested by millert@@; OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.64 2016/10/16 22:12:50 bluhm Exp $	*/
d178 1
d213 4
d417 4
@


1.64
log
@Fix trailing whitespace and shorten long lines.
No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.63 2016/10/16 22:00:14 bluhm Exp $	*/
d100 1
a100 1
	char childnum[11], **privargv;
d117 1
a117 1
			err(1, "unable to chroot");
d119 1
a119 1
			err(1, "unable to chdir");
d133 7
d157 2
a158 1
	for (i = 0; i < argc; i++)
@


1.63
log
@Use closefrom(4) in privsep parent and avoid some global file
descriptor variables in syslogd(8) this way.
OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.62 2016/10/06 13:03:47 bluhm Exp $	*/
d70 1
a70 1
	PRIV_DONE_CONFIG_PARSE	/* signal that the initial config parse is done */
@


1.62
log
@Do an exec on itself in the privileged syslogd(8) parent process
to reshuffle its memory layout.
Input rzalamena@@; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.61 2016/06/28 18:22:50 jca Exp $	*/
a141 23
	/* Close descriptors that only the unpriv child needs */
	if (fd_ctlconn != -1)
		close(fd_ctlconn);
	if (fd_ctlsock != -1)
		close(fd_ctlsock);
	if (fd_klog != -1)
		close(fd_klog);
	if (fd_sendsys != -1)
		close(fd_sendsys);
	if (fd_udp != -1)
		close(fd_udp);
	if (fd_udp6 != -1)
		close(fd_udp6);
	if (fd_bind != -1)
		close(fd_bind);
	if (fd_listen != -1)
		close(fd_listen);
	if (fd_tls != -1)
		close(fd_tls);
	for (i = 0; i < nunix; i++)
		if (fd_unix[i] != -1)
			close(fd_unix[i]);

d144 3
@


1.61
log
@whitespace nit
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.60 2016/04/02 19:55:10 krw Exp $	*/
d5 1
a74 3
static char config_file[PATH_MAX];
static struct stat cf_info;
static int allow_getnameinfo = 0;
d95 2
a96 2
int
priv_init(char *conf, int numeric, int lockfd, int nullfd, char *argv[])
d98 1
a98 6
	int i, fd, socks[2], cmd, addr_len, result, restart;
	size_t path_len, protoname_len, hostname_len, servname_len;
	char path[PATH_MAX], protoname[5];
	char hostname[NI_MAXHOST], servname[NI_MAXSERV];
	struct sockaddr_storage addr;
	struct stat cf_stat;
d100 1
a100 9
	struct addrinfo hints, *res0;
	struct sigaction sa;

	memset(&sa, 0, sizeof(sa));
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	for (i = 1; i < _NSIG; i++)
		sigaction(i, &sa, NULL);
d129 1
a129 1
		return 0;
d131 1
a131 4

	if (pledge("stdio rpath wpath cpath dns getpw sendfd id proc exec",
	    NULL) == -1)
		err(1, "pledge priv");
a141 14
	/* Father */
	/* Pass TERM/HUP/INT/QUIT through to child, and accept CHLD */
	sa.sa_handler = sig_pass_to_chld;
	sigaction(SIGTERM, &sa, NULL);
	sigaction(SIGHUP, &sa, NULL);
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGQUIT, &sa, NULL);
	sa.sa_handler = sig_got_chld;
	sa.sa_flags |= SA_NOCLDSTOP;
	sigaction(SIGCHLD, &sa, NULL);

	setproctitle("[priv]");
	close(socks[1]);

d165 13
a177 3
	/* Save the config file specified by the child process */
	if (strlcpy(config_file, conf, sizeof config_file) >= sizeof(config_file))
		errx(1, "config_file truncation");
d179 46
a224 1
	if (stat(config_file, &cf_info) < 0)
a226 6
	/* Save whether or not the child can have access to getnameinfo(3) */
	if (numeric > 0)
		allow_getnameinfo = 0;
	else
		allow_getnameinfo = 1;

d232 1
a232 1
		if (may_read(socks[0], &cmd, sizeof(int)))
d238 1
a238 1
			must_read(socks[0], &path_len, sizeof(size_t));
d241 1
a241 1
			must_read(socks[0], &path, path_len);
d245 1
a245 1
			send_fd(socks[0], fd);
d257 1
a257 1
			must_read(socks[0], &path_len, sizeof(size_t));
d260 1
a260 1
			must_read(socks[0], &path, path_len);
d271 1
a271 1
			send_fd(socks[0], fd);
d281 1
a281 1
			send_fd(socks[0], fd);
d290 3
a292 3
			stat(config_file, &cf_info);
			fd = open(config_file, O_RDONLY|O_NONBLOCK, 0);
			send_fd(socks[0], fd);
d301 1
a301 1
			if (stat(config_file, &cf_stat) < 0 ||
d307 1
a307 1
				must_write(socks[0], &result, sizeof(int));
d310 1
a310 1
				must_write(socks[0], &result, sizeof(int));
d323 1
a323 1
			must_read(socks[0], &protoname_len, sizeof(size_t));
d327 1
a327 1
			must_read(socks[0], &protoname, protoname_len);
d330 1
a330 1
			must_read(socks[0], &hostname_len, sizeof(size_t));
d334 1
a334 1
			must_read(socks[0], &hostname, hostname_len);
d337 1
a337 1
			must_read(socks[0], &servname_len, sizeof(size_t));
d341 1
a341 1
			must_read(socks[0], &servname, servname_len);
d376 1
a376 1
				must_write(socks[0], &addr_len, sizeof(int));
d380 2
a381 2
				must_write(socks[0], &i, sizeof(int));
				must_write(socks[0], res0->ai_addr, i);
d388 1
a388 1
			if (!allow_getnameinfo)
d391 1
a391 1
			must_read(socks[0], &addr_len, sizeof(int));
d394 1
a394 1
			must_read(socks[0], &addr, addr_len);
d399 1
a399 1
				must_write(socks[0], &addr_len, sizeof(int));
d402 2
a403 2
				must_write(socks[0], &addr_len, sizeof(int));
				must_write(socks[0], hostname, addr_len);
d412 1
a412 1
	close(socks[0]);
d416 2
a417 3
		if (fd_unix[i] != -1)
			(void)unlink(path_unix[i]);
	if (path_ctlsock != NULL && fd_ctlsock != -1)
d421 1
a421 1
		int r;
d423 1
a423 1
		wait(&r);
d425 1
d428 1
a428 1
	_exit(0);
@


1.60
log
@Eliminate superfluous 3rd params in fcntl(F_GETFL) calls.

ttymsg.c doesn't need to include fcntl.h.

Tweak standard fd sanitising to be more like the sanitise_stdfd()
used elsewhere, though other uses of 'nullfd' make importing
sanitise_stdfd() itself unappetizing.

Add a die(0) if dup2() fails.

suggestions & ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.59 2015/10/20 12:40:19 bluhm Exp $	*/
d436 1
a436 1
	for(cmd++; *cmd && *cmd == ' '; cmd++)
@


1.59
log
@After pledge "dns" has been refactored and setsockopt(SO_RCVBUF)
has been added to it, the syslogd privsep parent does not need
pledge "inet" anymore.
discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.58 2015/10/18 16:35:06 bluhm Exp $	*/
d449 1
a449 1
	if ((flags = fcntl(fd[1], F_GETFL, 0)) == -1) {
@


1.58
log
@Add "id" pledge to syslogd privsep process.  Needed for logging to pipe.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.57 2015/10/16 16:10:10 bluhm Exp $	*/
d147 1
a147 1
	if (pledge("stdio rpath wpath cpath inet dns getpw sendfd id proc exec",
@


1.57
log
@Pledge the syslogd privsep process with "stdio rpath wpath cpath
inet dns getpw sendfd proc exec".
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.56 2015/10/15 20:26:47 bluhm Exp $	*/
d147 1
a147 1
	if (pledge("stdio rpath wpath cpath inet dns getpw sendfd proc exec",
@


1.56
log
@In syslogd replace the dprintf() macro with a logdebug() function
as dprintf(3) is in libc now and does something different.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.55 2015/10/09 16:58:25 bluhm Exp $	*/
d146 4
@


1.55
log
@If syslogd is started with -S, it accepts TLS connections to receive
encrypted messages.  The server certificates are taken from /etc/ssl
like relayd does.
OK benno@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.54 2015/07/07 17:53:04 bluhm Exp $	*/
d215 1
a215 1
			dprintf("[priv]: msg PRIV_OPEN_TTY received\n");
d233 1
a233 1
			dprintf("[priv]: msg PRIV_OPEN_%s received\n",
d258 1
a258 1
			dprintf("[priv]: msg PRIV_OPEN_UTMP received\n");
d268 1
a268 1
			dprintf("[priv]: msg PRIV_OPEN_CONFIG received\n");
d279 1
a279 1
			dprintf("[priv]: msg PRIV_CONFIG_MODIFIED received\n");
d284 1
a284 1
				dprintf("config file modified: restarting\n");
d294 2
a295 1
			dprintf("[priv]: msg PRIV_DONE_CONFIG_PARSE received\n");
d300 1
a300 1
			dprintf("[priv]: msg PRIV_GETADDRINFO received\n");
d366 1
a366 1
			dprintf("[priv]: msg PRIV_GETNAMEINFO received\n");
@


1.54
log
@When syslogd is invoked with -T listen_address, it creates a TCP
socket and accepts incomming messages.  At the moment, only RFC
6587 3.4.2. Non-Transparent-Framing format with new-line separator
is supprted for incomming messsages.  Outgoing messages are encoded
as 3.4.1. Octet Counting.  Autodetection of incomming format will
be implemented later.
OK deraadt@@ jmc@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.53 2015/07/06 16:12:16 millert Exp $	*/
d187 2
@


1.53
log
@Remove some unneeded includes.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.52 2015/06/30 12:03:32 bluhm Exp $	*/
d185 2
@


1.52
log
@Add a -U command line switch for syslogd to specify an explict bind
address to receive UDP packets.  One advantge over -u and the *
sockets is that you can bind to localhost and divert the packets
with pf.  It is also possible to use a non standard port.
OK jung@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.51 2015/01/19 16:40:49 bluhm Exp $	*/
a18 1
#include <sys/ioctl.h>
a19 3
#include <sys/uio.h>
#include <sys/types.h>
#include <sys/socket.h>
a28 1
#include <poll.h>
a34 1
#include <util.h>
@


1.51
log
@Replace HOST_NAME_MAX+1 with NI_MAXHOST when the hostname is used
with getaddrinfo() or getnameinfo(), but keep HOST_NAME_MAX+1 when
the hostname comes from gethostname().
No binary change;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.50 2015/01/16 06:40:21 deraadt Exp $	*/
d189 2
@


1.50
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.49 2014/12/31 13:55:57 bluhm Exp $	*/
d26 1
d30 1
d42 1
a42 1
#include <limits.h>
d108 2
a109 2
	char path[PATH_MAX], protoname[5], hostname[HOST_NAME_MAX+1];
	char servname[NI_MAXSERV];
d704 1
a704 1
	char protocpy[5], hostcpy[HOST_NAME_MAX+1], servcpy[NI_MAXSERV];
@


1.49
log
@Implement sending syslog messages over TCP streams.
test and OK jasper@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.48 2014/10/05 18:14:01 bluhm Exp $	*/
d18 1
a19 1
#include <sys/param.h>
d40 1
d78 1
a78 1
static char config_file[MAXPATHLEN];
d85 1
a85 1
	char path[MAXPATHLEN];
d106 1
a106 1
	char path[MAXPATHLEN], protoname[5], hostname[MAXHOSTNAMELEN];
d531 1
a531 1
		strlcpy(lg->path, lognam, MAXPATHLEN);
d568 1
a568 1
	char path[MAXPATHLEN];
d591 1
a591 1
	char path[MAXPATHLEN];
d702 1
a702 1
	char protocpy[5], hostcpy[MAXHOSTNAMELEN], servcpy[NI_MAXSERV];
@


1.48
log
@Switch syslogd from using poll(2) to libevent.
test and OK nicm@@; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.47 2014/10/03 21:55:22 bluhm Exp $	*/
d320 2
a321 1
			if (strcmp(protoname, "udp") == 0) {
d323 22
a344 4
			} else if (strcmp(protoname, "udp4") == 0) {
				hints.ai_family = AF_INET;
			} else if (strcmp(protoname, "udp6") == 0) {
				hints.ai_family = AF_INET6;
a347 2
			hints.ai_socktype = SOCK_DGRAM;
			hints.ai_protocol = IPPROTO_UDP;
@


1.47
log
@Cleanup the reporting socket code in syslogd.
- Name variable path_ctlsock consistently.
- Name function ctlconn_logto() consistently.
- Replace the nested if/else logic in ctlconn_write_handler()
  with if/return.
- Call ctlconn_cleanup() only if there is a control connection.
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.46 2014/09/27 11:28:37 bluhm Exp $	*/
d174 12
d187 2
a188 14
		if (pfd[PFD_UNIX_0 + i].fd != -1)
			close(pfd[PFD_UNIX_0 + i].fd);
	if (pfd[PFD_INET].fd != -1)
		close(pfd[PFD_INET].fd);
	if (pfd[PFD_INET6].fd != -1)
		close(pfd[PFD_INET6].fd);
	if (pfd[PFD_CTLSOCK].fd != -1)
		close(pfd[PFD_CTLSOCK].fd);
	if (pfd[PFD_CTLCONN].fd != -1)
		close(pfd[PFD_CTLCONN].fd);
	if (pfd[PFD_KLOG].fd != -1)
		close(pfd[PFD_KLOG].fd);
	if (pfd[PFD_SENDSYS].fd != -1)
		close(pfd[PFD_SENDSYS].fd);
d374 1
a374 1
		if (pfd[PFD_UNIX_0 + i].fd != -1)
d376 1
a376 1
	if (path_ctlsock != NULL && pfd[PFD_CTLSOCK].fd != -1)
@


1.46
log
@Also in debug mode, close nullfd when it is not needed anymore.
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.45 2014/09/10 13:16:20 doug Exp $	*/
d376 2
a377 2
	if (ctlsock_path != NULL && pfd[PFD_CTLSOCK].fd != -1)
		(void)unlink(ctlsock_path);
@


1.45
log
@Remove redundant null check and rename vars consistently in syslogd

Merge in more functionality from bluhm's patch.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.44 2014/09/08 00:43:42 doug Exp $	*/
a155 1

@


1.44
log
@Fix a syslogd regression when specifying all 20 additional log paths

bluhm@@ found and fixed this bug.  This is a modified version of his
patch which makes the intention a little clearer.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.43 2014/08/25 20:19:14 bluhm Exp $	*/
d175 1
a175 1
	for (i = 0; i < nfunix; i++)
d374 3
a376 3
	for (i = 0; i < nfunix; i++)
		if (funixn[i] != NULL && pfd[PFD_UNIX_0 + i].fd != -1)
			(void)unlink(funixn[i]);
@


1.43
log
@Call check_tty_name() and check_log_name() with the string size and
don't access memory beyond.  Make sure that the complete string
"/dev/null" can be copied.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.42 2014/08/25 18:19:18 bluhm Exp $	*/
d186 1
a186 1
	if (pfd[PFD_KLOG].fd)
d188 2
@


1.42
log
@Allow to restrict syslogd to a protocol family with -4 and -6 command
line switches.  If the log server is an FQDN, DNS chooses wether
to take the IPv4 or IPv6 route.  Allow to prefix the log host with
udp4:// or udp6:// to choose a protocol.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.41 2014/08/25 18:05:30 bluhm Exp $	*/
d218 1
a218 1
			check_tty_name(path, path_len);
d237 1
a237 1
			check_log_name(path, path_len);
d472 1
a472 1
check_tty_name(char *tty, size_t ttylen)
d478 1
a478 1
	for (p = tty; *p && p < tty + ttylen; p++)
d489 1
a489 1
	strlcpy(tty, "/dev/null", ttylen);
d497 1
a497 1
check_log_name(char *lognam, size_t loglen)
d503 1
a503 1
	for (p = lognam; *p && p < lognam + loglen; p++)
d531 1
a531 1
	strlcpy(lognam, "/dev/null", loglen);
@


1.41
log
@Fix the gcc compiler warnings "comparison between signed and
unsigned".  Some checks got stricter.  The (size_t) cast is only
done, if the argument is not negative.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.40 2014/08/21 17:00:34 bluhm Exp $	*/
d104 2
a105 2
	size_t path_len, hostname_len, servname_len;
	char path[MAXPATHLEN], hostname[MAXHOSTNAMELEN];
d296 8
a303 1
			/* Expecting: len, hostname, len, servname */
d319 9
a327 1
			hints.ai_family = AF_UNSPEC;
d329 1
d680 1
a680 1
priv_getaddrinfo(char *host, char *serv, struct sockaddr *addr,
d683 1
a683 1
	char hostcpy[MAXHOSTNAMELEN], servcpy[NI_MAXSERV];
d685 1
a685 1
	size_t hostname_len, servname_len;
d690 4
a693 1
	if (strlcpy(hostcpy, host, sizeof hostcpy) >= sizeof(hostcpy))
d696 1
a696 1
	if (strlcpy(servcpy, serv, sizeof servcpy) >= sizeof(servcpy))
d702 2
@


1.40
log
@Send and receive UDP syslog packets on the IPv6 socket.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.39 2014/08/21 00:04:58 bluhm Exp $	*/
d333 1
a333 1
			if (addr_len <= 0 || addr_len > sizeof(addr))
d462 1
a462 1
	for (p = tty; *p && (p - tty) < ttylen; p++)
d487 1
a487 1
	for (p = lognam; *p && (p - lognam) < loglen; p++)
d696 1
a696 1
	if (addr_len < ret_len)
d730 1
a730 1
	if (hostlen < ret_len)
d770 2
a771 1
	ssize_t res, pos = 0;
d794 2
a795 1
	ssize_t res, pos = 0;
d817 2
a818 1
	ssize_t res, pos = 0;
@


1.39
log
@Parse loghost in a separate function.  Allow [] around hostname,
needed for IPv6 addresses.  Print full loghost specifier in case
of error or debug.  Make string sizes more precise.
input henning@@; input and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.38 2014/08/20 20:10:17 bluhm Exp $	*/
d180 2
d311 2
a312 2
			memset(&hints, '\0', sizeof(hints));
			hints.ai_family = AF_INET;
@


1.38
log
@Replace gethostbyaddr(3) with getnameinfo(3).  Remove the sigprocmask()
that was necessary for gethostbyaddr() because the latter is not
signal safe.  Change the return code semantics of priv_getnameinfo()
to match getnameinfo(3).
input and OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.37 2014/08/20 19:16:27 bluhm Exp $	*/
d106 1
a106 1
	char servname[MAXHOSTNAMELEN];
d665 1
a665 1
	char hostcpy[MAXHOSTNAMELEN], servcpy[MAXHOSTNAMELEN];
@


1.37
log
@Rename priv_gethostserv() to priv_getaddrinfo() as this is what the
function does.  Change the return code semantics to match getaddrinfo(3).
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.36 2014/08/19 00:53:01 bluhm Exp $	*/
d71 1
a71 1
	PRIV_GETHOSTBYADDR,	/* resolve numeric address into hostname */
d79 1
a79 1
static int allow_gethostbyaddr = 0;
d103 1
a103 1
	int i, fd, socks[2], cmd, addr_len, addr_af, result, restart;
d107 1
a108 1
	struct hostent *hp;
d194 1
a194 1
	/* Save whether or not the child can have access to gethostbyaddr(3) */
d196 1
a196 1
		allow_gethostbyaddr = 0;
d198 1
a198 1
		allow_gethostbyaddr = 1;
d325 5
a329 5
		case PRIV_GETHOSTBYADDR:
			dprintf("[priv]: msg PRIV_GETHOSTBYADDR received\n");
			if (!allow_gethostbyaddr)
				errx(1, "rejected attempt to gethostbyaddr");
			/* Expecting: length, address, address family */
d331 1
a331 1
			if (addr_len <= 0 || addr_len > sizeof(hostname))
d333 4
a336 4
			must_read(socks[0], hostname, addr_len);
			must_read(socks[0], &addr_af, sizeof(int));
			hp = gethostbyaddr(hostname, addr_len, addr_af);
			if (hp == NULL) {
d340 1
a340 1
				addr_len = strlen(hp->h_name) + 1;
d342 1
a342 1
				must_write(socks[0], hp->h_name, addr_len);
d659 2
a660 2
/* Name/service to address translation.  Response is placed into addr, and
 * the length is returned (zero on error) */
d704 2
a705 2
/* Reverse address resolution; response is placed into res, and length of
 * response is returned (zero on error) */
d707 2
a708 1
priv_gethostbyaddr(char *addr, int addr_len, int af, char *res, size_t res_len)
d715 1
a715 1
	cmd = PRIV_GETHOSTBYADDR;
d717 2
a718 3
	must_write(priv_fd, &addr_len, sizeof(int));
	must_write(priv_fd, addr, addr_len);
	must_write(priv_fd, &af, sizeof(int));
d725 1
a725 1
		return 0;
d728 1
a728 1
	if (res_len < ret_len)
d732 2
a733 2
	must_read(priv_fd, res, ret_len);
	return ret_len;
@


1.36
log
@The _exit codes in syslogd privsep.c were the wrong way around.
Fatal errors should exit with 1, and regular shutdown should result
in exit with 0.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.35 2014/08/19 00:28:48 bluhm Exp $	*/
d70 1
a70 1
	PRIV_GETHOSTSERV,	/* resolve host/service names */
d292 2
a293 2
		case PRIV_GETHOSTSERV:
			dprintf("[priv]: msg PRIV_GETHOSTSERV received\n");
d296 2
a297 1
			if (hostname_len == 0 || hostname_len > sizeof(hostname))
d303 2
a304 1
			if (servname_len == 0 || servname_len > sizeof(servname))
d662 1
a662 1
priv_gethostserv(char *host, char *serv, struct sockaddr *addr,
d679 1
a679 1
	cmd = PRIV_GETHOSTSERV;
d691 1
a691 1
		return 0;
d701 1
a701 1
	return ret_len;
@


1.35
log
@Replace manually written function names with __func__.
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.34 2008/11/23 04:29:42 brad Exp $	*/
d213 1
a213 1
				_exit(0);
d232 1
a232 1
				_exit(0);
d297 1
a297 1
				_exit(0);
d303 1
a303 1
				_exit(0);
d330 1
a330 1
				_exit(0);
d365 1
a365 1
	_exit(1);
d798 1
a798 1
			_exit(0);
d820 1
a820 1
			_exit(0);
@


1.34
log
@Remove some whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.33 2008/09/29 18:41:56 deraadt Exp $	*/
d534 1
a534 1
		errx(1, "%s: called from privileged portion", "priv_open_tty");
d557 1
a557 1
		errx(1, "%s: called from privileged child", "priv_open_log");
d582 1
a582 1
		errx(1, "%s: called from privileged portion", "priv_open_utmp");
d608 1
a608 1
		errx(1, "%s: called from privileged portion", "priv_open_config");
d633 1
a633 2
		errx(1, "%s: called from privileged portion",
		    "priv_config_modified");
d651 1
a651 2
		errx(1, "%s: called from privileged portion",
		    "priv_config_parse_done");
d668 1
a668 1
		errx(1, "%s: called from privileged portion", "priv_gethostserv");
d671 1
a671 1
		errx(1, "%s: overflow attempt in hostname", "priv_gethostserv");
d674 1
a674 1
		errx(1, "%s: overflow attempt in servname", "priv_gethostserv");
d693 1
a693 1
		errx(1, "%s: overflow attempt in return", "priv_gethostserv");
d710 1
a710 1
		errx(1, "%s called from privileged portion", "priv_gethostbyaddr");
d727 1
a727 1
		errx(1, "%s: overflow attempt in return", "priv_gethostbyaddr");
@


1.33
log
@do not close a random file descriptor in debug mode, PR 5938 from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.32 2008/03/16 16:55:29 deraadt Exp $	*/
d116 1
a116 1
	sa.sa_handler = SIG_DFL; 
d162 1
a162 1
	sa.sa_handler = sig_pass_to_chld; 
@


1.32
log
@avoid errno trashing, ok mpf henning
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.31 2008/03/16 15:44:18 mpf Exp $	*/
a149 1
	close(lockfd);
d151 1
@


1.31
log
@syslogd leaves zombies around if multiple  |/pathto/mylogprog
children died in a row.
Do waitpid(2) in a loop until there's nothing left.
OK henning@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.30 2007/03/15 05:18:32 djm Exp $	*/
d740 1
a740 1
	int oerrno = errno;
d744 1
a744 1
	errno = oerrno;
d752 1
d760 1
@


1.30
log
@use warnx and not logerror in monitor, logerror is for the slave;
ok henning@@ while in lock
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.29 2007/02/20 11:24:32 henning Exp $	*/
d756 3
a758 5
	} while (pid == -1 && errno == EINTR);

	if (pid == child_pid &&
	    cur_state < STATE_QUIT)
		cur_state = STATE_QUIT;
@


1.29
log
@implement logging to other program's stdin.
if the target is like "| /path/to/program", syslogd forks and execs program
and sends the selected log messages to program's stdin.
uses a socketpair, grows the receive buffer on the reader side and has the
socket nonblocking on syslog'd side to prevent syslogd blocking.
I'm using that here to feed logsurfer from ports for automated log analysis,
werks beautifully.
lots of input & help mpf, ok mpf djm "no objections" millert
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.28 2006/07/09 14:42:27 millert Exp $	*/
d398 1
a398 1
		logerror("open_pipe");
d404 1
a404 1
		logerror("fcntl");
d409 1
a409 1
		logerror("fcntl");
d415 1
a415 1
		logerror("fork error");
d444 2
@


1.28
log
@Use sigaction() instead of signal() in the parent and use the
SA_NOCLDSTOP flag for the SIGCHLD handler so the kernel does not
notify us when the child has been stopped, only when it exits.
Fixes a problem where if you suspended the child process the
parent would exit.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.27 2005/12/02 16:50:11 moritz Exp $	*/
d66 1
d90 2
d226 3
a228 1
			dprintf("[priv]: msg PRIV_OPEN_LOG received\n");
d236 8
a243 1
			fd = open(path, O_WRONLY|O_APPEND|O_NONBLOCK, 0);
d368 78
d561 4
a564 1
	cmd = PRIV_OPEN_LOG;
d750 8
a757 1
	if (cur_state < STATE_QUIT)
@


1.27
log
@unlink() pid file on exit. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.26 2005/06/06 23:20:44 djm Exp $	*/
d108 1
d110 4
d115 1
a115 1
		signal(i, SIG_DFL);
d159 8
a166 5
	signal(SIGTERM, sig_pass_to_chld);
	signal(SIGHUP, sig_pass_to_chld);
	signal(SIGINT, sig_pass_to_chld);
	signal(SIGQUIT, sig_pass_to_chld);
	signal(SIGCHLD, sig_got_chld);
@


1.26
log
@fix fd leak on SIGHUP after config change, spotted by Stephen Marley; ok avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.25 2005/05/23 20:12:28 henning Exp $	*/
d344 1
@


1.25
log
@noo need for endpwent() here at all, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.24 2005/05/03 05:44:35 djm Exp $	*/
d328 2
@


1.24
log
@setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.23 2004/09/14 23:41:29 deraadt Exp $	*/
a118 1
	endpwent();
@


1.23
log
@portable code should not use that gcc __func__ specific junk when it is not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.22 2004/09/14 23:26:41 deraadt Exp $	*/
a125 2
		gid_t gidset[1];

d132 1
a132 2
		gidset[0] = pw->pw_gid;
		if (setgroups(1, gidset) == -1)
d134 4
a137 8
		if (setegid(pw->pw_gid) == -1)
			err(1, "setegid() failed");
		if (setgid(pw->pw_gid) == -1)
			err(1, "setgid() failed");
		if (seteuid(pw->pw_uid) == -1)
			err(1, "seteuid() failed");
		if (setuid(pw->pw_uid) == -1)
			err(1, "setuid() failed");
@


1.22
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.21 2004/07/09 16:22:04 deraadt Exp $	*/
d373 1
a373 1
	    __func__, tty);
d415 1
a415 1
	    __func__, lognam);
d439 1
a439 1
		errx(1, "%s: called from privileged portion", __func__);
d462 1
a462 1
		errx(1, "%s: called from privileged child", __func__);
d484 1
a484 1
		errx(1, "%s: called from privileged portion", __func__);
d510 1
a510 1
		errx(1, "%s: called from privileged portion", __func__);
d535 2
a536 1
		errx(1, "%s: called from privileged portion", __func__);
d554 2
a555 1
		errx(1, "%s: called from privileged portion", __func__);
d572 1
a572 1
		errx(1, "%s: called from privileged portion", __func__);
d575 1
a575 1
		errx(1, "%s: overflow attempt in hostname", __func__);
d578 1
a578 1
		errx(1, "%s: overflow attempt in servname", __func__);
d597 1
a597 1
		errx(1, "%s: overflow attempt in return", __func__);
d614 1
a614 1
		errx(1, "%s called from privileged portion", __func__);
d631 1
a631 1
		errx(1, "%s: overflow attempt in return", __func__);
@


1.21
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.20 2004/07/03 23:40:44 djm Exp $	*/
d648 1
@


1.20
log
@-Wall,-Wshadow cleanup with avsm@@; ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.19 2004/07/03 05:32:18 djm Exp $	*/
d530 1
a530 1
priv_config_modified()
@


1.19
log
@support @@hostname:port syntax in syslog.conf, prompted by msf@@ at c2k4;
ok henning@@ anil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.18 2004/04/09 20:13:25 canacar Exp $	*/
d382 1
a382 1
check_log_name(char *log, size_t loglen)
d388 1
a388 1
	for (p = log; *p && (p - log) < loglen; p++)
d397 1
a397 1
		strlcpy(lg->path, log, MAXPATHLEN);
d402 1
a402 1
			if (!strcmp(lg->path, log))
d415 2
a416 2
	    __func__, log);
	strlcpy(log, "/dev/null", loglen);
d455 1
a455 1
priv_open_log(const char *log)
d464 1
a464 1
	if (strlcpy(path, log, sizeof path) >= sizeof(path))
@


1.18
log
@Also pass SIGINT and SIGQUIT to child, noticed by mpech@@
ok avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.17 2004/04/02 21:44:50 avsm Exp $	*/
d69 1
a69 1
	PRIV_GETHOSTBYNAME,	/* resolve hostname into numerical address */
d101 1
a101 1
	size_t path_len, hostname_len;
d103 1
d107 1
d280 3
a282 3
		case PRIV_GETHOSTBYNAME:
			dprintf("[priv]: msg PRIV_GETHOSTBYNAME received\n");
			/* Expecting: length, hostname */
d288 12
a299 2
			hp = gethostbyname(hostname);
			if (hp == NULL) {
d303 5
a307 2
				must_write(socks[0], &hp->h_length, sizeof(int));
				must_write(socks[0], hp->h_addr, hp->h_length);
d559 1
a559 1
/* Resolve hostname into address.  Response is placed into addr, and
d562 2
a563 1
priv_gethostbyname(char *host, char *addr, size_t addr_len)
d565 1
a565 1
	char hostcpy[MAXHOSTNAMELEN];
d567 1
a567 1
	size_t hostname_len;
d575 3
d579 1
a579 1
	cmd = PRIV_GETHOSTBYNAME;
d583 2
d598 1
d600 1
@


1.17
log
@Do not bother closing an fd when we know it has failed.
Based on diff from Moritz Jodeit <moritz at jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.16 2004/03/14 19:17:05 otto Exp $	*/
d159 1
a159 1
	/* Pass TERM/HUP through to child, and accept CHLD */
d162 2
d613 1
a613 1
/* If priv parent gets a TERM or HUP, pass it through to child instead */
@


1.16
log
@Check return code of chdir() after chroot(); noted by Joris Vink, slight mod
from avsm@@.
ok avsm@@ hshoexer@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.15 2004/03/06 19:42:38 otto Exp $	*/
d211 1
d214 2
a215 2
			send_fd(socks[0], fd);
			close(fd);
d228 1
d231 2
a232 2
			send_fd(socks[0], fd);
			close(fd);
d238 1
d241 2
a242 2
			send_fd(socks[0], fd);
			close(fd);
d249 1
d252 2
a253 2
			send_fd(socks[0], fd);
			close(fd);
@


1.15
log
@cleanup, mostly signal handling
ok henning@@ millert@@ avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.14 2004/02/26 11:04:15 avsm Exp $	*/
d129 2
a130 1
		chdir("/");
@


1.14
log
@cure my speling
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.13 2004/01/04 08:28:49 djm Exp $	*/
d75 1
a75 1
static pid_t child_pid = -1;
d107 3
d117 1
a157 3
	for (i = 1; i <= _NSIG; i++)
		signal(i, SIG_DFL);

d610 2
d614 1
@


1.13
log
@Buffered logging for syslogd. Logs may be stored in memory buffers and
extracted using a small client. Useful for diskless systems.
much feedback from deraadt@@, canacar@@, jmc@@, jakob@@ ; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.12 2003/12/29 22:09:36 deraadt Exp $	*/
d52 1
a52 1
 * useful to force resoluton of remote syslog servers again).
@


1.12
log
@delint
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.11 2003/12/29 22:08:44 deraadt Exp $	*/
d171 4
d316 1
a316 1
		if (funixn[i] && pfd[PFD_UNIX_0 + i].fd != -1)
d318 2
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.10 2003/12/29 22:05:10 djm Exp $	*/
d60 1
a60 1
	STATE_QUIT,		/* shutting down */
@


1.10
log
@convert from select() to poll() for main event loop; tested millert@@, deraadt@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.9 2003/10/26 18:21:49 avsm Exp $	*/
d126 1
a126 1
		
@


1.9
log
@correct bad dprintf, from Moritz Jodeit <moritz at jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.8 2003/10/24 21:21:27 canacar Exp $	*/
d31 1
d167 6
a172 6
		if (funix[i] != -1)
			close(funix[i]);
	if (finet != -1)
		close(finet);
	if (fklog != -1)
		close(fklog);
d312 1
a312 1
		if (funixn[i] && funix[i] != -1)
@


1.8
log
@fix an occasional hang noticed by mpech@@ when a SIGHUP
is received after the configuration is modified.

tested by mpech@@, ok avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.7 2003/10/22 19:37:38 deraadt Exp $	*/
d211 1
a211 1
			dprintf("[priv]: msg PRIV_OPEN_LOG received: %s\n", path);
@


1.7
log
@setgroups; avsm ok
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.6 2003/09/24 23:35:45 avsm Exp $	*/
a59 1
	STATE_RESTART		/* kill child and re-exec to restart */
d74 1
a74 1
static pid_t child_pid;
d94 1
d99 1
a99 1
	int i, fd, socks[2], cmd, addr_len, addr_af, result;
d188 1
d191 2
a192 1
		must_read(socks[0], &cmd, sizeof(int));
d252 1
a252 1
				result = 1;
a253 1
				increase_state(STATE_RESTART);
d314 1
a314 1
	if (cur_state == STATE_RESTART) {
d395 1
a395 1
	if (state < STATE_INIT || state > STATE_RESTART)
d602 2
a603 1
	kill(child_pid, sig);
d612 22
@


1.6
log
@cleanup privsep communications between child/parent with a lot more
paranoia.  noticed by aaron@@, feedback from drahn@@ cloder@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.5 2003/08/15 23:13:06 deraadt Exp $	*/
d119 2
d125 4
@


1.5
log
@remove extra \n in {warn,err}{,x} calls
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.4 2003/08/01 14:04:35 avsm Exp $	*/
d100 1
a186 1
			must_read(socks[0], &path, sizeof path);
d188 7
a194 1
			check_tty_name(path, sizeof path);
a202 1
			must_read(socks[0], &path, sizeof path);
d204 7
a210 1
			check_log_name(path, sizeof path);
d260 6
a265 2
			/* Expecting: hostname[MAXHOSTNAMELEN] */
			must_read(socks[0], &hostname, sizeof hostname);
d282 1
a282 1
			if (addr_len > sizeof(hostname))
d399 1
d406 2
d410 2
a411 1
	must_write(priv_fd, path, sizeof(path));
d422 1
d429 2
d433 2
a434 1
	must_write(priv_fd, path, sizeof(path));
d529 4
d536 1
a536 3

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);
d540 2
a541 1
	must_write(priv_fd, hostcpy, sizeof(hostcpy));
@


1.4
log
@clean up debug output some, and correct an incorrect error check in
priv_gethostbyaddr()
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.3 2003/07/31 21:28:28 deraadt Exp $	*/
d405 1
a405 1
		errx(1, "%s: called from privileged child\n", __func__);
@


1.3
log
@delint
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.2 2003/07/31 18:25:58 avsm Exp $	*/
d191 1
a191 1
				warnx("%s: priv_open_tty failed", __func__);
d202 1
a202 1
				warnx("%s: priv_open_log failed", __func__);
d211 1
a211 1
				warnx("%s: priv_open_utmp failed", __func__);
d221 1
a221 1
				warnx("%s: priv_open_config failed", __func__);
d264 1
a264 2
				errx(1, "%s: rejected attempt to gethostbyaddr",
				    __func__);
d282 1
a282 1
			errx(1, "%s: unknown command %d", __func__, cmd);
a286 1
	dprintf("%s: shutting down priv parent\n", __func__);
a384 1
	dprintf("[unpriv] priv_open_tty\n");
a403 1
	dprintf("[unpriv] priv_open_log %s\n", log);
a422 1
	dprintf("[unpriv] priv_open_utmp\n");
a448 1
	dprintf("[unpriv] priv_open_config\n");
a473 1
	dprintf("[unpriv] priv_config_modified called\n");
d476 1
a506 2
	dprintf("[unpriv] %s called\n", __func__);

a539 2
	dprintf("[unpriv] %s called\n", __func__);

d553 1
a553 1
	if (!res_len)
@


1.2
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.1 2003/07/31 18:20:07 avsm Exp $	*/
d60 1
a60 1
	STATE_RESTART,		/* kill child and re-exec to restart */
d71 1
a71 1
	PRIV_DONE_CONFIG_PARSE,	/* signal that the initial config parse is done */
@


1.1
log
@Privilege separated syslog daemon.  The child listening to log requests drops
to user _syslogd and chroots itself, while the privileged parent grants it
access to open logfiles and other calls it needs.

The only difference from existing behaviour is that if syslog.conf changes
and syslogd receives a HUP, it will re-exec itself and have two new PIDs.
A HUP with an unchanged config will make syslogd reopen logfiles as before.

Lots of help and code from deraadt@@ , and advice from millert@@

Various versions tested by todd, cloder, mpech, markus, tdeval and others
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d240 1
a240 1
			break;    
d374 1
a374 1
		errx (1, "attempt to decrease or match current state");
d376 1
a376 1
		errx (1, "attempt to switch to invalid state");
d440 1
a440 1
		close (fd);
d467 1
a467 1
		close (fd);
@

