head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.12
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.10
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.6
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.16
	OPENBSD_5_0:1.7.0.14
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.12
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.10
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.6
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.2
	OPENBSD_3_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.07.09.20.16.04;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	tTqbKMmqqxpC4eic;

1.10
date	2015.07.06.16.12.16;	author millert;	state Exp;
branches;
next	1.9;
commitid	MZymOysCDJJlr2xr;

1.9
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	Uu5nFG3wCl0LACBb;

1.8
date	2012.04.04.17.24.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.24.16.11.05;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.15.16.19.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.03.13.01.49.53;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.14.23.41.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.13.02.51.48;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.03.23.40.44;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.31.18.20.07;	author avsm;	state Exp;
branches;
next	;


desc
@@


1.11
log
@During fd passing, receive_fd() tries to read the result value and
the file descriptor.  If the fd limit is exhausted, recvmsg(2)
fails.  The kernel discards the fd, but the result value stays in
the socket.  It has to be read on its own to keep the privsep parent
and syslogd child in sync.
OK benno@@
@
text
@/*	$OpenBSD: privsep_fdpass.c,v 1.10 2015/07/06 16:12:16 millert Exp $	*/

/*
 * Copyright 2001 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Copyright (c) 2002 Matthieu Herrb
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "syslogd.h"

void
send_fd(int sock, int fd)
{
	struct msghdr msg;
	union {
		struct cmsghdr hdr;
		char buf[CMSG_SPACE(sizeof(int))];
	} cmsgbuf;
	struct cmsghdr *cmsg;
	struct iovec vec;
	int result = 0;
	ssize_t n;

	memset(&msg, 0, sizeof(msg));

	if (fd >= 0) {
		msg.msg_control = (caddr_t)&cmsgbuf.buf;
		msg.msg_controllen = sizeof(cmsgbuf.buf);
		cmsg = CMSG_FIRSTHDR(&msg);
		cmsg->cmsg_len = CMSG_LEN(sizeof(int));
		cmsg->cmsg_level = SOL_SOCKET;
		cmsg->cmsg_type = SCM_RIGHTS;
		*(int *)CMSG_DATA(cmsg) = fd;
	} else {
		result = errno;
	}

	vec.iov_base = &result;
	vec.iov_len = sizeof(int);
	msg.msg_iov = &vec;
	msg.msg_iovlen = 1;

	if ((n = sendmsg(sock, &msg, 0)) == -1)
		warn("%s: sendmsg(%d)", "send_fd", sock);
	if (n != sizeof(int))
		warnx("%s: sendmsg: expected sent 1 got %ld",
		    "send_fd", (long)n);
}

int
receive_fd(int sock)
{
	struct msghdr msg;
	union {
		struct cmsghdr hdr;
		char buf[CMSG_SPACE(sizeof(int))];
	} cmsgbuf;
	struct cmsghdr *cmsg;
	struct iovec vec;
	ssize_t n;
	int result;
	int fd;

	memset(&msg, 0, sizeof(msg));
	vec.iov_base = &result;
	vec.iov_len = sizeof(int);
	msg.msg_iov = &vec;
	msg.msg_iovlen = 1;
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);

	if ((n = recvmsg(sock, &msg, 0)) == -1) {
		warn("%s: recvmsg", "receive_fd");
		/* receive message failed, but the result is in the socket */
		if (errno == EMSGSIZE)
			recv(sock, &result, sizeof(int), MSG_DONTWAIT);
		return -1;
	}
	if (n != sizeof(int))
		warnx("%s: recvmsg: expected received 1 got %ld",
		    "receive_fd", (long)n);
	if (result == 0) {
		cmsg = CMSG_FIRSTHDR(&msg);
		if (cmsg == NULL) {
			warnx("%s: no message header", "receive_fd");
			return (-1);
		}
		if (cmsg->cmsg_type != SCM_RIGHTS)
			warnx("%s: expected type %d got %d", "receive_fd",
			    SCM_RIGHTS, cmsg->cmsg_type);
		fd = (*(int *)CMSG_DATA(cmsg));
		return fd;
	} else {
		errno = result;
		return -1;
	}
}
@


1.10
log
@Remove some unneeded includes.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_fdpass.c,v 1.9 2015/01/16 06:40:21 deraadt Exp $	*/
d107 3
@


1.9
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_fdpass.c,v 1.8 2012/04/04 17:24:50 deraadt Exp $	*/
a34 4
#include <sys/uio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
a36 2
#include <fcntl.h>
#include <signal.h>
d41 1
@


1.8
log
@Return an error much earlier if recvmsg fails
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_fdpass.c,v 1.7 2008/03/24 16:11:05 deraadt Exp $	*/
d34 1
a34 1
#include <sys/param.h>
@


1.7
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_fdpass.c,v 1.6 2008/03/15 16:19:02 deraadt Exp $	*/
d110 1
a110 1
	if ((n = recvmsg(sock, &msg, 0)) == -1)
d112 2
@


1.6
log
@Repair the simple cases for msg_controllen where it should just be
CMSG_SIZE(sizeof(int)), not sizeof(buffer) which may be larger because
of alignment; ok kettenis hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_fdpass.c,v 1.5 2008/03/13 01:49:53 deraadt Exp $	*/
d66 1
a66 1
		msg.msg_controllen = CMSG_LEN(sizeof(int));
d108 1
a108 1
	msg.msg_controllen = CMSG_LEN(sizeof(int));
@


1.5
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_fdpass.c,v 1.4 2004/09/14 23:41:29 deraadt Exp $	*/
d66 1
a66 1
		msg.msg_controllen = sizeof(cmsgbuf.buf);
d108 1
a108 1
	msg.msg_controllen = sizeof(cmsgbuf.buf);
@


1.4
log
@portable code should not use that gcc __func__ specific junk when it is not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_fdpass.c,v 1.3 2004/08/13 02:51:48 djm Exp $	*/
d53 4
a56 1
	char tmp[CMSG_SPACE(sizeof(int))];
d65 2
a66 2
		msg.msg_control = (caddr_t)tmp;
		msg.msg_controllen = CMSG_LEN(sizeof(int));
d92 4
a95 1
	char tmp[CMSG_SPACE(sizeof(int))];
d107 2
a108 2
	msg.msg_control = tmp;
	msg.msg_controllen = sizeof(tmp);
@


1.3
log
@extra check for no message case; ok markus, deraadt, hshoexer, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_fdpass.c,v 1.2 2004/07/03 23:40:44 djm Exp $	*/
d79 1
a79 1
		warn("%s: sendmsg(%d)", __func__, sock);
d82 1
a82 1
		    __func__, (long)n);
d105 1
a105 1
		warn("%s: recvmsg", __func__);
d108 1
a108 1
		    __func__, (long)n);
d112 1
a112 1
			warnx("%s: no message header", __func__);
d116 1
a116 1
			warnx("%s: expected type %d got %d", __func__,
@


1.2
log
@-Wall,-Wshadow cleanup with avsm@@; ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_fdpass.c,v 1.1 2003/07/31 18:20:07 avsm Exp $	*/
d111 4
@


1.1
log
@Privilege separated syslog daemon.  The child listening to log requests drops
to user _syslogd and chroots itself, while the privileged parent grants it
access to open logfiles and other calls it needs.

The only difference from existing behaviour is that if syslog.conf changes
and syslogd receives a HUP, it will re-exec itself and have two new PIDs.
A HUP with an unchanged config will make syslogd reopen logfiles as before.

Lots of help and code from deraadt@@ , and advice from millert@@

Various versions tested by todd, cloder, mpech, markus, tdeval and others
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
send_fd(int socket, int fd)
d78 2
a79 2
	if ((n = sendmsg(socket, &msg, 0)) == -1)
		warn("%s: sendmsg(%d)", __func__, socket);
d86 1
a86 1
receive_fd(int socket)
d104 1
a104 1
	if ((n = recvmsg(socket, &msg, 0)) == -1)
@

