head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.4
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.4.0.22
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.20
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.16
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.14
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.12
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.10
	OPENBSD_5_0:1.4.0.8
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.16
date	2017.08.08.14.23.23;	author bluhm;	state Exp;
branches;
next	1.15;
commitid	mLHelEDyH1jZRa58;

1.15
date	2017.04.05.21.55.31;	author bluhm;	state Exp;
branches;
next	1.14;
commitid	flr3ijis68GFyMYo;

1.14
date	2017.04.05.11.31.45;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	TF7j2iQD9pdWhJEf;

1.13
date	2017.03.24.16.24.36;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	eQv2cIMKfjubUfpJ;

1.12
date	2017.03.16.12.14.37;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	8kPQW6TdPPWadHlQ;

1.11
date	2016.08.16.18.41.57;	author tedu;	state Exp;
branches;
next	1.10;
commitid	eyeRGwF24702KeRh;

1.10
date	2016.04.02.19.55.10;	author krw;	state Exp;
branches;
next	1.9;
commitid	uFCdPoth1U2KDjGH;

1.9
date	2015.10.23.16.28.52;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	eBs6rrorZWMEEvct;

1.8
date	2015.10.21.14.03.07;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	TmKVn9eOlSCpK5iI;

1.7
date	2015.07.06.16.12.16;	author millert;	state Exp;
branches;
next	1.6;
commitid	MZymOysCDJJlr2xr;

1.6
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	Uu5nFG3wCl0LACBb;

1.5
date	2014.08.25.18.05.30;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	V6d93DJvIyTMzMa3;

1.4
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.03.23.40.44;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.27.00.27.50;	author avsm;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.31.18.20.07;	author avsm;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Kernel sendsyslog(2), libc syslog(3), and syslogd(8) restrict and
truncate the length of a syslog message to 8192 bytes.  Use one
global define LOG_MAXLINE for all of them.
OK deraadt@@ millert@@
@
text
@/*	$OpenBSD: ttymsg.c,v 1.15 2017/04/05 21:55:31 bluhm Exp $	*/
/*	$NetBSD: ttymsg.c,v 1.3 1994/11/17 07:17:55 jtc Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/syslog.h>

#include <dirent.h>
#include <errno.h>
#include <event.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "log.h"
#include "syslogd.h"

#ifndef nitems
#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
#endif

struct tty_delay {
	struct event	 td_event;
	size_t		 td_length;
	char		 td_line[LOG_MAXLINE];
};
int tty_delayed = 0;
void ttycb(int, short, void *);

/*
 * Display the contents of a uio structure on a terminal.
 * Schedules an event if write would block, waiting up to TTYMSGTIME
 * seconds.
 */
void
ttymsg(struct iovec *iov, int iovcnt, char *utline)
{
	static char device[MAXNAMLEN] = _PATH_DEV;
	int cnt, fd;
	size_t left;
	ssize_t wret;
	struct iovec localiov[6];

	if (iovcnt < 0 || (size_t)iovcnt > nitems(localiov)) {
		log_warnx("too many iov's (change code in syslogd/ttymsg.c)");
		return;
	}

	/*
	 * Ignore lines that start with "ftp" or "uucp".
	 */
	if ((strncmp(utline, "ftp", 3) == 0) ||
	    (strncmp(utline, "uucp", 4) == 0))
		return;

	(void) strlcpy(device + sizeof(_PATH_DEV) - 1, utline,
	    sizeof(device) - (sizeof(_PATH_DEV) - 1));
	if (strchr(device + sizeof(_PATH_DEV) - 1, '/')) {
		/* A slash is an attempt to break security... */
		log_warnx("'/' in tty device \"%s\"", device);
		return;
	}

	/*
	 * open will fail on slip lines or exclusive-use lines
	 * if not running as root; not an error.
	 */
	if ((fd = priv_open_tty(device)) < 0) {
		if (errno != EBUSY && errno != EACCES)
			log_warn("priv_open_tty device \"%s\"", device);
		return;
	}

	left = 0;
	for (cnt = 0; cnt < iovcnt; ++cnt)
		left += iov[cnt].iov_len;

	for (;;) {
		wret = writev(fd, iov, iovcnt);
		if (wret >= 0) {
			if ((size_t)wret >= left)
				break;
			left -= wret;
			if (iov != localiov) {
				memmove(localiov, iov,
				    iovcnt * sizeof(struct iovec));
				iov = localiov;
			}
			while ((size_t)wret >= iov->iov_len) {
				wret -= iov->iov_len;
				++iov;
				--iovcnt;
			}
			if (wret) {
				iov->iov_base = (char *)iov->iov_base + wret;
				iov->iov_len -= wret;
			}
			continue;
		}
		if (errno == EWOULDBLOCK) {
			struct tty_delay	*td;
			struct timeval		 to;

			if (tty_delayed >= TTYMAXDELAY) {
				log_warnx("tty device \"%s\": %s",
				    device, "too many delayed writes");
				break;
			}
			log_debug("ttymsg delayed write");
			if (iov != localiov) {
				memmove(localiov, iov,
				    iovcnt * sizeof(struct iovec));
				iov = localiov;
			}
			if ((td = malloc(sizeof(*td))) == NULL) {
				log_warn("allocate delay tty device \"%s\"",
				    device);
				break;
			}
			td->td_length = 0;
			if (left > LOG_MAXLINE)
				left = LOG_MAXLINE;
			while (iovcnt && left) {
				if (iov->iov_len > left)
					iov->iov_len = left;
				memcpy(td->td_line + td->td_length,
				    iov->iov_base, iov->iov_len);
				td->td_length += iov->iov_len;
				left -= iov->iov_len;
				++iov;
				--iovcnt;
			}
			tty_delayed++;
			event_set(&td->td_event, fd, EV_WRITE, ttycb, td);
			to.tv_sec = TTYMSGTIME;
			to.tv_usec = 0;
			event_add(&td->td_event, &to);
			return;
		}
		/*
		 * We get ENODEV on a slip line if we're running as root,
		 * and EIO if the line just went away.
		 */
		if (errno != ENODEV && errno != EIO)
			log_warn("writev tty device \"%s\"", device);
		break;
	}

	(void) close(fd);
	return;
}

void
ttycb(int fd, short event, void *arg)
{
	struct tty_delay	*td = arg;
	struct timeval		 to;
	ssize_t			 wret;

	if (event != EV_WRITE)
		goto done;

	wret = write(fd, td->td_line, td->td_length);
	if (wret < 0 && errno != EINTR && errno != EWOULDBLOCK)
		goto done;
	if (wret > 0) {
		td->td_length -= wret;
		if (td->td_length == 0)
			goto done;
		memmove(td->td_line, td->td_line + wret, td->td_length);
	}
	to.tv_sec = TTYMSGTIME;
	to.tv_usec = 0;
	event_add(&td->td_event, &to);
	return;

 done:
	tty_delayed--;
	close(fd);
	free(td);
}
@


1.15
log
@As we did not have nice log functions before, ttymsg() had to return
the error string.  Log the message when the error happens and make
the function void.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.14 2017/04/05 11:31:45 bluhm Exp $	*/
d34 1
d56 1
a56 1
	char		 td_line[MAXLINE];
d152 2
a153 2
			if (left > MAXLINE)
				left = MAXLINE;
@


1.14
log
@Replace logdebug() with generic log_debug() from log.c.  Implement
log_debugadd() to construct debug message incrementally.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.13 2017/03/24 16:24:36 bluhm Exp $	*/
d63 1
a63 3
 * seconds.  Returns pointer to error string on unexpected error;
 * string is not newline-terminated.  Various "normal" errors are ignored
 * (exclusive-use, lack of permission, etc.).
d65 1
a65 1
char *
a68 1
	static char ebuf[ERRBUFSIZE];
d74 4
a77 2
	if (iovcnt < 0 || (size_t)iovcnt > nitems(localiov))
		return ("too many iov's (change code in syslogd/ttymsg.c)");
d84 1
a84 1
		return (NULL);
d90 2
a91 3
		(void) snprintf(ebuf, sizeof(ebuf), "'/' in \"%s\"",
		    device);
		return (ebuf);
d99 3
a101 5
		if (errno == EBUSY || errno == EACCES)
			return (NULL);
		(void) snprintf(ebuf, sizeof(ebuf),
		    "%s: %s", device, strerror(errno));
		return (ebuf);
d135 3
a137 3
				(void) snprintf(ebuf, sizeof(ebuf),
				    "%s: too many delayed writes", device);
				goto error;
d146 3
a148 3
				(void) snprintf(ebuf, sizeof(ebuf),
				    "%s: malloc: %s", device, strerror(errno));
				goto error;
d168 1
a168 1
			return (NULL);
d174 3
a176 7
		if (errno == ENODEV || errno == EIO)
			break;
		(void) snprintf(ebuf, sizeof(ebuf),
		    "%s: %s", device, strerror(errno));
 error:
		(void) close(fd);
		return (ebuf);
d180 1
a180 1
	return (NULL);
@


1.13
log
@Replace bcopy(3) with memmove(3) in function ttymsg().  Values of
iov and localiov may overlap.  No more bcopy(3) in syslogd(8).
from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.12 2017/03/16 12:14:37 bluhm Exp $	*/
d45 1
d143 1
a143 1
			logdebug("ttymsg delayed write\n");
@


1.12
log
@There was a file descripotor leak in the syslogd(8) ttymsg() error
path.  Before returning early with an error, close the newly opened
file descriptor.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.11 2016/08/16 18:41:57 tedu Exp $	*/
d118 1
a118 1
				bcopy(iov, localiov,
d144 1
a144 1
				bcopy(iov, localiov,
@


1.11
log
@stop including sys/param.h for nitems. define locally as needed.
ok natano reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.10 2016/04/02 19:55:10 krw Exp $	*/
d140 1
a140 1
				return (ebuf);
d151 1
a151 1
				return (ebuf);
a178 1
		(void) close(fd);
d181 2
@


1.10
log
@Eliminate superfluous 3rd params in fcntl(F_GETFL) calls.

ttymsg.c doesn't need to include fcntl.h.

Tweak standard fd sanitising to be more like the sanitise_stdfd()
used elsewhere, though other uses of 'nullfd' make importing
sanitise_stdfd() itself unappetizing.

Add a die(0) if dup2() fails.

suggestions & ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.9 2015/10/23 16:28:52 bluhm Exp $	*/
a32 1
#include <sys/param.h>	/* nitems */
d46 4
@


1.9
log
@If writing to a tty blocks, syslogd forked and tried to write again
in a background process.  A potential fork(2) at every message is
bad, so replace this with an event.  As a bonus the syslogd child
process does not need to pledge "proc" anymore.  Also limit the
number of delayed write events.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.8 2015/10/21 14:03:07 bluhm Exp $	*/
a38 1
#include <fcntl.h>
@


1.8
log
@Do some cleanup in syslogd ttymsg().  Add a debug message when the
syslogd child calls fork(2) to delay blocked output.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.7 2015/07/06 16:12:16 millert Exp $	*/
d38 1
d49 8
d59 1
a59 1
 * Forks and finishes in child if write would block, waiting up to TTYMSGTIME
a72 2
	int forked = 0;
	sigset_t mask;
d132 2
a133 2
			int off = 0;
			pid_t cpid;
d135 4
a138 3
			if (forked) {
				(void) close(fd);
				_exit(1);
d141 6
a146 2
			cpid = fork();
			if (cpid < 0) {
d148 1
a148 2
				    "fork: %s", strerror(errno));
				(void) close(fd);
d151 19
a169 13
			if (cpid) {	/* parent */
				(void) close(fd);
				return (NULL);
			}
			forked++;
			/* wait at most TTYMSGTIME seconds */
			(void) signal(SIGALRM, SIG_DFL);
			(void) signal(SIGTERM, SIG_DFL); /* XXX */
			(void) sigemptyset(&mask);
			(void) sigprocmask(SIG_SETMASK, &mask, NULL);
			(void) alarm((u_int)TTYMSGTIME);
			(void) fcntl(fd, O_NONBLOCK, &off);
			continue;
a177 2
		if (forked)
			_exit(1);
a183 2
	if (forked)
		_exit(0);
d185 30
@


1.7
log
@Remove some unneeded includes.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.6 2015/01/16 06:40:21 deraadt Exp $	*/
a35 2
#include <signal.h>
#include <fcntl.h>
d38 1
d40 1
a40 1
#include <unistd.h>
d42 1
d44 1
a44 1
#include <stdlib.h>
d50 1
a50 1
 * Forks and finishes in child if write would block, waiting up to tmout
d56 1
a56 1
ttymsg(struct iovec *iov, int iovcnt, char *line, int tmout)
d59 3
a61 2
	static char errbuf[1024];
	int cnt, fd, left;
d73 2
a74 2
	if ((strncmp(line, "ftp", 3) == 0) ||
	    (strncmp(line, "uucp", 4) == 0))
d77 1
a77 1
	(void) strlcpy(device + sizeof(_PATH_DEV) - 1, line,
d81 1
a81 1
		(void) snprintf(errbuf, sizeof(errbuf), "'/' in \"%s\"",
d83 1
a83 1
		return (errbuf);
d93 1
a93 1
		(void) snprintf(errbuf, sizeof(errbuf),
d95 1
a95 1
		return (errbuf);
d98 2
a99 1
	for (cnt = left = 0; cnt < iovcnt; ++cnt)
a103 2
		if (wret >= left)
			break;
d105 2
d113 1
a113 1
			for (cnt = 0; (size_t)wret >= iov->iov_len; ++cnt) {
d132 1
d135 1
a135 1
				(void) snprintf(errbuf, sizeof(errbuf),
d138 1
a138 1
				return (errbuf);
d145 1
a145 1
			/* wait at most tmout seconds */
d150 1
a150 1
			(void) alarm((u_int)tmout);
d163 1
a163 1
		(void) snprintf(errbuf, sizeof(errbuf),
d165 1
a165 1
		return (errbuf);
@


1.6
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.5 2014/08/25 18:05:30 bluhm Exp $	*/
a34 2
#include <sys/types.h>
#include <sys/uio.h>
@


1.5
log
@Fix the gcc compiler warnings "comparison between signed and
unsigned".  Some checks got stricter.  The (size_t) cast is only
done, if the argument is not negative.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.4 2009/10/27 23:59:54 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>
@


1.4
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.3 2004/07/03 23:40:44 djm Exp $	*/
d33 2
d37 1
a46 1
#include <sys/stat.h>
d62 2
a63 1
	int cnt, fd, left, wret;
d68 1
a68 1
	if (iovcnt > sizeof(localiov) / sizeof(localiov[0]))
d113 1
a113 1
			for (cnt = 0; wret >= iov->iov_len; ++cnt) {
@


1.3
log
@-Wall,-Wshadow cleanup with avsm@@; ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.2 2003/08/27 00:27:50 avsm Exp $	*/
a31 7

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)ttymsg.c	8.2 (Berkeley) 11/16/93";
#endif
static const char rcsid[] = "$OpenBSD: ttymsg.c,v 1.2 2003/08/27 00:27:50 avsm Exp $";
#endif /* not lint */
@


1.2
log
@correct error message (wall -> syslogd)
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.1 2003/07/31 18:20:07 avsm Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: ttymsg.c,v 1.1 2003/07/31 18:20:07 avsm Exp $";
d123 1
a123 1
				iov->iov_base += wret;
@


1.1
log
@Privilege separated syslog daemon.  The child listening to log requests drops
to user _syslogd and chroots itself, while the privileged parent grants it
access to open logfiles and other calls it needs.

The only difference from existing behaviour is that if syslog.conf changes
and syslogd receives a HUP, it will re-exec itself and have two new PIDs.
A HUP with an unchanged config will make syslogd reopen logfiles as before.

Lots of help and code from deraadt@@ , and advice from millert@@

Various versions tested by todd, cloder, mpech, markus, tdeval and others
@
text
@d1 1
a1 1
/*	$OpenBSD: ttymsg.c,v 1.13 2003/06/26 21:59:10 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: ttymsg.c,v 1.13 2003/06/26 21:59:10 deraadt Exp $";
d73 1
a73 1
		return ("too many iov's (change code in wall/ttymsg.c)");
@

