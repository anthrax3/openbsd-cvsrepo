head	1.6;
access;
symbols
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2002.12.31.16.35.42;	author miod;	state dead;
branches;
next	1.5;

1.5
date	2002.09.06.20.16.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.06.19.52.35;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.02.22.50.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.43.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.35;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.6
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*
 * GSP assembler - symbol table
 *
 * Copyright (c) 1993 Paul Mackerras.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Mackerras.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <string.h>
#include "gsp_ass.h"

#define NHASH	64		/* must be power of 2 */

symbol symbol_hash[NHASH];

symbol
lookup(char *id, bool makeit)
{
	register symbol ptr, p, *pp;
	register int h;
	register char *ip;

	h = 0;
	for( ip = id; *ip != 0; )
		h = (h << 1) + *ip++;
	h &= NHASH-1;
	for( pp = &symbol_hash[h]; (p = *pp) != NULL; pp = &p->next )
		if( (h = strcmp(id, p->name)) == 0 )
			return p;
		else if( h < 0 )
			break;
	if( !makeit )
		return NULL;
	ptr = (symbol) alloc (sizeof(struct symbol) + strlen(id));
	ptr->ndefn = 0;
	ptr->flags = 0;
	ptr->value = 0;
	ptr->lineno = NOT_YET;
	strcpy(ptr->name, id);
	*pp = ptr;
	ptr->next = p;
	ptr->nlab = NULL;
	return ptr;
}

void
define_sym(char *id, unsigned int val, unsigned int lineno, int flags)
{
	register symbol ptr;

	ptr = lookup(id, TRUE);
	if( (ptr->flags & SET_LABEL) == 0 ){
		if( ptr->ndefn >= 2 ){
			perr("Multiply defined label %s", id);
			if( (flags & SET_LABEL) != 0 )
				return;
		} else if( pass2 && ptr->value != val )
			perr("Phase error on label %s (%#x -> %#x)",
				id, ptr->value, val);
	}
	ptr->flags = flags;
	ptr->ndefn += 1;
	ptr->value = val;
	ptr->lineno = lineno;
}

void
set_label(char *id)
{
	if( id != NULL ){
		define_sym(id, pc, lineno, DEFINED);
		if( pass2 )
			do_list_pc();
	}
}

void
do_asg(char *name, expr value, int flags)
{
	int32_t val;
	unsigned int line;

	if( eval_expr(value, &val, &line) )
		flags |= DEFINED;
	if( line < lineno )
		line = lineno;
	define_sym(name, val, line, flags);
	if( pass2 )
		do_show_val(val);
}

void
set_numeric_label(int lnum)
{
	register symbol bp, fp;
	register struct numlab *nl;
	char id[32];

	/* define the backward reference symbol */
	snprintf(id, sizeof id, "%dB", lnum);
	bp = lookup(id, TRUE);
	bp->flags = NUMERIC_LABEL | DEFINED;
	bp->value = pc;
	bp->lineno = lineno;

	/* look up the forward reference symbol */
	id[strlen(id) - 1] = 'F';
	fp = lookup(id, TRUE);

	if( !pass2 ){
		/* Record a new numeric label and link it into the
		   chain.  fp->nlab points to the head of the chain,
		   bp->nlab points to the tail.  */
		ALLOC(nl, struct numlab *);
		nl->value = pc;
		nl->lineno = lineno;
		nl->next = NULL;
		if( bp->nlab == NULL )
			fp->nlab = nl;
		else
			bp->nlab->next = nl;
		bp->nlab = nl;
		fp->flags = NUMERIC_LABEL;
	} else {
		/* Advance to the next numeric label entry in the chain
		   and update the value of the forward reference symbol. */
		if( pc != fp->value )
			perr("Phase error on numeric label %d (%#x -> %#x)",
				lnum, fp->value, pc);
		nl = fp->nlab;
		nl = nl->next;
		if( nl == NULL ){
			/* no more labels of this number */
			/* forward references are now undefined */
			fp->flags &= ~DEFINED;
			fp->lineno = NOT_YET;
			fp->value = 0;
		} else {
			fp->lineno = nl->lineno;
			fp->value = nl->value;
			fp->nlab = nl;
		}
		do_list_pc();
	}
}

/* At the beginning of pass 2, reset all of the numeric labels.
   Backward references become undefined, forward references are defined
   by the first instance of the label. */
void
reset_numeric_labels()
{
	register symbol p;
	register struct numlab *nl;
	register int h;

	for( h = 0; h < NHASH; ++h )
		for( p = symbol_hash[h]; p != NULL; p = p->next )
			if( (p->flags & NUMERIC_LABEL) != 0 ) {
				if( (p->flags & DEFINED) != 0 ){
					/* a backward reference */
					p->flags &= ~DEFINED;
				} else {
					/* a forward reference */
					p->flags |= DEFINED;
					nl = p->nlab;
					p->value = nl->value;
					p->lineno = nl->lineno;
				}
			}
}
@


1.5
log
@first cut at -Wall
@
text
@@


1.4
log
@compile with -ansi
@
text
@d71 1
a71 1
define_sym(char *id, unsigned val, unsigned lineno, int flags)
d105 1
a105 1
	unsigned line;
d124 1
a124 1
	sprintf(id, "%dB", lnum);
d183 1
a183 1
			if( (p->flags & NUMERIC_LABEL) != 0 )
d194 1
@


1.3
log
@withough -> without
@
text
@d138 1
a138 1
		new(nl);
@


1.2
log
@use string.h
@
text
@d19 1
a19 1
 *    derived from this software withough specific prior written permission
@


1.1
log
@Initial revision
@
text
@d32 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
