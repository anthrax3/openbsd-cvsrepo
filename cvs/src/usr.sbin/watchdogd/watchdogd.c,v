head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.10
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.8
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.10
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.8
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.14
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.12
	OPENBSD_5_0:1.13.0.10
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.8
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.6
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.15
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Uu5nFG3wCl0LACBb;

1.14
date	2012.12.18.21.28.45;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.24.14.28.19;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.02.22.46.37;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.23.10.37.33;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.21.15.51.54;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.04.11.04.55;	author mbalmer;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.26.06.16.09;	author mbalmer;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.17.11.38.50;	author mbalmer;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.24.17.39.52;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.09.15.09.06;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.08.13.08.09;	author mbalmer;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.08.12.48.06;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.08.12.08.56;	author mbalmer;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: watchdogd.c,v 1.14 2012/12/18 21:28:45 millert Exp $ */

/*
 * Copyright (c) 2005 Marc Balmer <mbalmer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/resource.h>
#include <sys/signal.h>
#include <sys/sysctl.h>
#include <sys/mman.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

volatile sig_atomic_t	quit = 0;

__dead void	usage(void);
void		sighdlr(int);
int		main(int, char *[]);

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dnq] [-i interval] [-p period]\n",
	    __progname);
	exit(1);
}

/* ARGSUSED */
void
sighdlr(int signum)
{
	quit = 1;
}

int
main(int argc, char *argv[])
{
	struct rlimit	 rlim;
	const char	*errstr;
	size_t		 len;
	u_int		 interval = 0, period = 30, nperiod;
	int		 ch, trigauto, sauto, speriod;
	int		 quiet = 0, daemonize = 1, retval = 1, do_restore = 1;
	int		 mib[3];

	while ((ch = getopt(argc, argv, "di:np:q")) != -1) {
		switch (ch) {
		case 'd':
			daemonize = 0;
			break;
		case 'i':
			interval = (u_int)strtonum(optarg, 1LL, 86400LL,
			    &errstr);
			if (errstr)
				errx(1, "interval is %s: %s", errstr, optarg);
			break;
		case 'n':
			do_restore = 0;
			break;
		case 'p':
			period = (u_int)strtonum(optarg, 2LL, 86400LL, &errstr);
			if (errstr)
				errx(1, "period is %s: %s", errstr, optarg);
			break;
		case 'q':
			quiet = 1;
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	if (interval == 0 && (interval = period / 3) == 0)
		interval = 1;

	if (period <= interval)
		errx(1, "retrigger interval too long");

	/* save kern.watchdog.period and kern.watchdog.auto for restore */
	mib[0] = CTL_KERN;
	mib[1] = KERN_WATCHDOG;
	mib[2] = KERN_WATCHDOG_PERIOD;

	len = sizeof(speriod);
	if (sysctl(mib, 3, &speriod, &len, &period, sizeof(period)) == -1) {
		if (errno == EOPNOTSUPP)
			errx(1, "no watchdog timer available");
		else
			err(1, "can't access kern.watchdog.period");
	}

	mib[2] = KERN_WATCHDOG_AUTO;
	len = sizeof(sauto);
	trigauto = 0;

	if (sysctl(mib, 3, &sauto, &len, &trigauto, sizeof(trigauto)) == -1)
		err(1, "can't access kern.watchdog.auto");

	/* Double check the timeout period, some devices change the value */
	mib[2] = KERN_WATCHDOG_PERIOD;
	len = sizeof(nperiod);
	if (sysctl(mib, 3, &nperiod, &len, NULL, 0) == -1) {
		warnx("can't read back kern.watchdog.period, "
		    "restoring original values");
		goto restore;
	}

	if (nperiod != period && !quiet)
		warnx("period adjusted to %d by device", nperiod);

	if (nperiod <= interval) {
		warnx("retrigger interval %d too long, "
		    "restoring original values", interval);
		goto restore;
	}

	if (daemonize && daemon(0, 0)) {
		warn("can't daemonize, restoring original values");
		goto restore;
	}

	/*
	 * mlockall() below will wire the whole stack up to the limit
	 * thus we have to reduce stack size to avoid resource abuse
	 */
	rlim.rlim_cur = 256 * 1024;
	rlim.rlim_max = 256 * 1024;
	(void)setrlimit(RLIMIT_STACK, &rlim);

	(void)mlockall(MCL_CURRENT | MCL_FUTURE);
	setpriority(PRIO_PROCESS, getpid(), -5);

	signal(SIGTERM, sighdlr);

	retval = 0;
	while (!quit) {
		if (sysctl(mib, 3, NULL, 0, &period, sizeof(period)) == -1)
			quit = retval = 1;
		sleep(interval);
	}

	if (do_restore) {
restore:	sysctl(mib, 3, NULL, 0, &speriod, sizeof(speriod));
		mib[2] = KERN_WATCHDOG_AUTO;
		sysctl(mib, 3, NULL, 0, &sauto, sizeof(sauto));
	}

	return retval;
}
@


1.14
log
@We no longer use struct eproc for kinfo_proc in sysctl.h so there
is no direct need for sys/proc.h or sys/resource.h.  Some consumers
of kinfo_proc need these for the proc flags and rlimit defines like
RLIM_INF so add the appropriate includes to them.
OK deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.13 2009/06/24 14:28:19 sthen Exp $ */
d19 1
a19 1
#include <sys/param.h>
d21 1
@


1.13
log
@Lower stack size before mlockall(). With login.conf defaults for i386,
this avoids wiring (8MB-256KB).  From AerieBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.12 2008/05/12 19:15:02 pyr Exp $ */
d20 1
@


1.12
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.11 2007/01/02 22:46:37 mbalmer Exp $ */
d55 1
d143 8
@


1.11
log
@tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.10 2006/12/23 10:37:33 mbalmer Exp $ */
d88 5
@


1.10
log
@Do not name both a variable and a goto target 'restore'; it's legal, but
confusing.  at least it confused thib...
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.9 2006/12/21 15:51:54 mbalmer Exp $ */
d156 1
a156 1
	return (retval);
@


1.9
log
@Let watchdogd use the new watchdog(4) semantics.  When the new option -n
(no restore) is specified, the watchdog will not be restored to it's
original values when watchdogd terminates.

that means, when watchdogd is run with -n and you 'halt' the system, the
watchdog hardware will reset it.  which is wanted when the machine is
remote and the system shuts down unplanned.

"looks ok" markus
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.8 2006/08/04 11:04:55 mbalmer Exp $ */
d59 1
a59 1
	int		 quiet = 0, daemonize = 1, retval = 1, restore = 1;
d74 1
a74 1
			restore = 0;
d150 1
a150 1
	if (restore) {
@


1.8
log
@Add a '-q' option to suppress warning messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.7 2006/06/26 06:16:09 mbalmer Exp $ */
d40 1
a40 1
	fprintf(stderr, "usage: %s [-dq] [-i interval] [-p period]\n",
d59 1
a59 1
	int		 quiet = 0, daemonize = 1, retval = 1;
d62 1
a62 1
	while ((ch = getopt(argc, argv, "di:p:q")) != -1) {
d73 3
d150 5
a154 4
restore:
	sysctl(mib, 3, NULL, 0, &speriod, sizeof(speriod));
	mib[2] = KERN_WATCHDOG_AUTO;
	sysctl(mib, 3, NULL, 0, &sauto, sizeof(sauto));
@


1.7
log
@Code cleanup/shortening.  No binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.6 2006/01/17 11:38:50 mbalmer Exp $ */
d40 1
a40 1
	fprintf(stderr, "usage: %s [-d] [-i interval] [-p period]\n",
d59 1
a59 1
	int		 daemonize = 1, retval = 1;
d62 1
a62 1
	while ((ch = getopt(argc, argv, "di:p:")) != -1) {
d78 3
d121 1
a121 1
	if (nperiod != period)
@


1.6
log
@Use the @@openbsd.org email address for the copyright and add an AUTHORS
section.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.5 2005/09/24 17:39:52 mickey Exp $ */
d45 1
d57 1
a57 1
	u_int		 interval, period, nperiod;
d59 1
a59 1
	int		 daemonize, retval;
a61 5
	interval = 0;
	period = 30;
	daemonize = 1;
	retval = 1;

d68 2
a69 1
			interval = (int)strtonum(optarg, 1LL, 86400LL, &errstr);
d74 1
a74 1
			period = (int)strtonum(optarg, 2LL, 86400LL, &errstr);
a79 1
			/* NOTREACHED */
@


1.5
log
@give it a bit highr priority and exit w/ failure if systcl ever fails; marc@@ henning@@ ok some time ago...
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.4 2005/08/09 15:09:06 mickey Exp $ */
d4 1
a4 1
 * Copyright (c) 2005 Marc Balmer <marc@@msys.ch>
@


1.4
log
@link static and mlockall() once daemonised to prevent sudden pageins and wdog misfire; discussed a lot at wtf; mbalmer@@ art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.3 2005/08/08 13:08:09 mbalmer Exp $ */
d137 1
d144 1
a144 1
			quit = 1;
@


1.3
log
@Use unsigned integers for period and nperiod.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.2 2005/08/08 12:48:06 henning Exp $ */
d135 2
@


1.2
log
@function prototypes, spacing, KNF, and other readability fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: watchdogd.c,v 1.1 2005/08/08 12:08:56 mbalmer Exp $ */
d56 2
a57 2
	u_int		 interval;
	int		 ch, period, nperiod, trigauto, sauto, speriod;
@


1.1
log
@Initial import of watchdogd, a daemon to retrigger the watchdog timer
from userland (not yet linked to the build process).

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d29 5
a33 1
volatile sig_atomic_t quit = 0;
d54 6
a59 10
	int ch;
	unsigned int interval;
	int period, nperiod;
	int trigauto;
	int sauto, speriod;
	size_t len;
	int mib[3];
	const char *errstr;
	int daemonize;
	int retval;
d87 2
a88 5
	if (interval == 0) {
		interval = period / 3;
		if (interval == 0)
			interval = 1;
	}
a93 1

a106 1

d111 1
a111 1
		err(1, "can't access kern.watchdog.auto"); 
a113 1

d150 1
a150 1
	return retval; 
@

