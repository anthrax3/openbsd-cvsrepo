head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.12
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.8
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.4
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.16
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.14
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.4
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.21
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.20;
commitid	2uw1UTO4k6erpWzK;

1.20
date	2011.03.25.08.52.21;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.31.08.55.00;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.25.08.33.00;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.13.09.36.06;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.12.18.18.24;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.19.13.07.58;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.27.02.24.42;	author norby;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.26.23.42.18;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.26.20.00.14;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.26.19.54.49;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.25.22.05.58;	author norby;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.05.13.01.21;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.17.21.17.12;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.08.12.56.48;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.02.19.29.15;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@/*	$OpenBSD: lsack.c,v 1.20 2011/03/25 08:52:21 claudio Exp $ */

/*
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>

#include <stdlib.h>
#include <string.h>

#include "ospfd.h"
#include "ospf.h"
#include "log.h"
#include "ospfe.h"

int		 send_ls_ack(struct iface *, struct in_addr, struct ibuf *);
struct ibuf	*prepare_ls_ack(struct iface *);
void		 start_ls_ack_tx_timer_now(struct iface *);

/* link state acknowledgement packet handling */
struct ibuf *
prepare_ls_ack(struct iface *iface)
{
	struct ibuf	*buf;

	if ((buf = ibuf_open(iface->mtu - sizeof(struct ip))) == NULL) {
		log_warn("prepare_ls_ack");
		return (NULL);
	}

	/* OSPF header */
	if (gen_ospf_hdr(buf, iface, PACKET_TYPE_LS_ACK)) {
		log_warn("prepare_ls_ack");
		ibuf_free(buf);
		return (NULL);
	}

	return (buf);
}

int
send_ls_ack(struct iface *iface, struct in_addr addr, struct ibuf *buf)
{
	struct sockaddr_in	dst;
	int			ret;

	/* update authentication and calculate checksum */
	if (auth_gen(buf, iface)) {
		log_warn("send_ls_ack");
		return (-1);
	}

	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);
	dst.sin_addr.s_addr = addr.s_addr;

	ret = send_packet(iface, buf, &dst);
	return (ret);
}

int
send_direct_ack(struct iface *iface, struct in_addr addr, void *d, size_t len)
{
	struct ibuf	*buf;
	int		 ret;

	if ((buf = prepare_ls_ack(iface)) == NULL)
		return (-1);

	/* LS ack(s) */
	if (ibuf_add(buf, d, len)) {
		log_warn("send_direct_ack");
		ibuf_free(buf);
		return (-1);
	}

	ret = send_ls_ack(iface, addr, buf);
	ibuf_free(buf);
	return (ret);
}

void
recv_ls_ack(struct nbr *nbr, char *buf, u_int16_t len)
{
	struct lsa_hdr	 lsa_hdr;

	switch (nbr->state) {
	case NBR_STA_DOWN:
	case NBR_STA_ATTEMPT:
	case NBR_STA_INIT:
	case NBR_STA_2_WAY:
	case NBR_STA_XSTRT:
	case NBR_STA_SNAP:
		log_debug("recv_ls_ack: packet ignored in state %s, "
		    "neighbor ID %s", nbr_state_name(nbr->state),
		    inet_ntoa(nbr->id));
		break;
	case NBR_STA_XCHNG:
	case NBR_STA_LOAD:
	case NBR_STA_FULL:
		while (len >= sizeof(lsa_hdr)) {
			memcpy(&lsa_hdr, buf, sizeof(lsa_hdr));

			if (lsa_hdr_check(nbr, &lsa_hdr)) {
				/* try both list in case of DROTHER */
				if (nbr->iface->state & IF_STA_DROTHER)
					(void)ls_retrans_list_del(
					    nbr->iface->self, &lsa_hdr);
				(void)ls_retrans_list_del(nbr, &lsa_hdr);
			}

			buf += sizeof(lsa_hdr);
			len -= sizeof(lsa_hdr);
		}
		if (len > 0) {
			log_warnx("recv_ls_ack: bad packet size, "
			    "neighbor ID %s", inet_ntoa(nbr->id));
			return;
		}
		break;
	default:
		fatalx("recv_ls_ack: unknown neighbor state");
	}
}

int
lsa_hdr_check(struct nbr *nbr, struct lsa_hdr *lsa_hdr)
{
	/* invalid age */
	if ((ntohs(lsa_hdr->age) < 1) || (ntohs(lsa_hdr->age) > MAX_AGE)) {
		log_debug("lsa_hdr_check: invalid age, neighbor ID %s",
		     inet_ntoa(nbr->id));
		return (0);
	}

	/* invalid type */
	switch (lsa_hdr->type) {
	case LSA_TYPE_ROUTER:
	case LSA_TYPE_NETWORK:
	case LSA_TYPE_SUM_NETWORK:
	case LSA_TYPE_SUM_ROUTER:
	case LSA_TYPE_EXTERNAL:
		break;
	default:
		log_debug("lsa_hdr_check: invalid LSA type %d, neighbor ID %s",
		    lsa_hdr->type, inet_ntoa(nbr->id));
		return (0);
	}

	/* invalid sequence number */
	if (ntohl(lsa_hdr->seq_num) == RESV_SEQ_NUM) {
		log_debug("ls_hdr_check: invalid seq num, neighbor ID %s",
			inet_ntoa(nbr->id));
		return (0);
	}

	return (1);
}

/* link state ack list */
void
ls_ack_list_add(struct iface *iface, struct lsa_hdr *lsa)
{
	struct lsa_entry	*le;

	if (lsa == NULL)
		fatalx("ls_ack_list_add: no LSA header");

	if ((le = calloc(1, sizeof(*le))) == NULL)
		fatal("ls_ack_list_add");

	if (ls_ack_list_empty(iface))
		start_ls_ack_tx_timer(iface);

	TAILQ_INSERT_TAIL(&iface->ls_ack_list, le, entry);
	le->le_lsa = lsa;
	iface->ls_ack_cnt++;

	/* reschedule now if we have enough for a reasonably sized packet */
	if (iface->ls_ack_cnt > IP_MSS / sizeof(struct lsa_hdr))
		start_ls_ack_tx_timer_now(iface);
}

void
ls_ack_list_free(struct iface *iface, struct lsa_entry *le)
{
	TAILQ_REMOVE(&iface->ls_ack_list, le, entry);
	free(le->le_lsa);
	free(le);

	iface->ls_ack_cnt--;
}

void
ls_ack_list_clr(struct iface *iface)
{
	struct lsa_entry	*le;

	while ((le = TAILQ_FIRST(&iface->ls_ack_list)) != NULL) {
		TAILQ_REMOVE(&iface->ls_ack_list, le, entry);
		free(le->le_lsa);
		free(le);
	}
	iface->ls_ack_cnt = 0;
}

int
ls_ack_list_empty(struct iface *iface)
{
	return (TAILQ_EMPTY(&iface->ls_ack_list));
}

/* timers */
/* ARGSUSED */
void
ls_ack_tx_timer(int fd, short event, void *arg)
{
	struct in_addr		 addr;
	struct iface		*iface = arg;
	struct lsa_entry	*le, *nle;
	struct nbr		*nbr;
	struct ibuf		*buf;
	int			 cnt;

	while (!ls_ack_list_empty(iface)) {
		if ((buf = prepare_ls_ack(iface)) == NULL)
			fatal("ls_ack_tx_timer");
		cnt = 0;

		for (le = TAILQ_FIRST(&iface->ls_ack_list); le != NULL;
		    le = nle) {
			nle = TAILQ_NEXT(le, entry);
			if (ibuf_left(buf) < sizeof(struct lsa_hdr) +
			    MD5_DIGEST_LENGTH)
				break;
			if (ibuf_add(buf, le->le_lsa, sizeof(struct lsa_hdr)))
				break;
			ls_ack_list_free(iface, le);
			cnt++;
		}
		if (cnt == 0) {
			log_warnx("ls_ack_tx_timer: lost in space");
			ibuf_free(buf);
			return;
		}

		/* send LS ack(s) but first set correct destination */
		switch (iface->type) {
		case IF_TYPE_POINTOPOINT:
			inet_aton(AllSPFRouters, &addr);
			send_ls_ack(iface, addr, buf);
			break;
		case IF_TYPE_BROADCAST:
			if (iface->state & IF_STA_DRORBDR)
				inet_aton(AllSPFRouters, &addr);
			else
				inet_aton(AllDRouters, &addr);
			send_ls_ack(iface, addr, buf);
			break;
		case IF_TYPE_NBMA:
		case IF_TYPE_POINTOMULTIPOINT:
		case IF_TYPE_VIRTUALLINK:
			LIST_FOREACH(nbr, &iface->nbr_list, entry) {
				if (nbr == iface->self)
					continue;
				if (!(nbr->state & NBR_STA_FLOOD))
					continue;
				send_ls_ack(iface, nbr->addr, buf);
			}
			break;
		default:
			fatalx("lsa_ack_tx_timer: unknown interface type");
		}
		ibuf_free(buf);
	}
}

void
start_ls_ack_tx_timer(struct iface *iface)
{
	struct timeval tv;

	timerclear(&tv);
	tv.tv_sec = iface->rxmt_interval / 2;

	if (evtimer_add(&iface->lsack_tx_timer, &tv) == -1)
		fatal("start_ls_ack_tx_timer");
}

void
start_ls_ack_tx_timer_now(struct iface *iface)
{
	struct timeval tv;

	timerclear(&tv);
	if (evtimer_add(&iface->lsack_tx_timer, &tv) == -1)
		fatal("start_ls_ack_tx_timer_now");
}

void
stop_ls_ack_tx_timer(struct iface *iface)
{
	if (evtimer_del(&iface->lsack_tx_timer) == -1)
		fatal("stop_ls_ack_tx_timer");
}
@


1.20
log
@Rewrite the lsack generation. Make it more like the lsupdate code.
Removes some of the rather strange packet handling.
Tested by a few especially sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.19 2010/05/26 13:56:08 nicm Exp $ */
a21 1
#include <netinet/in_systm.h>
@


1.19
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.18 2009/01/31 08:55:00 claudio Exp $ */
d34 3
a36 1
void	 start_ls_ack_tx_timer_now(struct iface *);
d39 20
d60 1
a60 1
send_ls_ack(struct iface *iface, struct in_addr addr, void *data, size_t len)
d62 2
a63 3
	struct sockaddr_in	 dst;
	struct ibuf		*buf;
	int			 ret;
d65 5
a69 3
	/* XXX IBUF_READ_SIZE */
	if ((buf = ibuf_dynamic(PKG_DEF_SIZE, READ_BUF_SIZE)) == NULL)
		fatal("send_ls_ack");
d75 3
a77 3
	/* OSPF header */
	if (gen_ospf_hdr(buf, iface, PACKET_TYPE_LS_ACK))
		goto fail;
d79 5
a83 3
	/* LS ack(s) */
	if (ibuf_add(buf, data, len))
		goto fail;
d85 2
a86 3
	/* update authentication and calculate checksum */
	if (auth_gen(buf, iface))
		goto fail;
d88 6
a93 1
	ret = send_packet(iface, buf, &dst);
d95 1
a97 4
fail:
	log_warn("send_ls_ack");
	ibuf_free(buf);
	return (-1);
d197 2
a198 3
	/* reschedule now if we have enough for a full packet */
	if (iface->ls_ack_cnt >
	    ((iface->mtu - PACKET_HDR) / sizeof(struct lsa_hdr))) {
a199 2
	}

a237 1
	struct lsa_hdr		*lsa_hdr;
d240 2
a241 6
	char			*buf;
	char			*ptr;
	int			 cnt = 0;

	if ((buf = calloc(1, READ_BUF_SIZE)) == NULL)
		fatal("ls_ack_tx_timer");
d244 2
a245 1
		ptr = buf;
d247 3
a249 2
		for (le = TAILQ_FIRST(&iface->ls_ack_list); le != NULL &&
		    (ptr - buf < iface->mtu - PACKET_HDR); le = nle) {
d251 5
a255 2
			memcpy(ptr, le->le_lsa, sizeof(struct lsa_hdr));
			ptr += sizeof(*lsa_hdr);
d259 5
d269 1
a269 1
			send_ls_ack(iface, addr, buf, ptr - buf);
d276 1
a276 1
			send_ls_ack(iface, addr, buf, ptr - buf);
d286 1
a286 1
				send_ls_ack(iface, nbr->addr, buf, ptr - buf);
d292 1
a293 2

	free(buf);
@


1.18
log
@Pass the buffer to send_packet() instead of spliting it up. This removes
some direct access to struct buf internals in the rest of ospfe.
Based on a larger buffer cleanup diff that was OK norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.17 2006/04/25 08:33:00 claudio Exp $ */
d41 1
a41 1
	struct buf		*buf;
d44 2
a45 2
	/* XXX READ_BUF_SIZE */
	if ((buf = buf_dynamic(PKG_DEF_SIZE, READ_BUF_SIZE)) == NULL)
d57 1
a57 1
	if (buf_add(buf, data, len))
d66 1
a66 1
	buf_free(buf);
d70 1
a70 1
	buf_free(buf);
@


1.17
log
@Use size_t for buffer lenght passed to send_ls_ack() plus an ARGSUSED.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.16 2006/03/13 09:36:06 claudio Exp $ */
d64 1
a64 1
	ret = send_packet(iface, buf->buf, buf->wpos, &dst);
@


1.16
log
@The return value of the start/stop timer functions is almost never checked.
Switch them to void functions and check if evtimer_add/del fails -- in which
case we fatal() as there is no useful way to recover in such an event.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.15 2005/11/12 18:18:24 deraadt Exp $ */
d38 1
a38 1
send_ls_ack(struct iface *iface, struct in_addr addr, void *data, int len)
d209 1
@


1.15
log
@spacing mostly
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.14 2005/10/19 13:07:58 stevesk Exp $ */
d34 1
a34 1
int	 start_ls_ack_tx_timer_now(struct iface *);
d99 3
a101 3
					ls_retrans_list_del(nbr->iface->self,
					    &lsa_hdr);
				ls_retrans_list_del(nbr, &lsa_hdr);
d268 1
a268 1
int
d276 2
a277 1
	return (evtimer_add(&iface->lsack_tx_timer, &tv));
d280 1
a280 1
int
d286 2
a287 2

	return (evtimer_add(&iface->lsack_tx_timer, &tv));
d290 1
a290 1
int
d293 2
a294 1
	return (evtimer_del(&iface->lsack_tx_timer));
@


1.14
log
@use string.h; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.13 2005/05/27 02:24:42 norby Exp $ */
a115 2

	return;
@


1.13
log
@Nasty bug!
Found during the development of virtual link support.
Personally I spend 3 hours chasing this, and I didn't find it.
Claudio spend 2 hours and he found it, credit goes to him :-)

It is wise to put the payload you just created onto the wire, instead
of putting some freshly 0'ed bytes....

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.12 2005/05/26 23:42:18 claudio Exp $ */
d27 1
a27 1
#include <strings.h>
@


1.12
log
@Unnecessary ()
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.11 2005/05/26 20:00:14 norby Exp $ */
d259 1
a259 1
				send_ls_ack(iface, nbr->addr, ptr, ptr - buf);
@


1.11
log
@Remove unneeded debugging stuff when handling LS ack.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.10 2005/05/26 19:54:49 norby Exp $ */
d229 2
a230 2
		for (le = TAILQ_FIRST(&iface->ls_ack_list); (le != NULL) &&
		    ((ptr - buf) < iface->mtu - PACKET_HDR); le = nle) {
@


1.10
log
@Simplify and cleanup passive interface handling.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.9 2005/05/25 22:05:58 norby Exp $ */
a43 3
	log_debug("send_ls_ack: interface %s addr %s",
	    iface->name, inet_ntoa(addr));

a78 2
	log_debug("recv_ls_ack: neighbor ID %s", inet_ntoa(nbr->id));

a92 3
		log_debug("recv_ls_ack: state %s, neighbor ID %s",
		    nbr_state_name(nbr->state), inet_ntoa(nbr->id));

a237 3
		log_debug("ls_ack_tx_timer: sending %d ack(s), interface %s",
		    cnt, iface->name);

a274 1
	log_debug("start_ls_ack_tx_timer: interface %s", iface->name);
d277 1
a285 1
	log_debug("start_ls_ack_tx_timer_now: interface %s", iface->name);
a293 2
	log_debug("stop_ls_ack_tx_timer: interface %s", iface->name);

@


1.9
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.8 2005/04/05 13:01:21 claudio Exp $ */
a45 3

	if (iface->passive)
		return (0);
@


1.8
log
@Use the dynamic buffer API for packet generation and sending.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.7 2005/03/22 22:13:48 norby Exp $ */
d277 1
a277 1
			fatalx("lsa_flood: unknown interface type");
@


1.7
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.6 2005/03/17 21:17:12 claudio Exp $ */
d41 2
a42 3
	char			*buf;
	char			*ptr;
	int			 ret = 0;
d50 2
a51 2
	/* XXX use buffer API instead for better decoupling */
	if ((ptr = buf = calloc(1, READ_BUF_SIZE)) == NULL)
d59 2
a60 2
	gen_ospf_hdr(ptr, iface, PACKET_TYPE_LS_ACK);
	ptr += sizeof(struct ospf_hdr);
d63 2
a64 2
	memcpy(ptr, data, len);		/* XXX size check ??? */
	ptr += len;
d67 2
a68 1
	auth_gen(buf, ptr - buf, iface);
d70 1
a70 3
	if ((ret = send_packet(iface, buf, (ptr - buf), &dst)) == -1)
		log_warnx("send_ls_ack: error sending packet on "
		    "interface %s", iface->name);
d72 1
a72 1
	free(buf);
d74 4
@


1.6
log
@Handle the retransmission queues correctly. Mainly iface state DROTHER
needs to be handled specially because the backup DR does not send acks and
so his retransmission queue fills up and does not get cleared.
Also implement the retransmission timeout correctly.

OK henning@@ norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.5 2005/02/08 12:56:48 claudio Exp $ */
d213 1
a213 1
bool
@


1.5
log
@The LSA seq_num should be unsigned as it is expected by ntohl/htonl() even
though the seq_num needs to be compared as signed number.
No idea how IETF came up with such a stupid idea especially because the
seq_num is not allowed to wrap.
requested by henning@@ OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.4 2005/02/02 19:29:15 henning Exp $ */
d105 5
a109 1
			if (lsa_hdr_check(nbr, &lsa_hdr))
d111 1
@


1.4
log
@excessive ()
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.3 2005/02/02 19:15:07 henning Exp $ */
d149 1
a149 1
	if (ntohl(lsa_hdr->seq_num) == 0x80000000) {
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d149 1
a149 1
	if ((ntohl(lsa_hdr->seq_num) == 0x80000000)) {
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsack.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d178 1
a178 1
	if (iface->ls_ack_cnt  > 
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2004, 2005 Esben Norby <esben.norby@@ericsson.com>
@

