head	1.94;
access;
symbols
	OPENBSD_6_1_BASE:1.94
	OPENBSD_6_0:1.89.0.4
	OPENBSD_6_0_BASE:1.89
	OPENBSD_5_9:1.89.0.2
	OPENBSD_5_9_BASE:1.89
	OPENBSD_5_8:1.85.0.4
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.83.0.2
	OPENBSD_5_7_BASE:1.83
	OPENBSD_5_6:1.81.0.4
	OPENBSD_5_6_BASE:1.81
	OPENBSD_5_5:1.80.0.4
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.79.0.2
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.78.0.6
	OPENBSD_5_3_BASE:1.78
	OPENBSD_5_2:1.78.0.4
	OPENBSD_5_2_BASE:1.78
	OPENBSD_5_1_BASE:1.78
	OPENBSD_5_1:1.78.0.2
	OPENBSD_5_0:1.77.0.2
	OPENBSD_5_0_BASE:1.77
	OPENBSD_4_9:1.75.0.2
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.74.0.2
	OPENBSD_4_8_BASE:1.74
	OPENBSD_4_7:1.73.0.2
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.70.0.4
	OPENBSD_4_6_BASE:1.70
	OPENBSD_4_5:1.60.0.2
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.57.0.2
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.56.0.2
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9;
locks; strict;
comment	@ * @;


1.94
date	2017.01.24.04.24.25;	author benno;	state Exp;
branches;
next	1.93;
commitid	PUkGTVeidQeu8XjZ;

1.93
date	2016.09.28.14.39.52;	author krw;	state Exp;
branches;
next	1.92;
commitid	VsoFRUtzDouNG1Ir;

1.92
date	2016.09.04.10.10.23;	author krw;	state Exp;
branches;
next	1.91;
commitid	rZNIXRmah2G4uMab;

1.91
date	2016.09.03.10.22.57;	author renato;	state Exp;
branches;
next	1.90;
commitid	N55V2Rf3b7gYYZ14;

1.90
date	2016.09.02.14.02.48;	author benno;	state Exp;
branches;
next	1.89;
commitid	ZCYScyTMvHGcp7WF;

1.89
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.88;
commitid	LQHdRRMF0nq0fugE;

1.88
date	2015.12.05.12.20.13;	author claudio;	state Exp;
branches;
next	1.87;
commitid	ev1fE7U8gIdVx8OS;

1.87
date	2015.12.03.11.41.06;	author claudio;	state Exp;
branches;
next	1.86;
commitid	Rtzon3iP98l2jBUz;

1.86
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.85;
commitid	kLBPo9HaQrkEaNW3;

1.85
date	2015.07.20.23.45.39;	author benno;	state Exp;
branches;
next	1.84;
commitid	5hkliGAgtkCCmQz6;

1.84
date	2015.03.14.02.22.09;	author claudio;	state Exp;
branches;
next	1.83;
commitid	fXmmDzNCmmCnJGkB;

1.83
date	2015.02.10.05.24.48;	author claudio;	state Exp;
branches;
next	1.82;
commitid	4XccNzu2mQpqfy01;

1.82
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	Uu5nFG3wCl0LACBb;

1.81
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.80;
commitid	lIxCxHhVEpsmXOdi;

1.80
date	2013.11.13.20.43.00;	author benno;	state Exp;
branches;
next	1.79;

1.79
date	2013.03.22.11.29.01;	author sthen;	state Exp;
branches;
next	1.78;

1.78
date	2011.08.20.11.16.09;	author sthen;	state Exp;
branches;
next	1.77;

1.77
date	2011.05.06.13.50.37;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2011.03.24.08.35.59;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2010.09.02.14.03.22;	author sobrado;	state Exp;
branches;
next	1.74;

1.74
date	2010.05.14.08.30.18;	author sthen;	state Exp;
branches;
next	1.73;

1.73
date	2010.02.19.10.35.52;	author dlg;	state Exp;
branches;
next	1.72;

1.72
date	2010.02.16.18.16.40;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2009.11.02.20.20.54;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.06.07.31.26;	author eric;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.05.19.33.59;	author pyr;	state Exp;
branches;
next	1.68;

1.68
date	2009.06.05.04.12.52;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2009.05.31.18.46.01;	author jacekm;	state Exp;
branches;
next	1.66;

1.66
date	2009.05.31.16.58.54;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2009.05.15.15.55.07;	author mpf;	state Exp;
branches;
next	1.64;

1.64
date	2009.04.07.14.57.33;	author reyk;	state Exp;
branches;
next	1.63;

1.63
date	2009.03.27.14.37.26;	author michele;	state Exp;
branches;
next	1.62;

1.62
date	2009.03.24.19.26.13;	author michele;	state Exp;
branches;
next	1.61;

1.61
date	2009.03.01.16.03.12;	author michele;	state Exp;
branches;
next	1.60;

1.60
date	2009.01.07.21.16.36;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2009.01.01.20.44.06;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.24.18.28.02;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.25.12.06.30;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.20.13.29.44;	author pyr;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.14.19.35.01;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.13.16.35.22;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.11.12.16.45;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.01.08.35.12;	author norby;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.25.11.25.41;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2007.09.18.16.59.08;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.25.19.11.27;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.19.14.42.09;	author pyr;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.29.22.08.25;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2007.03.25.15.48.54;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2007.03.21.10.54.30;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.17.22.28.58;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2007.03.16.10.56.31;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.01.13.25.28;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.01.13.02.04;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.20.17.13.36;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.21.17.22.29;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.07.19.14.27;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.01.13.20.18;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.06.12.35.44;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.03.13.05.02;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.31.03.24.06;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.30.22.06.14;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.27.11.57.24;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.25.09.34.13;	author norby;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.14.16.14.30;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.08.16.02.59;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.10.18.30.47;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.12.15.10.02;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.29.13.58.49;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.18.15.40.36;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.15.18.58.47;	author norby;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.21.19.10.22;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.26.22.05.14;	author norby;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.26.18.46.16;	author norby;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.23.22.54.05;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.25.09.28.45;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.19.07.34.52;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.17.21.50.18;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.26.13.53.51;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.26.13.39.50;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.26.13.35.16;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.26.11.04.28;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.25.13.39.10;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.25.13.35.24;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.15.22.03.56;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.08.20.12.18;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.07.10.28.14;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.27.08.21.15;	author norby;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.24.16.28.43;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.07.05.51.00;	author david;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.18.52.32;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.94
log
@sync log.c from relayd et al to ospfd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@
@
text
@/*	$OpenBSD: ospfd.c,v 1.93 2016/09/28 14:39:52 krw Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/sysctl.h>
#include <syslog.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <event.h>
#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>

#include "ospfd.h"
#include "ospf.h"
#include "ospfe.h"
#include "control.h"
#include "log.h"
#include "rde.h"

void		main_sig_handler(int, short, void *);
__dead void	usage(void);
__dead void	ospfd_shutdown(void);

void	main_dispatch_ospfe(int, short, void *);
void	main_dispatch_rde(int, short, void *);

int	ospf_reload(void);
int	ospf_sendboth(enum imsg_type, void *, u_int16_t);
int	merge_interfaces(struct area *, struct area *);
struct iface *iface_lookup(struct area *, struct iface *);

int	pipe_parent2ospfe[2];
int	pipe_parent2rde[2];
int	pipe_ospfe2rde[2];

struct ospfd_conf	*ospfd_conf = NULL;
struct imsgev		*iev_ospfe;
struct imsgev		*iev_rde;
char			*conffile;

pid_t			 ospfe_pid = 0;
pid_t			 rde_pid = 0;

/* ARGSUSED */
void
main_sig_handler(int sig, short event, void *arg)
{
	/* signal handler rules don't apply, libevent decouples for us */
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		ospfd_shutdown();
		/* NOTREACHED */
	case SIGHUP:
		if (ospf_reload() == -1)
			log_warnx("configuration reload failed");
		else
			log_debug("configuration reloaded");
		break;
	default:
		fatalx("unexpected signal");
		/* NOTREACHED */
	}
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-cdnv] [-D macro=value]"
	    " [-f file] [-s socket]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct event		 ev_sigint, ev_sigterm, ev_sighup;
	struct area		*a;
	int			 ch, opts = 0;
	int			 debug = 0;
	int			 ipforwarding;
	int			 mib[4];
	size_t			 len;
	char			*sockname;

	conffile = CONF_FILE;
	ospfd_process = PROC_MAIN;
	sockname = OSPFD_SOCKET;

	log_init(1, LOG_DAEMON);	/* log to stderr until daemonized */
	log_procinit(log_procnames[ospfd_process]);
	log_setverbose(1);

	while ((ch = getopt(argc, argv, "cdD:f:ns:v")) != -1) {
		switch (ch) {
		case 'c':
			opts |= OSPFD_OPT_FORCE_DEMOTE;
			break;
		case 'd':
			debug = 1;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'n':
			opts |= OSPFD_OPT_NOACTION;
			break;
		case 's':
			sockname = optarg;
			break;
		case 'v':
			if (opts & OSPFD_OPT_VERBOSE)
				opts |= OSPFD_OPT_VERBOSE2;
			opts |= OSPFD_OPT_VERBOSE;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	mib[0] = CTL_NET;
	mib[1] = PF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_FORWARDING;
	len = sizeof(ipforwarding);
	if (sysctl(mib, 4, &ipforwarding, &len, NULL, 0) == -1)
		err(1, "sysctl");

	if (ipforwarding != 1) {
		log_warnx("WARNING: IP forwarding NOT enabled, "
		    "running as stub router");
		opts |= OSPFD_OPT_STUB_ROUTER;
	}

	/* fetch interfaces early */
	kif_init();

	/* parse config file */
	if ((ospfd_conf = parse_config(conffile, opts)) == NULL) {
		kif_clear();
		exit(1);
	}
	ospfd_conf->csock = sockname;

	if (ospfd_conf->opts & OSPFD_OPT_NOACTION) {
		if (ospfd_conf->opts & OSPFD_OPT_VERBOSE)
			print_config(ospfd_conf);
		else
			fprintf(stderr, "configuration OK\n");
		kif_clear();
		exit(0);
	}

	/* check for root privileges  */
	if (geteuid())
		errx(1, "need root privileges");

	/* check for ospfd user */
	if (getpwnam(OSPFD_USER) == NULL)
		errx(1, "unknown user %s", OSPFD_USER);

	log_init(debug, LOG_DAEMON);
	log_setverbose(ospfd_conf->opts & OSPFD_OPT_VERBOSE);

	if (!debug)
		daemon(1, 0);

	log_info("startup");

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_parent2ospfe) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_parent2rde) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_ospfe2rde) == -1)
		fatal("socketpair");

	/* start children */
	rde_pid = rde(ospfd_conf, pipe_parent2rde, pipe_ospfe2rde,
	    pipe_parent2ospfe);
	ospfe_pid = ospfe(ospfd_conf, pipe_parent2ospfe, pipe_ospfe2rde,
	    pipe_parent2rde);

	event_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, main_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, NULL);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);

	/* setup pipes to children */
	close(pipe_parent2ospfe[1]);
	close(pipe_parent2rde[1]);
	close(pipe_ospfe2rde[0]);
	close(pipe_ospfe2rde[1]);

	if ((iev_ospfe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_rde = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_ospfe->ibuf, pipe_parent2ospfe[0]);
	iev_ospfe->handler = main_dispatch_ospfe;
	imsg_init(&iev_rde->ibuf, pipe_parent2rde[0]);
	iev_rde->handler = main_dispatch_rde;

	/* setup event handler */
	iev_ospfe->events = EV_READ;
	event_set(&iev_ospfe->ev, iev_ospfe->ibuf.fd, iev_ospfe->events,
	    iev_ospfe->handler, iev_ospfe);
	event_add(&iev_ospfe->ev, NULL);

	iev_rde->events = EV_READ;
	event_set(&iev_rde->ev, iev_rde->ibuf.fd, iev_rde->events,
	    iev_rde->handler, iev_rde);
	event_add(&iev_rde->ev, NULL);

	if (kr_init(!(ospfd_conf->flags & OSPFD_FLAG_NO_FIB_UPDATE),
	    ospfd_conf->rdomain) == -1)
		fatalx("kr_init failed");

	/* remove unneeded stuff from config */
	while ((a = LIST_FIRST(&ospfd_conf->area_list)) != NULL) {
		LIST_REMOVE(a, entry);
		area_del(a);
	}

	event_dispatch();

	ospfd_shutdown();
	/* NOTREACHED */
	return (0);
}

__dead void
ospfd_shutdown(void)
{
	pid_t			 pid;
	int			 status;
	struct redistribute	*r;

	/* close pipes */
	msgbuf_clear(&iev_ospfe->ibuf.w);
	close(iev_ospfe->ibuf.fd);
	msgbuf_clear(&iev_rde->ibuf.w);
	close(iev_rde->ibuf.fd);

	control_cleanup(ospfd_conf->csock);
	while ((r = SIMPLEQ_FIRST(&ospfd_conf->redist_list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&ospfd_conf->redist_list, entry);
		free(r);
	}
	kr_shutdown();
	carp_demote_shutdown();

	log_debug("waiting for children to terminate");
	do {
		pid = wait(&status);
		if (pid == -1) {
			if (errno != EINTR && errno != ECHILD)
				fatal("wait");
		} else if (WIFSIGNALED(status))
			log_warnx("%s terminated; signal %d",
			    (pid == rde_pid) ? "route decision engine" :
			    "ospf engine", WTERMSIG(status));
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	free(iev_ospfe);
	free(iev_rde);
	free(ospfd_conf);

	log_info("terminating");
	exit(0);
}

/* imsg handling */
/* ARGSUSED */
void
main_dispatch_ospfe(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	struct demote_msg	 dmsg;
	ssize_t			 n;
	int			 shut = 0, verbose;

	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_RELOAD:
			if (ospf_reload() == -1)
				log_warnx("configuration reload failed");
			else
				log_debug("configuration reloaded");
			break;
		case IMSG_CTL_FIB_COUPLE:
			kr_fib_couple();
			break;
		case IMSG_CTL_FIB_DECOUPLE:
			kr_fib_decouple();
			break;
		case IMSG_CTL_FIB_RELOAD:
			kr_fib_reload();
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
			kr_show_route(&imsg);
			break;
		case IMSG_CTL_IFINFO:
			if (imsg.hdr.len == IMSG_HEADER_SIZE)
				kr_ifinfo(NULL, imsg.hdr.pid);
			else if (imsg.hdr.len == IMSG_HEADER_SIZE + IFNAMSIZ)
				kr_ifinfo(imsg.data, imsg.hdr.pid);
			else
				log_warnx("IFINFO request with wrong len");
			break;
		case IMSG_DEMOTE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(dmsg))
				fatalx("invalid size of OE request");
			memcpy(&dmsg, imsg.data, sizeof(dmsg));
			carp_demote_set(dmsg.demote_group, dmsg.level);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by ospfe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		default:
			log_debug("main_dispatch_ospfe: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
void
main_dispatch_rde(int fd, short event, void *bula)
{
	struct imsgev	*iev = bula;
	struct imsgbuf  *ibuf;
	struct imsg	 imsg;
	ssize_t		 n;
	int		 count, shut = 0;

	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_KROUTE_CHANGE:
			count = (imsg.hdr.len - IMSG_HEADER_SIZE) /
			    sizeof(struct kroute);
			if (kr_change(imsg.data, count))
				log_warn("main_dispatch_rde: error changing "
				    "route");
			break;
		case IMSG_KROUTE_DELETE:
			if (kr_delete(imsg.data))
				log_warn("main_dispatch_rde: error deleting "
				    "route");
			break;
		default:
			log_debug("main_dispatch_rde: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
main_imsg_compose_ospfe(int type, pid_t pid, void *data, u_int16_t datalen)
{
	if (iev_ospfe)
		imsg_compose_event(iev_ospfe, type, 0, pid, -1, data, datalen);
}

void
main_imsg_compose_rde(int type, pid_t pid, void *data, u_int16_t datalen)
{
	if (iev_rde)
		imsg_compose_event(iev_rde, type, 0, pid, -1, data, datalen);
}

void
imsg_event_add(struct imsgev *iev)
{
	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev);
	event_add(&iev->ev, NULL);
}

int
imsg_compose_event(struct imsgev *iev, u_int16_t type, u_int32_t peerid,
    pid_t pid, int fd, void *data, u_int16_t datalen)
{
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) != -1)
		imsg_event_add(iev);
	return (ret);
}

int
ospf_redistribute(struct kroute *kr, u_int32_t *metric)
{
	struct redistribute	*r;
	u_int8_t		 is_default = 0;

	/* only allow 0.0.0.0/0 via REDIST_DEFAULT */
	if (kr->prefix.s_addr == INADDR_ANY && kr->prefixlen == 0)
		is_default = 1;

	SIMPLEQ_FOREACH(r, &ospfd_conf->redist_list, entry) {
		switch (r->type & ~REDIST_NO) {
		case REDIST_LABEL:
			if (kr->rtlabel == r->label) {
				*metric = r->metric;
				return (r->type & REDIST_NO ? 0 : 1);
			}
			break;
		case REDIST_STATIC:
			/*
			 * Dynamic routes are not redistributable. Placed here
			 * so that link local addresses can be redistributed
			 * via a rtlabel.
			 */
			if (is_default)
				continue;
			if (kr->flags & F_DYNAMIC)
				continue;
			if (kr->flags & F_STATIC) {
				*metric = r->metric;
				return (r->type & REDIST_NO ? 0 : 1);
			}
			break;
		case REDIST_CONNECTED:
			if (is_default)
				continue;
			if (kr->flags & F_DYNAMIC)
				continue;
			if (kr->flags & F_CONNECTED) {
				*metric = r->metric;
				return (r->type & REDIST_NO ? 0 : 1);
			}
			break;
		case REDIST_ADDR:
			if (kr->flags & F_DYNAMIC)
				continue;

			if (r->addr.s_addr == INADDR_ANY &&
			    r->mask.s_addr == INADDR_ANY) {
				if (is_default) {
					*metric = r->metric;
					return (r->type & REDIST_NO ? 0 : 1);
				} else
					return (0);
			}

			if ((kr->prefix.s_addr & r->mask.s_addr) ==
			    (r->addr.s_addr & r->mask.s_addr) &&
			    kr->prefixlen >= mask2prefixlen(r->mask.s_addr)) {
				*metric = r->metric;
				return (r->type & REDIST_NO ? 0 : 1);
			}
			break;
		case REDIST_DEFAULT:
			if (is_default) {
				*metric = r->metric;
				return (r->type & REDIST_NO ? 0 : 1);
			}
			break;
		}
	}

	return (0);
}

int
ospf_reload(void)
{
	struct area		*area;
	struct iface		*iface;
	struct ospfd_conf	*xconf;
	struct redistribute	*r;

	if ((xconf = parse_config(conffile, ospfd_conf->opts)) == NULL)
		return (-1);

	/* send config to childs */
	if (ospf_sendboth(IMSG_RECONF_CONF, xconf, sizeof(*xconf)) == -1)
		return (-1);

	/* send interfaces */
	LIST_FOREACH(area, &xconf->area_list, entry) {
		if (ospf_sendboth(IMSG_RECONF_AREA, area, sizeof(*area)) == -1)
			return (-1);

		SIMPLEQ_FOREACH(r, &area->redist_list, entry) {
			main_imsg_compose_rde(IMSG_RECONF_REDIST, 0, r,
			    sizeof(*r));
		}
		LIST_FOREACH(iface, &area->iface_list, entry) {
			if (ospf_sendboth(IMSG_RECONF_IFACE, iface,
			    sizeof(*iface)) == -1)
				return (-1);
			if (iface->auth_type == AUTH_CRYPT)
				if (md_list_send(&iface->auth_md_list,
				    iev_ospfe) == -1)
					return (-1);
		}
	}

	if (ospf_sendboth(IMSG_RECONF_END, NULL, 0) == -1)
		return (-1);

	merge_config(ospfd_conf, xconf);
	/* update redistribute lists */
	kr_reload();
	return (0);
}

int
ospf_sendboth(enum imsg_type type, void *buf, u_int16_t len)
{
	if (imsg_compose_event(iev_ospfe, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	if (imsg_compose_event(iev_rde, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	return (0);
}

void
merge_config(struct ospfd_conf *conf, struct ospfd_conf *xconf)
{
	struct area		*a, *xa, *na;
	struct iface		*iface;
	struct redistribute	*r;
	int			 rchange = 0;

	/* change of rtr_id needs a restart */
	conf->flags = xconf->flags;
	conf->spf_delay = xconf->spf_delay;
	conf->spf_hold_time = xconf->spf_hold_time;
	if (SIMPLEQ_EMPTY(&conf->redist_list) !=
	    SIMPLEQ_EMPTY(&xconf->redist_list))
		rchange = 1;
	conf->rfc1583compat = xconf->rfc1583compat;

	if (ospfd_process == PROC_MAIN) {
		/* main process does neither use areas nor interfaces */
		while ((r = SIMPLEQ_FIRST(&conf->redist_list)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&conf->redist_list, entry);
			free(r);
		}
		while ((r = SIMPLEQ_FIRST(&xconf->redist_list)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&xconf->redist_list, entry);
			SIMPLEQ_INSERT_TAIL(&conf->redist_list, r, entry);
		}
		goto done;
	}

	/* merge areas and interfaces */
	for (a = LIST_FIRST(&conf->area_list); a != NULL; a = na) {
		na = LIST_NEXT(a, entry);
		/* find deleted areas */
		if ((xa = area_find(xconf, a->id)) == NULL) {
			if (ospfd_process == PROC_OSPF_ENGINE) {
				LIST_FOREACH(iface, &a->iface_list, entry)
					if_fsm(iface, IF_EVT_DOWN);
			}
			LIST_REMOVE(a, entry);
			area_del(a);
		}
	}

	for (xa = LIST_FIRST(&xconf->area_list); xa != NULL; xa = na) {
		na = LIST_NEXT(xa, entry);
		if ((a = area_find(conf, xa->id)) == NULL) {
			LIST_REMOVE(xa, entry);
			LIST_INSERT_HEAD(&conf->area_list, xa, entry);
			if (ospfd_process == PROC_OSPF_ENGINE) {
				/* start interfaces */
				ospfe_demote_area(xa, 0);
				LIST_FOREACH(iface, &xa->iface_list, entry) {
					if_init(conf, iface);
					if (if_fsm(iface, IF_EVT_UP)) {
						log_debug("error starting "
						    "interface %s",
						    iface->name);
					}
				}
			}
			/* no need to merge interfaces */
			continue;
		}
		/*
		 * stub is not yet used but switching between stub and normal
		 * will be another painful job.
		 */
		if (a->stub != xa->stub && ospfd_process == PROC_OSPF_ENGINE)
			a->dirty = 1; /* force rtr LSA update */
		if (xa->stub && ospfd_process == PROC_RDE_ENGINE) {
			while ((r = SIMPLEQ_FIRST(&a->redist_list)) != NULL) {
				SIMPLEQ_REMOVE_HEAD(&a->redist_list, entry);
				free(r);
			}

			while ((r = SIMPLEQ_FIRST(&xa->redist_list)) != NULL) {
				SIMPLEQ_REMOVE_HEAD(&xa->redist_list, entry);
				SIMPLEQ_INSERT_TAIL(&a->redist_list, r, entry);
			}
		}

		a->stub = xa->stub;
		a->stub_default_cost = xa->stub_default_cost;
		if (ospfd_process == PROC_RDE_ENGINE)
			a->dirty = 1; /* force SPF tree recalculation */

		/* merge interfaces */
		if (merge_interfaces(a, xa) &&
		    ospfd_process == PROC_OSPF_ENGINE)
			a->dirty = 1; /* force rtr LSA update */
	}

	if (ospfd_process == PROC_OSPF_ENGINE) {
		LIST_FOREACH(a, &conf->area_list, entry) {
			LIST_FOREACH(iface, &a->iface_list, entry) {
				if (iface->state == IF_STA_NEW) {
					iface->state = IF_STA_DOWN;
					if_init(conf, iface);
					if (if_fsm(iface, IF_EVT_UP)) {
						log_debug("error starting "
						    "interface %s",
						    iface->name);
					}
				}
			}
			if (a->dirty || rchange) {
				a->dirty = 0;
				orig_rtr_lsa(a);
			}
		}
	}
	if (ospfd_process == PROC_RDE_ENGINE) {
		LIST_FOREACH(a, &conf->area_list, entry) {
			if (a->dirty) {
				start_spf_timer();
				break;
			}
		}
	}

done:
	while ((a = LIST_FIRST(&xconf->area_list)) != NULL) {
		LIST_REMOVE(a, entry);
		area_del(a);
	}
	free(xconf);
}

int
merge_interfaces(struct area *a, struct area *xa)
{
	struct iface	*i, *xi, *ni;
	int		 dirty = 0;

	/* problems:
	 * - new interfaces (easy)
	 * - deleted interfaces (needs to be done via fsm?)
	 * - changing passive (painful?)
	 */
	for (i = LIST_FIRST(&a->iface_list); i != NULL; i = ni) {
		ni = LIST_NEXT(i, entry);
		if (iface_lookup(xa, i) == NULL) {
			log_debug("merge_interfaces: proc %d area %s removing "
			    "interface %s", ospfd_process, inet_ntoa(a->id),
			    i->name);
			if (ospfd_process == PROC_OSPF_ENGINE)
				if_fsm(i, IF_EVT_DOWN);
			else if (ospfd_process == PROC_RDE_ENGINE)
				rde_nbr_iface_del(i);
			LIST_REMOVE(i, entry);
			if_del(i);
		}
	}

	for (xi = LIST_FIRST(&xa->iface_list); xi != NULL; xi = ni) {
		ni = LIST_NEXT(xi, entry);
		if ((i = iface_lookup(a, xi)) == NULL) {
			/* new interface but delay initialisation */
			log_debug("merge_interfaces: proc %d area %s adding "
			    "interface %s", ospfd_process, inet_ntoa(a->id),
			    xi->name);
			LIST_REMOVE(xi, entry);
			LIST_INSERT_HEAD(&a->iface_list, xi, entry);
			xi->area = a;
			if (ospfd_process == PROC_OSPF_ENGINE)
				xi->state = IF_STA_NEW;
			continue;
		}
		log_debug("merge_interfaces: proc %d area %s merging "
		    "interface %s", ospfd_process, inet_ntoa(a->id), i->name);
		i->dst = xi->dst;
		i->abr_id = xi->abr_id;
		i->baudrate = xi->baudrate;
		i->dead_interval = xi->dead_interval;
		i->mtu = xi->mtu;
		i->transmit_delay = xi->transmit_delay;
		i->hello_interval = xi->hello_interval;
		i->rxmt_interval = xi->rxmt_interval;
		if (i->metric != xi->metric)
			dirty = 1;
		i->metric = xi->metric;
		i->priority = xi->priority;
		if (i->self)
			i->self->priority = i->priority;
		i->flags = xi->flags; /* needed? */
		i->type = xi->type; /* needed? */
		i->if_type = xi->if_type; /* needed? */
		i->linkstate = xi->linkstate; /* needed? */

		i->auth_type = xi->auth_type;
		strncpy(i->auth_key, xi->auth_key, MAX_SIMPLE_AUTH_LEN);
		md_list_clr(&i->auth_md_list);
		md_list_copy(&i->auth_md_list, &xi->auth_md_list);

		if (i->passive != xi->passive) {
			/* need to restart interface to cope with this change */
			if (ospfd_process == PROC_OSPF_ENGINE)
				if_fsm(i, IF_EVT_DOWN);
			i->passive = xi->passive;
			if (ospfd_process == PROC_OSPF_ENGINE)
				if_fsm(i, IF_EVT_UP);
		}
	}
	return (dirty);
}

struct iface *
iface_lookup(struct area *area, struct iface *iface)
{
	struct iface	*i;

	LIST_FOREACH(i, &area->iface_list, entry)
		if (i->ifindex == iface->ifindex &&
		    i->addr.s_addr == iface->addr.s_addr &&
		    i->mask.s_addr == iface->mask.s_addr)
			return (i);
	return (NULL);
}
@


1.93
log
@'unneded stuff' -> 'unneeded stuff' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.92 2016/09/04 10:10:23 krw Exp $ */
d28 1
a120 1
	log_procname = log_procnames[ospfd_process];
d123 3
a125 2
	log_init(1);	/* log to stderr until daemonized */
	log_verbose(1);
d206 2
a207 2
	log_init(debug);
	log_verbose(ospfd_conf->opts & OSPFD_OPT_VERBOSE);
d395 1
a395 1
			log_verbose(verbose);
@


1.92
log
@A few bits of stray leading/embedded/trailing whitespace spotted while
stealing code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.91 2016/09/03 10:22:57 renato Exp $ */
d269 1
a269 1
	/* remove unneded stuff from config */
@


1.91
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.90 2016/09/02 14:02:48 benno Exp $ */
d285 1
a285 1
	pid_t		 	 pid;
@


1.90
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.89 2016/02/02 17:51:11 sthen Exp $ */
d51 1
a51 2
void		ospfd_shutdown(void);
int		check_child(pid_t, const char *);
d77 1
a77 6
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */

	int	die = 0;

d81 2
a82 14
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		if (check_child(ospfe_pid, "ospf engine")) {
			ospfe_pid = 0;
			die = 1;
		}
		if (check_child(rde_pid, "route decision engine")) {
			rde_pid = 0;
			die = 1;
		}
		if (die)
			ospfd_shutdown();
		break;
d109 1
a109 1
	struct event		 ev_sigint, ev_sigterm, ev_sigchld, ev_sighup;
a233 1
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, NULL);
a236 1
	signal_add(&ev_sigchld, NULL);
d282 1
a282 1
void
d286 1
d289 5
a293 5
	if (ospfe_pid)
		kill(ospfe_pid, SIGTERM);

	if (rde_pid)
		kill(rde_pid, SIGTERM);
d303 1
d305 8
a312 3
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
a314 1
	msgbuf_clear(&iev_ospfe->ibuf.w);
a315 1
	msgbuf_clear(&iev_rde->ibuf.w);
a320 20
}

int
check_child(pid_t pid, const char *pname)
{
	int	status;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("lost child: %s terminated; signal %d",
			    pname, WTERMSIG(status));
			return (1);
		}
	}

	return (0);
@


1.89
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.88 2015/12/05 12:20:13 claudio Exp $ */
d138 1
@


1.88
log
@Pledge ospfd SE ("stdio inet mcast") and RDE ("stdio") move some code
around to make it possible. Parent can't be pledged at the moment because
of carp ioctl (carp demote). Putting it in so that people can test.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.87 2015/12/03 11:41:06 claudio Exp $ */
a244 3

	/* show who we are */
	setproctitle("parent");
@


1.87
log
@imsg_read will return EAGAIN in some cases so prep code for it.
This is in the way for ospfd pledge so in it goes. OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.86 2015/09/27 17:31:50 stsp Exp $ */
a194 1

d200 1
a200 1
		kr_shutdown();
d210 1
a210 1
		kr_shutdown();
@


1.86
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.85 2015/07/20 23:45:39 benno Exp $ */
d376 1
a376 1
		if ((n = imsg_read(ibuf)) == -1)
d463 1
a463 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.85
log
@Fix a segfault at startup when if_change() ist called before
imsg_init() exposed by the second part of this diff which makes
carp(4) interfaces be recognized to be in "backup" mode on start-up.

Problem analyzed and fix provided by Johan Ymerson, thanks!

ok claudio@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.84 2015/03/14 02:22:09 claudio Exp $ */
d865 1
a865 1
		i->media_type = xi->media_type; /* needed? */
@


1.84
log
@When removing interfaces in the RDE we also need to remove all the RDE
neighbors that are part of that interface or we open us up to use after
free situations like the one found by sthen@@.
Diff makes sense sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.83 2015/02/10 05:24:48 claudio Exp $ */
d514 2
a515 1
	imsg_compose_event(iev_ospfe, type, 0, pid, -1, data, datalen);
d521 2
a522 1
	imsg_compose_event(iev_rde, type, 0, pid, -1, data, datalen);
@


1.83
log
@Convert ospfd over to SOCK_CLOEXEC | SOCK_NONBLOCK and make the route
socket non-blocking. Introduce the same trigger for partial rt msgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.82 2015/01/16 06:40:19 deraadt Exp $ */
d824 2
@


1.82
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.81 2014/07/12 20:16:38 krw Exp $ */
d231 2
a232 2
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_parent2ospfe) == -1)
d234 2
a235 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2rde) == -1)
d237 2
a238 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_ospfe2rde) == -1)
a239 6
	session_socket_blockmode(pipe_parent2ospfe[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2ospfe[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2rde[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2rde[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_ospfe2rde[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_ospfe2rde[1], BM_NONBLOCK);
@


1.81
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.80 2013/11/13 20:43:00 benno Exp $ */
a26 1
#include <sys/param.h>
@


1.80
log
@from claudio
"Let msgbuf_write return -1 with errno EAGAIN. The users then must
check if this was the case and readd the event or poll again.  The
current handling in the imsg code is wrong for sure."

ok gilles, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.79 2013/03/22 11:29:01 sthen Exp $ */
d387 1
a387 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d389 2
d474 1
a474 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d476 2
@


1.79
log
@whitespace tweak; gratuitous difference with ospf6d
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.78 2011/08/20 11:16:09 sthen Exp $ */
d387 1
a387 1
		if (msgbuf_write(&ibuf->w) == -1)
d472 1
a472 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.78
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"ospfd -v" (previously only "-vd" worked). Feedback on earlier implementation
from henning@@ blambert@@ claudio@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.77 2011/05/06 13:50:37 claudio Exp $ */
d599 1
a599 1
					return (r->type & REDIST_NO? 0 : 1);
@


1.77
log
@Do not special case loopback interfaces on init. Instead force them
to IF_STA_LOOPBACK in if_act_start() this way they will repsect
IFF_UP on startup. Also remove a now no longer needed workaround
when reloading interfaces.
Initial diff provided by Patrick Coleman. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.76 2011/03/24 08:35:59 claudio Exp $ */
d142 1
a169 1
			log_verbose(1);
d225 1
@


1.76
log
@Fix some memory leaks. Mainly better cleanup on shutdown but the v_nexthop
leak is a runtime one.
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.75 2010/09/02 14:03:22 sobrado Exp $ */
d839 1
a839 2
			if (ospfd_process == PROC_OSPF_ENGINE &&
			    !(xi->state == IF_STA_LOOPBACK))
@


1.75
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.74 2010/05/14 08:30:18 sthen Exp $ */
d312 2
a313 1
	pid_t		 pid;
d322 4
@


1.74
log
@When merging interfaces after a config reload, the fsm state for interfaces
is forced into IF_STA_NEW so that if_init() can be called to setup timers etc.
When a loopback interface is added to the config, this means there's no way
to get to the correct state.

Fix by avoiding changing an existing IF_STA_LOOPBACK and forcing loopback
interfaces to be passive (otherwise skipping the if_init on an active
interface causes problems).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.73 2010/02/19 10:35:52 dlg Exp $ */
d746 1
a746 1
			
@


1.73
log
@implement ospfctl fib reload.

this tells the daemon to resync the kernels list of interfaces and routes
with the daemons list. this is very useful if the routing socket overflows
and you want to sync things up again.

lots and lots of help from claudio@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.71 2009/11/02 20:20:54 claudio Exp $ */
d834 2
a835 1
			if (ospfd_process == PROC_OSPF_ENGINE)
@


1.72
log
@Only merge interfaces that have the same address and netmask. Fixes a bug
with reloads when running ospfd on multiple aliases on the same interface.
Is also needed to handle interface address changes in a much better way.
OK dlg@@, sthen@@
@
text
@d405 3
@


1.71
log
@Implement IMSG_CTL_LOG_VERBOSE to enable or disable debug logging on runtime.
It always annoyed me that in case of a problem I had to restart the ospf in
forground debug mode and by doing so losing all routes at least twice.
OK henning, sthen, michele
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.70 2009/06/06 07:31:26 eric Exp $ */
a836 1
		i->addr = xi->addr;
a837 1
		i->mask = xi->mask;
d849 2
d879 3
a881 1
		if (i->ifindex == iface->ifindex)
@


1.70
log
@sync ospfctl/ospfd with the common imsg code, making it lib ready as well.

"looks ok" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.69 2009/06/05 19:33:59 pyr Exp $ */
d169 1
a170 1

d370 1
a370 1
	int			 shut = 0;
d422 5
@


1.69
log
@make ospfd's imsg lib ready as well.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.68 2009/06/05 04:12:52 claudio Exp $ */
d68 2
a69 2
struct imsgbuf		*ibuf_ospfe;
struct imsgbuf		*ibuf_rde;
d273 2
a274 2
	if ((ibuf_ospfe = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_rde = malloc(sizeof(struct imsgbuf))) == NULL)
d276 4
a279 2
	imsg_init(ibuf_ospfe, pipe_parent2ospfe[0], main_dispatch_ospfe);
	imsg_init(ibuf_rde, pipe_parent2rde[0], main_dispatch_rde);
d282 9
a290 9
	ibuf_ospfe->events = EV_READ;
	event_set(&ibuf_ospfe->ev, ibuf_ospfe->fd, ibuf_ospfe->events,
	    ibuf_ospfe->handler, ibuf_ospfe);
	event_add(&ibuf_ospfe->ev, NULL);

	ibuf_rde->events = EV_READ;
	event_set(&ibuf_rde->ev, ibuf_rde->fd, ibuf_rde->events,
	    ibuf_rde->handler, ibuf_rde);
	event_add(&ibuf_rde->ev, NULL);
d330 4
a333 4
	msgbuf_clear(&ibuf_ospfe->w);
	free(ibuf_ospfe);
	msgbuf_clear(&ibuf_rde->w);
	free(ibuf_rde);
d365 2
a366 1
	struct imsgbuf		*ibuf = bula;
d372 2
d431 1
a431 1
		imsg_event_add(ibuf);
d434 1
a434 1
		event_del(&ibuf->ev);
d443 2
a444 1
	struct imsgbuf  *ibuf = bula;
d449 2
d490 1
a490 1
		imsg_event_add(ibuf);
d493 1
a493 1
		event_del(&ibuf->ev);
d501 1
a501 1
	imsg_compose_event(ibuf_ospfe, type, 0, pid, -1, data, datalen);
d507 1
a507 1
	imsg_compose_event(ibuf_rde, type, 0, pid, -1, data, datalen);
a509 1
/* this needs to be added here so that ospfctl can be used without libevent */
d511 1
a511 1
imsg_event_add(struct imsgbuf *ibuf)
d513 7
a519 7
	ibuf->events = EV_READ;
	if (ibuf->w.queued)
		ibuf->events |= EV_WRITE;

	event_del(&ibuf->ev);
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf);
	event_add(&ibuf->ev, NULL);
d523 1
a523 1
imsg_compose_event(struct imsgbuf *ibuf, u_int16_t type, u_int32_t peerid,
d528 1
a528 1
	if ((ret = imsg_compose(ibuf, type, peerid,
d530 1
a530 1
		imsg_event_add(ibuf);
d639 1
a639 1
				    ibuf_ospfe) == -1)
d656 1
a656 1
	if (imsg_compose_event(ibuf_ospfe, type, 0, 0, -1, buf, len) == -1)
d658 1
a658 1
	if (imsg_compose_event(ibuf_rde, type, 0, 0, -1, buf, len) == -1)
@


1.68
log
@Preliminary rdomain support, all hacked up by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.67 2009/05/31 18:46:01 jacekm Exp $ */
d493 1
a493 1
	imsg_compose(ibuf_ospfe, type, 0, pid, data, datalen);
d499 1
a499 1
	imsg_compose(ibuf_rde, type, 0, pid, data, datalen);
d516 12
d649 1
a649 1
	if (imsg_compose(ibuf_ospfe, type, 0, 0, buf, len) == -1)
d651 1
a651 1
	if (imsg_compose(ibuf_rde, type, 0, 0, buf, len) == -1)
@


1.67
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.66 2009/05/31 16:58:54 claudio Exp $ */
d290 2
a291 1
	if (kr_init(!(ospfd_conf->flags & OSPFD_FLAG_NO_FIB_UPDATE)) == -1)
@


1.66
log
@The libevent callback function may be called with EV_READ and EV_WRITE
set at the same time so using a switch to do read or write is a bad idea.
Problem noticed by Eygene Ryabinkin on FreeBSD for some reasons it is not
triggered on OpenBSD.
Fix aggreed by a most other libevent hackers
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.65 2009/05/15 15:55:07 mpf Exp $ */
a376 1
		imsg_event_add(ibuf);
a450 1
		imsg_event_add(ibuf);
@


1.65
log
@Do not ignore the route metric for "redistribute default".
Got broken in -r 1.62. Pointed out by bluhm@@
OK bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.64 2009/04/07 14:57:33 reyk Exp $ */
d368 1
a368 2
	switch (event) {
	case EV_READ:
d373 2
a374 2
		break;
	case EV_WRITE:
a377 3
		return;
	default:
		fatalx("unknown event");
d443 1
a443 2
	switch (event) {
	case EV_READ:
d448 2
a449 2
		break;
	case EV_WRITE:
a452 3
		return;
	default:
		fatalx("unknown event");
@


1.64
log
@allow to specify an alternate control socket instead of /var/run/ospfd.sock.
this is required to run multiple instances of ospfd.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.63 2009/03/27 14:37:26 michele Exp $ */
d573 2
a574 1
				if (is_default)
d576 1
a576 1
				else
d588 2
a589 1
			if (is_default)
d591 1
@


1.63
log
@Allow the announcement of default route also via redistribute 0.0.0.0/0
and route labels.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.62 2009/03/24 19:26:13 michele Exp $ */
d119 2
a120 1
	fprintf(stderr, "usage: %s [-cdnv] [-D macro=value] [-f file]\n",
d135 1
d139 1
d143 1
a143 1
	while ((ch = getopt(argc, argv, "cdD:f:nv")) != -1) {
d162 3
d205 1
d317 1
a317 1
	control_cleanup();
@


1.62
log
@Change the behaviour of redistribute default.
Now a default route have to be present in the fib to be correctly advertised.

Spotted and tested by Steven Surdok on ripd.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.61 2009/03/01 16:03:12 michele Exp $ */
a529 2
			if (is_default)
				continue;
a560 2
			if (is_default)
				continue;
d563 9
d581 1
a581 1
				return (1);
@


1.61
log
@Print the correct function name in log_debug().

OK claudio@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.60 2009/01/07 21:16:36 claudio Exp $ */
a57 2
void	ospf_redistribute_default(int);

a291 3
	/* redistribute default */
	ospf_redistribute_default(IMSG_NETWORK_ADD);

d521 1
d523 1
a523 1
	/* only allow 0.0.0.0/0 via REDISTRIBUTE_DEFAULT */
d525 1
a525 1
		return (0);
d530 2
d543 2
d553 2
d563 2
d575 2
a576 1
			/* nothing to be done here */
a581 19
}

void
ospf_redistribute_default(int type)
{
	struct rroute		 rr;
	struct redistribute	*r;

	SIMPLEQ_FOREACH(r, &ospfd_conf->redist_list, entry) {
		if (r->type != REDIST_DEFAULT)
			continue;
		if (r->type == (REDIST_DEFAULT | REDIST_NO))
			return;

		bzero(&rr, sizeof(rr));
		rr.metric = r->metric;
		main_imsg_compose_rde(type, 0, &rr, sizeof(struct rroute));
		return;
	}
@


1.60
log
@Full stub area support. This allows ABRs to announce a default network
summary LSA into stub areas so that these routers are able to reach the
outside of the area.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.59 2009/01/01 20:44:06 claudio Exp $ */
d795 1
a795 1
			log_debug("merge_config: proc %d area %s removing "
d809 1
a809 1
			log_debug("merge_config: proc %d area %s adding "
d819 2
a820 2
		log_debug("merge_config: proc %d area %s merging interface %s",
		    ospfd_process, inet_ntoa(a->id), i->name);
@


1.59
log
@Call kr_shutdown() before exit even in config test mode and config parse
error case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.58 2008/11/24 18:28:02 claudio Exp $ */
d570 3
d582 8
a589 1
	struct rroute	rr;
d591 3
a593 1
	if (!(ospfd_conf->redistribute & REDISTRIBUTE_DEFAULT))
d595 1
a595 4

	bzero(&rr, sizeof(rr));
	rr.metric = ospfd_conf->defaultmetric;
	main_imsg_compose_rde(type, 0, &rr, sizeof(struct rroute));
d604 1
d618 4
d664 2
a665 2
	if ((conf->redistribute & REDISTRIBUTE_ON) !=
	    (xconf->redistribute & REDISTRIBUTE_ON))
a666 1
	conf->redistribute = xconf->redistribute;
d720 1
a720 2
		if (a->stub != xa->stub &&
		    ospfd_process == PROC_OSPF_ENGINE)
d722 11
d761 8
@


1.58
log
@Initial support for stub areas. The bit still missing is the redistribution
of the default summary net lsa on ABRs but that is comming. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.57 2008/05/12 19:15:02 pyr Exp $ */
d197 2
a198 1
	if ((ospfd_conf = parse_config(conffile, opts)) == NULL )
d200 1
d207 1
@


1.57
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.56 2007/10/25 12:06:30 claudio Exp $ */
d704 4
@


1.56
log
@Add -D makro=value as well so that all routing daemons are in sync.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.55 2007/10/20 13:29:44 pyr Exp $ */
d172 5
@


1.55
log
@forgot about ospfd in last commit.
ok hennin@@ too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.54 2007/10/14 19:35:01 claudio Exp $ */
d121 2
a122 1
	fprintf(stderr, "usage: %s [-cdnv] [-f file]\n", __progname);
d142 1
a142 1
	while ((ch = getopt(argc, argv, "cdf:nv")) != -1) {
d149 5
@


1.54
log
@Missing space
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.53 2007/10/13 16:35:22 deraadt Exp $ */
d139 2
a166 3
	/* start logging */
	log_init(debug);

d204 2
@


1.53
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.52 2007/10/11 12:16:45 claudio Exp $ */
d552 1
a552 1
				return (r->type & REDIST_NO? 0 : 1);
@


1.52
log
@Don't check for OSPF_OPTION_E in the parent. OSPF_OPTION_E is per area and
so the parent process has no way to know if it should redistribute or not.
Let the RDE decide. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.51 2007/10/01 08:35:12 norby Exp $ */
a57 1
int	check_file_secrecy(int, const char *);
a491 23
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		warn("cannot stat %s", fname);
		return (-1);
	}

	if (st.st_uid != 0 && st.st_uid != getuid()) {
		warnx("%s: owner not root or current user", fname);
		return (-1);
	}

	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		warnx("%s: group/world readable/writeable", fname);
		return (-1);
	}

	return (0);
@


1.51
log
@fix alot of whitespace problems...
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.50 2007/09/25 11:25:41 claudio Exp $ */
a534 4

	/* stub area router? */
	if ((ospfd_conf->options & OSPF_OPTION_E) == 0)
		return (0);
@


1.50
log
@Last missing piece in the equal cost multipath support for ospfd.
Send all possible nexthops to the parent process and correctly sync
the RIB, FIB and kernel routing table. Based on initial work by pyr@@.
OK pyr@@ norby@@
PS: don't forget that you need to enable multipath support via a sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.49 2007/09/18 16:59:08 claudio Exp $ */
d773 3
a775 2
			log_debug("merge_config: proc %d area %s removing interface %s",
			    ospfd_process, inet_ntoa(a->id), i->name);
d787 3
a789 2
			log_debug("merge_config: proc %d area %s adding interface %s",
			    ospfd_process, inet_ntoa(a->id), xi->name);
@


1.49
log
@Correctly track the E-bit of router LSA on config reloads. If redistribution
is turned on or off the E-bit needs to be toggled accordingly else the
AS-external LSA are ignored by the other OSPF routers.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.48 2007/07/25 19:11:27 claudio Exp $ */
d429 1
a429 1
	int		 shut = 0;
d456 3
a458 1
			if (kr_change(imsg.data))
@


1.48
log
@Don't fatal if the imsg pipe is closed, this is often triggered in the parent
and hides the real cause of the termination.
OK norby@@, reyk@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.47 2007/06/19 14:42:09 pyr Exp $ */
d655 1
d661 3
d742 1
a742 1
			if (a->dirty) {
@


1.47
log
@Allow ospfd reconfiguration through SIGHUP, add SIGHUP handlers in
children like in bgpd so that ``pkill -1 ospfd'' works as expected.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.46 2007/05/29 22:08:25 claudio Exp $ */
d350 1
d357 1
a357 1
			fatalx("pipe closed");
d413 7
a419 1
	imsg_event_add(ibuf);
d429 1
d436 1
a436 1
			fatalx("pipe closed");
d472 7
a478 1
	imsg_event_add(ibuf);
@


1.46
log
@Demote support for ospfd. It is possible to specify a demote group on
interfaces and areas. With this carp setups using ospfd are more reliable
because we can fail over if the OSPF connectivity is (partially) lost.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.45 2007/03/25 15:48:54 claudio Exp $ */
d106 4
a109 2
		/* reconfigure */
		/* ... */
@


1.45
log
@If the interface metric changes on reload it is necessary to re-originate
the router LSA so that the change propagates instantly. Call orig_rtr_lsa()
in merge_config() if a interface in an area changes. Do it as late as possible
to reduce the amount of updates generated by a config reload.
Found and tested by Stuart Henderson. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.44 2007/03/21 10:54:30 claudio Exp $ */
d120 1
a120 1
	fprintf(stderr, "usage: %s [-dnv] [-f file]\n", __progname);
d138 1
a138 1
	while ((ch = getopt(argc, argv, "df:nv")) != -1) {
d140 3
d301 1
d346 1
d397 6
d681 1
@


1.44
log
@Add support for RFC 3137: OSPF Stub Router Advertisement
This allows ospfd to announce networks without the need to transit traffic.
stub router is enabled if the fib is not coupled, net.inet.ip.forwarding is
not 1 or if the stub router global config option is set to yes.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.43 2007/03/17 22:28:58 claudio Exp $ */
d63 1
a63 1
void	merge_interfaces(struct area *, struct area *);
d688 2
a689 1
		a->dirty = 1; /* force SPF tree recalculation */
d692 3
a694 1
		merge_interfaces(a, xa);
d710 4
d725 1
a725 1
void
d729 1
d773 2
d796 1
@


1.43
log
@Exchange a strlcpy() with a strncpy(). A similar change was done in parse.y
some time ago. The simple password needs to be nul extended and is allowed
to fill the full buffer the perfect job for stncpy().
Found and tested by Jon Morby.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.42 2007/03/16 10:56:31 claudio Exp $ */
d172 6
a177 2
	if (!ipforwarding)
		log_warnx("WARNING: IP forwarding NOT enabled");
d629 2
a630 1
	/* change of rtr_id needs a restart and flags are ignored */
@


1.42
log
@Don't forget to set the metric in the REDIST_LABEL case. OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.41 2007/02/01 13:25:28 claudio Exp $ */
d768 1
a768 1
		strlcpy(i->auth_key, xi->auth_key, MAX_SIMPLE_AUTH_LEN);
@


1.41
log
@whitespace cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.40 2007/02/01 13:02:04 claudio Exp $ */
d514 2
a515 1
			if (kr->rtlabel == r->label)
d517 1
@


1.40
log
@Preliminary configuration reload support. Seems to work reasonably well
after fixing many use-after-free errors a couple of days ago.
Most cases -- adding/removing of interfaces, adding/removing of areas --
seem to work. Still merge_config() is a behemoth of a function and some
edge cases may not be covered correctly (yet).
OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.39 2007/01/20 17:13:36 claudio Exp $ */
d336 1
a336 1
	struct imsgbuf  	*ibuf = bula;
d764 1
a764 1
		
a790 1

@


1.39
log
@Ignore SIGPIPE in the parent and RDE as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.38 2006/12/21 17:22:29 claudio Exp $ */
d61 5
d70 1
a70 1
struct ospfd_conf	*conf = NULL;
d73 1
d128 1
a128 1
	char			*conffile;
d179 1
a179 1
	if ((conf = parse_config(conffile, opts)) == NULL )
d182 3
a184 3
	if (conf->opts & OSPFD_OPT_NOACTION) {
		if (conf->opts & OSPFD_OPT_VERBOSE)
			print_config(conf);
d218 3
a220 2
	rde_pid = rde(conf, pipe_parent2rde, pipe_ospfe2rde, pipe_parent2ospfe);
	ospfe_pid = ospfe(conf, pipe_parent2ospfe, pipe_ospfe2rde,
d262 1
a262 1
	if (kr_init(!(conf->flags & OSPFD_FLAG_NO_FIB_UPDATE)) == -1)
d265 6
a283 1
	struct area	*a;
a291 5
	while ((a = LIST_FIRST(&conf->area_list)) != NULL) {
		LIST_REMOVE(a, entry);
		area_del(a);
	}

d305 1
a305 1
	free(conf);
d336 3
a338 3
	struct imsgbuf  *ibuf = bula;
	struct imsg	 imsg;
	ssize_t		 n;
d365 4
a368 1
			/* XXX reconfig */
d504 1
a504 1
	if ((conf->options & OSPF_OPTION_E) == 0)
d511 1
a511 1
	SIMPLEQ_FOREACH(r, &conf->redist_list, entry) {
d559 1
a559 1
	if (!(conf->redistribute & REDISTRIBUTE_DEFAULT))
d563 1
a563 1
	rr.metric = conf->defaultmetric;
d565 225
@


1.38
log
@Unbreak redistribute default and make it possible to specify a metric for
the default route as well. OK norby@@, michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.37 2006/12/07 19:14:27 claudio Exp $ */
d230 1
@


1.37
log
@Make it possible to set the metric and LSA type for redistributed routes.
Mostly based on a diff by Pierre-Yves Ritschard (I just simplified the parser
code). OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.36 2006/11/01 13:20:18 claudio Exp $ */
d546 1
a546 1
	struct kroute	kr;
d548 6
a553 3
	bzero(&kr, sizeof(kr));
	if (conf->redistribute & REDISTRIBUTE_DEFAULT)
		main_imsg_compose_rde(type, 0, &kr, sizeof(struct kroute));
@


1.36
log
@Fix copy pasto, use SIGCHLD for the sigchild handler not SIGINT twice.
Spotted by janus <at> errornet.de
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.35 2006/08/06 12:35:44 claudio Exp $ */
d488 1
a488 1
ospf_redistribute(struct kroute *kr)
d514 2
a515 1
			if (kr->flags & F_STATIC)
d517 1
d522 2
a523 1
			if (kr->flags & F_CONNECTED)
d525 1
d532 2
a533 1
			    kr->prefixlen >= mask2prefixlen(r->mask.s_addr))
d535 1
@


1.35
log
@There is no need to initialize the log framework twice. Especially because
between the two calls no logging can happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.34 2006/07/03 13:05:02 claudio Exp $ */
d224 1
a224 1
	signal_set(&ev_sigchld, SIGINT, main_sig_handler, NULL);
@


1.34
log
@Add missing breaks and suddenly all starts to make sense again. Wondered
why one of my boxes started to redistribute all my bgpd routes into ospf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.33 2006/05/31 03:24:06 claudio Exp $ */
a131 3
	/* start logging */
	log_init(1);

d155 1
@


1.33
log
@More redistribute fun. Add a possibility to deny redistribution of specified
routes via "no redistribute rtlabel admin". Redistribute rules are parsed
in order and the first match is used. Only exception is "redistribute default"
Which is independent of the other rules and can't be negated.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.32 2006/05/30 22:06:14 claudio Exp $ */
d518 1
d524 1
@


1.32
log
@Now that rtlabels are accessable via sysctl we can use route lables to
define which routes should be redistributed via OSPF. So now you can
define the export list on a fine graded basis. More to come... OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.31 2006/03/27 11:57:24 claudio Exp $ */
d503 1
a503 1
		switch (r->type) {
d506 1
a506 1
				return (1);
d517 1
a517 1
				return (1);
d522 1
a522 1
				return (1);
d524 6
a529 1
			/* ignore */
@


1.31
log
@More specific warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.30 2006/03/25 09:34:13 norby Exp $ */
d492 2
d502 26
a527 6
	if ((conf->redistribute_flags & REDISTRIBUTE_STATIC) &&
	    (kr->flags & F_STATIC))
		return (1);
	if ((conf->redistribute_flags & REDISTRIBUTE_CONNECTED) &&
	    (kr->flags & F_CONNECTED))
		return (1);
d538 1
a538 1
	if (conf->redistribute_flags & REDISTRIBUTE_DEFAULT)
@


1.30
log
@Highlight that running an OSPF router without forwarding enabled is
very damaging to the network.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.29 2006/03/14 16:14:30 claudio Exp $ */
d169 1
a169 1
		log_warnx("WARNING: forwarding NOT enabled");
@


1.29
log
@Kill unneeded util.h include.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.28 2006/03/08 16:02:59 claudio Exp $ */
d27 2
d125 3
d159 11
@


1.28
log
@Cleanup with lint. Kill unused variable and fix some types.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.27 2006/02/10 18:30:47 claudio Exp $ */
a39 1
#include <util.h>
@


1.27
log
@ospfd does not need fd passing via the imsg framework so remove that code
and remove other unneeded functions that are only used in bgpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.26 2006/01/12 15:10:02 claudio Exp $ */
a63 2
volatile sig_atomic_t	 main_quit = 0;

d71 1
d311 1
d317 1
a317 1
	int		 n;
d374 1
d380 1
a380 1
	int		 n;
@


1.26
log
@Rewrite the redistribute code. The previous implementation was stupid and
resulted in a major bottleneck if bgpd was used on the same box -- not clever
to do linear searches over 175k entries :(. This now moves the redistribute
code back into kroute duty and kills the linear list. Also default routes are
now redistributed without the need for a kernel default route.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.25 2005/12/29 13:58:49 claudio Exp $ */
d428 1
a428 2

	imsg_compose(ibuf_ospfe, type, 0, pid, -1, data, datalen);
d434 1
a434 2

	imsg_compose(ibuf_rde, type, 0, pid, -1, data, datalen);
@


1.25
log
@More correct cleanup on exit. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.24 2005/10/18 15:40:36 claudio Exp $ */
d37 1
d58 1
d245 3
d474 32
@


1.24
log
@Cleanup interface code a minimal bit. There is no need for if_shutdown(),
especially it got called in the wrong place.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.23 2005/08/15 18:58:47 norby Exp $ */
d253 2
a254 1
	pid_t	pid;
d262 5
d280 1
@


1.23
log
@Fix possible race condition in signal handler.

Report and fix from Micheal Knudsen.

Prep, test and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.22 2005/06/21 19:10:22 claudio Exp $ */
a262 1
	if_shutdown(conf);
@


1.22
log
@The ev_sighup event handler should handle SIGHUP and not SIGTERM.
SIGTERM is already handled by ev_sigterm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.21 2005/05/26 22:05:14 norby Exp $ */
d83 2
a84 2
		ospfd_shutdown();
		/* NOTREACHED */
@


1.21
log
@Cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.20 2005/05/26 18:46:16 norby Exp $ */
d211 1
a211 1
	signal_set(&ev_sighup, SIGTERM, main_sig_handler, NULL);
@


1.20
log
@Support dumping the configuration the way bgpd(8) does it.

This makes it possible to have ospfd(8) parse a configuration file and
display the parsed result.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.19 2005/05/23 22:54:05 henning Exp $ */
d333 1
a333 2
			log_debug("main_dispatch_ospfe: IMSG_CTL_RELOAD");
			/* reconfig */
@


1.19
log
@useless use of endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.18 2005/04/25 09:28:45 claudio Exp $ */
d112 1
a112 1
	fprintf(stderr, "usage: %s [-d] [-f file]\n", __progname);
d121 1
a121 1
	int			 ch;
d130 1
a130 1
	while ((ch = getopt(argc, argv, "df:")) != -1) {
d138 9
d159 1
a159 1
	if ((conf = parse_config(conffile, OSPFD_OPT_VERBOSE)) == NULL )
d162 8
a242 2
	show_config(conf);

d435 1
a435 1
		log_warn("cannot stat %s", fname);
d440 1
a440 1
		log_warnx("%s: owner not root or current user", fname);
d445 1
a445 1
		log_warnx("%s: group/world readable/writeable", fname);
@


1.18
log
@Call if_init() in ospfe only, neither the rde nor the parent need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.17 2005/04/19 07:34:52 claudio Exp $ */
a159 2

	endpwent();
@


1.17
log
@Don't call event_set() before event_init().
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.16 2005/04/17 21:50:18 claudio Exp $ */
a180 5

	if (if_init(conf))
		log_info("error initializing interfaces");
	else
		log_debug("interfaces initialized");
@


1.16
log
@Use fatalx() instead of ospfd_shutdown() if kr_init() fails.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.15 2005/03/26 13:53:51 henning Exp $ */
a181 2
	event_init();

d194 2
@


1.15
log
@explciitely 0-initialize pids
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.14 2005/03/26 13:39:50 claudio Exp $ */
d231 1
a231 1
		ospfd_shutdown();
@


1.14
log
@Prototypes where moved to ospfd.h so no need to keep them here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.13 2005/03/26 13:35:16 claudio Exp $ */
d68 2
a69 2
pid_t			 ospfe_pid;
pid_t			 rde_pid;
@


1.13
log
@Implement the IMSG_CTL_IFINFO bits correctly. This is needed for
"ospfctl show fib interface".
OK henning@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.12 2005/03/26 11:04:28 henning Exp $ */
a54 2
void	main_imsg_compose_ospfe(int, pid_t, void *, u_int16_t);
void	main_imsg_compose_rde(int, pid_t, void *, u_int16_t);
a419 1

@


1.12
log
@fix a little race on SIGCHLD where we must delay the claenup until
we invalidated all child pids in case both were killed in a very short
time, spotted by and diff from Michael Knudsen <e@@molioner.dk>, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.11 2005/03/25 13:39:10 henning Exp $ */
d341 5
a345 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE + IFNAMSIZ)
a346 2
			else
				kr_ifinfo(imsg.data);
@


1.11
log
@what is an ospfe engine?
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.10 2005/03/25 13:35:24 henning Exp $ */
d80 2
d90 1
a90 1
			ospfd_shutdown();
d94 3
a97 1
		}
@


1.10
log
@extra char in getopt string, Michael Knudsen <e@@molioner.dk>
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.9 2005/03/15 22:03:56 claudio Exp $ */
d86 1
a86 1
		if (check_child(ospfe_pid, "ospfe engine")) {
@


1.9
log
@Add control messages for the show fib commands.
OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.8 2005/03/08 20:12:18 norby Exp $ */
d128 1
a128 1
	while ((ch = getopt(argc, argv, "dhf:")) != -1) {
@


1.8
log
@Remove no longer valid route entries.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.7 2005/03/07 10:28:14 claudio Exp $ */
d331 10
@


1.7
log
@Track interface state (up/down) and media status. Simplify the code a bit
by using the kif/kroute info while allocating interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.6 2005/02/27 08:21:15 norby Exp $ */
d375 7
a381 1
				log_warn("main_dispatch_rde: error changing route");
@


1.6
log
@SPF and route table calculation.

Calculate Shortest Path Tree for each area known in the link state
database.

The Shortest Path Tree is used as input for route table calculation.
Route tabled is calculated and the result is inserted into the kernel
route table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.5 2005/02/24 16:28:43 claudio Exp $ */
d143 3
@


1.5
log
@Remove the kroute nexthop specific code as there is no need for this in
ospfd. While there clean up some other no longer needed stuff.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.4 2005/02/07 05:51:00 david Exp $ */
d370 4
@


1.4
log
@spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.3 2005/02/02 18:52:32 henning Exp $ */
a322 3
		case IMSG_CTL_SHOW_INTERFACE:
			kr_show_route(&imsg);
			break;
a393 24

void
send_nexthop_update(struct kroute_nexthop *msg)
{
	char	*gw = NULL;

	if (msg->gateway.s_addr)
		if (asprintf(&gw, ": via %s",
		    inet_ntoa(msg->gateway)) == -1) {
			log_warn("send_nexthop_update");
			main_quit = 1;
		}

	log_info("nexthop %s now %s%s%s", inet_ntoa(msg->nexthop),
	    msg->valid ? "valid" : "invalid",
	    msg->connected ? ": directly connected" : "",
	    msg->gateway.s_addr ? gw : "");

	free(gw);

	if (imsg_compose(ibuf_rde, IMSG_NEXTHOP_UPDATE, 0, 0, -1,
	    msg, sizeof(struct kroute_nexthop)) == -1)
		main_quit = 1;
}
@


1.3
log
@usage() is __dead
pt out by Alexander v Gernler
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d148 1
a148 1
	/* check for root priviledges */
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d48 4
a51 4
void	main_sig_handler(int, short, void *);
void	usage(void);
void	ospfd_shutdown(void);
int	check_child(pid_t, const char *);
d105 1
a105 1
void
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * Copyright (c) 2004 Esben Norby <esben.norby@@ericsson.com>
@

