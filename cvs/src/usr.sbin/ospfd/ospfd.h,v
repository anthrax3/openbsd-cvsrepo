head	1.97;
access;
symbols
	OPENBSD_6_1_BASE:1.97
	OPENBSD_6_0:1.94.0.4
	OPENBSD_6_0_BASE:1.94
	OPENBSD_5_9:1.94.0.2
	OPENBSD_5_9_BASE:1.94
	OPENBSD_5_8:1.91.0.14
	OPENBSD_5_8_BASE:1.91
	OPENBSD_5_7:1.91.0.6
	OPENBSD_5_7_BASE:1.91
	OPENBSD_5_6:1.91.0.10
	OPENBSD_5_6_BASE:1.91
	OPENBSD_5_5:1.91.0.8
	OPENBSD_5_5_BASE:1.91
	OPENBSD_5_4:1.91.0.4
	OPENBSD_5_4_BASE:1.91
	OPENBSD_5_3:1.91.0.2
	OPENBSD_5_3_BASE:1.91
	OPENBSD_5_2:1.90.0.6
	OPENBSD_5_2_BASE:1.90
	OPENBSD_5_1_BASE:1.90
	OPENBSD_5_1:1.90.0.4
	OPENBSD_5_0:1.90.0.2
	OPENBSD_5_0_BASE:1.90
	OPENBSD_4_9:1.89.0.2
	OPENBSD_4_9_BASE:1.89
	OPENBSD_4_8:1.87.0.4
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.87.0.2
	OPENBSD_4_7_BASE:1.87
	OPENBSD_4_6:1.83.0.4
	OPENBSD_4_6_BASE:1.83
	OPENBSD_4_5:1.75.0.2
	OPENBSD_4_5_BASE:1.75
	OPENBSD_4_4:1.71.0.4
	OPENBSD_4_4_BASE:1.71
	OPENBSD_4_3:1.71.0.2
	OPENBSD_4_3_BASE:1.71
	OPENBSD_4_2:1.68.0.2
	OPENBSD_4_2_BASE:1.68
	OPENBSD_4_1:1.65.0.2
	OPENBSD_4_1_BASE:1.65
	OPENBSD_4_0:1.60.0.2
	OPENBSD_4_0_BASE:1.60
	OPENBSD_3_9:1.46.0.2
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16;
locks; strict;
comment	@ * @;


1.97
date	2017.01.24.04.24.25;	author benno;	state Exp;
branches;
next	1.96;
commitid	PUkGTVeidQeu8XjZ;

1.96
date	2017.01.23.00.12.36;	author jca;	state Exp;
branches;
next	1.95;
commitid	2o8lW93FfcozcY1I;

1.95
date	2016.09.02.14.02.48;	author benno;	state Exp;
branches;
next	1.94;
commitid	ZCYScyTMvHGcp7WF;

1.94
date	2015.12.05.12.20.13;	author claudio;	state Exp;
branches;
next	1.93;
commitid	ev1fE7U8gIdVx8OS;

1.93
date	2015.11.22.13.09.10;	author claudio;	state Exp;
branches;
next	1.92;
commitid	pxM0r18iZwdhX0Ks;

1.92
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.91;
commitid	kLBPo9HaQrkEaNW3;

1.91
date	2013.01.17.10.07.56;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.89;

1.89
date	2011.01.12.15.07.46;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2010.09.25.13.28.43;	author claudio;	state Exp;
branches;
next	1.87;

1.87
date	2010.02.19.10.35.52;	author dlg;	state Exp;
branches;
next	1.86;

1.86
date	2010.02.16.18.27.11;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2010.02.16.08.39.05;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2009.11.02.20.20.54;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2009.06.06.18.31.42;	author pyr;	state Exp;
branches;
next	1.82;

1.82
date	2009.06.06.07.31.26;	author eric;	state Exp;
branches;
next	1.81;

1.81
date	2009.06.05.19.33.59;	author pyr;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.05.04.12.52;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.05.01.19.09;	author pyr;	state Exp;
branches;
next	1.78;

1.78
date	2009.06.02.20.16.59;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2009.04.07.14.57.33;	author reyk;	state Exp;
branches;
next	1.76;

1.76
date	2009.03.04.12.51.01;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2009.01.31.11.44.49;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2009.01.07.21.16.36;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2008.12.12.22.43.17;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.24.18.28.02;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2007.10.11.12.19.31;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2007.09.25.11.25.41;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2007.09.11.16.02.55;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.19.16.45.15;	author reyk;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.29.22.08.25;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2007.03.21.10.54.30;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.01.13.02.04;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2007.02.01.12.51.01;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2006.12.21.17.22.29;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2006.12.07.19.14.27;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.17.08.55.31;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2006.06.28.10.53.39;	author norby;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.31.03.24.06;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.30.22.06.14;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2006.04.25.08.22.14;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2006.04.24.20.18.03;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2006.04.20.17.04.30;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.23.18.37.34;	author norby;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.22.16.01.20;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.15.13.25.33;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.09.18.11.34;	author norby;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.09.15.43.21;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.09.09.43.03;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.09.09.32.37;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.08.13.49.07;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2006.02.24.21.06.47;	author norby;	state Exp;
branches;
next	1.45;

1.45
date	2006.02.19.21.48.56;	author norby;	state Exp;
branches;
next	1.44;

1.44
date	2006.02.10.18.30.47;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2006.02.09.20.47.20;	author norby;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.01.18.31.47;	author norby;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.12.15.10.02;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.05.15.53.36;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.04.10.46.23;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2005.10.18.09.36.21;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.24.21.10.32;	author msf;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.17.20.03.35;	author msf;	state Exp;
branches;
next	1.35;

1.35
date	2005.06.26.19.22.12;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.27.02.07.13;	author norby;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.26.18.46.16;	author norby;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.26.04.09.24;	author norby;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.24.21.36.40;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.22.18.05.42;	author norby;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.12.19.10.12;	author norby;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.12.08.55.39;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.27.11.27.28;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.12.09.54.59;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.05.13.01.22;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.31.19.32.10;	author norby;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.29.17.26.35;	author norby;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.26.13.35.16;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.26.11.06.49;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.23.20.15.50;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.23.11.30.21;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.23.10.46.26;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.15.22.03.56;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.14.18.21.29;	author norby;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.12.11.03.05;	author norby;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.08.20.12.18;	author norby;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.07.10.28.14;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.27.08.21.15;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.24.16.28.43;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.16.15.23.33;	author norby;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.10.14.05.48;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.09.17.41.16;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.09.14.39.56;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.07.05.51.00;	author david;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.01.21.25.18;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.97
log
@sync log.c from relayd et al to ospfd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@
@
text
@/*	$OpenBSD: ospfd.h,v 1.96 2017/01/23 00:12:36 jca Exp $ */

/*
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _OSPFD_H_
#define _OSPFD_H_

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/tree.h>
#include <md5.h>
#include <net/if.h>
#include <netinet/in.h>
#include <event.h>

#include <imsg.h>
#include "ospf.h"
#include "log.h"

#define CONF_FILE		"/etc/ospfd.conf"
#define	OSPFD_SOCKET		"/var/run/ospfd.sock"
#define OSPFD_USER		"_ospfd"

#define NBR_HASHSIZE		128
#define LSA_HASHSIZE		512

#define NBR_IDSELF		1
#define NBR_CNTSTART		(NBR_IDSELF + 1)

#define	READ_BUF_SIZE		65535
#define	PKG_DEF_SIZE		512	/* compromise */
#define	RT_BUF_SIZE		16384
#define	MAX_RTSOCK_BUF		128 * 1024

#define	OSPFD_FLAG_NO_FIB_UPDATE	0x0001
#define	OSPFD_FLAG_STUB_ROUTER		0x0002

#define	F_OSPFD_INSERTED	0x0001
#define	F_KERNEL		0x0002
#define	F_CONNECTED		0x0004
#define	F_STATIC		0x0008
#define	F_DYNAMIC		0x0010
#define	F_DOWN			0x0020
#define	F_REJECT		0x0040
#define	F_BLACKHOLE		0x0080
#define	F_REDISTRIBUTED		0x0100

static const char * const log_procnames[] = {
	"parent",
	"ospfe",
	"rde"
};

struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	void			*data;
	short			 events;
};

enum imsg_type {
	IMSG_NONE,
	IMSG_CTL_RELOAD,
	IMSG_CTL_SHOW_INTERFACE,
	IMSG_CTL_SHOW_DATABASE,
	IMSG_CTL_SHOW_DB_EXT,
	IMSG_CTL_SHOW_DB_NET,
	IMSG_CTL_SHOW_DB_RTR,
	IMSG_CTL_SHOW_DB_SELF,
	IMSG_CTL_SHOW_DB_SUM,
	IMSG_CTL_SHOW_DB_ASBR,
	IMSG_CTL_SHOW_DB_OPAQ,
	IMSG_CTL_SHOW_NBR,
	IMSG_CTL_SHOW_RIB,
	IMSG_CTL_SHOW_SUM,
	IMSG_CTL_SHOW_SUM_AREA,
	IMSG_CTL_FIB_COUPLE,
	IMSG_CTL_FIB_DECOUPLE,
	IMSG_CTL_FIB_RELOAD,
	IMSG_CTL_AREA,
	IMSG_CTL_IFACE,
	IMSG_CTL_KROUTE,
	IMSG_CTL_KROUTE_ADDR,
	IMSG_CTL_IFINFO,
	IMSG_CTL_END,
	IMSG_CTL_LOG_VERBOSE,
	IMSG_KROUTE_CHANGE,
	IMSG_KROUTE_DELETE,
	IMSG_IFINFO,
	IMSG_NEIGHBOR_UP,
	IMSG_NEIGHBOR_DOWN,
	IMSG_NEIGHBOR_CHANGE,
	IMSG_NEIGHBOR_CAPA,
	IMSG_NETWORK_ADD,
	IMSG_NETWORK_DEL,
	IMSG_AREA_CHANGE,
	IMSG_DD,
	IMSG_DD_END,
	IMSG_DD_BADLSA,
	IMSG_DB_SNAPSHOT,
	IMSG_DB_END,
	IMSG_LS_REQ,
	IMSG_LS_UPD,
	IMSG_LS_SNAP,
	IMSG_LS_ACK,
	IMSG_LS_FLOOD,
	IMSG_LS_BADREQ,
	IMSG_LS_MAXAGE,
	IMSG_ABR_UP,
	IMSG_ABR_DOWN,
	IMSG_RECONF_CONF,
	IMSG_RECONF_AREA,
	IMSG_RECONF_IFACE,
	IMSG_RECONF_AUTHMD,
	IMSG_RECONF_REDIST,
	IMSG_RECONF_END,
	IMSG_DEMOTE,
	IMSG_IFADDRDEL
};

#define	REDIST_CONNECTED	0x01
#define	REDIST_STATIC		0x02
#define	REDIST_LABEL		0x04
#define	REDIST_ADDR		0x08
#define	REDIST_NO		0x10
#define	REDIST_DEFAULT		0x20

struct redistribute {
	SIMPLEQ_ENTRY(redistribute)	entry;
	struct in_addr			addr;
	struct in_addr			mask;
	u_int32_t			metric;
	u_int16_t			label;
	u_int16_t			type;
};
SIMPLEQ_HEAD(redist_list, redistribute);

struct vertex;
struct rde_nbr;
RB_HEAD(lsa_tree, vertex);

struct area {
	LIST_ENTRY(area)	 entry;
	struct in_addr		 id;
	struct lsa_tree		 lsa_tree;

	LIST_HEAD(, iface)	 iface_list;
	LIST_HEAD(, rde_nbr)	 nbr_list;
	struct redist_list	 redist_list;
/*	list			 addr_range_list; */
	char			 demote_group[IFNAMSIZ];
	u_int32_t		 stub_default_cost;
	u_int32_t		 num_spf_calc;
	int			 active;
	u_int8_t		 transit;
	u_int8_t		 stub;
	u_int8_t		 dirty;
	u_int8_t		 demote_level;
};

/* interface states */
#define	IF_STA_NEW		0x00	/* dummy state for reload */
#define	IF_STA_DOWN		0x01
#define	IF_STA_LOOPBACK		0x02
#define	IF_STA_WAITING		0x04
#define	IF_STA_POINTTOPOINT	0x08
#define	IF_STA_DROTHER		0x10
#define	IF_STA_BACKUP		0x20
#define	IF_STA_DR		0x40
#define IF_STA_DRORBDR		(IF_STA_DR | IF_STA_BACKUP)
#define	IF_STA_MULTI		(IF_STA_DROTHER | IF_STA_BACKUP | IF_STA_DR)
#define	IF_STA_ANY		0x7f

/* interface events */
enum iface_event {
	IF_EVT_NOTHING,
	IF_EVT_UP,
	IF_EVT_WTIMER,
	IF_EVT_BACKUP_SEEN,
	IF_EVT_NBR_CHNG,
	IF_EVT_LOOP,
	IF_EVT_UNLOOP,
	IF_EVT_DOWN
};

/* interface actions */
enum iface_action {
	IF_ACT_NOTHING,
	IF_ACT_STRT,
	IF_ACT_ELECT,
	IF_ACT_RST
};

/* interface types */
enum iface_type {
	IF_TYPE_POINTOPOINT,
	IF_TYPE_BROADCAST,
	IF_TYPE_NBMA,
	IF_TYPE_POINTOMULTIPOINT,
	IF_TYPE_VIRTUALLINK
};

/* neighbor states */
#define	NBR_STA_DOWN		0x0001
#define	NBR_STA_ATTEMPT		0x0002
#define	NBR_STA_INIT		0x0004
#define	NBR_STA_2_WAY		0x0008
#define	NBR_STA_XSTRT		0x0010
#define NBR_STA_SNAP		0x0020
#define	NBR_STA_XCHNG		0x0040
#define	NBR_STA_LOAD		0x0080
#define	NBR_STA_FULL		0x0100
#define	NBR_STA_ACTIVE		(~NBR_STA_DOWN)
#define	NBR_STA_FLOOD		(NBR_STA_XCHNG | NBR_STA_LOAD | NBR_STA_FULL)
#define	NBR_STA_ADJFORM		(NBR_STA_XSTRT | NBR_STA_SNAP | NBR_STA_FLOOD)
#define	NBR_STA_BIDIR		(NBR_STA_2_WAY | NBR_STA_ADJFORM)
#define	NBR_STA_PRELIM		(NBR_STA_DOWN | NBR_STA_ATTEMPT | NBR_STA_INIT)
#define	NBR_STA_ANY		0xffff

/* neighbor events */
enum nbr_event {
	NBR_EVT_NOTHING,
	NBR_EVT_HELLO_RCVD,
	NBR_EVT_2_WAY_RCVD,
	NBR_EVT_NEG_DONE,
	NBR_EVT_SNAP_DONE,
	NBR_EVT_XCHNG_DONE,
	NBR_EVT_BAD_LS_REQ,
	NBR_EVT_LOAD_DONE,
	NBR_EVT_ADJ_OK,
	NBR_EVT_SEQ_NUM_MIS,
	NBR_EVT_1_WAY_RCVD,
	NBR_EVT_KILL_NBR,
	NBR_EVT_ITIMER,
	NBR_EVT_LL_DOWN,
	NBR_EVT_ADJTMOUT
};

/* neighbor actions */
enum nbr_action {
	NBR_ACT_NOTHING,
	NBR_ACT_RST_ITIMER,
	NBR_ACT_STRT_ITIMER,
	NBR_ACT_EVAL,
	NBR_ACT_SNAP,
	NBR_ACT_SNAP_DONE,
	NBR_ACT_XCHNG_DONE,
	NBR_ACT_ADJ_OK,
	NBR_ACT_RESTRT_DD,
	NBR_ACT_DEL,
	NBR_ACT_CLR_LST,
	NBR_ACT_HELLO_CHK
};

/* auth types */
enum auth_type {
	AUTH_NONE,
	AUTH_SIMPLE,
	AUTH_CRYPT
};

/* spf states */
enum spf_state {
	SPF_IDLE,
	SPF_DELAY,
	SPF_HOLD,
	SPF_HOLDQUEUE
};

enum dst_type {
	DT_NET,
	DT_RTR
};

enum path_type {
	PT_INTRA_AREA,
	PT_INTER_AREA,
	PT_TYPE1_EXT,
	PT_TYPE2_EXT
};

enum rib_type {
	RIB_NET = 1,
	RIB_RTR,
	RIB_EXT
};

struct auth_md {
	TAILQ_ENTRY(auth_md)	 entry;
	char			 key[MD5_DIGEST_LENGTH];
	u_int8_t		 keyid;
};

/* lsa list used in RDE and OE */
TAILQ_HEAD(lsa_head, lsa_entry);
TAILQ_HEAD(auth_md_head, auth_md);

struct iface {
	LIST_ENTRY(iface)	 entry;
	struct event		 hello_timer;
	struct event		 wait_timer;
	struct event		 lsack_tx_timer;

	LIST_HEAD(, nbr)	 nbr_list;
	struct auth_md_head	 auth_md_list;
	struct lsa_head		 ls_ack_list;
	struct lsa_tree		 lsa_tree;

	char			 name[IF_NAMESIZE];
	char			 demote_group[IFNAMSIZ];
	char			 auth_key[MAX_SIMPLE_AUTH_LEN];
	struct in_addr		 addr;
	struct in_addr		 dst;
	struct in_addr		 mask;
	struct in_addr		 abr_id;
	struct nbr		*dr;	/* designated router */
	struct nbr		*bdr;	/* backup designated router */
	struct nbr		*self;
	struct area		*area;

	u_int64_t		 baudrate;
	u_int32_t		 dead_interval;
	u_int32_t		 fast_hello_interval;
	u_int32_t		 ls_ack_cnt;
	u_int32_t		 crypt_seq_num;
	time_t			 uptime;
	unsigned int		 ifindex;
	u_int			 rdomain;
	int			 fd;
	int			 state;
	int			 mtu;
	u_int16_t		 flags;
	u_int16_t		 transmit_delay;
	u_int16_t		 hello_interval;
	u_int16_t		 rxmt_interval;
	u_int16_t		 metric;
	enum iface_type		 type;
	enum auth_type		 auth_type;
	u_int8_t		 if_type;
	u_int8_t		 auth_keyid;
	u_int8_t		 linkstate;
	u_int8_t		 priority;
	u_int8_t		 passive;
};

struct ifaddrdel {
	struct in_addr		addr;
	unsigned int		ifindex;
};

/* ospf_conf */
enum {
	PROC_MAIN,
	PROC_OSPF_ENGINE,
	PROC_RDE_ENGINE
} ospfd_process;

struct ospfd_conf {
	struct event		ev;
	struct in_addr		rtr_id;
	LIST_HEAD(, area)	area_list;
	LIST_HEAD(, vertex)	cand_list;
	struct redist_list	redist_list;

	u_int32_t		opts;
#define OSPFD_OPT_VERBOSE	0x00000001
#define OSPFD_OPT_VERBOSE2	0x00000002
#define OSPFD_OPT_NOACTION	0x00000004
#define OSPFD_OPT_STUB_ROUTER	0x00000008
#define OSPFD_OPT_FORCE_DEMOTE	0x00000010
	u_int32_t		spf_delay;
	u_int32_t		spf_hold_time;
	time_t			uptime;
	int			spf_state;
	int			ospf_socket;
	int			flags;
	u_int8_t		rfc1583compat;
	u_int8_t		border;
	u_int8_t		redistribute;
	u_int			rdomain;
	char			*csock;
};

/* kroute */
struct kroute {
	struct in_addr	prefix;
	struct in_addr	nexthop;
	u_int32_t	ext_tag;
	u_int32_t	metric;
	u_int16_t	flags;
	u_int16_t	rtlabel;
	u_short		ifindex;
	u_int8_t	prefixlen;
	u_int8_t	priority;
};

struct kif_addr {
	TAILQ_ENTRY(kif_addr)	 entry;
	struct in_addr		 addr;
	struct in_addr		 mask;
	struct in_addr		 dstbrd;
};

struct kif {
	char			 ifname[IF_NAMESIZE];
	u_int64_t		 baudrate;
	int			 flags;
	int			 mtu;
	unsigned int		 ifindex;
	u_int			 rdomain;
	u_int8_t		 if_type;
	u_int8_t		 link_state;
	u_int8_t		 nh_reachable;	/* for nexthop verification */
};

/* name2id */
struct n2id_label {
	TAILQ_ENTRY(n2id_label)	 entry;
	char			*name;
	u_int16_t		 id;
	u_int32_t		 ext_tag;
	int			 ref;
};

TAILQ_HEAD(n2id_labels, n2id_label);
extern struct n2id_labels rt_labels;

/* control data structures */
struct ctl_iface {
	char			 name[IF_NAMESIZE];
	struct in_addr		 addr;
	struct in_addr		 mask;
	struct in_addr		 area;
	struct in_addr		 rtr_id;
	struct in_addr		 dr_id;
	struct in_addr		 dr_addr;
	struct in_addr		 bdr_id;
	struct in_addr		 bdr_addr;
	struct timeval		 hello_timer;
	time_t			 uptime;
	u_int64_t		 baudrate;
	u_int32_t		 dead_interval;
	u_int32_t		 fast_hello_interval;
	unsigned int		 ifindex;
	int			 state;
	int			 mtu;
	int			 nbr_cnt;
	int			 adj_cnt;
	u_int16_t		 transmit_delay;
	u_int16_t		 hello_interval;
	u_int16_t		 flags;
	u_int16_t		 metric;
	u_int16_t		 rxmt_interval;
	enum iface_type		 type;
	u_int8_t		 linkstate;
	u_int8_t		 if_type;
	u_int8_t		 priority;
	u_int8_t		 passive;
	enum auth_type		 auth_type;
	u_int8_t		 auth_keyid;
};

struct ctl_nbr {
	char			 name[IF_NAMESIZE];
	struct in_addr		 id;
	struct in_addr		 addr;
	struct in_addr		 dr;
	struct in_addr		 bdr;
	struct in_addr		 area;
	time_t			 dead_timer;
	time_t			 uptime;
	u_int32_t		 db_sum_lst_cnt;
	u_int32_t		 ls_req_lst_cnt;
	u_int32_t		 ls_retrans_lst_cnt;
	u_int32_t		 state_chng_cnt;
	int			 nbr_state;
	int			 iface_state;
	u_int8_t		 priority;
	u_int8_t		 options;
};

struct ctl_rt {
	struct in_addr		 prefix;
	struct in_addr		 nexthop;
	struct in_addr		 area;
	struct in_addr		 adv_rtr;
	time_t			 uptime;
	u_int32_t		 cost;
	u_int32_t		 cost2;
	enum path_type		 p_type;
	enum dst_type		 d_type;
	u_int8_t		 flags;
	u_int8_t		 prefixlen;
	u_int8_t		 connected;
};

struct ctl_sum {
	struct in_addr		 rtr_id;
	u_int32_t		 spf_delay;
	u_int32_t		 spf_hold_time;
	u_int32_t		 num_ext_lsa;
	u_int32_t		 num_area;
	u_int32_t		 ext_lsa_cksum;
	time_t			 uptime;
	u_int8_t		 rfc1583compat;
};

struct ctl_sum_area {
	struct in_addr		 area;
	u_int32_t		 num_iface;
	u_int32_t		 num_adj_nbr;
	u_int32_t		 num_spf_calc;
	u_int32_t		 num_lsa;
	u_int32_t		 lsa_cksum;
};

struct demote_msg {
	char			 demote_group[IF_NAMESIZE];
	int			 level;
};

/* area.c */
struct area	*area_new(void);
int		 area_del(struct area *);
struct area	*area_find(struct ospfd_conf *, struct in_addr);
void		 area_track(struct area *);
int		 area_border_router(struct ospfd_conf *);
u_int8_t	 area_ospf_options(struct area *);

/* carp.c */
int		 carp_demote_init(char *, int);
void		 carp_demote_shutdown(void);
int		 carp_demote_get(char *);
int		 carp_demote_set(char *, int);

/* parse.y */
struct ospfd_conf	*parse_config(char *, int);
int			 cmdline_symset(char *);

/* in_cksum.c */
u_int16_t	 in_cksum(void *, size_t);

/* iso_cksum.c */
u_int16_t	 iso_cksum(void *, u_int16_t, u_int16_t);

/* kroute.c */
int		 kif_init(void);
void		 kif_clear(void);
int		 kr_init(int, u_int);
int		 kr_change(struct kroute *, int);
int		 kr_delete(struct kroute *);
void		 kr_shutdown(void);
void		 kr_fib_couple(void);
void		 kr_fib_decouple(void);
void		 kr_fib_reload(void);
void		 kr_dispatch_msg(int, short, void *);
void		 kr_show_route(struct imsg *);
void		 kr_ifinfo(char *, pid_t);
struct kif	*kif_findname(char *, struct in_addr, struct kif_addr **);
void		 kr_reload(void);

u_int8_t	mask2prefixlen(in_addr_t);
in_addr_t	prefixlen2mask(u_int8_t);

/* logmsg.h */
const char	*nbr_state_name(int);
const char	*if_state_name(int);
const char	*if_type_name(enum iface_type);
const char	*if_auth_name(enum auth_type);
const char	*dst_type_name(enum dst_type);
const char	*path_type_name(enum path_type);

/* name2id.c */
u_int16_t	 rtlabel_name2id(const char *);
const char	*rtlabel_id2name(u_int16_t);
void		 rtlabel_unref(u_int16_t);
u_int32_t	 rtlabel_id2tag(u_int16_t);
u_int16_t	 rtlabel_tag2id(u_int32_t);
void		 rtlabel_tag(u_int16_t, u_int32_t);

/* ospfd.c */
void	main_imsg_compose_ospfe(int, pid_t, void *, u_int16_t);
void	main_imsg_compose_rde(int, pid_t, void *, u_int16_t);
int	ospf_redistribute(struct kroute *, u_int32_t *);
void	merge_config(struct ospfd_conf *, struct ospfd_conf *);
void	imsg_event_add(struct imsgev *);
int	imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, void *, u_int16_t);

/* printconf.c */
void	print_config(struct ospfd_conf *);

#endif	/* _OSPFD_H_ */
@


1.96
log
@Remove incomplete "forced nexthop" support.

Discussed with claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.95 2016/09/02 14:02:48 benno Exp $ */
d34 1
d582 1
a582 1
/* log.h */
@


1.95
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.94 2015/12/05 12:20:13 claudio Exp $ */
a61 1
#define	F_FORCED_NEXTHOP	0x0200
@


1.94
log
@Pledge ospfd SE ("stdio inet mcast") and RDE ("stdio") move some code
around to make it possible. Parent can't be pledged at the moment because
of carp ioctl (carp demote). Putting it in so that people can test.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.93 2015/11/22 13:09:10 claudio Exp $ */
d63 6
@


1.93
log
@Improve ABR support especially for self-originated stub networks.
This seems to solve the last issues people reported when using ospfd
in multiple areas. OK sthen@@ prodding by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.92 2015/09/27 17:31:50 stsp Exp $ */
d339 1
d420 2
a421 1
	u_short			 ifindex;
d559 1
@


1.92
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.91 2013/01/17 10:07:56 markus Exp $ */
d107 1
d503 1
d535 1
a535 1
void		 area_track(struct area *, int);
@


1.91
log
@improve snapshot handling:
- don't start a new snapshot if we are already in NBR_STA_SNAP
- ignore IMSG_DB_SNAPSHOT and IMSG_DB_END unless we are in NBR_STA_SNAP
- add new IMSG_LS_SNAP message so we can distinguish it from
  IMSG_LS_UPD. this way we can ignore them if we are not in NBR_STA_SNAP
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.90 2011/05/09 12:24:41 claudio Exp $ */
d348 1
a348 1
	u_int8_t		 media_type;
d419 1
a419 1
	u_int8_t		 media_type;
d464 1
a464 1
	u_int8_t		 mediatype;
@


1.90
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.89 2011/01/12 15:07:46 claudio Exp $ */
d114 1
@


1.89
log
@Kill struct rroute and move the metric to struct kroute. This
disturbed me for a long time and makes upcomming work a bit easier.
OK sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.88 2010/09/25 13:28:43 claudio Exp $ */
d83 1
d92 1
d104 1
d316 1
@


1.88
log
@When counting the lsa also build the sum of the ls_checksums. This can be
used to quickly verify if two LSDBs are in sync. Other systems do the same.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.87 2010/02/19 10:35:52 dlg Exp $ */
d62 1
d393 1
a398 5
};

struct rroute {
	struct kroute	kr;
	u_int32_t	metric;
@


1.87
log
@implement ospfctl fib reload.

this tells the daemon to resync the kernels list of interfaces and routes
with the daemons list. this is very useful if the routing socket overflows
and you want to sync things up again.

lots and lots of help from claudio@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.85 2010/02/16 08:39:05 dlg Exp $ */
d508 1
d519 1
@


1.86
log
@Pick up RTM_DELADDR and issue an internal IFADDRDEL message to the ospfe to
inform about the interface address change. If this is an active interface
it will be downed. A ospfctl reload is needed to fetch the new/changed IP
if one got set. OK dlg@@, sthen@@
@
text
@d88 1
d557 1
@


1.85
log
@implement support for fast hello packets.

if route-dead-time is set to "minimal" (rather than a number of
seconds), the dead time is set to 1 second and hellos are sent at
the interval specified by fast-hello-interval in msecs. this is non
standard wrt to the ospf rfc, but it does interoperate with at least
one other router vendor.

this allows much better responsiveness to l3 topology changes than
the standard intervals allow. if i yank a cable to one of my
upstreams, the routes adjust in a second rather than the default
of 40 i was running with before. the users dont even notice something
changed.

developed while working with joshua atterbury.
ok claudio@@ as part of a larger diff.
dedicated to zan rowe who thinks she is a bigger nerd than me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.84 2009/11/02 20:20:54 claudio Exp $ */
d121 2
a122 1
	IMSG_DEMOTE
d346 5
@


1.84
log
@Implement IMSG_CTL_LOG_VERBOSE to enable or disable debug logging on runtime.
It always annoyed me that in case of a problem I had to restart the ospf in
forground debug mode and by doing so losing all routes at least twice.
OK henning, sthen, michele
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.83 2009/06/06 18:31:42 pyr Exp $ */
d325 1
d438 1
a438 1
	time_t			 hello_timer;
d442 1
@


1.83
log
@Get ready for including imsg.h from a lib, when it comes along.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.82 2009/06/06 07:31:26 eric Exp $ */
d93 1
@


1.82
log
@sync ospfctl/ospfd with the common imsg code, making it lib ready as well.

"looks ok" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.81 2009/06/05 19:33:59 pyr Exp $ */
d32 1
a32 1
#include "imsg.h"
@


1.81
log
@make ospfd's imsg lib ready as well.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.80 2009/06/05 04:12:52 claudio Exp $ */
d63 8
d577 2
a578 2
void	imsg_event_add(struct imsgbuf *);
int	imsg_compose_event(struct imsgbuf *, u_int16_t, u_int32_t,
@


1.80
log
@Preliminary rdomain support, all hacked up by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.79 2009/06/05 01:19:09 pyr Exp $ */
d32 1
a62 36
/* buffer */
struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 max;
	size_t			 wpos;
	size_t			 rpos;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

#define	IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
#define	MAX_IMSGSIZE		8192

struct buf_read {
	u_char			 buf[READ_BUF_SIZE];
	u_char			*rptr;
	size_t			 wpos;
};

struct imsgbuf {
	TAILQ_HEAD(, imsg_fd)	fds;
	struct buf_read		r;
	struct msgbuf		w;
	struct event		ev;
	void			(*handler)(int, short, void *);
	int			fd;
	pid_t			pid;
	short			events;
};

a114 12
struct imsg_hdr {
	enum imsg_type	type;
	u_int16_t	len;
	u_int32_t	peerid;
	pid_t		pid;
};

struct imsg {
	struct imsg_hdr	 hdr;
	void		*data;
};

a514 14
/* buffer.c */
struct buf	*buf_open(size_t);
struct buf	*buf_dynamic(size_t, size_t);
int		 buf_add(struct buf *, const void *, size_t);
void		*buf_reserve(struct buf *, size_t);
void		*buf_seek(struct buf *, size_t, size_t);
size_t		 buf_size(struct buf *);
size_t		 buf_left(struct buf *);
void		 buf_close(struct msgbuf *, struct buf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);

a524 13
/* imsg.c */
void	 imsg_init(struct imsgbuf *, int, void (*)(int, short, void *));
ssize_t	 imsg_read(struct imsgbuf *);
ssize_t	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    void *, u_int16_t);
struct buf	*imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
		    u_int16_t);
int	 imsg_add(struct buf *, void *, u_int16_t);
int	 imsg_close(struct imsgbuf *, struct buf *);
void	 imsg_free(struct imsg *);
void	 imsg_event_add(struct imsgbuf *); /* needs to be provided externally */

d569 3
@


1.79
log
@treat buf->wpos as the size to send out on the wire, not buf->size,
this plays better with dynamic buffers which are now the norm.
ok by a slightly annoyed claudio@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.78 2009/06/02 20:16:59 claudio Exp $ */
d413 1
d607 1
a607 1
int		 kr_init(int);
@


1.78
log
@Track reject and blackhole routes and allow them to be redistributed even
though they point to the loopback. Mainly used for redistribute default since
on default free routers we need to have a fake route now.
After discussion with Tonnerre Lombard, idea OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.77 2009/04/07 14:57:33 reyk Exp $ */
d569 1
a569 1
int		 buf_close(struct msgbuf *, struct buf *);
@


1.77
log
@allow to specify an alternate control socket instead of /var/run/ospfd.sock.
this is required to run multiple instances of ospfd.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.76 2009/03/04 12:51:01 claudio Exp $ */
d54 6
a59 4
#define	F_CONNECTED		0x0008
#define	F_DOWN			0x0010
#define	F_STATIC		0x0020
#define	F_DYNAMIC		0x0040
@


1.76
log
@Introduce and use buf_size(buf) instead of buf->wpos -- at least in the non
buf/imsg specific code. buf_close() will no force a truncation of the buffer
to the wpos but actually add code in imsg.c to detect and report such silly
behaviour. Makes the buf API a bit more sane.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.75 2009/01/31 11:44:49 claudio Exp $ */
d411 1
@


1.75
log
@Implement buf_left() to make some some more buffer handling easier.
buf_left() returns the bytes left in a buffer. This makes the check to
keep MD5_DIGEST_LENGTH bytes unallocated in some messages easier.
From the buf cleanup diff that was OK norby@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.74 2009/01/07 21:16:36 claudio Exp $ */
d561 1
a561 1
int		 buf_add(struct buf *, void *, size_t);
d564 1
@


1.74
log
@Full stub area support. This allows ABRs to announce a default network
summary LSA into stub areas so that these routers are able to reach the
outside of the area.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.73 2008/12/12 22:43:17 claudio Exp $ */
d564 1
@


1.73
log
@Make the kroute code routing priority aware. This solves a few issues and
makes to code simpler. While the routing table is somewhat simpler the
redistribution code does not allow a much more radical approach. With some
additional help of Mr. Kernel and his rtsock it should be possible to rip
even more code out of kroute.c.
Tested and OK sthen@@, gollo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.72 2008/11/24 18:28:02 claudio Exp $ */
a59 3
#define REDISTRIBUTE_ON		0x01
#define REDISTRIBUTE_DEFAULT	0x02

d143 1
d160 17
a176 1
/* area */
d188 1
a388 15
#define	REDIST_CONNECTED	0x01
#define	REDIST_STATIC		0x02
#define	REDIST_LABEL		0x04
#define	REDIST_ADDR		0x08
#define	REDIST_NO		0x10

struct redistribute {
	SIMPLEQ_ENTRY(redistribute)	entry;
	struct in_addr			addr;
	struct in_addr			mask;
	u_int32_t			metric;
	u_int16_t			label;
	u_int16_t			type;
};

d394 1
a394 1
	SIMPLEQ_HEAD(, redistribute) redist_list;
a395 1
	u_int32_t		defaultmetric;
@


1.72
log
@Initial support for stub areas. The bit still missing is the redistribution
of the default summary net lsa on ABRs but that is comming. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.71 2007/10/11 12:19:31 claudio Exp $ */
a53 1
#define	F_BGPD_INSERTED		0x0004
a122 1
	IMSG_KROUTE_GET,
d418 1
a420 1
	u_int32_t	ext_tag;
d423 1
@


1.71
log
@Bye bye global ospf options. OSPF options are per area (at least the one
flag that we set). So introduce a area_ospf_options() function that will
return the correct flags for each area. This makes stub area support a lot
easier.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.70 2007/09/25 11:25:41 claudio Exp $ */
d133 1
@


1.70
log
@Last missing piece in the equal cost multipath support for ospfd.
Send all possible nexthops to the parent process and correctly sync
the RIB, FIB and kernel routing table. Based on initial work by pyr@@.
OK pyr@@ norby@@
PS: don't forget that you need to enable multipath support via a sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.69 2007/09/11 16:02:55 claudio Exp $ */
a409 1
	int			options; /* OSPF options */
d557 1
@


1.69
log
@Switch some more baudrates to 64 bit and initialize iface->baudrate.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.68 2007/06/19 16:45:15 reyk Exp $ */
d603 1
a603 1
int		 kr_change(struct kroute *);
@


1.68
log
@add support for mapping route labels to AS-external route tags.

manpage bits from jmc@@
ok norby@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.67 2007/05/29 22:08:25 claudio Exp $ */
d345 1
a345 1
	u_int32_t		 baudrate;
d441 1
a441 1
	u_long			 baudrate;
d475 1
a475 1
	u_int32_t		 baudrate;
@


1.67
log
@Demote support for ospfd. It is possible to specify a demote group on
interfaces and areas. With this carp setups using ospfd are more reliable
because we can fail over if the OSPF connectivity is (partially) lost.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.66 2007/03/21 10:54:30 claudio Exp $ */
d422 1
d450 12
d629 3
@


1.66
log
@Add support for RFC 3137: OSPF Stub Router Advertisement
This allows ospfd to announce networks without the need to transit traffic.
stub router is enabled if the fib is not coupled, net.inet.ip.forwarding is
not 1 or if the stub router global config option is set to yes.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.65 2007/02/01 13:02:04 claudio Exp $ */
d147 2
a148 1
	IMSG_RECONF_END
d176 1
d183 1
d334 1
d403 1
d534 5
d557 6
@


1.65
log
@Preliminary configuration reload support. Seems to work reasonably well
after fixing many use-after-free errors a couple of days ago.
Most cases -- adding/removing of interfaces, adding/removing of areas --
seem to work. Still merge_config() is a behemoth of a function and some
edge cases may not be covered correctly (yet).
OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.64 2007/02/01 12:51:01 claudio Exp $ */
d50 1
d398 1
@


1.64
log
@kr_reload() -- another helper function for reload support. This one
takes care that redistribution is correct after reload. OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.63 2006/12/21 17:22:29 claudio Exp $ */
d141 6
a146 1
	IMSG_ABR_DOWN
d183 1
d603 1
@


1.63
log
@Unbreak redistribute default and make it possible to specify a metric for
the default route as well. OK norby@@, michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.62 2006/12/07 19:14:27 claudio Exp $ */
d575 1
@


1.62
log
@Make it possible to set the metric and LSA type for redistributed routes.
Mostly based on a diff by Pierre-Yves Ritschard (I just simplified the parser
code). OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.61 2006/11/17 08:55:31 claudio Exp $ */
d386 1
@


1.61
log
@Support for multiple networks on one interface. Until now only the main
address of a interface could be used. Now it is possible to specify a
interface more than once if multiple networks are configured. An alternative
network can be specified via e.g. interface em0:10.0.5.1. The old interface
syntax without the IP still works and uses the main/first configured IP
address.
ospfd now needs to include the IP header on outgoing messages as it is not
possible to specifiy the source address in sendto(2). Additionally all
multicast joins and leaves have to be tracked.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.60 2006/06/28 10:53:39 norby Exp $ */
d374 1
d412 5
d594 1
a594 1
int	ospf_redistribute(struct kroute *kr);
@


1.60
log
@Track the uptime of the ospfd daemon itself.
It is possible to read the uptime of the daemon with the "ospfctl show"
command.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.59 2006/05/31 03:24:06 claudio Exp $ */
d411 7
d567 1
a567 1
struct kif	*kif_findname(char *);
@


1.59
log
@More redistribute fun. Add a possibility to deny redistribution of specified
routes via "no redistribute rtlabel admin". Redistribute rules are parsed
in order and the first match is used. Only exception is "redistribute default"
Which is independent of the other rules and can't be negated.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.58 2006/05/30 22:06:14 claudio Exp $ */
d391 1
d495 1
@


1.58
log
@Now that rtlabels are accessable via sysctl we can use route lables to
define which routes should be redistributed via OSPF. So now you can
define the export list on a fine graded basis. More to come... OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.57 2006/04/25 08:22:14 claudio Exp $ */
d364 5
a368 6
enum redist_types {
	REDIST_CONNECTED,
	REDIST_STATIC,
	REDIST_LABEL,
	REDIST_ADDR
};
d375 1
a375 1
	enum redist_types		type;
@


1.57
log
@Path the length of the packet as size_t to in_cksum(). Enforce that the
passed size is not bigger than 2^16 (limit of the used algorithm).
This removes some more lint warnings and makes sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.56 2006/04/24 20:18:03 claudio Exp $ */
d60 2
a61 3
#define REDISTRIBUTE_STATIC	0x01
#define REDISTRIBUTE_CONNECTED	0x02
#define REDISTRIBUTE_DEFAULT	0x04
d364 15
d384 1
a394 1
	int			redistribute_flags;
d398 1
d406 1
d571 5
@


1.56
log
@Fix parser to match current behaviour and make auth-type et al. part of the
global and per area defaults. With this it is now possible to define one
set of auth-md keys and use them in every defined interface. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.55 2006/04/20 17:04:30 claudio Exp $ */
d527 1
a527 1
u_int16_t	 in_cksum(void *, int);
@


1.55
log
@Simplify the defaults handling. This is long overdue and necessary to add
auth-type et al. to the main and area blocks. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.54 2006/03/23 18:37:34 norby Exp $ */
d312 1
d321 1
a321 1
	TAILQ_HEAD(, auth_md)	 auth_md_list;
@


1.54
log
@List interfaces they way we list neighbors etc.
This makes it much easier to grep in the output.
The original format of "show interface" can be seen with
"show interface detail".

help and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.53 2006/03/22 16:01:20 claudio Exp $ */
a171 1
	u_int32_t		 dead_interval;
a172 5
	u_int16_t		 transmit_delay;
	u_int16_t		 hello_interval;
	u_int16_t		 rxmt_interval;
	u_int16_t		 metric;
	u_int8_t		 priority;
@


1.53
log
@Move the AS external LSA tree out of struct ospfd_config. This simplifies
the code and makes config reloads easier. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.52 2006/03/15 13:25:33 claudio Exp $ */
d438 1
@


1.52
log
@Looks like auth-type simple was busted since a long time. We bcmp() a
c string with a lenght <= 8 with a buffer of size 8. Now in some cases
there can be trailing garbage after the c-string and so the bcmp() fails.
Found by Sergey Matveychuk who provided a similar patch.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.51 2006/03/09 18:11:34 norby Exp $ */
a372 1
	struct lsa_tree		lsa_tree;
@


1.51
log
@Track interface uptime.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.50 2006/03/09 15:43:21 claudio Exp $ */
d32 2
d330 1
a334 1
	char			*auth_key;
@


1.50
log
@Move *_name functions to log.c and use these for both ospfd and ospfctl.
Stuff that is only used in ospfd debug messages is simplified.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.49 2006/03/09 09:43:03 claudio Exp $ */
d342 1
d422 1
@


1.49
log
@in_cksum() should return a u_int16_t and not int. Switch a variable to
unsigned. Found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.48 2006/03/09 09:32:37 claudio Exp $ */
d223 52
a294 5
static const char * const dst_type_names[] = {
	"Network",
	"Router"
};

a307 7
static const char * const path_type_names[] = {
	"Intra-Area",
	"Inter-Area",
	"Type 1 ext",
	"Type 2 ext"
};

d548 8
@


1.48
log
@if_event_names is only used by interface.c so move it there.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.47 2006/03/08 13:49:07 claudio Exp $ */
d488 1
a488 1
int		 in_cksum(void *, int);
@


1.47
log
@Fix logic of the kroute code. First of all there was a porblem if a prefix
is known via kernel and ospf. If the kernel route is removed the ospf one
was not added to the FIB. This is an uncommon event so it is OK to request
an update from the RIB in this case.
Additionally ospfd treated bgpd inserted routes like static routes. This
is wrong because IGP routes habe a higher preference over EGP routes. In
this case a bgpd route needs to be overridden by a ospfd one.
With these to fixes bgpd and ospfd start to play nicely together.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.46 2006/02/24 21:06:47 norby Exp $ */
a203 11
};

static const char * const if_event_names[] = {
	"NOTHING",
	"UP",
	"WAITTIMER",
	"BACKUPSEEN",
	"NEIGHBORCHANGE",
	"LOOP",
	"UNLOOP",
	"DOWN"
@


1.46
log
@Keep track of the uptime of the entries in the RIB.
It is now possible to see the uptime of the individual entries in the RIB.
The uptime can be displayed with "ospfctl show rib"

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.45 2006/02/19 21:48:56 norby Exp $ */
d51 2
a52 1
#define	F_CONNECTED		0x0004
a55 1
#define	F_LONGER		0x0080
d122 1
@


1.45
log
@Keep track of the duration of our relationships with neighbors.
Displayed in "ospfctl show neighbor".

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.44 2006/02/10 18:30:47 claudio Exp $ */
d435 1
@


1.44
log
@ospfd does not need fd passing via the imsg framework so remove that code
and remove other unneeded functions that are only used in bgpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.43 2006/02/09 20:47:20 norby Exp $ */
d419 1
@


1.43
log
@Don't calculate all areas every time the link state database is updated,
only calculate the dirty ones.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.42 2006/02/01 18:31:47 norby Exp $ */
a69 1
	int			 fd;
a153 5
struct imsg_fd {
	TAILQ_ENTRY(imsg_fd)	entry;
	int			fd;
};

a472 1
int		 buf_write(int, struct buf *);
a476 2
int		 msgbuf_writebound(struct msgbuf *);
int		 msgbuf_unbounded(struct msgbuf *msgbuf);
d484 3
a486 3
int	 imsg_read(struct imsgbuf *);
int	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t, int,
@


1.42
log
@zap unused function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.41 2006/01/12 15:10:02 claudio Exp $ */
d184 1
@


1.41
log
@Rewrite the redistribute code. The previous implementation was stupid and
resulted in a major bottleneck if bgpd was used on the same box -- not clever
to do linear searches over 175k entries :(. This now moves the redistribute
code back into kroute duty and kills the linear list. Also default routes are
now redistributed without the need for a kernel default route.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.40 2006/01/05 15:53:36 claudio Exp $ */
a500 1
int	 imsg_get_fd(struct imsgbuf *);
@


1.40
log
@Make ospfd respect carp(4) interfaces and their weird behaviour. They will
not be used to connect to a OSPF cloud and forced to be passive. With this
ospfd will only announce the carp interface route if the interface is master.
So you can connect a LAN in a redundant way to your ospf backbone. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.39 2005/11/04 10:46:23 claudio Exp $ */
d56 1
a521 2
void		 kif_update(struct kif *);
int		 kif_validate(int);
d529 1
@


1.39
log
@Kill spf_timer in struct ospfd_conf. There is no need for two event structs
just use ev for the spf_timer -- ev is unused in the RDE.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.38 2005/10/18 09:36:21 claudio Exp $ */
d327 1
@


1.38
log
@The kroute nexthop stuff was removed long time ago. So remove these
function prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.37 2005/09/24 21:10:32 msf Exp $ */
a341 1
	struct event		spf_timer;
@


1.37
log
@- add auth_type and auth_keyid to struct ctl_iface
- have ospfctl tell us when we are using authentication with 'show interface'

ok claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.36 2005/09/17 20:03:35 msf Exp $ */
a517 2
int		 kr_nexthop_add(struct in_addr);
void		 kr_nexthop_delete(struct in_addr);
@


1.36
log
@- add get_rtr_id() based on bgpd's get_bgpid()
- remove rtr_id from struct iface we don't need to keep a copy of this value
  per interface
- replace all references to iface->rtr_id.s_addr with calls to ospfe_rtr_id()

ok claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.35 2005/06/26 19:22:12 claudio Exp $ */
d411 2
@


1.35
log
@Do not automaticaly announce routes that have RTF_DYNAMIC set. These routes
are e.g. created by the PMTU code and are removed after some time.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.34 2005/05/27 02:07:13 norby Exp $ */
a304 1
	struct in_addr		 rtr_id;
@


1.34
log
@Preparations for virtual link support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.33 2005/05/26 18:46:16 norby Exp $ */
d54 2
a55 1
#define	F_LONGER		0x0040
@


1.33
log
@Support dumping the configuration the way bgpd(8) does it.

This makes it possible to have ospfd(8) parse a configuration file and
display the parsed result.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.32 2005/05/26 04:09:24 norby Exp $ */
d136 3
a138 1
	IMSG_LS_MAXAGE
d305 1
@


1.32
log
@Remove unused variable.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.31 2005/05/24 21:36:40 claudio Exp $ */
a457 2
void		 show_config(struct ospfd_conf *xconf);

d527 3
@


1.31
log
@Only redistribute networks if the interface they depend on is actually
up and running. This makes redistribution of carp(4)-ed networks magically
work. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.30 2005/05/22 18:05:42 norby Exp $ */
a351 1
	int			maxdepth;
@


1.30
log
@Handle cost2 for AS-external, and prepare for handling flags in
ospfctl show rib detail.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.29 2005/05/12 19:10:12 norby Exp $ */
d521 2
@


1.29
log
@Add "show database asbr/external/network/router/self-originate/summary"
to ospfctl.

Show detailed information about the LSAs in the Link State Database.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.28 2005/05/12 08:55:39 claudio Exp $ */
d435 1
d438 1
@


1.28
log
@If activly connected to more than one area set B flag in the self-originated
router LSA. To do that correctly we need to track the number of active
neighbors for each area. If the routers ABR status changes all router LSA
need to be updated via orig_rtr_lsa_all().
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.27 2005/04/27 11:27:28 claudio Exp $ */
d102 6
@


1.27
log
@Sort struct msgbuf by size. From Alexander von Gernler via henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.26 2005/04/12 09:54:59 claudio Exp $ */
d166 1
d352 1
d457 2
@


1.26
log
@Support for self originated AS-external LSA.
With "redistribute (static|connected|default|none)" it is possible to
tell ospfd which external routes should be announced.
Connected routes will be announced only if there is no corresponding
interface configured, in that case the prefix is not external.
Adding and removing of announced prefixes are done automaticaly.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.25 2005/04/05 13:01:22 claudio Exp $ */
d72 1
a74 1
	TAILQ_HEAD(, buf)	 bufs;
@


1.25
log
@Use the dynamic buffer API for packet generation and sending.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.24 2005/03/31 19:32:10 norby Exp $ */
d39 3
d56 4
d119 2
d334 4
a341 4
	int			maxdepth;
	LIST_HEAD(, area)	area_list;
	LIST_HEAD(, vertex)	cand_list;
	struct lsa_tree		lsa_tree;
d345 1
d348 1
@


1.24
log
@Add support for crypt authentication (MD5).

ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.23 2005/03/29 17:26:35 norby Exp $ */
d40 1
@


1.23
log
@The RFC never mentions anything about transfer, this should be transmit.

From Jason Ackley (thanks).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.22 2005/03/26 13:35:16 claudio Exp $ */
d27 1
d262 6
d278 1
d295 1
d307 1
@


1.22
log
@Implement the IMSG_CTL_IFINFO bits correctly. This is needed for
"ospfctl show fib interface".
OK henning@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.21 2005/03/26 11:06:49 claudio Exp $ */
d155 1
a155 1
	u_int16_t		 transfer_delay;
d292 1
a292 1
	u_int16_t		 transfer_delay;
d370 1
a370 1
	u_int16_t		 transfer_delay;
@


1.21
log
@kroute.c cleanup, simplify code and remove unused functions.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.20 2005/03/23 20:15:50 claudio Exp $ */
d485 1
a485 1
void		 kr_ifinfo(char *);
@


1.20
log
@prefixlen2mask() should return a network byte order result as it does imply
by using an in_addr_t as return type. It simplyfies also the usage as in most
cases the mask is used with a struct in_addr address which is also network
byte order. Add prototypes of prefixlen2mask() and mask2prefixlen() to
ospfd.h as it is used or will be used at different places.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.19 2005/03/23 11:30:21 henning Exp $ */
d490 4
@


1.19
log
@grow receive buffer on the routing socket, from bgpd
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.18 2005/03/23 10:46:26 henning Exp $ */
d487 3
@


1.18
log
@ssize_t -> size_t, from ntpd, there from Alexander von Gernler
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.17 2005/03/22 22:13:48 norby Exp $ */
d40 1
@


1.17
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.16 2005/03/15 22:03:56 claudio Exp $ */
d73 1
a73 1
	ssize_t			 wpos;
@


1.16
log
@Add control messages for the show fib commands.
OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.15 2005/03/14 18:21:29 norby Exp $ */
a29 1
#include <stdbool.h>
d159 2
a160 3

	bool			 transit;
	bool			 stub;
d299 1
a299 2

	bool			 passive;
d377 1
a377 1
	bool			 passive;
@


1.15
log
@Add "show summary" to ospfctl.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.14 2005/03/12 11:03:05 norby Exp $ */
d100 3
@


1.14
log
@Add "show rib" and "show rib detail" to ospfctl.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.13 2005/03/08 20:12:18 norby Exp $ */
d95 2
d144 1
a145 1
	struct lsa_tree		 lsa_tree;
d150 1
a150 1

d327 1
d407 17
@


1.13
log
@Remove no longer valid route entries.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.12 2005/03/07 10:28:14 claudio Exp $ */
d94 1
d244 6
d393 11
@


1.12
log
@Track interface state (up/down) and media status. Simplify the code a bit
by using the kif/kroute info while allocating interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.11 2005/02/27 08:21:15 norby Exp $ */
d226 10
d246 2
a247 2
	"Type 1 external",
	"Type 2 external"
@


1.11
log
@SPF and route table calculation.

Calculate Shortest Path Tree for each area known in the link state
database.

The Shortest Path Tree is used as input for route table calculation.
Route tabled is calculated and the result is inserted into the kernel
route table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.10 2005/02/24 16:28:43 claudio Exp $ */
a312 1
	u_int8_t	prefixlen;
d316 1
d320 4
a324 2
	int			 flags;
	char			 ifname[IF_NAMESIZE];
a326 1
	u_long			 baudrate;
d425 13
a437 11
int	kr_init(int);
int	kr_change(struct kroute *);
int	kr_delete(struct kroute *);
void	kr_shutdown(void);
void	kr_fib_couple(void);
void	kr_fib_decouple(void);
void	kr_dispatch_msg(int, short, void *);
int	kr_nexthop_add(struct in_addr);
void	kr_nexthop_delete(struct in_addr);
void	kr_show_route(struct imsg *);
void	kr_ifinfo(char *);
@


1.10
log
@Remove the kroute nexthop specific code as there is no need for this in
ospfd. While there clean up some other no longer needed stuff.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.9 2005/02/16 15:23:33 norby Exp $ */
d32 3
a34 3
#define CONF_FILE			"/etc/ospfd.conf"
#define	OSPFD_SOCKET			"/var/run/ospfd.sock"
#define OSPFD_USER			"_ospfd"
d98 2
d139 2
a140 2
	LIST_ENTRY(area)		 entry;
	struct in_addr			 id;
d142 5
a146 12
	struct lsa_tree			 lsa_tree;
	LIST_HEAD(, iface)		 iface_list;
	LIST_HEAD(, rde_nbr)		 nbr_list;
/*	list				 addr_range_list; */
	u_int32_t			 stub_default_cost;

	u_int32_t	dead_interval;
	u_int16_t	transfer_delay;
	u_int16_t	hello_interval;
	u_int16_t	rxmt_interval;
	u_int16_t	metric;
	u_int8_t	priority;
d148 9
a156 2
	bool				 transit;
	bool				 stub;
d218 22
d292 1
d300 1
a300 1

d302 3
@


1.9
log
@Support point to point links.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.8 2005/02/10 14:05:48 claudio Exp $ */
a46 1
#define	F_NEXTHOP		0x0008
a49 2
#define	F_REJECT		0x0080
#define	F_BLACKHOLE		0x0100
a97 3
	IMSG_NEXTHOP_ADD,
	IMSG_NEXTHOP_REMOVE,
	IMSG_NEXTHOP_UPDATE,
a290 8
struct kroute_nexthop {
	struct in_addr		nexthop;
	u_int8_t		valid;
	u_int8_t		connected;
	struct in_addr		gateway;
	struct kroute		kr;
};

a406 4
void	send_nexthop_update(struct kroute_nexthop *);

/* ospfd.c */
void	 send_nexthop_update(struct kroute_nexthop *);
@


1.8
log
@Work around a timing issue in the db exchange phase. The DB description
packets comming from the net are looped through the RDE and may get
delayed because of this. The result is that the neighbor FSM ends in
state FULL instead of LOADING and so the LSDB is not correctly
synchronized. Issue found by norby@@ OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.7 2005/02/09 17:41:16 claudio Exp $ */
d236 1
@


1.7
log
@Fix interface fsm by inserting dummy events and actions as placeholder
for 0. Action 0 was IF_ACT_STRT and that's why if_act_start() got called
multiple times. The inappropriate hack from the previous commit is no
longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.6 2005/02/09 14:39:56 claudio Exp $ */
d109 1
@


1.6
log
@Add buf_seek() as buf_reserve() fails if a buf_add()/buf_reserve() is
called afterwards as it may realloc() the buffer and so the returned
pointer is bogus. Needed by the upcomming originate LSA code.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.5 2005/02/07 05:51:00 david Exp $ */
d176 1
d187 1
d199 1
@


1.5
log
@spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.4 2005/02/02 19:15:07 henning Exp $ */
d370 1
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.3 2005/02/01 21:25:18 claudio Exp $ */
d395 1
a395 1
void	 imsg_event_add(struct imsgbuf *); /* needs to be provided externaly */
@


1.3
log
@Introduce dynmaic buffers. Dynamic buffers are realloced() until max is
hit. This makes it possible to alloc a buffer based on the max packet size
and filling it up slowly till the packet is finished or *sigh* an overflow
is detected. While doing that switch most sizes from ssize_t to the unsigned
size_t as this makes more sense. The ssize_t -> size_t change is mostly from
henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d150 1
a150 1
	
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d58 4
a61 3
	ssize_t			 size;
	ssize_t			 wpos;
	ssize_t			 rpos;
d366 4
a369 3
struct buf	*buf_open(ssize_t);
int		 buf_add(struct buf *, void *, ssize_t);
void		*buf_reserve(struct buf *, ssize_t);
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2004 Esben Norby <esben.norby@@ericsson.com>
@

