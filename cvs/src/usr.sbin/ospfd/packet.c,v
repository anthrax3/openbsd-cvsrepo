head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.10
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.8
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.4
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.20
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.18
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.14
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.12
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.10
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.22.0.6
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.31
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.30;
commitid	2uw1UTO4k6erpWzK;

1.30
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2010.02.16.18.04.39;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.05.00.53.33;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2009.01.31.08.55.00;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.12.09.54.47;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.24.16.11.04;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2008.03.15.16.25.00;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2008.03.13.01.49.53;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.17.08.55.31;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.27.14.37.38;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.09.13.31.57;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.19.18.52.06;	author norby;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.12.18.18.24;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.26.01.28.41;	author stevesk;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.19.22.00.37;	author stevesk;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.19.13.07.58;	author stevesk;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.18.09.32.16;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.12.09.09.36;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.17.20.03.35;	author msf;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.11.16.28.07;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.27.07.24.51;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.26.19.54.49;	author norby;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.14.20.02.10;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.05.13.01.22;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.31.19.32.10;	author norby;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.16.15.23.33;	author norby;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.07.05.51.00;	author david;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.04.07.40.54;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@/*	$OpenBSD: packet.c,v 1.30 2010/05/26 13:56:08 nicm Exp $ */

/*
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <net/if_dl.h>

#include <errno.h>
#include <event.h>
#include <stdlib.h>
#include <string.h>

#include "ospfd.h"
#include "ospf.h"
#include "log.h"
#include "ospfe.h"

int		 ip_hdr_sanity_check(const struct ip *, u_int16_t);
int		 ospf_hdr_sanity_check(const struct ip *,
		    struct ospf_hdr *, u_int16_t, const struct iface *);
struct iface	*find_iface(struct ospfd_conf *, unsigned int, struct in_addr);

int
gen_ospf_hdr(struct ibuf *buf, struct iface *iface, u_int8_t type)
{
	struct ospf_hdr	ospf_hdr;

	bzero(&ospf_hdr, sizeof(ospf_hdr));
	ospf_hdr.version = OSPF_VERSION;
	ospf_hdr.type = type;
	ospf_hdr.rtr_id = ospfe_router_id();
	if (iface->type != IF_TYPE_VIRTUALLINK)
		ospf_hdr.area_id = iface->area->id.s_addr;
	ospf_hdr.auth_type = htons(iface->auth_type);

	return (ibuf_add(buf, &ospf_hdr, sizeof(ospf_hdr)));
}

/* send and receive packets */
int
send_packet(struct iface *iface, struct ibuf *buf, struct sockaddr_in *dst)
{
	struct msghdr		 msg;
	struct iovec		 iov[2];
	struct ip		 ip_hdr;

	/* setup IP hdr */
	bzero(&ip_hdr, sizeof(ip_hdr));
	ip_hdr.ip_v = IPVERSION;
	ip_hdr.ip_hl = sizeof(ip_hdr) >> 2;
	ip_hdr.ip_tos = IPTOS_PREC_INTERNETCONTROL;
	ip_hdr.ip_len = htons(ibuf_size(buf) + sizeof(ip_hdr));
	ip_hdr.ip_id = 0;  /* 0 means kernel set appropriate value */
	ip_hdr.ip_off = 0;
	ip_hdr.ip_ttl = iface->type != IF_TYPE_VIRTUALLINK ?
	    IP_DEFAULT_MULTICAST_TTL : MAXTTL;
	ip_hdr.ip_p = IPPROTO_OSPF;
	ip_hdr.ip_sum = 0;
	ip_hdr.ip_src = iface->addr;
	ip_hdr.ip_dst = dst->sin_addr;

	/* setup buffer */
	bzero(&msg, sizeof(msg));
	iov[0].iov_base = &ip_hdr;
	iov[0].iov_len = sizeof(ip_hdr);
	iov[1].iov_base = buf->buf;
	iov[1].iov_len = ibuf_size(buf);
	msg.msg_name = dst;
	msg.msg_namelen = sizeof(*dst);
	msg.msg_iov = iov;
	msg.msg_iovlen = 2;

	/* set outgoing interface for multicast traffic */
	if (IN_MULTICAST(ntohl(dst->sin_addr.s_addr)))
		if (if_set_mcast(iface) == -1)
			return (-1);

	if (sendmsg(iface->fd, &msg, 0) == -1) {
		log_warn("send_packet: error sending packet on interface %s",
		    iface->name);
		return (-1);
	}

	return (0);
}

void
recv_packet(int fd, short event, void *bula)
{
	union {
		struct cmsghdr hdr;
		char	buf[CMSG_SPACE(sizeof(struct sockaddr_dl))];
	} cmsgbuf;
	struct msghdr		 msg;
	struct iovec		 iov;
	struct ip		 ip_hdr;
	struct in_addr		 addr;
	struct ospfd_conf	*xconf = bula;
	struct ospf_hdr		*ospf_hdr;
	struct iface		*iface;
	struct nbr		*nbr = NULL;
	char			*buf;
	struct cmsghdr		*cmsg;
	ssize_t			 r;
	u_int16_t		 len;
	int			 l;
	unsigned int		 ifindex = 0;

	if (event != EV_READ)
		return;

	/* setup buffer */
	bzero(&msg, sizeof(msg));
	iov.iov_base = buf = pkt_ptr;
	iov.iov_len = READ_BUF_SIZE;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);

	if ((r = recvmsg(fd, &msg, 0)) == -1) {
		if (errno != EAGAIN && errno != EINTR)
			log_debug("recv_packet: read error: %s",
			    strerror(errno));
		return;
	}
	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
	    cmsg = CMSG_NXTHDR(&msg, cmsg)) {
		if (cmsg->cmsg_level == IPPROTO_IP &&
		    cmsg->cmsg_type == IP_RECVIF) {
			ifindex = ((struct sockaddr_dl *)
			    CMSG_DATA(cmsg))->sdl_index;
			break;
		}
	}

	len = (u_int16_t)r;

	/* IP header sanity checks */
	if (len < sizeof(ip_hdr)) {
		log_warnx("recv_packet: bad packet size");
		return;
	}
	memcpy(&ip_hdr, buf, sizeof(ip_hdr));
	if ((l = ip_hdr_sanity_check(&ip_hdr, len)) == -1)
		return;
	buf += l;
	len -= l;

	/* find a matching interface */
	if ((iface = find_iface(xconf, ifindex, ip_hdr.ip_src)) == NULL) {
		/* XXX add a counter here */
		return;
	}

	/*
	 * Packet needs to be sent to AllSPFRouters or AllDRouters
	 * or to the address of the interface itself.
	 * AllDRouters is only valid for DR and BDR but this is checked later.
	 */
	inet_aton(AllSPFRouters, &addr);
	if (ip_hdr.ip_dst.s_addr != addr.s_addr) {
		inet_aton(AllDRouters, &addr);
		if (ip_hdr.ip_dst.s_addr != addr.s_addr) {
			if (ip_hdr.ip_dst.s_addr != iface->addr.s_addr) {
				log_debug("recv_packet: packet sent to wrong "
				    "address %s, interface %s",
				    inet_ntoa(ip_hdr.ip_dst), iface->name);
				return;
			}
		}
	}

	/* OSPF header sanity checks */
	if (len < sizeof(*ospf_hdr)) {
		log_debug("recv_packet: bad packet size");
		return;
	}
	ospf_hdr = (struct ospf_hdr *)buf;

	if ((l = ospf_hdr_sanity_check(&ip_hdr, ospf_hdr, len, iface)) == -1)
		return;

	nbr = nbr_find_id(iface, ospf_hdr->rtr_id);
	if (ospf_hdr->type != PACKET_TYPE_HELLO && nbr == NULL) {
		log_debug("recv_packet: unknown neighbor ID");
		return;
	}

	if (auth_validate(buf, len, iface, nbr)) {
		log_warnx("recv_packet: authentication error, "
		    "interface %s", iface->name);
		return;
	}

	buf += sizeof(*ospf_hdr);
	len = l - sizeof(*ospf_hdr);

	/* switch OSPF packet type */
	switch (ospf_hdr->type) {
	case PACKET_TYPE_HELLO:
		inet_aton(AllDRouters, &addr);
		if (ip_hdr.ip_dst.s_addr == addr.s_addr) {
			log_debug("recv_packet: invalid destination IP "
			     "address");
			break;
		}

		recv_hello(iface, ip_hdr.ip_src, ospf_hdr->rtr_id, buf, len);
		break;
	case PACKET_TYPE_DD:
		recv_db_description(nbr, buf, len);
		break;
	case PACKET_TYPE_LS_REQUEST:
		recv_ls_req(nbr, buf, len);
		break;
	case PACKET_TYPE_LS_UPDATE:
		recv_ls_update(nbr, buf, len);
		break;
	case PACKET_TYPE_LS_ACK:
		recv_ls_ack(nbr, buf, len);
		break;
	default:
		log_debug("recv_packet: unknown OSPF packet type, interface %s",
		    iface->name);
	}
}

int
ip_hdr_sanity_check(const struct ip *ip_hdr, u_int16_t len)
{
	if (ntohs(ip_hdr->ip_len) != len) {
		log_debug("recv_packet: invalid IP packet length %u",
		    ntohs(ip_hdr->ip_len));
		return (-1);
	}

	if (ip_hdr->ip_p != IPPROTO_OSPF)
		/* this is enforced by the socket itself */
		fatalx("recv_packet: invalid IP proto");

	return (ip_hdr->ip_hl << 2);
}

int
ospf_hdr_sanity_check(const struct ip *ip_hdr, struct ospf_hdr *ospf_hdr,
    u_int16_t len, const struct iface *iface)
{
	struct in_addr		 addr;

	if (ospf_hdr->version != OSPF_VERSION) {
		log_debug("recv_packet: invalid OSPF version %d",
		    ospf_hdr->version);
		return (-1);
	}

	if (ntohs(ospf_hdr->len) > len ||
	    len <= sizeof(struct ospf_hdr)) {
		log_debug("recv_packet: invalid OSPF packet length %d",
		    ntohs(ospf_hdr->len));
		return (-1);
	}

	if (iface->type != IF_TYPE_VIRTUALLINK) {
		if (ospf_hdr->area_id != iface->area->id.s_addr) {
			addr.s_addr = ospf_hdr->area_id;
			log_debug("recv_packet: invalid area ID %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
			return (-1);
		}
	} else {
		if (ospf_hdr->area_id != 0) {
			addr.s_addr = ospf_hdr->area_id;
			log_debug("recv_packet: invalid area ID %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
			return (-1);
		}
	}

	if (iface->type == IF_TYPE_BROADCAST || iface->type == IF_TYPE_NBMA) {
		if (inet_aton(AllDRouters, &addr) == 0)
			fatalx("recv_packet: inet_aton");
		if (ip_hdr->ip_dst.s_addr == addr.s_addr &&
		    (iface->state & IF_STA_DRORBDR) == 0) {
			log_debug("recv_packet: invalid destination IP in "
			    "state %s, interface %s",
			    if_state_name(iface->state), iface->name);
			return (-1);
		}
	}

	return (ntohs(ospf_hdr->len));
}

struct iface *
find_iface(struct ospfd_conf *xconf, unsigned int ifindex, struct in_addr src)
{
	struct area	*area = NULL;
	struct iface	*iface = NULL;

	/* returned interface needs to be active */
	LIST_FOREACH(area, &xconf->area_list, entry) {
		LIST_FOREACH(iface, &area->iface_list, entry) {
			switch (iface->type) {
			case IF_TYPE_VIRTUALLINK:
				if ((src.s_addr == iface->dst.s_addr) &&
				    !iface->passive)
					return (iface);
				break;
			case IF_TYPE_POINTOPOINT:
				if (ifindex == iface->ifindex &&
				    !iface->passive)
					return (iface);
				break;
			default:
				if (ifindex == iface->ifindex &&
				    (iface->addr.s_addr & iface->mask.s_addr) ==
				    (src.s_addr & iface->mask.s_addr) &&
				    !iface->passive)
					return (iface);
				break;
			}
		}
	}

	return (NULL);
}
@


1.30
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.29 2010/02/16 18:04:39 claudio Exp $ */
a23 1
#include <netinet/in_systm.h>
@


1.29
log
@Don't log the same thing twice. From a much bigger diff.
OK dlg@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.28 2009/06/05 00:53:33 pyr Exp $ */
d45 1
a45 1
gen_ospf_hdr(struct buf *buf, struct iface *iface, u_int8_t type)
d57 1
a57 1
	return (buf_add(buf, &ospf_hdr, sizeof(ospf_hdr)));
d62 1
a62 1
send_packet(struct iface *iface, struct buf *buf, struct sockaddr_in *dst)
d73 1
a73 1
	ip_hdr.ip_len = htons(buf_size(buf) + sizeof(ip_hdr));
d88 1
a88 1
	iov[1].iov_len = buf_size(buf);
@


1.28
log
@don't mess with buffer internals,
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.27 2009/01/31 08:55:00 claudio Exp $ */
d96 1
a96 3
		if (if_set_mcast(iface) == -1) {
			log_warn("send_packet: error setting multicast "
			    "interface, %s", iface->name);
a97 1
		}
@


1.27
log
@Pass the buffer to send_packet() instead of spliting it up. This removes
some direct access to struct buf internals in the rest of ospfe.
Based on a larger buffer cleanup diff that was OK norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.26 2008/09/12 09:54:47 claudio Exp $ */
d73 1
a73 1
	ip_hdr.ip_len = htons(buf->wpos + sizeof(ip_hdr));
d88 1
a88 1
	iov[1].iov_len = buf->wpos;
@


1.26
log
@Don't be to strict in find_iface() about what we accept on point-to-point
links. If a packet arrived on a point-to-point interface we should accept it
even if the source address of the packet is different to our iface destination
address. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.25 2008/03/24 16:11:04 deraadt Exp $ */
d62 1
a62 1
send_packet(struct iface *iface, void *pkt, size_t len, struct sockaddr_in *dst)
d73 1
a73 1
	ip_hdr.ip_len = htons(len + sizeof(ip_hdr));
d87 2
a88 2
	iov[1].iov_base = pkt;
	iov[1].iov_len = len;
@


1.25
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.24 2008/03/15 16:25:00 deraadt Exp $ */
a335 1
				    iface->dst.s_addr == src.s_addr &&
@


1.24
log
@Repair more msg_controllen dealing with structures or arrays of
descriptors; ok hshoexer, also looked at by kettenis and henning
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.23 2008/03/13 01:49:53 deraadt Exp $ */
d143 1
a143 1
	msg.msg_controllen = CMSG_LEN(sizeof(struct sockaddr_dl));
@


1.23
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.22 2006/11/17 08:55:31 claudio Exp $ */
d143 1
a143 1
	msg.msg_controllen = sizeof(cmsgbuf.buf);
@


1.22
log
@Support for multiple networks on one interface. Until now only the main
address of a interface could be used. Now it is possible to specify a
interface more than once if multiple networks are configured. An alternative
network can be specified via e.g. interface em0:10.0.5.1. The old interface
syntax without the IP still works and uses the main/first configured IP
address.
ospfd now needs to include the IP header on outgoing messages as it is not
possible to specifiy the source address in sendto(2). Additionally all
multicast joins and leaves have to be tracked.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.21 2006/09/27 14:37:38 claudio Exp $ */
d114 4
a117 1
	char			 cbuf[CMSG_SPACE(sizeof(struct sockaddr_dl))];
d142 2
a143 2
	msg.msg_control = cbuf;
	msg.msg_controllen = sizeof(cbuf);
@


1.21
log
@Use IP_RECVIF to get the incomming interface of OSPF packets. Now we use
the source address and the interface index to find the corresponding
struct interface which is less error prone. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.20 2006/03/09 13:31:57 claudio Exp $ */
d64 30
d102 1
a102 2
	if (sendto(iface->fd, pkt, len, 0,
	    (struct sockaddr *)dst, sizeof(*dst)) == -1 ) {
a136 2
	msg.msg_name = NULL;
	msg.msg_namelen = 0;
d173 1
a173 1
		log_debug("recv_packet: cannot find valid interface");
@


1.20
log
@Switch send_packet from char * to void * and from int to size_t. The function
is now similar to sendto et al.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.19 2006/02/19 18:52:06 norby Exp $ */
d21 1
d27 1
d42 1
a42 1
struct iface	*find_iface(struct ospfd_conf *, struct in_addr);
d85 5
a90 1
	struct ip		 ip_hdr;
a93 1
	struct in_addr		 addr;
d95 1
d99 1
d105 9
a113 1
	buf = pkt_ptr;
d115 1
a115 1
	if ((r = recvfrom(fd, buf, READ_BUF_SIZE, 0, NULL, NULL)) == -1) {
d117 2
a118 1
			log_debug("recv_packet: error receiving packet");
d121 9
d145 1
a145 1
	if ((iface = find_iface(xconf, ip_hdr.ip_src)) == NULL) {
d170 1
a170 1
		log_warnx("recv_packet: bad packet size");
d290 1
a290 1
find_iface(struct ospfd_conf *xconf, struct in_addr src)
d298 19
a316 11
			if (iface->fd > 0 &&
			    (iface->type == IF_TYPE_POINTOPOINT) &&
			    (iface->dst.s_addr == src.s_addr) &&
			    !iface->passive)
				return (iface);

			if (iface->fd > 0 && (iface->addr.s_addr &
			    iface->mask.s_addr) == (src.s_addr &
			    iface->mask.s_addr) && !iface->passive &&
			    iface->type != IF_TYPE_VIRTUALLINK) {
				return (iface);
a319 7

	LIST_FOREACH(area, &xconf->area_list, entry)
		LIST_FOREACH(iface, &area->iface_list, entry)
			if ((iface->type == IF_TYPE_VIRTUALLINK) &&
			    (src.s_addr == iface->dst.s_addr)) {
				return (iface);
			}
@


1.19
log
@Do not allocate a new chunk of memory every time we receive a packet.
This should have been fixed ages ago since it really improves the
performance of ospfd.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.18 2005/11/12 18:18:24 deraadt Exp $ */
d60 1
a60 1
send_packet(struct iface *iface, char *pkt, int len, struct sockaddr_in *dst)
@


1.18
log
@spacing mostly
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.17 2005/10/26 01:28:41 stevesk Exp $ */
d89 1
a89 1
	char			*buf, *ptr;
d97 2
a98 7
	/*
	 * XXX I don't like to allocate a buffer for each packet received
	 * and freeing that buffer at the end of the function. It would be
	 * enough to allocate the buffer on startup.
	 */
	if ((ptr = buf = calloc(1, READ_BUF_SIZE)) == NULL)
		fatal("recv_packet");
d103 1
a103 1
		goto done;
d111 1
a111 1
		goto done;
d115 1
a115 1
		goto done;
d122 1
a122 1
		goto done;
d138 1
a138 1
				goto done;
d146 1
a146 1
		goto done;
d151 1
a151 1
		goto done;
d156 1
a156 1
		goto done;
d162 1
a162 1
		goto done;
a195 2
done:
	free(ptr);
@


1.17
log
@some unneeded #includes; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.16 2005/10/19 22:00:37 stevesk Exp $ */
a202 1
	return;
@


1.16
log
@small cleanups while reading; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.15 2005/10/19 13:07:58 stevesk Exp $ */
a20 1
#include <sys/time.h>
a28 1
#include <md5.h>
a301 1

@


1.15
log
@use string.h; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.14 2005/10/18 09:32:16 claudio Exp $ */
d250 1
a250 1
	 } else {
@


1.14
log
@Correct log_debug(). Found while scrolling through that file.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.13 2005/10/12 09:09:36 claudio Exp $ */
d32 1
a32 1
#include <strings.h>
@


1.13
log
@Minor cleanup. Use iface->state & IF_STA_DRORBDR as used in other places
instead of iface->state != (IF_STA_DR | IF_STA_BACKUP).  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.12 2005/09/17 20:03:35 msf Exp $ */
d252 1
d254 1
a254 1
			    "interface %s",iface->name);
@


1.12
log
@- add get_rtr_id() based on bgpd's get_bgpid()
- remove rtr_id from struct iface we don't need to keep a copy of this value
  per interface
- replace all references to iface->rtr_id.s_addr with calls to ospfe_rtr_id()

ok claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.11 2005/08/11 16:28:07 henning Exp $ */
d261 2
a262 2
		if ((ip_hdr->ip_dst.s_addr == addr.s_addr) &&
		    (iface->state != (IF_STA_DR | IF_STA_BACKUP))) {
@


1.11
log
@EINTR, and a little KNF in packet.c
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.10 2005/05/27 07:24:51 norby Exp $ */
d52 1
a52 1
	ospf_hdr.rtr_id = iface->rtr_id.s_addr;
@


1.10
log
@Virtual link support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.9 2005/05/26 19:54:49 norby Exp $ */
d108 1
a108 1
		if (errno != EAGAIN) {
a109 1
		}
@


1.9
log
@Simplify and cleanup passive interface handling.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.8 2005/04/14 20:02:10 cloder Exp $ */
d53 2
a54 1
	ospf_hdr.area_id = iface->area->id.s_addr;
d244 13
a256 6
	if (ospf_hdr->area_id != iface->area->id.s_addr) {
		/* TODO backbone area is allowed for virtual links */
		addr.s_addr = ospf_hdr->area_id;
		log_debug("recv_packet: invalid area ID %s, interface %s",
		    inet_ntoa(addr), iface->name);
		return (-1);
d291 2
a292 1
			    iface->mask.s_addr) && !iface->passive)
d294 1
d297 8
@


1.8
log
@Some format string cleanup. OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.7 2005/04/05 13:01:22 claudio Exp $ */
a62 6
	if (iface->passive) {
		log_warnx("send_packet: cannot send packet on passive "
		    "interface %s", iface->name);
		return (-1);
	}

@


1.7
log
@Use the dynamic buffer API for packet generation and sending.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.6 2005/03/31 19:32:10 norby Exp $ */
d218 1
a218 1
		log_debug("recv_packet: invalid IP packet length %s",
@


1.6
log
@Add support for crypt authentication (MD5).

ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.5 2005/02/16 15:23:33 norby Exp $ */
d44 2
a45 2
void
gen_ospf_hdr(void *buf, struct iface *iface, u_int8_t type)
d47 8
a54 1
	struct ospf_hdr	*ospf_hdr = buf;
d56 1
a56 7
	ospf_hdr->version = OSPF_VERSION;
	ospf_hdr->type = type;
	ospf_hdr->len = 0;			/* updated later */
	ospf_hdr->rtr_id = iface->rtr_id.s_addr;
	ospf_hdr->area_id = iface->area->id.s_addr;
	ospf_hdr->chksum = 0;			/* updated later */
	ospf_hdr->auth_type = htons(iface->auth_type);
a67 5

	/* XXX I don't like this */
	/* MD5 digest is _not_ part of the OSPF packet len */
	if (iface->auth_type == AUTH_CRYPT)
		len += MD5_DIGEST_LENGTH;
@


1.5
log
@Support point to point links.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.4 2005/02/07 05:51:00 david Exp $ */
d30 1
d68 5
d170 12
a184 7
	if (ospf_hdr->type != PACKET_TYPE_HELLO)
		/* find neighbor */
		if ((nbr = nbr_find_id(iface, ospf_hdr->rtr_id)) == NULL) {
			log_debug("recv_packet: unknown neighbor ID");
			goto done;
		}

a270 6
	}

	if (auth_validate(ospf_hdr, iface)) {
		log_warnx("recv_packet: authentication error, interface %s",
		    iface->name);
		return (-1);
@


1.4
log
@spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.3 2005/02/04 07:40:54 claudio Exp $ */
d280 6
@


1.3
log
@Use log_warn() insteade of log_warnx() after sendto() and if_set_mcast()
errors as errno was set by the call.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d243 1
a243 1
		/* TODO backbone area is allowed for virtual links */ 
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d70 1
a70 1
			log_debug("send_packet: error setting multicast "
d77 1
a77 1
		log_warnx("send_packet: error sending packet on interface %s",
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2004, 2005 Esben Norby <esben.norby@@ericsson.com>
@

