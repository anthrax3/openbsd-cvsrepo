head	1.47;
access;
symbols
	OPENBSD_6_1:1.47.0.8
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.47.0.4
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.46.0.14
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.6
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.46.0.10
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.8
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.4
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.43.0.6
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.41.0.4
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.2
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.37.0.10
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.6
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.4
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12;
locks; strict;
comment	@ * @;


1.47
date	2015.11.22.13.09.10;	author claudio;	state Exp;
branches;
next	1.46;
commitid	pxM0r18iZwdhX0Ks;

1.46
date	2013.01.17.10.07.56;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.17.10.02.04;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.17.09.58.15;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2011.03.24.08.35.59;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.07.22.32.34;	author sthen;	state Exp;
branches;
next	1.40;

1.40
date	2010.02.16.18.13.52;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.30.14.39.07;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.30.14.37.11;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2008.02.11.12.37.37;	author norby;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.11.08.21.29;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.13.17.47.52;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.24.14.08.28;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.06.12.36.23;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.13.09.36.06;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.09.15.43.21;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.19.21.48.56;	author norby;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.19.19.23.17;	author norby;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.19.18.55.47;	author norby;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.09.15.23.08;	author norby;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.15.20.29.06;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.19.21.46.21;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.29.15.14.57;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.13.08.32.29;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.27.08.44.43;	author norby;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.27.02.45.15;	author norby;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.26.22.09.10;	author norby;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.26.20.42.10;	author norby;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.26.20.21.09;	author norby;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.12.08.55.39;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.01.17.35.27;	author david;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.12.09.54.59;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.31.19.32.10;	author norby;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.17.21.17.12;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.10.14.05.48;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.10.10.16.02;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.09.20.40.23;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.09.16.14.23;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.09.16.08.06;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.09.15.57.57;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.09.12.53.17;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.01.21.15.40;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Improve ABR support especially for self-originated stub networks.
This seems to solve the last issues people reported when using ospfd
in multiple areas. OK sthen@@ prodding by deraadt@@
@
text
@/*	$OpenBSD: neighbor.c,v 1.46 2013/01/17 10:07:56 markus Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>

#include <ctype.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <event.h>

#include "ospfd.h"
#include "ospf.h"
#include "ospfe.h"
#include "log.h"
#include "rde.h"

int	 nbr_adj_ok(struct nbr *);

LIST_HEAD(nbr_head, nbr);

struct nbr_table {
	struct nbr_head		*hashtbl;
	u_int32_t		 hashmask;
} nbrtable;

#define NBR_HASH(x)		\
	&nbrtable.hashtbl[(x) & nbrtable.hashmask]

u_int32_t	peercnt = NBR_CNTSTART;

struct {
	int		state;
	enum nbr_event	event;
	enum nbr_action	action;
	int		new_state; /* 0 means action decides or unchanged */
} nbr_fsm_tbl[] = {
    /* current state	event that happened	action to take		resulting state */
    {NBR_STA_ACTIVE,	NBR_EVT_HELLO_RCVD,	NBR_ACT_RST_ITIMER,	0},
    {NBR_STA_BIDIR,	NBR_EVT_2_WAY_RCVD,	NBR_ACT_NOTHING,	0},
    {NBR_STA_INIT,	NBR_EVT_1_WAY_RCVD,	NBR_ACT_NOTHING,	0},
    {NBR_STA_DOWN,	NBR_EVT_HELLO_RCVD,	NBR_ACT_STRT_ITIMER,	NBR_STA_INIT},
    {NBR_STA_ATTEMPT,	NBR_EVT_HELLO_RCVD,	NBR_ACT_RST_ITIMER,	NBR_STA_INIT},
    {NBR_STA_INIT,	NBR_EVT_2_WAY_RCVD,	NBR_ACT_EVAL,		0},
    {NBR_STA_XSTRT,	NBR_EVT_NEG_DONE,	NBR_ACT_SNAP,		0},
    {NBR_STA_SNAP,	NBR_EVT_SNAP_DONE,	NBR_ACT_SNAP_DONE,	NBR_STA_XCHNG},
    {NBR_STA_XCHNG,	NBR_EVT_XCHNG_DONE,	NBR_ACT_XCHNG_DONE,	0},
    {NBR_STA_LOAD,	NBR_EVT_LOAD_DONE,	NBR_ACT_NOTHING,	NBR_STA_FULL},
    {NBR_STA_2_WAY,	NBR_EVT_ADJ_OK,		NBR_ACT_EVAL,		0},
    {NBR_STA_ADJFORM,	NBR_EVT_ADJ_OK,		NBR_ACT_ADJ_OK,		0},
    {NBR_STA_PRELIM,	NBR_EVT_ADJ_OK,		NBR_ACT_HELLO_CHK,	0},
    {NBR_STA_ADJFORM,	NBR_EVT_ADJTMOUT,	NBR_ACT_RESTRT_DD,	0},
    {NBR_STA_FLOOD,	NBR_EVT_SEQ_NUM_MIS,	NBR_ACT_RESTRT_DD,	0},
    {NBR_STA_FLOOD,	NBR_EVT_BAD_LS_REQ,	NBR_ACT_RESTRT_DD,	0},
    {NBR_STA_ANY,	NBR_EVT_KILL_NBR,	NBR_ACT_DEL,		NBR_STA_DOWN},
    {NBR_STA_ANY,	NBR_EVT_LL_DOWN,	NBR_ACT_DEL,		NBR_STA_DOWN},
    {NBR_STA_ANY,	NBR_EVT_ITIMER,		NBR_ACT_DEL,		NBR_STA_DOWN},
    {NBR_STA_BIDIR,	NBR_EVT_1_WAY_RCVD,	NBR_ACT_CLR_LST,	NBR_STA_INIT},
    {-1,		NBR_EVT_NOTHING,	NBR_ACT_NOTHING,	0},
};

const char * const nbr_event_names[] = {
	"NOTHING",
	"HELLO_RECEIVED",
	"2_WAY_RECEIVED",
	"NEGOTIATION_DONE",
	"SNAPSHOT_DONE",
	"EXCHANGE_DONE",
	"BAD_LS_REQ",
	"LOADING_DONE",
	"ADJ_OK",
	"SEQ_NUM_MISMATCH",
	"1_WAY_RECEIVED",
	"KILL_NBR",
	"INACTIVITY_TIMER",
	"LL_DOWN",
	"ADJ_TIMEOUT"
};

const char * const nbr_action_names[] = {
	"NOTHING",
	"RESET_INACTIVITY_TIMER",
	"START_INACTIVITY_TIMER",
	"EVAL",
	"SNAPSHOT",
	"SNAPSHOT_DONE",
	"EXCHANGE_DONE",
	"ADJ_OK",
	"RESET_DD",
	"DELETE",
	"CLEAR_LISTS",
	"HELLO_CHK"
};

int
nbr_fsm(struct nbr *nbr, enum nbr_event event)
{
	struct timeval	now;
	int		old_state;
	int		new_state = 0;
	int		i, ret = 0;

	if (nbr == nbr->iface->self)
		return (0);

	old_state = nbr->state;
	for (i = 0; nbr_fsm_tbl[i].state != -1; i++)
		if ((nbr_fsm_tbl[i].state & old_state) &&
		    (nbr_fsm_tbl[i].event == event)) {
			new_state = nbr_fsm_tbl[i].new_state;
			break;
		}

	if (nbr_fsm_tbl[i].state == -1) {
		/* event outside of the defined fsm, ignore it. */
		log_warnx("nbr_fsm: neighbor ID %s, "
		    "event %s not expected in state %s",
		    inet_ntoa(nbr->id), nbr_event_names[event],
		    nbr_state_name(old_state));
		return (0);
	}

	switch (nbr_fsm_tbl[i].action) {
	case NBR_ACT_RST_ITIMER:
		ret = nbr_act_reset_itimer(nbr);
		break;
	case NBR_ACT_STRT_ITIMER:
		ret = nbr_act_start_itimer(nbr);
		break;
	case NBR_ACT_EVAL:
		ret = nbr_act_eval(nbr);
		break;
	case NBR_ACT_SNAP:
		ret = nbr_act_snapshot(nbr);
		break;
	case NBR_ACT_SNAP_DONE:
		/* start db exchange */
		start_db_tx_timer(nbr);
		break;
	case NBR_ACT_XCHNG_DONE:
		ret = nbr_act_exchange_done(nbr);
		break;
	case NBR_ACT_ADJ_OK:
		ret = nbr_act_adj_ok(nbr);
		break;
	case NBR_ACT_RESTRT_DD:
		ret = nbr_act_restart_dd(nbr);
		break;
	case NBR_ACT_DEL:
		ret = nbr_act_delete(nbr);
		break;
	case NBR_ACT_CLR_LST:
		ret = nbr_act_clear_lists(nbr);
		break;
	case NBR_ACT_HELLO_CHK:
		ret = nbr_act_hello_check(nbr);
		break;
	case NBR_ACT_NOTHING:
		/* do nothing */
		break;
	}

	if (ret) {
		log_warnx("nbr_fsm: error changing state for neighbor ID %s, "
		    "event %s, state %s", inet_ntoa(nbr->id),
		    nbr_event_names[event], nbr_state_name(old_state));
		return (-1);
	}

	if (new_state != 0)
		nbr->state = new_state;

	if (old_state != nbr->state) {
		nbr->stats.sta_chng++;
		/* state change inform RDE */
		ospfe_imsg_compose_rde(IMSG_NEIGHBOR_CHANGE,
		    nbr->peerid, 0, &nbr->state, sizeof(nbr->state));

		if (old_state & NBR_STA_FULL || nbr->state & NBR_STA_FULL) {
			/*
			 * neighbor changed from/to FULL
			 * originate new rtr and net LSA
			 */
			orig_rtr_lsa(nbr->iface->area);
			if (nbr->iface->state & IF_STA_DR)
				orig_net_lsa(nbr->iface);

			gettimeofday(&now, NULL);
			nbr->uptime = now.tv_sec;
		}

		/* bidirectional communication lost */
		if (old_state & ~NBR_STA_PRELIM && nbr->state & NBR_STA_PRELIM)
			if_fsm(nbr->iface, IF_EVT_NBR_CHNG);

		log_debug("nbr_fsm: event %s resulted in action %s and "
		    "changing state for neighbor ID %s from %s to %s",
		    nbr_event_names[event],
		    nbr_action_names[nbr_fsm_tbl[i].action],
		    inet_ntoa(nbr->id), nbr_state_name(old_state),
		    nbr_state_name(nbr->state));

		if (nbr->iface->type == IF_TYPE_VIRTUALLINK) {
			orig_rtr_lsa(nbr->iface->area);
		}
	}

	return (ret);
}

void
nbr_init(u_int32_t hashsize)
{
	struct nbr_head	*head;
	struct nbr	*nbr;
	u_int32_t        hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	nbrtable.hashtbl = calloc(hs, sizeof(struct nbr_head));
	if (nbrtable.hashtbl == NULL)
		fatal("nbr_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&nbrtable.hashtbl[i]);

	nbrtable.hashmask = hs - 1;

	/* allocate a dummy neighbor used for self originated AS ext routes */
	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
		fatal("nbr_init");

	nbr->id.s_addr = ospfe_router_id();
	nbr->state = NBR_STA_DOWN;
	nbr->peerid = NBR_IDSELF;
	head = NBR_HASH(nbr->peerid);
	LIST_INSERT_HEAD(head, nbr, hash);

	TAILQ_INIT(&nbr->ls_retrans_list);
	TAILQ_INIT(&nbr->db_sum_list);
	TAILQ_INIT(&nbr->ls_req_list);
}

struct nbr *
nbr_new(u_int32_t nbr_id, struct iface *iface, int self)
{
	struct nbr_head	*head;
	struct nbr	*nbr;
	struct rde_nbr	 rn;

	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
		fatal("nbr_new");

	nbr->state = NBR_STA_DOWN;
	nbr->dd_master = 1;
	nbr->dd_seq_num = arc4random();	/* RFC: some unique value */
	nbr->id.s_addr = nbr_id;

	/* get next unused peerid */
	while (nbr_find_peerid(++peercnt))
		;
	nbr->peerid = peercnt;
	head = NBR_HASH(nbr->peerid);
	LIST_INSERT_HEAD(head, nbr, hash);

	/* add to peer list */
	nbr->iface = iface;
	LIST_INSERT_HEAD(&iface->nbr_list, nbr, entry);

	TAILQ_INIT(&nbr->ls_retrans_list);
	TAILQ_INIT(&nbr->db_sum_list);
	TAILQ_INIT(&nbr->ls_req_list);

	nbr->ls_req = NULL;

	if (self) {
		nbr->state = NBR_STA_FULL;
		nbr->addr.s_addr = iface->addr.s_addr;
		nbr->priority = iface->priority;
	}

	/* set event structures */
	evtimer_set(&nbr->inactivity_timer, nbr_itimer, nbr);
	evtimer_set(&nbr->db_tx_timer, db_tx_timer, nbr);
	evtimer_set(&nbr->lsreq_tx_timer, ls_req_tx_timer, nbr);
	evtimer_set(&nbr->ls_retrans_timer, ls_retrans_timer, nbr);
	evtimer_set(&nbr->adj_timer, nbr_adj_timer, nbr);

	bzero(&rn, sizeof(rn));
	rn.id.s_addr = nbr->id.s_addr;
	rn.area_id.s_addr = nbr->iface->area->id.s_addr;
	rn.ifindex = nbr->iface->ifindex;
	rn.state = nbr->state;
	rn.self = self;
	ospfe_imsg_compose_rde(IMSG_NEIGHBOR_UP, nbr->peerid, 0, &rn,
	    sizeof(rn));

	return (nbr);
}

void
nbr_del(struct nbr *nbr)
{
	ospfe_imsg_compose_rde(IMSG_NEIGHBOR_DOWN, nbr->peerid, 0, NULL, 0);

	if (evtimer_pending(&nbr->inactivity_timer, NULL))
		evtimer_del(&nbr->inactivity_timer);
	if (evtimer_pending(&nbr->db_tx_timer, NULL))
		evtimer_del(&nbr->db_tx_timer);
	if (evtimer_pending(&nbr->lsreq_tx_timer, NULL))
		evtimer_del(&nbr->lsreq_tx_timer);
	if (evtimer_pending(&nbr->ls_retrans_timer, NULL))
		evtimer_del(&nbr->ls_retrans_timer);
	if (evtimer_pending(&nbr->adj_timer, NULL))
		evtimer_del(&nbr->adj_timer);

	/* clear lists */
	ls_retrans_list_clr(nbr);
	db_sum_list_clr(nbr);
	ls_req_list_clr(nbr);

	if (nbr->peerid != NBR_IDSELF)
		LIST_REMOVE(nbr, entry);
	LIST_REMOVE(nbr, hash);

	free(nbr);
}

struct nbr *
nbr_find_peerid(u_int32_t peerid)
{
	struct nbr_head	*head;
	struct nbr	*nbr;

	head = NBR_HASH(peerid);

	LIST_FOREACH(nbr, head, hash) {
		if (nbr->peerid == peerid)
			return (nbr);
	}

	return (NULL);
}

struct nbr *
nbr_find_id(struct iface *iface, u_int32_t rtr_id)
{
	struct nbr	*nbr = NULL;

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr->id.s_addr == rtr_id)
			return (nbr);
	}

	return (NULL);
}

/* timers */
/* ARGSUSED */
void
nbr_itimer(int fd, short event, void *arg)
{
	struct nbr *nbr = arg;

	if (nbr->state == NBR_STA_DOWN)
		nbr_del(nbr);
	else
		nbr_fsm(nbr, NBR_EVT_ITIMER);
}

void
nbr_start_itimer(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = nbr->iface->dead_interval;

	if (evtimer_add(&nbr->inactivity_timer, &tv) == -1)
		fatal("nbr_start_itimer");
}

void
nbr_stop_itimer(struct nbr *nbr)
{
	if (evtimer_del(&nbr->inactivity_timer) == -1)
		fatal("nbr_stop_itimer");
}

void
nbr_reset_itimer(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = nbr->iface->dead_interval;

	if (evtimer_add(&nbr->inactivity_timer, &tv) == -1)
		fatal("nbr_reset_itimer");
}

/* ARGSUSED */
void
nbr_adj_timer(int fd, short event, void *arg)
{
	struct nbr *nbr = arg;

	if (!(nbr->state & NBR_STA_ADJFORM))
		return;

	if (nbr->state & NBR_STA_ACTIVE && nbr->state != NBR_STA_FULL) {
		log_warnx("nbr_adj_timer: failed to form adjacency with %s "
		    "on interface %s", inet_ntoa(nbr->id), nbr->iface->name);
		nbr_fsm(nbr, NBR_EVT_ADJTMOUT);
	}
}

void
nbr_start_adj_timer(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = DEFAULT_ADJ_TMOUT;

	if (evtimer_add(&nbr->adj_timer, &tv) == -1)
		fatal("nbr_start_adj_timer");
}

/* actions */
int
nbr_act_reset_itimer(struct nbr *nbr)
{
	nbr_reset_itimer(nbr);

	return (0);
}

int
nbr_act_start_itimer(struct nbr *nbr)
{
	nbr_start_itimer(nbr);

	return (0);
}

int
nbr_adj_ok(struct nbr *nbr)
{
	struct iface	*iface = nbr->iface;

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_POINTOMULTIPOINT:
		/* always ok */
		break;
	case IF_TYPE_BROADCAST:
	case IF_TYPE_NBMA:
		/*
		 * if neighbor is dr, bdr or router self is dr or bdr
		 * start forming adjacency
		 */
		if (iface->dr == nbr || iface->bdr == nbr ||
		    iface->state & IF_STA_DRORBDR)
			break;
		return (0);
	default:
		fatalx("nbr_adj_ok: unknown interface type");
	}
	return (1);
}

int
nbr_act_eval(struct nbr *nbr)
{
	if (!nbr_adj_ok(nbr)) {
		nbr->state = NBR_STA_2_WAY;
		return (0);
	}

	nbr->state = NBR_STA_XSTRT;
	nbr->dd_master = 1;
	nbr->dd_seq_num++;	/* as per RFC */
	nbr->dd_pending = 0;
	/* initial db negotiation */
	start_db_tx_timer(nbr);

	nbr_start_adj_timer(nbr);

	return (0);
}

int
nbr_act_snapshot(struct nbr *nbr)
{
	stop_db_tx_timer(nbr);

	/* we need to wait for the old snapshot to finish */
	if (nbr->dd_snapshot) {
		log_debug("nbr_act_snapshot: giving up, old snapshot running "
		    "for neigbor ID %s", inet_ntoa(nbr->id));
		return (nbr_act_restart_dd(nbr));
	}
	ospfe_imsg_compose_rde(IMSG_NEIGHBOR_CAPA, nbr->peerid, 0,
	    &nbr->capa_options, sizeof(nbr->capa_options));
	ospfe_imsg_compose_rde(IMSG_DB_SNAPSHOT, nbr->peerid, 0, NULL, 0);

	nbr->dd_snapshot = 1;	/* wait for IMSG_DB_END */
	nbr->state = NBR_STA_SNAP;

	return (0);
}

int
nbr_act_exchange_done(struct nbr *nbr)
{
	if (nbr->dd_master)
		stop_db_tx_timer(nbr);

	if (ls_req_list_empty(nbr) && nbr->state == NBR_STA_XCHNG &&
	    nbr->dd_pending == 0) {
		nbr->state = NBR_STA_FULL;
		return (0);
	}

	nbr->state = NBR_STA_LOAD;

	if (!ls_req_list_empty(nbr))
		start_ls_req_tx_timer(nbr);

	return (0);
}

int
nbr_act_adj_ok(struct nbr *nbr)
{
	if (nbr_adj_ok(nbr)) {
		if (nbr->state == NBR_STA_2_WAY)
			return (nbr_act_eval(nbr));
	} else {
		nbr->state = NBR_STA_2_WAY;
		return (nbr_act_clear_lists(nbr));
	}

	return (0);
}

int
nbr_act_restart_dd(struct nbr *nbr)
{
	nbr_act_clear_lists(nbr);

	if (!nbr_adj_ok(nbr)) {
		nbr->state = NBR_STA_2_WAY;
		return (0);
	}

	nbr->state = NBR_STA_XSTRT;
	nbr->dd_master = 1;
	nbr->dd_seq_num += arc4random() & 0xffff;
	nbr->dd_pending = 0;

	/* initial db negotiation */
	start_db_tx_timer(nbr);

	nbr_start_adj_timer(nbr);

	return (0);
}

int
nbr_act_delete(struct nbr *nbr)
{
	struct timeval	tv;

	if (nbr == nbr->iface->self) {
		nbr->dr.s_addr = 0;
		nbr->bdr.s_addr = 0;
		return (0);
	}

	/* stop timers */
	nbr_stop_itimer(nbr);

	/* clear dr and bdr */
	nbr->dr.s_addr = 0;
	nbr->bdr.s_addr = 0;
	/* XXX reset crypt_seq_num will allow replay attacks. */
	nbr->crypt_seq_num = 0;

	/* schedule kill timer */
	timerclear(&tv);
	tv.tv_sec = DEFAULT_NBR_TMOUT;

	if (evtimer_add(&nbr->inactivity_timer, &tv)) {
		log_warnx("nbr_act_delete: error scheduling neighbor ID %s "
		    "for removal", inet_ntoa(nbr->id));
	}

	return (nbr_act_clear_lists(nbr));
}

int
nbr_act_clear_lists(struct nbr *nbr)
{
	/* stop timers */
	stop_db_tx_timer(nbr);
	stop_ls_req_tx_timer(nbr);

	/* clear lists */
	ls_retrans_list_clr(nbr);
	db_sum_list_clr(nbr);
	ls_req_list_clr(nbr);

	return (0);
}

int
nbr_act_hello_check(struct nbr *nbr)
{
	log_debug("nbr_act_hello_check: neighbor ID %s", inet_ntoa(nbr->id));

	return (-1);
}

struct ctl_nbr *
nbr_to_ctl(struct nbr *nbr)
{
	static struct ctl_nbr	 nctl;
	struct timeval		 tv, now, res;
	struct lsa_entry	*le;

	memcpy(nctl.name, nbr->iface->name, sizeof(nctl.name));
	memcpy(&nctl.id, &nbr->id, sizeof(nctl.id));
	memcpy(&nctl.addr, &nbr->addr, sizeof(nctl.addr));
	memcpy(&nctl.dr, &nbr->dr, sizeof(nctl.dr));
	memcpy(&nctl.bdr, &nbr->bdr, sizeof(nctl.bdr));
	memcpy(&nctl.area, &nbr->iface->area->id, sizeof(nctl.area));

	/* this list is 99% of the time empty so that's OK for now */
	nctl.db_sum_lst_cnt = 0;
	TAILQ_FOREACH(le, &nbr->db_sum_list, entry)
		nctl.db_sum_lst_cnt++;

	nctl.ls_req_lst_cnt = nbr->ls_req_cnt;
	nctl.ls_retrans_lst_cnt = nbr->ls_ret_cnt;

	nctl.nbr_state = nbr->state;

	/*
	 * We need to trick a bit to show the remote iface state.
	 * The idea is to print DR, BDR or DROther dependent on
	 * the type of the neighbor.
	 */
	if (nbr->iface->dr == nbr)
		nctl.iface_state = IF_STA_DR;
	else if (nbr->iface->bdr == nbr)
		nctl.iface_state = IF_STA_BACKUP;
	else if (nbr->iface->state & IF_STA_MULTI)
		nctl.iface_state = IF_STA_DROTHER;
	else
		nctl.iface_state = nbr->iface->state;

	nctl.state_chng_cnt = nbr->stats.sta_chng;

	nctl.priority = nbr->priority;
	nctl.options = nbr->options | nbr->capa_options;

	gettimeofday(&now, NULL);
	if (evtimer_pending(&nbr->inactivity_timer, &tv)) {
		timersub(&tv, &now, &res);
		if (nbr->state & NBR_STA_DOWN)
			nctl.dead_timer = DEFAULT_NBR_TMOUT - res.tv_sec;
		else
			nctl.dead_timer = res.tv_sec;
	} else
		nctl.dead_timer = 0;

	if (nbr->state == NBR_STA_FULL) {
		nctl.uptime = now.tv_sec - nbr->uptime;
	} else
		nctl.uptime = 0;

	return (&nctl);
}

struct lsa_hdr *
lsa_hdr_new(void)
{
	struct lsa_hdr	*lsa_hdr = NULL;

	if ((lsa_hdr = calloc(1, sizeof(*lsa_hdr))) == NULL)
		fatal("lsa_hdr_new");

	return (lsa_hdr);
}
@


1.46
log
@improve snapshot handling:
- don't start a new snapshot if we are already in NBR_STA_SNAP
- ignore IMSG_DB_SNAPSHOT and IMSG_DB_END unless we are in NBR_STA_SNAP
- add new IMSG_LS_SNAP message so we can distinguish it from
  IMSG_LS_UPD. this way we can ignore them if we are not in NBR_STA_SNAP
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.43 2011/05/09 12:24:41 claudio Exp $ */
a206 1
			area_track(nbr->iface->area, nbr->state);
@


1.45
log
@ignore the nbr_adj_timer if we are not forming adjacencies; ok claudio
@
text
@d59 1
a59 1
	int		new_state;
d68 1
a68 1
    {NBR_STA_XSTRT,	NBR_EVT_NEG_DONE,	NBR_ACT_SNAP,		NBR_STA_SNAP},
d76 2
a77 2
    {NBR_STA_FLOOD,	NBR_EVT_SEQ_NUM_MIS,	NBR_ACT_RESTRT_DD,	NBR_STA_XSTRT},
    {NBR_STA_FLOOD,	NBR_EVT_BAD_LS_REQ,	NBR_ACT_RESTRT_DD,	NBR_STA_XSTRT},
d523 6
d532 3
@


1.44
log
@transmit correct state to RDE; ok claudio
@
text
@d432 2
a433 2
	if (nbr->state == NBR_STA_2_WAY)
		return ;
@


1.43
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.42 2011/03/24 08:35:59 claudio Exp $ */
d200 1
a200 1
		    nbr->peerid, 0, &new_state, sizeof(new_state));
@


1.42
log
@Fix some memory leaks. Mainly better cleanup on shutdown but the v_nexthop
leak is a runtime one.
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.41 2010/05/07 22:32:34 sthen Exp $ */
d316 1
d523 2
d683 1
a683 1
	nctl.options = nbr->options;
@


1.41
log
@When failing to form an adjacency, log the interface name as well
as the neighbour. ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.40 2010/02/16 18:13:52 claudio Exp $ */
d345 2
a346 1
	LIST_REMOVE(nbr, entry);
@


1.40
log
@Clear the DR and BDR addresses in nbr_act_delete(), makes the election
process more reliable after interface flaps. Especially when the router-id
changed at the same time.
OK dlg@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.39 2009/09/30 14:39:07 claudio Exp $ */
d434 2
a435 2
		log_warnx("nbr_adj_timer: failed to form adjacency with %s",
		    inet_ntoa(nbr->id));
@


1.39
log
@Oups, these changes should not have been commited. Revert.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.37 2008/02/11 12:37:37 norby Exp $ */
d588 3
a590 1
	if (nbr == nbr->iface->self)
d592 1
d600 1
@


1.38
log
@Announce a stub network LSA for backup carp interfaces. This should help
when fail-over happens, since removing the better route will not result
in a blackhole until the update from the new master is processed.
Tested, OK and input sthen@@, phessler@@
@
text
@a213 5

			/* demote P2P links if the neighbor resets */
			if (nbr->iface->type == IF_TYPE_POINTOPOINT)
				ospfe_demote_iface(nbr->iface,
				    !(old_state & NBR_STA_FULL));
@


1.37
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.36 2007/10/11 08:21:29 claudio Exp $ */
d214 5
@


1.36
log
@Do not overload nbr->options with the dd exchange bits. nbr->options is used
by the hello protocol. Instead add a dd_more flag that is used together with
(the renamed) dd_master flag.
Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.35 2007/06/13 17:47:52 claudio Exp $ */
d491 1
a491 1
		fatalx("nbr_act_ok: unknown interface type");
@


1.35
log
@NBR_ACT_HELLO_CHK was missing in the nbr_action_names list.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.34 2007/01/24 14:08:28 claudio Exp $ */
d279 1
a279 1
	nbr->master = 1;
d505 1
a505 1
	nbr->master = 1;
d529 1
a529 1
	if (nbr->master)
d571 1
a571 1
	nbr->master = 1;
@


1.34
log
@When deleting a neighbor or a interface make sure that no events are pending.
Needed for reload support.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.33 2006/08/06 12:36:23 claudio Exp $ */
d114 2
a115 1
	"CLEAR_LISTS"
@


1.33
log
@Remove a XXX in a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.32 2006/03/13 09:36:06 claudio Exp $ */
d327 11
@


1.32
log
@The return value of the start/stop timer functions is almost never checked.
Switch them to void functions and check if evtimer_add/del fails -- in which
case we fatal() as there is no useful way to recover in such an event.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.31 2006/03/09 15:43:21 claudio Exp $ */
d137 1
a137 1
		/* XXX event outside of the defined fsm, ignore it. */
@


1.31
log
@Move *_name functions to log.c and use these for both ospfd and ospfctl.
Stuff that is only used in ospfd debug messages is simplified.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.30 2006/02/19 21:48:56 norby Exp $ */
d361 1
a361 1
		if (nbr->id.s_addr == rtr_id) {
a362 1
		}
d369 1
d375 1
a375 1
	if (nbr->state == NBR_STA_DOWN) {
d377 1
a377 1
	} else
d381 1
a381 1
int
d389 2
a390 1
	return (evtimer_add(&nbr->inactivity_timer, &tv));
d393 1
a393 1
int
d396 2
a397 1
	return (evtimer_del(&nbr->inactivity_timer));
d400 1
a400 1
int
d408 2
a409 1
	return (evtimer_add(&nbr->inactivity_timer, &tv));
d412 1
d428 1
a428 1
int
d436 2
a437 1
	return (evtimer_add(&nbr->adj_timer, &tv));
d444 1
a444 5
	if (nbr_reset_itimer(nbr)) {
		log_warnx("nbr_act_reset_itimer: cannot schedule inactivity "
		    "timer, neighbor ID %s", inet_ntoa(nbr->id));
		return (-1);
	}
d452 1
a452 6
	if (nbr_start_itimer(nbr)) {
		log_warnx("nbr_act_start_itimer: cannot schedule inactivity "
		    "timer, neighbor ID %s",
		    inet_ntoa(nbr->id));
		return (-1);
	}
d580 1
a580 5
	if (nbr_stop_itimer(nbr)) {
		log_warnx("nbr_act_delete: error removing inactivity timer, "
		    "neighbor ID %s", inet_ntoa(nbr->id));
		return (-1);
	}
a584 1

d602 3
a604 11
	if (stop_db_tx_timer(nbr)) {
		log_warnx("nbr_act_clear_lists: error removing db_tx_timer, "
		    "neighbor ID %s", inet_ntoa(nbr->id));
		return (-1);
	}

	if (stop_ls_req_tx_timer(nbr)) {
		log_warnx("nbr_act_clear_lists: error removing lsreq_tx_timer, "
		    "neighbor ID %s", inet_ntoa(nbr->id));
		return (-1);
	}
@


1.30
log
@Keep track of the duration of our relationships with neighbors.
Displayed in "ospfctl show neighbor".

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.29 2006/02/19 19:23:17 norby Exp $ */
d140 1
a140 1
		    inet_ntoa(nbr->id), nbr_event_name(event),
d188 1
a188 1
		    nbr_event_name(event), nbr_state_name(old_state));
d221 2
a222 2
		    nbr_event_name(event),
		    nbr_action_name(nbr_fsm_tbl[i].action),
a697 40
}

/* names */
const char *
nbr_state_name(int state)
{
	switch (state) {
	case NBR_STA_DOWN:
		return ("DOWN");
	case NBR_STA_ATTEMPT:
		return ("ATTEMPT");
	case NBR_STA_INIT:
		return ("INIT");
	case NBR_STA_2_WAY:
		return ("2-WAY");
	case NBR_STA_XSTRT:
		return ("EXSTART");
	case NBR_STA_SNAP:
		return ("SNAPSHOT");
	case NBR_STA_XCHNG:
		return ("EXCHANGE");
	case NBR_STA_LOAD:
		return ("LOADING");
	case NBR_STA_FULL:
		return ("FULL");
	default:
		return ("UNKNOWN");
	}
}

const char *
nbr_event_name(int event)
{
	return (nbr_event_names[event]);
}

const char *
nbr_action_name(int action)
{
	return (nbr_action_names[action]);
@


1.29
log
@Do not kick the adj_timer for neighbors that are in state 2-Way.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.28 2006/02/19 18:55:47 norby Exp $ */
d120 1
d210 3
d691 5
@


1.28
log
@Do not traverse the entire LS retransmission list to figure out how many
are present on it.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.27 2006/02/09 15:23:08 norby Exp $ */
d409 3
@


1.27
log
@Prevent the neighbor FSM from getting stuck forever in state EXSTART.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.26 2005/12/15 20:29:06 claudio Exp $ */
d652 1
a652 5

	/* XXX */
	nctl.ls_retrans_lst_cnt = 0;
	TAILQ_FOREACH(le, &nbr->ls_retrans_list, entry)
		nctl.ls_retrans_lst_cnt++;
@


1.26
log
@Simpify iface_del() and nbr_del(). make them void funtions as they can not fail
and do not remove a element twice in iface_del(). OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.25 2005/10/19 21:46:21 claudio Exp $ */
d496 2
a504 1
	nbr_start_adj_timer(nbr);
d562 2
@


1.25
log
@Add neighbor ID in warning and use correct function names.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.24 2005/09/29 15:14:57 claudio Exp $ */
d319 1
a319 1
int
a321 3
	if (nbr == nbr->iface->self)
		return (0);

a332 2

	return (0);
d569 3
@


1.24
log
@Show the time a neighbor was DOWN instead of counting down from
DEFAULT_NBR_TMOUT. Makes it easy to see since when a peer is dead.
OK norby@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.23 2005/06/13 08:32:29 claudio Exp $ */
d416 2
a417 1
		log_debug("nbr_adj_timer: failed to form adjacency");
d604 1
a604 1
		log_warnx("nbr_act_delete: error removing db_tx_timer, "
d610 1
a610 1
		log_warnx("nbr_act_delete: error removing lsreq_tx_timer, "
@


1.23
log
@simplify the fsm by moving all the checks that are done if the state changed
into one if (old_state != nbr->state) { block.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.22 2005/05/27 08:44:43 norby Exp $ */
d680 4
a683 1
		nctl.dead_timer = res.tv_sec;
@


1.22
log
@When the neighbor at the other end of the virtual link goes to state
full, originate a new router LSA.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.21 2005/05/27 02:45:15 norby Exp $ */
d194 3
a196 2
	/* state change inform RDE */
	if (old_state != nbr->state)
d200 14
a213 12
	/* bidirectional communication lost */
	if (old_state & ~NBR_STA_PRELIM && nbr->state & NBR_STA_PRELIM)
		if_fsm(nbr->iface, IF_EVT_NBR_CHNG);

	/* neighbor changed from/to FULL originate new rtr and net LSA */
	if (old_state != nbr->state && (old_state & NBR_STA_FULL ||
	    nbr->state & NBR_STA_FULL)) {
		area_track(nbr->iface->area, nbr->state);
		orig_rtr_lsa(nbr->iface->area);
		if (nbr->iface->state & IF_STA_DR)
			orig_net_lsa(nbr->iface);
	}
a214 2
	if (old_state != nbr->state) {
		nbr->stats.sta_chng++;
@


1.21
log
@Clearify.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.20 2005/05/26 22:09:10 norby Exp $ */
d220 4
@


1.20
log
@Remove unused event/action caption.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.19 2005/05/26 20:42:10 norby Exp $ */
d462 1
@


1.19
log
@Remove unused neighbor state.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.18 2005/05/26 20:21:09 norby Exp $ */
a87 1
	"START",
a104 1
	"START",
@


1.18
log
@Remove unneeded debug stuff when handling neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.17 2005/05/12 08:55:39 claudio Exp $ */
a65 1
    {NBR_STA_DOWN,	NBR_EVT_STRT,		NBR_ACT_STRT,		NBR_STA_ATTEMPT},
a146 3
	case NBR_ACT_STRT:
		ret = nbr_act_start(nbr);
		break;
a429 8
int
nbr_act_start(struct nbr *nbr)
{
	log_debug("nbr_act_start: neighbor ID %s", inet_ntoa(nbr->id));

	return (-1);
}

@


1.17
log
@If activly connected to more than one area set B flag in the self-originated
router LSA. To do that correctly we need to track the number of active
neighbors for each area. If the routers ABR status changes all router LSA
need to be updated via orig_rtr_lsa_all().
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.16 2005/05/01 17:35:27 david Exp $ */
a308 3
	log_debug("nbr_new: neighbor ID %s, peerid %lu",
	    inet_ntoa(nbr->id), nbr->peerid);

a322 3
	log_debug("nbr_del: neighbor ID %s, peerid %lu", inet_ntoa(nbr->id),
	    nbr->peerid);

a376 2
	log_debug("nbr_itimer: %s", inet_ntoa(nbr->id));

a387 2
	log_debug("nbr_start_itimer: %s", inet_ntoa(nbr->id));

a426 2
	log_debug("nbr_start_adj_timer: %s", inet_ntoa(nbr->id));

a495 2
	log_debug("nbr_act_eval: neighbor ID %s", inet_ntoa(nbr->id));

a513 2
	log_debug("nbr_act_snapshot: neighbor ID %s", inet_ntoa(nbr->id));

a524 2
	log_debug("nbr_act_exchange_done: neighbor ID %s", inet_ntoa(nbr->id));

a544 2
	log_debug("nbr_act_adj_ok: neighbor ID %s", inet_ntoa(nbr->id));

a558 2
	log_debug("nbr_act_restart_dd: neighbor ID %s", inet_ntoa(nbr->id));

a581 2
	log_debug("nbr_act_delete: neighbor ID %s", inet_ntoa(nbr->id));

a609 2
	log_debug("nbr_act_clear_lists: neighbor ID %s", inet_ntoa(nbr->id));

@


1.16
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.15 2005/04/12 09:54:59 claudio Exp $ */
d212 1
@


1.15
log
@Support for self originated AS-external LSA.
With "redistribute (static|connected|default|none)" it is possible to
tell ospfd which external routes should be announced.
Connected routes will be announced only if there is no corresponding
interface configured, in that case the prefix is not external.
Adding and removing of announced prefixes are done automaticaly.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.14 2005/03/31 19:32:10 norby Exp $ */
d492 1
a492 1
		 * start forming adjacancy
@


1.14
log
@Add support for crypt authentication (MD5).

ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.13 2005/03/22 22:13:48 norby Exp $ */
d53 1
a53 1
u_int32_t	peercnt;
d233 2
d247 14
d267 1
a267 1
	struct nbr	*nbr = NULL;
@


1.13
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.12 2005/03/17 21:17:12 claudio Exp $ */
d599 2
@


1.12
log
@Handle the retransmission queues correctly. Mainly iface state DROTHER
needs to be handled specially because the backup DR does not send acks and
so his retransmission queue fills up and does not get cleared.
Also implement the retransmission timeout correctly.

OK henning@@ norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.11 2005/02/10 14:05:48 claudio Exp $ */
d258 1
a258 1
	nbr->master = true;
d499 1
a499 1
	nbr->master = true;
d572 1
a572 1
	nbr->master = true;
@


1.11
log
@Work around a timing issue in the db exchange phase. The DB description
packets comming from the net are looped through the RDE and may get
delayed because of this. The result is that the neighbor FSM ends in
state FULL instead of LOADING and so the LSDB is not correctly
synchronized. Issue found by norby@@ OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.10 2005/02/10 10:16:02 claudio Exp $ */
d289 1
@


1.10
log
@Cleanup the neighbor FSM. Use log_warnx() where appropriate and don't
use the correct enum instead of 0 in the nbr_fsm_tbl.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.9 2005/02/09 20:40:23 claudio Exp $ */
d500 1
d528 2
a529 1
	if (ls_req_list_empty(nbr) && nbr->state == NBR_STA_XCHNG) {
d535 3
a537 1
	start_ls_req_tx_timer(nbr);
d573 1
@


1.9
log
@Rework of self originated LSA. First of all the code to generate the LSA
is rewritten to use the dynamic buffer api introduced lately.
Add missing parts in the RDE to merge these LSA originated from the OE into
the LSDB with correct seq_num, etc.
Add hooks to the neighbor and interface fsm so that the LSA get updated if
needed. This is not perfect, still many things are missing. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.8 2005/02/09 16:14:23 claudio Exp $ */
d63 2
a64 2
    {NBR_STA_BIDIR,	NBR_EVT_2_WAY_RCVD,	0,			0},
    {NBR_STA_INIT,	NBR_EVT_1_WAY_RCVD,	0,			0},
d72 1
a72 1
    {NBR_STA_LOAD,	NBR_EVT_LOAD_DONE,	0,			NBR_STA_FULL},
d83 1
a83 1
    {-1,		0,			-1,			0},
d140 1
a140 1
		log_debug("nbr_fsm: neighbor ID %s, "
d185 1
a185 1
	default:
d191 1
a191 1
		log_debug("nbr_fsm: error changing state for neighbor ID %s, "
@


1.8
log
@Print the interface state from the view of the neighbor in ospfctl sh nei.
The idea is to print DR, BDR or DROther dependent on the type of the
neighbor. This is only done for multicast capable networks.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.7 2005/02/09 16:08:06 claudio Exp $ */
d200 2
a201 1
	if (nbr->state != old_state)
d205 2
a206 2
	if (old_state & ~NBR_STA_PRELIM && new_state & NBR_STA_PRELIM)
		/* bidirectional communication lost */
d208 8
@


1.7
log
@Prevent the ADJ_TMOUT from complaining about an unexpected event.
From norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.6 2005/02/09 15:57:57 claudio Exp $ */
d657 14
a670 1
	nctl.iface_state = nbr->iface->state;
@


1.6
log
@Fix the restart DD case. In case of a timeout recheck the adjacency and go
to state NBR_STA_XSTRT and issue a new initial DB description packet or go
to NBR_STA_2_WAY respectivly.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.5 2005/02/09 12:53:17 claudio Exp $ */
d399 1
a399 1
	if (nbr->state != NBR_STA_FULL) {
@


1.5
log
@Print the neighbor address and not the local interface address in
ospfctl show nei.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.4 2005/02/02 19:15:07 henning Exp $ */
d76 1
a76 1
    {NBR_STA_ADJFORM,	NBR_EVT_ADJTMOUT,	NBR_ACT_RESTRT_DD,	NBR_STA_2_WAY},
d550 8
d561 4
a564 1
	return (nbr_act_clear_lists(nbr));
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.3 2005/02/01 21:15:40 norby Exp $ */
d628 1
a628 1
	memcpy(&nctl.addr, &nbr->iface->addr, sizeof(nctl.addr));
@


1.3
log
@Free neighbors that have been inactive for 24hrs.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d625 1
a625 1
	
d656 1
a656 1
 		nctl.dead_timer = res.tv_sec;
d659 1
a659 1
	
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d358 4
a361 1
	nbr_fsm(nbr, NBR_EVT_ITIMER);
d559 2
d573 9
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * Copyright (c) 2004, 2005 Esben Norby <esben.norby@@ericsson.com>
@

