head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.10
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.33.0.8
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.10
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.8
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.4
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.4
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.33
date	2016.02.18.15.33.24;	author bluhm;	state Exp;
branches;
next	1.32;
commitid	NFmu67fVQghPIX21;

1.32
date	2015.03.13.02.31.29;	author claudio;	state Exp;
branches;
next	1.31;
commitid	MMOnXVdj2WKGvACB;

1.31
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.30;
commitid	2uw1UTO4k6erpWzK;

1.30
date	2013.01.17.08.58.53;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2011.03.04.09.24.46;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.01.31.11.44.49;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.31.08.55.00;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.08.19.18.17;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.24.18.28.02;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2008.02.11.12.37.37;	author norby;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.11.12.19.31;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.11.08.21.29;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.13.09.36.06;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.09.13.34.19;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.12.18.18.24;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.04.10.30.23;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.19.21.43.20;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.18.15.39.05;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.17.20.03.35;	author msf;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.27.05.51.22;	author norby;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.26.19.54.49;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.26.19.10.56;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.22.15.33.00;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.12.09.47.30;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.05.13.01.21;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.10.14.05.48;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.09.15.39.22;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Fix format string of a warning.
from markus@@; OK claudio@@
@
text
@/*	$OpenBSD: database.c,v 1.32 2015/03/13 02:31:29 claudio Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ospfd.h"
#include "ospf.h"
#include "log.h"
#include "ospfe.h"

extern struct ospfd_conf	*oeconf;

void	db_sum_list_next(struct nbr *);

/* database description packet handling */
int
send_db_description(struct nbr *nbr)
{
	struct sockaddr_in	 dst;
	struct db_dscrp_hdr	 dd_hdr;
	struct lsa_entry	*le, *nle;
	struct ibuf		*buf;
	int			 ret = 0;
	u_int8_t		 bits = 0;

	if ((buf = ibuf_open(nbr->iface->mtu - sizeof(struct ip))) == NULL)
		fatal("send_db_description");

	/* OSPF header */
	if (gen_ospf_hdr(buf, nbr->iface, PACKET_TYPE_DD))
		goto fail;

	/* reserve space for database description header */
	if (ibuf_reserve(buf, sizeof(dd_hdr)) == NULL)
		goto fail;

	switch (nbr->state) {
	case NBR_STA_DOWN:
	case NBR_STA_ATTEMPT:
	case NBR_STA_INIT:
	case NBR_STA_2_WAY:
	case NBR_STA_SNAP:
		log_debug("send_db_description: neighbor ID %s: "
		    "cannot send packet in state %s", inet_ntoa(nbr->id),
		    nbr_state_name(nbr->state));
		ret = -1;
		goto done;
	case NBR_STA_XSTRT:
		bits |= OSPF_DBD_MS | OSPF_DBD_M | OSPF_DBD_I;
		nbr->dd_more = 1;
		break;
	case NBR_STA_XCHNG:
		if (nbr->dd_master)
			bits |= OSPF_DBD_MS;
		else
			bits &= ~OSPF_DBD_MS;

		if (TAILQ_EMPTY(&nbr->db_sum_list)) {
			bits &= ~OSPF_DBD_M;
			nbr->dd_more = 0;
		} else {
			bits |= OSPF_DBD_M;
			nbr->dd_more = 1;
		}

		bits &= ~OSPF_DBD_I;

		/* build LSA list, keep space for a possible md5 sum */
		for (le = TAILQ_FIRST(&nbr->db_sum_list); le != NULL &&
		    ibuf_left(buf) >= MD5_DIGEST_LENGTH + sizeof(struct lsa_hdr);
		    le = nle) {
			nbr->dd_end = nle = TAILQ_NEXT(le, entry);
			if (ibuf_add(buf, le->le_lsa, sizeof(struct lsa_hdr)))
				goto fail;
		}
		break;
	case NBR_STA_LOAD:
	case NBR_STA_FULL:
		if (nbr->dd_master)
			bits |= OSPF_DBD_MS;
		else
			bits &= ~OSPF_DBD_MS;
		bits &= ~OSPF_DBD_M;
		bits &= ~OSPF_DBD_I;

		nbr->dd_more = 0;
		break;
	default:
		fatalx("send_db_description: unknown neighbor state");
	}

	/* set destination */
	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);

	switch (nbr->iface->type) {
	case IF_TYPE_POINTOPOINT:
		inet_aton(AllSPFRouters, &dst.sin_addr);
		dd_hdr.iface_mtu = htons(nbr->iface->mtu);
		break;
	case IF_TYPE_BROADCAST:
		dst.sin_addr = nbr->addr;
		dd_hdr.iface_mtu = htons(nbr->iface->mtu);
		break;
	case IF_TYPE_NBMA:
	case IF_TYPE_POINTOMULTIPOINT:
		/* XXX not supported */
		break;
	case IF_TYPE_VIRTUALLINK:
		dst.sin_addr = nbr->iface->dst;
		dd_hdr.iface_mtu = 0;
		break;
	default:
		fatalx("send_db_description: unknown interface type");
	}

	/* XXX button or not for opaque LSA? */
	dd_hdr.opts = area_ospf_options(nbr->iface->area) | OSPF_OPTION_O;
	dd_hdr.bits = bits;
	dd_hdr.dd_seq_num = htonl(nbr->dd_seq_num);

	memcpy(ibuf_seek(buf, sizeof(struct ospf_hdr), sizeof(dd_hdr)),
	    &dd_hdr, sizeof(dd_hdr));

	/* update authentication and calculate checksum */
	if (auth_gen(buf, nbr->iface))
		goto fail;

	/* transmit packet */
	ret = send_packet(nbr->iface, buf, &dst);
done:
	ibuf_free(buf);
	return (ret);
fail:
	log_warn("send_db_description");
	ibuf_free(buf);
	return (-1);
}

void
recv_db_description(struct nbr *nbr, char *buf, u_int16_t len)
{
	struct db_dscrp_hdr	 dd_hdr;
	int			 dupe = 0;

	if (len < sizeof(dd_hdr)) {
		log_warnx("recv_db_description: neighbor ID %s: "
		    "bad packet size", inet_ntoa(nbr->id));
		return;
	}
	memcpy(&dd_hdr, buf, sizeof(dd_hdr));
	buf += sizeof(dd_hdr);
	len -= sizeof(dd_hdr);

	/* db description packet sanity checks */
	if (ntohs(dd_hdr.iface_mtu) > nbr->iface->mtu) {
		log_warnx("recv_db_description: neighbor ID %s: "
		    "invalid MTU %d expected %d", inet_ntoa(nbr->id),
		    ntohs(dd_hdr.iface_mtu), nbr->iface->mtu);
		return;
	}

	if (nbr->last_rx_options == dd_hdr.opts &&
	    nbr->last_rx_bits == dd_hdr.bits &&
	    ntohl(dd_hdr.dd_seq_num) == nbr->dd_seq_num - nbr->dd_master ?
	    1 : 0) {
		log_debug("recv_db_description: dupe from neighbor ID %s",
		    inet_ntoa(nbr->id));
		dupe = 1;
	}

	switch (nbr->state) {
	case NBR_STA_DOWN:
	case NBR_STA_ATTEMPT:
	case NBR_STA_2_WAY:
	case NBR_STA_SNAP:
		log_debug("recv_db_description: neighbor ID %s: "
		    "packet ignored in state %s", inet_ntoa(nbr->id),
		    nbr_state_name(nbr->state));
		return;
	case NBR_STA_INIT:
		/* evaluate dr and bdr after issuing a 2-Way event */
		nbr_fsm(nbr, NBR_EVT_2_WAY_RCVD);
		if_fsm(nbr->iface, IF_EVT_NBR_CHNG);
		if (nbr->state != NBR_STA_XSTRT)
			return;
		/* FALLTHROUGH */
	case NBR_STA_XSTRT:
		if (dupe)
			return;
		nbr->capa_options = dd_hdr.opts;
		if ((nbr->capa_options & nbr->options) != nbr->options) {
			log_warnx("recv_db_description: neighbor ID %s "
			    "sent inconsistent options %x vs. %x",
			    inet_ntoa(nbr->id), nbr->capa_options,
			    nbr->options);
		}
		/*
		 * check bits: either I,M,MS or only M
		 */
		if (dd_hdr.bits == (OSPF_DBD_I | OSPF_DBD_M | OSPF_DBD_MS)) {
			/* if nbr Router ID is larger than own -> slave */
			if ((ntohl(nbr->id.s_addr)) >
			    ntohl(ospfe_router_id())) {
				/* slave */
				nbr->dd_master = 0;
				nbr->dd_seq_num = ntohl(dd_hdr.dd_seq_num);

				/* event negotiation done */
				nbr_fsm(nbr, NBR_EVT_NEG_DONE);
			}
		} else if (!(dd_hdr.bits & (OSPF_DBD_I | OSPF_DBD_MS))) {
			/* M only case: we are master */
			if (ntohl(dd_hdr.dd_seq_num) != nbr->dd_seq_num) {
				log_warnx("recv_db_description: "
				    "neighbor ID %s: "
				    "invalid seq num, mine %x his %x",
				    inet_ntoa(nbr->id), nbr->dd_seq_num,
				    ntohl(dd_hdr.dd_seq_num));
				return;
			}
			nbr->dd_seq_num++;

			/* event negotiation done */
			nbr_fsm(nbr, NBR_EVT_NEG_DONE);

			/* this packet may already have data so pass it on */
			if (len > 0) {
				nbr->dd_pending++;
				ospfe_imsg_compose_rde(IMSG_DD, nbr->peerid,
				    0, buf, len);
			}
		} else {
			/* ignore packet */
			log_debug("recv_db_description: neighbor ID %s: "
			    "packet ignored in state %s (bad flags)",
			    inet_ntoa(nbr->id), nbr_state_name(nbr->state));
		}
		break;
	case NBR_STA_XCHNG:
	case NBR_STA_LOAD:
	case NBR_STA_FULL:
		if (dd_hdr.bits & OSPF_DBD_I ||
		    !(dd_hdr.bits & OSPF_DBD_MS) == !nbr->dd_master) {
			log_warnx("recv_db_description: neighbor ID %s: "
			    "seq num mismatch, bad flags", inet_ntoa(nbr->id));
			nbr_fsm(nbr, NBR_EVT_SEQ_NUM_MIS);
			return;
		}

		if (nbr->last_rx_options != dd_hdr.opts) {
			log_warnx("recv_db_description: neighbor ID %s: "
			    "seq num mismatch, bad options",
			    inet_ntoa(nbr->id));
			nbr_fsm(nbr, NBR_EVT_SEQ_NUM_MIS);
			return;
		}

		if (dupe) {
			if (!nbr->dd_master)
				/* retransmit */
				start_db_tx_timer(nbr);
			return;
		}

		if (nbr->state != NBR_STA_XCHNG) {
			log_warnx("recv_db_description: neighbor ID %s: "
			    "invalid seq num, mine %x his %x",
			    inet_ntoa(nbr->id), nbr->dd_seq_num,
			    ntohl(dd_hdr.dd_seq_num));
			nbr_fsm(nbr, NBR_EVT_SEQ_NUM_MIS);
			return;
		}

		/* sanity check dd seq number */
		if (nbr->dd_master) {
			/* master */
			if (ntohl(dd_hdr.dd_seq_num) != nbr->dd_seq_num) {
				log_warnx("recv_db_description: "
				    "neighbor ID %s: "
				    "invalid seq num, mine %x his %x, master",
				    inet_ntoa(nbr->id), nbr->dd_seq_num,
				    ntohl(dd_hdr.dd_seq_num));
				nbr_fsm(nbr, NBR_EVT_SEQ_NUM_MIS);
				return;
			}
			nbr->dd_seq_num++;
		} else {
			/* slave */
			if (ntohl(dd_hdr.dd_seq_num) != nbr->dd_seq_num + 1) {
				log_warnx("recv_db_description: "
				    "neighbor ID %s: "
				    "invalid seq num, mine %x his %x, slave",
				    inet_ntoa(nbr->id), nbr->dd_seq_num,
				    ntohl(dd_hdr.dd_seq_num));
				nbr_fsm(nbr, NBR_EVT_SEQ_NUM_MIS);
				return;
			}
			nbr->dd_seq_num = ntohl(dd_hdr.dd_seq_num);
		}

		/* forward to RDE and let it decide which LSAs to request */
		if (len > 0) {
			nbr->dd_pending++;
			ospfe_imsg_compose_rde(IMSG_DD, nbr->peerid, 0,
			    buf, len);
		}

		/* next packet */
		db_sum_list_next(nbr);
		start_db_tx_timer(nbr);

		if (!(dd_hdr.bits & OSPF_DBD_M) &&
		    TAILQ_EMPTY(&nbr->db_sum_list))
			if (!nbr->dd_master || !nbr->dd_more)
				nbr_fsm(nbr, NBR_EVT_XCHNG_DONE);
		break;
	default:
		fatalx("recv_db_description: unknown neighbor state");
	}

	nbr->last_rx_options = dd_hdr.opts;
	nbr->last_rx_bits = dd_hdr.bits;
}

void
db_sum_list_add(struct nbr *nbr, struct lsa_hdr *lsa)
{
	struct lsa_entry	*le;

	if ((le = calloc(1, sizeof(*le))) == NULL)
		fatal("db_sum_list_add");

	TAILQ_INSERT_TAIL(&nbr->db_sum_list, le, entry);
	le->le_lsa = lsa;
}

void
db_sum_list_next(struct nbr *nbr)
{
	struct lsa_entry	*le;

	while ((le = TAILQ_FIRST(&nbr->db_sum_list)) != nbr->dd_end) {
		TAILQ_REMOVE(&nbr->db_sum_list, le, entry);
		free(le->le_lsa);
		free(le);
	}
}

void
db_sum_list_clr(struct nbr *nbr)
{
	nbr->dd_end = NULL;
	db_sum_list_next(nbr);
}

/* timers */
/* ARGSUSED */
void
db_tx_timer(int fd, short event, void *arg)
{
	struct nbr *nbr = arg;
	struct timeval tv;

	switch (nbr->state) {
	case NBR_STA_DOWN:
	case NBR_STA_ATTEMPT:
	case NBR_STA_INIT:
	case NBR_STA_2_WAY:
	case NBR_STA_SNAP:
		return ;
	case NBR_STA_XSTRT:
	case NBR_STA_XCHNG:
	case NBR_STA_LOAD:
	case NBR_STA_FULL:
		send_db_description(nbr);
		break;
	default:
		log_debug("db_tx_timer: neighbor ID %s: unknown neighbor state",
		    inet_ntoa(nbr->id));
		break;
	}

	/* reschedule db_tx_timer but only in master mode */
	if (nbr->dd_master) {
		timerclear(&tv);
		tv.tv_sec = nbr->iface->rxmt_interval;
		if (evtimer_add(&nbr->db_tx_timer, &tv) == -1)
			fatal("db_tx_timer");
	}
}

void
start_db_tx_timer(struct nbr *nbr)
{
	struct timeval	tv;

	if (nbr == nbr->iface->self)
		return;

	timerclear(&tv);
	if (evtimer_add(&nbr->db_tx_timer, &tv) == -1)
		fatal("start_db_tx_timer");
}

void
stop_db_tx_timer(struct nbr *nbr)
{
	if (nbr == nbr->iface->self)
		return;

	if (evtimer_del(&nbr->db_tx_timer) == -1)
		fatal("stop_db_tx_timer");
}
@


1.32
log
@Make sure that the debug messages include the neighbor ID so we hava a chance
to know which neighbor caused the problems. While there make sure that all
messages log roughly in the same way.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.31 2014/10/25 03:23:49 lteo Exp $ */
d170 1
a170 1
		log_warnx("recv_db_description: neighbor ID %s: ",
@


1.31
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.30 2013/01/17 08:58:53 markus Exp $ */
d66 3
a68 3
		log_debug("send_db_description: cannot send packet in state %s,"
		    " neighbor ID %s", nbr_state_name(nbr->state),
		    inet_ntoa(nbr->id));
d170 2
a171 2
		log_warnx("recv_db_description: "
		    "bad packet size, neighbor ID %s", inet_ntoa(nbr->id));
d180 3
a182 3
		log_warnx("recv_db_description: invalid MTU %d sent by "
		    "neighbor ID %s, expected %d", ntohs(dd_hdr.iface_mtu),
		    inet_ntoa(nbr->id), nbr->iface->mtu);
d190 1
a190 1
		log_debug("recv_db_description: dupe from ID %s",
d200 3
a202 3
		log_debug("recv_db_description: packet ignored in state %s, "
		    "neighbor ID %s", nbr_state_name(nbr->state),
		    inet_ntoa(nbr->id));
d238 5
a242 3
				log_warnx("recv_db_description: invalid "
				    "seq num, mine %x his %x",
				    nbr->dd_seq_num, ntohl(dd_hdr.dd_seq_num));
d258 3
a260 3
			log_debug("recv_db_description: packet ignored in "
			    "state %s (bad flags), neighbor ID %s",
			    nbr_state_name(nbr->state), inet_ntoa(nbr->id));
d268 2
a269 2
			log_warnx("recv_db_description: seq num mismatch, "
			    "bad flags");
d275 3
a277 2
			log_warnx("recv_db_description: seq num mismatch, "
			    "bad options");
d290 4
a293 3
			log_warnx("recv_db_description: invalid "
			    "seq num, mine %x his %x",
			    nbr->dd_seq_num, ntohl(dd_hdr.dd_seq_num));
d302 5
a306 3
				log_warnx("recv_db_description: invalid "
				    "seq num, mine %x his %x",
				    nbr->dd_seq_num, ntohl(dd_hdr.dd_seq_num));
d314 5
a318 3
				log_warnx("recv_db_description: invalid "
				    "seq num, mine %x his %x",
				    nbr->dd_seq_num, ntohl(dd_hdr.dd_seq_num));
d402 2
a403 2
		log_debug("db_tx_timer: unknown neighbor state, "
		    "neighbor ID %s", inet_ntoa(nbr->id));
@


1.30
log
@the event NBR_EVT_SEQ_NUM_MIS is not defined in state NBR_STA_XSTRT
(would change back to NBR_STA_XSTRT anyway)
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.29 2011/05/09 12:24:41 claudio Exp $ */
a22 1
#include <netinet/in_systm.h>
@


1.29
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.28 2011/03/04 09:24:46 claudio Exp $ */
a241 1
				nbr_fsm(nbr, NBR_EVT_SEQ_NUM_MIS);
@


1.28
log
@Indent block correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.27 2010/05/26 13:56:08 nicm Exp $ */
d141 2
a142 1
	dd_hdr.opts = area_ospf_options(nbr->iface->area);
d215 7
@


1.27
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.26 2009/01/31 11:44:49 claudio Exp $ */
d190 3
a192 3
			log_debug("recv_db_description: dupe from ID %s",
			    inet_ntoa(nbr->id));
			dupe = 1;
@


1.26
log
@Implement buf_left() to make some some more buffer handling easier.
buf_left() returns the bytes left in a buffer. This makes the check to
keep MD5_DIGEST_LENGTH bytes unallocated in some messages easier.
From the buf cleanup diff that was OK norby@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.25 2009/01/31 08:55:00 claudio Exp $ */
d46 1
a46 1
	struct buf		*buf;
d50 1
a50 1
	if ((buf = buf_open(nbr->iface->mtu - sizeof(struct ip))) == NULL)
d58 1
a58 1
	if (buf_reserve(buf, sizeof(dd_hdr)) == NULL)
d94 1
a94 1
		    buf_left(buf) >= MD5_DIGEST_LENGTH + sizeof(struct lsa_hdr);
d97 1
a97 1
			if (buf_add(buf, le->le_lsa, sizeof(struct lsa_hdr)))
d145 1
a145 1
	memcpy(buf_seek(buf, sizeof(struct ospf_hdr), sizeof(dd_hdr)),
d155 1
a155 1
	buf_free(buf);
d159 1
a159 1
	buf_free(buf);
@


1.25
log
@Pass the buffer to send_packet() instead of spliting it up. This removes
some direct access to struct buf internals in the rest of ospfe.
Based on a larger buffer cleanup diff that was OK norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.24 2009/01/08 19:18:17 claudio Exp $ */
d94 2
a95 2
		    buf->wpos + sizeof(struct lsa_hdr) < buf->max -
		    MD5_DIGEST_LENGTH; le = nle) {
@


1.24
log
@Include the neighbor ID in a debug output so that it is clear which router
is sendingf the duplicate entries. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.23 2008/11/24 18:28:02 claudio Exp $ */
d153 1
a153 1
	ret = send_packet(nbr->iface, buf->buf, buf->wpos, &dst);
@


1.23
log
@Initial support for stub areas. The bit still missing is the redistribution
of the default summary net lsa on ABRs but that is comming. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.22 2008/02/11 12:37:37 norby Exp $ */
d190 2
a191 1
			log_debug("recv_db_description: dupe");
@


1.22
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.21 2007/10/11 12:19:31 claudio Exp $ */
d238 3
a246 4

			/* event negotiation done */
			nbr_fsm(nbr, NBR_EVT_NEG_DONE);

@


1.21
log
@Bye bye global ospf options. OSPF options are per area (at least the one
flag that we set). So introduce a area_ospf_options() function that will
return the correct flags for each area. This makes stub area support a lot
easier.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.20 2007/10/11 08:21:29 claudio Exp $ */
d170 1
a170 1
		log_warnx("recv_dd_description: "
d180 1
a180 1
		log_warnx("recv_dd_description: invalid MTU %d sent by "
@


1.20
log
@Do not overload nbr->options with the dd exchange bits. nbr->options is used
by the hello protocol. Instead add a dd_more flag that is used together with
(the renamed) dd_master flag.
Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.19 2006/03/13 09:36:06 claudio Exp $ */
d141 1
a141 1
	dd_hdr.opts = oeconf->options;
@


1.19
log
@The return value of the start/stop timer functions is almost never checked.
Switch them to void functions and check if evtimer_add/del fails -- in which
case we fatal() as there is no useful way to recover in such an event.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.18 2006/03/09 13:34:19 claudio Exp $ */
d48 1
d73 2
a74 1
		nbr->options |= OSPF_DBD_MS | OSPF_DBD_M | OSPF_DBD_I;
d77 8
a84 3
		if (nbr->master) {
			/* master */
			nbr->options |= OSPF_DBD_MS;
d86 2
a87 2
			/* slave */
			nbr->options &= ~OSPF_DBD_MS;
d90 1
a90 6
		if (TAILQ_EMPTY(&nbr->db_sum_list))
			nbr->options &= ~OSPF_DBD_M;
		else
			nbr->options |= OSPF_DBD_M;

		nbr->options &= ~OSPF_DBD_I;
d103 6
a108 9
		if (nbr->master) {
			/* master */
			nbr->options |= OSPF_DBD_MS;
		} else {
			/* slave */
			nbr->options &= ~OSPF_DBD_MS;
		}
		nbr->options &= ~OSPF_DBD_M;
		nbr->options &= ~OSPF_DBD_I;
d110 1
d142 1
a142 1
	dd_hdr.bits = nbr->options;
d188 2
a189 1
	    ntohl(dd_hdr.dd_seq_num) == nbr->dd_seq_num - nbr->master ? 1 : 0) {
d221 1
a221 1
				nbr->master = 0;
d259 1
a259 1
		    !(dd_hdr.bits & OSPF_DBD_MS) == !nbr->master) {
d274 1
a274 1
			if (!nbr->master)
d289 1
a289 1
		if (nbr->master) {
d324 1
a324 1
			if (!nbr->master || !(nbr->options & OSPF_DBD_M))
d394 1
a394 1
	if (nbr->master) {
@


1.18
log
@Mark event callbacks with ARGSUSED to silence lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.17 2005/11/12 18:18:24 deraadt Exp $ */
d396 2
a397 1
		evtimer_add(&nbr->db_tx_timer, &tv);
d401 1
a401 1
int
d407 1
a407 1
		return (0);
d410 2
a411 2

	return (evtimer_add(&nbr->db_tx_timer, &tv));
d414 1
a414 1
int
d418 1
a418 1
		return (0);
d420 2
a421 1
	return (evtimer_del(&nbr->db_tx_timer));
@


1.17
log
@spacing mostly
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.16 2005/11/04 10:30:23 claudio Exp $ */
d366 1
@


1.16
log
@In the super fast start-up case in recv_db_description() make sure the
the 2WAY neighbor event is issued before the interface NBR_CHNG.
Fix some comments while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.15 2005/10/19 21:43:20 claudio Exp $ */
a331 1
	return;
@


1.15
log
@fix some spellings in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.14 2005/10/18 15:39:05 claudio Exp $ */
d203 2
a204 1
		/* evaluate dr and bdr before issuing a 2-Way event */
a205 1
		nbr_fsm(nbr, NBR_EVT_2_WAY_RCVD);
a213 1
		 * I,M,MS is checked here the M only case is a fall-through
d227 1
a227 1
			/* master */
@


1.14
log
@Better warning for non equal MTU in the database phase. Instead of just
whining that the MTU differs tell actually what is expected and what was
sent.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.13 2005/09/17 20:03:35 msf Exp $ */
d311 1
a311 1
		/* forward to RDE and let it decide which LSA's to request */
@


1.13
log
@- add get_rtr_id() based on bgpd's get_bgpid()
- remove rtr_id from struct iface we don't need to keep a copy of this value
  per interface
- replace all references to iface->rtr_id.s_addr with calls to ospfe_rtr_id()

ok claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.12 2005/05/27 05:51:22 norby Exp $ */
d180 3
a182 2
		log_warnx("recv_dd_description: invalid MTU, neighbor ID %s",
		    inet_ntoa(nbr->id));
@


1.12
log
@Virtual link support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.11 2005/05/26 19:54:49 norby Exp $ */
d218 1
a218 1
			    ntohl(nbr->iface->rtr_id.s_addr)) {
@


1.11
log
@Simplify and cleanup passive interface handling.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.10 2005/05/26 19:10:56 norby Exp $ */
d131 2
d134 1
a134 1
		dst.sin_addr = nbr->addr;
a176 1

@


1.10
log
@Remove a lot of unneeded debug output during the database change.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.9 2005/04/22 15:33:00 claudio Exp $ */
a47 3

	if (nbr->iface->passive)
		return (0);
@


1.9
log
@RFC tells that the MTU in the db exchange packet may not be bigger than
the interface MTU but it may be smaller. This makes Philip Olssons
extreme networks summit24 happy as this stupid thing sets the MTU to 0.
testing Philip Olsson, OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.8 2005/04/12 09:47:30 claudio Exp $ */
a48 3
	log_debug("send_db_description: neighbor ID %s, seq_num %x",
	    inet_ntoa(nbr->id), nbr->dd_seq_num);

a74 3
		log_debug("send_db_description: state %s, neighbor ID %s",
		    nbr_state_name(nbr->state), inet_ntoa(nbr->id));

a77 3
		log_debug("send_db_description: state %s, neighbor ID %s",
		    nbr_state_name(nbr->state), inet_ntoa(nbr->id));

a103 3
		log_debug("send_db_description: state %s, neighbor ID %s",
		    nbr_state_name(nbr->state), inet_ntoa(nbr->id));

a169 3
	log_debug("recv_db_description: neighbor ID %s, seq_num %x",
	    inet_ntoa(nbr->id), nbr->dd_seq_num);

a193 1
	log_debug("recv_db_description: seq_num %x", ntohl(dd_hdr.dd_seq_num));
a203 3
		log_debug("recv_db_description: state %s, neighbor ID %s",
		    nbr_state_name(nbr->state), inet_ntoa(nbr->id));

a210 3
		log_debug("recv_db_description: state %s, neighbor ID %s",
		    nbr_state_name(nbr->state), inet_ntoa(nbr->id));

a221 2
				log_debug("recv_db_description: slave, "
				    "neighbor ID %s", inet_ntoa(nbr->id));
a258 3
		log_debug("recv_db_description: state %s, neighbor ID %s",
		    nbr_state_name(nbr->state), inet_ntoa(nbr->id));

a374 2
	log_debug("db_tx_timer: neighbor ID %s", inet_ntoa(nbr->id));

a397 2
		log_debug("db_tx_timer: reschedule neighbor ID %s",
		    inet_ntoa(nbr->id));
a409 2
	log_debug("start_db_tx_timer: neighbor ID %s", inet_ntoa(nbr->id));

a419 2

	log_debug("stop_db_tx_timer: neighbor ID %s", inet_ntoa(nbr->id));
@


1.8
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.7 2005/04/05 13:01:21 claudio Exp $ */
d196 1
a196 1
	if (ntohs(dd_hdr.iface_mtu) != nbr->iface->mtu) {
@


1.7
log
@Use the dynamic buffer API for packet generation and sending.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.6 2005/03/22 22:13:48 norby Exp $ */
d104 1
a104 1
		    buf->wpos + sizeof(struct lsa_hdr) < buf->max - 
@


1.6
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.5 2005/02/10 14:05:48 claudio Exp $ */
d23 2
d44 1
a44 2
	struct db_dscrp_hdr	*dd_hdr;
	struct lsa_hdr		*lsa_hdr;
d46 1
a46 2
	char			*buf;
	char			*ptr;
d55 1
a55 1
	if ((ptr = buf = calloc(1, READ_BUF_SIZE)) == NULL)
d59 2
a60 2
	gen_ospf_hdr(ptr, nbr->iface, PACKET_TYPE_DD);
	ptr += sizeof(struct ospf_hdr);
d62 3
a64 6
	/* database description header */
	dd_hdr = (struct db_dscrp_hdr *)ptr;
	dd_hdr->opts = oeconf->options;
	dd_hdr->dd_seq_num = htonl(nbr->dd_seq_num);

	ptr += sizeof(*dd_hdr);
d102 4
a105 5
		/* build LSA list */
		lsa_hdr = (struct lsa_hdr *)ptr;

		for (le = TAILQ_FIRST(&nbr->db_sum_list); (le != NULL) &&
		    ((ptr - buf) < nbr->iface->mtu - PACKET_HDR); le = nle) {
d107 2
a108 2
			memcpy(ptr, le->le_lsa, sizeof(struct lsa_hdr));
			ptr += sizeof(*lsa_hdr);
d128 1
a128 5
		log_debug("send_db_description: unknown neighbor state, "
		    "neighbor ID %s", inet_ntoa(nbr->id));
		ret = -1;
		goto done;
		break;
d138 1
a138 1
		dd_hdr->iface_mtu = htons(nbr->iface->mtu);
d142 1
a142 1
		dd_hdr->iface_mtu = htons(nbr->iface->mtu);
d148 1
a148 1
		dd_hdr->iface_mtu = 0;
d154 6
a159 1
	dd_hdr->bits = nbr->options;
d162 2
a163 1
	auth_gen(buf, ptr - buf, nbr->iface);
d166 1
a166 4
	if ((ret = send_packet(nbr->iface, buf, (ptr - buf), &dst)) == -1)
		log_warnx("send_db_description: error sending packet on "
		    "interface %s", nbr->iface->name);

d168 1
a168 2
	free(buf);

d170 4
@


1.5
log
@Work around a timing issue in the db exchange phase. The DB description
packets comming from the net are looped through the RDE and may get
delayed because of this. The result is that the neighbor FSM ends in
state FULL instead of LOADING and so the LSDB is not correctly
synchronized. Issue found by norby@@ OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.4 2005/02/09 15:39:22 claudio Exp $ */
d248 1
a248 1
				nbr->master = false;
@


1.4
log
@Once again a round of bugfixes in the db exchange process. This is
one of the worst documented parts of the RFC.
The initial packet sent by the slave may have no flags set. Don't
enforce that the M bit is set but instead check that the I bit and
MS bit are unset.
The master should only issue NBR_EVT_XCHNG_DONE if it has sent at
least one packet with M bit cleared else the slave may get stuck
in state Exchange.
In NBR_STA_LOAD the db_tx_timer() still needs to send db descriptions
out. This will be the last packet sent with the cleared M bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.3 2005/02/02 19:15:07 henning Exp $ */
d266 2
a267 1
			if (len > 0)
d270 1
d342 2
a343 1
		if (len > 0)
d346 1
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d254 1
a254 1
		} else if (dd_hdr.bits == OSPF_DBD_M) {
d350 2
a351 1
			nbr_fsm(nbr, NBR_EVT_XCHNG_DONE);
a407 1
	case NBR_STA_LOAD:
d411 1
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d272 1
a272 1
		
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * Copyright (c) 2004, 2005 Esben Norby <esben.norby@@ericsson.com>
@

