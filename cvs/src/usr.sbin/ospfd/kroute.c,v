head	1.108;
access;
symbols
	OPENBSD_6_2_BASE:1.108
	OPENBSD_6_1:1.107.0.4
	OPENBSD_6_1_BASE:1.107
	OPENBSD_6_0:1.106.0.4
	OPENBSD_6_0_BASE:1.106
	OPENBSD_5_9:1.106.0.2
	OPENBSD_5_9_BASE:1.106
	OPENBSD_5_8:1.102.0.4
	OPENBSD_5_8_BASE:1.102
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.94.0.4
	OPENBSD_5_6_BASE:1.94
	OPENBSD_5_5:1.93.0.4
	OPENBSD_5_5_BASE:1.93
	OPENBSD_5_4:1.92.0.2
	OPENBSD_5_4_BASE:1.92
	OPENBSD_5_3:1.91.0.6
	OPENBSD_5_3_BASE:1.91
	OPENBSD_5_2:1.91.0.4
	OPENBSD_5_2_BASE:1.91
	OPENBSD_5_1_BASE:1.91
	OPENBSD_5_1:1.91.0.2
	OPENBSD_5_0:1.90.0.2
	OPENBSD_5_0_BASE:1.90
	OPENBSD_4_9:1.89.0.2
	OPENBSD_4_9_BASE:1.89
	OPENBSD_4_8:1.87.0.2
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.78.0.2
	OPENBSD_4_7_BASE:1.78
	OPENBSD_4_6:1.71.0.4
	OPENBSD_4_6_BASE:1.71
	OPENBSD_4_5:1.67.0.2
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.59.0.2
	OPENBSD_4_4_BASE:1.59
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.108
date	2017.07.24.11.00.01;	author friehm;	state Exp;
branches;
next	1.107;
commitid	LhKZV4SjfogJNr88;

1.107
date	2016.12.27.09.15.16;	author jca;	state Exp;
branches;
next	1.106;
commitid	uxl52KDjKZIRKB9M;

1.106
date	2015.12.05.12.20.13;	author claudio;	state Exp;
branches;
next	1.105;
commitid	ev1fE7U8gIdVx8OS;

1.105
date	2015.10.26.11.46.25;	author claudio;	state Exp;
branches;
next	1.104;
commitid	yPDLgot4pOlLBPMu;

1.104
date	2015.10.24.16.42.18;	author claudio;	state Exp;
branches;
next	1.103;
commitid	4uDpi5z11u8ssIYP;

1.103
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.102;
commitid	kLBPo9HaQrkEaNW3;

1.102
date	2015.07.20.23.45.39;	author benno;	state Exp;
branches;
next	1.101;
commitid	5hkliGAgtkCCmQz6;

1.101
date	2015.07.19.01.59.32;	author benno;	state Exp;
branches;
next	1.100;
commitid	C7PSAS4g16J65TZI;

1.100
date	2015.07.18.15.57.14;	author mpi;	state Exp;
branches;
next	1.99;
commitid	892Bda7x92IlN8xM;

1.99
date	2015.07.17.20.06.46;	author claudio;	state Exp;
branches;
next	1.98;
commitid	rBayjxs8Vi9ihek0;

1.98
date	2015.02.11.05.57.44;	author claudio;	state Exp;
branches;
next	1.97;
commitid	KGpl02mQCzC2nHQ2;

1.97
date	2015.02.10.08.26.47;	author claudio;	state Exp;
branches;
next	1.96;
commitid	yHicxsWLxcTVUWEb;

1.96
date	2015.02.10.05.24.48;	author claudio;	state Exp;
branches;
next	1.95;
commitid	4XccNzu2mQpqfy01;

1.95
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.94;
commitid	Uu5nFG3wCl0LACBb;

1.94
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.93;
commitid	uXnRK9VvnFZsAqfW;

1.93
date	2013.10.30.17.24.35;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2013.06.01.16.00.21;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2011.09.16.18.24.57;	author sthen;	state Exp;
branches;
next	1.90;

1.90
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.89;

1.89
date	2011.01.12.15.07.46;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2010.10.14.07.35.47;	author claudio;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.14.01.00.32;	author dlg;	state Exp;
branches;
next	1.86;

1.86
date	2010.07.12.14.35.13;	author bluhm;	state Exp;
branches;
next	1.85;

1.85
date	2010.07.09.15.38.28;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.27.05.15.20;	author dlg;	state Exp;
branches;
next	1.83;

1.83
date	2010.06.23.23.34.02;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2010.06.23.04.26.51;	author dlg;	state Exp;
branches;
next	1.81;

1.81
date	2010.05.18.15.19.07;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2010.04.02.23.55.37;	author sthen;	state Exp;
branches;
next	1.79;

1.79
date	2010.04.01.14.02.40;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2010.02.23.10.59.31;	author dlg;	state Exp;
branches;
next	1.77;

1.77
date	2010.02.22.13.28.01;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2010.02.22.10.56.29;	author dlg;	state Exp;
branches;
next	1.75;

1.75
date	2010.02.19.10.37.12;	author dlg;	state Exp;
branches;
next	1.74;

1.74
date	2010.02.19.10.35.52;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2010.02.16.18.27.11;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2009.07.23.16.36.27;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2009.06.05.22.40.24;	author chris;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.05.04.12.52;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.02.20.16.59;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2009.04.26.12.48.06;	author sthen;	state Exp;
branches;
next	1.67;

1.67
date	2009.01.16.20.50.13;	author gollo;	state Exp;
branches;
next	1.66;

1.66
date	2009.01.08.19.27.56;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2009.01.06.22.00.31;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.01.20.40.10;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2008.12.17.14.57.00;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2008.12.12.22.43.17;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2008.11.21.17.10.45;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2008.09.29.09.54.30;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2008.07.24.18.46.59;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2008.06.13.07.05.26;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.09.12.46.45;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2008.05.05.12.55.37;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.17.20.52.42;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.01.08.35.12;	author norby;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.25.11.25.41;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2007.07.23.12.21.35;	author pyr;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.19.16.45.15;	author reyk;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.13.17.16.07;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.12.04.23.47;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.22.14.08.41;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.19.13.01.04;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.12.12.51.37;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2007.03.27.09.43.20;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2007.03.13.17.01.15;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.13.16.48.03;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.25.18.10.47;	author deraadt;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2007.02.24.00.10.45;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.01.12.51.01;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2006.12.13.13.30.07;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.07.19.14.27;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.28.16.36.58;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.17.08.55.31;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.16.15.55.29;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.30.22.06.14;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.27.19.28.20;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.28.15.46.10;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.25.08.01.16;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.18.19.19.18;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.16.11.40.54;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.16.11.38.11;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.08.13.49.07;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.23.22.29.15;	author claudio;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2006.01.12.15.10.02;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.12.15.00.48;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.05.15.53.36;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.14.00.44.40;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.08.08.38.42;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.26.19.22.12;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.24.21.36.40;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.24.21.31.07;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.13.08.29.13;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.16.21.48.21;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.12.09.54.59;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.31.19.32.10;	author norby;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.26.13.35.16;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.26.11.06.49;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.23.20.28.29;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.23.20.15.50;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.23.11.30.21;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.23.11.07.42;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.15.22.03.56;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.07.10.28.14;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.24.16.28.43;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.15.15.39.30;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;

1.25.2.1
date	2006.05.05.13.57.56;	author brad;	state Exp;
branches;
next	;

1.42.2.1
date	2007.04.30.20.45.01;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.108
log
@Unify ROUNDUP macros for parsing route messages.
Use the macro from route(8) / ospf6d(8) since it works also with argument 0.

OK claudio@@
@
text
@/*	$OpenBSD: kroute.c,v 1.107 2016/12/27 09:15:16 jca Exp $ */

/*
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/tree.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "ospfd.h"
#include "log.h"

struct {
	u_int32_t		rtseq;
	pid_t			pid;
	int			fib_sync;
	int			fib_serial;
	int			fd;
	struct event		ev;
	struct event		reload;
	u_int			rdomain;
#define KR_RELOAD_IDLE	0
#define KR_RELOAD_FETCH	1
#define KR_RELOAD_HOLD	2
	int			reload_state;
} kr_state;

struct kroute_node {
	RB_ENTRY(kroute_node)	 entry;
	struct kroute_node	*next;
	struct kroute		 r;
	int			 serial;
};

struct kif_node {
	RB_ENTRY(kif_node)	 entry;
	TAILQ_HEAD(, kif_addr)	 addrs;
	struct kif		 k;
};

void	kr_redist_remove(struct kroute_node *, struct kroute_node *);
int	kr_redist_eval(struct kroute *, struct kroute *);
void	kr_redistribute(struct kroute_node *);
int	kroute_compare(struct kroute_node *, struct kroute_node *);
int	kif_compare(struct kif_node *, struct kif_node *);
int	kr_change_fib(struct kroute_node *, struct kroute *, int, int);
int	kr_delete_fib(struct kroute_node *);

struct kroute_node	*kroute_find(in_addr_t, u_int8_t, u_int8_t);
struct kroute_node	*kroute_matchgw(struct kroute_node *, struct in_addr);
int			 kroute_insert(struct kroute_node *);
int			 kroute_remove(struct kroute_node *);
void			 kroute_clear(void);

struct kif_node		*kif_find(u_short);
struct kif_node		*kif_insert(u_short);
int			 kif_remove(struct kif_node *);
struct kif		*kif_update(u_short, int, struct if_data *,
			    struct sockaddr_dl *);
int			 kif_validate(u_short);

struct kroute_node	*kroute_match(in_addr_t);

int		protect_lo(void);
u_int8_t	prefixlen_classful(in_addr_t);
void		get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
void		if_change(u_short, int, struct if_data *, struct sockaddr_dl *);
void		if_newaddr(u_short, struct sockaddr_in *, struct sockaddr_in *,
		    struct sockaddr_in *);
void		if_deladdr(u_short, struct sockaddr_in *, struct sockaddr_in *,
		    struct sockaddr_in *);
void		if_announce(void *);

int		send_rtmsg(int, int, struct kroute *);
int		dispatch_rtmsg(void);
int		fetchtable(void);
int		fetchifs(u_short);
int		rtmsg_process(char *, size_t);
void		kr_fib_reload_timer(int, short, void *);
void		kr_fib_reload_arm_timer(int);

RB_HEAD(kroute_tree, kroute_node)	krt = RB_INITIALIZER(&krt);
RB_PROTOTYPE(kroute_tree, kroute_node, entry, kroute_compare)
RB_GENERATE(kroute_tree, kroute_node, entry, kroute_compare)

RB_HEAD(kif_tree, kif_node)		kit = RB_INITIALIZER(&kit);
RB_PROTOTYPE(kif_tree, kif_node, entry, kif_compare)
RB_GENERATE(kif_tree, kif_node, entry, kif_compare)

int
kif_init(void)
{
	if (fetchifs(0) == -1)
		return (-1);

	return (0);
}

int
kr_init(int fs, u_int rdomain)
{
	int		opt = 0, rcvbuf, default_rcvbuf;
	socklen_t	optlen;

	kr_state.fib_sync = fs;
	kr_state.rdomain = rdomain;

	if ((kr_state.fd = socket(AF_ROUTE,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK, AF_INET)) == -1) {
		log_warn("kr_init: socket");
		return (-1);
	}

	/* not interested in my own messages */
	if (setsockopt(kr_state.fd, SOL_SOCKET, SO_USELOOPBACK,
	    &opt, sizeof(opt)) == -1)
		log_warn("kr_init: setsockopt");	/* not fatal */

	/* grow receive buffer, don't wanna miss messages */
	optlen = sizeof(default_rcvbuf);
	if (getsockopt(kr_state.fd, SOL_SOCKET, SO_RCVBUF,
	    &default_rcvbuf, &optlen) == -1)
		log_warn("kr_init getsockopt SOL_SOCKET SO_RCVBUF");
	else
		for (rcvbuf = MAX_RTSOCK_BUF;
		    rcvbuf > default_rcvbuf &&
		    setsockopt(kr_state.fd, SOL_SOCKET, SO_RCVBUF,
		    &rcvbuf, sizeof(rcvbuf)) == -1 && errno == ENOBUFS;
		    rcvbuf /= 2)
			;	/* nothing */

	kr_state.pid = getpid();
	kr_state.rtseq = 1;

	if (fetchtable() == -1)
		return (-1);

	if (protect_lo() == -1)
		return (-1);

	event_set(&kr_state.ev, kr_state.fd, EV_READ | EV_PERSIST,
	    kr_dispatch_msg, NULL);
	event_add(&kr_state.ev, NULL);

	kr_state.reload_state = KR_RELOAD_IDLE;
	evtimer_set(&kr_state.reload, kr_fib_reload_timer, NULL);

	return (0);
}

int
kr_change_fib(struct kroute_node *kr, struct kroute *kroute, int krcount,
    int action)
{
	int			 i;
	struct kroute_node	*kn, *nkn;

	if (action == RTM_ADD) {
		/*
		 * First remove all stale multipath routes.
		 * This step must be skipped when the action is RTM_CHANGE
		 * because it is already a single path route that will be
		 * changed.
		 */
		for (kn = kr; kn != NULL; kn = nkn) {
			for (i = 0; i < krcount; i++) {
				if (kn->r.nexthop.s_addr ==
				    kroute[i].nexthop.s_addr)
					break;
			}
			nkn = kn->next;
			if (i == krcount) {
				/* stale route */
				if (kr_delete_fib(kn) == -1)
					log_warnx("kr_delete_fib failed");
				/*
				 * if head element was removed we need to adjust
				 * the head
				 */
				if (kr == kn)
					kr = nkn;
			}
		}
	}

	/*
	 * now add or change the route
	 */
	for (i = 0; i < krcount; i++) {
		/* nexthop within 127/8 -> ignore silently */
		if ((kroute[i].nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
		    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
			continue;

		if (action == RTM_ADD && kr) {
			for (kn = kr; kn != NULL; kn = kn->next) {
				if (kn->r.nexthop.s_addr ==
				    kroute[i].nexthop.s_addr)
					break;
			}

			if (kn != NULL)
				/* nexthop already present, skip it */
				continue;
		} else
			/* modify first entry */
			kn = kr;

		/* send update */
		if (send_rtmsg(kr_state.fd, action, &kroute[i]) == -1)
			return (-1);

		/* create new entry unless we are changing the first entry */
		if (action == RTM_ADD)
			if ((kn = calloc(1, sizeof(*kn))) == NULL)
				fatal(NULL);

		kn->r.prefix.s_addr = kroute[i].prefix.s_addr;
		kn->r.prefixlen = kroute[i].prefixlen;
		kn->r.nexthop.s_addr = kroute[i].nexthop.s_addr;
		kn->r.flags = kroute[i].flags | F_OSPFD_INSERTED;
		kn->r.priority = RTP_OSPF;
		kn->r.ext_tag = kroute[i].ext_tag;
		rtlabel_unref(kn->r.rtlabel);	/* for RTM_CHANGE */
		kn->r.rtlabel = kroute[i].rtlabel;

		if (action == RTM_ADD)
			if (kroute_insert(kn) == -1) {
				log_debug("kr_update_fib: cannot insert %s",
				    inet_ntoa(kn->r.nexthop));
				free(kn);
			}
		action = RTM_ADD;
	}
	return  (0);
}

int
kr_change(struct kroute *kroute, int krcount)
{
	struct kroute_node	*kr;
	int			 action = RTM_ADD;

	kroute->rtlabel = rtlabel_tag2id(kroute->ext_tag);

	kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen, RTP_OSPF);
	if (kr != NULL && kr->next == NULL && krcount == 1)
		/* single path OSPF route */
		action = RTM_CHANGE;

	return (kr_change_fib(kr, kroute, krcount, action));
}

int
kr_delete_fib(struct kroute_node *kr)
{
	if (kr->r.priority != RTP_OSPF)
		log_warn("kr_delete_fib: %s/%d has wrong priority %d",
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen, kr->r.priority);

	if (send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r) == -1)
		return (-1);

	if (kroute_remove(kr) == -1)
		return (-1);

	return (0);
}

int
kr_delete(struct kroute *kroute)
{
	struct kroute_node	*kr, *nkr;

	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen,
	    RTP_OSPF)) == NULL)
		return (0);

	while (kr != NULL) {
		nkr = kr->next;
		if (kr_delete_fib(kr) == -1)
			return (-1);
		kr = nkr;
	}
	return (0);
}

void
kr_shutdown(void)
{
	kr_fib_decouple();
	kroute_clear();
	kif_clear();
}

void
kr_fib_couple(void)
{
	struct kroute_node	*kr;
	struct kroute_node	*kn;

	if (kr_state.fib_sync == 1)	/* already coupled */
		return;

	kr_state.fib_sync = 1;

	RB_FOREACH(kr, kroute_tree, &krt)
		if (kr->r.priority == RTP_OSPF)
			for (kn = kr; kn != NULL; kn = kn->next)
				send_rtmsg(kr_state.fd, RTM_ADD, &kn->r);

	log_info("kernel routing table coupled");
}

void
kr_fib_decouple(void)
{
	struct kroute_node	*kr;
	struct kroute_node	*kn;

	if (kr_state.fib_sync == 0)	/* already decoupled */
		return;

	RB_FOREACH(kr, kroute_tree, &krt)
		if (kr->r.priority == RTP_OSPF)
			for (kn = kr; kn != NULL; kn = kn->next)
				send_rtmsg(kr_state.fd, RTM_DELETE, &kn->r);

	kr_state.fib_sync = 0;

	log_info("kernel routing table decoupled");
}

void
kr_fib_reload_timer(int fd, short event, void *bula)
{
	if (kr_state.reload_state == KR_RELOAD_FETCH) {
		kr_fib_reload();
		kr_state.reload_state = KR_RELOAD_HOLD;
		kr_fib_reload_arm_timer(KR_RELOAD_HOLD_TIMER);
	} else {
		kr_state.reload_state = KR_RELOAD_IDLE;
	}
}

void
kr_fib_reload_arm_timer(int delay)
{
	struct timeval		 tv;

	timerclear(&tv);
	tv.tv_sec = delay / 1000;
	tv.tv_usec = (delay % 1000) * 1000;

	if (evtimer_add(&kr_state.reload, &tv) == -1)
		fatal("add_reload_timer");
}

void
kr_fib_reload()
{
	struct kroute_node	*krn, *kr, *kn;

	log_info("reloading interface list and routing table");

	kr_state.fib_serial++;

	if (fetchifs(0) == -1 || fetchtable() == -1)
		return;

	for (kr = RB_MIN(kroute_tree, &krt); kr != NULL; kr = krn) {
		krn = RB_NEXT(kroute_tree, &krt, kr);

		do {
			kn = kr->next;

			if (kr->serial != kr_state.fib_serial) {
				if (kr->r.priority == RTP_OSPF) {
					kr->serial = kr_state.fib_serial;
					if (send_rtmsg(kr_state.fd,
					    RTM_ADD, &kr->r) != 0)
						break;
				} else
					kroute_remove(kr);
			}

		} while ((kr = kn) != NULL);
	}
}

/* ARGSUSED */
void
kr_dispatch_msg(int fd, short event, void *bula)
{
	/* XXX this is stupid */
	if (dispatch_rtmsg() == -1)
		event_loopexit(NULL);
}

void
kr_show_route(struct imsg *imsg)
{
	struct kroute_node	*kr;
	struct kroute_node	*kn;
	int			 flags;
	struct in_addr		 addr;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(flags)) {
			log_warnx("kr_show_route: wrong imsg len");
			return;
		}
		memcpy(&flags, imsg->data, sizeof(flags));
		RB_FOREACH(kr, kroute_tree, &krt)
			if (!flags || kr->r.flags & flags) {
				kn = kr;
				do {
					main_imsg_compose_ospfe(IMSG_CTL_KROUTE,
					    imsg->hdr.pid,
					    &kn->r, sizeof(kn->r));
				} while ((kn = kn->next) != NULL);
			}
		break;
	case IMSG_CTL_KROUTE_ADDR:
		if (imsg->hdr.len != IMSG_HEADER_SIZE +
		    sizeof(struct in_addr)) {
			log_warnx("kr_show_route: wrong imsg len");
			return;
		}
		memcpy(&addr, imsg->data, sizeof(addr));
		kr = NULL;
		kr = kroute_match(addr.s_addr);
		if (kr != NULL)
			main_imsg_compose_ospfe(IMSG_CTL_KROUTE, imsg->hdr.pid,
			    &kr->r, sizeof(kr->r));
		break;
	default:
		log_debug("kr_show_route: error handling imsg");
		break;
	}

	main_imsg_compose_ospfe(IMSG_CTL_END, imsg->hdr.pid, NULL, 0);
}

void
kr_ifinfo(char *ifname, pid_t pid)
{
	struct kif_node	*kif;

	RB_FOREACH(kif, kif_tree, &kit)
		if (ifname == NULL || !strcmp(ifname, kif->k.ifname)) {
			main_imsg_compose_ospfe(IMSG_CTL_IFINFO,
			    pid, &kif->k, sizeof(kif->k));
		}

	main_imsg_compose_ospfe(IMSG_CTL_END, pid, NULL, 0);
}

void
kr_redist_remove(struct kroute_node *kh, struct kroute_node *kn)
{
	struct kroute	*kr;

	/* was the route redistributed? */
	if ((kn->r.flags & F_REDISTRIBUTED) == 0)
		return;

	/* remove redistributed flag */
	kn->r.flags &= ~F_REDISTRIBUTED;
	kr = &kn->r;

	/* probably inform the RDE (check if no other path is redistributed) */
	for (kn = kh; kn; kn = kn->next)
		if (kn->r.flags & F_REDISTRIBUTED)
			break;

	if (kn == NULL)
		main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, kr,
		    sizeof(struct kroute));
}

int
kr_redist_eval(struct kroute *kr, struct kroute *new_kr)
{
	u_int32_t	 a, metric = 0;

	/* Only non-ospfd routes are considered for redistribution. */
	if (!(kr->flags & F_KERNEL))
		goto dont_redistribute;

	/* Dynamic routes are not redistributable. */
	if (kr->flags & F_DYNAMIC)
		goto dont_redistribute;

	/* interface is not up and running so don't announce */
	if (kr->flags & F_DOWN)
		goto dont_redistribute;

	/*
	 * We consider the loopback net, multicast and experimental addresses
	 * as not redistributable.
	 */
	a = ntohl(kr->prefix.s_addr);
	if (IN_MULTICAST(a) || IN_BADCLASS(a) ||
	    (a >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
		goto dont_redistribute;
	/*
	 * Consider networks with nexthop loopback as not redistributable
	 * unless it is a reject or blackhole route.
	 */
	if (kr->nexthop.s_addr == htonl(INADDR_LOOPBACK) &&
	    !(kr->flags & (F_BLACKHOLE|F_REJECT)))
		goto dont_redistribute;

	/* Should we redistribute this route? */
	if (!ospf_redistribute(kr, &metric))
		goto dont_redistribute;

	/* prefix should be redistributed */
	kr->flags |= F_REDISTRIBUTED;
	/*
	 * only one of all multipath routes can be redistributed so
	 * redistribute the best one.
	 */
	if (new_kr->metric > metric) {
		*new_kr = *kr;
		new_kr->metric = metric;
	}

	return (1);

dont_redistribute:
	/* was the route redistributed? */
	if ((kr->flags & F_REDISTRIBUTED) == 0)
		return (0);

	kr->flags &= ~F_REDISTRIBUTED;
	return (1);
}

void
kr_redistribute(struct kroute_node *kh)
{
	struct kroute_node	*kn;
	struct kroute		 kr;
	int			 redistribute = 0;

	/* only the highest prio route can be redistributed */
	if (kroute_find(kh->r.prefix.s_addr, kh->r.prefixlen, RTP_ANY) != kh)
		return;

	bzero(&kr, sizeof(kr));
	kr.metric = UINT_MAX;
	for (kn = kh; kn; kn = kn->next)
		if (kr_redist_eval(&kn->r, &kr))
			redistribute = 1;

	if (!redistribute)
		return;

	if (kr.flags & F_REDISTRIBUTED) {
		main_imsg_compose_rde(IMSG_NETWORK_ADD, 0, &kr,
		    sizeof(struct kroute));
	} else {
		kr = kh->r;
		main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, &kr,
		    sizeof(struct kroute));
	}
}

void
kr_reload(void)
{
	struct kroute_node	*kr, *kn;
	u_int32_t		 dummy;
	int			 r;

	RB_FOREACH(kr, kroute_tree, &krt) {
		for (kn = kr; kn; kn = kn->next) {
			r = ospf_redistribute(&kn->r, &dummy);
			/*
			 * if it is redistributed, redistribute again metric
			 * may have changed.
			 */
			if ((kn->r.flags & F_REDISTRIBUTED && !r) || r)
				break;
		}
		if (kn) {
			/*
			 * kr_redistribute copes with removes and RDE with
			 * duplicates
			 */
			kr_redistribute(kr);
		}
	}
}

/* rb-tree compare */
int
kroute_compare(struct kroute_node *a, struct kroute_node *b)
{
	if (ntohl(a->r.prefix.s_addr) < ntohl(b->r.prefix.s_addr))
		return (-1);
	if (ntohl(a->r.prefix.s_addr) > ntohl(b->r.prefix.s_addr))
		return (1);
	if (a->r.prefixlen < b->r.prefixlen)
		return (-1);
	if (a->r.prefixlen > b->r.prefixlen)
		return (1);

	/* if the priority is RTP_ANY finish on the first address hit */
	if (a->r.priority == RTP_ANY || b->r.priority == RTP_ANY)
		return (0);
	if (a->r.priority < b->r.priority)
		return (-1);
	if (a->r.priority > b->r.priority)
		return (1);
	return (0);
}

int
kif_compare(struct kif_node *a, struct kif_node *b)
{
	return (b->k.ifindex - a->k.ifindex);
}

/* tree management */
struct kroute_node *
kroute_find(in_addr_t prefix, u_int8_t prefixlen, u_int8_t prio)
{
	struct kroute_node	s;
	struct kroute_node	*kn, *tmp;

	s.r.prefix.s_addr = prefix;
	s.r.prefixlen = prefixlen;
	s.r.priority = prio;

	kn = RB_FIND(kroute_tree, &krt, &s);
	if (kn && prio == RTP_ANY) {
		tmp = RB_PREV(kroute_tree, &krt, kn);
		while (tmp) {
			if (kroute_compare(&s, tmp) == 0)
				kn = tmp;
			else
				break;
			tmp = RB_PREV(kroute_tree, &krt, kn);
		}
	}
	return (kn);
}

struct kroute_node *
kroute_matchgw(struct kroute_node *kr, struct in_addr nh)
{
	in_addr_t	nexthop;

	nexthop = nh.s_addr;

	while (kr) {
		if (kr->r.nexthop.s_addr == nexthop)
			return (kr);
		kr = kr->next;
	}

	return (NULL);
}

int
kroute_insert(struct kroute_node *kr)
{
	struct kroute_node	*krm, *krh;

	kr->serial = kr_state.fib_serial;

	if ((krh = RB_INSERT(kroute_tree, &krt, kr)) != NULL) {
		/*
		 * Multipath route, add at end of list.
		 */
		krm = krh;
		while (krm->next != NULL)
			krm = krm->next;
		krm->next = kr;
		kr->next = NULL; /* to be sure */
	} else
		krh = kr;

	if (!(kr->r.flags & F_KERNEL)) {
		/* don't validate or redistribute ospf route */
		kr->r.flags &= ~F_DOWN;
		return (0);
	}

	if (kif_validate(kr->r.ifindex))
		kr->r.flags &= ~F_DOWN;
	else
		kr->r.flags |= F_DOWN;

	kr_redistribute(krh);
	return (0);
}

int
kroute_remove(struct kroute_node *kr)
{
	struct kroute_node	*krm;

	if ((krm = RB_FIND(kroute_tree, &krt, kr)) == NULL) {
		log_warnx("kroute_remove failed to find %s/%u",
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
		return (-1);
	}

	if (krm == kr) {
		/* head element */
		if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
			log_warnx("kroute_remove failed for %s/%u",
			    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
			return (-1);
		}
		if (kr->next != NULL) {
			if (RB_INSERT(kroute_tree, &krt, kr->next) != NULL) {
				log_warnx("kroute_remove failed to add %s/%u",
				    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
				return (-1);
			}
		}
	} else {
		/* somewhere in the list */
		while (krm->next != kr && krm->next != NULL)
			krm = krm->next;
		if (krm->next == NULL) {
			log_warnx("kroute_remove multipath list corrupted "
			    "for %s/%u", inet_ntoa(kr->r.prefix),
			    kr->r.prefixlen);
			return (-1);
		}
		krm->next = kr->next;
	}

	kr_redist_remove(krm, kr);
	rtlabel_unref(kr->r.rtlabel);

	free(kr);
	return (0);
}

void
kroute_clear(void)
{
	struct kroute_node	*kr;

	while ((kr = RB_MIN(kroute_tree, &krt)) != NULL)
		kroute_remove(kr);
}

struct kif_node *
kif_find(u_short ifindex)
{
	struct kif_node	s;

	bzero(&s, sizeof(s));
	s.k.ifindex = ifindex;

	return (RB_FIND(kif_tree, &kit, &s));
}

struct kif *
kif_findname(char *ifname, struct in_addr addr, struct kif_addr **kap)
{
	struct kif_node	*kif;
	struct kif_addr	*ka;

	RB_FOREACH(kif, kif_tree, &kit)
		if (!strcmp(ifname, kif->k.ifname)) {
			ka = TAILQ_FIRST(&kif->addrs);
			if (addr.s_addr != 0) {
				TAILQ_FOREACH(ka, &kif->addrs, entry) {
					if (addr.s_addr == ka->addr.s_addr)
						break;
				}
			}
			if (kap != NULL)
				*kap = ka;
			return (&kif->k);
		}

	return (NULL);
}

struct kif_node *
kif_insert(u_short ifindex)
{
	struct kif_node	*kif;

	if ((kif = calloc(1, sizeof(struct kif_node))) == NULL)
		return (NULL);

	kif->k.ifindex = ifindex;
	TAILQ_INIT(&kif->addrs);

	if (RB_INSERT(kif_tree, &kit, kif) != NULL)
		fatalx("kif_insert: RB_INSERT");

	return (kif);
}

int
kif_remove(struct kif_node *kif)
{
	struct kif_addr	*ka;

	if (RB_REMOVE(kif_tree, &kit, kif) == NULL) {
		log_warnx("RB_REMOVE(kif_tree, &kit, kif)");
		return (-1);
	}

	while ((ka = TAILQ_FIRST(&kif->addrs)) != NULL) {
		TAILQ_REMOVE(&kif->addrs, ka, entry);
		free(ka);
	}
	free(kif);
	return (0);
}

void
kif_clear(void)
{
	struct kif_node	*kif;

	while ((kif = RB_MIN(kif_tree, &kit)) != NULL)
		kif_remove(kif);
}

struct kif *
kif_update(u_short ifindex, int flags, struct if_data *ifd,
    struct sockaddr_dl *sdl)
{
	struct kif_node		*kif;

	if ((kif = kif_find(ifindex)) == NULL) {
		if ((kif = kif_insert(ifindex)) == NULL)
			return (NULL);
		kif->k.nh_reachable = (flags & IFF_UP) &&
		    LINK_STATE_IS_UP(ifd->ifi_link_state);
	}

	kif->k.flags = flags;
	kif->k.link_state = ifd->ifi_link_state;
	kif->k.if_type = ifd->ifi_type;
	kif->k.baudrate = ifd->ifi_baudrate;
	kif->k.mtu = ifd->ifi_mtu;
	kif->k.rdomain = ifd->ifi_rdomain;

	if (sdl && sdl->sdl_family == AF_LINK) {
		if (sdl->sdl_nlen >= sizeof(kif->k.ifname))
			memcpy(kif->k.ifname, sdl->sdl_data,
			    sizeof(kif->k.ifname) - 1);
		else if (sdl->sdl_nlen > 0)
			memcpy(kif->k.ifname, sdl->sdl_data,
			    sdl->sdl_nlen);
		/* string already terminated via calloc() */
	}

	return (&kif->k);
}

int
kif_validate(u_short ifindex)
{
	struct kif_node		*kif;

	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("interface with index %u not found", ifindex);
		return (1);
	}

	return (kif->k.nh_reachable);
}

struct kroute_node *
kroute_match(in_addr_t key)
{
	int			 i;
	struct kroute_node	*kr;

	/* we will never match the default route */
	for (i = 32; i > 0; i--)
		if ((kr = kroute_find(key & prefixlen2mask(i), i,
		    RTP_ANY)) != NULL)
			return (kr);

	/* if we don't have a match yet, try to find a default route */
	if ((kr = kroute_find(0, 0, RTP_ANY)) != NULL)
			return (kr);

	return (NULL);
}

/* misc */
int
protect_lo(void)
{
	struct kroute_node	*kr;

	/* special protection for 127/8 */
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
		log_warn("protect_lo");
		return (-1);
	}
	kr->r.prefix.s_addr = htonl(INADDR_LOOPBACK & IN_CLASSA_NET);
	kr->r.prefixlen = 8;
	kr->r.flags = F_KERNEL|F_CONNECTED;

	if (RB_INSERT(kroute_tree, &krt, kr) != NULL)
		free(kr);	/* kernel route already there, no problem */

	return (0);
}

u_int8_t
prefixlen_classful(in_addr_t ina)
{
	/* it hurt to write this. */

	if (ina >= 0xf0000000U)		/* class E */
		return (32);
	else if (ina >= 0xe0000000U)	/* class D */
		return (4);
	else if (ina >= 0xc0000000U)	/* class C */
		return (24);
	else if (ina >= 0x80000000U)	/* class B */
		return (16);
	else				/* class A */
		return (8);
}

u_int8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

in_addr_t
prefixlen2mask(u_int8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	return (htonl(0xffffffff << (32 - prefixlen)));
}

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		} else
			rti_info[i] = NULL;
	}
}

void
if_change(u_short ifindex, int flags, struct if_data *ifd,
    struct sockaddr_dl *sdl)
{
	struct kroute_node	*kr, *tkr;
	struct kif		*kif;
	u_int8_t		 reachable;

	if ((kif = kif_update(ifindex, flags, ifd, sdl)) == NULL) {
		log_warn("if_change:  kif_update(%u)", ifindex);
		return;
	}

	/* notify ospfe about interface link state */
	main_imsg_compose_ospfe(IMSG_IFINFO, 0, kif, sizeof(struct kif));

	reachable = (kif->flags & IFF_UP) &&
	    LINK_STATE_IS_UP(kif->link_state);

	if (reachable == kif->nh_reachable)
		return;		/* nothing changed wrt nexthop validity */

	kif->nh_reachable = reachable;

	/* update redistribute list */
	RB_FOREACH(kr, kroute_tree, &krt) {
		for (tkr = kr; tkr != NULL; tkr = tkr->next) {
			if (tkr->r.ifindex == ifindex) {
				if (reachable)
					tkr->r.flags &= ~F_DOWN;
				else
					tkr->r.flags |= F_DOWN;

			}
		}
		kr_redistribute(kr);
	}
}

void
if_newaddr(u_short ifindex, struct sockaddr_in *ifa, struct sockaddr_in *mask,
    struct sockaddr_in *brd)
{
	struct kif_node *kif;
	struct kif_addr *ka;

	if (ifa == NULL || ifa->sin_family != AF_INET)
		return;
	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("if_newaddr: corresponding if %d not found", ifindex);
		return;
	}
	if ((ka = calloc(1, sizeof(struct kif_addr))) == NULL)
		fatal("if_newaddr");
	ka->addr = ifa->sin_addr;
	if (mask)
		ka->mask = mask->sin_addr;
	else
		ka->mask.s_addr = INADDR_NONE;
	if (brd)
		ka->dstbrd = brd->sin_addr;
	else
		ka->dstbrd.s_addr = INADDR_NONE;

	TAILQ_INSERT_TAIL(&kif->addrs, ka, entry);
}

void
if_deladdr(u_short ifindex, struct sockaddr_in *ifa, struct sockaddr_in *mask,
    struct sockaddr_in *brd)
{
	struct kif_node *kif;
	struct kif_addr *ka, *nka;
	struct ifaddrdel ifc;

	if (ifa == NULL || ifa->sin_family != AF_INET)
		return;
	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("if_deladdr: corresponding if %d not found", ifindex);
		return;
	}

	for (ka = TAILQ_FIRST(&kif->addrs); ka != NULL; ka = nka) {
		nka = TAILQ_NEXT(ka, entry);

		if (ka->addr.s_addr == ifa->sin_addr.s_addr) {
			TAILQ_REMOVE(&kif->addrs, ka, entry);
			ifc.addr = ifa->sin_addr;
			ifc.ifindex = ifindex;
			main_imsg_compose_ospfe(IMSG_IFADDRDEL, 0, &ifc,
			    sizeof(ifc));
			free(ka);
			return;
		}
	}
}

void
if_announce(void *msg)
{
	struct if_announcemsghdr	*ifan;
	struct kif_node			*kif;

	ifan = msg;

	switch (ifan->ifan_what) {
	case IFAN_ARRIVAL:
		kif = kif_insert(ifan->ifan_index);
		strlcpy(kif->k.ifname, ifan->ifan_name, sizeof(kif->k.ifname));
		break;
	case IFAN_DEPARTURE:
		kif = kif_find(ifan->ifan_index);
		kif_remove(kif);
		break;
	}
}

/* rtsock */
int
send_rtmsg(int fd, int action, struct kroute *kroute)
{
	struct iovec		iov[5];
	struct rt_msghdr	hdr;
	struct sockaddr_in	prefix;
	struct sockaddr_in	nexthop;
	struct sockaddr_in	mask;
	struct sockaddr_rtlabel	sa_rl;
	int			iovcnt = 0;
	const char		*label;

	if (kr_state.fib_sync == 0)
		return (0);

	/* initialize header */
	bzero(&hdr, sizeof(hdr));
	hdr.rtm_version = RTM_VERSION;
	hdr.rtm_type = action;
	hdr.rtm_priority = RTP_OSPF;
	hdr.rtm_tableid = kr_state.rdomain;	/* rtableid */
	if (action == RTM_CHANGE)
		hdr.rtm_fmask = RTF_REJECT|RTF_BLACKHOLE;
	else
		hdr.rtm_flags = RTF_MPATH;
	hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	hdr.rtm_msglen = sizeof(hdr);
	/* adjust iovec */
	iov[iovcnt].iov_base = &hdr;
	iov[iovcnt++].iov_len = sizeof(hdr);

	bzero(&prefix, sizeof(prefix));
	prefix.sin_len = sizeof(prefix);
	prefix.sin_family = AF_INET;
	prefix.sin_addr.s_addr = kroute->prefix.s_addr;
	/* adjust header */
	hdr.rtm_addrs |= RTA_DST;
	hdr.rtm_msglen += sizeof(prefix);
	/* adjust iovec */
	iov[iovcnt].iov_base = &prefix;
	iov[iovcnt++].iov_len = sizeof(prefix);

	if (kroute->nexthop.s_addr != 0) {
		bzero(&nexthop, sizeof(nexthop));
		nexthop.sin_len = sizeof(nexthop);
		nexthop.sin_family = AF_INET;
		nexthop.sin_addr.s_addr = kroute->nexthop.s_addr;
		/* adjust header */
		hdr.rtm_flags |= RTF_GATEWAY;
		hdr.rtm_addrs |= RTA_GATEWAY;
		hdr.rtm_msglen += sizeof(nexthop);
		/* adjust iovec */
		iov[iovcnt].iov_base = &nexthop;
		iov[iovcnt++].iov_len = sizeof(nexthop);
	}

	bzero(&mask, sizeof(mask));
	mask.sin_len = sizeof(mask);
	mask.sin_family = AF_INET;
	mask.sin_addr.s_addr = prefixlen2mask(kroute->prefixlen);
	/* adjust header */
	hdr.rtm_addrs |= RTA_NETMASK;
	hdr.rtm_msglen += sizeof(mask);
	/* adjust iovec */
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = sizeof(mask);

	if (kroute->rtlabel != 0) {
		sa_rl.sr_len = sizeof(sa_rl);
		sa_rl.sr_family = AF_UNSPEC;
		label = rtlabel_id2name(kroute->rtlabel);
		if (strlcpy(sa_rl.sr_label, label,
		    sizeof(sa_rl.sr_label)) >= sizeof(sa_rl.sr_label)) {
			log_warnx("send_rtmsg: invalid rtlabel");
			return (-1);
		}
		/* adjust header */
		hdr.rtm_addrs |= RTA_LABEL;
		hdr.rtm_msglen += sizeof(sa_rl);
		/* adjust iovec */
		iov[iovcnt].iov_base = &sa_rl;
		iov[iovcnt++].iov_len = sizeof(sa_rl);
	}

retry:
	if (writev(fd, iov, iovcnt) == -1) {
		if (errno == ESRCH) {
			if (hdr.rtm_type == RTM_CHANGE) {
				hdr.rtm_type = RTM_ADD;
				goto retry;
			} else if (hdr.rtm_type == RTM_DELETE) {
				log_info("route %s/%u vanished before delete",
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen);
				return (0);
			}
		}
		log_warn("send_rtmsg: action %u, prefix %s/%u", hdr.rtm_type,
		    inet_ntoa(kroute->prefix), kroute->prefixlen);
		return (0);
	}

	return (0);
}

int
fetchtable(void)
{
	size_t			 len;
	int			 mib[7];
	char			*buf;
	int			 rv;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
	mib[6] = kr_state.rdomain;	/* rtableid */

	if (sysctl(mib, 7, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchtable");
		return (-1);
	}
	if (sysctl(mib, 7, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	rv = rtmsg_process(buf, len);
	free(buf);

	return (rv);
}

int
fetchifs(u_short ifindex)
{
	size_t			 len;
	int			 mib[6];
	char			*buf;
	int			 rv;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_IFLIST;
	mib[5] = ifindex;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchif");
		return (-1);
	}
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	rv = rtmsg_process(buf, len);
	free(buf);

	return (rv);
}

int
dispatch_rtmsg(void)
{
	char			 buf[RT_BUF_SIZE];
	ssize_t			 n;

	if ((n = read(kr_state.fd, &buf, sizeof(buf))) == -1) {
		if (errno == EAGAIN || errno == EINTR)
			return (0);
		log_warn("dispatch_rtmsg: read error");
		return (-1);
	}

	if (n == 0) {
		log_warnx("routing socket closed");
		return (-1);
	}

	return (rtmsg_process(buf, n));
}

int
rtmsg_process(char *buf, size_t len)
{
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct ifa_msghdr	*ifam;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct sockaddr_rtlabel	*label;
	struct kroute_node	*kr, *okr;
	struct in_addr		 prefix, nexthop;
	u_int8_t		 prefixlen, prio;
	int			 flags, mpath;
	u_short			 ifindex = 0;
	int			 rv, delay;

	size_t			 offset;
	char			*next;

	for (offset = 0; offset < len; offset += rtm->rtm_msglen) {
		next = buf + offset;
		rtm = (struct rt_msghdr *)next;
		if (len < offset + sizeof(u_short) ||
		    len < offset + rtm->rtm_msglen)
			fatalx("rtmsg_process: partial rtm in buffer");
		if (rtm->rtm_version != RTM_VERSION)
			continue;

		prefix.s_addr = 0;
		prefixlen = 0;
		nexthop.s_addr = 0;
		mpath = 0;
		prio = 0;
		flags = F_KERNEL;

		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		switch (rtm->rtm_type) {
		case RTM_ADD:
		case RTM_GET:
		case RTM_CHANGE:
		case RTM_DELETE:
			if (rtm->rtm_errno)		/* failed attempts... */
				continue;

			if (rtm->rtm_tableid != kr_state.rdomain)
				continue;

			if (rtm->rtm_type == RTM_GET &&
			    rtm->rtm_pid != kr_state.pid)
				continue;

			if ((sa = rti_info[RTAX_DST]) == NULL)
				continue;

			/* Skip ARP/ND cache and broadcast routes. */
			if (rtm->rtm_flags & (RTF_LLINFO|RTF_BROADCAST))
				continue;

			if (rtm->rtm_flags & RTF_MPATH)
				mpath = 1;
			prio = rtm->rtm_priority;
			flags = (prio == RTP_OSPF) ?
			    F_OSPFD_INSERTED : F_KERNEL;

			switch (sa->sa_family) {
			case AF_INET:
				prefix.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				sa_in = (struct sockaddr_in *)
				    rti_info[RTAX_NETMASK];
				if (sa_in != NULL) {
					if (sa_in->sin_len != 0)
						prefixlen = mask2prefixlen(
						    sa_in->sin_addr.s_addr);
				} else if (rtm->rtm_flags & RTF_HOST)
					prefixlen = 32;
				else
					prefixlen =
					    prefixlen_classful(prefix.s_addr);
				if (rtm->rtm_flags & RTF_STATIC)
					flags |= F_STATIC;
				if (rtm->rtm_flags & RTF_BLACKHOLE)
					flags |= F_BLACKHOLE;
				if (rtm->rtm_flags & RTF_REJECT)
					flags |= F_REJECT;
				if (rtm->rtm_flags & RTF_DYNAMIC)
					flags |= F_DYNAMIC;
				break;
			default:
				continue;
			}

			ifindex = rtm->rtm_index;
			if ((sa = rti_info[RTAX_GATEWAY]) != NULL) {
				switch (sa->sa_family) {
				case AF_INET:
					if (rtm->rtm_flags & RTF_CONNECTED) {
						flags |= F_CONNECTED;
						break;
					}

					nexthop.s_addr = ((struct
					    sockaddr_in *)sa)->sin_addr.s_addr;
					break;
				case AF_LINK:
					/*
					 * Traditional BSD connected routes have
					 * a gateway of type AF_LINK.
					 */
					flags |= F_CONNECTED;
					break;
				}
			}
		}

		switch (rtm->rtm_type) {
		case RTM_ADD:
		case RTM_GET:
		case RTM_CHANGE:
			if (nexthop.s_addr == 0 && !(flags & F_CONNECTED)) {
				log_warnx("no nexthop for %s/%u",
				    inet_ntoa(prefix), prefixlen);
				continue;
			}

			if ((okr = kroute_find(prefix.s_addr, prefixlen, prio))
			    != NULL) {
				/* get the correct route */
				kr = okr;
				if ((mpath || prio == RTP_OSPF) &&
				    (kr = kroute_matchgw(okr, nexthop)) ==
				    NULL) {
					log_warnx("dispatch_rtmsg "
					    "mpath route not found");
					/* add routes we missed out earlier */
					goto add;
				}

				if (kr->r.flags & F_REDISTRIBUTED)
					flags |= F_REDISTRIBUTED;
				kr->r.nexthop.s_addr = nexthop.s_addr;
				kr->r.flags = flags;
				kr->r.ifindex = ifindex;

				rtlabel_unref(kr->r.rtlabel);
				kr->r.rtlabel = 0;
				kr->r.ext_tag = 0;
				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL) {
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);
					kr->r.ext_tag =
					    rtlabel_id2tag(kr->r.rtlabel);
				}

				if (kif_validate(kr->r.ifindex))
					kr->r.flags &= ~F_DOWN;
				else
					kr->r.flags |= F_DOWN;

				/* just readd, the RDE will care */
				kr->serial = kr_state.fib_serial;
				kr_redistribute(okr);
			} else {
add:
				if ((kr = calloc(1,
				    sizeof(struct kroute_node))) == NULL) {
					log_warn("dispatch calloc");
					return (-1);
				}

				kr->r.prefix.s_addr = prefix.s_addr;
				kr->r.prefixlen = prefixlen;
				kr->r.nexthop.s_addr = nexthop.s_addr;
				kr->r.flags = flags;
				kr->r.ifindex = ifindex;
				kr->r.priority = prio;

				if (rtm->rtm_priority == RTP_OSPF) {
					log_warnx("alien OSPF route %s/%d",
					    inet_ntoa(prefix), prefixlen);
					rv = send_rtmsg(kr_state.fd,
					    RTM_DELETE, &kr->r);
					free(kr);
					if (rv == -1)
						return (-1);
				} else {
					if ((label = (struct sockaddr_rtlabel *)
					    rti_info[RTAX_LABEL]) != NULL) {
						kr->r.rtlabel =
						    rtlabel_name2id(
						    label->sr_label);
						kr->r.ext_tag =
						    rtlabel_id2tag(
						    kr->r.rtlabel);
					}

					kroute_insert(kr);
				}
			}
			break;
		case RTM_DELETE:
			if ((kr = kroute_find(prefix.s_addr, prefixlen, prio))
			    == NULL)
				continue;
			if (!(kr->r.flags & F_KERNEL))
				continue;
			/* get the correct route */
			okr = kr;
			if (mpath &&
			    (kr = kroute_matchgw(kr, nexthop)) == NULL) {
				log_warnx("dispatch_rtmsg "
				    "mpath route not found");
				return (-1);
			}
			if (kroute_remove(kr) == -1)
				return (-1);
			break;
		case RTM_IFINFO:
			memcpy(&ifm, next, sizeof(ifm));
			if_change(ifm.ifm_index, ifm.ifm_flags, &ifm.ifm_data,
			    (struct sockaddr_dl *)rti_info[RTAX_IFP]);
			break;
		case RTM_NEWADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;

			if_newaddr(ifam->ifam_index,
			    (struct sockaddr_in *)rti_info[RTAX_IFA],
			    (struct sockaddr_in *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in *)rti_info[RTAX_BRD]);
			break;
		case RTM_DELADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;

			if_deladdr(ifam->ifam_index,
			    (struct sockaddr_in *)rti_info[RTAX_IFA],
			    (struct sockaddr_in *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in *)rti_info[RTAX_BRD]);
			break;
		case RTM_IFANNOUNCE:
			if_announce(next);
			break;
		case RTM_DESYNC:
			/*
			 * We lost some routing packets. Schedule a reload
			 * of the kernel route/interface information.
			 */
			if (kr_state.reload_state == KR_RELOAD_IDLE) {
				delay = KR_RELOAD_TIMER;
				log_info("desync; scheduling fib reload");
			} else {
				delay = KR_RELOAD_HOLD_TIMER;
				log_debug("desync during KR_RELOAD_%s",
				    kr_state.reload_state ==
				    KR_RELOAD_FETCH ? "FETCH" : "HOLD");
			}
			kr_state.reload_state = KR_RELOAD_FETCH;
			kr_fib_reload_arm_timer(delay);
			break;
		default:
			/* ignore for now */
			break;
		}
	}

	return (offset);
}
@


1.107
log
@struct rroute has been removed, rename variables.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.106 2015/12/05 12:20:13 claudio Exp $ */
d986 2
a987 2
#define	ROUNDUP(a)	\
    (((a) & (sizeof(long) - 1)) ? (1 + ((a) | (sizeof(long) - 1))) : (a))
@


1.106
log
@Pledge ospfd SE ("stdio inet mcast") and RDE ("stdio") move some code
around to make it possible. Parent can't be pledged at the moment because
of carp ioctl (carp demote). Putting it in so that people can test.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.105 2015/10/26 11:46:25 claudio Exp $ */
d493 1
a493 1
	struct kroute	*rr;
d501 1
a501 1
	rr = &kn->r;
d509 1
a509 1
		main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, rr,
d514 1
a514 1
kr_redist_eval(struct kroute *kr, struct kroute *rr)
d556 3
a558 3
	if (rr->metric > metric) {
		*rr = *kr;
		rr->metric = metric;
d576 1
a576 1
	struct kroute		 rr;
d583 2
a584 2
	bzero(&rr, sizeof(rr));
	rr.metric = UINT_MAX;
d586 1
a586 1
		if (kr_redist_eval(&kn->r, &rr))
d592 2
a593 2
	if (rr.flags & F_REDISTRIBUTED) {
		main_imsg_compose_rde(IMSG_NETWORK_ADD, 0, &rr,
d596 2
a597 2
		rr = kh->r;
		main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, &rr,
@


1.105
log
@Kernel got fixed we no longer need to check if rtm_pid is 0 to filter out
route messages that are not from us.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.104 2015/10/24 16:42:18 claudio Exp $ */
a87 1
void			 kif_clear(void);
d112 1
a112 1
RB_HEAD(kroute_tree, kroute_node)	krt;
d116 1
a116 1
RB_HEAD(kif_tree, kif_node)		kit;
a122 5
	RB_INIT(&kit);
	/* init also krt tree so that we can call kr_shutdown() */
	RB_INIT(&krt);
	kr_state.fib_sync = 0;	/* decoupled */

d883 1
@


1.104
log
@Filter our RTM_GET messages which are not from us.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.103 2015/09/27 17:31:50 stsp Exp $ */
d1374 1
a1374 2
			    rtm->rtm_pid != kr_state.pid &&
			    rtm->rtm_pid != 0)
@


1.103
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.102 2015/07/20 23:45:39 benno Exp $ */
d1371 5
@


1.102
log
@Fix a segfault at startup when if_change() ist called before
imsg_init() exposed by the second part of this diff which makes
carp(4) interfaces be recognized to be in "backup" mode on start-up.

Problem analyzed and fix provided by Johan Ymerson, thanks!

ok claudio@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.101 2015/07/19 01:59:32 benno Exp $ */
d886 1
a886 1
	kif->k.media_type = ifd->ifi_type;
@


1.101
log
@revert previous

    Properly handle carp(4) interfaces in "backup" mode on start-up.

    Problem analyzed and fix provided by Johan Ymerson, thanks!

    ok claudio@@, benno@@

it breaks on systems without carp because iev_ospfe is not initiallized
at the time kif_init() is called in main.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.99 2015/07/17 20:06:46 claudio Exp $ */
d1022 3
a1031 3

	/* notify ospfe about interface link state */
	main_imsg_compose_ospfe(IMSG_IFINFO, 0, kif, sizeof(struct kif));
@


1.100
log
@Properly handle carp(4) interfaces in "backup" mode on start-up.

Problem analyzed and fix provided by Johan Ymerson, thanks!

ok claudio@@, benno@@
@
text
@a1021 3
	/* notify ospfe about interface link state */
	main_imsg_compose_ospfe(IMSG_IFINFO, 0, kif, sizeof(struct kif));

d1029 3
@


1.99
log
@Do similar handling of connected routes and filtering of llinfo and broadcast.
With this the ospfd fib and the kernel routing table are better in sync.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.98 2015/02/11 05:57:44 claudio Exp $ */
d1022 3
a1031 3

	/* notify ospfe about interface link state */
	main_imsg_compose_ospfe(IMSG_IFINFO, 0, kif, sizeof(struct kif));
@


1.98
log
@Use sizeof(u_short) in the first check since there are RT messages that
are less then sizeof(*rtm) bytes long (e.g. interface announcements).
Found the hard way by phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.97 2015/02/10 08:26:47 claudio Exp $ */
d1376 2
a1377 1
			if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
d1418 5
d1427 4
@


1.97
log
@Forgot the EAGAIN or EINTR check on read.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.96 2015/02/10 05:24:48 claudio Exp $ */
d1346 1
a1346 1
		if (len < offset + sizeof(*rtm) ||
@


1.96
log
@Convert ospfd over to SOCK_CLOEXEC | SOCK_NONBLOCK and make the route
socket non-blocking. Introduce the same trigger for partial rt msgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.95 2015/01/16 06:40:19 deraadt Exp $ */
d1310 2
@


1.95
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.94 2014/06/23 03:46:17 guenther Exp $ */
d109 1
a109 1
int		rtmsg_process(char *, int);
d144 2
a145 1
	if ((kr_state.fd = socket(AF_ROUTE, SOCK_RAW, AF_INET)) == -1) {
d1323 1
a1323 1
rtmsg_process(char *buf, int len)
d1338 1
a1338 1
	int			 offset;
d1344 3
@


1.94
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.93 2013/10/30 17:24:35 deraadt Exp $ */
a19 1
#include <sys/param.h>
d38 1
@


1.93
log
@another simple %i to %d conversion for obviousness
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.92 2013/06/01 16:00:21 claudio Exp $ */
d1240 1
a1240 1
	mib[1] = AF_ROUTE;
d1276 1
a1276 1
	mib[1] = AF_ROUTE;
@


1.92
log
@Minor cleanup, do not set values to 0 twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.91 2011/09/16 18:24:57 sthen Exp $ */
d1057 1
a1057 1
		log_warnx("if_newaddr: corresponding if %i not found", ifindex);
d1086 1
a1086 1
		log_warnx("if_deladdr: corresponding if %i not found", ifindex);
@


1.91
log
@Rather than reloading kernel routes immediately when an RTM_DESYNC is seen,
set (or extend) a timer and only reload when this expires. Avoids repeatedly
dumping full kernel routes (thus generating more load) when the machine has
problems keeping up with messages on the route socket. (if you see lots of
repeated "reloading interface list and routing table" in ospfd logs, this
will help).

Suggestions/ok claudio@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.90 2011/07/04 04:34:14 claudio Exp $ */
a1347 1
		flags = F_KERNEL;
d1351 1
a1360 6
			prefix.s_addr = 0;
			prefixlen = 0;
			nexthop.s_addr = 0;
			mpath = 0;
			prio = 0;

d1438 2
a1439 1
					log_warnx("mpath route not found");
d1517 2
a1518 2
				log_warnx("dispatch_rtmsg mpath route"
				    " not found");
@


1.90
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.89 2011/01/12 15:07:46 claudio Exp $ */
d50 1
d52 4
d110 2
d180 3
d370 26
a395 1
kr_fib_reload(void)
a1209 1

d1335 1
a1335 1
	int			 rv;
d1561 2
a1562 2
			 * We lost some routing packets. Force a reload of
			 * the kernel route/interface information.
d1564 11
a1574 1
			kr_fib_reload();
@


1.89
log
@Kill struct rroute and move the metric to struct kroute. This
disturbed me for a long time and makes upcomming work a bit easier.
OK sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.88 2010/10/14 07:35:47 claudio Exp $ */
d845 1
a845 3
		    (LINK_STATE_IS_UP(ifd->ifi_link_state) ||
		    (ifd->ifi_link_state == LINK_STATE_UNKNOWN &&
		    ifd->ifi_type != IFT_CARP));
d987 1
a987 3
	    (LINK_STATE_IS_UP(kif->link_state) ||
	    (kif->link_state == LINK_STATE_UNKNOWN &&
	    kif->media_type != IFT_CARP));
@


1.88
log
@kr_redistribute() needs to be called with the head node of a multipath
chain. Fix kroute_insert() and rtmsg_process() to correctly do this.
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.87 2010/07/14 01:00:32 dlg Exp $ */
d55 1
a56 1
	struct kroute_node	*next;
d67 1
a67 1
int	kr_redist_eval(struct kroute *, struct rroute *);
a377 1

d463 1
a463 1
	struct rroute	 rr;
d471 1
a471 2
	rr.kr = kn->r;
	rr.metric = DEFAULT_REDIST_METRIC;	/* some dummy value */
d479 2
a480 2
		main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, &rr,
		    sizeof(struct rroute));
d484 1
a484 1
kr_redist_eval(struct kroute *kr, struct rroute *rr)
d527 1
a527 1
		rr->kr = *kr;
d530 1
d546 1
a546 1
	struct rroute		 rr;
d562 1
a562 1
	if (rr.kr.flags & F_REDISTRIBUTED) {
d564 1
a564 1
		    sizeof(struct rroute));
d566 1
a566 2
		rr.metric = DEFAULT_REDIST_METRIC;	/* some dummy value */
		rr.kr = kh->r;
d568 1
a568 1
		    sizeof(struct rroute));
@


1.87
log
@handle RTM_DESYNC. if the kernel says we're out of sync with the kernel
routing table and interface list, do a reload of the kernel state.

ive been running this in production for 2 or 3 weeks.
tested by sthen@@
ok sthen@@ claudio@@ deraadt@@
code written by andrew sallaway at the univeristy of queensland.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.86 2010/07/12 14:35:13 bluhm Exp $ */
d674 1
a674 1
	struct kroute_node	*krm;
d678 1
a678 1
	if ((krm = RB_INSERT(kroute_tree, &krt, kr)) != NULL) {
d682 1
d688 1
a688 1
		krm = kr;
d701 1
a701 1
	kr_redistribute(krm);
d1445 1
a1445 1
				kr_redistribute(kr);
@


1.86
log
@Merge duplicate log messages into one log_warn().
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.85 2010/07/09 15:38:28 claudio Exp $ */
d364 2
d1529 7
@


1.85
log
@ospfd is a AF_INET only routing daemon so limit the routing socket to that
af. This is possible since this filtering no longer blocks RTM_IFINFO.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.84 2010/06/27 05:15:20 dlg Exp $ */
d1181 1
a1181 2
		switch (errno) {
		case ESRCH:
a1189 6
			} else {
				log_warnx("send_rtmsg: action %u, "
				    "prefix %s/%u: %s", hdr.rtm_type,
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen, strerror(errno));
				return (0);
a1190 6
			break;
		default:
			log_warnx("send_rtmsg: action %u, prefix %s/%u: %s",
			    hdr.rtm_type, inet_ntoa(kroute->prefix),
			    kroute->prefixlen, strerror(errno));
			return (0);
d1192 3
@


1.84
log
@fix rtmsg_process to return on an error during processing rather than
continue. fix kr_dispatch_msg so it acts when rtmsg_process fails.

from andrew sallaway based on discussion with claudio@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.82 2010/06/23 04:26:51 dlg Exp $ */
d137 1
a137 1
	if ((kr_state.fd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1) {
@


1.83
log
@127/8 is INADDR_LOOPBACK & IN_CLASSA_NET the kroute code does not
automagicaly mask the addresses. While there kill a #ifdef that no
longer makes sense since it is the least problem for portable versions.
@
text
@d395 2
a396 1
	dispatch_rtmsg();
d1458 1
a1458 2
					rv = -1;
					break;
d1475 1
a1475 1
						break;
@


1.82
log
@fetchifs and fetchtable return -1 on error, not !0. in fact, they return
the number of bytes they processed from the kernel on success, so testing
against 0 meant that the fib reload code always dropped out early.

found by andrew sallaway
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.81 2010/05/18 15:19:07 claudio Exp $ */
d910 1
a910 1
	kr->r.prefix.s_addr = htonl(INADDR_LOOPBACK);
a1356 1
#ifdef RTF_MPATH
a1358 1
#endif
@


1.81
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.80 2010/04/02 23:55:37 sthen Exp $ */
d366 1
a366 1
	if (fetchifs(0) != 0 || fetchtable() != 0)
@


1.80
log
@The rtm_errno check which was moved in the last commit should only
be done for rtmsgs (which have an rtm_errno) and not ifmsgs (which have
part of an if_data struct in that location). Fixes problems finding
interface addresses at startup. ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.79 2010/04/01 14:02:40 claudio Exp $ */
d644 1
a644 1
			else 
a666 1

@


1.79
log
@Minor cleanup figured out while syncing kroute with snmpd's.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.78 2010/02/23 10:59:31 dlg Exp $ */
a1331 3
		if (rtm->rtm_errno)		/* failed attempts... */
			continue;

d1345 3
@


1.78
log
@fetchtable and the kroute dispatch handlers both parse the same messages
in slightly different ways. this unifies these handlers and cuts
fetchtable over to using the generic handler.

help from claudio@@ and sthen@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.77 2010/02/22 13:28:01 dlg Exp $ */
a1212 1
	char			*buf;
d1215 2
a1216 2

	int			 rv = 0;
d1332 6
a1348 3
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

a1357 2
			if (rtm->rtm_errno)		/* failed attempts... */
				continue;
a1512 2
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(ifm.ifm_addrs, sa, rti_info);
a1520 2
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);
a1531 2
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);
@


1.77
log
@dedup some code a bit. rather than have the same code in fetchifs and
dispatch_rtmsg, factor the message handling out. both fetchifs and
dispatch_rtmsg get a buffer full of messages and then run it through a
parser. now they get their buffers and pass it to rtmsg_process.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.76 2010/02/22 10:56:29 dlg Exp $ */
d1213 1
a1215 11
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct sockaddr_rtlabel	*label;
	struct kroute_node	*kr, *okr;

	struct in_addr		 prefix, nexthop;
	u_int8_t		 prefixlen, prio;
	int			 flags, mpath;
	u_short			 ifindex = 0;
d1241 2
a1242 86
	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;

		prefix.s_addr = 0;
		prefixlen = 0;
		nexthop.s_addr = 0;
		mpath = 0;
		prio = 0;

		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		if ((sa = rti_info[RTAX_DST]) == NULL)
			continue;

		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
			continue;

#ifdef RTF_MPATH
		if (rtm->rtm_flags & RTF_MPATH)
			mpath = 1;
#endif
		prio = rtm->rtm_priority;
		flags = (prio == RTP_OSPF) ? F_OSPFD_INSERTED : F_KERNEL;

		switch (sa->sa_family) {
		case AF_INET:
			prefix.s_addr =
			    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
			sa_in = (struct sockaddr_in *)
			    rti_info[RTAX_NETMASK];
			if (sa_in != NULL) {
				if (sa_in->sin_len != 0)
					prefixlen = mask2prefixlen(
					    sa_in->sin_addr.s_addr);
			} else if (rtm->rtm_flags & RTF_HOST)
				prefixlen = 32;
			else
				prefixlen =
				    prefixlen_classful(prefix.s_addr);
			if (rtm->rtm_flags & RTF_STATIC)
				flags |= F_STATIC;
			if (rtm->rtm_flags & RTF_BLACKHOLE)
				flags |= F_BLACKHOLE;
			if (rtm->rtm_flags & RTF_REJECT)
				flags |= F_REJECT;
			if (rtm->rtm_flags & RTF_DYNAMIC)
				flags |= F_DYNAMIC;
			break;
		default:
			continue;
		}

		ifindex = rtm->rtm_index;
		if ((sa = rti_info[RTAX_GATEWAY]) != NULL) {
			switch (sa->sa_family) {
			case AF_INET:
				nexthop.s_addr = ((struct
				    sockaddr_in *)sa)->sin_addr.s_addr;
				break;
			case AF_LINK:
				flags |= F_CONNECTED;
				break;
			}
		}

		if (nexthop.s_addr == 0 && !(flags & F_CONNECTED)) {
			log_warnx("fetchtable no nexthop for %s/%u",
			    inet_ntoa(prefix), prefixlen);
			continue;
		}

		if ((okr = kroute_find(prefix.s_addr, prefixlen, prio))
		    != NULL) {
			/* get the correct route */
			kr = okr;
			if ((mpath || prio == RTP_OSPF) &&
			    (kr = kroute_matchgw(okr, nexthop)) == NULL) {
				log_warnx("fetchtable mpath route"
				    " not found");
				/* add routes we missed out earlier */
				goto add;
			}
a1243 63
			if (kr->r.flags & F_REDISTRIBUTED)
				flags |= F_REDISTRIBUTED;
			kr->r.nexthop.s_addr = nexthop.s_addr;
			kr->r.flags = flags;
			kr->r.ifindex = ifindex;

			rtlabel_unref(kr->r.rtlabel);
			kr->r.rtlabel = 0;
			kr->r.ext_tag = 0;
			if ((label = (struct sockaddr_rtlabel *)
			    rti_info[RTAX_LABEL]) != NULL) {
				kr->r.rtlabel =
				    rtlabel_name2id(label->sr_label);
				kr->r.ext_tag =
				    rtlabel_id2tag(kr->r.rtlabel);
			}

			if (kif_validate(kr->r.ifindex))
				kr->r.flags &= ~F_DOWN;
			else
				kr->r.flags |= F_DOWN;

			/* just readd, the RDE will care */
			kr->serial = kr_state.fib_serial;
			kr_redistribute(kr);
		} else {
add:
			if ((kr = calloc(1,
			    sizeof(struct kroute_node))) == NULL) {
				log_warn("fetchtable calloc");
				rv = -1;
				break;
			}

			kr->r.prefix.s_addr = prefix.s_addr;
			kr->r.prefixlen = prefixlen;
			kr->r.nexthop.s_addr = nexthop.s_addr;
			kr->r.flags = flags;
			kr->r.ifindex = ifindex;
			kr->r.priority = prio;

			if (rtm->rtm_priority == RTP_OSPF) {
				log_warnx("alien OSPF route %s/%d",
				    inet_ntoa(prefix), prefixlen);
				rv = send_rtmsg(kr_state.fd,
				    RTM_DELETE, &kr->r);
				free(kr);
				if (rv == -1)
					break;
			} else {
				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL) {
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);
					kr->r.ext_tag =
					    rtlabel_id2tag(kr->r.rtlabel);
				}

				kroute_insert(kr);
			}
		}
	}
	free(buf);
d1315 1
d1333 11
a1343 2
		if (rtm->rtm_type == RTM_ADD || rtm->rtm_type == RTM_CHANGE ||
		    rtm->rtm_type == RTM_DELETE) {
d1350 1
a1350 1
			if (rtm->rtm_pid == kr_state.pid) /* caused by us */
d1353 1
a1353 1
			if (rtm->rtm_errno)		/* failed attempts... */
d1356 1
a1356 1
			if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
a1357 1

d1363 2
d1410 1
d1413 1
a1413 1
				log_warnx("dispatch_rtmsg no nexthop for %s/%u",
a1419 3
				/* just add new multipath routes */
				if (mpath && rtm->rtm_type == RTM_ADD)
					goto add;
d1422 4
a1425 4
				if (mpath && (kr = kroute_matchgw(okr,
				    nexthop)) == NULL) {
					log_warnx("dispatch_rtmsg mpath route"
					    " not found");
d1453 2
a1454 2
				okr->serial = kr_state.fib_serial;
				kr_redistribute(okr);
d1459 3
a1461 2
					log_warn("dispatch_rtmsg");
					return (-1);
d1463 1
d1471 20
a1490 6
				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL) {
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);
					kr->r.ext_tag =
					    rtlabel_id2tag(kr->r.rtlabel);
a1491 2

				kroute_insert(kr);
@


1.76
log
@remove the original fetchtable code and replace it with the new
refetchtable.

tested by me and sthen@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.75 2010/02/19 10:37:12 dlg Exp $ */
d104 1
d1409 2
a1410 5
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct ifa_msghdr	*ifam;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
d1433 2
a1434 20
	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		switch (rtm->rtm_type) {
		case RTM_IFINFO:
			memcpy(&ifm, next, sizeof(ifm));
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(ifm.ifm_addrs, sa, rti_info);
			if_change(ifm.ifm_index, ifm.ifm_flags, &ifm.ifm_data,
			    (struct sockaddr_dl *)rti_info[RTAX_IFP]);
			break;
		case RTM_NEWADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);
d1436 1
a1436 9
			if_newaddr(ifam->ifam_index,
			    (struct sockaddr_in *)rti_info[RTAX_IFA],
			    (struct sockaddr_in *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in *)rti_info[RTAX_BRD]);
			break;
		}
	}
	free(buf);
	return (0);
d1444 17
a1460 1
	char			*next, *lim;
d1473 2
a1474 4
	if ((n = read(kr_state.fd, &buf, sizeof(buf))) == -1) {
		log_warn("dispatch_rtmsg: read error");
		return (-1);
	}
d1476 2
a1477 7
	if (n == 0) {
		log_warnx("routing socket closed");
		return (-1);
	}

	lim = buf + n;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
d1686 2
a1687 1
	return (0);
@


1.75
log
@oops, remove dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.74 2010/02/19 10:35:52 dlg Exp $ */
a102 1
int		refetchtable(void);
d365 1
a365 1
	if (fetchifs(0) != 0 || refetchtable() != 0)
a1218 117
	struct kroute_node	*kr;

	mib[0] = CTL_NET;
	mib[1] = AF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
	mib[6] = kr_state.rdomain;	/* rtableid */

	if (sysctl(mib, 7, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchtable");
		return (-1);
	}
	if (sysctl(mib, 7, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		if ((sa = rti_info[RTAX_DST]) == NULL)
			continue;

		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
			continue;

		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("fetchtable");
			free(buf);
			return (-1);
		}

		kr->r.flags = F_KERNEL;
		kr->r.priority = rtm->rtm_priority;

		switch (sa->sa_family) {
		case AF_INET:
			kr->r.prefix.s_addr =
			    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
			sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
			if (rtm->rtm_flags & RTF_STATIC)
				kr->r.flags |= F_STATIC;
			if (rtm->rtm_flags & RTF_BLACKHOLE)
				kr->r.flags |= F_BLACKHOLE;
			if (rtm->rtm_flags & RTF_REJECT)
				kr->r.flags |= F_REJECT;
			if (rtm->rtm_flags & RTF_DYNAMIC)
				kr->r.flags |= F_DYNAMIC;
			if (sa_in != NULL) {
				if (sa_in->sin_len == 0)
					break;
				kr->r.prefixlen =
				    mask2prefixlen(sa_in->sin_addr.s_addr);
			} else if (rtm->rtm_flags & RTF_HOST)
				kr->r.prefixlen = 32;
			else
				kr->r.prefixlen =
				    prefixlen_classful(kr->r.prefix.s_addr);
			break;
		default:
			free(kr);
			continue;
		}

		kr->r.ifindex = rtm->rtm_index;
		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
			case AF_INET:
				kr->r.nexthop.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				break;
			case AF_LINK:
				kr->r.flags |= F_CONNECTED;
				break;
			}

		if (rtm->rtm_priority == RTP_OSPF)  {
			send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);
			free(kr);
		} else {
			if ((label = (struct sockaddr_rtlabel *)
			    rti_info[RTAX_LABEL]) != NULL) {
				kr->r.rtlabel =
				    rtlabel_name2id(label->sr_label);
				kr->r.ext_tag =
				    rtlabel_id2tag(kr->r.rtlabel);
			}
			kroute_insert(kr);
		}

	}
	free(buf);
	return (0);
}

int
refetchtable(void)
{
	size_t			 len;
	int			 mib[7];
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct sockaddr_rtlabel	*label;
d1320 1
a1320 1
			log_warnx("refetchtable no nexthop for %s/%u",
d1331 1
a1331 1
				log_warnx("refetchtable mpath route"
d1366 1
a1366 1
				log_warn("refetchtable calloc");
@


1.74
log
@implement ospfctl fib reload.

this tells the daemon to resync the kernels list of interfaces and routes
with the daemons list. this is very useful if the routing socket overflows
and you want to sync things up again.

lots and lots of help from claudio@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.72 2009/07/23 16:36:27 claudio Exp $ */
a72 1
int	kroute_sync(struct kroute_node *);
a356 17
}

int
kroute_sync(struct kroute_node *kn)
{
	int rv = 0;

	if (kn->serial == kr_state.fib_serial)
		return (0);

	if (kn->r.priority == RTP_OSPF) {
		kn->serial = kr_state.fib_serial;
		rv = send_rtmsg(kr_state.fd, RTM_ADD, &kn->r);
	} else
		kroute_remove(kn);

	return (rv);
@


1.73
log
@Pick up RTM_DELADDR and issue an internal IFADDRDEL message to the ospfe to
inform about the interface address change. If this is an active interface
it will be downed. A ospfctl reload is needed to fetch the new/changed IP
if one got set. OK dlg@@, sthen@@
@
text
@d47 1
d57 1
d73 1
d104 1
d360 48
d692 2
d1346 194
d1756 1
@


1.72
log
@Spelling and comment fixes by stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.71 2009/06/05 22:40:24 chris Exp $ */
d94 2
d1008 30
d1567 13
@


1.71
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.70 2009/06/05 04:12:52 claudio Exp $ */
d486 1
a486 1
	 * only on of all multipath routes can be redistributed so
d640 1
a640 2
		 * Multipath route, add at end of list and clone the
		 * ospfd inserted flag.
@


1.70
log
@Preliminary rdomain support, all hacked up by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.69 2009/06/02 20:16:59 claudio Exp $ */
d1182 1
a1182 1
		sa = (struct sockaddr *)(rtm + 1);
d1367 1
a1367 1
			sa = (struct sockaddr *)(rtm + 1);
@


1.69
log
@Track reject and blackhole routes and allow them to be redistributed even
though they point to the loopback. Mainly used for redistribute default since
on default free routers we need to have a fake route now.
After discussion with Tonnerre Lombard, idea OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.68 2009/04/26 12:48:06 sthen Exp $ */
d49 1
d124 1
a124 1
kr_init(int fs)
d130 1
d1047 1
d1161 1
a1161 1
	mib[6] = 0;	/* rtableid */
d1370 1
a1370 1
			if (rtm->rtm_tableid != 0)
@


1.68
log
@comment typos; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.67 2009/01/16 20:50:13 gollo Exp $ */
d470 2
a471 1
	 * Consider networks with nexthop loopback as not redistributable.
d473 2
a474 1
	if (kr->nexthop.s_addr == htonl(INADDR_LOOPBACK))
d1204 4
d1402 4
@


1.67
log
@fix last update

OK claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.66 2009/01/08 19:27:56 claudio Exp $ */
d475 1
a475 1
	/* Should we redistrubute this route? */
@


1.66
log
@Fix use after free of kr. Happend when the first loop removed the head
element without updating the kr pointer which was later on used again.
Found by david@@. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.65 2009/01/06 22:00:31 claudio Exp $ */
d190 1
a190 1
			if (i == krcount)
d194 7
a200 6
			/*
			 * if head element was removed we need to adjust
			 * the head
			 */
			if (kr == kn)
				kr = nkn;
@


1.65
log
@Remove workaround added in rev 1.63. The real issue has been found and
fixed and the bandaid is no longer needed. See rev. 1.26 of sys/net/radix.c
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.64 2009/01/01 20:40:10 claudio Exp $ */
d194 6
@


1.64
log
@Move initialisation of krt into kif_init so that it is possible to call
kr_shutdown() after kif_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.63 2008/12/17 14:57:00 claudio Exp $ */
a1018 1
	struct kroute_node	*rn;
a1028 5
		return (0);

	/* XXX workaround for bug with CLONING routes */
	rn = kroute_find(kroute->prefix.s_addr, kroute->prefixlen, RTP_ANY);
	if (rn && rn->r.priority < RTP_STATIC)
@


1.63
log
@Add a workaround for some crazyness that happens if a cloning route has a
low priority gateway route below itself plus a carp interface on the same
network. The result is that some arp entries can't be added.
This is a bandaid that will give me time to figure out the real bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.62 2008/12/12 22:43:17 claudio Exp $ */
d112 3
a154 2

	RB_INIT(&krt);
@


1.62
log
@Make the kroute code routing priority aware. This solves a few issues and
makes to code simpler. While the routing table is somewhat simpler the
redistribution code does not allow a much more radical approach. With some
additional help of Mr. Kernel and his rtsock it should be possible to rip
even more code out of kroute.c.
Tested and OK sthen@@, gollo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.61 2008/11/21 17:10:45 claudio Exp $ */
d1018 1
d1029 5
@


1.61
log
@Kill some old debug messages that are no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.60 2008/09/29 09:54:30 claudio Exp $ */
d71 1
a71 1
struct kroute_node	*kroute_find(in_addr_t, u_int8_t);
d232 1
d256 4
a259 26
	kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen);

	if (kr != NULL) {
		if (kr->r.flags & F_KERNEL) {
			/* a non-ospf route already exists. not a problem */
			if (!(kr->r.flags & F_BGPD_INSERTED)) {
				do {
					kr->r.flags |= F_OSPFD_INSERTED;
					kr = kr->next;
				} while (kr);
				return (0);
			}
			/*
			 * XXX as long as there is no multipath support in
			 * bgpd this is safe else we end up in a bad situation.
			 */
			/*
			 * ospf route has higher pref
			 * - reset flags to the ospf ones
			 * - use RTM_CHANGE
			 * - zero out ifindex (this is no longer relevant)
			 */
			action = RTM_CHANGE;
		} else if (kr->next == NULL)	/* single path OSPF route */
			action = RTM_CHANGE;
	}
d267 3
a269 8
	if (!(kr->r.flags & F_OSPFD_INSERTED))
		return (0);

	if (kr->r.flags & F_KERNEL) {
		/* remove F_OSPFD_INSERTED flag, route still exists in kernel */
		kr->r.flags &= ~F_OSPFD_INSERTED;
		return (0);
	}
d285 2
a286 2
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen)) ==
	    NULL)
d318 2
a319 2
		if (!(kr->r.flags & F_KERNEL))
			for (kn = kr; kn != NULL; kn = kn->next) {
a320 1
			}
d334 3
a336 3
	RB_FOREACH(kr, kroute_tree, &krt) {
		if (!(kr->r.flags & F_KERNEL))
			for (kn = kr; kn != NULL; kn = kn->next) {
a337 2
			}
	}
d348 1
d499 4
d562 8
d581 1
a581 1
kroute_find(in_addr_t prefix, u_int8_t prefixlen)
d584 1
d588 1
d590 12
a601 1
	return (RB_FIND(kroute_tree, &krt, &s));
a630 1
		kr->r.flags |= krm->r.flags & F_OSPFD_INSERTED;
d840 2
a841 1
		if ((kr = kroute_find(key & prefixlen2mask(i), i)) != NULL)
d845 1
a845 1
	if ((kr = kroute_find(0, 0)) != NULL)
a1033 1
	hdr.rtm_flags = RTF_PROTO2|RTF_MPATH;
d1035 4
a1038 2
	if (action == RTM_CHANGE)	/* force PROTO2 reset the other flags */
		hdr.rtm_fmask = RTF_PROTO2|RTF_PROTO1|RTF_REJECT|RTF_BLACKHOLE;
d1185 1
a1195 2
			if (rtm->rtm_flags & RTF_PROTO1)
				kr->r.flags |= F_BGPD_INSERTED;
d1224 1
a1224 1
		if (rtm->rtm_flags & RTF_PROTO2)  {
d1321 1
a1321 1
	u_int8_t		 prefixlen;
d1346 1
d1369 2
a1389 2
				if (rtm->rtm_flags & RTF_PROTO1)
					flags |= F_BGPD_INSERTED;
d1418 2
a1419 2
			if ((okr = kroute_find(prefix.s_addr, prefixlen)) !=
			    NULL) {
a1432 7
				/*
				 * ospf route overridden by kernel. Preference
				 * of the route is not checked because this is
				 * forced -- most probably by a user.
				 */
				if (kr->r.flags & F_OSPFD_INSERTED)
					flags |= F_OSPFD_INSERTED;
d1469 1
d1483 2
a1484 2
			if ((kr = kroute_find(prefix.s_addr, prefixlen)) ==
			    NULL)
a1495 8
			/*
			 * last route is getting removed request the
			 * ospf route from the RDE to insert instead
			 */
			if (okr == kr && kr->next == NULL &&
			    kr->r.flags & F_OSPFD_INSERTED)
				main_imsg_compose_rde(IMSG_KROUTE_GET, 0,
				    &kr->r, sizeof(struct kroute));
@


1.60
log
@Refactor code that handles the kroute interfaces and make it possible to
learn new interfaces during runtime. This should solve the issue with
reloads failing when interfaces where created during runtime.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.59 2008/07/24 18:46:59 claudio Exp $ */
a192 3
			log_debug("kr_update_fib: before: %s%s",
			    inet_ntoa(kn->r.nexthop),
			    i == krcount ? " (deleted)" : "");
a210 4

			log_debug("kr_update_fib: after : %s%s",
			     inet_ntoa(kroute[i].nexthop),
			     kn == NULL ? " (added)" : "");
@


1.59
log
@Use memcpy() and memcmp() like everywhere else in ospfd. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.58 2008/06/13 07:05:26 claudio Exp $ */
d90 1
a90 1
void		if_change(u_short, int, struct if_data *);
d802 1
a802 1
	if ((kif = kif_find(ifindex)) == NULL)
d805 5
d936 2
a937 1
if_change(u_short ifindex, int flags, struct if_data *ifd)
d943 1
a943 1
	if ((kif = kif_update(ifindex, flags, ifd, NULL)) == NULL) {
a1261 1
	struct kif		*kif = NULL;
d1295 2
a1296 11

			if ((kif = kif_update(ifm.ifm_index,
			    ifm.ifm_flags, &ifm.ifm_data,
			    (struct sockaddr_dl *)rti_info[RTAX_IFP])) == NULL)
				fatal("fetchifs");

			kif->nh_reachable = (kif->flags & IFF_UP) &&
			    (LINK_STATE_IS_UP(ifm.ifm_data.ifi_link_state) ||
			    (ifm.ifm_data.ifi_link_state ==
			    LINK_STATE_UNKNOWN &&
			    ifm.ifm_data.ifi_type != IFT_CARP));
d1524 4
a1527 2
			if_change(ifm.ifm_index, ifm.ifm_flags,
			    &ifm.ifm_data);
@


1.58
log
@Simplify ROUNDUP() macro, it does not need the additional size argument.
That will be sizeof(long) no matter what.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.57 2008/05/09 12:46:45 henning Exp $ */
d1287 1
a1287 1
			bcopy(rtm, &ifm, sizeof ifm);
@


1.57
log
@insert/delete routes w/ prio RTP_OSPF
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.56 2008/05/05 12:55:37 claudio Exp $ */
d912 2
a913 2
#define	ROUNDUP(a, size)	\
    (((a) & ((size) - 1)) ? (1 + ((a) | ((size) - 1))) : (a))
d924 1
a924 1
			    ROUNDUP(sa->sa_len, sizeof(long)));
@


1.56
log
@Use rtm_hdrlen instead of the static header length. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.55 2007/10/17 20:52:42 claudio Exp $ */
d1039 1
@


1.55
log
@From ripd: Add missing RTM_VERSION checks
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.54 2007/10/01 08:35:12 norby Exp $ */
d1287 1
a1287 1
			sa = (struct sockaddr *)(next + sizeof(ifm));
@


1.54
log
@fix alot of whitespace problems...
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.53 2007/09/25 11:25:41 claudio Exp $ */
d1169 2
d1351 2
@


1.53
log
@Last missing piece in the equal cost multipath support for ospfd.
Send all possible nexthops to the parent process and correctly sync
the RIB, FIB and kernel routing table. Based on initial work by pyr@@.
OK pyr@@ norby@@
PS: don't forget that you need to enable multipath support via a sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.52 2007/07/23 12:21:35 pyr Exp $ */
d91 1
a91 1
void		if_newaddr(u_short, struct sockaddr_in *, struct sockaddr_in *, 
d682 1
a682 1
	       	if (kr->next != NULL) {
d971 1
a971 1
if_newaddr(u_short ifindex, struct sockaddr_in *ifa, struct sockaddr_in *mask, 
d973 1
a973 1
{   
d976 1
a976 1
		     
d980 2
a981 1
		log_warnx("if_newaddr: corresponding if %i not found", ifindex);		return;
d1510 1
a1510 1
			/* 
@


1.52
log
@when multipath routes exist, display them in ospfctl sh fib output.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.51 2007/06/19 16:45:15 reyk Exp $ */
d68 2
d169 87
a255 1
kr_change(struct kroute *kroute)
d262 5
a266 5
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen)) !=
	    NULL) {
		if (!(kr->r.flags & F_KERNEL))
			action = RTM_CHANGE;
		else {	/* a non-ospf route already exists. not a problem */
d285 2
a286 6
			kr->r.flags = kroute->flags | F_OSPFD_INSERTED;
			kr->r.ifindex = 0;
			rtlabel_unref(kr->r.rtlabel);
			kr->r.ext_tag = kroute->ext_tag;
			kr->r.rtlabel = kroute->rtlabel;
		}
d289 7
a295 3
	/* nexthop within 127/8 -> ignore silently */
	if ((kroute->nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
	    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
d298 3
a300 5
	/*
	 * Ingnore updates that did not change the route.
	 * Currently only the nexthop can change.
	 */
	if (kr && kr->r.nexthop.s_addr == kroute->nexthop.s_addr)
d302 1
d304 1
a304 1
	if (send_rtmsg(kr_state.fd, action, kroute) == -1)
d307 2
a308 16
	if (action == RTM_ADD) {
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("kr_change");
			return (-1);
		}
		kr->r.prefix.s_addr = kroute->prefix.s_addr;
		kr->r.prefixlen = kroute->prefixlen;
		kr->r.nexthop.s_addr = kroute->nexthop.s_addr;
		kr->r.flags = kroute->flags | F_OSPFD_INSERTED;
		kr->r.ext_tag = kroute->ext_tag;
		kr->r.rtlabel = kroute->rtlabel;

		if (kroute_insert(kr) == -1)
			free(kr);
	} else
		kr->r.nexthop.s_addr = kroute->nexthop.s_addr;
d316 1
a316 1
	struct kroute_node	*kr;
d322 5
a326 10
	if (!(kr->r.flags & F_OSPFD_INSERTED))
		return (0);

	if (kr->r.flags & F_KERNEL) {
		/* remove F_OSPFD_INSERTED flag, route still exists in kernel */
		do {
			kr->r.flags &= ~F_OSPFD_INSERTED;
			kr = kr->next;
		} while (kr);
		return (0);
a327 7

	if (send_rtmsg(kr_state.fd, RTM_DELETE, kroute) == -1)
		return (-1);

	if (kroute_remove(kr) == -1)
		return (-1);

d343 1
d352 3
a354 1
			send_rtmsg(kr_state.fd, RTM_ADD, &kr->r);
d363 1
d368 1
a368 1
	RB_FOREACH(kr, kroute_tree, &krt)
d370 4
a373 1
			send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);
d1037 1
a1037 1
	hdr.rtm_flags = RTF_PROTO2;
@


1.51
log
@add support for mapping route labels to AS-external route tags.

manpage bits from jmc@@
ok norby@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.50 2007/06/13 17:16:07 claudio Exp $ */
d323 1
d336 6
a341 2
				main_imsg_compose_ospfe(IMSG_CTL_KROUTE,
				    imsg->hdr.pid, &kr->r, sizeof(kr->r));
@


1.50
log
@Ingnore updates that did not change the route. This enhances the signal to
nois ratio on the routing socket. OK norby@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.49 2007/06/12 04:23:47 claudio Exp $ */
d172 2
d200 2
a201 1
			kr->r.rtlabel = 0;
d229 2
d948 1
a948 1
	struct iovec		iov[4];
d953 1
d955 1
d1009 18
d1156 1
a1156 1
			    rti_info[RTAX_LABEL]) != NULL)
d1159 3
d1382 1
d1384 1
a1384 1
				    rti_info[RTAX_LABEL]) != NULL)
d1387 3
d1412 1
a1412 1
				    rti_info[RTAX_LABEL]) != NULL)
d1415 3
@


1.49
log
@When removeing as-ext LSA initialise the metric to some sane default else
the ospfd on the other side is dropping the packets because the sanity check
fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.48 2007/05/22 14:08:41 claudio Exp $ */
d205 7
@


1.48
log
@Rework the way how ospfd fetches and tracks interfaces. Try to merge the
code which is very similar and especially include RTM_NEWADDR in
dispatch_rtmsg(). With this newly created interfaces will no longer cause
config reload problems.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.47 2007/04/19 13:01:04 claudio Exp $ */
d374 1
a374 1
	rr.metric = 0;
d462 1
@


1.47
log
@Use iovecs to write routing messages to the socket instead of a static
structure. This gives greater flexibility and solves an upcoming problem
with multipath routes. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.46 2007/04/12 12:51:37 claudio Exp $ */
d75 2
a76 2
struct kif_node		*kif_find(int);
int			 kif_insert(struct kif_node *);
d79 3
a81 1
int			 kif_validate(int);
d89 2
d96 1
a96 1
int		fetchifs(int);
d633 1
a633 1
kif_find(int ifindex)
d666 2
a667 2
int
kif_insert(struct kif_node *kif)
d669 10
a678 5
	if (RB_INSERT(kif_tree, &kit, kif) != NULL) {
		log_warnx("RB_INSERT(kif_tree, &kit, kif)");
		free(kif);
		return (-1);
	}
d680 1
a680 1
	return (0);
d710 29
d740 1
a740 1
kif_validate(int ifindex)
a846 1
	struct kif_node		*kif;
d848 1
d851 2
a852 2
	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("interface with index %u not found", ifindex);
d856 4
a859 4
	kif->k.flags = flags;
	kif->k.link_state = ifd->ifi_link_state;
	kif->k.media_type = ifd->ifi_type;
	kif->k.baudrate = ifd->ifi_baudrate;
d861 1
a861 4
	if ((reachable = (flags & IFF_UP) &&
	    (LINK_STATE_IS_UP(ifd->ifi_link_state) ||
	    (ifd->ifi_link_state == LINK_STATE_UNKNOWN &&
	    ifd->ifi_type != IFT_CARP))) == kif->k.nh_reachable)
d864 1
a864 1
	kif->k.nh_reachable = reachable;
d867 1
a867 1
	main_imsg_compose_ospfe(IMSG_IFINFO, 0, &kif->k, sizeof(kif->k));
d882 27
a908 1
			
d921 1
a921 6
		if ((kif = calloc(1, sizeof(struct kif_node))) == NULL) {
			log_warn("if_announce");
			return;
		}

		kif->k.ifindex = ifan->ifan_index;
a922 1
		kif_insert(kif);
d1135 1
a1135 1
fetchifs(int ifindex)
d1141 1
a1141 1
	struct if_msghdr	*ifmp, ifm;
d1143 1
a1143 2
	struct kif_node		*kif = NULL;
	struct kif_addr		*kaddr;
a1144 2
	struct sockaddr_dl	*sdl;
	struct sockaddr_in	*sain;
d1174 1
a1174 2
			ifmp = (struct if_msghdr *)rtm;
			bcopy(ifmp, &ifm, sizeof ifm);
d1178 4
a1181 6
			if ((kif = calloc(1, sizeof(struct kif_node))) ==
			    NULL) {
				log_warn("fetchifs");
				free(buf);
				return (-1);
			}
d1183 1
a1183 7
			kif->k.ifindex = ifm.ifm_index;
			kif->k.flags = ifm.ifm_flags;
			kif->k.link_state = ifm.ifm_data.ifi_link_state;
			kif->k.media_type = ifm.ifm_data.ifi_type;
			kif->k.baudrate = ifm.ifm_data.ifi_baudrate;
			kif->k.mtu = ifm.ifm_data.ifi_mtu;
			kif->k.nh_reachable = (kif->k.flags & IFF_UP) &&
a1187 14
			TAILQ_INIT(&kif->addrs);
			if ((sa = rti_info[RTAX_IFP]) != NULL &&
			    sa->sa_family == AF_LINK) {
				sdl = (struct sockaddr_dl *)sa;
				if (sdl->sdl_nlen >= sizeof(kif->k.ifname))
					memcpy(kif->k.ifname, sdl->sdl_data,
					    sizeof(kif->k.ifname) - 1);
				else if (sdl->sdl_nlen > 0)
					memcpy(kif->k.ifname, sdl->sdl_data,
					    sdl->sdl_nlen);
				/* string already terminated via calloc() */
			}

			kif_insert(kif);
d1191 2
a1192 4
			if (kif && ifam->ifam_index != kif->k.ifindex)
				fatalx("fetchifs: bad interface table");
			if (kif == NULL || (ifam->ifam_addrs &
			    (RTA_NETMASK | RTA_IFA | RTA_BRD)) == 0)
d1194 1
a1194 1
			sa = (struct sockaddr *)(next + sizeof(*ifam));
d1197 4
a1200 26
			if ((sa = rti_info[RTAX_IFA]) != NULL &&
			    sa->sa_family == AF_INET) {
				if ((kaddr = calloc(1,
				    sizeof(struct kif_addr))) == NULL) {
					log_warn("fetchifs");
					free(buf);
					return (-1);
				}

				sain = (struct sockaddr_in *)sa;
				kaddr->addr = sain->sin_addr;

				if ((sa = rti_info[RTAX_NETMASK]) != NULL) {
					sain = (struct sockaddr_in *)sa;
					kaddr->mask = sain->sin_addr;
				} else
					kaddr->mask.s_addr = INADDR_NONE;

				if ((sa = rti_info[RTAX_BRD]) != NULL) {
					sain = (struct sockaddr_in *)sa;
					kaddr->dstbrd = sain->sin_addr;
				} else
					kaddr->dstbrd.s_addr = INADDR_NONE;

				TAILQ_INSERT_TAIL(&kif->addrs, kaddr, entry);
			}
d1216 1
d1408 13
@


1.46
log
@Before starting to evaluate the redistributon of a route it helps to set
the metric to the highest and least preferred possible value else no routes
are redistributed. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.45 2007/03/27 09:43:20 claudio Exp $ */
d25 1
d880 6
a885 6
	struct {
		struct rt_msghdr	hdr;
		struct sockaddr_in	prefix;
		struct sockaddr_in	nexthop;
		struct sockaddr_in	mask;
	} r;
d890 5
a894 5
	bzero(&r, sizeof(r));
	r.hdr.rtm_msglen = sizeof(r);
	r.hdr.rtm_version = RTM_VERSION;
	r.hdr.rtm_type = action;
	r.hdr.rtm_flags = RTF_PROTO2;
d896 42
a937 17
		r.hdr.rtm_fmask =
		    RTF_PROTO2|RTF_PROTO1|RTF_REJECT|RTF_BLACKHOLE;
	r.hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	r.hdr.rtm_addrs = RTA_DST|RTA_GATEWAY|RTA_NETMASK;
	r.prefix.sin_len = sizeof(r.prefix);
	r.prefix.sin_family = AF_INET;
	r.prefix.sin_addr.s_addr = kroute->prefix.s_addr;

	r.nexthop.sin_len = sizeof(r.nexthop);
	r.nexthop.sin_family = AF_INET;
	r.nexthop.sin_addr.s_addr = kroute->nexthop.s_addr;
	if (kroute->nexthop.s_addr != 0)
		r.hdr.rtm_flags |= RTF_GATEWAY;

	r.mask.sin_len = sizeof(r.mask);
	r.mask.sin_family = AF_INET;
	r.mask.sin_addr.s_addr = prefixlen2mask(kroute->prefixlen);
d940 1
a940 1
	if (write(fd, &r, sizeof(r)) == -1) {
d943 2
a944 2
			if (r.hdr.rtm_type == RTM_CHANGE) {
				r.hdr.rtm_type = RTM_ADD;
d946 1
a946 1
			} else if (r.hdr.rtm_type == RTM_DELETE) {
d953 1
a953 1
				    "prefix %s/%u: %s", r.hdr.rtm_type,
d961 1
a961 1
			    r.hdr.rtm_type, inet_ntoa(kroute->prefix),
@


1.45
log
@First step to make ospfd equal cost multipath aware.
Change kroute.c code so that it correctly tracks multipath routes.
Route redistribution is way more complex in a mulitpath environment.
It is not possible to redistribute multiple pathes and only a part of the
multipath routes may be redistributable. So a route is redistributed as soon
as one of the multipath routes is redistributable.
Tested and OK norby@@ and pyr@@ -- at least we see no regression
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.44 2007/03/13 17:01:15 claudio Exp $ */
d445 1
@


1.44
log
@Don't call rtlabel_unref() twice on RTM_DELETE. kroute_remove() does it
so don't unref before calling kroute_remove() or we end up with wrong
reference counts.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.43 2007/03/13 16:48:03 claudio Exp $ */
d53 1
d62 3
a64 1
void	kr_redistribute(int, struct kroute *);
d69 1
d173 4
a176 1
				kr->r.flags |= F_OSPFD_INSERTED;
d180 4
d237 4
a240 1
		kr->r.flags &= ~F_OSPFD_INSERTED;
d358 1
a358 1
kr_redistribute(int type, struct kroute *kr)
d360 1
a360 2
	u_int32_t	a, metric = 0;
	struct rroute	rr;
d362 2
a363 11
	if (type == IMSG_NETWORK_DEL) {
dont_redistribute:
		/* was the route redistributed? */
		if (kr->flags & F_REDISTRIBUTED) {
			/* remove redistributed flag and inform the RDE */
			kr->flags &= ~F_REDISTRIBUTED;
			rr.kr = *kr;
			rr.metric = 0;
			main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, &rr,
			    sizeof(struct rroute));
		}
d365 20
a384 1
	}
d416 1
a416 1
	/* Does not matter if we resend the kr, the RDE will cope. */
d418 18
d437 23
a459 3
	rr.kr = *kr;
	rr.metric = metric;
	main_imsg_compose_rde(type, 0, &rr, sizeof(struct rroute));
d465 1
a465 1
	struct kroute_node	*kr;
d470 15
a484 6
		r = ospf_redistribute(&kr->r, &dummy);
		if (kr->r.flags & F_REDISTRIBUTED && !r) {
			kr_redistribute(IMSG_NETWORK_DEL, &kr->r);
		} else if (r) {
			/* RIB will cope with duplicates */
			kr_redistribute(IMSG_NETWORK_ADD, &kr->r);
d522 17
d542 14
a555 6
	if (RB_INSERT(kroute_tree, &krt, kr) != NULL) {
		log_warnx("kroute_tree insert failed for %s/%u",
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
		free(kr);
		return (-1);
	}
d568 1
a568 2
	kr_redistribute(IMSG_NETWORK_ADD, &kr->r);

d575 4
a578 2
	if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
		log_warnx("kroute_remove failed for %s/%u",
d583 28
a610 1
	kr_redistribute(IMSG_NETWORK_DEL, &kr->r);
d808 1
a808 2
	struct kroute_node	*kr;
	int			 type;
a827 1
	type = reachable ? IMSG_NETWORK_ADD : IMSG_NETWORK_DEL;
d833 7
a839 6
	RB_FOREACH(kr, kroute_tree, &krt)
		if (kr->r.ifindex == ifindex) {
			if (reachable)
				kr->r.flags &= ~F_DOWN;
			else
				kr->r.flags |= F_DOWN;
d841 1
a841 1
			kr_redistribute(type, &kr->r);
d843 3
a988 5
#ifdef RTF_MPATH
		if (rtm->rtm_flags & RTF_MPATH)		/* multipath */
			continue;
#endif

d1187 1
a1187 1
	struct kroute_node	*kr;
d1190 1
a1190 1
	int			 flags;
d1211 1
d1221 1
a1221 1
			if (rtm->rtm_pid == kr_state.pid)	/* cause by us */
d1224 1
a1224 1
			if (rtm->rtm_errno)			/* failed attempts... */
d1230 4
d1283 1
a1283 1
			if ((kr = kroute_find(prefix.s_addr, prefixlen)) !=
d1285 18
a1302 2
				/* ospf route overridden by kernel */
				/* pref is not checked because this is forced */
d1324 1
a1324 1
				kr_redistribute(IMSG_NETWORK_ADD, &kr->r);
d1326 1
d1352 14
a1365 1
			if (kr->r.flags & F_OSPFD_INSERTED)
@


1.43
log
@rtm_tableid is only valid for RTM_ADD, RTM_CHANGE and RTM_DELETE but not
for stuff like RTM_IFINFO or RTM_IFANNOUNCE. So move check to a save location.
Always check rtm_type before accessing some random value inside the route
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.42 2007/02/25 18:10:47 deraadt Exp $ */
a1212 1
			rtlabel_unref(kr->r.rtlabel);
@


1.42
log
@copy mis-aligned routing socket message into a properly aligned struct, so
that we can access it safely; ok claudio
in the long term we must deal with the 32/64 bit issues of if_buadrate and
friends
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.41 2007/02/24 00:10:45 deraadt Exp $ */
a1091 3
		if (rtm->rtm_tableid != 0)
			continue;

d1096 3
@


1.42.2.1
log
@From claudio@@
> ospfd and ripd a re busted in 4.1 because the are unable to track
> linkstates. This was fixed in 1.43 of ospfd/kroute.c and 1.6 of
> ripd/kroute.c.
>
> revision 1.43
> date: 2007/03/13 16:48:03;  author: claudio;  state: Exp;  lines: +4 -4
> rtm_tableid is only valid for RTM_ADD, RTM_CHANGE and RTM_DELETE but not
> for stuff like RTM_IFINFO or RTM_IFANNOUNCE. So move check to a save
> location.
> Always check rtm_type before accessing some random value inside the route
> message.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.42 2007/02/25 18:10:47 deraadt Exp $ */
d1092 3
a1098 3

			if (rtm->rtm_tableid != 0)
				continue;
@


1.41
log
@spelling; sthen@@spacehopper
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.40 2007/02/01 12:51:01 claudio Exp $ */
d939 1
a939 1
	struct if_msghdr	*ifm;
d975 4
a978 3
			ifm = (struct if_msghdr *)rtm;
			sa = (struct sockaddr *)(next + sizeof(*ifm));
			get_rtaddrs(ifm->ifm_addrs, sa, rti_info);
d987 6
a992 6
			kif->k.ifindex = ifm->ifm_index;
			kif->k.flags = ifm->ifm_flags;
			kif->k.link_state = ifm->ifm_data.ifi_link_state;
			kif->k.media_type = ifm->ifm_data.ifi_type;
			kif->k.baudrate = ifm->ifm_data.ifi_baudrate;
			kif->k.mtu = ifm->ifm_data.ifi_mtu;
d994 2
a995 2
			    (LINK_STATE_IS_UP(ifm->ifm_data.ifi_link_state) ||
			    (ifm->ifm_data.ifi_link_state ==
d997 1
a997 1
			    ifm->ifm_data.ifi_type != IFT_CARP));
@


1.40
log
@kr_reload() -- another helper function for reload support. This one
takes care that redistribution is correct after reload. OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.39 2006/12/13 13:30:07 claudio Exp $ */
d1015 1
a1015 1
				fatalx("fetchifs: bad interafce table");
@


1.39
log
@Doh! I forgot the change from kroute to rroute in the deletion case.
Found by Armin Wolfermann
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.38 2006/12/07 19:14:27 claudio Exp $ */
d399 18
@


1.38
log
@Make it possible to set the metric and LSA type for redistributed routes.
Mostly based on a diff by Pierre-Yves Ritschard (I just simplified the parser
code). OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.37 2006/11/28 19:21:15 reyk Exp $ */
d355 4
a358 2
			main_imsg_compose_rde(IMSG_NETWORK_DEL, 0, kr,
			    sizeof(struct kroute));
@


1.37
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.36 2006/11/28 16:36:58 henning Exp $ */
d346 2
a347 2
	u_int32_t	a;

d388 1
a388 1
	if (!ospf_redistribute(kr))
d393 4
a396 1
	main_imsg_compose_rde(type, 0, kr, sizeof(struct kroute));
@


1.36
log
@mib we pass to sysctl when fetching the routing table has 7 entries now,
not 6 any more (rtableid added). need to tell sysctl so.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.35 2006/11/17 08:55:31 claudio Exp $ */
d677 1
a677 1
	    (ifd->ifi_link_state == LINK_STATE_UP ||
d970 1
a970 1
			    (ifm->ifm_data.ifi_link_state == LINK_STATE_UP ||
@


1.35
log
@Support for multiple networks on one interface. Until now only the main
address of a interface could be used. Now it is possible to specify a
interface more than once if multiple networks are configured. An alternative
network can be specified via e.g. interface em0:10.0.5.1. The old interface
syntax without the IP still works and uses the main/first configured IP
address.
ospfd now needs to include the IP header on outgoing messages as it is not
possible to specifiy the source address in sendto(2). Additionally all
multicast joins and leaves have to be tracked.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.34 2006/11/16 15:55:29 henning Exp $ */
d815 1
a815 1
	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
d823 1
a823 1
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
@


1.34
log
@ignore routing messages for alternate tables for now, from bgpd
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.33 2006/05/30 22:06:14 claudio Exp $ */
d57 1
d492 1
a492 1
kif_findname(char *ifname)
d495 1
d498 10
a507 1
		if (!strcmp(ifname, kif->k.ifname))
d509 1
d529 2
d536 4
d915 5
a919 2
	struct if_msghdr	 ifm;
	struct kif_node		*kif;
d922 1
d946 3
a948 3
	for (next = buf; next < lim; next += ifm.ifm_msglen) {
		memcpy(&ifm, next, sizeof(ifm));
		if (ifm.ifm_type != RTM_IFINFO)
d950 12
d963 14
a976 21
		sa = (struct sockaddr *)(next + sizeof(ifm));
		get_rtaddrs(ifm.ifm_addrs, sa, rti_info);

		if ((kif = calloc(1, sizeof(struct kif_node))) == NULL) {
			log_warn("fetchifs");
			free(buf);
			return (-1);
		}

		kif->k.ifindex = ifm.ifm_index;
		kif->k.flags = ifm.ifm_flags;
		kif->k.link_state = ifm.ifm_data.ifi_link_state;
		kif->k.media_type = ifm.ifm_data.ifi_type;
		kif->k.baudrate = ifm.ifm_data.ifi_baudrate;
		kif->k.mtu = ifm.ifm_data.ifi_mtu;
		kif->k.nh_reachable = (kif->k.flags & IFF_UP) &&
		    (ifm.ifm_data.ifi_link_state == LINK_STATE_UP ||
		    (ifm.ifm_data.ifi_link_state == LINK_STATE_UNKNOWN &&
		    ifm.ifm_data.ifi_type != IFT_CARP));
		if ((sa = rti_info[RTAX_IFP]) != NULL)
			if (sa->sa_family == AF_LINK) {
d987 40
a1026 1
		kif_insert(kif);
@


1.33
log
@Now that rtlabels are accessable via sysctl we can use route lables to
define which routes should be redistributed via OSPF. So now you can
define the export list on a fine graded basis. More to come... OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.32 2006/05/27 19:28:20 claudio Exp $ */
d781 1
a781 1
	int			 mib[6];
d795 1
d1001 3
@


1.32
log
@Revert last commit. Having ifindex of 0 is an error and needs to be reported.
Having routes with incorrect ifindex makes it impossible to correctly validate
routes. -current ospfd needs a -current kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.31 2006/04/28 15:46:10 henning Exp $ */
d180 2
a225 1
		kr->r.ifindex = 0;	/* ifindex is no longer relevant */
d349 1
d352 1
a352 1
			/* remove redistributed flag */
d354 1
a354 1
			main_imsg_compose_rde(type, 0, kr,
d362 1
a362 1
		return;
d366 1
a366 1
		return;
d370 1
a370 1
		return;
d379 1
a379 1
		return;
d384 1
a384 1
		return;
d388 1
a388 1
		return;
d464 1
d786 1
d877 5
a881 1
		} else
d883 1
d975 1
d1070 2
d1076 7
d1102 5
d1119 1
@


1.31
log
@do not log "interface with index 0 not found". ifindex == 0 happens on
routes. same as in bgpd now. norby ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.30 2006/04/25 08:01:16 claudio Exp $ */
d538 1
a538 3
		if (ifindex > 0)
			log_warnx("interface with index %u not found",
			    ifindex);
d646 1
a646 2
		log_warnx("interface with index %u not found",
		    ifindex);
@


1.30
log
@ARGSUSED for event handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.29 2006/04/18 19:19:18 claudio Exp $ */
d538 3
a540 2
		log_warnx("interface with index %u not found",
		    ifindex);
@


1.29
log
@struct kif_kr is not used in ospfd.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.28 2006/04/16 11:40:54 henning Exp $ */
d279 1
@


1.28
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.27 2006/04/16 11:38:11 henning Exp $ */
a52 5
};

struct kif_kr {
	LIST_ENTRY(kif_kr)	 entry;
	struct kroute_node	*kr;
@


1.27
log
@only look at later rt_msghdr fields for those messages actually using
rt_msghdr, same as in bgpd, ok claudio norby
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.26 2006/03/08 13:49:07 claudio Exp $ */
d1041 2
a1042 2
					nexthop.s_addr =
					    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
@


1.26
log
@Fix logic of the kroute code. First of all there was a porblem if a prefix
is known via kernel and ospf. If the kernel route is removed the ospf one
was not added to the FIB. This is an uncommon event so it is OK to request
an update from the RIB in this case.
Additionally ospfd treated bgpd inserted routes like static routes. This
is wrong because IGP routes habe a higher preference over EGP routes. In
this case a bgpd route needs to be overridden by a ospfd one.
With these to fixes bgpd and ospfd start to play nicely together.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.25 2006/01/23 22:29:15 claudio Exp $ */
d976 1
a976 1
	u_short			 ifindex;
a990 2
		sa = (struct sockaddr *)(rtm + 1);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
d997 7
a1003 2
		if (rtm->rtm_pid == kr_state.pid)	/* cause by us */
			continue;
d1005 2
a1006 2
		if (rtm->rtm_errno)			/* failed attempts... */
			continue;
a1007 2
		if (rtm->rtm_type == RTM_ADD || rtm->rtm_type == RTM_CHANGE ||
		    rtm->rtm_type == RTM_DELETE) {
d1010 1
a1035 1
		}
d1037 11
a1047 10
		ifindex = rtm->rtm_index;
		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
			case AF_INET:
				nexthop.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				break;
			case AF_LINK:
				flags |= F_CONNECTED;
				break;
d1049 1
@


1.25
log
@Kill stupid comment. "not reached" after a continue is superfluous.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.24 2006/01/12 15:10:02 claudio Exp $ */
d169 1
a169 1
		if (kr->r.flags & F_OSPFD_INSERTED)
d171 15
a185 2
		else	/* a non-ospf route already exists. not a problem */
			return (0);
d226 4
a229 3
	/* nexthop within 127/8 -> ignore silently */
	if ((kroute->nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
	    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
d231 1
d261 1
a261 1
		if ((kr->r.flags & F_OSPFD_INSERTED))
d276 1
a276 1
		if ((kr->r.flags & F_OSPFD_INSERTED))
d363 1
a363 1
	if (kr->flags & F_OSPFD_INSERTED)
d440 1
a440 1
	if (kr->r.flags & F_OSPFD_INSERTED) {
d730 3
d846 2
d1028 2
d1059 15
a1073 18
				if (kr->r.flags & F_KERNEL) {
					kr->r.nexthop.s_addr = nexthop.s_addr;
					kr->r.flags = flags;

					if (kif_validate(kr->r.ifindex))
						kr->r.flags &= ~F_DOWN;
					else
						kr->r.flags |= F_DOWN;

					/* just readd, the RDE will care */
					kr_redistribute(IMSG_NETWORK_ADD,
					    &kr->r);
				}
			} else if (rtm->rtm_type == RTM_CHANGE) {
				log_warnx("change req for %s/%u: not "
				    "in table", inet_ntoa(prefix),
				    prefixlen);
				continue;
d1095 3
@


1.25.2.1
log
@MFC:
Fix by henning@@

only look at later rt_msghdr fields for those messages actually using
rt_msghdr, same as in bgpd
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.25 2006/01/23 22:29:15 claudio Exp $ */
d956 1
a956 1
	u_short			 ifindex = 0;
d971 2
d979 6
a986 9
			sa = (struct sockaddr *)(rtm + 1);
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

			if (rtm->rtm_pid == kr_state.pid)	/* cause by us */
				continue;

			if (rtm->rtm_errno)			/* failed attempts... */
				continue;

a988 1

d1012 1
d1014 10
a1023 11
			ifindex = rtm->rtm_index;
			if ((sa = rti_info[RTAX_GATEWAY]) != NULL) {
				switch (sa->sa_family) {
				case AF_INET:
					nexthop.s_addr =
					    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
					break;
				case AF_LINK:
					flags |= F_CONNECTED;
					break;
				}
a1024 1
		}
@


1.24
log
@Rewrite the redistribute code. The previous implementation was stupid and
resulted in a major bottleneck if bgpd was used on the same box -- not clever
to do linear searches over 175k entries :(. This now moves the redistribute
code back into kroute duty and kills the linear list. Also default routes are
now redistributed without the need for a kernel default route.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.23 2006/01/12 15:00:48 claudio Exp $ */
a1010 1
				/* not reached */
@


1.23
log
@Change inet_addr("127.0.0.1") into htonl(INADDR_LOOPBACK) and similar.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.22 2006/01/05 15:53:36 claudio Exp $ */
d78 1
d335 16
d355 4
d373 6
d425 12
a436 2
	if (kr->r.flags & F_KERNEL)
		kr_redistribute(IMSG_NETWORK_ADD, &kr->r);
d450 1
a450 2
	if (kr->r.flags & F_KERNEL)
		kr_redistribute(IMSG_NETWORK_DEL, &kr->r);
a520 14
void
kif_update(struct kif *k)
{
	struct kif_node		*kif;

	if ((kif = kif_find(k->ifindex)) == NULL) {
		log_warnx("interface with index %u not found",
		    k->ifindex);
		return;
	}

	memcpy(&kif->k, k, sizeof(struct kif));
}

d631 2
d653 3
d657 11
a667 1
	main_imsg_compose_rde(IMSG_IFINFO, 0, &kif->k, sizeof(kif->k));
d817 1
a817 2
		if (!(rtm->rtm_flags & RTF_PROTO1))
			kr->r.flags = F_KERNEL;
d1041 6
@


1.22
log
@Make ospfd respect carp(4) interfaces and their weird behaviour. They will
not be used to connect to a OSPF cloud and forced to be passive. With this
ospfd will only announce the carp interface route if the interface is master.
So you can connect a LAN in a redundant way to your ospf backbone. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.21 2005/12/14 00:44:40 claudio Exp $ */
d175 2
a176 2
	if ((kroute->nexthop.s_addr & htonl(0xff000000)) ==
	    inet_addr("127.0.0.0"))
d213 2
a214 2
	if ((kroute->nexthop.s_addr & htonl(0xff000000)) ==
	    inet_addr("127.0.0.0"))
d542 1
a542 1
	kr->r.prefix.s_addr = inet_addr("127.0.0.1");
@


1.21
log
@Replace strlcpy() with memcpy() in the sockaddr_dl handling. sdl_data is
not a C string and strlcpy() only works on C strings -- returns length of
the source.  Found by tedu@@ OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.20 2005/08/08 08:38:42 claudio Exp $ */
d29 1
d623 3
a625 1
	    (ifd->ifi_link_state != LINK_STATE_DOWN)) == kif->k.nh_reachable)
d885 3
a887 1
		    (ifm.ifm_data.ifi_link_state != LINK_STATE_DOWN);
@


1.20
log
@tab before newline.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.19 2005/06/26 19:22:12 claudio Exp $ */
d887 2
a888 2
					strlcpy(kif->k.ifname, sdl->sdl_data,
					    sizeof(kif->k.ifname));
d890 3
a892 2
					strlcpy(kif->k.ifname, sdl->sdl_data,
					    sdl->sdl_nlen + 1);
@


1.19
log
@Do not automaticaly announce routes that have RTF_DYNAMIC set. These routes
are e.g. created by the PMTU code and are removed after some time.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.18 2005/05/24 21:36:40 claudio Exp $ */
d336 1
a336 1
	
@


1.18
log
@Only redistribute networks if the interface they depend on is actually
up and running. This makes redistribution of carp(4)-ed networks magically
work. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.17 2005/05/24 21:31:07 claudio Exp $ */
d333 4
d787 2
d964 2
@


1.17
log
@Set ifindex for all kernel routes. This makes it very easy to track the
state of static prefixes.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.16 2005/05/13 08:29:13 claudio Exp $ */
d480 28
d623 1
@


1.16
log
@The NET_RT_IFLIST sysctl returns RTM_IFINFO and RTM_NEWADDR messages in
the buffer. While RTM_IFINFO starts with a struct if_msghdr RTM_NEWADDR
does not. In other words (struct sockaddr *)(next + sizeof(ifm)) is only
correct for RTM_IFINFO and not for RTM_NEWADDR. So move the ifm_type check
up else get_rtaddrs() would access memory outside of buf.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.15 2005/04/16 21:48:21 claudio Exp $ */
d770 1
a778 1
				kr->r.ifindex = rtm->rtm_index;
a900 1
		ifindex = 0;
d936 1
a944 1
				ifindex = rtm->rtm_index;
@


1.15
log
@Set F_STATIC flag earlier else the default route will end up as non-static.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.14 2005/04/12 09:54:59 claudio Exp $ */
d828 3
a832 3

		if (ifm.ifm_type != RTM_IFINFO)
			continue;
@


1.14
log
@Support for self originated AS-external LSA.
With "redistribute (static|connected|default|none)" it is possible to
tell ospfd which external routes should be announced.
Connected routes will be announced only if there is no corresponding
interface configured, in that case the prefix is not external.
Adding and removing of announced prefixes are done automaticaly.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.13 2005/03/31 19:32:10 norby Exp $ */
d752 2
a763 2
			if (rtm->rtm_flags & RTF_STATIC)
				kr->r.flags |= F_STATIC;
@


1.13
log
@Add support for crypt authentication (MD5).

ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.12 2005/03/26 13:35:16 claudio Exp $ */
d64 1
d328 22
d393 3
d408 3
d762 2
d928 2
d963 3
@


1.12
log
@Implement the IMSG_CTL_IFINFO bits correctly. This is needed for
"ospfctl show fib interface".
OK henning@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.11 2005/03/26 11:06:49 claudio Exp $ */
d323 1
a323 1
	
@


1.11
log
@kroute.c cleanup, simplify code and remove unused functions.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.10 2005/03/23 20:28:29 claudio Exp $ */
d314 1
a314 1
kr_ifinfo(char *ifname)
d319 3
a321 4
		if (!strcmp(ifname, kif->k.ifname)) {
			main_imsg_compose_ospfe(IMSG_CTL_IFINFO, 0,
			    &kif->k, sizeof(kif->k));
			return;
d323 2
@


1.10
log
@The interface name in struct sockaddr_dl may not be nul terminated and
so the strlcpy() will copy to much. Use sa_nlen instead with some additional
logic. This fixes a problem where interfaces where not found.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.9 2005/03/23 20:15:50 claudio Exp $ */
a38 1
#include "ospfd.h"
a40 3
/* XXX */
void main_imsg_compose_ospfe(int, pid_t, void *, u_int16_t);

a58 2
LIST_HEAD(kif_kr_head, kif_kr);

a61 1
	struct kif_kr_head	 kroute_l;
a76 3
int			 kif_kr_insert(struct kroute_node *);
int			 kif_kr_remove(struct kroute_node *);

a368 8
	if (kr->r.flags & F_KERNEL) {
		if (!(kr->r.flags & F_CONNECTED))
			kr->r.flags |= F_STATIC;

		if (kr->r.flags & F_CONNECTED)
			if (kif_kr_insert(kr) == -1)
				return (-1);
	}
a380 6
	if (kr->r.flags & F_CONNECTED)
		if (kif_kr_remove(kr) == -1) {
			free(kr);
			return (-1);
		}

a419 2
	LIST_INIT(&kif->kroute_l);

a431 2
	struct kif_kr	*kkr;

a436 6
	while ((kkr = LIST_FIRST(&kif->kroute_l)) != NULL) {
		LIST_REMOVE(kkr, entry);
		kroute_remove(kkr->kr);
		free(kkr);
	}

a449 54
int
kif_kr_insert(struct kroute_node *kr)
{
	struct kif_node	*kif;
	struct kif_kr	*kkr;

	if ((kif = kif_find(kr->r.ifindex)) == NULL) {
		if (kr->r.ifindex)
			log_warnx("interface with index %u not found",
			    kr->r.ifindex);
		return (0);
	}

	if ((kkr = calloc(1, sizeof(struct kif_kr))) == NULL) {
		log_warn("kif_kr_insert");
		return (-1);
	}

	kkr->kr = kr;

	LIST_INSERT_HEAD(&kif->kroute_l, kkr, entry);

	return (0);
}

int
kif_kr_remove(struct kroute_node *kr)
{
	struct kif_node	*kif;
	struct kif_kr	*kkr;

	if ((kif = kif_find(kr->r.ifindex)) == NULL) {
		if (kr->r.ifindex)
			log_warnx("interface with index %u not found",
			    kr->r.ifindex);
		return (0);
	}

	for (kkr = LIST_FIRST(&kif->kroute_l); kkr != NULL && kkr->kr != kr;
	    kkr = LIST_NEXT(kkr, entry))
		;	/* nothing */

	if (kkr == NULL) {
		log_warnx("can't remove connected route from interface "
		    "with index %u: not found", kr->r.ifindex);
		return (-1);
	}

	LIST_REMOVE(kkr, entry);
	free(kkr);

	return (0);
}

a545 1
	struct kif_kr		*kkr;
a564 12

	LIST_FOREACH(kkr, &kif->kroute_l, entry) {
		/*
		 * we treat link_state == LINK_STATE_UNKNOWN as valid
		 * not all interfaces have a concept of "link state" and/or
		 * do not report up
		 */
		if (reachable)
			kkr->kr->r.flags &= ~F_DOWN;
		else
			kkr->kr->r.flags |= F_DOWN;
	}
a927 6
					if ((kr->r.flags & F_CONNECTED) &&
					    !(flags & F_CONNECTED))
						kif_kr_remove(kr);
					if ((flags & F_CONNECTED) &&
					    !(kr->r.flags & F_CONNECTED))
						kif_kr_insert(kr);
@


1.9
log
@prefixlen2mask() should return a network byte order result as it does imply
by using an in_addr_t as return type. It simplyfies also the usage as in most
cases the mask is used with a struct in_addr address which is also network
byte order. Add prototypes of prefixlen2mask() and mask2prefixlen() to
ospfd.h as it is used or will be used at different places.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.8 2005/03/23 11:30:21 henning Exp $ */
d920 1
a920 1
				if (sdl->sdl_nlen > 0)
d923 3
@


1.8
log
@grow receive buffer on the routing socket, from bgpd
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.117 2005/03/15 10:18:39 henning Exp $ */
a90 2
u_int8_t	mask2prefixlen(in_addr_t);
in_addr_t	prefixlen2mask(u_int8_t);
a542 3
	in_addr_t		 ina;

	ina = ntohl(key);
d546 1
a546 2
		if ((kr =
		    kroute_find(htonl(ina & prefixlen2mask(i)), i)) != NULL)
d609 1
a609 1
	return (0xffffffff << (32 - prefixlen));
d727 1
a727 1
	r.mask.sin_addr.s_addr = htonl(prefixlen2mask(kroute->prefixlen));
@


1.7
log
@explicitely initialize opt, from bgpd
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.6 2005/03/15 22:03:56 claudio Exp $ */
d124 2
a125 1
	int opt = 0;
d138 13
@


1.6
log
@Add control messages for the show fib commands.
OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.5 2005/03/07 10:28:14 claudio Exp $ */
d124 1
a124 1
	int opt;
@


1.5
log
@Track interface state (up/down) and media status. Simplify the code a bit
by using the kif/kroute info while allocating interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.4 2005/02/24 16:28:43 claudio Exp $ */
d273 4
d278 25
d318 1
a318 1
			main_imsg_compose_ospfe(IMSG_IFINFO, 0,
d807 2
a808 1
		kr->r.flags = F_KERNEL;
a828 1
			/* not reached */
d843 5
a847 1
		kroute_insert(kr);
@


1.4
log
@Remove the kroute nexthop specific code as there is no need for this in
ospfd. While there clean up some other no longer needed stuff.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.3 2005/02/15 15:39:30 henning Exp $ */
d102 1
a102 1
RB_HEAD(kroute_tree, kroute_node)	kroute_tree, krt;
d106 1
a106 1
RB_HEAD(kif_tree, kif_node)		kif_tree, kit;
d111 11
a141 4
	RB_INIT(&kit);

	if (fetchifs(0) == -1)
		return (-1);
d149 2
a150 1
	event_set(&kr_state.ev, kr_state.fd, EV_READ, kr_dispatch_msg, NULL);
d388 12
a610 2
	main_imsg_compose_ospfe(IMSG_IFINFO, 0, &kif->k, sizeof(kif->k));

d616 1
d873 1
a875 1

@


1.3
log
@let ospfd "tag" its routes with RTF_PROTO2, bgpd uses RTF_PROTO1 already
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
a43 2
void main_imsg_compose_rde(int, pid_t, void *, u_int16_t);
extern struct ospfd_conf	*conf;
a57 6
struct knexthop_node {
	RB_ENTRY(knexthop_node)	 entry;
	struct in_addr		 nexthop;
	struct kroute_node	*kroute;
};

a71 1
int	knexthop_compare(struct knexthop_node *, struct knexthop_node *);
a78 5
struct knexthop_node	*knexthop_find(struct in_addr);
int			 knexthop_insert(struct knexthop_node *);
int			 knexthop_remove(struct knexthop_node *);
void			 knexthop_clear(void);

a86 1
void			 knexthop_validate(struct knexthop_node *);
a87 3
void			 kroute_attach_nexthop(struct knexthop_node *,
			    struct kroute_node *);
void			 kroute_detach_nexthop(struct knexthop_node *);
a105 4
RB_HEAD(knexthop_tree, knexthop_node)	knexthop_tree, knt;
RB_PROTOTYPE(knexthop_tree, knexthop_node, entry, knexthop_compare)
RB_GENERATE(knexthop_tree, knexthop_node, entry, knexthop_compare)

a130 1
	RB_INIT(&knt);
d158 1
a158 1
		else	/* a non-bgp route already exists. not a problem */
d182 1
a182 1
	} else {
a183 9
		if (kroute->flags & F_BLACKHOLE)
			kr->r.flags |= F_BLACKHOLE;
		else
			kr->r.flags &= ~F_BLACKHOLE;
		if (kroute->flags & F_REJECT)
			kr->r.flags |= F_REJECT;
		else
			kr->r.flags &= ~F_REJECT;
	}
a217 1
	knexthop_clear();
a261 45
int
kr_nexthop_add(struct in_addr addr)
{
	struct knexthop_node	*h;

	if ((h = knexthop_find(addr)) != NULL) {
		/* should not happen... this is really an error path */
		struct kroute_nexthop	 nh;

		bzero(&nh, sizeof(nh));
		memcpy(&nh.nexthop, &addr, sizeof(nh.nexthop));
		if (h->kroute != NULL) {
			nh.valid = 1;
			nh.connected = h->kroute->r.flags & F_CONNECTED;
			if (h->kroute->r.nexthop.s_addr != 0)
				nh.gateway.s_addr =
				    h->kroute->r.nexthop.s_addr;
			memcpy(&nh.kr, &h->kroute->r, sizeof(nh.kr));
		}
		send_nexthop_update(&nh);
	} else {
		if ((h = calloc(1, sizeof(struct knexthop_node))) == NULL) {
			log_warn("kr_nexthop_add");
			return (-1);
		}
		memcpy(&h->nexthop, &addr, sizeof(h->nexthop));

		if (knexthop_insert(h) == -1)
			return (-1);
	}

	return (0);
}

void
kr_nexthop_delete(struct in_addr addr)
{
	struct knexthop_node	*kn;

	if ((kn = knexthop_find(addr)) == NULL)
		return;

	knexthop_remove(kn);
}

a264 3
	struct area	*area = NULL;
	struct iface	*iface = NULL;

a265 8
	case IMSG_CTL_SHOW_INTERFACE:
		LIST_FOREACH(area, &conf->area_list, entry) {
			LIST_FOREACH(iface, &area->iface_list, entry) {
				main_imsg_compose_ospfe(IMSG_CTL_SHOW_INTERFACE,
				    imsg->hdr.pid, iface, sizeof(*iface));
			}
		}
		break;
a302 11
knexthop_compare(struct knexthop_node *a, struct knexthop_node *b)
{
	u_int32_t	r;

	if ((r = b->nexthop.s_addr - a->nexthop.s_addr) != 0)
		return (r);

	return (0);
}

int
a322 3
	struct knexthop_node	*h;
	in_addr_t		 mask, ina;

a333 6
		mask = prefixlen2mask(kr->r.prefixlen);
		ina = ntohl(kr->r.prefix.s_addr);
		RB_FOREACH(h, knexthop_tree, &knt)
			if ((ntohl(h->nexthop.s_addr) & mask) == ina)
				knexthop_validate(h);

a343 2
	struct knexthop_node	*s;

a349 6
	/* check wether a nexthop depends on this kroute */
	if ((kr->r.flags & F_KERNEL) && (kr->r.flags & F_NEXTHOP))
		RB_FOREACH(s, knexthop_tree, &knt)
			if (s->kroute == kr)
				knexthop_validate(s);

a368 49
struct knexthop_node *
knexthop_find(struct in_addr addr)
{
	struct knexthop_node	s;

	memcpy(&s.nexthop, &addr, sizeof(s.nexthop));

	return (RB_FIND(knexthop_tree, &knt, &s));
}

int
knexthop_insert(struct knexthop_node *kn)
{
	if (RB_INSERT(knexthop_tree, &knt, kn) != NULL) {
		log_warnx("knexthop_tree insert failed for %s",
			    inet_ntoa(kn->nexthop));
		free(kn);
		return (-1);
	}

	knexthop_validate(kn);

	return (0);
}

int
knexthop_remove(struct knexthop_node *kn)
{
	kroute_detach_nexthop(kn);

	if (RB_REMOVE(knexthop_tree, &knt, kn) == NULL) {
		log_warnx("knexthop_remove failed for %s",
		    inet_ntoa(kn->nexthop));
		return (-1);
	}

	free(kn);
	return (0);
}

void
knexthop_clear(void)
{
	struct knexthop_node	*kn;

	while ((kn = RB_MIN(knexthop_tree, &knt)) != NULL)
		knexthop_remove(kn);
}

a405 1
		kkr->kr->r.flags &= ~F_NEXTHOP;
a476 33
/* nexthop validation */
void
knexthop_validate(struct knexthop_node *kn)
{
	struct kroute_node	*kr;
	struct kroute_nexthop	 n;
	int			 was_valid = 0;

	if (kn->kroute != NULL && (!(kn->kroute->r.flags & F_DOWN)))
		was_valid = 1;

	bzero(&n, sizeof(n));
	memcpy(&n.nexthop, &kn->nexthop, sizeof(n.nexthop));
	kroute_detach_nexthop(kn);

	if ((kr = kroute_match(kn->nexthop.s_addr)) == NULL) {
		if (was_valid)
			send_nexthop_update(&n);
	} else {					/* match */
		if (kr->r.flags & F_DOWN) {		/* is down */
			if (was_valid)
				send_nexthop_update(&n);
		} else {				/* valid */
			n.valid = 1;
			n.connected = kr->r.flags & F_CONNECTED;
			n.gateway.s_addr = kr->r.nexthop.s_addr;
			memcpy(&n.kr, &kr->r, sizeof(n.kr));
			send_nexthop_update(&n);
		}
		kroute_attach_nexthop(kn, kr);
	}
}

a498 30
void
kroute_attach_nexthop(struct knexthop_node *kn, struct kroute_node *kr)
{
	kn->kroute = kr;
	kr->r.flags |= F_NEXTHOP;
}

void
kroute_detach_nexthop(struct knexthop_node *kn)
{
	struct knexthop_node	*s;

	/*
	 * check wether there's another nexthop depending on this kroute
	 * if not remove the flag
	 */

	if (kn->kroute == NULL)
		return;

	for (s = RB_MIN(knexthop_tree, &knt); s != NULL &&
	    s->kroute != kn->kroute; s = RB_NEXT(knexthop_tree, &knt, s))
		;	/* nothing */

	if (s == NULL)
		kn->kroute->r.flags &= ~F_NEXTHOP;

	kn->kroute = NULL;
}

a577 2
	struct kroute_nexthop	 nh;
	struct knexthop_node	*n;
a608 15

		RB_FOREACH(n, knexthop_tree, &knt)
			if (n->kroute == kkr->kr) {
				bzero(&nh, sizeof(nh));
				memcpy(&nh.nexthop, &n->nexthop,
				    sizeof(nh.nexthop));
				if (!(kkr->kr->r.flags & F_DOWN)) {
					nh.valid = 1;
					nh.connected = 1;
					nh.gateway.s_addr =
					    kkr->kr->r.nexthop.s_addr;
				}
				memcpy(&nh.kr, &kkr->kr->r, sizeof(nh.kr));
				send_nexthop_update(&nh);
			}
a656 4
	if (kroute->flags & F_BLACKHOLE)
		r.hdr.rtm_flags |= RTF_BLACKHOLE;
	if (kroute->flags & F_REJECT)
		r.hdr.rtm_flags |= RTF_REJECT;
a965 2
					if (kr->r.flags & F_NEXTHOP)
						flags |= F_NEXTHOP;
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d903 1
a903 1
	r.hdr.rtm_flags = RTF_PROTO1;
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2004 Esben Norby <esben.norby@@ericsson.com>
@

