head	1.81;
access;
symbols
	OPENBSD_6_0:1.81.0.4
	OPENBSD_6_0_BASE:1.81
	OPENBSD_5_9:1.81.0.2
	OPENBSD_5_9_BASE:1.81
	OPENBSD_5_8:1.78.0.4
	OPENBSD_5_8_BASE:1.78
	OPENBSD_5_7:1.75.0.8
	OPENBSD_5_7_BASE:1.75
	OPENBSD_5_6:1.75.0.12
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.75.0.10
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.75.0.6
	OPENBSD_5_4_BASE:1.75
	OPENBSD_5_3:1.75.0.4
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.75.0.2
	OPENBSD_5_2_BASE:1.75
	OPENBSD_5_1_BASE:1.74
	OPENBSD_5_1:1.74.0.4
	OPENBSD_5_0:1.74.0.2
	OPENBSD_5_0_BASE:1.74
	OPENBSD_4_9:1.70.0.4
	OPENBSD_4_9_BASE:1.70
	OPENBSD_4_8:1.70.0.2
	OPENBSD_4_8_BASE:1.70
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.63.0.4
	OPENBSD_4_6_BASE:1.63
	OPENBSD_4_5:1.61.0.2
	OPENBSD_4_5_BASE:1.61
	OPENBSD_4_4:1.60.0.4
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.60.0.2
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.59.0.2
	OPENBSD_4_2_BASE:1.59
	OPENBSD_4_1:1.58.0.2
	OPENBSD_4_1_BASE:1.58
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11;
locks; strict;
comment	@ * @;


1.81
date	2015.12.05.12.20.13;	author claudio;	state Exp;
branches;
next	1.80;
commitid	ev1fE7U8gIdVx8OS;

1.80
date	2015.11.22.13.09.10;	author claudio;	state Exp;
branches;
next	1.79;
commitid	pxM0r18iZwdhX0Ks;

1.79
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.78;
commitid	kLBPo9HaQrkEaNW3;

1.78
date	2015.07.20.23.45.39;	author benno;	state Exp;
branches;
next	1.77;
commitid	5hkliGAgtkCCmQz6;

1.77
date	2015.07.19.01.59.32;	author benno;	state Exp;
branches;
next	1.76;
commitid	C7PSAS4g16J65TZI;

1.76
date	2015.07.18.15.57.14;	author mpi;	state Exp;
branches;
next	1.75;
commitid	892Bda7x92IlN8xM;

1.75
date	2012.05.14.10.17.21;	author sthen;	state Exp;
branches;
next	1.74;

1.74
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2011.06.21.17.31.07;	author mikeb;	state Exp;
branches;
next	1.72;

1.72
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2011.05.06.13.50.37;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2010.07.03.04.44.52;	author guenther;	state Exp;
branches;
next	1.69;

1.69
date	2010.05.14.08.30.18;	author sthen;	state Exp;
branches;
next	1.68;

1.68
date	2010.02.16.18.20.37;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2010.02.16.08.39.05;	author dlg;	state Exp;
branches;
next	1.66;

1.66
date	2009.09.30.14.39.07;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2009.09.30.14.37.11;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2009.08.09.23.04.16;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2009.06.05.04.12.52;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2009.04.26.12.48.06;	author sthen;	state Exp;
branches;
next	1.61;

1.61
date	2009.01.01.22.50.13;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2007.09.11.16.02.55;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.29.22.08.25;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.01.13.25.28;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.01.13.06.00;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2007.01.24.14.08.28;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.17.08.55.31;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2006.09.27.14.37.38;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2006.08.18.11.54.28;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.24.20.18.03;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.16.11.40.54;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.23.18.37.34;	author norby;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.15.13.25.33;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.13.09.36.06;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.09.18.11.34;	author norby;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.09.15.43.21;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.09.13.37.04;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.09.09.32.37;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.08.15.35.07;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.05.15.53.36;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.15.20.29.06;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.04.20.49.47;	author norby;	state Exp;
branches;
next	1.38;

1.38
date	2005.10.19.21.43.20;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.18.15.40.36;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.12.09.25.57;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.28.20.38.31;	author msf;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.24.21.10.32;	author msf;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.17.20.03.35;	author msf;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.15.19.42.51;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.30.21.07.58;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.21.20.50.26;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.13.08.52.47;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2005.06.13.08.48.16;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.13.08.44.24;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.13.08.41.16;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.27.02.14.20;	author norby;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.26.22.31.28;	author norby;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.26.19.54.49;	author norby;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.26.18.46.16;	author norby;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.12.10.14.39;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.25.11.31.50;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.25.09.55.18;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.25.09.28.45;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.25.09.09.56;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.19.07.34.52;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.31.20.13.22;	author norby;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.31.19.32.10;	author norby;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.29.17.26.35;	author norby;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.11.12.26.50;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.07.10.28.14;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.16.15.23.33;	author norby;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.09.20.40.23;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.09.17.41.16;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.09.16.37.29;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.09.16.32.32;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.07.05.51.00;	author david;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.81
log
@Pledge ospfd SE ("stdio inet mcast") and RDE ("stdio") move some code
around to make it possible. Parent can't be pledged at the moment because
of carp ioctl (carp demote). Putting it in so that people can test.
OK benno@@
@
text
@/*	$OpenBSD: interface.c,v 1.80 2015/11/22 13:09:10 claudio Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/if_types.h>
#include <ctype.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <event.h>

#include "ospfd.h"
#include "ospf.h"
#include "log.h"
#include "ospfe.h"

void		 if_hello_timer(int, short, void *);
void		 if_start_hello_timer(struct iface *);
void		 if_stop_hello_timer(struct iface *);
void		 if_stop_wait_timer(struct iface *);
void		 if_wait_timer(int, short, void *);
void		 if_start_wait_timer(struct iface *);
void		 if_stop_wait_timer(struct iface *);
struct nbr	*if_elect(struct nbr *, struct nbr *);

struct {
	int			state;
	enum iface_event	event;
	enum iface_action	action;
	int			new_state;
} iface_fsm[] = {
    /* current state	event that happened	action to take	resulting state */
    {IF_STA_DOWN,	IF_EVT_UP,		IF_ACT_STRT,	0},
    {IF_STA_WAITING,	IF_EVT_BACKUP_SEEN,	IF_ACT_ELECT,	0},
    {IF_STA_WAITING,	IF_EVT_WTIMER,		IF_ACT_ELECT,	0},
    {IF_STA_ANY,	IF_EVT_WTIMER,		IF_ACT_NOTHING,	0},
    {IF_STA_WAITING,	IF_EVT_NBR_CHNG,	IF_ACT_NOTHING,	0},
    {IF_STA_MULTI,	IF_EVT_NBR_CHNG,	IF_ACT_ELECT,	0},
    {IF_STA_ANY,	IF_EVT_NBR_CHNG,	IF_ACT_NOTHING,	0},
    {IF_STA_ANY,	IF_EVT_DOWN,		IF_ACT_RST,	IF_STA_DOWN},
    {IF_STA_ANY,	IF_EVT_LOOP,		IF_ACT_RST,	IF_STA_LOOPBACK},
    {IF_STA_LOOPBACK,	IF_EVT_UNLOOP,		IF_ACT_NOTHING,	IF_STA_DOWN},
    {-1,		IF_EVT_NOTHING,		IF_ACT_NOTHING,	0},
};

static int vlink_cnt = 0;

const char * const if_event_names[] = {
	"NOTHING",
	"UP",
	"WAITTIMER",
	"BACKUPSEEN",
	"NEIGHBORCHANGE",
	"LOOP",
	"UNLOOP",
	"DOWN"
};

const char * const if_action_names[] = {
	"NOTHING",
	"START",
	"ELECT",
	"RESET"
};

int
if_fsm(struct iface *iface, enum iface_event event)
{
	int	old_state;
	int	new_state = 0;
	int	i, ret = 0;

	old_state = iface->state;

	for (i = 0; iface_fsm[i].state != -1; i++)
		if ((iface_fsm[i].state & old_state) &&
		    (iface_fsm[i].event == event)) {
			new_state = iface_fsm[i].new_state;
			break;
		}

	if (iface_fsm[i].state == -1) {
		/* event outside of the defined fsm, ignore it. */
		log_debug("if_fsm: interface %s, "
		    "event %s not expected in state %s", iface->name,
		    if_event_names[event], if_state_name(old_state));
		return (0);
	}

	switch (iface_fsm[i].action) {
	case IF_ACT_STRT:
		ret = if_act_start(iface);
		break;
	case IF_ACT_ELECT:
		ret = if_act_elect(iface);
		break;
	case IF_ACT_RST:
		ret = if_act_reset(iface);
		break;
	case IF_ACT_NOTHING:
		/* do nothing */
		break;
	}

	if (ret) {
		log_debug("if_fsm: error changing state for interface %s, "
		    "event %s, state %s", iface->name, if_event_names[event],
		    if_state_name(old_state));
		return (-1);
	}

	if (new_state != 0)
		iface->state = new_state;

	if (iface->state != old_state) {
		area_track(iface->area);
		orig_rtr_lsa(iface->area);
	}

	if (old_state & (IF_STA_MULTI | IF_STA_POINTTOPOINT) &&
	    (iface->state & (IF_STA_MULTI | IF_STA_POINTTOPOINT)) == 0)
		ospfe_demote_iface(iface, 0);
	if ((old_state & (IF_STA_MULTI | IF_STA_POINTTOPOINT)) == 0 &&
	    iface->state & (IF_STA_MULTI | IF_STA_POINTTOPOINT))
		ospfe_demote_iface(iface, 1);

	log_debug("if_fsm: event %s resulted in action %s and changing "
	    "state for interface %s from %s to %s",
	    if_event_names[event], if_action_names[iface_fsm[i].action],
	    iface->name, if_state_name(old_state), if_state_name(iface->state));

	return (ret);
}

struct iface *
if_new(struct kif *kif, struct kif_addr *ka)
{
	struct iface		*iface;

	if ((iface = calloc(1, sizeof(*iface))) == NULL)
		err(1, "if_new: calloc");

	iface->state = IF_STA_DOWN;

	LIST_INIT(&iface->nbr_list);
	TAILQ_INIT(&iface->ls_ack_list);
	TAILQ_INIT(&iface->auth_md_list);
	RB_INIT(&iface->lsa_tree);

	iface->crypt_seq_num = arc4random() & 0x0fffffff;

	if (kif == NULL) {
		iface->type = IF_TYPE_VIRTUALLINK;
		snprintf(iface->name, sizeof(iface->name), "vlink%d",
		    vlink_cnt++);
		iface->flags |= IFF_UP;
		iface->mtu = IP_MSS;
		return (iface);
	}

	strlcpy(iface->name, kif->ifname, sizeof(iface->name));

	/* get type */
	if (kif->flags & IFF_POINTOPOINT)
		iface->type = IF_TYPE_POINTOPOINT;
	if (kif->flags & IFF_BROADCAST &&
	    kif->flags & IFF_MULTICAST)
		iface->type = IF_TYPE_BROADCAST;
	if (kif->flags & IFF_LOOPBACK) {
		iface->type = IF_TYPE_POINTOPOINT;
		iface->passive = 1;
	}

	/* get mtu, index and flags */
	iface->mtu = kif->mtu;
	iface->ifindex = kif->ifindex;
	iface->rdomain = kif->rdomain;
	iface->flags = kif->flags;
	iface->linkstate = kif->link_state;
	iface->if_type = kif->if_type;
	iface->baudrate = kif->baudrate;

	/* set address, mask and p2p addr */
	iface->addr = ka->addr;
	iface->mask = ka->mask;
	if (kif->flags & IFF_POINTOPOINT) {
		iface->dst = ka->dstbrd;
	}

	return (iface);
}

void
if_del(struct iface *iface)
{
	struct nbr	*nbr = NULL;

	/* revert the demotion when the interface is deleted */
	if ((iface->state & (IF_STA_MULTI | IF_STA_POINTTOPOINT)) == 0)
		ospfe_demote_iface(iface, 1);

	/* clear lists etc */
	while ((nbr = LIST_FIRST(&iface->nbr_list)) != NULL)
		nbr_del(nbr);

	if (evtimer_pending(&iface->hello_timer, NULL))
		evtimer_del(&iface->hello_timer);
	if (evtimer_pending(&iface->wait_timer, NULL))
		evtimer_del(&iface->wait_timer);
	if (evtimer_pending(&iface->lsack_tx_timer, NULL))
		evtimer_del(&iface->lsack_tx_timer);

	ls_ack_list_clr(iface);
	md_list_clr(&iface->auth_md_list);
	free(iface);
}

void
if_init(struct ospfd_conf *xconf, struct iface *iface)
{
	/* init the dummy local neighbor */
	iface->self = nbr_new(ospfe_router_id(), iface, 1);

	/* set event handlers for interface */
	evtimer_set(&iface->lsack_tx_timer, ls_ack_tx_timer, iface);
	evtimer_set(&iface->hello_timer, if_hello_timer, iface);
	evtimer_set(&iface->wait_timer, if_wait_timer, iface);

	iface->fd = xconf->ospf_socket;

	ospfe_demote_iface(iface, 0);
}

/* timers */
/* ARGSUSED */
void
if_hello_timer(int fd, short event, void *arg)
{
	struct iface *iface = arg;
	struct timeval tv;

	send_hello(iface);

	/* reschedule hello_timer */
	timerclear(&tv);
	if (iface->dead_interval == FAST_RTR_DEAD_TIME)
		tv.tv_usec = iface->fast_hello_interval * 1000;
	else
		tv.tv_sec = iface->hello_interval;
	if (evtimer_add(&iface->hello_timer, &tv) == -1)
		fatal("if_hello_timer");
}

void
if_start_hello_timer(struct iface *iface)
{
	struct timeval tv;

	timerclear(&tv);
	if (evtimer_add(&iface->hello_timer, &tv) == -1)
		fatal("if_start_hello_timer");
}

void
if_stop_hello_timer(struct iface *iface)
{
	if (evtimer_del(&iface->hello_timer) == -1)
		fatal("if_stop_hello_timer");
}

/* ARGSUSED */
void
if_wait_timer(int fd, short event, void *arg)
{
	struct iface *iface = arg;

	if_fsm(iface, IF_EVT_WTIMER);
}

void
if_start_wait_timer(struct iface *iface)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = iface->dead_interval;
	if (evtimer_add(&iface->wait_timer, &tv) == -1)
		fatal("if_start_wait_timer");
}

void
if_stop_wait_timer(struct iface *iface)
{
	if (evtimer_del(&iface->wait_timer) == -1)
		fatal("if_stop_wait_timer");
}

/* actions */
int
if_act_start(struct iface *iface)
{
	struct in_addr		 addr;
	struct timeval		 now;

	if (!(iface->flags & IFF_UP) ||
	    (!LINK_STATE_IS_UP(iface->linkstate) &&
	    !(iface->if_type == IFT_CARP &&
	    iface->linkstate == LINK_STATE_DOWN)))
		return (0);

	if (iface->if_type == IFT_CARP && iface->passive == 0) {
		/* force passive mode on carp interfaces */
		log_warnx("if_act_start: forcing interface %s to passive",
		    iface->name);
		iface->passive = 1;
	}

	gettimeofday(&now, NULL);
	iface->uptime = now.tv_sec;

	/* loopback interfaces have a special state and are passive */
	if (iface->flags & IFF_LOOPBACK)
		iface->state = IF_STA_LOOPBACK;

	if (iface->passive) {
		/* for an update of stub network entries */
		orig_rtr_lsa(iface->area);
		return (0);
	}

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
		inet_aton(AllSPFRouters, &addr);
		if (if_join_group(iface, &addr))
			return (-1);
		iface->state = IF_STA_POINTTOPOINT;
		break;
	case IF_TYPE_VIRTUALLINK:
		iface->state = IF_STA_POINTTOPOINT;
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_NBMA:
		log_debug("if_act_start: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	case IF_TYPE_BROADCAST:
		inet_aton(AllSPFRouters, &addr);
		if (if_join_group(iface, &addr))
			return (-1);
		if (iface->priority == 0) {
			iface->state = IF_STA_DROTHER;
		} else {
			iface->state = IF_STA_WAITING;
			if_start_wait_timer(iface);
		}
		break;
	default:
		fatalx("if_act_start: unknown interface type");
	}

	/* hello timer needs to be started in any case */
	if_start_hello_timer(iface);
	return (0);
}

struct nbr *
if_elect(struct nbr *a, struct nbr *b)
{
	if (a->priority > b->priority)
		return (a);
	if (a->priority < b->priority)
		return (b);
	if (ntohl(a->id.s_addr) > ntohl(b->id.s_addr))
		return (a);
	return (b);
}

int
if_act_elect(struct iface *iface)
{
	struct in_addr	 addr;
	struct nbr	*nbr, *bdr = NULL, *dr = NULL;
	int		 round = 0;
	int		 changed = 0;
	int		 old_state;
	char		 b1[16], b2[16], b3[16], b4[16];

start:
	/* elect backup designated router */
	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr->priority == 0 || nbr == dr ||	/* not electable */
		    nbr->state & NBR_STA_PRELIM ||	/* not available */
		    nbr->dr.s_addr == nbr->addr.s_addr)	/* don't elect DR */
			continue;
		if (bdr != NULL) {
			/*
			 * routers announcing themselves as BDR have higher
			 * precedence over those routers announcing a
			 * different BDR.
			 */
			if (nbr->bdr.s_addr == nbr->addr.s_addr) {
				if (bdr->bdr.s_addr == bdr->addr.s_addr)
					bdr = if_elect(bdr, nbr);
				else
					bdr = nbr;
			} else if (bdr->bdr.s_addr != bdr->addr.s_addr)
					bdr = if_elect(bdr, nbr);
		} else
			bdr = nbr;
	}

	/* elect designated router */
	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr->priority == 0 || nbr->state & NBR_STA_PRELIM ||
		    (nbr != dr && nbr->dr.s_addr != nbr->addr.s_addr))
			/* only DR may be elected check priority too */
			continue;
		if (dr == NULL)
			dr = nbr;
		else
			dr = if_elect(dr, nbr);
	}

	if (dr == NULL) {
		/* no designated router found use backup DR */
		dr = bdr;
		bdr = NULL;
	}

	/*
	 * if we are involved in the election (e.g. new DR or no
	 * longer BDR) redo the election
	 */
	if (round == 0 &&
	    ((iface->self == dr && iface->self != iface->dr) ||
	    (iface->self != dr && iface->self == iface->dr) ||
	    (iface->self == bdr && iface->self != iface->bdr) ||
	    (iface->self != bdr && iface->self == iface->bdr))) {
		/*
		 * Reset announced DR/BDR to calculated one, so
		 * that we may get elected in the second round.
		 * This is needed to drop from a DR to a BDR.
		 */
		iface->self->dr.s_addr = dr->addr.s_addr;
		if (bdr)
			iface->self->bdr.s_addr = bdr->addr.s_addr;
		round = 1;
		goto start;
	}

	log_debug("if_act_elect: interface %s old dr %s new dr %s, "
	    "old bdr %s new bdr %s", iface->name,
	    iface->dr ? inet_ntop(AF_INET, &iface->dr->addr, b1, sizeof(b1)) :
	    "none", dr ? inet_ntop(AF_INET, &dr->addr, b2, sizeof(b2)) : "none",
	    iface->bdr ? inet_ntop(AF_INET, &iface->bdr->addr, b3, sizeof(b3)) :
	    "none", bdr ? inet_ntop(AF_INET, &bdr->addr, b4, sizeof(b4)) :
	    "none");

	/*
	 * After the second round still DR or BDR change state to DR or BDR,
	 * etc.
	 */
	old_state = iface->state;
	if (dr == iface->self)
		iface->state = IF_STA_DR;
	else if (bdr == iface->self)
		iface->state = IF_STA_BACKUP;
	else
		iface->state = IF_STA_DROTHER;

	/* TODO if iface is NBMA send all non eligible neighbors event Start */

	/*
	 * if DR or BDR changed issue a AdjOK? event for all neighbors > 2-Way
	 */
	if (iface->dr != dr || iface->bdr != bdr)
		changed = 1;

	iface->dr = dr;
	iface->bdr = bdr;

	if (changed) {
		inet_aton(AllDRouters, &addr);
		if (old_state & IF_STA_DRORBDR &&
		    (iface->state & IF_STA_DRORBDR) == 0) {
			if (if_leave_group(iface, &addr))
				return (-1);
		} else if ((old_state & IF_STA_DRORBDR) == 0 &&
		    iface->state & IF_STA_DRORBDR) {
			if (if_join_group(iface, &addr))
				return (-1);
		}

		LIST_FOREACH(nbr, &iface->nbr_list, entry) {
			if (nbr->state & NBR_STA_BIDIR)
				nbr_fsm(nbr, NBR_EVT_ADJ_OK);
		}

		orig_rtr_lsa(iface->area);
		if (iface->state & IF_STA_DR || old_state & IF_STA_DR)
			orig_net_lsa(iface);
	}

	if_start_hello_timer(iface);
	return (0);
}

int
if_act_reset(struct iface *iface)
{
	struct nbr		*nbr = NULL;
	struct in_addr		 addr;

	if (iface->passive) {
		/* for an update of stub network entries */
		orig_rtr_lsa(iface->area);
		return (0);
	}

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		/* try to cleanup */
		inet_aton(AllSPFRouters, &addr);
		if_leave_group(iface, &addr);
		if (iface->state & IF_STA_DRORBDR) {
			inet_aton(AllDRouters, &addr);
			if_leave_group(iface, &addr);
		}
		break;
	case IF_TYPE_VIRTUALLINK:
		/* nothing */
		break;
	case IF_TYPE_NBMA:
	case IF_TYPE_POINTOMULTIPOINT:
		log_debug("if_act_reset: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	default:
		fatalx("if_act_reset: unknown interface type");
	}

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr_fsm(nbr, NBR_EVT_KILL_NBR)) {
			log_debug("if_act_reset: error killing neighbor %s",
			    inet_ntoa(nbr->id));
		}
	}

	iface->dr = NULL;
	iface->bdr = NULL;

	ls_ack_list_clr(iface);
	stop_ls_ack_tx_timer(iface);
	if_stop_hello_timer(iface);
	if_stop_wait_timer(iface);

	/* send empty hello to tell everybody that we are going down */
	send_hello(iface);

	return (0);
}

struct ctl_iface *
if_to_ctl(struct iface *iface)
{
	static struct ctl_iface	 ictl;
	struct timeval		 tv, now, res;
	struct nbr		*nbr;

	memcpy(ictl.name, iface->name, sizeof(ictl.name));
	memcpy(&ictl.addr, &iface->addr, sizeof(ictl.addr));
	memcpy(&ictl.mask, &iface->mask, sizeof(ictl.mask));
	ictl.rtr_id.s_addr = ospfe_router_id();
	memcpy(&ictl.area, &iface->area->id, sizeof(ictl.area));
	if (iface->dr) {
		memcpy(&ictl.dr_id, &iface->dr->id, sizeof(ictl.dr_id));
		memcpy(&ictl.dr_addr, &iface->dr->addr, sizeof(ictl.dr_addr));
	} else {
		bzero(&ictl.dr_id, sizeof(ictl.dr_id));
		bzero(&ictl.dr_addr, sizeof(ictl.dr_addr));
	}
	if (iface->bdr) {
		memcpy(&ictl.bdr_id, &iface->bdr->id, sizeof(ictl.bdr_id));
		memcpy(&ictl.bdr_addr, &iface->bdr->addr,
		    sizeof(ictl.bdr_addr));
	} else {
		bzero(&ictl.bdr_id, sizeof(ictl.bdr_id));
		bzero(&ictl.bdr_addr, sizeof(ictl.bdr_addr));
	}
	ictl.ifindex = iface->ifindex;
	ictl.state = iface->state;
	ictl.mtu = iface->mtu;
	ictl.nbr_cnt = 0;
	ictl.adj_cnt = 0;
	ictl.baudrate = iface->baudrate;
	ictl.dead_interval = iface->dead_interval;
	ictl.fast_hello_interval = iface->fast_hello_interval;
	ictl.transmit_delay = iface->transmit_delay;
	ictl.hello_interval = iface->hello_interval;
	ictl.flags = iface->flags;
	ictl.metric = iface->metric;
	ictl.rxmt_interval = iface->rxmt_interval;
	ictl.type = iface->type;
	ictl.linkstate = iface->linkstate;
	ictl.if_type = iface->if_type;
	ictl.priority = iface->priority;
	ictl.passive = iface->passive;
	ictl.auth_type = iface->auth_type;
	ictl.auth_keyid = iface->auth_keyid;

	gettimeofday(&now, NULL);
	if (evtimer_pending(&iface->hello_timer, &tv)) {
		timersub(&tv, &now, &res);
		ictl.hello_timer = res;
	} else {
		ictl.hello_timer.tv_sec = -1;
	}

	if (iface->state != IF_STA_DOWN &&
	    iface->uptime != 0) {
		ictl.uptime = now.tv_sec - iface->uptime;
	} else
		ictl.uptime = 0;

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr == iface->self)
			continue;
		ictl.nbr_cnt++;
		if (nbr->state & NBR_STA_ADJFORM)
			ictl.adj_cnt++;
	}

	return (&ictl);
}

/* misc */
int
if_set_recvif(int fd, int enable)
{
	if (setsockopt(fd, IPPROTO_IP, IP_RECVIF, &enable,
	    sizeof(enable)) < 0) {
		log_warn("if_set_recvif: error setting IP_RECVIF");
		return (-1);
	}
	return (0);
}

void
if_set_sockbuf(int fd)
{
	int	bsize;

	bsize = 65535;
	while (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &bsize,
	    sizeof(bsize)) == -1)
		bsize /= 2;

	if (bsize != 65535)
		log_warnx("if_set_sockbuf: recvbuf size only %d", bsize);

	bsize = 65535;
	while (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &bsize,
	    sizeof(bsize)) == -1)
		bsize /= 2;

	if (bsize != 65535)
		log_warnx("if_set_sockbuf: sendbuf size only %d", bsize);
}

/*
 * only one JOIN or DROP per interface and address is allowed so we need
 * to keep track of what is added and removed.
 */
struct if_group_count {
	LIST_ENTRY(if_group_count)	entry;
	struct in_addr			addr;
	unsigned int			ifindex;
	int				count;
};

LIST_HEAD(,if_group_count) ifglist = LIST_HEAD_INITIALIZER(ifglist);

int
if_join_group(struct iface *iface, struct in_addr *addr)
{
	struct ip_mreq		 mreq;
	struct if_group_count	*ifg;

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		LIST_FOREACH(ifg, &ifglist, entry)
			if (iface->ifindex == ifg->ifindex &&
			    addr->s_addr == ifg->addr.s_addr)
				break;
		if (ifg == NULL) {
			if ((ifg = calloc(1, sizeof(*ifg))) == NULL)
				fatal("if_join_group");
			ifg->addr.s_addr = addr->s_addr;
			ifg->ifindex = iface->ifindex;
			LIST_INSERT_HEAD(&ifglist, ifg, entry);
		}

		if (ifg->count++ != 0)
			/* already joined */
			return (0);

		mreq.imr_multiaddr.s_addr = addr->s_addr;
		mreq.imr_interface.s_addr = iface->addr.s_addr;

		if (setsockopt(iface->fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
		    (void *)&mreq, sizeof(mreq)) < 0) {
			log_warn("if_join_group: error IP_ADD_MEMBERSHIP, "
			    "interface %s address %s", iface->name,
			    inet_ntoa(*addr));
			return (-1);
		}
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_NBMA:
		log_debug("if_join_group: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	default:
		fatalx("if_join_group: unknown interface type");
	}

	return (0);
}

int
if_leave_group(struct iface *iface, struct in_addr *addr)
{
	struct ip_mreq		 mreq;
	struct if_group_count	*ifg;

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		LIST_FOREACH(ifg, &ifglist, entry)
			if (iface->ifindex == ifg->ifindex &&
			    addr->s_addr == ifg->addr.s_addr)
				break;

		/* if interface is not found just try to drop membership */
		if (ifg) {
			if (--ifg->count != 0)
				/* others still joined */
				return (0);

			LIST_REMOVE(ifg, entry);
			free(ifg);
		}

		mreq.imr_multiaddr.s_addr = addr->s_addr;
		mreq.imr_interface.s_addr = iface->addr.s_addr;

		if (setsockopt(iface->fd, IPPROTO_IP, IP_DROP_MEMBERSHIP,
		    (void *)&mreq, sizeof(mreq)) < 0) {
			log_warn("if_leave_group: error IP_DROP_MEMBERSHIP, "
			    "interface %s address %s", iface->name,
			    inet_ntoa(*addr));
			return (-1);
		}
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_NBMA:
		log_debug("if_leave_group: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	default:
		fatalx("if_leave_group: unknown interface type");
	}

	return (0);
}

int
if_set_mcast(struct iface *iface)
{
	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		if (setsockopt(iface->fd, IPPROTO_IP, IP_MULTICAST_IF,
		    &iface->addr.s_addr, sizeof(iface->addr.s_addr)) < 0) {
			log_warn("if_set_mcast: error setting "
			    "IP_MULTICAST_IF, interface %s", iface->name);
			return (-1);
		}
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_NBMA:
		log_debug("if_set_mcast: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	default:
		fatalx("if_set_mcast: unknown interface type");
	}

	return (0);
}

int
if_set_mcast_loop(int fd)
{
	u_int8_t	loop = 0;

	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,
	    (char *)&loop, sizeof(loop)) < 0) {
		log_warn("if_set_mcast_loop: error setting IP_MULTICAST_LOOP");
		return (-1);
	}

	return (0);
}

int
if_set_ip_hdrincl(int fd)
{
	int	hincl = 1;

	if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &hincl, sizeof(hincl)) < 0) {
		log_warn("if_set_ip_hdrincl: error setting IP_HDRINCL");
		return (-1);
	}

	return (0);
}
@


1.80
log
@Improve ABR support especially for self-originated stub networks.
This seems to solve the last issues people reported when using ospfd
in multiple areas. OK sthen@@ prodding by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.79 2015/09/27 17:31:50 stsp Exp $ */
d201 1
a244 3
	struct ifreq	ifr;
	u_int		rdomain;

a253 12

	strlcpy(ifr.ifr_name, iface->name, sizeof(ifr.ifr_name));
	if (ioctl(iface->fd, SIOCGIFRDOMAIN, (caddr_t)&ifr) == -1)
		rdomain = 0;
	else {
		rdomain = ifr.ifr_rdomainid;
		if (setsockopt(iface->fd, SOL_SOCKET, SO_RTABLE,
		    &rdomain, sizeof(rdomain)) == -1)
			fatal("failed to set rdomain");
	}
	if (rdomain != xconf->rdomain)
		fatalx("interface rdomain mismatch");
@


1.79
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.78 2015/07/20 23:45:39 benno Exp $ */
d139 2
a140 1
	if (iface->state != old_state)
d142 1
@


1.78
log
@Fix a segfault at startup when if_change() ist called before
imsg_init() exposed by the second part of this diff which makes
carp(4) interfaces be recognized to be in "backup" mode on start-up.

Problem analyzed and fix provided by Johan Ymerson, thanks!

ok claudio@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.77 2015/07/19 01:59:32 benno Exp $ */
d201 1
a201 1
	iface->media_type = kif->media_type;
d343 1
a343 1
	    !(iface->media_type == IFT_CARP &&
d347 1
a347 1
	if (iface->media_type == IFT_CARP && iface->passive == 0) {
d642 1
a642 1
	ictl.mediatype = iface->media_type;
@


1.77
log
@revert previous

    Properly handle carp(4) interfaces in "backup" mode on start-up.

    Problem analyzed and fix provided by Johan Ymerson, thanks!

    ok claudio@@, benno@@

it breaks on systems without carp because iev_ospfe is not initiallized
at the time kif_init() is called in main.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.75 2012/05/14 10:17:21 sthen Exp $ */
d341 4
a344 2
	if (!((iface->flags & IFF_UP) &&
	    LINK_STATE_IS_UP(iface->linkstate)))
@


1.76
log
@Properly handle carp(4) interfaces in "backup" mode on start-up.

Problem analyzed and fix provided by Johan Ymerson, thanks!

ok claudio@@, benno@@
@
text
@d341 2
a342 4
	if (!(iface->flags & IFF_UP) ||
	    (!LINK_STATE_IS_UP(iface->linkstate) &&
	    !(iface->media_type == IFT_CARP &&
	    iface->linkstate == LINK_STATE_DOWN)))
@


1.75
log
@Don't display a nonsense uptime for an inactive interface. ldpd fix from
Rafael Zalamena on tech@@, I also applied it to ospfd.  ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.74 2011/07/04 04:34:14 claudio Exp $ */
d341 4
a344 2
	if (!((iface->flags & IFF_UP) &&
	    LINK_STATE_IS_UP(iface->linkstate)))
@


1.74
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.73 2011/06/21 17:31:07 mikeb Exp $ */
d654 2
a655 1
	if (iface->state != IF_STA_DOWN) {
@


1.73
log
@Convert SO_RTABLE's protocol level to the SOL_SOCKET;  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.72 2011/05/09 12:24:41 claudio Exp $ */
d342 1
a342 3
	    (LINK_STATE_IS_UP(iface->linkstate) ||
	    (iface->linkstate == LINK_STATE_UNKNOWN &&
	    iface->media_type != IFT_CARP))))
@


1.72
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.71 2011/05/06 13:50:37 claudio Exp $ */
d260 1
a260 1
		if (setsockopt(iface->fd, IPPROTO_IP, SO_RTABLE,
@


1.71
log
@Do not special case loopback interfaces on init. Instead force them
to IF_STA_LOOPBACK in if_act_start() this way they will repsect
IFF_UP on startup. Also remove a now no longer needed workaround
when reloading interfaces.
Initial diff provided by Patrick Coleman. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.70 2010/07/03 04:44:52 guenther Exp $ */
d170 1
@


1.70
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.69 2010/05/14 08:30:18 sthen Exp $ */
a191 1
		iface->state = IF_STA_LOOPBACK;
d353 7
a364 3

	gettimeofday(&now, NULL);
	iface->uptime = now.tv_sec;
@


1.69
log
@When merging interfaces after a config reload, the fsm state for interfaces
is forced into IF_STA_NEW so that if_init() can be called to setup timers etc.
When a loopback interface is added to the config, this means there's no way
to get to the correct state.

Fix by avoiding changing an existing IF_STA_LOOPBACK and forcing loopback
interfaces to be passive (otherwise skipping the if_init on an active
interface causes problems).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.68 2010/02/16 18:20:37 claudio Exp $ */
d256 1
a256 1
	if (ioctl(iface->fd, SIOCGIFRTABLEID, (caddr_t)&ifr) == -1)
d260 1
a260 1
		if (setsockopt(iface->fd, IPPROTO_IP, SO_RDOMAIN,
@


1.68
log
@When taking an interface down just try to do the cleanup. In cases where
the interface was removed or when the address changed leaving the multicast
groups will fail because that already happend. Fix if_leave_group() to
remove the refcount before doing the ioctl() so that the reference is
correctly removed. OK dlg@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.67 2010/02/16 08:39:05 dlg Exp $ */
d193 1
@


1.67
log
@implement support for fast hello packets.

if route-dead-time is set to "minimal" (rather than a number of
seconds), the dead time is set to 1 second and hellos are sent at
the interval specified by fast-hello-interval in msecs. this is non
standard wrt to the ospf rfc, but it does interoperate with at least
one other router vendor.

this allows much better responsiveness to l3 topology changes than
the standard intervals allow. if i yank a cable to one of my
upstreams, the routes adjust in a second rather than the default
of 40 i was running with before. the users dont even notice something
changed.

developed while working with joshua atterbury.
ok claudio@@ as part of a larger diff.
dedicated to zan rowe who thinks she is a bigger nerd than me.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.66 2009/09/30 14:39:07 claudio Exp $ */
d554 1
d556 1
a556 4
		if (if_leave_group(iface, &addr)) {
			log_warnx("if_act_reset: error leaving group %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
		}
d559 1
a559 5
			if (if_leave_group(iface, &addr)) {
				log_warnx("if_act_reset: "
				    "error leaving group %s, interface %s",
				    inet_ntoa(addr), iface->name);
			}
d778 8
a785 3
		if (ifg && --ifg->count != 0)
			/* others still joined */
			return (0);
a796 5

		if (ifg) {
			LIST_REMOVE(ifg, entry);
			free(ifg);
		}
d819 1
a819 1
			log_debug("if_set_mcast: error setting "
@


1.66
log
@Oups, these changes should not have been commited. Revert.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.64 2009/08/09 23:04:16 claudio Exp $ */
d281 4
a284 1
	tv.tv_sec = iface->hello_interval;
d635 1
d652 4
a655 3
		ictl.hello_timer = res.tv_sec;
	} else
		ictl.hello_timer = -1;
@


1.65
log
@Announce a stub network LSA for backup carp interfaces. This should help
when fail-over happens, since removing the better route will not result
in a blackhole until the update from the new master is processed.
Tested, OK and input sthen@@, phessler@@
@
text
@d142 2
a143 1
	if (old_state & IF_STA_MULTI && (iface->state & IF_STA_MULTI) == 0)
d145 2
a146 1
	if ((old_state & IF_STA_MULTI) == 0 && iface->state & IF_STA_MULTI)
@


1.64
log
@Scale both receive and send buffer on the raw socket. The default 8192
bytes is not enough for larger networks causing send errors because of
too big packets. OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.63 2009/06/05 04:12:52 claudio Exp $ */
d142 1
a142 2
	if (old_state & (IF_STA_MULTI | IF_STA_POINTTOPOINT) &&
	    (iface->state & (IF_STA_MULTI | IF_STA_POINTTOPOINT)) == 0)
d144 1
a144 2
	if ((old_state & (IF_STA_MULTI | IF_STA_POINTTOPOINT)) == 0 &&
	    iface->state & (IF_STA_MULTI | IF_STA_POINTTOPOINT))
@


1.63
log
@Preliminary rdomain support, all hacked up by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.62 2009/04/26 12:48:06 sthen Exp $ */
d681 1
a681 1
if_set_recvbuf(int fd)
d689 11
@


1.62
log
@comment typos; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.61 2009/01/01 22:50:13 claudio Exp $ */
d241 3
d253 12
@


1.61
log
@Remove some other useless debug messages that just add unneeded noise.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.60 2007/09/11 16:02:55 claudio Exp $ */
d438 1
a438 1
		/* no designate router found use backup DR */
@


1.60
log
@Switch some more baudrates to 64 bit and initialize iface->baudrate.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.59 2007/05/29 22:08:25 claudio Exp $ */
a217 2
	log_debug("if_del: interface %s", iface->name);

d325 1
a325 3
	    iface->media_type != IFT_CARP)))) {
		log_debug("if_act_start: interface %s link down",
		    iface->name);
a326 1
	}
@


1.59
log
@Demote support for ospfd. It is possible to specify a demote group on
interfaces and areas. With this carp setups using ospfd are more reliable
because we can fail over if the OSPF connectivity is (partially) lost.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.58 2007/02/01 13:25:28 claudio Exp $ */
d201 1
@


1.58
log
@whitespace cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.57 2007/02/01 13:06:00 claudio Exp $ */
d142 7
d219 4
d251 2
@


1.57
log
@If an interface is going down send out an empty OSPF hello packet so that
all other routers will drop the session immediatly instead of waiting for
the timeout that is normaly 40 sec. This reduces fail-over time massivly
and does not hurt anymore since we are now able to reload the configuration
on the fly. OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.56 2007/01/24 14:08:28 claudio Exp $ */
d567 1
a567 1
	
d683 1
a683 1
	struct ip_mreq	 	 mreq;
d732 1
a732 1
	struct ip_mreq	 	 mreq;
@


1.56
log
@When deleting a neighbor or a interface make sure that no events are pending.
Needed for reload support.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.55 2006/11/28 19:21:15 reyk Exp $ */
d567 3
@


1.55
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.54 2006/11/17 08:55:31 claudio Exp $ */
d215 7
@


1.54
log
@Support for multiple networks on one interface. Until now only the main
address of a interface could be used. Now it is possible to specify a
interface more than once if multiple networks are configured. An alternative
network can be specified via e.g. interface em0:10.0.5.1. The old interface
syntax without the IP still works and uses the main/first configured IP
address.
ospfd now needs to include the IP header on outgoing messages as it is not
possible to specifiy the source address in sendto(2). Additionally all
multicast joins and leaves have to be tracked.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.53 2006/09/27 14:37:38 claudio Exp $ */
d304 1
a304 1
	    (iface->linkstate == LINK_STATE_UP ||
@


1.53
log
@Use IP_RECVIF to get the incomming interface of OSPF packets. Now we use
the source address and the interface index to find the corresponding
struct interface which is less error prone. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.52 2006/08/18 11:54:28 claudio Exp $ */
d151 1
a151 1
if_new(struct kif *kif)
a152 1
	struct sockaddr_in	*sain;
a153 2
	struct ifreq		*ifr;
	int			 s;
a176 8
	if ((ifr = calloc(1, sizeof(*ifr))) == NULL)
		err(1, "if_new: calloc");

	/* set up ifreq */
	strlcpy(ifr->ifr_name, kif->ifname, sizeof(ifr->ifr_name));
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		err(1, "if_new: socket");

d195 3
a197 13
	/* get address */
	if (ioctl(s, SIOCGIFADDR, ifr) < 0)
		err(1, "if_new: cannot get address");
	sain = (struct sockaddr_in *)&ifr->ifr_addr;
	iface->addr = sain->sin_addr;

	/* get mask */
	if (ioctl(s, SIOCGIFNETMASK, ifr) < 0)
		err(1, "if_new: cannot get mask");
	sain = (struct sockaddr_in *)&ifr->ifr_addr;
	iface->mask = sain->sin_addr;

	/* get p2p dst address */
d199 1
a199 4
		if (ioctl(s, SIOCGIFDSTADDR, ifr) < 0)
			err(1, "if_new: cannot get dst addr");
		sain = (struct sockaddr_in *)&ifr->ifr_addr;
		iface->dst = sain->sin_addr;
a201 3
	free(ifr);
	close(s);

d331 1
a331 3
		if (if_join_group(iface, &addr)) {
			log_warnx("if_act_start: error joining group %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
a332 1
		}
d345 1
a345 3
		if (if_join_group(iface, &addr)) {
			log_warnx("if_act_start: error joining group %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
a346 1
		}
d483 1
a483 4
			if (if_leave_group(iface, &addr)) {
				log_warnx("if_act_elect: "
				    "error leaving group %s, interface %s",
				    inet_ntoa(addr), iface->name);
a484 1
			}
d487 1
a487 4
			if (if_join_group(iface, &addr)) {
				log_warnx("if_act_elect: "
				    "error joining group %s, interface %s",
				    inet_ntoa(addr), iface->name);
a488 1
			}
a635 25
if_set_mcast_ttl(int fd, u_int8_t ttl)
{
	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,
	    (char *)&ttl, sizeof(ttl)) < 0) {
		log_warn("if_set_mcast_ttl: error setting "
		    "IP_MULTICAST_TTL to %d", ttl);
		return (-1);
	}

	return (0);
}

int
if_set_tos(int fd, int tos)
{
	if (setsockopt(fd, IPPROTO_IP, IP_TOS,
	    (int *)&tos, sizeof(tos)) < 0) {
		log_warn("if_set_tos: error setting IP_TOS to 0x%x", tos);
		return (-1);
	}

	return (0);
}

int
d657 13
d673 2
a674 1
	struct ip_mreq	 mreq;
d679 16
d700 3
a702 2
			log_debug("if_join_group: error IP_ADD_MEMBERSHIP, "
			    "interface %s", iface->name);
d722 2
a723 1
	struct ip_mreq	 mreq;
d728 10
d743 3
a745 2
			log_debug("if_leave_group: error IP_DROP_MEMBERSHIP, "
			    "interface %s", iface->name);
d748 5
d801 13
@


1.52
log
@Correctly leave the all AllDRouters group (224.0.0.6) if the interface was
in state DR or BACKUP. Found while analizing PR5192 with norby@@ -- seems to
help but there is still a issue left. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.51 2006/04/24 20:18:03 claudio Exp $ */
d698 11
@


1.51
log
@Fix parser to match current behaviour and make auth-type et al. part of the
global and per area defaults. With this it is now possible to define one
set of auth-md keys and use them in every defined interface. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.50 2006/04/16 11:40:54 henning Exp $ */
d565 8
@


1.50
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.49 2006/03/23 18:37:34 norby Exp $ */
d165 1
a165 1
	md_list_init(iface);
d244 1
a244 1
	md_list_clr(iface);
@


1.49
log
@List interfaces they way we list neighbors etc.
This makes it much easier to grep in the output.
The original format of "show interface" can be seen with
"show interface detail".

help and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.48 2006/03/15 13:25:33 claudio Exp $ */
d638 1
a638 1
 	ictl.mediatype = iface->media_type;
@


1.48
log
@Looks like auth-type simple was busted since a long time. We bcmp() a
c string with a lenght <= 8 with a buffer of size 8. Now in some cases
there can be trailing garbage after the c-string and so the bcmp() fails.
Found by Sergey Matveychuk who provided a similar patch.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.47 2006/03/13 09:36:06 claudio Exp $ */
d638 1
@


1.47
log
@The return value of the start/stop timer functions is almost never checked.
Switch them to void functions and check if evtimer_add/del fails -- in which
case we fatal() as there is no useful way to recover in such an event.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.46 2006/03/09 18:11:34 norby Exp $ */
a244 1
	free(iface->auth_key);
@


1.46
log
@Track interface uptime.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.45 2006/03/09 15:43:21 claudio Exp $ */
d42 3
a44 3
int		 if_start_hello_timer(struct iface *);
int		 if_stop_hello_timer(struct iface *);
int		 if_stop_wait_timer(struct iface *);
d46 2
a47 2
int		 if_start_wait_timer(struct iface *);
int		 if_stop_wait_timer(struct iface *);
d276 2
a277 1
	evtimer_add(&iface->hello_timer, &tv);
d280 1
a280 1
int
d286 2
a287 1
	return (evtimer_add(&iface->hello_timer, &tv));
d290 1
a290 1
int
d293 2
a294 1
	return (evtimer_del(&iface->hello_timer));
d306 1
a306 1
int
d313 2
a314 1
	return (evtimer_add(&iface->wait_timer, &tv));
d317 1
a317 1
int
d320 2
a321 1
	return (evtimer_del(&iface->wait_timer));
a364 3
		if (if_start_hello_timer(iface))
			log_warnx("if_act_start: cannot schedule hello "
			    "timer, interface %s", iface->name);
a367 3
		if (if_start_hello_timer(iface))
			log_warnx("if_act_start: cannot schedule hello "
			    "timer, interface %s", iface->name);
a382 3
			if (if_start_hello_timer(iface))
				log_warnx("if_act_start: cannot schedule hello "
				    "timer, interface %s", iface->name);
d385 1
a385 6
			if (if_start_hello_timer(iface))
				log_warnx("if_act_start: cannot schedule hello "
				    "timer, interface %s", iface->name);
			if (if_start_wait_timer(iface))
				log_warnx("if_act_start: cannot schedule wait "
				    "timer, interface %s", iface->name);
d392 2
d543 1
a543 5
	if (if_start_hello_timer(iface)) {
		log_warnx("if_act_elect: cannot schedule hello_timer");
		return (-1);
	}

d591 3
a593 17
	if (stop_ls_ack_tx_timer(iface)) {
		log_warnx("if_act_reset: error removing ls_ack_tx_timer, "
		    "interface %s", iface->name);
		return (-1);
	}

	if (if_stop_hello_timer(iface)) {
		log_warnx("if_act_reset: error removing hello_timer, "
		    "interface %s", iface->name);
		return (-1);
	}

	if (if_stop_wait_timer(iface)) {
		log_warnx("if_act_reset: error removing wait_timer, "
		    "interface %s", iface->name);
		return (-1);
	}
@


1.45
log
@Move *_name functions to log.c and use these for both ospfd and ospfctl.
Stuff that is only used in ospfd debug messages is simplified.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.44 2006/03/09 13:37:04 claudio Exp $ */
d324 1
d348 3
d675 5
@


1.44
log
@KNF, remove some unneded type casts and add some ARGSUSED. This makes lint
almost happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.43 2006/03/09 09:32:37 claudio Exp $ */
a89 14
const char * const if_type_names[] = {
	"POINTOPOINT",
	"BROADCAST",
	"NBMA",
	"POINTOMULTIPOINT",
	"VIRTUALLINK"
};

const char * const if_auth_names[] = {
	"none",
	"simple",
	"crypt"
};

d110 1
a110 1
		    if_event_name(event), if_state_name(old_state));
d131 1
a131 1
		    "event %s, state %s", iface->name, if_event_name(event),
d144 1
a144 1
	    if_event_name(event), if_action_name(iface_fsm[i].action),
a680 48
}

/* names */
const char *
if_state_name(int state)
{
	switch (state) {
	case IF_STA_DOWN:
		return ("DOWN");
	case IF_STA_LOOPBACK:
		return ("LOOPBACK");
	case IF_STA_WAITING:
		return ("WAITING");
	case IF_STA_POINTTOPOINT:
		return ("POINT-TO-POINT");
	case IF_STA_DROTHER:
		return ("DROTHER");
	case IF_STA_BACKUP:
		return ("BACKUP");
	case IF_STA_DR:
		return ("DR");
	default:
		return ("UNKNOWN");
	}
}

const char *
if_event_name(int event)
{
	return (if_event_names[event]);
}

const char *
if_action_name(int action)
{
	return (if_action_names[action]);
}

const char *
if_type_name(int type)
{
	return (if_type_names[type]);
}

const char *
if_auth_name(int type)
{
	return (if_auth_names[type]);
@


1.43
log
@if_event_names is only used by interface.c so move it there.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.42 2006/03/08 15:35:07 claudio Exp $ */
d221 1
a221 1
	if (ioctl(s, SIOCGIFADDR, (caddr_t)ifr) < 0)
d223 1
a223 1
	sain = (struct sockaddr_in *) &ifr->ifr_addr;
d227 1
a227 1
	if (ioctl(s, SIOCGIFNETMASK, (caddr_t)ifr) < 0)
d229 1
a229 1
	sain = (struct sockaddr_in *) &ifr->ifr_addr;
d234 1
a234 1
		if (ioctl(s, SIOCGIFDSTADDR, (caddr_t)ifr) < 0)
d236 1
a236 1
		sain = (struct sockaddr_in *) &ifr->ifr_addr;
d278 1
d308 1
d851 1
a851 2
		    (char *)&iface->addr.s_addr,
		    sizeof(iface->addr.s_addr)) < 0) {
@


1.42
log
@Spaces and other minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.41 2006/01/05 15:53:36 claudio Exp $ */
d71 11
@


1.41
log
@Make ospfd respect carp(4) interfaces and their weird behaviour. They will
not be used to connect to a OSPF cloud and forced to be passive. With this
ospfd will only announce the carp interface route if the interface is master.
So you can connect a LAN in a redundant way to your ospf backbone. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.40 2005/12/15 20:29:06 claudio Exp $ */
d110 1
a110 1
		/* XXX event outside of the defined fsm, ignore it. */
d766 1
a766 1
		bsize /= 2; 
@


1.40
log
@Simpify iface_del() and nbr_del(). make them void funtions as they can not fail
and do not remove a element twice in iface_del(). OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.39 2005/12/04 20:49:47 norby Exp $ */
d27 1
a164 1
	iface->passive = 1;
d207 1
d327 3
a329 1
	    (iface->linkstate != LINK_STATE_DOWN))) {
d335 13
d560 6
@


1.39
log
@Increase the receive buffer of the raw socket.

Prevents some of the retransmitting during bulk ls update transfers.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.38 2005/10/19 21:43:20 claudio Exp $ */
d234 1
a234 1
int
d242 1
a242 3
	iface->self = NULL; /* trick neighbor.c code to remove self too */
	while ((nbr = LIST_FIRST(&iface->nbr_list)) != NULL) {
		LIST_REMOVE(nbr, entry);
a243 1
	}
d248 1
a248 2

	return (-1);
@


1.38
log
@fix some spellings in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.37 2005/10/18 15:40:36 claudio Exp $ */
d738 11
@


1.37
log
@Cleanup interface code a minimal bit. There is no need for if_shutdown(),
especially it got called in the wrong place.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.36 2005/10/12 09:25:57 claudio Exp $ */
d420 1
a420 1
			 * routers announcing themselfs as BDR have higher
d463 1
a463 1
		 * Reset announced DR/DBR to calculated one, so
@


1.36
log
@If router is DR or BDR join the AllDRouter list (and leave it if otherwise).
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.35 2005/09/28 20:38:31 msf Exp $ */
a266 10
}

int
if_shutdown(struct ospfd_conf *xconf)
{
	int	ret = 0;

	ret = close(xconf->ospf_socket);

	return (ret);
@


1.35
log
@- use proper function name in log message

ok norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.34 2005/09/24 21:10:32 msf Exp $ */
d414 1
d516 19
d539 1
@


1.34
log
@- add auth_type and auth_keyid to struct ctl_iface
- have ospfctl tell us when we are using authentication with 'show interface'

ok claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.33 2005/09/17 20:03:35 msf Exp $ */
d110 1
a110 1
		log_debug("fsm_if: interface %s, "
d132 1
a132 1
		log_debug("fsm_if: error changing state for interface %s, "
d144 1
a144 1
	log_debug("fsm_if: event %s resulted in action %s and changing "
@


1.33
log
@- add get_rtr_id() based on bgpd's get_bgpid()
- remove rtr_id from struct iface we don't need to keep a copy of this value
  per interface
- replace all references to iface->rtr_id.s_addr with calls to ospfe_rtr_id()

ok claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.32 2005/09/15 19:42:51 claudio Exp $ */
d634 2
@


1.32
log
@Correctly handle loopback interfaces. Mark them as point-to-point networks
that are in loopback mode. With this it is possible to use lo1 to hold the
loopback address of the router as done often on ciscos etc.
Problem found and fix tested by jakob@@ OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.31 2005/08/30 21:07:58 claudio Exp $ */
d601 1
a601 1
	memcpy(&ictl.rtr_id, &iface->rtr_id, sizeof(ictl.rtr_id));
@


1.31
log
@Fix one of the most fragile part of ospfd -- the interface election code.
One of the main problems is that the RFC is very unprecise about the process
and so a bit of guessing and "violating" the RFC is needed.
The problem was that on fast restarts ospfd computed wrong DR and BDR
routers.  OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.30 2005/06/21 20:50:26 claudio Exp $ */
d192 1
a192 1
	if ((kif->flags & IFF_POINTOPOINT))
d194 2
a195 2
	if ((kif->flags & IFF_BROADCAST) &&
	    (kif->flags & IFF_MULTICAST))
d197 4
d221 1
a221 1
	if (iface->type == IF_TYPE_POINTOPOINT) {
@


1.30
log
@Backout/Disable the change introduced in rev. 1.26. Don't start the hello
timer in IF_STA_WAITING. We are not ready for this because the RFC is totaly
fucked up in that specific area causing many issues on fast reloads.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.29 2005/06/13 08:52:47 claudio Exp $ */
a379 1
#if 0
a382 1
#endif
@


1.29
log
@One additional if_act_elect bug. Neighbors in preliminary state (down, attempt
and init) are not electable not only neighbors that are in state down.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.28 2005/06/13 08:48:16 claudio Exp $ */
d380 1
d384 1
@


1.28
log
@Doh. Fix another stupid copy paste typo. Once again BDR != DR.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.27 2005/06/13 08:44:24 claudio Exp $ */
d420 1
a420 1
		    nbr->state & NBR_STA_DOWN ||	/* not available */
d442 1
a442 1
		if (nbr->priority == 0 || nbr->state & NBR_STA_DOWN ||
@


1.27
log
@add a new fsm transition for IF_EVT_WTIMER in state IF_STA_ANY that simply
ignores the event. This removes the warning "fsm_if: interface em0, event
WAITTIMER not expected in state DROTHER" in case of a quick startup.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.26 2005/06/13 08:41:16 claudio Exp $ */
d474 1
a474 1
			iface->self->bdr.s_addr = dr->addr.s_addr;
@


1.26
log
@start hello timer even if in state IF_STA_WAITING (this makes the startup much
faster and follows the RFC more closely).
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.25 2005/05/27 02:14:20 norby Exp $ */
d59 1
@


1.25
log
@Virtual link support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.24 2005/05/26 22:31:28 norby Exp $ */
d379 3
@


1.24
log
@Make interface election less verbose.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.23 2005/05/26 19:54:49 norby Exp $ */
d68 2
d171 9
d261 1
a261 17
	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
		iface->fd = xconf->ospf_socket;
		break;
	case IF_TYPE_BROADCAST:
		/* all bcast interfaces use the same socket */
		iface->fd = xconf->ospf_socket;
		break;
	case IF_TYPE_NBMA:
		break;
	case IF_TYPE_POINTOMULTIPOINT:
		break;
	case IF_TYPE_VIRTUALLINK:
		break;
	default:
		fatalx("if_init: unknown interface type");
	}
d354 6
a360 1
	case IF_TYPE_VIRTUALLINK:
d539 3
a543 1
	case IF_TYPE_VIRTUALLINK:
@


1.23
log
@Simplify and cleanup passive interface handling.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.22 2005/05/26 18:46:16 norby Exp $ */
a411 2
	log_debug("if_act_elect: interface %s", iface->name);

d435 1
a435 2
	log_debug("if_act_elect: bdr %s", bdr ?
	    inet_ntop(AF_INET, &bdr->addr, b4, sizeof(b4)) : "none");
d447 1
a447 2
	log_debug("if_act_elect: dr %s", dr ?
	    inet_ntop(AF_INET, &dr->addr, b4, sizeof(b4)) : "none");
a470 1
		log_debug("if_act_elect: round two");
@


1.22
log
@Support dumping the configuration the way bgpd(8) does it.

This makes it possible to have ospfd(8) parse a configuration file and
display the parsed result.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.21 2005/05/12 10:14:39 claudio Exp $ */
d289 3
a291 5
	if (!iface->passive) {
		timerclear(&tv);
		tv.tv_sec = iface->hello_interval;
		evtimer_add(&iface->hello_timer, &tv);
	}
a337 6

	if (iface->passive) {
		log_debug("if_act_start: cannot start passive interface %s",
		    iface->name);
		return (-1);
	}
@


1.21
log
@Fix multiple bugs in if_act_elect(). In some cases DR were set wrongly
because of a stupid typo that I fixed in rev. 1.6 but forgot to fix the
bug I introduced before because of that typo. Also reset the DR/BDR fields
of iface->self when going to round two. Without the reset it is e.g. not
possible to drop from DR to BDR.
Issue found and patch tested by Stephen Marley
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.20 2005/04/25 11:31:50 claudio Exp $ */
d84 3
a86 3
	"NONE",
	"SIMPLE",
	"CRYPT"
@


1.20
log
@Call if_init() later and for each interface separately.
Move code from if_act_start() to if_init() that needs to be called only
once per interface. Especially event_set should be called only once as it
initializes struct event and so may cause corruption of the event queue if
called twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.19 2005/04/25 09:55:18 claudio Exp $ */
d430 5
d453 1
a453 1
		if (dr == NULL || bdr == NULL)
d475 8
@


1.19
log
@Move the creation of the ospf_socket from if_init() directly into ospfe().
This makes it possible to call if_init() at a much later time.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.18 2005/04/25 09:28:45 claudio Exp $ */
d239 2
a240 2
int
if_init(struct ospfd_conf *xconf)
d242 2
a243 2
	struct area	*area = NULL;
	struct iface	*iface = NULL;
d245 21
a265 20
	LIST_FOREACH(area, &xconf->area_list, entry) {
		LIST_FOREACH(iface, &area->iface_list, entry) {
			switch (iface->type) {
			case IF_TYPE_POINTOPOINT:
				iface->fd = xconf->ospf_socket;
				break;
			case IF_TYPE_BROADCAST:
				/* all bcast interfaces use the same socket */
				iface->fd = xconf->ospf_socket;
				break;
			case IF_TYPE_NBMA:
				break;
			case IF_TYPE_POINTOMULTIPOINT:
				break;
			case IF_TYPE_VIRTUALLINK:
				break;
			default:
				fatalx("if_init: unknown interface type");
			}
		}
a266 2

	return (0);
a352 9

	/* init the dummy local neighbor */
	if (iface->self == NULL)
		iface->self = nbr_new(ospfe_router_id(), iface, 1);

	/* set event handlers for interface */
	evtimer_set(&iface->lsack_tx_timer, ls_ack_tx_timer, iface);
	evtimer_set(&iface->hello_timer, if_hello_timer, iface);
	evtimer_set(&iface->wait_timer, if_wait_timer, iface);
@


1.18
log
@Call if_init() in ospfe only, neither the rde nor the parent need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.17 2005/04/25 09:09:56 claudio Exp $ */
a47 3
int		 if_set_mcast_ttl(int, u_int8_t);
int		 if_set_tos(int, int);
int		 if_set_mcast_loop(int);
a243 18

	if ((xconf->ospf_socket = socket(AF_INET, SOCK_RAW,
	    IPPROTO_OSPF)) == -1) {
		log_warn("if_init: error creating socket");
		return (-1);
	}

	/* set some defaults */
	if (if_set_mcast_ttl(xconf->ospf_socket,
	    IP_DEFAULT_MULTICAST_TTL) == -1)
		return (-1);

	if (if_set_mcast_loop(xconf->ospf_socket) == -1)
		return (-1);

	if (if_set_tos(xconf->ospf_socket, IPTOS_PREC_INTERNETCONTROL) == -1)
		return (-1);

@


1.17
log
@Change order of execution in if_act_reset(). First notify all neighbor
that the interface gets reset (NBR_EVT_KILL_NBR) and than clear all
timers of the interface. The nbr_fsm() may start some of the timers which
has strange results.
Tested by Philip Olsson.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.16 2005/04/19 07:34:52 claudio Exp $ */
a247 1
	/* XXX wrong as hell */
@


1.16
log
@Don't call event_set() before event_init().
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.15 2005/03/31 20:13:22 norby Exp $ */
a561 18
	if (if_stop_hello_timer(iface)) {
		log_warnx("if_act_reset: error removing hello_timer, "
		    "interface %s", iface->name);
		return (-1);
	}

	if (if_stop_wait_timer(iface)) {
		log_warnx("if_act_reset: error removing wait_timer, "
		    "interface %s", iface->name);
		return (-1);
	}

	if (stop_ls_ack_tx_timer(iface)) {
		log_warnx("if_act_reset: error removing ls_ack_tx_timer, "
		    "interface %s", iface->name);
		return (-1);
	}

d590 19
@


1.15
log
@Better crypt sequence number initialization.

Suggested by henning@@

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.14 2005/03/31 19:32:10 norby Exp $ */
a171 2
	evtimer_set(&iface->lsack_tx_timer, ls_ack_tx_timer, iface);

a214 4
	/* set event handlers for interface */
	evtimer_set(&iface->hello_timer, if_hello_timer, iface);
	evtimer_set(&iface->wait_timer, if_wait_timer, iface);

d381 4
a384 2
	/* up interface */
		/* ... */
@


1.14
log
@Add support for crypt authentication (MD5).

ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.13 2005/03/29 17:26:35 norby Exp $ */
d170 1
a170 1
	iface->crypt_seq_num = arc4random();
@


1.13
log
@The RFC never mentions anything about transfer, this should be transmit.

From Jason Ackley (thanks).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.12 2005/03/22 22:13:48 norby Exp $ */
d168 3
d242 2
@


1.12
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.11 2005/03/11 12:26:50 henning Exp $ */
d645 1
a645 1
	ictl.transfer_delay = iface->transfer_delay;
@


1.11
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.10 2005/03/07 10:28:14 claudio Exp $ */
d164 1
a164 1
	iface->passive = true;
@


1.10
log
@Track interface state (up/down) and media status. Simplify the code a bit
by using the kif/kroute info while allocating interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.9 2005/02/16 15:23:33 norby Exp $ */
a180 1
	
@


1.9
log
@Support point to point links.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.8 2005/02/09 20:40:23 claudio Exp $ */
d112 1
a112 1
		    nbr_event_name(event), if_state_name(old_state));
d153 1
a153 1
if_new(char *name, unsigned int idx)
d156 1
a156 1
	struct iface		*iface = NULL;
d161 1
a161 1
		errx(1, "if_new: calloc");
d171 1
a171 1
	strlcpy(iface->name, name, sizeof(iface->name));
d174 1
a174 1
		errx(1, "if_new: calloc");
d177 1
a177 1
	strlcpy(ifr->ifr_name, name, sizeof(ifr->ifr_name));
d179 1
a179 1
		errx(1, "if_new: socket");
d181 1
d183 1
a183 3
	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)ifr) < 0)
		errx(1, "if_new: cannot get type");
	if ((ifr->ifr_flags & IFF_POINTOPOINT))
d185 2
a186 3

	if ((ifr->ifr_flags & IFF_BROADCAST) &&
	    (ifr->ifr_flags & IFF_MULTICAST))
d189 5
a193 1
	iface->flags = ifr->ifr_flags;
d197 1
a197 1
		errx(1, "if_new: cannot get address");
d203 1
a203 1
		errx(1, "if_new: cannot get mask");
d210 1
a210 1
			errx(1, "if_new: cannot get dst addr");
a214 7
	/* get mtu */
	if (ioctl(s, SIOCGIFMTU, (caddr_t)ifr) < 0)
		errx(1, "if_new: cannot get mtu");

	iface->mtu = ifr->ifr_mtu;
	iface->ifindex = idx;

d372 7
d380 2
a381 1
	iface->self = nbr_new(ospfe_router_id(), iface, 1);
a603 5
	}

	while ((nbr = LIST_FIRST(&iface->nbr_list))) {
		LIST_REMOVE(nbr, entry);
		nbr_del(nbr);
@


1.8
log
@Rework of self originated LSA. First of all the code to generate the LSA
is rewritten to use the dynamic buffer api introduced lately.
Add missing parts in the RDE to merge these LSA originated from the OE into
the LSDB with correct seq_num, etc.
Add hooks to the neighbor and interface fsm so that the LSA get updated if
needed. This is not perfect, still many things are missing. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.7 2005/02/09 17:41:16 claudio Exp $ */
d95 3
a97 3
	int			old_state;
	int			new_state = 0;
	int			i, ret = 0;
d205 8
d278 1
d385 11
a578 3
		log_debug("if_act_reset: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
d756 1
a767 1
	case IF_TYPE_POINTOPOINT:
d787 1
a798 1
	case IF_TYPE_POINTOPOINT:
d816 1
a825 1
	case IF_TYPE_POINTOPOINT:
@


1.7
log
@Fix interface fsm by inserting dummy events and actions as placeholder
for 0. Action 0 was IF_ACT_STRT and that's why if_act_start() got called
multiple times. The inappropriate hack from the previous commit is no
longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.6 2005/02/09 16:37:29 claudio Exp $ */
d141 3
d247 1
d426 1
d496 1
d515 1
a515 1
	if (changed)
d520 4
@


1.6
log
@Don't elect neighbors that are down and fix a stupid copy-pasto.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.5 2005/02/09 16:32:32 claudio Exp $ */
d62 1
a62 1
    {IF_STA_WAITING,	IF_EVT_NBR_CHNG,	0,		0},
d64 1
a64 1
    {IF_STA_ANY,	IF_EVT_NBR_CHNG,	0,		0},
d67 2
a68 2
    {IF_STA_LOOPBACK,	IF_EVT_UNLOOP,		0,		IF_STA_DOWN},
    {-1,		0,			-1,		0},
d72 1
d126 1
a126 1
	default:
d365 1
a365 2
	if (iface->self == NULL)
		iface->self = nbr_new(ospfe_router_id(), iface, 1);
d374 1
d383 1
a396 4
	case IF_TYPE_NBMA:
		log_debug("if_act_start: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
@


1.5
log
@Initialize iface->self only once. if_act_start() may be called multiple
times for a interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.4 2005/02/07 05:51:00 david Exp $ */
d432 1
d450 2
a451 2
		if (nbr->priority == 0 || (nbr != dr &&
		    nbr->dr.s_addr != nbr->addr.s_addr))
d457 1
a457 1
			dr = if_elect(bdr, nbr);
@


1.4
log
@spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.3 2005/02/02 19:15:07 henning Exp $ */
d364 2
a365 1
	iface->self = nbr_new(ospfe_router_id(), iface, 1);
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d465 1
a465 1
	/* 
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d634 1
a634 1
 		ictl.hello_timer = res.tv_sec;
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * Copyright (c) 2004, 2005 Esben Norby <esben.norby@@ericsson.com>
@

