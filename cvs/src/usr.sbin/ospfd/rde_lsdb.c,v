head	1.50;
access;
symbols
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.50.0.8
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.49.0.10
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.49.0.6
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.48.0.4
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.47.0.6
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.4
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.44.0.4
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.42.0.6
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.40.0.4
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10;
locks; strict;
comment	@ * @;


1.50
date	2015.11.22.13.09.10;	author claudio;	state Exp;
branches;
next	1.49;
commitid	pxM0r18iZwdhX0Ks;

1.49
date	2013.08.14.20.16.09;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2013.01.17.10.07.56;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2011.05.02.11.45.55;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2011.03.24.08.36.00;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.19.09.11.08;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2009.11.12.22.29.15;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.07.21.16.36;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2008.11.24.18.28.02;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2008.02.11.12.37.37;	author norby;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.16.21.03.31;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.10.13.26.39;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2007.01.29.13.04.13;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.24.10.48.47;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.13.13.24.09;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.08.21.28.08;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.30.05.25.33;	author norby;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.29.16.50.36;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.25.08.06.32;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.22.16.01.20;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.13.09.36.06;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.08.15.35.07;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.23.16.16.27;	author norby;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.15.11.47.40;	author norby;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.09.20.47.20;	author norby;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.05.15.10.57;	author norby;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.04.11.36.31;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.04.10.50.54;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.12.09.08.25;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.06.17.06.44;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.08.12.22.48;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.25.15.21.39;	author norby;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.25.08.06.57;	author david;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.24.20.54.33;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.24.07.13.00;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.24.06.55.21;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.12.20.43.14;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.12.19.10.12;	author norby;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.12.10.26.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.27.08.21.15;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.09.22.58.08;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.09.20.44.37;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.09.20.40.23;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.08.12.56.48;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.07.05.51.00;	author david;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.04.07.38.04;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.29.15;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Improve ABR support especially for self-originated stub networks.
This seems to solve the last issues people reported when using ospfd
in multiple areas. OK sthen@@ prodding by deraadt@@
@
text
@/*	$OpenBSD: rde_lsdb.c,v 1.49 2013/08/14 20:16:09 claudio Exp $ */

/*
 * Copyright (c) 2004, 2005 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/tree.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ospf.h"
#include "ospfd.h"
#include "rde.h"
#include "log.h"

struct vertex	*vertex_get(struct lsa *, struct rde_nbr *, struct lsa_tree *);

int		 lsa_router_check(struct lsa *, u_int16_t);
struct vertex	*lsa_find_tree(struct lsa_tree *, u_int16_t, u_int32_t,
		    u_int32_t);
void		 lsa_timeout(int, short, void *);
void		 lsa_refresh(struct vertex *);
int		 lsa_equal(struct lsa *, struct lsa *);

RB_GENERATE(lsa_tree, vertex, entry, lsa_compare)

void
lsa_init(struct lsa_tree *t)
{
	RB_INIT(t);
}

int
lsa_compare(struct vertex *a, struct vertex *b)
{
	if (a->type < b->type)
		return (-1);
	if (a->type > b->type)
		return (1);
	if (a->adv_rtr < b->adv_rtr)
		return (-1);
	if (a->adv_rtr > b->adv_rtr)
		return (1);
	if (a->ls_id < b->ls_id)
		return (-1);
	if (a->ls_id > b->ls_id)
		return (1);
	return (0);
}


struct vertex *
vertex_get(struct lsa *lsa, struct rde_nbr *nbr, struct lsa_tree *tree)
{
	struct vertex	*v;
	struct timespec	 tp;

	if ((v = calloc(1, sizeof(struct vertex))) == NULL)
		fatal(NULL);
	TAILQ_INIT(&v->nexthop);
	v->area = nbr->area;
	v->peerid = nbr->peerid;
	v->lsa = lsa;
	clock_gettime(CLOCK_MONOTONIC, &tp);
	v->changed = v->stamp = tp.tv_sec;
	v->cost = LS_INFINITY;
	v->ls_id = ntohl(lsa->hdr.ls_id);
	v->adv_rtr = ntohl(lsa->hdr.adv_rtr);
	v->type = lsa->hdr.type;
	v->lsa_tree = tree;

	if (!nbr->self)
		v->flooded = 1; /* XXX fix me */
	v->self = nbr->self;

	evtimer_set(&v->ev, lsa_timeout, v);

	return (v);
}

void
vertex_free(struct vertex *v)
{
	RB_REMOVE(lsa_tree, v->lsa_tree, v);

	(void)evtimer_del(&v->ev);
	vertex_nexthop_clear(v);
	free(v->lsa);
	free(v);
}

void
vertex_nexthop_clear(struct vertex *v)
{
	struct v_nexthop	*vn;

	while ((vn = TAILQ_FIRST(&v->nexthop))) {
		TAILQ_REMOVE(&v->nexthop, vn, entry);
		free(vn);
	}
}

void
vertex_nexthop_add(struct vertex *dst, struct vertex *parent, u_int32_t nexthop)
{
	struct v_nexthop	*vn;

	if ((vn = calloc(1, sizeof(*vn))) == NULL)
		fatal("vertex_nexthop_add");

	vn->prev = parent;
	vn->nexthop.s_addr = nexthop;

	TAILQ_INSERT_TAIL(&dst->nexthop, vn, entry);
}

/* returns -1 if a is older, 1 if newer and 0 if equal to b */
int
lsa_newer(struct lsa_hdr *a, struct lsa_hdr *b)
{
	int32_t		 a32, b32;
	u_int16_t	 a16, b16;
	int		 i;

	if (a == NULL)
		return (-1);
	if (b == NULL)
		return (1);

	/*
	 * The sequence number is defined as signed 32-bit integer,
	 * no idea how IETF came up with such a stupid idea.
	 */
	a32 = (int32_t)ntohl(a->seq_num);
	b32 = (int32_t)ntohl(b->seq_num);

	if (a32 > b32)
		return (1);
	if (a32 < b32)
		return (-1);

	a16 = ntohs(a->ls_chksum);
	b16 = ntohs(b->ls_chksum);

	if (a16 > b16)
		return (1);
	if (a16 < b16)
		return (-1);

	a16 = ntohs(a->age);
	b16 = ntohs(b->age);

	if (a16 >= MAX_AGE && b16 >= MAX_AGE)
		return (0);
	if (b16 >= MAX_AGE)
		return (-1);
	if (a16 >= MAX_AGE)
		return (1);

	i = b16 - a16;
	if (abs(i) > MAX_AGE_DIFF)
		return (i > 0 ? 1 : -1);

	return (0);
}

int
lsa_check(struct rde_nbr *nbr, struct lsa *lsa, u_int16_t len)
{
	struct area	*area = nbr->area;
	u_int32_t	 metric;

	if (len < sizeof(lsa->hdr)) {
		log_warnx("lsa_check: bad packet size");
		return (0);
	}
	if (ntohs(lsa->hdr.len) != len) {
		log_warnx("lsa_check: bad packet size");
		return (0);
	}

	if (iso_cksum(lsa, len, 0)) {
		log_warnx("lsa_check: bad packet checksum");
		return (0);
	}

	/* invalid ages */
	if ((ntohs(lsa->hdr.age) < 1 && !nbr->self) ||
	    ntohs(lsa->hdr.age) > MAX_AGE) {
		log_warnx("lsa_check: bad age");
		return (0);
	}

	/* invalid sequence number */
	if (ntohl(lsa->hdr.seq_num) == RESV_SEQ_NUM) {
		log_warnx("ls_check: bad seq num");
		return (0);
	}

	switch (lsa->hdr.type) {
	case LSA_TYPE_ROUTER:
		if (!lsa_router_check(lsa, len))
			return (0);
		break;
	case LSA_TYPE_NETWORK:
		if ((len % sizeof(u_int32_t)) ||
		    len < sizeof(lsa->hdr) + sizeof(u_int32_t)) {
			log_warnx("lsa_check: bad LSA network packet");
			return (0);
		}
		break;
	case LSA_TYPE_SUM_NETWORK:
	case LSA_TYPE_SUM_ROUTER:
		if ((len % sizeof(u_int32_t)) ||
		    len < sizeof(lsa->hdr) + sizeof(lsa->data.sum)) {
			log_warnx("lsa_check: bad LSA summary packet");
			return (0);
		}
		metric = ntohl(lsa->data.sum.metric);
		if (metric & ~LSA_METRIC_MASK) {
			log_warnx("lsa_check: bad LSA summary metric");
			return (0);
		}
		break;
	case LSA_TYPE_EXTERNAL:
		if ((len % (3 * sizeof(u_int32_t))) ||
		    len < sizeof(lsa->hdr) + sizeof(lsa->data.asext)) {
			log_warnx("lsa_check: bad LSA as-external packet");
			return (0);
		}
		metric = ntohl(lsa->data.asext.metric);
		if (metric & ~(LSA_METRIC_MASK | LSA_ASEXT_E_FLAG)) {
			log_warnx("lsa_check: bad LSA as-external metric");
			return (0);
		}
		/* AS-external-LSA are silently discarded in stub areas */
		if (area->stub)
			return (0);
		break;
	case LSA_TYPE_LINK_OPAQ:
	case LSA_TYPE_AREA_OPAQ:
	case LSA_TYPE_AS_OPAQ:
		if (len % sizeof(u_int32_t)) {
			log_warnx("lsa_check: bad opaque LSA packet");
			return (0);
		}
		/* Type-11 Opaque-LSA are silently discarded in stub areas */
		if (lsa->hdr.type == LSA_TYPE_AS_OPAQ && area->stub)
			return (0);
		break;
	default:
		log_warnx("lsa_check: unknown type %u", lsa->hdr.type);
		return (0);
	}

	/* MaxAge handling */
	if (lsa->hdr.age == htons(MAX_AGE) && !nbr->self && lsa_find(nbr->iface,
	    lsa->hdr.type, lsa->hdr.ls_id, lsa->hdr.adv_rtr) == NULL &&
	    !rde_nbr_loading(area)) {
		/*
		 * if no neighbor in state Exchange or Loading
		 * ack LSA but don't add it. Needs to be a direct ack.
		 */
		rde_imsg_compose_ospfe(IMSG_LS_ACK, nbr->peerid, 0, &lsa->hdr,
		    sizeof(struct lsa_hdr));
		return (0);
	}

	return (1);
}

int
lsa_router_check(struct lsa *lsa, u_int16_t len)
{
	struct lsa_rtr_link	*rtr_link;
	char			*buf = (char *)lsa;
	u_int16_t		 i, off, nlinks;

	off = sizeof(lsa->hdr) + sizeof(struct lsa_rtr);
	if (off > len) {
		log_warnx("lsa_check: invalid LSA router packet");
		return (0);
	}

	if (lsa->hdr.ls_id != lsa->hdr.adv_rtr) {
		log_warnx("lsa_check: invalid LSA router packet, bad adv_rtr");
		return (0);
	}

	nlinks = ntohs(lsa->data.rtr.nlinks);
	if (nlinks == 0) {
		log_warnx("lsa_check: invalid LSA router packet");
		return (0);
	}
	for (i = 0; i < nlinks; i++) {
		rtr_link = (struct lsa_rtr_link *)(buf + off);
		off += sizeof(struct lsa_rtr_link);
		if (off > len) {
			log_warnx("lsa_check: invalid LSA router packet");
			return (0);
		}
		off += rtr_link->num_tos * sizeof(u_int32_t);
		if (off > len) {
			log_warnx("lsa_check: invalid LSA router packet");
			return (0);
		}
	}

	if (i != nlinks) {
		log_warnx("lsa_check: invalid LSA router packet");
		return (0);
	}
	return (1);
}

int
lsa_self(struct rde_nbr *nbr, struct lsa *new, struct vertex *v)
{
	struct iface	*iface;
	struct lsa	*dummy;

	if (nbr->self)
		return (0);

	if (rde_router_id() == new->hdr.adv_rtr)
		goto self;

	if (new->hdr.type == LSA_TYPE_NETWORK)
		LIST_FOREACH(iface, &nbr->area->iface_list, entry)
		    if (iface->addr.s_addr == new->hdr.ls_id)
			    goto self;

	return (0);

self:
	if (v == NULL) {
		/*
		 * LSA is no longer announced, remove by premature aging.
		 * The problem is that new may not be altered so a copy
		 * needs to be added to the LSA DB first.
		 */
		if ((dummy = malloc(ntohs(new->hdr.len))) == NULL)
			fatal("lsa_self");
		memcpy(dummy, new, ntohs(new->hdr.len));
		dummy->hdr.age = htons(MAX_AGE);
		/*
		 * The clue is that by using the remote nbr as originator
		 * the dummy LSA will be reflooded via the default timeout
		 * handler.
		 */
		(void)lsa_add(rde_nbr_self(nbr->area), dummy);
		return (1);
	}

	/*
	 * LSA is still originated, just reflood it. But we need to create
	 * a new instance by setting the LSA sequence number equal to the
	 * one of new and calling lsa_refresh(). Flooding will be done by the
	 * caller.
	 */
	v->lsa->hdr.seq_num = new->hdr.seq_num;
	lsa_refresh(v);
	return (1);
}

int
lsa_add(struct rde_nbr *nbr, struct lsa *lsa)
{
	struct lsa_tree	*tree;
	struct vertex	*new, *old;
	struct timeval	 tv, now, res;

	if (lsa->hdr.type == LSA_TYPE_EXTERNAL ||
	    lsa->hdr.type == LSA_TYPE_AS_OPAQ)
		tree = &asext_tree;
	else if (lsa->hdr.type == LSA_TYPE_LINK_OPAQ)
		tree = &nbr->iface->lsa_tree;
	else
		tree = &nbr->area->lsa_tree;

	new = vertex_get(lsa, nbr, tree);
	old = RB_INSERT(lsa_tree, tree, new);

	if (old != NULL) {
		if (old->deleted && evtimer_pending(&old->ev, &tv)) {
			/* new update added before hold time expired */
			gettimeofday(&now, NULL);
			timersub(&tv, &now, &res);

			/* remove old LSA and insert new LSA with delay */
			vertex_free(old);
			RB_INSERT(lsa_tree, tree, new);
			new->deleted = 1;

			if (evtimer_add(&new->ev, &res) != 0)
				fatal("lsa_add");
			return (1);
		}
		if (!lsa_equal(new->lsa, old->lsa)) {
			if (lsa->hdr.type != LSA_TYPE_EXTERNAL &&
			    lsa->hdr.type != LSA_TYPE_AS_OPAQ)
				nbr->area->dirty = 1;
			start_spf_timer();
		}
		vertex_free(old);
		RB_INSERT(lsa_tree, tree, new);
	} else {
		if (lsa->hdr.type != LSA_TYPE_EXTERNAL &&
		    lsa->hdr.type != LSA_TYPE_AS_OPAQ)
			nbr->area->dirty = 1;
		start_spf_timer();
	}

	/* timeout handling either MAX_AGE or LS_REFRESH_TIME */
	timerclear(&tv);

	if (nbr->self && ntohs(new->lsa->hdr.age) == DEFAULT_AGE)
		tv.tv_sec = LS_REFRESH_TIME;
	else
		tv.tv_sec = MAX_AGE - ntohs(new->lsa->hdr.age);

	if (evtimer_add(&new->ev, &tv) != 0)
		fatal("lsa_add");
	return (0);
}

void
lsa_del(struct rde_nbr *nbr, struct lsa_hdr *lsa)
{
	struct vertex	*v;
	struct timeval	 tv;

	v = lsa_find(nbr->iface, lsa->type, lsa->ls_id, lsa->adv_rtr);
	if (v == NULL)
		return;

	v->deleted = 1;
	/* hold time to make sure that a new lsa is not added premature */
	timerclear(&tv);
	tv.tv_sec = MIN_LS_INTERVAL;
	if (evtimer_add(&v->ev, &tv) == -1)
		fatal("lsa_del");
}

void
lsa_age(struct vertex *v)
{
	struct timespec	tp;
	time_t		now;
	int		d;
	u_int16_t	age;

	clock_gettime(CLOCK_MONOTONIC, &tp);
	now = tp.tv_sec;

	d = now - v->stamp;
	/* set stamp so that at least new calls work */
	v->stamp = now;

	if (d < 0) {
		log_warnx("lsa_age: time went backwards");
		return;
	}

	age = ntohs(v->lsa->hdr.age);
	if (age + d > MAX_AGE)
		age = MAX_AGE;
	else
		age += d;

	v->lsa->hdr.age = htons(age);
}

struct vertex *
lsa_find(struct iface *iface, u_int8_t type, u_int32_t ls_id, u_int32_t adv_rtr)
{
	struct lsa_tree	*tree;

	if (type == LSA_TYPE_EXTERNAL ||
	    type == LSA_TYPE_AS_OPAQ)
		tree = &asext_tree;
	else if (type == LSA_TYPE_LINK_OPAQ)
		tree = &iface->lsa_tree;
	else
		tree = &iface->area->lsa_tree;

	return lsa_find_tree(tree, type, ls_id, adv_rtr);
}

struct vertex *
lsa_find_area(struct area *area, u_int8_t type, u_int32_t ls_id,
    u_int32_t adv_rtr)
{
	return lsa_find_tree(&area->lsa_tree, type, ls_id, adv_rtr);
}

struct vertex *
lsa_find_tree(struct lsa_tree *tree, u_int16_t type, u_int32_t ls_id,
    u_int32_t adv_rtr)
{
	struct vertex	 key;
	struct vertex	*v;

	key.ls_id = ntohl(ls_id);
	key.adv_rtr = ntohl(adv_rtr);
	key.type = type;

	v = RB_FIND(lsa_tree, tree, &key);

	/* LSA that are deleted are not findable */
	if (v && v->deleted)
		return (NULL);

	if (v)
		lsa_age(v);

	return (v);
}

struct vertex *
lsa_find_net(struct area *area, u_int32_t ls_id)
{
	struct lsa_tree	*tree = &area->lsa_tree;
	struct vertex	*v;

	/* XXX speed me up */
	RB_FOREACH(v, lsa_tree, tree) {
		if (v->lsa->hdr.type == LSA_TYPE_NETWORK &&
		    v->lsa->hdr.ls_id == ls_id) {
			/* LSA that are deleted are not findable */
			if (v->deleted)
				return (NULL);
			lsa_age(v);
			return (v);
		}
	}

	return (NULL);
}

u_int16_t
lsa_num_links(struct vertex *v)
{
	switch (v->type) {
	case LSA_TYPE_ROUTER:
		return (ntohs(v->lsa->data.rtr.nlinks));
	case LSA_TYPE_NETWORK:
		return ((ntohs(v->lsa->hdr.len) - sizeof(struct lsa_hdr)
		    - sizeof(u_int32_t)) / sizeof(struct lsa_net_link));
	default:
		fatalx("lsa_num_links: invalid LSA type");
	}
}

void
lsa_snap(struct rde_nbr *nbr)
{
	struct lsa_tree	*tree = &nbr->area->lsa_tree;
	struct vertex	*v;

	do {
		RB_FOREACH(v, lsa_tree, tree) {
			if (v->deleted)
				continue;
			switch (v->type) {
			case LSA_TYPE_LINK_OPAQ:
			case LSA_TYPE_AREA_OPAQ:
			case LSA_TYPE_AS_OPAQ:
				if (nbr->capa_options & OSPF_OPTION_O)
					break;
				continue;
			}
			lsa_age(v);
			if (ntohs(v->lsa->hdr.age) >= MAX_AGE)
				rde_imsg_compose_ospfe(IMSG_LS_SNAP, nbr->peerid,
				    0, &v->lsa->hdr, ntohs(v->lsa->hdr.len));
			else
				rde_imsg_compose_ospfe(IMSG_DB_SNAPSHOT,
				    nbr->peerid, 0, &v->lsa->hdr,
				    sizeof(struct lsa_hdr));
		}
		if (tree == &asext_tree)
			break;
		if (tree == &nbr->area->lsa_tree)
			tree = &nbr->iface->lsa_tree;
		else if (nbr->area->stub)
			break;
		else
			tree = &asext_tree;
	} while (1);
}

void
lsa_dump(struct lsa_tree *tree, int imsg_type, pid_t pid)
{
	struct vertex	*v;

	RB_FOREACH(v, lsa_tree, tree) {
		if (v->deleted)
			continue;
		lsa_age(v);
		switch (imsg_type) {
		case IMSG_CTL_SHOW_DATABASE:
			break;
		case IMSG_CTL_SHOW_DB_SELF:
			if (v->lsa->hdr.adv_rtr == rde_router_id())
				break;
			continue;
		case IMSG_CTL_SHOW_DB_EXT:
			if (v->type == LSA_TYPE_EXTERNAL)
				break;
			continue;
		case IMSG_CTL_SHOW_DB_NET:
			if (v->type == LSA_TYPE_NETWORK)
				break;
			continue;
		case IMSG_CTL_SHOW_DB_RTR:
			if (v->type == LSA_TYPE_ROUTER)
				break;
			continue;
		case IMSG_CTL_SHOW_DB_SUM:
			if (v->type == LSA_TYPE_SUM_NETWORK)
				break;
			continue;
		case IMSG_CTL_SHOW_DB_ASBR:
			if (v->type == LSA_TYPE_SUM_ROUTER)
				break;
			continue;
		case IMSG_CTL_SHOW_DB_OPAQ:
			if (v->type == LSA_TYPE_LINK_OPAQ ||
			    v->type == LSA_TYPE_AREA_OPAQ ||
			    v->type == LSA_TYPE_AS_OPAQ)
				break;
			continue;
		default:
			log_warnx("lsa_dump: unknown imsg type");
			return;
		}
		rde_imsg_compose_ospfe(imsg_type, 0, pid, &v->lsa->hdr,
		    ntohs(v->lsa->hdr.len));
	}
}

/* ARGSUSED */
void
lsa_timeout(int fd, short event, void *bula)
{
	struct vertex	*v = bula;
	struct timeval	 tv;

	lsa_age(v);

	if (v->deleted) {
		if (ntohs(v->lsa->hdr.age) >= MAX_AGE) {
			vertex_free(v);
		} else {
			v->deleted = 0;

			/* schedule recalculation of the RIB */
			if (v->type != LSA_TYPE_EXTERNAL &&
			    v->type != LSA_TYPE_AS_OPAQ)
				v->area->dirty = 1;
			start_spf_timer();

			rde_imsg_compose_ospfe(IMSG_LS_FLOOD, v->peerid, 0,
			    v->lsa, ntohs(v->lsa->hdr.len));

			/* timeout handling either MAX_AGE or LS_REFRESH_TIME */
			timerclear(&tv);
			if (v->self)
				tv.tv_sec = LS_REFRESH_TIME;
			else
				tv.tv_sec = MAX_AGE - ntohs(v->lsa->hdr.age);

			if (evtimer_add(&v->ev, &tv) != 0)
				fatal("lsa_timeout");
		}
		return;
	}

	if (v->self && ntohs(v->lsa->hdr.age) < MAX_AGE)
		lsa_refresh(v);

	rde_imsg_compose_ospfe(IMSG_LS_FLOOD, v->peerid, 0,
	    v->lsa, ntohs(v->lsa->hdr.len));
}

void
lsa_refresh(struct vertex *v)
{
	struct timeval	 tv;
	struct timespec	 tp;
	u_int32_t	 seqnum;
	u_int16_t	 len;

	/* refresh LSA by increasing sequence number by one */
	if (v->self && ntohs(v->lsa->hdr.age) >= MAX_AGE)
		/* self originated network that is currently beeing removed */
		v->lsa->hdr.age = htons(MAX_AGE);
	else
		v->lsa->hdr.age = htons(DEFAULT_AGE);
	seqnum = ntohl(v->lsa->hdr.seq_num);
	if (seqnum++ == MAX_SEQ_NUM)
		/* XXX fix me */
		fatalx("sequence number wrapping");
	v->lsa->hdr.seq_num = htonl(seqnum);

	/* recalculate checksum */
	len = ntohs(v->lsa->hdr.len);
	v->lsa->hdr.ls_chksum = 0;
	v->lsa->hdr.ls_chksum = htons(iso_cksum(v->lsa, len, LS_CKSUM_OFFSET));

	clock_gettime(CLOCK_MONOTONIC, &tp);
	v->changed = v->stamp = tp.tv_sec;

	timerclear(&tv);
	tv.tv_sec = LS_REFRESH_TIME;
	if (evtimer_add(&v->ev, &tv) == -1)
		fatal("lsa_refresh");
}

void
lsa_merge(struct rde_nbr *nbr, struct lsa *lsa, struct vertex *v)
{
	struct timeval	tv;
	struct timespec	tp;
	time_t		now;
	u_int16_t	len;

	if (v == NULL) {
		if (lsa_add(nbr, lsa))
			/* delayed update */
			return;
		rde_imsg_compose_ospfe(IMSG_LS_FLOOD, nbr->peerid, 0,
		    lsa, ntohs(lsa->hdr.len));
		return;
	}

	/* set the seq_num to the current one. lsa_refresh() will do the ++ */
	lsa->hdr.seq_num = v->lsa->hdr.seq_num;
	/* recalculate checksum */
	len = ntohs(lsa->hdr.len);
	lsa->hdr.ls_chksum = 0;
	lsa->hdr.ls_chksum = htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	/* compare LSA most header fields are equal so don't check them */
	if (lsa_equal(lsa, v->lsa)) {
		free(lsa);
		return;
	}

	/* overwrite the lsa all other fields are unaffected */
	free(v->lsa);
	v->lsa = lsa;
	start_spf_timer();
	if (v->type != LSA_TYPE_EXTERNAL &&
	    v->type != LSA_TYPE_AS_OPAQ)
		nbr->area->dirty = 1;

	/* set correct timeout for reflooding the LSA */
	clock_gettime(CLOCK_MONOTONIC, &tp);
	now = tp.tv_sec;
	timerclear(&tv);
	if (v->changed + MIN_LS_INTERVAL >= now)
		tv.tv_sec = MIN_LS_INTERVAL;
	if (evtimer_add(&v->ev, &tv) == -1)
		fatal("lsa_merge");
}

void
lsa_remove_invalid_sums(struct area *area)
{
	struct lsa_tree	*tree = &area->lsa_tree;
	struct vertex	*v, *nv;

	/* XXX speed me up */
	for (v = RB_MIN(lsa_tree, tree); v != NULL; v = nv) {
		nv = RB_NEXT(lsa_tree, tree, v);
		if ((v->type == LSA_TYPE_SUM_NETWORK ||
		    v->type == LSA_TYPE_SUM_ROUTER) &&
		    v->self && v->cost == LS_INFINITY &&
		    v->deleted == 0) {
			/*
			 * age the lsa and call lsa_timeout() which will
			 * actually remove it from the database.
			 */
			v->lsa->hdr.age = htons(MAX_AGE);
			lsa_timeout(0, 0, v);
		}
	}
}

void
lsa_generate_stub_sums(struct area *area)
{
	struct rt_node rn;
	struct redistribute *r;
	struct vertex *v;
	struct lsa *lsa;
	struct area *back;

	if (!area->stub)
		return;

	back = rde_backbone_area();
	if (!back || !back->active)
		return;

	SIMPLEQ_FOREACH(r, &area->redist_list, entry) {
		bzero(&rn, sizeof(rn));
		if (r->type == REDIST_DEFAULT) {
			/* setup fake rt_node */
			rn.prefixlen = 0;
			rn.prefix.s_addr = INADDR_ANY;
			rn.cost = r->metric & LSA_METRIC_MASK;

			/* update lsa but only if it was changed */
			v = lsa_find_area(area, LSA_TYPE_SUM_NETWORK,
			    rn.prefix.s_addr, rde_router_id());
			lsa = orig_sum_lsa(&rn, area, LSA_TYPE_SUM_NETWORK, 0);
			lsa_merge(rde_nbr_self(area), lsa, v);

			if (v == NULL)
				v = lsa_find_area(area, LSA_TYPE_SUM_NETWORK,
				    rn.prefix.s_addr, rde_router_id());

			/*
			 * suppressed/deleted routes are not found in the
			 * second lsa_find
			 */
			if (v)
				v->cost = rn.cost;
			return;
		} else if (r->type == (REDIST_DEFAULT | REDIST_NO))
			return;
	}
}

int
lsa_equal(struct lsa *a, struct lsa *b)
{
	/*
	 * compare LSA that already have same type, adv_rtr and ls_id
	 * so not all header need to be compared
	 */
	if (a == NULL || b == NULL)
		return (0);
	if (a->hdr.len != b->hdr.len)
		return (0);
	if (a->hdr.opts != b->hdr.opts)
		return (0);
	/* LSAs with age MAX_AGE are never equal */
	if (a->hdr.age == htons(MAX_AGE) || b->hdr.age == htons(MAX_AGE))
		return (0);
	if (memcmp(&a->data, &b->data, ntohs(a->hdr.len) -
	    sizeof(struct lsa_hdr)))
		return (0);

	return (1);
}
@


1.49
log
@Enforce that the ls_id and the adv_rtr field in a type 1 router LSA are
the same. This will drop updates trying to attack the OSPF LSDB. For
ospfd such bad router LSA were never a problem since the LSA lookup always
includes the ls_id and adv_rtr -- so the bad packets would have never been
picked up by the SPF calculation.
OK bluhm@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.48 2013/01/17 10:07:56 markus Exp $ */
a120 4

	if (nexthop == 0)
		/* invalid nexthop, skip it */
		return;
@


1.48
log
@improve snapshot handling:
- don't start a new snapshot if we are already in NBR_STA_SNAP
- ignore IMSG_DB_SNAPSHOT and IMSG_DB_END unless we are in NBR_STA_SNAP
- add new IMSG_LS_SNAP message so we can distinguish it from
  IMSG_LS_UPD. this way we can ignore them if we are not in NBR_STA_SNAP
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.47 2011/05/09 12:24:41 claudio Exp $ */
d300 5
@


1.47
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.46 2011/05/02 11:45:55 claudio Exp $ */
d588 1
a588 1
				rde_imsg_compose_ospfe(IMSG_LS_UPD, nbr->peerid,
@


1.46
log
@More spring cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.45 2011/03/24 08:36:00 claudio Exp $ */
d30 1
a30 1
struct vertex	*vertex_get(struct lsa *, struct rde_nbr *);
d33 2
d54 4
a61 4
	if (a->adv_rtr < b->adv_rtr)
		return (-1);
	if (a->adv_rtr > b->adv_rtr)
		return (1);
d67 1
a67 1
vertex_get(struct lsa *lsa, struct rde_nbr *nbr)
d84 1
d98 1
a98 4
	if (v->type == LSA_TYPE_EXTERNAL)
		RB_REMOVE(lsa_tree, &asext_tree, v);
	else
		RB_REMOVE(lsa_tree, &v->area->lsa_tree, v);
d258 11
d275 1
a275 1
	if (lsa->hdr.age == htons(MAX_AGE) && !nbr->self && lsa_find(area,
d386 2
a387 1
	if (lsa->hdr.type == LSA_TYPE_EXTERNAL)
d389 2
d394 1
a394 1
	new = vertex_get(lsa, nbr);
d413 2
a414 1
			if (lsa->hdr.type != LSA_TYPE_EXTERNAL)
d421 2
a422 1
		if (lsa->hdr.type != LSA_TYPE_EXTERNAL)
d446 1
a446 1
	v = lsa_find(nbr->area, lsa->type, lsa->ls_id, lsa->adv_rtr);
d488 25
a512 1
lsa_find(struct area *area, u_int8_t type, u_int32_t ls_id, u_int32_t adv_rtr)
a515 1
	struct lsa_tree	*tree;
a520 5
	if (type == LSA_TYPE_EXTERNAL)
		tree = &asext_tree;
	else
		tree = &area->lsa_tree;

d569 1
a569 1
lsa_snap(struct area *area, u_int32_t peerid)
d571 1
a571 1
	struct lsa_tree	*tree = &area->lsa_tree;
d578 8
d588 1
a588 1
				rde_imsg_compose_ospfe(IMSG_LS_UPD, peerid,
d591 3
a593 2
				rde_imsg_compose_ospfe(IMSG_DB_SNAPSHOT, peerid,
				    0, &v->lsa->hdr, sizeof(struct lsa_hdr));
d595 5
a599 1
		if (tree != &area->lsa_tree || area->stub)
d601 2
a602 1
		tree = &asext_tree;
d617 1
a617 3
			rde_imsg_compose_ospfe(IMSG_CTL_SHOW_DATABASE, 0, pid,
			    &v->lsa->hdr, ntohs(v->lsa->hdr.len));
			continue;
d642 6
d673 2
a674 1
			if (v->lsa->hdr.type != LSA_TYPE_EXTERNAL)
d769 2
a770 1
	if (v->type != LSA_TYPE_EXTERNAL)
d831 1
a831 1
			v = lsa_find(area, LSA_TYPE_SUM_NETWORK,
d837 1
a837 1
				v = lsa_find(area, LSA_TYPE_SUM_NETWORK,
a873 1

@


1.45
log
@Fix some memory leaks. Mainly better cleanup on shutdown but the v_nexthop
leak is a runtime one.
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.44 2010/07/19 09:11:08 claudio Exp $ */
a531 2

	return (0);
@


1.44
log
@lsa_refresh() was able to resurect dead LSA resulting in zombie anouncements.
Make sure that if the LSA is managed by this router that we force timed-out
LSA to stay timed out which causes them to be pruned in the secound round.
This problem can show up when not exactly the same LSA is pruned because
the checksum is used as tiebreaker resulting in indeterministic selection
of which LSA is considered newer.
OK bluhm@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.43 2009/11/12 22:29:15 claudio Exp $ */
d101 1
d104 29
@


1.43
log
@Add more paranoia in lsa_router_check(). There needs to be at least one
router link in a type-1 LSA.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.42 2009/01/07 21:16:36 claudio Exp $ */
d629 5
a633 1
	v->lsa->hdr.age = htons(DEFAULT_AGE);
d783 1
a783 1
	/* LSA with age MAX_AGE are never equal */
@


1.42
log
@Full stub area support. This allows ABRs to announce a default network
summary LSA into stub areas so that these routers are able to reach the
outside of the area.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.41 2008/11/24 18:28:02 claudio Exp $ */
d263 4
@


1.41
log
@Initial support for stub areas. The bit still missing is the redistribution
of the default summary net lsa on ABRs but that is comming. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.40 2008/02/11 12:37:37 norby Exp $ */
d713 46
@


1.40
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.39 2007/10/16 21:03:31 claudio Exp $ */
d520 1
a520 1
		if (tree != &area->lsa_tree)
@


1.39
log
@Use v->type insead of v->lsa->hdr.type. Idea came while looking at ospf6d.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.38 2007/04/10 13:26:39 claudio Exp $ */
d604 1
a604 1
				fatal("lsa_add");
@


1.38
log
@Next step in equal cost multipath support. Make the SPF calculation multipath
aware. Both the SPF and RIB trees need additional structures to store the
multiple nexthops to the destination but only the first active nexthop is
passed to the parent process and used for routing. This is the next thing
that needs to be modified. Tested and OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.37 2007/01/29 13:04:13 claudio Exp $ */
d680 1
a680 1
	if (lsa->hdr.type != LSA_TYPE_EXTERNAL)
d702 2
a703 2
		if ((v->lsa->hdr.type == LSA_TYPE_SUM_NETWORK ||
		    v->lsa->hdr.type == LSA_TYPE_SUM_ROUTER) &&
@


1.37
log
@Do not link from the LS DB to outside structures that may vanish before
the actual LS DB entry is removed. In particular a neighbor may be removed
at any time -- we were lucky because we kept down neighbors around for
another 24h. Reload support unhided this problem again. Just copy the
needed info into the vertex. Pointing to the area is save as the vertex is
part of the area itself and removed when the area is removed.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.36 2007/01/24 10:48:47 claudio Exp $ */
d72 1
@


1.36
log
@Remove some log_debug()s that are no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.35 2006/12/13 13:24:09 claudio Exp $ */
d72 2
a73 1
	v->nbr = nbr;
d81 1
d84 1
d97 1
a97 1
		RB_REMOVE(lsa_tree, &v->nbr->area->lsa_tree, v);
d589 1
a589 1
				v->nbr->area->dirty = 1;
d592 1
a592 1
			rde_imsg_compose_ospfe(IMSG_LS_FLOOD, v->nbr->peerid, 0,
d597 1
a597 1
			if (v->nbr->self)
d608 1
a608 1
	if (v->nbr->self && ntohs(v->lsa->hdr.age) < MAX_AGE)
d611 1
a611 1
	rde_imsg_compose_ospfe(IMSG_LS_FLOOD, v->nbr->peerid, 0,
d703 1
a703 1
		    v->nbr->self && v->cost == LS_INFINITY &&
@


1.35
log
@Correct funtion name in fatal message.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.34 2006/12/08 21:28:08 claudio Exp $ */
a355 3
			log_debug("lsa_add: removing %p and putting %p on hold "
			    "queue (timeout %d)", old, new, res.tv_sec);

a395 2
	log_debug("lsa_del: putting %p on hold queue", v);

a560 1
			log_debug("%d", imsg_type);
a579 1
			log_debug("lsa_timeout: finally free %p", v);
a597 3

			log_debug("lsa_timeout: flodding %p new timeout %d",
			    v, tv.tv_sec);
@


1.34
log
@Fix a crash seen on busy area border routers. The problem was a NULL
dereference in rde_summary_update(). Even though we merge in the new LSA
it may be suppressed because the remove happened less than 5 seconds ago.
So the second lsa_find() is still unable to locate the LSA and in this case
we may not access v->cost. Additionally only remove not yet deleted LSA
in lsa_remove_invalid_sums(), removing already removed entries removes also
the suppressed LSAs.
Problem found and fix tested by Pierre-Yves Ritschard. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.33 2006/08/30 05:25:33 norby Exp $ */
d406 1
a406 1
		fatal("lsa_merge");
@


1.33
log
@Remove useless logging, the logged event happens all the time, no need to
spam the logs.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.32 2006/05/29 16:50:36 claudio Exp $ */
d710 2
a711 1
		    v->nbr->self && v->cost == LS_INFINITY) {
@


1.32
log
@Delay lsa database deletes for MIN_LS_INTERVAL seconds so that flapping
routes do not cause a update storm. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.31 2006/04/25 08:06:32 claudio Exp $ */
d396 1
a396 2
	if (v == NULL) {
		log_warnx("lsa_del: LSA no longer in table");
a397 1
	}
@


1.31
log
@The return value of lsa_num_links is an u_int16_t tnd not int. Found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.30 2006/03/22 16:01:20 claudio Exp $ */
d91 4
a94 2
	if (v == NULL)
		return;
d315 1
a315 1
		lsa_add(rde_nbr_self(nbr->area), dummy);
d330 1
a330 1
void
d335 1
a335 1
	struct timeval	 tv;
d346 17
a367 1
		RB_REMOVE(lsa_tree, tree, old);
d386 1
a391 1
	struct lsa_tree	*tree;
d393 1
d401 1
a401 4
	if (lsa->type == LSA_TYPE_EXTERNAL)
		tree = &asext_tree;
	else
		tree = &nbr->area->lsa_tree;
d403 6
a408 2
	RB_REMOVE(lsa_tree, tree, v);
	vertex_free(v);
d457 5
d478 3
d513 2
d535 2
d582 1
d586 31
d663 3
a665 1
		lsa_add(nbr, lsa);
@


1.30
log
@Move the AS external LSA tree out of struct ospfd_config. This simplifies
the code and makes config reloads easier. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.29 2006/03/13 09:36:06 claudio Exp $ */
d461 1
a461 1
int
@


1.29
log
@The return value of the start/stop timer functions is almost never checked.
Switch them to void functions and check if evtimer_add/del fails -- in which
case we fatal() as there is no useful way to recover in such an event.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.28 2006/03/08 15:35:07 claudio Exp $ */
a36 2
struct lsa_tree	*global_lsa_tree;

d42 1
a42 2
	global_lsa_tree = t;
	RB_INIT(global_lsa_tree);
d336 1
a336 1
		tree = global_lsa_tree;
d383 1
a383 1
		tree = global_lsa_tree;
d432 1
a432 1
		tree = global_lsa_tree;
d495 1
a495 1
		tree = global_lsa_tree;
@


1.28
log
@Spaces and other minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.27 2006/02/23 16:16:27 norby Exp $ */
d97 1
a97 1
	evtimer_del(&v->ev);
d548 1
d589 2
a590 1
	evtimer_add(&v->ev, &tv);
d634 2
a635 1
	evtimer_add(&v->ev, &tv);
@


1.27
log
@Prevent ospfd from crashing when LSA Ext's are changed.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.26 2006/02/15 11:47:40 norby Exp $ */
d667 1
a667 1
	       return (0);
@


1.26
log
@Do not try to dirty an area when adding LSA ext.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.25 2006/02/09 20:47:20 norby Exp $ */
d348 2
a349 1
			nbr->area->dirty = 1;
d623 2
a624 1
	nbr->area->dirty = 1;
@


1.25
log
@Don't calculate all areas every time the link state database is updated,
only calculate the dirty ones.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.24 2006/01/05 15:10:57 norby Exp $ */
d355 2
a356 1
		nbr->area->dirty = 1;
@


1.24
log
@Improve how ospfd copes with time changes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.23 2005/11/04 11:36:31 claudio Exp $ */
d347 2
a348 1
		if (!lsa_equal(new->lsa, old->lsa))
d350 1
d354 2
a355 1
	} else
d357 1
a357 1

d621 1
@


1.23
log
@The maximal rate LSA can be updated is all MIN_LS_INTERVAL seconds and not
MIN_LS_ARRIVAL. MIN_LS_ARRIVAL is used to limit the rate of incomming updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.22 2005/11/04 10:50:54 claudio Exp $ */
d71 1
d77 2
a78 1
	v->changed = v->stamp = time(NULL);
d392 1
d397 3
a399 1
	now = time(NULL);
d561 1
d578 3
a580 1
	v->changed = v->stamp = time(NULL);
d590 1
d620 2
a621 1
	now = time(NULL);
@


1.22
log
@Set the vertex timestamp as soon as possible giving ospfd a chance to recover
from time jumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.21 2005/10/12 09:08:25 claudio Exp $ */
d613 2
a614 2
	if (v->changed + MIN_LS_ARRIVAL >= now)
		tv.tv_sec = MIN_LS_ARRIVAL;
@


1.21
log
@In one special condition ospfd sent out ls updates without updating the
checksum. Because of the invalid checksum the other routers dropped it and
so the update was retransmitted over and over again. Now we update the
checksum in lsa_merge() after bumping the sequence number instead of
hoping that lsa_timeout() -> lsa_refresh() will do it for us.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.20 2005/10/06 17:06:44 claudio Exp $ */
d396 3
a410 1
	v->stamp = now;
@


1.20
log
@I should have read the RFC more carefully.
   ...if only one of the instances has its LS age field set to MaxAge
The important part is "only one", so check if both LSA are at MaxAge and
in that case return 0 -- the LSAs are identical.
This fixes a super nasty doom loop between two ospfd sending each other
LSA updates at an incredible speed. Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.19 2005/08/08 12:22:48 claudio Exp $ */
d581 1
d592 4
@


1.19
log
@Try to do an SPF recalculation only if the LS DB changed.
This is still not perfect as on ABRs it is only necessary to
recalculate the area that got changed and not all others too.
More to come but it is a good start. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.18 2005/05/25 15:21:39 norby Exp $ */
d136 2
@


1.18
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.17 2005/05/25 08:06:57 david Exp $ */
d35 1
d341 1
d343 2
d348 3
a350 1
	}
d591 1
a591 5
	if (lsa->hdr.len == v->lsa->hdr.len &&
	    lsa->hdr.opts == v->lsa->hdr.opts &&
	    lsa->hdr.age != htons(MAX_AGE) &&
	    memcmp(&lsa->data, &v->lsa->data, ntohs(lsa->hdr.len) -
	    sizeof(struct lsa_hdr)) == 0) {
d599 1
d629 23
@


1.17
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.16 2005/05/24 20:54:33 claudio Exp $ */
d620 1
a620 1
			 * actually remove it form the database.
@


1.16
log
@An lsa with age == MAX_AGE is always different and needs to be merged.
This solves a bug that made it impossible to remove a LSA by premature aging.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.15 2005/05/24 07:13:00 claudio Exp $ */
d620 1
a620 1
			 * acctually remove it form the database.
@


1.15
log
@In lsa_merge() check if the LSA changed. If it did not change just free the
new one and use the old one. This will reduce the amount of updates sent.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.14 2005/05/24 06:55:21 claudio Exp $ */
d587 1
@


1.14
log
@Fix some obvious issues in the summary LSA origination.
Actually remove summary LSA if the LSA they refer to are no longer valid.
Set correct cost on the summary LSA.
Announce type 4 summary LSA.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.13 2005/05/12 20:43:14 claudio Exp $ */
d581 11
a591 1
	/* TODO check for changes */
a592 2
	/* set the seq_num to the current on. lsa_refresh() will do the ++ */
	lsa->hdr.seq_num = v->lsa->hdr.seq_num;
@


1.13
log
@Every time a LSA is returned from a lookup lsa_age() it.
Also move the lsa_age() prototype to rde.h so that we can access it from
the SPF code.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.12 2005/05/12 19:10:12 norby Exp $ */
d432 1
d434 2
a435 2
		if ((v->lsa->hdr.type == LSA_TYPE_NETWORK) &&
		    (v->lsa->hdr.ls_id == (ls_id))) {
a534 2
	log_debug("lsa_timeout: REFLOOD age %d", ntohs(v->lsa->hdr.age));

d596 23
@


1.12
log
@Add "show database asbr/external/network/router/self-originate/summary"
to ospfctl.

Show detailed information about the LSAs in the Link State Database.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.11 2005/04/12 10:26:09 deraadt Exp $ */
a32 1
void		 lsa_age(struct vertex *);
d435 1
@


1.11
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.10 2005/02/27 08:21:15 norby Exp $ */
d482 1
a482 1
lsa_dump(struct lsa_tree *tree, pid_t pid)
d488 36
a523 2
		rde_imsg_compose_ospfe(IMSG_CTL_SHOW_DATABASE, 0, pid,
		    &v->lsa->hdr, ntohs(v->lsa->hdr.len));
@


1.10
log
@SPF and route table calculation.

Calculate Shortest Path Tree for each area known in the link state
database.

The Shortest Path Tree is used as input for route table calculation.
Route tabled is calculated and the result is inserted into the kernel
route table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.9 2005/02/09 22:58:08 claudio Exp $ */
d114 1
a114 1
	 * The sequnece number is defined as signed 32-bit integer,
@


1.9
log
@Fix premature ageing of self originating LSA. Still not perfect but better
than before where it just failed to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.8 2005/02/09 20:44:37 claudio Exp $ */
d427 32
d555 1
a555 1
	
d559 1
a559 1
	if (v->changed + MIN_LS_ARRIVAL >= now) 
@


1.8
log
@Use log_warnx() in lsa_check() to report bad LSA settings.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.7 2005/02/09 20:40:23 claudio Exp $ */
d312 1
a312 1
		lsa_add(nbr, dummy);
d315 1
d350 1
a350 1
	if (nbr->self)
d468 1
a468 1
	log_debug("lsa_timeout: REFLOOD");
d470 1
a470 1
	if (v->nbr->self && v->lsa->hdr.age != htons(MAX_AGE))
@


1.7
log
@Rework of self originated LSA. First of all the code to generate the LSA
is rewritten to use the dynamic buffer api introduced lately.
Add missing parts in the RDE to merge these LSA originated from the OE into
the LSDB with correct seq_num, etc.
Add hooks to the neighbor and interface fsm so that the LSA get updated if
needed. This is not perfect, still many things are missing. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.6 2005/02/08 12:56:48 claudio Exp $ */
d171 1
a171 1
		log_debug("lsa_check: bad age");
d177 1
a177 1
		log_debug("ls_check: bad seq num");
@


1.6
log
@The LSA seq_num should be unsigned as it is expected by ntohl/htonl() even
though the seq_num needs to be compared as signed number.
No idea how IETF came up with such a stupid idea especially because the
seq_num is not allowed to wrap.
requested by henning@@ OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.5 2005/02/07 05:51:00 david Exp $ */
d227 1
a227 1
	if (ntohs(lsa->hdr.age) == MAX_AGE && lsa_find(area,
d469 1
a469 1
	if (v->nbr->self)
d484 1
a484 1
	v->lsa->hdr.age = ntohs(DEFAULT_AGE);
d496 1
a496 1
	v->changed = time(NULL);
d499 29
@


1.5
log
@spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.4 2005/02/04 07:38:04 claudio Exp $ */
d113 4
d176 1
a176 1
	if (ntohl(lsa->hdr.seq_num) == 0x80000000) {
@


1.4
log
@Add sanity checks for AS-external LSA. Refine some other checks to be as
strict as possible. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.3 2005/02/02 19:29:15 henning Exp $ */
d479 1
a479 1
	/* refresh LSA by increasing sequnce number by one */
@


1.3
log
@excessive ()
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.2 2005/02/02 19:15:07 henning Exp $ */
a32 1
int		 lsa_asext_check(struct area *, struct lsa *, u_int16_t);
d148 1
d151 1
a151 1
		log_warnx("lsa_check: invalid packet size");
d155 1
a155 1
		log_warnx("lsa_check: invalid packet size");
d160 1
a160 1
		log_warnx("lsa_check: invalid packet checksum");
d167 1
a167 1
		log_debug("lsa_check: invalid age");
d173 1
a173 1
		log_debug("ls_check: invalid seq num");
d183 1
a183 1
		if ((len & 0x03) ||
d185 1
a185 1
			log_warnx("lsa_check: invalid LSA network packet");
d191 8
a198 2
		if (len != sizeof(struct lsa_hdr) + sizeof(struct lsa_sum)) {
			log_warnx("lsa_check: invalid LSA summary packet");
d203 12
a214 1
		if (!lsa_asext_check(area, lsa, len))
a269 11
	return (1);
}

int
lsa_asext_check(struct area *area, struct lsa *lsa, u_int16_t len)
{
	if (area->stub)
		/* AS-external-LSA are discarded in stub areas */
		return (0);

	/* XXX check size */
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_lsdb.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d172 1
a172 1
	if ((ntohl(lsa->hdr.seq_num) == 0x80000000)) {
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d338 1
a338 1
	
d456 1
a456 1
	
@

