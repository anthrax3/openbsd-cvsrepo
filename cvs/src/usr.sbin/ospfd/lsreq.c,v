head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.16
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.12
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.14
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.6
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.10
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.8
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.10
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.8
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.14.0.10
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.20
date	2013.01.17.09.02.22;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.06.07.31.26;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.05.19.33.59;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.31.11.44.49;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.31.08.55.00;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.13.09.36.06;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.09.13.34.19;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.10.18.30.47;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.15.20.39.33;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.26.20.05.29;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.26.19.54.49;	author norby;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.12.09.47.30;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.05.13.01.22;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.23.20.36.57;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.10.14.05.48;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.20
log
@the peer might still send more DD messages, even if the RDE has
processed all received DDs (dd_pending == 0), so we need to check
for state != NBR_STA_XCHNG; ok claudio@@
@
text
@/*	$OpenBSD: lsreq.c,v 1.19 2010/05/26 13:56:08 nicm Exp $ */

/*
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>

#include "ospfd.h"
#include "ospf.h"
#include "log.h"
#include "ospfe.h"

extern struct imsgev		*iev_rde;

/* link state request packet handling */
int
send_ls_req(struct nbr *nbr)
{
	struct sockaddr_in	 dst;
	struct ls_req_hdr	 ls_req_hdr;
	struct lsa_entry	*le, *nle;
	struct ibuf		*buf;
	int			 ret;

	if ((buf = ibuf_open(nbr->iface->mtu - sizeof(struct ip))) == NULL)
		fatal("send_ls_req");

	/* set destination */
	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);

	switch (nbr->iface->type) {
	case IF_TYPE_POINTOPOINT:
		inet_aton(AllSPFRouters, &dst.sin_addr);
		break;
	case IF_TYPE_BROADCAST:
	case IF_TYPE_NBMA:
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
		dst.sin_addr.s_addr = nbr->addr.s_addr;
		break;
	default:
		fatalx("send_ls_req: unknown interface type");
	}

	/* OSPF header */
	if (gen_ospf_hdr(buf, nbr->iface, PACKET_TYPE_LS_REQUEST))
		goto fail;

	/* LSA header(s), keep space for a possible md5 sum */
	for (le = TAILQ_FIRST(&nbr->ls_req_list); le != NULL &&
	    ibuf_left(buf) >= sizeof(struct ls_req_hdr) + MD5_DIGEST_LENGTH;
	    le = nle) {
		nbr->ls_req = nle = TAILQ_NEXT(le, entry);
		ls_req_hdr.type = htonl(le->le_lsa->type);
		ls_req_hdr.ls_id = le->le_lsa->ls_id;
		ls_req_hdr.adv_rtr = le->le_lsa->adv_rtr;
		if (ibuf_add(buf, &ls_req_hdr, sizeof(ls_req_hdr)))
			goto fail;
	}

	/* update authentication and calculate checksum */
	if (auth_gen(buf, nbr->iface))
		goto fail;

	ret = send_packet(nbr->iface, buf, &dst);

	ibuf_free(buf);
	return (ret);
fail:
	log_warn("send_ls_req");
	ibuf_free(buf);
	return (-1);
}

void
recv_ls_req(struct nbr *nbr, char *buf, u_int16_t len)
{
	switch (nbr->state) {
	case NBR_STA_DOWN:
	case NBR_STA_ATTEMPT:
	case NBR_STA_INIT:
	case NBR_STA_2_WAY:
	case NBR_STA_XSTRT:
	case NBR_STA_SNAP:
		log_debug("recv_ls_req: packet ignored in state %s, "
		    "neighbor ID %s", nbr_state_name(nbr->state),
		    inet_ntoa(nbr->id));
		break;
	case NBR_STA_XCHNG:
	case NBR_STA_LOAD:
	case NBR_STA_FULL:
		imsg_compose_event(iev_rde, IMSG_LS_REQ, nbr->peerid,
		    0, -1, buf, len);
		break;
	default:
		fatalx("recv_ls_req: unknown neighbor state");
	}
}

/* link state request list */
void
ls_req_list_add(struct nbr *nbr, struct lsa_hdr *lsa)
{
	struct lsa_entry	*le;

	if (lsa == NULL)
		fatalx("ls_req_list_add: no LSA header");

	if ((le = calloc(1, sizeof(*le))) == NULL)
		fatal("ls_req_list_add");

	TAILQ_INSERT_TAIL(&nbr->ls_req_list, le, entry);
	le->le_lsa = lsa;
	nbr->ls_req_cnt++;
}

struct lsa_entry *
ls_req_list_get(struct nbr *nbr, struct lsa_hdr *lsa_hdr)
{
	struct lsa_entry	*le;

	TAILQ_FOREACH(le, &nbr->ls_req_list, entry) {
		if ((lsa_hdr->type == le->le_lsa->type) &&
		    (lsa_hdr->ls_id == le->le_lsa->ls_id) &&
		    (lsa_hdr->adv_rtr == le->le_lsa->adv_rtr))
			return (le);
	}
	return (NULL);
}

void
ls_req_list_free(struct nbr *nbr, struct lsa_entry *le)
{
	if (nbr->ls_req == le) {
		nbr->ls_req = TAILQ_NEXT(le, entry);
	}

	TAILQ_REMOVE(&nbr->ls_req_list, le, entry);
	free(le->le_lsa);
	free(le);
	nbr->ls_req_cnt--;

	/* received all requested LSA(s), send a new LS req */
	if (nbr->ls_req != NULL &&
	    nbr->ls_req == TAILQ_FIRST(&nbr->ls_req_list)) {
		start_ls_req_tx_timer(nbr);
	}

	/* we might not have received all DDs and are still in XCHNG */
	if (ls_req_list_empty(nbr) && nbr->dd_pending == 0 &&
	    nbr->state != NBR_STA_XCHNG)
		nbr_fsm(nbr, NBR_EVT_LOAD_DONE);
}

void
ls_req_list_clr(struct nbr *nbr)
{
	struct lsa_entry	*le;

	while ((le = TAILQ_FIRST(&nbr->ls_req_list)) != NULL) {
		TAILQ_REMOVE(&nbr->ls_req_list, le, entry);
		free(le->le_lsa);
		free(le);
	}

	nbr->ls_req_cnt = 0;
	nbr->ls_req = NULL;
}

int
ls_req_list_empty(struct nbr *nbr)
{
	return (TAILQ_EMPTY(&nbr->ls_req_list));
}

/* timers */
/* ARGSUSED */
void
ls_req_tx_timer(int fd, short event, void *arg)
{
	struct nbr	*nbr = arg;
	struct timeval	 tv;

	switch (nbr->state) {
	case NBR_STA_DOWN:
	case NBR_STA_ATTEMPT:
	case NBR_STA_INIT:
	case NBR_STA_2_WAY:
	case NBR_STA_SNAP:
	case NBR_STA_XSTRT:
	case NBR_STA_XCHNG:
		return;
	case NBR_STA_LOAD:
		send_ls_req(nbr);
		break;
	case NBR_STA_FULL:
		return;
	default:
		log_debug("ls_req_tx_timer: unknown neighbor state, "
		    "neighbor ID %s", inet_ntoa(nbr->id));
		break;
	}

	/* reschedule lsreq_tx_timer */
	if (nbr->state == NBR_STA_LOAD) {
		timerclear(&tv);
		tv.tv_sec = nbr->iface->rxmt_interval;
		if (evtimer_add(&nbr->lsreq_tx_timer, &tv) == -1)
			fatal("ls_req_tx_timer");
	}
}

void
start_ls_req_tx_timer(struct nbr *nbr)
{
	struct timeval tv;

	if (nbr == nbr->iface->self)
		return;

	timerclear(&tv);
	if (evtimer_add(&nbr->lsreq_tx_timer, &tv) == -1)
		fatal("start_ls_req_tx_timer");
}

void
stop_ls_req_tx_timer(struct nbr *nbr)
{
	if (nbr == nbr->iface->self)
		return;

	if (evtimer_del(&nbr->lsreq_tx_timer) == -1)
		fatal("stop_ls_req_tx_timer");
}
@


1.19
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.18 2009/06/06 07:31:26 eric Exp $ */
d167 3
a169 1
	if (ls_req_list_empty(nbr) && nbr->dd_pending == 0)
@


1.18
log
@sync ospfctl/ospfd with the common imsg code, making it lib ready as well.

"looks ok" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.17 2009/06/05 19:33:59 pyr Exp $ */
d39 1
a39 1
	struct buf		*buf;
d42 1
a42 1
	if ((buf = buf_open(nbr->iface->mtu - sizeof(struct ip))) == NULL)
d69 1
a69 1
	    buf_left(buf) >= sizeof(struct ls_req_hdr) + MD5_DIGEST_LENGTH;
d75 1
a75 1
		if (buf_add(buf, &ls_req_hdr, sizeof(ls_req_hdr)))
d85 1
a85 1
	buf_free(buf);
d89 1
a89 1
	buf_free(buf);
@


1.17
log
@make ospfd's imsg lib ready as well.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.16 2009/01/31 11:44:49 claudio Exp $ */
d30 1
a30 1
extern struct imsgbuf		*ibuf_rde;
d110 1
a110 1
		imsg_compose_event(ibuf_rde, IMSG_LS_REQ, nbr->peerid,
@


1.16
log
@Implement buf_left() to make some some more buffer handling easier.
buf_left() returns the bytes left in a buffer. This makes the check to
keep MD5_DIGEST_LENGTH bytes unallocated in some messages easier.
From the buf cleanup diff that was OK norby@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.15 2009/01/31 08:55:00 claudio Exp $ */
d110 2
a111 1
		imsg_compose(ibuf_rde, IMSG_LS_REQ, nbr->peerid, 0, buf, len);
@


1.15
log
@Pass the buffer to send_packet() instead of spliting it up. This removes
some direct access to struct buf internals in the rest of ospfe.
Based on a larger buffer cleanup diff that was OK norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.14 2006/03/13 09:36:06 claudio Exp $ */
d69 2
a70 2
	    buf->wpos + sizeof(struct ls_req_hdr) < buf->max -
	    MD5_DIGEST_LENGTH; le = nle) {
@


1.14
log
@The return value of the start/stop timer functions is almost never checked.
Switch them to void functions and check if evtimer_add/del fails -- in which
case we fatal() as there is no useful way to recover in such an event.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.13 2006/03/09 13:34:19 claudio Exp $ */
d83 1
a83 1
	ret = send_packet(nbr->iface, buf->buf, buf->wpos, &dst);
@


1.13
log
@Mark event callbacks with ARGSUSED to silence lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.12 2006/02/10 18:30:47 claudio Exp $ */
d223 2
a224 1
		evtimer_add(&nbr->lsreq_tx_timer, &tv);
d228 1
a228 1
int
d234 1
a234 1
		return (0);
d237 2
a238 2

	return (evtimer_add(&nbr->lsreq_tx_timer, &tv));
d241 1
a241 1
int
d245 1
a245 1
		return (0);
d247 2
a248 1
	return (evtimer_del(&nbr->lsreq_tx_timer));
@


1.12
log
@ospfd does not need fd passing via the imsg framework so remove that code
and remove other unneeded functions that are only used in bgpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.11 2005/12/15 20:39:33 claudio Exp $ */
d192 1
@


1.11
log
@No need to call the nbr_fsm for unexpected LS requests. The RFC tells to
just ignore thos packets. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.10 2005/05/26 20:05:29 norby Exp $ */
d110 1
a110 2
		imsg_compose(ibuf_rde, IMSG_LS_REQ, nbr->peerid, 0, -1,
		    buf, len);
@


1.10
log
@Remove unneeded debug messages from LS request.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.9 2005/05/26 19:54:49 norby Exp $ */
a105 1
		nbr_fsm(nbr, NBR_EVT_ADJ_OK);
@


1.9
log
@Simplify and cleanup passive interface handling.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.8 2005/04/12 09:47:30 claudio Exp $ */
a95 2
	log_debug("recv_ls_req: neighbor ID %s", inet_ntoa(nbr->id));

a199 2
	log_debug("ls_req_tx_timer: neighbor ID %s", inet_ntoa(nbr->id));

a223 2
		log_debug("ls_req_tx_timer: reschedule neighbor ID %s",
		    inet_ntoa(nbr->id));
a235 1
	log_debug("start_ls_req_tx_timer: neighbor ID %s", inet_ntoa(nbr->id));
a245 2

	log_debug("stop_ls_req_tx_timer: neighbor ID %s", inet_ntoa(nbr->id));
@


1.8
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.7 2005/04/05 13:01:22 claudio Exp $ */
a40 3

	if (nbr->iface->passive)
		return (0);
@


1.7
log
@Use the dynamic buffer API for packet generation and sending.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.6 2005/03/23 20:36:57 claudio Exp $ */
d72 1
a72 1
	    buf->wpos + sizeof(struct ls_req_hdr) < buf->max - 
@


1.6
log
@mini KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.5 2005/03/22 22:13:48 norby Exp $ */
d37 1
a37 1
	struct ls_req_hdr	*ls_req_hdr;
d39 2
a40 5
	char			*buf = NULL;
	char			*ptr;
	int			 ret = 0;

	log_debug("send_ls_req: neighbor ID %s", inet_ntoa(nbr->id));
d45 1
a45 2
	/* XXX use buffer API instead for better decoupling */
	if ((ptr = buf = calloc(1, READ_BUF_SIZE)) == NULL)
d67 2
a68 2
	gen_ospf_hdr(ptr, nbr->iface, PACKET_TYPE_LS_REQUEST);
	ptr += sizeof(struct ospf_hdr);
d70 1
a70 1
	/* LSA header(s) */
d72 2
a73 1
	    (ptr - buf) < nbr->iface->mtu - PACKET_HDR; le = nle) {
d75 5
a79 5
		ls_req_hdr = (struct ls_req_hdr *)ptr;
		ls_req_hdr->type = htonl(le->le_lsa->type);
		ls_req_hdr->ls_id = le->le_lsa->ls_id;
		ls_req_hdr->adv_rtr = le->le_lsa->adv_rtr;
		ptr += sizeof(*ls_req_hdr);
d83 4
a86 1
	auth_gen(buf, ptr - buf, nbr->iface);
d88 1
a88 4
	if ((ret = send_packet(nbr->iface, buf, (ptr - buf), &dst)) == -1)
		log_warnx("send_ls_req: error sending packet on "
		    "interface %s", nbr->iface->name);
	free(buf);
d90 4
@


1.5
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.4 2005/02/10 14:05:48 claudio Exp $ */
d201 2
a202 2
	struct nbr *nbr = arg;
	struct timeval tv;
@


1.4
log
@Work around a timing issue in the db exchange phase. The DB description
packets comming from the net are looped through the RDE and may get
delayed because of this. The result is that the neighbor FSM ends in
state FULL instead of LOADING and so the LSDB is not correctly
synchronized. Issue found by norby@@ OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.3 2005/02/02 19:15:07 henning Exp $ */
d191 1
a191 1
bool
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d172 1
a172 1
	if (ls_req_list_empty(nbr))
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsreq.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d214 1
a214 1
		return; 
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2004, 2005 Esben Norby <esben.norby@@ericsson.com>
@

