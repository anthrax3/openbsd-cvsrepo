head	1.108;
access;
symbols
	OPENBSD_6_2:1.108.0.6
	OPENBSD_6_2_BASE:1.108
	OPENBSD_6_1:1.108.0.4
	OPENBSD_6_1_BASE:1.108
	OPENBSD_6_0:1.101.0.2
	OPENBSD_6_0_BASE:1.101
	OPENBSD_5_9:1.100.0.2
	OPENBSD_5_9_BASE:1.100
	OPENBSD_5_8:1.97.0.4
	OPENBSD_5_8_BASE:1.97
	OPENBSD_5_7:1.96.0.2
	OPENBSD_5_7_BASE:1.96
	OPENBSD_5_6:1.96.0.4
	OPENBSD_5_6_BASE:1.96
	OPENBSD_5_5:1.95.0.4
	OPENBSD_5_5_BASE:1.95
	OPENBSD_5_4:1.94.0.10
	OPENBSD_5_4_BASE:1.94
	OPENBSD_5_3:1.94.0.8
	OPENBSD_5_3_BASE:1.94
	OPENBSD_5_2:1.94.0.6
	OPENBSD_5_2_BASE:1.94
	OPENBSD_5_1_BASE:1.94
	OPENBSD_5_1:1.94.0.4
	OPENBSD_5_0:1.94.0.2
	OPENBSD_5_0_BASE:1.94
	OPENBSD_4_9:1.91.0.2
	OPENBSD_4_9_BASE:1.91
	OPENBSD_4_8:1.87.0.2
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.84.0.2
	OPENBSD_4_7_BASE:1.84
	OPENBSD_4_6:1.81.0.4
	OPENBSD_4_6_BASE:1.81
	OPENBSD_4_5:1.77.0.2
	OPENBSD_4_5_BASE:1.77
	OPENBSD_4_4:1.73.0.4
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.73.0.2
	OPENBSD_4_3_BASE:1.73
	OPENBSD_4_2:1.69.0.2
	OPENBSD_4_2_BASE:1.69
	OPENBSD_4_1:1.60.0.2
	OPENBSD_4_1_BASE:1.60
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10;
locks; strict;
comment	@ * @;


1.108
date	2017.01.24.04.24.25;	author benno;	state Exp;
branches;
next	1.107;
commitid	PUkGTVeidQeu8XjZ;

1.107
date	2017.01.23.00.12.36;	author jca;	state Exp;
branches;
next	1.106;
commitid	2o8lW93FfcozcY1I;

1.106
date	2016.12.27.09.15.16;	author jca;	state Exp;
branches;
next	1.105;
commitid	uxl52KDjKZIRKB9M;

1.105
date	2016.09.28.14.39.52;	author krw;	state Exp;
branches;
next	1.104;
commitid	VsoFRUtzDouNG1Ir;

1.104
date	2016.09.04.10.10.23;	author krw;	state Exp;
branches;
next	1.103;
commitid	rZNIXRmah2G4uMab;

1.103
date	2016.09.03.10.22.57;	author renato;	state Exp;
branches;
next	1.102;
commitid	N55V2Rf3b7gYYZ14;

1.102
date	2016.09.02.14.02.48;	author benno;	state Exp;
branches;
next	1.101;
commitid	ZCYScyTMvHGcp7WF;

1.101
date	2016.06.06.15.56.22;	author benno;	state Exp;
branches;
next	1.100;
commitid	0LZuXmExthFwhWZd;

1.100
date	2015.12.05.12.20.13;	author claudio;	state Exp;
branches;
next	1.99;
commitid	ev1fE7U8gIdVx8OS;

1.99
date	2015.12.03.11.41.06;	author claudio;	state Exp;
branches;
next	1.98;
commitid	Rtzon3iP98l2jBUz;

1.98
date	2015.11.22.13.09.10;	author claudio;	state Exp;
branches;
next	1.97;
commitid	pxM0r18iZwdhX0Ks;

1.97
date	2015.03.14.02.22.09;	author claudio;	state Exp;
branches;
next	1.96;
commitid	fXmmDzNCmmCnJGkB;

1.96
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.95;
commitid	lIxCxHhVEpsmXOdi;

1.95
date	2013.11.13.20.43.00;	author benno;	state Exp;
branches;
next	1.94;

1.94
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.93;

1.93
date	2011.05.02.11.17.03;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2011.03.24.08.35.59;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2011.01.18.20.46.06;	author claudio;	state Exp;
branches;
next	1.90;

1.90
date	2011.01.17.17.20.26;	author claudio;	state Exp;
branches;
next	1.89;

1.89
date	2011.01.12.15.07.46;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2010.09.25.13.28.43;	author claudio;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.19.09.16.30;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2010.07.01.21.19.57;	author bluhm;	state Exp;
branches;
next	1.85;

1.85
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2009.11.11.07.59.10;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.02.20.20.54;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2009.10.05.08.20.26;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2009.06.06.07.31.26;	author eric;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.05.19.33.59;	author pyr;	state Exp;
branches;
next	1.79;

1.79
date	2009.05.31.18.46.01;	author jacekm;	state Exp;
branches;
next	1.78;

1.78
date	2009.05.31.16.58.54;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2009.01.27.12.45.52;	author michele;	state Exp;
branches;
next	1.76;

1.76
date	2009.01.07.21.16.36;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2008.12.12.22.43.17;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2008.11.24.18.28.02;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.11.12.37.37;	author norby;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.11.12.19.31;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2007.10.01.08.35.12;	author norby;	state Exp;
branches;
next	1.70;

1.70
date	2007.09.25.11.25.41;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2007.07.25.19.11.27;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.19.16.45.15;	author reyk;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.19.14.42.09;	author pyr;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.11.07.09.15;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2007.04.10.13.26.39;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.05.18.50.45;	author pyr;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.04.12.45.44;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.04.12.40.13;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2007.03.30.14.12.55;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2007.02.12.13.23.13;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2007.02.09.10.19.40;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.01.13.25.28;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.01.13.02.05;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.01.12.46.54;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2007.01.29.13.04.13;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2007.01.24.10.48.47;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.20.17.13.36;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2007.01.11.21.43.13;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.11.21.35.15;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2006.12.21.17.10.11;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.08.21.28.08;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.07.19.14.27;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.28.10.53.39;	author norby;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.30.22.06.14;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.29.16.50.36;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.22.16.01.20;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.09.16.55.51;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.08.16.03.40;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.08.13.49.07;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.21.13.02.59;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2006.02.10.18.30.47;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.10.13.00.49;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.12.15.10.02;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.05.15.10.57;	author norby;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.29.13.58.49;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.05.13.18.25;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.04.10.46.23;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.04.10.38.03;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.19.21.43.20;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.12.09.51.58;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.12.09.42.57;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.08.12.22.48;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.26.22.22.37;	author norby;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.26.18.46.16;	author norby;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.25.23.20.36;	author norby;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.25.08.06.57;	author david;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.24.21.36.40;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.24.20.40.57;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.24.06.55.21;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.23.23.03.07;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.23.22.54.05;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.22.17.49.26;	author norby;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.12.19.10.12;	author norby;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.11.20.07.04;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.09.13.53.29;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.08.19.58.51;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.02.02.26.35;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.12.09.54.59;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.06.09.27.28;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.14.18.21.29;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.12.11.03.05;	author norby;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.08.20.12.18;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.27.08.21.15;	author norby;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.10.14.05.48;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.09.22.58.08;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.09.20.40.23;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.108
log
@sync log.c from relayd et al to ospfd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@
@
text
@/*	$OpenBSD: rde.c,v 1.107 2017/01/23 00:12:36 jca Exp $ */

/*
 * Copyright (c) 2004, 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <err.h>
#include <errno.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <pwd.h>
#include <unistd.h>
#include <event.h>

#include "ospf.h"
#include "ospfd.h"
#include "ospfe.h"
#include "log.h"
#include "rde.h"

void		 rde_sig_handler(int sig, short, void *);
__dead void	 rde_shutdown(void);
void		 rde_dispatch_imsg(int, short, void *);
void		 rde_dispatch_parent(int, short, void *);
void		 rde_dump_area(struct area *, int, pid_t);

void		 rde_send_summary(pid_t);
void		 rde_send_summary_area(struct area *, pid_t);
void		 rde_nbr_init(u_int32_t);
void		 rde_nbr_free(void);
struct rde_nbr	*rde_nbr_find(u_int32_t);
struct rde_nbr	*rde_nbr_new(u_int32_t, struct rde_nbr *);
void		 rde_nbr_del(struct rde_nbr *);

void		 rde_req_list_add(struct rde_nbr *, struct lsa_hdr *);
int		 rde_req_list_exists(struct rde_nbr *, struct lsa_hdr *);
void		 rde_req_list_del(struct rde_nbr *, struct lsa_hdr *);
void		 rde_req_list_free(struct rde_nbr *);

struct iface	*rde_asext_lookup(u_int32_t, int);
void		 rde_asext_get(struct kroute *);
void		 rde_asext_put(struct kroute *);
void		 rde_asext_free(void);
struct lsa	*orig_asext_lsa(struct kroute *, u_int32_t, u_int16_t);
struct lsa	*orig_sum_lsa(struct rt_node *, struct area *, u_int8_t, int);

struct ospfd_conf	*rdeconf = NULL, *nconf = NULL;
struct imsgev		*iev_ospfe;
struct imsgev		*iev_main;
struct rde_nbr		*nbrself;
struct lsa_tree		 asext_tree;

/* ARGSUSED */
void
rde_sig_handler(int sig, short event, void *arg)
{
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */

	switch (sig) {
	case SIGINT:
	case SIGTERM:
		rde_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* route decision engine */
pid_t
rde(struct ospfd_conf *xconf, int pipe_parent2rde[2], int pipe_ospfe2rde[2],
    int pipe_parent2ospfe[2])
{
	struct event		 ev_sigint, ev_sigterm;
	struct timeval		 now;
	struct area		*area;
	struct iface		*iface;
	struct passwd		*pw;
	struct redistribute	*r;
	pid_t			 pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
		/* NOTREACHED */
	case 0:
		break;
	default:
		return (pid);
	}

	/* cleanup a bit */
	kif_clear();

	rdeconf = xconf;

	if ((pw = getpwnam(OSPFD_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("route decision engine");
	/*
	 * XXX needed with fork+exec
	 * log_init(debug, LOG_DAEMON);
	 * log_setverbose(verbose);
	 */

	ospfd_process = PROC_RDE_ENGINE;
	log_procinit(log_procnames[ospfd_process]);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	if (pledge("stdio", NULL) == -1)
		fatal("pledge");

	event_init();
	rde_nbr_init(NBR_HASHSIZE);
	lsa_init(&asext_tree);

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, rde_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, rde_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipes */
	close(pipe_ospfe2rde[0]);
	close(pipe_parent2rde[0]);
	close(pipe_parent2ospfe[0]);
	close(pipe_parent2ospfe[1]);

	if ((iev_ospfe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_ospfe->ibuf, pipe_ospfe2rde[1]);
	iev_ospfe->handler = rde_dispatch_imsg;
	imsg_init(&iev_main->ibuf, pipe_parent2rde[1]);
	iev_main->handler = rde_dispatch_parent;

	/* setup event handler */
	iev_ospfe->events = EV_READ;
	event_set(&iev_ospfe->ev, iev_ospfe->ibuf.fd, iev_ospfe->events,
	    iev_ospfe->handler, iev_ospfe);
	event_add(&iev_ospfe->ev, NULL);

	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	evtimer_set(&rdeconf->ev, spf_timer, rdeconf);
	cand_list_init();
	rt_init();

	/* remove unneeded stuff from config */
	LIST_FOREACH(area, &rdeconf->area_list, entry)
		LIST_FOREACH(iface, &area->iface_list, entry)
			md_list_clr(&iface->auth_md_list);

	while ((r = SIMPLEQ_FIRST(&rdeconf->redist_list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&rdeconf->redist_list, entry);
		free(r);
	}

	gettimeofday(&now, NULL);
	rdeconf->uptime = now.tv_sec;

	event_dispatch();

	rde_shutdown();
	/* NOTREACHED */

	return (0);
}

__dead void
rde_shutdown(void)
{
	struct area	*a;
	struct vertex	*v, *nv;

	/* close pipes */
	msgbuf_clear(&iev_ospfe->ibuf.w);
	close(iev_ospfe->ibuf.fd);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	stop_spf_timer(rdeconf);
	cand_list_clr();
	rt_clear();

	while ((a = LIST_FIRST(&rdeconf->area_list)) != NULL) {
		LIST_REMOVE(a, entry);
		area_del(a);
	}
	for (v = RB_MIN(lsa_tree, &asext_tree); v != NULL; v = nv) {
		nv = RB_NEXT(lsa_tree, &asext_tree, v);
		vertex_free(v);
	}
	rde_asext_free();
	rde_nbr_free();

	free(iev_ospfe);
	free(iev_main);
	free(rdeconf);

	log_info("route decision engine exiting");
	_exit(0);
}

int
rde_imsg_compose_ospfe(int type, u_int32_t peerid, pid_t pid, void *data,
    u_int16_t datalen)
{
	return (imsg_compose_event(iev_ospfe, type, peerid, pid, -1,
	    data, datalen));
}

/* ARGSUSED */
void
rde_dispatch_imsg(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	struct in_addr		 aid;
	struct ls_req_hdr	 req_hdr;
	struct lsa_hdr		 lsa_hdr, *db_hdr;
	struct rde_nbr		 rn, *nbr;
	struct timespec		 tp;
	struct lsa		*lsa;
	struct area		*area;
	struct vertex		*v;
	char			*buf;
	ssize_t			 n;
	time_t			 now;
	int			 r, state, self, error, shut = 0, verbose;
	u_int16_t		 l;

	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	clock_gettime(CLOCK_MONOTONIC, &tp);
	now = tp.tv_sec;

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("rde_dispatch_imsg: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_NEIGHBOR_UP:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(rn))
				fatalx("invalid size of OE request");
			memcpy(&rn, imsg.data, sizeof(rn));

			if (rde_nbr_new(imsg.hdr.peerid, &rn) == NULL)
				fatalx("rde_dispatch_imsg: "
				    "neighbor already exists");
			break;
		case IMSG_NEIGHBOR_DOWN:
			rde_nbr_del(rde_nbr_find(imsg.hdr.peerid));
			break;
		case IMSG_NEIGHBOR_CHANGE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(state))
				fatalx("invalid size of OE request");
			memcpy(&state, imsg.data, sizeof(state));

			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			nbr->state = state;
			if (nbr->state & NBR_STA_FULL)
				rde_req_list_free(nbr);
			break;
		case IMSG_NEIGHBOR_CAPA:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(u_int8_t))
				fatalx("invalid size of OE request");
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;
			nbr->capa_options = *(u_int8_t *)imsg.data;
			break;
		case IMSG_AREA_CHANGE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(state))
				fatalx("invalid size of OE request");

			LIST_FOREACH(area, &rdeconf->area_list, entry) {
				if (area->id.s_addr == imsg.hdr.peerid)
					break;
			}
			if (area == NULL)
				break;
			memcpy(&state, imsg.data, sizeof(state));
			area->active = state;
			break;
		case IMSG_DB_SNAPSHOT:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			lsa_snap(nbr);

			imsg_compose_event(iev_ospfe, IMSG_DB_END, imsg.hdr.peerid,
			    0, -1, NULL, 0);
			break;
		case IMSG_DD:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			buf = imsg.data;
			error = 0;
			for (l = imsg.hdr.len - IMSG_HEADER_SIZE;
			    l >= sizeof(lsa_hdr); l -= sizeof(lsa_hdr)) {
				memcpy(&lsa_hdr, buf, sizeof(lsa_hdr));
				buf += sizeof(lsa_hdr);

				if (lsa_hdr.type == LSA_TYPE_EXTERNAL &&
				    nbr->area->stub) {
					error = 1;
					break;
				}
				v = lsa_find(nbr->iface, lsa_hdr.type,
				    lsa_hdr.ls_id, lsa_hdr.adv_rtr);
				if (v == NULL)
					db_hdr = NULL;
				else
					db_hdr = &v->lsa->hdr;

				if (lsa_newer(&lsa_hdr, db_hdr) > 0) {
					/*
					 * only request LSAs that are
					 * newer or missing
					 */
					rde_req_list_add(nbr, &lsa_hdr);
					imsg_compose_event(iev_ospfe, IMSG_DD,
					    imsg.hdr.peerid, 0, -1, &lsa_hdr,
					    sizeof(lsa_hdr));
				}
			}
			if (l != 0 && !error)
				log_warnx("rde_dispatch_imsg: peerid %u, "
				    "trailing garbage in Database Description "
				    "packet", imsg.hdr.peerid);

			if (!error)
				imsg_compose_event(iev_ospfe, IMSG_DD_END,
				    imsg.hdr.peerid, 0, -1, NULL, 0);
			else
				imsg_compose_event(iev_ospfe, IMSG_DD_BADLSA,
				    imsg.hdr.peerid, 0, -1, NULL, 0);
			break;
		case IMSG_LS_REQ:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			buf = imsg.data;
			for (l = imsg.hdr.len - IMSG_HEADER_SIZE;
			    l >= sizeof(req_hdr); l -= sizeof(req_hdr)) {
				memcpy(&req_hdr, buf, sizeof(req_hdr));
				buf += sizeof(req_hdr);

				if ((v = lsa_find(nbr->iface,
				    ntohl(req_hdr.type), req_hdr.ls_id,
				    req_hdr.adv_rtr)) == NULL) {
					log_debug("rde_dispatch_imsg: "
					    "requested LSA not found");
					imsg_compose_event(iev_ospfe,
					    IMSG_LS_BADREQ, imsg.hdr.peerid,
					    0, -1, NULL, 0);
					continue;
				}
				imsg_compose_event(iev_ospfe, IMSG_LS_UPD,
				    imsg.hdr.peerid, 0, -1, v->lsa,
				    ntohs(v->lsa->hdr.len));
			}
			if (l != 0)
				log_warnx("rde_dispatch_imsg: peerid %u, "
				    "trailing garbage in LS Request "
				    "packet", imsg.hdr.peerid);
			break;
		case IMSG_LS_UPD:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			lsa = malloc(imsg.hdr.len - IMSG_HEADER_SIZE);
			if (lsa == NULL)
				fatal(NULL);
			memcpy(lsa, imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);

			if (!lsa_check(nbr, lsa,
			    imsg.hdr.len - IMSG_HEADER_SIZE)) {
				free(lsa);
				break;
			}

			v = lsa_find(nbr->iface, lsa->hdr.type, lsa->hdr.ls_id,
			    lsa->hdr.adv_rtr);
			if (v == NULL)
				db_hdr = NULL;
			else
				db_hdr = &v->lsa->hdr;

			if (nbr->self) {
				lsa_merge(nbr, lsa, v);
				/* lsa_merge frees the right lsa */
				break;
			}

			r = lsa_newer(&lsa->hdr, db_hdr);
			if (r > 0) {
				/* new LSA newer than DB */
				if (v && v->flooded &&
				    v->changed + MIN_LS_ARRIVAL >= now) {
					free(lsa);
					break;
				}

				rde_req_list_del(nbr, &lsa->hdr);

				if (!(self = lsa_self(nbr, lsa, v)))
					if (lsa_add(nbr, lsa))
						/* delayed lsa */
						break;

				/* flood and perhaps ack LSA */
				imsg_compose_event(iev_ospfe, IMSG_LS_FLOOD,
				    imsg.hdr.peerid, 0, -1, lsa,
				    ntohs(lsa->hdr.len));

				/* reflood self originated LSA */
				if (self && v)
					imsg_compose_event(iev_ospfe,
					    IMSG_LS_FLOOD, v->peerid, 0, -1,
					    v->lsa, ntohs(v->lsa->hdr.len));
				/* new LSA was not added so free it */
				if (self)
					free(lsa);
			} else if (r < 0) {
				/*
				 * point 6 of "The Flooding Procedure"
				 * We are violating the RFC here because
				 * it does not make sense to reset a session
				 * because an equal LSA is already in the table.
				 * Only if the LSA sent is older than the one
				 * in the table we should reset the session.
				 */
				if (rde_req_list_exists(nbr, &lsa->hdr)) {
					imsg_compose_event(iev_ospfe,
					    IMSG_LS_BADREQ, imsg.hdr.peerid,
					    0, -1, NULL, 0);
					free(lsa);
					break;
				}

				/* lsa no longer needed */
				free(lsa);

				/* new LSA older than DB */
				if (ntohl(db_hdr->seq_num) == MAX_SEQ_NUM &&
				    ntohs(db_hdr->age) == MAX_AGE)
					/* seq-num wrap */
					break;

				if (v->changed + MIN_LS_ARRIVAL >= now)
					break;

				/* directly send current LSA, no ack */
				imsg_compose_event(iev_ospfe, IMSG_LS_UPD,
				    imsg.hdr.peerid, 0, -1, v->lsa,
				    ntohs(v->lsa->hdr.len));
			} else {
				/* LSA equal send direct ack */
				imsg_compose_event(iev_ospfe, IMSG_LS_ACK,
				    imsg.hdr.peerid, 0, -1, &lsa->hdr,
				    sizeof(lsa->hdr));
				free(lsa);
			}
			break;
		case IMSG_LS_MAXAGE:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct lsa_hdr))
				fatalx("invalid size of OE request");
			memcpy(&lsa_hdr, imsg.data, sizeof(lsa_hdr));

			if (rde_nbr_loading(nbr->area))
				break;

			v = lsa_find(nbr->iface, lsa_hdr.type, lsa_hdr.ls_id,
			    lsa_hdr.adv_rtr);
			if (v == NULL)
				db_hdr = NULL;
			else
				db_hdr = &v->lsa->hdr;

			/*
			 * only delete LSA if the one in the db is not newer
			 */
			if (lsa_newer(db_hdr, &lsa_hdr) <= 0)
				lsa_del(nbr, &lsa_hdr);
			break;
		case IMSG_CTL_SHOW_DATABASE:
		case IMSG_CTL_SHOW_DB_EXT:
		case IMSG_CTL_SHOW_DB_NET:
		case IMSG_CTL_SHOW_DB_RTR:
		case IMSG_CTL_SHOW_DB_SELF:
		case IMSG_CTL_SHOW_DB_SUM:
		case IMSG_CTL_SHOW_DB_ASBR:
		case IMSG_CTL_SHOW_DB_OPAQ:
			if (imsg.hdr.len != IMSG_HEADER_SIZE &&
			    imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(aid)) {
				log_warnx("rde_dispatch_imsg: wrong imsg len");
				break;
			}
			if (imsg.hdr.len == IMSG_HEADER_SIZE) {
				LIST_FOREACH(area, &rdeconf->area_list, entry) {
					rde_dump_area(area, imsg.hdr.type,
					    imsg.hdr.pid);
				}
				lsa_dump(&asext_tree, imsg.hdr.type,
				    imsg.hdr.pid);
			} else {
				memcpy(&aid, imsg.data, sizeof(aid));
				if ((area = area_find(rdeconf, aid)) != NULL) {
					rde_dump_area(area, imsg.hdr.type,
					    imsg.hdr.pid);
					if (!area->stub)
						lsa_dump(&asext_tree,
						    imsg.hdr.type,
						    imsg.hdr.pid);
				}
			}
			imsg_compose_event(iev_ospfe, IMSG_CTL_END, 0,
			    imsg.hdr.pid, -1, NULL, 0);
			break;
		case IMSG_CTL_SHOW_RIB:
			LIST_FOREACH(area, &rdeconf->area_list, entry) {
				imsg_compose_event(iev_ospfe, IMSG_CTL_AREA,
				    0, imsg.hdr.pid, -1, area, sizeof(*area));

				rt_dump(area->id, imsg.hdr.pid, RIB_RTR);
				rt_dump(area->id, imsg.hdr.pid, RIB_NET);
			}
			aid.s_addr = 0;
			rt_dump(aid, imsg.hdr.pid, RIB_EXT);

			imsg_compose_event(iev_ospfe, IMSG_CTL_END, 0,
			    imsg.hdr.pid, -1, NULL, 0);
			break;
		case IMSG_CTL_SHOW_SUM:
			rde_send_summary(imsg.hdr.pid);
			LIST_FOREACH(area, &rdeconf->area_list, entry)
				rde_send_summary_area(area, imsg.hdr.pid);
			imsg_compose_event(iev_ospfe, IMSG_CTL_END, 0,
			    imsg.hdr.pid, -1, NULL, 0);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by ospfe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		default:
			log_debug("rde_dispatch_imsg: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
void
rde_dispatch_parent(int fd, short event, void *bula)
{
	static struct area	*narea;
	struct iface		*niface;
	struct imsg		 imsg;
	struct kroute		 rr;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf;
	struct redistribute	*nred;
	ssize_t			 n;
	int			 shut = 0;

	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("rde_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_NETWORK_ADD:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(rr)) {
				log_warnx("rde_dispatch_parent: "
				    "wrong imsg len");
				break;
			}
			memcpy(&rr, imsg.data, sizeof(rr));
			rde_asext_get(&rr);
			break;
		case IMSG_NETWORK_DEL:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(rr)) {
				log_warnx("rde_dispatch_parent: "
				    "wrong imsg len");
				break;
			}
			memcpy(&rr, imsg.data, sizeof(rr));
			rde_asext_put(&rr);
			break;
		case IMSG_RECONF_CONF:
			if ((nconf = malloc(sizeof(struct ospfd_conf))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct ospfd_conf));

			LIST_INIT(&nconf->area_list);
			LIST_INIT(&nconf->cand_list);
			break;
		case IMSG_RECONF_AREA:
			if ((narea = area_new()) == NULL)
				fatal(NULL);
			memcpy(narea, imsg.data, sizeof(struct area));

			LIST_INIT(&narea->iface_list);
			LIST_INIT(&narea->nbr_list);
			RB_INIT(&narea->lsa_tree);
			SIMPLEQ_INIT(&narea->redist_list);

			LIST_INSERT_HEAD(&nconf->area_list, narea, entry);
			break;
		case IMSG_RECONF_REDIST:
			if ((nred= malloc(sizeof(struct redistribute))) == NULL)
				fatal(NULL);
			memcpy(nred, imsg.data, sizeof(struct redistribute));

			SIMPLEQ_INSERT_TAIL(&narea->redist_list, nred, entry);
			break;
		case IMSG_RECONF_IFACE:
			if ((niface = malloc(sizeof(struct iface))) == NULL)
				fatal(NULL);
			memcpy(niface, imsg.data, sizeof(struct iface));

			LIST_INIT(&niface->nbr_list);
			TAILQ_INIT(&niface->ls_ack_list);
			TAILQ_INIT(&niface->auth_md_list);
			RB_INIT(&niface->lsa_tree);

			niface->area = narea;
			LIST_INSERT_HEAD(&narea->iface_list, niface, entry);

			break;
		case IMSG_RECONF_END:
			merge_config(rdeconf, nconf);
			nconf = NULL;
			break;
		default:
			log_debug("rde_dispatch_parent: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
rde_dump_area(struct area *area, int imsg_type, pid_t pid)
{
	struct iface	*iface;

	/* dump header */
	imsg_compose_event(iev_ospfe, IMSG_CTL_AREA, 0, pid, -1,
	    area, sizeof(*area));

	/* dump link local lsa */
	LIST_FOREACH(iface, &area->iface_list, entry) {
		imsg_compose_event(iev_ospfe, IMSG_CTL_IFACE,
		    0, pid, -1, iface, sizeof(*iface));
		lsa_dump(&iface->lsa_tree, imsg_type, pid);
	}

	/* dump area lsa */
	lsa_dump(&area->lsa_tree, imsg_type, pid);
}

u_int32_t
rde_router_id(void)
{
	return (rdeconf->rtr_id.s_addr);
}

struct area *
rde_backbone_area(void)
{
	struct in_addr	id;

	id.s_addr = INADDR_ANY;

	return (area_find(rdeconf, id));
}

void
rde_send_change_kroute(struct rt_node *r)
{
	int			 krcount = 0;
	struct kroute		 kr;
	struct rt_nexthop	*rn;
	struct ibuf		*wbuf;

	if ((wbuf = imsg_create(&iev_main->ibuf, IMSG_KROUTE_CHANGE, 0, 0,
	    sizeof(kr))) == NULL) {
		return;
	}

	TAILQ_FOREACH(rn, &r->nexthop, entry) {
		if (rn->invalid)
			continue;
		if (rn->connected)
			/* skip self-originated routes */
			continue;
		krcount++;

		bzero(&kr, sizeof(kr));
		kr.prefix.s_addr = r->prefix.s_addr;
		kr.nexthop.s_addr = rn->nexthop.s_addr;
		kr.prefixlen = r->prefixlen;
		kr.ext_tag = r->ext_tag;
		imsg_add(wbuf, &kr, sizeof(kr));
	}
	if (krcount == 0) {
		/* no valid nexthop or self originated, so remove */
		ibuf_free(wbuf);
		rde_send_delete_kroute(r);
		return;
	}
	imsg_close(&iev_main->ibuf, wbuf);
	imsg_event_add(iev_main);
}

void
rde_send_delete_kroute(struct rt_node *r)
{
	struct kroute	 kr;

	bzero(&kr, sizeof(kr));
	kr.prefix.s_addr = r->prefix.s_addr;
	kr.prefixlen = r->prefixlen;

	imsg_compose_event(iev_main, IMSG_KROUTE_DELETE, 0, 0, -1,
	    &kr, sizeof(kr));
}

void
rde_send_summary(pid_t pid)
{
	static struct ctl_sum	 sumctl;
	struct timeval		 now;
	struct area		*area;
	struct vertex		*v;

	bzero(&sumctl, sizeof(struct ctl_sum));

	sumctl.rtr_id.s_addr = rde_router_id();
	sumctl.spf_delay = rdeconf->spf_delay;
	sumctl.spf_hold_time = rdeconf->spf_hold_time;

	LIST_FOREACH(area, &rdeconf->area_list, entry)
		sumctl.num_area++;

	RB_FOREACH(v, lsa_tree, &asext_tree) {
		sumctl.num_ext_lsa++;
		sumctl.ext_lsa_cksum += ntohs(v->lsa->hdr.ls_chksum);
	}

	gettimeofday(&now, NULL);
	if (rdeconf->uptime < now.tv_sec)
		sumctl.uptime = now.tv_sec - rdeconf->uptime;
	else
		sumctl.uptime = 0;

	sumctl.rfc1583compat = rdeconf->rfc1583compat;

	rde_imsg_compose_ospfe(IMSG_CTL_SHOW_SUM, 0, pid, &sumctl,
	    sizeof(sumctl));
}

void
rde_send_summary_area(struct area *area, pid_t pid)
{
	static struct ctl_sum_area	 sumareactl;
	struct iface			*iface;
	struct rde_nbr			*nbr;
	struct lsa_tree			*tree = &area->lsa_tree;
	struct vertex			*v;

	bzero(&sumareactl, sizeof(struct ctl_sum_area));

	sumareactl.area.s_addr = area->id.s_addr;
	sumareactl.num_spf_calc = area->num_spf_calc;

	LIST_FOREACH(iface, &area->iface_list, entry)
		sumareactl.num_iface++;

	LIST_FOREACH(nbr, &area->nbr_list, entry)
		if (nbr->state == NBR_STA_FULL && !nbr->self)
			sumareactl.num_adj_nbr++;

	RB_FOREACH(v, lsa_tree, tree) {
		sumareactl.num_lsa++;
		sumareactl.lsa_cksum += ntohs(v->lsa->hdr.ls_chksum);
	}

	rde_imsg_compose_ospfe(IMSG_CTL_SHOW_SUM_AREA, 0, pid, &sumareactl,
	    sizeof(sumareactl));
}

LIST_HEAD(rde_nbr_head, rde_nbr);

struct nbr_table {
	struct rde_nbr_head	*hashtbl;
	u_int32_t		 hashmask;
} rdenbrtable;

#define RDE_NBR_HASH(x)		\
	&rdenbrtable.hashtbl[(x) & rdenbrtable.hashmask]

void
rde_nbr_init(u_int32_t hashsize)
{
	struct rde_nbr_head	*head;
	u_int32_t		 hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	rdenbrtable.hashtbl = calloc(hs, sizeof(struct rde_nbr_head));
	if (rdenbrtable.hashtbl == NULL)
		fatal("rde_nbr_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&rdenbrtable.hashtbl[i]);

	rdenbrtable.hashmask = hs - 1;

	if ((nbrself = calloc(1, sizeof(*nbrself))) == NULL)
		fatal("rde_nbr_init");

	nbrself->id.s_addr = rde_router_id();
	nbrself->peerid = NBR_IDSELF;
	nbrself->state = NBR_STA_DOWN;
	nbrself->self = 1;
	head = RDE_NBR_HASH(NBR_IDSELF);
	LIST_INSERT_HEAD(head, nbrself, hash);
}

void
rde_nbr_free(void)
{
	free(nbrself);
	free(rdenbrtable.hashtbl);
}

struct rde_nbr *
rde_nbr_find(u_int32_t peerid)
{
	struct rde_nbr_head	*head;
	struct rde_nbr		*nbr;

	head = RDE_NBR_HASH(peerid);

	LIST_FOREACH(nbr, head, hash) {
		if (nbr->peerid == peerid)
			return (nbr);
	}

	return (NULL);
}

struct rde_nbr *
rde_nbr_new(u_int32_t peerid, struct rde_nbr *new)
{
	struct rde_nbr_head	*head;
	struct rde_nbr		*nbr;
	struct area		*area;
	struct iface		*iface;

	if (rde_nbr_find(peerid))
		return (NULL);
	if ((area = area_find(rdeconf, new->area_id)) == NULL)
		fatalx("rde_nbr_new: unknown area");

	LIST_FOREACH(iface, &area->iface_list, entry) {
		if (iface->ifindex == new->ifindex)
			break;
	}
	if (iface == NULL)
		fatalx("rde_nbr_new: unknown interface");

	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
		fatal("rde_nbr_new");

	memcpy(nbr, new, sizeof(*nbr));
	nbr->peerid = peerid;
	nbr->area = area;
	nbr->iface = iface;

	TAILQ_INIT(&nbr->req_list);

	head = RDE_NBR_HASH(peerid);
	LIST_INSERT_HEAD(head, nbr, hash);
	LIST_INSERT_HEAD(&area->nbr_list, nbr, entry);

	return (nbr);
}

void
rde_nbr_iface_del(struct iface *iface)
{
	struct rde_nbr_head	*head;
	struct rde_nbr		*nbr, *xnbr;
	u_int32_t		 i;

	for (i = 0; i <= rdenbrtable.hashmask; i++) {
		head = &rdenbrtable.hashtbl[i];
		LIST_FOREACH_SAFE(nbr, head, hash, xnbr) {
			if (nbr->iface == iface)
				rde_nbr_del(nbr);
		}
	}
}

void
rde_nbr_del(struct rde_nbr *nbr)
{
	if (nbr == NULL)
		return;

	rde_req_list_free(nbr);

	LIST_REMOVE(nbr, entry);
	LIST_REMOVE(nbr, hash);

	free(nbr);
}

int
rde_nbr_loading(struct area *area)
{
	struct rde_nbr		*nbr;
	int			 checkall = 0;

	if (area == NULL) {
		area = LIST_FIRST(&rdeconf->area_list);
		checkall = 1;
	}

	while (area != NULL) {
		LIST_FOREACH(nbr, &area->nbr_list, entry) {
			if (nbr->self)
				continue;
			if (nbr->state & NBR_STA_XCHNG ||
			    nbr->state & NBR_STA_LOAD)
				return (1);
		}
		if (!checkall)
			break;
		area = LIST_NEXT(area, entry);
	}

	return (0);
}

struct rde_nbr *
rde_nbr_self(struct area *area)
{
	struct rde_nbr		*nbr;

	LIST_FOREACH(nbr, &area->nbr_list, entry)
		if (nbr->self)
			return (nbr);

	/* this may not happen */
	fatalx("rde_nbr_self: area without self");
	return (NULL);
}

/*
 * LSA req list
 */
void
rde_req_list_add(struct rde_nbr *nbr, struct lsa_hdr *lsa)
{
	struct rde_req_entry	*le;

	if ((le = calloc(1, sizeof(*le))) == NULL)
		fatal("rde_req_list_add");

	TAILQ_INSERT_TAIL(&nbr->req_list, le, entry);
	le->type = lsa->type;
	le->ls_id = lsa->ls_id;
	le->adv_rtr = lsa->adv_rtr;
}

int
rde_req_list_exists(struct rde_nbr *nbr, struct lsa_hdr *lsa_hdr)
{
	struct rde_req_entry	*le;

	TAILQ_FOREACH(le, &nbr->req_list, entry) {
		if ((lsa_hdr->type == le->type) &&
		    (lsa_hdr->ls_id == le->ls_id) &&
		    (lsa_hdr->adv_rtr == le->adv_rtr))
			return (1);
	}
	return (0);
}

void
rde_req_list_del(struct rde_nbr *nbr, struct lsa_hdr *lsa_hdr)
{
	struct rde_req_entry	*le;

	TAILQ_FOREACH(le, &nbr->req_list, entry) {
		if ((lsa_hdr->type == le->type) &&
		    (lsa_hdr->ls_id == le->ls_id) &&
		    (lsa_hdr->adv_rtr == le->adv_rtr)) {
			TAILQ_REMOVE(&nbr->req_list, le, entry);
			free(le);
			return;
		}
	}
}

void
rde_req_list_free(struct rde_nbr *nbr)
{
	struct rde_req_entry	*le;

	while ((le = TAILQ_FIRST(&nbr->req_list)) != NULL) {
		TAILQ_REMOVE(&nbr->req_list, le, entry);
		free(le);
	}
}

/*
 * as-external LSA handling
 */
struct asext_node {
	RB_ENTRY(asext_node)    entry;
	struct kroute		r;
	u_int32_t		ls_id;
};

static __inline int	asext_compare(struct asext_node *, struct asext_node *);
struct asext_node	*asext_find(u_int32_t, u_int8_t);

RB_HEAD(asext_tree, asext_node)		ast;
RB_PROTOTYPE(asext_tree, asext_node, entry, asext_compare)
RB_GENERATE(asext_tree, asext_node, entry, asext_compare)

static __inline int
asext_compare(struct asext_node *a, struct asext_node *b)
{
	if (ntohl(a->r.prefix.s_addr) < ntohl(b->r.prefix.s_addr))
		return (-1);
	if (ntohl(a->r.prefix.s_addr) > ntohl(b->r.prefix.s_addr))
		return (1);
	if (a->r.prefixlen < b->r.prefixlen)
		return (-1);
	if (a->r.prefixlen > b->r.prefixlen)
		return (1);
	return (0);
}

struct asext_node *
asext_find(u_int32_t addr, u_int8_t prefixlen)
{
	struct asext_node	a;

	a.r.prefix.s_addr = addr;
	a.r.prefixlen = prefixlen;

	return (RB_FIND(asext_tree, &ast, &a));
}

struct iface *
rde_asext_lookup(u_int32_t prefix, int plen)
{
	struct area	*area;
	struct iface	*iface;

	LIST_FOREACH(area, &rdeconf->area_list, entry) {
		LIST_FOREACH(iface, &area->iface_list, entry) {
			if ((iface->addr.s_addr & iface->mask.s_addr) ==
			    (prefix & iface->mask.s_addr) && (plen == -1 ||
			    iface->mask.s_addr == prefixlen2mask(plen)))
				return (iface);
		}
	}
	return (NULL);
}

void
rde_asext_get(struct kroute *kr)
{
	struct asext_node	*an, *oan;
	struct vertex		*v;
	struct lsa		*lsa;
	u_int32_t		 mask;

	if (rde_asext_lookup(kr->prefix.s_addr, kr->prefixlen)) {
		/* already announced as (stub) net LSA */
		log_debug("rde_asext_get: %s/%d is net LSA",
		    inet_ntoa(kr->prefix), kr->prefixlen);
		return;
	}

	an = asext_find(kr->prefix.s_addr, kr->prefixlen);
	if (an == NULL) {
		if ((an = calloc(1, sizeof(*an))) == NULL)
			fatal("rde_asext_get");
		bcopy(kr, &an->r, sizeof(*kr));
		an->ls_id = kr->prefix.s_addr;
		RB_INSERT(asext_tree, &ast, an);
	} else {
		/* the bcopy does not change the lookup key so it is save */
		bcopy(kr, &an->r, sizeof(*kr));
	}

	/*
	 * ls_id must be unique, for overlapping routes this may
	 * not be true. In this case a unique ls_id needs to be found.
	 * The algorithm will change the ls_id of the less specific
	 * route. E.g. in the case of 10.0.0.0/16 and 10.0.0.0/24
	 * 10.0.0.0/24 will get the 10.0.0.0 ls_id and 10.0.0.0/16
	 * will change the ls_id to 10.0.255.255 and see if that is unique.
	 */
	oan = an;
	mask = prefixlen2mask(oan->r.prefixlen);
	v = lsa_find(NULL, LSA_TYPE_EXTERNAL, oan->ls_id,
	    rdeconf->rtr_id.s_addr);
	while (v && v->lsa->data.asext.mask != mask) {
		/* conflict needs to be resolved. change less specific lsa */
		if (ntohl(v->lsa->data.asext.mask) < ntohl(mask)) {
			/* lsa to insert is more specific, fix other lsa */
			mask = v->lsa->data.asext.mask;
			oan = asext_find(v->lsa->hdr.ls_id & mask,
			   mask2prefixlen(mask));
			if (oan == NULL)
				fatalx("as-ext LSA DB corrupted");
		}
		/* oan is less specific and needs new ls_id */
		if (oan->ls_id == oan->r.prefix.s_addr)
			oan->ls_id |= ~mask;
		else {
			u_int32_t	tmp = ntohl(oan->ls_id);
			oan->ls_id = htonl(tmp - 1);
			if (oan->ls_id == oan->r.prefix.s_addr) {
				log_warnx("prefix %s/%d can not be "
				    "redistributed, no unique ls_id found.",
				    inet_ntoa(kr->prefix), kr->prefixlen);
				RB_REMOVE(asext_tree, &ast, an);
				free(an);
				return;
			}
		}
		mask = prefixlen2mask(oan->r.prefixlen);
		v = lsa_find(NULL, LSA_TYPE_EXTERNAL, oan->ls_id,
		    rdeconf->rtr_id.s_addr);
	}

	v = lsa_find(NULL, LSA_TYPE_EXTERNAL, an->ls_id,
	    rdeconf->rtr_id.s_addr);
	lsa = orig_asext_lsa(kr, an->ls_id, DEFAULT_AGE);
	lsa_merge(nbrself, lsa, v);

	if (oan != an) {
		v = lsa_find(NULL, LSA_TYPE_EXTERNAL, oan->ls_id,
		    rdeconf->rtr_id.s_addr);
		lsa = orig_asext_lsa(&oan->r, oan->ls_id, DEFAULT_AGE);
		lsa_merge(nbrself, lsa, v);
	}
}

void
rde_asext_put(struct kroute *kr)
{
	struct asext_node	*an;
	struct vertex		*v;
	struct lsa		*lsa;

	/*
	 * just try to remove the LSA. If the prefix is announced as
	 * stub net LSA asext_find() will fail and nothing will happen.
	 */
	an = asext_find(kr->prefix.s_addr, kr->prefixlen);
	if (an == NULL) {
		log_debug("rde_asext_put: NO SUCH LSA %s/%d",
		    inet_ntoa(kr->prefix), kr->prefixlen);
		return;
	}

	/* inherit metric and ext_tag from the current LSA,
	 * some routers don't like to get withdraws that are
	 * different from what they have in their table.
	 */
	v = lsa_find(NULL, LSA_TYPE_EXTERNAL, an->ls_id,
	    rdeconf->rtr_id.s_addr);
	if (v != NULL) {
		kr->metric = ntohl(v->lsa->data.asext.metric);
		kr->ext_tag = ntohl(v->lsa->data.asext.ext_tag);
	}

	/* remove by reflooding with MAX_AGE */
	lsa = orig_asext_lsa(kr, an->ls_id, MAX_AGE);
	lsa_merge(nbrself, lsa, v);

	RB_REMOVE(asext_tree, &ast, an);
	free(an);
}

void
rde_asext_free(void)
{
	struct asext_node	*an, *nan;

	for (an = RB_MIN(asext_tree, &ast); an != NULL; an = nan) {
		nan = RB_NEXT(asext_tree, &ast, an);
		RB_REMOVE(asext_tree, &ast, an);
		free(an);
	}
}

struct lsa *
orig_asext_lsa(struct kroute *kr, u_int32_t ls_id, u_int16_t age)
{
	struct lsa	*lsa;
	struct iface	*iface;
	u_int16_t	 len;

	len = sizeof(struct lsa_hdr) + sizeof(struct lsa_asext);
	if ((lsa = calloc(1, len)) == NULL)
		fatal("orig_asext_lsa");

	log_debug("orig_asext_lsa: %s/%d age %d",
	    inet_ntoa(kr->prefix), kr->prefixlen, age);

	/* LSA header */
	lsa->hdr.age = htons(age);
	lsa->hdr.opts = area_ospf_options(NULL);
	lsa->hdr.type = LSA_TYPE_EXTERNAL;
	lsa->hdr.adv_rtr = rdeconf->rtr_id.s_addr;
	/* update of seqnum is done by lsa_merge */
	lsa->hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa->hdr.len = htons(len);

	/* prefix and mask */
	lsa->hdr.ls_id = ls_id;
	lsa->data.asext.mask = prefixlen2mask(kr->prefixlen);

	/*
	 * nexthop -- on connected routes we are the nexthop,
	 * in other cases we may announce the true nexthop if the
	 * nexthop is reachable via an OSPF enabled interface but only
	 * broadcast & NBMA interfaces are considered in that case.
	 * It does not make sense to announce the nexthop of a point-to-point
	 * link since the traffic has to go through this box anyway.
	 * Some implementations actually check that there are multiple
	 * neighbors on the particular segment, we skip that check.
	 */
	iface = rde_asext_lookup(kr->nexthop.s_addr, -1);
	if (kr->flags & F_CONNECTED)
		lsa->data.asext.fw_addr = 0;
	else if (iface && (iface->type == IF_TYPE_BROADCAST ||
	    iface->type == IF_TYPE_NBMA))
		lsa->data.asext.fw_addr = kr->nexthop.s_addr;
	else
		lsa->data.asext.fw_addr = 0;

	lsa->data.asext.metric = htonl(kr->metric);
	lsa->data.asext.ext_tag = htonl(kr->ext_tag);

	lsa->hdr.ls_chksum = 0;
	lsa->hdr.ls_chksum = htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	return (lsa);
}

/*
 * summary LSA stuff
 */
void
rde_summary_update(struct rt_node *rte, struct area *area)
{
	struct rt_nexthop	*rn;
	struct rt_node		*nr;
	struct vertex		*v = NULL;
	struct lsa		*lsa;
	u_int8_t		 type = 0;

	/* first check if we actually need to announce this route */
	if (!(rte->d_type == DT_NET || rte->flags & OSPF_RTR_E))
		return;
	/* route is invalid, lsa_remove_invalid_sums() will do the cleanup */
	if (rte->cost >= LS_INFINITY)
		return;
	/* never create summaries for as-ext LSA */
	if (rte->p_type == PT_TYPE1_EXT || rte->p_type == PT_TYPE2_EXT)
		return;
	/* no need for summary LSA in the originating area */
	if (rte->area.s_addr == area->id.s_addr)
		return;
	/* no need to originate inter-area routes to the backbone */
	if (rte->p_type == PT_INTER_AREA && area->id.s_addr == INADDR_ANY)
		return;
	/* nexthop check, nexthop part of area -> no summary */
	TAILQ_FOREACH(rn, &rte->nexthop, entry) {
		if (rn->invalid)
			continue;
		nr = rt_lookup(DT_NET, rn->nexthop.s_addr);
		if (nr && nr->area.s_addr == area->id.s_addr)
			continue;
		break;
	}
	if (rn == NULL)
		/* all nexthops belong to this area or are invalid */
		return;

	/* TODO AS border router specific checks */
	/* TODO inter-area network route stuff */
	/* TODO intra-area stuff -- condense LSA ??? */

	if (rte->d_type == DT_NET) {
		type = LSA_TYPE_SUM_NETWORK;
	} else if (rte->d_type == DT_RTR) {
		if (area->stub)
			/* do not redistribute type 4 LSA into stub areas */
			return;
		type = LSA_TYPE_SUM_ROUTER;
	} else
		fatalx("rde_summary_update: unknown route type");

	/* update lsa but only if it was changed */
	v = lsa_find_area(area, type, rte->prefix.s_addr, rde_router_id());
	lsa = orig_sum_lsa(rte, area, type, rte->invalid);
	lsa_merge(rde_nbr_self(area), lsa, v);

	if (v == NULL)
		v = lsa_find_area(area, type, rte->prefix.s_addr,
		    rde_router_id());

	/* suppressed/deleted routes are not found in the second lsa_find */
	if (v)
		v->cost = rte->cost;
}

struct lsa *
orig_sum_lsa(struct rt_node *rte, struct area *area, u_int8_t type, int invalid)
{
	struct lsa	*lsa;
	u_int16_t	 len;

	len = sizeof(struct lsa_hdr) + sizeof(struct lsa_sum);
	if ((lsa = calloc(1, len)) == NULL)
		fatal("orig_sum_lsa");

	/* LSA header */
	lsa->hdr.age = htons(invalid ? MAX_AGE : DEFAULT_AGE);
	lsa->hdr.opts = area_ospf_options(area);
	lsa->hdr.type = type;
	lsa->hdr.adv_rtr = rdeconf->rtr_id.s_addr;
	lsa->hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa->hdr.len = htons(len);

	/* prefix and mask */
	/*
	 * TODO ls_id must be unique, for overlapping routes this may
	 * not be true. In this case a hack needs to be done to
	 * make the ls_id unique.
	 */
	lsa->hdr.ls_id = rte->prefix.s_addr;
	if (type == LSA_TYPE_SUM_NETWORK)
		lsa->data.sum.mask = prefixlen2mask(rte->prefixlen);
	else
		lsa->data.sum.mask = 0;	/* must be zero per RFC */

	lsa->data.sum.metric = htonl(rte->cost & LSA_METRIC_MASK);

	lsa->hdr.ls_chksum = 0;
	lsa->hdr.ls_chksum =
	    htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	return (lsa);
}
@


1.107
log
@Remove incomplete "forced nexthop" support.

Discussed with claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.106 2016/12/27 09:15:16 jca Exp $ */
d128 6
d135 1
a135 1
	log_procname = log_procnames[ospfd_process];
d612 1
a612 1
			log_verbose(verbose);
@


1.106
log
@struct rroute has been removed, rename variables.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.105 2016/09/28 14:39:52 krw Exp $ */
d1345 1
a1345 3
	if (kr->flags & F_FORCED_NEXTHOP)
		lsa->data.asext.fw_addr = kr->nexthop.s_addr;
	else if (kr->flags & F_CONNECTED)
@


1.105
log
@'unneded stuff' -> 'unneeded stuff' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.104 2016/09/04 10:10:23 krw Exp $ */
d1177 1
a1177 1
rde_asext_get(struct kroute *rr)
d1184 1
a1184 1
	if (rde_asext_lookup(rr->prefix.s_addr, rr->prefixlen)) {
d1187 1
a1187 1
		    inet_ntoa(rr->prefix), rr->prefixlen);
d1191 1
a1191 1
	an = asext_find(rr->prefix.s_addr, rr->prefixlen);
d1195 2
a1196 2
		bcopy(rr, &an->r, sizeof(*rr));
		an->ls_id = rr->prefix.s_addr;
d1200 1
a1200 1
		bcopy(rr, &an->r, sizeof(*rr));
d1234 1
a1234 1
				    inet_ntoa(rr->prefix), rr->prefixlen);
d1247 1
a1247 1
	lsa = orig_asext_lsa(rr, an->ls_id, DEFAULT_AGE);
d1259 1
a1259 1
rde_asext_put(struct kroute *rr)
d1269 1
a1269 1
	an = asext_find(rr->prefix.s_addr, rr->prefixlen);
d1272 1
a1272 1
		    inet_ntoa(rr->prefix), rr->prefixlen);
d1283 2
a1284 2
		rr->metric = ntohl(v->lsa->data.asext.metric);
		rr->ext_tag = ntohl(v->lsa->data.asext.ext_tag);
d1288 1
a1288 1
	lsa = orig_asext_lsa(rr, an->ls_id, MAX_AGE);
d1308 1
a1308 1
orig_asext_lsa(struct kroute *rr, u_int32_t ls_id, u_int16_t age)
d1319 1
a1319 1
	    inet_ntoa(rr->prefix), rr->prefixlen, age);
d1332 1
a1332 1
	lsa->data.asext.mask = prefixlen2mask(rr->prefixlen);
d1344 4
a1347 4
	iface = rde_asext_lookup(rr->nexthop.s_addr, -1);
	if (rr->flags & F_FORCED_NEXTHOP)
		lsa->data.asext.fw_addr = rr->nexthop.s_addr;
	else if (rr->flags & F_CONNECTED)
d1351 1
a1351 1
		lsa->data.asext.fw_addr = rr->nexthop.s_addr;
d1355 2
a1356 2
	lsa->data.asext.metric = htonl(rr->metric);
	lsa->data.asext.ext_tag = htonl(rr->ext_tag);
@


1.104
log
@A few bits of stray leading/embedded/trailing whitespace spotted while
stealing code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.103 2016/09/03 10:22:57 renato Exp $ */
d180 1
a180 1
	/* remove unneded stuff from config */
@


1.103
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.102 2016/09/02 14:02:48 benno Exp $ */
a846 1
		
d1134 1
a1134 1
static __inline int             
@


1.102
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.101 2016/06/06 15:56:22 benno Exp $ */
d42 1
a42 1
void		 rde_shutdown(void);
d201 1
a201 1
void
d207 6
a227 1
	msgbuf_clear(&iev_ospfe->ibuf.w);
a228 1
	msgbuf_clear(&iev_main->ibuf.w);
@


1.101
log
@add format attributes to the proper functions and then fix the
warning in rde.c
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.100 2015/12/05 12:20:13 claudio Exp $ */
d129 1
@


1.100
log
@Pledge ospfd SE ("stdio inet mcast") and RDE ("stdio") move some code
around to make it possible. Parent can't be pledged at the moment because
of carp ioctl (carp demote). Putting it in so that people can test.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.99 2015/12/03 11:41:06 claudio Exp $ */
d377 1
a377 1
				log_warnx("rde_dispatch_imsg: peerid %lu, "
d414 1
a414 1
				log_warnx("rde_dispatch_imsg: peerid %lu, "
@


1.99
log
@imsg_read will return EAGAIN in some cases so prep code for it.
This is in the way for ospfd pledge so in it goes. OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.98 2015/11/22 13:09:10 claudio Exp $ */
d114 3
d135 3
a219 1
	kr_shutdown();
@


1.98
log
@Improve ABR support especially for self-originated stub networks.
This seems to solve the last issues people reported when using ospfd
in multiple areas. OK sthen@@ prodding by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.97 2015/03/14 02:22:09 claudio Exp $ */
d258 1
a258 1
		if ((n = imsg_read(ibuf)) == -1)
d275 1
a275 1
			fatal("rde_dispatch_imsg: imsg_read error");
d631 1
a631 1
		if ((n = imsg_read(ibuf)) == -1)
d645 1
a645 1
			fatal("rde_dispatch_parent: imsg_read error");
@


1.97
log
@When removing interfaces in the RDE we also need to remove all the RDE
neighbors that are part of that interface or we open us up to use after
free situations like the one found by sthen@@.
Diff makes sense sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.96 2014/07/12 20:16:38 krw Exp $ */
a300 5
			if (state != nbr->state &&
			    (nbr->state & NBR_STA_FULL ||
			    state & NBR_STA_FULL))
				area_track(nbr->area, state);

d313 13
d782 3
d794 6
a799 2
	if (krcount == 0)
		fatalx("rde_send_change_kroute: no valid nexthop found");
d1370 3
d1384 2
d1391 2
a1392 1
	if (rn == NULL)	/* all nexthops belong to this area */
a1394 2
	if (rte->cost >= LS_INFINITY)
		return;
@


1.96
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.95 2013/11/13 20:43:00 benno Exp $ */
d963 16
@


1.95
log
@from claudio
"Let msgbuf_write return -1 with errno EAGAIN. The users then must
check if this was the case and readd the event or poll again.  The
current handling in the imsg code is wrong for sure."

ok gilles, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.94 2011/05/09 12:24:41 claudio Exp $ */
d264 1
a264 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d266 2
d629 1
a629 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d631 2
@


1.94
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.93 2011/05/02 11:17:03 claudio Exp $ */
d264 1
a264 1
		if (msgbuf_write(&ibuf->w) == -1)
d627 1
a627 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.93
log
@Wrap some long lines and other cleanup. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.92 2011/03/24 08:35:59 claudio Exp $ */
d45 1
a64 1

d308 8
d321 1
a321 1
			lsa_snap(nbr->area, imsg.hdr.peerid);
d343 1
a343 1
				v = lsa_find(nbr->area, lsa_hdr.type,
d384 1
a384 1
				if ((v = lsa_find(nbr->area,
d419 1
a419 1
			v = lsa_find(nbr->area, lsa->hdr.type, lsa->hdr.ls_id,
d515 1
a515 1
			v = lsa_find(nbr->area, lsa_hdr.type, lsa_hdr.ls_id,
d535 1
d543 1
a543 4
					imsg_compose_event(iev_ospfe,
					    IMSG_CTL_AREA, 0, imsg.hdr.pid, -1,
					    area, sizeof(*area));
					lsa_dump(&area->lsa_tree, imsg.hdr.type,
d551 1
a551 4
					imsg_compose_event(iev_ospfe,
					    IMSG_CTL_AREA, 0, imsg.hdr.pid, -1,
					    area, sizeof(*area));
					lsa_dump(&area->lsa_tree, imsg.hdr.type,
d692 1
d718 20
d930 1
d937 7
d950 1
d1371 1
a1371 1
	v = lsa_find(area, type, rte->prefix.s_addr, rde_router_id());
d1376 2
a1377 1
		v = lsa_find(area, type, rte->prefix.s_addr, rde_router_id());
@


1.92
log
@Fix some memory leaks. Mainly better cleanup on shutdown but the v_nexthop
leak is a runtime one.
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.91 2011/01/18 20:46:06 claudio Exp $ */
d230 2
a231 1
	return (imsg_compose_event(iev_ospfe, type, peerid, pid, -1, data, datalen));
d299 2
a300 1
			if (state != nbr->state && (nbr->state & NBR_STA_FULL ||
d447 4
a450 4
					imsg_compose_event(iev_ospfe, IMSG_LS_FLOOD,
					    v->peerid, 0, -1, v->lsa,
					    ntohs(v->lsa->hdr.len));
				/* lsa not added so free it */
d463 3
a465 2
					imsg_compose_event(iev_ospfe, IMSG_LS_BADREQ,
					    imsg.hdr.peerid, 0, -1, NULL, 0);
d508 1
a508 1
				    lsa_hdr.adv_rtr);
d534 3
a536 3
					imsg_compose_event(iev_ospfe, IMSG_CTL_AREA,
					    0, imsg.hdr.pid, -1, area,
					    sizeof(*area));
d545 3
a547 3
					imsg_compose_event(iev_ospfe, IMSG_CTL_AREA,
					    0, imsg.hdr.pid, -1, area,
					    sizeof(*area));
d556 2
a557 2
			imsg_compose_event(iev_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    -1, NULL, 0);
d570 2
a571 2
			imsg_compose_event(iev_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    -1, NULL, 0);
d577 2
a578 2
			imsg_compose_event(iev_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    -1, NULL, 0);
d770 2
a771 1
	imsg_compose_event(iev_main, IMSG_KROUTE_DELETE, 0, 0, -1, &kr, sizeof(kr));
@


1.91
log
@When fixing conflicts make sure the right vertex is passed to lsa_merge()
so that the correct sequence number is used for the LSA. So re-lookup the
vertex before calling lsa_merge().
Problem found and diff OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.90 2011/01/17 17:20:26 claudio Exp $ */
d62 1
d198 1
d208 5
d214 1
d377 5
a381 2
					imsg_compose_event(iev_ospfe, IMSG_LS_BADREQ,
					    imsg.hdr.peerid, 0, -1, NULL, 0);
d410 1
a410 1
				    lsa->hdr.adv_rtr);
d1212 12
@


1.90
log
@Fix redistribution of overlapping routes (e.g 10/8 and 10.0/16).
Select a different LS ID in case of a conflict. The most specific
route keeps the LS ID the others will try their broadcast addr
first and then count down. The redistributed asext LSA are now
stored in a RB tree to make this all work.
Tested by a few people no problems seen so far.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.89 2011/01/12 15:07:46 claudio Exp $ */
d1153 2
d1159 2
d1162 1
a1162 1
		lsa_merge(nbrself, lsa, NULL);
@


1.89
log
@Kill struct rroute and move the metric to struct kroute. This
disturbed me for a long time and makes upcomming work a bit easier.
OK sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.88 2010/09/25 13:28:43 claudio Exp $ */
d60 3
a62 2
struct lsa	*rde_asext_get(struct kroute *);
struct lsa	*rde_asext_put(struct kroute *);
a63 1
struct lsa	*orig_asext_lsa(struct kroute *, u_int16_t);
a596 2
	struct lsa		*lsa;
	struct vertex		*v;
d628 1
a628 7

			if ((lsa = rde_asext_get(&rr)) != NULL) {
				v = lsa_find(NULL, lsa->hdr.type,
				    lsa->hdr.ls_id, lsa->hdr.adv_rtr);

				lsa_merge(nbrself, lsa, v);
			}
d637 1
a637 14

			if ((lsa = rde_asext_put(&rr)) != NULL) {
				v = lsa_find(NULL, lsa->hdr.type,
				    lsa->hdr.ls_id, lsa->hdr.adv_rtr);

				/*
				 * if v == NULL no LSA is in the table and
				 * nothing has to be done.
				 */
				if (v)
					lsa_merge(nbrself, lsa, v);
				else
					free(lsa);
			}
d1029 38
d1084 1
a1084 1
struct lsa *
d1087 5
d1096 63
a1158 1
		return (NULL);
a1159 2
	/* update of seqnum is done by lsa_merge */
	return (orig_asext_lsa(rr, DEFAULT_AGE));
d1162 1
a1162 1
struct lsa *
d1165 4
d1171 12
a1182 1
	 * stub net LSA lsa_find() will fail later and nothing will happen.
d1184 6
d1192 62
a1253 1
	return (orig_asext_lsa(rr, MAX_AGE));
a1316 78
}


/*
 * functions for self-originated LSA
 */
struct lsa *
orig_asext_lsa(struct kroute *rr, u_int16_t age)
{
	struct lsa	*lsa;
	struct iface	*iface;
	u_int16_t	 len;

	len = sizeof(struct lsa_hdr) + sizeof(struct lsa_asext);
	if ((lsa = calloc(1, len)) == NULL)
		fatal("orig_asext_lsa");

	log_debug("orig_asext_lsa: %s/%d age %d",
	    inet_ntoa(rr->prefix), rr->prefixlen, age);

	/* LSA header */
	lsa->hdr.age = htons(age);
	lsa->hdr.opts = area_ospf_options(NULL);
	lsa->hdr.type = LSA_TYPE_EXTERNAL;
	lsa->hdr.adv_rtr = rdeconf->rtr_id.s_addr;
	lsa->hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa->hdr.len = htons(len);

	/* prefix and mask */
	/*
	 * TODO ls_id must be unique, for overlapping routes this may
	 * not be true. In this case a hack needs to be done to
	 * make the ls_id unique.
	 */
	lsa->hdr.ls_id = rr->prefix.s_addr;
	lsa->data.asext.mask = prefixlen2mask(rr->prefixlen);

	if (age == MAX_AGE) {
		/* inherit metric and ext_tag from the current LSA,
		 * some routers don't like to get withdraws that are
		 * different from what they have in their table.
		 */
		struct vertex *v;
		v = lsa_find(NULL, lsa->hdr.type, lsa->hdr.ls_id,
		    lsa->hdr.adv_rtr);
		if (v != NULL) {
			rr->metric = ntohl(v->lsa->data.asext.metric);
			rr->ext_tag = ntohl(v->lsa->data.asext.ext_tag);
		}
	}

	/*
	 * nexthop -- on connected routes we are the nexthop,
	 * in other cases we may announce the true nexthop if the
	 * nexthop is reachable via an OSPF enabled interface but only
	 * broadcast & NBMA interfaces are considered in that case.
	 * It does not make sense to announce the nexthop of a point-to-point
	 * link since the traffic has to go through this box anyway.
	 * Some implementations actually check that there are multiple
	 * neighbors on the particular segment, we skip that check.
	 */
	iface = rde_asext_lookup(rr->nexthop.s_addr, -1);
	if (rr->flags & F_CONNECTED)
		lsa->data.asext.fw_addr = 0;
	else if (iface && (iface->type == IF_TYPE_BROADCAST ||
	    iface->type == IF_TYPE_NBMA))
		lsa->data.asext.fw_addr = rr->nexthop.s_addr;
	else
		lsa->data.asext.fw_addr = 0;

	lsa->data.asext.metric = htonl(rr->metric);
	lsa->data.asext.ext_tag = htonl(rr->ext_tag);

	lsa->hdr.ls_chksum = 0;
	lsa->hdr.ls_chksum =
	    htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	return (lsa);
@


1.88
log
@When counting the lsa also build the sum of the ls_checksums. This can be
used to quickly verify if two LSDBs are in sync. Other systems do the same.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.87 2010/07/19 09:16:30 claudio Exp $ */
d60 2
a61 2
struct lsa	*rde_asext_get(struct rroute *);
struct lsa	*rde_asext_put(struct rroute *);
d63 1
a63 1
struct lsa	*orig_asext_lsa(struct rroute *, u_int16_t);
d594 1
a594 1
	struct rroute		 rr;
d1068 1
a1068 1
rde_asext_get(struct rroute *rr)
d1070 1
a1070 1
	if (rde_asext_lookup(rr->kr.prefix.s_addr, rr->kr.prefixlen)) {
d1073 1
a1073 1
		    inet_ntoa(rr->kr.prefix), rr->kr.prefixlen);
d1081 1
a1081 1
rde_asext_put(struct rroute *rr)
d1160 1
a1160 1
orig_asext_lsa(struct rroute *rr, u_int16_t age)
d1171 1
a1171 1
	    inet_ntoa(rr->kr.prefix), rr->kr.prefixlen, age);
d1187 2
a1188 2
	lsa->hdr.ls_id = rr->kr.prefix.s_addr;
	lsa->data.asext.mask = prefixlen2mask(rr->kr.prefixlen);
d1200 1
a1200 1
			rr->kr.ext_tag = ntohl(v->lsa->data.asext.ext_tag);
d1214 2
a1215 2
	iface = rde_asext_lookup(rr->kr.nexthop.s_addr, -1);
	if (rr->kr.flags & F_CONNECTED)
d1219 1
a1219 1
		lsa->data.asext.fw_addr = rr->kr.nexthop.s_addr;
d1224 1
a1224 1
	lsa->data.asext.ext_tag = htonl(rr->kr.ext_tag);
@


1.87
log
@When removing an announced prefix inherit the metric and ext_tag from the
LSA that is currently in the tree. Pruning with default metrics is bad
since the checksum of the LSA is different and therefor an additional
update cycle is needed to convince the other systems.
OK bluhm@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.86 2010/07/01 21:19:57 bluhm Exp $ */
d797 1
a797 1
	RB_FOREACH(v, lsa_tree, &asext_tree)
d799 3
d836 1
a836 1
	RB_FOREACH(v, lsa_tree, tree)
d838 2
@


1.86
log
@Fix memory leak by adding a missing free(lsa).
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.85 2010/05/26 13:56:08 nicm Exp $ */
d1184 14
@


1.85
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.84 2009/11/11 07:59:10 claudio Exp $ */
d656 2
@


1.84
log
@Fix an obvious use after free. Found by parfait. Reported and OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.83 2009/11/02 20:20:54 claudio Exp $ */
d741 1
a741 1
	struct buf		*wbuf;
@


1.83
log
@Implement IMSG_CTL_LOG_VERBOSE to enable or disable debug logging on runtime.
It always annoyed me that in case of a problem I had to restart the ospf in
forground debug mode and by doing so losing all routes at least twice.
OK henning, sthen, michele
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.82 2009/10/05 08:20:26 claudio Exp $ */
a440 3
				/* lsa no longer needed */
				free(lsa);

d452 1
d455 3
@


1.82
log
@Until now AS-ext LSA were always announced with the router as nexthop.
Change this so that the real nexthop is announced if the following
conditions are met:
 - the nexthop is reachable via an OSPF enabled interface
 - the interface is a broadcast or NBMA interface
It does not make sense to announce the nexthop of a point-to-point link
since the traffic has to go through this box anyway. This is closer to
what other systems implement.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.81 2009/06/06 07:31:26 eric Exp $ */
d243 1
a243 1
	int			 r, state, self, error, shut = 0;
d564 5
@


1.81
log
@sync ospfctl/ospfd with the common imsg code, making it lib ready as well.

"looks ok" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.80 2009/06/05 19:33:59 pyr Exp $ */
d59 1
d1037 2
a1038 2
struct lsa *
rde_asext_get(struct rroute *rr)
d1043 1
a1043 1
	LIST_FOREACH(area, &rdeconf->area_list, entry)
d1046 3
a1048 7
			    rr->kr.prefix.s_addr && iface->mask.s_addr ==
			    prefixlen2mask(rr->kr.prefixlen)) {
				/* already announced as (stub) net LSA */
				log_debug("rde_asext_get: %s/%d is net LSA",
				    inet_ntoa(rr->kr.prefix), rr->kr.prefixlen);
				return (NULL);
			}
d1050 3
d1054 9
d1150 1
d1179 7
a1185 4
	 * on all other cases we announce the true nexthop.
	 * XXX this is wrong as the true nexthop may be outside
	 * of the ospf cloud and so unreachable. For now we force
	 * all traffic to be directed to us.
d1187 8
a1194 1
	lsa->data.asext.fw_addr = 0;
@


1.80
log
@make ospfd's imsg lib ready as well.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.79 2009/05/31 18:46:01 jacekm Exp $ */
d66 2
a67 2
struct imsgbuf		*ibuf_ospfe;
struct imsgbuf		*ibuf_main;
d148 2
a149 2
	if ((ibuf_ospfe = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d151 4
a154 2
	imsg_init(ibuf_ospfe, pipe_ospfe2rde[1], rde_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent2rde[1], rde_dispatch_parent);
d157 9
a165 9
	ibuf_ospfe->events = EV_READ;
	event_set(&ibuf_ospfe->ev, ibuf_ospfe->fd, ibuf_ospfe->events,
	    ibuf_ospfe->handler, ibuf_ospfe);
	event_add(&ibuf_ospfe->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d207 4
a210 4
	msgbuf_clear(&ibuf_ospfe->w);
	free(ibuf_ospfe);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
d221 1
a221 1
	return (imsg_compose_event(ibuf_ospfe, type, peerid, pid, -1, data, datalen));
d228 2
a229 1
	struct imsgbuf		*ibuf = bula;
d245 2
d304 1
a304 1
			imsg_compose_event(ibuf_ospfe, IMSG_DB_END, imsg.hdr.peerid,
d337 1
a337 1
					imsg_compose_event(ibuf_ospfe, IMSG_DD,
d348 1
a348 1
				imsg_compose_event(ibuf_ospfe, IMSG_DD_END,
d351 1
a351 1
				imsg_compose_event(ibuf_ospfe, IMSG_DD_BADLSA,
d368 1
a368 1
					imsg_compose_event(ibuf_ospfe, IMSG_LS_BADREQ,
d372 1
a372 1
				imsg_compose_event(ibuf_ospfe, IMSG_LS_UPD,
d427 1
a427 1
				imsg_compose_event(ibuf_ospfe, IMSG_LS_FLOOD,
d433 1
a433 1
					imsg_compose_event(ibuf_ospfe, IMSG_LS_FLOOD,
d452 1
a452 1
					imsg_compose_event(ibuf_ospfe, IMSG_LS_BADREQ,
d467 1
a467 1
				imsg_compose_event(ibuf_ospfe, IMSG_LS_UPD,
d472 1
a472 1
				imsg_compose_event(ibuf_ospfe, IMSG_LS_ACK,
d518 1
a518 1
					imsg_compose_event(ibuf_ospfe, IMSG_CTL_AREA,
d529 1
a529 1
					imsg_compose_event(ibuf_ospfe, IMSG_CTL_AREA,
d540 1
a540 1
			imsg_compose_event(ibuf_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
d545 1
a545 1
				imsg_compose_event(ibuf_ospfe, IMSG_CTL_AREA,
d554 1
a554 1
			imsg_compose_event(ibuf_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
d561 1
a561 1
			imsg_compose_event(ibuf_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
d572 1
a572 1
		imsg_event_add(ibuf);
d575 1
a575 1
		event_del(&ibuf->ev);
d588 2
a589 1
	struct imsgbuf		*ibuf = bula;
d596 2
d704 1
a704 1
		imsg_event_add(ibuf);
d707 1
a707 1
		event_del(&ibuf->ev);
d736 1
a736 1
	if ((wbuf = imsg_create(ibuf_main, IMSG_KROUTE_CHANGE, 0, 0,
d755 2
a756 2
	imsg_close(ibuf_main, wbuf);
	imsg_event_add(ibuf_main);
d768 1
a768 1
	imsg_compose_event(ibuf_main, IMSG_KROUTE_DELETE, 0, 0, -1, &kr, sizeof(kr));
@


1.79
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.78 2009/05/31 16:58:54 claudio Exp $ */
d219 1
a219 1
	return (imsg_compose(ibuf_ospfe, type, peerid, pid, data, datalen));
d299 2
a300 2
			imsg_compose(ibuf_ospfe, IMSG_DB_END, imsg.hdr.peerid,
			    0, NULL, 0);
d332 2
a333 2
					imsg_compose(ibuf_ospfe, IMSG_DD,
					    imsg.hdr.peerid, 0, &lsa_hdr,
d343 2
a344 2
				imsg_compose(ibuf_ospfe, IMSG_DD_END,
				    imsg.hdr.peerid, 0, NULL, 0);
d346 2
a347 2
				imsg_compose(ibuf_ospfe, IMSG_DD_BADLSA,
				    imsg.hdr.peerid, 0, NULL, 0);
d363 2
a364 2
					imsg_compose(ibuf_ospfe, IMSG_LS_BADREQ,
					    imsg.hdr.peerid, 0, NULL, 0);
d367 2
a368 2
				imsg_compose(ibuf_ospfe, IMSG_LS_UPD,
				    imsg.hdr.peerid, 0, v->lsa,
d422 2
a423 2
				imsg_compose(ibuf_ospfe, IMSG_LS_FLOOD,
				    imsg.hdr.peerid, 0, lsa,
d428 2
a429 2
					imsg_compose(ibuf_ospfe, IMSG_LS_FLOOD,
					    v->peerid, 0, v->lsa,
d447 2
a448 2
					imsg_compose(ibuf_ospfe, IMSG_LS_BADREQ,
					    imsg.hdr.peerid, 0, NULL, 0);
d462 2
a463 2
				imsg_compose(ibuf_ospfe, IMSG_LS_UPD,
				    imsg.hdr.peerid, 0, v->lsa,
d467 2
a468 2
				imsg_compose(ibuf_ospfe, IMSG_LS_ACK,
				    imsg.hdr.peerid, 0, &lsa->hdr,
d513 2
a514 2
					imsg_compose(ibuf_ospfe, IMSG_CTL_AREA,
					    0, imsg.hdr.pid, area,
d524 2
a525 2
					imsg_compose(ibuf_ospfe, IMSG_CTL_AREA,
					    0, imsg.hdr.pid, area,
d535 2
a536 2
			imsg_compose(ibuf_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    NULL, 0);
d540 2
a541 2
				imsg_compose(ibuf_ospfe, IMSG_CTL_AREA,
				    0, imsg.hdr.pid, area, sizeof(*area));
d549 2
a550 2
			imsg_compose(ibuf_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    NULL, 0);
d556 2
a557 2
			imsg_compose(ibuf_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    NULL, 0);
d748 1
d760 1
a760 1
	imsg_compose(ibuf_main, IMSG_KROUTE_DELETE, 0, 0, &kr, sizeof(kr));
@


1.78
log
@The libevent callback function may be called with EV_READ and EV_WRITE
set at the same time so using a switch to do read or write is a bad idea.
Problem noticed by Eygene Ryabinkin on FreeBSD for some reasons it is not
triggered on OpenBSD.
Fix aggreed by a most other libevent hackers
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.77 2009/01/27 12:45:52 michele Exp $ */
a250 1
		imsg_event_add(ibuf);
a598 1
		imsg_event_add(ibuf);
@


1.77
log
@No need to check if neighbor exists before adding it
as it is already done in rde_nbr_new().

ok claudio@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.76 2009/01/07 21:16:36 claudio Exp $ */
d242 1
a242 2
	switch (event) {
	case EV_READ:
d247 2
a248 2
		break;
	case EV_WRITE:
a251 3
		return;
	default:
		fatalx("unknown event");
d591 1
a591 2
	switch (event) {
	case EV_READ:
d596 2
a597 2
		break;
	case EV_WRITE:
a600 3
		return;
	default:
		fatalx("unknown event");
@


1.76
log
@Full stub area support. This allows ABRs to announce a default network
summary LSA into stub areas so that these routers are able to reach the
outside of the area.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.75 2008/12/12 22:43:17 claudio Exp $ */
d273 1
a273 1
			if (rde_nbr_find(imsg.hdr.peerid))
a275 1
			rde_nbr_new(imsg.hdr.peerid, &rn);
@


1.75
log
@Make the kroute code routing priority aware. This solves a few issues and
makes to code simpler. While the routing table is somewhat simpler the
redistribution code does not allow a much more radical approach. With some
additional help of Mr. Kernel and his rtsock it should be possible to rip
even more code out of kroute.c.
Tested and OK sthen@@, gollo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.74 2008/11/24 18:28:02 claudio Exp $ */
d592 1
d671 1
d675 7
d721 10
d1078 2
d1096 10
a1105 1
	/* TODO nexthop check, nexthop part of area -> no summary */
@


1.74
log
@Initial support for stub areas. The bit still missing is the redistribution
of the default summary net lsa on ABRs but that is comming. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.73 2008/02/11 12:37:37 norby Exp $ */
a587 1
	struct kroute		 kr;
a591 1
	struct rt_node		*rn;
a651 16
			break;
		case IMSG_KROUTE_GET:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(kr)) {
				log_warnx("rde_dispatch_parent: "
				    "wrong imsg len");
				break;
			}
			memcpy(&kr, imsg.data, sizeof(kr));

			if ((rn = rt_find(kr.prefix.s_addr, kr.prefixlen,
			    DT_NET)) != NULL)
				rde_send_change_kroute(rn);
			else
				/* should not happen */
				imsg_compose(ibuf_main, IMSG_KROUTE_DELETE, 0,
				    0, &kr, sizeof(kr));
@


1.73
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.72 2007/10/11 12:19:31 claudio Exp $ */
d239 1
a239 1
	int			 r, state, self, shut = 0;
d314 1
d320 5
d343 1
a343 1
			if (l != 0)
d348 6
a353 2
			imsg_compose(ibuf_ospfe, IMSG_DD_END, imsg.hdr.peerid,
			    0, NULL, 0);
d1103 3
@


1.72
log
@Bye bye global ospf options. OSPF options are per area (at least the one
flag that we set). So introduce a area_ospf_options() function that will
return the correct flags for each area. This makes stub area support a lot
easier.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.71 2007/10/01 08:35:12 norby Exp $ */
d504 1
a504 1
				log_warnx("rde_dispatch: wrong imsg len");
d556 1
a556 1
			log_debug("rde_dispatch_msg: unexpected imsg %d",
d612 2
a613 1
				log_warnx("rde_dispatch: wrong imsg len");
d627 2
a628 1
				log_warnx("rde_dispatch: wrong imsg len");
d647 2
a648 1
				log_warnx("rde_dispatch: wrong imsg len");
@


1.71
log
@fix alot of whitespace problems...
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.70 2007/09/25 11:25:41 claudio Exp $ */
d63 1
a63 1
struct lsa	*orig_sum_lsa(struct rt_node *, u_int8_t, int);
d1096 1
a1096 1
	lsa = orig_sum_lsa(rte, type, rte->invalid);
d1126 1
a1126 1
	lsa->hdr.opts = rdeconf->options;	/* XXX not updated */
d1161 1
a1161 1
orig_sum_lsa(struct rt_node *rte, u_int8_t type, int invalid)
d1172 1
a1172 1
	lsa->hdr.opts = rdeconf->options;	/* XXX not updated */
@


1.70
log
@Last missing piece in the equal cost multipath support for ospfd.
Send all possible nexthops to the parent process and correctly sync
the RIB, FIB and kernel routing table. Based on initial work by pyr@@.
OK pyr@@ norby@@
PS: don't forget that you need to enable multipath support via a sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.69 2007/07/25 19:11:27 claudio Exp $ */
d721 1
a721 1
	struct kroute	 	 kr;
d1049 1
a1049 1
	/* 
d1102 1
a1102 1
	/* suppressed/deleted routes are not found in the second lsa_find */ 
@


1.69
log
@Don't fatal if the imsg pipe is closed, this is often triggered in the parent
and hides the real cause of the termination.
OK norby@@, reyk@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.68 2007/06/19 16:45:15 reyk Exp $ */
d720 1
d723 6
d731 10
a740 2
		if (!rn->invalid)
			break;
d742 1
a742 1
	if (!rn)
d744 1
a744 8

	bzero(&kr, sizeof(kr));
	kr.prefix.s_addr = r->prefix.s_addr;
	kr.nexthop.s_addr = rn->nexthop.s_addr;
	kr.prefixlen = r->prefixlen;
	kr.ext_tag = r->ext_tag;

	imsg_compose(ibuf_main, IMSG_KROUTE_CHANGE, 0, 0, &kr, sizeof(kr));
@


1.68
log
@add support for mapping route labels to AS-external route tags.

manpage bits from jmc@@
ok norby@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.67 2007/06/19 14:42:09 pyr Exp $ */
d239 1
a239 1
	int			 r, state, self;
d247 1
a247 1
			fatalx("pipe closed");
d562 7
a568 1
	imsg_event_add(ibuf);
d585 1
d592 1
a592 1
			fatalx("pipe closed");
d702 7
a708 1
	imsg_event_add(ibuf);
@


1.67
log
@Allow ospfd reconfiguration through SIGHUP, add SIGHUP handlers in
children like in bgpd so that ``pkill -1 ospfd'' works as expected.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.66 2007/04/11 07:09:15 claudio Exp $ */
d721 1
d1130 1
a1130 1
	lsa->data.asext.ext_tag = 0;
@


1.66
log
@Simplify rde_summary_update(). The route entry has a valid/invalid flag
so there is no need to loop over the nexthops and we no longer need to
pass the rt_nexthop to the summary LSA generation (a flag is enough).
OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.65 2007/04/10 13:26:39 claudio Exp $ */
d140 1
@


1.65
log
@Next step in equal cost multipath support. Make the SPF calculation multipath
aware. Both the SPF and RIB trees need additional structures to store the
multiple nexthops to the destination but only the first active nexthop is
passed to the parent process and used for routing. This is the next thing
that needs to be modified. Tested and OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.64 2007/04/05 18:50:45 pyr Exp $ */
d63 1
a63 1
struct lsa	*orig_sum_lsa(struct rt_node *, struct rt_nexthop *, u_int8_t);
a1042 1
	struct rt_nexthop	*rn;
a1044 7
	TAILQ_FOREACH(rn, &rte->nexthop, entry) {
		if (!rn->invalid)
			break;
	}
	if (!rn)
		rn = TAILQ_FIRST(&rte->nexthop);

d1073 1
a1073 1
	lsa = orig_sum_lsa(rte, rn, type);
d1138 1
a1138 1
orig_sum_lsa(struct rt_node *rte, struct rt_nexthop *rn, u_int8_t type)
d1148 1
a1148 1
	lsa->hdr.age = htons(rn->invalid ? MAX_AGE : DEFAULT_AGE);
a1174 1

@


1.64
log
@remove an unused function.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.63 2007/04/04 12:45:44 claudio Exp $ */
d63 1
a63 1
struct lsa	*orig_sum_lsa(struct rt_node *, u_int8_t);
d706 9
a714 1
	struct kroute	 kr;
d718 1
a718 1
	kr.nexthop.s_addr = r->nexthop.s_addr;
a730 1
	kr.nexthop.s_addr = r->nexthop.s_addr;
d1041 11
a1051 3
	struct vertex	*v = NULL;
	struct lsa	*lsa;
	u_int8_t	 type = 0;
d1081 1
a1081 1
	lsa = orig_sum_lsa(rte, type);
d1146 1
a1146 1
orig_sum_lsa(struct rt_node *rte, u_int8_t type)
d1156 1
a1156 1
	lsa->hdr.age = htons(rte->invalid ? MAX_AGE : DEFAULT_AGE);
@


1.63
log
@Type 4 (router) summery LSA need to be sent out with an LS ID equal to the
ASBR router ID. Using the avertising router for this only works for intra-
area routes but fails horribly for inter-area ones. Luckily RIB router entries
use the router ID as prefix so just use that instead -- this simplifies the
code nicly. Figured out the hardway by pyr@@. Tested and OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.62 2007/04/04 12:40:13 claudio Exp $ */
a211 7
}

/* imesg */
int
rde_imsg_compose_parent(int type, pid_t pid, void *data, u_int16_t datalen)
{
	return (imsg_compose(ibuf_main, type, 0, pid, data, datalen));
@


1.62
log
@There is no need to originate inter-area routes to the backbone.
Inter-area routes are already comming from the backbone so readding them
is wrong.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.61 2007/03/30 14:12:55 claudio Exp $ */
a1063 1
	/* update lsa but only if it was changed */
a1065 1
		v = lsa_find(area, type, rte->prefix.s_addr, rde_router_id());
a1067 1
		v = lsa_find(area, type, rte->adv_rtr.s_addr, rde_router_id());
d1071 2
d1076 3
a1078 8
	if (v == NULL) {
		if (rte->d_type == DT_NET)
			v = lsa_find(area, type, rte->prefix.s_addr,
			    rde_router_id());
		else
			v = lsa_find(area, type, rte->adv_rtr.s_addr,
			    rde_router_id());
	}
d1161 2
a1162 2
	if (type == LSA_TYPE_SUM_NETWORK) {
		lsa->hdr.ls_id = rte->prefix.s_addr;
d1164 1
a1164 2
	} else {
		lsa->hdr.ls_id = rte->adv_rtr.s_addr;
a1165 1
	}
@


1.61
log
@Use correct function name in fatalx() message.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.60 2007/02/12 13:23:13 claudio Exp $ */
d1053 3
@


1.60
log
@rde_nbr_loading() may be called with area == NULL. Check for this condition
and scan all available areas in that case -- the only case when this may
happen is for self announced AS-ext LSA. This solves a crash when
redistributed routes were removed shortly after startup.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.59 2007/02/09 10:19:40 claudio Exp $ */
d1069 1
a1069 1
		fatalx("orig_sum_lsa: unknown route type");
@


1.59
log
@Remove unneeded statement. The debug code needing it is long gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.58 2007/02/01 13:25:28 claudio Exp $ */
d903 1
d905 3
a907 6
	LIST_FOREACH(nbr, &area->nbr_list, entry) {
		if (nbr->self)
			continue;
		if (nbr->state & NBR_STA_XCHNG ||
		    nbr->state & NBR_STA_LOAD)
			return (1);
d909 14
@


1.58
log
@whitespace cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.57 2007/02/01 13:02:05 claudio Exp $ */
a483 2

			aid.s_addr = lsa_hdr.ls_id;
@


1.57
log
@Preliminary configuration reload support. Seems to work reasonably well
after fixing many use-after-free errors a couple of days ago.
Most cases -- adding/removing of interfaces, adding/removing of areas --
seem to work. Still merge_config() is a behemoth of a function and some
edge cases may not be covered correctly (yet).
OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.56 2007/02/01 12:46:54 claudio Exp $ */
d172 1
a172 1
	
@


1.56
log
@There is no need to check if the LSA is matched by an net LSA in
rde_asext_put(). Just try to remove the as-ext LSA, if the prefix is
announced as stub net LSA lsa_find() will fail later and nothing will
happen. OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.55 2007/01/29 13:04:13 claudio Exp $ */
d65 1
a65 1
struct ospfd_conf	*rdeconf = NULL;
d577 2
d658 18
d677 18
@


1.55
log
@Do not link from the LS DB to outside structures that may vanish before
the actual LS DB entry is removed. In particular a neighbor may be removed
at any time -- we were lucky because we kept down neighbors around for
another 24h. Reload support unhided this problem again. Just copy the
needed info into the vertex. Pointing to the area is save as the vertex is
part of the area itself and removed when the area is removed.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.54 2007/01/24 10:48:47 claudio Exp $ */
d634 6
a639 1
				lsa_merge(nbrself, lsa, v);
d978 4
a981 14
	struct area	*area;
	struct iface	*iface;

	LIST_FOREACH(area, &rdeconf->area_list, entry)
		LIST_FOREACH(iface, &area->iface_list, entry) {
			if ((iface->addr.s_addr & iface->mask.s_addr) ==
			    rr->kr.prefix.s_addr && iface->mask.s_addr ==
			    prefixlen2mask(rr->kr.prefixlen)) {
				/* already announced as (stub) net LSA */
				log_debug("rde_asext_put: %s/%d is net LSA",
				    inet_ntoa(rr->kr.prefix), rr->kr.prefixlen);
				return (NULL);
			}
		}
@


1.54
log
@Remove some log_debug()s that are no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.53 2007/01/20 17:13:36 claudio Exp $ */
d431 1
a431 1
					    v->nbr->peerid, 0, v->lsa,
@


1.53
log
@Ignore SIGPIPE in the parent and RDE as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.52 2007/01/11 21:43:13 claudio Exp $ */
a485 3
			log_debug("rde_dispatch_imsg: IMSG_LS_MAXAGE, "
			    "type %d ls_id %s", lsa_hdr.type,
			    inet_ntoa(aid));
d487 1
a487 2
			if (rde_nbr_loading(nbr->area)) {
				log_debug("IMSG_LS_MAXAGE still loading");
a488 1
			}
@


1.52
log
@Silently ignore unknown neighbors in the rde and ospfe imsg handler. This
is needed for upcomming reload support -- it can happen that a message to
a just deleted neighbor is still pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.51 2007/01/11 21:35:15 claudio Exp $ */
d139 1
@


1.51
log
@Remove unneeded config stuff when booting up the RDE. This makes the reload
handling a bit easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.50 2006/12/21 17:10:11 claudio Exp $ */
d293 1
a293 3
				fatalx("rde_dispatch_imsg: "
				    "neighbor does not exist");

d306 1
a306 2
				fatalx("rde_dispatch_imsg: "
				    "neighbor does not exist");
d316 1
a316 2
				fatalx("rde_dispatch_imsg: "
				    "neighbor does not exist");
d353 1
a353 2
				fatalx("rde_dispatch_imsg: "
				    "neighbor does not exist");
d380 1
a380 2
				fatalx("rde_dispatch_imsg: "
				    "neighbor does not exist");
d477 1
a477 2
				fatalx("rde_dispatch_imsg: "
				    "neighbor does not exist");
@


1.50
log
@order variables by size/type.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.49 2006/12/08 21:28:08 claudio Exp $ */
d94 1
d96 2
a97 1
	struct event		 ev_sigint, ev_sigterm;
d167 5
@


1.49
log
@Fix a crash seen on busy area border routers. The problem was a NULL
dereference in rde_summary_update(). Even though we merge in the new LSA
it may be suppressed because the remove happened less than 5 seconds ago.
So the second lsa_find() is still unable to locate the LSA and in this case
we may not access v->cost. Additionally only remove not yet deleted LSA
in lsa_remove_invalid_sums(), removing already removed entries removes also
the suppressed LSAs.
Problem found and fix tested by Pierre-Yves Ritschard. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.48 2006/12/07 19:14:27 claudio Exp $ */
d95 1
a97 1
	struct event		 ev_sigint, ev_sigterm;
@


1.48
log
@Make it possible to set the metric and LSA type for redistributed routes.
Mostly based on a diff by Pierre-Yves Ritschard (I just simplified the parser
code). OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.47 2006/06/28 10:53:39 norby Exp $ */
d1043 3
a1045 1
	v->cost = rte->cost;
@


1.47
log
@Track the uptime of the ospfd daemon itself.
It is possible to read the uptime of the daemon with the "ospfctl show"
command.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.46 2006/05/30 22:06:14 claudio Exp $ */
d59 2
a60 2
struct lsa	*rde_asext_get(struct kroute *);
struct lsa	*rde_asext_put(struct kroute *);
d62 1
a62 1
struct lsa	*orig_asext_lsa(struct kroute *, u_int16_t);
d583 1
d614 1
a614 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(kr)) {
d618 1
a618 1
			memcpy(&kr, imsg.data, sizeof(kr));
d620 1
a620 1
			if ((lsa = rde_asext_get(&kr)) != NULL) {
d628 1
a628 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(kr)) {
d632 1
a632 1
			memcpy(&kr, imsg.data, sizeof(kr));
d634 1
a634 1
			if ((lsa = rde_asext_put(&kr)) != NULL) {
d953 1
a953 1
rde_asext_get(struct kroute *kr)
d961 2
a962 2
			    kr->prefix.s_addr && iface->mask.s_addr ==
			    prefixlen2mask(kr->prefixlen)) {
d965 1
a965 1
				    inet_ntoa(kr->prefix), kr->prefixlen);
d971 1
a971 1
	return (orig_asext_lsa(kr, DEFAULT_AGE));
d975 1
a975 1
rde_asext_put(struct kroute *kr)
d983 2
a984 2
			    kr->prefix.s_addr && iface->mask.s_addr ==
			    prefixlen2mask(kr->prefixlen)) {
d987 1
a987 1
				    inet_ntoa(kr->prefix), kr->prefixlen);
d993 1
a993 1
	return (orig_asext_lsa(kr, MAX_AGE));
d1051 1
a1051 1
orig_asext_lsa(struct kroute *kr, u_int16_t age)
d1061 1
a1061 1
	    inet_ntoa(kr->prefix), kr->prefixlen, age);
d1077 2
a1078 2
	lsa->hdr.ls_id = kr->prefix.s_addr;
	lsa->data.asext.mask = prefixlen2mask(kr->prefixlen);
d1089 1
a1089 2
	lsa->data.asext.metric = htonl(/* LSA_ASEXT_E_FLAG | */ 100);
	/* XXX until now there is no metric */
@


1.46
log
@Now that rtlabels are accessable via sysctl we can use route lables to
define which routes should be redistributed via OSPF. So now you can
define the export list on a fine graded basis. More to come... OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.45 2006/05/29 16:50:36 claudio Exp $ */
d94 1
d170 3
d702 1
d717 6
@


1.45
log
@Delay lsa database deletes for MIN_LS_INTERVAL seconds so that flapping
routes do not cause a update storm. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.44 2006/03/22 16:01:20 claudio Exp $ */
d95 1
d163 5
@


1.44
log
@Move the AS external LSA tree out of struct ospfd_config. This simplifies
the code and makes config reloads easier. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.43 2006/03/09 16:55:51 claudio Exp $ */
d403 3
d407 3
a409 1
					lsa_add(nbr, lsa);
a410 1
				rde_req_list_del(nbr, &lsa->hdr);
@


1.43
log
@More spring cleaning with lint. Change a few types and add some comments to
help lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.42 2006/03/08 16:03:40 claudio Exp $ */
d69 1
d108 1
a108 1
	rdeconf = xconf; /* XXX may not be replaced because of the lsa_tree */
d128 1
a128 1
	lsa_init(&rdeconf->lsa_tree);
d513 1
a513 1
				lsa_dump(&rdeconf->lsa_tree, imsg.hdr.type,
d524 1
a524 1
						lsa_dump(&rdeconf->lsa_tree,
a687 1
	struct lsa_tree		*tree = &rdeconf->lsa_tree;
d700 1
a700 1
	RB_FOREACH(v, lsa_tree, tree)
@


1.42
log
@Remove unused quit flag inherited from bgpd long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.41 2006/03/08 13:49:07 claudio Exp $ */
d70 1
a84 1
		/* NOTREACHED */
d100 1
d209 1
d224 1
d226 1
a226 1
	int			 r, n, state, self;
d562 1
d572 1
a572 1
	int			 n;
d1032 1
a1032 1
	size_t		 len;
d1082 1
a1082 1
	size_t		 len;
@


1.41
log
@Fix logic of the kroute code. First of all there was a porblem if a prefix
is known via kernel and ospf. If the kernel route is removed the ospf one
was not added to the FIB. This is an uncommon event so it is OK to request
an update from the RIB in this case.
Additionally ospfd treated bgpd inserted routes like static routes. This
is wrong because IGP routes habe a higher preference over EGP routes. In
this case a bgpd route needs to be overridden by a ospfd one.
With these to fixes bgpd and ospfd start to play nicely together.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.40 2006/02/21 13:02:59 claudio Exp $ */
a64 1
volatile sig_atomic_t	 rde_quit = 0;
@


1.40
log
@Better English in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.39 2006/02/10 18:30:47 claudio Exp $ */
d563 2
a565 1
	struct imsg		 imsg;
d568 1
a568 1
	struct kroute		 kr;
d621 16
@


1.39
log
@ospfd does not need fd passing via the imsg framework so remove that code
and remove other unneeded functions that are only used in bgpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.38 2006/02/10 13:00:49 claudio Exp $ */
d425 1
a425 1
				 * because a equal LSA is already in the table.
@


1.38
log
@If ABR only look in the backbone area 0.0.0.0 for summary LSA. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.37 2006/01/12 15:10:02 claudio Exp $ */
d199 1
a199 1
	return (imsg_compose(ibuf_main, type, 0, pid, -1, data, datalen));
d206 1
a206 1
	return (imsg_compose(ibuf_ospfe, type, peerid, pid, -1, data, datalen));
d294 1
a294 1
			    0, -1, NULL, 0);
d322 2
a323 2
					    imsg.hdr.peerid, 0, -1,
					    &lsa_hdr, sizeof(lsa_hdr));
d332 1
a332 1
			    0, -1, NULL, 0);
d350 1
a350 1
					    imsg.hdr.peerid, 0, -1, NULL, 0);
d354 2
a355 2
				    imsg.hdr.peerid, 0, -1,
				    v->lsa, ntohs(v->lsa->hdr.len));
d406 2
a407 2
				    imsg.hdr.peerid, 0, -1,
				    lsa, ntohs(lsa->hdr.len));
d412 2
a413 2
					    v->nbr->peerid, 0, -1,
					    v->lsa, ntohs(v->lsa->hdr.len));
d431 1
a431 1
					    imsg.hdr.peerid, 0, -1, NULL, 0);
d446 2
a447 2
				    imsg.hdr.peerid, 0, -1,
				    v->lsa, ntohs(v->lsa->hdr.len));
d451 1
a451 1
				    imsg.hdr.peerid, 0, -1, &lsa->hdr,
d505 1
a505 1
					    0, imsg.hdr.pid, -1, area,
d516 1
a516 1
					    0, imsg.hdr.pid, -1, area,
d527 1
a527 1
			    -1, NULL, 0);
d532 1
a532 2
				    0, imsg.hdr.pid, -1, area,
				    sizeof(*area));
d541 1
a541 1
			    -1, NULL, 0);
d548 1
a548 1
			    -1, NULL, 0);
d647 1
a647 1
	imsg_compose(ibuf_main, IMSG_KROUTE_CHANGE, 0, 0, -1, &kr, sizeof(kr));
d660 1
a660 1
	imsg_compose(ibuf_main, IMSG_KROUTE_DELETE, 0, 0, -1, &kr, sizeof(kr));
@


1.37
log
@Rewrite the redistribute code. The previous implementation was stupid and
resulted in a major bottleneck if bgpd was used on the same box -- not clever
to do linear searches over 175k entries :(. This now moves the redistribute
code back into kroute duty and kills the linear list. Also default routes are
now redistributed without the need for a kernel default route.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.36 2006/01/05 15:10:57 norby Exp $ */
d276 5
a281 1

@


1.36
log
@Improve how ospfd copes with time changes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.35 2005/12/29 13:58:49 claudio Exp $ */
a58 2
int		 rde_redistribute(struct kroute *);
void		 rde_update_redistribute(int);
a60 1
void		 rde_asext_free(void);
a183 1
	rde_asext_free();
a564 1
	struct kif		 kif;
a617 12
		case IMSG_IFINFO:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(kif)) {
				log_warnx("rde_dispatch: wrong imsg len");
				break;
			}
			memcpy(&kif, imsg.data, sizeof(kif));

			log_debug("IMSG_IFINFO: ifindex %i reachable %d",
			    kif.ifindex, kif.nh_reachable);
			kif_update(&kif);
			rde_update_redistribute(kif.ifindex);
			break;
d907 2
a908 4
LIST_HEAD(, rde_asext) rde_asext_list;

int
rde_redistribute(struct kroute *kr)
a911 30
	int		 rv = 0;

	if (!(kr->flags & F_KERNEL))
		return (0);

	if ((rdeconf->options & OSPF_OPTION_E) == 0)
		return (0);

	if ((rdeconf->redistribute_flags & REDISTRIBUTE_DEFAULT) &&
	    (kr->prefix.s_addr == INADDR_ANY && kr->prefixlen == 0))
		return (1);

	/* only allow 0.0.0.0/0 if REDISTRIBUTE_DEFAULT */
	if (kr->prefix.s_addr == INADDR_ANY && kr->prefixlen == 0)
		return (0);

	if ((rdeconf->redistribute_flags & REDISTRIBUTE_STATIC) &&
	    (kr->flags & F_STATIC))
		rv = 1;
	if ((rdeconf->redistribute_flags & REDISTRIBUTE_CONNECTED) &&
	    (kr->flags & F_CONNECTED))
		rv = 1;

	/* route does not match redistribute_flags */
	if (rv == 0)
		return (0);

	/* interface is not up and running so don't announce */
	if (kif_validate(kr->ifindex) == 0)
		return (0);
d917 6
a922 2
			    prefixlen2mask(kr->prefixlen))
				rv = 0;	/* already announced as net LSA */
d925 2
a926 60
	return (rv);
}

void
rde_update_redistribute(int ifindex)
{
	struct rde_asext	*ae;
	struct lsa		*lsa;
	struct vertex		*v;
	int			 wasused;

	LIST_FOREACH(ae, &rde_asext_list, entry)
		if (ae->kr.ifindex == ifindex) {
			wasused = ae->used;
			ae->used = rde_redistribute(&ae->kr);
			if (ae->used)
				lsa = orig_asext_lsa(&ae->kr, DEFAULT_AGE);
			else if (wasused)
				lsa = orig_asext_lsa(&ae->kr, MAX_AGE);
			else
				continue;

			v = lsa_find(NULL, lsa->hdr.type,
			    lsa->hdr.ls_id, lsa->hdr.adv_rtr);

			lsa_merge(nbrself, lsa, v);
		}
}

struct lsa *
rde_asext_get(struct kroute *kr)
{
	struct rde_asext	*ae;
	int			 wasused;

	LIST_FOREACH(ae, &rde_asext_list, entry)
		if (kr->prefix.s_addr == ae->kr.prefix.s_addr &&
		    kr->prefixlen == ae->kr.prefixlen)
			break;

	if (ae == NULL) {
		if ((ae = calloc(1, sizeof(*ae))) == NULL)
			fatal("rde_asext_get");
		LIST_INSERT_HEAD(&rde_asext_list, ae, entry);
	}

	memcpy(&ae->kr, kr, sizeof(ae->kr));

	wasused = ae->used;
	ae->used = rde_redistribute(kr);

	if (ae->used)
		/* update of seqnum is done by lsa_merge */
		return (orig_asext_lsa(kr, DEFAULT_AGE));
	else if (wasused)
		/* lsa_merge will take care of removing the lsa from the db */
		return (orig_asext_lsa(kr, MAX_AGE));
	else
		/* not in lsdb, superseded by a net lsa */
		return (NULL);
d932 2
a933 2
	struct rde_asext	*ae;
	int			 used;
d935 10
a944 9
	LIST_FOREACH(ae, &rde_asext_list, entry)
		if (kr->prefix.s_addr == ae->kr.prefix.s_addr &&
		    kr->prefixlen == ae->kr.prefixlen) {
			LIST_REMOVE(ae, entry);
			used = ae->used;
			free(ae);
			if (used)
				return (orig_asext_lsa(kr, MAX_AGE));
			break;
a945 7
	return (NULL);
}

void
rde_asext_free(void)
{
	struct rde_asext	*ae;
d947 2
a948 4
	while ((ae = LIST_FIRST(&rde_asext_list)) != NULL) {
		LIST_REMOVE(ae, entry);
		free(ae);
	}
a949 1

@


1.35
log
@More correct cleanup on exit. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.34 2005/12/05 13:18:25 claudio Exp $ */
d222 1
d247 2
a248 1
	now = time(NULL);
@


1.34
log
@Optimize rde_redistribute() a bit and remove two unneeded and way to verbose
log_debug() messages. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.33 2005/11/04 10:46:23 claudio Exp $ */
d49 1
d63 1
d176 2
d182 7
a188 1
	msgbuf_write(&ibuf_ospfe->w);
a190 1
	msgbuf_write(&ibuf_main->w);
d193 1
d767 7
d1048 12
@


1.33
log
@Kill spf_timer in struct ospfd_conf. There is no need for two event structs
just use ev for the spf_timer -- ev is unused in the RDE.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.32 2005/11/04 10:38:03 claudio Exp $ */
a589 2
			log_debug("rde: new announced net %s/%d",
			    inet_ntoa(kr.prefix), kr.prefixlen);
a603 2
			log_debug("rde: removing announced net %s/%d",
				    inet_ntoa(kr.prefix), kr.prefixlen);
d934 4
@


1.32
log
@Use >= instead of == to compare cost with LS_INFINITY. While there fix a typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.31 2005/10/19 21:43:20 claudio Exp $ */
d159 1
a159 1
	evtimer_set(&rdeconf->spf_timer, spf_timer, rdeconf);
@


1.31
log
@fix some spellings in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.30 2005/10/12 09:51:58 claudio Exp $ */
d1051 2
a1052 2
	/* TODO nexthop check, nexthop part of aera -> no summary */
	if (rte->cost == LS_INFINITY)
@


1.30
log
@Fix the flooding procedure. Violate the RFC else many BAD_LS_REQ events and
session drops happend while booting up. If a router is conected to a other
router over two different interface one session will be unable to load until
the other one is in state FULL. ospfd no longer issues a BAD_LS_REQ event
if the LSA is equal to the one in table but if the sent lsa is older a
BAD_LS_REQ event is still issued.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.29 2005/10/12 09:42:57 claudio Exp $ */
d305 1
a305 1
					 * only request LSA's that are
@


1.29
log
@Fix a massive memory leak in the RDE. ospfd leaked every ls update unless
lsa_add() was called (which is just one specific case of many)
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.28 2005/08/08 12:22:48 claudio Exp $ */
a404 5
			} else if (rde_req_list_exists(nbr, &lsa->hdr)) {
				/* lsa no longer needed */
				free(lsa);
				imsg_compose(ibuf_ospfe, IMSG_LS_BADREQ,
				    imsg.hdr.peerid, 0, -1, NULL, 0);
d409 14
d428 1
@


1.28
log
@Try to do an SPF recalculation only if the LS DB changed.
This is still not perfect as on ABRs it is only necessary to
recalculate the area that got changed and not all others too.
More to come but it is a good start. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.27 2005/05/26 22:22:37 norby Exp $ */
d362 2
a363 1
			    imsg.hdr.len - IMSG_HEADER_SIZE))
d365 1
d376 1
d384 2
a385 1
				    v->changed + MIN_LS_ARRIVAL >= now)
d387 1
d402 3
d406 2
d411 3
d431 1
@


1.27
log
@Remove unneeded debugging messages from rde imsg handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.26 2005/05/26 18:46:16 norby Exp $ */
a373 1
				start_spf_timer(rdeconf);
a396 2

				start_spf_timer(rdeconf);
@


1.26
log
@Support dumping the configuration the way bgpd(8) does it.

This makes it possible to have ospfd(8) parse a configuration file and
display the parsed result.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.25 2005/05/25 23:20:36 norby Exp $ */
a277 2
			log_debug("rde_dispatch_imsg: IMSG_DB_SNAPSHOT, "
			    "neighbor %s", inet_ntoa(nbr->id));
a288 2
			log_debug("rde_dispatch_imsg: IMSG_DD, "
			    "neighbor %s", inet_ntoa(nbr->id));
a326 3
			log_debug("rde_dispatch_imsg: IMSG_LS_REQ, "
			    "neighbor %s len %d", inet_ntoa(nbr->id),
			    imsg.hdr.len - IMSG_HEADER_SIZE);
a354 3
			log_debug("rde_dispatch_imsg: IMSG_LS_UPD, "
			    "neighbor %s len %d", inet_ntoa(nbr->id),
			    imsg.hdr.len - IMSG_HEADER_SIZE);
a398 2
				/* start spf_timer */
				log_debug("rde_dispatch_imsg: start spf_timer");
d929 1
a929 2
	log_debug("rde_redistribute: prefix %s/%d used %d",
	    inet_ntoa(kr->prefix), kr->prefixlen, rv);
@


1.25
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.24 2005/05/25 08:06:57 david Exp $ */
d612 1
a612 1
			
@


1.24
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.23 2005/05/24 21:36:40 claudio Exp $ */
d108 1
a108 1
	rdeconf = xconf; /* XXX my not be replaced because of the lsa_tree */
@


1.23
log
@Only redistribute networks if the interface they depend on is actually
up and running. This makes redistribution of carp(4)-ed networks magically
work. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.22 2005/05/24 20:40:57 claudio Exp $ */
d1034 1
a1034 1
	/* first check if we acctually need to announce this route */
@


1.22
log
@Fix format string.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.21 2005/05/24 06:55:21 claudio Exp $ */
d59 1
d548 1
d606 12
d930 4
a935 3
			log_debug("rde_redistribute: iface %s/%d",
			    inet_ntoa(iface->addr),
			    mask2prefixlen(iface->mask.s_addr));
d944 26
@


1.21
log
@Fix some obvious issues in the summary LSA origination.
Actually remove summary LSA if the LSA they refer to are no longer valid.
Set correct cost on the summary LSA.
Announce type 4 summary LSA.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.20 2005/05/23 23:03:07 claudio Exp $ */
d447 1
a447 1
			    "type %d ls_id %d", lsa_hdr.type,
@


1.20
log
@First part of summary LSA origination. Not perfect but a start.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.19 2005/05/23 22:54:05 henning Exp $ */
a438 3
			log_debug("rde_dispatch_imsg: IMSG_LS_MAXAGE, "
			    "neighbor %s len %d", inet_ntoa(nbr->id),
			    imsg.hdr.len - IMSG_HEADER_SIZE);
d445 5
d989 1
a989 1
	struct vertex	*v;
d991 1
a991 1
	u_int8_t	 type;
d994 1
a994 1
	if (!(rte->d_type == DT_NET /* || as border rtr */))
d1021 10
d1119 1
a1119 2
	lsa->data.sum.metric = htonl(/* LSA_ASEXT_E_FLAG | */ 100);
	/* XXX until now there is no metric */
@


1.19
log
@useless use of endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.18 2005/05/22 17:49:26 norby Exp $ */
d62 3
a885 3
struct lsa	*orig_asext_lsa(struct kroute *, u_int16_t);


d981 44
d1033 1
a1033 1
		fatal("rde_asext_new");
d1049 1
a1049 1
	 * not be true. In this case it a hack needs to be done to
d1067 42
@


1.18
log
@The Route Information Base for AS-External should only be dumped once.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.17 2005/05/12 19:10:12 norby Exp $ */
a120 2

	endpwent();
@


1.17
log
@Add "show database asbr/external/network/router/self-originate/summary"
to ospfctl.

Show detailed information about the LSAs in the Link State Database.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.16 2005/05/11 20:07:04 claudio Exp $ */
a511 1
				rt_dump(area->id, imsg.hdr.pid, RIB_EXT);
d513 3
@


1.16
log
@Add some newlines to make the code easier to follow. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.15 2005/05/09 13:53:29 claudio Exp $ */
d466 6
d482 2
a483 1
					lsa_dump(&area->lsa_tree, imsg.hdr.pid);
d485 2
a486 1
				lsa_dump(&rdeconf->lsa_tree, imsg.hdr.pid);
d493 2
a494 1
					lsa_dump(&area->lsa_tree, imsg.hdr.pid);
d497 1
d875 1
a875 1
	}		
d1007 1
a1007 1
	 */ 
@


1.15
log
@Force all as-external routes to point to the router announcing them by
setting the forward address to 0.0.0.0. This is needed as we currently
fail to check if the real nexthop is covered by an ospf route --
uncovered routes are ignored by the other routers.
OK norby@@ tested and requested by Philip Olsson
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.14 2005/05/08 19:58:51 claudio Exp $ */
d260 1
d265 1
d757 1
@


1.14
log
@Keep track of the req list in the RDE. The RFC requires us to check for
silly updates while fetching the table from the other server. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.13 2005/05/02 02:26:35 djm Exp $ */
d1001 3
d1005 1
a1005 4
	if (kr->flags & F_CONNECTED)
		lsa->data.asext.fw_addr = 0;
	else
		lsa->data.asext.fw_addr = kr->nexthop.s_addr;
@


1.13
log
@use setres[ug]id for privilege dropping; ok norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.12 2005/04/12 09:54:59 claudio Exp $ */
d53 5
d265 3
d303 1
a303 1
				if (lsa_newer(&lsa_hdr, db_hdr) > 0)
d308 1
a308 1
					/* XXX add to local REQ list */
d312 1
d393 1
d408 3
a410 1
			/* TODO LSA on req list -> BadLSReq */
d755 1
d770 2
d805 58
@


1.12
log
@Support for self originated AS-external LSA.
With "redistribute (static|connected|default|none)" it is possible to
tell ospfd which external routes should be announced.
Connected routes will be announced only if there is no corresponding
interface configured, in that case the prefix is not external.
Adding and removing of announced prefixes are done automaticaly.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.11 2005/04/06 09:27:28 claudio Exp $ */
d113 2
a114 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid)) {
a115 1
	}
@


1.11
log
@When deleting LSA because they hit max age (IMSG_LS_MAXAGE) check if the
current LSA in the database was updated while max age LSA was flooded out.
This solves a reace condition where self originated LSA got removed because
an other server sent an update with age set to MAXAGE.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.10 2005/03/14 18:21:29 norby Exp $ */
d44 2
d53 4
d61 1
d99 1
a99 1
	rdeconf = xconf;
d140 1
a140 1
	imsg_init(ibuf_main, pipe_parent2rde[1], rde_dispatch_imsg);
a394 1
			/* TODO LSA on req list -> BadLSReq */
d399 1
d434 2
a435 1
			if (rde_nbr_loading(nbr->area))
d437 1
d511 75
d685 2
a686 1
	u_int32_t        hs, i;
d698 10
d791 153
@


1.10
log
@Add "show summary" to ospfctl.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.9 2005/03/12 11:03:05 norby Exp $ */
d430 12
a441 1
			lsa_del(nbr, &lsa_hdr);
@


1.9
log
@Add "show rib" and "show rib detail" to ospfctl.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.8 2005/03/08 20:12:18 norby Exp $ */
d44 2
a45 1

d474 7
d521 54
@


1.8
log
@Remove no longer valid route entries.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.7 2005/02/27 08:21:15 norby Exp $ */
d456 13
@


1.7
log
@SPF and route table calculation.

Calculate Shortest Path Tree for each area known in the link state
database.

The Shortest Path Tree is used as input for route table calculation.
Route tabled is calculated and the result is inserted into the kernel
route table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.6 2005/02/10 14:05:48 claudio Exp $ */
d162 1
d477 1
a477 1
rde_send_kroute(struct rt_node *r)
d487 13
@


1.6
log
@Work around a timing issue in the db exchange phase. The DB description
packets comming from the net are looped through the RDE and may get
delayed because of this. The result is that the neighbor FSM ends in
state FULL instead of LOADING and so the LSDB is not correctly
synchronized. Issue found by norby@@ OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.5 2005/02/09 22:58:08 claudio Exp $ */
d145 4
d160 2
a161 2

	/* ... */
d363 1
d387 4
d475 9
d485 2
@


1.5
log
@Fix premature ageing of self originating LSA. Still not perfect but better
than before where it just failed to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.4 2005/02/09 20:40:23 claudio Exp $ */
d297 3
@


1.4
log
@Rework of self originated LSA. First of all the code to generate the LSA
is rewritten to use the dynamic buffer api introduced lately.
Add missing parts in the RDE to merge these LSA originated from the OE into
the LSDB with correct seq_num, etc.
Add hooks to the neighbor and interface fsm so that the LSA get updated if
needed. This is not perfect, still many things are missing. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.3 2005/02/02 19:15:07 henning Exp $ */
d559 14
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d353 5
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d403 1
a403 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE + 
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * Copyright (c) 2004 Esben Norby <esben.norby@@ericsson.com>
@

