head	1.45;
access;
symbols
	OPENBSD_6_2:1.45.0.2
	OPENBSD_6_2_BASE:1.45
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.44.0.8
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.4
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.41.0.10
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.8
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.4
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.40.0.6
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.39.0.4
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.6
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.45
date	2016.12.26.17.38.14;	author jca;	state Exp;
branches;
next	1.44;
commitid	7dXGn3bjEh7gjeKW;

1.44
date	2015.01.28.22.03.17;	author bluhm;	state Exp;
branches;
next	1.43;
commitid	uF8XZsdxBSPX6Mo0;

1.43
date	2015.01.22.22.09.39;	author tedu;	state Exp;
branches;
next	1.42;
commitid	T9OZHPLQerEDZIns;

1.42
date	2014.12.18.19.26.46;	author tedu;	state Exp;
branches;
next	1.41;
commitid	wJjiOIHY7d7KeiCM;

1.41
date	2013.01.17.09.06.35;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2011.03.08.11.00.44;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.06.07.31.26;	author eric;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.05.19.33.59;	author pyr;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.13.03.58.26;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.31.11.44.49;	author claudio;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2009.01.31.08.55.00;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2008.02.11.12.37.37;	author norby;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.02.18.49.55;	author norby;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.29.16.49.40;	author norby;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.25.08.24.45;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.13.09.36.06;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.08.15.35.07;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.23.16.06.29;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.21.10.12.17;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.19.18.55.47;	author norby;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.10.18.30.47;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.05.15.10.57;	author norby;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.29.13.53.36;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.12.18.18.24;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.21.11.53.27;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.21.08.29.25;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.19.22.00.37;	author stevesk;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.19.21.43.20;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.19.13.07.58;	author stevesk;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.13.09.57.37;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.13.09.36.37;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.12.10.16.01;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.03.15.05.49;	author msf;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.26.20.10.24;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.26.19.54.49;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.05.13.01.22;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.29.17.26.35;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.17.21.17.12;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.09.22.34.05;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.09.15.41.33;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;

1.35.2.1
date	2009.05.25.15.55.12;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Fix typo, happend -> happened
@
text
@/*	$OpenBSD: lsupdate.c,v 1.44 2015/01/28 22:03:17 bluhm Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <stdlib.h>
#include <string.h>
#include <siphash.h>

#include "ospf.h"
#include "ospfd.h"
#include "log.h"
#include "ospfe.h"
#include "rde.h"

extern struct ospfd_conf	*oeconf;
extern struct imsgev		*iev_rde;

struct ibuf *prepare_ls_update(struct iface *);
int	add_ls_update(struct ibuf *, struct iface *, void *, u_int16_t,
	    u_int16_t);
int	send_ls_update(struct ibuf *, struct iface *, struct in_addr, u_int32_t);

void	ls_retrans_list_insert(struct nbr *, struct lsa_entry *);
void	ls_retrans_list_remove(struct nbr *, struct lsa_entry *);

/* link state update packet handling */
int
lsa_flood(struct iface *iface, struct nbr *originator, struct lsa_hdr *lsa_hdr,
    void *data)
{
	struct nbr		*nbr;
	struct lsa_entry	*le = NULL;
	int			 queued = 0, dont_ack = 0;
	int			 r;

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr == iface->self)
			continue;
		if (!(nbr->state & NBR_STA_FLOOD))
			continue;

		if (iface->state & IF_STA_DROTHER && !queued)
			while ((le = ls_retrans_list_get(iface->self, lsa_hdr)))
			    ls_retrans_list_free(iface->self, le);

		while ((le = ls_retrans_list_get(nbr, lsa_hdr)))
			ls_retrans_list_free(nbr, le);

		if (!(nbr->state & NBR_STA_FULL) &&
		    (le = ls_req_list_get(nbr, lsa_hdr)) != NULL) {
			r = lsa_newer(lsa_hdr, le->le_lsa);
			if (r > 0) {
				/* to flood LSA is newer than requested */
				ls_req_list_free(nbr, le);
				/* new needs to be flooded */
			} else if (r < 0) {
				/* to flood LSA is older than requested */
				continue;
			} else {
				/* LSA are equal */
				ls_req_list_free(nbr, le);
				continue;
			}
		}

		if (nbr == originator) {
			dont_ack++;
			continue;
		}

		/* non DR or BDR router keep all lsa in one retrans list */
		if (iface->state & IF_STA_DROTHER) {
			if (!queued)
				ls_retrans_list_add(iface->self, data,
				    iface->rxmt_interval, 0);
			queued = 1;
		} else {
			ls_retrans_list_add(nbr, data, iface->rxmt_interval, 0);
			queued = 1;
		}
	}

	if (!queued)
		return (0);

	if (iface == originator->iface && iface->self != originator) {
		if (iface->dr == originator || iface->bdr == originator)
			return (0);
		if (iface->state & IF_STA_BACKUP)
			return (0);
		dont_ack++;
	}

	/*
	 * initial flood needs to be queued separately, timeout is zero
	 * and oneshot has to be set because the retransimssion queues
	 * are already loaded.
	 */
	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		ls_retrans_list_add(iface->self, data, 0, 1);
		break;
	case IF_TYPE_NBMA:
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
		LIST_FOREACH(nbr, &iface->nbr_list, entry) {
			if (nbr == iface->self)
				continue;
			if (!(nbr->state & NBR_STA_FLOOD))
				continue;
			if (!TAILQ_EMPTY(&nbr->ls_retrans_list)) {
				le = TAILQ_LAST(&nbr->ls_retrans_list,
				    lsa_head);
				if (lsa_hdr->type != le->le_lsa->type ||
				    lsa_hdr->ls_id != le->le_lsa->ls_id ||
				    lsa_hdr->adv_rtr != le->le_lsa->adv_rtr)
					continue;
			}
			ls_retrans_list_add(nbr, data, 0, 1);
		}
		break;
	default:
		fatalx("lsa_flood: unknown interface type");
	}

	return (dont_ack == 2);
}

struct ibuf *
prepare_ls_update(struct iface *iface)
{
	struct ibuf		*buf;

	if ((buf = ibuf_dynamic(iface->mtu - sizeof(struct ip),
	    IP_MAXPACKET - sizeof(struct ip))) == NULL)
		fatal("prepare_ls_update");

	/* OSPF header */
	if (gen_ospf_hdr(buf, iface, PACKET_TYPE_LS_UPDATE))
		goto fail;

	/* reserve space for number of lsa field */
	if (ibuf_reserve(buf, sizeof(u_int32_t)) == NULL)
		goto fail;

	return (buf);
fail:
	log_warn("prepare_ls_update");
	ibuf_free(buf);
	return (NULL);
}

int
add_ls_update(struct ibuf *buf, struct iface *iface, void *data, u_int16_t len,
    u_int16_t older)
{
	void		*lsage;
	u_int16_t	 age;

	if ((size_t)iface->mtu < sizeof(struct ip) + sizeof(struct ospf_hdr) +
	    sizeof(u_int32_t) + ibuf_size(buf) + len + MD5_DIGEST_LENGTH) {
		/* start new packet unless this is the first LSA to pack */
		if (ibuf_size(buf) > sizeof(struct ospf_hdr) +
		    sizeof(u_int32_t))
			return (0);
	}

	lsage = ibuf_reserve(buf, 0);
	if (ibuf_add(buf, data, len)) {
		log_warn("add_ls_update");
		return (0);
	}

	/* age LSA before sending it out */
	memcpy(&age, data, sizeof(age));
	age = ntohs(age);
	if ((age += older + iface->transmit_delay) >= MAX_AGE)
		age = MAX_AGE;
	age = htons(age);
	memcpy(lsage, &age, sizeof(age));

	return (1);
}



int
send_ls_update(struct ibuf *buf, struct iface *iface, struct in_addr addr,
    u_int32_t nlsa)
{
	struct sockaddr_in	 dst;
	int			 ret;

	nlsa = htonl(nlsa);
	memcpy(ibuf_seek(buf, sizeof(struct ospf_hdr), sizeof(nlsa)),
	    &nlsa, sizeof(nlsa));
	/* update authentication and calculate checksum */
	if (auth_gen(buf, iface))
		goto fail;

	/* set destination */
	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);
	dst.sin_addr.s_addr = addr.s_addr;

	ret = send_packet(iface, buf, &dst);

	ibuf_free(buf);
	return (ret);
fail:
	log_warn("send_ls_update");
	ibuf_free(buf);
	return (-1);
}

void
recv_ls_update(struct nbr *nbr, char *buf, u_int16_t len)
{
	struct lsa_hdr		 lsa;
	u_int32_t		 nlsa;

	if (len < sizeof(nlsa)) {
		log_warnx("recv_ls_update: bad packet size, neighbor ID %s",
		    inet_ntoa(nbr->id));
		return;
	}
	memcpy(&nlsa, buf, sizeof(nlsa));
	nlsa = ntohl(nlsa);
	buf += sizeof(nlsa);
	len -= sizeof(nlsa);

	switch (nbr->state) {
	case NBR_STA_DOWN:
	case NBR_STA_ATTEMPT:
	case NBR_STA_INIT:
	case NBR_STA_2_WAY:
	case NBR_STA_XSTRT:
	case NBR_STA_SNAP:
		log_debug("recv_ls_update: packet ignored in state %s, "
		    "neighbor ID %s", nbr_state_name(nbr->state),
		    inet_ntoa(nbr->id));
		break;
	case NBR_STA_XCHNG:
	case NBR_STA_LOAD:
	case NBR_STA_FULL:
		for (; nlsa > 0 && len > 0; nlsa--) {
			if (len < sizeof(lsa)) {
				log_warnx("recv_ls_update: bad packet size, "
				    "neighbor ID %s", inet_ntoa(nbr->id));
				return;
			}
			memcpy(&lsa, buf, sizeof(lsa));
			if (len < ntohs(lsa.len)) {
				log_warnx("recv_ls_update: bad packet size, "
				    "neighbor ID %s", inet_ntoa(nbr->id));
				return;
			}
			imsg_compose_event(iev_rde, IMSG_LS_UPD, nbr->peerid, 0,
			    -1, buf, ntohs(lsa.len));
			buf += ntohs(lsa.len);
			len -= ntohs(lsa.len);
		}
		if (nlsa > 0 || len > 0) {
			log_warnx("recv_ls_update: bad packet size, "
			    "neighbor ID %s", inet_ntoa(nbr->id));
			return;
		}
		break;
	default:
		fatalx("recv_ls_update: unknown neighbor state");
	}
}

/* link state retransmit list */
void
ls_retrans_list_add(struct nbr *nbr, struct lsa_hdr *lsa,
    unsigned short timeout, unsigned short oneshot)
{
	struct timeval		 tv;
	struct lsa_entry	*le;
	struct lsa_ref		*ref;

	if ((ref = lsa_cache_get(lsa)) == NULL)
		fatalx("King Bula sez: somebody forgot to lsa_cache_add");

	if ((le = calloc(1, sizeof(*le))) == NULL)
		fatal("ls_retrans_list_add");

	le->le_ref = ref;
	le->le_when = timeout;
	le->le_oneshot = oneshot;

	ls_retrans_list_insert(nbr, le);

	if (!evtimer_pending(&nbr->ls_retrans_timer, NULL)) {
		timerclear(&tv);
		tv.tv_sec = TAILQ_FIRST(&nbr->ls_retrans_list)->le_when;

		if (evtimer_add(&nbr->ls_retrans_timer, &tv) == -1)
			fatal("ls_retrans_list_add");
	}
}

int
ls_retrans_list_del(struct nbr *nbr, struct lsa_hdr *lsa_hdr)
{
	struct lsa_entry	*le;

	if ((le = ls_retrans_list_get(nbr, lsa_hdr)) == NULL)
		return (-1);
	/*
	 * Compare LSA with the Ack by comparing not only the seq_num and
	 * checksum but also the age field.  Since we only care about MAX_AGE
	 * vs. non-MAX_AGE LSA, a simple >= comparison is good enough.  This
	 * ensures that a LSA withdrawal is not acked by a previous update.
	 */
	if (lsa_hdr->seq_num == le->le_ref->hdr.seq_num &&
	    lsa_hdr->ls_chksum == le->le_ref->hdr.ls_chksum &&
	    ntohs(lsa_hdr->age) >= ntohs(le->le_ref->hdr.age)) {
		ls_retrans_list_free(nbr, le);
		return (0);
	}

	return (-1);
}

struct lsa_entry *
ls_retrans_list_get(struct nbr *nbr, struct lsa_hdr *lsa_hdr)
{
	struct lsa_entry	*le;

	TAILQ_FOREACH(le, &nbr->ls_retrans_list, entry) {
		if ((lsa_hdr->type == le->le_ref->hdr.type) &&
		    (lsa_hdr->ls_id == le->le_ref->hdr.ls_id) &&
		    (lsa_hdr->adv_rtr == le->le_ref->hdr.adv_rtr))
			return (le);
	}
	return (NULL);
}

void
ls_retrans_list_insert(struct nbr *nbr, struct lsa_entry *new)
{
	struct lsa_entry	*le;
	unsigned short		 when = new->le_when;

	TAILQ_FOREACH(le, &nbr->ls_retrans_list, entry) {
		if (when < le->le_when) {
			new->le_when = when;
			TAILQ_INSERT_BEFORE(le, new, entry);
			nbr->ls_ret_cnt++;
			return;
		}
		when -= le->le_when;
	}
	new->le_when = when;
	TAILQ_INSERT_TAIL(&nbr->ls_retrans_list, new, entry);
	nbr->ls_ret_cnt++;
}

void
ls_retrans_list_remove(struct nbr *nbr, struct lsa_entry *le)
{
	struct timeval		 tv;
	struct lsa_entry	*next = TAILQ_NEXT(le, entry);
	int			 reset = 0;

	/* adjust timeout of next entry */
	if (next)
		next->le_when += le->le_when;

	if (TAILQ_FIRST(&nbr->ls_retrans_list) == le &&
	    evtimer_pending(&nbr->ls_retrans_timer, NULL))
		reset = 1;

	TAILQ_REMOVE(&nbr->ls_retrans_list, le, entry);
	nbr->ls_ret_cnt--;

	if (reset && TAILQ_FIRST(&nbr->ls_retrans_list)) {
		if (evtimer_del(&nbr->ls_retrans_timer) == -1)
			fatal("ls_retrans_list_remove");

		timerclear(&tv);
		tv.tv_sec = TAILQ_FIRST(&nbr->ls_retrans_list)->le_when;

		if (evtimer_add(&nbr->ls_retrans_timer, &tv) == -1)
			fatal("ls_retrans_list_remove");
	}
}

void
ls_retrans_list_free(struct nbr *nbr, struct lsa_entry *le)
{
	ls_retrans_list_remove(nbr, le);

	lsa_cache_put(le->le_ref, nbr);
	free(le);
}

void
ls_retrans_list_clr(struct nbr *nbr)
{
	struct lsa_entry	*le;

	while ((le = TAILQ_FIRST(&nbr->ls_retrans_list)) != NULL)
		ls_retrans_list_free(nbr, le);

	nbr->ls_ret_cnt = 0;
}

/* ARGSUSED */
void
ls_retrans_timer(int fd, short event, void *bula)
{
	struct timeval		 tv;
	struct timespec		 tp;
	struct in_addr		 addr;
	struct nbr		*nbr = bula;
	struct lsa_entry	*le;
	struct ibuf		*buf;
	time_t			 now;
	int			 d;
	u_int32_t		 nlsa = 0;

	if ((le = TAILQ_FIRST(&nbr->ls_retrans_list)) != NULL)
		le->le_when = 0;	/* timer fired */
	else
		return;			/* queue empty, nothing to do */

	clock_gettime(CLOCK_MONOTONIC, &tp);
	now = tp.tv_sec;

	if (nbr->iface->self == nbr) {
		/*
		 * oneshot needs to be set for lsa queued for flooding,
		 * if oneshot is not set then the lsa needs to be converted
		 * because the router switched lately to DR or BDR
		 */
		if (le->le_oneshot && nbr->iface->state & IF_STA_DRORBDR)
			inet_aton(AllSPFRouters, &addr);
		else if (nbr->iface->state & IF_STA_DRORBDR) {
			/*
			 * old retransmission needs to be converted into
			 * flood by rerunning the lsa_flood.
			 */
			lsa_flood(nbr->iface, nbr, &le->le_ref->hdr,
			    le->le_ref->data);
			ls_retrans_list_free(nbr, le);
			/* ls_retrans_list_free retriggers the timer */
			return;
		} else if (nbr->iface->type == IF_TYPE_POINTOPOINT)
			memcpy(&addr, &nbr->iface->dst, sizeof(addr));
		else
			inet_aton(AllDRouters, &addr);
	} else
		memcpy(&addr, &nbr->addr, sizeof(addr));

	if ((buf = prepare_ls_update(nbr->iface)) == NULL) {
		le->le_when = 1;
		goto done;
	}

	while ((le = TAILQ_FIRST(&nbr->ls_retrans_list)) != NULL &&
	    le->le_when == 0) {
		d = now - le->le_ref->stamp;
		if (d < 0)
			d = 0;
		else if (d > MAX_AGE)
			d = MAX_AGE;

		if (add_ls_update(buf, nbr->iface, le->le_ref->data,
		    le->le_ref->len, d) == 0) {
			if (nlsa == 0) {
				/* something bad happened retry later */
				log_warnx("ls_retrans_timer: sending LS update "
				    "to neighbor ID %s failed",
				    inet_ntoa(nbr->id));
				TAILQ_REMOVE(&nbr->ls_retrans_list, le, entry);
				nbr->ls_ret_cnt--;
				le->le_when = nbr->iface->rxmt_interval;
				ls_retrans_list_insert(nbr, le);
			}
			break;
		}
		nlsa++;
		if (le->le_oneshot)
			ls_retrans_list_free(nbr, le);
		else {
			TAILQ_REMOVE(&nbr->ls_retrans_list, le, entry);
			nbr->ls_ret_cnt--;
			le->le_when = nbr->iface->rxmt_interval;
			ls_retrans_list_insert(nbr, le);
		}
	}
	if (nlsa)
		send_ls_update(buf, nbr->iface, addr, nlsa);
	else
		ibuf_free(buf);

done:
	if ((le = TAILQ_FIRST(&nbr->ls_retrans_list)) != NULL) {
		timerclear(&tv);
		tv.tv_sec = le->le_when;

		if (evtimer_add(&nbr->ls_retrans_timer, &tv) == -1)
			fatal("ls_retrans_timer");
	}
}

LIST_HEAD(lsa_cache_head, lsa_ref);

struct lsa_cache {
	struct lsa_cache_head	*hashtbl;
	u_int32_t		 hashmask;
} lsacache;

SIPHASH_KEY lsacachekey;

struct lsa_ref		*lsa_cache_look(struct lsa_hdr *);

void
lsa_cache_init(u_int32_t hashsize)
{
	u_int32_t        hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	lsacache.hashtbl = calloc(hs, sizeof(struct lsa_cache_head));
	if (lsacache.hashtbl == NULL)
		fatal("lsa_cache_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&lsacache.hashtbl[i]);
	arc4random_buf(&lsacachekey, sizeof(lsacachekey));

	lsacache.hashmask = hs - 1;
}

static uint32_t
lsa_hash_hdr(const struct lsa_hdr *hdr)
{
	return SipHash24(&lsacachekey, hdr, sizeof(*hdr));
}

struct lsa_ref *
lsa_cache_add(void *data, u_int16_t len)
{
	struct lsa_cache_head	*head;
	struct lsa_ref		*ref, *old;
	struct timespec		 tp;

	if ((ref = calloc(1, sizeof(*ref))) == NULL)
		fatal("lsa_cache_add");
	memcpy(&ref->hdr, data, sizeof(ref->hdr));

	if ((old = lsa_cache_look(&ref->hdr))) {
		free(ref);
		old->refcnt++;
		return (old);
	}

	if ((ref->data = malloc(len)) == NULL)
		fatal("lsa_cache_add");
	memcpy(ref->data, data, len);

	clock_gettime(CLOCK_MONOTONIC, &tp);
	ref->stamp = tp.tv_sec;
	ref->len = len;
	ref->refcnt = 1;

	head = &lsacache.hashtbl[lsa_hash_hdr(&ref->hdr) & lsacache.hashmask];
	LIST_INSERT_HEAD(head, ref, entry);
	return (ref);
}

struct lsa_ref *
lsa_cache_get(struct lsa_hdr *lsa_hdr)
{
	struct lsa_ref		*ref;

	ref = lsa_cache_look(lsa_hdr);
	if (ref)
		ref->refcnt++;

	return (ref);
}

void
lsa_cache_put(struct lsa_ref *ref, struct nbr *nbr)
{
	if (--ref->refcnt > 0)
		return;

	if (ntohs(ref->hdr.age) >= MAX_AGE)
		ospfe_imsg_compose_rde(IMSG_LS_MAXAGE, nbr->peerid, 0,
		    ref->data, sizeof(struct lsa_hdr));

	free(ref->data);
	LIST_REMOVE(ref, entry);
	free(ref);
}

struct lsa_ref *
lsa_cache_look(struct lsa_hdr *lsa_hdr)
{
	struct lsa_cache_head	*head;
	struct lsa_ref		*ref;

	head = &lsacache.hashtbl[lsa_hash_hdr(lsa_hdr) & lsacache.hashmask];

	LIST_FOREACH(ref, head, entry) {
		if (memcmp(&ref->hdr, lsa_hdr, sizeof(*lsa_hdr)) == 0)
			/* found match */
			return (ref);
	}

	return (NULL);
}
@


1.44
log
@When comparing the LSA with the Ack, also check the age field.  This
ensures that a LSA withdrawal is not acked by a previous update.
From Florian Riehm;  OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.43 2015/01/22 22:09:39 tedu Exp $ */
d495 1
a495 1
				/* something bad happend retry later */
@


1.43
log
@remove a stupid -Wstrict-prototype warning by making the hash function
static. noticed by florian riehm
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.42 2014/12/18 19:26:46 tedu Exp $ */
d332 6
d339 2
a340 1
	    lsa_hdr->ls_chksum == le->le_ref->hdr.ls_chksum) {
@


1.42
log
@simple to use siphash here. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.41 2013/01/17 09:06:35 markus Exp $ */
d553 1
a553 1
uint32_t
@


1.41
log
@for point-to-point interfaces we need to send lsupdates to the
interface address, since there is no DR and multicast messages to
the DR will be ignored. see RFC 2328, 13.3(5)
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.40 2011/03/08 11:00:44 claudio Exp $ */
a20 1
#include <sys/hash.h>
d27 1
d531 2
d548 1
d553 6
d585 1
a585 2
	head = &lsacache.hashtbl[hash32_buf(&ref->hdr, sizeof(ref->hdr),
	    HASHINIT) & lsacache.hashmask];
d623 1
a623 2
	head = &lsacache.hashtbl[hash32_buf(lsa_hdr, sizeof(*lsa_hdr),
	    HASHINIT) & lsacache.hashmask];
@


1.40
log
@It was not possible to send out LS updates larger then the MTU.
Change the code in such a way that single huge LSA get fragmented
but avoid IP fragmentation when packing multiple ones.
Problem found and fix tested by Benjamin Papillon.
Tested & OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.39 2010/05/26 13:56:08 nicm Exp $ */
d465 3
a467 1
		} else
@


1.39
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.38 2009/06/06 07:31:26 eric Exp $ */
d155 2
a156 1
	if ((buf = ibuf_open(iface->mtu - sizeof(struct ip))) == NULL)
d181 7
a187 2
	if (ibuf_left(buf) < (size_t)len + MD5_DIGEST_LENGTH)
		return (0);
d484 11
a494 1
		    le->le_ref->len, d) == 0)
d496 1
d507 4
a510 1
	send_ls_update(buf, nbr->iface, addr, nlsa);
@


1.38
log
@sync ospfctl/ospfd with the common imsg code, making it lib ready as well.

"looks ok" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.37 2009/06/05 19:33:59 pyr Exp $ */
d38 2
a39 2
struct buf *prepare_ls_update(struct iface *);
int	add_ls_update(struct buf *, struct iface *, void *, u_int16_t,
d41 1
a41 1
int	send_ls_update(struct buf *, struct iface *, struct in_addr, u_int32_t);
d150 1
a150 1
struct buf *
d153 1
a153 1
	struct buf		*buf;
d155 1
a155 1
	if ((buf = buf_open(iface->mtu - sizeof(struct ip))) == NULL)
d163 1
a163 1
	if (buf_reserve(buf, sizeof(u_int32_t)) == NULL)
d169 1
a169 1
	buf_free(buf);
d174 1
a174 1
add_ls_update(struct buf *buf, struct iface *iface, void *data, u_int16_t len,
d180 1
a180 1
	if (buf_left(buf) < (size_t)len + MD5_DIGEST_LENGTH)
d183 2
a184 2
	lsage = buf_reserve(buf, 0);
	if (buf_add(buf, data, len)) {
d203 1
a203 1
send_ls_update(struct buf *buf, struct iface *iface, struct in_addr addr,
d210 1
a210 1
	memcpy(buf_seek(buf, sizeof(struct ospf_hdr), sizeof(nlsa)),
d223 1
a223 1
	buf_free(buf);
d227 1
a227 1
	buf_free(buf);
d428 1
a428 1
	struct buf		*buf;
@


1.37
log
@make ospfd's imsg lib ready as well.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.36 2009/03/13 03:58:26 claudio Exp $ */
d36 1
a36 1
extern struct imsgbuf		*ibuf_rde;
d273 1
a273 1
			imsg_compose_event(ibuf_rde, IMSG_LS_UPD, nbr->peerid, 0,
@


1.36
log
@When commiting the buf_left() change adding len to the check was dropped and
so a warning later on could be hit in some cases. Found by dlg@@ OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.35 2009/01/31 11:44:49 claudio Exp $ */
d273 2
a274 2
			imsg_compose(ibuf_rde, IMSG_LS_UPD, nbr->peerid, 0,
			    buf, ntohs(lsa.len));
@


1.35
log
@Implement buf_left() to make some some more buffer handling easier.
buf_left() returns the bytes left in a buffer. This makes the check to
keep MD5_DIGEST_LENGTH bytes unallocated in some messages easier.
From the buf cleanup diff that was OK norby@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.34 2009/01/31 08:55:00 claudio Exp $ */
d39 2
a40 1
int	add_ls_update(struct buf *, struct iface *, void *, int, u_int16_t);
d174 1
a174 1
add_ls_update(struct buf *buf, struct iface *iface, void *data, int len,
d180 1
a180 1
	if (buf_left(buf) < MD5_DIGEST_LENGTH)
a603 1

@


1.35.2.1
log
@Bring back rev. 1.36 from -current
When commiting the buf_left() change adding len to the check was dropped and
so a warning later on could be hit in some cases. Found by dlg@@ OK dlg@@

This should solve out of memory warnings seen on lsupdate in some cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.35 2009/01/31 11:44:49 claudio Exp $ */
d39 1
a39 2
int	add_ls_update(struct buf *, struct iface *, void *, u_int16_t,
	    u_int16_t);
d173 1
a173 1
add_ls_update(struct buf *buf, struct iface *iface, void *data, u_int16_t len,
d179 1
a179 1
	if (buf_left(buf) < (size_t)len + MD5_DIGEST_LENGTH)
d603 1
@


1.34
log
@Pass the buffer to send_packet() instead of spliting it up. This removes
some direct access to struct buf internals in the rest of ospfe.
Based on a larger buffer cleanup diff that was OK norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.33 2008/02/11 12:37:37 norby Exp $ */
d176 2
a177 2
	size_t		pos;
	u_int16_t	age;
d179 1
a179 1
	if (buf->wpos + len >= buf->max - MD5_DIGEST_LENGTH)
d182 1
a182 1
	pos = buf->wpos;
d194 1
a194 1
	memcpy(buf_seek(buf, pos, sizeof(age)), &age, sizeof(age));
@


1.33
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.32 2006/06/02 18:49:55 norby Exp $ */
d220 1
a220 1
	ret = send_packet(iface, buf->buf, buf->wpos, &dst);
@


1.32
log
@remove unused variable, found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.31 2006/05/29 16:49:40 norby Exp $ */
d155 1
a155 1
		fatal("send_ls_update");
@


1.31
log
@Remove useless debug message that gets triggered all the time in big networks.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.30 2006/04/25 08:24:45 claudio Exp $ */
d48 1
a48 1
    void *data, u_int16_t len)
d454 1
a454 1
			    le->le_ref->data, le->le_ref->len);
@


1.30
log
@Kill unused function and add a ARGSUSED.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.29 2006/03/13 09:36:06 claudio Exp $ */
a329 3

	log_warnx("ls_retrans_list_del: invalid LS ack received, neighbor %s",
	     inet_ntoa(nbr->id));
@


1.29
log
@The return value of the start/stop timer functions is almost never checked.
Switch them to void functions and check if evtimer_add/del fails -- in which
case we fatal() as there is no useful way to recover in such an event.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.28 2006/03/08 15:35:07 claudio Exp $ */
d421 1
a421 6
int
ls_retrans_list_empty(struct nbr *nbr)
{
	return (TAILQ_EMPTY(&nbr->ls_retrans_list));
}

@


1.28
log
@Spaces and other minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.27 2006/02/23 16:06:29 claudio Exp $ */
d314 1
a314 1
			log_warn("ls_retrans_list_add: evtimer_add failed");
d390 2
a391 1
		evtimer_del(&nbr->ls_retrans_timer);
d397 1
a397 1
			log_warn("ls_retrans_timer: evtimer_add failed");
d505 1
a505 1
			log_warn("ls_retrans_timer: evtimer_add failed");
@


1.27
log
@Rework the LSA cache and make it behave. Until now we only used the type,
id and adv router as hash and that resulted and weird behaviour. Because the
age was not used in the compare it was almost impossible to MAXAGE some
LSAs in busy networks. The result was a slowly growing retransmission queue
and an ospf engine spending way to much time traversing these sometimes huge
queues. Now we just hash the full lsa_hdr and so age is included.
Additionally correctly age LSAs in the retransmission queues.
ok ok ok ok ok ok and a lot of help (plus a busy OSPF network) norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.26 2006/02/21 10:12:17 claudio Exp $ */
d446 1
a446 1
	
@


1.26
log
@Correctly count the number of LSAs in the retransmission list. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.25 2006/02/19 18:55:47 norby Exp $ */
d21 1
d39 1
a39 1
int	add_ls_update(struct buf *, struct iface *, void *, int);
d62 1
a62 1
			if ((le = ls_retrans_list_get(iface->self, lsa_hdr)))
d65 1
a65 1
		if ((le = ls_retrans_list_get(nbr, lsa_hdr)))
d173 2
a174 1
add_ls_update(struct buf *buf, struct iface *iface, void *data, int len)
d176 2
a177 2
	size_t			 pos;
	u_int16_t		 age;
d191 1
a191 1
	if ((age += iface->transmit_delay) >= MAX_AGE)
d323 1
a323 2
	le = ls_retrans_list_get(nbr, lsa_hdr);
	if (le == NULL)
a367 1

d430 1
d435 2
d444 3
d477 6
d484 1
a484 1
		    le->le_ref->len) == 0)
a515 1
struct lsa_cache_head	*lsa_cache_hash(struct lsa_hdr *);
d560 2
a561 1
	head = lsa_cache_hash(&ref->hdr);
d599 3
a601 1
	head = lsa_cache_hash(lsa_hdr);
d603 1
a603 5
		if (ref->hdr.type == lsa_hdr->type &&
		    ref->hdr.ls_id == lsa_hdr->ls_id &&
		    ref->hdr.adv_rtr == lsa_hdr->adv_rtr &&
		    ref->hdr.seq_num == lsa_hdr->seq_num &&
		    ref->hdr.ls_chksum == lsa_hdr->ls_chksum) {
a605 1
		}
d607 1
a610 14
struct lsa_cache_head *
lsa_cache_hash(struct lsa_hdr *lsa_hdr)
{
	u_int32_t	hash = 8271;

	hash ^= lsa_hdr->type;
	hash ^= lsa_hdr->ls_id;
	hash ^= lsa_hdr->adv_rtr;
	hash ^= lsa_hdr->seq_num;
	hash ^= lsa_hdr->ls_chksum;
	hash &= lsacache.hashmask;

	return (&lsacache.hashtbl[hash]);
}
@


1.25
log
@Do not traverse the entire LS retransmission list to figure out how many
are present on it.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.24 2006/02/10 18:30:47 claudio Exp $ */
d360 1
d479 1
@


1.24
log
@ospfd does not need fd passing via the imsg framework so remove that code
and remove other unneeded functions that are only used in bgpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.23 2006/01/05 15:10:57 norby Exp $ */
d198 1
a198 1
	
d366 2
d384 1
a384 1
	
d386 1
d415 2
d439 1
a439 1
	
d480 1
a480 1
		}		
@


1.23
log
@Improve how ospfd copes with time changes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.22 2005/12/29 13:53:36 claudio Exp $ */
d270 1
a270 1
			imsg_compose(ibuf_rde, IMSG_LS_UPD, nbr->peerid, 0, -1,
@


1.22
log
@Instead of a simple timer per neighbor for the LS retransmition list use
a timewheel. All LSA updates are now first added to the queue and sent out
later. This makes it possible to cluster multiple LSA updates into on OSPF
packet. This gives a massive speedup when large databases need to be synced.
Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.21 2005/11/12 18:18:24 deraadt Exp $ */
d521 1
d536 3
a538 1
	ref->stamp = time(NULL);
@


1.21
log
@spacing mostly
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.20 2005/10/21 11:53:27 claudio Exp $ */
d37 7
a48 1
	struct in_addr		 addr;
d92 2
a93 1
				ls_retrans_list_add(iface->self, data);
d96 1
a96 1
			ls_retrans_list_add(nbr, data);
d112 5
a116 1
	/* flood LSA but first set correct destination */
a118 3
		inet_aton(AllSPFRouters, &addr);
		send_ls_update(iface, addr, data, len);
		break;
d120 1
a120 5
		if (iface->state & IF_STA_DRORBDR)
			inet_aton(AllSPFRouters, &addr);
		else
			inet_aton(AllDRouters, &addr);
		send_ls_update(iface, addr, data, len);
d138 1
a138 1
			send_ls_update(iface, nbr->addr, data, len);
d148 2
a149 2
int
send_ls_update(struct iface *iface, struct in_addr addr, void *data, int len)
a150 1
	struct sockaddr_in	 dst;
a151 4
	size_t			 pos;
	u_int32_t		 nlsa;
	u_int16_t		 age;
	int			 ret;
d153 1
a153 2
	/* XXX READ_BUF_SIZE */
	if ((buf = buf_dynamic(PKG_DEF_SIZE, READ_BUF_SIZE)) == NULL)
a155 5
	/* set destination */
	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);
	dst.sin_addr.s_addr = addr.s_addr;

d160 2
a161 2
	nlsa = htonl(1);
	if (buf_add(buf, &nlsa, sizeof(nlsa)))
d164 16
d181 4
a184 2
	if (buf_add(buf, data, len))
		goto fail;
d194 15
d213 5
d288 2
a289 1
ls_retrans_list_add(struct nbr *nbr, struct lsa_hdr *lsa)
d302 4
a305 1
	TAILQ_INSERT_TAIL(&nbr->ls_retrans_list, le, entry);
d309 1
a309 1
		tv.tv_sec = nbr->iface->rxmt_interval;
d351 46
d399 1
a399 1
	TAILQ_REMOVE(&nbr->ls_retrans_list, le, entry);
d427 2
d430 5
d436 8
a443 1
		if (!(nbr->iface->state & IF_STA_DROTHER)) {
d445 2
a446 5
			 * Iick, we are suddenly DR or BDDR so convert this
			 * retrans list into a real flood. I'm not 100% sure if
			 * using iface->self as originator is correct but we
			 * will flood the whole net with this and that's the
			 * idea.
d448 4
a451 6
			while ((le = TAILQ_FIRST(&nbr->ls_retrans_list)) !=
			    NULL) {
				lsa_flood(nbr->iface, nbr, &le->le_ref->hdr,
				    le->le_ref->data, le->le_ref->len);
				ls_retrans_list_free(nbr, le);
			}
d453 2
a454 2
		}
		inet_aton(AllDRouters, &addr);
d458 4
d463 17
a480 3
		send_ls_update(nbr->iface, addr, le->le_ref->data,
		    le->le_ref->len);

d482 1
a482 1
		tv.tv_sec = nbr->iface->rxmt_interval;
@


1.20
log
@htons() instead of ntohs() when going from host to network.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.19 2005/10/21 08:29:25 claudio Exp $ */
a252 2

	return;
@


1.19
log
@Revert part of rev 1.14. For now queue LSAs to all neighbors if the interface
is in state BACKUP or DR -- even to the DR. This causes unneeded retransmission of LSAs but solves a problem with self originated ones. The BDR was no longer
capable to reliably flood self originated LSA. Better solution will follow.
Reported by stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.18 2005/10/19 22:00:37 stevesk Exp $ */
d180 1
a180 1
	age = ntohs(age);
@


1.18
log
@small cleanups while reading; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.17 2005/10/19 21:43:20 claudio Exp $ */
d88 1
a88 7
		} else if (iface->dr != nbr) {
			/*
			 * DR and BDR queue a packet to all other routers
			 * exept to the DR. The BDR does not need to
			 * retransmit LSA to the DR -- this will be done
			 * by the originatior.
			 */
@


1.17
log
@fix some spellings in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.16 2005/10/19 13:07:58 stevesk Exp $ */
d198 1
a198 1
	log_warn("send_hello");
@


1.16
log
@use string.h; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.15 2005/10/13 09:57:37 claudio Exp $ */
d181 1
a181 1
	/* age LSA befor sending it out */
@


1.15
log
@Fix a memory leak in the ospf engine. First of all ospfd did not track if a
LSA was already queued on nbr self. So after the first round -- where the
lsa was queued -- ospfd would remove it again in a second run.
That was not enough but the LSA was removed from the wrong neighbor -- nbr
instead of iface->self. LIST_REMOVE does not track the queue and so that
resulted in some strangeness (especially the lsa_cache did not get cleared).
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.14 2005/10/13 09:36:37 claudio Exp $ */
d26 1
a26 1
#include <strings.h>
@


1.14
log
@Correctly queue ls updates on the retransmission lists.
First of all it is not clever to set queued before we actually queue
something -- unless queued is set. If ospfd is running as BDR don't add
updates to the retransmission list to the DR.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.13 2005/10/12 10:16:01 claudio Exp $ */
d54 1
a54 1
		if (iface->state & IF_STA_DROTHER)
d56 1
a56 1
			    ls_retrans_list_free(nbr, le);
@


1.13
log
@Correct function name in warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.12 2005/10/03 15:05:49 msf Exp $ */
d83 1
a83 1
		queued = 1;
d87 8
a94 1
		} else
d96 2
@


1.12
log
@typo

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.11 2005/05/26 20:10:24 norby Exp $ */
d376 1
a376 1
			log_warn("ls_retrans_list_add: evtimer_add failed");
@


1.11
log
@Remove unneeded debugging stuff when handling LS updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.10 2005/05/26 19:54:49 norby Exp $ */
d294 1
a294 1
	log_warnx("ls_retrans_list_del: invalid LS ack received, neigbor %s",
@


1.10
log
@Simplify and cleanup passive interface handling.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.9 2005/04/05 13:01:22 claudio Exp $ */
a137 1

a150 3
	log_debug("send_ls_update: interface %s addr %s",
	    iface->name, inet_ntoa(addr));

a198 2

	log_debug("recv_ls_update: neighbor ID %s", inet_ntoa(nbr->id));
@


1.9
log
@Use the dynamic buffer API for packet generation and sending.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.8 2005/03/29 17:26:35 norby Exp $ */
a47 3
	if (iface->passive)
		return (0);

a153 3

	if (iface->passive)
		return (0);
@


1.8
log
@The RFC never mentions anything about transfer, this should be transmit.

From Jason Ackley (thanks).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.7 2005/03/22 22:13:48 norby Exp $ */
d149 2
a150 2
	char			*buf;
	char			*ptr;
d153 1
a153 1
	int			 ret = 0;
d161 2
a162 2
	/* XXX use buffer API instead for better decoupling */
	if ((ptr = buf = calloc(1, READ_BUF_SIZE)) == NULL)
d171 2
a172 2
	gen_ospf_hdr(ptr, iface, PACKET_TYPE_LS_UPDATE);
	ptr += sizeof(struct ospf_hdr);
d175 2
a176 2
	memcpy(ptr, &nlsa, sizeof(nlsa));
	ptr += sizeof(nlsa);
d178 3
a180 1
	memcpy(ptr, data, len);		/* XXX */
d183 1
a183 1
	memcpy(&age, ptr, sizeof(age));
d188 1
a188 3
	memcpy(ptr, &age, sizeof(age));

	ptr += len;
d191 2
a192 1
	auth_gen(buf, ptr - buf, iface);
d194 1
a194 3
	if ((ret = send_packet(iface, buf, (ptr - buf), &dst)) == -1)
		log_warnx("send_ls_update: error sending packet on "
		    "interface %s", iface->name);
d196 1
a196 1
	free(buf);
d198 4
@


1.7
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.6 2005/03/17 21:17:12 claudio Exp $ */
d183 1
a183 1
	if ((age += iface->transfer_delay) >= MAX_AGE)
@


1.6
log
@Handle the retransmission queues correctly. Mainly iface state DROTHER
needs to be handled specially because the backup DR does not send acks and
so his retransmission queue fills up and does not get cleared.
Also implement the retransmission timeout correctly.

OK henning@@ norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.5 2005/02/09 22:34:05 claudio Exp $ */
d341 1
a341 1
bool
d354 1
a354 1
	
d376 1
a376 1
		
@


1.5
log
@mini KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.4 2005/02/09 15:41:33 claudio Exp $ */
d44 1
a44 1
	struct lsa_entry	*le;
d57 5
a61 2
		le = ls_retrans_list_get(nbr, lsa_hdr);
		if (le)
a85 1
		ls_retrans_list_add(nbr, data);	/* XXX error handling */
d87 5
d93 1
d264 1
a264 1
int
d267 1
d271 2
a272 3
	ref = lsa_cache_get(lsa);
	if (ref == NULL)
		return (1);
d280 7
a286 1
	return (0);
d296 1
a296 1
		return (1);
d306 1
a306 1
	return (1);
d345 42
@


1.4
log
@If the router self is the originator of the LS update flood it out
no matter what. This solves an issue where self originated updates
where not flooded because the router was the DR.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.3 2005/02/02 19:15:07 henning Exp $ */
d175 2
a176 1
	if ((age += iface->transfer_delay) >= MAX_AGE) age = MAX_AGE;
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d89 1
a89 1
	if (iface == originator->iface) {
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d178 1
a178 1
	
d391 1
a391 1
	
d404 1
a404 1
	
d419 1
a419 1
	
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * Copyright (c) 2004, 2005 Esben Norby <esben.norby@@ericsson.com>
@

