head	1.99;
access;
symbols
	OPENBSD_6_1:1.99.0.2
	OPENBSD_6_1_BASE:1.99
	OPENBSD_6_0:1.94.0.4
	OPENBSD_6_0_BASE:1.94
	OPENBSD_5_9:1.94.0.2
	OPENBSD_5_9_BASE:1.94
	OPENBSD_5_8:1.90.0.6
	OPENBSD_5_8_BASE:1.90
	OPENBSD_5_7:1.90.0.2
	OPENBSD_5_7_BASE:1.90
	OPENBSD_5_6:1.88.0.4
	OPENBSD_5_6_BASE:1.88
	OPENBSD_5_5:1.87.0.4
	OPENBSD_5_5_BASE:1.87
	OPENBSD_5_4:1.86.0.2
	OPENBSD_5_4_BASE:1.86
	OPENBSD_5_3:1.85.0.2
	OPENBSD_5_3_BASE:1.85
	OPENBSD_5_2:1.83.0.6
	OPENBSD_5_2_BASE:1.83
	OPENBSD_5_1_BASE:1.83
	OPENBSD_5_1:1.83.0.4
	OPENBSD_5_0:1.83.0.2
	OPENBSD_5_0_BASE:1.83
	OPENBSD_4_9:1.77.0.2
	OPENBSD_4_9_BASE:1.77
	OPENBSD_4_8:1.76.0.2
	OPENBSD_4_8_BASE:1.76
	OPENBSD_4_7:1.74.0.2
	OPENBSD_4_7_BASE:1.74
	OPENBSD_4_6:1.69.0.4
	OPENBSD_4_6_BASE:1.69
	OPENBSD_4_5:1.62.0.2
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.60.0.4
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.60.0.2
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.53.0.2
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13;
locks; strict;
comment	@ * @;


1.99
date	2017.01.24.04.24.25;	author benno;	state Exp;
branches;
next	1.98;
commitid	PUkGTVeidQeu8XjZ;

1.98
date	2016.12.21.10.30.11;	author jca;	state Exp;
branches;
next	1.97;
commitid	SzQx8LqV2faSWnXV;

1.97
date	2016.12.21.10.28.48;	author jca;	state Exp;
branches;
next	1.96;
commitid	VFwzbdI5GqTFFhYT;

1.96
date	2016.09.03.10.22.57;	author renato;	state Exp;
branches;
next	1.95;
commitid	N55V2Rf3b7gYYZ14;

1.95
date	2016.09.02.14.02.48;	author benno;	state Exp;
branches;
next	1.94;
commitid	ZCYScyTMvHGcp7WF;

1.94
date	2015.12.05.12.20.13;	author claudio;	state Exp;
branches;
next	1.93;
commitid	ev1fE7U8gIdVx8OS;

1.93
date	2015.12.03.11.41.06;	author claudio;	state Exp;
branches;
next	1.92;
commitid	Rtzon3iP98l2jBUz;

1.92
date	2015.11.22.13.09.10;	author claudio;	state Exp;
branches;
next	1.91;
commitid	pxM0r18iZwdhX0Ks;

1.91
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.90;
commitid	kLBPo9HaQrkEaNW3;

1.90
date	2015.02.10.05.24.48;	author claudio;	state Exp;
branches;
next	1.89;
commitid	4XccNzu2mQpqfy01;

1.89
date	2014.11.18.20.54.29;	author krw;	state Exp;
branches;
next	1.88;
commitid	yCis8OrOsfixbKpI;

1.88
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.87;
commitid	lIxCxHhVEpsmXOdi;

1.87
date	2013.11.13.20.43.00;	author benno;	state Exp;
branches;
next	1.86;

1.86
date	2013.03.22.08.42.55;	author sthen;	state Exp;
branches;
next	1.85;

1.85
date	2013.01.17.10.07.56;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2013.01.17.10.05.17;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2011.05.02.09.22.23;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2011.03.25.08.52.21;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2011.03.24.08.35.59;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2011.03.08.10.56.02;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2010.10.01.13.29.25;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2010.06.28.23.02.07;	author bluhm;	state Exp;
branches;
next	1.75;

1.75
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2010.02.16.18.27.11;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2009.09.30.14.37.11;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2009.09.30.14.30.24;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2009.09.19.16.22.10;	author sthen;	state Exp;
branches;
next	1.70;

1.70
date	2009.08.09.23.04.16;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.06.07.31.26;	author eric;	state Exp;
branches;
next	1.68;

1.68
date	2009.06.05.19.33.59;	author pyr;	state Exp;
branches;
next	1.67;

1.67
date	2009.05.31.18.46.01;	author jacekm;	state Exp;
branches;
next	1.66;

1.66
date	2009.05.31.16.58.54;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2009.04.26.12.48.06;	author sthen;	state Exp;
branches;
next	1.64;

1.64
date	2009.04.07.14.57.33;	author reyk;	state Exp;
branches;
next	1.63;

1.63
date	2009.03.04.12.51.01;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.07.21.16.36;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2008.11.24.18.28.02;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.13.13.21.24;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2007.10.11.12.19.31;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.01.08.35.12;	author norby;	state Exp;
branches;
next	1.57;

1.57
date	2007.07.25.19.11.27;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.19.14.42.09;	author pyr;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.29.22.08.25;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2007.03.21.10.54.30;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.26.12.16.18;	author norby;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.01.13.02.04;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.11.21.43.13;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.49;

1.49
date	2006.11.17.08.55.31;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2006.09.27.14.37.38;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.02.18.49.55;	author norby;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.30.22.12.52;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.25.08.03.15;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.16.11.40.55;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.09.09.03.22;	author norby;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.08.16.03.40;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.08.13.23.08;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.21.13.02.59;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2006.02.19.18.52.06;	author norby;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.10.18.30.47;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.05.15.53.36;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.29.13.53.36;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.15.20.30.44;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.04.20.49.47;	author norby;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.19.21.43.20;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.18.15.40.36;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.13.08.27.29;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.27.08.41.25;	author norby;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.27.07.58.46;	author norby;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.27.04.48.48;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.27.02.37.39;	author norby;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.26.22.55.56;	author norby;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.26.22.45.00;	author norby;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.26.22.06.26;	author norby;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.26.19.54.49;	author norby;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.26.18.46.16;	author norby;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.23.22.54.05;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.12.19.10.12;	author norby;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.12.08.55.39;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.02.02.26.35;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.25.11.31.50;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.25.09.55.18;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.25.09.28.45;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.12.09.54.59;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.15.22.03.56;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.14.18.21.29;	author norby;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.12.11.03.05;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.12.10.49.12;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.07.10.28.14;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.27.08.21.15;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.19.10.19.56;	author norby;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.10.14.05.48;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.09.20.40.23;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.07.05.51.00;	author david;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.99
log
@sync log.c from relayd et al to ospfd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@
@
text
@/*	$OpenBSD: ospfe.c,v 1.98 2016/12/21 10:30:11 jca Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if_types.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <fcntl.h>
#include <pwd.h>
#include <unistd.h>
#include <event.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>

#include "ospf.h"
#include "ospfd.h"
#include "ospfe.h"
#include "rde.h"
#include "control.h"
#include "log.h"

void		 ospfe_sig_handler(int, short, void *);
__dead void	 ospfe_shutdown(void);
void		 orig_rtr_lsa_all(struct area *);
struct iface	*find_vlink(struct abr_rtr *);

struct ospfd_conf	*oeconf = NULL, *nconf;
struct imsgev		*iev_main;
struct imsgev		*iev_rde;
int			 oe_nofib;

/* ARGSUSED */
void
ospfe_sig_handler(int sig, short event, void *bula)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		ospfe_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* ospf engine */
pid_t
ospfe(struct ospfd_conf *xconf, int pipe_parent2ospfe[2], int pipe_ospfe2rde[2],
    int pipe_parent2rde[2])
{
	struct area	*area;
	struct iface	*iface;
	struct redistribute *r;
	struct passwd	*pw;
	struct event	 ev_sigint, ev_sigterm;
	pid_t		 pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	/* cleanup a bit */
	kif_clear();

	/* create ospfd control socket outside chroot */
	if (control_init(xconf->csock) == -1)
		fatalx("control socket setup failed");

	/* create the raw ip socket */
	if ((xconf->ospf_socket = socket(AF_INET,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    IPPROTO_OSPF)) == -1)
		fatal("error creating raw socket");

	/* set some defaults */
	if (if_set_mcast_loop(xconf->ospf_socket) == -1)
		fatal("if_set_mcast_loop");
	if (if_set_ip_hdrincl(xconf->ospf_socket) == -1)
		fatal("if_set_ip_hdrincl");
	if (if_set_recvif(xconf->ospf_socket, 1) == -1)
		fatal("if_set_recvif");
	if_set_sockbuf(xconf->ospf_socket);

	oeconf = xconf;
	if (oeconf->flags & OSPFD_FLAG_NO_FIB_UPDATE)
		oe_nofib = 1;

	if ((pw = getpwnam(OSPFD_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("ospf engine");
	/*
	 * XXX needed with fork+exec
	 * log_init(debug, LOG_DAEMON);
	 * log_setverbose(verbose);
	 */

	ospfd_process = PROC_OSPF_ENGINE;
	log_procinit(log_procnames[ospfd_process]);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	if (pledge("stdio inet mcast", NULL) == -1)
		fatal("pledge");

	event_init();
	nbr_init(NBR_HASHSIZE);
	lsa_cache_init(LSA_HASHSIZE);

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, ospfe_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, ospfe_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipes */
	close(pipe_parent2ospfe[0]);
	close(pipe_ospfe2rde[1]);
	close(pipe_parent2rde[0]);
	close(pipe_parent2rde[1]);

	if ((iev_rde = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_rde->ibuf, pipe_ospfe2rde[0]);
	iev_rde->handler = ospfe_dispatch_rde;
	imsg_init(&iev_main->ibuf, pipe_parent2ospfe[1]);
	iev_main->handler = ospfe_dispatch_main;

	/* setup event handler */
	iev_rde->events = EV_READ;
	event_set(&iev_rde->ev, iev_rde->ibuf.fd, iev_rde->events,
	    iev_rde->handler, iev_rde);
	event_add(&iev_rde->ev, NULL);

	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	event_set(&oeconf->ev, oeconf->ospf_socket, EV_READ|EV_PERSIST,
	    recv_packet, oeconf);
	event_add(&oeconf->ev, NULL);

	/* remove unneeded config stuff */
	while ((r = SIMPLEQ_FIRST(&oeconf->redist_list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&oeconf->redist_list, entry);
		free(r);
	}
	LIST_FOREACH(area, &oeconf->area_list, entry) {
		while ((r = SIMPLEQ_FIRST(&area->redist_list)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&area->redist_list, entry);
			free(r);
		}
	}

	/* listen on ospfd control socket */
	TAILQ_INIT(&ctl_conns);
	control_listen();

	if ((pkt_ptr = calloc(1, READ_BUF_SIZE)) == NULL)
		fatal("ospfe");

	/* start interfaces */
	LIST_FOREACH(area, &oeconf->area_list, entry) {
		ospfe_demote_area(area, 0);
		LIST_FOREACH(iface, &area->iface_list, entry) {
			if_init(xconf, iface);
			if (if_fsm(iface, IF_EVT_UP)) {
				log_debug("error starting interface %s",
				    iface->name);
			}
		}
	}

	event_dispatch();

	ospfe_shutdown();
	/* NOTREACHED */
	return (0);
}

__dead void
ospfe_shutdown(void)
{
	struct area	*area;
	struct iface	*iface;

	/* close pipes */
	msgbuf_write(&iev_rde->ibuf.w);
	msgbuf_clear(&iev_rde->ibuf.w);
	close(iev_rde->ibuf.fd);
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	/* stop all interfaces and remove all areas */
	while ((area = LIST_FIRST(&oeconf->area_list)) != NULL) {
		LIST_FOREACH(iface, &area->iface_list, entry) {
			if (if_fsm(iface, IF_EVT_DOWN)) {
				log_debug("error stopping interface %s",
				    iface->name);
			}
		}
		LIST_REMOVE(area, entry);
		area_del(area);
	}

	nbr_del(nbr_find_peerid(NBR_IDSELF));
	close(oeconf->ospf_socket);

	/* clean up */
	free(iev_rde);
	free(iev_main);
	free(oeconf);
	free(pkt_ptr);

	log_info("ospf engine exiting");
	_exit(0);
}

/* imesg */
int
ospfe_imsg_compose_parent(int type, pid_t pid, void *data, u_int16_t datalen)
{
	return (imsg_compose_event(iev_main, type, 0, pid, -1, data, datalen));
}

int
ospfe_imsg_compose_rde(int type, u_int32_t peerid, pid_t pid,
    void *data, u_int16_t datalen)
{
	return (imsg_compose_event(iev_rde, type, peerid, pid, -1,
	    data, datalen));
}

/* ARGSUSED */
void
ospfe_dispatch_main(int fd, short event, void *bula)
{
	static struct area	*narea;
	static struct iface	*niface;
	struct ifaddrdel	*ifc;
	struct imsg	 imsg;
	struct imsgev	*iev = bula;
	struct imsgbuf	*ibuf = &iev->ibuf;
	struct area	*area = NULL;
	struct iface	*iface = NULL;
	struct kif	*kif;
	struct auth_md	 md;
	int		 n, link_ok, stub_changed, shut = 0;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("ospfe_dispatch_main: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_IFINFO:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kif))
				fatalx("IFINFO imsg with wrong len");
			kif = imsg.data;
			link_ok = (kif->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(kif->link_state);

			LIST_FOREACH(area, &oeconf->area_list, entry) {
				LIST_FOREACH(iface, &area->iface_list, entry) {
					if (kif->ifindex == iface->ifindex &&
					    iface->type !=
					    IF_TYPE_VIRTUALLINK) {
						int prev_link_state =
						    (iface->flags & IFF_UP) &&
						    LINK_STATE_IS_UP(iface->linkstate);

						iface->flags = kif->flags;
						iface->linkstate =
						    kif->link_state;
						iface->mtu = kif->mtu;

						if (link_ok == prev_link_state)
							break;

						if (link_ok) {
							if_fsm(iface,
							    IF_EVT_UP);
							log_warnx("interface %s"
							    " up", iface->name);
						} else {
							if_fsm(iface,
							    IF_EVT_DOWN);
							log_warnx("interface %s"
							    " down",
							    iface->name);
						}
					}
				}
			}
			break;
		case IMSG_IFADDRDEL:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct ifaddrdel))
				fatalx("IFADDRDEL imsg with wrong len");
			ifc = imsg.data;

			LIST_FOREACH(area, &oeconf->area_list, entry) {
				LIST_FOREACH(iface, &area->iface_list, entry) {
					if (ifc->ifindex == iface->ifindex &&
					    ifc->addr.s_addr ==
					    iface->addr.s_addr) {
						if_fsm(iface, IF_EVT_DOWN);
						log_warnx("interface %s:%s "
						    "gone", iface->name,
						    inet_ntoa(iface->addr));
						break;
					}
				}
			}
			break;
		case IMSG_RECONF_CONF:
			if ((nconf = malloc(sizeof(struct ospfd_conf))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct ospfd_conf));

			LIST_INIT(&nconf->area_list);
			LIST_INIT(&nconf->cand_list);
			break;
		case IMSG_RECONF_AREA:
			if ((narea = area_new()) == NULL)
				fatal(NULL);
			memcpy(narea, imsg.data, sizeof(struct area));

			LIST_INIT(&narea->iface_list);
			LIST_INIT(&narea->nbr_list);
			RB_INIT(&narea->lsa_tree);
			SIMPLEQ_INIT(&narea->redist_list);

			LIST_INSERT_HEAD(&nconf->area_list, narea, entry);
			break;
		case IMSG_RECONF_IFACE:
			if ((niface = malloc(sizeof(struct iface))) == NULL)
				fatal(NULL);
			memcpy(niface, imsg.data, sizeof(struct iface));

			LIST_INIT(&niface->nbr_list);
			TAILQ_INIT(&niface->ls_ack_list);
			TAILQ_INIT(&niface->auth_md_list);
			RB_INIT(&niface->lsa_tree);

			niface->area = narea;
			LIST_INSERT_HEAD(&narea->iface_list, niface, entry);
			break;
		case IMSG_RECONF_AUTHMD:
			memcpy(&md, imsg.data, sizeof(struct auth_md));
			md_list_add(&niface->auth_md_list, md.keyid, md.key);
			break;
		case IMSG_RECONF_END:
			if ((oeconf->flags & OSPFD_FLAG_STUB_ROUTER) !=
			    (nconf->flags & OSPFD_FLAG_STUB_ROUTER))
				stub_changed = 1;
			else
				stub_changed = 0;
			merge_config(oeconf, nconf);
			nconf = NULL;
			if (stub_changed)
				orig_rtr_lsa_all(NULL);
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_IFINFO:
		case IMSG_CTL_END:
			control_imsg_relay(&imsg);
			break;
		default:
			log_debug("ospfe_dispatch_main: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
void
ospfe_dispatch_rde(int fd, short event, void *bula)
{
	struct lsa_hdr		 lsa_hdr;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct nbr		*nbr;
	struct lsa_hdr		*lhp;
	struct lsa_ref		*ref;
	struct area		*area;
	struct iface		*iface;
	struct lsa_entry	*le;
	struct imsg		 imsg;
	struct abr_rtr		 ar;
	int			 n, noack = 0, shut = 0;
	u_int16_t		 l, age;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("ospfe_dispatch_rde: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_DD:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			/*
			 * Ignore imsg when in the wrong state because a
			 * NBR_EVT_SEQ_NUM_MIS may have been issued in between.
			 * Luckily regetting the DB snapshot acts as a barrier
			 * for both state and process synchronisation.
			 */
			if ((nbr->state & NBR_STA_FLOOD) == 0)
				break;

			/* put these on my ls_req_list for retrieval */
			lhp = lsa_hdr_new();
			memcpy(lhp, imsg.data, sizeof(*lhp));
			ls_req_list_add(nbr, lhp);
			break;
		case IMSG_DD_END:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			/* see above */
			if ((nbr->state & NBR_STA_FLOOD) == 0)
				break;

			nbr->dd_pending--;
			if (nbr->dd_pending == 0 && nbr->state & NBR_STA_LOAD) {
				if (ls_req_list_empty(nbr))
					nbr_fsm(nbr, NBR_EVT_LOAD_DONE);
				else
					start_ls_req_tx_timer(nbr);
			}
			break;
		case IMSG_DD_BADLSA:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			if (nbr->iface->self == nbr)
				fatalx("ospfe_dispatch_rde: "
				    "dummy neighbor got BADREQ");

			nbr_fsm(nbr, NBR_EVT_SEQ_NUM_MIS);
			break;
		case IMSG_DB_SNAPSHOT:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;
			if (nbr->state != NBR_STA_SNAP)	/* discard */
				break;

			/* add LSA header to the neighbor db_sum_list */
			lhp = lsa_hdr_new();
			memcpy(lhp, imsg.data, sizeof(*lhp));
			db_sum_list_add(nbr, lhp);
			break;
		case IMSG_DB_END:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			nbr->dd_snapshot = 0;
			if (nbr->state != NBR_STA_SNAP)
				break;

			/* snapshot done, start tx of dd packets */
			nbr_fsm(nbr, NBR_EVT_SNAP_DONE);
			break;
		case IMSG_LS_FLOOD:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			l = imsg.hdr.len - IMSG_HEADER_SIZE;
			if (l < sizeof(lsa_hdr))
				fatalx("ospfe_dispatch_rde: "
				    "bad imsg size");
			memcpy(&lsa_hdr, imsg.data, sizeof(lsa_hdr));

			ref = lsa_cache_add(imsg.data, l);

			if (lsa_hdr.type == LSA_TYPE_EXTERNAL) {
				/*
				 * flood on all areas but stub areas and
				 * virtual links
				 */
				LIST_FOREACH(area, &oeconf->area_list, entry) {
				    if (area->stub)
					    continue;
				    LIST_FOREACH(iface, &area->iface_list,
					entry) {
					    noack += lsa_flood(iface, nbr,
						&lsa_hdr, imsg.data);
				    }
				}
			} else if (lsa_hdr.type == LSA_TYPE_LINK_OPAQ) {
				/*
				 * Flood on interface only
				 */
				noack += lsa_flood(nbr->iface, nbr,
				    &lsa_hdr, imsg.data);
			} else {
				/*
				 * Flood on all area interfaces. For
				 * area 0.0.0.0 include the virtual links.
				 */
				area = nbr->iface->area;
				LIST_FOREACH(iface, &area->iface_list, entry) {
					noack += lsa_flood(iface, nbr,
					    &lsa_hdr, imsg.data);
				}
				/* XXX virtual links */
			}

			/* remove from ls_req_list */
			le = ls_req_list_get(nbr, &lsa_hdr);
			if (!(nbr->state & NBR_STA_FULL) && le != NULL) {
				ls_req_list_free(nbr, le);
				/*
				 * XXX no need to ack requested lsa
				 * the problem is that the RFC is very
				 * unclear about this.
				 */
				noack = 1;
			}

			if (!noack && nbr->iface != NULL &&
			    nbr->iface->self != nbr) {
				if (!(nbr->iface->state & IF_STA_BACKUP) ||
				    nbr->iface->dr == nbr) {
					/* delayed ack */
					lhp = lsa_hdr_new();
					memcpy(lhp, &lsa_hdr, sizeof(*lhp));
					ls_ack_list_add(nbr->iface, lhp);
				}
			}

			lsa_cache_put(ref, nbr);
			break;
		case IMSG_LS_UPD:
		case IMSG_LS_SNAP:
			/*
			 * IMSG_LS_UPD is used in two cases:
			 * 1. as response to ls requests
			 * 2. as response to ls updates where the DB
			 *    is newer then the sent LSA
			 * IMSG_LS_SNAP is used in one case:
			 *    in EXSTART when the LSA has age MaxAge
			 */
			l = imsg.hdr.len - IMSG_HEADER_SIZE;
			if (l < sizeof(lsa_hdr))
				fatalx("ospfe_dispatch_rde: "
				    "bad imsg size");

			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			if (nbr->iface->self == nbr)
				break;

			if (imsg.hdr.type == IMSG_LS_SNAP &&
			    nbr->state != NBR_STA_SNAP)
				break;

			memcpy(&age, imsg.data, sizeof(age));
			ref = lsa_cache_add(imsg.data, l);
			if (ntohs(age) >= MAX_AGE)
				/* add to retransmit list */
				ls_retrans_list_add(nbr, imsg.data, 0, 0);
			else
				ls_retrans_list_add(nbr, imsg.data, 0, 1);

			lsa_cache_put(ref, nbr);
			break;
		case IMSG_LS_ACK:
			/*
			 * IMSG_LS_ACK is used in two cases:
			 * 1. LSA was a duplicate
			 * 2. LS age is MaxAge and there is no current
			 *    instance in the DB plus no neighbor in state
			 *    Exchange or Loading
			 */
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			if (nbr->iface->self == nbr)
				break;

			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(lsa_hdr))
				fatalx("ospfe_dispatch_rde: bad imsg size");
			memcpy(&lsa_hdr, imsg.data, sizeof(lsa_hdr));

			/* for case one check for implied acks */
			if (nbr->iface->state & IF_STA_DROTHER)
				if (ls_retrans_list_del(nbr->iface->self,
				    &lsa_hdr) == 0)
					break;
			if (ls_retrans_list_del(nbr, &lsa_hdr) == 0)
				break;

			/* send a direct acknowledgement */
			send_direct_ack(nbr->iface, nbr->addr, imsg.data,
			    imsg.hdr.len - IMSG_HEADER_SIZE);

			break;
		case IMSG_LS_BADREQ:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			if (nbr->iface->self == nbr)
				fatalx("ospfe_dispatch_rde: "
				    "dummy neighbor got BADREQ");

			nbr_fsm(nbr, NBR_EVT_BAD_LS_REQ);
			break;
		case IMSG_ABR_UP:
			memcpy(&ar, imsg.data, sizeof(ar));

			if ((iface = find_vlink(&ar)) != NULL &&
			    iface->state == IF_STA_DOWN)
				if (if_fsm(iface, IF_EVT_UP)) {
					log_debug("error starting interface %s",
					    iface->name);
				}
			break;
		case IMSG_ABR_DOWN:
			memcpy(&ar, imsg.data, sizeof(ar));

			if ((iface = find_vlink(&ar)) != NULL &&
			    iface->state == IF_STA_POINTTOPOINT)
				if (if_fsm(iface, IF_EVT_DOWN)) {
					log_debug("error stopping interface %s",
					    iface->name);
				}
			break;
		case IMSG_CTL_AREA:
		case IMSG_CTL_IFACE:
		case IMSG_CTL_END:
		case IMSG_CTL_SHOW_DATABASE:
		case IMSG_CTL_SHOW_DB_EXT:
		case IMSG_CTL_SHOW_DB_NET:
		case IMSG_CTL_SHOW_DB_RTR:
		case IMSG_CTL_SHOW_DB_SELF:
		case IMSG_CTL_SHOW_DB_SUM:
		case IMSG_CTL_SHOW_DB_ASBR:
		case IMSG_CTL_SHOW_DB_OPAQ:
		case IMSG_CTL_SHOW_RIB:
		case IMSG_CTL_SHOW_SUM:
		case IMSG_CTL_SHOW_SUM_AREA:
			control_imsg_relay(&imsg);
			break;
		default:
			log_debug("ospfe_dispatch_rde: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

struct iface *
find_vlink(struct abr_rtr *ar)
{
	struct area	*area;
	struct iface	*iface = NULL;

	LIST_FOREACH(area, &oeconf->area_list, entry)
		LIST_FOREACH(iface, &area->iface_list, entry)
			if (iface->abr_id.s_addr == ar->abr_id.s_addr &&
			    iface->type == IF_TYPE_VIRTUALLINK &&
			    iface->area->id.s_addr == ar->area.s_addr) {
				iface->dst.s_addr = ar->dst_ip.s_addr;
				iface->addr.s_addr = ar->addr.s_addr;
				iface->metric = ar->metric;

				return (iface);
			}

	return (iface);
}

void
orig_rtr_lsa_all(struct area *area)
{
	struct area	*a;

	/*
	 * update all router LSA in all areas except area itself,
	 * as this update is already running.
	 */
	LIST_FOREACH(a, &oeconf->area_list, entry)
		if (a != area)
			orig_rtr_lsa(a);
}

void
orig_rtr_lsa(struct area *area)
{
	struct lsa_hdr		 lsa_hdr;
	struct lsa_rtr		 lsa_rtr;
	struct lsa_rtr_link	 rtr_link;
	struct iface		*iface;
	struct ibuf		*buf;
	struct nbr		*nbr, *self = NULL;
	u_int16_t		 num_links = 0;
	u_int16_t		 chksum;
	u_int8_t		 border, virtual = 0;

	log_debug("orig_rtr_lsa: area %s", inet_ntoa(area->id));

	if ((buf = ibuf_dynamic(sizeof(lsa_hdr),
	    IP_MAXPACKET - sizeof(struct ip) - sizeof(struct ospf_hdr) -
	    sizeof(u_int32_t) - MD5_DIGEST_LENGTH)) == NULL)
		fatal("orig_rtr_lsa");

	/* reserve space for LSA header and LSA Router header */
	if (ibuf_reserve(buf, sizeof(lsa_hdr)) == NULL)
		fatal("orig_rtr_lsa: ibuf_reserve failed");

	if (ibuf_reserve(buf, sizeof(lsa_rtr)) == NULL)
		fatal("orig_rtr_lsa: ibuf_reserve failed");

	/* links */
	LIST_FOREACH(iface, &area->iface_list, entry) {
		if (self == NULL && iface->self != NULL)
			self = iface->self;

		bzero(&rtr_link, sizeof(rtr_link));

		if (iface->state & IF_STA_LOOPBACK) {
			rtr_link.id = iface->addr.s_addr;
			rtr_link.data = 0xffffffff;
			rtr_link.type = LINK_TYPE_STUB_NET;
			rtr_link.metric = htons(iface->metric);
			num_links++;
			if (ibuf_add(buf, &rtr_link, sizeof(rtr_link)))
				fatalx("orig_rtr_lsa: ibuf_add failed");
			continue;
		}

		switch (iface->type) {
		case IF_TYPE_POINTOPOINT:
			LIST_FOREACH(nbr, &iface->nbr_list, entry)
				if (nbr != iface->self &&
				    nbr->state & NBR_STA_FULL)
					break;
			if (nbr) {
				log_debug("orig_rtr_lsa: point-to-point, "
				    "interface %s", iface->name);
				rtr_link.id = nbr->id.s_addr;
				rtr_link.data = iface->addr.s_addr;
				rtr_link.type = LINK_TYPE_POINTTOPOINT;
				/* RFC 3137: stub router support */
				if (oeconf->flags & OSPFD_FLAG_STUB_ROUTER ||
				    oe_nofib)
					rtr_link.metric = MAX_METRIC;
				else
					rtr_link.metric = htons(iface->metric);
				num_links++;
				if (ibuf_add(buf, &rtr_link, sizeof(rtr_link)))
					fatalx("orig_rtr_lsa: ibuf_add failed");
			}
			if (iface->state & IF_STA_POINTTOPOINT) {
				log_debug("orig_rtr_lsa: stub net, "
				    "interface %s", iface->name);
				bzero(&rtr_link, sizeof(rtr_link));
				if (nbr) {
					rtr_link.id = nbr->addr.s_addr;
					rtr_link.data = 0xffffffff;
				} else {
					rtr_link.id = iface->addr.s_addr;
					rtr_link.data = iface->mask.s_addr;
				}
				rtr_link.type = LINK_TYPE_STUB_NET;
				rtr_link.metric = htons(iface->metric);
				num_links++;
				if (ibuf_add(buf, &rtr_link, sizeof(rtr_link)))
					fatalx("orig_rtr_lsa: ibuf_add failed");
			}
			continue;
		case IF_TYPE_BROADCAST:
		case IF_TYPE_NBMA:
			if ((iface->state & IF_STA_MULTI)) {
				if (iface->dr == iface->self) {
					LIST_FOREACH(nbr, &iface->nbr_list,
					    entry)
						if (nbr != iface->self &&
						    nbr->state & NBR_STA_FULL)
							break;
				} else
					nbr = iface->dr;

				if (nbr && nbr->state & NBR_STA_FULL) {
					log_debug("orig_rtr_lsa: transit net, "
					    "interface %s", iface->name);

					rtr_link.id = iface->dr->addr.s_addr;
					rtr_link.data = iface->addr.s_addr;
					rtr_link.type = LINK_TYPE_TRANSIT_NET;
					break;
				}
			}

			/*
			 * do not add a stub net LSA for interfaces that are:
			 *  - down
			 *  - have a linkstate which is down, apart from carp:
			 *    backup carp interfaces have linkstate down, but
			 *    we still announce them.
			 */
			if (!(iface->flags & IFF_UP) ||
			    (!LINK_STATE_IS_UP(iface->linkstate) &&
			    !(iface->if_type == IFT_CARP &&
			    iface->linkstate == LINK_STATE_DOWN)))
				continue;
			log_debug("orig_rtr_lsa: stub net, "
			    "interface %s", iface->name);

			rtr_link.id =
			    iface->addr.s_addr & iface->mask.s_addr;
			rtr_link.data = iface->mask.s_addr;
			rtr_link.type = LINK_TYPE_STUB_NET;

			rtr_link.num_tos = 0;
			/*
			 * backup carp interfaces are anounced with high metric
			 * for faster failover.
			 */
			if (iface->if_type == IFT_CARP &&
			    iface->linkstate == LINK_STATE_DOWN)
				rtr_link.metric = MAX_METRIC;
			else
				rtr_link.metric = htons(iface->metric);
			num_links++;
			if (ibuf_add(buf, &rtr_link, sizeof(rtr_link)))
				fatalx("orig_rtr_lsa: ibuf_add failed");
			continue;
		case IF_TYPE_VIRTUALLINK:
			LIST_FOREACH(nbr, &iface->nbr_list, entry) {
				if (nbr != iface->self &&
				    nbr->state & NBR_STA_FULL)
					break;
			}
			if (nbr) {
				rtr_link.id = nbr->id.s_addr;
				rtr_link.data = iface->addr.s_addr;
				rtr_link.type = LINK_TYPE_VIRTUAL;
				/* RFC 3137: stub router support */
				if (oeconf->flags & OSPFD_FLAG_STUB_ROUTER ||
				    oe_nofib)
					rtr_link.metric = MAX_METRIC;
				else
					rtr_link.metric = htons(iface->metric);
				num_links++;
				virtual = 1;
				if (ibuf_add(buf, &rtr_link, sizeof(rtr_link)))
					fatalx("orig_rtr_lsa: ibuf_add failed");

				log_debug("orig_rtr_lsa: virtual link, "
				    "interface %s", iface->name);
			}
			continue;
		case IF_TYPE_POINTOMULTIPOINT:
			log_debug("orig_rtr_lsa: stub net, "
			    "interface %s", iface->name);
			rtr_link.id = iface->addr.s_addr;
			rtr_link.data = 0xffffffff;
			rtr_link.type = LINK_TYPE_STUB_NET;
			rtr_link.metric = htons(iface->metric);
			num_links++;
			if (ibuf_add(buf, &rtr_link, sizeof(rtr_link)))
				fatalx("orig_rtr_lsa: ibuf_add failed");

			LIST_FOREACH(nbr, &iface->nbr_list, entry) {
				if (nbr != iface->self &&
				    nbr->state & NBR_STA_FULL) {
					bzero(&rtr_link, sizeof(rtr_link));
					log_debug("orig_rtr_lsa: "
					    "point-to-multipoint, interface %s",
					    iface->name);
					rtr_link.id = nbr->addr.s_addr;
					rtr_link.data = iface->addr.s_addr;
					rtr_link.type = LINK_TYPE_POINTTOPOINT;
					/* RFC 3137: stub router support */
					if (oe_nofib || oeconf->flags &
					    OSPFD_FLAG_STUB_ROUTER)
						rtr_link.metric = MAX_METRIC;
					else
						rtr_link.metric =
						    htons(iface->metric);
					num_links++;
					if (ibuf_add(buf, &rtr_link,
					    sizeof(rtr_link)))
						fatalx("orig_rtr_lsa: "
						    "ibuf_add failed");
				}
			}
			continue;
		default:
			fatalx("orig_rtr_lsa: unknown interface type");
		}

		rtr_link.num_tos = 0;
		/* RFC 3137: stub router support */
		if ((oeconf->flags & OSPFD_FLAG_STUB_ROUTER || oe_nofib) &&
		    rtr_link.type != LINK_TYPE_STUB_NET)
			rtr_link.metric = MAX_METRIC;
		else
			rtr_link.metric = htons(iface->metric);
		num_links++;
		if (ibuf_add(buf, &rtr_link, sizeof(rtr_link)))
			fatalx("orig_rtr_lsa: ibuf_add failed");
	}

	/* LSA router header */
	lsa_rtr.flags = 0;
	/*
	 * Set the E bit as soon as an as-ext lsa may be redistributed, only
	 * setting it in case we redistribute something is not worth the fuss.
	 * Do not set the E bit in case of a stub area.
	 */
	if (oeconf->redistribute && !area->stub)
		lsa_rtr.flags |= OSPF_RTR_E;

	border = (area_border_router(oeconf) != 0);
	if (border != oeconf->border) {
		oeconf->border = border;
		orig_rtr_lsa_all(area);
	}
	if (oeconf->border)
		lsa_rtr.flags |= OSPF_RTR_B;

	/* TODO set V flag if a active virtual link ends here and the
	 * area is the transit area for this link. */
	if (virtual)
		lsa_rtr.flags |= OSPF_RTR_V;

	lsa_rtr.dummy = 0;
	lsa_rtr.nlinks = htons(num_links);
	memcpy(ibuf_seek(buf, sizeof(lsa_hdr), sizeof(lsa_rtr)),
	    &lsa_rtr, sizeof(lsa_rtr));

	/* LSA header */
	lsa_hdr.age = htons(DEFAULT_AGE);
	lsa_hdr.opts = area_ospf_options(area);
	lsa_hdr.type = LSA_TYPE_ROUTER;
	lsa_hdr.ls_id = oeconf->rtr_id.s_addr;
	lsa_hdr.adv_rtr = oeconf->rtr_id.s_addr;
	lsa_hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa_hdr.len = htons(ibuf_size(buf));
	lsa_hdr.ls_chksum = 0;		/* updated later */
	memcpy(ibuf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));

	chksum = htons(iso_cksum(buf->buf, ibuf_size(buf), LS_CKSUM_OFFSET));
	memcpy(ibuf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
	    &chksum, sizeof(chksum));

	if (self && num_links)
		imsg_compose_event(iev_rde, IMSG_LS_UPD, self->peerid, 0,
		    -1, buf->buf, ibuf_size(buf));
	else
		log_warnx("orig_rtr_lsa: empty area %s",
		    inet_ntoa(area->id));

	ibuf_free(buf);
}

void
orig_net_lsa(struct iface *iface)
{
	struct lsa_hdr		 lsa_hdr;
	struct nbr		*nbr;
	struct ibuf		*buf;
	int			 num_rtr = 0;
	u_int16_t		 chksum;

	if ((buf = ibuf_dynamic(sizeof(lsa_hdr),
	    IP_MAXPACKET - sizeof(struct ip) - sizeof(struct ospf_hdr) -
	    sizeof(u_int32_t) - MD5_DIGEST_LENGTH)) == NULL)
		fatal("orig_net_lsa");

	/* reserve space for LSA header and LSA Router header */
	if (ibuf_reserve(buf, sizeof(lsa_hdr)) == NULL)
		fatal("orig_net_lsa: ibuf_reserve failed");

	/* LSA net mask and then all fully adjacent routers */
	if (ibuf_add(buf, &iface->mask, sizeof(iface->mask)))
		fatal("orig_net_lsa: ibuf_add failed");

	/* fully adjacent neighbors + self */
	LIST_FOREACH(nbr, &iface->nbr_list, entry)
		if (nbr->state & NBR_STA_FULL) {
			if (ibuf_add(buf, &nbr->id, sizeof(nbr->id)))
				fatal("orig_net_lsa: ibuf_add failed");
			num_rtr++;
		}

	if (num_rtr == 1) {
		/* non transit net therefore no need to generate a net lsa */
		ibuf_free(buf);
		return;
	}

	/* LSA header */
	if (iface->state & IF_STA_DR)
		lsa_hdr.age = htons(DEFAULT_AGE);
	else
		lsa_hdr.age = htons(MAX_AGE);

	lsa_hdr.opts = area_ospf_options(iface->area);
	lsa_hdr.type = LSA_TYPE_NETWORK;
	lsa_hdr.ls_id = iface->addr.s_addr;
	lsa_hdr.adv_rtr = oeconf->rtr_id.s_addr;
	lsa_hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa_hdr.len = htons(ibuf_size(buf));
	lsa_hdr.ls_chksum = 0;		/* updated later */
	memcpy(ibuf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));

	chksum = htons(iso_cksum(buf->buf, ibuf_size(buf), LS_CKSUM_OFFSET));
	memcpy(ibuf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
	    &chksum, sizeof(chksum));

	imsg_compose_event(iev_rde, IMSG_LS_UPD, iface->self->peerid, 0,
	    -1, buf->buf, ibuf_size(buf));

	ibuf_free(buf);
}

u_int32_t
ospfe_router_id(void)
{
	return (oeconf->rtr_id.s_addr);
}

void
ospfe_fib_update(int type)
{
	int	old = oe_nofib;

	if (type == IMSG_CTL_FIB_COUPLE)
		oe_nofib = 0;
	if (type == IMSG_CTL_FIB_DECOUPLE)
		oe_nofib = 1;
	if (old != oe_nofib)
		orig_rtr_lsa_all(NULL);
}

void
ospfe_iface_ctl(struct ctl_conn *c, unsigned int idx)
{
	struct area		*area;
	struct iface		*iface;
	struct ctl_iface	*ictl;

	LIST_FOREACH(area, &oeconf->area_list, entry)
		LIST_FOREACH(iface, &area->iface_list, entry)
			if (idx == 0 || idx == iface->ifindex) {
				ictl = if_to_ctl(iface);
				imsg_compose_event(&c->iev,
				    IMSG_CTL_SHOW_INTERFACE, 0, 0, -1,
				    ictl, sizeof(struct ctl_iface));
			}
}

void
ospfe_nbr_ctl(struct ctl_conn *c)
{
	struct area	*area;
	struct iface	*iface;
	struct nbr	*nbr;
	struct ctl_nbr	*nctl;

	LIST_FOREACH(area, &oeconf->area_list, entry)
		LIST_FOREACH(iface, &area->iface_list, entry)
			LIST_FOREACH(nbr, &iface->nbr_list, entry) {
				if (iface->self != nbr) {
					nctl = nbr_to_ctl(nbr);
					imsg_compose_event(&c->iev,
					    IMSG_CTL_SHOW_NBR, 0, 0, -1, nctl,
					    sizeof(struct ctl_nbr));
				}
			}

	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}

void
ospfe_demote_area(struct area *area, int active)
{
	struct demote_msg	dmsg;

	if (ospfd_process != PROC_OSPF_ENGINE ||
	    area->demote_group[0] == '\0')
		return;

	bzero(&dmsg, sizeof(dmsg));
	strlcpy(dmsg.demote_group, area->demote_group,
	    sizeof(dmsg.demote_group));
	dmsg.level = area->demote_level;
	if (active)
		dmsg.level = -dmsg.level;

	ospfe_imsg_compose_parent(IMSG_DEMOTE, 0, &dmsg, sizeof(dmsg));
}

void
ospfe_demote_iface(struct iface *iface, int active)
{
	struct demote_msg	dmsg;

	if (ospfd_process != PROC_OSPF_ENGINE ||
	    iface->demote_group[0] == '\0')
		return;

	bzero(&dmsg, sizeof(dmsg));
	strlcpy(dmsg.demote_group, iface->demote_group,
	sizeof(dmsg.demote_group));
	if (active)
		dmsg.level = -1;
	else
		dmsg.level = 1;

	log_warnx("ospfe_demote_iface: group %s level %d", dmsg.demote_group,
	    dmsg.level);

	ospfe_imsg_compose_parent(IMSG_DEMOTE, 0, &dmsg, sizeof(dmsg));
}
@


1.98
log
@For IFINFO msgs, don't run the FSM if the interface state hasn't changed.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.96 2016/09/03 10:22:57 renato Exp $ */
d125 6
d132 1
a132 1
	log_procname = log_procnames[ospfd_process];
@


1.97
log
@When receiving an IFINFO message, also update the MTU of the interface

Helps recovering from MTU mismatches.  Prompted by a diff from Remi
Locherer, ok claudio@@
@
text
@d318 4
d326 3
@


1.96
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.95 2016/09/02 14:02:48 benno Exp $ */
d321 1
@


1.95
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.94 2015/12/05 12:20:13 claudio Exp $ */
d46 1
a46 1
void		 ospfe_shutdown(void);
d215 1
a215 1
void
d221 8
a244 2
	msgbuf_write(&iev_rde->ibuf.w);
	msgbuf_clear(&iev_rde->ibuf.w);
a245 2
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
@


1.94
log
@Pledge ospfd SE ("stdio inet mcast") and RDE ("stdio") move some code
around to make it possible. Parent can't be pledged at the moment because
of carp ioctl (carp demote). Putting it in so that people can test.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.93 2015/12/03 11:41:06 claudio Exp $ */
d126 1
@


1.93
log
@imsg_read will return EAGAIN in some cases so prep code for it.
This is in the way for ospfd pledge so in it goes. OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.92 2015/11/22 13:09:10 claudio Exp $ */
d90 3
d132 3
a232 1
	kr_shutdown();
@


1.92
log
@Improve ABR support especially for self-originated stub networks.
This seems to solve the last issues people reported when using ospfd
in multiple areas. OK sthen@@ prodding by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.91 2015/09/27 17:31:50 stsp Exp $ */
d276 1
a276 1
		if ((n = imsg_read(ibuf)) == -1)
d290 1
a290 1
			fatal("ospfe_dispatch_main: imsg_read error");
d438 1
a438 1
		if ((n = imsg_read(ibuf)) == -1)
d452 1
a452 1
			fatal("ospfe_dispatch_rde: imsg_read error");
@


1.91
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.90 2015/02/10 05:24:48 claudio Exp $ */
a998 1

d1001 1
@


1.90
log
@Convert ospfd over to SOCK_CLOEXEC | SOCK_NONBLOCK and make the route
socket non-blocking. Introduce the same trigger for partial rt msgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.89 2014/11/18 20:54:29 krw Exp $ */
d882 1
a882 1
			    !(iface->media_type == IFT_CARP &&
d898 1
a898 1
			if (iface->media_type == IFT_CARP &&
@


1.89
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.88 2014/07/12 20:16:38 krw Exp $ */
d95 2
a96 1
	if ((xconf->ospf_socket = socket(AF_INET, SOCK_RAW,
@


1.88
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.87 2013/11/13 20:43:00 benno Exp $ */
a36 1
#include <stdlib.h>
@


1.87
log
@from claudio
"Let msgbuf_write return -1 with errno EAGAIN. The users then must
check if this was the case and readd the event or poll again.  The
current handling in the imsg code is wrong for sure."

ok gilles, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.86 2013/03/22 08:42:55 sthen Exp $ */
d282 1
a282 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d284 2
d444 1
a444 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d446 2
@


1.86
log
@reinstate code to announce routes to backup carp interfaces. this was removed
in a cleanup in r1.83, but we do still want to announce these (with a high
metric), so that a specific route to the relevant network is maintained
during failover.  ok florian@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.85 2013/01/17 10:07:56 markus Exp $ */
d282 1
a282 1
		if (msgbuf_write(&ibuf->w) == -1)
d442 1
a442 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.85
log
@improve snapshot handling:
- don't start a new snapshot if we are already in NBR_STA_SNAP
- ignore IMSG_DB_SNAPSHOT and IMSG_DB_END unless we are in NBR_STA_SNAP
- add new IMSG_LS_SNAP message so we can distinguish it from
  IMSG_LS_UPD. this way we can ignore them if we are not in NBR_STA_SNAP
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.83 2011/07/04 04:34:14 claudio Exp $ */
d872 3
a874 1
			 *  - have a linkstate which is down
d877 3
a879 1
			    !LINK_STATE_IS_UP(iface->linkstate))
@


1.84
log
@do not send IMSG_LS_UPD if we have no links; ok claudio
@
text
@d504 2
d517 4
d596 1
d598 1
a598 1
			 * IMSG_LS_UPD is used in three cases:
d602 2
a603 1
			 * 3. in EXSTART when the LSA has age MaxAge
d615 4
@


1.83
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.82 2011/05/09 12:24:41 claudio Exp $ */
d1007 1
a1007 1
	if (self)
@


1.82
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.81 2011/05/02 09:22:23 claudio Exp $ */
d299 1
a299 4
			    (LINK_STATE_IS_UP(kif->link_state) ||
			    (kif->link_state == LINK_STATE_UNKNOWN &&
			    kif->media_type != IFT_CARP));

d860 1
a860 4
			 *  - have a linkstate which is down and are not carp
			 *  - have a linkstate unknown and are carp
			 * carp uses linkstate down for backup and unknown
			 * in cases where a major fubar happend.
d863 1
a863 5
			    (iface->media_type != IFT_CARP &&
			    !(LINK_STATE_IS_UP(iface->linkstate) ||
			    iface->linkstate == LINK_STATE_UNKNOWN)) ||
			    (iface->media_type == IFT_CARP &&
			    iface->linkstate == LINK_STATE_UNKNOWN))
@


1.81
log
@Some KNF, some other cleanup, fix some fatalx() messages.
No functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.80 2011/03/25 08:52:21 claudio Exp $ */
d378 1
d548 6
d686 1
d695 1
@


1.80
log
@Rewrite the lsack generation. Make it more like the lsupdate code.
Removes some of the rather strange packet handling.
Tested by a few especially sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.79 2011/03/24 08:35:59 claudio Exp $ */
d255 2
a256 1
	return (imsg_compose_event(iev_rde, type, peerid, pid, -1, data, datalen));
d268 1
a268 1
	struct imsgbuf	*ibuf;
a274 2
	ibuf = &iev->ibuf;

d425 1
a425 1
	struct imsgbuf		*ibuf;
a436 2
	ibuf = &iev->ibuf;

d784 1
a784 1
				fatalx("orig_rtr_lsa: buf_add failed");
d808 1
a808 1
					fatalx("orig_rtr_lsa: buf_add failed");
d825 1
a825 1
					fatalx("orig_rtr_lsa: buf_add failed");
d1109 3
a1111 2
				imsg_compose_event(&c->iev, IMSG_CTL_SHOW_INTERFACE,
				    0, 0, -1, ictl, sizeof(struct ctl_iface));
d1174 1
a1174 1
		dmsg.level);
@


1.79
log
@Fix some memory leaks. Mainly better cleanup on shutdown but the v_nexthop
leak is a runtime one.
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.78 2011/03/08 10:56:02 claudio Exp $ */
d646 1
a646 1
			send_ls_ack(nbr->iface, nbr->addr, imsg.data,
@


1.78
log
@Instead of using IBUF_READ_SIZE as upper bound when building various
packets use a better upper bound based on IP_MAXPACKET. Also change
one IBUF_READ_SIZE to READ_BUF_SIZE since that is what the rest of
the code uses. Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.77 2010/10/01 13:29:25 claudio Exp $ */
d226 2
@


1.77
log
@Reword a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.76 2010/06/28 23:02:07 bluhm Exp $ */
d186 1
a186 1
	if ((pkt_ptr = calloc(1, IBUF_READ_SIZE)) == NULL)
d759 3
a761 2
	/* XXX IBUF_READ_SIZE */
	if ((buf = ibuf_dynamic(sizeof(lsa_hdr), READ_BUF_SIZE)) == NULL)
d1028 3
a1030 2
	/* XXX IBUF_READ_SIZE */
	if ((buf = ibuf_dynamic(sizeof(lsa_hdr), IBUF_READ_SIZE)) == NULL)
@


1.76
log
@Fix IFADDRDEL imsg error message.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.75 2010/05/26 13:56:08 nicm Exp $ */
d550 2
a551 2
				 * flood on all area interfaces on
				 * area 0.0.0.0 include also virtual links.
@


1.75
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.74 2010/02/16 18:27:11 claudio Exp $ */
d331 1
a331 1
				fatalx("IFINFO imsg with wrong len");
@


1.74
log
@Pick up RTM_DELADDR and issue an internal IFADDRDEL message to the ospfe to
inform about the interface address change. If this is an active interface
it will be downed. A ospfctl reload is needed to fetch the new/changed IP
if one got set. OK dlg@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.73 2009/09/30 14:37:11 claudio Exp $ */
d186 1
a186 1
	if ((pkt_ptr = calloc(1, READ_BUF_SIZE)) == NULL)
d751 1
a751 1
	struct buf		*buf;
d759 2
a760 2
	/* XXX READ_BUF_SIZE */
	if ((buf = buf_dynamic(sizeof(lsa_hdr), READ_BUF_SIZE)) == NULL)
d764 2
a765 2
	if (buf_reserve(buf, sizeof(lsa_hdr)) == NULL)
		fatal("orig_rtr_lsa: buf_reserve failed");
d767 2
a768 2
	if (buf_reserve(buf, sizeof(lsa_rtr)) == NULL)
		fatal("orig_rtr_lsa: buf_reserve failed");
d783 1
a783 1
			if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
d807 1
a807 1
				if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
d824 1
a824 1
				if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
d885 2
a886 2
			if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
				fatalx("orig_rtr_lsa: buf_add failed");
d906 2
a907 2
				if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
					fatalx("orig_rtr_lsa: buf_add failed");
d921 2
a922 2
			if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
				fatalx("orig_rtr_lsa: buf_add failed");
d942 1
a942 1
					if (buf_add(buf, &rtr_link,
d945 1
a945 1
						    "buf_add failed");
d961 2
a962 2
		if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
			fatalx("orig_rtr_lsa: buf_add failed");
d990 1
a990 1
	memcpy(buf_seek(buf, sizeof(lsa_hdr), sizeof(lsa_rtr)),
d1000 1
a1000 1
	lsa_hdr.len = htons(buf_size(buf));
d1002 1
a1002 1
	memcpy(buf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));
d1004 2
a1005 2
	chksum = htons(iso_cksum(buf->buf, buf_size(buf), LS_CKSUM_OFFSET));
	memcpy(buf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
d1010 1
a1010 1
		    -1, buf->buf, buf_size(buf));
d1015 1
a1015 1
	buf_free(buf);
d1023 1
a1023 1
	struct buf		*buf;
d1027 2
a1028 2
	/* XXX READ_BUF_SIZE */
	if ((buf = buf_dynamic(sizeof(lsa_hdr), READ_BUF_SIZE)) == NULL)
d1032 2
a1033 2
	if (buf_reserve(buf, sizeof(lsa_hdr)) == NULL)
		fatal("orig_net_lsa: buf_reserve failed");
d1036 2
a1037 2
	if (buf_add(buf, &iface->mask, sizeof(iface->mask)))
		fatal("orig_net_lsa: buf_add failed");
d1042 2
a1043 2
			if (buf_add(buf, &nbr->id, sizeof(nbr->id)))
				fatal("orig_net_lsa: buf_add failed");
d1049 1
a1049 1
		buf_free(buf);
d1064 1
a1064 1
	lsa_hdr.len = htons(buf_size(buf));
d1066 1
a1066 1
	memcpy(buf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));
d1068 2
a1069 2
	chksum = htons(iso_cksum(buf->buf, buf_size(buf), LS_CKSUM_OFFSET));
	memcpy(buf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
d1073 1
a1073 1
	    -1, buf->buf, buf_size(buf));
d1075 1
a1075 1
	buf_free(buf);
@


1.73
log
@Announce a stub network LSA for backup carp interfaces. This should help
when fail-over happens, since removing the better route will not result
in a blackhole until the update from the new master is processed.
Tested, OK and input sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.72 2009/09/30 14:30:24 claudio Exp $ */
d262 1
d324 20
@


1.72
log
@0xffff -> MAX_METRIC. Idea by sthen@@, I like it :)
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.71 2009/09/19 16:22:10 sthen Exp $ */
d830 14
a843 4
			if ((iface->flags & IFF_UP) == 0 ||
			    iface->linkstate == LINK_STATE_DOWN ||
			    (!LINK_STATE_IS_UP(iface->linkstate) &&
			    iface->media_type == IFT_CARP))
a844 1

d852 15
a866 1
			break;
d1149 3
@


1.71
log
@KNF indentation; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.70 2009/08/09 23:04:16 claudio Exp $ */
d782 1
a782 1
					rtr_link.metric = 0xffff;
d857 1
a857 1
					rtr_link.metric = 0xffff;
d893 1
a893 1
						rtr_link.metric = 0xffff;
d913 1
a913 1
			rtr_link.metric = 0xffff;
@


1.70
log
@Scale both receive and send buffer on the raw socket. The default 8192
bytes is not enough for larger networks causing send errors because of
too big packets. OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.69 2009/06/06 07:31:26 eric Exp $ */
d1102 1
a1102 1
	sizeof(dmsg.demote_group));
@


1.69
log
@sync ospfctl/ospfd with the common imsg code, making it lib ready as well.

"looks ok" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.68 2009/06/05 19:33:59 pyr Exp $ */
d107 1
a107 1
	if_set_recvbuf(xconf->ospf_socket);
@


1.68
log
@make ospfd's imsg lib ready as well.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.67 2009/05/31 18:46:01 jacekm Exp $ */
d52 2
a53 2
struct imsgbuf		*ibuf_main;
struct imsgbuf		*ibuf_rde;
d147 2
a148 2
	if ((ibuf_rde = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d150 4
a153 2
	imsg_init(ibuf_rde, pipe_ospfe2rde[0], ospfe_dispatch_rde);
	imsg_init(ibuf_main, pipe_parent2ospfe[1], ospfe_dispatch_main);
d156 9
a164 9
	ibuf_rde->events = EV_READ;
	event_set(&ibuf_rde->ev, ibuf_rde->fd, ibuf_rde->events,
	    ibuf_rde->handler, ibuf_rde);
	event_add(&ibuf_rde->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d229 6
a234 6
	msgbuf_write(&ibuf_rde->w);
	msgbuf_clear(&ibuf_rde->w);
	free(ibuf_rde);
	msgbuf_write(&ibuf_main->w);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
d246 1
a246 1
	return (imsg_compose_event(ibuf_main, type, 0, pid, -1, data, datalen));
d253 1
a253 1
	return (imsg_compose_event(ibuf_rde, type, peerid, pid, -1, data, datalen));
d263 2
a264 1
	struct imsgbuf  *ibuf = bula;
d271 2
d389 1
a389 1
		imsg_event_add(ibuf);
d392 1
a392 1
		event_del(&ibuf->ev);
d402 2
a403 1
	struct imsgbuf		*ibuf = bula;
d415 2
d680 1
a680 1
		imsg_event_add(ibuf);
d683 1
a683 1
		event_del(&ibuf->ev);
d965 1
a965 1
		imsg_compose_event(ibuf_rde, IMSG_LS_UPD, self->peerid, 0,
d1028 1
a1028 1
	imsg_compose_event(ibuf_rde, IMSG_LS_UPD, iface->self->peerid, 0,
d1064 1
a1064 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_SHOW_INTERFACE,
d1082 1
a1082 1
					imsg_compose_event(&c->ibuf,
d1088 1
a1088 1
	imsg_compose_event(&c->ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
@


1.67
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.66 2009/05/31 16:58:54 claudio Exp $ */
d244 1
a244 1
	return (imsg_compose(ibuf_main, type, 0, pid, data, datalen));
d251 1
a251 1
	return (imsg_compose(ibuf_rde, type, peerid, pid, data, datalen));
d957 2
a958 2
		imsg_compose(ibuf_rde, IMSG_LS_UPD, self->peerid, 0,
		    buf->buf, buf_size(buf));
d1020 2
a1021 2
	imsg_compose(ibuf_rde, IMSG_LS_UPD, iface->self->peerid, 0,
	    buf->buf, buf_size(buf));
d1056 2
a1057 2
				imsg_compose(&c->ibuf, IMSG_CTL_SHOW_INTERFACE,
				    0, 0, ictl, sizeof(struct ctl_iface));
d1074 2
a1075 2
					imsg_compose(&c->ibuf,
					    IMSG_CTL_SHOW_NBR, 0, 0, nctl,
d1080 1
a1080 1
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, NULL, 0);
@


1.66
log
@The libevent callback function may be called with EV_READ and EV_WRITE
set at the same time so using a switch to do read or write is a bad idea.
Problem noticed by Eygene Ryabinkin on FreeBSD for some reasons it is not
triggered on OpenBSD.
Fix aggreed by a most other libevent hackers
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.65 2009/04/26 12:48:06 sthen Exp $ */
a276 1
		imsg_event_add(ibuf);
a417 1
		imsg_event_add(ibuf);
@


1.65
log
@comment typos; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.64 2009/04/07 14:57:33 reyk Exp $ */
d268 1
a268 2
	switch (event) {
	case EV_READ:
d273 2
a274 2
		break;
	case EV_WRITE:
a277 3
		return;
	default:
		fatalx("unknown event");
d410 1
a410 2
	switch (event) {
	case EV_READ:
d415 2
a416 2
		break;
	case EV_WRITE:
a419 3
		return;
	default:
		fatalx("unknown event");
@


1.64
log
@allow to specify an alternate control socket instead of /var/run/ospfd.sock.
this is required to run multiple instances of ospfd.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.63 2009/03/04 12:51:01 claudio Exp $ */
d942 1
a942 1
	 * area is the tranist area for this link. */
d1006 1
a1006 1
		/* non transit net therefor no need to generate a net lsa */
@


1.63
log
@Introduce and use buf_size(buf) instead of buf->wpos -- at least in the non
buf/imsg specific code. buf_close() will no force a truncation of the buffer
to the wpos but actually add code in imsg.c to detect and report such silly
behaviour. Makes the buf API a bit more sane.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.62 2009/01/07 21:16:36 claudio Exp $ */
d92 1
a92 1
	if (control_init() == -1)
@


1.62
log
@Full stub area support. This allows ABRs to announce a default network
summary LSA into stub areas so that these routers are able to reach the
outside of the area.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.61 2008/11/24 18:28:02 claudio Exp $ */
d958 1
a958 1
	lsa_hdr.len = htons(buf->wpos);
d962 1
a962 1
	chksum = htons(iso_cksum(buf->buf, buf->wpos, LS_CKSUM_OFFSET));
d968 1
a968 1
		    buf->buf, buf->wpos);
d1022 1
a1022 1
	lsa_hdr.len = htons(buf->wpos);
d1026 1
a1026 1
	chksum = htons(iso_cksum(buf->buf, buf->wpos, LS_CKSUM_OFFSET));
d1031 1
a1031 1
	    buf->buf, buf->wpos);
@


1.61
log
@Initial support for stub areas. The bit still missing is the redistribution
of the default summary net lsa on ABRs but that is comming. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.60 2007/10/13 13:21:24 claudio Exp $ */
d173 6
d344 1
@


1.60
log
@Funny typo, it is fib not fip so adjust function name.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.59 2007/10/11 12:19:31 claudio Exp $ */
d435 9
d454 4
d466 11
d921 1
@


1.59
log
@Bye bye global ospf options. OSPF options are per area (at least the one
flag that we set). So introduce a area_ospf_options() function that will
return the correct flags for each area. This makes stub area support a lot
easier.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.58 2007/10/01 08:35:12 norby Exp $ */
d1011 1
a1011 1
ospfe_fip_update(int type)
@


1.58
log
@fix alot of whitespace problems...
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.57 2007/07/25 19:11:27 claudio Exp $ */
d898 1
a898 1
	if (oeconf->redistribute && (oeconf->options & OSPF_OPTION_E))
d921 1
a921 1
	lsa_hdr.opts = oeconf->options;		/* XXX */
d985 1
a985 1
	lsa_hdr.opts = oeconf->options;		/* XXX */
@


1.57
log
@Don't fatal if the imsg pipe is closed, this is often triggered in the parent
and hides the real cause of the termination.
OK norby@@, reyk@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.56 2007/06/19 14:42:09 pyr Exp $ */
d1071 1
a1071 1
	strlcpy(dmsg.demote_group, area->demote_group,  
d1090 1
a1090 1
	strlcpy(dmsg.demote_group, iface->demote_group,  
@


1.56
log
@Allow ospfd reconfiguration through SIGHUP, add SIGHUP handlers in
children like in bgpd so that ``pkill -1 ospfd'' works as expected.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.55 2007/05/29 22:08:25 claudio Exp $ */
d260 1
a260 1
	int		 n, link_ok, stub_changed;
d267 1
a267 1
			fatalx("pipe closed");
d381 7
a387 1
	imsg_event_add(ibuf);
d404 1
a404 1
	int			 n, noack = 0;
d412 1
a412 1
			fatalx("pipe closed");
d650 7
a656 1
	imsg_event_add(ibuf);
@


1.55
log
@Demote support for ospfd. It is possible to specify a demote group on
interfaces and areas. With this carp setups using ospfd are more reliable
because we can fail over if the OSPF connectivity is (partially) lost.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.54 2007/03/21 10:54:30 claudio Exp $ */
d139 1
@


1.54
log
@Add support for RFC 3137: OSPF Stub Router Advertisement
This allows ospfd to announce networks without the need to transit traffic.
stub router is enabled if the fib is not coupled, net.inet.ip.forwarding is
not 1 or if the stub router global config option is set to yes.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.53 2007/02/26 12:16:18 norby Exp $ */
d182 1
d1046 39
@


1.53
log
@Set the metric for loopback interfaces.

Fix by Dustin Lundquist - thank you very much.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.52 2007/02/01 13:02:04 claudio Exp $ */
d54 1
d110 2
d258 1
a258 1
	int		 n, link_ok;
d356 5
d363 2
d736 6
a741 1
				rtr_link.metric = htons(iface->metric);
d757 1
a758 1
				rtr_link.type = LINK_TYPE_STUB_NET;
d811 6
a816 1
				rtr_link.metric = htons(iface->metric);
d832 1
d842 1
a842 1
					    "point-to-point, interface %s",
d847 7
a853 1
					rtr_link.metric = htons(iface->metric);
d867 6
a872 1
		rtr_link.metric = htons(iface->metric);
d895 2
a899 2
	/* TODO set V flag if a active virtual link ends here and the
	 * area is the tranist area for this link. */
d994 13
@


1.52
log
@Preliminary configuration reload support. Seems to work reasonably well
after fixing many use-after-free errors a couple of days ago.
Most cases -- adding/removing of interfaces, adding/removing of areas --
seem to work. Still merge_config() is a behemoth of a function and some
edge cases may not be covered correctly (yet).
OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.51 2007/01/11 21:43:13 claudio Exp $ */
d707 1
@


1.51
log
@Silently ignore unknown neighbors in the rde and ospfe imsg handler. This
is needed for upcomming reload support -- it can happen that a message to
a just deleted neighbor is still pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.50 2006/11/28 19:21:15 reyk Exp $ */
d51 1
a51 1
struct ospfd_conf	*oeconf = NULL;
d247 2
d254 1
d315 40
@


1.50
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.49 2006/11/17 08:55:31 claudio Exp $ */
d74 2
a75 2
	struct area	*area = NULL;
	struct iface	*iface = NULL;
d372 1
a372 2
				fatalx("ospfe_dispatch_rde: "
				    "neighbor not found");
d382 1
a382 2
				fatalx("ospfe_dispatch_rde: "
				    "neighbor not found");
d395 1
a395 2
				fatalx("ospfe_dispatch_rde: "
				    "neighbor not found");
d405 1
a405 2
				fatalx("ospfe_dispatch_rde: "
				    "neighbor not found");
d413 1
a413 2
				fatalx("ospfe_dispatch_rde: "
				    "neighbor not found");
d490 1
a490 2
				fatalx("ospfe_dispatch_rde: "
				    "neighbor not found");
d515 1
a515 2
				fatalx("ospfe_dispatch_rde: "
				    "neighbor not found");
d540 1
a540 2
				fatalx("ospfe_dispatch_rde: "
				    "neighbor not found");
@


1.49
log
@Support for multiple networks on one interface. Until now only the main
address of a interface could be used. Now it is possible to specify a
interface more than once if multiple networks are configured. An alternative
network can be specified via e.g. interface em0:10.0.5.1. The old interface
syntax without the IP still works and uses the main/first configured IP
address.
ospfd now needs to include the IP header on outgoing messages as it is not
possible to specifiy the source address in sendto(2). Additionally all
multicast joins and leaves have to be tracked.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.48 2006/09/27 14:37:38 claudio Exp $ */
d283 1
a283 1
			    (kif->link_state == LINK_STATE_UP ||
d738 1
a738 1
			    (iface->linkstate != LINK_STATE_UP &&
@


1.48
log
@Use IP_RECVIF to get the incomming interface of OSPF packets. Now we use
the source address and the interface index to find the corresponding
struct interface which is less error prone. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.47 2006/06/02 18:49:55 norby Exp $ */
a99 4
	if (if_set_mcast_ttl(xconf->ospf_socket,
	    IP_DEFAULT_MULTICAST_TTL) == -1)
		fatal("if_set_mcast_ttl");

d102 2
a103 3

	if (if_set_tos(xconf->ospf_socket, IPTOS_PREC_INTERNETCONTROL) == -1)
		fatal("if_set_tos");
@


1.47
log
@remove unused variable, found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.46 2006/05/30 22:12:52 claudio Exp $ */
d109 2
a110 1

@


1.46
log
@Uups, this file should be commited with the redistribute rtlabel stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.45 2006/04/25 08:03:15 claudio Exp $ */
d443 1
a443 1
						&lsa_hdr, imsg.data, l);
d454 1
a454 1
					    &lsa_hdr, imsg.data, l);
@


1.45
log
@More lint cleanup. Kill unneeded stuff and sprinkle some ARGSUSED.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.44 2006/04/16 11:40:55 henning Exp $ */
d76 1
d168 6
d820 1
a820 1
	if (oeconf->redistribute_flags && (oeconf->options & OSPF_OPTION_E))
@


1.44
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.43 2006/03/09 09:03:22 norby Exp $ */
a53 1
struct ctl_conn		*ctl_conn;
d55 1
a65 1
		/* NOTREACHED */
d240 1
d326 1
d816 1
a816 2
	border = area_border_router(oeconf);

@


1.43
log
@Log link state changes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.42 2006/03/08 16:03:40 claudio Exp $ */
d288 2
a289 1
					    iface->type != IF_TYPE_VIRTUALLINK) {
@


1.42
log
@Remove unused quit flag inherited from bgpd long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.41 2006/03/08 13:23:08 claudio Exp $ */
d296 2
d301 3
@


1.41
log
@Check for implied acks. If we receive an update that is on our retransmission
queue for the neighbor there is no need to send back an ack.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.40 2006/02/21 13:02:59 claudio Exp $ */
a50 1
volatile sig_atomic_t	 ospfe_quit = 0;
@


1.40
log
@Better English in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.39 2006/02/19 18:52:06 norby Exp $ */
d518 11
a528 1
			/* TODO for case one check for implied acks */
@


1.39
log
@Do not allocate a new chunk of memory every time we receive a packet.
This should have been fixed ages ago since it really improves the
performance of ospfd.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.38 2006/02/10 18:30:47 claudio Exp $ */
d507 1
a507 1
			 *    instance in the DB plus no neighbor is state
@


1.38
log
@ospfd does not need fd passing via the imsg framework so remove that code
and remove other unneeded functions that are only used in bgpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.37 2006/01/05 15:53:36 claudio Exp $ */
d173 3
d222 1
d722 1
a722 1
			
@


1.37
log
@Make ospfd respect carp(4) interfaces and their weird behaviour. They will
not be used to connect to a OSPF cloud and forced to be passive. With this
ospfd will only announce the carp interface route if the interface is master.
So you can connect a LAN in a redundant way to your ospf backbone. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.36 2005/12/29 13:53:36 claudio Exp $ */
d228 1
a228 1
	return (imsg_compose(ibuf_main, type, 0, pid, -1, data, datalen));
d235 1
a235 1
	return (imsg_compose(ibuf_rde, type, peerid, pid, -1, data, datalen));
d831 2
a832 2
		imsg_compose(ibuf_rde, IMSG_LS_UPD,
		    self->peerid, 0, -1, buf->buf, buf->wpos);
d894 1
a894 1
	imsg_compose(ibuf_rde, IMSG_LS_UPD, iface->self->peerid, 0, -1,
d918 1
a918 1
				    0, 0, -1, ictl, sizeof(struct ctl_iface));
d936 1
a936 1
					    IMSG_CTL_SHOW_NBR, 0, 0, -1, nctl,
d941 1
a941 1
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
@


1.36
log
@Instead of a simple timer per neighbor for the LS retransmition list use
a timewheel. All LSA updates are now first added to the queue and sent out
later. This makes it possible to cluster multiple LSA updates into on OSPF
packet. This gives a massive speedup when large databases need to be synced.
Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.35 2005/12/15 20:30:44 claudio Exp $ */
d26 1
d176 4
a179 6
			if (!iface->passive) {
				if_init(xconf, iface);
				if (if_fsm(iface, IF_EVT_UP)) {
					log_debug("error starting interface %s",
					    iface->name);
				}
d200 3
a202 5
			if (!iface->passive) {
				if (if_fsm(iface, IF_EVT_DOWN)) {
					log_debug("error stopping interface %s",
					    iface->name);
				}
d246 1
a246 1
	int		 n;
d276 5
d289 2
a290 3
						if ((kif->flags & IFF_UP) &&
						    (kif->link_state !=
						     LINK_STATE_DOWN)) {
d712 7
d743 2
a744 2
				log_debug("orig_rtr_lsa: virtual link, interface %s",
				     iface->name);
@


1.35
log
@Fix ospfe shutdown function. The cleanup was totaly busted. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.34 2005/12/04 20:49:47 norby Exp $ */
d488 2
a489 1
			if (ntohs(age) >= MAX_AGE) {
d491 3
a493 4
				ref = lsa_cache_add(imsg.data, l);
				ls_retrans_list_add(nbr, imsg.data);
				lsa_cache_put(ref, nbr);
			}
d495 1
a495 2
			/* send direct don't add to retransmit list */
			send_ls_update(nbr->iface, nbr->addr, imsg.data, l);
@


1.34
log
@Increase the receive buffer of the raw socket.

Prevents some of the retransmitting during bulk ls update transfers.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.33 2005/10/19 21:43:20 claudio Exp $ */
d199 1
a199 1
	LIST_FOREACH(area, &oeconf->area_list, entry) {
d208 1
d221 1
@


1.33
log
@fix some spellings in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.32 2005/10/18 15:40:36 claudio Exp $ */
d109 2
@


1.32
log
@Cleanup interface code a minimal bit. There is no need for if_shutdown(),
especially it got called in the wrong place.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.31 2005/06/13 08:27:29 claudio Exp $ */
d498 1
a498 1
			 * 2. LSA's age is MaxAge and there is no current
@


1.31
log
@Passive interfaces belong to the area and should be announced as stub
networks. Bug report and testing by Stephen Marley.
While there kill an unneeded log_debug().
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.30 2005/05/27 08:41:25 norby Exp $ */
d208 2
@


1.30
log
@Set the V-bit when originating virtual links in router LSAs.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.29 2005/05/27 07:58:46 norby Exp $ */
a635 5

		if (iface->state & IF_STA_DOWN)
			continue;

		log_debug("orig_rtr_lsa: interface %s", iface->name);
@


1.29
log
@Virtual link support, originate virtual links in router LSAs.

jajaja claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.28 2005/05/27 04:48:48 claudio Exp $ */
d617 1
a617 1
	u_int8_t		 border;
d731 1
d797 2
@


1.28
log
@Fix a access after free on shutdown. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.27 2005/05/27 02:37:39 norby Exp $ */
d584 1
d720 17
a736 2
			log_debug("orig_rtr_lsa: not supported, interface %s",
			     iface->name);
@


1.27
log
@Initial virtual link support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.26 2005/05/26 22:55:56 norby Exp $ */
a204 1
			area_del(area);
d206 1
@


1.26
log
@More usable debug output when originating router lsas.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.25 2005/05/26 22:45:00 norby Exp $ */
d41 1
d45 4
a48 3
void	 ospfe_sig_handler(int, short, void *);
void	 ospfe_shutdown(void);
void	 orig_rtr_lsa_all(struct area *);
d276 2
a277 1
					if (kif->ifindex == iface->ifindex) {
d322 1
d527 20
d569 20
@


1.25
log
@Another unneeded debug message.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.24 2005/05/26 22:06:26 norby Exp $ */
a588 2
		log_debug("orig_rtr_lsa: interface %s", iface->name);

d594 2
@


1.24
log
@Remove unneeded debugging messages from ospfe imsg handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.23 2005/05/26 19:54:49 norby Exp $ */
a394 4

			log_debug("ospfe_dispatch_rde: IMSG_LS_FLOOD, "
			    "neighbor id %s, len %d", inet_ntoa(nbr->id),
			    imsg.hdr.len - IMSG_HEADER_SIZE);
@


1.23
log
@Simplify and cleanup passive interface handling.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.22 2005/05/26 18:46:16 norby Exp $ */
a350 4
			log_debug("ospfe_dispatch_rde: IMSG_DD, "
			    "neighbor id %s, len %d", inet_ntoa(nbr->id),
			    imsg.hdr.len - IMSG_HEADER_SIZE);

a375 4
			log_debug("ospfe_dispatch_rde: IMSG_DB_SNAPSHOT, "
			    "neighbor id %s, len %d", inet_ntoa(nbr->id),
			    imsg.hdr.len - IMSG_HEADER_SIZE);

a386 4
			log_debug("ospfe_dispatch_rde: IMSG_DB_END, "
			    "neighbor id %s, len %d", inet_ntoa(nbr->id),
			    imsg.hdr.len - IMSG_HEADER_SIZE);

a477 4
			log_debug("ospfe_dispatch_rde: IMSG_LS_UPD, "
			    "neighbor id %s, len %d", inet_ntoa(nbr->id),
			    imsg.hdr.len - IMSG_HEADER_SIZE);

a504 4
			log_debug("ospfe_dispatch_rde: IMSG_LS_ACK, "
			    "neighbor id %s, len %d", inet_ntoa(nbr->id),
			    imsg.hdr.len - IMSG_HEADER_SIZE);

a520 4
			log_debug("ospfe_dispatch_rde: IMSG_LS_BADREQ, "
			    "neighbor id %s, len %d", inet_ntoa(nbr->id),
			    imsg.hdr.len - IMSG_HEADER_SIZE);

a780 2

	log_debug("orig_net_lsa: iface %s", iface->name);
@


1.22
log
@Support dumping the configuration the way bgpd(8) does it.

This makes it possible to have ospfd(8) parse a configuration file and
display the parsed result.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.21 2005/05/23 22:54:05 henning Exp $ */
d171 6
a176 4
			if_init(xconf, iface);
			if (if_fsm(iface, IF_EVT_UP)) {
				log_debug("error starting interface %s",
				    iface->name);
d197 5
a201 3
			if (if_fsm(iface, IF_EVT_DOWN)) {
				log_debug("error stopping interface %s",
				    iface->name);
d203 1
a204 1
		area_del(area);
@


1.21
log
@useless use of endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.20 2005/05/12 19:10:12 norby Exp $ */
d750 1
a750 1
	
@


1.20
log
@Add "show database asbr/external/network/router/self-originate/summary"
to ospfctl.

Show detailed information about the LSAs in the Link State Database.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.19 2005/05/12 08:55:39 claudio Exp $ */
a124 2

	endpwent();
@


1.19
log
@If activly connected to more than one area set B flag in the self-originated
router LSA. To do that correctly we need to track the number of active
neighbors for each area. If the routers ABR status changes all router LSA
need to be updated via orig_rtr_lsa_all().
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.18 2005/05/02 02:26:35 djm Exp $ */
d552 6
@


1.18
log
@use setres[ug]id for privilege dropping; ok norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.17 2005/04/25 11:31:50 claudio Exp $ */
d46 1
d568 14
d592 1
d746 11
a756 1
	/* TODO if activly connected to more than one area set B flag */
@


1.17
log
@Call if_init() later and for each interface separately.
Move code from if_act_start() to if_init() that needs to be called only
once per interface. Especially event_set should be called only once as it
initializes struct event and so may cause corruption of the event queue if
called twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.16 2005/04/25 09:55:18 claudio Exp $ */
d121 2
a122 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid)) {
a123 1
	}
@


1.16
log
@Move the creation of the ospf_socket from if_init() directly into ospfe().
This makes it possible to call if_init() at a much later time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.15 2005/04/25 09:28:45 claudio Exp $ */
a106 3
	if (if_init(xconf))
		fatalx("error initializing interfaces");

d173 1
@


1.15
log
@Call if_init() in ospfe only, neither the rde nor the parent need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.14 2005/04/12 09:54:59 claudio Exp $ */
d90 16
@


1.14
log
@Support for self originated AS-external LSA.
With "redistribute (static|connected|default|none)" it is possible to
tell ospfd which external routes should be announced.
Connected routes will be announced only if there is no corresponding
interface configured, in that case the prefix is not external.
Adding and removing of announced prefixes are done automaticaly.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.13 2005/03/15 22:03:56 claudio Exp $ */
d90 3
@


1.13
log
@Add control messages for the show fib commands.
OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.12 2005/03/14 18:21:29 norby Exp $ */
d432 5
a436 1
				/* XXX no need to ack requested lsa */
d440 2
a441 1
			if (!noack && nbr->iface->self != nbr) {
d482 1
a482 1
				ls_retrans_list_add(nbr, imsg.data); /* XXX */
d707 10
a716 1
	lsa_rtr.flags = oeconf->flags;	/* XXX */
d724 1
a724 1
	lsa_hdr.opts = oeconf->options;	/* XXX */
d790 1
a790 1
	lsa_hdr.opts = oeconf->options;	/* XXX */
@


1.12
log
@Add "show summary" to ospfctl.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.11 2005/03/12 11:03:05 norby Exp $ */
d272 3
a275 1
			log_debug("ospfe_dispatch_main: IMSG_CTL_END");
@


1.11
log
@Add "show rib" and "show rib detail" to ospfctl.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.9 2005/03/07 10:28:14 claudio Exp $ */
d525 2
d529 2
a530 2
		case IMSG_CTL_AREA:
		case IMSG_CTL_END:
@


1.10
log
@Small K&F.

ok henning@@
@
text
@d526 1
@


1.9
log
@Track interface state (up/down) and media status. Simplify the code a bit
by using the kif/kroute info while allocating interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.8 2005/02/27 08:21:15 norby Exp $ */
d554 2
a555 1
	if ((buf = buf_dynamic(sizeof(lsa_hdr), READ_BUF_SIZE /* XXX */)) == NULL)
d739 2
a740 1
	if ((buf = buf_dynamic(sizeof(lsa_hdr), READ_BUF_SIZE /* XXX */)) == NULL)
@


1.8
log
@SPF and route table calculation.

Calculate Shortest Path Tree for each area known in the link state
database.

The Shortest Path Tree is used as input for route table calculation.
Route tabled is calculated and the result is inserted into the kernel
route table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.7 2005/02/19 10:19:56 norby Exp $ */
a252 3
			log_debug("ospfe_dispatch_main: ifindex %d changed",
			    kif->ifindex);

d256 6
a261 1
						if (kif->flags & IFF_UP) {
a270 1

@


1.7
log
@Originate P2P links correctly.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.6 2005/02/10 14:05:48 claudio Exp $ */
d343 1
a343 1
			
d663 1
a663 1
			
d695 1
a695 1
	lsa_rtr.flags = 0;	/* XXX */
d715 1
a715 1
	
@


1.6
log
@Work around a timing issue in the db exchange phase. The DB description
packets comming from the net are looped through the RDE and may get
delayed because of this. The result is that the neighbor FSM ends in
state FULL instead of LOADING and so the LSDB is not correctly
synchronized. Issue found by norby@@ OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.5 2005/02/09 20:40:23 claudio Exp $ */
d594 1
a594 1
				rtr_link.id = nbr->addr.s_addr;
@


1.5
log
@Rework of self originated LSA. First of all the code to generate the LSA
is rewritten to use the dynamic buffer api introduced lately.
Add missing parts in the RDE to merge these LSA originated from the OE into
the LSDB with correct seq_num, etc.
Add hooks to the neighbor and interface fsm so that the LSA get updated if
needed. This is not perfect, still many things are missing. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.4 2005/02/07 05:51:00 david Exp $ */
d337 14
@


1.4
log
@spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.3 2005/02/02 19:15:07 henning Exp $ */
a45 3
void	 orig_lsa(void);
void	 orig_rtr_lsa(struct area *);
void	 orig_net_lsa(struct iface *);
a163 2
	orig_lsa();

a525 13
orig_lsa(void)
{
	struct area	*area;
	struct iface	*iface;

	LIST_FOREACH(area, &oeconf->area_list, entry) {
		orig_rtr_lsa(area);
		LIST_FOREACH(iface, &area->iface_list, entry)
			orig_net_lsa(iface);
	}
}

void
d528 3
a530 1
	struct lsa		*lsa;
d532 4
a535 4
	char			*buf;
	struct lsa_rtr_link	*rtr_link;
	int			 num_links = 0;
	u_int16_t		 len;
d539 1
a539 1
	if ((buf = calloc(1, READ_BUF_SIZE)) == NULL)
d542 6
a547 11
	/* LSA header */
	lsa = (struct lsa *)buf;
	lsa->hdr.age = htons(DEFAULT_AGE);	/* XXX */
	lsa->hdr.opts = oeconf->options;	/* XXX */
	lsa->hdr.type = LSA_TYPE_ROUTER;
	lsa->hdr.ls_id = oeconf->rtr_id.s_addr;
	lsa->hdr.adv_rtr = oeconf->rtr_id.s_addr;
	lsa->hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa->hdr.ls_chksum = 0;		/* updated later */
	lsa->hdr.len = 0;		/* updated later */
	len = sizeof(struct lsa_hdr) + sizeof(struct lsa_rtr);
d553 18
a570 1
		rtr_link = (struct lsa_rtr_link *)(buf + len);
d573 16
a588 10
		case IF_TYPE_VIRTUALLINK:
			log_debug("orig_rtr_lsa: not supported, interface %s",
			     iface->name);
			break;
		case IF_TYPE_BROADCAST:
			if (iface->state == IF_STA_DOWN)
				break;

			if ((iface->state == IF_STA_WAITING) ||
			    iface->dr == NULL) {	/* XXX */
d591 36
a626 12

				rtr_link->id =
				    iface->addr.s_addr & iface->mask.s_addr;
				rtr_link->data = iface->mask.s_addr;
				rtr_link->type = LINK_TYPE_STUB_NET;
			} else {
				log_debug("orig_rtr_lsa: transit net, "
				    "interface %s", iface->name);

				rtr_link->id = iface->dr->addr.s_addr;
				rtr_link->data = iface->addr.s_addr;
				rtr_link->type = LINK_TYPE_TRANSIT_NET;
d628 2
d631 4
a634 4
			rtr_link->num_tos = 0;
			rtr_link->metric = htons(iface->metric);
			num_links++;
			len += sizeof(struct lsa_rtr_link);
d636 1
a636 2
		case IF_TYPE_NBMA:
		case IF_TYPE_POINTOMULTIPOINT:
d639 30
a668 1
			break;
d672 6
d680 6
a685 3
	lsa->data.rtr.flags = 0;	/* XXX */
	lsa->data.rtr.dummy = 0;
	lsa->data.rtr.nlinks = htons(num_links);
d687 21
a707 1
	lsa->hdr.len = htons(len);
d709 1
a709 5
	lsa->hdr.ls_chksum = htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	imsg_compose(ibuf_rde, IMSG_LS_UPD,
	    LIST_FIRST(&area->iface_list)->self->peerid, 0, -1, buf,
	    ntohs(lsa->hdr.len));
d715 1
a715 1
	struct lsa		*lsa;
d717 1
a717 1
	char			*buf;
d719 1
a719 1
	u_int16_t		 len;
d723 1
a723 4
	/* XXX if not dr quit */
		/* ... */

	if ((buf = calloc(1, READ_BUF_SIZE)) == NULL)
d726 7
a732 14
	/* LSA header */
	lsa = (struct lsa *)buf;
	lsa->hdr.age = htons(DEFAULT_AGE);	/* XXX */
	lsa->hdr.opts = oeconf->options;	/* XXX */
	lsa->hdr.type = LSA_TYPE_NETWORK;
	lsa->hdr.ls_id = oeconf->rtr_id.s_addr;
	lsa->hdr.adv_rtr = oeconf->rtr_id.s_addr;
	lsa->hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa->hdr.ls_chksum = 0;		/* updated later */
	lsa->hdr.len = 0;		/* updated later */
	len = sizeof(lsa->hdr);

	lsa->data.net.mask = iface->mask.s_addr;
	len += sizeof(lsa->data.net.mask);
a733 1
	/* attached routers */
d735 4
a738 3
	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr->state != NBR_STA_FULL) {	/* XXX */
			lsa->data.net.att_rtr[num_rtr] = nbr->id.s_addr;
a739 1
			len += sizeof(nbr->id);
d741 5
d748 21
a768 1
	lsa->hdr.len = htons(len);
d770 1
a770 5
	lsa->hdr.ls_chksum = htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));
/*
	imsg_compose(ibuf_rde, IMSG_LS_UPD, iface->self->peerid, 0, -1, buf,
	     ntohs(lsa->hdr.len));
*/
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d338 1
a338 1
			/* put these on my ls_req_list for retrival */
d405 1
a405 1
				 * flood on all area interfaces on 
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d700 1
a700 2
                                            0, 0, -1,
					    ictl, sizeof(struct ctl_iface));
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * Copyright (c) 2004 Esben Norby <esben.norby@@ericsson.com>
@

