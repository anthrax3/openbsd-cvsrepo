head	1.12;
access;
symbols
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.14
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.12
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.8
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.6
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.0.2
	OPENBSD_3_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2017.03.21.12.06.56;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	6uuBMurt3Uh42fgX;

1.11
date	2017.01.24.04.24.25;	author benno;	state Exp;
branches;
next	1.10;
commitid	PUkGTVeidQeu8XjZ;

1.10
date	2017.01.23.08.40.45;	author benno;	state Exp;
branches;
next	1.9;
commitid	XAsrNmbaOlDjCj8g;

1.9
date	2016.09.02.14.02.48;	author benno;	state Exp;
branches;
next	1.8;
commitid	ZCYScyTMvHGcp7WF;

1.8
date	2014.11.03.07.40.31;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	KxzfvwQ64ayFBEwr;

1.7
date	2011.08.20.11.16.09;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.02.20.20.54;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.09.16.58.40;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.09.15.43.21;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.08.15.36.28;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.31.12.14.34;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.12
log
@From a syslog perspective it does not make sense to log fatal and
warn with the same severity.  Switch log_warn() to LOG_ERR and keep
fatal() at LOG_CRIT.
OK reyk@@ florian@@
@
text
@/*	$OpenBSD: log.c,v 1.11 2017/01/24 04:24:25 benno Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <syslog.h>
#include <errno.h>
#include <time.h>

#include "log.h"

static int		 debug;
static int		 verbose;
static const char	*log_procname;

void
log_init(int n_debug, int facility)
{
	extern char	*__progname;

	debug = n_debug;
	verbose = n_debug;
	log_procinit(__progname);

	if (!debug)
		openlog(__progname, LOG_PID | LOG_NDELAY, facility);

	tzset();
}

void
log_procinit(const char *procname)
{
	if (procname != NULL)
		log_procname = procname;
}

void
log_setverbose(int v)
{
	verbose = v;
}

int
log_getverbose(void)
{
	return (verbose);
}

void
logit(int pri, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vlog(pri, fmt, ap);
	va_end(ap);
}

void
vlog(int pri, const char *fmt, va_list ap)
{
	char	*nfmt;
	int	 saved_errno = errno;

	if (debug) {
		/* best effort in out of mem situations */
		if (asprintf(&nfmt, "%s\n", fmt) == -1) {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		} else {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
		}
		fflush(stderr);
	} else
		vsyslog(pri, fmt, ap);

	errno = saved_errno;
}

void
log_warn(const char *emsg, ...)
{
	char		*nfmt;
	va_list		 ap;
	int		 saved_errno = errno;

	/* best effort to even work in out of memory situations */
	if (emsg == NULL)
		logit(LOG_ERR, "%s", strerror(saved_errno));
	else {
		va_start(ap, emsg);

		if (asprintf(&nfmt, "%s: %s", emsg,
		    strerror(saved_errno)) == -1) {
			/* we tried it... */
			vlog(LOG_ERR, emsg, ap);
			logit(LOG_ERR, "%s", strerror(saved_errno));
		} else {
			vlog(LOG_ERR, nfmt, ap);
			free(nfmt);
		}
		va_end(ap);
	}

	errno = saved_errno;
}

void
log_warnx(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_ERR, emsg, ap);
	va_end(ap);
}

void
log_info(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_INFO, emsg, ap);
	va_end(ap);
}

void
log_debug(const char *emsg, ...)
{
	va_list	 ap;

	if (verbose) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

static void
vfatalc(int code, const char *emsg, va_list ap)
{
	static char	s[BUFSIZ];
	const char	*sep;

	if (emsg != NULL) {
		(void)vsnprintf(s, sizeof(s), emsg, ap);
		sep = ": ";
	} else {
		s[0] = '\0';
		sep = "";
	}
	if (code)
		logit(LOG_CRIT, "fatal in %s: %s%s%s",
		    log_procname, s, sep, strerror(code));
	else
		logit(LOG_CRIT, "fatal in %s%s%s", log_procname, sep, s);
}

void
fatal(const char *emsg, ...)
{
	va_list	ap;

	va_start(ap, emsg);
	vfatalc(errno, emsg, ap);
	va_end(ap);
	exit(1);
}

void
fatalx(const char *emsg, ...)
{
	va_list	ap;

	va_start(ap, emsg);
	vfatalc(0, emsg, ap);
	va_end(ap);
	exit(1);
}
@


1.11
log
@sync log.c from relayd et al to ospfd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.34 2017/01/09 14:49:21 reyk Exp $	*/
d108 1
a108 1
		logit(LOG_CRIT, "%s", strerror(saved_errno));
d115 2
a116 2
			vlog(LOG_CRIT, emsg, ap);
			logit(LOG_CRIT, "%s", strerror(saved_errno));
d118 1
a118 1
			vlog(LOG_CRIT, nfmt, ap);
d133 1
a133 1
	vlog(LOG_CRIT, emsg, ap);
@


1.10
log
@copy log.c/h from bgpd.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.9 2016/09/02 14:02:48 benno Exp $ */
a18 2
#include <errno.h>
#include <stdarg.h>
d21 1
d24 1
a27 1
#include "ospfd.h"
d29 3
a31 3
int		 debug;
int		 verbose;
const char	*log_procname;
d34 1
a34 1
log_init(int n_debug)
d39 2
d43 1
a43 1
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);
d49 8
a56 1
log_verbose(int v)
d61 6
d81 1
d95 2
d102 3
a104 2
	char	*nfmt;
	va_list	 ap;
d108 1
a108 1
		logit(LOG_CRIT, "%s", strerror(errno));
d112 2
a113 1
		if (asprintf(&nfmt, "%s: %s", emsg, strerror(errno)) == -1) {
d116 1
a116 1
			logit(LOG_CRIT, "%s", strerror(errno));
d123 2
d159 20
d182 1
a182 2
	char	 s[1024];
	va_list	 ap;
d185 1
a185 1
	vsnprintf(s, sizeof(s), emsg, ap);
a186 12

	if (emsg == NULL)
		logit(LOG_CRIT, "fatal in %s: %s", log_procname,
		    strerror(errno));
	else
		if (errno)
			logit(LOG_CRIT, "fatal in %s: %s: %s",
			    log_procname, s, strerror(errno));
		else
			logit(LOG_CRIT, "fatal in %s: %s",
			    log_procname, s);

d191 1
a191 1
fatalx(const char *emsg)
d193 6
a198 2
	errno = 0;
	fatal(emsg);
@


1.9
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.8 2014/11/03 07:40:31 bluhm Exp $ */
a25 1
#include <unistd.h>
d139 1
a139 1
fatal(const char *emsg)
d141 7
d154 1
a154 1
			    log_procname, emsg, strerror(errno));
d157 1
a157 1
			    log_procname, emsg);
d159 1
a159 4
	if (ospfd_process == PROC_MAIN)
		exit(1);
	else				/* parent copes via SIGCHLD */
		_exit(1);
@


1.8
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.7 2011/08/20 11:16:09 sthen Exp $ */
d25 1
d28 1
a29 1
#include "log.h"
d31 3
a33 8
static const char * const procnames[] = {
	"parent",
	"ospfe",
	"rde"
};

int	debug;
int	verbose;
d143 1
a143 1
		logit(LOG_CRIT, "fatal in %s: %s", procnames[ospfd_process],
d148 1
a148 1
			    procnames[ospfd_process], emsg, strerror(errno));
d151 1
a151 1
			    procnames[ospfd_process], emsg);
a164 116

/* names */
const char *
nbr_state_name(int state)
{
	switch (state) {
	case NBR_STA_DOWN:
		return ("DOWN");
	case NBR_STA_ATTEMPT:
		return ("ATTMP");
	case NBR_STA_INIT:
		return ("INIT");
	case NBR_STA_2_WAY:
		return ("2-WAY");
	case NBR_STA_XSTRT:
		return ("EXSTA");
	case NBR_STA_SNAP:
		return ("SNAP");
	case NBR_STA_XCHNG:
		return ("EXCHG");
	case NBR_STA_LOAD:
		return ("LOAD");
	case NBR_STA_FULL:
		return ("FULL");
	default:
		return ("UNKNW");
	}
}

const char *
if_state_name(int state)
{
	switch (state) {
	case IF_STA_DOWN:
		return ("DOWN");
	case IF_STA_LOOPBACK:
		return ("LOOP");
	case IF_STA_WAITING:
		return ("WAIT");
	case IF_STA_POINTTOPOINT:
		return ("P2P");
	case IF_STA_DROTHER:
		return ("OTHER");
	case IF_STA_BACKUP:
		return ("BCKUP");
	case IF_STA_DR:
		return ("DR");
	default:
		return ("UNKNW");
	}
}

const char *
if_type_name(enum iface_type type)
{
	switch (type) {
	case IF_TYPE_POINTOPOINT:
		return ("POINTOPOINT");
	case IF_TYPE_BROADCAST:
		return ("BROADCAST");
	case IF_TYPE_NBMA:
		return ("NBMA");
	case IF_TYPE_POINTOMULTIPOINT:
		return ("POINTOMULTIPOINT");
	case IF_TYPE_VIRTUALLINK:
		return ("VIRTUALLINK");
	}
	/* NOTREACHED */
	return ("UNKNOWN");
}

const char *
if_auth_name(enum auth_type type)
{
	switch (type) {
	case AUTH_NONE:
		return ("none");
	case AUTH_SIMPLE:
		return ("simple");
	case AUTH_CRYPT:
		return ("crypt");
	}
	/* NOTREACHED */
	return ("unknown");
}

const char *
dst_type_name(enum dst_type type)
{
	switch (type) {
	case DT_NET:
		return ("Network");
	case DT_RTR:
		return ("Router");
	}
	/* NOTREACHED */
	return ("unknown");
}

const char *
path_type_name(enum path_type type)
{
	switch (type) {
	case PT_INTRA_AREA:
		return ("Intra-Area");
	case PT_INTER_AREA:
		return ("Inter-Area");
	case PT_TYPE1_EXT:
		return ("Type 1 ext");
	case PT_TYPE2_EXT:
		return ("Type 2 ext");
	}
	/* NOTREACHED */
	return ("unknown");
}

@


1.7
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"ospfd -v" (previously only "-vd" worked). Feedback on earlier implementation
from henning@@ blambert@@ claudio@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2009/11/02 20:20:54 claudio Exp $ */
a37 2

void	 logit(int, const char *, ...);
@


1.6
log
@Implement IMSG_CTL_LOG_VERBOSE to enable or disable debug logging on runtime.
It always annoyed me that in case of a problem I had to restart the ospf in
forground debug mode and by doing so losing all routes at least twice.
OK henning, sthen, michele
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2006/03/09 16:58:40 claudio Exp $ */
a46 1
	verbose = n_debug;
@


1.5
log
@Add some NOTREACHED to please lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.4 2006/03/09 15:43:21 claudio Exp $ */
d37 1
d47 1
d56 6
d139 1
a139 1
	if (debug) {
@


1.4
log
@Move *_name functions to log.c and use these for both ospfd and ospfctl.
Stuff that is only used in ospfd debug messages is simplified.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2006/03/08 15:36:28 claudio Exp $ */
d231 1
d246 1
d259 1
d276 1
@


1.3
log
@Move procnames from log.h to log.c it is only used there.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2005/03/31 12:14:34 henning Exp $ */
d163 111
@


1.2
log
@and some includes too much here as well, grunk
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d29 6
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a18 6
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <err.h>
@

