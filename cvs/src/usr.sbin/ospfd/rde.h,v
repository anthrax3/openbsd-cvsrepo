head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.6
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.38.0.12
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.16
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.14
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.10
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.8
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.6
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.4
	OPENBSD_5_0:1.38.0.2
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.35.0.10
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.8
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.4
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.6
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.34.0.6
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.4
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7;
locks; strict;
comment	@ * @;


1.39
date	2015.03.14.02.22.09;	author claudio;	state Exp;
branches;
next	1.38;
commitid	fXmmDzNCmmCnJGkB;

1.38
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2011.05.02.11.45.55;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2011.03.24.08.36.00;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.07.21.16.36;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.19.16.45.15;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.10.13.26.39;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.05.18.50.45;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.29.13.04.13;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.29.16.50.36;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.25.08.06.31;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.22.16.01.20;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.13.09.36.06;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.24.21.06.47;	author norby;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.10.13.00.49;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.02.15.10.57;	author norby;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.26.15.05.08;	author norby;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.24.18.31.32;	author norby;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.12.15.10.02;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.08.12.22.48;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.27.18.59.41;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.27.17.59.36;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.27.02.01.53;	author norby;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.24.06.55.21;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.23.23.03.07;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.22.18.05.42;	author norby;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.13.17.18.53;	author norby;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.12.20.43.13;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.12.19.10.12;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.08.19.58.51;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.12.09.54.59;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.12.11.03.05;	author norby;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.08.20.12.18;	author norby;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.27.08.21.15;	author norby;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.09.22.58.08;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.09.20.40.23;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.39
log
@When removing interfaces in the RDE we also need to remove all the RDE
neighbors that are part of that interface or we open us up to use after
free situations like the one found by sthen@@.
Diff makes sense sthen@@
@
text
@/*	$OpenBSD: rde.h,v 1.38 2011/05/09 12:24:41 claudio Exp $ */

/*
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _RDE_H_
#define _RDE_H_

#include <sys/types.h>
#include <sys/time.h>
#include <sys/tree.h>
#include <sys/queue.h>
#include <event.h>
#include <limits.h>

struct v_nexthop {
	TAILQ_ENTRY(v_nexthop)	 entry;
	struct vertex		*prev;
	struct in_addr		 nexthop;
};

TAILQ_HEAD(v_nexthead, v_nexthop);

struct vertex {
	RB_ENTRY(vertex)	 entry;
	TAILQ_ENTRY(vertex)	 cand;
	struct v_nexthead	 nexthop;
	struct event		 ev;
	struct area		*area;
	struct lsa		*lsa;
	struct lsa_tree		*lsa_tree;
	time_t			 changed;
	time_t			 stamp;
	u_int32_t		 cost;
	u_int32_t		 peerid;	/* neighbor unique imsg ID */
	u_int32_t		 ls_id;
	u_int32_t		 adv_rtr;
	u_int8_t		 type;
	u_int8_t		 flooded;
	u_int8_t		 deleted;
	u_int8_t		 self;
};

struct rde_req_entry {
	TAILQ_ENTRY(rde_req_entry)	entry;
	u_int32_t			ls_id;
	u_int32_t			adv_rtr;
	u_int8_t			type;
};

/* just the info RDE needs */
struct rde_nbr {
	LIST_ENTRY(rde_nbr)		 entry, hash;
	struct in_addr			 id;
	struct in_addr			 area_id;
	TAILQ_HEAD(, rde_req_entry)	 req_list;
	struct area			*area;
	struct iface			*iface;
	u_int32_t			 peerid;	/* unique ID in DB */
	int				 state;
	unsigned int			 ifindex;
	u_int8_t			 self;
	u_int8_t			 capa_options;
};

struct rt_nexthop {
	TAILQ_ENTRY(rt_nexthop)	entry;
	struct in_addr		nexthop;
	struct in_addr		adv_rtr;
	time_t			uptime;
	u_int8_t		connected;
	u_int8_t		invalid;
};

struct rt_node {
	RB_ENTRY(rt_node)	entry;
	TAILQ_HEAD(,rt_nexthop)	nexthop;
	struct in_addr		prefix;
	struct in_addr		area;
	u_int32_t		cost;
	u_int32_t		cost2;
	u_int32_t		ext_tag;
	enum path_type		p_type;
	enum dst_type		d_type;
	u_int8_t		flags;
	u_int8_t		prefixlen;
	u_int8_t		invalid;
};

struct abr_rtr {
	struct in_addr		 addr;
	struct in_addr		 abr_id;
	struct in_addr		 dst_ip;
	struct in_addr		 area;
	u_int16_t		 metric;
};

extern struct lsa_tree	asext_tree;

/* rde.c */
pid_t		 rde(struct ospfd_conf *, int [2], int [2], int [2]);
int		 rde_imsg_compose_ospfe(int, u_int32_t, pid_t, void *,
		     u_int16_t);
u_int32_t	 rde_router_id(void);
struct area	*rde_backbone_area(void);
void		 rde_send_change_kroute(struct rt_node *);
void		 rde_send_delete_kroute(struct rt_node *);
void		 rde_nbr_iface_del(struct iface *);
void		 rde_nbr_del(struct rde_nbr *);
int		 rde_nbr_loading(struct area *);
struct rde_nbr	*rde_nbr_self(struct area *);
void		 rde_summary_update(struct rt_node *, struct area *);
struct lsa	*orig_sum_lsa(struct rt_node *, struct area *, u_int8_t, int);

/* rde_lsdb.c */
void		 lsa_init(struct lsa_tree *);
int		 lsa_compare(struct vertex *, struct vertex *);
void		 vertex_free(struct vertex *);
void		 vertex_nexthop_clear(struct vertex *);
void		 vertex_nexthop_add(struct vertex *, struct vertex *,
		    u_int32_t);
int		 lsa_newer(struct lsa_hdr *, struct lsa_hdr *);
int		 lsa_check(struct rde_nbr *, struct lsa *, u_int16_t);
int		 lsa_self(struct rde_nbr *, struct lsa *, struct vertex *);
int		 lsa_add(struct rde_nbr *, struct lsa *);
void		 lsa_del(struct rde_nbr *, struct lsa_hdr *);
void		 lsa_age(struct vertex *);
struct vertex	*lsa_find(struct iface *, u_int8_t, u_int32_t, u_int32_t);
struct vertex	*lsa_find_area(struct area *, u_int8_t, u_int32_t, u_int32_t);
struct vertex	*lsa_find_net(struct area *area, u_int32_t);
u_int16_t	 lsa_num_links(struct vertex *);
void		 lsa_snap(struct rde_nbr *);
void		 lsa_dump(struct lsa_tree *, int, pid_t);
void		 lsa_merge(struct rde_nbr *, struct lsa *, struct vertex *);
void		 lsa_remove_invalid_sums(struct area *);
void		 lsa_generate_stub_sums(struct area *);

/* rde_spf.c */
void		 spf_calc(struct area *);
void		 rt_calc(struct vertex *, struct area *, struct ospfd_conf *);
void		 asext_calc(struct vertex *);
void		 spf_tree_clr(struct area *);

void		 cand_list_init(void);
void		 cand_list_add(struct vertex *);
struct vertex	*cand_list_pop(void);
int		 cand_list_present(struct vertex *);
void		 cand_list_clr(void);

void		 spf_timer(int, short, void *);
void		 start_spf_timer(void);
void		 stop_spf_timer(struct ospfd_conf *);
void		 start_spf_holdtimer(struct ospfd_conf *);

void		 rt_init(void);
int		 rt_compare(struct rt_node *, struct rt_node *);
struct rt_node	*rt_find(in_addr_t, u_int8_t, enum dst_type);
int		 rt_insert(struct rt_node *);
int		 rt_remove(struct rt_node *);
void		 rt_clear(void);
void		 rt_dump(struct in_addr, pid_t, u_int8_t);
struct rt_node	*rt_lookup(enum dst_type, in_addr_t);

RB_PROTOTYPE(lsa_tree, vertex, entry, lsa_compare)

#endif	/* _RDE_H_ */
@


1.38
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.37 2011/05/02 11:45:55 claudio Exp $ */
d121 1
@


1.37
log
@More spring cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.36 2011/03/24 08:36:00 claudio Exp $ */
d44 1
d71 1
d74 3
a76 1
	int				 self;
d140 2
a141 1
struct vertex	*lsa_find(struct area *, u_int8_t, u_int32_t, u_int32_t);
d144 1
a144 1
void		 lsa_snap(struct area *, u_int32_t);
@


1.36
log
@Fix some memory leaks. Mainly better cleanup on shutdown but the v_nexthop
leak is a runtime one.
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.35 2009/01/07 21:16:36 claudio Exp $ */
a169 3

struct lsa_rtr_link	*get_rtr_link(struct vertex *, int);
struct lsa_net_link	*get_net_link(struct vertex *, int);
@


1.35
log
@Full stub area support. This allows ABRs to announce a default network
summary LSA into stub areas so that these routers are able to reach the
outside of the area.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.34 2007/06/19 16:45:15 reyk Exp $ */
d127 3
@


1.34
log
@add support for mapping route labels to AS-external route tags.

manpage bits from jmc@@
ok norby@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.33 2007/04/10 13:26:39 claudio Exp $ */
d114 1
d121 1
d140 1
d166 1
@


1.33
log
@Next step in equal cost multipath support. Make the SPF calculation multipath
aware. Both the SPF and RIB trees need additional structures to store the
multiple nexthops to the destination but only the first active nexthop is
passed to the parent process and used for routing. This is the next thing
that needs to be modified. Tested and OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.32 2007/04/05 18:50:45 pyr Exp $ */
d91 1
@


1.32
log
@remove an unused function.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.31 2007/01/29 13:04:13 claudio Exp $ */
d29 8
d40 1
a41 2
	struct in_addr		 nexthop;
	struct vertex		*prev;
d75 9
d85 11
a95 14
	RB_ENTRY(rt_node)	 entry;
	struct in_addr		 prefix;
	struct in_addr		 nexthop;
	struct in_addr		 area;
	struct in_addr		 adv_rtr;
	u_int32_t		 cost;
	u_int32_t		 cost2;
	time_t			 uptime;
	enum path_type		 p_type;
	enum dst_type		 d_type;
	u_int8_t		 flags;
	u_int8_t		 prefixlen;
	u_int8_t		 invalid;
	u_int8_t		 connected;
@


1.31
log
@Do not link from the LS DB to outside structures that may vanish before
the actual LS DB entry is removed. In particular a neighbor may be removed
at any time -- we were lucky because we kept down neighbors around for
another 24h. Reload support unhided this problem again. Just copy the
needed info into the vertex. Pointing to the area is save as the vertex is
part of the area itself and removed when the area is removed.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.30 2006/05/29 16:50:36 claudio Exp $ */
a96 1
int		 rde_imsg_compose_parent(int, pid_t, void *, u_int16_t);
@


1.30
log
@Delay lsa database deletes for MIN_LS_INTERVAL seconds so that flapping
routes do not cause a update storm. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.29 2006/04/25 08:06:31 claudio Exp $ */
d35 1
a35 1
	struct rde_nbr		*nbr;
d40 1
d46 1
@


1.29
log
@The return value of lsa_num_links is an u_int16_t tnd not int. Found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.28 2006/03/22 16:01:20 claudio Exp $ */
d44 1
d113 1
a113 1
void		 lsa_add(struct rde_nbr *, struct lsa *);
@


1.28
log
@Move the AS external LSA tree out of struct ospfd_config. This simplifies
the code and makes config reloads easier. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.27 2006/03/13 09:36:06 claudio Exp $ */
d117 1
a117 1
int		 lsa_num_links(struct vertex *);
@


1.27
log
@The return value of the start/stop timer functions is almost never checked.
Switch them to void functions and check if evtimer_add/del fails -- in which
case we fatal() as there is no useful way to recover in such an event.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.26 2006/02/24 21:06:47 norby Exp $ */
d89 2
@


1.26
log
@Keep track of the uptime of the entries in the RIB.
It is now possible to see the uptime of the individual entries in the RIB.
The uptime can be displayed with "ospfctl show rib"

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.25 2006/02/10 13:00:49 claudio Exp $ */
d134 3
a136 3
int		 start_spf_timer(void);
int		 stop_spf_timer(struct ospfd_conf *);
int		 start_spf_holdtimer(struct ospfd_conf *);
@


1.25
log
@If ABR only look in the backbone area 0.0.0.0 for summary LSA. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.24 2006/02/02 15:10:57 norby Exp $ */
d73 1
@


1.24
log
@zap cand_list_empty, found by lint.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.23 2006/01/26 15:05:08 norby Exp $ */
d122 1
a122 1
void		 rt_calc(struct vertex *, struct area *);
@


1.23
log
@Separate route table calculations from the SPF calculation.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.22 2006/01/24 18:31:32 norby Exp $ */
a130 1
int		 cand_list_empty(void);
@


1.22
log
@Split SPF calc and AS Ext calc.

Initial diff by claudio@@ reworked by me.

test and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.21 2006/01/12 15:10:02 claudio Exp $ */
d122 1
@


1.21
log
@Rewrite the redistribute code. The previous implementation was stupid and
resulted in a major bottleneck if bgpd was used on the same box -- not clever
to do linear searches over 175k entries :(. This now moves the redistribute
code back into kroute duty and kills the linear list. Also default routes are
now redistributed without the need for a kernel default route.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.20 2005/08/08 12:22:48 claudio Exp $ */
d122 1
@


1.20
log
@Try to do an SPF recalculation only if the LS DB changed.
This is still not perfect as on ABRs it is only necessary to
recalculate the area that got changed and not all others too.
More to come but it is a good start. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.19 2005/06/27 18:59:41 claudio Exp $ */
a62 6
};

struct rde_asext {
	LIST_ENTRY(rde_asext)	 entry;
	struct kroute		 kr;
	int			 used;
@


1.19
log
@Mark connected routes (routes without a nexthop) in the rib. Without this
as-ext routes would select a wrong nexthop if the forwarding router is
directly connected. OK, help and debugging norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.18 2005/06/27 17:59:36 claudio Exp $ */
d138 1
a138 1
int		 start_spf_timer(struct ospfd_conf *);
@


1.18
log
@Don't let /32 DT_NET routes override DT_RTR routes. This should help
setups with /32 loopback networks.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.17 2005/05/27 02:01:53 norby Exp $ */
d84 1
@


1.17
log
@Preparation for upcoming virtual link support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.16 2005/05/24 06:55:21 claudio Exp $ */
d143 1
a143 1
struct rt_node	*rt_find(in_addr_t, u_int8_t);
@


1.16
log
@Fix some obvious issues in the summary LSA origination.
Actually remove summary LSA if the LSA they refer to are no longer valid.
Set correct cost on the summary LSA.
Announce type 4 summary LSA.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.15 2005/05/23 23:03:07 claudio Exp $ */
d84 8
@


1.15
log
@First part of summary LSA origination. Not perfect but a start.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.14 2005/05/22 18:05:42 norby Exp $ */
d115 1
@


1.14
log
@Handle cost2 for AS-external, and prepare for handling flags in
ospfctl show rib detail.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.13 2005/05/13 17:18:53 norby Exp $ */
d97 1
@


1.13
log
@Cost type 2 will be needed soon.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.12 2005/05/12 20:43:13 claudio Exp $ */
d81 1
@


1.12
log
@Every time a LSA is returned from a lookup lsa_age() it.
Also move the lsa_age() prototype to rde.h so that we can access it from
the SPF code.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.11 2005/05/12 19:10:12 norby Exp $ */
d78 1
@


1.11
log
@Add "show database asbr/external/network/router/self-originate/summary"
to ospfctl.

Show detailed information about the LSAs in the Link State Database.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.10 2005/05/08 19:58:51 claudio Exp $ */
d105 1
@


1.10
log
@Keep track of the req list in the RDE. The RFC requires us to check for
silly updates while fetching the table from the other server. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.9 2005/04/12 09:54:59 claudio Exp $ */
d109 1
a109 1
void		 lsa_dump(struct lsa_tree *, pid_t);
@


1.9
log
@Support for self originated AS-external LSA.
With "redistribute (static|connected|default|none)" it is possible to
tell ospfd which external routes should be announced.
Connected routes will be announced only if there is no corresponding
interface configured, in that case the prefix is not external.
Adding and removing of announced prefixes are done automaticaly.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.8 2005/03/22 22:13:48 norby Exp $ */
d46 7
d55 8
a62 8
	LIST_ENTRY(rde_nbr)	 entry, hash;
	struct in_addr		 id;
	struct in_addr		 area_id;
	struct lsa_head		 ls_req_list;
	struct area		*area;
	u_int32_t		 peerid;	/* unique ID in DB */
	int			 state;
	int			 self;
@


1.8
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.7 2005/03/12 11:03:05 norby Exp $ */
d56 6
@


1.7
log
@Add "show rib" and "show rib detail" to ospfctl.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.6 2005/03/08 20:12:18 norby Exp $ */
d68 1
a68 1
	bool			 invalid;
d106 1
a106 1
bool		 cand_list_present(struct vertex *);
d108 1
a108 1
bool		 cand_list_empty(void);
@


1.6
log
@Remove no longer valid route entries.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.5 2005/02/27 08:21:15 norby Exp $ */
d63 1
d121 1
@


1.5
log
@SPF and route table calculation.

Calculate Shortest Path Tree for each area known in the link state
database.

The Shortest Path Tree is used as input for route table calculation.
Route tabled is calculated and the result is inserted into the kernel
route table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.4 2005/02/09 22:58:08 claudio Exp $ */
a60 1
	u_int8_t		 prefixlen;
d62 2
d65 3
a67 1
	u_int32_t		 cost;
d76 2
a77 1
void		 rde_send_kroute(struct rt_node *);
@


1.4
log
@Fix premature ageing of self originating LSA. Still not perfect but better
than before where it just failed to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.3 2005/02/09 20:40:23 claudio Exp $ */
d31 1
d58 9
d73 1
d88 2
d93 26
@


1.3
log
@Rework of self originated LSA. First of all the code to generate the LSA
is rewritten to use the dynamic buffer api introduced lately.
Add missing parts in the RDE to merge these LSA originated from the OE into
the LSDB with correct seq_num, etc.
Add hooks to the neighbor and interface fsm so that the LSA get updated if
needed. This is not perfect, still many things are missing. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d65 1
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d66 1
a66 1
/* rde_spf.c */
d78 1
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2004, 2005 Esben Norby <esben.norby@@ericsson.com>
@

