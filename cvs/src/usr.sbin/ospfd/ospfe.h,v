head	1.46;
access;
symbols
	OPENBSD_6_0:1.46.0.8
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.4
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.45.0.10
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.8
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.44.0.6
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.42.0.4
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.4
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.38.0.4
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.2
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.46
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.45;
commitid	2uw1UTO4k6erpWzK;

1.45
date	2013.01.17.10.07.56;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2011.03.25.08.52.21;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2009.08.09.23.04.16;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.06.07.31.26;	author eric;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.31.08.55.00;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.13.13.21.24;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.11.08.21.29;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.29.22.08.25;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.21.10.54.30;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.01.12.41.03;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.17.08.55.31;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2006.09.27.14.37.38;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.02.18.49.55;	author norby;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.25.08.33.00;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.25.08.24.45;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.24.20.18.03;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.13.09.36.06;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.09.15.43.21;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.09.13.31.57;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.19.21.48.56;	author norby;	state Exp;
branches;
next	1.23;

1.23
date	2006.02.19.18.55.47;	author norby;	state Exp;
branches;
next	1.22;

1.22
date	2006.02.19.18.52.06;	author norby;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.02.15.11.54;	author norby;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.29.13.53.36;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.15.20.29.06;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.04.20.49.47;	author norby;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.04.10.19.16;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.18.15.40.36;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.26.20.42.10;	author norby;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.25.11.31.50;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.25.09.55.18;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.12.09.54.59;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.05.13.01.22;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.31.19.32.10;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.17.21.17.12;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.07.10.28.14;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.10.14.05.48;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.09.20.47.04;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.09.20.40.23;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.15.07;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@/*	$OpenBSD: ospfe.h,v 1.45 2013/01/17 10:07:56 markus Exp $ */

/*
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _OSPFE_H_
#define _OSPFE_H_

#define max(x,y) ((x) > (y) ? (x) : (y))

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>

TAILQ_HEAD(ctl_conns, ctl_conn)	ctl_conns;

struct lsa_entry {
	TAILQ_ENTRY(lsa_entry)	 entry;
	union {
		struct lsa_hdr	*lu_lsa;
		struct lsa_ref	*lu_ref;
	}			 le_data;
	unsigned short		 le_when;
	unsigned short		 le_oneshot;
};
#define	le_lsa	le_data.lu_lsa
#define	le_ref	le_data.lu_ref

struct lsa_ref {
	LIST_ENTRY(lsa_ref)	 entry;
	struct lsa_hdr		 hdr;
	void			*data;
	time_t			 stamp;
	int			 refcnt;
	u_int16_t		 len;
};

struct nbr_stats {
	u_int32_t		 sta_chng;
};

struct nbr {
	LIST_ENTRY(nbr)		 entry, hash;
	struct event		 inactivity_timer;
	struct event		 db_tx_timer;
	struct event		 lsreq_tx_timer;
	struct event		 ls_retrans_timer;
	struct event		 adj_timer;

	struct nbr_stats	 stats;

	struct lsa_head		 ls_retrans_list;
	struct lsa_head		 db_sum_list;
	struct lsa_head		 ls_req_list;

	struct in_addr		 addr;
	struct in_addr		 id;
	struct in_addr		 dr;		/* designated router */
	struct in_addr		 bdr;		/* backup designated router */

	struct iface		*iface;
	struct lsa_entry	*ls_req;
	struct lsa_entry	*dd_end;

	u_int32_t		 dd_seq_num;
	u_int32_t		 dd_pending;
	u_int32_t		 peerid;	/* unique ID in DB */
	u_int32_t		 ls_req_cnt;
	u_int32_t		 ls_ret_cnt;
	u_int32_t		 crypt_seq_num;

	time_t			 uptime;
	int			 state;
	u_int8_t		 priority;
	u_int8_t		 options;
	u_int8_t		 capa_options;
	u_int8_t		 last_rx_options;
	u_int8_t		 last_rx_bits;
	u_int8_t		 dd_master;
	u_int8_t		 dd_more;
	u_int8_t		 dd_snapshot;	/* snapshot running */
};

/* auth.c */
int		 auth_validate(void *buf, u_int16_t len, struct iface *,
		     struct nbr *);
int		 auth_gen(struct ibuf *, struct iface *);
void		 md_list_add(struct auth_md_head *, u_int8_t, char *);
void		 md_list_copy(struct auth_md_head *, struct auth_md_head *);
void		 md_list_clr(struct auth_md_head *);
int		 md_list_send(struct auth_md_head *, struct imsgev *);

/* database.c */
int	 send_db_description(struct nbr *);
void	 recv_db_description(struct nbr *, char *, u_int16_t);
void	 db_sum_list_add(struct nbr *, struct lsa_hdr *);
int	 db_sum_list_del(struct nbr *, struct lsa_hdr *);
void	 db_sum_list_clr(struct nbr *);
void	 db_tx_timer(int, short, void *);
void	 start_db_tx_timer(struct nbr *);
void	 stop_db_tx_timer(struct nbr *);

/* hello.c */
int	 send_hello(struct iface *);
void	 recv_hello(struct iface *,  struct in_addr, u_int32_t,
	     char *, u_int16_t);

/* ospfe.c */
pid_t		 ospfe(struct ospfd_conf *, int[2], int[2], int[2]);
void		 ospfe_dispatch_main(int, short, void *);
void		 ospfe_dispatch_rde(int, short, void *);
int		 ospfe_imsg_compose_parent(int, pid_t, void *, u_int16_t);
int		 ospfe_imsg_compose_rde(int, u_int32_t, pid_t, void *,
		     u_int16_t);
u_int32_t	 ospfe_router_id(void);
void		 ospfe_fib_update(int);
void		 ospfe_iface_ctl(struct ctl_conn *, unsigned int);
void		 ospfe_nbr_ctl(struct ctl_conn *);
void		 orig_rtr_lsa(struct area *);
void		 orig_net_lsa(struct iface *);
void		 ospfe_demote_area(struct area *, int);
void		 ospfe_demote_iface(struct iface *, int);

/* interface.c */
int		 if_fsm(struct iface *, enum iface_event);

struct iface	*if_new(struct kif *, struct kif_addr *);
void		 if_del(struct iface *);
void		 if_init(struct ospfd_conf *, struct iface *);

int		 if_act_start(struct iface *);
int		 if_act_elect(struct iface *);
int		 if_act_reset(struct iface *);

struct ctl_iface	*if_to_ctl(struct iface *);

int	 if_join_group(struct iface *, struct in_addr *);
int	 if_leave_group(struct iface *, struct in_addr *);
int	 if_set_mcast(struct iface *);
int	 if_set_recvif(int, int);
void	 if_set_sockbuf(int);
int	 if_set_mcast_loop(int);
int	 if_set_ip_hdrincl(int);

/* lsack.c */
int	 delay_lsa_ack(struct iface *, struct lsa_hdr *);
int	 send_direct_ack(struct iface *, struct in_addr, void *, size_t);
void	 recv_ls_ack(struct nbr *, char *, u_int16_t);
int	 lsa_hdr_check(struct nbr *, struct lsa_hdr *);
void	 ls_ack_list_add(struct iface *, struct lsa_hdr *);
void	 ls_ack_list_free(struct iface *, struct lsa_entry *);
void	 ls_ack_list_clr(struct iface *);
int	 ls_ack_list_empty(struct iface *);
void	 ls_ack_tx_timer(int, short, void *);
void	 start_ls_ack_tx_timer(struct iface *);
void	 stop_ls_ack_tx_timer(struct iface *);

/* lsreq.c */
int	 send_ls_req(struct nbr *);
void	 recv_ls_req(struct nbr *, char *, u_int16_t);
void	 ls_req_list_add(struct nbr *, struct lsa_hdr *);
int	 ls_req_list_del(struct nbr *, struct lsa_hdr *);
struct lsa_entry	*ls_req_list_get(struct nbr *, struct lsa_hdr *);
void	 ls_req_list_free(struct nbr *, struct lsa_entry *);
void	 ls_req_list_clr(struct nbr *);
int	 ls_req_list_empty(struct nbr *);
void	 ls_req_tx_timer(int, short, void *);
void	 start_ls_req_tx_timer(struct nbr *);
void	 stop_ls_req_tx_timer(struct nbr *);

/* lsupdate.c */
int		 lsa_flood(struct iface *, struct nbr *, struct lsa_hdr *,
		     void *);
void		 recv_ls_update(struct nbr *, char *, u_int16_t);

void		 ls_retrans_list_add(struct nbr *, struct lsa_hdr *,
		     unsigned short, unsigned short);
int		 ls_retrans_list_del(struct nbr *, struct lsa_hdr *);
struct lsa_entry	*ls_retrans_list_get(struct nbr *, struct lsa_hdr *);
void		 ls_retrans_list_free(struct nbr *, struct lsa_entry *);
void		 ls_retrans_list_clr(struct nbr *);
void		 ls_retrans_timer(int, short, void *);

void		 lsa_cache_init(u_int32_t);
struct lsa_ref	*lsa_cache_add(void *, u_int16_t);
struct lsa_ref	*lsa_cache_get(struct lsa_hdr *);
void		 lsa_cache_put(struct lsa_ref *, struct nbr *);

/* neighbor.c */
void		 nbr_init(u_int32_t);
struct nbr	*nbr_new(u_int32_t, struct iface *, int);
void		 nbr_del(struct nbr *);

struct nbr	*nbr_find_id(struct iface *, u_int32_t);
struct nbr	*nbr_find_peerid(u_int32_t);

int	 nbr_fsm(struct nbr *, enum nbr_event);

void	 nbr_itimer(int, short, void *);
void	 nbr_start_itimer(struct nbr *);
void	 nbr_stop_itimer(struct nbr *);
void	 nbr_reset_itimer(struct nbr *);

void	 nbr_adj_timer(int, short, void *);
void	 nbr_start_adj_timer(struct nbr *);

int	 nbr_act_reset_itimer(struct nbr *);
int	 nbr_act_start_itimer(struct nbr *);
int	 nbr_act_eval(struct nbr *);
int	 nbr_act_snapshot(struct nbr *);
int	 nbr_act_exchange_done(struct nbr *);
int	 nbr_act_adj_ok(struct nbr *);
int	 nbr_act_restart_dd(struct nbr *);
int	 nbr_act_delete(struct nbr *);
int	 nbr_act_clear_lists(struct nbr *);
int	 nbr_act_hello_check(struct nbr *);

struct ctl_nbr	*nbr_to_ctl(struct nbr *);

struct lsa_hdr	*lsa_hdr_new(void);

/* packet.c */
int	 gen_ospf_hdr(struct ibuf *, struct iface *, u_int8_t);
int	 send_packet(struct iface *, struct ibuf *, struct sockaddr_in *);
void	 recv_packet(int, short, void *);

char	*pkt_ptr;	/* packet buffer */

#endif	/* _OSPFE_H_ */
@


1.45
log
@improve snapshot handling:
- don't start a new snapshot if we are already in NBR_STA_SNAP
- ignore IMSG_DB_SNAPSHOT and IMSG_DB_END unless we are in NBR_STA_SNAP
- add new IMSG_LS_SNAP message so we can distinguish it from
  IMSG_LS_UPD. this way we can ignore them if we are not in NBR_STA_SNAP
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.44 2011/05/09 12:24:41 claudio Exp $ */
a26 1
#include <netinet/in_systm.h>
@


1.44
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.43 2011/03/25 08:52:21 claudio Exp $ */
d96 1
@


1.43
log
@Rewrite the lsack generation. Make it more like the lsupdate code.
Removes some of the rather strange packet handling.
Tested by a few especially sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.42 2010/05/26 13:56:08 nicm Exp $ */
d91 1
@


1.42
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.41 2009/08/09 23:04:16 claudio Exp $ */
d160 1
a160 1
int	 send_ls_ack(struct iface *, struct in_addr, void *, size_t);
@


1.41
log
@Scale both receive and send buffer on the raw socket. The default 8192
bytes is not enough for larger networks causing send errors because of
too big packets. OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.40 2009/06/06 07:31:26 eric Exp $ */
d100 1
a100 1
int		 auth_gen(struct buf *, struct iface *);
d236 2
a237 2
int	 gen_ospf_hdr(struct buf *, struct iface *, u_int8_t);
int	 send_packet(struct iface *, struct buf *, struct sockaddr_in *);
@


1.40
log
@sync ospfctl/ospfd with the common imsg code, making it lib ready as well.

"looks ok" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.39 2009/01/31 08:55:00 claudio Exp $ */
d154 1
a154 1
void	 if_set_recvbuf(int);
@


1.39
log
@Pass the buffer to send_packet() instead of spliting it up. This removes
some direct access to struct buf internals in the rest of ospfe.
Based on a larger buffer cleanup diff that was OK norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.38 2007/10/13 13:21:24 claudio Exp $ */
d104 1
a104 1
int		 md_list_send(struct auth_md_head *, struct imsgbuf *);
@


1.38
log
@Funny typo, it is fib not fip so adjust function name.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.37 2007/10/11 08:21:29 claudio Exp $ */
d237 1
a237 1
int	 send_packet(struct iface *, void *, size_t, struct sockaddr_in *);
@


1.37
log
@Do not overload nbr->options with the dd exchange bits. nbr->options is used
by the hello protocol. Instead add a dd_more flag that is used together with
(the renamed) dd_master flag.
Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.36 2007/05/29 22:08:25 claudio Exp $ */
d129 1
a129 1
void		 ospfe_fip_update(int);
@


1.36
log
@Demote support for ospfd. It is possible to specify a demote group on
interfaces and areas. With this carp setups using ospfd are more reliable
because we can fail over if the OSPF connectivity is (partially) lost.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.35 2007/03/21 10:54:30 claudio Exp $ */
d93 2
a94 1
	u_int8_t		 master;
@


1.35
log
@Add support for RFC 3137: OSPF Stub Router Advertisement
This allows ospfd to announce networks without the need to transit traffic.
stub router is enabled if the fib is not coupled, net.inet.ip.forwarding is
not 1 or if the stub router global config option is set to yes.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.34 2007/02/01 12:41:03 claudio Exp $ */
d133 2
@


1.34
log
@Implement md_list_send() function to send auth crypt keys to the OSPF engine.
Needed for reload support. OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.33 2006/11/17 08:55:31 claudio Exp $ */
d128 1
@


1.33
log
@Support for multiple networks on one interface. Until now only the main
address of a interface could be used. Now it is possible to specify a
interface more than once if multiple networks are configured. An alternative
network can be specified via e.g. interface em0:10.0.5.1. The old interface
syntax without the IP still works and uses the main/first configured IP
address.
ospfd now needs to include the IP header on outgoing messages as it is not
possible to specifiy the source address in sendto(2). Additionally all
multicast joins and leaves have to be tracked.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.32 2006/09/27 14:37:38 claudio Exp $ */
d103 1
@


1.32
log
@Use IP_RECVIF to get the incomming interface of OSPF packets. Now we use
the source address and the interface index to find the corresponding
struct interface which is less error prone. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.31 2006/06/02 18:49:55 norby Exp $ */
d135 1
a135 1
struct iface	*if_new(struct kif *);
a147 2
int	 if_set_mcast_ttl(int, u_int8_t);
int	 if_set_tos(int, int);
d151 1
@


1.31
log
@remove unused variable, found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.30 2006/04/25 08:33:00 claudio Exp $ */
d150 1
@


1.30
log
@Use size_t for buffer lenght passed to send_ls_ack() plus an ARGSUSED.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.29 2006/04/25 08:24:45 claudio Exp $ */
d181 1
a181 1
		     void *, u_int16_t);
@


1.29
log
@Kill unused function and add a ARGSUSED.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.28 2006/04/24 20:18:03 claudio Exp $ */
d155 1
a155 1
int	 send_ls_ack(struct iface *, struct in_addr, void *data, int len);
@


1.28
log
@Fix parser to match current behaviour and make auth-type et al. part of the
global and per area defaults. With this it is now possible to define one
set of auth-md keys and use them in every defined interface. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.27 2006/03/13 09:36:06 claudio Exp $ */
a189 1
int		 ls_retrans_list_empty(struct nbr *);
@


1.27
log
@The return value of the start/stop timer functions is almost never checked.
Switch them to void functions and check if evtimer_add/del fails -- in which
case we fatal() as there is no useful way to recover in such an event.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.26 2006/03/09 15:43:21 claudio Exp $ */
d100 3
a102 4
void		 md_list_init(struct iface *);
void		 md_list_add(struct iface *, u_int8_t, char *);
void		 md_list_clr(struct iface *);
struct auth_md	*md_list_find(struct iface *, u_int8_t);
@


1.26
log
@Move *_name functions to log.c and use these for both ospfd and ospfctl.
Stuff that is only used in ospfd debug messages is simplified.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.25 2006/03/09 13:31:57 claudio Exp $ */
d112 2
a113 2
int	 start_db_tx_timer(struct nbr *);
int	 stop_db_tx_timer(struct nbr *);
d164 2
a165 2
int	 start_ls_ack_tx_timer(struct iface *);
int	 stop_ls_ack_tx_timer(struct iface *);
d177 2
a178 2
int	 start_ls_req_tx_timer(struct nbr *);
int	 stop_ls_req_tx_timer(struct nbr *);
d210 3
a212 3
int	 nbr_start_itimer(struct nbr *);
int	 nbr_stop_itimer(struct nbr *);
int	 nbr_reset_itimer(struct nbr *);
d215 1
a215 1
int	 nbr_start_adj_timer(struct nbr *);
@


1.25
log
@Switch send_packet from char * to void * and from int to size_t. The function
is now similar to sendto et al.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.24 2006/02/19 21:48:56 norby Exp $ */
a31 52
/* neighbor states */
#define	NBR_STA_DOWN		0x0001
#define	NBR_STA_ATTEMPT		0x0002
#define	NBR_STA_INIT		0x0004
#define	NBR_STA_2_WAY		0x0008
#define	NBR_STA_XSTRT		0x0010
#define NBR_STA_SNAP		0x0020
#define	NBR_STA_XCHNG		0x0040
#define	NBR_STA_LOAD		0x0080
#define	NBR_STA_FULL		0x0100
#define	NBR_STA_ACTIVE		(~NBR_STA_DOWN)
#define	NBR_STA_FLOOD		(NBR_STA_XCHNG | NBR_STA_LOAD | NBR_STA_FULL)
#define	NBR_STA_ADJFORM		(NBR_STA_XSTRT | NBR_STA_SNAP | NBR_STA_FLOOD)
#define	NBR_STA_BIDIR		(NBR_STA_2_WAY | NBR_STA_ADJFORM)
#define	NBR_STA_PRELIM		(NBR_STA_DOWN | NBR_STA_ATTEMPT | NBR_STA_INIT)
#define	NBR_STA_ANY		0xffff

/* neighbor events */
enum nbr_event {
	NBR_EVT_NOTHING,
	NBR_EVT_HELLO_RCVD,
	NBR_EVT_2_WAY_RCVD,
	NBR_EVT_NEG_DONE,
	NBR_EVT_SNAP_DONE,
	NBR_EVT_XCHNG_DONE,
	NBR_EVT_BAD_LS_REQ,
	NBR_EVT_LOAD_DONE,
	NBR_EVT_ADJ_OK,
	NBR_EVT_SEQ_NUM_MIS,
	NBR_EVT_1_WAY_RCVD,
	NBR_EVT_KILL_NBR,
	NBR_EVT_ITIMER,
	NBR_EVT_LL_DOWN,
	NBR_EVT_ADJTMOUT
};

/* neighbor actions */
enum nbr_action {
	NBR_ACT_NOTHING,
	NBR_ACT_RST_ITIMER,
	NBR_ACT_STRT_ITIMER,
	NBR_ACT_EVAL,
	NBR_ACT_SNAP,
	NBR_ACT_SNAP_DONE,
	NBR_ACT_XCHNG_DONE,
	NBR_ACT_ADJ_OK,
	NBR_ACT_RESTRT_DD,
	NBR_ACT_DEL,
	NBR_ACT_CLR_LST,
	NBR_ACT_HELLO_CHK
};

a145 6
const char	*if_state_name(int);
const char	*if_event_name(int);
const char	*if_action_name(int);
const char	*if_type_name(int);
const char	*if_auth_name(int);

a228 4

const char	*nbr_state_name(int);
const char	*nbr_event_name(int);
const char	*nbr_action_name(int);
@


1.24
log
@Keep track of the duration of our relationships with neighbors.
Displayed in "ospfctl show neighbor".

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.23 2006/02/19 18:55:47 norby Exp $ */
d296 1
a296 1
int	 send_packet(struct iface *, char *, int, struct sockaddr_in *);
@


1.23
log
@Do not traverse the entire LS retransmission list to figure out how many
are present on it.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.22 2006/02/19 18:52:06 norby Exp $ */
d139 1
@


1.22
log
@Do not allocate a new chunk of memory every time we receive a packet.
This should have been fixed ages ago since it really improves the
performance of ospfd.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.21 2006/02/02 15:11:54 norby Exp $ */
d136 1
@


1.21
log
@zap md_list_empty, found by lint.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.20 2005/12/29 13:53:36 claudio Exp $ */
d296 2
@


1.20
log
@Instead of a simple timer per neighbor for the LS retransmition list use
a timewheel. All LSA updates are now first added to the queue and sent out
later. This makes it possible to cluster multiple LSA updates into on OSPF
packet. This gives a massive speedup when large databases need to be synced.
Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.19 2005/12/15 20:29:06 claudio Exp $ */
a152 1
int		 md_list_empty(struct iface *);
@


1.19
log
@Simpify iface_del() and nbr_del(). make them void funtions as they can not fail
and do not remove a element twice in iface_del(). OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.18 2005/12/04 20:49:47 norby Exp $ */
d90 2
a239 1
int		 send_ls_update(struct iface *, struct in_addr, void *, int);
d242 2
a243 1
void		 ls_retrans_list_add(struct nbr *, struct lsa_hdr *);
@


1.18
log
@Increase the receive buffer of the raw socket.

Prevents some of the retransmitting during bulk ls update transfers.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.17 2005/11/04 10:19:16 claudio Exp $ */
d186 1
a186 1
int		 if_del(struct iface *);
d257 1
a257 1
int		 nbr_del(struct nbr *);
@


1.17
log
@Remove unused variable link_state in struct nbr.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.16 2005/10/18 15:40:36 claudio Exp $ */
d206 1
@


1.16
log
@Cleanup interface code a minimal bit. There is no need for if_shutdown(),
especially it got called in the wrong place.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.15 2005/05/26 20:42:10 norby Exp $ */
a136 1
	u_int8_t		 link_state;
@


1.15
log
@Remove unused neighbor state.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.14 2005/04/25 11:31:50 claudio Exp $ */
a188 1
int		 if_shutdown(struct ospfd_conf *);
@


1.14
log
@Call if_init() later and for each interface separately.
Move code from if_act_start() to if_init() that needs to be called only
once per interface. Especially event_set should be called only once as it
initializes struct event and so may cause corruption of the event queue if
called twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.13 2005/04/25 09:55:18 claudio Exp $ */
a52 1
	NBR_EVT_STRT,
a70 1
	NBR_ACT_STRT,
a272 1
int	 nbr_act_start(struct nbr *);
@


1.13
log
@Move the creation of the ospf_socket from if_init() directly into ospfe().
This makes it possible to call if_init() at a much later time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.12 2005/04/12 09:54:59 claudio Exp $ */
d190 1
a190 1
int		 if_init(struct ospfd_conf *);
@


1.12
log
@Support for self originated AS-external LSA.
With "redistribute (static|connected|default|none)" it is possible to
tell ospfd which external routes should be announced.
Connected routes will be announced only if there is no corresponding
interface configured, in that case the prefix is not external.
Adding and removing of announced prefixes are done automaticaly.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.11 2005/04/05 13:01:22 claudio Exp $ */
d208 3
@


1.11
log
@Use the dynamic buffer API for packet generation and sending.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.10 2005/03/31 19:32:10 norby Exp $ */
a247 1

@


1.10
log
@Add support for crypt authentication (MD5).

ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.9 2005/03/22 22:13:48 norby Exp $ */
d150 1
a150 1
int		 auth_gen(void *, u_int16_t, struct iface *);
d294 1
a294 1
void	 gen_ospf_hdr(void *, struct iface *, u_int8_t);
@


1.9
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.8 2005/03/17 21:17:12 claudio Exp $ */
d136 1
d148 8
a155 2
int	 auth_validate(struct ospf_hdr *, const struct iface *);
int	 auth_gen(void *, u_int16_t, const struct iface *);
@


1.8
log
@Handle the retransmission queues correctly. Mainly iface state DROTHER
needs to be handled specially because the backup DR does not send acks and
so his retransmission queue fills up and does not get cleared.
Also implement the retransmission timeout correctly.

OK henning@@ norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.7 2005/03/07 10:28:14 claudio Exp $ */
d143 1
a143 2

	bool			 master;
d210 1
a210 1
bool	 ls_ack_list_empty(struct iface *);
d223 1
a223 1
bool	 ls_req_list_empty(struct nbr *);
d239 1
a239 1
bool		 ls_retrans_list_empty(struct nbr *);
@


1.7
log
@Track interface state (up/down) and media status. Simplify the code a bit
by using the kif/kroute info while allocating interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.6 2005/02/10 14:05:48 claudio Exp $ */
d114 1
d235 1
a235 1
int		 ls_retrans_list_add(struct nbr *, struct lsa_hdr *);
d241 2
@


1.6
log
@Work around a timing issue in the db exchange phase. The DB description
packets comming from the net are looped through the RDE and may get
delayed because of this. The result is that the neighbor FSM ends in
state FULL instead of LOADING and so the LSDB is not correctly
synchronized. Issue found by norby@@ OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.5 2005/02/09 20:47:04 claudio Exp $ */
d137 1
d181 1
a181 1
struct iface	*if_new(char *, unsigned int);
@


1.5
log
@NBR_STA_ACTIVE is just ~NBR_STA_DOWN instead of some hardcoded magic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.4 2005/02/09 20:40:23 claudio Exp $ */
d132 1
a133 1

@


1.4
log
@Rework of self originated LSA. First of all the code to generate the LSA
is rewritten to use the dynamic buffer api introduced lately.
Add missing parts in the RDE to merge these LSA originated from the OE into
the LSDB with correct seq_num, etc.
Add hooks to the neighbor and interface fsm so that the LSA get updated if
needed. This is not perfect, still many things are missing. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.3 2005/02/02 19:15:07 henning Exp $ */
d42 1
a42 1
#define	NBR_STA_ACTIVE		0xfffc
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d174 2
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.h,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d238 1
a238 1
void	 	 lsa_cache_init(u_int32_t);
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2004, 2005 Esben Norby <esben.norby@@ericsson.com>
@

