head	1.83;
access;
symbols
	OPENBSD_6_2:1.83.0.2
	OPENBSD_6_2_BASE:1.83
	OPENBSD_6_1:1.83.0.4
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.81.0.2
	OPENBSD_6_0_BASE:1.81
	OPENBSD_5_9:1.80.0.2
	OPENBSD_5_9_BASE:1.80
	OPENBSD_5_8:1.79.0.6
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.76.0.6
	OPENBSD_5_6_BASE:1.76
	OPENBSD_5_5:1.76.0.4
	OPENBSD_5_5_BASE:1.76
	OPENBSD_5_4:1.74.0.2
	OPENBSD_5_4_BASE:1.74
	OPENBSD_5_3:1.73.0.10
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.73.0.8
	OPENBSD_5_2_BASE:1.73
	OPENBSD_5_1_BASE:1.73
	OPENBSD_5_1:1.73.0.6
	OPENBSD_5_0:1.73.0.4
	OPENBSD_5_0_BASE:1.73
	OPENBSD_4_9:1.73.0.2
	OPENBSD_4_9_BASE:1.73
	OPENBSD_4_8:1.72.0.2
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.70.0.2
	OPENBSD_4_7_BASE:1.70
	OPENBSD_4_6:1.67.0.4
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.65.0.2
	OPENBSD_4_5_BASE:1.65
	OPENBSD_4_4:1.61.0.4
	OPENBSD_4_4_BASE:1.61
	OPENBSD_4_3:1.61.0.2
	OPENBSD_4_3_BASE:1.61
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.43.0.2
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.83
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.82;
commitid	3AKCl24jEn0sIt6p;

1.82
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.81;
commitid	uzjOUwLRoN7KbcZI;

1.81
date	2016.06.21.21.35.25;	author benno;	state Exp;
branches;
next	1.80;
commitid	AL6SnrmnHkmPOpjv;

1.80
date	2015.12.05.12.20.13;	author claudio;	state Exp;
branches;
next	1.79;
commitid	ev1fE7U8gIdVx8OS;

1.79
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.78;
commitid	3Z7yItGpFsmshk0c;

1.78
date	2014.11.03.07.40.31;	author bluhm;	state Exp;
branches;
next	1.77;
commitid	KxzfvwQ64ayFBEwr;

1.77
date	2014.11.02.00.22.00;	author doug;	state Exp;
branches;
next	1.76;
commitid	w6x4TwAlyQVHMuWm;

1.76
date	2014.01.22.00.21.16;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2013.11.25.12.59.34;	author benno;	state Exp;
branches;
next	1.74;

1.74
date	2013.03.06.21.36.57;	author sthen;	state Exp;
branches;
next	1.73;

1.73
date	2010.12.13.13.43.37;	author bluhm;	state Exp;
branches;
next	1.72;

1.72
date	2010.08.03.18.42.41;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2010.03.24.07.18.39;	author gollo;	state Exp;
branches;
next	1.70;

1.70
date	2010.02.16.08.39.05;	author dlg;	state Exp;
branches;
next	1.69;

1.69
date	2010.02.16.08.22.42;	author dlg;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.25.12.55.35;	author dlg;	state Exp;
branches;
next	1.67;

1.67
date	2009.06.05.04.12.52;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2009.03.31.21.03.49;	author tobias;	state Exp;
branches;
next	1.65;

1.65
date	2009.01.26.23.03.28;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.07.21.16.36;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2008.11.24.18.28.02;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2008.10.17.13.02.55;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2008.02.26.10.09.58;	author mpf;	state Exp;
branches;
next	1.60;

1.60
date	2008.02.22.10.56.50;	author simon;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.20.13.29.44;	author pyr;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.16.20.01.23;	author mpf;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.13.16.35.22;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.11.14.39.17;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.11.12.19.31;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.01.08.35.12;	author norby;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.12.09.59.09;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2007.07.11.14.10.25;	author pyr;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.19.16.45.15;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.29.22.08.25;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2007.03.28.14.17.13;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2007.03.22.15.56.52;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2007.03.21.10.54.30;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2007.03.16.10.54.43;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.01.13.25.28;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.14.13.20.17;	author michele;	state Exp;
branches;
next	1.41;

1.41
date	2007.01.11.21.36.49;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2006.12.21.17.22.29;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2006.12.07.19.14.27;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.17.08.55.31;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2006.10.29.19.29.09;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.25.12.26.49;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2006.10.25.12.23.10;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.31.03.59.51;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.31.03.24.06;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.31.02.18.23;	author pat;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.30.22.06.14;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.26.01.06.12;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.24.20.18.03;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.20.17.04.30;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.15.13.29.45;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.15.13.25.33;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.08.15.35.07;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.20.00.01.20;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.05.15.53.36;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.15.20.19.48;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.04.10.15.43;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.30.23.01.38;	author stevesk;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.28.14.51.57;	author stevesk;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.17.20.03.35;	author msf;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.15.20.24.46;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.28.22.35.34;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.26.18.46.16;	author norby;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.23.19.59.02;	author norby;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.12.09.54.59;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.06.20.21.08;	author norby;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.31.19.32.10;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.29.17.26.35;	author norby;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.12.11.03.05;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.12.10.49.12;	author norby;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.07.10.28.14;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.27.08.21.15;	author norby;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.02.21.02.25;	author norby;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.47.20;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.83
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@/*	$OpenBSD: parse.y,v 1.82 2017/01/05 12:42:18 krw Exp $ */

/*
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <unistd.h>
#include <ifaddrs.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>

#include "ospf.h"
#include "ospfd.h"
#include "ospfe.h"
#include "log.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

void		 clear_config(struct ospfd_conf *xconf);
u_int32_t	 get_rtr_id(void);
int		 host(const char *, struct in_addr *, struct in_addr *);

static struct ospfd_conf	*conf;
static int			 errors = 0;

struct area	*area = NULL;
struct iface	*iface = NULL;

struct config_defaults {
	char		auth_key[MAX_SIMPLE_AUTH_LEN];
	struct auth_md_head	 md_list;
	u_int32_t	dead_interval;
	u_int32_t	fast_hello_interval;
	u_int16_t	transmit_delay;
	u_int16_t	hello_interval;
	u_int16_t	rxmt_interval;
	u_int16_t	metric;
	enum auth_type	auth_type;
	u_int8_t	auth_keyid;
	u_int8_t	priority;
};

struct config_defaults	 globaldefs;
struct config_defaults	 areadefs;
struct config_defaults	 ifacedefs;
struct config_defaults	*defs;

struct area	*conf_get_area(struct in_addr);
struct iface	*conf_get_if(struct kif *, struct kif_addr *);
int		 conf_check_rdomain(unsigned int);

typedef struct {
	union {
		int64_t		 number;
		char		*string;
		struct redistribute *redist;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	AREA INTERFACE ROUTERID FIBUPDATE REDISTRIBUTE RTLABEL RDOMAIN
%token	RFC1583COMPAT STUB ROUTER SPFDELAY SPFHOLDTIME EXTTAG
%token	AUTHKEY AUTHTYPE AUTHMD AUTHMDKEYID
%token	METRIC PASSIVE
%token	HELLOINTERVAL FASTHELLOINTERVAL TRANSMITDELAY
%token	RETRANSMITINTERVAL ROUTERDEADTIME ROUTERPRIORITY
%token	SET TYPE
%token	YES NO
%token	MSEC MINIMAL
%token	DEMOTE
%token	INCLUDE
%token	ERROR
%token	<v.string>	STRING
%token	<v.number>	NUMBER
%type	<v.number>	yesno no optlist optlist_l option demotecount msec
%type	<v.number>	deadtime
%type	<v.string>	string
%type	<v.redist>	redistribute

%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar conf_main '\n'
		| grammar varset '\n'
		| grammar area '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 1)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

string		: string STRING	{
			if (asprintf(&$$, "%s %s", $1, $2) == -1) {
				free($1);
				free($2);
				yyerror("string: asprintf");
				YYERROR;
			}
			free($1);
			free($2);
		}
		| STRING
		;

yesno		: YES	{ $$ = 1; }
		| NO	{ $$ = 0; }
		;

no		: /* empty */	{ $$ = 0; }
		| NO		{ $$ = 1; }
		;

msec		: MSEC NUMBER {
			$$ = $2;
		}
		| NUMBER {
			$$ = $1 * 1000;
		}
		;

varset		: STRING '=' string		{
			char *s = $1;
			if (conf->opts & OSPFD_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

conf_main	: ROUTERID STRING {
			if (!inet_aton($2, &conf->rtr_id)) {
				yyerror("error parsing router-id");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| FIBUPDATE yesno {
			if ($2 == 0)
				conf->flags |= OSPFD_FLAG_NO_FIB_UPDATE;
			else
				conf->flags &= ~OSPFD_FLAG_NO_FIB_UPDATE;
		}
		| redistribute {
			SIMPLEQ_INSERT_TAIL(&conf->redist_list, $1, entry);
			conf->redistribute = 1;
		}
		| RTLABEL STRING EXTTAG NUMBER {
			if ($4 < 0 || $4 > UINT_MAX) {
				yyerror("invalid external route tag");
				free($2);
				YYERROR;
			}
			rtlabel_tag(rtlabel_name2id($2), $4);
			free($2);
		}
		| RDOMAIN NUMBER {
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("invalid rdomain");
				YYERROR;
			}
			conf->rdomain = $2;
		}
		| RFC1583COMPAT yesno {
			conf->rfc1583compat = $2;
		}
		| SPFDELAY msec {
			if ($2 < MIN_SPF_DELAY || $2 > MAX_SPF_DELAY) {
				yyerror("spf-delay out of range "
				    "(%d-%d)", MIN_SPF_DELAY,
				    MAX_SPF_DELAY);
				YYERROR;
			}
			conf->spf_delay = $2;
		}
		| SPFHOLDTIME msec {
			if ($2 < MIN_SPF_HOLDTIME || $2 > MAX_SPF_HOLDTIME) {
				yyerror("spf-holdtime out of range "
				    "(%d-%d)", MIN_SPF_HOLDTIME,
				    MAX_SPF_HOLDTIME);
				YYERROR;
			}
			conf->spf_hold_time = $2;
		}
		| STUB ROUTER yesno {
			if ($3)
				conf->flags |= OSPFD_FLAG_STUB_ROUTER;
			else
				/* allow to force non stub mode */
				conf->flags &= ~OSPFD_FLAG_STUB_ROUTER;
		}
		| defaults
		;


redistribute	: no REDISTRIBUTE NUMBER '/' NUMBER optlist {
			struct redistribute	*r;

			if ((r = calloc(1, sizeof(*r))) == NULL)
				fatal(NULL);
			r->type = REDIST_ADDR;
			if ($3 < 0 || $3 > 255 || $5 < 1 || $5 > 32) {
				yyerror("bad network: %llu/%llu", $3, $5);
				free(r);
				YYERROR;
			}
			r->addr.s_addr = htonl($3 << IN_CLASSA_NSHIFT);
			r->mask.s_addr = prefixlen2mask($5);

			if ($1)
				r->type |= REDIST_NO;
			r->metric = $6;
			$$ = r;
		}
		| no REDISTRIBUTE STRING optlist {
			struct redistribute	*r;

			if ((r = calloc(1, sizeof(*r))) == NULL)
				fatal(NULL);
			if (!strcmp($3, "default"))
				r->type = REDIST_DEFAULT;
			else if (!strcmp($3, "static"))
				r->type = REDIST_STATIC;
			else if (!strcmp($3, "connected"))
				r->type = REDIST_CONNECTED;
			else if (host($3, &r->addr, &r->mask))
				r->type = REDIST_ADDR;
			else {
				yyerror("unknown redistribute type");
				free($3);
				free(r);
				YYERROR;
			}

			if ($1)
				r->type |= REDIST_NO;
			r->metric = $4;
			free($3);
			$$ = r;
		}
		| no REDISTRIBUTE RTLABEL STRING optlist {
			struct redistribute	*r;

			if ((r = calloc(1, sizeof(*r))) == NULL)
				fatal(NULL);
			r->type = REDIST_LABEL;
			r->label = rtlabel_name2id($4);
			if ($1)
				r->type |= REDIST_NO;
			r->metric = $5;
			free($4);

			$$ = r;
		}
		;

optlist		: /* empty */ 			{ $$ = DEFAULT_REDIST_METRIC; }
		| SET option			{
			$$ = $2;
			if (($$ & LSA_METRIC_MASK) == 0)
				$$ |= DEFAULT_REDIST_METRIC;
		}
		| SET optnl '{' optnl optlist_l optnl '}'	{
			$$ = $5;
			if (($$ & LSA_METRIC_MASK) == 0)
				$$ |= DEFAULT_REDIST_METRIC;
		}
		;

optlist_l	: optlist_l comma option {
			if ($1 & LSA_ASEXT_E_FLAG && $3 & LSA_ASEXT_E_FLAG) {
				yyerror("redistribute type already defined");
				YYERROR;
			}
			if ($1 & LSA_METRIC_MASK && $3 & LSA_METRIC_MASK) {
				yyerror("redistribute metric already defined");
				YYERROR;
			}
			$$ = $1 | $3;
		}
		| option { $$ = $1; }
		;

option		: METRIC NUMBER {
			if ($2 == 0 || $2 > MAX_METRIC) {
				yyerror("invalid redistribute metric");
				YYERROR;
			}
			$$ = $2;
		}
		| TYPE NUMBER {
			switch ($2) {
			case 1:
				$$ = 0;
				break;
			case 2:
				$$ = LSA_ASEXT_E_FLAG;
				break;
			default:
				yyerror("only external type 1 and 2 allowed");
				YYERROR;
			}
		}
		;

authmd		: AUTHMD NUMBER STRING {
			if ($2 < MIN_MD_ID || $2 > MAX_MD_ID) {
				yyerror("auth-md key-id out of range "
				    "(%d-%d)", MIN_MD_ID, MAX_MD_ID);
				free($3);
				YYERROR;
			}
			if (strlen($3) > MD5_DIGEST_LENGTH) {
				yyerror("auth-md key length out of range "
				    "(max length %d)",
				    MD5_DIGEST_LENGTH);
				free($3);
				YYERROR;
			}
			md_list_add(&defs->md_list, $2, $3);
			free($3);
		}

authmdkeyid	: AUTHMDKEYID NUMBER {
			if ($2 < MIN_MD_ID || $2 > MAX_MD_ID) {
				yyerror("auth-md-keyid out of range "
				    "(%d-%d)", MIN_MD_ID, MAX_MD_ID);
				YYERROR;
			}
			defs->auth_keyid = $2;
		}

authtype	: AUTHTYPE STRING {
			enum auth_type	type;

			if (!strcmp($2, "none"))
				type = AUTH_NONE;
			else if (!strcmp($2, "simple"))
				type = AUTH_SIMPLE;
			else if (!strcmp($2, "crypt"))
				type = AUTH_CRYPT;
			else {
				yyerror("unknown auth-type");
				free($2);
				YYERROR;
			}
			free($2);
			defs->auth_type = type;
		}
		;

authkey		: AUTHKEY STRING {
			if (strlen($2) > MAX_SIMPLE_AUTH_LEN) {
				yyerror("auth-key too long (max length %d)",
				    MAX_SIMPLE_AUTH_LEN);
					free($2);
					YYERROR;
			}
			strncpy(defs->auth_key, $2,
			    sizeof(defs->auth_key));
			free($2);
		}
		;

defaults	: METRIC NUMBER {
			if ($2 < MIN_METRIC || $2 > MAX_METRIC) {
				yyerror("metric out of range (%d-%d)",
				    MIN_METRIC, MAX_METRIC);
				YYERROR;
			}
			defs->metric = $2;
		}
		| ROUTERPRIORITY NUMBER {
			if ($2 < MIN_PRIORITY || $2 > MAX_PRIORITY) {
				yyerror("router-priority out of range (%d-%d)",
				    MIN_PRIORITY, MAX_PRIORITY);
				YYERROR;
			}
			defs->priority = $2;
		}
		| ROUTERDEADTIME deadtime {
			defs->dead_interval = $2;
		}
		| TRANSMITDELAY NUMBER {
			if ($2 < MIN_TRANSMIT_DELAY ||
			    $2 > MAX_TRANSMIT_DELAY) {
				yyerror("transmit-delay out of range (%d-%d)",
				    MIN_TRANSMIT_DELAY, MAX_TRANSMIT_DELAY);
				YYERROR;
			}
			defs->transmit_delay = $2;
		}
		| HELLOINTERVAL NUMBER {
			if ($2 < MIN_HELLO_INTERVAL ||
			    $2 > MAX_HELLO_INTERVAL) {
				yyerror("hello-interval out of range (%d-%d)",
				    MIN_HELLO_INTERVAL, MAX_HELLO_INTERVAL);
				YYERROR;
			}
			defs->hello_interval = $2;
		}
		| FASTHELLOINTERVAL MSEC NUMBER {
			if ($3 < MIN_FAST_INTERVAL ||
			    $3 > MAX_FAST_INTERVAL) {
				yyerror("fast-hello-interval msec out of "
				    "range (%d-%d)", MIN_FAST_INTERVAL,
				    MAX_FAST_INTERVAL);
				YYERROR;
			}
			defs->fast_hello_interval = $3;
		}
		| RETRANSMITINTERVAL NUMBER {
			if ($2 < MIN_RXMT_INTERVAL || $2 > MAX_RXMT_INTERVAL) {
				yyerror("retransmit-interval out of range "
				    "(%d-%d)", MIN_RXMT_INTERVAL,
				    MAX_RXMT_INTERVAL);
				YYERROR;
			}
			defs->rxmt_interval = $2;
		}
		| authtype
		| authkey
		| authmdkeyid
		| authmd
		;

deadtime	: NUMBER {
			if ($1 < MIN_RTR_DEAD_TIME || $1 > MAX_RTR_DEAD_TIME) {
				yyerror("router-dead-time out of range (%d-%d)",
				    MIN_RTR_DEAD_TIME, MAX_RTR_DEAD_TIME);
				YYERROR;
			}
			$$ = $1;
		}
		| MINIMAL {
			$$ = FAST_RTR_DEAD_TIME;
		}

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl		/* one newline or more */
		;

comma		: ','
		| /*empty*/
		;

area		: AREA STRING {
			struct in_addr	id;
			if (inet_aton($2, &id) == 0) {
				yyerror("error parsing area");
				free($2);
				YYERROR;
			}
			free($2);
			area = conf_get_area(id);

			memcpy(&areadefs, defs, sizeof(areadefs));
			md_list_copy(&areadefs.md_list, &defs->md_list);
			defs = &areadefs;
		} '{' optnl areaopts_l '}' {
			area = NULL;
			md_list_clr(&defs->md_list);
			defs = &globaldefs;
		}
		;

demotecount	: NUMBER	{ $$ = $1; }
		| /*empty*/	{ $$ = 1; }
		;

areaopts_l	: areaopts_l areaoptsl nl
		| areaoptsl optnl
		;

areaoptsl	: interface
		| DEMOTE STRING	demotecount {
			if ($3 < 1 || $3 > 255) {
				yyerror("demote count out of range (1-255)");
				free($2);
				YYERROR;
			}
			area->demote_level = $3;
			if (strlcpy(area->demote_group, $2,
			    sizeof(area->demote_group)) >=
			    sizeof(area->demote_group)) {
				yyerror("demote group name \"%s\" too long",
				    $2);
				free($2);
				YYERROR;
			}
			free($2);
			if (carp_demote_init(area->demote_group,
			    conf->opts & OSPFD_OPT_FORCE_DEMOTE) == -1) {
				yyerror("error initializing group \"%s\"",
				    area->demote_group);
				YYERROR;
			}
		}
		| defaults
		| STUB 			{ area->stub = 1; }
		| STUB redistribute {
			area->stub = 1;
			if ($2->type != REDIST_DEFAULT) {
				yyerror("bad redistribute option");
				YYERROR;
			}
			if (!SIMPLEQ_EMPTY(&area->redist_list)) {
				yyerror("area redistribute option only "
				    "allowed once");
				YYERROR;
			}
			SIMPLEQ_INSERT_TAIL(&area->redist_list, $2, entry);
		}
		;

interface	: INTERFACE STRING	{
			struct kif	*kif;
			struct kif_addr	*ka = NULL;
			char		*s;
			struct in_addr	 addr;

			s = strchr($2, ':');
			if (s) {
				*s++ = '\0';
				if (inet_aton(s, &addr) == 0) {
					yyerror(
					    "error parsing interface address");
					free($2);
					YYERROR;
				}
			} else
				addr.s_addr = 0;

			if ((kif = kif_findname($2, addr, &ka)) == NULL) {
				yyerror("unknown interface %s", $2);
				free($2);
				YYERROR;
			}
			if (ka == NULL) {
				if (s)
					yyerror("address %s not configured on "
					    "interface %s", s, $2);
				else
					yyerror("unnumbered interface %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
			iface = conf_get_if(kif, ka);
			if (iface == NULL)
				YYERROR;
			iface->area = area;
			LIST_INSERT_HEAD(&area->iface_list, iface, entry);

			memcpy(&ifacedefs, defs, sizeof(ifacedefs));
			md_list_copy(&ifacedefs.md_list, &defs->md_list);
			defs = &ifacedefs;
		} interface_block {
			iface->dead_interval = defs->dead_interval;
			iface->fast_hello_interval = defs->fast_hello_interval;
			iface->transmit_delay = defs->transmit_delay;
			if (iface->dead_interval == FAST_RTR_DEAD_TIME)
				iface->hello_interval = 0;
			else
				iface->hello_interval = defs->hello_interval;
			iface->rxmt_interval = defs->rxmt_interval;
			iface->metric = defs->metric;
			iface->priority = defs->priority;
			iface->auth_type = defs->auth_type;
			iface->auth_keyid = defs->auth_keyid;
			memcpy(iface->auth_key, defs->auth_key,
			    sizeof(iface->auth_key));
			md_list_copy(&iface->auth_md_list, &defs->md_list);
			md_list_clr(&defs->md_list);
			iface = NULL;
			/* interface is always part of an area */
			defs = &areadefs;
		}
		;

interface_block	: '{' optnl interfaceopts_l '}'
		| '{' optnl '}'
		|
		;

interfaceopts_l	: interfaceopts_l interfaceoptsl nl
		| interfaceoptsl optnl
		;

interfaceoptsl	: PASSIVE		{ iface->passive = 1; }
		| DEMOTE STRING		{
			if (strlcpy(iface->demote_group, $2,
			    sizeof(iface->demote_group)) >=
			    sizeof(iface->demote_group)) {
				yyerror("demote group name \"%s\" too long",
				    $2);
				free($2);
				YYERROR;
			}
			free($2);
			if (carp_demote_init(iface->demote_group,
			    conf->opts & OSPFD_OPT_FORCE_DEMOTE) == -1) {
				yyerror("error initializing group \"%s\"",
				    iface->demote_group);
				YYERROR;
			}
		}
		| defaults
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{"area",		AREA},
		{"auth-key",		AUTHKEY},
		{"auth-md",		AUTHMD},
		{"auth-md-keyid",	AUTHMDKEYID},
		{"auth-type",		AUTHTYPE},
		{"demote",		DEMOTE},
		{"external-tag",	EXTTAG},
		{"fast-hello-interval",	FASTHELLOINTERVAL},
		{"fib-update",		FIBUPDATE},
		{"hello-interval",	HELLOINTERVAL},
		{"include",		INCLUDE},
		{"interface",		INTERFACE},
		{"metric",		METRIC},
		{"minimal",		MINIMAL},
		{"msec",		MSEC},
		{"no",			NO},
		{"passive",		PASSIVE},
		{"rdomain",		RDOMAIN},
		{"redistribute",	REDISTRIBUTE},
		{"retransmit-interval",	RETRANSMITINTERVAL},
		{"rfc1583compat",	RFC1583COMPAT},
		{"router",		ROUTER},
		{"router-dead-time",	ROUTERDEADTIME},
		{"router-id",		ROUTERID},
		{"router-priority",	ROUTERPRIORITY},
		{"rtlabel",		RTLABEL},
		{"set",			SET},
		{"spf-delay",		SPFDELAY},
		{"spf-holdtime",	SPFHOLDTIME},
		{"stub",		STUB},
		{"transmit-delay",	TRANSMITDELAY},
		{"type",		TYPE},
		{"yes",			YES}
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		log_warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("malloc");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

struct ospfd_conf *
parse_config(char *filename, int opts)
{
	struct sym	*sym, *next;

	if ((conf = calloc(1, sizeof(struct ospfd_conf))) == NULL)
		fatal("parse_config");
	conf->opts = opts;
	if (conf->opts & OSPFD_OPT_STUB_ROUTER)
		conf->flags |= OSPFD_FLAG_STUB_ROUTER;

	bzero(&globaldefs, sizeof(globaldefs));
	defs = &globaldefs;
	TAILQ_INIT(&defs->md_list);
	defs->dead_interval = DEFAULT_RTR_DEAD_TIME;
	defs->fast_hello_interval = DEFAULT_FAST_INTERVAL;
	defs->transmit_delay = DEFAULT_TRANSMIT_DELAY;
	defs->hello_interval = DEFAULT_HELLO_INTERVAL;
	defs->rxmt_interval = DEFAULT_RXMT_INTERVAL;
	defs->metric = DEFAULT_METRIC;
	defs->priority = DEFAULT_PRIORITY;

	conf->spf_delay = DEFAULT_SPF_DELAY;
	conf->spf_hold_time = DEFAULT_SPF_HOLDTIME;
	conf->spf_state = SPF_IDLE;

	if ((file = pushfile(filename, !(conf->opts & OSPFD_OPT_NOACTION))) == NULL) {
		free(conf);
		return (NULL);
	}
	topfile = file;

	LIST_INIT(&conf->area_list);
	LIST_INIT(&conf->cand_list);
	SIMPLEQ_INIT(&conf->redist_list);

	yyparse();
	errors = file->errors;
	popfile();

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if ((conf->opts & OSPFD_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	/* free global config defaults */
	md_list_clr(&globaldefs.md_list);

	/* check that all interfaces belong to the configured rdomain */
	errors += conf_check_rdomain(conf->rdomain);

	if (errors) {
		clear_config(conf);
		return (NULL);
	}

	if (conf->rtr_id.s_addr == 0)
		conf->rtr_id.s_addr = get_rtr_id();

	return (conf);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

struct area *
conf_get_area(struct in_addr id)
{
	struct area	*a;

	a = area_find(conf, id);
	if (a)
		return (a);
	a = area_new();
	LIST_INSERT_HEAD(&conf->area_list, a, entry);

	a->id.s_addr = id.s_addr;

	return (a);
}

struct iface *
conf_get_if(struct kif *kif, struct kif_addr *ka)
{
	struct area	*a;
	struct iface	*i;

	LIST_FOREACH(a, &conf->area_list, entry)
		LIST_FOREACH(i, &a->iface_list, entry)
			if (i->ifindex == kif->ifindex &&
			    i->addr.s_addr == ka->addr.s_addr) {
				yyerror("interface %s already configured",
				    kif->ifname);
				return (NULL);
			}

	i = if_new(kif, ka);
	i->auth_keyid = 1;

	return (i);
}

int
conf_check_rdomain(unsigned int rdomain)
{
	struct area	*a;
	struct iface	*i;
	int		 errs = 0;

	LIST_FOREACH(a, &conf->area_list, entry)
		LIST_FOREACH(i, &a->iface_list, entry)
			if (i->rdomain != rdomain) {
				logit(LOG_CRIT,
				    "interface %s not in rdomain %u",
				    i->name, rdomain);
				errs++;
			}

	return (errs);
}

void
clear_config(struct ospfd_conf *xconf)
{
	struct area	*a;

	while ((a = LIST_FIRST(&xconf->area_list)) != NULL) {
		LIST_REMOVE(a, entry);
		area_del(a);
	}

	free(xconf);
}

u_int32_t
get_rtr_id(void)
{
	struct ifaddrs		*ifap, *ifa;
	u_int32_t		 ip = 0, cur, localnet;

	localnet = htonl(INADDR_LOOPBACK & IN_CLASSA_NET);

	if (getifaddrs(&ifap) == -1)
		fatal("getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (strncmp(ifa->ifa_name, "carp", 4) == 0)
			continue;
		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;
		cur = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
		if ((cur & localnet) == localnet)	/* skip 127/8 */
			continue;
		if (ntohl(cur) < ntohl(ip) || ip == 0)
			ip = cur;
	}
	freeifaddrs(ifap);

	if (ip == 0)
		fatal("router-id is 0.0.0.0");

	return (ip);
}

int
host(const char *s, struct in_addr *addr, struct in_addr *mask)
{
	struct in_addr		 ina;
	int			 bits = 32;

	bzero(&ina, sizeof(struct in_addr));
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (0);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (0);
	}

	addr->s_addr = ina.s_addr;
	mask->s_addr = prefixlen2mask(bits);

	return (1);
}
@


1.82
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.81 2016/06/21 21:35:25 benno Exp $ */
d1129 1
a1129 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.81
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.80 2015/12/05 12:20:13 claudio Exp $ */
d1164 4
a1167 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d1226 1
a1226 1
	TAILQ_FOREACH(sym, &symhead, entry)
d1231 1
@


1.80
log
@Pledge ospfd SE ("stdio inet mcast") and RDE ("stdio") move some code
around to make it possible. Parent can't be pledged at the moment because
of carp ioctl (carp demote). Putting it in so that people can test.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.79 2014/11/20 05:51:20 jsg Exp $ */
d198 1
d201 7
@


1.79
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.78 2014/11/03 07:40:31 bluhm Exp $ */
d110 1
d1137 3
d1260 19
@


1.78
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.77 2014/11/02 00:22:00 doug Exp $ */
d930 3
@


1.77
log
@Add gcc format attributes to parse.y for ospf{6,}d.

Fix a few yyerror() lines that are missing arguments.

ok claudio@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.76 2014/01/22 00:21:16 henning Exp $ */
d701 1
a701 1
	char		*nfmt;
d705 2
a706 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d708 2
a709 1
	free(nfmt);
@


1.76
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.74 2013/03/06 21:36:57 sthen Exp $ */
d59 3
a61 1
int		 yyerror(const char *, ...);
d565 2
a566 1
				yyerror("demote group name \"%s\" too long");
d674 2
a675 1
				yyerror("demote group name \"%s\" too long");
@


1.75
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d1018 2
a1019 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
@


1.74
log
@sync yyerror() with version in bgpd so that it logs to syslog when daemonized.
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.73 2010/12/13 13:43:37 bluhm Exp $ */
d767 1
a767 1
char	*parsebuf;
d769 1
a769 1
char	 pushback_buffer[MAXPUSHBACK];
d862 2
a863 2
	char	 buf[8096];
	char	*p, *val;
d886 1
a886 1
				*p++ = (char)c;
d931 1
a931 1
			*p++ = (char)c;
@


1.73
log
@Do not use a carp address as ospf router id because it is not unique.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.72 2010/08/03 18:42:41 henning Exp $ */
d39 1
d696 2
a697 1
	va_list	ap;
d701 3
a703 3
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
d705 1
@


1.72
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.71 2010/03/24 07:18:39 gollo Exp $ */
d1273 2
@


1.71
log
@options must be sorted.

OK: henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.70 2010/02/16 08:39:05 dlg Exp $ */
d915 2
a916 1
				else if (next == '\n')
d918 1
a918 1
				else
@


1.70
log
@implement support for fast hello packets.

if route-dead-time is set to "minimal" (rather than a number of
seconds), the dead time is set to 1 second and hellos are sent at
the interval specified by fast-hello-interval in msecs. this is non
standard wrt to the ospf rfc, but it does interoperate with at least
one other router vendor.

this allows much better responsiveness to l3 topology changes than
the standard intervals allow. if i yank a cable to one of my
upstreams, the routes adjust in a second rather than the default
of 40 i was running with before. the users dont even notice something
changed.

developed while working with joshua atterbury.
ok claudio@@ as part of a larger diff.
dedicated to zan rowe who thinks she is a bigger nerd than me.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.69 2010/02/16 08:22:42 dlg Exp $ */
d724 1
a725 1
		{"fast-hello-interval",	FASTHELLOINTERVAL},
@


1.69
log
@allow spf-delay and spf-holdtime to be specified in msec so ospfd can
better respond to rapid topology changes.

developed while working with joshua atterbury
ok claudio@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.68 2009/11/25 12:55:35 dlg Exp $ */
d90 1
d123 1
a123 1
%token	HELLOINTERVAL TRANSMITDELAY
d127 1
a127 1
%token	MSEC
d134 1
d454 1
a454 6
		| ROUTERDEADTIME NUMBER {
			if ($2 < MIN_RTR_DEAD_TIME || $2 > MAX_RTR_DEAD_TIME) {
				yyerror("router-dead-time out of range (%d-%d)",
				    MIN_RTR_DEAD_TIME, MAX_RTR_DEAD_TIME);
				YYERROR;
			}
d475 10
d500 12
d635 1
d637 4
a640 1
			iface->hello_interval = defs->hello_interval;
d725 1
d730 1
d1083 1
@


1.68
log
@add support for include

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.66 2009/03/31 21:03:49 tobias Exp $ */
d126 1
d132 1
a132 1
%type	<v.number>	yesno no optlist optlist_l option demotecount
d183 8
d238 1
a238 1
		| SPFDELAY NUMBER {
d247 1
a247 1
		| SPFHOLDTIME NUMBER {
d706 1
@


1.67
log
@Preliminary rdomain support, all hacked up by reyk@@
@
text
@d127 1
d138 1
d146 15
d694 1
@


1.66
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.65 2009/01/26 23:03:28 claudio Exp $ */
d118 1
a118 1
%token	AREA INTERFACE ROUTERID FIBUPDATE REDISTRIBUTE RTLABEL
d202 7
d681 1
@


1.65
log
@First convert IP addresses to host-byte-order before checking which one is
smaller. Additionally fix the check to find the lowest configured IP as
suggested by the RFC. Found with stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.64 2009/01/07 21:16:36 claudio Exp $ */
d965 1
a965 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d967 5
@


1.64
log
@Full stub area support. This allows ABRs to announce a default network
summary LSA into stub areas so that these routers are able to reach the
outside of the area.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.63 2008/11/24 18:28:02 claudio Exp $ */
d1211 1
a1211 1
		if (cur > ip || ip == 0)
@


1.63
log
@Initial support for stub areas. The bit still missing is the redistribution
of the default summary net lsa on ABRs but that is comming. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2008/10/17 13:02:55 henning Exp $ */
d111 1
d132 1
d189 3
a191 72
		| no REDISTRIBUTE NUMBER '/' NUMBER optlist {
			struct redistribute	*r;

			if ((r = calloc(1, sizeof(*r))) == NULL)
				fatal(NULL);
			r->type = REDIST_ADDR;
			if ($3 < 0 || $3 > 255 || $5 < 1 || $5 > 32) {
				yyerror("bad network: %llu/%llu", $3, $5);
				free(r);
				YYERROR;
			}
			r->addr.s_addr = htonl($3 << IN_CLASSA_NSHIFT);
			r->mask.s_addr = prefixlen2mask($5);

			if ($1)
				r->type |= REDIST_NO;
			r->metric = $6;

			SIMPLEQ_INSERT_TAIL(&conf->redist_list, r, entry);
			conf->redistribute |= REDISTRIBUTE_ON;
		}
		| no REDISTRIBUTE STRING optlist {
			struct redistribute	*r;

			if (!strcmp($3, "default")) {
				if (!$1)
					conf->redistribute |=
					    REDISTRIBUTE_DEFAULT;
				else
					conf->redistribute &=
					    ~REDISTRIBUTE_DEFAULT;
				conf->defaultmetric = $4;
			} else {
				if ((r = calloc(1, sizeof(*r))) == NULL)
					fatal(NULL);
				if (!strcmp($3, "static"))
					r->type = REDIST_STATIC;
				else if (!strcmp($3, "connected"))
					r->type = REDIST_CONNECTED;
				else if (host($3, &r->addr, &r->mask))
					r->type = REDIST_ADDR;
				else {
					yyerror("unknown redistribute type");
					free($3);
					free(r);
					YYERROR;
				}

				if ($1)
					r->type |= REDIST_NO;
				r->metric = $4;

				SIMPLEQ_INSERT_TAIL(&conf->redist_list, r,
				    entry);
			}
			conf->redistribute |= REDISTRIBUTE_ON;
			free($3);
		}
		| no REDISTRIBUTE RTLABEL STRING optlist {
			struct redistribute	*r;

			if ((r = calloc(1, sizeof(*r))) == NULL)
				fatal(NULL);
			r->type = REDIST_LABEL;
			r->label = rtlabel_name2id($4);
			if ($1)
				r->type |= REDIST_NO;
			r->metric = $5;
			free($4);

			SIMPLEQ_INSERT_TAIL(&conf->redist_list, r, entry);
			conf->redistribute |= REDISTRIBUTE_ON;
d233 62
d523 14
a536 1
		| STUB			{ area->stub = 1; }
@


1.62
log
@bring in the findeol() fix from pfctl. list of affected parsers by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.61 2008/02/26 10:09:58 mpf Exp $ */
d528 1
@


1.61
log
@Have popfile() also close the main config file,
but only do the final popfile call after yyparse() is done.
This also fixes config reload on SIGHUP for some daemons.

Spotted by otto@@. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2008/02/22 10:56:50 simon Exp $ */
a768 1
	pushback_index = 0;
d772 4
a775 1
		c = lgetc(0);
@


1.60
log
@remove comma from type list, add missing semicolon for consistency

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2007/11/12 23:59:41 mpf Exp $ */
d52 1
a52 1
} *file;
d720 3
a722 2
			yyerror("reached end of file while parsing quoted string");
			if (popfile() == EOF)
d740 1
a740 1
		if (popfile() == EOF)
d981 1
a981 1
	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
d983 7
a989 8
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
d1021 1
@


1.59
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2007/10/20 13:29:44 pyr Exp $ */
d129 1
a129 1
%type	<v.number>	yesno no optlist, optlist_l option demotecount
d161 1
@


1.58
log
@forgot about ospfd in last commit.
ok hennin@@ too.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2007/10/16 20:01:23 mpf Exp $ */
a735 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d792 1
a792 1
	while ((c = lgetc(0)) == ' ')
@


1.57
log
@Allow '=' to end a number in all lexers.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2007/10/16 06:06:49 deraadt Exp $ */
d961 2
a962 1
	    (nfile->name = strdup(name)) == NULL)
d964 1
d966 1
a1024 1
		warn("%s", filename);
@


1.56
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2007/10/13 16:35:22 deraadt Exp $ */
d870 1
a870 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.55
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2007/10/11 14:39:17 deraadt Exp $ */
d847 1
a847 1
				if (next == quotec)
d849 2
@


1.54
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2007/10/11 12:19:31 claudio Exp $ */
d27 1
d33 1
d45 35
a80 2
static FILE			*fin = NULL;
static int			 lineno = 1;
a81 1
char				*infile;
a85 13
int	 yyerror(const char *, ...);
int	 yyparse(void);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(int);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);
void	 clear_config(struct ospfd_conf *xconf);
int	 check_file_secrecy(int fd, const char *fname);
u_int32_t	get_rtr_id(void);
int	 host(const char *, struct in_addr *, struct in_addr *);

d104 2
a105 13
TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entries;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};

int			 symset(const char *, const char *, int);
char			*symget(const char *);
struct area		*conf_get_area(struct in_addr);
struct iface		*conf_get_if(struct kif *, struct kif_addr *);
d139 1
a139 1
		| grammar error '\n'		{ errors++; }
d631 1
a631 1
	errors = 1;
d633 1
a633 1
	fprintf(stderr, "%s:%d: ", infile, yylval.lineno);
a642 1

d699 1
a699 1
lgetc(int inquot)
d701 1
a701 2
	int	c, next;
	FILE *f = fin;
d717 7
a723 2
	if (inquot) {
		c = getc(f);
d727 2
a728 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d733 2
a734 2
		yylval.lineno = lineno;
		lineno++;
d739 1
a739 1
			c = getc(f);
d741 1
a741 1
		ungetc(c, f);
d745 5
d781 1
a781 1
			lineno++;
d795 1
a795 1
	int	 endc, next, c;
d803 1
a803 1
	yylval.lineno = lineno;
d837 1
a837 1
		endc = c;
d839 1
a839 1
			if ((c = lgetc(1)) == EOF)
d842 1
a842 1
				lineno++;
d845 1
a845 1
				if ((next = lgetc(1)) == EOF)
d847 1
a847 1
				if (next == endc)
d851 1
a851 1
			} else if (c == endc) {
d925 2
a926 2
		yylval.lineno = lineno;
		lineno++;
d933 61
d1001 3
d1019 1
a1019 1
	if ((fin = fopen(filename, "r")) == NULL) {
a1023 1
	infile = filename;
a1024 3
	conf->opts = opts;
	if (conf->opts & OSPFD_OPT_STUB_ROUTER)
		conf->flags |= OSPFD_FLAG_STUB_ROUTER;
a1028 7
	if (!(conf->opts & OSPFD_OPT_NOACTION))
		if (check_file_secrecy(fileno(fin), filename)) {
			fclose(fin);
			free(conf);
			return (NULL);
		}

d1030 2
a1031 2

	fclose(fin);
d1035 1
a1035 1
		next = TAILQ_NEXT(sym, entries);
d1042 1
a1042 1
			TAILQ_REMOVE(&symhead, sym, entries);
d1067 1
a1067 1
	    sym = TAILQ_NEXT(sym, entries))
d1076 1
a1076 1
			TAILQ_REMOVE(&symhead, sym, entries);
d1096 1
a1096 1
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d1127 1
a1127 1
	TAILQ_FOREACH(sym, &symhead, entries)
@


1.53
log
@Bye bye global ospf options. OSPF options are per area (at least the one
flag that we set). So introduce a area_ospf_options() function that will
return the correct flags for each area. This makes stub area support a lot
easier.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2007/10/01 08:35:12 norby Exp $ */
d56 1
a56 1
int	 lgetc(FILE *);
d690 1
a690 1
lgetc(FILE *f)
d693 1
d709 5
d761 1
a761 1
		c = lgetc(fin);
d777 1
a777 1
	int	 endc, c;
d782 1
a782 1
	while ((c = lgetc(fin)) == ' ')
d787 1
a787 1
		while ((c = lgetc(fin)) != '\n' && c != EOF)
d791 1
a791 1
			if ((c = lgetc(fin)) == EOF)
d821 1
a821 1
			if ((c = lgetc(fin)) == EOF)
a822 4
			if (c == endc) {
				*p = '\0';
				break;
			}
d826 10
d845 1
a845 1
			errx(1, "yylex: strdup");
d859 1
a859 1
		} while ((c = lgetc(fin)) != EOF && isdigit(c));
d867 2
a868 2
			yylval.v.number = strtonum(buf, LLONG_MIN, LLONG_MAX,
			    &errstr);
d870 2
a871 2
				yyerror("\"%s\" invalid number: %s", buf,
				    errstr);
d898 1
a898 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
@


1.52
log
@fix alot of whitespace problems...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2007/09/12 09:59:09 claudio Exp $ */
a920 1
	conf->options = OSPF_OPTION_E;
@


1.51
log
@Another parser.y that switches to parse numbers directly in the lexer.
Most complex part was "redistribute 10/8" which need special handling.
With and OK deraadt@@, OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2007/07/11 14:10:25 pyr Exp $ */
d855 2
a856 1
			yylval.v.number = strtonum(buf, LLONG_MIN, LLONG_MAX, &errstr);
d858 2
a859 1
				yyerror("\"%s\" invalid number: %s", buf, errstr);
@


1.50
log
@make the demote count argument optional as advertised in the man page.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2007/06/19 16:45:15 reyk Exp $ */
d99 1
a99 1
		u_int32_t	 number;
d118 2
a119 1
%type	<v.number>	number yesno no optlist, optlist_l option demotecount
a131 15
number		: STRING {
			u_int32_t	 uval;
			const char	*errstr;

			uval = strtonum($1, 0, UINT_MAX, &errstr);
			if (errstr) {
				yyerror("number %s is %s", $1, errstr);
				free($1);
				YYERROR;
			} else
				$$ = uval;
			free($1);
		}
		;

d176 21
d249 2
a250 2
		| RTLABEL STRING EXTTAG number {
			if (!$4) {
d261 1
a261 1
		| SPFDELAY number {
d270 1
a270 1
		| SPFHOLDTIME number {
d316 1
a316 1
option		: METRIC number {
d323 1
a323 1
		| TYPE number {
d332 1
a332 1
				yyerror("illegal external type %u", $2);
d338 1
a338 1
authmd		: AUTHMD number STRING {
d356 1
a356 1
authmdkeyid	: AUTHMDKEYID number {
d397 1
a397 1
defaults	: METRIC number {
d405 1
a405 1
		| ROUTERPRIORITY number {
d413 1
a413 1
		| ROUTERDEADTIME number {
d421 1
a421 1
		| TRANSMITDELAY number {
d430 1
a430 1
		| HELLOINTERVAL number {
d439 1
a439 1
		| RETRANSMITINTERVAL number {
d485 1
a485 1
demotecount	: number	{ $$ = $1; }
d495 2
a496 2
			if ($3 > 255) {
				yyerror("demote count too big: max 255");
d835 34
@


1.49
log
@add support for mapping route labels to AS-external route tags.

manpage bits from jmc@@
ok norby@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2007/05/29 22:08:25 claudio Exp $ */
d118 1
a118 1
%type	<v.number>	number yesno no optlist, optlist_l option
d478 4
d487 1
a487 1
		| DEMOTE STRING	number	{
@


1.48
log
@Demote support for ospfd. It is possible to specify a demote group on
interfaces and areas. With this carp setups using ospfd are more reliable
because we can fail over if the OSPF connectivity is (partially) lost.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2007/03/28 14:17:13 claudio Exp $ */
d108 1
a108 1
%token	RFC1583COMPAT STUB ROUTER SPFDELAY SPFHOLDTIME
d242 9
d637 1
@


1.47
log
@Remove unused variable found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2007/03/22 15:56:52 claudio Exp $ */
d115 1
d474 22
d570 16
d627 1
@


1.46
log
@Somehow I forgot how to correctly sort in alphabetical order.
"router" needs to be added before "router-dead-time".
Figured out by Stuart Henderson
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2007/03/21 10:54:30 claudio Exp $ */
a47 1
char				*start_state;
@


1.45
log
@Add support for RFC 3137: OSPF Stub Router Advertisement
This allows ospfd to announce networks without the need to transit traffic.
stub router is enabled if the fib is not coupled, net.inet.ip.forwarding is
not 1 or if the stub router global config option is set to yes.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2007/03/16 10:54:43 claudio Exp $ */
d598 1
a599 1
		{"router",		ROUTER},
@


1.44
log
@Make sure that the metric on redistributed prefixes is always != 0.
If no metric was specified for it to DEFAULT_REDIST_METRIC. While this was
checked for the simple case it was not done if only a metric type was
specified.  OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2007/02/01 13:25:28 claudio Exp $ */
d109 1
a109 1
%token	RFC1583COMPAT SPFDELAY SPFHOLDTIME
d263 7
d599 1
d606 1
d838 2
@


1.43
log
@whitespace cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2007/01/14 13:20:17 michele Exp $ */
d267 10
a276 2
		| SET option			{ $$ = $2; }
		| SET optnl '{' optnl optlist_l optnl '}'	{ $$ = $5; }
@


1.42
log
@typo
metricr -> metric
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2007/01/11 21:36:49 claudio Exp $ */
d267 1
a267 1
		| SET option 			{ $$ = $2; }
@


1.41
log
@Join two lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2006/12/21 17:22:29 claudio Exp $ */
d277 1
a277 1
				yyerror("redistribute metricr already defined");
@


1.40
log
@Unbreak redistribute default and make it possible to specify a metric for
the default route as well. OK norby@@, michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2006/12/07 19:14:27 claudio Exp $ */
d499 1
a499 2
			LIST_INSERT_HEAD(&area->iface_list,
			    iface, entry);
@


1.39
log
@Make it possible to set the metric and LSA type for redistributed routes.
Mostly based on a diff by Pierre-Yves Ritschard (I just simplified the parser
code). OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2006/11/17 08:55:31 claudio Exp $ */
d194 7
a200 7
				conf->redistribute |= REDISTRIBUTE_DEFAULT;
				if ($1) {
					yyerror("cannot use 'no' with "
					    "redistribute default");
					free($3);
					YYERROR;
				}
@


1.38
log
@Support for multiple networks on one interface. Until now only the main
address of a interface could be used. Now it is possible to specify a
interface more than once if multiple networks are configured. An alternative
network can be specified via e.g. interface em0:10.0.5.1. The old interface
syntax without the IP still works and uses the main/first configured IP
address.
ospfd now needs to include the IP header on outgoing messages as it is not
possible to specifiy the source address in sendto(2). Additionally all
multicast joins and leaves have to be tracked.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2006/10/29 19:29:09 claudio Exp $ */
d114 1
d118 1
a118 1
%type	<v.number>	number yesno no
d190 1
a190 1
		| no REDISTRIBUTE STRING {
d219 1
a225 1

d227 1
a227 1
		| no REDISTRIBUTE RTLABEL STRING {
d236 1
d266 41
d430 4
d588 1
d592 1
a1036 1

@


1.37
log
@Allow braces to fit on a single line if only one or no argument is used.
This allows construct like these:
area 0.0.0.1 {
        interface lo0
        interface em1 { passive }
}

From Pierre-Yves Ritschard
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2006/10/25 12:26:49 claudio Exp $ */
d96 1
a96 1
struct iface		*conf_get_if(struct kif *);
d416 16
a431 1
			struct kif *kif;
d433 1
a433 1
			if ((kif = kif_findname($2)) == NULL) {
d438 9
d448 1
a448 1
			iface = conf_get_if(kif);
d907 1
a907 1
conf_get_if(struct kif *kif)
d914 2
a915 1
			if (i->ifindex == kif->ifindex) {
d921 1
a921 1
	i = if_new(kif);
@


1.36
log
@Remove a parser debug functionality that was never used in ospfd.
From Pierre-Yves Ritschard
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2006/10/25 12:23:10 claudio Exp $ */
d407 2
a408 2
areaopts_l	: areaopts_l areaoptsl
		| areaoptsl
d411 2
a412 2
areaoptsl	: interface nl
		| defaults nl
d458 2
a459 2
interfaceopts_l	: interfaceopts_l interfaceoptsl
		| interfaceoptsl
d462 2
a463 2
interfaceoptsl	: PASSIVE nl		{ iface->passive = 1; }
		| defaults nl
@


1.35
log
@Use strtonum(3) instead of the hand made atoul. This solves an issue with
possible integer truncation because of the use of u_longs and u_int32_t in
the code. Initial diff by Pierre-Yves Ritschard but slightly modified version
commited.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2006/05/31 03:59:51 claudio Exp $ */
a46 1
static int			 pdebug = 1;
d527 1
a527 3
	if (p) {
		if (pdebug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
d529 1
a529 3
	} else {
		if (pdebug > 1)
			fprintf(stderr, "string: %s\n", s);
a530 1
	}
@


1.34
log
@Support for "[no] redistribute 10.6/16", all routes that match into this
range will match this "rule". This should be it, now it is time to write
some documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2006/05/31 03:24:06 claudio Exp $ */
a95 1
int			 atoul(char *, u_long *);
d132 2
a133 1
			u_long	ulval;
d135 3
a137 2
			if (atoul($1, &ulval) == -1) {
				yyerror("%s is not a number", $1);
d141 1
a141 1
				$$ = ulval;
a869 16
}

int
atoul(char *s, u_long *ulvalp)
{
	u_long	 ulval;
	char	*ep;

	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
		return (-1);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (-1);
	*ulvalp = ulval;
	return (0);
@


1.33
log
@More redistribute fun. Add a possibility to deny redistribution of specified
routes via "no redistribute rtlabel admin". Redistribute rules are parsed
in order and the first match is used. Only exception is "redistribute default"
Which is independent of the other rules and can't be negated.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2006/05/31 02:18:23 pat Exp $ */
d65 1
d207 2
d963 22
@


1.32
log
@Plug memory leak; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2006/05/30 22:06:14 claudio Exp $ */
d115 1
d118 1
a118 1
%type	<v.number>	number yesno
d157 2
a158 11
yesno		: STRING {
			if (!strcmp($1, "yes"))
				$$ = 1;
			else if (!strcmp($1, "no"))
				$$ = 0;
			else {
				free($1);
				YYERROR;
			}
			free($1);
		}
d161 3
d188 1
a188 1
		| REDISTRIBUTE STRING {
d191 1
a191 1
			if (!strcmp($2, "default"))
d193 7
a199 1
			else {
d202 1
a202 1
				if (!strcmp($2, "static"))
d204 1
a204 1
				else if (!strcmp($2, "connected"))
d208 1
a208 1
					free($2);
d213 3
d220 1
a220 1
			free($2);
d223 1
a223 1
		| REDISTRIBUTE RTLABEL STRING {
d229 4
a232 2
			r->label = rtlabel_name2id($3);
			free($3);
d505 1
d516 2
a517 1
		{"transmit-delay",	TRANSMITDELAY}
@


1.31
log
@Now that rtlabels are accessable via sysctl we can use route lables to
define which routes should be redistributed via OSPF. So now you can
define the export list on a fine graded basis. More to come... OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2006/05/26 01:06:12 deraadt Exp $ */
a210 1
				free($2);
d216 1
@


1.30
log
@\<char> is <char> except for \<newline> -- no exceptions.  much like how
other things work.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2006/04/24 20:18:03 claudio Exp $ */
d109 1
a109 1
%token	AREA INTERFACE ROUTERID FIBUPDATE REDISTRIBUTE
d194 4
a197 11
			if (!strcmp($2, "static"))
				conf->redistribute_flags |=
				    REDISTRIBUTE_STATIC;
			else if (!strcmp($2, "connected"))
				conf->redistribute_flags |=
				    REDISTRIBUTE_CONNECTED;
			else if (!strcmp($2, "default"))
				conf->redistribute_flags |=
				    REDISTRIBUTE_DEFAULT;
			else if (!strcmp($2, "none"))
				conf->redistribute_flags = 0;
d199 12
a210 1
				yyerror("unknown redistribute type");
d212 3
a214 1
				YYERROR;
d216 14
a229 1
			free($2);
d506 1
d717 2
a718 4
	if ((conf = calloc(1, sizeof(struct ospfd_conf))) == NULL) {
		errx(1, "parse_config calloc");
		return (NULL);
	}
d744 2
@


1.29
log
@Fix parser to match current behaviour and make auth-type et al. part of the
global and per area defaults. With this it is now possible to define one
set of auth-md keys and use them in every defined interface. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2006/04/20 17:04:30 claudio Exp $ */
d536 1
a536 3
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, f);
@


1.28
log
@Simplify the defaults handling. This is long overdue and necessary to add
auth-type et al. to the main and area blocks. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2006/03/15 13:29:45 claudio Exp $ */
d67 2
d74 2
d250 1
a250 1
			md_list_add(iface, $2, $3);
d260 1
a260 1
			iface->auth_keyid = $2;
d278 1
a278 1
			iface->auth_type = type;
d289 2
a290 2
			strncpy(iface->auth_key, $2,
			    sizeof(iface->auth_key));
d346 5
d370 1
d374 1
d404 1
d413 6
a418 1

d434 1
a434 5
interfaceoptsl	: authmd nl
		| authkey nl
		| authmdkeyid nl
		| authtype nl
		| PASSIVE nl		{ iface->passive = 1; }
d706 1
d753 3
@


1.27
log
@There is no need to check iface != NULL. These parser rules are only allowed
if iface is set and so the check is superfluous. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2006/03/15 13:25:33 claudio Exp $ */
d66 1
a66 1
static struct {
d73 6
a78 1
} defaults;
d175 1
a175 52
conf_main	: METRIC number {
			if ($2 < MIN_METRIC || $2 > MAX_METRIC) {
				yyerror("metric out of range (%d-%d)",
				    MIN_METRIC, MAX_METRIC);
				YYERROR;
			}
			defaults.metric = $2;
		}
		| ROUTERPRIORITY number {
			if ($2 < MIN_PRIORITY || $2 > MAX_PRIORITY) {
				yyerror("router-priority out of range (%d-%d)",
				    MIN_PRIORITY, MAX_PRIORITY);
				YYERROR;
			}
			defaults.priority = $2;
		}
		| ROUTERDEADTIME number {
			if ($2 < MIN_RTR_DEAD_TIME || $2 > MAX_RTR_DEAD_TIME) {
				yyerror("router-dead-time out of range (%d-%d)",
				    MIN_RTR_DEAD_TIME, MAX_RTR_DEAD_TIME);
				YYERROR;
			}
			defaults.dead_interval = $2;
		}
		| TRANSMITDELAY number {
			if ($2 < MIN_TRANSMIT_DELAY ||
			    $2 > MAX_TRANSMIT_DELAY) {
				yyerror("transmit-delay out of range (%d-%d)",
				    MIN_TRANSMIT_DELAY, MAX_TRANSMIT_DELAY);
				YYERROR;
			}
			defaults.transmit_delay = $2;
		}
		| HELLOINTERVAL number {
			if ($2 < MIN_HELLO_INTERVAL ||
			    $2 > MAX_HELLO_INTERVAL) {
				yyerror("hello-interval out of range (%d-%d)",
				    MIN_HELLO_INTERVAL, MAX_HELLO_INTERVAL);
				YYERROR;
			}
			defaults.hello_interval = $2;
		}
		| RETRANSMITINTERVAL number {
			if ($2 < MIN_RXMT_INTERVAL || $2 > MAX_RXMT_INTERVAL) {
				yyerror("retransmit-interval out of range "
				    "(%d-%d)", MIN_RXMT_INTERVAL,
				    MAX_RXMT_INTERVAL);
				YYERROR;
			}
			defaults.rxmt_interval = $2;
		}
		| ROUTERID STRING {
d229 1
d291 1
a291 27
optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl		/* one newline or more */
		;

area		: AREA STRING {
			struct in_addr	id;
			if (inet_aton($2, &id) == 0) {
				yyerror("error parsing area");
				free($2);
				YYERROR;
			}
			free($2);
			area = conf_get_area(id);
		} '{' optnl areaopts_l '}' {
			area = NULL;
		}
		;

areaopts_l	: areaopts_l areaoptsl
		| areaoptsl
		;

areaoptsl	: interface nl
		| METRIC number nl {
d297 1
a297 1
			area->metric = $2;
d299 1
a299 1
		| ROUTERPRIORITY number nl {
d305 1
a305 1
			area->priority = $2;
d307 1
a307 1
		| ROUTERDEADTIME number nl {
d313 1
a313 1
			area->dead_interval = $2;
d315 1
a315 1
		| TRANSMITDELAY number nl {
d322 1
a322 1
			area->transmit_delay = $2;
d324 1
a324 1
		| HELLOINTERVAL number nl {
d331 1
a331 1
			area->hello_interval = $2;
d333 1
a333 1
		| RETRANSMITINTERVAL number nl {
d340 1
a340 1
			area->rxmt_interval = $2;
d342 32
d391 3
d395 7
d403 2
d422 1
a422 51
		| METRIC number nl {
			if ($2 < MIN_METRIC || $2 > MAX_METRIC) {
				yyerror("metric out of range (%d-%d)",
				    MIN_METRIC, MAX_METRIC);
				YYERROR;
			}
			iface->metric = $2;
		}
		| ROUTERPRIORITY number nl {
			if ($2 < MIN_PRIORITY || $2 > MAX_PRIORITY) {
				yyerror("router-priority out of range (%d-%d)",
				    MIN_PRIORITY, MAX_PRIORITY);
				YYERROR;
			}
			iface->priority = $2;
		}
		| ROUTERDEADTIME number nl {
			if ($2 < MIN_RTR_DEAD_TIME || $2 > MAX_RTR_DEAD_TIME) {
				yyerror("router-dead-time out of range (%d-%d)",
				    MIN_RTR_DEAD_TIME, MAX_RTR_DEAD_TIME);
				YYERROR;
			}
			iface->dead_interval = $2;
		}
		| TRANSMITDELAY number nl {
			if ($2 < MIN_TRANSMIT_DELAY ||
			    $2 > MAX_TRANSMIT_DELAY) {
				yyerror("transmit-delay out of range (%d-%d)",
				    MIN_TRANSMIT_DELAY, MAX_TRANSMIT_DELAY);
				YYERROR;
			}
			iface->transmit_delay = $2;
		}
		| HELLOINTERVAL number nl {
			if ($2 < MIN_HELLO_INTERVAL ||
			    $2 > MAX_HELLO_INTERVAL) {
				yyerror("hello-interval out of range (%d-%d)",
				    MIN_HELLO_INTERVAL, MAX_HELLO_INTERVAL);
				YYERROR;
			}
			iface->hello_interval = $2;
		}
		| RETRANSMITINTERVAL number nl {
			if ($2 < MIN_RXMT_INTERVAL || $2 > MAX_RXMT_INTERVAL) {
				yyerror("retransmit-interval out of range "
				    "(%d-%d)", MIN_RXMT_INTERVAL,
				    MAX_RXMT_INTERVAL);
				YYERROR;
			}
			iface->rxmt_interval = $2;
		}
d691 8
a698 6
	defaults.dead_interval = DEFAULT_RTR_DEAD_TIME;
	defaults.transmit_delay = DEFAULT_TRANSMIT_DELAY;
	defaults.hello_interval = DEFAULT_HELLO_INTERVAL;
	defaults.rxmt_interval = DEFAULT_RXMT_INTERVAL;
	defaults.metric = DEFAULT_METRIC;
	defaults.priority = DEFAULT_PRIORITY;
a851 7
	a->dead_interval = defaults.dead_interval;
	a->transmit_delay = defaults.transmit_delay;
	a->hello_interval = defaults.hello_interval;
	a->rxmt_interval = defaults.rxmt_interval;
	a->metric = defaults.metric;
	a->priority = defaults.priority;

a871 6
	i->dead_interval = area->dead_interval;
	i->transmit_delay = area->transmit_delay;
	i->hello_interval = area->hello_interval;
	i->rxmt_interval = area->rxmt_interval;
	i->metric = area->metric;
	i->priority = area->priority;
@


1.26
log
@Looks like auth-type simple was busted since a long time. We bcmp() a
c string with a lenght <= 8 with a buffer of size 8. Now in some cases
there can be trailing garbage after the c-string and so the bcmp() fails.
Found by Sergey Matveychuk who provided a similar patch.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2006/03/08 15:35:07 claudio Exp $ */
d278 12
a289 15
			if (iface != NULL) {
				if ($2 < MIN_MD_ID || $2 > MAX_MD_ID) {
					yyerror("auth-md key-id out of range "
					    "(%d-%d)", MIN_MD_ID, MAX_MD_ID);
					free($3);
					YYERROR;
				}
				if (strlen($3) > MD5_DIGEST_LENGTH) {
					yyerror("auth-md key length out of range "
					    "(max length %d)",
					    MD5_DIGEST_LENGTH);
					free($3);
					YYERROR;
				}
				md_list_add(iface, $2, $3);
d291 1
d296 4
a299 7
			if (iface != NULL) {
				if ($2 < MIN_MD_ID || $2 > MAX_MD_ID) {
					yyerror("auth-md-keyid out of range "
					    "(%d-%d)", MIN_MD_ID, MAX_MD_ID);
					YYERROR;
				}
				iface->auth_keyid = $2;
d301 1
d324 3
a326 4
			if (iface != NULL) {
				if (strlen($2) > MAX_SIMPLE_AUTH_LEN) {
					yyerror("auth-key too long "
					    "(max length %d)", MAX_SIMPLE_AUTH_LEN);
a328 3
				}
				strncpy(iface->auth_key, $2,
				    sizeof(iface->auth_key));
d330 2
@


1.25
log
@Spaces and other minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2006/01/20 00:01:20 millert Exp $ */
d330 1
a330 1
					yyerror("auth-key length out of range "
d335 4
a338 3
				iface->auth_key = $2;
			} else
				free($2);
@


1.24
log
@Explicitly include limits.h if we are going to use its contents.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2006/01/05 15:53:36 claudio Exp $ */
d827 1
a827 1
	
d1004 1
a1004 1
	
@


1.23
log
@Make ospfd respect carp(4) interfaces and their weird behaviour. They will
not be used to connect to a OSPF cloud and forced to be passive. With this
ospfd will only announce the carp interface route if the interface is master.
So you can connect a LAN in a redundant way to your ospf backbone. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2005/12/15 20:19:48 claudio Exp $ */
d33 1
@


1.22
log
@Fix memory leaks in the parser. Make the string passed with area more strict.
Finaly implement clear_config(). OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2005/11/04 10:15:43 claudio Exp $ */
a433 1
			iface->passive = 0;
@


1.21
log
@Make "interface em0 { }" work again. Reported and OK stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2005/10/30 23:01:38 stevesk Exp $ */
d220 1
a220 1
		| ROUTERID string {
d226 1
d335 2
a336 1
			}
d347 1
a347 1
area		: AREA string {
d973 8
a980 2
	/* XXX clear conf */
		/* ... */
@


1.20
log
@remove some unneeded #includes and correct keyword in error string;
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2005/10/28 14:51:57 stevesk Exp $ */
d439 1
@


1.19
log
@clean auth error messages; ok claudio@@ msf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2005/09/17 20:03:35 msf Exp $ */
a25 1
#include <sys/time.h>
a28 1
#include <net/if.h>
a35 1
#include <syslog.h>
d348 1
a348 1
				yyerror("error parsing area-id");
@


1.18
log
@- add get_rtr_id() based on bgpd's get_bgpid()
- remove rtr_id from struct iface we don't need to keep a copy of this value
  per interface
- replace all references to iface->rtr_id.s_addr with calls to ospfe_rtr_id()

ok claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2005/09/15 20:24:46 claudio Exp $ */
d281 1
a281 1
					yyerror("auth-keyid out of range "
d287 1
a287 1
					yyerror("auth-md length out of range "
d301 1
a301 1
					yyerror("auth-keyid out of range "
d331 2
a332 2
					yyerror("auth-key size out of range "
					    "(max %d)", MAX_SIMPLE_AUTH_LEN);
@


1.17
log
@auth-md-keyid 0 is valid but is not allowed on Cis^H^Hrap routers.
Default to id 1 and mention it in the man page.
From a discussion with msf@@ OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2005/06/28 22:35:34 claudio Exp $ */
d34 1
d66 1
a434 1
			iface->rtr_id = conf->rtr_id;
d825 3
d975 28
@


1.16
log
@Make it possible to specify interfaces just by using "interface em0" without
a {} block. Only drawback is that it is no longer possible to do
"interface em0\n{ ...".
OK henning@@ norby@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2005/05/26 18:46:16 norby Exp $ */
d961 1
@


1.15
log
@Support dumping the configuration the way bgpd(8) does it.

This makes it possible to have ospfd(8) parse a configuration file and
display the parsed result.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2005/05/23 19:59:02 norby Exp $ */
d254 1
a254 1
				conf->rfc1583compat = $2;
d355 1
a355 3
		} optnl '{' optnl {

		} areaopts_l '}' {
d418 1
a418 1
interface	: INTERFACE STRING {
d435 1
a435 3
		} optnl '{' optnl {

		} interfaceopts_l '}' {
d438 4
@


1.14
log
@Make the rfc1583compat flag changable in ospfd.conf(5).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2005/04/12 09:54:59 claudio Exp $ */
d794 6
a799 5
	if (check_file_secrecy(fileno(fin), filename)) {
		fclose(fin);
		free(conf);
		return (NULL);
	}
@


1.13
log
@Support for self originated AS-external LSA.
With "redistribute (static|connected|default|none)" it is possible to
tell ospfd which external routes should be announced.
Connected routes will be announced only if there is no corresponding
interface configured, in that case the prefix is not external.
Adding and removing of announced prefixes are done automaticaly.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2005/04/06 20:21:08 norby Exp $ */
d101 1
a101 1
%token	SPFDELAY SPFHOLDTIME
d253 3
d551 1
@


1.12
log
@Add check for key lengths. Based on diff from Jason Ackley.
Reworked by me.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2005/03/31 19:32:10 norby Exp $ */
d100 1
a100 1
%token	AREA INTERFACE ROUTERID FIBUPDATE
d234 19
d546 1
@


1.11
log
@Add support for crypt authentication (MD5).

ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2005/03/29 17:26:35 norby Exp $ */
d257 1
a257 1
					yyerror("keyid out of range "
d262 7
d277 1
a277 1
					yyerror("keyid out of range "
d306 6
a312 1
				/* XXX truncate and warn! */
@


1.10
log
@The RFC never mentions anything about transfer, this should be transmit.

From Jason Ackley (thanks).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2005/03/22 22:13:48 norby Exp $ */
d102 1
a102 1
%token	AUTHKEY AUTHTYPE
d254 24
d286 1
a286 1
				type = AUTH_SIMPLE;
d414 3
a416 1
interfaceoptsl	: authkey nl
d507 2
@


1.9
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2005/03/12 11:03:05 norby Exp $ */
d68 1
a68 1
	u_int16_t	transfer_delay;
d197 1
a197 1
				yyerror("transfer-delay out of range (%d-%d)",
d201 1
a201 1
			defaults.transfer_delay = $2;
d336 1
a336 1
				yyerror("transfer-delay out of range (%d-%d)",
d340 1
a340 1
			area->transfer_delay = $2;
d420 1
a420 1
				yyerror("transfer-delay out of range (%d-%d)",
d424 1
a424 1
			iface->transfer_delay = $2;
d709 1
a709 1
	defaults.transfer_delay = DEFAULT_TRANSMIT_DELAY;
d864 1
a864 1
	a->transfer_delay = defaults.transfer_delay;
d891 1
a891 1
	i->transfer_delay = area->transfer_delay;
@


1.8
log
@Add "show rib" and "show rib detail" to ospfctl.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2005/03/07 10:28:14 claudio Exp $ */
d378 1
a378 1
			iface->passive = false;
d392 1
a392 1
		| PASSIVE nl		{ iface->passive = true; }
@


1.7
log
@Small K&F.

ok henning@@
@
text
@@


1.6
log
@Track interface state (up/down) and media status. Simplify the code a bit
by using the kif/kroute info while allocating interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2005/02/27 08:21:15 norby Exp $ */
d195 2
a196 1
			if ($2 < MIN_TRANSMIT_DELAY || $2 > MAX_TRANSMIT_DELAY) {
d334 2
a335 1
			if ($2 < MIN_TRANSMIT_DELAY || $2 > MAX_TRANSMIT_DELAY) {
d418 2
a419 1
			if ($2 < MIN_TRANSMIT_DELAY || $2 > MAX_TRANSMIT_DELAY) {
@


1.5
log
@SPF and route table calculation.

Calculate Shortest Path Tree for each area known in the link state
database.

The Shortest Path Tree is used as input for route table calculation.
Route tabled is calculated and the result is inserted into the kernel
route table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2005/02/02 21:02:25 norby Exp $ */
d88 1
a88 1
struct iface		*conf_get_if(char *, unsigned int);
d361 1
a361 1
			unsigned int	idx;
d363 1
a363 1
			if ((idx = if_nametoindex($2)) == 0 ) {
a367 1
			iface = conf_get_if($2, idx);
d369 1
d873 1
a873 1
conf_get_if(char *name, unsigned int idx)
d880 1
a880 1
			if (i->ifindex == idx) {
d882 1
a882 1
				    name);
d886 1
a886 1
	i = if_new(name, idx);
@


1.4
log
@Change keyword fibupdate to fib-update, for consistency with bgpd.conf(5).

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2005/02/02 19:47:20 norby Exp $ */
d4 1
a4 1
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
d101 1
d233 18
d488 3
a490 1
		{"transmit-delay",	TRANSMITDELAY},
d713 3
@


1.3
log
@Typo in constant.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d460 1
a460 1
		{"fibupdate",		FIBUPDATE},
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d194 1
a194 1
			if ($2 < MIN_TRANSIT_DELAY || $2 > MAX_TRANSIT_DELAY) {
d196 1
a196 1
				    MIN_TRANSIT_DELAY, MAX_TRANSIT_DELAY);
d314 1
a314 1
			if ($2 < MIN_TRANSIT_DELAY || $2 > MAX_TRANSIT_DELAY) {
d316 1
a316 1
				    MIN_TRANSIT_DELAY, MAX_TRANSIT_DELAY);
d397 1
a397 1
			if ($2 < MIN_TRANSIT_DELAY || $2 > MAX_TRANSIT_DELAY) {
d399 1
a399 1
				    MIN_TRANSIT_DELAY, MAX_TRANSIT_DELAY);
d685 1
a685 1
	defaults.transfer_delay = DEFAULT_TRANSIT_DELAY;
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2004 Esben Norby <esben.norby@@ericsson.com>
@

