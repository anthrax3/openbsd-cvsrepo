head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.8
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.10
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.14
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.18
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.16
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.12
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2015.05.05.01.26.37;	author jsg;	state Exp;
branches;
next	1.19;
commitid	t9z5FiHTkQbSNv6Z;

1.19
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.06.07.31.26;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.05.19.33.58;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.04.12.51.01;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.24.18.46.59;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.11.11.50.30;	author norby;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.01.13.25.28;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.01.12.41.03;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.24.20.18.03;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.08.15.35.07;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.02.15.11.54;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.12.18.18.24;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.19.22.00.37;	author stevesk;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.05.13.01.21;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.04.13.49.13;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.31.19.32.10;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.53.33;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.20
log
@use the sizeof the struct not the sizeof a pointer to the struct
ok claudio@@
@
text
@/*	$OpenBSD: auth.c,v 1.19 2010/09/02 14:03:21 sobrado Exp $ */

/*
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <limits.h>
#include <md5.h>
#include <stdlib.h>
#include <string.h>

#include "ospfd.h"
#include "ospf.h"
#include "log.h"
#include "ospfe.h"

struct auth_md *md_list_find(struct auth_md_head *, u_int8_t);

int
auth_validate(void *buf, u_int16_t len, struct iface *iface, struct nbr *nbr)
{
	MD5_CTX		 hash;
	u_int8_t	 digest[MD5_DIGEST_LENGTH];
	u_int8_t	 recv_digest[MD5_DIGEST_LENGTH];
	struct ospf_hdr	*ospf_hdr = buf;
	struct auth_md	*md;
	char		*auth_data;

	if (ntohs(ospf_hdr->auth_type) != (u_int16_t)iface->auth_type) {
		log_debug("auth_validate: wrong auth type, interface %s",
		    iface->name);
		return (-1);
	}

	switch (iface->auth_type) {
	case AUTH_SIMPLE:
		if (memcmp(ospf_hdr->auth_key.simple, iface->auth_key,
		    sizeof(ospf_hdr->auth_key.simple))) {
			log_debug("auth_validate: wrong password, interface %s",
			    iface->name);
			return (-1);
		}
		/* FALLTHROUGH */
	case AUTH_NONE:
		/* clear the key before chksum */
		bzero(ospf_hdr->auth_key.simple,
		     sizeof(ospf_hdr->auth_key.simple));

		if (in_cksum(ospf_hdr, ntohs(ospf_hdr->len))) {
			log_debug("auth_validate: invalid checksum, "
			    "interface %s", iface->name);
			return (-1);
		}
		break;
	case AUTH_CRYPT:
		/*
		 * We must allow keys that are configured on the interface
		 * but not necessarily set as the transmit key
		 * (iface->auth_keyid). This allows for key rotation to new
		 * keys without taking down the network.
		 */
		if ((md = md_list_find(&iface->auth_md_list,
		    ospf_hdr->auth_key.crypt.keyid)) == NULL) {
			log_debug("auth_validate: keyid %d not configured, "
			    "interface %s", ospf_hdr->auth_key.crypt.keyid,
			    iface->name);
			return (-1);
		}

		if (nbr != NULL && ntohl(ospf_hdr->auth_key.crypt.seq_num) <
		    nbr->crypt_seq_num) {
			log_debug("auth_validate: decreasing seq num, "
			    "interface %s", iface->name);
			return (-1);
		}

		if (ospf_hdr->auth_key.crypt.len != MD5_DIGEST_LENGTH) {
			log_debug("auth_validate: invalid key length, "
			    "interface %s", iface->name);
			return (-1);
		}

		if (len - ntohs(ospf_hdr->len) < MD5_DIGEST_LENGTH) {
			log_debug("auth_validate: invalid key length, "
			    "interface %s", iface->name);
			return (-1);
		}

		auth_data = buf;
		auth_data += ntohs(ospf_hdr->len);

		/* save the received digest and clear it in the packet */
		memcpy(recv_digest, auth_data, sizeof(recv_digest));
		bzero(auth_data, MD5_DIGEST_LENGTH);

		/* insert plaintext key */
		bzero(digest, MD5_DIGEST_LENGTH);
		strncpy(digest, md->key, MD5_DIGEST_LENGTH);

		/* calculate MD5 digest */
		MD5Init(&hash);
		MD5Update(&hash, buf, ntohs(ospf_hdr->len));
		MD5Update(&hash, digest, MD5_DIGEST_LENGTH);
		MD5Final(digest, &hash);

		if (memcmp(recv_digest, digest, sizeof(digest))) {
			log_debug("auth_validate: invalid MD5 digest, "
			    "interface %s", iface->name);
			return (-1);
		}

		if (nbr != NULL)
			nbr->crypt_seq_num =
			    ntohl(ospf_hdr->auth_key.crypt.seq_num);
		break;
	default:
		log_debug("auth_validate: unknown auth type, interface %s",
		    iface->name);
		return (-1);
	}

	return (0);
}

int
auth_gen(struct ibuf *buf, struct iface *iface)
{
	MD5_CTX		 hash;
	u_int8_t	 digest[MD5_DIGEST_LENGTH];
	struct ospf_hdr	*ospf_hdr;
	struct auth_md	*md;

	if ((ospf_hdr = ibuf_seek(buf, 0, sizeof(*ospf_hdr))) == NULL)
		fatalx("auth_gen: buf_seek failed");

	/* update length */
	if (ibuf_size(buf) > USHRT_MAX)
		fatalx("auth_gen: resulting ospf packet too big");
	ospf_hdr->len = htons(ibuf_size(buf));
	/* clear auth_key field */
	bzero(ospf_hdr->auth_key.simple, sizeof(ospf_hdr->auth_key.simple));

	switch (iface->auth_type) {
	case AUTH_NONE:
		ospf_hdr->chksum = in_cksum(buf->buf, ibuf_size(buf));
		break;
	case AUTH_SIMPLE:
		ospf_hdr->chksum = in_cksum(buf->buf, ibuf_size(buf));

		strncpy(ospf_hdr->auth_key.simple, iface->auth_key,
		    sizeof(ospf_hdr->auth_key.simple));
		break;
	case AUTH_CRYPT:
		ospf_hdr->chksum = 0;
		ospf_hdr->auth_key.crypt.keyid = iface->auth_keyid;
		ospf_hdr->auth_key.crypt.seq_num = htonl(iface->crypt_seq_num);
		ospf_hdr->auth_key.crypt.len = MD5_DIGEST_LENGTH;
		iface->crypt_seq_num++;

		/* insert plaintext key */
		if ((md = md_list_find(&iface->auth_md_list,
		    iface->auth_keyid)) == NULL) {
			log_debug("auth_gen: keyid %d not configured, "
			    "interface %s", iface->auth_keyid, iface->name);
			return (-1);
		}

		bzero(digest, MD5_DIGEST_LENGTH);
		strncpy(digest, md->key, MD5_DIGEST_LENGTH);

		/* calculate MD5 digest */
		MD5Init(&hash);
		MD5Update(&hash, buf->buf, ibuf_size(buf));
		MD5Update(&hash, digest, MD5_DIGEST_LENGTH);
		MD5Final(digest, &hash);

		return (ibuf_add(buf, digest, MD5_DIGEST_LENGTH));
	default:
		log_debug("auth_gen: unknown auth type, interface %s",
		    iface->name);
		return (-1);
	}

	return (0);
}

/* md list */
void
md_list_add(struct auth_md_head *head, u_int8_t keyid, char *key)
{
	struct auth_md	*md;

	if ((md = md_list_find(head, keyid)) != NULL) {
		/* update key */
		strncpy(md->key, key, sizeof(md->key));
		return;
	}

	if ((md = calloc(1, sizeof(struct auth_md))) == NULL)
		fatalx("md_list_add");

	md->keyid = keyid;
	strncpy(md->key, key, sizeof(md->key));
	TAILQ_INSERT_TAIL(head, md, entry);
}

void
md_list_copy(struct auth_md_head *to, struct auth_md_head *from)
{
	struct auth_md	*m, *md;

	TAILQ_INIT(to);

	TAILQ_FOREACH(m, from, entry) {
		if ((md = calloc(1, sizeof(struct auth_md))) == NULL)
			fatalx("md_list_copy");

		md->keyid = m->keyid;
		strncpy(md->key, m->key, sizeof(md->key));
		TAILQ_INSERT_TAIL(to, md, entry);
	}
}

void
md_list_clr(struct auth_md_head *head)
{
	struct auth_md	*m;

	while ((m = TAILQ_FIRST(head)) != NULL) {
		TAILQ_REMOVE(head, m, entry);
		free(m);
	}
}

struct auth_md *
md_list_find(struct auth_md_head *head, u_int8_t keyid)
{
	struct auth_md	*m;

	TAILQ_FOREACH(m, head, entry)
		if (m->keyid == keyid)
			return (m);

	return (NULL);
}

int
md_list_send(struct auth_md_head *head, struct imsgev *to)
{
	struct auth_md	*m;

	TAILQ_FOREACH(m, head, entry)
		if (imsg_compose_event(to, IMSG_RECONF_AUTHMD, 0, 0, -1, m,
		    sizeof(*m)) == -1)
			return (-1);

	return (0);
}
@


1.19
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.18 2010/05/26 13:56:08 nicm Exp $ */
d147 1
a147 1
	if ((ospf_hdr = ibuf_seek(buf, 0, sizeof(ospf_hdr))) == NULL)
@


1.18
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.17 2009/06/06 07:31:26 eric Exp $ */
d267 1
a267 1
		if (imsg_compose_event(to, IMSG_RECONF_AUTHMD, 0, 0, -1, m, 
@


1.17
log
@sync ospfctl/ospfd with the common imsg code, making it lib ready as well.

"looks ok" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.16 2009/06/05 19:33:58 pyr Exp $ */
d140 1
a140 1
auth_gen(struct buf *buf, struct iface *iface)
d147 1
a147 1
	if ((ospf_hdr = buf_seek(buf, 0, sizeof(ospf_hdr))) == NULL)
d151 1
a151 1
	if (buf_size(buf) > USHRT_MAX)
d153 1
a153 1
	ospf_hdr->len = htons(buf_size(buf));
d159 1
a159 1
		ospf_hdr->chksum = in_cksum(buf->buf, buf_size(buf));
d162 1
a162 1
		ospf_hdr->chksum = in_cksum(buf->buf, buf_size(buf));
d187 1
a187 1
		MD5Update(&hash, buf->buf, buf_size(buf));
d191 1
a191 1
		return (buf_add(buf, digest, MD5_DIGEST_LENGTH));
@


1.16
log
@make ospfd's imsg lib ready as well.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.15 2009/03/04 12:51:01 claudio Exp $ */
d262 1
a262 1
md_list_send(struct auth_md_head *head, struct imsgbuf *to)
@


1.15
log
@Introduce and use buf_size(buf) instead of buf->wpos -- at least in the non
buf/imsg specific code. buf_close() will no force a truncation of the buffer
to the wpos but actually add code in imsg.c to detect and report such silly
behaviour. Makes the buf API a bit more sane.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.14 2008/07/24 18:46:59 claudio Exp $ */
d267 1
a267 1
		if (imsg_compose(to, IMSG_RECONF_AUTHMD, 0, 0, m,
@


1.14
log
@Use memcpy() and memcmp() like everywhere else in ospfd. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.13 2008/02/11 11:50:30 norby Exp $ */
d151 1
a151 1
	if (buf->wpos > USHRT_MAX)
d153 1
a153 1
	ospf_hdr->len = htons((u_int16_t)buf->wpos);
d159 1
a159 1
		ospf_hdr->chksum = in_cksum(buf->buf, buf->wpos);
d162 1
a162 1
		ospf_hdr->chksum = in_cksum(buf->buf, buf->wpos);
d187 1
a187 1
		MD5Update(&hash, buf->buf, buf->wpos);
@


1.13
log
@log_debug error messages report incorrect function names

from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.12 2007/02/01 13:25:28 claudio Exp $ */
d51 1
a51 1
		if (bcmp(ospf_hdr->auth_key.simple, iface->auth_key,
d107 1
a107 1
		bcopy(auth_data, recv_digest, sizeof(recv_digest));
d120 1
a120 1
		if (bcmp(recv_digest, digest, sizeof(digest))) {
@


1.12
log
@whitespace cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.11 2007/02/01 12:41:03 claudio Exp $ */
d177 1
a177 1
			log_debug("auth_validate: keyid %d not configured, "
d230 1
a230 1
			fatalx("md_list_add");
@


1.11
log
@Implement md_list_send() function to send auth crypt keys to the OSPF engine.
Needed for reload support. OK norby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.10 2006/04/24 20:18:03 claudio Exp $ */
d227 1
a227 1
	
@


1.10
log
@Fix parser to match current behaviour and make auth-type et al. part of the
global and per area defaults. With this it is now possible to define one
set of auth-md keys and use them in every defined interface. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.9 2006/03/08 15:35:07 claudio Exp $ */
d259 13
@


1.9
log
@Spaces and other minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.8 2006/02/02 15:11:54 norby Exp $ */
d31 2
d76 2
a77 2
		if ((md = md_list_find(iface, ospf_hdr->auth_key.crypt.keyid))
		    == NULL) {
d175 2
a176 1
		if ((md = md_list_find(iface, iface->auth_keyid)) == NULL) {
d203 1
a203 1
md_list_init(struct iface *iface)
d205 1
a205 7
	TAILQ_INIT(&iface->auth_md_list);
}

void
md_list_add(struct iface *iface, u_int8_t keyid, char *key)
{
	struct auth_md	*m, *md;
d207 1
a207 1
	if ((md = md_list_find(iface, keyid)) != NULL) {
d218 7
d226 9
a234 5
	TAILQ_FOREACH(m, &iface->auth_md_list, entry) {
		if (m->keyid > keyid) {
			TAILQ_INSERT_BEFORE(m, md, entry);
			return;
		}
a235 1
	TAILQ_INSERT_TAIL(&iface->auth_md_list, md, entry);
d239 1
a239 1
md_list_clr(struct iface *iface)
d243 2
a244 2
	while ((m = TAILQ_FIRST(&iface->auth_md_list)) != NULL) {
		TAILQ_REMOVE(&iface->auth_md_list, m, entry);
d250 1
a250 1
md_list_find(struct iface *iface, u_int8_t keyid)
d254 1
a254 1
	TAILQ_FOREACH(m, &iface->auth_md_list, entry)
@


1.8
log
@zap md_list_empty, found by lint.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.7 2005/11/12 18:18:24 deraadt Exp $ */
d62 2
a63 2
			log_debug("auth_validate: invalid checksum, interface %s",
			    iface->name);
d153 1
a153 2
	bzero(ospf_hdr->auth_key.simple,
	    sizeof(ospf_hdr->auth_key.simple));
d173 1
a173 2
		if ((md = md_list_find(iface, iface->auth_keyid))
		    == NULL) {
@


1.7
log
@spacing mostly
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.6 2005/10/19 22:00:37 stevesk Exp $ */
a241 6
}

int
md_list_empty(struct iface *iface)
{
	return (TAILQ_EMPTY(&iface->auth_md_list));
@


1.6
log
@small cleanups while reading; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.5 2005/04/05 13:01:21 claudio Exp $ */
a230 2

	return;
@


1.5
log
@Use the dynamic buffer API for packet generation and sending.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.4 2005/04/04 13:49:13 claudio Exp $ */
d62 1
a62 1
			log_debug("recv_packet: invalid checksum, interface %s",
d150 1
a150 1
		fatalx("auth_gen: resulting ospf packet to big");
@


1.4
log
@On auth crypt verify not only the main key is allowed but all configured keys.
This makes changing keys a piece of cake -- if ospfd would support reloads.
Found and patch from Jason Ackley.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.3 2005/03/31 19:32:10 norby Exp $ */
d21 1
d138 1
a138 1
auth_gen(void *buf, u_int16_t len, struct iface *iface)
d142 1
a142 1
	struct ospf_hdr	*ospf_hdr = buf;
d144 3
a146 1
	char		*auth_data;
d149 3
a151 1
	ospf_hdr->len = htons(len);
d158 1
a158 1
		ospf_hdr->chksum = in_cksum(buf, len);
d161 1
a161 1
		ospf_hdr->chksum = in_cksum(buf, len);
d186 1
a186 1
		MD5Update(&hash, buf, len);
d190 1
a190 7
		/* insert MD5 digest */
		/* XXX this will be fixed soon, when we switch to dynamic
		 * buffers */
		auth_data = buf;
		auth_data += len;
		bcopy(digest, auth_data, sizeof(digest));
		break;
@


1.3
log
@Add support for crypt authentication (MD5).

ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.2 2005/01/28 17:53:33 norby Exp $ */
d67 11
a77 3
		if (ospf_hdr->auth_key.crypt.keyid != iface->auth_keyid) {
			log_debug("auth_validate: invalid key id, "
			    "interface %s", iface->name);
a107 8
		if ((md = md_list_find(iface, iface->auth_keyid))
		    == NULL) {
			log_debug("auth_validate: keyid %d not configured, "
			    "interface %s", iface->auth_keyid,
			    iface->name);
			return (-1);
		}

@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
d21 2
d31 1
a31 1
auth_validate(struct ospf_hdr *pkt, const struct iface *iface)
d33 8
a40 1
	if (ntohs(pkt->auth_type) != (u_int16_t)iface->auth_type) {
a46 2
	case AUTH_NONE:
		break;
d48 2
a49 2
		if (bcmp(pkt->auth_key.simple, iface->auth_key,
		    sizeof(pkt->auth_key.simple))) {
d54 2
d57 8
a64 2
		bzero(pkt->auth_key.simple,
		     sizeof(pkt->auth_key.simple));
d67 60
a126 3
		log_debug("auth_validate: not supported, interface %s",
		    iface->name);
		return (-1);
a132 6
	if (in_cksum(pkt, ntohs(pkt->len))) {
		log_debug("recv_packet: invalid checksum, interface %s",
		    iface->name);
		return (-1);
	}

d137 1
a137 1
auth_gen(void *buf, u_int16_t len, const struct iface *iface)
d139 2
d142 2
d145 1
a145 1
	/* update length, and checksum */
d147 3
a149 1
	ospf_hdr->chksum = in_cksum(buf, len);
d153 1
d156 2
d162 30
a191 3
		log_debug("auth_gen: not supported, interface %s",
		    iface->name);
		return (-1);
d199 64
@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2004, 2005 Esben Norby <esben.norby@@ericsson.com>
@

