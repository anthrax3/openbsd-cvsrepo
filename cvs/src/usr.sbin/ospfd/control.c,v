head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.2
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.37.0.4
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.4
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.44
date	2017.01.24.04.24.25;	author benno;	state Exp;
branches;
next	1.43;
commitid	PUkGTVeidQeu8XjZ;

1.43
date	2017.01.08.23.04.42;	author krw;	state Exp;
branches;
next	1.42;
commitid	T1ZdV0xhVeBLIhr0;

1.42
date	2015.12.03.11.41.06;	author claudio;	state Exp;
branches;
next	1.41;
commitid	Rtzon3iP98l2jBUz;

1.41
date	2015.02.10.05.24.48;	author claudio;	state Exp;
branches;
next	1.40;
commitid	4XccNzu2mQpqfy01;

1.40
date	2014.07.11.16.43.33;	author krw;	state Exp;
branches;
next	1.39;
commitid	TgA9QmI8ib2B7iAZ;

1.39
date	2013.11.13.20.43.00;	author benno;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2012.04.11.08.33.53;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2012.04.10.07.56.54;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.02.14.03.22;	author sobrado;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.14.11.52.19;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2010.02.21.20.53.20;	author michele;	state Exp;
branches;
next	1.31;

1.31
date	2010.02.19.10.35.52;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2009.12.08.15.54.50;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.02.19.10.02;	author mk;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.02.20.20.54;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.06.07.31.26;	author eric;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.05.19.33.58;	author pyr;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.31.18.46.01;	author jacekm;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.31.16.58.54;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.07.14.57.33;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.25.17.09.55;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.21.11.14.42;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.31.12.17.35;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.13.13.21.24;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.21.10.54.30;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.19.10.03.25;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.23.17.39.33;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.25.08.00.22;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.21.17.49.00;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.10.18.30.47;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.18.15.42.15;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.12.19.10.12;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.26.13.35.16;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.15.22.03.56;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.15.16.59.45;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.14.18.21.29;	author norby;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.14.16.57.41;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.12.11.03.05;	author norby;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.12.10.49.12;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.11.15.48.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.05.40;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.44
log
@sync log.c from relayd et al to ospfd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@
@
text
@/*	$OpenBSD: control.c,v 1.43 2017/01/08 23:04:42 krw Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ospfd.h"
#include "ospf.h"
#include "ospfe.h"
#include "log.h"
#include "control.h"

#define	CONTROL_BACKLOG	5

struct ctl_conn	*control_connbyfd(int);
struct ctl_conn	*control_connbypid(pid_t);
void		 control_close(int);

int
control_init(char *path)
{
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask;

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    0)) == -1) {
		log_warn("control_init: socket");
		return (-1);
	}

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, path, sizeof(sun.sun_path));

	if (unlink(path) == -1)
		if (errno != ENOENT) {
			log_warn("control_init: unlink %s", path);
			close(fd);
			return (-1);
		}

	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("control_init: bind: %s", path);
		close(fd);
		umask(old_umask);
		return (-1);
	}
	umask(old_umask);

	if (chmod(path, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
		log_warn("control_init: chmod");
		close(fd);
		(void)unlink(path);
		return (-1);
	}

	control_state.fd = fd;

	return (0);
}

int
control_listen(void)
{

	if (listen(control_state.fd, CONTROL_BACKLOG) == -1) {
		log_warn("control_listen: listen");
		return (-1);
	}

	event_set(&control_state.ev, control_state.fd, EV_READ,
	    control_accept, NULL);
	event_add(&control_state.ev, NULL);
	evtimer_set(&control_state.evt, control_accept, NULL);

	return (0);
}

void
control_cleanup(char *path)
{
	if (path == NULL)
		return;
	event_del(&control_state.ev);
	event_del(&control_state.evt);
	unlink(path);
}

/* ARGSUSED */
void
control_accept(int listenfd, short event, void *bula)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*c;

	event_add(&control_state.ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	len = sizeof(sun);
	if ((connfd = accept4(listenfd, (struct sockaddr *)&sun, &len,
	    SOCK_CLOEXEC | SOCK_NONBLOCK)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&control_state.ev);
			evtimer_add(&control_state.evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("control_accept: accept");
		return;
	}

	if ((c = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		log_warn("control_accept");
		close(connfd);
		return;
	}

	imsg_init(&c->iev.ibuf, connfd);
	c->iev.handler = control_dispatch_imsg;
	c->iev.events = EV_READ;
	event_set(&c->iev.ev, c->iev.ibuf.fd, c->iev.events,
	    c->iev.handler, &c->iev);
	event_add(&c->iev.ev, NULL);

	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
}

struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.fd == fd)
			break;
	}

	return (c);
}

struct ctl_conn *
control_connbypid(pid_t pid)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.pid == pid)
			break;
	}

	return (c);
}

void
control_close(int fd)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("control_close: fd %d: not found", fd);
		return;
	}

	msgbuf_clear(&c->iev.ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	event_del(&c->iev.ev);
	close(c->iev.ibuf.fd);

	/* Some file descriptors are available again. */
	if (evtimer_pending(&control_state.evt, NULL)) {
		evtimer_del(&control_state.evt);
		event_add(&control_state.ev, NULL);
	}

	free(c);
}

/* ARGSUSED */
void
control_dispatch_imsg(int fd, short event, void *bula)
{
	struct ctl_conn	*c;
	struct imsg	 imsg;
	ssize_t		 n;
	unsigned int	 ifidx;
	int		 verbose;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("control_dispatch_imsg: fd %d: not found", fd);
		return;
	}

	if (event & EV_READ) {
		if (((n = imsg_read(&c->iev.ibuf)) == -1 && errno != EAGAIN) ||
		    n == 0) {
			control_close(fd);
			return;
		}
	}
	if (event & EV_WRITE) {
		if (msgbuf_write(&c->iev.ibuf.w) <= 0 && errno != EAGAIN) {
			control_close(fd);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
			control_close(fd);
			return;
		}

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_FIB_COUPLE:
		case IMSG_CTL_FIB_DECOUPLE:
			ospfe_fib_update(imsg.hdr.type);
			/* FALLTHROUGH */
		case IMSG_CTL_FIB_RELOAD:
		case IMSG_CTL_RELOAD:
			c->iev.ibuf.pid = imsg.hdr.pid;
			ospfe_imsg_compose_parent(imsg.hdr.type, 0, NULL, 0);
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_IFINFO:
			c->iev.ibuf.pid = imsg.hdr.pid;
			ospfe_imsg_compose_parent(imsg.hdr.type, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_CTL_SHOW_INTERFACE:
			if (imsg.hdr.len == IMSG_HEADER_SIZE +
			    sizeof(ifidx)) {
				memcpy(&ifidx, imsg.data, sizeof(ifidx));
				ospfe_iface_ctl(c, ifidx);
				imsg_compose_event(&c->iev, IMSG_CTL_END, 0,
				    0, -1, NULL, 0);
			}
			break;
		case IMSG_CTL_SHOW_DATABASE:
		case IMSG_CTL_SHOW_DB_EXT:
		case IMSG_CTL_SHOW_DB_NET:
		case IMSG_CTL_SHOW_DB_RTR:
		case IMSG_CTL_SHOW_DB_SELF:
		case IMSG_CTL_SHOW_DB_SUM:
		case IMSG_CTL_SHOW_DB_ASBR:
		case IMSG_CTL_SHOW_DB_OPAQ:
		case IMSG_CTL_SHOW_RIB:
		case IMSG_CTL_SHOW_SUM:
			c->iev.ibuf.pid = imsg.hdr.pid;
			ospfe_imsg_compose_rde(imsg.hdr.type, 0, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_CTL_SHOW_NBR:
			ospfe_nbr_ctl(c);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(verbose))
				break;

			/* forward to other processes */
			ospfe_imsg_compose_parent(imsg.hdr.type, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			ospfe_imsg_compose_rde(imsg.hdr.type, 0, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		default:
			log_debug("control_dispatch_imsg: "
			    "error handling imsg %d", imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}

	imsg_event_add(&c->iev);
}

int
control_imsg_relay(struct imsg *imsg)
{
	struct ctl_conn	*c;

	if ((c = control_connbypid(imsg->hdr.pid)) == NULL)
		return (0);

	return (imsg_compose_event(&c->iev, imsg->hdr.type, 0, imsg->hdr.pid,
	    -1, imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
}
@


1.43
log
@Replace hand-rolled for(;;) traversal of ctl_conns TAILQ with
TAILQ_FOREACH().

No intentional functional change.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.42 2015/12/03 11:41:06 claudio Exp $ */
d304 1
a304 1
			log_verbose(verbose);
@


1.42
log
@imsg_read will return EAGAIN in some cases so prep code for it.
This is in the way for ospfd pledge so in it goes. OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.41 2015/02/10 05:24:48 claudio Exp $ */
d165 4
a168 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
d178 4
a181 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.pid != pid;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
@


1.41
log
@Convert ospfd over to SOCK_CLOEXEC | SOCK_NONBLOCK and make the route
socket non-blocking. Introduce the same trigger for partial rt msgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.40 2014/07/11 16:43:33 krw Exp $ */
d225 2
a226 1
		if ((n = imsg_read(&c->iev.ibuf)) == -1 || n == 0) {
@


1.40
log
@Close the control fd when it has reported EOF.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.39 2013/11/13 20:43:00 benno Exp $ */
d48 2
a49 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
a80 1
	session_socket_blockmode(fd, BM_NONBLOCK);
d127 2
a128 2
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
a143 2
	session_socket_blockmode(connfd, BM_NONBLOCK);

a323 17
}

void
session_socket_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
@


1.39
log
@from claudio
"Let msgbuf_write return -1 with errno EAGAIN. The users then must
check if this was the case and readd the event or poll again.  The
current handling in the imsg code is wrong for sure."

ok gilles, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.38 2013/03/11 17:40:11 deraadt Exp $ */
d233 1
a233 1
		if (msgbuf_write(&c->iev.ibuf.w) == -1 && errno != EAGAIN) {
@


1.38
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.37 2012/04/11 08:33:53 deraadt Exp $ */
d233 1
a233 1
		if (msgbuf_write(&c->iev.ibuf.w) == -1) {
@


1.37
log
@delete excessive evtimer_pending; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.36 2012/04/10 07:56:54 deraadt Exp $ */
d138 2
a139 1
		} else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.36
log
@Handle file descriptor exhaustion in the accept() case.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.35 2011/05/09 12:24:41 claudio Exp $ */
d109 1
a109 2
	if (evtimer_pending(&control_state.evt, NULL))
		event_del(&control_state.evt);
@


1.35
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.34 2010/09/02 14:03:22 sobrado Exp $ */
d95 1
a95 1
	event_set(&control_state.ev, control_state.fd, EV_READ | EV_PERSIST,
d98 1
d106 6
a111 2
	if (path)
		unlink(path);
d123 4
d130 10
a139 1
		if (errno != EWOULDBLOCK && errno != EINTR)
d201 7
@


1.34
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.33 2010/05/14 11:52:19 claudio Exp $ */
d256 1
@


1.33
log
@Use calloc() instead of malloc() to allocate the connection structure. This
way the memory is zeroed. This is equivalent to the relayd commit by reyk.
OK reyk, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.32 2010/02/21 20:53:20 michele Exp $ */
d278 1
a278 1
			break;		
@


1.32
log
@Kill double declaration of control_imsg_relay().

From Christiano F. Haesbaert.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.31 2010/02/19 10:35:52 dlg Exp $ */
d128 1
a128 1
	if ((c = malloc(sizeof(struct ctl_conn))) == NULL) {
@


1.31
log
@implement ospfctl fib reload.

this tells the daemon to resync the kernels list of interfaces and routes
with the daemons list. this is very useful if the routing socket overflows
and you want to sync things up again.

lots and lots of help from claudio@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.29 2009/12/02 19:10:02 mk Exp $ */
a35 2

int control_imsg_relay(struct imsg *imsg);
@


1.30
log
@porcesses -> processes
@
text
@d230 1
@


1.29
log
@log_warn() consistency.

`OK' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.28 2009/11/02 20:20:54 claudio Exp $ */
d271 1
a271 1
			/* forward to other porcesses */
@


1.28
log
@Implement IMSG_CTL_LOG_VERBOSE to enable or disable debug logging on runtime.
It always annoyed me that in case of a problem I had to restart the ospf in
forground debug mode and by doing so losing all routes at least twice.
OK henning, sthen, michele
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.27 2009/06/06 07:31:26 eric Exp $ */
d124 1
a124 1
			log_warn("control_accept");
@


1.27
log
@sync ospfctl/ospfd with the common imsg code, making it lib ready as well.

"looks ok" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.26 2009/06/05 19:33:58 pyr Exp $ */
d196 1
d238 2
a239 3
			ospfe_imsg_compose_parent(imsg.hdr.type,
			    imsg.hdr.pid, imsg.data,
			    imsg.hdr.len - IMSG_HEADER_SIZE);
d266 14
@


1.26
log
@make ospfd's imsg lib ready as well.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.25 2009/05/31 18:46:01 jacekm Exp $ */
d136 6
a141 5
	imsg_init(&c->ibuf, connfd, control_dispatch_imsg);
	c->ibuf.events = EV_READ;
	event_set(&c->ibuf.ev, c->ibuf.fd, c->ibuf.events,
	    c->ibuf.handler, &c->ibuf);
	event_add(&c->ibuf.ev, NULL);
d151 1
a151 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.fd != fd;
d163 1
a163 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.pid != pid;
d180 1
a180 1
	msgbuf_clear(&c->ibuf.w);
d183 2
a184 2
	event_del(&c->ibuf.ev);
	close(c->ibuf.fd);
d203 1
a203 1
		if ((n = imsg_read(&c->ibuf)) == -1 || n == 0) {
d209 1
a209 1
		if (msgbuf_write(&c->ibuf.w) == -1) {
d216 1
a216 1
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1) {
d230 1
a230 1
			c->ibuf.pid = imsg.hdr.pid;
d236 1
a236 1
			c->ibuf.pid = imsg.hdr.pid;
d246 1
a246 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_END, 0,
d259 1
a259 1
			c->ibuf.pid = imsg.hdr.pid;
d274 1
a274 1
	imsg_event_add(&c->ibuf);
d285 1
a285 1
	return (imsg_compose_event(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
@


1.25
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.24 2009/05/31 16:58:54 claudio Exp $ */
d245 2
a246 2
				imsg_compose(&c->ibuf, IMSG_CTL_END, 0,
				    0, NULL, 0);
d284 2
a285 2
	return (imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
	    imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
@


1.24
log
@The libevent callback function may be called with EV_READ and EV_WRITE
set at the same time so using a switch to do read or write is a bad idea.
Problem noticed by Eygene Ryabinkin on FreeBSD for some reasons it is not
triggered on OpenBSD.
Fix aggreed by a most other libevent hackers
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.23 2009/04/07 14:57:33 reyk Exp $ */
a211 1
		imsg_event_add(&c->ibuf);
@


1.23
log
@allow to specify an alternate control socket instead of /var/run/ospfd.sock.
this is required to run multiple instances of ospfd.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.22 2009/02/25 17:09:55 claudio Exp $ */
d201 1
a201 2
	switch (event) {
	case EV_READ:
d206 3
a208 3
		break;
	case EV_WRITE:
		if (msgbuf_write(&c->ibuf.w) < 0) {
a212 3
		return;
	default:
		fatalx("unknown event");
@


1.22
log
@Fix an invalid pointer dereference in control_close(). If control_connbyfd()
fails -- which should never happen -- the function does not return and is
accession the NULL set control pointer later on.
Found by Matthew Haub. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.21 2008/11/21 11:14:42 claudio Exp $ */
d44 1
a44 1
control_init(void)
d57 1
a57 1
	strlcpy(sun.sun_path, OSPFD_SOCKET, sizeof(sun.sun_path));
d59 1
a59 1
	if (unlink(OSPFD_SOCKET) == -1)
d61 1
a61 1
			log_warn("control_init: unlink %s", OSPFD_SOCKET);
d68 1
a68 1
		log_warn("control_init: bind: %s", OSPFD_SOCKET);
d75 1
a75 1
	if (chmod(OSPFD_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
d78 1
a78 1
		(void)unlink(OSPFD_SOCKET);
d105 1
a105 1
control_cleanup(void)
d107 2
a108 2

	unlink(OSPFD_SOCKET);
@


1.21
log
@imsg_* returns ssize_t
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2008/01/31 12:17:35 henning Exp $ */
d174 1
a174 1
	if ((c = control_connbyfd(fd)) == NULL)
d176 2
@


1.20
log
@do not leak confd on malloc failure in control_accept()
found by Igor Zinovik <zinovik@@cs.karelia.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2007/10/13 13:21:24 claudio Exp $ */
d191 1
a191 1
	int		 n;
@


1.19
log
@Funny typo, it is fib not fip so adjust function name.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2007/03/21 10:54:30 claudio Exp $ */
d132 1
@


1.18
log
@Add support for RFC 3137: OSPF Stub Router Advertisement
This allows ospfd to announce networks without the need to transit traffic.
stub router is enabled if the fib is not coupled, net.inet.ip.forwarding is
not 1 or if the stub router global config option is set to yes.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.17 2007/03/19 10:03:25 henning Exp $ */
d228 1
a228 1
			ospfe_fip_update(imsg.hdr.type);
@


1.17
log
@when our red/recv/recvmsg in imsg_read gives EINTR or EAGAIN, do not
signal "connection closed" upstream.
spotted by Valentin Kozamernik <tin@@komna.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2007/01/23 17:39:33 claudio Exp $ */
d228 2
@


1.16
log
@Typo in fatal() message found by dunceor @@ gmail dot com
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2006/04/25 08:00:22 claudio Exp $ */
d200 1
a200 1
		if ((n = imsg_read(&c->ibuf)) <= 0) {
@


1.15
log
@Mark event handlers with ARGSUSED to please lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2006/03/21 17:49:00 claudio Exp $ */
d294 1
a294 1
		fatal("fnctl F_GETFL");
d302 1
a302 1
		fatal("fnctl F_SETFL");
@


1.14
log
@Kill debug message that floods the log if ospfctl is killed while dumping
large tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2006/02/10 18:30:47 claudio Exp $ */
d111 1
d184 1
@


1.13
log
@ospfd does not need fd passing via the imsg framework so remove that code
and remove other unneeded functions that are only used in bgpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2005/10/18 15:42:15 claudio Exp $ */
d279 1
a279 2
	if ((c = control_connbypid(imsg->hdr.pid)) == NULL) {
		log_debug("control_imsg_relay: no connection pid");
a280 1
	}
@


1.12
log
@Simplify code a bit. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2005/05/12 19:10:12 norby Exp $ */
d244 1
a244 1
				    0, -1, NULL, 0);
d284 1
a284 1
	return (imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid, -1,
@


1.11
log
@Add "show database asbr/external/network/router/self-originate/summary"
to ospfctl.

Show detailed information about the LSAs in the Link State Database.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2005/03/26 13:35:16 claudio Exp $ */
d227 1
d254 2
a261 6
			break;
		case IMSG_CTL_SHOW_RIB:
		case IMSG_CTL_SHOW_SUM:
			c->ibuf.pid = imsg.hdr.pid;
			ospfe_imsg_compose_rde(imsg.hdr.type, 0, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
@


1.10
log
@Implement the IMSG_CTL_IFINFO bits correctly. This is needed for
"ospfctl show fib interface".
OK henning@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2005/03/22 22:13:48 norby Exp $ */
d247 6
@


1.9
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2005/03/15 22:03:56 claudio Exp $ */
d231 1
@


1.8
log
@Add control messages for the show fib commands.
OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2005/03/15 16:59:45 claudio Exp $ */
d232 1
a232 1
			ospfe_imsg_compose_parent(imsg.hdr.type, 
@


1.7
log
@First close() than unlink().
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2005/03/14 18:21:29 norby Exp $ */
d228 7
@


1.6
log
@Add "show summary" to ospfctl.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2005/03/14 16:57:41 claudio Exp $ */
d77 1
a78 1
		close(fd);
@


1.5
log
@unlink() control socket in error path. Spotted by Theo at FOSDEM.
Was way too long in one of my trees.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2005/03/12 11:03:05 norby Exp $ */
d247 1
@


1.4
log
@Add "show rib" and "show rib detail" to ospfctl.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2005/03/11 15:48:58 deraadt Exp $ */
d77 1
@


1.3
log
@Small K&F.

ok henning@@
@
text
@d245 5
@


1.2
log
@move umask() song and dance closer around the bind, being more careful about errors; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2005/01/28 14:05:40 claudio Exp $ */
a227 1

@


1.1
log
@Welcome ospfd
started by Esben Norby some time ago by using the imsg/three process framework
of bgpd. He implemented the basic concept plus the ospf finite state machines.
Later I joined and helped him cleanup, debug and extend his work.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.
status:
The basic protocol works for broadcast networks and the LS database is
synchronized and updated. It is not possible to be DR or BDR on a network
and other interface types like point-to-point are not yet supported.
The shortest path tree is not calculated and so no routing information is
exchanged with the kernel FIB.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a54 1
	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
d66 1
d70 1
d73 1
a79 2

	umask(old_umask);
@

