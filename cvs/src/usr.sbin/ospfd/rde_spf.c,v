head	1.76;
access;
symbols
	OPENBSD_6_2:1.76.0.10
	OPENBSD_6_2_BASE:1.76
	OPENBSD_6_1:1.76.0.8
	OPENBSD_6_1_BASE:1.76
	OPENBSD_6_0:1.76.0.4
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.76.0.2
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.75.0.14
	OPENBSD_5_8_BASE:1.75
	OPENBSD_5_7:1.75.0.6
	OPENBSD_5_7_BASE:1.75
	OPENBSD_5_6:1.75.0.10
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.75.0.8
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.75.0.4
	OPENBSD_5_4_BASE:1.75
	OPENBSD_5_3:1.75.0.2
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.74.0.2
	OPENBSD_5_2_BASE:1.74
	OPENBSD_5_1_BASE:1.73
	OPENBSD_5_1:1.73.0.4
	OPENBSD_5_0:1.73.0.2
	OPENBSD_5_0_BASE:1.73
	OPENBSD_4_9:1.69.0.6
	OPENBSD_4_9_BASE:1.69
	OPENBSD_4_8:1.69.0.4
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.69.0.2
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.67.0.6
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.67.0.2
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.66.0.4
	OPENBSD_4_4_BASE:1.66
	OPENBSD_4_3:1.66.0.2
	OPENBSD_4_3_BASE:1.66
	OPENBSD_4_2:1.63.0.2
	OPENBSD_4_2_BASE:1.63
	OPENBSD_4_1:1.58.0.2
	OPENBSD_4_1_BASE:1.58
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7;
locks; strict;
comment	@ * @;


1.76
date	2015.11.22.13.09.10;	author claudio;	state Exp;
branches;
next	1.75;
commitid	pxM0r18iZwdhX0Ks;

1.75
date	2012.09.18.18.58.56;	author bluhm;	state Exp;
branches;
next	1.74;

1.74
date	2012.04.04.19.20.44;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2011.05.24.20.21.51;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2011.05.09.12.24.41;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2011.05.02.11.45.55;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2011.03.24.08.36.00;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2010.02.16.08.22.42;	author dlg;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.12.22.19.33;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2009.01.07.21.16.36;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2008.02.11.12.37.37;	author norby;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.01.08.35.12;	author norby;	state Exp;
branches;
next	1.64;

1.64
date	2007.09.16.15.00.11;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2007.08.06.11.32.34;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.19.16.45.15;	author reyk;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.12.06.30.08;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.10.13.26.39;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.02.16.26.03;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2007.01.29.13.23.05;	author norby;	state Exp;
branches;
next	1.57;

1.57
date	2007.01.29.13.04.13;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2007.01.24.12.05.10;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.06.13.03.39;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.30.22.15.55;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2006.04.25.19.27.36;	author norby;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.22.16.01.20;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.21.08.36.27;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.13.09.36.06;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.24.21.06.47;	author norby;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2006.02.10.13.00.49;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.02.09.20.47.20;	author norby;	state Exp;
branches;
next	1.46;

1.46
date	2006.02.02.15.10.57;	author norby;	state Exp;
branches;
next	1.45;

1.45
date	2006.02.01.20.24.08;	author norby;	state Exp;
branches;
next	1.44;

1.44
date	2006.02.01.19.56.15;	author norby;	state Exp;
branches;
next	1.43;

1.43
date	2006.02.01.18.38.51;	author norby;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.26.15.05.08;	author norby;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.24.20.27.04;	author norby;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.24.20.06.03;	author norby;	state Exp;
branches;
next	1.39;

1.39
date	2006.01.24.18.31.32;	author norby;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.02.12.21.31;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.14.11.48.05;	author norby;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.12.18.18.24;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.04.14.37.26;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.04.10.46.23;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.01.19.09.34;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.30.21.02.35;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.08.12.22.48;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.08.08.51.47;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.27.18.59.41;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2005.06.27.17.59.36;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.26.23.50.10;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.26.20.44.44;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.28.17.49.59;	author norby;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.27.01.02.04;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.27.00.56.35;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.27.00.50.50;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.26.23.31.04;	author norby;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.26.23.23.39;	author norby;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.26.23.11.53;	author norby;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.26.22.44.24;	author norby;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.24.06.55.21;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.23.23.03.07;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.23.22.26.45;	author norby;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.22.18.05.42;	author norby;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.12.20.57.01;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.12.20.53.02;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.12.19.32.46;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.05.15.27.34;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.23.20.15.50;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.22.22.13.48;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.17.16.46.15;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.14.18.21.29;	author norby;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.12.11.03.05;	author norby;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.12.10.49.12;	author norby;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.08.20.12.18;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.02.16.17.04;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.27.08.21.15;	author norby;	state Exp;
branches;
next	;

1.49.2.1
date	2006.05.04.22.19.03;	author brad;	state Exp;
branches;
next	;


desc
@@


1.76
log
@Improve ABR support especially for self-originated stub networks.
This seems to solve the last issues people reported when using ospfd
in multiple areas. OK sthen@@ prodding by deraadt@@
@
text
@/*	$OpenBSD: rde_spf.c,v 1.75 2012/09/18 18:58:56 bluhm Exp $ */

/*
 * Copyright (c) 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <err.h>
#include <stdlib.h>
#include <string.h>

#include "ospfd.h"
#include "ospf.h"
#include "log.h"
#include "rde.h"

extern struct ospfd_conf	*rdeconf;
TAILQ_HEAD(, vertex)		 cand_list;
RB_HEAD(rt_tree, rt_node)	 rt;
RB_PROTOTYPE(rt_tree, rt_node, entry, rt_compare)
RB_GENERATE(rt_tree, rt_node, entry, rt_compare)
struct vertex			*spf_root = NULL;

void	 calc_nexthop(struct vertex *, struct vertex *,
	     struct area *, struct lsa_rtr_link *);
void	 rt_nexthop_clear(struct rt_node *);
void	 rt_nexthop_add(struct rt_node *, struct v_nexthead *, u_int8_t,
	     struct in_addr);
void	 rt_update(struct in_addr, u_int8_t, struct v_nexthead *, u_int8_t,
	     u_int32_t, u_int32_t, struct in_addr, struct in_addr,
	     enum path_type, enum dst_type, u_int8_t, u_int32_t);
void	 rt_invalidate(struct area *);
struct lsa_rtr_link	*get_rtr_link(struct vertex *, int);
struct lsa_net_link	*get_net_link(struct vertex *, int);
int	 linked(struct vertex *, struct vertex *);

void
spf_calc(struct area *area)
{
	struct vertex		*v, *w;
	struct lsa_rtr_link	*rtr_link = NULL;
	struct lsa_net_link	*net_link;
	u_int32_t		 d;
	int			 i;
	struct in_addr		 addr;

	/* clear SPF tree */
	spf_tree_clr(area);
	cand_list_clr();

	/* initialize SPF tree */
	if ((v = spf_root = lsa_find_area(area, LSA_TYPE_ROUTER,
	    rde_router_id(), rde_router_id())) == NULL) {
		/* empty area because no interface is active */
		return;
	}

	area->transit = 0;
	spf_root->cost = 0;
	w = NULL;

	/* make sure the spf root has a nexthop */
	vertex_nexthop_clear(spf_root);
	vertex_nexthop_add(spf_root, spf_root, 0);

	/* calculate SPF tree */
	do {
		/* loop links */
		for (i = 0; i < lsa_num_links(v); i++) {
			switch (v->type) {
			case LSA_TYPE_ROUTER:
				rtr_link = get_rtr_link(v, i);
				switch (rtr_link->type) {
				case LINK_TYPE_STUB_NET:
					/* skip */
					continue;
				case LINK_TYPE_POINTTOPOINT:
				case LINK_TYPE_VIRTUAL:
					/* find router LSA */
					w = lsa_find_area(area, LSA_TYPE_ROUTER,
					    rtr_link->id, rtr_link->id);
					break;
				case LINK_TYPE_TRANSIT_NET:
					/* find network LSA */
					w = lsa_find_net(area, rtr_link->id);
					break;
				default:
					fatalx("spf_calc: invalid link type");
				}
				break;
			case LSA_TYPE_NETWORK:
				net_link = get_net_link(v, i);
				/* find router LSA */
				w = lsa_find_area(area, LSA_TYPE_ROUTER,
				    net_link->att_rtr, net_link->att_rtr);
				break;
			default:
				fatalx("spf_calc: invalid LSA type");
			}

			if (w == NULL)
				continue;

			if (w->lsa->hdr.age == MAX_AGE)
				continue;

			if (!linked(w, v)) {
				addr.s_addr = htonl(w->ls_id);
				log_debug("spf_calc: w id %s type %d has ",
				    inet_ntoa(addr), w->type);
				addr.s_addr = htonl(v->ls_id);
				log_debug("    no link to v id %s type %d",
				    inet_ntoa(addr), v->type);
				continue;
			}

			if (v->type == LSA_TYPE_ROUTER)
				d = v->cost + ntohs(rtr_link->metric);
			else
				d = v->cost;

			if (cand_list_present(w)) {
				if (d > w->cost)
					continue;
				if (d < w->cost) {
					w->cost = d;
					vertex_nexthop_clear(w);
					calc_nexthop(w, v, area, rtr_link);
					/*
					 * need to readd to candidate list
					 * because the list is sorted
					 */
					TAILQ_REMOVE(&cand_list, w, cand);
					cand_list_add(w);
				} else
					/* equal cost path */
					calc_nexthop(w, v, area, rtr_link);
			} else if (w->cost == LS_INFINITY && d < LS_INFINITY) {
				w->cost = d;

				vertex_nexthop_clear(w);
				calc_nexthop(w, v, area, rtr_link);
				cand_list_add(w);
			}
		}

		/* get next vertex */
		v = cand_list_pop();
		w = NULL;
	} while (v != NULL);

	/* spf_dump(area); */
	log_debug("spf_calc: area %s calculated", inet_ntoa(area->id));

	area->num_spf_calc++;
	start_spf_timer();
}

void
rt_calc(struct vertex *v, struct area *area, struct ospfd_conf *conf)
{
	struct vertex		*w;
	struct v_nexthop	*vn;
	struct lsa_rtr_link	*rtr_link = NULL;
	int			 i;
	struct in_addr		 addr, adv_rtr;

	lsa_age(v);
	if (ntohs(v->lsa->hdr.age) == MAX_AGE)
		return;

	switch (v->type) {
	case LSA_TYPE_ROUTER:
		/* stub networks */
		if (v->cost >= LS_INFINITY)
			return;

		for (i = 0; i < lsa_num_links(v); i++) {
			rtr_link = get_rtr_link(v, i);
			if (rtr_link->type != LINK_TYPE_STUB_NET)
				continue;

			addr.s_addr = rtr_link->id;
			adv_rtr.s_addr = htonl(v->adv_rtr);

			rt_update(addr, mask2prefixlen(rtr_link->data),
			    &v->nexthop, v->type,
			    v->cost + ntohs(rtr_link->metric), 0,
			    area->id, adv_rtr, PT_INTRA_AREA, DT_NET,
			    v->lsa->data.rtr.flags, 0);
		}

		/* router, only add border and as-external routers */
		if ((v->lsa->data.rtr.flags & (OSPF_RTR_B | OSPF_RTR_E)) == 0)
			return;

		addr.s_addr = htonl(v->ls_id);
		adv_rtr.s_addr = htonl(v->adv_rtr);

		rt_update(addr, 32, &v->nexthop, v->type, v->cost, 0, area->id,
		    adv_rtr, PT_INTRA_AREA, DT_RTR, v->lsa->data.rtr.flags, 0);
		break;
	case LSA_TYPE_NETWORK:
		if (v->cost >= LS_INFINITY)
			return;

		addr.s_addr = htonl(v->ls_id) & v->lsa->data.net.mask;
		adv_rtr.s_addr = htonl(v->adv_rtr);
		rt_update(addr, mask2prefixlen(v->lsa->data.net.mask),
		    &v->nexthop, v->type, v->cost, 0, area->id, adv_rtr,
		    PT_INTRA_AREA, DT_NET, 0, 0);
		break;
	case LSA_TYPE_SUM_NETWORK:
	case LSA_TYPE_SUM_ROUTER:
		/* if ABR only look at area 0.0.0.0 LSA */
		if (area_border_router(conf) && area->id.s_addr != INADDR_ANY)
			return;

		/* ignore self-originated stuff */
		if (v->self)
			return;

		/* TODO type 3 area address range check */

		if ((w = lsa_find_area(area, LSA_TYPE_ROUTER,
		    htonl(v->adv_rtr),
		    htonl(v->adv_rtr))) == NULL)
			return;

		/* copy nexthops */
		vertex_nexthop_clear(v);	/* XXX needed ??? */
		TAILQ_FOREACH(vn, &w->nexthop, entry)
			vertex_nexthop_add(v, w, vn->nexthop.s_addr);

		v->cost = w->cost +
		    (ntohl(v->lsa->data.sum.metric) & LSA_METRIC_MASK);

		if (v->cost >= LS_INFINITY)
			return;

		adv_rtr.s_addr = htonl(v->adv_rtr);
		if (v->type == LSA_TYPE_SUM_NETWORK) {
			addr.s_addr = htonl(v->ls_id) & v->lsa->data.sum.mask;
			rt_update(addr, mask2prefixlen(v->lsa->data.sum.mask),
			    &v->nexthop, v->type, v->cost, 0, area->id, adv_rtr,
			    PT_INTER_AREA, DT_NET, 0, 0);
		} else {
			addr.s_addr = htonl(v->ls_id);
			rt_update(addr, 32, &v->nexthop, v->type, v->cost, 0,
			    area->id, adv_rtr, PT_INTER_AREA, DT_RTR,
			    v->lsa->data.rtr.flags, 0);
		}

		break;
	case LSA_TYPE_AREA_OPAQ:
		/* nothing to calculate */
		break;
	default:
		/* as-external LSA are stored in a different tree */
		fatalx("rt_calc: invalid LSA type");
	}
}

void
asext_calc(struct vertex *v)
{
	struct rt_node		*r;
	struct rt_nexthop	*rn;
	u_int32_t		 cost2;
	struct in_addr		 addr, adv_rtr, a;
	enum path_type		 type;

	lsa_age(v);
	if (ntohs(v->lsa->hdr.age) == MAX_AGE ||
	    (ntohl(v->lsa->data.asext.metric) & LSA_METRIC_MASK) >=
	    LS_INFINITY)
		return;

	switch (v->type) {
	case LSA_TYPE_EXTERNAL:
		/* ignore self-originated stuff */
		if (v->self)
			return;

		if ((r = rt_lookup(DT_RTR, htonl(v->adv_rtr))) == NULL)
			return;

		/* XXX RFC1583Compatibility */
		if (v->lsa->data.asext.fw_addr != 0 &&
		    (r = rt_lookup(DT_NET, v->lsa->data.asext.fw_addr)) == NULL)
			return;

		if (v->lsa->data.asext.fw_addr != 0 &&
		    r->p_type != PT_INTRA_AREA &&
		    r->p_type != PT_INTER_AREA)
			return;

		if (ntohl(v->lsa->data.asext.metric) & LSA_ASEXT_E_FLAG) {
			v->cost = r->cost;
			cost2 = ntohl(v->lsa->data.asext.metric) &
			    LSA_METRIC_MASK;
			type = PT_TYPE2_EXT;
		} else {
			v->cost = r->cost + (ntohl(v->lsa->data.asext.metric) &
			     LSA_METRIC_MASK);
			cost2 = 0;
			type = PT_TYPE1_EXT;
		}

		a.s_addr = 0;
		adv_rtr.s_addr = htonl(v->adv_rtr);
		addr.s_addr = htonl(v->ls_id) & v->lsa->data.asext.mask;

		vertex_nexthop_clear(v);
		TAILQ_FOREACH(rn, &r->nexthop, entry) {
			if (rn->invalid)
				continue;

			/*
			 * if a fw_addr is specified and the nexthop
			 * is directly connected then it is possible to
			 * send traffic directly to fw_addr.
			 */
			if (v->lsa->data.asext.fw_addr != 0 && rn->connected)
				vertex_nexthop_add(v, NULL,
				    v->lsa->data.asext.fw_addr);
			else
				vertex_nexthop_add(v, NULL, rn->nexthop.s_addr);
		}

		rt_update(addr, mask2prefixlen(v->lsa->data.asext.mask),
		    &v->nexthop, v->type, v->cost, cost2, a, adv_rtr, type,
		    DT_NET, 0, ntohl(v->lsa->data.asext.ext_tag));
		break;
	case LSA_TYPE_AS_OPAQ:
		/* nothing to calculate */
		break;
	default:
		fatalx("asext_calc: invalid LSA type");
	}
}

void
spf_tree_clr(struct area *area)
{
	struct lsa_tree	*tree = &area->lsa_tree;
	struct vertex	*v;

	RB_FOREACH(v, lsa_tree, tree) {
		v->cost = LS_INFINITY;
		vertex_nexthop_clear(v);
	}
}

void
calc_nexthop(struct vertex *dst, struct vertex *parent,
    struct area *area, struct lsa_rtr_link *rtr_link)
{
	struct v_nexthop	*vn;
	struct iface		*iface;
	int			 i;

	/* case 1 */
	if (parent == spf_root) {
		switch (dst->type) {
		case LSA_TYPE_ROUTER:
			if (rtr_link->type != LINK_TYPE_POINTTOPOINT)
				fatalx("inconsistent SPF tree");
			LIST_FOREACH(iface, &area->iface_list, entry) {
				if (rtr_link->data == iface->addr.s_addr) {
					vertex_nexthop_add(dst, parent,
					    iface->dst.s_addr);
					return;
				}
			}
			fatalx("no interface found for interface");
		case LSA_TYPE_NETWORK:
			switch (rtr_link->type) {
			case LINK_TYPE_POINTTOPOINT:
			case LINK_TYPE_STUB_NET:
				/* ignore */
				break;
			case LINK_TYPE_TRANSIT_NET:
				if ((htonl(dst->ls_id) &
				    dst->lsa->data.net.mask) ==
				    (rtr_link->data &
				     dst->lsa->data.net.mask)) {
					vertex_nexthop_add(dst, parent,
					    rtr_link->data);
				}
				break;
			default:
				fatalx("calc_nexthop: invalid link "
				    "type");
			}
			return;
		default:
			fatalx("calc_nexthop: invalid dst type");
		}
		return;
	}

	/* case 2 */
	if (parent->type == LSA_TYPE_NETWORK && dst->type == LSA_TYPE_ROUTER) {
		TAILQ_FOREACH(vn, &parent->nexthop, entry) {
			if (vn->prev == spf_root) {
				for (i = 0; i < lsa_num_links(dst); i++) {
					rtr_link = get_rtr_link(dst, i);
					if ((rtr_link->type ==
					    LINK_TYPE_TRANSIT_NET) &&
					    (rtr_link->data &
					    parent->lsa->data.net.mask) ==
					    (htonl(parent->ls_id) &
					    parent->lsa->data.net.mask))
						vertex_nexthop_add(dst, parent,
						    rtr_link->data);
				}
			} else {
				vertex_nexthop_add(dst, parent,
				    vn->nexthop.s_addr);
			}
		}
		return;
	}

	/* case 3 */
	TAILQ_FOREACH(vn, &parent->nexthop, entry)
		vertex_nexthop_add(dst, parent, vn->nexthop.s_addr);
}

/* candidate list */
void
cand_list_init(void)
{
	TAILQ_INIT(&cand_list);
}

void
cand_list_add(struct vertex *v)
{
	struct vertex	*c = NULL;

	TAILQ_FOREACH(c, &cand_list, cand) {
		if (c->cost > v->cost) {
			TAILQ_INSERT_BEFORE(c, v, cand);
			return;
		} else if (c->cost == v->cost && c->type == LSA_TYPE_ROUTER &&
		    v->type == LSA_TYPE_NETWORK) {
			TAILQ_INSERT_BEFORE(c, v, cand);
			return;
		}
	}
	TAILQ_INSERT_TAIL(&cand_list, v, cand);
}

struct vertex *
cand_list_pop(void)
{
	struct vertex	*c;

	if ((c = TAILQ_FIRST(&cand_list)) != NULL) {
		TAILQ_REMOVE(&cand_list, c, cand);
	}

	return (c);
}

int
cand_list_present(struct vertex *v)
{
	struct vertex	*c;

	TAILQ_FOREACH(c, &cand_list, cand) {
		if (c == v)
			return (1);
	}

	return (0);
}

void
cand_list_clr(void)
{
	struct vertex *c;

	while ((c = TAILQ_FIRST(&cand_list)) != NULL) {
		TAILQ_REMOVE(&cand_list, c, cand);
	}
}

/* timers */
/* ARGSUSED */
void
spf_timer(int fd, short event, void *arg)
{
	struct vertex		*v;
	struct ospfd_conf	*conf = arg;
	struct area		*area;
	struct rt_node		*r;

	switch (conf->spf_state) {
	case SPF_IDLE:
		fatalx("spf_timer: invalid state IDLE");
	case SPF_HOLDQUEUE:
		conf->spf_state = SPF_DELAY;
		/* FALLTHROUGH */
	case SPF_DELAY:
		LIST_FOREACH(area, &conf->area_list, entry) {
			if (area->dirty) {
				/* invalidate RIB entries of this area */
				rt_invalidate(area);

				/* calculate SPF tree */
				spf_calc(area);

				/* calculate route table */
				RB_FOREACH(v, lsa_tree, &area->lsa_tree) {
					rt_calc(v, area, conf);
				}

				area->dirty = 0;
			}
		}

		/* calculate as-external routes, first invalidate them */
		rt_invalidate(NULL);
		RB_FOREACH(v, lsa_tree, &asext_tree) {
			asext_calc(v);
		}

		RB_FOREACH(r, rt_tree, &rt) {
			LIST_FOREACH(area, &conf->area_list, entry)
				rde_summary_update(r, area);

			if (r->d_type != DT_NET)
				continue;

			if (r->invalid)
				rde_send_delete_kroute(r);
			else
				rde_send_change_kroute(r);
		}

		LIST_FOREACH(area, &conf->area_list, entry) {
			lsa_generate_stub_sums(area);
			lsa_remove_invalid_sums(area);
		}

		start_spf_holdtimer(conf);
		break;
	case SPF_HOLD:
		conf->spf_state = SPF_IDLE;
		break;
	default:
		fatalx("spf_timer: unknown state");
	}
}

void
start_spf_timer(void)
{
	struct timeval	tv;

	switch (rdeconf->spf_state) {
	case SPF_IDLE:
		timerclear(&tv);
		tv.tv_sec = rdeconf->spf_delay / 1000;
		tv.tv_usec = (rdeconf->spf_delay % 1000) * 1000;
		rdeconf->spf_state = SPF_DELAY;
		if (evtimer_add(&rdeconf->ev, &tv) == -1)
			fatal("start_spf_timer");
		break;
	case SPF_DELAY:
		/* ignore */
		break;
	case SPF_HOLD:
		rdeconf->spf_state = SPF_HOLDQUEUE;
		break;
	case SPF_HOLDQUEUE:
		/* ignore */
		break;
	default:
		fatalx("start_spf_timer: invalid spf_state");
	}
}

void
stop_spf_timer(struct ospfd_conf *conf)
{
	if (evtimer_del(&conf->ev) == -1)
		fatal("stop_spf_timer");
}

void
start_spf_holdtimer(struct ospfd_conf *conf)
{
	struct timeval	tv;

	switch (conf->spf_state) {
	case SPF_DELAY:
		timerclear(&tv);
		tv.tv_sec = rdeconf->spf_hold_time / 1000;
		tv.tv_usec = (rdeconf->spf_hold_time % 1000) * 1000;
		conf->spf_state = SPF_HOLD;
		if (evtimer_add(&conf->ev, &tv) == -1)
			fatal("start_spf_holdtimer");
		break;
	case SPF_IDLE:
	case SPF_HOLD:
	case SPF_HOLDQUEUE:
		fatalx("start_spf_holdtimer: invalid state");
	default:
		fatalx("start_spf_holdtimer: unknown state");
	}
}

/* route table */
void
rt_init(void)
{
	RB_INIT(&rt);
}

int
rt_compare(struct rt_node *a, struct rt_node *b)
{
	if (ntohl(a->prefix.s_addr) < ntohl(b->prefix.s_addr))
		return (-1);
	if (ntohl(a->prefix.s_addr) > ntohl(b->prefix.s_addr))
		return (1);
	if (a->prefixlen < b->prefixlen)
		return (-1);
	if (a->prefixlen > b->prefixlen)
		return (1);
	if (a->d_type > b->d_type)
		return (-1);
	if (a->d_type < b->d_type)
		return (1);
	return (0);
}

struct rt_node *
rt_find(in_addr_t prefix, u_int8_t prefixlen, enum dst_type d_type)
{
	struct rt_node	s;

	s.prefix.s_addr = prefix;
	s.prefixlen = prefixlen;
	s.d_type = d_type;

	return (RB_FIND(rt_tree, &rt, &s));
}

int
rt_insert(struct rt_node *r)
{
	if (RB_INSERT(rt_tree, &rt, r) != NULL) {
		log_warnx("rt_insert failed for %s/%u",
		    inet_ntoa(r->prefix), r->prefixlen);
		free(r);
		return (-1);
	}

	return (0);
}

int
rt_remove(struct rt_node *r)
{
	if (RB_REMOVE(rt_tree, &rt, r) == NULL) {
		log_warnx("rt_remove failed for %s/%u",
		    inet_ntoa(r->prefix), r->prefixlen);
		return (-1);
	}

	rt_nexthop_clear(r);
	free(r);
	return (0);
}

void
rt_invalidate(struct area *area)
{
	struct rt_node		*r, *nr;
	struct rt_nexthop	*rn, *nrn;

	for (r = RB_MIN(rt_tree, &rt); r != NULL; r = nr) {
		nr = RB_NEXT(rt_tree, &rt, r);
		if (area == NULL) {
			/* look only at as_ext routes */
			if (r->p_type != PT_TYPE1_EXT &&
			    r->p_type != PT_TYPE2_EXT)
				continue;
		} else {
			/* ignore all as_ext routes */
			if (r->p_type == PT_TYPE1_EXT ||
			    r->p_type == PT_TYPE2_EXT)
				continue;

			/* look only at routes matching the area */
			if (r->area.s_addr != area->id.s_addr)
				continue;
		}
		r->invalid = 1;
		for (rn = TAILQ_FIRST(&r->nexthop); rn != NULL; rn = nrn) {
			nrn = TAILQ_NEXT(rn, entry);
			if (rn->invalid) {
				TAILQ_REMOVE(&r->nexthop, rn, entry);
				free(rn);
			} else
				rn->invalid = 1;
		}
		if (TAILQ_EMPTY(&r->nexthop))
			rt_remove(r);
	}
}

void
rt_nexthop_clear(struct rt_node *r)
{
	struct rt_nexthop	*rn;

	while ((rn = TAILQ_FIRST(&r->nexthop)) != NULL) {
		TAILQ_REMOVE(&r->nexthop, rn, entry);
		free(rn);
	}
}

void
rt_nexthop_add(struct rt_node *r, struct v_nexthead *vnh, u_int8_t type,
    struct in_addr adv_rtr)
{
	struct v_nexthop	*vn;
	struct rt_nexthop	*rn;
	struct timespec		 now;

	TAILQ_FOREACH(vn, vnh, entry) {
		TAILQ_FOREACH(rn, &r->nexthop, entry) {
			if (rn->nexthop.s_addr != vn->nexthop.s_addr)
				continue;

			rn->adv_rtr.s_addr = adv_rtr.s_addr;
			rn->connected = (type == LSA_TYPE_NETWORK &&
			    vn->prev == spf_root) || (vn->nexthop.s_addr == 0);
			rn->invalid = 0;

			r->invalid = 0;
			break;
		}
		if (rn)
			continue;

		if ((rn = calloc(1, sizeof(struct rt_nexthop))) == NULL)
			fatal("rt_nexthop_add");

		clock_gettime(CLOCK_MONOTONIC, &now);
		rn->nexthop.s_addr = vn->nexthop.s_addr;
		rn->adv_rtr.s_addr = adv_rtr.s_addr;
		rn->uptime = now.tv_sec;
		rn->connected = (type == LSA_TYPE_NETWORK &&
		    vn->prev == spf_root) || (vn->nexthop.s_addr == 0);
		rn->invalid = 0;

		r->invalid = 0;
		TAILQ_INSERT_TAIL(&r->nexthop, rn, entry);
	}
}

void
rt_clear(void)
{
	struct rt_node	*r;

	while ((r = RB_MIN(rt_tree, &rt)) != NULL)
		rt_remove(r);
}

void
rt_dump(struct in_addr area, pid_t pid, u_int8_t r_type)
{
	static struct ctl_rt	 rtctl;
	struct timespec		 now;
	struct rt_node		*r;
	struct rt_nexthop	*rn;

	clock_gettime(CLOCK_MONOTONIC, &now);

	RB_FOREACH(r, rt_tree, &rt) {
		if (r->invalid)
			continue;

		if (r->area.s_addr != area.s_addr)
			continue;

		switch (r_type) {
		case RIB_RTR:
			if (r->d_type != DT_RTR)
				continue;
			break;
		case RIB_NET:
			if (r->d_type != DT_NET)
				continue;
			if (r->p_type == PT_TYPE1_EXT ||
			    r->p_type == PT_TYPE2_EXT)
				continue;
			break;
		case RIB_EXT:
			if (r->p_type != PT_TYPE1_EXT &&
			    r->p_type != PT_TYPE2_EXT)
				continue;
			break;
		default:
			fatalx("rt_dump: invalid RIB type");
		}

		bzero(&rtctl, sizeof(rtctl));
		rtctl.prefix.s_addr = r->prefix.s_addr;
		rtctl.area.s_addr = r->area.s_addr;
		rtctl.cost = r->cost;
		rtctl.cost2 = r->cost2;
		rtctl.p_type = r->p_type;
		rtctl.d_type = r->d_type;
		rtctl.flags = r->flags;
		rtctl.prefixlen = r->prefixlen;

		TAILQ_FOREACH(rn, &r->nexthop, entry) {
			if (rn->invalid)
				continue;

			rtctl.connected = rn->connected;
			rtctl.nexthop.s_addr = rn->nexthop.s_addr;
			rtctl.adv_rtr.s_addr = rn->adv_rtr.s_addr;
			rtctl.uptime = now.tv_sec - rn->uptime;

			rde_imsg_compose_ospfe(IMSG_CTL_SHOW_RIB, 0, pid,
			    &rtctl, sizeof(rtctl));
		}
	}
}

void
rt_update(struct in_addr prefix, u_int8_t prefixlen, struct v_nexthead *vnh,
     u_int8_t v_type, u_int32_t cost, u_int32_t cost2, struct in_addr area,
     struct in_addr adv_rtr, enum path_type p_type, enum dst_type d_type,
     u_int8_t flags, u_int32_t tag)
{
	struct rt_node		*rte;
	struct rt_nexthop	*rn;
	int			 better = 0, equal = 0;

	if ((rte = rt_find(prefix.s_addr, prefixlen, d_type)) == NULL) {
		if ((rte = calloc(1, sizeof(struct rt_node))) == NULL)
			fatal("rt_update");

		TAILQ_INIT(&rte->nexthop);
		rte->prefix.s_addr = prefix.s_addr;
		rte->prefixlen = prefixlen;
		rte->cost = cost;
		rte->cost2 = cost2;
		rte->area = area;
		rte->p_type = p_type;
		rte->d_type = d_type;
		rte->flags = flags;
		rte->ext_tag = tag;

		rt_nexthop_add(rte, vnh, v_type, adv_rtr);

		rt_insert(rte);
	} else {
		/* order:
		 * 1. intra-area
		 * 2. inter-area
		 * 3. type 1 as ext
		 * 4. type 2 as ext
		 */
		if (rte->invalid)	/* everything is better than invalid */
			better = 1;
		else if (p_type < rte->p_type)
			better = 1;
		else if (p_type == rte->p_type)
			switch (p_type) {
			case PT_INTRA_AREA:
			case PT_INTER_AREA:
				if (cost < rte->cost)
					better = 1;
				else if (cost == rte->cost &&
				    rte->area.s_addr == area.s_addr)
					equal = 1;
				break;
			case PT_TYPE1_EXT:
				/* XXX rfc1583 compat */
				if (cost < rte->cost)
					better = 1;
				else if (cost == rte->cost)
					equal = 1;
				break;
			case PT_TYPE2_EXT:
				if (cost2 < rte->cost2)
					better = 1;
				/* XXX rfc1583 compat */
				else if (cost2 == rte->cost2 &&
				    cost < rte->cost)
					better = 1;
				else if (cost2 == rte->cost2 &&
				    cost == rte->cost)
					equal = 1;
				break;
			}

		if (better) {
			TAILQ_FOREACH(rn, &rte->nexthop, entry)
				rn->invalid = 1;

			rte->area = area;
			rte->cost = cost;
			rte->cost2 = cost2;
			rte->p_type = p_type;
			rte->flags = flags;
			rte->ext_tag = tag;
		}

		if (equal || better)
			rt_nexthop_add(rte, vnh, v_type, adv_rtr);
	}
}

struct rt_node *
rt_lookup(enum dst_type type, in_addr_t addr)
{
	struct rt_node	*rn;
	u_int8_t	 i = 32;

	if (type == DT_RTR) {
		rn = rt_find(addr, 32, type);
		if (rn && rn->invalid == 0)
			return (rn);
		return (NULL);
	}

	/* type == DT_NET */
	do {
		if ((rn = rt_find(addr & prefixlen2mask(i), i, type)) &&
		    rn->invalid == 0)
			return (rn);
	} while (i-- != 0);

	return (NULL);
}

/* router LSA links */
struct lsa_rtr_link *
get_rtr_link(struct vertex *v, int idx)
{
	struct lsa_rtr_link	*rtr_link = NULL;
	char			*buf = (char *)v->lsa;
	u_int16_t		 i, off, nlinks;

	if (v->type != LSA_TYPE_ROUTER)
		fatalx("get_rtr_link: invalid LSA type");

	off = sizeof(v->lsa->hdr) + sizeof(struct lsa_rtr);

	/* nlinks validated earlier by lsa_check() */
	nlinks = lsa_num_links(v);
	for (i = 0; i < nlinks; i++) {
		rtr_link = (struct lsa_rtr_link *)(buf + off);
		if (i == idx)
			return (rtr_link);

		off += sizeof(struct lsa_rtr_link) +
		    rtr_link->num_tos * sizeof(u_int32_t);
	}

	fatalx("get_rtr_link: index not found");
}

/* network LSA links */
struct lsa_net_link *
get_net_link(struct vertex *v, int idx)
{
	struct lsa_net_link	*net_link = NULL;
	char			*buf = (char *)v->lsa;
	u_int16_t		 i, off, nlinks;

	if (v->type != LSA_TYPE_NETWORK)
		fatalx("get_net_link: invalid LSA type");

	off = sizeof(v->lsa->hdr) + sizeof(u_int32_t);

	/* nlinks validated earlier by lsa_check() */
	nlinks = lsa_num_links(v);
	for (i = 0; i < nlinks; i++) {
		net_link = (struct lsa_net_link *)(buf + off);
		if (i == idx)
			return (net_link);

		off += sizeof(struct lsa_net_link);
	}

	fatalx("get_net_link: index not found");
}

/* misc */
int
linked(struct vertex *w, struct vertex *v)
{
	struct lsa_rtr_link	*rtr_link = NULL;
	struct lsa_net_link	*net_link = NULL;
	int			 i;

	switch (w->type) {
	case LSA_TYPE_ROUTER:
		for (i = 0; i < lsa_num_links(w); i++) {
			rtr_link = get_rtr_link(w, i);
			switch (v->type) {
			case LSA_TYPE_ROUTER:
				if (rtr_link->type == LINK_TYPE_POINTTOPOINT &&
				    rtr_link->id == htonl(v->ls_id))
					return (1);
				break;
			case LSA_TYPE_NETWORK:
				if (rtr_link->id == htonl(v->ls_id))
					return (1);
				break;
			default:
				fatalx("linked: invalid type");
			}
		}
		return (0);
	case LSA_TYPE_NETWORK:
		for (i = 0; i < lsa_num_links(w); i++) {
			net_link = get_net_link(w, i);
			switch (v->type) {
			case LSA_TYPE_ROUTER:
				if (net_link->att_rtr == htonl(v->ls_id))
					return (1);
				break;
			default:
				fatalx("linked: invalid type");
			}
		}
		return (0);
	default:
		fatalx("linked: invalid LSA type");
	}

	return (0);
}
@


1.75
log
@The if (!better && !equal) check is redundant as the same condition
is checked a few lines below again.  Fewer checks make the code
more readable.
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.74 2012/04/04 19:20:44 claudio Exp $ */
d25 1
d68 1
a68 1
	    rde_router_id(), rde_router_id())) == NULL)
d71 1
d77 4
d168 1
a168 2
	log_debug("spf_calc: area %s calculated",
	    inet_ntoa(area->id));
d190 1
a190 1
		if (v->cost >= LS_INFINITY || TAILQ_EMPTY(&v->nexthop))
d219 1
a219 1
		if (v->cost >= LS_INFINITY || TAILQ_EMPTY(&v->nexthop))
d253 1
a253 1
		if (v->cost >= LS_INFINITY || TAILQ_EMPTY(&v->nexthop))
d759 1
a759 1
			    vn->prev == spf_root);
d776 1
a776 1
		    vn->prev == spf_root);
d831 10
d845 1
a845 1
			rtctl.prefix.s_addr = r->prefix.s_addr;
a846 1
			rtctl.area.s_addr = r->area.s_addr;
a847 6
			rtctl.cost = r->cost;
			rtctl.cost2 = r->cost2;
			rtctl.p_type = r->p_type;
			rtctl.d_type = r->d_type;
			rtctl.flags = r->flags;
			rtctl.prefixlen = r->prefixlen;
a864 3

	if (vnh == NULL || TAILQ_EMPTY(vnh))	/* XXX remove */
		fatalx("rt_update: invalid nexthop");
@


1.74
log
@Both LSA_TYPE_AREA_OPAQ and LSA_TYPE_AS_OPAQ can be found when traversing
the LSDB. So adjust SPF calculation to not trigger a fatal.
Problem found and fix tested by Chris Wopat
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.73 2011/05/24 20:21:51 claudio Exp $ */
a918 3

		if (!better && !equal)
			return;
@


1.73
log
@Fix nexthop calculation for directly connected P2P links. connected
may only be set on directly connected networks but not on router
nodes which are used by the P2P links. Fix for PR 6597. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.72 2011/05/09 12:24:41 claudio Exp $ */
d265 3
d344 3
@


1.72
log
@First bits to support opaque LSA. Type-9, 10 and 11 are LSA that can
hold about any data you like and is used for things like greaceful
reload. Implement the basic redistribute logic and LSDB handling but
the data sent is currently not looked at.
Tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.71 2011/05/02 11:45:55 claudio Exp $ */
d41 1
a41 1
void	 rt_nexthop_add(struct rt_node *, struct v_nexthead *,
d43 1
a43 1
void	 rt_update(struct in_addr, u_int8_t, struct v_nexthead *,
d197 2
a198 1
			    &v->nexthop, v->cost + ntohs(rtr_link->metric), 0,
d210 1
a210 1
		rt_update(addr, 32, &v->nexthop, v->cost, 0, area->id,
d220 2
a221 2
		    &v->nexthop, v->cost, 0, area->id, adv_rtr, PT_INTRA_AREA,
		    DT_NET, 0, 0);
d255 1
a255 1
			    &v->nexthop, v->cost, 0, area->id, adv_rtr,
d259 2
a260 2
			rt_update(addr, 32, &v->nexthop, v->cost, 0, area->id,
			    adv_rtr, PT_INTER_AREA, DT_RTR,
d326 9
a334 8
			if (rn->connected && r->d_type == DT_NET) {
				if (v->lsa->data.asext.fw_addr != 0)
					vertex_nexthop_add(v, NULL,
					    v->lsa->data.asext.fw_addr);
				else
					vertex_nexthop_add(v, NULL,
					    htonl(v->adv_rtr));
			} else
d339 1
a339 1
		    &v->nexthop, v->cost, cost2, a, adv_rtr, type,
d734 1
a734 1
rt_nexthop_add(struct rt_node *r, struct v_nexthead *vnh,
d747 2
a748 1
			rn->connected = vn->prev == spf_root;
d764 2
a765 1
		rn->connected = vn->prev == spf_root;
d844 1
a844 1
     u_int32_t cost, u_int32_t cost2, struct in_addr area,
d870 1
a870 1
		rt_nexthop_add(rte, vnh, adv_rtr);
d930 1
a930 1
			rt_nexthop_add(rte, vnh, adv_rtr);
@


1.71
log
@More spring cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.70 2011/03/24 08:36:00 claudio Exp $ */
d66 2
a67 2
	if ((v = spf_root = lsa_find(area, LSA_TYPE_ROUTER, rde_router_id(),
	    rde_router_id())) == NULL)
d89 1
a89 1
					w = lsa_find(area, LSA_TYPE_ROUTER,
d103 1
a103 1
				w = lsa_find(area, LSA_TYPE_ROUTER,
d234 1
a234 1
		if ((w = lsa_find(area, LSA_TYPE_ROUTER,
@


1.70
log
@Fix some memory leaks. Mainly better cleanup on shutdown but the v_nexthop
leak is a runtime one.
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.69 2010/02/16 08:22:42 dlg Exp $ */
d38 12
a49 10
void		 calc_nexthop(struct vertex *, struct vertex *,
		     struct area *, struct lsa_rtr_link *);
void		 rt_nexthop_clear(struct rt_node *);
void		 rt_nexthop_add(struct rt_node *, struct v_nexthead *,
		     struct in_addr);
void		 rt_update(struct in_addr, u_int8_t, struct v_nexthead *,
		     u_int32_t, u_int32_t, struct in_addr, struct in_addr,
		     enum path_type, enum dst_type, u_int8_t, u_int32_t);
void		 rt_invalidate(struct area *);
int		 linked(struct vertex *, struct vertex *);
d1029 1
a1029 1
				fatalx("spf_calc: invalid type");
d1042 1
a1042 1
				fatalx("spf_calc: invalid type");
d1047 1
a1047 1
		fatalx("spf_calc: invalid LSA type");
@


1.69
log
@allow spf-delay and spf-holdtime to be specified in msec so ospfd can
better respond to rapid topology changes.

developed while working with joshua atterbury
ok claudio@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.68 2009/11/12 22:19:33 claudio Exp $ */
a37 2
void		 calc_nexthop_clear(struct vertex *);
void		 calc_nexthop_add(struct vertex *, struct vertex *, u_int32_t);
d134 1
a134 1
					calc_nexthop_clear(w);
d148 1
a148 1
				calc_nexthop_clear(w);
d238 1
a238 1
		calc_nexthop_clear(v);	/* XXX needed ??? */
d240 1
a240 1
			calc_nexthop_add(v, w, vn->nexthop.s_addr);
d318 1
a318 1
		calc_nexthop_clear(v);
d325 1
a325 1
					calc_nexthop_add(v, NULL,
d328 1
a328 1
					calc_nexthop_add(v, NULL,
d331 1
a331 1
				calc_nexthop_add(v, NULL, rn->nexthop.s_addr);
d351 1
a351 1
		calc_nexthop_clear(v);
a355 29
calc_nexthop_clear(struct vertex *v)
{
	struct v_nexthop	*vn;

	while ((vn = TAILQ_FIRST(&v->nexthop))) {
		TAILQ_REMOVE(&v->nexthop, vn, entry);
		free(vn);
	}
}

void
calc_nexthop_add(struct vertex *dst, struct vertex *parent, u_int32_t nexthop)
{
	struct v_nexthop	*vn;

	if (nexthop == 0)
		/* invalid nexthop, skip it */
		return;

	if ((vn = calloc(1, sizeof(*vn))) == NULL)
		fatal("calc_nexthop_add");

	vn->prev = parent;
	vn->nexthop.s_addr = nexthop;

	TAILQ_INSERT_TAIL(&dst->nexthop, vn, entry);
}

void
d371 1
a371 1
					calc_nexthop_add(dst, parent,
d388 1
a388 1
					calc_nexthop_add(dst, parent,
d415 1
a415 1
						calc_nexthop_add(dst, parent,
d419 1
a419 1
				calc_nexthop_add(dst, parent,
d428 1
a428 1
		calc_nexthop_add(dst, parent, vn->nexthop.s_addr);
@


1.68
log
@get_rtr_link and get_net_link are not supposed to fail and returning
NULL would be bad. So instead use a fatalx() in that impossible case.
After a discussion with deraadt@@ because of a parfait warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.67 2009/01/07 21:16:36 claudio Exp $ */
d598 2
a599 1
		tv.tv_sec = rdeconf->spf_delay;
d633 2
a634 1
		tv.tv_sec = conf->spf_hold_time;
@


1.67
log
@Full stub area support. This allows ABRs to announce a default network
summary LSA into stub areas so that these routers are able to reach the
outside of the area.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.66 2008/02/11 12:37:37 norby Exp $ */
d1004 1
a1004 1
	return (NULL);
d1030 1
a1030 1
	return (NULL);
@


1.66
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.65 2007/10/01 08:35:12 norby Exp $ */
a47 1
struct rt_node	*rt_lookup(enum dst_type, in_addr_t);
d575 2
a576 1
		LIST_FOREACH(area, &conf->area_list, entry)
d578 1
@


1.65
log
@fix alot of whitespace problems...
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.64 2007/09/16 15:00:11 claudio Exp $ */
d641 1
a641 1
		fatalx("spf_start_holdtimer: unknown state");
@


1.64
log
@Change the way nexthops are calculated on the root level. Instead of looking
from the target back and trying to figure the nexthop out, the link is searched
in the interface list and the info from the matiching interface is used.
This should solve the nexthop issues with setups having multiple point-to-point
links between two routers as reported on misc@@ some time ago.
tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.63 2007/08/06 11:32:34 claudio Exp $ */
d328 1
a328 1
					calc_nexthop_add(v, NULL, 
d331 1
a331 1
					calc_nexthop_add(v, NULL, 
@


1.63
log
@Fix two issues in the RIB calculation. First rt_nexthop_add() should not
return from the inner loop if the outer loop is not finished -- just break
the inner loop and continue the outside one. In rt_update() nexthops should
not be cleared and freed if the new route is better. This resulted in reset
RIB timers after any calculation run. Instead just mark the nexthop invalid
and go on. Tested and OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.62 2007/06/19 16:45:15 reyk Exp $ */
d40 2
a41 1
void		 calc_nexthop(struct vertex *, struct vertex *);
d138 1
a138 1
					calc_nexthop(w, v);
d147 1
a147 1
					calc_nexthop(w, v);
d152 1
a152 1
				calc_nexthop(w, v);
d388 2
a389 1
calc_nexthop(struct vertex *dst, struct vertex *parent)
a390 1
	struct lsa_rtr_link	*rtr_link = NULL;
d392 1
d399 4
a402 4
			for (i = 0; i < lsa_num_links(dst); i++) {
				rtr_link = get_rtr_link(dst, i);
				if (rtr_link->type == LINK_TYPE_POINTTOPOINT &&
				    ntohl(rtr_link->id) == parent->ls_id) {
d404 2
a405 2
					    rtr_link->data);
					break;
d408 1
a408 1
			return;
d410 12
a421 21
			for (i = 0; i < lsa_num_links(parent); i++) {
				rtr_link = get_rtr_link(parent, i);
				switch (rtr_link->type) {
				case LINK_TYPE_POINTTOPOINT:
					/* ignore */
					break;
				case LINK_TYPE_TRANSIT_NET:
					if ((htonl(dst->ls_id) &
					    dst->lsa->data.net.mask) ==
					    (rtr_link->data &
					     dst->lsa->data.net.mask)) {
						calc_nexthop_add(dst, parent,
						    rtr_link->data);
					}
					break;
				case LINK_TYPE_STUB_NET:
					break;

				default:
					fatalx("calc_nexthop: invalid link "
					    "type");
d423 4
d432 1
d460 1
a460 1
	    calc_nexthop_add(dst, parent, vn->nexthop.s_addr);
@


1.62
log
@add support for mapping route labels to AS-external route tags.

manpage bits from jmc@@
ok norby@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.61 2007/06/12 06:30:08 claudio Exp $ */
d777 1
a777 1
			return;
d779 2
d872 3
a874 2
	struct rt_node	*rte;
	int		 better = 0, equal = 0;
d942 2
a943 1
			rt_nexthop_clear(rte);
@


1.61
log
@When calculating as_ext routes only respect the connected flag for rt_nodes
with d_type DT_NET. Without this directly connected DT_RTRs use the wrong
nexthop and fail to install the as_ext route because the nexthop is not
directly reachable.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.60 2007/04/10 13:26:39 claudio Exp $ */
d46 1
a46 1
		     enum path_type, enum dst_type, u_int8_t);
d199 1
a199 1
			    v->lsa->data.rtr.flags);
d210 1
a210 1
		    adv_rtr, PT_INTRA_AREA, DT_RTR, v->lsa->data.rtr.flags);
d220 1
a220 1
		    DT_NET, 0);
d255 1
a255 1
			    PT_INTER_AREA, DT_NET, 0);
d260 1
a260 1
			    v->lsa->data.rtr.flags);
d338 1
a338 1
		    DT_NET, 0);
d868 1
a868 1
     u_int8_t flags)
d889 1
d946 1
@


1.60
log
@Next step in equal cost multipath support. Make the SPF calculation multipath
aware. Both the SPF and RIB trees need additional structures to store the
multiple nexthops to the destination but only the first active nexthop is
passed to the parent process and used for routing. This is the next thing
that needs to be modified. Tested and OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.59 2007/04/02 16:26:03 claudio Exp $ */
d325 1
a325 1
			if (rn->connected) {
@


1.59
log
@Use fatal() if calloc fails instead of fatalx().
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.58 2007/01/29 13:23:05 norby Exp $ */
d38 9
a46 4
void		 calc_next_hop(struct vertex *, struct vertex *);
void		 rt_update(struct in_addr, u_int8_t, struct in_addr, u_int32_t,
		     u_int32_t, struct in_addr, struct in_addr, enum path_type,
		     enum dst_type, u_int8_t, u_int8_t);
a133 1

d136 2
a137 2
					w->prev = v;
					calc_next_hop(w, v);
d144 3
a146 1
				}
a148 1
				w->prev = v;
d150 2
a151 1
				calc_next_hop(w, v);
a158 1

d173 1
d185 1
a185 1
		if (v->cost >= LS_INFINITY || v->nexthop.s_addr == 0)
d197 1
a197 1
			    v->nexthop, v->cost + ntohs(rtr_link->metric), 0,
d199 1
a199 1
			    v->lsa->data.rtr.flags, v->prev == spf_root);
d209 2
a210 2
		rt_update(addr, 32, v->nexthop, v->cost, 0, area->id,
		    adv_rtr, PT_INTRA_AREA, DT_RTR, v->lsa->data.rtr.flags, 0);
d213 1
a213 1
		if (v->cost >= LS_INFINITY || v->nexthop.s_addr == 0)
d219 2
a220 2
		    v->nexthop, v->cost, 0, area->id, adv_rtr, PT_INTRA_AREA,
		    DT_NET, 0, v->prev == spf_root);
d239 5
a243 1
		v->nexthop = w->nexthop;
d247 1
a247 1
		if (v->cost >= LS_INFINITY || v->nexthop.s_addr == 0)
d254 2
a255 2
			    v->nexthop, v->cost, 0, area->id, adv_rtr,
			    PT_INTER_AREA, DT_NET, 0, 0);
d258 1
a258 1
			rt_update(addr, 32, v->nexthop, v->cost, 0, area->id,
d260 1
a260 1
			    v->lsa->data.rtr.flags, 0);
d274 1
d304 1
a304 11
		if (r->connected) {
			if (v->lsa->data.asext.fw_addr != 0)
				v->nexthop.s_addr =
				    v->lsa->data.asext.fw_addr;
			else
				v->nexthop.s_addr = htonl(v->adv_rtr);
		} else
			v->nexthop = r->nexthop;

		if (ntohl(v->lsa->data.asext.metric) &
		    LSA_ASEXT_E_FLAG) {
d310 1
a310 2
			v->cost = r->cost +
			    (ntohl(v->lsa->data.asext.metric) &
d319 17
d337 2
a338 2
		    v->nexthop, v->cost, cost2, a, adv_rtr, type,
		    DT_NET, 0, 0);
d353 12
a364 2
		v->prev = NULL;
		v->nexthop.s_addr = 0;
d369 19
a387 1
calc_next_hop(struct vertex *dst, struct vertex *parent)
d390 1
d401 2
a402 1
					dst->nexthop.s_addr = rtr_link->data;
d419 2
a420 2
						dst->nexthop.s_addr =
						    rtr_link->data;
d427 1
a427 1
					fatalx("calc_next_hop: invalid link "
d433 1
a433 1
			fatalx("calc_next_hop: invalid dst type");
d438 18
a455 8
	if (parent->type == LSA_TYPE_NETWORK && dst->type == LSA_TYPE_ROUTER &&
	    dst->prev == parent && parent->prev == spf_root) {
		for (i = 0; i < lsa_num_links(dst); i++) {
			rtr_link = get_rtr_link(dst, i);
			if ((rtr_link->type == LINK_TYPE_TRANSIT_NET) &&
			    (rtr_link->data & parent->lsa->data.net.mask) ==
			    (htonl(parent->ls_id) & parent->lsa->data.net.mask))
				dst->nexthop.s_addr = rtr_link->data;
a456 1

d459 1
d461 2
a462 1
	dst->nexthop = parent->nexthop;
d706 1
d714 2
a715 1
	struct rt_node	*r, *nr;
d734 10
a743 1
		if (r->invalid)
d745 47
a791 2
		else
			r->invalid = 1;
d810 1
d842 15
a856 11
		rtctl.prefix.s_addr = r->prefix.s_addr;
		rtctl.nexthop.s_addr = r->nexthop.s_addr;
		rtctl.area.s_addr = r->area.s_addr;
		rtctl.adv_rtr.s_addr = r->adv_rtr.s_addr;
		rtctl.cost = r->cost;
		rtctl.cost2 = r->cost2;
		rtctl.p_type = r->p_type;
		rtctl.d_type = r->d_type;
		rtctl.flags = r->flags;
		rtctl.prefixlen = r->prefixlen;
		rtctl.uptime = now.tv_sec - r->uptime;
d858 3
a860 2
		rde_imsg_compose_ospfe(IMSG_CTL_SHOW_RIB, 0, pid, &rtctl,
		    sizeof(rtctl));
d865 1
a865 1
rt_update(struct in_addr prefix, u_int8_t prefixlen, struct in_addr nexthop,
d868 1
a868 1
     u_int8_t flags, u_int8_t connected)
a869 1
	struct timespec	 now;
d871 1
a871 1
	int		 better = 0;
d873 1
a873 1
	if (nexthop.s_addr == 0)	/* XXX remove */
a875 2
	clock_gettime(CLOCK_MONOTONIC, &now);

d879 2
a882 2
		rte->nexthop.s_addr = nexthop.s_addr;
		rte->adv_rtr.s_addr = adv_rtr.s_addr;
d889 2
a890 3
		rte->invalid = 0;
		rte->connected = connected;
		rte->uptime = now.tv_sec;
d894 47
a940 7
		if (rte->invalid) {
			/* invalidated entry - just update */
			if (rte->nexthop.s_addr != nexthop.s_addr ||
			    rte->cost != cost || rte->cost2 != cost2)
				rte->uptime = now.tv_sec;
			rte->nexthop.s_addr = nexthop.s_addr;
			rte->adv_rtr.s_addr = adv_rtr.s_addr;
a942 1
			rte->area = area;
a944 46
			rte->invalid = 0;
			rte->connected = connected;
		} else {
			/* order:
			 * 1. intra-area
			 * 2. inter-area
			 * 3. type 1 as ext
			 * 4. type 2 as ext
			 */
			if (p_type < rte->p_type)
				better = 1;
			else if (p_type == rte->p_type)
				switch (p_type) {
				case PT_INTRA_AREA:
				case PT_INTER_AREA:
					if (cost < rte->cost)
						better = 1;
					/* ignore equal pathes */
					break;
				case PT_TYPE1_EXT:
					/* XXX rfc1583 compat */
					if (cost < rte->cost)
						better = 1;
					break;
				case PT_TYPE2_EXT:
					if (cost2 < rte->cost2)
						better = 1;
					/* XXX rfc1583 compat */
					else if (cost2 == rte->cost2 &&
					    cost < rte->cost)
						better = 1;
					break;
				}
			if (better) {
				if (rte->nexthop.s_addr != nexthop.s_addr)
					rte->uptime = now.tv_sec;
				rte->nexthop.s_addr = nexthop.s_addr;
				rte->adv_rtr.s_addr = adv_rtr.s_addr;
				rte->cost = cost;
				rte->cost2 = cost2;
				rte->area = area;
				rte->p_type = p_type;
				rte->flags = flags;
				rte->invalid = 0;
				rte->connected = connected;
			}
d946 3
@


1.58
log
@Remove useless debug message when calculating the SPF tree.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.57 2007/01/29 13:04:13 claudio Exp $ */
d761 1
a761 1
			fatalx("rt_update");
@


1.57
log
@Do not link from the LS DB to outside structures that may vanish before
the actual LS DB entry is removed. In particular a neighbor may be removed
at any time -- we were lucky because we kept down neighbors around for
another 24h. Reload support unhided this problem again. Just copy the
needed info into the vertex. Pointing to the area is save as the vertex is
part of the area itself and removed when the area is removed.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.56 2007/01/24 12:05:10 claudio Exp $ */
d105 1
a105 2
			if (w == NULL) {
				log_debug("spf_calc: w = NULL");
a106 1
			}
@


1.56
log
@Remove most of the spf calculation related log_debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.55 2006/07/06 13:03:39 claudio Exp $ */
d225 1
a225 1
		if (v->nbr->self)
d279 1
a279 1
		if (v->nbr->self)
@


1.55
log
@In rt_invalidate() skip all as_ext routes if routes matching a specific area
are invalidated. as_ext routes have a uninitalised area id (aka 0.0.0.0) and
so bad stuff happend when area 0.0.0.0 was invalidated. Because of this the
FIB and RIB got out of sync in some scenarios.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.54 2006/05/30 22:15:55 claudio Exp $ */
a55 3
	log_debug("spf_calc: calculation started, area ID %s",
	    inet_ntoa(area->id));

d110 1
a110 2
			if (w->lsa->hdr.age == MAX_AGE) {
				log_debug("spf_calc: age = MAX_AGE");
a111 1
			}
d159 1
a159 1
	log_debug("spf_calc: calculation ended, area ID %s",
a482 1
		log_debug("spf_timer: HOLDQUEUE -> DELAY");
a527 1
		log_debug("spf_timer: state HOLD -> IDLE");
a541 1
		log_debug("start_spf_timer: IDLE -> DELAY");
a551 1
		log_debug("start_spf_timer: HOLD -> HOLDQUEUE");
a578 1
		log_debug("spf_start_holdtimer: DELAY -> HOLD");
@


1.54
log
@Correctly calculate point-to-point nexthop address. The logic was badly twisted
but funnily worked for routers with just one point-to-point link.
Found by Marc Winiger. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.53 2006/04/25 19:27:36 norby Exp $ */
d677 5
@


1.53
log
@kill unused old debug code.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.52 2006/03/22 16:01:20 claudio Exp $ */
d360 5
a364 4
				if (rtr_link->type != LINK_TYPE_POINTTOPOINT &&
				    rtr_link->id != parent->ls_id)
					continue;
				dst->nexthop.s_addr = rtr_link->data;
@


1.52
log
@Move the AS external LSA tree out of struct ospfd_config. This simplifies
the code and makes config reloads easier. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.51 2006/03/21 08:36:27 claudio Exp $ */
a37 2
void		 spf_dump(struct area *);	/* XXX */
void		 cand_list_dump(void);		/* XXX */
a46 29
spf_dump(struct area *area)
{
	struct lsa_tree	*tree = &area->lsa_tree;
	struct vertex	*v;
	struct vertex	*p;	/* parent */
	struct in_addr	 addr;

	log_debug("spf_dump:");
	RB_FOREACH(v, lsa_tree, tree) {
		addr.s_addr = htonl(v->ls_id);
		log_debug("    id %s type %d cost %d", inet_ntoa(addr),
		     v->type, v->cost);
		log_debug("    nexthop: %s", inet_ntoa(v->nexthop));

#if 1
		log_debug("    --------------------------------------------");
		p = v->prev;
		while (p != NULL) {
			addr.s_addr = htonl(p->ls_id);
			log_debug("        id %15s type %d cost %d",
			    inet_ntoa(addr), p->type, p->cost);
			p = p->prev;
		}
	log_debug("");
#endif
	}
}

void
a156 2
		/* cand_list_dump(); */

a435 15
}

void
cand_list_dump(void)
{
	struct vertex	*c = NULL;
	struct in_addr	 addr;

	log_debug("cand_list_dump:");
	TAILQ_FOREACH(c, &cand_list, cand) {
		addr.s_addr = htonl(c->ls_id);
		log_debug("    id %s type %d cost %d", inet_ntoa(addr),
		     c->type, c->cost);
	}
	log_debug("");
@


1.51
log
@Invalidating the full RIB and then only recalculating part of it is not
that smart. Kill the global rt_invalidate() instead clear only that part of
the RIB that is actually recalculated. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.50 2006/03/13 09:36:06 claudio Exp $ */
d558 1
a558 1
		RB_FOREACH(v, lsa_tree, &conf->lsa_tree) {
@


1.50
log
@The return value of the start/stop timer functions is almost never checked.
Switch them to void functions and check if evtimer_add/del fails -- in which
case we fatal() as there is no useful way to recover in such an event.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.49 2006/02/24 21:06:47 norby Exp $ */
d45 1
a45 1
void		 rt_invalidate(void);
a538 2
		rt_invalidate();

d541 3
d556 2
a557 1
		/* calculate as-external routes */
d712 1
a712 1
rt_invalidate(void)
d718 10
@


1.49
log
@Keep track of the uptime of the entries in the RIB.
It is now possible to see the uptime of the individual entries in the RIB.
The uptime can be displayed with "ospfctl show rib"

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.48 2006/02/10 13:00:49 claudio Exp $ */
d522 1
d587 1
a587 1
int
d598 3
a600 1
		return (evtimer_add(&rdeconf->ev, &tv));
a613 2

	return (1);
d616 1
a616 1
int
d619 2
a620 1
	return (evtimer_del(&conf->ev));
d623 1
a623 1
int
d634 3
a636 1
		return (evtimer_add(&conf->ev, &tv));
a643 2

	return (1);
@


1.49.2.1
log
@MFC:
Fix by claudio@@

Invalidating the full RIB and then only recalculating part of it is not
that smart. Kill the global rt_invalidate() instead clear only that part of
the RIB that is actually recalculated.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.51 2006/03/21 08:36:27 claudio Exp $ */
d45 1
a45 1
void		 rt_invalidate(struct area *);
d538 2
a541 3
				/* invalidate RIB entries of this area */
				rt_invalidate(area);

d554 1
a554 2
		/* calculate as-external routes, first invalidate them */
		rt_invalidate(NULL);
d708 1
a708 1
rt_invalidate(struct area *area)
a713 10
		if (area == NULL) {
			/* look only at as_ext routes */
			if (r->p_type != PT_TYPE1_EXT &&
			    r->p_type != PT_TYPE2_EXT)
				continue;
		} else {
			/* look only at routes matching the area */
			if (r->area.s_addr != area->id.s_addr)
				continue;
		}
@


1.48
log
@If ABR only look in the backbone area 0.0.0.0 for summary LSA. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.47 2006/02/09 20:47:20 norby Exp $ */
d734 1
d737 2
d777 1
d790 1
d797 2
d814 1
d820 3
d864 2
@


1.47
log
@Don't calculate all areas every time the link state database is updated,
only calculate the dirty ones.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.46 2006/02/02 15:10:57 norby Exp $ */
d205 1
a205 1
rt_calc(struct vertex *v, struct area *area)
d259 2
d547 1
a547 1
					rt_calc(v, area);
d555 1
a555 1
		RB_FOREACH(v, lsa_tree, &rdeconf->lsa_tree) {
@


1.46
log
@zap cand_list_empty, found by lint.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.45 2006/02/01 20:24:08 norby Exp $ */
d539 8
a546 2
			/* calculate SPF tree */
			spf_calc(area);
d548 1
a548 3
			/* calculate route table */
			RB_FOREACH(v, lsa_tree, &area->lsa_tree) {
				rt_calc(v, area);
@


1.45
log
@spf_calc should only do what the name says - calculate the spf tree.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.44 2006/02/01 19:56:15 norby Exp $ */
a516 6
}

int
cand_list_empty(void)
{
	return (TAILQ_EMPTY(&cand_list));
@


1.44
log
@Wrong type, found by lint.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.43 2006/02/01 18:38:51 norby Exp $ */
a79 1
	struct lsa_tree		*tree = &area->lsa_tree;
a195 10
	/* calculate route table */
	RB_FOREACH(v, lsa_tree, tree) {
		rt_calc(v, area);
	}

	/* calculate as-external routes */
	RB_FOREACH(v, lsa_tree, &rdeconf->lsa_tree) {
		asext_calc(v);
	}

d529 1
d544 2
a545 1
		LIST_FOREACH(area, &conf->area_list, entry)
d547 11
@


1.43
log
@variable naming, a -> addr.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.42 2006/01/26 15:05:08 norby Exp $ */
d315 1
a315 1
	enum dst_type		 type;
@


1.42
log
@Separate route table calculations from the SPF calculation.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.41 2006/01/24 20:27:04 norby Exp $ */
d86 1
a86 1
	struct in_addr		 a;
d151 1
a151 1
				a.s_addr = htonl(w->ls_id);
d153 2
a154 2
				    inet_ntoa(a), w->type);
				a.s_addr = htonl(v->ls_id);
d156 1
a156 1
				    inet_ntoa(a), v->type);
@


1.41
log
@Correct debug text
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.40 2006/01/24 20:06:03 norby Exp $ */
d86 1
a86 1
	struct in_addr		 addr, adv_rtr, a;
d199 2
a200 9
		lsa_age(v);
		if (ntohs(v->lsa->hdr.age) == MAX_AGE)
			continue;

		switch (v->type) {
		case LSA_TYPE_ROUTER:
			/* stub networks */
			if (v->cost >= LS_INFINITY || v->nexthop.s_addr == 0)
				continue;
d202 4
a205 4
			for (i = 0; i < lsa_num_links(v); i++) {
				rtr_link = get_rtr_link(v, i);
				if (rtr_link->type != LINK_TYPE_STUB_NET)
					continue;
d207 3
a209 2
				addr.s_addr = rtr_link->id;
				adv_rtr.s_addr = htonl(v->adv_rtr);
d211 11
a221 7
				rt_update(addr, mask2prefixlen(rtr_link->data),
				    v->nexthop, v->cost +
				    ntohs(rtr_link->metric), 0, area->id,
				    adv_rtr, PT_INTRA_AREA, DT_NET,
				    v->lsa->data.rtr.flags,
				    v->prev == spf_root);
			}
d223 3
a225 4
			/* router, only add border and as-external routers */
			if ((v->lsa->data.rtr.flags & (OSPF_RTR_B |
			    OSPF_RTR_E)) == 0)
				continue;
d227 5
a231 2
			addr.s_addr = htonl(v->ls_id);
			adv_rtr.s_addr = htonl(v->adv_rtr);
d233 3
a235 6
			rt_update(addr, 32, v->nexthop, v->cost, 0, area->id,
			    adv_rtr, PT_INTRA_AREA, DT_RTR,
			    v->lsa->data.rtr.flags, 0);
			break;
		case LSA_TYPE_NETWORK:
			if (v->cost >= LS_INFINITY || v->nexthop.s_addr == 0)
d238 1
a238 1
			addr.s_addr = htonl(v->ls_id) & v->lsa->data.net.mask;
a239 7
			rt_update(addr, mask2prefixlen(v->lsa->data.net.mask),
			    v->nexthop, v->cost, 0, area->id, adv_rtr,
			    PT_INTRA_AREA, DT_NET, 0, v->prev == spf_root);
			break;
		case LSA_TYPE_SUM_NETWORK:
		case LSA_TYPE_SUM_ROUTER:
			/* if ABR only look at area 0.0.0.0 LSA */
d241 5
a245 3
			/* ignore self-originated stuff */
			if (v->nbr->self)
				continue;
d247 3
a249 1
			/* TODO type 3 area address range check */
d251 2
a252 4
			if ((w = lsa_find(area, LSA_TYPE_ROUTER,
			    htonl(v->adv_rtr),
			    htonl(v->adv_rtr))) == NULL)
				continue;
d254 46
a299 26
			v->nexthop = w->nexthop;
			v->cost = w->cost +
			    (ntohl(v->lsa->data.sum.metric) & LSA_METRIC_MASK);

			if (v->cost >= LS_INFINITY || v->nexthop.s_addr == 0)
				continue;

			adv_rtr.s_addr = htonl(v->adv_rtr);
			if (v->type == LSA_TYPE_SUM_NETWORK) {
				addr.s_addr = htonl(v->ls_id) &
				    v->lsa->data.sum.mask;
				rt_update(addr,
				    mask2prefixlen(v->lsa->data.sum.mask),
				    v->nexthop, v->cost, 0, area->id, adv_rtr,
				    PT_INTER_AREA, DT_NET, 0, 0);
			} else {
				addr.s_addr = htonl(v->ls_id);
				rt_update(addr, 32, v->nexthop, v->cost, 0,
				    area->id, adv_rtr, PT_INTER_AREA, DT_RTR,
				    v->lsa->data.rtr.flags, 0);
			}

			break;
		default:
			/* as-external LSA are stored in a different tree */
			fatalx("spf_calc: invalid LSA type");
a300 1
	}
d302 4
a305 3
	/* calculate as-external routes */
	RB_FOREACH(v, lsa_tree, &rdeconf->lsa_tree) {
		asext_calc(v);
a306 7

	/* spf_dump(area); */
	log_debug("spf_calc: calculation ended, area ID %s",
	    inet_ntoa(area->id));

	area->num_spf_calc++;
	start_spf_timer();
@


1.40
log
@Fix bad indent.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.39 2006/01/24 18:31:32 norby Exp $ */
d368 1
a368 1
		fatalx("spf_calc_asext: invalid LSA type");
@


1.39
log
@Split SPF calc and AS Ext calc.

Initial diff by claudio@@ reworked by me.

test and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.38 2005/12/02 12:21:31 claudio Exp $ */
d329 1
a329 2
		    (r = rt_lookup(DT_NET,
				   v->lsa->data.asext.fw_addr)) == NULL)
@


1.38
log
@Fixed version of r1.35, readd candidate to list in both cases so that the list
remains sorted. Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.37 2005/11/14 11:48:05 norby Exp $ */
d84 1
a84 2
	struct rt_node		*r;
	u_int32_t		 cost2, d;
a86 1
	enum dst_type		 type;
d293 1
a293 58
		lsa_age(v);
		if (ntohs(v->lsa->hdr.age) == MAX_AGE)
			continue;

		switch (v->type) {
		case LSA_TYPE_EXTERNAL:
			/* ignore self-originated stuff */
			if (v->nbr->self)
				continue;

			if ((r = rt_lookup(DT_RTR, htonl(v->adv_rtr))) == NULL)
				continue;

			if (v->lsa->data.asext.fw_addr != 0 &&
			    (r = rt_lookup(DT_NET,
			    v->lsa->data.asext.fw_addr)) == NULL)
				continue;

#if 0
			if (r->p_type != PT_INTRA_AREA &&
			    r->p_type != PT_INTER_AREA)
				continue;
#endif

			/* XXX RFC1583Compatibility */
			if (r->connected) {
				if (v->lsa->data.asext.fw_addr != 0)
					v->nexthop.s_addr =
					    v->lsa->data.asext.fw_addr;
				else
					v->nexthop.s_addr = htonl(v->adv_rtr);
			} else
				v->nexthop = r->nexthop;

			if (ntohl(v->lsa->data.asext.metric) &
			    LSA_ASEXT_E_FLAG) {
				v->cost = r->cost;
				cost2 = ntohl(v->lsa->data.asext.metric) &
				     LSA_METRIC_MASK;
				type = PT_TYPE2_EXT;
			} else {
				v->cost = r->cost +
				    (ntohl(v->lsa->data.asext.metric) &
				     LSA_METRIC_MASK);
				cost2 = 0;
				type = PT_TYPE1_EXT;
			}

			a.s_addr = 0;
			adv_rtr.s_addr = htonl(v->adv_rtr);
			addr.s_addr = htonl(v->ls_id) & v->lsa->data.asext.mask;
			rt_update(addr, mask2prefixlen(v->lsa->data.asext.mask),
			    v->nexthop, v->cost, cost2, a, adv_rtr, type,
			    DT_NET, 0, 0);
			break;
		default:
			fatalx("spf_calc: invalid LSA type");
		}
d302 69
@


1.37
log
@Revert candidate list change since it is broken.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.36 2005/11/12 18:18:24 deraadt Exp $ */
d175 6
a183 2

				cand_list_add(w);
d187 1
@


1.36
log
@spacing mostly
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.35 2005/11/04 14:37:26 claudio Exp $ */
a174 5
					/*
					 * need to readd to candidate list
					 * because the list is sorted
					 */
					TAILQ_REMOVE(&cand_list, w, cand);
d178 2
d181 1
a183 1
			cand_list_add(w);
@


1.35
log
@The candidate list is a sorted linear list so when changing the cost of
a vertex that is already a candidate it is necessary to remove and insert
the candidate otherwise the candidate list is no longer correctly sorted.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.34 2005/11/04 10:46:23 claudio Exp $ */
a74 2

	return;
a358 2

	return;
a436 2

	return;
a461 2

	return;
@


1.34
log
@Kill spf_timer in struct ospfd_conf. There is no need for two event structs
just use ev for the spf_timer -- ev is unused in the RDE.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.33 2005/09/01 19:09:34 claudio Exp $ */
d177 5
a184 2

				cand_list_add(w);
a185 1

d188 1
@


1.33
log
@rt_lookup() did not respect the route node invalid flag and so AS-ext
routes where not cleared even though the advertising router was no longer
reachable. Same problem has the rt_dump() function that is used for
ospfctl show rib.  Tested by me and norby@@
OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.32 2005/08/30 21:02:35 claudio Exp $ */
d584 1
a584 1
		return (evtimer_add(&rdeconf->spf_timer, &tv));
d605 1
a605 1
	return (evtimer_del(&conf->spf_timer));
d619 1
a619 1
		return (evtimer_add(&conf->spf_timer, &tv));
@


1.32
log
@Fix a bug in the nexthop calculation for complex networks. The result was a
routing table where most entries used the local interface IP as nexthop. This
bug was found by jakob@@ and he verified that it fixes his problems. Additional
tests by me and norby@@.
OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.31 2005/08/08 12:22:48 claudio Exp $ */
d724 3
d860 6
a865 2
	if (type == DT_RTR)
		return (rt_find(addr, 32, type));
d869 2
a870 1
		if ((rn = rt_find(addr & prefixlen2mask(i), i, type)))
@


1.31
log
@Try to do an SPF recalculation only if the LS DB changed.
This is still not perfect as on ABRs it is only necessary to
recalculate the area that got changed and not all others too.
More to come but it is a good start. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.30 2005/08/08 08:51:47 claudio Exp $ */
d155 6
a160 1
				log_debug("spf_calc: w has no link to v");
d176 1
d178 5
a184 10
			} else {
				if (w->cost == LS_INFINITY ||
				    w->prev == NULL) {
					w->cost = d;

					cand_list_add(w);
					w->prev = v;

					calc_next_hop(w, v);
				}
d205 1
a205 1
			if (v->cost == LS_INFINITY || v->nexthop.s_addr == 0)
@


1.30
log
@Correctly order LSA/route entries. Also prefer network vertices over router
ones in the candidate list. Be more careful about LS_INFINITY as it is
possible that the cost overflows in the calculation (checking for == is in
some cases wrong). Simplify the code a bit. Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.29 2005/06/27 18:59:41 claudio Exp $ */
d356 1
a356 1
	start_spf_timer(rdeconf);
d561 1
a561 1
		start_spf_holdtimer(rdeconf);
d573 1
a573 1
start_spf_timer(struct ospfd_conf *conf)
d577 1
a577 1
	switch (conf->spf_state) {
d581 3
a583 3
		tv.tv_sec = conf->spf_delay;
		conf->spf_state = SPF_DELAY;
		return (evtimer_add(&conf->spf_timer, &tv));
d589 1
a589 1
		conf->spf_state = SPF_HOLDQUEUE;
@


1.29
log
@Mark connected routes (routes without a nexthop) in the rib. Without this
as-ext routes would select a wrong nexthop if the forwarding router is
directly connected. OK, help and debugging norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.28 2005/06/27 17:59:36 claudio Exp $ */
a157 3
			if (w->cost != LS_INFINITY && w->prev != NULL &&
			    !cand_list_present(w))
				continue;
d175 3
a177 3
				if (w->cost == LS_INFINITY) {
					w->cost = 0;
					w->cost += d;
d236 1
a236 1
			if (v->cost == LS_INFINITY || v->nexthop.s_addr == 0)
d262 1
a262 1
			    ntohl(v->lsa->data.sum.metric);
d264 1
a264 1
			if (v->cost == LS_INFINITY || v->nexthop.s_addr == 0)
d309 7
a315 1
			/* XXX the nexthop is choosen in a more extreme way */
d318 1
a318 1
					v->nexthop.s_addr = 
a452 1
	/* XXX TODO: network vertex takes precedence over router vertex */
d457 4
d770 1
d805 31
a835 3
			/* XXX better route ? */
			/* consider intra vs. inter */
			if (cost < rte->cost) {
@


1.28
log
@Don't let /32 DT_NET routes override DT_RTR routes. This should help
setups with /32 loopback networks.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.27 2005/06/26 23:50:10 deraadt Exp $ */
d43 1
a43 1
		     enum dst_type, u_int8_t);
d222 2
a223 1
				    v->lsa->data.rtr.flags);
d236 1
a236 1
			    v->lsa->data.rtr.flags);
d246 1
a246 1
			    PT_INTRA_AREA, DT_NET, 0);
d277 1
a277 1
				    PT_INTER_AREA, DT_NET, 0);
d282 1
a282 1
				    v->lsa->data.rtr.flags);
d313 8
a320 1
			v->nexthop = r->nexthop;
d341 1
a341 1
			    DT_NET, 0);
d761 1
a761 1
     u_int8_t flags)
d782 1
d796 1
d809 1
@


1.27
log
@typo by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.26 2005/06/26 20:44:44 claudio Exp $ */
d42 3
a44 3
		     u_int32_t, struct in_addr, struct in_addr, u_int8_t,
		     u_int8_t, u_int8_t);
struct rt_node	*rt_lookup(u_int8_t, in_addr_t);
d90 1
a90 1
	u_int8_t		 type;
d634 4
d642 1
a642 1
rt_find(in_addr_t prefix, u_int8_t prefixlen)
d648 1
d752 2
a753 1
     struct in_addr adv_rtr, u_int8_t p_type, u_int8_t d_type, u_int8_t flags)
d760 1
a760 1
	if ((rte = rt_find(prefix.s_addr, prefixlen)) == NULL) {
d805 1
a805 1
rt_lookup(u_int8_t type, in_addr_t addr)
d810 2
a811 7
	if (type == DT_RTR) {
		rn = rt_find(addr, 32);
		if (rn == NULL || rn->d_type != DT_RTR)
			/* /32 networks need to be ignored */
			return (NULL);
		return (rn);
	}
d813 1
d815 1
a815 2
		/* a DT_NET /32 is equivalent to a DT_RTR */
		if ((rn = rt_find(addr & prefixlen2mask(i), i)))
@


1.26
log
@Don't htonl() something that is already in network byte order. AS-Ext routes
suffered because of this. Normaly seen because they where not added to the rib
or ended up with a bad nexthop.
This is what you get for stealing code from bgpd :(
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.25 2005/05/28 17:49:59 norby Exp $ */
d814 1
a814 1
		if ((rn = rt_find(addr & prefixlen2mask(i)), i))
@


1.25
log
@Fix confusing typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.24 2005/05/27 01:02:04 claudio Exp $ */
d814 1
a814 1
		if ((rn = rt_find(htonl(addr & prefixlen2mask(i)), i)))
@


1.24
log
@While calculating the routing table don't ignore all routes with a cost of
LS_INFINITY. Summary LSA are not touched by the SPF algorithm and so they
got dropped here because the still had a cost of LS_INFINITY.
The calculated routing table starts to make sense now.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.23 2005/05/27 00:56:35 claudio Exp $ */
d249 1
a249 1
			/* if BDR only look at area 0.0.0.0 LSA */
@


1.23
log
@Only checking if w->cost is non equal to LS_INFINITY and w->prev is NULL is
not enough to distinguish between calculated vertexes and those just queued
in the candidate list. So add a additional check if the vertex is on the
candidate list. This fixes a problem Stephen Marley reported some time ago.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.22 2005/05/27 00:50:50 claudio Exp $ */
d201 1
a201 2
		if (ntohs(v->lsa->hdr.age) == MAX_AGE ||
		    v->cost == LS_INFINITY)
d207 1
a207 1
			if (v->nexthop.s_addr == 0)
d238 1
a238 1
			if (v->nexthop.s_addr == 0)
d266 1
a266 1
			if (v->nexthop.s_addr == 0)
@


1.22
log
@Fix nexthop calculation by setting w->prev before calling calc_next_hop().
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.21 2005/05/26 23:31:04 norby Exp $ */
d158 2
a159 1
			if (w->cost != LS_INFINITY && w->prev != NULL) {
d161 1
a161 1
			}
@


1.21
log
@Remove annoying spf_calc debug line.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.20 2005/05/26 23:23:39 norby Exp $ */
a169 4
				if (d == w->cost) {
					calc_next_hop(w, v);
				}

a170 2
					calc_next_hop(w, v);

d174 2
@


1.20
log
@Remove route update debugging messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.19 2005/05/26 23:11:53 norby Exp $ */
a158 1
				log_debug("spf_calc: w already in SPF tree");
@


1.19
log
@Disable cand_list_dump and spf_dump by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.18 2005/05/26 22:44:24 norby Exp $ */
a759 2
		log_debug("rt_update: creating %s/%d", inet_ntoa(prefix),
		    prefixlen);
a775 3
		log_debug("rt_update: updating %s/%d", inet_ntoa(prefix),
		    prefixlen);

@


1.18
log
@Unwanted.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.17 2005/05/24 06:55:21 claudio Exp $ */
d194 1
a194 1
		cand_list_dump();
d345 1
a345 1
	spf_dump(area);
@


1.17
log
@Fix some obvious issues in the summary LSA origination.
Actually remove summary LSA if the LSA they refer to are no longer valid.
Set correct cost on the summary LSA.
Announce type 4 summary LSA.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.16 2005/05/23 23:03:07 claudio Exp $ */
a566 2

	log_debug("start_spf_timer:");
@


1.16
log
@First part of summary LSA origination. Not perfect but a start.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.15 2005/05/23 22:26:45 norby Exp $ */
d548 3
@


1.15
log
@Kill rt_dump_debug stuff as "ospfctl show rib [detail]" provides the same
information.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.14 2005/05/22 18:05:42 norby Exp $ */
d533 1
a533 1
		LIST_FOREACH(area, &conf->area_list, entry) {
a534 1
		}
d537 3
@


1.14
log
@Handle cost2 for AS-external, and prepare for handling flags in
ospfctl show rib detail.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.13 2005/05/12 20:57:01 claudio Exp $ */
a38 1
void		 rt_dump_debug(void);		/* XXX */
a79 20
rt_dump_debug(void)
{
	struct rt_node	*r;
	int		 i = 0;

	log_debug("rt_dump_debug:");

	RB_FOREACH(r, rt_tree, &rt) {
		log_debug("net: %s/%d", inet_ntoa(r->prefix), r->prefixlen);
		log_debug("   nexthop: %s   cost: %d  ptype: %s   dtype: %s",
		    inet_ntoa(r->nexthop), r->cost, path_type_names[r->p_type],
		    dst_type_names[r->d_type]);
		log_debug("                      area: %s", inet_ntoa(r->area));
		i++;
	}

	log_debug("count: %d", i);
}

void
a345 1
	rt_dump_debug();
@


1.13
log
@Calculate routes for summary and as-external LSA. Still some minor parts
missing but good enough to be used.
Tested and some input by Stephen Marley.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.12 2005/05/12 20:53:02 claudio Exp $ */
d43 2
a44 1
		     struct in_addr, struct in_addr, u_int8_t, u_int8_t);
d108 1
a108 1
	u_int32_t		 d;
d246 3
a248 2
				    ntohs(rtr_link->metric), area->id, adv_rtr,
				    PT_INTRA_AREA, DT_NET);
d259 3
a261 2
			rt_update(addr, 32, v->nexthop, v->cost, area->id,
			    adv_rtr, PT_INTRA_AREA, DT_RTR);
d270 2
a271 2
			    v->nexthop, v->cost, area->id, adv_rtr,
			    PT_INTRA_AREA, DT_NET);
d301 2
a302 2
				    v->nexthop, v->cost, area->id, adv_rtr,
				    PT_INTER_AREA, DT_NET);
d305 3
a307 3
				rt_update(addr, 32,
				    v->nexthop, v->cost, area->id, adv_rtr,
				    PT_INTER_AREA, DT_RTR);
d343 2
a344 1
				/* XXX where to put type2 cost? */
d350 1
d358 2
a359 1
			    v->nexthop, v->cost, a, adv_rtr, type, DT_NET);
d739 3
d744 1
a744 1
			if (r->p_type != PT_TYPE1_EXT ||
d757 1
d760 1
a767 1

d770 2
a771 2
     u_int32_t cost, struct in_addr area, struct in_addr adv_rtr,
     u_int8_t p_type, u_int8_t d_type)
d788 1
d792 1
d805 1
d808 1
d817 1
d820 1
d840 1
a840 1
	
@


1.12
log
@lsa_age() the vertex befor comparing the age with MAX_AGE.
Move a common check (cost == LS_INFINITY) out of the switch cases.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.11 2005/05/12 19:32:46 claudio Exp $ */
d44 1
d102 1
a102 1
	struct lsa_tree	*tree = &area->lsa_tree;
d105 2
a106 1
	struct lsa_net_link	*net_link = NULL;
d109 2
a110 1
	struct in_addr		 addr, adv_rtr;
d249 5
a253 1
			/* router */
d257 1
a257 1
			rt_update(addr, 0, v->nexthop, v->cost, area->id,
d271 5
a275 1
			if (rdeconf->flags & OSPF_RTR_B)
d278 2
a291 1
			addr.s_addr = htonl(v->ls_id) & v->lsa->data.sum.mask;
d293 14
a306 6
			rt_update(addr, mask2prefixlen(v->lsa->data.sum.mask),
			    v->nexthop, v->cost, area->id, adv_rtr,
			    PT_INTER_AREA, DT_NET);
			break;
		case LSA_TYPE_SUM_ROUTER:
			/* XXX */
d308 13
d322 32
a353 1
			/* XXX */
d809 23
@


1.11
log
@Don't fatal in case no root node was found for spf calculation.
The area may be empty because there is no active interface.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.10 2005/05/05 15:27:34 claudio Exp $ */
d221 3
a223 1
		if (ntohs(v->lsa->hdr.age) == MAX_AGE)
d229 1
a229 2
			if ((v->cost == LS_INFINITY) ||
			    (v->nexthop.s_addr == 0))
d254 1
a254 2
			if ((v->cost == LS_INFINITY) ||
			    (v->nexthop.s_addr == 0))
@


1.10
log
@Fix a stupid typo in the #if 0 block in spf_calc() and start using that code
block. The idea is to ignore nodes that are already part of the SPF tree as
soon as possible.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.9 2005/03/23 20:15:50 claudio Exp $ */
d119 3
a121 1
		fatalx("spf_calc: cannot find self originated router LSA");
@


1.9
log
@prefixlen2mask() should return a network byte order result as it does imply
by using an in_addr_t as return type. It simplyfies also the usage as in most
cases the mask is used with a struct in_addr address which is also network
byte order. Add prototypes of prefixlen2mask() and mask2prefixlen() to
ospfd.h as it is used or will be used at different places.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.8 2005/03/22 22:13:48 norby Exp $ */
d173 1
a173 2
#if 0
			if ((w->cost != LS_INFINITY) && (v->prev != NULL)) {
a176 1
#endif
@


1.8
log
@Remove bool cruft.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.7 2005/03/17 16:46:15 claudio Exp $ */
a45 1
u_int8_t	 mask2prefixlen(in_addr_t);
@


1.7
log
@Fix an access after free. It is not allowed to use a RB_REMOVE inside of a
RB_FOREACH.
OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.6 2005/03/14 18:21:29 norby Exp $ */
d45 1
a45 1
bool		 linked(struct vertex *, struct vertex *);
d121 1
a121 1
	area->transit = false;
d439 1
a439 1
bool
d446 1
a446 1
			return (true);
d449 1
a449 1
	return (false);
d462 1
a462 1
bool
d639 1
a639 1
			r->invalid = true;
d718 1
a718 1
		rte->invalid = false;
d732 1
a732 1
			rte->invalid = false;
d742 1
a742 1
				rte->invalid = false;
d802 1
a802 1
bool
d817 1
a817 1
					return (true);
d821 1
a821 1
					return (true);
d827 1
a827 1
		return (false);
d834 1
a834 1
					return (true);
d840 1
a840 1
		return (false);
d845 1
a845 1
	return (false);
@


1.6
log
@Add "show summary" to ospfctl.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.5 2005/03/12 11:03:05 norby Exp $ */
d632 1
a632 1
	struct rt_node	*r;
d634 2
a635 1
	RB_FOREACH(r, rt_tree, &rt)
d640 1
@


1.5
log
@Add "show rib" and "show rib detail" to ospfctl.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.4 2005/03/12 10:49:12 norby Exp $ */
d246 1
a246 1
			/* routers */
d302 1
@


1.4
log
@Small K&F.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.3 2005/03/08 20:12:18 norby Exp $ */
d38 9
a46 9
void	 spf_dump(struct area *);	/* XXX */
void	 rt_dump(void);			/* XXX */
void	 cand_list_dump(void);		/* XXX */
void	 calc_next_hop(struct vertex *, struct vertex *);
void	 rt_update(struct in_addr, u_int8_t, struct in_addr, u_int32_t,
	     struct in_addr, u_int8_t, u_int8_t);
void	 rt_invalidate(void);
bool	 linked(struct vertex *, struct vertex *);
u_int8_t mask2prefixlen(in_addr_t);
d80 1
a80 1
rt_dump(void)
d85 1
a85 1
	log_debug("rt_dump:");
d108 1
a108 1
	struct in_addr		 addr;
d238 1
d242 1
a242 1
				    ntohs(rtr_link->metric), area->id,
d245 7
d259 1
d261 2
a262 2
			    v->nexthop, v->cost, area->id, PT_INTRA_AREA,
			    DT_NET);
d281 1
d283 2
a284 2
			    v->nexthop, v->cost, area->id, PT_INTER_AREA,
			    DT_NET);
d298 1
a298 1
	rt_dump();
d490 3
d532 1
d650 43
d694 2
a695 1
     u_int32_t cost, struct in_addr area, u_int8_t p_type, u_int8_t d_type)
d710 1
d725 1
d735 1
@


1.3
log
@Remove no longer valid route entries.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.2 2005/03/02 16:17:04 norby Exp $ */
d326 1
a326 1
			}			
d337 1
a337 1
					    dst->lsa->data.net.mask) == 
d351 1
a351 1
			}			
@


1.2
log
@Calculate the nexthop correctly if the calculating router has
Point-to-point links.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.1 2005/02/27 08:21:15 norby Exp $ */
d33 1
a33 1
RB_HEAD(rt_tree, rt_node)	rt_tree, rt;
d42 3
a44 1
void	 rt_update(struct in_addr, u_int8_t, struct in_addr, u_int32_t, u_int8_t);
d46 1
a46 1
u_int8_t	mask2prefixlen(in_addr_t);
d89 4
a92 2
		log_debug("   nexthop: %s   cost: %d   type: %s",
		    inet_ntoa(r->nexthop), r->cost, path_type_names[r->p_type]);
a93 2

		rde_send_kroute(r);
a189 1
					/* calc next hop */
a193 1
					/* calc next hop */
a206 1
					/* calc next hop */
d241 2
a242 1
				    ntohs(rtr_link->metric), PT_INTRA_AREA);
d252 2
a253 1
			    v->nexthop, v->cost, PT_INTRA_AREA);
d273 2
a274 1
			    v->nexthop, v->cost, PT_INTER_AREA);
d277 1
d280 1
d329 23
a351 1
			/* XXX TODO */
d463 1
a463 2

	log_debug("spf_timer:");
d473 2
a474 1
		rt_clear();	/* XXX we should save to old rt! */
d478 8
d615 12
d637 1
a637 1
     u_int32_t cost, u_int8_t p_type)
d641 3
d653 1
d655 2
d663 2
a664 3
		/* XXX better route ? */
		/* consider intra vs. inter */
		if (cost < rte->cost) {
d667 1
d669 11
d697 1
d724 1
@


1.1
log
@SPF and route table calculation.

Calculate Shortest Path Tree for each area known in the link state
database.

The Shortest Path Tree is used as input for route table calculation.
Route tabled is calculated and the result is inserted into the kernel
route table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d290 1
a290 1
	return ;
d316 8
a323 3
			/* XXX */
			log_debug("calc_next_hop: router not handled");
			break;
d325 2
a326 3
			/* XXX */
			log_debug("calc_next_hop: net not handled");
			break;
a329 2

		return ;
d343 1
a343 1
		return ;
d348 1
a348 1
	return ;
d372 1
a372 1
	return ;
@

