head	1.13;
access;
symbols;
locks; strict;
comment	@ * @;


1.13
date	2017.01.24.13.32.55;	author jsing;	state Exp;
branches;
next	1.12;
commitid	d53S4Fpx9gPB2Hox;

1.12
date	2017.01.24.12.05.14;	author jsing;	state Exp;
branches;
next	1.11;
commitid	8yg0jKPVoY1hQFt1;

1.11
date	2017.01.21.08.41.42;	author benno;	state Exp;
branches;
next	1.10;
commitid	gRa5yf7qfj3cY6Ul;

1.10
date	2016.10.04.15.49.42;	author jsing;	state Exp;
branches;
next	1.9;
commitid	xPKHkEMFcVwCgYRo;

1.9
date	2016.10.04.15.41.07;	author jsing;	state Exp;
branches;
next	1.8;
commitid	VCpWdmbFSzYBdFmX;

1.8
date	2016.09.13.17.13.37;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	nxoiZiJPhAAVKQhE;

1.7
date	2016.09.13.16.49.28;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	Kh60oAaRyMBwMrcR;

1.6
date	2016.09.01.12.17.00;	author florian;	state Exp;
branches;
next	1.5;
commitid	gosvRyqlI28bFwVD;

1.5
date	2016.09.01.00.35.22;	author florian;	state Exp;
branches;
next	1.4;
commitid	BIKpBY4sC6SiXDhj;

1.4
date	2016.09.01.00.21.36;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	P9IiJlKSbxnKzQyC;

1.3
date	2016.08.31.23.36.16;	author benno;	state Exp;
branches;
next	1.2;
commitid	sdi8gqZrjm1aFux5;

1.2
date	2016.08.31.22.57.36;	author deraadt;	state Exp;
branches;
next	1.1;
commitid	eGljFCfJCPC54si7;

1.1
date	2016.08.31.22.01.42;	author florian;	state Exp;
branches;
next	;
commitid	1Bh2CBIwvUy50FSg;


desc
@@


1.13
log
@Make returns consistent and remove parentheses per style(9).

Transformed with coccinelle.

Requested by and ok tb@@
@
text
@/*	$Id: netproc.c,v 1.12 2017/01/24 12:05:14 jsing Exp $ */
/*
 * Copyright (c) 2016 Kristaps Dzonsons <kristaps@@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "http.h"
#include "extern.h"
#include "parse.h"

#define	RETRY_DELAY 5
#define RETRY_MAX 10

/*
 * Buffer used when collecting the results of a CURL transfer.
 */
struct	buf {
	char	*buf; /* binary buffer */
	size_t	 sz; /* length of buffer */
};

/*
 * Used for CURL communications.
 */
struct	conn {
	const char	  *na; /* nonce authority */
	int		   fd; /* acctproc handle */
	int		   dfd; /* dnsproc handle */
	struct buf	   buf; /* transfer buffer */
};

/*
 * If something goes wrong (or we're tracing output), we dump the
 * current transfer's data as a debug message.
 * Make sure that print all non-printable characters as question marks
 * so that we don't spam the console.
 * Also, consolidate white-space.
 * This of course will ruin string literals, but the intent here is just
 * to show the message, not to replicate it.
 */
static void
buf_dump(const struct buf *buf)
{
	size_t	 i;
	int	 j;
	char	*nbuf;

	if (buf->sz == 0)
		return;
	if ((nbuf = malloc(buf->sz)) == NULL)
		err(EXIT_FAILURE, "malloc");

	for (j = 0, i = 0; i < buf->sz; i++)
		if (isspace((int)buf->buf[i])) {
			nbuf[j++] = ' ';
			while (isspace((int)buf->buf[i]))
				i++;
			i--;
		} else
			nbuf[j++] = isprint((int)buf->buf[i]) ?
			    buf->buf[i] : '?';
	dodbg("transfer buffer: [%.*s] (%zu bytes)", j, nbuf, buf->sz);
	free(nbuf);
}

/*
 * Extract the domain and port from a URL.
 * The url must be formatted as schema://address[/stuff].
 * This returns NULL on failure.
 */
static char *
url2host(const char *host, short *port, char **path)
{
	char	*url, *ep;

	/* We only understand HTTP and HTTPS. */

	if (strncmp(host, "https://", 8) == 0) {
		*port = 443;
		if ((url = strdup(host + 8)) == NULL) {
			warn("strdup");
			return NULL;
		}
	} else if (strncmp(host, "http://", 7) == 0) {
		*port = 80;
		if ((url = strdup(host + 7)) == NULL) {
			warn("strdup");
			return NULL;
		}
	} else {
		warnx("%s: unknown schema", host);
		return NULL;
	}

	/* Terminate path part. */

	if ((ep = strchr(url, '/')) != NULL) {
		*path = strdup(ep);
		*ep = '\0';
	} else
		*path = strdup("");

	if (*path == NULL) {
		warn("strdup");
		free(url);
		return NULL;
	}

	return url;
}

/*
 * Contact dnsproc and resolve a host.
 * Place the answers in "v" and return the number of answers, which can
 * be at most MAX_SERVERS_DNS.
 * Return <0 on failure.
 */
static ssize_t
urlresolve(int fd, const char *host, struct source *v)
{
	char		*addr;
	size_t		 i, sz;
	long		 lval;

	if (writeop(fd, COMM_DNS, DNS_LOOKUP) <= 0)
		return -1;
	else if (writestr(fd, COMM_DNSQ, host) <= 0)
		return -1;
	else if ((lval = readop(fd, COMM_DNSLEN)) < 0)
		return -1;

	sz = lval;
	assert(sz <= MAX_SERVERS_DNS);

	for (i = 0; i < sz; i++) {
		memset(&v[i], 0, sizeof(struct source));
		if ((lval = readop(fd, COMM_DNSF)) < 0)
			goto err;
		else if (lval != 4 && lval != 6)
			goto err;
		else if ((addr = readstr(fd, COMM_DNSA)) == NULL)
			goto err;
		v[i].family = lval;
		v[i].ip = addr;
	}

	return sz;
err:
	for (i = 0; i < sz; i++)
		free(v[i].ip);
	return -1;
}

/*
 * Send a "regular" HTTP GET message to "addr" and stuff the response
 * into the connection buffer.
 * Return the HTTP error code or <0 on failure.
 */
static long
nreq(struct conn *c, const char *addr)
{
	struct httpget	*g;
	struct source	 src[MAX_SERVERS_DNS];
	char		*host, *path;
	short		 port;
	size_t		 srcsz;
	ssize_t		 ssz;
	long		 code;

	if ((host = url2host(addr, &port, &path)) == NULL)
		return -1;

	if ((ssz = urlresolve(c->dfd, host, src)) < 0) {
		free(host);
		free(path);
		return -1;
	}
	srcsz = ssz;

	g = http_get(src, srcsz, host, port, path, NULL, 0);
	free(host);
	free(path);
	if (g == NULL)
		return -1;

	code = g->code;

	/* Copy the body part into our buffer. */

	free(c->buf.buf);
	c->buf.sz = g->bodypartsz;
	c->buf.buf = malloc(c->buf.sz);
	memcpy(c->buf.buf, g->bodypart, c->buf.sz);
	http_get_free(g);
	if (c->buf.buf == NULL) {
		warn("malloc");
		return -1;
	}
	return code;
}

/*
 * Create and send a signed communication to the ACME server.
 * Stuff the response into the communication buffer.
 * Return <0 on failure on the HTTP error code otherwise.
 */
static long
sreq(struct conn *c, const char *addr, const char *req)
{
	struct httpget	*g;
	struct source	 src[MAX_SERVERS_DNS];
	char		*host, *path, *nonce, *reqsn;
	short		 port;
	struct httphead	*h;
	ssize_t		 ssz;
	long		 code;

	if ((host = url2host(c->na, &port, &path)) == NULL)
		return -1;

	if ((ssz = urlresolve(c->dfd, host, src)) < 0) {
		free(host);
		free(path);
		return -1;
	}

	g = http_get(src, (size_t)ssz, host, port, path, NULL, 0);
	free(host);
	free(path);
	if (g == NULL)
		return -1;

	h = http_head_get("Replay-Nonce", g->head, g->headsz);
	if (h == NULL) {
		warnx("%s: no replay nonce", c->na);
		http_get_free(g);
		return -1;
	} else if ((nonce = strdup(h->val)) == NULL) {
		warn("strdup");
		http_get_free(g);
		return -1;
	}
	http_get_free(g);

	/*
	 * Send the nonce and request payload to the acctproc.
	 * This will create the proper JSON object we need.
	 */

	if (writeop(c->fd, COMM_ACCT, ACCT_SIGN) <= 0) {
		free(nonce);
		return -1;
	} else if (writestr(c->fd, COMM_PAY, req) <= 0) {
		free(nonce);
		return -1;
	} else if (writestr(c->fd, COMM_NONCE, nonce) <= 0) {
		free(nonce);
		return -1;
	}
	free(nonce);

	/* Now read back the signed payload. */

	if ((reqsn = readstr(c->fd, COMM_REQ)) == NULL)
		return -1;

	/* Now send the signed payload to the CA. */

	if ((host = url2host(addr, &port, &path)) == NULL) {
		free(reqsn);
		return -1;
	} else if ((ssz = urlresolve(c->dfd, host, src)) < 0) {
		free(host);
		free(path);
		free(reqsn);
		return -1;
	}

	g = http_get(src, (size_t)ssz, host, port, path, reqsn, strlen(reqsn));

	free(host);
	free(path);
	free(reqsn);
	if (g == NULL)
		return -1;

	/* Stuff response into parse buffer. */

	code = g->code;

	free(c->buf.buf);
	c->buf.sz = g->bodypartsz;
	c->buf.buf = malloc(c->buf.sz);
	memcpy(c->buf.buf, g->bodypart, c->buf.sz);
	http_get_free(g);
	if (c->buf.buf == NULL) {
		warn("malloc");
		return -1;
	}
	return code;
}

/*
 * Send to the CA that we want to authorise a new account.
 * This only happens once for a new account key.
 * Returns non-zero on success.
 */
static int
donewreg(struct conn *c, const char *agreement, const struct capaths *p)
{
	int		 rc = 0;
	char		*req;
	long		 lc;

	dodbg("%s: new-reg", p->newreg);

	if ((req = json_fmt_newreg(agreement)) == NULL)
		warnx("json_fmt_newreg");
	else if ((lc = sreq(c, p->newreg, req)) < 0)
		warnx("%s: bad comm", p->newreg);
	else if (lc != 200 && lc != 201)
		warnx("%s: bad HTTP: %ld", p->newreg, lc);
	else if (c->buf.buf == NULL || c->buf.sz == 0)
		warnx("%s: empty response", p->newreg);
	else
		rc = 1;

	if (rc == 0 || verbose > 1)
		buf_dump(&c->buf);
	free(req);
	return rc;
}

/*
 * Request a challenge for the given domain name.
 * This must happen for each name "alt".
 * On non-zero exit, fills in "chng" with the challenge.
 */
static int
dochngreq(struct conn *c, const char *alt, struct chng *chng,
    const struct capaths *p)
{
	int		 rc = 0;
	char		*req;
	long		 lc;
	struct jsmnn	*j = NULL;

	dodbg("%s: req-auth: %s", p->newauthz, alt);

	if ((req = json_fmt_newauthz(alt)) == NULL)
		warnx("json_fmt_newauthz");
	else if ((lc = sreq(c, p->newauthz, req)) < 0)
		warnx("%s: bad comm", p->newauthz);
	else if (lc != 200 && lc != 201)
		warnx("%s: bad HTTP: %ld", p->newauthz, lc);
	else if ((j = json_parse(c->buf.buf, c->buf.sz)) == NULL)
		warnx("%s: bad JSON object", p->newauthz);
	else if (!json_parse_challenge(j, chng))
		warnx("%s: bad challenge", p->newauthz);
	else
		rc = 1;

	if (rc == 0 || verbose > 1)
		buf_dump(&c->buf);
	json_free(j);
	free(req);
	return rc;
}

/*
 * Note to the CA that a challenge response is in place.
 */
static int
dochngresp(struct conn *c, const struct chng *chng, const char *th)
{
	int	 rc = 0;
	long	 lc;
	char	*req;

	dodbg("%s: challenge", chng->uri);

	if ((req = json_fmt_challenge(chng->token, th)) == NULL)
		warnx("json_fmt_challenge");
	else if ((lc = sreq(c, chng->uri, req)) < 0)
		warnx("%s: bad comm", chng->uri);
	else if (lc != 200 && lc != 201 && lc != 202)
		warnx("%s: bad HTTP: %ld", chng->uri, lc);
	else
		rc = 1;

	if (rc == 0 || verbose > 1)
		buf_dump(&c->buf);
	free(req);
	return rc;
}

/*
 * Check with the CA whether a challenge has been processed.
 * Note: we'll only do this a limited number of times, and pause for a
 * time between checks, but this happens in the caller.
 */
static int
dochngcheck(struct conn *c, struct chng *chng)
{
	int		 cc;
	long		 lc;
	struct jsmnn	*j;

	dodbg("%s: status", chng->uri);

	if ((lc = nreq(c, chng->uri)) < 0) {
		warnx("%s: bad comm", chng->uri);
		return 0;
	} else if (lc != 200 && lc != 201 && lc != 202) {
		warnx("%s: bad HTTP: %ld", chng->uri, lc);
		buf_dump(&c->buf);
		return 0;
	} else if ((j = json_parse(c->buf.buf, c->buf.sz)) == NULL) {
		warnx("%s: bad JSON object", chng->uri);
		buf_dump(&c->buf);
		return 0;
	} else if ((cc = json_parse_response(j)) == -1) {
		warnx("%s: bad response", chng->uri);
		buf_dump(&c->buf);
		json_free(j);
		return 0;
	} else if (cc > 0)
		chng->status = 1;

	json_free(j);
	return 1;
}

static int
dorevoke(struct conn *c, const char *addr, const char *cert)
{
	char		*req;
	int		 rc = 0;
	long		 lc = 0;

	dodbg("%s: revocation", addr);

	if ((req = json_fmt_revokecert(cert)) == NULL)
		warnx("json_fmt_revokecert");
	else if ((lc = sreq(c, addr, req)) < 0)
		warnx("%s: bad comm", addr);
	else if (lc != 200 && lc != 201 && lc != 409)
		warnx("%s: bad HTTP: %ld", addr, lc);
	else
		rc = 1;

	if (lc == 409)
		warnx("%s: already revoked", addr);

	if (rc == 0 || verbose > 1)
		buf_dump(&c->buf);
	free(req);
	return rc;
}

/*
 * Submit our certificate to the CA.
 * This, upon success, will return the signed CA.
 */
static int
docert(struct conn *c, const char *addr, const char *cert)
{
	char	*req;
	int	 rc = 0;
	long	 lc;

	dodbg("%s: certificate", addr);

	if ((req = json_fmt_newcert(cert)) == NULL)
		warnx("json_fmt_newcert");
	else if ((lc = sreq(c, addr, req)) < 0)
		warnx("%s: bad comm", addr);
	else if (lc != 200 && lc != 201)
		warnx("%s: bad HTTP: %ld", addr, lc);
	else if (c->buf.sz == 0 || c->buf.buf == NULL)
		warnx("%s: empty response", addr);
	else
		rc = 1;

	if (rc == 0 || verbose > 1)
		buf_dump(&c->buf);
	free(req);
	return rc;
}

/*
 * Look up directories from the certificate authority.
 */
static int
dodirs(struct conn *c, const char *addr, struct capaths *paths)
{
	struct jsmnn	*j = NULL;
	long		 lc;
	int		 rc = 0;

	dodbg("%s: directories", addr);

	if ((lc = nreq(c, addr)) < 0)
		warnx("%s: bad comm", addr);
	else if (lc != 200 && lc != 201)
		warnx("%s: bad HTTP: %ld", addr, lc);
	else if ((j = json_parse(c->buf.buf, c->buf.sz)) == NULL)
		warnx("json_parse");
	else if (!json_parse_capaths(j, paths))
		warnx("%s: bad CA paths", addr);
	else
		rc = 1;

	if (rc == 0 || verbose > 1)
		buf_dump(&c->buf);
	json_free(j);
	return rc;
}

/*
 * Request the full chain certificate.
 */
static int
dofullchain(struct conn *c, const char *addr)
{
	int	 rc = 0;
	long	 lc;

	dodbg("%s: full chain", addr);

	if ((lc = nreq(c, addr)) < 0)
		warnx("%s: bad comm", addr);
	else if (lc != 200 && lc != 201)
		warnx("%s: bad HTTP: %ld", addr, lc);
	else
		rc = 1;

	if (rc == 0 || verbose > 1)
		buf_dump(&c->buf);
	return rc;
}

/*
 * Here we communicate with the ACME server.
 * For this, we'll need the certificate we want to upload and our
 * account key information.
 */
int
netproc(int kfd, int afd, int Cfd, int cfd, int dfd, int rfd,
    int newacct, int revocate, struct authority_c *authority,
    const char *const *alts,size_t altsz, const char *agreement)
{
	int		 rc = 0;
	size_t		 i;
	char		*cert = NULL, *thumb = NULL, *url = NULL;
	struct conn	 c;
	struct capaths	 paths;
	struct chng	*chngs = NULL;
	long		 lval;

	memset(&paths, 0, sizeof(struct capaths));
	memset(&c, 0, sizeof(struct conn));

	if (pledge("stdio inet rpath", NULL) == -1) {
		warn("pledge");
		goto out;
	}

	if (http_init() == -1) {
		warn("http_init");
		goto out;
	}

	if (pledge("stdio inet", NULL) == -1) {
		warn("pledge");
		goto out;
	}

	/*
	 * Wait until the acctproc, keyproc, and revokeproc have started
	 * up and are ready to serve us data.
	 * There's no point in running if these don't work.
	 * Then check whether revokeproc indicates that the certificate
	 * on file (if any) can be updated.
	 */

	if ((lval = readop(afd, COMM_ACCT_STAT)) == 0) {
		rc = 1;
		goto out;
	} else if (lval != ACCT_READY) {
		warnx("unknown operation from acctproc");
		goto out;
	}

	if ((lval = readop(kfd, COMM_KEY_STAT)) == 0) {
		rc = 1;
		goto out;
	} else if (lval != KEY_READY) {
		warnx("unknown operation from keyproc");
		goto out;
	}

	if ((lval = readop(rfd, COMM_REVOKE_RESP)) == 0) {
		rc = 1;
		goto out;
	} else if (lval != REVOKE_EXP && lval != REVOKE_OK) {
		warnx("unknown operation from revokeproc");
		goto out;
	}

	/* If our certificate is up-to-date, return now. */

	if (lval == REVOKE_OK) {
		rc = 1;
		goto out;
	}

	/* Allocate main state. */

	chngs = calloc(altsz, sizeof(struct chng));
	if (chngs == NULL) {
		warn("calloc");
		goto out;
	}

	c.dfd = dfd;
	c.fd = afd;
	c.na = authority->api;

	/*
	 * Look up the domain of the ACME server.
	 * We'll use this ourselves instead of having libcurl do the DNS
	 * resolution itself.
	 */
	if (!dodirs(&c, c.na, &paths))
		goto out;

	/*
	 * If we're meant to revoke, then wait for revokeproc to send us
	 * the certificate (if it's found at all).
	 * Following that, submit the request to the CA then notify the
	 * certproc, which will in turn notify the fileproc.
	 */

	if (revocate) {
		if ((cert = readstr(rfd, COMM_CSR)) == NULL)
			goto out;
		if (!dorevoke(&c, paths.revokecert, cert))
			goto out;
		else if (writeop(cfd, COMM_CSR_OP, CERT_REVOKE) > 0)
			rc = 1;
		goto out;
	}

	/* If new, register with the CA server. */

	if (newacct && ! donewreg(&c, agreement, &paths))
		goto out;

	/* Pre-authorise all domains with CA server. */

	for (i = 0; i < altsz; i++)
		if (!dochngreq(&c, alts[i], &chngs[i], &paths))
			goto out;

	/*
	 * We now have our challenges.
	 * We need to ask the acctproc for the thumbprint.
	 * We'll combine this to the challenge to create our response,
	 * which will be orchestrated by the chngproc.
	 */

	if (writeop(afd, COMM_ACCT, ACCT_THUMBPRINT) <= 0)
		goto out;
	else if ((thumb = readstr(afd, COMM_THUMB)) == NULL)
		goto out;

	/* We'll now ask chngproc to build the challenge. */

	for (i = 0; i < altsz; i++) {
		if (writeop(Cfd, COMM_CHNG_OP, CHNG_SYN) <= 0)
			goto out;
		else if (writestr(Cfd, COMM_THUMB, thumb) <= 0)
			goto out;
		else if (writestr(Cfd, COMM_TOK, chngs[i].token) <= 0)
			goto out;

		/* Read that the challenge has been made. */

		if (readop(Cfd, COMM_CHNG_ACK) != CHNG_ACK)
			goto out;

		/* Write to the CA that it's ready. */

		if (!dochngresp(&c, &chngs[i], thumb))
			goto out;
	}

	/*
	 * We now wait on the ACME server for each domain.
	 * Connect to the server (assume it's the same server) once
	 * every five seconds.
	 */

	for (i = 0; i < altsz; i++) {
		if (chngs[i].status == 1)
			continue;

		if (chngs[i].retry++ >= RETRY_MAX) {
			warnx("%s: too many tries", chngs[i].uri);
			goto out;
		}

		/* Sleep before every attempt. */
		sleep(RETRY_DELAY);
		if (!dochngcheck(&c, &chngs[i]))
			goto out;
	}

	/*
	 * Write our acknowledgement that the challenges are over.
	 * The challenge process will remove all of the files.
	 */

	if (writeop(Cfd, COMM_CHNG_OP, CHNG_STOP) <= 0)
		goto out;

	/* Wait to receive the certificate itself. */

	if ((cert = readstr(kfd, COMM_CERT)) == NULL)
		goto out;

	/*
	 * Otherwise, submit the CA for signing, download the signed
	 * copy, and ship that into the certificate process for copying.
	 */

	if (!docert(&c, paths.newcert, cert))
		goto out;
	else if (writeop(cfd, COMM_CSR_OP, CERT_UPDATE) <= 0)
		goto out;
	else if (writebuf(cfd, COMM_CSR, c.buf.buf, c.buf.sz) <= 0)
		goto out;

	/*
	 * Read back the issuer from the certproc.
	 * Then contact the issuer to get the certificate chain.
	 * Write this chain directly back to the certproc.
	 */

	if ((url = readstr(cfd, COMM_ISSUER)) == NULL)
		goto out;
	else if (!dofullchain(&c, url))
		goto out;
	else if (writebuf(cfd, COMM_CHAIN, c.buf.buf, c.buf.sz) <= 0)
		goto out;

	rc = 1;
out:
	close(cfd);
	close(kfd);
	close(afd);
	close(Cfd);
	close(dfd);
	close(rfd);
	free(cert);
	free(url);
	free(thumb);
	free(c.buf.buf);
	if (chngs != NULL)
		for (i = 0; i < altsz; i++)
			json_free_challenge(&chngs[i]);
	free(chngs);
	json_free_capaths(&paths);
	return rc;
}
@


1.12
log
@Replace comparisons between a constant or enum and an expression, with
a comparison between the expression and the constant or enum. This
significantly improves readability.

Transformed with coccinelle.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.11 2017/01/21 08:41:42 benno Exp $ */
d101 1
a101 1
			return (NULL);
d107 1
a107 1
			return (NULL);
d111 1
a111 1
		return (NULL);
d125 1
a125 1
		return (NULL);
d128 1
a128 1
	return (url);
d145 1
a145 1
		return (-1);
d147 1
a147 1
		return (-1);
d149 1
a149 1
		return (-1);
d166 1
a166 1
	return (sz);
d170 1
a170 1
	return (-1);
d190 1
a190 1
		return (-1);
d195 1
a195 1
		return (-1);
d203 1
a203 1
		return (-1);
d216 1
a216 1
		return (-1);
d218 1
a218 1
	return (code);
d238 1
a238 1
		return (-1);
d243 1
a243 1
		return (-1);
d250 1
a250 1
		return (-1);
d256 1
a256 1
		return (-1);
d260 1
a260 1
		return (-1);
d271 1
a271 1
		return (-1);
d274 1
a274 1
		return (-1);
d277 1
a277 1
		return (-1);
d284 1
a284 1
		return (-1);
d290 1
a290 1
		return (-1);
d295 1
a295 1
		return (-1);
d304 1
a304 1
		return (-1);
d317 1
a317 1
		return (-1);
d319 1
a319 1
	return (code);
d350 1
a350 1
	return (rc);
d386 1
a386 1
	return (rc);
d413 1
a413 1
	return (rc);
d432 1
a432 1
		return (0);
d436 1
a436 1
		return (0);
d440 1
a440 1
		return (0);
d445 1
a445 1
		return (0);
d450 1
a450 1
	return (1);
d477 1
a477 1
	return (rc);
d507 1
a507 1
	return (rc);
d536 1
a536 1
	return (rc);
d559 1
a559 1
	return (rc);
d794 1
a794 1
	return (rc);
@


1.11
log
@acme-client use configuration file [1 of 5]

start using the configuration file and delete command line arguments:

-a agreement    -> agreement url ...
-c certdir      -> domain certificate "path"
-f accountkey   -> account key "path"
-k domainkey    -> domain key "path"
-s authority    -> sign with "name"

new argument:
-f configfile

the changes needed to use the new configuration are local to main.c for now.
While the configuration could be passed directly to netproc(), keyproc() etc,
the diff is smaller this way.

This also removes the multidir (-m) mode for now - specify different paths in
each domain {} block instead.

ok florian
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.10 2016/10/04 15:49:42 jsing Exp $ */
d67 1
a67 1
	if (0 == buf->sz)
d69 1
a69 1
	if (NULL == (nbuf = malloc(buf->sz)))
d97 1
a97 1
	if (0 == strncmp(host, "https://", 8)) {
d99 1
a99 1
		if (NULL == (url = strdup(host + 8))) {
d103 1
a103 1
	} else if (0 == strncmp(host, "http://", 7)) {
d105 1
a105 1
		if (NULL == (url = strdup(host + 7))) {
d116 1
a116 1
	if (NULL != (ep = strchr(url, '/'))) {
d122 1
a122 1
	if (NULL == *path) {
d158 1
a158 1
		else if (4 != lval && 6 != lval)
d160 1
a160 1
		else if (NULL == (addr = readstr(fd, COMM_DNSA)))
d189 1
a189 1
	if (NULL == (host = url2host(addr, &port, &path)))
d202 1
a202 1
	if (NULL == g)
d214 1
a214 1
	if (NULL == c->buf.buf) {
d237 1
a237 1
	if (NULL == (host = url2host(c->na, &port, &path)))
d249 1
a249 1
	if (NULL == g)
d253 1
a253 1
	if (NULL == h) {
d257 1
a257 1
	} else if (NULL == (nonce = strdup(h->val))) {
d283 1
a283 1
	if (NULL == (reqsn = readstr(c->fd, COMM_REQ)))
d288 1
a288 1
	if (NULL == (host = url2host(addr, &port, &path))) {
d303 1
a303 1
	if (NULL == g)
d315 1
a315 1
	if (NULL == c->buf.buf) {
d336 1
a336 1
	if (NULL == (req = json_fmt_newreg(agreement)))
d340 1
a340 1
	else if (200 != lc && 201 != lc)
d342 1
a342 1
	else if (NULL == c->buf.buf || 0 == c->buf.sz)
d347 1
a347 1
	if (0 == rc || verbose > 1)
d369 1
a369 1
	if (NULL == (req = json_fmt_newauthz(alt)))
d373 1
a373 1
	else if (200 != lc && 201 != lc)
d375 1
a375 1
	else if (NULL == (j = json_parse(c->buf.buf, c->buf.sz)))
d382 1
a382 1
	if (0 == rc || verbose > 1)
d401 1
a401 1
	if (NULL == (req = json_fmt_challenge(chng->token, th)))
d405 1
a405 1
	else if (200 != lc && 201 != lc && 202 != lc)
d410 1
a410 1
	if (0 == rc || verbose > 1)
d433 1
a433 1
	} else if (200 != lc && 201 != lc && 202 != lc) {
d437 1
a437 1
	} else if (NULL == (j = json_parse(c->buf.buf, c->buf.sz))) {
d441 1
a441 1
	} else if (-1 == (cc = json_parse_response(j))) {
d462 1
a462 1
	if (NULL == (req = json_fmt_revokecert(cert)))
d466 1
a466 1
	else if (200 != lc && 201 != lc && 409 != lc)
d471 1
a471 1
	if (409 == lc)
d474 1
a474 1
	if (0 == rc || verbose > 1)
d493 1
a493 1
	if (NULL == (req = json_fmt_newcert(cert)))
d497 1
a497 1
	else if (200 != lc && 201 != lc)
d499 1
a499 1
	else if (0 == c->buf.sz || NULL == c->buf.buf)
d504 1
a504 1
	if (0 == rc || verbose > 1)
d524 1
a524 1
	else if (200 != lc && 201 != lc)
d526 1
a526 1
	else if (NULL == (j = json_parse(c->buf.buf, c->buf.sz)))
d533 1
a533 1
	if (0 == rc || verbose > 1)
d552 1
a552 1
	else if (200 != lc && 201 != lc)
d557 1
a557 1
	if (0 == rc || verbose > 1)
d606 1
a606 1
	if (0 == (lval = readop(afd, COMM_ACCT_STAT))) {
d609 1
a609 1
	} else if (ACCT_READY != lval) {
d614 1
a614 1
	if (0 == (lval = readop(kfd, COMM_KEY_STAT))) {
d617 1
a617 1
	} else if (KEY_READY != lval) {
d622 1
a622 1
	if (0 == (lval = readop(rfd, COMM_REVOKE_RESP))) {
d625 1
a625 1
	} else if (REVOKE_EXP != lval && REVOKE_OK != lval) {
d632 1
a632 1
	if (REVOKE_OK == lval) {
d640 1
a640 1
	if (NULL == chngs) {
d665 1
a665 1
		if (NULL == (cert = readstr(rfd, COMM_CSR)))
d694 1
a694 1
	else if (NULL == (thumb = readstr(afd, COMM_THUMB)))
d709 1
a709 1
		if (CHNG_ACK != readop(Cfd, COMM_CHNG_ACK))
d725 1
a725 1
		if (1 == chngs[i].status)
d749 1
a749 1
	if (NULL == (cert = readstr(kfd, COMM_CERT)))
d770 1
a770 1
	if (NULL == (url = readstr(cfd, COMM_ISSUER)))
d789 1
a789 1
	if (NULL != chngs)
@


1.10
log
@Avoid a potential MITM - calling tls_config_insecure_noverify() is a bad
idea, so stop doing that. Instead, use a single tls_config, set it up and
configure the CA file to use while we still have rpath, then drop rpath.
This also avoids creating a new tls_config for each and every HTTPS
connection, which is unnecessary.

ok benno@@ florian@@
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.9 2016/10/04 15:41:07 jsing Exp $ */
d28 1
d569 2
a570 2
    int newacct, int revocate, int authority, const char *const *alts,
    size_t altsz, const char *agreement)
d647 1
a647 1
	c.na = authorities[authority].caurl;
@


1.9
log
@s/letsencrypt/ACME/
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.8 2016/09/13 17:13:37 deraadt Exp $ */
d581 10
@


1.8
log
@A small amount more KNF to make this easier on our eyes.  Not going further
than this.
ok florian
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.7 2016/09/13 16:49:28 deraadt Exp $ */
d562 1
a562 1
 * Here we communicate with the letsencrypt server.
@


1.7
log
@hoist local variable initialization directly into the definitions,
rather than doing it right afterwards.
ok florian
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.6 2016/09/01 12:17:00 florian Exp $ */
d79 1
a79 1
				buf->buf[i] : '?';
d297 1
a297 2
	g = http_get(src, (size_t)ssz, host,
		port, path, reqsn, strlen(reqsn));
d327 1
a327 2
donewreg(struct conn *c, const char *agreement,
	const struct capaths *p)
d358 2
a359 2
dochngreq(struct conn *c, const char *alt,
	struct chng *chng, const struct capaths *p)
d376 1
a376 1
	else if ( ! json_parse_challenge(j, chng))
d527 1
a527 1
	else if ( ! json_parse_capaths(j, paths))
d568 2
a569 2
    int newacct, int revocate, int authority,
    const char *const *alts, size_t altsz, const char *agreement)
d643 1
a643 1
	if ( ! dodirs(&c, c.na, &paths))
d656 1
a656 1
		if ( ! dorevoke(&c, paths.revokecert, cert))
d671 1
a671 1
		if ( ! dochngreq(&c, alts[i], &chngs[i], &paths))
d703 1
a703 1
		if ( ! dochngresp(&c, &chngs[i], thumb))
d724 1
a724 1
		if ( ! dochngcheck(&c, &chngs[i]))
d746 1
a746 1
	if ( ! docert(&c, paths.newcert, cert))
d761 1
a761 1
	else if ( ! dofullchain(&c, url))
@


1.6
log
@Implement table driven selection to which ACME authorities we can
talk.
Suggest by and OK deraadt, OK benno.

(Later on deraadt and benno discussed if this should be handled with a
config file. This seems to be good enough for now. We can do a config
file later.)
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.5 2016/09/01 00:35:22 florian Exp $ */
d331 1
a331 1
	int		 rc;
a334 1
	rc = 0;
d363 1
a363 1
	int		 rc;
d366 1
a366 1
	struct jsmnn	*j;
a367 2
	j = NULL;
	rc = 0;
d396 1
a396 1
	int	 rc;
a399 1
	rc = 0;
d458 2
a459 2
	int		 rc;
	long		 lc;
a460 2
	lc = 0;
	rc = 0;
d489 1
a489 1
	int	 rc;
a491 1
	rc = 0;
d517 1
a517 1
	struct jsmnn	*j;
d519 1
a519 1
	int		 rc;
a520 2
	j = NULL;
	rc = 0;
d546 1
a546 1
	int	 rc;
a548 1
	rc = 0;
d570 2
a571 2
	int newacct, int revocate, int authority,
	const char *const *alts, size_t altsz, const char *agreement)
d573 1
a573 1
	int		 rc;
d575 1
a575 1
	char		*cert, *thumb, *url;
d578 1
a578 1
	struct chng	*chngs;
a580 1
	rc = 0;
a582 2
	url = cert = thumb = NULL;
	chngs = NULL;
@


1.5
log
@we don't have config.h
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.4 2016/09/01 00:21:36 deraadt Exp $ */
a28 3
#define URL_REAL_CA "https://acme-v01.api.letsencrypt.org/directory"
#define URL_STAGE_CA "https://acme-staging.api.letsencrypt.org/directory"

d580 1
a580 1
	int newacct, int revocate, int staging,
d651 1
a651 1
	c.na = staging ? URL_STAGE_CA : URL_REAL_CA;
@


1.4
log
@Collapse krazy abstractions for other sandbox models, using chroot and
pledge directly as needed.
ok florian
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.3 2016/08/31 23:36:16 benno Exp $ */
a16 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.3
log
@whitespace
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.2 2016/08/31 22:57:36 deraadt Exp $ */
d603 2
a604 9
	/* File-system, user, and sandbox jail. */

	if ( ! sandbox_before())
		goto out;
	else if ( ! dropfs(PATH_VAR_EMPTY))
		goto out;
	else if ( ! dropprivs())
		goto out;
	else if ( ! sandbox_after())
d606 1
@


1.2
log
@revoke -> revocate, to avoid alias
ok florian
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.1 2016/08/31 22:01:42 florian Exp $ */
d106 1
a106 1
			return(NULL);
d112 1
a112 1
			return(NULL);
d116 1
a116 1
		return(NULL);
d130 1
a130 1
		return(NULL);
d132 2
a133 2
 
	return(url);
d145 3
a147 3
	char	  	  *addr;
	size_t	  	   i, sz;
	long	  	   lval;
d150 1
a150 1
		return(-1);
d152 1
a152 1
		return(-1);
d154 1
a154 1
		return(-1);
d165 1
a165 1
		else if (NULL == (addr = readstr(fd, COMM_DNSA))) 
d171 1
a171 1
	return(sz);
d175 1
a175 1
	return(-1);
d195 1
a195 1
		return(-1);
d200 1
a200 1
		return(-1);
d208 1
a208 1
		return(-1);
d216 1
a216 1
	c->buf.buf = malloc(c->buf.sz);	
d221 1
a221 1
		return(-1);
d223 1
a223 1
	return(code);
d243 1
a243 1
		return(-1);
d248 1
a248 1
		return(-1);
d255 1
a255 1
		return(-1);
d261 1
a261 1
		return(-1);
d265 1
a265 1
		return(-1);
d269 1
a269 1
	/* 
d276 1
a276 1
		return(-1);
d279 1
a279 1
		return(-1);
d282 1
a282 1
		return(-1);
d289 1
a289 1
		return(-1);
d295 1
a295 1
		return(-1);
d300 1
a300 1
		return(-1);
d303 1
a303 1
	g = http_get(src, (size_t)ssz, host, 
d310 1
a310 1
		return(-1);
d318 1
a318 1
	c->buf.buf = malloc(c->buf.sz);	
d323 1
a323 1
		return(-1);
d325 1
a325 1
	return(code);
d334 1
a334 1
donewreg(struct conn *c, const char *agreement, 
d358 1
a358 1
	return(rc);
d367 1
a367 1
dochngreq(struct conn *c, const char *alt, 
d387 1
a387 1
	else if ( ! json_parse_challenge(j, chng)) 
d396 1
a396 1
	return(rc);
d416 1
a416 1
	else if (200 != lc && 201 != lc && 202 != lc) 
d424 1
a424 1
	return(rc);
d443 1
a443 1
		return(0);
d447 1
a447 1
		return(0);
d451 1
a451 1
		return(0);
d456 1
a456 1
		return(0);
d461 1
a461 1
	return(1);
d490 1
a490 1
	return(rc);
d521 1
a521 1
	return(rc);
d552 1
a552 1
	return(rc);
d576 1
a576 1
	return(rc);
d586 1
a586 1
	int newacct, int revocate, int staging, 
d594 1
a594 1
	struct chng 	*chngs;
d605 1
a605 1
	if ( ! sandbox_before()) 
d614 1
a614 1
	/* 
d644 1
a644 1
	} 
d652 1
a652 1
	
d683 1
a683 1
		if ( ! dorevoke(&c, paths.revokecert, cert)) 
d688 1
a688 1
	} 
d755 1
a755 1
	/* 
d773 1
a773 1
	if ( ! docert(&c, paths.newcert, cert)) 
d780 1
a780 1
	/* 
d810 1
a810 1
	return(rc);
@


1.1
log
@Import Kristaps' letskencrypt and call it acme-client in tree.
OK to get it in deraadt@@ (and probably beck@@)

At least deraadt@@, beck@@ and otto@@ are fine with the name and the
disagreements stopped.
@
text
@d1 1
a1 1
/*	$Id: netproc.c,v 1.63 2016/08/06 17:37:21 kristaps Exp $ */
d586 1
a586 1
	int newacct, int revoke, int staging, 
d680 1
a680 1
	if (revoke) {
@

