head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.2
	OPENBSD_6_1_BASE:1.34;
locks; strict;
comment	@ * @;


1.34
date	2017.03.23.12.58.28;	author florian;	state Exp;
branches;
next	1.33;
commitid	viKs4jFX40cWmc5P;

1.33
date	2017.01.24.13.32.55;	author jsing;	state Exp;
branches;
next	1.32;
commitid	d53S4Fpx9gPB2Hox;

1.32
date	2017.01.24.12.53.52;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	QYSA2DhKNoKjBuQG;

1.31
date	2017.01.24.12.38.41;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	dm3gPrFl8qY6XMgD;

1.30
date	2017.01.24.12.05.14;	author jsing;	state Exp;
branches;
next	1.29;
commitid	8yg0jKPVoY1hQFt1;

1.29
date	2017.01.21.15.53.15;	author jmc;	state Exp;
branches;
next	1.28;
commitid	uFz3ZWg6ET7ZanFc;

1.28
date	2017.01.21.12.59.06;	author benno;	state Exp;
branches;
next	1.27;
commitid	0yg1zkbZVPED65C0;

1.27
date	2017.01.21.12.54.10;	author florian;	state Exp;
branches;
next	1.26;
commitid	mkwEBMFRIM4VxyvV;

1.26
date	2017.01.21.09.00.29;	author benno;	state Exp;
branches;
next	1.25;
commitid	CMrTfyA83h2coxRw;

1.25
date	2017.01.21.08.55.09;	author florian;	state Exp;
branches;
next	1.24;
commitid	Hg0OwJOQlOaOYtKU;

1.24
date	2017.01.21.08.54.26;	author florian;	state Exp;
branches;
next	1.23;
commitid	Uiu2I50X4ppn4tZ4;

1.23
date	2017.01.21.08.52.30;	author florian;	state Exp;
branches;
next	1.22;
commitid	q7qJsshzLEmCz5cx;

1.22
date	2017.01.21.08.51.00;	author florian;	state Exp;
branches;
next	1.21;
commitid	T7qIHmRXCYj7oUQO;

1.21
date	2017.01.21.08.49.59;	author florian;	state Exp;
branches;
next	1.20;
commitid	aZl2SOEwNNYkJM8e;

1.20
date	2017.01.21.08.48.11;	author florian;	state Exp;
branches;
next	1.19;
commitid	xFqAdcUs1HXTLl7d;

1.19
date	2017.01.21.08.47.21;	author benno;	state Exp;
branches;
next	1.18;
commitid	MbkMl6gkRxhbIoJK;

1.18
date	2017.01.21.08.45.52;	author benno;	state Exp;
branches;
next	1.17;
commitid	ucXLMiWW7wrYIkLR;

1.17
date	2017.01.21.08.44.35;	author benno;	state Exp;
branches;
next	1.16;
commitid	Y1oxAc4HVi4RfSjT;

1.16
date	2017.01.21.08.43.09;	author benno;	state Exp;
branches;
next	1.15;
commitid	finywD0D93nLo0tu;

1.15
date	2017.01.21.08.41.42;	author benno;	state Exp;
branches;
next	1.14;
commitid	gRa5yf7qfj3cY6Ul;

1.14
date	2016.09.18.20.18.25;	author benno;	state Exp;
branches;
next	1.13;
commitid	aNA1IkqJB7MlJKGl;

1.13
date	2016.09.13.17.13.37;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	nxoiZiJPhAAVKQhE;

1.12
date	2016.09.13.16.49.28;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	Kh60oAaRyMBwMrcR;

1.11
date	2016.09.13.16.04.51;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	24EhsuVM5m11dYAL;

1.10
date	2016.09.01.13.47.54;	author florian;	state Exp;
branches;
next	1.9;
commitid	FaYlHZzjsW3P17Fx;

1.9
date	2016.09.01.12.17.00;	author florian;	state Exp;
branches;
next	1.8;
commitid	gosvRyqlI28bFwVD;

1.8
date	2016.09.01.00.35.22;	author florian;	state Exp;
branches;
next	1.7;
commitid	BIKpBY4sC6SiXDhj;

1.7
date	2016.09.01.00.32.00;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	FOdvEuW2tyLUIMzo;

1.6
date	2016.09.01.00.21.36;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	P9IiJlKSbxnKzQyC;

1.5
date	2016.09.01.00.03.39;	author benno;	state Exp;
branches;
next	1.4;
commitid	q7yMAvCHhRlsZSOk;

1.4
date	2016.08.31.23.30.59;	author benno;	state Exp;
branches;
next	1.3;
commitid	ab2GrYGqqNzHEUYW;

1.3
date	2016.08.31.22.57.36;	author deraadt;	state Exp;
branches;
next	1.2;
commitid	eGljFCfJCPC54si7;

1.2
date	2016.08.31.22.20.53;	author florian;	state Exp;
branches;
next	1.1;
commitid	nQCQp7KVH1l1RBlq;

1.1
date	2016.08.31.22.01.42;	author florian;	state Exp;
branches;
next	;
commitid	1Bh2CBIwvUy50FSg;


desc
@@


1.34
log
@pull root check up, the parser will bomb out anyway
OK benno
@
text
@/*	$Id: main.c,v 1.33 2017/01/24 13:32:55 jsing Exp $ */
/*
 * Copyright (c) 2016 Kristaps Dzonsons <kristaps@@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/socket.h>

#include <ctype.h>
#include <err.h>
#include <libgen.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "extern.h"
#include "parse.h"

#define WWW_DIR "/var/www/acme"
#define CONF_FILE "/etc/acme-client.conf"

int
main(int argc, char *argv[])
{
	const char	 **alts = NULL;
	char		 *certdir = NULL, *certfile = NULL;
	char		 *chainfile = NULL, *fullchainfile = NULL;
	char		 *acctkey = NULL;
	char		 *chngdir = NULL, *auth = NULL, *agreement = NULL;
	char		 *conffile = CONF_FILE;
	int		  key_fds[2], acct_fds[2], chng_fds[2], cert_fds[2];
	int		  file_fds[2], dns_fds[2], rvk_fds[2];
	int		  force = 0;
	int		  c, rc, revocate = 0;
	int		  popts = 0;
	pid_t		  pids[COMP__MAX];
	extern int	  verbose;
	extern enum comp  proccomp;
	size_t		  i, altsz, ne;

	struct acme_conf	*conf = NULL;
	struct authority_c	*authority = NULL;
	struct domain_c		*domain = NULL;
	struct altname_c	*ac;

	while ((c = getopt(argc, argv, "FADrvnf:")) != -1)
		switch (c) {
		case 'f':
			if ((conffile = strdup(optarg)) == NULL)
				err(EXIT_FAILURE, "strdup");
			break;
		case 'F':
			force = 1;
			break;
		case 'A':
			popts |= ACME_OPT_NEWACCT;
			break;
		case 'D':
			popts |= ACME_OPT_NEWDKEY;
			break;
		case 'r':
			revocate = 1;
			break;
		case 'v':
			verbose = verbose ? 2 : 1;
			popts |= ACME_OPT_VERBOSE;
			break;
		case 'n':
			popts |= ACME_OPT_CHECK;
			break;
		default:
			goto usage;
		}

	if (getuid() != 0)
		errx(EXIT_FAILURE, "must be run as root");

	/* parse config file */
	if ((conf = parse_config(conffile, popts)) == NULL)
		exit(EXIT_FAILURE);

	argc -= optind;
	argv += optind;
	if (argc != 1)
		goto usage;

	if ((domain = domain_find(conf, argv[0])) == NULL)
		errx(EXIT_FAILURE, "domain %s not found", argv[0]);

	argc--;
	argv++;

	if (domain->cert != NULL) {
		if ((certdir = dirname(domain->cert)) != NULL) {
			if ((certdir = strdup(certdir)) == NULL)
				err(EXIT_FAILURE, "strdup");
		} else
			err(EXIT_FAILURE, "dirname");
	} else {
		/* the parser enforces that at least cert or fullchain is set */
		if ((certdir = dirname(domain->fullchain)) != NULL) {
			if ((certdir = strdup(certdir)) == NULL)
				err(EXIT_FAILURE, "strdup");
		} else
			err(EXIT_FAILURE, "dirname");

	}

	if (domain->cert != NULL) {
		if ((certfile = basename(domain->cert)) != NULL) {
			if ((certfile = strdup(certfile)) == NULL)
				err(EXIT_FAILURE, "strdup");
		} else
			err(EXIT_FAILURE, "basename");
	}

	if(domain->chain != NULL) {
		if ((chainfile = strstr(domain->chain, certdir)) != NULL)
			chainfile = domain->chain + strlen(certdir);
		else
			chainfile = domain->chain;

		if ((chainfile = strdup(chainfile)) == NULL)
			err(EXIT_FAILURE, "strdup");
	}

	if(domain->fullchain != NULL) {
		if ((fullchainfile = strstr(domain->fullchain, certdir)) != NULL)
			fullchainfile = domain->fullchain + strlen(certdir);
		else
			fullchainfile = domain->fullchain;

		if ((fullchainfile = strdup(fullchainfile)) == NULL)
			err(EXIT_FAILURE, "strdup");
	}

	if ((auth = domain->auth) == NULL) {
		/* use the first authority from the config as default XXX */
		authority = authority_find0(conf);
		if (authority == NULL)
			errx(EXIT_FAILURE, "no authorities configured");
	} else {
		authority = authority_find(conf, auth);
		if (authority == NULL)
			errx(EXIT_FAILURE, "authority %s not found", auth);
	}

	agreement = authority->agreement;
	acctkey = authority->account;

	if (acctkey == NULL) {
		/* XXX replace with existance check in parse.y */
		err(EXIT_FAILURE, "no account key in config?");
	}
	if (domain->challengedir == NULL)
		chngdir = strdup(WWW_DIR);
	else
		chngdir = domain->challengedir;

	if (chngdir == NULL)
		err(EXIT_FAILURE, "strdup");

	/*
	 * Do some quick checks to see if our paths exist.
	 * This will be done in the children, but we might as well check
	 * now before the fork.
	 * XXX maybe use conf_check_file() from parse.y
	 */

	ne = 0;

	if (access(certdir, R_OK) == -1) {
		warnx("%s: cert directory must exist", certdir);
		ne++;
	}

	if (!(popts & ACME_OPT_NEWDKEY) && access(domain->key, R_OK) == -1) {
		warnx("%s: domain key file must exist", domain->key);
		ne++;
	} else if ((popts & ACME_OPT_NEWDKEY) && access(domain->key, R_OK) != -1) {
		dodbg("%s: domain key exists (not creating)", domain->key);
		popts &= ~ACME_OPT_NEWDKEY;
	}

	if (access(chngdir, R_OK) == -1) {
		warnx("%s: challenge directory must exist", chngdir);
		ne++;
	}

	if (!(popts & ACME_OPT_NEWACCT) && access(acctkey, R_OK) == -1) {
		warnx("%s: account key file must exist", acctkey);
		ne++;
	} else if ((popts & ACME_OPT_NEWACCT) && access(acctkey, R_OK) != -1) {
		dodbg("%s: account key exists (not creating)", acctkey);
		popts &= ~ACME_OPT_NEWACCT;
	}

	if (ne > 0)
		exit(EXIT_FAILURE);

	if (popts & ACME_OPT_CHECK)
		exit(EXIT_SUCCESS);

	/* Set the zeroth altname as our domain. */
	altsz = domain->altname_count + 1;
	alts = calloc(altsz, sizeof(char *));
	if (alts == NULL)
		err(EXIT_FAILURE, "calloc");
	alts[0] = domain->domain;
	i = 1;
	/* XXX get rid of alts[] later */
	TAILQ_FOREACH(ac, &domain->altname_list, entry)
		alts[i++] = ac->domain;

	/*
	 * Open channels between our components.
	 */

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, key_fds) == -1)
		err(EXIT_FAILURE, "socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, acct_fds) == -1)
		err(EXIT_FAILURE, "socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, chng_fds) == -1)
		err(EXIT_FAILURE, "socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, cert_fds) == -1)
		err(EXIT_FAILURE, "socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, file_fds) == -1)
		err(EXIT_FAILURE, "socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, dns_fds) == -1)
		err(EXIT_FAILURE, "socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, rvk_fds) == -1)
		err(EXIT_FAILURE, "socketpair");

	/* Start with the network-touching process. */

	if ((pids[COMP_NET] = fork()) == -1)
		err(EXIT_FAILURE, "fork");

	if (pids[COMP_NET] == 0) {
		proccomp = COMP_NET;
		close(key_fds[0]);
		close(acct_fds[0]);
		close(chng_fds[0]);
		close(cert_fds[0]);
		close(file_fds[0]);
		close(file_fds[1]);
		close(dns_fds[0]);
		close(rvk_fds[0]);
		c = netproc(key_fds[1], acct_fds[1],
		    chng_fds[1], cert_fds[1],
		    dns_fds[1], rvk_fds[1],
		    (popts & ACME_OPT_NEWACCT), revocate, authority,
		    (const char *const *)alts, altsz,
		    agreement);
		free(alts);
		exit(c ? EXIT_SUCCESS : EXIT_FAILURE);
	}

	close(key_fds[1]);
	close(acct_fds[1]);
	close(chng_fds[1]);
	close(cert_fds[1]);
	close(dns_fds[1]);
	close(rvk_fds[1]);

	/* Now the key-touching component. */

	if ((pids[COMP_KEY] = fork()) == -1)
		err(EXIT_FAILURE, "fork");

	if (pids[COMP_KEY] == 0) {
		proccomp = COMP_KEY;
		close(cert_fds[0]);
		close(dns_fds[0]);
		close(rvk_fds[0]);
		close(acct_fds[0]);
		close(chng_fds[0]);
		close(file_fds[0]);
		close(file_fds[1]);
		c = keyproc(key_fds[0], domain->key,
		    (const char **)alts, altsz, (popts & ACME_OPT_NEWDKEY));
		free(alts);
		exit(c ? EXIT_SUCCESS : EXIT_FAILURE);
	}

	close(key_fds[0]);

	/* The account-touching component. */

	if ((pids[COMP_ACCOUNT] = fork()) == -1)
		err(EXIT_FAILURE, "fork");

	if (pids[COMP_ACCOUNT] == 0) {
		proccomp = COMP_ACCOUNT;
		free(alts);
		close(cert_fds[0]);
		close(dns_fds[0]);
		close(rvk_fds[0]);
		close(chng_fds[0]);
		close(file_fds[0]);
		close(file_fds[1]);
		c = acctproc(acct_fds[0], acctkey, (popts & ACME_OPT_NEWACCT));
		exit(c ? EXIT_SUCCESS : EXIT_FAILURE);
	}

	close(acct_fds[0]);

	/* The challenge-accepting component. */

	if ((pids[COMP_CHALLENGE] = fork()) == -1)
		err(EXIT_FAILURE, "fork");

	if (pids[COMP_CHALLENGE] == 0) {
		proccomp = COMP_CHALLENGE;
		free(alts);
		close(cert_fds[0]);
		close(dns_fds[0]);
		close(rvk_fds[0]);
		close(file_fds[0]);
		close(file_fds[1]);
		c = chngproc(chng_fds[0], chngdir);
		exit(c ? EXIT_SUCCESS : EXIT_FAILURE);
	}

	close(chng_fds[0]);

	/* The certificate-handling component. */

	if ((pids[COMP_CERT] = fork()) == -1)
		err(EXIT_FAILURE, "fork");

	if (pids[COMP_CERT] == 0) {
		proccomp = COMP_CERT;
		free(alts);
		close(dns_fds[0]);
		close(rvk_fds[0]);
		close(file_fds[1]);
		c = certproc(cert_fds[0], file_fds[0]);
		exit(c ? EXIT_SUCCESS : EXIT_FAILURE);
	}

	close(cert_fds[0]);
	close(file_fds[0]);

	/* The certificate-handling component. */

	if ((pids[COMP_FILE] = fork()) == -1)
		err(EXIT_FAILURE, "fork");

	if (pids[COMP_FILE] == 0) {
		proccomp = COMP_FILE;
		free(alts);
		close(dns_fds[0]);
		close(rvk_fds[0]);
		c = fileproc(file_fds[1], certdir, certfile, chainfile,
		    fullchainfile);
		/*
		 * This is different from the other processes in that it
		 * can return 2 if the certificates were updated.
		 */
		exit(c > 1 ? 2 : (c ? EXIT_SUCCESS : EXIT_FAILURE));
	}

	close(file_fds[1]);

	/* The DNS lookup component. */

	if ((pids[COMP_DNS] = fork()) == -1)
		err(EXIT_FAILURE, "fork");

	if (pids[COMP_DNS] == 0) {
		proccomp = COMP_DNS;
		free(alts);
		close(rvk_fds[0]);
		c = dnsproc(dns_fds[0]);
		exit(c ? EXIT_SUCCESS : EXIT_FAILURE);
	}

	close(dns_fds[0]);

	/* The expiration component. */

	if ((pids[COMP_REVOKE] = fork()) == -1)
		err(EXIT_FAILURE, "fork");

	if (pids[COMP_REVOKE] == 0) {
		proccomp = COMP_REVOKE;
		c = revokeproc(rvk_fds[0], certdir,
		    certfile != NULL ? certfile : fullchainfile,
		    force, revocate,
		    (const char *const *)alts, altsz);
		free(alts);
		exit(c ? EXIT_SUCCESS : EXIT_FAILURE);
	}

	close(rvk_fds[0]);

	/* Jail: sandbox, file-system, user. */

	if (pledge("stdio", NULL) == -1) {
		warn("pledge");
		exit(EXIT_FAILURE);
	}

	/*
	 * Collect our subprocesses.
	 * Require that they both have exited cleanly.
	 */

	rc = checkexit(pids[COMP_KEY], COMP_KEY) +
	    checkexit(pids[COMP_CERT], COMP_CERT) +
	    checkexit(pids[COMP_NET], COMP_NET) +
	    checkexit_ext(&c, pids[COMP_FILE], COMP_FILE) +
	    checkexit(pids[COMP_ACCOUNT], COMP_ACCOUNT) +
	    checkexit(pids[COMP_CHALLENGE], COMP_CHALLENGE) +
	    checkexit(pids[COMP_DNS], COMP_DNS) +
	    checkexit(pids[COMP_REVOKE], COMP_REVOKE);

	free(alts);
	return rc != COMP__MAX ? EXIT_FAILURE : (c == 2 ? EXIT_SUCCESS : 2);
usage:
	fprintf(stderr,
	    "usage: acme-client [-ADFnrv] [-f configfile] domain\n");
	return EXIT_FAILURE;
}
@


1.33
log
@Make returns consistent and remove parentheses per style(9).

Transformed with coccinelle.

Requested by and ok tb@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.32 2017/01/24 12:53:52 deraadt Exp $ */
d88 3
a104 3

	if (getuid() != 0)
		errx(EXIT_FAILURE, "must be run as root");
@


1.32
log
@
Complete jsing's coccinelle cleanup... by hand
ok jsing
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.31 2017/01/24 12:38:41 deraadt Exp $ */
d433 1
a433 2
	return (rc != COMP__MAX ? EXIT_FAILURE :
	    (c == 2 ? EXIT_SUCCESS : 2));
d437 1
a437 1
	return (EXIT_FAILURE);
@


1.31
log
@errx() does not need extra newline
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.30 2017/01/24 12:05:14 jsing Exp $ */
d434 1
a434 1
		(c == 2 ? EXIT_SUCCESS : 2));
@


1.30
log
@Replace comparisons between a constant or enum and an expression, with
a comparison between the expression and the constant or enum. This
significantly improves readability.

Transformed with coccinelle.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.29 2017/01/21 15:53:15 jmc Exp $ */
d98 1
a98 1
		errx(EXIT_FAILURE, "domain %s not found\n", argv[0]);
d154 1
a154 1
			errx(EXIT_FAILURE, "no authorities configured\n");
d158 1
a158 1
			errx(EXIT_FAILURE, "authority %s not found\n", auth);
@


1.29
log
@tweak previous;
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.28 2017/01/21 12:59:06 benno Exp $ */
d59 1
a59 1
	while (-1 != (c = getopt(argc, argv, "FADrvnf:")))
d62 1
a62 1
			if (NULL == (conffile = strdup(optarg)))
d94 1
a94 1
	if (1 != argc)
d164 1
a164 1
	if (NULL == acctkey) {
d173 1
a173 1
	if (NULL == chngdir)
d185 1
a185 1
	if (-1 == access(certdir, R_OK)) {
d190 1
a190 1
	if (!(popts & ACME_OPT_NEWDKEY) && -1 == access(domain->key, R_OK)) {
d193 1
a193 1
	} else if ((popts & ACME_OPT_NEWDKEY) && -1 != access(domain->key, R_OK)) {
d198 1
a198 1
	if (-1 == access(chngdir, R_OK)) {
d203 1
a203 1
	if (!(popts & ACME_OPT_NEWACCT) && -1 == access(acctkey, R_OK)) {
d206 1
a206 1
	} else if ((popts & ACME_OPT_NEWACCT) && -1 != access(acctkey, R_OK)) {
d220 1
a220 1
	if (NULL == alts)
d232 1
a232 1
	if (-1 == socketpair(AF_UNIX, SOCK_STREAM, 0, key_fds))
d234 1
a234 1
	if (-1 == socketpair(AF_UNIX, SOCK_STREAM, 0, acct_fds))
d236 1
a236 1
	if (-1 == socketpair(AF_UNIX, SOCK_STREAM, 0, chng_fds))
d238 1
a238 1
	if (-1 == socketpair(AF_UNIX, SOCK_STREAM, 0, cert_fds))
d240 1
a240 1
	if (-1 == socketpair(AF_UNIX, SOCK_STREAM, 0, file_fds))
d242 1
a242 1
	if (-1 == socketpair(AF_UNIX, SOCK_STREAM, 0, dns_fds))
d244 1
a244 1
	if (-1 == socketpair(AF_UNIX, SOCK_STREAM, 0, rvk_fds))
d249 1
a249 1
	if (-1 == (pids[COMP_NET] = fork()))
d252 1
a252 1
	if (0 == pids[COMP_NET]) {
d281 1
a281 1
	if (-1 == (pids[COMP_KEY] = fork()))
d284 1
a284 1
	if (0 == pids[COMP_KEY]) {
d303 1
a303 1
	if (-1 == (pids[COMP_ACCOUNT] = fork()))
d306 1
a306 1
	if (0 == pids[COMP_ACCOUNT]) {
d323 1
a323 1
	if (-1 == (pids[COMP_CHALLENGE] = fork()))
d326 1
a326 1
	if (0 == pids[COMP_CHALLENGE]) {
d342 1
a342 1
	if (-1 == (pids[COMP_CERT] = fork()))
d345 1
a345 1
	if (0 == pids[COMP_CERT]) {
d360 1
a360 1
	if (-1 == (pids[COMP_FILE] = fork()))
d363 1
a363 1
	if (0 == pids[COMP_FILE]) {
d381 1
a381 1
	if (-1 == (pids[COMP_DNS] = fork()))
d384 1
a384 1
	if (0 == pids[COMP_DNS]) {
d396 1
a396 1
	if (-1 == (pids[COMP_REVOKE] = fork()))
d399 1
a399 1
	if (0 == pids[COMP_REVOKE]) {
d433 2
a434 2
	return (COMP__MAX != rc ? EXIT_FAILURE :
	    (2 == c ? EXIT_SUCCESS : 2));
@


1.28
log
@move config data structures mostly to TAILQs, because that way we
preserve order.

ok florian@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.27 2017/01/21 12:54:10 florian Exp $ */
d437 1
a437 1
	    "usage: acme-client [-FADrvn] [-f file] domain\n");
@


1.27
log
@it is ok to only specify a full chain certificate
OK benno
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.26 2017/01/21 09:00:29 benno Exp $ */
d225 1
a225 1
	LIST_FOREACH(ac, &domain->altname_list, entry)
@


1.26
log
@add option 'domain full chain certificate "path"',
revokation works, the fullchain file will be unlinked.

ok florian
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.25 2017/01/21 08:55:09 florian Exp $ */
d106 13
a118 4
	/*
	 * Now we allocate our directories and file paths IFF we haven't
	 * specified them on the command-line.
	 */
d120 1
a120 5
	if ((certdir = dirname(domain->cert)) != NULL) {
		if ((certdir = strdup(certdir)) == NULL)
			err(EXIT_FAILURE, "strdup");
	} else
		err(EXIT_FAILURE, "dirname");
d122 7
a128 5
	if ((certfile = basename(domain->cert)) != NULL) {
		if ((certfile = strdup(certfile)) == NULL)
			err(EXIT_FAILURE, "strdup");
	} else
		err(EXIT_FAILURE, "basename");
d401 3
a403 1
		c = revokeproc(rvk_fds[0], certdir, certfile, force, revocate,
@


1.25
log
@Implement domain chain certificate.
OK benno
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.24 2017/01/21 08:54:26 florian Exp $ */
d39 2
a40 1
	char		 *certdir = NULL, *certfile = NULL, *chainfile = NULL;
d133 10
d361 2
a362 1
		c = fileproc(file_fds[1], certdir, certfile, chainfile, NULL);
@


1.24
log
@Split certificate file from config file into certdir and certfile.
This way we can still chroot to certdir but the the certificate file
is not fixed to "cert.pem".

Writing of chain.pem and fullchain.pem is currently broken with this.

OK benno
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.23 2017/01/21 08:52:30 florian Exp $ */
d39 2
a40 1
	char		 *certdir = NULL, *certfile = NULL, *acctkey = NULL;
d122 10
d350 1
a350 1
		c = fileproc(file_fds[1], certdir, certfile, NULL, NULL);
@


1.23
log
@Remove backup option. This is not acme-client's business; also it gets
in the way.
OK benno
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.22 2017/01/21 08:51:00 florian Exp $ */
d22 1
d39 2
a40 2
	char		 *certdir = NULL, *acctkey = NULL, *chngdir = NULL;
	char		 *auth = NULL, *agreement = NULL;
d109 11
a119 1
	certdir = domain->cert;
d339 1
a339 1
		c = fileproc(file_fds[1], certdir);
d371 1
a371 1
		c = revokeproc(rvk_fds[0], certdir, force, revocate,
@


1.22
log
@We are only dealing with one domain on the command line
OK benno
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.21 2017/01/21 08:49:59 florian Exp $ */
a42 1
	int		  backup = 0;
d56 1
a56 1
	while (-1 != (c = getopt(argc, argv, "bFADrvnf:")))
a57 3
		case 'b':
			backup = 1;
			break;
d328 1
a328 1
		c = fileproc(file_fds[1], backup, certdir);
d394 1
a394 1
	    "usage: acme-client [-bFADrvn] [-f file] domain\n");
@


1.21
log
@typo; ok benno
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.20 2017/01/21 08:48:11 florian Exp $ */
d95 1
a95 1
	if (0 == argc)
a97 8
	/* Make sure that the domains are sane. */

	for (i = 0; i < (size_t)argc; i++) {
		if (domain_valid(argv[i]))
			continue;
		errx(EXIT_FAILURE, "%s: bad domain syntax", argv[i]);
	}

a102 2
	if (argc != 0)
		goto usage;
@


1.20
log
@typo; ok benno
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.19 2017/01/21 08:47:21 benno Exp $ */
d178 1
a178 1
		warnx("%s: -f file must exist", acctkey);
@


1.19
log
@acme-client use configuration file [5 of 5]
implement new -n option to check and print configuration

ok florian
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.18 2017/01/21 08:45:52 benno Exp $ */
d165 1
a165 1
		warnx("%s: -k file must exist", domain->key);
@


1.18
log
@acme-client use configuration file [4 of 5]

fix getopt()

ok florian
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.17 2017/01/21 08:44:35 benno Exp $ */
d57 1
a57 1
	while (-1 != (c = getopt(argc, argv, "bFADrvf:")))
d82 3
d188 3
d408 1
a408 1
	    "usage: acme-client [-bFADrv] [-f file] domain\n");
@


1.17
log
@acme-client use configuration file [3 of 5]

change command line options:

    n -> A   new Account key
    N -> D   new Domain key

With this acme-client has these main usage patterns:

* create new Account Key and Domain Key and get a certificate:

  acme-client -A -D www.example.com

* renew certificate:

  acme-client www.example.com

* revoke certificate:

  acme-client -r www.example.com

ok florian
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.16 2017/01/21 08:43:09 benno Exp $ */
d57 1
a57 1
	while (-1 != (c = getopt(argc, argv, "bFnNrvf:")))
@


1.16
log
@acme-client use configuration file [2 of 5]

- add challengedir option to config file
- remove -C option from command line

ok florian
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.15 2017/01/21 08:41:42 benno Exp $ */
d69 1
a69 1
		case 'n':
d72 1
a72 1
		case 'N':
d402 1
a402 1
	    "usage: acme-client [-bFnNrv] [-f file] domain\n");
@


1.15
log
@acme-client use configuration file [1 of 5]

start using the configuration file and delete command line arguments:

-a agreement    -> agreement url ...
-c certdir      -> domain certificate "path"
-f accountkey   -> account key "path"
-k domainkey    -> domain key "path"
-s authority    -> sign with "name"

new argument:
-f configfile

the changes needed to use the new configuration are local to main.c for now.
While the configuration could be passed directly to netproc(), keyproc() etc,
the diff is smaller this way.

This also removes the multidir (-m) mode for now - specify different paths in
each domain {} block instead.

ok florian
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.14 2016/09/18 20:18:25 benno Exp $ */
d57 1
a57 1
	while (-1 != (c = getopt(argc, argv, "bFnNrvf:C:")))
a61 5
		case 'C':
			free(chngdir);
			if (NULL == (chngdir = strdup(optarg)))
				err(EXIT_FAILURE, "strdup");
			break;
d139 1
a139 1
	if (NULL == chngdir)
d141 2
d170 1
a170 1
		warnx("%s: -C directory must exist", chngdir);
a396 2
	free(acctkey);
	free(chngdir);
d402 1
a402 4
	    "usage: acme-client [-bFnNrv] [-C challengedir]\n"
	    "                   [-f file] domain\n");
	free(acctkey);
	free(chngdir);
@


1.14
log
@add a config file parser to acme-client (unused at the moment, so that
it can be worked on in the tree).
ok florian@@ deraadt@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.13 2016/09/13 17:13:37 deraadt Exp $ */
a30 3
#define SSL_DIR "/etc/ssl/acme"
#define SSL_PRIV_DIR "/etc/ssl/acme/private"
#define ETC_DIR "/etc/acme"
d32 1
a32 29
#define PRIVKEY_FILE "privkey.pem"

struct authority authorities[] = {
#define	DEFAULT_AUTHORITY 0
	{"letsencrypt",
	    "https://letsencrypt.org/documents/LE-SA-v1.1.1-August-1-2016.pdf",
	    "https://acme-v01.api.letsencrypt.org/directory"},
	{"letsencrypt-staging",
	    "https://letsencrypt.org/documents/LE-SA-v1.1.1-August-1-2016.pdf",
	    "https://acme-staging.api.letsencrypt.org/directory"},
};

/*
 * Wrap around asprintf(3), which sometimes nullifies the input values,
 * sometimes not, but always returns <0 on error.
 * Returns NULL on failure or the pointer on success.
 */
static char *
doasprintf(const char *fmt, ...)
{
	int	 c;
	char	*cp;
	va_list	 ap;

	va_start(ap, fmt);
	c = vasprintf(&cp, fmt, ap);
	va_end(ap);
	return (c < 0 ? NULL : cp);
}
d37 1
a37 1
	const char	 *domain, *agreement = NULL, **alts = NULL;
d39 2
a40 1
	char		 *keyfile = NULL;
d43 2
a44 2
	int		  newacct = 0, remote = 0, backup = 0;
	int		  force = 0, multidir = 0, newkey = 0;
d46 1
a46 1
	int		  authority = DEFAULT_AUTHORITY;
d52 6
a57 1
	while (-1 != (c = getopt(argc, argv, "bFmnNrs:tva:f:c:C:k:")))
a58 3
		case 'a':
			agreement = optarg;
			break;
a61 5
		case 'c':
			free(certdir);
			if (NULL == (certdir = strdup(optarg)))
				err(EXIT_FAILURE, "strdup");
			break;
d68 1
a68 2
			free(acctkey);
			if (NULL == (acctkey = strdup(optarg)))
a73 8
		case 'k':
			free(keyfile);
			if (NULL == (keyfile = strdup(optarg)))
				err(EXIT_FAILURE, "strdup");
			break;
		case 'm':
			multidir = 1;
			break;
d75 1
a75 1
			newacct = 1;
d78 1
a78 1
			newkey = 1;
a82 18
		case 's':
			authority = -1;
			for (i = 0; i < nitems(authorities); i++) {
				if (strcmp(authorities[i].name, optarg) == 0) {
					authority = i;
					break;
				}
			}
			if (-1 == authority)
				errx(EXIT_FAILURE, "unknown acme authority");
			break;
		case 't':
			/*
			 / Undocumented feature.
			 * Don't use it.
			 */
			remote = 1;
			break;
d85 1
d91 3
a93 2
	if (NULL == agreement)
		agreement = authorities[authority].agreement;
d108 3
a110 1
	domain = argv[0];
d113 2
a121 3
	 * If we're in "multidir" (-m) mode, we use our initial domain
	 * name when specifying the prefixes.
	 * Otherwise, we put them all in a known location.
d124 20
a143 14
	if (NULL == certdir)
		certdir = multidir ?
			doasprintf(SSL_DIR "/%s", domain) :
			strdup(SSL_DIR);
	if (NULL == keyfile)
		keyfile = multidir ?
			doasprintf(SSL_PRIV_DIR "/%s/"
				PRIVKEY_FILE, domain) :
			strdup(SSL_PRIV_DIR "/" PRIVKEY_FILE);
	if (NULL == acctkey)
		acctkey = multidir ?
			doasprintf(ETC_DIR "/%s/"
				PRIVKEY_FILE, domain) :
			strdup(ETC_DIR "/" PRIVKEY_FILE);
d147 1
a147 2
	if (NULL == certdir || NULL == keyfile ||
	    NULL == acctkey || NULL == chngdir)
d154 1
d160 1
a160 1
		warnx("%s: -c directory must exist", certdir);
d164 2
a165 2
	if (!newkey && -1 == access(keyfile, R_OK)) {
		warnx("%s: -k file must exist", keyfile);
d167 3
a169 3
	} else if (newkey && -1 != access(keyfile, R_OK)) {
		dodbg("%s: domain key exists (not creating)", keyfile);
		newkey = 0;
d177 1
a177 1
	if (!newacct && -1 == access(acctkey, R_OK)) {
d180 1
a180 1
	} else if (newacct && -1 != access(acctkey, R_OK)) {
d182 1
a182 1
		newacct = 0;
d189 1
a189 2

	altsz = argc + 1;
d193 5
a197 3
	alts[0] = domain;
	for (i = 0; i < (size_t)argc; i++)
		alts[i + 1] = argv[i];
d236 1
a236 1
		    newacct, revocate, authority,
d264 2
a265 2
		c = keyproc(key_fds[0], keyfile,
		    (const char **)alts, altsz, newkey);
d286 1
a286 1
		c = acctproc(acct_fds[0], acctkey, newacct);
d305 1
a305 1
		c = chngproc(chng_fds[0], chngdir, remote);
a399 2
	free(certdir);
	free(keyfile);
d407 2
a408 5
	    "usage: acme-client [-bFmnNrv] [-a agreement] [-C challengedir]\n"
	    "                   [-c certdir] [-f accountkey] [-k domainkey]\n"
	    "                   [-s authority] domain [altnames...]\n");
	free(certdir);
	free(keyfile);
@


1.13
log
@A small amount more KNF to make this easier on our eyes.  Not going further
than this.
ok florian
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.12 2016/09/13 16:49:28 deraadt Exp $ */
d29 1
a45 17

/*
 * This isn't RFC1035 compliant, but does the bare minimum in making
 * sure that we don't get bogus domain names on the command line, which
 * might otherwise screw up our directory structure.
 * Returns zero on failure, non-zero on success.
 */
static int
domain_valid(const char *cp)
{

	for (; '\0' != *cp; cp++)
		if (!('.' == *cp || '-' == *cp ||
		    '_' == *cp || isalnum((int)*cp)))
			return (0);
	return (1);
}
@


1.12
log
@hoist local variable initialization directly into the definitions,
rather than doing it right afterwards.
ok florian
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.11 2016/09/13 16:04:51 deraadt Exp $ */
d56 1
a56 1
	for ( ; '\0' != *cp; cp++)
d186 1
a186 1
	if ( getuid() != 0)
d231 1
a231 1
	if ( ! newkey && -1 == access(keyfile, R_OK)) {
d235 1
a235 2
		dodbg("%s: domain key exists "
			"(not creating)", keyfile);
d244 1
a244 1
	if ( ! newacct && -1 == access(acctkey, R_OK)) {
d248 1
a248 2
		dodbg("%s: account key exists "
			"(not creating)", acctkey);
d331 1
a331 1
			(const char **)alts, altsz, newkey);
d410 1
a410 2
		exit(c > 1 ? 2 :
		    (c ? EXIT_SUCCESS : EXIT_FAILURE));
d437 2
a438 3
		c = revokeproc(rvk_fds[0], certdir,
			force, revocate,
			(const char *const *)alts, altsz);
@


1.11
log
@Inconsistant use of case (value): idiom drives me nuts, I have no idea
what purpose it was intended to serve.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.10 2016/09/01 13:47:54 florian Exp $ */
d84 9
a92 5
	const char	 *domain, *agreement;
	char		 *certdir, *acctkey, *chngdir, *keyfile;
	int		  key_fds[2], acct_fds[2], chng_fds[2],
			  cert_fds[2], file_fds[2], dns_fds[2],
			  rvk_fds[2];
a93 2
	int		  c, rc, newacct, remote, revocate, force,
			  multidir, newkey, backup, authority;
a96 8
	const char	**alts;

	alts = NULL;
	newacct = remote = revocate = verbose = force =
		multidir = newkey = backup = 0;
	authority = DEFAULT_AUTHORITY;
	certdir = keyfile = acctkey = chngdir = NULL;
	agreement = NULL;
@


1.10
log
@update usage(); pointed out by jmc@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.9 2016/09/01 12:17:00 florian Exp $ */
d106 1
a106 1
		case ('a'):
d109 1
a109 1
		case ('b'):
d112 1
a112 1
		case ('c'):
d117 1
a117 1
		case ('C'):
d122 1
a122 1
		case ('f'):
d127 1
a127 1
		case ('F'):
d130 1
a130 1
		case ('k'):
d135 1
a135 1
		case ('m'):
d138 1
a138 1
		case ('n'):
d141 1
a141 1
		case ('N'):
d144 1
a144 1
		case ('r'):
d147 1
a147 1
		case ('s'):
d158 1
a158 1
		case ('t'):
d165 1
a165 1
		case ('v'):
@


1.9
log
@Implement table driven selection to which ACME authorities we can
talk.
Suggest by and OK deraadt, OK benno.

(Later on deraadt and benno discussed if this should be handled with a
config file. This seems to be good enough for now. We can do a config
file later.)
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.8 2016/09/01 00:35:22 florian Exp $ */
d485 1
a485 1
	    "usage: acme-client [-bFmnNrsv] [-a agreement] [-C challengedir]\n"
d487 1
a487 1
	    "                   domain [altnames...]\n");
@


1.8
log
@we don't have config.h
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.7 2016/09/01 00:32:00 deraadt Exp $ */
a29 2
#define AGREEMENT "https://letsencrypt.org" \
		  "/documents/LE-SA-v1.1.1-August-1-2016.pdf"
d36 10
d91 1
a91 1
			  staging, multidir, newkey, backup;
d99 2
a100 1
		multidir = staging = newkey = backup = 0;
d102 1
a102 1
	agreement = AGREEMENT;
d104 1
a104 1
	while (-1 != (c = getopt(argc, argv, "bFmnNrstva:f:c:C:k:")))
d148 9
a156 1
			staging = 1;
d172 3
d310 1
a310 1
		    newacct, revocate, staging,
@


1.7
log
@line wrap usage
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.6 2016/09/01 00:21:36 deraadt Exp $ */
a16 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.6
log
@Collapse krazy abstractions for other sandbox models, using chroot and
pledge directly as needed.
ok florian
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.5 2016/09/01 00:03:39 benno Exp $ */
d467 4
a470 9
	fprintf(stderr, "usage: %s "
		"[-bFmnNrsv] "
		"[-a agreement] "
		"[-C challengedir] "
		"[-c certdir] "
		"[-f accountkey] "
		"[-k domainkey] "
		"domain [altnames...]\n",
		getprogname());
@


1.5
log
@knf
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.4 2016/08/31 23:30:59 benno Exp $ */
d175 1
a175 1
	if ( ! checkprivs())
d440 2
a441 7
	if ( ! sandbox_before())
		exit(EXIT_FAILURE);
	else if ( ! dropfs(PATH_VAR_EMPTY))
		exit(EXIT_FAILURE);
	else if ( ! dropprivs())
		exit(EXIT_FAILURE);
	else if ( ! sandbox_after())
d443 1
@


1.4
log
@whitespace
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.3 2016/08/31 22:57:36 deraadt Exp $ */
d291 5
a295 5
			chng_fds[1], cert_fds[1],
			dns_fds[1], rvk_fds[1],
			newacct, revocate, staging,
			(const char *const *)alts, altsz,
			agreement);
d402 1
a402 1
		     (c ? EXIT_SUCCESS : EXIT_FAILURE));
d455 7
a461 7
	     checkexit(pids[COMP_CERT], COMP_CERT) +
	     checkexit(pids[COMP_NET], COMP_NET) +
	     checkexit_ext(&c, pids[COMP_FILE], COMP_FILE) +
	     checkexit(pids[COMP_ACCOUNT], COMP_ACCOUNT) +
	     checkexit(pids[COMP_CHALLENGE], COMP_CHALLENGE) +
	     checkexit(pids[COMP_DNS], COMP_DNS) +
	     checkexit(pids[COMP_REVOKE], COMP_REVOKE);
d469 1
a469 1
	       (2 == c ? EXIT_SUCCESS : 2));
@


1.3
log
@revoke -> revocate, to avoid alias
ok florian
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.2 2016/08/31 22:20:53 florian Exp $ */
d52 4
a55 4
		if (!('.' == *cp || '-' == *cp || 
 		      '_' == *cp || isalnum((int)*cp)))
			return(0);
	return(1);
d73 1
a73 1
	return(c < 0 ? NULL : cp);
d80 2
a81 2
	char	 	 *certdir, *acctkey, *chngdir, *keyfile;
	int		  key_fds[2], acct_fds[2], chng_fds[2], 
d93 1
a93 1
	newacct = remote = revocate = verbose = force = 
d98 1
a98 1
	while (-1 != (c = getopt(argc, argv, "bFmnNrstva:f:c:C:k:"))) 
d178 1
a178 1
	/* 
d187 1
a187 1
		certdir = multidir ? 
d192 1
a192 1
			doasprintf(SSL_PRIV_DIR "/%s/" 
d196 1
a196 1
		acctkey = multidir ? 
d207 2
a208 2
	/* 
	 * Do some quick checks to see if our paths exist. 
d256 2
a257 2
	/* 
	 * Open channels between our components. 
d290 3
a292 3
		c = netproc(key_fds[1], acct_fds[1], 
			chng_fds[1], cert_fds[1], 
			dns_fds[1], rvk_fds[1], 
d321 1
a321 1
		c = keyproc(key_fds[0], keyfile, 
d429 1
a429 1
		c = revokeproc(rvk_fds[0], certdir, 
d468 1
a468 1
	return(COMP__MAX != rc ? EXIT_FAILURE :
d478 1
a478 1
		"domain [altnames...]\n", 
d484 1
a484 1
	return(EXIT_FAILURE);
@


1.2
log
@store files in directories called acme
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.1 2016/08/31 22:01:42 florian Exp $ */
d85 1
a85 1
	int		  c, rc, newacct, remote, revoke, force,
d93 1
a93 1
	newacct = remote = revoke = verbose = force = 
d139 1
a139 1
			revoke = 1;
d293 1
a293 1
			newacct, revoke, staging,
d430 1
a430 1
			force, revoke,
@


1.1
log
@Import Kristaps' letskencrypt and call it acme-client in tree.
OK to get it in deraadt@@ (and probably beck@@)

At least deraadt@@, beck@@ and otto@@ are fine with the name and the
disagreements stopped.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.59 2016/08/06 17:37:41 kristaps Exp $ */
d35 4
a38 4
#define SSL_DIR "/etc/ssl/letsencrypt"
#define SSL_PRIV_DIR "/etc/ssl/letsencrypt/private"
#define ETC_DIR "/etc/letsencrypt"
#define WWW_DIR "/var/www/letsencrypt"
@

