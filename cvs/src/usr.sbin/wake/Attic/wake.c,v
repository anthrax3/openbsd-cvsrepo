head	1.15;
access;
symbols;
locks; strict;
comment	@ * @;


1.15
date	2009.02.08.22.53.01;	author mbalmer;	state dead;
branches;
next	1.14;

1.14
date	2009.02.02.22.08.58;	author sobrado;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.02.21.29.27;	author mbalmer;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.30.21.00.42;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.29.15.50.03;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.29.14.18.20;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.29.13.47.17;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.29.13.20.27;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.29.13.12.21;	author pyr;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.29.13.10.39;	author pyr;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.29.13.07.09;	author pyr;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.29.10.43.36;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.28.22.28.38;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.28.14.06.31;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.28.13.40.48;	author mbalmer;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove wake(8).  The bin directories are full, no new commands to be added.
@
text
@/*	$OpenBSD: wake.c,v 1.14 2009/02/02 22:08:58 sobrado Exp $ */

/*
 * Copyright (C) 2006,2007,2008,2009 Marc Balmer <mbalmer@@openbsd.org>
 * Copyright (C) 2000 Eugene M. Kim.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Author's name may not be used endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/queue.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <net/bpf.h>
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>
#include <unistd.h>

#ifndef BPF_PATH_FORMAT
#define BPF_PATH_FORMAT "/dev/bpf%u"
#endif

#ifndef SYNC_LEN
#define SYNC_LEN 6
#endif

#ifndef DESTADDR_COUNT
#define DESTADDR_COUNT 16
#endif

__dead void	usage(void);

int	wake(const char *iface, const char *host);
int	get_bpf(void);
int	bind_if_to_bpf(char const *ifname, int bpf);
int	get_ether(char const *text, struct ether_addr *addr);
int	send_wakeup(int bpf, struct ether_addr const *addr);

void
usage(void)
{
	extern char *__progname;

	(void)fprintf(stderr, "usage: %s interface lladdr ...\n", __progname);
	exit(0);
}

int
wake(const char *iface, const char *host)
{
	int res, bpf;
	struct ether_addr macaddr;

	bpf = get_bpf();
	if (bpf == -1)
		return -1;
	if (bind_if_to_bpf(iface, bpf) == -1 ||
	    get_ether(host, &macaddr) == -1) {
		(void)close(bpf);
		return -1;
	}
	res = send_wakeup(bpf, &macaddr);
	(void)close(bpf);
	return res;
}

int
get_bpf(void)
{
	int i, fd;
	char path[MAXPATHLEN];

	for (i = 0;; i++) {
		if (snprintf(path, sizeof(path), BPF_PATH_FORMAT, i) == -1)
			return -1;

		fd = open(path, O_RDWR);
		if (fd != -1)
			return fd;
		if (errno == EBUSY)
			continue;
		break;
	}
	return -1;
}

int
bind_if_to_bpf(char const *ifname, int bpf)
{
	struct ifreq ifr;
	u_int dlt;

	if (strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name)) >=
	    sizeof(ifr.ifr_name))
		return -1;
	if (ioctl(bpf, BIOCSETIF, &ifr) == -1)
		return -1;
	if (ioctl(bpf, BIOCGDLT, &dlt) == -1)
		return -1;
	if (dlt != DLT_EN10MB)
		return -1;
	return 0;
}

int
get_ether(char const *text, struct ether_addr *addr)
{
	struct ether_addr *paddr;
	paddr = ether_aton(text);
	if (paddr != NULL) {
		*addr = *paddr;
		return 0;
	}
	if (ether_hostton(text, addr))
		return -1;
	return 0;
}

int
send_wakeup(int bpf, struct ether_addr const *addr)
{
	struct {
		struct ether_header hdr;
		u_char data[SYNC_LEN + ETHER_ADDR_LEN * DESTADDR_COUNT];
	} pkt;
	u_char *p;
	int i;
	ssize_t bw;
	ssize_t len;

	(void)memset(pkt.hdr.ether_dhost, 0xff, sizeof(pkt.hdr.ether_dhost));
	pkt.hdr.ether_type = htons(0);
	(void)memset(pkt.data, 0xff, SYNC_LEN);
	for (p = pkt.data + SYNC_LEN, i = 0; i < DESTADDR_COUNT;
	    p += ETHER_ADDR_LEN, i++)
		bcopy(addr->ether_addr_octet, p, ETHER_ADDR_LEN);
	p = (u_char *)&pkt;
	len = sizeof(pkt);
	bw = 0;
	while (len) {
		if ((bw = write(bpf, &pkt, sizeof(pkt))) == -1)
			return -1;
		len -= bw;
		p += bw;
	}
	return 0;
}

int
main(int argc, char *argv[])
{
	int n;

	if (argc < 3)
		usage();

	for (n = 2; n < argc; n++)
		if (wake(argv[1], argv[n]))
			warn("error sending Wake on LAN frame over %s to %s",
			    argv[1], argv[n]);
	return 0;
}
@


1.14
log
@tweak the synopsis and usage, lladdr is not an optional argument.

jmc@@ might further improve on it, if needed.

ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.13 2009/02/02 21:29:27 mbalmer Exp $ */
@


1.13
log
@Can wake up several machines in one invocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.12 2009/01/30 21:00:42 pyr Exp $ */
d77 1
a77 1
	(void)fprintf(stderr, "usage: %s interface lladdr\n", __progname);
@


1.12
log
@avoid an alloc/free loop while looking for a bpf.
ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.11 2009/01/29 15:50:03 mbalmer Exp $ */
d185 3
a187 1
	if (argc != 3)
d190 4
a193 3
	if (wake(argv[1], argv[2]))
		err(1, "error sending Wake on LAN frame over %s to %s",
		    argv[1], argv[2]);
@


1.11
log
@Better error handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.10 2009/01/29 14:18:20 pyr Exp $ */
d30 1
d104 1
a104 1
	char *path;
d107 1
a107 1
		if (asprintf(&path, BPF_PATH_FORMAT, i) == -1)
a110 1
		free(path);
@


1.10
log
@Correct capitalization.
From Thomas Pfaff.
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.9 2009/01/29 13:47:17 mbalmer Exp $ */
d69 1
a69 1
void	send_wakeup(int bpf, struct ether_addr const *addr);
d83 1
a83 1
	int bpf;
d94 1
a94 1
	send_wakeup(bpf, &macaddr);
d96 1
a96 1
	return 0;
d152 1
a152 1
void
d175 1
a175 1
			err(1, "cannot send Wake on LAN frame");
d179 1
@


1.9
log
@Correct copyright years.
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.8 2009/01/29 13:20:27 pyr Exp $ */
d175 1
a175 1
			err(1, "cannot send wake on lan frame");
@


1.8
log
@* Add more CFLAGS commonly found in src/usr.sbin/
* Add prototype for wake()
* Add __dead to usage (for lint)
* Do not rely on pointer value for asprintf return as advised
* Make sure lint is happy

some comments and ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.7 2009/01/29 13:12:21 pyr Exp $ */
d4 1
a4 1
 * Copyright (C) 2006-2008 Marc Balmer.
@


1.7
log
@detect truncation with strlcpy, not strlen.
ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.6 2009/01/29 13:10:39 pyr Exp $ */
d63 3
a69 1
void	usage(void);
d76 1
a76 1
	fprintf(stderr, "usage: %s interface lladdr\n", __progname);
d89 3
a91 6
	if (bind_if_to_bpf(iface, bpf) == -1) {
		close(bpf);
		return -1;
	}
	if (get_ether(host, &macaddr) == -1) {
		close(bpf);
d95 1
a95 1
	close(bpf);
d106 1
a106 2
		asprintf(&path, BPF_PATH_FORMAT, i);
		if (path == NULL)
d164 1
a164 1
	memset(pkt.hdr.ether_dhost, 0xff, sizeof(pkt.hdr.ether_dhost));
d166 1
a166 1
	memset(pkt.data, 0xff, SYNC_LEN);
@


1.6
log
@Report error if wake on lan frame is not sent correctly.
Loop in the really unlikely event of a non atomic write.
ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.5 2009/01/29 13:07:09 pyr Exp $ */
d128 2
a129 1
	if (strlen(ifname) >= sizeof(ifr.ifr_name))
a130 1
	strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
@


1.5
log
@simplify the bpf opening loop a bit.
``shorter is always better'' and ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.4 2009/01/29 10:43:36 michele Exp $ */
d163 2
d172 9
a180 1
	(void)write(bpf, &pkt, sizeof(pkt));
@


1.4
log
@Round brackets are not required. Back out previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.3 2009/01/28 22:28:38 michele Exp $ */
d110 1
d112 2
a113 2
		if (fd != -1) {
			free(path);
d115 1
a115 4
		}
		switch (errno) {
		case EBUSY:
			free(path);
d117 1
a117 6
		case ENOENT:
			free(path);
			return -1;
		}
		free(path);
		return -1;
@


1.3
log
@Add brackets around return values.
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.2 2009/01/28 14:06:31 sobrado Exp $ */
d86 1
a86 1
		return (-1);
d89 1
a89 1
		return (-1);
d93 1
a93 1
		return (-1);
d97 1
a97 1
	return (0);
d109 1
a109 1
			return (-1);
d113 1
a113 1
			return (fd);
d121 1
a121 1
			return (-1);
d124 1
a124 1
		return (-1);
d126 1
a126 1
	return (-1);
d136 1
a136 1
		return (-1);
d139 1
a139 1
		return (-1);
d141 1
a141 1
		return (-1);
d143 2
a144 2
		return (-1);
	return (0);
d154 1
a154 1
		return (0);
d157 2
a158 2
		return (-1);
	return (0);
d189 1
a189 1
	return (0);
@


1.2
log
@minor improvement to usage()

ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wake.c,v 1.1 2009/01/28 13:40:48 mbalmer Exp $ */
d86 1
a86 1
		return -1;
d89 1
a89 1
		return -1;
d93 1
a93 1
		return -1;
d97 1
a97 1
	return 0;
d109 1
a109 1
			return -1;
d113 1
a113 1
			return fd;
d121 1
a121 1
			return -1;
d124 1
a124 1
		return -1;
d126 1
a126 1
	return -1;
d136 1
a136 1
		return -1;
d139 1
a139 1
		return -1;
d141 1
a141 1
		return -1;
d143 2
a144 2
		return -1;
	return 0;
d154 1
a154 1
		return 0;
d157 2
a158 2
		return -1;
	return 0;
d189 1
a189 1
	return 0;
@


1.1
log
@wake is a command to send wake on lan frames over an ethernet to wake on lan
capable machines, remote powering them up.

ok claudio, sthen, "I like this a lot" & ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d74 1
a74 1
	fprintf(stderr, "%s <interface> <lladdr>\n", __progname);
@

