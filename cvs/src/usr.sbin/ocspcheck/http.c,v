head	1.9;
access;
symbols;
locks; strict;
comment	@ * @;


1.9
date	2017.03.26.18.41.02;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	cDA5L4uJ4e4JHAVo;

1.8
date	2017.02.03.08.08.15;	author guenther;	state Exp;
branches;
next	1.7;
commitid	P29bgNaYzdoOG6Ga;

1.7
date	2017.02.01.18.54.37;	author beck;	state Exp;
branches;
next	1.6;
commitid	6gLktzhWyb2F8bqN;

1.6
date	2017.01.25.13.31.01;	author benno;	state Exp;
branches;
next	1.5;
commitid	GdbDKgVCrF0MKhZU;

1.5
date	2017.01.24.10.57.48;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	R0RtXR2ycEHON1w3;

1.4
date	2017.01.24.10.33.16;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	4pm3sTlFEjHWpm6p;

1.3
date	2017.01.24.10.02.11;	author beck;	state Exp;
branches;
next	1.2;
commitid	kUI6dyy17TRluvzO;

1.2
date	2017.01.24.09.59.45;	author beck;	state Exp;
branches;
next	1.1;
commitid	bXdSVtw6HvBLlhHz;

1.1
date	2017.01.24.08.50.57;	author beck;	state Exp;
branches;
next	;
commitid	X98y5V8uQ2fL8dt4;


desc
@@


1.9
log
@recallocarray() for data buffer from the net.
ok beck
@
text
@/*	$Id: http.c,v 1.8 2017/02/03 08:08:15 guenther Exp $ */
/*
 * Copyright (c) 2016 Kristaps Dzonsons <kristaps@@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <arpa/inet.h>
#include <netinet/in.h>

#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <tls.h>
#include <unistd.h>

#include "http.h"
#include <tls.h>

#define DEFAULT_CA_FILE "/etc/ssl/cert.pem"

/*
 * A buffer for transferring HTTP/S data.
 */
struct	httpxfer {
	char		*hbuf;    /* header transfer buffer */
	size_t		 hbufsz;  /* header buffer size */
	int		 headok;  /* header has been parsed */
	char		*bbuf;    /* body transfer buffer */
	size_t		 bbufsz;  /* body buffer size */
	int		 bodyok;  /* body has been parsed */
	char		*headbuf; /* lookaside buffer for headers */
	struct httphead	*head;    /* parsed headers */
	size_t		 headsz;  /* number of headers */
};

/*
 * An HTTP/S connection object.
 */
struct	http {
	int		   fd;     /* connected socket */
	short		   port;   /* port number */
	struct source	   src;    /* endpoint (raw) host */
	char		  *path;   /* path to request */
	char		  *host;   /* name of endpoint host */
	struct tls	  *ctx;    /* if TLS */
	writefp		   writer; /* write function */
	readfp		   reader; /* read function */
};

struct tls_config *tlscfg;

static ssize_t
dosysread(char *buf, size_t sz, const struct http *http)
{
	ssize_t	 rc;

	rc = read(http->fd, buf, sz);
	if (rc < 0)
		warn("%s: read", http->src.ip);
	return rc;
}

static ssize_t
dosyswrite(const void *buf, size_t sz, const struct http *http)
{
	ssize_t	 rc;

	rc = write(http->fd, buf, sz);
	if (rc < 0)
		warn("%s: write", http->src.ip);
	return rc;
}

static ssize_t
dotlsread(char *buf, size_t sz, const struct http *http)
{
	ssize_t	 rc;

	do {
		rc = tls_read(http->ctx, buf, sz);
	} while (rc == TLS_WANT_POLLIN || rc == TLS_WANT_POLLOUT);

	if (rc < 0)
		warnx("%s: tls_read: %s", http->src.ip,
		    tls_error(http->ctx));
	return rc;
}

static ssize_t
dotlswrite(const void *buf, size_t sz, const struct http *http)
{
	ssize_t	 rc;

	do {
		rc = tls_write(http->ctx, buf, sz);
	} while (rc == TLS_WANT_POLLIN || rc == TLS_WANT_POLLOUT);

	if (rc < 0)
		warnx("%s: tls_write: %s", http->src.ip,
		    tls_error(http->ctx));
	return rc;
}

int
http_init()
{
	if (tlscfg != NULL)
		return 0;

	if (tls_init() == -1) {
		warn("tls_init");
		goto err;
	}

	tlscfg = tls_config_new();
	if (tlscfg == NULL) {
		warn("tls_config_new");
		goto err;
	}

	if (tls_config_set_ca_file(tlscfg, DEFAULT_CA_FILE) == -1) {
		warn("tls_config_set_ca_file: %s", tls_config_error(tlscfg));
		goto err;
	}

	return 0;

 err:
	tls_config_free(tlscfg);
	tlscfg = NULL;

	return -1;
}

static ssize_t
http_read(char *buf, size_t sz, const struct http *http)
{
	ssize_t	 ssz, xfer;

	xfer = 0;
	do {
		if ((ssz = http->reader(buf, sz, http)) < 0)
			return -1;
		if (ssz == 0)
			break;
		xfer += ssz;
		sz -= ssz;
		buf += ssz;
	} while (ssz > 0 && sz > 0);

	return xfer;
}

static int
http_write(const char *buf, size_t sz, const struct http *http)
{
	ssize_t	 ssz, xfer;

	xfer = sz;
	while (sz > 0) {
		if ((ssz = http->writer(buf, sz, http)) < 0)
			return -1;
		sz -= ssz;
		buf += (size_t)ssz;
	}
	return xfer;
}

void
http_disconnect(struct http *http)
{
	int rc;

	if (http->ctx != NULL) {
		/* TLS connection. */
		do {
			rc = tls_close(http->ctx);
		} while (rc == TLS_WANT_POLLIN || rc == TLS_WANT_POLLOUT);

		if (rc < 0)
			warnx("%s: tls_close: %s", http->src.ip,
			    tls_error(http->ctx));

		tls_free(http->ctx);
	}
	if (http->fd != -1) {
		if (close(http->fd) == -1)
			warn("%s: close", http->src.ip);
	}

	http->fd = -1;
	http->ctx = NULL;
}

void
http_free(struct http *http)
{

	if (http == NULL)
		return;
	http_disconnect(http);
	free(http->host);
	free(http->path);
	free(http->src.ip);
	free(http);
}

struct http *
http_alloc(const struct source *addrs, size_t addrsz,
    const char *host, short port, const char *path)
{
	struct sockaddr_storage ss;
	int		 family, fd, c;
	socklen_t	 len;
	size_t		 cur, i = 0;
	struct http	*http;

	/* Do this while we still have addresses to connect. */
again:
	if (i == addrsz)
		return NULL;
	cur = i++;

	/* Convert to PF_INET or PF_INET6 address from string. */

	memset(&ss, 0, sizeof(struct sockaddr_storage));

	if (addrs[cur].family == 4) {
		family = PF_INET;
		((struct sockaddr_in *)&ss)->sin_family = AF_INET;
		((struct sockaddr_in *)&ss)->sin_port = htons(port);
		c = inet_pton(AF_INET, addrs[cur].ip,
		    &((struct sockaddr_in *)&ss)->sin_addr);
		len = sizeof(struct sockaddr_in);
	} else if (addrs[cur].family == 6) {
		family = PF_INET6;
		((struct sockaddr_in6 *)&ss)->sin6_family = AF_INET6;
		((struct sockaddr_in6 *)&ss)->sin6_port = htons(port);
		c = inet_pton(AF_INET6, addrs[cur].ip,
		    &((struct sockaddr_in6 *)&ss)->sin6_addr);
		len = sizeof(struct sockaddr_in6);
	} else {
		warnx("%s: unknown family", addrs[cur].ip);
		goto again;
	}

	if (c < 0) {
		warn("%s: inet_ntop", addrs[cur].ip);
		goto again;
	} else if (c == 0) {
		warnx("%s: inet_ntop", addrs[cur].ip);
		goto again;
	}

	/* Create socket and connect. */

	fd = socket(family, SOCK_STREAM, 0);
	if (fd == -1) {
		warn("%s: socket", addrs[cur].ip);
		goto again;
	} else if (connect(fd, (struct sockaddr *)&ss, len) == -1) {
		warn("%s: connect", addrs[cur].ip);
		close(fd);
		goto again;
	}

	/* Allocate the communicator. */

	http = calloc(1, sizeof(struct http));
	if (http == NULL) {
		warn("calloc");
		close(fd);
		return NULL;
	}
	http->fd = fd;
	http->port = port;
	http->src.family = addrs[cur].family;
	http->src.ip = strdup(addrs[cur].ip);
	http->host = strdup(host);
	http->path = strdup(path);
	if (http->src.ip == NULL || http->host == NULL || http->path == NULL) {
		warn("strdup");
		goto err;
	}

	/* If necessary, do our TLS setup. */

	if (port != 443) {
		http->writer = dosyswrite;
		http->reader = dosysread;
		return http;
	}

	http->writer = dotlswrite;
	http->reader = dotlsread;

	if ((http->ctx = tls_client()) == NULL) {
		warn("tls_client");
		goto err;
	} else if (tls_configure(http->ctx, tlscfg) == -1) {
		warnx("%s: tls_configure: %s",
			http->src.ip, tls_error(http->ctx));
		goto err;
	}

	if (tls_connect_socket(http->ctx, http->fd, http->host) != 0) {
		warnx("%s: tls_connect_socket: %s, %s", http->src.ip,
		    http->host, tls_error(http->ctx));
		goto err;
	}

	return http;
err:
	http_free(http);
	return NULL;
}

struct httpxfer *
http_open(const struct http *http, const void *p, size_t psz)
{
	char		*req;
	int		 c;
	struct httpxfer	*trans;

	if (p == NULL) {
		c = asprintf(&req,
		    "GET %s HTTP/1.0\r\n"
		    "Host: %s\r\n"
		    "\r\n",
		    http->path, http->host);
	} else {
		c = asprintf(&req,
		    "POST %s HTTP/1.0\r\n"
		    "Host: %s\r\n"
		    "Content-Length: %zu\r\n"
		    "\r\n",
		    http->path, http->host, psz);
	}
	if (c == -1) {
		warn("asprintf");
		return NULL;
	} else if (!http_write(req, c, http)) {
		free(req);
		return NULL;
	} else if (p != NULL && !http_write(p, psz, http)) {
		free(req);
		return NULL;
	}

	free(req);

	trans = calloc(1, sizeof(struct httpxfer));
	if (trans == NULL)
		warn("calloc");
	return trans;
}

void
http_close(struct httpxfer *x)
{

	if (x == NULL)
		return;
	free(x->hbuf);
	free(x->bbuf);
	free(x->headbuf);
	free(x->head);
	free(x);
}

/*
 * Read the HTTP body from the wire.
 * If invoked multiple times, this will return the same pointer with the
 * same data (or NULL, if the original invocation returned NULL).
 * Returns NULL if read or allocation errors occur.
 * You must not free the returned pointer.
 */
char *
http_body_read(const struct http *http, struct httpxfer *trans, size_t *sz)
{
	char		 buf[BUFSIZ];
	ssize_t		 ssz;
	void		*pp;
	size_t		 szp;

	if (sz == NULL)
		sz = &szp;

	/* Have we already parsed this? */

	if (trans->bodyok > 0) {
		*sz = trans->bbufsz;
		return trans->bbuf;
	} else if (trans->bodyok < 0)
		return NULL;

	*sz = 0;
	trans->bodyok = -1;

	do {
		/* If less than sizeof(buf), at EOF. */
		if ((ssz = http_read(buf, sizeof(buf), http)) < 0)
			return NULL;
		else if (ssz == 0)
			break;

		pp = recallocarray(trans->bbuf,
		    trans->bbufsz, trans->bbufsz + ssz, 1);
		if (pp == NULL) {
			warn("recallocarray");
			return NULL;
		}
		trans->bbuf = pp;
		memcpy(trans->bbuf + trans->bbufsz, buf, ssz);
		trans->bbufsz += ssz;
	} while (ssz == sizeof(buf));

	trans->bodyok = 1;
	*sz = trans->bbufsz;
	return trans->bbuf;
}

struct httphead *
http_head_get(const char *v, struct httphead *h, size_t hsz)
{
	size_t	 i;

	for (i = 0; i < hsz; i++) {
		if (strcmp(h[i].key, v))
			continue;
		return &h[i];
	}
	return NULL;
}

/*
 * Look through the headers and determine our HTTP code.
 * This will return -1 on failure, otherwise the code.
 */
int
http_head_status(const struct http *http, struct httphead *h, size_t sz)
{
	int		 rc;
	unsigned int	 code;
	struct httphead *st;

	if ((st = http_head_get("Status", h, sz)) == NULL) {
		warnx("%s: no status header", http->src.ip);
		return -1;
	}

	rc = sscanf(st->val, "%*s %u %*s", &code);
	if (rc < 0) {
		warn("sscanf");
		return -1;
	} else if (rc != 1) {
		warnx("%s: cannot convert status header", http->src.ip);
		return -1;
	}
	return code;
}

/*
 * Parse headers from the transfer.
 * Malformed headers are skipped.
 * A special "Status" header is added for the HTTP status line.
 * This can only happen once http_head_read has been called with
 * success.
 * This can be invoked multiple times: it will only parse the headers
 * once and after that it will just return the cache.
 * You must not free the returned pointer.
 * If the original header parse failed, or if memory allocation fails
 * internally, this returns NULL.
 */
struct httphead *
http_head_parse(const struct http *http, struct httpxfer *trans, size_t *sz)
{
	size_t		 hsz, szp;
	struct httphead	*h;
	char		*cp, *ep, *ccp, *buf;

	if (sz == NULL)
		sz = &szp;

	/*
	 * If we've already parsed the headers, return the
	 * previously-parsed buffer now.
	 * If we have errors on the stream, return NULL now.
	 */

	if (trans->head != NULL) {
		*sz = trans->headsz;
		return trans->head;
	} else if (trans->headok <= 0)
		return NULL;

	if ((buf = strdup(trans->hbuf)) == NULL) {
		warn("strdup");
		return NULL;
	}
	hsz = 0;
	cp = buf;

	do {
		if ((cp = strstr(cp, "\r\n")) != NULL)
			cp += 2;
		hsz++;
	} while (cp != NULL);

	/*
	 * Allocate headers, then step through the data buffer, parsing
	 * out headers as we have them.
	 * We know at this point that the buffer is NUL-terminated in
	 * the usual way.
	 */

	h = calloc(hsz, sizeof(struct httphead));
	if (h == NULL) {
		warn("calloc");
		free(buf);
		return NULL;
	}

	*sz = hsz;
	hsz = 0;
	cp = buf;

	do {
		if ((ep = strstr(cp, "\r\n")) != NULL) {
			*ep = '\0';
			ep += 2;
		}
		if (hsz == 0) {
			h[hsz].key = "Status";
			h[hsz++].val = cp;
			continue;
		}

		/* Skip bad headers. */
		if ((ccp = strchr(cp, ':')) == NULL) {
			warnx("%s: header without separator", http->src.ip);
			continue;
		}

		*ccp++ = '\0';
		while (isspace((int)*ccp))
			ccp++;
		h[hsz].key = cp;
		h[hsz++].val = ccp;
	} while ((cp = ep) != NULL);

	trans->headbuf = buf;
	trans->head = h;
	trans->headsz = hsz;
	return h;
}

/*
 * Read the HTTP headers from the wire.
 * If invoked multiple times, this will return the same pointer with the
 * same data (or NULL, if the original invocation returned NULL).
 * Returns NULL if read or allocation errors occur.
 * You must not free the returned pointer.
 */
char *
http_head_read(const struct http *http, struct httpxfer *trans, size_t *sz)
{
	char		 buf[BUFSIZ];
	ssize_t		 ssz;
	char		*ep;
	void		*pp;
	size_t		 szp;

	if (sz == NULL)
		sz = &szp;

	/* Have we already parsed this? */

	if (trans->headok > 0) {
		*sz = trans->hbufsz;
		return trans->hbuf;
	} else if (trans->headok < 0)
		return NULL;

	*sz = 0;
	ep = NULL;
	trans->headok = -1;

	/*
	 * Begin by reading by BUFSIZ blocks until we reach the header
	 * termination marker (two CRLFs).
	 * We might read into our body, but that's ok: we'll copy out
	 * the body parts into our body buffer afterward.
	 */

	do {
		/* If less than sizeof(buf), at EOF. */
		if ((ssz = http_read(buf, sizeof(buf), http)) < 0)
			return NULL;
		else if (ssz == 0)
			break;
		pp = realloc(trans->hbuf, trans->hbufsz + ssz);
		if (pp == NULL) {
			warn("realloc");
			return NULL;
		}
		trans->hbuf = pp;
		memcpy(trans->hbuf + trans->hbufsz, buf, ssz);
		trans->hbufsz += ssz;
		/* Search for end of headers marker. */
		ep = memmem(trans->hbuf, trans->hbufsz, "\r\n\r\n", 4);
	} while (ep == NULL && ssz == sizeof(buf));

	if (ep == NULL) {
		warnx("%s: partial transfer", http->src.ip);
		return NULL;
	}
	*ep = '\0';

	/*
	 * The header data is invalid if it has any binary characters in
	 * it: check that now.
	 * This is important because we want to guarantee that all
	 * header keys and pairs are properly NUL-terminated.
	 */

	if (strlen(trans->hbuf) != (uintptr_t)(ep - trans->hbuf)) {
		warnx("%s: binary data in header", http->src.ip);
		return NULL;
	}

	/*
	 * Copy remaining buffer into body buffer.
	 */

	ep += 4;
	trans->bbufsz = (trans->hbuf + trans->hbufsz) - ep;
	trans->bbuf = malloc(trans->bbufsz);
	if (trans->bbuf == NULL) {
		warn("malloc");
		return NULL;
	}
	memcpy(trans->bbuf, ep, trans->bbufsz);

	trans->headok = 1;
	*sz = trans->hbufsz;
	return trans->hbuf;
}

void
http_get_free(struct httpget *g)
{

	if (g == NULL)
		return;
	http_close(g->xfer);
	http_free(g->http);
	free(g);
}

struct httpget *
http_get(const struct source *addrs, size_t addrsz, const char *domain,
    short port, const char *path, const void *post, size_t postsz)
{
	struct http	*h;
	struct httpxfer	*x;
	struct httpget	*g;
	struct httphead	*head;
	size_t		 headsz, bodsz, headrsz;
	int		 code;
	char		*bod, *headr;

	h = http_alloc(addrs, addrsz, domain, port, path);
	if (h == NULL)
		return NULL;

	if ((x = http_open(h, post, postsz)) == NULL) {
		http_free(h);
		return NULL;
	} else if ((headr = http_head_read(h, x, &headrsz)) == NULL) {
		http_close(x);
		http_free(h);
		return NULL;
	} else if ((bod = http_body_read(h, x, &bodsz)) == NULL) {
		http_close(x);
		http_free(h);
		return NULL;
	}

	http_disconnect(h);

	if ((head = http_head_parse(h, x, &headsz)) == NULL) {
		http_close(x);
		http_free(h);
		return NULL;
	} else if ((code = http_head_status(h, head, headsz)) < 0) {
		http_close(x);
		http_free(h);
		return NULL;
	}

	if ((g = calloc(1, sizeof(struct httpget))) == NULL) {
		warn("calloc");
		http_close(x);
		http_free(h);
		return NULL;
	}

	g->headpart = headr;
	g->headpartsz = headrsz;
	g->bodypart = bod;
	g->bodypartsz = bodsz;
	g->head = head;
	g->headsz = headsz;
	g->code = code;
	g->xfer = x;
	g->http = h;
	return g;
}

#if 0
int
main(void)
{
	struct httpget	*g;
	struct httphead	*httph;
	size_t		 i, httphsz;
	struct source	 addrs[2];
	size_t		 addrsz;

#if 0
	addrs[0].ip = "127.0.0.1";
	addrs[0].family = 4;
	addrsz = 1;
#else
	addrs[0].ip = "2a00:1450:400a:806::2004";
	addrs[0].family = 6;
	addrs[1].ip = "193.135.3.123";
	addrs[1].family = 4;
	addrsz = 2;
#endif

	if (http_init() == -1)
		errx(EXIT_FAILURE, "http_init");

#if 0
	g = http_get(addrs, addrsz, "localhost", 80, "/index.html");
#else
	g = http_get(addrs, addrsz, "www.google.ch", 80, "/index.html",
	    NULL, 0);
#endif

	if (g == NULL)
		errx(EXIT_FAILURE, "http_get");

	httph = http_head_parse(g->http, g->xfer, &httphsz);
	warnx("code: %d", g->code);

	for (i = 0; i < httphsz; i++)
		warnx("head: [%s]=[%s]", httph[i].key, httph[i].val);

	http_get_free(g);
	return (EXIT_SUCCESS);
}
#endif
@


1.8
log
@Don't use <sys/param.h> from userland without cause.  Sort <sys/*>
before other includes per style(9) while we're here.

ok florian@@ bcook@@ jsing@@ beck@@
@
text
@d1 1
a1 1
/*	$Id: http.c,v 1.7 2017/02/01 18:54:37 beck Exp $ */
d425 3
a427 1
		pp = realloc(trans->bbuf, trans->bbufsz + ssz);
d429 1
a429 1
			warn("realloc");
@


1.7
log
@netinet/in.h should be included, and freebsd and some others
don't have EAI_NODATA, so make this easier for people
from bernard spill
@
text
@d1 1
a1 1
/*	$Id: http.c,v 1.6 2017/01/25 13:31:01 benno Exp $ */
d18 3
a22 2
#include <sys/socket.h>
#include <sys/param.h>
@


1.6
log
@bring changes from acme-client over here.
ok beck@@
@
text
@d1 1
a1 1
/*	$Id: http.c,v 1.18 2017/01/24 13:32:55 jsing Exp $ */
d18 2
a21 1
#include <arpa/inet.h>
@


1.5
log
@string terminator is called a NUL
@
text
@d1 1
a1 1
/*	$Id: http.c,v 1.4 2017/01/24 10:33:16 deraadt Exp $ */
d77 1
a77 1
	return (rc);
d88 1
a88 1
	return (rc);
d103 1
a103 1
	return (rc);
d118 1
a118 1
	return (rc);
d125 1
a125 1
		return (0);
d143 1
a143 1
	return (0);
d149 1
a149 1
	return (-1);
d160 1
a160 1
			return (-1);
d168 1
a168 1
	return (xfer);
d179 1
a179 1
			return (-1);
d183 1
a183 1
	return (xfer);
d238 1
a238 1
		return (NULL);
d290 1
a290 1
		return (NULL);
d308 1
a308 1
		return (http);
d329 1
a329 1
	return (http);
d332 1
a332 1
	return (NULL);
a351 2
		    "Content-Type: application/ocsp-request\r\n"
		    "Accept: application/ocsp-response\r\n"
d358 1
a358 1
		return (NULL);
d361 1
a361 1
		return (NULL);
d364 1
a364 1
		return (NULL);
d372 1
a372 1
	return (trans);
d410 1
a410 1
		return (trans->bbuf);
d412 1
a412 1
		return (NULL);
d420 1
a420 1
			return (NULL);
d426 1
a426 1
			return (NULL);
d431 1
a431 1
	} while (sizeof(buf) == ssz);
d435 1
a435 1
	return (trans->bbuf);
d446 1
a446 1
		return (&h[i]);
d448 1
a448 1
	return (NULL);
d464 1
a464 1
		return (-1);
d470 1
a470 1
		return (-1);
d473 1
a473 1
		return (-1);
d475 1
a475 1
	return (code);
d508 1
a508 1
		return (trans->head);
d510 1
a510 1
		return (NULL);
d514 1
a514 1
		return (NULL);
d536 1
a536 1
		return (NULL);
d570 1
a570 1
	return (h);
d596 1
a596 1
		return (trans->hbuf);
d598 1
a598 1
		return (NULL);
d614 1
a614 1
			return (NULL);
d620 1
a620 1
			return (NULL);
d631 1
a631 1
		return (NULL);
d644 1
a644 1
		return (NULL);
d656 1
a656 1
		return (NULL);
d662 1
a662 1
	return (trans->hbuf);
d690 1
a690 1
		return (NULL);
d694 1
a694 1
		return (NULL);
d698 1
a698 1
		return (NULL);
d702 1
a702 1
		return (NULL);
d710 1
a710 1
		return (NULL);
d714 1
a714 1
		return (NULL);
d721 1
a721 1
		return (NULL);
d733 1
a733 1
	return (g);
@


1.4
log
@Yes the "if (const == val" idiom provides some safety, but it grates on
us too much.
ok beck jsing
@
text
@d1 1
a1 1
/*	$Id: http.c,v 1.1 2017/01/24 08:50:57 beck Exp $ */
d530 1
a530 1
	 * We know at this point that the buffer is nil-terminated in
d641 1
a641 1
	 * header keys and pairs are properly nil-terminated.
@


1.3
log
@revert accidental commit of theo diff
@
text
@d98 1
a98 1
	} while (TLS_WANT_POLLIN == rc || TLS_WANT_POLLOUT == rc);
d113 1
a113 1
	} while (TLS_WANT_POLLIN == rc || TLS_WANT_POLLOUT == rc);
d124 1
a124 1
	if (NULL != tlscfg)
d127 1
a127 1
	if (-1 == tls_init()) {
d133 1
a133 1
	if (NULL == tlscfg) {
d138 1
a138 1
	if (-1 == tls_config_set_ca_file(tlscfg, DEFAULT_CA_FILE)) {
d161 1
a161 1
		if (0 == ssz)
d191 1
a191 1
	if (NULL != http->ctx) {
d195 1
a195 1
		} while (TLS_WANT_POLLIN == rc || TLS_WANT_POLLOUT == rc);
d203 2
a204 2
	if (-1 != http->fd) {
		if (-1 == close(http->fd))
d216 1
a216 1
	if (NULL == http)
d245 1
a245 1
	if (4 == addrs[cur].family) {
d252 1
a252 1
	} else if (6 == addrs[cur].family) {
d267 1
a267 1
	} else if (0 == c) {
d275 1
a275 1
	if (-1 == fd) {
d278 1
a278 1
	} else if (-1 == connect(fd, (struct sockaddr *)&ss, len)) {
d287 1
a287 1
	if (NULL == http) {
d298 1
a298 1
	if (NULL == http->src.ip || NULL == http->host || NULL == http->path) {
d305 1
a305 1
	if (443 != port) {
d314 1
a314 1
	if (NULL == (http->ctx = tls_client())) {
d317 1
a317 1
	} else if (-1 == tls_configure(http->ctx, tlscfg)) {
d323 1
a323 1
	if (0 != tls_connect_socket(http->ctx, http->fd, http->host)) {
d342 1
a342 1
	if (NULL == p) {
d358 1
a358 1
	if (-1 == c) {
d364 1
a364 1
	} else if (NULL != p && ! http_write(p, psz, http)) {
d372 1
a372 1
	if (NULL == trans)
d381 1
a381 1
	if (NULL == x)
d405 1
a405 1
	if (NULL == sz)
d423 1
a423 1
		else if (0 == ssz)
d426 1
a426 1
		if (NULL == pp) {
d464 1
a464 1
	if (NULL == (st = http_head_get("Status", h, sz))) {
d473 1
a473 1
	} else if (1 != rc) {
d499 1
a499 1
	if (NULL == sz)
d508 1
a508 1
	if (NULL != trans->head) {
d514 1
a514 1
	if (NULL == (buf = strdup(trans->hbuf))) {
d522 1
a522 1
		if (NULL != (cp = strstr(cp, "\r\n")))
d525 1
a525 1
	} while (NULL != cp);
d535 1
a535 1
	if (NULL == h) {
d546 1
a546 1
		if (NULL != (ep = strstr(cp, "\r\n"))) {
d550 1
a550 1
		if (0 == hsz) {
d557 1
a557 1
		if (NULL == (ccp = strchr(cp, ':'))) {
d567 1
a567 1
	} while (NULL != (cp = ep));
d591 1
a591 1
	if (NULL == sz)
d617 1
a617 1
		else if (0 == ssz)
d620 1
a620 1
		if (NULL == pp) {
d629 1
a629 1
	} while (NULL == ep && sizeof(buf) == ssz);
d631 1
a631 1
	if (NULL == ep) {
d656 1
a656 1
	if (NULL == trans->bbuf) {
d671 1
a671 1
	if (NULL == g)
d691 1
a691 1
	if (NULL == h)
d694 1
a694 1
	if (NULL == (x = http_open(h, post, postsz))) {
d697 1
a697 1
	} else if (NULL == (headr = http_head_read(h, x, &headrsz))) {
d701 1
a701 1
	} else if (NULL == (bod = http_body_read(h, x, &bodsz))) {
d709 1
a709 1
	if (NULL == (head = http_head_parse(h, x, &headsz))) {
d719 1
a719 1
	if (NULL == (g = calloc(1, sizeof(struct httpget)))) {
d770 1
a770 1
	if (NULL == g)
@


1.2
log
@Just don't bother with OpenSSL error strings, they are mostly
irrelevant and look gross here anyway.. we don't need them
@
text
@d98 1
a98 1
	} while (rc == TLS_WANT_POLLIN || rc == TLS_WANT_POLLOUT);
d113 1
a113 1
	} while (rc == TLS_WANT_POLLIN || rc == TLS_WANT_POLLOUT);
d124 1
a124 1
	if (tlscfg != NULL)
d127 1
a127 1
	if (tls_init() == -1) {
d133 1
a133 1
	if (tlscfg == NULL) {
d138 1
a138 1
	if (tls_config_set_ca_file(tlscfg, DEFAULT_CA_FILE) == -1) {
d161 1
a161 1
		if (ssz == 0)
d191 1
a191 1
	if (http->ctx != NULL) {
d195 1
a195 1
		} while (rc == TLS_WANT_POLLIN || rc == TLS_WANT_POLLOUT);
d203 2
a204 2
	if (http->fd != -1) {
		if (close(http->fd) == -1)
d216 1
a216 1
	if (http == NULL)
d245 1
a245 1
	if (addrs[cur].family == 4) {
d252 1
a252 1
	} else if (addrs[cur].family == 6) {
d267 1
a267 1
	} else if (c == 0) {
d275 1
a275 1
	if (fd == -1) {
d278 1
a278 1
	} else if (connect(fd, (struct sockaddr *)&ss, len) == -1) {
d287 1
a287 1
	if (http == NULL) {
d298 1
a298 1
	if (http->src.ip == NULL || http->host == NULL || http->path == NULL) {
d305 1
a305 1
	if (port != 443) {
d314 1
a314 1
	if ((http->ctx = tls_client()) == NULL) {
d317 1
a317 1
	} else if (tls_configure(http->ctx, tlscfg) == -1) {
d323 1
a323 1
	if (tls_connect_socket(http->ctx, http->fd, http->host) != 0) {
d342 1
a342 1
	if (p == NULL) {
d358 1
a358 1
	if (c == -1) {
d364 1
a364 1
	} else if (p != NULL && !http_write(p, psz, http)) {
d372 1
a372 1
	if (trans == NULL)
d381 1
a381 1
	if (x == NULL)
d405 1
a405 1
	if (sz == NULL)
d423 1
a423 1
		else if (ssz == 0)
d426 1
a426 1
		if (pp == NULL) {
d464 1
a464 1
	if ((st = http_head_get("Status", h, sz)) == NULL) {
d473 1
a473 1
	} else if (rc != 1) {
d499 1
a499 1
	if (sz == NULL)
d508 1
a508 1
	if (trans->head != NULL) {
d514 1
a514 1
	if ((buf = strdup(trans->hbuf)) == NULL) {
d522 1
a522 1
		if ((cp = strstr(cp, "\r\n")) != NULL)
d525 1
a525 1
	} while (cp != NULL);
d535 1
a535 1
	if (h == NULL) {
d546 1
a546 1
		if ((ep = strstr(cp, "\r\n")) != NULL) {
d550 1
a550 1
		if (hsz == 0) {
d557 1
a557 1
		if ((ccp = strchr(cp, ':')) == NULL) {
d567 1
a567 1
	} while ((cp = ep) != NULL);
d591 1
a591 1
	if (sz == NULL)
d617 1
a617 1
		else if (ssz == 0)
d620 1
a620 1
		if (pp == NULL) {
d629 1
a629 1
	} while (ep == NULL && ssz == sizeof(buf));
d631 1
a631 1
	if (ep == NULL) {
d656 1
a656 1
	if (trans->bbuf == NULL) {
d671 1
a671 1
	if (g == NULL)
d691 1
a691 1
	if (h == NULL)
d694 1
a694 1
	if ((x = http_open(h, post, postsz)) == NULL) {
d697 1
a697 1
	} else if ((headr = http_head_read(h, x, &headrsz)) == NULL) {
d701 1
a701 1
	} else if ((bod = http_body_read(h, x, &bodsz)) == NULL) {
d709 1
a709 1
	if ((head = http_head_parse(h, x, &headsz)) == NULL) {
d719 1
a719 1
	if ((g = calloc(1, sizeof(struct httpget))) == NULL) {
d770 1
a770 1
	if (g == NULL)
@


1.1
log
@New ocspcheck utility to validate a certificate against its ocsp responder
and save the reply for stapling

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$Id: http.c,v 1.14 2016/11/02 09:33:46 jsing Exp $ */
d98 1
a98 1
	} while (TLS_WANT_POLLIN == rc || TLS_WANT_POLLOUT == rc);
d113 1
a113 1
	} while (TLS_WANT_POLLIN == rc || TLS_WANT_POLLOUT == rc);
d124 1
a124 1
	if (NULL != tlscfg)
d127 1
a127 1
	if (-1 == tls_init()) {
d133 1
a133 1
	if (NULL == tlscfg) {
d138 1
a138 1
	if (-1 == tls_config_set_ca_file(tlscfg, DEFAULT_CA_FILE)) {
d161 1
a161 1
		if (0 == ssz)
d191 1
a191 1
	if (NULL != http->ctx) {
d195 1
a195 1
		} while (TLS_WANT_POLLIN == rc || TLS_WANT_POLLOUT == rc);
d203 2
a204 2
	if (-1 != http->fd) {
		if (-1 == close(http->fd))
d216 1
a216 1
	if (NULL == http)
d245 1
a245 1
	if (4 == addrs[cur].family) {
d252 1
a252 1
	} else if (6 == addrs[cur].family) {
d267 1
a267 1
	} else if (0 == c) {
d275 1
a275 1
	if (-1 == fd) {
d278 1
a278 1
	} else if (-1 == connect(fd, (struct sockaddr *)&ss, len)) {
d287 1
a287 1
	if (NULL == http) {
d298 1
a298 1
	if (NULL == http->src.ip || NULL == http->host || NULL == http->path) {
d305 1
a305 1
	if (443 != port) {
d314 1
a314 1
	if (NULL == (http->ctx = tls_client())) {
d317 1
a317 1
	} else if (-1 == tls_configure(http->ctx, tlscfg)) {
d323 1
a323 1
	if (0 != tls_connect_socket(http->ctx, http->fd, http->host)) {
d342 1
a342 1
	if (NULL == p) {
d358 1
a358 1
	if (-1 == c) {
d364 1
a364 1
	} else if (NULL != p && ! http_write(p, psz, http)) {
d372 1
a372 1
	if (NULL == trans)
d381 1
a381 1
	if (NULL == x)
d405 1
a405 1
	if (NULL == sz)
d423 1
a423 1
		else if (0 == ssz)
d426 1
a426 1
		if (NULL == pp) {
d464 1
a464 1
	if (NULL == (st = http_head_get("Status", h, sz))) {
d473 1
a473 1
	} else if (1 != rc) {
d499 1
a499 1
	if (NULL == sz)
d508 1
a508 1
	if (NULL != trans->head) {
d514 1
a514 1
	if (NULL == (buf = strdup(trans->hbuf))) {
d522 1
a522 1
		if (NULL != (cp = strstr(cp, "\r\n")))
d525 1
a525 1
	} while (NULL != cp);
d535 1
a535 1
	if (NULL == h) {
d546 1
a546 1
		if (NULL != (ep = strstr(cp, "\r\n"))) {
d550 1
a550 1
		if (0 == hsz) {
d557 1
a557 1
		if (NULL == (ccp = strchr(cp, ':'))) {
d567 1
a567 1
	} while (NULL != (cp = ep));
d591 1
a591 1
	if (NULL == sz)
d617 1
a617 1
		else if (0 == ssz)
d620 1
a620 1
		if (NULL == pp) {
d629 1
a629 1
	} while (NULL == ep && sizeof(buf) == ssz);
d631 1
a631 1
	if (NULL == ep) {
d656 1
a656 1
	if (NULL == trans->bbuf) {
d671 1
a671 1
	if (NULL == g)
d691 1
a691 1
	if (NULL == h)
d694 1
a694 1
	if (NULL == (x = http_open(h, post, postsz))) {
d697 1
a697 1
	} else if (NULL == (headr = http_head_read(h, x, &headrsz))) {
d701 1
a701 1
	} else if (NULL == (bod = http_body_read(h, x, &bodsz))) {
d709 1
a709 1
	if (NULL == (head = http_head_parse(h, x, &headsz))) {
d719 1
a719 1
	if (NULL == (g = calloc(1, sizeof(struct httpget)))) {
d770 1
a770 1
	if (NULL == g)
@

