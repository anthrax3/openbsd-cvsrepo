head	1.28;
access;
symbols
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.18.0.14
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.12
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.10
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.15.0.16
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.14
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.12
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.10
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.8
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.28
date	2016.08.27.01.42.37;	author guenther;	state Exp;
branches;
next	1.27;
commitid	XibKWFfMr3L2Zwhv;

1.27
date	2016.07.25.16.28.06;	author visa;	state Exp;
branches;
next	1.26;
commitid	NyYBlOhh4dBHluyo;

1.26
date	2016.01.26.18.26.19;	author mmcc;	state Exp;
branches;
next	1.25;
commitid	W1L20xeSwlpa0n3G;

1.25
date	2015.11.19.19.31.20;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	IhIkk3ETqezxqUUj;

1.24
date	2015.08.03.13.39.22;	author mpi;	state Exp;
branches;
next	1.23;
commitid	uiW7oRovJrs3HD81;

1.23
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	Uu5nFG3wCl0LACBb;

1.22
date	2013.11.12.19.49.42;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2013.08.15.13.43.33;	author bluhm;	state Exp;
branches;
next	1.20;

1.20
date	2013.07.20.18.25.34;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2013.07.20.18.21.11;	author bluhm;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.25.15.47.19;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.05.22.40.24;	author chris;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.04.09.03.08;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.08.20.17.49;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.20.17.58.16;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.26.09.25.21;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.01.03.24.07;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.05.26.06.31.26;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.07.10.08.06.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.03.23.04.18.40;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.02.09.10.06.21;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	98.02.09.10.04.54;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	96.08.13.03.12.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.11.15.07.04.08;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Pull in <sys/time.h> for gettimeofday()

ok deraadt@@
@
text
@/*	$OpenBSD: arptab.c,v 1.27 2016/07/25 16:28:06 visa Exp $ */

/*
 * Copyright (c) 1984, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Sun Microsystems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * set arp table entries
 */


#include <sys/file.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/time.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <arpa/inet.h>

#include <netdb.h>
#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <paths.h>
#include <syslog.h>
#include <string.h>
#include <err.h>

/* ROUNDUP() is nasty, but it is identical to what's in the kernel. */
#define ROUNDUP(a)					\
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

static pid_t pid;
static int s = -1;

int rtget(struct sockaddr_inarp **, struct sockaddr_dl **);

void
arptab_init(void)
{
	s = socket(PF_ROUTE, SOCK_RAW, 0);
	if (s < 0)
		err(1, "arp: socket");
}

struct	sockaddr_in so_mask = {8, 0, 0, { 0xffffffff}};
struct	sockaddr_inarp blank_sin = {sizeof(blank_sin), AF_INET }, sin_m;
struct	sockaddr_dl blank_sdl = {sizeof(blank_sdl), AF_LINK }, sdl_m;
struct	sockaddr_dl ifp_m = {sizeof(&ifp_m), AF_LINK};
time_t	expire_time;
int	flags, export_only, doing_proxy;

struct	{
	struct	rt_msghdr m_rtm;
	char	m_space[512];
} m_rtmsg;

int	arptab_set(u_char *, u_int32_t);
int	rtmsg(int);

/*
 * Set an individual arp entry
 */
int
arptab_set(u_char *eaddr, u_int32_t host)
{
	struct sockaddr_inarp *sin = &sin_m;
	struct rt_msghdr *rtm = &(m_rtmsg.m_rtm);
	struct sockaddr_dl *sdl;
	struct timeval now;
	int rt;

	pid = getpid();

	sdl_m = blank_sdl;
	sin_m = blank_sin;
	sin->sin_addr.s_addr = host;
	memcpy((u_char *)LLADDR(&sdl_m), (char *)eaddr, 6);
	sdl_m.sdl_alen = 6;
	expire_time = 0;
	doing_proxy = flags = export_only = 0;
	gettimeofday(&now, 0);
	expire_time = now.tv_sec + 20 * 60;

tryagain:
	if (rtget(&sin, &sdl)) {
		syslog(LOG_ERR,"%s: %m", inet_ntoa(sin->sin_addr));
		return (1);
	}

	if (sin->sin_addr.s_addr == sin_m.sin_addr.s_addr) {
		if (sdl->sdl_family == AF_LINK &&
		    (rtm->rtm_flags & RTF_LLINFO) &&
		    !(rtm->rtm_flags & RTF_GATEWAY))
			switch (sdl->sdl_type) {
			case IFT_ETHER:
			case IFT_FDDI:
			case IFT_ISO88023:
			case IFT_ISO88024:
			case IFT_ISO88025:
				goto overwrite;
			default:
				break;
		}
		if (doing_proxy == 0) {
			syslog(LOG_ERR, "arptab_set: can only proxy for %s",
			    inet_ntoa(sin->sin_addr));
			return (1);
		}
		if (sin_m.sin_other & SIN_PROXY) {
			syslog(LOG_ERR,
			    "arptab_set: proxy entry exists for non 802 device");
			return(1);
		}
		sin_m.sin_other = SIN_PROXY;
		export_only = 1;
		goto tryagain;
	}
overwrite:
	if (sdl->sdl_family != AF_LINK) {
		syslog(LOG_ERR,
		    "arptab_set: cannot intuit interface index and type for %s",
		    inet_ntoa(sin->sin_addr));
		return (1);
	}
	sdl_m.sdl_type = sdl->sdl_type;
	sdl_m.sdl_index = sdl->sdl_index;
	rt = rtmsg(RTM_ADD);
	return (rt);
}

int
rtmsg(int cmd)
{
	static int seq;
	struct rt_msghdr *rtm = &m_rtmsg.m_rtm;
	char *cp = m_rtmsg.m_space;
	int l;

retry:
	errno = 0;
	if (cmd == RTM_DELETE)
		goto doit;
	memset((char *)&m_rtmsg, 0, sizeof(m_rtmsg));
	rtm->rtm_flags = flags;
	rtm->rtm_version = RTM_VERSION;

	switch (cmd) {
	default:
		syslog(LOG_ERR, "arptab_set: internal wrong cmd");
		exit(1);
	case RTM_ADD:
		rtm->rtm_addrs |= RTA_GATEWAY;
		rtm->rtm_rmx.rmx_expire = expire_time;
		rtm->rtm_inits = RTV_EXPIRE;
		rtm->rtm_flags |= (RTF_HOST | RTF_STATIC);
		sin_m.sin_other = 0;
		if (doing_proxy) {
			if (export_only)
				sin_m.sin_other = SIN_PROXY;
			else {
				rtm->rtm_addrs |= RTA_NETMASK;
				rtm->rtm_flags &= ~RTF_HOST;
			}
		}
		/* FALLTHROUGH */
	case RTM_GET:
		rtm->rtm_addrs |= (RTA_DST | RTA_IFP);
	}
#define NEXTADDR(w, s) \
	if (rtm->rtm_addrs & (w)) { \
		memcpy(cp, (char *)&s, sizeof(s)); \
		cp += sizeof(s); \
	}

	NEXTADDR(RTA_DST, sin_m);
	NEXTADDR(RTA_GATEWAY, sdl_m);
	NEXTADDR(RTA_NETMASK, so_mask);
	NEXTADDR(RTA_IFP, ifp_m);

	rtm->rtm_msglen = cp - (char *)&m_rtmsg;
doit:
	l = rtm->rtm_msglen;
	rtm->rtm_seq = ++seq;
	rtm->rtm_type = cmd;
	if (write(s, (char *)&m_rtmsg, l) < 0) {
		if (errno != ESRCH && errno != EEXIST) {
			syslog(LOG_ERR, "writing to routing socket: %m");
			return (-1);
		}
	}
	do {
		l = recv(s, (char *)&m_rtmsg, sizeof(m_rtmsg), MSG_DONTWAIT);
	} while (l > 0 && (rtm->rtm_version != RTM_VERSION ||
	    rtm->rtm_seq != seq || rtm->rtm_pid != pid));
	if (l < 0) {
		if (errno == EAGAIN || errno == EINTR)
			goto retry;
		syslog(LOG_ERR, "arptab_set: read from routing socket: %m");
	}
	return (0);
}

int
rtget(struct sockaddr_inarp **sinp, struct sockaddr_dl **sdlp)
{
	struct rt_msghdr *rtm = &(m_rtmsg.m_rtm);
	struct sockaddr_inarp *sin = NULL;
	struct sockaddr_dl *sdl = NULL;
	struct sockaddr *sa;
	char *cp;
	unsigned int i;

	if (rtmsg(RTM_GET) < 0)
		return (1);

	if (rtm->rtm_addrs) {
		cp = ((char *)rtm + rtm->rtm_hdrlen);
		for (i = 1; i; i <<= 1) {
			if (i & rtm->rtm_addrs) {
				sa = (struct sockaddr *)cp;
				switch (i) {
				case RTA_DST:
					sin = (struct sockaddr_inarp *)sa;
					break;
				case RTA_IFP:
					sdl = (struct sockaddr_dl *)sa;
					break;
				default:
					break;
				}
				cp += ROUNDUP(sa->sa_len);
			}
		}
	}

	if (sin == NULL || sdl == NULL)
		return (1);

	*sinp = sin;
	*sdlp = sdl;

	return (0);
}
@


1.27
log
@Fix rarpd hang. The receive buffer of a route socket can become full
while rarpd process is idle. To avoid getting stuck in rtmsg(),
the process has to clear the buffer and retry.

ok benno@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arptab.c,v 1.26 2016/01/26 18:26:19 mmcc Exp $ */
d43 1
@


1.26
log
@Use an unsigned int rather than an int when iterating through all 32
bits in the form:

for (i = 1; i; i <<= 1)

This avoids undefined operations when shifting into and out of the
highest-order bit.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arptab.c,v 1.25 2015/11/19 19:31:20 deraadt Exp $ */
d175 1
d228 1
a228 1
		l = read(s, (char *)&m_rtmsg, sizeof(m_rtmsg));
d231 3
a233 1
	if (l < 0)
d235 1
@


1.25
log
@hoist the SOCK_RAW setup to the top before pledge
issues discovered by sebastia
comments from semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: arptab.c,v 1.24 2015/08/03 13:39:22 mpi Exp $ */
d243 1
a243 1
	int i;
@


1.24
log
@Explicitly request the sockaddr_dl when doing a RTM_GET rather than
assuming that it will be in the gateway sa.

Fixes a regression introduced with the support of multiple connected
routes, found the hardway by sebastia@@.

ok florian@@, benno@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arptab.c,v 1.23 2015/01/16 06:40:19 deraadt Exp $ */
d73 2
a74 2
static void
getsocket(void)
a107 1
	getsocket();
a122 2
		close(s);
		s = -1;
a142 2
			close(s);
			s = -1;
a147 2
			close(s);
			s = -1;
a158 2
		close(s);
		s = -1;
a163 2
	close(s);
	s = -1;
@


1.23
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: arptab.c,v 1.22 2013/11/12 19:49:42 deraadt Exp $ */
d64 4
d71 2
d84 1
d122 1
a122 1
	if (rtmsg(RTM_GET) < 0) {
d128 1
a128 2
	sin = (struct sockaddr_inarp *)((char *)rtm + rtm->rtm_hdrlen);
	sdl = (struct sockaddr_dl *)(sin->sin_len + (char *)sin);
d213 1
a213 1
		rtm->rtm_addrs |= RTA_DST;
d224 1
d243 42
@


1.22
log
@handle lack of prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: arptab.c,v 1.21 2013/08/15 13:43:33 bluhm Exp $ */
a39 1
#include <sys/param.h>
@


1.21
log
@Reduce the warnings when arp, rarp, ndp are compiled with WARNINGS=yes.
warning: declaration of 'time' shadows a global declaration
No binary change; OK lteo@@ florian@@ henning@@ mikeb@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arptab.c,v 1.20 2013/07/20 18:25:34 bluhm Exp $ */
d68 1
a68 1
void
@


1.20
log
@Add missing RCS id.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d99 1
a99 1
	struct timeval time;
d112 2
a113 2
	gettimeofday(&time, 0);
	expire_time = time.tv_sec + 20 * 60;
@


1.19
log
@arp and rarpd used an int expire_time for time calculation.  Convert
this into time_t.
OK benno@@
@
text
@d1 2
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d77 2
a78 1
int	expire_time, flags, export_only, doing_proxy;
d108 2
a109 1
	doing_proxy = flags = export_only = expire_time = 0;
@


1.17
log
@Another copy another missing RTM_VERSION check.
Tested and OK sthen@@, OK henning@@
@
text
@a32 10
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1984, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char sccsid[] = "@@(#)arp.c	8.2 (Berkeley) 1/2/94";
#endif /* not lint */

@


1.16
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d239 2
a240 1
	} while (l > 0 && (rtm->rtm_seq != seq || rtm->rtm_pid != pid));
@


1.15
log
@nlist.h not needed
@
text
@d128 1
a128 1
	sin = (struct sockaddr_inarp *)(rtm + 1);
@


1.14
log
@lots of munging about; canacar ok, tested by pb, looked at by various others
@
text
@a64 1
#include <nlist.h>
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d72 1
d81 2
a82 4
	if (s < 0) {
		perror("arp: socket");
		exit(1);
	}
d89 1
d93 1
a93 1
}	m_rtmsg;
d105 1
a106 1
	struct rt_msghdr *rtm = &(m_rtmsg.m_rtm);
d134 10
a143 4
		    !(rtm->rtm_flags & RTF_GATEWAY)) switch (sdl->sdl_type) {
		case IFT_ETHER: case IFT_FDDI: case IFT_ISO88023:
		case IFT_ISO88024: case IFT_ISO88025:
			goto overwrite;
a183 1
	int rlen;
d232 1
a232 1
	if ((rlen = write(s, (char *)&m_rtmsg, l)) < 0) {
@


1.12
log
@ansi
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@pid_t cleanup
@
text
@d81 1
a81 1
getsocket()
d106 1
a106 3
arptab_set(eaddr, host)
	u_char *eaddr;
	u_int32_t host;
d179 1
a179 2
rtmsg(cmd)
	int cmd;
@


1.10
log
@kill more registers.

millert@@ ok
@
text
@d77 1
a77 1
static int pid;
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d110 3
a112 3
	register struct sockaddr_inarp *sin = &sin_m;
	register struct sockaddr_dl *sdl;
	register struct rt_msghdr *rtm = &(m_rtmsg.m_rtm);
d186 3
a188 3
	register struct rt_msghdr *rtm = &m_rtmsg.m_rtm;
	register char *cp = m_rtmsg.m_space;
	register int l;
@


1.8
log
@no need to extern int errno if errno.h is included
@
text
@d99 2
a100 2
int	arptab_set __P((u_char *, u_int32_t));
int	rtmsg __P((int));
@


1.7
log
@need string.h
@
text
@a76 1
extern int errno;
@


1.6
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d75 1
@


1.5
log
@cleanup for -Wall; fix routed+rarpd interaction pointed out by
Pierre.Beyssac@@hsc.fr; and fix a buglet of greek origin.
@
text
@d146 1
a146 1
			syslog(LOG_ERR, "arptab_set: can only proxy for %s\n",
d154 1
a154 1
			    "arptab_set: proxy entry exists for non 802 device\n");
d166 1
a166 1
		    "arptab_set: cannot intuit interface index and type for %s\n",
d199 1
a199 1
		syslog(LOG_ERR, "arptab_set: internal wrong cmd\n");
@


1.4
log
@Fix typo in syslog message.
@
text
@d71 2
d99 3
d105 1
d108 1
a108 1
	u_long host;
d114 1
d118 1
d122 1
a122 1
	bcopy((char *)eaddr, (u_char *)LLADDR(&sdl_m), 6);
d174 1
d177 1
a177 1
	return (rtmsg(RTM_ADD));
d180 1
d182 1
d193 1
a193 1
	bzero((char *)&m_rtmsg, sizeof(m_rtmsg));
d221 3
a223 1
		bcopy((char *)&s, cp, sizeof(s)); cp += sizeof(s);}
@


1.3
log
@Close/reopen routing socket, to avoid running out of the socket's buffer space.
@
text
@d188 1
a188 1
		syslog(LOG_ERR, "arptap_set: internal wrong cmd\n");
@


1.2
log
@indent
@
text
@d81 1
d83 2
a84 5
		s = socket(PF_ROUTE, SOCK_RAW, 0);
		if (s < 0) {
			perror("arp: socket");
			exit(1);
		}
d123 2
d140 2
d147 2
d160 2
d166 2
@


1.1
log
@rarpd can once again set arp entries on the local host; from freebsd
@
text
@d78 3
a80 1
getsocket() {
d138 2
a139 1
			syslog(LOG_ERR, "arptab_set: can only proxy for %s\n", inet_ntoa(sin->sin_addr));
d143 2
a144 1
			syslog(LOG_ERR,"arptab_set: proxy entry exists for non 802 device\n");
d153 3
a155 1
		syslog(LOG_ERR,"arptab_set: cannot intuit interface index and type for %s\n", inet_ntoa(sin->sin_addr));
@
