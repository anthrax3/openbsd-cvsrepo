head	1.71;
access;
symbols
	OPENBSD_6_1:1.71.0.4
	OPENBSD_6_1_BASE:1.71
	OPENBSD_6_0:1.68.0.4
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.67.0.2
	OPENBSD_5_9_BASE:1.67
	OPENBSD_5_8:1.60.0.4
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.53.0.12
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.10
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.53.0.6
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.53.0.4
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.2
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.6
	OPENBSD_5_0:1.52.0.4
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.8
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.48.0.4
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.48.0.2
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.47.0.8
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.47.0.6
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.47.0.4
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.46.0.2
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.44.0.4
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.44.0.2
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.43.0.2
	OPENBSD_3_6_BASE:1.43
	OPENBSD_3_5:1.41.0.4
	OPENBSD_3_5_BASE:1.41
	OPENBSD_3_4:1.41.0.2
	OPENBSD_3_4_BASE:1.41
	OPENBSD_3_3:1.37.0.4
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.6
	OPENBSD_2_8:1.29.0.4
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.29.0.2
	OPENBSD_2_7_BASE:1.29
	OPENBSD_2_6:1.26.0.2
	OPENBSD_2_6_BASE:1.26
	OPENBSD_2_5:1.25.0.2
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.23.0.2
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.71
date	2017.01.20.06.22.38;	author krw;	state Exp;
branches;
next	1.70;
commitid	foJg1zb3SREGYH5v;

1.70
date	2017.01.20.03.31.40;	author krw;	state Exp;
branches;
next	1.69;
commitid	iLb5S4rQdgzBjLJm;

1.69
date	2016.12.18.06.11.23;	author krw;	state Exp;
branches;
next	1.68;
commitid	fCnIjtvaaZwmYSr8;

1.68
date	2016.05.28.07.00.18;	author natano;	state Exp;
branches;
next	1.67;
commitid	V3qpA476A18HvhDy;

1.67
date	2015.11.19.19.31.20;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	IhIkk3ETqezxqUUj;

1.66
date	2015.11.13.16.10.23;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	AdyQptZ6D96lxhFg;

1.65
date	2015.10.27.11.47.17;	author jca;	state Exp;
branches;
next	1.64;
commitid	svi9OSEMTnayVcox;

1.64
date	2015.10.26.10.08.14;	author jung;	state Exp;
branches;
next	1.63;
commitid	HllzbCvumEtKpBqi;

1.63
date	2015.10.26.09.57.55;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	lT6pbS5V0UKyyVn8;

1.62
date	2015.10.16.23.09.53;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	BJLJJ5ZoOOVufGgk;

1.61
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	z3HrihslRYb4HqW9;

1.60
date	2015.07.16.17.51.22;	author miod;	state Exp;
branches;
next	1.59;
commitid	VrGLVlF7dUAIJWn6;

1.59
date	2015.01.19.23.51.54;	author guenther;	state Exp;
branches;
next	1.58;
commitid	liH7zu0aIcozfHQK;

1.58
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	Uu5nFG3wCl0LACBb;

1.57
date	2014.12.16.03.35.49;	author millert;	state Exp;
branches;
next	1.56;
commitid	nQ60kcXwyMctmczv;

1.56
date	2014.10.31.20.11.52;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	B3wtD4W7ja8MKAsd;

1.55
date	2014.10.29.06.16.34;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	Ox4zJIj2ZNsh2HvQ;

1.54
date	2014.10.08.04.58.18;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	KAbD9YlUhNvCEmsz;

1.53
date	2012.04.06.18.03.52;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2010.08.29.12.33.25;	author chl;	state Exp;
branches;
next	1.51;

1.51
date	2010.08.26.18.25.38;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2010.08.26.17.07.46;	author jsg;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.02.00.50.42;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.01.23.17.29.22;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.21.01.40.24;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2004.09.15.22.33.15;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.08.20.17.49;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.05.01.16.39;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.21.19.44.33;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2003.07.21.19.44.05;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.01.15.53.43;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.15.14.52.12;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.20.17.58.16;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.26.09.25.21;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.17.19.42.39;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.01.23.27.23;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.13.20.13.29;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.14.02.52.35;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	99.11.22.08.39.33;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	99.10.29.07.27.40;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	99.08.09.16.55.57;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	99.02.04.00.23.48;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	99.02.03.23.14.15;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	98.08.15.17.25.32;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.07.27.04.34.36;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.07.13.06.58.48;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.07.07.17.29.49;	author art;	state Exp;
branches;
next	1.19;

1.19
date	98.05.03.22.49.09;	author d;	state Exp;
branches;
next	1.18;

1.18
date	98.04.25.06.29.53;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.03.23.04.18.41;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.12.17.08.55.22;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.09.18.08.05.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.09.17.21.10.10;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.09.12.04.07.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.08.18.03.11.32;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.25.20.12.18;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.06.22.22.56.34;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.03.29.04.01.58;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.05.13.41.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.22.09.22.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.44.15;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.08.12.23.42.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.25.15.13.50;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.41.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.15.07.04.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Oops. one "error(NONFATAL,..." got flipped to "error(...)" instead
of "warning(...)".

Spotted by & ok procter@@
@
text
@/*	$OpenBSD: rarpd.c,v 1.70 2017/01/20 03:31:40 krw Exp $ */
/*	$NetBSD: rarpd.c,v 1.25 1998/04/23 02:48:33 mrg Exp $	*/

/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * rarpd - Reverse ARP Daemon
 */

#include <sys/time.h>
#include <sys/file.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/bpf.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <dirent.h>
#include <poll.h>
#include <ifaddrs.h>
#include <paths.h>

/*
 * The structures for each interface.
 */
struct if_addr {
	in_addr_t ia_ipaddr;		/* IP address of this interface */
	in_addr_t ia_netmask;		/* subnet or net mask */
	struct if_addr *ia_next;
};

struct if_info {
	int	ii_fd;			/* BPF file descriptor */
	char	ii_name[IFNAMSIZ];	/* if name, e.g. "en0" */
	u_char	ii_eaddr[ETHER_ADDR_LEN];	/* Ethernet address of this iface */
	struct if_addr *ii_addrs;	/* Networks this interface is on */
	struct if_info *ii_next;
};
/*
 * The list of all interfaces that are being listened to.  rarp_loop()
 * "selects" on the descriptors in this list.
 */
struct if_info *iflist;

int    rarp_open(char *);
void   init_one(char *);
void   init_all(void);
void   rarp_loop(void);
void   lookup_addrs(char *, struct if_info *);
__dead void   usage(void);
void   rarp_process(struct if_info *, u_char *);
void   rarp_reply(struct if_info *, struct if_addr *,
	    struct ether_header *, u_int32_t, struct hostent *);
void	arptab_init(void);
int    arptab_set(u_char *, u_int32_t);
__dead void   error(const char *,...);
void   warning(const char *,...);
void   debug(const char *,...);
u_int32_t ipaddrtonetmask(u_int32_t);
int    rarp_bootable(u_int32_t);

int	aflag = 0;		/* listen on "all" interfaces  */
int	dflag = 0;		/* print debugging messages */
int	fflag = 0;		/* don't fork */
int	lflag = 0;		/* log all replies */
int	tflag = 0;		/* tftpboot check */

int
main(int argc, char *argv[])
{
	extern char *__progname;
	extern int optind, opterr;
	int op;

	/* All error reporting is done through syslogs. */
	openlog(__progname, LOG_PID | LOG_CONS, LOG_DAEMON);

	opterr = 0;
	while ((op = getopt(argc, argv, "adflt")) != -1) {
		switch (op) {
		case 'a':
			++aflag;
			break;
		case 'd':
			++dflag;
			break;
		case 'f':
			++fflag;
			break;
		case 'l':
			++lflag;
			break;
		case 't':
			++tflag;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if ((aflag && argc > 0) || (!aflag && argc == 0))
		usage();

	if (aflag)
		init_all();
	else
		while (argc > 0) {
			init_one(argv[0]);
			argc--;
			argv++;
		}

	if ((!fflag) && (!dflag)) {
		if (daemon(0, 0) == -1)
			error("failed to daemonize: %s", strerror(errno));
	}
	rarp_loop();
	exit(0);
}

/*
 * Add 'ifname' to the interface list.  Lookup its IP address and network
 * mask and Ethernet address, and open a BPF file for it.
 */
void
init_one(char *ifname)
{
	struct if_info *p;
	int fd;

	/* first check to see if this "if" was already opened? */
	for (p = iflist; p; p = p->ii_next)
		if (!strncmp(p->ii_name, ifname, IFNAMSIZ))
			return;

	fd = rarp_open(ifname);
	if (fd < 0)
		return;

	p = malloc(sizeof(*p));
	if (p == 0)
		error("malloc: %s", strerror(errno));

	p->ii_next = iflist;
	iflist = p;

	p->ii_fd = fd;
	strncpy(p->ii_name, ifname, IFNAMSIZ);
	p->ii_addrs = NULL;
	lookup_addrs(ifname, p);
}
/*
 * Initialize all "candidate" interfaces that are in the system
 * configuration list.  A "candidate" is up, not loopback and not
 * point to point.
 */
void
init_all(void)
{
	struct ifaddrs *ifap, *ifa;
	struct sockaddr_dl *sdl;

	if (getifaddrs(&ifap) != 0)
		error("getifaddrs: %s", strerror(errno));

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		if (sdl->sdl_family != AF_LINK || sdl->sdl_type != IFT_ETHER ||
		    sdl->sdl_alen != 6)
			continue;

		if ((ifa->ifa_flags &
		    (IFF_UP | IFF_LOOPBACK | IFF_POINTOPOINT)) != IFF_UP)
			continue;
		init_one(ifa->ifa_name);
	}
	freeifaddrs(ifap);
}

__dead void
usage(void)
{
	(void) fprintf(stderr, "usage: rarpd [-adflt] if0 [... ifN]\n");
	exit(1);
}

static struct bpf_insn insns[] = {
	BPF_STMT(BPF_LD | BPF_H | BPF_ABS, 12),
	BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, ETHERTYPE_REVARP, 0, 3),
	BPF_STMT(BPF_LD | BPF_H | BPF_ABS, 20),
	BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, ARPOP_REVREQUEST, 0, 1),
	BPF_STMT(BPF_RET | BPF_K, sizeof(struct ether_arp) +
	    sizeof(struct ether_header)),
	BPF_STMT(BPF_RET | BPF_K, 0),
};

static struct bpf_program filter = {
	sizeof insns / sizeof(insns[0]),
	insns
};

/*
 * Open a BPF file and attach it to the interface named 'device'.
 * Set immediate mode, and set a filter that accepts only RARP requests.
 */
int
rarp_open(char *device)
{
	int	fd, immediate;
	struct ifreq ifr;
	u_int   dlt;

	if ((fd = open("/dev/bpf0", O_RDWR)) == -1)
		error("/dev/bpf0: %s", strerror(errno));

	/* Set immediate mode so packets are processed as they arrive. */
	immediate = 1;
	if (ioctl(fd, BIOCIMMEDIATE, &immediate) < 0) {
		error("BIOCIMMEDIATE: %s", strerror(errno));
	}

	(void) strncpy(ifr.ifr_name, device, sizeof ifr.ifr_name);
	if (ioctl(fd, BIOCSETIF, (caddr_t)&ifr) < 0) {
		if (aflag) {	/* for -a skip not ethernet interfaces */
			close(fd);
			return -1;
		}
		error("BIOCSETIF: %s", strerror(errno));
	}

	/*
	 * Check that the data link layer is an Ethernet; this code
	 * won't work with anything else.
	 */
	if (ioctl(fd, BIOCGDLT, (caddr_t) &dlt) < 0)
		error("BIOCGDLT: %s", strerror(errno));
	if (dlt != DLT_EN10MB) {
		if (aflag) {	/* for -a skip not ethernet interfaces */
			close(fd);
			return -1;
		}
		error("%s is not an ethernet", device);
	}
	/* Set filter program. */
	if (ioctl(fd, BIOCSETF, (caddr_t)&filter) < 0)
		error("BIOCSETF: %s", strerror(errno));
	return fd;
}
/*
 * Perform various sanity checks on the RARP request packet.  Return
 * false on failure and log the reason.
 */
static int
rarp_check(u_char *p, int len)
{
	struct ether_header *ep = (struct ether_header *) p;
	struct ether_arp *ap = (struct ether_arp *) (p + sizeof(*ep));

	(void) debug("got a packet");

	if (len < sizeof(*ep) + sizeof(*ap)) {
		warning("truncated request");
		return 0;
	}
	/* XXX This test might be better off broken out... */
	if (ntohs (ep->ether_type) != ETHERTYPE_REVARP ||
	    ntohs (ap->arp_hrd) != ARPHRD_ETHER ||
	    ntohs (ap->arp_op) != ARPOP_REVREQUEST ||
	    ntohs (ap->arp_pro) != ETHERTYPE_IP ||
	    ap->arp_hln != 6 || ap->arp_pln != 4) {
		warning("request fails sanity check");
		return 0;
	}
	if (memcmp((char *) &ep->ether_shost, (char *) &ap->arp_sha, 6) != 0) {
		warning("ether/arp sender address mismatch");
		return 0;
	}
	if (memcmp((char *) &ap->arp_sha, (char *) &ap->arp_tha, 6) != 0) {
		warning("ether/arp target address mismatch");
		return 0;
	}
	return 1;
}

/*
 * Loop indefinitely listening for RARP requests on the
 * interfaces in 'iflist'.
 */
void
rarp_loop(void)
{
	int	cc, fd, numfd = 0, i;
	u_int	bufsize;
	struct pollfd *pfd;
	u_char	*buf, *bp, *ep;
	struct if_info *ii;

	if (iflist == 0)
		error("no interfaces");
	if (ioctl(iflist->ii_fd, BIOCGBLEN, (caddr_t)&bufsize) < 0)
		error("BIOCGBLEN: %s", strerror(errno));

	arptab_init();

	if (pledge("stdio rpath dns", NULL) == -1)
		error("pledge");

	buf = malloc((size_t) bufsize);
	if (buf == 0)
		error("malloc: %s", strerror(errno));
	/*
	 * Initialize the set of descriptors to listen to.
	 */
	for (ii = iflist; ii; ii = ii->ii_next)
		numfd++;
	pfd = reallocarray(NULL, numfd, sizeof(*pfd));
	if (pfd == NULL)
		error("reallocarray: %s", strerror(errno));
	for (i = 0, ii = iflist; ii; ii = ii->ii_next, i++) {
		pfd[i].fd = ii->ii_fd;
		pfd[i].events = POLLIN;
	}

	while (1) {
		if (poll(pfd, numfd, -1) == -1) {
			if (errno == EINTR)
				continue;
			error("poll: %s", strerror(errno));
		}
		for (i = 0, ii = iflist; ii; ii = ii->ii_next, i++) {
			if (pfd[i].revents == 0)
				continue;
			fd = ii->ii_fd;
		again:
			cc = read(fd, (char *)buf, bufsize);
			/* Don't choke when we get ptraced */
			if (cc < 0 && errno == EINTR)
				goto again;
			if (cc < 0)
				error("read: %s", strerror(errno));
			/* Loop through the packet(s) */
#define bhp ((struct bpf_hdr *)bp)
			bp = buf;
			ep = bp + cc;
			while (bp < ep) {
				int caplen, hdrlen;

				caplen = bhp->bh_caplen;
				hdrlen = bhp->bh_hdrlen;
				if (rarp_check(bp + hdrlen, caplen))
					rarp_process(ii, bp + hdrlen);
				bp += BPF_WORDALIGN(hdrlen + caplen);
			}
		}
	}
	free(pfd);
}

#ifndef TFTP_DIR
#define TFTP_DIR "/tftpboot"
#endif

/*
 * True if this server can boot the host whose IP address is 'addr'.
 * This check is made by looking in the tftp directory for the
 * configuration file.
 */
int
rarp_bootable(u_int32_t addr)
{
	struct dirent *dent;
	char    ipname[40];
	static DIR *dd = 0;
	DIR *d;

	(void) snprintf(ipname, sizeof ipname, "%08X", addr);
	/* If directory is already open, rewind it.  Otherwise, open it. */
	if ((d = dd))
		rewinddir(d);
	else {
		if (chdir(TFTP_DIR) == -1)
			error("chdir: %s", strerror(errno));
		d = opendir(".");
		if (d == 0)
			error("opendir: %s", strerror(errno));
		dd = d;
	}
	while ((dent = readdir(d)))
		if (strncmp(dent->d_name, ipname, 8) == 0)
			return 1;
	return 0;
}


/*
 * Given a list of IP addresses, 'alist', return the first address that
 * is on network 'net'; 'netmask' is a mask indicating the network portion
 * of the address.
 */
static u_int32_t
choose_ipaddr(u_int32_t **alist, u_int32_t net, u_int32_t netmask)
{
	for (; *alist; ++alist) {
		if ((**alist & netmask) == net)
			return **alist;
	}
	return 0;
}
/*
 * Answer the RARP request in 'pkt', on the interface 'ii'.  'pkt' has
 * already been checked for validity.  The reply is overlaid on the request.
 */
void
rarp_process(struct if_info *ii, u_char *pkt)
{
	char    ename[HOST_NAME_MAX+1];
	u_int32_t  target_ipaddr;
	struct ether_header *ep;
	struct ether_addr *ea;
	struct hostent *hp;
	struct	in_addr in;
	struct if_addr *ia;

	ep = (struct ether_header *) pkt;
	ea = (struct ether_addr *) &ep->ether_shost;

	debug("%s", ether_ntoa(ea));
	if (ether_ntohost(ename, ea) != 0) {
		debug("ether_ntohost failed");
		return;
	}
	if ((hp = gethostbyname(ename)) == 0) {
		debug("gethostbyname (%s) failed", ename);
		return;
	}

	/* Choose correct address from list. */
	if (hp->h_addrtype != AF_INET)
		error("cannot handle non IP addresses");
	for (target_ipaddr = 0, ia = ii->ii_addrs; ia; ia = ia->ia_next) {
		target_ipaddr = choose_ipaddr((u_int32_t **) hp->h_addr_list,
		    ia->ia_ipaddr & ia->ia_netmask, ia->ia_netmask);
		if (target_ipaddr)
			break;
	}

	if (target_ipaddr == 0) {
		for (ia = ii->ii_addrs; ia; ia = ia->ia_next) {
			in.s_addr = ia->ia_ipaddr & ia->ia_netmask;
			warning("cannot find %s on net %s",
			    ename, inet_ntoa(in));
		}
		return;
	}
	if (tflag == 0 || rarp_bootable(htonl(target_ipaddr)))
		rarp_reply(ii, ia, ep, target_ipaddr, hp);
	debug("reply sent");
}

/*
 * Lookup the ethernet address of the interface attached to the BPF
 * file descriptor 'fd'; return it in 'eaddr'.
 */
void
lookup_addrs(char *ifname, struct if_info *p)
{
	struct ifaddrs *ifap, *ifa;
	struct sockaddr_dl *sdl;
	u_char *eaddr = p->ii_eaddr;
	struct if_addr *ia, **iap = &p->ii_addrs;
	struct in_addr in;
	int found = 0;

	if (getifaddrs(&ifap) != 0)
		error("getifaddrs: %s", strerror(errno));

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (strcmp(ifa->ifa_name, ifname))
			continue;
		sdl = (struct sockaddr_dl *) ifa->ifa_addr;
		if (sdl->sdl_family == AF_LINK &&
		    sdl->sdl_type == IFT_ETHER && sdl->sdl_alen == 6) {
			memcpy((caddr_t)eaddr, (caddr_t)LLADDR(sdl), 6);
			if (dflag)
				fprintf(stderr, "%s: %x:%x:%x:%x:%x:%x\n",
				    ifa->ifa_name,
				    eaddr[0], eaddr[1], eaddr[2],
				    eaddr[3], eaddr[4], eaddr[5]);
			found = 1;
		} else if (sdl->sdl_family == AF_INET) {
			ia = malloc(sizeof (struct if_addr));
			if (ia == NULL)
				error("lookup_addrs: malloc: %s",
				    strerror(errno));
			ia->ia_next = NULL;
			ia->ia_ipaddr =
			    ((struct sockaddr_in *) ifa->ifa_addr)->
			    sin_addr.s_addr;
			ia->ia_netmask =
			    ((struct sockaddr_in *) ifa->ifa_netmask)->
			    sin_addr.s_addr;
			/* If SIOCGIFNETMASK didn't work,
			   figure out a mask from the IP
			   address class. */
			if (ia->ia_netmask == 0)
				ia->ia_netmask =
				    ipaddrtonetmask(ia->ia_ipaddr);
			if (dflag) {
				in.s_addr = ia->ia_ipaddr;
				fprintf(stderr, "\t%s\n",
				    inet_ntoa(in));
			}
			*iap = ia;
			iap = &ia->ia_next;
		}
	}
	freeifaddrs(ifap);
	if (!found)
		error("lookup_addrs: Never saw interface `%s'!", ifname);
}

/*
 * Build a reverse ARP packet and sent it out on the interface.
 * 'ep' points to a valid ARPOP_REVREQUEST.  The ARPOP_REVREPLY is built
 * on top of the request, then written to the network.
 *
 * RFC 903 defines the ether_arp fields as follows.  The following comments
 * are taken (more or less) straight from this document.
 *
 * ARPOP_REVREQUEST
 *
 * arp_sha is the hardware address of the sender of the packet.
 * arp_spa is undefined.
 * arp_tha is the 'target' hardware address.
 *   In the case where the sender wishes to determine his own
 *   protocol address, this, like arp_sha, will be the hardware
 *   address of the sender.
 * arp_tpa is undefined.
 *
 * ARPOP_REVREPLY
 *
 * arp_sha is the hardware address of the responder (the sender of the
 *   reply packet).
 * arp_spa is the protocol address of the responder (see the note below).
 * arp_tha is the hardware address of the target, and should be the same as
 *   that which was given in the request.
 * arp_tpa is the protocol address of the target, that is, the desired address.
 *
 * Note that the requirement that arp_spa be filled in with the responder's
 * protocol is purely for convenience.  For instance, if a system were to use
 * both ARP and RARP, then the inclusion of the valid protocol-hardware
 * address pair (arp_spa, arp_sha) may eliminate the need for a subsequent
 * ARP request.
 */
void
rarp_reply(struct if_info *ii, struct if_addr *ia, struct ether_header *ep,
    u_int32_t ipaddr, struct hostent *hp)
{
	struct ether_arp *ap = (struct ether_arp *) (ep + 1);
	int len, n;

	/*
	 * Poke the kernel arp tables with the ethernet/ip address
	 * combination given.  When processing a reply, we must
	 * do this so that the booting host (i.e. the guy running
	 * rarpd), won't try to ARP for the hardware address of the
	 * guy being booted (he cannot answer the ARP).
	 */
	if (arptab_set((u_char *)&ap->arp_sha, ipaddr) > 0)
		syslog(LOG_ERR, "couldn't update arp table");

	/* Build the rarp reply by modifying the rarp request in place. */
	ep->ether_type = htons(ETHERTYPE_REVARP);
	ap->ea_hdr.ar_hrd = htons(ARPHRD_ETHER);
	ap->ea_hdr.ar_pro = htons(ETHERTYPE_IP);
	ap->arp_op = htons(ARPOP_REVREPLY);

	memcpy((char *) &ep->ether_dhost, (char *) &ap->arp_sha, 6);
	memcpy((char *) &ep->ether_shost, (char *) ii->ii_eaddr, 6);
	memcpy((char *) &ap->arp_sha, (char *) ii->ii_eaddr, 6);

	memcpy((char *) ap->arp_tpa, (char *) &ipaddr, 4);
	/* Target hardware is unchanged. */
	memcpy((char *) ap->arp_spa, (char *) &ia->ia_ipaddr, 4);

	if (lflag) {
		struct ether_addr ea;

		memcpy(&ea.ether_addr_octet, &ap->arp_sha, 6);
		syslog(LOG_INFO, "%s asked; %s replied", hp->h_name,
		    ether_ntoa(&ea));
	}

	len = sizeof(*ep) + sizeof(*ap);
	n = write(ii->ii_fd, (char *) ep, len);
	if (n != len)
		warning("write: only %d of %d bytes written", n, len);
}
/*
 * Get the netmask of an IP address.  This routine is used if
 * SIOCGIFNETMASK doesn't work.
 */
u_int32_t
ipaddrtonetmask(u_int32_t addr)
{
	if (IN_CLASSA(addr))
		return IN_CLASSA_NET;
	if (IN_CLASSB(addr))
		return IN_CLASSB_NET;
	if (IN_CLASSC(addr))
		return IN_CLASSC_NET;
	error("unknown IP address class: %08X", addr);
}

void
warning(const char *fmt,...)
{
	va_list ap;

	if (dflag) {
		(void) fprintf(stderr, "rarpd: warning: ");
		va_start(ap, fmt);
		(void) vfprintf(stderr, fmt, ap);
		va_end(ap);
		(void) fprintf(stderr, "\n");
	}
	va_start(ap, fmt);
	vsyslog(LOG_ERR, fmt, ap);
	va_end(ap);
}

__dead void
error(const char *fmt,...)
{
	va_list ap;

	if (dflag) {
		(void) fprintf(stderr, "rarpd: error: ");
		va_start(ap, fmt);
		(void) vfprintf(stderr, fmt, ap);
		va_end(ap);
		(void) fprintf(stderr, "\n");
	}
	va_start(ap, fmt);
	vsyslog(LOG_ERR, fmt, ap);
	va_end(ap);
	exit(1);
}

void
debug(const char *fmt,...)
{
	va_list ap;

	if (dflag) {
		va_start(ap, fmt);
		(void) fprintf(stderr, "rarpd: ");
		(void) vfprintf(stderr, fmt, ap);
		va_end(ap);
		(void) fprintf(stderr, "\n");
	}
}
@


1.70
log
@Split error() into error() and warn() so that error() can be marked
__dead and thus let gcc sleep at night.

ok tb@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.69 2016/12/18 06:11:23 krw Exp $ */
d484 1
a484 1
			error("cannot find %s on net %s",
@


1.69
log
@Nuke more unused variables.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.68 2016/05/28 07:00:18 natano Exp $ */
a54 3
#define FATAL		1	/* fatal error occurred */
#define NONFATAL	0	/* non fatal error occurred */

d82 1
a82 1
void   usage(void);
d88 2
a89 1
void   error(int, const char *,...);
a129 1
			/* NOTREACHED */
d149 1
a149 1
			error(FATAL, "failed to daemonize: %s", strerror(errno));
d175 2
a176 4
	if (p == 0) {
		error(FATAL, "malloc: %s", strerror(errno));
		/* NOTREACHED */
	}
d197 2
a198 4
	if (getifaddrs(&ifap) != 0) {
		error(FATAL, "getifaddrs: %s", strerror(errno));
		/* NOTREACHED */
	}
d214 1
a214 1
void
d248 1
a248 1
		error(FATAL, "/dev/bpf0: %s", strerror(errno));
d253 1
a253 2
		error(FATAL, "BIOCIMMEDIATE: %s", strerror(errno));
		/* NOTREACHED */
d262 1
a262 2
		error(FATAL, "BIOCSETIF: %s", strerror(errno));
		/* NOTREACHED */
d269 2
a270 4
	if (ioctl(fd, BIOCGDLT, (caddr_t) &dlt) < 0) {
		error(FATAL, "BIOCGDLT: %s", strerror(errno));
		/* NOTREACHED */
	}
d276 1
a276 2
		error(FATAL, "%s is not an ethernet", device);
		/* NOTREACHED */
d279 2
a280 4
	if (ioctl(fd, BIOCSETF, (caddr_t)&filter) < 0) {
		error(FATAL, "BIOCSETF: %s", strerror(errno));
		/* NOTREACHED */
	}
d296 1
a296 1
		error(NONFATAL, "truncated request");
d305 1
a305 1
		error(NONFATAL, "request fails sanity check");
d309 1
a309 1
		error(NONFATAL, "ether/arp sender address mismatch");
d313 1
a313 1
		error(NONFATAL, "ether/arp target address mismatch");
d332 4
a335 8
	if (iflist == 0) {
		error(FATAL, "no interfaces");
		/* NOTREACHED */
	}
	if (ioctl(iflist->ii_fd, BIOCGBLEN, (caddr_t)&bufsize) < 0) {
		error(FATAL, "BIOCGBLEN: %s", strerror(errno));
		/* NOTREACHED */
	}
d340 1
a340 1
		error(FATAL, "pledge");
d343 2
a344 4
	if (buf == 0) {
		error(FATAL, "malloc: %s", strerror(errno));
		/* NOTREACHED */
	}
d351 2
a352 4
	if (pfd == NULL) {
		error(FATAL, "reallocarray: %s", strerror(errno));
		/* NOTREACHED */
	}
d362 1
a362 2
			error(FATAL, "poll: %s", strerror(errno));
			/* NOTREACHED */
d373 2
a374 4
			if (cc < 0) {
				error(FATAL, "read: %s", strerror(errno));
				/* NOTREACHED */
			}
d415 2
a416 4
		if (chdir(TFTP_DIR) == -1) {
			error(FATAL, "chdir: %s", strerror(errno));
			/* NOTREACHED */
		}
d418 2
a419 4
		if (d == 0) {
			error(FATAL, "opendir: %s", strerror(errno));
			/* NOTREACHED */
		}
d472 2
a473 4
	if (hp->h_addrtype != AF_INET) {
		error(FATAL, "cannot handle non IP addresses");
		/* NOTREACHED */
	}
d484 1
a484 1
			error(NONFATAL, "cannot find %s on net %s",
d508 2
a509 4
	if (getifaddrs(&ifap) != 0) {
		error(FATAL, "getifaddrs: %s", strerror(errno));
		/* NOTREACHED */
	}
d527 1
a527 1
				error(FATAL, "lookup_addrs: malloc: %s",
d553 1
a553 1
		error(FATAL, "lookup_addrs: Never saw interface `%s'!", ifname);
d631 1
a631 1
		error(NONFATAL, "write: only %d of %d bytes written", n, len);
d646 1
a646 2
	error(FATAL, "unknown IP address class: %08X", addr);
	/* NOTREACHED */
d650 1
a650 1
error(int fatal, const char *fmt,...)
d655 1
a655 4
		if (fatal)
			(void) fprintf(stderr, "rarpd: error: ");
		else
			(void) fprintf(stderr, "rarpd: warning: ");
d664 18
a681 3
	if (fatal)
		exit(1);
	/* NOTREACHED */
@


1.68
log
@Replace the /dev/bpf* open loop with a plain open("/dev/bpf0", ...).
ok deraadt jca
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.67 2015/11/19 19:31:20 deraadt Exp $ */
d107 1
a107 2
	int op, devnull, f;
	pid_t pid;
@


1.67
log
@hoist the SOCK_RAW setup to the top before pledge
issues discovered by sebastia
comments from semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.66 2015/11/13 16:10:23 deraadt Exp $ */
a228 19
static int
bpf_open(void)
{
	int	fd, n = 0;
	char    device[sizeof "/dev/bpf0000000000"];

	/* Go through all the minors and find one that isn't in use. */
	do {
		(void) snprintf(device, sizeof device, "/dev/bpf%d", n++);
		fd = open(device, O_RDWR);
	} while (fd < 0 && errno == EBUSY);

	if (fd < 0) {
		error(FATAL, "%s: %s", device, strerror(errno));
		/* NOTREACHED */
	}
	return fd;
}

d255 2
a256 1
	fd = bpf_open();
@


1.66
log
@pledge "stdio rpath dns" right at the start of the servicing loop.
Commiting to gather reports.
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.65 2015/10/27 11:47:17 jca Exp $ */
d89 1
d373 2
@


1.65
log
@Consistency in error messages.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.64 2015/10/26 10:08:14 jung Exp $ */
d372 4
@


1.64
log
@remove util.h include and -lutil after pidfile removal

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.63 2015/10/26 09:57:55 deraadt Exp $ */
d384 1
a384 1
		error(FATAL, "malloc: %s", strerror(errno));
d396 1
a396 1
			error(FATAL, "select: %s", strerror(errno));
@


1.63
log
@stop using pidfile()
ok benno jung jca
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.62 2015/10/16 23:09:53 deraadt Exp $ */
a50 1
#include <util.h>
@


1.62
log
@use daemon(), jca had the same diff in his tree
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.61 2015/08/20 22:39:29 deraadt Exp $ */
a153 1
		pidfile(NULL);
@


1.61
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.60 2015/07/16 17:51:22 miod Exp $ */
d152 2
a153 11
		pid = fork();
		if (pid > 0)
			/* Parent exits, leaving child in background. */
			exit(0);
		else
			if (pid == -1) {
				error(FATAL, "cannot fork");
				/* NOTREACHED */
			}

		/* write pid file */
a154 20

		/* Fade into the background */
		f = open(_PATH_TTY, O_RDWR);
		if (f >= 0) {
			if (ioctl(f, TIOCNOTTY, 0) < 0) {
				error(FATAL, "TIOCNOTTY: %s", strerror(errno));
				/* NOTREACHED */
			}
			(void) close(f);
		}
		(void) chdir("/");
		(void) setpgid(0, 0);
		devnull = open(_PATH_DEVNULL, O_RDWR);
		if (devnull >= 0) {
			(void) dup2(devnull, STDIN_FILENO);
			(void) dup2(devnull, STDOUT_FILENO);
			(void) dup2(devnull, STDERR_FILENO);
			if (devnull > 2)
				(void) close(devnull);
		}
@


1.60
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.59 2015/01/19 23:51:54 guenther Exp $ */
d208 1
a208 1
	p = (struct if_info *)malloc(sizeof(*p));
d403 1
a403 1
	buf = (u_char *) malloc((size_t) bufsize);
@


1.59
log
@Routing sockets are here to stay, so delete the wrapper that would use the
defunct ioctl(SIOCSARP)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.58 2015/01/16 06:40:19 deraadt Exp $ */
d674 1
a674 1
	 * combinataion given.  When processing a reply, we must
@


1.58
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.57 2014/12/16 03:35:49 millert Exp $ */
d90 1
a90 1
void   update_arptab(u_char *, u_int32_t);
a631 42
int arptab_set(u_char *eaddr, u_int32_t host);

/*
 * Poke the kernel arp tables with the ethernet/ip address combinataion
 * given.  When processing a reply, we must do this so that the booting
 * host (i.e. the guy running rarpd), won't try to ARP for the hardware
 * address of the guy being booted (he cannot answer the ARP).
 */
void
update_arptab(u_char *ep, u_int32_t ipaddr)
{
#ifdef SIOCSARP
	struct sockaddr_in *sin;
	struct arpreq request;
	u_int32_t host;
	u_char *eaddr;
	int s;

	request.arp_flags = 0;
	sin = (struct sockaddr_in *)&request.arp_pa;
	sin->sin_family = AF_INET;
	sin->sin_addr.s_addr = ipaddr;
	request.arp_ha.sa_family = AF_UNSPEC;
	/* This is needed #if defined(COMPAT_43) && BYTE_ORDER != BIG_ENDIAN,
	   because AF_UNSPEC is zero and the kernel assumes that a zero
	   sa_family means that the real sa_family value is in sa_len.  */
	request.arp_ha.sa_len = 16; /* XXX */
	memcpy((char *) request.arp_ha.sa_data, (char *) ep, 6);

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s < 0) {
		error(NONFATAL, "socket: %s", strerror(errno));
	} else {
		if (ioctl(s, SIOCSARP, (caddr_t)&request) < 0)
		    error(NONFATAL, "SIOCSARP: %s", strerror(errno));
		(void) close(s);
	}
#else
	if (arptab_set(ep, ipaddr) > 0)
		syslog(LOG_ERR, "couldn't update arp table");
#endif
}
d672 9
a680 1
	update_arptab((u_char *)&ap->arp_sha, ipaddr);
@


1.57
log
@Replace setpgrp(0, getpid()) with setpgid(0, 0).  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.56 2014/10/31 20:11:52 deraadt Exp $ */
a28 7
#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>
#include <string.h>
#include <stdarg.h>
#include <sys/param.h>
#include <unistd.h>
d30 1
a30 1
#include <net/bpf.h>
d33 1
d39 8
a46 1
#include <sys/file.h>
d522 1
a522 1
	char    ename[MAXHOSTNAMELEN];
@


1.56
log
@convert select() to poll().  Bit more complicated here.  Some interesting
discussion with millert about POLLHUP, which is not needed here because
this is a bpf description, but indicates we need to consider that elsewhere.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.55 2014/10/29 06:16:34 deraadt Exp $ */
d174 1
a174 1
		(void) setpgrp(0, getpid());
@


1.55
log
@delete obscure workaround for a bug in SunOS.
(But leave the VMS workaround intact)
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.54 2014/10/08 04:58:18 deraadt Exp $ */
d51 1
d388 1
a388 1
	int	cc, fd, fdsn, maxfd = 0;
d390 1
a390 1
	fd_set  *fdsp, *lfdsp;
a407 1
	 * Find the highest numbered file descriptor for select().
d411 10
a420 12
		if (ii->ii_fd > maxfd)
			maxfd = ii->ii_fd;

	fdsn = howmany(maxfd+1, NFDBITS) * sizeof(fd_mask);
	if ((fdsp = (fd_set *)malloc(fdsn)) == NULL)
		error(FATAL, "malloc");
	if ((lfdsp = (fd_set *)malloc(fdsn)) == NULL)
		error(FATAL, "malloc");

	memset(fdsp, 0, fdsn);
	for (ii = iflist; ii; ii = ii->ii_next)
		FD_SET(ii->ii_fd, fdsp);
d423 3
a425 3
		memcpy(lfdsp, fdsp, fdsn);
		if (select(maxfd + 1, lfdsp, (fd_set *) 0,
			(fd_set *) 0, (struct timeval *) 0) < 0) {
d429 3
a431 1
		for (ii = iflist; ii; ii = ii->ii_next) {
a432 2
			if (!FD_ISSET(fd, lfdsp))
				continue;
d434 1
a434 1
			cc = read(fd, (char *) buf, bufsize);
d457 1
@


1.54
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.53 2012/04/06 18:03:52 deraadt Exp $ */
a439 3
			/* Due to a SunOS bug, after 2^31 bytes, the file
			 * offset overflows and read fails with EINVAL.  The
			 * lseek() to 0 will fix things. */
a440 5
				if (errno == EINVAL &&
				    (lseek(fd, (off_t)0, SEEK_CUR) + bufsize) < 0) {
					(void) lseek(fd, (off_t)0, SEEK_SET);
					goto again;
				}
@


1.53
log
@BIOCGBLEN is using a u_int, not an int
and casting to size_t for malloc is better
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.52 2010/08/29 12:33:25 chl Exp $ */
d609 1
a609 1
			ia = malloc (sizeof (struct if_addr));
@


1.52
log
@remove unused variable

ok jsg@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.51 2010/08/26 18:25:38 jsg Exp $ */
d387 2
a388 1
	int	cc, fd, fdsn, bufsize, maxfd = 0;
d390 1
a390 1
	u_char *buf, *bp, *ep;
d401 1
a401 1
	buf = (u_char *) malloc((unsigned) bufsize);
@


1.51
log
@remove a silly comment that duplicates the usage string at the start of
the file.
spotted by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.50 2010/08/26 17:07:46 jsg Exp $ */
a105 1
	char   *ifname;
@


1.50
log
@Allow multiple interfaces to be specified instead of all or one.
ok krw@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.49 2009/10/27 23:59:54 deraadt Exp $ */
a26 2
 *
 * usage:	rarpd [-adflt] interface
@


1.49
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.48 2008/05/17 23:31:52 sobrado Exp $ */
d137 4
a140 2
	ifname = argv[optind++];
	if ((aflag && ifname) || (!aflag && ifname == 0))
d146 5
a150 1
		init_one(ifname);
d256 1
a256 1
	(void) fprintf(stderr, "usage: rarpd [-adflt] interface\n");
@


1.48
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.47 2006/04/02 00:50:42 deraadt Exp $ */
a23 10
#ifndef lint
char    copyright[] =
"@@(#) Copyright (c) 1990 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif				/* not lint */

#ifndef lint
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.47 2006/04/02 00:50:42 deraadt Exp $";
#endif

@


1.47
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.46 2006/01/23 17:29:22 millert Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.46 2006/01/23 17:29:22 millert Exp $";
d38 1
a38 2
 * Usage:	rarpd -a [-d] [-f] [-l] [-t]
 *		rarpd [-d] [-f] [-l] [-t] interface
d260 1
a260 2
	(void) fprintf(stderr, "usage: rarpd -a [-dflt]\n");
	(void) fprintf(stderr, "       rarpd [-dflt] interface\n");
@


1.46
log
@Include <sys/param.h> instead of <sys/types.h> so we get MAXHOSTNAMELEN
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.45 2005/12/21 01:40:24 millert Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.45 2005/12/21 01:40:24 millert Exp $";
d454 1
a454 1
					(void) lseek(fd, (off_t)0, 0);
@


1.45
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.44 2004/09/15 22:33:15 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.44 2004/09/15 22:33:15 deraadt Exp $";
d47 1
a47 1
#include <sys/types.h>
@


1.44
log
@rename local err() function to error()
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.43 2004/05/08 20:17:49 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.43 2004/05/08 20:17:49 deraadt Exp $";
a57 1
#include <sys/errno.h>
d59 1
@


1.43
log
@lots of munging about; canacar ok, tested by pb, looked at by various others
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.42 2004/05/05 01:16:39 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.42 2004/05/05 01:16:39 deraadt Exp $";
d102 1
a102 1
void   err(int, const char *,...);
d164 1
a164 1
				err(FATAL, "cannot fork");
d175 1
a175 1
				err(FATAL, "TIOCNOTTY: %s", strerror(errno));
d216 1
a216 1
		err(FATAL, "malloc: %s", strerror(errno));
d240 1
a240 1
		err(FATAL, "getifaddrs: %s", strerror(errno));
d279 1
a279 1
		err(FATAL, "%s: %s", device, strerror(errno));
d316 1
a316 1
		err(FATAL, "BIOCIMMEDIATE: %s", strerror(errno));
d326 1
a326 1
		err(FATAL, "BIOCSETIF: %s", strerror(errno));
d335 1
a335 1
		err(FATAL, "BIOCGDLT: %s", strerror(errno));
d343 1
a343 1
		err(FATAL, "%s is not an ethernet", device);
d348 1
a348 1
		err(FATAL, "BIOCSETF: %s", strerror(errno));
d366 1
a366 1
		err(NONFATAL, "truncated request");
d375 1
a375 1
		err(NONFATAL, "request fails sanity check");
d379 1
a379 1
		err(NONFATAL, "ether/arp sender address mismatch");
d383 1
a383 1
		err(NONFATAL, "ether/arp target address mismatch");
d402 1
a402 1
		err(FATAL, "no interfaces");
d406 1
a406 1
		err(FATAL, "BIOCGBLEN: %s", strerror(errno));
d411 1
a411 1
		err(FATAL, "malloc: %s", strerror(errno));
d424 1
a424 1
		err(1, "malloc");
d426 1
a426 1
		err(1, "malloc");
d436 1
a436 1
			err(FATAL, "select: %s", strerror(errno));
d457 1
a457 1
				err(FATAL, "read: %s", strerror(errno));
d500 1
a500 1
			err(FATAL, "chdir: %s", strerror(errno));
d505 1
a505 1
			err(FATAL, "opendir: %s", strerror(errno));
d561 1
a561 1
		err(FATAL, "cannot handle non IP addresses");
d574 1
a574 1
			err(NONFATAL, "cannot find %s on net %s",
d599 1
a599 1
		err(FATAL, "getifaddrs: %s", strerror(errno));
d619 1
a619 1
				err(FATAL, "lookup_addrs: malloc: %s",
d645 1
a645 1
		err(FATAL, "lookup_addrs: Never saw interface `%s'!", ifname);
d679 1
a679 1
		err(NONFATAL, "socket: %s", strerror(errno));
d682 1
a682 1
		    err(NONFATAL, "SIOCSARP: %s", strerror(errno));
d757 1
a757 1
		err(NONFATAL, "write: only %d of %d bytes written", n, len);
d772 1
a772 1
	err(FATAL, "unknown IP address class: %08X", addr);
d777 1
a777 1
err(int fatal, const char *fmt,...)
@


1.42
log
@move static filter out of function
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.41 2003/07/21 19:44:33 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.41 2003/07/21 19:44:33 deraadt Exp $";
d38 2
a39 2
 * Usage:	rarpd -a [ -d ] [ -f ] [ -l ]
 *		rarpd [ -d ] [ -f ] [ -l ] interface
a104 2

#ifdef REQUIRE_TFTPBOOT
a105 1
#endif
d108 4
a111 3
int     dflag = 0;		/* print debugging messages */
int     fflag = 0;		/* don't fork */
int     lflag = 0;		/* log all replies */
a115 2
	int op, devnull, f;
	char   *ifname, *hostname;
a116 1
	extern char *optarg;
d118 2
d126 1
a126 1
	while ((op = getopt(argc, argv, "adfl")) != -1) {
a130 1

a133 1

a136 1

d140 3
a142 1

a148 1
	hostname = ifname ? argv[optind] : 0;
d261 2
a262 2
	(void) fprintf(stderr, "usage: rarpd -a [-dfl]\n");
	(void) fprintf(stderr, "       rarpd [-dfl] interface\n");
d307 1
a307 1
	int     fd, immediate;
d319 1
d321 1
a321 1
	if (ioctl(fd, BIOCSETIF, (caddr_t) & ifr) < 0) {
d329 6
a334 3
	/* Check that the data link layer is an Ethernet; this code won't work
	 * with anything else. */
	if (ioctl(fd, BIOCGDLT, (caddr_t) & dlt) < 0) {
d347 1
a347 1
	if (ioctl(fd, BIOCSETF, (caddr_t) & filter) < 0) {
d396 2
a398 4
	int     cc, fd;
	fd_set  *fdsp, *lfdsp;
	int	fdsn;
	int     bufsize, maxfd = 0;
d405 1
a405 1
	if (ioctl(iflist->ii_fd, BIOCGBLEN, (caddr_t) & bufsize) < 0) {
d453 2
a454 2
				    (lseek(fd, 0, SEEK_CUR) + bufsize) < 0) {
					(void) lseek(fd, 0, 0);
a474 2
	free(fdsp);
	free(lfdsp);
a476 2
#ifdef REQUIRE_TFTPBOOT

a489 1
	DIR *d;
d492 1
d496 1
a496 1
	if (d = dd)
d510 1
a510 1
	while (dent = readdir(d))
d515 1
a515 1
#endif /* REQUIRE_TFTPBOOT */
d538 2
a542 2
	u_int32_t  target_ipaddr;
	char    ename[MAXHOSTNAMELEN];
d579 1
a579 3
#ifdef REQUIRE_TFTPBOOT
	if (rarp_bootable(htonl(target_ipaddr)))
#endif
d595 1
a596 1
	struct in_addr in;
d609 1
a609 2
			memcpy((caddr_t)eaddr, (caddr_t)LLADDR(sdl),
			    6);
d611 1
a611 2
				fprintf(stderr,
				    "%s: %x:%x:%x:%x:%x:%x\n",
d660 1
a660 1
	int     s;
d662 1
a662 2
	struct sockaddr_in *sin;

d664 1
a664 1
	u_int32_t host;
d667 1
a667 1
	sin = (struct sockaddr_in *) & request.arp_pa;
d681 1
a681 1
		if (ioctl(s, SIOCSARP, (caddr_t) & request) < 0) {
a682 1
		}
a726 1
	int     n;
d728 1
a728 1
	int     len;
d730 1
a730 1
	update_arptab((u_char *) & ap->arp_sha, ipaddr);
d756 1
a756 1
	if (n != len) {
a757 1
	}
d794 1
a794 1
	if (fatal) {
a795 1
	}
@


1.41
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.40 2003/07/21 19:44:05 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.40 2003/07/21 19:44:05 deraadt Exp $";
d289 16
d312 1
a312 1
	int     fd;
a314 15
	int     immediate;

	static struct bpf_insn insns[] = {
		BPF_STMT(BPF_LD | BPF_H | BPF_ABS, 12),
		BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, ETHERTYPE_REVARP, 0, 3),
		BPF_STMT(BPF_LD | BPF_H | BPF_ABS, 20),
		BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, ARPOP_REVREQUEST, 0, 1),
		BPF_STMT(BPF_RET | BPF_K, sizeof(struct ether_arp) +
		    sizeof(struct ether_header)),
		BPF_STMT(BPF_RET | BPF_K, 0),
	};
	static struct bpf_program filter = {
		sizeof insns / sizeof(insns[0]),
		insns
	};
@


1.40
log
@use more defines; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.39 2003/06/01 15:53:43 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.39 2003/06/01 15:53:43 deraadt Exp $";
d528 1
a528 1
u_int32_t
@


1.39
log
@various format string cleanups; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.38 2003/05/15 14:52:12 itojun Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.38 2003/05/15 14:52:12 itojun Exp $";
d65 1
d82 1
a82 1
	u_char	ii_eaddr[6];		/* Ethernet address of this iface */
d177 1
a177 1
		f = open("/dev/tty", O_RDWR);
d187 1
a187 1
		devnull = open("/dev/null", O_RDWR);
d189 3
a191 3
			(void) dup2(devnull, 0);
			(void) dup2(devnull, 1);
			(void) dup2(devnull, 2);
@


1.38
log
@assume presense of getifaddrs(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.37 2002/07/20 17:58:16 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.37 2002/07/20 17:58:16 deraadt Exp $";
d554 1
a554 1
	debug(ether_ntoa(ea));
@


1.37
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.36 2002/05/26 09:25:21 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.36 2002/05/26 09:25:21 deraadt Exp $";
a63 1
#ifdef HAVE_IFADDRS_H
a64 1
#endif
a239 1
#ifdef HAVE_IFADDRS_H
a259 61
#else
	char *inbuf = NULL, *ninbuf;
	struct ifconf ifc;
	struct ifreq *ifr;
	struct sockaddr_dl *sdl;
	int fd, inlen = 8192;
	int i, len;

	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		err(FATAL, "socket: %s", strerror(errno));
		/* NOTREACHED */
	}

	while (1) {
		ifc.ifc_len = inlen;
		ninbuf = realloc(inbuf, inlen);
		if (ninbuf == NULL) {
			if (inbuf)
				free(inbuf);
			close(fd);
			err(FATAL, "init_all: malloc: %s", strerror(errno));
		}
		ifc.ifc_buf = inbuf = ninbuf;
		if (ioctl(fd, SIOCGIFCONF, (char *)&ifc) < 0) {
			(void) close(fd);
			free(inbuf);
			err(FATAL, "init_all: SIOCGIFCONF: %s",
			    strerror(errno));
			/* NOTREACHED */
		}
		if (ifc.ifc_len + sizeof(*ifr) < inlen)
			break;
		inlen *= 2;
	}

	ifr = ifc.ifc_req;
	for (i = 0; i < ifc.ifc_len;
	    i += len, ifr = (struct ifreq *)((caddr_t)ifr + len)) {
		len = sizeof(ifr->ifr_name) +
		    (ifr->ifr_addr.sa_len > sizeof(struct sockaddr) ?
		    ifr->ifr_addr.sa_len : sizeof(struct sockaddr));

		sdl = (struct sockaddr_dl *)&ifr->ifr_addr;
		if (sdl->sdl_family != AF_LINK || sdl->sdl_type != IFT_ETHER ||
		    sdl->sdl_alen != 6)
			continue;

		if (ioctl(fd, SIOCGIFFLAGS, (caddr_t)ifr) < 0) {
			free(inbuf);
			err(FATAL, "init_all: SIOCGIFFLAGS %s: %s",
			    ifr->ifr_name, strerror(errno));
			/* NOTREACHED */
		}
		if ((ifr->ifr_flags &
		    (IFF_UP | IFF_LOOPBACK | IFF_POINTOPOINT)) != IFF_UP)
			continue;
		init_one(ifr->ifr_name);
	}
	free(inbuf);
	(void) close(fd);
#endif
a597 1
#ifdef HAVE_IFADDRS_H
a654 100
#else
	u_char *eaddr = p->ii_eaddr;
	struct if_addr *ia, **iap = &p->ii_addrs;
	char *inbuf = NULL, *ninbuf;
	struct ifconf ifc;
	struct ifreq *ifr, ifr_mask;
	struct in_addr in;
	struct sockaddr_dl *sdl;
	int fd;
	int i, len, inlen = 8192, found = 0;

	/* We cannot use SIOCGIFADDR on the BPF descriptor.
	   We must instead get all the interfaces with SIOCGIFCONF
	   and find the right one.  */

	/* Use datagram socket to get Ethernet address. */
	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		err(FATAL, "socket: %s", strerror(errno));
		/* NOTREACHED */
	}

	while (1) {
		ifc.ifc_len = inlen;
		ninbuf= realloc(inbuf, inlen);
		if (ninbuf == NULL) {
			if (inbuf)
				free(inbuf);
			close(fd);
			err(FATAL, "lookup_addrs: malloc: %s",
			    strerror(errno));
		}
		ifc.ifc_buf = inbuf = ninbuf;
		if (ioctl(fd, SIOCGIFCONF, (char *)&ifc) < 0) {
			(void) close(fd);
			free(inbuf);
			err(FATAL, "lookup_addrs: SIOCGIFCONF: %s",
			    strerror(errno));
			/* NOTREACHED */
		}
		if (ifc.ifc_len + sizeof(*ifr) < inlen)
			break;
		inlen *= 2;
	}

	ifr = ifc.ifc_req;
	for (i = 0; i < ifc.ifc_len;
	    i += len, ifr = (struct ifreq *)((caddr_t)ifr + len)) {
		len = sizeof(ifr->ifr_name) +
		    (ifr->ifr_addr.sa_len > sizeof(struct sockaddr) ?
		    ifr->ifr_addr.sa_len : sizeof(struct sockaddr));
		if (!strncmp(ifr->ifr_name, ifname, sizeof(ifr->ifr_name))) {
			sdl = (struct sockaddr_dl *) & ifr->ifr_addr;
			if (sdl->sdl_family == AF_LINK &&
			    sdl->sdl_type == IFT_ETHER && sdl->sdl_alen == 6) {
				memcpy((caddr_t)eaddr, (caddr_t)LLADDR(sdl), 6);
				if (dflag)
					fprintf(stderr,
					    "%s: %x:%x:%x:%x:%x:%x\n",
					    ifr->ifr_name,
					    eaddr[0], eaddr[1], eaddr[2],
					    eaddr[3], eaddr[4], eaddr[5]);
				found = 1;
			} else if (sdl->sdl_family == AF_INET) {
				ia = malloc (sizeof (struct if_addr));
				if (ia == NULL)
					err(FATAL, "lookup_addrs: malloc: %s",
					    strerror(errno));
				ia->ia_next = NULL;
				ia->ia_ipaddr =
				    ((struct sockaddr_in *) sdl)->
				    sin_addr.s_addr;
				memcpy(&ifr_mask, ifr, sizeof(*ifr));
				if (ioctl(fd, SIOCGIFNETMASK,
				    (char *) &ifr_mask) < 0)
					err(FATAL, "SIOCGIFNETMASK: %s",
					    strerror(errno));
				ia->ia_netmask =
				    ((struct sockaddr_in *)
				    & ifr_mask.ifr_addr)->sin_addr.s_addr;
				/* If SIOCGIFNETMASK didn't work,
				   figure out a mask from the IP
				   address class. */
				if (ia->ia_netmask == 0)
					ia->ia_netmask =
					    ipaddrtonetmask(ia->ia_ipaddr);
				if (dflag) {
					in.s_addr = ia->ia_ipaddr;
					fprintf(stderr, "\t%s\n",
					    inet_ntoa(in));
				}
				*iap = ia;
				iap = &ia->ia_next;
			}
		}
	}

	free(inbuf);
	if (!found)
		err(FATAL, "lookup_addrs: Never saw interface `%s'!", ifname);
#endif
@


1.36
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.35 2002/03/14 16:44:25 mpech Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.35 2002/03/14 16:44:25 mpech Exp $";
d81 1
a81 1
	int     ii_fd;			/* BPF file descriptor */
d83 1
a83 1
	u_char  ii_eaddr[6];		/* Ethernet address of this iface */
d111 1
a111 1
int     aflag = 0;		/* listen on "all" interfaces  */
d117 1
a117 3
main(argc, argv)
	int     argc;
	char  **argv;
d119 1
a119 1
	int     op, devnull, f;
a163 2
		FILE *fp;

d206 1
a206 2
init_one(ifname)
	char   *ifname;
d240 1
a240 1
init_all()
d300 1
a300 1
	     i += len, ifr = (struct ifreq *)((caddr_t)ifr + len)) {
d302 2
a303 2
		      (ifr->ifr_addr.sa_len > sizeof(struct sockaddr) ?
		       ifr->ifr_addr.sa_len : sizeof(struct sockaddr));
d327 1
a327 1
usage()
d335 1
a335 1
bpf_open()
d337 1
a337 2
	int     fd;
	int     n = 0;
d357 1
a357 2
rarp_open(device)
	char   *device;
d421 1
a421 3
rarp_check(p, len)
	u_char *p;
	int     len;
d457 1
a457 1
rarp_loop()
d480 3
a482 3
         * Find the highest numbered file descriptor for select().
         * Initialize the set of descriptors to listen to.
         */
d556 1
a556 2
rarp_bootable(addr)
	u_int32_t  addr;
d592 1
a592 4
choose_ipaddr(alist, net, netmask)
	u_int32_t **alist;
	u_int32_t  net;
	u_int32_t  netmask;
d605 1
a605 3
rarp_process(ii, pkt)
	struct if_info *ii;
	u_char *pkt;
d660 1
a660 3
lookup_addrs(ifname, p)
	char *ifname;
	struct if_info *p;
d766 1
a766 1
	     i += len, ifr = (struct ifreq *)((caddr_t)ifr + len)) {
d768 2
a769 2
		      (ifr->ifr_addr.sa_len > sizeof(struct sockaddr) ?
		       ifr->ifr_addr.sa_len : sizeof(struct sockaddr));
d774 1
a774 2
				memcpy((caddr_t)eaddr, (caddr_t)LLADDR(sdl),
				    6);
d831 1
a831 3
update_arptab(ep, ipaddr)
	u_char *ep;
	u_int32_t  ipaddr;
d900 2
a901 6
rarp_reply(ii, ia, ep, ipaddr, hp)
	struct if_info *ii;
	struct if_addr *ia;
	struct ether_header *ep;
	u_int32_t  ipaddr;
	struct hostent *hp;
d924 1
a924 1
		struct ether_addr ea;		
d927 1
a927 1
		syslog(LOG_INFO, "%s asked; %s replied", hp->h_name, 
d942 1
a942 2
ipaddrtonetmask(addr)
	u_int32_t  addr;
@


1.35
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.34 2002/02/19 19:39:40 millert Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.34 2002/02/19 19:39:40 millert Exp $";
d121 1
a121 1
	int     op, pid, devnull, f;
d126 1
@


1.34
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.33 2002/02/17 19:42:39 millert Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.33 2002/02/17 19:42:39 millert Exp $";
d538 1
a538 1
				register int caplen, hdrlen;
d567 2
a568 2
	register struct dirent *dent;
	register DIR *d;
@


1.33
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.32 2002/02/16 21:28:08 millert Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.32 2002/02/16 21:28:08 millert Exp $";
d46 1
a977 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a978 1
#ifdef __STDC__
a979 6
#else
err(fmt, va_alist)
	int     fatal;
	char   *fmt;
va_dcl
#endif
d982 1
a987 1
#ifdef __STDC__
a988 3
#else
		va_start(ap);
#endif
a992 1
#ifdef __STDC__
a993 3
#else
	va_start(ap);
#endif
a1002 1
#ifdef __STDC__
a1003 5
#else
debug(fmt, va_alist)
	char   *fmt;
va_dcl
#endif
a1007 1
#ifdef __STDC__
a1008 3
#else
		va_start(ap);
#endif
@


1.32
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.31 2001/12/01 23:27:23 miod Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.31 2001/12/01 23:27:23 miod Exp $";
d99 2
a100 2
void   rarp_reply    __P((struct if_info *, struct if_addr *,
	struct ether_header *, u_int32_t, struct hostent *));
@


1.31
log
@Use pidfile() instead of doing the equivalent thing by hand, and sometimes
forgetting to unlink the pid file at exit.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.30 2001/06/13 20:13:29 markus Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.30 2001/06/13 20:13:29 markus Exp $";
d92 7
a98 7
int    rarp_open     __P((char *));
void   init_one      __P((char *));
void   init_all      __P((void));
void   rarp_loop     __P((void));
void   lookup_addrs  __P((char *, struct if_info *));
void   usage         __P((void));
void   rarp_process  __P((struct if_info *, u_char *));
d101 4
a104 4
void   update_arptab __P((u_char *, u_int32_t));
void   err           __P((int, const char *,...));
void   debug         __P((const char *,...));
u_int32_t ipaddrtonetmask __P((u_int32_t));
d107 1
a107 1
int    rarp_bootable __P((u_int32_t));
d838 1
a838 1
int arptab_set __P((u_char *eaddr, u_int32_t host));
@


1.30
log
@more va_start/end fixes, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.29 2000/04/14 02:52:35 itojun Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.29 2000/04/14 02:52:35 itojun Exp $";
d62 1
a66 2
#include "pathnames.h"

d177 1
a177 4
		if ((fp = fopen(_PATH_RARPDPID, "w")) != NULL) {
			fprintf(fp, "%u\n", getpid());
			(void)fclose(fp);
		}
a1015 1
		unlink(_PATH_RARPDPID);
@


1.29
log
@use getifaddrs, not SIOCGIFCONF.  #ifdef will be removed later.
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.28 1999/11/22 08:39:33 mickey Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.28 1999/11/22 08:39:33 mickey Exp $";
a997 5
#ifdef __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif
d1003 5
d1009 1
d1012 5
@


1.28
log
@fix a bug w/ choice_ipaddr() reply fine, but the loop goes on.
in other words, loop variable might get null on the list end while
scoring variable still has the right value, which caused NULL to get
passed into rarpd_reply() in ia arg, causing coredumps deeper in.
no big deal, fixed; d@@ looked over.
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.27 1999/10/29 07:27:40 niklas Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.27 1999/10/29 07:27:40 niklas Exp $";
d62 3
d249 22
d330 1
d681 59
d839 1
@


1.27
log
@Allow RARP on aliased interfaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.26 1999/08/09 16:55:57 niklas Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.26 1999/08/09 16:55:57 niklas Exp $";
d624 1
a624 2
	for (target_ipaddr = 0, ia = ii->ii_addrs; target_ipaddr == 0 && ia;
	     ia = ia->ia_next)
d627 3
@


1.26
log
@Fixup interface walking, and do not be upset when seeing non-ethernet ifs
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.25 1999/02/04 00:23:48 millert Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.25 1999/02/04 00:23:48 millert Exp $";
d69 1
a69 1
 * The structure for each interface.
d71 6
d80 2
a81 3
	u_char  ii_eaddr[6];		/* Ethernet address of this interface */
	u_int32_t ii_ipaddr;		/* IP address of this interface */
	u_int32_t ii_netmask;		/* subnet or net mask */
d94 1
a94 2
void   lookup_eaddr  __P((char *, u_char *));
void   lookup_ipaddr __P((char *, u_int32_t *, u_int32_t *));
d97 2
a98 2
void   rarp_reply    __P((struct if_info *, struct ether_header *, u_int32_t,
	struct hostent *));
d216 1
a216 1
	for(p = iflist; p; p = p->ii_next)
d235 2
a236 2
	lookup_eaddr(ifname, p->ii_eaddr);
	lookup_ipaddr(ifname, &p->ii_ipaddr, &p->ii_netmask);
d604 1
d624 4
a627 2
	target_ipaddr = choose_ipaddr((u_int32_t **) hp->h_addr_list,
	    ii->ii_ipaddr & ii->ii_netmask, ii->ii_netmask);
d630 5
a634 3
		in.s_addr = ii->ii_ipaddr & ii->ii_netmask;
		err(NONFATAL, "cannot find %s on net %s",
		    ename, inet_ntoa(in));
d640 1
a640 1
		rarp_reply(ii, ep, target_ipaddr, hp);
d643 1
d649 1
a649 1
lookup_eaddr(ifname, eaddr)
d651 1
a651 1
	u_char *eaddr;
d653 2
d657 2
a658 1
	struct ifreq *ifr;
d661 1
a661 1
	int i, len, inlen = 8192;
d680 1
a680 1
			err(FATAL, "lookup_eaddr: malloc: %s",
d687 1
a687 1
			err(FATAL, "lookup_eaddr: SIOCGIFCONF: %s",
a701 4
		sdl = (struct sockaddr_dl *)&ifr->ifr_addr;
		if (sdl->sdl_family != AF_LINK || sdl->sdl_type != IFT_ETHER ||
		    sdl->sdl_alen != 6)
			continue;
d703 43
a745 7
			memcpy((caddr_t)eaddr, (caddr_t)LLADDR(sdl), 6);
			if (dflag)
				fprintf(stderr, "%s: %x:%x:%x:%x:%x:%x\n",
				    ifr->ifr_name, eaddr[0], eaddr[1],
				    eaddr[2], eaddr[3], eaddr[4], eaddr[5]);
			free(inbuf);
			return;
d750 2
a751 37
	err(FATAL, "lookup_eaddr: Never saw interface `%s'!", ifname);
}
/*
 * Lookup the IP address and network mask of the interface named 'ifname'.
 */
void
lookup_ipaddr(ifname, addrp, netmaskp)
	char   *ifname;
	u_int32_t *addrp;
	u_int32_t *netmaskp;
{
	int     fd;
	struct ifreq ifr;

	/* Use datagram socket to get IP address. */
	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		err(FATAL, "socket: %s", strerror(errno));
		/* NOTREACHED */
	}
	(void) strncpy(ifr.ifr_name, ifname, sizeof ifr.ifr_name);
	if (ioctl(fd, SIOCGIFADDR, (char *) &ifr) < 0) {
		err(FATAL, "SIOCGIFADDR: %s", strerror(errno));
		/* NOTREACHED */
	}
	*addrp = ((struct sockaddr_in *) & ifr.ifr_addr)->sin_addr.s_addr;
	if (ioctl(fd, SIOCGIFNETMASK, (char *) &ifr) < 0) {
		perror("SIOCGIFNETMASK");
		unlink(_PATH_RARPDPID);
		exit(1);
	}
	*netmaskp = ((struct sockaddr_in *) & ifr.ifr_addr)->sin_addr.s_addr;
	/* If SIOCGIFNETMASK didn't work, figure out a mask from the IP
	 * address class. */
	if (*netmaskp == 0)
		*netmaskp = ipaddrtonetmask(*addrp);

	(void) close(fd);
d834 1
a834 1
rarp_reply(ii, ep, ipaddr, hp)
d836 1
d859 1
a859 1
	memcpy((char *) ap->arp_spa, (char *) &ii->ii_ipaddr, 4);
@


1.25
log
@Use ether_ntoa() instead of doing the equivalent by hand
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.24 1999/02/03 23:14:15 millert Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.24 1999/02/03 23:14:15 millert Exp $";
d245 1
d267 2
a268 1
			err(FATAL, "init_all: SIOCGIFCONF: %s", strerror(errno));
d283 5
d667 2
a668 1
			err(FATAL, "init_all: malloc: %s", strerror(errno));
d674 2
a675 1
			err(FATAL, "init_all: SIOCGIFCONF: %s", strerror(errno));
d686 3
a688 1
		len = sizeof(ifr->ifr_name) + ifr->ifr_addr.sa_len;
@


1.24
log
@Add more debugging info via -d; m4@@umn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.23 1998/08/15 17:25:32 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.23 1998/08/15 17:25:32 deraadt Exp $";
d588 1
d595 1
d597 2
a598 4
	debug("ethernet address=0x%-2.2x:%-2.2x:%-2.2x:%-2.2x:%-2.2x:%-2.2x",
		 ep->ether_shost[0], ep->ether_shost[1], ep->ether_shost[2],
		 ep->ether_shost[3], ep->ether_shost[4], ep->ether_shost[5]);
	if (ether_ntohost(ename, (struct ether_addr *)&ep->ether_shost) != 0) {
@


1.23
log
@realloc misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.22 1998/07/27 04:34:36 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.22 1998/07/27 04:34:36 deraadt Exp $";
d595 5
a599 2
	if (ether_ntohost(ename, (struct ether_addr *)&ep->ether_shost) != 0 ||
	    (hp = gethostbyname(ename)) == 0)
d601 5
d625 1
@


1.22
log
@fix usage
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.21 1998/07/13 06:58:48 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.21 1998/07/13 06:58:48 deraadt Exp $";
d242 1
a242 1
	char *inbuf = NULL;
d255 4
a258 2
		ifc.ifc_buf = inbuf = realloc(inbuf, inlen);
		if (inbuf == NULL) {
d262 1
d627 1
a627 1
	char *inbuf = NULL;
d646 4
a649 2
		ifc.ifc_buf = inbuf = realloc(inbuf, inlen);
		if (inbuf == NULL) {
d653 1
@


1.21
log
@boring stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.20 1998/07/07 17:29:49 art Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.20 1998/07/07 17:29:49 art Exp $";
d296 2
a297 2
	(void) fprintf(stderr, "usage: rarpd -a [ -d -f ]\n");
	(void) fprintf(stderr, "       rarpd [ -d -f ] interface\n");
@


1.20
log
@fd_set is not a struct
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.19 1998/05/03 22:49:09 d Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.19 1998/05/03 22:49:09 d Exp $";
d306 1
a306 1
	char    device[sizeof "/dev/bpf000"];
d310 1
a310 1
		(void) sprintf(device, "/dev/bpf%d", n++);
d532 1
a532 1
	char    ipname[9];
d535 1
a535 1
	(void) sprintf(ipname, "%08X", addr);
@


1.19
log
@don't lose errors from socket()
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.18 1998/04/25 06:29:53 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.18 1998/04/25 06:29:53 deraadt Exp $";
d470 2
a471 2
		if (select(maxfd + 1, lfdsp, (struct fd_set *) 0,
			(struct fd_set *) 0, (struct timeval *) 0) < 0) {
@


1.18
log
@logging to syslogd on -l flag; netbsd
create /var/run/rarpd.pid if running
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.17 1998/03/23 04:18:41 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.17 1998/03/23 04:18:41 deraadt Exp $";
d751 7
a757 2
	if (ioctl(s, SIOCSARP, (caddr_t) & request) < 0) {
		err(NONFATAL, "SIOCSARP: %s", strerror(errno));
a758 1
	(void) close(s);
@


1.17
log
@cleanup for -Wall; fix routed+rarpd interaction pointed out by
Pierre.Beyssac@@hsc.fr; and fix a buglet of greek origin.
@
text
@d1 2
a2 2
/*	$OpenBSD: rarpd.c,v 1.16 1997/12/17 08:55:22 deraadt Exp $ */
/*	$NetBSD: rarpd.c,v 1.12 1996/03/21 18:28:23 jtc Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.16 1997/12/17 08:55:22 deraadt Exp $";
d38 2
a39 2
 * Usage:	rarpd -a [ -d -f ]
 *		rarpd [ -d -f ] interface
d63 2
d93 2
a94 1
void   rarp_reply    __P((struct if_info *, struct ether_header *, u_int32_t));
d107 1
d124 1
a124 1
	while ((op = getopt(argc, argv, "adf")) != -1) {
d138 4
d158 2
d169 7
d479 1
a479 1
	again:
d613 1
a613 1
		rarp_reply(ii, ep, target_ipaddr);
d706 1
d794 1
a794 1
rarp_reply(ii, ep, ipaddr)
d798 1
d820 8
d884 2
a885 1
	if (fatal)
d887 1
@


1.16
log
@do not overflow fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.15 1997/09/18 08:05:47 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.15 1997/09/18 08:05:47 deraadt Exp $";
d111 2
a112 2
	char   *ifname, *hostname, *name;

a115 7
	if ((name = strrchr(argv[0], '/')))
		++name;
	else
		name = argv[0];
	if (*name == '-')
		++name;

d117 1
a117 1
	openlog(name, LOG_PID | LOG_CONS, LOG_DAEMON);
d395 1
a395 1
	if (bcmp((char *) &ep->ether_shost, (char *) &ap->arp_sha, 6) != 0) {
d399 1
a399 1
	if (bcmp((char *) &ap->arp_sha, (char *) &ap->arp_tha, 6) != 0) {
d651 1
a651 1
			bcopy((caddr_t)LLADDR(sdl), (caddr_t)eaddr, 6);
d730 1
a730 1
	bcopy((char *) ep, (char *) request.arp_ha.sa_data, 6);
d793 3
a795 3
	bcopy((char *) &ap->arp_sha, (char *) &ep->ether_dhost, 6);
	bcopy((char *) ii->ii_eaddr, (char *) &ep->ether_shost, 6);
	bcopy((char *) ii->ii_eaddr, (char *) &ap->arp_sha, 6);
d797 1
a797 1
	bcopy((char *) &ipaddr, (char *) ap->arp_tpa, 4);
d799 1
a799 1
	bcopy((char *) &ii->ii_ipaddr, (char *) ap->arp_spa, 4);
@


1.15
log
@more SIOCGIFCONF small worldedness
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.14 1997/09/17 21:10:10 niklas Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.14 1997/09/17 21:10:10 niklas Exp $";
d422 2
a423 1
	fd_set  fds, listeners;
d444 1
a444 3
	FD_ZERO(&fds);
	for (ii = iflist; ii; ii = ii->ii_next) {
		FD_SET(ii->ii_fd, &fds);
d447 11
a457 1
	}
d459 2
a460 2
		listeners = fds;
		if (select(maxfd + 1, &listeners, (struct fd_set *) 0,
d467 1
a467 1
			if (!FD_ISSET(fd, &listeners))
d501 2
@


1.14
log
@If sa_len >sizeof(struct sockaddr) limit it there.  Taken from ifconfig(8),
Also enhance the SIOCGIFFLAGS error message with the interface name.
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.13 1997/09/12 04:07:20 millert Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.13 1997/09/12 04:07:20 millert Exp $";
d603 1
a603 1
	char inbuf[8192];
d608 1
a608 1
	int i, len;
d620 16
a635 6
	ifc.ifc_len = sizeof(inbuf);
	ifc.ifc_buf = inbuf;
	if (ioctl(fd, SIOCGIFCONF, (caddr_t)&ifc) < 0 ||
	    ifc.ifc_len < sizeof(struct ifreq)) {
		err(FATAL, "lookup_eaddr: SIOGIFCONF: %s", strerror(errno));
		/* NOTREACHED */
d637 1
d652 1
d657 1
@


1.13
log
@Kill extra newline in err()/warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.12 1997/08/18 03:11:32 millert Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.12 1997/08/18 03:11:32 millert Exp $";
d264 4
a267 1
		len = sizeof(ifr->ifr_name) + ifr->ifr_addr.sa_len;
d270 2
a271 2
			err(FATAL, "init_all: SIOCGIFFLAGS: %s",
			    strerror(errno));
@


1.12
log
@#include <string.h> not <strings.h> -- Yes, I'm a weanie...
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.11 1997/07/25 20:12:18 mickey Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.11 1997/07/25 20:12:18 mickey Exp $";
d582 1
a582 1
		err(NONFATAL, "cannot find %s on net %s\n",
@


1.11
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.10 1997/06/22 22:56:34 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.10 1997/06/22 22:56:34 deraadt Exp $";
a45 1
#include <strings.h>
@


1.10
log
@MAXHOSTNAMELEN
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.9 1997/03/29 04:01:58 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.9 1997/03/29 04:01:58 deraadt Exp $";
d806 1
a806 1
#if __STDC__
d813 1
a813 1
#if __STDC__
d823 1
a823 1
#if __STDC__
d844 1
a844 1
#if __STDC__
d855 1
a855 1
#if __STDC__
@


1.9
log
@take a shot at 64-bit clean
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.8 1997/02/05 13:41:04 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.8 1997/02/05 13:41:04 deraadt Exp $";
d564 1
a564 1
	char    ename[256];
@


1.8
log
@for -a, survive existance of non-ethernet non-pointtopoint interfaces, Jean-Luc.Richier@@imag.fr
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.7 1997/01/22 09:22:01 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.7 1997/01/22 09:22:01 deraadt Exp $";
d74 2
a75 2
	u_long  ii_ipaddr;		/* IP address of this interface */
	u_long  ii_netmask;		/* subnet or net mask */
d89 1
a89 1
void   lookup_ipaddr __P((char *, u_long *, u_long *));
d92 2
a93 2
void   rarp_reply    __P((struct if_info *, struct ether_header *, u_long));
void   update_arptab __P((u_char *, u_long));
d96 1
a96 1
u_long ipaddrtonetmask __P((u_long));
d99 1
a99 1
int    rarp_bootable __P((u_long));
d505 1
a505 1
	u_long  addr;
d540 1
a540 1
u_long
d542 3
a544 3
	u_long **alist;
	u_long  net;
	u_long  netmask;
d563 1
a563 1
	u_long  target_ipaddr;
d578 1
a578 1
	target_ipaddr = choose_ipaddr((u_long **) hp->h_addr_list,
d651 2
a652 2
	u_long *addrp;
	u_long *netmaskp;
d681 1
a681 1
int arptab_set __P((u_char *eaddr, u_long host));
d692 1
a692 1
	u_long  ipaddr;
d700 1
a700 1
	u_long host;
d760 1
a760 1
	u_long  ipaddr;
d792 1
a792 1
u_long
d794 1
a794 1
	u_long  addr;
@


1.7
log
@SIOCGIFCONF nicely
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.6 1997/01/15 23:44:15 millert Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.6 1997/01/15 23:44:15 millert Exp $";
d200 1
d207 4
d216 1
d220 1
a220 1
	p->ii_fd = rarp_open(ifname);
d345 4
d359 4
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.5 1996/08/12 23:42:12 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.5 1996/08/12 23:42:12 deraadt Exp $";
d227 1
a227 1
	char inbuf[8192];
d230 1
a230 1
	int fd;
d238 16
a253 6
	ifc.ifc_len = sizeof(inbuf);
	ifc.ifc_buf = inbuf;
	if (ioctl(fd, SIOCGIFCONF, (caddr_t)&ifc) < 0 ||
	    ifc.ifc_len < sizeof(struct ifreq)) {
		err(FATAL, "init_all: SIOCGIFCONF: %s", strerror(errno));
		/* NOTREACHED */
d255 1
d261 1
d271 1
@


1.5
log
@cleanup protos and such
@
text
@d1 1
a1 1
/*	$OpenBSD: rarpd.c,v 1.4 1996/06/25 15:13:50 deraadt Exp $ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.4 1996/06/25 15:13:50 deraadt Exp $";
d128 1
a128 1
	while ((op = getopt(argc, argv, "adf")) != EOF) {
@


1.4
log
@only open one bpf per interface; netbsd pr#2106; codewarrior@@daemon.org
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d31 1
a31 1
static char rcsid[] = "$OpenBSD: rarpd.c,v 1.2 1995/11/15 07:04:09 deraadt Exp $";
d117 1
a117 1
	if (name = strrchr(argv[0], '/'))
d188 1
d190 1
d542 1
a542 1
	if (ether_ntohost(ename, &ep->ether_shost) != 0 ||
d653 3
d671 3
@


1.3
log
@sync to netbsd 960418
@
text
@d71 5
a75 4
	int     ii_fd;		/* BPF file descriptor */
	u_char  ii_eaddr[6];	/* Ethernet address of this interface */
	u_long  ii_ipaddr;	/* IP address of this interface */
	u_long  ii_netmask;	/* subnet or net mask */
d199 5
d213 1
@


1.2
log
@rarpd can once again set arp entries on the local host; from freebsd
@
text
@d1 3
d31 1
a31 2
static char rcsid[] =
"@@(#) $Id: rarpd.c,v 1.1.1.1 1995/10/18 08:48:02 deraadt Exp $";
d105 1
a105 1
void
@


1.1
log
@Initial revision
@
text
@d29 1
a29 1
"@@(#) $Id: rarpd.c,v 1.8 1995/09/01 21:55:47 thorpej Exp $";
d653 1
a668 1
#if 0
d674 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
