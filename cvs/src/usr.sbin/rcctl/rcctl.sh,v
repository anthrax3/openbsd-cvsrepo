head	1.106;
access;
symbols
	OPENBSD_6_2:1.106.0.4
	OPENBSD_6_2_BASE:1.106
	OPENBSD_6_1:1.105.0.4
	OPENBSD_6_1_BASE:1.105
	OPENBSD_6_0:1.103.0.2
	OPENBSD_6_0_BASE:1.103
	OPENBSD_5_9:1.88.0.2
	OPENBSD_5_9_BASE:1.88
	OPENBSD_5_8:1.78.0.4
	OPENBSD_5_8_BASE:1.78
	OPENBSD_5_7:1.66.0.2
	OPENBSD_5_7_BASE:1.66;
locks; strict;
comment	@# @;


1.106
date	2017.05.30.12.04.27;	author tb;	state Exp;
branches;
next	1.105;
commitid	10TzgqVCDGumO7GM;

1.105
date	2016.09.07.13.13.13;	author ajacoutot;	state Exp;
branches;
next	1.104;
commitid	HVprWhUkyOMmsnVL;

1.104
date	2016.07.30.06.25.21;	author ajacoutot;	state Exp;
branches;
next	1.103;
commitid	zMVkxk3JPpa5Z4ro;

1.103
date	2016.07.19.08.28.03;	author sthen;	state Exp;
branches;
next	1.102;
commitid	L42tuc3U2AUaTByV;

1.102
date	2016.06.19.15.00.37;	author ajacoutot;	state Exp;
branches;
next	1.101;
commitid	eTtpTIZtQrOt7Ukk;

1.101
date	2016.06.19.11.32.25;	author ajacoutot;	state Exp;
branches;
next	1.100;
commitid	YArTXUekkarx74Zc;

1.100
date	2016.06.19.11.14.20;	author ajacoutot;	state Exp;
branches;
next	1.99;
commitid	GPsIBTUhl9hyDTV0;

1.99
date	2016.06.19.10.54.20;	author ajacoutot;	state Exp;
branches;
next	1.98;
commitid	cYadOGpG6No2SVsV;

1.98
date	2016.06.19.10.50.27;	author ajacoutot;	state Exp;
branches;
next	1.97;
commitid	7uzfyQ9ybOSevHvt;

1.97
date	2016.06.19.10.46.08;	author ajacoutot;	state Exp;
branches;
next	1.96;
commitid	EYywgWDTceTgr8rh;

1.96
date	2016.06.17.11.24.58;	author ajacoutot;	state Exp;
branches;
next	1.95;
commitid	LD34a377ZboPMYw7;

1.95
date	2016.04.26.18.39.29;	author ajacoutot;	state Exp;
branches;
next	1.94;
commitid	PJ4xn85FNOyxlLX0;

1.94
date	2016.04.26.17.58.42;	author ajacoutot;	state Exp;
branches;
next	1.93;
commitid	wcKESoQAakspGb4F;

1.93
date	2016.04.09.08.02.22;	author ajacoutot;	state Exp;
branches;
next	1.92;
commitid	Yii71L6JtBbXAYRE;

1.92
date	2016.04.01.08.18.57;	author ajacoutot;	state Exp;
branches;
next	1.91;
commitid	u5ex1puxVA4hDZRY;

1.91
date	2016.03.28.08.10.19;	author ajacoutot;	state Exp;
branches;
next	1.90;
commitid	lYbG3RVmDybbRBS2;

1.90
date	2016.03.27.13.11.33;	author ajacoutot;	state Exp;
branches;
next	1.89;
commitid	ZU51tbe8ryyzZt04;

1.89
date	2016.03.27.13.06.00;	author ajacoutot;	state Exp;
branches;
next	1.88;
commitid	zVI61434SBtNk13z;

1.88
date	2016.01.24.08.51.50;	author ajacoutot;	state Exp;
branches;
next	1.87;
commitid	XTvDrEE6L0c3LDBH;

1.87
date	2015.12.06.14.24.48;	author mpi;	state Exp;
branches;
next	1.86;
commitid	XGhJaPC9eOsfGRUe;

1.86
date	2015.11.29.15.58.59;	author ajacoutot;	state Exp;
branches;
next	1.85;
commitid	cKnIbezqQ4jQBisz;

1.85
date	2015.11.01.10.59.23;	author ajacoutot;	state Exp;
branches;
next	1.84;
commitid	fyz6D4vMA39PK4j5;

1.84
date	2015.10.31.11.09.41;	author ajacoutot;	state Exp;
branches;
next	1.83;
commitid	LB5ZnD02xNkcKksU;

1.83
date	2015.10.24.13.57.24;	author ajacoutot;	state Exp;
branches;
next	1.82;
commitid	xBhyabk6ONmONtJz;

1.82
date	2015.10.06.18.46.05;	author schwarze;	state Exp;
branches;
next	1.81;
commitid	peSkLa2o7xANIMJI;

1.81
date	2015.10.04.13.38.11;	author ajacoutot;	state Exp;
branches;
next	1.80;
commitid	Ey0euxtCfCCTN7Dz;

1.80
date	2015.10.03.10.39.21;	author ajacoutot;	state Exp;
branches;
next	1.79;
commitid	UbKWKTnqGWOn2tce;

1.79
date	2015.08.12.06.28.18;	author ajacoutot;	state Exp;
branches;
next	1.78;
commitid	cjQYjxx9lgFZI3zz;

1.78
date	2015.08.03.13.18.48;	author ajacoutot;	state Exp;
branches;
next	1.77;
commitid	cjwFcYTejF6vPfFp;

1.77
date	2015.08.01.11.28.14;	author ajacoutot;	state Exp;
branches;
next	1.76;
commitid	QuQO3Gozh2X12aw6;

1.76
date	2015.07.25.04.12.43;	author ajacoutot;	state Exp;
branches;
next	1.75;
commitid	MjcQEEzvG5XAncd7;

1.75
date	2015.07.17.18.00.43;	author ajacoutot;	state Exp;
branches;
next	1.74;
commitid	bkYvpkpvttHBBGRc;

1.74
date	2015.07.16.23.05.12;	author ajacoutot;	state Exp;
branches;
next	1.73;
commitid	UCCn2Y3hCfm74FMY;

1.73
date	2015.07.16.22.03.02;	author ajacoutot;	state Exp;
branches;
next	1.72;
commitid	Sec8HQgrxAWitMx8;

1.72
date	2015.07.16.21.52.16;	author ajacoutot;	state Exp;
branches;
next	1.71;
commitid	tZbjGdZvPH28aIur;

1.71
date	2015.07.15.04.19.41;	author ajacoutot;	state Exp;
branches;
next	1.70;
commitid	yxBpeXp3UAKZbYBW;

1.70
date	2015.07.15.03.00.46;	author ajacoutot;	state Exp;
branches;
next	1.69;
commitid	RjVLF6tzxGU9ksvg;

1.69
date	2015.07.14.23.16.56;	author ajacoutot;	state Exp;
branches;
next	1.68;
commitid	7OYOUh5nldN4YZwq;

1.68
date	2015.03.28.08.08.52;	author ajacoutot;	state Exp;
branches;
next	1.67;
commitid	FPwgNcfzYCwXI5HE;

1.67
date	2015.03.28.07.41.46;	author ajacoutot;	state Exp;
branches;
next	1.66;
commitid	G1UTMJrmNOCiMxly;

1.66
date	2015.03.02.06.58.42;	author ajacoutot;	state Exp;
branches;
next	1.65;
commitid	1CzOaVoUpxH4J1Jv;

1.65
date	2015.03.01.18.38.05;	author sebastia;	state Exp;
branches;
next	1.64;
commitid	LMU9hzJKqM9DFugp;

1.64
date	2015.01.18.10.29.53;	author ajacoutot;	state Exp;
branches;
next	1.63;
commitid	Sk7RxVNFQbQQQQdN;

1.63
date	2015.01.12.14.40.35;	author ajacoutot;	state Exp;
branches;
next	1.62;
commitid	Yr1XuB2DBI6s80ZN;

1.62
date	2015.01.12.13.51.20;	author ajacoutot;	state Exp;
branches;
next	1.61;
commitid	nLBce60QISL56yAg;

1.61
date	2015.01.12.13.40.12;	author ajacoutot;	state Exp;
branches;
next	1.60;
commitid	C9x0pTyfVlvsqBa3;

1.60
date	2015.01.08.13.29.34;	author ajacoutot;	state Exp;
branches;
next	1.59;
commitid	fz3tZZXQM01v0lYO;

1.59
date	2015.01.06.14.48.59;	author ajacoutot;	state Exp;
branches;
next	1.58;
commitid	h2gWiYgSC35YGuhK;

1.58
date	2015.01.06.12.49.55;	author ajacoutot;	state Exp;
branches;
next	1.57;
commitid	4cfAW882JCEZja6C;

1.57
date	2015.01.06.12.27.42;	author ajacoutot;	state Exp;
branches;
next	1.56;
commitid	j4AwbhzHPdPH3zCM;

1.56
date	2015.01.06.11.47.50;	author ajacoutot;	state Exp;
branches;
next	1.55;
commitid	OpPRRpwA3cpAHfnu;

1.55
date	2015.01.01.09.44.20;	author ajacoutot;	state Exp;
branches;
next	1.54;
commitid	1zOARzvF1kp0sf72;

1.54
date	2014.12.30.15.33.53;	author ajacoutot;	state Exp;
branches;
next	1.53;
commitid	GPNAVjqA44xaH972;

1.53
date	2014.12.30.15.31.33;	author robert;	state Exp;
branches;
next	1.52;
commitid	DrISivzkmSPBAj4f;

1.52
date	2014.12.30.14.46.33;	author ajacoutot;	state Exp;
branches;
next	1.51;
commitid	U30Oqazqah5BldsI;

1.51
date	2014.12.24.13.04.43;	author ajacoutot;	state Exp;
branches;
next	1.50;
commitid	8Il3Ss79EtWtXb6k;

1.50
date	2014.12.23.10.07.44;	author ajacoutot;	state Exp;
branches;
next	1.49;
commitid	qSKlhq9tiMnxAX0Q;

1.49
date	2014.11.01.13.59.42;	author ajacoutot;	state Exp;
branches;
next	1.48;
commitid	gzi9HxhNMMryVMvv;

1.48
date	2014.10.31.09.07.48;	author ajacoutot;	state Exp;
branches;
next	1.47;
commitid	t78OE5alZDi00ot1;

1.47
date	2014.10.31.09.04.08;	author ajacoutot;	state Exp;
branches;
next	1.46;
commitid	ilfX5de1aHW4fei6;

1.46
date	2014.10.27.21.24.26;	author rpe;	state Exp;
branches;
next	1.45;
commitid	IKLBlTOftGXodHP1;

1.45
date	2014.10.15.07.38.24;	author ajacoutot;	state Exp;
branches;
next	1.44;
commitid	JbJsI63IFRXg5DN6;

1.44
date	2014.10.13.19.06.53;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	T5ZVOHHlSHt9JmBo;

1.43
date	2014.10.11.19.12.19;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	y8HI2ctbzsUiwSP9;

1.42
date	2014.10.11.13.42.49;	author ajacoutot;	state Exp;
branches;
next	1.41;
commitid	uBr8dJGDbeBOEk6x;

1.41
date	2014.10.10.15.59.36;	author ajacoutot;	state Exp;
branches;
next	1.40;
commitid	TESQikP6jnWFXkG4;

1.40
date	2014.10.10.15.42.30;	author ajacoutot;	state Exp;
branches;
next	1.39;
commitid	vWyoAJtv3UWkxkEw;

1.39
date	2014.10.10.07.27.44;	author ajacoutot;	state Exp;
branches;
next	1.38;
commitid	8HURsTGfFrPP1s98;

1.38
date	2014.09.01.18.01.55;	author ajacoutot;	state Exp;
branches;
next	1.37;
commitid	FYgUodnKDVM4gUlx;

1.37
date	2014.08.31.10.44.37;	author ajacoutot;	state Exp;
branches;
next	1.36;
commitid	l0QEEQZJb96fswsI;

1.36
date	2014.08.31.07.08.25;	author ajacoutot;	state Exp;
branches;
next	1.35;
commitid	Eb8XOyUMeu4drocL;

1.35
date	2014.08.30.20.37.46;	author ajacoutot;	state Exp;
branches;
next	1.34;
commitid	ZXek4I17r0FXLBUG;

1.34
date	2014.08.29.21.04.37;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	7HPKrwFpOrpuw7Pm;

1.33
date	2014.08.29.20.21.13;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	mWVqAExFQNadZNrN;

1.32
date	2014.08.28.14.51.16;	author ajacoutot;	state Exp;
branches;
next	1.31;
commitid	lVuVHGMEUjJiWiw8;

1.31
date	2014.08.28.07.53.07;	author ajacoutot;	state Exp;
branches;
next	1.30;
commitid	XnuKMOrwacZEYbud;

1.30
date	2014.08.28.06.52.57;	author ajacoutot;	state Exp;
branches;
next	1.29;
commitid	t6p33b5c4zRFqiep;

1.29
date	2014.08.27.23.50.45;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	Wp9lFqvVyv79JgER;

1.28
date	2014.08.26.22.39.09;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	8P8ryCAKLIk3JqNZ;

1.27
date	2014.08.25.23.15.37;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	UFOSnTeC8wDV34XZ;

1.26
date	2014.08.25.21.34.34;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	UdPVV6JagBzSQP3u;

1.25
date	2014.08.25.21.06.46;	author ajacoutot;	state Exp;
branches;
next	1.24;
commitid	LiS2AoKMcZtOHkMn;

1.24
date	2014.08.25.19.01.26;	author ajacoutot;	state Exp;
branches;
next	1.23;
commitid	ijTiIiqtcl7zrMYt;

1.23
date	2014.08.25.18.50.22;	author ajacoutot;	state Exp;
branches;
next	1.22;
commitid	WFotk5jxFtrclpOb;

1.22
date	2014.08.25.14.29.18;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	MZGJ8NQ9zE95zjnc;

1.21
date	2014.08.25.07.35.37;	author ajacoutot;	state Exp;
branches;
next	1.20;
commitid	WVclxGQXDYQSrhjV;

1.20
date	2014.08.24.19.44.02;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	2TN516OFcMgxshOB;

1.19
date	2014.08.24.19.00.46;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	k228MFGAvwOw5U1k;

1.18
date	2014.08.24.18.10.26;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	FpTOPRwBDkgG8Gqg;

1.17
date	2014.08.24.17.52.38;	author ajacoutot;	state Exp;
branches;
next	1.16;
commitid	GdYVfyFT34RT1t1w;

1.16
date	2014.08.24.17.01.44;	author ajacoutot;	state Exp;
branches;
next	1.15;
commitid	S4ixjKLkkcNdbpVy;

1.15
date	2014.08.24.13.46.57;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	ER1vGyvDJGpbK1gi;

1.14
date	2014.08.24.08.13.15;	author ajacoutot;	state Exp;
branches;
next	1.13;
commitid	oRKeBRNSPloEbsQ6;

1.13
date	2014.08.24.07.46.54;	author ajacoutot;	state Exp;
branches;
next	1.12;
commitid	RiNL4XVv0qyaXs6r;

1.12
date	2014.08.24.07.33.26;	author ajacoutot;	state Exp;
branches;
next	1.11;
commitid	lsbRcZMiAAkNWJ2i;

1.11
date	2014.08.21.14.26.16;	author jsg;	state Exp;
branches;
next	1.10;
commitid	GvWN3VDje4zAgY3V;

1.10
date	2014.08.21.12.47.22;	author ajacoutot;	state Exp;
branches;
next	1.9;
commitid	RUUoF1ATEdgHPtHE;

1.9
date	2014.08.21.08.54.58;	author ajacoutot;	state Exp;
branches;
next	1.8;
commitid	NeNnnVGhGjF9bHW0;

1.8
date	2014.08.20.17.15.17;	author rpe;	state Exp;
branches;
next	1.7;
commitid	mS9IeuiD6l1qfmNf;

1.7
date	2014.08.20.15.04.14;	author ajacoutot;	state Exp;
branches;
next	1.6;
commitid	XtRSx7CQ0lvWy6oX;

1.6
date	2014.08.20.13.23.56;	author ajacoutot;	state Exp;
branches;
next	1.5;
commitid	gXegUntQ4wYtoHv9;

1.5
date	2014.08.20.07.55.45;	author rpointel;	state Exp;
branches;
next	1.4;
commitid	G15dSpFGGWGT7vmI;

1.4
date	2014.08.19.17.51.05;	author ajacoutot;	state Exp;
branches;
next	1.3;
commitid	5UudAP3Qr9uEHzz3;

1.3
date	2014.08.19.16.47.18;	author ajacoutot;	state Exp;
branches;
next	1.2;
commitid	i2hTiEguLciFsJsE;

1.2
date	2014.08.19.15.26.18;	author ajacoutot;	state Exp;
branches;
next	1.1;
commitid	nOgLvHc7ItKq0KJF;

1.1
date	2014.08.19.14.08.20;	author ajacoutot;	state Exp;
branches;
next	;
commitid	mpurVxj2DZYZZkdt;


desc
@@


1.106
log
@Introduce a scary rc.conf(8) knob library_aslr=(YES|NO) to turn off the
reordering of libraries by rc(8). This way machines with very slow disk I/O
have a chance of booting within reasonable time now that libcrypto is also
randomized.

Discussed with various;
input & ok from deraadt ajacoutot
@
text
@#!/bin/ksh
#
# $OpenBSD: rcctl.sh,v 1.105 2016/09/07 13:13:13 ajacoutot Exp $
#
# Copyright (c) 2014, 2015 Antoine Jacoutot <ajacoutot@@openbsd.org>
# Copyright (c) 2014 Ingo Schwarze <schwarze@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

_special_svcs="accounting check_quotas ipsec library_aslr multicast pf
               spamd_black"
readonly _special_svcs

# get local functions from rc.subr(8)
FUNCS_ONLY=1
. /etc/rc.d/rc.subr
_rc_parse_conf

usage()
{
	local _a _i
	for _i in ${_rc_actions}; do _a="$(echo -n ${_i}${_a:+|${_a}})"; done

	_rc_err \
	"usage:	rcctl get|getdef|set service | daemon [variable [arguments]]
	rcctl [-df] ${_a} daemon ...
	rcctl disable|enable|order [daemon ...]
	rcctl ls all|failed|off|on|started|stopped"
}

needs_root()
{
	[ "$(id -u)" -ne 0 ] && _rc_err "${0##*/}: \"$*\" needs root privileges"
}

rcctl_err()
{
	_rc_err "${0##*/}: ${1}" ${2}
}

ls_rcscripts()
{
	local _s

	cd /etc/rc.d && set -- *
	for _s; do
		[[ ${_s} = *.* ]] && continue
		[ ! -d "${_s}" ] && echo "${_s}"
	done
}

pkg_scripts_append()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	rcconf_edit_begin
	if [ -z "${pkg_scripts}" ]; then
		echo pkg_scripts="${_svc}" >>${_TMP_RCCONF}
	elif ! echo ${pkg_scripts} | grep -qw -- ${_svc}; then
		grep -v "^pkg_scripts.*=" /etc/rc.conf.local >${_TMP_RCCONF}
		echo pkg_scripts="${pkg_scripts} ${_svc}" >>${_TMP_RCCONF}
	fi
	rcconf_edit_end
}

pkg_scripts_order()
{
	local _svcs="$*"
	[ -n "${_svcs}" ] || return

	needs_root ${action}
	local _pkg_scripts _svc
	for _svc in ${_svcs}; do
		if svc_is_base ${_svc} || svc_is_special ${_svc}; then
			rcctl_err "${_svc} is not a pkg script"
		elif ! svc_get ${_svc} status; then
			rcctl_err "${_svc} is not enabled"
		fi
	done
	_pkg_scripts=$(echo "${_svcs} ${pkg_scripts}" | tr "[:blank:]" "\n" | \
		     awk -v ORS=' ' '!x[$0]++')
	rcconf_edit_begin
	grep -v "^pkg_scripts.*=" /etc/rc.conf.local >${_TMP_RCCONF}
	echo pkg_scripts=${_pkg_scripts} >>${_TMP_RCCONF}
	rcconf_edit_end
}

pkg_scripts_rm()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	[ -z "${pkg_scripts}" ] && return

	rcconf_edit_begin
	sed "/^pkg_scripts[[:>:]]/{s/[[:<:]]${_svc}[[:>:]]//g
	    s/['\"]//g;s/ *= */=/;s/   */ /g;s/ $//;/=$/d;}" \
	    /etc/rc.conf.local >${_TMP_RCCONF}
	rcconf_edit_end
}

rcconf_edit_begin()
{
	_TMP_RCCONF=$(mktemp -p /etc -t rc.conf.local.XXXXXXXXXX) || \
		rcctl_err "cannot create temporary file under /etc"
	if [ -f /etc/rc.conf.local ]; then
		cat /etc/rc.conf.local >${_TMP_RCCONF} || \
			rcctl_err "cannot append to ${_TMP_RCCONF}"
	else
		touch /etc/rc.conf.local || \
			rcctl_err "cannot create /etc/rc.conf.local"
	fi
}

rcconf_edit_end()
{
	sort -u -o ${_TMP_RCCONF} ${_TMP_RCCONF} || \
		rcctl_err "cannot modify ${_TMP_RCCONF}"
	cat ${_TMP_RCCONF} >/etc/rc.conf.local || \
		rcctl_err "cannot append to /etc/rc.conf.local"
	if [ ! -s /etc/rc.conf.local ]; then
		rm /etc/rc.conf.local || \
			rcctl_err "cannot remove /etc/rc.conf.local"
	fi
	rm -f ${_TMP_RCCONF}
	_rc_parse_conf # reload new values
}

svc_is_avail()
{
	local _svc=$1
	_rc_check_name "${_svc}" || return

	[ -x "/etc/rc.d/${_svc}" ] && return
	svc_is_special ${_svc}
}

svc_is_base()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	local _cached _ret

	_cached=$(eval echo \${cached_svc_is_base_${_svc}})
	[ "${_cached}" ] && return "${_cached}"

	grep -qw "^${_svc}_flags" /etc/rc.conf
	_ret=$?

	set -A cached_svc_is_base_${_svc} -- ${_ret}
	return ${_ret}
}

svc_is_meta()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	local _cached _ret

	_cached=$(eval echo \${cached_svc_is_meta_${_svc}})
	[ "${_cached}" ] && return "${_cached}"

	[ -r "/etc/rc.d/${_svc}" ] && ! grep -qw "^rc_cmd" /etc/rc.d/${_svc}
	_ret=$?

	set -A cached_svc_is_meta_${_svc} -- ${_ret}
	return ${_ret}
}

svc_is_special()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	local _cached _ret

	_cached=$(eval echo \${cached_svc_is_special_${_svc}})
	[ "${_cached}" ] && return "${_cached}"

	echo ${_special_svcs} | grep -qw -- ${_svc}
	_ret=$?

	set -A cached_svc_is_special_${_svc} -- ${_ret}
	return ${_ret}
}

svc_ls()
{
	local _lsarg=$1
	[ -n "${_lsarg}" ] || return

	# we do not want to return the "status" nor the rc.d(8) script retcode
	local _ret=0 _on _svc _started

	case ${_lsarg} in
		all)
			(
				ls_rcscripts
				echo ${_special_svcs} | tr "[:blank:]" "\n"
			) | sort
			;;
		failed)
			for _svc in $(svc_ls on); do
				! svc_is_special ${_svc} && \
					! /etc/rc.d/${_svc} check >/dev/null && \
					echo ${_svc} && _ret=1
			done
			;;
		off|on)
			for _svc in $(svc_ls all); do
				svc_get ${_svc} status && _on=1
					[ "${_lsarg}" = "on" -a -n "${_on}" ] || \
						[ "${_lsarg}" = "off" -a -z "${_on}" ] && \
					echo ${_svc}
				unset _on
			done
			;;
		started|stopped)
			for _svc in $(ls_rcscripts); do
				/etc/rc.d/${_svc} check >/dev/null && _started=1
				[ "${_lsarg}" = "started" -a -n "${_started}" ] || \
					[ "${_lsarg}" = "stopped" -a -z "${_started}" ] && \
					echo ${_svc}
				unset _started
			done
			;;
		*)
			_ret=1
	esac

	return ${_ret}
}

svc_get()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	local _status=0 _val _var=$2
	local daemon_class daemon_flags daemon_rtable daemon_timeout daemon_user

	if svc_is_special ${_svc}; then
		daemon_flags="$(eval echo \${${_svc}})"
	else
		# set pkg daemon_flags to "NO" to match base svc
		if ! svc_is_base ${_svc}; then
			if ! echo ${pkg_scripts} | grep -qw -- ${_svc}; then
				daemon_flags="NO"
			fi
		fi

		if ! svc_is_meta ${_svc}; then
			# these are expensive, make sure they are explicitely requested
			if [ -z "${_var}" -o "${_var}" = "class" ]; then
				getcap -f /etc/login.conf ${_svc} 1>/dev/null 2>&1 && \
					daemon_class=${_svc}
				[ -z "${daemon_class}" ] && \
					daemon_class="$(svc_getdef ${_svc} class)"
			fi
			if [[ -z ${_var} || ${_var} == @@(flags|status) ]]; then
				[ -z "${daemon_flags}" ] && \
					daemon_flags="$(eval echo \"\${${_svc}_flags}\")"
				[ -z "${daemon_flags}" ] && \
					daemon_flags="$(svc_getdef ${_svc} flags)"
			fi
			if [ -z "${_var}" -o "${_var}" = "rtable" ]; then
				[ -z "${daemon_rtable}" ] && \
					daemon_rtable="$(eval echo \"\${${_svc}_rtable}\")"
				[ -z "${daemon_rtable}" ] && \
					daemon_rtable="$(svc_getdef ${_svc} rtable)"
			fi
			if [ -z "${_var}" -o "${_var}" = "timeout" ]; then
				[ -z "${daemon_timeout}" ] && \
					daemon_timeout="$(eval echo \"\${${_svc}_timeout}\")"
				[ -z "${daemon_timeout}" ] && \
					daemon_timeout="$(svc_getdef ${_svc} timeout)"
			fi
			if [ -z "${_var}" -o "${_var}" = "user" ]; then
				[ -z "${daemon_user}" ] && \
					daemon_user="$(eval echo \"\${${_svc}_user}\")"
				[ -z "${daemon_user}" ] && \
					daemon_user="$(svc_getdef ${_svc} user)"
			fi
		fi
	fi

	[ "${daemon_flags}" = "NO" ] && _status=1

	if [ -n "${_var}" ]; then
		[ "${_var}" = "status" ] && return ${_status}
		eval _val=\${daemon_${_var}}
		[ -z "${_val}" ] || print -r -- "${_val}"
	else
		svc_is_meta ${_svc} && return ${_status}
		if svc_is_special ${_svc}; then
			echo "${_svc}=${daemon_flags}"
		else
			echo "${_svc}_class=${daemon_class}"
			echo "${_svc}_flags=${daemon_flags}"
			echo "${_svc}_rtable=${daemon_rtable}"
			echo "${_svc}_timeout=${daemon_timeout}"
			echo "${_svc}_user=${daemon_user}"
		fi
		return ${_status}
	fi
}

# to prevent namespace pollution, only call in a subshell
svc_getdef()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	local _status=0 _val _var=$2
	local daemon_class daemon_flags daemon_rtable daemon_timeout daemon_user

	if svc_is_special ${_svc}; then
		# unconditionally parse: we always output flags and/or status
		_rc_parse_conf /etc/rc.conf
		daemon_flags="$(eval echo \${${_svc}})"
		[ "${daemon_flags}" = "NO" ] && _status=1
	else
		if ! svc_is_base ${_svc}; then
			_status=1 # all pkg_scripts are off by default
		else
			# abuse /etc/rc.conf behavior of only setting flags
			# to empty or "NO" to get our default status;
			# we'll get our default flags from the rc.d script
			[[ -z ${_var} || ${_var} == status ]] && \
				_rc_parse_conf /etc/rc.conf
			[ "$(eval echo \${${_svc}_flags})" = "NO" ] && _status=1
		fi

		if ! svc_is_meta ${_svc}; then
			rc_cmd() { }
			. /etc/rc.d/${_svc} >/dev/null 2>&1

			daemon_class=daemon
			[ -z "${daemon_rtable}" ] && daemon_rtable=0
			[ -z "${daemon_timeout}" ] && daemon_timeout=30
			[ -z "${daemon_user}" ] && daemon_user=root
		fi
	fi

	if [ -n "${_var}" ]; then
		[ "${_var}" = "status" ] && return ${_status}
		eval _val=\${daemon_${_var}}
		[ -z "${_val}" ] || print -r -- "${_val}"
	else
		svc_is_meta ${_svc} && return ${_status}
		if svc_is_special ${_svc}; then
			echo "${_svc}=${daemon_flags}"
		else
			echo "${_svc}_class=${daemon_class}"
			echo "${_svc}_flags=${daemon_flags}"
			echo "${_svc}_rtable=${daemon_rtable}"
			echo "${_svc}_timeout=${daemon_timeout}"
			echo "${_svc}_user=${daemon_user}"
		fi
		return ${_status}
	fi
}

svc_rm()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	rcconf_edit_begin
	if svc_is_special ${_svc}; then
		grep -v "^${_svc}.*=" /etc/rc.conf.local >${_TMP_RCCONF}
		( svc_getdef ${_svc} status ) && \
			echo "${_svc}=NO" >>${_TMP_RCCONF}
	else
		grep -Ev "^${_svc}_(flags|rtable|timeout|user).*=" \
			/etc/rc.conf.local >${_TMP_RCCONF}
		( svc_getdef ${_svc} status ) && \
			echo "${_svc}_flags=NO" >>${_TMP_RCCONF}
	fi
	rcconf_edit_end
}

svc_set()
{
	local _svc=$1 _var=$2
	[ -n "${_svc}" -a -n "${_var}" ] || return

	shift 2
	local _args="$*"

	# don't check if we are already enabled or disabled because rc.conf(8)
	# defaults may have changed in which case we may have a matching
	# redundant entry in rc.conf.local that we can drop
	if [ "${_var}" = "status" ]; then
		if [ "${_args}" = "on" ]; then
			_var="flags"
			# keep our flags if we're already enabled
			eval "_args=\"\${${_svc}_${_var}}\""
			[ "${_args}" = "NO" ] && unset _args
			if ! svc_is_base ${_svc} && ! svc_is_special ${_svc}; then
				pkg_scripts_append ${_svc}
			fi
		elif [ "${_args}" = "off" ]; then
			if ! svc_is_base ${_svc} && ! svc_is_special ${_svc}; then
				pkg_scripts_rm ${_svc}
			fi
			svc_rm ${_svc}
			return
		else
			rcctl_err "invalid status \"${_args}\""
		fi
	else
		svc_get ${_svc} status || \
			rcctl_err "${svc} is not enabled"
	fi

	if svc_is_special ${_svc}; then
		[ "${_var}" = "flags" ] || return
		rcconf_edit_begin
		grep -v "^${_svc}.*=" /etc/rc.conf.local >${_TMP_RCCONF}
		( svc_getdef ${_svc} status ) || \
			echo "${_svc}=YES" >>${_TMP_RCCONF}
		rcconf_edit_end
		return
	fi

	if [ -n "${_args}" ]; then
		if [ "${_var}" = "rtable" ]; then
			[[ ${_args} != +([[:digit:]]) || ${_args} -lt 0 ]] && \
				rcctl_err "\"${_args}\" is not an integer"
		fi
		if [ "${_var}" = "timeout" ]; then
			[[ ${_args} != +([[:digit:]]) || ${_args} -le 0 ]] && \
				rcctl_err "\"${_args}\" is not a positive integer"
		fi
		if [ "${_var}" = "user" ]; then
			getent passwd "${_args}" >/dev/null || \
				rcctl_err "user \"${_args}\" does not exist"
		fi
		# unset flags if they match the default enabled ones
		[ "${_args}" = "$(svc_getdef ${_svc} ${_var})" ] && \
			unset _args
	fi

	# protect leading whitespace
	[ "${_args}" = "${_args# }" ] || _args="\"${_args}\""

	# reset: value may have changed
	unset ${_svc}_${_var}

	rcconf_edit_begin
	grep -v "^${_svc}_${_var}.*=" /etc/rc.conf.local >${_TMP_RCCONF}
	if [ -n "${_args}" ] || \
	   ( svc_is_base ${_svc} && ! svc_getdef ${_svc} status && [ "${_var}" == "flags" ] ); then
		echo "${_svc}_${_var}=${_args}" >>${_TMP_RCCONF}
	fi
	rcconf_edit_end
}

unset _RC_DEBUG _RC_FORCE
while getopts "df" c; do
	case "$c" in
		d) _RC_DEBUG=-d;;
		f) _RC_FORCE=-f;;
		*) usage;;
	esac
done
shift $((OPTIND-1))
[ $# -gt 0 ] || usage

action=$1
ret=0

case ${action} in
	ls)
		lsarg=$2
		[[ ${lsarg} == @@(all|failed|off|on|started|stopped) ]] || usage
		;;
	order)
		shift 1
		svcs="$*"
		for svc in ${svcs}; do
			svc_is_avail ${svc} || \
				rcctl_err "service ${svc} does not exist" 2
		done
		;;
	disable|enable|start|stop|restart|reload|check)
		shift 1
		svcs="$*"
		[ -z "${svcs}" ] && usage
		# it's ok to disable a non-existing daemon
		if [ "${action}" != "disable" ]; then
			for svc in ${svcs}; do
				svc_is_avail ${svc} || \
					rcctl_err "service ${svc} does not exist" 2
			done
		fi
		;;
	get|getdef)
		svc=$2
		var=$3
		[ -z "${svc}" ] && usage
		[ "${svc}" = "all" ] || svc_is_avail ${svc} || \
			rcctl_err "service ${svc} does not exist" 2
		if [ -n "${var}" ]; then
			[ "${svc}" = "all" ] && usage
			[[ ${var} != @@(class|flags|status|rtable|timeout|user) ]] && usage
			if svc_is_meta ${svc}; then
				[ "${var}" != "status" ] && \
					rcctl_err "/etc/rc.d/${svc} is a meta script, cannot \"${action} ${var}\""
			fi
			if svc_is_special ${svc}; then
				[[ ${var} == @@(class|rtable|timeout|user) ]] && \
					rcctl_err "\"${svc}\" is a special variable, cannot \"${action} ${var}\""
			fi
		fi
		;;
	set)
		svc=$2
		var=$3
		[ $# -ge 3 ] && shift 3 || shift $#
		args="$*"
		[ -z "${svc}" ] && usage
		# it's ok to disable a non-existing daemon
		if [ "${action} ${var} ${args}" != "set status off" ]; then
			svc_is_avail ${svc} || \
				rcctl_err "service ${svc} does not exist" 2
		fi
		[[ ${var} != @@(class|flags|rtable|status|timeout|user) ]] && usage
		svc_is_meta ${svc} && [ "${var}" != "status" ] && \
			rcctl_err "/etc/rc.d/${svc} is a meta script, cannot \"${action} ${var}\""
		[[ ${var} = flags && ${args} = NO ]] && \
			rcctl_err "\"flags NO\" contradicts \"${action}\""
		if svc_is_special ${svc}; then
			[[ ${var} != status ]] && \
				rcctl_err "\"${svc}\" is a special variable, cannot \"${action} ${var}\""
		fi
		[[ ${var} == class ]] && \
			rcctl_err "\"${svc}_class\" is a read-only variable set in login.conf(5)"
		;;
	*)
		usage
		;;
esac

case ${action} in
	disable)
		needs_root ${action}
		for svc in ${svcs}; do
			svc_set ${svc} status off || ret=$?;
		done
		exit ${ret}
		;;
	enable)
		needs_root ${action}
		for svc in ${svcs}; do
			svc_set ${svc} status on || ret=$?;
		done
		exit ${ret}
		;;
	get|getdef)
		if [ "${svc}" = "all" ]; then
			for svc in $(svc_ls all); do
				( svc_${action} ${svc} "${var}" )
			done
			return 0 # we do not want the svc status
		else
			( svc_${action} ${svc} "${var}" )
		fi
		;;
	ls)
		# some rc.d(8) scripts need root for rc_check()
		[[ ${lsarg} == @@(started|stopped|failed) ]] && needs_root ${action} ${lsarg}
		svc_ls ${lsarg}
		;;
	order)
		if [ -n "${svcs}" ]; then
			needs_root ${action}
			pkg_scripts_order ${svcs}
		else
			[[ -z ${pkg_scripts} ]] || echo ${pkg_scripts}
		fi
		;;
	set)
		needs_root ${action}
		svc_set ${svc} "${var}" "${args}"
		;;
	start|stop|restart|reload|check)
		for svc in ${svcs}; do
			if svc_is_special ${svc}; then
				rcctl_err "\"${svc}\" is a special variable, no rc.d(8) script"
			fi
			/etc/rc.d/${svc} ${_RC_DEBUG} ${_RC_FORCE} ${action} || ret=$?;
		done
		exit ${ret}
		;;
	*)
		usage
		;;
esac
@


1.105
log
@Validate service names with _rc_check_name() from rc.subr.

ok sthen@@ robert@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.104 2016/07/30 06:25:21 ajacoutot Exp $
d20 2
a21 1
_special_svcs="accounting check_quotas ipsec multicast pf spamd_black"
@


1.104
log
@This is effectively a ksh(1) script.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.103 2016/07/19 08:28:03 sthen Exp $
d142 1
a142 1
	[ -n "${_svc}" ] || return
@


1.103
log
@In rcctl ls, skip all files with a '.' in the name, not just rc.subr;
pkg_add renames files in this way when the checksums don't match at update
or removal time. [[ ]] suggestion from guenther@@ to avoid the messy "case"
that I had in my first diff. Other feedback/suggestions from halex aja
millert, ok halex@@ aja@@.
@
text
@d1 1
a1 1
#!/bin/sh
d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.102 2016/06/19 15:00:37 ajacoutot Exp $
@


1.102
log
@Replace some expensive evals.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.101 2016/06/19 11:32:25 ajacoutot Exp $
d56 1
a56 1
		[ "${_s}" = "rc.subr" ] && continue
@


1.101
log
@Do caching differently.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.100 2016/06/19 11:14:20 ajacoutot Exp $
d153 3
a155 1
	local _cached=$(eval echo \${cached_svc_is_base_${_svc}})
d159 1
d161 2
a162 2
	eval cached_svc_is_base_${_svc}=$?
	eval return \${cached_svc_is_base_${_svc}}
d170 3
a172 1
	local _cached=$(eval echo \${cached_svc_is_meta_${_svc}})
d176 1
d178 2
a179 2
	eval cached_svc_is_meta_${_svc}=$?
	eval return \${cached_svc_is_meta_${_svc}}
d187 3
a189 1
	local _cached=$(eval echo \${cached_svc_is_special_${_svc}})
d193 1
d195 2
a196 2
	eval cached_svc_is_special_${_svc}=$?
	eval return \${cached_svc_is_special_${_svc}}
@


1.100
log
@Temporarily turn caching off; there's a small regression when enabling
multiple daemons at once; being worked on.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.96 2016/06/17 11:24:58 ajacoutot Exp $
d153 2
a154 2
#	[ -n "${cached_svc_is_base[${_svc}]}" ] && \
#		return ${cached_svc_is_base[${_svc}]}
d158 2
a159 2
	cached_svc_is_base[${_svc}]=$?
	return ${cached_svc_is_base[${_svc}]}
d167 2
a168 2
#	[ -n "${cached_svc_is_meta[${_svc}]}" ] && \
#		return ${cached_svc_is_meta[${_svc}]}
d172 2
a173 2
	cached_svc_is_meta[${_svc}]=$?
	return ${cached_svc_is_meta[${_svc}]}
d181 2
a182 2
#	[ -n "${cached_svc_is_special[${_svc}]}" ] && \
#		return ${cached_svc_is_special[${_svc}]}
d186 2
a187 2
	cached_svc_is_special[${_svc}]=$?
	return ${cached_svc_is_special[${_svc}]}
@


1.99
log
@Implement rcctl get|getdef all.
With this and the previous 2 commits, we can move from constructs like:
$ for i in $(rcctl ls all); do rcctl get $i; done
to just:
$ rcctl get all
Shrinking the run by a factor of more than 3.5.

prodded by and discussed with reyk@@ at BSDcan2016
ok robert@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.98 2016/06/19 10:50:27 ajacoutot Exp $
d153 2
a154 2
	[ "${_cached_svc_is_base[${_svc}]}" ] && \
		return ${_cached_svc_is_base[${_svc}]}
d158 2
a159 2
	_cached_svc_is_base[${_svc}]=$?
	return ${_cached_svc_is_base[${_svc}]}
d167 2
a168 2
	[ "${_cached_svc_is_meta[${_svc}]}" ] && \
		return ${_cached_svc_is_meta[${_svc}]}
d172 2
a173 2
	_cached_svc_is_meta[${_svc}]=$?
	return ${_cached_svc_is_meta[${_svc}]}
d181 2
a182 2
	[ "${_cached_svc_is_special[${_svc}]}" ] && \
		return ${_cached_svc_is_special[${_svc}]}
d186 2
a187 2
	_cached_svc_is_special[${_svc}]=$?
	return ${_cached_svc_is_special[${_svc}]}
@


1.98
log
@Cache result of often used functions (svc_is_{base,meta,special}).
Large speedup when iterating over all rc.d scripts.

with and ok robert@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.97 2016/06/19 10:46:08 ajacoutot Exp $
d506 1
a506 1
		svc_is_avail ${svc} || \
d509 1
d564 9
a572 5
	get)
		svc_get ${svc} "${var}"
		;;
	getdef)
		( svc_getdef ${svc} "${var}" )
@


1.97
log
@grep(1) /etc/rc.conf instead of /etc/rc to detect whether a particular
rc.d script comes from base of not; it's much faster.

ok robert@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.96 2016/06/17 11:24:58 ajacoutot Exp $
d153 3
d157 3
d167 3
d171 3
d181 3
d185 3
@


1.96
log
@No need to hardcode return code.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.95 2016/04/26 18:39:29 ajacoutot Exp $
d153 1
a153 2
	grep -E 'start_daemon[[:space:]]+[[:alnum:]]' /etc/rc | \
		cut -d ' ' -f2- | grep -qw -- ${_svc}
@


1.95
log
@It's ok to disable a non-existing daemon.
Think "pkg_delete foobar && rcctl disable foobar".
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.94 2016/04/26 17:58:42 ajacoutot Exp $
d144 1
a144 1
	[ -x "/etc/rc.d/${_svc}" ] && return 0
@


1.94
log
@Implement daemon_rtable support.
From Jiri B <jirib ! devio ! us>, thanks!
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.93 2016/04/09 08:02:22 ajacoutot Exp $
d477 7
a483 4
		for svc in ${svcs}; do
			svc_is_avail ${svc} || \
				rcctl_err "service ${svc} does not exist" 2
		done
d509 5
a513 2
		svc_is_avail ${svc} || \
			rcctl_err "service ${svc} does not exist" 2
@


1.93
log
@Use builtin.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.92 2016/04/01 08:18:57 ajacoutot Exp $
d226 1
a226 1
	local daemon_class daemon_flags daemon_timeout daemon_user
d252 6
d286 1
d301 1
a301 1
	local daemon_class daemon_flags daemon_timeout daemon_user
d325 1
d342 1
d361 1
a361 1
		grep -Ev "^${_svc}_(flags|timeout|user).*=" \
d414 4
d489 1
a489 1
			[[ ${var} != @@(class|flags|status|timeout|user) ]] && usage
d495 1
a495 1
				[[ ${var} == @@(class|timeout|user) ]] && \
d508 1
a508 1
		[[ ${var} != @@(class|flags|status|timeout|user) ]] && usage
@


1.92
log
@Rename the 'faulty' list action to 'failed'; it clearer.

prodded by matthieu@@
ok millert@@ jung@@ sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.91 2016/03/28 08:10:19 ajacoutot Exp $
d30 3
d35 1
a35 1
	rcctl [-df] $(echo ${_rc_actions} | tr "[:blank:]" "|") daemon ...
@


1.91
log
@Remove left-over debug line.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.90 2016/03/27 13:11:33 ajacoutot Exp $
d34 1
a34 1
	rcctl ls all|faulty|off|on|started|stopped"
d185 1
a185 1
		faulty)
d447 1
a447 1
		[[ ${lsarg} == @@(all|faulty|off|on|started|stopped) ]] || usage
d532 1
a532 1
		[[ ${lsarg} == @@(started|stopped|faulty) ]] && needs_root ${action} ${lsarg}
@


1.90
log
@Compute "action" from the _rc_actions variable.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.89 2016/03/27 13:06:00 ajacoutot Exp $
a26 2

echo $_rc_actions
@


1.89
log
@Make usage() a bit more user friendly wrt "action" and "lsarg".

prodded by espie@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.88 2016/01/24 08:51:50 ajacoutot Exp $
d28 2
d34 1
a34 1
	rcctl [-df] start|stop|restart|reload|check daemon ...
@


1.88
log
@Check all daemons in "faulty", not just the base ones.
reported by landry@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.87 2015/12/06 14:24:48 mpi Exp $
d32 1
a32 1
	rcctl [-df] action daemon ...
d34 1
a34 1
	rcctl ls lsarg"
@


1.87
log
@multicast_{host,router} -> multicast.

ok ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.86 2015/11/29 15:58:59 ajacoutot Exp $
d187 1
a187 1
				svc_is_base ${_svc} && \
@


1.86
log
@Better cope with meta rc.d scripts; these are ugly but well...
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.85 2015/11/01 10:59:23 ajacoutot Exp $
d20 1
a20 2
_special_svcs="accounting check_quotas ipsec multicast_host multicast_router pf
               spamd_black"
@


1.85
log
@Tweak wording.
Make sure the rc.d script exist in svc_is_meta().
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.84 2015/10/31 11:09:41 ajacoutot Exp $
d160 1
a160 1
	[ -r "/etc/rc.d/${_svc}" ] && grep -q "^_pkg_scripts=" /etc/rc.d/${_svc}
d236 26
a261 24
		# these are expensive, make sure they are explicitely requested
		if [ -z "${_var}" -o "${_var}" = "class" ]; then
			getcap -f /etc/login.conf ${_svc} 1>/dev/null 2>&1 && \
				daemon_class=${_svc}
			[ -z "${daemon_class}" ] && \
				daemon_class="$(svc_getdef ${_svc} class)"
		fi
		if [[ -z ${_var} || ${_var} == @@(flags|status) ]]; then
			[ -z "${daemon_flags}" ] && \
				daemon_flags="$(eval echo \"\${${_svc}_flags}\")"
			[ -z "${daemon_flags}" ] && \
				daemon_flags="$(svc_getdef ${_svc} flags)"
		fi
		if [ -z "${_var}" -o "${_var}" = "timeout" ]; then
			[ -z "${daemon_timeout}" ] && \
				daemon_timeout="$(eval echo \"\${${_svc}_timeout}\")"
			[ -z "${daemon_timeout}" ] && \
				daemon_timeout="$(svc_getdef ${_svc} timeout)"
		fi
		if [ -z "${_var}" -o "${_var}" = "user" ]; then
			[ -z "${daemon_user}" ] && \
				daemon_user="$(eval echo \"\${${_svc}_user}\")"
			[ -z "${daemon_user}" ] && \
				daemon_user="$(svc_getdef ${_svc} user)"
d272 1
a302 1
			
d311 8
a318 6
		rc_cmd() { }
		. /etc/rc.d/${_svc} >/dev/null 2>&1

		daemon_class=daemon
		[ -z "${daemon_timeout}" ] && daemon_timeout=30
		[ -z "${daemon_user}" ] && daemon_user=root
d326 1
a472 2
		svc_is_meta ${svc} && \
			rcctl_err "/etc/rc.d/${svc} is a meta script, cannot \"${action} ${var}\""
d475 4
d493 2
a494 1
		svc_is_meta ${svc} && \
a495 1
		[[ ${var} != @@(class|flags|status|timeout|user) ]] && usage
@


1.84
log
@Only handle meta scripts for rc.d actions and enable/disable only.

ok sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.83 2015/10/24 13:57:24 ajacoutot Exp $
d160 1
a160 1
	grep -q "^_pkg_scripts=" /etc/rc.d/${_svc}
d469 1
a469 1
			rcctl_err "\"${svc}\" is a meta script, cannot \"${action} ${svc} ${var}\""
d474 1
a474 1
					rcctl_err "\"${svc}\" is a special variable, cannot \"${action} ${svc} ${var}\""
d487 1
a487 1
			rcctl_err "\"${svc}\" is a meta script, cannot \"${action} ${svc} ${var}\""
d493 1
a493 1
				rcctl_err "\"${svc}\" is a special variable, cannot \"${action} ${svc} ${var}\""
@


1.83
log
@"enable" and "disable" are here to stay now that they have a real added value
(possibility to pass several enable|disable daemons at once); so document them.
While here, add a check to make sure a service|daemon exists when running "order".

"Yay" and ok sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.82 2015/10/06 18:46:05 schwarze Exp $
d155 8
d468 2
d486 2
@


1.82
log
@With growing functionality, the synopsis became long and confusing.
The syntax of some subcommands has almost nothing in common with the
syntax of others.  So split the synopsis to make it more readable.
"if you feel it helps, go for it"  jmc@@ ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.81 2015/10/04 13:38:11 ajacoutot Exp $
d34 1
a34 1
	rcctl order [daemon ...]
d440 4
a444 1
	# enable|disable: undocumented, deprecated
d492 1
a492 1
	disable) # undocumented, deprecated
d499 1
a499 1
	enable) # undocumented, deprecated
@


1.81
log
@Make it possible to give the same action to several daemons at once.
e.g.
# rcctl restart sshd ntpd

from Martijn van Duren with tweaks
ok sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.80 2015/10/03 10:39:21 ajacoutot Exp $
d31 5
a35 2
	_rc_err "usage: ${0##*/} [-df] action|get|getdef|ls|order|set
             [service | daemon [variable [arguments]] | daemons | lsarg]"
@


1.80
log
@Properly indent usage() output.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.79 2015/08/12 06:28:18 ajacoutot Exp $
d427 1
a427 12
if [ "${action}" = "ls" ]; then
	lsarg=$2
	[[ ${lsarg} == @@(all|faulty|off|on|started|stopped) ]] || usage
elif [ "${action}" = "order" ]; then
	shift 1
	svcs="$*"
else
	svc=$2
	var=$3
	[ $# -ge 3 ] && shift 3 || shift $#
	args="$*"
fi
d429 52
a480 2
if [ -n "${svc}" ]; then
	[[ ${action} == @@(disable|enable|get|getdef|set|start|stop|restart|reload|check) ]] || \
d482 2
a483 21
	svc_is_avail ${svc} || \
		rcctl_err "service ${svc} does not exist" 2
elif [[ ${action} != @@(ls|order) ]] ; then
	usage
fi

if [ -n "${var}" ]; then
	[[ ${var} != @@(class|flags|status|timeout|user) ]] && usage
	[[ ${action} == set && ${var} = flags && ${args} = NO ]] && \
		rcctl_err "\"flags NO\" contradicts \"${action}\""
	[[ ${action} == set && ${var} == class ]] && \
		rcctl_err "\"${svc}_class\" is a read-only variable set in login.conf(5)"
	if svc_is_special ${svc}; then
		if [[ ${action} == set && ${var} != status ]] || \
			[[ ${action} == @@(get|getdef) && ${var} == @@(class|timeout|user) ]]; then
			rcctl_err "\"${svc}\" is a special variable, cannot \"${action} ${svc} ${var}\""
		fi
	fi
elif [ ${action} = "set" ]; then
	usage
fi
d488 4
a491 1
		svc_set ${svc} status off
d495 4
a498 1
		svc_set ${svc} status on
d524 7
a530 4
		if svc_is_special ${svc}; then
			rcctl_err "\"${svc}\" is a special variable, no rc.d(8) script"
		fi
		/etc/rc.d/${svc} ${_RC_DEBUG} ${_RC_FORCE} ${action}
@


1.79
log
@Remove getall now that we're post 5.8.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.78 2015/08/03 13:18:48 ajacoutot Exp $
d32 1
a32 1
                [service | daemon [variable [arguments]] | daemons | lsarg]"
@


1.78
log
@"ls" requires an argument.

issue reported by kirby@@
"hurry up" deraadt@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.77 2015/08/01 11:28:14 ajacoutot Exp $
d445 1
a445 1
elif [[ ${action} != @@(getall|ls|order) ]] ; then
a475 4
		;;
	getall) # undocumented, deprecated
		for i in $(svc_ls all); do svc_get ${i}; done
		return 0
@


1.77
log
@Tweak needs_root() output.
When using "ls" with a root action, properly output the action and flags
in the error output; from Theo Buehler
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.76 2015/07/25 04:12:43 ajacoutot Exp $
d429 1
a438 3

[ -n "${lsarg}" ] && [[ ${lsarg} != @@(all|faulty|off|on|started|stopped) ]] && \
	usage
@


1.76
log
@Fix usage() output.

from Michael Reed
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.75 2015/07/17 18:00:43 ajacoutot Exp $
d37 1
a37 1
	[ "$(id -u)" -ne 0 ] && _rc_err "${0##*/} $1: need root privileges"
d488 1
a488 1
		[[ ${lsarg} == @@(started|stopped|faulty) ]] && needs_root
@


1.75
log
@return 0 when using "getall"

spotted by jasper@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.74 2015/07/16 23:05:12 ajacoutot Exp $
d32 1
a32 1
		[service | daemon [variable [arguments]] | daemons | lsarg]"
@


1.74
log
@Consistency
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.73 2015/07/16 22:03:02 ajacoutot Exp $
d481 1
@


1.73
log
@No daemon_class for special services.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.72 2015/07/16 21:52:16 ajacoutot Exp $
d45 2
a46 1
ls_rcscripts() {
@


1.72
log
@Shorten variable name.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.71 2015/07/15 04:19:41 ajacoutot Exp $
d458 1
a458 1
			[[ ${action} == @@(get|getdef) && ${var} == @@(timeout|user) ]]; then
@


1.71
log
@Make it possible to get the daemon_class.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.70 2015/07/15 03:00:46 ajacoutot Exp $
d20 3
a22 3
_special_services="accounting check_quotas ipsec multicast_host multicast_router
                   pf spamd_black"
readonly _special_services
d156 1
a156 1
	echo ${_special_services} | grep -qw -- ${_svc}
d171 1
a171 1
				echo ${_special_services} | tr "[:blank:]" "\n"
@


1.70
log
@Sort 'ls all'.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.69 2015/07/14 23:16:56 ajacoutot Exp $
d212 1
a212 1
	local daemon_flags daemon_timeout daemon_user
d225 6
d261 1
d277 1
a277 1
	local daemon_flags daemon_timeout daemon_user
d300 1
d313 1
d451 1
a451 1
	[[ ${var} != @@(flags|status|timeout|user) ]] && usage
d454 2
@


1.69
log
@Deprecate getall (will be removed after 5.8).
Implement a new "ls" subcommand, to list daemons according to the argument
(all, started, ...).

input and ok robert@@
ok jasper@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.68 2015/03/28 08:08:52 ajacoutot Exp $
d169 4
a172 2
			ls_rcscripts
			for _svc in ${_special_services}; do echo ${_svc}; done
@


1.68
log
@Add comment.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.67 2015/03/28 07:41:46 ajacoutot Exp $
d20 2
a21 2
_special_services="accounting check_quotas ipsec multicast_host
                   multicast_router pf spamd_black"
d31 2
a32 2
	_rc_err "usage: ${0##*/} [-df] enable|disable|get|set|getdef|getall|order|action
             [service | daemon [variable [arguments]] | daemons]"
d147 2
a148 1
	grep -E 'start_daemon[[:space:]]+[[:alnum:]]' /etc/rc | cut -d ' ' -f2- | grep -qw -- ${_svc}
d159 45
d222 19
a240 12
		[ -z "${daemon_flags}" ] && \
			daemon_flags="$(eval echo \"\${${_svc}_flags}\")"
		[ -z "${daemon_flags}" ] && \
			daemon_flags="$(svc_getdef ${_svc} flags)"
		[ -z "${daemon_timeout}" ] && \
			daemon_timeout="$(eval echo \"\${${_svc}_timeout}\")"
		[ -z "${daemon_timeout}" ] && \
			daemon_timeout="$(svc_getdef ${_svc} timeout)"
		[ -z "${daemon_user}" ] && \
			daemon_user="$(eval echo \"\${${_svc}_user}\")"
		[ -z "${daemon_user}" ] && \
			daemon_user="$(svc_getdef ${_svc} user)"
d415 3
a417 1
if [ "${action}" = "order" ]; then
d427 3
d431 2
a432 1
	[[ ${action} = getall ]] && usage
d435 1
a435 1
elif [[ ${action} != @@(getall|order) ]] ; then
a440 1
	[[ ${action} != @@(get|getdef|set) ]] && usage
d445 1
a445 1
			[[ ${action} == @@(get|getdef) && ${var} == @@(timeout|user) ]] ; then
d454 1
a454 1
	disable)
d458 1
a458 1
	enable)
d465 2
a466 5
	getall)
		for i in $(ls_rcscripts) ${_special_services}; do
			svc_get ${i}
		done
		return 0 # we do not want the "status"
d470 5
@


1.67
log
@Add rcctl_err() which is a wrapper for _rc_err() with common rcctl(8) verbiage.
Add some explicit error messages while here.

Prefer cat over cp/mv to edit rc.conf.local; this prevents creating
rc.conf.local with mode 0600.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.66 2015/03/02 06:58:42 ajacoutot Exp $
d285 3
@


1.66
log
@Extend previous.

ok sebastia@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.65 2015/03/01 18:38:05 sebastia Exp $
d40 5
d79 1
a79 1
			_rc_err "${0##*/}: ${_svc} is not a pkg script"
d81 1
a81 1
			_rc_err "${0##*/}: ${_svc} is not enabled"
d108 2
a109 1
	_TMP_RCCONF=$(mktemp -p /etc -t rc.conf.local.XXXXXXXXXX) || exit 1
d111 2
a112 2
		# only to keep permissions (file content is not needed)
		cp -p /etc/rc.conf.local ${_TMP_RCCONF} || exit 1
d114 2
a115 1
		touch /etc/rc.conf.local || exit 1
d121 4
a124 2
	sort -u -o ${_TMP_RCCONF} ${_TMP_RCCONF} || exit 1
	mv ${_TMP_RCCONF} /etc/rc.conf.local || exit 1
d126 2
a127 1
		rm /etc/rc.conf.local || exit 1
d129 1
d301 1
a301 1
			_rc_err "${0##*/}: invalid status \"${_args}\""
d305 1
a305 1
			_rc_err "${0##*/}: ${svc} is not enabled"
d321 1
a321 1
				_rc_err "${0##*/}: \"${_args}\" is not a positive integer"
d325 1
a325 1
				_rc_err "${0##*/}: user \"${_args}\" does not exist"
d372 1
a372 1
		_rc_err "${0##*/}: service ${svc} does not exist" 2
d381 1
a381 1
		_rc_err "${0##*/}: \"flags NO\" contradicts \"${action}\""
d385 1
a385 1
			_rc_err "${0##*/}: \"${svc}\" is a special variable, cannot \"${action} ${svc} ${var}\""
d427 1
a427 1
			_rc_err "${0##*/}: \"${svc}\" is a special variable, no rc.d(8) script"
@


1.65
log
@svc_is_base function didn't catched all base daemons, apparently found
trying to manage rtadvd with it.

OK ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.64 2015/01/18 10:29:53 ajacoutot Exp $
d136 1
a136 1
	grep "start_daemon " /etc/rc | cut -d ' ' -f2- | grep -qw -- ${_svc}
@


1.64
log
@Drop backward compat syntax.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.63 2015/01/12 14:40:35 ajacoutot Exp $
d136 1
a136 1
	grep "^start_daemon " /etc/rc | cut -d ' ' -f2- | grep -qw -- ${_svc}
@


1.63
log
@Make sure the given user exists.

"I like it" sthen@@
ok robert@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.62 2015/01/12 13:51:20 ajacoutot Exp $
d20 2
a21 1
_special_services="accounting check_quotas ipsec multicast_host multicast_router pf spamd_black"
d362 1
a362 1
elif [[ ${action} != @@(getall|order|status) ]] ; then
d368 2
a369 2
	[[ ${action} != @@(enable|get|getdef|set) ]] && usage
	[[ ${action} == @@(enable|set) && ${var} = flags && ${args} = NO ]] && \
d372 1
a372 1
		if [[ ${action} == @@(enable|set) && ${var} != status ]] || \
a376 2
	[[ ${action} == enable && ${var} != flags ]] && \
		_rc_err "${0##*/}: invalid action \"${action} ${svc} ${var}\""
a388 4
		# XXX backward compat
		if [ -n "${var}" ]; then
			svc_set ${svc} "${var}" "${args}"
		fi
a412 11
		;;
	status) # XXX backward compat
		if [ -n "${svc}" ]; then
			svc_get ${svc} flags
			svc_get ${svc} status
		else
			for i in $(ls_rcscripts) ${_special_services}; do
				svc_get ${i} | grep -Ev '_(timeout|user)'
			done
			return 0 # we do not want the "status"
		fi
@


1.62
log
@Make it possible to reset "timeout" to the default value.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.61 2015/01/12 13:40:12 ajacoutot Exp $
d310 4
@


1.61
log
@"timeout" must be a positive integer.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.60 2015/01/08 13:29:34 ajacoutot Exp $
a305 6
	if [ "${_var}" = "timeout" ]; then
		[[ ${_args} != +([[:digit:]]) || ${_args} -le 0 ]] && \
			_rc_err "${0##*/}: \"${_args}\" is not a positive integer"
	fi

	# unset flags if they match the default enabled ones
d307 5
@


1.60
log
@"default" is gone.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.59 2015/01/06 14:48:59 ajacoutot Exp $
d308 1
a308 1
			_rc_err "${0##*/}: \"${_args}\" is not an integer"
@


1.59
log
@Simplify special vars argument checking; invalidating some bogus constructs
in the process.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.58 2015/01/06 12:49:55 ajacoutot Exp $
a379 4
	default) # XXX backward compat
		( svc_getdef ${svc} flags )
		( svc_getdef ${svc} status )
		;;
@


1.58
log
@While on death-row, 'rcctl status' still is still allowed for now -- so
make its output match the older one.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.57 2015/01/06 12:27:42 ajacoutot Exp $
d368 2
a369 3
		if [[ ${var} != @@(flags|status) || \
			${action} != @@(set|get|getdef|enable) ]] || \
			[[ ${action} == @@(enable|set) && -n ${args} ]]; then
@


1.57
log
@Rename some internal variables (flag and flags is way too error-prone):
flag -> var
flags -> args
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.56 2015/01/06 11:47:50 ajacoutot Exp $
d427 1
a427 1
				svc_get ${i}
@


1.56
log
@Major rcctl(8) rewrite to simplify it and add new features. It can now
configure "user" and "timeout". Committing now because there's been no
release yet including rcctl(8) so it's easier to modify its usage.

Usage extended (*retaining full backward compatibility for now*) to:
rcctl set|get|getdef foobar [flags|user|timeout|status]

The followings will be dropped soon but not right now to give people
time to adjust:
rcctl enable sshd flags	# 'enable' takes no flags, use 'rcctl set ...'
rcctl status sshd	# use 'rcctl get sshd [flags|status|timeout|user]'
rcctl default sshd	# use 'rcctl getdef sshd [flags|status|timeout|user]'
rcctl status		# use 'rcctl getall'

Man page changes will come soon. Make sure you have an up-to-date rc.subr.

discussed with schwarze@@ robert@@ jasper@@ sthen@@
"love the idea" jasper@@
ok schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.55 2015/01/01 09:44:20 ajacoutot Exp $
d257 1
a257 1
		grep -Ev "^${_svc}_(flags|user|timeout).*=" \
d271 1
a271 1
	local _flags="$*"
d274 1
a274 1
		if [ "${_flags}" = "on" ]; then
d277 2
a278 2
			eval "_flags=\"\${${_svc}_${_var}}\""
			[ "${_flags}" = "NO" ] && unset _flags
d282 1
a282 1
		elif [ "${_flags}" = "off" ]; then
d289 1
a289 1
			_rc_err "${0##*/}: invalid status \"${_flags}\""
d307 2
a308 2
		[[ ${_flags} != +([[:digit:]]) || ${_flags} -le 0 ]] && \
			_rc_err "${0##*/}: \"${_flags}\" is not an integer"
d312 3
a314 3
	if [ -n "${_flags}" ]; then
		[ "${_flags}" = "$(svc_getdef ${_svc} ${_var})" ] && \
			unset _flags
d318 1
a318 1
	[ "${_flags}" = "${_flags# }" ] || _flags="\"${_flags}\""
d325 1
a325 1
	if [ -n "${_flags}" ] || \
d327 1
a327 1
		echo "${_svc}_${_var}=${_flags}" >>${_TMP_RCCONF}
d349 1
a349 1
	flag=$3
d351 1
a351 1
	flags="$*"
d362 2
a363 2
if [ -n "${flag}" ]; then
	[[ ${flag} != @@(flags|status|timeout|user) ]] && usage
d365 1
a365 1
	[[ ${action} == @@(enable|set) && ${flag} = flags && ${flags} = NO ]] && \
d368 1
a368 1
		if [[ ${flag} != @@(flags|status) || \
d370 2
a371 2
			[[ ${action} == @@(enable|set) && -n ${flags} ]]; then
			_rc_err "${0##*/}: \"${svc}\" is a special variable, cannot \"${action} ${svc} ${flag}\""
d374 2
a375 2
	[[ ${action} == enable && ${flag} != flags ]] && \
		_rc_err "${0##*/}: invalid action \"${action} ${svc} ${flag}\""
d393 2
a394 2
		if [ -n "${flag}" ]; then
			svc_set ${svc} "${flag}" "${flags}"
d398 1
a398 1
		svc_get ${svc} "${flag}"
d407 1
a407 1
		( svc_getdef ${svc} "${flag}" )
d419 1
a419 1
		svc_set ${svc} "${flag}" "${flags}"
@


1.55
log
@Drop redundant FUNCS_ONLY.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.54 2014/12/30 15:33:53 ajacoutot Exp $
d5 1
a5 1
# Copyright (c) 2014 Antoine Jacoutot <ajacoutot@@openbsd.org>
d30 2
a31 2
	_rc_err "usage: ${0##*/} [-df] enable|disable|status|default|order|action
             [service | daemon [flags [arguments]] | daemons]"
d49 51
d118 1
d121 1
a121 1
svc_avail()
d124 1
a124 1
	[ -n "${_svc}" ] || return 1
a125 1
	[ "${_svc}" = "rc.subr" ] && return 1
d127 1
a127 1
	svc_special ${_svc}
d130 1
a130 1
svc_base()
d138 1
a138 1
svc_enabled()
d143 1
a143 1
	[ "$(svc_flags ${_svc})" != "NO" ]
d146 1
a146 1
svc_enabled_default()
a149 1
	local _ret=1
d151 2
a152 3
	_rc_parse_conf /etc/rc.conf
	svc_enabled ${_svc} && _ret=0
	_rc_parse_conf
d154 2
a155 11
	return ${_ret}
}

svc_flags()
{
	local _svc=$1
	[ -n "${_svc}" ] || return
	local daemon_flags

	if svc_special ${_svc}; then
		echo "$(eval echo \${${_svc}})"
d158 1
a158 1
		if ! svc_base ${_svc}; then
d160 1
a160 1
				echo "NO" && return
d163 1
d167 26
a192 3
			daemon_flags="$(svc_flags_default ${_svc})"

		[ -n "${daemon_flags}" ] && print -r -- "${daemon_flags}"
d197 1
a197 1
svc_flags_default()
d202 8
a209 2
	if svc_special ${_svc}; then
		svc_enabled_default ${_svc} && echo "YES" || echo "NO"
d211 12
a224 11
		[ -n "${daemon_flags}" ] && print -r -- "${daemon_flags}"
	fi
}

svc_special()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	echo ${_special_services} | grep -qw -- ${_svc}
}
d226 2
a227 14
svc_status()
{
	local _i _svc=$1

	if [ -n "${_svc}" ]; then
		svc_flags ${_svc}
		svc_enabled ${_svc}
	else
		for _i in $(ls_rcscripts); do
			echo "${_i}_flags=$(svc_flags ${_i})"
		done
		for _i in ${_special_services}; do
			echo "${_i}=$(svc_flags ${_i})"
		done
a228 5
}

svc_status_default()
{
	local _i _svc=$1
d230 4
a233 3
	if [ -n "${_svc}" ]; then
		( svc_flags_default ${_svc} )
		svc_enabled_default ${_svc}
d235 8
a242 6
		for _i in $(ls_rcscripts); do
			echo "${_i}_flags=$(svc_flags_default ${_i})"
		done
		for _i in ${_special_services}; do
			echo "${_i}=$(svc_flags_default ${_i})"
		done
d246 1
a246 1
pkg_scripts_append()
d252 9
a260 5
	if [ -z "${pkg_scripts}" ]; then
		echo pkg_scripts="${_svc}" >>${_TMP_RCCONF}
	elif ! echo ${pkg_scripts} | grep -qw -- ${_svc}; then
		grep -v "^pkg_scripts.*=" /etc/rc.conf.local >${_TMP_RCCONF}
		echo pkg_scripts="${pkg_scripts} ${_svc}" >>${_TMP_RCCONF}
d265 1
a265 1
pkg_scripts_order()
d267 5
a271 2
	local _svcs="$*"
	[ -n "${_svcs}" ] || return
d273 17
a289 7
	needs_root ${action}
	local _pkg_scripts _svc
	for _svc in ${_svcs}; do
		if svc_base ${_svc} || svc_special ${_svc}; then
			_rc_err "${0##*/}: ${_svc} is not a pkg script"
		elif ! svc_enabled ${_svc}; then
			_rc_err "${0##*/}: ${_svc} is not enabled"
d291 4
a294 15
	done
	_pkg_scripts=$(echo "${_svcs} ${pkg_scripts}" | tr "[:blank:]" "\n" | \
		     awk -v ORS=' ' '!x[$0]++')
	rcconf_edit_begin
	grep -v "^pkg_scripts.*=" /etc/rc.conf.local >${_TMP_RCCONF}
	echo pkg_scripts=${_pkg_scripts} >>${_TMP_RCCONF}
	rcconf_edit_end
}

pkg_scripts_rm()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	[ -z "${pkg_scripts}" ] && return
d296 2
a297 13
	rcconf_edit_begin
	sed "/^pkg_scripts[[:>:]]/{s/[[:<:]]${_svc}[[:>:]]//g
	    s/['\"]//g;s/ *= */=/;s/   */ /g;s/ $//;/=$/d;}" \
	    /etc/rc.conf.local >${_TMP_RCCONF}
	rcconf_edit_end
}

add_flags()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	if svc_special ${_svc}; then
d300 1
a300 1
		if ! svc_enabled_default ${_svc}; then
a301 1
		fi
d306 3
a308 9
	local _flags

	if [ -n "$2" ]; then
		shift 2
		_flags="$*"
	else
		# keep our flags since none were given
		eval "_flags=\"\${${_svc}_flags}\""
		[ "${_flags}" = "NO" ] && unset _flags
d313 1
a313 1
		[ "${_flags}" = "$(svc_flags_default ${_svc})" ] && \
d320 3
d324 1
a324 1
	grep -v "^${_svc}_flags.*=" /etc/rc.conf.local >${_TMP_RCCONF}
d326 2
a327 22
	   ( svc_base ${_svc} && ! svc_enabled_default ${_svc} ); then
		echo "${_svc}_flags=${_flags}" >>${_TMP_RCCONF}
	fi
	rcconf_edit_end
}

rm_flags()
{
	local _svc=$1
	[ -n "${_svc}" ] || return

	rcconf_edit_begin
	if svc_special ${_svc}; then
		grep -v "^${_svc}.*=" /etc/rc.conf.local >${_TMP_RCCONF}
		if svc_enabled_default ${_svc}; then
			echo "${_svc}=NO" >>${_TMP_RCCONF}
		fi
	else
		grep -v "^${_svc}_flags.*=" /etc/rc.conf.local >${_TMP_RCCONF}
		if svc_enabled_default ${_svc}; then
			echo "${_svc}_flags=NO" >>${_TMP_RCCONF}
		fi
d355 2
a356 1
	if ! svc_avail ${svc}; then
d358 1
a358 2
	fi
elif [[ ${action} != @@(default|order|status) ]] ; then
d363 9
a371 6
	if [ "${flag}" = "flags" ]; then
		if [ "${action}" != "enable" ]; then
			_rc_err "${0##*/}: \"${flag}\" can only be set with \"enable\""
		fi
		if svc_special ${svc} && [ -n "${flags}" ]; then
			_rc_err "${0##*/}: \"${svc}\" is a special variable, cannot set \"${flag}\""
a372 5
		if [ "${flag}" = "flags" -a "${flags}" = "NO" ]; then
			_rc_err "${0##*/}: \"flags ${flags}\" contradicts \"enable\""
		fi
	else
		usage
d374 4
d381 3
a383 2
	default)
		svc_status_default ${svc}
d387 1
a387 4
		if ! svc_base ${svc} && ! svc_special ${svc}; then
			pkg_scripts_rm ${svc}
		fi
		rm_flags ${svc}
d391 4
a394 3
		add_flags ${svc} "${flag}" "${flags}"
		if ! svc_base ${svc} && ! svc_special ${svc}; then
			pkg_scripts_append ${svc}
d397 12
d417 14
a430 2
	status)
		svc_status ${svc}
d433 1
a433 1
		if svc_special ${svc}; then
@


1.54
log
@Rename a few functions name. Will help factorize some stuffs.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.52 2014/12/30 14:46:33 ajacoutot Exp $
a140 1
		FUNCS_ONLY=1
@


1.53
log
@do not print an empty order in case pkg_scripts is undefined
ok ajacoutot@@
@
text
@d69 11
a79 1
svc_default_enabled()
a82 1
	local _ret=1
d84 1
a84 5
	_rc_parse_conf /etc/rc.conf
	svc_is_enabled ${_svc} && _ret=0
	_rc_parse_conf

	return ${_ret}
d87 1
a87 2
# to prevent namespace pollution, only call in a subshell
svc_default_enabled_flags()
d92 1
a92 8
	if svc_is_special ${_svc}; then
		svc_default_enabled ${_svc} && echo "YES" || echo "NO"
	else
		FUNCS_ONLY=1
		rc_cmd() { }
		. /etc/rc.d/${_svc} >/dev/null 2>&1
		[ -n "${daemon_flags}" ] && print -r -- "${daemon_flags}"
	fi
d95 1
a95 1
svc_get_defaults()
d97 7
a103 1
	local _i _svc=$1
d105 1
a105 11
	if [ -n "${_svc}" ]; then
		( svc_default_enabled_flags ${_svc} )
		svc_default_enabled ${_svc}
	else
		for _i in $(ls_rcscripts); do
			echo "${_i}_flags=$(svc_default_enabled_flags ${_i})"
		done
		for _i in ${_special_services}; do
			echo "${_i}=$(svc_default_enabled_flags ${_i})"
		done
	fi
d108 1
a108 1
svc_get_flags()
d114 1
a114 1
	if svc_is_special ${_svc}; then
d118 1
a118 1
		if ! svc_is_base ${_svc}; then
d126 1
a126 1
			daemon_flags="$(svc_default_enabled_flags ${_svc})"
d132 2
a133 1
svc_get_status()
d135 2
a136 1
	local _i _svc=$1
d138 2
a139 3
	if [ -n "${_svc}" ]; then
		svc_get_flags ${_svc}
		svc_is_enabled ${_svc}
d141 4
a144 6
		for _i in $(ls_rcscripts); do
			echo "${_i}_flags=$(svc_get_flags ${_i})"
		done
		for _i in ${_special_services}; do
			echo "${_i}=$(svc_get_flags ${_i})"
		done
d148 1
a148 11
svc_is_avail()
{
	local _svc=$1
	[ -n "${_svc}" ] || return 1

	[ "${_svc}" = "rc.subr" ] && return 1
	[ -x "/etc/rc.d/${_svc}" ] && return 0
	svc_is_special ${_svc}
}

svc_is_base()
d153 1
a153 1
	grep "^start_daemon " /etc/rc | cut -d ' ' -f2- | grep -qw -- ${_svc}
d156 1
a156 1
svc_is_enabled()
d158 1
a158 2
	local _svc=$1
	[ -n "${_svc}" ] || return
d160 11
a170 1
	[ "$(svc_get_flags ${_svc})" != "NO" ]
d173 1
a173 1
svc_is_special()
d175 1
a175 2
	local _svc=$1
	[ -n "${_svc}" ] || return
d177 11
a187 1
	echo ${_special_services} | grep -qw -- ${_svc}
d190 1
a190 1
append_to_pkg_scripts()
d205 1
a205 1
order_pkg_scripts()
d213 1
a213 1
		if svc_is_base ${_svc} || svc_is_special ${_svc}; then
d215 1
a215 1
		elif ! svc_is_enabled ${_svc}; then
d227 1
a227 1
rm_from_pkg_scripts()
d246 1
a246 1
	if svc_is_special ${_svc}; then
d249 1
a249 1
		if ! svc_default_enabled ${_svc}; then
d269 1
a269 1
		[ "${_flags}" = "$(svc_default_enabled_flags ${_svc})" ] && \
d279 1
a279 1
	   ( svc_is_base ${_svc} && ! svc_default_enabled ${_svc} ); then
d291 1
a291 1
	if svc_is_special ${_svc}; then
d293 1
a293 1
		if svc_default_enabled ${_svc}; then
d298 1
a298 1
		if svc_default_enabled ${_svc}; then
d328 1
a328 1
	if ! svc_is_avail ${svc}; then
d340 1
a340 1
		if svc_is_special ${svc} && [ -n "${flags}" ]; then
d353 1
a353 1
		svc_get_defaults ${svc}
d357 2
a358 2
		if ! svc_is_base ${svc} && ! svc_is_special ${svc}; then
			rm_from_pkg_scripts ${svc}
d365 2
a366 2
		if ! svc_is_base ${svc} && ! svc_is_special ${svc}; then
			append_to_pkg_scripts ${svc}
d372 1
a372 1
			order_pkg_scripts ${svcs}
d378 1
a378 1
		svc_get_status ${svc}
d381 1
a381 1
		if svc_is_special ${svc}; then
@


1.52
log
@add_flags() does not need any action argument.
Use the flags variable instead of hardcoding the output in preparation for
further subcommands.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.51 2014/12/24 13:04:43 ajacoutot Exp $
d374 1
a374 1
			echo ${pkg_scripts}
@


1.51
log
@Implement some kind ordering in the startup of package script daemons.
'rcctl order ...' will prepend the daemon(s) given as argument to the
pkg_scripts line (it can be all daemons, some, or just one).
Without argument, it'll display the current order.

While here, drop a couple of examples from the man page to only leave
the most interesting one.

ok schwarze@@ rpe@@ (with tweaks) jasper@@ robert@@ sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.50 2014/12/23 10:07:44 ajacoutot Exp $
d243 1
a243 1
	local _svc=$2
d258 2
a259 2
	if [ -n "$3" ]; then
		shift 3
d338 1
a338 1
			_rc_err "${0##*/}: \"flags\" can only be set with \"enable\""
d341 1
a341 1
			_rc_err "${0##*/}: \"${svc}\" is a special variable, cannot set \"flags\""
d343 2
a344 2
		if [ "${flags}" = "NO" ]; then
			_rc_err "${0##*/}: \"flags NO\" contradicts \"enable\""
d364 1
a364 1
		add_flags ${action} ${svc} "${flag}" "${flags}"
@


1.50
log
@Consistency: put variables between curly braces.
No functional change intended.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.49 2014/11/01 13:59:42 ajacoutot Exp $
d30 2
a31 2
	_rc_err "usage: ${0##*/} [-df] enable|disable|status|default|action
             [service | daemon [flags [arguments]]]"
d205 22
d317 9
a325 4
svc=$2
flag=$3
[ $# -ge 3 ] && shift 3 || shift $#
flags="$*"
d331 1
a331 1
elif [ "${action}" != "default" -a "${action}" != "status" ] ; then
d367 8
@


1.49
log
@Simplify.

with and ok schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.48 2014/10/31 09:07:48 ajacoutot Exp $
d300 3
a302 3
if [ -n "$svc" ]; then
	if ! svc_is_avail $svc; then
		_rc_err "${0##*/}: service $svc does not exist" 2
d304 1
a304 1
elif [ "$action" != "default" -a "$action" != "status" ] ; then
d308 3
a310 3
if [ -n "$flag" ]; then
	if [ "$flag" = "flags" ]; then
		if [ "$action" != "enable" ]; then
d313 2
a314 2
		if svc_is_special $svc && [ -n "$flags" ]; then
			_rc_err "${0##*/}: \"$svc\" is a special variable, cannot set \"flags\""
d316 1
a316 1
		if [ "$flags" = "NO" ]; then
d324 1
a324 1
case $action in
d326 1
a326 1
		svc_get_defaults $svc
d329 3
a331 3
		needs_root $action
		if ! svc_is_base $svc && ! svc_is_special $svc; then
			rm_from_pkg_scripts $svc
d333 1
a333 1
		rm_flags $svc
d336 4
a339 4
		needs_root $action
		add_flags $action $svc "$flag" "$flags"
		if ! svc_is_base $svc && ! svc_is_special $svc; then
			append_to_pkg_scripts $svc
d343 1
a343 1
		svc_get_status $svc
d346 2
a347 2
		if svc_is_special $svc; then
			_rc_err "${0##*/}: \"$svc\" is a special variable, no rc.d(8) script"
d349 1
a349 1
		/etc/rc.d/$svc ${_RC_DEBUG} ${_RC_FORCE} $action
@


1.48
log
@Make default output matches status. Hackish but we are not allowed to
use svc_default_enabled_flags like any other function...
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.46 2014/10/27 21:24:26 rpe Exp $
d103 1
a103 3
		# XXX would be much simpler to just do that:
		#svc_default_enabled_flags ${_svc}
		print -r -- "$(svc_default_enabled_flags ${_svc})" | sed '/^$/d'
@


1.47
log
@Useless use of sed(1).

ok swartze@@
@
text
@d103 3
a105 1
		print -r -- "$(svc_default_enabled_flags ${_svc})"
@


1.46
log
@Ensure proper separation of grep's options and rcctl options that
may end up in ${svc} by mistake.

OK ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.45 2014/10/15 07:38:24 ajacoutot Exp $
d135 1
a135 1
		print -r -- "${daemon_flags}" | sed '/^$/d'
@


1.45
log
@Add a new ls_rcscripts() function to properly get all rc.d(8) scripts
ignoring irrelevant stuffs under /etc/rc.d.

reworked based on a submission from Craig R. Skinner
ok schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.44 2014/10/13 19:06:53 schwarze Exp $
d126 1
a126 1
			if ! echo ${pkg_scripts} | grep -qw ${_svc}; then
d171 1
a171 1
	grep "^start_daemon " /etc/rc | cut -d ' ' -f2- | grep -qw ${_svc}
d187 1
a187 1
	echo ${_special_services} | grep -qw ${_svc}
d198 1
a198 1
	elif ! echo ${pkg_scripts} | grep -qw ${_svc}; then
@


1.44
log
@Carefully quote the flags argument such that leading blank characters
are preserved in all situations; this is relevant such that for
example 'rcctl enable identd flags " "' puts 'identd_flags=" "'
into /etc/rc.conf.local and subsequent 'rcctl enable identd' without
flags keeps it intact instead of stripping it down to 'identd_flags='.
ok ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.43 2014/10/11 19:12:19 schwarze Exp $
d39 10
d106 1
a106 1
		for _i in $(ls -A /etc/rc.d | grep -v rc.subr); do
d147 1
a147 1
		for _i in $(ls -A /etc/rc.d | grep -v rc.subr); do
@


1.43
log
@Fix a small bug in  rcctl status <daemon>:
If the daemon has default flags in its rc.d(8) script
but its flags are explicitly set to =" " in rc.conf.local(8),
the default flags were erroneously displayed.  Show " " instead.
ok ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.42 2014/10/11 13:42:49 ajacoutot Exp $
d228 1
a228 1
		_flags=$*
d231 1
a231 1
		eval "_flags=\${${_svc}_flags}"
d241 3
d248 1
a248 1
		echo ${_svc}_flags=${_flags} >>${_TMP_RCCONF}
d287 2
a288 1
flags=$*
d303 1
a303 1
		if svc_is_special $svc && [ -n "$4" ]; then
d306 1
a306 1
		if [ "$4" = "NO" ]; then
d327 1
a327 1
		add_flags $flags
@


1.42
log
@Add a new "default" command to  display the default flags and whether a
service is enabled or disabled by default.

idea from Patrik Lundin
discussed with and ok schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.41 2014/10/10 15:59:36 ajacoutot Exp $
d121 1
a121 1
			daemon_flags="$(eval echo \${${_svc}_flags})"
@


1.41
log
@Actually use built-in print like rc.subr already does.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.40 2014/10/10 15:42:30 ajacoutot Exp $
d30 1
a30 1
	_rc_err "usage: ${0##*/} [-df] enable|disable|status|action
d72 1
a72 2
# for security reason and to prevent namespace pollution, only call in a
# subshell against base system daemons or disabled package scripts
d78 25
a102 4
	FUNCS_ONLY=1
	rc_cmd() { }
	. /etc/rc.d/${_svc} >/dev/null 2>&1
	[ -n "${daemon_flags}" ] && print -r -- ${daemon_flags}
d125 1
a125 1
		print -r -- ${daemon_flags} | sed '/^$/d'
d290 1
a290 1
elif [ "$action" != "status" ]; then
d311 3
@


1.40
log
@Use printf(1) to prevent '-e' in daemon_flags from being fed as an
argument to the built-in echo.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.39 2014/10/10 07:27:44 ajacoutot Exp $
d82 1
a82 1
	[ -n "${daemon_flags}" ] && printf "%s\n" ${daemon_flags}
d105 1
a105 1
		printf "%s\n" ${daemon_flags} | sed '/^$/d'
@


1.39
log
@Allow passing flags without arguments for special variables.

initial request and patch from Patrik Lundin
simpler patch from and ok schwartze@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.38 2014/09/01 18:01:55 ajacoutot Exp $
d82 1
a82 1
	[ -n "${daemon_flags}" ] && echo ${daemon_flags}
d105 1
a105 1
		echo ${daemon_flags} | sed '/^$/d'
@


1.38
log
@Fix evil typo.

from wbyte via Bryan Steele
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.37 2014/08/31 10:44:37 ajacoutot Exp $
d279 1
a279 1
		if svc_is_special $svc; then
@


1.37
log
@Add Ingo's copyright as per his request.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.36 2014/08/31 07:08:25 ajacoutot Exp $
d103 1
a103 1
			deamon_flags="$(svc_default_enabled_flags ${_svc})"
@


1.36
log
@No need to update daemon_flags in the enviroment anymore since the
recent change to append_to_pkg_scripts().
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.35 2014/08/30 20:37:46 ajacoutot Exp $
d6 1
@


1.35
log
@When a service is not available, return ENOENT.
Previous to this commit it was not possible to know whether a service
existed without parsing the output of 'rcctl status' which is very
expensive.

req. by armani@@
ok robert@@ schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.34 2014/08/29 21:04:37 schwarze Exp $
a226 3

	# update daemon_flags
	eval "${_svc}_flags=\${_flags}"
@


1.34
log
@Additional input validation:
Error out on "rcctl enable daemon flags NO".
Without this check, this "enable" command effectively disabled the daemon.
"commit" ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.33 2014/08/29 20:21:13 schwarze Exp $
d270 1
a270 1
		_rc_err "${0##*/}: service $svc does not exist"
@


1.33
log
@Simplify append_to_pkg_scripts(), in particular avoid the expensive
svc_is_enabled() and look at ${pkg_scripts} only, flags are not
relevant to this function.
"please commit" ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.32 2014/08/28 14:51:16 ajacoutot Exp $
d283 3
@


1.32
log
@Drop check and tweak comment.

with schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.31 2014/08/28 07:53:07 ajacoutot Exp $
a163 2
	svc_is_enabled ${_svc} && return

d165 3
a167 1
	if [ -n "${pkg_scripts}" ]; then
a169 2
	else
		echo pkg_scripts="${_svc}" >>${_TMP_RCCONF}
@


1.31
log
@Simplify.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.30 2014/08/28 06:52:57 ajacoutot Exp $
d71 2
a72 2
# For security reasons, only call this if the service is enabled.
# To avoid namespace pollution, only call it in a subshell.
a76 1
	svc_is_special ${_svc} && return
@


1.30
log
@Consistency in conditionals; no functional change.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.29 2014/08/27 23:50:45 schwarze Exp $
d35 1
a35 3
	if [ "$(id -u)" -ne 0 ]; then
		_rc_err "${0##*/} $1: need root privileges"
	fi
a263 1

@


1.29
log
@Disentangle svc_default_enabled_flags() and svc_get_flags().
This saves three expensive function calls in svc_default_enabled_flags(),
two to _rc_parse_conf() and one to svc_get_flags().  No functional change.
Feedback and ok ajacoutot@@.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.28 2014/08/26 22:39:09 schwarze Exp $
d133 1
a133 1
	[ "${_svc}" == "rc.subr" ] && return 1
d151 1
a151 1
	[[ "$(svc_get_flags ${_svc})" != "NO" ]]
d216 1
a216 1
		[[ "${_flags}" = "NO" ]] && unset _flags
d221 1
a221 1
		[[ "${_flags}" = "$(svc_default_enabled_flags ${_svc})" ]] && \
@


1.28
log
@Simplify the function add_flags().
Do not validate input twice, scrap needless array, and avoid needless
expensive function calls to svc_get_flags(), svc_default_enabled_flags(),
_rc_parse_conf(), and resolve code duplication.  No functional change.
Feedback and OK ajacoutot@@.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.27 2014/08/25 23:15:37 schwarze Exp $
d73 2
d79 1
d81 4
a84 5
	_rc_parse_conf /etc/rc.conf
	pkg_scripts=${_svc}
	unset ${_svc}_flags
	echo $(svc_get_flags ${_svc})
	_rc_parse_conf
a103 1
		# rc.d shell script: no other way to get "${daemon_flags}"
d105 1
a105 6
			daemon_flags=$(
				FUNCS_ONLY=1
				rc_cmd() { }
				. /etc/rc.d/${_svc} >/dev/null 2>&1
				echo ${daemon_flags}
			)
@


1.27
log
@Base system special services have no flags, so move the test for them
up front in add_flags().  This avoids unnecessary work, avoids setting
bogus variables, and reduces the risk of screwing up things when changing
the code.  No functional change right now.
ok ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.26 2014/08/25 21:34:34 schwarze Exp $
d212 1
a212 3
	local _deflags _flags _numargs=$#

	_deflags="$(svc_default_enabled_flags ${_svc})"
d215 2
a216 10
		# there is an early check for this; but this function is fed with $*
		[ "$3" = "flags" ] || return
		if [ -n "$4" ]; then
			while [ "${_numargs}" -ge 4 ]
			do
				eval _flags=\"\$${_numargs} ${_flags}\"
				let _numargs--
			done
			set -A _flags -- ${_flags}
		fi
d218 3
a220 5
		# set our flags since none was given
		set -A _flags -- $(svc_get_flags ${_svc})
		if [[ "${_flags[@@]}" = "NO" ]]; then
			set -A _flags -- ${_deflags}
		fi
d224 3
a226 2
	if [[ "${_deflags}" = "${_flags[@@]}" ]]; then
		unset _flags
d229 5
a233 14
	if svc_is_base ${_svc}; then
		rcconf_edit_begin
		grep -v "^${_svc}_flags.*=" /etc/rc.conf.local >${_TMP_RCCONF}
		if ! svc_default_enabled ${_svc} || test "${#_flags[*]}" -gt 0; then
			echo ${_svc}_flags=${_flags[@@]} >>${_TMP_RCCONF}
		fi
		rcconf_edit_end
	else
		rcconf_edit_begin
		grep -v "^${_svc}_flags.*=" /etc/rc.conf.local >${_TMP_RCCONF}
		if [ "${#_flags[*]}" -gt 0 ]; then
			echo ${_svc}_flags=${_flags[@@]} >>${_TMP_RCCONF}
		fi
		rcconf_edit_end
d235 1
d238 1
a238 3
	unset ${_svc}_flags
	_rc_parse_conf
	eval ${_svc}_flags=\"$(svc_get_flags ${_svc})\"
@


1.26
log
@get rid of the tempfile in svc_default_enabled_flags();
feedback and ok ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.25 2014/08/25 21:06:46 ajacoutot Exp $
d201 11
d240 1
a240 8
	if svc_is_special ${_svc}; then
		rcconf_edit_begin
		grep -v "^${_svc}.*=" /etc/rc.conf.local >${_TMP_RCCONF}
		if ! svc_default_enabled ${_svc}; then
			echo "${_svc}=YES" >>${_TMP_RCCONF}
		fi
		rcconf_edit_end
	elif svc_is_base ${_svc}; then
@


1.25
log
@rc.d scripts are shell scripts and need to be sourced in svc_get_flags().
It's the only way to get daemon_flags in case it contains line
continuation... We only need to do that for enable package scripts.

original idea from Sebastien Marie
discussed with, input from and ok schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.24 2014/08/25 19:01:26 ajacoutot Exp $
a76 1
	local _tmp=$(mktemp -t rcctl-deflags.XXXXXXXXXX) || exit 1
d78 3
a80 4
	echo "pkg_scripts=${_svc}" >${_tmp}
	echo "${_svc}_flags=" >>${_tmp}
	_rc_parse_conf /etc/rc.conf ${_tmp}
	rm ${_tmp}
@


1.24
log
@For functions that take args, return immediately if no args is passed.
Add/drop missing/unused local variables.

no functionnal change
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.23 2014/08/25 18:50:22 ajacoutot Exp $
d104 1
d106 7
a112 1
			eval $(grep '^daemon_flags=' /etc/rc.d/${_svc})
@


1.23
log
@Cope with some weird rc.conf.local file like "foobar" in pkg_scripts
while "foobar_flags" is set to "NO"...
Reparse deamon_flags at the end of add_flags() since they may have been
modified by the function.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.22 2014/08/25 14:29:18 schwarze Exp $
a61 1
	local _ret=1
d64 1
a74 1
	local _tmp=$(mktemp -t rcctl-deflags.XXXXXXXXXX) || exit 1
d77 1
a88 1
	local daemon_flags
d91 1
d112 1
a112 1
	local _affix _svc=$1
a146 1
	local _flags _i
a193 1
	local _deflags _flags _numargs=$#
d196 1
@


1.22
log
@Simplify rm_from_pkg_scripts(); minus ten lines; no functional change;
ok ajacoutot@@.

For non-trivial automated text editing in sh(1), thou shalt use sed(1).
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.21 2014/08/25 07:35:37 ajacoutot Exp $
d73 14
d96 1
a96 2
		daemon_flags="$(eval echo \${${_svc}_flags})"
		# reset flags for pkg daemon to match the output of base/special svc
d99 1
a99 1
				daemon_flags="NO"
d102 3
a104 1
		if [ -z "${daemon_flags}" ]; then
d106 1
a106 2
		fi
		echo ${daemon_flags}
d115 1
a115 1
		svc_get_flags ${_svc} | sed '/^$/d'
d195 1
a195 1
	local _flags _numargs=$#
d199 2
d212 5
a216 8
	elif svc_is_enabled ${_svc}; then
		# svc is already enabled and flags are not (re)set: return unless
		# svc is enabled by default and our current flags are not empty
		# (if they are, we drop the default "svc_flags=" further down)
		if ! svc_default_enabled ${_svc}; then
			return
		elif [ -n "$(svc_get_flags ${_svc})" ]; then
			return
d220 5
a224 1
	# special var
d232 1
a232 5
		return
	fi

	# base-system script
	if svc_is_base ${_svc}; then
d239 7
a245 1
		return
d248 4
a251 7
	# pkg script
	rcconf_edit_begin
	grep -v "^${_svc}_flags.*=" /etc/rc.conf.local >${_TMP_RCCONF}
	if [ "${#_flags[*]}" -gt 0 ]; then
		echo ${_svc}_flags=${_flags[@@]} >>${_TMP_RCCONF}
	fi
	rcconf_edit_end
@


1.21
log
@Display usage on 2 lines.

reworked from an original diff by schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.20 2014/08/24 19:44:02 schwarze Exp $
a166 1
	local _i _pkg_scripts
a171 8
	for _i in ${pkg_scripts}; do
		if [ ${_i} != ${_svc} ]; then
			_pkg_scripts="${_pkg_scripts} ${_i}"
		fi
	done
	pkg_scripts=$(printf ' %s' ${_pkg_scripts})
	pkg_scripts=${_pkg_scripts## }

d173 3
a175 4
	grep -v "^pkg_scripts.*=" /etc/rc.conf.local >${_TMP_RCCONF}
	if [ -n "${pkg_scripts}" ]; then
		echo pkg_scripts="${pkg_scripts}" >>${_TMP_RCCONF}
	fi
@


1.20
log
@Delete the function svc_get_all().
In svc_is_avail(), this simplifies the code by getting rid of the loop.
When running "rcctl status", this allows to not run svc_is_special() -
which spawns a grep - for each and every service, resulting in a 20%
speedup.  As a bonus, we get the special services listed at the end,
where they are easier to see than mixed in with the daemons.
ok ajacoutot@@ jasper@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.19 2014/08/24 19:00:46 schwarze Exp $
d29 2
a30 1
	_rc_err "usage: ${0##*/} [-df] enable|disable|status|action [service | daemon [flags [...]]]"
@


1.19
log
@Whitelisting allowed services is safer and less confusing than
blacklisting auxiliary variables, and it makes the coupling
to rc.subr(8) less tight.
Feedback and OK ajacoutot@@.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.18 2014/08/24 18:10:26 schwarze Exp $
a71 12
svc_get_all()
{
	local _i

	(
		ls -A /etc/rc.d | grep -v rc.subr
		for _i in ${_special_services}; do
			echo ${_i}
		done
	) | sort
}

d103 5
a107 3
		for _i in $(svc_get_all); do
			svc_is_special ${_i} && unset _affix || _affix="_flags"
			echo "${_i}${_affix}=$(svc_get_flags ${_i})"
d114 2
a115 1
	local _i
d117 3
a119 6
	for _i in $(svc_get_all); do
		if [ ${_i} = "$1" ]; then
			return 0
		fi
	done
	return 1
@


1.18
log
@Start all error messages with "rcctl: " such that it is clear where
they come from.  While here, there is no need to check the argument
of needs_root() before displaying it, it is always provided.
ok ajacoutot@@ jasper@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.17 2014/08/24 17:52:38 ajacoutot Exp $
d19 3
d78 1
a78 1
		for _i in ${_allowed_keys[@@]}; do
d80 1
a80 1
		done | grep -Ev '(nfs_server|savecore_flag|amd_master|pf_rules|ipsec_rules|shlib_dirs|pkg_scripts)'
d156 1
a156 1
	echo ${_allowed_keys[@@]} | grep -qw ${_svc}
@


1.17
log
@Add a comment to unconfuse Ingo :-)
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.16 2014/08/24 17:01:44 ajacoutot Exp $
d32 1
a32 1
		_rc_err "${0##*/} ${1:+$1: }need root privileges"
d295 1
a295 1
		_rc_err "service $svc does not exist"
d304 1
a304 1
			_rc_err "\"flags\" can only be set with \"enable\""
d307 1
a307 1
			_rc_err "\"$svc\" is a special variable, cannot set \"flags\""
d334 1
a334 1
			_rc_err "\"$svc\" is a special variable, no rc.d(8) script"
@


1.16
log
@Drop obvious comments.
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.15 2014/08/24 13:46:57 schwarze Exp $
d40 1
@


1.15
log
@reduce indentation of main program by one tab, no functional change
ok ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.14 2014/08/24 08:13:15 ajacoutot Exp $
a60 1
	# get _defaults_ values only
a61 1

a62 2

	# reparse _all_ values
@


1.14
log
@Fix args to needs_root() when using "disable" (broken in the v1.9
positional args cleanup commit).

from Sebastien Marie
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.13 2014/08/24 07:46:54 ajacoutot Exp $
d289 2
d296 12
a307 4
if [ $# -gt 0 ]; then
	if [ -n "$svc" ]; then
		if ! svc_is_avail $svc; then
			_rc_err "service $svc does not exist"
d309 4
a312 1
	elif [ "$action" != "status" ]; then
a314 42
	if [ -n "$flag" ]; then
		if [ "$flag" = "flags" ]; then
			if [ "$action" != "enable" ]; then
				_rc_err "\"flags\" can only be set with \"enable\""
			fi
			if svc_is_special $svc; then
				_rc_err "\"$svc\" is a special variable, cannot set \"flags\""
			fi
		else
			usage
		fi
	fi
	case $action in
		disable)
			needs_root $action
			if ! svc_is_base $svc && ! svc_is_special $svc; then
				rm_from_pkg_scripts $svc
			fi
			rm_flags $svc
			;;
		enable)
			needs_root $action
			add_flags $flags
			if ! svc_is_base $svc && ! svc_is_special $svc; then
				append_to_pkg_scripts $svc
			fi
			;;
		status)
			svc_get_status $svc
			;;
		start|stop|restart|reload|check)
			if svc_is_special $svc; then
				_rc_err "\"$svc\" is a special variable, no rc.d(8) script"
			fi
			/etc/rc.d/$svc ${_RC_DEBUG} ${_RC_FORCE} $action
			;;
		*)
			usage
			;;
	esac
else
	usage
d316 29
@


1.13
log
@Since rcctl(8) can changes the position of such and such variable, sort
the file so that we always have a consistent output.

ok schwarze@@ jasper@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.12 2014/08/24 07:33:26 ajacoutot Exp $
d316 1
a316 1
			needs_root $svc
@


1.12
log
@Make it possible to pass `-d' and `-f' to the rc.d(8) script.

man page bits from schwarze@@
ok jasper@@ schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: rcctl.sh,v 1.11 2014/08/21 14:26:16 jsg Exp $
d48 1
@


1.11
log
@add $OpenBSD$
@
text
@d3 1
a3 1
# $OpenBSD$
d26 1
a26 1
	_rc_err "usage: ${0##*/} enable|disable|status|action [service | daemon [flags [...]]]"
d278 10
d335 1
a335 1
			/etc/rc.d/$svc $action
@


1.10
log
@Make "rcctl status" output match rc.conf(8) format.

ok jasper@@
@
text
@d3 2
@


1.9
log
@If a service is disabled its flags are unconditionally set to "NO", so
there's not need to display "enabled" or "disabled" when calling "status",
we have the information already.
@
text
@d106 1
a106 1
	local _svc=$1
d113 2
a114 3
			printf "%18s" ${_i}
			echo -n "\tflags="
			svc_get_flags ${_i}
@


1.8
log
@Store the positional args in vars with meaningful names which makes the arg
checking block easier to comprehend.

OK ajacoutot@@
@
text
@a113 1
			svc_is_enabled ${_i} && echo -n "(enabled)" || echo -n "(disabled)"
@


1.7
log
@Greatly simplify get/set flags and status.

Provide a unified output for the status of disabled services/daemons:
foobar_flags will always be "NO" regardless of the type (pkg script,
base system daemon, special variable).
@
text
@d278 5
d284 3
a286 3
	if [ -n "$2" ]; then
		if ! svc_is_avail $2; then
			_rc_err "service $2 does not exist"
d288 1
a288 1
	elif [ "$1" != "status" ]; then
d291 3
a293 3
	if [ -n "$3" ]; then
		if [ "$3" = "flags" ]; then
			if [ "$1" != "enable" ]; then
d296 2
a297 2
			if svc_is_special $2; then
				_rc_err "\"$2\" is a special variable, cannot set \"flags\""
d303 1
a303 1
	case $1 in
d305 3
a307 3
			needs_root $1
			if ! svc_is_base $2 && ! svc_is_special $2; then
				rm_from_pkg_scripts $2
d309 1
a309 1
			rm_flags $2
d312 4
a315 4
			needs_root $1
			add_flags $*
			if ! svc_is_base $2 && ! svc_is_special $2; then
				append_to_pkg_scripts $2
d319 1
a319 1
			svc_get_status $2
d322 2
a323 2
			if svc_is_special $2; then
				_rc_err "\"$2\" is a special variable, no rc.d(8) script"
d325 1
a325 1
			/etc/rc.d/$2 $1
@


1.6
log
@Drop default values from rc.conf.local when we run "enable".
@
text
@a68 20
svc_default_flags()
{
	local daemon_flags
	local _svc=$1
	[ -n "${_svc}" ] || return

	# get _defaults_ values only
	_rc_parse_conf /etc/rc.conf

	if svc_is_base ${_svc} || svc_is_special ${_svc}; then
		svc_get_flags ${_svc}
	else
		eval $(grep '^daemon_flags=' /etc/rc.d/${_svc})
		echo ${daemon_flags}
	fi

	# reparse _all_ values
	_rc_parse_conf
}

d89 1
a89 1
	elif ! svc_is_base ${_svc}; then
d91 6
a100 2
	else
		echo "$(eval echo \${${_svc}_flags})"
d147 1
a147 15
	if svc_is_base ${_svc}; then
		eval _flags=\${${_svc}_flags}
		if [ "${_flags}" != "NO" ]; then
			return
		fi
	elif svc_is_special ${_svc}; then
		eval _flags=\${${_svc}}
		if [ "${_flags}" != "NO" ]; then
			return
		fi
	else
		echo ${pkg_scripts} | grep -qw ${_svc} && return
	fi

	return 1
d217 8
a224 4
		# we did not (re)set the flags: stop here if svc is already
		# enabled and our current flags do not match the default ones;
		# if they do, we drop the default "svc_flags=" further down
		[[ "$(svc_default_flags ${_svc})" != "$(svc_get_flags ${_svc})" ]] && return
d253 1
a253 2
		[[ "${_flags[@@]}" != "$(svc_default_flags ${_svc})" ]] && \
			echo ${_svc}_flags=${_flags[@@]} >>${_TMP_RCCONF}
@


1.5
log
@unify the declaration of functions.
ok aja@@
@
text
@d64 1
a64 1
	svc_is_base ${_svc} && _rc_parse_conf
d69 20
d247 4
a250 2
		# svc is already enabled and we did not (re)set the flags
		return
d279 2
a280 1
		echo ${_svc}_flags=${_flags[@@]} >>${_TMP_RCCONF}
@


1.4
log
@Sync usage.
@
text
@d22 2
a23 1
usage() {
d34 2
a35 1
rcconf_edit_begin() {
d44 2
a45 1
rcconf_edit_end() {
d52 2
a53 1
svc_default_enabled() {
d81 2
a82 1
svc_get_flags() {
d100 2
a101 1
svc_get_status() {
@


1.3
log
@Simplify some checks
Return immediatly from add_flags() if we are already enabled and no flags
are (re)set; unbreak "enable" under some circumstances.
@
text
@d23 1
a23 1
	_rc_err "usage: ${0##*/} enable|disable|status|action [service [flags [...]]]"
@


1.2
log
@Drop commented code.
@
text
@d209 3
a211 1
	if [ -n "$3" -a "$3" = "flags" ]; then
d220 3
a222 3
	elif svc_is_base ${_svc}; then
		# base svc: save current flags because they are reset below
		set -A _flags --  $(eval echo \${${_svc}_flags})
d248 4
a251 7
	if [ -n "$3" -a "$3" = "flags" ]; then
		rcconf_edit_begin
		grep -v "^${_svc}_flags.*=" /etc/rc.conf.local >${_TMP_RCCONF}
		if [ "${#_flags[*]}" -gt 0 ]; then
			echo ${_svc}_flags=${_flags[@@]} >>${_TMP_RCCONF}
		fi
		rcconf_edit_end
d253 1
@


1.1
log
@Introduce rcctl(8), a simple utility for maintaining rc.conf.local(8).

# rcctl
usage: rcctl enable|disable|status|action [service [flags [...]]]

Lots of man page improvement from the usual suspects (jmc@@ and schwarze@@)
not hooked up yet but committing now so work can continue in-tree
agreed by several
@
text
@a208 6
	# svc is already enabled and we did not (re)set the flags
	#if svc_is_enabled "${_svc}" && test -z "$3"; then
	#	return
	#fi

	#if [ -n "$3" -a "$3" = "flags" -a -n "$4" ]; then
@

