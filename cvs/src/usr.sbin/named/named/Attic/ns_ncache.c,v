head	1.6;
access;
symbols
	OPENBSD_3_2:1.4.0.18
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.16
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.14
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2003.02.21.08.59.45;	author jakob;	state dead;
branches;
next	1.5;

1.5
date	2002.11.14.02.54.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.05.22.07.09.17;	author millert;	state Exp;
branches
	1.4.14.1
	1.4.16.1
	1.4.18.1;
next	1.3;

1.3
date	98.05.22.00.47.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.03.12.10.42.32;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.02.19.19.54.23;	author dm;	state Exp;
branches;
next	;

1.4.14.1
date	2002.11.14.23.44.14;	author millert;	state Exp;
branches;
next	;

1.4.16.1
date	2002.11.14.23.34.39;	author millert;	state Exp;
branches;
next	;

1.4.18.1
date	2002.11.14.23.50.10;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@remove bind4; ok deraadt@@
@
text
@/*	$OpenBSD: ns_ncache.c,v 1.5 2002/11/14 02:54:22 millert Exp $	*/

/**************************************************************************
 * ns_ncache.c
 * author: anant kumar
 * last modification: March 17, 1993
 *
 * implements negative caching
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <syslog.h>
#include <errno.h>
#include <stdio.h>
#include <resolv.h>

#include "named.h"

#ifdef NCACHE

#define BOUNDS_CHECK(ptr, count) \
	do { \
		if ((ptr) + (count) > eom) { \
			return; \
		} \
	} while (0)

void
cache_n_resp(msg, msglen)
	u_char *msg;
	int msglen;
{
	register struct databuf *dp;
	HEADER *hp;
	u_char *cp, *eom, *rdatap;
	char dname[MAXDNAME];
	int n;
	int type, class;
#ifdef VALIDATE
	int Vcode;
#endif
	int flags;
	u_int dlen;

	nameserIncr(from_addr.sin_addr, nssRcvdNXD);

	hp = (HEADER *)msg;
	cp = msg+HFIXEDSZ;
	eom = msg + msglen;
  
	n = dn_expand(msg, eom, cp, dname, sizeof dname);
	if (n < 0) {
		dprintf(1, (ddt, "Query expand name failed:cache_n_resp\n"));
		hp->rcode = FORMERR;
		return;
	}
	cp += n;
	BOUNDS_CHECK(cp, 2 * INT16SZ);
	GETSHORT(type, cp);
	GETSHORT(class, cp);
	dprintf(1, (ddt,
		    "ncache: dname %s, type %d, class %d\n",
		    dname, type, class));

#ifdef VALIDATE
	Vcode = validate(dname, dname, &from_addr, type, class, NULL, 0,
			 hp->rcode == NXDOMAIN ? NXDOMAIN : NOERROR_NODATA);
	if (Vcode == INVALID || Vcode == VALID_NO_CACHE) {
		/*Valid_no_cache should never occur but doesn't hurt to check*/
		return;
	}
#endif
#ifdef RETURNSOA
	if (hp->nscount) {
		u_int32_t ttl;
		u_int16_t atype;
		u_char *tp = cp;
		u_char *cp1;
		u_char data[MAXDATA];
		u_char *eod = data + sizeof(data);

		/* we store NXDOMAIN as T_SOA regardless of the query type */
		if (hp->rcode == NXDOMAIN)
			type = T_SOA;

		/* store their SOA record */
		n = dn_skipname(tp, eom);
		if (n < 0) {
			dprintf(3, (ddt, "ncache: form error\n"));
			return;
		}
		tp += n;
		BOUNDS_CHECK(tp, 3 * INT16SZ + INT32SZ);
		GETSHORT(atype, tp);		/* type */
		if (atype != T_SOA) {
			dprintf(3, (ddt,
				    "ncache: type (%d) != T_SOA\n",atype));
			goto no_soa;
		}
		tp += INT16SZ;		/* class */
		GETLONG(ttl, tp);	/* ttl */
		GETSHORT(dlen, tp);	/* dlen */
		BOUNDS_CHECK(tp, dlen);
		rdatap = tp;

		/* origin */
		n = dn_expand(msg, eom, tp, (char*)data, eod - data);
		if (n < 0) {
			dprintf(3, (ddt, "ncache: form error 2\n"));
			return;
		}
		tp += n;
		n = strlen((char*)data) + 1;
		cp1 = data + n;
		/* mail */
		n = dn_expand(msg, msg + msglen, tp, (char*)cp1, eod - cp1);
		if (n < 0) {
			dprintf(3, (ddt, "ncache: form error 2\n"));
			return;
		}
		tp += n;
		n = strlen((char*)cp1) + 1;
		cp1 += n;
		n = 5 * INT32SZ;
		if (n > (eod - cp1))	/* Can't happen. See MAXDATA. */
			return;
		BOUNDS_CHECK(tp, n);
		bcopy(tp, cp1, n);
		/* serial, refresh, retry, expire, min */
		cp1 += n;
		tp += n;
		if (tp != rdatap + dlen) {
			dprintf(3, (ddt, "ncache: form error 2\n"));
			return;
		}
		/* store the zone of the soa record */
		n = dn_expand(msg, msg + msglen, cp, (char*)cp1, eod - cp1);
		if (n < 0) {
			dprintf(3, (ddt, "ncache: form error 2\n"));
			return;
		}
		n = strlen((char*)cp1) + 1;
		cp1 += n;

		dp = savedata(class, type, MIN(ttl, NTTL) + tt.tv_sec, data,
			      cp1 - data);
	} else {
 no_soa:
#endif
	dp = savedata(class, type, NTTL + tt.tv_sec, NULL, 0);
#ifdef RETURNSOA
	}
#endif
	dp->d_zone = DB_Z_CACHE;
	dp->d_cred = hp->aa ? DB_C_AUTH : DB_C_ANSWER;
	dp->d_clev = 0;
	if(hp->rcode == NXDOMAIN) {
		dp->d_rcode = NXDOMAIN;
		flags = DB_NODATA|DB_NOTAUTH|DB_NOHINTS;
	} else {
		dp->d_rcode = NOERROR_NODATA;
		flags = DB_NOTAUTH|DB_NOHINTS;
	}

	if ((n = db_update(dname, dp, dp, flags, hashtab)) != OK) {
		dprintf(1, (ddt,
			  "db_update failed return value:%d, cache_n_resp()\n",
			    n));
		db_free(dp);
		return;
	}
	dprintf(4, (ddt,
		    "ncache succeeded: [%s %s %s] rcode:%d ttl:%ld\n",
		    dname, p_type(type), p_class(class),
		    dp->d_rcode, (long)(dp->d_ttl-tt.tv_sec)));
	return;
}

#endif /*NCACHE*/
@


1.5
log
@Sync with bind-4.9.11-REL; fixes the problems listed in:
    http://www.isc.org/products/BIND/bind-security.html
including a buffer overflow that could lead to remote code execution.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ncache.c,v 1.4 1998/05/22 07:09:17 millert Exp $	*/
@


1.4
log
@bind 4.9.7 + -u, -g, and -t from bind 8.1.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ncache.c,v 1.3 1998/05/22 00:47:42 millert Exp $	*/
d84 2
a85 2
		u_char data[MAXDNAME*2 + INT32SZ*5];
		size_t len = sizeof data;
d112 1
a112 1
		n = dn_expand(msg, eom, tp, (char*)data, len);
a119 1
		len -= n;
d121 1
a121 1
		n = dn_expand(msg, msg + msglen, tp, (char*)cp1, len);
a128 1
		len -= n;
d130 2
a135 1
		len -= n;
d142 1
a142 1
		n = dn_expand(msg, msg + msglen, cp, (char*)cp1, len);
@


1.4.18.1
log
@Apply http://www.isc.org/products/BIND/patches/bind4910.diff
Fixes bugs listed in http://www.isc.org/products/BIND/bind-security.html
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ncache.c,v 1.4 1998/05/22 07:09:17 millert Exp $	*/
d84 2
a85 2
		u_char data[MAXDATA];
		u_char *eod = data + sizeof(data);
d112 1
a112 1
		n = dn_expand(msg, eom, tp, (char*)data, eod - data);
d120 1
d122 1
a122 1
		n = dn_expand(msg, msg + msglen, tp, (char*)cp1, eod - cp1);
d130 1
a131 2
		if (n > (eod - cp1))	/* Can't happen. See MAXDATA. */
			return;
d136 1
d143 1
a143 1
		n = dn_expand(msg, msg + msglen, cp, (char*)cp1, eod - cp1);
@


1.4.14.1
log
@Apply http://www.isc.org/products/BIND/patches/bind4910.diff
Fixes bugs listed in http://www.isc.org/products/BIND/bind-security.html
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ncache.c,v 1.4 1998/05/22 07:09:17 millert Exp $	*/
d84 2
a85 2
		u_char data[MAXDATA];
		u_char *eod = data + sizeof(data);
d112 1
a112 1
		n = dn_expand(msg, eom, tp, (char*)data, eod - data);
d120 1
d122 1
a122 1
		n = dn_expand(msg, msg + msglen, tp, (char*)cp1, eod - cp1);
d130 1
a131 2
		if (n > (eod - cp1))	/* Can't happen. See MAXDATA. */
			return;
d136 1
d143 1
a143 1
		n = dn_expand(msg, msg + msglen, cp, (char*)cp1, eod - cp1);
@


1.4.16.1
log
@Apply http://www.isc.org/products/BIND/patches/bind4910.diff
Fixes bugs listed in http://www.isc.org/products/BIND/bind-security.html
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ncache.c,v 1.4 1998/05/22 07:09:17 millert Exp $	*/
d84 2
a85 2
		u_char data[MAXDATA];
		u_char *eod = data + sizeof(data);
d112 1
a112 1
		n = dn_expand(msg, eom, tp, (char*)data, eod - data);
d120 1
d122 1
a122 1
		n = dn_expand(msg, msg + msglen, tp, (char*)cp1, eod - cp1);
d130 1
a131 2
		if (n > (eod - cp1))	/* Can't happen. See MAXDATA. */
			return;
d136 1
d143 1
a143 1
		n = dn_expand(msg, msg + msglen, cp, (char*)cp1, eod - cp1);
@


1.3
log
@bind 4.9.6, 4.9.7 comming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ncache.c,v 1.2 1997/03/12 10:42:32 downsj Exp $	*/
d26 7
d40 1
a40 1
	u_char *cp;
d48 1
d54 1
d56 1
a56 1
	n = dn_expand(msg, msg + msglen, cp, dname, sizeof dname);
d63 1
d91 2
a92 2
		/* store ther SOA record */
		n = dn_skipname(tp, msg + msglen);
d98 1
d107 3
a109 1
		tp += INT16SZ;		/* dlen */
d112 1
a112 1
		n = dn_expand(msg, msg + msglen, tp, (char*)data, len);
d131 3
a133 1
		bcopy(tp, cp1, n = 5 * INT32SZ);
d137 5
@


1.2
log
@BIND 4.9.5-P1.

libresolv and include are required until the new resolver gets integrated
into libc.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
		u_char data[BUFSIZ+MAXDNAME];
@


1.1
log
@netbsd: bind 4.9.3
@
text
@d1 1
a1 1
/*	$NetBSD: ns_ncache.c,v 1.1 1996/02/02 15:28:55 mrg Exp $	*/
d11 1
d37 1
d39 1
d69 61
a129 55
	if (hp->rcode==NXDOMAIN) {
	    u_int32_t ttl;
	    u_int16_t atype;
	    u_char * tp = cp;
	    u_char * cp1;
	    u_char data[BUFSIZ+MAXDNAME];
	    int len = sizeof(data);

	    /* store ther SOA record */
	    if (!hp->nscount) {
		dprintf(3, (ddt, "ncache: nscount == 0\n"));
		return;
	    }
	    n = dn_skipname(tp, msg + msglen);
	    if (n < 0) {
		dprintf(3, (ddt, "ncache: form error\n"));
		return;
	    }
	    tp += n;
	    GETSHORT(atype,tp);		/* type */
	    if (atype != T_SOA) {
		dprintf(3, (ddt, "ncache: type (%d) != T_SOA\n",atype));
		return;
	    }
	    tp += sizeof(u_int16_t);	/* class */
	    GETLONG(ttl,tp);		/* ttl */
	    tp += sizeof(u_int16_t);	/* dlen */

	    if ((n = dn_expand(msg, msg + msglen, tp, data, len))
			< 0 ) {
		dprintf(3, (ddt, "ncache: form error 2\n"));
		return;
	    }	/* origin */
	    tp += n;
	    cp1 = data + (n = strlen(data) + 1);
	    len -= n;
	    if ((n = dn_expand(msg, msg + msglen, tp, cp1, len)) < 0 ) {
		dprintf(3, (ddt, "ncache: form error 2\n"));
		return;
	    }	/* mail */
	    tp += n;
	    n = strlen(cp1) + 1;
	    cp1 +=  n;
	    len -= n;
	    bcopy(tp, cp1, n = 5 * sizeof(u_int32_t));
	    /* serial, refresh, retry, expire, min */
	    cp1 += n;
	    len -= n;
	    /* store the zone of the soa record */
	    if ((n = dn_expand(msg, msg + msglen, cp, cp1, len)) < 0 ) {
		dprintf(3, (ddt, "ncache: form error 2\n"));
		return;
	    }
	    n = strlen(cp1) + 1;
	    cp1 += n;
d131 2
a132 2
	    dp = savedata(class, T_SOA, MIN(ttl,NTTL)+tt.tv_sec, data,
			  cp1 - data);
d134 1
d136 1
a136 1
	dp = savedata(class, type, NTTL+tt.tv_sec, NULL, 0);
d151 1
a151 1
	if ((n = db_update(dname,dp,dp,flags,hashtab)) != OK) {
d155 1
a155 1
		free((char *)dp);
d159 1
a159 1
		    "ncache succeeded: [%s %s %s] rcode:%d ttl:%l\n",
@
