head	1.6;
access;
symbols
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.14
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.12
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.0.6
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2003.02.21.08.59.44;	author jakob;	state dead;
branches;
next	1.5;

1.5
date	2002.11.14.02.54.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.26.06.08.17;	author itojun;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	98.05.22.00.47.20;	author millert;	state Exp;
branches
	1.2.14.1;
next	1.1;

1.1
date	97.03.12.10.42.04;	author downsj;	state Exp;
branches;
next	;

1.2.14.1
date	2002.11.14.23.44.14;	author millert;	state Exp;
branches;
next	;

1.3.2.1
date	2002.11.14.23.34.39;	author millert;	state Exp;
branches;
next	;

1.4.2.1
date	2002.11.14.23.50.10;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@remove bind4; ok deraadt@@
@
text
@/*	$OpenBSD: getnetnamadr.c,v 1.5 2002/11/14 02:54:22 millert Exp $	*/

/* Copyright (c) 1993 Carlos Leandro and Rui Salgueiro
 *	Dep. Matematica Universidade de Coimbra, Portugal, Europe
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 */
/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)getnetbyaddr.c	8.1 (Berkeley) 6/4/93";
static char sccsid_[] = "from getnetnamadr.c	1.4 (Coimbra) 93/06/03";
static char rcsid[] = "$From: getnetnamadr.c,v 8.8 1997/06/01 20:34:37 vixie Exp $";
#else
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.5 2002/11/14 02:54:22 millert Exp $";
#endif
#endif /* LIBC_SCCS and not lint */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <stdio.h>
#include <netdb.h>
#include <resolv.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>

extern int h_errno;

#if defined(mips) && defined(SYSTYPE_BSD43)
extern int errno;
#endif

struct netent *_getnetbyaddr(long net, int type);
struct netent *_getnetbyname(const char *name);

#define BYADDR 0
#define BYNAME 1
#define	MAXALIASES	35

#if PACKETSZ > 1024
#define	MAXPACKET	PACKETSZ
#else
#define	MAXPACKET	1024
#endif

typedef union {
	HEADER	hdr;
	u_char	buf[MAXPACKET];
} querybuf;

typedef union {
	long	al;
	char	ac;
} align;

static struct netent *
getnetanswer(answer, anslen, net_i)
	querybuf *answer;
	int anslen;
	int net_i;
{

	register HEADER *hp;
	register u_char *cp;
	register int n;
	u_char *eom;
	int type, class, ancount, qdcount, haveanswer, i, nchar;
	char aux1[30], aux2[30], *in, *st, *pauxt, *bp, **ap,
		*paux1 = &aux1[0], *paux2 = &aux2[0], *ep;
	static	struct netent net_entry;
	static	char *net_aliases[MAXALIASES], netbuf[PACKETSZ];
	static  char ans[MAXDNAME];

	/*
	 * find first satisfactory answer
	 *
	 *      answer --> +------------+  ( MESSAGE )
	 *		   |   Header   |
	 *		   +------------+
	 *		   |  Question  | the question for the name server
	 *		   +------------+
	 *		   |   Answer   | RRs answering the question
	 *		   +------------+
	 *		   | Authority  | RRs pointing toward an authority
	 *		   | Additional | RRs holding additional information
	 *		   +------------+
	 */
	eom = answer->buf + anslen;
	hp = &answer->hdr;
	ancount = ntohs(hp->ancount); /* #/records in the answer section */
	qdcount = ntohs(hp->qdcount); /* #/entries in the question section */
	bp = netbuf;
	ep = netbuf + sizeof(netbuf);
	cp = answer->buf + HFIXEDSZ;
	if (!qdcount) {
		if (hp->aa)
			h_errno = HOST_NOT_FOUND;
		else
			h_errno = TRY_AGAIN;
		return (NULL);
	}
	while (qdcount-- > 0) {
		n = __dn_skipname(cp, eom);
		if (n < 0 || (cp + n + QFIXEDSZ) > eom) {
			h_errno = NO_RECOVERY;
			return(NULL);
		}
		cp += n + QFIXEDSZ;
	}
	ap = net_aliases;
	*ap = NULL;
	net_entry.n_aliases = net_aliases;
	haveanswer = 0;
	while (--ancount >= 0 && cp < eom) {
		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
		if ((n < 0) || !res_dnok(bp))
			break;
		cp += n;
		ans[0] = '\0';
		(void)strcpy(ans, bp);
		GETSHORT(type, cp);
		GETSHORT(class, cp);
		cp += INT32SZ;		/* TTL */
		GETSHORT(n, cp);
		if (class == C_IN && type == T_PTR) {
			n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
			if ((n < 0) || !res_hnok(bp)) {
				cp += n;
				return (NULL);
			}
			cp += n; 
			if ((ap + 2) < &net_aliases[MAXALIASES]) {
				*ap++ = bp;
				bp += strlen(bp) + 1;
				net_entry.n_addrtype =
					(class == C_IN) ? AF_INET : AF_UNSPEC;
				haveanswer++;
			}
		}
	}
	if (haveanswer) {
		*ap = NULL;
		switch (net_i) {
		case BYADDR:
			net_entry.n_name = *net_entry.n_aliases;
			net_entry.n_net = 0L;
			break;
		case BYNAME:
			ap = net_entry.n_aliases;
		next_alias:
			in = *ap++;
			if (in == NULL) {
				h_errno = HOST_NOT_FOUND;
				return (NULL);
			}
			net_entry.n_name = ans;
			aux2[0] = '\0';
			for (i = 0; i < 4; i++) {
				for (st = in, nchar = 0;
				     isdigit((unsigned char)*st);
				     st++, nchar++)
					;
				if (*st != '.' || nchar == 0 || nchar > 3)
					goto next_alias;
				if (i != 0)
					nchar++;
				(void)strncpy(paux1, in, nchar);
				paux1[nchar] = '\0';
				pauxt = paux2;
				paux2 = strcat(paux1, paux2);
				paux1 = pauxt;
				in = ++st;
			}		  
			if (strcasecmp(in, "IN-ADDR.ARPA") != 0)
				goto next_alias;
			net_entry.n_net = inet_network(paux2);
			break;
		}
		net_entry.n_aliases++;
		return (&net_entry);
	}
	h_errno = TRY_AGAIN;
	return (NULL);
}

struct netent *
getnetbyaddr(net, net_type)
	register u_long net;
	register int net_type;
{
	unsigned int netbr[4];
	int nn, anslen;
	querybuf buf;
	char qbuf[MAXDNAME];
	unsigned long net2;
	struct netent *net_entry;

	if (net_type != AF_INET)
		return (_getnetbyaddr(net, net_type));

	for (nn = 4, net2 = net; net2; net2 >>= 8)
		netbr[--nn] = net2 & 0xff;
	switch (nn) {
	case 3: 	/* Class A */
		sprintf(qbuf, "0.0.0.%u.in-addr.arpa", netbr[3]);
		break;
	case 2: 	/* Class B */
		sprintf(qbuf, "0.0.%u.%u.in-addr.arpa", netbr[3], netbr[2]);
		break;
	case 1: 	/* Class C */
		sprintf(qbuf, "0.%u.%u.%u.in-addr.arpa", netbr[3], netbr[2],
		    netbr[1]);
		break;
	case 0: 	/* Class D - E */
		sprintf(qbuf, "%u.%u.%u.%u.in-addr.arpa", netbr[3], netbr[2],
		    netbr[1], netbr[0]);
		break;
	}
	anslen = res_query(qbuf, C_IN, T_PTR, (u_char *)&buf, sizeof(buf));
	if (anslen < 0) {
#ifdef DEBUG
		if (_res.options & RES_DEBUG)
			printf("res_query failed\n");
#endif
		if (errno == ECONNREFUSED)
			return (_getnetbyaddr(net, net_type));
		return (NULL);
	}
	net_entry = getnetanswer(&buf, anslen, BYADDR);
	if (net_entry) {
		unsigned u_net = net;	/* maybe net should be unsigned ? */

		/* Strip trailing zeros */
		while ((u_net & 0xff) == 0 && u_net != 0)
			u_net >>= 8;
		net_entry->n_net = u_net;
		return (net_entry);
	}
	return (_getnetbyaddr(net, net_type));
}

struct netent *
getnetbyname(net)
	register const char *net;
{
	int anslen;
	querybuf buf;
	char qbuf[MAXDNAME];
	struct netent *net_entry;

	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
		h_errno = NETDB_INTERNAL;
		return (NULL);
	}
	strcpy(&qbuf[0], net);
	anslen = res_search(qbuf, C_IN, T_PTR, (u_char *)&buf, sizeof(buf));
	if (anslen < 0) {
#ifdef DEBUG
		if (_res.options & RES_DEBUG)
			printf("res_query failed\n");
#endif
		if (errno == ECONNREFUSED)
			return (_getnetbyname(net));
		return (_getnetbyname(net));
	}
	net_entry = getnetanswer(&buf, anslen, BYNAME);
	if (net_entry)
		return (net_entry);
	return (_getnetbyname(net));
}
@


1.5
log
@Sync with bind-4.9.11-REL; fixes the problems listed in:
    http://www.isc.org/products/BIND/bind-security.html
including a buffer overflow that could lead to remote code execution.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.4 2002/06/26 06:08:17 itojun Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.4 2002/06/26 06:08:17 itojun Exp $";
@


1.4
log
@avoid remote buffer overrun on hostbuf[].  From: Joost Pol <joost@@pine.nl>

correct bad practice in the code - it uses two changing variables
to manage buffer (buf and buflen).  we eliminate buflen and use
fixed point (ep) as the ending pointer.

this fix is critical.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.3 2002/02/16 21:28:05 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.3 2002/02/16 21:28:05 millert Exp $";
d108 5
a112 4
	char aux1[30], aux2[30], ans[30], *in, *st, *pauxt, *bp, **ap,
		*paux1 = &aux1[0], *paux2 = &aux2[0], flag = 0, *ep;
static	struct netent net_entry;
static	char *net_aliases[MAXALIASES], netbuf[PACKETSZ];
d142 8
a149 2
	while (qdcount-- > 0)
		cp += __dn_skipname(cp, eom) + QFIXEDSZ;
d160 1
a160 1
		(void)strcpy(&ans[0], bp);
d172 7
a178 5
			*ap++ = bp;
			bp += strlen(bp) + 1;
			net_entry.n_addrtype =
				(class == C_IN) ? AF_INET : AF_UNSPEC;
			haveanswer++;
d189 8
a196 2
			in = *net_entry.n_aliases;
			net_entry.n_name = &ans[0];
d200 1
a200 1
				     *st != '.';
d203 9
a211 10
				if (nchar != 1 || *in != '0' || flag) {
					flag = 1;
					(void)strncpy(paux1,
						      (i==0) ? in : in-1,
						      (i==0) ?nchar : nchar+1);
					paux1[(i==0) ? nchar : nchar+1] = '\0';
					pauxt = paux2;
					paux2 = strcat(paux1, paux2);
					paux1 = pauxt;
				}
d214 2
@


1.4.2.1
log
@Apply http://www.isc.org/products/BIND/patches/bind4910.diff
Fixes bugs listed in http://www.isc.org/products/BIND/bind-security.html
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.4 2002/06/26 06:08:17 itojun Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.4 2002/06/26 06:08:17 itojun Exp $";
d108 4
a111 5
	char aux1[30], aux2[30], *in, *st, *pauxt, *bp, **ap,
		*paux1 = &aux1[0], *paux2 = &aux2[0], *ep;
	static	struct netent net_entry;
	static	char *net_aliases[MAXALIASES], netbuf[PACKETSZ];
	static  char ans[MAXDNAME];
d141 2
a142 8
	while (qdcount-- > 0) {
		n = __dn_skipname(cp, eom);
		if (n < 0 || (cp + n + QFIXEDSZ) > eom) {
			h_errno = NO_RECOVERY;
			return(NULL);
		}
		cp += n + QFIXEDSZ;
	}
d153 1
a153 1
		(void)strcpy(ans, bp);
d165 5
a169 7
			if ((ap + 2) < &net_aliases[MAXALIASES]) {
				*ap++ = bp;
				bp += strlen(bp) + 1;
				net_entry.n_addrtype =
					(class == C_IN) ? AF_INET : AF_UNSPEC;
				haveanswer++;
			}
d180 2
a181 8
			ap = net_entry.n_aliases;
		next_alias:
			in = *ap++;
			if (in == NULL) {
				h_errno = HOST_NOT_FOUND;
				return (NULL);
			}
			net_entry.n_name = ans;
d185 1
a185 1
				     isdigit((unsigned char)*st);
d188 10
a197 9
				if (*st != '.' || nchar == 0 || nchar > 3)
					goto next_alias;
				if (i != 0)
					nchar++;
				(void)strncpy(paux1, in, nchar);
				paux1[nchar] = '\0';
				pauxt = paux2;
				paux2 = strcat(paux1, paux2);
				paux1 = pauxt;
a199 2
			if (strcasecmp(in, "IN-ADDR.ARPA") != 0)
				goto next_alias;
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.2 1998/05/22 00:47:20 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.2 1998/05/22 00:47:20 millert Exp $";
d107 1
a107 1
	int type, class, buflen, ancount, qdcount, haveanswer, i, nchar;
d109 1
a109 1
		*paux1 = &aux1[0], *paux2 = &aux2[0], flag = 0;
d132 1
a132 1
	buflen = sizeof(netbuf);
d148 1
a148 1
		n = dn_expand(answer->buf, eom, cp, bp, buflen);
d159 1
a159 1
			n = dn_expand(answer->buf, eom, cp, bp, buflen);
@


1.3.2.1
log
@Apply http://www.isc.org/products/BIND/patches/bind4910.diff
Fixes bugs listed in http://www.isc.org/products/BIND/bind-security.html
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.3 2002/02/16 21:28:05 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.3 2002/02/16 21:28:05 millert Exp $";
d108 4
a111 5
	char aux1[30], aux2[30], *in, *st, *pauxt, *bp, **ap,
		*paux1 = &aux1[0], *paux2 = &aux2[0];
	static	struct netent net_entry;
	static	char *net_aliases[MAXALIASES], netbuf[PACKETSZ];
	static	char ans[MAXDNAME];
d141 2
a142 8
	while (qdcount-- > 0) {
		n = __dn_skipname(cp, eom);
		if (n < 0 || (cp + n + QFIXEDSZ) > eom) {
			h_errno = NO_RECOVERY;
			return(NULL);
		}
		cp += n + QFIXEDSZ;
	}
d153 1
a153 1
		(void)strcpy(ans, bp);
d165 5
a169 7
			if ((ap + 2) < &net_aliases[MAXALIASES]) {
				*ap++ = bp;
				bp += strlen(bp) + 1;
				net_entry.n_addrtype =
					(class == C_IN) ? AF_INET : AF_UNSPEC;
				haveanswer++;
			}
d180 2
a181 8
			ap = net_entry.n_aliases;
		next_alias:
			in = *ap++;
			if (in == NULL) {
				h_errno = HOST_NOT_FOUND;
				return (NULL);
			}
			net_entry.n_name = ans;
d185 1
a185 1
				     isdigit((unsigned char)*st);
d188 10
a197 9
				if (*st != '.' || nchar == 0 || nchar > 3)
					goto next_alias;
				if (i != 0)
					nchar++;
				(void)strncpy(paux1, in, nchar);
				paux1[nchar] = '\0';
				pauxt = paux2;
				paux2 = strcat(paux1, paux2);
				paux1 = pauxt;
a199 2
			if (strcasecmp(in, "IN-ADDR.ARPA") != 0)
				goto next_alias;
@


1.2
log
@bind 4.9.6, 4.9.7 comming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.1 1997/03/12 10:42:04 downsj Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.1 1997/03/12 10:42:04 downsj Exp $";
d73 2
a74 2
struct netent *_getnetbyaddr __P((long net, int type));
struct netent *_getnetbyname __P((const char *name));
@


1.2.14.1
log
@Apply http://www.isc.org/products/BIND/patches/bind4910.diff
Fixes bugs listed in http://www.isc.org/products/BIND/bind-security.html
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.2 1998/05/22 00:47:20 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.2 1998/05/22 00:47:20 millert Exp $";
d108 4
a111 5
	char aux1[30], aux2[30], *in, *st, *pauxt, *bp, **ap,
		*paux1 = &aux1[0], *paux2 = &aux2[0];
	static	struct netent net_entry;
	static	char *net_aliases[MAXALIASES], netbuf[PACKETSZ];
	static	char ans[MAXDNAME];
d141 2
a142 8
	while (qdcount-- > 0) {
		n = __dn_skipname(cp, eom);
		if (n < 0 || (cp + n + QFIXEDSZ) > eom) {
			h_errno = NO_RECOVERY;
			return(NULL);
		}
		cp += n + QFIXEDSZ;
	}
d153 1
a153 1
		(void)strcpy(ans, bp);
d165 5
a169 7
			if ((ap + 2) < &net_aliases[MAXALIASES]) {
				*ap++ = bp;
				bp += strlen(bp) + 1;
				net_entry.n_addrtype =
					(class == C_IN) ? AF_INET : AF_UNSPEC;
				haveanswer++;
			}
d180 2
a181 8
			ap = net_entry.n_aliases;
		next_alias:
			in = *ap++;
			if (in == NULL) {
				h_errno = HOST_NOT_FOUND;
				return (NULL);
			}
			net_entry.n_name = ans;
d185 1
a185 1
				     isdigit((unsigned char)*st);
d188 10
a197 9
				if (*st != '.' || nchar == 0 || nchar > 3)
					goto next_alias;
				if (i != 0)
					nchar++;
				(void)strncpy(paux1, in, nchar);
				paux1[nchar] = '\0';
				pauxt = paux2;
				paux2 = strcat(paux1, paux2);
				paux1 = pauxt;
a199 2
			if (strcasecmp(in, "IN-ADDR.ARPA") != 0)
				goto next_alias;
@


1.1
log
@BIND 4.9.5-P1.

libresolv and include are required until the new resolver gets integrated
into libc.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
static char rcsid[] = "$From: getnetnamadr.c,v 8.7 1996/08/05 08:31:35 vixie Exp $";
d49 1
a49 1
static char rcsid[] = "$OpenBSD$";
d111 1
a111 1
static	char *net_aliases[MAXALIASES], netbuf[BUFSIZ+1];
@

