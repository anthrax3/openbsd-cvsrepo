head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.12
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.8
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.5
date	2014.01.01.09.24.54;	author mcbride;	state Exp;
branches;
next	1.4;

1.4
date	2013.12.31.07.15.57;	author mcbride;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.11.07.56.02;	author patrick;	state Exp;
branches;
next	1.2;

1.2
date	2013.11.01.14.47.47;	author syl;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.28.09.00.06;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Fix 'make bsd.umg' by skipping PT_OPENBSD_RANDOMIZE segments, as well as
other innocuous segment types (PT_NOTE, PT_NULL). Handle PT_LOAD, fail on
any others.

Thanks kettenis and millert for feedback

ok deraadt
@
text
@/*      $OpenBSD: copy_elf.c,v 1.4 2013/12/31 07:15:57 mcbride Exp $       */

/*
 * Copyright (c) 2013 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <err.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include <sys/exec_elf.h>

#if defined(ELFSIZE) && (ELFSIZE == 32)
#define elfoff2h(x) letoh32(x)
#define h2elfoff(x) htole32(x)
#elif defined(ELFSIZE) && (ELFSIZE == 64)
#define elfoff2h(x) letoh64(x)
#define h2elfoff(x) htole64(x)
#else
#error "unknown elf size"
#endif

struct image_header;

#define        roundup(x, y)   ((((x)+((y)-1))/(y))*(y))

extern u_long copy_data(int, const char *, int, const char *, u_long,
	    struct image_header *, Elf_Word);
u_long	copy_mem(void *, int, const char *, u_long, struct image_header *,
	    Elf_Word);
extern u_long fill_zeroes(int, const char *, u_long, struct image_header *,
	    Elf_Word);

u_long
ELFNAME(copy_elf)(int ifd, const char *iname, int ofd, const char *oname,
    u_long crc, struct image_header *ih)
{
	ssize_t nbytes;
	Elf_Ehdr ehdr, elf;
	Elf_Phdr phdr;
	Elf_Addr vaddr, ovaddr, svaddr, off, ssym;
	Elf_Shdr *shp, *wshp;
	Elf_Addr esym = 0, esymval;
	int i, sz, havesyms;

	nbytes = read(ifd, &ehdr, sizeof ehdr);
	if (nbytes == -1)
		err(1, "%s", iname);
	if (nbytes != sizeof ehdr)
		return 0;

	elf = ehdr;

	if (lseek(ifd, (off_t)elfoff2h(elf.e_shoff), SEEK_SET) == -1)
		err(1, "%s unable to seek to section header", iname);

	sz = letoh16(elf.e_shnum) * sizeof(Elf_Shdr);
	shp = calloc(sz, 1);
	if (read(ifd, shp, sz) != sz)
		err(1, "%s: read section headers", iname);

	wshp = calloc(sz, 1);
	memcpy(wshp, shp, sz);

	/* first walk the load sections to find the kernel addresses */
	/* next we walk the sections to find the
	 * location of esym (first address of data space
	 */
	for (i = 0; i < letoh16(ehdr.e_phnum); i++) {
		if (lseek(ifd, elfoff2h(ehdr.e_phoff) + i *
		    letoh16(ehdr.e_phentsize), SEEK_SET) == (off_t)-1)
			err(1, "%s", iname);
		if (read(ifd, &phdr, sizeof phdr) != sizeof(phdr))
			err(1, "%s", iname);
		/* assumes it loads in incrementing address order */
		if (letoh32(phdr.p_type) == PT_LOAD)
			vaddr = elfoff2h(phdr.p_vaddr) +
			    elfoff2h(phdr.p_memsz);
	}

	/* ok, we need to write the elf header and section header
	 * which contains info about the not yet written section data
	 * however due to crc the data all has to be written in order
	 * which means walking the structures twice once to precompute
	 * the data, once to write the data.
	 */
	ssym = vaddr;
	vaddr += roundup((sizeof(Elf_Ehdr) + sz), sizeof(Elf_Addr));
	off = roundup((sizeof(Elf_Ehdr) + sz), sizeof(Elf_Addr));
	for (i = 0; i < letoh16(elf.e_shnum); i++) {
		if (esym == 0 && elfoff2h(shp[i].sh_flags) & SHF_WRITE &&
		    elfoff2h(shp[i].sh_flags) & SHF_ALLOC)
			esym = elfoff2h(shp[i].sh_addr);

		if (letoh32(shp[i].sh_type) == SHT_SYMTAB ||
		    letoh32(shp[i].sh_type) == SHT_STRTAB) {
#ifdef DEBUG
		fprintf(stderr, "shdr %d %d/%d off %lx\n", i,
		    letoh32(shp[i].sh_type), roundup(elfoff2h(shp[i].sh_size),
		    sizeof(Elf_Addr)), off);
#endif
			/* data is at shp[i].sh_offset of len shp[i].sh_size */
			wshp[i].sh_offset = h2elfoff(off);
			off += roundup(elfoff2h(shp[i].sh_size),
			    sizeof(Elf_Addr));
			vaddr += roundup(elfoff2h(shp[i].sh_size),
			    sizeof(Elf_Addr));
		}
	}
	esymval = vaddr;
#ifdef DEBUG
	fprintf(stderr, "esymval %lx size %ld\n", esymval, esymval - ssym);
#endif

	for (i = 0; i < letoh16(ehdr.e_phnum); i++) {
#ifdef DEBUG
		fprintf(stderr, "phdr %d/%d\n", i, letoh16(ehdr.e_phnum));
#endif
		if (lseek(ifd, elfoff2h(ehdr.e_phoff) + i *
		    letoh16(ehdr.e_phentsize), SEEK_SET) == (off_t)-1)
			err(1, "%s", iname);
		if (read(ifd, &phdr, sizeof phdr) != sizeof(phdr))
			err(1, "%s", iname);

#ifdef DEBUG
		fprintf(stderr,
		    "vaddr %p type %#x offset %p filesz %p memsz %p\n",
		    elfoff2h(phdr.p_vaddr), letoh32(phdr.p_type),
	            elfoff2h(phdr.p_offset), elfoff2h(phdr.p_filesz),
                    elfoff2h(phdr.p_memsz));
#endif

		switch (letoh32(phdr.p_type)) {
		case PT_LOAD:
			break;
		case PT_NULL:
		case PT_NOTE:
		case PT_OPENBSD_RANDOMIZE:
#ifdef DEBUG
			fprintf(stderr, "skipping segment type %#x\n",
			    letoh32(phdr.p_type));
#endif
			continue;
		default:
			errx(1, "unexpected segment type %#x",
			    letoh32(phdr.p_type));
		}

		if (i == 0) 
			vaddr = elfoff2h(phdr.p_vaddr);
		else if (vaddr != elfoff2h(phdr.p_vaddr)) {
#ifdef DEBUG
			fprintf(stderr, "gap %p->%p\n", vaddr,
			    elfoff2h(phdr.p_vaddr));
#endif
			/* fill the gap between the previous phdr if any */
			crc = fill_zeroes(ofd, oname, crc, ih,
			    elfoff2h(phdr.p_vaddr) - vaddr);
			vaddr = elfoff2h(phdr.p_vaddr);
		}

		if (elfoff2h(phdr.p_filesz) != 0) {
#ifdef DEBUG
			fprintf(stderr, "copying %p from infile %p\n",
			   elfoff2h(phdr.p_filesz), elfoff2h(phdr.p_offset));
#endif
			/* esym will be in the data portion of a region */
			if (esym >= elfoff2h(phdr.p_vaddr) &&
			    esym < elfoff2h(phdr.p_vaddr) +
			    elfoff2h(phdr.p_filesz)) {
				/* load the region up to the esym
				 * (may be empty)
				 */
				Elf_Addr loadlen = esym -
				    elfoff2h(phdr.p_vaddr);

				if (lseek(ifd, elfoff2h(phdr.p_offset),
				    SEEK_SET) == (off_t)-1)
					err(1, "%s", iname);
				crc = copy_data(ifd, iname, ofd, oname, crc,
				    ih, loadlen);

				crc = copy_mem(&esymval, ofd, oname, crc, ih,
				    sizeof(esymval));

				if (lseek(ifd, elfoff2h(phdr.p_offset) +
				    loadlen + sizeof(esymval), SEEK_SET) ==
				    (off_t)-1)
					err(1, "%s", iname);
				crc = copy_data(ifd, iname, ofd, oname, crc,
				    ih, elfoff2h(phdr.p_filesz) - loadlen -
				    sizeof(esymval));
			} else {

				if (lseek(ifd, elfoff2h(phdr.p_offset),
				    SEEK_SET) == (off_t)-1)
					err(1, "%s", iname);
				crc = copy_data(ifd, iname, ofd, oname, crc,
				    ih, elfoff2h(phdr.p_filesz));
			}
			if (elfoff2h(phdr.p_memsz) - elfoff2h(phdr.p_filesz)
			    != 0) {
#ifdef DEBUG
				fprintf(stderr, "zeroing %p\n",
				    elfoff2h(phdr.p_memsz) -
				    elfoff2h(phdr.p_filesz));
#endif
				crc = fill_zeroes(ofd, oname, crc, ih,
				    elfoff2h(phdr.p_memsz) -
				    elfoff2h(phdr.p_filesz));
			}
			ovaddr = vaddr + elfoff2h(phdr.p_memsz);
		} else {
			ovaddr = vaddr;
		}
		/*
		 * If p_filesz == 0, this is likely .bss, which we do not
		 * need to provide. If it's not the last phdr, the gap
		 * filling code will output the necessary zeroes anyway.
		 */
		vaddr += elfoff2h(phdr.p_memsz);
	}

	vaddr = roundup(vaddr, sizeof(Elf_Addr));
	if (vaddr != ovaddr) {
#ifdef DEBUG
		fprintf(stderr, "gap %p->%p\n", vaddr, elfoff2h(phdr.p_vaddr));
#endif
		/* fill the gap between the previous phdr if not aligned */
		crc = fill_zeroes(ofd, oname, crc, ih, vaddr - ovaddr);
	}

	for (havesyms = i = 0; i < letoh16(elf.e_shnum); i++)
		if (letoh32(shp[i].sh_type) == SHT_SYMTAB)
			havesyms = 1;

	if (havesyms == 0)
		return crc;

	elf.e_phoff = 0;
	elf.e_shoff = h2elfoff(sizeof(Elf_Ehdr));
	elf.e_phentsize = 0;
	elf.e_phnum = 0;
	crc = copy_mem(&elf, ofd, oname, crc, ih, sizeof(elf));
	crc = copy_mem(wshp, ofd, oname, crc, ih, sz);
	off = sizeof(elf) + sz;
	vaddr += sizeof(elf) + sz;

	off = roundup((sizeof(Elf_Ehdr) + sz), sizeof(Elf_Addr));
	for (i = 0; i < letoh16(elf.e_shnum); i++) {
		if (letoh32(shp[i].sh_type) == SHT_SYMTAB ||
		    letoh32(shp[i].sh_type) == SHT_STRTAB) {
			Elf_Addr align;
			/* data is at shp[i].sh_offset of len shp[i].sh_size */
			if (lseek(ifd, elfoff2h(shp[i].sh_offset), SEEK_SET)
			    == -1)
				err(1, "%s", iname);

			off += elfoff2h(shp[i].sh_size);
			vaddr += elfoff2h(shp[i].sh_size);
			crc = copy_data(ifd, iname, ofd, oname, crc, ih,
			    elfoff2h(shp[i].sh_size));
			align = roundup(elfoff2h(shp[i].sh_size),
			    sizeof(Elf_Addr)) - elfoff2h(shp[i].sh_size);
			if (align != 0) {
				vaddr += align;
				crc = fill_zeroes(ofd, oname, crc, ih, align);
			}
		}
	}

	if (vaddr != esymval)
		warnx("esymval and vaddr mismatch %lx %lx\n", esymval, vaddr);

	return crc;
}
@


1.4
log
@s/hphdr/phdr/ to fix compile with DEBUG

ok miod
@
text
@d1 1
a1 1
/*      $OpenBSD: copy_elf.c,v 1.3 2013/11/11 07:56:02 patrick Exp $       */
d140 5
a144 3
		fprintf(stderr, "vaddr %p offset %p filesz %p memsz %p\n",
		    elfoff2h(phdr.p_vaddr), elfoff2h(phdr.p_offset),
		    elfoff2h(phdr.p_filesz), elfoff2h(phdr.p_memsz));
d146 18
a163 1
		if (i == 0)
@


1.3
log
@Make sure string and symbol tables are properly aligned.

From and with drahn@@bitrig, fgs@@, syl@@
Tested by aalm@@, ok fgs@@
@
text
@d1 1
a1 1
/*      $OpenBSD: copy_elf.c,v 1.2 2013/11/01 14:47:47 syl Exp $       */
d160 1
a160 1
			   elfoff2h(hphdr.p_filesz), elfoff2h(phdr.p_offset));
@


1.2
log
@Fix endianess for big endian architecture.

Works with macppc.
ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: copy_elf.c,v 1.1 2013/10/28 09:00:06 patrick Exp $       */
d105 2
a106 1
		if (esym == 0 && elfoff2h(shp[i].sh_flags) & SHF_WRITE)
d242 1
d248 1
d255 1
d258 6
d266 3
@


1.1
log
@Improve mkuboot's ELF handling.  This fixes the problem where mkuboot
running on 64-bit systems does not create valid images.
While there, append kernel symbols at the end of the kernel.

ok syl@@
@
text
@d1 1
a1 1
/*      $OpenBSD$       */
d27 10
d45 2
a46 1
extern u_long fill_zeroes(int, const char *, u_long, struct image_header *, Elf_Word);
d49 2
a50 2
ELFNAME(copy_elf)(int ifd, const char *iname, int ofd, const char *oname, u_long crc,
    struct image_header *ih)
d68 1
a68 1
	if (lseek(ifd, (off_t)elf.e_shoff, SEEK_SET) == -1)  {
a69 1
	}
d71 1
a71 1
	sz = elf.e_shnum * sizeof(Elf_Shdr);
d73 1
a73 1
	if (read(ifd, shp, sz) != sz) {
d75 1
a75 1
	}
a78 1

d83 3
a85 3
	for (i = 0; i < ehdr.e_phnum; i++) {
		if (lseek(ifd, ehdr.e_phoff + i * ehdr.e_phentsize, SEEK_SET) ==
		    (off_t)-1)
d90 3
a92 2
		if (phdr.p_type == PT_LOAD)
			vaddr = phdr.p_vaddr + phdr.p_memsz;
d104 10
a113 9
	for (i = 0; i < elf.e_shnum; i++) {
		if (esym == 0 && shp[i].sh_flags & SHF_WRITE) {
			esym = shp[i].sh_addr;
		}
		if (shp[i].sh_type == SHT_SYMTAB || 
		    shp[i].sh_type == SHT_STRTAB) {
#ifdef DEBUG
		fprintf(stderr, "shdr %d %d/%d off %lx\n", i, shp[i].sh_type,
		    roundup(shp[i].sh_size, sizeof(Elf_Addr)), off);
d116 5
a120 3
			wshp[i].sh_offset = off;
			off   += roundup(shp[i].sh_size, sizeof(Elf_Addr));
			vaddr += roundup(shp[i].sh_size, sizeof(Elf_Addr));
d125 1
a125 1
		fprintf(stderr, "esymval %lx size %ld\n", esymval, esymval - ssym);
d128 1
a128 1
	for (i = 0; i < ehdr.e_phnum; i++) {
d130 1
a130 1
		fprintf(stderr, "phdr %d/%d\n", i, ehdr.e_phnum);
d132 2
a133 2
		if (lseek(ifd, ehdr.e_phoff + i * ehdr.e_phentsize, SEEK_SET) ==
		    (off_t)-1)
d140 2
a141 1
		    phdr.p_vaddr, phdr.p_offset, phdr.p_filesz, phdr.p_memsz);
d144 2
a145 2
			vaddr = phdr.p_vaddr;
		else if (vaddr != phdr.p_vaddr) {
d147 2
a148 1
			fprintf(stderr, "gap %p->%p\n", vaddr, phdr.p_vaddr);
d152 2
a153 2
			    phdr.p_vaddr - vaddr);
			vaddr = phdr.p_vaddr;
d156 1
a156 1
		if (phdr.p_filesz != 0) {
d159 1
a159 1
			    phdr.p_filesz, phdr.p_offset);
d162 3
a164 2
			if (esym >= phdr.p_vaddr &&
			    esym < phdr.p_vaddr + phdr.p_filesz) {
d168 2
a169 1
				Elf_Addr loadlen = esym - phdr.p_vaddr;
d171 2
a172 2
				if (lseek(ifd, phdr.p_offset, SEEK_SET) ==
				    (off_t)-1)
d180 3
a182 2
				if (lseek(ifd, phdr.p_offset + loadlen +
				    sizeof(esymval), SEEK_SET) == (off_t)-1)
d185 1
a185 1
				    ih, phdr.p_filesz - loadlen -
d189 2
a190 2
				if (lseek(ifd, phdr.p_offset, SEEK_SET) ==
				    (off_t)-1)
d193 1
a193 1
				    ih, phdr.p_filesz);
d195 2
a196 1
			if (phdr.p_memsz - phdr.p_filesz != 0) {
d199 2
a200 1
				    phdr.p_memsz - phdr.p_filesz);
d203 2
a204 1
				    phdr.p_memsz - phdr.p_filesz);
d206 1
a206 1
			ovaddr = vaddr + phdr.p_memsz;
d215 1
a215 1
		vaddr += phdr.p_memsz;
d221 1
a221 1
		fprintf(stderr, "gap %p->%p\n", vaddr, phdr.p_vaddr);
d227 3
a229 3
	for (havesyms = i = 0; i < elf.e_shnum; i++)
		if (shp[i].sh_type == SHT_SYMTAB)
		havesyms = 1;
d235 1
a235 1
	elf.e_shoff = sizeof(Elf_Ehdr);
d243 3
a245 3
	for (i = 0; i < elf.e_shnum; i++) {
		if (shp[i].sh_type == SHT_SYMTAB || 
		    shp[i].sh_type == SHT_STRTAB) {
d247 2
a248 1
			if (lseek(ifd, shp[i].sh_offset, SEEK_SET) == -1) {
d250 2
a251 2
			}
			off += shp[i].sh_size;
d253 1
a253 1
			    shp[i].sh_size);
@

