head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.6
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2016.12.20.11.27.11;	author jsg;	state Exp;
branches;
next	1.6;
commitid	fELL92HBrGHkYVvc;

1.6
date	2015.10.12.06.24.28;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	MVH7VSDiUYTxMGgN;

1.5
date	2015.10.12.05.54.18;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	ZhWTxBgT835jYXj9;

1.4
date	2014.05.18.21.18.07;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.28.09.00.06;	author patrick;	state Exp;
branches;
next	1.2;

1.2
date	2013.07.28.18.07.16;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2013.05.30.19.17.15;	author bmercer;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Add the u-boot arm64 architecture number and map it to "aarch64" to
match OpenBSD/arm64 MACHINE_ARCH.

ok patrick@@
@
text
@/*	$OpenBSD: mkuboot.c,v 1.6 2015/10/12 06:24:28 deraadt Exp $	*/

/*
 * Copyright (c) 2008 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <err.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <zlib.h>
#include <sys/exec_elf.h>

#define IH_OS_OPENBSD		1 /* OpenBSD */
#define IH_OS_LINUX		5 /* Linux */

#define IH_ARCH_ALPHA           1       /* Alpha        */
#define IH_ARCH_ARM             2       /* ARM          */
#define IH_ARCH_I386            3       /* Intel x86    */
#define IH_ARCH_IA64            4       /* IA64         */
#define IH_ARCH_MIPS            5       /* MIPS         */
#define IH_ARCH_MIPS64          6       /* MIPS  64 Bit */
#define IH_ARCH_PPC             7       /* PowerPC      */
#define IH_ARCH_SH              9       /* SuperH       */
#define IH_ARCH_SPARC           10      /* Sparc        */
#define IH_ARCH_SPARC64         11      /* Sparc 64 Bit */
#define IH_ARCH_M68K            12      /* M68K         */
#define IH_ARCH_ARM64           22      /* AARCH64      */

#define IH_TYPE_STANDALONE	1 /* Standalone */
#define IH_TYPE_KERNEL		2 /* OS Kernel Image */
#define IH_TYPE_SCRIPT		6 /* Script file */

#define IH_COMP_NONE		0 /* No compression */

#define IH_MAGIC		0x27051956	/* Image Magic Number */
#define IH_NMLEN		32 		/* Image Name Length */

struct image_header {
	uint32_t	ih_magic;
	uint32_t	ih_hcrc;
	uint32_t	ih_time;
	uint32_t	ih_size;
	uint32_t	ih_load;
	uint32_t	ih_ep;
	uint32_t	ih_dcrc;
	uint8_t		ih_os;
	uint8_t		ih_arch;
	uint8_t		ih_type;
	uint8_t		ih_comp;
	uint8_t		ih_name[IH_NMLEN];
};

extern char *__progname;

extern u_long	elf32_copy_elf(int, const char *, int, const char *, u_long,
	    struct image_header *);
extern u_long	elf64_copy_elf(int, const char *, int, const char *, u_long,
	    struct image_header *);

u_long	copy_data(int, const char *, int, const char *, u_long,
	    struct image_header *, Elf_Word);
u_long	(*copy_elf)(int, const char *, int, const char *, u_long,
	    struct image_header *);

u_long	copy_mem(void *, int, const char *, u_long, struct image_header *,
	    Elf_Word);
u_long	copy_raw(int, const char *, int, const char *, u_long,
	    struct image_header *);
u_long	fill_zeroes(int, const char *, u_long, struct image_header *, Elf_Word);
int	is_elf(int, const char *);
void	usage(void);

struct arch_map {
	int id;
	const char *arch;
};

static const struct arch_map archmap[] = {
    { IH_ARCH_ARM64,	"aarch64" },
    { IH_ARCH_ALPHA,	"alpha" },
    { IH_ARCH_IA64,	"amd64" },
    { IH_ARCH_ARM,	"arm" },
    { IH_ARCH_I386,	"i386" },
    { IH_ARCH_M68K,	"m68k" },
    { IH_ARCH_MIPS,	"mips" },
    { IH_ARCH_MIPS64,	"mips64" },
    { IH_ARCH_PPC,	"powerpc" },
    { IH_ARCH_SPARC,	"sparc" },
    { IH_ARCH_SPARC64,	"sparc64" },
    { IH_ARCH_SH,	"superh" },
    { 0, NULL }
};

struct type_map {
	int id;
	const char *type;
};
static const struct type_map typemap[] = {
    { IH_TYPE_STANDALONE,	"standalone" },
    { IH_TYPE_KERNEL,		"kernel" },
    { IH_TYPE_SCRIPT,		"script" },
    { 0, NULL }
};

struct os_map {
	int id;
	const char *arch;
};

static const struct os_map osmap[] = {
    { IH_OS_OPENBSD,	"OpenBSD" },
    { IH_OS_LINUX,	"Linux" },
    { 0, NULL }
};


int
main(int argc, char *argv[])
{
	struct image_header ih;
	struct stat sb;
	const struct arch_map *mapptr;
	const struct os_map *osmapptr;
	const struct type_map *typemapptr;
	const char *iname, *oname;
	const char *arch = MACHINE_ARCH;
	const char *os = "OpenBSD";
	const char *type = "kernel";
	const char *imgname = "boot";
	int ifd, ofd;
	uint32_t fsize;
	u_long crc;
	int c, ep, load;

	ep = load = 0;
	while ((c = getopt(argc, argv, "a:e:l:n:o:t:")) != -1) {
		switch (c) {
		case 'a':
			arch = optarg;
			break;
		case 'e':
			sscanf(optarg, "0x%x", &ep);
			break;
		case 'l':
			sscanf(optarg, "0x%x", &load);
			break;
		case 'n':
			imgname = optarg;
			break;
		case 'o':
			os = optarg;
			break;
		case 't':
			type = optarg;
			break;
		default:
			usage();
		}
	}

	for (mapptr = archmap; mapptr->arch; mapptr++)
		if (strcasecmp(arch, mapptr->arch) == 0)
			break;

	if (mapptr->arch == NULL) {
		printf("unknown arch '%s'\n", arch);
		usage();
	}

	for (osmapptr = osmap; osmapptr->arch; osmapptr++)
		if (strcasecmp(os, osmapptr->arch) == 0)
			break;

	if (osmapptr->arch == NULL) {
		printf("unknown OS '%s'\n", os);
		usage();
	}

	for (typemapptr = typemap; typemapptr->type; typemapptr++)
		if (strcasecmp(type, typemapptr->type) == 0)
			break;

	if (typemapptr->type == NULL) {
		printf("unknown type '%s'\n", os);
		usage();
	}

	if (argc - optind != 2)
		usage();

	iname = argv[optind++];
	oname = argv[optind++];

	/* Initialize U-Boot header. */
	bzero(&ih, sizeof ih);
	ih.ih_magic = htobe32(IH_MAGIC);
	ih.ih_time = htobe32(time(NULL));
	ih.ih_load = htobe32(load);
	ih.ih_ep = htobe32(ep);
	ih.ih_os = osmapptr->id;
	ih.ih_arch = mapptr->id;
	ih.ih_type = typemapptr->id;
	ih.ih_comp = IH_COMP_NONE;
	strlcpy((char *)ih.ih_name, imgname, sizeof ih.ih_name);

	ifd = open(iname, O_RDONLY);
	if (ifd < 0)
		err(1, "%s", iname);
	if (fstat(ifd, &sb) == -1)
		err(1, "%s", iname);

	ofd = open(oname, O_RDWR | O_TRUNC | O_CREAT, 0644);
	if (ofd < 0)
		err(1, "%s", oname);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	/* Write initial header. */
	if (write(ofd, &ih, sizeof ih) != sizeof ih)
		err(1, "%s", oname);

	/* Write data, calculating the data CRC as we go. */
	crc = crc32(0L, Z_NULL, 0);

	if (ih.ih_type == IH_TYPE_SCRIPT) {
		/* scripts have two extra words of size/pad */
		fsize = htobe32(sb.st_size);
		crc = crc32(crc, (Bytef *)&fsize, sizeof(fsize));
		if (write(ofd, &fsize, sizeof fsize) != sizeof fsize)
			err(1, "%s", oname);
		fsize = 0;
		crc = crc32(crc, (Bytef *)&fsize, sizeof(fsize));
		if (write(ofd, &fsize, sizeof fsize) != sizeof fsize)
			err(1, "%s", oname);
	}

	if (is_elf(ifd, iname))
		crc = copy_elf(ifd, iname, ofd, oname, crc, &ih);
	else
		crc = copy_raw(ifd, iname, ofd, oname, crc, &ih);
	ih.ih_dcrc = htobe32(crc);

	if (ih.ih_type == IH_TYPE_SCRIPT) {
		ih.ih_size += 8; /* two extra pad words */
	}

	ih.ih_size = htobe32(ih.ih_size);

	/* Calculate header CRC. */
	crc = crc32(0, (Bytef *)&ih, sizeof ih);
	ih.ih_hcrc = htobe32(crc);

	/* Write finalized header. */
	if (lseek(ofd, 0, SEEK_SET) != 0)
		err(1, "%s", oname);
	if (write(ofd, &ih, sizeof ih) != sizeof ih)
		err(1, "%s", oname);

	return(0);
}

int
is_elf(int ifd, const char *iname)
{
	ssize_t nbytes;
	Elf_Ehdr ehdr;

	nbytes = read(ifd, &ehdr, sizeof ehdr);
	if (nbytes == -1)
		err(1, "%s", iname);
	if (lseek(ifd, 0, SEEK_SET) != 0)
		err(1, "%s", iname);

	if (nbytes != sizeof ehdr || !IS_ELF(ehdr))
		return 0;

	if (ehdr.e_ident[EI_CLASS] == ELFCLASS32)
		copy_elf = elf32_copy_elf;
	else if (ehdr.e_ident[EI_CLASS] == ELFCLASS64)
		copy_elf = elf64_copy_elf;
	else
		err(1, "%s: invalid elf, not 32 or 64 bit", iname);
	return 1;
}

u_long
copy_data(int ifd, const char *iname, int ofd, const char *oname, u_long crc,
    struct image_header *ih, Elf_Word size)
{
	ssize_t nbytes, chunk;
	char buf[BUFSIZ];

	while (size != 0) {
		chunk = size > BUFSIZ ? BUFSIZ : size;
		nbytes = read(ifd, buf, chunk);
		if (nbytes != chunk)
			err(1, "%s", iname);
		if (write(ofd, buf, nbytes) != nbytes)
			err(1, "%s", oname);
		crc = crc32(crc, (Bytef *)buf, nbytes);
		ih->ih_size += nbytes;
		size -= nbytes;
	}

	return crc;
}

u_long
copy_mem(void *mem, int ofd, const char *oname, u_long crc,
    struct image_header *ih, Elf_Word size)
{
	ssize_t nbytes;
	char *memp = (char *)mem;

	while (size != 0) {
		nbytes = size > BUFSIZ ? BUFSIZ : size;
		if (write(ofd, memp, nbytes) != nbytes)
			err(1, "%s", oname);
		crc = crc32(crc, (Bytef *)memp, nbytes);
		memp += nbytes;
		ih->ih_size += nbytes;
		size -= nbytes;
	}

	return crc;
}

u_long
fill_zeroes(int ofd, const char *oname, u_long crc, struct image_header *ih,
    Elf_Word size)
{
	ssize_t nbytes, chunk;
	char buf[BUFSIZ];

	memset(buf, 0, BUFSIZ);
	while (size != 0) {
		chunk = size > BUFSIZ ? BUFSIZ : size;
		nbytes = write(ofd, buf, chunk);
		if (nbytes != chunk)
			err(1, "%s", oname);
		crc = crc32(crc, (Bytef *)buf, nbytes);
		ih->ih_size += nbytes;
		size -= nbytes;
	}

	return crc;
}

u_long
copy_raw(int ifd, const char *iname, int ofd, const char *oname, u_long crc,
    struct image_header *ih)
{
	ssize_t nbytes;
	char buf[BUFSIZ];

	while ((nbytes = read(ifd, buf, sizeof buf)) != 0) {
		if (nbytes == -1)
			err(1, "%s", iname);
		if (write(ofd, buf, nbytes) != nbytes)
			err(1, "%s", oname);
		crc = crc32(crc, (Bytef *)buf, nbytes);
		ih->ih_size += nbytes;
	}

	return crc;
}

void
usage(void)
{
	const struct arch_map *mapptr;
	const struct os_map *osmapptr;

	(void)fprintf(stderr,
	    "usage: %s [-a arch] [-e entry] [-l loadaddr] [-n name] [-o os] "
	    "[-t type] infile outfile\n", __progname);
	(void)fprintf(stderr,
	    "arch is one of:");
	for (mapptr = archmap; mapptr->arch; mapptr++)
		(void)fprintf(stderr, " %s", mapptr->arch);
	(void)fprintf(stderr, "\n");
	(void)fprintf(stderr,
	    "os is one of:");
	for (osmapptr = osmap; osmapptr->arch; osmapptr++)
		(void)fprintf(stderr, " %s", osmapptr->arch);
	(void)fprintf(stderr, "\n");
	
	exit(1);
}
@


1.6
log
@pledge "stdio" after opening up the input & output files.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: mkuboot.c,v 1.5 2015/10/12 05:54:18 deraadt Exp $	*/
d46 1
d98 1
@


1.5
log
@fstat() of opened fd, rather than stat(), to avoid TOCTOU
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: mkuboot.c,v 1.4 2014/05/18 21:18:07 miod Exp $	*/
d232 3
@


1.4
log
@Correctly handle files smaller than an ELF header; reported by drahn@@bitrig
@
text
@d1 1
a1 1
/*	$OpenBSD: mkuboot.c,v 1.3 2013/10/28 09:00:06 patrick Exp $	*/
d226 2
a231 4

	if (stat(iname, &sb) == -1) {
		err(1, "%s", oname);
	}
@


1.3
log
@Improve mkuboot's ELF handling.  This fixes the problem where mkuboot
running on 64-bit systems does not create valid images.
While there, append kernel symbols at the end of the kernel.

ok syl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkuboot.c,v 1.2 2013/07/28 18:07:16 miod Exp $	*/
a287 3
	if (nbytes != sizeof ehdr)
		return 0;

d290 2
a291 1
	if (!IS_ELF(ehdr))
@


1.2
log
@Let mkuboot recognize native ELF binaries and only output the program headers
area in this case, to save the need for `objcopy -O binary'; this will make
beagle install/upgrade processes easier until they get a native bootloader.
Tested by florian@@ on panda ES and rapha@@ on BeagleBone
@
text
@d1 1
a1 1
/*	$OpenBSD: mkuboot.c,v 1.1 2013/05/30 19:17:15 bmercer Exp $	*/
d73 5
d80 1
a80 1
u_long	copy_elf(int, const char *, int, const char *, u_long,
d82 3
d221 1
a221 1
	strlcpy(ih.ih_name, imgname, sizeof ih.ih_name);
d245 1
a245 1
		crc = crc32(crc, (void *)&fsize, sizeof(fsize));
d249 1
a249 1
		crc = crc32(crc, (void *)&fsize, sizeof(fsize));
d267 1
a267 1
	crc = crc32(0, (void *)&ih, sizeof ih);
d293 2
d296 7
a302 1
	return IS_ELF(ehdr);
d306 2
a307 2
copy_elf(int ifd, const char *iname, int ofd, const char *oname, u_long crc,
    struct image_header *ih)
d309 2
a310 5
	ssize_t nbytes;
	Elf_Ehdr ehdr;
	Elf_Phdr phdr;
	Elf_Addr vaddr;
	int i;
d312 4
a315 12
	nbytes = read(ifd, &ehdr, sizeof ehdr);
	if (nbytes == -1)
		err(1, "%s", iname);
	if (nbytes != sizeof ehdr)
		return 0;

	for (i = 0; i < ehdr.e_phnum; i++) {
#ifdef DEBUG
		fprintf(stderr, "phdr %d/%d\n", i, ehdr.e_phnum);
#endif
		if (lseek(ifd, ehdr.e_phoff + i * ehdr.e_phentsize, SEEK_SET) ==
		    (off_t)-1)
d317 5
a321 43
		if (read(ifd, &phdr, sizeof phdr) != sizeof(phdr))
			err(1, "%s", iname);

#ifdef DEBUG
		fprintf(stderr, "vaddr %p offset %p filesz %p memsz %p\n",
		    phdr.p_vaddr, phdr.p_offset, phdr.p_filesz, phdr.p_memsz);
#endif
		if (i == 0)
			vaddr = phdr.p_vaddr;
		else if (vaddr != phdr.p_vaddr) {
#ifdef DEBUG
			fprintf(stderr, "gap %p->%p\n", vaddr, phdr.p_vaddr);
#endif
			/* fill the gap between the previous phdr if any */
			crc = fill_zeroes(ofd, oname, crc, ih,
			    phdr.p_vaddr - vaddr);
			vaddr = phdr.p_vaddr;
		}

		if (phdr.p_filesz != 0) {
#ifdef DEBUG
			fprintf(stderr, "copying %p from infile %p\n",
			    phdr.p_filesz, phdr.p_offset);
#endif
			if (lseek(ifd, phdr.p_offset, SEEK_SET) == (off_t)-1)
				err(1, "%s", iname);
			crc = copy_data(ifd, iname, ofd, oname, crc, ih,
			    phdr.p_filesz);
			if (phdr.p_memsz - phdr.p_filesz != 0) {
#ifdef DEBUG
				fprintf(stderr, "zeroing %p\n",
				    phdr.p_memsz - phdr.p_filesz);
#endif
				crc = fill_zeroes(ofd, oname, crc, ih,
				    phdr.p_memsz - phdr.p_filesz);
			}
		}
		/*
		 * If p_filesz == 0, this is likely .bss, which we do not
		 * need to provide. If it's not the last phdr, the gap
		 * filling code will output the necessary zeroes anyway.
		 */
		vaddr += phdr.p_memsz;
d328 1
a328 1
copy_data(int ifd, const char *iname, int ofd, const char *oname, u_long crc,
d331 2
a332 2
	ssize_t nbytes, chunk;
	char buf[BUFSIZ];
d335 2
a336 5
		chunk = size > BUFSIZ ? BUFSIZ : size;
		nbytes = read(ifd, buf, chunk);
		if (nbytes != chunk)
			err(1, "%s", iname);
		if (write(ofd, buf, nbytes) != nbytes)
d338 2
a339 1
		crc = crc32(crc, buf, nbytes);
d360 1
a360 1
		crc = crc32(crc, buf, nbytes);
d380 1
a380 1
		crc = crc32(crc, buf, nbytes);
@


1.1
log
@Move mkuboot to the proper location.
OK jasper@@ get it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkuboot.c,v 1.4 2010/07/10 20:47:10 drahn Exp $	*/
d30 1
d73 8
a141 2
	ssize_t nbytes;
	char buf[BUFSIZ];
d246 4
a249 8
	while ((nbytes = read(ifd, buf, sizeof buf)) != 0) {
		if (nbytes == -1)
			err(1, "%s", iname);
		if (write(ofd, buf, nbytes) != nbytes)
			err(1, "%s", oname);
		crc = crc32(crc, buf, nbytes);
		ih.ih_size += nbytes;
	}
d269 151
@

