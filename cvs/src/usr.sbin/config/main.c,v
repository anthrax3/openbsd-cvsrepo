head	1.57;
access;
symbols
	OPENBSD_6_1:1.57.0.2
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.48.0.6
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.44.0.6
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.4
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.2
	OPENBSD_5_0:1.42.0.2
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.41.0.6
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.4
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.6
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.39.0.6
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.38.0.6
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.38.0.4
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.36.0.6
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.4
	OPENBSD_3_6_BASE:1.36
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	OPENBSD_3_3:1.29.0.4
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	OPENBSD_3_0:1.20.0.8
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.6
	OPENBSD_2_8:1.20.0.4
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.17.0.4
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2016.10.16.18.02.03;	author tb;	state Exp;
branches;
next	1.56;
commitid	uIW3efGZeoddQTWW;

1.56
date	2016.10.16.17.50.00;	author tb;	state Exp;
branches;
next	1.55;
commitid	9USjn6ChymyvzYCb;

1.55
date	2016.10.16.09.36.46;	author natano;	state Exp;
branches;
next	1.54;
commitid	ueEjUfmdF8scqcRd;

1.54
date	2016.10.16.09.19.15;	author natano;	state Exp;
branches;
next	1.53;
commitid	dfkhSiBXxKSzXrXN;

1.53
date	2016.10.16.08.47.17;	author natano;	state Exp;
branches;
next	1.52;
commitid	3GeRQs4gMF5Lpvsk;

1.52
date	2016.10.14.18.51.04;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	AlGClnyXTb9I2mDq;

1.51
date	2016.09.12.14.33.12;	author akfaew;	state Exp;
branches;
next	1.50;
commitid	gQiVPnnWQ9DooT9Z;

1.50
date	2015.10.16.13.37.44;	author millert;	state Exp;
branches;
next	1.49;
commitid	H99PcNtHGZMrNl2r;

1.49
date	2015.10.12.15.56.58;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	dJhmVQLZN5IyKMzG;

1.48
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	Uu5nFG3wCl0LACBb;

1.47
date	2014.05.18.09.29.54;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2013.11.23.17.38.15;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2013.10.29.15.37.56;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2012.06.22.22.02.29;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2011.10.02.22.20.49;	author edd;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.15.02.48.14;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2008.10.03.13.01.26;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.20.19.42.14;	author jmc;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.12.15.40.09;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.04.28.22.28.00;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.04.18.30.05;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.04.00.47.01;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.29.05.26.11;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.26.17.01.14;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.28.04.55.07;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.28.16.52.21;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.06.19.02.06;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.14.02.59.41;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.14.21.35.01;	author todd;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.29.09.45.39;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.17.19.42.35;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.11.23.47.00;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.05.10.11.23;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.04.14.23.43;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	99.11.27.03.49.13;	author d;	state Exp;
branches;
next	1.18;

1.18
date	99.10.04.20.00.51;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.05.25.09.35.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.11.13.08.21.54;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.07.06.04.07.09;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.07.06.03.54.05;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	97.04.14.02.24.04;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.04.04.19.56.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.04.04.19.54.29;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.01.18.02.24.16;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.01.15.23.43.53;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.10.23.22.37.53;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.09.13.04.25.41;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.09.12.07.51.17;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.08.29.03.33.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.23.40.14;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.25.15.55.06;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.18.54.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Add a == EOF that was accidentally lost in previous commit.
@
text
@/*	$OpenBSD: main.c,v 1.56 2016/10/16 17:50:00 tb Exp $	*/
/*	$NetBSD: main.c,v 1.22 1997/02/02 21:12:33 thorpej Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)main.c	8.1 (Berkeley) 6/6/93
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "config.h"

int	firstfile(const char *);
int	yyparse(void);

static struct hashtab *mkopttab;
static struct nvlist **nextopt;
static struct nvlist **nextdefopt;
static struct nvlist **nextmkopt;

static __dead void stop(void);
static int do_option(struct hashtab *, struct nvlist ***,
    const char *, const char *, const char *);
static int crosscheck(void);
static int badstar(void);
static int mksymlinks(void);
static int hasparent(struct devi *);
static int cfcrosscheck(struct config *, const char *, struct nvlist *);
static void optiondelta(void);

int	verbose;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
		"usage: %s [-p] [-b builddir] [-s srcdir] [config-file]\n"
		"       %s [-u] [-f | -o outfile] -e infile\n",
		__progname, __progname);

	exit(1);
}

int pflag = 0;
char *sflag = NULL;
char *bflag = NULL;
char *startdir;

int
main(int argc, char *argv[])
{
	char *p;
	const char *last_component;
	char *outfile = NULL;
	int ch, eflag, uflag, fflag;
	char dirbuffer[PATH_MAX];

	if (pledge("stdio rpath wpath cpath flock proc exec", NULL) == -1)
		err(1, "pledge");

	pflag = eflag = uflag = fflag = 0;
	while ((ch = getopt(argc, argv, "epfb:s:o:u")) != -1) {
		switch (ch) {

		case 'o':
			outfile = optarg;
			break;
		case 'u':
			uflag = 1;
			break;
		case 'f':
			fflag = 1;
			break;

		case 'e':
			eflag = 1;
			if (!isatty(STDIN_FILENO))
				verbose = 1;
			break;

		case 'p':
			/*
			 * Essentially the same as makeoptions PROF="-pg",
			 * but also changes the path from ../../compile/FOO
			 * to ../../compile/FOO.PROF; i.e., compile a
			 * profiling kernel based on a typical "regular"
			 * kernel.
			 *
			 * Note that if you always want profiling, you
			 * can (and should) use a "makeoptions" line.
			 */
			pflag = 1;
			break;

		case 'b':
			bflag = optarg;
			builddir = optarg;
			break;

		case 's':
			sflag = optarg;
			srcdir = optarg;
			break;

		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 1 || (eflag && argv[0] == NULL))

		usage();
	if (bflag) {
		startdir = getcwd(dirbuffer, sizeof dirbuffer);
		if (startdir == NULL)
			warn("Use of -b and can't getcwd, no make config");
	} else {
		startdir = "../../conf";
	}

	if (eflag) {
#ifdef MAKE_BOOTSTRAP
		errx(1, "UKC not available in this binary");
#else
		return (ukc(argv[0], outfile, uflag, fflag));
#endif
	}

	conffile = (argc == 1) ? argv[0] : "CONFIG";
	if (firstfile(conffile))
		err(2, "cannot read %s", conffile);

	/*
	 * Init variables.
	 */
	minmaxusers = 1;
	maxmaxusers = 10000;
	initintern();
	initfiles();
	initsem();
	devbasetab = ht_new();
	devatab = ht_new();
	selecttab = ht_new();
	needcnttab = ht_new();
	opttab = ht_new();
	mkopttab = ht_new();
	defopttab = ht_new();
	nextopt = &options;
	nextmkopt = &mkoptions;
	nextdefopt = &defoptions;

	/*
	 * Handle profiling (must do this before we try to create any
	 * files).
	 */
	last_component = strrchr(conffile, '/');
	last_component = (last_component) ? last_component + 1 : conffile;
	if (pflag) {
		if (asprintf(&p, "../compile/%s.PROF", last_component) == -1)
			err(1, NULL);
		(void)addmkoption(intern("PROF"), "-pg");
		(void)addoption(intern("GPROF"), NULL);
	} else {
		if (asprintf(&p, "../compile/%s", last_component) == -1)
			err(1, NULL);
	}
	defbuilddir = (argc == 0) ? "." : p;

	/*
	 * Parse config file (including machine definitions).
	 */
	if (yyparse())
		stop();

	/*
	 * Fix (as in `set firmly in place') files.
	 */
	if (fixfiles())
		stop();

	/*
	 * Fix objects and libraries.
	 */
	if (fixobjects())
		stop();

	/*
	 * Perform cross-checking.
	 */
	if (maxusers == 0) {
		if (defmaxusers) {
			(void)printf("maxusers not specified; %d assumed\n",
			    defmaxusers);
			maxusers = defmaxusers;
		} else {
			warnx("need \"maxusers\" line");
			errors++;
		}
	}
	if (crosscheck() || errors)
		stop();

	/*
	 * Squeeze things down and finish cross-checks (STAR checks must
	 * run after packing).
	 */
	pack();
	if (badstar())
		stop();

	/*
	 * Ready to go.  Build all the various files.
	 */
	if (mksymlinks() || mkmakefile() || mkheaders() || mkswap() ||
	    mkioconf())
		stop();
	optiondelta();
	return (0);
}

static int
mksymlink(const char *value, const char *path)
{
	int ret = 0;

	if (remove(path) && errno != ENOENT) {
		warn("remove(%s)", path);
		ret = 1;
	}
	if (symlink(value, path)) {
		warn("symlink(%s -> %s)", path, value);
		ret = 1;
	}
	return (ret);
}


/*
 * Make a symlink for "machine" so that "#include <machine/foo.h>" works,
 * and for the machine's CPU architecture, so that works as well.
 */
static int
mksymlinks(void)
{
	int ret;
	char *p, buf[PATH_MAX];
	const char *q;

	snprintf(buf, sizeof buf, "arch/%s/include", machine);
	p = sourcepath(buf);
	ret = mksymlink(p, "machine");
	if (machinearch != NULL) {
		snprintf(buf, sizeof buf, "arch/%s/include", machinearch);
		p = sourcepath(buf);
		q = machinearch;
	} else {
		p = strdup("machine");
		if (!p)
			errx(1, "out of memory");
		q = machine;
	}
	ret |= mksymlink(p, q);
	free(p);

	return (ret);
}

static __dead void
stop(void)
{
	(void)fprintf(stderr, "*** Stop.\n");
	exit(1);
}

/*
 * Define a standard option, for which a header file will be generated.
 */
void
defoption(const char *name)
{
	char *p, *low, c;
	const char *n;

	/*
	 * Convert to lower case.  The header file name will be
	 * in lower case, so we store the lower case version in
	 * the hash table to detect option name collisions.  The
	 * original string will be stored in the nvlist for use
	 * in the header file.
	 */
	low = emalloc(strlen(name) + 1);
	for (n = name, p = low; (c = *n) != '\0'; n++)
		*p++ = isupper((unsigned char)c) ?
		    tolower((unsigned char)c) : c;
	*p = 0;

	n = intern(low);
	free(low);
	(void)do_option(defopttab, &nextdefopt, n, name, "defopt");

	/*
	 * Insert a verbatim copy of the option name, as well,
	 * to speed lookups when creating the Makefile.
	 */
	(void)ht_insert(defopttab, name, (void *)name);
}

/*
 * Remove an option.
 */
void
removeoption(const char *name)
{
	struct nvlist *nv, *nvt;
	char *p, *low, c;
	const char *n;

	if ((nv = ht_lookup(opttab, name)) != NULL) {
		if (options == nv) {
			options = nv->nv_next;
			nvfree(nv);
		} else {
			nvt = options;
			while (nvt->nv_next != NULL) {
				if (nvt->nv_next == nv) {
					nvt->nv_next = nvt->nv_next->nv_next;
					nvfree(nv);
					break;
				} else
					nvt = nvt->nv_next;
			}
		}
	}

	(void)ht_remove(opttab, name);

	low = emalloc(strlen(name) + 1);
	/* make lowercase, then remove from select table */
	for (n = name, p = low; (c = *n) != '\0'; n++)
		*p++ = isupper((unsigned char)c) ?
		    tolower((unsigned char)c) : c;
	*p = 0;
	n = intern(low);
	free(low);
	(void)ht_remove(selecttab, n);
}

/*
 * Add an option from "options FOO".  Note that this selects things that
 * are "optional foo".
 */
void
addoption(const char *name, const char *value)
{
	char *p, *low, c;
	const char *n;

	if (do_option(opttab, &nextopt, name, value, "options"))
		return;

	low = emalloc(strlen(name) + 1);
	/* make lowercase, then add to select table */
	for (n = name, p = low; (c = *n) != '\0'; n++)
		*p++ = isupper((unsigned char)c) ?
		    tolower((unsigned char)c) : c;
	*p = 0;
	n = intern(low);
	free(low);
	(void)ht_insert(selecttab, n, (void *)n);
}

/*
 * Add a "make" option.
 */
void
addmkoption(const char *name, const char *value)
{

	(void)do_option(mkopttab, &nextmkopt, name, value, "mkoptions");
}

/*
 * Add a name=value pair to an option list.  The value may be NULL.
 */
static int
do_option(struct hashtab *ht, struct nvlist ***nppp, const char *name,
    const char *value, const char *type)
{
	struct nvlist *nv;

	/* assume it will work */
	nv = newnv(name, value, NULL, 0, NULL);
	if (ht_insert(ht, name, nv) == 0) {
		**nppp = nv;
		*nppp = &nv->nv_next;
		return (0);
	}

	/* oops, already got that option */
	nvfree(nv);
	if ((nv = ht_lookup(ht, name)) == NULL)
		panic("do_option");
	if (nv->nv_str != NULL)
		error("already have %s `%s=%s'", type, name, nv->nv_str);
	else
		error("already have %s `%s'", type, name);
	return (1);
}

/*
 * Return true if there is at least one instance of the given unit
 * on the given device attachment (or any units, if unit == WILD).
 */
int
deva_has_instances(struct deva *deva, int unit)
{
	struct devi *i;

	if (unit == WILD)
		return (deva->d_ihead != NULL);
	for (i = deva->d_ihead; i != NULL; i = i->i_asame)
		if (unit == i->i_unit)
			return (1);
	return (0);
}

/*
 * Return true if there is at least one instance of the given unit
 * on the given base (or any units, if unit == WILD).
 */
int
devbase_has_instances(struct devbase *dev, int unit)
{
	struct deva *da;

	for (da = dev->d_ahead; da != NULL; da = da->d_bsame)
		if (deva_has_instances(da, unit))
			return (1);
	return (0);
}

static int
hasparent(struct devi *i)
{
	struct nvlist *nv;
	int atunit = i->i_atunit;

	/*
	 * We determine whether or not a device has a parent in in one
	 * of two ways:
	 *	(1) If a parent device was named in the config file,
	 *	    i.e. cases (2) and (3) in sem.c:adddev(), then
	 *	    we search its devbase for a matching unit number.
	 *	(2) If the device was attach to an attribute, then we
	 *	    search all attributes the device can be attached to
	 *	    for parents (with appropriate unit numbers) that
	 *	    may be able to attach the device.
	 */

	/*
	 * Case (1): A parent was named.  Either it's configured, or not.
	 */
	if (i->i_atdev != NULL)
		return (devbase_has_instances(i->i_atdev, atunit));

	/*
	 * Case (2): No parent was named.  Look for devs that provide the attr.
	 */
	if (i->i_atattr != NULL)
		for (nv = i->i_atattr->a_refs; nv != NULL; nv = nv->nv_next)
			if (devbase_has_instances(nv->nv_ptr, atunit))
				return (1);
	return (0);
}

static int
cfcrosscheck(struct config *cf, const char *what, struct nvlist *nv)
{
	struct devbase *dev;
	struct devi *pd;
	int errs, devminor;

	if (maxpartitions <= 0)
		panic("cfcrosscheck");

	for (errs = 0; nv != NULL; nv = nv->nv_next) {
		if (nv->nv_name == NULL)
			continue;
		dev = ht_lookup(devbasetab, nv->nv_name);
		if (dev == NULL)
			panic("cfcrosscheck(%s)", nv->nv_name);
		devminor = minor(nv->nv_int) / maxpartitions;
		if (devbase_has_instances(dev, devminor))
			continue;
		if (devbase_has_instances(dev, STAR) &&
		    devminor >= dev->d_umax)
			continue;
		for (pd = allpseudo; pd != NULL; pd = pd->i_next)
			if (pd->i_base == dev && devminor < dev->d_umax &&
			    devminor >= 0)
				goto loop;
		(void)fprintf(stderr,
		    "%s:%d: %s says %s on %s, but there's no %s\n",
		    conffile, cf->cf_lineno,
		    cf->cf_name, what, nv->nv_str, nv->nv_str);
		errs++;
loop:
		;
	}
	return (errs);
}

/*
 * Cross-check the configuration: make sure that each target device
 * or attribute (`at foo[0*?]') names at least one real device.  Also
 * see that the root, swap, and dump devices for all configurations
 * are there.
 */
int
crosscheck(void)
{
	struct devi *i;
	struct config *cf;
	int errs;

	errs = 0;
	for (i = alldevi; i != NULL; i = i->i_next) {
		if (i->i_at == NULL || hasparent(i))
			continue;
		xerror(conffile, i->i_lineno,
		    "%s at %s is orphaned", i->i_name, i->i_at);
		(void)fprintf(stderr, " (%s %s declared)\n",
		    i->i_atunit == WILD ? "nothing matching" : "no",
		    i->i_at);
		errs++;
	}
	if (allcf == NULL) {
		(void)fprintf(stderr, "%s has no configurations!\n",
		    conffile);
		errs++;
	}
	for (cf = allcf; cf != NULL; cf = cf->cf_next) {
		if (cf->cf_root != NULL) {	/* i.e., not swap generic */
			errs += cfcrosscheck(cf, "root", cf->cf_root);
			errs += cfcrosscheck(cf, "swap", cf->cf_swap);
			errs += cfcrosscheck(cf, "dumps", cf->cf_dump);
		}
	}
	return (errs);
}

/*
 * Check to see if there is a *'d unit with a needs-count file.
 */
int
badstar(void)
{
	struct devbase *d;
	struct deva *da;
	struct devi *i;
	int errs, n;

	errs = 0;
	for (d = allbases; d != NULL; d = d->d_next) {
		for (da = d->d_ahead; da != NULL; da = da->d_bsame)
			for (i = da->d_ihead; i != NULL; i = i->i_asame) {
				if (i->i_unit == STAR)
					goto foundstar;
			}
		continue;
	foundstar:
		if (ht_lookup(needcnttab, d->d_name)) {
			warnx("%s's cannot be *'d until its driver is fixed",
			    d->d_name);
			errs++;
			continue;
		}
		for (n = 0; i != NULL; i = i->i_alias)
			if (!i->i_collapsed)
				n++;
		if (n < 1)
			panic("badstar() n<1");
	}
	return (errs);
}

/*
 * Verify/create builddir if necessary, change to it, and verify srcdir.
 * This will be called when we see the first include.
 */
void
setupdirs(void)
{
	struct stat st;
	FILE *fp;

	/* srcdir must be specified if builddir is not specified or if
	 * no configuration filename was specified. */
	if ((builddir || strcmp(defbuilddir, ".") == 0) && !srcdir) {
		error("source directory must be specified");
		exit(1);
	}

	if (srcdir == NULL)
		srcdir = "../../../..";
	if (builddir == NULL)
		builddir = defbuilddir;

	if (stat(builddir, &st) != 0) {
		if (mkdir(builddir, 0777))
			err(2, "cannot create %s", builddir);
	} else if (!S_ISDIR(st.st_mode))
		errc(2, ENOTDIR, "%s", builddir);
	if (chdir(builddir) != 0)
		errx(2, "cannot change to %s", builddir);
	if (stat(srcdir, &st) != 0 || !S_ISDIR(st.st_mode))
		errc(2, ENOTDIR, "%s", srcdir);

	if (bflag) {
		if (pledge("stdio rpath wpath cpath flock", NULL) == -1)
			err(1, "pledge");
		return;
	}

	if (stat("obj", &st) == 0)
		goto reconfig;

	fp = fopen("Makefile", "w");
	if (!fp)
		errx(2, "cannot create Makefile");
	if (fprintf(fp, ".include \"../Makefile.inc\"\n") < 0 ||
	    fclose(fp) == EOF)
		errx(2, "cannot write Makefile");

reconfig:
	if (system("make obj") != 0)
		exit(2);
	if (system("make config") != 0)
		exit(2);
	exit(0);
}

struct opt {
	const char *name;
	const char *val;
};

int
optcmp(const void *v1, const void *v2)
{
	const struct opt *sp1 = v1, *sp2 = v2;
	int r;

	r = strcmp(sp1->name, sp2->name);
	if (r == 0) {
		if (!sp1->val && !sp2->val)
			r = 0;
		else if (sp1->val && !sp2->val)
			r = -1;
		else if (sp2->val && !sp1->val)
			r = 1;
		else r = strcmp(sp1->val, sp2->val);
	}
	return (r);
}

void
optiondelta(void)
{
	struct nvlist *nv;
	char nbuf[BUFSIZ], obuf[BUFSIZ];	/* XXX size */
	int nnewopts, ret = 0, i;
	struct opt *newopts;
	FILE *fp;

	for (nnewopts = 0, nv = options; nv != NULL; nv = nv->nv_next)
		nnewopts++;
	newopts = ereallocarray(NULL, nnewopts, sizeof(struct opt));
	if (newopts == NULL)
		ret = 0;
	for (i = 0, nv = options; nv != NULL; nv = nv->nv_next, i++) {
		newopts[i].name = nv->nv_name;
		newopts[i].val = nv->nv_str;
	}
	qsort(newopts, nnewopts, sizeof (struct opt), optcmp);

	/* compare options against previous config */
	if ((fp = fopen("options", "r"))) {
		for (i = 0; !feof(fp) && i < nnewopts && ret == 0; i++) {
			if (newopts[i].val)
				snprintf(nbuf, sizeof nbuf, "%s=%s\n",
				    newopts[i].name, newopts[i].val);
			else
				snprintf(nbuf, sizeof nbuf, "%s\n",
				    newopts[i].name);
			if (fgets(obuf, sizeof obuf, fp) == NULL ||
			    strcmp(nbuf, obuf))
				ret = 1;
		}
		fclose(fp);
		fp = NULL;
	} else if (access("options", F_OK) == 0)
		ret = 1;

	/* replace with the new list of options */
	if ((fp = fopen("options", "w+"))) {
		rewind(fp);
		for (i = 0; i < nnewopts; i++) {
			if (newopts[i].val)
				fprintf(fp, "%s=%s\n", newopts[i].name,
				    newopts[i].val);
			else
				fprintf(fp, "%s\n", newopts[i].name);
		}
		fclose(fp);
	}
	free(newopts);
	if (ret == 0)
		return;
	(void)printf("Kernel options have changed -- you must run \"make clean\"\n");
}
@


1.56
log
@Use the err(3) family of functions more consistently.

ok jca, improvements and ok millert, natano
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.55 2016/10/16 09:36:46 natano Exp $	*/
d680 2
a681 1
	if (fprintf(fp, ".include \"../Makefile.inc\"\n") < 0 || fclose(fp))
@


1.55
log
@Remove the -g option. It is obsolete/undocumented since the initial
import from NetBSD in '95 and does nothing except print an error.

ok tb
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2016/10/16 09:19:15 natano Exp $	*/
d78 1
a78 1
void
d172 1
a172 2
		fprintf(stderr, "config: UKC not available in this binary\n");
		exit(1);
d179 2
a180 5
	if (firstfile(conffile)) {
		(void)fprintf(stderr, "config: cannot read %s: %s\n",
		    conffile, strerror(errno));
		exit(2);
	}
d245 1
a245 2
			(void)fprintf(stderr,
			    "config: need \"maxusers\" line\n");
d267 1
a267 1
	exit(0);
d276 1
a276 1
		warn("config: remove(%s)", path);
d280 1
a280 1
		warn("config: symlink(%s -> %s)", path, value);
d622 1
a622 2
			(void)fprintf(stderr,
		    "config: %s's cannot be *'d until its driver is fixed\n",
d659 8
a666 20
		if (mkdir(builddir, 0777)) {
			(void)fprintf(stderr, "config: cannot create %s: %s\n",
			    builddir, strerror(errno));
			exit(2);
		}
	} else if (!S_ISDIR(st.st_mode)) {
		(void)fprintf(stderr, "config: %s is not a directory\n",
		    builddir);
		exit(2);
	}
	if (chdir(builddir) != 0) {
		(void)fprintf(stderr, "config: cannot change to %s\n",
		    builddir);
		exit(2);
	}
	if (stat(srcdir, &st) != 0 || !S_ISDIR(st.st_mode)) {
		(void)fprintf(stderr, "config: %s is not a directory\n",
		    srcdir);
		exit(2);
	}
d678 4
a681 9
	if (!fp) {
		(void)fprintf(stderr, "config: cannot create Makefile\n");
		exit(2);
	}
	if (fprintf(fp, ".include \"../Makefile.inc\"\n") < 0) {
		(void)fprintf(stderr, "config: cannot create Makefile\n");
		exit(2);
	}
	fclose(fp);
@


1.54
log
@Remove declarations for optarg and optind. They are declared in <unistd.h>.
ok tb
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2016/10/16 08:47:17 natano Exp $	*/
d109 1
a109 1
	while ((ch = getopt(argc, argv, "egpfb:s:o:u")) != -1) {
a126 12

		case 'g':
			/*
			 * In addition to DEBUG, you probably wanted to
			 * set "options KGDB" and maybe others.  We could
			 * do that for you, but you really should just
			 * put them in the config file.
			 */
			(void)fputs(
			    "-g is obsolete (use makeoptions DEBUG=\"-g\")\n",
			    stderr);
			usage();
@


1.53
log
@Stop complaining about changed kernel options when called for an empty
directory. With the new kernel obj mechanism config always prints

	Kernel options have changed -- you must run "make clean"

on the first run. The message is suppressed when the compile directory
didn't exist before, but now the directory always exists when config is
run, so we have to use something else to detect if this is a "fresh" run
or an update of an existing directory. Use the options file instead,
which is used to track the kernel options of the last config run. If the
file doesn't exist, it is safe to assume, that this is a "fresh"
directory.

ok tb deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2016/10/14 18:51:04 deraadt Exp $	*/
a59 3

extern char *optarg;
extern int optind;
@


1.52
log
@Change the default non -b behaviour of config(8) to operate with the
new compile behaviour:
- create a Makefile including ../Makefile.inc
- run "make obj" to create the obj directory
- run "make config", to use logic in ../Makefile.inc to re-run config
  with the correct -b options, thereby creating a layout in obj/
- exit 0.
As a result, the old patterns our fingers are used to continue to work
and there will be fewer curses.
ok natano tb
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.51 2016/09/12 14:33:12 akfaew Exp $	*/
a78 2
int	madedir = 0;

a684 1
		madedir = 1;
d788 1
a788 1
	} else
d804 1
a804 1
	if (ret == 0 || madedir == 1)
@


1.51
log
@strlen + emalloc + snprintf = asprintf

ok deraadt@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2015/10/16 13:37:44 millert Exp $	*/
d110 1
a110 1
	if (pledge("stdio rpath wpath cpath flock", NULL) == -1)
d667 1
d703 27
@


1.50
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.49 2015/10/12 15:56:58 deraadt Exp $	*/
d229 2
a230 3
		int len = strlen(last_component) + 17;
		p = emalloc(len);
		(void)snprintf(p, len, "../compile/%s.PROF", last_component);
d234 2
a235 3
		int len = strlen(last_component) + 12;
		p = emalloc(len);
		(void)snprintf(p, len, "../compile/%s", last_component);
@


1.49
log
@pledge "stdio rpath wpath cpath"; all the path options are used
until the bitter end.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.48 2015/01/16 06:40:16 deraadt Exp $	*/
d110 1
a110 1
	if (pledge("stdio rpath wpath cpath", NULL) == -1)
@


1.48
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2014/05/18 09:29:54 espie Exp $	*/
d109 3
@


1.47
log
@use reallocarray and friends. okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2013/11/23 17:38:15 deraadt Exp $	*/
a45 1
#include <sys/param.h>
d54 1
d316 1
a316 1
	char *p, buf[MAXPATHLEN];
@


1.46
log
@unsigned char casts for ctype
ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2013/10/29 15:37:56 espie Exp $	*/
d738 1
a738 1
	newopts = (struct opt *)emalloc(nnewopts * sizeof(struct opt));
@


1.45
log
@emit an extra "config" convenience target that allows one
to rerun config without changing directories.

Lots of inputs by deraadt@@, who wanted it to work for movable
relative directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2012/06/22 22:02:29 guenther Exp $	*/
d363 2
a364 1
		*p++ = isupper(c) ? tolower(c) : c;
d410 2
a411 1
		*p++ = isupper(c) ? tolower(c) : c;
d434 2
a435 1
		*p++ = isupper(c) ? tolower(c) : c;
@


1.44
log
@Improve error messages when removing/recreating symlinks in the build dir

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2011/10/02 22:20:49 edd Exp $	*/
d96 5
d107 2
a108 1
	int pflag, ch, eflag, uflag, fflag;
d157 1
d162 1
d174 1
d176 7
@


1.43
log
@Fix some minor things in config(8):
 * As haesbaert suggests, correctly order include files.
 * Found some old style function defs. Updated.
 * Found a prototype inside a function. Moved.

OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2011/04/15 02:48:14 deraadt Exp $	*/
d275 17
d305 1
a305 6
	(void)unlink("machine");
	ret = symlink(p, "machine");
	if (ret)
		(void)fprintf(stderr, "config: symlink(machine -> %s): %s\n",
		    p, strerror(errno));

d316 1
a316 5
	(void)unlink(q);
	ret = symlink(p, q);
	if (ret)
		(void)fprintf(stderr, "config: symlink(%s -> %s): %s\n",
		    q, p, strerror(errno));
@


1.42
log
@do not need the run "make depend" reminder anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2009/10/27 23:59:51 deraadt Exp $	*/
d47 1
d49 1
a51 1
#include <err.h>
d55 1
@


1.41
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2008/10/03 13:01:26 deraadt Exp $	*/
a268 1
	(void)printf("Don't forget to run \"make depend\"\n");
@


1.40
log
@correct comment; a part of PR4184
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2007/03/20 19:42:14 jmc Exp $	*/
a42 6

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */
@


1.39
log
@make synopsis/usage() a little nicer;
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2005/11/12 15:40:09 deraadt Exp $	*/
d388 1
a388 1
	/* make lowercase, then add to select table */
@


1.38
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2005/04/28 22:28:00 deraadt Exp $	*/
d92 5
a96 3
	fprintf(stderr, "usage: %s [-p] [-s srcdir] [-b builddir] [sysname]\n",
	    __progname);
	fprintf(stderr, "       %s -e [-u] [-f | -o newkernel] kernel\n", __progname);
@


1.37
log
@if running in -e mode, and stdin is not a tty, then re-print the commands
that are read.  This makes this more easily to script.
Note:  sparc needs a new config(8) installed before attempting to build
a new release because of stuff in src/etc/etc.sparc/Makefile.inc
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2004/01/04 18:30:05 deraadt Exp $	*/
d213 1
a213 1
		p  = emalloc(len);
@


1.36
log
@knf and lint
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2004/01/04 00:47:01 deraadt Exp $	*/
d85 2
d122 2
a159 1
		case '?':
@


1.35
log
@Wall and spacing, I am hunting bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2003/12/29 05:26:11 deraadt Exp $	*/
d661 1
a661 1
			      builddir);
d666 1
a666 1
			      builddir);
d671 1
a671 1
			      srcdir);
@


1.34
log
@similar to pr 3614, but simplified diff. reduce 500-byte limit on identifiers;
originally from Alexander.Farber@@t-online.de
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2003/09/26 17:01:14 deraadt Exp $	*/
d56 1
@


1.33
log
@use emalloc and watch for strdup failure
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2003/06/28 04:55:07 deraadt Exp $	*/
d326 1
a327 2
	char *p, c;
	char low[500];
d336 1
d342 1
d359 1
a360 2
	char *p, c;
	char low[500];
d363 1
a363 2
		if (options == nv)
		{
d373 1
a373 2
				}
				else
d381 1
d387 1
d398 1
a399 2
	char *p, c;
	char low[500];
d404 1
d410 1
@


1.32
log
@ansi & prototype cleanup.  tested in mkr on most arch's.  ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2003/06/02 23:36:52 millert Exp $	*/
d299 2
d709 1
a709 1
	newopts = (struct opt *)malloc(nnewopts * sizeof(struct opt));
@


1.31
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2003/03/28 16:52:21 millert Exp $	*/
d85 1
a85 1
usage()
d96 1
a96 3
main(argc, argv)
	int argc;
	char **argv;
d279 1
a279 1
mksymlinks()
d312 1
a312 1
stop()
d322 1
a322 2
defoption(name)
	const char *name;
d353 1
a353 2
removeoption(name)
        const char *name;
d394 1
a394 2
addoption(name, value)
	const char *name, *value;
d415 1
a415 2
addmkoption(name, value)
	const char *name, *value;
d425 2
a426 4
do_option(ht, nppp, name, value, type)
	struct hashtab *ht;
	struct nvlist ***nppp;
	const char *name, *value, *type;
d454 1
a454 3
deva_has_instances(deva, unit)
	struct deva *deva;
	int unit;
d471 1
a471 3
devbase_has_instances(dev, unit)
	struct devbase *dev;
	int unit;
d482 1
a482 2
hasparent(i)
	struct devi *i;
d516 1
a516 4
cfcrosscheck(cf, what, nv)
	struct config *cf;
	const char *what;
	struct nvlist *nv;
d559 1
a559 1
crosscheck()
d595 1
a595 1
badstar()
d632 1
a632 1
setupdirs()
d678 1
a678 2
optcmp(sp1, sp2)
	struct opt *sp1, *sp2;
d680 1
d697 1
a697 1
optiondelta()
@


1.30
log
@We were malloc()ing one byte more than we needed; Alexander Farber
Closes PR #3168
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2002/09/06 19:02:06 deraadt Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.29
log
@; after label:
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2002/07/14 02:59:41 deraadt Exp $	*/
d220 1
a220 1
		int len = strlen(last_component) + 13;
@


1.28
log
@kill sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2002/06/14 21:35:01 todd Exp $	*/
d567 1
@


1.27
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2002/05/29 09:45:39 deraadt Exp $	*/
d214 3
a216 2
		p  = emalloc(strlen(last_component) + 17);
		(void)sprintf(p, "../compile/%s.PROF", last_component);
d220 3
a222 2
		p = emalloc(strlen(last_component) + 13);
		(void)sprintf(p, "../compile/%s", last_component);
@


1.26
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2002/03/14 16:44:24 mpech Exp $	*/
d348 1
a348 1
	 * Insert a verbatum copy of the option name, as well,
d510 1
a510 1
	 *	    for parents (with appropriate unit numebrs) that
@


1.25
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2002/02/17 19:42:35 millert Exp $	*/
d289 1
a289 1
	sprintf(buf, "arch/%s/include", machine);
d298 1
a298 1
		sprintf(buf, "arch/%s/include", machinearch);
@


1.24
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2002/02/16 21:28:01 millert Exp $	*/
d104 1
a104 1
	register char *p;
d329 2
a330 2
	register const char *n;
	register char *p, c;
d361 3
a363 3
	register struct nvlist *nv, *nvt;
	register const char *n;
	register char *p, c;
d403 2
a404 2
	register const char *n;
	register char *p, c;
d438 1
a438 1
	register struct nvlist *nv;
d465 1
a465 1
	register struct deva *deva;
d468 1
a468 1
	register struct devi *i;
d484 1
a484 1
	register struct devbase *dev;
d487 1
a487 1
	register struct deva *da;
d497 1
a497 1
	register struct devi *i;
d499 1
a499 1
	register struct nvlist *nv;
d532 1
a532 1
	register struct config *cf;
d534 1
a534 1
	register struct nvlist *nv;
d536 2
a537 2
	register struct devbase *dev;
	register struct devi *pd;
d578 2
a579 2
	register struct devi *i;
	register struct config *cf;
d614 4
a617 4
	register struct devbase *d;
	register struct deva *da;
	register struct devi *i;
	register int errs, n;
d716 1
a716 1
	register struct nvlist *nv;
@


1.23
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2001/12/11 23:47:00 miod Exp $	*/
d77 2
a78 2
static int do_option __P((struct hashtab *, struct nvlist ***,
			const char *, const char *, const char *));
@


1.22
log
@Make Makefile.boot produce a working config(8) again, at least on 4.4BSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2001/12/05 10:11:23 deraadt Exp $	*/
d65 2
a66 2
int	firstfile __P((const char *));
int	yyparse __P((void));
d76 1
a76 1
static __dead void stop __P((void));
d79 6
a84 6
static int crosscheck __P((void));
static int badstar __P((void));
static int mksymlinks __P((void));
static int hasparent __P((struct devi *));
static int cfcrosscheck __P((struct config *, const char *, struct nvlist *));
static void optiondelta __P((void));
@


1.21
log
@more free KNF from maja, though this was hard to do
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2000/01/04 14:23:43 angelos Exp $	*/
d172 5
a176 1
	if (eflag)
d178 2
@


1.20
log
@Add rmoption/rmoptions; useful for people who want a slightly
modified version of GENERIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 1999/11/27 03:49:13 d Exp $	*/
d697 1
a697 1
			r = 0;	
@


1.19
log
@re-enable config without arguments; fix usage
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 1999/10/04 20:00:51 deraadt Exp $	*/
d346 41
@


1.18
log
@config -e support; ukc from maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 1998/05/25 09:35:06 deraadt Exp $	*/
d93 1
a93 1
	fprintf(stderr, "usage: %s [-p] [-s srcdir] [-b builddir] sysname\n",
d95 1
a95 1
	fprintf(stderr, "       %s -e [-u] [-o newkernel] kernel\n", __progname);
d169 1
a169 1
	if (argc > 1 || !argv[0])
@


1.17
log
@missing :; tv
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 1997/11/13 08:21:54 deraadt Exp $	*/
d88 11
d106 2
a107 1
	int pflag, ch;
d109 2
a110 2
	pflag = 0;
	while ((ch = getopt(argc, argv, "gpb:s:")) != -1) {
d113 14
d137 1
a137 1
			goto usage;
d163 1
a163 1
			goto usage;
d169 6
a174 5
	if (argc > 1) {
usage:
		(void)fputs("usage: config [-p] [-s srcdir] [-b builddir] sysname\n", stderr);
		exit(1);
	}
@


1.16
log
@from mycroft;
Allow options and makeoptions to take an empty string as a value.
Add `object' and `library' keywords to pull in precompiled .o and .a files.
Syntax is like the `file' keyword; e.g.:
object  arch/i386/i386/mumble.o         [mumble] [needs-flag]
Largely from Michael Richardson in PR 3833, with some changes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 1997/07/06 04:07:09 downsj Exp $	*/
d486 1
a486 1
		    "%s%d: %s says %s on %s, but there's no %s\n",
@


1.15
log
@-Wall happiness
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1997/07/06 03:54:05 downsj Exp $	*/
d201 6
@


1.14
log
@Add defopt support, from NetBSD; thorpej (I think, I don't have the commit
message).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 1997/04/14 02:24:04 deraadt Exp $	*/
a571 1
	char *prof;
@


1.13
log
@do not whine about new directories; reported by briggs
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.12 1997/04/04 19:56:35 deraadt Exp $	*/
/*	$NetBSD: main.c,v 1.18 1996/08/31 20:58:20 mycroft Exp $	*/
a70 1
static struct hashtab *opttab;
d73 1
d169 1
d172 1
d281 32
@


1.12
log
@with small quantities of beer and pizza i produce fewer bugs. really.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1997/04/04 19:54:29 deraadt Exp $	*/
d86 2
d558 1
d651 1
a651 1
	if (ret == 0)
@


1.11
log
@if the user changes an option, spit out a warning telling them they need
to make clean. i expect i will get compliments for this change, but
i'd really rather receive beer and pizza.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1997/01/18 02:24:16 briggs Exp $	*/
d586 3
a588 3
		if (!sp1 && !sp2)
			r = 0;
		else if (sp1 && !sp2)
d590 1
a590 1
		else if (sp2 && !sp1)
@


1.10
log
@Sync. with current NetBSD--keeping local changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1997/01/15 23:43:53 millert Exp $	*/
d84 1
d231 1
d571 80
@


1.9
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1996/10/23 22:37:53 niklas Exp $	*/
d114 1
a114 1
			 * to ../../compile/FOO.prof; i.e., compile a
d422 3
d524 45
@


1.8
log
@Merge of NetBSD 961020.  Includes flexible build/source dir specs
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1996/09/13 04:25:41 mickey Exp $	*/
d95 1
a95 1
	while ((ch = getopt(argc, argv, "gpb:s:")) != EOF) {
@


1.7
log
@remove mapartitions default.
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.6 1996/09/12 07:51:17 mickey Exp $	*/
/*	$NetBSD: main.c,v 1.17 1996/03/17 11:50:13 cgd Exp $	*/
d56 1
d91 1
a92 1
	struct stat st;
d95 1
a95 1
	while ((ch = getopt(argc, argv, "gp")) != EOF) {
d124 8
d140 1
a140 1
	if (argc != 1) {
d142 1
a142 1
		(void)fputs("usage: config [-p] sysname\n", stderr);
d145 1
a145 1
	conffile = argv[0];
d173 2
d176 2
a177 5
		char *s;

		s = emalloc(strlen(conffile) + sizeof(".PROF"));
		(void)sprintf(s, "%s.PROF", conffile);
		confdirbase = s;
d180 3
a182 16
	} else
		confdirbase = conffile;

	/*
	 * Verify, creating if necessary, the compilation directory.
	 */
	p = path(NULL);
	if (stat(p, &st)) {
		if (mkdir(p, 0777)) {
			(void)fprintf(stderr, "config: cannot create %s: %s\n",
			    p, strerror(errno));
			exit(2);
		}
	} else if (!S_ISDIR(st.st_mode)) {
		(void)fprintf(stderr, "config: %s is not a directory\n", p);
		exit(2);
d184 1
d241 2
a242 1
	char *p, buf[200];
d244 4
a247 4
	p = path("machine");
	(void)sprintf(buf, "../../include");
	(void)unlink(p);
	ret = symlink(buf, p);
d249 2
a250 3
		(void)fprintf(stderr, "config: symlink(%s -> %s): %s\n",
		    p, buf, strerror(errno));
	free(p);
d253 3
a255 2
		p = path(machinearch);
		(void)sprintf(buf, "../../../%s/include", machinearch);
d257 2
a258 2
		p = path(machine);
		(void)sprintf(buf, "machine");
d260 2
a261 2
	(void)unlink(p);
	ret = symlink(buf, p);
d264 1
a264 1
		    p, buf, strerror(errno));
@


1.6
log
@set maxpartitions to machine default.
fix shift/reduce conflicts in grammar (i'm ukrainian, not else ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/08/29 03:33:06 deraadt Exp $	*/
a61 1
#include <machine/disklabel.h>
a147 1
	maxpartitions = MAXPARTITIONS;
@


1.5
log
@fix some warnings and errors
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1996/03/25 15:55:06 niklas Exp $	*/
d62 1
d149 1
@


1.4
log
@sync to netbsd 960418
@
text
@d248 1
a248 1
	(void)sprintf(buf, "../../include", machine);
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: main.c,v 1.13 1996/03/03 17:28:17 thorpej Exp $	*/
d4 1
a4 1
/* 
a80 1
static int has_instances __P((struct devbase *, int));
d152 1
d326 1
a326 1
	nv = newnv(name, value, NULL, 0);
d346 1
a346 1
 * on the given base (or any units, if unit == WILD).
d348 3
a350 3
static int
has_instances(dev, unit)
	register struct devbase *dev;
d356 2
a357 2
		return (dev->d_ihead != NULL);
	for (i = dev->d_ihead; i != NULL; i = i->i_bsame)
d363 17
d387 21
a407 2
	if (i->i_atdev != NULL && has_instances(i->i_atdev, atunit))
		return (1);
d410 1
a410 1
			if (has_instances(nv->nv_ptr, atunit))
d423 1
a423 1
	int errs;
d431 5
a435 2
		if (has_instances(dev, STAR) ||
		    has_instances(dev, minor(nv->nv_int) / maxpartitions))
d438 2
a439 3
			if (pd->i_base == dev &&
			    (minor(nv->nv_int) / maxpartitions) < dev->d_umax &&
			    (minor(nv->nv_int) / maxpartitions) >= 0)
d470 3
a472 5
		if (i->i_atunit == WILD)
			(void)fprintf(stderr, " (no %s declared)\n",
			    i->i_at);
		else
			(void)fprintf(stderr, " (no %s declared)\n", i->i_at);
d491 1
a491 2
 * Check to see if there is more than one *'d unit for any device,
 * or a *'d unit with a needs-count file.
d497 1
d503 5
a507 3
		for (i = d->d_ihead; i != NULL; i = i->i_bsame)
			if (i->i_unit == STAR)
				goto foundstar;
a521 6
		if (n == 1)
			continue;
		(void)fprintf(stderr,
		    "config: %d %s*'s in configuration; can only have 1\n",
		    n, d->d_name);
		errs++;
@


1.2
log
@for orphaned devices, print the parent that cannot be found; from banshee@@gabriella.resort.com; netbsd pr#1800
@
text
@d1 3
a45 1
 *	$Id: main.c,v 1.1.1.1 1995/10/18 08:48:33 deraadt Exp $
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
 *	$Id: main.c,v 1.12 1995/04/28 06:55:09 cgd Exp $
d431 2
a432 2
			(void)fprintf(stderr, " (no %s's declared)\n",
			    i->i_base->d_name);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
