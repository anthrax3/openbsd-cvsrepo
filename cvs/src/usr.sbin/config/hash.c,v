head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.10
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.12
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.8
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.4
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.12
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.8
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.4
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.14.0.32
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.30
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.28
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.24
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.26
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.22
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.20
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.18
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.16
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.14
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.12
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.10
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.01.17.07.37.14;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	iHtj9Ft11QOX8Zfw;

1.17
date	2015.01.16.16.25.50;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	yATCAkjABfBH86n1;

1.16
date	2014.05.18.09.29.54;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.10.02.22.20.49;	author edd;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.04.18.30.05;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.28.04.55.07;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.06.21.10.20;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.15.01.49.52;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.15.01.47.13;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.04.14.23.43;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	97.08.07.10.36.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.07.10.22.25;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.18.02.24.15;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.40.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.05;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@document the <sys/param.h>
@
text
@/*	$OpenBSD: hash.c,v 1.17 2015/01/16 16:25:50 deraadt Exp $	*/
/*	$NetBSD: hash.c,v 1.4 1996/11/07 22:59:43 gwr Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)hash.c	8.1 (Berkeley) 6/6/93
 */

#include <sys/param.h>	/* ALIGNBYTES */

#include <stdlib.h>
#include <string.h>

#include "config.h"

/*
 * Interned strings are kept in a hash table.  By making each string
 * unique, the program can compare strings by comparing pointers.
 */
struct hashent {
	struct	hashent *h_next;	/* hash buckets are chained */
	const char *h_name;		/* the string */
	u_int	h_hash;			/* its hash value */
	void	*h_value;		/* other values (for name=value) */
};
struct hashtab {
	size_t	ht_size;		/* size (power of 2) */
	u_int	ht_mask;		/* == ht_size - 1 */
	u_int	ht_used;		/* number of entries used */
	u_int	ht_lim;			/* when to expand */
	struct	hashent **ht_tab;	/* base of table */
};
static struct hashtab strings;

/*
 * HASHFRACTION controls ht_lim, which in turn controls the average chain
 * length.  We allow a few entries, on average, as comparing them is usually
 * cheap (the h_hash values prevent a strcmp).
 */
#define	HASHFRACTION(sz) ((sz) * 3 / 2)

/* round up to next multiple of y, where y is a power of 2 */
#define	ROUND(x, y) (((x) + (y) - 1) & ~((y) - 1))

static void *poolalloc(size_t);
static void ht_init(struct hashtab *, size_t);
static void ht_expand(struct hashtab *);
/*
 * Allocate space that will never be freed.
 */
static void *
poolalloc(size_t size)
{
	char *p;
	size_t alloc;
	static char *pool;
	static size_t nleft;

	if (nleft < size) {
		/*
		 * Compute a `good' size to allocate via malloc.
		 * 16384 is a guess at a good page size for malloc;
		 * 32 is a guess at malloc's overhead.
		 */
		alloc = ROUND(size + 32, 16384) - 32;
		p = emalloc(alloc);
		nleft = alloc - size;
	} else {
		p = pool;
		nleft -= size;
	}
	pool = p + size;
	return (p);
}

/*
 * Initialize a new hash table.  The size must be a power of 2.
 */
static void
ht_init(struct hashtab *ht, size_t sz)
{
	struct hashent **h;
	u_int n;

	h = ereallocarray(NULL, sz, sizeof *h);
	ht->ht_tab = h;
	ht->ht_size = sz;
	ht->ht_mask = sz - 1;
	for (n = 0; n < sz; n++)
		*h++ = NULL;
	ht->ht_used = 0;
	ht->ht_lim = HASHFRACTION(sz);
}

/*
 * Expand an existing hash table.
 */
static void
ht_expand(struct hashtab *ht)
{
	struct hashent *p, **h, **oldh, *q;
	u_int n, i;

	n = ht->ht_size * 2;
	h = ecalloc(n, sizeof *h);
	oldh = ht->ht_tab;
	n--;
	for (i = ht->ht_size; i != 0; i--) {
		for (p = *oldh++; p != NULL; p = q) {
			q = p->h_next;
			p->h_next = h[p->h_hash & n];
			h[p->h_hash & n] = p;
		}
	}
	free(ht->ht_tab);
	ht->ht_tab = h;
	ht->ht_mask = n;
	ht->ht_size = ++n;
	ht->ht_lim = HASHFRACTION(n);
}

/*
 * Make a new hash entry, setting its h_next to NULL.
 */
static __inline struct hashent *
newhashent(const char *name, u_int h)
{
	struct	hashent *hp;
	char	*m;

	m = poolalloc(sizeof(*hp) + ALIGNBYTES);
	hp = (struct hashent *)ALIGN(m);
	hp->h_name = name;
	hp->h_hash = h;
	hp->h_next = NULL;
	return (hp);
}

/*
 * Hash a string.
 */
static __inline u_int
hash(const char *str)
{
	u_int h;

	for (h = 0; *str;)
		h = (h << 5) + h + *str++;
	return (h);
}

void
initintern(void)
{

	ht_init(&strings, 128);
}

/*
 * Generate a single unique copy of the given string.  We expect this
 * function to be used frequently, so it should be fast.
 */
const char *
intern(const char *s)
{
	struct hashtab *ht;
	struct hashent *hp, **hpp;
	u_int h;
	char *p;
	size_t l;

	ht = &strings;
	h = hash(s);
	hpp = &ht->ht_tab[h & ht->ht_mask];
	for (; (hp = *hpp) != NULL; hpp = &hp->h_next)
		if (hp->h_hash == h && strcmp(hp->h_name, s) == 0)
			return (hp->h_name);
	l = strlen(s) + 1;
	p = poolalloc(l);
	bcopy(s, p, l);
	*hpp = newhashent(p, h);
	if (++ht->ht_used > ht->ht_lim)
		ht_expand(ht);
	return (p);
}

struct hashtab *
ht_new(void)
{
	struct hashtab *ht;

	ht = emalloc(sizeof *ht);
	ht_init(ht, 8);
	return (ht);
}

/*
 * Remove.
 */
int
ht_remove(struct hashtab *ht, const char *nam)
{
	struct hashent *hp, *thp;
	u_int h;

	h = hash(nam);
	hp = ht->ht_tab[h & ht->ht_mask];
	while (hp && hp->h_name == nam)	{
		ht->ht_tab[h & ht->ht_mask] = hp->h_next;
		/* XXX free hp ? */
		hp = ht->ht_tab[h & ht->ht_mask];
	}

	if ((hp = ht->ht_tab[h & ht->ht_mask]) == NULL)
		return (0);

	for (thp = hp->h_next; thp != NULL; thp = hp->h_next) {
		if (thp->h_name == nam) {
			hp->h_next = thp->h_next;
			/* XXX free thp ? */
		} else
			hp = thp;
	}

	return (0);
}

/*
 * Insert and/or replace.
 */
int
ht_insrep(struct hashtab *ht, const char *nam, void *val, int replace)
{
	struct hashent *hp, **hpp;
	u_int h;

	h = hash(nam);
	hpp = &ht->ht_tab[h & ht->ht_mask];
	for (; (hp = *hpp) != NULL; hpp = &hp->h_next) {
		if (hp->h_name == nam) {
			if (replace)
				hp->h_value = val;
			return (1);
		}
	}
	*hpp = hp = newhashent(nam, h);
	hp->h_value = val;
	if (++ht->ht_used > ht->ht_lim)
		ht_expand(ht);
	return (0);
}

void *
ht_lookup(struct hashtab *ht, const char *nam)
{
	struct hashent *hp, **hpp;
	u_int h;

	h = hash(nam);
	hpp = &ht->ht_tab[h & ht->ht_mask];
	for (; (hp = *hpp) != NULL; hpp = &hp->h_next)
		if (hp->h_name == nam)
			return (hp->h_value);
	return (NULL);
}
@


1.17
log
@More evil bootstrap code.  #ifndef ALIGNBYTES  #define ALIGNBYTES 3.
Which makes this code go all wrong depending on where a system has put
their things like ALIGNBYTES.
Delete with prejudice.  When someone needs to compile this in another
environment, they need to face this hurdle, and maybe change the
embedded memory allocator...
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.16 2014/05/18 09:29:54 espie Exp $	*/
d44 1
a44 1
#include <sys/param.h>
@


1.16
log
@use reallocarray and friends. okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.15 2011/10/02 22:20:49 edd Exp $	*/
a49 11

/*
 * These are really for MAKE_BOOTSTRAP but harmless.
 * XXX - Why not just use malloc in here, anyway?
 */
#ifndef	ALIGNBYTES
#define	ALIGNBYTES 3
#endif
#ifndef ALIGN
#define	ALIGN(p)	(((long)(p) + ALIGNBYTES) &~ ALIGNBYTES)
#endif
@


1.15
log
@Fix some minor things in config(8):
 * As haesbaert suggests, correctly order include files.
 * Found some old style function defs. Updated.
 * Found a prototype inside a function. Moved.

OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.14 2004/01/04 18:30:05 deraadt Exp $	*/
d131 1
a131 1
	h = emalloc(sz * sizeof *h);
d151 1
a151 3
	h = emalloc(n * sizeof *h);
	for (i = 0; i < n; i++)
		h[i] = NULL;
@


1.14
log
@knf and lint
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.13 2003/06/28 04:55:07 deraadt Exp $	*/
d45 1
d48 1
@


1.13
log
@ansi & prototype cleanup.  tested in mkr on most arch's.  ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.12 2003/06/02 23:36:52 millert Exp $	*/
d171 1
a171 1
static inline struct hashent *
d188 1
a188 1
static inline u_int
d255 1
a255 1
	        ht->ht_tab[h & ht->ht_mask] = hp->h_next;
d261 1
a261 1
	        return (0);
d264 2
a265 2
	        if (thp->h_name == nam) {
		        hp->h_next = thp->h_next;
d268 1
a268 1
		        hp = thp;
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.11 2002/09/06 21:10:20 henning Exp $	*/
d89 3
d96 1
a96 2
poolalloc(size)
	size_t size;
d124 1
a124 3
ht_init(ht, sz)
	struct hashtab *ht;
	size_t sz;
d143 1
a143 2
ht_expand(ht)
	struct hashtab *ht;
d199 1
a199 1
initintern()
d210 1
a210 2
intern(s)
	const char *s;
d234 1
a234 1
ht_new()
d247 1
a247 3
ht_remove(ht, nam)
	struct hashtab *ht;
	const char *nam;
d278 1
a278 5
ht_insrep(ht, nam, val, replace)
	struct hashtab *ht;
	const char *nam;
	void *val;
	int replace;
d300 1
a300 3
ht_lookup(ht, nam)
	struct hashtab *ht;
	const char *nam;
@


1.11
log
@ansi
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.10 2002/03/14 16:44:24 mpech Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.9 2000/11/15 01:49:52 angelos Exp $	*/
d177 1
a177 3
newhashent(name, h)
	const char *name;
	u_int h;
d179 2
a180 2
	struct hashent *hp;
	char *m;
d194 1
a194 2
hash(str)
	const char *str;
@


1.9
log
@Last commit introduced extra space (lame)
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.8 2000/11/15 01:47:13 angelos Exp $	*/
d100 2
a101 2
	register char *p;
	register size_t alloc;
d127 1
a127 1
	register struct hashtab *ht;
d130 2
a131 2
	register struct hashent **h;
	register u_int n;
d148 1
a148 1
	register struct hashtab *ht;
d150 2
a151 2
	register struct hashent *p, **h, **oldh, *q;
	register u_int n, i;
d181 2
a182 2
	register struct hashent *hp;
	register char *m;
d197 1
a197 1
	register const char *str;
d199 1
a199 1
	register u_int h;
d219 1
a219 1
	register const char *s;
d221 5
a225 5
	register struct hashtab *ht;
	register struct hashent *hp, **hpp;
	register u_int h;
	register char *p;
	register size_t l;
d245 1
a245 1
	register struct hashtab *ht;
d257 2
a258 2
	register struct hashtab *ht;
	register const char *nam;
d260 2
a261 2
	register struct hashent *hp, *thp;
	register u_int h;
d290 2
a291 2
	register struct hashtab *ht;
	register const char *nam;
d295 2
a296 2
	register struct hashent *hp, **hpp;
	register u_int h;
d316 2
a317 2
	register struct hashtab *ht;
	register const char *nam;
d319 2
a320 2
	register struct hashent *hp, **hpp;
	register u_int h;
@


1.8
log
@Fix bug introduced with overriding of pseudo-devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.7 2000/01/04 14:23:43 angelos Exp $	*/
d275 1
a275 1
	        if (thp->h_name ==  nam) {
@


1.7
log
@Add rmoption/rmoptions; useful for people who want a slightly
modified version of GENERIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.6 1997/08/07 10:36:57 deraadt Exp $	*/
d267 1
a267 1
		/* XXX Free hp ? */
d275 1
a275 1
	        if (thp->h_name == nam) {
d277 1
a277 1
			/* XXX Free hp ? */
@


1.6
log
@jason is tired.  this is not needed. our locator table stuff uses less
memory too.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash.c,v 1.4 1997/01/18 02:24:15 briggs Exp $	*/
d250 33
@


1.5
log
@cf_locnames support, from NetBSD (jtk, according to the RCSids).
@
text
@d2 1
a2 1
/*	$NetBSD: hash.c,v 1.5 1997/03/14 00:14:12 jtk Exp $	*/
a294 24
}

/*
 * first parameter to callback is the entry name from the hash table
 * second parameter is the value from the hash table
 * third argument is passed through from the "arg" parameter to ht_enumerate()
 */

int
ht_enumerate(ht, cbfunc, arg)
	struct hashtab *ht;
	ht_callback cbfunc;
	void *arg;
{
	struct hashent *hp, **hpp;
	register u_int i;
	int rval = 0;

	for (i = 0; i < ht->ht_size; i++) {
		hpp = &ht->ht_tab[i];
		for (; (hp = *hpp) != NULL; hpp = &hp->h_next)
			rval += (*cbfunc)(hp->h_name, hp->h_value, arg);
	}
	return rval;
@


1.4
log
@Sync. with current NetBSD--keeping local changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: hash.c,v 1.3 1996/04/21 23:40:12 deraadt Exp $	*/
/*	$NetBSD: hash.c,v 1.4 1996/11/07 22:59:43 gwr Exp $	*/
d295 24
@


1.3
log
@sync to netbsd 960418
@
text
@d1 2
a2 2
/*	$OpenBSD: hash.c,v 1.2 1996/03/25 15:55:05 niklas Exp $	*/
/*	$NetBSD: hash.c,v 1.3 1996/03/17 13:18:20 cgd Exp $	*/
d52 11
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: hash.c,v 1.2 1996/03/03 17:28:15 thorpej Exp $	*/
d265 2
@


1.1
log
@Initial revision
@
text
@d1 3
a45 1
 *	$Id: hash.c,v 1.1 1995/04/28 06:55:07 cgd Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
