head	1.36;
access;
symbols
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.31.0.12
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.8
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.6
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.4
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.28.0.12
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.10
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.6
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.14
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.12
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.10
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.8
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.6
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.4
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.25.0.4
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.16.0.4
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.6
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.4
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.10.27.14.33.30;	author tb;	state Exp;
branches;
next	1.35;
commitid	T3AzYV9ZFKG22u3A;

1.35
date	2016.10.16.17.50.00;	author tb;	state Exp;
branches;
next	1.34;
commitid	9USjn6ChymyvzYCb;

1.34
date	2015.09.11.07.13.58;	author miod;	state Exp;
branches;
next	1.33;
commitid	WZlt70060zREibS9;

1.33
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Uu5nFG3wCl0LACBb;

1.32
date	2014.05.18.09.29.54;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2011.10.02.22.20.50;	author edd;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.16.11.34.43;	author chl;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.01.04.35.21;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.24.21.35.03;	author maja;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.02.21.59.33;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.01.16.20.04;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.04.18.30.05;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.06.21.46.53;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.26.17.01.25;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.28.04.55.07;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.29.09.45.39;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.10.20.46.07;	author maja;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.04.20.42.12;	author maja;	state Exp;
branches;
next	1.15;

1.15
date	99.10.02.07.38.20;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.04.18.17.15.08;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	98.05.11.09.59.40;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.08.07.10.36.58;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.08.07.10.22.26;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.07.06.04.07.11;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.02.03.13.59.43;	author maja;	state Exp;
branches;
next	1.8;

1.8
date	97.01.18.02.24.17;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.10.23.22.37.55;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.09.06.08.53.44;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.07.07.22.02.20;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.06.16.10.30.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.40.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.08;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.34;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Remove some code that was already disabled when it was committed
20 years ago.  While there, eliminate two dead assignments.

ok natano
@
text
@/*	$OpenBSD: mkioconf.c,v 1.35 2016/10/16 17:50:00 tb Exp $	*/
/*	$NetBSD: mkioconf.c,v 1.41 1996/11/11 14:18:49 mycroft Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)mkioconf.c	8.1 (Berkeley) 6/6/93
 */

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "config.h"

/*
 * Make ioconf.c.
 */
static int cforder(const void *, const void *);
static int emitcfdata(FILE *);
static int emitexterns(FILE *);
static int emithdr(FILE *);
static int emitloc(FILE *);
static int emitlocnames(FILE *);
static int emitpseudo(FILE *);
static int emitpv(FILE *);
static int emitroots(FILE *);

#define	SEP(pos, max)	(((u_int)(pos) % (max)) == 0 ? "\n\t" : " ")

/*
 * NEWLINE can only be used in the emitXXX functions.
 * In most cases it can be subsumed into an fprintf.
 */
#define	NEWLINE		if (putc('\n', fp) < 0) return (1)

int
mkioconf(void)
{
	FILE *fp;
	int v;

	qsort(packed, npacked, sizeof *packed, cforder);
	if ((fp = fopen("ioconf.c", "w")) == NULL) {
		warn("cannot write ioconf.c");
		return (1);
	}
	v = emithdr(fp);
	if (v != 0 || emitexterns(fp) || emitloc(fp) ||
	    emitlocnames(fp) || emitpv(fp) || emitcfdata(fp) ||
	    emitroots(fp) || emitpseudo(fp)) {
		if (v >= 0)
			warn("error writing ioconf.c");
		(void)fclose(fp);
		/* (void)unlink("ioconf.c"); */
		return (1);
	}
	(void)fclose(fp);
	return (0);
}

static int
cforder(const void *a, const void *b)
{
	int n1, n2;

	n1 = (*(struct devi **)a)->i_cfindex;
	n2 = (*(struct devi **)b)->i_cfindex;
	return (n1 - n2);
}

static int
emithdr(FILE *ofp)
{
	FILE *ifp;
	size_t n;
	char ifn[200], buf[BUFSIZ];

	if (fprintf(ofp, "\
/*\n\
 * MACHINE GENERATED: DO NOT EDIT\n\
 *\n\
 * ioconf.c, from \"%s\"\n\
 */\n\n", conffile) < 0)
		return (1);
	(void)snprintf(ifn, sizeof ifn, "ioconf.incl.%s", machine);
	if ((ifp = fopen(ifn, "r")) != NULL) {
		while ((n = fread(buf, 1, sizeof(buf), ifp)) > 0)
			if (fwrite(buf, 1, n, ofp) != n)
				return (1);
		if (ferror(ifp)) {
			warn("error reading %s", ifn);
			(void)fclose(ifp);
			return (-1);
		}
		(void)fclose(ifp);
	} else {
		if (fputs("\
#include <sys/param.h>\n\
#include <sys/device.h>\n", ofp) < 0)
			return (1);
	}
	return (0);
}

static int
emitexterns(FILE *fp)
{
	struct devbase *d;
	struct deva *da;

	NEWLINE;
	for (d = allbases; d != NULL; d = d->d_next) {
		if (!devbase_has_instances(d, WILD))
			continue;
		if (fprintf(fp, "extern struct cfdriver %s_cd;\n",
			    d->d_name) < 0)
			return (1);
	}
	NEWLINE;
	for (da = alldevas; da != NULL; da = da->d_next) {
		if (!deva_has_instances(da, WILD))
			continue;
		if (fprintf(fp, "extern struct cfattach %s_ca;\n",
			    da->d_name) < 0)
			return (1);
	}
	NEWLINE;
	return (0);
}

static int
emitloc(FILE *fp)
{
	int i;

	if (fprintf(fp, "\n/* locators */\n\
static long loc[%d] = {", locators.used) < 0)
		return (1);
	for (i = 0; i < locators.used; i++)
		if (fprintf(fp, "%s%s,", SEP(i, 8), locators.vec[i]) < 0)
			return (1);
	if (fprintf(fp, "\n};\n") < 0)
		return(1);
	return (fprintf(fp, "\n#ifndef MAXEXTRALOC\n\
#define MAXEXTRALOC 32\n\
#endif\n\
long extraloc[MAXEXTRALOC] = { -1 };\n\
int nextraloc = MAXEXTRALOC;\n\
int uextraloc = 0;\n") < 0);
}

static int nlocnames, maxlocnames = 8;
static char **locnames;

short
addlocname(const char *name)
{
	int i;

	if (locnames == NULL || nlocnames+1 > maxlocnames) {
		maxlocnames *= 4;
		locnames = ereallocarray(locnames, maxlocnames, sizeof(char *));
	}
	for (i = 0; i < nlocnames; i++)
		if (strcmp(name, locnames[i]) == 0)
			return (i);
	/*printf("adding %s at %d\n", name, nlocnames);*/
	locnames[nlocnames++] = (char *)name;
	return (nlocnames - 1);
}

static int nlocnami, maxlocnami = 8;
static short *locnami;

void
addlocnami(short index)
{
	if (locnami == NULL || nlocnami+1 > maxlocnami) {
		maxlocnami *= 4;
		locnami = ereallocarray(locnami, maxlocnami, sizeof(short));
	}
	locnami[nlocnami++] = index;
}


/*
 * Emit locator names
 * XXX the locnamp[] table is not compressed like it should be!
 */
static int
emitlocnames(FILE *fp)
{
	struct devi **p, *i;
	struct nvlist *nv;
	struct attr *a;
	int added, start;
	int v, j, x;

	addlocnami(-1);
	for (p = packed; (i = *p) != NULL; p++) {
		/*printf("child %s\n", i->i_name);*/

		/* initialize all uninitialized parents */
		for (x = 0; x < i->i_pvlen; x++) {
			if (i->i_parents[x]->i_plocnami)
				continue;
			start = nlocnami;

			/* add all the names */
			a = i->i_atattr;
			added = 0;
			for (nv = a->a_locs, v = 0; nv != NULL;
			    nv = nv->nv_next, v++) {
				addlocnami(addlocname(nv->nv_name));
				added = 1;
			}
			/* terminate list of names */
			if (added)
				addlocnami(-1);
			else
				start--;

			/*printf("bus %s starts at %d\n", i->i_parents[x]->i_name,
			    start);*/
			i->i_parents[x]->i_plocnami = start;

		}
	}
	for (p = packed; (i = *p) != NULL; p++)
		if (i->i_pvlen)
			i->i_locnami = i->i_parents[0]->i_plocnami;
	if (fprintf(fp, "\nchar *locnames[] = {\n") < 0)
		return (1);
	for (j = 0; j < nlocnames; j++)
		if (fprintf(fp, "\t\"%s\",\n", locnames[j]) < 0)
			return (1);
	if (fprintf(fp, "};\n\n") < 0)
		return (1);

	if (fprintf(fp,
	    "/* each entry is an index into locnames[]; -1 terminates */\n") < 0)
		return (1);
	if (fprintf(fp, "short locnamp[] = {") < 0)
		return (1);
	for (j = 0; j < nlocnami; j++)
		if (fprintf(fp, "%s%d,", SEP(j, 8), locnami[j]) < 0)
			return (1);
	return (fprintf(fp, "\n};\n") < 0);
}


/*
 * Emit global parents-vector.
 */
static int
emitpv(FILE *fp)
{
	int i;

	if (fprintf(fp, "\n/* size of parent vectors */\n\
int pv_size = %d;\n", parents.used) < 0)
		return (1);
	if (fprintf(fp, "\n/* parent vectors */\n\
short pv[%d] = {", parents.used) < 0)
		return (1);
	for (i = 0; i < parents.used; i++)
		if (fprintf(fp, "%s%d,", SEP(i, 16), parents.vec[i]) < 0)
			return (1);
	return (fprintf(fp, "\n};\n") < 0);
}

/*
 * Emit the cfdata array.
 */
static int
emitcfdata(FILE *fp)
{
	struct devi **p, *i;
	int unit, v;
	const char *state, *basename, *attachment;
	struct nvlist *nv;
	struct attr *a;
	char *loc;
	char locbuf[20];

	if (fprintf(fp, "\n\
#define NORM FSTATE_NOTFOUND\n\
#define STAR FSTATE_STAR\n\
#define DNRM FSTATE_DNOTFOUND\n\
#define DSTR FSTATE_DSTAR\n\
\n\
struct cfdata cfdata[] = {\n\
    /* attachment       driver        unit  state loc     flags parents nm starunit1 */\n") < 0)
		return (1);
	for (p = packed; (i = *p) != NULL; p++) {
		/* the description */
		if (fprintf(fp, "/*%3d: %s at ", i->i_cfindex, i->i_name) < 0)
			return (1);
		for (v = 0; v < i->i_pvlen; v++)
			if (fprintf(fp, "%s%s", v == 0 ? "" : "|",
			    i->i_parents[v]->i_name) < 0)
				return (1);
		if (v == 0 && fputs("root", fp) < 0)
			return (1);
		a = i->i_atattr;
		for (nv = a->a_locs, v = 0; nv != NULL; nv = nv->nv_next, v++)
			if (fprintf(fp, " %s %s",
			    nv->nv_name, i->i_locs[v]) < 0)
				return (1);
		if (fputs(" */\n", fp) < 0)
			return (-1);

		/* then the actual defining line */
		basename = i->i_base->d_name;
		attachment = i->i_atdeva->d_name;
		if (i->i_unit == STAR) {
			unit = i->i_base->d_umax;
			if (i->i_disable) {
				state = "DSTR";
			} else {
				state = "STAR";
			}
		} else {
			unit = i->i_unit;
			if (i->i_disable) {
				state = "DNRM";
			} else {
				state = "NORM";
			}
		}
		if (i->i_locoff >= 0) {
			(void)snprintf(locbuf, sizeof locbuf, "loc+%3d",
			    i->i_locoff);
			loc = locbuf;
		} else
			loc = "loc";
		if (fprintf(fp, "\
    {&%s_ca,%s&%s_cd,%s%2d, %s, %7s, %#4x, pv+%2d, %d, %4d},\n",
		    attachment, strlen(attachment) < 6 ? "\t\t" : "\t",
		    basename, strlen(basename) < 3 ? "\t\t" : "\t", unit,
		    state, loc, i->i_cfflags, i->i_pvoff, i->i_locnami,
		    unit) < 0)
			  return (1);
	}
	if (fprintf(fp, "    {0},\n    {0},\n    {0},\n    {0},\n") < 0)
		return (1);
	if (fprintf(fp, "    {0},\n    {0},\n    {0},\n    {0},\n") < 0)
		return (1);
	return (fputs("    {(struct cfattach *)-1}\n};\n", fp) < 0);
}

/*
 * Emit the table of potential roots.
 */
static int
emitroots(FILE *fp)
{
	struct devi **p, *i;
	int cnt = 0;

	if (fputs("\nshort cfroots[] = {\n", fp) < 0)
		return (1);
	for (p = packed; (i = *p) != NULL; p++) {
		if (i->i_at != NULL)
			continue;
		if (i->i_unit != 0 &&
		    (i->i_unit != STAR || i->i_base->d_umax != 0))
			warnx("warning: `%s at root' is not unit 0", i->i_name);
		if (fprintf(fp, "\t%2d /* %s */,\n",
		    i->i_cfindex, i->i_name) < 0)
			return (1);
		cnt++;
	}
	if (fputs("\t-1\n};\n", fp) < 0)
		return (1);

	return(fprintf(fp, "\nint cfroots_size = %d;\n", cnt+1) < 0);
}

/*
 * Emit pseudo-device initialization.
 */
static int
emitpseudo(FILE *fp)
{
	struct devi *i;
	struct devbase *d;
	int cnt = 0, umax;

	if (fputs("\n/* pseudo-devices */\n", fp) < 0)
		return (1);
	for (i = allpseudo; i != NULL; i = i->i_next)
		if (fprintf(fp, "extern void %sattach(int);\n",
		    i->i_base->d_name) < 0)
			return (1);
	if (fputs("\nchar *pdevnames[] = {\n", fp) < 0)
		return (1);
	for (i = allpseudo; i != NULL; i = i->i_next) {
		d = i->i_base;
		if (fprintf(fp, "\t\"%s\",\n", d->d_name) < 0)
			return (1);
		cnt++;
	}
	if (fputs("};\n", fp) < 0)
		return (1);
	if (fprintf(fp, "\nint pdevnames_size = %d;\n", cnt) < 0)
		return (1);
	if (fputs("\nstruct pdevinit pdevinit[] = {\n", fp) < 0)
		return (1);
	for (i = allpseudo; i != NULL; i = i->i_next) {
		d = i->i_base;
		umax = d->d_umax;
		if (i->i_disable)
		    umax*=-1;
		if (fprintf(fp, "\t{ %sattach, %d },\n",
		    d->d_name, umax) < 0)
			return (1);
	}
	return (fputs("\t{ NULL, 0 }\n};\n", fp) < 0);
}
@


1.35
log
@Use the err(3) family of functions more consistently.

ok jca, improvements and ok millert, natano
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.34 2015/09/11 07:13:58 miod Exp $	*/
a235 1
#if 1
a247 1
			nv = a->a_locs;
a268 17
#else
	addlocnami(-1);
	for (p = packed; (i = *p) != NULL; p++) {

		i->i_locnami = nlocnami;

		/* add all the names */
		a = i->i_atattr;
		nv = a->a_locs;
		for (nv = a->a_locs, v = 0; nv != NULL; nv = nv->nv_next, v++)
			addlocnami(addlocname(nv->nv_name));

		/* terminate list of names */
		addlocnami(-1);

	}
#endif
a342 1
		nv = a->a_locs;
@


1.34
log
@Change device locators type from int to long, for the sake of 64-bit ports
without proper device trees.

Be sure to build and install config(8) and rerun it before attempting to build
a kernel.

ok kettenis@@ deraadt@@ jasper@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.33 2015/01/16 06:40:16 deraadt Exp $	*/
d44 1
d81 1
a81 2
		(void)fprintf(stderr, "config: cannot write ioconf.c: %s\n",
		    strerror(errno));
d89 1
a89 3
			(void)fprintf(stderr,
			    "config: error writing ioconf.c: %s\n",
			    strerror(errno));
d128 1
a128 2
			(void)fprintf(stderr, "config: error reading %s: %s\n",
			    ifn, strerror(errno));
d425 1
a425 3
			(void)fprintf(stderr,
			    "config: warning: `%s at root' is not unit 0\n",
			    i->i_name);
@


1.33
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.32 2014/05/18 09:29:54 espie Exp $	*/
d177 1
a177 1
static int loc[%d] = {", locators.used) < 0)
d187 1
a187 1
int extraloc[MAXEXTRALOC] = { -1 };\n\
@


1.32
log
@use reallocarray and friends. okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.31 2011/10/02 22:20:50 edd Exp $	*/
a42 2

#include <sys/param.h>
@


1.31
log
@Fix some minor things in config(8):
 * As haesbaert suggests, correctly order include files.
 * Found some old style function defs. Updated.
 * Found a prototype inside a function. Moved.

OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.30 2011/07/16 11:34:43 chl Exp $	*/
d204 1
a204 1
		locnames = (char **)erealloc(locnames, maxlocnames * sizeof(char *));
d222 1
a222 1
		locnami = (short *)erealloc(locnami, maxlocnami * sizeof(short));
@


1.30
log
@remove unused variable

ok miod@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.29 2011/06/01 04:35:21 matthew Exp $	*/
d45 1
d50 1
@


1.29
log
@Kill the nearly-15-years-dead cf_ivstubs field from struct cfdata.

ok miod@@, deraadt@@

N.B.: If you're following -current, you MUST recompile config(8) and
re-config your kernel or else ioconf.c will fail to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.28 2008/03/24 21:35:03 maja Exp $	*/
d339 1
a339 1
	const char *vs, *state, *basename, *attachment;
@


1.28
log
@Make it possible to disable/enable pseudo devices in UKC, config file and
at config -e. -moj  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.27 2005/01/02 21:59:33 deraadt Exp $	*/
d352 1
a352 1
    /* attachment       driver        unit  state loc     flags parents nm ivstubs starunit1 */\n") < 0)
a390 2
		vs = "";
		v = 0;
d398 1
a398 1
    {&%s_ca,%s&%s_cd,%s%2d, %s, %7s, %#4x, pv+%2d, %d, %s%d, %4d},\n",
d402 1
a402 1
		    vs, v, unit) < 0)
@


1.27
log
@breaks at least vax; backout
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.25 2004/01/04 18:30:05 deraadt Exp $	*/
d452 1
a452 1
	int cnt = 0;
d476 3
d480 1
a480 1
		    d->d_name, d->d_umax) < 0)
@


1.26
log
@Make sure uextraloc ends up in .data so UKC works.  OK deraadt@@
@
text
@d189 1
a189 1
int uextraloc __attribute__((__section__(\"data\")));\n") < 0);
@


1.25
log
@knf and lint
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.24 2003/12/06 21:46:53 deraadt Exp $	*/
d189 1
a189 1
int uextraloc = 0;\n") < 0);
@


1.24
log
@NULL not 0 at end of pdevinit[]
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.23 2003/09/26 17:01:25 deraadt Exp $	*/
d337 1
a337 1
	struct devi **p, *i, **par;
a357 1
		par = i->i_parents;
@


1.23
log
@use erealloc
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.22 2003/06/28 04:55:07 deraadt Exp $	*/
d481 1
a481 1
	return (fputs("\t{ 0, 0 }\n};\n", fp) < 0);
@


1.22
log
@ansi & prototype cleanup.  tested in mkr on most arch's.  ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.21 2003/06/02 23:36:52 millert Exp $	*/
d202 1
a202 1
		locnames = (char **)realloc(locnames, maxlocnames * sizeof(char *));
d220 1
a220 1
		locnami = (short *)realloc(locnami, maxlocnami * sizeof(short));
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.20 2002/05/29 09:45:39 deraadt Exp $	*/
d73 1
a73 1
mkioconf()
d101 1
a101 2
cforder(a, b)
	const void *a, *b;
d111 1
a111 2
emithdr(ofp)
	FILE *ofp;
d146 1
a146 2
emitexterns(fp)
	FILE *fp;
d172 1
a172 2
emitloc(fp)
	FILE *fp;
d196 1
a196 2
addlocname(name)
	char *name;
d208 1
a208 1
	locnames[nlocnames++] = name;
d216 1
a216 2
addlocnami(index)
	short index;
d231 1
a231 2
emitlocnames(fp)
	FILE *fp;
d315 1
a315 2
emitpv(fp)
	FILE *fp;
d335 1
a335 2
emitcfdata(fp)
	FILE *fp;
d419 1
a419 2
emitroots(fp)
	FILE *fp;
d449 1
a449 2
emitpseudo(fp)
	FILE *fp;
@


1.20
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.19 2002/03/14 16:44:24 mpech Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.18 2002/02/16 21:28:01 millert Exp $	*/
d130 1
a130 1
	(void)sprintf(ifn, "ioconf.incl.%s", machine);
d408 2
a409 1
			(void)sprintf(locbuf, "loc+%3d", i->i_locoff);
@


1.18
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.17 2001/11/10 20:46:07 maja Exp $	*/
d79 1
a79 1
	register FILE *fp;
d108 1
a108 1
	register int n1, n2;
d117 1
a117 1
	register FILE *ofp;
d119 2
a120 2
	register FILE *ifp;
	register size_t n;
d153 1
a153 1
	register FILE *fp;
d155 2
a156 2
	register struct devbase *d;
	register struct deva *da;
d180 1
a180 1
	register FILE *fp;
d182 1
a182 1
	register int i;
d242 1
a242 1
	register FILE *fp;
d244 3
a246 3
	register struct devi **p, *i;
	register struct nvlist *nv;
	register struct attr *a;
d327 1
a327 1
	register FILE *fp;
d329 1
a329 1
	register int i;
d348 1
a348 1
	register FILE *fp;
d350 5
a354 5
	register struct devi **p, *i, **par;
	register int unit, v;
	register const char *vs, *state, *basename, *attachment;
	register struct nvlist *nv;
	register struct attr *a;
d432 1
a432 1
	register FILE *fp;
d434 1
a434 1
	register struct devi **p, *i;
d463 1
a463 1
	register FILE *fp;
d465 2
a466 2
	register struct devi *i;
	register struct devbase *d;
@


1.17
log
@Move extraloc to data segment. This fixes save of new locators for cloned devices. -moj ok @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.16 2001/02/04 20:42:12 maja Exp $	*/
d58 9
a66 9
static int cforder __P((const void *, const void *));
static int emitcfdata __P((FILE *));
static int emitexterns __P((FILE *));
static int emithdr __P((FILE *));
static int emitloc __P((FILE *));
static int emitlocnames __P((FILE *));
static int emitpseudo __P((FILE *));
static int emitpv __P((FILE *));
static int emitroots __P((FILE *));
d472 1
a472 1
		if (fprintf(fp, "extern void %sattach __P((int));\n",
@


1.16
log
@Add support for pseudo devices. This is done by adding more information
in ioconf.c. The only thing that can be done with pseudo devices is
changing the number of created units. -moj ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.15 1999/10/02 07:38:20 deraadt Exp $	*/
d195 1
a195 1
int extraloc[MAXEXTRALOC];\n\
@


1.15
log
@extraloc[] support; maja
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.14 1999/04/18 17:15:08 espie Exp $	*/
d467 1
d475 12
@


1.14
log
@Make -W -Wall happier.
Classical modern C type-checking, signed vs. unsigned.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.13 1998/05/11 09:59:40 niklas Exp $	*/
d190 8
a197 1
	return (fprintf(fp, "\n};\n") < 0);
@


1.13
log
@Formerly reuse of unit numbers of detached devices was impossible, with
this change starred devices will search from the first allowed unit for
such devices and up for free units when attaching.  This means you have
to rerun config(8) before yopu compile current kernels.  FYI, this is
a necessity when doing PCMCIA flashcard reading, otherwise you soon run
out of unit numbers.

I have also added a way to detach all children of a certain device, used
in a new PCMCIA framework to come, so you detach all functions on a
single PCMCIA card when pulling it out.

A few bugs wrt starred devices fixed in the autoconfig_verbose code too.
Last and least, fixed some panic messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.12 1997/08/07 10:36:58 deraadt Exp $	*/
d120 1
a120 1
	register int n;
@


1.12
log
@jason is tired.  this is not needed. our locator table stuff uses less
memory too.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.10 1997/07/06 04:07:11 downsj Exp $	*/
d358 1
a358 1
    /* attachment       driver        unit  state loc     flags parents nm ivstubs */\n") < 0)
d406 1
a406 1
    {&%s_ca,%s&%s_cd,%s%2d, %s, %7s, %#4x, pv+%2d, %d, %s%d},\n",
d410 1
a410 1
		    vs, v) < 0)
@


1.11
log
@cf_locnames support, from NetBSD (jtk, according to the RCSids).
@
text
@d2 1
a2 1
/*	$NetBSD: mkioconf.c,v 1.43 1997/03/14 22:54:08 jtk Exp $	*/
a57 1
static int cf_locnames_print __P((const char *, void *, void *));
a177 28
/*
 * Emit an initialized array of character strings describing this
 * attribute's locators.
 */
static int
cf_locnames_print(name, value, arg)
	const char *name;
	void *value;
	void *arg;
{
	struct attr *a;
	register struct nvlist *nv;
	FILE *fp = arg;

	a = value;
	if (a->a_locs) {
		if (fprintf(fp, "const char *%scf_locnames[] = { ", name) < 0)
			return (1);
		for (nv = a->a_locs; nv; nv = nv->nv_next) {
			if (fprintf(fp, "\"%s\", ", nv->nv_name) < 0)
				return (1);
		}
		if (fprintf(fp, "NULL};\n") < 0)
			return (1);
	}
	return 0;
}

d190 1
a190 4
	if (fprintf(fp,
		    "\n};\n\nconst char *nullcf_locnames[] = {NULL};\n") < 0)
		return (1);
	return ht_enumerate(attrtab, cf_locnames_print, fp);
d358 1
a358 2
    /* attachment       driver        unit  state loc     flags parents nm ivstubs\n\
       locnames */\n") < 0)
d406 1
a406 2
    {&%s_ca,%s&%s_cd,%s%2d, %s, %7s, %#4x, pv+%2d, %d, %s%d,\n\
     %scf_locnames},\n",
d410 1
a410 1
		    vs, v, a->a_locs ? a->a_name : "null") < 0)
@


1.10
log
@-Wall happiness
@
text
@d1 2
a2 2
/*	$OpenBSD: mkioconf.c,v 1.9 1997/02/03 13:59:43 maja Exp $	*/
/*	$NetBSD: mkioconf.c,v 1.41 1996/11/11 14:18:49 mycroft Exp $	*/
d58 1
d179 28
d219 4
a222 1
	return (fprintf(fp, "\n};\n") < 0);
d390 2
a391 1
    /* attachment       driver        unit  state loc     flags parents nm ivstubs */\n") < 0)
d439 2
a440 1
    {&%s_ca,%s&%s_cd,%s%2d, %s, %7s, %#4x, pv+%2d, %d, %s%d},\n",
d444 1
a444 1
		    vs, v) < 0)
@


1.9
log
@Added some code lost in last rev. Now BOOT_CONFIG might work again. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.8 1997/01/18 02:24:17 briggs Exp $	*/
a66 1
static char *vecname __P((char *, const char *, int));
@


1.8
log
@Sync. with current NetBSD--keeping local changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.7 1996/10/23 22:37:55 niklas Exp $	*/
d346 1
a346 1
	register const char *state, *basename, *attachment;
d359 1
a359 1
    /* attachment       driver        unit  state loc     flags parents */\n") < 0)
d399 2
d407 1
a407 1
    {&%s_ca,%s&%s_cd,%s%2d, %s, %7s, %#6x, pv+%2d},\n",
d410 3
a412 2
		    state, loc, i->i_cfflags, i->i_pvoff) < 0)
			return (1);
@


1.7
log
@Merge of NetBSD 961020.  Includes flexible build/source dir specs
@
text
@d1 2
a2 2
/*	$OpenBSD: mkioconf.c,v 1.6 1996/09/06 08:53:44 maja Exp $	*/
/*	$NetBSD: mkioconf.c,v 1.40 1996/08/31 21:15:10 mycroft Exp $	*/
d346 1
a346 1
	register const char *vs, *state, *basename, *attachment;
d359 1
a359 1
    /* attachment       driver        unit  state loc     flags parents nm ivstubs */\n") < 0)
a398 2
		vs = "";
		v = 0;
d405 1
a405 1
    {&%s_ca,%s&%s_cd,%s%2d, %s, %7s, %#4x, pv+%2d, %d, %s%d},\n",
d408 1
a408 2
		    state, loc, i->i_cfflags, i->i_pvoff, i->i_locnami,
		    vs, v) < 0)
@


1.6
log
@Added support for add device in subr_userconf. Not perfect but a good start.
This needed changes in config, so if your kernel uses BOOT_CONFIG you need
to rebuild config before a new kernel can be built. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: mkioconf.c,v 1.5 1996/07/07 22:02:20 maja Exp $	*/
/*	$NetBSD: mkioconf.c,v 1.38 1996/03/17 06:29:27 cgd Exp $	*/
a66 1
static int emitvec __P((FILE *));
a68 2
static const char *s_i386;

a80 1
	register char *fname;
a82 3
	s_i386 = intern("i386");

	fname = path("ioconf.c");
d84 3
a86 3
	if ((fp = fopen(fname, "w")) == NULL) {
		(void)fprintf(stderr, "config: cannot write %s: %s\n",
		    fname, strerror(errno));
d90 1
a90 1
	if (v != 0 || emitvec(fp) || emitexterns(fp) || emitloc(fp) ||
d95 2
a96 2
			    "config: error writing %s: %s\n",
			    fname, strerror(errno));
d98 1
a98 2
		/* (void)unlink(fname); */
		free(fname);
a101 1
	free(fname);
d399 2
a400 7
		if (i->i_ivoff < 0) {
			vs = "";
			v = 0;
		} else {
			vs = "vec+";
			v = i->i_ivoff;
		}
a476 65
}

/*
 * Emit interrupt vector declarations, and calculate offsets.
 */
static int
emitvec(fp)
	register FILE *fp;
{
	register struct nvlist *head, *nv;
	register struct devi **p, *i;
	register int j, nvec, unit;
	char buf[200];

	nvec = 0;
	for (p = packed; (i = *p) != NULL; p++) {
		if ((head = i->i_atdeva->d_vectors) == NULL)
			continue;
		if ((unit = i->i_unit) == STAR)
			panic("emitvec unit==STAR");
		if (nvec == 0)
			NEWLINE;
		for (j = 0, nv = head; nv != NULL; j++, nv = nv->nv_next)
			if (fprintf(fp,
			    "/* IVEC %s %d */ extern void %s();\n",
			    nv->nv_name, unit,
			    vecname(buf, nv->nv_name, unit)) < 0)
				return (1);
		nvec += j + 1;
	}
	if (nvec == 0)
		return (0);
	if (fprintf(fp, "\nstatic void (*vec[%d]) __P((void)) = {", nvec) < 0)
		return (1);
	nvec = 0;
	for (p = packed; (i = *p) != NULL; p++) {
		if ((head = i->i_atdeva->d_vectors) == NULL)
			continue;
		i->i_ivoff = nvec;
		unit = i->i_unit;
		for (nv = head; nv != NULL; nv = nv->nv_next)
			if (fprintf(fp, "%s%s,",
			    SEP(nvec++, 4),
			    vecname(buf, nv->nv_name, unit)) < 0)
				return (1);
		if (fprintf(fp, "%s0,", SEP(nvec++, 4)) < 0)
			return (1);
	}
	return (fputs("\n};\n", fp) < 0);
}

static char *
vecname(buf, name, unit)
	char *buf;
	const char *name;
	int unit;
{

	/* @@#%* 386 uses a different name format */
	if (machine == s_i386) {
		(void)sprintf(buf, "V%s%d", name, unit);
		return (buf);
	}
	(void)sprintf(buf, "X%s%d", name, unit);
	return (buf);
@


1.5
log
@Add support for allowing disabled devices in a config file. e.g.
ep0 at isa? disable port ? irq ?
disable must be placed before any attribute for the device. /moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.4 1996/06/16 10:30:00 deraadt Exp $	*/
d334 3
d338 1
a338 1
static short pv[%d] = {", parents.used) < 0)
d428 5
a432 1
	return (fputs("    {0}\n};\n", fp) < 0);
d443 1
d458 1
d460 4
a463 1
	return (fputs("\t-1\n};\n", fp) < 0);
@


1.4
log
@provide locator names to kernel (update your config(8) binary!)
@
text
@d1 1
a1 1
/*	$OpenBSD: mkioconf.c,v 1.2 1996/03/25 15:55:08 niklas Exp $	*/
d361 2
d392 5
a396 1
			state = "STAR";
d399 5
a403 1
			state = "NORM";
@


1.3
log
@sync to netbsd 960418
@
text
@d63 1
d98 2
a99 1
	    emitpv(fp) || emitcfdata(fp) || emitroots(fp) || emitpseudo(fp)) {
d203 122
d363 1
a363 1
    /* attachment       driver        unit state loc   flags parents ivstubs */\n") < 0)
d408 1
a408 1
    {&%s_ca,%s&%s_cd,%s%2d, %s, %7s, %#6x, pv+%2d, %s%d},\n",
d411 2
a412 1
		    state, loc, i->i_cfflags, i->i_pvoff, vs, v) < 0)
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mkioconf.c,v 1.36 1996/03/03 17:28:23 thorpej Exp $	*/
d4 1
a4 1
/* 
d164 1
d168 1
a168 1
		if (d->d_ihead == NULL)
d170 1
a170 1
		if (fprintf(fp, "extern struct cfdriver %scd;\n",
d175 8
d228 1
a228 1
	register const char *vs, *state, *basename;
d239 1
a239 1
\t/* driver     unit state    loc     flags parents ivstubs */\n") < 0)
d263 1
d284 2
a285 1
\t{&%scd,%s%2d, %s, %7s, %#6x, pv+%2d, %s%d},\n",
d290 1
a290 1
	return (fputs("\t{0}\n};\n", fp) < 0);
d360 1
a360 1
		if ((head = i->i_base->d_vectors) == NULL)
d380 1
a380 1
		if ((head = i->i_base->d_vectors) == NULL)
@


1.1
log
@Initial revision
@
text
@d1 3
a45 1
 *	$Id: mkioconf.c,v 1.35 1995/04/28 06:55:13 cgd Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
