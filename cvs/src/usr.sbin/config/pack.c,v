head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.10
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.12
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.8
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.4
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.12
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.15.0.32
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.30
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.28
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.24
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.26
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.22
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.20
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.18
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.16
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.14
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.12
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.10
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.8
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.12
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.10
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.8
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	NIKLAS:1.7.0.2
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2014.05.18.09.29.54;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.10.02.22.20.50;	author edd;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.04.00.47.01;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.28.04.55.07;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.09.02.11.47;	author jsyn;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.19.01.11.25;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.12.12.00.24.41;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.12.11.22.36.14;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.12.11.13.00.13;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.23.22.37.58;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.10.23.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.40.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.11;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.34;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: pack.c,v 1.17 2014/05/18 09:29:54 espie Exp $	*/
/*	$NetBSD: pack.c,v 1.5 1996/08/31 21:15:11 mycroft Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)pack.c	8.1 (Berkeley) 6/6/93
 */

#include <stdlib.h>
#include <string.h>

#include "config.h"

/*
 * Packing.  We have three separate kinds of packing here.
 *
 * First, we pack device instances, to collapse things like
 *
 *	uba0 at sbi0 nexus ?
 *	uba0 at bi0 nexus ?
 *
 * into a single instance that is "at sbi0 or bi0".
 *
 * Second, we pack locators.  Given something like
 *
 *	hp0 at mba0 drive 0
 *	hp* at mba* drive ?
 *	ht0 at mba0 drive 0
 *	tu0 at ht0 slave 0
 *	ht* at mba* drive ?
 *	tu* at ht* slave ?
 *
 * (where the default drive and slave numbers are -1), we have three
 * locators whose value is 0 and three whose value is -1.  Rather than
 * emitting six integers, we emit just two.
 *
 * Finally, we pack parent vectors.  This is very much like packing
 * locators.  Unlike locators, however, parent vectors are always
 * terminated by -1 (rather like the way C strings always end with
 * a NUL).
 *
 * When packing locators, we would like to find sequences such as
 *	{1 2 3} {2 3 4} {3} {4 5}
 * and turn this into the flat sequence {1 2 3 4 5}, with each subsequence
 * given by the appropriate offset (here 0, 1, 2, and 3 respectively).
 * When we pack parent vectors, overlap of this sort is impossible.
 * Non-overlapping packing is much easier, and so we use that here
 * and miss out on the chance to squeeze the locator sequence optimally.
 * (So it goes.)
 */

typedef int (*vec_cmp_func)(const void *, int, int);

#define	TAILHSIZE	128
#define	PVHASH(i)	((i) & (TAILHSIZE - 1))
#define	LOCHASH(l)	(((long)(l) >> 2) & (TAILHSIZE - 1))
struct tails {
	struct	tails *t_next;
	int	t_ends_at;
};

static struct tails *tails[TAILHSIZE];
static int locspace;
static int pvecspace;
static int longest_pvec;

static void packdevi(void);
static void packlocs(void);
static void packpvec(void);

static void addparents(struct devi *src, struct devi *dst);
static int nparents(struct devi **, struct devbase *, int);
static int sameas(struct devi *, struct devi *);
static int findvec(const void *, int, int, vec_cmp_func, int);
static int samelocs(const void *, int, int);
static int addlocs(const char **, int);
static int loclencmp(const void *, const void *);
static int samepv(const void *, int, int);
static int addpv(short *, int);
static int pvlencmp(const void *, const void *);
static void resettails(void);

void
pack(void)
{
	struct devi *i;
	int n;

	/* Pack instances and make parent vectors. */
	packdevi();

	/*
	 * Now that we know what we have, find upper limits on space
	 * needed for the loc[] and pv[] tables, and find the longest
	 * single pvec.  The loc and pv table sizes are bounded by
	 * what we would get if no packing occurred.
	 */
	locspace = pvecspace = 0;
	for (i = alldevi; i != NULL; i = i->i_next) {
		if (i->i_collapsed)
			continue;
		locspace += i->i_atattr->a_loclen;
		n = i->i_pvlen + 1;
		if (n > longest_pvec)
			longest_pvec = n;
		pvecspace += n;
	}

	/* Allocate and pack loc[]. */
	locators.vec = ereallocarray(NULL, locspace, sizeof(*locators.vec));
	locators.used = 0;
	packlocs();

	/* Allocate and pack pv[]. */
	parents.vec = ereallocarray(NULL, pvecspace, sizeof(*parents.vec));
	parents.used = 0;
	packpvec();
}

/*
 * Pack instances together wherever possible.  When everything is
 * packed, go back and set up the parents for each.  We must do this
 * on a second pass because during the first one, we do not know which,
 * if any, of the parents will collapse during packing.
 */
void
packdevi(void)
{
	struct devi *i, *l, *p;
	struct deva *d;
	int j, m, n;

	packed = ereallocarray(NULL, ndevi + 1, sizeof *packed);
	n = 0;
	for (d = alldevas; d != NULL; d = d->d_next) {
		/*
		 * For each instance of each attachment, add or collapse
		 * all its aliases.
		 */
		for (i = d->d_ihead; i != NULL; i = i->i_asame) {
			m = n;
			for (l = i; l != NULL; l = l->i_alias) {
				/* Skip if we already handled this one.  */
				if (l->i_cfindex >= 0)
					continue;
				l->i_pvlen = 0;
				l->i_pvoff = -1;
				l->i_locoff = -1;
				/* try to find an equivalent for l */
				for (j = m; j < n; j++) {
					p = packed[j];
					if (sameas(l, p)) {
						l->i_collapsed = 1;
						l->i_cfindex = p->i_cfindex;
						goto nextalias;
					}
				}
				/* could not find a suitable alias */
				l->i_collapsed = 0;
				l->i_cfindex = n;
				l->i_parents = emalloc(sizeof(*l->i_parents));
				l->i_parents[0] = NULL;
				packed[n++] = l;
			nextalias:;
			}
		}
	}
	npacked = n;
	packed[n] = NULL;
	for (i = alldevi; i != NULL; i = i->i_next)
		addparents(i, packed[i->i_cfindex]);
}

/*
 * Return true if two aliases are "the same".  In this case, they need
 * to attach via the same attribute, have the same config flags, and
 * have the same locators.
 */
static int
sameas(struct devi *i1, struct devi *i2)
{
	const char **p1, **p2;

	if (i1->i_atattr != i2->i_atattr)
		return (0);
	if (i1->i_cfflags != i2->i_cfflags)
		return (0);
	for (p1 = i1->i_locs, p2 = i2->i_locs; *p1 == *p2; p2++)
		if (*p1++ == 0)
			return (1);
	return 0;
}

/*
 * Add the parents associated with "src" to the (presumably uncollapsed)
 * instance "dst".
 */
static void
addparents(struct devi *src, struct devi *dst)
{
	struct nvlist *nv;
	struct devi *i, **p, **q;
	int j, n, old, new, ndup;

	if (dst->i_collapsed)
		panic("addparents() i_collapsed");

	/* Collect up list of parents to add. */
	if (src->i_at == NULL)	/* none, because we are "at root" */
		return;
	if (src->i_atdev != NULL) {
		n = nparents(NULL, src->i_atdev, src->i_atunit);
		p = ereallocarray(NULL, n, sizeof *p);
		if (n == 0)
			return;
		(void)nparents(p, src->i_atdev, src->i_atunit);
	} else {
		n = 0;
		for (nv = src->i_atattr->a_refs; nv != NULL; nv = nv->nv_next)
			n += nparents(NULL, nv->nv_ptr, src->i_atunit);
		if (n == 0)
			return;
		p = ereallocarray(NULL, n, sizeof *p);
		n = 0;
		for (nv = src->i_atattr->a_refs; nv != NULL; nv = nv->nv_next)
			n += nparents(p + n, nv->nv_ptr, src->i_atunit);
	}
	/* Now elide duplicates. */
	ndup = 0;
	for (j = 0; j < n; j++) {
		i = p[j];
		for (q = dst->i_parents; *q != NULL; q++) {
			if (*q == i) {
				ndup++;
				p[j] = NULL;
				break;
			}
		}
	}
	/* Finally, add all the non-duplicates. */
	old = dst->i_pvlen;
	new = old + (n - ndup);
	if (old > new)
		panic("addparents() old > new");
	if (old == new) {
		free(p);
		return;
	}
	dst->i_parents = q = ereallocarray(dst->i_parents, new + 1, sizeof(*q));
	dst->i_pvlen = new;
	q[new] = NULL;
	q += old;
	for (j = 0; j < n; j++)
		if (p[j] != NULL)
			*q++ = p[j];
	free(p);
}

/*
 * Count up parents, and optionally store pointers to each.
 */
static int
nparents(struct devi **p, struct devbase *dev, int unit)
{
	struct devi *i, *l;
	int n;

	n = 0;
	/* for each instance ... */
	for (i = dev->d_ihead; i != NULL; i = i->i_bsame) {
		/* ... take each un-collapsed alias */
		for (l = i; l != NULL; l = l->i_alias) {
			if (!l->i_collapsed &&
			    (unit == WILD || unit == l->i_unit)) {
				if (p != NULL)
					*p++ = l;
				n++;
			}
		}
	}
	return (n);
}

static void
packlocs(void)
{
	struct devi **p, *i;
	int l, o;

	qsort(packed, npacked, sizeof *packed, loclencmp);
	for (p = packed; (i = *p) != NULL; p++) {
		if ((l = i->i_atattr->a_loclen) > 0) {
			o = findvec(i->i_locs, LOCHASH(i->i_locs[l - 1]), l,
				    samelocs, locators.used);
			i->i_locoff = o < 0 ? addlocs(i->i_locs, l) : o;
		} else
			i->i_locoff = -1;
	}
	resettails();
}

static void
packpvec(void)
{
	struct devi **p, *i, **par;
	int l, v, o;
	short *vec;

	vec = ereallocarray(NULL, longest_pvec, sizeof(*vec));
	qsort(packed, npacked, sizeof *packed, pvlencmp);
	for (p = packed; (i = *p) != NULL; p++) {
		l = i->i_pvlen;
		if (l > longest_pvec)
			panic("packpvec");
		par = i->i_parents;
		for (v = 0; v < l; v++)
			vec[v] = par[v]->i_cfindex;
		if (l == 0 || (o = findvec(vec, PVHASH(vec[l - 1]), l,
		    samepv, parents.used)) < 0)
			o = addpv(vec, l);
		i->i_pvoff = o;
	}
	free(vec);
	resettails();
}

/*
 * Return the index at which the given vector already exists, or -1
 * if it is not anywhere in the current set.  If we return -1, we assume
 * our caller will add it at the end of the current set, and we make
 * sure that next time, we will find it there.
 */
static int
findvec(const void *ptr, int hash, int len, vec_cmp_func cmp, int nextplace)
{
	struct tails *t, **hp;
	int off;

	hp = &tails[hash];
	for (t = *hp; t != NULL; t = t->t_next) {
		off = t->t_ends_at - len;
		if (off >= 0 && (*cmp)(ptr, off, len))
			return (off);
	}
	t = emalloc(sizeof(*t));
	t->t_next = *hp;
	*hp = t;
	t->t_ends_at = nextplace + len;
	return (-1);
}

/*
 * Comparison function for locators.
 */
static int
samelocs(const void *ptr, int off, int len)
{
	const char **p, **q;

	for (p = &locators.vec[off], q = (const char **)ptr; --len >= 0;)
		if (*p++ != *q++)
			return (0);	/* different */
	return (1);			/* same */
}

/*
 * Add the given locators at the end of the global loc[] table.
 */
static int
addlocs(const char **locs, int len)
{
	const char **p;
	int ret;

	ret = locators.used;
	if ((locators.used = ret + len) > locspace)
		panic("addlocs: overrun");
	for (p = &locators.vec[ret]; --len >= 0;)
		*p++ = *locs++;
	return (ret);
}

/*
 * Comparison function for qsort-by-locator-length, longest first.
 * We rashly assume that subtraction of these lengths does not overflow.
 */
static int
loclencmp(const void *a, const void *b)
{
	int l1, l2;

	l1 = (*(struct devi **)a)->i_atattr->a_loclen;
	l2 = (*(struct devi **)b)->i_atattr->a_loclen;
	return (l2 - l1);
}

/*
 * Comparison function for parent vectors.
 */
static int
samepv(const void *ptr, int off, int len)
{
	short *p, *q;

	for (p = &parents.vec[off], q = (short *)ptr; --len >= 0;)
		if (*p++ != *q++)
			return (0);	/* different */
	return (1);			/* same */
}

/*
 * Add the given parent vectors at the end of the global pv[] table.
 */
static int
addpv(short *pv, int len)
{
	short *p;
	int ret;
	static int firstend = -1;

	/*
	 * If the vector is empty, reuse the first -1.  It will be
	 * there if there are any nonempty vectors at all, since we
	 * do the longest first.  If there are no nonempty vectors,
	 * something is probably wrong, but we will ignore that here.
	 */
	if (len == 0 && firstend >= 0)
		return (firstend);
	len++;			/* account for trailing -1 */
	ret = parents.used;
	if ((parents.used = ret + len) > pvecspace)
		panic("addpv: overrun");
	for (p = &parents.vec[ret]; --len > 0;)
		*p++ = *pv++;
	*p = -1;
	if (firstend < 0)
		firstend = parents.used - 1;
	return (ret);
}

/*
 * Comparison function for qsort-by-parent-vector-length, longest first.
 * We rashly assume that subtraction of these lengths does not overflow.
 */
static int
pvlencmp(const void *a, const void *b)
{
	int l1, l2;

	l1 = (*(struct devi **)a)->i_pvlen;
	l2 = (*(struct devi **)b)->i_pvlen;
	return (l2 - l1);
}

static void
resettails(void)
{
	struct tails **p, *t, *next;
	int i;

	for (p = tails, i = TAILHSIZE; --i >= 0; p++) {
		for (t = *p; t != NULL; t = next) {
			next = t->t_next;
			free(t);
		}
		*p = NULL;
	}
}
@


1.17
log
@use reallocarray and friends. okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.16 2011/10/02 22:20:50 edd Exp $	*/
a42 2

#include <sys/param.h>
@


1.16
log
@Fix some minor things in config(8):
 * As haesbaert suggests, correctly order include files.
 * Found some old style function defs. Updated.
 * Found a prototype inside a function. Moved.

OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.15 2004/01/04 00:47:01 deraadt Exp $	*/
d147 1
a147 1
	locators.vec = emalloc(locspace * sizeof(*locators.vec));
d152 1
a152 1
	parents.vec = emalloc(pvecspace * sizeof(*parents.vec));
d170 1
a170 1
	packed = emalloc((ndevi + 1) * sizeof *packed);
d250 1
a250 1
		p = emalloc(n * sizeof *p);
d260 1
a260 1
		p = emalloc(n * sizeof *p);
d286 1
a286 1
	dst->i_parents = q = erealloc(dst->i_parents, (new + 1) * sizeof(*q));
d346 1
a346 1
	vec = emalloc(longest_pvec * sizeof(*vec));
@


1.15
log
@Wall and spacing, I am hunting bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.14 2003/06/28 04:55:07 deraadt Exp $	*/
d45 1
d48 1
@


1.14
log
@ansi & prototype cleanup.  tested in mkr on most arch's.  ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.13 2003/06/02 23:36:52 millert Exp $	*/
d348 2
a349 1
if (l > longest_pvec) panic("packpvec");
d353 3
a355 4
		if (l == 0 ||
		    (o = findvec(vec, PVHASH(vec[l - 1]), l,
			    samepv, parents.used)) < 0)
		    	o = addpv(vec, l);
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.12 2002/06/09 02:11:47 jsyn Exp $	*/
d119 1
a119 1
pack()
d162 1
a162 1
packdevi()
d215 1
a215 2
sameas(i1, i2)
	struct devi *i1, *i2;
d234 1
a234 2
addparents(src, dst)
	struct devi *src, *dst;
d298 1
a298 4
nparents(p, dev, unit)
	struct devi **p;
	struct devbase *dev;
	int unit;
d320 1
a320 1
packlocs()
d338 1
a338 1
packpvec()
d369 1
a369 5
findvec(ptr, hash, len, cmp, nextplace)
	const void *ptr;
	int hash, len;
	vec_cmp_func cmp;
	int nextplace;
d391 1
a391 4
samelocs(ptr, off, len)
	const void *ptr;
	int off;
	int len;
d405 1
a405 3
addlocs(locs, len)
	const char **locs;
	int len;
d423 1
a423 2
loclencmp(a, b)
	const void *a, *b;
d436 1
a436 4
samepv(ptr, off, len)
	const void *ptr;
	int off;
	int len;
d450 1
a450 3
addpv(pv, len)
	short *pv;
	int len;
d481 1
a481 2
pvlencmp(a, b)
	const void *a, *b;
d491 1
a491 1
resettails()
@


1.12
log
@fix the use of "cuz" in the tree; these are all in comments

noticed by aaron@@, recommended by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.11 2002/03/14 16:44:24 mpech Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.10 2002/02/16 21:28:01 millert Exp $	*/
d250 1
a250 1
	if (src->i_at == NULL)	/* none, 'cuz "at root" */
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.9 1999/01/19 01:11:25 niklas Exp $	*/
d125 2
a126 2
	register struct devi *i;
	register int n;
d168 3
a170 3
	register struct devi *i, *l, *p;
	register struct deva *d;
	register int j, m, n;
d220 1
a220 1
	register struct devi *i1, *i2;
d222 1
a222 1
	register const char **p1, **p2;
d240 1
a240 1
	register struct devi *src, *dst;
d242 3
a244 3
	register struct nvlist *nv;
	register struct devi *i, **p, **q;
	register int j, n, old, new, ndup;
d305 3
a307 3
	register struct devi **p;
	register struct devbase *dev;
	register int unit;
d309 2
a310 2
	register struct devi *i, *l;
	register int n;
d331 2
a332 2
	register struct devi **p, *i;
	register int l, o;
d349 3
a351 3
	register struct devi **p, *i, **par;
	register int l, v, o;
	register short *vec;
d384 2
a385 2
	register struct tails *t, **hp;
	register int off;
d407 1
a407 1
	register int len;
d409 1
a409 1
	register const char **p, **q;
d422 2
a423 2
	register const char **locs;
	register int len;
d425 2
a426 2
	register const char **p;
	register int ret;
d444 1
a444 1
	register int l1, l2;
d458 1
a458 1
	register int len;
d460 1
a460 1
	register short *p, *q;
d473 2
a474 2
	register short *pv;
	register int len;
d476 2
a477 2
	register short *p;
	register int ret;
d508 1
a508 1
	register int l1, l2;
d518 2
a519 2
	register struct tails **p, *t, *next;
	register int i;
@


1.9
log
@Retry sane probe ordering, i.e. ordered like the attachments
found in the various config files.
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.7 1996/12/11 22:36:14 niklas Exp $	*/
d91 1
a91 1
typedef int (*vec_cmp_func) __P((const void *, int, int));
d106 15
a120 15
static void packdevi __P((void));
static void packlocs __P((void));
static void packpvec __P((void));

static void addparents __P((struct devi *src, struct devi *dst));
static int nparents __P((struct devi **, struct devbase *, int));
static int sameas __P((struct devi *, struct devi *));
static int findvec __P((const void *, int, int, vec_cmp_func, int));
static int samelocs __P((const void *, int, int));
static int addlocs __P((const char **, int));
static int loclencmp __P((const void *, const void *));
static int samepv __P((const void *, int, int));
static int addpv __P((short *, int));
static int pvlencmp __P((const void *, const void *));
static void resettails __P((void));
@


1.8
log
@Revert sane attach ordering for the time being
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.5 1996/10/23 22:37:58 niklas Exp $	*/
d169 1
a169 1
	register struct devbase *d;
d174 1
a174 1
	for (d = allbases; d != NULL; d = d->d_next) {
d176 1
a176 1
		 * For each instance of each device, add or collapse
d179 1
a179 1
		for (i = d->d_ihead; i != NULL; i = i->i_bsame) {
d182 3
@


1.7
log
@Remove dups from cfdata via marking algorithm
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.6 1996/12/11 13:00:13 niklas Exp $	*/
d169 1
a169 1
	register struct deva *d;
d174 1
a174 1
	for (d = alldevas; d != NULL; d = d->d_next) {
d176 1
a176 1
		 * For each instance of each attachment, add or collapse
d179 1
a179 1
		for (i = d->d_ihead; i != NULL; i = i->i_asame) {
a181 3
				/* Skip if we already handled this one.  */
				if (l->i_cfindex >= 0)
					continue;
@


1.6
log
@Sane attach ordering
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.5 1996/10/23 22:37:58 niklas Exp $	*/
d179 1
a179 1
		for (i = d->d_ihead; i != NULL; i = i->i_bsame) {
d182 3
@


1.5
log
@Merge of NetBSD 961020.  Includes flexible build/source dir specs
@
text
@d1 1
a1 1
/*	$OpenBSD: pack.c,v 1.4 1996/06/23 10:23:04 deraadt Exp $	*/
d169 1
a169 1
	register struct devbase *d;
d174 1
a174 1
	for (d = allbases; d != NULL; d = d->d_next) {
d176 1
a176 1
		 * For each instance of each device, add or collapse
@


1.4
log
@from netbsd; two devices instances which are otherwise the same but do
not attach via the same attributes are _not_ the same, and should not
be treated as aliases of each other.
@
text
@d1 2
a2 2
/*	$OpenBSD: pack.c,v 1.3 1996/04/21 23:40:21 deraadt Exp $	*/
/*	$NetBSD: pack.c,v 1.3.4.1 1996/06/17 18:22:44 cgd Exp $	*/
a184 1
				l->i_ivoff = -1;
@


1.3
log
@sync to netbsd 960418
@
text
@d1 2
a2 2
/*	$OpenBSD: pack.c,v 1.2 1996/03/25 15:55:11 niklas Exp $	*/
/*	$NetBSD: pack.c,v 1.3 1996/03/17 06:29:33 cgd Exp $	*/
d213 2
a214 1
 * to have the same config flags and the same locators.
d222 2
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pack.c,v 1.2 1996/03/03 17:28:32 thorpej Exp $	*/
d4 1
a4 1
/* 
@


1.1
log
@Initial revision
@
text
@d1 3
a45 1
 *	$Id: pack.c,v 1.1 1995/04/28 06:55:20 cgd Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
