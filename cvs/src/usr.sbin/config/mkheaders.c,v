head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.6
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.8
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.4
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.8
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.6
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.4
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.18.0.34
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.32
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.30
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.26
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.28
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.24
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.22
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.20
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.18
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.16
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.14
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.12
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.10
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.8
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.10.0.14
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.12
	OPENBSD_2_8:1.10.0.10
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.8
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.10.16.17.50.00;	author tb;	state Exp;
branches;
next	1.21;
commitid	9USjn6ChymyvzYCb;

1.21
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2013.11.23.17.38.15;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2011.10.02.22.20.49;	author edd;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.28.04.55.07;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.17.15.08.49;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.11.16.58.31;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.14.02.59.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.29.09.45.39;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.05.14.21.16.44;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.05.11.01.19.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.07.10.36.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.07.10.22.26;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.07.06.04.07.10;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.07.06.03.54.05;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.23.22.37.54;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.40.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.07;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Use the err(3) family of functions more consistently.

ok jca, improvements and ok millert, natano
@
text
@/*	$OpenBSD: mkheaders.c,v 1.21 2015/01/16 06:40:16 deraadt Exp $	*/
/*	$NetBSD: mkheaders.c,v 1.12 1997/02/02 21:12:34 thorpej Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)mkheaders.c	8.1 (Berkeley) 6/6/93
 */

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "config.h"

static int emitcnt(struct nvlist *);
static int emitopt(struct nvlist *);
static int emitwarn(const char *, char *, FILE *);
static char *cntname(const char *);

/*
 * Make headers containing counts, as needed.
 */
int
mkheaders(void)
{
	struct files *fi;
	struct nvlist *nv;

	for (fi = allfiles; fi != NULL; fi = fi->fi_next) {
		if (fi->fi_flags & FI_HIDDEN)
			continue;
		if (fi->fi_flags & (FI_NEEDSCOUNT | FI_NEEDSFLAG) &&
		    emitcnt(fi->fi_optf))
			return (1);
	}

	for (nv = defoptions; nv != NULL; nv = nv->nv_next)
		if (emitopt(nv))
			return (1);

	return (0);
}

static int
emitcnt(struct nvlist *head)
{
	struct nvlist *nv;
	FILE *fp;
	int cnt;
	char nam[100];
	char buf[BUFSIZ];
	char fname[BUFSIZ];

	(void)snprintf(fname, sizeof fname, "%s.h", head->nv_name);
	if ((fp = fopen(fname, "r")) == NULL)
		goto writeit;
	nv = head;
	while (fgets(buf, sizeof(buf), fp) != NULL) {
		if (nv == NULL)
			goto writeit;
		if (sscanf(buf, "#define %99s %d", nam, &cnt) != 2 ||
		    strcmp(nam, cntname(nv->nv_name)) != 0 ||
		    cnt != nv->nv_int)
			goto writeit;
		nv = nv->nv_next;
	}
	if (ferror(fp))
		return (emitwarn("read", fname, fp));
	(void)fclose(fp);
	if (nv == NULL)
		return (0);
writeit:
	if ((fp = fopen(fname, "w")) == NULL)
		return (emitwarn("writ", fname, NULL));
	for (nv = head; nv != NULL; nv = nv->nv_next)
		if (fprintf(fp, "#define\t%s\t%d\n",
		    cntname(nv->nv_name), nv->nv_int) < 0)
			return (emitwarn("writ", fname, fp));
	if (fclose(fp))
		return (emitwarn("writ", fname, NULL));
	return (0);
}

static int
emitopt(struct nvlist *nv)
{
	struct nvlist *option;
	char new_contents[BUFSIZ], buf[BUFSIZ];
	char fname[BUFSIZ];
	int totlen, nlines;
	FILE *fp;

	/*
	 * Generate the new contents of the file.
	 */
	if ((option = ht_lookup(opttab, nv->nv_str)) == NULL)
		totlen = snprintf(new_contents, sizeof new_contents,
		    "/* option `%s' not defined */\n",
		    nv->nv_str);
	else {
		if (option->nv_str != NULL)
			totlen = snprintf(new_contents, sizeof new_contents,
			    "#define\t%s\t%s\n",
			    option->nv_name, option->nv_str);
		else
			totlen = snprintf(new_contents, sizeof new_contents,
			    "#define\t%s\n",
			    option->nv_name);
	}

	if (totlen < 0 || totlen >= sizeof new_contents) {
		warnx("string too long");
		return (1);
	}

	/*
	 * Compare the new file to the old.
	 */
	snprintf(fname, sizeof fname, "opt_%s.h", nv->nv_name);
	if ((fp = fopen(fname, "r")) == NULL)
		goto writeit;
	nlines = 0;
	while (fgets(buf, sizeof(buf), fp) != NULL) {
		if (++nlines != 1 ||
		    strcmp(buf, new_contents) != 0)
			goto writeit;
	}
	if (ferror(fp))
		return (emitwarn("read", fname, fp));
	(void)fclose(fp);
	if (nlines == 1)
		return (0);
writeit:
	/*
	 * They're different, or the file doesn't exist.
	 */
	if ((fp = fopen(fname, "w")) == NULL)
		return (emitwarn("writ", fname, NULL));
	if (fprintf(fp, "%s", new_contents) < 0)
		return (emitwarn("writ", fname, fp));
	if (fclose(fp))
		return (emitwarn("writ", fname, fp));
	return (0);
}

static int
emitwarn(const char *what, char *fname, FILE *fp)
{

	warn("error %sing %s", what, fname);
	if (fp)
		(void)fclose(fp);
	return (1);
}

static char *
cntname(const char *src)
{
	char *dst, c;
	static char buf[100];

	dst = buf;
	*dst++ = 'N';
	while ((c = *src++) != 0)
		*dst++ = islower((unsigned char)c) ?
		    toupper((unsigned char)c) : c;
	*dst = 0;
	return (buf);
}
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.20 2013/11/23 17:38:15 deraadt Exp $	*/
d45 1
d55 1
a55 1
static int err(const char *, char *, FILE *);
d106 1
a106 1
		return (err("read", fname, fp));
d111 2
a112 5
	if ((fp = fopen(fname, "w")) == NULL) {
		(void)fprintf(stderr, "config: cannot write %s: %s\n",
		    fname, strerror(errno));
		return (1);
	}
d116 1
a116 1
			return (err("writ", fname, fp));
d118 1
a118 1
		return (err("writ", fname, NULL));
d150 1
a150 1
		fprintf(stderr, "config: string too long\n");
d167 1
a167 1
		return (err("read", fname, fp));
d175 2
a176 5
	if ((fp = fopen(fname, "w")) == NULL) {
		(void)fprintf(stderr, "config: cannot write %s: %s\n",
		    fname, strerror(errno));
		return (1);
	}
d178 1
a178 1
		return (err("writ", fname, fp));
d180 1
a180 1
		return (err("writ", fname, fp));
d185 1
a185 1
err(const char *what, char *fname, FILE *fp)
d188 1
a188 2
	(void)fprintf(stderr, "config: error %sing %s: %s\n",
	    what, fname, strerror(errno));
@


1.20
log
@unsigned char casts for ctype
ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.19 2011/10/02 22:20:49 edd Exp $	*/
a42 2

#include <sys/param.h>
@


1.19
log
@Fix some minor things in config(8):
 * As haesbaert suggests, correctly order include files.
 * Found some old style function defs. Updated.
 * Found a prototype inside a function. Moved.

OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.18 2003/06/28 04:55:07 deraadt Exp $	*/
d211 2
a212 1
		*dst++ = islower(c) ? toupper(c) : c;
@


1.18
log
@ansi & prototype cleanup.  tested in mkr on most arch's.  ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.17 2003/06/02 23:36:52 millert Exp $	*/
d45 1
d51 1
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.16 2003/04/17 15:08:49 drahn Exp $	*/
d61 1
a61 1
mkheaders()
d82 1
a82 2
emitcnt(head)
	struct nvlist *head;
d125 1
a125 2
emitopt(nv)
	struct nvlist *nv;
d190 1
a190 4
err(what, fname, fp)
	const char *what;
	char *fname;
	FILE *fp;
d201 1
a201 2
cntname(src)
	const char *src;
@


1.16
log
@Assign the return value of snprintf to an int, not a char. fixes a comparison
is always true error on ppc. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.15 2002/12/11 16:58:31 deraadt Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.15
log
@handle snprintf < 0
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.14 2002/07/14 02:59:41 deraadt Exp $	*/
d135 2
a136 2
	char fname[BUFSIZ], totlen;
	int nlines;
@


1.14
log
@kill sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.13 2002/05/29 09:45:39 deraadt Exp $	*/
d157 1
a157 1
	if (totlen >= sizeof new_contents) {
@


1.13
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.12 2002/03/14 16:44:24 mpech Exp $	*/
d135 1
a135 1
	char fname[BUFSIZ], *p;
a141 1
	p = new_contents;
d143 2
a144 1
		p += sprintf(p, "/* option `%s' not defined */\n",
a146 1
		p += sprintf(p, "#define\t%s", option->nv_name);
d148 12
a159 2
			p += sprintf(p, "\t%s", option->nv_str);
		p += sprintf(p, "\n");
@


1.12
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.11 2002/02/16 21:28:01 millert Exp $	*/
d96 1
a96 1
	(void)sprintf(fname, "%s.h", head->nv_name);
d156 1
a156 1
	sprintf(fname, "opt_%s.h", nv->nv_name);
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.10 1998/05/14 21:16:44 deraadt Exp $	*/
d67 2
a68 2
	register struct files *fi;
	register struct nvlist *nv;
d87 1
a87 1
	register struct nvlist *head;
d89 2
a90 2
	register struct nvlist *nv;
	register FILE *fp;
d202 1
a202 1
	register const char *src;
d204 1
a204 1
	register char *dst, c;
@


1.10
log
@more careful scanf
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.9 1998/05/11 01:19:17 deraadt Exp $	*/
d56 4
a59 4
static int emitcnt __P((struct nvlist *));
static int emitopt __P((struct nvlist *));
static int err __P((const char *, char *, FILE *));
static char *cntname __P((const char *));
@


1.9
log
@set max field width of %s correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.8 1997/08/07 10:36:58 deraadt Exp $	*/
d103 1
a103 1
		if (sscanf(buf, "#define %100s %d", nam, &cnt) != 2 ||
@


1.8
log
@jason is tired.  this is not needed. our locator table stuff uses less
memory too.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.6 1997/07/06 04:07:10 downsj Exp $	*/
d103 1
a103 1
		if (sscanf(buf, "#define %s %d", nam, &cnt) != 2 ||
@


1.7
log
@cf_locnames support, from NetBSD (jtk, according to the RCSids).
@
text
@d2 1
a2 1
/*	$NetBSD: mkheaders.c,v 1.15 1997/07/18 11:27:37 jtk Exp $	*/
a56 1
static int emitlocs __P((void));
a58 1
static int locators_print __P((const char *, void *, void *));
a60 1

a81 3
	if (emitlocs())
		return (1);

a182 122
	return (0);
}

/*
 * A callback function for walking the attribute hash table.
 * Emit CPP definitions of manifest constants for the locators on the
 * "name" attribute node (passed as the "value" parameter).
 */
static int
locators_print(name, value, arg)
	const char *name;
	void *value;
	void *arg;
{
	struct attr *a;
	register struct nvlist *nv;
	register int i;
	char *locdup, *namedup;
	register char *cp;
	FILE *fp = arg;

	a = value;
	if (a->a_locs) {
		if (strchr(name, ' ') != NULL || strchr(name, '\t') != NULL)
			/*
			 * name contains a space; we can't generate
			 * usable defines, so ignore it.
			 */
			return 0;
		locdup = strdup(name);
		for (cp = locdup; *cp; cp++)
			if (islower(*cp))
				*cp = toupper(*cp);
		if (fprintf(fp, "extern const char *%scf_locnames[];\n",
			    name) < 0)
			return 1;
		for (i = 0, nv = a->a_locs; nv; nv = nv->nv_next, i++) {
			if (strchr(nv->nv_name, ' ') != NULL ||
			    strchr(nv->nv_name, '\t') != NULL)
				/*
				 * name contains a space; we can't generate
				 * usable defines, so ignore it.
				 */
				continue;
			namedup = strdup(nv->nv_name);
			for (cp = namedup; *cp; cp++)
				if (islower(*cp))
					*cp = toupper(*cp);
			if (fprintf(fp, "#define %sCF_%s %d\n",
				    locdup, namedup, i) < 0)
				return 1;
			if (nv->nv_str &&
			    fprintf(fp,
				    "#define %sCF_%s_DEFAULT %s\n",
				    locdup, namedup, nv->nv_str) < 0)
				return 1;
			free(namedup);
		}
		free(locdup);
	}
	return 0;
}

/*
 * Build the "locators.h" file with manifest constants for all potential
 * locators in the configuration.  Do this by enumerating the attribute
 * hash table and emitting all the locators for each attribute.
 */
static int
emitlocs()
{
	struct nvlist *option;
	char nbuf[BUFSIZ], obuf[BUFSIZ];
	char *tfname, *nfname;
	const char *n;
	int count, rval;
	FILE *tfp = NULL, *nfp = NULL;
	
	tfname = "tmp_locators.h";
	if ((tfp = fopen(tfname, "w")) == NULL) {
		(void)fprintf(stderr, "config: cannot write %s: %s\n",
		    tfname, strerror(errno));
		return (1);
	}

	rval = ht_enumerate(attrtab, locators_print, tfp);
	if (fclose(tfp) == EOF)
		return(err("clos", tfname, NULL));

	if ((tfp = fopen(tfname, "r")) == NULL)
		goto moveit;

	/*
	 * Compare the new file to the old.
	 */
	nfname = "locators.h";
	if ((nfp = fopen(nfname, "r")) == NULL)
		goto moveit;

	while (fgets(obuf, sizeof(obuf), tfp) != NULL) {
		if (fgets(nbuf, sizeof(nbuf), nfp) == NULL)
			goto moveit;

		if (strcmp(obuf, nbuf) != 0)
			goto moveit;
	}
	(void) fclose(nfp);
	(void) fclose(tfp);
	if (remove(tfname) == -1)
		return(err("remov", tfname, NULL));
	return (0);

moveit:
	/*
	 * They're different, or the file doesn't exist.
	 */
	if (nfp)
		(void) fclose(nfp);
	if (tfp)
		(void) fclose(tfp);
	if (rename(tfname, nfname) == -1)
		return(err("renam", tfname, NULL));
@


1.6
log
@-Wall happiness
@
text
@d1 2
a2 2
/*	$OpenBSD: mkheaders.c,v 1.5 1997/07/06 03:54:05 downsj Exp $	*/
/*	$NetBSD: mkheaders.c,v 1.12 1997/02/02 21:12:34 thorpej Exp $	*/
d57 1
d60 1
d63 1
d85 3
d189 122
@


1.5
log
@Add defopt support, from NetBSD; thorpej (I think, I don't have the commit
message).
@
text
@d1 1
a1 1
/*	$OpenBSD: mkheaders.c,v 1.4 1996/10/23 22:37:54 niklas Exp $	*/
d135 1
a135 2
	char fname[BUFSIZ], *p, c;
	const char *n;
@


1.4
log
@Merge of NetBSD 961020.  Includes flexible build/source dir specs
@
text
@d1 2
a2 2
/*	$OpenBSD: mkheaders.c,v 1.3 1996/04/21 23:40:15 deraadt Exp $	*/
/*	$NetBSD: mkheaders.c,v 1.11 1996/08/31 20:58:22 mycroft Exp $	*/
d57 1
d68 1
d77 5
d130 58
a197 1
	free(fname);
@


1.3
log
@sync to netbsd 960418
@
text
@d1 2
a2 2
/*	$OpenBSD: mkheaders.c,v 1.2 1996/03/25 15:55:07 niklas Exp $	*/
/*	$NetBSD: mkheaders.c,v 1.10 1996/03/17 13:18:21 cgd Exp $	*/
a83 1
	register char *fname;
d87 1
d89 1
a89 2
	(void)sprintf(buf, "%s.h", head->nv_name);
	fname = path(buf);
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mkheaders.c,v 1.8 1996/03/03 17:28:20 thorpej Exp $	*/
d4 1
a4 1
/* 
d72 1
a72 1
		    emitcnt(fi->fi_opt))
@


1.1
log
@Initial revision
@
text
@d1 3
a45 1
 *	$Id: mkheaders.c,v 1.7 1995/04/28 06:55:12 cgd Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
