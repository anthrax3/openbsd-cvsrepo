head	1.24;
access;
symbols
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.12
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.8
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.4
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.10
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.8
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.4
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.18
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.16
	OPENBSD_5_0:1.22.0.14
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.12
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.10
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.6
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.10
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.8
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.6
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2012.09.17.17.36.13;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.24.21.35.03;	author maja;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.22.22.35.15;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.25.08.26.59;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.27.18.09.52;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.04.00.47.01;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.28.04.55.07;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.11.23.33.28;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.30.07.36.44;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.29.18.39.00;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.23.06.02.58;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.04.14.23.43;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.11.13.08.21.54;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.06.03.54.04;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.01.18.02.24.14;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.10.23.22.37.52;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.09.12.07.51.17;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.07.07.22.02.20;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.40.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@%{
/*	$OpenBSD: gram.y,v 1.23 2012/09/17 17:36:13 espie Exp $	*/
/*	$NetBSD: gram.y,v 1.14 1997/02/02 21:12:32 thorpej Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)gram.y	8.1 (Berkeley) 6/6/93
 */

#include <sys/param.h>	/* NODEV */
#include <sys/types.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <errno.h>
#include "config.h"
#include "sem.h"

#define	FORMAT(n) ((n) > -10 && (n) < 10 ? "%d" : "0x%x")

#define	stop(s)	error(s), exit(1)

int	include(const char *, int);
void	yyerror(const char *);
int	yylex(void);

static	struct	config conf;	/* at most one active at a time */

/* the following is used to recover nvlist space after errors */
static	struct	nvlist *alloc[1000];
static	int	adepth;
#define	new0(n,s,p,i,x)	(alloc[adepth++] = newnv(n, s, p, i, x))
#define	new_n(n)	new0(n, NULL, NULL, 0, NULL)
#define	new_nx(n, x)	new0(n, NULL, NULL, 0, x)
#define	new_ns(n, s)	new0(n, s, NULL, 0, NULL)
#define	new_si(s, i)	new0(NULL, s, NULL, i, NULL)
#define	new_nsi(n,s,i)	new0(n, s, NULL, i, NULL)
#define	new_np(n, p)	new0(n, NULL, p, 0, NULL)
#define	new_s(s)	new0(NULL, s, NULL, 0, NULL)
#define	new_p(p)	new0(NULL, NULL, p, 0, NULL)
#define	new_px(p, x)	new0(NULL, NULL, p, 0, x)

#define	fx_atom(s)	new0(s, NULL, NULL, FX_ATOM, NULL)
#define	fx_not(e)	new0(NULL, NULL, NULL, FX_NOT, e)
#define	fx_and(e1, e2)	new0(NULL, NULL, e1, FX_AND, e2)
#define	fx_or(e1, e2)	new0(NULL, NULL, e1, FX_OR, e2)

static	void	cleanup(void);
static	void	setmachine(const char *, const char *);
static	void	check_maxpart(void);

%}

%union {
	struct	attr *attr;
	struct	devbase *devb;
	struct	deva *deva;
	struct	nvlist *list;
	const char *str;
	int	val;
}

%token	AND AT ATTACH BUILD COMPILE_WITH CONFIG DEFINE DEFOPT
%token	DEVICE DISABLE
%token	DUMPS ENDFILE XFILE XOBJECT FLAGS INCLUDE XMACHINE MAJOR MAKEOPTIONS
%token	MAXUSERS MAXPARTITIONS MINOR ON OPTIONS PSEUDO_DEVICE ROOT SOURCE SWAP
%token	WITH NEEDS_COUNT NEEDS_FLAG RMOPTIONS ENABLE
%token	<val> NUMBER
%token	<str> PATHNAME WORD EMPTY

%left '|'
%left '&'

%type	<list>	pathnames
%type	<list>	fopts fexpr fatom
%type	<val>	fflgs fflag oflgs oflag
%type	<str>	rule
%type	<attr>	attr
%type	<devb>	devbase
%type	<deva>	devattach_opt
%type	<val>	disable
%type	<list>	atlist interface_opt
%type	<str>	atname
%type	<list>	loclist_opt loclist locdef
%type	<str>	locdefault
%type	<list>	attrs_opt attrs
%type	<list>	locators locator
%type	<list>	swapdev_list dev_spec
%type	<str>	device_instance
%type	<str>	attachment
%type	<str>	value
%type	<val>	major_minor signed_number npseudo
%type	<val>	flags_opt

%%

/*
 * A configuration consists of a machine type, followed by the machine
 * definition files (via the include() mechanism), followed by the
 * configuration specification(s) proper.  In effect, this is two
 * separate grammars, with some shared terminals and nonterminals.
 * Note that we do not have sufficient keywords to enforce any order
 * between elements of "topthings" without introducing shift/reduce
 * conflicts.  Instead, check order requirements in the C code.
 */
Configuration:
	topthings			/* dirspecs, include "std.arch" */
	machine_spec			/* "machine foo" from machine descr. */
	dev_defs dev_eof		/* sys/conf/files */
	dev_defs dev_eof		/* sys/arch/${MACHINE_ARCH}/... */
	dev_defs dev_eof		/* sys/arch/${MACHINE}/... */
					{ check_maxpart(); }
	specs;				/* rest of machine description */

topthings:
	topthings topthing |
	/* empty */;

topthing:
	SOURCE PATHNAME '\n'		{ if (!srcdir) srcdir = $2; } |
	BUILD  PATHNAME '\n'		{ if (!builddir) builddir = $2; } |
	include '\n' |
	'\n';

machine_spec:
	XMACHINE WORD '\n'		{ setmachine($2,NULL); } |
	XMACHINE WORD WORD '\n'		{ setmachine($2,$3); } |
	error { stop("cannot proceed without machine specifier"); };

dev_eof:
	ENDFILE				{ enddefs(); checkfiles(); };

pathnames:
	PATHNAME			{ $$ = new_nsi($1, NULL, 0); } |
	pathnames '|' PATHNAME		{ ($$ = $1)->nv_next = new_nsi($3, NULL, 0); };

/*
 * Various nonterminals shared between the grammars.
 */
file:
	XFILE pathnames fopts fflgs rule { addfile($2, $3, $4, $5); };

object:
	XOBJECT PATHNAME fopts oflgs	{ addobject($2, $3, $4); };

/* order of options is important, must use right recursion */
fopts:
	fexpr				{ $$ = $1; } |
	/* empty */			{ $$ = NULL; };

fexpr:
	fatom				{ $$ = $1; } |
	'!' fatom			{ $$ = fx_not($2); } |
	fexpr '&' fexpr			{ $$ = fx_and($1, $3); } |
	fexpr '|' fexpr			{ $$ = fx_or($1, $3); } |
	'(' fexpr ')'			{ $$ = $2; };

fatom:
	WORD				{ $$ = fx_atom($1); };

fflgs:
	fflgs fflag			{ $$ = $1 | $2; } |
	/* empty */			{ $$ = 0; };

fflag:
	NEEDS_COUNT			{ $$ = FI_NEEDSCOUNT; } |
	NEEDS_FLAG			{ $$ = FI_NEEDSFLAG; };

oflgs:
	oflgs oflag			{ $$ = $1 | $2; } |
	/* empty */			{ $$ = 0; };

oflag:
	NEEDS_FLAG			{ $$ = OI_NEEDSFLAG; };

rule:
	COMPILE_WITH WORD		{ $$ = $2; } |
	/* empty */			{ $$ = NULL; };

include:
	INCLUDE WORD			{ include($2, 0); };


/*
 * The machine definitions grammar.
 */
dev_defs:
	dev_defs dev_def |
	/* empty */;

dev_def:
	one_def '\n'			{ adepth = 0; } |
	'\n' |
	error '\n'			{ cleanup(); };

one_def:
	file |
	object |
	include |
	DEFINE WORD interface_opt	{ (void)defattr($2, $3); } |
	DEFOPT WORD			{ defoption($2); } |
	DEVICE devbase interface_opt attrs_opt
					{ defdev($2, 0, $3, $4); } |
	ATTACH devbase AT atlist devattach_opt attrs_opt
					{ defdevattach($5, $2, $4, $6); } |
	MAXUSERS NUMBER NUMBER NUMBER	{ setdefmaxusers($2, $3, $4); } |
	MAXPARTITIONS NUMBER		{ maxpartitions = $2; } |
	PSEUDO_DEVICE devbase attrs_opt { defdev($2,1,NULL,$3); } |
	MAJOR '{' majorlist '}';

disable:
	DISABLE				{ $$ = 1; } |
	/* empty */			{ $$ = 0; };

atlist:
	atlist ',' atname		{ $$ = new_nx($3, $1); } |
	atname				{ $$ = new_n($1); };

atname:
	WORD				{ $$ = $1; } |
	ROOT				{ $$ = NULL; };

devbase:
	WORD				{ $$ = getdevbase((char *)$1); };

devattach_opt:
	WITH WORD			{ $$ = getdevattach($2); } |
	/* empty */			{ $$ = NULL; };

interface_opt:
	'{' loclist_opt '}'		{ $$ = new_nx("", $2); } |
	/* empty */			{ $$ = NULL; };

loclist_opt:
	loclist				{ $$ = $1; } |
	/* empty */			{ $$ = NULL; };

/* loclist order matters, must use right recursion */
loclist:
	locdef ',' loclist		{ ($$ = $1)->nv_next = $3; } |
	locdef				{ $$ = $1; };

/* "[ WORD locdefault ]" syntax may be unnecessary... */
locdef:
	WORD locdefault			{ $$ = new_nsi($1, $2, 0); } |
	WORD				{ $$ = new_nsi($1, NULL, 0); } |
	'[' WORD locdefault ']'		{ $$ = new_nsi($2, $3, 1); };

locdefault:
	'=' value			{ $$ = $2; };

value:
	WORD				{ $$ = $1; } |
	EMPTY				{ $$ = $1; } |
	signed_number			{
						char bf[40];

						(void)snprintf(bf, sizeof bf,
						    FORMAT($1), $1);
						$$ = intern(bf);
					};

signed_number:
	NUMBER				{ $$ = $1; } |
	'-' NUMBER			{ $$ = -$2; };

attrs_opt:
	':' attrs			{ $$ = $2; } |
	/* empty */			{ $$ = NULL; };

attrs:
	attrs ',' attr			{ $$ = new_px($3, $1); } |
	attr				{ $$ = new_p($1); };

attr:
	WORD				{ $$ = getattr($1); };

majorlist:
	majorlist ',' majordef |
	majordef;

majordef:
	devbase '=' NUMBER		{ setmajor($1, $3); };



/*
 * The configuration grammar.
 */
specs:
	specs spec |
	/* empty */;

spec:
	config_spec '\n'		{ adepth = 0; } |
	'\n' |
	error '\n'			{ cleanup(); };

config_spec:
	file |
	object |
	include |
	OPTIONS opt_list |
	RMOPTIONS ropt_list |
	MAKEOPTIONS mkopt_list |
	MAXUSERS NUMBER			{ setmaxusers($2); } |
	CONFIG conf sysparam_list	{ addconf(&conf); } |
	PSEUDO_DEVICE WORD npseudo disable { addpseudo($2, $3, $4); } |
	device_instance AT attachment ENABLE { enabledev($1, $3); } |
	device_instance AT attachment disable locators flags_opt
					{ adddev($1, $3, $5, $6, $4); };

mkopt_list:
	mkopt_list ',' mkoption |
	mkoption;

mkoption:
	WORD '=' value			{ addmkoption($1, $3); }

opt_list:
	opt_list ',' option |
	option;

ropt_list:
	ropt_list ',' WORD { removeoption($3); } |
	WORD { removeoption($1); };

option:
	WORD				{ addoption($1, NULL); } |
	WORD '=' value			{ addoption($1, $3); };

conf:
	WORD				{ conf.cf_name = $1;
					    conf.cf_lineno = currentline();
					    conf.cf_root = NULL;
					    conf.cf_swap = NULL;
					    conf.cf_dump = NULL; };

sysparam_list:
	sysparam_list sysparam |
	sysparam;

sysparam:
	ROOT on_opt dev_spec	 { setconf(&conf.cf_root, "root", $3); } |
	SWAP on_opt swapdev_list { setconf(&conf.cf_swap, "swap", $3); } |
	DUMPS on_opt dev_spec	 { setconf(&conf.cf_dump, "dumps", $3); };

swapdev_list:
	dev_spec AND swapdev_list	{ ($$ = $1)->nv_next = $3; } |
	dev_spec			{ $$ = $1; };

dev_spec:
	WORD				{ $$ = new_si($1, NODEV); } |
	major_minor			{ $$ = new_si(NULL, $1); };

major_minor:
	MAJOR NUMBER MINOR NUMBER	{ $$ = makedev($2, $4); };

on_opt:
	ON | /* empty */;

npseudo:
	NUMBER				{ $$ = $1; } |
	/* empty */			{ $$ = 1; };

device_instance:
	WORD '*'			{ $$ = starref($1); } |
	WORD				{ $$ = $1; };

attachment:
	ROOT				{ $$ = NULL; } |
	WORD '?'			{ $$ = wildref($1); } |
	WORD				{ $$ = $1; };

locators:
	locators locator		{ ($$ = $2)->nv_next = $1; } |
	/* empty */			{ $$ = NULL; };

locator:
	WORD value			{ $$ = new_ns($1, $2); } |
	WORD '?'			{ $$ = new_ns($1, NULL); };

flags_opt:
	FLAGS NUMBER			{ $$ = $2; } |
	/* empty */			{ $$ = 0; };

%%

void
yyerror(const char *s)
{

	error("%s", s);
}

/*
 * Cleanup procedure after syntax error: release any nvlists
 * allocated during parsing the current line.
 */
static void
cleanup(void)
{
	struct nvlist **np;
	int i;

	for (np = alloc, i = adepth; --i >= 0; np++)
		nvfree(*np);
	adepth = 0;
}

static void
setmachine(const char *mch, const char *mcharch)
{
	char buf[PATH_MAX];

	machine = mch;
	machinearch = mcharch;

	(void)snprintf(buf, sizeof buf, "arch/%s/conf/files.%s", machine, machine);
	if (include(buf, ENDFILE) != 0)
		exit(1);

	if (machinearch != NULL)
		(void)snprintf(buf, sizeof buf, "arch/%s/conf/files.%s",
		    machinearch, machinearch);
	else
		strlcpy(buf, _PATH_DEVNULL, sizeof buf);
	if (include(buf, ENDFILE) != 0)
		exit(1);

	if (include("conf/files", ENDFILE) != 0)
		exit(1);
}

static void
check_maxpart(void)
{
	if (maxpartitions <= 0) {
		stop("cannot proceed without maxpartitions specifier");
	}
}
@


1.23
log
@tedu lint tendrils through config internals.
also mark some known targets as .PHONY

okay miod@@
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.22 2008/03/24 21:35:03 maja Exp $	*/
d45 1
a46 1
#include <sys/param.h>
d50 1
d451 1
a451 1
	char buf[MAXPATHLEN];
@


1.22
log
@Make it possible to disable/enable pseudo devices in UKC, config file and
at config -e. -moj  ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.21 2008/03/22 22:35:15 deraadt Exp $	*/
d99 1
a99 1
%token	AND AT ATTACH BUILD COMPILE_WITH LINT_WITH CONFIG DEFINE DEFOPT
a113 1
%type	<str>	lintrule
d177 1
a177 1
	XFILE pathnames fopts fflgs rule lintrule { addfile($2, $3, $4, $5, $6); };
a213 4
	/* empty */			{ $$ = NULL; };

lintrule:
	LINT_WITH WORD			{ $$ = $2; } |
@


1.21
log
@spaces found reading that diff
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.20 2007/11/25 08:26:59 deraadt Exp $	*/
d349 1
a349 1
	PSEUDO_DEVICE WORD npseudo	{ addpseudo($2, $3); } |
@


1.20
log
@Extend the "file" directive to accept multiple pathnames seperated by '|'.
If more than one path is provided, access() them to choose which one should
be used, while parsing for ${name} expansions... currently limited to
MACHINE_ARCH
ok miod
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.19 2006/04/27 18:09:52 espie Exp $	*/
d99 1
a99 1
%token	AND AT ATTACH BUILD COMPILE_WITH LINT_WITH CONFIG DEFINE DEFOPT 
@


1.19
log
@lint(1) support in config:
- LINTS variables to hold the list of *.ln files.
- OBJS derives from it, since it can contain more files.
- add set of explicit rules for each .ln file.
- add a lint-with keyword that duplicates compile-with functionality
to special-case linting instead of compilation.

Full linting is dependent on LINT_* macros in the arch dependent template
files.

As is, doesn't break normal build. Just creates larger Makefiles.

Review/ok miod@@, cloder@@, deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.18 2004/01/04 00:47:01 deraadt Exp $	*/
d110 1
d170 4
d178 1
a178 1
	XFILE PATHNAME fopts fflgs rule	lintrule { addfile($2, $3, $4, $5, $6); };
@


1.18
log
@Wall and spacing, I am hunting bugs
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.17 2003/06/28 04:55:07 deraadt Exp $	*/
d99 2
a100 1
%token	AND AT ATTACH BUILD COMPILE_WITH CONFIG DEFINE DEFOPT DEVICE DISABLE
d113 1
d173 1
a173 1
	XFILE PATHNAME fopts fflgs rule	{ addfile($2, $3, $4, $5); };
d210 4
@


1.17
log
@ansi & prototype cleanup.  tested in mkr on most arch's.  ok dhartmei
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.16 2003/06/11 23:33:28 deraadt Exp $	*/
d161 1
a161 1
	XMACHINE WORD WORD '\n' 	{ setmachine($2,$3); } |
d237 1
a237 1
	MAXPARTITIONS NUMBER 		{ maxpartitions = $2; } |
d275 1
a275 1
	WORD locdefault 		{ $$ = new_nsi($1, $2, 0); } |
@


1.16
log
@some ansification, some de-register
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.15 2003/06/02 23:36:52 millert Exp $	*/
d254 1
a254 1
	WORD				{ $$ = getdevbase($1); };
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.14 2002/05/30 07:36:44 deraadt Exp $	*/
d420 1
a420 2
yyerror(s)
	const char *s;
d431 1
a431 1
cleanup()
d433 2
a434 2
	register struct nvlist **np;
	register int i;
d442 1
a442 3
setmachine(mch, mcharch)
	const char *mch;
	const char *mcharch;
d466 1
a466 1
check_maxpart()
@


1.14
log
@snprintf in .y files
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.13 2002/05/29 18:39:00 deraadt Exp $	*/
d26 1
a26 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@more strlcat and strlcpy
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.12 2002/02/16 21:28:01 millert Exp $	*/
d289 7
a295 3
	signed_number			{ char bf[40];
					    (void)sprintf(bf, FORMAT($1), $1);
					    $$ = intern(bf); };
d456 1
a456 1
	(void)sprintf(buf, "arch/%s/conf/files.%s", machine, machine);
d461 1
a461 1
		(void)sprintf(buf, "arch/%s/conf/files.%s",
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.11 2001/01/23 06:02:58 angelos Exp $	*/
d460 1
a460 1
		strcpy(buf, _PATH_DEVNULL);
@


1.11
log
@Allow entries like "foo at bar enable", which override previous
entries like "foo bar bar disable"; useful for kernel config lamers
like myself who don't like to use 'config -e' or 'bsd -c' to manually
enable USB. Tested with uhci/ohci on i386.
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.10 2000/01/04 14:23:43 angelos Exp $	*/
d63 3
a65 3
int	include __P((const char *, int));
void	yyerror __P((const char *));
int	yylex __P((void));
d88 3
a90 3
static	void	cleanup __P((void));
static	void	setmachine __P((const char *, const char *));
static	void	check_maxpart __P((void));
@


1.10
log
@Add rmoption/rmoptions; useful for people who want a slightly
modified version of GENERIC.
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.9 1997/11/13 08:21:54 deraadt Exp $	*/
d106 1
a106 1
%token	WITH NEEDS_COUNT NEEDS_FLAG RMOPTIONS
d339 1
@


1.9
log
@from mycroft;
Allow options and makeoptions to take an empty string as a value.
Add `object' and `library' keywords to pull in precompiled .o and .a files.
Syntax is like the `file' keyword; e.g.:
object  arch/i386/i386/mumble.o         [mumble] [needs-flag]
Largely from Michael Richardson in PR 3833, with some changes by me.
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.8 1997/07/06 03:54:04 downsj Exp $	*/
d106 1
a106 1
%token	WITH NEEDS_COUNT NEEDS_FLAG
d334 1
d352 4
@


1.8
log
@Add defopt support, from NetBSD; thorpej (I think, I don't have the commit
message).
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.7 1997/01/18 02:24:14 briggs Exp $	*/
d104 3
a106 3
%token	DUMPS ENDFILE XFILE FLAGS INCLUDE XMACHINE MAJOR MAKEOPTIONS MAXUSERS
%token	MAXPARTITIONS MINOR ON OPTIONS PSEUDO_DEVICE ROOT SOURCE SWAP WITH
%token	NEEDS_COUNT NEEDS_FLAG
d108 1
a108 1
%token	<str> PATHNAME WORD
d114 1
a114 1
%type	<val>	fflgs fflag
d177 3
d203 7
d232 1
d288 1
d331 1
@


1.7
log
@Sync. with current NetBSD--keeping local changes.
@
text
@d2 2
a3 2
/*	$OpenBSD: gram.y,v 1.6 1996/10/23 22:37:52 niklas Exp $	*/
/*	$NetBSD: gram.y,v 1.12 1996/11/11 23:54:17 gwr Exp $	*/
d103 2
a104 2
%token	AND AT ATTACH BUILD COMPILE_WITH CONFIG DEFINE DEVICE DISABLE DUMPS
%token	ENDFILE XFILE FLAGS INCLUDE XMACHINE MAJOR MAKEOPTIONS MAXUSERS
d224 1
@


1.6
log
@Merge of NetBSD 961020.  Includes flexible build/source dir specs
@
text
@d2 2
a3 2
/*	$OpenBSD: gram.y,v 1.5 1996/09/12 07:51:17 mickey Exp $	*/
/*	$NetBSD: gram.y,v 1.9 1996/08/31 21:15:07 mycroft Exp $	*/
d49 1
a50 2
#include <sys/types.h>
#include <sys/stat.h>
a51 1
#include <paths.h>
a65 1
extern const char *lastfile;
a87 1
static	void	setupdirs __P((void));
d90 1
a90 1
static	void	setmaxpartitions __P((int));
d106 2
a107 1
%token	<val> FFLAG NUMBER
d110 3
d114 1
a114 1
%type	<val>	fflgs
a132 3
%left	'|'
%left	'&'

d140 3
d145 6
a150 4
	dirs hdrs machine_spec		/* "machine foo" from machine descr. */
	dev_defs dev_eof		/* ../../conf/devices */
	dev_defs dev_eof		/* devices.foo */
	maxpart_spec dev_defs dev_eof	/* ../../conf/devices */
d153 2
a154 14
dirs:
	dirspecs			= { setupdirs(); };

dirspecs:
	dirspecs dir |
	/* empty */;

dir:
	SOURCE PATHNAME			= { if (!srcdir) srcdir = $2; } |
	BUILD PATHNAME			= { if (!builddir) builddir = $2; } |
	'\n';

hdrs:
	hdrs hdr |
d157 4
a160 2
hdr:
	include |
d164 3
a166 3
	XMACHINE WORD			= { setmachine($2,NULL); } |
	XMACHINE WORD WORD		= { setmachine($2,$3); } |
	error = { stop("cannot proceed without machine specifier"); };
d169 1
a169 9
	ENDFILE				= { enddefs(lastfile); checkfiles(); };

maxpart_blanks:
	maxpart_blanks '\n' |
	/* empty */;

maxpart_spec:
	maxpart_blanks MAXPARTITIONS NUMBER	= { setmaxpartitions($3); } |
	error = { stop("cannot proceed without maxpartitions specifier"); };
d175 1
a175 1
	XFILE PATHNAME fopts fflgs rule	= { addfile($2, $3, $4, $5); };
d179 2
a180 2
	fexpr				= { $$ = $1; } |
	/* empty */			= { $$ = NULL; };
d183 5
a187 5
	fatom				= { $$ = $1; } |
	'!' fatom			= { $$ = fx_not($2); } |
	fexpr '&' fexpr			= { $$ = fx_and($1, $3); } |
	fexpr '|' fexpr			= { $$ = fx_or($1, $3); } |
	'(' fexpr ')'			= { $$ = $2; };
d190 1
a190 1
	WORD				= { $$ = fx_atom($1); };
d193 6
a198 2
	fflgs FFLAG			= { $$ = $1 | $2; } |
	/* empty */			= { $$ = 0; };
d201 2
a202 2
	COMPILE_WITH WORD		= { $$ = $2; } |
	/* empty */			= { $$ = NULL; };
d205 2
a206 1
	INCLUDE WORD			= { include($2, '\n'); };
d216 1
a216 1
	one_def '\n'			= { adepth = 0; } |
d218 1
a218 1
	error '\n'			= { cleanup(); };
d223 1
a223 1
	DEFINE WORD interface_opt	= { (void)defattr($2, $3); } |
d225 1
a225 1
					= { defdev($2, 0, $3, $4); } |
d227 4
a230 3
					= { defdevattach($5, $2, $4, $6); } |
	MAXUSERS NUMBER NUMBER NUMBER	= { setdefmaxusers($2, $3, $4); } |
	PSEUDO_DEVICE devbase attrs_opt = { defdev($2,1,NULL,$3); } |
d234 2
a235 2
	DISABLE				= { $$ = 1; } |
	/* empty */			= { $$ = 0; };
d238 2
a239 2
	atlist ',' atname		= { $$ = new_nx($3, $1); } |
	atname				= { $$ = new_n($1); };
d242 2
a243 2
	WORD				= { $$ = $1; } |
	ROOT				= { $$ = NULL; };
d246 1
a246 1
	WORD				= { $$ = getdevbase($1); };
d249 2
a250 2
	WITH WORD			= { $$ = getdevattach($2); } |
	/* empty */			= { $$ = NULL; };
d253 2
a254 2
	'{' loclist_opt '}'		= { $$ = new_nx("", $2); } |
	/* empty */			= { $$ = NULL; };
d257 2
a258 2
	loclist				= { $$ = $1; } |
	/* empty */			= { $$ = NULL; };
d262 2
a263 2
	locdef ',' loclist		= { ($$ = $1)->nv_next = $3; } |
	locdef				= { $$ = $1; };
d267 3
a269 3
	WORD locdefault 		= { $$ = new_nsi($1, $2, 0); } |
	WORD				= { $$ = new_nsi($1, NULL, 0); } |
	'[' WORD locdefault ']'		= { $$ = new_nsi($2, $3, 1); };
d272 1
a272 1
	'=' value			= { $$ = $2; };
d275 2
a276 2
	WORD				= { $$ = $1; } |
	signed_number			= { char bf[40];
d281 2
a282 2
	NUMBER				= { $$ = $1; } |
	'-' NUMBER			= { $$ = -$2; };
d285 2
a286 2
	':' attrs			= { $$ = $2; } |
	/* empty */			= { $$ = NULL; };
d289 2
a290 2
	attrs ',' attr			= { $$ = new_px($3, $1); } |
	attr				= { $$ = new_p($1); };
d293 1
a293 1
	WORD				= { $$ = getattr($1); };
d300 1
a300 1
	devbase '=' NUMBER		= { setmajor($1, $3); };
d312 1
a312 1
	config_spec '\n'		= { adepth = 0; } |
d314 1
a314 1
	error '\n'			= { cleanup(); };
d321 3
a323 3
	MAXUSERS NUMBER			= { setmaxusers($2); } |
	CONFIG conf sysparam_list	= { addconf(&conf); } |
	PSEUDO_DEVICE WORD npseudo	= { addpseudo($2, $3); } |
d325 1
a325 1
					= { adddev($1, $3, $5, $6, $4); };
d332 1
a332 1
	WORD '=' value			= { addmkoption($1, $3); }
d339 2
a340 2
	WORD				= { addoption($1, NULL); } |
	WORD '=' value			= { addoption($1, $3); };
d343 1
a343 1
	WORD				= { conf.cf_name = $1;
d354 3
a356 3
	ROOT on_opt dev_spec	 = { setconf(&conf.cf_root, "root", $3); } |
	SWAP on_opt swapdev_list = { setconf(&conf.cf_swap, "swap", $3); } |
	DUMPS on_opt dev_spec	 = { setconf(&conf.cf_dump, "dumps", $3); };
d359 2
a360 2
	dev_spec AND swapdev_list	= { ($$ = $1)->nv_next = $3; } |
	dev_spec			= { $$ = $1; };
d363 2
a364 2
	WORD				= { $$ = new_si($1, NODEV); } |
	major_minor			= { $$ = new_si(NULL, $1); };
d367 1
a367 1
	MAJOR NUMBER MINOR NUMBER	= { $$ = makedev($2, $4); };
d373 2
a374 2
	NUMBER				= { $$ = $1; } |
	/* empty */			= { $$ = 1; };
d377 2
a378 2
	WORD '*'			= { $$ = starref($1); } |
	WORD				= { $$ = $1; };
d381 3
a383 3
	ROOT				= { $$ = NULL; } |
	WORD '?'			= { $$ = wildref($1); } |
	WORD				= { $$ = $1; };
d386 2
a387 2
	locators locator		= { ($$ = $2)->nv_next = $1; } |
	/* empty */			= { $$ = NULL; };
d390 2
a391 2
	WORD value			= { $$ = new_ns($1, $2); } |
	WORD '?'			= { $$ = new_ns($1, NULL); };
d394 2
a395 2
	FLAGS NUMBER			= { $$ = $2; } |
	/* empty */			= { $$ = 0; };
a407 42
 * Verify/create builddir if necessary, change to it, and verify srcdir.
 */
static void
setupdirs()
{
	struct stat st;
	char *prof;

	/* srcdir must be specified if builddir is not specified or if
	 * no configuration filename was specified. */
	if ((builddir || strcmp(defbuilddir, ".") == 0) && !srcdir)
		stop("source directory must be specified");

	if (srcdir == NULL)
		srcdir = "../../../..";
	if (builddir == NULL)
		builddir = defbuilddir;

	if (stat(builddir, &st) != 0) {
		if (mkdir(builddir, 0777)) {
			(void)fprintf(stderr, "config: cannot create %s: %s\n",
			    builddir, strerror(errno));
			exit(2);
		}
	} else if (!S_ISDIR(st.st_mode)) {
		(void)fprintf(stderr, "config: %s is not a directory\n",
			      builddir);
		exit(2);
	}
	if (chdir(builddir) != 0) {
		(void)fprintf(stderr, "config: cannot change to %s\n",
			      builddir);
		exit(2);
	}
	if (stat(srcdir, &st) != 0 || !S_ISDIR(st.st_mode)) {
		(void)fprintf(stderr, "config: %s is not a directory\n",
			      srcdir);
		exit(2);
	}
}

/*
d449 1
a449 2
setmaxpartitions(n)
	int n;
d451 3
a453 2

	maxpartitions = n;
@


1.5
log
@set maxpartitions to machine default.
fix shift/reduce conflicts in grammar (i'm ukrainian, not else ;)
@
text
@d2 2
a3 2
/*	$OpenBSD: gram.y,v 1.4 1996/07/07 22:02:20 maja Exp $	*/
/*	$NetBSD: gram.y,v 1.7 1996/03/17 13:18:18 cgd Exp $	*/
d50 2
d57 1
d91 1
d107 3
a109 3
%token	AND AT ATTACH COMPILE_WITH CONFIG DEFINE DEVICE DISABLE DUMPS ENDFILE
%token	XFILE FLAGS INCLUDE XMACHINE MAJOR MAKEOPTIONS MAXUSERS MAXPARTITIONS
%token	MINOR ON OPTIONS PSEUDO_DEVICE ROOT SWAP VECTOR WITH
a123 1
%type	<list>	veclist_opt veclist
d145 1
a145 1
	hdrs machine_spec		/* "machine foo" from machine descr. */
d151 12
d217 1
a217 1
	INCLUDE WORD			= { (void)include($2, '\n'); };
d237 2
a238 3
	ATTACH devbase AT atlist veclist_opt devattach_opt attrs_opt
					= { defdevattach($6, $2, $4, $5	,
				    $7); } |
a254 9
veclist_opt:
	VECTOR veclist			= { $$ = $2; } |
	/* empty */			= { $$ = NULL; };

/* veclist order matters, must use right recursion */
veclist:
	WORD veclist			= { $$ = new_nx($1, $2); } |
	WORD				= { $$ = new_n($1); };

d418 42
d479 1
a479 1
	char buf[MAXPATHLEN], archbuf[MAXPATHLEN];
d483 5
d489 1
a489 1
		(void)sprintf(archbuf, "../../%s/conf/files.%s",
d492 3
a494 2
		strncpy(archbuf, _PATH_DEVNULL, MAXPATHLEN);
	(void)sprintf(buf, "files.%s", machine);
d496 1
a496 3
	if (include(buf, ENDFILE) ||
	    include(archbuf, ENDFILE) ||
	    include("../../../conf/files", ENDFILE))
@


1.4
log
@Add support for allowing disabled devices in a config file. e.g.
ep0 at isa? disable port ? irq ?
disable must be placed before any attribute for the device. /moj
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.3 1996/04/21 23:40:11 deraadt Exp $	*/
d129 3
@


1.3
log
@sync to netbsd 960418
@
text
@d2 1
a2 1
/*	$OpenBSD: gram.y,v 1.2 1996/03/25 15:55:04 niklas Exp $	*/
d103 1
a103 1
%token	AND AT ATTACH COMPILE_WITH CONFIG DEFINE DEVICE DUMPS ENDFILE
d115 1
d220 2
a221 2
					= { defdevattach($6, $2, $4, $5,
					    $7); } |
d226 4
d326 2
a327 2
	device_instance AT attachment locators flags_opt
					= { adddev($1, $3, $4, $5); };
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d2 2
a3 2
/*	$OpenBSD$	*/
/*	$NetBSD: gram.y,v 1.3 1996/03/03 17:28:13 thorpej Exp $	*/
d72 15
a86 8
#define	new0(n,s,p,i)	(alloc[adepth++] = newnv(n, s, p, i))
#define	new_n(n)	new0(n, NULL, NULL, 0)
#define	new_ns(n, s)	new0(n, s, NULL, 0)
#define	new_si(s, i)	new0(NULL, s, NULL, i)
#define	new_nsi(n,s,i)	new0(n, s, NULL, i)
#define	new_np(n, p)	new0(n, NULL, p, 0)
#define	new_s(s)	new0(NULL, s, NULL, 0)
#define	new_p(p)	new0(NULL, NULL, p, 0)
d97 1
d103 1
a103 1
%token	AND AT COMPILE_WITH CONFIG DEFINE DEVICE DUMPS ENDFILE
d105 1
a105 1
%token	MINOR ON OPTIONS PSEUDO_DEVICE ROOT SWAP VECTOR
d109 1
a109 1
%type	<list>	fopts
d114 1
d176 1
a176 1
	WORD fopts			= { ($$ = new_n($1))->nv_next = $2; } |
d179 10
d216 5
a220 2
	DEVICE devbase AT atlist veclist_opt interface_opt attrs_opt
					= { defdev($2, 0, $4, $5, $6, $7); } |
d222 1
a222 1
	PSEUDO_DEVICE devbase attrs_opt = { defdev($2,1,NULL,NULL,NULL,$3); } |
d226 1
a226 1
	atlist ',' atname		= { ($$ = new_n($3))->nv_next = $1; } |
d239 1
a239 1
	WORD veclist			= { ($$ = new_n($1))->nv_next = $2; } |
d245 4
d250 1
a250 1
	'{' loclist_opt '}'		= { ($$ = new_n(""))->nv_next = $2; } |
d286 1
a286 1
	attrs ',' attr			= { ($$ = new_p($3))->nv_next = $1; } |
a379 1
	WORD '*'			= { $$ = starref($1); } |
@


1.1
log
@Initial revision
@
text
@d2 2
a46 1
 *	$Id: gram.y,v 1.2 1995/04/28 08:15:48 cgd Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
