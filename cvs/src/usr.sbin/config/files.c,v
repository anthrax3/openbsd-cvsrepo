head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.10
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.12
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.4
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.10
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.8
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.17.0.6
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.6
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.7.0.16
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.14
	OPENBSD_2_8:1.7.0.12
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	Uu5nFG3wCl0LACBb;

1.19
date	2012.09.17.17.36.13;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.10.02.22.20.49;	author edd;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.02.20.42.17;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.22.22.35.15;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.25.08.26.59;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.27.18.09.52;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.28.04.55.07;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.17.19.42.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.05.10.11.23;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.13.08.21.53;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.07.14.02;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.08.29.03.33.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.23.40.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.25.15.55.03;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.22.00.32.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: files.c,v 1.19 2012/09/17 17:36:13 espie Exp $	*/
/*	$NetBSD: files.c,v 1.6 1996/03/17 13:18:17 cgd Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)files.c	8.1 (Berkeley) 6/6/93
 */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "config.h"

extern const char *yyfile;

/*
 * We check that each full path name is unique.  File base names
 * should generally also be unique, e.g., having both a net/xx.c and
 * a kern/xx.c (or, worse, a net/xx.c and a new/xx.c++) is probably
 * wrong, but is permitted under some conditions.
 */
static struct hashtab *basetab;		/* file base names */
static struct hashtab *pathtab;		/* full path names */

static struct files **nextfile;
static struct files **unchecked;

static struct objects **nextobject;

static int	checkaux(const char *, void *);
static int	fixcount(const char *, void *);
static int	fixfsel(const char *, void *);
static int	fixsel(const char *, void *);
static int	expr_eval(struct nvlist *,
		    int (*)(const char *, void *), void *);
static void	expr_free(struct nvlist *);

#ifdef DEBUG
static void	pr0();
#endif

void
initfiles(void)
{

	basetab = ht_new();
	pathtab = ht_new();
	nextfile = &allfiles;
	unchecked = &allfiles;
	nextobject = &allobjects;
}

void
addfile(struct nvlist *nvpath, struct nvlist *optx, int flags, const char *rule)
{
	struct files *fi;
	const char *dotp, *dotp1, *tail, *path, *tail1 = NULL;
	struct nvlist *nv;
	size_t baselen;
	int needc, needf;
	char base[200];

	/* check various errors */
	needc = flags & FI_NEEDSCOUNT;
	needf = flags & FI_NEEDSFLAG;
	if (needc && needf) {
		error("cannot mix needs-count and needs-flag");
		goto bad;
	}
	if (optx == NULL && (needc || needf)) {
		error("nothing to %s", needc ? "count" : "flag");
		goto bad;
	}

	for (nv = nvpath; nv; nv = nv->nv_next) {
		path = nv->nv_name;

		/* find last part of pathname, and same without trailing suffix */
		tail = strrchr(path, '/');
		if (tail == NULL)
			tail = path;
		else
			tail++;
		dotp = strrchr(tail, '.');
		if (dotp == NULL || dotp[1] == 0 ||
		    (baselen = dotp - tail) >= sizeof(base)) {
			error("invalid pathname `%s'", path);
			goto bad;
		}

		/*
		 * Ensure all tailnames are identical, because .o
		 * filenames must be identical too.
		 */
		if (tail1 &&
		    (dotp - tail != dotp1 - tail1 ||
		    strncmp(tail1, tail, dotp - tail)))
			error("different production from %s %s",
			    nvpath->nv_name, tail);
		tail1 = tail;
		dotp1 = dotp;
	}

	/*
	 * Commit this file to memory.  We will decide later whether it
	 * will be used after all.
	 */
	fi = emalloc(sizeof *fi);
	if (ht_insert(pathtab, path, fi)) {
		free(fi);
		if ((fi = ht_lookup(pathtab, path)) == NULL)
			panic("addfile: ht_lookup(%s)", path);
		error("duplicate file %s", path);
		xerror(fi->fi_srcfile, fi->fi_srcline,
		    "here is the original definition");
	}
	memcpy(base, tail, baselen);
	base[baselen] = 0;
	fi->fi_next = NULL;
	fi->fi_srcfile = yyfile;
	fi->fi_srcline = currentline();
	fi->fi_flags = flags;
	fi->fi_nvpath = nvpath;
	fi->fi_base = intern(base);
	fi->fi_optx = optx;
	fi->fi_optf = NULL;
	fi->fi_mkrule = rule;
	*nextfile = fi;
	nextfile = &fi->fi_next;
	return;
bad:
	expr_free(optx);
}

void
addobject(const char *path, struct nvlist *optx, int flags)
{
	struct objects *oi;

	/*
	 * Commit this object to memory.  We will decide later whether it
	 * will be used after all.
	 */
	oi = emalloc(sizeof *oi);
	if (ht_insert(pathtab, path, oi)) {
		free(oi);
		if ((oi = ht_lookup(pathtab, path)) == NULL)
			panic("addfile: ht_lookup(%s)", path);
		error("duplicate file %s", path);
		xerror(oi->oi_srcfile, oi->oi_srcline,
		    "here is the original definition");
	}
	oi->oi_next = NULL;
	oi->oi_srcfile = yyfile;
	oi->oi_srcline = currentline();
	oi->oi_flags = flags;
	oi->oi_path = path;
	oi->oi_optx = optx;
	oi->oi_optf = NULL;
	*nextobject = oi;
	nextobject = &oi->oi_next;
}

/*
 * We have finished reading some "files" file, either ../../conf/files
 * or ./files.$machine.  Make sure that everything that is flagged as
 * needing a count is reasonable.  (This prevents ../../conf/files from
 * depending on some machine-specific device.)
 */
void
checkfiles(void)
{
	struct files *fi, *last;

	last = NULL;
	for (fi = *unchecked; fi != NULL; last = fi, fi = fi->fi_next)
		if ((fi->fi_flags & FI_NEEDSCOUNT) != 0)
			(void)expr_eval(fi->fi_optx, checkaux, fi);
	if (last != NULL)
		unchecked = &last->fi_next;
}

/*
 * Auxiliary function for checkfiles, called from expr_eval.
 * We are not actually interested in the expression's value.
 */
static int
checkaux(const char *name, void *context)
{
	struct files *fi = context;

	if (ht_lookup(devbasetab, name) == NULL) {
		xerror(fi->fi_srcfile, fi->fi_srcline,
		    "`%s' is not a countable device",
		    name);
		/* keep fixfiles() from complaining again */
		fi->fi_flags |= FI_HIDDEN;
	}
	return (0);
}

/*
 * We have finished reading everything.  Tack the files down: calculate
 * selection and counts as needed.  Check that the object files built
 * from the selected sources do not collide.
 */
int
fixfiles(void)
{
	struct files *fi, *ofi;
	struct nvlist *flathead, **flatp;
	int err, sel;

	err = 0;
	for (fi = allfiles; fi != NULL; fi = fi->fi_next) {
		/* Skip files that generated counted-device complaints. */
		if (fi->fi_flags & FI_HIDDEN)
			continue;

		/* Optional: see if it is to be included. */
		if (fi->fi_optx != NULL) {
			flathead = NULL;
			flatp = &flathead;
			sel = expr_eval(fi->fi_optx,
			    fi->fi_flags & FI_NEEDSCOUNT ? fixcount :
			    fi->fi_flags & FI_NEEDSFLAG ? fixfsel :
			    fixsel,
			    &flatp);
			fi->fi_optf = flathead;
			if (!sel)
				continue;
		}

		/* We like this file.  Make sure it generates a unique .o. */
		if (ht_insert(basetab, fi->fi_base, fi)) {
			if ((ofi = ht_lookup(basetab, fi->fi_base)) == NULL)
				panic("fixfiles ht_lookup(%s)", fi->fi_base);
			/*
			 * If the new file comes from a different source,
			 * allow the new one to override the old one.
			 */
			if (fi->fi_nvpath != ofi->fi_nvpath) {
				if (ht_replace(basetab, fi->fi_base, fi) != 1)
					panic("fixfiles ht_replace(%s)",
					    fi->fi_base);
				ofi->fi_flags &= ~FI_SEL;
				ofi->fi_flags |= FI_HIDDEN;
			} else {
				xerror(fi->fi_srcfile, fi->fi_srcline,
				    "object file collision on %s.o, from %s",
				    fi->fi_base, fi->fi_nvpath->nv_name);
				xerror(ofi->fi_srcfile, ofi->fi_srcline,
				    "here is the previous file: %s",
				    ofi->fi_nvpath->nv_name);
				err = 1;
			}
		}
		fi->fi_flags |= FI_SEL;
	}
	return (err);
}

/*
 * We have finished reading everything.  Tack the objects down: calculate
 * selection.
 */
int
fixobjects(void)
{
	struct objects *oi;
	struct nvlist *flathead, **flatp;
	int err, sel;

	err = 0;
	for (oi = allobjects; oi != NULL; oi = oi->oi_next) {
		/* Optional: see if it is to be included. */
		if (oi->oi_optx != NULL) {
			flathead = NULL;
			flatp = &flathead;
			sel = expr_eval(oi->oi_optx,
			    oi->oi_flags & OI_NEEDSFLAG ? fixfsel :
			    fixsel,
			    &flatp);
			oi->oi_optf = flathead;
			if (!sel)
				continue;
		}

		oi->oi_flags |= OI_SEL;
	}
	return (err);
}

/*
 * Called when evaluating a needs-count expression.  Make sure the
 * atom is a countable device.  The expression succeeds iff there
 * is at least one of them (note that while `xx*' will not always
 * set xx's d_umax > 0, you cannot mix '*' and needs-count).  The
 * mkheaders() routine wants a flattened, in-order list of the
 * atoms for `#define name value' lines, so we build that as we
 * are called to eval each atom.
 */
static int
fixcount(const char *name, void *context)
{
	struct nvlist ***p = context;
	struct devbase *dev;
	struct nvlist *nv;

	dev = ht_lookup(devbasetab, name);
	if (dev == NULL)	/* cannot occur here; we checked earlier */
		panic("fixcount(%s)", name);
	nv = newnv(name, NULL, NULL, dev->d_umax, NULL);
	**p = nv;
	*p = &nv->nv_next;
	(void)ht_insert(needcnttab, name, nv);
	return (dev->d_umax != 0);
}

/*
 * Called from fixfiles when eval'ing a selection expression for a
 * file that will generate a .h with flags.  We will need the flat list.
 */
static int
fixfsel(const char *name, void *context)
{
	struct nvlist ***p = context;
	struct nvlist *nv;
	int sel;

	sel = ht_lookup(selecttab, name) != NULL;
	nv = newnv(name, NULL, NULL, sel, NULL);
	**p = nv;
	*p = &nv->nv_next;
	return (sel);
}

/*
 * As for fixfsel above, but we do not need the flat list.
 */
static int
fixsel(const char *name, void *context)
{

	return (ht_lookup(selecttab, name) != NULL);
}

/*
 * Eval an expression tree.  Calls the given function on each node,
 * passing it the given context & the name; return value is &/|/! of
 * results of evaluating atoms.
 *
 * No short circuiting ever occurs.  fn must return 0 or 1 (otherwise
 * our mixing of C's bitwise & boolean here may give surprises).
 */
static int
expr_eval(struct nvlist *expr, int (*fn)(const char *, void *), void *context)
{
	int lhs, rhs;

	switch (expr->nv_int) {

	case FX_ATOM:
		return ((*fn)(expr->nv_name, context));

	case FX_NOT:
		return (!expr_eval(expr->nv_next, fn, context));

	case FX_AND:
		lhs = expr_eval(expr->nv_ptr, fn, context);
		rhs = expr_eval(expr->nv_next, fn, context);
		return (lhs & rhs);

	case FX_OR:
		lhs = expr_eval(expr->nv_ptr, fn, context);
		rhs = expr_eval(expr->nv_next, fn, context);
		return (lhs | rhs);
	}
	panic("expr_eval %d", expr->nv_int);
	return (0);
}

/*
 * Free an expression tree.
 */
static void
expr_free(struct nvlist *expr)
{
	struct nvlist *rhs;

	/* This loop traverses down the RHS of each subexpression. */
	for (; expr != NULL; expr = rhs) {
		switch (expr->nv_int) {

		/* Atoms and !-exprs have no left hand side. */
		case FX_ATOM:
		case FX_NOT:
			break;

		/* For AND and OR nodes, free the LHS. */
		case FX_AND:
		case FX_OR:
			expr_free(expr->nv_ptr);
			break;

		default:
			panic("expr_free %d", expr->nv_int);
		}
		rhs = expr->nv_next;
		nvfree(expr);
	}
}

#ifdef DEBUG
/*
 * Print expression tree.
 */
void
prexpr(struct nvlist *expr)
{
	printf("expr =");
	pr0(expr);
	printf("\n");
	(void)fflush(stdout);
}

static void
pr0(struct nvlist *e)
{

	switch (e->nv_int) {
	case FX_ATOM:
		printf(" %s", e->nv_name);
		return;
	case FX_NOT:
		printf(" (!");
		break;
	case FX_AND:
		printf(" (&");
		break;
	case FX_OR:
		printf(" (|");
		break;
	default:
		printf(" (?%d?", e->nv_int);
		break;
	}
	if (e->nv_ptr)
		pr0(e->nv_ptr);
	pr0(e->nv_next);
	printf(")");
}
#endif
@


1.19
log
@tedu lint tendrils through config internals.
also mark some known targets as .PHONY

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.18 2011/10/02 22:20:49 edd Exp $	*/
a42 2

#include <sys/param.h>
@


1.18
log
@Fix some minor things in config(8):
 * As haesbaert suggests, correctly order include files.
 * Found some old style function defs. Updated.
 * Found a prototype inside a function. Moved.

OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.17 2010/06/02 20:42:17 chl Exp $	*/
d93 1
a93 2
addfile(struct nvlist *nvpath, struct nvlist *optx, int flags, const char *rule,
    const char *lintrule)
d166 1
a166 2
	fi->fi_mkrule[0] = rule;
	fi->fi_mkrule[1] = lintrule;
@


1.17
log
@fix potential use of uninitialized value, and remove unused variables.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.16 2008/03/22 22:35:15 deraadt Exp $	*/
d45 1
d50 1
d77 4
a461 2
	static void pr0();

@


1.16
log
@spaces found reading that diff
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.15 2007/11/25 08:26:59 deraadt Exp $	*/
d105 1
a105 1
		error("nothing to %s for %s", needc ? "count" : "flag", path);
@


1.15
log
@Extend the "file" directive to accept multiple pathnames seperated by '|'.
If more than one path is provided, access() them to choose which one should
be used, while parsing for ${name} expansions... currently limited to
MACHINE_ARCH
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.14 2006/04/27 18:09:52 espie Exp $	*/
d129 1
a129 1
		if (tail1 && 
@


1.14
log
@lint(1) support in config:
- LINTS variables to hold the list of *.ln files.
- OBJS derives from it, since it can contain more files.
- add set of explicit rules for each .ln file.
- add a lint-with keyword that duplicates compile-with functionality
to special-case linting instead of compilation.

Full linting is dependent on LINT_* macros in the arch dependent template
files.

As is, doesn't break normal build. Just creates larger Makefiles.

Review/ok miod@@, cloder@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.13 2003/06/28 04:55:07 deraadt Exp $	*/
d87 1
a87 1
addfile(const char *path, struct nvlist *optx, int flags, const char *rule, 
d91 2
a92 1
	const char *dotp, *tail;
d109 27
a135 11
	/* find last part of pathname, and same without trailing suffix */
	tail = strrchr(path, '/');
	if (tail == NULL)
		tail = path;
	else
		tail++;
	dotp = strrchr(tail, '.');
	if (dotp == NULL || dotp[1] == 0 ||
	    (baselen = dotp - tail) >= sizeof(base)) {
		error("invalid pathname `%s'", path);
		goto bad;
d157 1
a157 2
	fi->fi_path = path;
	fi->fi_tail = tail;
d277 1
a277 1
			if (fi->fi_path != ofi->fi_path) {
d286 1
a286 1
				    fi->fi_base, fi->fi_path);
d289 1
a289 1
				    ofi->fi_path);
@


1.13
log
@ansi & prototype cleanup.  tested in mkr on most arch's.  ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.12 2003/06/02 23:36:52 millert Exp $	*/
d87 2
a88 1
addfile(const char *path, struct nvlist *optx, int flags, const char *rule)
d145 2
a146 1
	fi->fi_mkrule = rule;
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.11 2002/03/14 16:44:24 mpech Exp $	*/
d76 1
a76 1
initfiles()
d87 1
a87 5
addfile(path, optx, flags, rule)
	const char *path;
	struct nvlist *optx;
	int flags;
	const char *rule;
d153 1
a153 4
addobject(path, optx, flags)
	const char *path;
	struct nvlist *optx;
	int flags;
d188 1
a188 1
checkfiles()
d205 1
a205 3
checkaux(name, context)
	const char *name;
	void *context;
d225 1
a225 1
fixfiles()
d285 1
a285 1
fixobjects()
d321 1
a321 3
fixcount(name, context)
	const char *name;
	void *context;
d342 1
a342 3
fixfsel(name, context)
	const char *name;
	void *context;
d359 1
a359 3
fixsel(name, context)
	const char *name;
	void *context;
d374 1
a374 4
expr_eval(expr, fn, context)
	struct nvlist *expr;
	int (*fn)(const char *, void *);
	void *context;
d404 1
a404 2
expr_free(expr)
	struct nvlist *expr;
d436 1
a436 2
prexpr(expr)
	struct nvlist *expr;
d447 1
a447 2
pr0(e)
	struct nvlist *e;
@


1.11
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.10 2002/02/17 19:42:35 millert Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.9 2002/02/16 21:28:01 millert Exp $	*/
d201 1
a201 1
	register struct files *fi, *last;
d220 1
a220 1
	register struct files *fi = context;
d240 1
a240 1
	register struct files *fi, *ofi;
d335 1
a335 1
	register const char *name;
d338 3
a340 3
	register struct nvlist ***p = context;
	register struct devbase *dev;
	register struct nvlist *nv;
d361 3
a363 3
	register struct nvlist ***p = context;
	register struct nvlist *nv;
	register int sel;
d394 3
a396 3
	register struct nvlist *expr;
	register int (*fn)(const char *, void *);
	register void *context;
d427 1
a427 1
	register struct nvlist *expr;
d429 1
a429 1
	register struct nvlist *rhs;
d472 1
a472 1
	register struct nvlist *e;
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.8 2001/12/05 10:11:23 deraadt Exp $	*/
d75 2
a76 2
static int	expr_eval __P((struct nvlist *,
		    int (*)(const char *, void *), void *));
@


1.8
log
@more free KNF from maja, though this was hard to do
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.7 1997/11/13 08:21:53 deraadt Exp $	*/
d71 4
a74 4
static int	checkaux __P((const char *, void *));
static int	fixcount __P((const char *, void *));
static int	fixfsel __P((const char *, void *));
static int	fixsel __P((const char *, void *));
d77 1
a77 1
static void	expr_free __P((struct nvlist *));
d395 1
a395 1
	register int (*fn) __P((const char *, void *));
@


1.7
log
@from mycroft;
Allow options and makeoptions to take an empty string as a value.
Add `object' and `library' keywords to pull in precompiled .o and .a files.
Syntax is like the `file' keyword; e.g.:
object  arch/i386/i386/mumble.o         [mumble] [needs-flag]
Largely from Michael Richardson in PR 3833, with some changes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.6 1997/01/17 07:14:02 millert Exp $	*/
d180 1
a180 1
	} 
d190 1
a190 1
}     
d293 1
a293 1
/*    
d296 2
a297 2
 */   
int    
d299 1
a299 1
{     
d302 1
a302 1
	int err, sel; 
d319 1
a319 1
		oi->oi_flags |= OI_SEL;  
d322 1
a322 1
}     
@


1.6
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.5 1996/08/29 03:33:05 deraadt Exp $	*/
d69 2
d87 1
a89 13
#if 0
static void
showprev(pref, fi)
	const char *pref;
	register struct files *fi;
{

	xerror(fi->fi_srcfile, fi->fi_srcline,
	    "%sfile %s ...", pref, fi->fi_path);
	errors--;
}
#endif

d160 32
a201 1
	/*register struct nvlist *nv;*/
d249 2
a251 1
			/* Optional: see if it is to be included. */
d293 31
d419 1
a419 1
	/* NOTREACHED */
@


1.5
log
@fix some warnings and errors
@
text
@d1 1
a1 1
/*	$OpenBSD: files.c,v 1.3 1996/03/25 15:55:03 niklas Exp $	*/
d126 1
a126 1
	tail = rindex(path, '/');
d131 1
a131 1
	dotp = rindex(tail, '.');
@


1.4
log
@sync to netbsd 960418
@
text
@d87 1
d98 1
d180 1
a180 1
	register struct nvlist *nv;
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: files.c,v 1.3 1996/03/03 17:28:10 thorpej Exp $	*/
d4 1
a4 1
/* 
d69 8
d99 1
a99 1
addfile(path, opts, flags, rule)
d101 1
a101 1
	struct nvlist *opts;
d106 1
a106 1
	const char *base, *dotp, *tail;
d109 1
a109 1
	char buf[200];
d118 1
a118 1
	if (opts == NULL && (needc || needf)) {
a121 5
	if ((fi = ht_lookup(pathtab, path)) != NULL) {
		showprev("", fi);
		error("file %s listed again", path);
		goto bad;
	}
d131 1
a131 1
	    (baselen = dotp - tail) >= sizeof(buf)) {
d137 2
a138 5
	 * Make a copy of the path without the .c/.s/whatever suffix.
	 * This must be unique per "files" file (e.g., a specific
	 * file can override a standard file, but no standard file
	 * can override another standard file).  This is not perfect
	 * but should catch any major errors.
d140 8
a147 15
	bcopy(tail, buf, baselen);
	buf[baselen] = 0;
	base = intern(buf);
	if ((fi = ht_lookup(basetab, base)) != NULL) {
		if (fi->fi_srcfile != yyfile) {
			showprev("note: ", fi);
			error("is overridden by %s", path);
			errors--;	/* take it away */
			fi->fi_flags |= FI_HIDDEN;
		} else {
			showprev("", fi);
			error("collides with %s (both make %s.o)",
			    path, base);
			goto bad;
		}
d149 2
a150 5

	/*
	 * Commit this file to memory.
	 */
	fi = emalloc(sizeof *fi);
a154 1
	fi->fi_lastc = dotp[strlen(dotp) - 1];
d157 3
a159 2
	fi->fi_base = base;
	fi->fi_opt = opts;
a160 3
	if (ht_insert(pathtab, path, fi))
		panic("addfile: ht_insert(%s)", path);
	(void)ht_replace(basetab, base, fi);
d165 1
a165 1
	nvfreel(opts);
d181 3
a183 12
	for (fi = *unchecked; fi != NULL; last = fi, fi = fi->fi_next) {
		if ((fi->fi_flags & FI_NEEDSCOUNT) == 0)
			continue;
		for (nv = fi->fi_opt; nv != NULL; nv = nv->nv_next)
			if (ht_lookup(devbasetab, nv->nv_name) == NULL) {
				xerror(fi->fi_srcfile, fi->fi_srcline,
				    "`%s' is not a countable device",
				    nv->nv_name);
				/* keep fixfiles() from complaining again */
				fi->fi_flags |= FI_HIDDEN;
			}
	}
d189 21
d211 2
a212 1
 * selection and counts as needed.
d217 3
a219 4
	register struct files *fi;
	register struct nvlist *nv;
	register struct devbase *dev;
	int sel, err;
d223 1
d226 12
a237 3
		if ((nv = fi->fi_opt) == NULL) {	/* standard */
			fi->fi_flags |= FI_SEL;
			continue;
d239 24
a262 29
		/* figure out whether it is selected */
		sel = 0;
		if (fi->fi_flags & FI_NEEDSCOUNT) {
			/* ... and compute counts too */
			do {
				dev = ht_lookup(devbasetab, nv->nv_name);
				if (dev == NULL) {
					xerror(fi->fi_srcfile, fi->fi_srcline,
					    "`%s' is not a countable device",
					    nv->nv_name);
					err = 1;
				} else {
					if (dev->d_umax)
						sel = 1;
					nv->nv_int = dev->d_umax;
					(void)ht_insert(needcnttab,
					    nv->nv_name, nv);
				}
			} while ((nv = nv->nv_next) != NULL);
		} else {
			do {
				if (ht_lookup(selecttab, nv->nv_name)) {
					sel = 1;
					break;
				}
			} while ((nv = nv->nv_next) != NULL);
			if (fi->fi_flags & FI_NEEDSFLAG)
				for (nv = fi->fi_opt; nv; nv = nv->nv_next)
					nv->nv_int = sel;
d264 1
a264 3
		/* if selected, we are go */
		if (sel)
			fi->fi_flags |= FI_SEL;
d268 175
@


1.2
log
@From NetBSD:
Spelling correction
@
text
@d1 3
a45 1
 *	$Id: files.c,v 1.1.1.1 1995/10/18 08:48:33 deraadt Exp $
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
 *	$Id: files.c,v 1.1 1995/04/28 06:55:05 cgd Exp $
d144 1
a144 1
			error("is overriden by %s", path);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
