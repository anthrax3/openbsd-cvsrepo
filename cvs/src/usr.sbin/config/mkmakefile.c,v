head	1.44;
access;
symbols
	OPENBSD_6_2_BASE:1.44
	OPENBSD_6_1:1.42.0.4
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.41.0.8
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.4
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.37.0.4
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.36.0.4
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.2
	OPENBSD_5_0:1.35.0.6
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.4
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.6
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.21.0.4
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.12
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2017.07.18.16.43.27;	author tb;	state Exp;
branches;
next	1.43;
commitid	iapv8276IrtCm0Fi;

1.43
date	2017.06.22.15.57.16;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	FlfWbfYHI6yxXhh6;

1.42
date	2016.10.16.17.50.00;	author tb;	state Exp;
branches;
next	1.41;
commitid	9USjn6ChymyvzYCb;

1.41
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	Uu5nFG3wCl0LACBb;

1.40
date	2014.06.04.07.14.29;	author jsg;	state Exp;
branches;
next	1.39;
commitid	KlEGh7mFXfLIyEYA;

1.39
date	2013.11.23.17.38.15;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.10.29.15.37.56;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2012.09.17.17.36.13;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2011.10.02.22.20.50;	author edd;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.02.20.42.17;	author chl;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.31.21.56.43;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.24.20.02.08;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.19.19.46.57;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.14.10.18.34;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2008.04.19.14.22.04;	author chl;	state Exp;
branches;
next	1.29;

1.29
date	2008.03.22.22.35.15;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.22.22.30.36;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.27.14.56.31;	author chl;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.26.19.49.46;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.26.17.25.59;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.26.17.24.24;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.25.20.10.40;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.25.08.26.59;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.06.05.05.16;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.06.11.31.46;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.27.18.09.52;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.08.02.22.54;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.05.04.32.21;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.04.18.30.05;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.28.04.55.07;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.23.22.16.40;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.29.09.45.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.05.10.11.23;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.05.02.55.24;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	97.11.13.08.21.55;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.06.03.54.06;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.10.23.22.37.56;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.10.04;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.40.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.09;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.34;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Stop automatically regenerating gap.o (and hence linking a new kernel)
whenever make is issued. Only do this when there are actual source changes
below /sys. This restores the behavior prior to the KARL implementation.

Problem noticed and patiently explained by mpi
implementation with a lot of help from espie

ok mpi, espie, deraadt
@
text
@/*	$OpenBSD: mkmakefile.c,v 1.43 2017/06/22 15:57:16 deraadt Exp $	*/
/*	$NetBSD: mkmakefile.c,v 1.34 1997/02/02 21:12:36 thorpej Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)mkmakefile.c	8.1 (Berkeley) 6/6/93
 */

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "config.h"
#include "sem.h"

/*
 * Make the Makefile.
 */

static const char *srcpath(struct files *);

static int emitdefs(FILE *);
static int emitreconfig(FILE *);
static int emitfiles(FILE *, int);

static int emitobjs(FILE *);
static int emitcfiles(FILE *);
static int emitsfiles(FILE *);
static int emitrules(FILE *);
static int emitload(FILE *);

int
mkmakefile(void)
{
	FILE *ifp, *ofp;
	int lineno;
	int (*fn)(FILE *);
	char *ifname;
	char line[BUFSIZ], buf[200];

	(void)snprintf(buf, sizeof buf, "arch/%s/conf/Makefile.%s",
	    machine, machine);
	ifname = sourcepath(buf);
	if ((ifp = fopen(ifname, "r")) == NULL) {
		warn("cannot read %s", ifname);
		free(ifname);
		return (1);
	}
	if ((ofp = fopen("Makefile", "w")) == NULL) {
		warn("cannot write Makefile");
		free(ifname);
		(void)fclose(ifp);
		return (1);
	}
	if (emitdefs(ofp) != 0)
		goto wrerror;
	lineno = 0;
	while (fgets(line, sizeof(line), ifp) != NULL) {
		lineno++;
		if (line[0] != '%') {
			if (fputs(line, ofp) < 0)
				goto wrerror;
			continue;
		}
		if (strcmp(line, "%OBJS\n") == 0)
			fn = emitobjs;
		else if (strcmp(line, "%CFILES\n") == 0)
			fn = emitcfiles;
		else if (strcmp(line, "%SFILES\n") == 0)
			fn = emitsfiles;
		else if (strcmp(line, "%RULES\n") == 0)
			fn = emitrules;
		else if (strcmp(line, "%LOAD\n") == 0)
			fn = emitload;
		else {
			xerror(ifname, lineno,
			    "unknown %% construct ignored: %s", line);
			continue;
		}
		if ((*fn)(ofp))
			goto wrerror;
	}
	if (startdir != NULL) {
		if (emitreconfig(ofp) != 0)
			goto wrerror;
	}
	if (ferror(ifp)) {
		warn("error reading %s (at line %d)", ifname, lineno);
		goto bad;
	}
	if (fclose(ofp)) {
		ofp = NULL;
		goto wrerror;
	}
	(void)fclose(ifp);
	free(ifname);
	return (0);
wrerror:
	warn("error writing Makefile");
bad:
	if (ofp != NULL)
		(void)fclose(ofp);
	/* (void)unlink("Makefile"); */
	free(ifname);
	return (1);
}

char *
expandname(const char *_nam)
{
	char *ret = NULL, *nam, *n, *s, *e, *expand;
	const char *var = NULL;

	if ((nam = n = strdup(_nam)) == NULL)
		errx(1, "out of memory");

	while (*n) {
		/* Search for a ${name} to expand */
		if ((s = strchr(n, '$')) == NULL) {
			if (ret == NULL)
				break;
			if (asprintf(&expand, "%s%s", ret, n) == -1)
				errx(1, "out of memory");
			free(ret);
			ret = expand;
			break;
		}
		*s++ = '\0';
		if (*s != '{')
			error("{");
		e = strchr(++s, '}');
		if (!e)
			error("}");
		*e = '\0';

		if (strcmp(s, "MACHINE_ARCH") == 0)
			var = machinearch ? machinearch : machine;
		else if (strcmp(s, "MACHINE") == 0)
			var = machine;
		else
			error("variable `%s' not supported", s);

		if (asprintf(&expand, "%s%s", ret ? ret : nam, var) == -1)
			errx(1, "out of memory");
		free(ret);
		ret = expand;
		n = e + 1;
	}
	free(nam);
	return (ret);
}

/*
 * Return (possibly in a static buffer) the name of the `source' for a
 * file.  If we have `options source', or if the file is marked `always
 * source', this is always the path from the `file' line; otherwise we
 * get the .o from the obj-directory.
 */
static const char *
srcpath(struct files *fi)
{
	/* Always have source, don't support object dirs for kernel builds. */
	struct nvlist *nv, *nv1;
	char *expand, *source;

	/* Search path list for files we will want to use */
	if (fi->fi_nvpath->nv_next == NULL) {
		nv = fi->fi_nvpath;
		goto onlyone;
	}

	for (nv = fi->fi_nvpath; nv; nv = nv->nv_next) {
		expand = expandname(nv->nv_name);
		source = sourcepath(expand ? expand : nv->nv_name);
		if (access(source, R_OK) == 0) {
			/* XXX poolalloc() prevents freeing old nv_name */
			if (expand)
				nv->nv_name = intern(expand);
			break;
		}
		free(expand);
		free(source);
	}
	if (nv == NULL)
		nv = fi->fi_nvpath;

	/*
	 * Now that we know which path is selected, delete all the
	 * other paths to skip the access() checks next time.
	 */
	while ((nv1 = fi->fi_nvpath)) {
		nv1 = nv1->nv_next;
		if (fi->fi_nvpath != nv)
			nvfree(fi->fi_nvpath);
		fi->fi_nvpath = nv1;
	}
	fi->fi_nvpath = nv;
	nv->nv_next = NULL;
onlyone:
	return (nv->nv_name);
}

static int
emitdefs(FILE *fp)
{
	struct nvlist *nv;
	char *sp;

	if (fputs("IDENT=", fp) < 0)
		return (1);
	sp = "";
	for (nv = options; nv != NULL; nv = nv->nv_next) {
		if (ht_lookup(defopttab, nv->nv_name) != NULL)
			continue;
		if (fprintf(fp, "%s-D%s", sp, nv->nv_name) < 0)
		    return 1;
		if (nv->nv_str)
		    if (fprintf(fp, "=\"%s\"", nv->nv_str) < 0)
			return 1;
		sp = " ";
	}
	if (putc('\n', fp) < 0)
		return (1);
	if (fprintf(fp, "PARAM=-DMAXUSERS=%d\n", maxusers) < 0)
		return (1);
	if (fprintf(fp, "S=\t%s\n", srcdir) < 0)
		return (1);
	if (fprintf(fp, "_mach=%s\n", machine) < 0)
		return (1);
	if (fprintf(fp, "_arch=%s\n", machinearch ? machinearch : machine) < 0)
		return (1);
	for (nv = mkoptions; nv != NULL; nv = nv->nv_next)
		if (fprintf(fp, "%s=%s\n", nv->nv_name, nv->nv_str) < 0)
			return (1);
	return (0);
}

static int
emitreconfig(FILE *fp)
{
	if (fputs("\n"
	    ".PHONY: config\n"
	    "config:\n", fp) < 0)
		return (1);
	if (fprintf(fp, "\tcd %s && config ", startdir) < 0)
		return (1);
	if (pflag) {
		if (fputs("-p ", fp) < 0)
			return (1);
	}
	if (sflag) {
		if (fprintf(fp, "-s %s ", sflag) < 0)
			return (1);
	}
	if (bflag) {
		if (fprintf(fp, "-b %s ", bflag) < 0)
			return (1);
	}
	/* other options */
	if (fprintf(fp, "%s\n", conffile) < 0)
		return (1);
	return (0);
}

static int
emitobjs(FILE *fp)
{
	struct files *fi;
	struct objects *oi;
	int lpos, len, sp;
	const char *fpath;

	if (fputs("OBJS=", fp) < 0)
		return (1);
	sp = '\t';
	lpos = 7;
	for (fi = allfiles; fi != NULL; fi = fi->fi_next) {
		if ((fi->fi_flags & FI_SEL) == 0)
			continue;
		if ((fpath = srcpath(fi)) == NULL)
			return (1);
		len = strlen(fi->fi_base) + 3;
		if (lpos + len > 72) {
			if (fputs(" \\\n", fp) < 0)
				return (1);
			sp = '\t';
			lpos = 7;
		}
		if (fprintf(fp, "%c%s.o", sp, fi->fi_base) < 0)
			return (1);
		lpos += len + 1;
		sp = ' ';
	}
	for (oi = allobjects; oi != NULL; oi = oi->oi_next) {
		if ((oi->oi_flags & OI_SEL) == 0)
			continue;
		len = strlen(oi->oi_path) + 3;
		if (lpos + len > 72) {
			if (fputs(" \\\n", fp) < 0)
				return (1);
			sp = '\t';
			lpos = 7;
		}
		if (fprintf(fp, "%c$S/%s", sp, oi->oi_path) < 0)
			return (1);
		lpos += len + 1;
		sp = ' ';
	}
	if (putc('\n', fp) < 0)
		return (1);
	return (0);
}

static int
emitcfiles(FILE *fp)
{

	return (emitfiles(fp, 'c'));
}

static int
emitsfiles(FILE *fp)
{

	return (emitfiles(fp, 's'));
}

static int
emitfiles(FILE *fp, int suffix)
{
	struct files *fi;
	int lpos, len, sp;
	const char *fpath;
	char uppersuffix = toupper((unsigned char)suffix);

	if (fprintf(fp, "%cFILES=", uppersuffix) < 0)
		return (1);
	sp = '\t';
	lpos = 7;
	for (fi = allfiles; fi != NULL; fi = fi->fi_next) {
		if ((fi->fi_flags & FI_SEL) == 0)
			continue;
		if ((fpath = srcpath(fi)) == NULL)
			return (1);
		len = strlen(fpath);
		if (fpath[len - 1] != suffix && fpath[len - 1] != uppersuffix)
			continue;
		if (*fpath != '/')
			len += 3;	/* "$S/" */
		if (lpos + len > 72) {
			if (fputs(" \\\n", fp) < 0)
				return (1);
			sp = '\t';
			lpos = 7;
		}
		if (fprintf(fp, "%c%s%s", sp, *fpath != '/' ? "$S/" : "",
		    fpath) < 0)
			return (1);
		lpos += len + 1;
		sp = ' ';
	}
	if (putc('\n', fp) < 0)
		return (1);
	return (0);
}

/*
 * Emit the make-rules.
 */
static int
emit_1rule(FILE *fp, struct files *fi, const char *fpath, const char *suffix)
{
	if (fprintf(fp, "%s%s: %s%s\n", fi->fi_base, suffix,
	    *fpath != '/' ? "$S/" : "", fpath) < 0)
		return (1);
	if (fi->fi_mkrule != NULL) {
		if (fprintf(fp, "\t%s\n\n", fi->fi_mkrule) < 0)
			return (1);
	}
	return (0);
}

static int
emitrules(FILE *fp)
{
	struct files *fi;
	const char *fpath;

	/* write suffixes */
	if (fprintf(fp,
	    ".SUFFIXES:\n"
	    ".SUFFIXES: .s .S .c .o\n\n"

	    ".PHONY: depend all install clean tags newbsd update-link\n\n"

	    ".c.o:\n"
	    "\t${NORMAL_C}\n\n"

	    ".s.o:\n"
	    "\t${NORMAL_S}\n\n"

	    ".S.o:\n"
	    "\t${NORMAL_S}\n\n") < 0)
		return (1);


	for (fi = allfiles; fi != NULL; fi = fi->fi_next) {
		if ((fi->fi_flags & FI_SEL) == 0)
			continue;
		if ((fpath = srcpath(fi)) == NULL)
			return (1);
		/* special rule: need to emit them independently */
		if (fi->fi_mkrule) {
			if (emit_1rule(fp, fi, fpath, ".o"))
				return (1);
		/* simple default rule */
		} else {
			if (fprintf(fp, "%s.o: %s%s\n", fi->fi_base,
			    *fpath != '/' ? "$S/" : "", fpath) < 0)
				return (1);
		}

	}
	return (0);
}

/*
 * Emit the load commands.
 *
 * This function is not to be called `spurt'.
 */
static int
emitload(FILE *fp)
{
	struct config *cf;
	const char *nm, *swname;
	int first;

	if (fputs("all:", fp) < 0)
		return (1);
	for (cf = allcf; cf != NULL; cf = cf->cf_next) {
		if (fprintf(fp, " %s", cf->cf_name) < 0)
			return (1);
	}
	if (fputs("\n\n", fp) < 0)
		return (1);
	for (first = 1, cf = allcf; cf != NULL; cf = cf->cf_next) {
		nm = cf->cf_name;
		swname =
		    cf->cf_root != NULL ? cf->cf_name : "generic";
		if (fprintf(fp, "%s: ${SYSTEM_DEP} swap%s.o", nm, swname) < 0)
			return (1);
		if (first) {
			if (fputs(" vers.o", fp) < 0)
				return (1);
			first = 0;
		}
		if (fprintf(fp, "\n"
		    "\t${SYSTEM_LD_HEAD}\n"
		    "\t${SYSTEM_LD} swap%s.o\n"
		    "\t${SYSTEM_LD_TAIL}\n"
		    "\n"
		    "swap%s.o: ", swname, swname) < 0)
			return (1);
		if (cf->cf_root != NULL) {
			if (fprintf(fp, "swap%s.c\n", nm) < 0)
				return (1);
		} else {
			if (fprintf(fp, "$S/conf/swapgeneric.c\n") < 0)
				return (1);
		}
		if (fputs("\t${NORMAL_C}\n\n", fp) < 0)
			return (1);

		if (fprintf(fp, "new%s:\n", nm) < 0)
			return (1);
		if (fprintf(fp,
		    "\t${MAKE_GAP}\n"
		    "\t${SYSTEM_LD_HEAD}\n"
		    "\t${SYSTEM_LD} swap%s.o\n"
		    "\t${SYSTEM_LD_TAIL}\n"
		    "\tmv -f new%s %s\n\n",
		    swname, nm, nm) < 0)
			return (1);

		if (fprintf(fp, "update-link:\n") < 0)
			return (1);
		if (fprintf(fp,
		    "\tmkdir -p -m 700 /usr/share/compile\n"
		    "\trm -rf /usr/share/compile/%s /usr/share/compile.tgz\n"
		    "\tmkdir /usr/share/compile/%s\n"
		    "\ttar -chf - Makefile makegap.sh ld.script *.o | \\\n"
		    "\t    tar -C /usr/share/compile/%s -xf -\n\n",
		    last_component, last_component, last_component) < 0)
			return (1);
	}
	return (0);
}
@


1.43
log
@Generate the newbsd: and install-update: targets here, rather than
in the source Makefile.* files.
ok tb rpe mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.42 2016/10/16 17:50:00 tb Exp $	*/
d513 1
a513 1
		if (fprintf(fp, "new%s: gap.o\n", nm) < 0)
d516 1
@


1.42
log
@Use the err(3) family of functions more consistently.

ok jca, improvements and ok millert, natano
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.41 2015/01/16 06:40:16 deraadt Exp $	*/
d432 1
a432 1
	    ".PHONY: depend all install clean tags\n\n"
d511 21
@


1.41
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.40 2014/06/04 07:14:29 jsg Exp $	*/
d83 1
a83 2
		(void)fprintf(stderr, "config: cannot read %s: %s\n",
		    ifname, strerror(errno));
d88 1
a88 2
		(void)fprintf(stderr, "config: cannot write Makefile: %s\n",
		    strerror(errno));
d126 1
a126 3
		(void)fprintf(stderr,
		    "config: error reading %s (at line %d): %s\n",
		    ifname, lineno, strerror(errno));
d137 1
a137 2
	(void)fprintf(stderr, "config: error writing Makefile: %s\n",
	    strerror(errno));
@


1.40
log
@fix a fd leak in an error path
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.39 2013/11/23 17:38:15 deraadt Exp $	*/
a42 2

#include <sys/param.h>
@


1.39
log
@unsigned char casts for ctype
ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.38 2013/10/29 15:37:56 espie Exp $	*/
d94 1
@


1.38
log
@emit an extra "config" convenience target that allows one
to rerun config without changing directories.

Lots of inputs by deraadt@@, who wanted it to work for movable
relative directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.37 2012/09/17 17:36:13 espie Exp $	*/
d378 1
a378 1
	int uppersuffix = toupper(suffix);
@


1.37
log
@tedu lint tendrils through config internals.
also mark some known targets as .PHONY

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.36 2011/10/02 22:20:50 edd Exp $	*/
d63 1
d124 4
d279 27
@


1.36
log
@Fix some minor things in config(8):
 * As haesbaert suggests, correctly order include files.
 * Found some old style function defs. Updated.
 * Found a prototype inside a function. Moved.

OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.35 2010/06/02 20:42:17 chl Exp $	*/
d285 1
a285 1
	if (fputs("LINTS=", fp) < 0)
a293 26
		len = strlen(fpath);
		if (fpath[len - 1] == 's' || fpath[len - 1] == 'S')
			continue;
		len = strlen(fi->fi_base) + 3;
		if (lpos + len > 72) {
			if (fputs(" \\\n", fp) < 0)
				return (1);
			sp = '\t';
			lpos = 7;
		}
		if (fprintf(fp, "%c%s.ln", sp, fi->fi_base) < 0)
			return (1);
		lpos += len + 1;
		sp = ' ';
	}
	if (fputs("\n\nOBJS=\t${LINTS:.ln=.o}", fp) < 0)
		return (1);
	lpos = 7 + strlen("${LINTS:.ln=.o}");
	for (fi = allfiles; fi != NULL; fi = fi->fi_next) {
		if ((fi->fi_flags & FI_SEL) == 0)
			continue;
		if ((fpath = srcpath(fi)) == NULL)
			return (1);
		len = strlen(fpath);
		if (fpath[len - 1] != 's' && fpath[len - 1] != 'S')
			continue;
d383 1
a383 2
emit_1rule(FILE *fp, struct files *fi, const char *fpath, const char *suffix,
    int ruleindex)
d388 2
a389 2
	if (fi->fi_mkrule[ruleindex] != NULL) {
		if (fprintf(fp, "\t%s\n\n", fi->fi_mkrule[ruleindex]) < 0)
d404 3
a406 1
	    ".SUFFIXES: .s .S .c .o .ln\n\n"
a410 3
	    ".c.ln:\n"
	    "\t${LINT_C}\n\n"

a413 3
	    ".s.ln:\n"
	    "\t${LINT_S}\n\n"

d415 1
a415 4
	    "\t${NORMAL_S}\n\n"

	    ".S.ln:\n"
	    "\t${LINT_S}\n\n") < 0)
d425 2
a426 3
		if (fi->fi_mkrule[0] || fi->fi_mkrule[1]) {
			if (emit_1rule(fp, fi, fpath, ".o", 0) ||
			    emit_1rule(fp, fi, fpath, ".ln", 1))
d430 1
a430 2
			if (fprintf(fp, "%s.o %s.ln: %s%s\n", fi->fi_base,
			    fi->fi_base,
@


1.35
log
@fix potential use of uninitialized value, and remove unused variables.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.34 2010/05/31 21:56:43 deraadt Exp $	*/
d45 1
d52 1
@


1.34
log
@Do not add the swap*.c to the CFILES as a dependency.  The rest of the
Makefile.* file copes with swap*.c the same as vers.c; it is also much
nicer to keep the whole CFILES as far-reaching absolute or relative paths
rather than relative to .
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.33 2010/05/24 20:02:08 deraadt Exp $	*/
a367 1
	struct config *cf;
a369 1
	char swapname[100];
@


1.33
log
@automatically generate the _arch= and _mach= lines at the top of the kernel
Makefile, since we already know them.  (Later on, we can remove the chunks
from the Makefile.* files...)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.32 2009/10/19 19:46:57 guenther Exp $	*/
a398 26
	}
	/*
	 * The allfiles list does not include the configuration-specific
	 * C source files.  These files should be eliminated someday, but
	 * for now, we have to add them to ${CFILES} (and only ${CFILES}).
	 */
	if (suffix == 'c') {
		for (cf = allcf; cf != NULL; cf = cf->cf_next) {
			if (cf->cf_root == NULL)
				(void)snprintf(swapname, sizeof swapname,
				    "$S/conf/swapgeneric.c");
			else
				(void)snprintf(swapname, sizeof swapname,
				    "./swap%s.c", cf->cf_name);
			len = strlen(swapname);
			if (lpos + len > 72) {
				if (fputs(" \\\n", fp) < 0)
					return (1);
				sp = '\t';
				lpos = 7;
			}
			if (fprintf(fp, "%c%s", sp, swapname) < 0)
				return (1);
			lpos += len + 1;
			sp = ' ';
		}
@


1.32
log
@Correct a target name so that we don't rebuild vers.o (and then
bsd) unless some other object has changed.  Rebuild and reinstall
in /usr/src/usr.sbin/config/ after updating!

"I like it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.31 2008/08/14 10:18:34 espie Exp $	*/
d264 4
@


1.31
log
@simplify S definition to just srcdir, since it appears there's no special
case anymore.
Note that you can always override it from the command line if you need it.

after discussion with deraadt@@ and tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.30 2008/04/19 14:22:04 chl Exp $	*/
d524 1
a524 1
			if (fputs(" newvers", fp) < 0)
@


1.30
log
@remove build warnings:
- unused variables
- missing return

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.29 2008/03/22 22:35:15 deraadt Exp $	*/
d263 2
a264 18
	switch (*srcdir) {
	case '/':
		if (fprintf(fp, "S=\t%s\n", srcdir) < 0)
			return (1);
		break;
	case '.':
		if (fprintf(fp, "S!=\techo `/bin/pwd`/%s\n", srcdir) < 0)
			return (1);
		break;
	default:
		/*
		 * libkern and libcompat "Makefile.inc"s want relative S
		 * specification to begin with '.'.
		 */
		if (fprintf(fp, "S!=\techo .`/bin/pwd`/%s\n", srcdir) < 0)
			return (1);
		break;
	}
@


1.29
log
@spaces found reading that diff
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.28 2008/03/22 22:30:36 espie Exp $	*/
d457 1
d464 1
a464 3
	const char *cp, *fpath;
	int ch;
	char buf[200];
@


1.28
log
@put in explicit suffix rules, they're needed anyways since $< is only used
for suffix rules.

Use them to avoid writing loads of explicit lines.
Shaves 2/3 of each Makefile off.

okay miod@@, deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.27 2007/11/27 14:56:31 chl Exp $	*/
d501 1
a501 1
			    	return (1);
d504 1
a504 1
			if (fprintf(fp, "%s.o %s.ln: %s%s\n", fi->fi_base, 
@


1.27
log
@add missing header for errx.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.26 2007/11/26 19:49:46 deraadt Exp $	*/
d447 14
a460 1
emitrules1(FILE *fp, const char *suffix, const char *rule_prefix, int ruleindex)
d467 25
d497 10
a506 7
		if (fprintf(fp, "%s%s: %s%s\n", fi->fi_base, suffix,
		    *fpath != '/' ? "$S/" : "", fpath) < 0)
			return (1);
		if ((cp = fi->fi_mkrule[ruleindex]) == NULL) {
			cp = rule_prefix;
			if (fpath[0] == '\0') {
				errno = ENOENT;
a507 7
			}
			ch = fpath[strlen(fpath) - 1];
			if (islower(ch))
				ch = toupper(ch);
			(void)snprintf(buf, sizeof buf, "${%s_%c}",
			    cp, ch);
			cp = buf;
d509 1
a509 2
		if (fprintf(fp, "\t%s\n\n", cp) < 0)
			return (1);
a511 6
}

static int
emitrules(FILE *fp)
{
	return emitrules1(fp, ".o", "NORMAL", 0) || emitrules1(fp, ".ln", "LINT", 1);
@


1.26
log
@Let multiple variables in the same filename expand
ok otto millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.25 2007/11/26 17:25:59 deraadt Exp $	*/
d46 1
@


1.25
log
@Put the converted filename into the makefiles, so that we can later support
variables make(1) does not natively convert in the same way.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.23 2007/11/25 20:10:40 deraadt Exp $	*/
d144 45
a200 1
	const char *var;
d209 2
a210 31
		char *s, *e;

		expand = NULL;
		s = strchr(nv->nv_name, '$');
		if (s) {
			size_t len;

			/* Search for a ${name} to expand */
			if (s[1] != '{')
				error("{");
			e = strchr(s + 2, '}');
			if (!e)
				error("}");

			len = e - s - 2;
			if (strlen("MACHINE_ARCH") == len &&
			    bcmp(s + 2, "MACHINE_ARCH", len) == 0)
				var = machinearch ? machinearch : machine;
			else if (strlen("MACHINE") == len &&
			    bcmp(s + 2, "MACHINE", len) == 0)
				var = machine;
			else
				error("variable %*.*s not supported",
				    e - s - 2, e - s - 2, s + 2);

			asprintf(&expand, "%*.*s%s%s",
			    s - nv->nv_name, s - nv->nv_name, nv->nv_name,
			    var, e + 1);
			source = sourcepath(expand);
		} else
			source = sourcepath(nv->nv_name);
d212 1
a212 1
			/* poolalloc() prevents freeing old nv_name */
d217 1
a217 2
		if (expand)
			free(expand);
d224 2
a225 2
	 * Now that we know which path is right, delete all the
	 * other filenames to skip the access() checks next time
@


1.24
log
@discard still-born support for .o files in the "file" command..
this is OpenBSD.. source for everyone..
@
text
@d153 1
d155 1
a156 1
	char *source;
d167 1
a169 1
			char *expand;
a193 1
			free(expand);
d196 4
a199 1
		if (access(source, R_OK) == 0)
d201 3
@


1.23
log
@correct pathname variable matching, and also support ${MACHINE}
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.22 2007/11/25 08:26:29 deraadt Exp $	*/
a152 2
#if 1
	/* Always have source, don't support object dirs for kernel builds. */
a216 13

#else
	static char buf[MAXPATHLEN];

	if (have_source || (fi->fi_flags & FI_ALWAYSSRC) != 0)
		return (fi->fi_path);
	if (objpath == NULL) {
		error("obj-directory not set");
		return (NULL);
	}
	(void)snprintf(buf, sizeof buf, "%s/%s.o", objpath, fi->fi_base);
	return (buf);
#endif
@


1.22
log
@Extend the "file" directive to accept multiple pathnames seperated by '|'.
If more than one path is provided, access() them to choose which one should
be used, while parsing for ${name} expansions... currently limited to
MACHINE_ARCH
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.21 2006/12/06 05:05:16 ray Exp $	*/
d156 1
d171 1
d179 9
a187 2
			if (strncmp(s + 2, "MACHINE_ARCH",
			    strlen("MACHINE_ARCH")) != 0)
d190 1
d193 1
a193 1
			    machinearch ? machinearch : machine, e + 1);
@


1.21
log
@Don't access buf[strlen(buf) - 1] for zero-length strings.

OK jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.20 2006/05/06 11:31:46 espie Exp $	*/
d155 55
a209 1
	return (fi->fi_path);
@


1.20
log
@lint can't do assembly files, put them directly in OBJS.
okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.19 2006/04/27 18:09:52 espie Exp $	*/
d394 4
@


1.19
log
@lint(1) support in config:
- LINTS variables to hold the list of *.ln files.
- OBJS derives from it, since it can contain more files.
- add set of explicit rules for each .ln file.
- add a lint-with keyword that duplicates compile-with functionality
to special-case linting instead of compilation.

Full linting is dependent on LINT_* macros in the arch dependent template
files.

As is, doesn't break normal build. Just creates larger Makefiles.

Review/ok miod@@, cloder@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.18 2006/04/08 02:22:54 krw Exp $	*/
d223 1
d232 5
d252 20
@


1.18
log
@Whack some obviously dead code (double return's, code after goto).

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.17 2005/12/05 04:32:21 drahn Exp $	*/
d224 1
a224 1
	if (fputs("OBJS=", fp) < 0)
d231 1
a231 1
		len = strlen(fi->fi_base) + 2;
d238 1
a238 1
		if (fprintf(fp, "%c%s.o", sp, fi->fi_base) < 0)
d243 3
d351 1
a351 1
emitrules(FILE *fp)
d363 1
a363 1
		if (fprintf(fp, "%s.o: %s%s\n", fi->fi_base,
d366 2
a367 2
		if ((cp = fi->fi_mkrule) == NULL) {
			cp = "NORMAL";
d379 6
@


1.17
log
@Ignore case on the file extension, to allow both .s and .S to be included
in SFILES for mkdep. Would also pick up .C files (but we dont allow with those
in the kernel) ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.16 2004/01/04 18:30:05 deraadt Exp $	*/
a124 3
		/* (void)unlink("Makefile"); */
		free(ifname);
		return (1);
@


1.16
log
@knf and lint
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.15 2003/06/28 04:55:07 deraadt Exp $	*/
d288 1
d290 1
a290 1
	if (fprintf(fp, "%cFILES=", toupper(suffix)) < 0)
d300 1
a300 1
		if (fpath[len - 1] != suffix)
@


1.15
log
@ansi & prototype cleanup.  tested in mkr on most arch's.  ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.14 2003/06/02 23:36:52 millert Exp $	*/
d247 13
a259 13
	        if ((oi->oi_flags & OI_SEL) == 0)
	                continue;
	        len = strlen(oi->oi_path) + 3;
	        if (lpos + len > 72) {
	                if (fputs(" \\\n", fp) < 0)
	                        return (1);
	                sp = '\t';
	                lpos = 7;
	        }
	        if (fprintf(fp, "%c$S/%s", sp, oi->oi_path) < 0)
	                return (1);
	        lpos += len + 1;
	        sp = ' ';
d297 1
a297 1
                        return (1);
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.13 2003/05/23 22:16:40 tedu Exp $	*/
d69 1
a69 1
mkmakefile()
d154 1
a154 2
srcpath(fi)
	struct files *fi;
d174 1
a174 2
emitdefs(fp)
	FILE *fp;
d221 1
a221 2
emitobjs(fp)
	FILE *fp;
d267 1
a267 2
emitcfiles(fp)
	FILE *fp;
d274 1
a274 2
emitsfiles(fp)
	FILE *fp;
d281 1
a281 3
emitfiles(fp, suffix)
	FILE *fp;
	int suffix;
d350 1
a350 2
emitrules(fp)
	FILE *fp;
d386 1
a386 2
emitload(fp)
	FILE *fp;
@


1.13
log
@moved swapgeneric.c
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.12 2002/05/29 09:45:39 deraadt Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.11 2002/03/14 16:44:24 mpech Exp $	*/
d335 1
a335 2
				    "$S/arch/%s/%s/swapgeneric.c",
				    machine, machine);
d424 6
a429 6
		if (fprintf(fp, "\n\
\t${SYSTEM_LD_HEAD}\n\
\t${SYSTEM_LD} swap%s.o\n\
\t${SYSTEM_LD_TAIL}\n\
\n\
swap%s.o: ", swname, swname) < 0)
d435 1
a435 2
			if (fprintf(fp, "$S/arch/%s/%s/swapgeneric.c\n",
			    machine, machine) < 0)
@


1.11
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.10 2002/02/16 21:28:01 millert Exp $	*/
d81 2
a82 1
	(void)sprintf(buf, "arch/%s/conf/Makefile.%s", machine, machine);
d334 1
a334 1
				(void)sprintf(swapname,
d338 2
a339 2
				(void)sprintf(swapname, "./swap%s.c",
				    cf->cf_name);
d383 2
a384 1
			(void)sprintf(buf, "${%s_%c}", cp, ch);
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.9 2001/12/05 10:11:23 deraadt Exp $	*/
d75 4
a78 4
	register FILE *ifp, *ofp;
	register int lineno;
	register int (*fn)(FILE *);
	register char *ifname;
d158 1
a158 1
	register struct files *fi;
d179 1
a179 1
	register FILE *fp;
d181 2
a182 2
	register struct nvlist *nv;
	register char *sp;
d227 1
a227 1
	register FILE *fp;
d229 3
a231 3
	register struct files *fi;
	register struct objects *oi;
	register int lpos, len, sp;
d290 1
a290 1
	register FILE *fp;
d293 4
a296 4
	register struct files *fi;
	register struct config *cf;
	register int lpos, len, sp;
	register const char *fpath;
d362 1
a362 1
	register FILE *fp;
d364 2
a365 2
	register struct files *fi;
	register const char *cp, *fpath;
d398 1
a398 1
	register FILE *fp;
d400 2
a401 2
	register struct config *cf;
	register const char *nm, *swname;
@


1.9
log
@more free KNF from maja, though this was hard to do
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.8 2001/01/05 02:55:24 angelos Exp $	*/
d61 1
a61 1
static const char *srcpath __P((struct files *));
d63 2
a64 2
static int emitdefs __P((FILE *));
static int emitfiles __P((FILE *, int));
d66 5
a70 5
static int emitobjs __P((FILE *));
static int emitcfiles __P((FILE *));
static int emitsfiles __P((FILE *));
static int emitrules __P((FILE *));
static int emitload __P((FILE *));
d77 1
a77 1
	register int (*fn) __P((FILE *));
@


1.8
log
@Generate Makefiles that don't get confused if the source layout (with
regards to depth and symbolic links) is not what's expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.7 1997/11/13 08:21:55 deraadt Exp $	*/
d61 2
a62 2
static const char *srcpath __P((struct files *)); 
                        
@


1.7
log
@from mycroft;
Allow options and makeoptions to take an empty string as a value.
Add `object' and `library' keywords to pull in precompiled .o and .a files.
Syntax is like the `file' keyword; e.g.:
object  arch/i386/i386/mumble.o         [mumble] [needs-flag]
Largely from Michael Richardson in PR 3833, with some changes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.6 1997/07/06 03:54:06 downsj Exp $	*/
d201 2
a202 1
	if (*srcdir == '/' || *srcdir == '.') {
d205 6
a210 1
	} else {
d215 1
a215 1
		if (fprintf(fp, "S=\t./%s\n", srcdir) < 0)
d217 1
@


1.6
log
@Add defopt support, from NetBSD; thorpej (I think, I don't have the commit
message).
@
text
@d1 1
a1 1
/*	$OpenBSD: mkmakefile.c,v 1.5 1996/10/23 22:37:56 niklas Exp $	*/
d223 1
d244 15
@


1.5
log
@Merge of NetBSD 961020.  Includes flexible build/source dir specs
@
text
@d1 2
a2 2
/*	$OpenBSD: mkmakefile.c,v 1.4 1996/05/10 12:10:04 mickey Exp $	*/
/*	$NetBSD: mkmakefile.c,v 1.32 1996/09/23 05:04:23 ghudson Exp $	*/
d188 2
@


1.4
log
@do 'make links' treat swap*.o just as all the .o files.
@
text
@d1 2
a2 2
/*	$OpenBSD: mkmakefile.c,v 1.2 1996/03/25 15:55:09 niklas Exp $	*/
/*	$NetBSD: mkmakefile.c,v 1.29 1996/03/17 13:18:23 cgd Exp $	*/
d78 2
a79 2
	register char *ofname;
	char line[BUFSIZ], ifname[200];
d81 2
a82 1
	(void)sprintf(ifname, "Makefile.%s", machine);
d86 1
d89 4
a92 5
	ofname = path("Makefile");
	if ((ofp = fopen(ofname, "w")) == NULL) {
		(void)fprintf(stderr, "config: cannot write %s: %s\n",
		    ofname, strerror(errno));
		free(ofname);
d128 2
a129 2
		/* (void)unlink(ofname); */
		free(ofname);
d137 1
a137 1
	free(ofname);
d140 2
a141 2
	(void)fprintf(stderr, "config: error writing %s: %s\n",
	    ofname, strerror(errno));
d145 2
a146 2
	/* (void)unlink(ofname); */
	free(ofname);
d199 11
d353 1
a353 1
			cp = fi->fi_flags & FI_DRIVER ? "DRIVER" : "NORMAL";
d357 1
a357 2
			(void)sprintf(buf, "${%s_%c%s}", cp, ch,
			    fi->fi_flags & FI_CONFIGDEP ? "_C" : "");
@


1.3
log
@sync to netbsd 960418
@
text
@d300 1
a300 1
				(void)sprintf(swapname, "swap%s.c",
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mkmakefile.c,v 1.27 1996/03/03 17:28:26 thorpej Exp $	*/
d4 1
a4 1
/* 
d56 1
d61 2
d64 2
a68 1
static int emitfiles __P((FILE *, int));
d149 27
d259 1
d269 4
a272 2
		len = strlen(fi->fi_path);
		if (fi->fi_path[len - 1] != suffix)
d274 1
a274 1
		if (*fi->fi_path != '/')
d282 2
a283 2
		if (fprintf(fp, "%c%s%s", sp, *fi->fi_path != '/' ? "$S/" : "",
		    fi->fi_path) < 0)
d328 1
a328 1
	register const char *cp;
d335 2
d338 1
a338 1
		    *fi->fi_path != '/' ? "$S/" : "", fi->fi_path) < 0)
d342 1
a342 1
			ch = fi->fi_lastc;
@


1.1
log
@Initial revision
@
text
@d1 3
a45 1
 *	$Id: mkmakefile.c,v 1.25 1995/04/28 06:55:15 cgd Exp $
d199 1
a199 1
	if (lpos != 7 && putc('\n', fp) < 0)
d281 1
a281 1
	if (lpos != 7 && putc('\n', fp) < 0)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
