head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.28.0.8
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.4
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.23.0.20
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.18
	OPENBSD_5_0:1.23.0.16
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.14
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.12
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.8
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.6
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.10
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.8
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.6
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.14.0.8
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.6
	OPENBSD_2_8:1.14.0.4
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.6
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2016.10.16.09.35.40;	author tb;	state Exp;
branches;
next	1.28;
commitid	yfpiX98eJQunxUQe;

1.28
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2014.05.18.09.29.54;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.29.15.37.56;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.05.23.20.26;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2012.09.17.17.36.13;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.25.08.26.59;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.27.18.09.52;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.04.18.30.05;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.04.00.47.01;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.17.19.42.35;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.05.10.11.23;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.04.14.23.43;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	99.10.04.20.00.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.11.13.08.21.53;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.08.07.10.36.57;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.08.07.10.22.24;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.07.25.20.12.10;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.07.06.03.54.04;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.01.18.02.24.13;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.10.23.22.37.51;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.07.22.02.19;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.06.16.10.29.58;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.40.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Add printf format attributes to the custom error functions.

ok natano
@
text
@/*	$OpenBSD: config.h,v 1.28 2015/01/16 06:40:16 deraadt Exp $	*/
/*	$NetBSD: config.h,v 1.30 1997/02/02 21:12:30 thorpej Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)config.h	8.1 (Berkeley) 6/6/93
 */

/*
 * config.h:  Global definitions for "config"
 */

#include <sys/types.h>

#include <paths.h>
#include <stdlib.h>
#include <unistd.h>

/* These are really for MAKE_BOOTSTRAP but harmless. */
#ifndef __dead
#define __dead
#endif
#ifndef _PATH_DEVNULL
#define _PATH_DEVNULL "/dev/null"
#endif


/*
 * Name/value lists.  Values can be strings or pointers and/or can carry
 * integers.  The names can be NULL, resulting in simple value lists.
 */
struct nvlist {
	struct	nvlist *nv_next;
	const char *nv_name;
	union {
		const char *un_str;
		void *un_ptr;
	} nv_un;
#define	nv_str	nv_un.un_str
#define	nv_ptr	nv_un.un_ptr
	int	nv_int;
};

/*
 * Kernel configurations.
 */
struct config {
	struct	config *cf_next;	/* linked list */
	const char *cf_name;		/* "vmunix" */
	int	cf_lineno;		/* source line */
	struct	nvlist *cf_root;	/* "root on ra0a" */
	struct	nvlist *cf_swap;	/* "swap on ra0b and ra1b" */
	struct	nvlist *cf_dump;	/* "dumps on ra0b" */
};

/*
 * Attributes.  These come in two flavors: "plain" and "interface".
 * Plain attributes (e.g., "ether") simply serve to pull in files.
 * Interface attributes (e.g., "scsi") carry three lists: locators,
 * child devices, and references.  The locators are those things
 * that must be specified in order to configure a device instance
 * using this attribute (e.g., "tg0 at scsi0").  The a_devs field
 * lists child devices that can connect here (e.g., "tg"s), while
 * the a_refs are parents that carry the attribute (e.g., actual
 * SCSI host adapter drivers such as the SPARC "esp").
 */
struct attr {
	const char *a_name;		/* name of this attribute */
	int	a_iattr;		/* true => allows children */
	struct	nvlist *a_locs;		/* locators required */
	int	a_loclen;		/* length of above list */
	struct	nvlist *a_devs;		/* children */
	struct	nvlist *a_refs;		/* parents */
};

/*
 * The "base" part (struct devbase) of a device ("uba", "sd"; but not
 * "uba2" or "sd0").  It may be found "at" one or more attributes,
 * including "at root" (this is represented by a NULL attribute), as
 * specified by the device attachments (struct deva).
 *
 * Each device may also export attributes.  If any provide an output
 * interface (e.g., "esp" provides "scsi"), other devices (e.g.,
 * "tg"s) can be found at instances of this one (e.g., "esp"s).
 * Such a connection must provide locators as specified by that
 * interface attribute (e.g., "target").  The base device can
 * export both output (aka `interface') attributes, as well as
 * import input (`plain') attributes.  Device attachments may
 * only import input attributes; it makes no sense to have a
 * specific attachment export a new interface to other devices.
 *
 * Each base carries a list of instances (via d_ihead).  Note that this
 * list "skips over" aliases; those must be found through the instances
 * themselves.  Each base also carries a list of possible attachments,
 * each of which specify a set of devices that the device can attach
 * to, as well as the device instances that are actually using that
 * attachment.
 */
struct devbase {
	const char *d_name;		/* e.g., "sd" */
	struct	devbase *d_next;	/* linked list */
	int	d_isdef;		/* set once properly defined */
	int	d_ispseudo;		/* is a pseudo-device */
	int	d_major;		/* used for "root on sd0", e.g. */
	struct	nvlist *d_attrs;	/* attributes, if any */
	int	d_umax;			/* highest unit number + 1 */
	struct	devi *d_ihead;		/* first instance, if any */
	struct	devi **d_ipp;		/* used for tacking on more instances */
	struct	deva *d_ahead;		/* first attachment, if any */
	struct	deva **d_app;		/* used for tacking on attachments */
};

struct deva {
	const char *d_name;		/* name of attachment, e.g. "com_isa" */
	struct	deva *d_next;		/* linked list */
	struct	deva *d_bsame;		/* list on same base */
	int	d_isdef;		/* set once properly defined */
	struct	devbase *d_devbase;	/* the base device */
	struct	nvlist *d_atlist;	/* e.g., "at tg" (attr list) */
	struct	nvlist *d_attrs;	/* attributes, if any */
	struct	devi *d_ihead;		/* first instance, if any */
	struct	devi **d_ipp;		/* used for tacking on more instances */
};

/*
 * An "instance" of a device.  The same instance may be listed more
 * than once, e.g., "xx0 at isa? port FOO" + "xx0 at isa? port BAR".
 *
 * After everything has been read in and verified, the devi's are
 * "packed" to collect all the information needed to generate ioconf.c.
 * In particular, we try to collapse multiple aliases into a single entry.
 * We then assign each "primary" (non-collapsed) instance a cfdata index.
 * Note that there may still be aliases among these.
 */
struct devi {
	/* created while parsing config file */
	const char *i_name;	/* e.g., "sd0" */
	int	i_unit;		/* unit from name, e.g., 0 */
	int	i_disable;	/* device is disabled */
	struct	devbase *i_base;/* e.g., pointer to "sd" base */
	struct	devi *i_next;	/* list of all instances */
	struct	devi *i_bsame;	/* list on same base */
	struct	devi *i_asame;	/* list on same base attachment */
	struct	devi *i_alias;	/* other aliases of this instance */
	const char *i_at;	/* where this is "at" (NULL if at root) */
	struct	attr *i_atattr;	/* attr that allowed attach */
	struct	devbase *i_atdev;/* if "at <devname><unit>", else NULL */
	struct	deva *i_atdeva;
	const char **i_locs;	/* locators (as given by i_atattr) */
	int	i_atunit;	/* unit from "at" */
	int	i_cfflags;	/* flags from config line */
	int	i_lineno;	/* line # in config, for later errors */

	/* created during packing or ioconf.c generation */
/*		i_loclen	   via i_atattr->a_loclen */
	short	i_collapsed;	/* set => this alias no longer needed */
	short	i_cfindex;	/* our index in cfdata */
	short	i_pvlen;	/* number of parents */
	short	i_pvoff;	/* offset in parents.vec */
	short	i_locoff;	/* offset in locators.vec */
	struct	devi **i_parents;/* the parents themselves */
	int	i_locnami;	/* my index into locnami[] */
	int	i_plocnami;	/* parent's locnami[] index */
};
/* special units */
#define	STAR	(-1)		/* unit number for, e.g., "sd*" */
#define	WILD	(-2)		/* unit number for, e.g., "sd?" */

/*
 * Files.  Each file is either standard (always included) or optional,
 * depending on whether it has names on which to *be* optional.  The
 * options field (fi_optx) is actually an expression tree, with nodes
 * for OR, AND, and NOT, as well as atoms (words) representing some
 * particular option.  The node type is stored in the nv_int field.
 * Subexpressions appear in the `next' field; for the binary operators
 * AND and OR, the left subexpression is first stored in the nv_ptr field.
 *
 * For any file marked as needs-count or needs-flag, fixfiles() will
 * build fi_optf, a `flat list' of the options with nv_int fields that
 * contain counts or `need' flags; this is used in mkheaders().
 */
struct files {
	struct	files *fi_next;	/* linked list */
	const char *fi_srcfile;	/* the name of the "files" file that got us */
	u_short	fi_srcline;	/* and the line number */
	u_char	fi_flags;	/* as below */
	char	fi_lastc;	/* last char from path */
	struct nvlist *fi_nvpath; /* list of paths */
	const char *fi_base;	/* tail minus ".c" (or whatever) */
	struct  nvlist *fi_optx;/* options expression */
	struct  nvlist *fi_optf;/* flattened version of above, if needed */
	const char *fi_mkrule;/* special make rules, if any */
};

/*
 * Objects and libraries.  This allows precompiled object and library
 * files (e.g. binary-only device drivers) to be linked in.
 */
struct objects {
	struct  objects *oi_next;/* linked list */
	const char *oi_srcfile; /* the name of the "objects" file that got us */
	u_short oi_srcline;	/* and the line number */
	u_char  oi_flags;	/* as below */
	char    oi_lastc;	/* last char from path */
	const char *oi_path;    /* full object path */
	struct  nvlist *oi_optx;/* options expression */
	struct  nvlist *oi_optf;/* flattened version of above, if needed */
};

#define	OI_SEL		0x01	/* selected */
#define	OI_NEEDSFLAG	0x02	/* needs-flag */

#define	FX_ATOM		0	/* atom (in nv_name) */
#define	FX_NOT		1	/* NOT expr (subexpression in nv_next) */
#define	FX_AND		2	/* AND expr (lhs in nv_ptr, rhs in nv_next) */
#define	FX_OR		3	/* OR expr (lhs in nv_ptr, rhs in nv_next) */

/* flags */
#define	FI_SEL		0x01	/* selected */
#define	FI_NEEDSCOUNT	0x02	/* needs-count */
#define	FI_NEEDSFLAG	0x04	/* needs-flag */
#define	FI_HIDDEN	0x08	/* obscured by other(s), base names overlap */

/*
 * Hash tables look up name=value pairs.  The pointer value of the name
 * is assumed to be constant forever; this can be arranged by interning
 * the name.  (This is fairly convenient since our lexer does this for
 * all identifier-like strings---it has to save them anyway, lest yacc's
 * look-ahead wipe out the current one.)
 */
struct hashtab;

const char *conffile;		/* source file, e.g., "GENERIC.sparc" */
const char *machine;		/* machine type, e.g., "sparc" or "sun3" */
const char *machinearch;	/* machine arch, e.g., "sparc" or "m68k" */
const char *srcdir;		/* path to source directory (rel. to build) */
const char *builddir;		/* path to build directory */
const char *defbuilddir;	/* default build directory */
int	errors;			/* counts calls to error() */
int	minmaxusers;		/* minimum "maxusers" parameter */
int	defmaxusers;		/* default "maxusers" parameter */
int	maxmaxusers;		/* default "maxusers" parameter */
int	maxusers;		/* configuration's "maxusers" parameter */
int	maxpartitions;		/* configuration's "maxpartitions" parameter */
struct	nvlist *options;	/* options */
struct	nvlist *defoptions;	/* "defopt"'d options */
struct	nvlist *mkoptions;	/* makeoptions */
struct	hashtab *devbasetab;	/* devbase lookup */
struct	hashtab *devatab;	/* devbase attachment lookup */
struct	hashtab *selecttab;	/* selects things that are "optional foo" */
struct	hashtab *needcnttab;	/* retains names marked "needs-count" */
struct	hashtab *opttab;	/* table of configured options */
struct	hashtab *defopttab;	/* options that have been "defopt"'d */
struct	devbase *allbases;	/* list of all devbase structures */
struct	deva *alldevas;		/* list of all devbase attachment structures */
struct	config *allcf;		/* list of configured kernels */
struct	devi *alldevi;		/* list of all instances */
struct	devi *allpseudo;	/* list of all pseudo-devices */
int	ndevi;			/* number of devi's (before packing) */
int	npseudo;		/* number of pseudo's */

struct	files *allfiles;	/* list of all kernel source files */
struct objects *allobjects;	/* list of all kernel object and library files */

struct	devi **packed;		/* arrayified table for packed devi's */
int	npacked;		/* size of packed table, <= ndevi */

struct {			/* pv[] table for config */
	short	*vec;
	int	used;
} parents;
struct {			/* loc[] table for config */
	const char **vec;
	int	used;
} locators;

/* files.c */
void	initfiles(void);
void	checkfiles(void);
int	fixfiles(void);		/* finalize */
int	fixobjects(void);
void	addfile(struct nvlist *, struct nvlist *, int, const char *);
void	addobject(const char *, struct nvlist *, int);

/* hash.c */
struct	hashtab *ht_new(void);
int	ht_insrep(struct hashtab *, const char *, void *, int);
int	ht_remove(struct hashtab *, const char *);
#define	ht_insert(ht, nam, val) ht_insrep(ht, nam, val, 0)
#define	ht_replace(ht, nam, val) ht_insrep(ht, nam, val, 1)
void	*ht_lookup(struct hashtab *, const char *);
void	initintern(void);
const char *intern(const char *);

/* main.c */
void	addoption(const char *name, const char *value);
void	removeoption(const char *name);
void	addmkoption(const char *name, const char *value);
void	defoption(const char *name);
int	devbase_has_instances(struct devbase *, int);
int	deva_has_instances(struct deva *, int);
void	setupdirs(void);
int	pflag;
char 	*sflag;
char	*bflag;
char	*startdir;

/* mkheaders.c */
int	mkheaders(void);

/* mkioconf.c */
int	mkioconf(void);

/* mkmakefile.c */
int	mkmakefile(void);

/* mkswap.c */
int	mkswap(void);

/* pack.c */
void	pack(void);

/* scan.l */
int	currentline(void);
int	firstfile(const char *);
int	include(const char *, int);

/* sem.c, other than for yacc actions */
void	initsem(void);

/* util.c */
void	*emalloc(size_t);
void	*ereallocarray(void *, size_t, size_t);
void	*ecalloc(size_t, size_t);
char	*sourcepath(const char *);
void	error(const char *, ...)			/* immediate errs */
		__attribute__((__format__ (printf, 1, 2)));
void	xerror(const char *, int, const char *, ...)	/* delayed errs */
		__attribute__((__format__ (printf, 3, 4)));
__dead void panic(const char *, ...)
		__attribute__((__format__ (printf, 1, 2)));
struct nvlist *newnv(const char *, const char *, void *, int, struct nvlist *);
void	nvfree(struct nvlist *);
void	nvfreel(struct nvlist *);

int	ukc(char *, char *, int, int);
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.27 2014/05/18 09:29:54 espie Exp $	*/
d371 6
a376 3
void	error(const char *, ...);			/* immediate errs */
void	xerror(const char *, int, const char *, ...);	/* delayed errs */
__dead void panic(const char *, ...);
@


1.27
log
@use reallocarray and friends. okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.26 2013/10/29 15:37:56 espie Exp $	*/
a48 1
#include <sys/param.h>
a49 1
#if !defined(MAKE_BOOTSTRAP) && defined(BSD)
a50 2
#endif /* ...BSD */

@


1.26
log
@emit an extra "config" convenience target that allows one
to rerun config without changing directories.

Lots of inputs by deraadt@@, who wanted it to work for movable
relative directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.25 2012/12/05 23:20:26 deraadt Exp $	*/
d372 2
a373 1
void	*erealloc(void *, size_t);
@


1.25
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.24 2012/09/17 17:36:13 espie Exp $	*/
d342 4
@


1.24
log
@tedu lint tendrils through config internals.
also mark some known targets as .PHONY

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.23 2007/11/25 08:26:59 deraadt Exp $	*/
a51 1
#include <sys/cdefs.h>
@


1.23
log
@Extend the "file" directive to accept multiple pathnames seperated by '|'.
If more than one path is provided, access() them to choose which one should
be used, while parsing for ${name} expansions... currently limited to
MACHINE_ARCH
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.22 2006/04/27 18:09:52 espie Exp $	*/
d232 1
a232 1
	const char *fi_mkrule[2];/* special make rules, if any */
d322 1
a322 1
void	addfile(struct nvlist *, struct nvlist *, int, const char *, const char *);
@


1.22
log
@lint(1) support in config:
- LINTS variables to hold the list of *.ln files.
- OBJS derives from it, since it can contain more files.
- add set of explicit rules for each .ln file.
- add a lint-with keyword that duplicates compile-with functionality
to special-case linting instead of compilation.

Full linting is dependent on LINT_* macros in the arch dependent template
files.

As is, doesn't break normal build. Just creates larger Makefiles.

Review/ok miod@@, cloder@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.21 2004/01/04 18:30:05 deraadt Exp $	*/
d228 1
a228 2
	const char *fi_path;	/* full file path */
	const char *fi_tail;	/* name, i.e., strrchr(fi_path, '/') + 1 */
d322 1
a322 1
void	addfile(const char *, struct nvlist *, int, const char *, const char *);
@


1.21
log
@knf and lint
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.20 2004/01/04 00:47:01 deraadt Exp $	*/
d233 1
a233 1
	const char *fi_mkrule;	/* special make rule, if any */
d323 1
a323 1
void	addfile(const char *, struct nvlist *, int, const char *);
@


1.20
log
@Wall and spacing, I am hunting bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.19 2003/06/02 23:36:52 millert Exp $	*/
d243 3
a245 3
	u_short oi_srcline;     /* and the line number */
	u_char  oi_flags;       /* as below */
	char    oi_lastc;       /* last char from path */
d329 1
a329 1
int     ht_remove(struct hashtab *, const char *);
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.18 2002/02/19 19:39:40 millert Exp $	*/
d195 1
a195 1
/* 		i_loclen	   via i_atattr->a_loclen */
@


1.18
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.17 2002/02/17 19:42:35 millert Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.16 2002/02/16 21:28:01 millert Exp $	*/
a59 1
#ifdef __STDC__
a61 1
#endif
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.15 2001/12/05 10:11:23 deraadt Exp $	*/
a57 6
#else /* ...BSD */
#if defined(__STDC__) || defined(__cplusplus)
#define	__P(protos)	protos		/* full-blown ANSI C */
#else /* ...STDC */
#define	__P(protos)	()		/* traditional C preprocessor */
#endif /* ...STDC */
d381 1
a381 2
struct nvlist *newnv __P((const char *, const char *, void *, int,
	    struct nvlist *));
@


1.15
log
@more free KNF from maja, though this was hard to do
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.14 2000/01/04 14:23:43 angelos Exp $	*/
d331 6
a336 6
void	initfiles __P((void));
void	checkfiles __P((void));
int	fixfiles __P((void));	/* finalize */
int	fixobjects __P((void));
void	addfile __P((const char *, struct nvlist *, int, const char *));
void	addobject __P((const char *, struct nvlist *, int));
d339 3
a341 3
struct	hashtab *ht_new __P((void));
int	ht_insrep __P((struct hashtab *, const char *, void *, int));
int     ht_remove __P((struct hashtab *, const char *));
d344 3
a346 3
void	*ht_lookup __P((struct hashtab *, const char *));
void	initintern __P((void));
const char *intern __P((const char *));
d349 7
a355 7
void	addoption __P((const char *name, const char *value));
void	removeoption __P((const char *name));
void	addmkoption __P((const char *name, const char *value));
void	defoption __P((const char *name));
int	devbase_has_instances __P((struct devbase *, int));
int	deva_has_instances __P((struct deva *, int));
void	setupdirs __P((void));
d358 1
a358 1
int	mkheaders __P((void));
d361 1
a361 1
int	mkioconf __P((void));
d364 1
a364 1
int	mkmakefile __P((void));
d367 1
a367 1
int	mkswap __P((void));
d370 1
a370 1
void	pack __P((void));
d373 3
a375 3
int	currentline __P((void));
int	firstfile __P((const char *));
int	include __P((const char *, int));
d378 1
a378 1
void	initsem __P((void));
d381 6
a386 6
void	*emalloc __P((size_t));
void	*erealloc __P((void *, size_t));
char	*sourcepath __P((const char *));
void	error __P((const char *, ...));			/* immediate errs */
void	xerror __P((const char *, int, const char *, ...)); /* delayed errs */
__dead void panic __P((const char *, ...));
d389 2
a390 2
void	nvfree __P((struct nvlist *));
void	nvfreel __P((struct nvlist *));
d392 1
a392 1
int	ukc __P((char *, char *, int, int));
@


1.14
log
@Add rmoption/rmoptions; useful for people who want a slightly
modified version of GENERIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.13 1999/10/04 20:00:50 deraadt Exp $	*/
d62 1
a62 1
#define	__P(protos)	()		/* traditional C preprocessor */    
d225 1
a225 1
 * for OR, AND, and NOT, as well as atoms (words) representing some   
d229 1
a229 1
 * 
@


1.13
log
@config -e support; ukc from maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.12 1997/11/13 08:21:53 deraadt Exp $	*/
d341 1
d350 1
@


1.12
log
@from mycroft;
Allow options and makeoptions to take an empty string as a value.
Add `object' and `library' keywords to pull in precompiled .o and .a files.
Syntax is like the `file' keyword; e.g.:
object  arch/i386/i386/mumble.o         [mumble] [needs-flag]
Largely from Michael Richardson in PR 3833, with some changes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.11 1997/08/07 10:36:57 deraadt Exp $	*/
d389 2
@


1.11
log
@jason is tired.  this is not needed. our locator table stuff uses less
memory too.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.9 1997/07/25 20:12:10 mickey Exp $	*/
d247 19
d316 1
d334 1
d336 1
d372 1
@


1.10
log
@cf_locnames support, from NetBSD (jtk, according to the RCSids).
@
text
@d2 1
a2 1
/*	$NetBSD: config.h,v 1.31 1997/03/14 00:14:09 jtk Exp $	*/
a287 2
struct	hashtab *attrtab;	/* attributes (locators, etc.) */

a323 2
typedef int (*ht_callback) __P((const char *, void *, void *));
int	ht_enumerate __P((struct hashtab *, ht_callback, void *));
@


1.9
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 2
a2 2
/*	$OpenBSD: config.h,v 1.8 1997/07/06 03:54:04 downsj Exp $	*/
/*	$NetBSD: config.h,v 1.30 1997/02/02 21:12:30 thorpej Exp $	*/
d288 2
d326 2
@


1.8
log
@Add defopt support, from NetBSD; thorpej (I think, I don't have the commit
message).
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.7 1997/01/18 02:24:13 briggs Exp $	*/
d66 1
a66 1
#if __STDC__
@


1.7
log
@Sync. with current NetBSD--keeping local changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: config.h,v 1.6 1996/10/23 22:37:51 niklas Exp $	*/
/*	$NetBSD: config.h,v 1.28 1996/11/11 23:40:09 gwr Exp $	*/
d280 1
d286 2
a287 1

d328 1
@


1.6
log
@Merge of NetBSD 961020.  Includes flexible build/source dir specs
@
text
@d1 2
a2 2
/*	$OpenBSD: config.h,v 1.5 1996/07/07 22:02:19 maja Exp $	*/
/*	$NetBSD: config.h,v 1.26 1996/08/31 21:15:05 mycroft Exp $	*/
d49 32
d241 1
a241 1
	const char *fi_tail;	/* name, i.e., rindex(fi_path, '/') + 1 */
d328 1
d347 1
@


1.5
log
@Add support for allowing disabled devices in a config file. e.g.
ep0 at isa? disable port ? irq ?
disable must be placed before any attribute for the device. /moj
@
text
@d1 2
a2 2
/*	$OpenBSD: config.h,v 1.4 1996/06/16 10:29:58 deraadt Exp $	*/
/*	$NetBSD: config.h,v 1.23 1996/03/17 13:18:15 cgd Exp $	*/
a139 1
	struct	nvlist *d_vectors;	/* interrupt vectors, if any */
a180 1
	short	i_ivoff;	/* offset in interrupt vectors, if any */
d222 3
a224 5
#define	FI_CONFIGDEP	0x02	/* config-dependent */
#define	FI_DRIVER	0x04	/* device-driver */
#define	FI_NEEDSCOUNT	0x08	/* needs-count */
#define	FI_NEEDSFLAG	0x10	/* needs-flag */
#define	FI_HIDDEN	0x20	/* obscured by other(s), base names overlap */
a235 1
const char *confdirbase;	/* basename of compile directory, usu. same */
d238 3
d321 1
a321 1
char	*path __P((const char *));
@


1.4
log
@provide locator names to kernel (update your config(8) binary!)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.h,v 1.2 1996/03/25 15:55:02 niklas Exp $	*/
d160 1
@


1.3
log
@sync to netbsd 960418
@
text
@d183 2
a184 1

@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: config.h,v 1.19 1996/03/03 17:28:08 thorpej Exp $	*/
d97 4
a100 3
 * The "base" part of a device ("uba", "sd"; but not "uba2" or
 * "sd0").  It may be found "at" one or more attributes, including
 * "at root" (this is represented by a NULL attribute).
d106 5
a110 1
 * interface attribute (e.g., "target").
d114 4
a117 1
 * themselves.
d125 14
a143 1
	int	d_umax;			/* highest unit number + 1 */
d163 1
d167 2
a168 1
	struct	devbase *i_atdev;/* dev if "at <devname><unit>", else NULL */
d191 10
a200 1
 * depending on whether it has names on which to *be* optional.
d211 2
a212 1
	struct	nvlist *fi_opt;	/* optional on ... */
d215 4
d250 1
d255 1
d294 2
d325 2
a326 1
struct nvlist *newnv __P((const char *, const char *, void *, int));
@


1.1
log
@Initial revision
@
text
@d1 3
a45 1
 *	$Id: config.h,v 1.18 1995/04/28 06:55:01 cgd Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
