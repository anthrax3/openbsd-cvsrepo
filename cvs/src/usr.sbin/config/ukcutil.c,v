head	1.23;
access;
symbols
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.18
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.10
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.14
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.12
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.8
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.6
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.4
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.14.0.18
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.16
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.14
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.12
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.10
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2017.09.27.15.14.52;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	l9afTFePGBozxTKI;

1.22
date	2016.10.27.14.32.10;	author tb;	state Exp;
branches;
next	1.21;
commitid	ydSgDaGzBtYbCKGC;

1.21
date	2015.09.21.14.45.14;	author guenther;	state Exp;
branches;
next	1.20;
commitid	gCISBV4IZwfk20hM;

1.20
date	2011.10.02.22.20.50;	author edd;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.24.21.35.03;	author maja;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.23.15.00.29;	author maja;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.08.01.23.16;	author simon;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.04.18.30.05;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.21.19.03;	author maja;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.06.21.10.20;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.14.02.59.41;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.02.12.59.54;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.23.13.30.24;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.10.23.15.34;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.05.10.11.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.04.20.42.12;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.31.22.41.32;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.15.23.53.34;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.08.21.42.40;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.08.23.23.37;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.10.04.20.00.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@config -e's adds new devices to an extra locator array, which is accounted
using a variable which started at 0 and hence got planted in .bss.
Refactor that variable to begin at the maximum and decrease, such that it
lands in .data instead.
ok jsg
@
text
@/*	$OpenBSD: ukcutil.c,v 1.22 2016/10/27 14:32:10 tb Exp $ */

/*
 * Copyright (c) 1999-2001 Mats O Jansson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/device.h>

#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <nlist.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "cmd.h"
#include "exec.h"
#include "ukc.h"
#include "misc.h"

extern	int ukc_mod_kernel;

struct	cfdata *
get_cfdata(int idx)
{
	return((struct cfdata *)(adjust((caddr_t)nl[P_CFDATA].n_value) +
	    idx * sizeof(struct cfdata)));
}

short *
get_locnamp(int idx)
{
	return((short *)(adjust((caddr_t)nl[S_LOCNAMP].n_value) +
	    idx * sizeof(short)));
}

static caddr_t *
get_locnames(int idx)
{
	return((caddr_t *)(adjust((caddr_t)nl[P_LOCNAMES].n_value) +
	    idx * sizeof(caddr_t)));
}

static long *
get_extraloc(int nslots)
{
	long *extralocp, *locp;
	int *rextralocp, *textralocp;

	extralocp = (long *)adjust((caddr_t)nl[IA_EXTRALOC].n_value);
	rextralocp = (int *)adjust((caddr_t)nl[I_REXTRALOC].n_value);
	textralocp = (int *)adjust((caddr_t)nl[I_TEXTRALOC].n_value);
	if (*rextralocp < nslots)
		return (NULL);

	locp = &extralocp[*textralocp - *rextralocp];
	*rextralocp -= nslots;
	return locp;
}

static char *
get_pdevnames(int idx)
{
	caddr_t *p;

	p = (caddr_t *)adjust((caddr_t)nl[P_PDEVNAMES].n_value +
	    idx * sizeof(caddr_t));
	return(char *)adjust((caddr_t)*p);

}

static struct pdevinit *
get_pdevinit(int idx)
{
	return((struct pdevinit *)(adjust((caddr_t)nl[S_PDEVINIT].n_value) +
	    idx * sizeof(struct pdevinit)));
}

int
more(void)
{
	int quit = 0;
	cmd_t cmd;

	if (cnt != -1) {
		if (cnt > 0 && cnt == lines) {
			printf("--- more ---");
			fflush(stdout);
			ask_cmd(&cmd);
			cnt = 0;
			if (cmd.cmd[0] == 'q' || cmd.cmd[0] == 'Q')
				quit = 1;
		}
		cnt++;
	}
	return (quit);
}

static void
pnum(long val)
{
	if (val > -2 && val < 16) {
		printf("%ld", val);
		return;
	}

	switch (base) {
	case 8:
		printf("0%lo", val);
		break;
	case 10:
		printf("%ld", val);
		break;
	case 16:
	default:
		printf("0x%lx", val);
		break;
	}
}

static void
pdevnam(short devno)
{
	struct cfdata *cd;
	struct cfdriver *cdrv;

	cd = get_cfdata(devno);

	cdrv = (struct cfdriver *)adjust((caddr_t)cd->cf_driver);
	printf("%s", adjust((caddr_t)cdrv->cd_name));

	switch (cd->cf_fstate) {
	case FSTATE_NOTFOUND:
	case FSTATE_DNOTFOUND:
		printf("%d", cd->cf_unit);
		break;
	case FSTATE_FOUND:
		printf("*FOUND*");
		break;
	case FSTATE_STAR:
	case FSTATE_DSTAR:
		printf("*");
		break;
	default:
		printf("*UNKNOWN*");
		break;
	}
}

void
pdev(short devno)
{
	struct pdevinit *pi;
	struct cfdata *cd;
	short	*s, *ln;
	long	*i;
	caddr_t	*p;
	char	c;

	if (nopdev == 0) {
		if (devno > maxdev && devno <= totdev) {
			printf("%3d free slot (for add)\n", devno);
			return;
		}
		if (devno > totdev && devno <= totdev + maxpseudo) {
			pi = get_pdevinit(devno - totdev -1);
			printf("%3d %s count %d", devno,
			    get_pdevnames(devno - totdev - 1),
			    abs(pi->pdev_count));
			if (pi->pdev_count < 0)
				printf(" disable");
			printf(" (pseudo device)\n");
			return;
		}
	}

	if (devno > maxdev) {
		printf("Unknown devno (max is %d)\n", maxdev);
		return;
	}

	cd = get_cfdata(devno);

	printf("%3d ", devno);
	pdevnam(devno);
	printf(" at");

	c = ' ';
	s = (short *)adjust((caddr_t)cd->cf_parents);
	if (*s == -1)
		printf(" root");
	while (*s != -1) {
		printf("%c", c);
		pdevnam(*s);
		c = '|';
		s++;
	}
	switch (cd->cf_fstate) {
	case FSTATE_NOTFOUND:
	case FSTATE_FOUND:
	case FSTATE_STAR:
		break;
	case FSTATE_DNOTFOUND:
	case FSTATE_DSTAR:
		printf(" disable");
		break;
	default:
		printf(" ???");
		break;
	}

	i = (long *)adjust((caddr_t)cd->cf_loc);
	ln = get_locnamp(cd->cf_locnames);
	while (*ln != -1) {
		p = get_locnames(*ln);
		printf(" %s ", adjust((caddr_t)*p));
		ln++;
		pnum(*i);
		i++;
	}
	printf(" flags 0x%x\n", cd->cf_flags);
}

static int
numberl(const char *c, long *val)
{
	char *ep;

	errno = 0;
	*val = strtol(c, &ep, 0);
	if (*c == '\0' || (!isspace((unsigned char)*ep) && *ep != '\0') ||
	    (errno == ERANGE && (*val == LONG_MAX || *val == LONG_MIN)))
		return (-1);
	return (0);
}

int
number(const char *c, int *val)
{
	long v;
	int ret = numberl(c, &v);

	if (ret == 0) {
		if (v <= INT_MAX && v >= INT_MIN)
			*val = (int)v;
		else
			ret = -1;
	}
	return (ret);
}

int
device(char *cmd, int *len, short *unit, short *state)
{
	short u = 0, s = FSTATE_FOUND;
	int l = 0;
	char *c;

	c = cmd;
	while (*c >= 'a' && *c <= 'z') {
		l++;
		c++;
	}

	if (*c == '*') {
		s = FSTATE_STAR;
		c++;
	} else {
		while (*c >= '0' && *c <= '9') {
			s = FSTATE_NOTFOUND;
			u = u*10 + *c - '0';
			c++;
		}
	}
	while (*c == ' ' || *c == '\t' || *c == '\n')
		c++;

	if (*c == '\0') {
		*len = l;
		*unit = u;
		*state = s;
		return(0);
	}
	return(-1);
}

int
attr(char *cmd, int *val)
{
	short attr = -1, i = 0, l = 0;
	caddr_t *p;
	char *c;

	c = cmd;
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\0') {
		c++;
		l++;
	}

	p = get_locnames(0);

	while (i <= maxlocnames) {
		if (strlen((char *)adjust((caddr_t)*p)) == l) {
			if (strncasecmp(cmd, adjust((caddr_t)*p), l) == 0)
				attr = i;
		}
		p++;
		i++;
	}
	if (attr == -1)
		return (-1);

	*val = attr;
	return(0);
}

static int
modifyl(char *item, long *val)
{
	cmd_t cmd;
	long a;

	ukc_mod_kernel = 1;
	while (1) {
		printf("%s [", item);
		pnum(*val);
		printf("] ? ");
		fflush(stdout);

		ask_cmd(&cmd);

		if (strlen(cmd.cmd) != 0) {
			if (strlen(cmd.args) == 0) {
				if (numberl(cmd.cmd, &a) == 0) {
					*val = a;
					return (1);
				} else
					printf("Unknown argument\n");
			} else
				printf("Too many arguments\n");
		} else
			return (0);
	}
}

void
modify(char *item, int *val)
{
	long a = *val;

	while (modifyl(item, &a)) {
		if (a <= INT_MAX && a >= INT_MIN) {
			*val = (int)a;
			break;
		}
		printf("Out of range argument\n");
	}
}

void
change(int devno)
{
	int	i, share = 0;
	long	*j = NULL, *l = NULL;
	struct cfdata *cd, *c;
	struct pdevinit *pi;
	short	*ln, *lk;
	caddr_t	*p;

	ukc_mod_kernel = 1;
	if (devno <=  maxdev) {
		pdev(devno);
		if (!ask_yn("change"))
			return;

		cd = get_cfdata(devno);

		/*
		 * Search for some other driver sharing this
		 * locator table. if one does, we may need to
		 * replace the locators with a new copy.
		 */
		c = get_cfdata(0);
		for (i = 0; c->cf_driver; i++) {
			if (i != devno && c->cf_loc == cd->cf_loc)
				share = 1;
			c++;
		}

		ln = get_locnamp(cd->cf_locnames);
		l = (long *)adjust((caddr_t)cd->cf_loc);

		if (share) {
			if (oldkernel) {
				printf("Can't do that on this kernel\n");
				return;
			}

			lk = ln;
			i = 0;
			while (*lk != -1) {
				lk++;
				i++;
			}
			lk = ln;

			j = l = get_extraloc(i);
			if (l == NULL) {
				printf("Not enough space to change device.\n");
				return;
			}
			if (i)
				bcopy(adjust((caddr_t)cd->cf_loc), l,
				    sizeof(long) * i);
		}

		while (*ln != -1) {
			p = get_locnames(*ln);
			modifyl((char *)adjust(*p), l);
			ln++;
			l++;
		}
		modify("flags", &cd->cf_flags);

		if (share) {
			if (bcmp(adjust((caddr_t)cd->cf_loc),
			    j, sizeof(long) * i)) {
				cd->cf_loc = (long *)readjust((caddr_t)j);
			}
		}

		printf("%3d ", devno);
		pdevnam(devno);
		printf(" changed\n");
		pdev(devno);
		return;
	}

	if (nopdev == 0) {
		if (devno > maxdev && devno <= totdev) {
			printf("%3d can't change free slot\n", devno);
			return;
		}

		if (devno > totdev && devno <= totdev + maxpseudo) {
			pdev(devno);
			if (ask_yn("change")) {
				pi = get_pdevinit(devno-totdev-1);
				modify("count", &pi->pdev_count);
				printf("%3d %s changed\n", devno,
				    get_pdevnames(devno - totdev - 1));
				pdev(devno);
			}
			return;
		}
	}

	printf("Unknown devno (max is %d)\n", totdev+maxpseudo);
}

void
change_history(int devno, char *str)
{
	int	i, share = 0;
	long	*j = NULL, *l = NULL;
	struct cfdata *cd, *c;
	struct pdevinit *pi;
	short	*ln, *lk;

	ukc_mod_kernel = 1;

	if (devno <= maxdev) {

		pdev(devno);
		cd = get_cfdata(devno);

		/*
		 * Search for some other driver sharing this
		 * locator table. if one does, we may need to
		 * replace the locators with a new copy.
		 */
		c = get_cfdata(0);
		for (i = 0; c->cf_driver; i++) {
			if (i != devno && c->cf_loc == cd->cf_loc)
				share = 1;
			c++;
		}

		ln = get_locnamp(cd->cf_locnames);
		l = (long *)adjust((caddr_t)cd->cf_loc);

		if (share) {
			if (oldkernel) {
				printf("Can't do that on this kernel\n");
				return;
			}

			lk = ln;
			i = 0;
			while (*lk != -1) {
				lk++;
				i++;
			}
			lk = ln;

			j = l = get_extraloc(i);
			if (l == NULL) {
				printf("Not enough space to change device.\n");
				return;
			}
			if (i)
				bcopy(adjust((caddr_t)cd->cf_loc), l,
				    sizeof(long) * i);
		}

		while (*ln != -1) {
			*l = atoi(str);
			if (*str == '-')
				str++;
			while (*str >= '0' && *str <= '9')
				str++;
			if (*str == ' ')
				str++;
			ln++;
			l++;
		}

		if (*str) {
			cd->cf_flags = atoi(str);
			if (*str == '-')
				str++;
			while (*str >= '0' && *str <= '9')
				str++;
			if (*str == ' ')
				str++;
		}

		if (share) {
			if (bcmp(adjust((caddr_t)cd->cf_loc),
			    j, sizeof(long) * i)) {
				cd->cf_loc = (long *)readjust((caddr_t)j);
			}
		}

		printf("%3d ", devno);
		pdevnam(devno);
		printf(" changed\n");
		pdev(devno);
		return;
	}

	if (nopdev == 0) {
		if (devno > maxdev && devno <= totdev) {
			printf("%3d can't change free slot\n", devno);
			return;
		}
		if (devno > totdev && devno <= totdev + maxpseudo) {
			pdev(devno);
			pi = get_pdevinit(devno-totdev-1);

			if (*str) {
				pi->pdev_count = atoi(str);
				if (*str == '-')
					str++;
				while (*str >= '0' && *str <= '9')
					str++;
				if (*str == ' ')
					str++;
			}

			printf("%3d %s changed\n", devno,
			    get_pdevnames(devno - totdev - 1));
			pdev(devno);
			return;
		}
	}

	printf("Unknown devno (max is %d)\n", totdev + maxpseudo);
}

void
disable(int devno)
{
	struct cfdata *cd;
	struct pdevinit *pi;
	int done = 0;

	if (devno <= maxdev) {

		cd = get_cfdata(devno);

		switch (cd->cf_fstate) {
		case FSTATE_NOTFOUND:
			cd->cf_fstate = FSTATE_DNOTFOUND;
			break;
		case FSTATE_STAR:
			cd->cf_fstate = FSTATE_DSTAR;
			break;
		case FSTATE_DNOTFOUND:
		case FSTATE_DSTAR:
			done = 1;
			break;
		default:
			printf("Error unknown state\n");
			break;
		}

		printf("%3d ", devno);
		pdevnam(devno);
		if (done) {
			printf(" already");
		} else {
			ukc_mod_kernel = 1;
		}
		printf(" disabled\n");

		return;
	}

	if (nopdev == 0) {
		if (devno > maxdev && devno <= totdev) {
			printf("%3d can't disable free slot\n", devno);
			return;
		}
		if (devno > totdev && devno <= totdev + maxpseudo) {
			pi = get_pdevinit(devno-totdev-1);

			printf("%3d %s", devno,
				get_pdevnames(devno - totdev - 1));
			if (pi->pdev_count < 1) {
				printf(" already");
			} else {
				ukc_mod_kernel = 1;
				pi->pdev_count*=-1;
			}
			printf(" disabled\n");
			return;
		}
	}

	printf("Unknown devno (max is %d)\n", totdev+maxpseudo);

}

void
enable(int devno)
{
	struct cfdata *cd;
	struct pdevinit *pi;
	int done = 0;

	if (devno <= maxdev) {
		cd = get_cfdata(devno);

		switch (cd->cf_fstate) {
		case FSTATE_DNOTFOUND:
			cd->cf_fstate = FSTATE_NOTFOUND;
			break;
		case FSTATE_DSTAR:
			cd->cf_fstate = FSTATE_STAR;
			break;
		case FSTATE_NOTFOUND:
		case FSTATE_STAR:
			done = 1;
			break;
		default:
			printf("Error unknown state\n");
			break;
		}

		printf("%3d ", devno);
		pdevnam(devno);
		if (done) {
			printf(" already");
		} else {
			ukc_mod_kernel = 1;
		}
		printf(" enabled\n");

		return;
	}

	if (nopdev == 0) {
		if (devno > maxdev && devno <= totdev) {
			printf("%3d can't enable free slot\n", devno);
			return;
		}
		if (devno > totdev && devno <= totdev + maxpseudo) {
			pi = get_pdevinit(devno-totdev-1);

			printf("%3d %s", devno,
				get_pdevnames(devno - totdev - 1));
			if (pi->pdev_count > 0) {
				printf(" already");
			} else {
				ukc_mod_kernel = 1;
				pi->pdev_count*=-1;
			}
			printf(" enabled\n");
			return;
		}
	}

	printf("Unknown devno (max is %d)\n", totdev+maxpseudo);
}

void
show(void)
{
	caddr_t *p;
	int	i = 0;

	cnt = 0;

	p = get_locnames(0);

	while (i <= maxlocnames) {
		if (more())
			break;
		printf("%s\n", (char *)adjust(*p));
		p++;
		i++;
	}

	cnt = -1;
}

void
common_attr_val(short attr, int *val, char routine)
{
	int	i = 0;
	struct cfdata *cd;
	long	*l;
	short *ln;
	int quit = 0;

	cnt = 0;

	cd = get_cfdata(0);

	while (cd->cf_attach != 0) {
		l = (long *)adjust((caddr_t)cd->cf_loc);
		ln = get_locnamp(cd->cf_locnames);
		while (*ln != -1) {
			if (*ln == attr) {
				if (val == NULL) {
					quit = more();
					pdev(i);
				} else {
					if (*val == *l) {
						quit = more();
						switch (routine) {
						case UC_ENABLE:
							enable(i);
							break;
						case UC_DISABLE:
							disable(i);
							break;
						case UC_SHOW:
							pdev(i);
							break;
						default:
							printf("Unknown routine /%c/\n",
							    routine);
							break;
						}
					}
				}
			}
			if (quit)
				break;
			ln++;
			l++;
		}
		if (quit)
			break;
		i++;
		cd++;
	}

	cnt = -1;
}

void
show_attr(char *cmd)
{
	char *c;
	caddr_t *p;
	short attr = -1, i = 0, l = 0;
	int a;

	c = cmd;
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\0') {
		c++;
		l++;
	}
	while (*c == ' ' || *c == '\t' || *c == '\n') {
		c++;
	}

	p = get_locnames(0);

	while (i <= maxlocnames) {
		if (strlen((char *)adjust(*p)) == l) {
			if (strncasecmp(cmd, adjust(*p), l) == 0)
				attr = i;
		}
		p++;
		i++;
	}

	if (attr == -1) {
		printf("Unknown attribute\n");
		return;
	}

	if (*c == '\0') {
		common_attr_val(attr, NULL, UC_SHOW);
	} else {
		if (number(c, &a) == 0) {
			common_attr_val(attr, &a, UC_SHOW);
		} else {
			printf("Unknown argument\n");
		}
	}
}

void
common_dev(char *dev, int len, short unit, short state, char routine)
{
	struct cfdata *cd;
	struct cfdriver *cdrv;
	int i = 0;

	switch (routine) {
	case UC_CHANGE:
		break;
	default:
		cnt = 0;
		break;
	}

	cnt = 0;

	cd = get_cfdata(0);

	while (cd->cf_attach != 0) {
		cdrv = (struct cfdriver *)adjust((caddr_t)cd->cf_driver);

		if (strlen((char *)adjust(cdrv->cd_name)) == len) {
			/*
			 * Ok, if device name is correct
			 *  If state == FSTATE_FOUND, look for "dev"
			 *  If state == FSTATE_STAR, look for "dev*"
			 *  If state == FSTATE_NOTFOUND, look for "dev0"
			 */
			if (!strncasecmp(dev,(char *)adjust(cdrv->cd_name), len) &&
			    (state == FSTATE_FOUND ||
			    (state == FSTATE_STAR &&
			    (cd->cf_fstate == FSTATE_STAR ||
			    cd->cf_fstate == FSTATE_DSTAR)) ||
			    (state == FSTATE_NOTFOUND &&
			    cd->cf_unit == unit &&
			    (cd->cf_fstate == FSTATE_NOTFOUND ||
			    cd->cf_fstate == FSTATE_DNOTFOUND)))) {
				if (more())
					break;
				switch (routine) {
				case UC_CHANGE:
					change(i);
					break;
				case UC_ENABLE:
					enable(i);
					break;
				case UC_DISABLE:
					disable(i);
					break;
				case UC_FIND:
					pdev(i);
					break;
				default:
					printf("Unknown routine /%c/\n",
					    routine);
					break;
				}
			}
		}
		i++;
		cd++;
	}

	if (nopdev == 0) {
		for (i = 0; i < maxpseudo; i++) {
			if (!strncasecmp(dev, (char *)get_pdevnames(i), len) &&
			    state == FSTATE_FOUND) {
				switch (routine) {
				case UC_CHANGE:
					change(totdev+1+i);
					break;
				case UC_ENABLE:
					enable(totdev+1+i);
					break;
				case UC_DISABLE:
					disable(totdev+1+i);
					break;
				case UC_FIND:
					pdev(totdev+1+i);
					break;
				default:
					printf("Unknown pseudo routine /%c/\n",
					    routine);
					break;
				}
			}
		}
	}

	switch (routine) {
	case UC_CHANGE:
		break;
	default:
		cnt = -1;
		break;
	}
}

void
common_attr(char *cmd, int attr, char routine)
{
	char *c;
	short l = 0;
	int a;

	c = cmd;
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\0') {
		c++;
		l++;
	}
	while (*c == ' ' || *c == '\t' || *c == '\n') {
		c++;
	}
	if (*c == '\0') {
		printf("Value missing for attribute\n");
		return;
	}

	if (number(c, &a) == 0) {
		common_attr_val(attr, &a, routine);
	} else {
		printf("Unknown argument\n");
	}
}

void
add_read(char *prompt, char field, char *dev, int len, int *val)
{
	int ok = 0;
	int a;
	cmd_t cmd;
	struct cfdata *cd;
	struct cfdriver *cdrv;

	*val = -1;

	while (!ok) {
		printf("%s ? ", prompt);
		fflush(stdout);

		ask_cmd(&cmd);

		if (strlen(cmd.cmd) != 0) {
			if (number(cmd.cmd, &a) == 0) {
				if (a > maxdev) {
					printf("Unknown devno (max is %d)\n",
					    maxdev);
				} else {
					cd = get_cfdata(a);
					cdrv = (struct cfdriver *)
					  adjust((caddr_t)cd->cf_driver);
					if (strncasecmp(dev,
							(char *)adjust(cdrv->cd_name),
							len) != 0 &&
					    field == 'a') {
						printf("Not same device type\n");
					} else {
						*val = a;
						ok = 1;
					}
				}
			} else if (cmd.cmd[0] == '?') {
				common_dev(dev, len, 0,
				    FSTATE_FOUND, UC_FIND);
			} else if (cmd.cmd[0] == 'q' ||
				   cmd.cmd[0] == 'Q') {
				ok = 1;
			} else {
				printf("Unknown argument\n");
			}
		} else {
			ok = 1;
		}
	}

}

void
add(char *dev, int len, short unit, short state)
{
	int i = 0, found = 0, *p;
	short *pv;
	struct cfdata new, *cd, *cdp;
	struct cfdriver *cdrv;
	int  val, max_unit, star_unit;

	ukc_mod_kernel = 1;

	bzero(&new, sizeof(struct cfdata));

	if (maxdev == totdev) {
		printf("No more space for new devices.\n");
		return;
	}

	if (state == FSTATE_FOUND) {
		printf("Device not complete number or * is missing\n");
		return;
	}

	cd = get_cfdata(0);

	while (cd->cf_attach != 0) {
		cdrv = (struct cfdriver *)adjust((caddr_t)cd->cf_driver);

		if (strlen((char *)adjust(cdrv->cd_name)) == len &&
		    strncasecmp(dev, (char *)adjust(cdrv->cd_name), len) == 0)
			found = 1;
		cd++;
	}

	if (!found) {
		printf("No device of this type exists.\n");
		return;
	}

	add_read("Clone Device (DevNo, 'q' or '?')", 'a', dev, len, &val);

	if (val != -1) {
		cd = get_cfdata(val);
		new = *cd;
		new.cf_unit = unit;
		new.cf_fstate = state;
		add_read("Insert before Device (DevNo, 'q' or '?')",
		    'i', dev, len, &val);
	}

	if (val != -1) {

		/* Insert the new record */
		cdp = cd = get_cfdata(maxdev+1);
		cdp--;
		for (i = maxdev; val <= i; i--) {
			*cd-- = *cdp--;
		}
		cd = get_cfdata(val);
		*cd = new;

		/* Fix indexs in pv */
		p = (int *)adjust((caddr_t)nl[I_PV_SIZE].n_value);
		pv = (short *)adjust((caddr_t)nl[SA_PV].n_value);
		for (i = 0; i < *p; i++) {
			if (*pv != 1 && *pv >= val)
				*pv = *pv + 1;
			pv++;
		}

		/* Fix indexs in cfroots */
		p = (int *)adjust((caddr_t)nl[I_CFROOTS_SIZE].n_value);
		pv = (short *)adjust((caddr_t)nl[SA_CFROOTS].n_value);
		for (i = 0; i < *p; i++) {
			if (*pv != 1 && *pv >= val)
				*pv = *pv + 1;
			pv++;
		}

		maxdev++;

		max_unit = -1;

		/* Find max unit number of the device type */

		cd = get_cfdata(0);

		while (cd->cf_attach != 0) {
			cdrv = (struct cfdriver *)
			  adjust((caddr_t)cd->cf_driver);

			if (strlen((char *)adjust(cdrv->cd_name)) == len &&
			    strncasecmp(dev, (char *)adjust(cdrv->cd_name),
			    len) == 0) {
				switch (cd->cf_fstate) {
				case FSTATE_NOTFOUND:
				case FSTATE_DNOTFOUND:
					if (cd->cf_unit > max_unit)
						max_unit = cd->cf_unit;
					break;
				default:
					break;
				}
			}
			cd++;
		}

		/*
		 * For all * entries set unit number to max+1, and update
		 * cf_starunit1 if necessary.
		 */
		max_unit++;
		star_unit = -1;
		cd = get_cfdata(0);
		while (cd->cf_attach != 0) {
			cdrv = (struct cfdriver *)
			    adjust((caddr_t)cd->cf_driver);

			if (strlen((char *)adjust(cdrv->cd_name)) == len &&
			    strncasecmp(dev, (char *)adjust(cdrv->cd_name),
			    len) == 0) {
				switch (cd->cf_fstate) {
				case FSTATE_NOTFOUND:
				case FSTATE_DNOTFOUND:
					if (cd->cf_unit > star_unit)
						star_unit = cd->cf_unit;
					break;
				default:
					break;
				}
			}
			cd++;
		}
		star_unit++;

		cd = get_cfdata(0);
		while (cd->cf_attach != 0) {
			cdrv = (struct cfdriver *)
			    adjust((caddr_t)cd->cf_driver);

			if (strlen((char *)adjust(cdrv->cd_name)) == len &&
			    strncasecmp(dev, (char *)adjust(cdrv->cd_name),
			    len) == 0) {
				switch (cd->cf_fstate) {
				case FSTATE_STAR:
				case FSTATE_DSTAR:
					cd->cf_unit = max_unit;
					if (cd->cf_starunit1 < star_unit)
						cd->cf_starunit1 = star_unit;
					break;
				default:
					break;
				}
			}
			cd++;
		}

		pdev(val);
	}

	/* cf_attach, cf_driver, cf_unit, cf_fstate, cf_loc, cf_flags,
	   cf_parents, cf_locnames, cf_locnames and cf_ivstubs */
}

void
add_history(int devno, short unit, short state, int newno)
{
	int i = 0, *p;
	short *pv;
	struct cfdata new, *cd, *cdp;
	struct cfdriver *cdrv;
	int  val, max_unit;
	int  len;
	char *dev;

	ukc_mod_kernel = 1;

	bzero(&new, sizeof(struct cfdata));
	cd = get_cfdata(devno);
	new = *cd;
	new.cf_unit = unit;
	new.cf_fstate = state;

	val = newno;

	cdrv = (struct cfdriver *) adjust((caddr_t)cd->cf_driver);
	dev = adjust((caddr_t)cdrv->cd_name);
	len = strlen(dev);

	/* Insert the new record */
	cdp = cd = get_cfdata(maxdev+1);
	cdp--;
	for (i = maxdev; val <= i; i--)
		*cd-- = *cdp--;
	cd = get_cfdata(val);
	*cd = new;

	/* Fix indexs in pv */
	p = (int *)adjust((caddr_t)nl[I_PV_SIZE].n_value);
	pv = (short *)adjust((caddr_t)nl[SA_PV].n_value);
	for (i = 0; i < *p; i++) {
		if (*pv != 1 && *pv >= val)
			*pv = *pv + 1;
		pv++;
	}

	/* Fix indexs in cfroots */
	p = (int *)adjust((caddr_t)nl[I_CFROOTS_SIZE].n_value);
	pv = (short *)adjust((caddr_t)nl[SA_CFROOTS].n_value);
	for (i = 0; i < *p; i++) {
		if (*pv != 1 && *pv >= val)
			*pv = *pv + 1;
		pv++;
	}

	maxdev++;
	max_unit = -1;

	/* Find max unit number of the device type */
	cd = get_cfdata(0);
	while (cd->cf_attach != 0) {
		cdrv = (struct cfdriver *)
		    adjust((caddr_t)cd->cf_driver);

		if (strlen((char *)adjust(cdrv->cd_name)) == len &&
		    strncasecmp(dev, (char *)adjust(cdrv->cd_name),
		    len) == 0) {
			switch (cd->cf_fstate) {
			case FSTATE_NOTFOUND:
			case FSTATE_DNOTFOUND:
				if (cd->cf_unit > max_unit)
					max_unit = cd->cf_unit;
				break;
			default:
				break;
			}
		}
		cd++;
	}

	/* For all * entries set unit number to max+1 */
	max_unit++;
	cd = get_cfdata(0);
	while (cd->cf_attach != 0) {
		cdrv = (struct cfdriver *)
		    adjust((caddr_t)cd->cf_driver);

		if (strlen((char *)adjust(cdrv->cd_name)) == len &&
		    strncasecmp(dev, (char *)adjust(cdrv->cd_name),
		    len) == 0) {
			switch (cd->cf_fstate) {
			case FSTATE_STAR:
			case FSTATE_DSTAR:
				cd->cf_unit = max_unit;
				break;
			default:
				break;
			}
		}
		cd++;
	}

	printf("%3d ", newno);
	pdevnam(newno);
	printf(" added\n");
	pdev(val);
}

int
config(void)
{
	cmd_t cmd;
	int i, st;

	/* Set up command table pointer */
	cmd.table = cmd_table;

	printf("Enter 'help' for information\n");

	/* Edit cycle */
	do {
again:
		printf("ukc> ");
		fflush(stdout);
		ask_cmd(&cmd);

		if (cmd.cmd[0] == '\0')
			goto again;
		for (i = 0; cmd_table[i].cmd != NULL; i++)
			if (strstr(cmd_table[i].cmd, cmd.cmd) ==
			    cmd_table[i].cmd)
				break;

		/* Quick hack to put in '?' == 'help' */
		if (!strcmp(cmd.cmd, "?"))
			i = 0;

		/* Check for valid command */
		if (cmd_table[i].cmd == NULL) {
			printf("Invalid command '%s'.  Try 'help'.\n", cmd.cmd);
			continue;
		} else
			strlcpy(cmd.cmd, cmd_table[i].cmd, sizeof cmd.cmd);

		/* Call function */
		st = cmd_table[i].fcn(&cmd);

		/* Update status */
		if (st == CMD_EXIT)
			break;
		if (st == CMD_SAVE)
			break;
	} while (1);

	return (st == CMD_SAVE);
}

void
process_history(int len, char *buf)
{
	char *c;
	int devno, newno;
	short unit, state;
	struct timezone *tz;

	if (len == 0) {
		printf("History is empty\n");
		return;
	}

	printf("Processing history...\n");

	buf[len] = 0;

	c = buf;

	while (*c != '\0') {
		switch (*c) {
		case 'a':
			c++;
			c++;
			devno = atoi(c);
			while (*c >= '0' && *c <= '9')
				c++;
			c++;
			unit = atoi(c);
			if (*c == '-') c++;
			while (*c >= '0' && *c <= '9')
				c++;
			c++;
			state = atoi(c);
			if (*c == '-')
				c++;
			while (*c >= '0' && *c <= '9')
				c++;
			c++;
			newno = atoi(c);
			while (*c >= '0' && *c <= '9')
				c++;
			add_history(devno, unit, state, newno);
			while (*c != '\n')
				c++;
			c++;
			break;
		case 'c':
			c++;
			c++;
			devno = atoi(c);
			while (*c >= '0' && *c <= '9')
				c++;
			if (*c == ' ')
				c++;
			if (*c != '\n')
				change_history(devno, c);
			while (*c != '\n')
				c++;
			c++;
			break;
		case 'd':
			c++;
			devno = atoi(c);
			disable(devno);
			while (*c != '\n')
				c++;
			c++;
			break;
		case 'e':
			c++;
			devno = atoi(c);
			enable(devno);
			while (*c != '\n')
				c++;
			c++;
			break;
		case 't':
			c++;
			c++;
			tz = (struct timezone *)adjust((caddr_t)nl[TZ_TZ].
			    n_value);
			tz->tz_minuteswest = atoi(c);
			while (*c != ' ')
				c++;
			c++;
			tz->tz_dsttime = atoi(c);
			while (*c != '\n')
				c++;
			c++;
			ukc_mod_kernel = 1;
			break;
		case 'q':
			while (*c != '\0')
				c++;
			break;
		default:
			printf("unknown command %c\n", *c);
			while (*c != '\0' && *c != '\n')
				c++;
			break;
		}
	}
}
@


1.22
log
@Remove OLDSCSIBUS conditional. Unused since it was imported 21 years ago.

ok natano
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.21 2015/09/21 14:45:14 guenther Exp $ */
d68 1
a68 1
get_extraloc(int idx)
d70 12
a81 2
	return((long *)(adjust((caddr_t)nl[IA_EXTRALOC].n_value) +
	    idx * sizeof(long)));
d387 1
a387 1
	long	*j = NULL, *k = NULL, *l;
d430 2
a431 3
			j = (long *)adjust((caddr_t)nl[I_NEXTRALOC].n_value);
			k = (long *)adjust((caddr_t)nl[I_UEXTRALOC].n_value);
			if ((i + *k) > *j) {
d435 3
a437 4

			j = l = get_extraloc(*k);
			bcopy(adjust((caddr_t)cd->cf_loc),
			    l, sizeof(long) * i);
d449 2
a450 2
			if (bcmp(adjust((caddr_t)cd->cf_loc), j,
			    sizeof(long) * i)) {
a451 1
				*k = *k + i;
d488 1
a488 1
	long	*j = NULL, *k = NULL, *l;
d529 2
a530 3
			j = (long *)adjust((caddr_t)nl[I_NEXTRALOC].n_value);
			k = (long *)adjust((caddr_t)nl[I_UEXTRALOC].n_value);
			if ((i + *k) > *j) {
d534 3
a536 4

			j = l = get_extraloc(*k);
			bcopy(adjust((caddr_t)cd->cf_loc),
			    l, sizeof(long) * i);
a564 1
				*k = *k + i;
@


1.21
log
@Make UKC handle device locators as longs

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.20 2011/10/02 22:20:50 edd Exp $ */
a142 5

#if defined(OLDSCSIBUS)
	if (strlen(adjust((caddr_t)cdrv->cd_name)) == 0)
		printf("oldscsibus");
#endif
@


1.20
log
@Fix some minor things in config(8):
 * As haesbaert suggests, correctly order include files.
 * Found some old style function defs. Updated.
 * Found a prototype inside a function. Moved.

OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.19 2011/04/06 11:36:26 miod Exp $ */
d31 2
d60 1
a60 1
caddr_t *
d67 1
a67 1
int *
d70 2
a71 2
	return((int *)(adjust((caddr_t)nl[IA_EXTRALOC].n_value) +
	    idx * sizeof(int)));
d74 1
a74 1
char *
d85 1
a85 1
struct pdevinit *
d112 2
a113 2
void
pnum(int val)
d116 1
a116 1
		printf("%d", val);
d122 1
a122 1
		printf("0%o", val);
d125 1
a125 1
		printf("%d", val);
d129 1
a129 1
		printf("0x%x", val);
d134 1
a134 1
void
d174 1
a174 1
	int	*i;
d230 1
a230 1
	i = (int *)adjust((caddr_t)cd->cf_loc);
d242 13
d258 2
a259 17
	int neg = 0, base = 10;
	u_int num = 0;

	if (*c == '-') {
		neg = 1;
		c++;
	}
	if (*c == '0') {
		base = 8;
		c++;
		if (*c == 'x' || *c == 'X') {
			base = 16;
			c++;
		}
	}
	while (*c != '\n' && *c != '\t' && *c != ' ' && *c != '\0') {
		u_char cc = *c;
d261 3
a263 6
		if (cc >= '0' && cc <= '9')
			cc = cc - '0';
		else if (cc >= 'a' && cc <= 'f')
			cc = cc - 'a' + 10;
		else if (cc >= 'A' && cc <= 'F')
			cc = cc - 'A' + 10;
d265 1
a265 6
			return (-1);

		if (cc > base)
			return (-1);
		num = num * base + cc;
		c++;
d267 1
a267 5

	if (neg && num > INT_MAX)	/* overflow */
		return (1);
	*val = neg ? - num : num;
	return (0);
d335 2
a336 2
void
modify(char *item, int *val)
d339 1
a339 1
	int a;
d352 1
a352 1
				if (number(cmd.cmd, &a) == 0) {
d354 1
a354 1
					break;
d360 12
d373 2
d381 2
a382 1
	int	i, share = 0, *j = NULL, *k = NULL, *l;
d409 1
a409 1
		l = (int *)adjust((caddr_t)cd->cf_loc);
d425 2
a426 2
			j = (int *)adjust((caddr_t)nl[I_NEXTRALOC].n_value);
			k = (int *)adjust((caddr_t)nl[I_UEXTRALOC].n_value);
d434 1
a434 1
			    l, sizeof(int) * i);
d439 1
a439 1
			modify((char *)adjust(*p), l);
d447 2
a448 2
			    sizeof(int) * i)) {
				cd->cf_loc = (int *)readjust((caddr_t)j);
d485 2
a486 1
	int	i, share = 0, *j = NULL, *k = NULL, *l;
d511 1
a511 1
		l = (int *)adjust((caddr_t)cd->cf_loc);
d527 2
a528 2
			j = (int *)adjust((caddr_t)nl[I_NEXTRALOC].n_value);
			k = (int *)adjust((caddr_t)nl[I_UEXTRALOC].n_value);
d536 1
a536 1
			    l, sizeof(int) * i);
d563 2
a564 2
			    j, sizeof(int) * i)) {
				cd->cf_loc = (int *)readjust((caddr_t)j);
d757 1
a757 1
	int   *l;
d766 1
a766 1
		l = (int *)adjust((caddr_t)cd->cf_loc);
@


1.19
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.18 2009/10/27 23:59:51 deraadt Exp $ */
d30 1
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.17 2008/03/24 21:35:03 maja Exp $ */
d1361 1
a1361 1
	while (*c != NULL) {
d1435 1
a1435 1
			while (*c != NULL)
d1440 1
a1440 1
			while (*c != NULL && *c != '\n')
@


1.17
log
@Make it possible to disable/enable pseudo devices in UKC, config file and
at config -e. -moj  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.16 2008/03/23 15:00:29 maja Exp $ */
a25 4

#ifndef LINT
static	char rcsid[] = "$OpenBSD: ukcutil.c,v 1.16 2008/03/23 15:00:29 maja Exp $";
#endif
@


1.16
log
@Done mark a disable of a disabled device as an change (and same with enable).
Reported by jj@@ a long time ago. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.15 2008/03/08 01:23:16 simon Exp $ */
d28 1
a28 1
static	char rcsid[] = "$OpenBSD: ukcutil.c,v 1.15 2008/03/08 01:23:16 simon Exp $";
d186 1
a186 1
			printf("%3d %s count %d (pseudo device)\n", devno,
d188 4
a191 1
			    pi->pdev_count);
d608 1
d649 11
a659 2
			printf("%3d %s can't disable pseudo device\n", devno,
			    get_pdevnames(devno - totdev - 1));
d672 1
d712 11
a722 2
			printf("%3d %s can't enable pseudo device\n", devno,
			    get_pdevnames(devno - totdev - 1));
@


1.15
log
@avoid request for input if lines are set to zero

ok deraadt@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.14 2004/01/04 18:30:05 deraadt Exp $ */
d28 1
a28 1
static	char rcsid[] = "$OpenBSD: ukcutil.c,v 1.14 2004/01/04 18:30:05 deraadt Exp $";
a606 2
	ukc_mod_kernel = 1;

d629 1
a629 1
		if (done)
d631 3
a660 2
	ukc_mod_kernel = 1;

d682 1
a682 1
		if (done)
d684 3
@


1.14
log
@knf and lint
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.13 2003/06/02 21:19:03 maja Exp $ */
d28 1
a28 1
static	char rcsid[] = "$OpenBSD: ukcutil.c,v 1.13 2003/06/02 21:19:03 maja Exp $";
d100 1
a100 1
		if (cnt == lines) {
@


1.13
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.12 2002/09/06 21:10:20 henning Exp $ */
d28 1
a28 1
static	char rcsid[] = "$OpenBSD: ukcutil.c,v 1.12 2002/09/06 21:10:20 henning Exp $";
d51 1
a51 1
	    idx*sizeof(struct cfdata)));
d58 1
a58 1
	    idx*sizeof(short)));
d65 1
a65 1
	    idx*sizeof(caddr_t)));
d72 1
a72 1
	    idx*sizeof(int)));
d81 1
a81 1
	    idx*sizeof(caddr_t));
d90 1
a90 1
	    idx*sizeof(struct pdevinit)));
d136 1
a136 1
pdevnam(short int devno)
d170 1
a170 1
pdev(short int devno)
d172 1
a177 1
	struct pdevinit *pi;
d243 1
a244 2
	int neg = 0;
	int base = 10;
d283 1
a283 1
device(char *cmd, int *len, short int *unit, short int *state)
d285 1
a285 1
	short int u = 0, s = FSTATE_FOUND;
d294 1
a313 1

d320 2
a322 2
	caddr_t *p;
	short int attr = -1, i = 0, l = 0;
d379 1
a380 1
	caddr_t	*p;
a381 1
	int	 i, share = 0, *j = NULL, *k = NULL, *l;
d383 1
d388 2
a389 1
		if (ask_yn("change")) {
d391 1
a391 1
			cd = get_cfdata(devno);
d393 11
a403 11
			/*
			 * Search for some other driver sharing this
			 * locator table. if one does, we may need to
			 * replace the locators with a new copy.
			 */
			c = get_cfdata(0);
			for (i = 0; c->cf_driver; i++) {
				if (i != devno && c->cf_loc == cd->cf_loc)
					share = 1;
				c++;
			}
d405 2
a406 2
			ln = get_locnamp(cd->cf_locnames);
			l = (int *)adjust((caddr_t)cd->cf_loc);
d408 5
a412 5
			if (share) {
				if (oldkernel) {
					printf("Can't do that on this kernel\n");
					return;
				}
d414 7
a420 7
				lk = ln;
				i = 0;
				while (*lk != -1) {
					lk++;
					i++;
				}
				lk = ln;
d422 6
a427 6
				j = (int *)adjust((caddr_t)nl[I_NEXTRALOC].n_value);
				k = (int *)adjust((caddr_t)nl[I_UEXTRALOC].n_value);
				if ((i + *k) > *j) {
					printf("Not enough space to change device.\n");
					return;
				}
d429 4
a432 4
				j = l = get_extraloc(*k);
				bcopy(adjust((caddr_t)cd->cf_loc),
				    l, sizeof(int) * i);
			}
d434 7
a440 7
			while (*ln != -1) {
				p = get_locnames(*ln);
				modify((char *)adjust(*p), l);
				ln++;
				l++;
			}
			modify("flags", &cd->cf_flags);
d442 5
a446 6
			if (share) {
				if (bcmp(adjust((caddr_t)cd->cf_loc), j,
				    sizeof(int) * i)) {
					cd->cf_loc = (int *)readjust((caddr_t)j);
					*k = *k + i;
				}
d448 1
d450 4
a453 5
			printf("%3d ", devno);
			pdevnam(devno);
			printf(" changed\n");
			pdev(devno);
		}
d482 1
a482 1
	int	 i, share = 0, *j = NULL, *k = NULL, *l;
a485 1
	caddr_t	*p;
a535 1
			p = get_locnames(*ln);
d727 1
a727 1
common_attr_val(short int attr, int *val, char routine)
d827 1
a827 1
common_dev(char *dev, int len, short int unit, short int state, char routine)
d1005 1
a1005 1
add(char *dev, int len, short int unit, short int state)
d1169 1
a1169 1
add_history(int devno, short int unit, short int state, int newno)
@


1.12
log
@ansi
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.11 2002/07/14 02:59:41 deraadt Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d28 1
a28 1
static	char rcsid[] = "$OpenBSD: ukcutil.c,v 1.11 2002/07/14 02:59:41 deraadt Exp $";
@


1.11
log
@kill sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.10 2002/05/02 12:59:54 miod Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: ukcutil.c,v 1.10 2002/05/02 12:59:54 miod Exp $";
d50 1
a50 1
extern int ukc_mod_kernel;
d52 2
a53 3
struct cfdata *
get_cfdata(idx)
	int	idx;
d60 1
a60 2
get_locnamp(idx)
	int	idx;
d67 1
a67 2
get_locnames(idx)
	int	idx;
d74 1
a74 2
get_extraloc(idx)
	int	idx;
d81 1
a81 2
get_pdevnames(idx)
	int	idx;
d92 1
a92 2
get_pdevinit(idx)
	int	idx;
d99 1
a99 1
more()
d119 1
a119 2
pnum(val)
	int val;
d141 1
a141 2
pdevnam(devno)
	short devno;
d175 1
a175 2
pdev(devno)
	short devno;
d246 1
a246 3
number(c, val)
	const char *c;
	int *val;
d289 1
a289 4
device(cmd, len, unit, state)
	char *cmd;
	int *len;
	short *unit, *state;
d291 1
a291 1
	short u = 0, s = FSTATE_FOUND;
d324 1
a324 3
attr(cmd, val)
	char *cmd;
	int *val;
d328 1
a328 1
	short attr = -1, i = 0, l = 0;
d354 1
a354 3
modify(item, val)
	char *item;
	int  *val;
d383 1
a383 2
change(devno)
	int devno;
d486 1
a486 3
change_history(devno, str)
	int devno;
	char *str;
d610 1
a610 2
disable(devno)
	int devno;
d663 1
a663 2
enable(devno)
	int devno;
d714 1
a714 1
show()
d735 1
a735 4
common_attr_val(attr, val, routine)
	short attr;
	int   *val;
	char  routine;
d791 1
a791 2
show_attr(cmd)
	char *cmd;
d835 1
a835 5
common_dev(dev, len, unit, state, routine)
	char *dev;
	int len;
	short unit, state;
	char routine;
d934 1
a934 4
common_attr(cmd, attr, routine)
	char *cmd;
	int attr;
	char routine;
d961 1
a961 6
add_read(prompt, field, dev, len, val)
	char *prompt;
	char field;
	char *dev;
	int len;
	int *val;
d1013 1
a1013 4
add(dev, len, unit, state)
	char *dev;
	int len;
	short unit, state;
d1177 1
a1177 3
add_history(devno, unit, state, newno)
	int devno, newno;
	short unit, state;
d1281 1
a1281 1
config()
d1330 1
a1330 3
process_history(len, buf)
	int len;
	char *buf;
@


1.10
log
@In UKC, when adding a fixed unit device (foo0) by cloning a star device
(foo*), be sure to update all cf_starunit1 fields for related star devices,
so that they will not compete for the foo0 probe.

This fixes the new sparc bsd.scsi3 behaviour.

Tested by brad@@ and myself, ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.9 2002/03/23 13:30:24 espie Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: ukcutil.c,v 1.9 2002/03/23 13:30:24 espie Exp $";
d1358 1
a1358 1
			strcpy(cmd.cmd, cmd_table[i].cmd);
@


1.9
log
@small cleanups:
ansi prototypes,
help formating,
common code to handle integer parameters.

Let SystemV shm parameters be settable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.8 2001/12/10 23:15:34 deraadt Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: ukcutil.c,v 1.8 2001/12/10 23:15:34 deraadt Exp $";
d1061 1
a1061 1
	int  val, max_unit;
d1161 4
a1164 1
		/* For all * entries set unit number to max+1 */
d1166 23
d1201 2
d1214 1
a1214 1
	/* cf_attach, cf_driver, cf_unit, cf_state, cf_loc, cf_flags,
@


1.8
log
@handle "q" input better; bug reported in 2244
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.7 2001/12/05 10:11:23 deraadt Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: ukcutil.c,v 1.7 2001/12/05 10:11:23 deraadt Exp $";
d256 1
a256 1
	char *c;
@


1.7
log
@more free KNF from maja, though this was hard to do
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.6 2001/02/04 20:42:12 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: ukcutil.c,v 1.6 2001/02/04 20:42:12 maja Exp $";
d1007 2
@


1.6
log
@Add support for pseudo devices. This is done by adding more information
in ioconf.c. The only thing that can be done with pseudo devices is
changing the number of created units. -moj ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.5 2001/01/31 22:41:32 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: ukcutil.c,v 1.5 2001/01/31 22:41:32 maja Exp $";
d57 1
a57 1
				 idx*sizeof(struct cfdata)));
d65 1
a65 1
			 idx*sizeof(short)));
d73 1
a73 1
			   idx*sizeof(caddr_t)));
d81 1
a81 1
		       idx*sizeof(int)));
d84 1
a84 1
caddr_t *
d91 2
a92 2
			   idx*sizeof(caddr_t));
	return(caddr_t *)adjust((caddr_t)*p);
d101 1
a101 1
				 idx*sizeof(struct pdevinit)));
a120 1
	
d129 15
a143 14
		printf("%d",val);
	} else {
		switch (base) {
		case 8:
			printf("0%o",val);
			break;
		case 10:
			printf("%d",val);
			break;
		case 16:
		default:
			printf("0x%x",val);
			break;
		}
d159 1
a159 1
	if (strlen(adjust((caddr_t)cdrv->cd_name)) == 0) {
a160 1
	}
d187 1
a187 1
	short	*s,*ln;
d193 2
a194 2
	if (nopdev == 0) { 
		if ((devno > maxdev) && (devno <= totdev)) {
d198 5
a202 5
		if ((devno > totdev) && (devno <= (totdev+maxpseudo))) {
			pi = get_pdevinit(devno-totdev-1);
			printf("%3d %s count %d (pseudo device)\n", devno, 
				get_pdevnames(devno-totdev-1),
				pi->pdev_count);
d362 1
a362 2

	if (attr == -1) {
a363 1
	}
a365 1

d378 1
a378 2

	while(1) {
d395 1
a395 1
		} else {
a396 1
		}
d404 1
a404 1
	struct cfdata *cd,*c;
d407 2
a408 2
	int	 i,share = 0,*j,*k,*l;
	short	*ln,*lk;
a410 3

	j = k = NULL;

a411 1

a412 1

a421 1

d431 1
a431 1
			
d438 1
a438 1
				lk = ln; 
d441 2
a442 1
					lk++; i++;
d445 1
a445 1
				
a453 1

d455 1
a455 1
				      l, sizeof(int) * i);
d460 1
a460 1
				modify((char *)adjust(*p),l);
d467 2
a468 2
				if (bcmp(adjust((caddr_t)cd->cf_loc),
					 j, sizeof(int) * i)) {
d483 1
a483 1
		if ((devno > maxdev) && (devno <= totdev)) {
d487 2
a488 2
		if ((devno > totdev) && (devno <= (totdev+maxpseudo))) {
			
a489 1
			
a490 1

a491 1

d493 2
a494 1
				printf("%3d %s changed\n", devno, get_pdevnames(devno-totdev-1));
d505 1
a505 1
change_history(devno,str)
d509 4
a512 1
	struct cfdata *cd,*c;
a513 3
	struct pdevinit *pi;
	int	 i,share = 0,*j,*k,*l;
	short	*ln,*lk;
d517 1
a517 3
	j = k = NULL;

	if (devno <=  maxdev) {
a519 1

a526 1

d536 1
a536 1
			
d543 1
a543 1
			lk = ln; 
d546 2
a547 1
				lk++; i++;
d550 1
a550 1
				
a558 1

d560 1
a560 1
			      l, sizeof(int) * i);
d566 6
a571 3
			if (*str == '-') str++;
			while ((*str >= '0') && (*str <= '9')) str++;
			if (*str == ' ') str++;
d578 6
a583 3
			if (*str == '-') str++;
			while ((*str >= '0') && (*str <= '9')) str++;
			if (*str == ' ') str++;
d588 1
a588 1
				 j, sizeof(int) * i)) {
a597 1
		
d602 1
a602 1
		if ((devno > maxdev) && (devno <= totdev)) {
d606 1
a606 2
		if ((devno > totdev) && (devno <= (totdev+maxpseudo))) {
			
a607 1
			
d612 6
a617 3
				if (*str == '-') str++;
				while ((*str >= '0') && (*str <= '9')) str++;
				if (*str == ' ') str++;
d620 2
a621 1
			printf("%3d %s changed\n", devno, get_pdevnames(devno-totdev-1));
a622 1

d627 1
a627 1
	printf("Unknown devno (max is %d)\n", totdev+maxpseudo);
d640 1
a640 1
		
d669 1
a669 1
		if ((devno > maxdev) && (devno <= totdev)) {
d673 3
a675 3
		if ((devno > totdev) && (devno <= (totdev+maxpseudo))) {
			printf("%3d %s can't disable pseudo device\n", devno, 
				get_pdevnames(devno-totdev-1));
d690 1
a690 1
	
a693 1
		
d717 1
a717 1
		
d722 1
a722 1
		if ((devno > maxdev) && (devno <= totdev)) {
d726 3
a728 3
		if ((devno > totdev) && (devno <= (totdev+maxpseudo))) {
			printf("%3d %s can't enable pseudo device\n", devno, 
				get_pdevnames(devno-totdev-1));
d773 1
a773 1
	while(cd->cf_attach != 0) {
d776 1
a776 1
		while(*ln != -1) {
d780 1
a780 1
					pdev(i);			
d838 1
a838 1
			if (strncasecmp(cmd, adjust(*p), l) == 0) {
a839 1
			}
d884 1
a884 1
	while(cd->cf_attach != 0) {
d894 1
a894 2
			if (strncasecmp(dev,(char *)adjust(cdrv->cd_name),
					len) == 0 &&
d896 7
a902 7
			     (state == FSTATE_STAR &&
			      (cd->cf_fstate == FSTATE_STAR ||
			       cd->cf_fstate == FSTATE_DSTAR)) ||
			     (state == FSTATE_NOTFOUND &&
			      cd->cf_unit == unit &&
			      (cd->cf_fstate == FSTATE_NOTFOUND ||
			       cd->cf_fstate == FSTATE_DNOTFOUND)))) {
d931 3
a933 3
			if ((strncasecmp(dev,(char *)get_pdevnames(i),
			     len) == 0) && (state == FSTATE_FOUND)) {
				switch(routine) {
d947 2
a948 1
					printf("Unknown pseudo routine /%c/\n",routine);
d1008 1
a1008 1
	while(!ok) {
d1011 1
a1011 1
		
d1057 1
a1057 1
	struct cfdata new,*cd,*cdp;
d1077 1
a1077 1
	while(cd->cf_attach != 0) {
d1092 1
a1092 1
	
d1103 1
a1103 1
		
d1117 1
a1117 1
			if ((*pv != 1) && (*pv >= val))
d1126 1
a1126 1
			if ((*pv != 1) && (*pv >= val))
d1130 1
a1130 1
		
d1139 1
a1139 1
		while(cd->cf_attach != 0) {
d1145 1
a1145 1
					len) == 0) {
a1158 1

a1159 1

a1160 1

d1162 1
a1162 2

		while(cd->cf_attach != 0) {
d1164 1
a1164 1
			  adjust((caddr_t)cd->cf_driver);
d1168 1
a1168 1
					len) == 0) {
d1195 1
a1195 1
	struct cfdata new,*cd,*cdp;
a1203 1

d1208 1
a1208 1
	
d1218 1
a1218 1
	for (i = maxdev; val <= i; i--) {
a1219 1
	}
d1222 1
a1222 1
	
d1227 1
a1227 1
		if ((*pv != 1) && (*pv >= val))
d1236 1
a1236 1
		if ((*pv != 1) && (*pv >= val))
d1240 1
a1240 1
		
a1241 1
	
a1244 1

d1246 1
a1246 2

	while(cd->cf_attach != 0) {
d1248 1
a1248 1
		  adjust((caddr_t)cd->cf_driver);
d1252 1
a1252 1
				len) == 0) {
a1265 1

a1266 1

a1267 1

d1269 1
a1269 2

	while(cd->cf_attach != 0) {
d1271 1
a1271 1
		  adjust((caddr_t)cd->cf_driver);
d1275 1
a1275 1
				len) == 0) {
a1287 1

a1291 1

d1315 2
a1316 1
			if (strstr(cmd_table[i].cmd, cmd.cmd)==cmd_table[i].cmd)
d1344 1
a1344 1
process_history(len,buf)
d1349 2
a1350 2
	int devno,newno;
	short unit,state;
d1359 1
a1359 1
	
d1363 1
a1363 1
	
d1367 2
a1368 1
			c++; c++;
d1370 3
a1372 1
			while ((*c >= '0') && (*c <= '9')) c++; c++;
d1375 3
a1377 1
			while ((*c >= '0') && (*c <= '9')) c++; c++;
d1379 5
a1383 2
			if (*c == '-') c++;
			while ((*c >= '0') && (*c <= '9')) c++; c++;
d1385 6
a1390 3
			while ((*c >= '0') && (*c <= '9')) c++;
			add_history(devno,unit,state,newno);
			while (*c != '\n') c++; c++;
d1393 2
a1394 1
			c++; c++;
d1396 9
a1404 6
			while ((*c >= '0') && (*c <= '9')) c++;
			if (*c == ' ') c++;
			if (*c != '\n') { 
				change_history(devno,c);
			}
			while (*c != '\n') c++; c++;
d1410 3
a1412 1
			while (*c != '\n') c++; c++;
d1418 3
a1420 1
			while (*c != '\n') c++; c++;
d1423 2
a1424 1
			c++; c++;
d1428 3
a1430 1
			while (*c != ' ') c++; c++;
d1432 3
a1434 1
			while (*c != '\n') c++; c++;
d1438 2
a1439 1
			while (*c != NULL) c++;
d1442 3
a1444 2
			printf("unknown command %c\n",*c);
			while ((*c != NULL) && (*c != '\n')) c++;
@


1.5
log
@Dont write kernel if nothing has changed. ok @@deraadt. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.4 2001/01/15 23:53:34 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: ukcutil.c,v 1.4 2001/01/15 23:53:34 maja Exp $";
d84 20
d192 15
d208 1
a208 1
	if (devno >  maxdev) {
d412 1
d491 22
a512 2
	} else {
		printf("Unknown devno (max is %d)\n", maxdev);
d514 2
d525 1
d611 26
a636 2
	} else {
		printf("Unknown devno (max is %d)\n", maxdev);
d638 2
d676 14
a689 2
	} else {
		printf("Unknown devno (max is %d)\n", maxdev);
d691 3
d730 14
a743 2
	} else {
		printf("Unknown devno (max is %d)\n", maxdev);
d745 2
d944 25
d1085 1
a1085 1
		printf("Device not complete number or * is missing/n");
@


1.4
log
@Fix bug that sometime ignored first command in -e mode. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.3 2000/08/08 21:42:40 deraadt Exp $ */
d4 1
a4 1
 * Copyright (c) 1999 Mats O Jansson.  All rights reserved.
d33 1
a33 1
static char rcsid[] = "$OpenBSD: ukcutil.c,v 1.3 2000/08/08 21:42:40 deraadt Exp $";
d50 2
d346 2
d380 2
d470 2
d564 2
d603 2
d936 2
d1080 2
d1300 1
@


1.3
log
@permit changing flags
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.2 2000/01/08 23:23:37 d Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: ukcutil.c,v 1.2 2000/01/08 23:23:37 d Exp $";
d94 2
a97 2
		if (cmd.cmd[0] == 'q' || cmd.cmd[0] == 'Q')
			quit = 1;
@


1.2
log
@Allow UKC to change tz with 'timezone' command.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukcutil.c,v 1.1 1999/10/04 20:00:52 deraadt Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: ukcutil.c,v 1.1 1999/10/04 20:00:52 deraadt Exp $";
d215 1
a215 1
	printf("\n");
d434 1
d522 7
@


1.1
log
@config -e support; ukc from maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD$";
d37 1
d1216 1
d1266 9
@

