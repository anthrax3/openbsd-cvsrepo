head	1.43;
access;
symbols
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.33.0.6
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.12
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.10
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6;
locks; strict;
comment	@ * @;


1.43
date	2017.07.02.15.28.26;	author benno;	state Exp;
branches;
next	1.42;
commitid	O1Rrj73rj6EeHP15;

1.42
date	2017.07.02.14.27.30;	author benno;	state Exp;
branches;
next	1.41;
commitid	2Xe9BR5D8dBy0BPP;

1.41
date	2017.06.18.12.03.47;	author benno;	state Exp;
branches;
next	1.40;
commitid	1ImWCgIqWBjLLpn1;

1.40
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.39;
commitid	3AKCl24jEn0sIt6p;

1.39
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.38;
commitid	uzjOUwLRoN7KbcZI;

1.38
date	2016.06.21.21.35.24;	author benno;	state Exp;
branches;
next	1.37;
commitid	AL6SnrmnHkmPOpjv;

1.37
date	2016.01.29.02.22.57;	author mmcc;	state Exp;
branches;
next	1.36;
commitid	ruS0qh9wzgVwUQqr;

1.36
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.35;
commitid	3Z7yItGpFsmshk0c;

1.35
date	2014.11.03.18.44.36;	author bluhm;	state Exp;
branches;
next	1.34;
commitid	8nAFL7sqdqdC8oHX;

1.34
date	2014.11.03.03.42.11;	author doug;	state Exp;
branches;
next	1.33;
commitid	uiZmdZeIp1Ogo5tH;

1.33
date	2014.01.22.00.21.16;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.25.12.55.44;	author benno;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.06.21.42.40;	author sthen;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.03.18.42.40;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.31.21.03.48;	author tobias;	state Exp;
branches;
next	1.28;

1.28
date	2008.10.17.13.02.55;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2008.03.10.07.40.01;	author mpf;	state Exp;
branches;
next	1.26;

1.26
date	2008.02.26.10.09.58;	author mpf;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.25.06.03.31;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.21.08.29.34;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.16.20.01.23;	author mpf;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.13.16.35.21;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.11.14.39.17;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.12.02.09.03;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.11.23.30.30;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.25.18.58.42;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.25.18.57.34;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.26.01.06.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.16.06.27.02;	author mcbride;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.16.06.17.42;	author mcbride;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.20.00.01.20;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.03.16.29.36;	author sturm;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.07.12.41.53;	author mcbride;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.03.17.51.12;	author mpf;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.28.01.00.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.07.16.46.17;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.06.21.47.21;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.15.00.56.01;	author mcbride;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.14.11.24.35;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.05.02.18.55;	author mcbride;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.04.23.47.49;	author mcbride;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Second diff to rename additional "always" variable in struct ifsd_config.
from Rob Pierce.
Requested by stsp@@
@
text
@/*	$OpenBSD: parse.y,v 1.42 2017/07/02 14:27:30 benno Exp $	*/

/*
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>

#include <ctype.h>
#include <unistd.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <event.h>

#include "ifstated.h"
#include "log.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

static struct ifsd_config	*conf;
char				*start_state;

struct ifsd_action		*curaction;
struct ifsd_state		*curstate = NULL;

void			 link_states(struct ifsd_action *);
void			 set_expression_depth(struct ifsd_expression *, int);
void			 init_state(struct ifsd_state *);
struct ifsd_ifstate	*new_ifstate(u_short, int);
struct ifsd_external	*new_external(char *, u_int32_t);

typedef struct {
	union {
		int64_t		 number;
		char		*string;
		struct in_addr	 addr;
		u_short		 interface;

		struct ifsd_expression	*expression;
		struct ifsd_ifstate	*ifstate;
		struct ifsd_external	*external;

	} v;
	int lineno;
} YYSTYPE;

%}

%token	STATE INITSTATE
%token	LINK UP DOWN UNKNOWN ADDED REMOVED
%token	IF RUN SETSTATE EVERY INIT
%left	AND OR
%left	UNARY
%token	ERROR
%token	<v.string>	STRING
%token	<v.number>	NUMBER
%type	<v.string>	string
%type	<v.interface>	interface
%type	<v.ifstate>	if_test
%type	<v.external>	ext_test
%type	<v.expression>	expr term
%%

grammar		: /* empty */
		| grammar '\n'
		| grammar conf_main '\n'
		| grammar varset '\n'
		| grammar action '\n'
		| grammar state '\n'
		| grammar error '\n'		{ file->errors++; }
		;

string		: string STRING				{
			if (asprintf(&$$, "%s %s", $1, $2) == -1) {
				free($1);
				free($2);
				yyerror("string: asprintf");
				YYERROR;
			}
			free($1);
			free($2);
		}
		| STRING
		;

varset		: STRING '=' string		{
			char *s = $1;
			if (conf->opts & IFSD_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1) {
				free($1);
				free($3);
				yyerror("cannot store variable");
				YYERROR;
			}
			free($1);
			free($3);
		}
		;

conf_main	: INITSTATE STRING		{
			start_state = $2;
		}
		;

interface	: STRING		{
			if (($$ = if_nametoindex($1)) == 0) {
				yyerror("unknown interface %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl		/* one newline or more */
		;

action		: RUN STRING		{
			struct ifsd_action *action;

			if ((action = calloc(1, sizeof(*action))) == NULL)
				err(1, "action: calloc");
			action->type = IFSD_ACTION_COMMAND;
			action->act.command = $2;
			if (action->act.command == NULL)
				err(1, "action: strdup");
			TAILQ_INSERT_TAIL(&curaction->act.c.actions,
			    action, entries);
		}
		| SETSTATE STRING	{
			struct ifsd_action *action;

			if (curstate == NULL) {
				free($2);
				yyerror("set-state must be used inside 'if'");
				YYERROR;
			}
			if ((action = calloc(1, sizeof(*action))) == NULL)
				err(1, "action: calloc");
			action->type = IFSD_ACTION_CHANGESTATE;
			action->act.statename = $2;
			TAILQ_INSERT_TAIL(&curaction->act.c.actions,
			    action, entries);
		}
		| IF {
			struct ifsd_action *action;

			if ((action = calloc(1, sizeof(*action))) == NULL)
				err(1, "action: calloc");
			action->type = IFSD_ACTION_CONDITION;
			TAILQ_INIT(&action->act.c.actions);
			TAILQ_INSERT_TAIL(&curaction->act.c.actions,
			    action, entries);
			action->parent = curaction;
			curaction = action;
		} expr action_block {
			set_expression_depth(curaction->act.c.expression, 0);
			curaction = curaction->parent;
		}
		;

action_block	: optnl '{' optnl action_l '}'
		| optnl action
		;

action_l	: action_l action nl
		| action nl
		;

init		: INIT {
			if (curstate != NULL)
				curaction = curstate->init;
			else
				curaction = conf->initstate.init;
		} action_block {
			if (curstate != NULL)
				curaction = curstate->body;
			else
				curaction = conf->initstate.body;
		}
		;

if_test		: interface '.' LINK '.' UP		{
			$$ = new_ifstate($1, IFSD_LINKUP);
		}
		| interface '.' LINK '.' DOWN		{
			$$ = new_ifstate($1, IFSD_LINKDOWN);
		}
		| interface '.' LINK '.' UNKNOWN	{
			$$ = new_ifstate($1, IFSD_LINKUNKNOWN);
		}
		;

ext_test	: STRING EVERY NUMBER {
			if ($3 <= 0 || $3 > UINT_MAX) {
				yyerror("invalid interval: %lld", $3);
				free($1);
				YYERROR;
			}
			$$ = new_external($1, $3);
			free($1);
		}
		;

term		: if_test {
			if (($$ = calloc(1, sizeof(*$$))) == NULL)
				err(1, NULL);
			curaction->act.c.expression = $$;
			$$->type = IFSD_OPER_IFSTATE;
			$$->u.ifstate = $1;
			TAILQ_INSERT_TAIL(&$1->expressions, $$, entries);
		}
		| ext_test {
			if (($$ = calloc(1, sizeof(*$$))) == NULL)
				err(1, NULL);
			curaction->act.c.expression = $$;
			$$->type = IFSD_OPER_EXTERNAL;
			$$->u.external = $1;
			TAILQ_INSERT_TAIL(&$1->expressions, $$, entries);
		}
		| '(' expr ')'			{
			$$ = $2;
		}
		;

expr		: '!' expr %prec UNARY			{
			if (($$ = calloc(1, sizeof(*$$))) == NULL)
				err(1, NULL);
			curaction->act.c.expression = $$;
			$$->type = IFSD_OPER_NOT;
			$2->parent = $$;
			$$->right = $2;
		}
		| expr AND expr			{
			if (($$ = calloc(1, sizeof(*$$))) == NULL)
				err(1, NULL);
			curaction->act.c.expression = $$;
			$$->type = IFSD_OPER_AND;
			$1->parent = $$;
			$3->parent = $$;
			$$->left = $1;
			$$->right = $3;
		}
		| expr OR expr			{
			if (($$ = calloc(1, sizeof(*$$))) == NULL)
				err(1, NULL);
			curaction->act.c.expression = $$;
			$$->type = IFSD_OPER_OR;
			$1->parent = $$;
			$3->parent = $$;
			$$->left = $1;
			$$->right = $3;
		}
		| term
		;

state		: STATE string {
			struct ifsd_state *state = NULL;

			TAILQ_FOREACH(state, &conf->states, entries)
				if (!strcmp(state->name, $2)) {
					yyerror("state %s already exists", $2);
					free($2);
					YYERROR;
				}
			if ((state = calloc(1, sizeof(*curstate))) == NULL)
				err(1, NULL);
			init_state(state);
			state->name = $2;
			curstate = state;
			curaction = state->body;
		} optnl '{' optnl stateopts_l '}' {
			TAILQ_INSERT_TAIL(&conf->states, curstate, entries);
			curstate = NULL;
			curaction = conf->initstate.body;
		}
		;

stateopts_l	: stateopts_l stateoptsl
		| stateoptsl
		;

stateoptsl	: init nl
		| action nl
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "&&",			AND},
		{ "added",		ADDED},
		{ "down",		DOWN},
		{ "every",		EVERY},
		{ "if",			IF},
		{ "init",		INIT},
		{ "init-state",		INITSTATE},
		{ "link",		LINK},
		{ "removed",		REMOVED},
		{ "run",		RUN},
		{ "set-state",		SETSTATE},
		{ "state",		STATE},
		{ "unknown",		UNKNOWN},
		{ "up",			UP},
		{ "||",			OR}
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ',' && x != '.'))

	if (isalnum(c) || c == ':' || c == '_' || c == '&' || c == '|') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		warn("malloc");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

struct ifsd_config *
parse_config(char *filename, int opts)
{
	int		 errors = 0;
	struct sym	*sym, *next;
	struct ifsd_state *state;

	if ((conf = calloc(1, sizeof(struct ifsd_config))) == NULL) {
		err(1, NULL);
		return (NULL);
	}

	if ((file = pushfile(filename, 0)) == NULL) {
		free(conf);
		return (NULL);
	}
	topfile = file;

	TAILQ_INIT(&conf->states);

	init_state(&conf->initstate);
	curaction = conf->initstate.body;
	conf->opts = opts;

	yyparse();

	/* Link states */
	TAILQ_FOREACH(state, &conf->states, entries) {
		link_states(state->init);
		link_states(state->body);
	}

	errors = file->errors;
	popfile();

	if (start_state != NULL) {
		TAILQ_FOREACH(state, &conf->states, entries) {
			if (strcmp(start_state, state->name) == 0) {
				conf->curstate = state;
				break;
			}
		}
		if (conf->curstate == NULL)
			errx(1, "invalid start state %s", start_state);
	} else {
		conf->curstate = TAILQ_FIRST(&conf->states);
	}

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if ((conf->opts & IFSD_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	if (errors) {
		clear_config(conf);
		errors = 0;
		return (NULL);
	}

	return (conf);
}

void
link_states(struct ifsd_action *action)
{
	struct ifsd_action *subaction;

	switch (action->type) {
	default:
	case IFSD_ACTION_COMMAND:
		break;
	case IFSD_ACTION_CHANGESTATE: {
		struct ifsd_state *state;

		TAILQ_FOREACH(state, &conf->states, entries) {
			if (strcmp(action->act.statename,
			    state->name) == 0) {
				action->act.nextstate = state;
				break;
			}
		}
		if (state == NULL) {
			fprintf(stderr, "error: state '%s' not declared\n",
			    action->act.statename);
			file->errors++;
		}
		break;
	}
	case IFSD_ACTION_CONDITION:
		TAILQ_FOREACH(subaction, &action->act.c.actions, entries)
			link_states(subaction);
		break;
	}
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		err(1, NULL);

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

void
set_expression_depth(struct ifsd_expression *expression, int depth)
{
	expression->depth = depth;
	if (conf->maxdepth < depth)
		conf->maxdepth = depth;
	if (expression->left != NULL)
		set_expression_depth(expression->left, depth + 1);
	if (expression->right != NULL)
		set_expression_depth(expression->right, depth + 1);
}

void
init_state(struct ifsd_state *state)
{
	TAILQ_INIT(&state->interface_states);
	TAILQ_INIT(&state->external_tests);

	if ((state->init = calloc(1, sizeof(*state->init))) == NULL)
		err(1, "init_state: calloc");
	state->init->type = IFSD_ACTION_CONDITION;
	TAILQ_INIT(&state->init->act.c.actions);

	if ((state->body = calloc(1, sizeof(*state->body))) == NULL)
		err(1, "init_state: calloc");
	state->body->type = IFSD_ACTION_CONDITION;
	TAILQ_INIT(&state->body->act.c.actions);
}

struct ifsd_ifstate *
new_ifstate(u_short ifindex, int s)
{
	struct ifsd_ifstate *ifstate = NULL;
	struct ifsd_state *state;

	if (curstate != NULL)
		state = curstate;
	else
		state = &conf->initstate;

	TAILQ_FOREACH(ifstate, &state->interface_states, entries)
		if (ifstate->ifindex == ifindex && ifstate->ifstate == s)
			break;
	if (ifstate == NULL) {
		if ((ifstate = calloc(1, sizeof(*ifstate))) == NULL)
			err(1, NULL);
		ifstate->ifindex = ifindex;
		ifstate->ifstate = s;
		TAILQ_INIT(&ifstate->expressions);
		TAILQ_INSERT_TAIL(&state->interface_states, ifstate, entries);
	}
	ifstate->prevstate = -1;
	ifstate->refcount++;
	return (ifstate);
}

struct ifsd_external *
new_external(char *command, u_int32_t frequency)
{
	struct ifsd_external *external = NULL;
	struct ifsd_state *state;

	if (curstate != NULL)
		state = curstate;
	else
		state = &conf->initstate;

	TAILQ_FOREACH(external, &state->external_tests, entries)
		if (strcmp(external->command, command) == 0 &&
		    external->frequency == frequency)
			break;
	if (external == NULL) {
		if ((external = calloc(1, sizeof(*external))) == NULL)
			err(1, NULL);
		if ((external->command = strdup(command)) == NULL)
			err(1, NULL);
		external->frequency = frequency;
		TAILQ_INIT(&external->expressions);
		TAILQ_INSERT_TAIL(&state->external_tests, external, entries);
	}
	external->prevstatus = -1;
	external->refcount++;
	return (external);
}
@


1.42
log
@Rename one of the "always" variables to "body" for improved readability.
No functional change.
from Rob Pierce.

ok stsp@@ and me
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2017/06/18 12:03:47 benno Exp $	*/
d245 1
a245 1
				curaction = conf->always.init;
d250 1
a250 1
				curaction = conf->always.body;
d346 1
a346 1
			curaction = conf->always.body;
d749 2
a750 2
	init_state(&conf->always);
	curaction = conf->always.body;
d946 1
a946 1
		state = &conf->always;
d973 1
a973 1
		state = &conf->always;
@


1.41
log
@update log.c in ifstated to the same used in bgpd etc.
Done by Rob Pierce <rob AT 2keys DOT ca>, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2017/01/05 13:53:09 krw Exp $	*/
d248 1
a248 1
				curaction = curstate->always;
d250 1
a250 1
				curaction = conf->always.always;
d342 1
a342 1
			curaction = state->always;
d346 1
a346 1
			curaction = conf->always.always;
d750 1
a750 1
	curaction = conf->always.always;
d758 1
a758 1
		link_states(state->always);
d931 1
a931 1
	if ((state->always = calloc(1, sizeof(*state->always))) == NULL)
d933 2
a934 2
	state->always->type = IFSD_ACTION_CONDITION;
	TAILQ_INIT(&state->always->act.c.actions);
@


1.40
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2017/01/05 12:42:18 krw Exp $	*/
d44 1
@


1.39
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2016/06/21 21:35:24 benno Exp $	*/
d777 1
a777 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.38
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2016/01/29 02:22:57 mmcc Exp $	*/
d837 4
a840 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d899 1
a899 1
	TAILQ_FOREACH(sym, &symhead, entry)
d904 1
@


1.37
log
@Fix err.h uses, reporting errno when available and simplifying error
messages.

Partially from Michael Reed.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2014/11/20 05:51:20 jsg Exp $	*/
d145 1
d148 7
@


1.36
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2014/11/03 18:44:36 bluhm Exp $	*/
d269 1
a269 1
				errx(1, "term: calloc");
d277 1
a277 1
				errx(1, "term: calloc");
d290 1
a290 1
				errx(1, "expr: calloc");
d298 1
a298 1
				errx(1, "expr: calloc");
d308 1
a308 1
				errx(1, "expr: calloc");
d329 1
a329 1
				errx(1, "state: calloc");
d688 1
a688 1
		warnx("%s", nfile->name);
d728 1
a728 1
		errx(1, "parse_config calloc");
d875 1
a875 1
		errx(1, "cmdline_symset: malloc");
d943 1
a943 1
			errx(1, "new_ifstate: calloc");
d971 1
a971 1
			errx(1, "new_external: calloc");
d973 1
a973 1
			errx(1, "new_external: strdup");
@


1.35
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2014/11/03 03:42:11 doug Exp $	*/
d571 3
@


1.34
log
@Add gcc format attributes to more warn/error functions in parse.y files.

Fix a few missing or incorrect format characters.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2014/01/22 00:21:16 henning Exp $	*/
d360 1
a360 1
	char		*nfmt;
d364 2
a365 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d367 2
a368 1
	free(nfmt);
@


1.33
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2013/03/06 21:42:40 sthen Exp $	*/
d58 3
a60 1
int		 yyerror(const char *, ...);
d258 1
a258 1
				yyerror("invalid interval: %d", $3);
@


1.32
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d661 2
a662 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		warnx("%s: group/world readable/writeable", fname);
@


1.31
log
@as done in ospf{,6}d/relayd, sync yyerror in various other daemons with
that from bgpd, so that it logs to syslog when daemonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2010/08/03 18:42:40 henning Exp $	*/
d410 1
a410 1
char	*parsebuf;
d412 1
a412 1
char	 pushback_buffer[MAXPUSHBACK];
d505 2
a506 2
	char	 buf[8096];
	char	*p, *val;
d529 1
a529 1
				*p++ = (char)c;
d574 1
a574 1
			*p++ = (char)c;
@


1.30
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2009/03/31 21:03:48 tobias Exp $	*/
d358 1
d362 3
a364 3
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
d366 1
@


1.29
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2008/10/17 13:02:55 henning Exp $	*/
d559 2
a560 1
				else if (next == '\n')
d562 1
a562 1
				else
@


1.28
log
@bring in the findeol() fix from pfctl. list of affected parsers by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2008/03/10 07:40:01 mpf Exp $	*/
d670 1
a670 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d672 5
@


1.27
log
@Fix a null deref in link_state, which happens on config
files which refer to undeclared states.
popfile() needs to be called later.

Found by and OK cnst@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2008/02/26 10:09:58 mpf Exp $	*/
a482 1
	pushback_index = 0;
d486 4
a489 1
		c = lgetc(0);
@


1.26
log
@Have popfile() also close the main config file,
but only do the final popfile call after yyparse() is done.
This also fixes config reload on SIGHUP for some daemons.

Spotted by otto@@. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2007/11/12 23:59:41 mpf Exp $	*/
a730 2
	errors = file->errors;
	popfile();
d737 3
@


1.25
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2007/10/25 06:03:31 pyr Exp $	*/
d52 1
a52 1
} *file;
d434 3
a436 2
			yyerror("reached end of file while parsing quoted string");
			if (popfile() == EOF)
d454 1
a454 1
		if (popfile() == EOF)
d695 1
a695 1
	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
d697 7
a703 8
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
d722 1
@


1.24
log
@sync logging with most other daemons.
ok mcbride@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2007/10/21 08:29:34 pyr Exp $	*/
a450 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d507 1
a507 1
	while ((c = lgetc(0)) == ' ')
@


1.23
log
@sync with other daemons.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2007/10/16 20:01:23 mpf Exp $	*/
d107 1
a107 1
%token	IF RUN SETSTATE EVERY INIT LOGLEVEL
a158 13
		| LOGLEVEL STRING			{
			if (!strcmp($2, "none"))
				conf->loglevel = IFSD_LOG_NONE;
			else if (!strcmp($2, "quiet"))
				conf->loglevel = IFSD_LOG_QUIET;
			else if (!strcmp($2, "normal"))
				conf->loglevel = IFSD_LOG_NORMAL;
			else if (!strcmp($2, "verbose"))
				conf->loglevel = IFSD_LOG_VERBOSE;
			else if (!strcmp($2, "debug"))
				conf->loglevel = IFSD_LOG_DEBUG;
			free($2);
		}
a386 1
		{ "loglevel",		LOGLEVEL},
a734 1
	conf->loglevel = IFSD_LOG_NORMAL;
@


1.22
log
@Allow '=' to end a number in all lexers.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2007/10/16 06:06:49 deraadt Exp $	*/
d690 2
a691 1
	    (nfile->name = strdup(name)) == NULL)
d693 1
d695 1
a740 1
		warn("%s", filename);
@


1.21
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2007/10/13 16:35:21 deraadt Exp $	*/
d599 1
a599 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.20
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2007/10/11 14:39:17 deraadt Exp $	*/
d576 1
a576 1
				if (next == quotec)
d578 2
@


1.19
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2007/09/12 02:09:03 deraadt Exp $	*/
d27 1
d33 1
d36 1
a41 1
#include <limits.h>
d45 19
a63 19
static struct ifsd_config	*conf;
static FILE			*fin = NULL;
static int			 lineno = 1;
static int			 errors = 0;
char				*infile;
char				*start_state;

struct ifsd_action		*curaction;
struct ifsd_state		*curstate = NULL;

int	 yyerror(const char *, ...);
int	 yyparse(void);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(int);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);

d67 1
a67 1
	TAILQ_ENTRY(sym)	 entries;
d73 8
a82 2
int			 symset(const char *, const char *, int);
char			*symget(const char *);
d126 1
a126 1
		| grammar error '\n'		{ errors++; }
d370 1
a370 1
	va_list	ap;
d372 1
a372 1
	errors = 1;
d374 1
a374 1
	fprintf(stderr, "%s:%d: ", infile, yylval.lineno);
d428 1
a428 1
lgetc(int inquot)
d430 1
a430 2
	int	c, next;
	FILE *f = fin;
d446 7
a452 2
	if (inquot) {
		c = getc(f);
d456 2
a457 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d462 2
a463 2
		yylval.lineno = lineno;
		lineno++;
d468 1
a468 1
			c = getc(f);
d470 1
a470 1
		ungetc(c, f);
d474 5
d510 1
a510 1
			lineno++;
d524 1
a524 1
	int	 endc, next, c;
d532 1
a532 1
	yylval.lineno = lineno;
d566 1
a566 1
		endc = c;
d568 1
a568 1
			if ((c = lgetc(1)) == EOF)
d571 1
a571 1
				lineno++;
d574 1
a574 1
				if ((next = lgetc(1)) == EOF)
d576 1
a576 1
				if (next == endc)
d580 1
a580 1
			} else if (c == endc) {
d654 2
a655 2
		yylval.lineno = lineno;
		lineno++;
d662 61
d726 1
d735 1
a735 1
	if ((fin = fopen(filename, "r")) == NULL) {
a739 1
	infile = filename;
d749 2
a750 2

	fclose(fin);
d773 1
a773 1
		next = TAILQ_NEXT(sym, entries);
d780 1
a780 1
			TAILQ_REMOVE(&symhead, sym, entries);
d816 1
a816 1
			errors++;
d833 1
a833 1
	    sym = TAILQ_NEXT(sym, entries))
d842 1
a842 1
			TAILQ_REMOVE(&symhead, sym, entries);
d862 1
a862 1
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d893 1
a893 1
	TAILQ_FOREACH(sym, &symhead, entries)
@


1.18
log
@unchecked conversion from signed 64 to unsigned 32
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2007/09/11 23:30:30 deraadt Exp $	*/
d57 1
a57 1
int	 lgetc(FILE *);
d420 1
a420 1
lgetc(FILE *f)
d423 1
d439 5
d491 1
a491 1
		c = lgetc(fin);
d507 1
a507 1
	int	 endc, c;
d512 1
a512 1
	while ((c = lgetc(fin)) == ' ')
d517 1
a517 1
		while ((c = lgetc(fin)) != '\n' && c != EOF)
d521 1
a521 1
			if ((c = lgetc(fin)) == EOF)
d551 1
a551 1
			if ((c = lgetc(fin)) == EOF)
a552 4
			if (c == endc) {
				*p = '\0';
				break;
			}
d556 10
d575 1
a575 1
			errx(1, "yylex: strdup");
d589 1
a589 1
		} while ((c = lgetc(fin)) != EOF && isdigit(c));
d628 1
a628 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
@


1.17
log
@extend lex to spot numbers in the stream, without impacting the parsing
of ip addresses and such.  this change is being pushed into all the pfctl
derived parsers, starting with the easier ones;  range check written by
mpf; ok mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2006/10/25 18:58:42 henning Exp $	*/
d260 1
a260 1
			if ($3 <= 0) {
@


1.16
log
@strtonum, Pierre-Yves Ritschard <pyr@@spootnik.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2006/10/25 18:57:34 henning Exp $	*/
d82 1
a82 1
		u_int32_t	 number;
d104 1
a104 1
%type	<v.number>	number
a120 15
number		: STRING			{
			u_int32_t	 uval;
			const char	*errstr;

			uval = strtonum($1, 0, UINT_MAX, &errstr);
			if (errstr) {	
				yyerror("number %s is %s", $1, errstr);
				free($1);
				YYERROR;
			} else
				$$ = uval;
			free($1);
		}
		;

d259 6
a264 1
ext_test	: STRING EVERY number {
d565 36
@


1.15
log
@same old debug cruft from bgpd as killed in ospfd and dvrmpd - is it yet
somewhere else?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2006/05/26 01:06:12 deraadt Exp $	*/
a74 1
int			 atoul(char *, u_long *);
d122 2
a123 1
			u_long	ulval;
d125 3
a127 2
			if (atoul($1, &ulval) == -1) {
				yyerror("%s is not a number", $1);
d131 1
a131 1
				$$ = ulval;
a782 16
}

int
atoul(char *s, u_long *ulvalp)
{
	u_long	 ulval;
	char	*ep;

	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
		return (-1);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (-1);
	*ulvalp = ulval;
	return (0);
@


1.14
log
@\<char> is <char> except for \<newline> -- no exceptions.  much like how
other things work.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2006/03/16 06:27:02 mcbride Exp $	*/
a46 1
static int			 pdebug = 1;
d415 1
a415 3
	if (p) {
		if (pdebug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
d417 1
a417 3
	} else {
		if (pdebug > 1)
			fprintf(stderr, "string: %s\n", s);
a418 1
	}
@


1.13
log
@Make ifstated handle config reloads after a parse error. Fixes PR5051
Fix from Michael Knudsen.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2006/03/16 06:17:42 mcbride Exp $	*/
d456 1
a456 3
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, f);
@


1.12
log
@Error out of ifstate.conf parsing instead of dumping core in operation
when a undefined ruleset is referenced.  Fixes PR5049.

Report and troubleshooting from Michael Knudsen.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2006/01/20 00:01:20 millert Exp $	*/
d678 1
@


1.11
log
@Explicitly include limits.h if we are going to use its contents.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2005/08/03 16:29:36 sturm Exp $	*/
d702 5
@


1.10
log
@use action_block in init instead of custom code, permits single line
commands w/o braces in init

ok henning, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2005/02/07 12:41:53 mcbride Exp $	*/
d39 1
@


1.9
log
@Fix error message: set-state, not setstate.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2005/02/03 17:51:12 mpf Exp $	*/
d254 1
a254 1
		} optnl '{' optnl action_l '}' {
@


1.8
log
@Simplify the ifstated syntax:

 "carp0 link up" => carp0.link.up
 "and"           => &&
 "or"            => ||

* Allow one line actions after if statements without braces.
* Remove unecessary parentheses in the example config.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2004/04/28 01:00:50 deraadt Exp $	*/
d214 1
a214 1
				yyerror("setstate must be used inside 'if'");
@


1.7
log
@correct yacc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2004/03/07 16:46:17 henning Exp $	*/
d235 1
a235 1
		} expr optnl '{' optnl action_l '}' {
d241 4
d262 1
a262 1
if_test		: interface LINK UP		{
d265 1
a265 1
		| interface LINK DOWN		{
d268 1
a268 1
		| interface LINK UNKNOWN	{
d393 1
a394 1
		{ "and",		AND},
a401 1
		{ "or",			OR},
d407 2
a408 1
		{ "up",			UP}
d587 1
a587 1
	x != ','))
d589 1
a589 1
	if (isalnum(c) || c == ':' || c == '_') {
@


1.6
log
@plug 18 memory leaks, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2004/03/06 21:47:21 henning Exp $	*/
d256 1
a632 1

@


1.5
log
@pull a fix from bgpd:
plug a memory leak in the lexer.
the issue is this code fragement from yylex():
.		token = lookup(buf);
.		yylval.v.string = strdup(buf);
.		if (yylval.v.string == NULL)
.			err(1, "yylex: strdup");
.		return (token);
lookup() tries to match buf against a list of keywords, and returns the
associated token if it has a match, or the token STRING otherwise.
STRING is the only token that needs (and free()s) yylval.v.string. however,
we assigned memory for it with the strdup in yylex for each and every token.
the fix is obviously only setting yylval.v.string when lookup() returns STRING.
Patrick Latifi noticed that something was leaking with token handling,
analysis and fix by me.
ok deraadt@@
also err instead of errx after strdup failure
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2004/02/15 00:56:01 mcbride Exp $	*/
d127 1
d131 1
d137 2
d152 2
d157 2
d163 1
a163 4
			if ((start_state = strdup($2)) == NULL) {
				yyerror("conf_main: strdup");
				YYERROR;
			}
d176 1
d183 1
d186 1
d203 1
a203 1
			action->act.command = strdup($2);
d213 1
d220 1
a220 2
			if ((action->act.statename = strdup($2)) == NULL)
				err(1, "action: strdup");
d270 1
d332 1
d338 1
a338 2
			if ((state->name = strdup($2)) == NULL)
				errx(1, "state: strdup");
@


1.4
log
@- Check error condition on config; load exit() on initial startup, simply
  warn if loading due to SIGHUP. (pointed out by mpf@@)
- Can't just bcopy the config struct, there are TAILQs. Pass pointers instead.
- Initialise the SIGHUP and routing socket handlers after config is loaded.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2004/02/14 11:24:35 mcbride Exp $	*/
d585 3
a587 4
		token = lookup(buf);
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			errx(1, "yylex: strdup");
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2004/02/05 02:18:55 mcbride Exp $	*/
d600 2
a601 2
int
parse_config(char *filename, struct ifsd_config *xconf)
d606 1
a606 1
	if ((conf = calloc(1, sizeof(struct ifsd_config))) == NULL)
d608 9
d623 1
a623 1
	conf->opts = xconf->opts;
a624 6
	if ((fin = fopen(filename, "r")) == NULL) {
		warn("%s", filename);
		free(conf);
		return (-1);
	}
	infile = filename;
d663 4
a666 2
	bcopy(conf, xconf, sizeof(*conf));
	free(conf);
d668 1
a668 1
	return (errors ? -1 : 0);
@


1.2
log
@Clean up command line options:
- Make -v work as intended.
- Add -n to test config without doing anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2004/02/04 23:47:49 mcbride Exp $	*/
d99 1
a99 1
%token	LINK UP DOWN UNKNOWN ADDED REMOVED 
d176 4
a179 4
                                yyerror("unknown interface %s", $1);
                                YYERROR;
                        }
                }
d189 1
a189 1
action		: RUN STRING 		{
d192 1
a192 1
			if ((action = calloc(1, sizeof(*action))) == NULL) 
d201 1
a201 1
		| SETSTATE STRING 	{
d208 1
a208 1
			if ((action = calloc(1, sizeof(*action))) == NULL) 
d219 1
a219 1
			if ((action = calloc(1, sizeof(*action))) == NULL) 
a241 2
			if (curaction == NULL) errx(1, "curaction == NULL");
				
a246 1
			if (curaction == NULL) errx(1, "curaction == NULL");
d268 1
a268 1
                        curaction->act.c.expression = $$;
d276 1
a276 1
                        curaction->act.c.expression = $$;
d289 1
a289 1
                        curaction->act.c.expression = $$;
d297 1
a297 1
                        curaction->act.c.expression = $$;
d307 1
a307 1
                        curaction->act.c.expression = $$;
d317 1
a317 1
state		: STATE string { 
d357 1
a357 1
        va_list		 ap;
d610 1
a610 1
 
d662 1
a662 1
       
d823 1
a823 1
	
d850 1
a850 1
	
d863 1
a863 1
	} 
@


1.1
log
@Update to ifstated; replace parser, introduce the concept of states,
external tests, and boolean logic. Allows ifstated to handle partial
failures on firewalls that are CARPd to each other.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d617 1
@

