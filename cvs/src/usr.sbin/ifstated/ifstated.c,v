head	1.48;
access;
symbols
	OPENBSD_6_1:1.41.0.18
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.14
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.10
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.12
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.4
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.41.0.8
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.6
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.40.0.8
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.6
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.38.0.4
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.33.0.4
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.30.0.4
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16;
locks; strict;
comment	@ * @;


1.48
date	2017.07.02.15.28.26;	author benno;	state Exp;
branches;
next	1.47;
commitid	O1Rrj73rj6EeHP15;

1.47
date	2017.07.02.14.28.45;	author benno;	state Exp;
branches;
next	1.46;
commitid	Dr4fItaoTgDyYewh;

1.46
date	2017.07.02.14.27.30;	author benno;	state Exp;
branches;
next	1.45;
commitid	2Xe9BR5D8dBy0BPP;

1.45
date	2017.06.28.11.10.08;	author benno;	state Exp;
branches;
next	1.44;
commitid	tUK1smkVTTOdBDTV;

1.44
date	2017.06.28.10.38.16;	author benno;	state Exp;
branches;
next	1.43;
commitid	mztrOCiaDTxWOH3C;

1.43
date	2017.06.27.20.46.34;	author benno;	state Exp;
branches;
next	1.42;
commitid	7lArNVpd4auDn8MQ;

1.42
date	2017.06.18.12.03.47;	author benno;	state Exp;
branches;
next	1.41;
commitid	1ImWCgIqWBjLLpn1;

1.41
date	2013.05.30.19.22.48;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2011.03.15.08.38.07;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.07.21.52.00;	author stsp;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.07.15.14.22;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2010.02.04.13.50.14;	author stevesk;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.25.17.14.57;	author sthen;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.25.09.33.03;	author sthen;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.27.18.50.00;	author stevesk;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.25.06.03.31;	author pyr;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.28.19.28.16;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.16.06.12.58;	author mcbride;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.08.13.50.26;	author camield;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.01.23.23.37;	author mpf;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.01.23.13.09;	author mpf;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.01.22.19.33;	author mpf;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.25.00.31.05;	author mpf;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.23.22.19.40;	author mpf;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.28.16.59.42;	author mpf;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.07.12.38.44;	author mcbride;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.05.21.17.02;	author mpf;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.21.12.04.39;	author mpf;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.15.23.59.11;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.27.11.55.27;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.15.19.42.33;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.10.00.09.42;	author mcbride;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.07.08.49.05;	author mcbride;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.07.08.37.49;	author mcbride;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.26.11.52.59;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.16.05.26.58;	author mcbride;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.15.00.56.01;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.12.19.22.13;	author mcbride;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.12.08.12.58;	author mcbride;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.12.01.43.48;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.12.00.19.42;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.12.00.08.14;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.12.00.04.08;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.05.02.18.55;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.04.23.47.49;	author mcbride;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.23.21.34.30;	author mcbride;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Second diff to rename additional "always" variable in struct ifsd_config.
from Rob Pierce.
Requested by stsp@@
@
text
@/*	$OpenBSD: ifstated.c,v 1.47 2017/07/02 14:28:45 benno Exp $	*/

/*
 * Copyright (c) 2004 Marco Pfatschbacher <mpf@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * ifstated listens to link_state transitions on interfaces
 * and executes predefined commands.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <net/if.h>
#include <net/route.h>
#include <netinet/in.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <stdint.h>
#include <syslog.h>
#include <err.h>
#include <event.h>
#include <unistd.h>
#include <ifaddrs.h>

#include "ifstated.h"
#include "log.h"

struct	 ifsd_config *conf = NULL, *newconf = NULL;

int	 opts = 0;
int	 opt_inhibit = 0;
char	*configfile = "/etc/ifstated.conf";
struct event	rt_msg_ev, sighup_ev, startup_ev, sigchld_ev;

void		startup_handler(int, short, void *);
void		sighup_handler(int, short, void *);
int		load_config(void);
void		sigchld_handler(int, short, void *);
void		rt_msg_handler(int, short, void *);
void		external_handler(int, short, void *);
void		external_exec(struct ifsd_external *, int);
void		check_external_status(struct ifsd_state *);
void		external_evtimer_setup(struct ifsd_state *, int);
void		scan_ifstate(int, int, int);
int		scan_ifstate_single(int, int, struct ifsd_state *);
void		fetch_state(void);
__dead void	usage(void);
void		adjust_expressions(struct ifsd_expression_list *, int);
void		adjust_external_expressions(struct ifsd_state *);
void		eval_state(struct ifsd_state *);
int		state_change(void);
void		do_action(struct ifsd_action *);
void		remove_action(struct ifsd_action *, struct ifsd_state *);
void		remove_expression(struct ifsd_expression *,
		    struct ifsd_state *);

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dhinv] [-D macro=value] [-f file]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct timeval tv;
	int ch, rt_fd;
	int debug = 0;
	unsigned int rtfilter;

	log_init(1, LOG_DAEMON);	/* log to stderr until daemonized */
	log_setverbose(1);

	while ((ch = getopt(argc, argv, "dD:f:hniv")) != -1) {
		switch (ch) {
		case 'd':
			debug = 1;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				errx(1, "could not parse macro definition %s",
				    optarg);
			break;
		case 'f':
			configfile = optarg;
			break;
		case 'h':
			usage();
			break;
		case 'n':
			opts |= IFSD_OPT_NOACTION;
			break;
		case 'i':
			opt_inhibit = 1;
			break;
		case 'v':
			if (opts & IFSD_OPT_VERBOSE)
				opts |= IFSD_OPT_VERBOSE2;
			opts |= IFSD_OPT_VERBOSE;
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	if (opts & IFSD_OPT_NOACTION) {
		if ((newconf = parse_config(configfile, opts)) == NULL)
			exit(1);
		warnx("configuration OK");
		exit(0);
	}

	if (!debug)
		daemon(1, 0);

	event_init();
	log_init(debug, LOG_DAEMON);
	log_setverbose(opts & IFSD_OPT_VERBOSE);

	if ((rt_fd = socket(PF_ROUTE, SOCK_RAW, 0)) < 0)
		err(1, "no routing socket");

	rtfilter = ROUTE_FILTER(RTM_IFINFO);
	if (setsockopt(rt_fd, PF_ROUTE, ROUTE_MSGFILTER,
	    &rtfilter, sizeof(rtfilter)) == -1)	/* not fatal */
		log_warn("%s: setsockopt msgfilter", __func__);

	rtfilter = RTABLE_ANY;
	if (setsockopt(rt_fd, PF_ROUTE, ROUTE_TABLEFILTER,
	    &rtfilter, sizeof(rtfilter)) == -1)	/* not fatal */
		log_warn("%s: setsockopt tablefilter", __func__);

	signal_set(&sigchld_ev, SIGCHLD, sigchld_handler, NULL);
	signal_add(&sigchld_ev, NULL);

	/* Loading the config needs to happen in the event loop */
	timerclear(&tv);
	evtimer_set(&startup_ev, startup_handler, (void *)(long)rt_fd);
	evtimer_add(&startup_ev, &tv);

	event_loop(0);
	exit(0);
}

void
startup_handler(int fd, short event, void *arg)
{
	int rfd = (int)(long)arg;

	if (load_config() != 0) {
		log_warnx("unable to load config");
		exit(1);
	}

	event_set(&rt_msg_ev, rfd, EV_READ|EV_PERSIST, rt_msg_handler, NULL);
	event_add(&rt_msg_ev, NULL);

	signal_set(&sighup_ev, SIGHUP, sighup_handler, NULL);
	signal_add(&sighup_ev, NULL);

	log_info("started");
}

void
sighup_handler(int fd, short event, void *arg)
{
	log_info("reloading config");
	if (load_config() != 0)
		log_warnx("unable to reload config");
}

int
load_config(void)
{
	if ((newconf = parse_config(configfile, opts)) == NULL)
		return (-1);
	if (conf != NULL)
		clear_config(conf);
	conf = newconf;
	conf->initstate.entered = time(NULL);
	fetch_state();
	external_evtimer_setup(&conf->initstate, IFSD_EVTIMER_ADD);
	adjust_external_expressions(&conf->initstate);
	eval_state(&conf->initstate);
	if (conf->curstate != NULL) {
		log_info("initial state: %s", conf->curstate->name);
		conf->curstate->entered = time(NULL);
		conf->nextstate = conf->curstate;
		conf->curstate = NULL;
		while (state_change())
			do_action(conf->curstate->body);
	}
	return (0);
}

void
rt_msg_handler(int fd, short event, void *arg)
{
	char msg[2048];
	struct rt_msghdr *rtm = (struct rt_msghdr *)&msg;
	struct if_msghdr ifm;
	int len;

	len = read(fd, msg, sizeof(msg));

	/* XXX ignore errors? */
	if (len < sizeof(struct rt_msghdr))
		return;

	if (rtm->rtm_version != RTM_VERSION)
		return;

	if (rtm->rtm_type != RTM_IFINFO)
		return;

	memcpy(&ifm, rtm, sizeof(ifm));
	scan_ifstate(ifm.ifm_index, ifm.ifm_data.ifi_link_state, 1);
}

void
sigchld_handler(int fd, short event, void *arg)
{
	check_external_status(&conf->initstate);
	if (conf->curstate != NULL)
		check_external_status(conf->curstate);
}

void
external_handler(int fd, short event, void *arg)
{
	struct ifsd_external *external = (struct ifsd_external *)arg;
	struct timeval tv;

	/* re-schedule */
	timerclear(&tv);
	tv.tv_sec = external->frequency;
	evtimer_set(&external->ev, external_handler, external);
	evtimer_add(&external->ev, &tv);

	/* execute */
	external_exec(external, 1);
}

void
external_exec(struct ifsd_external *external, int async)
{
	char *argp[] = {"sh", "-c", NULL, NULL};
	pid_t pid;
	int s;

	if (external->pid > 0) {
		log_debug("previous command %s [%d] still running, killing it",
		    external->command, external->pid);
		kill(external->pid, SIGKILL);
		waitpid(external->pid, &s, 0);
		external->pid = 0;
	}

	argp[2] = external->command;
	log_debug("running %s", external->command);
	pid = fork();
	if (pid < 0) {
		log_warn("fork error");
	} else if (pid == 0) {
		execv("/bin/sh", argp);
		_exit(1);
		/* NOTREACHED */
	} else {
		external->pid = pid;
	}
	if (!async) {
		waitpid(external->pid, &s, 0);
		external->pid = 0;
		if (WIFEXITED(s))
			external->prevstatus = WEXITSTATUS(s);
	}
}

void
adjust_external_expressions(struct ifsd_state *state)
{
	struct ifsd_external *external;
	struct ifsd_expression_list expressions;

	TAILQ_INIT(&expressions);
	TAILQ_FOREACH(external, &state->external_tests, entries) {
		struct ifsd_expression *expression;

		if (external->prevstatus == -1)
			continue;

		TAILQ_FOREACH(expression, &external->expressions, entries) {
			TAILQ_INSERT_TAIL(&expressions,
			    expression, eval);
			expression->truth = !external->prevstatus;
		}
		adjust_expressions(&expressions, conf->maxdepth);
	}
}

void
check_external_status(struct ifsd_state *state)
{
	struct ifsd_external *external, *end = NULL;
	int status, s, changed = 0;

	/* Do this manually; change ordering so the oldest is first */
	external = TAILQ_FIRST(&state->external_tests);
	while (external != NULL && external != end) {
		struct ifsd_external *newexternal;

		newexternal = TAILQ_NEXT(external, entries);

		if (external->pid <= 0)
			goto loop;

		if (wait4(external->pid, &s, WNOHANG, NULL) == 0)
			goto loop;

		external->pid = 0;
		if (end == NULL)
			end = external;
		if (WIFEXITED(s))
			status = WEXITSTATUS(s);
		else {
			log_warnx("%s exited abnormally", external->command);
			goto loop;
		}

		if (external->prevstatus != status &&
		    (external->prevstatus != -1 || !opt_inhibit)) {
			changed = 1;
			external->prevstatus = status;
		}
		external->lastexec = time(NULL);
		TAILQ_REMOVE(&state->external_tests, external, entries);
		TAILQ_INSERT_TAIL(&state->external_tests, external, entries);
loop:
		external = newexternal;
	}

	if (changed) {
		adjust_external_expressions(state);
		eval_state(state);
	}
}

void
external_evtimer_setup(struct ifsd_state *state, int action)
{
	struct ifsd_external *external;
	int s;

	if (state != NULL) {
		switch (action) {
		case IFSD_EVTIMER_ADD:
			TAILQ_FOREACH(external,
			    &state->external_tests, entries) {
				struct timeval tv;

				/* run it once right away */
				external_exec(external, 0);

				/* schedule it for later */
				timerclear(&tv);
				tv.tv_sec = external->frequency;
				evtimer_set(&external->ev, external_handler,
				    external);
				evtimer_add(&external->ev, &tv);
			}
			break;
		case IFSD_EVTIMER_DEL:
			TAILQ_FOREACH(external,
			    &state->external_tests, entries) {
				if (external->pid > 0) {
					kill(external->pid, SIGKILL);
					waitpid(external->pid, &s, 0);
					external->pid = 0;
				}
				evtimer_del(&external->ev);
			}
			break;
		}
	}
}

#define	LINK_STATE_IS_DOWN(_s)		(!LINK_STATE_IS_UP((_s)))

int
scan_ifstate_single(int ifindex, int s, struct ifsd_state *state)
{
	struct ifsd_ifstate *ifstate;
	struct ifsd_expression_list expressions;
	int changed = 0;

	TAILQ_INIT(&expressions);

	TAILQ_FOREACH(ifstate, &state->interface_states, entries) {
		if (ifstate->ifindex == ifindex) {
			if (ifstate->prevstate != s &&
			    (ifstate->prevstate != -1 || !opt_inhibit)) {
				struct ifsd_expression *expression;
				int truth;

				truth =
				    (ifstate->ifstate == IFSD_LINKUNKNOWN &&
				    s == LINK_STATE_UNKNOWN) ||
				    (ifstate->ifstate == IFSD_LINKDOWN &&
				    LINK_STATE_IS_DOWN(s)) ||
				    (ifstate->ifstate == IFSD_LINKUP &&
				    LINK_STATE_IS_UP(s));

				TAILQ_FOREACH(expression,
				    &ifstate->expressions, entries) {
					expression->truth = truth;
					TAILQ_INSERT_TAIL(&expressions,
					    expression, eval);
					changed = 1;
				}
				ifstate->prevstate = s;
			}
		}
	}

	if (changed)
		adjust_expressions(&expressions, conf->maxdepth);
	return (changed);
}

void
scan_ifstate(int ifindex, int s, int do_eval)
{
	struct ifsd_state *state;
	int cur_eval = 0;

	if (scan_ifstate_single(ifindex, s, &conf->initstate) && do_eval)
		eval_state(&conf->initstate);
	TAILQ_FOREACH(state, &conf->states, entries) {
		if (scan_ifstate_single(ifindex, s, state) &&
		    (do_eval && state == conf->curstate))
			cur_eval = 1;
	}
	/* execute actions _after_ all expressions have been adjusted */
	if (cur_eval)
		eval_state(conf->curstate);
}

/*
 * Do a bottom-up ajustment of the expression tree's truth value,
 * level-by-level to ensure that each expression's subexpressions have been
 * evaluated.
 */
void
adjust_expressions(struct ifsd_expression_list *expressions, int depth)
{
	struct ifsd_expression_list nexpressions;
	struct ifsd_expression *expression;

	TAILQ_INIT(&nexpressions);
	while ((expression = TAILQ_FIRST(expressions)) != NULL) {
		TAILQ_REMOVE(expressions, expression, eval);
		if (expression->depth == depth) {
			struct ifsd_expression *te;

			switch (expression->type) {
			case IFSD_OPER_AND:
				expression->truth = expression->left->truth &&
				    expression->right->truth;
				break;
			case IFSD_OPER_OR:
				expression->truth = expression->left->truth ||
				    expression->right->truth;
				break;
			case IFSD_OPER_NOT:
				expression->truth = !expression->right->truth;
				break;
			default:
				break;
			}
			if (expression->parent != NULL) {
				if (TAILQ_EMPTY(&nexpressions))
				te = NULL;
				TAILQ_FOREACH(te, &nexpressions, eval)
					if (expression->parent == te)
						break;
				if (te == NULL)
					TAILQ_INSERT_TAIL(&nexpressions,
					    expression->parent, eval);
			}
		} else
			TAILQ_INSERT_TAIL(&nexpressions, expression, eval);
	}
	if (depth > 0)
		adjust_expressions(&nexpressions, depth - 1);
}

void
eval_state(struct ifsd_state *state)
{
	struct ifsd_external *external;

	external = TAILQ_FIRST(&state->external_tests);
	if (external == NULL || external->lastexec >= state->entered ||
	    external->lastexec == 0) {
		do_action(state->body);
		while (state_change())
			do_action(conf->curstate->body);
	}
}

/*
 *If a previous action included a state change, process it.
 */
int
state_change(void)
{
	if (conf->nextstate != NULL && conf->curstate != conf->nextstate) {
		log_info("changing state to %s", conf->nextstate->name);
		if (conf->curstate != NULL) {
			evtimer_del(&conf->curstate->ev);
			external_evtimer_setup(conf->curstate,
			    IFSD_EVTIMER_DEL);
		}
		conf->curstate = conf->nextstate;
		conf->nextstate = NULL;
		conf->curstate->entered = time(NULL);
		external_evtimer_setup(conf->curstate, IFSD_EVTIMER_ADD);
		adjust_external_expressions(conf->curstate);
		do_action(conf->curstate->init);
		return (1);
	}
	return (0);
}

/*
 * Run recursively through the tree of actions.
 */
void
do_action(struct ifsd_action *action)
{
	struct ifsd_action *subaction;

	switch (action->type) {
	case IFSD_ACTION_COMMAND:
		log_debug("running %s", action->act.command);
		system(action->act.command);
		break;
	case IFSD_ACTION_CHANGESTATE:
		conf->nextstate = action->act.nextstate;
		break;
	case IFSD_ACTION_CONDITION:
		if ((action->act.c.expression != NULL &&
		    action->act.c.expression->truth) ||
		    action->act.c.expression == NULL) {
			TAILQ_FOREACH(subaction, &action->act.c.actions,
			    entries)
				do_action(subaction);
		}
		break;
	default:
		log_debug("%s: unknown action %d", __func__, action->type);
		break;
	}
}

/*
 * Fetch the current link states.
 */
void
fetch_state(void)
{
	struct ifaddrs *ifap, *ifa;
	char *oname = NULL;
	int sock = socket(AF_INET, SOCK_DGRAM, 0);

	if (getifaddrs(&ifap) != 0)
		err(1, "getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		struct ifreq ifr;
		struct if_data ifrdat;

		if (oname && !strcmp(oname, ifa->ifa_name))
			continue;
		oname = ifa->ifa_name;

		strlcpy(ifr.ifr_name, ifa->ifa_name, sizeof(ifr.ifr_name));
		ifr.ifr_data = (caddr_t)&ifrdat;

		if (ioctl(sock, SIOCGIFDATA, (caddr_t)&ifr) == -1)
			continue;

		scan_ifstate(if_nametoindex(ifa->ifa_name),
		    ifrdat.ifi_link_state, 0);
	}
	freeifaddrs(ifap);
	close(sock);
}

/*
 * Clear the config.
 */
void
clear_config(struct ifsd_config *oconf)
{
	struct ifsd_state *state;

	external_evtimer_setup(&conf->initstate, IFSD_EVTIMER_DEL);
	if (conf != NULL && conf->curstate != NULL)
		external_evtimer_setup(conf->curstate, IFSD_EVTIMER_DEL);
	while ((state = TAILQ_FIRST(&oconf->states)) != NULL) {
		TAILQ_REMOVE(&oconf->states, state, entries);
		remove_action(state->init, state);
		remove_action(state->body, state);
		free(state->name);
		free(state);
	}
	remove_action(oconf->initstate.init, &oconf->initstate);
	remove_action(oconf->initstate.body, &oconf->initstate);
	free(oconf);
}

void
remove_action(struct ifsd_action *action, struct ifsd_state *state)
{
	struct ifsd_action *subaction;

	if (action == NULL || state == NULL)
		return;

	switch (action->type) {
	case IFSD_ACTION_LOG:
		free(action->act.logmessage);
		break;
	case IFSD_ACTION_COMMAND:
		free(action->act.command);
		break;
	case IFSD_ACTION_CHANGESTATE:
		break;
	case IFSD_ACTION_CONDITION:
		if (action->act.c.expression != NULL)
			remove_expression(action->act.c.expression, state);
		while ((subaction =
		    TAILQ_FIRST(&action->act.c.actions)) != NULL) {
			TAILQ_REMOVE(&action->act.c.actions,
			    subaction, entries);
			remove_action(subaction, state);
		}
	}
	free(action);
}

void
remove_expression(struct ifsd_expression *expression,
    struct ifsd_state *state)
{
	switch (expression->type) {
	case IFSD_OPER_IFSTATE:
		TAILQ_REMOVE(&expression->u.ifstate->expressions, expression,
		    entries);
		if (--expression->u.ifstate->refcount == 0) {
			TAILQ_REMOVE(&state->interface_states,
			    expression->u.ifstate, entries);
			free(expression->u.ifstate);
		}
		break;
	case IFSD_OPER_EXTERNAL:
		TAILQ_REMOVE(&expression->u.external->expressions, expression,
		    entries);
		if (--expression->u.external->refcount == 0) {
			TAILQ_REMOVE(&state->external_tests,
			    expression->u.external, entries);
			free(expression->u.external->command);
			event_del(&expression->u.external->ev);
			free(expression->u.external);
		}
		break;
	default:
		if (expression->left != NULL)
			remove_expression(expression->left, state);
		if (expression->right != NULL)
			remove_expression(expression->right, state);
		break;
	}
	free(expression);
}
@


1.47
log
@Remove variable assignment in declaration and add whitespace to improve
readability. No functional change.
from Rob Pierce.

ok stsp@@ and me
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.46 2017/07/02 14:27:30 benno Exp $	*/
d210 1
a210 1
	conf->always.entered = time(NULL);
d212 3
a214 3
	external_evtimer_setup(&conf->always, IFSD_EVTIMER_ADD);
	adjust_external_expressions(&conf->always);
	eval_state(&conf->always);
d253 1
a253 1
	check_external_status(&conf->always);
d466 2
a467 2
	if (scan_ifstate_single(ifindex, s, &conf->always) && do_eval)
		eval_state(&conf->always);
d638 1
a638 1
	external_evtimer_setup(&conf->always, IFSD_EVTIMER_DEL);
d648 2
a649 2
	remove_action(oconf->always.init, &oconf->always);
	remove_action(oconf->always.body, &oconf->always);
@


1.46
log
@Rename one of the "always" variables to "body" for improved readability.
No functional change.
from Rob Pierce.

ok stsp@@ and me
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.45 2017/06/28 11:10:08 benno Exp $	*/
d530 3
a532 1
	struct ifsd_external *external = TAILQ_FIRST(&state->external_tests);
@


1.45
log
@whitespace fixes, from Rob Pierce and me
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.44 2017/06/28 10:38:16 benno Exp $	*/
d221 1
a221 1
			do_action(conf->curstate->always);
d533 1
a533 1
		do_action(state->always);
d535 1
a535 1
			do_action(conf->curstate->always);
d642 1
a642 1
		remove_action(state->always, state);
d647 1
a647 1
	remove_action(oconf->always.always, &oconf->always);
@


1.44
log
@usage() gets __dead attribute, from Rob Pierce
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.43 2017/06/27 20:46:34 benno Exp $	*/
d75 2
a76 1
void		remove_expression(struct ifsd_expression *, struct ifsd_state *);
d155 1
a155 1
	    &rtfilter, sizeof(rtfilter)) == -1)         /* not fatal */
d160 1
a160 1
	    &rtfilter, sizeof(rtfilter)) == -1)         /* not fatal */
d184 1
a184 1
	
d609 1
a609 1
		struct if_data  ifrdat;
a626 2


@


1.43
log
@Hoist some privileged code in preparation for future work.
Based on an approach in vmd with mc146818/ns8250.
diff by Rob Pierce <rob -AT- 2keys -DOT- ca>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.42 2017/06/18 12:03:47 benno Exp $	*/
d56 20
a75 20
void	startup_handler(int, short, void *);
void	sighup_handler(int, short, void *);
int	load_config(void);
void	sigchld_handler(int, short, void *);
void	rt_msg_handler(int, short, void *);
void	external_handler(int, short, void *);
void	external_exec(struct ifsd_external *, int);
void	check_external_status(struct ifsd_state *);
void	external_evtimer_setup(struct ifsd_state *, int);
void	scan_ifstate(int, int, int);
int	scan_ifstate_single(int, int, struct ifsd_state *);
void	fetch_state(void);
void	usage(void);
void	adjust_expressions(struct ifsd_expression_list *, int);
void	adjust_external_expressions(struct ifsd_state *);
void	eval_state(struct ifsd_state *);
int	state_change(void);
void	do_action(struct ifsd_action *);
void	remove_action(struct ifsd_action *, struct ifsd_state *);
void	remove_expression(struct ifsd_expression *, struct ifsd_state *);
d77 1
a77 1
void
@


1.42
log
@update log.c in ifstated to the same used in bgpd etc.
Done by Rob Pierce <rob AT 2keys DOT ca>, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.41 2013/05/30 19:22:48 henning Exp $	*/
d39 1
d91 1
a91 1
	int ch;
d93 1
d149 13
d167 1
a167 1
	evtimer_set(&startup_ev, startup_handler, NULL);
d177 1
a177 5
	int rt_fd;
	unsigned int rtfilter;

	if ((rt_fd = socket(PF_ROUTE, SOCK_RAW, 0)) < 0)
		err(1, "no routing socket");
a182 10

	rtfilter = ROUTE_FILTER(RTM_IFINFO);
	if (setsockopt(rt_fd, PF_ROUTE, ROUTE_MSGFILTER,
	    &rtfilter, sizeof(rtfilter)) == -1)         /* not fatal */
		log_warn("%s: setsockopt msgfilter", __func__);

	rtfilter = RTABLE_ANY;
	if (setsockopt(rt_fd, PF_ROUTE, ROUTE_TABLEFILTER,
	    &rtfilter, sizeof(rtfilter)) == -1)         /* not fatal */
		log_warn("%s: setsockopt tablefilter", __func__);
d184 1
a184 1
	event_set(&rt_msg_ev, rt_fd, EV_READ|EV_PERSIST, rt_msg_handler, NULL);
@


1.41
log
@setsockopt to see messages for interfaces in all routing domains again
instead of just the primary one.
problem reported along with the right idea on how to fix it by Sean
Gallagher (sean at teletech.com.au), actual fix by yours truly. Thanks Sean!
ok ryan claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.39 2011/03/15 08:38:07 okan Exp $	*/
d39 1
d46 1
d93 2
a94 1
	log_init(1);
d144 2
a145 1
	log_init(debug);
d176 1
a176 1
		log_warn("startup_handler: setsockopt msgfilter");
d181 1
a181 1
		log_warn("startup_handler: setsockopt tablefilter");
d587 1
a587 1
		log_debug("do_action: unknown action %d", action->type);
@


1.40
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d172 6
a177 1
		log_warn("startup_handler: setsockopt");
@


1.39
log
@use appropriate timerclear macro - from Christiano F. Haesbaert

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.38 2010/07/07 21:52:00 stsp Exp $	*/
d406 1
a406 2
#define	LINK_STATE_IS_DOWN(_s)						\
	(!LINK_STATE_IS_UP((_s)) && (_s) != LINK_STATE_UNKNOWN)
@


1.38
log
@Make ifstated cause a little less noise in /var/log/daemon.
State transitions are still logged, but commands run are now
printed only in debug mode (ifstated -d).

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.37 2010/06/07 15:14:22 deraadt Exp $	*/
d147 1
a147 2
	tv.tv_usec = 0;
	tv.tv_sec = 0;
d254 1
a254 1
	tv.tv_usec = 0;
d384 1
a384 1
				tv.tv_usec = 0;
@


1.37
log
@setproctitle(NULL) is not needed, Michael Lechtermann; ok mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.36 2010/02/04 13:50:14 stevesk Exp $	*/
d272 1
a272 1
		log_info("previous command %s [%d] still running, killing it",
d564 1
a564 1
		log_info("running %s", action->act.command);
@


1.36
log
@remove assumption that internal IFSD_LINK* defines are the same as
LINK_STATE* defines in <net/if.h>, which were changed Sep 14.  this
fixes link state down being treated as up.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.35 2009/06/25 17:14:57 sthen Exp $	*/
d137 1
a137 1
	if (!debug) {
a138 2
		setproctitle(NULL);
	}
@


1.35
log
@fix the function name in log_warn() text, it was borrowed from some
previous test code of mine.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.34 2009/06/25 09:33:03 sthen Exp $	*/
d409 3
d428 5
a432 1
				truth = (ifstate->ifstate == s) ||
@


1.34
log
@Teach ifstated to use ROUTE_FILTER. Requested by claudio@@.
ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.33 2008/05/12 19:15:02 pyr Exp $	*/
d175 1
a175 1
		log_warn("kr_init: setsockopt ROUTE_MSGFILTER");
@


1.33
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.32 2007/11/27 18:50:00 stevesk Exp $	*/
d162 1
d172 5
@


1.32
log
@remove some unneeded #includes; ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.31 2007/10/25 06:03:31 pyr Exp $	*/
d124 5
@


1.31
log
@sync logging with most other daemons.
ok mcbride@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.30 2006/11/28 19:28:16 reyk Exp $	*/
a37 1
#include <fcntl.h>
a40 1
#include <util.h>
a41 2
#include <syslog.h>
#include <stdarg.h>
@


1.30
log
@handle the new link states as UP
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.29 2006/03/16 06:12:58 mcbride Exp $	*/
a52 1
int	 opt_debug = 0;
a76 2
void	log_init(int);
void	logit(int, const char *, ...);
d93 3
d100 1
a100 1
			opt_debug = 1;
d136 1
a136 1
	if (!opt_debug) {
d142 1
a142 1
	log_init(opt_debug);
d166 1
a166 1
		logit(IFSD_LOG_QUIET, "unable to load config");
d176 1
a176 1
	logit(IFSD_LOG_NORMAL, "started");
d182 1
a182 1
	logit(IFSD_LOG_NORMAL, "reloading config");
d184 1
a184 1
		logit(IFSD_LOG_QUIET, "unable to reload config");
d201 1
a201 2
		logit(IFSD_LOG_NORMAL,
		    "initial state: %s", conf->curstate->name);
d267 1
a267 2
		logit(IFSD_LOG_NORMAL,
		    "previous command %s [%d] still running, killing it",
d275 1
a275 1
	logit(IFSD_LOG_VERBOSE, "running %s", external->command);
d278 1
a278 1
		logit(IFSD_LOG_QUIET, "fork error");
d341 1
a341 2
			logit(IFSD_LOG_QUIET,
			    "%s exited abnormally", external->command);
d525 1
a525 2
		logit(IFSD_LOG_NORMAL, "changing state to %s",
		    conf->nextstate->name);
d552 1
a552 1
		logit(IFSD_LOG_NORMAL, "running %s", action->act.command);
d568 1
a568 2
		logit(IFSD_LOG_DEBUG, "do_action: unknown action %d",
		    action->type);
a694 34
}

void
log_init(int n_debug)
{
	extern char	*__progname;

	if (!n_debug)
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);
}

void
logit(int level, const char *fmt, ...)
{
	va_list	 ap;
	char	*nfmt;

	if (conf != NULL && level > conf->loglevel)
		return;

	va_start(ap, fmt);
	if (opt_debug) {
		/* best effort in out of mem situations */
		if (asprintf(&nfmt, "ifstated: %s\n", fmt) != -1) {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
		} else {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		}
	} else
		vsyslog(LOG_NOTICE, fmt, ap);

	va_end(ap);
@


1.29
log
@Kill useless arguments to libevent *_set() functions.

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.28 2006/02/08 13:50:26 camield Exp $	*/
d421 3
a423 1
				truth = (ifstate->ifstate == s);
@


1.28
log
@- configuration file can have relative path
- do not suppress logging if there is no configuration yet, otherwise
  we cannot log that configuration parsing failed

ok mpf@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.27 2006/02/01 23:23:37 mpf Exp $	*/
d144 1
a144 1
	signal_set(&sigchld_ev, SIGCHLD, sigchld_handler, &sigchld_ev);
d150 1
a150 1
	evtimer_set(&startup_ev, startup_handler, &startup_ev);
d170 1
a170 2
	event_set(&rt_msg_ev, rt_fd, EV_READ|EV_PERSIST,
	    rt_msg_handler, &rt_msg_ev);
d173 1
a173 1
	signal_set(&sighup_ev, SIGHUP, sighup_handler, &sighup_ev);
@


1.27
log
@Simplify expression code. Patch from markus@@.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.26 2006/02/01 23:13:09 mpf Exp $	*/
d137 1
a137 1
		daemon(0, 0);
d166 1
a166 1
		logit(IFSD_LOG_NORMAL, "unable to load config");
d185 1
a185 1
		logit(IFSD_LOG_NORMAL, "unable to reload config");
d716 1
a716 1
	if (conf == NULL || level > conf->loglevel)
@


1.26
log
@Run external tests synchronous at state changes and
call adjust_external_expressions() which updates the
expressions for all states.
Address similar state caching problems for external tests as
in previous commit.

Don't ignore set-state actions if they are happening right
after a state change. (Based on a patch from Holger Mikolon).

ok markus@@, testing sturm@@, ok mcbride@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.24 2006/01/25 00:31:05 mpf Exp $	*/
d313 1
a313 4
			if (external->prevstatus == 0)
				expression->truth = 1;
			else
				expression->truth = 0;
d422 1
a422 4
				if (ifstate->ifstate == s)
					truth = 1;
				else
					truth = 0;
d478 2
a479 5
				if (expression->left->truth &&
				    expression->right->truth)
					expression->truth = 1;
				else
					expression->truth = 0;
d482 2
a483 5
				if (expression->left->truth ||
				    expression->right->truth)
					expression->truth = 1;
				else
					expression->truth = 0;
d486 1
a486 4
				if (expression->right->truth)
					expression->truth = 0;
				else
					expression->truth = 1;
@


1.25
log
@If we reenter a state, it still has the old link state values cached.
Therefore, if it enters a state without calling scan_ifstate()
(e.g. through an external-test) ifstated will do the wrong thing (tm).
Change scan_ifstate() to first walk over all states and update the
expressions _before_ they are evaluated.
Help and ok markus@@, testing sturm@@, ok mcbride@@.
@
text
@d64 1
a64 1
void	external_async_exec(struct ifsd_external *);
d72 1
d74 1
a74 1
void	state_change(void);
d198 2
d207 2
a208 1
		eval_state(conf->nextstate);
a209 1
	external_evtimer_setup(&conf->always, IFSD_EVTIMER_ADD);
d258 1
a258 1
	external_async_exec(external);
d262 1
a262 1
external_async_exec(struct ifsd_external *external)
d289 31
a325 1
	struct ifsd_expression_list expressions;
a327 2
	TAILQ_INIT(&expressions);

a353 2
			struct ifsd_expression *expression;

d355 1
a355 9
			TAILQ_FOREACH(expression,
			    &external->expressions, entries) {
				TAILQ_INSERT_TAIL(&expressions,
				    expression, eval);
				if (status == 0)
					expression->truth = 1;
				else
					expression->truth = 0;
			}
a359 1
		external->prevstatus = status;
d365 1
a365 1
		adjust_expressions(&expressions, conf->maxdepth);
d384 1
a384 1
				external_async_exec(external);
d530 2
a531 1
		state_change();
d538 1
a538 1
void
d553 1
d555 1
d557 1
@


1.24
log
@Remove gratuitous fetch_state() calls in state_change().
It could race with a second incoming routing message, which would
not trigger any action, because of the already updated status cache.
Found by markus@@.
OK markus@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.23 2006/01/23 22:19:40 mpf Exp $	*/
d67 2
a68 1
int	scan_ifstate(int, int, struct ifsd_state *);
d231 1
a231 7

	if (scan_ifstate(ifm.ifm_index, ifm.ifm_data.ifi_link_state,
	    &conf->always))
		eval_state(&conf->always);
	if ((conf->curstate != NULL) && scan_ifstate(ifm.ifm_index,
	    ifm.ifm_data.ifi_link_state, conf->curstate))
		eval_state(conf->curstate);
d390 1
a390 1
scan_ifstate(int ifindex, int s, struct ifsd_state *state)
d427 18
d596 1
a596 4
		    ifrdat.ifi_link_state, &conf->always);
		if (conf->curstate != NULL)
			scan_ifstate(if_nametoindex(ifa->ifa_name),
			    ifrdat.ifi_link_state, conf->curstate);
@


1.23
log
@Open the routing socket before load_config() calls fetch_state().
Otherwise we could loose routing messages that arrive in between.                                                                OK markus@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.22 2005/07/28 16:59:42 mpf Exp $	*/
a518 1
		fetch_state();
a519 1
		fetch_state();
@


1.22
log
@Fix two situations where ifstated was leaking zombies.
Tested by sturm@@ OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.21 2005/02/07 12:38:44 mcbride Exp $	*/
d160 3
a166 3

	if ((rt_fd = socket(PF_ROUTE, SOCK_RAW, 0)) < 0)
		err(1, "no routing socket");
@


1.21
log
@Fix protos, and a KNF nit. From Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.20 2004/10/05 21:17:02 mpf Exp $	*/
d268 1
d275 1
d359 1
d384 1
@


1.20
log
@Use priority instead of facility in vsyslog()
Pointed out by Peter Philipp. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.19 2004/09/21 12:04:39 mpf Exp $	*/
a69 1
void	doconfig(const char*);
d77 1
a77 1
void	logit(int level, const char *fmt, ...);
d82 1
a82 1
	extern char* __progname;
@


1.19
log
@Start external tests and init commands also in the initial state.
Log the pid when killing an external program.
Avoid a possible NULL dereference.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.18 2004/06/15 23:59:11 deraadt Exp $	*/
d710 1
a710 1
		vsyslog(LOG_DAEMON, fmt, ap);
@


1.18
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.17 2004/04/27 11:55:27 jmc Exp $	*/
d202 3
a204 1
		eval_state(conf->curstate);
d272 2
a273 2
		    "previous command %s still running, killing it",
		    external->command);
d491 2
a492 1
	if (external == NULL || external->lastexec >= state->entered) {
d507 2
a508 2
		evtimer_del(&conf->curstate->ev);
		if (conf->curstate != NULL)
d511 1
@


1.17
log
@various small fixes;
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.16 2004/03/15 19:42:33 markus Exp $	*/
d86 1
a86 1
		__progname);
d93 1
a94 1
	struct timeval tv;
a210 1
	struct if_msghdr ifm;
d213 1
d265 1
a266 1
	char *argp[] = {"sh", "-c", NULL, NULL};
@


1.16
log
@call daemon(3) early; from tholo@@; ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.15 2004/03/10 00:09:42 mcbride Exp $	*/
d85 1
a85 1
	fprintf(stderr, "usage: %s [-dhinv] [-D macro=value] [-f config]\n",
@


1.15
log
@Plug memory leak on SIGHUP. From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.14 2004/03/07 08:49:05 mcbride Exp $	*/
a127 2
	event_init();

a134 2
	log_init(opt_debug);

d139 3
@


1.14
log
@Document -v in ifstated.8 and usage() and use __progname in usage().

Fix from merith at redmoon dot openbsd dot de, with slightly modified wording.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.13 2004/03/07 08:37:49 mcbride Exp $	*/
d610 1
@


1.13
log
@Don't try to dereference null configuration.

Fix from merith at redmoon dot openbsd dot de.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.12 2004/02/26 11:52:59 henning Exp $	*/
d83 4
a86 1
	fprintf(stderr, "usage: ifstated [-dhinv] [-f config]\n");
@


1.12
log
@bring in log_init() from bgpd which gives us openlog(), ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.11 2004/02/16 05:26:58 mcbride Exp $	*/
d596 1
a596 1
	if (conf->curstate != NULL)
d689 1
a689 1
	if (level > conf->loglevel)
@


1.11
log
@freeifaddrs() data from getifaddrs()

from Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.10 2004/02/15 00:56:01 mcbride Exp $	*/
d77 1
d134 2
d672 9
@


1.10
log
@- Check error condition on config; load exit() on initial startup, simply
  warn if loading due to SIGHUP. (pointed out by mpf@@)
- Can't just bcopy the config struct, there are TAILQs. Pass pointers instead.
- Initialise the SIGHUP and routing socket handlers after config is loaded.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.9 2004/02/12 19:22:13 mcbride Exp $	*/
d578 1
@


1.9
log
@Add missing \n to logit(), reverse logic on asprintf error so the error case
comes last.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.8 2004/02/12 08:12:58 mcbride Exp $	*/
d50 1
a50 1
struct	 ifsd_config conf;
d52 1
d56 1
d60 1
a60 1
void	load_config(void);
a74 1
void	clear_config(struct ifsd_config *);
d89 1
a89 2
	struct event startup_ev, sighup_ev, sigchld_ev, rt_msg_ev;
	int rt_fd, ch;
d109 1
a109 1
			conf.opts |= IFSD_OPT_NOACTION;
d115 3
a117 3
			if (conf.opts & IFSD_OPT_VERBOSE)
				conf.opts |= IFSD_OPT_VERBOSE2;
			conf.opts |= IFSD_OPT_VERBOSE;
d126 2
a127 2
	if (conf.opts & IFSD_OPT_NOACTION) {
		if (parse_config(configfile, &conf) != 0)
a137 10
	if ((rt_fd = socket(PF_ROUTE, SOCK_RAW, 0)) < 0)
		err(1, "no routing socket");

	event_set(&rt_msg_ev, rt_fd, EV_READ|EV_PERSIST,
	    rt_msg_handler, &rt_msg_ev);
	event_add(&rt_msg_ev, NULL);

	signal_set(&sighup_ev, SIGHUP, sighup_handler, &sighup_ev);
	signal_add(&sighup_ev, NULL);

d154 17
a171 1
	load_config();
d178 2
a179 2
	clear_config(&conf);
	load_config();
d182 1
a182 1
void
d185 6
a190 2
	parse_config(configfile, &conf);
	conf.always.entered = time(NULL);
d192 2
a193 2
	eval_state(&conf.always);
	if (conf.curstate != NULL) {
d195 3
a197 3
		    "initial state: %s", conf.curstate->name);
		conf.curstate->entered = time(NULL);
		eval_state(conf.curstate);
d199 2
a200 1
	external_evtimer_setup(&conf.always, IFSD_EVTIMER_ADD);
d226 5
a230 5
	    &conf.always))
		eval_state(&conf.always);
	if ((conf.curstate != NULL) && scan_ifstate(ifm.ifm_index,
	    ifm.ifm_data.ifi_link_state, conf.curstate))
		eval_state(conf.curstate);
d236 3
a238 3
	check_external_status(&conf.always);
	if (conf.curstate != NULL)
		check_external_status(conf.curstate);
d342 1
a342 1
		adjust_expressions(&expressions, conf.maxdepth);
d418 1
a418 1
		adjust_expressions(&expressions, conf.maxdepth);
d496 1
a496 1
	if (conf.nextstate != NULL && conf.curstate != conf.nextstate) {
d498 9
a506 8
		    conf.nextstate->name);
		evtimer_del(&conf.curstate->ev);
		if (conf.curstate != NULL)
			external_evtimer_setup(conf.curstate, IFSD_EVTIMER_DEL);
		conf.curstate = conf.nextstate;
		conf.nextstate = NULL;
		conf.curstate->entered = time(NULL);
		external_evtimer_setup(conf.curstate, IFSD_EVTIMER_ADD);
d508 1
a508 1
		do_action(conf.curstate->init);
d527 1
a527 1
		conf.nextstate = action->act.nextstate;
d573 2
a574 2
		    ifrdat.ifi_link_state, &conf.always);
		if (conf.curstate != NULL)
d576 1
a576 1
			    ifrdat.ifi_link_state, conf.curstate);
d591 3
a593 3
	external_evtimer_setup(&conf.always, IFSD_EVTIMER_DEL);
	if (conf.curstate != NULL)
		external_evtimer_setup(conf.curstate, IFSD_EVTIMER_DEL);
d676 1
a676 1
	if (level > conf.loglevel)
@


1.8
log
@Add missing \n on usage. From Daniel Cavanagh <nofsk@@vtown.com.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.7 2004/02/12 01:43:48 henning Exp $	*/
d670 4
a673 1
		if (asprintf(&nfmt, "ifstated: %s", fmt) == -1) {
a675 3
		} else {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
@


1.7
log
@the macro terminator suggests: hastalavista, LOG()
use a logit() function with varargs and bells and whistles instead of this
macro gore in LOG with static # of args that results in highlights like
LOG(level, "%s", "started")
logit blatantly stolenb from bgpd
test and ok and "remove the \n then" ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.6 2004/02/12 00:19:42 henning Exp $	*/
d81 1
a81 1
	fprintf(stderr, "usage: ifstated [-dhinv] [-f config]");
@


1.6
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.5 2004/02/12 00:08:14 henning Exp $	*/
d76 1
a76 9

#define LOG(l,s,a) do {					\
	if (l <= conf.loglevel) {			\
		if (opt_debug)				\
			printf("ifstated: " s , a );	\
		else					\
			syslog(LOG_DAEMON, s , a);	\
	}						\
} while(0)
d81 1
a81 1
	fprintf(stderr, "usage: ifstated [-dhinv] [-f config]\n");
d129 1
a129 1
		warnx("configuration OK\n");
d164 1
a164 1
	LOG(IFSD_LOG_NORMAL, "%s\n", "started");
d171 1
a171 1
	LOG(IFSD_LOG_NORMAL, "%s\n", "reloading config");
d184 2
a185 2
		LOG(IFSD_LOG_NORMAL,
		    "initial state: %s\n", conf.curstate->name);
d253 2
a254 2
		LOG(IFSD_LOG_NORMAL,
		    "previous command %s still running, killing it\n",
d261 1
a261 1
	LOG(IFSD_LOG_VERBOSE, "running %s\n", external->command);
d264 1
a264 1
		LOG(IFSD_LOG_QUIET, "%s", "fork error");
d302 1
a302 1
			LOG(IFSD_LOG_QUIET,
d486 1
a486 1
		LOG(IFSD_LOG_NORMAL, "changing state to %s\n",
d511 1
a511 1
		LOG(IFSD_LOG_NORMAL, "running %s\n", action->act.command);
d527 1
a527 1
		LOG(IFSD_LOG_DEBUG, "do_action: unknown action %d",
d656 25
@


1.5
log
@we need to memcpy out the ifmsghdr, it has different alignent requirements
then the char buffer and sparc64 hates unaligned shitz, ryan hshoexer ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.3 2004/02/05 02:18:55 mcbride Exp $	*/
d53 2
a54 2
int	 opt_inhibit = 0; 
char 	*configfile = "/etc/ifstated.conf";
d99 1
a99 1
	
d108 1
a108 1
				    optarg); 
d202 1
a202 1
{       
d208 1
a208 1
	len = read(fd, msg, sizeof(msg)); 
d249 1
a249 1
	
d261 1
a261 1
		LOG(IFSD_LOG_NORMAL, 
d286 1
a286 1
	struct ifsd_expression_list expressions;	
d288 1
a288 1
	
d369 1
a369 1
			   &state->external_tests, entries) {
d385 1
a385 1
	struct ifsd_expression_list expressions;	
a391 1
			
d460 1
a460 1
			if (expression->parent != NULL){ 
d506 1
a506 1
	} 
d550 1
a550 1
	
@


1.4
log
@bit KNF, to stderr what belongs to stderr, err where you mean err and not
errx as written
ryan hshoexer ok
@
text
@d203 1
a203 1
	struct if_msghdr *ifm;
d220 1
a220 1
	ifm = (struct if_msghdr *)rtm;
d222 1
a222 1
	if (scan_ifstate(ifm->ifm_index, ifm->ifm_data.ifi_link_state,
d225 2
a226 2
	if ((conf.curstate != NULL) && scan_ifstate(ifm->ifm_index,
	    ifm->ifm_data.ifi_link_state, conf.curstate))
@


1.3
log
@Clean up command line options:
- Make -v work as intended.
- Add -n to test config without doing anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.2 2004/02/04 23:47:49 mcbride Exp $	*/
a49 1

d137 1
a137 1
		printf("configuration OK\n");
d147 1
a147 1
                errx(1, "no routing socket");
d207 1
a207 1
        
d553 1
a553 1
                err(1, "getifaddrs");
@


1.2
log
@Update to ifstated; replace parser, introduce the concept of states,
external tests, and boolean logic. Allows ifstated to handle partial
failures on firewalls that are CARPd to each other.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifstated.c,v 1.1 2004/01/23 21:34:30 mcbride Exp $	*/
d90 1
a90 1
	fprintf(stderr, "usage: ifstated [-hdi] [-f config]\n");
d101 1
a101 1
	while ((ch = getopt(argc, argv, "dD:f:hi")) != -1) {
d117 3
d135 6
a140 3
	if (parse_config(configfile, &conf) != 0)
		errx(1, NULL);

@


1.1
log
@ifstated, from mpf@@.  This daemon listens on the routing socket for
interface link state changes and runs commands when these changes occur.
This is particularly useful with carp(4) interfaces; stay tuned for
additional features and documentation.

ok deraadt@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
d29 1
d41 1
d46 1
d48 1
a49 2
#define CMD_LENGTH 100
#define CONF_LINES 50
d51 4
a54 9
struct conf_t {
	u_short dev;			/* if_index  */
	u_char state;			/* if_link_state */
	char cmd[CMD_LENGTH];
} conf_table[CONF_LINES];

char	*state_name[] = { "UNKNOWN", "DOWN", "UP" };
int	opt_debug = 0;
int	opt_inhibit = 0; 		/* don't run scripts on startup */
d57 10
a66 8
#define MAX_IFINDEX 64
int 	prev_states[MAX_IFINDEX]; 	/* -1 to trigger init */

volatile sig_atomic_t got_sighup;

void	loop(void);
void	eval_rtmsg(struct rt_msghdr *, int);
void	scan_table(int, int);
d70 16
a85 6
void	sighup_handler(int);
#define LOG(s,a) if (opt_debug) \
	printf("ifstated: " s , a ); \
	else \
	syslog(LOG_DAEMON, s , a);

d97 5
a101 4
	int ch;
	struct sigaction sact;

	while ((ch = getopt(argc, argv, "hdif:")) != -1) {
d103 11
a116 3
		case 'd':
			opt_debug = 1;
			break;
d120 4
a123 2
		case 'f':
			configfile = optarg;
d130 4
a133 1
	doconfig(configfile);
a134 6
	bzero((char *)&sact, sizeof sact);
	sigemptyset(&sact.sa_mask);
	sact.sa_flags = 0;
	/* sact.sa_flags |= SA_RESTART; */
	sact.sa_handler = sighup_handler;
	(void) sigaction(SIGHUP, &sact, NULL);
d141 2
a142 1
	LOG("%s\n", "started");
d144 15
a158 1
	loop();
d160 2
a161 2
	LOG("%s\n", "dropped out of main loop. exiting");
	return (0);
d165 1
a165 1
doconfig(const char *conf)
d167 3
a169 7
	FILE *fconfig = NULL;
	char *line = NULL;
	size_t len, lineno = 0;
	int device = -1;
	int state = -1;
	int nrofstates = sizeof(state_name) / sizeof(char *);
	int cf_line = 0;
d171 7
a177 1
	fconfig = fopen(conf, "r");
d179 15
a193 2
	if (fconfig == NULL)
		errx(1, "could not open config: %s\n", conf);
d195 9
a203 2
	bzero(conf_table, sizeof(conf_table));
	bzero(prev_states, sizeof(prev_states));
d205 3
a207 2
	while ((line = fparseln(fconfig, &len, &lineno, 
	    NULL, FPARSELN_UNESCALL)) != NULL) {
d209 2
a210 7
		char statename[20];
		char devname[IF_NAMESIZE];
		int i;
		char *cp;
		
#define WS      " \t\n"
		cp = line;
d212 2
a213 6
		cp += strspn(cp, WS);
		if (cp[0] == '\0') {
			/* empty line */
			free(line);
			continue;
		}
d215 1
a215 2
		if (cf_line >= CONF_LINES)
			errx(1, "too much lines in config\n");
d217 7
a223 15
		/* commands */
		if (line[0] == ' ' || line[0] == '\t') {
			cp = line;
			while (*cp == ' ' || *cp == '\t')
				cp++;

			if (state == -1)
				errx(1, "no context for config line: %lu\n",
				    (u_long) lineno);

			conf_table[cf_line].dev = device;
			conf_table[cf_line].state = state;
			snprintf(conf_table[cf_line].cmd, CMD_LENGTH, "%s", cp);
			/* read state via fetch_state() at startup */
			prev_states[device] = -1;
d225 7
a231 4
			cf_line++;
			free(line);
			continue;
		}
d233 5
a237 2
		/* context */
		state = -1;
d239 9
a247 2
		if (sscanf(line, "%[^.].%19[^:]\n", devname, statename) != 2)
			errx(1, "bad state definition at: %d\n", lineno);
d249 5
a253 2
		if ((device = if_nametoindex(devname)) == 0)
			errx(1, "no such device %s at: %d\n", devname, lineno);
d255 7
a261 4
		for (i = nrofstates - 1; i >= 0; i--)
			if (strncmp(state_name[i], statename, 
			    strlen(state_name[i])) == 0)
				state = i;
d263 11
a273 7
		if (state == -1)
			errx(1, "bad state definition at: %d\n", lineno);

		if (device >= MAX_IFINDEX)
			errx(1, "ifindex exceeded at: %d\n", lineno);

		free(line);
a274 1
	fclose(fconfig);
d278 1
a278 1
loop(void)
d280 5
a284 3
	int sockfd;
	int n;
	char msg[2048];
d286 23
a308 8
	if ((sockfd = socket(PF_ROUTE, SOCK_RAW, 0)) < 0)
		errx(1, "no routing socket");

	if (!opt_inhibit)
		fetch_state();

	for (;;) {
		n = read(sockfd, msg, sizeof(msg)); 
d310 14
a323 7
		/* reread config, run commands for current states */
		if (got_sighup) {
			got_sighup = 0;
			LOG("%s\n", "restart");
			doconfig(configfile);
			if (!opt_inhibit)
				fetch_state();
d325 7
d333 3
a335 1
		eval_rtmsg((struct rt_msghdr *) msg, n);
d340 1
a340 1
sighup_handler(int x)
d342 32
a373 1
	got_sighup = 1;
d376 2
a377 2
void
eval_rtmsg(struct rt_msghdr *rtm, int msglen)
d379 30
a408 1
	struct if_msghdr *ifm;
d410 4
a413 3
	/* XXX ignore errors? */
	if (msglen < sizeof(struct rt_msghdr))
		return;
d415 10
a424 2
	if (rtm->rtm_version != RTM_VERSION)
		return;
d426 46
a471 2
	if (rtm->rtm_type != RTM_IFINFO)
		return;
d473 8
a480 2
	ifm = (struct if_msghdr *)rtm;
	scan_table(ifm->ifm_index, ifm->ifm_data.ifi_link_state);
d483 21
d506 1
a506 2
 * Scan conf_table for commands to run.
 * Ignore, if there was no change to the previous state.
d509 1
a509 1
scan_table(int if_index, int state)
d511 1
a511 7
	int i = 0;

	while (conf_table[i].cmd[0] != '\0') {
		if (conf_table[i].dev == if_index &&
		    conf_table[i].state == state &&
		    if_index <= MAX_IFINDEX &&
		    prev_states[if_index] != state) {
d513 15
a527 2
			LOG("%s\n", conf_table[i].cmd);
			system(conf_table[i].cmd);
d529 5
a533 1
		i++;
a534 1
	prev_states[if_index] = state;
d537 3
a539 1
/* Fetch the current link states. */
d543 2
a544 1
	int i;
d547 4
a550 1
	for (i = 0; i < MAX_IFINDEX; i++) {
d554 1
a554 3
		char if_name[IF_NAMESIZE];

		if (prev_states[i] != -1)
d556 1
d558 1
a558 3
		if_indextoname(i, if_name);

		strlcpy(ifr.ifr_name, if_name, sizeof(ifr.ifr_name));
d564 62
a625 1
		scan_table(i, ifrdat.ifi_link_state);
d627 31
d659 1
a659 1
	close(sock);
@

