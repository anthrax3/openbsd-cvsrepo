head	1.8;
access;
symbols
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.8
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.6
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.04.28.06.57.41;	author henning;	state dead;
branches;
next	1.7;

1.7
date	2002.09.06.19.52.30;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.18.03.44.06;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.11.06.01.19;	author nordin;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.24.06.05.11;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.03.16.04.40;	author ericj;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.21.00.33.55;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.08.18.03.43.34;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.8
log
@It is a big pleasure for me to remove this highe pile of gunk from the tree.
dhclient, dhcrelay and dhcpd have been factored out and cleaned up big time,
dhcpd and dhcrelay chroot itself, drop privileges and lock their bpf
descriptors after applyiing read/write filters now, and this pile of ISC code
with it's lovely char ServerName; /* Name of Server */ constructs is
obsolete.
theo ok, I owe you some beers for this pleasure
@
text
@/* dhcpd.c

   DHCP Server Daemon. */

/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999
 * The Internet Software Consortium.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */


static char copyright[] =
"Copyright 1995, 1996, 1997, 1998, 1999 The Internet Software Consortium.";
static char arr [] = "All rights reserved.";
static char message [] = "Internet Software Consortium DHCP Server";
static char contrib [] = "Please contribute if you find this software useful.";
static char url [] = "For info, please visit http://www.isc.org/dhcp-contrib.html";

#include "dhcpd.h"
#include "version.h"

static void usage PROTO ((char *));

TIME cur_time;
struct group root_group;

struct iaddr server_identifier;
int server_identifier_matched;

u_int16_t local_port;
u_int16_t remote_port;

int log_priority;
#ifdef DEBUG
int log_perror = -1;
#else
int log_perror = 1;
#endif

char *path_dhcpd_conf = _PATH_DHCPD_CONF;
char *path_dhcpd_db = _PATH_DHCPD_DB;
char *path_dhcpd_pid = _PATH_DHCPD_PID;

int main (argc, argv)
	int argc;
	char **argv;
{
	int i, status;
	struct servent *ent;
	char *s, *appname;
	int cftest = 0;
#ifndef DEBUG
	int pidfilewritten = 0;
	int pid;
	char pbuf [20];
	int daemon = 1;
#endif
	int quiet = 0;

	appname = strrchr (argv [0], '/');
	if (!appname)
		appname = argv [0];
	else
		appname++;

	/* Initially, log errors to stderr as well as to syslogd. */
	openlog (appname, LOG_NDELAY, DHCPD_LOG_FACILITY);
	setlogmask (LOG_UPTO (LOG_INFO));

	for (i = 1; i < argc; i++) {
		if (!strcmp (argv [i], "-p")) {
			if (++i == argc)
				usage (appname);
			for (s = argv [i]; *s; s++)
				if (!isdigit (*s))
					error ("%s: not a valid UDP port",
					       argv [i]);
			status = atoi (argv [i]);
			if (status < 1 || status > 65535)
				error ("%s: not a valid UDP port",
				       argv [i]);
			local_port = htons (status);
			debug ("binding to user-specified port %d",
			       ntohs (local_port));
		} else if (!strcmp (argv [i], "-f")) {
#ifndef DEBUG
			daemon = 0;
#endif
		} else if (!strcmp (argv [i], "-d")) {
#ifndef DEBUG
			daemon = 0;
#endif
			log_perror = -1;
		} else if (!strcmp (argv [i], "-cf")) {
			if (++i == argc)
				usage (appname);
			path_dhcpd_conf = argv [i];
		} else if (!strcmp (argv [i], "-pf")) {
			if (++i == argc)
				usage (appname);
			path_dhcpd_pid = argv [i];
		} else if (!strcmp (argv [i], "-lf")) {
			if (++i == argc)
				usage (appname);
			path_dhcpd_db = argv [i];
                } else if (!strcmp (argv [i], "-t")) {
			/* test configurations only */
#ifndef DEBUG
			daemon = 0;
#endif
			cftest = 1;
			log_perror = -1;
		} else if (!strcmp (argv [i], "-q")) {
			quiet = 1;
			quiet_interface_discovery = 1;
		} else if (argv [i][0] == '-') {
			usage (appname);
		} else {
			struct interface_info *tmp =
				((struct interface_info *)
				 dmalloc (sizeof *tmp, "get_interface_list"));
			if (!tmp)
				error ("Insufficient memory to %s %s",
				       "record interface", argv [i]);
			memset (tmp, 0, sizeof *tmp);
			strlcpy (tmp->name, argv [i], sizeof(tmp->name));
			tmp->next = interfaces;
			tmp->flags = INTERFACE_REQUESTED;
			interfaces = tmp;
		}
	}

	if (!quiet) {
		note ("%s %s", message, DHCP_VERSION);
		note ("%s", copyright);
		note ("%s", arr);
		note ("%s", "");
		note ("%s", contrib);
		note ("%s", url);
		note ("%s", "");
	} else
		log_perror = 0;

	/* Default to the DHCP/BOOTP port. */
	if (!local_port)
	{
		ent = getservbyname ("dhcp", "udp");
		if (!ent)
			local_port = htons (67);
		else
			local_port = ent -> s_port;
#ifndef __CYGWIN32__ /* XXX */
		endservent ();
#endif
	}
  
	remote_port = htons (ntohs (local_port) + 1);

	/* Get the current time... */
	GET_TIME (&cur_time);

	/* Read the dhcpd.conf file... */
	if (!readconf ())
		error ("Configuration file errors encountered -- exiting");

        /* test option should cause an early exit */
 	if (cftest) 
 		exit(0);

	/* Start up the database... */
	db_startup ();

	/* Discover all the network interfaces and initialize them. */
	discover_interfaces (DISCOVER_SERVER);

	/* Initialize icmp support... */
	icmp_startup (1, lease_pinged);

#ifndef DEBUG
	if (daemon) {
		/* First part of becoming a daemon... */
		if ((pid = fork ()) == -1)
			error ("Can't fork daemon: %m");
		else if (pid)
			exit (0);
	}

	/* Read previous pid file. */
	if ((i = open (path_dhcpd_pid, O_RDONLY)) != -1) {
		status = read (i, pbuf, (sizeof pbuf) - 1);
		close (i);
		pbuf [status] = 0;
		pid = atoi (pbuf);

		/* If the previous server process is not still running,
		   write a new pid file immediately. */
		if (pid && (pid == getpid () || kill (pid, 0) == -1)) {
			unlink (path_dhcpd_pid);
			if ((i = open (path_dhcpd_pid,
				       O_WRONLY | O_CREAT, 0640)) != -1) {
				snprintf (pbuf, sizeof(pbuf), "%d\n",
				  (int)getpid ());
				write (i, pbuf, strlen (pbuf));
				close (i);
				pidfilewritten = 1;
			}
		} else
			error ("There's already a DHCP server running.\n");
	}

	/* If we were requested to log to stdout on the command line,
	   keep doing so; otherwise, stop. */
	if (log_perror == -1)
		log_perror = 1;
	else
		log_perror = 0;

	if (daemon) {
		/* Become session leader and get pid... */
		close (0);
		close (1);
		close (2);
		pid = setsid ();
	}

	/* If we didn't write the pid file earlier because we found a
	   process running the logged pid, but we made it to here,
	   meaning nothing is listening on the bootp port, then write
	   the pid file out - what's in it now is bogus anyway. */
	if (!pidfilewritten) {
		unlink (path_dhcpd_pid);
		if ((i = open (path_dhcpd_pid,
			       O_WRONLY | O_CREAT, 0640)) != -1) {
			snprintf (pbuf, sizeof(pbuf), "%d\n",
			  (int)getpid ());
			write (i, pbuf, strlen (pbuf));
			close (i);
			pidfilewritten = 1;
		}
	}
#endif /* !DEBUG */

	/* Set up the bootp packet handler... */
	bootp_packet_handler = do_packet;

	/* Receive packets and dispatch them... */
	dispatch ();

	/* Not reached */
	return 0;
}

/* Print usage message. */

static void usage (appname)
	char *appname;
{
	note ("%s", message);
	note ("%s", copyright);
	note ("%s", arr);
	note ("%s", "");
	note ("%s", contrib);
	note ("%s", url);
	note ("%s", "");

	warn ("Usage: %s [-p <UDP port #>] [-d] [-f] [-cf config-file]",
	      appname);
	error("            [-lf lease-file] [-pf pidfile] [if0 [...ifN]]");
}

void cleanup ()
{
}

void lease_pinged (from, packet, length)
	struct iaddr from;
	u_int8_t *packet;
	int length;
{
	struct lease *lp;

	/* Don't try to look up a pinged lease if we aren't trying to
	   ping one - otherwise somebody could easily make us churn by
	   just forging repeated ICMP EchoReply packets for us to look
	   up. */
	if (!outstanding_pings)
		return;

	lp = find_lease_by_ip_addr (from);

	if (!lp) {
		note ("unexpected ICMP Echo Reply from %s", piaddr (from));
		return;
	}

	if (!lp -> state && ! lp -> releasing) {
		warn ("ICMP Echo Reply for %s arrived late or is spurious.",
		      piaddr (from));
		return;
	}

	/* At this point it looks like we pinged a lease and got a
	 * response, which shouldn't have happened. 
	 * if it did it's either one of two two cases:
	 * 1 - we pinged this lease before offering it and
	 *     something answered, so we abandon it.
	 * 2 - we pinged this lease before releaseing it 
	 *     and something answered, so we don't release it.
	 */
	if (lp -> releasing) {
		warn ("IP address %s answers a ping after sending a release",
		      piaddr (lp -> ip_addr));
		warn ("Possible release spoof - Not releasing address %s",
		      piaddr (lp -> ip_addr));
		lp -> releasing = 0;
	}
	else {
		free_lease_state (lp -> state, "lease_pinged");
		lp -> state = (struct lease_state *)0;
		abandon_lease (lp, "pinged before offer");
	}
	cancel_timeout (lease_ping_timeout, lp);
	--outstanding_pings;
}

void lease_ping_timeout (vlp)
	void *vlp;
{
	struct lease *lp = vlp;
	
	--outstanding_pings;
	if (lp->releasing) {
		lp->releasing = 0;
		release_lease(lp);
	}
	else 
		dhcp_reply (lp);
}
@


1.7
log
@socklen_t use; pvalchev ok
@
text
@@


1.6
log
@format string audit.  From: Gregory Steuck <greg@@nest.cx>
@
text
@d76 1
a76 1
int main (argc, argv, envp)
d78 1
a78 1
	char **argv, **envp;
@


1.5
log
@Remove \n from warn(3). ok deraadt@@
@
text
@d167 6
a172 6
		note (copyright);
		note (arr);
		note ("");
		note (contrib);
		note (url);
		note ("");
d290 7
a296 7
	note (message);
	note (copyright);
	note (arr);
	note ("");
	note (contrib);
	note (url);
	note ("");
@


1.4
log
@dhcp 2.0pl5 merge/cleanup/deadcode slashing. still needs more eyes on this
but appears to work better than what's been in-tree before for dealing with
stupid dhcp servers.
@
text
@d329 1
a329 1
		warn ("ICMP Echo Reply for %s arrived late or is spurious.\n",
@


1.3
log
@
-Wall cleanup.
roll a function for writing out pidfile's instead of rolling it for each
program.
be careful with a few more buffers
@
text
@d6 2
a7 2
 * Copyright (c) 1995, 1996, 1997 The Internet Software Consortium.
 * All rights reserved.
a42 4
#ifndef lint
static char ocopyright[] =
"$Id: dhcpd.c,v 1.2 2000/07/21 00:33:55 beck Exp $ Copyright 1995, 1996 The Internet Software Consortium.";
#endif
d45 1
a45 1
"Copyright 1995, 1996 The Internet Software Consortium.";
d47 3
a49 1
static char message [] = "Internet Software Consortium DHCPD $Name:  $";
d52 1
d54 1
a54 1
static void usage PROTO ((void));
a61 4
#ifdef USE_FALLBACK
struct interface_info fallback_interface;
#endif

d74 1
d82 1
a82 1
	char *s;
d86 1
a86 1
	pid_t pid;
d92 6
d99 1
a99 10
#ifdef SYSLOG_4_2
	openlog ("dhcpd", LOG_NDELAY);
	log_priority = DHCPD_LOG_FACILITY;
#else
	openlog ("dhcpd", LOG_NDELAY, DHCPD_LOG_FACILITY);
#endif

#ifndef DEBUG
#ifndef SYSLOG_4_2
#ifndef __CYGWIN32__ /* XXX */
a100 3
#endif
#endif
#endif	
d105 1
a105 1
				usage ();
d128 1
a128 1
				usage ();
d130 4
d136 1
a136 1
				usage ();
d149 1
a149 1
			usage ();
d158 3
a160 3
			strlcpy(tmp->name, argv[i], IFNAMSIZ);
			tmp -> next = interfaces;
			tmp -> flags = INTERFACE_REQUESTED;
d166 1
a166 1
		note (message);
d169 6
a174 1
	}
d206 1
a206 1
	discover_interfaces (1);
d214 1
a214 1
		if ((pid = fork ()) < 0)
d221 1
a221 1
	if ((i = open (_PATH_DHCPD_PID, O_RDONLY)) >= 0) {
d225 1
a225 1
		pid = (pid_t)atoi(pbuf);
d229 12
a240 4
		if (pid && kill (pid, 0) < 0) {
			write_pidfile(_PATH_DHCPD_PID, getpid());
			pidfilewritten = 1;
		}
d263 9
a271 2
		write_pidfile(_PATH_DHCPD_PID, getpid());
		pidfilewritten = 1;
d287 2
a288 1
static void usage ()
d293 8
a300 3

	error ("Usage: dhcpd [-p <UDP port #>] [-d] [-f] [-cf config-file]%s",
	       "\n            [-lf lease-file] [if0 [...ifN]]");
d343 1
a343 1
	  	warn ("IP address %s answers a ping after sending a release",
a351 1

d368 1
a368 1
	else {
a369 1
	}
@


1.2
log
@Deal with a bunch of dhcp issues, ok fries@@:
	- some minor cleanup (syscall return codes, dead code, use strlcpy,
	  etc)
	- sanity check dhcp option values recieved by dhclient
	  so that things that should look like a hostname look like a
	  hostname, and things that should look like an ip address look
	  like an ip address, if they don't ignore the lease
	  offer because it's bogus.
	- Make the dhcp server attempt to ping an address when it recieves
	  a RELEASE from it. If the address answers a ping, ignore the
	  release offer. This helps make spoofing releases to liberate
	  addresses more difficult.
@
text
@d45 1
a45 1
"$Id: dhcpd.c,v 1.1 1998/08/18 03:43:34 deraadt Exp $ Copyright 1995, 1996 The Internet Software Consortium.";
a78 1
char *path_dhcpd_pid = _PATH_DHCPD_PID;
d90 1
a90 1
	int pid;
d164 1
a164 1
			strcpy (tmp -> name, argv [i]);
d222 1
a222 1
	if ((i = open (path_dhcpd_pid, O_RDONLY)) >= 0) {
d226 1
a226 1
		pid = atoi (pbuf);
d231 2
a232 8
			unlink (path_dhcpd_pid);
			if ((i = open (path_dhcpd_pid,
				       O_WRONLY | O_CREAT, 0640)) >= 0) {
				sprintf (pbuf, "%d\n", (int)getpid ());
				write (i, pbuf, strlen (pbuf));
				close (i);
				pidfilewritten = 1;
			}
d256 2
a257 8
		unlink (path_dhcpd_pid);
		if ((i = open (path_dhcpd_pid,
			       O_WRONLY | O_CREAT, 0640)) >= 0) {
			sprintf (pbuf, "%d\n", (int)getpid ());
			write (i, pbuf, strlen (pbuf));
			close (i);
			pidfilewritten = 1;
		}
@


1.1
log
@ISC dhcp, needs security audit for sure
@
text
@d45 1
a45 1
"$Id: dhcpd.c,v 1.1.1.7 1998/05/18 06:54:01 mellon Exp $ Copyright 1995, 1996 The Internet Software Consortium.";
d321 1
a321 1
	if (!lp -> state) {
d328 17
a344 3
	   response, which shouldn't have happened. */
	free_lease_state (lp -> state, "lease_pinged");
	lp -> state = (struct lease_state *)0;
d346 2
a347 1
	abandon_lease (lp, "pinged before offer");
d356 1
a356 1

d358 7
a364 1
	dhcp_reply (lp);
@

