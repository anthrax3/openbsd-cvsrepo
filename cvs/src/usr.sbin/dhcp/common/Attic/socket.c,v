head	1.10;
access;
symbols
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.0.10
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.8
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.6
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2004.04.28.06.57.40;	author henning;	state dead;
branches;
next	1.9;

1.9
date	2002.09.06.19.52.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.10.00.39.41;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.02.10.02.34;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.03.03.06.57;	author weingart;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.27.19.28.32;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.24.22.11.47;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.24.06.05.08;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.30.17.54.07;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	98.08.18.03.43.27;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@It is a big pleasure for me to remove this highe pile of gunk from the tree.
dhclient, dhcrelay and dhcpd have been factored out and cleaned up big time,
dhcpd and dhcrelay chroot itself, drop privileges and lock their bpf
descriptors after applyiing read/write filters now, and this pile of ISC code
with it's lovely char ServerName; /* Name of Server */ constructs is
obsolete.
theo ok, I owe you some beers for this pleasure
@
text
@/* socket.c

   BSD socket interface code... */

/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999
 * The Internet Software Consortium.   All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include "dhcpd.h"

/* Generic interface registration routine... */
int if_register_socket (info)
	struct interface_info *info;
{
	struct sockaddr_in name;
	int sock;
	int flag;

	/* Set up the address we're going to bind to. */
	memset(&name, 0, sizeof name);
	name.sin_family = AF_INET;
	name.sin_port = local_port;
	name.sin_addr.s_addr = INADDR_ANY;

	/* Make a socket... */
	if ((sock = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
		error ("Can't create dhcp socket: %m");

	/* Set the REUSEADDR option so that we don't fail to start if
	   we're being restarted. */
	flag = 1;
	if (setsockopt (sock, SOL_SOCKET, SO_REUSEADDR,
			(char *)&flag, sizeof flag) < 0)
		error ("Can't set SO_REUSEADDR option on dhcp socket: %m");

	flag = 1;
	if (setsockopt (sock, SOL_SOCKET, SO_REUSEPORT,
			(char *)&flag, sizeof flag) < 0)
		error ("Can't set SO_REUSEPORT option on dhcp socket: %m");

	/* Set the BROADCAST option so that we can broadcast DHCP responses. */
	if (setsockopt (sock, SOL_SOCKET, SO_BROADCAST,
			(char *)&flag, sizeof flag) < 0)
		error ("Can't set SO_BROADCAST option on dhcp socket: %m");

	/* Bind the socket to this interface's IP address. */
	if (bind (sock, (struct sockaddr *)&name, sizeof name) < 0)
		error ("Can't bind to dhcp address: %m");

	flag = IPSEC_LEVEL_BYPASS;
	if (setsockopt (sock, IPPROTO_IP, IP_AUTH_LEVEL,
			(char *)&flag, sizeof flag) == -1)
		if (errno != EOPNOTSUPP)
			error ("Can't bypass auth IPsec on dhcp socket: %m");
	if (setsockopt (sock, IPPROTO_IP, IP_ESP_TRANS_LEVEL,
			(char *)&flag, sizeof flag) == -1)
		if (errno != EOPNOTSUPP)
			error ("Can't bypass ESP transport on dhcp socket: %m");
	if (setsockopt (sock, IPPROTO_IP, IP_ESP_NETWORK_LEVEL,
			(char *)&flag, sizeof flag) == -1)
		if (errno != EOPNOTSUPP)
			error ("Can't bypass ESP network on dhcp socket: %m");

	return sock;
}

void if_register_fallback (info)
	struct interface_info *info;
{

	info -> wfdesc = if_register_socket (info);

	if (!quiet_interface_discovery)
		note ("Sending on   Socket/%s%s%s",
		      info -> name,
		      (info -> shared_network ? "/" : ""),
		      (info -> shared_network ?
		       info -> shared_network -> name : ""));
}

ssize_t send_fallback (interface, packet, raw, len, from, to, hto)
	struct interface_info *interface;
	struct packet *packet;
	struct dhcp_packet *raw;
	size_t len;
	struct in_addr from;
	struct sockaddr_in *to;
	struct hardware *hto;
{
	int result;

	result = sendto (interface -> wfdesc, (char *)raw, len, 0,
	  (struct sockaddr *)to, sizeof *to);

	if (result == -1) {
		warn ("send_fallback: %m");
		if (errno == ENETUNREACH)
			warn ("send_fallback: please consult README file %s",
			  "regarding broadcast address.");
	}
	return result;
}

/* This just reads in a packet and silently discards it. */

void fallback_discard (protocol)
	struct protocol *protocol;
{
	char buf [1540];
	struct sockaddr_in from;
	socklen_t flen = sizeof from;
	int status;
	struct interface_info *interface = protocol -> local;

	status = recvfrom (interface -> wfdesc, buf, sizeof buf, 0,
			   (struct sockaddr *)&from, &flen);
	if (status == 0)
		warn ("fallback_discard: %m");
}
@


1.9
log
@socklen_t use; pvalchev ok
@
text
@@


1.8
log
@more sockaddr initializations.
@
text
@d145 1
a145 1
	int flen = sizeof from;
@


1.7
log
@clear sockaddr_in before use
@
text
@a57 1
	memset (name.sin_zero, 0, sizeof (name.sin_zero));
@


1.6
log
@ENODEV -> EOPNOTSUPP to make this work.  beck@@ ok.
@
text
@d54 1
@


1.5
log
@don't die if IPV6 isn't there, so that this will work even with
kernels without IPV6 support.
@
text
@d87 1
a87 1
		if (errno != ENODEV)
d91 1
a91 1
		if (errno != ENODEV)
d95 1
a95 1
		if (errno != ENODEV)
@


1.4
log
@Old M of mine, uncovered by the recent dhcpd update:  Bypass IPsec in all
DHCP traffic.
@
text
@d86 3
a88 2
			(char *)&flag, sizeof flag) < 0)
		error ("Can't bypass auth IPsec on dhcp socket: %m");
d90 3
a92 2
			(char *)&flag, sizeof flag) < 0)
		error ("Can't bypass ESP transport on dhcp socket: %m");
d94 3
a96 2
			(char *)&flag, sizeof flag) < 0)
		error ("Can't bypass ESP network on dhcp socket: %m");
@


1.3
log
@dhcp 2.0pl5 merge/cleanup/deadcode slashing. still needs more eyes on this
but appears to work better than what's been in-tree before for dealing with
stupid dhcp servers.
@
text
@d84 11
@


1.2
log
@setockopt(SO_REUSEPORT), so multiple dhclients work, PR 1391
@
text
@d6 2
a7 2
 * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.
 * All rights reserved.
a42 13
/* SO_BINDTODEVICE support added by Elliot Poger (poger@@leland.stanford.edu).
 * This sockopt allows a socket to be bound to a particular interface,
 * thus enabling the use of DHCPD on a multihomed host.
 * If SO_BINDTODEVICE is defined in your system header files, the use of
 * this sockopt will be automatically enabled. 
 * I have implemented it under Linux; other systems should be doable also.
 */

#ifndef lint
static char copyright[] =
"$Id: socket.c,v 1.1 1998/08/18 03:43:27 deraadt Exp $ Copyright (c) 1995, 1996 The Internet Software Consortium.  All rights reserved.\n";
#endif /* not lint */

a44 39
#ifdef USE_SOCKET_FALLBACK
#  define USE_SOCKET_SEND
#  define if_register_send if_register_fallback
#  define send_packet send_fallback
#  define if_reinitialize_send if_reinitialize_fallback
#endif

static int once = 0;

/* Reinitializes the specified interface after an address change.   This
   is not required for packet-filter APIs. */

#ifdef USE_SOCKET_SEND
void if_reinitialize_send (info)
	struct interface_info *info;
{
#if 0
#ifndef USE_SOCKET_RECEIVE
	once = 0;
	close (info -> wfdesc);
#endif
	if_register_send (info);
#endif
}
#endif

#ifdef USE_SOCKET_RECEIVE
void if_reinitialize_receive (info)
	struct interface_info *info;
{
#if 0
	once = 0;
	close (info -> rfdesc);
	if_register_receive (info);
#endif
}
#endif

#if defined (USE_SOCKET_SEND) || defined (USE_SOCKET_RECEIVE)
a52 8
#ifndef SO_BINDTODEVICE
	/* Make sure only one interface is registered. */
	if (once)
		error ("The standard socket API can only support %s",
		       "hosts with a single network interface.");
	once = 1;
#endif

d73 1
a73 1
	        error ("Can't set SO_REUSEPORT option on dhcp socket: %m");
a83 8
#ifdef SO_BINDTODEVICE
	/* Bind this socket to this interface. */
	if (setsockopt (sock, SOL_SOCKET, SO_BINDTODEVICE,
			(char *)(info -> ifp), sizeof *(info -> ifp)) < 0) {
		error("setting SO_BINDTODEVICE");
	}
#endif

a85 1
#endif /* USE_SOCKET_SEND || USE_SOCKET_RECEIVE */
d87 1
a87 2
#ifdef USE_SOCKET_SEND
void if_register_send (info)
d90 1
a90 1
#ifndef USE_SOCKET_RECEIVE
a91 11
#else
	info -> wfdesc = info -> rfdesc;
#endif
	if (!quiet_interface_discovery)
		note ("Sending on   Socket/%s/%s",
		      info -> name,
		      (info -> shared_network ?
		       info -> shared_network -> name : "unattached"));

}
#endif /* USE_SOCKET_SEND */
a92 7
#ifdef USE_SOCKET_RECEIVE
void if_register_receive (info)
	struct interface_info *info;
{
	/* If we're using the socket API for sending and receiving,
	   we don't need to register this interface twice. */
	info -> rfdesc = if_register_socket (info);
d94 1
a94 1
		note ("Listening on Socket/%s/%s",
d96 1
d98 1
a98 1
		       info -> shared_network -> name : "unattached"));
a99 1
#endif /* USE_SOCKET_RECEIVE */
d101 1
a101 2
#ifdef USE_SOCKET_SEND
ssize_t send_packet (interface, packet, raw, len, from, to, hto)
a110 16
#ifdef IGNORE_HOSTUNREACH
	int retry = 0;
	do {
#endif
		result = sendto (interface -> wfdesc, (char *)raw, len, 0,
				 (struct sockaddr *)to, sizeof *to);
#ifdef IGNORE_HOSTUNREACH
	} while (to -> sin_addr.s_addr == htonl (INADDR_BROADCAST) &&
		 result < 0 &&
		 (errno == EHOSTUNREACH ||
		  errno == ECONNREFUSED) &&
		 retry++ < 10);
#endif
	return result;
}
#endif /* USE_SOCKET_SEND */
d112 2
a113 10
#ifdef USE_SOCKET_RECEIVE
ssize_t receive_packet (interface, buf, len, from, hfrom)
	struct interface_info *interface;
	unsigned char *buf;
	size_t len;
	struct sockaddr_in *from;
	struct hardware *hfrom;
{
	int flen = sizeof *from;
	int result;
d115 6
a120 12
#ifdef IGNORE_HOSTUNREACH
	int retry = 0;
	do {
#endif
		result = recvfrom (interface -> rfdesc, buf, len, 0,
				   (struct sockaddr *)from, &flen);
#ifdef IGNORE_HOSTUNREACH
	} while (result < 0 &&
		 (errno == EHOSTUNREACH ||
		  errno == ECONNREFUSED) &&
		 retry++ < 10);
#endif
a122 1
#endif /* USE_SOCKET_RECEIVE */
a123 1
#ifdef USE_SOCKET_FALLBACK
d137 1
a137 1
	if (status < 0)
a139 1
#endif /* USE_SOCKET_RECEIVE */
@


1.1
log
@ISC dhcp, needs security audit for sure
@
text
@d53 1
a53 1
"$Id: socket.c,v 1.1.1.4 1998/05/18 06:53:56 mellon Exp $ Copyright (c) 1995, 1996 The Internet Software Consortium.  All rights reserved.\n";
d129 5
@

