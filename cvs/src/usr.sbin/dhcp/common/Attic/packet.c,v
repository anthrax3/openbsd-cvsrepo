head	1.5;
access;
symbols
	OPENBSD_3_5:1.4.0.12
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.10
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.8
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.1.0.10
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.8
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.6
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.04.28.06.57.40;	author henning;	state dead;
branches;
next	1.4;

1.4
date	2001.06.24.06.05.07;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.14.23.01.19;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.03.16.04.38;	author ericj;	state Exp;
branches;
next	1.1;

1.1
date	98.08.18.03.43.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@It is a big pleasure for me to remove this highe pile of gunk from the tree.
dhclient, dhcrelay and dhcpd have been factored out and cleaned up big time,
dhcpd and dhcrelay chroot itself, drop privileges and lock their bpf
descriptors after applyiing read/write filters now, and this pile of ISC code
with it's lovely char ServerName; /* Name of Server */ constructs is
obsolete.
theo ok, I owe you some beers for this pleasure
@
text
@/* packet.c

   Packet assembly code, originally contributed by Archie Cobbs. */

/*
 * Copyright (c) 1995, 1996, 1999 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include "dhcpd.h"

#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/udp.h>

/* Compute the easy part of the checksum on a range of bytes. */

u_int32_t checksum (buf, nbytes, sum)
	unsigned char *buf;
	unsigned nbytes;
	u_int32_t sum;
{
	int i;

#ifdef DEBUG_CHECKSUM
	debug ("checksum (%x %d %x)", buf, nbytes, sum);
#endif

	/* Checksum all the pairs of bytes first... */
	for (i = 0; i < (nbytes & ~1U); i += 2) {
#ifdef DEBUG_CHECKSUM_VERBOSE
		debug ("sum = %x", sum);
#endif
		sum += (u_int16_t) ntohs(*((u_int16_t *)(buf + i)));
		/* Add carry. */
		if (sum > 0xFFFF)
			sum -= 0xFFFF;
	}	

	/* If there's a single byte left over, checksum it, too.   Network
	   byte order is big-endian, so the remaining byte is the high byte. */
	if (i < nbytes) {
#ifdef DEBUG_CHECKSUM_VERBOSE
		debug ("sum = %x", sum);
#endif
		sum += buf [i] << 8;
		/* Add carry. */
		if (sum > 0xFFFF)
			sum -= 0xFFFF;
	}
	
	return sum;
}

/* Finish computing the sum, and then put it into network byte order. */

u_int32_t wrapsum (sum)
	u_int32_t sum;
{
#ifdef DEBUG_CHECKSUM
	debug ("wrapsum (%x)", sum);
#endif

	sum = ~sum & 0xFFFF;
#ifdef DEBUG_CHECKSUM_VERBOSE
	debug ("sum = %x", sum);
#endif
	
#ifdef DEBUG_CHECKSUM
	debug ("wrapsum returns %x", htons (sum));
#endif
	return htons(sum);
}

/* Assemble an hardware header... */
/* XXX currently only supports ethernet; doesn't check for other types. */

void assemble_hw_header (interface, buf, bufix, to)
	struct interface_info *interface;
	unsigned char *buf;
	int *bufix;
	struct hardware *to;
{
#if defined (HAVE_TR_SUPPORT)
	if (interface -> hw_address.htype == HTYPE_IEEE802)
		assemble_tr_header (interface, buf, bufix, to);
	else
#endif
		assemble_ethernet_header (interface, buf, bufix, to);

}

/* UDP header and IP header assembled together for convenience. */

void assemble_udp_ip_header (interface, buf, bufix,
			     from, to, port, data, len)
	struct interface_info *interface;
	unsigned char *buf;
	int *bufix;
	u_int32_t from;
	u_int32_t to;
	unsigned int port;
	unsigned char *data;
	int len;
{
	struct ip ip;
	struct udphdr udp;

	/* Fill out the IP header */
	ip.ip_v = 4;
	ip.ip_hl = 5;
	ip.ip_tos = IPTOS_LOWDELAY;
	ip.ip_len = htons(sizeof(ip) + sizeof(udp) + len);
	ip.ip_id = 0;
	ip.ip_off = 0;
	ip.ip_ttl = 16;
	ip.ip_p = IPPROTO_UDP;
	ip.ip_sum = 0;
	ip.ip_src.s_addr = from;
	ip.ip_dst.s_addr = to;
	
	/* Checksum the IP header... */
	ip.ip_sum = wrapsum (checksum ((unsigned char *)&ip, sizeof ip, 0));
	
	/* Copy the ip header into the buffer... */
	memcpy (&buf [*bufix], &ip, sizeof ip);
	*bufix += sizeof ip;

	/* Fill out the UDP header */
	udp.uh_sport = local_port;		/* XXX */
	udp.uh_dport = port;			/* XXX */
	udp.uh_ulen = htons(sizeof(udp) + len);
	memset (&udp.uh_sum, 0, sizeof udp.uh_sum);

	/* Compute UDP checksums, including the ``pseudo-header'', the UDP
	   header and the data. */

	udp.uh_sum =
		wrapsum (checksum ((unsigned char *)&udp, sizeof udp,
				   checksum (data, len, 
					     checksum ((unsigned char *)
						       &ip.ip_src,
						       2 * sizeof ip.ip_src,
						       IPPROTO_UDP +
						       (u_int32_t)
						       ntohs (udp.uh_ulen)))));

	/* Copy the udp header into the buffer... */
	memcpy (&buf [*bufix], &udp, sizeof udp);
	*bufix += sizeof udp;
}

/* Decode a hardware header... */

ssize_t decode_hw_header (interface, buf, bufix, from)
     struct interface_info *interface;
     unsigned char *buf;
     int bufix;
     struct hardware *from;
{
#if defined (HAVE_TR_SUPPORT)
	if (interface -> hw_address.htype == HTYPE_IEEE802)
		return decode_tr_header (interface, buf, bufix, from);
	else
#endif
		return decode_ethernet_header (interface, buf, bufix, from);
}

/* UDP header and IP header decoded together for convenience. */

ssize_t decode_udp_ip_header (interface, buf, bufix, from, data, buflen)
	struct interface_info *interface;
	unsigned char *buf;
	int bufix;
	struct sockaddr_in *from;
	unsigned char *data;
	int buflen;
{
  struct ip *ip;
  struct udphdr *udp;
  u_int32_t ip_len = (buf [bufix] & 0xf) << 2;
  u_int32_t sum, usum;
  static int ip_packets_seen;
  static int ip_packets_bad_checksum;
  static int udp_packets_seen;
  static int udp_packets_bad_checksum;
  static int udp_packets_length_checked;
  static int udp_packets_length_overflow;
  int len = 0;

  ip = (struct ip *)(buf + bufix);
  udp = (struct udphdr *)(buf + bufix + ip_len);

  /* Check the IP header checksum - it should be zero. */
  ++ip_packets_seen;
  if (wrapsum (checksum (buf + bufix, ip_len, 0))) {
	  ++ip_packets_bad_checksum;
	  if (ip_packets_seen > 4 &&
	      (ip_packets_seen / ip_packets_bad_checksum) < 2) {
		  note ("%d bad IP checksums seen in %d packets",
			ip_packets_bad_checksum, ip_packets_seen);
		  ip_packets_seen = ip_packets_bad_checksum = 0;
	  }
	  return -1;
  }

  /* Check the IP packet length. */
  if (ntohs (ip -> ip_len) != buflen)
	  debug ("ip length %d disagrees with bytes received %d.",
		 ntohs (ip -> ip_len), buflen);

  /* Copy out the IP source address... */
  memcpy (&from -> sin_addr, &ip -> ip_src, 4);

  /* Compute UDP checksums, including the ``pseudo-header'', the UDP
     header and the data.   If the UDP checksum field is zero, we're
     not supposed to do a checksum. */

  if (!data) {
	  data = buf + bufix + ip_len + sizeof *udp;
	  len = ntohs (udp -> uh_ulen) - sizeof *udp;
	  ++udp_packets_length_checked;
	  if (len + data > buf + bufix + buflen) {
		  ++udp_packets_length_overflow;
		  if (udp_packets_length_checked > 4 &&
		      (udp_packets_length_checked /
		       udp_packets_length_overflow) < 2) {
			  note ("%d udp packets in %d too long - dropped",
				udp_packets_length_overflow,
				udp_packets_length_checked);
			  udp_packets_length_overflow =
				  udp_packets_length_checked = 0;
		  }
		  return -1;
	  }
	  if (len + data != buf + bufix + buflen)
		  debug ("accepting packet with data after udp payload.");
  }

  usum = udp -> uh_sum;
  udp -> uh_sum = 0;

  sum = wrapsum (checksum ((unsigned char *)udp, sizeof *udp,
			   checksum (data, len,
				     checksum ((unsigned char *)
					       &ip -> ip_src,
					       2 * sizeof ip -> ip_src,
					       IPPROTO_UDP +
					       (u_int32_t)
					       ntohs (udp -> uh_ulen)))));

  udp_packets_seen++;
  if (usum && usum != sum) {
	  udp_packets_bad_checksum++;
	  if (udp_packets_seen > 4 &&
	      (udp_packets_seen / udp_packets_bad_checksum) < 2) {
		  note ("%d bad udp checksums in %d packets",
			udp_packets_bad_checksum, udp_packets_seen);
		  udp_packets_seen = udp_packets_bad_checksum = 0;
	  }
	  return -1;
  }

  /* Copy out the port... */
  memcpy (&from -> sin_port, &udp -> uh_sport, sizeof udp -> uh_sport);

  return ip_len + sizeof *udp;
}
@


1.4
log
@dhcp 2.0pl5 merge/cleanup/deadcode slashing. still needs more eyes on this
but appears to work better than what's been in-tree before for dealing with
stupid dhcp servers.
@
text
@@


1.3
log
@Compute UDP checksum, PR 1621 (matthieu.herrb@@wanadoo.fr)
@
text
@d6 1
a6 1
 * Copyright (c) 1995, 1996 The Internet Software Consortium.
a42 5
#ifndef lint
static char copyright[] =
"$Id: packet.c,v 1.2 2001/01/03 16:04:38 ericj Exp $ Copyright (c) 1996 The Internet Software Consortium.  All rights reserved.\n";
#endif /* not lint */

d45 3
a47 5
#if defined (PACKET_ASSEMBLY) || defined (PACKET_DECODING)
#include "includes/netinet/ip.h"
#include "includes/netinet/udp.h"
#include "includes/netinet/if_ether.h"
#endif /* PACKET_ASSEMBLY || PACKET_DECODING */
d56 1
a56 1
	unsigned i;
d88 1
a88 1
/* Finish computing the checksum, and then put it into network byte order. */
d99 1
a99 1
	log_debug ("sum = %x", sum);
a107 1
#ifdef PACKET_ASSEMBLY
d117 3
a119 9
	struct ether_header eh;

	if (to && to -> hlen == 6) /* XXX */
		memcpy (eh.ether_dhost, to -> haddr, sizeof eh.ether_dhost);
	else
		memset (eh.ether_dhost, 0xff, sizeof (eh.ether_dhost));
	if (interface -> hw_address.hlen == sizeof (eh.ether_shost))
		memcpy (eh.ether_shost, interface -> hw_address.haddr,
			sizeof (eh.ether_shost));
a120 6
		memset (eh.ether_shost, 0x00, sizeof (eh.ether_shost));

#ifdef BROKEN_FREEBSD_BPF /* Fixed in FreeBSD 2.2 */
	eh.ether_type = ETHERTYPE_IP;
#else
	eh.ether_type = htons (ETHERTYPE_IP);
d122 1
a123 2
	memcpy (&buf [*bufix], &eh, sizeof eh);
	*bufix += sizeof eh;
d135 1
a135 1
	u_int16_t port;
a170 1
#if 1
a179 1
#endif
a184 1
#endif /* PACKET_ASSEMBLY */
a185 1
#ifdef PACKET_DECODING
a186 1
/* XXX currently only supports ethernet; doesn't check for other types. */
d194 4
a197 7
  struct ether_header eh;

  memcpy (&eh, buf + bufix, sizeof eh);

#ifdef USERLAND_FILTER
  if (ntohs (eh.ether_type) != ETHERTYPE_IP)
	  return -1;
d199 1
a199 5
  memcpy (from -> haddr, eh.ether_shost, sizeof (eh.ether_shost));
  from -> htype = ARPHRD_ETHER;
  from -> hlen = sizeof eh.ether_shost;

  return sizeof eh;
d204 1
a204 1
ssize_t decode_udp_ip_header (interface, buf, bufix, from, data, len)
d210 1
a210 1
	int len;
d215 8
a226 10
#ifdef USERLAND_FILTER
  /* Is it a UDP packet? */
  if (ip -> ip_p != IPPROTO_UDP)
	  return -1;

  /* Is it to the port we're serving? */
  if (udp -> uh_dport != local_port)
	  return -1;
#endif /* USERLAND_FILTER */

d228 1
d230 7
a236 2
	  note ("Bad IP checksum: %x",
		wrapsum (checksum (buf + bufix, sizeof *ip, 0)));
d240 5
d254 17
a270 1
	  len -= ip_len + sizeof *udp;
a272 1
#if 0
d280 1
a280 1
					       sizeof ip -> ip_src,
d285 1
d287 7
a293 1
	  note ("Bad udp checksum: %x %x", usum, sum);
a295 1
#endif
a301 1
#endif /* PACKET_DECODING */
@


1.2
log
@
-Wall cleanup.
roll a function for writing out pidfile's instead of rolling it for each
program.
be careful with a few more buffers
@
text
@d45 1
a45 1
"$Id: packet.c,v 1.1 1998/08/18 03:43:26 deraadt Exp $ Copyright (c) 1996 The Internet Software Consortium.  All rights reserved.\n";
d60 1
a60 1
	int nbytes;
d63 1
a63 1
	int i;
d70 1
a70 1
	for (i = 0; i < (nbytes & ~1); i += 2) {
d75 3
d87 3
d95 1
a95 2
/* Fold the upper sixteen bits of the checksum down into the lower bits,
   complement the sum, and then put it into network byte order. */
d104 1
a104 2
	while (sum > 0x10000) {
		sum = (sum >> 16) + (sum & 0xFFFF);
d106 1
a106 10
		debug ("sum = %x", sum);
#endif
		sum += (sum >> 16);
#ifdef DEBUG_CHECKSUM_VERBOSE
		debug ("sum = %x", sum);
#endif
	}
	sum = sum ^ 0xFFFF;
#ifdef DEBUG_CHECKSUM_VERBOSE
	debug ("sum = %x", sum);
d192 1
a192 1
#if 0
d198 1
a198 1
						       sizeof ip.ip_src,
@


1.1
log
@ISC dhcp, needs security audit for sure
@
text
@d45 1
a45 1
"$Id: packet.c,v 1.1.1.3 1997/06/08 04:54:18 mellon Exp $ Copyright (c) 1996 The Internet Software Consortium.  All rights reserved.\n";
a252 1
  u_int32_t sum, usum;
@

