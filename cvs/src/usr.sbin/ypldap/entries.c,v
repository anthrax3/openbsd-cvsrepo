head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.8
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.14
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.12
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	OPENBSD_5_0:1.1.0.14
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.12
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.10
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.8
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.2;
commitid	Uu5nFG3wCl0LACBb;

1.2
date	2011.08.28.11.53.16;	author aschrijver;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.26.15.10.01;	author pyr;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: entries.c,v 1.2 2011/08/28 11:53:16 aschrijver Exp $ */
/*
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <unistd.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "ypldap.h"

void
flatten_entries(struct env *env)
{
	size_t		 wrlen;
	size_t		 len;
	char		*linep;
	char		*endp;
	char		*tmp;
	struct userent	*ue;
	struct groupent	*ge;

	log_debug("flattening trees");
	/*
	 * This takes all the line pointers in RB elements and
	 * concatenates them in a single string, to be able to
	 * implement next element lookup without tree traversal.
	 *
	 * An extra octet is alloced to make space for an additional NUL.
	 */
	wrlen = env->sc_user_line_len;
	if ((linep = calloc(1, env->sc_user_line_len + 1)) == NULL) {
		/*
		 * XXX: try allocating a smaller chunk of memory
		 */
		fatal("out of memory");
	}
	endp = linep;

	RB_FOREACH(ue, user_name_tree, env->sc_user_names) {
		/*
		 * we convert the first nul back to a column,
		 * copy the string and then convert it back to a nul.
		 */
		ue->ue_line[strlen(ue->ue_line)] = ':';
		log_debug("pushing line: %s", ue->ue_line);
		len = strlen(ue->ue_line) + 1;
		memcpy(endp, ue->ue_line, len);
		endp[strcspn(endp, ":")] = '\0';
		free(ue->ue_line);
		ue->ue_line = endp;
		endp += len;
		wrlen -= len;

		/*
		 * To save memory strdup(3) the netid_line which originally used
		 * LINE_WIDTH bytes
		 */
		tmp = ue->ue_netid_line;
		ue->ue_netid_line = strdup(tmp);
		if (ue->ue_netid_line == NULL) {
			fatal("out of memory");
		}
		free(tmp);
	}
	env->sc_user_lines = linep;

	wrlen = env->sc_group_line_len;
	if ((linep = calloc(1, env->sc_group_line_len + 1)) == NULL) {
		/*
		 * XXX: try allocating a smaller chunk of memory
		 */
		fatal("out of memory");
	}
	endp = linep;
	RB_FOREACH(ge, group_name_tree, env->sc_group_names) {
		/*
		 * we convert the first nul back to a column,
		 * copy the string and then convert it back to a nul.
		 */
		ge->ge_line[strlen(ge->ge_line)] = ':';
		log_debug("pushing line: %s", ge->ge_line);
		len = strlen(ge->ge_line) + 1;
		memcpy(endp, ge->ge_line, len);
		endp[strcspn(endp, ":")] = '\0';
		free(ge->ge_line);
		ge->ge_line = endp;
		endp += len;
		wrlen -= len;
	}
	env->sc_group_lines = linep;
}

int
userent_name_cmp(struct userent *ue1, struct userent *ue2)
{
	return (strcmp(ue1->ue_line, ue2->ue_line));
}

int
userent_uid_cmp(struct userent *ue1, struct userent *ue2)
{
	return (ue1->ue_uid - ue2->ue_uid);
}

int
groupent_name_cmp(struct groupent *ge1, struct groupent *ge2)
{
	return (strcmp(ge1->ge_line, ge2->ge_line));
}

int
groupent_gid_cmp(struct groupent *ge1, struct groupent *ge2)
{
	return (ge1->ge_gid - ge2->ge_gid);
}

RB_GENERATE(user_name_tree, userent, ue_name_node, userent_name_cmp);
RB_GENERATE(user_uid_tree, userent, ue_uid_node, userent_uid_cmp);
RB_GENERATE(group_name_tree, groupent, ge_name_node, groupent_name_cmp);
RB_GENERATE(group_gid_tree, groupent, ge_gid_node, groupent_gid_cmp);
@


1.2
log
@Add support for the netid.byname YP map. This map is used by getgrouplist(3),
which is used by (amongst other things) initgroups(3) to set the supplemantary
groups on login.

OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.1 2008/06/26 15:10:01 pyr Exp $ */
a18 1
#include <sys/param.h>
d34 1
@


1.1
log
@ypldap -- Intended to be a drop-in replacement for ypserv, gluing in a
LDAP directory and thus providing support for users and groups stored in
LDAP for the get{pw,gr}ent family of functions.

As of now it relies on external LDAP libraries, choose the one of your
liking though openldap would do fine. Not linked to the builds until
some things are sorted out, having our own LDAP client code for
instance, better support for group membership lookup as well.

Remember to sync with the latest master.passwd and group files as well
to have the _ypldap user available, which is needed.

``just get it in'' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d45 1
d80 11
@

