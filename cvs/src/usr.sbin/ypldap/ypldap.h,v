head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.14.0.8
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.4
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.6
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.19
date	2017.05.30.09.33.31;	author jmatthew;	state Exp;
branches;
next	1.18;
commitid	egu4B2UiCIANQ1k3;

1.18
date	2017.01.20.12.39.36;	author benno;	state Exp;
branches;
next	1.17;
commitid	Yzi1kRLQb7fCsZzA;

1.17
date	2016.04.10.09.59.21;	author jmatthew;	state Exp;
branches;
next	1.16;
commitid	ts3vZKIMheWeZZGq;

1.16
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Uu5nFG3wCl0LACBb;

1.15
date	2014.11.03.20.15.31;	author bluhm;	state Exp;
branches;
next	1.14;
commitid	ziMZlrkCPhUaYhzj;

1.14
date	2013.03.06.21.42.40;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2012.04.30.11.28.25;	author jmatthew;	state Exp;
branches;
next	1.12;

1.12
date	2011.08.28.11.53.16;	author aschrijver;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.11.08.38.30;	author pyr;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.06.18.31.42;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.06.05.02.58;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.06.21.52.55;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2008.10.28.13.47.22;	author aschrijver;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.19.12.00.54;	author aschrijver;	state Exp;
branches;
next	1.5;

1.5
date	2008.10.14.21.41.03;	author aschrijver;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.30.16.24.16;	author aschrijver;	state Exp;
branches;
next	1.3;

1.3
date	2008.07.02.17.36.15;	author pyr;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.26.15.13.17;	author pyr;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.26.15.10.01;	author pyr;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Teach ypldap to use tls when connecting to ldap servers.
libtls help from jsing@@, linker help from deraadt@@
@
text
@/*	$OpenBSD: ypldap.h,v 1.18 2017/01/20 12:39:36 benno Exp $ */

/*
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <imsg.h>
#include <tls.h>

#define YPLDAP_USER		"_ypldap"
#define YPLDAP_CONF_FILE	"/etc/ypldap.conf"
#define YPLDAP_CERT_FILE	"/etc/ssl/cert.pem"
#define DEFAULT_INTERVAL	600
#define LINE_WIDTH		1024
#define FILTER_WIDTH		128
#define ATTR_WIDTH		32

#define        MAX_SERVERS_DNS                 8

enum imsg_type {
	IMSG_NONE,
	IMSG_CONF_START,
	IMSG_CONF_IDM,
	IMSG_CONF_END,
	IMSG_START_UPDATE,
	IMSG_END_UPDATE,
	IMSG_TRASH_UPDATE,
	IMSG_PW_ENTRY,
	IMSG_GRP_ENTRY,
	IMSG_HOST_DNS
};

struct ypldap_addr {
	TAILQ_ENTRY(ypldap_addr)	 next;
	struct sockaddr_storage          ss;
};
TAILQ_HEAD(ypldap_addr_list, ypldap_addr);

enum {
	PROC_MAIN,
	PROC_CLIENT
} ypldap_process;

static const char * const log_procnames[] = {
	"parent",
	"ldapclient"
};

struct userent {
	RB_ENTRY(userent)		 ue_name_node;
	RB_ENTRY(userent)		 ue_uid_node;
	uid_t				 ue_uid;
	char				*ue_line;
	char				*ue_netid_line;
	gid_t				 ue_gid;
};

struct groupent {
	RB_ENTRY(groupent)		 ge_name_node;
	RB_ENTRY(groupent)		 ge_gid_node;
	gid_t				 ge_gid;
	char				*ge_line;
};

enum client_state {
        STATE_NONE,
        STATE_DNS_INPROGRESS,
        STATE_DNS_TEMPFAIL,
        STATE_DNS_DONE,
	STATE_LDAP_FAIL,
	STATE_LDAP_DONE
};

/*
 * beck, djm, dlg: pay attention to the struct name
 */
struct idm {
	TAILQ_ENTRY(idm)		 idm_entry;
	u_int32_t                        idm_id;
	char				 idm_name[HOST_NAME_MAX+1];
#define F_SSL				 0x00100000
#define F_CONFIGURING			 0x00200000
#define F_NEEDAUTH			 0x00400000
#define F_STARTTLS			 0x00800000
#define F_FIXED_ATTR(n)			 (1<<n)
#define F_LIST(n)                        (1<<n)
	enum client_state		 idm_state;
	u_int32_t			 idm_flags; /* lower 20 reserved */
	u_int32_t			 idm_list;
	struct ypldap_addr_list		 idm_addr;
	in_port_t			 idm_port;
	char				 idm_binddn[LINE_WIDTH];
	char				 idm_bindcred[LINE_WIDTH];
	char				 idm_basedn[LINE_WIDTH];
	char				 idm_groupdn[LINE_WIDTH];
#define FILTER_USER			 1
#define FILTER_GROUP			 0
	char				 idm_filters[2][FILTER_WIDTH];
#define ATTR_NAME			 0
#define ATTR_PASSWD			 1
#define ATTR_UID			 2
#define ATTR_GID			 3
#define ATTR_CLASS			 4
#define ATTR_CHANGE			 5
#define ATTR_EXPIRE			 6
#define ATTR_GECOS			 7
#define ATTR_DIR			 8
#define ATTR_SHELL			 9
#define ATTR_GR_NAME			 10
#define ATTR_GR_PASSWD			 11
#define ATTR_GR_GID			 12
#define ATTR_GR_MEMBERS			 13
#define ATTR_MAX			 10
#define ATTR_GR_MIN			 10
#define ATTR_GR_MAX			 14
	char				 idm_attrs[14][ATTR_WIDTH];
	struct env			*idm_env;
	struct tls_config		*idm_tls_config;
};

struct idm_req {
	union {
		uid_t			 ik_uid;
		uid_t			 ik_gid;
	}				 ir_key;
	char				 ir_line[LINE_WIDTH];
};

struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	void			*data;
	short			 events;
};

struct env {
#define YPLDAP_OPT_VERBOSE		 0x01
#define YPLDAP_OPT_NOACTION		 0x02
	u_int8_t			 sc_opts;
#define YPMAP_PASSWD_BYNAME		 0x00000001
#define YPMAP_PASSWD_BYUID		 0x00000002
#define YPMAP_MASTER_PASSWD_BYNAME	 0x00000004
#define YPMAP_MASTER_PASSWD_BYUID	 0x00000008
#define YPMAP_GROUP_BYNAME		 0x00000010
#define YPMAP_GROUP_BYGID		 0x00000020
#define YPMAP_NETID_BYNAME		 0x00000040
	u_int32_t			 sc_flags;

	u_int32_t			 sc_maxid;

	char				 sc_domainname[HOST_NAME_MAX+1];
	struct timeval			 sc_conf_tv;
	struct event			 sc_conf_ev;
	char				*sc_cafile;
	TAILQ_HEAD(idm_list, idm)	 sc_idms;
	struct imsgev			*sc_iev;
	struct imsgev			*sc_iev_dns;

	RB_HEAD(user_name_tree,userent)	 *sc_user_names;
	RB_HEAD(user_uid_tree,userent)	 sc_user_uids;
	RB_HEAD(group_name_tree,groupent)*sc_group_names;
	RB_HEAD(group_gid_tree,groupent) sc_group_gids;
	struct user_name_tree		 *sc_user_names_t;
	struct group_name_tree		 *sc_group_names_t;
	size_t				 sc_user_line_len;
	size_t				 sc_group_line_len;
	char				*sc_user_lines;
	char				*sc_group_lines;

	struct yp_data			*sc_yp;

	int				 update_trashed;
};

/* log.c */
void		 log_init(int);
void		 log_warn(const char *, ...);
void		 log_warnx(const char *, ...);
void		 log_info(const char *, ...);
void		 log_debug(const char *, ...);
void		 logit(int, const char *, ...);
void		 vlog(int, const char *, va_list);
__dead void	 fatal(const char *);
__dead void	 fatalx(const char *);

/* parse.y */
int		 parse_config(struct env *, const char *, int);
int		 cmdline_symset(char *);

/* ldapclient.c */
pid_t		 ldapclient(int []);

/* ypldap.c */
void		 purge_config(struct env *);
void		 imsg_event_add(struct imsgev *);
int	 	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
		    pid_t, int, void *, u_int16_t);

/* entries.c */
void		 flatten_entries(struct env *);
int		 userent_name_cmp(struct userent *, struct userent *);
int		 userent_uid_cmp(struct userent *, struct userent *);
int		 groupent_name_cmp(struct groupent *, struct groupent *);
int		 groupent_gid_cmp(struct groupent *, struct groupent *);
RB_PROTOTYPE(	 user_name_tree, userent, ue_name_node, userent_name_cmp);
RB_PROTOTYPE(	 user_uid_tree, userent, ue_uid_node, userent_uid_cmp);
RB_PROTOTYPE(	 group_name_tree, groupent, ge_name_node, groupent_name_cmp);
RB_PROTOTYPE(	 group_gid_tree, groupent, ge_gid_node, groupent_gid_cmp);

/* yp.c */
void		 yp_init(struct env *);
void		 yp_enable_events(void);

/* ypldap_dns.c */
pid_t		 ypldap_dns(int[2], struct passwd *);
@


1.18
log
@work on making log.c similar in all daemons:

reduce the (mostly whitespace) differences so that log.c's can be
diffed easily. disclaimer change ok henning@@.

ok krw@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.h,v 1.17 2016/04/10 09:59:21 jmatthew Exp $ */
d20 1
d24 1
d96 1
d130 1
a130 4
	struct event			 idm_ev;
#ifdef SSL
	struct ssl			*idm_ssl;
#endif
d167 1
@


1.17
log
@convert ypldap_addr list to a tailq

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.h,v 1.16 2015/01/16 06:40:22 deraadt Exp $ */
d53 5
@


1.16
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.h,v 1.15 2014/11/03 20:15:31 bluhm Exp $ */
d44 1
a44 1
	struct ypldap_addr              *next;
d47 1
d94 1
a94 1
	struct ypldap_addr		*idm_addr;
@


1.15
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.h,v 1.14 2013/03/06 21:42:40 sthen Exp $ */
d84 1
a84 1
	char				 idm_name[MAXHOSTNAMELEN];
d158 1
a158 1
	char				 sc_domainname[MAXHOSTNAMELEN];
@


1.14
log
@as done in ospf{,6}d/relayd, sync yyerror in various other daemons with
that from bgpd, so that it logs to syslog when daemonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.h,v 1.13 2012/04/30 11:28:25 jmatthew Exp $ */
d187 1
@


1.13
log
@add 'groupdn' option for specifying a separate base DN for group searches.
from Jim Smith, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.h,v 1.12 2011/08/28 11:53:16 aschrijver Exp $ */
d187 1
@


1.12
log
@Add support for the netid.byname YP map. This map is used by getgrouplist(3),
which is used by (amongst other things) initgroups(3) to set the supplemantary
groups on login.

OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.h,v 1.11 2010/10/11 08:38:30 pyr Exp $ */
d98 1
@


1.11
log
@zap unused definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.h,v 1.10 2009/06/06 18:31:42 pyr Exp $ */
d58 2
d152 1
d176 2
@


1.10
log
@Get ready for including imsg.h from a lib, when it comes along.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.h,v 1.9 2009/06/06 05:02:58 eric Exp $ */
a186 4

/* listener.c */
void		 listener_setup(struct env *);
void		 listener_init(struct env *);
@


1.9
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.h,v 1.8 2009/01/06 21:52:55 jasper Exp $ */
d19 1
a19 1
#include "imsg.h"
@


1.8
log
@- add missing rcs id

ok aschrijver@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.h,v 1.2 2008/12/29 15:48:13 aschrijver Exp $ */
d19 2
a29 43
/* buffer */
struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 max;
	size_t			 wpos;
	size_t			 rpos;
	int			 fd;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

#define IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
#define MAX_IMSGSIZE		8192

struct buf_read {
	u_char			 buf[MAX_IMSGSIZE];
	u_char			*rptr;
	size_t			 wpos;
};

struct imsg_fd {
	TAILQ_ENTRY(imsg_fd)	entry;
	int			fd;
};

struct imsgbuf {
	TAILQ_HEAD(, imsg_fd)	 fds;
	struct buf_read		 r;
	struct msgbuf		 w;
	struct event		 ev;
	void			(*handler)(int, short, void *);
	int			 fd;
	pid_t			 pid;
	short			 events;
	void			*data;
};

a47 12
struct imsg_hdr {
	u_int16_t	 type;
	u_int16_t	 len;
	u_int32_t	 peerid;
	pid_t		 pid;
};

struct imsg {
	struct imsg_hdr	 hdr;
	void		*data;
};

d132 8
d158 2
a159 2
	struct imsgbuf			*sc_ibuf;
	struct imsgbuf			*sc_ibuf_dns;
a174 25
/* buffer.c */
struct buf	*buf_open(size_t);
struct buf	*buf_dynamic(size_t, size_t);
int		 buf_add(struct buf *, void *, size_t);
void		*buf_reserve(struct buf *, size_t);
int		 buf_close(struct msgbuf *, struct buf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);

/* imsg.c */
void	 imsg_init(struct imsgbuf *, int, void (*)(int, short, void *));
ssize_t	 imsg_read(struct imsgbuf *);
ssize_t	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    void *, u_int16_t);
struct buf *imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    u_int16_t);
int	 imsg_add(struct buf *, void *, u_int16_t);
int	 imsg_close(struct imsgbuf *, struct buf *);
void	 imsg_free(struct imsg *);
void	 imsg_event_add(struct imsgbuf *); /* needs to be provided externally */
void	 imsg_clear(struct imsgbuf *);

d197 3
@


1.7
log
@Do the DNS resolution in a seperate process. A lot of code is copied from ntpd.
This is necessary because DNS resolution is not possible from a chroot.

Cleanup the aldap interface a bit.
@
text
@d1 2
@


1.6
log
@Do the DNS resolution before the chroot and disable LDAP referrals for now.
@
text
@d24 2
d78 7
a84 1
	IMSG_GRP_ENTRY
d118 9
d132 1
d139 1
d142 1
a142 1
	struct addrinfo			 *idm_addrinfo;
d195 2
d202 1
d280 3
@


1.5
log
@Add support for referrals and lists of attributes.
@
text
@d123 1
@


1.4
log
@aldap library -- Replacement for openldap used in ypldap. aldap is an semi-asynchronous client interface to connect to LDAP servers.
@
text
@d120 1
d122 1
a152 1
	
@


1.3
log
@kill a bunch of dead code.
@
text
@d124 1
@


1.2
log
@cleanup include file. remove unneeded socket cleanup.
@
text
@d68 1
a68 9
	IMSG_NONE = 0,
	IMSG_GETPWENT = 1,	/* sends nothing expects nothing */
	IMSG_SETPWENT = 2,	/* sends nothing expects nothing */
	IMSG_GETPWNAM = 3,	/* sends a name expects a line */ 
	IMSG_GETPWID = 4,	/* sends a uid_t expects a line */
	IMSG_GETGRENT = 5,	/* sends nothing expects nothing */
	IMSG_SETGRENT = 6,	/* sends nothing expects nothing */
	IMSG_GETGRNAM = 7,	/* sends a name expects a line */ 
	IMSG_GETGRID = 8,	/* sends a uid_t expects a line */
a70 1
	IMSG_CONF_SERVER,
a90 5
enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK,
};

d94 1
a94 7
} lb_process;

union req {
	uid_t	uid;
	gid_t	gid;
	char	nam[_PW_NAME_LEN+1];
};
a209 6
#if 0
int	 imsg_get_fd(struct imsgbuf *);
int	 imsg_composev(struct imsgbuf *, enum imsg_type, u_int32_t,
	    pid_t, const struct iovec *, int);
int	 imsg_flush(struct imsgbuf *);
#endif
@


1.1
log
@ypldap -- Intended to be a drop-in replacement for ypserv, gluing in a
LDAP directory and thus providing support for users and groups stored in
LDAP for the get{pw,gr}ent family of functions.

As of now it relies on external LDAP libraries, choose the one of your
liking though openldap would do fine. Not linked to the builds until
some things are sorted out, having our own LDAP client code for
instance, better support for group membership lookup as well.

Remember to sync with the latest master.passwd and group files as well
to have the _ypldap user available, which is needed.

``just get it in'' deraadt@@
@
text
@d17 1
a17 1
#define YPLDAP_USER		"_ospfd"
a19 1
#define _PATH_LDAPBIND_SOCK	"/var/run/ypldap.sock"
@

