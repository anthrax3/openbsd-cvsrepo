head	1.21;
access;
symbols
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.12.0.10
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.6
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.21
date	2017.01.20.12.39.36;	author benno;	state Exp;
branches;
next	1.20;
commitid	Yzi1kRLQb7fCsZzA;

1.20
date	2016.11.29.17.15.27;	author mestre;	state Exp;
branches;
next	1.19;
commitid	CQYD3F1ga2KSp3i3;

1.19
date	2016.04.28.22.28.36;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	CT0dVV7rkja2zSx0;

1.18
date	2015.12.05.13.15.06;	author claudio;	state Exp;
branches;
next	1.17;
commitid	FfLQmz3yqIh8whgZ;

1.17
date	2015.11.15.01.31.57;	author jmatthew;	state Exp;
branches;
next	1.16;
commitid	7Y3xWswsfF9egpoF;

1.16
date	2015.11.02.10.06.06;	author jmatthew;	state Exp;
branches;
next	1.15;
commitid	IScUjkYEysVkyn73;

1.15
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Uu5nFG3wCl0LACBb;

1.14
date	2014.07.13.15.38.09;	author krw;	state Exp;
branches;
next	1.13;
commitid	YMZZVEWN6UliVVgC;

1.13
date	2014.07.13.12.07.59;	author krw;	state Exp;
branches;
next	1.12;
commitid	2FWuacsyDR9pZNOt;

1.12
date	2012.03.15.01.44.22;	author jmatthew;	state Exp;
branches;
next	1.11;

1.11
date	2012.03.10.01.23.08;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2011.08.28.11.53.16;	author aschrijver;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.01.18.24.04;	author zinovik;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.06.05.02.58;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.29.11.21.42;	author form;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.30.16.24.16;	author aschrijver;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.03.11.04.03;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.03.11.01.50;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2008.07.02.17.36.15;	author pyr;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.26.15.13.17;	author pyr;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.26.15.10.01;	author pyr;	state Exp;
branches;
next	;


desc
@@


1.21
log
@work on making log.c similar in all daemons:

reduce the (mostly whitespace) differences so that log.c's can be
diffed easily. disclaimer change ok henning@@.

ok krw@@ jmatthew@@
@
text
@/*	$OpenBSD: ypldap.c,v 1.20 2016/11/29 17:15:27 mestre Exp $ */

/*
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/signal.h>
#include <sys/tree.h>
#include <sys/wait.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <event.h>
#include <unistd.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "ypldap.h"
#include "log.h"

__dead void	 usage(void);
int		 check_child(pid_t, const char *);
void		 main_sig_handler(int, short, void *);
void		 main_shutdown(void);
void		 main_dispatch_client(int, short, void *);
void		 main_configure_client(struct env *);
void		 main_init_timer(int, short, void *);
void		 main_start_update(struct env *);
void		 main_trash_update(struct env *);
void		 main_end_update(struct env *);
int		 main_create_user_groups(struct env *);
void		 purge_config(struct env *);
void		 reconfigure(struct env *);

int		 pipe_main2client[2];

pid_t		 client_pid = 0;
char		*conffile = YPLDAP_CONF_FILE;
int		 opts = 0;

void
usage(void)
{
	extern const char	*__progname;

	fprintf(stderr, "usage: %s [-dnv] [-D macro=value] [-f file]\n",
	    __progname);
	exit(1);
}

int
check_child(pid_t pid, const char *pname)
{
	int	status;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("check_child: lost child %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("check_child: lost child %s terminated; "
			    "signal %d", pname, WTERMSIG(status));
			return (1);
		}
	}
	return (0);
}

/* ARGUSED */
void
main_sig_handler(int sig, short event, void *p)
{
	int		 die = 0;

	switch (sig) {
	case SIGTERM:
	case SIGINT:
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		if (check_child(client_pid, "ldap client")) {
			client_pid = 0;
			die = 1;
		}
		if (die)
			main_shutdown();
		break;
	case SIGHUP:
		/* reconfigure */
		break;
	default:
		fatalx("unexpected signal");
	}
}

void
main_shutdown(void)
{
	_exit(0);
}

void
main_start_update(struct env *env)
{
	env->update_trashed = 0;

	log_debug("starting directory update");
	env->sc_user_line_len = 0;
	env->sc_group_line_len = 0;
	if ((env->sc_user_names_t = calloc(1,
	    sizeof(*env->sc_user_names_t))) == NULL ||
	    (env->sc_group_names_t = calloc(1,
	    sizeof(*env->sc_group_names_t))) == NULL)
		fatal(NULL);
	RB_INIT(env->sc_user_names_t);
	RB_INIT(env->sc_group_names_t);
}

/*
 * XXX: Currently this function should only be called when updating is
 * finished. A notification should be send to ldapclient that it should stop
 * sending new pwd/grp entries before it can be called from different places.
 */
void
main_trash_update(struct env *env)
{
	struct userent	*ue;
	struct groupent	*ge;

	env->update_trashed = 1;

	while ((ue = RB_ROOT(env->sc_user_names_t)) != NULL) {
		RB_REMOVE(user_name_tree,
		    env->sc_user_names_t, ue);
		free(ue->ue_line);
		free(ue->ue_netid_line);
		free(ue);
	}
	free(env->sc_user_names_t);
	env->sc_user_names_t = NULL;
	while ((ge = RB_ROOT(env->sc_group_names_t))
	    != NULL) {
		RB_REMOVE(group_name_tree,
		    env->sc_group_names_t, ge);
		free(ge->ge_line);
		free(ge);
	}
	free(env->sc_group_names_t);
	env->sc_group_names_t = NULL;
}

int
main_create_user_groups(struct env *env)
{
	struct userent		*ue;
	struct userent		 ukey;
	struct groupent		*ge;
	gid_t			 pw_gid;
	char			*bp, *cp;
	char			*p;
	const char		*errstr = NULL;
	size_t			 len;

	RB_FOREACH(ue, user_name_tree, env->sc_user_names_t) {
		bp = cp = ue->ue_line;

		/* name */
		bp += strlen(bp) + 1;

		/* password */
		bp += strcspn(bp, ":") + 1;

		/* uid */
		bp += strcspn(bp, ":") + 1;

		/* gid */
		bp[strcspn(bp, ":")] = '\0';

		pw_gid = (gid_t)strtonum(bp, 0, GID_MAX, &errstr);
		if (errstr) {
			log_warnx("main: failed to parse gid for uid: %d\n", ue->ue_uid);
			return (-1);
		}

		/* bring gid column back to its proper state */
		bp[strlen(bp)] = ':';

		if ((ue->ue_netid_line = calloc(1, LINE_WIDTH)) == NULL) {
			return (-1);
		}

		if (snprintf(ue->ue_netid_line, LINE_WIDTH-1, "%d:%d", ue->ue_uid, pw_gid) >= LINE_WIDTH) {

			return (-1);
		}

		ue->ue_gid = pw_gid;
	}

	RB_FOREACH(ge, group_name_tree, env->sc_group_names_t) {
		bp = cp = ge->ge_line;

		/* name */
		bp += strlen(bp) + 1;

		/* password */
		bp += strcspn(bp, ":") + 1;

		/* gid */
		bp += strcspn(bp, ":") + 1;

		cp = bp;
		if (*bp == '\0')
			continue;
		bp = cp;
		for (;;) { 
			if (!(cp = strsep(&bp, ",")))
				break;
			ukey.ue_line = cp;
			if ((ue = RB_FIND(user_name_tree, env->sc_user_names_t,
			    &ukey)) == NULL) {
				/* User not found */
				log_warnx("main: unknown user %s in group %s\n",
				    ukey.ue_line, ge->ge_line);
				if (bp != NULL)
					*(bp-1) = ',';
				continue;
			}
			if (bp != NULL)
				*(bp-1) = ',';

			/* Make sure the new group doesn't equal to the main gid */
			if (ge->ge_gid == ue->ue_gid)
				continue;

			len = strlen(ue->ue_netid_line);
			p = ue->ue_netid_line + len;

			if ((snprintf(p, LINE_WIDTH-len-1, ",%d",
				ge->ge_gid)) >= (int)(LINE_WIDTH-len)) {
				return (-1);
			}
		}
	}

	return (0);
}

void
main_end_update(struct env *env)
{
	struct userent		*ue;
	struct groupent		*ge;

	if (env->update_trashed)
		return;

	log_debug("updates are over, cleaning up trees now");

	if (main_create_user_groups(env) == -1) {
		main_trash_update(env);
		return;
	}

	if (env->sc_user_names == NULL) {
		env->sc_user_names = env->sc_user_names_t;
		env->sc_user_lines = NULL;
		env->sc_user_names_t = NULL;

		env->sc_group_names = env->sc_group_names_t;
		env->sc_group_lines = NULL;
		env->sc_group_names_t = NULL;

		flatten_entries(env);
		goto make_uids;
	}

	/*
	 * clean previous tree.
	 */
	while ((ue = RB_ROOT(env->sc_user_names)) != NULL) {
		RB_REMOVE(user_name_tree, env->sc_user_names,
		    ue);
		free(ue->ue_netid_line);
		free(ue);
	}
	free(env->sc_user_names);
	free(env->sc_user_lines);

	env->sc_user_names = env->sc_user_names_t;
	env->sc_user_lines = NULL;
	env->sc_user_names_t = NULL;

	while ((ge = RB_ROOT(env->sc_group_names)) != NULL) {
		RB_REMOVE(group_name_tree,
		    env->sc_group_names, ge);
		free(ge);
	}
	free(env->sc_group_names);
	free(env->sc_group_lines);

	env->sc_group_names = env->sc_group_names_t;
	env->sc_group_lines = NULL;
	env->sc_group_names_t = NULL;


	flatten_entries(env);

	/*
	 * trees are flat now. build up uid, gid and netid trees.
	 */

make_uids:
	RB_INIT(&env->sc_user_uids);
	RB_INIT(&env->sc_group_gids);
	RB_FOREACH(ue, user_name_tree, env->sc_user_names)
		RB_INSERT(user_uid_tree,
		    &env->sc_user_uids, ue);
	RB_FOREACH(ge, group_name_tree, env->sc_group_names)
		RB_INSERT(group_gid_tree,
		    &env->sc_group_gids, ge);

}

void
main_dispatch_client(int fd, short events, void *p)
{
	int		 n;
	int		 shut = 0;
	struct env	*env = p;
	struct imsgev	*iev = env->sc_iev;
	struct imsgbuf	*ibuf = &iev->ibuf;
	struct idm_req	 ir;
	struct imsg	 imsg;

	if ((events & (EV_READ | EV_WRITE)) == 0)
		fatalx("unknown event");

	if (events & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)
			shut = 1;
	}
	if (events & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)
			shut = 1;
		goto done;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("main_dispatch_client: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_START_UPDATE:
			main_start_update(env);
			break;
		case IMSG_PW_ENTRY: {
			struct userent	*ue;
			size_t		 len;

			if (env->update_trashed)
				break;

			(void)memcpy(&ir, imsg.data, sizeof(ir));
			if ((ue = calloc(1, sizeof(*ue))) == NULL ||
			    (ue->ue_line = strdup(ir.ir_line)) == NULL) {
				/*
				 * should cancel tree update instead.
				 */
				fatal("out of memory");
			}
			ue->ue_uid = ir.ir_key.ik_uid;
			len = strlen(ue->ue_line) + 1;
			ue->ue_line[strcspn(ue->ue_line, ":")] = '\0';
			if (RB_INSERT(user_name_tree, env->sc_user_names_t,
			    ue) != NULL) { /* dup */
				free(ue->ue_line);
				free(ue);
			} else
				env->sc_user_line_len += len;
			break;
		}
		case IMSG_GRP_ENTRY: {
			struct groupent	*ge;
			size_t		 len;

			if (env->update_trashed)
				break;

			(void)memcpy(&ir, imsg.data, sizeof(ir));
			if ((ge = calloc(1, sizeof(*ge))) == NULL ||
			    (ge->ge_line = strdup(ir.ir_line)) == NULL) {
				/*
				 * should cancel tree update instead.
				 */
				fatal("out of memory");
			}
			ge->ge_gid = ir.ir_key.ik_gid;
			len = strlen(ge->ge_line) + 1;
			ge->ge_line[strcspn(ge->ge_line, ":")] = '\0';
			if (RB_INSERT(group_name_tree, env->sc_group_names_t,
			    ge) != NULL) { /* dup */
				free(ge->ge_line);
				free(ge);
			} else
				env->sc_group_line_len += len;
			break;
		}
		case IMSG_TRASH_UPDATE:
			main_trash_update(env);
			break;
		case IMSG_END_UPDATE: {
			main_end_update(env);
			break;
		}
		default:
			log_debug("main_dispatch_client: unexpected imsg %d",
			   imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}

done:
	if (!shut)
		imsg_event_add(iev);
	else {
		log_debug("king bula sez: ran into dead pipe");
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
main_configure_client(struct env *env)
{
	struct idm	*idm;
	struct imsgev	*iev = env->sc_iev;

	imsg_compose_event(iev, IMSG_CONF_START, 0, 0, -1, env, sizeof(*env));
	TAILQ_FOREACH(idm, &env->sc_idms, idm_entry) {
		imsg_compose_event(iev, IMSG_CONF_IDM, 0, 0, -1,
		    idm, sizeof(*idm));
	}
	imsg_compose_event(iev, IMSG_CONF_END, 0, 0, -1, NULL, 0);
}

void
main_init_timer(int fd, short event, void *p)
{
	struct env	*env = p;

	main_configure_client(env);
}

void
purge_config(struct env *env)
{
	struct idm	*idm;

	while ((idm = TAILQ_FIRST(&env->sc_idms)) != NULL) {
		TAILQ_REMOVE(&env->sc_idms, idm, idm_entry);
		free(idm);
	}
}

int
main(int argc, char *argv[])
{
	int		 c;
	int		 debug;
	struct passwd	*pw;
	struct env	 env;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct event	 ev_sigchld;
	struct event	 ev_sighup;
	struct event	 ev_timer;
	struct timeval	 tv;

	debug = 0;
	ypldap_process = PROC_MAIN;
	log_procname = log_procnames[ypldap_process];

	log_init(1);

	while ((c = getopt(argc, argv, "dD:nf:v")) != -1) {
		switch (c) {
		case 'd':
			debug = 2;
			log_verbose(debug);
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'n':
			debug = 2;
			opts |= YPLDAP_OPT_NOACTION;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'v':
			opts |= YPLDAP_OPT_VERBOSE;
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (argc)
		usage();

	RB_INIT(&env.sc_user_uids);
	RB_INIT(&env.sc_group_gids);

	if (parse_config(&env, conffile, opts))
		exit(1);
	if (opts & YPLDAP_OPT_NOACTION) {
		fprintf(stderr, "configuration OK\n");
		exit(0);
	}

	if (geteuid())
		errx(1, "need root privileges");

	log_init(debug);

	if (!debug) {
		if (daemon(1, 0) == -1)
			err(1, "failed to daemonize");
	}

	log_info("startup%s", (debug > 1)?" [debug mode]":"");

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, PF_UNSPEC,
	    pipe_main2client) == -1)
		fatal("socketpair");

	client_pid = ldapclient(pipe_main2client);

	setproctitle("parent");
	event_init();

	signal_set(&ev_sigint, SIGINT, main_sig_handler, &env);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, &env);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, &env);
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, &env);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sighup, NULL);
	signal_add(&ev_sigchld, NULL);

	close(pipe_main2client[1]);
	if ((env.sc_iev = calloc(1, sizeof(*env.sc_iev))) == NULL)
		fatal(NULL);
	imsg_init(&env.sc_iev->ibuf, pipe_main2client[0]);
	env.sc_iev->handler = main_dispatch_client;

	env.sc_iev->events = EV_READ;
	env.sc_iev->data = &env;
	event_set(&env.sc_iev->ev, env.sc_iev->ibuf.fd, env.sc_iev->events,
	     env.sc_iev->handler, &env);
	event_add(&env.sc_iev->ev, NULL);

	yp_init(&env);

	if ((pw = getpwnam(YPLDAP_USER)) == NULL)
		fatal("getpwnam");

#ifndef DEBUG
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("cannot drop privileges");
#else
#warning disabling privilege revocation in debug mode
#endif

	if (pledge("stdio inet", NULL) == -1)
		fatal("pledge");

	memset(&tv, 0, sizeof(tv));
	evtimer_set(&ev_timer, main_init_timer, &env);
	evtimer_add(&ev_timer, &tv);

	yp_enable_events();
	event_dispatch();
	main_shutdown();

	return (0);
}

void
imsg_event_add(struct imsgev *iev)
{
	if (iev->handler == NULL) {
		imsg_flush(&iev->ibuf);
		return;
	}

	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev->data);
	event_add(&iev->ev, NULL);
}

int
imsg_compose_event(struct imsgev *iev, u_int16_t type, u_int32_t peerid,
    pid_t pid, int fd, void *data, u_int16_t datalen)
{
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) != -1)
		imsg_event_add(iev);
	return (ret);
}
@


1.20
log
@Use memset(3) instead of bzero(3)

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.19 2016/04/28 22:28:36 schwarze Exp $ */
d40 1
d511 1
d519 1
@


1.19
log
@When a group contains a non-existent user, make the warning
message more helpful by mentioning the group name.
Joint work with Richie at UStA dot de.
OK jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.18 2015/12/05 13:15:06 claudio Exp $ */
d613 1
a613 1
	bzero(&tv, sizeof(tv));
@


1.18
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.17 2015/11/15 01:31:57 jmatthew Exp $ */
d244 2
a245 3
				log_warnx("main: user: %s is referenced as a "
					"group member, but can't be found in the "
					"users map.\n", ukey.ue_line);
@


1.17
log
@pledge for ypldap is easy because it's purely a network program.
One process talks to yp clients, one talks to ldap servers, one does dns.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.16 2015/11/02 10:06:06 jmatthew Exp $ */
d362 1
a362 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.16
log
@use SOCK_NONBLOCK instead of fcntl

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.15 2015/01/16 06:40:22 deraadt Exp $ */
d610 3
@


1.15
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.14 2014/07/13 15:38:09 krw Exp $ */
a31 1
#include <fcntl.h>
a53 1
void		 set_nonblock(int);
d567 1
a567 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
a570 3
	set_nonblock(pipe_main2client[0]);
	set_nonblock(pipe_main2client[1]);

a648 14
}

void
set_nonblock(int fd)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	flags |= O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
@


1.14
log
@Since the event(s) passed to a callback can be a mask of all events
of interest and EV_WRITE is or'ed into the interesting events, it
is more correct to check both events each time. Pointed out by
Claudio.

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.13 2014/07/13 12:07:59 krw Exp $ */
a19 1
#include <sys/param.h>
d22 1
d38 1
@


1.13
log
@Close connection/remove event handler when msgbuf_write() hits an
EOF.

ok jmatthew@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.12 2012/03/15 01:44:22 jmatthew Exp $ */
d349 1
a349 1
main_dispatch_client(int fd, short event, void *p)
d359 4
a362 2
	switch (event) {
	case EV_READ:
d367 2
a368 2
		break;
	case EV_WRITE:
a373 2
	default:
		fatalx("unknown event");
@


1.12
log
@don't leak ue_netid_line when freeing the old user tree

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.11 2012/03/10 01:23:08 dlg Exp $ */
d30 1
d367 1
a367 1
		if (msgbuf_write(&ibuf->w) == -1)
d369 3
a371 2
		imsg_event_add(iev);
		return;
d452 2
@


1.11
log
@ldap doesnt necessarily do referential checks on the users in a
group, so it is possible for them to list users that dont exist as
members. they should just skip such entries instead of fail horribly.

diff from jim smith
ok aschrijver@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.10 2011/08/28 11:53:16 aschrijver Exp $ */
d306 1
@


1.10
log
@Add support for the netid.byname YP map. This map is used by getgrouplist(3),
which is used by (amongst other things) initgroups(3) to set the supplemantary
groups on login.

OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.9 2010/04/01 18:24:04 zinovik Exp $ */
d249 1
a249 1
				return (-1);
@


1.9
log
@fix fatal calls, that they will report function names from which they are
called, in case of failure developer will be digging for a bug in wrong place

ok krw@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.8 2009/06/06 05:02:58 eric Exp $ */
d47 4
d124 223
d381 1
a381 10
			log_debug("starting directory update");
			env->sc_user_line_len = 0;
			env->sc_group_line_len = 0;
			if ((env->sc_user_names_t = calloc(1,
			    sizeof(*env->sc_user_names_t))) == NULL ||
			    (env->sc_group_names_t = calloc(1,
			    sizeof(*env->sc_group_names_t))) == NULL)
				fatal(NULL);
			RB_INIT(env->sc_user_names_t);
			RB_INIT(env->sc_group_names_t);
d387 3
d413 3
d435 2
a436 21
		case IMSG_TRASH_UPDATE: {
			struct userent	*ue;
			struct groupent	*ge;

			while ((ue = RB_ROOT(env->sc_user_names_t)) != NULL) {
				RB_REMOVE(user_name_tree,
				    env->sc_user_names_t, ue);
				free(ue->ue_line);
				free(ue);
			}
			free(env->sc_user_names_t);
			env->sc_user_names_t = NULL;
			while ((ge = RB_ROOT(env->sc_group_names_t))
			    != NULL) {
				RB_REMOVE(group_name_tree,
				    env->sc_group_names_t, ge);
				free(ge->ge_line);
				free(ge);
			}
			free(env->sc_group_names_t);
			env->sc_group_names_t = NULL;
a437 1
		}
d439 1
a439 61
			struct userent	*ue;
			struct groupent	*ge;

			log_debug("updates are over, cleaning up trees now");

			if (env->sc_user_names == NULL) {
				env->sc_user_names = env->sc_user_names_t;
				env->sc_user_lines = NULL;
				env->sc_user_names_t = NULL;

				env->sc_group_names = env->sc_group_names_t;
				env->sc_group_lines = NULL;
				env->sc_group_names_t = NULL;

				flatten_entries(env);
				goto make_uids;
			}

			/*
			 * clean previous tree.
			 */
			while ((ue = RB_ROOT(env->sc_user_names)) != NULL) {
				RB_REMOVE(user_name_tree, env->sc_user_names,
				    ue);
				free(ue);
			}
			free(env->sc_user_names);
			free(env->sc_user_lines);

			env->sc_user_names = env->sc_user_names_t;
			env->sc_user_lines = NULL;
			env->sc_user_names_t = NULL;

			while ((ge = RB_ROOT(env->sc_group_names)) != NULL) {
				RB_REMOVE(group_name_tree,
				    env->sc_group_names, ge);
				free(ge);
			}
			free(env->sc_group_names);
			free(env->sc_group_lines);

			env->sc_group_names = env->sc_group_names_t;
			env->sc_group_lines = NULL;
			env->sc_group_names_t = NULL;


			flatten_entries(env);

			/*
			 * trees are flat now. build up uid and gid trees.
			 */

make_uids:
			RB_INIT(&env->sc_user_uids);
			RB_INIT(&env->sc_group_gids);
			RB_FOREACH(ue, user_name_tree, env->sc_user_names)
				RB_INSERT(user_uid_tree,
				    &env->sc_user_uids, ue);
			RB_FOREACH(ge, group_name_tree, env->sc_group_names)
				RB_INSERT(group_gid_tree,
				    &env->sc_group_gids, ge);
@


1.8
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.7 2009/01/29 11:21:42 form Exp $ */
d148 1
a148 1
			fatal("main_dispatch_client: imsg_read error");
@


1.7
log
@No need to use RB_FIND here, RB_INSERT does that job for us.

ok aschrijver@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.6 2008/09/30 16:24:16 aschrijver Exp $ */
d125 2
a126 1
	struct imsgbuf	*ibuf = env->sc_ibuf;
d140 1
a140 1
		imsg_event_add(ibuf);
d306 1
a306 1
		imsg_event_add(ibuf);
d309 1
a309 1
		event_del(&ibuf->ev);
d318 1
a318 1
	struct imsgbuf	*ibuf = env->sc_ibuf;
d320 1
a320 1
	imsg_compose(ibuf, IMSG_CONF_START, 0, 0, env, sizeof(*env));
d322 2
a323 1
		imsg_compose(ibuf, IMSG_CONF_IDM, 0, 0, idm, sizeof(*idm));
d325 1
a325 1
	imsg_compose(ibuf, IMSG_CONF_END, 0, 0, NULL, 0);
d441 1
a441 1
	if ((env.sc_ibuf = calloc(1, sizeof(*env.sc_ibuf))) == NULL)
d443 2
a444 1
	imsg_init(env.sc_ibuf, pipe_main2client[0], main_dispatch_client);
d446 5
a450 5
	env.sc_ibuf->events = EV_READ;
	env.sc_ibuf->data = &env;
	event_set(&env.sc_ibuf->ev, env.sc_ibuf->fd, env.sc_ibuf->events,
	     env.sc_ibuf->handler, &env);
	event_add(&env.sc_ibuf->ev, NULL);
d478 1
a478 1
imsg_event_add(struct imsgbuf *ibuf)
d480 13
a492 1
	struct env	*env = ibuf->data;
d494 5
a498 3
	ibuf->events = EV_READ;
	if (ibuf->w.queued)
		ibuf->events |= EV_WRITE;
d500 4
a503 3
	event_del(&ibuf->ev);
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, env);
	event_add(&ibuf->ev, NULL);
@


1.6
log
@aldap library -- Replacement for openldap used in ypldap. aldap is an semi-asynchronous client interface to connect to LDAP servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.5 2008/09/03 11:04:03 jsg Exp $ */
d179 1
a179 1
			if (RB_FIND(user_name_tree, env->sc_user_names_t,
d183 2
a184 4
				break;
			}
			RB_INSERT(user_name_tree, env->sc_user_names_t, ue);
			env->sc_user_line_len += len;
d202 1
a202 1
			if (RB_FIND(group_name_tree, env->sc_group_names_t,
d206 2
a207 4
				break;
			}
			RB_INSERT(group_name_tree, env->sc_group_names_t, ge);
			env->sc_group_line_len += len;
@


1.5
log
@; -> : in getopt optstring.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.4 2008/09/03 11:01:50 jsg Exp $ */
d251 1
a251 1
	
d282 1
a282 1
			
d398 1
a398 1
	
d413 1
a413 1
	
d470 1
a470 1
	
d486 1
a486 1
	
d496 1
a496 1
 
d499 1
a499 1
        
d501 1
a501 1
         
@


1.4
log
@Missing break in case statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.3 2008/07/02 17:36:15 pyr Exp $ */
d368 1
a368 1
	while ((c = getopt(argc, argv, "dD;nf:v")) != -1) {
@


1.3
log
@kill a bunch of dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.2 2008/06/26 15:13:17 pyr Exp $ */
d381 1
@


1.2
log
@cleanup include file. remove unneeded socket cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypldap.c,v 1.1 2008/06/26 15:10:01 pyr Exp $ */
d364 1
a364 1
	lb_process = PROC_MAIN;
@


1.1
log
@ypldap -- Intended to be a drop-in replacement for ypserv, gluing in a
LDAP directory and thus providing support for users and groups stored in
LDAP for the get{pw,gr}ent family of functions.

As of now it relies on external LDAP libraries, choose the one of your
liking though openldap would do fine. Not linked to the builds until
some things are sorted out, having our own LDAP client code for
instance, better support for group membership lookup as well.

Remember to sync with the latest master.passwd and group files as well
to have the _ypldap user available, which is needed.

``just get it in'' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a115 1
	(void)unlink(_PATH_LDAPBIND_SOCK);
@

