head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.2
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.38.0.4
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.4
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.2
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.39
date	2017.05.30.09.33.31;	author jmatthew;	state Exp;
branches;
next	1.38;
commitid	egu4B2UiCIANQ1k3;

1.38
date	2017.01.20.12.39.36;	author benno;	state Exp;
branches;
next	1.37;
commitid	Yzi1kRLQb7fCsZzA;

1.37
date	2016.11.29.17.15.27;	author mestre;	state Exp;
branches;
next	1.36;
commitid	CQYD3F1ga2KSp3i3;

1.36
date	2016.04.10.09.59.21;	author jmatthew;	state Exp;
branches;
next	1.35;
commitid	ts3vZKIMheWeZZGq;

1.35
date	2015.12.05.13.15.06;	author claudio;	state Exp;
branches;
next	1.34;
commitid	FfLQmz3yqIh8whgZ;

1.34
date	2015.11.17.02.16.52;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	mR48vMZGtIikS0Ri;

1.33
date	2015.11.15.01.31.57;	author jmatthew;	state Exp;
branches;
next	1.32;
commitid	7Y3xWswsfF9egpoF;

1.32
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	Uu5nFG3wCl0LACBb;

1.31
date	2014.11.16.23.24.44;	author tedu;	state Exp;
branches;
next	1.30;
commitid	IRdpp80JeipGhTkz;

1.30
date	2014.07.13.15.38.09;	author krw;	state Exp;
branches;
next	1.29;
commitid	YMZZVEWN6UliVVgC;

1.29
date	2014.07.13.12.07.59;	author krw;	state Exp;
branches;
next	1.28;
commitid	2FWuacsyDR9pZNOt;

1.28
date	2013.11.26.12.02.59;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2013.04.30.05.14.59;	author jmatthew;	state Exp;
branches;
next	1.26;

1.26
date	2012.04.30.21.40.03;	author jmatthew;	state Exp;
branches;
next	1.25;

1.25
date	2012.04.30.11.28.25;	author jmatthew;	state Exp;
branches;
next	1.24;

1.24
date	2012.03.15.03.44.46;	author jmatthew;	state Exp;
branches;
next	1.23;

1.23
date	2011.08.28.16.37.28;	author aschrijver;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.28.11.53.16;	author aschrijver;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.17.14.34.15;	author martinh;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.17.14.24.01;	author martinh;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.13.06.12.29;	author martinh;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.09.12.17.34;	author zinovik;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.05.18.54.33;	author zinovik;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.12.09.08.56;	author zinovik;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.01.18.24.04;	author zinovik;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.06.05.02.58;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.27.23.29.42;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.27.16.17.49;	author aschrijver;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.27.11.33.22;	author aschrijver;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.26.21.56.15;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2008.10.28.13.47.22;	author aschrijver;	state Exp;
branches;
next	1.8;

1.8
date	2008.10.21.11.33.36;	author aschrijver;	state Exp;
branches;
next	1.7;

1.7
date	2008.10.20.18.19.25;	author aschrijver;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.19.12.00.54;	author aschrijver;	state Exp;
branches;
next	1.5;

1.5
date	2008.10.14.21.41.03;	author aschrijver;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.06.11.20.20;	author aschrijver;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.30.16.24.16;	author aschrijver;	state Exp;
branches;
next	1.2;

1.2
date	2008.07.02.17.36.15;	author pyr;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.26.15.10.01;	author pyr;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Teach ypldap to use tls when connecting to ldap servers.
libtls help from jsing@@, linker help from deraadt@@
@
text
@/* $OpenBSD: ldapclient.c,v 1.38 2017/01/20 12:39:36 benno Exp $ */

/*
 * Copyright (c) 2008 Alexander Schrijver <aschrijver@@openbsd.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <netdb.h>
#include <errno.h>
#include <err.h>
#include <signal.h>
#include <event.h>
#include <fcntl.h>
#include <unistd.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "aldap.h"
#include "log.h"
#include "ypldap.h"

void    client_sig_handler(int, short, void *);
void	client_dispatch_dns(int, short, void *);
void    client_dispatch_parent(int, short, void *);
void    client_shutdown(void);
void    client_connect(int, short, void *);
void    client_configure(struct env *);
void    client_periodic_update(int, short, void *);
int	client_build_req(struct idm *, struct idm_req *, struct aldap_message *,
	    int, int);
int	client_search_idm(struct env *, struct idm *, struct aldap *,
	    char **, char *, int, int, enum imsg_type);
int	client_try_idm(struct env *, struct idm *);
int	client_addr_init(struct idm *);
int	client_addr_free(struct idm *);

struct aldap	*client_aldap_open(struct ypldap_addr_list *);

/*
 * dummy wrapper to provide aldap_init with its fd's.
 */
struct aldap *
client_aldap_open(struct ypldap_addr_list *addr)
{
	int			 fd = -1;
	struct ypldap_addr	 *p;

	TAILQ_FOREACH(p, addr, next) {
		char			 hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
		struct sockaddr		*sa = (struct sockaddr *)&p->ss;

		if (getnameinfo(sa, SA_LEN(sa), hbuf, sizeof(hbuf), sbuf,
			sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV))
				errx(1, "could not get numeric hostname");

		if ((fd = socket(sa->sa_family, SOCK_STREAM, 0)) < 0)
			return NULL;

		if (connect(fd, sa, SA_LEN(sa)) == 0)
			break;

		warn("connect to %s port %s (%s) failed", hbuf, sbuf, "tcp");
		close(fd);
		fd = -1;
	}

	if (fd == -1)
		return NULL;

	return aldap_init(fd);
}

int
client_addr_init(struct idm *idm)
{
        struct sockaddr_in      *sa_in;
        struct sockaddr_in6     *sa_in6;
        struct ypldap_addr      *h;
	int                     defport;

	if (idm->idm_port != 0)
		defport = idm->idm_port;
	else if (idm->idm_flags & F_SSL)
		defport = LDAPS_PORT;
	else
		defport = LDAP_PORT;

	TAILQ_FOREACH(h, &idm->idm_addr, next) {
                switch (h->ss.ss_family) {
                case AF_INET:
                        sa_in = (struct sockaddr_in *)&h->ss;
                        if (ntohs(sa_in->sin_port) == 0)
                                sa_in->sin_port = htons(defport);
                        idm->idm_state = STATE_DNS_DONE;
                        break;
                case AF_INET6:
                        sa_in6 = (struct sockaddr_in6 *)&h->ss;
                        if (ntohs(sa_in6->sin6_port) == 0)
                                sa_in6->sin6_port = htons(defport);
                        idm->idm_state = STATE_DNS_DONE;
                        break;
                default:
                        fatalx("king bula sez: wrong AF in client_addr_init");
                        /* not reached */
                }
        }

        return (0);
}

int
client_addr_free(struct idm *idm)
{
        struct ypldap_addr	*h;

	while (!TAILQ_EMPTY(&idm->idm_addr)) {
		h = TAILQ_FIRST(&idm->idm_addr);
		TAILQ_REMOVE(&idm->idm_addr, h, next);
		free(h);
	}

	return (0);
}

void
client_sig_handler(int sig, short event, void *p)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		client_shutdown();
		break;
	default:
		fatalx("unexpected signal");
	}
}

void
client_dispatch_dns(int fd, short events, void *p)
{
	struct imsg		 imsg;
	u_int16_t		 dlen;
	u_char			*data;
	struct ypldap_addr	*h;
	int			 n, wait_cnt = 0;
	struct idm		*idm;
	int			 shut = 0;

	struct env		*env = p;
	struct imsgev		*iev = env->sc_iev_dns;
	struct imsgbuf		*ibuf = &iev->ibuf;

	if ((events & (EV_READ | EV_WRITE)) == 0)
		fatalx("unknown event");

	if (events & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)
			shut = 1;
	}
	if (events & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)
			shut = 1;
		goto done;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("client_dispatch_dns: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_HOST_DNS:
			TAILQ_FOREACH(idm, &env->sc_idms, idm_entry)
				if (idm->idm_id == imsg.hdr.peerid)
					break;
			if (idm == NULL) {
				log_warnx("IMSG_HOST_DNS with invalid peerID");
				break;
			}
			if (!TAILQ_EMPTY(&idm->idm_addr)) {
				log_warnx("IMSG_HOST_DNS but addrs set!");
				break;
			}

			dlen = imsg.hdr.len - IMSG_HEADER_SIZE;
			if (dlen == 0) {	/* no data -> temp error */
				idm->idm_state = STATE_DNS_TEMPFAIL;
				break;
			}

			data = (u_char *)imsg.data;
			while (dlen >= sizeof(struct sockaddr_storage)) {
				if ((h = calloc(1, sizeof(*h))) == NULL)
					fatal(NULL);
				memcpy(&h->ss, data, sizeof(h->ss));
				TAILQ_INSERT_HEAD(&idm->idm_addr, h, next);

				data += sizeof(h->ss);
				dlen -= sizeof(h->ss);
			}
			if (dlen != 0)
				fatalx("IMSG_HOST_DNS: dlen != 0");

			client_addr_init(idm);

			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}

	TAILQ_FOREACH(idm, &env->sc_idms, idm_entry) {
		if (client_try_idm(env, idm) == -1)
			idm->idm_state = STATE_LDAP_FAIL;

		if (idm->idm_state < STATE_LDAP_DONE)
			wait_cnt++;
	}
	if (wait_cnt == 0)
		imsg_compose_event(env->sc_iev, IMSG_END_UPDATE, 0, 0, -1,
		    NULL, 0);

done:
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
client_dispatch_parent(int fd, short events, void *p)
{
	int			 n;
	int			 shut = 0;
	struct imsg		 imsg;
	struct env		*env = p;
	struct imsgev		*iev = env->sc_iev;
	struct imsgbuf		*ibuf = &iev->ibuf;

	if ((events & (EV_READ | EV_WRITE)) == 0)
		fatalx("unknown event");

	if (events & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)
			shut = 1;
	}
	if (events & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)
			shut = 1;
		goto done;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("client_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CONF_START: {
			struct env	params;

			if (env->sc_flags & F_CONFIGURING) {
				log_warnx("configuration already in progress");
				break;
			}
			memcpy(&params, imsg.data, sizeof(params));
			log_debug("configuration starting");
			env->sc_flags |= F_CONFIGURING;
			purge_config(env);
			memcpy(&env->sc_conf_tv, &params.sc_conf_tv,
			    sizeof(env->sc_conf_tv));
			env->sc_flags |= params.sc_flags;
			break;
		}
		case IMSG_CONF_IDM: {
			struct idm	*idm;

			if (!(env->sc_flags & F_CONFIGURING))
				break;
			if ((idm = calloc(1, sizeof(*idm))) == NULL)
				fatal(NULL);
			memcpy(idm, imsg.data, sizeof(*idm));
			idm->idm_env = env;
			TAILQ_INSERT_TAIL(&env->sc_idms, idm, idm_entry);
			break;
		}
		case IMSG_CONF_END:
			env->sc_flags &= ~F_CONFIGURING;
			log_debug("applying configuration");
			client_configure(env);
			break;
		default:
			log_debug("client_dispatch_parent: unexpect imsg %d",
			    imsg.hdr.type);

			break;
		}
		imsg_free(&imsg);
	}

done:
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
client_shutdown(void)
{
	log_info("ldap client exiting");
	_exit(0);
}

pid_t
ldapclient(int pipe_main2client[2])
{
	pid_t            pid, dns_pid;
	int              pipe_dns[2];
	struct passwd	*pw;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct env	 env;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
		break;
	case 0:
		break;
	default:
		return (pid);
	}

	memset(&env, 0, sizeof(env));
	TAILQ_INIT(&env.sc_idms);

	if ((pw = getpwnam(YPLDAP_USER)) == NULL)
		fatal("getpwnam");

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_dns) == -1)
		fatal("socketpair");
	dns_pid = ypldap_dns(pipe_dns, pw);
	close(pipe_dns[1]);

#ifndef DEBUG
	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir");
#else
#warning disabling chrooting in DEBUG mode
#endif
	setproctitle("ldap client");
	ypldap_process = PROC_CLIENT;
	log_procname = log_procnames[ypldap_process];

#ifndef DEBUG
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("cannot drop privileges");
#else
#warning disabling privilege revocation in DEBUG mode
#endif

	if (pledge("stdio inet", NULL) == -1)
		fatal("pledge");

	event_init();
	signal(SIGPIPE, SIG_IGN);
	signal_set(&ev_sigint, SIGINT, client_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, client_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);

	close(pipe_main2client[0]);
	if ((env.sc_iev = calloc(1, sizeof(*env.sc_iev))) == NULL)
		fatal(NULL);
	if ((env.sc_iev_dns = calloc(1, sizeof(*env.sc_iev_dns))) == NULL)
		fatal(NULL);

	env.sc_iev->events = EV_READ;
	env.sc_iev->data = &env;
	imsg_init(&env.sc_iev->ibuf, pipe_main2client[1]);
	env.sc_iev->handler = client_dispatch_parent;
	event_set(&env.sc_iev->ev, env.sc_iev->ibuf.fd, env.sc_iev->events,
	    env.sc_iev->handler, &env);
	event_add(&env.sc_iev->ev, NULL);

	env.sc_iev_dns->events = EV_READ;
	env.sc_iev_dns->data = &env;
	imsg_init(&env.sc_iev_dns->ibuf, pipe_dns[0]);
	env.sc_iev_dns->handler = client_dispatch_dns;
	event_set(&env.sc_iev_dns->ev, env.sc_iev_dns->ibuf.fd,
	    env.sc_iev_dns->events, env.sc_iev_dns->handler, &env);
	event_add(&env.sc_iev_dns->ev, NULL);

	event_dispatch();
	client_shutdown();

	return (0);

}

int
client_build_req(struct idm *idm, struct idm_req *ir, struct aldap_message *m,
    int min_attr, int max_attr)
{
	char	**ldap_attrs;
	int	 i, k;

	memset(ir, 0, sizeof(*ir));
	for (i = min_attr; i < max_attr; i++) {
		if (idm->idm_flags & F_FIXED_ATTR(i)) {
			if (strlcat(ir->ir_line, idm->idm_attrs[i],
			    sizeof(ir->ir_line)) >= sizeof(ir->ir_line))
				/*
				 * entry yields a line > 1024, trash it.
				 */
				return (-1);

			if (i == ATTR_UID) {
				ir->ir_key.ik_uid = strtonum(
				    idm->idm_attrs[i], 0,
				    UID_MAX, NULL);
			} else if (i == ATTR_GR_GID) {
				ir->ir_key.ik_gid = strtonum(
				    idm->idm_attrs[i], 0,
				    GID_MAX, NULL);
			}
		} else if (idm->idm_list & F_LIST(i)) {
			aldap_match_attr(m, idm->idm_attrs[i], &ldap_attrs);
			for (k = 0; k >= 0 && ldap_attrs && ldap_attrs[k] != NULL; k++) {
				/* XXX: Fail when attributes have illegal characters e.g. ',' */
				if (strlcat(ir->ir_line, ldap_attrs[k],
				    sizeof(ir->ir_line)) >= sizeof(ir->ir_line))
					continue;
				if (ldap_attrs[k+1] != NULL)
					if (strlcat(ir->ir_line, ",",
						    sizeof(ir->ir_line))
					    >= sizeof(ir->ir_line)) {
						aldap_free_attr(ldap_attrs);
						return (-1);
					}
			}
			aldap_free_attr(ldap_attrs);
		} else {
			if (aldap_match_attr(m, idm->idm_attrs[i], &ldap_attrs) == -1)
				return (-1);
			if (ldap_attrs[0] == NULL)
				return (-1);
			if (strlcat(ir->ir_line, ldap_attrs[0],
			    sizeof(ir->ir_line)) >= sizeof(ir->ir_line)) {
				aldap_free_attr(ldap_attrs);
				return (-1);
			}
			if (i == ATTR_UID) {
				ir->ir_key.ik_uid = strtonum(
				    ldap_attrs[0], 0, UID_MAX, NULL);
			} else if (i == ATTR_GR_GID) {
				ir->ir_key.ik_uid = strtonum(
				    ldap_attrs[0], 0, GID_MAX, NULL);
			}
			aldap_free_attr(ldap_attrs);
		}

		if (i + 1 != max_attr)
			if (strlcat(ir->ir_line, ":",
			    sizeof(ir->ir_line)) >= sizeof(ir->ir_line))
				return (-1);
	}

	return (0);
}

int
client_search_idm(struct env *env, struct idm *idm, struct aldap *al,
    char **attrs, char *filter, int min_attr, int max_attr,
    enum imsg_type type)
{
	struct idm_req		 ir;
	struct aldap_message	*m;
	struct aldap_page_control *pg = NULL;
	const char		*errstr;
	char			*dn;

	dn = idm->idm_basedn;
	if (type == IMSG_GRP_ENTRY && idm->idm_groupdn[0] != '\0')
		dn = idm->idm_groupdn;

	do {
		if (aldap_search(al, dn, LDAP_SCOPE_SUBTREE,
		    filter, attrs, 0, 0, 0, pg) == -1) {
			aldap_get_errno(al, &errstr);
			log_debug("%s", errstr);
			return (-1);
		}

		if (pg != NULL) {
			aldap_freepage(pg);
			pg = NULL;
		}

		while ((m = aldap_parse(al)) != NULL) {
			if (al->msgid != m->msgid) {
				goto fail;
			}
			
			if (m->message_type == LDAP_RES_SEARCH_RESULT) {
				if (m->page != NULL && m->page->cookie_len != 0)
					pg = m->page;
				else
					pg = NULL;

				aldap_freemsg(m);
				break;
			}

			if (m->message_type != LDAP_RES_SEARCH_ENTRY) {
				goto fail;
			}

			if (client_build_req(idm, &ir, m, min_attr, max_attr) == 0)
				imsg_compose_event(env->sc_iev, type, 0, 0, -1,
				    &ir, sizeof(ir));

			aldap_freemsg(m);	
		}
	} while (pg != NULL);

	return (0);

fail:
	aldap_freemsg(m);	
	if (pg != NULL) {
		aldap_freepage(pg);
	}

	return (-1);
}

int
client_try_idm(struct env *env, struct idm *idm)
{
	const char		*where;
	char			*attrs[ATTR_MAX+1];
	int			 i, j;
	struct aldap_message	*m;
	struct aldap		*al;

	where = "connect";
	if ((al = client_aldap_open(&idm->idm_addr)) == NULL)
		return (-1);

	if (idm->idm_flags & F_STARTTLS) {
		log_debug("requesting starttls");
		where = "starttls";
		if (aldap_req_starttls(al) == -1)
			goto bad;

		where = "parsing";
		if ((m = aldap_parse(al)) == NULL)
			goto bad;
		where = "verifying msgid";
		if (al->msgid != m->msgid) {
			aldap_freemsg(m);
			goto bad;
		}
		where = "starttls result";
		if (aldap_get_resultcode(m) != LDAP_SUCCESS) {
			aldap_freemsg(m);
			goto bad;
		}
		aldap_freemsg(m);
	}

	if (idm->idm_flags & (F_STARTTLS | F_SSL)) {
		log_debug("starting tls");
		where = "enabling tls";
		if (aldap_tls(al, idm->idm_tls_config, idm->idm_name) < 0) {
			const char *err;
			aldap_get_errno(al, &err);
			log_debug("tls failed: %s", err);
			goto bad;
		}
	}

	if (idm->idm_flags & F_NEEDAUTH) {
		where = "binding";
		if (aldap_bind(al, idm->idm_binddn, idm->idm_bindcred) == -1)
			goto bad;

		where = "parsing";
		if ((m = aldap_parse(al)) == NULL)
			goto bad;
		where = "verifying msgid";
		if (al->msgid != m->msgid) {
			aldap_freemsg(m);
			goto bad;
		}
		aldap_freemsg(m);
	}

	memset(attrs, 0, sizeof(attrs));
	for (i = 0, j = 0; i < ATTR_MAX; i++) {
		if (idm->idm_flags & F_FIXED_ATTR(i))
			continue;
		attrs[j++] = idm->idm_attrs[i];
	}
	attrs[j] = NULL;

	/*
	 * build password line.
	 */
	where = "search";
	log_debug("searching password entries");
	if (client_search_idm(env, idm, al, attrs,
	    idm->idm_filters[FILTER_USER], 0, ATTR_MAX, IMSG_PW_ENTRY) == -1)
		goto bad;

	memset(attrs, 0, sizeof(attrs));
	for (i = ATTR_GR_MIN, j = 0; i < ATTR_GR_MAX; i++) {
		if (idm->idm_flags & F_FIXED_ATTR(i))
			continue;
		attrs[j++] = idm->idm_attrs[i];
	}
	attrs[j] = NULL;

	/*
	 * build group line.
	 */
	where = "search";
	log_debug("searching group entries");
	if (client_search_idm(env, idm, al, attrs,
	    idm->idm_filters[FILTER_GROUP], ATTR_GR_MIN, ATTR_GR_MAX,
	    IMSG_GRP_ENTRY) == -1)
		goto bad;

	aldap_close(al);

	idm->idm_state = STATE_LDAP_DONE;

	return (0);
bad:
	aldap_close(al);
	log_debug("directory %s errored out in %s", idm->idm_name, where);
	return (-1);
}

void
client_periodic_update(int fd, short event, void *p)
{
	struct env	*env = p;

	struct idm	*idm;
	int		 fail_cnt = 0;

	/* If LDAP isn't finished, notify the master process to trash the
	 * update. */
	TAILQ_FOREACH(idm, &env->sc_idms, idm_entry) {
		if (idm->idm_state < STATE_LDAP_DONE)
			fail_cnt++;

		idm->idm_state = STATE_NONE;

		client_addr_free(idm);
	}
	if (fail_cnt > 0) {
		log_debug("trash the update");
		imsg_compose_event(env->sc_iev, IMSG_TRASH_UPDATE, 0, 0, -1,
		    NULL, 0);
	}

	client_configure(env);
}

void
client_configure(struct env *env)
{
	struct timeval	 tv;
	struct idm	*idm;
        u_int16_t        dlen;

	log_debug("connecting to directories");

	imsg_compose_event(env->sc_iev, IMSG_START_UPDATE, 0, 0, -1, NULL, 0);

	/* Start the DNS lookups */
	TAILQ_FOREACH(idm, &env->sc_idms, idm_entry) {
		dlen = strlen(idm->idm_name) + 1;
		imsg_compose_event(env->sc_iev_dns, IMSG_HOST_DNS, idm->idm_id,
		    0, -1, idm->idm_name, dlen);
	}

	tv.tv_sec = env->sc_conf_tv.tv_sec;
	tv.tv_usec = env->sc_conf_tv.tv_usec;
	evtimer_set(&env->sc_conf_ev, client_periodic_update, env);
	evtimer_add(&env->sc_conf_ev, &tv);
}
@


1.38
log
@work on making log.c similar in all daemons:

reduce the (mostly whitespace) differences so that log.c's can be
diffed easily. disclaimer change ok henning@@.

ok krw@@ jmatthew@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.37 2016/11/29 17:15:27 mestre Exp $ */
d87 1
d101 9
a109 1
        struct ypldap_addr         *h;
d116 1
a116 1
                                sa_in->sin_port = htons(LDAP_PORT);
d122 1
a122 1
                                sa_in6->sin6_port = htons(LDAP_PORT);
d595 33
@


1.37
log
@Use memset(3) instead of bzero(3)

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.36 2016/04/10 09:59:21 jmatthew Exp $ */
d42 1
d387 1
@


1.36
log
@convert ypldap_addr list to a tailq

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.35 2015/12/05 13:15:06 claudio Exp $ */
d365 1
a365 1
	bzero(&env, sizeof(env));
d442 1
a442 1
	bzero(ir, sizeof(*ir));
d601 1
a601 1
	bzero(attrs, sizeof(attrs));
d618 1
a618 1
	bzero(attrs, sizeof(attrs));
@


1.35
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.34 2015/11/17 02:16:52 deraadt Exp $ */
d59 1
a59 1
struct aldap	*client_aldap_open(struct ypldap_addr *);
d65 1
a65 1
client_aldap_open(struct ypldap_addr *addr)
d70 1
a70 1
	for (p = addr; p != NULL; p = p->next) {
d101 1
a101 1
        for (h = idm->idm_addr; h != NULL; h = h->next) {
d127 1
a127 1
        struct ypldap_addr         *h, *p;
d129 3
a131 5
	if (idm->idm_addr == NULL)
		return (-1);

	for (h = idm->idm_addr; h != NULL; h = p) {
		p = h->next;
a134 2
	idm->idm_addr = NULL;

d198 2
a199 2
			if (idm->idm_addr != NULL) {
				log_warnx("IMSG_HOST_DNS but addr != NULL!");
d211 1
a211 2
				if ((h = calloc(1, sizeof(struct ypldap_addr))) ==
				    NULL)
d214 1
a214 7

				if (idm->idm_addr == NULL)
					h->next = NULL;
				else
					h->next = idm->idm_addr;

				idm->idm_addr = h;
d582 1
a582 1
	if ((al = client_aldap_open(idm->idm_addr)) == NULL)
@


1.34
log
@clean headers
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.33 2015/11/15 01:31:57 jmatthew Exp $ */
d174 1
a174 1
		if ((n = imsg_read(ibuf)) == -1)
d277 1
a277 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.33
log
@pledge for ypldap is easy because it's purely a network program.
One process talks to yp clients, one talks to ldap servers, one does dns.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.32 2015/01/16 06:40:22 deraadt Exp $ */
a22 1
#include <sys/signal.h>
d31 1
@


1.32
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.31 2014/11/16 23:24:44 tedu Exp $ */
d406 3
@


1.31
log
@use sa_family instead of hard coded inet. from Yury Konovalov
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.30 2014/07/13 15:38:09 krw Exp $ */
a20 1
#include <sys/param.h>
d23 1
d39 1
@


1.30
log
@Since the event(s) passed to a callback can be a mask of all events
of interest and EV_WRITE is or'ed into the interesting events, it
is more correct to check both events each time. Pointed out by
Claudio.

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.29 2014/07/13 12:07:59 krw Exp $ */
d77 1
a77 1
		if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
@


1.29
log
@Close connection/remove event handler when msgbuf_write() hits an
EOF.

ok jmatthew@@ claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.28 2013/11/26 12:02:59 henning Exp $ */
d155 1
a155 1
client_dispatch_dns(int fd, short event, void *p)
d169 4
a172 2
	switch (event) {
	case EV_READ:
d177 2
a178 2
		break;
	case EV_WRITE:
a183 2
	default:
		fatalx("unknown event");
d263 1
a263 1
client_dispatch_parent(int fd, short event, void *p)
d272 2
d275 1
a275 2
	switch (event) {
	case EV_READ:
d280 2
a281 2
		break;
	case EV_WRITE:
a286 2
	default:
		fatalx("unknown event");
@


1.28
log
@msgbuf_write EAGAIN, ok gilles benno
all of these from a long train ride
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.26 2012/04/30 21:40:03 jmatthew Exp $ */
d177 1
a177 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d179 3
a181 2
		imsg_event_add(iev);
		return;
d252 1
d281 1
a281 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d283 3
a285 2
		imsg_event_add(iev);
		return;
d338 2
@


1.27
log
@ignore SIGPIPE so we don't fall over if an ldap connection breaks

ok dlg@@
@
text
@d177 1
a177 1
		if (msgbuf_write(&ibuf->w) == -1)
d279 1
a279 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.26
log
@Use paged searches so we can handle larger directories.  Servers that don't
understand paging, such as ldapd(8), ignore it and return a single set of
results as before.
from Jim Smith, some tweaks and fixes by me, ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.25 2012/04/30 11:28:25 jmatthew Exp $ */
d403 1
@


1.25
log
@add 'groupdn' option for specifying a separate base DN for group searches.
from Jim Smith, ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.24 2012/03/15 03:44:46 jmatthew Exp $ */
d515 1
d523 5
a527 10
	if (aldap_search(al, dn, LDAP_SCOPE_SUBTREE,
		    filter, attrs, 0, 0, 0) == -1) {
		aldap_get_errno(al, &errstr);
		log_debug("%s", errstr);
		return (-1);
	}

	while ((m = aldap_parse(al)) != NULL) {
		if (al->msgid != m->msgid) {
			aldap_freemsg(m);
d530 4
a533 4
		/* end of the search result chain */
		if (m->message_type == LDAP_RES_SEARCH_RESULT) {
			aldap_freemsg(m);
			break;
d535 25
a559 4
		/* search entry; the rest we won't handle */
		if (m->message_type != LDAP_RES_SEARCH_ENTRY) {
			aldap_freemsg(m);
			return (-1);
d561 3
d565 4
a568 4
		if (client_build_req(idm, &ir, m, min_attr, max_attr) == 0)
			imsg_compose_event(env->sc_iev, type, 0, 0, -1,
			    &ir, sizeof(ir));
		aldap_freemsg(m);
d571 1
a571 1
	return (0);
@


1.24
log
@Accept empty/nonexistant ldap attributes when we want a list.  This allows
empty groups to show up, which is helpful if they're used as primary
groups.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.23 2011/08/28 16:37:28 aschrijver Exp $ */
d516 1
d518 5
a522 1
	if (aldap_search(al, idm->idm_basedn, LDAP_SCOPE_SUBTREE,
@


1.23
log
@Use the correct terminology, replace the term "entry" with the term "attribute" where applicable.

OK martinh@@ pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.22 2011/08/28 11:53:16 aschrijver Exp $ */
d464 3
a466 6
			if (aldap_match_attr(m, idm->idm_attrs[i], &ldap_attrs) == -1)
				return (-1);
			if (ldap_attrs[0] == NULL)
				return (-1);
			for (k = 0; k >= 0 && ldap_attrs[k] != NULL; k++) {
				/* XXX: Fail when attributes have ilegal characters e.g. ',' */
@


1.22
log
@Add support for the netid.byname YP map. This map is used by getgrouplist(3),
which is used by (amongst other things) initgroups(3) to set the supplemantary
groups on login.

OK pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.21 2011/01/17 14:34:15 martinh Exp $ */
d464 1
a464 1
			if (aldap_match_entry(m, idm->idm_attrs[i], &ldap_attrs) == -1)
d469 1
a469 1
				/* XXX: Fail when entries have ilegal characters e.g. ',' */
d477 1
a477 1
						aldap_free_entry(ldap_attrs);
d481 1
a481 1
			aldap_free_entry(ldap_attrs);
d483 1
a483 1
			if (aldap_match_entry(m, idm->idm_attrs[i], &ldap_attrs) == -1)
d489 1
a489 1
				aldap_free_entry(ldap_attrs);
d499 1
a499 1
			aldap_free_entry(ldap_attrs);
@


1.21
log
@Refactor ldap searches for passwd and group queries into a common
client_search_idm function.

ok pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.20 2011/01/17 14:24:01 martinh Exp $ */
d469 1
@


1.20
log
@extract common code for building the idm_req struct for passwords
and groups in a new function client_build_req

ok pyr@@

CV: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.19 2011/01/13 06:12:29 martinh Exp $ */
d52 2
d511 41
d554 1
a554 1
	const char		*where, *errstr;
a556 1
	struct idm_req		 ir;
a587 8
	where = "search";
	if (aldap_search(al, idm->idm_basedn, LDAP_SCOPE_SUBTREE,
		    idm->idm_filters[FILTER_USER], attrs, 0, 0, 0) == -1) {
		aldap_get_errno(al, &errstr);
		log_debug("%s\n", errstr);
		goto bad;
	}

d591 5
a595 23
	while ((m = aldap_parse(al)) != NULL) {
		where = "verifying msgid";
		if (al->msgid != m->msgid) {
			aldap_freemsg(m);
			goto bad;
		}
		/* end of the search result chain */
		if (m->message_type == LDAP_RES_SEARCH_RESULT) {
			aldap_freemsg(m);
			break;
		}
		/* search entry; the rest we won't handle */
		where = "verifying message_type";
		if (m->message_type != LDAP_RES_SEARCH_ENTRY) {
			aldap_freemsg(m);
			goto bad;
		}

		if (client_build_req(idm, &ir, m, 0, ATTR_MAX) == 0)
			imsg_compose_event(env->sc_iev, IMSG_PW_ENTRY, 0, 0, -1,
			    &ir, sizeof(ir));
		aldap_freemsg(m);
	}
a604 9
	where = "search";
	if (aldap_search(al, idm->idm_basedn, LDAP_SCOPE_SUBTREE,
		    idm->idm_filters[FILTER_GROUP], attrs, 0, 0, 0) == -1) {
		aldap_get_errno(al, &errstr);
		log_debug("%s\n", errstr);
		
		goto bad;
	}

d608 6
a613 24
	while ((m = aldap_parse(al)) != NULL) {
		where = "verifying msgid";
		if (al->msgid != m->msgid) {
			aldap_freemsg(m);
			goto bad;
		}
		/* end of the search result chain */
		if (m->message_type == LDAP_RES_SEARCH_RESULT) {
			aldap_freemsg(m);
			break;
		}
		/* search entry; the rest we won't handle */
		where = "verifying message_type";
		if (m->message_type != LDAP_RES_SEARCH_ENTRY) {
			aldap_freemsg(m);
			goto bad;
		}

		if (client_build_req(idm, &ir, m, ATTR_GR_MIN, ATTR_GR_MAX) == 0)
			imsg_compose_event(env->sc_iev, IMSG_GRP_ENTRY, 0, 0, -1,
			    &ir, sizeof(ir));

		aldap_freemsg(m);
	}
@


1.19
log
@Remove forward declarations of non-existant functions.
ok pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.18 2010/07/09 12:17:34 zinovik Exp $ */
d50 2
d436 73
d513 1
a513 2
	char			**ldap_attrs;
	int			 i, j, k;
d574 4
a577 57
		/* search entry */
		bzero(&ir, sizeof(ir));
		for (i = 0, j = 0; i < ATTR_MAX; i++) {
			if (idm->idm_flags & F_FIXED_ATTR(i)) {
				if (strlcat(ir.ir_line, idm->idm_attrs[i],
				    sizeof(ir.ir_line)) >= sizeof(ir.ir_line))
					/*
					 * entry yields a line > 1024, trash it.
					 */
					goto next_pwdentry;
				if (i == ATTR_UID) {
					ir.ir_key.ik_uid = strtonum(
					    idm->idm_attrs[i], 0,
					    UID_MAX, NULL);
				}
			} else if (idm->idm_list & F_LIST(i)) {
				if (aldap_match_entry(m, attrs[j++], &ldap_attrs) == -1)
					goto next_pwdentry;
				if (ldap_attrs[0] == NULL)
					goto next_pwdentry;
				for (k = 0; k >= 0 && ldap_attrs[k] != NULL; k++) {
					if (strlcat(ir.ir_line, ldap_attrs[k],
					    sizeof(ir.ir_line)) >= sizeof(ir.ir_line))
						continue;
					if (ldap_attrs[k+1] != NULL)
						if (strlcat(ir.ir_line, ",",
							    sizeof(ir.ir_line))
						    >= sizeof(ir.ir_line)) {
							aldap_free_entry(ldap_attrs);
							goto next_pwdentry;
						}
				}
				aldap_free_entry(ldap_attrs);
			} else {
				if (aldap_match_entry(m, attrs[j++], &ldap_attrs) == -1)
					goto next_pwdentry;
				if (ldap_attrs[0] == NULL)
					goto next_pwdentry;
				if (strlcat(ir.ir_line, ldap_attrs[0],
				    sizeof(ir.ir_line)) >= sizeof(ir.ir_line)) {
					aldap_free_entry(ldap_attrs);
					goto next_pwdentry;
				}
				if (i == ATTR_UID) {
					ir.ir_key.ik_uid = strtonum(
					    ldap_attrs[0], 0, UID_MAX, NULL);
				}
				aldap_free_entry(ldap_attrs);
			}
			if (i != ATTR_SHELL)
				if (strlcat(ir.ir_line, ":",
				    sizeof(ir.ir_line)) >= sizeof(ir.ir_line))
					goto next_pwdentry;
		}
		imsg_compose_event(env->sc_iev, IMSG_PW_ENTRY, 0, 0, -1,
		    &ir, sizeof(ir));
next_pwdentry:
d618 5
a622 57
		/* search entry */
		bzero(&ir, sizeof(ir));
		for (i = ATTR_GR_MIN, j = 0; i < ATTR_GR_MAX; i++) {
			if (idm->idm_flags & F_FIXED_ATTR(i)) {
				if (strlcat(ir.ir_line, idm->idm_attrs[i],
				    sizeof(ir.ir_line)) >= sizeof(ir.ir_line))
					/*
					 * entry yields a line > 1024, trash it.
					 */
					goto next_grpentry;
				if (i == ATTR_GR_GID) {
					ir.ir_key.ik_gid = strtonum(
					    idm->idm_attrs[i], 0,
					    GID_MAX, NULL);
				}
			} else if (idm->idm_list & F_LIST(i)) {
				if (aldap_match_entry(m, attrs[j++], &ldap_attrs) == -1)
					goto next_grpentry;
				if (ldap_attrs[0] == NULL)
					goto next_grpentry;
				for (k = 0; k >= 0 && ldap_attrs[k] != NULL; k++) {
					if (strlcat(ir.ir_line, ldap_attrs[k],
					    sizeof(ir.ir_line)) >= sizeof(ir.ir_line))
						continue;
					if (ldap_attrs[k+1] != NULL)
						if (strlcat(ir.ir_line, ",",
							    sizeof(ir.ir_line))
						    >= sizeof(ir.ir_line)) {
							aldap_free_entry(ldap_attrs);
							goto next_grpentry;
						}
				}
				aldap_free_entry(ldap_attrs);
			} else {
				if (aldap_match_entry(m, attrs[j++], &ldap_attrs) == -1)
					goto next_grpentry;
				if (ldap_attrs[0] == NULL)
					goto next_grpentry;
				if (strlcat(ir.ir_line, ldap_attrs[0],
				    sizeof(ir.ir_line)) >= sizeof(ir.ir_line)) {
					aldap_free_entry(ldap_attrs);
					goto next_grpentry;
				}
				if (i == ATTR_GR_GID) {
					ir.ir_key.ik_uid = strtonum(
					    ldap_attrs[0], 0, GID_MAX, NULL);
				}
				aldap_free_entry(ldap_attrs);
			}
			if (i != ATTR_GR_MEMBERS)
				if (strlcat(ir.ir_line, ":",
				    sizeof(ir.ir_line)) >= sizeof(ir.ir_line))
					goto next_grpentry;
		}
		imsg_compose_event(env->sc_iev, IMSG_GRP_ENTRY, 0, 0, -1,
		    &ir, sizeof(ir));
next_grpentry:
@


1.18
log
@use macro defines for magical numbers, instead hardcoded values

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.17 2010/07/05 18:54:33 zinovik Exp $ */
a50 2
void	client_try_idm_wrapper(int, short, void *);
void	client_try_server_wrapper(int, short, void *);
@


1.17
log
@original `for' loop has bug `use after free'.  At first iteration we are
checking h != NULL, then we free(h) and then we do `h = h->next', but `h' is
not valid anymore.

ok @@krw
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.16 2010/06/12 09:08:56 zinovik Exp $ */
d103 1
a103 1
                                sa_in->sin_port = htons(389);
d109 1
a109 1
                                sa_in6->sin6_port = htons(389);
@


1.16
log
@at line 445 `al' is allocated via `aldap_init' in `client_aldap_open'
function, but when further in code we might do `goto bad', `al' is not freed
with `aldap_close', so plug memory leak on error path

tested by jasper@@

ok pyr@@, jasper@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.15 2010/04/01 18:24:04 zinovik Exp $ */
d124 1
a124 1
        struct ypldap_addr         *h;
d129 2
a130 1
	for (h = idm->idm_addr; h != NULL; h = h->next)
d132 1
@


1.15
log
@fix fatal calls, that they will report function names from which they are
called, in case of failure developer will be digging for a bug in wrong place

ok krw@@, pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.14 2009/06/06 05:02:58 eric Exp $ */
d663 1
@


1.14
log
@Sync with relayd:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

ok pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.13 2009/01/27 23:29:42 pyr Exp $ */
d183 1
a183 1
			fatal("client_dispatch_parent: imsg_read_error");
d285 1
a285 1
			fatal("client_dispatch_parent: imsg_read_error");
@


1.13
log
@keep namespace clean.
discussed w/ aschrijver@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.12 2009/01/27 16:17:49 aschrijver Exp $ */
d162 2
a163 1
	struct imsgbuf		*ibuf = env->sc_ibuf_dns;
d175 1
a175 1
		imsg_event_add(ibuf);
d244 2
a245 1
		imsg_compose(env->sc_ibuf, IMSG_END_UPDATE, 0, 0, NULL, 0);
d248 1
a248 1
		imsg_event_add(ibuf);
d251 1
a251 1
		event_del(&ibuf->ev);
d263 2
a264 1
	struct imsgbuf		*ibuf = env->sc_ibuf;
d277 1
a277 1
		imsg_event_add(ibuf);
d332 1
a332 1
		imsg_event_add(ibuf);
d335 1
a335 1
		event_del(&ibuf->ev);
d405 1
a405 1
	if ((env.sc_ibuf = calloc(1, sizeof(*env.sc_ibuf))) == NULL)
d407 1
a407 1
	if ((env.sc_ibuf_dns = calloc(1, sizeof(*env.sc_ibuf_dns))) == NULL)
d410 15
a424 13
	env.sc_ibuf->events = EV_READ;
	env.sc_ibuf->data = &env;
	imsg_init(env.sc_ibuf, pipe_main2client[1], client_dispatch_parent);
	event_set(&env.sc_ibuf->ev, env.sc_ibuf->fd, env.sc_ibuf->events,
	    env.sc_ibuf->handler, &env);
	event_add(&env.sc_ibuf->ev, NULL);

	env.sc_ibuf_dns->events = EV_READ;
	env.sc_ibuf_dns->data = &env;
	imsg_init(env.sc_ibuf_dns, pipe_dns[0], client_dispatch_dns);
	event_set(&env.sc_ibuf_dns->ev, env.sc_ibuf_dns->fd, env.sc_ibuf_dns->events,
	    env.sc_ibuf_dns->handler, &env);
	event_add(&env.sc_ibuf_dns->ev, NULL);
d554 1
a554 1
		imsg_compose(env->sc_ibuf, IMSG_PW_ENTRY, 0, 0,
d651 1
a651 1
		imsg_compose(env->sc_ibuf, IMSG_GRP_ENTRY, 0, 0,
d687 2
a688 1
		imsg_compose(env->sc_ibuf, IMSG_TRASH_UPDATE, 0, 0, NULL, 0);
d703 1
a703 1
	imsg_compose(env->sc_ibuf, IMSG_START_UPDATE, 0, 0, NULL, 0);
d708 2
a709 2
		imsg_compose(env->sc_ibuf_dns, IMSG_HOST_DNS, idm->idm_id, 0,
		    idm->idm_name, dlen);
@


1.12
log
@

Add space after keywords.
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.11 2009/01/27 11:33:22 aschrijver Exp $ */
d56 1
a56 1
struct aldap	*aldap_open(struct ypldap_addr *);
d58 3
d62 1
a62 1
aldap_open(struct ypldap_addr *addr)
d440 1
a440 1
	if ((al = aldap_open(idm->idm_addr)) == NULL)
@


1.11
log
@

Add correct error handling to the aldap API.
Use the error handling in the ldapclient.

with help from pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.10 2009/01/26 21:56:15 pyr Exp $ */
d64 1
a64 1
	for(p = addr; p != NULL; p = p->next) {
d82 1
a82 1
	if(fd == -1)
d123 1
a123 1
	if(idm->idm_addr == NULL)
d210 1
a210 1
				if(idm->idm_addr == NULL)
d233 1
a233 1
		if(client_try_idm(env, idm) == -1)
d236 1
a236 1
		if(idm->idm_state < STATE_LDAP_DONE)
d239 1
a239 1
	if(wait_cnt == 0)
d437 1
a437 1
	if((al = aldap_open(idm->idm_addr)) == NULL)
d442 1
a442 1
		if(aldap_bind(al, idm->idm_binddn, idm->idm_bindcred) == -1)
d446 1
a446 1
		if((m = aldap_parse(al)) == NULL)
d449 1
a449 1
		if(al->msgid != m->msgid) {
d465 1
a465 1
	if(aldap_search(al, idm->idm_basedn, LDAP_SCOPE_SUBTREE,
d475 1
a475 1
	while((m = aldap_parse(al)) != NULL) {
d477 1
a477 1
		if(al->msgid != m->msgid) {
d488 1
a488 1
		if(m->message_type != LDAP_RES_SEARCH_ENTRY) {
d512 1
a512 1
				for(k = 0; k >= 0 && ldap_attrs[k] != NULL; k++) {
d516 1
a516 1
					if(ldap_attrs[k+1] != NULL)
d561 1
a561 1
	if(aldap_search(al, idm->idm_basedn, LDAP_SCOPE_SUBTREE,
d572 1
a572 1
	while((m = aldap_parse(al)) != NULL) {
d574 1
a574 1
		if(al->msgid != m->msgid) {
d585 1
a585 1
		if(m->message_type != LDAP_RES_SEARCH_ENTRY) {
d609 1
a609 1
				for(k = 0; k >= 0 && ldap_attrs[k] != NULL; k++) {
d613 1
a613 1
					if(ldap_attrs[k+1] != NULL)
d623 1
a623 1
				if(aldap_match_entry(m, attrs[j++], &ldap_attrs) == -1)
d670 1
a670 1
		if(idm->idm_state < STATE_LDAP_DONE)
d677 1
a677 1
	if(fail_cnt > 0) {
@


1.10
log
@move aldap_close in aldap.c, where it belongs.
discussed with aschrijver@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.9 2008/10/28 13:47:22 aschrijver Exp $ */
d428 1
a428 1
	const char		*where;
d466 3
a468 1
		    idm->idm_filters[FILTER_USER], attrs, 0, 0, 0) == -1)
d470 1
d562 4
a565 1
		    idm->idm_filters[FILTER_GROUP], attrs, 0, 0, 0) == -1)
d567 1
@


1.9
log
@Do the DNS resolution in a seperate process. A lot of code is copied from ntpd.
This is necessary because DNS resolution is not possible from a chroot.

Cleanup the aldap interface a bit.
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.8 2008/10/21 11:33:36 aschrijver Exp $ */
a56 12
int		 aldap_close(struct aldap *);

int
aldap_close(struct aldap *al)
{
	if(close(al->ber.fd) == -1)
		return (-1);

	free(al);

	return (0);
}
@


1.8
log
@Oops, freed to much memory.
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.7 2008/10/20 18:19:25 aschrijver Exp $ */
d44 1
d49 1
a49 1
void    client_configure_wrapper(int, short, void *);
d53 2
d56 1
a56 6
int	do_build_group(struct env *, struct idm *, struct aldap *, char *, enum
    scope, char *);
int	do_build_passwd(struct env *, struct idm *, struct aldap *, char *, enum
    scope, char *);

struct aldap	*aldap_openidm(struct idm *idm);
a57 4
#ifdef REFERRALS
struct aldap	*connect_to_referral(struct aldap_message *, struct aldap_url *);
struct aldap	*aldap_openhost(char *, char *);
#endif
d71 1
a71 1
aldap_openidm(struct idm *idm)
d73 2
a74 2
	int			 fd;
	struct addrinfo		*res0;
d76 3
a78 3
	res0 = idm->idm_addrinfo;
	do {
		char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
d80 1
a80 1
		if (getnameinfo(res0->ai_addr, res0->ai_addrlen, hbuf, sizeof(hbuf), sbuf,
d84 2
a85 3
		if ((fd = socket(res0->ai_family, res0->ai_socktype,
		    res0->ai_protocol)) < 0)
			continue;
d87 1
a87 1
		if (connect(fd, res0->ai_addr, res0->ai_addrlen) == 0)
a88 2
		else
			warn("connect to %s port %s (%s) failed", hbuf, sbuf, "tcp");
d90 1
d92 1
a92 2
		fd = -1;
	} while ((res0 = res0->ai_next) != NULL);
d100 45
d160 104
d356 2
a357 1
	pid_t		 pid;
d379 5
d413 2
d423 7
d437 2
a438 2
void
client_configure_wrapper(int fd, short event, void *p)
d440 6
a445 10
	struct env	*env = p;

	client_configure(env);
}

#ifdef REFERRALS
struct aldap *
aldap_openhost(char *host, char *port)
{
	struct addrinfo		 hints;
a446 1
	int			 fd;
d448 3
a450 2
	struct addrinfo *res, *res0;
	int error;
d452 4
a455 4
	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
d457 7
a463 45
	log_debug("trying directory: %s", host);

	if ((error = getaddrinfo(host, port, &hints, &res)))
		errx(1, "getaddrinfo: %s", gai_strerror(error));

	res0 = res;
	do {
		if ((fd = socket(res0->ai_family, res0->ai_socktype,
		    res0->ai_protocol)) < 0)
			continue;

		if (connect(fd, res0->ai_addr, res0->ai_addrlen) == 0)
			break;
		else
			warn("connect to %s port %s (%s) failed", host, port, "tcp");

		close(fd);
		fd = -1;
	} while ((res0 = res0->ai_next) != NULL);

	freeaddrinfo(res);

	if(fd == -1)
		return NULL;

	return aldap_init(fd);
}

struct aldap *
connect_to_referral(struct aldap_message *m, struct aldap_url *lu)
{
	int			 i;
	char			**refs, *port;
	struct aldap		*al = NULL;

	if((refs = aldap_get_references(m)) == NULL)
		return NULL;

	for(i = 0; i >= 0 && refs[i] != NULL; i++) {
		aldap_parse_url(refs[i], lu);
		asprintf(&port, "%d", lu->port ? lu->port : 389);

		if((al = aldap_openhost(lu->host, port)) != NULL) {
			free(port);
			break;
d465 1
a465 2

		free(port);
a467 23
	aldap_free_references(refs);

	return al;
}
#endif

#define MAX_REFERRALS 10
int
do_build_group(struct env *env, struct idm *idm, struct aldap *al, char
    *basedn, enum scope scope, char *filter)
{
	char			*attrs[ATTR_MAX+1];
	char			**ldap_attrs;
	struct idm_req		 ir;
	struct aldap_message	*m;
	int			i, j, k;
	const char		*where;
#ifdef REFERRALS
	static int		 refcnt = 0;
	struct aldap_url	 lu;
	struct aldap		*al_ref;
#endif

d469 1
a469 1
	for (i = ATTR_GR_MIN, j = 0; i < ATTR_GR_MAX; i++) {
d477 2
a478 1
	if(aldap_search(al, basedn, scope, filter, attrs, 0, 0, 0) == -1)
d482 1
a482 1
	 * build group line.
a489 30
#ifdef REFERRALS
		/* continuation referral */
		if (m->message_type == LDAP_RES_SEARCH_REFERENCE) {
			if(refcnt++ >= MAX_REFERRALS)
				goto next_entry;

			if((al_ref = connect_to_referral(m, &lu)) == NULL)
				goto next_entry;
			do_build_group(env, idm, al_ref, lu.dn,
			    lu.scope, idm->idm_filters[FILTER_GROUP]);
			aldap_close(al_ref);
			goto next_entry;
		}
		/* normal referral */
		if(m->message_type == LDAP_RES_SEARCH_RESULT &&
		    aldap_get_resultcode(m) == LDAP_REFERRAL) {
			if(refcnt++ == MAX_REFERRALS) {
				aldap_freemsg(m);
				break;
			}

			if((al_ref = connect_to_referral(m, &lu)) == NULL) {
				aldap_freemsg(m);
				break;
			}
			do_build_group(env, idm, al_ref, lu.dn,
			    lu.scope, idm->idm_filters[FILTER_GROUP]);
			aldap_close(al_ref);
		}
#endif
d503 1
a503 1
		for (i = ATTR_GR_MIN, j = 0; i < ATTR_GR_MAX; i++) {
d510 3
a512 3
					goto next_entry;
				if (i == ATTR_GR_GID) {
					ir.ir_key.ik_gid = strtonum(
d514 1
a514 1
					    GID_MAX, NULL);
d518 3
a520 3
					goto next_entry;
				if (ldap_attrs == NULL || ldap_attrs[0] == NULL)
					goto next_entry;
d530 1
a530 1
							goto next_entry;
d535 4
a538 4
				if(aldap_match_entry(m, attrs[j++], &ldap_attrs) == -1)
					goto next_entry;
				if (ldap_attrs == NULL || ldap_attrs[0] == NULL)
					goto next_entry;
d542 1
a542 1
					goto next_entry;
d544 1
a544 1
				if (i == ATTR_GR_GID) {
d546 1
a546 1
					    ldap_attrs[0], 0, GID_MAX, NULL);
d550 1
a550 1
			if (i != ATTR_GR_MEMBERS)
d553 1
a553 1
					goto next_entry;
d555 1
a555 1
		imsg_compose(env->sc_ibuf, IMSG_GRP_ENTRY, 0, 0,
d557 1
a557 1
next_entry:
a560 22
	return (0);
bad:
	log_debug("directory %s errored out in %s", idm->idm_name, where);
	return (-1);
}

int
do_build_passwd(struct env *env, struct idm *idm, struct aldap *al, char
    *basedn, enum scope scope, char *filter)
{
	char			*attrs[ATTR_MAX+1];
	char			**ldap_attrs;
	struct idm_req		 ir;
	struct aldap_message	*m;
	int			 i, j, k;
	const char		*where;
#ifdef REFERRALS
	static int		 refcnt = 0;
	struct aldap_url	 lu;
	struct aldap		*al_ref;
#endif

d562 1
a562 1
	for (i = 0, j = 0; i < ATTR_MAX; i++) {
d570 2
a571 1
	if(aldap_search(al, basedn, scope, filter, attrs, 0, 0, 0) == -1)
d575 1
a575 1
	 * build password line.
a582 30
#ifdef REFERRALS
		/* continuation referral */
		if (m->message_type == LDAP_RES_SEARCH_REFERENCE) {
			if(refcnt++ >= MAX_REFERRALS)
				goto next_entry;

			if((al_ref = connect_to_referral(m, &lu)) == NULL)
				goto next_entry;
			do_build_passwd(env, idm, al_ref, lu.dn,
			    lu.scope, idm->idm_filters[FILTER_USER]);
			aldap_close(al_ref);
			goto next_entry;
		}
		/* normal referral */
		if(m->message_type == LDAP_RES_SEARCH_RESULT &&
		    aldap_get_resultcode(m) == LDAP_REFERRAL) {
			if(refcnt++ == MAX_REFERRALS) {
				aldap_freemsg(m);
				break;
			}

			if((al_ref = connect_to_referral(m, &lu)) == NULL) {
				aldap_freemsg(m);
				break;
			}
			do_build_passwd(env, idm, al_ref, lu.dn,
			    lu.scope, idm->idm_filters[FILTER_USER]);
			aldap_close(al_ref);
		}
#endif
d596 1
a596 1
		for (i = 0, j = 0; i < ATTR_MAX; i++) {
d603 3
a605 3
					goto next_entry;
				if (i == ATTR_UID) {
					ir.ir_key.ik_uid = strtonum(
d607 1
a607 1
					    UID_MAX, NULL);
d611 3
a613 3
					goto next_entry;
				if (ldap_attrs == NULL || ldap_attrs[0] == NULL)
					goto next_entry;
d623 1
a623 1
							goto next_entry;
d628 4
a631 4
				if (aldap_match_entry(m, attrs[j++], &ldap_attrs) == -1)
					goto next_entry;
				if (ldap_attrs == NULL || ldap_attrs[0] == NULL)
					goto next_entry;
d635 1
a635 1
					goto next_entry;
d637 1
a637 1
				if (i == ATTR_UID) {
d639 1
a639 1
					    ldap_attrs[0], 0, UID_MAX, NULL);
d643 1
a643 1
			if (i != ATTR_SHELL)
d646 1
a646 1
					goto next_entry;
d648 1
a648 1
		imsg_compose(env->sc_ibuf, IMSG_PW_ENTRY, 0, 0,
d650 1
a650 1
next_entry:
d654 4
d664 2
a665 3

int
client_try_idm(struct env *env, struct idm *idm)
d667 1
a667 4
	const char		*where;
	struct idm_req		 ir;
	struct aldap_message	*m;
	struct aldap		*al;
d669 2
a670 2
	bzero(&ir, sizeof(ir));
	imsg_compose(env->sc_ibuf, IMSG_START_UPDATE, 0, 0, &ir, sizeof(ir));
d672 5
a676 3
	where = "connect";
	if((al = aldap_openidm(idm)) == NULL)
		goto bad;
d678 1
a678 4
	if (idm->idm_flags & F_NEEDAUTH) {
		where = "binding";
		if(aldap_bind(al, idm->idm_binddn, idm->idm_bindcred) == -1)
			goto bad;
d680 5
a684 9
		where = "parsing";
		if((m = aldap_parse(al)) == NULL)
			goto bad;
		where = "verifying msgid";
		if(al->msgid != m->msgid) {
			aldap_freemsg(m);
			goto bad;
		}
		aldap_freemsg(m);
d687 1
a687 11
	do_build_passwd(env, idm, al, idm->idm_basedn, LDAP_SCOPE_SUBTREE,
	    idm->idm_filters[FILTER_USER]);
	do_build_group(env, idm, al, idm->idm_basedn, LDAP_SCOPE_SUBTREE,
	    idm->idm_filters[FILTER_GROUP]);

	aldap_close(al);

	return (0);
bad:
	log_debug("directory %s errored out in %s", idm->idm_name, where);
	return (-1);
a692 1
	enum imsg_type	 finish;
d695 1
d698 1
a698 1
	finish = IMSG_END_UPDATE;
d700 8
a707 6
	TAILQ_FOREACH(idm, &env->sc_idms, idm_entry)
		if (client_try_idm(env, idm) == -1) {
			finish = IMSG_TRASH_UPDATE;
			break;
		}
	imsg_compose(env->sc_ibuf, finish, 0, 0, NULL, 0);
d710 1
a710 1
	evtimer_set(&env->sc_conf_ev, client_configure_wrapper, env);
@


1.7
log
@Do not stop connecting after the first connect fails.

OK mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.6 2008/10/19 12:00:54 aschrijver Exp $ */
a101 3

	freeaddrinfo(idm->idm_addrinfo);
	idm->idm_addrinfo = NULL;
@


1.6
log
@Do the DNS resolution before the chroot and disable LDAP referrals for now.
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.5 2008/10/14 21:41:03 aschrijver Exp $ */
d96 1
a96 1
		else {
a97 2
			return NULL;
		}
d103 6
d322 1
a322 1
		else {
a323 2
			return NULL;
		}
d331 1
a331 1
	if((al = aldap_init(fd)) == NULL)
d334 1
a334 1
	return al;
@


1.5
log
@Add support for referrals and lists of attributes.
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.4 2008/10/06 11:20:20 aschrijver Exp $ */
d58 1
a58 1
struct aldap	*aldap_open(char *, char *);
d60 1
d62 2
d77 1
a77 1
aldap_open(char *host, char *port)
a78 2
	struct addrinfo		 hints;
	struct aldap		*al;
d80 1
d82 3
a84 2
	struct addrinfo *res, *res0;
	int error;
d86 3
a88 4
	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
a89 7
	log_debug("trying directory: %s", host);

	if ((error = getaddrinfo(host, port, &hints, &res)))
		errx(1, "getaddrinfo: %s", gai_strerror(error));

	res0 = res;
	do {
d97 1
a97 1
			warn("connect to %s port %s (%s) failed", host, port, "tcp");
d105 2
a106 1
	freeaddrinfo(res);
a107 5
	if((al = aldap_init(fd)) == NULL)
		return NULL;

	return al;
}
d289 46
d349 1
a349 1
		if((al = aldap_open(lu->host, port)) != NULL) {
d361 1
a371 2
	struct aldap_url	 lu;
	struct aldap		*al_ref;
d374 1
d376 3
d401 1
d430 1
d437 1
a515 2
	struct aldap_url	 lu;
	struct aldap		*al_ref;
d518 1
d520 3
d545 1
d574 1
d581 1
d665 1
a665 1
	if((al = aldap_open(idm->idm_name, "389")) == NULL)
@


1.4
log
@Oops, also commit the header file. Remove silly debug message.
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.3 2008/09/30 16:24:16 aschrijver Exp $ */
a39 1
#define LDAP_DEPRECATED 1
a40 1

d53 16
a68 1
static int	remote_connect(const char *, const char *, struct addrinfo);
d70 5
a74 2
static int
remote_connect(const char *host, const char *port, struct addrinfo hints)
d76 4
d81 8
a88 1
	int s, error;
d95 1
a95 1
		if ((s = socket(res0->ai_family, res0->ai_socktype,
d99 1
a99 1
		if (connect(s, res0->ai_addr, res0->ai_addrlen) == 0)
d101 1
a101 1
		else
d103 2
d106 2
a107 2
		close(s);
		s = -1;
d112 4
a115 1
	return (s);
d298 28
d327 2
a328 1
client_try_idm(struct env *env, struct idm *idm)
a329 1
	int			i, j, fd;
a331 1
	const char		*where;
a332 1
	struct addrinfo		 hints;
d334 5
a338 31
	struct aldap		*al;

	log_debug("trying directory: %s", idm->idm_name);

	bzero(&ir, sizeof(ir));
	imsg_compose(env->sc_ibuf, IMSG_START_UPDATE, 0, 0, &ir, sizeof(ir));

	/* connect to LDAP server */
	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	where = "connect";
	fd = remote_connect(idm->idm_name, "389", hints);
	if(fd == -1)
		goto bad;

	al = aldap_init(fd);
	if(al == NULL)
		goto bad;

	/* do a bind request */
	if(aldap_bind(al, idm->idm_binddn, idm->idm_bindcred) == -1)
		goto bad;
	where = "parsing";
	if((m = aldap_parse(al)) == NULL)
		goto bad;
	if(al->msgid != m->msgid)
		goto bad; /* XXX: error reporting */
	aldap_freemsg(m);
d341 1
a341 1
	for (i = 0, j = 0; i < ATTR_MAX; i++) {
d348 3
a350 3
	/* do a search request */
	aldap_search(al, idm->idm_basedn, LDAP_SCOPE_SUBTREE,
	    idm->idm_filters[FILTER_USER], attrs, 0, 0, 0);
d353 1
a353 1
	 * build password line.
d356 36
a391 3
		if(al->msgid != m->msgid)
			goto bad; /* XXX: error reporting */
		if (m->message_type == LDAP_RES_SEARCH_RESULT)
d393 7
d401 1
a401 1
		for (i = 0, j = 0; i < ATTR_MAX; i++) {
d408 3
a410 3
					continue;
				if (i == ATTR_UID) {
					ir.ir_key.ik_uid = strtonum(
d412 18
a429 1
					    UID_MAX, NULL);
d431 1
d433 2
a434 1
				aldap_match_entry(m, attrs[j++], &ldap_attrs);
d436 1
a436 1
					continue;
d438 5
a442 3
				    sizeof(ir.ir_line)) >= sizeof(ir.ir_line))
					continue;
				if (i == ATTR_UID) {
d444 1
a444 1
					    ldap_attrs[0], 0, UID_MAX, NULL);
d448 1
a448 1
			if (i != ATTR_SHELL)
d451 1
a451 1
					continue;
d453 1
a453 1
		imsg_compose(env->sc_ibuf, IMSG_PW_ENTRY, 0, 0,
d455 2
d459 19
a477 3
	/*
	 * exact same code but for groups.
	 */
d480 1
a480 1
	for (i = ATTR_GR_MIN, j = 0; i < ATTR_GR_MAX; i++) {
d487 3
a489 2
	aldap_search(al, idm->idm_basedn, LDAP_SCOPE_SUBTREE,
	    idm->idm_filters[FILTER_GROUP], attrs, 0, 0, 0);
d491 3
d495 36
a530 3
		if(al->msgid != m->msgid)
			goto bad; /* XXX: error reporting */
		if (m->message_type == LDAP_RES_SEARCH_RESULT)
d532 7
d540 1
a540 1
		for (i = ATTR_GR_MIN, j = 0; i < ATTR_GR_MAX; i++) {
d547 3
a549 3
					continue;
				if (i == ATTR_GR_GID) {
					ir.ir_key.ik_gid = strtonum(
d551 18
a568 1
					    GID_MAX, NULL);
d570 1
d572 2
a573 1
				aldap_match_entry(m, attrs[j++], &ldap_attrs);
d575 1
a575 1
					continue;
d577 5
a581 3
				    sizeof(ir.ir_line)) >= sizeof(ir.ir_line))
					continue;
				if (i == ATTR_GR_GID) {
d583 1
a583 1
					    ldap_attrs[0], 0, GID_MAX, NULL);
d587 1
a587 1
			if (i != ATTR_GR_MEMBERS)
d590 1
a590 1
					continue;
d592 1
a592 1
		imsg_compose(env->sc_ibuf, IMSG_GRP_ENTRY, 0, 0,
d594 2
d597 45
@


1.3
log
@aldap library -- Replacement for openldap used in ypldap. aldap is an semi-asynchronous client interface to connect to LDAP servers.
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.2 2008/07/02 17:36:15 pyr Exp $ */
a421 1
	printf("dusss\n");
@


1.2
log
@kill a bunch of dead code.
@
text
@d1 1
a1 1
/* $OpenBSD: ldapclient.c,v 1.1 2008/06/26 15:10:01 pyr Exp $ */
d4 1
d29 1
d31 1
d41 1
a41 1
#include <ldap.h>
d55 31
d168 1
a168 1
			
d210 1
a210 1
	
d243 1
a243 1
	
d255 1
a255 1
	
d269 8
a276 10
	int		 i;
	int		 j;
	int		 msgid;
	size_t		 n;
	LDAP		*ld;
	LDAPMessage	*lm;
	char		**ldap_attrs;
	char		*attrs[ATTR_MAX+1];
	const char	*where;
	struct idm_req	 ir;
d283 9
a291 2
	where = "ldap_open";
	if ((ld = ldap_open(idm->idm_name, LDAP_PORT)) == NULL)
d293 3
a295 4
	
	where = "ldap_bind";
	if (ldap_bind(ld, idm->idm_binddn,
	    idm->idm_bindcred, LDAP_AUTH_SIMPLE) < 0)
d298 10
a314 5
	
	where = "ldap_search";
	if ((msgid = ldap_search(ld, idm->idm_binddn, LDAP_SCOPE_SUBTREE,
	    idm->idm_filters[FILTER_USER], attrs, 0)) < 0)
		goto bad;
d316 3
a318 10
	where = "ldap_result";
	if (ldap_result(ld, msgid, 1, NULL, &lm) == -1)
		goto bad;

	where = "ldap_result_message";
	if (lm == NULL)
		goto bad;
	where = "ldap_first_message";
	if ((lm = ldap_first_message(ld, lm)) == NULL)
		goto bad;
d323 5
a327 2
	n = ldap_count_entries(ld, lm);
	while (n-- > 0) {
d336 1
a336 1
					goto next_entry;
d343 3
a345 4
				ldap_attrs = (char **)ldap_get_values(ld,
				    lm, attrs[j++]);
				if (ldap_attrs == NULL)
					goto next_entry;
d348 1
a348 1
					goto next_entry;
d353 1
a353 1
				ldap_value_free(ldap_attrs);
d358 1
a358 2
					goto next_entry;

a361 4
next_entry:
		where = "ldap_next_message";
		if ((lm = ldap_next_message(ld, lm)) == NULL)
			goto bad;
d376 2
a377 4
	where = "ldap_search";
	if ((msgid = ldap_search(ld, idm->idm_binddn, LDAP_SCOPE_SUBTREE,
	    idm->idm_filters[FILTER_GROUP], attrs, 0)) < 0)
		goto bad;
d379 5
a383 18
	where = "ldap_result";
	if (ldap_result(ld, msgid, 1, NULL, &lm) == -1)
		goto bad;

	where = "ldap_result_message";
	if (lm == NULL)
		goto bad;

	where = "ldap_first_message";
	if ((lm = ldap_first_message(ld, lm)) == NULL)
		goto bad;

	/*
	 * build group line.
	 */

	n = ldap_count_entries(ld, lm);
	while (n--) {
d392 1
a392 1
					goto next_group_entry;
d399 3
a401 4
				ldap_attrs = (char **)ldap_get_values(ld,
				    lm, attrs[j++]);
				if (ldap_attrs == NULL)
					goto next_group_entry;
d404 1
a404 1
					goto next_group_entry;
d406 1
a406 1
					ir.ir_key.ik_gid = strtonum(
d409 1
a409 1
				ldap_value_free(ldap_attrs);
d414 1
a414 2
					goto next_group_entry;

a417 4
next_group_entry:
		where = "ldap_next_message";
		if ((lm = ldap_next_message(ld, lm)) == NULL)
			goto bad;
d422 1
@


1.1
log
@ypldap -- Intended to be a drop-in replacement for ypserv, gluing in a
LDAP directory and thus providing support for users and groups stored in
LDAP for the get{pw,gr}ent family of functions.

As of now it relies on external LDAP libraries, choose the one of your
liking though openldap would do fine. Not linked to the builds until
some things are sorted out, having our own LDAP client code for
instance, better support for group membership lookup as well.

Remember to sync with the latest master.passwd and group files as well
to have the _ypldap user available, which is needed.

``just get it in'' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d189 1
a189 1
	lb_process = PROC_CLIENT;
@

