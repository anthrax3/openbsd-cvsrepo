head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.6
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.8
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.6
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.11.29.17.15.27;	author mestre;	state Exp;
branches;
next	1.17;
commitid	CQYD3F1ga2KSp3i3;

1.17
date	2016.01.24.08.33.27;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	sSRmZ0Uvlxcgh9DO;

1.16
date	2016.01.24.08.30.38;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	c06LwHOlrZhqXzVZ;

1.15
date	2016.01.24.08.28.12;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	qb17LGc48Dlsnkbr;

1.14
date	2015.02.11.01.26.00;	author pelikan;	state Exp;
branches;
next	1.13;
commitid	sZPSGfvEBjjLtOKO;

1.13
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	Uu5nFG3wCl0LACBb;

1.12
date	2013.10.01.12.00.34;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2011.08.28.11.53.16;	author aschrijver;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.13.06.09.35;	author martinh;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.13.06.07.42;	author martinh;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.13.06.05.18;	author martinh;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.20.05.12.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2010.08.03.08.24.23;	author pyr;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.06.11.55.01;	author ajacoutot;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.10.23.51.56;	author robert;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.23.19.37.38;	author blambert;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.02.07.40.50;	author bernd;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.26.15.10.01;	author pyr;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Use memset(3) instead of bzero(3)

OK deraadt@@
@
text
@/*	$OpenBSD: yp.c,v 1.17 2016/01/24 08:33:27 matthieu Exp $ */
/*
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <sys/tree.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <unistd.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include <rpc/rpc.h>
#include <rpc/xdr.h>
#include <rpc/pmap_clnt.h>
#include <rpc/pmap_prot.h>
#include <rpc/pmap_rmt.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>

#include "ypldap.h"

void	yp_dispatch(struct svc_req *, SVCXPRT *);
void	yp_disable_events(void);
void	yp_fd_event(int, short, void *);
int	yp_check(struct svc_req *);
int	yp_valid_domain(char *, struct ypresp_val *);
void	yp_make_val(struct ypresp_val *, char *, int);
void	yp_make_keyval(struct ypresp_key_val *, char *, char *);

static struct env	*env;

struct yp_event {
	TAILQ_ENTRY(yp_event)	 ye_entry;
	struct event		 ye_event;
};

struct yp_data {
	SVCXPRT			*yp_trans_udp;
	SVCXPRT			*yp_trans_tcp;
	TAILQ_HEAD(, yp_event)	 yd_events;
};

void
yp_disable_events(void)
{
	struct yp_event	*ye;

	while ((ye = TAILQ_FIRST(&env->sc_yp->yd_events)) != NULL) {
		TAILQ_REMOVE(&env->sc_yp->yd_events, ye, ye_entry);
		event_del(&ye->ye_event);
		free(ye);
	}
}

void
yp_enable_events(void)
{
	int		 i;
	extern fd_set	*__svc_fdset;
	extern int	 __svc_fdsetsize;
	struct yp_event	*ye;

	for (i = 0; i < __svc_fdsetsize; i++) {
		if (FD_ISSET(i, __svc_fdset)) {
			if ((ye = calloc(1, sizeof(*ye))) == NULL)
				fatal(NULL);
			event_set(&ye->ye_event, i, EV_READ, yp_fd_event, NULL);
			event_add(&ye->ye_event, NULL);
			TAILQ_INSERT_TAIL(&env->sc_yp->yd_events, ye, ye_entry);
		}
	}
}

void
yp_fd_event(int fd, short event, void *p)
{
	svc_getreq_common(fd);
	yp_disable_events();
	yp_enable_events();
}

void
yp_init(struct env *x_env)
{
	struct yp_data	*yp;

	if ((yp = calloc(1, sizeof(*yp))) == NULL)
		fatal(NULL);
	TAILQ_INIT(&yp->yd_events);

	env = x_env;
	env->sc_yp = yp;
	
	(void)pmap_unset(YPPROG, YPVERS);

	if ((yp->yp_trans_udp = svcudp_create(RPC_ANYSOCK)) == NULL)
		fatal("cannot create udp service");
	if ((yp->yp_trans_tcp = svctcp_create(RPC_ANYSOCK, 0, 0)) == NULL)
		fatal("cannot create tcp service");

	if (!svc_register(yp->yp_trans_udp, YPPROG, YPVERS,
	    yp_dispatch, IPPROTO_UDP)) {
		fatal("unable to register (YPPROG, YPVERS, udp)");
	}
	if (!svc_register(yp->yp_trans_tcp, YPPROG, YPVERS,
	    yp_dispatch, IPPROTO_TCP)) {
		fatal("unable to register (YPPROG, YPVERS, tcp)");
	}
}

/*
 * lots of inspiration from ypserv by Mats O Jansson
 */
void
yp_dispatch(struct svc_req *req, SVCXPRT *trans)
{
	xdrproc_t		 xdr_argument;
	xdrproc_t		 xdr_result;
	char			*result;
	char			*(*cb)(char *, struct svc_req *);
        union {
		domainname	 ypproc_domain_2_arg;
		domainname	 ypproc_domain_nonack_2_arg;
		ypreq_key	 ypproc_match_2_arg;
		ypreq_nokey	 ypproc_first_2_arg;
		ypreq_key	 ypproc_next_2_arg;
		ypreq_xfr	 ypproc_xfr_2_arg;
		ypreq_nokey	 ypproc_all_2_arg;
		ypreq_nokey	 ypproc_master_2_arg;
		ypreq_nokey	 ypproc_order_2_arg;
		domainname	 ypproc_maplist_2_arg;
	} argument;

	xdr_argument = (xdrproc_t) xdr_void;
	xdr_result = (xdrproc_t) xdr_void;
	cb = NULL;
	switch (req->rq_proc) {
	case YPPROC_NULL:
		xdr_argument = (xdrproc_t) xdr_void;
		xdr_result = (xdrproc_t) xdr_void;
		if (yp_check(req) == -1)
			return;
		result = NULL;
		if (!svc_sendreply(trans, (xdrproc_t) xdr_void,
		    (void *)&result))
			svcerr_systemerr(trans);
		return;
	case YPPROC_DOMAIN:
		xdr_argument = (xdrproc_t) xdr_domainname;
		xdr_result = (xdrproc_t) xdr_bool;
		if (yp_check(req) == -1)
			return;
		cb = (void *)ypproc_domain_2_svc;
		break;
	case YPPROC_DOMAIN_NONACK:
		xdr_argument = (xdrproc_t) xdr_domainname;
		xdr_result = (xdrproc_t) xdr_bool;
		if (yp_check(req) == -1)
			return;
		cb = (void *)ypproc_domain_nonack_2_svc;
		break;
	case YPPROC_MATCH:
		xdr_argument = (xdrproc_t) xdr_ypreq_key;
		xdr_result = (xdrproc_t) xdr_ypresp_val;
		if (yp_check(req) == -1)
			return;
		cb = (void *)ypproc_match_2_svc;
		break;
	case YPPROC_FIRST:
		xdr_argument = (xdrproc_t) xdr_ypreq_nokey;
		xdr_result = (xdrproc_t) xdr_ypresp_key_val;
		if (yp_check(req) == -1)
			return;
		cb = (void *)ypproc_first_2_svc;
		break;
	case YPPROC_NEXT:
		xdr_argument = (xdrproc_t) xdr_ypreq_key;
		xdr_result = (xdrproc_t) xdr_ypresp_key_val;
		if (yp_check(req) == -1)
			return;
		cb = (void *)ypproc_next_2_svc;
		break;
	case YPPROC_XFR:
		if (yp_check(req) == -1)
			return;
		svcerr_noproc(trans);
		return;
	case YPPROC_CLEAR:
		log_debug("ypproc_clear");
		if (yp_check(req) == -1)
			return;
		svcerr_noproc(trans);
		return;
	case YPPROC_ALL:
		log_debug("ypproc_all");
		xdr_argument = (xdrproc_t) xdr_ypreq_nokey;
		xdr_result = (xdrproc_t) xdr_ypresp_all;
		if (yp_check(req) == -1)
			return;
		cb = (void *)ypproc_all_2_svc;
		break;
	case YPPROC_MASTER:
		xdr_argument = (xdrproc_t) xdr_ypreq_nokey;
		xdr_result = (xdrproc_t) xdr_ypresp_master;
		if (yp_check(req) == -1)
			return;
		cb = (void *)ypproc_master_2_svc;
		break;
	case YPPROC_ORDER:
		log_debug("ypproc_order");
		if (yp_check(req) == -1)
			return;
		svcerr_noproc(trans);
		return;
	case YPPROC_MAPLIST:
		xdr_argument = (xdrproc_t) xdr_domainname;
		xdr_result = (xdrproc_t) xdr_ypresp_maplist;
		if (yp_check(req) == -1)
			return;
		cb = (void *)ypproc_maplist_2_svc;
		break;
	default:
		svcerr_noproc(trans);
		return;
	}
	(void)memset(&argument, 0, sizeof(argument));

	if (!svc_getargs(trans, xdr_argument, (caddr_t)&argument)) {
		svcerr_decode(trans);
		return;
	}
	result = (*cb)((char *)&argument, req);
	if (result != NULL && !svc_sendreply(trans, xdr_result, result))
		svcerr_systemerr(trans);
	if (!svc_freeargs(trans, xdr_argument, (caddr_t)&argument)) {
		/*
		 * ypserv does it too.
		 */
		fatal("unable to free arguments");
	}
}

int
yp_check(struct svc_req *req)
{
	struct sockaddr_in	*caller;

	caller = svc_getcaller(req->rq_xprt);
	/*
	 * We might want to know who we allow here.
	 */
	return (0);
}

int
yp_valid_domain(char *domain, struct ypresp_val *res)
{
	if (domain == NULL) {
		log_debug("NULL domain !");
		return (-1);
	}
	if (strcmp(domain, env->sc_domainname) != 0) {
		res->stat = YP_NODOM;
		return (-1);
	}
	return (0);
}

bool_t *
ypproc_domain_2_svc(domainname *arg, struct svc_req *req)
{
	static bool_t	res;
	
	res = (bool_t)1;
	if (strcmp(*arg, env->sc_domainname) != 0)
		res = (bool_t)0;
	return (&res);
}

bool_t *
ypproc_domain_nonack_2_svc(domainname *arg, struct svc_req *req)
{
	static bool_t	res;
	
	if (strcmp(*arg, env->sc_domainname) != 0)
		return NULL;
	res = (bool_t)1;
	return (&res);
}

ypresp_val *
ypproc_match_2_svc(ypreq_key *arg, struct svc_req *req)
{
	struct userent		 ukey;
	struct userent		*ue;
	struct groupent		 gkey;
	struct groupent		*ge;
	static struct ypresp_val res;
	const char		*estr;
	char			*bp, *cp;
	char			 key[YPMAXRECORD+1];

	log_debug("matching '%.*s' in map %s", arg->key.keydat_len,
	   arg->key.keydat_val, arg->map);

	if (yp_valid_domain(arg->domain, (struct ypresp_val *)&res) == -1)
		return (&res);

	if (env->sc_user_names == NULL) {
		/*
		 * tree not ready.
		 */
		return (NULL);
	}

	if (arg->key.keydat_len > YPMAXRECORD) {
		log_debug("argument too long");
		return (NULL);
	}
	memset(key, 0, sizeof(key));
	(void)strncpy(key, arg->key.keydat_val, arg->key.keydat_len);

	if (strcmp(arg->map, "passwd.byname") == 0 ||
	    strcmp(arg->map, "master.passwd.byname") == 0) {
		ukey.ue_line = key;
		if ((ue = RB_FIND(user_name_tree, env->sc_user_names,
		    &ukey)) == NULL) {
			res.stat = YP_NOKEY;
			return (&res);
		}

		yp_make_val(&res, ue->ue_line, 1);
		return (&res);
	} else if (strcmp(arg->map, "passwd.byuid") == 0 ||
		   strcmp(arg->map, "master.passwd.byuid") == 0) {
		ukey.ue_uid = strtonum(key, 0, UID_MAX, &estr); 
		if (estr) {
			res.stat = YP_BADARGS;
			return (&res);
		}

		if ((ue = RB_FIND(user_uid_tree, &env->sc_user_uids,
		    &ukey)) == NULL) {
			res.stat = YP_NOKEY;
			return (&res);
		}

		yp_make_val(&res, ue->ue_line, 1);
		return (&res);
	} else if (strcmp(arg->map, "group.bygid") == 0) {
		gkey.ge_gid = strtonum(key, 0, GID_MAX, &estr); 
		if (estr) {
			res.stat = YP_BADARGS;
			return (&res);
		}
		if ((ge = RB_FIND(group_gid_tree, &env->sc_group_gids,
		    &gkey)) == NULL) {
			res.stat = YP_NOKEY;
			return (&res);
		}

		yp_make_val(&res, ge->ge_line, 1);
		return (&res);
	} else if (strcmp(arg->map, "group.byname") == 0) {
		gkey.ge_line = key;
		if ((ge = RB_FIND(group_name_tree, env->sc_group_names,
		    &gkey)) == NULL) {
			res.stat = YP_NOKEY;
			return (&res);
		}

		yp_make_val(&res, ge->ge_line, 1);
		return (&res);
	} else if (strcmp(arg->map, "netid.byname") == 0) {
		bp = cp = key;

		if (strncmp(bp, "unix.", strlen("unix.")) != 0) {
			res.stat = YP_BADARGS;
			return (&res);
		}

		bp += strlen("unix.");

		if (*bp == '\0') {
			res.stat = YP_BADARGS;
			return (&res);
		}

		if (!(cp = strsep(&bp, "@@"))) {
			res.stat = YP_BADARGS;
			return (&res);
		}

		if (strcmp(bp, arg->domain) != 0) {
			res.stat = YP_BADARGS;
			return (&res);
		}

		ukey.ue_uid = strtonum(cp, 0, UID_MAX, &estr); 
		if (estr) {
			res.stat = YP_BADARGS;
			return (&res);
		}

		if ((ue = RB_FIND(user_uid_tree, &env->sc_user_uids,
		    &ukey)) == NULL) {
			res.stat = YP_NOKEY;
			return (&res);
		}

		yp_make_val(&res, ue->ue_netid_line, 0);
		return (&res);
	
	} else {
		log_debug("unknown map %s", arg->map);
		res.stat = YP_NOMAP;
		return (&res);
	}
}

ypresp_key_val *
ypproc_first_2_svc(ypreq_nokey *arg, struct svc_req *req)
{
	static struct ypresp_key_val	res;

	if (yp_valid_domain(arg->domain, (struct ypresp_val *)&res) == -1)
		return (&res);

	if (strcmp(arg->map, "passwd.byname") == 0 ||
	    strcmp(arg->map, "master.passwd.byname") == 0) {
		if (env->sc_user_lines == NULL)
			return (NULL);

		yp_make_keyval(&res, env->sc_user_lines, env->sc_user_lines);
	} else if (strcmp(arg->map, "group.byname") == 0) {
		if (env->sc_group_lines == NULL)
			return (NULL);

		yp_make_keyval(&res, env->sc_group_lines, env->sc_group_lines);
	} else {
		log_debug("unknown map %s", arg->map);
		res.stat = YP_NOMAP;
	}

	return (&res);
}

ypresp_key_val *
ypproc_next_2_svc(ypreq_key *arg, struct svc_req *req)
{
	struct userent			 ukey;
	struct userent			*ue;
	struct groupent			 gkey;
	struct groupent			*ge;
	char				*line;
	static struct ypresp_key_val	 res;
	char				 key[YPMAXRECORD+1];

	if (yp_valid_domain(arg->domain, (struct ypresp_val *)&res) == -1)
		return (&res);

	if (strcmp(arg->map, "passwd.byname") == 0 ||
	    strcmp(arg->map, "master.passwd.byname") == 0) {
		memset(key, 0, sizeof(key));
		(void)strncpy(key, arg->key.keydat_val,
		    arg->key.keydat_len);
		ukey.ue_line = key;
		if ((ue = RB_FIND(user_name_tree, env->sc_user_names,
		    &ukey)) == NULL) {
			/*
			 * canacar's trick:
			 * the user might have been deleted in between calls
			 * to next since the tree may be modified by a reload.
			 * next should still return the next user in
			 * lexicographical order, hence insert the search key
			 * and look up the next field, then remove it again.
			 */
			RB_INSERT(user_name_tree, env->sc_user_names, &ukey);
			if ((ue = RB_NEXT(user_name_tree, &env->sc_user_names,
			    &ukey)) == NULL) {
				RB_REMOVE(user_name_tree, env->sc_user_names,
				    &ukey);
				res.stat = YP_NOKEY;
				return (&res);
			}
			RB_REMOVE(user_name_tree, env->sc_user_names, &ukey);
		}
		line = ue->ue_line + (strlen(ue->ue_line) + 1);
		line = line + (strlen(line) + 1);
		yp_make_keyval(&res, line, line);
		return (&res);


	} else if (strcmp(arg->map, "group.byname") == 0) {
		memset(key, 0, sizeof(key));
		(void)strncpy(key, arg->key.keydat_val,
		    arg->key.keydat_len);
		
		gkey.ge_line = key;
		if ((ge = RB_FIND(group_name_tree, env->sc_group_names,
		    &gkey)) == NULL) {
			/*
			 * canacar's trick reloaded.
			 */
			RB_INSERT(group_name_tree, env->sc_group_names, &gkey);
			if ((ge = RB_NEXT(group_name_tree, &env->sc_group_names,
			    &gkey)) == NULL) {
				RB_REMOVE(group_name_tree, env->sc_group_names,
				    &gkey);
				res.stat = YP_NOKEY;
				return (&res);
			}
			RB_REMOVE(group_name_tree, env->sc_group_names, &gkey);
		}

		line = ge->ge_line + (strlen(ge->ge_line) + 1);
		line = line + (strlen(line) + 1);
		yp_make_keyval(&res, line, line);
		return (&res);
	} else {
		log_debug("unknown map %s", arg->map);
		res.stat = YP_NOMAP;
		return (&res);
	}
}

ypresp_all *
ypproc_all_2_svc(ypreq_nokey *arg, struct svc_req *req)
{
	static struct ypresp_all	res;

	if (yp_valid_domain(arg->domain, (struct ypresp_val *)&res) == -1)
		return (&res);

	svcerr_auth(req->rq_xprt, AUTH_FAILED);
	return (NULL);
}

ypresp_master *
ypproc_master_2_svc(ypreq_nokey *arg, struct svc_req *req)
{
	static struct ypresp_master	 res;
	static char master[YPMAXPEER + 1];

	memset(&res, 0, sizeof(res));
	if (yp_valid_domain(arg->domain, (struct ypresp_val *)&res) == -1)
		return (&res);
	if (gethostname(master, sizeof(master)) == 0) {
		res.peer = (peername)master;
		res.stat = YP_TRUE;
	} else
		res.stat = YP_NOKEY;
	return (&res);
}

ypresp_maplist *
ypproc_maplist_2_svc(domainname *arg, struct svc_req *req)
{
	size_t			 i;
	static struct {
		char		*name;
		int		 cond;
	}			 mapnames[] = {
		{ "passwd.byname",		YPMAP_PASSWD_BYNAME },
		{ "passwd.byuid",		YPMAP_PASSWD_BYUID },
		{ "master.passwd.byname",	YPMAP_MASTER_PASSWD_BYNAME },
		{ "master.passwd.byuid",	YPMAP_MASTER_PASSWD_BYUID },
		{ "group.byname",		YPMAP_GROUP_BYNAME },
		{ "group.bygid",		YPMAP_GROUP_BYGID },
		{ "netid.byname",		YPMAP_NETID_BYNAME },
	};
	static ypresp_maplist	 res;
	static struct ypmaplist	 maps[sizeof(mapnames) / sizeof(mapnames[0])];
	
	if (yp_valid_domain(*arg, (struct ypresp_val *)&res) == -1)
		return (&res);

	res.stat = YP_TRUE;
	res.maps = NULL;
	for (i = 0; i < sizeof(mapnames) / sizeof(mapnames[0]); i++) {
		if (!(env->sc_flags & mapnames[i].cond))
			continue;
		maps[i].map = mapnames[i].name;
		maps[i].next = res.maps;
		res.maps = &maps[i];
	}

	return (&res);
}

void
yp_make_val(struct ypresp_val *res, char *line, int replacecolon)
{
	static char		 buf[LINE_WIDTH];

	memset(buf, 0, sizeof(buf));

	if (replacecolon)
		line[strlen(line)] = ':';
	(void)strlcpy(buf, line, sizeof(buf));
	if (replacecolon)
		line[strcspn(line, ":")] = '\0';
	log_debug("sending out %s", buf);

	res->stat = YP_TRUE;
	res->val.valdat_len = strlen(buf);
	res->val.valdat_val = buf;
}

void
yp_make_keyval(struct ypresp_key_val *res, char *key, char *line)
{
	static char	keybuf[YPMAXRECORD+1];
	static char	buf[LINE_WIDTH];

	memset(keybuf, 0, sizeof(keybuf));
	memset(buf, 0, sizeof(buf));
	
	(void)strlcpy(keybuf, key, sizeof(keybuf));
	res->key.keydat_len = strlen(keybuf);
	res->key.keydat_val = keybuf;

	if (*line == '\0') {
		res->stat = YP_NOMORE;
		return;
	}
	res->stat = YP_TRUE;
	line[strlen(line)] = ':';
	(void)strlcpy(buf, line, sizeof(buf));
	line[strcspn(line, ":")] = '\0';
	log_debug("sending out %s => %s", keybuf, buf);

	res->val.valdat_len = strlen(buf);
	res->val.valdat_val = buf;
}
@


1.17
log
@Set argument encode / result decode callbacks for 'all'.
listing a map is still not implemented though.
ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.16 2016/01/24 08:30:38 matthieu Exp $ */
d345 1
a345 1
	bzero(key, sizeof(key));
d489 1
a489 1
		bzero(key, sizeof(key));
d520 1
a520 1
		bzero(key, sizeof(key));
d570 1
a570 1
	bzero(&res, sizeof(res));
d621 1
a621 1
	bzero(buf, sizeof(buf));
d641 2
a642 2
	bzero(keybuf, sizeof(keybuf));
	bzero(buf, sizeof(buf));
@


1.16
log
@Set argument encode / result decode call backs for 'maplist'.
ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.15 2016/01/24 08:28:12 matthieu Exp $ */
d221 2
@


1.15
log
@Implement the 'master' request. ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.14 2015/02/11 01:26:00 pelikan Exp $ */
d239 2
a240 1
		log_debug("ypproc_maplist");
@


1.14
log
@YPPROC_XFR will trigger a crash, even if using it doesn't make sense.

ok deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.13 2015/01/16 06:40:22 deraadt Exp $ */
d226 2
a227 1
		log_debug("ypproc_master");
d565 1
d567 1
d570 5
a574 2

	res.stat = YP_YPERR;
@


1.13
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.12 2013/10/01 12:00:34 deraadt Exp $ */
d212 1
a212 1
		break;
@


1.12
log
@avoid a fd_set overflow by calling a different rpc svc function
ok jmatthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.11 2011/08/28 11:53:16 aschrijver Exp $ */
a18 1
#include <sys/param.h>
d35 1
@


1.11
log
@Add support for the netid.byname YP map. This map is used by getgrouplist(3),
which is used by (amongst other things) initgroups(3) to set the supplemantary
groups on login.

OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.10 2011/01/13 06:09:35 martinh Exp $ */
d102 1
a102 5
	fd_set	fdset;

	FD_ZERO(&fdset);
	FD_SET(fd, &fdset);
	svc_getreqset(&fdset);
@


1.10
log
@Remove double 'to' in comment, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.9 2011/01/13 06:07:42 martinh Exp $ */
d52 1
a52 1
void	yp_make_val(struct ypresp_val *, char *);
d325 1
d357 1
a357 1
		yp_make_val(&res, ue->ue_line);
d373 1
a373 1
		yp_make_val(&res, ue->ue_line);
d387 1
a387 1
		yp_make_val(&res, ge->ge_line);
d397 1
a397 1
		yp_make_val(&res, ge->ge_line);
d399 40
d583 1
a583 1
	}			 mapnames[6] = {
d590 1
d612 1
a612 1
yp_make_val(struct ypresp_val *res, char *line)
d618 2
a619 1
	line[strlen(line)] = ':';
d621 2
a622 1
	line[strcspn(line, ":")] = '\0';
@


1.9
log
@Log match requests at debug level.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.8 2011/01/13 06:05:18 martinh Exp $ */
d456 1
a456 1
			 * the user might have been deleted in between calls to
@


1.8
log
@Extract common preparation of key in ypmatch handling, and check the
argument length.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.7 2010/11/20 05:12:38 deraadt Exp $ */
d326 3
@


1.7
log
@clean up cases of ;;
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.6 2010/08/03 08:24:23 pyr Exp $ */
d336 8
a345 4
		bzero(key, sizeof(key));
		(void)strncpy(key, arg->key.keydat_val,
		    arg->key.keydat_len);
		
a356 3
		bzero(key, sizeof(key));
		(void)strncpy(key, arg->key.keydat_val,
		    arg->key.keydat_len);
a371 3
		bzero(key, sizeof(key));
		(void)strncpy(key, arg->key.keydat_val,
		    arg->key.keydat_len);
a385 4
		bzero(key, sizeof(key));
		(void)strncpy(key, arg->key.keydat_val,
		    arg->key.keydat_len);
		
@


1.6
log
@Fix a leak in ypldap. Found (and correct diff) from
plalonde (at) overnet.qc.ca

Prompted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.5 2010/05/06 11:55:01 ajacoutot Exp $ */
d228 1
a228 1
		break;;
@


1.5
log
@Use YPMAXRECORD instead of _PW_NAME_LEN here too.

ok robert@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.4 2009/10/10 23:51:56 robert Exp $ */
d94 1
@


1.4
log
@The YP protocol permits any string to be at least as long as
YPMAXRECORD, so use that instead of _PW_NAME_LEN.
with help from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.3 2009/07/23 19:37:38 blambert Exp $ */
d591 1
a591 1
	static char	keybuf[_PW_NAME_LEN+1];
@


1.3
log
@Silence some lint warnings about an unreachable return by consolidating
actual returns (which were returning the same value anyway).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.2 2009/06/02 07:40:50 bernd Exp $ */
d324 1
a324 1
	char			 key[_PW_NAME_LEN+1];
d443 1
a443 1
	char				 key[_PW_NAME_LEN+1];
@


1.2
log
@Also match on 'master.passwd.byuid'. Fixes a problem with lookup by uid.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp.c,v 1.1 2008/06/26 15:10:01 pyr Exp $ */
a420 1
		return (&res);
a425 1
		return (&res);
a428 1
		return (&res);
d430 2
a431 1
	return (NULL);
@


1.1
log
@ypldap -- Intended to be a drop-in replacement for ypserv, gluing in a
LDAP directory and thus providing support for users and groups stored in
LDAP for the get{pw,gr}ent family of functions.

As of now it relies on external LDAP libraries, choose the one of your
liking though openldap would do fine. Not linked to the builds until
some things are sorted out, having our own LDAP client code for
instance, better support for group membership lookup as well.

Remember to sync with the latest master.passwd and group files as well
to have the _ypldap user available, which is needed.

``just get it in'' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d350 2
a351 1
	} else if (strcmp(arg->map, "passwd.byuid") == 0) {
@

