head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.4
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.32.0.2
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.16
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.8
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.12
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.10
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.6
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.4
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.2
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.2
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19;
locks; strict;
comment	@ * @;


1.36
date	2017.03.27.04.46.47;	author jmatthew;	state Exp;
branches;
next	1.35;
commitid	1La8anG5Hhd6jRiY;

1.35
date	2017.02.03.08.23.46;	author guenther;	state Exp;
branches;
next	1.34;
commitid	RkgZAc0srXet0WqL;

1.34
date	2016.10.22.03.37.13;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	7z5NhR1ogABgmwxL;

1.33
date	2016.10.22.03.34.32;	author guenther;	state Exp;
branches;
next	1.32;
commitid	SNWFDvUAomrFq2dT;

1.32
date	2016.04.27.10.53.27;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	Gg9bq6KcwBteEIHS;

1.31
date	2015.12.05.19.10.19;	author mmcc;	state Exp;
branches;
next	1.30;
commitid	VlaAt5umLFev4qF4;

1.30
date	2012.04.30.21.40.03;	author jmatthew;	state Exp;
branches;
next	1.29;

1.29
date	2012.03.15.03.44.46;	author jmatthew;	state Exp;
branches;
next	1.28;

1.28
date	2011.08.28.16.37.28;	author aschrijver;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.21.17.32.12;	author martinh;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.21.14.45.59;	author gilles;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.14.13.15.22;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.28.10.05.28;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2010.02.07.13.04.25;	author blambert;	state Exp;
branches;
next	1.21;

1.21
date	2010.02.06.08.04.45;	author blambert;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.08.13.13.17;	author blambert;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.29.11.43.31;	author aschrijver;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.28.00.53.29;	author aschrijver;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.27.16.17.49;	author aschrijver;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.27.15.37.03;	author aschrijver;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.27.13.24.25;	author aschrijver;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.27.11.38.32;	author aschrijver;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.27.11.33.22;	author aschrijver;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.26.21.56.15;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.16.13.11.15;	author aschrijver;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.04.00.11.05;	author aschrijver;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.28.22.03.59;	author blambert;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.27.19.46.12;	author aschrijver;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.28.10.07.56;	author aschrijver;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.28.13.47.22;	author aschrijver;	state Exp;
branches;
next	1.5;

1.5
date	2008.10.14.21.41.03;	author aschrijver;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.06.08.01.28;	author aschrijver;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.02.15.24.14;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.30.17.31.04;	author pyr;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.30.16.24.16;	author aschrijver;	state Exp;
branches;
next	;


desc
@@


1.36
log
@simplify parseval() by allocating a buffer the size of the input string,
which will always be big enough to hold the output string.

ok dlg@@
@
text
@/*	$Id: aldap.c,v 1.35 2017/02/03 08:23:46 guenther Exp $ */
/*	$OpenBSD: aldap.c,v 1.35 2017/02/03 08:23:46 guenther Exp $ */

/*
 * Copyright (c) 2008 Alexander Schrijver <aschrijver@@openbsd.org>
 * Copyright (c) 2006, 2007 Marc Balmer <mbalmer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <arpa/inet.h>
#include <ctype.h>
#include <errno.h>
#include <inttypes.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include "aldap.h"

#if 0
#define DEBUG
#endif
#define VERSION 3

static struct ber_element	*ldap_parse_search_filter(struct ber_element *,
				    char *);
static struct ber_element	*ldap_do_parse_search_filter(
				    struct ber_element *, char **);
char				**aldap_get_stringset(struct ber_element *);
char				*utoa(char *);
static int			 isu8cont(unsigned char);
char				*parseval(char *, size_t);
int				aldap_create_page_control(struct ber_element *,
				    int, struct aldap_page_control *);

#ifdef DEBUG
void			 ldap_debug_elements(struct ber_element *);
#endif

#ifdef DEBUG
#define DPRINTF(x...)	printf(x)
#define LDAP_DEBUG(x, y)	do { fprintf(stderr, "*** " x "\n"); ldap_debug_elements(y); } while (0)
#else
#define DPRINTF(x...)	do { } while (0)
#define LDAP_DEBUG(x, y)	do { } while (0)
#endif

int
aldap_close(struct aldap *al)
{
	if (close(al->ber.fd) == -1)
		return (-1);

	ber_free(&al->ber);
	free(al);

	return (0);
}

struct aldap *
aldap_init(int fd)
{
	struct aldap *a;

	if ((a = calloc(1, sizeof(*a))) == NULL)
		return NULL;
	a->ber.fd = fd;

	return a;
}

int
aldap_bind(struct aldap *ldap, char *binddn, char *bindcred)
{
	struct ber_element *root = NULL, *elm;
	int error;

	if (binddn == NULL)
		binddn = "";
	if (bindcred == NULL)
		bindcred = "";

	if ((root = ber_add_sequence(NULL)) == NULL)
		goto fail;

	elm = ber_printf_elements(root, "d{tdsst", ++ldap->msgid, BER_CLASS_APP,
	    (unsigned long)LDAP_REQ_BIND, VERSION, binddn, bindcred,
	    BER_CLASS_CONTEXT, (unsigned long)LDAP_AUTH_SIMPLE);
	if (elm == NULL)
		goto fail;

	LDAP_DEBUG("aldap_bind", root);

	error = ber_write_elements(&ldap->ber, root);
	ber_free_elements(root);
	root = NULL;
	if (error == -1)
		goto fail;

	return (ldap->msgid);
fail:
	if (root != NULL)
		ber_free_elements(root);

	ldap->err = ALDAP_ERR_OPERATION_FAILED;
	return (-1);
}

int
aldap_unbind(struct aldap *ldap)
{
	struct ber_element *root = NULL, *elm;
	int error;

	if ((root = ber_add_sequence(NULL)) == NULL)
		goto fail;
	elm = ber_printf_elements(root, "d{t", ++ldap->msgid, BER_CLASS_APP,
	    LDAP_REQ_UNBIND_30);
	if (elm == NULL)
		goto fail;

	LDAP_DEBUG("aldap_unbind", root);

	error = ber_write_elements(&ldap->ber, root);
	ber_free_elements(root);
	root = NULL;
	if (error == -1)
		goto fail;

	return (ldap->msgid);
fail:
	if (root != NULL)
		ber_free_elements(root);

	ldap->err = ALDAP_ERR_OPERATION_FAILED;

	return (-1);
}

int
aldap_search(struct aldap *ldap, char *basedn, enum scope scope, char *filter,
    char **attrs, int typesonly, int sizelimit, int timelimit,
    struct aldap_page_control *page)
{
	struct ber_element *root = NULL, *ber, *c;
	int i, error;

	if ((root = ber_add_sequence(NULL)) == NULL)
		goto fail;

	ber = ber_printf_elements(root, "d{t", ++ldap->msgid, BER_CLASS_APP,
	    (unsigned long) LDAP_REQ_SEARCH);
	if (ber == NULL) {
		ldap->err = ALDAP_ERR_OPERATION_FAILED;
		goto fail;
	}

	c = ber;	
	ber = ber_printf_elements(ber, "sEEddb", basedn, (long long)scope,
	                         (long long)LDAP_DEREF_NEVER, sizelimit, 
				 timelimit, typesonly);
	if (ber == NULL) {
		ldap->err = ALDAP_ERR_OPERATION_FAILED;
		goto fail;
	}

	if ((ber = ldap_parse_search_filter(ber, filter)) == NULL) {
		ldap->err = ALDAP_ERR_PARSER_ERROR;
		goto fail;
	}

	if ((ber = ber_add_sequence(ber)) == NULL)
		goto fail;
	if (attrs != NULL)
		for (i = 0; attrs[i] != NULL; i++) {
			if ((ber = ber_add_string(ber, attrs[i])) == NULL)
				goto fail;
		}

	aldap_create_page_control(c, 100, page);

	LDAP_DEBUG("aldap_search", root);

	error = ber_write_elements(&ldap->ber, root);
	ber_free_elements(root);
	root = NULL;
	if (error == -1) {
		ldap->err = ALDAP_ERR_OPERATION_FAILED;
		goto fail;
	}

	return (ldap->msgid);

fail:
	if (root != NULL)
		ber_free_elements(root);

	return (-1);
}

int
aldap_create_page_control(struct ber_element *elm, int size,
    struct aldap_page_control *page)
{
	int len;
	struct ber c;
	struct ber_element *ber = NULL;

	c.br_wbuf = NULL;
	c.fd = -1;

	ber = ber_add_sequence(NULL);

	if (page == NULL) {
		if (ber_printf_elements(ber, "ds", 50, "") == NULL)
			goto fail;
	} else {
		if (ber_printf_elements(ber, "dx", 50, page->cookie,
			    page->cookie_len) == NULL)
			goto fail;
	}

	if ((len = ber_write_elements(&c, ber)) < 1)
		goto fail;
	if (ber_printf_elements(elm, "{t{sx", 2, 0, LDAP_PAGED_OID,
		                c.br_wbuf, (size_t)len) == NULL)
		goto fail;

	ber_free_elements(ber);
	ber_free(&c);
	return len;
fail:
	if (ber != NULL)
		ber_free_elements(ber);
	ber_free(&c);	

	return (-1);
}

struct aldap_message *
aldap_parse(struct aldap *ldap)
{
	int			 class;
	unsigned long		 type;
	long long		 msgid = 0;
	struct aldap_message	*m;
	struct ber_element	*a = NULL, *ep;

	if ((m = calloc(1, sizeof(struct aldap_message))) == NULL)
		return NULL;

	if ((m->msg = ber_read_elements(&ldap->ber, NULL)) == NULL)
		goto parsefail;

	LDAP_DEBUG("message", m->msg);

	if (ber_scanf_elements(m->msg, "{ite", &msgid, &class, &type, &a) != 0)
		goto parsefail;
	m->msgid = msgid;
	m->message_type = type;
	m->protocol_op = a;

	switch (m->message_type) {
	case LDAP_RES_BIND:
	case LDAP_RES_MODIFY:
	case LDAP_RES_ADD:
	case LDAP_RES_DELETE:
	case LDAP_RES_MODRDN:
	case LDAP_RES_COMPARE:
	case LDAP_RES_SEARCH_RESULT:
		if (ber_scanf_elements(m->protocol_op, "{EeSeSe",
		    &m->body.res.rescode, &m->dn, &m->body.res.diagmsg, &a) != 0)
			goto parsefail;
		if (m->body.res.rescode == LDAP_REFERRAL)
			if (ber_scanf_elements(a, "{e", &m->references) != 0)
				goto parsefail;
		if (m->msg->be_sub) {
			for (ep = m->msg->be_sub; ep != NULL; ep = ep->be_next) {
				ber_scanf_elements(ep, "t", &class, &type);
				if (class == 2 && type == 0)
					m->page = aldap_parse_page_control(ep->be_sub->be_sub,
					    ep->be_sub->be_sub->be_len);
			}
		} else
			m->page = NULL;
		break;
	case LDAP_RES_SEARCH_ENTRY:
		if (ber_scanf_elements(m->protocol_op, "{eS{e", &m->dn,
		    &m->body.search.attrs) != 0)
			goto parsefail;
		break;
	case LDAP_RES_SEARCH_REFERENCE:
		if (ber_scanf_elements(m->protocol_op, "{e", &m->references) != 0)
			goto parsefail;
		break;
	}

	return m;
parsefail:
	ldap->err = ALDAP_ERR_PARSER_ERROR;
	aldap_freemsg(m);
	return NULL;
}

struct aldap_page_control *
aldap_parse_page_control(struct ber_element *control, size_t len) 
{
	char *oid, *s;
	char *encoded;
	struct ber b;
	struct ber_element *elm;
	struct aldap_page_control *page;

	b.br_wbuf = NULL;
	b.fd = -1;
	ber_scanf_elements(control, "ss", &oid, &encoded);
	ber_set_readbuf(&b, encoded, control->be_next->be_len);
	elm = ber_read_elements(&b, NULL);

	if ((page = malloc(sizeof(struct aldap_page_control))) == NULL) {
		if (elm != NULL)
			ber_free_elements(elm);
		ber_free(&b);
		return NULL;
	}

	ber_scanf_elements(elm->be_sub, "is", &page->size, &s);
	page->cookie_len = elm->be_sub->be_next->be_len;

	if ((page->cookie = malloc(page->cookie_len)) == NULL) {
		if (elm != NULL)
			ber_free_elements(elm);
		ber_free(&b);
		free(page);
		return NULL;
	}
	memcpy(page->cookie, s, page->cookie_len);

	ber_free_elements(elm);
	ber_free(&b);
	return page;
}

void
aldap_freepage(struct aldap_page_control *page)
{
	free(page->cookie);
	free(page);
}

void
aldap_freemsg(struct aldap_message *msg)
{
	if (msg->msg)
		ber_free_elements(msg->msg);
	free(msg);
}

int
aldap_get_resultcode(struct aldap_message *msg)
{
	return msg->body.res.rescode;
}

char *
aldap_get_dn(struct aldap_message *msg)
{
	char *dn;

	if (msg->dn == NULL)
		return NULL;

	if (ber_get_string(msg->dn, &dn) == -1)
		return NULL;

	return utoa(dn);
}

char **
aldap_get_references(struct aldap_message *msg)
{
	if (msg->references == NULL)
		return NULL;
	return aldap_get_stringset(msg->references);
}

void
aldap_free_references(char **values)
{
	int i;

	if (values == NULL)
		return;

	for (i = 0; values[i] != NULL; i++)
		free(values[i]);

	free(values);
}

char *
aldap_get_diagmsg(struct aldap_message *msg)
{
	char *s;

	if (msg->body.res.diagmsg == NULL)
		return NULL;

	if (ber_get_string(msg->body.res.diagmsg, &s) == -1)
		return NULL;

	return utoa(s);
}

int
aldap_count_attrs(struct aldap_message *msg)
{
	int i;
	struct ber_element *a;

	if (msg->body.search.attrs == NULL)
		return (-1);

	for (i = 0, a = msg->body.search.attrs;
	    a != NULL && ber_get_eoc(a) != 0;
	    i++, a = a->be_next)
		;

	return i;
}

int
aldap_first_attr(struct aldap_message *msg, char **outkey, char ***outvalues)
{
	struct ber_element *b, *c;
	char *key;
	char **ret;

	if (msg->body.search.attrs == NULL)
		goto fail;

	if (ber_scanf_elements(msg->body.search.attrs, "{s(e)}e",
	    &key, &b, &c) != 0)
		goto fail;

	msg->body.search.iter = msg->body.search.attrs->be_next;

	if ((ret = aldap_get_stringset(b)) == NULL)
		goto fail;

	(*outvalues) = ret;
	(*outkey) = utoa(key);

	return (1);
fail:
	(*outkey) = NULL;
	(*outvalues) = NULL;
	return (-1);
}

int
aldap_next_attr(struct aldap_message *msg, char **outkey, char ***outvalues)
{
	struct ber_element *a, *b;
	char *key;
	char **ret;

	if (msg->body.search.iter == NULL)
		goto notfound;

	LDAP_DEBUG("attr", msg->body.search.iter);

	if (ber_get_eoc(msg->body.search.iter) == 0)
		goto notfound;

	if (ber_scanf_elements(msg->body.search.iter, "{s(e)}e", &key, &a, &b)
	    != 0)
		goto fail;

	msg->body.search.iter = msg->body.search.iter->be_next;

	if ((ret = aldap_get_stringset(a)) == NULL)
		goto fail;

	(*outvalues) = ret;
	(*outkey) = utoa(key);

	return (1);
fail:
notfound:
	(*outkey) = NULL;
	(*outvalues) = NULL;
	return (-1);
}

int
aldap_match_attr(struct aldap_message *msg, char *inkey, char ***outvalues)
{
	struct ber_element *a, *b;
	char *descr = NULL;
	char **ret;

	if (msg->body.search.attrs == NULL)
		goto fail;

	LDAP_DEBUG("attr", msg->body.search.attrs);

	for (a = msg->body.search.attrs;;) {
		if (a == NULL)
			goto notfound;
		if (ber_get_eoc(a) == 0)
			goto notfound;
		if (ber_scanf_elements(a, "{s(e", &descr, &b) != 0)
			goto fail;
		if (strcasecmp(descr, inkey) == 0)
			goto attrfound;
		a = a->be_next;
	}

attrfound:
	if ((ret = aldap_get_stringset(b)) == NULL)
		goto fail;

	(*outvalues) = ret;

	return (1);
fail:
notfound:
	(*outvalues) = NULL;
	return (-1);
}

int
aldap_free_attr(char **values)
{
	int i;

	if (values == NULL)
		return -1;

	for (i = 0; values[i] != NULL; i++)
		free(values[i]);

	free(values);

	return (1);
}

#if 0
void
aldap_free_url(struct aldap_url *lu)
{
	free(lu->buffer);
	free(lu->filter);
}

int
aldap_parse_url(char *url, struct aldap_url *lu)
{
	char		*p, *forward, *forward2;
	const char	*errstr = NULL;
	int		 i;

	if ((lu->buffer = p = strdup(url)) == NULL)
		return (-1);

	/* protocol */
	if (strncasecmp(LDAP_URL, p, strlen(LDAP_URL)) != 0)
		goto fail;
	lu->protocol = LDAP;
	p += strlen(LDAP_URL);

	/* host and optional port */
	if ((forward = strchr(p, '/')) != NULL)
		*forward = '\0';
	/* find the optional port */
	if ((forward2 = strchr(p, ':')) != NULL) {
		*forward2 = '\0';
		/* if a port is given */
		if (*(forward2+1) != '\0') {
#define PORT_MAX UINT16_MAX
			lu->port = strtonum(++forward2, 0, PORT_MAX, &errstr);
			if (errstr)
				goto fail;
		}
	}
	/* fail if no host is given */
	if (strlen(p) == 0)
		goto fail;
	lu->host = p;
	if (forward == NULL)
		goto done;
	/* p is assigned either a pointer to a character or to '\0' */
	p = ++forward;
	if (strlen(p) == 0)
		goto done;

	/* dn */
	if ((forward = strchr(p, '?')) != NULL)
		*forward = '\0';
	lu->dn = p;
	if (forward == NULL)
		goto done;
	/* p is assigned either a pointer to a character or to '\0' */
	p = ++forward;
	if (strlen(p) == 0)
		goto done;

	/* attributes */
	if ((forward = strchr(p, '?')) != NULL)
		*forward = '\0';
	for (i = 0; i < MAXATTR; i++) {
		if ((forward2 = strchr(p, ',')) == NULL) {
			if (strlen(p) == 0)
				break;
			lu->attributes[i] = p;
			break;
		}
		*forward2 = '\0';
		lu->attributes[i] = p;
		p = ++forward2;
	}
	if (forward == NULL)
		goto done;
	/* p is assigned either a pointer to a character or to '\0' */
	p = ++forward;
	if (strlen(p) == 0)
		goto done;

	/* scope */
	if ((forward = strchr(p, '?')) != NULL)
		*forward = '\0';
	if (strcmp(p, "base") == 0)
		lu->scope = LDAP_SCOPE_BASE;
	else if (strcmp(p, "one") == 0)
		lu->scope = LDAP_SCOPE_ONELEVEL;
	else if (strcmp(p, "sub") == 0)
		lu->scope = LDAP_SCOPE_SUBTREE;
	else
		goto fail;
	if (forward == NULL)
		goto done;
	p = ++forward;
	if (strlen(p) == 0)
		goto done;

	/* filter */
	if (p)
		lu->filter = p;
done:
	free(url);
	return (1);
fail:
	free(lu->buffer);
	lu->buffer = NULL;
	return (-1);
}

int
aldap_search_url(struct aldap *ldap, char *url, int typesonly, int sizelimit,
    int timelimit)
{
	struct aldap_url *lu;

	if ((lu = calloc(1, sizeof(*lu))) == NULL)
		return (-1);

	if (aldap_parse_url(url, lu))
		goto fail;

	if (aldap_search(ldap, lu->dn, lu->scope, lu->filter, lu->attributes,
	    typesonly, sizelimit, timelimit) == -1)
		goto fail;

	aldap_free_url(lu);
	return (ldap->msgid);
fail:
	aldap_free_url(lu);
	return (-1);
}
#endif /* 0 */

/*
 * internal functions
 */

char **
aldap_get_stringset(struct ber_element *elm)
{
	struct ber_element *a;
	int i;
	char **ret;
	char *s;

	if (elm->be_type != BER_TYPE_OCTETSTRING)
		return NULL;

	for (a = elm, i = 1; i > 0 && a != NULL && a->be_type ==
	    BER_TYPE_OCTETSTRING; a = a->be_next, i++)
		;
	if (i == 1)
		return NULL;

	if ((ret = calloc(i + 1, sizeof(char *))) == NULL)
		return NULL;

	for (a = elm, i = 0; a != NULL && a->be_type == BER_TYPE_OCTETSTRING;
	    a = a->be_next, i++) {

		ber_get_string(a, &s);
		ret[i] = utoa(s);
	}
	ret[i + 1] = NULL;

	return ret;
}

/*
 * Base case for ldap_do_parse_search_filter
 *
 * returns:
 *	struct ber_element *, ber_element tree
 *	NULL, parse failed
 */
static struct ber_element *
ldap_parse_search_filter(struct ber_element *ber, char *filter)
{
	struct ber_element *elm;
	char *cp;

	cp = filter;

	if (cp == NULL || *cp == '\0') {
		errno = EINVAL;
		return (NULL);
	}

	if ((elm = ldap_do_parse_search_filter(ber, &cp)) == NULL)
		return (NULL);

	if (*cp != '\0') {
		ber_free_elements(elm);
		ber_link_elements(ber, NULL);
		errno = EINVAL;
		return (NULL);
	}

	return (elm);
}

/*
 * Translate RFC4515 search filter string into ber_element tree
 *
 * returns:
 *	struct ber_element *, ber_element tree
 *	NULL, parse failed
 *
 * notes:
 *	when cp is passed to a recursive invocation, it is updated
 *	    to point one character beyond the filter that was passed
 *	    i.e., cp jumps to "(filter)" upon return
 *	                               ^
 *	goto's used to discriminate error-handling based on error type
 *	doesn't handle extended filters (yet)
 *
 */
static struct ber_element *
ldap_do_parse_search_filter(struct ber_element *prev, char **cpp)
{
	struct ber_element *elm, *root = NULL;
	char *attr_desc, *attr_val, *parsed_val, *cp;
	size_t len;
	unsigned long type;

	root = NULL;

	/* cpp should pass in pointer to opening parenthesis of "(filter)" */
	cp = *cpp;
	if (*cp != '(')
		goto syntaxfail;

	switch (*++cp) {
	case '&':		/* AND */
	case '|':		/* OR */
		if (*cp == '&')
			type = LDAP_FILT_AND;
		else
			type = LDAP_FILT_OR;

		if ((elm = ber_add_set(prev)) == NULL)
			goto callfail;
		root = elm;
		ber_set_header(elm, BER_CLASS_CONTEXT, type);

		if (*++cp != '(')		/* opening `(` of filter */
			goto syntaxfail;

		while (*cp == '(') {
			if ((elm =
			    ldap_do_parse_search_filter(elm, &cp)) == NULL)
				goto bad;
		}

		if (*cp != ')')			/* trailing `)` of filter */
			goto syntaxfail;
		break;

	case '!':		/* NOT */
		if ((root = ber_add_sequence(prev)) == NULL)
			goto callfail;
		ber_set_header(root, BER_CLASS_CONTEXT, LDAP_FILT_NOT);

		cp++;				/* now points to sub-filter */
		if ((elm = ldap_do_parse_search_filter(root, &cp)) == NULL)
			goto bad;

		if (*cp != ')')			/* trailing `)` of filter */
			goto syntaxfail;
		break;

	default:	/* SIMPLE || PRESENCE */
		attr_desc = cp;

		len = strcspn(cp, "()<>~=");
		cp += len;
		switch (*cp) {
		case '~':
			type = LDAP_FILT_APPR;
			cp++;
			break;
		case '<':
			type = LDAP_FILT_LE;
			cp++;
			break;
		case '>':
			type = LDAP_FILT_GE;
			cp++;
			break;
		case '=':
			type = LDAP_FILT_EQ;	/* assume EQ until disproven */
			break;
		case '(':
		case ')':
		default:
			goto syntaxfail;
		}
		attr_val = ++cp;

		/* presence filter */
		if (strncmp(attr_val, "*)", 2) == 0) {
			cp++;			/* point to trailing `)` */
			if ((root =
			    ber_add_nstring(prev, attr_desc, len)) == NULL)
				goto bad;

			ber_set_header(root, BER_CLASS_CONTEXT, LDAP_FILT_PRES);
			break;
		}

		if ((root = ber_add_sequence(prev)) == NULL)
			goto callfail;
		ber_set_header(root, BER_CLASS_CONTEXT, type);

		if ((elm = ber_add_nstring(root, attr_desc, len)) == NULL)
			goto callfail;

		len = strcspn(attr_val, "*)");
		if (len == 0 && *cp != '*')
			goto syntaxfail;
		cp += len;
		if (*cp == '\0')
			goto syntaxfail;

		if (*cp == '*') {	/* substring filter */
			int initial;

			cp = attr_val;

			ber_set_header(root, BER_CLASS_CONTEXT, LDAP_FILT_SUBS);

			if ((elm = ber_add_sequence(elm)) == NULL)
				goto callfail;

			for (initial = 1;; cp++, initial = 0) {
				attr_val = cp;

				len = strcspn(attr_val, "*)");
				if (len == 0) {
					if (*cp == ')')
						break;
					else
						continue;
				}
				cp += len;
				if (*cp == '\0')
					goto syntaxfail;

				if (initial)
					type = LDAP_FILT_SUBS_INIT;
				else if (*cp == ')')
					type = LDAP_FILT_SUBS_FIN;
				else
					type = LDAP_FILT_SUBS_ANY;

				if ((parsed_val = parseval(attr_val, len)) ==
				    NULL)
					goto callfail;
				elm = ber_add_nstring(elm, parsed_val,
				    strlen(parsed_val));
				free(parsed_val);
				if (elm == NULL)
					goto callfail;
				ber_set_header(elm, BER_CLASS_CONTEXT, type);
				if (type == LDAP_FILT_SUBS_FIN)
					break;
			}
			break;
		}

		if ((parsed_val = parseval(attr_val, len)) == NULL)
			goto callfail;
		elm = ber_add_nstring(elm, parsed_val, strlen(parsed_val));
		free(parsed_val);
		if (elm == NULL)
			goto callfail;
		break;
	}

	cp++;		/* now points one char beyond the trailing `)` */

	*cpp = cp;
	return (root);

syntaxfail:		/* XXX -- error reporting */
callfail:
bad:
	if (root != NULL)
		ber_free_elements(root);
	ber_link_elements(prev, NULL);
	return (NULL);
}

#ifdef DEBUG
/*
 * Display a list of ber elements.
 *
 */
void
ldap_debug_elements(struct ber_element *root)
{
	static int	 indent = 0;
	long long	 v;
	int		 d;
	char		*buf;
	size_t		 len;
	u_int		 i;
	int		 constructed;
	struct ber_oid	 o;

	/* calculate lengths */
	ber_calc_len(root);

	switch (root->be_encoding) {
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
		constructed = root->be_encoding;
		break;
	default:
		constructed = 0;
		break;
	}

	fprintf(stderr, "%*slen %lu ", indent, "", root->be_len);
	switch (root->be_class) {
	case BER_CLASS_UNIVERSAL:
		fprintf(stderr, "class: universal(%u) type: ", root->be_class);
		switch (root->be_type) {
		case BER_TYPE_EOC:
			fprintf(stderr, "end-of-content");
			break;
		case BER_TYPE_BOOLEAN:
			fprintf(stderr, "boolean");
			break;
		case BER_TYPE_INTEGER:
			fprintf(stderr, "integer");
			break;
		case BER_TYPE_BITSTRING:
			fprintf(stderr, "bit-string");
			break;
		case BER_TYPE_OCTETSTRING:
			fprintf(stderr, "octet-string");
			break;
		case BER_TYPE_NULL:
			fprintf(stderr, "null");
			break;
		case BER_TYPE_OBJECT:
			fprintf(stderr, "object");
			break;
		case BER_TYPE_ENUMERATED:
			fprintf(stderr, "enumerated");
			break;
		case BER_TYPE_SEQUENCE:
			fprintf(stderr, "sequence");
			break;
		case BER_TYPE_SET:
			fprintf(stderr, "set");
			break;
		}
		break;
	case BER_CLASS_APPLICATION:
		fprintf(stderr, "class: application(%u) type: ",
		    root->be_class);
		switch (root->be_type) {
		case LDAP_REQ_BIND:
			fprintf(stderr, "bind");
			break;
		case LDAP_RES_BIND:
			fprintf(stderr, "bind");
			break;
		case LDAP_REQ_UNBIND_30:
			break;
		case LDAP_REQ_SEARCH:
			fprintf(stderr, "search");
			break;
		case LDAP_RES_SEARCH_ENTRY:
			fprintf(stderr, "search_entry");
			break;
		case LDAP_RES_SEARCH_RESULT:
			fprintf(stderr, "search_result");
			break;
		case LDAP_REQ_MODIFY:
			fprintf(stderr, "modify");
			break;
		case LDAP_RES_MODIFY:
			fprintf(stderr, "modify");
			break;
		case LDAP_REQ_ADD:
			fprintf(stderr, "add");
			break;
		case LDAP_RES_ADD:
			fprintf(stderr, "add");
			break;
		case LDAP_REQ_DELETE_30:
			fprintf(stderr, "delete");
			break;
		case LDAP_RES_DELETE:
			fprintf(stderr, "delete");
			break;
		case LDAP_REQ_MODRDN:
			fprintf(stderr, "modrdn");
			break;
		case LDAP_RES_MODRDN:
			fprintf(stderr, "modrdn");
			break;
		case LDAP_REQ_COMPARE:
			fprintf(stderr, "compare");
			break;
		case LDAP_RES_COMPARE:
			fprintf(stderr, "compare");
			break;
		case LDAP_REQ_ABANDON_30:
			fprintf(stderr, "abandon");
			break;
		}
		break;
	case BER_CLASS_PRIVATE:
		fprintf(stderr, "class: private(%u) type: ", root->be_class);
		fprintf(stderr, "encoding (%lu) type: ", root->be_encoding);
		break;
	case BER_CLASS_CONTEXT:
		/* XXX: this is not correct */
		fprintf(stderr, "class: context(%u) type: ", root->be_class);
		switch(root->be_type) {
		case LDAP_AUTH_SIMPLE:
			fprintf(stderr, "auth simple");
			break;
		}
		break;
	default:
		fprintf(stderr, "class: <INVALID>(%u) type: ", root->be_class);
		break;
	}
	fprintf(stderr, "(%lu) encoding %lu ",
	    root->be_type, root->be_encoding);

	if (constructed)
		root->be_encoding = constructed;

	switch (root->be_encoding) {
	case BER_TYPE_BOOLEAN:
		if (ber_get_boolean(root, &d) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "%s(%d)\n", d ? "true" : "false", d);
		break;
	case BER_TYPE_INTEGER:
		if (ber_get_integer(root, &v) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "value %lld\n", v);
		break;
	case BER_TYPE_ENUMERATED:
		if (ber_get_enumerated(root, &v) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "value %lld\n", v);
		break;
	case BER_TYPE_BITSTRING:
		if (ber_get_bitstring(root, (void *)&buf, &len) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "hexdump ");
		for (i = 0; i < len; i++)
			fprintf(stderr, "%02x", buf[i]);
		fprintf(stderr, "\n");
		break;
	case BER_TYPE_OBJECT:
		if (ber_get_oid(root, &o) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "\n");
		break;
	case BER_TYPE_OCTETSTRING:
		if (ber_get_nstring(root, (void *)&buf, &len) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "string \"%.*s\"\n",  len, buf);
		break;
	case BER_TYPE_NULL:	/* no payload */
	case BER_TYPE_EOC:
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
	default:
		fprintf(stderr, "\n");
		break;
	}

	if (constructed && root->be_sub) {
		indent += 2;
		ldap_debug_elements(root->be_sub);
		indent -= 2;
	}
	if (root->be_next)
		ldap_debug_elements(root->be_next);
}
#endif

/*
 * Strip UTF-8 down to ASCII without validation.
 * notes:
 *	non-ASCII characters are displayed as '?'
 *	the argument u should be a NULL terminated sequence of UTF-8 bytes.
 */
char *
utoa(char *u)
{
	int	 len, i, j;
	char	*str;

	/* calculate the length to allocate */
	for (len = 0, i = 0; u[i] != '\0'; i++)
		if (!isu8cont(u[i]))
			len++;

	if ((str = calloc(len + 1, sizeof(char))) == NULL)
		return NULL;

	/* copy the ASCII characters to the newly allocated string */
	for (i = 0, j = 0; u[i] != '\0'; i++)
		if (!isu8cont(u[i]))
			str[j++] = isascii((unsigned char)u[i]) ? u[i] : '?';

	return str;
}

static int
isu8cont(unsigned char c)
{
	return (c & (0x80 | 0x40)) == 0x80;
}

/*
 * Parse a LDAP value
 * notes:
 *	the argument p should be a NUL-terminated sequence of ASCII bytes
 */
char *
parseval(char *p, size_t len)
{
	char	 hex[3];
	char	*buffer;
	size_t	 i, j;

	if ((buffer = calloc(1, len + 1)) == NULL)
		return NULL;

	for (i = j = 0; j < len; i++) {
		if (p[j] == '\\') {
			strlcpy(hex, p + j + 1, sizeof(hex));
			buffer[i] = (char)strtoumax(hex, NULL, 16);
			j += 3;
		} else {
			buffer[i] = p[j];
			j++;
		}
	}

	return buffer;
}

int
aldap_get_errno(struct aldap *a, const char **estr)
{
	switch (a->err) {
	case ALDAP_ERR_SUCCESS:
		*estr = "success";
		break;
	case ALDAP_ERR_PARSER_ERROR:
		*estr = "parser failed";
		break;
	case ALDAP_ERR_INVALID_FILTER:
		*estr = "invalid filter";
		break;
	case ALDAP_ERR_OPERATION_FAILED:
		*estr = "operation failed";
		break;
	default:
		*estr = "unknown";
		break;
	}
	return (a->err);
}
@


1.35
log
@Stop assuming that in_{addr,port}_t are typedefed in <sys/types.h> and
instead pull in <netinet/in.h> or <arpa/inet.h> when those are needed.

ok florian@@ beck@@ millert@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.34 2016/10/22 03:37:13 deraadt Exp $ */
/*	$OpenBSD: aldap.c,v 1.34 2016/10/22 03:37:13 deraadt Exp $ */
d1208 2
a1209 2
	char	*cp = p, *buffer, *newbuffer;
	size_t	 size, newsize, i, j;
d1211 1
a1211 2
	size = 50;
	if ((buffer = calloc(1, size)) == NULL)
d1215 2
a1216 12
		if (i >= size) {
			newsize = size + 1024;
			if ((newbuffer = realloc(buffer, newsize)) == NULL) {
				free(buffer);
				return (NULL);
			}
			buffer = newbuffer;
			size = newsize;
		}

		if (cp[j] == '\\') {
			strlcpy(hex, cp + j + 1, sizeof(hex));
d1220 1
a1220 1
			buffer[i] = cp[j];
@


1.34
log
@string terminators are called NUL, not NULL
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.33 2016/10/22 03:34:32 guenther Exp $ */
/*	$OpenBSD: aldap.c,v 1.33 2016/10/22 03:34:32 guenther Exp $ */
d21 1
@


1.33
log
@Fix copy-pasto in comment; from Rob Pierce (rob (at) 2keys.ca)
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.32 2016/04/27 10:53:27 schwarze Exp $ */
/*	$OpenBSD: aldap.c,v 1.32 2016/04/27 10:53:27 schwarze Exp $ */
d1201 1
a1201 1
 *	the argument p should be a NULL terminated sequence of ASCII bytes
@


1.32
log
@Simplify overengineered and buggy code that looked like as if it did
some kind of UTF-8 validation, but actually didn't, but instead, for
malformed UTF-8 input, caused buffer overruns in some cases and caused
skipping of valid ASCII characters in other cases.

Problem originally discovered and fix OK by stsp@@.
eric@@ agrees with the direction.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.31 2015/12/05 19:10:19 mmcc Exp $ */
/*	$OpenBSD: aldap.c,v 1.31 2015/12/05 19:10:19 mmcc Exp $ */
d1201 1
a1201 1
 *	the argument u should be a NULL terminated sequence of ASCII bytes.
@


1.31
log
@strings.h -> string.h to prevent an implicit declaration. Also removes
two NULL-checks before free().
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.30 2012/04/30 21:40:03 jmatthew Exp $ */
/*	$OpenBSD: aldap.c,v 1.30 2012/04/30 21:40:03 jmatthew Exp $ */
d21 1
d41 1
d1165 1
a1165 1
 * Convert UTF-8 to ASCII.
d1177 3
a1179 11
	for (len = 0, i = 0; u[i] != '\0'; ) {
		if ((u[i] & 0xF0) == 0xF0)
			i += 4;
		else if ((u[i] & 0xE0) == 0xE0)
			i += 3;
		else if ((u[i] & 0xC0) == 0xC0)
			i += 2;
		else
			i += 1;
		len++;
	}
d1185 3
a1187 15
	for (i = 0, j = 0; u[i] != '\0'; j++) {
		if ((u[i] & 0xF0) == 0xF0) {
			str[j] = '?';
			i += 4;
		} else if ((u[i] & 0xE0) == 0xE0) {
			str[j] = '?';
			i += 3;
		} else if ((u[i] & 0xC0) == 0xC0) {
			str[j] = '?';
			i += 2;
		} else {
			str[j] =  u[i];
			i += 1;
		}
	}
d1190 6
@


1.30
log
@Use paged searches so we can handle larger directories.  Servers that don't
understand paging, such as ldapd(8), ignore it and return a single set of
results as before.
from Jim Smith, some tweaks and fixes by me, ok dlg@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.29 2012/03/15 03:44:46 jmatthew Exp $ */
/*	$OpenBSD: aldap.c,v 1.29 2012/03/15 03:44:46 jmatthew Exp $ */
d355 1
a355 2
	if (page->cookie)
		free(page->cookie);
@


1.29
log
@Accept empty/nonexistant ldap attributes when we want a list.  This allows
empty groups to show up, which is helpful if they're used as primary
groups.

ok dlg@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.28 2011/08/28 16:37:28 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.28 2011/08/28 16:37:28 aschrijver Exp $ */
d34 4
a37 2
static struct ber_element	*ldap_parse_search_filter(struct ber_element*, char *);
static struct ber_element	*ldap_do_parse_search_filter(struct ber_element*, char **);
d41 2
d150 2
a151 1
    char **attrs, int typesonly, int sizelimit, int timelimit)
d153 1
a153 1
	struct ber_element *root = NULL, *ber;
d159 11
a169 3
	ber = ber_printf_elements(root, "d{tsEEddb", ++ldap->msgid, BER_CLASS_APP,
	    (unsigned long)LDAP_REQ_SEARCH, basedn, (long long)scope,
	    (long long)LDAP_DEREF_NEVER, sizelimit, timelimit, typesonly);
d188 2
d209 39
d251 2
a252 1
	int			 class = 0;
a253 1
	unsigned long		 type  = 0;
d255 1
a255 1
	struct ber_element	*a = NULL;
d285 9
d311 47
@


1.28
log
@Use the correct terminology, replace the term "entry" with the term "attribute" where applicable.

OK martinh@@ pyr@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.27 2011/04/06 11:36:26 miod Exp $ */
/*	$OpenBSD: aldap.c,v 1.27 2011/04/06 11:36:26 miod Exp $ */
d403 1
a403 1
		return (-1);
@


1.27
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.26 2010/07/21 17:32:12 martinh Exp $ */
/*	$OpenBSD: aldap.c,v 1.26 2010/07/21 17:32:12 martinh Exp $ */
d234 1
a234 1
		    &m->body.search.entries) != 0)
d315 1
a315 1
aldap_count_entries(struct aldap_message *msg)
d320 1
a320 1
	if (msg->body.search.entries == NULL)
d323 1
a323 1
	for (i = 0, a = msg->body.search.entries;
d332 1
a332 1
aldap_first_entry(struct aldap_message *msg, char **outkey, char ***outvalues)
d338 1
a338 1
	if (msg->body.search.entries == NULL)
d341 1
a341 1
	if (ber_scanf_elements(msg->body.search.entries, "{s(e)}e",
d345 1
a345 1
	msg->body.search.iter = msg->body.search.entries->be_next;
d361 1
a361 1
aldap_next_entry(struct aldap_message *msg, char **outkey, char ***outvalues)
d370 1
a370 1
	LDAP_DEBUG("entry", msg->body.search.iter);
d396 1
a396 1
aldap_match_entry(struct aldap_message *msg, char *inkey, char ***outvalues)
d402 1
a402 1
	if (msg->body.search.entries == NULL)
d405 1
a405 1
	LDAP_DEBUG("entry", msg->body.search.entries);
d407 1
a407 1
	for (a = msg->body.search.entries;;) {
d433 1
a433 1
aldap_free_entry(char **values)
@


1.26
log
@Search filter BER tags use a context-specific class, not an application
class. This allows ypldap to talk to ldapd, which otherwise refuses the
search filter.

ok gilles@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.25 2010/07/21 14:45:59 gilles Exp $ */
/*	$OpenBSD: aldap.c,v 1.25 2010/07/21 14:45:59 gilles Exp $ */
d1066 1
a1066 1
	for (len = 0, i = 0; u[i] != NULL; ) {
d1082 1
a1082 1
	for (i = 0, j = 0; u[i] != NULL; j++) {
@


1.25
log
@fix NULL-deref, ok martinh@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.24 2010/06/14 13:15:22 pyr Exp $ */
/*	$OpenBSD: aldap.c,v 1.24 2010/06/14 13:15:22 pyr Exp $ */
d692 1
a692 1
		ber_set_header(elm, BER_CLASS_APP, type);
d710 1
a710 1
		ber_set_header(root, BER_CLASS_APP, LDAP_FILT_NOT);
@


1.24
log
@fix a memory leak, from aschrivjer
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.23 2010/04/28 10:05:28 jasper Exp $ */
/*	$OpenBSD: aldap.c,v 1.23 2010/04/28 10:05:28 jasper Exp $ */
d606 1
a606 1
	for (a = elm, i = 0; a->be_type == BER_TYPE_OCTETSTRING;
@


1.23
log
@- plug memleak (in #if 0'd code)

ok pyr@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.22 2010/02/07 13:04:25 blambert Exp $ */
/*	$OpenBSD: aldap.c,v 1.22 2010/02/07 13:04:25 blambert Exp $ */
d58 1
@


1.22
log
@A few visual cleanups, and clarify a comment.

Also:

	for (i = 0; i >= 0 && foo; i++)

is functionally equivalent to:

	for (i = 0; foo; i++)

so use the clearer construct where appropriate.

ok pyr@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.21 2010/02/06 08:04:45 blambert Exp $ */
/*	$OpenBSD: aldap.c,v 1.21 2010/02/06 08:04:45 blambert Exp $ */
d549 1
@


1.21
log
@Simplify LDAP URL handling (currently unused):
instead of strdup()'ing multiple values from an already strdup'ed
buffer (none of which were checked for NULL upon return, which is
also fixed in this), just use a buffer attached to the aldap_url
struct.

Add an aldap_search_url() function, which is a wrapper around
aldap_parse_url and aldap_search.

Finally, since the URL bits are unused, wrap them in #if 0 for now.

ok pyr@@, whose heart was a little broken by the #if 0 (temporary, I swear!)
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.20 2009/07/08 13:13:17 blambert Exp $ */
/*	$OpenBSD: aldap.c,v 1.20 2009/07/08 13:13:17 blambert Exp $ */
d169 1
a169 1
		for (i = 0; i >= 0 && attrs[i] != NULL; i++) {
d225 1
a225 1
			    &m->body.res.rescode, &m->dn, &m->body.res.diagmsg, &a) != 0)
d293 1
a293 1
	for (i = 0; i >= 0 && values[i] != NULL; i++)
d322 2
a323 1
	for (i = 0, a = msg->body.search.entries; i >= 0 && a != NULL && ber_get_eoc(a) != 0;
d340 2
a341 2
	if (ber_scanf_elements(msg->body.search.entries, "{s(e)}e", &key, &b,
		    &c) != 0)
d439 1
a439 1
	for (i = 0; i >= 0 && values[i] != NULL; i++)
d604 1
a604 1
	for (a = elm, i = 0; i >= 0 && a->be_type == BER_TYPE_OCTETSTRING;
d658 1
a658 1
 *	    i.e., cp jumps to "(filter)"
d1115 1
a1115 1
	for (i = 0, j = 0; i >= 0 && j < len; i++) {
@


1.20
log
@Fix memory leak in sarch filter parsing code.

ok pyr@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.19 2009/01/29 11:43:31 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.19 2009/01/29 11:43:31 aschrijver Exp $ */
a62 1

d446 1
d450 1
a450 6
	int i;
	free(lu->host);
	free(lu->dn);
	for (i = 0; i < MAXATTR && lu->attributes[i] != NULL; i++) {
		free(lu->attributes[i]);
	}
d457 1
a457 1
	char		*dupstr, *p, *forward, *forward2;
d461 2
a462 1
	p = dupstr = strdup(url);
d487 1
a487 1
	lu->host = strdup(p);
d498 1
a498 1
	lu->dn = strdup(p);
d513 1
a513 1
			lu->attributes[i] = strdup(p);
d517 1
a517 1
		lu->attributes[i] = strdup(p);
d536 2
d545 2
a546 4
	if (p == NULL)
		goto done;
	lu->filter = strdup(p);

a547 1
	free(dupstr);
d550 2
a551 1
	free(dupstr);
d555 24
d1137 1
@


1.19
log
@

Make anonymous binds work properly.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.18 2009/01/28 00:53:29 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.18 2009/01/28 00:53:29 aschrijver Exp $ */
d784 4
a787 3
				if ((elm =
				    ber_add_nstring(elm, parsed_val,
					    strlen(parsed_val))) == NULL)
a788 1
				free(parsed_val);
d798 3
a800 2
		if ((elm = ber_add_nstring(elm, parsed_val,
				    strlen(parsed_val))) == NULL)
a801 1
		free(parsed_val);
@


1.18
log
@

Correct dup to dupstr.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.17 2009/01/27 16:17:49 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.17 2009/01/27 16:17:49 aschrijver Exp $ */
d81 5
@


1.17
log
@

Add space after keywords.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.16 2009/01/27 15:37:03 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.16 2009/01/27 15:37:03 aschrijver Exp $ */
d550 1
a550 1
	free(dup);
@


1.16
log
@

Oops, fix the error handling. Found by blambert@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.15 2009/01/27 13:24:25 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.15 2009/01/27 13:24:25 aschrijver Exp $ */
d55 1
a55 1
	if(close(al->ber.fd) == -1)
d69 1
a69 1
	if((a = calloc(1, sizeof(*a))) == NULL)
d82 1
a82 1
	if((root = ber_add_sequence(NULL)) == NULL)
d88 1
a88 1
	if(elm == NULL)
d101 1
a101 1
	if(root != NULL)
d114 1
a114 1
	if((root = ber_add_sequence(NULL)) == NULL)
d118 1
a118 1
	if(elm == NULL)
d131 1
a131 1
	if(root != NULL)
d146 1
a146 1
	if((root = ber_add_sequence(NULL)) == NULL)
d152 1
a152 1
	if(ber == NULL) {
d157 1
a157 1
	if((ber = ldap_parse_search_filter(ber, filter)) == NULL) {
d162 1
a162 1
	if((ber = ber_add_sequence(ber)) == NULL)
d164 3
a166 3
	if(attrs != NULL)
		for(i = 0; i >= 0 && attrs[i] != NULL; i++) {
			if((ber = ber_add_string(ber, attrs[i])) == NULL)
d183 1
a183 1
	if(root != NULL)
d198 1
a198 1
	if((m = calloc(1, sizeof(struct aldap_message))) == NULL)
d201 1
a201 1
	if((m->msg = ber_read_elements(&ldap->ber, NULL)) == NULL)
d206 1
a206 1
	if(ber_scanf_elements(m->msg, "{ite", &msgid, &class, &type, &a) != 0)
d212 1
a212 1
	switch(m->message_type) {
d220 1
a220 1
		if(ber_scanf_elements(m->protocol_op, "{EeSeSe",
d223 2
a224 2
		if(m->body.res.rescode == LDAP_REFERRAL)
			if(ber_scanf_elements(a, "{e", &m->references) != 0)
d228 1
a228 1
		if(ber_scanf_elements(m->protocol_op, "{eS{e", &m->dn,
d233 1
a233 1
		if(ber_scanf_elements(m->protocol_op, "{e", &m->references) != 0)
d264 1
a264 1
	if(msg->dn == NULL)
d267 1
a267 1
	if(ber_get_string(msg->dn, &dn) == -1)
d276 1
a276 1
	if(msg->references == NULL)
d286 1
a286 1
	if(values == NULL)
d289 1
a289 1
	for(i = 0; i >= 0 && values[i] != NULL; i++)
d300 1
a300 1
	if(msg->body.res.diagmsg == NULL)
d303 1
a303 1
	if(ber_get_string(msg->body.res.diagmsg, &s) == -1)
d315 1
a315 1
	if(msg->body.search.entries == NULL)
d318 1
a318 1
	for(i = 0, a = msg->body.search.entries; i >= 0 && a != NULL && ber_get_eoc(a) != 0;
d332 1
a332 1
	if(msg->body.search.entries == NULL)
d335 1
a335 1
	if(ber_scanf_elements(msg->body.search.entries, "{s(e)}e", &key, &b,
d341 1
a341 1
	if((ret = aldap_get_stringset(b)) == NULL)
d361 1
a361 1
	if(msg->body.search.iter == NULL)
d366 1
a366 1
	if(ber_get_eoc(msg->body.search.iter) == 0)
d369 1
a369 1
	if(ber_scanf_elements(msg->body.search.iter, "{s(e)}e", &key, &a, &b)
d375 1
a375 1
	if((ret = aldap_get_stringset(a)) == NULL)
d396 1
a396 1
	if(msg->body.search.entries == NULL)
d401 2
a402 2
	for(a = msg->body.search.entries;;) {
		if(a == NULL)
d404 1
a404 1
		if(ber_get_eoc(a) == 0)
d406 1
a406 1
		if(ber_scanf_elements(a, "{s(e", &descr, &b) != 0)
d408 1
a408 1
		if(strcasecmp(descr, inkey) == 0)
d414 1
a414 1
	if((ret = aldap_get_stringset(b)) == NULL)
d431 1
a431 1
	if(values == NULL)
d434 1
a434 1
	for(i = 0; i >= 0 && values[i] != NULL; i++)
d448 1
a448 1
	for(i = 0; i < MAXATTR && lu->attributes[i] != NULL; i++) {
d464 1
a464 1
	if(strncasecmp(LDAP_URL, p, strlen(LDAP_URL)) != 0)
d470 1
a470 1
	if((forward = strchr(p, '/')) != NULL)
d473 1
a473 1
	if((forward2 = strchr(p, ':')) != NULL) {
d476 1
a476 1
		if(*(forward2+1) != '\0') {
d479 1
a479 1
			if(errstr)
d484 1
a484 1
	if(strlen(p) == 0)
d487 1
a487 1
	if(forward == NULL)
d491 1
a491 1
	if(strlen(p) == 0)
d495 1
a495 1
	if((forward = strchr(p, '?')) != NULL)
d498 1
a498 1
	if(forward == NULL)
d502 1
a502 1
	if(strlen(p) == 0)
d506 1
a506 1
	if((forward = strchr(p, '?')) != NULL)
d508 3
a510 3
	for(i = 0; i < MAXATTR; i++) {
		if((forward2 = strchr(p, ',')) == NULL) {
			if(strlen(p) == 0)
d519 1
a519 1
	if(forward == NULL)
d523 1
a523 1
	if(strlen(p) == 0)
d527 1
a527 1
	if((forward = strchr(p, '?')) != NULL)
d529 1
a529 1
	if(strcmp(p, "base") == 0)
d531 1
a531 1
	else if(strcmp(p, "one") == 0)
d533 1
a533 1
	else if(strcmp(p, "sub") == 0)
d535 1
a535 1
	if(forward == NULL)
d538 1
a538 1
	if(strlen(p) == 0)
d542 1
a542 1
	if(p == NULL)
d566 1
a566 1
	if(elm->be_type != BER_TYPE_OCTETSTRING)
d569 1
a569 1
	for(a = elm, i = 1; i > 0 && a != NULL && a->be_type ==
d572 1
a572 1
	if(i == 1)
d575 1
a575 1
	if((ret = calloc(i + 1, sizeof(char *))) == NULL)
d578 1
a578 1
	for(a = elm, i = 0; i >= 0 && a->be_type == BER_TYPE_OCTETSTRING;
d669 1
a669 1
		while(*cp == '(') {
d697 1
a697 1
		switch(*cp) {
d776 1
a776 1
				if((parsed_val = parseval(attr_val, len)) ==
d791 1
a791 1
		if((parsed_val = parseval(attr_val, len)) == NULL)
d808 1
a808 1
	if(root != NULL)
d1038 2
a1039 2
	for(len = 0, i = 0; u[i] != NULL; ) {
		if((u[i] & 0xF0) == 0xF0)
d1041 1
a1041 1
		else if((u[i] & 0xE0) == 0xE0)
d1043 1
a1043 1
		else if((u[i] & 0xC0) == 0xC0)
d1050 1
a1050 1
	if((str = calloc(len + 1, sizeof(char))) == NULL)
d1054 2
a1055 2
	for(i = 0, j = 0; u[i] != NULL; j++) {
		if((u[i] & 0xF0) == 0xF0) {
d1058 1
a1058 1
		} else if((u[i] & 0xE0) == 0xE0) {
d1061 1
a1061 1
		} else if((u[i] & 0xC0) == 0xC0) {
d1086 1
a1086 1
	if((buffer = calloc(1, size)) == NULL)
d1089 2
a1090 2
	for(i = 0, j = 0; i >= 0 && j < len; i++) {
		if(i >= size) {
d1100 1
a1100 1
		if(cp[j] == '\\') {
@


1.15
log
@

Fix another double free in the filter parser.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.14 2009/01/27 11:38:32 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.14 2009/01/27 11:38:32 aschrijver Exp $ */
d152 2
a153 1
	if(ber == NULL)
d155 1
d157 4
a160 2
	if((ber = ldap_parse_search_filter(ber, filter)) == NULL)
		goto parsefail;
d175 2
a176 1
	if (error == -1)
d178 1
a181 2
parsefail:
	ldap->err = ALDAP_ERR_PARSER_ERROR;
a182 2
	ldap->err = ALDAP_ERR_OPERATION_FAILED;

@


1.14
log
@

Remove unnecessary comment.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.13 2009/01/27 11:33:22 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.13 2009/01/27 11:33:22 aschrijver Exp $ */
d612 1
@


1.13
log
@

Add correct error handling to the aldap API.
Use the error handling in the ldapclient.

with help from pyr@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.12 2009/01/26 21:56:15 pyr Exp $ */
/*	$OpenBSD: aldap.c,v 1.12 2009/01/26 21:56:15 pyr Exp $ */
d176 1
a176 1
parsefail: /* XXX -- error reporting */
@


1.12
log
@move aldap_close in aldap.c, where it belongs.
discussed with aschrijver@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.11 2009/01/16 13:11:15 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.11 2009/01/16 13:11:15 aschrijver Exp $ */
d103 2
d134 2
d177 1
d179 2
d238 1
d1108 22
@


1.11
log
@

Fix double free with invalid ldap filter (reported by dlg@@).
Fix more memory leaks.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.10 2009/01/04 00:11:05 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.10 2009/01/04 00:11:05 aschrijver Exp $ */
d25 1
d52 12
d447 1
a447 1
	char		*dup, *p, *forward, *forward2;
d451 1
a451 1
	p = dup = strdup(url);
d537 1
a537 1
	free(dup);
@


1.10
log
@

Fix memory leak (diff from blambert@@)

Fix debug messages.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.9 2008/12/28 22:03:59 blambert Exp $ */
/*	$OpenBSD: aldap.c,v 1.9 2008/12/28 22:03:59 blambert Exp $ */
d66 1
a66 1
	struct ber_element *root;
d69 4
a72 2
	root = ber_add_sequence(NULL);
	ber_printf_elements(root, "d{tdsst", ++ldap->msgid, BER_CLASS_APP,
d75 2
d82 1
d84 1
a84 1
		return (-1);
d87 4
d96 1
a96 1
	struct ber_element *root;
d99 3
a101 2
	root = ber_add_sequence(NULL);
	ber_printf_elements(root, "d{t", ++ldap->msgid, BER_CLASS_APP,
d103 2
d110 1
d112 1
a112 1
		return (-1);
d115 5
d126 1
a126 1
	struct ber_element *root, *ber;
d129 3
a131 1
	root = ber_add_sequence(NULL);
d135 2
d138 2
a139 2
	ber = ldap_parse_search_filter(ber, filter);
	ber = ber_add_sequence(ber);
d141 2
d144 4
a147 2
		for(i = 0; i >= 0 && attrs[i] != NULL; i++)
			ber = ber_add_string(ber, attrs[i]);
d153 1
d155 1
a155 1
		return (-1);
d158 7
d617 1
a617 1
	struct ber_element *elm, *root;
d767 1
a767 2
		if((parsed_val = parseval(attr_val, len)) ==
		    NULL)
d769 2
a770 2
		if ((elm = ber_add_nstring(elm, parsed_val, strlen(parsed_val)))
		    == NULL)
d784 3
a786 1
	ber_free_elements(root);
@


1.9
log
@Plug some memory leakage in aldap_parse by calling aldap_freemsg
Let aldap_freemsg allow for a NULL ber_element tree, since it's now
possible to pass one in.

"looks fine to me :-)" aschrijver@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.8 2008/12/27 19:46:12 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.8 2008/12/27 19:46:12 aschrijver Exp $ */
d67 1
d76 3
a78 1
	if(ber_write_elements(&ldap->ber, root) == -1)
a80 2
	ber_free_elements(root);

d88 1
d96 3
a98 1
	if(ber_write_elements(&ldap->ber, root) == -1)
a100 2
	ber_free_elements(root);

d109 1
a109 1
	int i;
d125 3
a127 1
	if(ber_write_elements(&ldap->ber, root) == -1)
a129 2
	ber_free_elements(root);

d304 3
a308 2
	if(msg->body.search.iter == NULL)
		goto notfound;
a338 2
	LDAP_DEBUG("entry", msg->search_entries);

d341 2
@


1.8
log
@

Fix memory leak.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.7 2008/11/28 10:07:56 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.7 2008/11/28 10:07:56 aschrijver Exp $ */
d144 1
a144 1
		return NULL;
d171 1
a171 1
			    &m->body.search.entries) != 0)
d182 1
d189 2
a190 1
	ber_free_elements(msg->msg);
@


1.7
log
@Add support for escaped characters to the search filter parsing function.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.6 2008/10/28 13:47:22 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.6 2008/10/28 13:47:22 aschrijver Exp $ */
d78 2
d97 2
d125 2
@


1.6
log
@Do the DNS resolution in a seperate process. A lot of code is copied from ntpd.
This is necessary because DNS resolution is not possible from a chroot.

Cleanup the aldap interface a bit.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.5 2008/10/14 21:41:03 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.5 2008/10/14 21:41:03 aschrijver Exp $ */
d36 2
a37 1
char				*utoa(char *u);
d522 1
a522 1
 * Base case for __ldap_do_parse_search_filter
d554 1
a554 1
 * Translate RFC2254 search filter string into ber_element tree
a567 1
 *	escaped characters aren't supported (yet).
d573 1
a573 1
	char *attr_desc, *attr_val, *cp;
d707 3
d711 2
a712 1
				    ber_add_nstring(elm, attr_val, len)) == NULL)
d714 1
d722 5
a726 1
		if ((elm = ber_add_nstring(elm, attr_val, len)) == NULL)
d728 1
d980 2
a981 1
	str = calloc(len + 1, sizeof(char));
d1001 40
@


1.5
log
@Add support for referrals and lists of attributes.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.4 2008/10/06 08:01:28 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.4 2008/10/06 08:01:28 aschrijver Exp $ */
d262 1
d265 1
a265 1
		return (-1);
d269 1
a269 1
		return (-1);
d273 4
a276 1
	(*outvalues) = aldap_get_stringset(b);
d280 4
d291 1
d306 4
a309 1
	(*outvalues) = aldap_get_stringset(a);
d325 1
d345 4
a348 1
	(*outvalues) = aldap_get_stringset(b);
@


1.4
log
@use strtonum() instead of atoi() and remove an unnecessary bzero()

ok pyr@@
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.3 2008/10/02 15:24:14 deraadt Exp $ */
/*	$OpenBSD: aldap.c,v 1.3 2008/10/02 15:24:14 deraadt Exp $ */
d159 1
a159 1
			if(ber_scanf_elements(a, "{e", &m->body.references) != 0)
d168 1
a168 1
		if(ber_scanf_elements(m->protocol_op, "{e", &m->body.references) != 0)
d208 3
a210 1
	 return aldap_get_stringset(msg->body.references);
d392 2
a393 1
			lu->port = strtonum(++forward2, 0, sizeof(lu->port), &errstr);
d484 2
a485 2
	for(a = elm, i = 1; i > 0 && a->be_type == BER_TYPE_OCTETSTRING;
	    a = a->be_next, i++)
d487 2
@


1.3
log
@use calloc() instead of malloc() and bzero()
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.2 2008/09/30 17:31:04 pyr Exp $ */
/*	$OpenBSD: aldap.c,v 1.2 2008/09/30 17:31:04 pyr Exp $ */
d21 2
a24 1
#include <errno.h>
d370 3
a372 2
	char	*dup, *p, *forward, *forward2;
	int	 i;
d389 5
a393 2
		if(*(forward2+1) != '\0')
			lu->port = atoi(++forward2);
a949 1
	bzero(str, (len + 1) * sizeof(char));
@


1.2
log
@fix ugly comments.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.1 2008/09/30 16:24:16 aschrijver Exp $ */
/*	$OpenBSD: aldap.c,v 1.1 2008/09/30 16:24:16 aschrijver Exp $ */
d54 1
a54 1
	if((a = malloc(sizeof(*a))) == NULL)
a55 1
	bzero(a, sizeof(*a));
d132 1
a132 1
	if((m = malloc(sizeof(struct aldap_message))) == NULL)
a133 1
	bzero(m, sizeof(struct aldap_message));
@


1.1
log
@aldap library -- Replacement for openldap used in ypldap. aldap is an semi-asynchronous client interface to connect to LDAP servers.
@
text
@d1 2
a2 2
/*	$Id: aldap.c,v 1.10 2008/08/28 17:15:14 alex Exp $ */
/*	$OpenBSD$ */
d27 3
a29 1
//#define DEBUG
a43 1
//#define LDAP_DEBUG(x, y)	do { printf("*** " x "\n"); } while (0)
@

