head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.10
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.8
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.4
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.34
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.32
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.28
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.26
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.24
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.22
	OPENBSD_5_0:1.20.0.20
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.18
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.16
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.12
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.14
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.10
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.8
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.21
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2006.12.31.03.25.58;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2006.09.28.17.43.42;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.27.18.14.59;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.15.20.53.02;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.18.17.54.12;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.10.13.42.37;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.01.02.03.58;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.01.01.28.19;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.01.01.11.30;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.01.00.36.41;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.23.20.40.38;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.20.12.02.04;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.07.22.32.52;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.30.16.50.03;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.09.13.21.13;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.30.17.18.24;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.04.16.48.55;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.17.19.13.35;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.13.18.31.38;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.13.18.12.23;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: hostapd.h,v 1.20 2006/12/31 03:25:58 reyk Exp $	*/

/*
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _HOSTAPD_H
#define _HOSTAPD_H

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <event.h>
#include <syslog.h>

#include <net80211/ieee80211.h>
#include <net80211/ieee80211_ioctl.h>

/*
 * hostapd (IAPP) <-> Host AP (APME)
 */

struct hostapd_node {
	u_int8_t	ni_macaddr[IEEE80211_ADDR_LEN];
	u_int8_t	ni_bssid[IEEE80211_ADDR_LEN];
	u_int32_t	ni_associd;
	u_int16_t	ni_capinfo;
	u_int16_t	ni_flags;
	u_int16_t	ni_rxseq;
	u_int16_t	ni_rssi;
};

/*
 * IAPP -> switches (LLC)
 */

struct hostapd_llc {
	struct ether_header x_hdr;
	struct llc x_llc;
} __packed;

#define IAPP_LLC	LLC_XID
#define IAPP_LLC_XID	0x81
#define IAPP_LLC_CLASS	1
#define IAPP_LLC_WINDOW	1 << 1

/*
 * hostapd configuration
 */

struct hostapd_counter {
	u_int64_t	cn_tx_llc;	/* sent LLC messages */
	u_int64_t	cn_rx_iapp;	/* received IAPP messages */
	u_int64_t	cn_tx_iapp;	/* sent IAPP messages */
	u_int64_t	cn_rx_apme;	/* received Host AP messages */
	u_int64_t	cn_tx_apme;	/* sent Host AP messages */
	u_int64_t	cn_rtap_miss;	/* missing radiotap field */
};

#define HOSTAPD_ENTRY_MASK_ADD(_a, _m)	do {					\
	(_a)[0] &= (_m)[0];							\
	(_a)[1] &= (_m)[1];							\
	(_a)[2] &= (_m)[2];							\
	(_a)[3] &= (_m)[3];							\
	(_a)[4] &= (_m)[4];							\
	(_a)[5] &= (_m)[5];							\
} while (0);
#define HOSTAPD_ENTRY_MASK_MATCH(_e, _b)	(				\
	((_e)->e_lladdr[0] == ((_b)[0] & (_e)->e_addr.a_mask[0])) &&		\
	((_e)->e_lladdr[1] == ((_b)[1] & (_e)->e_addr.a_mask[1])) &&		\
	((_e)->e_lladdr[2] == ((_b)[2] & (_e)->e_addr.a_mask[2])) &&		\
	((_e)->e_lladdr[3] == ((_b)[3] & (_e)->e_addr.a_mask[3])) &&		\
	((_e)->e_lladdr[4] == ((_b)[4] & (_e)->e_addr.a_mask[4])) &&		\
	((_e)->e_lladdr[5] == ((_b)[5] & (_e)->e_addr.a_mask[5]))		\
)

struct hostapd_inaddr {
	sa_family_t		in_af;
	union {
		struct in_addr	v4;
		struct in6_addr	v6;
	} in_v;
	int			in_netmask;
};

#define in_v4			in_v.v4
#define in_v6			in_v.v6

struct hostapd_entry {
	u_int8_t			e_lladdr[IEEE80211_ADDR_LEN];
	u_int8_t			e_flags;

#define HOSTAPD_ENTRY_F_LLADDR		0x00
#define HOSTAPD_ENTRY_F_MASK		0x01
#define HOSTAPD_ENTRY_F_INADDR		0x02

	union {
		u_int8_t		a_mask[IEEE80211_ADDR_LEN];
		struct hostapd_inaddr	a_inaddr;
	}				e_addr;

	RB_ENTRY(hostapd_entry)		e_nodes;
	TAILQ_ENTRY(hostapd_entry)	e_entries;
};

#define e_mask				e_addr.a_mask
#define e_inaddr			e_addr.a_inaddr

#define HOSTAPD_TABLE_NAMELEN		32

RB_HEAD(hostapd_tree, hostapd_entry);

struct hostapd_table {
	char				t_name[HOSTAPD_TABLE_NAMELEN];
	u_int8_t			t_flags;

#define HOSTAPD_TABLE_F_CONST		0x01

	struct hostapd_tree		t_tree;
	TAILQ_HEAD(, hostapd_entry)	t_mask_head;
	TAILQ_ENTRY(hostapd_table)	t_entries;
};

struct hostapd_radiotap {
	u_int32_t	r_present;
	u_int8_t	r_txrate;
	u_int16_t	r_chan;
	u_int16_t	r_chan_flags;
	u_int8_t	r_rssi;
	u_int8_t	r_max_rssi;
};
#define HOSTAPD_RADIOTAP_F(_x)	(1 << IEEE80211_RADIOTAP_##_x)

struct hostapd_ieee80211_frame {
	u_int8_t	i_fc[2];
	u_int8_t	i_dur[2];
	u_int8_t	i_from[IEEE80211_ADDR_LEN];
	u_int8_t	i_to[IEEE80211_ADDR_LEN];
	u_int8_t	i_bssid[IEEE80211_ADDR_LEN];
	u_int8_t	i_seq[2];
	void		*i_data;
	u_int		i_data_len;
};

enum hostapd_action {
	HOSTAPD_ACTION_NONE	= 0,
	HOSTAPD_ACTION_LOG	= 1,
	HOSTAPD_ACTION_RADIOTAP	= 2,
	HOSTAPD_ACTION_FRAME	= 3,
	HOSTAPD_ACTION_ADDNODE	= 4,
	HOSTAPD_ACTION_DELNODE	= 5,
	HOSTAPD_ACTION_RESEND	= 6
};

enum hostapd_op {
	HOSTAPD_OP_EQ		= 0,
	HOSTAPD_OP_NE		= 1,
	HOSTAPD_OP_LE		= 2,
	HOSTAPD_OP_LT		= 3,
	HOSTAPD_OP_GE		= 4,
	HOSTAPD_OP_GT		= 5
};

struct hostapd_action_data {
	union {
		struct hostapd_ieee80211_frame	u_frame;
		u_int8_t			u_lladdr[IEEE80211_ADDR_LEN];
	} a_data;
	u_int16_t				a_flags;

#define HOSTAPD_ACTION_F_REF_FROM		0x0001
#define HOSTAPD_ACTION_F_REF_TO			0x0002
#define HOSTAPD_ACTION_F_REF_BSSID		0x0004
#define HOSTAPD_ACTION_F_REF_RANDOM		0x0008
#define HOSTAPD_ACTION_F_REF_FROM_M		0x000f
#define HOSTAPD_ACTION_F_REF_FROM_S		0
#define HOSTAPD_ACTION_F_REF_TO_M		0x00f0
#define HOSTAPD_ACTION_F_REF_TO_S		4
#define HOSTAPD_ACTION_F_REF_BSSID_M		0x0f00
#define HOSTAPD_ACTION_F_REF_BSSID_S		8
#define HOSTAPD_ACTION_F_REF_M			0x0fff
#define HOSTAPD_ACTION_F_OPT_DIR_AUTO		0x1000
#define HOSTAPD_ACTION_F_OPT_LLADDR		0x2000
#define HOSTAPD_ACTION_F_OPT_TABLE		0x4000
};

#define a_frame					a_data.u_frame
#define a_lladdr				a_data.u_lladdr

struct hostapd_frame {
	struct hostapd_ieee80211_frame	f_frame;
	u_int32_t			f_radiotap;

	u_int32_t			f_flags;

#define HOSTAPD_FRAME_F_TYPE		0x00000001
#define HOSTAPD_FRAME_F_TYPE_N		0x00000002
#define HOSTAPD_FRAME_F_SUBTYPE		0x00000004
#define HOSTAPD_FRAME_F_SUBTYPE_N	0x00000008
#define HOSTAPD_FRAME_F_DIR		0x00000010
#define HOSTAPD_FRAME_F_DIR_N		0x00000020
#define HOSTAPD_FRAME_F_FROM		0x00000040
#define HOSTAPD_FRAME_F_FROM_N		0x00000080
#define HOSTAPD_FRAME_F_FROM_TABLE	0x00000100
#define HOSTAPD_FRAME_F_FROM_M		0x000001c0
#define HOSTAPD_FRAME_F_TO		0x00000200
#define HOSTAPD_FRAME_F_TO_N		0x00000400
#define HOSTAPD_FRAME_F_TO_TABLE	0x00000800
#define HOSTAPD_FRAME_F_TO_M		0x00000e00
#define HOSTAPD_FRAME_F_BSSID		0x00001000
#define HOSTAPD_FRAME_F_BSSID_N		0x00002000
#define HOSTAPD_FRAME_F_BSSID_TABLE	0x00004000
#define HOSTAPD_FRAME_F_BSSID_M		0x00007000
#define HOSTAPD_FRAME_F_APME		0x00008000
#define HOSTAPD_FRAME_F_APME_N		0x00010000
#define HOSTAPD_FRAME_F_APME_M		0x00018000
#define HOSTAPD_FRAME_F_RSSI		0x00020000
#define HOSTAPD_FRAME_F_RATE		0x00040000
#define HOSTAPD_FRAME_F_CHANNEL		0x00080000
#define HOSTAPD_FRAME_F_RADIOTAP_M	0x000e0000
#define HOSTAPD_FRAME_F_M		0x0fffffff
#define HOSTAPD_FRAME_F_RET_OK		0x00000000
#define HOSTAPD_FRAME_F_RET_QUICK	0x10000000
#define HOSTAPD_FRAME_F_RET_SKIP	0x20000000
#define HOSTAPD_FRAME_F_RET_M		0xf0000000
#define HOSTAPD_FRAME_F_RET_S		28

#define HOSTAPD_FRAME_TABLE						\
	(HOSTAPD_FRAME_F_FROM_TABLE | HOSTAPD_FRAME_F_TO_TABLE |	\
	HOSTAPD_FRAME_F_BSSID_TABLE)
#define HOSTAPD_FRAME_N							\
	(HOSTAPD_FRAME_F_FROM_N | HOSTAPD_FRAME_F_TO_N |		\
	HOSTAPD_FRAME_F_BSSID_N)

	struct hostapd_apme		*f_apme;
	struct hostapd_table		*f_from, *f_to, *f_bssid;
	struct timeval			f_limit, f_then, f_last;
	long				f_rate, f_rate_intval;
	long				f_rate_cnt, f_rate_delay;

	enum hostapd_op			f_rssi_op, f_txrate_op, f_chan_op;
	short				f_rssi, f_txrate, f_chan;

	enum hostapd_action		f_action;
	u_int32_t			f_action_flags;

#define HOSTAPD_ACTION_VERBOSE		0x00000001

	struct hostapd_action_data	f_action_data;

	TAILQ_ENTRY(hostapd_frame)	f_entries;
};

struct hostapd_apme {
	int				a_raw;
	u_int				a_rawlen;
	struct event			a_ev;
	char				a_iface[IFNAMSIZ];
	u_int8_t			a_bssid[IEEE80211_ADDR_LEN];
	void				*a_cfg;
	struct sockaddr_in		a_addr;

	struct event			a_chanev;
	u_int8_t			*a_chanavail;
	u_int8_t			a_curchan;
	u_int				a_maxchan;
	struct ieee80211chanreq		a_chanreq;

	TAILQ_ENTRY(hostapd_apme)	a_entries;
};

#ifndef IEEE80211_CHAN_MAX
#define IEEE80211_CHAN_MAX	255
#endif

#define HOSTAPD_HOPPER_MDELAY	800

struct hostapd_iapp {
	u_int16_t			i_cnt;
	int				i_raw;
	char				i_iface[IFNAMSIZ];
	int				i_udp;
	struct event			i_udp_ev;
	u_int16_t			i_udp_port;
	struct sockaddr_in		i_addr;
	struct sockaddr_in		i_broadcast;
	struct sockaddr_in		i_multicast;
	u_int8_t			i_ttl;
	u_int8_t			i_flags;

#define HOSTAPD_IAPP_F_ADD_NOTIFY	0x01
#define HOSTAPD_IAPP_F_RADIOTAP		0x02
#define HOSTAPD_IAPP_F_ROAMING_ADDRESS	0x04
#define HOSTAPD_IAPP_F_ROAMING_ROUTE	0x08
#define HOSTAPD_IAPP_F_DEFAULT							\
	(HOSTAPD_IAPP_F_ADD_NOTIFY | HOSTAPD_IAPP_F_RADIOTAP)
#define HOSTAPD_IAPP_F_ROAMING							\
	(HOSTAPD_IAPP_F_ROAMING_ROUTE | HOSTAPD_IAPP_F_ROAMING_ADDRESS)
#define HOSTAPD_IAPP_F_ADD		\
	(HOSTAPD_IAPP_F_ADD_NOTIFY | HOSTAPD_IAPP_F_ROAMING)

	struct hostapd_table		*i_addr_tbl;
	struct hostapd_table		*i_route_tbl;
};

struct hostapd_config {
	int				c_apme_ctl;
	u_int				c_apme_dlt;
	struct timeval			c_apme_hopdelay;

	struct hostapd_iapp		c_iapp;

	int				c_rtsock;
	int				c_rtseq;

	u_int8_t			c_flags;

#define HOSTAPD_CFG_F_APME		0x01
#define HOSTAPD_CFG_F_IAPP		0x02
#define HOSTAPD_CFG_F_IAPP_PASSIVE	0x04
#define HOSTAPD_CFG_F_RAW		0x08
#define HOSTAPD_CFG_F_UDP		0x10
#define HOSTAPD_CFG_F_BRDCAST		0x20
#define HOSTAPD_CFG_F_PRIV		0x40

	struct event			c_priv_ev;

	char				c_config[PATH_MAX];

	u_int				c_verbose;
	u_int				c_debug;
	u_int				c_id;

	struct hostapd_counter		c_stats;

	TAILQ_HEAD(, hostapd_apme)	c_apmes;
	TAILQ_HEAD(, hostapd_table)	c_tables;
	TAILQ_HEAD(, hostapd_frame)	c_frames;
};

#define	HOSTAPD_USER	"_hostapd"
#define HOSTAPD_CONFIG	"/etc/hostapd.conf"
#define HOSTAPD_DLT	DLT_IEEE802_11

#define HOSTAPD_LOG		0
#define HOSTAPD_LOG_VERBOSE	1
#define HOSTAPD_LOG_DEBUG	2

#define PRINTF			hostapd_printf
#define etheraddr_string(_s)	ether_ntoa((struct ether_addr*)_s)
#define TTEST2(var, l)		(						\
	snapend - (l) <= snapend && (const u_char *)&(var) <= snapend - (l)	\
)
#define TTEST(var)		TTEST2(var, sizeof(var))
#define TCHECK2(var, l)		if (!TTEST2(var, l)) goto trunc
#define TCHECK(var)		TCHECK2(var, sizeof(var))

__BEGIN_DECLS

void	 hostapd_log(u_int, const char *, ...);
void	 hostapd_printf(const char *, ...);
void	 hostapd_fatal(const char *, ...);
int	 hostapd_bpf_open(u_int);
void	 hostapd_cleanup(struct hostapd_config *);
int	 hostapd_check_file_secrecy(int, const char *);
void	 hostapd_randval(u_int8_t *, const u_int)
	    __attribute__((__bounded__(__buffer__, 1, 2)));

struct hostapd_table *hostapd_table_add(struct hostapd_config *,
	    const char *);
struct hostapd_table *hostapd_table_lookup(struct hostapd_config *,
	    const char *);
struct hostapd_entry *hostapd_entry_add(struct hostapd_table *,
	    u_int8_t *);
struct hostapd_entry *hostapd_entry_lookup(struct hostapd_table *,
	    u_int8_t *);
void	 hostapd_entry_update(struct hostapd_table *,
	    struct hostapd_entry *);

RB_PROTOTYPE(hostapd_tree, hostapd_entry, e_nodes, hostapd_entry_cmp);

int	 hostapd_parse_file(struct hostapd_config *);
int	 hostapd_parse_symset(char *);

void	 hostapd_priv_init(struct hostapd_config *);
int	 hostapd_priv_llc_xid(struct hostapd_config *, struct hostapd_node *);
void	 hostapd_priv_apme_bssid(struct hostapd_apme *);
int	 hostapd_priv_apme_getnode(struct hostapd_apme *,
	    struct hostapd_node *);
int	 hostapd_priv_apme_setnode(struct hostapd_apme *,
	    struct hostapd_node *node, int);
int	 hostapd_priv_roaming(struct hostapd_apme *, struct hostapd_node *,
	    int);

void	 hostapd_apme_init(struct hostapd_apme *);
int	 hostapd_apme_deauth(struct hostapd_apme *);
int	 hostapd_apme_add(struct hostapd_config *, const char *);
void	 hostapd_apme_term(struct hostapd_apme *);
struct hostapd_apme *hostapd_apme_lookup(struct hostapd_config *,
	    const char *);
void	 hostapd_apme_input(int, short, void *);
int	 hostapd_apme_output(struct hostapd_apme *,
	    struct hostapd_ieee80211_frame *);
int	 hostapd_apme_addnode(struct hostapd_apme *,
	    struct hostapd_node *node);
int	 hostapd_apme_delnode(struct hostapd_apme *,
	    struct hostapd_node *node);
int	 hostapd_apme_offset(struct hostapd_apme *, u_int8_t *,
	    const u_int);
struct hostapd_apme *hostapd_apme_addhopper(struct hostapd_config *,
	    const char *);
void	 hostapd_apme_sethopper(struct hostapd_apme *, int);

void	 hostapd_iapp_init(struct hostapd_config *);
void	 hostapd_iapp_term(struct hostapd_config *);
int	 hostapd_iapp_add_notify(struct hostapd_apme *,
	    struct hostapd_node *);
int	 hostapd_iapp_radiotap(struct hostapd_apme *,
	    u_int8_t *, const u_int);
void	 hostapd_iapp_input(int, short, void *);

void	 hostapd_llc_init(struct hostapd_config *);
int	 hostapd_llc_send_xid(struct hostapd_config *, struct hostapd_node *);

int	 hostapd_handle_input(struct hostapd_apme *, u_int8_t *, u_int);

void	 hostapd_print_ieee80211(u_int, u_int, u_int8_t *, u_int);

void	 hostapd_roaming_init(struct hostapd_config *);
void	 hostapd_roaming_term(struct hostapd_apme *);
int	 hostapd_roaming(struct hostapd_apme *, struct hostapd_node *, int);
int	 hostapd_roaming_add(struct hostapd_apme *,
	    struct hostapd_node *node);
int	 hostapd_roaming_del(struct hostapd_apme *,
	    struct hostapd_node *node);

__END_DECLS

#endif /* _HOSTAPD_H */
@


1.20
log
@add a channel hopper for wireless interfaces. the channel hopper will
jump to the next available channel after a configurable delay for the
specified list of wireless "hostap" interfaces, see the new "set
hostap hopper" commands in hostapd.conf(5).

with help by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.19 2006/09/28 17:43:42 reyk Exp $	*/
a21 1
#include <sys/param.h>
d346 1
a346 1
	char				c_config[MAXPATHLEN];
@


1.19
log
@hostapd tree search speedup via inlined compare function

suggested by Mike Belopuhov (mkb at crypt dot org dot ru)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.18 2006/06/27 18:14:59 reyk Exp $	*/
d282 6
d291 6
d328 1
d429 3
@


1.18
log
@add new event rules to match optional elements of radiotap headers:
signal percentage, transmit rate and channel frequency.

ok and hints by jsg@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.17 2006/05/15 20:53:02 reyk Exp $	*/
a384 1
int	 hostapd_entry_cmp(struct hostapd_entry *, struct hostapd_entry *);
@


1.17
log
@initial implementation of "IP Roaming" in hostapd, see hostapd.conf(5).

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.16 2005/12/18 17:54:12 reyk Exp $	*/
d76 1
d143 10
d174 9
d211 2
d236 4
d259 3
@


1.16
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.15 2005/12/10 13:42:37 reyk Exp $	*/
d271 2
d275 7
d290 3
d370 2
d403 8
@


1.15
log
@add an option to increase the multicast ttl which is currently limited
to 1 hop. by using a higher multicast ttl, you could use inter-network
multicast forwarding of hostapd messages (i.e. with mrouted(8) or
multicast-capable routing switches); "set iapp mode multicast ttl 2".
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.14 2005/12/01 02:03:58 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.14
log
@add configuration option to enable/disable specified iapp subtype handling
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.13 2005/12/01 01:28:19 reyk Exp $	*/
d266 1
@


1.13
log
@support netmasks in table entry ip address assignments
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.12 2005/12/01 01:11:30 reyk Exp $	*/
d266 6
@


1.12
log
@move iapp configuration in a separate data structure
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.11 2005/12/01 00:36:41 reyk Exp $	*/
d95 12
d113 1
a113 1
#define HOSTAPD_ENTRY_F_IPV4		0x02
d117 1
a117 1
		struct in_addr		a_ipv4;
d125 1
a125 1
#define e_ipv4				e_addr.a_ipv4
d251 1
@


1.11
log
@deauthenticate all stations on startup which will force them to
reassociate cleanly.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.10 2005/11/23 20:40:38 reyk Exp $	*/
d243 12
d259 1
a259 9
	u_int16_t			c_iapp;
	int				c_iapp_raw;
	char				c_iapp_iface[IFNAMSIZ];
	int				c_iapp_udp;
	struct event			c_iapp_udp_ev;
	u_int16_t			c_iapp_udp_port;
	struct sockaddr_in		c_iapp_addr;
	struct sockaddr_in		c_iapp_broadcast;
	struct sockaddr_in		c_iapp_multicast;
@


1.10
log
@add optional interface rule for event rules
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.9 2005/11/20 12:02:04 reyk Exp $	*/
d336 1
@


1.9
log
@add support for multiple hostap (wireless) interfaces.

for example, if you run one hostapd with two ath(4) devices. you have
to specify "set hostap interface { ath0, ath1 }" in hostapd.conf(5).

man page bits by jmc@@, tested by others
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.8 2005/10/07 22:32:52 reyk Exp $	*/
d199 3
d216 1
@


1.8
log
@move IAPP definitions to separate header file
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.7 2005/09/30 16:50:03 reyk Exp $	*/
d228 11
d240 1
a240 7
	int				c_apme;
	int				c_apme_raw;
	u_int				c_apme_rawlen;
	struct event			c_apme_ev;
	char				c_apme_iface[IFNAMSIZ];
	int				c_apme_n;
	u_int8_t			c_apme_bssid[IEEE80211_ADDR_LEN];
d273 1
d325 2
a326 2
void	 hostapd_priv_apme_bssid(struct hostapd_config *);
int	 hostapd_priv_apme_getnode(struct hostapd_config *,
d328 1
a328 1
int	 hostapd_priv_apme_setnode(struct hostapd_config *,
d331 5
a335 1
void	 hostapd_apme_init(struct hostapd_config *);
d337 1
a337 1
int	 hostapd_apme_output(struct hostapd_config *,
d339 1
a339 1
int	 hostapd_apme_addnode(struct hostapd_config *,
d341 1
a341 1
int	 hostapd_apme_delnode(struct hostapd_config *,
d343 1
a343 1
int	 hostapd_apme_offset(struct hostapd_config *, u_int8_t *,
d348 1
a348 1
int	 hostapd_iapp_add_notify(struct hostapd_config *,
d350 1
a350 1
int	 hostapd_iapp_radiotap(struct hostapd_config *,
d357 1
a357 1
int	 hostapd_handle_input(struct hostapd_config *, u_int8_t *, u_int);
@


1.7
log
@implement a way to match IEEE 802.11 flooding. this will help to detect
known DoS attacks, like de-auth flooding against wireless networks.
an example is provided in the manual page.

"or could you just got for it?", deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.6 2005/09/09 13:21:13 reyk Exp $	*/
a37 2
#define IEEE80211_IAPP_VERSION	0

a52 30
 * IAPP <-> IAPP
 */

struct ieee80211_iapp_frame {
	u_int8_t	i_version;
	u_int8_t	i_command;
	u_int16_t	i_identifier;
	u_int16_t	i_length;
} __packed;

enum ieee80211_iapp_frame_type {
	IEEE80211_IAPP_FRAME_ADD_NOTIFY			= 0,
	IEEE80211_IAPP_FRAME_MOVE_NOTIFY		= 1,
	IEEE80211_IAPP_FRAME_MOVE_RESPONSE		= 2,
	IEEE80211_IAPP_FRAME_SEND_SECURITY_BLOCK	= 3,
	IEEE80211_IAPP_FRAME_ACK_SECURITY_BLOCK		= 4,
	IEEE80211_IAPP_FRAME_CACHE_NOTIFY		= 5,
	IEEE80211_IAPP_FRAME_CACHE_RESPONSE		= 6,
	IEEE80211_IAPP_FRAME_HOSTAPD_RADIOTAP		= 12,
	IEEE80211_IAPP_FRAME_HOSTAPD_PCAP		= 13
};

struct ieee80211_iapp_add_notify {
	u_int8_t	a_length;
	u_int8_t	a_reserved;
	u_int8_t	a_macaddr[IEEE80211_ADDR_LEN];
	u_int16_t	a_seqnum;
} __packed;

/*
a270 4

#define IAPP_PORT	3517	/* XXX this should be added to /etc/services */
#define IAPP_MCASTADDR	"224.0.1.178"
#define IAPP_MAXSIZE	512
@


1.6
log
@replace hasch tables with red-black trees used by the node tables.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.5 2005/07/30 17:18:24 reyk Exp $	*/
d246 3
a248 1
	struct timeval			f_limit, f_then;
@


1.5
log
@enable -Wbounded

ok anil
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.4 2005/07/04 16:48:55 reyk Exp $	*/
d25 1
d140 1
d148 2
a149 4
#define HOSTAPD_TABLE_HASHSIZE		256
#define HOSTAPD_TABLE_HASH(_a)		(((((					\
	(0 ^ (_a)[0]) ^ (_a)[1]) ^ (_a)[2]) ^ (_a)[3]) ^ (_a)[4]) ^ (_a)[5]	\
)
d157 1
a157 1
	TAILQ_HEAD(, hostapd_entry)	t_head[HOSTAPD_TABLE_HASHSIZE];
d344 3
@


1.4
log
@add 'random' action address and auth open request/response
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.3 2005/06/17 19:13:35 reyk Exp $	*/
d331 2
a332 1
void	 hostapd_randval(u_int8_t *, const u_int);
@


1.3
log
@first step to implement a proactive wireless monitoring system using
hostapd(8). it's a very simple but powerful approach using highly
flexible and stateless event and action rules for IEEE 802.11 traffic.
you can monitor a wireless network by watching frames with types and
addresses (with support for tables and masks) and you can trigger
actions like writing log messages, sending pcap/radiotap dumps to the
IAPP network, removing nodes from the hostap, resending received
frames and sending contructed 802.11 frames in reply to traffic
received from any rogue nodes.

it's based on some initial work from the c2k5 which has been tested
and improved during the last weeks. some missing documentation for
hostapd.conf(5) will be written as soon as possible.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.2 2005/04/13 18:31:38 henning Exp $	*/
d191 3
a195 1
#define HOSTAPD_ACTION_F_REF_TO			0x0002
a197 1
#define HOSTAPD_ACTION_F_REF_BSSID		0x0004
d331 1
@


1.2
log
@KNG
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.h,v 1.1 2005/04/13 18:12:23 reyk Exp $	*/
a42 3
#define SIOCS80211IAPP	0
#define SIOCG80211IAPP	1

d71 3
a73 1
	IEEE80211_IAPP_FRAME_CACHE_RESPONSE		= 6
d109 144
a252 27
struct hostapd_config {
	int			c_apme;
	int			c_apme_raw;
	u_int			c_apme_rawlen;
	struct event		c_apme_ev;
	char			c_apme_iface[IFNAMSIZ];
	int			c_apme_n;
	u_int8_t		c_apme_bssid[IEEE80211_ADDR_LEN];

	u_int16_t		c_iapp;
	int			c_iapp_raw;
	char			c_iapp_iface[IFNAMSIZ];
	int			c_iapp_udp;
	struct event		c_iapp_udp_ev;
	u_int16_t		c_iapp_udp_port;
	struct sockaddr_in	c_iapp_addr;
	struct sockaddr_in	c_iapp_broadcast;
	struct sockaddr_in	c_iapp_multicast;

	u_int8_t		c_flags;

#define HOSTAPD_CFG_F_APME	0x01
#define HOSTAPD_CFG_F_IAPP	0x02
#define HOSTAPD_CFG_F_RAW	0x04
#define HOSTAPD_CFG_F_UDP	0x08
#define HOSTAPD_CFG_F_BRDCAST	0x10
#define HOSTAPD_CFG_F_PRIV	0x20
d254 2
a255 1
	struct event		c_priv_ev;
d257 37
a293 1
	char			c_config[MAXPATHLEN];
d295 1
a295 2
	u_int			c_verbose;
	u_int			c_debug;
d297 2
a298 1
	struct hostapd_counter	c_stats;
a302 1
#define IAPP_DLT	DLT_IEEE802_11
a305 1

d307 1
d313 9
d325 1
d331 11
d350 2
a351 2
int	 hostapd_priv_apme_delnode(struct hostapd_config *,
	    struct hostapd_node *);
d355 8
d368 2
d374 4
@


1.1
log
@add the initial version of the OpenBSD hostapd daemon

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 2
a134 2
#define HOSTAPD_CFG_F_RAW		0x04
#define HOSTAPD_CFG_F_UDP		0x08
d141 1
a141 1
	
d159 1
a159 1
#define HOSTAPD_LOG_DEBUG		2
d175 4
a178 2
int	 hostapd_priv_apme_getnode(struct hostapd_config *, struct hostapd_node *);
int	 hostapd_priv_apme_delnode(struct hostapd_config *, struct hostapd_node *);
d185 2
a186 1
int	 hostapd_iapp_add_notify(struct hostapd_config *, struct hostapd_node *);
@

