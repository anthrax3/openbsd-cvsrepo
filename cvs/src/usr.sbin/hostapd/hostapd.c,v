head	1.38;
access;
symbols
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.37.0.6
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.28
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.26
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.22
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.20
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.18
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.16
	OPENBSD_5_0:1.34.0.14
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.12
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.10
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.6
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.8
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.4
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17;
locks; strict;
comment	@ * @;


1.38
date	2017.04.19.05.36.13;	author natano;	state Exp;
branches;
next	1.37;
commitid	0scK6D05EyEW7eqZ;

1.37
date	2016.05.28.07.00.18;	author natano;	state Exp;
branches;
next	1.36;
commitid	V3qpA476A18HvhDy;

1.36
date	2015.12.22.19.45.09;	author mmcc;	state Exp;
branches;
next	1.35;
commitid	QOxpTmPlmUfcKYBg;

1.35
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2008.05.12.23.49.28;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.02.09.09.29;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.08.11.15.55;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2006.09.28.17.43.42;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.01.22.09.09;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.13.18.25.12;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.25.13.38.25;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.18.17.54.12;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.10.13.42.37;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.01.01.11.30;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.20.12.02.04;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.16.00.01.19;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.07.22.32.52;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.07.21.52.40;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.13.09.22.42;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.09.13.21.13;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.17.13.18.33;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.30.17.16.09;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.04.18.48.05;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.04.17.51.44;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.04.17.13.39;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.04.16.48.55;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.17.19.13.35;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.21.19.18.51;	author msf;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.14.10.59.56;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.13.21.15.36;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.13.19.59.08;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.13.19.26.05;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.13.19.16.08;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.13.19.08.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.13.18.55.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.13.18.25.28;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.13.18.12.23;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Switch base tools from /dev/bpf0 to /dev/bpf. Now that /dev/bpf has been
around for two releases, it should be safe to do so.

ok bluhm deraadt sthen tb yasuoka
@
text
@/*	$OpenBSD: hostapd.c,v 1.37 2016/05/28 07:00:18 natano Exp $	*/

/*
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/signal.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_arp.h>
#include <net/if_llc.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <err.h>

#include "hostapd.h"
#include "iapp.h"

void	 hostapd_usage(void);
void	 hostapd_udp_init(struct hostapd_config *);
void	 hostapd_sig_handler(int, short, void *);
static __inline int
	 hostapd_entry_cmp(struct hostapd_entry *, struct hostapd_entry *);

struct hostapd_config hostapd_cfg;

extern char *__progname;
char printbuf[BUFSIZ];

void
hostapd_usage(void)
{
	fprintf(stderr, "usage: %s [-dv] [-D macro=value] [-f file]\n",
	    __progname);
	exit(EXIT_FAILURE);
}

void
hostapd_log(u_int level, const char *fmt, ...)
{
	char *nfmt = NULL;
	va_list ap;

	if (level > hostapd_cfg.c_verbose)
		return;

	va_start(ap, fmt);
	if (hostapd_cfg.c_debug) {
		if (asprintf(&nfmt, "%s\n", fmt) != -1)
			vfprintf(stderr, nfmt, ap);
		else {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		}
		fflush(stderr);
	} else
		vsyslog(LOG_INFO, fmt, ap);
	va_end(ap);

	free(nfmt);
}

void
hostapd_printf(const char *fmt, ...)
{
	char newfmt[BUFSIZ];
	va_list ap;
	size_t n;

	if (fmt == NULL)
		goto flush;

	va_start(ap, fmt);
	bzero(newfmt, sizeof(newfmt));
	if ((n = strlcpy(newfmt, printbuf, sizeof(newfmt))) >= sizeof(newfmt))
		goto va_flush;
	if (strlcpy(newfmt + n, fmt, sizeof(newfmt) - n) >= sizeof(newfmt) - n)
		goto va_flush;
	if (vsnprintf(printbuf, sizeof(printbuf), newfmt, ap) == -1)
		goto va_flush;
	va_end(ap);

	return;

 va_flush:
	va_end(ap);
 flush:
	if (strlen(printbuf))
		hostapd_log(HOSTAPD_LOG, "%s", printbuf);
	bzero(printbuf, sizeof(printbuf));
}

void
hostapd_fatal(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	if (hostapd_cfg.c_debug) {
		vfprintf(stderr, fmt, ap);
		fflush(stderr);
	} else
		vsyslog(LOG_ERR, fmt, ap);
	va_end(ap);

	hostapd_cleanup(&hostapd_cfg);
	exit(EXIT_FAILURE);
}

int
hostapd_check_file_secrecy(int fd, const char *fname)
{
	struct stat st;

	if (fstat(fd, &st)) {
		hostapd_log(HOSTAPD_LOG,
		    "cannot stat %s", fname);
		return (-1);
	}

	if (st.st_uid != 0 && st.st_uid != getuid()) {
		hostapd_log(HOSTAPD_LOG,
		    "%s: owner not root or current user", fname);
		return (-1);
	}

	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		hostapd_log(HOSTAPD_LOG,
		    "%s: group/world readable/writeable", fname);
		return (-1);
	}

	return (0);
}

int
hostapd_bpf_open(u_int flags)
{
	int fd = -1;
	struct bpf_version bpv;

	if ((fd = open("/dev/bpf", flags)) == -1) {
		hostapd_fatal("unable to open BPF device: %s\n",
		    strerror(errno));
	}

	/*
	 * Get and validate the BPF version
	 */

	if (ioctl(fd, BIOCVERSION, &bpv) == -1)
		hostapd_fatal("failed to get BPF version: %s\n",
		    strerror(errno));

	if (bpv.bv_major != BPF_MAJOR_VERSION ||
	    bpv.bv_minor < BPF_MINOR_VERSION)
		hostapd_fatal("invalid BPF version\n");

	return (fd);
}

void
hostapd_udp_init(struct hostapd_config *cfg)
{
	struct hostapd_iapp *iapp = &cfg->c_iapp;
	struct ifreq ifr;
	struct sockaddr_in *addr, baddr;
	struct ip_mreq mreq;
	int brd = 1;

	bzero(&ifr, sizeof(ifr));

	/*
	 * Open a listening UDP socket
	 */

	if ((iapp->i_udp = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		hostapd_fatal("unable to open udp socket\n");

	cfg->c_flags |= HOSTAPD_CFG_F_UDP;

	(void)strlcpy(ifr.ifr_name, iapp->i_iface, sizeof(ifr.ifr_name));

	if (ioctl(iapp->i_udp, SIOCGIFADDR, &ifr) == -1)
		hostapd_fatal("UDP ioctl %s on \"%s\" failed: %s\n",
		    "SIOCGIFADDR", ifr.ifr_name, strerror(errno));

	addr = (struct sockaddr_in *)&ifr.ifr_addr;
	iapp->i_addr.sin_family = AF_INET;
	iapp->i_addr.sin_addr.s_addr = addr->sin_addr.s_addr;
	if (iapp->i_addr.sin_port == 0)
		iapp->i_addr.sin_port = htons(IAPP_PORT);

	if (ioctl(iapp->i_udp, SIOCGIFBRDADDR, &ifr) == -1)
		hostapd_fatal("UDP ioctl %s on \"%s\" failed: %s\n",
		    "SIOCGIFBRDADDR", ifr.ifr_name, strerror(errno));

	addr = (struct sockaddr_in *)&ifr.ifr_addr;
	iapp->i_broadcast.sin_family = AF_INET;
	iapp->i_broadcast.sin_addr.s_addr = addr->sin_addr.s_addr;
	iapp->i_broadcast.sin_port = iapp->i_addr.sin_port;

	baddr.sin_family = AF_INET;
	baddr.sin_addr.s_addr = htonl(INADDR_ANY);
	baddr.sin_port = iapp->i_addr.sin_port;

	if (bind(iapp->i_udp, (struct sockaddr *)&baddr,
	    sizeof(baddr)) == -1)
		hostapd_fatal("failed to bind UDP socket: %s\n",
		    strerror(errno));

	/*
	 * The revised 802.11F standard requires IAPP messages to be
	 * sent via multicast to the default group 224.0.1.178.
	 * Nevertheless, some implementations still use broadcasts
	 * for IAPP messages.
	 */
	if (cfg->c_flags & HOSTAPD_CFG_F_BRDCAST) {
		/*
		 * Enable broadcast
		 */
		if (setsockopt(iapp->i_udp, SOL_SOCKET, SO_BROADCAST,
		    &brd, sizeof(brd)) == -1)
			hostapd_fatal("failed to enable broadcast on socket\n");

		hostapd_log(HOSTAPD_LOG_DEBUG, "%s: using broadcast mode "
		    "(address %s)", iapp->i_iface, inet_ntoa(addr->sin_addr));
	} else {
		/*
		 * Enable multicast
		 */
		bzero(&mreq, sizeof(mreq));

		iapp->i_multicast.sin_family = AF_INET;
		if (iapp->i_multicast.sin_addr.s_addr == INADDR_ANY)
			iapp->i_multicast.sin_addr.s_addr =
			    inet_addr(IAPP_MCASTADDR);
		iapp->i_multicast.sin_port = iapp->i_addr.sin_port;

		mreq.imr_multiaddr.s_addr =
		    iapp->i_multicast.sin_addr.s_addr;
		mreq.imr_interface.s_addr =
		    iapp->i_addr.sin_addr.s_addr;

		if (setsockopt(iapp->i_udp, IPPROTO_IP,
		    IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) == -1)
			hostapd_fatal("failed to add multicast membership to "
			    "%s: %s\n", IAPP_MCASTADDR, strerror(errno));

		if (setsockopt(iapp->i_udp, IPPROTO_IP, IP_MULTICAST_TTL,
		    &iapp->i_ttl, sizeof(iapp->i_ttl)) < 0)
			hostapd_fatal("failed to set multicast ttl to "
			    "%u: %s\n", iapp->i_ttl, strerror(errno));

		hostapd_log(HOSTAPD_LOG_DEBUG, "%s: using multicast mode "
		    "(ttl %u, group %s)", iapp->i_iface, iapp->i_ttl,
		    inet_ntoa(iapp->i_multicast.sin_addr));
	}
}

/* ARGSUSED */
void
hostapd_sig_handler(int sig, short event, void *arg)
{
	switch (sig) {
	case SIGALRM:
	case SIGTERM:
	case SIGQUIT:
	case SIGINT:
		(void)event_loopexit(NULL);
	}
}

void
hostapd_cleanup(struct hostapd_config *cfg)
{
	struct hostapd_iapp *iapp = &cfg->c_iapp;
	struct ip_mreq mreq;
	struct hostapd_apme *apme;
	struct hostapd_table *table;
	struct hostapd_entry *entry;

	/* Release all Host APs */
	if (cfg->c_flags & HOSTAPD_CFG_F_APME) {
		while ((apme = TAILQ_FIRST(&cfg->c_apmes)) != NULL)
			hostapd_apme_term(apme);
	}

	if (cfg->c_flags & HOSTAPD_CFG_F_PRIV &&
	    (cfg->c_flags & HOSTAPD_CFG_F_BRDCAST) == 0) {
		/*
		 * Disable multicast and let the kernel unsubscribe
		 * from the multicast group.
		 */

		bzero(&mreq, sizeof(mreq));

		mreq.imr_multiaddr.s_addr =
		    inet_addr(IAPP_MCASTADDR);
		mreq.imr_interface.s_addr =
		    iapp->i_addr.sin_addr.s_addr;

		if (setsockopt(iapp->i_udp, IPPROTO_IP,
		    IP_DROP_MEMBERSHIP, &mreq, sizeof(mreq)) == -1)
			hostapd_log(HOSTAPD_LOG, "failed to remove multicast"
			    " membership to %s: %s",
			    IAPP_MCASTADDR, strerror(errno));
	}

	if ((cfg->c_flags & HOSTAPD_CFG_F_PRIV) == 0 &&
	    cfg->c_flags & HOSTAPD_CFG_F_APME) {
		/* Shutdown the Host AP protocol handler */
		hostapd_iapp_term(&hostapd_cfg);
	}

	/* Cleanup tables */
	while ((table = TAILQ_FIRST(&cfg->c_tables)) != NULL) {
		while ((entry = RB_MIN(hostapd_tree, &table->t_tree)) != NULL) {
			RB_REMOVE(hostapd_tree, &table->t_tree, entry);
			free(entry);
		}
		while ((entry = TAILQ_FIRST(&table->t_mask_head)) != NULL) {
			TAILQ_REMOVE(&table->t_mask_head, entry, e_entries);
			free(entry);
		}
		TAILQ_REMOVE(&cfg->c_tables, table, t_entries);
		free(table);
	}

	hostapd_log(HOSTAPD_LOG_VERBOSE, "bye!");
}

int
main(int argc, char *argv[])
{
	struct event ev_sigalrm;
	struct event ev_sigterm;
	struct event ev_sigquit;
	struct event ev_sigint;
	struct hostapd_config *cfg = &hostapd_cfg;
	struct hostapd_iapp *iapp;
	struct hostapd_apme *apme;
	char *config = NULL;
	u_int debug = 0, ret;
	int ch;

	/* Set startup logging */
	cfg->c_debug = 1;

	/*
	 * Get and parse command line options
	 */
	while ((ch = getopt(argc, argv, "f:D:dv")) != -1) {
		switch (ch) {
		case 'f':
			config = optarg;
			break;
		case 'D':
			if (hostapd_parse_symset(optarg) < 0)
				hostapd_fatal("could not parse macro "
				    "definition %s\n", optarg);
			break;
		case 'd':
			debug++;
			break;
		case 'v':
			cfg->c_verbose++;
			break;
		default:
			hostapd_usage();
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		hostapd_usage();

	if (config == NULL)
		ret = strlcpy(cfg->c_config, HOSTAPD_CONFIG, sizeof(cfg->c_config));
	else
		ret = strlcpy(cfg->c_config, config, sizeof(cfg->c_config));
	if (ret >= sizeof(cfg->c_config))
		hostapd_fatal("invalid configuration file\n");

	if (geteuid())
		hostapd_fatal("need root privileges\n");

	/* Parse the configuration file */
	if (hostapd_parse_file(cfg) != 0)
		hostapd_fatal("invalid configuration in %s\n", cfg->c_config);

	iapp = &cfg->c_iapp;

	if ((cfg->c_flags & HOSTAPD_CFG_F_IAPP) == 0)
		hostapd_fatal("IAPP interface not specified\n");

	if (cfg->c_apme_dlt == 0)
		cfg->c_apme_dlt = HOSTAPD_DLT;

	/*
	 * Setup the hostapd handlers
	 */
	hostapd_udp_init(cfg);
	hostapd_llc_init(cfg);

	/*
	 * Set runtime logging and detach as daemon
	 */
	if ((cfg->c_debug = debug) == 0) {
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);
		tzset();
		if (daemon(0, 0) == -1)
			hostapd_fatal("failed to daemonize\n");
	}

	if (cfg->c_flags & HOSTAPD_CFG_F_APME) {
		TAILQ_FOREACH(apme, &cfg->c_apmes, a_entries)
			hostapd_apme_init(apme);
	} else
		hostapd_log(HOSTAPD_LOG, "%s: running without a Host AP",
		    iapp->i_iface);

	/* Drop all privileges in an unprivileged child process */
	hostapd_priv_init(cfg);

	if (cfg->c_flags & HOSTAPD_CFG_F_APME)
		setproctitle("IAPP: %s, Host AP", iapp->i_iface);
	else
		setproctitle("IAPP: %s", iapp->i_iface);

	/*
	 * Unprivileged child process
	 */

	(void)event_init();

	/*
	 * Set signal handlers
	 */
	signal_set(&ev_sigalrm, SIGALRM, hostapd_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, hostapd_sig_handler, NULL);
	signal_set(&ev_sigquit, SIGQUIT, hostapd_sig_handler, NULL);
	signal_set(&ev_sigint, SIGINT, hostapd_sig_handler, NULL);
	signal_add(&ev_sigalrm, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sigquit, NULL);
	signal_add(&ev_sigint, NULL);
	signal(SIGHUP, SIG_IGN);
	signal(SIGCHLD, SIG_IGN);

	/* Initialize the IAPP protocol handler */
	hostapd_iapp_init(cfg);

	/*
	 * Schedule the Host AP listener
	 */
	if (cfg->c_flags & HOSTAPD_CFG_F_APME) {
		TAILQ_FOREACH(apme, &cfg->c_apmes, a_entries) {
			event_set(&apme->a_ev, apme->a_raw,
			    EV_READ | EV_PERSIST, hostapd_apme_input, apme);
			if (event_add(&apme->a_ev, NULL) == -1)
				hostapd_fatal("failed to add APME event");
		}
	}

	/*
	 * Schedule the IAPP listener
	 */
	event_set(&iapp->i_udp_ev, iapp->i_udp, EV_READ | EV_PERSIST,
	    hostapd_iapp_input, cfg);
	if (event_add(&iapp->i_udp_ev, NULL) == -1)
		hostapd_fatal("failed to add IAPP event");

	hostapd_log(HOSTAPD_LOG, "starting hostapd with pid %u",
	    getpid());

	/* Run event loop */
	if (event_dispatch() == -1)
		hostapd_fatal("failed to dispatch hostapd");

	/* Executed after the event loop has been terminated */
	hostapd_cleanup(cfg);
	return (EXIT_SUCCESS);
}

void
hostapd_randval(u_int8_t *buf, const u_int len)
{
	u_int32_t data = 0;
	u_int i;

	for (i = 0; i < len; i++) {
		if ((i % sizeof(data)) == 0)
			data = arc4random();
		buf[i] = data & 0xff;
		data >>= 8;
	}
}

struct hostapd_table *
hostapd_table_add(struct hostapd_config *cfg, const char *name)
{
	struct hostapd_table *table;

	if (hostapd_table_lookup(cfg, name) != NULL)
		return (NULL);
	if ((table = (struct hostapd_table *)
	    calloc(1, sizeof(struct hostapd_table))) == NULL)
		return (NULL);
	if (strlcpy(table->t_name, name, sizeof(table->t_name)) >=
	    sizeof(table->t_name)) {
		free(table);
		return (NULL);
	}
	RB_INIT(&table->t_tree);
	TAILQ_INIT(&table->t_mask_head);
	TAILQ_INSERT_TAIL(&cfg->c_tables, table, t_entries);

	return (table);
}

struct hostapd_table *
hostapd_table_lookup(struct hostapd_config *cfg, const char *name)
{
	struct hostapd_table *table;

	TAILQ_FOREACH(table, &cfg->c_tables, t_entries) {
		if (strcmp(name, table->t_name) == 0)
			return (table);
	}

	return (NULL);
}

struct hostapd_entry *
hostapd_entry_add(struct hostapd_table *table, u_int8_t *lladdr)
{
	struct hostapd_entry *entry;

	if (hostapd_entry_lookup(table, lladdr) != NULL)
		return (NULL);

	if ((entry = (struct hostapd_entry *)
	    calloc(1, sizeof(struct hostapd_entry))) == NULL)
		return (NULL);

	bcopy(lladdr, entry->e_lladdr, IEEE80211_ADDR_LEN);
	RB_INSERT(hostapd_tree, &table->t_tree, entry);

	return (entry);
}

struct hostapd_entry *
hostapd_entry_lookup(struct hostapd_table *table, u_int8_t *lladdr)
{
	struct hostapd_entry *entry, key;

	bcopy(lladdr, key.e_lladdr, IEEE80211_ADDR_LEN);
	if ((entry = RB_FIND(hostapd_tree, &table->t_tree, &key)) != NULL)
		return (entry);

	/* Masked entries can't be handled by the red-black tree */
	TAILQ_FOREACH(entry, &table->t_mask_head, e_entries) {
		if (HOSTAPD_ENTRY_MASK_MATCH(entry, lladdr))
			return (entry);
	}

	return (NULL);
}

void
hostapd_entry_update(struct hostapd_table *table, struct hostapd_entry *entry)
{
	RB_REMOVE(hostapd_tree, &table->t_tree, entry);

	/* Apply mask to entry */
	if (entry->e_flags & HOSTAPD_ENTRY_F_MASK) {
		HOSTAPD_ENTRY_MASK_ADD(entry->e_lladdr, entry->e_mask);
		TAILQ_INSERT_TAIL(&table->t_mask_head, entry, e_entries);
	} else {
		RB_INSERT(hostapd_tree, &table->t_tree, entry);
	}
}

static __inline int
hostapd_entry_cmp(struct hostapd_entry *a, struct hostapd_entry *b)
{
	return (memcmp(a->e_lladdr, b->e_lladdr, IEEE80211_ADDR_LEN));
}

RB_GENERATE(hostapd_tree, hostapd_entry, e_nodes, hostapd_entry_cmp);
@


1.37
log
@Replace the /dev/bpf* open loop with a plain open("/dev/bpf0", ...).
ok deraadt jca
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.36 2015/12/22 19:45:09 mmcc Exp $	*/
d176 1
a176 1
	if ((fd = open("/dev/bpf0", flags)) == -1) {
@


1.36
log
@remove a NULL-check before free()
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.35 2015/01/16 06:40:17 deraadt Exp $	*/
a172 1
	u_int i;
a173 1
	char *dev;
d176 3
a178 13
	/*
	 * Try to open the next available BPF device
	 */
	for (i = 0; i < 255; i++) {
		if (asprintf(&dev, "/dev/bpf%u", i) == -1)
			hostapd_fatal("failed to allocate buffer\n");

		if ((fd = open(dev, flags)) != -1) {
			free(dev);
			break;
		}

		free(dev);
a179 3

	if (fd == -1)
		hostapd_fatal("unable to open BPF device\n");
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.34 2008/05/12 23:49:28 millert Exp $	*/
d94 1
a94 2
	if (nfmt != NULL)
		free(nfmt);
@


1.34
log
@Fix cut and pasto; Steven Roberts
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.33 2008/05/12 19:15:02 pyr Exp $	*/
a19 1
#include <sys/param.h>
d22 1
d47 1
@


1.33
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.32 2007/05/02 09:09:29 claudio Exp $	*/
d426 1
a426 1
		usage();
@


1.32
log
@Use event(3) provided signal functions -- this decouples the event
handling and so the signal handlers are safe to call whatever they want.
This solves PR5463. OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.31 2007/02/08 11:15:55 reyk Exp $	*/
d422 5
@


1.31
log
@carefully check some return values and make lint happy. check for
truncation before feeding strings into the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.30 2006/09/28 17:43:42 reyk Exp $	*/
d54 1
a54 1
void	 hostapd_sig_handler(int);
d310 1
d312 1
a312 1
hostapd_sig_handler(int sig)
a313 5
	struct timeval tv;

	tv.tv_sec = 0;
	tv.tv_usec = 0;

d319 1
a319 1
		(void)event_loopexit(&tv);
d385 4
d485 8
a492 4
	signal(SIGALRM, hostapd_sig_handler);
	signal(SIGTERM, hostapd_sig_handler);
	signal(SIGQUIT, hostapd_sig_handler);
	signal(SIGINT, hostapd_sig_handler);
@


1.30
log
@hostapd tree search speedup via inlined compare function

suggested by Mike Belopuhov (mkb at crypt dot org dot ru)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.29 2006/06/01 22:09:09 reyk Exp $	*/
d231 1
a231 1
	strlcpy(ifr.ifr_name, iapp->i_iface, sizeof(ifr.ifr_name));
d323 1
a323 1
		event_loopexit(&tv);
d393 1
a393 1
	u_int debug = 0;
d424 1
a424 1
		strlcpy(cfg->c_config, HOSTAPD_CONFIG, sizeof(cfg->c_config));
d426 3
a428 1
		strlcpy(cfg->c_config, config, sizeof(cfg->c_config));
d457 2
a458 1
		daemon(0, 0);
d480 1
a480 1
	event_init();
d502 2
a503 1
			event_add(&apme->a_ev, NULL);
d512 2
a513 1
	event_add(&iapp->i_udp_ev, NULL);
d519 2
a520 1
	event_dispatch();
d551 5
a555 2

	strlcpy(table->t_name, name, sizeof(table->t_name));
@


1.29
log
@don't use the newline character in hostapd_log() calls
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.28 2006/05/13 18:25:12 reyk Exp $	*/
d55 2
d617 1
a617 1
int
@


1.28
log
@set the correct timezone using tzset() before before writing to syslog.

thanks to Bruno Carnazzi
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.27 2006/02/25 13:38:25 reyk Exp $	*/
d72 1
d80 6
a85 1
		vfprintf(stderr, fmt, ap);
d90 3
a114 3
	if (fmt[0] == '\n')
		goto flush;

d120 2
a121 1
	hostapd_log(HOSTAPD_LOG, "%s", printbuf);
d149 1
a149 1
		    "cannot stat %s\n", fname);
d155 1
a155 1
		    "%s: owner not root or current user\n", fname);
d161 1
a161 1
		    "%s: group/world readable/writeable\n", fname);
d274 1
a274 1
		    "(address %s)\n", iapp->i_iface, inet_ntoa(addr->sin_addr));
d303 1
a303 1
		    "(ttl %u, group %s)\n", iapp->i_iface, iapp->i_ttl,
d357 1
a357 1
			    " membership to %s: %s\n",
d381 1
a381 1
	hostapd_log(HOSTAPD_LOG_VERBOSE, "bye!\n");
d460 1
a460 1
		hostapd_log(HOSTAPD_LOG, "%s: running without a Host AP\n",
d508 1
a508 1
	hostapd_log(HOSTAPD_LOG, "starting hostapd with pid %u\n",
@


1.27
log
@fix for hostapd_printf() from Andrey Matveev:
---snip---
We allocate some memory with va_start() for storage variable arguments
in dynamic mode. va_end() takes care about clearing this memory.
Therefore we should be sure, that to each va_start() there corresponds
va_end() call. And on error path too.
---snap---
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.26 2005/12/18 17:54:12 reyk Exp $	*/
d445 1
@


1.26
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.25 2005/12/10 13:42:37 reyk Exp $	*/
d93 2
a94 6
	if (fmt == NULL) {
 flush:
		hostapd_log(HOSTAPD_LOG, "%s", printbuf);
		bzero(printbuf, sizeof(printbuf));
		return;
	}
d99 1
a99 1
		goto flush;
d101 1
a101 1
		goto flush;
d103 1
a103 1
		goto flush;
d108 8
@


1.25
log
@add an option to increase the multicast ttl which is currently limited
to 1 hop. by using a higher multicast ttl, you could use inter-network
multicast forwarding of hostapd messages (i.e. with mrouted(8) or
multicast-capable routing switches); "set iapp mode multicast ttl 2".
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.24 2005/12/01 01:11:30 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.24
log
@move iapp configuration in a separate data structure
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.23 2005/11/20 12:02:04 reyk Exp $	*/
a257 3

		hostapd_log(HOSTAPD_LOG_DEBUG, "using broadcast mode\n");

d261 3
a267 3

		hostapd_log(HOSTAPD_LOG_DEBUG, "using multicast mode\n");

d285 9
@


1.23
log
@add support for multiple hostap (wireless) interfaces.

for example, if you run one hostapd with two ath(4) devices. you have
to specify "set hostap interface { ath0, ath1 }" in hostapd.conf(5).

man page bits by jmc@@, tested by others
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.22 2005/11/16 00:01:19 reyk Exp $	*/
d201 1
d213 1
a213 1
	if ((cfg->c_iapp_udp = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
d218 1
a218 1
	strlcpy(ifr.ifr_name, cfg->c_iapp_iface, sizeof(ifr.ifr_name));
d220 1
a220 1
	if (ioctl(cfg->c_iapp_udp, SIOCGIFADDR, &ifr) == -1)
d225 4
a228 4
	cfg->c_iapp_addr.sin_family = AF_INET;
	cfg->c_iapp_addr.sin_addr.s_addr = addr->sin_addr.s_addr;
	if (cfg->c_iapp_addr.sin_port == 0)
		cfg->c_iapp_addr.sin_port = htons(IAPP_PORT);
d230 1
a230 1
	if (ioctl(cfg->c_iapp_udp, SIOCGIFBRDADDR, &ifr) == -1)
d235 3
a237 3
	cfg->c_iapp_broadcast.sin_family = AF_INET;
	cfg->c_iapp_broadcast.sin_addr.s_addr = addr->sin_addr.s_addr;
	cfg->c_iapp_broadcast.sin_port = cfg->c_iapp_addr.sin_port;
d241 1
a241 1
	baddr.sin_port = cfg->c_iapp_addr.sin_port;
d243 1
a243 1
	if (bind(cfg->c_iapp_udp, (struct sockaddr *)&baddr,
d261 1
a261 1
		if (setsockopt(cfg->c_iapp_udp, SOL_SOCKET, SO_BROADCAST,
d273 3
a275 3
		cfg->c_iapp_multicast.sin_family = AF_INET;
		if (cfg->c_iapp_multicast.sin_addr.s_addr == INADDR_ANY)
			cfg->c_iapp_multicast.sin_addr.s_addr =
d277 1
a277 1
		cfg->c_iapp_multicast.sin_port = cfg->c_iapp_addr.sin_port;
d280 1
a280 1
		    cfg->c_iapp_multicast.sin_addr.s_addr;
d282 1
a282 1
		    cfg->c_iapp_addr.sin_addr.s_addr;
d284 1
a284 1
		if (setsockopt(cfg->c_iapp_udp, IPPROTO_IP,
d311 1
d335 1
a335 1
		    cfg->c_iapp_addr.sin_addr.s_addr;
d337 1
a337 1
		if (setsockopt(cfg->c_iapp_udp, IPPROTO_IP,
d371 1
d416 2
d443 1
a443 1
		    cfg->c_iapp_iface);
d449 1
a449 1
		setproctitle("IAPP: %s, Host AP", cfg->c_iapp_iface);
d451 1
a451 1
		setproctitle("IAPP: %s", cfg->c_iapp_iface);
d486 1
a486 1
	event_set(&cfg->c_iapp_udp_ev, cfg->c_iapp_udp, EV_READ | EV_PERSIST,
d488 1
a488 1
	event_add(&cfg->c_iapp_udp_ev, NULL);
@


1.22
log
@add a configuration option for specifying a non-standard port and multicast
address for the IAPP messages. this is an initial approach to run multiple
hostapds on one machine, further work will be done later.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.21 2005/10/07 22:32:52 reyk Exp $	*/
d311 1
d315 6
d322 1
a322 2
	    (cfg->c_flags & HOSTAPD_CFG_F_BRDCAST) == 0 &&
	    cfg->c_apme_n == 0) {
d369 2
a370 1
	char *iapp_iface = NULL, *hostap_iface = NULL, *config = NULL;
a405 8
	if (iapp_iface != NULL)
		strlcpy(cfg->c_iapp_iface, iapp_iface,
		    sizeof(cfg->c_iapp_iface));

	if (hostap_iface != NULL)
		strlcpy(cfg->c_apme_iface, hostap_iface,
		    sizeof(cfg->c_apme_iface));

a415 3
	if ((cfg->c_flags & HOSTAPD_CFG_F_APME) == 0)
		strlcpy(cfg->c_apme_iface, "<none>", sizeof(cfg->c_apme_iface));

d433 6
a438 5
	if (cfg->c_flags & HOSTAPD_CFG_F_APME)
		hostapd_apme_init(cfg);
	else
		hostapd_log(HOSTAPD_LOG, "%s/%s: running without a Host AP\n",
		    cfg->c_apme_iface, cfg->c_iapp_iface);
d443 4
a446 2
	setproctitle("Host AP: %s, IAPP: %s",
	    cfg->c_apme_iface, cfg->c_iapp_iface);
d471 5
a475 3
		event_set(&cfg->c_apme_ev, cfg->c_apme_raw,
		    EV_READ | EV_PERSIST, hostapd_apme_input, cfg);
		event_add(&cfg->c_apme_ev, NULL);
d485 2
a486 2
	hostapd_log(HOSTAPD_LOG, "%s/%s: starting hostapd with pid %u\n",
	    cfg->c_apme_iface, cfg->c_iapp_iface, getpid());
a598 1

@


1.21
log
@move IAPP definitions to separate header file
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.20 2005/10/07 21:52:40 reyk Exp $	*/
d226 2
a227 1
	cfg->c_iapp_addr.sin_port = htons(IAPP_PORT);
d236 1
a236 1
	cfg->c_iapp_broadcast.sin_port = htons(IAPP_PORT);
d240 1
a240 1
	baddr.sin_port = htons(IAPP_PORT);
d249 3
a251 3
	 * sent via multicast to the group 224.0.1.178. Nevertheless,
	 * some implementations still use broadcasts for IAPP
	 * messages.
d273 4
a276 3
		cfg->c_iapp_multicast.sin_addr.s_addr =
		    inet_addr(IAPP_MCASTADDR);
		cfg->c_iapp_multicast.sin_port = htons(IAPP_PORT);
@


1.20
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.19 2005/09/13 09:22:42 reyk Exp $	*/
d50 1
@


1.19
log
@use memcmp instead of bcmp to compare tree nodes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.18 2005/09/09 13:21:13 reyk Exp $	*/
d341 1
a341 1
		while((entry = RB_MIN(hostapd_tree, &table->t_tree)) != NULL) {
@


1.18
log
@replace hasch tables with red-black trees used by the node tables.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.17 2005/08/17 13:18:33 reyk Exp $	*/
d591 1
a591 1
	return (bcmp(a->e_lladdr, b->e_lladdr, IEEE80211_ADDR_LEN));
@


1.17
log
@add newlines in hostapd_fatal() calls, fix some typos.
thanks to Brian Poole.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.16 2005/07/30 17:16:09 reyk Exp $	*/
a306 1
	int i;
d341 3
a343 7
		for (i = 0; i < HOSTAPD_TABLE_HASHSIZE; i++) {
			while ((entry =
			    TAILQ_FIRST(&table->t_head[i])) != NULL) {
				TAILQ_REMOVE(&table->t_head[i], entry,
				    e_entries);
				free(entry);
			}
a508 1
	int i;
d518 1
a518 2
	for (i = 0; i < HOSTAPD_TABLE_HASHSIZE; i++)
		TAILQ_INIT(&table->t_head[i]);
a540 1
	u_int hash;
d551 1
a551 2
	hash = HOSTAPD_TABLE_HASH(lladdr);
	TAILQ_INSERT_TAIL(&table->t_head[hash], entry, e_entries);
d559 1
a559 2
	u_int hash;
	struct hostapd_entry *entry;
d561 3
a563 5
	hash = HOSTAPD_TABLE_HASH(lladdr);
	TAILQ_FOREACH(entry, &table->t_head[hash], e_entries) {
		if (bcmp(lladdr, entry->e_lladdr, IEEE80211_ADDR_LEN) == 0)
			return (entry);
	}
d565 1
a565 1
	/* Masked entries can't be handled by the hash table */
d577 1
a577 4
	u_int hash;

	hash = HOSTAPD_TABLE_HASH(entry->e_lladdr);
	TAILQ_REMOVE(&table->t_head[hash], entry, e_entries);
d584 1
a584 2
		hash = HOSTAPD_TABLE_HASH(entry->e_lladdr);
		TAILQ_INSERT_TAIL(&table->t_head[hash], entry, e_entries);
d587 9
@


1.16
log
@flush print buffer on empty newlines
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.15 2005/07/04 18:48:05 deraadt Exp $	*/
d247 1
a247 1
	 * send via multicast to the group 224.0.1.178. Nevertheless,
d383 1
a383 1
				    "definition %s", optarg);
d467 1
a467 1
	/* Initialize the IAPP protcol handler */
@


1.15
log
@nicer text
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.14 2005/07/04 17:51:44 reyk Exp $	*/
d108 3
@


1.14
log
@remove command line options -i, -a and -b (iapp interface, hostap interface
and broadcast mode). please use the configuration file hostapd.conf(5)
instead, it is now mandatory to run hostapd with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.13 2005/07/04 17:13:39 reyk Exp $	*/
d414 1
a414 1
		hostapd_fatal("unspecified IAPP interface\n");
@


1.13
log
@print error messages to stderr instead of syslog on startup.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.12 2005/07/04 16:48:55 reyk Exp $	*/
d63 2
a64 2
	fprintf(stderr, "usage: %s [-bdv] [-a interface] [-D macro=value] "
	    "[-f file] [-i interface]\n", __progname);
d372 1
a372 1
	while ((ch = getopt(argc, argv, "a:bf:D:di:v")) != -1) {
a373 7
		case 'a':
			hostap_iface = optarg;
			cfg->c_flags |= HOSTAPD_CFG_F_APME;
			break;
		case 'b':
			cfg->c_flags |= HOSTAPD_CFG_F_BRDCAST;
			break;
a384 4
		case 'i':
			iapp_iface = optarg;
			cfg->c_flags |= HOSTAPD_CFG_F_IAPP;
			break;
d411 1
a411 1
		hostapd_fatal("invalid configuration\n");
@


1.12
log
@add 'random' action address and auth open request/response
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.11 2005/06/17 19:13:35 reyk Exp $	*/
d47 1
d363 1
d366 3
d390 1
a390 1
			cfg->c_debug++;
a416 5
	if (!cfg->c_debug) {
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);
		daemon(0, 0);
	}

d425 1
a425 1
		hostapd_usage();
d438 8
@


1.11
log
@first step to implement a proactive wireless monitoring system using
hostapd(8). it's a very simple but powerful approach using highly
flexible and stateless event and action rules for IEEE 802.11 traffic.
you can monitor a wireless network by watching frames with types and
addresses (with support for tables and masks) and you can trigger
actions like writing log messages, sending pcap/radiotap dumps to the
IAPP network, removing nodes from the hostap, resending received
frames and sending contructed 802.11 frames in reply to traffic
received from any rogue nodes.

it's based on some initial work from the c2k5 which has been tested
and improved during the last weeks. some missing documentation for
hostapd.conf(5) will be written as soon as possible.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.10 2005/05/21 19:18:51 msf Exp $	*/
d495 14
@


1.10
log
@hostapd doesn't really do much without root privileges, so check for that early

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.9 2005/04/14 10:59:56 reyk Exp $	*/
d57 1
d85 25
d287 1
a287 1
	
d303 1
d305 2
d336 18
d421 2
a422 1
	hostapd_parse_file(cfg);
d430 3
d495 93
@


1.9
log
@fix possible double free(), thans to Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.8 2005/04/13 21:15:36 reyk Exp $	*/
d369 3
@


1.8
log
@un-hack, use event_loopexit()

ok henning@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.7 2005/04/13 19:59:08 jmc Exp $	*/
d141 2
a142 1
		if ((fd = open(dev, flags)) != -1)
d144 1
d149 1
a149 2
	if (fd == -1) {
		free(dev);
a150 3
	}

	free(dev);
@


1.7
log
@sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.6 2005/04/13 19:26:05 henning Exp $	*/
a57 3
/* defined in event(3) to terminate the event loop */
extern volatile sig_atomic_t event_gotterm;

d262 5
d272 1
a272 2
		/* This will terminate libevent's main loop */
		event_gotterm = 1;
@


1.6
log
@only fflush STDERR when we actually log to STDERR, reyk ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.5 2005/04/13 19:16:08 henning Exp $	*/
d64 1
a64 1
	fprintf(stderr, "usage: %s [-dvb] [-a interface] [-D macro=value] "
@


1.5
log
@missing copyrights here as well
it is more than fine to re-use our code (please do!), but do not forget our
copyright!
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.4 2005/04/13 19:08:18 deraadt Exp $	*/
d65 1
a65 2
	    "[-f file] [-i interface]\n",
	    __progname);
d78 1
a78 1
	if (hostapd_cfg.c_debug)
d80 2
a81 1
	else
a82 1
	fflush(stderr);
d92 1
a92 1
	if (hostapd_cfg.c_debug)
d94 2
a95 1
	else
a96 1
	fflush(stderr);
@


1.4
log
@do not close descriptors before exit
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.3 2005/04/13 18:55:00 deraadt Exp $	*/
d5 1
@


1.3
log
@bzero of bss not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.2 2005/04/13 18:25:28 henning Exp $	*/
a99 1

a308 6

	if (!cfg->c_debug)
		closelog();

	/* Close all open file descriptors and sockets */
	closefrom(0);
d400 1
a400 1
	 */	
a440 1

@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: hostapd.c,v 1.1 2005/04/13 18:12:23 reyk Exp $	*/
a323 2

	bzero(cfg, sizeof(struct hostapd_config));
@


1.1
log
@add the initial version of the OpenBSD hostapd daemon

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d258 2
a259 3
			hostapd_fatal("failed to add multicast membership to %s:"
			    " %s\n",
			    IAPP_MCASTADDR, strerror(errno));
d267 1
a267 1
	case SIGALRM:	
d344 2
a345 2
				hostapd_fatal("could not parse macro definition %s",
				    optarg);
d451 1
a451 1
	return(EXIT_SUCCESS);
@

