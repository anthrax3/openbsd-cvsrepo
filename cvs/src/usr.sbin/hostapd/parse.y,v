head	1.53;
access;
symbols
	OPENBSD_6_2:1.53.0.2
	OPENBSD_6_2_BASE:1.53
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.51.0.2
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.49.0.6
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.45.0.6
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.43.0.14
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.12
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.10
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.8
	OPENBSD_5_0:1.43.0.6
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.4
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.41.0.4
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.38.0.4
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.2
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.29.0.4
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8;
locks; strict;
comment	@ * @;


1.53
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.52;
commitid	3AKCl24jEn0sIt6p;

1.52
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.51;
commitid	uzjOUwLRoN7KbcZI;

1.51
date	2016.06.21.21.35.24;	author benno;	state Exp;
branches;
next	1.50;
commitid	AL6SnrmnHkmPOpjv;

1.50
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	z3HrihslRYb4HqW9;

1.49
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	Uu5nFG3wCl0LACBb;

1.48
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.47;
commitid	3Z7yItGpFsmshk0c;

1.47
date	2014.11.14.03.20.36;	author doug;	state Exp;
branches;
next	1.46;
commitid	M08zdkdK3z1pxKwF;

1.46
date	2014.11.03.16.57.50;	author bluhm;	state Exp;
branches;
next	1.45;
commitid	z1D5eEr0kFR1H60Q;

1.45
date	2014.01.22.00.21.16;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2013.11.25.12.55.01;	author benno;	state Exp;
branches;
next	1.43;

1.43
date	2010.08.03.18.42.40;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.11.03.55.21;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2009.03.31.21.03.48;	author tobias;	state Exp;
branches;
next	1.40;

1.40
date	2009.02.15.22.27.13;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2008.10.17.13.02.55;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2008.02.27.15.36.42;	author mpf;	state Exp;
branches;
next	1.37;

1.37
date	2008.02.26.10.09.58;	author mpf;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.22.16.56.13;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.16.20.01.23;	author mpf;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.13.16.35.20;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.11.14.39.17;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.12.09.07.38;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.09.17.55.49;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.08.11.15.55;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.31.03.25.58;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.13.15.36.57;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2006.09.28.17.06.54;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.27.18.14.59;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.01.22.09.09;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.26.01.06.12;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.15.20.53.02;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.29.04.33.58;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.18.17.54.12;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.10.13.42.37;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.01.02.03.58;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.01.01.28.19;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.01.01.11.30;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.23.20.40.38;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.20.12.02.04;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.16.00.01.19;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.30.16.50.03;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.30.14.57.30;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.29.23.55.40;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.04.17.51.44;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.04.16.48.55;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.17.21.22.00;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.06.17.19.13.35;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.13.19.06.08;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.13.18.44.51;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.13.18.28.45;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.13.18.12.23;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@/*	$OpenBSD: parse.y,v 1.52 2017/01/05 12:42:18 krw Exp $	*/

/*
 * Copyright (c) 2004, 2005, 2006 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2002 - 2005 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_arp.h>
#include <net/if_llc.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

#include <net80211/ieee80211.h>
#include <net80211/ieee80211_radiotap.h>

#include <ctype.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <stdint.h>
#include <err.h>

#include "hostapd.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

extern struct hostapd_config hostapd_cfg;

typedef struct {
	union {
		struct {
			u_int8_t		lladdr[IEEE80211_ADDR_LEN];
			struct hostapd_table	*table;
			u_int32_t		flags;
		} reflladdr;
		struct {
			u_int16_t		alg;
			u_int16_t		transaction;
		} authalg;
		struct in_addr		in;
		char			*string;
		int64_t			number;
		u_int16_t		reason;
		enum hostapd_op		op;
		struct timeval		timeout;
	} v;
	int lineno;
} YYSTYPE;

struct hostapd_apme *apme;
struct hostapd_table *table;
struct hostapd_entry *entry;
struct hostapd_frame frame, *frame_ptr;
struct hostapd_ieee80211_frame *frame_ieee80211;

#define HOSTAPD_MATCH(_m, _not)	{					\
	frame.f_flags |= (_not) ?					\
	    HOSTAPD_FRAME_F_##_m##_N : HOSTAPD_FRAME_F_##_m;		\
}
#define HOSTAPD_MATCH_TABLE(_m, _not)	{				\
	frame.f_flags |= HOSTAPD_FRAME_F_##_m##_TABLE | ((_not) ?	\
	    HOSTAPD_FRAME_F_##_m##_N : HOSTAPD_FRAME_F_##_m);		\
}
#define HOSTAPD_MATCH_RADIOTAP(_x) {					\
	if (hostapd_cfg.c_apme_dlt == DLT_IEEE802_11 ||			\
	    (hostapd_cfg.c_apme_dlt == 0 &&				\
	    HOSTAPD_DLT == DLT_IEEE802_11)) {				\
		yyerror("option %s requires radiotap headers", #_x);	\
		YYERROR;						\
	}								\
	frame.f_radiotap |= HOSTAPD_RADIOTAP_F(RSSI);			\
	frame.f_flags |= HOSTAPD_FRAME_F_##_x;				\
}
#define HOSTAPD_IAPP_FLAG(_f, _not) {					\
	if (_not)							\
		hostapd_cfg.c_iapp.i_flags &= ~(HOSTAPD_IAPP_F_##_f);	\
	else								\
		hostapd_cfg.c_iapp.i_flags |= (HOSTAPD_IAPP_F_##_f);	\
}

%}

%token	MODE INTERFACE IAPP HOSTAP MULTICAST BROADCAST SET SEC USEC
%token	HANDLE TYPE SUBTYPE FROM TO BSSID WITH FRAME RADIOTAP NWID PASSIVE
%token	MANAGEMENT DATA PROBE BEACON ATIM ANY DS NO DIR RESEND RANDOM
%token	AUTH DEAUTH ASSOC DISASSOC REASSOC REQUEST RESPONSE PCAP RATE
%token	ERROR CONST TABLE NODE DELETE ADD LOG VERBOSE LIMIT QUICK SKIP
%token	REASON UNSPECIFIED EXPIRE LEAVE ASSOC TOOMANY NOT AUTHED ASSOCED
%token	RESERVED RSN REQUIRED INCONSISTENT IE INVALID MIC FAILURE OPEN
%token	ADDRESS PORT ON NOTIFY TTL INCLUDE ROUTE ROAMING RSSI TXRATE FREQ
%token	HOPPER DELAY NE LE GE ARROW
%token	<v.string>	STRING
%token	<v.number>	NUMBER
%type	<v.in>		ipv4addr
%type	<v.reflladdr>	refaddr, lladdr, randaddr, frmactionaddr, frmmatchaddr
%type	<v.reason>	frmreason_l
%type	<v.string>	table
%type	<v.string>	string
%type	<v.authalg>	authalg
%type	<v.op>		unaryop
%type	<v.number>	percent
%type	<v.number>	txrate
%type	<v.number>	freq
%type	<v.number>	not
%type	<v.timeout>	timeout

%%

/*
 * Configuration grammar
 */

grammar		: /* empty */
		| grammar '\n'
		| grammar include '\n'
		| grammar tabledef '\n'
		| grammar option '\n'
		| grammar event '\n'
		| grammar varset '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING
		{
			struct file *nfile;

			if ((nfile =
			    pushfile($2, 1)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}

option		: SET HOSTAP INTERFACE hostapifaces
		{
			if (!TAILQ_EMPTY(&hostapd_cfg.c_apmes))
				hostapd_cfg.c_flags |= HOSTAPD_CFG_F_APME;
		}
		| SET HOSTAP HOPPER INTERFACE hopperifaces
		| SET HOSTAP HOPPER DELAY timeout
		{
			bcopy(&$5, &hostapd_cfg.c_apme_hopdelay,
			    sizeof(struct timeval));
		}
		| SET HOSTAP MODE hostapmode
		| SET IAPP INTERFACE STRING passive
		{
			if (strlcpy(hostapd_cfg.c_iapp.i_iface, $4,
			    sizeof(hostapd_cfg.c_iapp.i_iface)) >=
			    sizeof(hostapd_cfg.c_iapp.i_iface)) {
				yyerror("invalid interface %s", $4);
				free($4);
				YYERROR;
			}

			hostapd_cfg.c_flags |= HOSTAPD_CFG_F_IAPP;

			hostapd_log(HOSTAPD_LOG_DEBUG,
			    "%s: IAPP interface added", $4);

			free($4);
		}
		| SET IAPP MODE iappmode
		| SET IAPP ADDRESS ROAMING TABLE table
		{
			if ((hostapd_cfg.c_iapp.i_addr_tbl =
			    hostapd_table_lookup(&hostapd_cfg, $6)) == NULL) {
				yyerror("undefined table <%s>", $6);
				free($6);
				YYERROR;
			}
			free($6);
		}
		| SET IAPP ROUTE ROAMING TABLE table
		{
			if ((hostapd_cfg.c_iapp.i_route_tbl =
			    hostapd_table_lookup(&hostapd_cfg, $6)) == NULL) {
				yyerror("undefined table <%s>", $6);
				free($6);
				YYERROR;
			}
			free($6);
		}
		| SET IAPP HANDLE SUBTYPE iappsubtypes
		;

iappmode	: MULTICAST iappmodeaddr iappmodeport iappmodettl
		{
			hostapd_cfg.c_flags &= ~HOSTAPD_CFG_F_BRDCAST;
		}
		| BROADCAST iappmodeport
		{
			hostapd_cfg.c_flags |= HOSTAPD_CFG_F_BRDCAST;
		}
		;

iappmodeaddr	: /* empty */
		| ADDRESS ipv4addr
		{
			bcopy(&$2, &hostapd_cfg.c_iapp.i_multicast.sin_addr,
			    sizeof(struct in_addr));
		}
		;

iappmodeport	: /* empty */
		| PORT NUMBER
		{
			if ($2 < 0 || $2 > UINT16_MAX) {
				yyerror("port out of range: %lld", $2);
				YYERROR;
			}
			hostapd_cfg.c_iapp.i_addr.sin_port = htons($2);
		}
		;

iappmodettl	: /* empty */
		| TTL NUMBER
		{
			if ($2 < 1 || $2 > UINT8_MAX) {
				yyerror("ttl out of range: %lld", $2);
				YYERROR;
			}
			hostapd_cfg.c_iapp.i_ttl = $2;
		}
		;

hostapmode	: RADIOTAP
		{
			hostapd_cfg.c_apme_dlt = DLT_IEEE802_11_RADIO;
		}
		| PCAP
		{
			hostapd_cfg.c_apme_dlt = DLT_IEEE802_11;
		}
		;

hostapifaces	: '{' optnl hostapifacelist optnl '}'
		| hostapiface
		;

hostapifacelist	: hostapiface
		| hostapifacelist comma hostapiface
		;

hostapiface	: STRING
		{
			if (hostapd_apme_add(&hostapd_cfg, $1) != 0) {
				yyerror("failed to add hostap interface");
				YYERROR;
			}
			free($1);
		}
		;

hopperifaces	: '{' optnl hopperifacelist optnl '}'
		| hopperiface
		;

hopperifacelist	: hopperiface
		| hopperifacelist comma hopperiface
		;

hopperiface	: STRING
		{
			if ((apme = hostapd_apme_addhopper(&hostapd_cfg,
			    $1)) == NULL) {
				yyerror("failed to add hopper %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

hostapmatch	: /* empty */
		| ON not STRING
		{
			if ((frame.f_apme =
			    hostapd_apme_lookup(&hostapd_cfg, $3)) == NULL) {
				yyerror("undefined hostap interface");
				free($3);
				YYERROR;
			}
			free($3);

			HOSTAPD_MATCH(APME, $2);
		}
		;

event		: HOSTAP HANDLE
		{
			bzero(&frame, sizeof(struct hostapd_frame));
			/* IEEE 802.11 frame to match */
			frame_ieee80211 = &frame.f_frame;
		} eventopt hostapmatch frmmatch {
			/* IEEE 802.11 raw frame to send as an action */
			frame_ieee80211 = &frame.f_action_data.a_frame;
		} action limit rate {
			if ((frame_ptr = calloc(1, sizeof(struct hostapd_frame)))
			    == NULL) {
				yyerror("calloc");
				YYERROR;
			}

			if (gettimeofday(&frame.f_last, NULL) == -1)
				hostapd_fatal("gettimeofday");
			timeradd(&frame.f_last, &frame.f_limit, &frame.f_then);

			bcopy(&frame, frame_ptr, sizeof(struct hostapd_frame));
			TAILQ_INSERT_TAIL(&hostapd_cfg.c_frames,
			    frame_ptr, f_entries);
		}
		;

iappsubtypes	: '{' optnl iappsubtypelist optnl '}'
		| iappsubtype
		;

iappsubtypelist	: iappsubtype
		| iappsubtypelist comma iappsubtype
		;

iappsubtype	: not ADD NOTIFY
		{
			HOSTAPD_IAPP_FLAG(ADD_NOTIFY, $1);
		}
		| not RADIOTAP
		{
			HOSTAPD_IAPP_FLAG(RADIOTAP, $1);
		}
		| not ROUTE ROAMING
		{
			HOSTAPD_IAPP_FLAG(ROAMING_ROUTE, $1);
		}
		| not ADDRESS ROAMING
		{
			HOSTAPD_IAPP_FLAG(ROAMING_ADDRESS, $1);
		}
		;

eventopt	: /* empty */
		{
			frame.f_flags |= HOSTAPD_FRAME_F_RET_OK;
		}
		| QUICK
		{
			frame.f_flags |= HOSTAPD_FRAME_F_RET_QUICK;
		}
		| SKIP
		{
			frame.f_flags |= HOSTAPD_FRAME_F_RET_SKIP;
		}
		;

action		: /* empty */
		{
			frame.f_action = HOSTAPD_ACTION_NONE;
		}
		| WITH LOG verbose
		{
			frame.f_action = HOSTAPD_ACTION_LOG;
		}
		| WITH FRAME frmaction
		{
			frame.f_action = HOSTAPD_ACTION_FRAME;
		}
		| WITH IAPP iapp
		| WITH NODE nodeopt frmactionaddr
		{
			if (($4.flags & HOSTAPD_ACTION_F_REF_M) == 0) {
				bcopy($4.lladdr, frame.f_action_data.a_lladdr,
				    IEEE80211_ADDR_LEN);
			} else
				frame.f_action_data.a_flags |= $4.flags;
		}
		| WITH RESEND
		{
			frame.f_action = HOSTAPD_ACTION_RESEND;
		}
		;

verbose		: /* empty */
		| VERBOSE
		{
			frame.f_action_flags |= HOSTAPD_ACTION_VERBOSE;
		}
		;

iapp		: TYPE RADIOTAP verbose
		{
			frame.f_action = HOSTAPD_ACTION_RADIOTAP;
		}
		;

nodeopt		: DELETE
		{
			frame.f_action = HOSTAPD_ACTION_DELNODE;
		}
		| ADD
		{
			frame.f_action = HOSTAPD_ACTION_ADDNODE;
		}
		;

frmmatch	: ANY
		| frm frmmatchtype frmmatchdir frmmatchfrom frmmatchto
			frmmatchbssid frmmatchrtap
		;

frm		: /* empty */
		| FRAME
		;

frmaction	: frmactiontype frmactiondir frmactionfrom frmactionto frmactionbssid
		;

limit		: /* empty */
		| LIMIT NUMBER SEC
		{
			if ($2 < 0 || $2 > LONG_MAX) {
				yyerror("limit out of range: %lld sec", $2);
				YYERROR;
			}
			frame.f_limit.tv_sec = $2;
		}
		| LIMIT NUMBER USEC
		{
			if ($2 < 0 || $2 > LONG_MAX) {
				yyerror("limit out of range: %lld usec", $2);
				YYERROR;
			}
			frame.f_limit.tv_usec = $2;
		}
		;

rate		: /* empty */
		| RATE NUMBER '/' NUMBER SEC
		{
			if (($2 < 1 || $2 > LONG_MAX) ||
			    ($4 < 1 || $4 > LONG_MAX)) {
				yyerror("rate out of range: %lld/%lld sec",
				    $2, $4);
				YYERROR;
			}

			if (!($2 && $4)) {
				yyerror("invalid rate");
				YYERROR;
			}

			frame.f_rate = $2;
			frame.f_rate_intval = $4;
		}
		;

frmmatchtype	: /* any */
		| TYPE ANY
		| TYPE not DATA
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_TYPE_DATA;
			HOSTAPD_MATCH(TYPE, $2);
		}
		| TYPE not MANAGEMENT frmmatchmgmt
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_TYPE_MGT;
			HOSTAPD_MATCH(TYPE, $2);
		}
		;

frmmatchmgmt	: /* any */
		| SUBTYPE ANY
		| SUBTYPE not frmsubtype
		{
			HOSTAPD_MATCH(SUBTYPE, $2);
		}
		;

frmsubtype	: PROBE REQUEST frmelems
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_PROBE_REQ;
		}
		| PROBE RESPONSE frmelems
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_PROBE_RESP;
		}
		| BEACON frmelems
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_BEACON;
		}
		| ATIM
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_ATIM;
		}
		| AUTH frmauth
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_AUTH;
		}
		| DEAUTH frmreason
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_DEAUTH;
		}
		| ASSOC REQUEST
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_ASSOC_REQ;
		}
		| DISASSOC frmreason
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_DISASSOC;
		}
		| ASSOC RESPONSE
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_ASSOC_RESP;
		}
		| REASSOC REQUEST
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_REASSOC_REQ;
		}
		| REASSOC RESPONSE
		{
			frame_ieee80211->i_fc[0] |=
			    IEEE80211_FC0_SUBTYPE_REASSOC_RESP;
		}
		;

frmelems	: /* empty */
		| frmelems_l
		;

frmelems_l	: frmelems_l frmelem
		| frmelem
		;

frmelem		: NWID not STRING
		;

frmauth		: /* empty */
		| authalg
		{
			if ((frame_ieee80211->i_data = malloc(6)) == NULL) {
				yyerror("failed to allocate auth");
				YYERROR;
			}
			((u_int16_t *)frame_ieee80211->i_data)[0] =
				$1.alg;
			((u_int16_t *)frame_ieee80211->i_data)[1] =
				$1.transaction;
			((u_int16_t *)frame_ieee80211->i_data)[0] = 0;
			frame_ieee80211->i_data_len = 6;
		}
		;

authalg		: OPEN REQUEST
		{
			$$.alg = htole16(IEEE80211_AUTH_ALG_OPEN);
			$$.transaction = htole16(IEEE80211_AUTH_OPEN_REQUEST);
		}
		| OPEN RESPONSE
		{
			$$.alg = htole16(IEEE80211_AUTH_ALG_OPEN);
			$$.transaction = htole16(IEEE80211_AUTH_OPEN_RESPONSE);
		}
		;

frmreason	: frmreason_l
		{
			if ($1 != 0) {
				if ((frame_ieee80211->i_data =
				    malloc(sizeof(u_int16_t))) == NULL) {
					yyerror("failed to allocate "
					    "reason code %u", $1);
					YYERROR;
				}
				*(u_int16_t *)frame_ieee80211->i_data =
				    htole16($1);
				frame_ieee80211->i_data_len = sizeof(u_int16_t);
			}
		}
		;

frmreason_l	: /* empty */
		{
			$$ = 0;
		}
		| REASON UNSPECIFIED
		{
			$$ = IEEE80211_REASON_UNSPECIFIED;
		}
		| REASON AUTH EXPIRE
		{
			$$ = IEEE80211_REASON_AUTH_EXPIRE;
		}
		| REASON AUTH LEAVE
		{
			$$ = IEEE80211_REASON_AUTH_LEAVE;
		}
		| REASON ASSOC EXPIRE
		{
			$$ = IEEE80211_REASON_ASSOC_EXPIRE;
		}
		| REASON ASSOC TOOMANY
		{
			$$ = IEEE80211_REASON_ASSOC_TOOMANY;
		}
		| REASON NOT AUTHED
		{
			$$ = IEEE80211_REASON_NOT_AUTHED;
		}
		| REASON NOT ASSOCED
		{
			$$ = IEEE80211_REASON_NOT_ASSOCED;
		}
		| REASON ASSOC LEAVE
		{
			$$ = IEEE80211_REASON_ASSOC_LEAVE;
		}
		| REASON ASSOC NOT AUTHED
		{
			$$ = IEEE80211_REASON_NOT_AUTHED;
		}
		| REASON RESERVED
		{
			$$ = 10;	/* XXX unknown */
		}
		| REASON RSN REQUIRED
		{
			$$ = IEEE80211_REASON_RSN_REQUIRED;
		}
		| REASON RSN INCONSISTENT
		{
			$$ = IEEE80211_REASON_RSN_INCONSISTENT;
		}
		| REASON IE INVALID
		{
			$$ = IEEE80211_REASON_IE_INVALID;
		}
		| REASON MIC FAILURE
		{
			$$ = IEEE80211_REASON_MIC_FAILURE;
		}
		;

frmmatchdir	: /* any */
		| DIR ANY
		| DIR not frmdir
		{
			HOSTAPD_MATCH(DIR, $2);
		}
		;

frmdir		: NO DS
		{
			frame_ieee80211->i_fc[1] |= IEEE80211_FC1_DIR_NODS;
		}
		| TO DS
		{
			frame_ieee80211->i_fc[1] |= IEEE80211_FC1_DIR_TODS;
		}
		| FROM DS
		{
			frame_ieee80211->i_fc[1] |= IEEE80211_FC1_DIR_FROMDS;
		}
		| DS TO DS
		{
			frame_ieee80211->i_fc[1] |= IEEE80211_FC1_DIR_DSTODS;
		}
		;

frmmatchfrom	: /* any */
		| FROM ANY
		| FROM not frmmatchaddr
		{
			if (($3.flags & HOSTAPD_ACTION_F_OPT_TABLE) == 0) {
				bcopy($3.lladdr, &frame_ieee80211->i_from,
				    IEEE80211_ADDR_LEN);
				HOSTAPD_MATCH(FROM, $2);
			} else {
				frame.f_from = $3.table;
				HOSTAPD_MATCH_TABLE(FROM, $2);
			}
		}
		;

frmmatchto	: /* any */
		| TO ANY
		| TO not frmmatchaddr
		{
			if (($3.flags & HOSTAPD_ACTION_F_OPT_TABLE) == 0) {
				bcopy($3.lladdr, &frame_ieee80211->i_to,
				    IEEE80211_ADDR_LEN);
				HOSTAPD_MATCH(TO, $2);
			} else {
				frame.f_to = $3.table;
				HOSTAPD_MATCH_TABLE(TO, $2);
			}
		}
		;

frmmatchbssid	: /* any */
		| BSSID ANY
		| BSSID not frmmatchaddr
		{
			if (($3.flags & HOSTAPD_ACTION_F_OPT_TABLE) == 0) {
				bcopy($3.lladdr, &frame_ieee80211->i_bssid,
				    IEEE80211_ADDR_LEN);
				HOSTAPD_MATCH(BSSID, $2);
			} else {
				frame.f_bssid = $3.table;
				HOSTAPD_MATCH_TABLE(BSSID, $2);
			}
		}
		;

frmmatchrtap	: /* empty */
		| frmmatchrtap_l
		;

frmmatchrtap_l	: frmmatchrtap_l frmmatchrtapopt
		| frmmatchrtapopt
		;

frmmatchrtapopt	: RSSI unaryop percent
		{
			if (($2 == HOSTAPD_OP_GT && $3 == 100) ||
			    ($2 == HOSTAPD_OP_LE && $3 == 100) ||
			    ($2 == HOSTAPD_OP_LT && $3 == 0) ||
			    ($2 == HOSTAPD_OP_GE && $3 == 0)) {
				yyerror("absurd unary comparison");
				YYERROR;
			}

			frame.f_rssi_op = $2;
			frame.f_rssi = $3;
			HOSTAPD_MATCH_RADIOTAP(RSSI);
		}
		| TXRATE unaryop txrate
		{
			frame.f_txrate_op = $2;
			frame.f_txrate = $3;
			HOSTAPD_MATCH_RADIOTAP(RATE);
		}
		| FREQ unaryop freq
		{
			frame.f_chan_op = $2;
			frame.f_chan = $3;
			HOSTAPD_MATCH_RADIOTAP(CHANNEL);
		}
		;

frmmatchaddr	: table
		{
			if (($$.table =
			    hostapd_table_lookup(&hostapd_cfg, $1)) == NULL) {
				yyerror("undefined table <%s>", $1);
				free($1);
				YYERROR;
			}
			$$.flags = HOSTAPD_ACTION_F_OPT_TABLE;
			free($1);
		}
		| lladdr
		{
			bcopy($1.lladdr, $$.lladdr, IEEE80211_ADDR_LEN);
			$$.flags = HOSTAPD_ACTION_F_OPT_LLADDR;
		}
		;

frmactiontype	: TYPE DATA
		{
			frame_ieee80211->i_fc[0] |= IEEE80211_FC0_TYPE_DATA;
		}
		| TYPE MANAGEMENT frmactionmgmt
		{
			frame_ieee80211->i_fc[0] |= IEEE80211_FC0_TYPE_MGT;
		}
		;

frmactionmgmt	: SUBTYPE frmsubtype
		;

frmactiondir	: /* empty */
		{
			frame.f_action_data.a_flags |=
			    HOSTAPD_ACTION_F_OPT_DIR_AUTO;
		}
		| DIR frmdir
		;

frmactionfrom	: FROM frmactionaddr
		{
			if (($2.flags & HOSTAPD_ACTION_F_REF_M) == 0) {
				bcopy($2.lladdr, frame_ieee80211->i_from,
				    IEEE80211_ADDR_LEN);
			} else
				frame.f_action_data.a_flags |=
				    ($2.flags << HOSTAPD_ACTION_F_REF_FROM_S);
		}
		;

frmactionto	: TO frmactionaddr
		{
			if (($2.flags & HOSTAPD_ACTION_F_REF_M) == 0) {
				bcopy($2.lladdr, frame_ieee80211->i_to,
				    IEEE80211_ADDR_LEN);
			} else
				frame.f_action_data.a_flags |=
				    ($2.flags << HOSTAPD_ACTION_F_REF_TO_S);
		}
		;

frmactionbssid	: BSSID frmactionaddr
		{
			if (($2.flags & HOSTAPD_ACTION_F_REF_M) == 0) {
				bcopy($2.lladdr, frame_ieee80211->i_bssid,
				    IEEE80211_ADDR_LEN);
			} else
				frame.f_action_data.a_flags |=
				    ($2.flags << HOSTAPD_ACTION_F_REF_BSSID_S);
		}
		;

frmactionaddr	: lladdr
		{
			bcopy($1.lladdr, $$.lladdr, IEEE80211_ADDR_LEN);
			$$.flags = $1.flags;
		}
		| randaddr
		{
			$$.flags = $1.flags;
		}
		| refaddr
		{
			$$.flags = $1.flags;
		}
		;

table		: '<' STRING '>' {
			if (strlen($2) >= HOSTAPD_TABLE_NAMELEN) {
				yyerror("table name %s too long, max %u",
				    $2, HOSTAPD_TABLE_NAMELEN - 1);
				free($2);
				YYERROR;
			}
			$$ = $2;
		}
		;

tabledef	: TABLE table {
			if ((table =
			    hostapd_table_add(&hostapd_cfg, $2)) == NULL) {
				yyerror("failed to add table: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		} tableopts {
			table = NULL;
		}
		;

tableopts	: /* empty */
		| tableopts_l
		;

tableopts_l	: tableopts_l tableopt
		| tableopt
		;

tableopt	: CONST	{
			if (table->t_flags & HOSTAPD_TABLE_F_CONST) {
				yyerror("option already specified");
				YYERROR;
			}
			table->t_flags |= HOSTAPD_TABLE_F_CONST;
		}
		| '{' optnl '}'
		| '{' optnl tableaddrlist optnl '}'
		;

string		: string STRING
		{
			if (asprintf(&$$, "%s %s", $1, $2) == -1)
				hostapd_fatal("string: asprintf");
			free($1);
			free($2);
		}
		| STRING
		;

varset		: STRING '=' string
		{
			char *s = $1;
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				hostapd_fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

refaddr		: '&' FROM
		{
			$$.flags |= HOSTAPD_ACTION_F_REF_FROM;
		}
		| '&' TO
		{
			$$.flags |= HOSTAPD_ACTION_F_REF_TO;
		}
		| '&' BSSID
		{
			$$.flags |= HOSTAPD_ACTION_F_REF_BSSID;
		}
		;

tableaddrlist	: tableaddrentry
		| tableaddrlist comma tableaddrentry
		;

tableaddrentry	: lladdr
		{
			if ((entry = hostapd_entry_add(table,
			    $1.lladdr)) == NULL) {
				yyerror("failed to add entry: %s",
				    etheraddr_string($1.lladdr));
				YYERROR;
			}
		} tableaddropt {
			entry = NULL;
		}
		;

tableaddropt	: /* empty */
		| assign ipv4addr ipv4netmask
		{
			entry->e_flags |= HOSTAPD_ENTRY_F_INADDR;
			entry->e_inaddr.in_af = AF_INET;
			bcopy(&$2, &entry->e_inaddr.in_v4,
			    sizeof(struct in_addr));
		}
		| mask lladdr
		{
			entry->e_flags |= HOSTAPD_ENTRY_F_MASK;
			bcopy($2.lladdr, entry->e_mask, IEEE80211_ADDR_LEN);

			/* Update entry position in the table */
			hostapd_entry_update(table, entry);
		}
		;

ipv4addr	: STRING
		{
			if (inet_net_pton(AF_INET, $1, &$$, sizeof($$)) == -1) {
				yyerror("invalid address: %s\n", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

ipv4netmask	: /* empty */
		{
			entry->e_inaddr.in_netmask = -1;
		}
		| '/' NUMBER
		{
			if ($2 < 0 || $2 > 32) {
				yyerror("netmask out of range: %lld", $2);
				YYERROR;
			}
			entry->e_inaddr.in_netmask = $2;
		}
		;

lladdr		: STRING
		{
			struct ether_addr *ea;

			if ((ea = ether_aton($1)) == NULL) {
				yyerror("invalid address: %s\n", $1);
				free($1);
				YYERROR;
			}
			free($1);

			bcopy(ea, $$.lladdr, IEEE80211_ADDR_LEN);
			$$.flags = HOSTAPD_ACTION_F_OPT_LLADDR;
		}
		;

randaddr	: RANDOM
		{
			$$.flags |= HOSTAPD_ACTION_F_REF_RANDOM;
		}
		;

passive		: /* empty */
		| PASSIVE
		{
			hostapd_cfg.c_flags |= HOSTAPD_CFG_F_IAPP_PASSIVE;
		}
		;

assign		: ARROW
		;

mask		: '&'
		;

comma		: /* emtpy */
		| ',' optnl
		;

optnl		: /* empty */
		| '\n'
		;

not		: /* empty */
		{
			$$ = 0;
		}
		| '!'
		{
			$$ = 1;
		}
		| NOT
		{
			$$ = 1;
		}
		;

unaryop		: /* any */
		{
			$$ = HOSTAPD_OP_EQ;
		}
		| '='
		{
			$$ = HOSTAPD_OP_EQ;
		}
		| '=='
		{
			$$ = HOSTAPD_OP_EQ;
		}
		| '!'
		{
			$$ = HOSTAPD_OP_NE;
		}
		| NE
		{
			$$ = HOSTAPD_OP_NE;
		}
		| LE
		{
			$$ = HOSTAPD_OP_LE;
		}
		| '<'
		{
			$$ = HOSTAPD_OP_LT;
		}
		| GE
		{
			$$ = HOSTAPD_OP_GE;
		}
		| '>'
		{
			$$ = HOSTAPD_OP_GT;
		}
		;

percent		: STRING
		{
			double val;
			char *cp;

			val = strtod($1, &cp);
			if (cp == NULL || strcmp(cp, "%") != 0 ||
			    val < 0 || val > 100) {
				yyerror("invalid percentage: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			$$ = val;
		}
		;

txrate		: STRING
		{
			double val;
			char *cp;

			val = strtod($1, &cp) * 2;
			if (cp == NULL || strcasecmp(cp, "mb") != 0 ||
			    val != (int)val) {
				yyerror("invalid rate: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			$$ = val;
		}
		;

freq		: STRING
		{
			double val;
			char *cp;

			val = strtod($1, &cp);
			if (cp != NULL) {
				if (strcasecmp(cp, "ghz") == 0) {
					$$ = val * 1000;
				} else if (strcasecmp(cp, "mhz") == 0) {
					$$ = val;
				} else
					cp = NULL;
			}
			if (cp == NULL) {
				yyerror("invalid frequency: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

timeout		: NUMBER
		{
			if ($1 < 1 || $1 > LONG_MAX) {
				yyerror("timeout out of range: %lld", $1);
				YYERROR;
			}
			$$.tv_sec = $1 / 1000;
			$$.tv_usec = ($1 % 1000) * 1000;
		}
		;
%%

/*
 * Parser and lexer
 */

struct keywords {
	char *k_name;
	int k_val;
};

int
kw_cmp(const void *a, const void *b)
{
	return strcmp(a, ((const struct keywords *)b)->k_name);
}

int
lookup(char *token)
{
	/* Keep this list sorted */
	static const struct keywords keywords[] = {
		{ "add",		ADD },
		{ "address",		ADDRESS },
		{ "any",		ANY },
		{ "assoc",		ASSOC },
		{ "assoced",		ASSOCED },
		{ "atim",		ATIM },
		{ "auth",		AUTH },
		{ "authed",		AUTHED },
		{ "beacon",		BEACON },
		{ "broadcast",		BROADCAST },
		{ "bssid",		BSSID },
		{ "const",		CONST },
		{ "data",		DATA },
		{ "deauth",		DEAUTH },
		{ "delay",		DELAY },
		{ "delete",		DELETE },
		{ "dir",		DIR },
		{ "disassoc",		DISASSOC },
		{ "ds",			DS },
		{ "expire",		EXPIRE },
		{ "failure",		FAILURE },
		{ "frame",		FRAME },
		{ "freq",		FREQ },
		{ "from",		FROM },
		{ "handle",		HANDLE },
		{ "hopper",		HOPPER },
		{ "hostap",		HOSTAP },
		{ "iapp",		IAPP },
		{ "ie",			IE },
		{ "include",		INCLUDE },
		{ "inconsistent",	INCONSISTENT },
		{ "interface",		INTERFACE },
		{ "invalid",		INVALID },
		{ "leave",		LEAVE },
		{ "limit",		LIMIT },
		{ "log",		LOG },
		{ "management",		MANAGEMENT },
		{ "mic",		MIC },
		{ "mode",		MODE },
		{ "multicast",		MULTICAST },
		{ "no",			NO },
		{ "node",		NODE },
		{ "not",		NOT },
		{ "notify",		NOTIFY },
		{ "nwid",		NWID },
		{ "on",			ON },
		{ "open",		OPEN },
		{ "passive",		PASSIVE },
		{ "pcap",		PCAP },
		{ "port",		PORT },
		{ "probe",		PROBE },
		{ "quick",		QUICK },
		{ "radiotap",		RADIOTAP },
		{ "random",		RANDOM },
		{ "rate",		RATE },
		{ "reason",		REASON },
		{ "reassoc",		REASSOC },
		{ "request",		REQUEST },
		{ "required",		REQUIRED },
		{ "resend",		RESEND },
		{ "reserved",		RESERVED },
		{ "response",		RESPONSE },
		{ "roaming",		ROAMING },
		{ "route",		ROUTE },
		{ "rsn",		RSN },
		{ "sec",		SEC },
		{ "set",		SET },
		{ "signal",		RSSI },
		{ "skip",		SKIP },
		{ "subtype",		SUBTYPE },
		{ "table",		TABLE },
		{ "to",			TO },
		{ "toomany",		TOOMANY },
		{ "ttl",		TTL },
		{ "txrate",		TXRATE },
		{ "type",		TYPE },
		{ "unspecified",	UNSPECIFIED },
		{ "usec",		USEC },
		{ "verbose",		VERBOSE },
		{ "with",		WITH }
	};
	const struct keywords *p;

	p = bsearch(token, keywords, sizeof(keywords) / sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	return (p == NULL ? STRING : p->k_val);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro \"%s\" not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			hostapd_fatal("yylex: strdup");
		return (STRING);
	case '-':
		next = lgetc(0);
		if (next == '>')
			return (ARROW);
		lungetc(next);
		break;
	case '!':
		next = lgetc(0);
		if (next == '=')
			return (NE);
		lungetc(next);
		break;		
	case '<':
		next = lgetc(0);
		if (next == '=')
			return (LE);
		lungetc(next);
		break;
	case '>':
		next = lgetc(0);
		if (next == '=')
			return (GE);
		lungetc(next);
		break;
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '/' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_' || c == '*') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				hostapd_fatal("yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);

	hostapd_log(HOSTAPD_LOG_DEBUG, "%s = \"%s\"", sym->nam, sym->val);

	return (0);
}

int
hostapd_parse_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		hostapd_fatal("cmdline_symset: malloc");

	(void)strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);

	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		warn("out of memory");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		warn("out of memory");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

int
hostapd_parse_file(struct hostapd_config *cfg)
{
	struct sym *sym, *next;
	int errors = 0;
	int ret;

	if ((file = pushfile(cfg->c_config, 1)) == NULL)
		hostapd_fatal("failed to open the main config file: %s\n",
		    cfg->c_config);
	topfile = file;

	/* Init tables and data structures */
	TAILQ_INIT(&cfg->c_apmes);
	TAILQ_INIT(&cfg->c_tables);
	TAILQ_INIT(&cfg->c_frames);
	cfg->c_iapp.i_multicast.sin_addr.s_addr = INADDR_ANY;
	cfg->c_iapp.i_flags = HOSTAPD_IAPP_F_DEFAULT;
	cfg->c_iapp.i_ttl = IP_DEFAULT_MULTICAST_TTL;
	cfg->c_apme_hopdelay.tv_sec = HOSTAPD_HOPPER_MDELAY / 1000;
	cfg->c_apme_hopdelay.tv_usec = (HOSTAPD_HOPPER_MDELAY % 1000) * 1000;

	ret = yyparse();
	errors = file->errors;
	popfile();

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if (!sym->used)
			hostapd_log(HOSTAPD_LOG_VERBOSE,
			    "warning: macro '%s' not used", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	return (errors ? EINVAL : ret);
}

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;

	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		hostapd_fatal("yyerror vasprintf");
	va_end(ap);
	fprintf(stderr, "%s:%d: %s\n", file->name, yylval.lineno, msg);
	fflush(stderr);
	free(msg);

	return (0);
}
@


1.52
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2016/06/21 21:35:24 benno Exp $	*/
d1777 1
a1777 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.51
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2015/08/20 22:39:29 deraadt Exp $	*/
d1608 4
a1611 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d1674 1
a1674 1
	TAILQ_FOREACH(sym, &symhead, entry)
d1679 1
@


1.50
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2015/01/16 06:40:17 deraadt Exp $	*/
d974 8
@


1.49
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2014/11/20 05:51:20 jsg Exp $	*/
d370 2
a371 2
			if ((frame_ptr = (struct hostapd_frame *)calloc(1,
				 sizeof(struct hostapd_frame))) == NULL) {
d650 1
a650 1
				if ((frame_ieee80211->i_data = (u_int16_t *)
d1614 1
a1614 1
	if ((sym = (struct sym *)calloc(1, sizeof(*sym))) == NULL)
d1648 1
a1648 1
	if ((sym = (char *)malloc(len)) == NULL)
@


1.48
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2014/11/14 03:20:36 doug Exp $	*/
a23 1
#include <sys/param.h>
d54 1
@


1.47
log
@Add gcc printf format attributes to yyerror() in parse.y files.
No yyerror() calls needed to be changed.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2014/11/03 16:57:50 bluhm Exp $	*/
d1489 3
@


1.46
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK benno@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2014/01/22 00:21:16 henning Exp $	*/
d73 3
a75 1
int		 yyerror(const char *, ...);
@


1.45
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2010/08/03 18:42:40 henning Exp $	*/
d1782 1
a1782 1
	char		*nfmt;
d1787 4
a1790 4
	if (asprintf(&nfmt, "%s:%d: %s\n", file->name, yylval.lineno,
	    fmt) == -1)
		hostapd_fatal("yyerror asprintf");
	vfprintf(stderr, nfmt, ap);
d1792 1
a1792 2
	va_end(ap);
	free(nfmt);
@


1.44
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d1681 2
a1682 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		warnx("%s: group/world readable/writeable", fname);
@


1.43
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2010/01/11 03:55:21 deraadt Exp $	*/
d1328 1
a1328 1
char	*parsebuf;
d1330 1
a1330 1
char	 pushback_buffer[MAXPUSHBACK];
d1423 2
a1424 2
	char	 buf[8096];
	char	*p, *val;
d1447 1
a1447 1
				*p++ = (char)c;
d1492 1
a1492 1
			*p++ = (char)c;
@


1.42
log
@lex <=, >=, !=, and -> into a single token for correctness and to reduce the
lookahead in the parser
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2009/03/31 21:03:48 tobias Exp $	*/
d1479 2
a1480 1
				else if (next == '\n')
d1482 1
a1482 1
				else
@


1.41
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2009/02/15 22:27:13 deraadt Exp $	*/
d155 1
a155 1
%token	HOPPER DELAY
d1082 1
a1082 1
assign		: '-' '>'
d1126 1
a1126 1
		| '!' '='
d1130 1
a1130 1
		| '<' '='
d1138 1
a1138 1
		| '>' '='
d1497 24
@


1.40
log
@no need for __packed, and it is even used wrong; from ragge
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2008/10/17 13:02:55 henning Exp $	*/
d1668 1
a1668 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d1670 5
@


1.39
log
@bring in the findeol() fix from pfctl. list of affected parsers by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2008/02/27 15:36:42 mpf Exp $	*/
d99 1
a99 1
		} reflladdr __packed;
@


1.38
log
@Unbreak parser by initializing topfile correctly.
I got fooled by patch(1). Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2008/02/26 10:09:58 mpf Exp $	*/
a1402 1
	pushback_index = 0;
d1406 4
a1409 1
		c = lgetc(0);
@


1.37
log
@Have popfile() also close the main config file,
but only do the final popfile call after yyparse() is done.
This also fixes config reload on SIGHUP for some daemons.

Spotted by otto@@. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2007/11/12 23:59:41 mpf Exp $	*/
d1714 1
a1742 1
	topfile = file;
@


1.36
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2007/10/22 16:56:13 pyr Exp $	*/
d67 1
a67 1
} *file;
d1354 3
a1356 2
			yyerror("reached end of file while parsing quoted string");
			if (popfile() == EOF)
d1374 1
a1374 1
		if (popfile() == EOF)
d1693 1
a1693 1
	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
d1695 7
a1701 8
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
d1742 1
@


1.35
log
@last one left behind.
all daemons synced.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2007/10/16 20:01:23 mpf Exp $	*/
a1370 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d1427 1
a1427 1
	while ((c = lgetc(0)) == ' ')
@


1.34
log
@Allow '=' to end a number in all lexers.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2007/10/16 06:06:49 deraadt Exp $	*/
d1674 2
a1675 1
	    (nfile->name = strdup(name)) == NULL)
d1677 1
d1679 1
@


1.33
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2007/10/13 16:35:20 deraadt Exp $	*/
d1505 1
a1505 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.32
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2007/10/11 14:39:17 deraadt Exp $	*/
d1482 1
a1482 1
				if (next == quotec)
d1484 2
@


1.31
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2007/09/12 09:07:38 reyk Exp $	*/
d56 1
d60 2
a61 5
extern struct hostapd_config hostapd_cfg;
static int errors = 0;

TAILQ_HEAD(filehead, file)	 filehead = TAILQ_HEAD_INITIALIZER(filehead);
struct file {
d63 1
a63 1

a64 1
	FILE			*stream;
d66 13
a78 2
};
static struct file *file;
a87 9

int		 yyerror(const char *, ...);
int		 yyparse(void);
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);
int		 yylex(void);
d90 2
a91 1
struct file	*hostapd_add_file(struct hostapd_config *, const char *);
d184 1
a184 1
		| grammar error '\n'		{ errors++; }
d192 1
a192 1
			    hostapd_add_file(&hostapd_cfg, $2)) == NULL) {
d1334 1
a1334 1
lgetc(int inquot)
d1336 1
a1336 2
	int	c, next;
	struct file *pfile;
d1352 7
a1358 2
	if (inquot) {
		c = getc(file->stream);
d1376 1
a1376 2
		if (ungetc(c, file->stream) == EOF)
			hostapd_fatal("lgetc: ungetc");
d1380 3
a1382 8
	while (c == EOF &&
	    (pfile = TAILQ_PREV(file, filehead, entry)) != NULL) {
		fclose(file->stream);
		free(file->name);
		TAILQ_REMOVE(&filehead, file, entry);
		free(file);

		file = pfile;
a1384 1

d1430 1
a1430 1
	int	 endc, c;
d1472 1
a1472 1
		endc = c;
d1474 1
a1474 1
			if ((c = lgetc(1)) == EOF)
a1475 4
			if (c == endc) {
				*p = '\0';
				break;
			}
d1479 10
d1646 20
d1667 1
a1667 1
hostapd_add_file(struct hostapd_config *cfg, const char *name)
d1669 1
a1669 1
	struct file *nfile = NULL;
d1671 12
a1682 1
	if ((nfile = calloc(1, sizeof(struct file))) == NULL)
a1683 12

	if ((nfile->name = strdup(name)) == NULL)
		goto err;

	if ((nfile->stream = fopen(name, "rb")) == NULL) {
		hostapd_log(HOSTAPD_LOG, "failed to open %s", name);
		goto err;
	}

	if (hostapd_check_file_secrecy(fileno(nfile->stream), name)) {
		hostapd_log(HOSTAPD_LOG, "invalid permissions for %s", name);
		goto err;
a1684 1

d1686 1
a1686 2
	TAILQ_INSERT_TAIL(&filehead, nfile, entry);

d1688 1
d1690 4
a1693 6
 err:
	if (nfile->name != NULL)
		free(nfile->name);
	if (nfile->stream != NULL)
		fclose(nfile->stream);
	free(nfile);
d1695 10
a1704 1
	return (NULL);
d1711 1
a1711 1
	struct file *nfile;
d1714 1
a1714 1
	if ((file = hostapd_add_file(cfg, cfg->c_config)) == NULL)
a1727 2
	errors = 0;

d1729 2
a1730 8

	for (file = TAILQ_FIRST(&filehead); file != NULL; file = nfile) {
		nfile = TAILQ_NEXT(file, entry);
		fclose(file->stream);
		free(file->name);
		TAILQ_REMOVE(&filehead, file, entry);
		free(file);
	}
d1752 2
a1753 2
	va_list ap;
	char *nfmt;
d1755 1
a1755 1
	errors = 1;
@


1.30
log
@Add NUMBER support for signed and unsigned 64bit numbers to the lexer
instead of passing numbers as STRINGs. Add careful range checks
whenever NUMBERs are used in the grammar.

From deraadt@@ (except the specific range checks)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2007/02/09 17:55:49 reyk Exp $	*/
d85 1
a85 1
int		 lgetc(void);
d1334 1
a1334 1
lgetc(void)
d1353 5
d1417 1
a1417 1
		c = lgetc();
d1438 1
a1438 1
	while ((c = lgetc()) == ' ')
d1443 1
a1443 1
		while ((c = lgetc()) != '\n' && c != EOF)
d1447 1
a1447 1
			if ((c = lgetc()) == EOF)
d1477 1
a1477 1
			if ((c = lgetc()) == EOF)
d1509 1
a1509 1
		} while ((c = lgetc()) != EOF && isdigit(c));
d1517 2
a1518 1
			yylval.v.number = strtonum(buf, LLONG_MIN, LLONG_MAX, &errstr);
d1520 2
a1521 1
				yyerror("\"%s\" invalid number: %s", buf, errstr);
d1548 1
a1548 1
		} while ((c = lgetc()) != EOF && (allowed_in_string(c)));
d1717 1
a1717 1
			    "warning: macro \"%s\" not used", sym->nam);
@


1.29
log
@unbreak the symset function
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2007/02/08 11:15:55 reyk Exp $	*/
d55 1
d106 1
a106 1
		long			val;
d157 1
a157 2
%token	<v.val>		VALUE
%type	<v.val>		number
d165 4
a168 4
%type	<v.val>		percent
%type	<v.val>		txrate
%type	<v.val>		freq
%type	<v.val>		not
d275 1
a275 1
		| PORT number
d277 4
d286 1
a286 1
		| TTL number
d288 4
d487 1
a487 1
		| LIMIT number SEC
d489 4
d495 1
a495 1
		| LIMIT number USEC
d497 4
d506 1
a506 1
		| RATE number '/' number SEC
d508 7
d1011 1
a1011 1
		| assign ipv4addr ipnetmask
d1039 1
a1039 1
ipnetmask	: /* empty */
d1043 1
a1043 1
		| '/' number
d1045 4
a1074 13
number		: STRING
		{
			const char *errstr;
			$$ = strtonum($1, 0, LONG_MAX, &errstr);
			if (errstr) {
				yyerror("invalid number: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

d1205 1
a1205 1
timeout		: number
d1207 4
d1492 34
@


1.28
log
@carefully check some return values and make lint happy. check for
truncation before feeding strings into the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2006/12/31 03:25:58 reyk Exp $	*/
d1562 1
a1562 2
	if (strlcpy(sym, s, len) >= len)
		hostapd_fatal("cmdline_symset: macro too long");
@


1.27
log
@add a channel hopper for wireless interfaces. the channel hopper will
jump to the next available channel after a configurable delay for the
specified list of wireless "hostap" interfaces, see the new "set
hostap hopper" commands in hostapd.conf(5).

with help by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2006/10/13 15:36:57 reyk Exp $	*/
d217 7
a223 2
			strlcpy(hostapd_cfg.c_iapp.i_iface, $4,
			    sizeof(hostapd_cfg.c_iapp.i_iface));
d366 2
a367 1
			gettimeofday(&frame.f_last, NULL);
d1349 2
a1350 1
		ungetc(c, file->stream);
d1562 2
a1563 1
	strlcpy(sym, s, len);
@


1.26
log
@check error condition of strtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2006/09/28 17:06:54 reyk Exp $	*/
d108 1
d113 1
d154 1
d169 1
d208 6
d311 20
d1184 7
d1227 1
d1238 1
d1631 2
@


1.25
log
@fix the configuration parser for event rules: correct handling of
multiple matches of the 'not' grammar rule and correct 'lladdr'
address matching.

figured out by Stephen Lewis (stephen at sock dot org dot uk), thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2006/06/27 18:14:59 reyk Exp $	*/
d1014 7
a1020 1
			$$ = strtonum($1, 0, LONG_MAX, NULL);
@


1.24
log
@add new event rules to match optional elements of radiotap headers:
signal percentage, transmit rate and channel frequency.

ok and hints by jsg@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2006/06/01 22:09:09 reyk Exp $	*/
a115 1
u_int negative;
d117 2
a118 2
#define HOSTAPD_MATCH(_m)	{					\
	frame.f_flags |= negative ?				\
d121 2
a122 2
#define HOSTAPD_MATCH_TABLE(_m)	{					\
	frame.f_flags |= HOSTAPD_FRAME_F_##_m##_TABLE | (negative ?	\
d135 2
a136 2
#define HOSTAPD_IAPP_FLAG(_f) {						\
	if (negative)							\
d165 1
d302 1
a302 1
		| ON STRING
d305 1
a305 1
			    hostapd_apme_lookup(&hostapd_cfg, $2)) == NULL) {
d307 1
a307 1
				free($2);
d310 1
a310 1
			free($2);
d312 1
a312 1
			HOSTAPD_MATCH(APME);
d350 1
a350 1
			HOSTAPD_IAPP_FLAG(ADD_NOTIFY);
d354 1
a354 1
			HOSTAPD_IAPP_FLAG(RADIOTAP);
d358 1
a358 1
			HOSTAPD_IAPP_FLAG(ROAMING_ROUTE);
d362 1
a362 1
			HOSTAPD_IAPP_FLAG(ROAMING_ADDRESS);
d472 1
a472 1
			HOSTAPD_MATCH(TYPE);
d478 1
a478 1
			HOSTAPD_MATCH(TYPE);
d486 1
a486 1
			HOSTAPD_MATCH(SUBTYPE);
d666 1
a666 1
		| DIR frmdir
d668 1
a668 1
			HOSTAPD_MATCH(DIR);
d691 2
a692 1
		| FROM frmmatchaddr
d694 2
a695 2
			if (($2.flags & HOSTAPD_ACTION_F_OPT_TABLE) == 0) {
				bcopy($2.lladdr, &frame_ieee80211->i_from,
d697 1
a697 1
				HOSTAPD_MATCH(FROM);
d699 2
a700 2
				frame.f_from = $2.table;
				HOSTAPD_MATCH_TABLE(FROM);
d706 2
a707 1
		| TO frmmatchaddr
d709 2
a710 2
			if (($2.flags & HOSTAPD_ACTION_F_OPT_TABLE) == 0) {
				bcopy($2.lladdr, &frame_ieee80211->i_to,
d712 1
a712 1
				HOSTAPD_MATCH(TO);
d714 2
a715 2
				frame.f_to = $2.table;
				HOSTAPD_MATCH_TABLE(TO);
d721 2
a722 1
		| BSSID frmmatchaddr
d724 2
a725 2
			if (($2.flags & HOSTAPD_ACTION_F_OPT_TABLE) == 0) {
				bcopy($2.lladdr, &frame_ieee80211->i_bssid,
d727 1
a727 1
				HOSTAPD_MATCH(BSSID);
d729 2
a730 2
				frame.f_bssid = $2.table;
				HOSTAPD_MATCH_TABLE(BSSID);
d771 1
a771 5
frmmatchaddr	: ANY
		{
			$$.flags = 0;
		}
		| not table
d774 3
a776 3
			    hostapd_table_lookup(&hostapd_cfg, $2)) == NULL) {
				yyerror("undefined table <%s>", $2);
				free($2);
d780 1
a780 1
			free($2);
d782 1
a782 1
		| not lladdr
d784 2
a785 2
			bcopy($2.lladdr, $$.lladdr, IEEE80211_ADDR_LEN);
			$$.flags = HOSTAPD_ACTION_F_OPT_TABLE;
d1042 1
a1042 1
			negative = 0;
d1046 1
a1046 1
			negative = 1;
d1050 1
a1050 1
			negative = 1;
@


1.23
log
@don't use the newline character in hostapd_log() calls
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2006/05/26 01:06:12 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
d43 3
d107 1
d126 10
d142 1
d152 1
a152 1
%token	ADDRESS PORT ON NOTIFY TTL INCLUDE ROUTE ROAMING
d162 4
d432 1
a432 1
			frmmatchbssid
d732 36
d1055 94
d1192 1
d1236 1
d1243 1
@


1.22
log
@\<char> is <char> except for \<newline> -- no exceptions.  much like how
other things work.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2006/05/15 20:53:02 reyk Exp $	*/
d194 1
a194 1
			    "%s: IAPP interface added\n", $4);
d1340 1
a1340 1
	hostapd_log(HOSTAPD_LOG_DEBUG, "%s = \"%s\"\n", sym->nam, sym->val);
d1393 1
a1393 1
		hostapd_log(HOSTAPD_LOG, "failed to open %s\n", name);
d1398 1
a1398 1
		hostapd_log(HOSTAPD_LOG, "invalid permissions for %s\n", name);
d1453 1
a1453 1
			    "warning: macro \"%s\" not used\n", sym->nam);
@


1.21
log
@initial implementation of "IP Roaming" in hostapd, see hostapd.conf(5).

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2005/12/29 04:33:58 reyk Exp $	*/
d1136 1
a1136 3
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, file->stream);
@


1.20
log
@add an 'include' rule to hostapd.conf(5); based on an older diff from
dhartmei@@ for the parser. this is useful if you have many hostapd
systems using the same configuration but individual local definitions
(like macros or table entries).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2005/12/18 17:54:12 reyk Exp $	*/
d137 1
a137 1
%token	ADDRESS PORT ON NOTIFY TTL INCLUDE
d199 20
d337 8
d1081 2
@


1.19
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2005/12/10 13:42:37 reyk Exp $	*/
d56 1
d58 9
a66 4
static FILE *fin = NULL;
static int lineno = 1;
static int errors = 0;
char *infile;
d77 11
a87 10
int	 yyerror(const char *, ...);
int	 yyparse(void);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(FILE *);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);
int	 symset(const char *, const char *, int);
char	*symget(const char *);
d137 1
a137 1
%token	ADDRESS PORT ON NOTIFY TTL
d156 1
d164 16
d1020 1
d1084 1
a1084 1
lgetc(FILE *f)
d1087 1
d1103 2
a1104 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d1108 1
a1108 1
			ungetc(next, f);
d1111 2
a1112 2
		yylval.lineno = lineno;
		lineno++;
d1117 1
a1117 1
			c = getc(f);
d1119 1
a1119 1
		ungetc(c, f);
d1123 11
d1163 1
a1163 1
		c = lgetc(fin);
d1165 1
a1165 1
			lineno++;
d1184 1
a1184 1
	while ((c = lgetc(fin)) == ' ')
d1187 1
a1187 1
	yylval.lineno = lineno;
d1189 1
a1189 1
		while ((c = lgetc(fin)) != '\n' && c != EOF)
d1193 1
a1193 1
			if ((c = lgetc(fin)) == EOF)
d1223 1
a1223 1
			if ((c = lgetc(fin)) == EOF)
d1230 1
a1230 1
				lineno++;
d1258 1
a1258 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
d1267 2
a1268 2
		yylval.lineno = lineno;
		lineno++;
d1353 36
d1393 1
d1396 3
a1398 9
	if ((fin = fopen(cfg->c_config, "r")) == NULL)
		hostapd_fatal("failed to open %s\n", cfg->c_config);

	infile = cfg->c_config;

	if (hostapd_check_file_secrecy(fileno(fin), cfg->c_config)) {
		fclose(fin);
		hostapd_fatal("invalid permissions for %s\n", cfg->c_config);
	}
a1407 1
	lineno = 1;
d1412 7
a1418 1
	fclose(fin);
d1446 2
a1447 1
	if (asprintf(&nfmt, "%s:%d: %s\n", infile, yylval.lineno, fmt) == -1)
@


1.18
log
@add an option to increase the multicast ttl which is currently limited
to 1 hop. by using a higher multicast ttl, you could use inter-network
multicast forwarding of hostapd messages (i.e. with mrouted(8) or
multicast-capable routing switches); "set iapp mode multicast ttl 2".
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2005/12/01 02:03:58 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.17
log
@add configuration option to enable/disable specified iapp subtype handling
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2005/12/01 01:28:19 reyk Exp $	*/
d130 1
a130 1
%token	ADDRESS PORT ON NOTIFY
d178 1
a178 1
iappmode	: MULTICAST iappmodeaddr iappmodeport
d203 7
d1036 1
d1338 1
@


1.16
log
@support netmasks in table entry ip address assignments
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2005/12/01 01:11:30 reyk Exp $	*/
a109 1
	negative = 0;							\
d114 6
a119 1
	negative = 0;							\
d130 1
a130 1
%token	ADDRESS PORT ON
d175 1
d270 18
d928 3
d1002 1
d1329 1
@


1.15
log
@move iapp configuration in a separate data structure
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2005/11/23 20:40:38 reyk Exp $	*/
d816 1
a816 1
		| assign ipv4addr
d818 4
a821 2
			entry->e_flags |= HOSTAPD_ENTRY_F_IPV4;
			bcopy(&$2, &entry->e_ipv4, sizeof(struct in_addr));
d841 10
@


1.14
log
@add optional interface rule for event rules
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2005/11/20 12:02:04 reyk Exp $	*/
d160 2
a161 2
			strlcpy(hostapd_cfg.c_iapp_iface, $4,
			    sizeof(hostapd_cfg.c_iapp_iface));
d186 1
a186 1
			bcopy(&$2, &hostapd_cfg.c_iapp_multicast.sin_addr,
d194 1
a194 1
			hostapd_cfg.c_iapp_addr.sin_port = htons($2);
d1289 1
a1289 1
	cfg->c_iapp_multicast.sin_addr.s_addr = INADDR_ANY;
@


1.13
log
@add support for multiple hostap (wireless) interfaces.

for example, if you run one hostapd with two ath(4) devices. you have
to specify "set hostap interface { ath0, ath1 }" in hostapd.conf(5).

man page bits by jmc@@, tested by others
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2005/11/16 00:01:19 reyk Exp $	*/
d126 1
a126 1
%token	ADDRESS PORT
d226 15
d246 1
a246 1
		} eventopt frmmatch {
d965 1
a1332 1

@


1.12
log
@add a configuration option for specifying a non-standard port and multicast
address for the IAPP messages. this is an initial approach to run multiple
hostapds on one machine, further work will be done later.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2005/09/30 16:50:03 reyk Exp $	*/
d152 1
a152 1
option		: SET HOSTAP INTERFACE STRING
d154 2
a155 10
			strlcpy(hostapd_cfg.c_apme_iface, $4,
			    sizeof(hostapd_cfg.c_apme_iface));

			hostapd_cfg.c_flags |= HOSTAPD_CFG_F_APME;

			hostapd_log(HOSTAPD_LOG_DEBUG,
			    "parse %s: Host AP interface %s\n",
			    hostapd_cfg.c_config, $4);

			free($4);
d165 2
a166 2
			hostapd_log(HOSTAPD_LOG_DEBUG, "parse %s: "
			    "IAPP interface %s\n", hostapd_cfg.c_config, $4);
d208 18
d1270 1
@


1.11
log
@implement a way to match IEEE 802.11 flooding. this will help to detect
known DoS attacks, like de-auth flooding against wireless networks.
an example is provided in the manual page.

"or could you just got for it?", deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2005/09/30 14:57:30 reyk Exp $	*/
d126 1
d181 1
a181 1
iappmode	: MULTICAST
d185 1
a185 1
		| BROADCAST
d191 15
d901 1
d943 1
d1262 1
@


1.10
log
@fix;5C the 'number' type, use a maximal value of LONG_MAX instead of 16.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2005/09/29 23:55:40 reyk Exp $	*/
d122 1
a122 1
%token	AUTH DEAUTH ASSOC DISASSOC REASSOC REQUEST RESPONSE PCAP
d208 1
a208 3
		} action limit {
			struct timeval t_now;

d215 2
a216 2
			gettimeofday(&t_now, NULL);
			timeradd(&t_now, &frame.f_limit, &frame.f_then);
d311 13
d930 1
@


1.9
log
@order alphabetically
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2005/07/04 17:51:44 reyk Exp $	*/
d814 1
a814 1
			$$ = strtonum($1, 0, 1 << sizeof(long), NULL);
@


1.8
log
@remove command line options -i, -a and -b (iapp interface, hostap interface
and broadcast mode). please use the configuration file hostapd.conf(5)
instead, it is now mandatory to run hostapd with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2005/07/04 16:48:55 reyk Exp $	*/
d909 1
a910 1
		{ "node",		NODE },
@


1.7
log
@add 'random' action address and auth open request/response
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2005/06/17 21:22:00 reyk Exp $	*/
d845 4
d1219 3
a1221 5
	if ((fin = fopen(cfg->c_config, "r")) == NULL) {
		hostapd_log(HOSTAPD_LOG, "unable to find %s, using defaults\n",
		    cfg->c_config);
		return (0);
	}
d1225 1
a1226 2
		fclose(fin);
		return (-1);
@


1.6
log
@support disassoc reason codes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2005/06/17 19:13:35 reyk Exp $	*/
d89 4
d121 1
a121 1
%token	MANAGEMENT DATA PROBE BEACON ATIM ANY DS NO DIR RESEND
d125 1
a125 1
%token	RESERVED RSN REQUIRED INCONSISTENT IE INVALID MIC FAILURE
d130 1
a130 1
%type	<v.reflladdr>	refaddr, lladdr, frmactionaddr, frmmatchaddr
d134 1
d290 7
a296 1
frmmatch	: frmmatchtype frmmatchdir frmmatchfrom frmmatchto frmmatchbssid
d357 1
a357 1
		| AUTH
d405 27
d658 5
a662 1
			$$.flags = 0;
d802 7
a808 1
			$$.flags = 0;
d908 1
d914 1
@


1.5
log
@first step to implement a proactive wireless monitoring system using
hostapd(8). it's a very simple but powerful approach using highly
flexible and stateless event and action rules for IEEE 802.11 traffic.
you can monitor a wireless network by watching frames with types and
addresses (with support for tables and masks) and you can trigger
actions like writing log messages, sending pcap/radiotap dumps to the
IAPP network, removing nodes from the hostap, resending received
frames and sending contructed 802.11 frames in reply to traffic
received from any rogue nodes.

it's based on some initial work from the c2k5 which has been tested
and improved during the last weeks. some missing documentation for
hostapd.conf(5) will be written as soon as possible.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2005/04/13 19:06:08 henning Exp $	*/
d127 1
a127 1
%type	<v.reason>	frmreason
a354 12

			if ($2 != 0) {
				if ((frame_ieee80211->i_data = (u_int16_t *)
				    malloc(sizeof(u_int16_t))) == NULL) {
					yyerror("failed to allocate deauth"
					    " reason code %u", $2);
					YYERROR;
				}
				*(u_int16_t *)frame_ieee80211->i_data =
				    htole16($2);
				frame_ieee80211->i_data_len = sizeof(u_int16_t);
			}
d361 1
a361 1
		| DISASSOC
d394 18
a411 1
frmreason	: /* empty */
@


1.4
log
@kill #if 0 crud
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2005/04/13 18:44:51 henning Exp $	*/
d84 9
a92 2
		char	*string;
		int	 val;
d97 16
d115 7
a121 2
%token	MODE INTERFACE IAPP HOSTAP MULTICAST BROADCAST SET
%token	ERROR
d124 5
d139 1
d141 1
d159 2
a160 1
		| SET IAPP INTERFACE STRING
d172 4
a175 1
		| SET IAPP MODE MULTICAST
d179 1
a179 1
		| SET IAPP MODE BROADCAST
d185 483
a667 1
string		: string STRING				{
d685 109
d816 64
a879 7
		{ "broadcast",	BROADCAST },
		{ "hostap",	HOSTAP },
		{ "iapp",	IAPP },
		{ "interface",	INTERFACE },
		{ "mode",	MODE },
		{ "multicast",	MULTICAST },
		{ "set",	SET },
d1095 1
a1095 1
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
d1129 1
a1129 1
	if ((sym = malloc(len)) == NULL)
d1173 4
d1198 1
a1198 1
	return (ret);
d1212 2
a1213 1
	hostapd_log(HOSTAPD_LOG, nfmt, ap);
@


1.3
log
@don't lose copyright on the way... reyk ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2005/04/13 18:28:45 henning Exp $	*/
a465 39

#if 0
int
yylex(void)
{
	char *p;
	int v;

	/* Locate next token */
	if (confptr == NULL) {
		confptr = confbuf;
	} else {
		for (p = confptr; *p && p < confbuf + conflen; p++)
			;
		*p++;
		if (!*p)
			return 0;
		confptr = p;
	}

	/* Numerical token? */
	if (isdigit(*confptr)) {
		for (p = confptr; *p; p++)
			if (*p == '.') /* IP-address, or bad input */
				goto is_string;
		v = (int)strtol(confptr, (char **)NULL, 10);
		yylval.val = v;
		return VALUE;
	}

 is_string:
	if ((v = lookup(confptr)) == STRING) {
		yylval.string = strdup(confptr);
		if (yylval.string == NULL)
			hostapd_fatal("yylex: strdup()");
	}
	return v;
}
#endif
@


1.2
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2005/04/13 18:12:23 reyk Exp $	*/
d5 4
@


1.1
log
@add the initial version of the OpenBSD hostapd daemon

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 5
a92 5
%token MODE INTERFACE IAPP HOSTAP MULTICAST BROADCAST SET
%token ERROR
%token <v.string> STRING
%token <v.val> VALUE
%type <v.string> string
d100 1
a100 1
grammar         : /* empty */
d102 1
a102 1
                | grammar option '\n'
d105 1
a105 1
		;	
d113 1
a113 1
			
d120 1
a120 1
                | SET IAPP INTERFACE STRING
d132 1
a132 1
                | SET IAPP MODE MULTICAST
d136 1
a136 1
                | SET IAPP MODE BROADCAST
@

