head	1.25;
access;
symbols
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.32
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.30
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.26
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.24
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.22
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.20
	OPENBSD_5_0:1.23.0.18
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.16
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.14
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.10
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.12
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.8
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.6
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13;
locks; strict;
comment	@ * @;


1.25
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.24;
commitid	LQHdRRMF0nq0fugE;

1.24
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2007.05.02.09.09.29;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.08.11.15.55;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.31.03.25.58;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.01.22.09.09;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.15.20.53.02;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.18.17.54.12;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.10.13.10.07;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.01.01.11.30;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.20.12.02.04;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.07.22.32.52;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.17.13.18.33;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.17.19.13.35;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.25.07.40.49;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.23.22.55.15;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.13.21.15.36;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.13.21.02.44;	author moritz;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.13.20.42.16;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.13.20.25.31;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.13.20.09.49;	author moritz;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.13.19.52.02;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.13.19.06.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.13.18.25.28;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.13.18.12.23;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@/*	$OpenBSD: privsep.c,v 1.24 2015/01/16 06:40:17 deraadt Exp $	*/

/*
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 1995, 1999 Theo de Raadt
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_arp.h>
#include <net/if_llc.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

#include <net80211/ieee80211.h>
#include <net80211/ieee80211_ioctl.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <netdb.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "hostapd.h"
#include "iapp.h"

enum hostapd_cmd_types {
	PRIV_APME_BSSID,	/* Get the Host AP's BSSID */
	PRIV_APME_GETNODE,	/* Get a node from the Host AP */
	PRIV_APME_ADDNODE,	/* Delete a node from the Host AP */
	PRIV_APME_DELNODE,	/* Delete a node from the Host AP */
	PRIV_APME_ADDROAMING,	/* Add a route to the kernel */
	PRIV_APME_DELROAMING,	/* Delete a route from the kernel */
	PRIV_LLC_SEND_XID	/* Send IEEE 802.3 LLC XID frame */
};

void	 hostapd_priv(int, short, void *);
struct hostapd_apme *hostapd_priv_getapme(int, struct hostapd_config *);
void	 hostapd_sig_relay(int, short, void *);
void	 hostapd_sig_chld(int, short, void *);
int	 hostapd_may_read(int, void *, size_t);
void	 hostapd_must_read(int, void *, size_t);
void	 hostapd_must_write(int, void *, size_t);

static int priv_fd = -1;
static volatile pid_t child_pid = -1;

/*
 * Main privsep functions
 */

void
hostapd_priv_init(struct hostapd_config *cfg)
{
	struct event ev_sigalrm;
	struct event ev_sigterm;
	struct event ev_sigint;
	struct event ev_sighup;
	struct event ev_sigchld;
	struct hostapd_iapp *iapp = &cfg->c_iapp;
	struct hostapd_apme *apme;
	int i, socks[2];
	struct passwd *pw;
	struct servent *se;

	for (i = 1; i < _NSIG; i++)
		signal(i, SIG_DFL);

	if ((se = getservbyname("iapp", "udp")) == NULL) {
		iapp->i_udp_port = IAPP_PORT;
	} else
		iapp->i_udp_port = se->s_port;

	if ((pw = getpwnam(HOSTAPD_USER)) == NULL)
		hostapd_fatal("failed to get user \"%s\"\n", HOSTAPD_USER);

	endservent();

	/* Create sockets */
	if (socketpair(AF_LOCAL, SOCK_STREAM, PF_UNSPEC, socks) == -1)
		hostapd_fatal("failed to get socket pair\n");

	if ((child_pid = fork()) < 0)
		hostapd_fatal("failed to fork child process\n");

	/*
	 * Unprivileged child process
	 */
	if (child_pid == 0) {
		cfg->c_flags &= ~HOSTAPD_CFG_F_PRIV;

		/*
		 * Change the child's root directory to the unprivileged
		 * user's home directory
		 */
		if (chroot(pw->pw_dir) == -1)
			hostapd_fatal("failed to change root directory\n");
		if (chdir("/") == -1)
			hostapd_fatal("failed to change directory\n");

		/*
		 * Drop privileges and clear the group access list
		 */
		if (setgroups(1, &pw->pw_gid) == -1 ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1 ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
			hostapd_fatal("can't drop privileges\n");

		(void)close(socks[0]);
		priv_fd = socks[1];
		return;
	}

	/*
	 * Privileged mother process
	 */
	cfg->c_flags |= HOSTAPD_CFG_F_PRIV;

	(void)event_init();

	/* Pass ALRM/TERM/INT/HUP through to child, and accept CHLD */
	signal_set(&ev_sigalrm, SIGALRM, hostapd_sig_relay, NULL);
	signal_set(&ev_sigterm, SIGTERM, hostapd_sig_relay, NULL);
	signal_set(&ev_sigint, SIGINT, hostapd_sig_relay, NULL);
	signal_set(&ev_sighup, SIGHUP, hostapd_sig_relay, NULL);
	signal_set(&ev_sigchld, SIGCHLD, hostapd_sig_chld, NULL);
	signal_add(&ev_sigalrm, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sighup, NULL);
	signal_add(&ev_sigchld, NULL);

	(void)close(socks[1]);

	if (cfg->c_flags & HOSTAPD_CFG_F_APME) {
		if ((cfg->c_apme_ctl = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
			hostapd_fatal("unable to open ioctl socket\n");
		TAILQ_FOREACH(apme, &cfg->c_apmes, a_entries)
			if (apme->a_chanavail != NULL)
				hostapd_apme_sethopper(apme, 0);
	}

	hostapd_roaming_init(cfg);

	/* Start a new event listener */
	event_set(&cfg->c_priv_ev, socks[0], EV_READ, hostapd_priv, cfg);
	if (event_add(&cfg->c_priv_ev, NULL) == -1)
		hostapd_fatal("failed to add priv event");

	/* Run privileged event loop */
	if (event_dispatch() == -1)
		hostapd_fatal("failed to dispatch priv hostapd");

	/* Executed after the event loop has been terminated */
	hostapd_cleanup(cfg);
	_exit(EXIT_SUCCESS);
}

struct hostapd_apme *
hostapd_priv_getapme(int fd, struct hostapd_config *cfg)
{
	struct hostapd_apme *apme;
	char name[IFNAMSIZ];
	int n;

	hostapd_must_read(fd, name, IFNAMSIZ);
	if ((cfg->c_flags & HOSTAPD_CFG_F_APME) == 0 ||
	    (apme = hostapd_apme_lookup(cfg, name)) == NULL) {
		n = ENXIO;
		hostapd_must_write(fd, &n, sizeof(int));
		return (NULL);
	}
	return (apme);
}

void
hostapd_priv(int fd, short sig, void *arg)
{
	struct hostapd_config *cfg = (struct hostapd_config *)arg;
	struct hostapd_apme *apme;
	struct hostapd_node node;
	struct ieee80211_bssid bssid;
	struct ieee80211_nodereq nr;
	struct ifreq ifr;
	unsigned long request;
	int ret = 0, cmd;

	/* Terminate the event if we got an invalid signal */
	if (sig != EV_READ)
		return;

	bzero(&node, sizeof(struct hostapd_node));
	bzero(&nr, sizeof(struct ieee80211_nodereq));

	/* Get privsep command */
	if (hostapd_may_read(fd, &cmd, sizeof(int)))
		return;

	switch (cmd) {
	case PRIV_APME_BSSID:
		hostapd_log(HOSTAPD_LOG_DEBUG,
		    "[priv]: msg PRIV_APME_BSSID received");

		if ((apme = hostapd_priv_getapme(fd, cfg)) == NULL)
			break;
		(void)strlcpy(bssid.i_name, apme->a_iface, sizeof(bssid.i_name));

		/* Try to get the APME's BSSID */
		if ((ret = ioctl(cfg->c_apme_ctl,
		    SIOCG80211BSSID, &bssid)) != 0)
			ret = errno;

		hostapd_must_write(fd, &ret, sizeof(int));
		if (ret == 0)
			hostapd_must_write(fd, &bssid.i_bssid,
			    IEEE80211_ADDR_LEN);
		break;

	case PRIV_APME_GETNODE:
		hostapd_log(HOSTAPD_LOG_DEBUG,
		    "[priv]: msg PRIV_APME_GETNODE received");

		hostapd_must_read(fd, &node, sizeof(struct hostapd_node));
		bcopy(node.ni_macaddr, nr.nr_macaddr, IEEE80211_ADDR_LEN);

		if ((apme = hostapd_priv_getapme(fd, cfg)) == NULL)
			break;
		(void)strlcpy(nr.nr_ifname, apme->a_iface, sizeof(ifr.ifr_name));

		/* Try to get a station from the APME */
		if ((ret = ioctl(cfg->c_apme_ctl,
		    SIOCG80211NODE, &nr)) != 0)
			ret = errno;

		hostapd_must_write(fd, &ret, sizeof(int));
		if (ret == 0) {
			node.ni_associd = nr.nr_associd;
			node.ni_flags = IEEE80211_NODEREQ_STATE(nr.nr_state);
			node.ni_rssi = nr.nr_rssi;
			node.ni_capinfo = nr.nr_capinfo;

			hostapd_must_write(fd, &node,
			    sizeof(struct hostapd_node));
		}
		break;

	case PRIV_APME_ADDNODE:
	case PRIV_APME_DELNODE:
		hostapd_log(HOSTAPD_LOG_DEBUG,
		    "[priv]: msg PRIV_APME_[ADD|DEL]NODE received");

		hostapd_must_read(fd, &node, sizeof(struct hostapd_node));
		bcopy(node.ni_macaddr, nr.nr_macaddr, IEEE80211_ADDR_LEN);

		if ((apme = hostapd_priv_getapme(fd, cfg)) == NULL)
			break;
		(void)strlcpy(nr.nr_ifname, apme->a_iface, sizeof(ifr.ifr_name));

		request = cmd == PRIV_APME_ADDNODE ?
		    SIOCS80211NODE : SIOCS80211DELNODE;

		/* Try to add/delete a station from the APME */
		if ((ret = ioctl(cfg->c_apme_ctl, request, &nr)) != 0)
			ret = errno;

		hostapd_must_write(fd, &ret, sizeof(int));
		break;

	case PRIV_LLC_SEND_XID:
		hostapd_log(HOSTAPD_LOG_DEBUG,
		    "[priv]: msg PRIV_LLC_SEND_XID received");

		hostapd_must_read(fd, &node, sizeof(struct hostapd_node));

		/* Send a LLC XID frame to reset possible switch ports */
		ret = hostapd_llc_send_xid(cfg, &node);
		hostapd_must_write(fd, &ret, sizeof(int));
		break;

	case PRIV_APME_ADDROAMING:
	case PRIV_APME_DELROAMING:
		hostapd_log(HOSTAPD_LOG_DEBUG,
		    "[priv]: msg PRIV_APME_[ADD|DEL]ROAMING received");

		hostapd_must_read(fd, &node, sizeof(struct hostapd_node));

		if ((apme = hostapd_priv_getapme(fd, cfg)) == NULL)
			break;
		ret = hostapd_roaming(apme, &node, cmd == PRIV_APME_ADDROAMING);
		hostapd_must_write(fd, &ret, sizeof(int));
		break;

	default:
		hostapd_fatal("[priv]: unknown command %d\n", cmd);
	}
	if (event_add(&cfg->c_priv_ev, NULL) == -1)
		hostapd_fatal("failed to schedult priv event");

	return;
}

/*
 * Unprivileged callers
 */
int
hostapd_priv_apme_getnode(struct hostapd_apme *apme, struct hostapd_node *node)
{
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;
	int ret, cmd;

	if (priv_fd < 0)
		hostapd_fatal("%s: called from privileged portion\n", __func__);

	if ((cfg->c_flags & HOSTAPD_CFG_F_APME) == 0)
		hostapd_fatal("%s: Host AP is not available\n", __func__);

	cmd = PRIV_APME_GETNODE;
	hostapd_must_write(priv_fd, &cmd, sizeof(int));
	hostapd_must_write(priv_fd, node, sizeof(struct hostapd_node));
	hostapd_must_write(priv_fd, &apme->a_iface, IFNAMSIZ);
	hostapd_must_read(priv_fd, &ret, sizeof(int));
	if (ret != 0)
		return (ret);

	hostapd_must_read(priv_fd, node, sizeof(struct hostapd_node));
	return (ret);
}

int
hostapd_priv_apme_setnode(struct hostapd_apme *apme, struct hostapd_node *node,
    int add)
{
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;
	struct hostapd_iapp *iapp = &cfg->c_iapp;
	int ret, cmd;

	if (priv_fd < 0)
		hostapd_fatal("%s: called from privileged portion\n", __func__);

	if ((cfg->c_flags & HOSTAPD_CFG_F_APME) == 0)
		hostapd_fatal("%s: Host AP is not available\n", __func__);

	if (add)
		cmd = PRIV_APME_ADDNODE;
	else
		cmd = PRIV_APME_DELNODE;
	hostapd_must_write(priv_fd, &cmd, sizeof(int));
	hostapd_must_write(priv_fd, node, sizeof(struct hostapd_node));
	hostapd_must_write(priv_fd, &apme->a_iface, IFNAMSIZ);

	hostapd_must_read(priv_fd, &ret, sizeof(int));
	if (ret == 0)
		hostapd_log(HOSTAPD_LOG_VERBOSE, "%s/%s: %s node %s",
		    apme->a_iface, iapp->i_iface,
		    add ? "added" : "removed",
		    etheraddr_string(node->ni_macaddr));

	return (ret);
}

void
hostapd_priv_apme_bssid(struct hostapd_apme *apme)
{
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;
	int ret, cmd;

	if (priv_fd < 0)
		hostapd_fatal("%s: called from privileged portion\n", __func__);

	if ((cfg->c_flags & HOSTAPD_CFG_F_APME) == 0)
		hostapd_fatal("%s: Host AP is not available\n", __func__);

	cmd = PRIV_APME_BSSID;
	hostapd_must_write(priv_fd, &cmd, sizeof(int));
	hostapd_must_write(priv_fd, &apme->a_iface, IFNAMSIZ);
	hostapd_must_read(priv_fd, &ret, sizeof(int));
	if (ret != 0)
		hostapd_fatal("failed to get Host AP's BSSID on"
		    " \"%s\": %s\n", apme->a_iface, strerror(errno));

	hostapd_must_read(priv_fd, &apme->a_bssid, IEEE80211_ADDR_LEN);
	cfg->c_stats.cn_tx_apme++;
}

int
hostapd_priv_llc_xid(struct hostapd_config *cfg, struct hostapd_node *node)
{
	int ret, cmd;

	if (priv_fd < 0)
		hostapd_fatal("%s: called from privileged portion\n", __func__);

	cmd = PRIV_LLC_SEND_XID;
	hostapd_must_write(priv_fd, &cmd, sizeof(int));
	hostapd_must_write(priv_fd, node, sizeof(struct hostapd_node));
	hostapd_must_read(priv_fd, &ret, sizeof(int));

	if (ret == 0)
		cfg->c_stats.cn_tx_llc++;
	return (ret);
}

int
hostapd_priv_roaming(struct hostapd_apme *apme, struct hostapd_node *node,
    int add)
{
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;
	int ret, cmd;

	if (priv_fd < 0)
		hostapd_fatal("%s: called from privileged portion\n", __func__);

	if ((cfg->c_flags & HOSTAPD_CFG_F_APME) == 0)
		hostapd_fatal("%s: Host AP is not available\n", __func__);

	if (add)
		cmd = PRIV_APME_ADDROAMING;
	else
		cmd = PRIV_APME_DELROAMING;
	hostapd_must_write(priv_fd, &cmd, sizeof(int));
	hostapd_must_write(priv_fd, node, sizeof(struct hostapd_node));
	hostapd_must_write(priv_fd, &apme->a_iface, IFNAMSIZ);

	hostapd_must_read(priv_fd, &ret, sizeof(int));

	return (ret);
}

/*
 * If priv parent gets a TERM or HUP, pass it through to child instead.
 */
/* ARGSUSED */
void
hostapd_sig_relay(int sig, short event, void *arg)
{
	int oerrno = errno;

	if (child_pid != -1)
		if (kill(child_pid, sig) == -1)
			hostapd_fatal("hostapd_sig_relay: kill(%d, %d)",
			    child_pid, sig);
	errno = oerrno;
}

/* ARGSUSED */
void
hostapd_sig_chld(int sig, short event, void *arg)
{
	/*
	 * If parent gets a SIGCHLD, it will exit.
	 */

	if (sig == SIGCHLD)
		(void)event_loopexit(NULL);
}

/*
 * privsep I/O functions
 */

/* Read all data or return 1 for error.  */
int
hostapd_may_read(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while ((ssize_t)n > pos) {
		res = read(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
			/* FALLTHROUGH */
		case 0:
			return (1);
		default:
			pos += res;
		}
	}
	return (0);
}

/*
 * Read data with the assertion that it all must come through, or
 * else abort the process.  Based on atomicio() from openssh.
 */
void
hostapd_must_read(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while ((ssize_t)n > pos) {
		res = read(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
			/* FALLTHROUGH */
		case 0:
			_exit(0);
			break;
		default:
			pos += res;
		}
	}
}

/*
 * Write data with the assertion that it all has to be written, or
 * else abort the process.  Based on atomicio() from openssh.
 */
void
hostapd_must_write(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while ((ssize_t)n > pos) {
		res = write(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
			/* FALLTHROUGH */
		case 0:
			_exit(0);
			break;
		default:
			pos += res;
		}
	}
}

@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.23 2007/05/02 09:09:29 claudio Exp $	*/
a171 2

	setproctitle("[priv]");
@


1.23
log
@Use event(3) provided signal functions -- this decouples the event
handling and so the signal handlers are safe to call whatever they want.
This solves PR5463. OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.22 2007/02/08 11:15:55 reyk Exp $	*/
a19 1
#include <sys/param.h>
d50 1
@


1.22
log
@carefully check some return values and make lint happy. check for
truncation before feeding strings into the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.21 2006/12/31 03:25:58 reyk Exp $	*/
d67 2
a68 2
void	 hostapd_sig_relay(int);
void	 hostapd_sig_chld(int);
d83 5
d150 10
a159 5
	signal(SIGALRM, hostapd_sig_relay);
	signal(SIGTERM, hostapd_sig_relay);
	signal(SIGINT, hostapd_sig_relay);
	signal(SIGHUP, hostapd_sig_relay);
	signal(SIGCHLD, hostapd_sig_chld);
d462 1
d464 1
a464 1
hostapd_sig_relay(int sig)
d475 1
d477 1
a477 1
hostapd_sig_chld(int sig)
a478 5
	struct timeval tv;

	tv.tv_sec = 0;
	tv.tv_usec = 0;

d484 1
a484 1
		(void)event_loopexit(&tv);
@


1.21
log
@add a channel hopper for wireless interfaces. the channel hopper will
jump to the next available channel after a configurable delay for the
specified list of wireless "hostap" interfaces, see the new "set
hostap hopper" commands in hostapd.conf(5).

with help by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.20 2006/06/01 22:09:09 reyk Exp $	*/
d132 1
a132 1
		close(socks[0]);
d142 1
a142 1
	event_init();
d151 1
a151 1
	close(socks[1]);
d167 2
a168 1
	event_add(&cfg->c_priv_ev, NULL);
d171 2
a172 1
	event_dispatch();
d226 1
a226 1
		strlcpy(bssid.i_name, apme->a_iface, sizeof(bssid.i_name));
d248 1
a248 1
		strlcpy(nr.nr_ifname, apme->a_iface, sizeof(ifr.ifr_name));
d277 1
a277 1
		strlcpy(nr.nr_ifname, apme->a_iface, sizeof(ifr.ifr_name));
d316 2
a317 1
	event_add(&cfg->c_priv_ev, NULL);
d458 3
a460 1
		kill(child_pid, sig);
d476 2
a477 3
	if (sig == SIGCHLD) {
		event_loopexit(&tv);
	}
@


1.20
log
@don't use the newline character in hostapd_log() calls
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.19 2006/05/15 20:53:02 reyk Exp $	*/
d84 1
d156 3
@


1.19
log
@initial implementation of "IP Roaming" in hostapd, see hostapd.conf(5).

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.18 2005/12/18 17:54:12 reyk Exp $	*/
d216 1
a216 1
		    "[priv]: msg PRIV_APME_BSSID received\n");
d235 1
a235 1
		    "[priv]: msg PRIV_APME_GETNODE received\n");
d264 1
a264 1
		    "[priv]: msg PRIV_APME_[ADD|DEL]NODE received\n");
d285 1
a285 1
		    "[priv]: msg PRIV_LLC_SEND_XID received\n");
d297 1
a297 1
		    "[priv]: msg PRIV_APME_[ADD|DEL]ROAMING received\n");
d366 1
a366 1
		hostapd_log(HOSTAPD_LOG_VERBOSE, "%s/%s: %s node %s\n",
@


1.18
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.17 2005/12/10 13:10:07 reyk Exp $	*/
d60 2
d157 2
d200 1
a200 1
	int ret, cmd;
d294 13
d413 26
@


1.17
log
@make lint more happy
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.16 2005/12/01 01:11:30 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.16
log
@move iapp configuration in a separate data structure
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.15 2005/11/20 12:02:04 reyk Exp $	*/
d446 1
d472 1
d475 1
d498 1
d501 1
@


1.15
log
@add support for multiple hostap (wireless) interfaces.

for example, if you run one hostapd with two ath(4) devices. you have
to specify "set hostap interface { ath0, ath1 }" in hostapd.conf(5).

man page bits by jmc@@, tested by others
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.14 2005/10/07 22:32:52 reyk Exp $	*/
d81 1
d90 1
a90 1
		cfg->c_iapp_udp_port = IAPP_PORT;
d92 1
a92 1
		cfg->c_iapp_udp_port = se->s_port;
d330 1
d349 3
a351 2
		hostapd_log(HOSTAPD_LOG, "%s: %s node %s\n",
		    apme->a_iface, add ? "added" : "removed",
@


1.14
log
@move IAPP definitions to separate header file
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.13 2005/08/17 13:18:33 reyk Exp $	*/
d64 1
d150 1
a150 1
		if ((cfg->c_apme = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
d168 17
d189 1
d213 3
a215 1
		strlcpy(bssid.i_name, cfg->c_apme_iface, sizeof(bssid.i_name));
d218 3
a220 6
		if (cfg->c_flags & HOSTAPD_CFG_F_APME) {
			if ((ret = ioctl(cfg->c_apme,
			    SIOCG80211BSSID, &bssid)) != 0)
				ret = errno;
		} else
			ret = ENXIO;
d235 3
a237 1
		strlcpy(nr.nr_ifname, cfg->c_apme_iface, sizeof(ifr.ifr_name));
d240 3
a242 6
		if (cfg->c_flags & HOSTAPD_CFG_F_APME) {
			if ((ret = ioctl(cfg->c_apme,
			    SIOCG80211NODE, &nr)) != 0)
				ret = errno;
		} else
			ret = ENXIO;
d264 3
a266 1
		strlcpy(nr.nr_ifname, cfg->c_apme_iface, sizeof(ifr.ifr_name));
d272 3
a274 5
		if (cfg->c_flags & HOSTAPD_CFG_F_APME) {
			if ((ret = ioctl(cfg->c_apme, request, &nr)) != 0)
				ret = errno;
		} else
			ret = ENXIO;
d293 2
d301 1
a301 1
hostapd_priv_apme_getnode(struct hostapd_config *cfg, struct hostapd_node *node)
d303 1
d315 1
d325 1
a325 1
hostapd_priv_apme_setnode(struct hostapd_config *cfg, struct hostapd_node *node,
d328 1
d343 2
d346 4
d355 1
a355 1
hostapd_priv_apme_bssid(struct hostapd_config *cfg)
d357 1
d368 1
a368 1

d372 1
a372 1
		    " \"%s\": %s\n", cfg->c_apme_iface, strerror(errno));
d374 1
a374 1
	hostapd_must_read(priv_fd, &cfg->c_apme_bssid, IEEE80211_ADDR_LEN);
@


1.13
log
@add newlines in hostapd_fatal() calls, fix some typos.
thanks to Brian Poole.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.12 2005/06/17 19:13:35 reyk Exp $	*/
d53 1
@


1.12
log
@first step to implement a proactive wireless monitoring system using
hostapd(8). it's a very simple but powerful approach using highly
flexible and stateless event and action rules for IEEE 802.11 traffic.
you can monitor a wireless network by watching frames with types and
addresses (with support for tables and masks) and you can trigger
actions like writing log messages, sending pcap/radiotap dumps to the
IAPP network, removing nodes from the hostap, resending received
frames and sending contructed 802.11 frames in reply to traffic
received from any rogue nodes.

it's based on some initial work from the c2k5 which has been tested
and improved during the last weeks. some missing documentation for
hostapd.conf(5) will be written as soon as possible.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.11 2005/05/25 07:40:49 reyk Exp $	*/
d98 1
a98 1
		hostapd_fatal("failed to get socket pair");
d101 1
a101 1
		hostapd_fatal("failed to fork child process");
d116 1
a116 1
			hostapd_fatal("failed to change directory");
d124 1
a124 1
			hostapd_fatal("can't drop privileges");
@


1.11
log
@add ifconfig -M option to replace wicontrol -L and -l for ap scanning
and node listing. wicontrol is not supported by net80211 drivers
anymore. further improvements will be done.

ok dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.10 2005/05/23 22:55:15 henning Exp $	*/
d57 1
d174 1
d238 1
d241 1
a241 1
		    "[priv]: msg PRIV_APME_DELNODE received\n");
d246 6
a251 1
		/* Try to delete a station from the APME */
d253 1
a253 2
			if ((ret = ioctl(cfg->c_apme,
			    SIOCS80211DELNODE, &nr)) != 0)
a298 1
	cfg->c_stats.cn_tx_apme++;
d303 2
a304 1
hostapd_priv_apme_delnode(struct hostapd_config *cfg, struct hostapd_node *node)
d314 4
a317 1
	cmd = PRIV_APME_DELNODE;
a320 2
	if (ret == 0)
		cfg->c_stats.cn_tx_apme++;
@


1.10
log
@-endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.9 2005/04/13 21:15:36 reyk Exp $	*/
d37 2
a38 3
#include <dev/ic/if_wi_ieee.h>
#include <dev/ic/if_wireg.h>
#include <dev/ic/if_wi_hostap.h>
d171 1
a171 1
	struct hostap_sta sta;
d180 1
a180 1
	bzero(&sta, sizeof(struct hostap_sta));
d212 1
a212 1
		bcopy(node.ni_macaddr, sta.addr, IEEE80211_ADDR_LEN);
d214 1
a214 2
		strlcpy(ifr.ifr_name, cfg->c_apme_iface, sizeof(ifr.ifr_name));
		ifr.ifr_data = (caddr_t)&sta;
d219 1
a219 1
			    SIOCHOSTAP_GET, &ifr)) != 0)
d226 4
a229 4
			node.ni_associd = sta.asid;
			node.ni_flags = sta.flags;
			node.ni_rssi = sta.sig_info;
			node.ni_capinfo = sta.capinfo;
d241 1
a241 1
		bcopy(node.ni_macaddr, sta.addr, IEEE80211_ADDR_LEN);
d246 1
a246 1
			    SIOCHOSTAP_DEL, &sta)) != 0)
d375 1
a375 1
	
@


1.9
log
@un-hack, use event_loopexit()

ok henning@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.8 2005/04/13 21:02:44 moritz Exp $	*/
a93 1
	endpwent();
@


1.8
log
@add some missing arguments, where format strings
expect them and a minor comment fix. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.7 2005/04/13 20:42:16 reyk Exp $	*/
a71 3
/* defined in event(3) to terminate the event loop */
extern volatile sig_atomic_t event_gotterm;

d377 5
d387 1
a387 2
		/* This will terminate libevent's main loop */
		event_gotterm = 1;
@


1.7
log
@set gid before uid
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.6 2005/04/13 20:25:31 deraadt Exp $	*/
d142 1
a142 1
	/* Pass ALR/TERM/HUP through to child, and accept CHLD */
d339 2
a340 3
		hostapd_fatal("%s: failed to get Host AP's BSSID on"
		    " \"%s\": %s\n",
		    cfg->c_apme_iface, strerror(errno));
@


1.6
log
@tighten code vertically
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.5 2005/04/13 20:09:49 moritz Exp $	*/
d126 2
a127 2
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1 ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
@


1.5
log
@really abort, when privdrop fails. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.4 2005/04/13 19:52:02 reyk Exp $	*/
d152 1
a152 1
		if ((cfg->c_apme = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
a153 1
		}
d207 1
a207 1
		if (ret == 0) {
a209 1
		}
a255 1

a266 1

a272 1

a278 1

a292 1

a297 1

a298 1

a315 1

a316 1

a343 1

a361 1

d366 1
a366 1
 * Signal handlers
a367 1

a372 5
	/*
	 * If priv parent gets a TERM or HUP, pass it through to child
	 * instead.
	 */

a374 1

@


1.4
log
@privsep i/o functions are based on atomicio, add copyright notice
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.3 2005/04/13 19:06:11 deraadt Exp $	*/
d125 3
a127 3
		if ((setgroups(1, &pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid)) == -1)
@


1.3
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.2 2005/04/13 18:25:28 henning Exp $	*/
d5 1
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.1 2005/04/13 18:12:23 reyk Exp $	*/
a166 1

d436 1
a436 1
/* 
d438 1
a438 1
 * else abort the process.  Based on atomicio() from openssh. 
@


1.1
log
@add the initial version of the OpenBSD hostapd daemon

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a133 1
	
d239 2
a240 1
			hostapd_must_write(fd, &node, sizeof(struct hostapd_node));
@

