head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.34
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.32
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.28
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.26
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.24
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.22
	OPENBSD_5_0:1.15.0.20
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.18
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.16
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.12
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.14
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.10
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.8
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.16
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Uu5nFG3wCl0LACBb;

1.15
date	2007.02.08.11.15.55;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.31.03.25.58;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.01.22.09.09;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.15.20.53.02;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.31.10.55.02;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.18.17.54.12;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.10.13.10.07;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.01.01.11.30;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.01.00.36.41;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.20.12.02.04;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.07.22.32.52;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.17.19.13.35;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.13.19.06.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.13.18.25.28;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.13.18.12.23;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: apme.c,v 1.15 2007/02/08 11:15:55 reyk Exp $	*/

/*
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* roundup isclr */
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_arp.h>
#include <net/if_llc.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

#include <net80211/ieee80211_radiotap.h>

#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "hostapd.h"
#include "iapp.h"

void	 hostapd_apme_frame(struct hostapd_apme *, u_int8_t *, u_int);
void	 hostapd_apme_hopper(int, short, void *);

int
hostapd_apme_add(struct hostapd_config *cfg, const char *name)
{
	struct hostapd_apme *apme;

	if (hostapd_apme_lookup(cfg, name) != NULL)
		return (EEXIST);
	if ((apme = (struct hostapd_apme *)
	    calloc(1, sizeof(struct hostapd_apme))) == NULL)
		return (ENOMEM);
	if (strlcpy(apme->a_iface, name, sizeof(apme->a_iface)) >=
	    sizeof(apme->a_iface)) {
		free(apme);
		return (EINVAL);
	}

	apme->a_cfg = cfg;
	apme->a_chanavail = NULL;

	TAILQ_INSERT_TAIL(&cfg->c_apmes, apme, a_entries);

	hostapd_log(HOSTAPD_LOG_DEBUG,
	    "%s: Host AP interface added", apme->a_iface);

	return (0);
}

int
hostapd_apme_deauth(struct hostapd_apme *apme)
{
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;
	struct hostapd_iapp *iapp = &cfg->c_iapp;
	u_int8_t buf[sizeof(struct ieee80211_frame) + sizeof(u_int16_t)];
	struct ieee80211_frame *wh;

	bzero(&buf, sizeof(buf));
	wh = (struct ieee80211_frame *)&buf[0];
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_DEAUTH;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	memset(&wh->i_addr1, 0xff, IEEE80211_ADDR_LEN);
	bcopy(apme->a_bssid, wh->i_addr2, IEEE80211_ADDR_LEN);
	bcopy(apme->a_bssid, wh->i_addr3, IEEE80211_ADDR_LEN);
	*(u_int16_t *)(wh + 1) = htole16(IEEE80211_REASON_AUTH_EXPIRE);

	if (write(apme->a_raw, buf, sizeof(buf)) == -1) {
		hostapd_log(HOSTAPD_LOG_VERBOSE,
		    "%s/%s: failed to deauthenticate all stations: %s",
		    iapp->i_iface, apme->a_iface,
		    strerror(errno));
		return (EIO);
	}

	hostapd_log(HOSTAPD_LOG_VERBOSE,
	    "%s/%s: deauthenticated all stations",
	    apme->a_iface, iapp->i_iface);

	return (0);
}

struct hostapd_apme *
hostapd_apme_lookup(struct hostapd_config *cfg, const char *name)
{
	struct hostapd_apme *apme;

	TAILQ_FOREACH(apme, &cfg->c_apmes, a_entries) {
		if (strcmp(name, apme->a_iface) == 0)
			return (apme);
	}

	return (NULL);
}

struct hostapd_apme *
hostapd_apme_addhopper(struct hostapd_config *cfg, const char *name)
{
	struct hostapd_apme *apme;

	if ((apme = hostapd_apme_lookup(cfg, name)) == NULL)
		return (NULL);
	if (apme->a_chanavail != NULL)
		return (NULL);
	apme->a_curchan = IEEE80211_CHAN_MAX;
	apme->a_maxchan = roundup(IEEE80211_CHAN_MAX, NBBY);
	if ((apme->a_chanavail = (u_int8_t *)
	    calloc(apme->a_maxchan, sizeof(u_int8_t))) == NULL)
		return (NULL);
	memset(apme->a_chanavail, 0xff,
	    apme->a_maxchan * sizeof(u_int8_t));
	(void)strlcpy(apme->a_chanreq.i_name, apme->a_iface, IFNAMSIZ);

	return (apme);
}

void
hostapd_apme_sethopper(struct hostapd_apme *apme, int now)
{
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;
	struct timeval tv;

	bzero(&tv, sizeof(tv));
	if (!now)
		bcopy(&cfg->c_apme_hopdelay, &tv, sizeof(tv));

	if (!evtimer_initialized(&apme->a_chanev))
		evtimer_set(&apme->a_chanev, hostapd_apme_hopper, apme);
	if (evtimer_add(&apme->a_chanev, &tv) == -1)
		hostapd_fatal("failed to add hopper event");
}

void
hostapd_apme_hopper(int fd, short sig, void *arg)
{
	struct hostapd_apme *apme = (struct hostapd_apme *)arg;
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;
	int ret;

	if (apme->a_curchan >= IEEE80211_CHAN_MAX)
		apme->a_curchan = 0;

	do {
		if (apme->a_curchan >= IEEE80211_CHAN_MAX)
			return;
		apme->a_curchan %= IEEE80211_CHAN_MAX;
		apme->a_curchan++;
	} while (isclr(apme->a_chanavail, apme->a_curchan));

	apme->a_chanreq.i_channel = apme->a_curchan;
	if ((ret = ioctl(cfg->c_apme_ctl, SIOCS80211CHANNEL,
	    &apme->a_chanreq)) != 0) {
		hostapd_apme_sethopper(apme, 1);
		return;
	}

	hostapd_log(HOSTAPD_LOG_DEBUG,
	    "[priv]: %s setting to channel %d",
	    apme->a_iface, apme->a_curchan);

	hostapd_apme_sethopper(apme, 0);
}

void
hostapd_apme_term(struct hostapd_apme *apme)
{
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;

	/* Remove the channel hopper, if active */
	if (apme->a_chanavail != NULL) {
		(void)event_del(&apme->a_chanev);
		free(apme->a_chanavail);
		apme->a_chanavail = NULL;
	}

	/* Kick a specified Host AP interface */
	(void)event_del(&apme->a_ev);
	if (close(apme->a_raw))
		hostapd_fatal("failed to close: %s\n",
		    strerror(errno));

	TAILQ_REMOVE(&cfg->c_apmes, apme, a_entries);

	/* Remove all dynamic roaming addresses */
	if (cfg->c_flags & HOSTAPD_CFG_F_PRIV)
		hostapd_roaming_term(apme);

	hostapd_log(HOSTAPD_LOG_DEBUG,
	    "%s: Host AP interface removed", apme->a_iface);

	free(apme);
}

void
hostapd_apme_input(int fd, short sig, void *arg)
{
	struct hostapd_apme *apme = (struct hostapd_apme *)arg;
	u_int8_t buf[IAPP_MAXSIZE], *bp, *ep;
	struct bpf_hdr *bph;
	ssize_t len;

	/* Ignore invalid signals */
	if (sig != EV_READ)
		return;

	bzero(&buf, sizeof(buf));

	if ((len = read(fd, buf, sizeof(buf))) <
	    (ssize_t)sizeof(struct ieee80211_frame))
		return;

	/*
	 * Loop through each frame.
	 */

	bp = (u_int8_t *)&buf;
	ep = bp + len;

	while (bp < ep) {
		register u_int caplen, hdrlen;

		bph = (struct bpf_hdr *)bp;
		caplen = bph->bh_caplen;
		hdrlen = bph->bh_hdrlen;

		/* Process frame */
		hostapd_apme_frame(apme, bp + hdrlen, caplen);

		bp += BPF_WORDALIGN(caplen + hdrlen);
	}
}

int
hostapd_apme_output(struct hostapd_apme *apme,
    struct hostapd_ieee80211_frame *frame)
{
	struct iovec iov[2];
	int iovcnt;
	struct ieee80211_frame wh;

	bzero(&wh, sizeof(wh));

	switch (frame->i_fc[1] & IEEE80211_FC1_DIR_MASK) {
	case IEEE80211_FC1_DIR_NODS:
		bcopy(frame->i_from, wh.i_addr2, IEEE80211_ADDR_LEN);
		bcopy(frame->i_to, wh.i_addr1, IEEE80211_ADDR_LEN);
		bcopy(frame->i_bssid, wh.i_addr3, IEEE80211_ADDR_LEN);
		break;
	case IEEE80211_FC1_DIR_TODS:
		bcopy(frame->i_from, wh.i_addr2, IEEE80211_ADDR_LEN);
		bcopy(frame->i_to, wh.i_addr3, IEEE80211_ADDR_LEN);
		bcopy(frame->i_bssid, wh.i_addr1, IEEE80211_ADDR_LEN);
		break;
	case IEEE80211_FC1_DIR_FROMDS:
		bcopy(frame->i_from, wh.i_addr3, IEEE80211_ADDR_LEN);
		bcopy(frame->i_to, wh.i_addr1, IEEE80211_ADDR_LEN);
		bcopy(frame->i_bssid, wh.i_addr2, IEEE80211_ADDR_LEN);
		break;
	default:
	case IEEE80211_FC1_DIR_DSTODS:
		return (EINVAL);
	}

	wh.i_fc[0] = IEEE80211_FC0_VERSION_0 | frame->i_fc[0];
	wh.i_fc[1] = frame->i_fc[1];
	bcopy(frame->i_dur, wh.i_dur, sizeof(wh.i_dur));
	bcopy(frame->i_seq, wh.i_seq, sizeof(wh.i_seq));

	iovcnt = 1;
	iov[0].iov_base = &wh;
	iov[0].iov_len = sizeof(struct ieee80211_frame);

	if (frame->i_data != NULL && frame->i_data_len > 0) {
		iovcnt = 2;
		iov[1].iov_base = frame->i_data;
		iov[1].iov_len = frame->i_data_len;
	}

	if (writev(apme->a_raw, iov, iovcnt) == -1)
		return (errno);

	return (0);
}

int
hostapd_apme_offset(struct hostapd_apme *apme,
    u_int8_t *buf, const u_int len)
{
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;
	struct ieee80211_radiotap_header *rh;
	u_int rh_len;

	if (cfg->c_apme_dlt == DLT_IEEE802_11)
		return (0);
	else if (cfg->c_apme_dlt != DLT_IEEE802_11_RADIO)
		return (-1);

	if (len < sizeof(struct ieee80211_radiotap_header))
		return (-1);

	rh = (struct ieee80211_radiotap_header*)buf;
	rh_len = letoh16(rh->it_len);

	if (rh->it_version != 0)
		return (-1);
	if (len <= rh_len)
		return (-1);

	return ((int)rh_len);
}

void
hostapd_apme_frame(struct hostapd_apme *apme, u_int8_t *buf, u_int len)
{
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;
	struct hostapd_iapp *iapp = &cfg->c_iapp;
	struct hostapd_apme *other_apme;
	struct hostapd_node node;
	struct ieee80211_frame *wh;
	int offset;

	if ((offset = hostapd_apme_offset(apme, buf, len)) < 0)
		return;
	wh = (struct ieee80211_frame *)(buf + offset);

	/* Ignore short frames or fragments */
	if (len < sizeof(struct ieee80211_frame))
		return;

	/* Handle received frames */
	if ((hostapd_handle_input(apme, buf, len) ==
	    (HOSTAPD_FRAME_F_RET_SKIP >> HOSTAPD_FRAME_F_RET_S)) ||
	    cfg->c_flags & HOSTAPD_CFG_F_IAPP_PASSIVE)
		return;

	/*
	 * Only accept local association response frames, ...
	 */
	if (!((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) ==
	    IEEE80211_FC1_DIR_NODS &&
	    (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_MGT &&
	    (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) ==
	    IEEE80211_FC0_SUBTYPE_ASSOC_RESP))
		return;

	/*
	 * ...sent by the Host AP (addr2) to our BSSID (addr3)
	 */
	if (bcmp(wh->i_addr2, apme->a_bssid, IEEE80211_ADDR_LEN) != 0 ||
	    bcmp(wh->i_addr3, apme->a_bssid, IEEE80211_ADDR_LEN) != 0)
		return;

	cfg->c_stats.cn_rx_apme++;

	/*
	 * Double-check if the station got associated to our Host AP
	 */
	bcopy(wh->i_addr1, node.ni_macaddr, IEEE80211_ADDR_LEN);
	if (hostapd_priv_apme_getnode(apme, &node) != 0) {
		hostapd_log(HOSTAPD_LOG_DEBUG,
		    "%s: invalid association from %s on the Host AP",
		    apme->a_iface, etheraddr_string(wh->i_addr1));
		return;
	}
	cfg->c_stats.cn_tx_apme++;

	/*
	 * Delete node on other attached Host APs
	 */
	TAILQ_FOREACH(other_apme, &cfg->c_apmes, a_entries) {
		if (apme == other_apme)
			continue;
		if (iapp->i_flags & HOSTAPD_IAPP_F_ROAMING)
			(void)hostapd_roaming_del(other_apme, &node);
		if (hostapd_apme_delnode(other_apme, &node) == 0)
			cfg->c_stats.cn_tx_apme++;
	}

	if (iapp->i_flags & HOSTAPD_IAPP_F_ROAMING)
		(void)hostapd_roaming_add(apme, &node);

	(void)hostapd_iapp_add_notify(apme, &node);
}

void
hostapd_apme_init(struct hostapd_apme *apme)
{
	struct hostapd_config *cfg = (struct hostapd_config *)apme->a_cfg;
	u_int i, dlt;
	struct ifreq ifr;

	apme->a_raw = hostapd_bpf_open(O_RDWR);

	apme->a_rawlen = IAPP_MAXSIZE;
	if (ioctl(apme->a_raw, BIOCSBLEN, &apme->a_rawlen) == -1)
		hostapd_fatal("failed to set BPF buffer len \"%s\": %s\n",
		    apme->a_iface, strerror(errno));

	i = 1;
	if (ioctl(apme->a_raw, BIOCIMMEDIATE, &i) == -1)
		hostapd_fatal("failed to set BPF immediate mode on \"%s\": "
		    "%s\n", apme->a_iface, strerror(errno));

	bzero(&ifr, sizeof(struct ifreq));
	(void)strlcpy(ifr.ifr_name, apme->a_iface, sizeof(ifr.ifr_name));

	/* This may fail, ignore it */
	(void)ioctl(apme->a_raw, BIOCPROMISC, NULL);

	/* Associate the wireless network interface to the BPF descriptor */
	if (ioctl(apme->a_raw, BIOCSETIF, &ifr) == -1)
		hostapd_fatal("failed to set BPF interface \"%s\": %s\n",
		    apme->a_iface, strerror(errno));

	dlt = cfg->c_apme_dlt;
	if (ioctl(apme->a_raw, BIOCSDLT, &dlt) == -1)
		hostapd_fatal("failed to set BPF link type on \"%s\": %s\n",
		    apme->a_iface, strerror(errno));

	/* Lock the BPF descriptor, no further configuration */
	if (ioctl(apme->a_raw, BIOCLOCK, NULL) == -1)
		hostapd_fatal("failed to lock BPF interface on \"%s\": %s\n",
		    apme->a_iface, strerror(errno));
}

int
hostapd_apme_addnode(struct hostapd_apme *apme, struct hostapd_node *node)
{
	return (hostapd_priv_apme_setnode(apme, node, 1));
}

int
hostapd_apme_delnode(struct hostapd_apme *apme, struct hostapd_node *node)
{
	return (hostapd_priv_apme_setnode(apme, node, 0));
}
@


1.15
log
@carefully check some return values and make lint happy. check for
truncation before feeding strings into the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.14 2006/12/31 03:25:58 reyk Exp $	*/
d19 1
a19 1
#include <sys/param.h>
a20 1
#include <sys/types.h>
d43 1
@


1.14
log
@add a channel hopper for wireless interfaces. the channel hopper will
jump to the next available channel after a configurable delay for the
specified list of wireless "hostap" interfaces, see the new "set
hostap hopper" commands in hostapd.conf(5).

with help by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.13 2006/06/01 22:09:09 reyk Exp $	*/
d61 5
a66 1
	strlcpy(apme->a_iface, name, sizeof(apme->a_iface));
d140 1
a140 1
	strlcpy(apme->a_chanreq.i_name, apme->a_iface, IFNAMSIZ);
d157 2
a158 1
	evtimer_add(&apme->a_chanev, &tv);
d199 1
a199 1
		event_del(&apme->a_chanev);
d205 4
a208 2
	event_del(&apme->a_ev);
	close(apme->a_raw);
d403 1
a403 1
			hostapd_roaming_del(other_apme, &node);
d409 1
a409 3
		hostapd_roaming_add(apme, &node);

	hostapd_iapp_add_notify(apme, &node);
d411 1
d434 1
a434 1
	strlcpy(ifr.ifr_name, apme->a_iface, sizeof(ifr.ifr_name));
d437 1
a437 1
	ioctl(apme->a_raw, BIOCPROMISC, NULL);
@


1.13
log
@don't use the newline character in hostapd_log() calls
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.12 2006/05/15 20:53:02 reyk Exp $	*/
d49 1
d64 1
d120 67
d191 7
@


1.12
log
@initial implementation of "IP Roaming" in hostapd, see hostapd.conf(5).

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.11 2006/01/31 10:55:02 reyk Exp $	*/
d67 1
a67 1
	    "%s: Host AP interface added\n", apme->a_iface);
d92 1
a92 1
		    "%s/%s: failed to deauthenticate all stations: %s\n",
d99 1
a99 1
	    "%s/%s: deauthenticated all stations\n",
d134 1
a134 1
	    "%s: Host AP interface removed\n", apme->a_iface);
d307 1
a307 1
		    "%s: invalid association from %s on the Host AP\n",
@


1.11
log
@fix a bug by updating the bpf packet header for each received frame in
the capture buffer.

to alex 'pukpuk' at gmx.de
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.10 2005/12/18 17:54:12 reyk Exp $	*/
d129 4
d261 1
d319 2
d324 3
@


1.10
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.9 2005/12/10 13:10:07 reyk Exp $	*/
a157 1
	bph = (struct bpf_hdr *)bp;
d162 2
@


1.9
log
@make lint more happy
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.8 2005/12/01 01:11:30 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.8
log
@move iapp configuration in a separate data structure
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.7 2005/12/01 00:36:41 reyk Exp $	*/
d162 1
a162 1
		register int caplen, hdrlen;
@


1.7
log
@deauthenticate all stations on startup which will force them to
reassociate cleanly.
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.6 2005/11/20 12:02:04 reyk Exp $	*/
d76 1
d93 1
a93 1
		    cfg->c_iapp_iface, apme->a_iface,
d100 1
a100 1
	    apme->a_iface, cfg->c_iapp_iface);
a122 3
	hostapd_log(HOSTAPD_LOG_DEBUG,
	    "%s: Host AP interface removed\n", apme->a_iface);

d128 4
@


1.6
log
@add support for multiple hostap (wireless) interfaces.

for example, if you run one hostapd with two ath(4) devices. you have
to specify "set hostap interface { ath0, ath1 }" in hostapd.conf(5).

man page bits by jmc@@, tested by others
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.5 2005/10/07 22:32:52 reyk Exp $	*/
d68 32
@


1.5
log
@move IAPP definitions to separate header file
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.4 2005/06/17 19:13:35 reyk Exp $	*/
d48 52
a99 1
void	 hostapd_apme_frame(struct hostapd_config *, u_int8_t *, u_int);
d104 1
a104 1
	struct hostapd_config *cfg = (struct hostapd_config *)arg;
d133 1
a133 1
		hostapd_apme_frame(cfg, bp + hdrlen, caplen);
d140 1
a140 1
hostapd_apme_output(struct hostapd_config *cfg,
d185 1
a185 1
	if (writev(cfg->c_apme_raw, iov, iovcnt) == -1)
d192 1
a192 1
hostapd_apme_offset(struct hostapd_config *cfg,
d195 1
d219 1
a219 1
hostapd_apme_frame(struct hostapd_config *cfg, u_int8_t *buf, u_int len)
d221 2
d227 1
a227 1
	if ((offset = hostapd_apme_offset(cfg, buf, len)) < 0)
d236 1
a236 1
	if ((hostapd_handle_input(cfg, buf, len) ==
d255 2
a256 2
	if (bcmp(wh->i_addr2, cfg->c_apme_bssid, IEEE80211_ADDR_LEN) != 0 ||
	    bcmp(wh->i_addr3, cfg->c_apme_bssid, IEEE80211_ADDR_LEN) != 0)
d265 1
a265 1
	if (hostapd_priv_apme_getnode(cfg, &node) != 0) {
d268 1
a268 1
		    cfg->c_apme_iface, etheraddr_string(wh->i_addr1));
d273 11
a283 1
	hostapd_iapp_add_notify(cfg, &node);
d288 1
a288 1
hostapd_apme_init(struct hostapd_config *cfg)
d290 1
d294 1
a294 1
	cfg->c_apme_raw = hostapd_bpf_open(O_RDWR);
d296 2
a297 2
	cfg->c_apme_rawlen = IAPP_MAXSIZE;
	if (ioctl(cfg->c_apme_raw, BIOCSBLEN, &cfg->c_apme_rawlen) == -1)
d299 1
a299 1
		    cfg->c_apme_iface, strerror(errno));
d302 1
a302 1
	if (ioctl(cfg->c_apme_raw, BIOCIMMEDIATE, &i) == -1)
d304 1
a304 1
		    "%s\n", cfg->c_apme_iface, strerror(errno));
d307 1
a307 1
	strlcpy(ifr.ifr_name, cfg->c_apme_iface, sizeof(ifr.ifr_name));
d310 1
a310 1
	ioctl(cfg->c_apme_raw, BIOCPROMISC, NULL);
d313 1
a313 1
	if (ioctl(cfg->c_apme_raw, BIOCSETIF, &ifr) == -1)
d315 1
a315 1
		    cfg->c_apme_iface, strerror(errno));
d318 1
a318 1
	if (ioctl(cfg->c_apme_raw, BIOCSDLT, &dlt) == -1)
d320 1
a320 1
		    cfg->c_apme_iface, strerror(errno));
d323 1
a323 1
	if (ioctl(cfg->c_apme_raw, BIOCLOCK, NULL) == -1)
d325 1
a325 1
		    cfg->c_apme_iface, strerror(errno));
d329 1
a329 1
hostapd_apme_addnode(struct hostapd_config *cfg, struct hostapd_node *node)
d331 1
a331 1
	return (hostapd_priv_apme_setnode(cfg, node, 1));
d335 1
a335 1
hostapd_apme_delnode(struct hostapd_config *cfg, struct hostapd_node *node)
d337 1
a337 1
	return (hostapd_priv_apme_setnode(cfg, node, 0));
@


1.4
log
@first step to implement a proactive wireless monitoring system using
hostapd(8). it's a very simple but powerful approach using highly
flexible and stateless event and action rules for IEEE 802.11 traffic.
you can monitor a wireless network by watching frames with types and
addresses (with support for tables and masks) and you can trigger
actions like writing log messages, sending pcap/radiotap dumps to the
IAPP network, removing nodes from the hostap, resending received
frames and sending contructed 802.11 frames in reply to traffic
received from any rogue nodes.

it's based on some initial work from the c2k5 which has been tested
and improved during the last weeks. some missing documentation for
hostapd.conf(5) will be written as soon as possible.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.3 2005/04/13 19:06:11 deraadt Exp $	*/
d46 1
@


1.3
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.2 2005/04/13 18:25:28 henning Exp $	*/
d24 1
d37 2
d87 78
d169 6
a174 1
	struct ieee80211_frame *wh = (struct ieee80211_frame *)buf;
d180 6
d212 2
a213 3
		    "%s/%s: invalid association from %s on the Host AP\n",
		    cfg->c_apme_iface, cfg->c_iapp_iface,
		    ether_ntoa((struct ether_addr*)wh->i_addr1));
d216 1
a217 1
	/* Call ADD.notify handler */
d219 1
d228 1
a228 1
	cfg->c_apme_raw = hostapd_bpf_open(O_RDONLY);
d251 1
a251 1
	dlt = IAPP_DLT;
d260 12
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: apme.c,v 1.1 2005/04/13 18:12:23 reyk Exp $	*/
d105 1
a105 1
	/* 
@


1.1
log
@add the initial version of the OpenBSD hostapd daemon

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d145 2
a146 2
		hostapd_fatal("failed to set BPF immediate mode on \"%s\": %s\n",
		    cfg->c_apme_iface, strerror(errno));
@

