head	1.151;
access;
symbols
	OPENBSD_6_1_BASE:1.151
	OPENBSD_6_0:1.145.0.4
	OPENBSD_6_0_BASE:1.145
	OPENBSD_5_9:1.145.0.2
	OPENBSD_5_9_BASE:1.145
	OPENBSD_5_8:1.140.0.4
	OPENBSD_5_8_BASE:1.140
	OPENBSD_5_7:1.138.0.2
	OPENBSD_5_7_BASE:1.138
	OPENBSD_5_6:1.132.0.4
	OPENBSD_5_6_BASE:1.132
	OPENBSD_5_5:1.88.0.4
	OPENBSD_5_5_BASE:1.88
	OPENBSD_5_4:1.82.0.8
	OPENBSD_5_4_BASE:1.82
	OPENBSD_5_3:1.82.0.6
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.82.0.4
	OPENBSD_5_2_BASE:1.82
	OPENBSD_5_1_BASE:1.82
	OPENBSD_5_1:1.82.0.2
	OPENBSD_5_0:1.77.0.2
	OPENBSD_5_0_BASE:1.77
	OPENBSD_4_9:1.73.0.2
	OPENBSD_4_9_BASE:1.73
	OPENBSD_4_8:1.72.0.2
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.67.0.4
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.66.0.2
	OPENBSD_4_5_BASE:1.66
	OPENBSD_4_4:1.65.0.10
	OPENBSD_4_4_BASE:1.65
	OPENBSD_4_3:1.65.0.8
	OPENBSD_4_3_BASE:1.65
	OPENBSD_4_2:1.65.0.6
	OPENBSD_4_2_BASE:1.65
	OPENBSD_4_1:1.65.0.4
	OPENBSD_4_1_BASE:1.65
	OPENBSD_4_0:1.65.0.2
	OPENBSD_4_0_BASE:1.65
	OPENBSD_3_9:1.64.0.2
	OPENBSD_3_9_BASE:1.64
	OPENBSD_3_8:1.63.0.2
	OPENBSD_3_8_BASE:1.63
	OPENBSD_3_7:1.62.0.2
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.61.0.4
	OPENBSD_3_6_BASE:1.61
	OPENBSD_3_5:1.61.0.2
	OPENBSD_3_5_BASE:1.61
	OPENBSD_3_4:1.60.0.2
	OPENBSD_3_4_BASE:1.60
	OPENBSD_3_3:1.53.0.2
	OPENBSD_3_3_BASE:1.53
	OPENBSD_3_2:1.52.0.2
	OPENBSD_3_2_BASE:1.52
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	OPENBSD_3_0:1.40.0.2
	OPENBSD_3_0_BASE:1.40
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_9:1.35.0.2
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.33.0.2
	OPENBSD_2_7_BASE:1.33
	OPENBSD_2_6:1.28.0.4
	OPENBSD_2_6_BASE:1.28
	OPENBSD_2_5:1.28.0.2
	OPENBSD_2_5_BASE:1.28
	OPENBSD_2_4:1.27.0.2
	OPENBSD_2_4_BASE:1.27
	OPENBSD_2_3:1.25.0.4
	OPENBSD_2_3_BASE:1.25
	OPENBSD_2_2:1.25.0.2
	OPENBSD_2_2_BASE:1.25
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.151
date	2017.01.24.14.07.41;	author florian;	state Exp;
branches;
next	1.150;
commitid	xTIfhyV5y4q6AFbR;

1.150
date	2017.01.13.18.00.10;	author florian;	state Exp;
branches;
next	1.149;
commitid	CssVvgvY8oJ73Spr;

1.149
date	2016.09.28.06.39.12;	author florian;	state Exp;
branches;
next	1.148;
commitid	sMHkRo7iaWZ6XuW4;

1.148
date	2016.09.27.05.33.46;	author florian;	state Exp;
branches;
next	1.147;
commitid	EvAproCaeMwxETCa;

1.147
date	2016.09.19.07.08.01;	author florian;	state Exp;
branches;
next	1.146;
commitid	Rpox0QUKrxk1Whtu;

1.146
date	2016.09.03.22.00.06;	author benno;	state Exp;
branches;
next	1.145;
commitid	3bNEZqrraFIYcAa1;

1.145
date	2016.02.12.05.11.29;	author semarie;	state Exp;
branches;
next	1.144;
commitid	aPEJPtGx7Z1E7Z14;

1.144
date	2015.11.06.19.13.36;	author florian;	state Exp;
branches;
next	1.143;
commitid	J0Ipm5tltcWtrBDz;

1.143
date	2015.10.09.01.37.10;	author deraadt;	state Exp;
branches;
next	1.142;
commitid	sbrB3Q5CNxcwZpfU;

1.142
date	2015.10.03.02.22.38;	author deraadt;	state Exp;
branches;
next	1.141;
commitid	aBYy2OIaWrpY7qi1;

1.141
date	2015.08.30.22.10.57;	author florian;	state Exp;
branches;
next	1.140;
commitid	MbBxnxDDaTu1FMGC;

1.140
date	2015.07.16.22.47.46;	author florian;	state Exp;
branches;
next	1.139;
commitid	tcNP7YsJSyBF2q9O;

1.139
date	2015.03.11.04.05.18;	author dlg;	state Exp;
branches;
next	1.138;
commitid	mgEEmlzJhGo6Ujes;

1.138
date	2015.02.11.09.49.38;	author florian;	state Exp;
branches;
next	1.137;
commitid	vs83CKW2X5K8bBEp;

1.137
date	2015.02.09.23.00.15;	author deraadt;	state Exp;
branches;
next	1.136;
commitid	822YD61EeG0Xl9Na;

1.136
date	2015.01.20.18.44.16;	author florian;	state Exp;
branches;
next	1.135;
commitid	yJRhEEDlZ86Gf0Cp;

1.135
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.134;
commitid	Uu5nFG3wCl0LACBb;

1.134
date	2014.12.09.17.46.24;	author millert;	state Exp;
branches;
next	1.133;
commitid	tIwHYIUsXu6LBms1;

1.133
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.132;
commitid	2uw1UTO4k6erpWzK;

1.132
date	2014.06.05.14.49.11;	author florian;	state Exp;
branches;
next	1.131;
commitid	YmJMzZmVKZVpKIpo;

1.131
date	2014.06.04.12.28.39;	author florian;	state Exp;
branches;
next	1.130;
commitid	YM9qglOoHqSy4YRP;

1.130
date	2014.06.04.12.20.31;	author florian;	state Exp;
branches;
next	1.129;
commitid	JglmJ8R5SEX8b6M3;

1.129
date	2014.05.28.10.29.24;	author daniel;	state Exp;
branches;
next	1.128;

1.128
date	2014.05.01.18.46.01;	author jmc;	state Exp;
branches;
next	1.127;

1.127
date	2014.04.28.09.45.30;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2014.04.23.09.27.13;	author florian;	state Exp;
branches;
next	1.125;

1.125
date	2014.04.23.09.22.34;	author florian;	state Exp;
branches;
next	1.124;

1.124
date	2014.04.23.09.21.41;	author florian;	state Exp;
branches;
next	1.123;

1.123
date	2014.04.23.09.20.59;	author florian;	state Exp;
branches;
next	1.122;

1.122
date	2014.04.23.09.16.11;	author florian;	state Exp;
branches;
next	1.121;

1.121
date	2014.04.23.09.14.49;	author florian;	state Exp;
branches;
next	1.120;

1.120
date	2014.04.23.09.14.07;	author florian;	state Exp;
branches;
next	1.119;

1.119
date	2014.04.23.09.13.00;	author florian;	state Exp;
branches;
next	1.118;

1.118
date	2014.04.23.09.10.53;	author florian;	state Exp;
branches;
next	1.117;

1.117
date	2014.04.23.08.58.26;	author florian;	state Exp;
branches;
next	1.116;

1.116
date	2014.04.23.08.55.42;	author florian;	state Exp;
branches;
next	1.115;

1.115
date	2014.04.23.08.50.27;	author florian;	state Exp;
branches;
next	1.114;

1.114
date	2014.04.23.08.47.16;	author florian;	state Exp;
branches;
next	1.113;

1.113
date	2014.04.23.08.44.50;	author florian;	state Exp;
branches;
next	1.112;

1.112
date	2014.04.21.14.26.10;	author florian;	state Exp;
branches;
next	1.111;

1.111
date	2014.04.19.14.06.10;	author florian;	state Exp;
branches;
next	1.110;

1.110
date	2014.04.18.17.01.47;	author florian;	state Exp;
branches;
next	1.109;

1.109
date	2014.04.18.17.01.06;	author florian;	state Exp;
branches;
next	1.108;

1.108
date	2014.04.18.17.00.07;	author florian;	state Exp;
branches;
next	1.107;

1.107
date	2014.04.18.16.58.02;	author florian;	state Exp;
branches;
next	1.106;

1.106
date	2014.04.18.16.46.18;	author florian;	state Exp;
branches;
next	1.105;

1.105
date	2014.04.18.16.32.42;	author florian;	state Exp;
branches;
next	1.104;

1.104
date	2014.04.18.16.29.26;	author florian;	state Exp;
branches;
next	1.103;

1.103
date	2014.04.18.16.24.41;	author florian;	state Exp;
branches;
next	1.102;

1.102
date	2014.04.18.16.22.18;	author florian;	state Exp;
branches;
next	1.101;

1.101
date	2014.04.18.16.19.11;	author florian;	state Exp;
branches;
next	1.100;

1.100
date	2014.04.18.16.04.39;	author florian;	state Exp;
branches;
next	1.99;

1.99
date	2014.04.18.15.58.43;	author florian;	state Exp;
branches;
next	1.98;

1.98
date	2014.04.18.08.44.25;	author florian;	state Exp;
branches;
next	1.97;

1.97
date	2014.03.29.11.19.41;	author florian;	state Exp;
branches;
next	1.96;

1.96
date	2014.03.29.11.18.39;	author florian;	state Exp;
branches;
next	1.95;

1.95
date	2014.03.24.11.11.49;	author mpi;	state Exp;
branches;
next	1.94;

1.94
date	2014.03.18.10.11.36;	author florian;	state Exp;
branches;
next	1.93;

1.93
date	2014.03.18.10.11.00;	author florian;	state Exp;
branches;
next	1.92;

1.92
date	2014.03.18.10.10.17;	author florian;	state Exp;
branches;
next	1.91;

1.91
date	2014.03.18.10.08.58;	author florian;	state Exp;
branches;
next	1.90;

1.90
date	2014.03.10.19.58.06;	author florian;	state Exp;
branches;
next	1.89;

1.89
date	2014.03.10.19.56.58;	author florian;	state Exp;
branches;
next	1.88;

1.88
date	2014.01.24.15.26.32;	author florian;	state Exp;
branches;
next	1.87;

1.87
date	2014.01.24.15.24.06;	author florian;	state Exp;
branches;
next	1.86;

1.86
date	2014.01.24.15.19.51;	author florian;	state Exp;
branches;
next	1.85;

1.85
date	2014.01.24.15.17.33;	author florian;	state Exp;
branches;
next	1.84;

1.84
date	2014.01.24.15.06.59;	author florian;	state Exp;
branches;
next	1.83;

1.83
date	2013.11.12.19.36.29;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2012.02.10.23.05.54;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2012.02.10.22.51.28;	author sthen;	state Exp;
branches;
next	1.80;

1.80
date	2012.01.12.11.25.08;	author sthen;	state Exp;
branches;
next	1.79;

1.79
date	2011.11.08.12.16.54;	author sthen;	state Exp;
branches;
next	1.78;

1.78
date	2011.09.17.14.10.05;	author haesbaert;	state Exp;
branches;
next	1.77;

1.77
date	2011.06.21.17.31.07;	author mikeb;	state Exp;
branches;
next	1.76;

1.76
date	2011.04.23.10.00.13;	author sthen;	state Exp;
branches;
next	1.75;

1.75
date	2011.04.06.12.05.00;	author sthen;	state Exp;
branches;
next	1.74;

1.74
date	2011.03.22.10.16.23;	author okan;	state Exp;
branches;
next	1.73;

1.73
date	2010.09.13.10.09.00;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2010.07.09.12.27.09;	author dhill;	state Exp;
branches;
next	1.71;

1.71
date	2010.07.08.20.23.03;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2010.07.05.21.44.48;	author robert;	state Exp;
branches;
next	1.69;

1.69
date	2010.07.03.04.44.52;	author guenther;	state Exp;
branches;
next	1.68;

1.68
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2009.06.05.00.10.01;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2008.10.04.02.21.49;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.31.03.05.57;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2005.11.02.11.35.54;	author jmc;	state Exp;
branches;
next	1.63;

1.63
date	2005.05.03.01.01.13;	author djm;	state Exp;
branches;
next	1.62;

1.62
date	2005.03.01.16.13.29;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.26.18.23.51;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2003.08.27.08.17.34;	author jmc;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.11.23.33.29;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.02.23.36.55;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2003.04.25.22.45.38;	author cloder;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.25.02.56.39;	author cloder;	state Exp;
branches;
next	1.55;

1.55
date	2003.04.25.02.12.19;	author cloder;	state Exp;
branches;
next	1.54;

1.54
date	2003.04.24.16.20.04;	author cloder;	state Exp;
branches;
next	1.53;

1.53
date	2002.11.18.04.45.11;	author itojun;	state Exp;
branches;
next	1.52;

1.52
date	2002.09.06.19.50.05;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2002.08.31.00.05.20;	author stevesk;	state Exp;
branches;
next	1.50;

1.50
date	2002.08.12.02.40.52;	author stevesk;	state Exp;
branches;
next	1.49;

1.49
date	2002.08.12.02.36.25;	author stevesk;	state Exp;
branches;
next	1.48;

1.48
date	2002.08.08.23.53.21;	author stevesk;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.03.23.01.10;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.29.07.56.44;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.29.07.46.29;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.02.06.42.29;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.26.13.24.54;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.21.00.46.44;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.16.21.28.10;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.10.05.49.23;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.10.01.24.01;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.09.21.06.23;	author pvalchev;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.01.01.57.00;	author pvalchev;	state Exp;
branches;
next	1.35;

1.35
date	2001.03.15.17.52.54;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.28.22.43.17;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.04.20.17.26.37;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2000.04.20.07.47.11;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	99.12.23.16.17.05;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	99.12.18.21.34.35;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	99.12.18.01.11.06;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	99.02.17.00.20.45;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	98.07.11.21.20.12;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.07.09.06.32.27;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.06.28.20.19.02;	author denny;	state Exp;
branches;
next	1.24;

1.24
date	97.06.23.09.28.57;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.06.12.01.12.27;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.06.11.10.17.04;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.06.11.06.47.24;	author denny;	state Exp;
branches;
next	1.20;

1.20
date	97.06.11.00.52.17;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.06.09.21.55.19;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.06.09.21.31.01;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.06.09.00.21.16;	author denny;	state Exp;
branches;
next	1.16;

1.16
date	97.02.22.20.39.20;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.02.04.16.44.15;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.01.30.22.43.11;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.30.07.07.07;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.01.17.07.14.30;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.12.22.03.29.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.10.16.06.33.03;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.10.12.03.19.52;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.08.16.20.19.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.16.20.07.54;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.05.12.04.52;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.23.10.58.24;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.23.10.52.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.29.23.30.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.19.15.23.26;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.29;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.151
log
@Tell traceroute6 to choose source address based on correct routing
table.
From dhill, tweeks by me.
OK benno
@
text
@/*	$OpenBSD: traceroute.c,v 1.150 2017/01/13 18:00:10 florian Exp $	*/
/*	$NetBSD: traceroute.c,v 1.10 1995/05/21 15:50:45 mycroft Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Van Jacobson.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * traceroute host  - trace the route ip packets follow going to "host".
 *
 * Attempt to trace the route an ip packet would follow to some
 * internet host.  We find out intermediate hops by launching probe
 * packets with a small ttl (time to live) then listening for an
 * icmp "time exceeded" reply from a gateway.  We start our probes
 * with a ttl of one and increase by one until we get an icmp "port
 * unreachable" (which means we got to "host") or hit a max (which
 * defaults to 64 hops & can be changed with the -m flag).  Three
 * probes (change with -q flag) are sent at each ttl setting and a
 * line is printed showing the ttl, address of the gateway and
 * round trip time of each probe.  If the probe answers come from
 * different gateways, the address of each responding system will
 * be printed.  If there is no response within a 5 sec. timeout
 * interval (changed with the -w flag), a "*" is printed for that
 * probe.
 *
 * Probe packets are UDP format.  We don't want the destination
 * host to process them so the destination port is set to an
 * unlikely value (if some clod on the destination is using that
 * value, it can be changed with the -p flag).
 *
 * A sample use might be:
 *
 *     [yak 71]% traceroute nis.nsf.net.
 *     traceroute to nis.nsf.net (35.1.1.48), 64 hops max, 56 byte packet
 *      1  helios.ee.lbl.gov (128.3.112.1)  19 ms  19 ms  0 ms
 *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms
 *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms
 *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  39 ms
 *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  39 ms  39 ms  39 ms
 *      6  128.32.197.4 (128.32.197.4)  40 ms  59 ms  59 ms
 *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  59 ms
 *      8  129.140.70.13 (129.140.70.13)  99 ms  99 ms  80 ms
 *      9  129.140.71.6 (129.140.71.6)  139 ms  239 ms  319 ms
 *     10  129.140.81.7 (129.140.81.7)  220 ms  199 ms  199 ms
 *     11  nic.merit.edu (35.1.1.48)  239 ms  239 ms  239 ms
 *
 * Note that lines 2 & 3 are the same.  This is due to a buggy
 * kernel on the 2nd hop system -- lbl-csam.arpa -- that forwards
 * packets with a zero ttl.
 *
 * A more interesting example is:
 *
 *     [yak 72]% traceroute allspice.lcs.mit.edu.
 *     traceroute to allspice.lcs.mit.edu (18.26.0.115), 64 hops max
 *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms
 *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  19 ms  19 ms
 *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  19 ms
 *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  19 ms  39 ms  39 ms
 *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  20 ms  39 ms  39 ms
 *      6  128.32.197.4 (128.32.197.4)  59 ms  119 ms  39 ms
 *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  39 ms
 *      8  129.140.70.13 (129.140.70.13)  80 ms  79 ms  99 ms
 *      9  129.140.71.6 (129.140.71.6)  139 ms  139 ms  159 ms
 *     10  129.140.81.7 (129.140.81.7)  199 ms  180 ms  300 ms
 *     11  129.140.72.17 (129.140.72.17)  300 ms  239 ms  239 ms
 *     12  * * *
 *     13  128.121.54.72 (128.121.54.72)  259 ms  499 ms  279 ms
 *     14  * * *
 *     15  * * *
 *     16  * * *
 *     17  * * *
 *     18  ALLSPICE.LCS.MIT.EDU (18.26.0.115)  339 ms  279 ms  279 ms
 *
 * (I start to see why I'm having so much trouble with mail to
 * MIT.)  Note that the gateways 12, 14, 15, 16 & 17 hops away
 * either don't send ICMP "time exceeded" messages or send them
 * with a ttl too small to reach us.  14 - 17 are running the
 * MIT C Gateway code that doesn't send "time exceeded"s.  God
 * only knows what's going on with 12.
 *
 * The silent gateway 12 in the above may be the result of a bug in
 * the 4.[23]BSD network code (and its derivatives):  4.x (x <= 3)
 * sends an unreachable message using whatever ttl remains in the
 * original datagram.  Since, for gateways, the remaining ttl is
 * zero, the icmp "time exceeded" is guaranteed to not make it back
 * to us.  The behavior of this bug is slightly more interesting
 * when it appears on the destination system:
 *
 *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms
 *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  39 ms
 *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  39 ms  19 ms
 *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  19 ms
 *      5  ccn-nerif35.Berkeley.EDU (128.32.168.35)  39 ms  39 ms  39 ms
 *      6  csgw.Berkeley.EDU (128.32.133.254)  39 ms  59 ms  39 ms
 *      7  * * *
 *      8  * * *
 *      9  * * *
 *     10  * * *
 *     11  * * *
 *     12  * * *
 *     13  rip.Berkeley.EDU (128.32.131.22)  59 ms !  39 ms !  39 ms !
 *
 * Notice that there are 12 "gateways" (13 is the final
 * destination) and exactly the last half of them are "missing".
 * What's really happening is that rip (a Sun-3 running Sun OS3.5)
 * is using the ttl from our arriving datagram as the ttl in its
 * icmp reply.  So, the reply will time out on the return path
 * (with no notice sent to anyone since icmp's aren't sent for
 * icmp's) until we probe with a ttl that's at least twice the path
 * length.  I.e., rip is really only 7 hops away.  A reply that
 * returns with a ttl of 1 is a clue this problem exists.
 * Traceroute prints a "!" after the time if the ttl is <= 1.
 * Since vendors ship a lot of obsolete (DEC's Ultrix, Sun 3.x) or
 * non-standard (HPUX) software, expect to see this problem
 * frequently and/or take care picking the target host of your
 * probes.
 *
 * Other possible annotations after the time are !H, !N, !P (got a host,
 * network or protocol unreachable, respectively), !S or !F (source
 * route failed or fragmentation needed -- neither of these should
 * ever occur and the associated gateway is busted if you see one).  If
 * almost all the probes result in some kind of unreachable, traceroute
 * will give up and exit.
 *
 * Notes
 * -----
 * This program must be run by root or be setuid.  (I suggest that
 * you *don't* make it setuid -- casual use could result in a lot
 * of unnecessary traffic on our poor, congested nets.)
 *
 * This program requires a kernel mod that does not appear in any
 * system available from Berkeley:  A raw ip socket using proto
 * IPPROTO_RAW must interpret the data sent as an ip datagram (as
 * opposed to data to be wrapped in a ip datagram).  See the README
 * file that came with the source to this program for a description
 * of the mods I made to /sys/netinet/raw_ip.c.  Your mileage may
 * vary.  But, again, ANY 4.x (x < 4) BSD KERNEL WILL HAVE TO BE
 * MODIFIED TO RUN THIS PROGRAM.
 *
 * The udp port usage may appear bizarre (well, ok, it is bizarre).
 * The problem is that an icmp message only contains 8 bytes of
 * data from the original datagram.  8 bytes is the size of a udp
 * header so, if we want to associate replies with the original
 * datagram, the necessary information must be encoded into the
 * udp header (the ip id could be used but there's no way to
 * interlock with the kernel's assignment of ip id's and, anyway,
 * it would have taken a lot more kernel hacking to allow this
 * code to set the ip id).  So, to allow two or more users to
 * use traceroute simultaneously, we use this task's pid as the
 * source port (the high bit is set to move the port number out
 * of the "likely" range).  To keep track of which probe is being
 * replied to (so times and/or hop counts don't get confused by a
 * reply that was delayed in transit), we increment the destination
 * port number before each probe.
 *
 * Don't use this as a coding example.  I was trying to find a
 * routing problem and this code sort-of popped out after 48 hours
 * without sleep.  I was amazed it ever compiled, much less ran.
 *
 * I stole the idea for this program from Steve Deering.  Since
 * the first release, I've learned that had I attended the right
 * IETF working group meetings, I also could have stolen it from Guy
 * Almes or Matt Mathis.  I don't know (or care) who came up with
 * the idea first.  I envy the originators' perspicacity and I'm
 * glad they didn't keep the idea a secret.
 *
 * Tim Seaver, Ken Adelman and C. Philip Wood provided bug fixes and/or
 * enhancements to the original distribution.
 *
 * I've hacked up a round-trip-route version of this that works by
 * sending a loose-source-routed udp datagram through the destination
 * back to yourself.  Unfortunately, SO many gateways botch source
 * routing, the thing is almost worthless.  Maybe one day...
 *
 *  -- Van Jacobson (van@@helios.ee.lbl.gov)
 *     Tue Dec 20 03:50:13 PST 1988
 */


#include <arpa/inet.h>
#include <endian.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <netdb.h>
#include <netinet/icmp6.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip6.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <unistd.h>

#include "traceroute.h"

struct in_addr	gateway[MAX_LSRR + 1];

int	 lsrrlen = 0;
int32_t	 sec_perturb;
int32_t	 usec_perturb;

u_char	 packet[512];
u_char	*outpacket;	/* last inbound (icmp) packet */

int	rcvsock;	/* receive (icmp) socket file descriptor */
int	sndsock;	/* send (udp) socket file descriptor */

static struct msghdr	rcvmhdr;
static struct iovec	rcviov[2];

int	rcvhlim;
struct in6_pktinfo *rcvpktinfo;

	int	datalen;	/* How much data */
static	int	headerlen;	/* How long packet's header is */

char	*hostname;

static int	nprobes = 3;
static u_int8_t	max_ttl = IPDEFTTL;
static u_int8_t	first_ttl = 1;

static int	options;	/* socket options */
static int	xflag;		/* show ICMP extension header */
static int	tflag;		/* tos flag was set */
static int	v6flag;

u_short		ident;
u_int16_t	srcport;
u_int16_t	port = 32768+666;/* start udp dest port # for probe packets */
u_char		proto = IPPROTO_UDP;

int		verbose;
int		curwaittime;	/* time left to wait for response */
int		nflag;		/* print addresses numerically */
int		dump;
int		Aflag;		/* lookup ASN */
int		last_tos;

void	usage(void);

#define	TRACEROUTE_USER	"_traceroute"

int
main(int argc, char *argv[])
{
	int mib[4] = { CTL_NET, PF_INET, IPPROTO_IP, IPCTL_DEFTTL };
	int ttl_flag = 0, incflag = 1, protoset = 0, sump = 0;
	int ch, i, lsrr = 0, on = 1, probe, seq = 0, tos = 0, error, packetlen;
	int rcvcmsglen, rcvsock4, rcvsock6, sndsock4, sndsock6, waittime;
	int v4sock_errno, v6sock_errno;
	struct addrinfo hints, *res;
	struct passwd *pw;
	size_t size;
	static u_char *rcvcmsgbuf;
	struct sockaddr_in from4, to4;
	struct sockaddr_in6 from6, to6;
	struct sockaddr *from, *to;
	struct hostent *hp;
	u_int32_t tmprnd;
	struct ip *ip = NULL;
	u_int8_t ttl;
	char *ep, hbuf[NI_MAXHOST], *dest, *source = NULL;
	const char *errstr;
	long l;
	uid_t ouid, uid;
	gid_t gid;
	u_int rtableid = 0;
	socklen_t len;

	rcvsock4 = rcvsock6 = sndsock4 = sndsock6 = -1;
	v4sock_errno = v6sock_errno = 0;

	waittime = 5 * 1000;

	if ((rcvsock6 = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0)
		v6sock_errno = errno;
	else if ((sndsock6 = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		v6sock_errno = errno;

	if ((rcvsock4 = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0)
		v4sock_errno = errno;
	else if ((sndsock4 = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
		v4sock_errno = errno;

	/* revoke privs */
	ouid = getuid();
	if ((pw = getpwnam(TRACEROUTE_USER)) != NULL) {
		uid = pw->pw_uid;
		gid = pw->pw_gid;
	} else {
		uid = getuid();
		gid = getgid();
	}
	if (setgroups(1, &gid) ||
	    setresgid(gid, gid, gid) ||
	    setresuid(uid, uid, uid))
		err(1, "unable to revoke privs");

	if (strcmp("traceroute6", __progname) == 0) {
		v6flag = 1;
		if (v6sock_errno != 0)
			errc(5, v6sock_errno, rcvsock6 < 0 ? "socket(ICMPv6)" :
			    "socket(SOCK_DGRAM)");
		rcvsock = rcvsock6;
		sndsock = sndsock6;
		if (rcvsock4 >= 0)
			close(rcvsock4);
		if (sndsock4 >= 0)
			close(sndsock4);
	} else {
		if (v4sock_errno != 0)
			errc(5, v4sock_errno, rcvsock4 < 0 ? "icmp socket" :
			    "raw socket");
		rcvsock = rcvsock4;
		sndsock = sndsock4;
		if (rcvsock6 >= 0)
			close(rcvsock6);
		if (sndsock6 >= 0)
			close(sndsock6);
	}

	if (v6flag) {
		mib[1] = PF_INET6;
		mib[2] = IPPROTO_IPV6;
		mib[3] = IPV6CTL_DEFHLIM;
		/* specify to tell receiving interface */
		if (setsockopt(rcvsock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
		    sizeof(on)) < 0)
			err(1, "setsockopt(IPV6_RECVPKTINFO)");

		/* specify to tell hoplimit field of received IP6 hdr */
		if (setsockopt(rcvsock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on,
		    sizeof(on)) < 0)
			err(1, "setsockopt(IPV6_RECVHOPLIMIT)");
	}

	size = sizeof(i);
	if (sysctl(mib, sizeof(mib)/sizeof(mib[0]), &i, &size, NULL, 0) == -1)
		err(1, "sysctl");
	max_ttl = i;

	while ((ch = getopt(argc, argv, v6flag ? "AcDdf:Ilm:np:q:Ss:w:vV:" :
	    "AcDdf:g:Ilm:nP:p:q:Ss:t:V:vw:x")) != -1)
		switch (ch) {
		case 'A':
			Aflag = 1;
			break;
		case 'c':
			incflag = 0;
			break;
		case 'd':
			options |= SO_DEBUG;
			break;
		case 'D':
			dump = 1;
			break;
		case 'f':
			first_ttl = strtonum(optarg, 1, max_ttl, &errstr);
			if (errstr)
				errx(1, "min ttl must be 1 to %u.", max_ttl);
			break;
		case 'g':
			if (lsrr >= MAX_LSRR)
				errx(1, "too many gateways; max %d", MAX_LSRR);
			if (inet_aton(optarg, &gateway[lsrr]) == 0) {
				hp = gethostbyname(optarg);
				if (hp == 0)
					errx(1, "unknown host %s", optarg);
				memcpy(&gateway[lsrr], hp->h_addr,
				    hp->h_length);
			}
			if (++lsrr == 1)
				lsrrlen = 4;
			lsrrlen += 4;
			break;
		case 'I':
			if (protoset)
				errx(1, "protocol already set with -P");
			protoset = 1;
			proto = IPPROTO_ICMP;
			break;
		case 'l':
			ttl_flag = 1;
			break;
		case 'm':
			max_ttl = strtonum(optarg, first_ttl, MAXTTL, &errstr);
			if (errstr)
				errx(1, "max ttl must be %u to %u.", first_ttl,
				    MAXTTL);
			break;
		case 'n':
			nflag = 1;
			break;
		case 'p':
			port = strtonum(optarg, 1, 65535, &errstr);
			if (errstr)
				errx(1, "port must be >0, <65536.");
			break;
		case 'P':
			if (protoset)
				errx(1, "protocol already set with -I");
			protoset = 1;
			proto = strtonum(optarg, 1, IPPROTO_MAX - 1, &errstr);
			if (errstr) {
				struct protoent *pent;

				pent = getprotobyname(optarg);
				if (pent)
					proto = pent->p_proto;
				else
					errx(1, "proto must be >=1, or a "
					    "name.");
			}
			break;
		case 'q':
			nprobes = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "nprobes must be >0.");
			break;
		case 's':
			/*
			 * set the ip source address of the outbound
			 * probe (e.g., on a multi-homed host).
			 */
			source = optarg;
			break;
		case 'S':
			sump = 1;
			break;
		case 't':
			if (!map_tos(optarg, &tos)) {
				if (strlen(optarg) > 1 && optarg[0] == '0' &&
				    optarg[1] == 'x') {
					errno = 0;
					ep = NULL;
					l = strtol(optarg, &ep, 16);
					if (errno || !*optarg || *ep ||
					    l < 0 || l > 255)
						errx(1, "illegal tos value %s",
						    optarg);
					tos = (int)l;
				} else {
					tos = strtonum(optarg, 0, 255, &errstr);
					if (errstr)
						errx(1, "illegal tos value %s",
						    optarg);
				}
			}
			tflag = 1;
			last_tos = tos;
			break;
		case 'v':
			verbose = 1;
			break;
		case 'V':
			rtableid = (unsigned int)strtonum(optarg, 0,
			    RT_TABLEID_MAX, &errstr);
			if (errstr)
				errx(1, "rtable value is %s: %s",
				    errstr, optarg);
			if (setsockopt(sndsock, SOL_SOCKET, SO_RTABLE,
			    &rtableid, sizeof(rtableid)) == -1)
				err(1, "setsockopt SO_RTABLE");
			if (setsockopt(rcvsock, SOL_SOCKET, SO_RTABLE,
			    &rtableid, sizeof(rtableid)) == -1)
				err(1, "setsockopt SO_RTABLE");
			break;
		case 'w':
			waittime = strtonum(optarg, 2, INT_MAX, &errstr);
			if (errstr)
				errx(1, "wait must be >1 sec.");
			waittime *= 1000;
			break;
		case 'x':
			xflag = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc < 1 || argc > 2)
		usage();

	setvbuf(stdout, NULL, _IOLBF, 0);

	ident = (getpid() & 0xffff) | 0x8000;
	tmprnd = arc4random();
	sec_perturb = (tmprnd & 0x80000000) ? -(tmprnd & 0x7ff) :
	    (tmprnd & 0x7ff);
	usec_perturb = arc4random();

	memset(&to4, 0, sizeof(to4));
	memset(&to6, 0, sizeof(to6));

	dest = *argv;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = v6flag ? PF_INET6 : PF_INET;
	hints.ai_socktype = SOCK_RAW;
	hints.ai_protocol = 0;
	hints.ai_flags = AI_CANONNAME;
	if ((error = getaddrinfo(dest, NULL, &hints, &res)))
		errx(1, "%s", gai_strerror(error));

	switch (res->ai_family) {
	case AF_INET:
		if (res->ai_addrlen != sizeof(to4))
		    errx(1, "size of sockaddr mismatch");

		to = (struct sockaddr *)&to4;
		from = (struct sockaddr *)&from4;
		break;
	case AF_INET6:
		if (res->ai_addrlen != sizeof(to6))
			errx(1, "size of sockaddr mismatch");

		to = (struct sockaddr *)&to6;
		from = (struct sockaddr *)&from6;
		break;
	default:
		errx(1, "unsupported AF: %d", res->ai_family);
		break;
	}

	memcpy(to, res->ai_addr, res->ai_addrlen);

	if (!hostname) {
		hostname = res->ai_canonname ? strdup(res->ai_canonname) : dest;
		if (!hostname)
			errx(1, "malloc");
	}

	if (res->ai_next) {
		if (getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
		    sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
			strlcpy(hbuf, "?", sizeof(hbuf));
		warnx("Warning: %s has multiple "
		    "addresses; using %s", hostname, hbuf);
	}
	freeaddrinfo(res);

	if (*++argv) {
		datalen = strtonum(*argv, 0, INT_MAX, &errstr);
		if (errstr)
			errx(1, "datalen out of range");
	}

	switch (to->sa_family) {
	case AF_INET:
		switch (proto) {
		case IPPROTO_UDP:
			headerlen = (sizeof(struct ip) + lsrrlen +
			    sizeof(struct udphdr) + sizeof(struct packetdata));
			break;
		case IPPROTO_ICMP:
			headerlen = (sizeof(struct ip) + lsrrlen +
			    sizeof(struct icmp) + sizeof(struct packetdata));
			break;
		default:
			headerlen = (sizeof(struct ip) + lsrrlen +
			    sizeof(struct packetdata));
		}

		if (datalen < 0 || datalen > IP_MAXPACKET - headerlen)
			errx(1, "packet size must be 0 to %d.",
			    IP_MAXPACKET - headerlen);

		datalen += headerlen;

		if ((outpacket = calloc(1, datalen)) == NULL)
			err(1, "calloc");

		rcviov[0].iov_base = (caddr_t)packet;
		rcviov[0].iov_len = sizeof(packet);
		rcvmhdr.msg_name = (caddr_t)&from4;
		rcvmhdr.msg_namelen = sizeof(from4);
		rcvmhdr.msg_iov = rcviov;
		rcvmhdr.msg_iovlen = 1;
		rcvmhdr.msg_control = NULL;
		rcvmhdr.msg_controllen = 0;

		ip = (struct ip *)outpacket;
		if (lsrr != 0) {
			u_char *p = (u_char *)(ip + 1);

			*p++ = IPOPT_NOP;
			*p++ = IPOPT_LSRR;
			*p++ = lsrrlen - 1;
			*p++ = IPOPT_MINOFF;
			gateway[lsrr] = to4.sin_addr;
			for (i = 1; i <= lsrr; i++) {
				memcpy(p, &gateway[i], sizeof(struct in_addr));
				p += sizeof(struct in_addr);
			}
			ip->ip_dst = gateway[0];
		} else
			ip->ip_dst = to4.sin_addr;
		ip->ip_off = htons(0);
		ip->ip_hl = (sizeof(struct ip) + lsrrlen) >> 2;
		ip->ip_p = proto;
		ip->ip_v = IPVERSION;
		ip->ip_tos = tos;

		if (setsockopt(sndsock, IPPROTO_IP, IP_HDRINCL, (char *)&on,
		    sizeof(on)) < 0)
			err(6, "IP_HDRINCL");

		if (source) {
			memset(&from4, 0, sizeof(from4));
			from4.sin_family = AF_INET;
			if (inet_aton(source, &from4.sin_addr) == 0)
				errx(1, "unknown host %s", source);
			ip->ip_src = from4.sin_addr;
			if (ouid != 0 &&
			    (ntohl(from4.sin_addr.s_addr) & 0xff000000U) ==
			    0x7f000000U && (ntohl(to4.sin_addr.s_addr) &
			    0xff000000U) != 0x7f000000U)
				errx(1, "source is on 127/8, destination is"
				    " not");
			if (ouid && bind(sndsock, (struct sockaddr *)&from4,
			    sizeof(from4)) < 0)
				err(1, "bind");
		}
		packetlen = datalen;
		break;
	case AF_INET6:
		/*
		 * packetlen is the size of the complete IP packet sent and
		 * reported in the first line of output.
		 * For IPv4 this is equal to datalen since we are constructing
		 * a raw packet.
		 * For IPv6 we need to always add the size of the IP6 header
		 * and for UDP packets the size of the UDP header since they
		 * are prepended to the packet by the kernel
		 */
		packetlen = sizeof(struct ip6_hdr);
		switch (proto) {
		case IPPROTO_UDP:
			headerlen = sizeof(struct packetdata);
			packetlen += sizeof(struct udphdr);
			break;
		case IPPROTO_ICMP:
			headerlen = sizeof(struct icmp6_hdr) +
			    sizeof(struct packetdata);
			break;
		default:
			errx(1, "Unsupported proto: %hhu", proto);
			break;
		}

		if (datalen < 0 || datalen > IP_MAXPACKET - headerlen)
			errx(1, "packet size must be 0 to %d.",
			    IP_MAXPACKET - headerlen);

		datalen += headerlen;
		packetlen += datalen;

		if ((outpacket = calloc(1, datalen)) == NULL)
			err(1, "calloc");

		/* initialize msghdr for receiving packets */
		rcviov[0].iov_base = (caddr_t)packet;
		rcviov[0].iov_len = sizeof(packet);
		rcvmhdr.msg_name = (caddr_t)&from6;
		rcvmhdr.msg_namelen = sizeof(from6);
		rcvmhdr.msg_iov = rcviov;
		rcvmhdr.msg_iovlen = 1;
		rcvcmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo)) +
		    CMSG_SPACE(sizeof(int));

		if ((rcvcmsgbuf = malloc(rcvcmsglen)) == NULL)
			errx(1, "malloc");
		rcvmhdr.msg_control = (caddr_t) rcvcmsgbuf;
		rcvmhdr.msg_controllen = rcvcmsglen;

		/*
		 * Send UDP or ICMP
		 */
		if (proto == IPPROTO_ICMP) {
			close(sndsock);
			sndsock = rcvsock;
		}

		/*
		 * Source selection
		 */
		memset(&from6, 0, sizeof(from6));
		if (source) {
			memset(&hints, 0, sizeof(hints));
			hints.ai_family = AF_INET6;
			hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
			hints.ai_flags = AI_NUMERICHOST;
			if ((error = getaddrinfo(source, "0", &hints, &res)))
				errx(1, "%s: %s", source, gai_strerror(error));
			if (res->ai_addrlen != sizeof(from6))
				errx(1, "size of sockaddr mismatch");
			memcpy(&from6, res->ai_addr, res->ai_addrlen);
			freeaddrinfo(res);
		} else {
			struct sockaddr_in6 nxt;
			int dummy;

			nxt = to6;
			nxt.sin6_port = htons(DUMMY_PORT);
			if ((dummy = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
				err(1, "socket");
			if (rtableid > 0 &&
			    setsockopt(dummy, SOL_SOCKET, SO_RTABLE, &rtableid,
			    sizeof(rtableid)) < 0)
				err(1, "setsockopt(SO_RTABLE)");
			if (connect(dummy, (struct sockaddr *)&nxt,
			    nxt.sin6_len) < 0)
				err(1, "connect");
			len = sizeof(from6);
			if (getsockname(dummy, (struct sockaddr *)&from6,
			    &len) < 0)
				err(1, "getsockname");
			close(dummy);
		}

		from6.sin6_port = htons(0);
		if (bind(sndsock, (struct sockaddr *)&from6, from6.sin6_len) <
		    0)
			err(1, "bind sndsock");

		len = sizeof(from6);
		if (getsockname(sndsock, (struct sockaddr *)&from6, &len) < 0)
			err(1, "getsockname");
		srcport = ntohs(from6.sin6_port);
		break;
	default:
		errx(1, "unsupported AF: %d", to->sa_family);
		break;
	}

	if (options & SO_DEBUG) {
		(void) setsockopt(rcvsock, SOL_SOCKET, SO_DEBUG,
		    (char *)&on, sizeof(on));
		(void) setsockopt(sndsock, SOL_SOCKET, SO_DEBUG,
		    (char *)&on, sizeof(on));
	}

	if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *)&datalen,
	    sizeof(datalen)) < 0)
		err(6, "SO_SNDBUF");

	if (nflag && !Aflag) {
		if (pledge("stdio inet", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio inet dns", NULL) == -1)
			err(1, "pledge");
	}

	if (getnameinfo(to, to->sa_len, hbuf,
	    sizeof(hbuf), NULL, 0, NI_NUMERICHOST))
		strlcpy(hbuf, "(invalid)", sizeof(hbuf));
	fprintf(stderr, "%s to %s (%s)", __progname, hostname, hbuf);
	if (source)
		fprintf(stderr, " from %s", source);
	fprintf(stderr, ", %u hops max, %d byte packets\n", max_ttl, packetlen);
	(void) fflush(stderr);

	if (first_ttl > 1)
		printf("Skipping %u intermediate hops\n", first_ttl - 1);

	for (ttl = first_ttl; ttl && ttl <= max_ttl; ++ttl) {
		int got_there = 0, unreachable = 0, timeout = 0, loss;
		in_addr_t lastaddr = 0;
		struct in6_addr lastaddr6;

		printf("%2u ", ttl);
		memset(&lastaddr6, 0, sizeof(lastaddr6));
		for (probe = 0, loss = 0; probe < nprobes; ++probe) {
			int cc;
			struct timeval t1, t2;

			gettime(&t1);
			send_probe(++seq, ttl, incflag, to);
			curwaittime = waittime;
			while ((cc = wait_for_reply(rcvsock, &rcvmhdr))) {
				gettime(&t2);
				i = packet_ok(to->sa_family, &rcvmhdr, cc, seq,
				    incflag);
				/* Skip wrong packet */
				if (i == 0) {
					curwaittime = waittime -
					    ((t2.tv_sec - t1.tv_sec) * 1000 +
					    (t2.tv_usec - t1.tv_usec) / 1000);
					if (curwaittime < 0)
						curwaittime = 0;
					continue;
				}
				if (to->sa_family == AF_INET) {
					ip = (struct ip *)packet;
					if (from4.sin_addr.s_addr != lastaddr) {
						print(from,
						    cc - (ip->ip_hl << 2),
						    inet_ntop(AF_INET,
						    &ip->ip_dst, hbuf,
						    sizeof(hbuf)));
						lastaddr =
						    from4.sin_addr.s_addr;
					}
				} else if (to->sa_family == AF_INET6) {
					if (!IN6_ARE_ADDR_EQUAL(
					    &from6.sin6_addr, &lastaddr6)) {
						print(from, cc, rcvpktinfo ?
						    inet_ntop( AF_INET6,
						    &rcvpktinfo->ipi6_addr,
						    hbuf, sizeof(hbuf)) : "?");
						lastaddr6 = from6.sin6_addr;
					}
				} else
					errx(1, "unsupported AF: %d",
					    to->sa_family);

				printf("  %g ms", deltaT(&t1, &t2));
				if (ttl_flag)
					printf(" (%u)", v6flag ? rcvhlim :
					    ip->ip_ttl);
				if (to->sa_family == AF_INET) {
					if (i == -2) {
						if (ip->ip_ttl <= 1)
							printf(" !");
						++got_there;
						break;
					}

					if (tflag)
						check_tos(ip);
				}

				/* time exceeded in transit */
				if (i == -1)
					break;
				icmp_code(to->sa_family, i - 1, &got_there,
				    &unreachable);
				break;
			}
			if (cc == 0) {
				printf(" *");
				timeout++;
				loss++;
			} else if (cc && probe == nprobes - 1 &&
			    (xflag || verbose))
				print_exthdr(packet, cc);
			(void) fflush(stdout);
		}
		if (sump)
			printf(" (%d%% loss)", (loss * 100) / nprobes);
		putchar('\n');
		if (got_there ||
		    (unreachable && (unreachable + timeout) >= nprobes))
			break;
	}
	exit(0);
}

void
usage(void)
{
	if (v6flag) {
		fprintf(stderr, "usage: traceroute6 [-AcDdIlnSv] [-f first_hop] "
		    "[-m max_hop] [-p port]\n"
		    "\t[-q nqueries] [-s src_addr] [-V rtable] [-w waittime] "
		    "host\n\t[datalen]\n");
	} else {
		fprintf(stderr,
		    "usage: %s [-AcDdIlnSvx] [-f first_ttl] [-g gateway_addr] "
		    "[-m max_ttl]\n"
		    "\t[-P proto] [-p port] [-q nqueries] [-s src_addr]\n"
		    "\t[-t toskeyword] "
		    "[-V rtable] [-w waittime] host [datalen]\n",
		    __progname);
	}
	exit(1);
}
@


1.150
log
@traceroute never sees a timeout when poll(2) returns when it receives
a packet not intended for us. E.g. a ping(8) is running in parallel.
In this case we need to account for the time we already waited.

Pointed out by Gabriel Nieto <gabnietof AT gmail>, thanks!

Looks good to and input millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.149 2016/09/28 06:39:12 florian Exp $	*/
d333 1
a333 1
	u_int rtableid;
d775 4
@


1.149
log
@Always do the setgroups, setresgid and setresuid even if if the
unprivileged user is not present instead of erroring out. This lets
ping and traceroute work in restricted enviornments like the bgplg
chroot.
Problem reported by sthen@@
input & prodding deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.148 2016/09/27 05:33:46 florian Exp $	*/
d299 1
a299 1
int		waittime = 5;	/* time to wait for response (in seconds) */
d315 1
a315 1
	int rcvcmsglen, rcvsock4, rcvsock6, sndsock4, sndsock6;
d339 2
d538 1
d844 1
d849 7
a855 2
				/* Skip short packet */
				if (i == 0)
d857 1
@


1.148
log
@Drop privileges to newly added _traceroute user/group.
It does not buy us much when called as a unpriv user. But if run as
root we can now lose privileges.
Input deraadt@@
OK benno@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.147 2016/09/19 07:08:01 florian Exp $	*/
d331 2
a332 1
	uid_t uid;
d350 11
a360 6
	uid = getuid();
	if ((pw = getpwnam(TRACEROUTE_USER)) == NULL)
		errx(1, "no %s user", TRACEROUTE_USER);
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
d679 1
a679 1
			if (uid != 0 &&
d685 1
a685 1
			if (uid && bind(sndsock, (struct sockaddr *)&from4,
@


1.147
log
@Only allow standard dot notation for IPv4 addresses as target.
We can get rid of inet_aton(3) and use the AF independent getaddrinfo(3).
OK natano@@, krw@@, millert@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.146 2016/09/03 22:00:06 benno Exp $	*/
d249 1
d307 2
d318 1
d350 6
a355 2
	if (setresuid(uid, uid, uid) == -1)
		err(1, "setresuid");
d673 1
a673 1
			if (getuid() != 0 &&
d679 1
a679 1
			if (getuid() && bind(sndsock, (struct sockaddr *)&from4,
@


1.146
log
@rearrange code: traceroute.c now only contains main() and usage(),
worker.c contains all other functions, and i tracked down which global
variables are used in which file and marked them accordingly with
static (or not). No functional change, just the basis of further work.

ok florian@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.145 2016/02/12 05:11:29 semarie Exp $	*/
d546 1
a546 6
	if (inet_aton(*argv, &to4.sin_addr) != 0) {
		hostname = *argv;
		if ((dest = strdup(inet_ntoa(to4.sin_addr))) == NULL)
			errx(1, "malloc");
	} else
		dest = *argv;
@


1.145
log
@pledge for "dns" if -A is passed, even with -n.

The -A (Look up the AS number for each hop address) use DNS service.

ok jca@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.144 2015/11/06 19:13:36 florian Exp $	*/
a235 6
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>
d237 7
d246 1
a247 3
#include <netinet/ip_var.h>
#include <netinet/ip6.h>
#include <netinet/icmp6.h>
a248 13

#define DUMMY_PORT 10010

#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <netmpls/mpls.h>

#include <ctype.h>
#include <err.h>
#include <poll.h>
#include <errno.h>
#include <netdb.h>
d252 4
a256 1
#include <limits.h>
d258 3
a260 1
#define MAX_LSRR		((MAX_IPOPTLEN - 4) / 4)
d262 3
a264 2
#define MPLS_LABEL(m)		((m & MPLS_LABEL_MASK) >> MPLS_LABEL_OFFSET)
#define MPLS_EXP(m)		((m & MPLS_EXP_MASK) >> MPLS_EXP_OFFSET)
d266 2
a267 42
/*
 * Format of the data in a (udp) probe packet.
 */
struct packetdata {
	u_char seq;		/* sequence number of this packet */
	u_int8_t ttl;		/* ttl packet left with */
	u_char pad[2];
	u_int32_t sec;		/* time packet left */
	u_int32_t usec;
} __packed;

struct in_addr gateway[MAX_LSRR + 1];
int lsrrlen = 0;
int32_t sec_perturb;
int32_t usec_perturb;

u_char packet[512], *outpacket;	/* last inbound (icmp) packet */

int wait_for_reply(int, struct msghdr *);
void dump_packet(void);
void build_probe4(int, u_int8_t, int);
void build_probe6(int, u_int8_t, int, struct sockaddr *);
void send_probe(int, u_int8_t, int, struct sockaddr *);
struct udphdr *get_udphdr(struct ip6_hdr *, u_char *);
int packet_ok(int, struct msghdr *, int, int, int);
int packet_ok4(struct msghdr *, int, int, int);
int packet_ok6(struct msghdr *, int, int, int);
void icmp_code(int, int, int *, int *);
void icmp4_code(int, int *, int *);
void icmp6_code(int, int *, int *);
void dump_packet(void);
void print_exthdr(u_char *, int);
void check_tos(struct ip*);
void print(struct sockaddr *, int, const char *);
const char *inetname(struct sockaddr*);
void print_asn(struct sockaddr_storage *);
u_short in_cksum(u_short *, int);
char *pr_type(u_int8_t);
int map_tos(char *, int *);
double deltaT(struct timeval *, struct timeval *);
void usage(void);
void gettime(struct timeval *);
d269 2
a270 2
int rcvsock;			/* receive (icmp) socket file descriptor */
int sndsock;			/* send (udp) socket file descriptor */
d272 2
a273 2
struct msghdr rcvmhdr;
struct iovec rcviov[2];
d275 1
a275 1
int rcvhlim;
d278 2
a279 2
int datalen;			/* How much data */
int headerlen;			/* How long packet's header is */
d281 1
a281 1
char *hostname;
d283 20
a302 19
int nprobes = 3;
u_int8_t max_ttl = IPDEFTTL;
u_int8_t first_ttl = 1;
u_short ident;
u_int16_t srcport;
u_int16_t port = 32768+666;	/* start udp dest port # for probe packets */
u_char	proto = IPPROTO_UDP;
u_int8_t  icmp_type = ICMP_ECHO; /* default ICMP code/type */
#define ICMP_CODE 0;
int options;			/* socket options */
int verbose;
int waittime = 5;		/* time to wait for response (in seconds) */
int nflag;			/* print addresses numerically */
int dump;
int xflag;			/* show ICMP extension header */
int tflag;			/* tos flag was set */
int Aflag;			/* lookup ASN */
int last_tos;
int v6flag;
d304 1
a304 1
extern char *__progname;
a905 880
print_exthdr(u_char *buf, int cc)
{
	struct icmp_ext_hdr exthdr;
	struct icmp_ext_obj_hdr objhdr;
	struct ip *ip;
	struct icmp *icp;
	int hlen, first;
	u_int32_t label;
	u_int16_t off, olen;
	u_int8_t type;

	ip = (struct ip *)buf;
	hlen = ip->ip_hl << 2;
	if (cc < hlen + ICMP_MINLEN)
		return;
	icp = (struct icmp *)(buf + hlen);
	cc -= hlen + ICMP_MINLEN;
	buf += hlen + ICMP_MINLEN;

	type = icp->icmp_type;
	if (type != ICMP_TIMXCEED && type != ICMP_UNREACH &&
	    type != ICMP_PARAMPROB)
		/* Wrong ICMP type for extension */
		return;

	off = icp->icmp_length * sizeof(u_int32_t);
	if (off == 0)
		/*
		 * rfc 4884 Section 5.5: traceroute MUST try to parse
		 * broken ext headers. Again IETF bent over to please
		 * idotic corporations.
		 */
		off = ICMP_EXT_OFFSET;
	else if (off < ICMP_EXT_OFFSET)
		/* rfc 4884 requires an offset of at least 128 bytes */
		return;

	/* make sure that at least one extension is present */
	if (cc < off + sizeof(exthdr) + sizeof(objhdr))
		/* Not enough space for ICMP extensions */
		return;

	cc -= off;
	buf += off;
	memcpy(&exthdr, buf, sizeof(exthdr));

	/* verify version */
	if ((exthdr.ieh_version & ICMP_EXT_HDR_VMASK) != ICMP_EXT_HDR_VERSION)
		return;

	/* verify checksum */
	if (exthdr.ieh_cksum && in_cksum((u_short *)buf, cc))
		return;

	buf += sizeof(exthdr);
	cc -= sizeof(exthdr);

	while (cc > sizeof(objhdr)) {
		memcpy(&objhdr, buf, sizeof(objhdr));
		olen = ntohs(objhdr.ieo_length);

		/* Sanity check the length field */
		if (olen < sizeof(objhdr) || olen > cc)
			return;

		cc -= olen;

		/* Move past the object header */
		buf += sizeof(objhdr);
		olen -= sizeof(objhdr);

		switch (objhdr.ieo_cnum) {
		case ICMP_EXT_MPLS:
			/* RFC 4950: ICMP Extensions for MPLS */
			switch (objhdr.ieo_ctype) {
			case 1:
				first = 0;
				while (olen >= sizeof(u_int32_t)) {
					memcpy(&label, buf, sizeof(u_int32_t));
					label = htonl(label);
					buf += sizeof(u_int32_t);
					olen -= sizeof(u_int32_t);

					if (first == 0) {
						printf(" [MPLS Label ");
						first++;
					} else
						printf(", ");
					printf("%d", MPLS_LABEL(label));
					if (MPLS_EXP(label))
						printf(" (Exp %x)",
						    MPLS_EXP(label));
				}
				if (olen > 0) {
					printf("|]");
					return;
				}
				if (first != 0)
					printf("]");
				break;
			default:
				buf += olen;
				break;
			}
			break;
		case ICMP_EXT_IFINFO:
		default:
			buf += olen;
			break;
		}
	}
}

void
check_tos(struct ip *ip)
{
	struct icmp *icp;
	struct ip *inner_ip;

	icp = (struct icmp *) (((u_char *)ip)+(ip->ip_hl<<2));
	inner_ip = (struct ip *) (((u_char *)icp)+8);

	if (inner_ip->ip_tos != last_tos)
		printf (" (TOS=%d!)", inner_ip->ip_tos);

	last_tos = inner_ip->ip_tos;
}

int
wait_for_reply(int sock, struct msghdr *mhdr)
{
	struct pollfd pfd[1];
	int cc = 0;

	pfd[0].fd = sock;
	pfd[0].events = POLLIN;
	pfd[0].revents = 0;

	if (poll(pfd, 1, waittime * 1000) > 0)
		cc = recvmsg(rcvsock, mhdr, 0);

	return (cc);
}

void
dump_packet(void)
{
	u_char *p;
	int i;

	fprintf(stderr, "packet data:");
	for (p = outpacket, i = 0; i < datalen; i++) {
		if ((i % 24) == 0)
			fprintf(stderr, "\n ");
		fprintf(stderr, " %02x", *p++);
	}
	fprintf(stderr, "\n");
}

void
build_probe4(int seq, u_int8_t ttl, int iflag)
{
	struct ip *ip = (struct ip *)outpacket;
	u_char *p = (u_char *)(ip + 1);
	struct udphdr *up = (struct udphdr *)(p + lsrrlen);
	struct icmp *icmpp = (struct icmp *)(p + lsrrlen);
	struct packetdata *op;
	struct timeval tv;

	ip->ip_len = htons(datalen);
	ip->ip_ttl = ttl;
	ip->ip_id = htons(ident+seq);

	switch (proto) {
	case IPPROTO_ICMP:
		icmpp->icmp_type = icmp_type;
		icmpp->icmp_code = ICMP_CODE;
		icmpp->icmp_seq = htons(seq);
		icmpp->icmp_id = htons(ident);
		op = (struct packetdata *)(icmpp + 1);
		break;
	case IPPROTO_UDP:
		up->uh_sport = htons(ident);
		if (iflag)
			up->uh_dport = htons(port+seq);
		else
			up->uh_dport = htons(port);
		up->uh_ulen = htons((u_short)(datalen - sizeof(struct ip) -
		    lsrrlen));
		up->uh_sum = 0;
		op = (struct packetdata *)(up + 1);
		break;
	default:
		op = (struct packetdata *)(ip + 1);
		break;
	}
	op->seq = seq;
	op->ttl = ttl;
	gettime(&tv);

	/*
	 * We don't want hostiles snooping the net to get any useful
	 * information about us. Send the timestamp in network byte order,
	 * and perturb the timestamp enough that they won't know our
	 * real clock ticker. We don't want to perturb the time by too
	 * much: being off by a suspiciously large amount might indicate
	 * OpenBSD.
	 *
	 * The timestamps in the packet are currently unused. If future
	 * work wants to use them they will have to subtract out the
	 * perturbation first.
	 */
	gettime(&tv);
	op->sec = htonl(tv.tv_sec + sec_perturb);
	op->usec = htonl((tv.tv_usec + usec_perturb) % 1000000);

	if (proto == IPPROTO_ICMP && icmp_type == ICMP_ECHO) {
		icmpp->icmp_cksum = 0;
		icmpp->icmp_cksum = in_cksum((u_short *)icmpp,
		    datalen - sizeof(struct ip) - lsrrlen);
		if (icmpp->icmp_cksum == 0)
			icmpp->icmp_cksum = 0xffff;
	}
}

void
build_probe6(int seq, u_int8_t hops, int iflag, struct sockaddr *to)
{
	struct timeval tv;
	struct packetdata *op;
	int i;

	i = hops;
	if (setsockopt(sndsock, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
	    (char *)&i, sizeof(i)) < 0)
		warn("setsockopt IPV6_UNICAST_HOPS");

	if (iflag)
		((struct sockaddr_in6*)to)->sin6_port = htons(port + seq);
	else
		((struct sockaddr_in6*)to)->sin6_port = htons(port);
	gettime(&tv);

	if (proto == IPPROTO_ICMP) {
		struct icmp6_hdr *icp = (struct icmp6_hdr *)outpacket;

		icp->icmp6_type = ICMP6_ECHO_REQUEST;
		icp->icmp6_code = 0;
		icp->icmp6_cksum = 0;
		icp->icmp6_id = ident;
		icp->icmp6_seq = htons(seq);
		op = (struct packetdata *)(outpacket +
		    sizeof(struct icmp6_hdr));
	} else
		op = (struct packetdata *)outpacket;
	op->seq = seq;
	op->ttl = hops;
	op->sec = htonl(tv.tv_sec);
	op->usec = htonl(tv.tv_usec);
}

void
send_probe(int seq, u_int8_t ttl, int iflag, struct sockaddr *to)
{
	int i;

	switch (to->sa_family) {
	case AF_INET:
		build_probe4(seq, ttl, iflag);
		break;
	case AF_INET6:
		build_probe6(seq, ttl, iflag, to);
		break;
	default:
		errx(1, "unsupported AF: %d", to->sa_family);
		break;
	}

	if (dump)
		dump_packet();

	i = sendto(sndsock, outpacket, datalen, 0, to, to->sa_len);
	if (i < 0 || i != datalen)  {
		if (i < 0)
			warn("sendto");
		printf("%s: wrote %s %d chars, ret=%d\n", __progname, hostname,
		    datalen, i);
		(void) fflush(stdout);
	}
}

double
deltaT(struct timeval *t1p, struct timeval *t2p)
{
	double dt;

	dt = (double)(t2p->tv_sec - t1p->tv_sec) * 1000.0 +
	    (double)(t2p->tv_usec - t1p->tv_usec) / 1000.0;
	return (dt);
}

static char *ttab[] = {
	"Echo Reply",
	"ICMP 1",
	"ICMP 2",
	"Dest Unreachable",
	"Source Quench",
	"Redirect",
	"ICMP 6",
	"ICMP 7",
	"Echo",
	"Router Advert",
	"Router Solicit",
	"Time Exceeded",
	"Param Problem",
	"Timestamp",
	"Timestamp Reply",
	"Info Request",
	"Info Reply",
	"Mask Request",
	"Mask Reply"
};

/*
 * Convert an ICMP "type" field to a printable string.
 */
char *
pr_type(u_int8_t t)
{
	if (t > 18)
		return ("OUT-OF-RANGE");
	return (ttab[t]);
}

int
packet_ok(int af, struct msghdr *mhdr, int cc, int seq, int iflag)
{
	switch (af) {
	case AF_INET:
		return packet_ok4(mhdr, cc, seq, iflag);
		break;
	case AF_INET6:
		return packet_ok6(mhdr, cc, seq, iflag);
		break;
	default:
		errx(1, "unsupported AF: %d", af);
		break;
	}
}

int
packet_ok4(struct msghdr *mhdr, int cc,int seq, int iflag)
{
	struct sockaddr_in *from = (struct sockaddr_in *)mhdr->msg_name;
	struct icmp *icp;
	u_char code;
	char *buf = (char *)mhdr->msg_iov[0].iov_base;
	u_int8_t type;
	int hlen;
	struct ip *ip;

	ip = (struct ip *) buf;
	hlen = ip->ip_hl << 2;
	if (cc < hlen + ICMP_MINLEN) {
		if (verbose)
			printf("packet too short (%d bytes) from %s\n", cc,
			    inet_ntoa(from->sin_addr));
		return (0);
	}
	cc -= hlen;
	icp = (struct icmp *)(buf + hlen);
	type = icp->icmp_type;
	code = icp->icmp_code;
	if ((type == ICMP_TIMXCEED && code == ICMP_TIMXCEED_INTRANS) ||
	    type == ICMP_UNREACH || type == ICMP_ECHOREPLY) {
		struct ip *hip;
		struct udphdr *up;
		struct icmp *icmpp;

		hip = &icp->icmp_ip;
		hlen = hip->ip_hl << 2;

		switch (proto) {
		case IPPROTO_ICMP:
			if (icmp_type == ICMP_ECHO &&
			    type == ICMP_ECHOREPLY &&
			    icp->icmp_id == htons(ident) &&
			    icp->icmp_seq == htons(seq))
				return (-2); /* we got there */

			icmpp = (struct icmp *)((u_char *)hip + hlen);
			if (hlen + 8 <= cc && hip->ip_p == IPPROTO_ICMP &&
			    icmpp->icmp_id == htons(ident) &&
			    icmpp->icmp_seq == htons(seq))
				return (type == ICMP_TIMXCEED? -1 : code + 1);
			break;

		case IPPROTO_UDP:
			up = (struct udphdr *)((u_char *)hip + hlen);
			if (hlen + 12 <= cc && hip->ip_p == proto &&
			    up->uh_sport == htons(ident) &&
			    ((iflag && up->uh_dport == htons(port + seq)) ||
			    (!iflag && up->uh_dport == htons(port))))
				return (type == ICMP_TIMXCEED? -1 : code + 1);
			break;
		default:
			/* this is some odd, user specified proto,
			 * how do we check it?
			 */
			if (hip->ip_p == proto)
				return (type == ICMP_TIMXCEED? -1 : code + 1);
		}
	}
	if (verbose) {
		int i;
		in_addr_t *lp = (in_addr_t *)&icp->icmp_ip;

		printf("\n%d bytes from %s", cc, inet_ntoa(from->sin_addr));
		printf(" to %s", inet_ntoa(ip->ip_dst));
		printf(": icmp type %u (%s) code %d\n", type, pr_type(type),
		    icp->icmp_code);
		for (i = 4; i < cc ; i += sizeof(in_addr_t))
			printf("%2d: x%8.8lx\n", i, (unsigned long)*lp++);
	}
	return (0);
}

int
packet_ok6(struct msghdr *mhdr, int cc, int seq, int iflag)
{
	struct icmp6_hdr *icp;
	struct sockaddr_in6 *from = (struct sockaddr_in6 *)mhdr->msg_name;
	u_char type, code;
	char *buf = (char *)mhdr->msg_iov[0].iov_base;
	struct cmsghdr *cm;
	int *hlimp;
	char hbuf[NI_MAXHOST];
	int useicmp = (proto == IPPROTO_ICMP);

	if (cc < sizeof(struct icmp6_hdr)) {
		if (verbose) {
			if (getnameinfo((struct sockaddr *)from, from->sin6_len,
			    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
				strlcpy(hbuf, "invalid", sizeof(hbuf));
			printf("data too short (%d bytes) from %s\n", cc, hbuf);
		}
		return(0);
	}
	icp = (struct icmp6_hdr *)buf;
	/* get optional information via advanced API */
	rcvpktinfo = NULL;
	hlimp = NULL;
	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
	    cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_PKTINFO &&
		    cm->cmsg_len ==
		    CMSG_LEN(sizeof(struct in6_pktinfo)))
			rcvpktinfo = (struct in6_pktinfo *)(CMSG_DATA(cm));

		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_HOPLIMIT &&
		    cm->cmsg_len == CMSG_LEN(sizeof(int)))
			hlimp = (int *)CMSG_DATA(cm);
	}
	if (rcvpktinfo == NULL || hlimp == NULL) {
		warnx("failed to get received hop limit or packet info");
		rcvhlim = 0;	/*XXX*/
	} else
		rcvhlim = *hlimp;

	type = icp->icmp6_type;
	code = icp->icmp6_code;
	if ((type == ICMP6_TIME_EXCEEDED && code == ICMP6_TIME_EXCEED_TRANSIT)
	    || type == ICMP6_DST_UNREACH) {
		struct ip6_hdr *hip;
		struct udphdr *up;

		hip = (struct ip6_hdr *)(icp + 1);
		if ((up = get_udphdr(hip, (u_char *)(buf + cc))) == NULL) {
			if (verbose)
				warnx("failed to get upper layer header");
			return(0);
		}
		if (useicmp &&
		    ((struct icmp6_hdr *)up)->icmp6_id == ident &&
		    ((struct icmp6_hdr *)up)->icmp6_seq == htons(seq))
			return (type == ICMP6_TIME_EXCEEDED ? -1 : code + 1);
		else if (!useicmp &&
		    up->uh_sport == htons(srcport) &&
		    ((iflag && up->uh_dport == htons(port + seq)) ||
		    (!iflag && up->uh_dport == htons(port))))
			return (type == ICMP6_TIME_EXCEEDED ? -1 : code + 1);
	} else if (useicmp && type == ICMP6_ECHO_REPLY) {
		if (icp->icmp6_id == ident &&
		    icp->icmp6_seq == htons(seq))
			return (ICMP6_DST_UNREACH_NOPORT + 1);
	}
	if (verbose) {
		char sbuf[NI_MAXHOST], dbuf[INET6_ADDRSTRLEN];
		u_int8_t *p;
		int i;

		if (getnameinfo((struct sockaddr *)from, from->sin6_len,
		    sbuf, sizeof(sbuf), NULL, 0, NI_NUMERICHOST) != 0)
			strlcpy(sbuf, "invalid", sizeof(sbuf));
		printf("\n%d bytes from %s to %s", cc, sbuf,
		    rcvpktinfo ? inet_ntop(AF_INET6, &rcvpktinfo->ipi6_addr,
		    dbuf, sizeof(dbuf)) : "?");
		printf(": icmp type %d (%s) code %d\n", type, pr_type(type),
		    icp->icmp6_code);
		p = (u_int8_t *)(icp + 1);
#define WIDTH	16
		for (i = 0; i < cc; i++) {
			if (i % WIDTH == 0)
				printf("%04x:", i);
			if (i % 4 == 0)
				printf(" ");
			printf("%02x", p[i]);
			if (i % WIDTH == WIDTH - 1)
				printf("\n");
		}
		if (cc % WIDTH != 0)
			printf("\n");
	}
	return(0);
}

void
print(struct sockaddr *from, int cc, const char *to)
{
	char hbuf[NI_MAXHOST];
	if (getnameinfo(from, from->sa_len,
	    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
		strlcpy(hbuf, "invalid", sizeof(hbuf));
	if (nflag)
		printf(" %s", hbuf);
	else
		printf(" %s (%s)", inetname(from), hbuf);

	if (Aflag)
		print_asn((struct sockaddr_storage *)from);

	if (verbose)
		printf(" %d bytes to %s", cc, to);
}

/*
 * Increment pointer until find the UDP or ICMP header.
 */
struct udphdr *
get_udphdr(struct ip6_hdr *ip6, u_char *lim)
{
	u_char *cp = (u_char *)ip6, nh;
	int hlen;
	int useicmp = (proto == IPPROTO_ICMP);

	if (cp + sizeof(*ip6) >= lim)
		return(NULL);

	nh = ip6->ip6_nxt;
	cp += sizeof(struct ip6_hdr);

	while (lim - cp >= 8) {
		switch (nh) {
		case IPPROTO_ESP:
		case IPPROTO_TCP:
			return(NULL);
		case IPPROTO_ICMPV6:
			return(useicmp ? (struct udphdr *)cp : NULL);
		case IPPROTO_UDP:
			return(useicmp ? NULL : (struct udphdr *)cp);
		case IPPROTO_FRAGMENT:
			hlen = sizeof(struct ip6_frag);
			nh = ((struct ip6_frag *)cp)->ip6f_nxt;
			break;
		case IPPROTO_AH:
			hlen = (((struct ip6_ext *)cp)->ip6e_len + 2) << 2;
			nh = ((struct ip6_ext *)cp)->ip6e_nxt;
			break;
		default:
			hlen = (((struct ip6_ext *)cp)->ip6e_len + 1) << 3;
			nh = ((struct ip6_ext *)cp)->ip6e_nxt;
			break;
		}

		cp += hlen;
	}

	return(NULL);
}

void
icmp_code(int af, int code, int *got_there, int *unreachable)
{
	switch (af) {
	case AF_INET:
		icmp4_code(code, got_there, unreachable);
		break;
	case AF_INET6:
		icmp6_code(code, got_there, unreachable);
		break;
	default:
		errx(1, "unsupported AF: %d", af);
		break;
	}
}

void
icmp4_code(int code, int *got_there, int *unreachable)
{
	struct ip *ip = (struct ip *)packet;

	switch (code) {
	case ICMP_UNREACH_PORT:
		if (ip->ip_ttl <= 1)
			printf(" !");
		++(*got_there);
		break;
	case ICMP_UNREACH_NET:
		++(*unreachable);
		printf(" !N");
		break;
	case ICMP_UNREACH_HOST:
		++(*unreachable);
		printf(" !H");
		break;
	case ICMP_UNREACH_PROTOCOL:
		++(*got_there);
		printf(" !P");
		break;
	case ICMP_UNREACH_NEEDFRAG:
		++(*unreachable);
		printf(" !F");
		break;
	case ICMP_UNREACH_SRCFAIL:
		++(*unreachable);
		printf(" !S");
		break;
	case ICMP_UNREACH_FILTER_PROHIB:
		++(*unreachable);
		printf(" !X");
		break;
	case ICMP_UNREACH_NET_PROHIB: /*misuse*/
		++(*unreachable);
		printf(" !A");
		break;
	case ICMP_UNREACH_HOST_PROHIB:
		++(*unreachable);
		printf(" !C");
		break;
	case ICMP_UNREACH_NET_UNKNOWN:
	case ICMP_UNREACH_HOST_UNKNOWN:
		++(*unreachable);
		printf(" !U");
		break;
	case ICMP_UNREACH_ISOLATED:
		++(*unreachable);
		printf(" !I");
		break;
	case ICMP_UNREACH_TOSNET:
	case ICMP_UNREACH_TOSHOST:
		++(*unreachable);
		printf(" !T");
		break;
	default:
		++(*unreachable);
		printf(" !<%d>", code);
		break;
	}
}

void
icmp6_code(int code, int *got_there, int *unreachable)
{
	switch (code) {
	case ICMP6_DST_UNREACH_NOROUTE:
		++(*unreachable);
		printf(" !N");
		break;
	case ICMP6_DST_UNREACH_ADMIN:
		++(*unreachable);
		printf(" !P");
		break;
	case ICMP6_DST_UNREACH_NOTNEIGHBOR:
		++(*unreachable);
		printf(" !S");
		break;
	case ICMP6_DST_UNREACH_ADDR:
		++(*unreachable);
		printf(" !A");
		break;
	case ICMP6_DST_UNREACH_NOPORT:
		if (rcvhlim >= 0 && rcvhlim <= 1)
			printf(" !");
		++(*got_there);
		break;
	default:
		++(*unreachable);
		printf(" !<%d>", code);
		break;
	}
}

/*
 * Checksum routine for Internet Protocol family headers (C Version)
 */
u_short
in_cksum(u_short *addr, int len)
{
	u_short *w = addr, answer;
	int nleft = len, sum = 0;

	/*
	 *  Our algorithm is simple, using a 32 bit accumulator (sum),
	 *  we add sequential 16 bit words to it, and at the end, fold
	 *  back all the carry bits from the top 16 bits into the lower
	 *  16 bits.
	 */
	while (nleft > 1)  {
		sum += *w++;
		nleft -= 2;
	}

	/* mop up an odd byte, if necessary */
	if (nleft == 1)
		sum += *(u_char *)w;

	/*
	 * add back carry outs from top 16 bits to low 16 bits
	 */
	sum = (sum >> 16) + (sum & 0xffff);	/* add hi 16 to low 16 */
	sum += (sum >> 16);			/* add carry */
	answer = ~sum;				/* truncate to 16 bits */
	return (answer);
}

/*
 * Construct an Internet address representation.
 */
const char *
inetname(struct sockaddr *sa)
{
	static char line[NI_MAXHOST], domain[HOST_NAME_MAX + 1];
	static int first = 1;
	char *cp;

	if (first) {
		first = 0;
		if (gethostname(domain, sizeof(domain)) == 0 &&
		    (cp = strchr(domain, '.')) != NULL)
			memmove(domain, cp + 1, strlen(cp + 1) + 1);
		else
			domain[0] = 0;
	}
	if (getnameinfo(sa, sa->sa_len, line, sizeof(line), NULL, 0,
	    NI_NAMEREQD) == 0) {
		if ((cp = strchr(line, '.')) != NULL && strcmp(cp + 1,
		    domain) == 0)
			*cp = '\0';
		return (line);
	}

	if (getnameinfo(sa, sa->sa_len, line, sizeof(line), NULL, 0,
	    NI_NUMERICHOST) != 0)
		return ("invalid");
	return (line);
}

void
print_asn(struct sockaddr_storage *ss)
{
	struct rrsetinfo *answers = NULL;
	int counter;
	const u_char *uaddr;
	char qbuf[MAXDNAME];

	switch (ss->ss_family) {
	case AF_INET:
		uaddr = (const u_char *)&((struct sockaddr_in *) ss)->sin_addr;
		if (snprintf(qbuf, sizeof qbuf, "%u.%u.%u.%u."
		    "origin.asn.cymru.com",
		    (uaddr[3] & 0xff), (uaddr[2] & 0xff),
		    (uaddr[1] & 0xff), (uaddr[0] & 0xff)) >= sizeof (qbuf))
			return;
		break;
	case AF_INET6:
		uaddr = (const u_char *)&((struct sockaddr_in6 *) ss)->sin6_addr;
		if (snprintf(qbuf, sizeof qbuf,
		    "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x."
		    "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x."
		    "origin6.asn.cymru.com",
		    (uaddr[15] & 0x0f), ((uaddr[15] >>4)& 0x0f),
		    (uaddr[14] & 0x0f), ((uaddr[14] >>4)& 0x0f),
		    (uaddr[13] & 0x0f), ((uaddr[13] >>4)& 0x0f),
		    (uaddr[12] & 0x0f), ((uaddr[12] >>4)& 0x0f),
		    (uaddr[11] & 0x0f), ((uaddr[11] >>4)& 0x0f),
		    (uaddr[10] & 0x0f), ((uaddr[10] >>4)& 0x0f),
		    (uaddr[9] & 0x0f), ((uaddr[9] >>4)& 0x0f),
		    (uaddr[8] & 0x0f), ((uaddr[8] >>4)& 0x0f),
		    (uaddr[7] & 0x0f), ((uaddr[7] >>4)& 0x0f),
		    (uaddr[6] & 0x0f), ((uaddr[6] >>4)& 0x0f),
		    (uaddr[5] & 0x0f), ((uaddr[5] >>4)& 0x0f),
		    (uaddr[4] & 0x0f), ((uaddr[4] >>4)& 0x0f),
		    (uaddr[3] & 0x0f), ((uaddr[3] >>4)& 0x0f),
		    (uaddr[2] & 0x0f), ((uaddr[2] >>4)& 0x0f),
		    (uaddr[1] & 0x0f), ((uaddr[1] >>4)& 0x0f),
		    (uaddr[0] & 0x0f), ((uaddr[0] >>4)& 0x0f)) >= sizeof (qbuf))
			return;
		break;
	default:
		return;
	}

	if (getrrsetbyname(qbuf, C_IN, T_TXT, 0, &answers) != 0)
		return;
	for (counter = 0; counter < answers->rri_nrdatas; counter++) {
		char *p, *as = answers->rri_rdatas[counter].rdi_data;
		as++; /* skip first byte, it contains length */
		if ((p = strchr(as,'|'))) {
			printf(counter ? ", " : " [");
			p[-1] = 0;
			printf("AS%s", as);
		}
	}
	if (counter)
		printf("]");

	freerrset(answers);
}

int
map_tos(char *s, int *val)
{
	/* DiffServ Codepoints and other TOS mappings */
	const struct toskeywords {
		const char	*keyword;
		int		 val;
	} *t, toskeywords[] = {
		{ "af11",		IPTOS_DSCP_AF11 },
		{ "af12",		IPTOS_DSCP_AF12 },
		{ "af13",		IPTOS_DSCP_AF13 },
		{ "af21",		IPTOS_DSCP_AF21 },
		{ "af22",		IPTOS_DSCP_AF22 },
		{ "af23",		IPTOS_DSCP_AF23 },
		{ "af31",		IPTOS_DSCP_AF31 },
		{ "af32",		IPTOS_DSCP_AF32 },
		{ "af33",		IPTOS_DSCP_AF33 },
		{ "af41",		IPTOS_DSCP_AF41 },
		{ "af42",		IPTOS_DSCP_AF42 },
		{ "af43",		IPTOS_DSCP_AF43 },
		{ "critical",		IPTOS_PREC_CRITIC_ECP },
		{ "cs0",		IPTOS_DSCP_CS0 },
		{ "cs1",		IPTOS_DSCP_CS1 },
		{ "cs2",		IPTOS_DSCP_CS2 },
		{ "cs3",		IPTOS_DSCP_CS3 },
		{ "cs4",		IPTOS_DSCP_CS4 },
		{ "cs5",		IPTOS_DSCP_CS5 },
		{ "cs6",		IPTOS_DSCP_CS6 },
		{ "cs7",		IPTOS_DSCP_CS7 },
		{ "ef",			IPTOS_DSCP_EF },
		{ "inetcontrol",	IPTOS_PREC_INTERNETCONTROL },
		{ "lowdelay",		IPTOS_LOWDELAY },
		{ "netcontrol",		IPTOS_PREC_NETCONTROL },
		{ "reliability",	IPTOS_RELIABILITY },
		{ "throughput",		IPTOS_THROUGHPUT },
		{ NULL,			-1 },
	};

	for (t = toskeywords; t->keyword != NULL; t++) {
		if (strcmp(s, t->keyword) == 0) {
			*val = t->val;
			return (1);
		}
	}

	return (0);
}

void
a922 11
}

void
gettime(struct timeval *tv)
{
	struct timespec ts;

	if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
		err(1, "clock_gettime(CLOCK_MONOTONIC)");

	TIMESPEC_TO_TIMEVAL(tv, &ts);
@


1.144
log
@"source" doesn't need to be a global. While here, the correct spelling
is NULL.
Noticed while trying to hoist the source address selection from
traceroute into ping / ping6.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.143 2015/10/09 01:37:10 deraadt Exp $	*/
d846 1
a846 1
	if (nflag) {
@


1.143
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.142 2015/10/03 02:22:38 deraadt Exp $	*/
a328 1
char *source = 0;
d371 1
a371 1
	char *ep, hbuf[NI_MAXHOST], *dest;
@


1.142
log
@like ping, traceroute is a setuid root priv-drop which holds a sockraw.
we can tame it substantially with "stdio inet", plus "dns" if the -n option
is missing.  a successful exploit against it then cannot create files, or
perform a variety of other operations, as described in the tame(2) man page.

florian helped me a fair bit hoisting initization code upwards in ping,
ping6, and traceroute, to make tame work here.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.141 2015/08/30 22:10:57 florian Exp $	*/
d848 2
a849 2
		if (tame("stdio inet", NULL) == -1)
			err(1, "tame");
d851 2
a852 2
		if (tame("stdio inet dns", NULL) == -1)
			err(1, "tame");
@


1.141
log
@warnx(3) has an implicit \n at the end.
pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.140 2015/07/16 22:47:46 florian Exp $	*/
d846 8
@


1.140
log
@The return type of memset(3) is void. No need for a cast.
No object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.139 2015/03/11 04:05:18 dlg Exp $	*/
d642 1
a642 1
		    "addresses; using %s\n", hostname, hbuf);
@


1.139
log
@port the idea of using clock_gettime(CLOCK_MONOTONIC) for measuring
intervals from src/sbin/ping/ping.c r1.115.

> use clock_gettime(CLOCK_MONOTONIC) to get timestamps to measure the
> interval between sending a ping and getting a reply for it.
>
> this makes it resistant against local wall clock changes, which can
> skew the intervals reported or make them go negative.

this version puts clock_getting in a local gettime() function that
converts to a struct timeval that all the previous callers of
gettimeofday expect to get.

requested by deraadt@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.138 2015/02/11 09:49:38 florian Exp $	*/
d591 2
a592 2
	(void) memset(&to4, 0, sizeof(to4));
	(void) memset(&to6, 0, sizeof(to6));
d713 1
a713 1
			(void) memset(&from4, 0, sizeof(from4));
@


1.138
log
@Replace base 10 strtol with strtonum.
OK krw@@, tedu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.137 2015/02/09 23:00:15 deraadt Exp $	*/
d315 1
d870 1
a870 1
			(void) gettimeofday(&t1, NULL);
d873 1
a873 1
				(void) gettimeofday(&t2, NULL);
d1144 1
a1144 1
	(void) gettimeofday(&tv, NULL);
d1158 1
a1158 1
	(void) gettimeofday(&tv, NULL);
d1187 1
a1187 1
	(void) gettimeofday(&tv, NULL);
d1843 11
@


1.137
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.136 2015/01/20 18:44:16 florian Exp $	*/
d455 2
a456 4
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l < 1 || l > max_ttl)
a457 1
			first_ttl = (u_int8_t)l;
d483 2
a484 5
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l < first_ttl ||
			    l > MAXTTL)
a486 1
			max_ttl = (u_int8_t)l;
d492 2
a493 4
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l <= 0 || l >= 65536)
a494 1
			port = (u_int16_t)l;
d500 2
a501 5
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l < 1 ||
			    l >= IPPROTO_MAX) {
d510 1
a510 2
			} else
				proto = (int)l;
d513 2
a514 4
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l < 1 || l > INT_MAX)
a515 1
			nprobes = (int)l;
a528 2
			errno = 0;
				errstr = NULL;
d530 15
a544 8
				    optarg[1] == 'x')
					tos = (int)strtol(optarg, NULL, 16);
				else
					tos = (int)strtonum(optarg, 0, 255,
					    &errstr);
				if (tos < 0 || tos > 255 || errstr || errno)
					errx(1, "illegal tos value %s",
					    optarg);
d566 2
a567 4
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l <= 1 || l > INT_MAX)
a568 1
			waittime = (int)l;
d646 2
a647 4
		errno = 0;
		ep = NULL;
		l = strtol(*argv, &ep, 10);
		if (errno || !*argv || *ep || l < 0 || l > INT_MAX)
a648 1
		datalen = (int)l;
@


1.136
log
@HOST_NAME_MAX + 1 is big enough for gethostname(3); this array has
been one char too big when it was defined in terms of MAXHOSTNAMELEN.
While here, NI_MAXHOST is big enough for getnameinfo(3).
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.135 2015/01/16 06:40:22 deraadt Exp $	*/
d443 1
a443 1
			Aflag++;
d483 1
a483 1
			ttl_flag++;
d496 1
a496 1
			nflag++;
d562 1
a562 1
			verbose++;
@


1.135
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.134 2014/12/09 17:46:24 millert Exp $	*/
d1462 1
a1462 1
		char sbuf[NI_MAXHOST+1], dbuf[INET6_ADDRSTRLEN];
d1706 1
a1706 1
	static char line[NI_MAXHOST], domain[HOST_NAME_MAX+1 + 1];
@


1.134
log
@Use memmove() instead of strlcpy() for an overlapping string copy
so we don't rely on undefined behavior.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.133 2014/10/25 03:23:49 lteo Exp $	*/
a235 1
#include <sys/param.h>
d267 1
d1706 1
a1706 1
	static char line[NI_MAXHOST], domain[MAXHOSTNAMELEN + 1];
@


1.133
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.132 2014/06/05 14:49:11 florian Exp $	*/
d1714 1
a1714 1
			(void) strlcpy(domain, cp + 1, sizeof(domain));
@


1.132
log
@Reduce code running as root by trying to create all needed sockets
first, remember which failed, drop privs and then decide which sockets
are needed and close the others.
Only error out if the creation of a needed socket failed. That is it
is non-fatal if tracerouting an INET4 address and the INET6 socket
creations failed.
prodding deraadt@@; OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.131 2014/06/04 12:28:39 florian Exp $	*/
a243 1
#include <netinet/in_systm.h>
@


1.131
log
@datalen is additional data, sync traceroute6 to traceroute. Also "nn
byte packets" in the first line of traceroute output is the length of
the complete IP packet, fix this for traceroute6.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.130 2014/06/04 12:20:31 florian Exp $	*/
d360 2
a361 1
	int rcvcmsglen;
d379 12
a390 12
	if (strcmp("traceroute6", __progname) == 0) {
		v6flag = 1;
		if ((rcvsock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0)
			err(5, "socket(ICMPv6)");
		if ((sndsock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
			err(5, "socket(SOCK_DGRAM)");
	} else {
		if ((rcvsock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0)
			err(5, "icmp socket");
		if ((sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
			err(5, "raw socket");
	}
d396 23
@


1.130
log
@Replace ICMP6ECHOLEN define with sizeof()
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.129 2014/05/28 10:29:24 daniel Exp $	*/
d359 1
a359 1
	int ch, i, lsrr = 0, on = 1, probe, seq = 0, tos = 0, error, minlen;
d722 1
d725 17
a741 2
		if (proto == IPPROTO_ICMP)
			minlen = sizeof(struct icmp6_hdr) +
d743 12
a754 7
		else
			minlen = sizeof(struct packetdata);
		if (datalen < minlen)
			datalen = minlen;
		else if (datalen >= IP_MAXPACKET)
			errx(1, "packet size must be %d <= s < %ld.\n", minlen,
			    (long)IP_MAXPACKET);
d847 1
a847 1
	fprintf(stderr, ", %u hops max, %d byte packets\n", max_ttl, datalen);
@


1.129
log
@a void function should not be returning anything.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.128 2014/05/01 18:46:01 jmc Exp $	*/
a328 2
#define ICMP6ECHOLEN 8

d725 2
a726 1
			minlen = ICMP6ECHOLEN + sizeof(struct packetdata);
d1170 2
a1171 1
		op = (struct packetdata *)(outpacket + ICMP6ECHOLEN);
@


1.128
log
@change some argument names in order to give some consistency between traceroute
and traceroute6; i also fudged the formatting to allow SYNOPSIS to display a
bit nicer, and for usage() to look like SYNOPSIS;

ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.127 2014/04/28 09:45:30 deraadt Exp $	*/
d1516 1
a1516 1
		return icmp4_code(code, got_there, unreachable);
d1519 1
a1519 1
		return icmp6_code(code, got_there, unreachable);
@


1.127
log
@whitespace cleanup while reading result of florian's recent (very nice) work
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.126 2014/04/23 09:27:13 florian Exp $	*/
d1802 4
a1805 4
		fprintf(stderr, "usage: traceroute6 [-AcDdIlnSv] [-f firsthop] "
		    "[-m hoplimit]\n"
		    "\t[-p port] [-q probes] [-s src] [-V rtableid] [-w waittime]\n"
		    "\thost [datalen]\n");
d1810 3
a1812 3
		    "\t[-P proto] [-p port] [-q nqueries] [-s src_addr] "
		    "[-t toskeyword]\n"
		    "\t[-V rtable] [-w waittime] host [packetsize]\n",
@


1.126
log
@Merge traceroute6 into traceroute.
Not yet enabled in the build.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.125 2014/04/23 09:22:34 florian Exp $	*/
d748 1
a748 1
	
d930 1
a930 1
			
d966 1
a966 1
	/* verify version */		
d978 1
a978 1
		memcpy(&objhdr, buf, sizeof(objhdr)); 
d981 1
a981 1
		/* Sanity check the length field */	
d1002 1
a1002 1
					
d1015 1
a1015 1
					return;	
d1511 2
a1512 1
void icmp_code(int af, int code, int *got_there, int *unreachable)
d1707 1
a1707 1
		if (snprintf(qbuf, sizeof qbuf, 
d1785 1
a1785 1
		{ NULL, 		-1 },
d1787 1
a1787 1
	
d1794 1
a1794 1
	
d1802 4
a1805 4
	fprintf(stderr, "usage: traceroute6 [-AcDdIlnSv] [-f firsthop] "
	    "[-m hoplimit]\n"
	    "\t[-p port] [-q probes] [-s src] [-V rtableid] [-w waittime]\n"
	    "\thost [datalen]\n");
@


1.125
log
@KNF
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.124 2014/04/23 09:21:41 florian Exp $	*/
d4 29
d249 2
d253 2
d296 1
d298 1
d301 1
d304 1
d323 3
d329 2
d338 1
d352 1
d361 2
a362 1
	int ch, i, lsrr = 0, on = 1, probe, seq = 0, tos = 0, error;
d365 1
d367 1
d371 1
a371 1
	struct ip *ip;
d378 1
d380 12
a391 4
	if ((rcvsock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0)
		err(5, "icmp socket");
	if ((sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
		err(5, "raw socket");
d398 15
d418 2
a419 2
	while ((ch = getopt(argc, argv, "AcDdf:g:Ilm:nP:p:q:Ss:t:V:vw:x"))
			!= -1)
d585 1
d595 1
a595 1
	hints.ai_family = PF_INET;
d610 7
d725 80
d836 1
d839 1
d864 13
a876 1
				}
d879 2
a880 1
					printf(" (%u)", ip->ip_ttl);
d1146 35
d1189 3
d1260 3
d1346 101
d1466 45
d1517 3
d1590 32
d1800 14
a1813 6
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-AcDdIlnSvx] [-f first_ttl] [-g gateway_addr] [-m max_ttl]\n"
	    "\t[-P proto] [-p port] [-q nqueries] [-s src_addr] [-t toskeyword]\n"
	    "\t[-V rtable] [-w waittime] host [packetsize]\n", __progname);
@


1.124
log
@Prepare merge: check AF
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.123 2014/04/23 09:20:59 florian Exp $	*/
d530 1
a530 1
	switch(res->ai_family) {
d569 1
a569 1
	switch(to->sa_family) {
d977 6
a982 6
		case AF_INET:
			build_probe4(seq, ttl, iflag);
			break;
		default:
			errx(1, "unsupported AF: %d", to->sa_family);
			break;
@


1.123
log
@missing break; not reachable
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.122 2014/04/23 09:16:11 florian Exp $	*/
d530 4
a533 2
	if (res->ai_addrlen != sizeof(to4))
	    errx(1, "size of sockaddr mismatch");
d535 7
a541 2
	to = (struct sockaddr *)&to4;
	from = (struct sockaddr *)&from4;
d569 76
a644 4
	switch (proto) {
	case IPPROTO_UDP:
		headerlen = (sizeof(struct ip) + lsrrlen +
		    sizeof(struct udphdr) + sizeof(struct packetdata));
d646 2
a647 3
	case IPPROTO_ICMP:
		headerlen = (sizeof(struct ip) + lsrrlen +
		    sizeof(struct icmp) + sizeof(struct packetdata));
a648 63
	default:
		headerlen = (sizeof(struct ip) + lsrrlen +
		    sizeof(struct packetdata));
	}

	if (datalen < 0 || datalen > IP_MAXPACKET - headerlen)
		errx(1, "packet size must be 0 to %d.",
		    IP_MAXPACKET - headerlen);

	datalen += headerlen;

	if ((outpacket = calloc(1, datalen)) == NULL)
		err(1, "calloc");

	rcviov[0].iov_base = (caddr_t)packet;
	rcviov[0].iov_len = sizeof(packet);
	rcvmhdr.msg_name = (caddr_t)&from4;
	rcvmhdr.msg_namelen = sizeof(from4);
	rcvmhdr.msg_iov = rcviov;
	rcvmhdr.msg_iovlen = 1;
	rcvmhdr.msg_control = NULL;
	rcvmhdr.msg_controllen = 0;

	ip = (struct ip *)outpacket;
	if (lsrr != 0) {
		u_char *p = (u_char *)(ip + 1);

		*p++ = IPOPT_NOP;
		*p++ = IPOPT_LSRR;
		*p++ = lsrrlen - 1;
		*p++ = IPOPT_MINOFF;
		gateway[lsrr] = to4.sin_addr;
		for (i = 1; i <= lsrr; i++) {
			memcpy(p, &gateway[i], sizeof(struct in_addr));
			p += sizeof(struct in_addr);
		}
		ip->ip_dst = gateway[0];
	} else
		ip->ip_dst = to4.sin_addr;
	ip->ip_off = htons(0);
	ip->ip_hl = (sizeof(struct ip) + lsrrlen) >> 2;
	ip->ip_p = proto;
	ip->ip_v = IPVERSION;
	ip->ip_tos = tos;

	if (setsockopt(sndsock, IPPROTO_IP, IP_HDRINCL, (char *)&on,
	    sizeof(on)) < 0)
		err(6, "IP_HDRINCL");

	if (source) {
		(void) memset(&from4, 0, sizeof(from4));
		from4.sin_family = AF_INET;
		if (inet_aton(source, &from4.sin_addr) == 0)
			errx(1, "unknown host %s", source);
		ip->ip_src = from4.sin_addr;
		if (getuid() != 0 &&
		    (ntohl(from4.sin_addr.s_addr) & 0xff000000U) ==
		    0x7f000000U && (ntohl(to4.sin_addr.s_addr) & 0xff000000U)
		    != 0x7f000000U)
			errx(1, "source is on 127/8, destination is not");
		if (getuid() &&
		    bind(sndsock, (struct sockaddr *)&from4, sizeof(from4)) < 0)
			err(1, "bind");
d692 11
a702 7
				ip = (struct ip *)packet;
				if (from4.sin_addr.s_addr != lastaddr) {
					print(from,
					    cc - (ip->ip_hl << 2),
					    inet_ntop(AF_INET, &ip->ip_dst,
					    hbuf, sizeof(hbuf)));
					lastaddr = from4.sin_addr.s_addr;
d707 10
a716 5
				if (i == -2) {
					if (ip->ip_ttl <= 1)
						printf(" !");
					++got_there;
					break;
a717 3

				if (tflag)
					check_tos(ip);
@


1.122
log
@No need to set protocol in hints.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.121 2014/04/23 09:14:49 florian Exp $	*/
d961 1
@


1.121
log
@zap redundant cast
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.120 2014/04/23 09:14:07 florian Exp $	*/
d525 1
a525 1
	hints.ai_protocol = IPPROTO_ICMP;
@


1.120
log
@Introduce check_tos to unclutter the main loop.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.119 2014/04/23 09:13:00 florian Exp $	*/
a688 1
					ip = (struct ip *)packet;
@


1.119
log
@move AF independet setsockopts down
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.118 2014/04/23 09:10:53 florian Exp $	*/
d270 1
d308 1
a317 1
	int last_tos = 0, tos_returned;
d324 1
a324 2
	struct ip *ip, *inner_ip;
	struct icmp *icp;
d696 2
a697 9
				icp = (struct icmp *) (((u_char *)ip)+(ip->ip_hl<<2));
				inner_ip = (struct ip *) (((u_char *)icp)+8);

				tos_returned = inner_ip->ip_tos;

				if (tflag && (tos_returned != last_tos))
					printf (" (TOS=%d!)", tos_returned);

				last_tos = tos_returned;
d837 15
@


1.118
log
@Add error checking to sysctl. While there pass in an int otherwise
it failes with ENOMEM in traceroute.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.117 2014/04/23 08:58:26 florian Exp $	*/
a615 6
	if (options & SO_DEBUG)
		(void) setsockopt(rcvsock, SOL_SOCKET, SO_DEBUG,
		    (char *)&on, sizeof(on));
	if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *)&datalen,
	    sizeof(datalen)) < 0)
		err(6, "SO_SNDBUF");
a618 3
	if (options & SO_DEBUG)
		(void) setsockopt(sndsock, SOL_SOCKET, SO_DEBUG,
		    (char *)&on, sizeof(on));
d635 11
@


1.117
log
@Prepare for merge: s/icmp_code/icmp4_code/ and use icmp_code for
the AF switch.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.116 2014/04/23 08:55:42 florian Exp $	*/
d318 1
a318 1
	size_t size = sizeof(max_ttl);
d342 4
a345 2
	(void) sysctl(mib, sizeof(mib)/sizeof(mib[0]), &max_ttl, &size,
	    NULL, 0);
@


1.116
log
@Prepare for merge: s/packet_ok/packet_ok4/ and use packet_ok
for the AF switch.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.115 2014/04/23 08:50:27 florian Exp $	*/
d266 2
a267 1
void icmp_code(int, int *, int *);
d705 2
a706 1
				icmp_code(i - 1, &got_there, &unreachable);
d1117 12
d1130 1
a1130 1
icmp_code(int code, int *got_there, int *unreachable)
@


1.115
log
@Prepare merge: introduce struct sockaddr *from, *to to be used in
AF independet places.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.114 2014/04/23 08:47:16 florian Exp $	*/
d264 2
a265 1
int packet_ok(struct msghdr *, int, int, int);
d667 2
a668 1
				i = packet_ok(&rcvmhdr, cc, seq, incflag);
d1007 14
a1020 1
packet_ok(struct msghdr *mhdr, int cc,int seq, int iflag)
@


1.114
log
@Prepare merge: s/to/to4/; s/from/from4/
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.113 2014/04/23 08:44:50 florian Exp $	*/
d318 1
d529 4
a532 1
	memcpy(&to4, res->ai_addr, res->ai_addrlen);
d641 1
a641 1
	if (getnameinfo((struct sockaddr *)&to4, to4.sin_len, hbuf,
d663 1
a663 1
			send_probe(++seq, ttl, incflag, (struct sockaddr*)&to4);
d672 1
a672 1
					print((struct sockaddr *)&from4,
@


1.113
log
@Make this compile with -Wall et al.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.112 2014/04/21 14:26:10 florian Exp $	*/
d317 1
a317 1
	struct sockaddr_in from, to;
d508 1
a508 1
	(void) memset(&to, 0, sizeof(to));
d510 1
a510 1
	if (inet_aton(*argv, &to.sin_addr) != 0) {
d512 1
a512 1
		if ((dest = strdup(inet_ntoa(to.sin_addr))) == NULL)
d525 1
a525 1
	if (res->ai_addrlen != sizeof(to))
d528 1
a528 1
	memcpy(&to, res->ai_addr, res->ai_addrlen);
d579 2
a580 2
	rcvmhdr.msg_name = (caddr_t)&from;
	rcvmhdr.msg_namelen = sizeof(from);
d594 1
a594 1
		gateway[lsrr] = to.sin_addr;
d601 1
a601 1
		ip->ip_dst = to.sin_addr;
d622 3
a624 3
		(void) memset(&from, 0, sizeof(struct sockaddr));
		from.sin_family = AF_INET;
		if (inet_aton(source, &from.sin_addr) == 0)
d626 1
a626 1
		ip->ip_src = from.sin_addr;
d628 3
a630 2
		    (ntohl(from.sin_addr.s_addr) & 0xff000000U) == 0x7f000000U &&
		    (ntohl(to.sin_addr.s_addr) & 0xff000000U) != 0x7f000000U)
d633 1
a633 1
		    bind(sndsock, (struct sockaddr *)&from, sizeof(from)) < 0)
d637 1
a637 1
	if (getnameinfo((struct sockaddr *)&to, to.sin_len, hbuf,
d659 1
a659 1
			send_probe(++seq, ttl, incflag, (struct sockaddr*)&to);
d667 2
a668 2
				if (from.sin_addr.s_addr != lastaddr) {
					print((struct sockaddr *)&from,
d672 1
a672 1
					lastaddr = from.sin_addr.s_addr;
@


1.112
log
@Revert 1.101 as it breaks source port selection. This needs more
thought / code shuffling.
Reported by deraadt@@ and sthen@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.111 2014/04/19 14:06:10 florian Exp $	*/
d314 1
a314 1
	int last_tos, tos_returned;
a327 1
	socklen_t len;
a650 1
		quad_t dt;
d1230 1
a1230 1
	char qbuf[MAXDNAME], *qp;
@


1.111
log
@Fix display of destination IP when host is an IP address.
Pointed out by and OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.110 2014/04/18 17:01:47 florian Exp $	*/
a236 2
#define DUMMY_PORT 10010

a291 1
u_int16_t srcport;
d503 1
a503 1
	ident = getpid() & 0xffff;
a621 1
	(void) memset(&from, 0, sizeof(struct sockaddr));
d623 1
d632 3
a634 14
	} else {
		struct sockaddr_in nxt;
		int dummy;

		nxt = to;
		nxt.sin_port = htons(DUMMY_PORT);
		if ((dummy = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
			err(1, "socket");
		if (connect(dummy, (struct sockaddr *)&nxt, sizeof(nxt)) < 0)
			err(1, "connect");
		len = sizeof(from);
		if (getsockname(dummy, (struct sockaddr *)&from, &len) < 0)
			err(1, "getsockname");
		close(dummy);
a635 8
	from.sin_port = htons(0);
	if (bind(sndsock, (struct sockaddr *)&from, sizeof(from)) < 0)
		err(1, "bind sndsock");

	len = sizeof(from);
	if (getsockname(sndsock, (struct sockaddr *)&from, &len) < 0)
		err(1, "getsockname");
	srcport = ntohs(from.sin_port);
d889 1
a889 1
		up->uh_sport = htons(srcport);
d1051 1
a1051 1
			    up->uh_sport == htons(srcport) &&
@


1.110
log
@Wrap long lines.
OK lteo@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.109 2014/04/18 17:01:06 florian Exp $	*/
d326 1
a326 1
	char *ep, hbuf[NI_MAXHOST];
d512 3
a514 3
	(void) memset(&to, 0, sizeof(struct sockaddr));
	to.sin_family = AF_INET;
	if (inet_aton(*argv, &to.sin_addr) != 0)
d516 20
a535 15
	else {
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = PF_INET;
		hints.ai_socktype = SOCK_RAW;
		hints.ai_protocol = IPPROTO_ICMP;
		hints.ai_flags = AI_CANONNAME;
		if ((error = getaddrinfo(*argv, NULL, &hints, &res)))
			errx(1, "%s", gai_strerror(error));

		if (res->ai_addrlen != sizeof(to))
		    errx(1, "size of sockaddr mismatch");

		memcpy(&to, res->ai_addr, res->ai_addrlen);
		hostname = res->ai_canonname ? strdup(res->ai_canonname) :
		    *argv;
d538 1
d540 6
a545 7
		if (res->ai_next) {
			if (getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
			    sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
				strlcpy(hbuf, "?", sizeof(hbuf));
			warnx("Warning: %s has multiple "
			    "addresses; using %s\n", hostname, hbuf);
		}
d547 2
@


1.109
log
@Move ident / perturb initialisation up, this is AF independent.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.108 2014/04/18 17:00:07 florian Exp $	*/
d376 2
a377 1
				memcpy(&gateway[lsrr], hp->h_addr, hp->h_length);
d428 2
a429 1
					errx(1, "proto must be >=1, or a name.");
@


1.108
log
@sync to traceroute6: use getnameinfo for destination ip
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.107 2014/04/18 16:58:02 florian Exp $	*/
d504 6
a601 6

	ident = getpid() & 0xffff;
	tmprnd = arc4random();
	sec_perturb = (tmprnd & 0x80000000) ? -(tmprnd & 0x7ff) :
	    (tmprnd & 0x7ff);
	usec_perturb = arc4random();
@


1.107
log
@Declare socklen_t len in main, it's used in two places, no need
to declare it twice. We can get rid of a { } block.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.106 2014/04/18 16:46:18 florian Exp $	*/
d650 4
a653 2
	fprintf(stderr, "traceroute to %s (%s)", hostname,
		inet_ntoa(to.sin_addr));
@


1.106
log
@Use getaddrinfo to resolve destination. I kept the inet_aton so the
great old ones can still traceroute 010.010.010.010.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.105 2014/04/18 16:32:42 florian Exp $	*/
d331 1
a628 1
		socklen_t len;
d645 4
a648 2
	{
		socklen_t len;
a649 5
		len = sizeof(from);
		if (getsockname(sndsock, (struct sockaddr *)&from, &len) < 0)
			err(1, "getsockname");
		srcport = ntohs(from.sin_port);
	}
@


1.105
log
@We do have SO_SNDBUF and IP_HDRINCL.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.104 2014/04/18 16:29:26 florian Exp $	*/
d316 1
a316 1
	int ch, i, lsrr = 0, on = 1, probe, seq = 0, tos = 0;
d318 1
d508 24
a531 10
		hp = gethostbyname(*argv);
		if (hp == 0)
			errx(1, "unknown host %s", *argv);
		to.sin_family = hp->h_addrtype;
		memcpy(&to.sin_addr, hp->h_addr, hp->h_length);
		if ((hostname = strdup(hp->h_name)) == NULL)
			err(1, "malloc");
		if (hp->h_addr_list[1] != NULL)
			warnx("Warning: %s has multiple addresses; using %s",
			    hostname, inet_ntoa(to.sin_addr));
@


1.104
log
@replace perror(3) with err(3)/warn(3)
OK lteo@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.103 2014/04/18 16:24:41 florian Exp $	*/
a589 1
#ifdef SO_SNDBUF
a592 2
#endif /* SO_SNDBUF */
#ifdef IP_HDRINCL
a595 1
#endif /* IP_HDRINCL */
@


1.103
log
@move cast from packet to ip up to avoid casts in print()
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.102 2014/04/18 16:22:18 florian Exp $	*/
d621 4
a624 8
		if ((dummy = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
			perror("socket");
			exit(1);
		}
		if (connect(dummy, (struct sockaddr *)&nxt, sizeof(nxt)) < 0) {
			perror("connect");
			exit(1);
		}
d626 2
a627 4
		if (getsockname(dummy, (struct sockaddr *)&from, &len) < 0) {
			perror("getsockname");
			exit(1);
		}
d631 2
a632 4
	if (bind(sndsock, (struct sockaddr *)&from, sizeof(from)) < 0) {
		perror("bind sndsock");
		exit(1);
	}
d638 2
a639 4
		if (getsockname(sndsock, (struct sockaddr *)&from, &len) < 0) {
			perror("getsockname");
			exit(1);
		}
d954 1
a954 1
			perror("sendto");
@


1.102
log
@move ICMP code parsing to function
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.101 2014/04/18 16:19:11 florian Exp $	*/
d680 1
d683 2
a684 3
					    (cc - (((struct ip*)packet)->ip_hl
					    <<2)), inet_ntop(AF_INET,
					    &((struct ip*)packet)->ip_dst,
a688 1
				ip = (struct ip *)packet;
@


1.101
log
@If -s is not given do a dummy connect to get outgoing ip,
unconditionally try to bind to this ip and get a source port for udp
this way, like traceroute6 is doing.  This means you can no longer
traceroute from IPs not present on the system. (There are probably
better tools if you want to send traffic from spoofed IPs.)
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.100 2014/04/18 16:04:39 florian Exp $	*/
d267 1
d299 1
a299 1
u_char  icmp_code = 0;
a670 1
			int code;
d713 1
a713 59
				code = i - 1;
				switch (code) {
				case ICMP_UNREACH_PORT:
					ip = (struct ip *)packet;
					if (ip->ip_ttl <= 1)
						printf(" !");
					++got_there;
					break;
				case ICMP_UNREACH_NET:
					++unreachable;
					printf(" !N");
					break;
				case ICMP_UNREACH_HOST:
					++unreachable;
					printf(" !H");
					break;
				case ICMP_UNREACH_PROTOCOL:
					++got_there;
					printf(" !P");
					break;
				case ICMP_UNREACH_NEEDFRAG:
					++unreachable;
					printf(" !F");
					break;
				case ICMP_UNREACH_SRCFAIL:
					++unreachable;
					printf(" !S");
					break;
				case ICMP_UNREACH_FILTER_PROHIB:
					++unreachable;
					printf(" !X");
					break;
				case ICMP_UNREACH_NET_PROHIB: /*misuse*/
					++unreachable;
					printf(" !A");
					break;
				case ICMP_UNREACH_HOST_PROHIB:
					++unreachable;
					printf(" !C");
					break;
				case ICMP_UNREACH_NET_UNKNOWN:
				case ICMP_UNREACH_HOST_UNKNOWN:
					++unreachable;
					printf(" !U");
					break;
				case ICMP_UNREACH_ISOLATED:
					++unreachable;
					printf(" !I");
					break;
				case ICMP_UNREACH_TOSNET:
				case ICMP_UNREACH_TOSHOST:
					++unreachable;
					printf(" !T");
					break;
				default:
					++unreachable;
					printf(" !<%d>", i - 1);
					break;
				}
d897 1
a897 1
		icmpp->icmp_code = icmp_code;
d1109 64
@


1.100
log
@sync packet_ok signature to traceroute6
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.99 2014/04/18 15:58:43 florian Exp $	*/
d237 2
d293 1
d580 1
a580 1
	ident = (getpid() & 0xffff) | 0x8000;
d603 1
a604 1
		(void) memset(&from, 0, sizeof(struct sockaddr));
d613 30
d644 6
a649 3
		if (getuid() &&
		    bind(sndsock, (struct sockaddr *)&from, sizeof(from)) < 0)
			err(1, "bind");
a650 1

d961 1
a961 1
		up->uh_sport = htons(ident);
d1123 1
a1123 1
			    up->uh_sport == htons(ident) &&
@


1.99
log
@Factor out build_probe{4,6} from send_probe; now send_probe is
AF independent. While there define outpacket as u_char and
cast as needed in traceroute6.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.98 2014/04/18 08:44:25 florian Exp $	*/
d264 1
a264 1
int packet_ok(u_char *, int, struct sockaddr_in *, int, int);
d641 1
a641 1
				i = packet_ok(packet, cc, &from, seq, incflag);
d1039 1
a1039 1
packet_ok(u_char *buf, int cc, struct sockaddr_in *from, int seq, int iflag)
d1041 1
d1044 1
@


1.98
log
@We are not ARCHAIC; no object change.
OK lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.97 2014/03/29 11:19:41 florian Exp $	*/
d262 2
a263 1
void send_probe(int, u_int8_t, int, struct sockaddr_in *);
d305 2
d638 1
a638 1
			send_probe(++seq, ttl, incflag, &to);
d904 1
a904 1
send_probe(int seq, u_int8_t ttl, int iflag, struct sockaddr_in *to)
a911 1
	int i;
d967 14
d985 1
a985 2
	i = sendto(sndsock, outpacket, datalen, 0, (struct sockaddr *)to,
	    sizeof(struct sockaddr_in));
d989 1
a989 1
		printf("traceroute: wrote %s %d chars, ret=%d\n", hostname,
@


1.97
log
@use deltaT to calculate time intervalls; reduces diff to traceroute6
OK benno@@, lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.96 2014/03/29 11:18:39 florian Exp $	*/
a654 1
#ifndef ARCHAIC
a657 1
#endif
a677 1
#ifndef ARCHAIC
a680 1
#endif /* ARCHAIC */
a1029 1
#ifndef ARCHAIC
a1041 3
#else
	icp = (struct icmp *)buf;
#endif /* ARCHAIC */
a1083 1
#ifndef ARCHAIC
a1094 1
#endif /* ARCHAIC */
@


1.96
log
@use iovec in wait_for_reply; reduces diff to traceroute6
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.95 2014/03/24 11:11:49 mpi Exp $	*/
d272 1
d650 1
a650 6
				dt = (quad_t)(t2.tv_sec - t1.tv_sec) * 1000000 +
				    (quad_t)(t2.tv_usec - t1.tv_usec);
				printf("  %u", (u_int)(dt / 1000));
				if (dt % 1000)
					printf(".%u", (u_int)(dt % 1000));
				printf(" ms");
d982 10
@


1.95
log
@Remove "-r" option from ping(8) and traceroute{,6}(8).  You've probably
never heard about it, it was to bypass the routing tables, not available
for IPv6 and we're going to always use the routing tables soon.

ok florian@@, man pages ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.94 2014/03/18 10:11:36 florian Exp $	*/
d210 1
d229 1
d260 1
a260 1
int wait_for_reply(int, struct sockaddr_in *, struct timeval *);
d277 3
d542 9
d635 1
a635 1
			while ((cc = wait_for_reply(rcvsock, &from, &t1))) {
a636 4
				if (t2.tv_sec - t1.tv_sec > waittime) {
					cc = 0;
					break;
				}
d878 1
a878 1
wait_for_reply(int sock, struct sockaddr_in *from, struct timeval *sent)
d880 6
a885 19
	socklen_t fromlen = sizeof (*from);
	struct timeval now, wait;
	int cc = 0, fdsn;
	fd_set *fdsp;

	fdsn = howmany(sock+1, NFDBITS) * sizeof(fd_mask);
	if ((fdsp = (fd_set *)malloc(fdsn)) == NULL)
		err(1, "malloc");
	memset(fdsp, 0, fdsn);
	FD_SET(sock, fdsp);
	gettimeofday(&now, NULL);
	wait.tv_sec = (sent->tv_sec + waittime) - now.tv_sec;
	wait.tv_usec =  sent->tv_usec - now.tv_usec;
	if (wait.tv_usec < 0) {
		wait.tv_usec += 1000000;
		wait.tv_sec--;
	}
	if (wait.tv_sec < 0)
		timerclear(&wait);
d887 2
a888 3
	if (select(sock+1, fdsp, (fd_set *)0, (fd_set *)0, &wait) > 0)
		cc = recvfrom(rcvsock, (char *)packet, sizeof(packet), 0,
		    (struct sockaddr *)from, &fromlen);
a889 1
	free(fdsp);
@


1.94
log
@Make print AF independet and use it in traceroute and traceroute6.
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.93 2014/03/18 10:11:00 florian Exp $	*/
d331 1
a331 1
	while ((ch = getopt(argc, argv, "AcDdf:g:Ilm:nP:p:q:rSs:t:V:vw:x"))
a423 3
		case 'r':
			options |= SO_DONTROUTE;
			break;
a580 3
	if (options & SO_DONTROUTE)
		(void) setsockopt(sndsock, SOL_SOCKET, SO_DONTROUTE,
		    (char *)&on, sizeof(on));
d1307 1
a1307 1
	    "usage: %s [-AcDdIlnrSvx] [-f first_ttl] [-g gateway_addr] [-m max_ttl]\n"
@


1.93
log
@Sync inetname from traceroute6 and thereby make it AF independent.
While there drop the !nflag check as it's never called with nflag set,
simplify the code a bit and adapt style from traceroute.
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.92 2014/03/18 10:10:17 florian Exp $	*/
d264 1
a264 1
void print(u_char *, int, struct sockaddr_in *);
d312 1
a312 1
	char *ep;
d638 5
a642 1
					print(packet, cc, &from);
d1114 1
a1114 1
print(u_char *buf, int cc, struct sockaddr_in *from)
d1116 4
a1119 7
	struct ip *ip;
	int hlen;

	ip = (struct ip *) buf;
	hlen = ip->ip_hl << 2;
	cc -= hlen;

d1121 1
a1121 1
		printf(" %s", inet_ntoa(from->sin_addr));
d1123 2
a1124 2
		printf(" %s (%s)", inetname((struct sockaddr*)from),
		    inet_ntoa(from->sin_addr));
d1129 1
a1129 1
		printf(" %d bytes to %s", cc, inet_ntoa(ip->ip_dst));
a1130 1

@


1.92
log
@AF independent print_asn
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.91 2014/03/18 10:08:58 florian Exp $	*/
d265 1
a265 1
char *inetname(struct in_addr);
d1122 1
a1122 1
		printf(" %s (%s)", inetname(from->sin_addr),
d1168 2
a1169 2
char *
inetname(struct in_addr in)
d1171 1
a1171 1
	static char domain[MAXHOSTNAMELEN], line[MAXHOSTNAMELEN];
a1172 1
	struct hostent *hp;
d1177 5
a1181 4
		if (gethostname(domain, sizeof domain) == 0 &&
		    (cp = strchr(domain, '.')) != NULL) {
			strlcpy(domain, cp + 1, sizeof(domain));
		}
d1183 6
a1188 9
	if (in.s_addr != INADDR_ANY) {
		hp = gethostbyaddr((char *)&in, sizeof(in), AF_INET);
		if (hp != NULL) {
			if ((cp = strchr(hp->h_name, '.')) != NULL &&
			    strcmp(cp + 1, domain) == 0)
				*cp = '\0';
			strlcpy(line, hp->h_name, sizeof(line));
			return (line);
		}
d1190 5
a1194 1
	return (inet_ntoa(in));
@


1.91
log
@Wrap long line.
OK lteo, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.90 2014/03/10 19:58:06 florian Exp $	*/
d266 1
a266 1
void print_asn(struct in_addr);
d1125 1
a1125 1
		print_asn(from->sin_addr);
d1197 1
a1197 1
print_asn(struct in_addr in)
d1199 1
a1199 1
	const u_char *uaddr = (const u_char *)&in.s_addr;
d1201 2
a1202 2
	struct rrsetinfo *answers = NULL;
	char qbuf[MAXDNAME];
d1204 34
a1237 3
	if (snprintf(qbuf, sizeof qbuf, "%u.%u.%u.%u.origin.asn.cymru.com",
	    (uaddr[3] & 0xff), (uaddr[2] & 0xff),
	    (uaddr[1] & 0xff), (uaddr[0] & 0xff)) >= sizeof (qbuf))
d1239 2
@


1.90
log
@12_malloc_memset_to_calloc.msg
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.89 2014/03/10 19:56:58 florian Exp $	*/
d748 2
a749 1
		if (got_there || (unreachable && (unreachable + timeout) >= nprobes))
@


1.89
log
@10_setvbuf.msg
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.88 2014/01/24 15:26:32 florian Exp $	*/
d537 2
a538 4
	outpacket = malloc(datalen);
	if (outpacket == 0)
		err(1, "malloc");
	(void) memset(outpacket, 0, datalen);
@


1.88
log
@Implement -D; from traceroute; reduces diff to traceroute.
While here add dump() prototype in traceroute
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.87 2014/01/24 15:24:06 florian Exp $	*/
d490 1
a490 1
	setlinebuf (stdout);
@


1.87
log
@Sort getopt cases, reduces diff to traceroute6
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.86 2014/01/24 15:19:51 florian Exp $	*/
d259 1
@


1.86
log
@It's an error to have more than 2 arguments; reduces diff to traceroute6
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.85 2014/01/24 15:17:33 florian Exp $	*/
a332 3
		case 'S':
			sump = 1;
			break;
a335 8
		case 'f':
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l < 1 || l > max_ttl)
				errx(1, "min ttl must be 1 to %u.", max_ttl);
			first_ttl = (u_int8_t)l;
			break;
d345 8
d432 3
@


1.85
log
@Sync "port" type to traceroute6; reduces diff to traceroute6
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.84 2014/01/24 15:06:59 florian Exp $	*/
d486 1
a486 1
	if (argc < 1)
@


1.84
log
@rename s to rcvsock
Reduces diff to traceroute6 and is easier to search for.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.83 2013/11/12 19:36:29 deraadt Exp $	*/
d284 1
a284 1
u_short port = 32768+666;	/* start udp dest port # for probe packets */
d397 1
a397 1
			port = (int)l;
@


1.83
log
@prototypes, some pleasing of gcc, and cleanup an unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.82 2012/02/10 23:05:54 deraadt Exp $	*/
d271 1
a271 1
int s;				/* receive (icmp) socket file descriptor */
d317 1
a317 1
	if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0)
d465 1
a465 1
			if (setsockopt(s, SOL_SOCKET, SO_RTABLE,
d570 1
a570 1
		(void) setsockopt(s, SOL_SOCKET, SO_DEBUG,
d628 1
a628 1
			while ((cc = wait_for_reply(s, &from, &t1))) {
d893 1
a893 1
		cc = recvfrom(s, (char *)packet, sizeof(packet), 0,
@


1.82
log
@bail on AS translation in impossible condition; ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.81 2012/02/10 22:51:28 sthen Exp $	*/
d261 1
d267 1
d1200 1
a1200 1
	int i, counter;
d1213 1
a1213 1
		if (p = strchr(as,'|')) {
@


1.81
log
@Use MAXDNAME not MAXDNAME+1 and remove unnecessary return.
Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.80 2012/01/12 11:25:08 sthen Exp $	*/
d1202 1
a1202 1
	(void) snprintf(qbuf, sizeof qbuf, "%u.%u.%u.%u.origin.asn.cymru.com",
d1204 2
a1205 1
	    (uaddr[1] & 0xff), (uaddr[0] & 0xff));
@


1.80
log
@Zap unused var in asn_lookup; from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.79 2011/11/08 12:16:54 sthen Exp $	*/
d1200 1
a1200 1
	char qbuf[MAXDNAME+1];
a1219 1
	return;
@


1.79
log
@Add -A option to display AS for each hop address, using origin.asn.cymru.com
DNS lookups. ok deraadt@@, henning likes it but would like some changes which
can be done after commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.78 2011/09/17 14:10:05 haesbaert Exp $	*/
d1198 1
a1198 1
	int n, i, counter;
d1205 1
a1205 1
	if (n = getrrsetbyname(qbuf, C_IN, T_TXT, 0, &answers))
@


1.78
log
@Standarize the ToS option across nc/ping/traceroute so that they'll
accept the same values as pf.conf. It accepts decimal, hexadecimal and
the dscp/tos keywords. The ping option was ripped of in SMALL.

ok mcbride@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.77 2011/06/21 17:31:07 mikeb Exp $	*/
d222 1
d264 1
d293 1
d328 1
a328 1
	while ((ch = getopt(argc, argv, "cDdf:g:Ilm:nP:p:q:rSs:t:V:vw:x"))
d334 3
d1122 2
d1194 29
d1277 1
a1277 1
	    "usage: %s [-cDdIlnrSvx] [-f first_ttl] [-g gateway_addr] [-m max_ttl]\n"
@


1.77
log
@Convert SO_RTABLE's protocol level to the SOL_SOCKET;  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.76 2011/04/23 10:00:13 sthen Exp $	*/
d264 1
d429 1
d431 11
a441 5
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l < 0 || l > 255)
				errx(1, "tos must be 0 to 255.");
			last_tos = tos = (int)l;
d443 1
d1186 48
d1241 1
a1241 1
	    "\t[-P proto] [-p port] [-q nqueries] [-s src_addr] [-t tos]\n"
@


1.76
log
@Only print changed TOS in returned packets when -t is set (last commit was
supposed to do this but I missed a piece). ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.75 2011/04/06 12:05:00 sthen Exp $	*/
d445 1
a445 1
			if (setsockopt(sndsock, IPPROTO_IP, SO_RTABLE,
d448 1
a448 1
			if (setsockopt(s, IPPROTO_IP, SO_RTABLE,
@


1.75
log
@When specifying tos with -t, display a message if the returned packet
has a different tos type. ok claudio@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.74 2011/03/22 10:16:23 okan Exp $	*/
d289 1
d434 1
d649 1
a649 1
				if (tos_returned != last_tos)
@


1.74
log
@use timerclear macro

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.73 2010/09/13 10:09:00 claudio Exp $	*/
d296 1
d301 2
a302 1
	struct ip *ip;
d432 1
a432 1
			tos = (int)l;
d641 11
@


1.73
log
@Reduce the output of MPLS information without removing information.
This gives a more compact output.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.72 2010/07/09 12:27:09 dhill Exp $	*/
d858 1
a858 1
		wait.tv_sec = wait.tv_usec = 0;
@


1.72
log
@inetname is only called when !nflag.  There is no need to again check for
!nflag within inetname().

from Alexandr Shadchin

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.71 2010/07/08 20:23:03 claudio Exp $	*/
d757 1
a757 1
	else if (off < 128)
d808 1
a808 1
						printf(" [MPLS: ");
d812 4
a815 3
					printf("Label %d Exp %d",
						MPLS_LABEL(label), 
						MPLS_EXP(label));
@


1.71
log
@Let traceroute parse extended ICMP messages as defined by RFC 4884.
Currently only the MPLS label can be shown (RFC 4950). The extended
information is only printed if either -x or -v was used.
Initialy based on a port from NetBSD done by dhill@@ but mostly rewritten now.
OK deraadt@@, dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.70 2010/07/05 21:44:48 robert Exp $	*/
a1131 2
 * If the nflag has been supplied, give
 * numeric value, otherwise try for symbolic name.
d1141 1
a1141 1
	if (first && !nflag) {
d1148 1
a1148 1
	if (!nflag && in.s_addr != INADDR_ANY) {
@


1.70
log
@Change SO_RDOMAIN to SO_RTABLE in err() after the recent "rename".
It seems this one was missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.69 2010/07/03 04:44:52 guenther Exp $	*/
d223 2
d234 4
a237 1
#define	MAX_LSRR	((MAX_IPOPTLEN - 4) / 4)
d260 1
d288 1
d321 2
a322 1
	while ((ch = getopt(argc, argv, "cDdf:g:Ilm:nP:p:q:rSs:t:V:vw:")) != -1)
d456 3
d709 3
a711 1
			}
d723 113
d1093 1
a1093 1
		printf(" %d bytes to %s", cc, inet_ntoa (ip->ip_dst));
d1169 1
a1169 1
	    "usage: %s [-cDdIlnrSv] [-f first_ttl] [-g gateway_addr] [-m max_ttl]\n"
@


1.69
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.68 2009/10/27 23:59:57 deraadt Exp $	*/
d435 1
a435 1
				err(1, "setsockopt SO_RDOMAIN");
d438 1
a438 1
				err(1, "setsockopt SO_RDOMAIN");
@


1.68
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.67 2009/06/05 00:10:01 claudio Exp $	*/
d298 2
a299 1
	uid_t uid, rdomain;
d428 1
a428 1
			rdomain = (unsigned int)strtonum(optarg, 0,
d431 1
a431 1
				errx(1, "rdomain value is %s: %s",
d433 2
a434 2
			if (setsockopt(sndsock, IPPROTO_IP, SO_RDOMAIN,
			    &rdomain, sizeof(rdomain)) == -1)
d436 2
a437 2
			if (setsockopt(s, IPPROTO_IP, SO_RDOMAIN,
			    &rdomain, sizeof(rdomain)) == -1)
d1045 1
a1045 1
	    "\t[-V rdomain] [-w waittime] host [packetsize]\n", __progname);
@


1.67
log
@Use -V to specify an alternate routing domain.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.66 2008/10/04 02:21:49 deraadt Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)traceroute.c	8.1 (Berkeley) 6/6/93";*/
#else
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.66 2008/10/04 02:21:49 deraadt Exp $";
#endif
#endif /* not lint */
@


1.66
log
@explicitly pad & pack the packetdata structure thrown around on the wire,
just like in traceroute6.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.65 2006/03/31 03:05:57 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.65 2006/03/31 03:05:57 deraadt Exp $";
d310 1
d312 1
a312 1
	uid_t uid;
d327 1
a327 1
	while ((ch = getopt(argc, argv, "SDIdg:f:m:np:q:rs:t:w:vlP:c")) != -1)
d440 13
d1058 1
a1058 1
	    "\t[-w waittime] host [packetsize]\n", __progname);
@


1.65
log
@lint
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.64 2005/11/02 11:35:54 jmc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.64 2005/11/02 11:35:54 jmc Exp $";
d254 1
d257 1
a257 1
};
@


1.64
log
@- sort options and sync usage()
- new sentence, new line
- a few other minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.63 2005/05/03 01:01:13 djm Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.63 2005/05/03 01:01:13 djm Exp $";
d502 1
a502 1
	outpacket = (u_char *)malloc(datalen);
@


1.63
log
@more setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.62 2005/03/01 16:13:29 markus Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.62 2005/03/01 16:13:29 markus Exp $";
d1041 2
a1042 2
	    "usage: %s [-cdDIlnrSv] [-f first_ttl] [-g gateway_addr] [-m max_ttl]\n"
	    "\t[-p port] [-P proto] [-q nqueries] [-s src_addr] [-t tos]\n"
@


1.62
log
@make sure the ttl does not wrap; pr 4093; ok Jared
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.61 2004/01/26 18:23:51 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.61 2004/01/26 18:23:51 deraadt Exp $";
d310 1
d318 3
a320 2
	seteuid(getuid());
	setuid(getuid());
@


1.61
log
@knf and cleanup; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.60 2003/08/27 08:17:34 jmc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.60 2003/08/27 08:17:34 jmc Exp $";
d579 1
a579 1
	for (ttl = first_ttl; ttl <= max_ttl; ++ttl) {
@


1.60
log
@- sort SYNOPSIS and DESCRIPTION
- add -v to SYNOPSIS
from Andrey Matveev;

- indent examples
- sync usage() with man page

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.59 2003/06/11 23:33:29 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.59 2003/06/11 23:33:29 deraadt Exp $";
d299 5
d305 1
a305 3
	struct sockaddr_in from, to;
	int ch, i, lsrr, on, probe, seq, tos;
	int ttl_flag, incflag = 1, protoset = 0;
d307 2
a308 4
	u_int32_t tmprnd;
	int sump = 0;
	int mib[4] = { CTL_NET, PF_INET, IPPROTO_IP, IPCTL_DEFTTL };
	size_t size = sizeof(max_ttl);
a309 2
	char *ep;
	u_int8_t ttl;
a322 4
	ttl_flag = 0;
	lsrr = 0;
	on = 1;
	seq = tos = 0;
d507 1
a507 1
		u_char *p;
a508 1
		p = (u_char *)(ip + 1);
d580 1
a581 3
		int got_there = 0;
		int unreachable = 0;
		int timeout = 0;
a582 1
		int loss;
d606 2
a607 2
				dt = (quad_t)(t2.tv_sec - t1.tv_sec) * 1000000
				    + (quad_t)(t2.tv_usec - t1.tv_usec);
d709 1
a711 1
	socklen_t fromlen = sizeof (*from);
d760 1
a761 1
	struct timeval tv;
d814 2
a815 1
		if (icmpp->icmp_cksum == 0) icmpp->icmp_cksum = 0xffff;
d824 1
a824 1
		if (i<0)
d832 22
a859 8
	static char *ttab[] = {
	"Echo Reply",	"ICMP 1",	"ICMP 2",	"Dest Unreachable",
	"Source Quench", "Redirect",	"ICMP 6",	"ICMP 7",
	"Echo",		"Router Advert",	"Router Solicit",	"Time Exceeded",
	"Param Problem", "Timestamp",	"Timestamp Reply", "Info Request",
	"Info Reply", "Mask Request", "Mask Reply"
	};

a861 1

a864 1

d888 2
a889 1
	type = icp->icmp_type; code = icp->icmp_code;
d891 1
a891 1
	    type == ICMP_UNREACH || type == ICMP_ECHOREPLY ) {
d973 2
a974 4
	int nleft = len;
	u_short *w = addr;
	u_short answer;
	int sum = 0;
d1008 3
a1011 3
	struct hostent *hp;
	static int first = 1;
	static char domain[MAXHOSTNAMELEN], line[MAXHOSTNAMELEN];
@


1.59
log
@some ansification, some de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.58 2003/06/02 23:36:55 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.58 2003/06/02 23:36:55 millert Exp $";
d1036 3
a1038 3
	    "usage: %s [-SDIdnrvc] [-g gateway_addr] ... [-m max_ttl] [-p port#]\n"
	    "\t[-P proto] [-q nqueries] [-s src_addr] [-t tos]\n"
	    "\t[-w wait] [-f first_ttl] host [data size]\n", __progname);
@


1.58
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.57 2003/04/25 22:45:38 cloder Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.57 2003/04/25 22:45:38 cloder Exp $";
d864 1
a864 1
	register struct icmp *icp;
d968 4
a971 4
	register int nleft = len;
	register u_short *w = addr;
	register u_short answer;
	register int sum = 0;
d1005 2
a1006 2
	register char *cp;
	register struct hostent *hp;
@


1.57
log
@Compile with -ansi -pedantic.  Replace one ugly lvalue cast with a memcpy.
Replace some strtoul with strtol and additional < 0 checks where needed.
OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.56 2003/04/25 02:56:39 cloder Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.56 2003/04/25 02:56:39 cloder Exp $";
@


1.56
log
@ICMP types are u_int8_t.  Use u_int8_t and %u for ICMP types instead of
u_char and %d.
OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.55 2003/04/25 02:12:19 cloder Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.55 2003/04/25 02:12:19 cloder Exp $";
d312 1
a312 1
	unsigned long l;
d340 1
a340 1
			l = strtoul(optarg, &ep, 10);
d379 1
a379 1
			l = strtoul(optarg, &ep, 10);
d392 1
a392 1
			l = strtoul(optarg, &ep, 10);
d403 1
a403 1
			l = strtoul(optarg, &ep, 10);
d419 1
a419 1
			l = strtoul(optarg, &ep, 10);
d437 1
a437 1
			l = strtoul(optarg, &ep, 10);
d448 1
a448 1
			l = strtoul(optarg, &ep, 10);
d483 2
a484 2
		l = strtoul(*argv, &ep, 10);
		if (errno || !*argv || *ep || l > INT_MAX)
d524 4
a527 2
		for (i = 1; i <= lsrr; i++)
			*((struct in_addr *)p)++ = gateway[i];
@


1.55
log
@TTL is defined as u_int8_t in both <netinet/ip.h> and
<netinet6/ip6_var.h>.  Don't need to use int and %d
for TTL in traceroute.
OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.54 2003/04/24 16:20:04 cloder Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.54 2003/04/24 16:20:04 cloder Exp $";
d292 1
a292 1
u_char  icmp_type = ICMP_ECHO; /* default ICMP code/type */
d846 1
a846 1
pr_type(u_char t)
d867 2
a868 1
	u_char type, code;
d934 1
a934 1
		printf(": icmp type %d (%s) code %d\n", type, pr_type(type),
@


1.54
log
@Validation of command line argument for packet data length was comparing
to the wrong thing, which resulted in a confusing error message later
on.  Do validation on the user supplied parameter.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.53 2002/11/18 04:45:11 itojun Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.53 2002/11/18 04:45:11 itojun Exp $";
d257 1
a257 1
	u_char ttl;		/* ttl packet left with */
d270 1
a270 1
void send_probe(int, int, int, struct sockaddr_in *);
d287 2
a288 2
int max_ttl = IPDEFTTL;
int first_ttl = 1;
d305 1
a305 1
	int ch, i, lsrr, on, probe, seq, tos, ttl;
d314 1
d342 2
a343 2
				errx(1, "min ttl must be 1 to %d.", max_ttl);
			first_ttl = (int)l;
d382 1
a382 1
				errx(1, "max ttl must be %d to %d.", first_ttl,
d384 1
a384 1
			max_ttl = (int)l;
d581 1
a581 1
	fprintf(stderr, ", %d hops max, %d byte packets\n", max_ttl, datalen);
d585 1
a585 1
		printf("Skipping %d intermediate hops\n", first_ttl - 1);
d595 1
a595 1
		printf("%2d ", ttl);
d625 1
a625 1
					printf(" (%d)", ip->ip_ttl);
d764 1
a764 1
send_probe(int seq, int ttl, int iflag, struct sockaddr_in *to)
@


1.53
log
@atoi -> strto*.  correct -p parsing (don't allow 65536).  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.52 2002/09/06 19:50:05 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.52 2002/09/06 19:50:05 deraadt Exp $";
d483 1
a483 1
		if (errno || !*argv || *ep || datalen > INT_MAX)
@


1.52
log
@socklen_t
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.51 2002/08/31 00:05:20 stevesk Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.51 2002/08/31 00:05:20 stevesk Exp $";
d312 2
d337 4
a340 2
			first_ttl = atoi(optarg);
			if (first_ttl < 1 || first_ttl > max_ttl)
d342 1
d376 5
a380 2
			max_ttl = atoi(optarg);
			if (max_ttl < first_ttl || max_ttl > MAXTTL)
d383 1
d389 4
a392 2
			port = atoi(optarg);
			if (port < 1 || port > 65536)
d394 1
d400 5
a404 2
			proto = atoi(optarg);
			if (proto < 1 || proto >= IPPROTO_MAX) {
d412 2
a413 1
			}
d416 4
a419 2
			nprobes = atoi(optarg);
			if (nprobes < 1)
d421 1
d434 4
a437 2
			tos = atoi(optarg);
			if (tos < 0 || tos > 255)
d439 1
d445 4
a448 2
			waittime = atoi(optarg);
			if (waittime <= 1)
d450 1
d479 8
a486 2
	if (*++argv)
		datalen = atoi(*argv);
@


1.51
log
@warn if multiple addresses are returned from DNS; suggested
by and ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.50 2002/08/12 02:40:52 stevesk Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.50 2002/08/12 02:40:52 stevesk Exp $";
d690 1
a690 1
	int fromlen = sizeof (*from);
@


1.50
log
@!X for 3/13 (administratively prohibited); ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.49 2002/08/12 02:36:25 stevesk Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.49 2002/08/12 02:36:25 stevesk Exp $";
d450 3
@


1.49
log
@SO_DONTROUTE on receive socket is not needed; ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.48 2002/08/08 23:53:21 stevesk Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.48 2002/08/08 23:53:21 stevesk Exp $";
d634 3
@


1.48
log
@remove unused struct timezone; ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.47 2002/07/03 23:01:10 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.47 2002/07/03 23:01:10 deraadt Exp $";
a507 3
		    (char *)&on, sizeof(on));
	if (options & SO_DONTROUTE)
		(void) setsockopt(s, SOL_SOCKET, SO_DONTROUTE,
@


1.47
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.46 2002/06/29 07:56:44 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.46 2002/06/29 07:56:44 deraadt Exp $";
a278 1
struct timezone tz;		/* leftover */
a566 1
			struct timezone tz;
d569 1
a569 1
			(void) gettimeofday(&t1, &tz);
d572 1
a572 1
				(void) gettimeofday(&t2, &tz);
d768 1
a768 1
	(void) gettimeofday(&tv, &tz);
d782 1
a782 1
	(void) gettimeofday(&tv, &tz);
@


1.46
log
@IPPROTO_ICMP will not change in our life; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.45 2002/06/29 07:46:29 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.45 2002/06/29 07:46:29 deraadt Exp $";
d302 1
a302 3
main(argc, argv)
	int argc;
	char *argv[];
d685 1
a685 4
wait_for_reply(sock, from, sent)
	int sock;
	struct sockaddr_in *from;
	struct timeval *sent;
d716 1
a716 1
dump_packet()
d731 1
a731 3
send_probe(seq, ttl, iflag, to)
	int seq, ttl, iflag;
	struct sockaddr_in *to;
d813 1
a813 2
pr_type(t)
	u_char t;
d831 1
a831 6
packet_ok(buf, cc, from, seq, iflag)
	u_char *buf;
	int cc;
	struct sockaddr_in *from;
	int seq;
	int iflag;
d910 1
a910 4
print(buf, cc, from)
	u_char *buf;
	int cc;
	struct sockaddr_in *from;
d934 1
a934 3
in_cksum(addr, len)
	u_short *addr;
	int len;
d971 1
a971 2
inetname(in)
	struct in_addr in;
d999 1
a999 1
usage()
@


1.45
log
@make -I and -P exclusive; constrain -p and -P to their respective maximums;
itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.44 2002/06/02 06:42:29 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.44 2002/06/02 06:42:29 deraadt Exp $";
a306 1
	struct protoent *pe;
d316 1
a316 5
	if ((pe = getprotobyname("icmp")) == NULL) {
		fprintf(stderr, "icmp: unknown protocol\n");
		exit(10);
	}
	if ((s = socket(AF_INET, SOCK_RAW, pe->p_proto)) < 0)
@


1.44
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.43 2002/05/26 13:24:54 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.43 2002/05/26 13:24:54 deraadt Exp $";
d309 2
a310 1
	int ch, i, lsrr, on, probe, seq, tos, ttl, ttl_flag, incflag = 1;
d370 3
d389 2
a390 2
			if (port < 1)
				errx(1, "port must be >0.");
d393 3
d397 1
a397 1
			if (proto < 1) {
d399 1
d490 1
@


1.43
log
@use sysctl to get ttl from the kernel; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.42 2002/05/21 00:46:44 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.42 2002/05/21 00:46:44 deraadt Exp $";
d748 1
a748 1
	switch(proto) {
d871 1
a871 1
		switch(proto) {
a872 1

@


1.42
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.41 2002/02/16 21:28:10 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.41 2002/02/16 21:28:10 millert Exp $";
d230 1
d313 2
d328 3
@


1.41
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.40 2001/08/12 12:03:03 heko Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.40 2001/08/12 12:03:03 heko Exp $";
a248 3
#define Fprintf (void)fprintf
#define Printf (void)printf

d314 1
a314 1
		Fprintf(stderr, "icmp: unknown protocol\n");
d496 1
a496 1
						(tmprnd & 0x7ff);
d501 1
a501 1
				  (char *)&on, sizeof(on));
d504 1
a504 1
				  (char *)&on, sizeof(on));
d517 1
a517 1
				  (char *)&on, sizeof(on));
d520 1
a520 1
				  (char *)&on, sizeof(on));
d538 1
a538 1
	Fprintf(stderr, "traceroute to %s (%s)", hostname,
d541 2
a542 2
		Fprintf(stderr, " from %s", source);
	Fprintf(stderr, ", %d hops max, %d byte packets\n", max_ttl, datalen);
d546 1
a546 1
		Printf("Skipping %d intermediate hops\n", first_ttl - 1);
d556 1
a556 1
		Printf("%2d ", ttl);
d580 2
a581 2
					+ (quad_t)(t2.tv_usec - t1.tv_usec);
				Printf("  %u", (u_int)(dt / 1000));
d583 2
a584 2
					Printf(".%u", (u_int)(dt % 1000));
				Printf(" ms");
d587 1
a587 1
					Printf(" (%d)", ip->ip_ttl);
d592 1
a592 1
						Printf(" !");
d606 1
a606 1
						Printf(" !");
d612 1
a612 1
					Printf(" !N");
d616 1
a616 1
					Printf(" !H");
d620 1
a620 1
					Printf(" !P");
d624 1
a624 1
					Printf(" !F");
d628 1
a628 1
					Printf(" !S");
d633 1
a633 1
					Printf(" !A");
d637 1
a637 1
					Printf(" !C");
d642 1
a642 1
					Printf(" !U");
d646 1
a646 1
					Printf(" !I");
d651 1
a651 1
					Printf(" !T");
d655 1
a655 1
					Printf(" !<%d>", i - 1);
d661 1
a661 1
				Printf(" *");
d668 1
a668 1
			Printf(" (%d%% loss)", (loss * 100) / nprobes);
d703 2
a704 2
		cc=recvfrom(s, (char *)packet, sizeof(packet), 0,
			    (struct sockaddr *)from, &fromlen);
d716 1
a716 1
	Fprintf(stderr, "packet data:");
d719 2
a720 2
			Fprintf(stderr, "\n ");
		Fprintf(stderr, " %02x", *p++);
d722 1
a722 1
	Fprintf(stderr, "\n");
d741 1
a741 1
	
d743 1
a743 1
	   case IPPROTO_ICMP:
d750 1
a750 1
	   case IPPROTO_UDP:
d788 1
a788 1
					datalen - sizeof(struct ip) - lsrrlen);
d796 1
a796 1
		   sizeof(struct sockaddr_in));
d800 2
a801 2
		Printf("traceroute: wrote %s %d chars, ret=%d\n", hostname,
			datalen, i);
d846 2
a847 2
			Printf("packet too short (%d bytes) from %s\n", cc,
				inet_ntoa(from->sin_addr));
d866 1
a866 1
		  case IPPROTO_ICMP:
d881 1
a881 1
		  case IPPROTO_UDP:
d902 3
a904 3
		Printf("\n%d bytes from %s", cc, inet_ntoa(from->sin_addr));
		Printf(" to %s", inet_ntoa(ip->ip_dst));
		Printf(": icmp type %d (%s) code %d\n", type, pr_type(type),
d907 1
a907 1
			Printf("%2d: x%8.8lx\n", i, (unsigned long)*lp++);
a912 1

d927 1
a927 1
		Printf(" %s", inet_ntoa(from->sin_addr));
d929 1
a929 1
		Printf(" %s (%s)", inetname(from->sin_addr),
d933 1
a933 1
		Printf(" %d bytes to %s", cc, inet_ntoa (ip->ip_dst));
d1012 1
d1014 3
a1016 3
"usage: %s [-SDIdnrvc] [-g gateway_addr] ... [-m max_ttl] [-p port#]\n\t\
[-P proto] [-q nqueries] [-s src_addr] [-t tos]\n\t\
[-w wait] [-f first_ttl] host [data size]\n", __progname);
@


1.40
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.39 2001/06/10 05:49:23 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.39 2001/06/10 05:49:23 deraadt Exp $";
d271 7
a277 7
int wait_for_reply __P((int, struct sockaddr_in *, struct timeval *));
void send_probe __P((int, int, int, struct sockaddr_in *));
int packet_ok __P((u_char *, int, struct sockaddr_in *, int, int));
void print __P((u_char *, int, struct sockaddr_in *));
char *inetname __P((struct in_addr));
u_short in_cksum __P((u_short *, int));
void usage __P((void));
@


1.39
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.38 2001/06/10 01:24:01 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.38 2001/06/10 01:24:01 deraadt Exp $";
d512 1
a512 1
#endif SO_SNDBUF
d517 1
a517 1
#endif IP_HDRINCL
d610 1
a610 1
#endif ARCHAIC
d857 1
a857 1
#endif ARCHAIC
d912 1
a912 1
#endif ARCHAIC
@


1.38
log
@Sprintf/sprintf no longer used, remove it
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.37 2001/06/09 21:06:23 pvalchev Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.37 2001/06/09 21:06:23 pvalchev Exp $";
d344 2
a345 2
		        incflag = 0;
		        break;
d375 1
a375 1
				     MAXTTL);
d510 1
a510 1
		       sizeof(datalen)) < 0)
d515 1
a515 1
		       sizeof(on)) < 0)
d568 1
a568 1
			while (cc = wait_for_reply(s, &from, &t1)) {
d674 1
a674 1
			exit(0);
d676 1
d710 1
a710 1
	return(cc);
d756 1
a756 1
		        up->uh_dport = htons(port+seq);
d758 3
a760 3
		        up->uh_dport = htons(port);
		up->uh_ulen =
		    htons((u_short)(datalen - sizeof(struct ip) - lsrrlen));
d825 1
a825 1
		return("OUT-OF-RANGE");
d827 1
a827 1
	return(ttab[t]);
d875 1
a875 1
			        return(-2); /* we got there */
d889 1
a889 1
			     (!iflag && up->uh_dport == htons(port))))
d896 1
a896 1
			if(hip->ip_p == proto)
d908 1
a908 1
		       icp->icmp_code);
d910 1
a910 1
			Printf("%2d: x%8.8lx\n", i, *lp++);
d913 1
a913 1
	return(0);
d934 1
a934 1
		       inet_ntoa(from->sin_addr));
d937 1
a937 1
		Printf (" %d bytes to %s", cc, inet_ntoa (ip->ip_dst));
@


1.37
log
@* Implement -S option to print the data loss in each hop in percents; freebsd
* Use __progname in usage()
* Use strlcpy vs strncpy+a[len-1]='\0'
ok mickey@@, jakob@@, option list order per aaron@@'s suggestion.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.36 2001/06/01 01:57:00 pvalchev Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: traceroute.c,v 1.36 2001/06/01 01:57:00 pvalchev Exp $";
a249 1
#define Sprintf (void)sprintf
@


1.36
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.35 2001/03/15 17:52:54 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD$";
d315 1
d334 1
a334 1
	while ((ch = getopt(argc, argv, "dDIg:f:m:np:q:rs:t:w:vlP:c")) != -1)
d336 3
d558 1
d561 1
a561 1
		for (probe = 0; probe < nprobes; ++probe) {
d667 1
d671 2
d996 1
a996 2
			(void)strncpy(domain, cp + 1, sizeof(domain) - 1);
			domain[sizeof(domain) - 1] = '\0';
d1005 1
a1005 2
			(void)strncpy(line, hp->h_name, sizeof(line) - 1);
			line[sizeof(line) - 1] = '\0';
d1015 3
a1017 2
	(void)fprintf(stderr,
"usage: traceroute [-dDInrvc] [-g gateway_addr] ... [-m max_ttl] [-p port#]\n\t\
d1019 1
a1019 1
[-w wait] [-f first_ttl] host [data size]\n");
@


1.35
log
@do not permit traceroute -s 127.0.0.1 non-127-net-address; solar
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.34 2000/08/28 22:43:17 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$NetBSD: traceroute.c,v 1.10 1995/05/21 15:50:45 mycroft Exp $";
@


1.34
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.33 2000/04/20 17:26:37 angelos Exp $	*/
d528 5
@


1.33
log
@Change the flag to -f, similar to Solaris.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.32 2000/04/20 07:47:11 angelos Exp $	*/
d449 3
a451 3
 	  case IPPROTO_UDP:
		headerlen = (sizeof(struct ip) + lsrrlen + 
		sizeof(struct udphdr) + sizeof(struct packetdata));
d453 3
a455 3
 	  case IPPROTO_ICMP:
		headerlen = (sizeof(struct ip) + lsrrlen + 
		sizeof(struct icmp) + sizeof(struct packetdata));
d457 3
a459 3
	  default:
		headerlen = (sizeof(struct ip) + lsrrlen + 
		+ sizeof(struct packetdata));
a731 1
	
d733 1
a733 1
	   case IPPROTO_ICMP: 
d738 1
a738 1
  		op = (struct packetdata *)(icmpp + 1);
d749 1
a749 1
  		op = (struct packetdata *)(up + 1);
d752 2
a753 1
  		op = (struct packetdata *)(ip + 1);
d858 1
a858 1
			if (icmp_type == ICMP_ECHO && 
d861 1
a861 1
			    icp->icmp_seq == htons(seq)) 
d863 1
a863 1
			 
@


1.32
log
@Add a "minimum ttl" option (starting point). Useful for skipping over
local-ISP routers that don't generate ICMP time exceeded.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.31 1999/12/23 16:17:05 angelos Exp $	*/
d292 1
a292 1
int min_ttl = 1;
d333 1
a333 1
	while ((ch = getopt(argc, argv, "dDIg:b:m:np:q:rs:t:w:vlP:c")) != -1)
d335 3
a337 3
		case 'b':
			min_ttl = atoi(optarg);
			if (min_ttl < 1 || min_ttl > max_ttl)
d370 2
a371 2
			if (max_ttl < min_ttl || max_ttl > MAXTTL)
				errx(1, "max ttl must be %d to %d.", min_ttl,
d540 2
a541 2
	if (min_ttl > 1)
		Printf("Skipping %d intermediate hops\n", min_ttl - 1);
d543 1
a543 1
	for (ttl = min_ttl; ttl <= max_ttl; ++ttl) {
d1007 1
a1007 1
[-w wait] [-b min_ttl] host [data size]\n");
@


1.31
log
@Add -I flag for compatibility.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.30 1999/12/18 21:34:35 angelos Exp $	*/
d292 1
d333 1
a333 1
	while ((ch = getopt(argc, argv, "dDIg:m:np:q:rs:t:w:vlP:c")) != -1)
d335 4
a338 2
		case 'I':
			proto = IPPROTO_ICMP;
d340 3
a345 3
		case 'c':
		        incflag = 0;
		        break;
d362 3
d370 3
a372 2
			if (max_ttl < 1 || max_ttl > MAXTTL)
				errx(1, "max ttl must be 1 to %d.", MAXTTL);
d540 4
a543 1
	for (ttl = 1; ttl <= max_ttl; ++ttl) {
d1007 1
a1007 1
[-w wait] host [data size]\n");
@


1.30
log
@If the protocol specified via the -P flag is 1 (IPPROTO_ICMP), use
ICMP Echo Request packets (rather than UDP packets) for the traceroute
(mlists@@gizmo.kyrnet.kg)

Also, if the -c flag is specified, the UDP destination port is not
incremented; rather, the base port is used for all packets (33434 or
as set via the -p flag).
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.29 1999/12/18 01:11:06 angelos Exp $	*/
d332 1
a332 1
	while ((ch = getopt(argc, argv, "dDg:m:np:q:rs:t:w:vlP:c")) != -1)
d334 3
d995 1
a995 1
"usage: traceroute [-dDnrvc] [-g gateway_addr] ... [-m max_ttl] [-p port#]\n\t\
@


1.29
log
@Fix error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.28 1999/02/17 00:20:45 millert Exp $	*/
a252 1
#define	HEADERSIZE	(sizeof(struct ip) + lsrrlen + sizeof(struct udphdr) + sizeof(struct packetdata))
d273 2
a274 2
void send_probe __P((int, int, struct sockaddr_in *));
int packet_ok __P((u_char *, int, struct sockaddr_in *, int));
d277 1
d285 1
d295 2
d311 1
a311 1
	int ch, i, lsrr, on, probe, seq, tos, ttl, ttl_flag;
d332 1
a332 1
	while ((ch = getopt(argc, argv, "dDg:m:np:q:rs:t:w:vlP:")) != -1)
d337 3
d374 1
a374 1
			if (proto <= 1) {
d380 1
a380 1
					errx(1, "proto must be >=2, or a name.");
d437 16
a452 1
	if (datalen < 0 || datalen > IP_MAXPACKET - HEADERSIZE)
d454 3
a456 2
		    IP_MAXPACKET - HEADERSIZE);
	datalen += HEADERSIZE;
d545 1
a545 1
			send_probe(++seq, ttl, &to);
d552 1
a552 1
				i = packet_ok(packet, cc, &from, seq);
d703 2
a704 2
send_probe(seq, ttl, to)
	int seq, ttl;
d710 2
a711 1
	struct packetdata *op = (struct packetdata *)(up + 1);
d718 24
a741 6

	up->uh_sport = htons(ident);
	up->uh_dport = htons(port+seq);
	up->uh_ulen = htons((u_short)(datalen - sizeof(struct ip) - lsrrlen));
	up->uh_sum = 0;

d762 7
d806 1
a806 1
packet_ok(buf, cc, from, seq)
d811 1
d834 1
a834 1
	    type == ICMP_UNREACH) {
d837 1
d841 32
a872 5
		up = (struct udphdr *)((u_char *)hip + hlen);
		if (hlen + 12 <= cc && hip->ip_p == proto &&
		    up->uh_sport == htons(ident) &&
		    up->uh_dport == htons(port+seq))
			return (type == ICMP_TIMXCEED? -1 : code+1);
a914 1
#ifdef notyet
a950 1
#endif notyet
d992 1
a992 1
"usage: traceroute [-dDnrv] [-g gateway_addr] ... [-m max_ttl] [-p port#]\n\t\
@


1.28
log
@re-enable the bind() for non-superusers so normal users cannot set the source address to be a non-local address
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.27 1998/07/11 21:20:12 deraadt Exp $	*/
d374 1
a374 1
					errx(1, "proto must be >=0, or a name.");
@


1.27
log
@change default ttl to IPDEFTTL; matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.26 1998/07/09 06:32:27 deraadt Exp $	*/
d496 2
a497 2
#ifndef IP_HDRINCL
		if (bind(sndsock, (struct sockaddr *)&from, sizeof(from)) < 0)
a498 1
#endif IP_HDRINCL
@


1.26
log
@MAXHOSTNAMELEN, and no need to terminate
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.25 1997/06/28 20:19:02 denny Exp $	*/
d63 1
a63 1
 * defaults to 30 hops & can be changed with the -m flag).  Three
d80 1
a80 1
 *     traceroute to nis.nsf.net (35.1.1.48), 30 hops max, 56 byte packet
d100 1
a100 1
 *     traceroute to allspice.lcs.mit.edu (18.26.0.115), 30 hops max
d290 1
a290 1
int max_ttl = 30;
@


1.25
log
@Repair breakage in 1.17. Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.24 1997/06/23 09:28:57 deraadt Exp $	*/
d894 1
a894 1
		if (gethostname(domain, MAXHOSTNAMELEN) == 0 &&
d898 1
a898 2
		} else
			domain[0] = '\0';
@


1.24
log
@long vs int
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.23 1997/06/12 01:12:27 mickey Exp $	*/
d618 1
@


1.23
log
@-freduce-math-strength manually (double, bye-bye)
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.22 1997/06/11 10:17:04 deraadt Exp $	*/
d510 1
a510 1
		u_long lastaddr = 0;
d800 1
a800 1
		u_long *lp = (u_long *)&icp->icmp_ip;
d806 1
a806 1
		for (i = 4; i < cc ; i += sizeof(long))
@


1.22
log
@dynamic fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute.c,v 1.21 1997/06/11 06:47:24 denny Exp $	*/
a274 1
double deltaT __P((struct timeval *, struct timeval *));
d514 1
d539 6
a544 1
				Printf("  %g ms", deltaT(&t1, &t2));
a733 13


double
deltaT(t1p, t2p)
	struct timeval *t1p, *t2p;
{
	register double dt;

	dt = (double)(t2p->tv_sec - t1p->tv_sec) * 1000.0 +
	     (double)(t2p->tv_usec - t1p->tv_usec) / 1000.0;
	return (dt);
}

@


1.21
log
@Always send timestamp in network byte order.
Always send timestamp as 32 bit values.
Perturb the timestamp by a small random amount.
Move $OpenBSD$ first (heh).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a631 1
	fd_set fds;
d633 1
a633 1
	int cc = 0;
d635 1
d637 5
a641 2
	FD_ZERO(&fds);
	FD_SET(sock, &fds);
d652 1
a652 1
	if (select(sock+1, &fds, (fd_set *)0, (fd_set *)0, &wait) > 0)
d656 1
@


1.20
log
@update usage
@
text
@d1 1
a2 1
/*	$OpenBSD: traceroute.c,v 1.19 1997/06/09 21:55:19 deraadt Exp $	*/
d262 2
a263 1
	struct timeval tv;	/* time packet left */
d268 2
d311 1
d463 4
d681 1
d694 17
a710 1
	(void) gettimeofday(&op->tv, &tz);
d893 1
a893 1
	static char domain[MAXHOSTNAMELEN + 1], line[MAXHOSTNAMELEN + 1];
@


1.19
log
@oops
@
text
@d2 1
a2 1
/*	$OpenBSD: traceroute.c,v 1.18 1997/06/09 21:31:01 deraadt Exp $	*/
d898 2
a899 1
[-q nqueries] [-s src_addr] [-t tos] [-w wait] host [data size]\n");
@


1.18
log
@permit changing protocol, useful for debugging sipp-esp/sipp-ah/ipencap; angelos/niklas/me
@
text
@d2 1
a2 1
/*	$OpenBSD: traceroute.c,v 1.17 1997/06/09 00:21:16 denny Exp $	*/
d370 2
a371 1
				errx(1, "proto must be >=0, or a name.");
@


1.17
log
@Handle additional icmp codes, and a default case for the rest.
Clean up inetname to use inet_ntoa().
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d291 1
d326 1
a326 1
	while ((ch = getopt(argc, argv, "dDg:m:np:q:rs:t:w:vl")) != -1)
d363 10
d453 1
a453 1
	ip->ip_p = IPPROTO_UDP;
d770 1
a770 1
		if (hlen + 12 <= cc && hip->ip_p == IPPROTO_UDP &&
@


1.16
log
@add "-l" flag see NetBSD PR #3227
@
text
@d2 1
d501 1
d511 14
a524 5
				if ((i = packet_ok(packet, cc, &from, seq))) {
					if (from.sin_addr.s_addr != lastaddr) {
						print(packet, cc, &from);
						lastaddr = from.sin_addr.s_addr;
					}
d526 12
a537 5
					Printf("  %g ms", deltaT(&t1, &t2));
					if (ttl_flag)
						Printf(" (%d)", ip->ip_ttl);
					switch(i - 1) {
					case ICMP_UNREACH_PORT:
d539 3
a541 3
						ip = (struct ip *)packet;
						if (ip->ip_ttl <= 1)
							Printf(" !");
d543 48
a590 32
						++got_there;
						break;
					case ICMP_UNREACH_NET:
						++unreachable;
						Printf(" !N");
						break;
					case ICMP_UNREACH_HOST:
						++unreachable;
						Printf(" !H");
						break;
					case ICMP_UNREACH_PROTOCOL:
						++got_there;
						Printf(" !P");
						break;
					case ICMP_UNREACH_NEEDFRAG:
						++unreachable;
						Printf(" !F");
						break;
					case ICMP_UNREACH_SRCFAIL:
						++unreachable;
						Printf(" !S");
						break;
					case ICMP_UNREACH_FILTER_PROHIB:
					case ICMP_UNREACH_NET_PROHIB: /*misuse*/
						++unreachable;
						Printf(" !A");
						break;
					case ICMP_UNREACH_HOST_PROHIB:
						++unreachable;
						Printf(" !C");
						break;
					}
d712 1
a712 1
	"Echo",		"ICMP 9",	"ICMP 10",	"Time Exceeded",
d714 1
a714 1
	"Info Reply"
d717 1
a717 1
	if(t > 16)
d854 1
a854 3
	static char line[MAXHOSTNAMELEN];
	struct hostent *hp;
	static char domain[MAXHOSTNAMELEN + 1];
d856 1
d861 5
a865 4
		    (cp = strchr(domain, '.')))
			(void) strcpy(domain, cp + 1);
		else
			domain[0] = 0;
a866 1
	cp = 0;
d868 8
a875 6
		hp = gethostbyaddr((char *)&in, sizeof (in), AF_INET);
		if (hp) {
			if ((cp = strchr(hp->h_name, '.')) &&
			    !strcmp(cp + 1, domain))
				*cp = 0;
			cp = hp->h_name;
d878 1
a878 9
	if (cp)
		(void) strcpy(line, cp);
	else {
		in.s_addr = ntohl(in.s_addr);
#define C(x)	((x) & 0xff)
		Sprintf(line, "%lu.%lu.%lu.%lu", C(in.s_addr >> 24),
			C(in.s_addr >> 16), C(in.s_addr >> 8), C(in.s_addr));
	}
	return (line);
@


1.15
log
@Changed ICMP "unreachable" code #defines to match the ones in
tcpdump/print-icmp.c since they were in BSD first.
@
text
@d304 1
a304 1
	int ch, i, lsrr, on, probe, seq, tos, ttl;
d320 1
d324 1
a324 1
	while ((ch = getopt(argc, argv, "dDg:m:np:q:rs:t:w:v")) != -1)
d345 3
d514 1
d516 2
@


1.14
log
@deal with IP_HDRINCL option network byte order change; lidl@@va.pubnix.com
@
text
@d540 2
a541 2
					case ICMP_UNREACH_ADM_PROHIB:
					case ICMP_UNREACH_NET_PROHIB:
@


1.13
log
@print !A on ICMP_UNREACH_ADM_PROHIB too
@
text
@d435 1
a435 1
	ip->ip_off = 0;
d621 1
a621 1
	ip->ip_len = datalen;
@


1.12
log
@r?index -> strr?chr
@
text
@d540 1
@


1.11
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d820 1
a820 1
		    (cp = index(domain, '.')))
d829 1
a829 1
			if ((cp = index(hp->h_name, '.')) &&
@


1.10
log
@check strdup ret val.
@
text
@d315 3
@


1.9
log
@Stop if the sum of unreachables and timeouts are >= number of probes, but
only if we have at least one unreachable
@
text
@d403 2
a404 1
		hostname = strdup(hp->h_name);
@


1.8
log
@if time expired, cc = 0 & break to *; Havard.Eidnes@@runit.sintef.no
@
text
@d485 1
d548 1
a548 1
			if (cc == 0)
d550 2
d555 1
a555 1
		if (got_there || unreachable >= nprobes)
@


1.7
log
@inet_ntoa*2 botch; netbsd pr#2701; he@@runit.sintef.no
@
text
@d496 4
@


1.6
log
@bigger buffer
@
text
@d716 2
a717 2
		Printf("\n%d bytes from %s to %s", cc,
			inet_ntoa(from->sin_addr), inet_ntoa(ip->ip_dst));
@


1.5
log
@other icmp traffic can cause a timeout to occur so must be more careful;
from freebsd pr#612; fenner@@parc.xerox.com
@
text
@d801 1
a801 1
	static char line[50];
@


1.4
log
@open sockets then revoke privs; and a strdup() solution from freebsd
@
text
@d269 1
a269 1
int wait_for_reply __P((int, struct sockaddr_in *));
d494 1
a494 1
			while (cc = wait_for_reply(s, &from)) {
d554 1
a554 1
wait_for_reply(sock, from)
d557 1
d560 1
a560 1
	struct timeval wait;
d566 9
a574 1
	wait.tv_sec = waittime; wait.tv_usec = 0;
@


1.3
log
@inet_ntoa backwards for -s; netbsd pr#2579; peter@@wonderland.org
@
text
@d307 10
d403 1
a403 1
		hostname = hp->h_name;
a438 6
	if ((pe = getprotobyname("icmp")) == NULL) {
		Fprintf(stderr, "icmp: unknown protocol\n");
		exit(10);
	}
	if ((s = socket(AF_INET, SOCK_RAW, pe->p_proto)) < 0)
		err(5, "icmp socket");
a444 4

	if ((sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
		err(5, "raw socket");

@


1.2
log
@Recognize "{net,host} access prohibited" icmp reply.
@
text
@d465 1
a465 1
		if (inet_aton(source, &from.sin_addr) != 0)
@


1.1
log
@Initial revision
@
text
@d531 8
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
