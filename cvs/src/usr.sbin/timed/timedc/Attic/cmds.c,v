head	1.22;
access;
symbols
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.18
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.16
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.14
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.12
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.10
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.8
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.6
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2011.07.07.21.00.59;	author deraadt;	state dead;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.17.16.29.25;	author sobrado;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.04.21.54.05;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.26.21.36.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.12.21.09.48;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.36.55;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.06.19.28.01;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.17.00.21.19;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.19.00.32.04;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.23.03.45.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.07.20.02.09;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.02.10.13.15;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.02.10.04.37;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.02.09.21.07;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.02.09.13.48;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.02.09.12.43;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	97.08.18.03.11.33;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.11.01.06.10.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.04.15.58.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@timed's time is up.  use ntpd(8).  Even our own fossil developers
switched a while back.
ok miod, kettenis
@
text
@/*	$OpenBSD: cmds.c,v 1.21 2009/10/27 23:59:57 deraadt Exp $	*/

/*-
 * Copyright (c) 1985, 1993 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef sgi
#ident "$Revision: 1.21 $"
#endif

#include "timedc.h"
#include <sys/file.h>

#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>

#include <poll.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define TSPTYPES
#include <protocols/timed.h>

#ifdef sgi
#include <bstring.h>
#include <sys/clock.h>
#else
#define	SECHR	(60*60)
#define	SECDAY	(24*SECHR)
#endif /* sgi */

# define DATE_PROTO "udp"
# define DATE_PORT "time"


int sock;
int sock_raw;
char myname[MAXHOSTNAMELEN];
struct hostent *hp;
struct sockaddr_in server;
struct sockaddr_in dayaddr;
extern int measure_delta;

void bytenetorder(struct tsp *);
void bytehostorder(struct tsp *);


#define BU ((unsigned long)2208988800U)	/* seconds before UNIX epoch */


/* compute the difference between our date and another machine
 */
static int				/* difference in days from our time */
daydiff(char *hostname)
{
	struct sockaddr_in from;
	struct timeval now;
	struct pollfd pfd;
	unsigned long sec;
	int i, trials;
	socklen_t fromlen;

	for (trials = 0; trials < 10; trials++) {
		/* ask for the time */
		sec = 0;

		siginterrupt(SIGINT, 1);
		if (sendto(sock, &sec, sizeof(sec), 0,
		    (struct sockaddr *)&dayaddr, sizeof(dayaddr)) < 0) {
			if (errno == EINTR && gotintr)
				goto bail;
			siginterrupt(SIGINT, 0);
			perror("sendto(sock)");
			goto bail;
		}
		siginterrupt(SIGINT, 0);

		for (;;) {
			pfd.fd = sock;
			pfd.events = POLLIN;
			i = poll(&pfd, 1, 2 * 1000);
			if (i < 0) {
				if (errno == EINTR) {
					if (gotintr)
						goto bail;
					continue;
				}
				perror("poll(date read)");
				goto bail;
			}
			if (i == 0)
				break;

			fromlen = sizeof(from);
			siginterrupt(SIGINT, 1);
			if (recvfrom(sock, &sec, sizeof(sec), 0,
			    (struct sockaddr *)&from, &fromlen) < 0) {
				if (errno == EINTR && gotintr)
					goto bail;
				siginterrupt(SIGINT, 0);
				perror("recvfrom(date read)");
				goto bail;
			}
			siginterrupt(SIGINT, 0);

			sec = ntohl(sec);
			if (sec < BU) {
				fprintf(stderr, "%s says it is before 1970: %lu",
				    hostname, sec);
				goto bail;
			}
			sec -= BU;

			(void)gettimeofday(&now, (struct timezone *)NULL);
			return (sec - now.tv_sec);
		}
	}

	/* if we get here, we tried too many times */
	fprintf(stderr,"%s will not tell us the date\n", hostname);

bail:
	siginterrupt(SIGINT, 0);	
	return (0);
}


/*
 * Clockdiff computes the difference between the time of the machine on
 * which it is called and the time of the machines given as argument.
 * The time differences measured by clockdiff are obtained using a sequence
 * of ICMP TSTAMP messages which are returned to the sender by the IP module
 * in the remote machine.
 * In order to compare clocks of machines in different time zones, the time
 * is transmitted (as a 32-bit value) in milliseconds since midnight UT.
 * If a hosts uses a different time format, it should set the high order
 * bit of the 32-bit quantity it transmits.
 * However, VMS apparently transmits the time in milliseconds since midnight
 * local time (rather than GMT) without setting the high order bit.
 * Furthermore, it does not understand daylight-saving time.  This makes
 * clockdiff behaving inconsistently with hosts running VMS.
 *
 * In order to reduce the sensitivity to the variance of message transmission
 * time, clockdiff sends a sequence of messages.  Yet, measures between
 * two `distant' hosts can be affected by a small error. The error can,
 * however, be reduced by increasing the number of messages sent in each
 * measurement.
 */
void
clockdiff(int argc, char *argv[])
{
	struct servent *sp;
	long avg;
	int avg_cnt;
	extern int measure(u_long, u_long, char *, struct sockaddr_in *, int);
	int measure_status;

	if (argc < 2)  {
		printf("usage: clockdiff host ...\n");
		return;
	}

	(void)gethostname(myname,sizeof(myname));

	/* get the address for the date ready */
	sp = getservbyname(DATE_PORT, DATE_PROTO);
	if (!sp) {
		(void)fprintf(stderr, "%s/%s is an unknown service\n",
		    DATE_PORT, DATE_PROTO);
		dayaddr.sin_port = 0;
	} else
		dayaddr.sin_port = sp->s_port;

	measure_status = 0;
	while (argc > 1) {
		argc--;
		argv++;

		siginterrupt(SIGINT, 1);
		hp = gethostbyname(*argv);
		if (hp == NULL) {
			if (errno == EINTR && gotintr) {
				siginterrupt(SIGINT, 0);
				return;
			}
			siginterrupt(SIGINT, 0);
			fprintf(stderr, "timedc: %s: ", *argv);
			herror(0);
			continue;
		}
		siginterrupt(SIGINT, 0);

		server.sin_family = hp->h_addrtype;
		bcopy(hp->h_addr, &server.sin_addr.s_addr, hp->h_length);
		for (avg_cnt = 0, avg = 0; avg_cnt < 16; avg_cnt++) {
			measure_status = measure(10000, 100, *argv, &server, 1);
			if (measure_status != GOOD)
				break;
			avg += measure_delta;
		}
		if (measure_status == GOOD)
			measure_delta = avg/avg_cnt;

		switch (measure_status) {
		case HOSTDOWN:
			printf("%s is down\n", hp->h_name);
			continue;
		case NONSTDTIME:
			printf("%s transmits a non-standard time format\n",
			    hp->h_name);
			continue;
		case UNREACHABLE:
			printf("%s is unreachable\n", hp->h_name);
			continue;
		}

		/*
		 * Try to get the date only after using ICMP timestamps to
		 * get the time.  This is because the date protocol
		 * is optional.
		 */
		if (dayaddr.sin_port != 0) {
			dayaddr.sin_family = hp->h_addrtype;
			bcopy(hp->h_addr, &dayaddr.sin_addr.s_addr,
			    hp->h_length);
			avg = daydiff(*argv);
			if (avg > SECDAY) {
				printf("time on %s is %ld days ahead %s\n",
				    hp->h_name, avg/SECDAY, myname);
				continue;
			} else if (avg < -SECDAY) {
				printf("time on %s is %ld days behind %s\n",
				    hp->h_name, -avg/SECDAY, myname);
				continue;
			}
		}

		if (measure_delta > 0) {
			printf("time on %s is %d ms. ahead of time on %s\n",
			    hp->h_name, measure_delta, myname);
		} else if (measure_delta == 0) {
			printf("%s and %s have the same time\n",
			    hp->h_name, myname);
		} else {
			printf("time on %s is %d ms. behind time on %s\n",
			    hp->h_name, -measure_delta, myname);
		}
	}
}


/*
 * finds location of master timedaemon
 */
void
msite(int argc, char *argv[])
{
	struct sockaddr_in dest, from;
	struct servent *srvp;
	int i, cc;
	socklen_t length;
	struct pollfd pfd;
	struct tsp msg;
	char *tgtname;

	if (argc < 1) {
		printf("usage: msite [hostname]\n");
		return;
	}

	srvp = getservbyname("timed", "udp");
	if (srvp == 0) {
		fprintf(stderr, "udp/timed: unknown service\n");
		return;
	}
	memset(&dest, 0, sizeof dest);
	dest.sin_port = srvp->s_port;
	dest.sin_family = AF_INET;

	(void)gethostname(myname, sizeof(myname));
	i = 1;

	do {
		tgtname = (i >= argc) ? myname : argv[i];
		siginterrupt(SIGINT, 1);
		hp = gethostbyname(tgtname);
		if (hp == 0) {
			if (errno == EINTR && gotintr)
				goto bail;
			siginterrupt(SIGINT, 0);
			fprintf(stderr, "timedc: %s: ", tgtname);
			herror(0);
			continue;
		}

		bcopy(hp->h_addr, &dest.sin_addr.s_addr, hp->h_length);
		(void)strlcpy(msg.tsp_name, myname, sizeof msg.tsp_name);
		msg.tsp_type = TSP_MSITE;
		msg.tsp_vers = TSPVERSION;
		bytenetorder(&msg);

		if (sendto(sock, &msg, sizeof(struct tsp), 0,
		    (struct sockaddr *)&dest, sizeof(dest)) < 0) {
			if (errno == EINTR && gotintr)
				goto bail;
			siginterrupt(SIGINT, 0);
			perror("sendto");
			continue;
		}

		pfd.fd = sock;
		pfd.events = POLLIN;
		switch (poll(&pfd, 1, 15 * 1000)) {
		case -1:
			if (errno == EINTR && gotintr)
				goto bail;
			siginterrupt(SIGINT, 0);
			continue;
		case 1:
			length = sizeof(from);
			cc = recvfrom(sock, &msg, sizeof(struct tsp), 0,
			    (struct sockaddr *)&from, &length);
			if (cc < 0) {
				if (errno == EINTR && gotintr)
					goto bail;
				siginterrupt(SIGINT, 0);
				perror("recvfrom");
				continue;
			}
			siginterrupt(SIGINT, 0);

			if (cc < sizeof(struct tsp)) {
				fprintf(stderr,
				    "short packet (%u/%u bytes) from %s\n",
				    cc, sizeof(struct tsp),
				    inet_ntoa(from.sin_addr));
				continue;
			}
			bytehostorder(&msg);
			if (msg.tsp_type == TSP_ACK) {
				printf("master timedaemon at %s is %s\n",
				    tgtname, msg.tsp_name);
			} else {
				if (msg.tsp_type >= TSPTYPENUMBER)
					printf("received unknown ack: %u\n",
					    msg.tsp_type);
				else
					printf("received wrong ack: %s\n",
					    tsptype[msg.tsp_type]);
			}
			break;
		case 0:
			siginterrupt(SIGINT, 0);
			printf("communication error with %s\n", tgtname);
			break;
		}
	} while (++i < argc);

bail:
	siginterrupt(SIGINT, 0);
}

/*
 * quits timedc
 */
void
quit(int ignored, char *unused[])
{
	exit(0);
}


/*
 * Causes the election timer to expire on the selected hosts
 * It sends just one udp message per machine, relying on
 * reliability of communication channel.
 */
void
testing(int argc, char *argv[])
{
	struct sockaddr_in sin;
	struct tsp msg;
	struct servent *srvp;

	if (argc < 2)  {
		printf("usage: election host1 [host2 ...]\n");
		return;
	}

	srvp = getservbyname("timed", "udp");
	if (srvp == 0) {
		fprintf(stderr, "udp/timed: unknown service\n");
		return;
	}

	while (argc > 1) {
		argc--;
		argv++;

		siginterrupt(SIGINT, 1);
		hp = gethostbyname(*argv);
		if (hp == NULL) {
			if (errno == EINTR && gotintr)
				goto bail;
			siginterrupt(SIGINT, 0);
			fprintf(stderr, "timedc: %s: ", *argv);
			herror(0);
			argc--;
			argv++;
			continue;
		}

		memset(&sin, 0, sizeof sin);
		sin.sin_port = srvp->s_port;
		sin.sin_family = hp->h_addrtype;
		bcopy(hp->h_addr, &sin.sin_addr.s_addr, hp->h_length);

		msg.tsp_type = TSP_TEST;
		msg.tsp_vers = TSPVERSION;
		(void)gethostname(myname, sizeof(myname));
		(void)strncpy(msg.tsp_name, myname, sizeof(msg.tsp_name));
		bytenetorder(&msg);

		if (sendto(sock, &msg, sizeof(struct tsp), 0,
		    (struct sockaddr *)&sin, sizeof(sin)) < 0) {
			if (errno == EINTR && gotintr)
				goto bail;
			siginterrupt(SIGINT, 0);
			perror("sendto");
		}
	}
bail:
	siginterrupt(SIGINT, 0);
}


/*
 * Enables or disables tracing on local timedaemon
 */
void
tracing(int argc, char *argv[])
{
	struct sockaddr_in dest;
	struct sockaddr_in from;
	struct tsp msg;
	struct servent *srvp;
	struct pollfd pfd;
	int cc, onflag;
	socklen_t length;

	if (argc != 2) {
		printf("usage: tracing { on | off }\n");
		return;
	}

	srvp = getservbyname("timed", "udp");
	if (srvp == 0) {
		fprintf(stderr, "udp/timed: unknown service\n");
		return;
	}

	memset(&dest, 0, sizeof dest);
	dest.sin_port = srvp->s_port;
	dest.sin_family = AF_INET;

	(void)gethostname(myname,sizeof(myname));
	siginterrupt(SIGINT, 1);
	hp = gethostbyname(myname);
	if (hp == NULL && errno == EINTR && gotintr)
		goto bail;

	bcopy(hp->h_addr, &dest.sin_addr.s_addr, hp->h_length);

	if (strcmp(argv[1], "on") == 0) {
		msg.tsp_type = TSP_TRACEON;
		onflag = ON;
	} else {
		msg.tsp_type = TSP_TRACEOFF;
		onflag = OFF;
	}

	(void)strlcpy(msg.tsp_name, myname, sizeof msg.tsp_name);
	msg.tsp_vers = TSPVERSION;
	bytenetorder(&msg);
	if (sendto(sock, &msg, sizeof(struct tsp), 0,
	    (struct sockaddr *)&dest, sizeof(dest)) < 0) {
		if (errno == EINTR && gotintr)
			goto bail;
		siginterrupt(SIGINT, 0);
		perror("sendto");
		return;
	}

	pfd.fd = sock;
	pfd.events = POLLIN;
	switch (poll(&pfd, 1, 5 * 1000)) {
	case 1:
		length = sizeof(from);
		cc = recvfrom(sock, &msg, sizeof(struct tsp), 0,
		    (struct sockaddr *)&from, &length);
		if (cc < 0) {
			if (errno == EINTR && gotintr)
				goto bail;
			siginterrupt(SIGINT, 0);
			perror("recvfrom");
			return;
		}
		siginterrupt(SIGINT, 0);
		if (cc < sizeof(struct tsp)) {
			fprintf(stderr, "short packet (%u/%u bytes) from %s\n",
			    cc, sizeof(struct tsp), inet_ntoa(from.sin_addr));
			goto bail;
		}
		bytehostorder(&msg);
		if (msg.tsp_type == TSP_ACK) {
			if (onflag)
				printf("timed tracing enabled\n");
			else
				printf("timed tracing disabled\n");
		} else  {
			if (msg.tsp_type >= TSPTYPENUMBER)
				printf("unknown ack received: %u\n",
				    msg.tsp_type);
			else
				printf("wrong ack received: %s\n",
				    tsptype[msg.tsp_type]);
		}
		break;
	case 0:
		siginterrupt(SIGINT, 0);
		printf("communication error\n");
		break;
	}
bail:
	siginterrupt(SIGINT, 0);
}
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.20 2008/03/17 16:29:25 sobrado Exp $	*/
d33 1
a33 1
#ident "$Revision: 1.20 $"
@


1.20
log
@use the right format for "usage:"; "usage:" is lowercase

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.19 2004/02/04 21:54:05 jmc Exp $	*/
a31 4
#ifndef lint
static char sccsid[] = "@@(#)cmds.c	5.1 (Berkeley) 5/11/93";
#endif /* not lint */

d33 1
a33 1
#ident "$Revision: 1.19 $"
@


1.19
log
@s/transmitts/transmits/
from Gavin Atkinson (FreeBSD PR 62346);
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.18 2003/06/26 21:36:40 deraadt Exp $	*/
d37 1
a37 1
#ident "$Revision: 1.18 $"
d191 1
a191 1
		printf("Usage: clockdiff host ... \n");
d299 1
a299 1
		printf("Usage: msite [hostname]\n");
d418 1
a418 1
		printf("Usage: election host1 [host2 ...]\n");
d484 1
a484 1
		printf("Usage: tracing { on | off }\n");
@


1.18
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.17 2003/06/12 21:09:48 deraadt Exp $	*/
d37 1
a37 1
#ident "$Revision: 1.17 $"
d241 1
a241 1
			printf("%s transmitts a non-standard time format\n",
@


1.17
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.16 2003/06/02 23:36:55 millert Exp $	*/
d37 1
a37 1
#ident "$Revision: 1.16 $"
d399 1
a399 1
quit(void)
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.15 2002/09/06 19:28:01 deraadt Exp $	*/
d37 1
a37 1
#ident "$Revision: 1.15 $"
d182 1
a182 3
clockdiff(argc, argv)
	int argc;
	char *argv[];
d399 1
a399 1
quit()
@


1.15
log
@socklen_t; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.14 2002/05/17 00:21:19 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
#ident "$Revision: 1.14 $"
@


1.14
log
@move setuid revocation closer to the start (make it more obvious); miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.13 2002/03/14 16:44:25 mpech Exp $	*/
d41 1
a41 1
#ident "$Revision: 1.13 $"
d96 2
a97 2
	int i, fromlen;
	int trials;
d298 2
a299 1
	int i, length, cc;
d486 2
a487 2
	int cc, length;
	int onflag;
@


1.13
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$Id: cmds.c,v 1.12 2002/01/19 00:32:04 mickey Exp $	*/
d41 1
a41 1
#ident "$Revision: 1.12 $"
a572 33
}

int
priv_resources()
{
	struct sockaddr_in sin;

	sock_raw = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
	if (sock_raw < 0)  {
		perror("opening raw socket");
		return (-1);
	}

	(void) seteuid(getuid());
	(void) setuid(getuid());

	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock < 0) {
		perror("opening socket");
		(void)close(sock_raw);
		return (-1);
	}

	memset(&sin, 0, sizeof sin);
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = INADDR_ANY;
	if (bind(sock, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
		fprintf(stderr, "all reserved ports in use\n");
		(void)close(sock_raw);
		return (-1);
	}

	return (1);
@


1.12
log
@do not bindresv() udp socket, for clockdiff to work w/ our inetd; millert@@ ok
@
text
@d1 1
a1 1
/*	$Id: cmds.c,v 1.11 2001/11/23 03:45:51 deraadt Exp $	*/
d41 1
a41 1
#ident "$Revision: 1.11 $"
d191 2
a192 2
	register long avg;
	register int avg_cnt;
@


1.11
log
@use siginterrupt() enabling around all blocking calls, and check the flags; millert ok
@
text
@d1 1
a1 1
/*	$Id: cmds.c,v 1.10 2001/04/07 20:02:09 ho Exp $	*/
d41 1
a41 1
#ident "$Revision: 1.10 $"
d580 9
d592 1
d599 1
a599 1
	if (bindresvport(sock, &sin) < 0) {
d601 1
a601 1
		(void)close(sock);
a604 6
	sock_raw = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
	if (sock_raw < 0)  {
		perror("opening raw socket");
		(void)close(sock);
		return (-1);
	}
@


1.10
log
@$OpenBSD$ here too.
@
text
@d1 1
a1 1
/*	$Id$	*/
d41 1
a41 1
#ident "$Revision: 1.9 $"
d52 1
d102 2
d106 3
d110 1
a110 1
			return (0);
d112 1
d119 3
a121 1
				if (errno == EINTR)
d123 1
d125 1
a125 1
				return (0);
d131 1
d134 3
d138 1
a138 1
				return (0);
d140 1
d144 1
a144 2
				fprintf(stderr,
				    "%s says it is before 1970: %lu",
d146 1
a146 1
				return (0);
d157 3
d214 4
a217 1
		argc--; argv++;
d220 5
d229 1
a286 1
	return;
d296 1
a296 3
	struct sockaddr_in dest;
	struct sockaddr_in from;
	struct tsp msg;
d298 1
d300 1
a301 2
	int i, length;
	int cc;
d313 1
d319 1
d322 1
d325 3
d332 1
a333 1

d338 1
d341 3
d350 7
a356 1
		if (poll(&pfd, 1, 15 * 1000)) {
d361 3
d367 2
d388 3
a390 1
		} else {
d392 1
d395 3
d434 4
a437 1
		argc--; argv++;
d440 3
d445 2
a446 1
			argc--; argv++;
d449 2
d460 1
d463 3
d469 2
d498 2
d504 1
d506 3
d524 3
d533 2
a534 1
	if (poll(&pfd, 1, 5 * 1000)) {
d539 3
d545 1
d549 1
a549 1
			return;
d565 3
a567 1
	} else
d569 4
d586 1
a586 1
	bzero(&sin, sizeof sin);
@


1.9
log
@style and fix cut & pasto from some previous commit.
@
text
@d1 2
d41 1
a41 1
#ident "$Revision: 1.7 $"
@


1.8
log
@More security fixes; check type before using it as tsptype index.
@
text
@d89 1
a89 2
	int i;
	int trials;
a91 2
	struct sockaddr_in from;
	int fromlen;
d93 2
a94 1

d100 1
a100 1
			   (struct sockaddr*)&dayaddr, sizeof(dayaddr)) < 0) {
d102 1
a102 1
			return 0;
d113 1
a113 1
				return 0;
d115 1
a115 1
			if (0 == i)
d119 2
a120 2
			if (recvfrom(sock,&sec,sizeof(sec),0,
				(struct sockaddr *)&from,&fromlen) < 0) {
d122 1
a122 1
				return 0;
d128 3
a130 3
					"%s says it is before 1970: %lu",
					hostname, sec);
				return 0;
d134 1
a134 1
			(void)gettimeofday(&now, (struct timezone*)0);
d141 1
a141 1
	return 0;
d171 4
a175 4
	extern int measure(u_long, u_long, char *, struct sockaddr_in*, int);
	register int avg_cnt;
	register long avg;
	struct servent *sp;
d188 1
a188 1
			      DATE_PORT, DATE_PROTO);
d190 1
a190 1
	} else {
a191 1
	}
d193 1
d206 1
a206 1
			measure_status = measure(10000,100, *argv, &server, 1);
d220 1
a220 1
			       hp->h_name);
d235 1
a235 1
			      hp->h_length);
d239 1
a239 1
				       hp->h_name, avg/SECDAY, myname);
d243 1
a243 1
				       hp->h_name, -avg/SECDAY, myname);
d250 1
a250 1
			       hp->h_name, measure_delta, myname);
d253 1
a253 1
			       hp->h_name, myname);
d256 1
a256 1
			       hp->h_name, -measure_delta, myname);
a268 1
	int cc;
a269 1
	int i, length;
a270 1
	struct pollfd pfd;
d273 1
d275 2
d308 1
a308 2
			   (struct sockaddr*)&dest,
			   sizeof(struct sockaddr)) < 0) {
d318 1
a318 1
			      (struct sockaddr *)&from, &length);
a329 1
 			bytehostorder(&msg);
d333 1
a333 1
				       tgtname, msg.tsp_name);
a365 1
	struct servent *srvp;
d368 1
d400 1
a400 2
			   (struct sockaddr*)&sin,
			   sizeof(struct sockaddr)) < 0) {
a412 4
	int onflag;
	int length;
	int cc;
	struct pollfd pfd;
d417 3
d450 1
a450 1
		   (struct sockaddr*)&dest, sizeof(struct sockaddr)) < 0) {
d496 1
a496 1
		return(-1);
d504 2
a505 2
		(void) close(sock);
		return(-1);
d511 2
a512 2
		(void) close(sock);
		return(-1);
d514 1
a514 1
	return(1);
@


1.7
log
@Use poll(2) instead of select(2).
@
text
@d39 1
a39 1
#ident "$Revision: 1.6 $"
d339 6
a344 2
				printf("received wrong ack: %s\n",
				       tsptype[msg.tsp_type]);
d477 1
a477 1
		if (msg.tsp_type == TSP_ACK)
d482 8
a489 3
		else
			printf("wrong ack received: %s\n",
						tsptype[msg.tsp_type]);
@


1.6
log
@Use strlcpy where possible.
@
text
@d39 1
a39 1
#ident "$Revision: 1.5 $"
d49 1
d91 2
a92 2
	struct timeval tout, now;
	fd_set ready;
a97 3
	/* wait 2 seconds between 10 tries */
	tout.tv_sec = 2;
	tout.tv_usec = 0;
d108 3
a110 4
			FD_ZERO(&ready);
			FD_SET(sock, &ready);
			i = select(sock+1, &ready, (fd_set *)0,
				   (fd_set *)0, &tout);
d114 1
a114 1
				perror("select(date read)");
a271 1
	fd_set ready;
d275 1
a275 1
	struct timeval tout;
d316 3
a318 6
		tout.tv_sec = 15;
		tout.tv_usec = 0;
		FD_ZERO(&ready);
		FD_SET(sock, &ready);
		if (select(FD_SETSIZE, &ready, (fd_set *)0, (fd_set *)0,
			   &tout)) {
d417 1
a417 1
	fd_set ready;
a419 1
	struct timeval tout;
d457 3
a459 5
	tout.tv_sec = 5;
	tout.tv_usec = 0;
	FD_ZERO(&ready);
	FD_SET(sock, &ready);
	if (select(FD_SETSIZE, &ready, (fd_set *)0, (fd_set *)0, &tout)) {
@


1.5
log
@Security fix; discard short packets.
@
text
@d39 1
a39 1
#ident "$Revision: 1.4 $"
d309 1
a309 2
		(void)strncpy(msg.tsp_name, myname, sizeof msg.tsp_name-1);
		msg.tsp_name[sizeof msg.tsp_name-1] = '\0';
d456 1
a456 2
	(void)strncpy(msg.tsp_name, myname, sizeof msg.tsp_name-1);
	msg.tsp_name[sizeof msg.tsp_name-1] = '\0';
@


1.4
log
@#include <string.h> not <strings.h> -- Yes, I'm a weanie...
@
text
@d39 1
a39 1
#ident "$Revision: 1.3 $"
d92 1
a92 1
	struct sockaddr from;
d125 1
a125 1
				     &from,&fromlen) < 0) {
d278 1
a278 1
	struct sockaddr from;
d327 1
a327 1
			length = sizeof(struct sockaddr);
d329 1
a329 1
				      &from, &length);
d334 8
d427 1
a427 1
	struct sockaddr from;
d472 1
a472 1
		length = sizeof(struct sockaddr);
d474 1
a474 1
			      &from, &length);
d477 5
@


1.3
log
@40 buf oflows
@
text
@d39 1
a39 1
#ident "$Revision: 1.2 $"
d50 1
a50 1
#include <strings.h>
@


1.2
log
@bzero sin, bindresvport
@
text
@d39 1
a39 1
#ident "$Revision: 1.1.1.1 $"
d309 2
a310 1
		(void)strcpy(msg.tsp_name, myname);
d449 2
a450 1
	(void)strcpy(msg.tsp_name, myname);
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
#ident "$Revision: 1.4 $"
a484 1
	int port;
d493 1
d495 2
a496 12
	sin.sin_addr.s_addr = 0;
	for (port = IPPORT_RESERVED - 1; port > IPPORT_RESERVED / 2; port--) {
		sin.sin_port = htons((u_short)port);
		if (bind(sock, (struct sockaddr*)&sin, sizeof (sin)) >= 0)
			break;
		if (errno != EADDRINUSE && errno != EADDRNOTAVAIL) {
			perror("bind");
			(void) close(sock);
			return(-1);
		}
	}
	if (port == IPPORT_RESERVED / 2) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
