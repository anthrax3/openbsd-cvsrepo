head	1.31;
access;
symbols
	OPENBSD_4_9:1.29.0.6
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.26.0.4
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.8
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.6
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.4
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.10
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2011.07.07.21.00.59;	author deraadt;	state dead;
branches;
next	1.30;

1.30
date	2011.03.19.23.40.11;	author okan;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.17.16.29.25;	author sobrado;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.17.20.10.44;	author chl;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.19.22.39.57;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.17.12.33.30;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.04.14.06.15;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.19.22.19.08;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.18.22.58.56;	author david;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.26.15.56.51;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.17.06.21.56;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.12.21.09.48;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.36.55;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.19.18.54.31;	author ericj;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.19.15.45.39;	author ericj;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.18.00.40.31;	author ericj;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.19.18.57.42;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.19.18.38.02;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.23.03.45.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.05.05.10.05;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.07.19.58.07;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.31.19.40.58;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	98.08.16.22.12.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.03.20.03.12.16;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	97.01.22.09.21.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.12.01.05.25.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.11.01.06.10.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.42.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@timed's time is up.  use ntpd(8).  Even our own fossil developers
switched a while back.
ok miod, kettenis
@
text
@/*	$OpenBSD: timed.c,v 1.30 2011/03/19 23:40:11 okan Exp $	*/

/*-
 * Copyright (c) 1985, 1993 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define TSPTYPES
#include "globals.h"
#include <net/if.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <setjmp.h>
#include "pathnames.h"
#include <math.h>
#include <sys/types.h>
#include <sys/queue.h>
#include <sys/times.h>
#include <netgroup.h>
#include <err.h>
#include <ifaddrs.h>

int trace = 0;
int sock, sock_raw = -1;
int status = 0;
u_short sequence;			/* sequence number */
long delay2;

int nslavenets;				/* nets were I could be a slave */
int nmasternets;			/* nets were I could be a master */
int nignorednets;			/* ignored nets */
int nnets;				/* nets I am connected to */

FILE *fd;				/* trace file FD */

jmp_buf jmpenv;

volatile sig_atomic_t gotintr;

struct netinfo *nettab = 0;
struct netinfo *slavenet;
int Mflag;
int justquit = 0;
int debug;

struct nets {
	char name[1024];
	in_addr_t net;
	TAILQ_ENTRY(nets) next;
};
static TAILQ_HEAD(, nets) nets;

struct hosttbl hosttbl[NHOSTS+1];	/* known hosts */

/* List of hosts we trust */
struct goodhost {
	char	name[MAXHOSTNAMELEN];
	int 	perm;
	TAILQ_ENTRY(goodhost) next;
};
static TAILQ_HEAD(, goodhost) goodhosts;

static char *goodgroup;			/* net group of trusted hosts */

/* prototypes */
static void addnetname(const char *);
static void checkignorednets(void);
static void pickslavenet(struct netinfo *);
static void add_good_host(const char *, int);
static void usage(void);

/*
 * The timedaemons synchronize the clocks of hosts in a local area network.
 * One daemon runs as master, all the others as slaves. The master
 * performs the task of computing clock differences and sends correction
 * values to the slaves.
 * Slaves start an election to choose a new master when the latter disappears
 * because of a machine crash, network partition, or when killed.
 * A resolution protocol is used to kill all but one of the masters
 * that happen to exist in segments of a partitioned network when the
 * network partition is fixed.
 *
 * Authors: Riccardo Gusella & Stefano Zatti
 *
 * overhauled at Silicon Graphics
 */
int
main(int argc, char **argv)
{
	int on;
	int ret;
	int nflag, iflag;
	struct timeval ntime;
	struct servent *srvp;
	struct netinfo *ntp;
	struct netinfo *ntip;
	struct netinfo *savefromnet;
	struct nets *nt;
	struct sockaddr_in server;
	u_short port;
	int ch;
	struct ifaddrs *ifap, *ifa;

	ntip = NULL;

	on = 1;
	nflag = 0;
	iflag = 0;

	TAILQ_INIT(&nets);
	TAILQ_INIT(&goodhosts);

	opterr = 0;
	while ((ch = getopt(argc, argv, "F:G:Mdi:n:t")) != -1) {
		switch (ch) {
		case 'F':
			add_good_host(optarg, 1);
			while (optind < argc && argv[optind][0] != '-')
				add_good_host(argv[optind++], 1);
			break;
		case 'G':
			if (goodgroup != NULL) {
				fprintf(stderr,"timed: only one net group\n");
				exit(1);
			}
			goodgroup = optarg;
			break;
		case 'M':
			Mflag = 1;
			break;
		case 'd':
			debug = 1;
			break;
		case 'i':
			iflag = 1;
			addnetname(optarg);
			break;
		case 'n':
			nflag = 1;
			addnetname(optarg);
			break;
		case 't':
			trace = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	if (optind < argc)
		usage();

	if (nflag && iflag) {
		fprintf(stderr, "timed: -i and -n make no sense together\n");
		exit(1);
	}

	/*
	 * If we care about which machine is the master, then we must be
	 * willing to be a master as well.
	 */
	if ((goodgroup != NULL) || !TAILQ_EMPTY(&goodhosts))
		Mflag = 1;

	if (gethostname(hostname, sizeof(hostname)) < 0) {
		perror("gethostname");
		exit(1);
	}
	self.l_bak = &self;
	self.l_fwd = &self;
	self.h_bak = &self;
	self.h_fwd = &self;
	self.head = 1;
	self.good = 1;

	/* Add ourselves to the list of trusted hosts */
	if (!TAILQ_EMPTY(&goodhosts))
		add_good_host(hostname, 1);

	if ((srvp = getservbyname("timed", "udp")) == NULL) {
		fprintf(stderr, "unknown service 'timed/udp'\n");
		exit(1);
	}
	port = srvp->s_port;
	bzero(&server, sizeof(server));
	server.sin_port = srvp->s_port;
	server.sin_family = AF_INET;
	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock < 0) {
		perror("socket");
		exit(1);
	}
	if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (char *)&on,
							sizeof(on)) < 0) {
		perror("setsockopt");
		exit(1);
	}
	if (bind(sock, (struct sockaddr*)&server, sizeof(server))) {
		if (errno == EADDRINUSE)
			fprintf(stderr,"timed: time daemon already running\n");
		else
			perror("bind");
		exit(1);
	}

	sequence = arc4random();     /* initial seq number */

	gettimeofday(&ntime, 0);
	/* rounds kernel variable time to multiple of 5 ms. */
	ntime.tv_sec = 0;
	ntime.tv_usec = -((ntime.tv_usec/1000) % 5) * 1000;
	(void)adjtime(&ntime, (struct timeval *)0);

	TAILQ_FOREACH(nt, &nets, next) {
		struct netent *nentp;

		nentp = getnetbyname(nt->name);
		if (nentp == 0) {
			nt->net = inet_network(nt->name);
			if (nt->net != INADDR_NONE)
				nentp = getnetbyaddr(nt->net, AF_INET);
		}
		if (nentp != 0) {
			nt->net = nentp->n_net;
		} else if (nt->net == INADDR_NONE) {
			fprintf(stderr, "timed: unknown net %s\n", nt->name);
			exit(1);
		} else if (nt->net == INADDR_ANY) {
			fprintf(stderr, "timed: bad net %s\n", nt->name);
			exit(1);
		} else {
			fprintf(stderr,
				"timed: warning: %s unknown in /etc/networks\n",
				nt->name);
		}

		if (0 == (nt->net & 0xff000000))
		    nt->net <<= 8;
		if (0 == (nt->net & 0xff000000))
		    nt->net <<= 8;
		if (0 == (nt->net & 0xff000000))
		    nt->net <<= 8;
	}

	if (getifaddrs(&ifap) != 0) {
		perror("timed: get interface configuration");
		exit(1);
	}

	ntp = NULL;
	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;
		if (!ntp)
			ntp = (struct netinfo*)malloc(sizeof(struct netinfo));
		bzero(ntp, sizeof(*ntp));
		ntp->my_addr=((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
		ntp->status = NOMASTER;

		if ((ifa->ifa_flags & IFF_UP) == 0)
			continue;
		if ((ifa->ifa_flags & IFF_BROADCAST) == 0 &&
		    (ifa->ifa_flags & IFF_POINTOPOINT) == 0) {
			continue;
		}

		((struct sockaddr_in *)ifa->ifa_addr)->sin_addr = ntp->my_addr;
		ntp->mask = ((struct sockaddr_in *)
			ifa->ifa_netmask)->sin_addr.s_addr;

		if (ifa->ifa_flags & IFF_BROADCAST) {
			ntp->dest_addr = *(struct sockaddr_in *)ifa->ifa_broadaddr;
			/* What if the broadcast address is all ones?
			 * So we cannot just mask ntp->dest_addr.  */
			ntp->net = ntp->my_addr;
			ntp->net.s_addr &= ntp->mask;
		} else {
			ntp->dest_addr = *(struct sockaddr_in *)ifa->ifa_dstaddr;
			ntp->net = ntp->dest_addr.sin_addr;
		}

		ntp->dest_addr.sin_port = port;

		TAILQ_FOREACH(nt, &nets, next) {
			if (ntohl(ntp->net.s_addr) == nt->net)
				break;
		}
		if ((nflag && !nt) || (iflag && nt))
			continue;

		ntp->next = NULL;
		if (nettab == NULL) {
			nettab = ntp;
		} else {
			ntip->next = ntp;
		}
		ntip = ntp;
		ntp = NULL;
	}

	if (ntp)
		(void) free((char *)ntp);
	if (nettab == NULL) {
		fprintf(stderr, "timed: no network usable\n");
		exit(1);
	}
	freeifaddrs(ifap);

	/* election timer delay in secs. */
	delay2 = casual(MINTOUT, MAXTOUT);

	if (!debug)
		daemon(debug, 0);

	if (trace)
		traceon();
	openlog("timed", LOG_CONS|LOG_PID, LOG_DAEMON);

	/*
	 * keep returning here
	 */
	ret = setjmp(jmpenv);
	savefromnet = fromnet;
	setstatus();

	if (Mflag) {
		switch (ret) {

		case 0:
			checkignorednets();
			pickslavenet(0);
			break;
		case 1:
			/* Just lost our master */
			if (slavenet != 0)
				slavenet->status = election(slavenet);
			if (!slavenet || slavenet->status == MASTER) {
				checkignorednets();
				pickslavenet(0);
			} else {
				makeslave(slavenet);	/* prune extras */
			}
			break;

		case 2:
			/* Just been told to quit */
			justquit = 1;
			pickslavenet(savefromnet);
			break;
		}

		setstatus();
		if (!(status & MASTER) && sock_raw != -1) {
			/* sock_raw is not being used now */
			(void)close(sock_raw);
			sock_raw = -1;
		}

		if (status == MASTER)
			master();
		else
			slave();

	} else {
		if (sock_raw != -1) {
			(void)close(sock_raw);
			sock_raw = -1;
		}

		if (ret) {
			/* we just lost our master or were told to quit */
			justquit = 1;
		}
		for (ntp = nettab; ntp != NULL; ntp = ntp->next) {
			if (ntp->status == MASTER) {
				rmnetmachs(ntp);
				ntp->status = NOMASTER;
			}
		}
		checkignorednets();
		pickslavenet(0);
		setstatus();

		slave();
	}
	/* NOTREACHED */
	return(0);
}


/*
 * suppress an upstart, untrustworthy, self-appointed master
 */
void
suppress(struct sockaddr_in *addr, const char *name, struct netinfo *net)
{
	struct sockaddr_in tgt;
	char tname[MAXHOSTNAMELEN];
	struct tsp msg;
	static struct timeval wait;

	if (trace)
		fprintf(fd, "suppress: %s\n", name);
	tgt = *addr;
	strlcpy(tname, name, sizeof(tname));

	while (readmsg(TSP_ANY, ANYADDR, &wait, net) != NULL) {
		if (trace)
			fprintf(fd, "suppress:\tdiscarded packet from %s\n",
				    name);
	}

	syslog(LOG_NOTICE, "suppressing false master %s", tname);

	memset(&msg, 0, sizeof(msg));
	msg.tsp_type = TSP_QUIT;
	strlcpy(msg.tsp_name, hostname, sizeof msg.tsp_name);

	(void)acksend(&msg, &tgt, tname, TSP_ACK, 0, 1);
}

void
lookformaster(struct netinfo *ntp)
{
	struct tsp resp, conflict, *answer;
	struct timeval ntime;
	char mastername[MAXHOSTNAMELEN];
	struct sockaddr_in masteraddr;

	get_goodgroup(0);
	ntp->status = SLAVE;

	/* look for master */
	memset(&resp, 0, sizeof(resp));
	resp.tsp_type = TSP_MASTERREQ;
	strlcpy(resp.tsp_name, hostname, sizeof(resp.tsp_name));

	answer = acksend(&resp, &ntp->dest_addr, ANYADDR,
			 TSP_MASTERACK, ntp, 0);
	if ((answer != NULL) && !good_host_name(answer->tsp_name)) {
		suppress(&from, answer->tsp_name, ntp);
		ntp->status = NOMASTER;
		answer = 0;
	}

	if (answer == NULL) {
		/*
		 * Various conditions can cause conflict: races between
		 * two just started timedaemons when no master is
		 * present, or timedaemons started during an election.
		 * A conservative approach is taken.  Give up and became a
		 * slave, postponing election of a master until first
		 * timer expires.
		 */
		timerclear(&ntime);
		answer = readmsg(TSP_MASTERREQ, ANYADDR, &ntime, ntp);
		if (answer != NULL) {
			if (!good_host_name(answer->tsp_name)) {
				suppress(&from, answer->tsp_name, ntp);
				ntp->status = NOMASTER;
			}
			return;
		}

		timerclear(&ntime);
		answer = readmsg(TSP_MASTERUP, ANYADDR, &ntime, ntp);
		if (answer != NULL) {
			if (!good_host_name(answer->tsp_name)) {
				suppress(&from, answer->tsp_name, ntp);
				ntp->status = NOMASTER;
			}
			return;
		}

		timerclear(&ntime);
		answer = readmsg(TSP_ELECTION, ANYADDR, &ntime, ntp);
		if (answer != NULL) {
			if (!good_host_name(answer->tsp_name)) {
				suppress(&from, answer->tsp_name, ntp);
				ntp->status = NOMASTER;
			}
			return;
		}

		if (Mflag)
			ntp->status = MASTER;
		else
			ntp->status = NOMASTER;
		return;
	}

	ntp->status = SLAVE;
	strlcpy(mastername, answer->tsp_name, sizeof mastername);
	masteraddr = from;

	/*
	 * If network has been partitioned, there might be other
	 * masters; tell the one we have just acknowledged that
	 * it has to gain control over the others.
	 */
	ntime.tv_sec = 0;
	ntime.tv_usec = 300000;
	answer = readmsg(TSP_MASTERACK, ANYADDR, &ntime, ntp);

	/*
	 * checking also not to send CONFLICT to ack'ed master
	 * due to duplicated MASTERACKs
	 */
	if (answer != NULL &&
	    strcmp(answer->tsp_name, mastername) != 0) {
		conflict.tsp_type = TSP_CONFLICT;
		strlcpy(conflict.tsp_name, hostname, sizeof conflict.tsp_name);
		if (!acksend(&conflict, &masteraddr, mastername,
			     TSP_ACK, 0, 0)) {
			syslog(LOG_ERR,
			       "error on sending TSP_CONFLICT");
		}
	}
}

/*
 * based on the current network configuration, set the status, and count
 * networks;
 */
void
setstatus(void)
{
	struct netinfo *ntp;

	status = 0;
	nmasternets = nslavenets = nnets = nignorednets = 0;
	if (trace)
		fprintf(fd, "Net status:\n");
	for (ntp = nettab; ntp != NULL; ntp = ntp->next) {
		switch ((int)ntp->status) {
		case MASTER:
			nmasternets++;
			break;
		case SLAVE:
			nslavenets++;
			break;
		case NOMASTER:
		case IGNORE:
			nignorednets++;
			break;
		}
		if (trace) {
			fprintf(fd, "\t%-16s", inet_ntoa(ntp->net));
			switch ((int)ntp->status) {
			case NOMASTER:
				fprintf(fd, "NOMASTER\n");
				break;
			case MASTER:
				fprintf(fd, "MASTER\n");
				break;
			case SLAVE:
				fprintf(fd, "SLAVE\n");
				break;
			case IGNORE:
				fprintf(fd, "IGNORE\n");
				break;
			default:
				fprintf(fd, "invalid state %d\n",
					(int)ntp->status);
				break;
			}
		}
		nnets++;
		status |= ntp->status;
	}
	status &= ~IGNORE;
	if (trace)
		fprintf(fd,
		    "\tnets=%d masters=%d slaves=%d ignored=%d delay2=%ld\n",
		    nnets, nmasternets, nslavenets, nignorednets, delay2);
}

void
makeslave(struct netinfo *net)
{
	struct netinfo *ntp;

	for (ntp = nettab; ntp != NULL; ntp = ntp->next) {
		if (ntp->status == SLAVE && ntp != net)
			ntp->status = IGNORE;
	}
	slavenet = net;
}

/*
 * Try to become master over ignored nets..
 */
static void
checkignorednets(void)
{
	struct netinfo *ntp;

	for (ntp = nettab; ntp != NULL; ntp = ntp->next) {
		if (!Mflag && ntp->status == SLAVE)
			break;

		if (ntp->status == IGNORE || ntp->status == NOMASTER) {
			lookformaster(ntp);
			if (!Mflag && ntp->status == SLAVE)
				break;
		}
	}
}

/*
 * choose a good network on which to be a slave
 *	The ignored networks must have already been checked.
 *	Take a hint about for a good network.
 */
static void
pickslavenet(struct netinfo *ntp)
{
	if (slavenet != 0 && slavenet->status == SLAVE) {
		makeslave(slavenet);		/* prune extras */
		return;
	}

	if (ntp == 0 || ntp->status != SLAVE) {
		for (ntp = nettab; ntp != 0; ntp = ntp->next) {
			if (ntp->status == SLAVE)
				break;
		}
	}
	makeslave(ntp);
}

/*
 * returns a random number in the range [inf, sup]
 */
long
casual(long inf, long sup)
{
	return (inf + random() % (sup - inf + 1));
}

char *
date(void)
{
	struct	timeval tv;
	time_t t;

	(void)gettimeofday(&tv, (struct timezone *)0);
	t = tv.tv_sec;
	return (ctime(&t));
}

void
addnetname(const char *name)
{
	struct nets *netlist;

	if ((netlist = (struct nets *)calloc(1, sizeof(*netlist))) == NULL)
		err(1, "malloc");
	strlcpy(netlist->name, name, sizeof(netlist->name));
	TAILQ_INSERT_TAIL(&nets, netlist, next);
}

/*
 * add_good_host() -
 *
 * Add a host to our list of trusted hosts.
 */
static void
add_good_host(const char *name, int perm)
{
	struct goodhost *ghp;
	struct hostent *hentp;

	if ((ghp = (struct goodhost *)calloc(1, sizeof(*ghp))) == NULL)
		err(1, "malloc");
	strlcpy(ghp->name, name, sizeof(ghp->name));
	ghp->perm = perm;
	TAILQ_INSERT_TAIL(&goodhosts, ghp, next);

	if ((hentp = gethostbyname(name)) == NULL && perm)
		(void)fprintf(stderr, "unknown host %s\n", name);
}


/* update our image of the net-group of trustworthy hosts
 */
void
get_goodgroup(int force)
{
# define NG_DELAY (30*60*CLK_TCK)	/* 30 minutes */
	static unsigned long last_update = -NG_DELAY;
	unsigned long new_update;
	struct hosttbl *htp;
	struct goodhost *ghp, *nxt;
	const char *mach, *usr, *dom;
	struct tms tm;


	/* if no netgroup, then we are finished */
	if (goodgroup == 0 || !Mflag)
		return;

	/* Do not chatter with the netgroup master too often.
	 */
	new_update = times(&tm);
	if (new_update < last_update + NG_DELAY
	    && !force)
		return;
	last_update = new_update;

	/* forget the old temporary entries */
	for (ghp = TAILQ_FIRST(&goodhosts); ghp != NULL; ghp = nxt) {
		nxt = TAILQ_NEXT(ghp, next);

		if (!ghp->perm) {
			TAILQ_REMOVE(&goodhosts, ghp, next);
			free(ghp);
		}
	}

	/* quit now if we are not one of the trusted masters
	 */
	if (!innetgr(goodgroup, &hostname[0], 0,0)) {
		if (trace)
			(void)fprintf(fd, "get_goodgroup: %s not in %s\n",
				      &hostname[0], goodgroup);
		return;
	}
	if (trace)
		(void)fprintf(fd, "get_goodgroup: %s in %s\n",
				  &hostname[0], goodgroup);

	/* mark the entire netgroup as trusted */
	(void)setnetgrent(goodgroup);
	while (getnetgrent(&mach,&usr,&dom)) {
		if (0 != mach)
			add_good_host(mach,0);
	}
	(void)endnetgrent();

	/* update list of slaves */
	for (htp = self.l_fwd; htp != &self; htp = htp->l_fwd) {
		htp->good = good_host_name(&htp->name[0]);
	}
}


/* see if a machine is trustworthy
 */
int					/* 1=trust hp to change our date */
good_host_name(const char *name)
{
	struct goodhost *ghp;

	if (TAILQ_EMPTY(&goodhosts) || !Mflag)
		return (1);

	TAILQ_FOREACH(ghp, &goodhosts, next) {
		if (strcasecmp(ghp->name, name) == 0)
			return (1);
	}

	/* XXX - Should be no need for this since we already added ourselves */
	if (strcasecmp(name, hostname) == 0)
		return (1);

	return (0);
}

static void
usage(void)
{
	(void)fprintf(stderr, "usage: timed [-dMt] [-F host ...] [-G netgroup] "
	    "[-i network | -n network]\n");
	exit(1);
}
@


1.30
log
@use timerclear macro

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.29 2009/10/27 23:59:57 deraadt Exp $	*/
@


1.29
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.28 2008/03/17 16:29:25 sobrado Exp $	*/
d480 1
a480 1
		ntime.tv_sec = ntime.tv_usec = 0;
d490 1
a490 1
		ntime.tv_sec = ntime.tv_usec = 0;
d500 1
a500 1
		ntime.tv_sec = ntime.tv_usec = 0;
@


1.28
log
@use the right format for "usage:"; "usage:" is lowercase

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.27 2007/10/17 20:10:44 chl Exp $	*/
a30 10

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1985, 1993 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char sccsid[] = "@@(#)timed.c	5.1 (Berkeley) 5/11/93";
#endif /* not lint */
@


1.27
log
@remove "unused variable" warnings

tested by deraadt@@ on a gcc2 arch

looks ok ray@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.26 2007/02/19 22:39:57 jmc Exp $	*/
d808 1
a808 1
	(void)fprintf(stderr, "timed: [-dMt] [-F host ...] [-G netgroup] "
@


1.26
log
@sort options and sync usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.25 2005/02/17 12:33:30 aaron Exp $	*/
a134 1
	int inlen = 8192;
@


1.25
log
@Fix scoping error where ignored nets could transition to the NOMASTER state
erroneously.  henning@@, otto@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.24 2003/11/04 14:06:15 jmc Exp $	*/
d809 2
a810 2
	(void)fprintf(stderr, "timed: [-dMt] [-i network | -n network] "
	    "[-F host1 host2 ...] [-G netgroup]\n");
@


1.24
log
@sort options in SYNOPSIS and sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.23 2003/08/19 22:19:08 itojun Exp $	*/
d411 1
a411 1
			if (ntp->status == MASTER)
d414 1
@


1.23
log
@rewrite SIOCGIFCONF into getifaddrs.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.22 2003/07/18 22:58:56 david Exp $	*/
d808 1
a808 1
	(void)fprintf(stderr, "timed: [-dtM] [-i network | -n network] "
@


1.22
log
@add missing includes
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.21 2003/06/26 15:56:51 mickey Exp $	*/
d55 1
a128 3
	char *inbuf = NULL, *cp, *cplim;
	struct ifconf ifc;
	struct ifreq ifreq, ifreqf, *ifr;
d137 1
d281 3
a283 21
	while (1) {
		char *ninbuf;

		ifc.ifc_len = inlen;
		ninbuf = realloc(inbuf, inlen);
		if (ninbuf == NULL) {
			if (inbuf)
				free(inbuf);
			close(sock);
			return (-1);
		}
		ifc.ifc_buf = inbuf = ninbuf;
		if (ioctl(sock, SIOCGIFCONF, (char *)&ifc) < 0) {
			(void) close(sock);
			free(inbuf);
			perror("timed: get interface configuration");
			exit(1);
		}
		if (ifc.ifc_len + sizeof(ifreq) < inlen)
			break;
		inlen *= 2;
d287 2
a288 6
#define size(p)	max((p).sa_len, sizeof(p))
	cplim = inbuf + ifc.ifc_len; /*skip over if's with big ifr_addr's */
	for (cp = inbuf; cp < cplim;
			cp += sizeof (ifr->ifr_name) + size(ifr->ifr_addr)) {
		ifr = (struct ifreq *)cp;
		if (ifr->ifr_addr.sa_family != AF_INET)
d292 2
a293 2
		bzero(ntp,sizeof(*ntp));
		ntp->my_addr=((struct sockaddr_in *)&ifr->ifr_addr)->sin_addr;
a294 2
		ifreq = *ifr;
		ifreqf = *ifr;
d296 1
a296 2
		if (ioctl(sock, SIOCGIFFLAGS, (char *)&ifreqf) < 0) {
			perror("get interface flags");
d298 2
a299 5
		}
		if ((ifreqf.ifr_flags & IFF_UP) == 0)
			continue;
		if ((ifreqf.ifr_flags & IFF_BROADCAST) == 0 &&
		    (ifreqf.ifr_flags & IFF_POINTOPOINT) == 0) {
d303 1
a303 5
		((struct sockaddr_in *)&ifr->ifr_addr)->sin_addr = ntp->my_addr;
		if (ioctl(sock, SIOCGIFNETMASK, (char *)&ifreq) < 0) {
			perror("get netmask");
			continue;
		}
d305 1
a305 1
			&ifreq.ifr_addr)->sin_addr.s_addr;
d307 2
a308 8
		if (ifreqf.ifr_flags & IFF_BROADCAST) {
			((struct sockaddr_in *)&ifr->ifr_addr)->sin_addr =
				ntp->my_addr;
			if (ioctl(sock, SIOCGIFBRDADDR, (char *)&ifreq) < 0) {
				perror("get broadaddr");
				continue;
			}
			ntp->dest_addr = *(struct sockaddr_in *)&ifreq.ifr_broadaddr;
d314 1
a314 8
			((struct sockaddr_in *)&ifr->ifr_addr)->sin_addr =
				ntp->my_addr;
			if (ioctl(sock, SIOCGIFDSTADDR,
						(char *)&ifreq) < 0) {
				perror("get destaddr");
				continue;
			}
			ntp->dest_addr = *(struct sockaddr_in *)&ifreq.ifr_dstaddr;
d343 1
a343 1
	free(inbuf);
@


1.21
log
@avoid using floating point for a random in [a, b] and kill a false comment
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.20 2003/06/17 06:21:56 jmc Exp $	*/
d54 1
@


1.20
log
@- document "-G netgroup";
from Kurt V. Hindenburg on misc@@
- show that -i and -n are mutually exclusive
- sync SYNOPSIS and usage()

help from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.19 2003/06/12 21:09:48 deraadt Exp $	*/
a241 3
	/* choose a unique seed for random number generation */
	(void)gettimeofday(&ntime, 0);

d244 1
a392 1

d718 1
a718 4
	double value;

	value = ((double)(random() & 0x7fffffff)) / (0x7fffffff*1.0);
	return(inf + (sup - inf)*value);
@


1.19
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.18 2003/06/02 23:36:55 millert Exp $	*/
d859 2
a860 2
	(void)fprintf(stderr, "timed: [-dtM] [-i net|-n net] "
	    "[-F host1 host2 ...] [-G netgp]\n");
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.17 2002/06/19 18:54:31 ericj Exp $	*/
d609 1
a609 1
setstatus()
d728 1
a728 1
date()
d857 1
a857 1
usage()
@


1.17
log
@
init goodhosts
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.16 2002/06/19 15:45:39 ericj Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16
log
@
more cleanup for timed.
use queue.h instead of these badly hand done lists
functionalize more common code
remove some unused code/declarations
use strlcpy
minor KNF

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.15 2002/06/18 00:40:31 ericj Exp $	*/
d150 2
@


1.15
log
@
remove ifdef sgi code, and HAVENIS. sgi was pointless and this didnt even come
close to compiling w/o HAVENIS
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.14 2002/03/14 16:44:25 mpech Exp $	*/
d55 1
a62 1
long delay1;
d82 6
a87 5
static struct nets {
	char	*name;
	long	net;
	struct nets *next;
} *nets = 0;
d91 2
a92 1
static struct goodhost {		/* hosts that we trust */
d94 4
a97 3
	struct goodhost *next;
	char	perm;
} *goodhosts;
d100 3
d105 2
a106 1
static void add_good_host(const char*,char);
a136 1
	struct netent *nentp;
d141 1
a141 6
	int c;
	extern char *optarg;
	extern int optind, opterr;

#define	IN_MSG "timed: -i and -n make no sense together\n"
#define USAGE "timed: [-dtM] [-i net|-n net] [-F host1 host2 ...] [-G netgp]\n"
d146 2
a147 2
	nflag = OFF;
	iflag = OFF;
d149 1
d151 2
a152 30
	while ((c = getopt(argc, argv, "Mtdn:i:F:G:")) != -1) {
		switch (c) {
		case 'M':
			Mflag = 1;
			break;

		case 't':
			trace = 1;
			break;

		case 'n':
			if (iflag) {
				fprintf(stderr, IN_MSG);
				exit(1);
			} else {
				nflag = ON;
				addnetname(optarg);
			}
			break;

		case 'i':
			if (nflag) {
				fprintf(stderr, IN_MSG);
				exit(1);
			} else {
				iflag = ON;
				addnetname(optarg);
			}
			break;

d154 1
a154 1
			add_good_host(optarg,1);
a157 4

		case 'd':
			debug = 1;
			break;
d159 1
a159 1
			if (goodgroup != 0) {
d165 17
a181 1

d183 2
a184 3
			fprintf(stderr, USAGE);
			exit(1);
			break;
d187 6
a192 2
	if (optind < argc) {
		fprintf(stderr, USAGE);
d197 2
a198 2
	 * If we care about which machine is the master, then we must
	 *	be willing to be a master
d200 1
a200 1
	if (0 != goodgroup || 0 != goodhosts)
d214 3
a216 2
	if (goodhosts != 0)		/* trust ourself */
		add_good_host(hostname,1);
d218 1
a218 2
	srvp = getservbyname("timed", "udp");
	if (srvp == 0) {
d254 3
a256 1
	for (nt = nets; nt; nt = nt->next) {
d284 1
d369 1
a369 1
		for (nt = nets; nt; nt = nt->next) {
a393 3
	/* microseconds to delay before responding to a broadcast */
	delay1 = casual(1, 100*1000);

d476 2
a477 1
/* suppress an upstart, untrustworthy, self-appointed master
d480 1
a480 3
suppress(struct sockaddr_in *addr,
         char *name,
	 struct netinfo *net)
d490 1
a490 1
	strlcpy(tname, name, sizeof tname);
d492 1
a492 1
	while (0 != readmsg(TSP_ANY, ANYADDR, &wait, net)) {
d499 2
d503 1
d519 1
d521 2
a522 1
	strlcpy(resp.tsp_name, hostname, sizeof resp.tsp_name);
d525 1
a525 1
	if (answer != 0 && !good_host_name(answer->tsp_name)) {
d530 2
a531 1
	if (answer == 0) {
d542 1
a542 1
		if (answer != 0) {
d552 1
a552 1
		if (answer != 0) {
d562 1
a562 1
		if (answer != 0) {
d589 1
d741 1
a741 1
addnetname(char *name)
d743 1
a743 1
	struct nets **netlist = &nets;
d745 4
a748 9
	while (*netlist)
		netlist = &((*netlist)->next);
	*netlist = (struct nets *)malloc(sizeof **netlist);
	if (*netlist == 0) {
		fprintf(stderr,"malloc failed\n");
		exit(1);
	}
	bzero((char *)*netlist, sizeof(**netlist));
	(*netlist)->name = name;
d751 5
a755 1
/* note a host as trustworthy */
d757 1
a757 2
add_good_host(const char* name,
	      char perm)		/* 1=not part of the netgroup */
d762 3
a764 9
	ghp = (struct goodhost*)malloc(sizeof(*ghp));
	if (!ghp) {
		syslog(LOG_ERR, "malloc failed");
		exit(1);
	}

	bzero((char*)ghp, sizeof(*ghp));
	(void)strncpy(&ghp->name[0], name, sizeof(ghp->name));
	ghp->next = goodhosts;
d766 1
a766 1
	goodhosts = ghp;
d768 1
a768 2
	hentp = gethostbyname(name);
	if (0 == hentp && perm)
d782 1
a782 1
	struct goodhost *ghp, **ghpp;
d800 3
a802 2
	ghpp = &goodhosts;
	while (0 != (ghp = *ghpp)) {
d804 2
a805 4
			*ghpp = ghp->next;
			free((char*)ghp);
		} else {
			ghpp = &ghp->next;
d839 1
a839 2
good_host_name(name)
	char *name;
d841 4
a844 2
	struct goodhost *ghp = goodhosts;
	char c;
d846 4
a849 2
	if (!ghp || !Mflag)		/* trust everyone if no one named */
		return 1;
d851 3
a853 6
	c = *name;
	do {
		if (c == ghp->name[0]
		    && !strcasecmp(name, ghp->name))
			return 1;	/* found him, so say so */
	} while (0 != (ghp = ghp->next));
d855 2
a856 2
	if (!strcasecmp(name,hostname))	/* trust ourself */
		return 1;
d858 6
a863 1
	return 0;			/* did not find him */
@


1.14
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.13 2002/02/19 18:57:42 mpech Exp $	*/
a45 4
#ifdef sgi
#ident "$Revision: 1.13 $"
#endif /* sgi */

a55 1
#ifdef HAVENIS
a56 6
#endif /* HAVENIS */
#ifdef sgi
#include <unistd.h>
#include <sys/syssgi.h>
#include <sys/schedctl.h>
#endif /* sgi */
a100 12
#ifdef sgi
char *timetrim_fn;
char *timetrim_wpat = "long timetrim = %ld;\ndouble tot_adj = %.0f;\ndouble tot_ticks = %.0f;\n/* timed version 2 */\n";
char *timetrim_rpat = "long timetrim = %ld;\ndouble tot_adj = %lf;\ndouble tot_ticks = %lf;";
long timetrim;
double tot_adj, hr_adj;			/* totals in nsec */
double tot_ticks, hr_ticks;

int bufspace = 60*1024;
#endif


a137 3
#ifdef sgi
	FILE *timetrim_st;
#endif
a139 5
#ifdef sgi
	struct tms tms;
#define USAGE "timed: [-dtM] [-i net|-n net] [-F host1 host2 ...] [-G netgp] [-P trimfile]\n"
#else
#ifdef HAVENIS
a140 4
#else
#define USAGE "timed: [-dtM] [-i net|-n net] [-F host1 host2 ...]\n"
#endif /* HAVENIS */
#endif /* sgi */
a147 8
#ifdef sgi
	if (0 > syssgi(SGI_GETTIMETRIM, &timetrim)) {
		perror("timed: syssgi(GETTIMETRIM)");
		timetrim = 0;
	}
	tot_ticks = hr_ticks = times(&tms);
#endif /* sgi */

d149 1
a149 1
	while ((c = getopt(argc, argv, "Mtdn:i:F:G:P:")) != -1) {
a194 5
#ifdef sgi
		case 'P':
			timetrim_fn = optarg;
			break;
#endif /* sgi */
d207 2
a208 41
#ifdef sgi
	if (timetrim_fn == 0) {
		;
	} else if (0 == (timetrim_st = fopen(timetrim_fn, "r+"))) {
		if (errno != ENOENT) {
			(void)fprintf(stderr,"timed: ");
			perror(timetrim_fn);
			timetrim_fn = 0;
		}
	} else {
		int i;
		long trim;
		double adj, ticks;

		i = fscanf(timetrim_st, timetrim_rpat,
			   &trim, &adj, &ticks);
		if (i < 1
		    || trim > MAX_TRIM
		    || trim < -MAX_TRIM
		    || i == 2
		    || (i == 3
			&& trim != rint(adj*CLK_TCK/ticks))) {
			if (trace && i != EOF)
				(void)fprintf(stderr,
		    "timed: unrecognized contents in %s\n",
					      timetrim_fn);
		} else {
			if (0 > syssgi(SGI_SETTIMETRIM,
				       trim)) {
			 perror("timed: syssgi(SETTIMETRIM)");
			} else {
				timetrim = trim;
			}
			if (i == 3)
				tot_ticks -= ticks;
		}
		(void)fclose(timetrim_st);
	}
#endif /* sgi */

	/* If we care about which machine is the master, then we must
a253 10
#ifdef sgi
	/*
	 * handle many slaves with our buffer
	 */
	if (0 > setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char*)&bufspace,
			 sizeof(bufspace))) {
		perror("setsockopt");
		exit(1);
	}
#endif /* sgi */
a259 1
#ifndef sgi
a263 1
#endif /* sgi */
a316 3
#ifdef sgi
#define size(p)	(sizeof(*ifr) - sizeof(ifr->ifr_name))  /* XXX hack. kludge */
#else
a317 1
#endif
a401 7
#ifdef sgi
	(void)schedctl(RENICE,0,10);	   /* run fast to get good time */

	/* ticks to delay before responding to a broadcast */
	delay1 = casual(0, CLK_TCK/10);
#else

a403 1
#endif /* sgi */
a408 3
#ifdef sgi
	(void)_daemonize(debug ? _DF_NOFORK|_DF_NOCHDIR : 0, sock, -1, -1);
#else
a410 1
#endif /* sgi */
a736 8
#ifdef sgi
	struct	timeval tv;
	static char tm[32];

	(void)gettimeofday(&tv, (struct timezone *)0);
	(void)cftime(tm, "%D %T", &tv.tv_sec);
	return (tm);
#else
a742 1
#endif /* sgi */
a794 1
#ifdef HAVENIS
a797 1
#endif
a823 1
#ifdef HAVENIS
a847 1
#endif /* HAVENIS */
@


1.13
log
@Use arc4random().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.12 2002/02/19 18:38:02 mpech Exp $	*/
d47 1
a47 1
#ident "$Revision: 1.12 $"
d150 1
a150 1
	register struct netinfo *ntp;
d786 1
a786 1
	register struct netinfo *ntp;
d801 1
a801 1
	register struct netinfo *ntp;
d872 1
a872 1
	register struct nets **netlist = &nets;
d890 2
a891 2
	register struct goodhost *ghp;
	register struct hostent *hentp;
d985 2
a986 2
	register struct goodhost *ghp = goodhosts;
	register char c;
@


1.12
log
@Fix gethostname() usage.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.11 2001/11/23 03:45:51 deraadt Exp $	*/
d47 1
a47 1
#ident "$Revision: 1.11 $"
a353 1
	srandom(ntime.tv_sec + ntime.tv_usec);
d355 1
a355 1
	sequence = random();     /* initial seq number */
@


1.11
log
@use siginterrupt() enabling around all blocking calls, and check the flags; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.10 2001/05/05 05:10:05 mickey Exp $	*/
d47 1
a47 1
#ident "$Revision: 1.10 $"
d301 1
a301 1
	if (gethostname(hostname, sizeof(hostname) - 1) < 0) {
@


1.10
log
@use strlcpy vs strncpy+a[len-1]='\0', some trailing spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: timed.c,v 1.9 2001/04/07 19:58:07 ho Exp $	*/
d47 1
a47 1
#ident "$Revision: 1.9 $"
d84 2
@


1.9
log
@Avoid a compiler warning. Add $OpenBSD$. (Suggestion and ok millert@@)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
#ident "$Revision: 1.8 $"
d465 1
a465 1
		} else { 
d616 1
a616 2
	(void)strncpy(tname, name, sizeof tname-1);
	tname[sizeof tname-1] = '\0';
d626 1
a626 2
	(void)strncpy(msg.tsp_name, hostname, sizeof msg.tsp_name-1);
	msg.tsp_name[sizeof msg.tsp_name-1] = '\0';
d643 1
a643 2
	(void)strncpy(resp.tsp_name, hostname, sizeof resp.tsp_name-1);
	resp.tsp_name[sizeof resp.tsp_name-1] = '\0';
d698 1
a698 2
	(void)strncpy(mastername, answer->tsp_name, sizeof mastername-1);
	mastername[sizeof mastername-1] = '\0';
d716 1
a716 3
		(void)strncpy(conflict.tsp_name, hostname,
		    sizeof conflict.tsp_name-1);
		conflict.tsp_name[sizeof conflict.tsp_name-1] = '\0';
@


1.8
log
@Fix -Wall warnings; millert@@ ok.
@
text
@d1 2
d47 1
a47 1
#ident "$Revision: 1.7 $"
d108 1
a108 1
static void add_good_host(char*,char);
d892 1
a892 1
add_good_host(char* name,
d927 1
a927 1
	char *mach, *usr, *dom;
@


1.7
log
@fix realloc leak
@
text
@d45 1
a45 1
#ident "$Revision: 1.6 $"
d58 3
a172 1
#ifdef lint
a173 1
#endif
d481 1
a481 1
		if (nflag && !nt || iflag && nt)
a594 1
#ifdef lint
a595 1
#endif
d782 2
a783 2
			"\tnets=%d masters=%d slaves=%d ignored=%d delay2=%d\n",
			nnets, nmasternets, nslavenets, nignorednets, delay2);
d922 1
d926 1
@


1.6
log
@Aliases.
@
text
@d45 1
a45 1
#ident "$Revision: 1.5 $"
d389 2
d392 4
a395 2
		ifc.ifc_buf = inbuf = realloc(inbuf, inlen);
		if (inbuf == NULL) {
d399 1
@


1.5
log
@SIOCGIFCONF nicely
@
text
@d45 1
a45 1
#ident "$Revision: 1.4 $"
d437 1
a437 1

d446 2
d457 3
a459 1
		} else {
@


1.4
log
@Fix byte-order bug in net number comparison (NetBSD).
From Juergen Hannken-Illjes <hannken@@eis.cs.tu-bs.de>, NetBSD PR #2961.
@
text
@d45 1
a45 1
#ident "$Revision: 1.3 $"
d140 1
a140 1
	char buf[BUFSIZ], *cp, *cplim;
d150 1
d388 16
a403 5
	ifc.ifc_len = sizeof(buf);
	ifc.ifc_buf = buf;
	if (ioctl(sock, SIOCGIFCONF, (char *)&ifc) < 0) {
		perror("timed: get interface configuration");
		exit(1);
d405 1
d412 2
a413 2
	cplim = buf + ifc.ifc_len; /*skip over if's with big ifr_addr's */
	for (cp = buf; cp < cplim;
d483 1
d490 1
a490 1

@


1.3
log
@40 buf oflows
@
text
@d45 1
a45 1
#ident "$Revision: 1.2 $"
d455 1
a455 1
			if (ntp->net.s_addr == nt->net)
@


1.2
log
@sync to netbsd 960418
@
text
@d45 1
a45 1
#ident "$Revision: 1.1.1.2 $"
d95 1
a95 1
	char	name[MAXHOSTNAMELEN+1];
d592 2
a593 1
	(void)strcpy(tname, name);
d603 2
a604 1
	(void)strcpy(msg.tsp_name, hostname);
d621 2
a622 1
	(void)strcpy(resp.tsp_name, hostname);
d677 2
a678 1
	(void)strcpy(mastername, answer->tsp_name);
d696 3
a698 1
		(void)strcpy(conflict.tsp_name, hostname);
@


1.1
log
@Initial revision
@
text
@d45 1
a45 1
#ident "$Revision: 1.5 $"
d150 1
a150 1
	char c;
d186 1
a186 1
	while ((c = getopt(argc, argv, "Mtdn:i:F:G:P:")) != EOF) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

