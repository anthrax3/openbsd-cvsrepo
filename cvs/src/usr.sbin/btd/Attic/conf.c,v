head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.14
	OPENBSD_5_0:1.4.0.12
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.10
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.8
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.5
date	2012.04.01.15.15.35;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2008.11.26.15.32.56;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.26.06.51.43;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.25.17.13.53;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.24.23.34.42;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.5
log
@move to the Attic
@
text
@#include <sys/types.h>

#include <netbt/hci.h>

#include <assert.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include "btd.h"

struct btd *
conf_new(void)
{
	struct btd *conf;

	if ((conf = calloc(1, sizeof(*conf))) == NULL)
		return NULL;

	TAILQ_INIT(&conf->interfaces);
	TAILQ_INIT(&conf->devices);

	return conf;
}

void
conf_delete(struct btd *conf)
{
	while (!TAILQ_EMPTY(&conf->interfaces))
		conf_delete_interface(TAILQ_FIRST(&conf->interfaces));

	while (!TAILQ_EMPTY(&conf->devices))
		conf_delete_device(TAILQ_FIRST(&conf->devices));
}

/* cope well, and silently with bad arguments, because this function
   may be called via the control socket */
struct bt_interface *
conf_add_interface(struct btd *conf, const bdaddr_t *addr)
{
	struct bt_interface *iface;

	if (conf_find_interface(conf, addr) != NULL) {
		errno = EEXIST;
		return NULL;
	}

	if ((iface = calloc(1, sizeof(*iface))) == NULL)
		return NULL;

	iface->env = conf;
	bdaddr_copy(&iface->addr, addr);

	TAILQ_INSERT_TAIL(&conf->interfaces, iface, entry);

	return iface;
}

struct bt_interface *
conf_find_interface(const struct btd *conf, const bdaddr_t *addr)
{
	struct bt_interface *iface;

	TAILQ_FOREACH(iface, &conf->interfaces, entry) {
		if (bdaddr_same(&iface->addr, addr))
			return iface;
	}

	return NULL;
}

void
conf_delete_interface(struct bt_interface *iface)
{
	struct btd *conf = iface->env;

	TAILQ_REMOVE(&conf->interfaces, iface, entry);

	free(iface);
}

/* cope well, and silently with bad arguments, because this function
   may be called via the control socket */
struct bt_device *
conf_add_device(struct btd *conf, const bdaddr_t *addr)
{
	struct bt_device *btdev;

	if (conf_find_device(conf, addr) != NULL) {
		errno = EEXIST;
		return NULL;
	}

	if ((btdev = calloc(1, sizeof(*btdev))) == NULL)
		return NULL;

	btdev->env = conf;
	bdaddr_copy(&btdev->addr, addr);

	TAILQ_INSERT_TAIL(&conf->devices, btdev, entry);

	return btdev;
}

struct bt_device *
conf_find_device(const struct btd *conf, const bdaddr_t *addr)
{
	struct bt_device *btdev;

	TAILQ_FOREACH(btdev, &conf->devices, entry) {
		if (bdaddr_same(&btdev->addr, addr))
			return btdev;
	}

	return NULL;
}

void
conf_delete_device(struct bt_device *btdev)
{
	struct btd *conf = btdev->env;

	TAILQ_REMOVE(&conf->devices, btdev, entry);

	free(btdev);
}

void
conf_lookup_pin(const struct btd *conf, const bdaddr_t *addr,
    uint8_t pin[HCI_PIN_SIZE], uint8_t *pin_size)
{
	struct bt_device *btdev;

	if ((btdev = conf_find_device(conf, addr)) == NULL &&
	    (btdev = conf_find_device(conf, BDADDR_ANY)) == NULL) {
		memset(pin, 0, HCI_PIN_SIZE);
		*pin_size = 0;
		return;
	}

	memcpy(pin, btdev->pin, HCI_PIN_SIZE);
	*pin_size = btdev->pin_size;
}

void
conf_dump(const struct btd *conf)
{
	struct bt_interface *iface;
	struct bt_device *btdev;

	TAILQ_FOREACH(iface, &conf->interfaces, entry) {
		log_debug("interface %s%s", bt_ntoa(&iface->addr, NULL),
		    iface->disabled ? " disabled" : "");
	}

	TAILQ_FOREACH(btdev, &conf->devices, entry) {
		log_debug("%s %s type %#x%s%*s%s (%s)",
		    btdev->flags & BTDF_ATTACH ? "attach" : "device",
		    bt_ntoa(&btdev->addr, NULL), btdev->type,
		    btdev->pin_size > 0 ? " pin \"" : "", btdev->pin_size,
		    btdev->pin, btdev->pin_size > 0 ? "\"" : "",
		    btdev->flags & BTDF_ATTACH_DONE ? "attached" :
		    "detached");
	}

}
@


1.4
log
@Device attach and detach (does not work because SDP is not implemented yet)
@
text
@@


1.3
log
@Implement config reloading (still only work in progress)
@
text
@d157 2
a158 1
		log_debug("device %s type %#x%s%*s%s",
d161 3
a163 1
		    btdev->pin, btdev->pin_size > 0 ? "\"" : "");
@


1.2
log
@Get rid of dependencies on ports libraries (among other things)
@
text
@a52 1
	iface->fd = -1;
d130 1
a130 1
    uint8_t pin[HCI_PIN_SIZE], uint8_t *pin_len)
d137 1
a137 1
		*pin_len = 0;
d142 1
a142 1
	*pin_len = btdev->pin_len;
d152 2
a153 1
		log_info("interface %s", bt_ntoa(&iface->addr, NULL));
d157 4
a160 1
		log_info("device %s", bt_ntoa(&btdev->addr, NULL));
@


1.1
log
@Bluetooth daemon and contrl utility, one for all, work in progress
@
text
@d6 1
d12 2
a13 2
struct bt_device *
conf_add_device(struct btd *conf, const bdaddr_t *addr)
d15 1
a15 2
	struct bt_device *btdev;
	struct bt_device *defaults;
d17 1
a17 5
	assert(conf_find_device(conf, addr) == NULL);

	btdev = calloc(1, sizeof(*btdev));
	if (btdev == NULL) {
		log_warn("conf_add_device");
a18 1
	}
d20 2
a21 1
	bdaddr_copy(&btdev->addr, addr);
d23 2
a24 2
	defaults = bdaddr_any(addr) ? NULL :
	    conf_find_device(conf, BDADDR_ANY);
d26 5
a30 13
	if (defaults != NULL) {
		btdev->type = defaults->type;
		btdev->flags = defaults->flags;

		if (defaults->pin != NULL) {
			if ((btdev->pin = malloc(HCI_KEY_SIZE)) == NULL) {
				log_warn("conf_add_device malloc");
				TAILQ_REMOVE(&conf->devices, btdev, entry);
				return NULL;
			}
			memcpy(btdev->pin, defaults->pin, HCI_KEY_SIZE);
		}
	}
d32 2
a33 3
	TAILQ_INSERT_TAIL(&conf->devices, btdev, entry);

	return btdev;
d36 2
a41 1
	struct bt_interface *defaults;
d43 4
a46 1
	assert(conf_find_interface(conf, addr) == NULL);
d48 1
a48 3
	iface = calloc(1, sizeof(*iface));
	if (iface == NULL) {
		log_warn("conf_add_interface");
a49 1
	}
d51 1
a52 1
	iface->env = conf;
d55 24
a78 2
	defaults = bdaddr_any(addr) ? NULL :
	    conf_find_interface(conf, BDADDR_ANY);
d80 9
a88 8
	if (defaults != NULL) {
		if (defaults->name != NULL &&
		    (iface->name = strdup(defaults->name)) == NULL) {
			log_warn("conf_add_interface strdup");
			TAILQ_REMOVE(&conf->interfaces, iface, entry);
			free(iface);
			return NULL;
		}
d90 3
a92 1
		iface->disabled = defaults->disabled;
d95 7
a101 1
	TAILQ_INSERT_TAIL(&conf->interfaces, iface, entry);
d103 1
a103 1
	return iface;
d119 13
a131 2
struct bt_interface *
conf_find_interface(const struct btd *conf, const bdaddr_t *addr)
d133 1
a133 1
	struct bt_interface *iface;
d135 5
a139 3
	TAILQ_FOREACH(iface, &conf->interfaces, entry) {
		if (bdaddr_same(&iface->addr, addr))
			return iface;
d142 2
a143 1
	return NULL;
d146 2
a147 2
const uint8_t *
conf_lookup_pin(const struct btd *conf, const bdaddr_t *addr)
d149 1
d152 7
a158 3
	if ((btdev = conf_find_device(conf, addr)) == NULL &&
	    (btdev = conf_find_device(conf, BDADDR_ANY)) == NULL)
		return NULL;
a159 1
	return btdev->pin;
@

