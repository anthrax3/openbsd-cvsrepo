head	1.4;
access;
symbols
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.14
	OPENBSD_5_0:1.3.0.12
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.10
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.4
date	2012.04.01.15.15.35;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2008.11.26.21.48.30;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.25.17.13.53;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.24.23.34.42;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.4
log
@move to the Attic
@
text
@#include <stdlib.h>
#include <string.h>

#include "btd.h"

bdaddr_t *
devinfo_laddr(struct bt_devinfo *info)
{
	return &info->baa.bd_laddr;
}

bdaddr_t *
devinfo_raddr(struct bt_devinfo *info)
{
	return &info->baa.bd_raddr;
}

int
devinfo_store(const struct bt_devinfo *info, void **data, size_t *datalen)
{
	*datalen = sizeof(info->baa);
	if (info->baa.bd_type == BTDEV_HID)
		*datalen += info->baa.bd_hid.hid_dlen;

	if ((*data = malloc(*datalen)) == NULL) {
		log_warn("devinfo_store");
		return -1;
	}

	memcpy(*data, &info->baa, sizeof(info->baa));
	if (info->baa.bd_type == BTDEV_HID &&
	    info->baa.bd_hid.hid_dlen > 0)
		memcpy((uint8_t *)*data + sizeof(info->baa),
		    info->baa.bd_hid.hid_desc,
		    info->baa.bd_hid.hid_dlen);

	return 0;
}

int
devinfo_load(struct bt_devinfo *info, void *data, size_t datalen)
{
	return devinfo_load_attach_args(&info->baa, data, datalen);
}

void
devinfo_unload(struct bt_devinfo *info)
{
	return devinfo_unload_attach_args(&info->baa);
}

int
devinfo_load_attach_args(struct btdev_attach_args *baa, void *data,
    size_t datalen)
{
	if (datalen < sizeof(*baa)) {
		log_warnx("devinfo data too short");
		memset(baa, 0, sizeof(*baa));
		return -1;
	}

	memcpy(baa, data, sizeof(*baa));
	data = (struct btdev_attach_args *)data + 1;
	datalen -= sizeof(*baa);

	if (baa->bd_type == BTDEV_HID) {
		uint16_t dlen = baa->bd_hid.hid_dlen;
		void *desc = NULL;

		if (datalen != dlen) {
			log_warnx("bad devinfo data length (HID)");
			return -1;
		}

		if (dlen > 0) {
			if ((desc = malloc(dlen)) == NULL) {
				log_warn("devinfo_load_attach_args");
				return -1;
			}
			memcpy(desc, data, dlen);
		}

		baa->bd_hid.hid_desc = desc;
	} else if (datalen > 0) {
		log_warnx("devinfo data too long");
		return -1;
	}

	return 0;
}

void
devinfo_unload_attach_args(struct btdev_attach_args *baa)
{
	if (baa->bd_type == BTDEV_HID && baa->bd_hid.hid_desc != NULL) {
		free(baa->bd_hid.hid_desc);
		baa->bd_hid.hid_desc = NULL;
		baa->bd_hid.hid_dlen = 0;
	}
}

void
devinfo_dump(const struct bt_devinfo *info)
{
	const struct btdev_attach_args *baa = &info->baa;

	log_info("laddr %s", bt_ntoa(&baa->bd_laddr, NULL));
	log_info("raddr %s", bt_ntoa(&baa->bd_raddr, NULL));
	log_info("type %#x", baa->bd_type);
	log_info("mode %d", baa->bd_mode);
}
@


1.3
log
@SDP works, but it needs to be redone (and non-blocking)

With this in bt.conf, the HID driver should work:

 # Enable all interfaces.
 interface * "OpenBSD BT"
 # Attach a keyboard and/or mouse, or a mobile phone emulating such things.
 attach 00:02:76:08:1c:37 type hid pin "0000"

Then start btd and run btctl -f bt.conf.
@
text
@@


1.2
log
@Get rid of dependencies on ports libraries (among other things)
@
text
@d6 12
@


1.1
log
@Bluetooth daemon and contrl utility, one for all, work in progress
@
text
@a0 1
#include <bluetooth.h>
@

