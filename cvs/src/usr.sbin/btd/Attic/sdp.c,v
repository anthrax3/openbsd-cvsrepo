head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.14
	OPENBSD_5_0:1.5.0.12
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.10
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.8
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.6
date	2012.04.01.15.15.35;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2008.11.27.00.51.17;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.26.21.48.30;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.26.15.32.56;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.25.17.13.53;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.24.23.34.42;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.6
log
@move to the Attic
@
text
@/*	$OpenBSD: sdp.c,v 1.5 2008/11/27 00:51:17 uwe Exp $	*/

/*
 * Copyright (c) 2008 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <netbt/l2cap.h>

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "btd.h"
#include "sdp.h"

struct sdp_state {
	TAILQ_HEAD(, sdp_session) sessions;
};

struct sdp_session *sdp_new_session(struct sdp_state *, const bdaddr_t *);
struct sdp_session *sdp_find_session(struct sdp_state *, const bdaddr_t *);
int sdp_open_session(struct sdp_session *, const bdaddr_t *);
void sdp_close_session(struct sdp_session *);
void sdp_delete_session(struct sdp_session *);
void sdp_eventcb(int, short, void *);

void
sdp_init(struct btd *env)
{
	struct sdp_state *sdp;

	sdp = env->sdp = calloc(1, sizeof(*env->sdp));

	TAILQ_INIT(&sdp->sessions);
}

/* return 0 on success, 2 if the SDP query is still in progress, 1 if
 * the device was not found, -1 on error */
int
sdp_get_devinfo(struct bt_interface *iface, struct bt_device *btdev)
{
	struct sdp_state *sdp = iface->env->sdp;
	struct sdp_session *sess;
	const char *service;

	switch (btdev->type) {
	case BTDEV_NONE:
		return 1;
	case BTDEV_HID:
		service = "HID";
		break;
	case BTDEV_HSET:
		service = "HSET";
		break;
	case BTDEV_HF:
		service = "HF";
		break;
	default:
		log_warnx("sdp_get_devinfo: invalid device type %#x",
		    btdev->type);
		return -1;
	}

	if ((sess = sdp_find_session(sdp, &btdev->addr)) == NULL &&
	    (sess = sdp_new_session(sdp, &btdev->addr)) == NULL)
		return -1;

	if (sdp_open_session(sess, &iface->addr) < 0)
		return -1;

	if (sdp_query(sess, &btdev->info.baa, &iface->addr, &btdev->addr,
	    service) < 0) {
		sdp_close_session(sess);
		return -1;
	}

	sdp_close_session(sess);
	return 0;
}

struct sdp_session *
sdp_new_session(struct sdp_state *sdp, const bdaddr_t *raddr)
{
	struct sdp_session *sess;

	if ((sess = calloc(1, sizeof(*sess))) == NULL) {
		log_warn("sdp_new_session");
		return NULL;
	}

	sess->sdp = sdp;
	sess->state = SDP_SESSION_CLOSED;
	bdaddr_copy(&sess->raddr, raddr);

	TAILQ_INSERT_TAIL(&sdp->sessions, sess, entry);

	return sess;
}

struct sdp_session *
sdp_find_session(struct sdp_state *sdp, const bdaddr_t *raddr)
{
	struct sdp_session *sess;

	TAILQ_FOREACH(sess, &sdp->sessions, entry)
		if (bdaddr_same(&sess->raddr, raddr))
			return sess;

	return NULL;
}

int
sdp_open_session(struct sdp_session *sess, const bdaddr_t *laddr)
{
	struct sockaddr_bt sa;
	socklen_t size;

	if (sess->state != SDP_SESSION_CLOSED) {
		if (bdaddr_same(&sess->laddr, laddr))
			return 0;

		sdp_close_session(sess);
	}

	bdaddr_copy(&sess->laddr, laddr);

	sess->fd = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);
	if (sess->fd == -1) {
		log_warn("sdp_open_session: socket");
		goto fail;
	}

	memset(&sa, 0, sizeof(sa));
	sa.bt_len = sizeof(sa);
	sa.bt_family = AF_BLUETOOTH;
	bdaddr_copy(&sa.bt_bdaddr, &sess->laddr);

	if (bind(sess->fd, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
		log_warn("sdp_open_session: bind");
		goto fail;
	}

	sa.bt_psm = L2CAP_PSM_SDP;
	bdaddr_copy(&sa.bt_bdaddr, &sess->raddr);

	if (connect(sess->fd, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
		log_warn("sdp_open_session: connect");
		goto fail;
	}

	size = sizeof(sess->omtu);
	if (getsockopt(sess->fd, BTPROTO_L2CAP, SO_L2CAP_OMTU, &sess->omtu,
	    &size) < 0) {
		log_warn("sdp_open_session: getsockopt");
		goto fail;
	}

	size = sizeof(sess->imtu);
	if (getsockopt(sess->fd, BTPROTO_L2CAP, SO_L2CAP_IMTU, &sess->imtu,
	    &size) < 0) {
		log_warn("sdp_open_session: getsockopt");
		goto fail;
	}

	if ((sess->req = malloc((size_t)sess->omtu)) == NULL) {
		log_warn("sdp_open_session: malloc req");
		goto fail;
	}
	sess->req_e = sess->req + sess->omtu;

	if ((sess->rsp = malloc((size_t)sess->imtu)) == NULL) {
		log_warn("sdp_open_session: malloc rsp");
		goto fail;
	}
	sess->rsp_e = sess->rsp + sess->imtu;

	event_set(&sess->ev, sess->fd, EV_READ | EV_PERSIST,
	    sdp_eventcb, sess);
	if (event_add(&sess->ev, NULL)) {
		log_warnx("event_add failed");
		goto fail;
	}

	sess->state = SDP_SESSION_OPEN;
	return 0;

fail:
	if (sess->fd != -1) {
		close(sess->fd);
		sess->fd = -1;
	}

	if (sess->req != NULL) {
		free(sess->req);
		sess->req = NULL;
	}

	if (sess->rsp != NULL) {
		free(sess->rsp);
		sess->rsp = NULL;
	}

	return -1;
}

void
sdp_close_session(struct sdp_session *sess)
{
	if (sess->state == SDP_SESSION_CLOSED)
		return;

	if (sess->req != NULL) {
		free(sess->req);
		sess->req = NULL;
	}

	if (sess->rsp != NULL) {
		free(sess->rsp);
		sess->rsp = NULL;
	}

	close(sess->fd);
	sess->fd = -1;
	sess->state = SDP_SESSION_CLOSED;
}

void
sdp_delete_session(struct sdp_session *sess)
{
	struct sdp_state *sdp = sess->sdp;

	sdp_close_session(sess);

	TAILQ_REMOVE(&sdp->sessions, sess, entry);

	free(sess);
}

void
sdp_eventcb(int fd, short evflags, void *arg)
{
}
@


1.5
log
@Ugly workaround to bring up interfaces which were down when we found them
@
text
@d1 1
a1 1
/*	$OpenBSD: sdp.c,v 1.4 2008/11/26 21:48:30 uwe Exp $	*/
@


1.4
log
@SDP works, but it needs to be redone (and non-blocking)

With this in bt.conf, the HID driver should work:

 # Enable all interfaces.
 interface * "OpenBSD BT"
 # Attach a keyboard and/or mouse, or a mobile phone emulating such things.
 attach 00:02:76:08:1c:37 type hid pin "0000"

Then start btd and run btctl -f bt.conf.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdp.c,v 1.3 2008/11/26 15:32:56 uwe Exp $	*/
a57 2
	log_debug("sdp_get_devinfo: raddr %s", bt_ntoa(&btdev->addr, NULL));

a84 1
		log_warnx("sdp_query failed");
a222 2

	log_debug("sdp_close_session: laddr %s", bt_ntoa(&sess->laddr, NULL));
@


1.3
log
@Device attach and detach (does not work because SDP is not implemented yet)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 2
d22 2
d26 1
a26 4

struct sdp_session {
	TAILQ_ENTRY(sdp_session) entry;
};
d32 7
d49 78
d128 1
a128 1
sdp_query(struct bt_interface *iface, struct bt_device *btdev)
d130 70
d201 58
@


1.2
log
@Get rid of dependencies on ports libraries (among other things)
@
text
@d1 1
a1 2
/*	$OpenBSD: sdp.c,v 1.1 2008/11/24 23:34:42 uwe Exp $	*/
/*	$NetBSD: sdp.c,v 1.5 2008/04/20 19:34:23 plunky Exp $	*/
a2 28
/*-
 * Copyright (c) 2006 Itronix Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Itronix Inc. may not be used to endorse
 *    or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ITRONIX INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ITRONIX INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d4 1
a4 2
 * Copyright (c) 2004 Maksim Yevmenkin <m_evmenkin@@yahoo.com>
 * All rights reserved.
d6 11
a16 20
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a18 9
#include <sys/types.h>

#include <dev/bluetooth/btdev.h>
#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <err.h>
#include <errno.h>
#include <sdp.h>
a19 1
#include <usbhid.h>
d23 2
a24 26
static int hid_mode(uint8_t *, int32_t);

static int32_t parse_l2cap_psm(sdp_attr_t *);
static int32_t parse_rfcomm_channel(sdp_attr_t *);
static int32_t parse_hid_descriptor(sdp_attr_t *);
static int32_t parse_boolean(sdp_attr_t *);

static int config_hid(struct btdev_attach_args *);
static int config_hset(struct btdev_attach_args *);
static int config_hf(struct btdev_attach_args *);

uint16_t hid_services[] = {
	SDP_SERVICE_CLASS_HUMAN_INTERFACE_DEVICE
};

uint32_t hid_attrs[] = {
	SDP_ATTR_RANGE(	SDP_ATTR_PROTOCOL_DESCRIPTOR_LIST,
			SDP_ATTR_PROTOCOL_DESCRIPTOR_LIST),
	SDP_ATTR_RANGE( SDP_ATTR_ADDITIONAL_PROTOCOL_DESCRIPTOR_LISTS,
			SDP_ATTR_ADDITIONAL_PROTOCOL_DESCRIPTOR_LISTS),
	SDP_ATTR_RANGE(	0x0205,		/* HIDReconnectInitiate */
			0x0206),	/* HIDDescriptorList */
	SDP_ATTR_RANGE(	0x0209,		/* HIDBatteryPower */
			0x0209),
	SDP_ATTR_RANGE(	0x020d,		/* HIDNormallyConnectable */
			0x020d)
d27 2
a28 2
uint16_t hset_services[] = {
	SDP_SERVICE_CLASS_HEADSET
d31 2
a32 48
uint32_t hset_attrs[] = {
	SDP_ATTR_RANGE(	SDP_ATTR_PROTOCOL_DESCRIPTOR_LIST,
			SDP_ATTR_PROTOCOL_DESCRIPTOR_LIST),
};

uint16_t hf_services[] = {
	SDP_SERVICE_CLASS_HANDSFREE_AUDIO_GATEWAY
};

uint32_t hf_attrs[] = {
	SDP_ATTR_RANGE(	SDP_ATTR_PROTOCOL_DESCRIPTOR_LIST,
			SDP_ATTR_PROTOCOL_DESCRIPTOR_LIST),
};

#define NUM(v)		(sizeof(v) / sizeof(v[0]))

static struct {
	const char		*name;
	int			(*handler)(struct btdev_attach_args *);
	const char		*description;
	uint16_t		*services;
	int			nservices;
	uint32_t		*attrs;
	int			nattrs;
} cfgtype[] = {
    {
	"HID",		config_hid,	"Human Interface Device",
	hid_services,	NUM(hid_services),
	hid_attrs,	NUM(hid_attrs),
    },
    {
	"HSET",		config_hset,	"Headset",
	hset_services,	NUM(hset_services),
	hset_attrs,	NUM(hset_attrs),
    },
    {
	"HF",		config_hf,	"Handsfree",
	hf_services,	NUM(hf_services),
	hf_attrs,	NUM(hf_attrs),
    },
};

static sdp_attr_t	values[8];
static uint8_t		buffer[NUM(values)][512];

int
sdp_query(struct btdev_attach_args *dict,
    bdaddr_t *laddr, bdaddr_t *raddr, const char *service)
d34 1
a34 21
	void *ss;
	int rv, i;

	for (i = 0 ; i < NUM(values) ; i++) {
		values[i].flags = SDP_ATTR_INVALID;
		values[i].attr = 0;
		values[i].vlen = sizeof(buffer[i]);
		values[i].value = buffer[i];
	}

	for (i = 0 ; i < NUM(cfgtype) ; i++) {
		if (strcasecmp(service, cfgtype[i].name) == 0) {
			ss = sdp_open(laddr, raddr);

			if (ss == NULL || (errno = sdp_error(ss)) != 0)
				return -1;

			rv = sdp_search(ss,
				cfgtype[i].nservices, cfgtype[i].services,
				cfgtype[i].nattrs, cfgtype[i].attrs,
				NUM(values), values);
d36 1
a36 5
			if (rv != 0) {
				errno = sdp_error(ss);
				return -1;
			}
			sdp_close(ss);
d38 1
a38 11
			rv = (*cfgtype[i].handler)(dict);
			if (rv != 0)
				return -1;

			return 0;
		}
	}

	fatalx("bad device type");
	/* NOTREACHED */
	return -1;
d41 2
a42 5
/*
 * Configure HID results
 */
static int
config_hid(struct btdev_attach_args *dict)
a43 127
	int32_t control_psm, interrupt_psm,
		reconnect_initiate, battery_power,
		normally_connectable, hid_length;
	uint8_t *hid_descriptor;
	int i;

	control_psm = -1;
	interrupt_psm = -1;
	reconnect_initiate = -1;
	normally_connectable = 0;
	battery_power = 0;
	hid_descriptor = NULL;
	hid_length = -1;

	for (i = 0; i < NUM(values) ; i++) {
		if (values[i].flags != SDP_ATTR_OK)
			continue;

		switch (values[i].attr) {
		case SDP_ATTR_PROTOCOL_DESCRIPTOR_LIST:
			control_psm = parse_l2cap_psm(&values[i]);
			break;

		case SDP_ATTR_ADDITIONAL_PROTOCOL_DESCRIPTOR_LISTS:
			interrupt_psm = parse_l2cap_psm(&values[i]);
			break;

		case 0x0205: /* HIDReconnectInitiate */
			reconnect_initiate = parse_boolean(&values[i]);
			break;

		case 0x0206: /* HIDDescriptorList */
			if (parse_hid_descriptor(&values[i]) == 0) {
				hid_descriptor = values[i].value;
				hid_length = values[i].vlen;
			}
			break;

		case 0x0209: /* HIDBatteryPower */
			battery_power = parse_boolean(&values[i]);
			break;

		case 0x020d: /* HIDNormallyConnectable */
			normally_connectable = parse_boolean(&values[i]);
			break;
		}
	}

	if (control_psm == -1
	    || interrupt_psm == -1
	    || reconnect_initiate == -1
	    || hid_descriptor == NULL
	    || hid_length == -1)
		return ENOATTR;

	dict->bd_type = BTDEV_HID;
	dict->bd_hid.hid_ctl = control_psm;
	dict->bd_hid.hid_int = interrupt_psm;
	dict->bd_hid.hid_desc = hid_descriptor;
	dict->bd_hid.hid_dlen = hid_length;
	dict->bd_mode = hid_mode(hid_descriptor, hid_length);

	if (!reconnect_initiate)
		dict->bd_hid.hid_flags |= BTHID_INITIATE;

	return 0;
}

/*
 * Configure HSET results
 */
static int
config_hset(struct btdev_attach_args *dict)
{
	uint32_t channel;
	int i;

	channel = -1;

	for (i = 0; i < NUM(values) ; i++) {
		if (values[i].flags != SDP_ATTR_OK)
			continue;

		switch (values[i].attr) {
		case SDP_ATTR_PROTOCOL_DESCRIPTOR_LIST:
			channel = parse_rfcomm_channel(&values[i]);
			break;
		}
	}

	if (channel == -1)
		return ENOATTR;

	dict->bd_type = BTDEV_HSET;
	dict->bd_hset.hset_channel = channel;

	return 0;
}

/*
 * Configure HF results
 */
static int
config_hf(struct btdev_attach_args *dict)
{
	uint32_t channel;
	int i;

	channel = -1;

	for (i = 0 ; i < NUM(values) ; i++) {
		if (values[i].flags != SDP_ATTR_OK)
			continue;

		switch (values[i].attr) {
		case SDP_ATTR_PROTOCOL_DESCRIPTOR_LIST:
			channel = parse_rfcomm_channel(&values[i]);
			break;
		}
	}

	if (channel == -1)
		return ENOATTR;

	dict->bd_type = BTDEV_HF;
	dict->bd_hf.hf_listen = 1;
	dict->bd_hf.hf_channel = channel;
a44 409
}

/*
 * Parse [additional] protocol descriptor list for L2CAP PSM
 *
 * seq8 len8				2
 *	seq8 len8			2
 *		uuid16 value16		3	L2CAP
 *		uint16 value16		3	PSM
 *	seq8 len8			2
 *		uuid16 value16		3	HID Protocol
 *				      ===
 *				       15
 */

static int32_t
parse_l2cap_psm(sdp_attr_t *a)
{
	uint8_t	*ptr = a->value;
	uint8_t	*end = a->value + a->vlen;
	int32_t	 type, len, uuid, psm;

	if (end - ptr < 15)
		return (-1);

	if (a->attr == SDP_ATTR_ADDITIONAL_PROTOCOL_DESCRIPTOR_LISTS) {
		SDP_GET8(type, ptr);
		switch (type) {
		case SDP_DATA_SEQ8:
			SDP_GET8(len, ptr);
			break;

		case SDP_DATA_SEQ16:
			SDP_GET16(len, ptr);
			break;

		case SDP_DATA_SEQ32:
			SDP_GET32(len, ptr);
			break;

		default:
			return (-1);
		}
		if (ptr + len > end)
			return (-1);
	}

	SDP_GET8(type, ptr);
	switch (type) {
	case SDP_DATA_SEQ8:
		SDP_GET8(len, ptr);
		break;

	case SDP_DATA_SEQ16:
		SDP_GET16(len, ptr);
		break;

	case SDP_DATA_SEQ32:
		SDP_GET32(len, ptr);
		break;

	default:
		return (-1);
	}
	if (ptr + len > end)
		return (-1);

	/* Protocol */
	SDP_GET8(type, ptr);
	switch (type) {
	case SDP_DATA_SEQ8:
		SDP_GET8(len, ptr);
		break;

	case SDP_DATA_SEQ16:
		SDP_GET16(len, ptr);
		break;

	case SDP_DATA_SEQ32:
		SDP_GET32(len, ptr);
		break;

	default:
		return (-1);
	}
	if (ptr + len > end)
		return (-1);

	/* UUID */
	if (ptr + 3 > end)
		return (-1);
	SDP_GET8(type, ptr);
	switch (type) {
	case SDP_DATA_UUID16:
		SDP_GET16(uuid, ptr);
		if (uuid != SDP_UUID_PROTOCOL_L2CAP)
			return (-1);
		break;

	case SDP_DATA_UUID32:  /* XXX FIXME can we have 32-bit UUID */
	case SDP_DATA_UUID128: /* XXX FIXME can we have 128-bit UUID */
	default:
		return (-1);
	}

	/* PSM */
	if (ptr + 3 > end)
		return (-1);
	SDP_GET8(type, ptr);
	if (type != SDP_DATA_UINT16)
		return (-1);
	SDP_GET16(psm, ptr);

	return (psm);
}

/*
 * Parse HID descriptor string
 *
 * seq8 len8			2
 *	seq8 len8		2
 *		uint8 value8	2
 *		str value	3
 *			      ===
 *			        9
 */

static int32_t
parse_hid_descriptor(sdp_attr_t *a)
{
	uint8_t	*ptr = a->value;
	uint8_t	*end = a->value + a->vlen;
	int32_t	 type, len, descriptor_type;

	if (end - ptr < 9)
		return (-1);

	SDP_GET8(type, ptr);
	switch (type) {
	case SDP_DATA_SEQ8:
		SDP_GET8(len, ptr);
		break;

	case SDP_DATA_SEQ16:
		SDP_GET16(len, ptr);
		break;

	case SDP_DATA_SEQ32:
		SDP_GET32(len, ptr);
		break;

	default:
		return (-1);
	}
	if (ptr + len > end)
		return (-1);

	while (ptr < end) {
		/* Descriptor */
		SDP_GET8(type, ptr);
		switch (type) {
		case SDP_DATA_SEQ8:
			if (ptr + 1 > end)
				return (-1);
			SDP_GET8(len, ptr);
			break;

		case SDP_DATA_SEQ16:
			if (ptr + 2 > end)
				return (-1);
			SDP_GET16(len, ptr);
			break;

		case SDP_DATA_SEQ32:
			if (ptr + 4 > end)
				return (-1);
			SDP_GET32(len, ptr);
			break;

		default:
			return (-1);
		}

		/* Descripor type */
		if (ptr + 1 > end)
			return (-1);
		SDP_GET8(type, ptr);
		if (type != SDP_DATA_UINT8 || ptr + 1 > end)
			return (-1);
		SDP_GET8(descriptor_type, ptr);

		/* Descriptor value */
		if (ptr + 1 > end)
			return (-1);
		SDP_GET8(type, ptr);
		switch (type) {
		case SDP_DATA_STR8:
			if (ptr + 1 > end)
				return (-1);
			SDP_GET8(len, ptr);
			break;

		case SDP_DATA_STR16:
			if (ptr + 2 > end)
				return (-1);
			SDP_GET16(len, ptr);
			break;

		case SDP_DATA_STR32:
			if (ptr + 4 > end)
				return (-1);
			SDP_GET32(len, ptr);
			break;

		default:
			return (-1);
		}
		if (ptr + len > end)
			return (-1);

		if (descriptor_type == UDESC_REPORT && len > 0) {
			a->value = ptr;
			a->vlen = len;

			return (0);
		}

		ptr += len;
	}

	return (-1);
}

/*
 * Parse boolean value
 *
 * bool8 int8
 */

static int32_t
parse_boolean(sdp_attr_t *a)
{
	if (a->vlen != 2 || a->value[0] != SDP_DATA_BOOL)
		return (-1);

	return (a->value[1]);
}

/*
 * Parse protocol descriptor list for the RFCOMM channel
 *
 * seq8 len8				2
 *	seq8 len8			2
 *		uuid16 value16		3	L2CAP
 *	seq8 len8			2
 *		uuid16 value16		3	RFCOMM
 *		uint8 value8		2	channel
 *				      ===
 *				       14
 */

static int32_t
parse_rfcomm_channel(sdp_attr_t *a)
{
	uint8_t	*ptr = a->value;
	uint8_t	*end = a->value + a->vlen;
	int32_t	 type, len, uuid, channel;

	if (end - ptr < 14)
		return (-1);

	SDP_GET8(type, ptr);
	switch (type) {
	case SDP_DATA_SEQ8:
		SDP_GET8(len, ptr);
		break;

	case SDP_DATA_SEQ16:
		SDP_GET16(len, ptr);
		break;

	case SDP_DATA_SEQ32:
		SDP_GET32(len, ptr);
		break;

	default:
		return (-1);
	}
	if (ptr + len > end)
		return (-1);

	/* Protocol */
	SDP_GET8(type, ptr);
	switch (type) {
	case SDP_DATA_SEQ8:
		SDP_GET8(len, ptr);
		break;

	case SDP_DATA_SEQ16:
		SDP_GET16(len, ptr);
		break;

	case SDP_DATA_SEQ32:
		SDP_GET32(len, ptr);
		break;

	default:
		return (-1);
	}
	if (ptr + len > end)
		return (-1);

	/* UUID */
	if (ptr + 3 > end)
		return (-1);
	SDP_GET8(type, ptr);
	switch (type) {
	case SDP_DATA_UUID16:
		SDP_GET16(uuid, ptr);
		if (uuid != SDP_UUID_PROTOCOL_L2CAP)
			return (-1);
		break;

	case SDP_DATA_UUID32:  /* XXX FIXME can we have 32-bit UUID */
	case SDP_DATA_UUID128: /* XXX FIXME can we have 128-bit UUID */
	default:
		return (-1);
	}

	/* Protocol */
	SDP_GET8(type, ptr);
	switch (type) {
	case SDP_DATA_SEQ8:
		SDP_GET8(len, ptr);
		break;

	case SDP_DATA_SEQ16:
		SDP_GET16(len, ptr);
		break;

	case SDP_DATA_SEQ32:
		SDP_GET32(len, ptr);
		break;

	default:
		return (-1);
	}
	if (ptr + len > end)
		return (-1);

	/* UUID */
	if (ptr + 3 > end)
		return (-1);
	SDP_GET8(type, ptr);
	switch (type) {
	case SDP_DATA_UUID16:
		SDP_GET16(uuid, ptr);
		if (uuid != SDP_UUID_PROTOCOL_RFCOMM)
			return (-1);
		break;

	case SDP_DATA_UUID32:  /* XXX FIXME can we have 32-bit UUID */
	case SDP_DATA_UUID128: /* XXX FIXME can we have 128-bit UUID */
	default:
		return (-1);
	}

	/* channel */
	if (ptr + 2 > end)
		return (-1);

	SDP_GET8(type, ptr);
	if (type != SDP_DATA_UINT8)
		return (-1);

	SDP_GET8(channel, ptr);

	return (channel);
}

/*
 * return appropriate mode for HID descriptor
 */
static int
hid_mode(uint8_t *desc, int32_t dlen)
{
	report_desc_t r;
	hid_data_t d;
	struct hid_item h;
	int mode;

	mode = BTDEV_MODE_AUTH;	/* default */

	r = hid_use_report_desc(desc, dlen);
	if (r == NULL)
		err(EXIT_FAILURE, "hid_use_report_desc");

	d = hid_start_parse(r, ~0, -1);
	while (hid_get_item(d, &h) > 0) {
		if (h.kind == hid_collection
		    && HID_PAGE(h.usage) == HUP_GENERIC_DESKTOP
		    && HID_USAGE(h.usage) == HUG_KEYBOARD)
			mode = BTDEV_MODE_ENCRYPT;
	}

	hid_end_parse(d);
	hid_dispose_report_desc(r);

	return mode;
@


1.1
log
@Bluetooth daemon and contrl utility, one for all, work in progress
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a63 1
#include <bluetooth.h>
@

