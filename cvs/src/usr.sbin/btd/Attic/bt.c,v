head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.14
	OPENBSD_5_0:1.6.0.12
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.10
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.8
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6;
locks; strict;
comment	@ * @;


1.7
date	2012.04.01.15.15.35;	author deraadt;	state dead;
branches;
next	1.6;

1.6
date	2008.11.27.00.51.17;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.26.21.48.30;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.26.15.32.56;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.26.06.51.43;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.25.17.13.53;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.24.23.34.41;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.7
log
@move to the Attic
@
text
@/*	$OpenBSD: bt.c,v 1.6 2008/11/27 00:51:17 uwe Exp $ */

/*
 * Copyright (c) 2008 Uwe Stuehler <uwe@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2004 Alexander Guy <alexander.guy@@andern.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>

#include <dev/bluetooth/btdev.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <usbhid.h>

#include "btd.h"

void bt_sighdlr(int, short, void *);

struct bt_interface *bt_find_inquiry_interface(struct btd *);
struct bt_interface *bt_find_attach_interface(struct bt_device *);

void bt_check_devices(int, short, void *);

int bt_get_devinfo(struct bt_device *);
int bt_device_attach(struct bt_device *);
int bt_device_detach(struct bt_device *);

struct event ev_sigint;
struct event ev_sigterm;
struct event ev_siginfo;
struct event ev_check_devices;

int priv_fd;

void
bt_sighdlr(int sig, short ev, void *arg)
{
	struct btd *env = arg;

	switch (sig) {
	case SIGINT:
	case SIGTERM:
		(void)event_loopexit(NULL);
		break;

	case SIGINFO:
		conf_dump(env);
		break;
	}
}

pid_t
bt_main(int pipe_prnt[2], struct btd *env, struct passwd *pw)
{
	struct stat stb;
	pid_t pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
		break;
	case 0:
		break;
	default:
		return pid;
	}

	setproctitle("bt engine");

	event_init();
	hid_init(NULL);
	db_open(BTD_DB, &env->db);
	hci_init(env);
	sdp_init(env);
	control_init(env);

	if (stat(pw->pw_dir, &stb) == -1)
		fatal("stat");
	if (stb.st_uid != 0 || (stb.st_mode & (S_IWGRP|S_IWOTH)) != 0)
		fatalx("bad privsep dir permissions");
	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	close(pipe_prnt[0]);

	priv_fd = pipe_prnt[1];

	signal_set(&ev_sigint, SIGINT, bt_sighdlr, env);
	signal_set(&ev_sigterm, SIGTERM, bt_sighdlr, env);
	signal_set(&ev_siginfo, SIGINFO, bt_sighdlr, env);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_siginfo, NULL);

	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
	signal(SIGCHLD, SIG_DFL);

	evtimer_set(&ev_check_devices, bt_check_devices, env);

	log_info("bt engine ready");

	(void)event_dispatch();

	log_info("bt engine exiting");
	exit(0);
}

void
bt_priv_msg(enum imsg_type type)
{
	bt_priv_send(&type, sizeof(type));
}

void
bt_priv_send(const void *buf, size_t n)
{
	if (atomic_write(priv_fd, buf, n) < 0)
		fatal("atomic_write");
}

void
bt_priv_recv(void *buf, size_t n)
{
	if (atomic_read(priv_fd, buf, n) < 0)
		fatal("atomic_read");
}

struct bt_interface *
bt_find_inquiry_interface(struct btd *env)
{
	struct bt_interface *iface;

	TAILQ_FOREACH_REVERSE(iface, &env->interfaces, interfaces, entry) {
		if (iface->physif != NULL)
			return iface;
	}

	return NULL;
}

struct bt_interface *
bt_find_attach_interface(struct bt_device *btdev)
{
	struct bt_interface *iface;

	TAILQ_FOREACH(iface, &btdev->env->interfaces, entry) {
		if (iface->physif != NULL)
			return iface;
	}

	return NULL;
}

void
bt_devices_changed(void)
{
	struct timeval tv;

	memset(&tv, 0, sizeof(tv));
	tv.tv_sec = 1;

	evtimer_add(&ev_check_devices, &tv);
}

void
bt_check_devices(int fd, short evflags, void *arg)
{
	struct btd *env = arg;
	struct bt_device *btdev;

	for (btdev = TAILQ_FIRST(&env->devices); btdev != NULL;) {
		if (!bdaddr_same(&btdev->addr, BDADDR_ANY) &&
		    (btdev->flags & (BTDF_ATTACH|BTDF_ATTACH_DONE)) ==
		    BTDF_ATTACH_DONE) {
			if (bt_device_detach(btdev) < 0) {
				btdev = TAILQ_NEXT(btdev, entry);
				continue;
			}

			if (!(btdev->flags & BTDF_ATTACH))
				log_info("%s: device is now detached",
				    bt_ntoa(&btdev->addr, NULL));
		}

		if (btdev->flags & BTDF_DELETED) {
			struct bt_device *next;

			next = TAILQ_NEXT(btdev, entry);
			conf_delete_device(btdev);
			btdev = next;
			continue;
		}

		if (!bdaddr_same(&btdev->addr, BDADDR_ANY) &&
		    (btdev->flags & (BTDF_ATTACH|BTDF_ATTACH_DONE)) ==
		    BTDF_ATTACH) {
			if (bt_device_attach(btdev) < 0) {
				btdev = TAILQ_NEXT(btdev, entry);
				continue;
			}

			if (btdev->flags & BTDF_ATTACH_DONE)
				log_info("%s: device is now attached",
				    bt_ntoa(&btdev->addr, NULL));
		}

		btdev = TAILQ_NEXT(btdev, entry);
	}
}

int
bt_get_devinfo(struct bt_device *btdev)
{
	struct btd *env = btdev->env;
	int res;

	res = db_get_devinfo(&env->db, &btdev->addr, &btdev->info);
	if (res < 0)
		return -1;
	else if (res != 0) {
		struct bt_interface *iface;

		if ((iface = bt_find_attach_interface(btdev)) == NULL)
			return 0;

		res = sdp_get_devinfo(iface, btdev);
		if (res < 0) {
			btdev->flags &= ~BTDF_SDP_STARTED;
			return -1;
		} else if (res == 1) {
			btdev->flags &= ~BTDF_SDP_STARTED;
			log_info("%s: SDP query failed",
			    bt_ntoa(&btdev->addr, NULL));
			return 0;
		} else if (res == 2) {
			if (!(btdev->flags & BTDF_SDP_STARTED)) {
				btdev->flags |= BTDF_SDP_STARTED;
				log_info("%s: SDP query started",
				    bt_ntoa(&btdev->addr, NULL));
			}
			return 0;
		} else if (res != 0)
			fatalx("bt_get_devinfo: sdp_get_devinfo");
	}

	bdaddr_copy(devinfo_raddr(&btdev->info), &btdev->addr);
	btdev->flags |= BTDF_DEVINFO_VALID;
	return 0;
}

int
bt_device_attach(struct bt_device *btdev)
{
	struct bt_interface *iface;
	void *buf;
	size_t n;
	int err;

	if (btdev->flags & BTDF_ATTACH_DONE)
		return 0;

	if (!(btdev->flags & BTDF_DEVINFO_VALID)) {
		if (bt_get_devinfo(btdev) < 0)
			return -1;
		if (!(btdev->flags & BTDF_DEVINFO_VALID))
			return 0;
	}

	if (bdaddr_any(devinfo_laddr(&btdev->info))) {
		if ((iface = bt_find_attach_interface(btdev)) == NULL)
			return 0;

		bdaddr_copy(devinfo_laddr(&btdev->info), &iface->addr);
	}

	if (devinfo_store(&btdev->info, &buf, &n) < 0)
		return -1;

	bt_priv_msg(IMSG_ATTACH);
	bt_priv_send(&n, sizeof(n));
	bt_priv_send(buf, n);
	bt_priv_recv(&err, sizeof(int));
	free(buf);

	switch (err) {
	case 0:
	case EADDRINUSE:
		btdev->flags |= BTDF_ATTACH_DONE;
		return 0;
	default:
		log_warnx("could not attach %s (%s)",
		    bt_ntoa(&btdev->addr, NULL), strerror(err));
		return -1;
	}
}

int
bt_device_detach(struct bt_device *btdev)
{
	struct bt_interface *iface;
	void *buf;
	size_t n;
	int err;

	if ((btdev->flags & BTDF_ATTACH) ||
	    !(btdev->flags & BTDF_ATTACH_DONE))
		return 0;

	if (!(btdev->flags & BTDF_DEVINFO_VALID)) {
		if (bt_get_devinfo(btdev) < 0)
			return -1;
		if (!(btdev->flags & BTDF_DEVINFO_VALID))
			return 0;
	}

	if (bdaddr_any(devinfo_laddr(&btdev->info))) {
		if ((iface = bt_find_attach_interface(btdev)) == NULL)
			return 0;

		bdaddr_copy(devinfo_laddr(&btdev->info), &iface->addr);
	}

	if (devinfo_store(&btdev->info, &buf, &n) < 0)
		return -1;

	bt_priv_msg(IMSG_DETACH);
	bt_priv_send(&n, sizeof(n));
	bt_priv_send(buf, n);
	bt_priv_recv(&err, sizeof(int));
	free(buf);

	switch (err) {
	case 0:
	case ENODEV:
		btdev->flags &= ~BTDF_ATTACH_DONE;
		return 0;
	default:
		log_warnx("could not detach %s (%s)",
		    bt_ntoa(&btdev->addr, NULL), strerror(err));
		return -1;
	}
}

int
bt_set_interface_flags(const struct btreq *btr)
{
	int err;

	bt_priv_msg(IMSG_SET_INTERFACE_FLAGS);
	bt_priv_send(btr->btr_name, sizeof(btr->btr_name));
	bt_priv_send(&btr->btr_flags, sizeof(btr->btr_flags));
	bt_priv_recv(&err, sizeof(err));

	return (errno = err) ? -1 : 0;
}
@


1.6
log
@Ugly workaround to bring up interfaces which were down when we found them
@
text
@d1 1
a1 1
/*	$OpenBSD: bt.c,v 1.5 2008/11/26 21:48:30 uwe Exp $ */
@


1.5
log
@SDP works, but it needs to be redone (and non-blocking)

With this in bt.conf, the HID driver should work:

 # Enable all interfaces.
 interface * "OpenBSD BT"
 # Attach a keyboard and/or mouse, or a mobile phone emulating such things.
 attach 00:02:76:08:1c:37 type hid pin "0000"

Then start btd and run btctl -f bt.conf.
@
text
@d1 1
a1 1
/*	$OpenBSD: bt.c,v 1.4 2008/11/26 15:32:56 uwe Exp $ */
d372 13
@


1.4
log
@Device attach and detach (does not work because SDP is not implemented yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: bt.c,v 1.3 2008/11/26 06:51:43 uwe Exp $ */
d163 1
a163 1
	TAILQ_FOREACH(iface, &env->interfaces, entry) {
d176 1
a176 2
	TAILQ_FOREACH_REVERSE(iface, &btdev->env->interfaces,
	    interfaces, entry) {
d190 2
d202 2
a203 1
		if ((btdev->flags & (BTDF_ATTACH|BTDF_ATTACH_DONE)) ==
d224 2
a225 1
		if ((btdev->flags & (BTDF_ATTACH|BTDF_ATTACH_DONE)) ==
d251 23
a273 2
		/* try sdp query */
		return 0;
d276 1
a276 1
	bdaddr_copy(&btdev->info.baa.bd_raddr, &btdev->addr);
d299 1
a299 1
	if (bdaddr_any(&btdev->info.baa.bd_laddr)) {
d303 1
a303 1
		bdaddr_copy(&btdev->info.baa.bd_laddr, &iface->addr);
d346 1
a346 1
	if (bdaddr_any(&btdev->info.baa.bd_laddr)) {
d350 1
a350 1
		bdaddr_copy(&btdev->info.baa.bd_laddr, &iface->addr);
@


1.3
log
@Implement config reloading (still only work in progress)
@
text
@d1 1
a1 1
/*	$OpenBSD: bt.c,v 1.2 2008/11/25 17:13:53 uwe Exp $ */
d41 9
d53 1
a92 1

a93 1

d95 2
a96 4

	if (hci_init(env))
		fatalx("can't set up HCI listeners");

d128 2
d156 192
@


1.2
log
@Get rid of dependencies on ports libraries (among other things)
@
text
@d1 1
a1 1
/*	$OpenBSD: bt.c,v 1.1 2008/11/24 23:34:41 uwe Exp $ */
d45 1
a45 4
struct bufferevent *ev_priv;
void bt_priv_readcb(struct bufferevent *, void *);
void bt_priv_writecb(struct bufferevent *, void *);
void bt_priv_errorcb(struct bufferevent *, short, void *);
d50 2
d59 1
a59 1
		/* report status */
d109 5
a113 9
	if ((ev_priv = bufferevent_new(pipe_prnt[1], bt_priv_readcb,
	    bt_priv_writecb, bt_priv_errorcb, env)) == NULL)
		fatalx("bufferevent_new ev_priv");

	bufferevent_enable(ev_priv, EV_READ);

	signal_set(&ev_sigint, SIGINT, bt_sighdlr, NULL);
	signal_set(&ev_sigterm, SIGTERM, bt_sighdlr, NULL);
	signal_set(&ev_siginfo, SIGINFO, bt_sighdlr, NULL);
d131 1
a131 1
bt_priv_readcb(struct bufferevent *ev, void *arg)
d133 1
a133 1
	log_debug(__func__);
d137 1
a137 1
bt_priv_writecb(struct bufferevent *ev, void *arg)
d139 2
a140 2
	/* nothing to do */
	log_debug(__func__);
d144 1
a144 1
bt_priv_errorcb(struct bufferevent *ev, short what, void *arg)
d146 2
a147 2
	log_warnx("priv pipe error, what=%#x", what);
	exit(0);
@


1.1
log
@Bluetooth daemon and contrl utility, one for all, work in progress
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.108 2008/10/02 14:00:21 henning Exp $ */
a26 1
#include <bluetooth.h>
@

