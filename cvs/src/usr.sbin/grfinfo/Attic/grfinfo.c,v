head	1.7;
access;
symbols
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2005.01.14.22.39.36;	author miod;	state dead;
branches;
next	1.6;

1.6
date	2002.09.06.22.12.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.06.22.08.36;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	97.02.03.05.10.59;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.01.15.23.43.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.34;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@/*	$OpenBSD: grfinfo.c,v 1.6 2002/09/06 22:12:18 deraadt Exp $	*/

/* 
 * Copyright (c) 1987-1993, The University of Utah and
 * the Center for Software Science at the University of Utah (CSS).
 * All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the Center
 * for Software Science at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSS ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSS DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSS requests users of this software to return to css-dist@@cs.utah.edu any
 * improvements that they make and grant CSS redistribution rights.
 *
 * 	from: Utah $Hdr: grfinfo.c 1.3 94/04/04$
 */

#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <util.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <dev/grfioctl.h>

int getinfo(char *);
void printall(void);
char *tname(void);
void usage(void);

struct grfinfo gi;

struct grf_info {
	int	grf_id;
	char	*grf_name;
} info[] = {
	GRFGATOR,	"gatorbox",
	GRFBOBCAT,	"topcat",
	GRFRBOX,	"renaissance",
	GRFFIREEYE,	"fireeye",
	GRFHYPERION,	"hyperion",
	GRFDAVINCI,	"davinci",
	-1,		"unknown",
};

int
main(int argc, char *argv[])
{
	int aflg, tflg;
	int c;
	char *dname;

	aflg = tflg = 0;
	while ((c = getopt(argc, argv, "at")) != -1) {
		switch (c) {
		case 'a':
			if (tflg != 0)
				usage();
			aflg++;
			break;
		case 't':
			if (aflg != 0)
				usage();
			tflg++;
			break;
		case '?':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc == 0)
		usage();
	while (argc-- != 0) {
		dname = *argv++;
		if (getinfo(dname)) {
			printf("%s: ", dname);
			if (aflg)
				printall();
			else
				printf("%s\n", tname());
		}
	}
	exit(0);
}

int
getinfo(char *dname)
{
	int f;

	f = opendev(dname, 0, OPENDEV_BLCK, NULL);
	if (f < 0) {
		warn("open(%s)", dname);
		return 0;
	}
	if (ioctl(f, GRFIOCGINFO, &gi) < 0) {
		warn("ioctl(%s)", dname);
		close(f);
		return 0;
	}

	close(f);
	return 1;
}

void
printall(void)
{
	printf("%d x %d, ", gi.gd_dwidth, gi.gd_dheight);
	if (gi.gd_colors < 3)
		printf("monochrome, ");
	else {
		printf("%d colors, ", gi.gd_colors);
		if (gi.gd_planes)
			printf("%d planes, ", gi.gd_planes);
	}
	printf("%s\n", tname());
	printf("registers: 0x%x bytes at 0x%x\n",
	    gi.gd_regsize, gi.gd_regaddr);
	printf("framebuf:  0x%x bytes at 0x%x (%d x %d)\n",
	    gi.gd_fbsize, gi.gd_fbaddr, gi.gd_fbwidth, gi.gd_fbheight);
}

char *
tname(void)
{
	struct grf_info *gp;

	for (gp = info; gp->grf_id >= 0; gp++)
		if (gi.gd_id == gp->grf_id)
			break;
	/*
	 * Heuristics to differentiate catseye from topcat:
	 *	low-res color catseye has 1k x 1k framebuffer and 64 colors
	 *	hi-res mono and color catseye have 1280 wide display
	 */
	if (gi.gd_id == GRFBOBCAT &&
	    (gi.gd_dwidth == 1280 ||
	    gi.gd_fbsize == 0x100000 && gi.gd_colors == 64))
		return("catseye");
	return(gp->grf_name);
}

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-at] device\n", __progname);
	exit(1);
}
@


1.6
log
@ansi; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: grfinfo.c,v 1.5 2002/09/06 22:08:36 miod Exp $	*/
@


1.5
log
@Modernize the same way as hilinfo: use opendev, clean the dust, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: grfinfo.c,v 1.4 2002/03/14 16:44:24 mpech Exp $	*/
d55 1
a55 2
main(argc, argv)
	char **argv;
d98 1
a98 2
getinfo(dname)
	char *dname;
d118 1
a118 1
printall()
d130 1
a130 1
	       gi.gd_regsize, gi.gd_regaddr);
d132 1
a132 1
	       gi.gd_fbsize, gi.gd_fbaddr, gi.gd_fbwidth, gi.gd_fbheight);
d136 1
a136 1
tname()
d150 1
a150 1
	     gi.gd_fbsize == 0x100000 && gi.gd_colors == 64))
d156 1
a156 1
usage()
@


1.4
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: grfinfo.c,v 1.3 1997/02/03 05:10:59 downsj Exp $	*/
d26 1
d28 2
d34 5
a38 4
int aflg = 0;
int tflg = 0;
char *pname;
char *dname, *tname();
d54 1
d58 1
a58 2
	extern int optind, optopt;
	extern char *optarg;
d60 1
d62 2
a63 2
	pname = argv[0];
	while ((c = getopt(argc, argv, "at")) != -1)
a64 1
		/* everything */
d66 2
a69 1
		/* type */
d71 2
a74 1
		/* bogon */
d76 1
d79 5
a83 1
	if (optind == argc)
d85 10
a94 6
	dname = argv[optind];
	getinfo();
	if (aflg)
		printall();
	else
		printf("%s\n", tname());
d98 3
a100 1
getinfo()
d104 9
a112 7
	f = open(dname, 0);
	if (f < 0 || ioctl(f, GRFIOCGINFO, &gi) < 0) {
		if (tflg)
			printf("none\n");
		else
			perror(dname);
		exit(1);
d114 1
d116 1
d119 1
d122 1
a122 1
	printf("%s: %d x %d ", dname, gi.gd_dwidth, gi.gd_dheight);
d124 1
a124 1
		printf("monochrome");
d126 1
a126 1
		printf("%d color", gi.gd_colors);
d128 1
a128 1
			printf(", %d plane", gi.gd_planes);
d130 1
a130 1
	printf(" %s\n", tname());
d157 1
d160 3
a162 1
	fprintf(stderr, "usage: %s [-at] device\n", pname);
@


1.3
log
@sync to netbsd 970101
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 1
	register int c;
d118 1
a118 1
	register struct grf_info *gp;
@


1.2
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 2
a23 1
 *	$Id: grfinfo.c,v 1.1.1.1 1995/10/18 08:47:34 deraadt Exp $
d32 1
a32 1
int tflg = 1;
d44 2
d78 1
a78 1
	else if (tflg)
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
 *	$Id: grfinfo.c,v 1.1 1994/04/04 21:53:25 cgd Exp $
d55 1
a55 1
	while ((c = getopt(argc, argv, "at")) != EOF)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
