head	1.25;
access;
symbols
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.21.0.12
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.10
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.6
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.4
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.17.0.4
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.11.0.14
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.12
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.10
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.25
date	2015.12.22.08.36.40;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	oPfIWbLnHhGxSfUY;

1.24
date	2015.03.31.13.38.27;	author mpi;	state Exp;
branches;
next	1.23;
commitid	BrIYBg9AgYZGScNl;

1.23
date	2015.02.09.23.00.15;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	822YD61EeG0Xl9Na;

1.22
date	2014.11.17.05.37.32;	author jsg;	state Exp;
branches;
next	1.21;
commitid	rycBsloutQdnrLmr;

1.21
date	2012.05.07.11.12.54;	author mpi;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.16.00.04.47;	author jakemsr;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.31.21.33.04;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.02.05.46.21;	author ckuethe;	state Exp;
branches;
next	1.17;

1.17
date	2008.09.04.11.46.18;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.17.16.30.05;	author sobrado;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.25.18.57.32;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.19.23.04.11;	author winiger;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.04.05.05.46;	author ckuethe;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.03.21.01.25;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.19.10.20.31;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.08.13.20.06;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.02.06.42.29;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.29.09.46.20;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.10.00.09.17;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.02.20.12.07;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.28.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.17.17.29.56;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.03.21.52.15;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Initialize a char* to NULL rather than 0.
@
text
@/*	$OpenBSD: usbdevs.c,v 1.24 2015/03/31 13:38:27 mpi Exp $	*/
/*	$NetBSD: usbdevs.c,v 1.19 2002/02/21 00:34:31 christos Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (augustss@@netbsd.org).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <errno.h>
#include <dev/usb/usb.h>

#ifndef nitems
#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
#endif

#define USBDEV "/dev/usb"

int verbose = 0;
int showdevs = 0;

void usage(void);
void usbdev(int f, int a, int rec);
void usbdump(int f);
void dumpone(char *name, int f, int addr);
int main(int, char **);

extern char *__progname;

void
usage(void)
{
	fprintf(stderr, "usage: %s [-dv] [-a addr] [-f dev]\n", __progname);
	exit(1);
}

char done[USB_MAX_DEVICES];
int indent;

void
usbdev(int f, int a, int rec)
{
	struct usb_device_info di;
	int e, p, i;

	di.udi_addr = a;
	e = ioctl(f, USB_DEVICEINFO, &di);
	if (e) {
		if (errno != ENXIO)
			printf("addr %d: I/O error\n", a);
		return;
	}

	printf("addr %d: ", a);
	done[a] = 1;
	if (verbose) {
		switch (di.udi_speed) {
		case USB_SPEED_LOW:
			printf("low speed, ");
			break;
		case USB_SPEED_FULL:
			printf("full speed, ");
			break;
		case USB_SPEED_HIGH:
			printf("high speed, ");
			break;
		case USB_SPEED_SUPER:
			printf("super speed, ");
			break;
		default:
			break;
		}

		if (di.udi_power)
			printf("power %d mA, ", di.udi_power);
		else
			printf("self powered, ");
		if (di.udi_config)
			printf("config %d, ", di.udi_config);
		else
			printf("unconfigured, ");
	}
	if (verbose) {
		printf("%s(0x%04x), %s(0x%04x), rev %s",
		    di.udi_product, di.udi_productNo,
		    di.udi_vendor, di.udi_vendorNo, di.udi_release);
		if (strlen(di.udi_serial))
			printf(", iSerialNumber %s", di.udi_serial);
	} else
		printf("%s, %s", di.udi_product, di.udi_vendor);
	printf("\n");
	if (showdevs) {
		for (i = 0; i < USB_MAX_DEVNAMES; i++)
			if (di.udi_devnames[i][0])
				printf("%*s  %s\n", indent, "",
				    di.udi_devnames[i]);
	}
	if (!rec)
		return;
	for (p = 0; p < di.udi_nports && p < nitems(di.udi_ports); p++) {
		int s = di.udi_ports[p];

		if (s >= USB_MAX_DEVICES) {
			if (verbose) {
				printf("%*sport %d %s\n", indent+1, "", p+1,
				    s == USB_PORT_ENABLED ? "enabled" :
				    s == USB_PORT_SUSPENDED ? "suspended" :
				    s == USB_PORT_POWERED ? "powered" :
				    s == USB_PORT_DISABLED ? "disabled" :
				    "???");
			}
			continue;
		}
		indent++;
		printf("%*s", indent, "");
		if (verbose)
			printf("port %d ", p+1);
		if (s == 0)
			printf("addr 0 should never happen!\n");
		else
			usbdev(f, s, 1);
		indent--;
	}
}

void
usbdump(int f)
{
	int a;

	for (a = 1; a < USB_MAX_DEVICES; a++) {
		if (!done[a])
			usbdev(f, a, 1);
	}
}

void
dumpone(char *name, int f, int addr)
{
	if (verbose)
		printf("Controller %s:\n", name);
	indent = 0;
	memset(done, 0, sizeof done);
	if (addr)
		usbdev(f, addr, 0);
	else
		usbdump(f);
}

int
main(int argc, char **argv)
{
	int ch, i, f;
	char buf[50];
	char *dev = NULL;
	const char *errstr;
	int addr = 0;
	int ncont;

	while ((ch = getopt(argc, argv, "a:df:v?")) != -1) {
		switch (ch) {
		case 'a':
			addr = strtonum(optarg, 1, USB_MAX_DEVICES, &errstr);
			if (errstr)
				errx(1, "addr %s", errstr);
			break;
		case 'd':
			showdevs = 1;
			break;
		case 'f':
			dev = optarg;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (dev == 0) {
		for (ncont = 0, i = 0; i < 10; i++) {
			snprintf(buf, sizeof buf, "%s%d", USBDEV, i);
			f = open(buf, O_RDONLY);
			if (f >= 0) {
				dumpone(buf, f, addr);
				close(f);
			} else {
				if (errno == ENOENT || errno == ENXIO)
					continue;
				warn("%s", buf);
			}
			ncont++;
		}
		if (verbose && ncont == 0)
			printf("%s: no USB controllers found\n",
			    __progname);
	} else {
		f = open(dev, O_RDONLY);
		if (f >= 0)
			dumpone(dev, f, addr);
		else
			err(1, "%s", dev);
	}
	exit(0);
}
@


1.24
log
@Do not iterate past the size of the array.

Found by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.23 2015/02/09 23:00:15 deraadt Exp $	*/
d185 1
a185 1
	char *dev = 0;
@


1.23
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.22 2014/11/17 05:37:32 jsg Exp $	*/
d43 4
d130 1
a130 1
	for (p = 0; p < di.udi_nports; p++) {
@


1.22
log
@show super speed status in verbose output
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.21 2012/05/07 11:12:54 mpi Exp $	*/
d194 1
a194 1
			showdevs++;
@


1.21
log
@Remove leftovers from last commit, getdevicedesc() cannot be used now
that the bus node is open read-only.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.20 2011/01/16 00:04:47 jakemsr Exp $	*/
d92 3
@


1.20
log
@the serial number is now available in struct usb_device_info, so
there's no need to use the USB_REQUEST ioctl to get the serial number.
this also means usbdevs can open /dev/usb* read-only, instead of
read-write, and still be fully functional.

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.19 2010/05/31 21:33:04 deraadt Exp $	*/
a49 1
int getdevicedesc(int, int, usb_device_descriptor_t *);
a146 19
}

int
getdevicedesc(int f, int addr, usb_device_descriptor_t *d)
{
	struct usb_ctl_request req;
	int r;

	req.ucr_addr = addr;
	req.ucr_request.bmRequestType = UT_READ_DEVICE;
	req.ucr_request.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.ucr_request.wValue, UDESC_DEVICE, 0);
	USETW(req.ucr_request.wIndex, 0);
	USETW(req.ucr_request.wLength, USB_DEVICE_DESCRIPTOR_SIZE);
	req.ucr_data = d;
	req.ucr_flags = 0;
	if ((r = ioctl(f, USB_REQUEST, &req)) == -1)
		perror("getdevicedesc: ioctl");
	return (r != -1);
@


1.19
log
@use strtonum() instead of atoi() to parse the device address
(from 1 - USB_MAX_DEVICES, not 0- as submitted)
from Gleydson Soares
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.18 2010/04/02 05:46:21 ckuethe Exp $	*/
a50 1
void getstring(int, int, int, char *, int);
a70 4
	usb_device_descriptor_t dd;
	char serialnum[USB_MAX_STRING_LEN];
	struct usb_ctl_request req;
	usb_string_descriptor_t us;
a71 1
	int langid = 0;
a80 15
	req.ucr_addr = a;
	req.ucr_request.bmRequestType = UT_READ_DEVICE;
	req.ucr_request.bRequest = UR_GET_DESCRIPTOR;
	req.ucr_data = &us;
	USETW2(req.ucr_request.wValue, UDESC_STRING, 0);
	USETW(req.ucr_request.wIndex, 0);
	USETW(req.ucr_request.wLength, 4);
	req.ucr_flags = 0;
	if (ioctl(f, USB_REQUEST, &req) >= 0)
		langid = UGETW(us.bString[0]);

	bzero(serialnum, sizeof serialnum);
	if (getdevicedesc(f, a, &dd))
		getstring(f, a, dd.iSerialNumber, serialnum, langid);

d111 2
a112 2
		if (strlen(serialnum))
			printf(", iSerialNumber %s", serialnum);
a169 50
getstring(int f, int addr, int si, char *s, int langid)
{
	struct usb_ctl_request req;
	usb_string_descriptor_t us;
	int r, i, n;
	u_int16_t c;

	if (si == 0) {
		*s = 0;
		return;
	}
	req.ucr_addr = addr;
	req.ucr_request.bmRequestType = UT_READ_DEVICE;
	req.ucr_request.bRequest = UR_GET_DESCRIPTOR;
	req.ucr_data = &us;
	USETW2(req.ucr_request.wValue, UDESC_STRING, si);
	USETW(req.ucr_request.wIndex, langid);
	USETW(req.ucr_request.wLength, 2);
	req.ucr_flags = USBD_SHORT_XFER_OK;

	if (ioctl(f, USB_REQUEST, &req) == -1){
		perror("getstring: ioctl");
		*s = 0;
		return;
	}

	USETW(req.ucr_request.wLength, us.bLength);

	if (ioctl(f, USB_REQUEST, &req) == -1){
		perror("getstring: ioctl");
		*s = 0;
		return;
	}

	n = us.bLength / 2 - 1;
	for (i = 0; i < n; i++) {
		c = UGETW(us.bString[i]);
		if ((c & 0xff00) == 0)
			*s++ = c;
		else if ((c & 0x00ff) == 0)
			*s++ = c >> 8;
		else {
			snprintf(s, 6, "\\u%04x", c);
			s += 6;
		}
	}
	*s++ = 0;
}

void
d229 1
a229 1
			f = open(buf, O_RDWR);
d244 1
a244 1
		f = open(dev, O_RDWR);
@


1.18
log
@Read description string length before reading description. From
Marcin Wyrwas in system/6338, tested with various ipods, usb drives
and smartphones. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.17 2008/09/04 11:46:18 jsg Exp $	*/
d270 1
d277 3
a279 1
			addr = atoi(optarg);
@


1.17
log
@Check for the correct ioctl failure case and reflect that
in the return code of getdevicedesc in which it is called.

ok yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.16 2008/06/26 05:42:21 ray Exp $	*/
d208 1
a208 1
	USETW(req.ucr_request.wLength, sizeof(usb_string_descriptor_t));
d210 8
@


1.16
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.15 2008/03/17 16:30:05 sobrado Exp $	*/
d185 1
a185 1
	if (r = ioctl(f, USB_REQUEST, &req))
d187 1
a187 2
	return 1;
	return (r == 0);
@


1.15
log
@"usage:" is lowercase; while here, KNF

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.14 2008/02/25 18:57:32 deraadt Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.14
log
@uninitialized variable needs zero'ing, ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.13 2008/01/19 23:04:11 winiger Exp $	*/
d68 1
a68 2
	fprintf(stderr, "Usage: %s [-dv] [-a addr] [-f dev]\n",
	    __progname);
@


1.13
log
@some usb devices stale (getstring: ioctl: Input/output error) if a
string is requested with language id 0, so we get the language table
first and use the language id from there

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.12 2007/12/04 05:05:46 ckuethe Exp $	*/
d106 1
@


1.12
log
@allow the usb serial number to be printed in verbose mode. this is
useful for people writing custom hotplugd(8) scripts, as well as ipod
users.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.11 2004/04/03 21:01:25 jmc Exp $	*/
d58 1
a58 1
void getstring(int, int, int, char *);
d82 2
d85 1
d94 12
d107 1
a107 1
		getstring(f, a, dd.iSerialNumber, serialnum);
d199 1
a199 1
getstring(int f, int addr, int si, char *s)
d215 1
a215 1
	USETW(req.ucr_request.wIndex, 0);
@


1.11
log
@- correct SYNOPSIS
- sync usage()
- some small tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.10 2004/01/19 10:20:31 deraadt Exp $	*/
d57 2
d80 2
d91 3
d124 2
d163 62
d282 1
a282 1
			f = open(buf, O_RDONLY);
d297 1
a297 1
		f = open(dev, O_RDONLY);
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.9 2003/07/08 13:20:06 nate Exp $	*/
d66 1
a66 1
	fprintf(stderr, "Usage: %s [-a addr] [-d] [-f dev] [-v]\n",
@


1.9
log
@Update to work with new kernel changes
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.8 2002/06/02 06:42:29 deraadt Exp $	*/
d64 1
a64 1
usage()
d91 11
a101 4
		case USB_SPEED_LOW:  printf("low speed, "); break;
		case USB_SPEED_FULL: printf("full speed, "); break;
		case USB_SPEED_HIGH: printf("high speed, "); break;
		default: break;
d115 2
a116 2
		       di.udi_product, di.udi_productNo,
		       di.udi_vendor, di.udi_vendorNo, di.udi_release);
d124 1
a124 1
				       di.udi_devnames[i]);
d130 1
d134 5
a138 5
				       s == USB_PORT_ENABLED ? "enabled" :
				       s == USB_PORT_SUSPENDED ? "suspended" :
				       s == USB_PORT_POWERED ? "powered" :
				       s == USB_PORT_DISABLED ? "disabled" :
				       "???");
a200 1
		case '?':
@


1.8
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.7 2002/05/30 19:09:05 deraadt Exp $	*/
a89 1
#ifdef notyet
a95 3
#endif
		if (di.udi_lowspeed)
			printf("low speed, ");
@


1.7
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.6 2002/05/29 09:46:20 deraadt Exp $	*/
d184 1
a184 1
		switch(ch) {
@


1.6
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.5 2002/05/10 00:09:17 nate Exp $	*/
d131 1
a131 1
				       s == USB_PORT_SUSPENDED ? "suspended" : 
a134 1
				
@


1.5
log
@Update usb userland stuff to reflect hid changes in the kernel.
This adds the new program usbhidaction which can be used to assign actions
to events that occur on a uhid device.  For example, you can now make the
volume buttons on some newer keyboards actually do something.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.4 2002/05/02 20:12:07 nate Exp $	*/
d208 1
a208 1
			sprintf(buf, "%s%d", USBDEV, i);
@


1.4
log
@userland portion of prefixing usb structure members to avoid name clashes.
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdevs.c,v 1.3 2002/02/16 21:28:10 millert Exp $	*/
/*	$NetBSD: usbdevs.c,v 1.11 1999/09/08 02:39:36 augustss Exp $	*/
d52 2
a53 2
int verbose;
int showdevs;
d75 1
a75 4
usbdev(f, a, rec)
	int f;
	int a;
	int rec;
d90 8
d100 1
d118 1
a118 1
		for (i = 0; i< USB_MAX_DEVNAMES; i++)
d120 2
a121 2
				printf("%*s %s\n", indent, "",
				    di.udi_devnames[i]);
d152 1
a152 2
usbdump(f)
	int f;
d163 1
a163 4
dumpone(name, f, addr)
	char *name;
	int f;
	int addr;
d176 1
a176 3
main(argc, argv)
	int argc;
	char **argv;
a179 2
	extern int optind;
	extern char *optarg;
d221 2
a222 1
			printf("%s: no USB controllers found\n", __progname);
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.2 2001/09/17 17:29:56 mickey Exp $	*/
d83 1
a83 1
	di.addr = a;
d93 1
a93 1
		if (di.lowspeed)
d95 2
a96 2
		if (di.power)
			printf("power %d mA, ", di.power);
d99 2
a100 2
		if (di.config)
			printf("config %d, ", di.config);
d106 2
a107 2
		       di.product, di.productNo,
		       di.vendor, di.vendorNo, di.release);
d109 1
a109 1
		printf("%s, %s", di.product, di.vendor);
d113 1
a113 1
			if (di.devnames[i][0])
d115 1
a115 1
				    di.devnames[i]);
d119 2
a120 2
	for (p = 0; p < di.nports; p++) {
		int s = di.ports[p];
@


1.2
log
@Add support for -d in usbdevs(8); from Jason Ackley <jason@@ackley.net>, pr#2005
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.1 2000/02/03 21:52:15 jakob Exp $	*/
d55 5
a59 5
void usage __P((void));
void usbdev __P((int f, int a, int rec));
void usbdump __P((int f));
void dumpone __P((char *name, int f, int addr));
int main __P((int, char **));
@


1.1
log
@usbdevs (from NetBSD). OK deraadt@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdevs.c,v 1.11 1999/09/08 02:39:36 augustss Exp $	*/
d53 1
d66 2
a67 1
	fprintf(stderr, "Usage: %s [-a addr] [-f dev] [-v]\n", __progname);
d81 1
a81 1
	int e, p;
d111 6
d186 1
a186 1
	while ((ch = getopt(argc, argv, "a:f:v")) != -1) {
d190 3
@

