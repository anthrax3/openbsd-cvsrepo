head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.4
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.19.0.2
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.34
date	2016.10.28.08.01.53;	author rzalamena;	state Exp;
branches;
next	1.33;
commitid	SMslalgbhOIf4OXA;

1.33
date	2016.09.03.15.45.02;	author jca;	state Exp;
branches;
next	1.32;
commitid	SU5xeGdxOhVCS8HO;

1.32
date	2015.11.03.07.48.03;	author gerhard;	state Exp;
branches;
next	1.31;
commitid	HTrbXFWx2xcvBieY;

1.31
date	2015.07.18.00.27.32;	author claudio;	state Exp;
branches;
next	1.30;
commitid	m5d7Me1rMY3KOxGM;

1.30
date	2015.01.16.00.05.13;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	khLbW7SmDyckNaAs;

1.29
date	2014.10.16.04.05.02;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	gQPnBGIeBLxf0pp6;

1.28
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.27;
commitid	uXnRK9VvnFZsAqfW;

1.27
date	2014.05.16.08.46.23;	author mikeb;	state Exp;
branches;
next	1.26;

1.26
date	2014.05.14.09.42.22;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.28.12.03.32;	author mikeb;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.30.17.24.35;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2012.11.13.22.08.33;	author florian;	state Exp;
branches;
next	1.22;

1.22
date	2012.09.18.08.36.39;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2012.09.18.08.29.09;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2012.09.17.16.43.59;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2012.06.10.14.52.46;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2012.05.28.20.55.40;	author joel;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.21.14.55.22;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2011.03.07.07.43.02;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.15.09.27.03;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.11.10.45.36;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.27.15.36.46;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.01.14.42.32;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.01.13.44.42;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.31.09.20.23;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.29.14.52.49;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.25.17.02.30;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.05.22.40.24;	author chris;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.16.09.51.15;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.29.09.24.43;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.28.16.59.31;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.28.15.33.37;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.06.04.10.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.05.09.22.44;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Use snmpd_env as the only global variable for env to simplify the daemon
and avoid problems.

ok jca@@
@
text
@/*	$OpenBSD: kroute.c,v 1.33 2016/09/03 15:45:02 jca Exp $	*/

/*
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/tree.h>
#include <sys/uio.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <event.h>

#include "snmpd.h"

struct ktable		**krt;
u_int			  krt_size;

struct {
	struct event		 ks_ev;
	u_long			 ks_iflastchange;
	u_long			 ks_nroutes;	/* 4 billions enough? */
	int			 ks_fd;
	int			 ks_ifd;
	u_short			 ks_nkif;
} kr_state;

struct kroute_node {
	RB_ENTRY(kroute_node)	 entry;
	struct kroute		 r;
	struct kroute_node	*next;
};

struct kroute6_node {
	RB_ENTRY(kroute6_node)	 entry;
	struct kroute6		 r;
	struct kroute6_node	*next;
};

struct kif_node {
	RB_ENTRY(kif_node)	 entry;
	TAILQ_HEAD(, kif_addr)	 addrs;
	TAILQ_HEAD(, kif_arp)	 arps;
	struct kif		 k;
};

int	kroute_compare(struct kroute_node *, struct kroute_node *);
int	kroute6_compare(struct kroute6_node *, struct kroute6_node *);
int	kif_compare(struct kif_node *, struct kif_node *);

void			 ktable_init(void);
int			 ktable_new(u_int, u_int);
void			 ktable_free(u_int);
int			 ktable_exists(u_int, u_int *);
struct ktable		*ktable_get(u_int);
int			 ktable_update(u_int);

struct kroute_node	*kroute_find(struct ktable *, in_addr_t, u_int8_t,
			    u_int8_t);
struct kroute_node	*kroute_matchgw(struct kroute_node *,
			    struct sockaddr_in *);
int			 kroute_insert(struct ktable *, struct kroute_node *);
int			 kroute_remove(struct ktable *, struct kroute_node *);
void			 kroute_clear(struct ktable *);

struct kroute6_node	*kroute6_find(struct ktable *, const struct in6_addr *,
			    u_int8_t, u_int8_t);
struct kroute6_node	*kroute6_matchgw(struct kroute6_node *,
			    struct sockaddr_in6 *);
int			 kroute6_insert(struct ktable *, struct kroute6_node *);
int			 kroute6_remove(struct ktable *, struct kroute6_node *);
void			 kroute6_clear(struct ktable *);

struct kif_arp		*karp_find(struct sockaddr *, u_short);
int			 karp_insert(struct kif_node *, struct kif_arp *);
int			 karp_remove(struct kif_node *, struct kif_arp *);

struct kif_node		*kif_find(u_short);
struct kif_node		*kif_insert(u_short);
int			 kif_remove(struct kif_node *);
void			 kif_clear(void);
struct kif		*kif_update(u_short, int, struct if_data *,
			    struct sockaddr_dl *);

int			 ka_compare(struct kif_addr *, struct kif_addr *);
void			 ka_insert(u_short, struct kif_addr *);
struct kif_addr		*ka_find(struct sockaddr *);
int			 ka_remove(struct kif_addr *);

u_int8_t	prefixlen_classful(in_addr_t);
u_int8_t	mask2prefixlen(in_addr_t);
in_addr_t	prefixlen2mask(u_int8_t);
u_int8_t	mask2prefixlen6(struct sockaddr_in6 *);
struct in6_addr *prefixlen2mask6(u_int8_t);
void		get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
void		if_change(u_short, int, struct if_data *, struct sockaddr_dl *);
void		if_newaddr(u_short, struct sockaddr *, struct sockaddr *,
		    struct sockaddr *);
void		if_deladdr(u_short, struct sockaddr *, struct sockaddr *,
		    struct sockaddr *);
void		if_announce(void *);

int		fetchtable(struct ktable *);
int		fetchifs(u_short);
int		fetcharp(struct ktable *);
void		dispatch_rtmsg(int, short, void *);
int		rtmsg_process(char *, int);
int		dispatch_rtmsg_addr(struct ktable *, struct rt_msghdr *,
		    struct sockaddr *[RTAX_MAX]);

RB_PROTOTYPE(kroute_tree, kroute_node, entry, kroute_compare)
RB_GENERATE(kroute_tree, kroute_node, entry, kroute_compare)

RB_PROTOTYPE(kroute6_tree, kroute6_node, entry, kroute6_compare)
RB_GENERATE(kroute6_tree, kroute6_node, entry, kroute6_compare)

RB_HEAD(kif_tree, kif_node)		kit;
RB_PROTOTYPE(kif_tree, kif_node, entry, kif_compare)
RB_GENERATE(kif_tree, kif_node, entry, kif_compare)

RB_HEAD(ka_tree, kif_addr)		kat;
RB_PROTOTYPE(ka_tree, kif_addr, node, ka_compare)
RB_GENERATE(ka_tree, kif_addr, node, ka_compare)

void
kr_init(void)
{
	int		opt = 0, rcvbuf, default_rcvbuf;
	unsigned int	tid = RTABLE_ANY;
	socklen_t	optlen;

	if ((kr_state.ks_ifd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatal("kr_init: ioctl socket");

	if ((kr_state.ks_fd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
		fatal("kr_init: route socket");

	/* not interested in my own messages */
	if (setsockopt(kr_state.ks_fd, SOL_SOCKET, SO_USELOOPBACK,
	    &opt, sizeof(opt)) == -1)
		log_warn("%s: SO_USELOOPBACK", __func__);	/* not fatal */

	if (snmpd_env->sc_rtfilter && setsockopt(kr_state.ks_fd, PF_ROUTE,
	    ROUTE_MSGFILTER, &snmpd_env->sc_rtfilter,
	    sizeof(snmpd_env->sc_rtfilter)) == -1)
		log_warn("%s: ROUTE_MSGFILTER", __func__);

	/* grow receive buffer, don't wanna miss messages */
	optlen = sizeof(default_rcvbuf);
	if (getsockopt(kr_state.ks_fd, SOL_SOCKET, SO_RCVBUF,
	    &default_rcvbuf, &optlen) == -1)
		log_warn("%s: SO_RCVBUF", __func__);
	else
		for (rcvbuf = MAX_RTSOCK_BUF;
		    rcvbuf > default_rcvbuf &&
		    setsockopt(kr_state.ks_fd, SOL_SOCKET, SO_RCVBUF,
		    &rcvbuf, sizeof(rcvbuf)) == -1 && errno == ENOBUFS;
		    rcvbuf /= 2)
			;	/* nothing */

	if (setsockopt(kr_state.ks_fd, AF_ROUTE, ROUTE_TABLEFILTER, &tid,
	    sizeof(tid)) == -1)
		log_warn("%s: ROUTE_TABLEFILTER", __func__);

	RB_INIT(&kit);
	RB_INIT(&kat);

	if (fetchifs(0) == -1)
		fatalx("kr_init: fetchifs");

	ktable_init();

	event_set(&kr_state.ks_ev, kr_state.ks_fd, EV_READ | EV_PERSIST,
	    dispatch_rtmsg, NULL);
	event_add(&kr_state.ks_ev, NULL);
}

void
ktable_init(void)
{
	u_int		 i;

	for (i = 0; i < RT_TABLEID_MAX; i++)
		if (ktable_exists(i, NULL))
			ktable_update(i);
}

int
ktable_new(u_int rtableid, u_int rdomid)
{
	struct ktable	**xkrt;
	struct ktable	 *kt;
	size_t		  newsize, oldsize;

	/* resize index table if needed */
	if (rtableid >= krt_size) {
		if ((xkrt = reallocarray(krt, rtableid + 1,
		    sizeof(struct ktable *))) == NULL) {
			log_warn("%s: realloc", __func__);
			return (-1);
		}
		krt = xkrt;
		oldsize = krt_size * sizeof(struct ktable *);
		krt_size = rtableid + 1;
		newsize = krt_size * sizeof(struct ktable *);
		bzero((char *)krt + oldsize, newsize - oldsize);
	}

	if (krt[rtableid])
		fatalx("ktable_new: table already exists");

	/* allocate new element */
	kt = krt[rtableid] = calloc(1, sizeof(struct ktable));
	if (kt == NULL) {
		log_warn("%s: calloc", __func__);
		return (-1);
	}

	/* initialize structure ... */
	RB_INIT(&kt->krt);
	RB_INIT(&kt->krt6);
	kt->rtableid = rtableid;
	kt->rdomain = rdomid;

	/* ... and load it */
	if (fetchtable(kt) == -1)
		return (-1);
	/* load arp information */
	if (fetcharp(kt) == -1)
		return (-1);

	log_debug("%s: new ktable for rtableid %d", __func__, rtableid);
	return (0);
}

void
ktable_free(u_int rtableid)
{
	struct ktable	*kt;

	if ((kt = ktable_get(rtableid)) == NULL)
		return;

	log_debug("%s: freeing ktable rtableid %u", __func__, kt->rtableid);
	kroute_clear(kt);
	kroute6_clear(kt);

	krt[kt->rtableid] = NULL;
	free(kt);
}

struct ktable *
ktable_get(u_int rtableid)
{
	if (rtableid >= krt_size)
		return (NULL);
	return (krt[rtableid]);
}

int
ktable_update(u_int rtableid)
{
	struct ktable	*kt;
	u_int		 rdomid;

	if (!ktable_exists(rtableid, &rdomid))
		fatalx("ktable_update: table doesn't exist");

	if (rdomid != rtableid) {
		if (ktable_get(rdomid) == NULL &&
		    ktable_new(rdomid, rdomid) != 0)
			return (-1);
	}

	kt = ktable_get(rtableid);
	if (kt == NULL) {
		if (ktable_new(rtableid, rdomid))
			return (-1);
	}
	return (0);
}

int
ktable_exists(u_int rtableid, u_int *rdomid)
{
	size_t			 len;
	struct rt_tableinfo	 info;
	int			 mib[6];

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;
	mib[4] = NET_RT_TABLE;
	mib[5] = rtableid;

	len = sizeof(info);
	if (sysctl(mib, 6, &info, &len, NULL, 0) == -1) {
		if (errno == ENOENT)
			/* table nonexistent */
			return (0);
		log_warn("%s: sysctl", __func__);
		/* must return 0 so that the table is considered non-existent */
		return (0);
	}
	if (rdomid)
		*rdomid = info.rti_domainid;
	return (1);
}

void
kr_shutdown(void)
{
	u_int	i;

	for (i = krt_size; i > 0; i--)
		ktable_free(i - 1);
	kif_clear();
}

u_int
kr_ifnumber(void)
{
	return (kr_state.ks_nkif);
}

u_long
kr_iflastchange(void)
{
	return (kr_state.ks_iflastchange);
}

int
kr_updateif(u_int if_index)
{
	return (fetchifs(if_index));
}

u_long
kr_routenumber(void)
{
	return (kr_state.ks_nroutes);
}

/* rb-tree compare */
int
kroute_compare(struct kroute_node *a, struct kroute_node *b)
{
	if (ntohl(a->r.prefix.s_addr) < ntohl(b->r.prefix.s_addr))
		return (-1);
	if (ntohl(a->r.prefix.s_addr) > ntohl(b->r.prefix.s_addr))
		return (1);
	if (a->r.prefixlen < b->r.prefixlen)
		return (-1);
	if (a->r.prefixlen > b->r.prefixlen)
		return (1);

	/* if the priority is RTP_ANY finish on the first address hit */
	if (a->r.priority == RTP_ANY || b->r.priority == RTP_ANY)
		return (0);
	if (a->r.priority < b->r.priority)
		return (-1);
	if (a->r.priority > b->r.priority)
		return (1);
	return (0);
}

int
kroute6_compare(struct kroute6_node *a, struct kroute6_node *b)
{
	int i;

	for (i = 0; i < 16; i++) {
		if (a->r.prefix.s6_addr[i] < b->r.prefix.s6_addr[i])
			return (-1);
		if (a->r.prefix.s6_addr[i] > b->r.prefix.s6_addr[i])
			return (1);
	}

	if (a->r.prefixlen < b->r.prefixlen)
		return (-1);
	if (a->r.prefixlen > b->r.prefixlen)
		return (1);

	/* if the priority is RTP_ANY finish on the first address hit */
	if (a->r.priority == RTP_ANY || b->r.priority == RTP_ANY)
		return (0);
	if (a->r.priority < b->r.priority)
		return (-1);
	if (a->r.priority > b->r.priority)
		return (1);
	return (0);
}

int
kif_compare(struct kif_node *a, struct kif_node *b)
{
	return (a->k.if_index - b->k.if_index);
}

int
ka_compare(struct kif_addr *a, struct kif_addr *b)
{
	if (a->addr.sa.sa_family < b->addr.sa.sa_family)
		return (-1);
	if (a->addr.sa.sa_family > b->addr.sa.sa_family)
		return (1);
	return (memcmp(&a->addr.sa, &b->addr.sa, a->addr.sa.sa_len));
}

/* tree management */
struct kroute_node *
kroute_find(struct ktable *kt, in_addr_t prefix, u_int8_t prefixlen,
    u_int8_t prio)
{
	struct kroute_node	s;
	struct kroute_node	*kn, *tmp;

	s.r.prefix.s_addr = prefix;
	s.r.prefixlen = prefixlen;
	s.r.priority = prio;

	kn = RB_FIND(kroute_tree, &kt->krt, &s);
	if (kn && prio == RTP_ANY) {
		tmp = RB_PREV(kroute_tree, &kt->krt, kn);
		while (tmp) {
			if (kroute_compare(&s, tmp) == 0)
				kn = tmp;
			else
				break;
			tmp = RB_PREV(kroute_tree, &kt->krt, kn);
		}
	}
	return (kn);
}

struct kroute_node *
kroute_matchgw(struct kroute_node *kr, struct sockaddr_in *sa_in)
{
	in_addr_t	nexthop;

	if (sa_in == NULL) {
		log_warnx("%s: no nexthop defined", __func__);
		return (NULL);
	}
	nexthop = sa_in->sin_addr.s_addr;

	while (kr) {
		if (kr->r.nexthop.s_addr == nexthop)
			return (kr);
		kr = kr->next;
	}

	return (NULL);
}

int
kroute_insert(struct ktable *kt, struct kroute_node *kr)
{
	struct kroute_node	*krm;

	if ((krm = RB_INSERT(kroute_tree, &kt->krt, kr)) != NULL) {
		/* multipath route, add at end of list */
		while (krm->next != NULL)
			krm = krm->next;
		krm->next = kr;
		kr->next = NULL; /* to be sure */
	}

	kr_state.ks_nroutes++;
	return (0);
}

int
kroute_remove(struct ktable *kt, struct kroute_node *kr)
{
	struct kroute_node	*krm;

	if ((krm = RB_FIND(kroute_tree, &kt->krt, kr)) == NULL) {
		log_warnx("%s: failed to find %s/%u", __func__,
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
		return (-1);
	}

	if (krm == kr) {
		/* head element */
		if (RB_REMOVE(kroute_tree, &kt->krt, kr) == NULL) {
			log_warnx("%s: failed for %s/%u", __func__,
			    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
			return (-1);
		}
		if (kr->next != NULL) {
			if (RB_INSERT(kroute_tree, &kt->krt, kr->next)
			    != NULL) {
				log_warnx("%s: failed to add %s/%u", __func__,
				    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
				return (-1);
			}
		}
	} else {
		/* somewhere in the list */
		while (krm->next != kr && krm->next != NULL)
			krm = krm->next;
		if (krm->next == NULL) {
			log_warnx("%s: multipath list corrupted for %s/%u",
			    __func__, inet_ntoa(kr->r.prefix), kr->r.prefixlen);
			return (-1);
		}
		krm->next = kr->next;
	}

	kr_state.ks_nroutes--;
	free(kr);
	return (0);
}

void
kroute_clear(struct ktable *kt)
{
	struct kroute_node	*kr;

	while ((kr = RB_MIN(kroute_tree, &kt->krt)) != NULL)
		kroute_remove(kt, kr);
}

struct kroute6_node *
kroute6_find(struct ktable *kt, const struct in6_addr *prefix,
    u_int8_t prefixlen, u_int8_t prio)
{
	struct kroute6_node	s;
	struct kroute6_node	*kn6, *tmp;

	memcpy(&s.r.prefix, prefix, sizeof(struct in6_addr));
	s.r.prefixlen = prefixlen;
	s.r.priority = prio;

	kn6 = RB_FIND(kroute6_tree, &kt->krt6, &s);
	if (kn6 && prio == RTP_ANY) {
		tmp = RB_PREV(kroute6_tree, &kt->krt6, kn6);
		while (tmp) {
			if (kroute6_compare(&s, tmp) == 0)
				kn6 = tmp;
			else
				break;
			tmp = RB_PREV(kroute6_tree, &kt->krt6, kn6);
		}
	}
	return (kn6);
}

struct kroute6_node *
kroute6_matchgw(struct kroute6_node *kr, struct sockaddr_in6 *sa_in6)
{
	struct in6_addr	nexthop;

	if (sa_in6 == NULL) {
		log_warnx("%s: no nexthop defined", __func__);
		return (NULL);
	}
	memcpy(&nexthop, &sa_in6->sin6_addr, sizeof(nexthop));

	while (kr) {
		if (memcmp(&kr->r.nexthop, &nexthop, sizeof(nexthop)) == 0)
			return (kr);
		kr = kr->next;
	}

	return (NULL);
}

int
kroute6_insert(struct ktable *kt, struct kroute6_node *kr)
{
	struct kroute6_node	*krm;

	if ((krm = RB_INSERT(kroute6_tree, &kt->krt6, kr)) != NULL) {
		/* multipath route, add at end of list */
		while (krm->next != NULL)
			krm = krm->next;
		krm->next = kr;
		kr->next = NULL; /* to be sure */
	}

	kr_state.ks_nroutes++;
	return (0);
}

int
kroute6_remove(struct ktable *kt, struct kroute6_node *kr)
{
	struct kroute6_node	*krm;

	if ((krm = RB_FIND(kroute6_tree, &kt->krt6, kr)) == NULL) {
		log_warnx("%s: failed for %s/%u", __func__,
		    log_in6addr(&kr->r.prefix), kr->r.prefixlen);
		return (-1);
	}

	if (krm == kr) {
		/* head element */
		if (RB_REMOVE(kroute6_tree, &kt->krt6, kr) == NULL) {
			log_warnx("%s: failed for %s/%u", __func__,
			    log_in6addr(&kr->r.prefix), kr->r.prefixlen);
			return (-1);
		}
		if (kr->next != NULL) {
			if (RB_INSERT(kroute6_tree, &kt->krt6, kr->next) !=
			    NULL) {
				log_warnx("%s: failed to add %s/%u", __func__,
				    log_in6addr(&kr->r.prefix),
				    kr->r.prefixlen);
				return (-1);
			}
		}
	} else {
		/* somewhere in the list */
		while (krm->next != kr && krm->next != NULL)
			krm = krm->next;
		if (krm->next == NULL) {
			log_warnx("%s: multipath list corrupted for %s/%u",
			    __func__, log_in6addr(&kr->r.prefix),
			    kr->r.prefixlen);
			return (-1);
		}
		krm->next = kr->next;
	}

	kr_state.ks_nroutes--;
	free(kr);
	return (0);
}

void
kroute6_clear(struct ktable *kt)
{
	struct kroute6_node	*kr;

	while ((kr = RB_MIN(kroute6_tree, &kt->krt6)) != NULL)
		kroute6_remove(kt, kr);
}

static inline int
karp_compare(struct kif_arp *a, struct kif_arp *b)
{
	/* Interface indices are assumed equal */
	if (ntohl(a->addr.sin.sin_addr.s_addr) >
	    ntohl(b->addr.sin.sin_addr.s_addr))
		return (1);
	if (ntohl(a->addr.sin.sin_addr.s_addr) <
	    ntohl(b->addr.sin.sin_addr.s_addr))
		return (-1);
	return (0);
}

static inline struct kif_arp *
karp_search(struct kif_node *kn, struct kif_arp *ka)
{
	struct kif_arp		*pivot;

	TAILQ_FOREACH(pivot, &kn->arps, entry) {
		switch (karp_compare(ka, pivot)) {
		case 0: /* found */
			return (pivot);
		case -1: /* ka < pivot, end the search */
			return (NULL);
		}
	}
	/* looped through the whole list and didn't find */
	return (NULL);
}

struct kif_arp *
karp_find(struct sockaddr *sa, u_short ifindex)
{
	struct kif_node		*kn;
	struct kif_arp		*ka = NULL, s;

	memcpy(&s.addr.sa, sa, sa->sa_len);

	if (ifindex == 0) {
		/*
		 * We iterate manually to handle zero ifindex special
		 * case differently from kif_find, in particular we
		 * want to look for the address on all available
		 * interfaces.
		 */
		RB_FOREACH(kn, kif_tree, &kit) {
			if ((ka = karp_search(kn, &s)) != NULL)
				break;
		}
	} else {
		if ((kn = kif_find(ifindex)) == NULL)
			return (NULL);
		ka = karp_search(kn, &s);
	}
	return (ka);
}

int
karp_insert(struct kif_node *kn, struct kif_arp *ka)
{
	struct kif_arp		*pivot;

	if (ka->if_index == 0)
		return (-1);
	if (!kn && (kn = kif_find(ka->if_index)) == NULL)
		return (-1);
	/* Put entry on the list in the ascending lexical order */
	TAILQ_FOREACH(pivot, &kn->arps, entry) {
		switch (karp_compare(ka, pivot)) {
		case 0: /* collision */
			return (-1);
		case -1: /* ka < pivot */
			TAILQ_INSERT_BEFORE(pivot, ka, entry);
			return (0);
		}
	}
	/* ka is larger than any other element on the list */
	TAILQ_INSERT_TAIL(&kn->arps, ka, entry);
	return (0);
}

int
karp_remove(struct kif_node *kn, struct kif_arp *ka)
{
	if (ka->if_index == 0)
		return (-1);
	if (!kn && (kn = kif_find(ka->if_index)) == NULL)
		return (-1);
	TAILQ_REMOVE(&kn->arps, ka, entry);
	free(ka);
	return (0);
}

struct kif_arp *
karp_first(u_short ifindex)
{
	struct kif_node		*kn;

	if ((kn = kif_find(ifindex)) == NULL)
		return (NULL);
	return (TAILQ_FIRST(&kn->arps));
}

struct kif_arp *
karp_getaddr(struct sockaddr *sa, u_short ifindex, int next)
{
	struct kif_arp		*ka;

	if ((ka = karp_find(sa, ifindex)) == NULL)
		return (NULL);
	return (next ? TAILQ_NEXT(ka, entry) : ka);
}

struct kif_node *
kif_find(u_short if_index)
{
	struct kif_node	s;

	if (if_index == 0)
		return (RB_MIN(kif_tree, &kit));

	bzero(&s, sizeof(s));
	s.k.if_index = if_index;

	return (RB_FIND(kif_tree, &kit, &s));
}

struct kif *
kr_getif(u_short if_index)
{
	struct kif_node	*kn;

	kn = kif_find(if_index);
	if (kn == NULL)
		return (NULL);

	return (&kn->k);
}

struct kif *
kr_getnextif(u_short if_index)
{
	struct kif_node	*kn;

	if ((kn = kif_find(if_index)) == NULL)
		return (NULL);
	if (if_index)
		kn = RB_NEXT(kif_tree, &kit, kn);
	if (kn == NULL)
		return (NULL);

	return (&kn->k);
}

struct kif_node *
kif_insert(u_short if_index)
{
	struct kif_node	*kif;

	if ((kif = calloc(1, sizeof(struct kif_node))) == NULL)
		return (NULL);

	kif->k.if_index = if_index;
	TAILQ_INIT(&kif->addrs);
	TAILQ_INIT(&kif->arps);

	if (RB_INSERT(kif_tree, &kit, kif) != NULL)
		fatalx("kif_insert: RB_INSERT");

	kr_state.ks_nkif++;
	kr_state.ks_iflastchange = smi_getticks();

	return (kif);
}

int
kif_remove(struct kif_node *kif)
{
	struct kif_addr	*ka;
	struct kif_arp	*kr;

	if (RB_REMOVE(kif_tree, &kit, kif) == NULL) {
		log_warnx("%s: RB_REMOVE failed", __func__);
		return (-1);
	}

	while ((ka = TAILQ_FIRST(&kif->addrs)) != NULL) {
		TAILQ_REMOVE(&kif->addrs, ka, entry);
		ka_remove(ka);
	}
	while ((kr = TAILQ_FIRST(&kif->arps)) != NULL) {
		karp_remove(kif, kr);
	}
	free(kif);

	kr_state.ks_nkif--;
	kr_state.ks_iflastchange = smi_getticks();

	return (0);
}

void
kif_clear(void)
{
	struct kif_node	*kif;

	while ((kif = RB_MIN(kif_tree, &kit)) != NULL)
		kif_remove(kif);
	kr_state.ks_nkif = 0;
	kr_state.ks_iflastchange = smi_getticks();
}

struct kif *
kif_update(u_short if_index, int flags, struct if_data *ifd,
    struct sockaddr_dl *sdl)
{
	struct kif_node		*kif;
	struct ether_addr	*ea;
	struct ifreq		 ifr;

	if ((kif = kif_find(if_index)) == NULL)
		if ((kif = kif_insert(if_index)) == NULL)
			return (NULL);

	kif->k.if_flags = flags;
	bcopy(ifd, &kif->k.if_data, sizeof(struct if_data));
	kif->k.if_ticks = smi_getticks();

	if (sdl && sdl->sdl_family == AF_LINK) {
		if (sdl->sdl_nlen >= sizeof(kif->k.if_name))
			memcpy(kif->k.if_name, sdl->sdl_data,
			    sizeof(kif->k.if_name) - 1);
		else if (sdl->sdl_nlen > 0)
			memcpy(kif->k.if_name, sdl->sdl_data,
			    sdl->sdl_nlen);
		/* string already terminated via calloc() */

		if ((ea = (struct ether_addr *)LLADDR(sdl)) != NULL)
			bcopy(&ea->ether_addr_octet, kif->k.if_lladdr,
			    ETHER_ADDR_LEN);
	}

	bzero(&ifr, sizeof(ifr));
	strlcpy(ifr.ifr_name, kif->k.if_name, sizeof(ifr.ifr_name));
	ifr.ifr_data = (caddr_t)&kif->k.if_descr;
	if (ioctl(kr_state.ks_ifd, SIOCGIFDESCR, &ifr) == -1)
		bzero(&kif->k.if_descr, sizeof(kif->k.if_descr));

	return (&kif->k);
}

void
ka_insert(u_short if_index, struct kif_addr *ka)
{
	if (ka->addr.sa.sa_len == 0)
		return;

	ka->if_index = if_index;
	RB_INSERT(ka_tree, &kat, ka);
}

struct kif_addr	*
ka_find(struct sockaddr *sa)
{
	struct kif_addr		ka;

	if (sa == NULL)
		return (RB_MIN(ka_tree, &kat));
	bzero(&ka.addr, sizeof(ka.addr));
	bcopy(sa, &ka.addr.sa, sa->sa_len);
	return (RB_FIND(ka_tree, &kat, &ka));
}

int
ka_remove(struct kif_addr *ka)
{
	RB_REMOVE(ka_tree, &kat, ka);
	free(ka);
	return (0);
}

struct kif_addr *
kr_getaddr(struct sockaddr *sa)
{
	return (ka_find(sa));
}

struct kif_addr *
kr_getnextaddr(struct sockaddr *sa)
{
	struct kif_addr	*ka;

	if ((ka = ka_find(sa)) == NULL)
		return (NULL);
	if (sa)
		ka = RB_NEXT(ka_tree, &kat, ka);

	return (ka);
}

/* misc */
u_int8_t
prefixlen_classful(in_addr_t ina)
{
	/* it hurt to write this. */

	if (ina >= 0xf0000000U)		/* class E */
		return (32);
	else if (ina >= 0xe0000000U)	/* class D */
		return (4);
	else if (ina >= 0xc0000000U)	/* class C */
		return (24);
	else if (ina >= 0x80000000U)	/* class B */
		return (16);
	else				/* class A */
		return (8);
}

u_int8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

in_addr_t
prefixlen2mask(u_int8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	return (htonl(0xffffffff << (32 - prefixlen)));
}

u_int8_t
mask2prefixlen6(struct sockaddr_in6 *sa_in6)
{
	u_int8_t	 l = 0, *ap, *ep;

	/*
	 * sin6_len is the size of the sockaddr so substract the offset of
	 * the possibly truncated sin6_addr struct.
	 */
	ap = (u_int8_t *)&sa_in6->sin6_addr;
	ep = (u_int8_t *)sa_in6 + sa_in6->sin6_len;
	for (; ap < ep; ap++) {
		/* this "beauty" is adopted from sbin/route/show.c ... */
		switch (*ap) {
		case 0xff:
			l += 8;
			break;
		case 0xfe:
			l += 7;
			return (l);
		case 0xfc:
			l += 6;
			return (l);
		case 0xf8:
			l += 5;
			return (l);
		case 0xf0:
			l += 4;
			return (l);
		case 0xe0:
			l += 3;
			return (l);
		case 0xc0:
			l += 2;
			return (l);
		case 0x80:
			l += 1;
			return (l);
		case 0x00:
			return (l);
		default:
			fatalx("non contiguous inet6 netmask");
		}
	}

	return (l);
}

struct in6_addr *
prefixlen2mask6(u_int8_t prefixlen)
{
	static struct in6_addr	mask;
	int			i;

	bzero(&mask, sizeof(mask));
	for (i = 0; i < prefixlen / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

	return (&mask);
}

#define	ROUNDUP(a)	\
    (((a) & (sizeof(long) - 1)) ? (1 + ((a) | (sizeof(long) - 1))) : (a))

void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		} else
			rti_info[i] = NULL;

	}
}

void
if_change(u_short if_index, int flags, struct if_data *ifd,
    struct sockaddr_dl *sdl)
{
	if (kif_update(if_index, flags, ifd, sdl) == NULL)
		log_warn("%s: interface %u update failed", __func__, if_index);
}

void
if_newaddr(u_short if_index, struct sockaddr *ifa, struct sockaddr *mask,
    struct sockaddr *brd)
{
	struct kif_node *kif;
	struct kif_addr *ka;

	if (ifa == NULL)
		return;
	if ((kif = kif_find(if_index)) == NULL) {
		log_warnx("%s: corresponding if %u not found", __func__,
		    if_index);
		return;
	}
	if ((ka = ka_find(ifa)) == NULL) {
		if ((ka = calloc(1, sizeof(struct kif_addr))) == NULL)
			fatal("if_newaddr");
		bcopy(ifa, &ka->addr.sa, ifa->sa_len);
		TAILQ_INSERT_TAIL(&kif->addrs, ka, entry);
		ka_insert(if_index, ka);
	}

	if (mask)
		bcopy(mask, &ka->mask.sa, mask->sa_len);
	else
		bzero(&ka->mask, sizeof(ka->mask));
	if (brd)
		bcopy(brd, &ka->dstbrd.sa, brd->sa_len);
	else
		bzero(&ka->dstbrd, sizeof(ka->dstbrd));
}

void
if_deladdr(u_short if_index, struct sockaddr *ifa, struct sockaddr *mask,
    struct sockaddr *brd)
{
	struct kif_node *kif;
	struct kif_addr *ka;

	if (ifa == NULL)
		return;
	if ((kif = kif_find(if_index)) == NULL) {
		log_warnx("%s: corresponding if %u not found", __func__,
		    if_index);
		return;
	}
	if ((ka = ka_find(ifa)) == NULL)
		return;

	TAILQ_REMOVE(&kif->addrs, ka, entry);
	ka_remove(ka);
}

void
if_announce(void *msg)
{
	struct if_announcemsghdr	*ifan;
	struct kif_node			*kif;

	ifan = msg;

	switch (ifan->ifan_what) {
	case IFAN_ARRIVAL:
		kif = kif_insert(ifan->ifan_index);
		strlcpy(kif->k.if_name, ifan->ifan_name,
		    sizeof(kif->k.if_name));
		break;
	case IFAN_DEPARTURE:
		kif = kif_find(ifan->ifan_index);
		kif_remove(kif);
		break;
	}
}

int
fetchtable(struct ktable *kt)
{
	int			 mib[7];
	size_t			 len;
	char			*buf;
	int			 rv;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
	mib[6] = kt->rtableid;

	if (sysctl(mib, 7, NULL, &len, NULL, 0) == -1) {
		if (kt->rtableid != 0 && errno == EINVAL)
			/* table nonexistent */
			return (0);
		log_warn("%s: failed to fetch routing table %u size", __func__,
		    kt->rtableid);
		return (-1);
	}
	if (len == 0)
		return (0);
	if ((buf = malloc(len)) == NULL) {
		log_warn("%s: malloc", __func__);
		return (-1);
	}
	if (sysctl(mib, 7, buf, &len, NULL, 0) == -1) {
		log_warn("%s: failed to fetch routing table %u", __func__,
		    kt->rtableid);
		free(buf);
		return (-1);
	}

	rv = rtmsg_process(buf, len);
	free(buf);

	return (rv);
}

int
fetchifs(u_short if_index)
{
	size_t			 len;
	int			 mib[6];
	char			*buf;
	int			 rv;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;	/* wildcard address family */
	mib[4] = NET_RT_IFLIST;
	mib[5] = if_index;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
		log_warn("%s: failed to fetch address table size for %u",
		    __func__, if_index);
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("%s: malloc", __func__);
		return (-1);
	}
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
		log_warn("%s: failed to fetch address table for %u",
		    __func__, if_index);
		free(buf);
		return (-1);
	}

	rv = rtmsg_process(buf, len);
	free(buf);

	return (rv);
}

int
fetcharp(struct ktable *kt)
{
	size_t			 len;
	int			 mib[7];
	char			*buf;
	int			 rv;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_FLAGS;
	mib[5] = RTF_LLINFO;
	mib[6] = kt->rtableid;

	if (sysctl(mib, 7, NULL, &len, NULL, 0) == -1) {
		log_warn("%s: failed to fetch arp table %u size", __func__,
		    kt->rtableid);
		return (-1);
	}
	/* Empty table? */
	if (len == 0)
		return (0);
	if ((buf = malloc(len)) == NULL) {
		log_warn("%s: malloc", __func__);
		return (-1);
	}
	if (sysctl(mib, 7, buf, &len, NULL, 0) == -1) {
		log_warn("%s: failed to fetch arp table %u", __func__,
		    kt->rtableid);
		free(buf);
		return (-1);
	}

	rv = rtmsg_process(buf, len);
	free(buf);

	return (rv);
}

/* ARGSUSED */
void
dispatch_rtmsg(int fd, short event, void *arg)
{
	char			 buf[RT_BUF_SIZE];
	ssize_t			 n;

	if ((n = read(fd, &buf, sizeof(buf))) == -1) {
		log_warn("%s: read error", __func__);
		return;
	}

	if (n == 0) {
		log_warnx("%s: routing socket closed", __func__);
		return;
	}

	rtmsg_process(buf, n);
}

int
rtmsg_process(char *buf, int len)
{
	struct ktable		*kt;
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct ifa_msghdr	*ifam;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	int			 offset;
	char			*next;

	for (offset = 0; offset < len; offset += rtm->rtm_msglen) {
		next = buf + offset;
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;

		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		switch (rtm->rtm_type) {
		case RTM_ADD:
		case RTM_GET:
		case RTM_CHANGE:
		case RTM_DELETE:
		case RTM_RESOLVE:
			if (rtm->rtm_errno)		 /* failed attempts */
				continue;

			if ((kt = ktable_get(rtm->rtm_tableid)) == NULL)
				continue;

			if (dispatch_rtmsg_addr(kt, rtm, rti_info) == -1)
				return (-1);
			break;
		case RTM_IFINFO:
			memcpy(&ifm, next, sizeof(ifm));
			if_change(ifm.ifm_index, ifm.ifm_flags, &ifm.ifm_data,
			    (struct sockaddr_dl *)rti_info[RTAX_IFP]);
			break;
		case RTM_DELADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;

			if_deladdr(ifam->ifam_index, rti_info[RTAX_IFA],
			    rti_info[RTAX_NETMASK], rti_info[RTAX_BRD]);
			break;
		case RTM_NEWADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;

			if_newaddr(ifam->ifam_index, rti_info[RTAX_IFA],
			    rti_info[RTAX_NETMASK], rti_info[RTAX_BRD]);
			break;
		case RTM_IFANNOUNCE:
			if_announce(next);
			break;
		case RTM_DESYNC:
			kr_shutdown();
			if (fetchifs(0) == -1)
				fatalx("rtmsg_process: fetchifs");
			ktable_init();
			break;
		default:
			/* ignore for now */
			break;
		}
	}

	return (offset);
}

int
dispatch_rtmsg_addr(struct ktable *kt, struct rt_msghdr *rtm,
    struct sockaddr *rti_info[RTAX_MAX])
{
	struct sockaddr		*sa, *psa;
	struct sockaddr_in	*sa_in, *psa_in = NULL;
	struct sockaddr_in6	*sa_in6, *psa_in6 = NULL;
	struct sockaddr_dl	*sa_dl;
	struct kroute_node	*kr;
	struct kroute6_node	*kr6;
	struct kif_arp		*ka;
	int			 flags, mpath = 0;
	u_int16_t		 ifindex;
	u_int8_t		 prefixlen;
	u_int8_t		 prio;

	flags = 0;
	ifindex = 0;
	prefixlen = 0;

	if ((psa = rti_info[RTAX_DST]) == NULL)
		return (-1);

	if (rtm->rtm_flags & RTF_STATIC)
		flags |= F_STATIC;
	if (rtm->rtm_flags & RTF_BLACKHOLE)
		flags |= F_BLACKHOLE;
	if (rtm->rtm_flags & RTF_REJECT)
		flags |= F_REJECT;
	if (rtm->rtm_flags & RTF_DYNAMIC)
		flags |= F_DYNAMIC;
#ifdef RTF_MPATH
	if (rtm->rtm_flags & RTF_MPATH)
		mpath = 1;
#endif

	prio = rtm->rtm_priority;
	switch (psa->sa_family) {
	case AF_INET:
		psa_in = (struct sockaddr_in *)psa;
		sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
		if (sa_in != NULL) {
			if (sa_in->sin_len != 0)
				prefixlen = mask2prefixlen(
				    sa_in->sin_addr.s_addr);
		} else if (rtm->rtm_flags & RTF_HOST)
			prefixlen = 32;
		else
			prefixlen =
			    prefixlen_classful(psa_in->sin_addr.s_addr);
		break;
	case AF_INET6:
		psa_in6 = (struct sockaddr_in6 *)psa;
		sa_in6 = (struct sockaddr_in6 *)rti_info[RTAX_NETMASK];
		if (sa_in6 != NULL) {
			if (sa_in6->sin6_len != 0)
				prefixlen = mask2prefixlen6(sa_in6);
		} else if (rtm->rtm_flags & RTF_HOST)
			prefixlen = 128;
		else
			fatalx("in6 net addr without netmask");
		break;
	default:
		return (0);
	}

	if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
		switch (sa->sa_family) {
		case AF_INET:
		case AF_INET6:
			if (rtm->rtm_flags & RTF_CONNECTED) {
				flags |= F_CONNECTED;
				ifindex = rtm->rtm_index;
			}
			mpath = 0;	/* link local stuff can't be mpath */
			break;
		case AF_LINK:
			/*
			 * Traditional BSD connected routes have
			 * a gateway of type AF_LINK.
			 */
			flags |= F_CONNECTED;
			ifindex = rtm->rtm_index;
			mpath = 0;	/* link local stuff can't be mpath */
			break;
		}

	if (rtm->rtm_type == RTM_DELETE) {
		if (sa != NULL && sa->sa_family == AF_LINK &&
		    (rtm->rtm_flags & RTF_HOST) &&
		    psa->sa_family == AF_INET) {
			if ((ka = karp_find(psa, ifindex)) == NULL)
				return (0);
			if (karp_remove(NULL, ka) == -1)
				return (-1);
			return (0);
		} else if (sa == NULL && (rtm->rtm_flags & RTF_HOST) &&
		    psa->sa_family == AF_INET) {
			if ((ka = karp_find(psa, ifindex)) != NULL)
				karp_remove(NULL, ka);
			/* Continue to the route section below  */
		}
		switch (psa->sa_family) {
		case AF_INET:
			sa_in = (struct sockaddr_in *)sa;
			if ((kr = kroute_find(kt, psa_in->sin_addr.s_addr,
			    prefixlen, prio)) == NULL)
				return (0);

			if (mpath)
				/* get the correct route */
				if ((kr = kroute_matchgw(kr, sa_in)) == NULL) {
					log_warnx("%s[delete]: "
					    "mpath route not found", __func__);
					return (0);
				}

			if (kroute_remove(kt, kr) == -1)
				return (-1);
			break;
		case AF_INET6:
			sa_in6 = (struct sockaddr_in6 *)sa;
			if ((kr6 = kroute6_find(kt, &psa_in6->sin6_addr,
			    prefixlen, prio)) == NULL)
				return (0);

			if (mpath)
				/* get the correct route */
				if ((kr6 = kroute6_matchgw(kr6, sa_in6)) ==
				    NULL) {
					log_warnx("%s[delete]: "
					    "IPv6 mpath route not found",
					    __func__);
					return (0);
				}

			if (kroute6_remove(kt, kr6) == -1)
				return (-1);
			break;
		}
		return (0);
	}

	if (sa == NULL && !(flags & F_CONNECTED))
		return (0);

	/* Add or update an ARP entry */
	if ((rtm->rtm_flags & RTF_LLINFO) && (rtm->rtm_flags & RTF_HOST) &&
	    sa != NULL && sa->sa_family == AF_LINK &&
	    psa->sa_family == AF_INET) {
		sa_dl = (struct sockaddr_dl *)sa;
		/* ignore incomplete entries */
		if (!sa_dl->sdl_alen)
			return (0);
		/* ignore entries that do not specify an interface */
		if (ifindex == 0)
			return (0);
		if ((ka = karp_find(psa, ifindex)) != NULL) {
			memcpy(&ka->target.sdl, sa_dl, sa_dl->sdl_len);
			if (rtm->rtm_flags & RTF_PERMANENT_ARP)
				flags |= F_STATIC;
			ka->flags = flags;
		} else {
			if ((ka = calloc(1, sizeof(struct kif_arp))) == NULL) {
				log_warn("%s: calloc", __func__);
				return (-1);
			}
			memcpy(&ka->addr.sa, psa, psa->sa_len);
			memcpy(&ka->target.sdl, sa_dl, sa_dl->sdl_len);
			if (rtm->rtm_flags & RTF_PERMANENT_ARP)
				flags |= F_STATIC;
			ka->flags = flags;
			ka->if_index = ifindex;
			if (karp_insert(NULL, ka)) {
				free(ka);
				log_warnx("%s: failed to insert", __func__);
				return (-1);
			}
		}
		return (0);
	}

	switch (psa->sa_family) {
	case AF_INET:
		sa_in = (struct sockaddr_in *)sa;
		if ((kr = kroute_find(kt, psa_in->sin_addr.s_addr, prefixlen,
		    prio)) != NULL) {
			/* get the correct route */
			if (mpath && rtm->rtm_type == RTM_CHANGE &&
			    (kr = kroute_matchgw(kr, sa_in)) == NULL) {
				log_warnx("%s[change]: "
				    "mpath route not found", __func__);
				return (-1);
			} else if (mpath && rtm->rtm_type == RTM_ADD)
				goto add4;

			if (sa_in != NULL)
				kr->r.nexthop.s_addr =
				    sa_in->sin_addr.s_addr;
			else
				kr->r.nexthop.s_addr = 0;
			kr->r.flags = flags;
			kr->r.if_index = ifindex;
			kr->r.ticks = smi_getticks();
		} else {
add4:
			if ((kr = calloc(1,
			    sizeof(struct kroute_node))) == NULL) {
				log_warn("%s: calloc", __func__);
				return (-1);
			}
			kr->r.prefix.s_addr = psa_in->sin_addr.s_addr;
			kr->r.prefixlen = prefixlen;
			if (sa_in != NULL)
				kr->r.nexthop.s_addr = sa_in->sin_addr.s_addr;
			else
				kr->r.nexthop.s_addr = 0;
			kr->r.flags = flags;
			kr->r.if_index = ifindex;
			kr->r.ticks = smi_getticks();
			kr->r.priority = prio;

			kroute_insert(kt, kr);
		}
		break;
	case AF_INET6:
		sa_in6 = (struct sockaddr_in6 *)sa;
		if ((kr6 = kroute6_find(kt, &psa_in6->sin6_addr, prefixlen,
		    prio)) != NULL) {
			/* get the correct route */
			if (mpath && rtm->rtm_type == RTM_CHANGE &&
			    (kr6 = kroute6_matchgw(kr6, sa_in6)) ==
			    NULL) {
				log_warnx("%s[change]: "
				    "IPv6 mpath route not found", __func__);
				return (-1);
			} else if (mpath && rtm->rtm_type == RTM_ADD)
				goto add6;

			if (sa_in6 != NULL)
				memcpy(&kr6->r.nexthop,
				    &sa_in6->sin6_addr,
				    sizeof(struct in6_addr));
			else
				memcpy(&kr6->r.nexthop,
				    &in6addr_any,
				    sizeof(struct in6_addr));

			kr6->r.flags = flags;
			kr6->r.if_index = ifindex;
			kr6->r.ticks = smi_getticks();
		} else {
add6:
			if ((kr6 = calloc(1,
			    sizeof(struct kroute6_node))) == NULL) {
				log_warn("%s: calloc", __func__);
				return (-1);
			}
			memcpy(&kr6->r.prefix, &psa_in6->sin6_addr,
			    sizeof(struct in6_addr));
			kr6->r.prefixlen = prefixlen;
			if (sa_in6 != NULL)
				memcpy(&kr6->r.nexthop, &sa_in6->sin6_addr,
				    sizeof(struct in6_addr));
			else
				memcpy(&kr6->r.nexthop, &in6addr_any,
				    sizeof(struct in6_addr));
			kr6->r.flags = flags;
			kr6->r.if_index = ifindex;
			kr6->r.ticks = smi_getticks();
			kr6->r.priority = prio;

			kroute6_insert(kt, kr6);
		}
		break;
	}

	return (0);
}

struct kroute *
kroute_first(void)
{
	struct kroute_node	*kn;
	struct ktable		*kt;

	if ((kt = ktable_get(0)) == NULL)
		return (NULL);
	kn = RB_MIN(kroute_tree, &kt->krt);
	return (&kn->r);
}

struct kroute *
kroute_getaddr(in_addr_t prefix, u_int8_t prefixlen, u_int8_t prio, int next)
{
	struct kroute_node	*kn;
	struct ktable		*kt;

	if ((kt = ktable_get(0)) == NULL)
		return (NULL);
	kn = kroute_find(kt, prefix, prefixlen, prio);
	if (kn != NULL && next)
		kn = RB_NEXT(kroute_tree, &kt->krt, kn);
	if (kn != NULL)
		return (&kn->r);
	else
		return (NULL);
}
@


1.33
log
@Fix pasto; zero ka->dstbrd instead of clobbering ka->mask.

Diff from Jan Klemkow, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.32 2015/11/03 07:48:03 gerhard Exp $	*/
a46 2
extern struct snmpd	*env;

d174 3
a176 2
	if (env->sc_rtfilter && setsockopt(kr_state.ks_fd, PF_ROUTE,
	    ROUTE_MSGFILTER, &env->sc_rtfilter, sizeof(env->sc_rtfilter)) == -1)
@


1.32
log
@When updating an interface, do not delete the kif_node but let
fetchifs() update the existing node. Thus we don't lose the ARP entries.

And while here, also handle RTM_DESYNC messages.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.31 2015/07/18 00:27:32 claudio Exp $	*/
d1130 1
a1130 2
		bzero(&ka->mask, sizeof(ka->mask));

@


1.31
log
@Better track connected routes similar to bgpd/ospfd.
According to sthen@@ this makes snmpd report routes more correct
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.30 2015/01/16 00:05:13 deraadt Exp $	*/
a367 6
	struct kif_node	*kn;

	if ((kn = kif_find(if_index)) != NULL)
		kif_remove(kn);

	/* Do not update the interface address list */
d1377 6
@


1.30
log
@first batch of cleanup to programs based upon the namespace cleanups
in net/pfvar.h sys/proc.h sys/ucred.h arpa/nameser.h
change to PATH_MAX, reduce use of MIN() and MAX(), HOST_NAME_MAX+1,
LOGIN_NAME_MAX, etc etc
ok millert guenther, some review by doug
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.29 2014/10/16 04:05:02 deraadt Exp $	*/
d1461 8
d1470 4
@


1.29
log
@use reallocarray().  Looked at a few times by doug, I am sure.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.28 2014/06/23 03:46:17 guenther Exp $	*/
a20 1
#include <sys/param.h>
@


1.28
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.27 2014/05/16 08:46:23 mikeb Exp $	*/
d230 2
a231 3
		oldsize = sizeof(struct ktable *) * krt_size;
		newsize = sizeof(struct ktable *) * (rtableid + 1);
		if ((xkrt = realloc(krt, newsize)) == NULL) {
d236 1
d238 1
@


1.27
log
@improve logging messages and style; requested by and ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.26 2014/05/14 09:42:22 mikeb Exp $	*/
d323 1
a323 1
	mib[1] = AF_ROUTE;
d1191 1
a1191 1
	mib[1] = AF_ROUTE;
d1234 1
a1234 1
	mib[1] = AF_ROUTE;
d1271 1
a1271 1
	mib[1] = AF_ROUTE;
@


1.26
log
@Sync ktable code with bgpd to fetch, store and perform lookups in
multiple routing tables.  Currently it doesn't do anything useful
but it's a prerequisite for any future work in this direction.

ok sthen, reyk, blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.25 2014/04/28 12:03:32 mikeb Exp $	*/
d175 1
a175 1
		log_warn("kr_init: setsockopt");	/* not fatal */
d179 1
a179 1
		log_warn("kr_init: setsockopt(ROUTE_MSGFILTER)");
d185 1
a185 1
		log_warn("kr_init getsockopt SOL_SOCKET SO_RCVBUF");
d196 1
a196 1
		log_warn("kr_init: setsockopt AF_ROUTE ROUTE_TABLEFILTER");
d202 1
a202 1
		fatalx("kr_init fetchifs");
d233 1
a233 1
			log_warn("ktable_new");
d242 1
a242 1
		fatalx("ktable_new: table already exists.");
d247 1
a247 1
		log_warn("ktable_new");
d264 1
a264 1
	log_debug("new ktable for rtableid %d", rtableid);
d276 1
a276 1
	log_debug("freeing ktable rtableid %u", kt->rtableid);
d299 1
a299 1
		fatalx("King Bula lost a table");	/* may not happen */
d334 1
a334 1
		log_warn("sysctl");
d481 1
a481 1
		log_warnx("kroute_matchgw: no nexthop defined");
d518 1
a518 1
		log_warnx("kroute_remove failed to find %s/%u",
d526 1
a526 1
			log_warnx("kroute_remove failed for %s/%u",
d533 1
a533 1
				log_warnx("kroute_remove failed to add %s/%u",
d543 2
a544 3
			log_warnx("kroute_remove multipath list corrupted "
			    "for %s/%u", inet_ntoa(kr->r.prefix),
			    kr->r.prefixlen);
d595 1
a595 1
		log_warnx("kroute6_matchgw: no nexthop defined");
d632 1
a632 1
		log_warnx("kroute6_remove failed for %s/%u",
d640 1
a640 1
			log_warnx("kroute6_remove failed for %s/%u",
d647 1
a647 1
				log_warnx("kroute6_remove failed to add %s/%u",
d658 2
a659 2
			log_warnx("kroute6_remove multipath list corrupted "
			    "for %s/%u", log_in6addr(&kr->r.prefix),
d862 1
a862 1
		log_warnx("RB_REMOVE(kif_tree, &kit, kif)");
d1104 1
a1104 1
		log_warn("if_change:  kif_update(%u)", if_index);
d1117 1
a1117 1
		log_warnx("if_newaddr: corresponding if %d not found",
d1150 1
a1150 1
		log_warnx("if_deladdr: corresponding if %d not found",
d1202 2
a1203 1
		log_warn("sysctl");
d1209 1
a1209 1
		log_warn("fetchtable");
d1213 2
a1214 1
		log_warn("sysctl2");
d1241 2
a1242 1
		log_warn("sysctl");
d1246 1
a1246 1
		log_warn("fetchif");
d1250 2
a1251 1
		log_warn("sysctl");
d1279 2
a1280 1
		log_warn("sysctl");
d1287 1
a1287 1
		log_warn("fetcharp");
d1291 2
a1292 1
		log_warn("sysctl");
d1311 1
a1311 1
		log_warn("dispatch_rtmsg: read error");
d1316 1
a1316 1
		log_warnx("routing socket closed");
d1493 2
a1494 2
					log_warnx("dispatch_rtmsg[delete] "
					    "mpath route not found");
d1511 3
a1513 2
					log_warnx("dispatch_rtmsg[delete] "
					    "IPv6 mpath route not found");
d1545 1
a1545 1
				log_warn("dispatch_rtmsg");
d1556 1
a1556 1
				log_warnx("dispatch_rtmsg: failed to insert");
d1571 2
a1572 2
				log_warnx("dispatch_rtmsg[change] "
				    "mpath route not found");
d1589 1
a1589 1
				log_warn("dispatch_rtmsg");
d1614 2
a1615 2
				log_warnx("dispatch_rtmsg[change] "
				    "IPv6 mpath route not found");
d1636 1
a1636 1
				log_warn("dispatch_rtmsg");
@


1.25
log
@Add support for exporting ARP table via ipNetToMediaTable OID.
With help from blambert@@ and sthen@@, tested by sthen@@, benno@@
and myself;  ok blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.24 2013/10/30 17:24:35 deraadt Exp $	*/
d50 3
d85 9
a93 1
struct kroute_node	*kroute_find(in_addr_t, u_int8_t, u_int8_t);
d96 3
a98 3
int			 kroute_insert(struct kroute_node *);
int			 kroute_remove(struct kroute_node *);
void			 kroute_clear(void);
d100 2
a101 2
struct kroute6_node	*kroute6_find(const struct in6_addr *, u_int8_t,
			     u_int8_t);
d104 3
a106 3
int			 kroute6_insert(struct kroute6_node *);
int			 kroute6_remove(struct kroute6_node *);
void			 kroute6_clear(void);
d137 1
a137 1
int		fetchtable(void);
d139 1
a139 1
int		fetcharp(void);
d142 1
a142 1
int		dispatch_rtmsg_addr(struct rt_msghdr *,
a144 1
RB_HEAD(kroute_tree, kroute_node)	krt;
a147 1
RB_HEAD(kroute6_tree, kroute6_node)	krt6;
d163 1
d194 4
a197 2
	RB_INIT(&krt);
	RB_INIT(&krt6);
d203 2
a204 4
	if (fetchtable() == -1)
		fatalx("kr_init fetchtable");
	if (fetcharp() == -1)
		fatalx("kr_init fetcharp");
d212 132
d346 4
a349 1
	kroute_clear();
d451 2
a452 1
kroute_find(in_addr_t prefix, u_int8_t prefixlen, u_int8_t prio)
d461 1
a461 1
	kn = RB_FIND(kroute_tree, &krt, &s);
d463 1
a463 1
		tmp = RB_PREV(kroute_tree, &krt, kn);
d469 1
a469 1
			tmp = RB_PREV(kroute_tree, &krt, kn);
d496 1
a496 1
kroute_insert(struct kroute_node *kr)
d500 1
a500 1
	if ((krm = RB_INSERT(kroute_tree, &krt, kr)) != NULL) {
d513 1
a513 1
kroute_remove(struct kroute_node *kr)
d517 1
a517 1
	if ((krm = RB_FIND(kroute_tree, &krt, kr)) == NULL) {
d525 1
a525 1
		if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
d531 2
a532 1
			if (RB_INSERT(kroute_tree, &krt, kr->next) != NULL) {
d557 1
a557 1
kroute_clear(void)
d561 2
a562 2
	while ((kr = RB_MIN(kroute_tree, &krt)) != NULL)
		kroute_remove(kr);
d566 2
a567 1
kroute6_find(const struct in6_addr *prefix, u_int8_t prefixlen, u_int8_t prio)
d576 1
a576 1
	kn6 = RB_FIND(kroute6_tree, &krt6, &s);
d578 1
a578 1
		tmp = RB_PREV(kroute6_tree, &krt6, kn6);
d584 1
a584 1
			tmp = RB_PREV(kroute6_tree, &krt6, kn6);
d611 1
a611 1
kroute6_insert(struct kroute6_node *kr)
d615 1
a615 1
	if ((krm = RB_INSERT(kroute6_tree, &krt6, kr)) != NULL) {
d628 1
a628 1
kroute6_remove(struct kroute6_node *kr)
d632 1
a632 1
	if ((krm = RB_FIND(kroute6_tree, &krt6, kr)) == NULL) {
d640 1
a640 1
		if (RB_REMOVE(kroute6_tree, &krt6, kr) == NULL) {
d646 2
a647 1
			if (RB_INSERT(kroute6_tree, &krt6, kr->next) != NULL) {
d673 1
a673 1
kroute6_clear(void)
d677 2
a678 2
	while ((kr = RB_MIN(kroute6_tree, &krt6)) != NULL)
		kroute6_remove(kr);
a1174 2
		/* Update the ARP table */
		fetcharp();
d1184 1
a1184 1
fetchtable(void)
d1197 1
a1197 1
	mib[6] = 0;	/* rtableid */
d1200 3
d1206 2
d1213 1
a1213 1
		log_warn("sysctl");
d1260 1
a1260 1
fetcharp(void)
d1273 1
a1273 1
	mib[6] = 0;
d1321 1
d1347 4
a1350 1
			if (dispatch_rtmsg_addr(rtm, rti_info) == -1)
d1389 2
a1390 1
dispatch_rtmsg_addr(struct rt_msghdr *rtm, struct sockaddr *rti_info[RTAX_MAX])
d1481 1
a1481 1
			if ((kr = kroute_find(psa_in->sin_addr.s_addr,
d1493 1
a1493 1
			if (kroute_remove(kr) == -1)
d1498 2
a1499 2
			if ((kr6 = kroute6_find(&psa_in6->sin6_addr, prefixlen,
			    prio)) == NULL)
d1511 1
a1511 1
			if (kroute6_remove(kr6) == -1)
d1560 1
a1560 1
		if ((kr = kroute_find(psa_in->sin_addr.s_addr, prefixlen,
d1597 1
a1597 1
			kroute_insert(kr);
d1602 1
a1602 1
		if ((kr6 = kroute6_find(&psa_in6->sin6_addr, prefixlen,
d1647 1
a1647 1
			kroute6_insert(kr6);
d1659 1
d1661 3
a1663 1
	kn = RB_MIN(kroute_tree, &krt);
d1671 1
d1673 3
a1675 1
	kn = kroute_find(prefix, prefixlen, prio);
d1677 1
a1677 1
		kn = RB_NEXT(kroute_tree, &krt, kn);
@


1.24
log
@another simple %i to %d conversion for obviousness
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.23 2012/11/13 22:08:33 florian Exp $	*/
d74 1
d97 4
d128 1
d193 2
d532 113
d696 1
d711 1
d722 3
d1026 2
d1107 39
d1190 1
a1192 2
			if (rtm->rtm_flags & RTF_LLINFO) /* arp cache */
				continue;
d1238 1
d1241 1
a1301 1
			sa = NULL;
d1307 14
d1363 36
@


1.23
log
@pasto in log message
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.22 2012/09/18 08:36:39 reyk Exp $	*/
d843 1
a843 1
		log_warnx("if_newaddr: corresponding if %i not found",
d876 1
a876 1
		log_warnx("if_deladdr: corresponding if %i not found",
@


1.22
log
@sync mask2prefixlen6() with the nicer version from bgpd/kroute.c:
"Instead of doing a poor mans offsetof() implementation change the code
to use an end pointer to compare against. Looks less scary and makes
gcc4 happy. OK henning@@" (bgpd/kroute.c commit 1.182)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.21 2012/09/18 08:29:09 reyk Exp $	*/
d1235 1
a1235 1
				    "mpath route not found");
@


1.21
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.20 2012/09/17 16:43:59 reyk Exp $	*/
d745 1
a745 1
	u_int8_t	 l = 0, i, len;
d748 1
a748 1
	 * sin6_len is the size of the sockaddr so subtract the offset of
d751 3
a753 3
	len = sa_in6->sin6_len -
	    (u_int8_t)(&((struct sockaddr_in6 *)NULL)->sin6_addr);
	for (i = 0; i < len; i++) {
d755 1
a755 1
		switch (sa_in6->sin6_addr.s6_addr[i]) {
@


1.20
log
@Update copyright and my email address in snmpd while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.19 2012/06/10 14:52:46 jsg Exp $	*/
d153 1
a153 1
	if ((kr_state.ks_fd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1) 
d426 1
a426 1
			else 
d489 1
a489 1
	       	if (kr->next != NULL) {
@


1.19
log
@kr_init() now returns void so don't try to return 0
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.18 2012/05/28 20:55:40 joel Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@vantronix.net>
@


1.18
log
@Plug a couple more fd leaks. As part of the fix, make all the *init
functions return void.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.17 2011/04/21 14:55:22 sthen Exp $	*/
a190 2

	return (0);
@


1.17
log
@Add a "filter-routes" option; when set, snmpd asks the kernel not to
send route updates. If you aren't interested in examining routing tables
over SNMP (e.g. if you only use it for sensors or interface stats) this
reduces cpu use during heavy route updates. Makes my full-table bgp
routers happier when a major peer bounces.  ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.16 2011/03/07 07:43:02 henning Exp $	*/
d144 1
a144 1
int
d150 5
a154 9
	if ((kr_state.ks_ifd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
		log_warn("kr_init: ioctl socket");
		return (-1);
	}

	if ((kr_state.ks_fd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1) {
		log_warn("kr_init: route socket");
		return (-1);
	}
d184 1
a184 1
		return (-1);
d186 1
a186 1
		return (-1);
@


1.16
log
@continguous -> contiguous
From: "Anthony J. Bentley" <anthonyjbentley at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.15 2010/10/15 09:27:03 sthen Exp $	*/
d48 2
d164 4
@


1.15
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.14 2010/06/11 10:45:36 jsg Exp $	*/
d783 1
a783 1
			fatalx("non continguous inet6 netmask");
@


1.14
log
@Implement IP-FORWARD-MIB, ipv4 only for now.

ok reyk@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.13 2010/04/27 15:36:46 claudio Exp $	*/
d748 1
a748 1
	 * sin6_len is the size of the sockaddr so substract the offset of
@


1.13
log
@Dumb mistake done twice. First in ospfd then synced to snmpd. rtm_errno
is only valid for messages with an rt_msghdr. So move the check back
where it was before.
Problem found by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.12 2010/04/01 14:42:32 claudio Exp $	*/
d1279 23
@


1.12
log
@Track blackhole and reject flags since the MIB knows about them.
Remove an unneeded stack storage as well.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.11 2010/04/01 13:44:42 claudio Exp $	*/
a1013 2
		if (rtm->rtm_errno)		 /* failed attempts */
			continue;
d1023 2
@


1.11
log
@After syncing kroute with bgpd sync now against ospfd's so that this code
uses only one rtm parser instead of three different ones. Fixes problems
with priorities that were not handled everywhere correctly.
Found by and OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.10 2010/03/31 09:20:23 claudio Exp $	*/
d1069 3
a1071 4
	struct sockaddr_storage	 ss;
	struct sockaddr		*sa;
	struct sockaddr_in	*sa_in, *p_in = (struct sockaddr_in *)&ss;
	struct sockaddr_in6	*sa_in6, *p_in6 = (struct sockaddr_in6 *)&ss;
a1081 1
	bzero(&ss, sizeof(ss));
d1083 1
a1083 1
	if ((sa = rti_info[RTAX_DST]) == NULL)
d1088 4
d1100 1
a1100 1
	switch (sa->sa_family) {
d1102 1
a1102 4
		p_in->sin_family = AF_INET;
		p_in->sin_len = sizeof(struct sockaddr_in);
		p_in->sin_addr.s_addr =
		    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
d1112 1
a1112 1
			    prefixlen_classful(p_in->sin_addr.s_addr);
d1115 1
a1115 5
		p_in6->sin6_family = AF_INET6;
		p_in6->sin6_len = sizeof(struct sockaddr_in6);
		memcpy(&p_in6->sin6_addr,
		    &((struct sockaddr_in6 *)sa)->sin6_addr,
		    sizeof(struct in6_addr));
d1140 1
a1140 1
		switch (ss.ss_family) {
d1143 1
a1143 1
			if ((kr = kroute_find(p_in->sin_addr.s_addr,
d1160 1
a1160 1
			if ((kr6 = kroute6_find(&p_in6->sin6_addr, prefixlen,
d1183 1
a1183 1
	switch (ss.ss_family) {
d1186 1
a1186 1
		if ((kr = kroute_find(p_in->sin_addr.s_addr, prefixlen,
d1212 1
a1212 1
			kr->r.prefix.s_addr = p_in->sin_addr.s_addr;
d1228 1
a1228 1
		if ((kr6 = kroute6_find(&p_in6->sin6_addr, prefixlen,
d1259 1
a1259 1
			memcpy(&kr6->r.prefix, &p_in6->sin6_addr,
@


1.10
log
@Track interface addresses in a AF independent way. This is needed to support
the AF independent MIBs like RFC4292 in the future. Additionally count number
of routes (also needed by some MIBs) and do not track the state of routes
since the MIB do not require it and it is expensive.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.9 2010/03/29 14:52:49 claudio Exp $	*/
d112 1
a112 1
void		if_change(u_short, int, struct if_data *);
d119 2
d122 1
a122 2
int		fetchifs(u_short);
int		fetchtable(void);
d826 2
a827 1
if_change(u_short if_index, int flags, struct if_data *ifd)
d829 1
a829 3
	struct kif		*kif;

	if ((kif = kif_update(if_index, flags, ifd, NULL)) == NULL)
d911 1
d913 2
a914 6
	int			 mib[7];
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct kroute_node	*kr;
d938 2
a939 13
	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		if ((sa = rti_info[RTAX_DST]) == NULL)
			continue;

		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
			continue;
d941 1
a941 47
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("fetchtable");
			free(buf);
			return (-1);
		}

		switch (sa->sa_family) {
		case AF_INET:
			kr->r.prefix.s_addr =
			    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
			sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
			if (rtm->rtm_flags & RTF_STATIC)
				kr->r.flags |= F_STATIC;
			if (rtm->rtm_flags & RTF_DYNAMIC)
				kr->r.flags |= F_DYNAMIC;
			if (sa_in != NULL) {
				if (sa_in->sin_len == 0)
					break;
				kr->r.prefixlen =
				    mask2prefixlen(sa_in->sin_addr.s_addr);
			} else if (rtm->rtm_flags & RTF_HOST)
				kr->r.prefixlen = 32;
			else
				kr->r.prefixlen =
				    prefixlen_classful(kr->r.prefix.s_addr);
			break;
		default:
			free(kr);
			continue;
		}

		kr->r.if_index = rtm->rtm_index;
		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
			case AF_INET:
				kr->r.nexthop.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				break;
			case AF_LINK:
				kr->r.flags |= F_CONNECTED;
				break;
			}
		kroute_insert(kr);
	}

	free(buf);
	return (0);
d949 2
a950 6
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct ifa_msghdr	*ifam;
	struct kif		*kif = NULL;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
d973 2
a974 23
	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		switch (rtm->rtm_type) {
		case RTM_IFINFO:
			bcopy(rtm, &ifm, sizeof ifm);
			sa = (struct sockaddr *)(next + sizeof(ifm));
			get_rtaddrs(ifm.ifm_addrs, sa, rti_info);

			if ((kif = kif_update(ifm.ifm_index,
			    ifm.ifm_flags, &ifm.ifm_data,
			    (struct sockaddr_dl *)rti_info[RTAX_IFP])) == NULL)
				fatal("fetchifs");
			break;
		case RTM_NEWADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);
d976 1
a976 7
			if_newaddr(ifam->ifam_index, rti_info[RTAX_IFA],
			    rti_info[RTAX_NETMASK], rti_info[RTAX_BRD]);
			break;
		}
	}
	free(buf);
	return (0);
a984 5
	char			*next, *lim;
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct ifa_msghdr	*ifam;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
d996 15
a1010 2
	lim = buf + n;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
d1014 5
d1022 1
a1024 6
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

			if (rtm->rtm_errno)		 /* failed attempts */
				continue;

d1029 1
a1029 1
				return;
d1033 2
a1034 2
			if_change(ifm.ifm_index, ifm.ifm_flags,
			    &ifm.ifm_data);
a1040 2
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);
a1049 2
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);
d1062 2
@


1.9
log
@Sync kroute.c code with bgpd so that snmpd is able to track INET6 addrs as
well. First big sync, the interface address tree still needs to be made
AF independent but that will be done in a second step.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.8 2009/06/25 17:02:30 claudio Exp $	*/
d49 3
a51 2
	u_int32_t		 ks_rtseq;
	pid_t			 ks_pid;
a53 1
	struct event		 ks_ev;
a54 1
	u_long			 ks_iflastchange;
a99 1
int			 kif_validate(u_short);
d102 2
a103 2
struct kif_addr		*ka_insert(u_short, struct kif_addr *);
struct kif_addr		*ka_find(struct in_addr *);
d113 4
a116 4
void		if_newaddr(u_short, struct sockaddr_in *, struct sockaddr_in *,
		    struct sockaddr_in *);
void		if_deladdr(u_short, struct sockaddr_in *, struct sockaddr_in *,
		    struct sockaddr_in *);
a174 3
	kr_state.ks_pid = getpid();
	kr_state.ks_rtseq = 1;

d223 6
d288 5
a292 1
	return (memcmp(&a->addr, &b->addr, sizeof(struct in_addr)));
d353 1
d395 1
d466 1
d509 1
d656 2
a657 2
int
kif_validate(u_short if_index)
d659 2
a660 6
	struct kif_node		*kif;

	if ((kif = kif_find(if_index)) == NULL) {
		log_warnx("interface with index %u not found", if_index);
		return (1);
	}
a661 8
	return (kif->k.if_nhreachable);
}

struct kif_addr *
ka_insert(u_short if_index, struct kif_addr *ka)
{
	if (ka->addr.s_addr == INADDR_ANY)
		return (ka);
d663 1
a663 1
	return (RB_INSERT(ka_tree, &kat, ka));
d667 1
a667 1
ka_find(struct in_addr *in)
d671 1
a671 1
	if (in == NULL)
d673 2
a674 1
	ka.addr.s_addr = in->s_addr;
d687 1
a687 1
kr_getaddr(struct in_addr *in)
d689 1
a689 1
	return (ka_find(in));
d693 1
a693 1
kr_getnextaddr(struct in_addr *in)
d697 1
a697 1
	if ((ka = ka_find(in)) == NULL)
d699 1
a699 1
	if (in)
a826 1
	struct kroute_node	*kr, *tkr;
a827 1
	u_int8_t		 reachable;
d829 1
a829 1
	if ((kif = kif_update(if_index, flags, ifd, NULL)) == NULL) {
a830 24
		return;
	}

	reachable = (kif->if_flags & IFF_UP) &&
	    (LINK_STATE_IS_UP(kif->if_link_state) ||
	    (kif->if_link_state == LINK_STATE_UNKNOWN &&
	    kif->if_type != IFT_CARP));

	if (reachable == kif->if_nhreachable)
		return;		/* nothing changed wrt nexthop validity */

	kif->if_nhreachable = reachable;

	/* update redistribute list */
	RB_FOREACH(kr, kroute_tree, &krt) {
		for (tkr = kr; tkr != NULL; tkr = tkr->next) {
			if (tkr->r.if_index == if_index) {
				if (reachable)
					tkr->r.flags &= ~F_DOWN;
				else
					tkr->r.flags |= F_DOWN;
			}
		}
	}
d834 2
a835 2
if_newaddr(u_short if_index, struct sockaddr_in *ifa, struct sockaddr_in *mask,
    struct sockaddr_in *brd)
d840 1
a840 1
	if (ifa == NULL || ifa->sin_family != AF_INET)
d847 8
a854 5
	if (ka_find(&ifa->sin_addr) != NULL)
		return;
	if ((ka = calloc(1, sizeof(struct kif_addr))) == NULL)
		fatal("if_newaddr");
	ka->addr = ifa->sin_addr;
d856 1
a856 1
		ka->mask = mask->sin_addr;
d858 1
a858 1
		ka->mask.s_addr = INADDR_NONE;
d860 1
a860 1
		ka->dstbrd = brd->sin_addr;
d862 1
a862 1
		ka->dstbrd.s_addr = INADDR_NONE;
a863 2
	TAILQ_INSERT_TAIL(&kif->addrs, ka, entry);
	ka_insert(if_index, ka);
d867 2
a868 2
if_deladdr(u_short if_index, struct sockaddr_in *ifa, struct sockaddr_in *mask,
    struct sockaddr_in *brd)
d873 1
a873 1
	if (ifa == NULL || ifa->sin_family != AF_INET)
d876 1
a876 1
		log_warnx("if_newaddr: corresponding if %i not found",
d880 1
a880 1
	if ((ka = ka_find(&ifa->sin_addr)) == NULL)
a1051 6

			kif->if_nhreachable = (kif->if_flags & IFF_UP) &&
			    (LINK_STATE_IS_UP(ifm.ifm_data.ifi_link_state) ||
			    (ifm.ifm_data.ifi_link_state ==
			    LINK_STATE_UNKNOWN &&
			    ifm.ifm_data.ifi_type != IFT_CARP));
d1061 2
a1062 4
			if_newaddr(ifam->ifam_index,
			    (struct sockaddr_in *)rti_info[RTAX_IFA],
			    (struct sockaddr_in *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in *)rti_info[RTAX_BRD]);
d1127 2
a1128 4
			if_deladdr(ifam->ifam_index,
			    (struct sockaddr_in *)rti_info[RTAX_IFA],
			    (struct sockaddr_in *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in *)rti_info[RTAX_BRD]);
d1138 2
a1139 4
			if_newaddr(ifam->ifam_index,
			    (struct sockaddr_in *)rti_info[RTAX_IFA],
			    (struct sockaddr_in *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in *)rti_info[RTAX_BRD]);
@


1.8
log
@Another kroute.c needing RTM_VERSION checks. Looked over by sthen@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.7 2009/06/05 22:40:24 chris Exp $	*/
d64 6
d76 7
a82 4
int			 kroute_compare(struct kroute_node *, struct kroute_node *);
struct kroute_node	*kroute_find(in_addr_t, u_int8_t);
struct kroute_node	*kroute_match(in_addr_t);
struct kroute_node	*kroute_matchgw(struct kroute_node *, struct in_addr);
d87 8
a94 2
int			 kif_init(void);
int			 kif_compare(struct kif_node *, struct kif_node *);
d108 18
a125 20
u_int16_t		 rtlabel_name2id(const char *);
const char		*rtlabel_id2name(u_int16_t);
void			 rtlabel_unref(u_int16_t);

int			 protect_lo(void);
u_int8_t		 prefixlen_classful(in_addr_t);
u_int8_t		 mask2prefixlen(in_addr_t);
in_addr_t		 prefixlen2mask(u_int8_t);
void			 get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
void			 if_change(u_short, int, struct if_data *);
void			 if_newaddr(u_short, struct sockaddr_in *, struct sockaddr_in *,
			    struct sockaddr_in *);
void			 if_deladdr(u_short, struct sockaddr_in *, struct sockaddr_in *,
			    struct sockaddr_in *);
void			 if_announce(void *);

int			 send_rtmsg(int, int, struct kroute *);
void			 dispatch_rtmsg(int, short, void *);
int			 fetchifs(u_short);
int			 fetchtable(void);
d131 4
a143 11
kif_init(void)
{
	RB_INIT(&kit);

	if (fetchifs(0) == -1)
		return (-1);

	return (0);
}

int
a148 3
	if (kif_init() == -1)
		return (-1);

d181 3
d185 2
a189 3
	if (protect_lo() == -1)
		return (-1);

d240 35
d292 1
a292 1
kroute_find(in_addr_t prefix, u_int8_t prefixlen)
d295 1
d299 1
d301 12
a312 1
	return (RB_FIND(kroute_tree, &krt, &s));
d316 1
a316 1
kroute_matchgw(struct kroute_node *kr, struct in_addr nh)
d320 5
a324 1
	nexthop = nh.s_addr;
d341 1
a341 5
		/*
		 * Multipath route, add at end of list and clone the
		 * ospfd inserted flag.
		 */
		kr->r.flags |= krm->r.flags & F_OSPFD_INSERTED;
a345 7
	} else
		krm = kr;

	if (!(kr->r.flags & F_KERNEL)) {
		/* don't validate or redistribute ospf route */
		kr->r.flags &= ~F_DOWN;
		return (0);
a347 5
	if (kif_validate(kr->r.if_index))
		kr->r.flags &= ~F_DOWN;
	else
		kr->r.flags |= F_DOWN;

a388 2
	rtlabel_unref(kr->r.rtlabel);

d402 112
d519 3
d533 1
a533 4
	if (if_index == 0)
		kn = RB_MIN(kif_tree, &kit);
	else
		kn = kif_find(if_index);
a544 5
	if (if_index == 0) {
		kn = RB_MIN(kif_tree, &kit);
		return (&kn->k);
	}

d547 2
a548 1
	kn = RB_NEXT(kif_tree, &kit, kn);
a659 18
struct kroute_node *
kroute_match(in_addr_t key)
{
	int			 i;
	struct kroute_node	*kr;

	/* we will never match the default route */
	for (i = 32; i > 0; i--)
		if ((kr = kroute_find(key & prefixlen2mask(i), i)) != NULL)
			return (kr);

	/* if we don't have a match yet, try to find a default route */
	if ((kr = kroute_find(0, 0)) != NULL)
			return (kr);

	return (NULL);
}

d674 2
d691 1
a691 10
	struct kif_addr	*ka;

	if (in == NULL)
		ka = RB_MIN(ka_tree, &kat);
	else
		ka = ka_find(in);
	if (ka == NULL)
		return (NULL);

	return (ka);
a698 3
	if (in == NULL)
		return (RB_MIN(ka_tree, &kat));

d701 2
a702 3
	ka = RB_NEXT(ka_tree, &kat, ka);
	if (ka == NULL)
		return (NULL);
a707 20
int
protect_lo(void)
{
	struct kroute_node	*kr;

	/* special protection for 127/8 */
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
		log_warn("protect_lo");
		return (-1);
	}
	kr->r.prefix.s_addr = htonl(INADDR_LOOPBACK);
	kr->r.prefixlen = 8;
	kr->r.flags = F_KERNEL|F_CONNECTED;

	if (RB_INSERT(kroute_tree, &krt, kr) != NULL)
		free(kr);	/* kernel route already there, no problem */

	return (0);
}

d743 66
a808 2
#define	ROUNDUP(a, size)	\
    (((a) & ((size) - 1)) ? (1 + ((a) | ((size) - 1))) : (a))
d819 1
a819 1
			    ROUNDUP(sa->sa_len, sizeof(long)));
a847 5
#ifdef notyet
	/* notify ospfe about interface link state */
	main_imsg_compose_ospfe(IMSG_IFINFO, 0, kif, sizeof(struct kif));
#endif

a943 1
	struct sockaddr_rtlabel	*label;
a987 2
		kr->r.flags = F_KERNEL;

a996 2
			if (rtm->rtm_flags & RTF_PROTO1)
				kr->r.flags |= F_BGPD_INSERTED;
a1023 6

		if ((label = (struct sockaddr_rtlabel *)
		    rti_info[RTAX_LABEL]) != NULL) {
			kr->r.rtlabel =
			    rtlabel_name2id(label->sr_label);
		}
a1115 7
	struct sockaddr_in	*sa_in;
	struct sockaddr_rtlabel	*label;
	struct kroute_node	*kr, *okr;
	struct in_addr		 prefix, nexthop;
	u_int8_t		 prefixlen;
	int			 flags, mpath;
	u_short			 if_index = 0;
d1133 4
a1136 8
		prefix.s_addr = 0;
		prefixlen = 0;
		flags = F_KERNEL;
		nexthop.s_addr = 0;
		mpath = 0;

		if (rtm->rtm_type == RTM_ADD || rtm->rtm_type == RTM_CHANGE ||
		    rtm->rtm_type == RTM_DELETE) {
d1140 1
a1140 1
			if (rtm->rtm_tableid != 0)
d1143 1
a1143 1
			if (rtm->rtm_pid == kr_state.ks_pid) /* caused by us */
d1146 1
a1146 139
			if (rtm->rtm_errno)		/* failed attempts... */
				continue;

			if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
				continue;

#ifdef RTF_MPATH
			if (rtm->rtm_flags & RTF_MPATH)
				mpath = 1;
#endif
			switch (sa->sa_family) {
			case AF_INET:
				prefix.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				sa_in = (struct sockaddr_in *)
				    rti_info[RTAX_NETMASK];
				if (sa_in != NULL) {
					if (sa_in->sin_len != 0)
						prefixlen = mask2prefixlen(
						    sa_in->sin_addr.s_addr);
				} else if (rtm->rtm_flags & RTF_HOST)
					prefixlen = 32;
				else
					prefixlen =
					    prefixlen_classful(prefix.s_addr);
				if (rtm->rtm_flags & RTF_STATIC)
					flags |= F_STATIC;
				if (rtm->rtm_flags & RTF_DYNAMIC)
					flags |= F_DYNAMIC;
				if (rtm->rtm_flags & RTF_PROTO1)
					flags |= F_BGPD_INSERTED;
				break;
			default:
				continue;
			}

			if_index = rtm->rtm_index;
			if ((sa = rti_info[RTAX_GATEWAY]) != NULL) {
				switch (sa->sa_family) {
				case AF_INET:
					nexthop.s_addr = ((struct
					    sockaddr_in *)sa)->sin_addr.s_addr;
					break;
				case AF_LINK:
					flags |= F_CONNECTED;
					break;
				}
			}
		}

		switch (rtm->rtm_type) {
		case RTM_ADD:
		case RTM_CHANGE:
			if (nexthop.s_addr == 0 && !(flags & F_CONNECTED)) {
				log_warnx("dispatch_rtmsg no nexthop for %s/%u",
				    inet_ntoa(prefix), prefixlen);
				continue;
			}

			if ((okr = kroute_find(prefix.s_addr, prefixlen)) !=
			    NULL) {
				/* just add new multipath routes */
				if (mpath && rtm->rtm_type == RTM_ADD)
					goto add;
				/* get the correct route */
				kr = okr;
				if (mpath && (kr = kroute_matchgw(okr,
				    nexthop)) == NULL) {
					log_warnx("dispatch_rtmsg mpath route"
					    " not found");
					/* add routes we missed out earlier */
					goto add;
				}

				kr->r.nexthop.s_addr = nexthop.s_addr;
				kr->r.flags = flags;
				kr->r.if_index = if_index;
				kr->r.ticks = smi_getticks();

				rtlabel_unref(kr->r.rtlabel);
				kr->r.rtlabel = 0;
				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL) {
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);
				}

				if (kif_validate(kr->r.if_index))
					kr->r.flags &= ~F_DOWN;
				else
					kr->r.flags |= F_DOWN;
			} else {
add:
				if ((kr = calloc(1,
				    sizeof(struct kroute_node))) == NULL) {
					log_warn("dispatch_rtmsg");
					return;
				}
				kr->r.prefix.s_addr = prefix.s_addr;
				kr->r.prefixlen = prefixlen;
				kr->r.nexthop.s_addr = nexthop.s_addr;
				kr->r.flags = flags;
				kr->r.if_index = if_index;
				kr->r.ticks = smi_getticks();

				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL) {
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);
				}

				kroute_insert(kr);
			}
			break;
		case RTM_DELETE:
			if ((kr = kroute_find(prefix.s_addr, prefixlen)) ==
			    NULL)
				continue;
			if (!(kr->r.flags & F_KERNEL))
				continue;
			/* get the correct route */
			okr = kr;
			if (mpath &&
			    (kr = kroute_matchgw(kr, nexthop)) == NULL) {
				log_warnx("dispatch_rtmsg mpath route"
				    " not found");
				return;
			}
#ifdef notyet
			/*
			 * last route is getting removed request the
			 * ospf route from the RDE to insert instead
			 */
			if (okr == kr && kr->next == NULL &&
			    kr->r.flags & F_OSPFD_INSERTED)
				main_imsg_compose_rde(IMSG_KROUTE_GET, 0,
				    &kr->r, sizeof(struct kroute));
#endif
			if (kroute_remove(kr) == -1)
d1190 2
a1191 2
u_int16_t
rtlabel_name2id(const char *name)
d1193 208
a1400 2
	return (0);
}
d1402 4
a1405 5
const char *
rtlabel_id2name(u_int16_t id)
{
	return ("");
}
d1407 1
a1407 4
void
rtlabel_unref(u_int16_t id)
{
	/* not used */
@


1.7
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.6 2008/01/16 09:51:15 reyk Exp $	*/
d815 2
d991 2
@


1.6
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.5 2007/12/29 09:24:43 reyk Exp $	*/
d815 1
a815 1
		sa = (struct sockaddr *)(rtm + 1);
d998 1
a998 1
			sa = (struct sockaddr *)(rtm + 1);
@


1.5
log
@add the IP-MIB ipAddrTable.  it requires to encode the ipv4 addresses
in the OIDs as the table index.  the next step is to simplify the
common mib implementation regarding the special requirements of these
strange snmp tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.4 2007/12/28 16:59:31 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 Reyk Floeter <reyk@@vantronix.net>
@


1.4
log
@split code handling the "structure of management information" and the
"message processing subsystem" into separate files smi.c and mps.c
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.3 2007/12/28 15:33:37 reyk Exp $	*/
d88 5
d105 2
d122 4
d244 6
a277 1

d380 1
a380 1
		kn = RB_ROOT(&kit);
d395 1
a395 1
		kn = RB_ROOT(&kit);
d440 1
a440 1
		free(ka);
d531 58
d718 2
d733 22
d1152 13
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.2 2007/12/06 04:10:46 deraadt Exp $	*/
d407 1
a407 1
	kr_state.ks_iflastchange = mps_getticks();
d429 1
a429 1
	kr_state.ks_iflastchange = mps_getticks();
d442 1
a442 1
	kr_state.ks_iflastchange = mps_getticks();
d459 1
a459 1
	kif->k.if_ticks = mps_getticks();
d986 1
a986 1
				kr->r.ticks = mps_getticks();
d1012 1
a1012 1
				kr->r.ticks = mps_getticks();
@


1.2
log
@correct bizzare function definition
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.1 2007/12/05 09:22:44 reyk Exp $	*/
d451 1
a451 1
        struct ifreq		 ifr;
d640 2
a641 1
		log_warnx("if_newaddr: corresponding if %i not found", if_index);
@


1.1
log
@Start working on snmpd(8) and snmpctl(8), a lightweight SNMP implementation
for OpenBSD.  SNMP is a necessary evil.  This is work in progress, don't
expect too much from it yet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.4 2007/11/13 00:46:51 reyk Exp $	*/
d1083 2
a1084 2
const char
*rtlabel_id2name(u_int16_t id)
@

