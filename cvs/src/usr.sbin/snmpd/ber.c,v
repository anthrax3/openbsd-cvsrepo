head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.8
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.6
	OPENBSD_5_0:1.23.0.4
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.31
date	2016.03.05.03.31.36;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	peHE8yJ7qz3xmeRH;

1.30
date	2015.12.05.06.42.18;	author mmcc;	state Exp;
branches;
next	1.29;
commitid	7b4R1o84KuZAdiL5;

1.29
date	2015.02.12.00.30.38;	author pelikan;	state Exp;
branches;
next	1.28;
commitid	fse1E86gItb03KjE;

1.28
date	2015.01.16.00.05.13;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	khLbW7SmDyckNaAs;

1.27
date	2014.04.25.06.57.11;	author blambert;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.14.12.55.10;	author blambert;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.01.12.41.47;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2012.09.17.16.30.34;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.20.08.30.13;	author martinh;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.14.13.46.08;	author martinh;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.08.17.52.47;	author martinh;	state Exp;
branches;
next	1.20;

1.20
date	2010.02.24.14.09.45;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.16.22.17.53;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.12.15.28.32;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.04.18.03.07;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.03.18.41.41;	author aschrijver;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.29.16.00.22;	author ragge;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.18.16.57.58;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2008.03.18.14.53.07;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.14.15.22.22;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.12.17.48.27;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2008.03.12.17.41.38;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.12.14.30.11;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.12.13.09.12;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.12.13.06.09;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.09.13.03.01;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.03.14.44.08;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.07.10.08.40;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.07.09.50.51;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.05.23.29.19;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.05.09.22.44;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.31
log
@mirror memset changes to ber.c made in ldapd (these 3 daemons
have subtly modified copies of the file)
from rob pierce
@
text
@/*	$OpenBSD: ber.c,v 1.30 2015/12/05 06:42:18 mmcc Exp $ */

/*
 * Copyright (c) 2007, 2012 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2006, 2007 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2006, 2007 Marc Balmer <mbalmer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <err.h>	/* XXX for debug output */
#include <stdio.h>	/* XXX for debug output */
#include <string.h>
#include <unistd.h>
#include <stdarg.h>

#include "ber.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

#define BER_TYPE_CONSTRUCTED	0x20	/* otherwise primitive */
#define BER_TYPE_SINGLE_MAX	30
#define BER_TAG_MASK		0x1f
#define BER_TAG_MORE		0x80	/* more subsequent octets */
#define BER_TAG_TYPE_MASK	0x7f
#define BER_CLASS_SHIFT		6

static int	ber_dump_element(struct ber *ber, struct ber_element *root);
static void	ber_dump_header(struct ber *ber, struct ber_element *root);
static void	ber_putc(struct ber *ber, u_char c);
static void	ber_write(struct ber *ber, void *buf, size_t len);
static ssize_t	get_id(struct ber *b, unsigned long *tag, int *class,
    int *cstruct);
static ssize_t	get_len(struct ber *b, ssize_t *len);
static ssize_t	ber_read_element(struct ber *ber, struct ber_element *elm);
static ssize_t	ber_readbuf(struct ber *b, void *buf, size_t nbytes);
static ssize_t	ber_getc(struct ber *b, u_char *c);
static ssize_t	ber_read(struct ber *ber, void *buf, size_t len);

#ifdef DEBUG
#define DPRINTF(...)	printf(__VA_ARGS__)
#else
#define DPRINTF(...)	do { } while (0)
#endif

struct ber_element *
ber_get_element(unsigned long encoding)
{
	struct ber_element *elm;

	if ((elm = calloc(1, sizeof(*elm))) == NULL)
		return NULL;

	elm->be_encoding = encoding;
	ber_set_header(elm, BER_CLASS_UNIVERSAL, BER_TYPE_DEFAULT);

	return elm;
}

void
ber_set_header(struct ber_element *elm, int class, unsigned long type)
{
	elm->be_class = class & BER_CLASS_MASK;
	if (type == BER_TYPE_DEFAULT)
		type = elm->be_encoding;
	elm->be_type = type;
}

void
ber_link_elements(struct ber_element *prev, struct ber_element *elm)
{
	if (prev != NULL) {
		if ((prev->be_encoding == BER_TYPE_SEQUENCE ||
		    prev->be_encoding == BER_TYPE_SET) &&
		    prev->be_sub == NULL)
			prev->be_sub = elm;
		else
			prev->be_next = elm;
	}
}

struct ber_element *
ber_unlink_elements(struct ber_element *prev)
{
	struct ber_element *elm;

	if ((prev->be_encoding == BER_TYPE_SEQUENCE ||
	    prev->be_encoding == BER_TYPE_SET) &&
	    prev->be_sub != NULL) {
		elm = prev->be_sub;
		prev->be_sub = NULL;
	} else {
		elm = prev->be_next;
		prev->be_next = NULL;
	}

	return (elm);
}

void
ber_replace_elements(struct ber_element *prev, struct ber_element *new)
{
	struct ber_element *ber, *next;

	ber = ber_unlink_elements(prev);
	next = ber_unlink_elements(ber);
	ber_link_elements(new, next);
	ber_link_elements(prev, new);

	/* cleanup old element */
	ber_free_elements(ber);
}

struct ber_element *
ber_add_sequence(struct ber_element *prev)
{
	struct ber_element *elm;

	if ((elm = ber_get_element(BER_TYPE_SEQUENCE)) == NULL)
		return NULL;

	ber_link_elements(prev, elm);

	return elm;
}

struct ber_element *
ber_add_set(struct ber_element *prev)
{
	struct ber_element *elm;

	if ((elm = ber_get_element(BER_TYPE_SET)) == NULL)
		return NULL;

	ber_link_elements(prev, elm);

	return elm;
}

struct ber_element *
ber_add_enumerated(struct ber_element *prev, long long val)
{
	struct ber_element *elm;
	u_int i, len = 0;
	u_char cur, last = 0;

	if ((elm = ber_get_element(BER_TYPE_ENUMERATED)) == NULL)
		return NULL;

	elm->be_numeric = val;

	for (i = 0; i < sizeof(long long); i++) {
		cur = val & 0xff;
		if (cur != 0 && cur != 0xff)
			len = i;
		if ((cur == 0 && last & 0x80) ||
		    (cur == 0xff && (last & 0x80) == 0))
			len = i;
		val >>= 8;
		last = cur;
	}
	elm->be_len = len + 1;

	ber_link_elements(prev, elm);

	return elm;
}

struct ber_element *
ber_add_integer(struct ber_element *prev, long long val)
{
	struct ber_element *elm;
	u_int i, len = 0;
	u_char cur, last = 0;

	if ((elm = ber_get_element(BER_TYPE_INTEGER)) == NULL)
		return NULL;

	elm->be_numeric = val;

	for (i = 0; i < sizeof(long long); i++) {
		cur = val & 0xff;
		if (cur != 0 && cur != 0xff)
			len = i;
		if ((cur == 0 && last & 0x80) ||
		    (cur == 0xff && (last & 0x80) == 0))
			len = i;
		val >>= 8;
		last = cur;
	}
	elm->be_len = len + 1;

	ber_link_elements(prev, elm);

	return elm;
}

int
ber_get_integer(struct ber_element *elm, long long *n)
{
	if (elm->be_encoding != BER_TYPE_INTEGER)
		return -1;

	*n = elm->be_numeric;
	return 0;
}

int
ber_get_enumerated(struct ber_element *elm, long long *n)
{
	if (elm->be_encoding != BER_TYPE_ENUMERATED)
		return -1;

	*n = elm->be_numeric;
	return 0;
}


struct ber_element *
ber_add_boolean(struct ber_element *prev, int bool)
{
	struct ber_element *elm;

	if ((elm = ber_get_element(BER_TYPE_BOOLEAN)) == NULL)
		return NULL;

	elm->be_numeric = bool ? 0xff : 0;
	elm->be_len = 1;

	ber_link_elements(prev, elm);

	return elm;
}

int
ber_get_boolean(struct ber_element *elm, int *b)
{
	if (elm->be_encoding != BER_TYPE_BOOLEAN)
		return -1;

	*b = !(elm->be_numeric == 0);
	return 0;
}

struct ber_element *
ber_add_string(struct ber_element *prev, const char *string)
{
	return ber_add_nstring(prev, string, strlen(string));
}

struct ber_element *
ber_add_nstring(struct ber_element *prev, const char *string0, size_t len)
{
	struct ber_element *elm;
	char *string;

	if ((string = calloc(1, len + 1)) == NULL)
		return NULL;
	if ((elm = ber_get_element(BER_TYPE_OCTETSTRING)) == NULL) {
		free(string);
		return NULL;
	}

	bcopy(string0, string, len);
	elm->be_val = string;
	elm->be_len = len;
	elm->be_free = 1;		/* free string on cleanup */

	ber_link_elements(prev, elm);

	return elm;
}

int
ber_get_string(struct ber_element *elm, char **s)
{
	if (elm->be_encoding != BER_TYPE_OCTETSTRING)
		return -1;

	*s = elm->be_val;
	return 0;
}

int
ber_get_nstring(struct ber_element *elm, void **p, size_t *len)
{
	if (elm->be_encoding != BER_TYPE_OCTETSTRING)
		return -1;

	*p = elm->be_val;
	*len = elm->be_len;
	return 0;
}

struct ber_element *
ber_add_bitstring(struct ber_element *prev, const void *v0, size_t len)
{
	struct ber_element *elm;
	void *v;

	if ((v = calloc(1, len)) == NULL)
		return NULL;
	if ((elm = ber_get_element(BER_TYPE_BITSTRING)) == NULL) {
		free(v);
		return NULL;
	}

	bcopy(v0, v, len);
	elm->be_val = v;
	elm->be_len = len;
	elm->be_free = 1;		/* free string on cleanup */

	ber_link_elements(prev, elm);

	return elm;
}

int
ber_get_bitstring(struct ber_element *elm, void **v, size_t *len)
{
	if (elm->be_encoding != BER_TYPE_BITSTRING)
		return -1;

	*v = elm->be_val;
	*len = elm->be_len;
	return 0;
}

struct ber_element *
ber_add_null(struct ber_element *prev)
{
	struct ber_element *elm;

	if ((elm = ber_get_element(BER_TYPE_NULL)) == NULL)
		return NULL;

	ber_link_elements(prev, elm);

	return elm;
}

int
ber_get_null(struct ber_element *elm)
{
	if (elm->be_encoding != BER_TYPE_NULL)
		return -1;

	return 0;
}

struct ber_element *
ber_add_eoc(struct ber_element *prev)
{
	struct ber_element *elm;

	if ((elm = ber_get_element(BER_TYPE_EOC)) == NULL)
		return NULL;

	ber_link_elements(prev, elm);

	return elm;
}

int
ber_get_eoc(struct ber_element *elm)
{
	if (elm->be_encoding != BER_TYPE_EOC)
		return -1;

	return 0;
}

size_t
ber_oid2ber(struct ber_oid *o, u_int8_t *buf, size_t len)
{
	u_int32_t	 v;
	u_int		 i, j = 0, k;

	if (o->bo_n < BER_MIN_OID_LEN || o->bo_n > BER_MAX_OID_LEN ||
	    o->bo_id[0] > 2 || o->bo_id[1] > 40)
		return (0);

	v = (o->bo_id[0] * 40) + o->bo_id[1];
	for (i = 2, j = 0; i <= o->bo_n; v = o->bo_id[i], i++) {
		for (k = 28; k >= 7; k -= 7) {
			if (v >= (u_int)(1 << k)) {
				if (len)
					buf[j] = v >> k | BER_TAG_MORE;
				j++;
			}
		}
		if (len)
			buf[j] = v & BER_TAG_TYPE_MASK;
		j++;
	}

	return (j);
}

int
ber_string2oid(const char *oidstr, struct ber_oid *o)
{
	char			*sp, *p, str[BUFSIZ];
	const char		*errstr;

	if (strlcpy(str, oidstr, sizeof(str)) >= sizeof(str))
		return (-1);
	memset(o, 0, sizeof(*o));

	/* Parse OID strings in the common forms n.n.n, n_n_n_n, or n-n-n */
	for (p = sp = str; p != NULL; sp = p) {
		if ((p = strpbrk(p, "._-")) != NULL)
			*p++ = '\0';
		o->bo_id[o->bo_n++] = strtonum(sp, 0, UINT_MAX, &errstr);
		if (errstr || o->bo_n > BER_MAX_OID_LEN)
			return (-1);
	}

	return (0);
}

struct ber_element *
ber_add_oid(struct ber_element *prev, struct ber_oid *o)
{
	struct ber_element	*elm;
	u_int8_t		*buf;
	size_t			 len;

	if ((elm = ber_get_element(BER_TYPE_OBJECT)) == NULL)
		return (NULL);

	if ((len = ber_oid2ber(o, NULL, 0)) == 0)
		goto fail;

	if ((buf = calloc(1, len)) == NULL)
		goto fail;

	elm->be_val = buf;
	elm->be_len = len;
	elm->be_free = 1;

	if (ber_oid2ber(o, buf, len) != len)
		goto fail;

	ber_link_elements(prev, elm);

	return (elm);

 fail:
	ber_free_elements(elm);
	return (NULL);
}

struct ber_element *
ber_add_noid(struct ber_element *prev, struct ber_oid *o, int n)
{
	struct ber_oid		 no;

	if (n > BER_MAX_OID_LEN)
		return (NULL);
	no.bo_n = n;
	bcopy(&o->bo_id, &no.bo_id, sizeof(no.bo_id));

	return (ber_add_oid(prev, &no));
}

struct ber_element *
ber_add_oidstring(struct ber_element *prev, const char *oidstr)
{
	struct ber_oid		 o;

	if (ber_string2oid(oidstr, &o) == -1)
		return (NULL);

	return (ber_add_oid(prev, &o));
}

int
ber_get_oid(struct ber_element *elm, struct ber_oid *o)
{
	u_int8_t	*buf;
	size_t		 len, i = 0, j = 0;

	if (elm->be_encoding != BER_TYPE_OBJECT)
		return (-1);

	buf = elm->be_val;
	len = elm->be_len;

	if (!buf[i])
		return (-1);

	memset(o, 0, sizeof(*o));
	o->bo_id[j++] = buf[i] / 40;
	o->bo_id[j++] = buf[i++] % 40;
	for (; i < len && j < BER_MAX_OID_LEN; i++) {
		o->bo_id[j] = (o->bo_id[j] << 7) + (buf[i] & ~0x80);
		if (buf[i] & 0x80)
			continue;
		j++;
	}
	o->bo_n = j;

	return (0);
}

struct ber_element *
ber_printf_elements(struct ber_element *ber, char *fmt, ...)
{
	va_list			 ap;
	int			 d, class;
	size_t			 len;
	unsigned long		 type;
	long long		 i;
	char			*s;
	void			*p;
	struct ber_oid		*o;
	struct ber_element	*sub = ber, *e;

	va_start(ap, fmt);
	while (*fmt) {
		switch (*fmt++) {
		case 'B':
			p = va_arg(ap, void *);
			len = va_arg(ap, size_t);
			if ((ber = ber_add_bitstring(ber, p, len)) == NULL)
				goto fail;
			break;
		case 'b':
			d = va_arg(ap, int);
			if ((ber = ber_add_boolean(ber, d)) == NULL)
				goto fail;
			break;
		case 'd':
			d = va_arg(ap, int);
			if ((ber = ber_add_integer(ber, d)) == NULL)
				goto fail;
			break;
		case 'e':
			e = va_arg(ap, struct ber_element *);
			ber_link_elements(ber, e);
			break;
		case 'E':
			i = va_arg(ap, long long);
			if ((ber = ber_add_enumerated(ber, i)) == NULL)
				goto fail;
			break;
		case 'i':
			i = va_arg(ap, long long);
			if ((ber = ber_add_integer(ber, i)) == NULL)
				goto fail;
			break;
		case 'O':
			o = va_arg(ap, struct ber_oid *);
			if ((ber = ber_add_oid(ber, o)) == NULL)
				goto fail;
			break;
		case 'o':
			s = va_arg(ap, char *);
			if ((ber = ber_add_oidstring(ber, s)) == NULL)
				goto fail;
			break;
		case 's':
			s = va_arg(ap, char *);
			if ((ber = ber_add_string(ber, s)) == NULL)
				goto fail;
			break;
		case 't':
			class = va_arg(ap, int);
			type = va_arg(ap, unsigned long);
			ber_set_header(ber, class, type);
			break;
		case 'x':
			s = va_arg(ap, char *);
			len = va_arg(ap, size_t);
			if ((ber = ber_add_nstring(ber, s, len)) == NULL)
				goto fail;
			break;
		case '0':
			if ((ber = ber_add_null(ber)) == NULL)
				goto fail;
			break;
		case '{':
			if ((ber = sub = ber_add_sequence(ber)) == NULL)
				goto fail;
			break;
		case '(':
			if ((ber = sub = ber_add_set(ber)) == NULL)
				goto fail;
			break;
		case '}':
		case ')':
			ber = sub;
			break;
		case '.':
			if ((e = ber_add_eoc(ber)) == NULL)
				goto fail;
			ber = e;
			break;
		default:
			break;
		}
	}
	va_end(ap);

	return (ber);
 fail:
	ber_free_elements(ber);
	return (NULL);
}

int
ber_scanf_elements(struct ber_element *ber, char *fmt, ...)
{
#define _MAX_SEQ		 128
	va_list			 ap;
	int			*d, level = -1;
	unsigned long		*t;
	long long		*i, l;
	void			**ptr;
	size_t			*len, ret = 0, n = strlen(fmt);
	char			**s;
	off_t			*pos;
	struct ber_oid		*o;
	struct ber_element	*parent[_MAX_SEQ], **e;

	memset(parent, 0, sizeof(struct ber_element *) * _MAX_SEQ);

	va_start(ap, fmt);
	while (*fmt) {
		switch (*fmt++) {
		case 'B':
			ptr = va_arg(ap, void **);
			len = va_arg(ap, size_t *);
			if (ber_get_bitstring(ber, ptr, len) == -1)
				goto fail;
			ret++;
			break;
		case 'b':
			d = va_arg(ap, int *);
			if (ber_get_boolean(ber, d) == -1)
				goto fail;
			ret++;
			break;
		case 'd':
			d = va_arg(ap, int *);
			if (ber_get_integer(ber, &l) == -1)
				goto fail;
			*d = l;
			ret++;
			break;
		case 'e':
			e = va_arg(ap, struct ber_element **);
			*e = ber;
			ret++;
			continue;
		case 'E':
			i = va_arg(ap, long long *);
			if (ber_get_enumerated(ber, i) == -1)
				goto fail;
			ret++;
			break;
		case 'i':
			i = va_arg(ap, long long *);
			if (ber_get_integer(ber, i) == -1)
				goto fail;
			ret++;
			break;
		case 'o':
			o = va_arg(ap, struct ber_oid *);
			if (ber_get_oid(ber, o) == -1)
				goto fail;
			ret++;
			break;
		case 'S':
			ret++;
			break;
		case 's':
			s = va_arg(ap, char **);
			if (ber_get_string(ber, s) == -1)
				goto fail;
			ret++;
			break;
		case 't':
			d = va_arg(ap, int *);
			t = va_arg(ap, unsigned long *);
			*d = ber->be_class;
			*t = ber->be_type;
			ret++;
			continue;
		case 'x':
			ptr = va_arg(ap, void **);
			len = va_arg(ap, size_t *);
			if (ber_get_nstring(ber, ptr, len) == -1)
				goto fail;
			ret++;
			break;
		case '0':
			if (ber->be_encoding != BER_TYPE_NULL)
				goto fail;
			ret++;
			break;
		case '.':
			if (ber->be_encoding != BER_TYPE_EOC)
				goto fail;
			ret++;
			break;
		case 'p':
			pos = va_arg(ap, off_t *);
			*pos = ber_getpos(ber);
			ret++;
			continue;
		case '{':
		case '(':
			if (ber->be_encoding != BER_TYPE_SEQUENCE &&
			    ber->be_encoding != BER_TYPE_SET)
				goto fail;
			if (ber->be_sub == NULL || level >= _MAX_SEQ-1)
				goto fail;
			parent[++level] = ber;
			ber = ber->be_sub;
			ret++;
			continue;
		case '}':
		case ')':
			if (parent[level] == NULL)
				goto fail;
			ber = parent[level--];
			ret++;
			break;
		default:
			goto fail;
		}

		if (ber->be_next == NULL)
			continue;
		ber = ber->be_next;
	}
	va_end(ap);
	return (ret == n ? 0 : -1);

 fail:
	va_end(ap);
	return (-1);

}

/*
 * write ber elements to the socket
 *
 * params:
 *	ber	holds the socket
 *	root	fully populated element tree
 *
 * returns:
 *      >=0     number of bytes written
 *	-1	on failure and sets errno
 */
int
ber_write_elements(struct ber *ber, struct ber_element *root)
{
	size_t len;

	/* calculate length because only the definite form is required */
	len = ber_calc_len(root);
	DPRINTF("write ber element of %zd bytes length\n", len);

	if (ber->br_wbuf != NULL && ber->br_wbuf + len > ber->br_wend) {
		free(ber->br_wbuf);
		ber->br_wbuf = NULL;
	}
	if (ber->br_wbuf == NULL) {
		if ((ber->br_wbuf = malloc(len)) == NULL)
			return -1;
		ber->br_wend = ber->br_wbuf + len;
	}

	/* reset write pointer */
	ber->br_wptr = ber->br_wbuf;

	if (ber_dump_element(ber, root) == -1)
		return -1;

	/* XXX this should be moved to a different function */
	if (ber->fd != -1)
		return write(ber->fd, ber->br_wbuf, len);

	return (len);
}

/*
 * read ber elements from the socket
 *
 * params:
 *	ber	holds the socket and lot more
 *	root	if NULL, build up an element tree from what we receive on
 *		the wire. If not null, use the specified encoding for the
 *		elements received.
 *
 * returns:
 *	!=NULL, elements read and store in the ber_element tree
 *	NULL, type mismatch or read error
 */
struct ber_element *
ber_read_elements(struct ber *ber, struct ber_element *elm)
{
	struct ber_element *root = elm;

	if (root == NULL) {
		if ((root = ber_get_element(0)) == NULL)
			return NULL;
	}

	DPRINTF("read ber elements, root %p\n", root);

	if (ber_read_element(ber, root) == -1) {
		/* Cleanup if root was allocated by us */
		if (elm == NULL)
			ber_free_elements(root);
		return NULL;
	}

	return root;
}

off_t
ber_getpos(struct ber_element *elm)
{
	return elm->be_offs;
}

void
ber_free_elements(struct ber_element *root)
{
	if (root->be_sub && (root->be_encoding == BER_TYPE_SEQUENCE ||
	    root->be_encoding == BER_TYPE_SET))
		ber_free_elements(root->be_sub);
	if (root->be_next)
		ber_free_elements(root->be_next);
	if (root->be_free && (root->be_encoding == BER_TYPE_OCTETSTRING ||
	    root->be_encoding == BER_TYPE_BITSTRING ||
	    root->be_encoding == BER_TYPE_OBJECT))
		free(root->be_val);
	free(root);
}

size_t
ber_calc_len(struct ber_element *root)
{
	unsigned long t;
	size_t s;
	size_t size = 2;	/* minimum 1 byte head and 1 byte size */

	/* calculate the real length of a sequence or set */
	if (root->be_sub && (root->be_encoding == BER_TYPE_SEQUENCE ||
	    root->be_encoding == BER_TYPE_SET))
		root->be_len = ber_calc_len(root->be_sub);

	/* fix header length for extended types */
	if (root->be_type > BER_TYPE_SINGLE_MAX)
		for (t = root->be_type; t > 0; t >>= 7)
			size++;
	if (root->be_len >= BER_TAG_MORE)
		for (s = root->be_len; s > 0; s >>= 8)
			size++;

	/* calculate the length of the following elements */
	if (root->be_next)
		size += ber_calc_len(root->be_next);

	/* This is an empty element, do not use a minimal size */
	if (root->be_class != BER_CLASS_CONTEXT &&
	    root->be_type == BER_TYPE_EOC && root->be_len == 0)
		return (0);

	return (root->be_len + size);
}

/*
 * internal functions
 */

static int
ber_dump_element(struct ber *ber, struct ber_element *root)
{
	unsigned long long l;
	int i;
	uint8_t u;

	ber_dump_header(ber, root);
	if (root->be_cb)
		root->be_cb(root->be_cbarg, ber->br_wptr - ber->br_wbuf);

	switch (root->be_encoding) {
	case BER_TYPE_BOOLEAN:
	case BER_TYPE_INTEGER:
	case BER_TYPE_ENUMERATED:
		l = (unsigned long long)root->be_numeric;
		for (i = root->be_len; i > 0; i--) {
			u = (l >> ((i - 1) * 8)) & 0xff;
			ber_putc(ber, u);
		}
		break;
	case BER_TYPE_BITSTRING:
		return -1;
	case BER_TYPE_OCTETSTRING:
	case BER_TYPE_OBJECT:
		ber_write(ber, root->be_val, root->be_len);
		break;
	case BER_TYPE_NULL:	/* no payload */
	case BER_TYPE_EOC:
		break;
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
		if (root->be_sub && ber_dump_element(ber, root->be_sub) == -1)
			return -1;
		break;
	}

	if (root->be_next == NULL)
		return 0;
	return ber_dump_element(ber, root->be_next);
}

static void
ber_dump_header(struct ber *ber, struct ber_element *root)
{
	u_char	id = 0, t, buf[8];
	unsigned long type;
	size_t size;

	/* class universal, type encoding depending on type value */
	/* length encoding */
	if (root->be_type <= BER_TYPE_SINGLE_MAX) {
		id = root->be_type | (root->be_class << BER_CLASS_SHIFT);
		if (root->be_encoding == BER_TYPE_SEQUENCE ||
		    root->be_encoding == BER_TYPE_SET)
			id |= BER_TYPE_CONSTRUCTED;

		ber_putc(ber, id);
	} else {
		id = BER_TAG_MASK | (root->be_class << BER_CLASS_SHIFT);
		if (root->be_encoding == BER_TYPE_SEQUENCE ||
		    root->be_encoding == BER_TYPE_SET)
			id |= BER_TYPE_CONSTRUCTED;

		ber_putc(ber, id);

		for (t = 0, type = root->be_type; type > 0; type >>= 7)
			buf[t++] = type & ~BER_TAG_MORE;

		while (t-- > 0) {
			if (t > 0)
				buf[t] |= BER_TAG_MORE;
			ber_putc(ber, buf[t]);
		}
	}

	if (root->be_len < BER_TAG_MORE) {
		/* short form */
		ber_putc(ber, root->be_len);
	} else {
		for (t = 0, size = root->be_len; size > 0; size >>= 8)
			buf[t++] = size & 0xff;

		ber_putc(ber, t | BER_TAG_MORE);

		while (t > 0)
			ber_putc(ber, buf[--t]);
	}
}

static void
ber_putc(struct ber *ber, u_char c)
{
	if (ber->br_wptr + 1 <= ber->br_wend)
		*ber->br_wptr = c;
	ber->br_wptr++;
}

static void
ber_write(struct ber *ber, void *buf, size_t len)
{
	if (ber->br_wptr + len <= ber->br_wend)
		bcopy(buf, ber->br_wptr, len);
	ber->br_wptr += len;
}

/*
 * extract a BER encoded tag. There are two types, a short and long form.
 */
static ssize_t
get_id(struct ber *b, unsigned long *tag, int *class, int *cstruct)
{
	u_char u;
	size_t i = 0;
	unsigned long t = 0;

	if (ber_getc(b, &u) == -1)
		return -1;

	*class = (u >> BER_CLASS_SHIFT) & BER_CLASS_MASK;
	*cstruct = (u & BER_TYPE_CONSTRUCTED) == BER_TYPE_CONSTRUCTED;

	if ((u & BER_TAG_MASK) != BER_TAG_MASK) {
		*tag = u & BER_TAG_MASK;
		return 1;
	}

	do {
		if (ber_getc(b, &u) == -1)
			return -1;
		t = (t << 7) | (u & ~BER_TAG_MORE);
		i++;
	} while (u & BER_TAG_MORE);

	if (i > sizeof(unsigned long)) {
		errno = ERANGE;
		return -1;
	}

	*tag = t;
	return i + 1;
}

/*
 * extract length of a ber object -- if length is unknown an error is returned.
 */
static ssize_t
get_len(struct ber *b, ssize_t *len)
{
	u_char	u, n;
	ssize_t	s, r;

	if (ber_getc(b, &u) == -1)
		return -1;
	if ((u & BER_TAG_MORE) == 0) {
		/* short form */
		*len = u;
		return 1;
	}

	if (u == 0x80) {
		/* Indefinite length not supported. */
		errno = EINVAL;
		return -1;
	}

	n = u & ~BER_TAG_MORE;
	if (sizeof(ssize_t) < n) {
		errno = ERANGE;
		return -1;
	}
	r = n + 1;

	for (s = 0; n > 0; n--) {
		if (ber_getc(b, &u) == -1)
			return -1;
		s = (s << 8) | u;
	}

	if (s < 0) {
		/* overflow */
		errno = ERANGE;
		return -1;
	}

	*len = s;
	return r;
}

static ssize_t
ber_read_element(struct ber *ber, struct ber_element *elm)
{
	long long val = 0;
	struct ber_element *next;
	unsigned long type;
	int i, class, cstruct;
	ssize_t len, r, totlen = 0;
	u_char c;

	if ((r = get_id(ber, &type, &class, &cstruct)) == -1)
		return -1;
	DPRINTF("ber read got class %d type %lu, %s\n",
	    class, type, cstruct ? "constructive" : "primitive");
	totlen += r;
	if ((r = get_len(ber, &len)) == -1)
		return -1;
	DPRINTF("ber read element size %zd\n", len);
	totlen += r + len;

	/* If using an external buffer and the total size of the element
	 * is larger then the external buffer don't bother to continue. */
	if (ber->fd == -1 && len > ber->br_rend - ber->br_rptr) {
		errno = ECANCELED;
		return -1;
	}

	elm->be_type = type;
	elm->be_len = len;
	elm->be_offs = ber->br_offs;	/* element position within stream */
	elm->be_class = class;

	if (elm->be_encoding == 0) {
		/* try to figure out the encoding via class, type and cstruct */
		if (cstruct)
			elm->be_encoding = BER_TYPE_SEQUENCE;
		else if (class == BER_CLASS_UNIVERSAL)
			elm->be_encoding = type;
		else if (ber->br_application != NULL) {
			/*
			 * Ask the application to map the encoding to a
			 * universal type. For example, a SMI IpAddress
			 * type is defined as 4 byte OCTET STRING.
			 */
			elm->be_encoding = (*ber->br_application)(elm);
		} else
			/* last resort option */
			elm->be_encoding = BER_TYPE_NULL;
	}

	switch (elm->be_encoding) {
	case BER_TYPE_EOC:	/* End-Of-Content */
		break;
	case BER_TYPE_BOOLEAN:
	case BER_TYPE_INTEGER:
	case BER_TYPE_ENUMERATED:
		if (len > (ssize_t)sizeof(long long))
			return -1;
		for (i = 0; i < len; i++) {
			if (ber_getc(ber, &c) != 1)
				return -1;
			val <<= 8;
			val |= c;
		}

		/* sign extend if MSB is set */
		if (val >> ((i - 1) * 8) & 0x80)
			val |= ULLONG_MAX << (i * 8);
		elm->be_numeric = val;
		break;
	case BER_TYPE_BITSTRING:
		elm->be_val = malloc(len);
		if (elm->be_val == NULL)
			return -1;
		elm->be_free = 1;
		elm->be_len = len;
		ber_read(ber, elm->be_val, len);
		break;
	case BER_TYPE_OCTETSTRING:
	case BER_TYPE_OBJECT:
		elm->be_val = malloc(len + 1);
		if (elm->be_val == NULL)
			return -1;
		elm->be_free = 1;
		elm->be_len = len;
		ber_read(ber, elm->be_val, len);
		((u_char *)elm->be_val)[len] = '\0';
		break;
	case BER_TYPE_NULL:	/* no payload */
		if (len != 0)
			return -1;
		break;
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
		if (elm->be_sub == NULL) {
			if ((elm->be_sub = ber_get_element(0)) == NULL)
				return -1;
		}
		next = elm->be_sub;
		while (len > 0) {
			r = ber_read_element(ber, next);
			if (r == -1)
				return -1;
			len -= r;
			if (len > 0 && next->be_next == NULL) {
				if ((next->be_next = ber_get_element(0)) ==
				    NULL)
					return -1;
			}
			next = next->be_next;
		}
		break;
	}
	return totlen;
}

static ssize_t
ber_readbuf(struct ber *b, void *buf, size_t nbytes)
{
	size_t	 sz;
	size_t	 len;

	if (b->br_rbuf == NULL)
		return -1;

	sz = b->br_rend - b->br_rptr;
	len = MINIMUM(nbytes, sz);
	if (len == 0) {
		errno = ECANCELED;
		return (-1);	/* end of buffer and parser wants more data */
	}

	bcopy(b->br_rptr, buf, len);
	b->br_rptr += len;

	return (len);
}

void
ber_set_readbuf(struct ber *b, void *buf, size_t len)
{
	b->br_rbuf = b->br_rptr = buf;
	b->br_rend = (u_int8_t *)buf + len;
}

ssize_t
ber_get_writebuf(struct ber *b, void **buf)
{
	if (b->br_wbuf == NULL)
		return -1;
	*buf = b->br_wbuf;
	return (b->br_wend - b->br_wbuf);
}

void
ber_set_application(struct ber *b, unsigned long (*cb)(struct ber_element *))
{
	b->br_application = cb;
}

void
ber_set_writecallback(struct ber_element *elm, void (*cb)(void *, size_t),
    void *arg)
{
	elm->be_cb = cb;
	elm->be_cbarg = arg;
}


void
ber_free(struct ber *b)
{
	free(b->br_wbuf);
}

static ssize_t
ber_getc(struct ber *b, u_char *c)
{
	return ber_read(b, c, 1);
}

static ssize_t
ber_read(struct ber *ber, void *buf, size_t len)
{
	u_char *b = buf;
	ssize_t	r, remain = len;

	/*
	 * XXX calling read here is wrong in many ways. The most obvious one
	 * being that we will block till data arrives.
	 * But for now it is _good enough_ *gulp*
	 */

	while (remain > 0) {
		if (ber->fd == -1)
			r = ber_readbuf(ber, b, remain);
		else
			r = read(ber->fd, b, remain);
		if (r == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			return -1;
		}
		if (r == 0)
			return (b - (u_char *)buf);
		b += r;
		remain -= r;
	}
	r = b - (u_char *)buf;
	ber->br_offs += r;
	return r;
}

int
ber_oid_cmp(struct ber_oid *a, struct ber_oid *b)
{
	size_t	 i;
	for (i = 0; i < BER_MAX_OID_LEN; i++) {
		if (a->bo_id[i] != 0) {
			if (a->bo_id[i] == b->bo_id[i])
				continue;
			else if (a->bo_id[i] < b->bo_id[i]) {
				/* b is a successor of a */
				return (1);
			} else {
				/* b is a predecessor of a */
				return (-1);
			}		
		} else if (b->bo_id[i] != 0) {
			/* b is larger, but a child of a */
			return (2);
		} else
			break;
	}

	/* b and a are identical */
	return (0);
}
@


1.30
log
@strings.h -> string.h to prevent an implicit declaration warning. Also
remove a handful of NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.29 2015/02/12 00:30:38 pelikan Exp $ */
d423 1
a423 1
	bzero(o, sizeof(*o));
d508 1
a508 1
	bzero(o, sizeof(*o));
d642 1
a642 1
	bzero(parent, sizeof(struct ber_element *) * _MAX_SEQ);
@


1.29
log
@ber_printf_elements should return NULL if any of its parts fail.

Leave the error handling up to its callers.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.28 2015/01/16 00:05:13 deraadt Exp $ */
d28 1
a28 1
#include <strings.h>
d1259 1
a1259 2
	if (b->br_wbuf != NULL)
		free (b->br_wbuf);
@


1.28
log
@first batch of cleanup to programs based upon the namespace cleanups
in net/pfvar.h sys/proc.h sys/ucred.h arpa/nameser.h
change to PATH_MAX, reduce use of MIN() and MAX(), HOST_NAME_MAX+1,
LOGIN_NAME_MAX, etc etc
ok millert guenther, some review by doug
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.27 2014/04/25 06:57:11 blambert Exp $ */
d541 2
a542 1
			ber = ber_add_bitstring(ber, p, len);
d546 2
a547 1
			ber = ber_add_boolean(ber, d);
d551 2
a552 1
			ber = ber_add_integer(ber, d);
d560 2
a561 1
			ber = ber_add_enumerated(ber, i);
d565 2
a566 1
			ber = ber_add_integer(ber, i);
d570 2
a571 1
			ber = ber_add_oid(ber, o);
d575 2
a576 1
			ber = ber_add_oidstring(ber, s);
d580 2
a581 1
			ber = ber_add_string(ber, s);
d591 2
a592 1
			ber = ber_add_nstring(ber, s, len);
d595 2
a596 1
			ber = ber_add_null(ber);
d599 2
a600 1
			ber = sub = ber_add_sequence(ber);
d603 2
a604 1
			ber = sub = ber_add_set(ber);
d611 3
a613 1
			ber = ber_add_eoc(ber);
d622 3
@


1.27
log
@Support running user-defined actions on receipt of snmp traps.

testing sthen@@
much man page guidance jmc@@
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.26 2014/04/14 12:55:10 blambert Exp $ */
a21 1
#include <sys/param.h>
d34 1
d1196 1
a1196 1
	len = MIN(nbytes, sz);
@


1.26
log
@Make snmpd use the AgentX protcol for accepting trap requests.
AgentX notifications are the only portion implemented right now;
get in the tree to flesh out the remainder.

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.25 2013/10/01 12:41:47 reyk Exp $ */
d617 1
a617 1
	long long		*i;
d643 7
a660 1
		case 'd':
@


1.25
log
@Add initial SNMP client utility to snmpctl(8).
For example, snmpctl snmp walk 127.0.0.1

commit it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.24 2012/09/17 16:30:34 reyk Exp $ */
d654 1
@


1.24
log
@Add initial SNMPv3 support to snmpd(8).

Traps are still sent via SNMPv2 protocol. They can neither be
authenticated nor encrypted. - Transport mode is still UDP. Not
additional transport subsystems were added. - Only the User-based
Security Model (USM, RFC3414) is supported.  View-Based Access Control
(VACM, RFC3415) is not included. - Configuration is described in
snmpd.conf(5).

This diff includes a few minor changes to ber.c/h adding a necessary
callback for the USM HMAC calculation and merging it with other
minor changes from ldapd's ber code.

From Gerhard Roth at genua
ok claudio@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.23 2010/09/20 08:30:13 martinh Exp $ */
d1275 26
@


1.23
log
@Allow output of null values with a context class. This is used in SNMPv2 to
return an error exception value for a varbind result ("noSuchObject[0]
IMPLICIT NULL" in rfc1905).
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.22 2010/06/14 13:46:08 martinh Exp $ */
d4 1
a4 1
 * Copyright (c) 2007 Reyk Floeter <reyk@@vantronix.net>
d272 1
a272 1
	if ((string = calloc(1, len)) == NULL)
d621 1
d699 5
d721 1
a721 1
			continue;
d817 6
d882 2
d1034 6
a1058 6
	if (s == 0) {
		/* invalid encoding */
		errno = EINVAL;
		return -1;
	}

d1083 7
d1092 1
d1224 9
d1242 1
a1242 11
	ssize_t r;
	/*
	 * XXX calling read here is wrong in many ways. The most obvious one
	 * being that we will block till data arrives.
	 * But for now it is _good enough_ *gulp*
	 */
	if (b->fd == -1)
		r = ber_readbuf(b, c, 1);
	else
		r = read(b->fd, c, 1);
	return r;
d1272 3
a1274 1
	return (b - (u_char *)buf);
@


1.22
log
@Fixes unlinking the first element inside a set or a sequence, and
fix reading empty sequences/sets. This minimizes the changes against
ldapd.

"looks good" pyr@@, ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.21 2010/06/08 17:52:47 martinh Exp $ */
d851 2
a852 1
	if (root->be_type == BER_TYPE_EOC && root->be_len == 0)
@


1.21
log
@ber_calc_len() is not an internal function, so adjust the comment.

from Dawe
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.20 2010/02/24 14:09:45 jmc Exp $ */
d104 1
a104 1
	    prev->be_sub == NULL) {
d1139 1
a1139 1
		do {
d1143 2
a1144 1
			if (next->be_next == NULL) {
d1150 1
a1150 2
			len -= r;
		} while (len > 0);
@


1.20
log
@match code and doc; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.19 2009/12/16 22:17:53 deraadt Exp $ */
a825 4
/*
 * internal functions
 */

d856 4
@


1.19
log
@knf and unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.18 2009/11/12 15:28:32 deraadt Exp $ */
d741 1
a741 4
 *	0	on success
 *
 * returns:
 *	0	on success
@


1.18
log
@accessses 1 entry too far, found by parfait, ok jsg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.17 2009/06/04 18:03:07 jsg Exp $ */
a417 1
	size_t			 len;
a422 1
	len = strlen(str);
d868 1
a868 1
	int i, pos;
a876 1
		pos = (root->be_numeric > 0);
@


1.17
log
@Make the types of ber_read() decl match the prototype.
'looks good' pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.16 2009/01/03 18:41:41 aschrijver Exp $ */
d705 1
a705 1
			if (ber->be_sub == NULL || level >= _MAX_SEQ)
@


1.16
log
@

Sync with ypldap.  Add ber_{add,get}_enumerated.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.1 2008/09/30 16:24:16 aschrijver Exp $ */
d1230 1
a1230 1
ber_read(struct ber *ber, void *buf, unsigned long len)
@


1.15
log
@Use C99, not gcc-specific variadics.  Ok miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.14 2008/03/18 16:57:58 reyk Exp $ */
d156 29
d223 11
d557 4
d649 6
d665 3
@


1.14
log
@remove ber_add_astring and make it the default behaviour in
ber_add_string, ber_add_nstring, and ber_add_bitstring to allocate and
copy the provided buffer instead of just attaching it to the ber
element.  this may add some overhead but fixes and avoids some bugs
with static buffers and simplifies the ber api again.

From Matthew at Dempsky dot org
With input from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.13 2008/03/18 14:53:07 reyk Exp $ */
d56 1
a56 1
#define DPRINTF(x...)	printf(x)
d58 1
a58 1
#define DPRINTF(x...)	do { } while (0)
@


1.13
log
@fix bug that ber_oid2ber skips the first byte when encoding powers of
128.  E.g., it will encode 128 as 0x00 instead of 0x81 0x00.

From Matthew at Dempsky dot org
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.12 2008/03/14 15:22:22 reyk Exp $ */
d221 1
a221 1
ber_add_string(struct ber_element *prev, char *string)
d223 1
a223 11
	struct ber_element *elm;

	if ((elm = ber_get_element(BER_TYPE_OCTETSTRING)) == NULL)
		return NULL;

	elm->be_val = string;
	elm->be_len = strlen(string);	/* terminating '\0' not included */

	ber_link_elements(prev, elm);

	return elm;
d227 1
a227 1
ber_add_astring(struct ber_element *prev, const char *string)
d230 1
a230 1
	char *str;
d232 1
a232 1
	if ((elm = ber_get_element(BER_TYPE_OCTETSTRING)) == NULL)
d234 2
a235 2
	if ((str = strdup(string)) == NULL) {
		ber_free_elements(elm);
d239 1
a239 17
	elm->be_val = str;
	elm->be_len = strlen(str);	/* terminating '\0' not included */
	elm->be_free = 1;		/* free string on cleanup */

	ber_link_elements(prev, elm);

	return elm;
}

struct ber_element *
ber_add_nstring(struct ber_element *prev, char *string, size_t len)
{
	struct ber_element *elm;

	if ((elm = ber_get_element(BER_TYPE_OCTETSTRING)) == NULL)
		return NULL;

d242 1
d271 1
a271 1
ber_add_bitstring(struct ber_element *prev, void *v, size_t len)
d274 1
d276 1
a276 1
	if ((elm = ber_get_element(BER_TYPE_BITSTRING)) == NULL)
d278 4
d283 1
d286 1
@


1.12
log
@add a new ber function ber_add_astring() that strdups the string and
sets the be_free flag (which is required in some cases).  this will
make it easier because it is done manually at some places in the code.

discussed with dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.11 2008/03/12 17:48:27 reyk Exp $ */
d379 1
a379 1
			if (v > (u_int)(1 << k)) {
@


1.11
log
@remove noisy warning message

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.10 2008/03/12 17:41:38 reyk Exp $ */
d230 22
@


1.10
log
@fix a memleak in the ber_read_elements() error case.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.9 2008/03/12 14:30:11 claudio Exp $ */
a1168 2
	if (r == -1)
		warn("ber_getc");
@


1.9
log
@Check that the current ber element is a sequence or a set when '{' or '('
is used.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.8 2008/03/12 13:09:12 claudio Exp $ */
d738 1
a738 1
ber_read_elements(struct ber *ber, struct ber_element *root)
d740 2
d749 4
a752 1
	if (ber_read_element(ber, root) == -1)
d754 1
@


1.8
log
@SNMP has a restricted BER encoding especially all encodings use the
definite-length from. So bail out with an error if this is not the case.
OK cloder@@, reyk@@
cvs: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.7 2008/03/12 13:06:09 claudio Exp $ */
d645 3
@


1.7
log
@Return an error if more data is requested even though the buffer is empty.
Fixes an infinite loop seen by cloder@@. OK cloder@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.6 2008/02/09 13:03:01 reyk Exp $ */
d943 1
a943 2
 * extract length of a ber object -- if length is unknown a length of -1 is
 * returned.
d978 5
a982 2
	if (s == 0)
		s = -1;
@


1.6
log
@fix a memleak in the snmp engine and the ber i/o; free the dynamically
allocated ber write buffer after using it.  extend the ber api with a
ber_free() function to do the required cleanup.

Thanks to Will Backman (bitgeist at yahoo dot com) for testing and for
figuring out that there was a memleak.
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.5 2008/01/03 14:44:08 reyk Exp $ */
d1105 4
@


1.5
log
@scalars have an index of 0 in the returned oid (like sysDescr.0).
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.4 2007/12/07 10:08:40 reyk Exp $ */
d1132 7
@


1.4
log
@comparison betweem signed and unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.3 2007/12/07 09:50:51 reyk Exp $ */
d425 13
@


1.3
log
@add a new 'd' format to ber_printf_elements to pass ints instead of
long longs; you have to pass the right type with vargs. this finally
fixes the previous problem on i386.

discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.2 2007/12/05 23:29:19 reyk Exp $ */
d1021 1
a1021 1
		if (len > (u_int)sizeof(long long))
@


1.2
log
@more typos in comments etc.

From Leonardo Chiquitto (leonardo at ngdn dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.1 2007/12/05 09:22:44 reyk Exp $ */
d491 4
@


1.1
log
@Start working on snmpd(8) and snmpctl(8), a lightweight SNMP implementation
for OpenBSD.  SNMP is a necessary evil.  This is work in progress, don't
expect too much from it yet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ber.c,v 1.70 2007/11/12 21:57:06 reyk Exp $ */
d759 1
a759 1
	/* calculate the real lenght of a sequence or set */
d926 1
a926 1
 * extract lenght of a ber object -- if length is unknown a length of -1 is
d1122 1
a1122 1
	 * XXX calling read here is wrong in many ways. The most obivous one
d1142 1
a1142 1
	 * XXX calling read here is wrong in many ways. The most obivous one
@

