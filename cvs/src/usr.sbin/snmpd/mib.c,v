head	1.83;
access;
symbols
	OPENBSD_6_1:1.83.0.2
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.80.0.4
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.80.0.2
	OPENBSD_5_9_BASE:1.80
	OPENBSD_5_8:1.76.0.4
	OPENBSD_5_8_BASE:1.76
	OPENBSD_5_7:1.75.0.2
	OPENBSD_5_7_BASE:1.75
	OPENBSD_5_6:1.71.0.4
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.66.0.4
	OPENBSD_5_5_BASE:1.66
	OPENBSD_5_4:1.64.0.2
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.63.0.2
	OPENBSD_5_3_BASE:1.63
	OPENBSD_5_2:1.56.0.2
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.2
	OPENBSD_5_0:1.45.0.2
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19;
locks; strict;
comment	@ * @;


1.83
date	2017.01.31.21.31.04;	author sthen;	state Exp;
branches;
next	1.82;
commitid	CLxnx09hdf2gmNy2;

1.82
date	2017.01.20.09.11.18;	author claudio;	state Exp;
branches;
next	1.81;
commitid	mTVRMehhEIBzD6bR;

1.81
date	2016.10.28.08.01.53;	author rzalamena;	state Exp;
branches;
next	1.80;
commitid	SMslalgbhOIf4OXA;

1.80
date	2015.11.17.12.30.23;	author gerhard;	state Exp;
branches;
next	1.79;
commitid	R0bCyZRMcTznjRKw;

1.79
date	2015.10.08.08.29.21;	author sthen;	state Exp;
branches;
next	1.78;
commitid	cy7LMU4SaCtIm4OT;

1.78
date	2015.10.08.07.26.34;	author sthen;	state Exp;
branches;
next	1.77;
commitid	WxcOx5vlSxnNNSmB;

1.77
date	2015.10.05.15.29.14;	author uebayasi;	state Exp;
branches;
next	1.76;
commitid	8fzumuBgZ88G39PA;

1.76
date	2015.06.10.10.03.59;	author mikeb;	state Exp;
branches;
next	1.75;
commitid	lzMdUzkoqk2pAr0A;

1.75
date	2015.01.21.21.50.33;	author deraadt;	state Exp;
branches;
next	1.74;
commitid	3o2AkhiRPQXvG94X;

1.74
date	2015.01.16.00.05.13;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	khLbW7SmDyckNaAs;

1.73
date	2014.11.18.20.54.29;	author krw;	state Exp;
branches;
next	1.72;
commitid	yCis8OrOsfixbKpI;

1.72
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.71;
commitid	2uw1UTO4k6erpWzK;

1.71
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.70;
commitid	vhXZZxMGVTWiFaF3;

1.70
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.69;
commitid	uXnRK9VvnFZsAqfW;

1.69
date	2014.05.07.01.23.52;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2014.04.28.12.03.32;	author mikeb;	state Exp;
branches;
next	1.67;

1.67
date	2014.04.08.14.04.11;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2013.10.01.12.41.47;	author reyk;	state Exp;
branches;
next	1.65;

1.65
date	2013.09.07.04.31.52;	author joel;	state Exp;
branches;
next	1.64;

1.64
date	2013.03.11.19.49.37;	author sthen;	state Exp;
branches;
next	1.63;

1.63
date	2012.12.18.21.28.45;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2012.11.29.13.16.30;	author mikeb;	state Exp;
branches;
next	1.61;

1.61
date	2012.10.01.11.36.55;	author reyk;	state Exp;
branches;
next	1.60;

1.60
date	2012.09.20.20.11.58;	author yuo;	state Exp;
branches;
next	1.59;

1.59
date	2012.09.18.08.29.09;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2012.09.17.16.43.59;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2012.09.17.16.30.34;	author reyk;	state Exp;
branches;
next	1.56;

1.56
date	2012.07.08.11.24.43;	author blambert;	state Exp;
branches;
next	1.55;

1.55
date	2012.06.19.18.43.27;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	2012.06.14.17.31.32;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	2012.05.26.14.45.55;	author joel;	state Exp;
branches;
next	1.52;

1.52
date	2012.03.20.03.01.26;	author joel;	state Exp;
branches;
next	1.51;

1.51
date	2012.02.27.16.45.16;	author sthen;	state Exp;
branches;
next	1.50;

1.50
date	2012.02.23.03.54.38;	author joel;	state Exp;
branches;
next	1.49;

1.49
date	2012.01.31.18.00.46;	author joel;	state Exp;
branches;
next	1.48;

1.48
date	2012.01.30.22.04.28;	author joel;	state Exp;
branches;
next	1.47;

1.47
date	2011.09.16.20.52.48;	author yuo;	state Exp;
branches;
next	1.46;

1.46
date	2011.09.16.15.44.31;	author yuo;	state Exp;
branches;
next	1.45;

1.45
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2011.04.10.03.20.59;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2010.10.15.11.56.13;	author sthen;	state Exp;
branches;
next	1.42;

1.42
date	2010.09.23.10.49.55;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.20.16.29.51;	author sthen;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.11.10.45.36;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.27.15.37.13;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.20.20.49.36;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.20.19.44.07;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.15.04.57.29;	author yuo;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.31.09.20.23;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.11.11.15.03;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.11.06.38.41;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.16.22.17.53;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.14.19.44.14;	author cnst;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.23.08.06.10;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.19.14.02.20;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.08.11.34.55;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2008.03.18.16.57.58;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.17.14.47.20;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.17.14.40.15;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2008.03.17.13.56.17;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2008.03.16.00.35.05;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.15.23.50.54;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.15.00.56.08;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.10.11.02.32;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.30.10.12.45;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.18.18.38.35;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.16.09.51.15;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.29.09.24.43;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.12.28.16.59.31;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.28.16.27.51;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.28.15.32.02;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.15.06.26.59;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.15.04.15.12;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.15.03.02.59;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.15.02.53.22;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.15.02.37.58;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.15.02.20.03;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.15.02.14.30;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.15.02.02.45;	author gilles;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.10.23.23.21;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.06.09.08.05;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.05.22.52.50;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.05.09.22.44;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.83
log
@Don't include a literal "%" in the value for humidity sensorValue in
OPENBSD-SENSORS-MIB, % is the unit for this value and is already present
in sensorUnits, and it's harder for NMS to parse "100.00%" as a number.
From Joel Knight.
@
text
@/*	$OpenBSD: mib.c,v 1.82 2017/01/20 09:11:18 claudio Exp $	*/

/*
 * Copyright (c) 2012 Joel Knight <joel@@openbsd.org>
 * Copyright (c) 2007, 2008, 2012 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* MAXCOMLEN */
#include <sys/queue.h>
#include <sys/proc.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/time.h>
#include <sys/tree.h>
#include <sys/utsname.h>
#include <sys/sysctl.h>
#include <sys/sensors.h>
#include <sys/sched.h>
#include <sys/mount.h>
#include <sys/ioctl.h>
#include <sys/disk.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_carp.h>
#include <netinet/ip_var.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/if_types.h>
#include <net/pfvar.h>
#include <netinet/ip_ipsp.h>
#include <net/if_pfsync.h>

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pwd.h>
#include <limits.h>
#include <kvm.h>

#include "snmpd.h"
#include "mib.h"

/*
 * Defined in SNMPv2-MIB.txt (RFC 3418)
 */

int	 mib_getsys(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_getsnmp(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_sysor(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_setsnmp(struct oid *, struct ber_oid *, struct ber_element **);

static struct oid mib_tree[] = MIB_TREE;
static struct ber_oid zerodotzero = { { 0, 0 }, 2 };

#define sizeofa(_a) (sizeof(_a) / sizeof((_a)[0]))

/* base MIB tree */
static struct oid base_mib[] = {
	{ MIB(mib_2),			OID_MIB },
	{ MIB(sysDescr),		OID_RD, mib_getsys },
	{ MIB(sysOID),			OID_RD, mib_getsys },
	{ MIB(sysUpTime),		OID_RD, mib_getsys },
	{ MIB(sysContact),		OID_RW, mib_getsys, mps_setstr },
	{ MIB(sysName),			OID_RW, mib_getsys, mps_setstr },
	{ MIB(sysLocation),		OID_RW, mib_getsys, mps_setstr },
	{ MIB(sysServices),		OID_RS, mib_getsys },
	{ MIB(sysORLastChange),		OID_RD, mps_getts },
	{ MIB(sysORIndex),		OID_TRD, mib_sysor },
	{ MIB(sysORID),			OID_TRD, mib_sysor },
	{ MIB(sysORDescr),		OID_TRD, mib_sysor },
	{ MIB(sysORUpTime),		OID_TRD, mib_sysor },
	{ MIB(snmp),			OID_MIB },
	{ MIB(snmpInPkts),		OID_RD, mib_getsnmp },
	{ MIB(snmpOutPkts),		OID_RD, mib_getsnmp },
	{ MIB(snmpInBadVersions),	OID_RD, mib_getsnmp },
	{ MIB(snmpInBadCommunityNames),	OID_RD, mib_getsnmp },
	{ MIB(snmpInBadCommunityUses),	OID_RD, mib_getsnmp },
	{ MIB(snmpInASNParseErrs),	OID_RD, mib_getsnmp },
	{ MIB(snmpInTooBigs),		OID_RD,	mib_getsnmp },
	{ MIB(snmpInNoSuchNames),	OID_RD, mib_getsnmp },
	{ MIB(snmpInBadValues),		OID_RD, mib_getsnmp },
	{ MIB(snmpInReadOnlys),		OID_RD, mib_getsnmp },
	{ MIB(snmpInGenErrs),		OID_RD, mib_getsnmp },
	{ MIB(snmpInTotalReqVars),	OID_RD, mib_getsnmp },
	{ MIB(snmpInTotalSetVars),	OID_RD, mib_getsnmp },
	{ MIB(snmpInGetRequests),	OID_RD, mib_getsnmp },
	{ MIB(snmpInGetNexts),		OID_RD, mib_getsnmp },
	{ MIB(snmpInSetRequests),	OID_RD, mib_getsnmp },
	{ MIB(snmpInGetResponses),	OID_RD, mib_getsnmp },
	{ MIB(snmpInTraps),		OID_RD, mib_getsnmp },
	{ MIB(snmpOutTooBigs),		OID_RD, mib_getsnmp },
	{ MIB(snmpOutNoSuchNames),	OID_RD, mib_getsnmp },
	{ MIB(snmpOutBadValues),	OID_RD, mib_getsnmp },
	{ MIB(snmpOutGenErrs),		OID_RD, mib_getsnmp },
	{ MIB(snmpOutGetRequests),	OID_RD, mib_getsnmp },
	{ MIB(snmpOutGetNexts),		OID_RD, mib_getsnmp },
	{ MIB(snmpOutSetRequests),	OID_RD, mib_getsnmp },
	{ MIB(snmpOutGetResponses),	OID_RD, mib_getsnmp },
	{ MIB(snmpOutTraps),		OID_RD, mib_getsnmp },
	{ MIB(snmpEnableAuthenTraps),	OID_RW, mib_getsnmp, mib_setsnmp },
	{ MIB(snmpSilentDrops),		OID_RD, mib_getsnmp },
	{ MIB(snmpProxyDrops),		OID_RD, mib_getsnmp },
	{ MIBEND }
};

int
mib_getsys(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_oid		 sysoid = OID(MIB_SYSOID_DEFAULT);
	char			*s = oid->o_data;
	struct ber_oid		*so = oid->o_data;
	struct utsname		 u;
	long long		 ticks;

	if (uname(&u) == -1)
		return (-1);

	switch (oid->o_oid[OIDIDX_system]) {
	case 1:
		if (s == NULL) {
			if (asprintf(&s, "%s %s %s %s %s",
			    u.sysname, u.nodename, u.release,
			    u.version, u.machine) == -1)
				return (-1);
			oid->o_data = s;
			oid->o_val = strlen(s);
		}
		*elm = ber_add_string(*elm, s);
		break;
	case 2:
		if (so == NULL)
			so = &sysoid;
		smi_oidlen(so);
		*elm = ber_add_oid(*elm, so);
		break;
	case 3:
		ticks = smi_getticks();
		*elm = ber_add_integer(*elm, ticks);
		ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_TIMETICKS);
		break;
	case 4:
		if (s == NULL) {
			if (asprintf(&s, "root@@%s", u.nodename) == -1)
				return (-1);
			oid->o_data = s;
			oid->o_val = strlen(s);
		}
		*elm = ber_add_string(*elm, s);
		break;
	case 5:
		if (s == NULL) {
			if ((s = strdup(u.nodename)) == NULL)
				return (-1);
			oid->o_data = s;
			oid->o_val = strlen(s);
		}
		*elm = ber_add_string(*elm, s);
		break;
	case 6:
		if (s == NULL)
			s = "";
		*elm = ber_add_string(*elm, s);
		break;
	case 7:
		*elm = ber_add_integer(*elm, oid->o_val);
		break;
	default:
		return (-1);
	}
	return (0);
}

int
mib_sysor(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	u_int32_t		 idx = 1, nmib = 0;
	struct oid		*next, *miboid;
	char			 buf[SNMPD_MAXSTRLEN];

	/* Count MIB root OIDs in the tree */
	for (next = NULL;
	    (next = smi_foreach(next, OID_MIB)) != NULL; nmib++);

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_sysOREntry];
	if (idx > nmib)
		return (1);

	/* Find the MIB root element for this Id */
	for (next = miboid = NULL, nmib = 1;
	    (next = smi_foreach(next, OID_MIB)) != NULL; nmib++) {
		if (nmib == idx)
			miboid = next;
	}
	if (miboid == NULL)
		return (-1);

	/* Tables need to prepend the OID on their own */
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_sysOR]) {
	case 1:
		ber = ber_add_integer(ber, idx);
		break;
	case 2:
		ber = ber_add_oid(ber, &miboid->o_id);
		break;
	case 3:
		/*
		 * This should be a description of the MIB.
		 * But we use the symbolic OID string for now, it may
		 * help to display names of internal OIDs.
		 */
		smi_oid2string(&miboid->o_id, buf, sizeof(buf), 0);
		ber = ber_add_string(ber, buf);
		break;
	case 4:
		/*
		 * We do not support dynamic loading of MIB at runtime,
		 * the sysORUpTime value of 0 will indicate "loaded at
		 * startup".
		 */
		ber = ber_add_integer(ber, 0);
		ber_set_header(ber,
		    BER_CLASS_APPLICATION, SNMP_T_TIMETICKS);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
mib_getsnmp(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct snmp_stats	*stats = &snmpd_env->sc_stats;
	long long		 i;
	struct statsmap {
		u_int8_t	 m_id;
		u_int32_t	*m_ptr;
	}			 mapping[] = {
		{ 1, &stats->snmp_inpkts },
		{ 2, &stats->snmp_outpkts },
		{ 3, &stats->snmp_inbadversions },
		{ 4, &stats->snmp_inbadcommunitynames },
		{ 5, &stats->snmp_inbadcommunityuses },
		{ 6, &stats->snmp_inasnparseerrs },
		{ 8, &stats->snmp_intoobigs },
		{ 9, &stats->snmp_innosuchnames },
		{ 10, &stats->snmp_inbadvalues },
		{ 11, &stats->snmp_inreadonlys },
		{ 12, &stats->snmp_ingenerrs },
		{ 13, &stats->snmp_intotalreqvars },
		{ 14, &stats->snmp_intotalsetvars },
		{ 15, &stats->snmp_ingetrequests },
		{ 16, &stats->snmp_ingetnexts },
		{ 17, &stats->snmp_insetrequests },
		{ 18, &stats->snmp_ingetresponses },
		{ 19, &stats->snmp_intraps },
		{ 20, &stats->snmp_outtoobigs },
		{ 21, &stats->snmp_outnosuchnames },
		{ 22, &stats->snmp_outbadvalues },
		{ 24, &stats->snmp_outgenerrs },
		{ 25, &stats->snmp_outgetrequests },
		{ 26, &stats->snmp_outgetnexts },
		{ 27, &stats->snmp_outsetrequests },
		{ 28, &stats->snmp_outgetresponses },
		{ 29, &stats->snmp_outtraps },
		{ 31, &stats->snmp_silentdrops },
		{ 32, &stats->snmp_proxydrops }
	};

	switch (oid->o_oid[OIDIDX_snmp]) {
	case 30:
		i = stats->snmp_enableauthentraps == 1 ? 1 : 2;
		*elm = ber_add_integer(*elm, i);
		break;
	default:
		for (i = 0;
		    (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
			if (oid->o_oid[OIDIDX_snmp] == mapping[i].m_id) {
				*elm = ber_add_integer(*elm, *mapping[i].m_ptr);
				ber_set_header(*elm,
				    BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
				return (0);
			}
		}
		return (-1);
	}

	return (0);
}

int
mib_setsnmp(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct snmp_stats	*stats = &snmpd_env->sc_stats;
	long long		 i;

	if (ber_get_integer(*elm, &i) == -1)
		return (-1);

	stats->snmp_enableauthentraps = i == 1 ? 1 : 0;

	return (0);
}

/*
 * Defined in SNMP-USER-BASED-SM-MIB.txt (RFC 3414)
 */
int	 mib_engine(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_usmstats(struct oid *, struct ber_oid *, struct ber_element **);

static struct oid usm_mib[] = {
	{ MIB(snmpEngine),			OID_MIB },
	{ MIB(snmpEngineID),			OID_RD, mib_engine },
	{ MIB(snmpEngineBoots),			OID_RD, mib_engine },
	{ MIB(snmpEngineTime),			OID_RD, mib_engine },
	{ MIB(snmpEngineMaxMsgSize),		OID_RD, mib_engine },
	{ MIB(usmStats),			OID_MIB },
	{ MIB(usmStatsUnsupportedSecLevels),	OID_RD, mib_usmstats },
	{ MIB(usmStatsNotInTimeWindow),		OID_RD, mib_usmstats },
	{ MIB(usmStatsUnknownUserNames),	OID_RD, mib_usmstats },
	{ MIB(usmStatsUnknownEngineId),		OID_RD, mib_usmstats },
	{ MIB(usmStatsWrongDigests),		OID_RD, mib_usmstats },
	{ MIB(usmStatsDecryptionErrors),	OID_RD, mib_usmstats },
	{ MIBEND }
};

int
mib_engine(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	switch (oid->o_oid[OIDIDX_snmpEngine]) {
	case 1:
		*elm = ber_add_nstring(*elm, snmpd_env->sc_engineid,
		    snmpd_env->sc_engineid_len);
		break;
	case 2:
		*elm = ber_add_integer(*elm, snmpd_env->sc_engine_boots);
		break;
	case 3:
		*elm = ber_add_integer(*elm, snmpd_engine_time());
		break;
	case 4:
		*elm = ber_add_integer(*elm, READ_BUF_SIZE);
		break;
	default:
		return -1;
	}
	return 0;
}

int
mib_usmstats(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct snmp_stats	*stats = &snmpd_env->sc_stats;
	long long		 i;
	struct statsmap {
		u_int8_t	 m_id;
		u_int32_t	*m_ptr;
	}			 mapping[] = {
		{ OIDVAL_usmErrSecLevel,	&stats->snmp_usmbadseclevel },
		{ OIDVAL_usmErrTimeWindow,	&stats->snmp_usmtimewindow },
		{ OIDVAL_usmErrUserName,	&stats->snmp_usmnosuchuser },
		{ OIDVAL_usmErrEngineId,	&stats->snmp_usmnosuchengine },
		{ OIDVAL_usmErrDigest,		&stats->snmp_usmwrongdigest },
		{ OIDVAL_usmErrDecrypt,		&stats->snmp_usmdecrypterr },
	};

	for (i = 0; (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
		if (oid->o_oid[OIDIDX_usmStats] == mapping[i].m_id) {
			*elm = ber_add_integer(*elm, *mapping[i].m_ptr);
			ber_set_header(*elm, BER_CLASS_APPLICATION,
			    SNMP_T_COUNTER32);
			return (0);
		}
	}
	return (-1);
}

/*
 * Defined in HOST-RESOURCES-MIB.txt (RFC 2790)
 */

int	 mib_hrsystemuptime(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_hrsystemdate(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_hrsystemprocs(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_hrmemory(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_hrstorage(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_hrdevice(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_hrprocessor(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_hrswrun(struct oid *, struct ber_oid *, struct ber_element **);

int	 kinfo_proc_comp(const void *, const void *);
int	 kinfo_proc(u_int32_t, struct kinfo_proc **);
int	 kinfo_args(struct kinfo_proc *, char **);

static struct oid hr_mib[] = {
	{ MIB(host),				OID_MIB },
	{ MIB(hrSystemUptime),			OID_RD, mib_hrsystemuptime },
	{ MIB(hrSystemDate),			OID_RD, mib_hrsystemdate },
	{ MIB(hrSystemProcesses),		OID_RD, mib_hrsystemprocs },
	{ MIB(hrSystemMaxProcesses),		OID_RD, mib_hrsystemprocs },
	{ MIB(hrMemorySize),			OID_RD,	mib_hrmemory },
	{ MIB(hrStorageIndex),			OID_TRD, mib_hrstorage },
	{ MIB(hrStorageType),			OID_TRD, mib_hrstorage },
	{ MIB(hrStorageDescr),			OID_TRD, mib_hrstorage },
	{ MIB(hrStorageAllocationUnits),	OID_TRD, mib_hrstorage },
	{ MIB(hrStorageSize),			OID_TRD, mib_hrstorage },
	{ MIB(hrStorageUsed),			OID_TRD, mib_hrstorage },
	{ MIB(hrStorageAllocationFailures),	OID_TRD, mib_hrstorage },
	{ MIB(hrDeviceIndex),			OID_TRD, mib_hrdevice },
	{ MIB(hrDeviceType),			OID_TRD, mib_hrdevice },
	{ MIB(hrDeviceDescr),			OID_TRD, mib_hrdevice },
	{ MIB(hrDeviceID),			OID_TRD, mib_hrdevice },
	{ MIB(hrDeviceStatus),			OID_TRD, mib_hrdevice },
	{ MIB(hrDeviceErrors),			OID_TRD, mib_hrdevice },
	{ MIB(hrProcessorFrwID),		OID_TRD, mib_hrprocessor },
	{ MIB(hrProcessorLoad),			OID_TRD, mib_hrprocessor },
	{ MIB(hrSWRunIndex),			OID_TRD, mib_hrswrun },
	{ MIB(hrSWRunName),			OID_TRD, mib_hrswrun },
	{ MIB(hrSWRunID),			OID_TRD, mib_hrswrun },
	{ MIB(hrSWRunPath),			OID_TRD, mib_hrswrun },
	{ MIB(hrSWRunParameters),		OID_TRD, mib_hrswrun },
	{ MIB(hrSWRunType),			OID_TRD, mib_hrswrun },
	{ MIB(hrSWRunStatus),			OID_TRD, mib_hrswrun },
	{ MIBEND }
};

int
mib_hrsystemuptime(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct timeval   boottime;
	int		 mib[] = { CTL_KERN, KERN_BOOTTIME };
	time_t		 now;
	size_t		 len;

	(void)time(&now);
	len = sizeof(boottime);

	if (sysctl(mib, 2, &boottime, &len, NULL, 0) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, (now - boottime.tv_sec) * 100);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_TIMETICKS);

	return (0);
}

int
mib_hrsystemdate(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct tm	*ptm;
	u_char		 s[11];
	time_t		 now;
	int		 tzoffset;
	unsigned short	 year;

	(void)time(&now);
	ptm = localtime(&now);

	year = htons(ptm->tm_year + 1900);
	memcpy(s, &year, 2);
	s[2] = ptm->tm_mon + 1;
	s[3] = ptm->tm_mday;
	s[4] = ptm->tm_hour;
	s[5] = ptm->tm_min;
	s[6] = ptm->tm_sec;
	s[7] = 0;

	tzoffset = ptm->tm_gmtoff;
	if (tzoffset < 0)
		s[8] = '-';
	else
		s[8] = '+';

	s[9] = abs(tzoffset) / 3600;
	s[10] = (abs(tzoffset) - (s[9] * 3600)) / 60;

	*elm = ber_add_nstring(*elm, s, sizeof(s));

	return (0);
}

int
mib_hrsystemprocs(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	char		 errbuf[_POSIX2_LINE_MAX];
	int		 val;
	int		 mib[] = { CTL_KERN, KERN_MAXPROC };
	kvm_t		*kd;
	size_t		 len;

	switch (oid->o_oid[OIDIDX_hrsystem]) {
	case 6:
		if ((kd = kvm_openfiles(NULL, NULL, NULL,
		    KVM_NO_FILES, errbuf)) == NULL)
			return (-1);

		if (kvm_getprocs(kd, KERN_PROC_ALL, 0,
		    sizeof(struct kinfo_proc), &val) == NULL)
			return (-1);

		*elm = ber_add_integer(*elm, val);
		ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_GAUGE32);

		kvm_close(kd);
		break;
	case 7:
		len = sizeof(val);
		if (sysctl(mib, 2, &val, &len, NULL, 0) == -1)
			return (-1);

		*elm = ber_add_integer(*elm, val);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
mib_hrmemory(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	int			 mib[] = { CTL_HW, HW_PHYSMEM64 };
	u_int64_t		 physmem;
	size_t			 len = sizeof(physmem);

	if (sysctl(mib, sizeofa(mib), &physmem, &len, NULL, 0) == -1)
		return (-1);

	ber = ber_add_integer(ber, physmem / 1024);

	return (0);
}

int
mib_hrstorage(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	u_int32_t		 idx;
	struct statfs		*mntbuf, *mnt;
	int			 mntsize, maxsize;
	u_int32_t		 units, size, used, fail = 0;
	const char		*descr = NULL;
	int			 mib[] = { CTL_HW, 0 };
	u_int64_t		 physmem, realmem;
	struct uvmexp		 uvm;
	size_t			 len;
	static struct ber_oid	*sop, so[] = {
		{ { MIB_hrStorageOther } },
		{ { MIB_hrStorageRam } },
		{ { MIB_hrStorageVirtualMemory } },
		{ { MIB_hrStorageFixedDisk } }
	};

	/* Physical memory, real memory, swap */
	mib[1] = HW_PHYSMEM64;
	len = sizeof(physmem);
	if (sysctl(mib, sizeofa(mib), &physmem, &len, NULL, 0) == -1)
		return (-1);
	mib[1] = HW_USERMEM64;
	len = sizeof(realmem);
	if (sysctl(mib, sizeofa(mib), &realmem, &len, NULL, 0) == -1)
		return (-1);
	mib[0] = CTL_VM;
	mib[1] = VM_UVMEXP;
	len = sizeof(uvm);
	if (sysctl(mib, sizeofa(mib), &uvm, &len, NULL, 0) == -1)
		return (-1);
	maxsize = 10;

	/* Disks */
	mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
	if (mntsize)
		maxsize = 30 + mntsize;

	/*
	 * Get and verify the current row index.
	 *
	 * We use a special mapping here that is inspired by other SNMP
	 * agents: index 1 + 2 for RAM, index 10 for swap, index 31 and
	 * higher for disk storage.
	 */
	idx = o->bo_id[OIDIDX_hrStorageEntry];
	if (idx > (u_int)maxsize)
		return (1);
	else if (idx > 2 && idx < 10)
		idx = 10;
	else if (idx > 10 && idx < 31)
		idx = 31;

	sop = &so[0];
	switch (idx) {
	case 1:
		descr = "Physical memory";
		units = uvm.pagesize;
		size = physmem / uvm.pagesize;
		used = size - uvm.free;
		sop = &so[1];
		break;
	case 2:
		descr = "Real memory";
		units = uvm.pagesize;
		size = realmem / uvm.pagesize;
		used = size - uvm.free;
		sop = &so[1];
		break;
	case 10:
		descr = "Swap space";
		units = uvm.pagesize;
		size = uvm.swpages;
		used = uvm.swpginuse;
		sop = &so[2];
		break;
	default:
		mnt = &mntbuf[idx - 31];
		descr = mnt->f_mntonname;
		units = mnt->f_bsize;
		size = mnt->f_blocks;
		used = mnt->f_blocks - mnt->f_bfree;
		sop = &so[3];
		break;
	}

	/* Tables need to prepend the OID on their own */
	o->bo_id[OIDIDX_hrStorageEntry] = idx;
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_hrStorage]) {
	case 1: /* hrStorageIndex */
		ber = ber_add_integer(ber, idx);
		break;
	case 2: /* hrStorageType */
		smi_oidlen(sop);
		ber = ber_add_oid(ber, sop);
		break;
	case 3: /* hrStorageDescr */
		ber = ber_add_string(ber, descr);
		break;
	case 4: /* hrStorageAllocationUnits */
		ber = ber_add_integer(ber, units);
		break;
	case 5: /* hrStorageSize */
		ber = ber_add_integer(ber, size);
		break;
	case 6: /* hrStorageUsed */
		ber = ber_add_integer(ber, used);
		break;
	case 7: /* hrStorageAllocationFailures */
		ber = ber_add_integer(ber, fail);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
mib_hrdevice(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	u_int32_t		 idx, fail = 0;
	int			 status;
	int			 mib[] = { CTL_HW, HW_MODEL };
	size_t			 len;
	char			 descr[BUFSIZ];
	static struct ber_oid	*sop, so[] = {
		{ { MIB_hrDeviceProcessor } },
	};

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_hrDeviceEntry];
	if (idx > (u_int)snmpd_env->sc_ncpu)
		return (1);

	/* Tables need to prepend the OID on their own */
	o->bo_id[OIDIDX_hrDeviceEntry] = idx;
	ber = ber_add_oid(ber, o);

	len = sizeof(descr);
	if (sysctl(mib, sizeofa(mib), &descr, &len, NULL, 0) == -1)
		return (-1);
	/* unknown(1), running(2), warning(3), testing(4), down(5) */
	status = 2;
	sop = &so[0];

	switch (o->bo_id[OIDIDX_hrDevice]) {
	case 1: /* hrDeviceIndex */
		ber = ber_add_integer(ber, idx);
		break;
	case 2: /* hrDeviceType */
		smi_oidlen(sop);
		ber = ber_add_oid(ber, sop);
		break;
	case 3: /* hrDeviceDescr */
		ber = ber_add_string(ber, descr);
		break;
	case 4: /* hrDeviceID */
		ber = ber_add_oid(ber, &zerodotzero);
		break;
	case 5: /* hrDeviceStatus */
		ber = ber_add_integer(ber, status);
		break;
	case 6: /* hrDeviceErrors */
		ber = ber_add_integer(ber, fail);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
mib_hrprocessor(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	u_int32_t		 idx;
	int64_t			*cptime2, val;

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_hrDeviceEntry];
	if (idx > (u_int)snmpd_env->sc_ncpu)
		return (1);
	else if (idx < 1)
		idx = 1;

	/* Tables need to prepend the OID on their own */
	o->bo_id[OIDIDX_hrDeviceEntry] = idx;
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_hrDevice]) {
	case 1: /* hrProcessorFrwID */
		ber = ber_add_oid(ber, &zerodotzero);
		break;
	case 2: /* hrProcessorLoad */
		/*
		 * The percentage of time that the system was not
		 * idle during the last minute.
		 */
		if (snmpd_env->sc_cpustates == NULL)
			return (-1);
		cptime2 = snmpd_env->sc_cpustates + (CPUSTATES * (idx - 1));
		val = 100 -
		    (cptime2[CP_IDLE] > 1000 ? 1000 : (cptime2[CP_IDLE] / 10));
		ber = ber_add_integer(ber, val);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
mib_hrswrun(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	struct kinfo_proc	*kinfo;
	char			*s;

	/* Get and verify the current row index */
	if (kinfo_proc(o->bo_id[OIDIDX_hrSWRunEntry], &kinfo) == -1)
		return (1);

	if (kinfo == NULL)
		return (1);

	/* Tables need to prepend the OID on their own */
	o->bo_id[OIDIDX_hrSWRunEntry] = kinfo->p_pid;
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_hrSWRun]) {
	case 1: /* hrSWRunIndex */
		ber = ber_add_integer(ber, kinfo->p_pid);
		break;
	case 2: /* hrSWRunName */
	case 4: /* hrSWRunPath */
		ber = ber_add_string(ber, kinfo->p_comm);
		break;
	case 3: /* hrSWRunID */
		ber = ber_add_oid(ber, &zerodotzero);
		break;
	case 5: /* hrSWRunParameters */
		if (kinfo_args(kinfo, &s) == -1)
			return (-1);

		ber = ber_add_string(ber, s);
		break;
	case 6: /* hrSWRunType */
		if (kinfo->p_flag & P_SYSTEM) {
			/* operatingSystem(2) */
			ber = ber_add_integer(ber, 2);
		} else {
			/* application(4) */
			ber = ber_add_integer(ber, 4);
		}
		break;
	case 7: /* hrSWRunStatus */
		switch (kinfo->p_stat) {
		case SONPROC:
			/* running(1) */
			ber = ber_add_integer(ber, 1);
			break;
		case SIDL:
		case SRUN:
		case SSLEEP:
			/* runnable(2) */
			ber = ber_add_integer(ber, 2);
			break;
		case SSTOP:
			/* notRunnable(3) */
			ber = ber_add_integer(ber, 3);
			break;
		case SDEAD:
		default:
			/* invalid(4) */
			ber = ber_add_integer(ber, 4);
			break;
		}
		break;
	default:
		return (-1);
	}

	return (0);
}

int
kinfo_proc_comp(const void *a, const void *b)
{
	struct kinfo_proc * const *k1 = a;
	struct kinfo_proc * const *k2 = b;

	return (((*k1)->p_pid > (*k2)->p_pid) ? 1 : -1);
}

int
kinfo_proc(u_int32_t idx, struct kinfo_proc **kinfo)
{
	static struct kinfo_proc *kp = NULL;
	static size_t		 nkp = 0;
	int			 mib[] = { CTL_KERN, KERN_PROC,
				    KERN_PROC_ALL, 0, sizeof(*kp), 0 };
	struct kinfo_proc	**klist;
	size_t			 size, count, i;

	for (;;) {
		size = nkp * sizeof(*kp);
		mib[5] = nkp;
		if (sysctl(mib, sizeofa(mib), kp, &size, NULL, 0) == -1) {
			if (errno == ENOMEM) {
				free(kp);
				kp = NULL;
				nkp = 0;
				continue;
			}

			return (-1);
		}

		count = size / sizeof(*kp);
		if (count <= nkp)
			break;

		kp = malloc(size);
		if (kp == NULL) {
			nkp = 0;
			return (-1);
		}
		nkp = count;
	}

	klist = calloc(count, sizeof(*klist));
	if (klist == NULL)
		return (-1);

	for (i = 0; i < count; i++)
		klist[i] = &kp[i];
	qsort(klist, count, sizeof(*klist), kinfo_proc_comp);

	*kinfo = NULL;
	for (i = 0; i < count; i++) {
		if (klist[i]->p_pid >= (int32_t)idx) {
			*kinfo = klist[i];
			break;
		}
	}
	free(klist);

	return (0);
}

int
kinfo_args(struct kinfo_proc *kinfo, char **s)
{
	static char		 str[128];
	static char		*buf = NULL;
	static size_t		 buflen = 128;

	int			 mib[] = { CTL_KERN, KERN_PROC_ARGS,
				    kinfo->p_pid, KERN_PROC_ARGV };
	char			*nbuf, **argv;

	if (buf == NULL) {
		buf = malloc(buflen);
		if (buf == NULL)
			return (-1);
	}

	str[0] = '\0';
	*s = str;

	while (sysctl(mib, sizeofa(mib), buf, &buflen, NULL, 0) == -1) {
		if (errno != ENOMEM) {
			/* some errors are expected, dont get too upset */
			return (0);
		}

		nbuf = realloc(buf, buflen + 128);
		if (nbuf == NULL)
			return (-1);

		buf = nbuf;
		buflen += 128;
	}

	argv = (char **)buf;
	if (argv[0] == NULL)
		return (0);

	argv++;
	while (*argv != NULL) {
		strlcat(str, *argv, sizeof(str));
		argv++;
		if (*argv != NULL)
			strlcat(str, " ", sizeof(str));
	}

	return (0);
}

/*
 * Defined in IF-MIB.txt (RFCs 1229, 1573, 2233, 2863)
 */

int	 mib_ifnumber(struct oid *, struct ber_oid *, struct ber_element **);
struct kif
	*mib_ifget(u_int);
int	 mib_iftable(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_ifxtable(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_ifstacklast(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_ifrcvtable(struct oid *, struct ber_oid *, struct ber_element **);

static u_int8_t ether_zeroaddr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static struct oid if_mib[] = {
	{ MIB(ifMIB),			OID_MIB },
	{ MIB(ifName),			OID_TRD, mib_ifxtable },
	{ MIB(ifInMulticastPkts),	OID_TRD, mib_ifxtable },
	{ MIB(ifInBroadcastPkts),	OID_TRD, mib_ifxtable },
	{ MIB(ifOutMulticastPkts),	OID_TRD, mib_ifxtable },
	{ MIB(ifOutBroadcastPkts),	OID_TRD, mib_ifxtable },
	{ MIB(ifHCInOctets),		OID_TRD, mib_ifxtable },
	{ MIB(ifHCInUcastPkts),		OID_TRD, mib_ifxtable },
	{ MIB(ifHCInMulticastPkts),	OID_TRD, mib_ifxtable },
	{ MIB(ifHCInBroadcastPkts),	OID_TRD, mib_ifxtable },
	{ MIB(ifHCOutOctets),		OID_TRD, mib_ifxtable },
	{ MIB(ifHCOutUcastPkts),	OID_TRD, mib_ifxtable },
	{ MIB(ifHCOutMulticastPkts),	OID_TRD, mib_ifxtable },
	{ MIB(ifHCOutBroadcastPkts),	OID_TRD, mib_ifxtable },
	{ MIB(ifLinkUpDownTrapEnable),	OID_TRD, mib_ifxtable },
	{ MIB(ifHighSpeed),		OID_TRD, mib_ifxtable },
	{ MIB(ifPromiscuousMode),	OID_TRD, mib_ifxtable },
	{ MIB(ifConnectorPresent),	OID_TRD, mib_ifxtable },
	{ MIB(ifAlias),			OID_TRD, mib_ifxtable },
	{ MIB(ifCounterDiscontinuityTime), OID_TRD, mib_ifxtable },
	{ MIB(ifRcvAddressStatus),	OID_TRD, mib_ifrcvtable },
	{ MIB(ifRcvAddressType),	OID_TRD, mib_ifrcvtable },
	{ MIB(ifStackLastChange),	OID_RD, mib_ifstacklast },
	{ MIB(ifNumber),		OID_RD, mib_ifnumber },
	{ MIB(ifIndex),			OID_TRD, mib_iftable },
	{ MIB(ifDescr),			OID_TRD, mib_iftable },
	{ MIB(ifType),			OID_TRD, mib_iftable },
	{ MIB(ifMtu),			OID_TRD, mib_iftable },
	{ MIB(ifSpeed),			OID_TRD, mib_iftable },
	{ MIB(ifPhysAddress),		OID_TRD, mib_iftable },
	{ MIB(ifAdminStatus),		OID_TRD, mib_iftable },
	{ MIB(ifOperStatus),		OID_TRD, mib_iftable },
	{ MIB(ifLastChange),		OID_TRD, mib_iftable },
	{ MIB(ifInOctets),		OID_TRD, mib_iftable },
	{ MIB(ifInUcastPkts),		OID_TRD, mib_iftable },
	{ MIB(ifInNUcastPkts),		OID_TRD, mib_iftable },
	{ MIB(ifInDiscards),		OID_TRD, mib_iftable },
	{ MIB(ifInErrors),		OID_TRD, mib_iftable },
	{ MIB(ifInUnknownProtos),	OID_TRD, mib_iftable },
	{ MIB(ifOutOctets),		OID_TRD, mib_iftable },
	{ MIB(ifOutUcastPkts),		OID_TRD, mib_iftable },
	{ MIB(ifOutNUcastPkts),		OID_TRD, mib_iftable },
	{ MIB(ifOutDiscards),		OID_TRD, mib_iftable },
	{ MIB(ifOutErrors),		OID_TRD, mib_iftable },
	{ MIB(ifOutQLen),		OID_TRD, mib_iftable },
	{ MIB(ifSpecific),		OID_TRD, mib_iftable },
	{ MIBEND }
};

int
mib_ifnumber(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	*elm = ber_add_integer(*elm, kr_ifnumber());
	return (0);
}

struct kif *
mib_ifget(u_int idx)
{
	struct kif	*kif;

	if ((kif = kr_getif(idx)) == NULL) {
		/*
		 * It may happen that an interface with a specific index
		 * does not exist or has been removed. Jump to the next
		 * available interface index.
		 */
		for (kif = kr_getif(0); kif != NULL;
		    kif = kr_getnextif(kif->if_index))
			if (kif->if_index > idx)
				break;
		if (kif == NULL)
			return (NULL);
	}
	idx = kif->if_index;

	/* Update interface information */
	kr_updateif(idx);
	if ((kif = kr_getif(idx)) == NULL) {
		log_debug("mib_ifxtable: interface %d disappeared?", idx);
		return (NULL);
	}

	return (kif);
}

int
mib_iftable(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	u_int32_t		 idx = 0;
	struct kif		*kif;
	long long		 i;
	size_t			 len;
	int			 ifq;
	int			 mib[] = { CTL_NET, PF_INET, IPPROTO_IP, 0, 0 };

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_ifEntry];
	if ((kif = mib_ifget(idx)) == NULL)
		return (1);

	/* Tables need to prepend the OID on their own */
	o->bo_id[OIDIDX_ifEntry] = kif->if_index;
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_if]) {
	case 1:
		ber = ber_add_integer(ber, kif->if_index);
		break;
	case 2:
		/*
		 * The ifDescr should contain a vendor, product, etc.
		 * but we just use the interface name (like ifName).
		 * The interface name includes the driver name on OpenBSD.
		 */
		ber = ber_add_string(ber, kif->if_name);
		break;
	case 3:
		if (kif->if_type >= 0xf0) {
			/*
			 * It does not make sense to announce the private
			 * interface types for CARP, ENC, PFSYNC, etc.
			 */
			ber = ber_add_integer(ber, IFT_OTHER);
		} else
			ber = ber_add_integer(ber, kif->if_type);
		break;
	case 4:
		ber = ber_add_integer(ber, kif->if_mtu);
		break;
	case 5:
		ber = ber_add_integer(ber, kif->if_baudrate);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_GAUGE32);
		break;
	case 6:
		if (bcmp(kif->if_lladdr, ether_zeroaddr,
		    sizeof(kif->if_lladdr)) == 0) {
			ber = ber_add_string(ber, "");
		} else {
			ber = ber_add_nstring(ber, kif->if_lladdr,
			    sizeof(kif->if_lladdr));
		}
		break;
	case 7:
		/* ifAdminStatus up(1), down(2), testing(3) */
		i = (kif->if_flags & IFF_UP) ? 1 : 2;
		ber = ber_add_integer(ber, i);
		break;
	case 8:
		/* ifOperStatus */
		if ((kif->if_flags & IFF_UP) == 0)
			i = 2;	/* down(2) */
		else if (kif->if_link_state == LINK_STATE_UNKNOWN)
			i = 4;	/* unknown(4) */
		else if (LINK_STATE_IS_UP(kif->if_link_state))
			i = 1;	/* up(1) */
		else
			i = 7;	/* lowerLayerDown(7) or dormant(5)? */
		ber = ber_add_integer(ber, i);
		break;
	case 9:
		ber = ber_add_integer(ber, kif->if_ticks);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_TIMETICKS);
		break;
	case 10:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_ibytes);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 11:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_ipackets);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 12:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_imcasts);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 13:
		mib[3] = IPCTL_IFQUEUE;
		mib[4] = IFQCTL_DROPS;
		len = sizeof(ifq);
		if (sysctl(mib, sizeofa(mib), &ifq, &len, 0, 0) == -1) {
			log_info("mib_iftable: %s: invalid ifq: %s",
			    kif->if_name, strerror(errno));
			return (-1);
		}
		ber = ber_add_integer(ber, ifq);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 14:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_ierrors);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 15:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_noproto);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 16:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_obytes);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 17:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_opackets);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 18:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_omcasts);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 19:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_oqdrops);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 20:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_oerrors);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 21:
		mib[3] = IPCTL_IFQUEUE;
		mib[4] = IFQCTL_LEN;
		len = sizeof(ifq);
		if (sysctl(mib, sizeofa(mib), &ifq, &len, 0, 0) == -1) {
			log_info("mib_iftable: %s: invalid ifq: %s",
			    kif->if_name, strerror(errno));
			return (-1);
		}
		ber = ber_add_integer(ber, ifq);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_GAUGE32);
		break;
	case 22:
		ber = ber_add_oid(ber, &zerodotzero);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
mib_ifxtable(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	u_int32_t		 idx = 0;
	struct kif		*kif;
	int			 i = 0;

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_ifXEntry];
	if ((kif = mib_ifget(idx)) == NULL)
		return (1);

	/* Tables need to prepend the OID on their own */
	o->bo_id[OIDIDX_ifXEntry] = kif->if_index;
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_ifX]) {
	case 1:
		ber = ber_add_string(ber, kif->if_name);
		break;
	case 2:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_imcasts);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 3:
		ber = ber_add_integer(ber, 0);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 4:
		ber = ber_add_integer(ber, (u_int32_t)kif->if_omcasts);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 5:
		ber = ber_add_integer(ber, 0);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 6:
		ber = ber_add_integer(ber, (u_int64_t)kif->if_ibytes);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 7:
		ber = ber_add_integer(ber, (u_int64_t)kif->if_ipackets);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 8:
		ber = ber_add_integer(ber, (u_int64_t)kif->if_imcasts);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 9:
		ber = ber_add_integer(ber, 0);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 10:
		ber = ber_add_integer(ber, (u_int64_t)kif->if_obytes);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 11:
		ber = ber_add_integer(ber, (u_int64_t)kif->if_opackets);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 12:
		ber = ber_add_integer(ber, (u_int64_t)kif->if_omcasts);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 13:
		ber = ber_add_integer(ber, 0);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 14:
		ber = ber_add_integer(ber, 0);	/* enabled(1), disabled(2) */
		break;
	case 15:
		i = kif->if_baudrate >= 1000000 ?
		    kif->if_baudrate / 1000000 : 0;
		ber = ber_add_integer(ber, i);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_GAUGE32);
		break;
	case 16:
		/* ifPromiscuousMode: true(1), false(2) */
		i = kif->if_flags & IFF_PROMISC ? 1 : 2;
		ber = ber_add_integer(ber, i);
		break;
	case 17:
		/* ifConnectorPresent: false(2), true(1) */
		i = kif->if_type == IFT_ETHER ? 1 : 2;
		ber = ber_add_integer(ber, i);
		break;
	case 18:
		ber = ber_add_string(ber, kif->if_descr);
		break;
	case 19:
		ber = ber_add_integer(ber, 0);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_TIMETICKS);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
mib_ifstacklast(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	ber = ber_add_integer(ber, kr_iflastchange());
	ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_TIMETICKS);
	return (0);
}

int
mib_ifrcvtable(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	u_int32_t		 idx = 0;
	struct kif		*kif;
	u_int			 i = 0;

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_ifRcvAddressEntry];
	if ((kif = mib_ifget(idx)) == NULL)
		return (1);

	/*
	 * The lladdr of the interface will be encoded in the returned OID
	 * ifRcvAddressX.ifindex.6.x.x.x.x.x.x = val
	 * Thanks to the virtual cloner interfaces, it is an easy 1:1
	 * mapping in OpenBSD; only one lladdr (MAC) address per interface.
	 */

	/* first set the base OID and caluculate the length */
	idx = 0;
	o->bo_id[OIDIDX_ifRcvAddressEntry + idx++] = kif->if_index;
	o->bo_id[OIDIDX_ifRcvAddressEntry + idx] = 0;
	smi_oidlen(o);

	/* extend the OID with the lladdr length and octets */
	o->bo_id[OIDIDX_ifRcvAddressEntry + idx++] = sizeof(kif->if_lladdr);
	o->bo_n++;
	for (i = 0; i < sizeof(kif->if_lladdr); i++, o->bo_n++)
		o->bo_id[OIDIDX_ifRcvAddressEntry + idx++] = kif->if_lladdr[i];

	/* write OID */
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_ifRcvAddress]) {
	case 2:
		/* ifRcvAddressStatus: RowStatus active(1), notInService(2) */
		i = kif->if_flags & IFF_UP ? 1 : 2;
		ber = ber_add_integer(ber, i);
		break;
	case 3:
		/* ifRcvAddressType: other(1), volatile(2), nonVolatile(3) */
		ber = ber_add_integer(ber, 1);
		break;
	default:
		return (-1);
	}

	return (0);
}

/*
 * Defined in 
 * - OPENBSD-PF-MIB.txt
 * - OPENBSD-SENSORS-MIB.txt
 * - OPENBSD-CARP-MIB.txt
 * (http://www.packetmischief.ca/openbsd-snmp-mibs/)
 */ 

struct carpif {
	struct carpreq	 carpr;
	struct kif	 kif;
};

int	 mib_pfinfo(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pfcounters(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pfscounters(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pflogif(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pfsrctrack(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pflimits(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pftimeouts(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pfifnum(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pfiftable(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pftablenum(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pftables(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pftableaddrs(struct oid *, struct ber_oid *, struct ber_element **);
struct ber_oid *
	 mib_pftableaddrstable(struct oid *, struct ber_oid *, struct ber_oid *);
int	 mib_pflabelnum(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pflabels(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_pfsyncstats(struct oid *, struct ber_oid *, struct ber_element **);

int	 mib_sensornum(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_sensors(struct oid *, struct ber_oid *, struct ber_element **);
const char *mib_sensorunit(struct sensor *);
char	*mib_sensorvalue(struct sensor *);

int	 mib_carpsysctl(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_carpstats(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_carpiftable(struct oid *, struct ber_oid *, struct ber_element **);
int	 mib_carpifnum(struct oid *, struct ber_oid *, struct ber_element **);
struct carpif
	*mib_carpifget(u_int);
int	 mib_memiftable(struct oid *, struct ber_oid *, struct ber_element **);

static struct oid openbsd_mib[] = {
	{ MIB(pfMIBObjects),		OID_MIB },
	{ MIB(pfRunning),		OID_RD, mib_pfinfo },
	{ MIB(pfRuntime),		OID_RD, mib_pfinfo },
	{ MIB(pfDebug),			OID_RD, mib_pfinfo },
	{ MIB(pfHostid),		OID_RD, mib_pfinfo },
	{ MIB(pfCntMatch),		OID_RD, mib_pfcounters },
	{ MIB(pfCntBadOffset),		OID_RD, mib_pfcounters },
	{ MIB(pfCntFragment),		OID_RD, mib_pfcounters },
	{ MIB(pfCntShort),		OID_RD, mib_pfcounters },
	{ MIB(pfCntNormalize),		OID_RD, mib_pfcounters },
	{ MIB(pfCntMemory),		OID_RD, mib_pfcounters },
	{ MIB(pfCntTimestamp),		OID_RD, mib_pfcounters },
	{ MIB(pfCntCongestion),		OID_RD, mib_pfcounters },
	{ MIB(pfCntIpOptions),		OID_RD, mib_pfcounters },
	{ MIB(pfCntProtoCksum),		OID_RD, mib_pfcounters },
	{ MIB(pfCntStateMismatch),	OID_RD, mib_pfcounters },
	{ MIB(pfCntStateInsert),	OID_RD, mib_pfcounters },
	{ MIB(pfCntStateLimit),		OID_RD, mib_pfcounters },
	{ MIB(pfCntSrcLimit),		OID_RD, mib_pfcounters },
	{ MIB(pfCntSynproxy),		OID_RD, mib_pfcounters },
	{ MIB(pfCntTranslate),		OID_RD, mib_pfcounters },
	{ MIB(pfCntNoRoute),		OID_RD, mib_pfcounters },
	{ MIB(pfStateCount),		OID_RD, mib_pfscounters },
	{ MIB(pfStateSearches),		OID_RD, mib_pfscounters },
	{ MIB(pfStateInserts),		OID_RD, mib_pfscounters },
	{ MIB(pfStateRemovals),		OID_RD, mib_pfscounters },
	{ MIB(pfLogIfName),		OID_RD, mib_pflogif },
	{ MIB(pfLogIfIpBytesIn),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIpBytesOut),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIpPktsInPass),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIpPktsInDrop),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIpPktsOutPass),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIpPktsOutDrop),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIp6BytesIn),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIp6BytesOut),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIp6PktsInPass),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIp6PktsInDrop),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIp6PktsOutPass),	OID_RD, mib_pflogif },
	{ MIB(pfLogIfIp6PktsOutDrop),	OID_RD, mib_pflogif },
	{ MIB(pfSrcTrackCount),		OID_RD, mib_pfsrctrack },
	{ MIB(pfSrcTrackSearches),	OID_RD, mib_pfsrctrack },
	{ MIB(pfSrcTrackInserts),	OID_RD, mib_pfsrctrack },
	{ MIB(pfSrcTrackRemovals),	OID_RD, mib_pfsrctrack },
	{ MIB(pfLimitStates),		OID_RD, mib_pflimits },
	{ MIB(pfLimitSourceNodes),	OID_RD, mib_pflimits },
	{ MIB(pfLimitFragments),	OID_RD, mib_pflimits },
	{ MIB(pfLimitMaxTables),	OID_RD, mib_pflimits },
	{ MIB(pfLimitMaxTableEntries),	OID_RD, mib_pflimits },
	{ MIB(pfTimeoutTcpFirst),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutTcpOpening),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutTcpEstablished),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutTcpClosing),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutTcpFinWait),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutTcpClosed),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutUdpFirst),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutUdpSingle),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutUdpMultiple),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutIcmpFirst),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutIcmpError),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutOtherFirst),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutOtherSingle),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutOtherMultiple),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutFragment),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutInterval),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutAdaptiveStart),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutAdaptiveEnd),	OID_RD, mib_pftimeouts },
	{ MIB(pfTimeoutSrcTrack),	OID_RD, mib_pftimeouts },
	{ MIB(pfIfNumber),		OID_RD, mib_pfifnum },
	{ MIB(pfIfIndex),		OID_TRD, mib_pfiftable },
	{ MIB(pfIfDescr),		OID_TRD, mib_pfiftable },
	{ MIB(pfIfType),		OID_TRD, mib_pfiftable },
	{ MIB(pfIfRefs),		OID_TRD, mib_pfiftable },
	{ MIB(pfIfRules),		OID_TRD, mib_pfiftable },
	{ MIB(pfIfIn4PassPkts),		OID_TRD, mib_pfiftable },
	{ MIB(pfIfIn4PassBytes),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfIn4BlockPkts),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfIn4BlockBytes),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfOut4PassPkts),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfOut4PassBytes),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfOut4BlockPkts),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfOut4BlockBytes),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfIn6PassPkts),		OID_TRD, mib_pfiftable },
	{ MIB(pfIfIn6PassBytes),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfIn6BlockPkts),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfIn6BlockBytes),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfOut6PassPkts),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfOut6PassBytes),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfOut6BlockPkts),	OID_TRD, mib_pfiftable },
	{ MIB(pfIfOut6BlockBytes),	OID_TRD, mib_pfiftable },
	{ MIB(pfTblNumber),		OID_RD, mib_pftablenum },
	{ MIB(pfTblIndex),		OID_TRD, mib_pftables },
	{ MIB(pfTblName),		OID_TRD, mib_pftables },
	{ MIB(pfTblAddresses),		OID_TRD, mib_pftables },
	{ MIB(pfTblAnchorRefs),		OID_TRD, mib_pftables },
	{ MIB(pfTblRuleRefs),		OID_TRD, mib_pftables },
	{ MIB(pfTblEvalsMatch),		OID_TRD, mib_pftables },
	{ MIB(pfTblEvalsNoMatch),	OID_TRD, mib_pftables },
	{ MIB(pfTblInPassPkts),		OID_TRD, mib_pftables },
	{ MIB(pfTblInPassBytes),	OID_TRD, mib_pftables },
	{ MIB(pfTblInBlockPkts),	OID_TRD, mib_pftables },
	{ MIB(pfTblInBlockBytes),	OID_TRD, mib_pftables },
	{ MIB(pfTblInXPassPkts),	OID_TRD, mib_pftables },
	{ MIB(pfTblInXPassBytes),	OID_TRD, mib_pftables },
	{ MIB(pfTblOutPassPkts),	OID_TRD, mib_pftables },
	{ MIB(pfTblOutPassBytes),	OID_TRD, mib_pftables },
	{ MIB(pfTblOutBlockPkts),	OID_TRD, mib_pftables },
	{ MIB(pfTblOutBlockBytes),	OID_TRD, mib_pftables },
	{ MIB(pfTblOutXPassPkts),	OID_TRD, mib_pftables },
	{ MIB(pfTblOutXPassBytes),	OID_TRD, mib_pftables },
	{ MIB(pfTblStatsCleared),	OID_TRD, mib_pftables },
	{ MIB(pfTblInMatchPkts),	OID_TRD, mib_pftables },
	{ MIB(pfTblInMatchBytes),	OID_TRD, mib_pftables },
	{ MIB(pfTblOutMatchPkts),	OID_TRD, mib_pftables },
	{ MIB(pfTblOutMatchBytes),	OID_TRD, mib_pftables },
	{ MIB(pfTblAddrTblIndex),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrNet),		OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrMask),		OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrCleared),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrInBlockPkts),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrInBlockBytes),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrInPassPkts),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrInPassBytes),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrOutBlockPkts),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrOutBlockBytes),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrOutPassPkts),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrOutPassBytes),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrInMatchPkts),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrInMatchBytes),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrOutMatchPkts),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfTblAddrOutMatchBytes),	OID_TRD, mib_pftableaddrs,
	    NULL, mib_pftableaddrstable },
	{ MIB(pfLabelNumber),		OID_RD, mib_pflabelnum },
	{ MIB(pfLabelIndex),		OID_TRD, mib_pflabels },
	{ MIB(pfLabelName),		OID_TRD, mib_pflabels },
	{ MIB(pfLabelEvals),		OID_TRD, mib_pflabels },
	{ MIB(pfLabelPkts),		OID_TRD, mib_pflabels },
	{ MIB(pfLabelBytes),		OID_TRD, mib_pflabels },
	{ MIB(pfLabelInPkts),		OID_TRD, mib_pflabels },
	{ MIB(pfLabelInBytes),		OID_TRD, mib_pflabels },
	{ MIB(pfLabelOutPkts),		OID_TRD, mib_pflabels },
	{ MIB(pfLabelOutBytes),		OID_TRD, mib_pflabels },
	{ MIB(pfLabelTotalStates),	OID_TRD, mib_pflabels },
	{ MIB(pfsyncIpPktsRecv),	OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncIp6PktsRecv),	OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncPktDiscardsForBadInterface), OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncPktDiscardsForBadTtl), OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncPktShorterThanHeader), OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncPktDiscardsForBadVersion), OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncPktDiscardsForBadAction), OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncPktDiscardsForBadLength), OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncPktDiscardsForBadAuth), OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncPktDiscardsForStaleState), OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncPktDiscardsForBadValues), OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncPktDiscardsForBadState), OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncIpPktsSent),	OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncIp6PktsSent),	OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncNoMemory),		OID_RD, mib_pfsyncstats },
	{ MIB(pfsyncOutputErrors),	OID_RD, mib_pfsyncstats },
	{ MIB(sensorsMIBObjects),	OID_MIB },
	{ MIB(sensorNumber),		OID_RD,	mib_sensornum },
	{ MIB(sensorIndex),		OID_TRD, mib_sensors },
	{ MIB(sensorDescr),		OID_TRD, mib_sensors },
	{ MIB(sensorType),		OID_TRD, mib_sensors },
	{ MIB(sensorDevice),		OID_TRD, mib_sensors },
	{ MIB(sensorValue),		OID_TRD, mib_sensors },
	{ MIB(sensorUnits),		OID_TRD, mib_sensors },
	{ MIB(sensorStatus),		OID_TRD, mib_sensors },
	{ MIB(carpMIBObjects),		OID_MIB },
	{ MIB(carpAllow),		OID_RD, mib_carpsysctl },
	{ MIB(carpPreempt),		OID_RD, mib_carpsysctl },
	{ MIB(carpLog),			OID_RD, mib_carpsysctl },
	{ MIB(carpIpPktsRecv),		OID_RD, mib_carpstats },
	{ MIB(carpIp6PktsRecv),		OID_RD, mib_carpstats },
	{ MIB(carpPktDiscardsBadIface),	OID_RD, mib_carpstats },
	{ MIB(carpPktDiscardsBadTtl),	OID_RD, mib_carpstats },
	{ MIB(carpPktShorterThanHdr),	OID_RD, mib_carpstats },
	{ MIB(carpDiscardsBadCksum),	OID_RD, mib_carpstats },
	{ MIB(carpDiscardsBadVersion),	OID_RD, mib_carpstats },
	{ MIB(carpDiscardsTooShort),	OID_RD, mib_carpstats },
	{ MIB(carpDiscardsBadAuth),	OID_RD, mib_carpstats },
	{ MIB(carpDiscardsBadVhid),	OID_RD, mib_carpstats },
	{ MIB(carpDiscardsBadAddrList),	OID_RD, mib_carpstats },
	{ MIB(carpIpPktsSent),		OID_RD, mib_carpstats },
	{ MIB(carpIp6PktsSent),		OID_RD, mib_carpstats },
	{ MIB(carpNoMemory),		OID_RD, mib_carpstats },
	{ MIB(carpTransitionsToMaster),	OID_RD, mib_carpstats },
	{ MIB(carpIfNumber),		OID_RD, mib_carpifnum },
	{ MIB(carpIfIndex),		OID_TRD, mib_carpiftable },
	{ MIB(carpIfDescr),		OID_TRD, mib_carpiftable },
	{ MIB(carpIfVhid),		OID_TRD, mib_carpiftable },
	{ MIB(carpIfDev	),		OID_TRD, mib_carpiftable },
	{ MIB(carpIfAdvbase),		OID_TRD, mib_carpiftable },
	{ MIB(carpIfAdvskew),		OID_TRD, mib_carpiftable },
	{ MIB(carpIfState),		OID_TRD, mib_carpiftable },
	{ MIB(memMIBObjects),		OID_MIB },
	{ MIB(memMIBVersion),		OID_RD, mps_getint, NULL, NULL,
	    OIDVER_OPENBSD_MEM },
	{ MIB(memIfName),		OID_TRD, mib_memiftable },
	{ MIB(memIfLiveLocks),		OID_TRD, mib_memiftable },
	{ MIBEND }
};

int
mib_pfinfo(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct pf_status	 s;
	time_t			 runtime;
	char			 str[11];

	if (pf_get_stats(&s))
		return (-1);

	switch (oid->o_oid[OIDIDX_pfstatus]) {
	case 1:
		*elm = ber_add_integer(*elm, s.running);
		break;
	case 2:
		if (s.since > 0)
			runtime = time(NULL) - s.since;
		else
			runtime = 0;
		runtime *= 100;
		*elm = ber_add_integer(*elm, runtime);
		ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_TIMETICKS);
		break;
	case 3:
		*elm = ber_add_integer(*elm, s.debug);
		break;
	case 4:
		snprintf(str, sizeof(str), "0x%08x", ntohl(s.hostid));
		*elm = ber_add_string(*elm, str);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
mib_pfcounters(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct pf_status	 s;
	int			 i;
	struct statsmap {
		u_int8_t	 m_id;
		u_int64_t	*m_ptr;
	}			 mapping[] = {
		{ 1, &s.counters[PFRES_MATCH] },
		{ 2, &s.counters[PFRES_BADOFF] },
		{ 3, &s.counters[PFRES_FRAG] },
		{ 4, &s.counters[PFRES_SHORT] },
		{ 5, &s.counters[PFRES_NORM] },
		{ 6, &s.counters[PFRES_MEMORY] },
		{ 7, &s.counters[PFRES_TS] },
		{ 8, &s.counters[PFRES_CONGEST] },
		{ 9, &s.counters[PFRES_IPOPTIONS] },
		{ 10, &s.counters[PFRES_PROTCKSUM] },
		{ 11, &s.counters[PFRES_BADSTATE] },
		{ 12, &s.counters[PFRES_STATEINS] },
		{ 13, &s.counters[PFRES_MAXSTATES] },
		{ 14, &s.counters[PFRES_SRCLIMIT] },
		{ 15, &s.counters[PFRES_SYNPROXY] },
		{ 16, &s.counters[PFRES_TRANSLATE] },
		{ 17, &s.counters[PFRES_NOROUTE] }
	};

	if (pf_get_stats(&s))
		return (-1);

	for (i = 0;
	    (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
		if (oid->o_oid[OIDIDX_pfstatus] == mapping[i].m_id) {
			*elm = ber_add_integer(*elm, *mapping[i].m_ptr);
			ber_set_header(*elm, BER_CLASS_APPLICATION,
			    SNMP_T_COUNTER64);
			return (0);
		}
	}
	return (-1);
}

int
mib_pfscounters(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct pf_status	 s;
	int			 i;
	struct statsmap {
		u_int8_t	 m_id;
		u_int64_t	*m_ptr;
	}			 mapping[] = {
		{ 2, &s.fcounters[FCNT_STATE_SEARCH] },
		{ 3, &s.fcounters[FCNT_STATE_INSERT] },
		{ 4, &s.fcounters[FCNT_STATE_REMOVALS] },
	};

	if (pf_get_stats(&s))
		return (-1);

	switch (oid->o_oid[OIDIDX_pfstatus]) {
	case 1:
		*elm = ber_add_integer(*elm, s.states);
		ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_UNSIGNED32);
		break;
	default:
		for (i = 0;
		    (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
			if (oid->o_oid[OIDIDX_pfstatus] == mapping[i].m_id) {
				*elm = ber_add_integer(*elm, *mapping[i].m_ptr);
				ber_set_header(*elm, BER_CLASS_APPLICATION,
				    SNMP_T_COUNTER64);
				return (0);
			}
		}
		return (-1);
	}

	return (0);
}

int
mib_pflogif(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct pf_status	 s;
	int			 i;
	struct statsmap {
		u_int8_t	 m_id;
		u_int64_t	*m_ptr;
	}			 mapping[] = {
		{ 2, &s.bcounters[IPV4][IN] },
		{ 3, &s.bcounters[IPV4][OUT] },
		{ 4, &s.pcounters[IPV4][IN][PF_PASS] },
		{ 5, &s.pcounters[IPV4][IN][PF_DROP] },
		{ 6, &s.pcounters[IPV4][OUT][PF_PASS] },
		{ 7, &s.pcounters[IPV4][OUT][PF_DROP] },
		{ 8, &s.bcounters[IPV6][IN] },
		{ 9, &s.bcounters[IPV6][OUT] },
		{ 10, &s.pcounters[IPV6][IN][PF_PASS] },
		{ 11, &s.pcounters[IPV6][IN][PF_DROP] },
		{ 12, &s.pcounters[IPV6][OUT][PF_PASS] },
		{ 13, &s.pcounters[IPV6][OUT][PF_DROP] }
	};

	if (pf_get_stats(&s))
		return (-1);

	switch (oid->o_oid[OIDIDX_pfstatus]) {
	case 1:
		*elm = ber_add_string(*elm, s.ifname);
		break;
	default:
		for (i = 0;
		    (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
			if (oid->o_oid[OIDIDX_pfstatus] == mapping[i].m_id) {
				*elm = ber_add_integer(*elm, *mapping[i].m_ptr);
				ber_set_header(*elm, BER_CLASS_APPLICATION,
				    SNMP_T_COUNTER64);
				return (0);
			}
		}
		return (-1);
	}

	return (0);
}

int
mib_pfsrctrack(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct pf_status	 s;
	int			 i;
	struct statsmap {
		u_int8_t	 m_id;
		u_int64_t	*m_ptr;
	}			 mapping[] = {
		{ 2, &s.scounters[SCNT_SRC_NODE_SEARCH] },
		{ 3, &s.scounters[SCNT_SRC_NODE_INSERT] },
		{ 4, &s.scounters[SCNT_SRC_NODE_REMOVALS] }
	};

	if (pf_get_stats(&s))
		return (-1);

	switch (oid->o_oid[OIDIDX_pfstatus]) {
	case 1:
		*elm = ber_add_integer(*elm, s.src_nodes);
		ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_UNSIGNED32);
		break;
	default:
		for (i = 0;
		    (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
			if (oid->o_oid[OIDIDX_pfstatus] == mapping[i].m_id) {
				*elm = ber_add_integer(*elm, *mapping[i].m_ptr);
				ber_set_header(*elm, BER_CLASS_APPLICATION,
				    SNMP_T_COUNTER64);
				return (0);
			}
		}
		return (-1);
	}

	return (0);
}

int
mib_pflimits(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct pfioc_limit	 pl;
	int			 i;
	extern int		 devpf;
	struct statsmap {
		u_int8_t	 m_id;
		u_int8_t	 m_limit;
	}			 mapping[] = {
		{ 1, PF_LIMIT_STATES },
		{ 2, PF_LIMIT_SRC_NODES },
		{ 3, PF_LIMIT_FRAGS },
		{ 4, PF_LIMIT_TABLES },
		{ 5, PF_LIMIT_TABLE_ENTRIES }
	};

	memset(&pl, 0, sizeof(pl));
	pl.index = PF_LIMIT_MAX;

	for (i = 0;
	    (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
		if (oid->o_oid[OIDIDX_pfstatus] == mapping[i].m_id) {
			pl.index = mapping[i].m_limit;
			break;
		}
	}

	if (pl.index == PF_LIMIT_MAX)
		return (-1);

	if (ioctl(devpf, DIOCGETLIMIT, &pl)) {
		log_warn("DIOCGETLIMIT");
		return (-1);
	}

	*elm = ber_add_integer(*elm, pl.limit);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_UNSIGNED32);

	return (0);
}

int
mib_pftimeouts(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct pfioc_tm		 pt;
	int			 i;
	extern int		 devpf;
	struct statsmap {
		u_int8_t	 m_id;
		u_int8_t	 m_tm;
	}			 mapping[] = {
		{ 1, PFTM_TCP_FIRST_PACKET },
		{ 2, PFTM_TCP_OPENING },
		{ 3, PFTM_TCP_ESTABLISHED },
		{ 4, PFTM_TCP_CLOSING },
		{ 5, PFTM_TCP_FIN_WAIT },
		{ 6, PFTM_TCP_CLOSED },
		{ 7, PFTM_UDP_FIRST_PACKET },
		{ 8, PFTM_UDP_SINGLE },
		{ 9, PFTM_UDP_MULTIPLE },
		{ 10, PFTM_ICMP_FIRST_PACKET },
		{ 11, PFTM_ICMP_ERROR_REPLY },
		{ 12, PFTM_OTHER_FIRST_PACKET },
		{ 13, PFTM_OTHER_SINGLE },
		{ 14, PFTM_OTHER_MULTIPLE },
		{ 15, PFTM_FRAG },
		{ 16, PFTM_INTERVAL },
		{ 17, PFTM_ADAPTIVE_START },
		{ 18, PFTM_ADAPTIVE_END },
		{ 19, PFTM_SRC_NODE }
	};

	memset(&pt, 0, sizeof(pt));
	pt.timeout = PFTM_MAX;

	for (i = 0;
	    (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
		if (oid->o_oid[OIDIDX_pfstatus] == mapping[i].m_id) {
			pt.timeout = mapping[i].m_tm;
			break;
		}
	}

	if (pt.timeout == PFTM_MAX)
		return (-1);

	if (ioctl(devpf, DIOCGETTIMEOUT, &pt)) {
		log_warn("DIOCGETTIMEOUT");
		return (-1);
	}

	*elm = ber_add_integer(*elm, pt.seconds);

	return (0);
}

int
mib_pfifnum(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	int	 c;

	if ((c = pfi_count()) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, c);

	return (0);
}

int
mib_pfiftable(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	struct pfi_kif		 pif;
	int			 idx, iftype;

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_pfIfEntry];

	if (pfi_get_if(&pif, idx))
		return (1);

	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_pfInterface]) {
	case 1:
		ber = ber_add_integer(ber, idx);
		break;
	case 2:
		ber = ber_add_string(ber, pif.pfik_name);
		break;
	case 3:
		iftype = (pif.pfik_ifp == NULL ? PFI_IFTYPE_GROUP
		    : PFI_IFTYPE_INSTANCE);
		ber = ber_add_integer(ber, iftype);
		break;
	case 4:
		ber = ber_add_integer(ber, pif.pfik_states);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_UNSIGNED32);
		break;
	case 5:
		ber = ber_add_integer(ber, pif.pfik_rules);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_UNSIGNED32);
		break;
	case 6:
		ber = ber_add_integer(ber, pif.pfik_packets[IPV4][IN][PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 7:
		ber = ber_add_integer(ber, pif.pfik_bytes[IPV4][IN][PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 8:
		ber = ber_add_integer(ber, pif.pfik_packets[IPV4][IN][BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 9:
		ber = ber_add_integer(ber, pif.pfik_bytes[IPV4][IN][BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 10:
		ber = ber_add_integer(ber, pif.pfik_packets[IPV4][OUT][PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 11:
		ber = ber_add_integer(ber, pif.pfik_bytes[IPV4][OUT][PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 12:
		ber = ber_add_integer(ber, pif.pfik_packets[IPV4][OUT][BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 13:
		ber = ber_add_integer(ber, pif.pfik_bytes[IPV4][OUT][BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 14:
		ber = ber_add_integer(ber, pif.pfik_packets[IPV6][IN][PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 15:
		ber = ber_add_integer(ber, pif.pfik_bytes[IPV6][IN][PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 16:
		ber = ber_add_integer(ber, pif.pfik_packets[IPV6][IN][BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 17:
		ber = ber_add_integer(ber, pif.pfik_bytes[IPV6][IN][BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 18:
		ber = ber_add_integer(ber, pif.pfik_packets[IPV6][OUT][PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 19:
		ber = ber_add_integer(ber, pif.pfik_bytes[IPV6][OUT][PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 20:
		ber = ber_add_integer(ber, pif.pfik_packets[IPV6][OUT][BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 21:
		ber = ber_add_integer(ber, pif.pfik_bytes[IPV6][OUT][BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	default:
		return (1);
	}

	return (0);
}

int
mib_pftablenum(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	int	 c;

	if ((c = pft_count()) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, c);

	return (0);
}

int
mib_pftables(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	struct pfr_tstats	 ts;
	time_t			 tzero;
	int			 idx;

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_pfTableEntry];

	if (pft_get_table(&ts, idx))
		return (1);

	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_pfTable]) {
	case 1:
		ber = ber_add_integer(ber, idx);
		break;
	case 2:
		ber = ber_add_string(ber, ts.pfrts_name);
		break;
	case 3:
		ber = ber_add_integer(ber, ts.pfrts_cnt);
		break;
	case 4:
		ber = ber_add_integer(ber, ts.pfrts_refcnt[PFR_REFCNT_ANCHOR]);
		break;
	case 5:
		ber = ber_add_integer(ber, ts.pfrts_refcnt[PFR_REFCNT_RULE]);
		break;
	case 6:
		ber = ber_add_integer(ber, ts.pfrts_match);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 7:
		ber = ber_add_integer(ber, ts.pfrts_nomatch);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 8:
		ber = ber_add_integer(ber, ts.pfrts_packets[IN][PFR_OP_PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 9:
		ber = ber_add_integer(ber, ts.pfrts_bytes[IN][PFR_OP_PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 10:
		ber = ber_add_integer(ber, ts.pfrts_packets[IN][PFR_OP_BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 11:
		ber = ber_add_integer(ber, ts.pfrts_bytes[IN][PFR_OP_BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 12:
		ber = ber_add_integer(ber, ts.pfrts_packets[IN][PFR_OP_XPASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 13:
		ber = ber_add_integer(ber, ts.pfrts_bytes[IN][PFR_OP_XPASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 14:
		ber = ber_add_integer(ber, ts.pfrts_packets[OUT][PFR_OP_PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 15:
		ber = ber_add_integer(ber, ts.pfrts_bytes[OUT][PFR_OP_PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 16:
		ber = ber_add_integer(ber, ts.pfrts_packets[OUT][PFR_OP_BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 17:
		ber = ber_add_integer(ber, ts.pfrts_bytes[OUT][PFR_OP_BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 18:
		ber = ber_add_integer(ber, ts.pfrts_packets[OUT][PFR_OP_XPASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 19:
		ber = ber_add_integer(ber, ts.pfrts_bytes[OUT][PFR_OP_XPASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 20:
		tzero = (time(NULL) - ts.pfrts_tzero) * 100;
		ber = ber_add_integer(ber, tzero);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_TIMETICKS);
		break;
	case 21:
		ber = ber_add_integer(ber, ts.pfrts_packets[IN][PFR_OP_MATCH]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 22:
		ber = ber_add_integer(ber, ts.pfrts_bytes[IN][PFR_OP_MATCH]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 23:
		ber = ber_add_integer(ber, ts.pfrts_packets[OUT][PFR_OP_MATCH]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 24:
		ber = ber_add_integer(ber, ts.pfrts_bytes[OUT][PFR_OP_MATCH]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	default:
		return (1);
	}

	return (0);
}

int
mib_pftableaddrs(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	struct pfr_astats	 as;
	int			 tblidx;

	tblidx = o->bo_id[OIDIDX_pfTblAddr + 1];
	mps_decodeinaddr(o, &as.pfras_a.pfra_ip4addr, OIDIDX_pfTblAddr + 2);
	as.pfras_a.pfra_net = o->bo_id[OIDIDX_pfTblAddr + 6];

	if (pfta_get_addr(&as, tblidx))
		return (-1);

	/* write OID */
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_pfTblAddr]) {
	case 1:
		ber = ber_add_integer(ber, tblidx);
		break;
	case 2:
		ber = ber_add_nstring(ber, (char *)&as.pfras_a.pfra_ip4addr,
		    sizeof(u_int32_t));
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_IPADDR);
		break;
	case 3:
		ber = ber_add_integer(ber, as.pfras_a.pfra_net);
		break;
	case 4:
		ber = ber_add_integer(ber, (time(NULL) - as.pfras_tzero) * 100);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_TIMETICKS);
		break;
	case 5:
		ber = ber_add_integer(ber, as.pfras_packets[IN][PFR_OP_BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 6:
		ber = ber_add_integer(ber, as.pfras_bytes[IN][PFR_OP_BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 7:
		ber = ber_add_integer(ber, as.pfras_packets[IN][PFR_OP_PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 8:
		ber = ber_add_integer(ber, as.pfras_bytes[IN][PFR_OP_PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 9:
		ber = ber_add_integer(ber, as.pfras_packets[OUT][PFR_OP_BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 10:
		ber = ber_add_integer(ber, as.pfras_bytes[OUT][PFR_OP_BLOCK]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 11:
		ber = ber_add_integer(ber, as.pfras_packets[OUT][PFR_OP_PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 12:
		ber = ber_add_integer(ber, as.pfras_bytes[OUT][PFR_OP_PASS]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 13:
		ber = ber_add_integer(ber, as.pfras_packets[IN][PFR_OP_MATCH]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 14:
		ber = ber_add_integer(ber, as.pfras_bytes[IN][PFR_OP_MATCH]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 15:
		ber = ber_add_integer(ber, as.pfras_packets[OUT][PFR_OP_MATCH]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 16:
		ber = ber_add_integer(ber, as.pfras_bytes[OUT][PFR_OP_MATCH]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	default:
		return (-1);
	}

	return (0);
}

struct ber_oid *
mib_pftableaddrstable(struct oid *oid, struct ber_oid *o, struct ber_oid *no)
{
	struct pfr_astats	 as;
	struct oid		 a, b;
	u_int32_t		 id, tblidx;

	bcopy(&oid->o_id, no, sizeof(*no));
	id = oid->o_oidlen - 1;

	if (o->bo_n >= oid->o_oidlen) {
		/*
		 * Compare the requested and the matched OID to see
		 * if we have to iterate to the next element.
		 */
		bzero(&a, sizeof(a));
		bcopy(o, &a.o_id, sizeof(struct ber_oid));
		bzero(&b, sizeof(b));
		bcopy(&oid->o_id, &b.o_id, sizeof(struct ber_oid));
		b.o_oidlen--;
		b.o_flags |= OID_TABLE;
		if (smi_oid_cmp(&a, &b) == 0) {
			o->bo_id[id] = oid->o_oid[id];
			bcopy(o, no, sizeof(*no));
		}
	}

	tblidx = no->bo_id[OIDIDX_pfTblAddr + 1];
	mps_decodeinaddr(no, &as.pfras_a.pfra_ip4addr, OIDIDX_pfTblAddr + 2);
	as.pfras_a.pfra_net = no->bo_id[OIDIDX_pfTblAddr + 6];

	if (tblidx == 0) {
		if (pfta_get_first(&as))
			return (NULL);
		tblidx = 1;
	} else {
		if (pfta_get_nextaddr(&as, &tblidx)) {
			/* We reached the last addr in the last table.
			 * When the next OIDIDX_pfTblAddr'th OID is requested,
			 * get the first table address again.
			 */
			o->bo_id[OIDIDX_pfTblAddr + 1] = 0;
			smi_oidlen(o);
			return (NULL);
		}
	}

	no->bo_id[OIDIDX_pfTblAddr + 1] = tblidx;
	mps_encodeinaddr(no, &as.pfras_a.pfra_ip4addr, OIDIDX_pfTblAddr + 2);
	no->bo_id[OIDIDX_pfTblAddr + 6] = as.pfras_a.pfra_net;
	no->bo_n += 1;

	smi_oidlen(o);

	return (no);
}

int
mib_pflabelnum(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct pfioc_rule	 pr;
	u_int32_t		 nr, mnr, lnr;
	extern int		 devpf;

	memset(&pr, 0, sizeof(pr));
	if (ioctl(devpf, DIOCGETRULES, &pr)) {
		log_warn("DIOCGETRULES");
		return (-1);
	}

	mnr = pr.nr;
	lnr = 0;
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(devpf, DIOCGETRULE, &pr)) {
			log_warn("DIOCGETRULE");
			return (-1);
		}

		if (pr.rule.label[0])
			lnr++;
	}

	*elm = ber_add_integer(*elm, lnr);

	return (0);
}

int
mib_pflabels(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	struct pfioc_rule	 pr;
	struct pf_rule		*r = NULL;
	u_int32_t		 nr, mnr, lnr;
	u_int32_t		 idx;
	extern int		 devpf;

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_pfLabelEntry];

	memset(&pr, 0, sizeof(pr));
	if (ioctl(devpf, DIOCGETRULES, &pr)) {
		log_warn("DIOCGETRULES");
		return (-1);
	}

	mnr = pr.nr;
	lnr = 0;
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(devpf, DIOCGETRULE, &pr)) {
			log_warn("DIOCGETRULE");
			return (-1);
		}

		if (pr.rule.label[0] && ++lnr == idx) {
			r = &pr.rule;
			break;
		}
	}

	if (r == NULL)
		return (1);

	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_pfLabel]) {
	case 1:
		ber = ber_add_integer(ber, lnr);
		break;
	case 2:
		ber = ber_add_string(ber, r->label);
		break;
	case 3:
		ber = ber_add_integer(ber, r->evaluations);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 4:
		ber = ber_add_integer(ber, r->packets[IN] + r->packets[OUT]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 5:
		ber = ber_add_integer(ber, r->bytes[IN] + r->bytes[OUT]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 6:
		ber = ber_add_integer(ber, r->packets[IN]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 7:
		ber = ber_add_integer(ber, r->bytes[IN]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 8:
		ber = ber_add_integer(ber, r->packets[OUT]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 9:
		ber = ber_add_integer(ber, r->bytes[OUT]);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 10:
		ber = ber_add_integer(ber, r->states_tot);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	default:
		return (1);
	}

	return (0);
}

int
mib_pfsyncstats(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	int			 i;
	int			 mib[] = { CTL_NET, PF_INET, IPPROTO_PFSYNC,
				    PFSYNCCTL_STATS };
	size_t			 len = sizeof(struct pfsyncstats);
	struct pfsyncstats	 s;
	struct statsmap {
		u_int8_t	 m_id;
		u_int64_t	*m_ptr;
	}			 mapping[] = {
		{ 1, &s.pfsyncs_ipackets },
		{ 2, &s.pfsyncs_ipackets6 },
		{ 3, &s.pfsyncs_badif },
		{ 4, &s.pfsyncs_badttl },
		{ 5, &s.pfsyncs_hdrops },
		{ 6, &s.pfsyncs_badver },
		{ 7, &s.pfsyncs_badact },
		{ 8, &s.pfsyncs_badlen },
		{ 9, &s.pfsyncs_badauth },
		{ 10, &s.pfsyncs_stale },
		{ 11, &s.pfsyncs_badval },
		{ 12, &s.pfsyncs_badstate },
		{ 13, &s.pfsyncs_opackets },
		{ 14, &s.pfsyncs_opackets6 },
		{ 15, &s.pfsyncs_onomem },
		{ 16, &s.pfsyncs_oerrors }
	};

	if (sysctl(mib, 4, &s, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}

	for (i = 0;
	    (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
		if (oid->o_oid[OIDIDX_pfstatus] == mapping[i].m_id) {
			*elm = ber_add_integer(*elm, *mapping[i].m_ptr);
			ber_set_header(*elm, BER_CLASS_APPLICATION,
			    SNMP_T_COUNTER64);
			return (0);
		}
	}

	return (-1);
}

int
mib_sensornum(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct sensordev	 sensordev;
	size_t			 len = sizeof(sensordev);
	int			 mib[] = { CTL_HW, HW_SENSORS, 0 };
	int			 i, c;

	for (i = c = 0; ; i++) {
		mib[2] = i;
		if (sysctl(mib, sizeofa(mib),
		    &sensordev, &len, NULL, 0) == -1) {
			if (errno == ENXIO)
				continue;
			if (errno == ENOENT)
				break;
			return (-1);
		}
		c += sensordev.sensors_count;
	}

	*elm = ber_add_integer(*elm, c);
	return (0);
}

int
mib_sensors(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	struct sensordev	 sensordev;
	size_t			 len = sizeof(sensordev);
	struct sensor		 sensor;
	size_t			 slen = sizeof(sensor);
	char			 desc[32];
	int			 mib[] = { CTL_HW, HW_SENSORS, 0, 0, 0 };
	int			 i, j, k;
	u_int32_t		 idx = 0, n;
	char			*s;

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_sensorEntry];

	for (i = 0, n = 1; ; i++) {
		mib[2] = i;
		if (sysctl(mib, 3, &sensordev, &len, NULL, 0) == -1) {
			if (errno == ENXIO)
				continue;
			if (errno == ENOENT)
				break;
			return (-1);
		}
		for (j = 0; j < SENSOR_MAX_TYPES; j++) {
			mib[3] = j;
			for (k = 0; k < sensordev.maxnumt[j]; k++) {
				mib[4] = k;
				if (sysctl(mib, 5,
				    &sensor, &slen, NULL, 0) == -1) {
					if (errno == ENXIO)
						continue;
					if (errno == ENOENT)
						break;
					return (-1);
				}
				if (sensor.flags & SENSOR_FINVALID)
					continue;
				if (n == idx)
					goto found;
				n++;
			}
		}
	}
	return (1);

 found:
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_sensor]) {
	case 1:
		ber = ber_add_integer(ber, (int32_t)n);
		break;
	case 2:
		if (sensor.desc[0] == '\0') {
			snprintf(desc, sizeof(desc), "%s%d",
			    sensor_type_s[sensor.type],
			    sensor.numt);
			ber = ber_add_string(ber, desc);
		} else
			ber = ber_add_string(ber, sensor.desc);
		break;
	case 3:
		ber = ber_add_integer(ber, sensor.type);
		break;
	case 4:
		ber = ber_add_string(ber, sensordev.xname);
		break;
	case 5:
		if ((s = mib_sensorvalue(&sensor)) == NULL)
			return (-1);
		ber = ber_add_string(ber, s);
		free(s);
		break;
	case 6:
		ber = ber_add_string(ber, mib_sensorunit(&sensor));
		break;
	case 7:
		ber = ber_add_integer(ber, sensor.status);
		break;
	}

	return (0);
}

#define SENSOR_DRIVE_STATES	(SENSOR_DRIVE_PFAIL + 1)
static const char * const sensor_drive_s[SENSOR_DRIVE_STATES] = {
	NULL, "empty", "ready", "powerup", "online", "idle", "active",
	"rebuild", "powerdown", "fail", "pfail"
};

static const char * const sensor_unit_s[SENSOR_MAX_TYPES + 1] = {
	"degC",	"RPM", "V DC", "V AC", "Ohm", "W", "A", "Wh", "Ah",
	"", "", "%", "lx", "", "sec", "%RH", "Hz", "degree", 
	"mm", "Pa", "m/s^2", ""
};

const char *
mib_sensorunit(struct sensor *s)
{
	u_int	 idx;
	idx = s->type > SENSOR_MAX_TYPES ?
	    SENSOR_MAX_TYPES : s->type;
	return (sensor_unit_s[idx]);
}

char *
mib_sensorvalue(struct sensor *s)
{
	char	*v;
	int	 ret = -1;

	switch (s->type) {
	case SENSOR_TEMP:
		ret = asprintf(&v, "%.2f",
		    (s->value - 273150000) / 1000000.0);
		break;
	case SENSOR_VOLTS_DC:
	case SENSOR_VOLTS_AC:
	case SENSOR_WATTS:
	case SENSOR_AMPS:
	case SENSOR_WATTHOUR:
	case SENSOR_AMPHOUR:
	case SENSOR_LUX:
	case SENSOR_FREQ:
	case SENSOR_ACCEL:
		ret = asprintf(&v, "%.2f", s->value / 1000000.0);
		break;
	case SENSOR_INDICATOR:
		ret = asprintf(&v, "%s", s->value ? "on" : "off");
		break;
	case SENSOR_PERCENT:
	case SENSOR_HUMIDITY:
		ret = asprintf(&v, "%.2f", s->value / 1000.0);
		break;
	case SENSOR_DISTANCE:
	case SENSOR_PRESSURE:
		ret = asprintf(&v, "%.2f", s->value / 1000.0);
		break;
	case SENSOR_TIMEDELTA:
		ret = asprintf(&v, "%.6f", s->value / 1000000000.0);
		break;
	case SENSOR_DRIVE:
		if (s->value > 0 && s->value < SENSOR_DRIVE_STATES) {
			ret = asprintf(&v, "%s", sensor_drive_s[s->value]);
			break;
		}
		/* FALLTHROUGH */
	case SENSOR_FANRPM:
	case SENSOR_OHMS:
	case SENSOR_INTEGER:
	default:
		ret = asprintf(&v, "%lld", s->value);
		break;
	}

	if (ret == -1)
		return (NULL);
	return (v);
}

int
mib_carpsysctl(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	size_t	 len;
	int	 mib[] = { CTL_NET, PF_INET, IPPROTO_CARP, 0 };
	int	 v;

	mib[3] = oid->o_oid[OIDIDX_carpsysctl];
	len = sizeof(v);

	if (sysctl(mib, 4, &v, &len, NULL, 0) == -1)
		return (1);

	*elm = ber_add_integer(*elm, v);
	return (0);
}

int
mib_carpstats(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	int			 mib[] = { CTL_NET, PF_INET, IPPROTO_CARP,
				    CARPCTL_STATS };
	size_t			 len;
	struct			 carpstats stats;
	int			 i;
	struct statsmap {
		u_int8_t	 m_id;
		u_int64_t	*m_ptr;
	}			 mapping[] = {
		{ 1, &stats.carps_ipackets },
		{ 2, &stats.carps_ipackets6 },
		{ 3, &stats.carps_badif },
		{ 4, &stats.carps_badttl },
		{ 5, &stats.carps_hdrops },
		{ 6, &stats.carps_badsum },
		{ 7, &stats.carps_badver },
		{ 8, &stats.carps_badlen },
		{ 9, &stats.carps_badauth },
		{ 10, &stats.carps_badvhid },
		{ 11, &stats.carps_badaddrs },
		{ 12, &stats.carps_opackets },
		{ 13, &stats.carps_opackets6 },
		{ 14, &stats.carps_onomem },
		{ 15, &stats.carps_preempt }
	};

	len = sizeof(stats);

	if (sysctl(mib, 4, &stats, &len, NULL, 0) == -1)
		return (1);

	for (i = 0;
	    (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
		if (oid->o_oid[OIDIDX_carpstats] == mapping[i].m_id) {
			*elm = ber_add_integer(*elm, *mapping[i].m_ptr);
			ber_set_header(*elm, BER_CLASS_APPLICATION,
			    SNMP_T_COUNTER64);
			return (0);
		}
	}

	return (-1);
}

int
mib_carpifnum(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct kif	*kif;
	int		 c = 0;

	for (kif = kr_getif(0); kif != NULL;
	    kif = kr_getnextif(kif->if_index))
		if (kif->if_type == IFT_CARP)
			c++;

	*elm = ber_add_integer(*elm, c);
	return (0);
}

struct carpif *
mib_carpifget(u_int idx)
{
	struct kif	*kif;
	struct carpif	*cif;
	int		 s;
	struct ifreq	 ifr;
	struct carpreq	 carpr;

	if ((kif = kr_getif(idx)) == NULL || kif->if_type != IFT_CARP) {
		/*
		 * It may happen that an interface with a specific index
		 * does not exist, has been removed, or is not a carp(4)
		 * interface. Jump to the next available carp(4) interface
		 * index.
		 */
		for (kif = kr_getif(0); kif != NULL;
		    kif = kr_getnextif(kif->if_index)) {
			if (kif->if_type != IFT_CARP)
				continue;
			if (kif->if_index > idx)
				break;

		}
		if (kif == NULL)
			return (NULL);
	}
	idx = kif->if_index;

	/* Update interface information */
	kr_updateif(idx);
	if ((kif = kr_getif(idx)) == NULL) {
		log_debug("mib_carpifget: interface %d disappeared?", idx);
		return (NULL);
	}

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		return (NULL);

	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, kif->if_name, sizeof(ifr.ifr_name));
	memset((char *)&carpr, 0, sizeof(carpr));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1) {
		close(s);
		return (NULL);
	}

	cif = calloc(1, sizeof(struct carpif));
	if (cif != NULL) {
		memcpy(&cif->carpr, &carpr, sizeof(struct carpreq));
		memcpy(&cif->kif, kif, sizeof(struct kif));
	}

	close(s);

	return (cif);
}

int
mib_carpiftable(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	u_int32_t		 idx;
	struct carpif		*cif;

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_carpIfEntry];

	if ((cif = mib_carpifget(idx)) == NULL)
		return (1);

	/* Tables need to prepend the OID on their own */
	o->bo_id[OIDIDX_carpIfEntry] = cif->kif.if_index;
	*elm = ber_add_oid(*elm, o);

	switch (o->bo_id[OIDIDX_carpIf]) {
	case 1:
		*elm = ber_add_integer(*elm, cif->kif.if_index);
		break;
	case 2:
		*elm = ber_add_string(*elm, cif->kif.if_name);
		break;
	case 3:
		*elm = ber_add_integer(*elm, cif->carpr.carpr_vhids[0]);
		break;
	case 4:
		*elm = ber_add_string(*elm, cif->carpr.carpr_carpdev);
		break;
	case 5:
		*elm = ber_add_integer(*elm, cif->carpr.carpr_advbase);
		break;
	case 6:
		*elm = ber_add_integer(*elm, cif->carpr.carpr_advskews[0]);
		break;
	case 7:
		*elm = ber_add_integer(*elm, cif->carpr.carpr_states[0]);
		break;
	default:
		free(cif);
		return (1);
	}

	free(cif);
	return (0);
}

int
mib_memiftable(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	u_int32_t		 idx = 0;
	struct kif		*kif;

	idx = o->bo_id[OIDIDX_memIfEntry];
	if ((kif = mib_ifget(idx)) == NULL)
		return (1);

	o->bo_id[OIDIDX_memIfEntry] = kif->if_index;
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_memIf]) {
	case 1:
		ber = ber_add_string(ber, kif->if_name);
		break;
	case 2:
		ber = ber_add_integer(ber, 0);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	default:
		return (-1);
	}

	return (0);
}

/*
 * Defined in IP-MIB.txt
 */

int mib_getipstat(struct ipstat *);
int mib_ipstat(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipforwarding(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipdefaultttl(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipinhdrerrs(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipinaddrerrs(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipforwdgrams(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipindiscards(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipreasmfails(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipfragfails(struct oid *, struct ber_oid *, struct ber_element **);
int mib_iproutingdiscards(struct oid *, struct ber_oid *,
    struct ber_element **);
int mib_ipaddr(struct oid *, struct ber_oid *, struct ber_element **);
struct ber_oid *
    mib_ipaddrtable(struct oid *, struct ber_oid *, struct ber_oid *);
int mib_physaddr(struct oid *, struct ber_oid *, struct ber_element **);
struct ber_oid *
    mib_physaddrtable(struct oid *, struct ber_oid *, struct ber_oid *);

static struct oid ip_mib[] = {
	{ MIB(ipMIB),			OID_MIB },
	{ MIB(ipForwarding),		OID_RD, mib_ipforwarding },
	{ MIB(ipDefaultTTL),		OID_RD, mib_ipdefaultttl },
	{ MIB(ipInReceives),		OID_RD, mib_ipstat },
	{ MIB(ipInHdrErrors),		OID_RD, mib_ipinhdrerrs },
	{ MIB(ipInAddrErrors),		OID_RD, mib_ipinaddrerrs },
	{ MIB(ipForwDatagrams),		OID_RD, mib_ipforwdgrams },
	{ MIB(ipInUnknownProtos),	OID_RD, mib_ipstat },
#ifdef notyet
	{ MIB(ipInDiscards) },
#endif
	{ MIB(ipInDelivers),		OID_RD, mib_ipstat },
	{ MIB(ipOutRequests),		OID_RD, mib_ipstat },
	{ MIB(ipOutDiscards),		OID_RD, mib_ipstat },
	{ MIB(ipOutNoRoutes),		OID_RD, mib_ipstat },
	{ MIB(ipReasmTimeout),		OID_RD, mps_getint, NULL,
	    NULL, IPFRAGTTL },
	{ MIB(ipReasmReqds),		OID_RD, mib_ipstat },
	{ MIB(ipReasmOKs),		OID_RD, mib_ipstat },
	{ MIB(ipReasmFails),		OID_RD, mib_ipreasmfails },
	{ MIB(ipFragOKs),		OID_RD, mib_ipstat },
	{ MIB(ipFragFails),		OID_RD, mib_ipfragfails },
	{ MIB(ipFragCreates),		OID_RD, mib_ipstat },
	{ MIB(ipAdEntAddr),		OID_TRD, mib_ipaddr, NULL,
	    mib_ipaddrtable },
	{ MIB(ipAdEntIfIndex),		OID_TRD, mib_ipaddr, NULL,
	    mib_ipaddrtable },
	{ MIB(ipAdEntNetMask),		OID_TRD, mib_ipaddr, NULL,
	    mib_ipaddrtable },
	{ MIB(ipAdEntBcastAddr),	OID_TRD, mib_ipaddr, NULL,
	    mib_ipaddrtable },
	{ MIB(ipAdEntReasmMaxSize),	OID_TRD, mib_ipaddr, NULL,
	    mib_ipaddrtable },
	{ MIB(ipNetToMediaIfIndex),	OID_TRD, mib_physaddr, NULL,
	    mib_physaddrtable },
	{ MIB(ipNetToMediaPhysAddress),	OID_TRD, mib_physaddr, NULL,
	    mib_physaddrtable },
	{ MIB(ipNetToMediaNetAddress),	OID_TRD, mib_physaddr, NULL,
	    mib_physaddrtable },
	{ MIB(ipNetToMediaType),	OID_TRD, mib_physaddr, NULL,
	    mib_physaddrtable },
#ifdef notyet
	{ MIB(ipRoutingDiscards) },
#endif
	{ MIBEND }
};

int
mib_ipforwarding(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	int	mib[] = { CTL_NET, PF_INET, IPPROTO_IP, IPCTL_FORWARDING };
	int	v;
	size_t	len = sizeof(v);

	if (sysctl(mib, sizeofa(mib), &v, &len, NULL, 0) == -1)
		return (-1);

	/* ipForwarding: forwarding(1), notForwarding(2) */
	*elm = ber_add_integer(*elm, (v == 0) ? 2 : 1);

	return (0);
}

int
mib_ipdefaultttl(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	int	mib[] = { CTL_NET, PF_INET, IPPROTO_IP, IPCTL_DEFTTL };
	int	v;
	size_t	len = sizeof(v);

	if (sysctl(mib, sizeofa(mib), &v, &len, NULL, 0) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, v);

	return (0);
}

int
mib_getipstat(struct ipstat *ipstat)
{
	int	 mib[] = { CTL_NET, PF_INET, IPPROTO_IP, IPCTL_STATS };
	size_t	 len = sizeof(*ipstat);

	return (sysctl(mib, sizeofa(mib), ipstat, &len, NULL, 0));
}

int
mib_ipstat(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ipstat		 ipstat;
	long long		 i;
	struct statsmap {
		u_int8_t	 m_id;
		u_long		*m_ptr;
	}			 mapping[] = {
		{ 3, &ipstat.ips_total },
		{ 7, &ipstat.ips_noproto },
		{ 9, &ipstat.ips_delivered },
		{ 10, &ipstat.ips_localout },
		{ 11, &ipstat.ips_odropped },
		{ 12, &ipstat.ips_noroute },
		{ 14, &ipstat.ips_fragments },
		{ 15, &ipstat.ips_reassembled },
		{ 17, &ipstat.ips_fragmented },
		{ 19, &ipstat.ips_ofragments }
	};

	if (mib_getipstat(&ipstat) == -1)
		return (-1);

	for (i = 0;
	    (u_int)i < (sizeof(mapping) / sizeof(mapping[0])); i++) {
		if (oid->o_oid[OIDIDX_ip] == mapping[i].m_id) {
			*elm = ber_add_integer(*elm, *mapping[i].m_ptr);
			ber_set_header(*elm,
			    BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
			return (0);
		}
	}

	return (-1);
}

int
mib_ipinhdrerrs(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	u_int32_t	errors;
	struct ipstat	ipstat;

	if (mib_getipstat(&ipstat) == -1)
		return (-1);

	errors = ipstat.ips_badsum + ipstat.ips_badvers +
	    ipstat.ips_tooshort + ipstat.ips_toosmall +
	    ipstat.ips_badhlen +  ipstat.ips_badlen +
	    ipstat.ips_badoptions + ipstat.ips_toolong +
	    ipstat.ips_badaddr;

	*elm = ber_add_integer(*elm, errors);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_ipinaddrerrs(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	u_int32_t	errors;
	struct ipstat	ipstat;

	if (mib_getipstat(&ipstat) == -1)
		return (-1);

	errors = ipstat.ips_cantforward + ipstat.ips_badaddr;

	*elm = ber_add_integer(*elm, errors);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_ipforwdgrams(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	u_int32_t	counter;
	struct ipstat	ipstat;

	if (mib_getipstat(&ipstat) == -1)
		return (-1);

	counter = ipstat.ips_forward + ipstat.ips_redirectsent;

	*elm = ber_add_integer(*elm, counter);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_ipindiscards(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	return (0);
}

int
mib_ipreasmfails(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	u_int32_t	counter;
	struct ipstat	ipstat;

	if (mib_getipstat(&ipstat) == -1)
		return (-1);

	counter = ipstat.ips_fragdropped + ipstat.ips_fragtimeout;

	*elm = ber_add_integer(*elm, counter);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_ipfragfails(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	u_int32_t	counter;
	struct ipstat	ipstat;

	if (mib_getipstat(&ipstat) == -1)
		return (-1);

	counter = ipstat.ips_badfrags + ipstat.ips_cantfrag;
	*elm = ber_add_integer(*elm, counter);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_iproutingdiscards(struct oid *oid, struct ber_oid *o,
    struct ber_element **elm)
{
	return (0);
}

struct ber_oid *
mib_ipaddrtable(struct oid *oid, struct ber_oid *o, struct ber_oid *no)
{
	struct sockaddr_in	 addr;
	u_int32_t		 col, id;
	struct oid		 a, b;
	struct kif_addr		*ka;

	bzero(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_len = sizeof(addr);

	bcopy(&oid->o_id, no, sizeof(*no));
	id = oid->o_oidlen - 1;

	if (o->bo_n >= oid->o_oidlen) {
		/*
		 * Compare the requested and the matched OID to see
		 * if we have to iterate to the next element.
		 */
		bzero(&a, sizeof(a));
		bcopy(o, &a.o_id, sizeof(struct ber_oid));
		bzero(&b, sizeof(b));
		bcopy(&oid->o_id, &b.o_id, sizeof(struct ber_oid));
		b.o_oidlen--;
		b.o_flags |= OID_TABLE;
		if (smi_oid_cmp(&a, &b) == 0) {
			col = oid->o_oid[id];
			o->bo_id[id] = col;
			bcopy(o, no, sizeof(*no));
		}
	}

	mps_decodeinaddr(no, &addr.sin_addr, OIDIDX_ipAddr + 1);
	if (o->bo_n <= (OIDIDX_ipAddr + 1))
		ka = kr_getaddr(NULL);
	else
		ka = kr_getnextaddr((struct sockaddr *)&addr);
	if (ka == NULL || ka->addr.sa.sa_family != AF_INET) {
		/*
		 * Encode invalid "last address" marker which will tell
		 * mib_ipaddr() to fail and the SNMP engine to find the
		 * next OID.
		 */
		mps_encodeinaddr(no, NULL, OIDIDX_ipAddr + 1);
	} else {
		/* Encode real IPv4 address */
		addr.sin_addr.s_addr = ka->addr.sin.sin_addr.s_addr;
		mps_encodeinaddr(no, &addr.sin_addr, OIDIDX_ipAddr + 1);
	}
	smi_oidlen(o);

	return (no);
}

int
mib_ipaddr(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct sockaddr_in	 addr;
	struct ber_element	*ber = *elm;
	struct kif_addr		*ka;
	u_int32_t		 val;

	bzero(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_len = sizeof(addr);

	if (mps_decodeinaddr(o, &addr.sin_addr, OIDIDX_ipAddr + 1) == -1) {
		/* Strip invalid address and fail */
		o->bo_n = OIDIDX_ipAddr + 1;
		return (1);
	}
	ka = kr_getaddr((struct sockaddr *)&addr);
	if (ka == NULL || ka->addr.sa.sa_family != AF_INET)
		return (1);

	/* write OID */
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_ipAddr]) {
	case 1:
		val = addr.sin_addr.s_addr;
		ber = ber_add_nstring(ber, (char *)&val, sizeof(u_int32_t));
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_IPADDR);
		break;
	case 2:
		ber = ber_add_integer(ber, ka->if_index);
		break;
	case 3:
		val = ka->mask.sin.sin_addr.s_addr;
		ber = ber_add_nstring(ber, (char *)&val, sizeof(u_int32_t));
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_IPADDR);
		break;
	case 4:
		ber = ber_add_integer(ber, ka->dstbrd.sa.sa_len ? 1 : 0);
		break;
	case 5:
		ber = ber_add_integer(ber, IP_MAXPACKET);
		break;
	default:
		return (-1);
	}

	return (0);
}

struct ber_oid *
mib_physaddrtable(struct oid *oid, struct ber_oid *o, struct ber_oid *no)
{
	struct sockaddr_in	 addr;
	struct oid		 a, b;
	struct kif		*kif;
	struct kif_arp		*ka;
	u_int32_t		 id, idx = 0;

	bcopy(&oid->o_id, no, sizeof(*no));
	id = oid->o_oidlen - 1;

	if (o->bo_n >= oid->o_oidlen) {
		/*
		 * Compare the requested and the matched OID to see
		 * if we have to iterate to the next element.
		 */
		bzero(&a, sizeof(a));
		bcopy(o, &a.o_id, sizeof(struct ber_oid));
		bzero(&b, sizeof(b));
		bcopy(&oid->o_id, &b.o_id, sizeof(struct ber_oid));
		b.o_oidlen--;
		b.o_flags |= OID_TABLE;
		if (smi_oid_cmp(&a, &b) == 0) {
			o->bo_id[id] = oid->o_oid[id];
			bcopy(o, no, sizeof(*no));
		}
	}

	if (o->bo_n > OIDIDX_ipNetToMedia + 1)
		idx = o->bo_id[OIDIDX_ipNetToMedia + 1];

	bzero(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_len = sizeof(addr);
	if (o->bo_n > OIDIDX_ipNetToMedia + 2)
		mps_decodeinaddr(no, &addr.sin_addr, OIDIDX_ipNetToMedia + 2);

	if ((kif = kr_getif(idx)) == NULL) {
		/* No configured interfaces */
		if (idx == 0)
			return (NULL);
		/*
		 * It may happen that an interface with a specific index
		 * does not exist or has been removed.  Jump to the next
		 * available interface.
		 */
		kif = kr_getif(0);
 nextif:
		for (; kif != NULL; kif = kr_getnextif(kif->if_index))
			if (kif->if_index > idx &&
			    (ka = karp_first(kif->if_index)) != NULL)
				break;
		if (kif == NULL) {
			/* No more interfaces with addresses on them */
			o->bo_id[OIDIDX_ipNetToMedia + 1] = 0;
			mps_encodeinaddr(no, NULL, OIDIDX_ipNetToMedia + 2);
			smi_oidlen(o);
			return (NULL);
		}
	} else {
		if (idx == 0 || addr.sin_addr.s_addr == 0)
			ka = karp_first(kif->if_index);
		else
			ka = karp_getaddr((struct sockaddr *)&addr, idx, 1);
		if (ka == NULL) {
			/* Try next interface */
			goto nextif;
		}
	}
	idx = kif->if_index;

	no->bo_id[OIDIDX_ipNetToMedia + 1] = idx;
	/* Encode real IPv4 address */
	memcpy(&addr, &ka->addr.sin, ka->addr.sin.sin_len);
	mps_encodeinaddr(no, &addr.sin_addr, OIDIDX_ipNetToMedia + 2);

	smi_oidlen(o);
	return (no);
}

int
mib_physaddr(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	struct sockaddr_in	 addr;
	struct kif_arp		*ka;
	u_int32_t		 val, idx = 0;

	idx = o->bo_id[OIDIDX_ipNetToMedia + 1];
	if (idx == 0) {
		/* Strip invalid interface index and fail */
		o->bo_n = OIDIDX_ipNetToMedia + 1;
		return (1);
	}

	/* Get the IP address */
	bzero(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_len = sizeof(addr);

	if (mps_decodeinaddr(o, &addr.sin_addr,
	    OIDIDX_ipNetToMedia + 2) == -1) {
		/* Strip invalid address and fail */
		o->bo_n = OIDIDX_ipNetToMedia + 2;
		return (1);
	}
	if ((ka = karp_getaddr((struct sockaddr *)&addr, idx, 0)) == NULL)
		return (1);

	/* write OID */
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_ipNetToMedia]) {
	case 1: /* ipNetToMediaIfIndex */
		ber = ber_add_integer(ber, ka->if_index);
		break;
	case 2: /* ipNetToMediaPhysAddress */
		if (bcmp(LLADDR(&ka->target.sdl), ether_zeroaddr,
		    sizeof(ether_zeroaddr)) == 0)
			ber = ber_add_nstring(ber, ether_zeroaddr,
			    sizeof(ether_zeroaddr));
		else
			ber = ber_add_nstring(ber, LLADDR(&ka->target.sdl),
			    ka->target.sdl.sdl_alen);
		break;
	case 3:	/* ipNetToMediaNetAddress */
		val = addr.sin_addr.s_addr;
		ber = ber_add_nstring(ber, (char *)&val, sizeof(u_int32_t));
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_IPADDR);
		break;
	case 4: /* ipNetToMediaType */
		if (ka->flags & F_STATIC)
			ber = ber_add_integer(ber, 4); /* static */
		else
			ber = ber_add_integer(ber, 3); /* dynamic */
		break;
	default:
		return (-1);
	}
	return (0);
}

/*
 * Defined in IP-FORWARD-MIB.txt (rfc4292)
 */

int mib_ipfnroutes(struct oid *, struct ber_oid *, struct ber_element **);
struct ber_oid *
mib_ipfroutetable(struct oid *oid, struct ber_oid *o, struct ber_oid *no);
int mib_ipfroute(struct oid *, struct ber_oid *, struct ber_element **);

static struct oid ipf_mib[] = {
	{ MIB(ipfMIB),			OID_MIB },
	{ MIB(ipfInetCidrRouteNumber),	OID_RD, mib_ipfnroutes },

	{ MIB(ipfRouteEntIfIndex),	OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIB(ipfRouteEntType),		OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIB(ipfRouteEntProto),	OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIB(ipfRouteEntAge),		OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIB(ipfRouteEntNextHopAS),	OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIB(ipfRouteEntRouteMetric1),	OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIB(ipfRouteEntRouteMetric2),	OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIB(ipfRouteEntRouteMetric3),	OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIB(ipfRouteEntRouteMetric4),	OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIB(ipfRouteEntRouteMetric5),	OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIB(ipfRouteEntStatus),	OID_TRD, mib_ipfroute, NULL,
	    mib_ipfroutetable },
	{ MIBEND }
};

int
mib_ipfnroutes(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	*elm = ber_add_integer(*elm, kr_routenumber());
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_GAUGE32);

	return (0);
}

struct ber_oid *
mib_ipfroutetable(struct oid *oid, struct ber_oid *o, struct ber_oid *no)
{
	u_int32_t		 col, id;
	struct oid		 a, b;
	struct sockaddr_in	 addr;
	struct kroute		*kr;
	int			 af, atype, idx;
	u_int8_t		 prefixlen;
	u_int8_t		 prio;

	bzero(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_len = sizeof(addr);

	bcopy(&oid->o_id, no, sizeof(*no));
	id = oid->o_oidlen - 1;

	if (o->bo_n >= oid->o_oidlen) {
		/*
		 * Compare the requested and the matched OID to see
		 * if we have to iterate to the next element.
		 */
		bzero(&a, sizeof(a));
		bcopy(o, &a.o_id, sizeof(struct ber_oid));
		bzero(&b, sizeof(b));
		bcopy(&oid->o_id, &b.o_id, sizeof(struct ber_oid));
		b.o_oidlen--;
		b.o_flags |= OID_TABLE;
		if (smi_oid_cmp(&a, &b) == 0) {
			col = oid->o_oid[id];
			o->bo_id[id] = col;
			bcopy(o, no, sizeof(*no));
		}
	}

	af = no->bo_id[OIDIDX_ipfInetCidrRoute + 1];
	mps_decodeinaddr(no, &addr.sin_addr, OIDIDX_ipfInetCidrRoute + 3);
	prefixlen = o->bo_id[OIDIDX_ipfInetCidrRoute + 7];
	prio = o->bo_id[OIDIDX_ipfInetCidrRoute + 10];

	if (af == 0)
		kr = kroute_first();
	else
		kr = kroute_getaddr(addr.sin_addr.s_addr, prefixlen, prio, 1);

	if (kr == NULL) {
		addr.sin_addr.s_addr = 0;
		prefixlen = 0;
		prio = 0;
		addr.sin_family = 0;
	} else {
		addr.sin_addr.s_addr = kr->prefix.s_addr;
		prefixlen = kr->prefixlen;
		prio = kr->priority;
	}

	switch (addr.sin_family) {
	case AF_INET:
		atype = 1;
		break;
	case AF_INET6:
		atype = 2;
		break;
	default:
		atype = 0;
		break;
	}
	idx = OIDIDX_ipfInetCidrRoute + 1;
	no->bo_id[idx++] = atype;
	no->bo_id[idx++] = 0x04;
	no->bo_n++;

	mps_encodeinaddr(no, &addr.sin_addr, idx);
	no->bo_id[no->bo_n++] = prefixlen;
	no->bo_id[no->bo_n++] = 0x02;
	no->bo_n += 2; /* policy */
	no->bo_id[OIDIDX_ipfInetCidrRoute + 10]  = prio;

	if (kr != NULL) {
		no->bo_id[no->bo_n++] = atype;
		no->bo_id[no->bo_n++] = 0x04;
		mps_encodeinaddr(no, &kr->nexthop, no->bo_n);
	} else
		no->bo_n += 2;

	smi_oidlen(o);

	return (no);
}

int
mib_ipfroute(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	struct kroute		*kr;
	struct sockaddr_in	 addr, nhaddr;
	int			 idx = o->bo_id[OIDIDX_ipfInetCidrRoute];
	int			 af;
	u_int8_t		 prefixlen, prio, type, proto;


	bzero(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_len = sizeof(addr);

	af = o->bo_id[OIDIDX_ipfInetCidrRoute + 1];
	mps_decodeinaddr(o, &addr.sin_addr, OIDIDX_ipfInetCidrRoute + 3);
	mps_decodeinaddr(o, &nhaddr.sin_addr, OIDIDX_ipfInetCidrRoute + 23);
	prefixlen = o->bo_id[OIDIDX_ipfInetCidrRoute + 7];
	prio = o->bo_id[OIDIDX_ipfInetCidrRoute + 10];
	kr = kroute_getaddr(addr.sin_addr.s_addr, prefixlen, prio, 0);
	if (kr == NULL || af == 0) {
		return (1);
	}

	/* write OID */
	ber = ber_add_oid(ber, o);

	switch (idx) {
	case 7: /* IfIndex */
		ber = ber_add_integer(ber, kr->if_index);
		break;
	case 8: /* Type */
		if (kr->flags & F_REJECT)
			type = 2;
		else if (kr->flags & F_BLACKHOLE)
			type = 5;
		else if (kr->flags & F_CONNECTED)
			type = 3;
		else
			type = 4;
		ber = ber_add_integer(ber, type);
		break;
	case 9: /* Proto */
		switch (kr->priority) {
		case RTP_CONNECTED:
			proto = 2;
			break;
		case RTP_STATIC:
			proto = 3;
			break;
		case RTP_OSPF:
			proto = 13;
			break;
		case RTP_ISIS:
			proto = 9;
			break;
		case RTP_RIP:
			proto = 8;
			break;
		case RTP_BGP:
			proto = 14;
			break;
		default:
			if (kr->flags & F_DYNAMIC)
				proto = 4;
			else
				proto = 1; /* not specified */
			break;
		}
		ber = ber_add_integer(ber, proto);
		break;
	case 10: /* Age */
		ber = ber_add_integer(ber, 0);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_GAUGE32);
		break;
	case 11: /* NextHopAS */
		ber = ber_add_integer(ber, 0);	/* unknown */
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_GAUGE32);
		break;
	case 12: /* Metric1 */
		ber = ber_add_integer(ber, -1);	/* XXX */
		break;
	case 13: /* Metric2 */
		ber = ber_add_integer(ber, -1);	/* XXX */
		break;
	case 14: /* Metric3 */
		ber = ber_add_integer(ber, -1);	/* XXX */
		break;
	case 15: /* Metric4 */
		ber = ber_add_integer(ber, -1);	/* XXX */
		break;
	case 16: /* Metric5 */
		ber = ber_add_integer(ber, -1);	/* XXX */
		break;
	case 17: /* Status */
		ber = ber_add_integer(ber, 1);	/* XXX */
		break;
	default:
		return (-1);
	}

	return (0);
}

/*
 * Defined in UCD-DISKIO-MIB.txt.
 */

int	mib_diskio(struct oid *oid, struct ber_oid *o, struct ber_element **elm);

static struct oid diskio_mib[] = {
	{ MIB(ucdDiskIOMIB),			OID_MIB },
	{ MIB(diskIOIndex),			OID_TRD, mib_diskio },
	{ MIB(diskIODevice),			OID_TRD, mib_diskio },
	{ MIB(diskIONRead),			OID_TRD, mib_diskio },
	{ MIB(diskIONWritten),			OID_TRD, mib_diskio },
	{ MIB(diskIOReads),			OID_TRD, mib_diskio },
	{ MIB(diskIOWrites),			OID_TRD, mib_diskio },
	{ MIB(diskIONReadX),			OID_TRD, mib_diskio },
	{ MIB(diskIONWrittenX),			OID_TRD, mib_diskio },
	{ MIBEND }
};

int
mib_diskio(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	u_int32_t		 idx;
	int			 mib[] = { CTL_HW, 0 };
	unsigned int		 diskcount;
	struct diskstats	*stats;
	size_t			 len;

	len = sizeof(diskcount);
	mib[1] = HW_DISKCOUNT;
	if (sysctl(mib, sizeofa(mib), &diskcount, &len, NULL, 0) == -1)
		return (-1);

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_diskIOEntry];
	if (idx > diskcount)
		return (1);

	/* Tables need to prepend the OID on their own */
	o->bo_id[OIDIDX_diskIOEntry] = idx;
	ber = ber_add_oid(ber, o);

	stats = calloc(diskcount, sizeof(*stats));
	if (stats == NULL)
		return (-1);
	/* We know len won't overflow, otherwise calloc() would have failed. */
	len = diskcount * sizeof(*stats);
	mib[1] = HW_DISKSTATS;
	if (sysctl(mib, sizeofa(mib), stats, &len, NULL, 0) == -1) {
		free(stats);
		return (-1);
	}

	switch (o->bo_id[OIDIDX_diskIO]) {
	case 1: /* diskIOIndex */
		ber = ber_add_integer(ber, idx);
		break;
	case 2: /* diskIODevice */
		ber = ber_add_string(ber, stats[idx - 1].ds_name);
		break;
	case 3: /* diskIONRead */
		ber = ber_add_integer(ber, (u_int32_t)stats[idx - 1].ds_rbytes);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 4: /* diskIONWritten */
		ber = ber_add_integer(ber, (u_int32_t)stats[idx - 1].ds_wbytes);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 5: /* diskIOReads */
		ber = ber_add_integer(ber, (u_int32_t)stats[idx - 1].ds_rxfer);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 6: /* diskIOWrites */
		ber = ber_add_integer(ber, (u_int32_t)stats[idx - 1].ds_wxfer);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	case 12: /* diskIONReadX */
		ber = ber_add_integer(ber, stats[idx - 1].ds_rbytes);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	case 13: /* diskIONWrittenX */
		ber = ber_add_integer(ber, stats[idx - 1].ds_wbytes);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
		break;
	default:
		free(stats);
		return (-1);
	}

	free(stats);
	return (0);
}

/*
 * Defined in BRIDGE-MIB.txt (rfc1493)
 *
 * This MIB is required by some NMS to accept the device because
 * the RFC says that mostly any network device has to provide this MIB... :(
 */

int	 mib_dot1dtable(struct oid *, struct ber_oid *, struct ber_element **);

static struct oid bridge_mib[] = {
	{ MIB(dot1dBridge),		OID_MIB },
	{ MIB(dot1dBaseBridgeAddress) },
	{ MIB(dot1dBaseNumPorts),	OID_RD, mib_ifnumber },
	{ MIB(dot1dBaseType),		OID_RD, mps_getint, NULL,
	    NULL, 4 /* srt (sourceroute + transparent) */ },
	{ MIB(dot1dBasePort),		OID_TRD, mib_dot1dtable },
	{ MIB(dot1dBasePortIfIndex),	OID_TRD, mib_dot1dtable },
	{ MIB(dot1dBasePortCircuit),	OID_TRD, mib_dot1dtable},
	{ MIB(dot1dBasePortDelayExceededDiscards), OID_TRD, mib_dot1dtable },
	{ MIB(dot1dBasePortMtuExceededDiscards), OID_TRD, mib_dot1dtable },
	{ MIBEND }
};

int
mib_dot1dtable(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ber_element	*ber = *elm;
	u_int32_t		 idx = 0;
	struct kif		*kif;

	/* Get and verify the current row index */
	idx = o->bo_id[OIDIDX_dot1dEntry];
	if ((kif = mib_ifget(idx)) == NULL)
		return (1);

	/* Tables need to prepend the OID on their own */
	o->bo_id[OIDIDX_dot1dEntry] = kif->if_index;
	ber = ber_add_oid(ber, o);

	switch (o->bo_id[OIDIDX_dot1d]) {
	case 1:
	case 2:
		ber = ber_add_integer(ber, kif->if_index);
		break;
	case 3:
		ber = ber_add_oid(ber, &zerodotzero);
		break;
	case 4:
	case 5:
		ber = ber_add_integer(ber, 0);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
		break;
	}

	return (0);
}

/*
 * Import all MIBs
 */

void
mib_init(void)
{
	/*
	 * MIB declarations (to register the OID names)
	 */
	smi_mibtree(mib_tree);

	/*
	 * MIB definitions (the implementation)
	 */

	/* SNMPv2-MIB */
	smi_mibtree(base_mib);

	/* SNMP-USER-BASED-SM-MIB */
	smi_mibtree(usm_mib);

	/* HOST-RESOURCES-MIB */
	smi_mibtree(hr_mib);

	/* IF-MIB */
	smi_mibtree(if_mib);

	/* IP-MIB */
	smi_mibtree(ip_mib);

	/* IP-FORWARD-MIB */
	smi_mibtree(ipf_mib);

	/* BRIDGE-MIB */
	smi_mibtree(bridge_mib);

	/* UCD-DISKIO-MIB */
	smi_mibtree(diskio_mib);

	/* OPENBSD-MIB */
	smi_mibtree(openbsd_mib);
}
@


1.82
log
@Because of pfsync this needs ip_ipsp.h. Missed in the pfsockaddr_union cleanup.
Found by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.81 2016/10/28 08:01:53 rzalamena Exp $	*/
d2665 1
a2665 1
		ret = asprintf(&v, "%.2f%%", s->value / 1000.0);
@


1.81
log
@Use snmpd_env as the only global variable for env to simplify the daemon
and avoid problems.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.80 2015/11/17 12:30:23 gerhard Exp $	*/
d44 1
@


1.80
log
@Sensors marked as invalid should be excluded by snmpd(8) from the sensors
MIB just as sysctl(8) excludes them from the 'hw.sensors' tree.

OK mikeb@@, stehn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.79 2015/10/08 08:29:21 sthen Exp $	*/
a60 2
extern struct snmpd	*env;

d256 1
a256 1
	struct snmp_stats	*stats = &env->sc_stats;
d317 1
a317 1
	struct snmp_stats	*stats = &env->sc_stats;
d355 2
a356 2
		*elm = ber_add_nstring(*elm, env->sc_engineid,
		    env->sc_engineid_len);
d359 1
a359 1
		*elm = ber_add_integer(*elm, env->sc_engine_boots);
d376 1
a376 1
	struct snmp_stats	*stats = &env->sc_stats;
d698 1
a698 1
	if (idx > (u_int)env->sc_ncpu)
d749 1
a749 1
	if (idx > (u_int)env->sc_ncpu)
d767 1
a767 1
		if (env->sc_cpustates == NULL)
d769 1
a769 1
		cptime2 = env->sc_cpustates + (CPUSTATES * (idx - 1));
@


1.79
log
@add comment, suggested by reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.78 2015/10/08 07:26:34 sthen Exp $	*/
d2559 1
a2559 1
			for (k = 0; k < sensordev.maxnumt[j]; k++, n++) {
d2569 2
d2573 1
@


1.78
log
@use correct return value for IP-MIB::ipForwarding, tweak/ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.77 2015/10/05 15:29:14 uebayasi Exp $	*/
d2987 1
@


1.77
log
@Teach snmpd(8) about if_oqdrops.

OK mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2987 1
a2987 1
	*elm = ber_add_integer(*elm, v);
@


1.76
log
@Export new pf "no-route" error counter

OK sthen, blambert for the SNMP part
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.75 2015/01/21 21:50:33 deraadt Exp $	*/
d1196 1
a1196 1
		ber = ber_add_integer(ber, 0);
@


1.75
log
@Include <netinet/in.h> before <net/pfvar.h>.  In a future change when
ports is ready, <net/pfvar.h> will stop including a pile of balony.
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.74 2015/01/16 00:05:13 deraadt Exp $	*/
d1454 1
d1711 2
a1712 1
		{ 16, &s.counters[PFRES_TRANSLATE] }
@


1.74
log
@first batch of cleanup to programs based upon the namespace cleanups
in net/pfvar.h sys/proc.h sys/ucred.h arpa/nameser.h
change to PATH_MAX, reduce use of MIN() and MAX(), HOST_NAME_MAX+1,
LOGIN_NAME_MAX, etc etc
ok millert guenther, some review by doug
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.73 2014/11/18 20:54:29 krw Exp $	*/
a35 4
#include <net/if.h>
#include <net/if_types.h>
#include <net/pfvar.h>
#include <net/if_pfsync.h>
d41 4
@


1.73
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.72 2014/10/25 03:23:49 lteo Exp $	*/
d20 1
a21 1
#include <sys/param.h>
a22 1
#include <sys/types.h>
@


1.72
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.71 2014/07/04 05:58:31 guenther Exp $	*/
a32 1
#include <sys/socket.h>
@


1.71
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.70 2014/06/23 03:46:17 guenther Exp $	*/
a42 1
#include <netinet/in_systm.h>
@


1.70
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.69 2014/05/07 01:23:52 tedu Exp $	*/
a845 1
		case SZOMB:
@


1.69
log
@use calloc. from peter malone
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.68 2014/04/28 12:03:32 mikeb Exp $	*/
d1085 1
a1085 1
	int			 mib[] = { CTL_NET, AF_INET, IPPROTO_IP, 0, 0 };
d2464 1
a2464 1
	int			 mib[] = { CTL_NET, AF_INET, IPPROTO_PFSYNC,
d2982 1
a2982 1
	int	mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_FORWARDING };
d2997 1
a2997 1
	int	mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_DEFTTL };
d3012 1
a3012 1
	int	 mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
@


1.68
log
@Add support for exporting ARP table via ipNetToMediaTable OID.
With help from blambert@@ and sthen@@, tested by sthen@@, benno@@
and myself;  ok blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.67 2014/04/08 14:04:11 mpi Exp $	*/
d2821 1
a2821 1
	cif = malloc(sizeof(struct carpif));
a2822 1
		memset(cif, 0, sizeof(struct carpif));
@


1.67
log
@Use VM_UVMEXP instead of VM_METER for memory usages and directly
include <sys/vmmeter.h> where it is needed instead of relying on
it being included by <uvm/uvm_extern.h>.

miod@@ likes it, ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.66 2013/10/01 12:41:47 reyk Exp $	*/
d2928 3
d2966 8
a2974 4
	{ MIB(ipNetToMediaIfIndex) },
	{ MIB(ipNetToMediaPhysAddress) },
	{ MIB(ipNetToMediaNetAddress) },
	{ MIB(ipNetToMediaType) },
d3260 143
@


1.66
log
@Add initial SNMP client utility to snmpctl(8).
For example, snmpctl snmp walk 127.0.0.1

commit it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.65 2013/09/07 04:31:52 joel Exp $	*/
a575 1
	struct vmtotal		 vm;
a597 4
	mib[1] = VM_METER;
	len = sizeof(vm);
	if (sysctl(mib, sizeofa(mib), &vm, &len, NULL, 0) == -1)
		return (-1);
d626 1
a626 1
		used = size - vm.t_free;
@


1.65
log
@Sync PF-MIB and snmpd up with the pf(4) table byte/packet counters for
'match' rules

ok sten ryek
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.64 2013/03/11 19:49:37 sthen Exp $	*/
d238 1
a238 1
		smi_oidstring(&miboid->o_id, buf, sizeof(buf));
@


1.64
log
@Report new PF "translation" counter, indicating that address translation
has failed due to no free ports in the configured range. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.63 2012/12/18 21:28:45 millert Exp $	*/
d1551 4
d1579 8
d2181 16
d2267 16
@


1.63
log
@We no longer use struct eproc for kinfo_proc in sysctl.h so there
is no direct need for sys/proc.h or sys/resource.h.  Some consumers
of kinfo_proc need these for the proc flags and rlimit defines like
RLIM_INF so add the appropriate includes to them.
OK deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.62 2012/11/29 13:16:30 mikeb Exp $	*/
d1462 1
d1706 2
a1707 1
		{ 15, &s.counters[PFRES_SYNPROXY] }
@


1.62
log
@export ipintrq drops as ifInDiscards; ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.61 2012/10/01 11:36:55 reyk Exp $	*/
d22 1
@


1.61
log
@Support the 0.0.0.0 and 255.255.255.255 IPv4 addresses in the ipAddrTable.
This fixes an issue which aborted the address traversal / SNMP walk when
an "any"/0.0.0.0 address was configured on an interface.  The problem
was found with a pppoe(4) device that is typically configured with 0.0.0.0
on startup.

Found and fix tested by Gerhard Roth
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.60 2012/09/20 20:11:58 yuo Exp $	*/
d1172 9
a1180 1
		ber = ber_add_integer(ber, (u_int32_t)kif->if_iqdrops);
d1204 1
a1204 9
		mib[3] = IPCTL_IFQUEUE;
		mib[4] = IFQCTL_DROPS;
		len = sizeof(ifq);
		if (sysctl(mib, sizeofa(mib), &ifq, &len, 0, 0) == -1) {
			log_info("mib_iftable: %s: invalid ifq: %s",
			    kif->if_name, strerror(errno));
			return (-1);
		}
		ber = ber_add_integer(ber, ifq);
@


1.60
log
@add more sensor types to sensor framework.
 - Pressure (10^-3 Pa)
 - distance (10^-6 m)
 - acceleration (10^-6 m/s^2)

ok deraadt@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.59 2012/09/18 08:29:09 reyk Exp $	*/
d3142 1
a3142 1
	if (addr.sin_addr.s_addr == INADDR_ANY)
d3146 9
a3154 3
	if (ka == NULL || ka->addr.sa.sa_family != AF_INET)
		addr.sin_addr.s_addr = 0;
	else
d3156 2
a3157 1
	mps_encodeinaddr(no, &addr.sin_addr, OIDIDX_ipAddr + 1);
d3175 5
a3179 1
	mps_decodeinaddr(o, &addr.sin_addr, OIDIDX_ipAddr + 1);
@


1.59
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.58 2012/09/17 16:43:59 reyk Exp $	*/
d2583 2
a2584 1
	"", "", "%", "lx", "", "sec", "%RH", "Hz", "degree", ""
d2615 1
d2624 4
@


1.58
log
@Update copyright and my email address in snmpd while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.57 2012/09/17 16:30:34 reyk Exp $	*/
d398 1
a398 1
			   SNMP_T_COUNTER32);
d457 4
a460 4
	struct timeval  boottime;
	int		mib[] = { CTL_KERN, KERN_BOOTTIME };
	time_t 		now;
	size_t		len;
d465 1
a465 1
	if (sysctl(mib, 2, &boottime, &len, NULL, 0) == -1) 
d1485 1
a1485 1
	{ MIB(pfLimitMaxTables), 	OID_RD, mib_pflimits },
d1717 1
a1717 1
		}	
d1744 1
a1744 1
	default:	
d1752 1
a1752 1
			}	
d1790 1
a1790 1
	default:	
d1798 1
a1798 1
			}	
d1828 1
a1828 1
	default:	
d1836 1
a1836 1
			}	
d1869 1
a1869 1
		}	
d1925 1
a1925 1
		}	
d2056 1
a2056 1
	
d2275 1
a2275 1
	
d2422 1
a2422 1
	int 			 mib[] = { CTL_NET, AF_INET, IPPROTO_PFSYNC, 
d2425 1
a2425 1
	struct pfsyncstats 	 s;
d2447 1
a2447 1
	
d2457 2
a2458 1
			ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
d2460 1
a2460 1
		}	
d2665 1
a2665 1
	int	 		 mib[] = { CTL_NET, PF_INET, IPPROTO_CARP,
d2668 1
a2668 1
	struct	 		 carpstats stats;
d2703 1
a2703 1
		}	
d2789 1
a2789 1
	struct carpif 		*cif;
d3240 1
a3240 1
	
d3301 1
a3301 1
	switch(addr.sin_family) {
@


1.57
log
@Add initial SNMPv3 support to snmpd(8).

Traps are still sent via SNMPv2 protocol. They can neither be
authenticated nor encrypted. - Transport mode is still UDP. Not
additional transport subsystems were added. - Only the User-based
Security Model (USM, RFC3414) is supported.  View-Based Access Control
(VACM, RFC3415) is not included. - Configuration is described in
snmpd.conf(5).

This diff includes a few minor changes to ber.c/h adding a necessary
callback for the USM HMAC calculation and merging it with other
minor changes from ldapd's ber code.

From Gerhard Roth at genua
ok claudio@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.56 2012/07/08 11:24:43 blambert Exp $	*/
d5 1
a5 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@vantronix.net>
@


1.56
log
@a -> an in a comment

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.55 2012/06/19 18:43:27 matthew Exp $	*/
d333 73
d799 1
a799 1
		return (-1);
d3608 3
@


1.55
log
@Use calloc() instead of malloc() for allocating the disk stats.

Requested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.54 2012/06/14 17:31:32 matthew Exp $	*/
d984 1
a984 1
		 * It may happen that a interface with a specific index
@


1.54
log
@Add support for UCD-DISKIO-MIB.

ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.53 2012/05/26 14:45:55 joel Exp $	*/
d3409 1
a3409 2
	len = diskcount * sizeof(*stats);
	stats = malloc(len);
d3412 2
@


1.53
log
@Plug some leaks when certain error conditions are met.
From Gerhard Roth via tech@@

ok krw@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.52 2012/03/20 03:01:26 joel Exp $	*/
d35 1
d3367 93
d3549 3
@


1.52
log
@New OIDs hrSystemUptime, hrSystemDate, hrSystemProcesses and
hrSystemMaxProcesses.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.51 2012/02/27 16:45:16 sthen Exp $	*/
d1363 1
a1363 1
	*mib_carpifget(struct carpif *, u_int);
d2650 1
a2650 1
mib_carpifget(struct carpif *cif, u_int idx)
d2653 1
d2693 2
a2694 1
	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
d2696 1
d2698 6
a2703 3
	memset(cif, 0, sizeof(struct carpif));
	memcpy(&cif->carpr, &carpr, sizeof(struct carpreq));
	memcpy(&cif->kif, kif, sizeof(struct kif));
a2715 3
	if ((cif = malloc(sizeof(struct carpif))) == NULL)
		return (1);

d2719 1
a2719 2
	if ((cif = mib_carpifget(cif, idx)) == NULL) {
		free(cif);
a2720 1
	}
@


1.51
log
@Use correct Counter32 type for following MIBs. They only return dummy data
but we should use the correct type anyway.

BRIDGE-MIB::dot1dBasePortDelayExceededDiscards
BRIDGE-MIB::dot1dBasePortMtuExceededDiscards

OK joel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.50 2012/02/23 03:54:38 joel Exp $	*/
d26 1
d56 2
d335 3
d350 4
d379 93
@


1.50
log
@Bring in PF-MIB to snmpd.

ok krw@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.49 2012/01/31 18:00:46 joel Exp $	*/
d3311 1
@


1.49
log
@Add the OPENBSD-CARP-MIB to snmpd


ok camield@@, "start committing" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.48 2012/01/30 22:04:28 joel Exp $	*/
d4 1
d37 2
d52 1
d1221 1
d1232 18
d1254 1
d1264 159
d1466 821
@


1.48
log
@If a kernel sensor doesn't have a description, come up with something
useful rather than leaving that field empty.


ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.47 2011/09/16 20:52:48 yuo Exp $	*/
d30 1
d32 1
d39 1
d1216 10
a1225 3
 * Defined in OPENBSD-SENSORS-MIB.txt
 * (http://packetmischief.ca/openbsd/snmp/)
 */
d1231 6
d1249 27
d1461 186
@


1.47
log
@reorder SENSOR_* in switch() and add missing cases.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.46 2011/09/16 15:44:31 yuo Exp $	*/
d1274 1
d1319 7
a1325 1
		ber = ber_add_string(ber, sensor.desc);
@


1.46
log
@apply following changes to sensor framework:
- change accuracy of SENSOR_FREQ from Hz to muHz
- add SENSOR_VOLTS_AC entry to userland programs

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.45 2011/07/04 04:34:14 claudio Exp $	*/
d1351 1
a1351 1
	"", "", "%", "lx", "", "sec", ""
d1401 1
@


1.45
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.44 2011/04/10 03:20:59 guenther Exp $	*/
d1381 1
a1401 1
	case SENSOR_FREQ:
@


1.44
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.43 2010/10/15 11:56:13 sthen Exp $	*/
d961 1
a961 1
		if ((kif->if_flags & IFF_UP) == 0) {
d963 3
a965 1
		} else if (LINK_STATE_IS_UP(kif->if_link_state)) {
d967 1
a967 1
		} else if (kif->if_link_state == LINK_STATE_DOWN) {
a968 2
		} else
			i = 4;	/* unknown(4) */
@


1.43
log
@return numeric 0 rather than attempting to return a null string,
fixes a segfault when walking memiftable.

seems sane to phessler, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.42 2010/09/23 10:49:55 dlg Exp $	*/
d332 2
a333 2
int	 kinfo_proc(u_int32_t, struct kinfo_proc2 **);
int	 kinfo_args(struct kinfo_proc2 *, char **);
d610 1
a610 1
	struct kinfo_proc2	*kinfo;
d684 2
a685 2
	struct kinfo_proc2 * const *k1 = a;
	struct kinfo_proc2 * const *k2 = b;
d691 1
a691 1
kinfo_proc(u_int32_t idx, struct kinfo_proc2 **kinfo)
d693 1
a693 1
	static struct kinfo_proc2 *kp = NULL;
d695 1
a695 1
	int			 mib[] = { CTL_KERN, KERN_PROC2,
d697 1
a697 1
	struct kinfo_proc2	**klist;
d747 1
a747 1
kinfo_args(struct kinfo_proc2 *kinfo, char **s)
@


1.42
log
@tweak the mclgeti algorithm to behave better under load.

instead of letting hardware rings grow on every interrupt, restrict
it so it can only grow once per softclock tick. we can only punish
the rings on softclock ticks, so it make sense to only grow on
softclock tick boundaries too.

the rings are now punished after >1 lost softclock tick rather than
>2. mclgeti is now more aggressive at detecting livelock.

the rings get punished by an 8th, rather than by half.

we now allow the rings to be punished again even if the system is
already considered in livelock.

without this diff a livelocked system will have its rx ring sizes
scale up and down very rapidly, while holding the rings low for too
long. this affected throughput significantly.

discussed and tested heavily at j2k10. there are still some games
with softnet we can play, but this is a good first step.

"put it in" and ok deraadt@@
ok claudio@@ krw@@ henning@@ mcbride@@

if we find out that it sucks we can pull it out again later. till then
we'll run with it and see how it goes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.41 2010/09/20 16:29:51 sthen Exp $	*/
d1431 2
a1432 1
		ber = ber_add_string(ber, 0);
@


1.41
log
@fix-up the sysORTable by using the same name (sensorsMIBObjects) as used
in the MIB, rather than a different spelling (sensorMIBObjects).

ok martinh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.40 2010/06/11 10:45:36 jsg Exp $	*/
d1431 1
a1431 2
		ber = ber_add_integer(ber, kif->if_data.ifi_livelocks);
		ber_set_header(ber, BER_CLASS_APPLICATION, SNMP_T_COUNTER64);
@


1.40
log
@Implement IP-FORWARD-MIB, ipv4 only for now.

ok reyk@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.39 2010/04/27 15:37:13 jsg Exp $	*/
d1224 1
a1224 1
	{ MIB(sensorMIBObjects),	OID_MIB },
@


1.39
log
@Correct sensor logic so we don't get stuck in a loop.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.38 2010/04/20 20:49:36 deraadt Exp $	*/
d1778 243
d2103 3
@


1.38
log
@Get rid of MAXSENSORDEVICES.  Gaps in sensordev lists are now handled
by returning ENXIO instead of ENOENT, to essentially indicate hotplug
sensor that has gone away.  Accessing beyond the end of the sensordev
list still returns ENOENT, so that you can see there are no further devices.
ok kettenis oga
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.37 2010/04/20 19:44:07 oga Exp $	*/
a1252 2
			if (errno = ENOENT)
				break;
d1255 2
d1285 3
a1287 1
			if (errno == EINVAL)
a1288 2
			if (errno == ENOENT)
				continue;
d1297 5
a1301 3
					if (errno != ENOENT)
						return (-1);
					continue;
@


1.37
log
@Add "frequency" type for sensors. (and teach userland how to print that
type).  Measured in Hz.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.36 2010/04/15 04:57:29 yuo Exp $	*/
d1249 1
a1249 1
	for (i = c = 0; i < MAXSENSORDEVICES; i++) {
d1253 5
a1257 3
			if (errno != ENOENT)
				return (-1);
			continue;
d1282 1
a1282 1
	for (i = 0, n = 1; i < MAXSENSORDEVICES; i++) {
d1285 5
a1289 3
			if (errno != ENOENT)
				return (-1);
			continue;
@


1.36
log
@add SENSOR_HUMIDITY to sensor framework to handle humidity values

ok kettenis@@ xsa@@ sobrado@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.35 2010/03/31 09:20:23 claudio Exp $	*/
d1395 1
@


1.35
log
@Track interface addresses in a AF independent way. This is needed to support
the AF independent MIBs like RFC4292 in the future. Additionally count number
of routes (also needed by some MIBs) and do not track the state of routes
since the MIB do not require it and it is expensive.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.34 2010/01/11 11:15:03 deraadt Exp $	*/
d1381 1
@


1.34
log
@Do not use after free kif->if_index; discovered with claudio
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.33 2010/01/11 06:38:41 deraadt Exp $	*/
d1677 1
a1679 1
	struct in_addr		 addr;
d1682 4
d1707 2
a1708 2
	mps_decodeinaddr(no, &addr, OIDIDX_ipAddr + 1);
	if (addr.s_addr == INADDR_ANY)
d1711 6
a1716 3
		ka = kr_getnextaddr(&addr);
	addr.s_addr = ka == NULL ? 0 : ka->addr.s_addr;
	mps_encodeinaddr(no, &addr, OIDIDX_ipAddr + 1);
d1725 1
a1727 1
	struct in_addr		 addr;
d1730 7
a1736 3
	mps_decodeinaddr(o, &addr, OIDIDX_ipAddr + 1);
	ka = kr_getaddr(&addr);
	if (ka == NULL)
d1744 1
a1744 1
		val = addr.s_addr;
d1752 1
a1752 1
		val = ka->mask.s_addr;
d1757 1
a1757 1
		ber = ber_add_integer(ber, ka->dstbrd.s_addr ? 1 : 0);
@


1.33
log
@use calloc() instead of multiplying for malloc(); ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.32 2009/12/16 22:17:53 deraadt Exp $	*/
d884 1
d887 3
a889 3
	kr_updateif(kif->if_index);
	if ((kif = kr_getif(kif->if_index)) == NULL) {
		log_debug("mib_ifxtable: interface disappeared?");
@


1.32
log
@knf and unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.31 2009/08/14 19:44:14 cnst Exp $	*/
d726 1
a726 1
	klist = malloc(count * sizeof(*klist));
@


1.31
log
@SENSOR_WATTS;  ok reyk deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.30 2008/12/23 08:06:10 reyk Exp $	*/
d1235 1
a1235 1
	{ MIB(memIfName), 		OID_TRD, mib_memiftable },
d1272 1
a1272 1
	int			 i, c, j, k;
d1279 1
a1279 1
	for (i = c = 0, n = 1; i < MAXSENSORDEVICES; i++) {
@


1.30
log
@export the livelock counter in a private mib openBSD.5.

discussed with dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.29 2008/12/19 14:02:20 reyk Exp $	*/
d1369 1
@


1.29
log
@fix IF-MIB element and implementation ifInUnknownErrors -> ifInUnknownProtos
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.28 2008/12/08 11:34:55 reyk Exp $	*/
d1220 1
d1232 5
d1401 33
@


1.28
log
@report memory and swap in hrStorage, and implement hrProcessor to report
hrProcessorLoad (where load means the percentage of time the system was
not idle during the last minute).  based on HOST-RESOURCES-MIB.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.27 2008/03/18 16:57:58 reyk Exp $	*/
d848 1
a848 1
	{ MIB(ifInUnknownErrors),	OID_TRD, mib_iftable },
d995 1
a995 1
		ber = ber_add_integer(ber, 0);	/* unknown errors? */
d1019 1
a1019 1
		ber = ber_add_integer(ber, kif->if_noproto + ifq);
@


1.27
log
@remove ber_add_astring and make it the default behaviour in
ber_add_string, ber_add_nstring, and ber_add_bitstring to allocate and
copy the provided buffer instead of just attaching it to the ber
element.  this may add some overhead but fixes and avoids some bugs
with static buffers and simplifies the ber api again.

From Matthew at Dempsky dot org
With input from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.26 2008/03/17 14:47:20 reyk Exp $	*/
d29 1
d327 2
a336 1
	{ MIB(hrStorage),			OID_MIB },
d345 8
a352 1
	{ MIB(hrSWRun),				OID_MIB },
a382 1
	static struct ber_oid	 so = { { MIB_hrStorageFixedDisk } };
d385 14
a398 1
	int			 mntsize;
d400 21
d422 2
a423 2
	if (mntsize == 0)
		return (-1);
d425 7
a431 1
	/* Get and verify the current row index */
d433 1
a433 1
	if ((int)idx > mntsize)
d435 37
a476 2
	mnt = &mntbuf[idx - 1];

d482 2
a483 2
		smi_oidlen(&so);
		ber = ber_add_oid(ber, &so);
d486 1
a486 1
		ber = ber_add_string(ber, mnt->f_mntonname);
d489 1
a489 1
		ber = ber_add_integer(ber, mnt->f_bsize);
d492 1
a492 1
		ber = ber_add_integer(ber, mnt->f_blocks);
d495 1
a495 1
		ber = ber_add_integer(ber, mnt->f_blocks - mnt->f_bfree);
d498 58
a555 1
		ber = ber_add_integer(ber, 0);
d557 41
@


1.26
log
@convert more strings to use the new ber_add_astring() function which
simplifies the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.25 2008/03/17 14:40:15 reyk Exp $	*/
d226 1
a226 1
		ber = ber_add_astring(ber, buf);
d449 1
a449 1
		ber = ber_add_astring(ber, kinfo->p_comm);
d458 1
a458 1
		ber = ber_add_astring(ber, s);
d744 1
a744 1
		ber = ber_add_astring(ber, kif->if_name);
d886 1
a886 1
		ber = ber_add_astring(ber, kif->if_name);
d956 1
a956 1
		ber = ber_add_astring(ber, kif->if_descr);
d1037 1
a1037 1
char	*mib_sensorunit(struct sensor *);
d1124 1
a1124 1
		ber = ber_add_astring(ber, sensor.desc);
d1130 1
a1130 1
		ber = ber_add_astring(ber, sensordev.xname);
d1136 1
a1136 1
		ber->be_free = 1;
d1139 1
a1139 4
		if ((s = mib_sensorunit(&sensor)) == NULL)
			return (-1);
		ber = ber_add_string(ber, s);
		ber->be_free = 1;
d1160 1
a1160 1
char *
d1166 1
a1166 1
	return (strdup(sensor_unit_s[idx]));
@


1.25
log
@another sizeofa instead of sizeof fix
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.24 2008/03/17 13:56:17 reyk Exp $	*/
d189 1
a189 1
	char			 buf[SNMPD_MAXSTRLEN], *ptr;
d226 1
a226 6
		if ((ptr = strdup(buf)) == NULL) {
			ber = ber_add_string(ber, miboid->o_name);
		} else {
			ber = ber_add_string(ber, ptr);
			ber->be_free = 1;
		}
a723 1
	char			*s;
d744 1
a744 4
		if ((s = strdup(kif->if_name)) == NULL)
			return (-1);
		ber = ber_add_string(ber, s);
		ber->be_free = 1;
a873 1
	char			*s;
d886 1
a886 4
		if ((s = strdup(kif->if_name)) == NULL)
			return (-1);
		ber = ber_add_string(ber, s);
		ber->be_free = 1;
d956 1
a956 4
		if ((s = strdup(kif->if_descr)) == NULL)
			return (-1);
		ber = ber_add_string(ber, s);
		ber->be_free = 1;
d1124 1
a1124 4
		if ((s = strdup(sensor.desc)) == NULL)
			return (-1);
		ber = ber_add_string(ber, s);
		ber->be_free = 1;
d1130 1
a1130 4
		if ((s = strdup(sensordev.xname)) == NULL)
			return (-1);
		ber = ber_add_string(ber, s);
		ber->be_free = 1;
@


1.24
log
@fix incorrect use of sizeof() where there sizeofa() macro should be used

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.23 2008/03/16 00:35:05 dlg Exp $	*/
d1079 2
a1080 1
		if (sysctl(mib, sizeof(mib), &sensordev, &len, NULL, 0) == -1) {
@


1.23
log
@implement the hrSWRun portion of the HOST-RESOURCES mib. you can see whats
running now, which is another thing my nms at work likes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.22 2008/03/15 23:50:54 dlg Exp $	*/
d367 1
a367 1
	if (sysctl(mib, sizeof(mib), &physmem, &len, NULL, 0) == -1)
@


1.22
log
@provide sizeofa for counting the number of elements in an array. use it for
passing the length of the mib in all these sysctl calls.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.21 2008/03/15 00:56:08 dlg Exp $	*/
d331 5
d348 8
d425 189
@


1.21
log
@move zerodotzero up so more stuff can use it

this is an ok bit of a bigger diff that reyk wanted split up
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.20 2008/03/10 11:02:32 dlg Exp $	*/
d65 2
a350 1
	size_t			 miblen = sizeof(mib) / sizeof(mib[0]);
d354 1
a354 1
	if (sysctl(mib, miblen, &physmem, &len, NULL, 0) == -1)
d640 1
a640 2
		if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
		    &ifq, &len, 0, 0) == -1) {
d656 1
a656 2
		if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
		    &ifq, &len, 0, 0) == -1) {
a872 1
	size_t			 miblen = sizeof(mib) / sizeof(mib[0]);
d877 1
a877 2
		if (sysctl(mib, miblen,
		    &sensordev, &len, NULL, 0) == -1) {
d907 1
a907 2
		if (sysctl(mib, 3,
		    &sensordev, &len, NULL, 0) == -1) {
d1104 1
a1104 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &v, &len, NULL, 0) == -1)
d1119 1
a1119 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &v, &len, NULL, 0) == -1)
d1133 1
a1133 2
	return (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    ipstat, &len, NULL, 0));
@


1.20
log
@provide a partial implementation of the HOST-RESOURCES-MIB. this implements
the hrStorage part, which is enough to see how much space is used on your
filesystems. makes my nms happy.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.18 2008/01/18 18:38:35 reyk Exp $	*/
d63 1
a428 1
static struct ber_oid zerodotzero = { { 0, 0 }, 2 };
@


1.19
log
@spacing
@
text
@d29 1
d323 93
d1439 3
@


1.18
log
@implement very basic support of the BRIDGE-MIB which is enough to get
recognized as a network device by some NMS.
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.17 2008/01/16 09:51:15 reyk Exp $	*/
d1320 1
a1320 1
		ber = ber_add_integer(ber, 0);		
@


1.17
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.16 2007/12/29 09:24:43 reyk Exp $	*/
d363 1
a363 1
	{ MIB(ifDescr),			OID_TRD, mib_iftable },
d1272 56
d1351 3
@


1.16
log
@add the IP-MIB ipAddrTable.  it requires to encode the ipv4 addresses
in the OIDs as the table index.  the next step is to simplify the
common mib implementation regarding the special requirements of these
strange snmp tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.15 2007/12/28 16:59:31 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 Reyk Floeter <reyk@@vantronix.net>
@


1.15
log
@split code handling the "structure of management information" and the
"message processing subsystem" into separate files smi.c and mps.c
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.14 2007/12/28 16:27:51 reyk Exp $	*/
d959 3
d979 2
a980 1
	{ MIB(ipReasmTimeout),		OID_RD, mps_getint, NULL, IPFRAGTTL },
d987 10
a997 5
	{ MIB(ipAdEntAddr) },
	{ MIB(ipAdEntIfIndex) },
	{ MIB(ipAdEntNetMask) },
	{ MIB(ipAdEntBcastAddr) },
	{ MIB(ipAdEntReasmMaxSize) },
d1184 84
@


1.14
log
@split the MIB declarations (names) from the definitions (implementation).
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.13 2007/12/28 15:32:02 reyk Exp $	*/
d139 1
a139 1
		mps_oidlen(so);
d143 1
a143 1
		ticks = mps_getticks();
d189 1
a189 1
	    (next = mps_foreach(next, OID_MIB)) != NULL; nmib++);
d198 1
a198 1
	    (next = mps_foreach(next, OID_MIB)) != NULL; nmib++) {
d221 1
a221 1
		mps_oidstring(&miboid->o_id, buf, sizeof(buf));
d723 1
a723 1
	mps_oidlen(o);
d1188 1
a1188 1
	mps_mibtree(mib_tree);
d1195 1
a1195 1
	mps_mibtree(base_mib);
d1198 1
a1198 1
	mps_mibtree(if_mib);
d1201 1
a1201 1
	mps_mibtree(ip_mib);
d1204 1
a1204 1
	mps_mibtree(openbsd_mib);
@


1.13
log
@use the snmp camelCase for MIB definitions, this allows to simplify
the code a bit and is mostly a stylistic change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.12 2007/12/15 06:26:59 reyk Exp $	*/
d61 2
a64 6
	{ MIB(iso) },
	{ MIB(org) },
	{ MIB(dod) },
	{ MIB(internet) },
	{ MIB(directory) },
	{ MIB(mgmt) },
a65 1
	{ MIB(system) },
a73 2
	{ MIB(sysORTable) },
	{ MIB(sysOREntry) },
a77 1
	{ MIB(transmission) },
a108 20
	{ MIB(experimental) },
	{ MIB(private) },
	{ MIB(enterprises) },
	{ MIB(security) },
	{ MIB(snmpV2) },
	{ MIB(snmpDomains) },
	{ MIB(snmpProxies) },
	{ MIB(snmpModules) },
	{ MIB(snmpMIB) },
	{ MIB(snmpMIBObjects) },
	{ MIB(snmpTrap) },
	{ MIB(snmpTrapOID) },
	{ MIB(snmpTrapEnterprise) },
	{ MIB(snmpTraps) },
	{ MIB(coldStart) },
	{ MIB(warmStart) },
	{ MIB(linkDown) },
	{ MIB(linkUp) },
	{ MIB(authenticationFailure) },
	{ MIB(egpNeighborLoss) },
a337 3
	{ MIB(ifMIBObjects) },
	{ MIB(ifXTable) },
	{ MIB(ifXEntry) },
a356 4
	{ MIB(ifStackTable) },
	{ MIB(ifStackEntry) },
	{ MIB(ifRcvAddressTable) },
	{ MIB(ifRcvAddressEntry) },
a359 1
	{ MIB(interfaces) },
a360 2
	{ MIB(ifTable) },
	{ MIB(ifEntry) },
a751 49
 * PRIVATE ENTERPRISE NUMBERS from
 * http://www.iana.org/assignments/enterprise-numbers
 *
 * This is not the complete list of private enterprise numbers, it only
 * includes some well-known companies and especially network companies
 * that are very common in the datacenters around the world. It would
 * be an overkill to include ~30.000 entries for all the organizations
 * from the official list.
 */
static struct oid enterprise_mib[] = {
	{ MIB(ibm) },
	{ MIB(cmu) },
	{ MIB(unix) },
	{ MIB(ciscoSystems) },
	{ MIB(hp) },
	{ MIB(mit) },
	{ MIB(nortelNetworks) },
	{ MIB(sun) },
	{ MIB(3com) },
	{ MIB(synOptics) },
	{ MIB(enterasys) },
	{ MIB(sgi) },
	{ MIB(apple) },
	{ MIB(att) },
	{ MIB(nokia) },
	{ MIB(cern) },
	{ MIB(fsc) },
	{ MIB(compaq) },
	{ MIB(dell) },
	{ MIB(alteon) },
	{ MIB(extremeNetworks) },
	{ MIB(foundryNetworks) },
	{ MIB(huawaiTechnology) },
	{ MIB(ucDavis) },
	{ MIB(checkPoint) },
	{ MIB(juniper) },
	{ MIB(force10Networks) },
	{ MIB(alcatelLucent) },
	{ MIB(snom) },
	{ MIB(google) },
	{ MIB(f5Networks) },
	{ MIB(sFlow) },
	{ MIB(microSystems) },
	{ MIB(vantronix) },
	{ MIB(openBSD) },
	{ MIBEND }
};

/*
a762 1
	{ MIB(sensors) },
a763 2
	{ MIB(sensorTable) },
	{ MIB(sensorEntry) },
d969 1
d971 1
d983 1
a983 3
	{ MIB(ipRoutingDiscards) },
	{ MIB(ipAddrTable) },
	{ MIB(ipAddrEntry) },
a988 2
	{ MIB(ipNetToMediaTable) },
	{ MIB(ipNetToMediaEntry) },
d993 2
a994 1
	{ MIB(ipNetToMediaType) },
d1185 9
a1201 3

	/* some http://www.iana.org/assignments/enterprise-numbers */
	mps_mibtree(enterprise_mib);
@


1.12
log
@fix the sensors mib to match the new OpenBSD PEN
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.11 2007/12/15 04:15:12 reyk Exp $	*/
d63 74
a136 74
	{ MIB(ISO), "iso" },
	{ MIB(ORG), "org" },
	{ MIB(DOD), "dod" },
	{ MIB(INTERNET), "internet" },
	{ MIB(DIRECTORY), "directory" },
	{ MIB(MGMT), "mgmt" },
	{ MIB(MIB_2), "mib-2", OID_MIB },
	{ MIB(SYSTEM), "system" },
	{ MIB(SYSDESCR), "sysDescr", OID_RD,		mib_getsys },
	{ MIB(SYSOID), "sysOID", OID_RD,		mib_getsys },
	{ MIB(SYSUPTIME), "sysUpTime", OID_RD,		mib_getsys },
	{ MIB(SYSCONTACT), "sysContact", OID_RW,	mib_getsys, mps_setstr },
	{ MIB(SYSNAME), "sysName", OID_RW,		mib_getsys, mps_setstr },
	{ MIB(SYSLOCATION), "sysLocation", OID_RW,	mib_getsys, mps_setstr },
	{ MIB(SYSSERVICES), "sysServices", OID_RS,	mib_getsys },
	{ MIB(SYSORLASTCHANGE), "sysORLastChange", OID_RD, mps_getts },
	{ MIB(SYSORTABLE), "sysORTable" },
	{ MIB(SYSORENTRY), "sysOREntry" },
	{ MIB(SYSORINDEX), "sysORIndex", OID_TRD,	mib_sysor },
	{ MIB(SYSORID), "sysORID", OID_TRD,		mib_sysor },
	{ MIB(SYSORDESCR), "sysORDescr", OID_TRD,	mib_sysor },
	{ MIB(SYSORUPTIME), "sysORUptime", OID_TRD,	mib_sysor },
	{ MIB(TRANSMISSION), "transmission" },
	{ MIB(SNMP), "snmp", OID_MIB },
	{ MIB(SNMPINPKTS), "snmpInPkts", OID_RD,	mib_getsnmp },
	{ MIB(SNMPOUTPKTS), "snmpOutPkts", OID_RD,	mib_getsnmp },
	{ MIB(SNMPINBADVERSIONS), "snmpInBadVersions", OID_RD, mib_getsnmp },
	{ MIB(SNMPINBADCOMNNAMES), "snmpInBadCommunityNames", OID_RD, mib_getsnmp },
	{ MIB(SNMPINBADCOMNUSES), "snmpInBadCommunityUses", OID_RD, mib_getsnmp },
	{ MIB(SNMPINASNPARSEERRS), "snmpInASNParseErrs", OID_RD, mib_getsnmp },
	{ MIB(SNMPINTOOBIGS), "snmpInTooBigs", OID_RD,	mib_getsnmp },
	{ MIB(SNMPINNOSUCHNAMES), "snmpInNoSuchNames", OID_RD, mib_getsnmp },
	{ MIB(SNMPINBADVALUES), "snmpInBadValues", OID_RD, mib_getsnmp },
	{ MIB(SNMPINREADONLYS), "snmpInReadOnlys", OID_RD, mib_getsnmp },
	{ MIB(SNMPINGENERRS), "snmpInGenErrs", OID_RD,	mib_getsnmp },
	{ MIB(SNMPINTOTALREQVARS), "snmpInTotalReqVars", OID_RD, mib_getsnmp },
	{ MIB(SNMPINTOTALSETVARS), "snmpInTotalSetVars", OID_RD, mib_getsnmp },
	{ MIB(SNMPINGETREQUESTS), "snmpInGetRequests", OID_RD, mib_getsnmp },
	{ MIB(SNMPINGETNEXTS), "snmpInGetNexts", OID_RD, mib_getsnmp },
	{ MIB(SNMPINSETREQUESTS), "snmpInSetRequests", OID_RD, mib_getsnmp },
	{ MIB(SNMPINGETRESPONSES), "snmpInGetResponses", OID_RD, mib_getsnmp },
	{ MIB(SNMPINTRAPS), "snmpInTraps", OID_RD,	mib_getsnmp },
	{ MIB(SNMPOUTTOOBIGS), "snmpOutTooBigs", OID_RD, mib_getsnmp },
	{ MIB(SNMPOUTNOSUCHNAMES), "snmpOutNoSuchNames", OID_RD, mib_getsnmp },
	{ MIB(SNMPOUTBADVALUES), "snmpOutBadValues", OID_RD, mib_getsnmp },
	{ MIB(SNMPOUTGENERRS), "snmpOutGenErrs", OID_RD, mib_getsnmp },
	{ MIB(SNMPOUTGETREQUESTS), "snmpOutGetRequests", OID_RD, mib_getsnmp },
	{ MIB(SNMPOUTGETNEXTS), "snmpOutGetNexts", OID_RD, mib_getsnmp },
	{ MIB(SNMPOUTSETREQUESTS), "snmpOutSetRequests", OID_RD, mib_getsnmp },
	{ MIB(SNMPOUTGETRESPONSES), "snmpOutGetResponses", OID_RD, mib_getsnmp },
	{ MIB(SNMPOUTTRAPS), "snmpOutTraps", OID_RD,	mib_getsnmp },
	{ MIB(SNMPENAUTHTRAPS), "snmpEnableAuthenTraps", OID_RW, mib_getsnmp, mib_setsnmp },
	{ MIB(SNMPSILENTDROPS), "snmpSilentDrops", OID_RD, mib_getsnmp },
	{ MIB(SNMPPROXYDROPS), "snmpProxyDrops", OID_RD, mib_getsnmp },
	{ MIB(EXPERIMENTAL), "experimental" },
	{ MIB(PRIVATE), "private" },
	{ MIB(ENTERPRISES), "enterprises" },
	{ MIB(SECURITY), "security" },
	{ MIB(SNMPV2), "snmpV2" },
	{ MIB(SNMPDOMAINS), "snmpDomains" },
	{ MIB(SNMPPROXIES), "snmpProxies" },
	{ MIB(SNMPMODULES), "snmpModules" },
	{ MIB(SNMPMIB), "snmpMIB" },
	{ MIB(SNMPMIBOBJECTS), "snmpMIBObjects" },
	{ MIB(SNMPTRAP), "snmpTrap" },
	{ MIB(SNMPTRAPOID), "snmpTrapOID" },
	{ MIB(SNMPTRAPENTERPRISE), "snmpTrapEnterprise" },
	{ MIB(SNMPTRAPS), "snmpTraps" },
	{ MIB(COLDSTART), "coldStart" },
	{ MIB(WARMSTART), "warmStart" },
	{ MIB(LINKDOWN), "linkDown" },
	{ MIB(LINKUP), "linkUp" },
	{ MIB(AUTHFAILURE), "authenticationFailure" },
	{ MIB(EGPNEIGHBORLOSS), "egpNeighborLoss" },
d152 1
a152 1
	switch (oid->o_oid[OIDIDX_SYSTEM]) {
d220 1
a220 1
	idx = o->bo_id[OIDIDX_ORENTRY];
d236 1
a236 1
	switch (o->bo_id[OIDIDX_OR]) {
d314 1
a314 1
	switch (oid->o_oid[OIDIDX_SNMP]) {
d322 1
a322 1
			if (oid->o_oid[OIDIDX_SNMP] == mapping[i].m_id) {
d365 56
a420 56
	{ MIB(IFMIB), "ifMIB", OID_MIB },
	{ MIB(IFMIBOBJECTS), "ifMIBObjects" },
	{ MIB(IFXTABLE), "ifXTable" },
	{ MIB(IFXENTRY), "ifXEntry" },
	{ MIB(IFNAME), "ifName", OID_TRD,		mib_ifxtable },
	{ MIB(IFINMASTPKTS), "ifInMulticastPkts", OID_TRD, mib_ifxtable },
	{ MIB(IFINBASTPKTS), "ifInBroadcastPkts", OID_TRD, mib_ifxtable },
	{ MIB(IFOUTMASTPKTS), "ifOutMulticastPkts", OID_TRD, mib_ifxtable },
	{ MIB(IFOUTBASTPKTS), "ifOurBroadcastPkts", OID_TRD, mib_ifxtable },
	{ MIB(IFHCINOCTETS), "ifHCInOctets", OID_TRD,	mib_ifxtable },
	{ MIB(IFHCINUCASTPKTS), "ifHCInUcastPkts", OID_TRD, mib_ifxtable },
	{ MIB(IFHCINMCASTPKTS), "ifHCInMulticastPkts", OID_TRD, mib_ifxtable },
	{ MIB(IFHCINBCASTPKTS), "ifHCInBroadcastPkts", OID_TRD, mib_ifxtable },
	{ MIB(IFHCOUTOCTETS), "ifHCOutOctets", OID_TRD,	mib_ifxtable },
	{ MIB(IFHCOUTUCASTPKTS), "ifHCOutUcastPkts", OID_TRD, mib_ifxtable },
	{ MIB(IFHCOUTMCASTPKTS), "ifHCOutMulticastPkts", OID_TRD, mib_ifxtable },
	{ MIB(IFHCOUTBCASTPKTS), "ifHCOutBroadcastPkts", OID_TRD, mib_ifxtable },
	{ MIB(IFLINKUPDORNTRAPENABLE), "ifLinkUpDownTrapEnable", OID_TRD, mib_ifxtable },
	{ MIB(IFHIGHSPEED), "ifHighSpeed", OID_TRD,	mib_ifxtable },
	{ MIB(IFPROMISCMODE), "ifPromiscuousMode", OID_TRD, mib_ifxtable },
	{ MIB(IFCONNECTORPRESENT), "ifConnectorPresent", OID_TRD, mib_ifxtable },
	{ MIB(IFALIAS), "ifAlias", OID_TRD,		mib_ifxtable },
	{ MIB(IFCNTDISCONTINUITYTIME), "ifCounterDiscontinuityTime", OID_TRD, mib_ifxtable },
	{ MIB(IFSTACKTABLE), "ifStackTable" },
	{ MIB(IFSTACKENTRY), "ifStackEntry" },
	{ MIB(IFRCVTABLE), "ifRcvAddressTable" },
	{ MIB(IFRCVENTRY), "ifRcvAddressEntry" },
	{ MIB(IFRCVSTATUS), "ifRcvAddressStatus", OID_TRD, mib_ifrcvtable },
	{ MIB(IFRCVTYPE), "ifRcvAddressType", OID_TRD,	mib_ifrcvtable },
	{ MIB(IFSTACKLASTCHANGE), "ifStackLastChange", OID_RD, mib_ifstacklast },
	{ MIB(INTERFACES), "interfaces" },
	{ MIB(IFNUMBER), "ifNumber", OID_RD,		mib_ifnumber },
	{ MIB(IFTABLE), "ifTable" },
	{ MIB(IFENTRY), "ifEntry" },
	{ MIB(IFINDEX), "ifIndex", OID_TRD,		mib_iftable },
	{ MIB(IFDESCR), "ifDescr", OID_TRD,		mib_iftable },
	{ MIB(IFTYPE), "ifDescr", OID_TRD,		mib_iftable },
	{ MIB(IFMTU), "ifMtu", OID_TRD,			mib_iftable },
	{ MIB(IFSPEED), "ifSpeed", OID_TRD,		mib_iftable },
	{ MIB(IFPHYSADDR), "ifPhysAddress", OID_TRD,	mib_iftable },
	{ MIB(IFADMINSTATUS), "ifAdminStatus", OID_TRD,	mib_iftable },
	{ MIB(IFOPERSTATUS), "ifOperStatus", OID_TRD,	mib_iftable },
	{ MIB(IFLASTCHANGE), "ifLastChange", OID_TRD,	mib_iftable },
	{ MIB(IFINOCTETS), "ifInOctets", OID_TRD,	mib_iftable },
	{ MIB(IFINUCASTPKTS), "ifInUcastPkts", OID_TRD,	mib_iftable },
	{ MIB(IFINNUCASTPKTS), "ifInNUcastPkts", OID_TRD, mib_iftable },
	{ MIB(IFINDISCARDS), "ifInDiscards", OID_TRD,	mib_iftable },
	{ MIB(IFINERRORS), "ifInErrors", OID_TRD,	mib_iftable },
	{ MIB(IFINUNKNOWNERRORS), "ifInUnknownErrors", OID_TRD,	mib_iftable },
	{ MIB(IFOUTOCTETS), "ifOutOctets", OID_TRD,	mib_iftable },
	{ MIB(IFOUTUCASTPKTS), "ifOutUcastPkts", OID_TRD, mib_iftable },
	{ MIB(IFOUTNUCASTPKTS), "ifOutNUcastPkts", OID_TRD, mib_iftable },
	{ MIB(IFOUTDISCARDS), "ifOutDiscards", OID_TRD,	mib_iftable },
	{ MIB(IFOUTERRORS), "ifOutErrors", OID_TRD,	mib_iftable },
	{ MIB(IFOUTQLEN), "ifOutQLen", OID_TRD,		mib_iftable },
	{ MIB(IFSPECIFIC), "ifSpecific", OID_TRD,	mib_iftable },
d473 1
a473 1
	idx = o->bo_id[OIDIDX_IFENTRY];
d478 1
a478 1
	o->bo_id[OIDIDX_IFENTRY] = kif->if_index;
d481 1
a481 1
	switch (o->bo_id[OIDIDX_IF]) {
d629 1
a629 1
	idx = o->bo_id[OIDIDX_IFXENTRY];
d634 1
a634 1
	o->bo_id[OIDIDX_IFXENTRY] = kif->if_index;
d637 1
a637 1
	switch (o->bo_id[OIDIDX_IFX]) {
d746 1
a746 1
	idx = o->bo_id[OIDIDX_IFRCVENTRY];
d759 2
a760 2
	o->bo_id[OIDIDX_IFRCVENTRY + idx++] = kif->if_index;
	o->bo_id[OIDIDX_IFRCVENTRY + idx] = 0;
d764 1
a764 1
	o->bo_id[OIDIDX_IFRCVENTRY + idx++] = sizeof(kif->if_lladdr);
d767 1
a767 1
		o->bo_id[OIDIDX_IFRCVENTRY + idx++] = kif->if_lladdr[i];
d772 1
a772 1
	switch (o->bo_id[OIDIDX_IFRCV]) {
d800 35
a834 35
	{ MIB(IBM), "ibm" },
	{ MIB(CMU), "cmu" },
	{ MIB(UNIX), "unix" },
	{ MIB(CISCO), "ciscoSystems" },
	{ MIB(HP), "hp" },
	{ MIB(MIT), "mit" },
	{ MIB(NORTEL), "nortelNetworks" },
	{ MIB(SUN), "sun" },
	{ MIB(3COM), "3com" },
	{ MIB(SYNOPTICS), "synOptics" },
	{ MIB(ENTERASYS), "enterasys" },
	{ MIB(SGI), "sgi" },
	{ MIB(APPLE), "apple" },
	{ MIB(ATT), "att" },
	{ MIB(NOKIA), "nokia" },
	{ MIB(CERN), "cern" },
	{ MIB(FSC), "fsc" },
	{ MIB(COMPAQ), "compaq" },
	{ MIB(DELL), "dell" },
	{ MIB(ALTEON), "alteon" },
	{ MIB(EXTREME), "extremeNetworks" },
	{ MIB(FOUNDRY), "foundryNetworks" },
	{ MIB(HUAWAI), "huawaiTechnology" },
	{ MIB(UCDAVIS), "ucDavis" },
	{ MIB(CHECKPOINT), "checkPoint" },
	{ MIB(JUNIPER), "juniper" },
	{ MIB(FORCE10), "force10Networks" },
	{ MIB(ALCATELLUCENT), "alcatelLucent" },
	{ MIB(SNOM), "snom" },
	{ MIB(GOOGLE), "google" },
	{ MIB(F5), "f5Networks" },
	{ MIB(SFLOW), "sFlow" },
	{ MIB(MSYS), "microSystems" },
	{ MIB(VANTRONIX), "vantronix" },
	{ MIB(OPENBSD), "openBSD" },
d849 12
a860 12
	{ MIB(SENSORMIBOBJECTS), "sensorMIBObjects", OID_MIB },
	{ MIB(SENSORS), "sensors" },
	{ MIB(SENSORNUMBER), "sensorNumber", OID_RD,	mib_sensornum },
	{ MIB(SENSORTABLE), "sensorTable" },
	{ MIB(SENSORENTRY), "sensorEntry" },
	{ MIB(SENSORINDEX), "sensorIndex", OID_TRD,	mib_sensors },
	{ MIB(SENSORDESCR), "sensorDescr", OID_TRD,	mib_sensors },
	{ MIB(SENSORTYPE), "sensorType", OID_TRD,	mib_sensors },
	{ MIB(SENSORDEVICE), "sensorDevice", OID_TRD,	mib_sensors },
	{ MIB(SENSORVALUE), "sensorValue", OID_TRD,	mib_sensors },
	{ MIB(SENSORUNITS), "sensorUnits", OID_TRD,	mib_sensors },
	{ MIB(SENSORSTATUS), "sensorStatus", OID_TRD,	mib_sensors },
d902 1
a902 1
	idx = o->bo_id[OIDIDX_SENSORENTRY];
d910 1
a910 1
			continue;	
d920 1
a920 1
					continue;	
d932 1
a932 1
	switch (o->bo_id[OIDIDX_SENSOR]) {
d1051 35
a1085 35
	{ MIB(IPMIB), "ipMIB", OID_MIB },
	{ MIB(IPFORWARDING), "ipForwarding", OID_RD, mib_ipforwarding },
	{ MIB(IPDEFAULTTTL), "ipDefaultTTL", OID_RD, mib_ipdefaultttl },
	{ MIB(IPINRECEIVES), "ipInReceives", OID_RD, mib_ipstat },
	{ MIB(IPINHDRERRORS), "ipInHdrErrors", OID_RD, mib_ipinhdrerrs },
	{ MIB(IPINADDRERRORS), "ipInAddrErrors", OID_RD, mib_ipinaddrerrs },
	{ MIB(IPFORWDATAGRAMS), "ipForwDatagrams", OID_RD, mib_ipforwdgrams },
	{ MIB(IPINUNKNOWNPROTOS), "ipInUnknownProtos", OID_RD, mib_ipstat },
	{ MIB(IPINDISCARDS), "ipInDiscards" },
	{ MIB(IPINDELIVERS), "ipInDelivers", OID_RD, mib_ipstat },
	{ MIB(IPOUTREQUESTS), "ipOutRequests", OID_RD, mib_ipstat },
	{ MIB(IPOUTDISCARDS), "ipOutDiscards", OID_RD, mib_ipstat },
	{ MIB(IPOUTNOROUTES), "ipOutNoRoutes", OID_RD, mib_ipstat },
	{ MIB(IPREASMTIMEOUT), "ipReasmTimeout", OID_RD, mps_getint, NULL, IPFRAGTTL },
	{ MIB(IPREASMREQDS), "ipReasmReqds", OID_RD, mib_ipstat },
	{ MIB(IPREASMOKS), "ipReasmOKs", OID_RD, mib_ipstat },
	{ MIB(IPREASMFAILS), "ipReasmFails", OID_RD, mib_ipreasmfails },
	{ MIB(IPFRAGOKS), "ipFragOKs", OID_RD, mib_ipstat },
	{ MIB(IPFRAGFAILS), "ipFragFails", OID_RD, mib_ipfragfails },
	{ MIB(IPFRAGCREATES), "ipFragCreate", OID_RD, mib_ipstat },
	{ MIB(IPROUTINGDISCARDS), "ipRoutingDiscards" },
	{ MIB(IPADDRTABLE), "ipAddrTable" },
	{ MIB(IPADDRENTRY), "ipAddrEntry" },
	{ MIB(IPADENTADDR), "ipAdEntAddr" },
	{ MIB(IPADENTIFINDEX), "ipAdEntIfIndex" },
	{ MIB(IPADENTNETMASK), "ipAdEntNetMask" },
	{ MIB(IPADENTBCASTADDR), "ipAdEntBcastAddr" },
	{ MIB(IPADENTREASMMAXSIZE), "ipAdEntReasmMaxSize" },
	{ MIB(IPNETTOMEDIATABLE), "ipNetToMediaTable" },
	{ MIB(IPNETTOMEDIAENTRY), "ipNetToMediaEntry" },
	{ MIB(IPNETTOMEDIAIFINDEX), "ipNetToMediaIfIndex" },
	{ MIB(IPNETTOMEDIAPHYSADDRESS), "ipNetToMediaPhysAddress" },
	{ MIB(IPNETTOMEDIANETADDRESS), "ipNetToMediaNetAddress" },
	{ MIB(IPNETTOMEDIATYPE), "ipNetToMediaType" },
	{ MIB(IPNETTOMEDIATYPE), "ipNetToMediaType" },
d1099 1
a1099 1
	
d1157 1
a1157 1
		if (oid->o_oid[OIDIDX_IP] == mapping[i].m_id) {
@


1.11
log
@shrink the code by making some ipstat parts table-driven.  at some
point i may want to define a general table-driven interface for mibs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.10 2007/12/15 03:02:59 reyk Exp $	*/
d870 1
d875 1
a875 1
		if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
a902 3
 
	mib[0] = CTL_HW;
	mib[1] = HW_SENSORS;
d906 1
a906 1
		if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
d909 1
a909 1
				return(-1);
d916 1
a916 1
				if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
@


1.10
log
@ips_odropped is ipOutDiscards not ipInDiscards
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.9 2007/12/15 02:53:22 gilles Exp $	*/
d1039 2
a1040 1
int mib_ipstat(struct ipstat *);
d1043 3
a1045 6
int mib_ipinreceives(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipinhdrerrors(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipinaddrerrors(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipforwdatagrams(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipinunknownprotos(struct oid *, struct ber_oid *,
    struct ber_element **);
a1046 7
int mib_ipindelivers(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipoutrequests(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipoutdiscards(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipoutnoroutes(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipreasmtimeout(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipreasmreqds(struct oid *, struct ber_oid *, struct ber_element **);
int mib_ipreasmoks(struct oid *, struct ber_oid *, struct ber_element **);
a1047 1
int mib_ipfragoks(struct oid *, struct ber_oid *, struct ber_element **);
a1048 1
int mib_ipfragcreate(struct oid *, struct ber_oid *, struct ber_element **);
d1056 5
a1060 5
	{ MIB(IPINRECEIVES), "ipInReceives", OID_RD, mib_ipinreceives },
	{ MIB(IPINHDRERRORS), "ipInHdrErrors", OID_RD, mib_ipinhdrerrors },
	{ MIB(IPINADDRERRORS), "ipInAddrErrors", OID_RD, mib_ipinaddrerrors },
	{ MIB(IPFORWDATAGRAMS), "ipForwDatagrams", OID_RD, mib_ipforwdatagrams },
	{ MIB(IPINUNKNOWNPROTOS), "ipInUnknownProtos", OID_RD, mib_ipinunknownprotos },
d1062 7
a1068 7
	{ MIB(IPINDELIVERS), "ipInDelivers", OID_RD, mib_ipindelivers },
	{ MIB(IPOUTREQUESTS), "ipOutRequests", OID_RD, mib_ipoutrequests },
	{ MIB(IPOUTDISCARDS), "ipOutDiscards", OID_RD, mib_ipoutdiscards },
	{ MIB(IPOUTNOROUTES), "ipOutNoRoutes", OID_RD, mib_ipoutnoroutes },
	{ MIB(IPREASMTIMEOUT), "ipReasmTimeout", OID_RD, mib_ipreasmtimeout },
	{ MIB(IPREASMREQDS), "ipReasmReqds", OID_RD, mib_ipreasmreqds },
	{ MIB(IPREASMOKS), "ipReasmOKs", OID_RD, mib_ipreasmoks },
d1070 1
a1070 1
	{ MIB(IPFRAGOKS), "ipFragOKs", OID_RD, mib_ipfragoks },
d1072 1
a1072 1
	{ MIB(IPFRAGCREATES), "ipFragCreate", OID_RD, mib_ipfragcreate },
a1091 10
mib_ipstat(struct ipstat *ipstat)
{
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
	size_t		len = sizeof(*ipstat);

	return (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    ipstat, &len, NULL, 0));
}

int
d1124 1
a1124 1
mib_ipinreceives(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
d1126 27
a1152 1
	struct ipstat	ipstat;
d1154 1
a1154 1
	if (mib_ipstat(&ipstat) == -1)
d1157 9
a1165 2
	*elm = ber_add_integer(*elm, ipstat.ips_total);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);
d1167 1
a1167 1
	return (0);
d1171 1
a1171 1
mib_ipinhdrerrors(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
d1176 1
a1176 1
	if (mib_ipstat(&ipstat) == -1)
d1192 1
a1192 1
mib_ipinaddrerrors(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
d1197 1
a1197 1
	if (mib_ipstat(&ipstat) == -1)
d1209 1
a1209 1
mib_ipforwdatagrams(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
d1214 1
a1214 1
	if (mib_ipstat(&ipstat) == -1)
a1225 14
mib_ipinunknownprotos(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ipstat	ipstat;

	if (mib_ipstat(&ipstat) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, ipstat.ips_noproto);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
a1231 93
mib_ipindelivers(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ipstat	ipstat;

	if (mib_ipstat(&ipstat) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, ipstat.ips_delivered);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_ipoutrequests(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ipstat	ipstat;

	if (mib_ipstat(&ipstat) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, ipstat.ips_localout);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_ipoutdiscards(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	u_int32_t	counter;
	struct ipstat	ipstat;

	if (mib_ipstat(&ipstat) == -1)
		return (-1);

	counter = ipstat.ips_odropped;
	*elm = ber_add_integer(*elm, counter);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_ipoutnoroutes(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ipstat	ipstat;

	if (mib_ipstat(&ipstat) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, ipstat.ips_noroute);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_ipreasmtimeout(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	*elm = ber_add_integer(*elm, IPFRAGTTL);
	return (0);
}

int
mib_ipreasmreqds(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ipstat	ipstat;

	if (mib_ipstat(&ipstat) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, ipstat.ips_fragments);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_ipreasmoks(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ipstat	ipstat;

	if (mib_ipstat(&ipstat) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, ipstat.ips_reassembled);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
d1237 1
a1237 1
	if (mib_ipstat(&ipstat) == -1)
a1248 14
mib_ipfragoks(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ipstat	ipstat;

	if (mib_ipstat(&ipstat) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, ipstat.ips_fragmented);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
d1254 1
a1254 1
	if (mib_ipstat(&ipstat) == -1)
a1258 14
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

	return (0);
}

int
mib_ipfragcreate(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
{
	struct ipstat	ipstat;

	if (mib_ipstat(&ipstat) == -1)
		return (-1);

	*elm = ber_add_integer(*elm, ipstat.ips_ofragments);
@


1.9
log
@add support for ipReasmTimeout

ok (and thanks to) reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.8 2007/12/15 02:37:58 reyk Exp $	*/
d1072 1
a1072 1
	{ MIB(IPINDISCARDS), "ipInDiscards", OID_RD, mib_ipindiscards },
d1075 1
a1075 1
	{ MIB(IPOUTDISCARDS), "ipOutDiscards" },
a1229 10
	u_int32_t	counter;
	struct ipstat	ipstat;

	if (mib_ipstat(&ipstat) == -1)
		return (-1);

	counter = ipstat.ips_odropped;
	*elm = ber_add_integer(*elm, counter);
	ber_set_header(*elm, BER_CLASS_APPLICATION, SNMP_T_COUNTER32);

d1264 10
@


1.8
log
@implement one function to call the ipstat sysctl needed in a number of
places instead of repeating the code.

inspired by an idea from gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.7 2007/12/15 02:20:03 reyk Exp $	*/
d33 2
d1294 1
@


1.7
log
@more sysctl style changes for older code
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.6 2007/12/15 02:14:30 reyk Exp $	*/
d875 2
a876 2
				return(-1);
			continue;	
d1037 1
d1044 2
a1045 1
int mib_ipinunknownprotos(struct oid *, struct ber_oid *, struct ber_element **);
a1050 1

a1054 1

d1058 2
a1059 2

int mib_iproutingdiscards(struct oid *, struct ber_oid *, struct ber_element **);
a1082 1

a1089 1

a1096 1

d1101 10
a1144 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1145 1
	size_t		len = sizeof(ipstat);
d1147 1
a1147 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
d1159 1
a1159 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1160 2
	size_t		len = sizeof(ipstat);
	u_int32_t	errors;
d1162 1
a1162 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
d1180 1
a1180 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1181 2
	size_t		len = sizeof(ipstat);
	u_int32_t	errors;
d1183 1
a1183 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
a1187 1

d1197 1
a1197 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1198 2
	size_t		len = sizeof(ipstat);
	u_int32_t	counter;
d1200 1
a1200 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
a1213 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1214 1
	size_t		len = sizeof(ipstat);
d1216 1
a1216 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
d1228 1
a1228 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1229 2
	size_t		len = sizeof(ipstat);
	u_int32_t	counter;
d1231 1
a1231 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
a1243 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1244 1
	size_t		len = sizeof(ipstat);
d1246 1
a1246 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
d1248 1
a1248 1
	
a1257 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1258 1
	size_t		len = sizeof(ipstat);
d1260 1
a1260 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
d1262 1
a1262 1
	
a1277 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1278 1
	size_t		len = sizeof(ipstat);
d1280 1
a1280 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
d1282 1
a1282 1
	
a1297 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1298 1
	size_t		len = sizeof(ipstat);
d1300 1
a1300 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
d1302 1
a1302 1
	
a1311 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1312 1
	size_t		len = sizeof(ipstat);
d1314 1
a1314 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
d1316 1
a1316 1
	
d1326 1
a1326 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1327 2
	size_t		len = sizeof(ipstat);
	u_int32_t	counter;
d1329 1
a1329 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
a1342 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1343 1
	size_t		len = sizeof(ipstat);
d1345 1
a1345 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
d1347 1
a1347 1
	
d1357 1
a1357 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1358 2
	size_t		len = sizeof(ipstat);
	u_int32_t	counter;
d1360 1
a1360 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
a1372 1
	int		mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
a1373 1
	size_t		len = sizeof(ipstat);
d1375 1
a1375 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1)
d1377 1
a1377 1
	
d1385 2
a1386 1
mib_iproutingdiscards(struct oid *oid, struct ber_oid *o, struct ber_element **elm)
@


1.6
log
@change the style of the sysctl mib setup
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.5 2007/12/15 02:02:45 gilles Exp $	*/
d467 1
a467 1
	int			 mib[5];
a577 3
		mib[0] = CTL_NET;
		mib[1] = AF_INET;
		mib[2] = IPPROTO_IP;
d581 2
a582 1
		if (sysctl(mib, 5, &ifq, &len, 0, 0) == -1) {
a594 3
		mib[0] = CTL_NET;
		mib[1] = AF_INET;
		mib[2] = IPPROTO_IP;
d598 2
a599 1
		if (sysctl(mib, 5, &ifq, &len, 0, 0) == -1) {
d867 2
a868 4
	int			 mib[3], i, c;

	mib[0] = CTL_HW;
	mib[1] = HW_SENSORS;
d872 2
a873 1
		if (sysctl(mib, 3, &sensordev, &len, NULL, 0) == -1) {
d893 2
a894 1
	int			 mib[5], i, c, j, k;
d906 2
a907 1
		if (sysctl(mib, 3, &sensordev, &len, NULL, 0) == -1) {
d916 2
a917 2
				if (sysctl(mib, 5, &sensor,
				    &slen, NULL, 0) == -1) {
@


1.5
log
@now that ip statistics are available through sysctl, make snmpd's IP-MIB
	aware of them

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.4 2007/12/10 23:23:21 gilles Exp $	*/
d1109 1
a1109 1
	int	mib[4];
d1111 1
a1111 8
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_FORWARDING;

	len = sizeof(v);
d1113 2
a1114 1
	if (sysctl(mib, 4, &v, &len, NULL, 0) == -1)
d1125 1
a1125 1
	int	mib[4];
d1127 1
a1127 6
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_DEFTTL;
d1129 2
a1130 3
	len = sizeof(v);

	if (sysctl(mib, 4, &v, &len, NULL, 0) == -1)
d1141 3
a1143 8
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;
d1145 2
a1146 3
	len = sizeof(ipstat);

	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1158 4
a1161 9
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	u_int32_t errors;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;
d1163 2
a1164 3
	len = sizeof(ipstat);

	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1182 4
a1185 9
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	u_int32_t errors;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;
d1187 2
a1188 3
	len = sizeof(ipstat);

	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1203 4
a1206 9
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	u_int32_t counter;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;
d1208 2
a1209 3
	len = sizeof(ipstat);

	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1223 3
a1225 8
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;
d1227 2
a1228 3
	len = sizeof(ipstat);

	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1240 4
a1243 9
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	u_int32_t counter;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;
d1245 2
a1246 3
	len = sizeof(ipstat);

	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1259 3
a1261 8
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;
d1263 2
a1264 3
	len = sizeof(ipstat);

	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1276 3
a1278 10
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;

	len = sizeof(ipstat);
d1280 2
a1281 1
	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1299 3
a1301 10
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;

	len = sizeof(ipstat);
d1303 2
a1304 1
	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1322 3
a1324 10
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;

	len = sizeof(ipstat);
d1326 2
a1327 1
	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1339 3
a1341 10
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;

	len = sizeof(ipstat);
d1343 2
a1344 1
	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1356 4
a1359 11
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	u_int32_t counter;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;

	len = sizeof(ipstat);
d1361 2
a1362 1
	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1376 3
a1378 10
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;

	len = sizeof(ipstat);
d1380 2
a1381 1
	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1393 4
a1396 11
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	u_int32_t counter;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;

	len = sizeof(ipstat);
d1398 2
a1399 1
	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
d1412 3
a1414 10
	int	mib[4];
	struct ipstat ipstat;
	size_t	len;
	
	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_STATS;

	len = sizeof(ipstat);
d1416 2
a1417 1
	if (sysctl(mib, 4, &ipstat, &len, NULL, 0) == -1)
@


1.4
log
@add ip_mib table as well as support for retrieving ipForwarding and
	ipDefaultTTL

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.3 2007/12/06 09:08:05 reyk Exp $	*/
d33 1
d1042 21
d1068 8
a1075 8
	{ MIB(IPINRECEIVES), "ipInReceives" },
	{ MIB(IPINHDRERRORS), "ipInHdrErrors" },
	{ MIB(IPINADDRERRORS), "ipInAddrErrors" },
	{ MIB(IPFORWDATAGRAMS), "ipForwDatagrams" },
	{ MIB(IPINUNKNOWNPROTOS), "ipInUnknownProtos" },
	{ MIB(IPINDISCARDS), "ipInDiscards" },
	{ MIB(IPINDELIVERS), "ipInDelivers" },
	{ MIB(IPOUTREQUESTS), "ipOutRequests" },
d1077 26
a1102 8
	{ MIB(IPOUTNOROUTES), "ipOutNoRoutes" },
	{ MIB(IPREASMTIMEOUT), "ipReasmTimeout" },
	{ MIB(IPREASMREQDS), "ipReasmReqds" },
	{ MIB(IPREASMOKS), "ipReasmOKs" },
	{ MIB(IPREASMFAILS), "ipReasmFails" },
	{ MIB(IPFRAGOKS), "ipFragOKs" },
	{ MIB(IPFRAGFAILS), "ipFragFails" },
	{ MIB(IPFRAGCREATES), "ipFragCreate" },
d1121 1
a1121 1
		return(-1);
d1143 1
a1143 1
		return(-1);
d1147 384
@


1.3
log
@do not re-use static char buffers, allocate them; this avoids some
strange effects in GETBULK mode. (this should go into ber.c).
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.2 2007/12/05 22:52:50 reyk Exp $	*/
d1039 71
d1122 3
@


1.2
log
@- add support joel's OPENBSD-SENSORS-MIB; it will dump the current
sensor status in a SNMP table.
- some other minor changes
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.1 2007/12/05 09:22:44 reyk Exp $	*/
d467 1
d488 4
a491 1
		ber = ber_add_string(ber, kif->if_name);
d627 1
d640 4
a643 1
		ber = ber_add_string(ber, kif->if_name);
d713 4
a716 1
		ber = ber_add_string(ber, kif->if_descr);
@


1.1
log
@Start working on snmpd(8) and snmpctl(8), a lightweight SNMP implementation
for OpenBSD.  SNMP is a necessary evil.  This is work in progress, don't
expect too much from it yet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mib.c,v 1.14 2007/11/13 20:08:47 reyk Exp $	*/
d28 1
d133 2
a134 1
	{ MIB(EGPNEIGHBORLOSS), "egpNeighborLoss" }
d417 2
a418 1
	{ MIB(IFSPECIFIC), "ifSpecific", OID_TRD,	mib_iftable }
d824 2
a825 1
	{ MIB(OPENBSD), "openBSD" }
d828 204
d1036 1
a1036 1
	mps_mibtree(base_mib, sizeof(base_mib) / sizeof(base_mib[0]));
d1039 1
a1039 1
	mps_mibtree(if_mib, sizeof(if_mib) / sizeof(if_mib[0]));
d1042 4
a1045 2
	mps_mibtree(enterprise_mib,
	    sizeof(enterprise_mib) / sizeof(enterprise_mib[0]));
@

