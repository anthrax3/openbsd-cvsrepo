head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.6
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.10
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.6
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5;
locks; strict;
comment	@ * @;


1.20
date	2016.10.28.08.01.53;	author rzalamena;	state Exp;
branches;
next	1.19;
commitid	SMslalgbhOIf4OXA;

1.19
date	2015.12.05.06.42.18;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	7b4R1o84KuZAdiL5;

1.18
date	2015.08.21.08.29.06;	author reyk;	state Exp;
branches;
next	1.17;
commitid	QjpJ6vYVVuFdQU8t;

1.17
date	2015.01.16.00.05.13;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	khLbW7SmDyckNaAs;

1.16
date	2014.11.19.10.19.00;	author blambert;	state Exp;
branches;
next	1.15;
commitid	cXioMeUnRYhFJvcH;

1.15
date	2014.04.28.12.48.36;	author blambert;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.01.15.19.12;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.01.12.44.31;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2013.10.01.12.41.47;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2013.09.26.09.11.29;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.26.08.12.40;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.21.07.07.55;	author gerhard;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.17.16.43.59;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2012.02.01.18.44.06;	author camield;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.16.22.17.53;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.16.09.51.15;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.04.12.57.40;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.02.20.54.59;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.29.09.24.43;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.28.16.59.31;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Use snmpd_env as the only global variable for env to simplify the daemon
and avoid problems.

ok jca@@
@
text
@

/*
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/tree.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_arp.h>
#include <net/if_media.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <pwd.h>
#include <vis.h>

#include "snmpd.h"
#include "mib.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

RB_HEAD(oidtree, oid);
RB_PROTOTYPE(oidtree, oid, o_element, smi_oid_cmp);
struct oidtree smi_oidtree;

RB_HEAD(keytree, oid);
RB_PROTOTYPE(keytree, oid, o_keyword, smi_key_cmp);
struct keytree smi_keytree;

u_long
smi_getticks(void)
{
	struct timeval	 now, run;
	u_long		 ticks;

	gettimeofday(&now, NULL);
	if (timercmp(&now, &snmpd_env->sc_starttime, <=))
		return (0);
	timersub(&now, &snmpd_env->sc_starttime, &run);
	ticks = run.tv_sec * 100;
	if (run.tv_usec)
		ticks += run.tv_usec / 10000;

	return (ticks);
}

void
smi_oidlen(struct ber_oid *o)
{
	size_t	 i;

	for (i = 0; i < BER_MAX_OID_LEN && o->bo_id[i] != 0; i++)
		;
	o->bo_n = i;
}

void
smi_scalar_oidlen(struct ber_oid *o)
{
	smi_oidlen(o);

	/* Append .0. */
	if (o->bo_n < BER_MAX_OID_LEN)
		o->bo_n++;
}

char *
smi_oid2string(struct ber_oid *o, char *buf, size_t len, size_t skip)
{
	char		 str[256];
	struct oid	*value, key;
	size_t		 i, lookup = 1;

	bzero(buf, len);
	bzero(&key, sizeof(key));
	bcopy(o, &key.o_id, sizeof(struct ber_oid));
	key.o_flags |= OID_KEY;		/* do not match wildcards */

	if (snmpd_env->sc_flags & SNMPD_F_NONAMES)
		lookup = 0;

	for (i = 0; i < o->bo_n; i++) {
		key.o_oidlen = i + 1;
		if (lookup && skip > i)
			continue;
		if (lookup &&
		    (value = RB_FIND(oidtree, &smi_oidtree, &key)) != NULL)
			snprintf(str, sizeof(str), "%s", value->o_name);
		else
			snprintf(str, sizeof(str), "%d", key.o_oid[i]);
		strlcat(buf, str, len);
		if (i < (o->bo_n - 1))
			strlcat(buf, ".", len);
	}

	return (buf);
}

int
smi_string2oid(const char *oidstr, struct ber_oid *o)
{
	char			*sp, *p, str[BUFSIZ];
	const char		*errstr;
	struct oid		*oid;
	struct ber_oid		 ko;

	if (strlcpy(str, oidstr, sizeof(str)) >= sizeof(str))
		return (-1);
	bzero(o, sizeof(*o));

	/*
	 * Parse OID strings in the common form n.n.n or n-n-n.
	 * Based on ber_string2oid with additional support for symbolic names.
	 */
	for (p = sp = str; p != NULL; sp = p) {
		if ((p = strpbrk(p, ".-")) != NULL)
			*p++ = '\0';
		if ((oid = smi_findkey(sp)) != NULL) {
			bcopy(&oid->o_id, &ko, sizeof(ko));
			if (o->bo_n && ber_oid_cmp(o, &ko) != 2)
				return (-1);
			bcopy(&ko, o, sizeof(*o));
			errstr = NULL;
		} else {
			o->bo_id[o->bo_n++] =
			    strtonum(sp, 0, UINT_MAX, &errstr);
		}
		if (errstr || o->bo_n > BER_MAX_OID_LEN)
			return (-1);
	}

	return (0);
}

void
smi_delete(struct oid *oid)
{
	struct oid	 key, *value;

	bzero(&key, sizeof(key));
	bcopy(&oid->o_id, &key.o_id, sizeof(struct ber_oid));
	if ((value = RB_FIND(oidtree, &smi_oidtree, &key)) != NULL &&
	    value == oid)
		RB_REMOVE(oidtree, &smi_oidtree, value);

	free(oid->o_data);
	if (oid->o_flags & OID_DYNAMIC) {
		free(oid->o_name);
		free(oid);
	}
}

int
smi_insert(struct oid *oid)
{
	struct oid		 key, *value;

	if ((oid->o_flags & OID_TABLE) && oid->o_get == NULL)
		fatalx("smi_insert: invalid MIB table");

	bzero(&key, sizeof(key));
	bcopy(&oid->o_id, &key.o_id, sizeof(struct ber_oid));
	value = RB_FIND(oidtree, &smi_oidtree, &key);
	if (value != NULL)
		return (-1);

	RB_INSERT(oidtree, &smi_oidtree, oid);
	return (0);
}

void
smi_mibtree(struct oid *oids)
{
	struct oid	*oid, *decl;
	size_t		 i;

	for (i = 0; oids[i].o_oid[0] != 0; i++) {
		oid = &oids[i];
		smi_oidlen(&oid->o_id);
		if (oid->o_name != NULL) {
			if ((oid->o_flags & OID_TABLE) && oid->o_get == NULL)
				fatalx("smi_mibtree: invalid MIB table");
			RB_INSERT(oidtree, &smi_oidtree, oid);
			RB_INSERT(keytree, &smi_keytree, oid);
			continue;
		}
		decl = RB_FIND(oidtree, &smi_oidtree, oid);
		if (decl == NULL)
			fatalx("smi_mibtree: undeclared MIB");
		decl->o_flags = oid->o_flags;
		decl->o_get = oid->o_get;
		decl->o_set = oid->o_set;
		decl->o_table = oid->o_table;
		decl->o_val = oid->o_val;
		decl->o_data = oid->o_data;
	}
}

int
smi_init(void)
{
	/* Initialize the Structure of Managed Information (SMI) */
	RB_INIT(&smi_oidtree);
	mib_init();
	return (0);
}

struct oid *
smi_find(struct oid *oid)
{
	return (RB_FIND(oidtree, &smi_oidtree, oid));
}

struct oid *
smi_findkey(char *name)
{
	struct oid	oid;
	if (name == NULL)
		return (NULL);
	oid.o_name = name;
	return (RB_FIND(keytree, &smi_keytree, &oid));
}

struct oid *
smi_next(struct oid *oid)
{
	return (RB_NEXT(oidtree, &smi_oidtree, oid));
}

struct oid *
smi_foreach(struct oid *oid, u_int flags)
{
	/*
	 * Traverse the tree of MIBs with the option to check
	 * for specific OID flags.
	 */
	if (oid == NULL) {
		oid = RB_MIN(oidtree, &smi_oidtree);
		if (oid == NULL)
			return (NULL);
		if (flags == 0 || (oid->o_flags & flags))
			return (oid);
	}
	for (;;) {
		oid = RB_NEXT(oidtree, &smi_oidtree, oid);
		if (oid == NULL)
			break;
		if (flags == 0 || (oid->o_flags & flags))
			return (oid);
	}

	return (oid);
}

#ifdef DEBUG
void
smi_debug_elements(struct ber_element *root)
{
	static int	 indent = 0;
	char		*value;
	int		 constructed;

	/* calculate lengths */
	ber_calc_len(root);

	switch (root->be_encoding) {
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
		constructed = root->be_encoding;
		break;
	default:
		constructed = 0;
		break;
	}

	fprintf(stderr, "%*slen %lu ", indent, "", root->be_len);
	switch (root->be_class) {
	case BER_CLASS_UNIVERSAL:
		fprintf(stderr, "class: universal(%u) type: ", root->be_class);
		switch (root->be_type) {
		case BER_TYPE_EOC:
			fprintf(stderr, "end-of-content");
			break;
		case BER_TYPE_BOOLEAN:
			fprintf(stderr, "boolean");
			break;
		case BER_TYPE_INTEGER:
			fprintf(stderr, "integer");
			break;
		case BER_TYPE_BITSTRING:
			fprintf(stderr, "bit-string");
			break;
		case BER_TYPE_OCTETSTRING:
			fprintf(stderr, "octet-string");
			break;
		case BER_TYPE_NULL:
			fprintf(stderr, "null");
			break;
		case BER_TYPE_OBJECT:
			fprintf(stderr, "object");
			break;
		case BER_TYPE_ENUMERATED:
			fprintf(stderr, "enumerated");
			break;
		case BER_TYPE_SEQUENCE:
			fprintf(stderr, "sequence");
			break;
		case BER_TYPE_SET:
			fprintf(stderr, "set");
			break;
		}
		break;
	case BER_CLASS_APPLICATION:
		fprintf(stderr, "class: application(%u) type: ",
		    root->be_class);
		switch (root->be_type) {
		case SNMP_T_IPADDR:
			fprintf(stderr, "ipaddr");
			break;
		case SNMP_T_COUNTER32:
			fprintf(stderr, "counter32");
			break;
		case SNMP_T_GAUGE32:
			fprintf(stderr, "gauge32");
			break;
		case SNMP_T_TIMETICKS:
			fprintf(stderr, "timeticks");
			break;
		case SNMP_T_OPAQUE:
			fprintf(stderr, "opaque");
			break;
		case SNMP_T_COUNTER64:
			fprintf(stderr, "counter64");
			break;
		}
		break;
	case BER_CLASS_CONTEXT:
		fprintf(stderr, "class: context(%u) type: ",
		    root->be_class);
		switch (root->be_type) {
		case SNMP_C_GETREQ:
			fprintf(stderr, "getreq");
			break;
		case SNMP_C_GETNEXTREQ:
			fprintf(stderr, "nextreq");
			break;
		case SNMP_C_GETRESP:
			fprintf(stderr, "getresp");
			break;
		case SNMP_C_SETREQ:
			fprintf(stderr, "setreq");
			break;
		case SNMP_C_TRAP:
			fprintf(stderr, "trap");
			break;
		case SNMP_C_GETBULKREQ:
			fprintf(stderr, "getbulkreq");
			break;
		case SNMP_C_INFORMREQ:
			fprintf(stderr, "informreq");
			break;
		case SNMP_C_TRAPV2:
			fprintf(stderr, "trapv2");
			break;
		case SNMP_C_REPORT:
			fprintf(stderr, "report");
			break;
		}
		break;
	case BER_CLASS_PRIVATE:
		fprintf(stderr, "class: private(%u) type: ", root->be_class);
		break;
	default:
		fprintf(stderr, "class: <INVALID>(%u) type: ", root->be_class);
		break;
	}
	fprintf(stderr, "(%lu) encoding %lu ",
	    root->be_type, root->be_encoding);

	if ((value = smi_print_element(root)) == NULL)
		goto invalid;

	switch (root->be_encoding) {
	case BER_TYPE_BOOLEAN:
		fprintf(stderr, "%s", value);
		break;
	case BER_TYPE_INTEGER:
	case BER_TYPE_ENUMERATED:
		fprintf(stderr, "value %s", value);
		break;
	case BER_TYPE_BITSTRING:
		fprintf(stderr, "hexdump %s", value);
		break;
	case BER_TYPE_OBJECT:
		fprintf(stderr, "oid %s", value);
		break;
	case BER_TYPE_OCTETSTRING:
		if (root->be_class == BER_CLASS_APPLICATION &&
		    root->be_type == SNMP_T_IPADDR) {
			fprintf(stderr, "addr %s", value);
		} else {
			fprintf(stderr, "string %s", value);
		}
		break;
	case BER_TYPE_NULL:	/* no payload */
	case BER_TYPE_EOC:
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
	default:
		fprintf(stderr, "%s", value);
		break;
	}

 invalid:
	if (value == NULL)
		fprintf(stderr, "<INVALID>");
	else
		free(value);
	fprintf(stderr, "\n");

	if (constructed)
		root->be_encoding = constructed;

	if (constructed && root->be_sub) {
		indent += 2;
		smi_debug_elements(root->be_sub);
		indent -= 2;
	}
	if (root->be_next)
		smi_debug_elements(root->be_next);
}
#endif

char *
smi_print_element(struct ber_element *root)
{
	char		*str = NULL, *buf, *p;
	size_t		 len, i;
	long long	 v;
	int		 d;
	struct ber_oid	 o;
	char		 strbuf[BUFSIZ];

	switch (root->be_encoding) {
	case BER_TYPE_BOOLEAN:
		if (ber_get_boolean(root, &d) == -1)
			goto fail;
		if (asprintf(&str, "%s(%d)", d ? "true" : "false", d) == -1)
			goto fail;
		break;
	case BER_TYPE_INTEGER:
	case BER_TYPE_ENUMERATED:
		if (ber_get_integer(root, &v) == -1)
			goto fail;
		if (asprintf(&str, "%lld", v) == -1)
			goto fail;
		break;
	case BER_TYPE_BITSTRING:
		if (ber_get_bitstring(root, (void *)&buf, &len) == -1)
			goto fail;
		if ((str = calloc(1, len * 2 + 1)) == NULL)
			goto fail;
		for (p = str, i = 0; i < len; i++) {
			snprintf(p, 3, "%02x", buf[i]);
			p += 2;
		}
		break;
	case BER_TYPE_OBJECT:
		if (ber_get_oid(root, &o) == -1)
			goto fail;
		if (asprintf(&str, "%s",
		    smi_oid2string(&o, strbuf, sizeof(strbuf), 0)) == -1)
			goto fail;
		break;
	case BER_TYPE_OCTETSTRING:
		if (ber_get_string(root, &buf) == -1)
			goto fail;
		if (root->be_class == BER_CLASS_APPLICATION &&
		    root->be_type == SNMP_T_IPADDR) {
			if (asprintf(&str, "%s",
			    inet_ntoa(*(struct in_addr *)buf)) == -1)
				goto fail;
		} else {
			if ((p = reallocarray(NULL, 4, root->be_len + 1)) == NULL)
				goto fail;
			strvisx(p, buf, root->be_len, VIS_NL);
			if (asprintf(&str, "\"%s\"", p) == -1) {
				free(p);
				goto fail;
			}
			free(p);
		}
		break;
	case BER_TYPE_NULL:	/* no payload */
	case BER_TYPE_EOC:
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
	default:
		str = strdup("");
		break;
	}

	return (str);

 fail:
	free(str);
	return (NULL);
}

unsigned long
smi_application(struct ber_element *elm)
{
	if (elm->be_class != BER_CLASS_APPLICATION)
		return (BER_TYPE_OCTETSTRING);

	switch (elm->be_type) {
	case SNMP_T_IPADDR:
		return (BER_TYPE_OCTETSTRING);
	case SNMP_T_COUNTER32:
	case SNMP_T_GAUGE32:
	case SNMP_T_TIMETICKS:
	case SNMP_T_OPAQUE:
	case SNMP_T_COUNTER64:
		return (BER_TYPE_INTEGER);
	default:
		break;
	}
	return (BER_TYPE_OCTETSTRING);
}

int
smi_oid_cmp(struct oid *a, struct oid *b)
{
	size_t	 i;

	for (i = 0; i < MINIMUM(a->o_oidlen, b->o_oidlen); i++)
		if (a->o_oid[i] != b->o_oid[i])
			return (a->o_oid[i] - b->o_oid[i]);

	/*
	 * Return success if the matched object is a table
	 * or a MIB registered by a subagent
	 * (it will match any sub-elements)
	 */
	if ((b->o_flags & OID_TABLE ||
	    b->o_flags & OID_REGISTERED) &&
	    (a->o_flags & OID_KEY) == 0 &&
	    (a->o_oidlen > b->o_oidlen))
		return (0);

	return (a->o_oidlen - b->o_oidlen);
}

RB_GENERATE(oidtree, oid, o_element, smi_oid_cmp);

int
smi_key_cmp(struct oid *a, struct oid *b)
{
	if (a->o_name == NULL || b->o_name == NULL)
		return (-1);
	return (strcasecmp(a->o_name, b->o_name));
}

RB_GENERATE(keytree, oid, o_keyword, smi_key_cmp);
@


1.19
log
@strings.h -> string.h to prevent an implicit declaration warning. Also
remove a handful of NULL-checks before free().
@
text
@a51 2
extern struct snmpd *env;

d67 1
a67 1
	if (timercmp(&now, &env->sc_starttime, <=))
d69 1
a69 1
	timersub(&now, &env->sc_starttime, &run);
d109 1
a109 1
	if (env->sc_flags & SNMPD_F_NONAMES)
@


1.18
log
@Use reallocarray() instead of malloc() before strvisx().

Found by deraadt@@
OK blambert@@
@
text
@d178 1
a178 2
	if (oid->o_data != NULL)
		free(oid->o_data);
d538 1
a538 2
	if (str != NULL)
		free(str);
@


1.17
log
@first batch of cleanup to programs based upon the namespace cleanups
in net/pfvar.h sys/proc.h sys/ucred.h arpa/nameser.h
change to PATH_MAX, reduce use of MIN() and MAX(), HOST_NAME_MAX+1,
LOGIN_NAME_MAX, etc etc
ok millert guenther, some review by doug
@
text
@d517 1
a517 1
			if ((p = malloc(root->be_len * 4 + 1)) == NULL)
@


1.16
log
@add support for AgentX subagents in snmpd

snmp requests are now packaged into pseudo-continuations
to allow for being dispatched to seperate processes;
lightly tested for interoperability with NetSNMP, but
doesn't implement the complete set of AgentX messages

while here, clean up return types of mps_get* functions,
and make smi_insert refuse to insert duplicate OIDs

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.15 2014/04/28 12:48:36 blambert Exp $	*/
a19 1
#include <sys/param.h>
d43 1
d50 2
d570 1
a570 1
	for (i = 0; i < MIN(a->o_oidlen, b->o_oidlen); i++)
@


1.15
log
@fix memory leak

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.14 2013/10/01 15:19:12 reyk Exp $	*/
d184 1
a184 1
void
d196 1
a196 1
		smi_delete(value);
d199 1
d574 1
d577 2
a578 1
	if ((b->o_flags & OID_TABLE) &&
@


1.14
log
@Tell strvisx() to encode newlines found in octet-strings to avoid ugly
line wraps.
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.13 2013/10/01 12:44:31 reyk Exp $	*/
d521 1
@


1.13
log
@fix typo
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.12 2013/10/01 12:41:47 reyk Exp $	*/
d516 1
a516 1
			strvisx(p, buf, root->be_len, 0);
@


1.12
log
@Add initial SNMP client utility to snmpctl(8).
For example, snmpctl snmp walk 127.0.0.1

commit it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.11 2013/09/26 09:11:29 reyk Exp $	*/
d143 1
a143 1
	 * Based on ber_string2oid with additional support for symbolid names.
@


1.11
log
@shuffle some snmpd functions to make them visible in smi.c for snmpctl.

ok gerhard@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.10 2013/09/26 08:12:40 reyk Exp $	*/
d56 4
d98 1
a98 1
smi_oidstring(struct ber_oid *o, char *buf, size_t len)
d114 2
d129 36
d214 1
d245 10
d502 1
a502 1
		    smi_oidstring(&o, strbuf, sizeof(strbuf))) == -1)
d583 10
@


1.10
log
@smi is an SNMP term that means "Structure of Managed Information".  I
thought about renaming the functions to just "snmp", but "smi" totally
makes sense.  So add a comment that explains the meaning of SMI (not life).
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.9 2013/06/21 07:07:55 gerhard Exp $	*/
d45 1
d230 276
@


1.9
log
@Bzero() the whole key before doing an RB_FIND() because smi_oid_cmp()
looks at more members than just 'o_id'.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.8 2012/09/17 16:43:59 reyk Exp $	*/
d188 1
@


1.8
log
@Update copyright and my email address in snmpd while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.7 2012/02/01 18:44:06 camield Exp $	*/
d127 1
d149 1
@


1.7
log
@Variable bindings need instance identifiers, for scalars this is always .0.
At least NetSNMP and HPOV now understand it.

ok joel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.6 2009/12/16 22:17:53 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@vantronix.net>
@


1.6
log
@knf and unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.5 2008/01/16 09:51:15 reyk Exp $	*/
d80 10
@


1.5
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.4 2008/01/04 12:57:40 reyk Exp $	*/
d76 3
a78 1
	for (i = 0; i < BER_MAX_OID_LEN && o->bo_id[i] != 0; i++);
@


1.4
log
@always bzero the oid lookup key before initializing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.3 2008/01/02 20:54:59 maja Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 Reyk Floeter <reyk@@vantronix.net>
@


1.3
log
@Make sure that a key belongs to the table before returning a match.
Change smi_odi_cmp to return int as expected by RB-tree. -moj

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.2 2007/12/29 09:24:43 reyk Exp $	*/
d88 1
@


1.2
log
@add the IP-MIB ipAddrTable.  it requires to encode the ipv4 addresses
in the OIDs as the table index.  the next step is to simplify the
common mib implementation regarding the special requirements of these
strange snmp tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: smi.c,v 1.1 2007/12/28 16:59:31 reyk Exp $	*/
d215 1
a215 1
long
d229 2
a230 1
	    (a->o_flags & OID_KEY) == 0)
@


1.1
log
@split code handling the "structure of management information" and the
"message processing subsystem" into separate files smi.c and mps.c
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 1
a89 1
	key.o_flags |= OID_TABLE;	/* do not match wildcards */
d164 1
d229 1
a229 1
	    (a->o_flags & OID_TABLE) == 0)
@

