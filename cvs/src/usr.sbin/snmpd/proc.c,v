head	1.24;
access;
symbols
	OPENBSD_6_1:1.23.0.4
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.24
date	2017.05.29.12.56.26;	author benno;	state Exp;
branches;
next	1.23;
commitid	A04MHpCnJol41Xoy;

1.23
date	2017.01.17.22.10.56;	author krw;	state Exp;
branches;
next	1.22;
commitid	nf3UdaW8au6U0a03;

1.22
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.21;
commitid	eA8b246voAapPTkX;

1.21
date	2016.10.28.09.07.08;	author rzalamena;	state Exp;
branches;
next	1.20;
commitid	Uh6U1yLTyYRsvccR;

1.20
date	2015.12.07.16.05.56;	author reyk;	state Exp;
branches;
next	1.19;
commitid	N57bKZPTW9wbXnJY;

1.19
date	2015.12.07.12.33.08;	author reyk;	state Exp;
branches;
next	1.18;
commitid	CRYSGrkpOiXC6mfK;

1.18
date	2015.12.05.13.14.40;	author claudio;	state Exp;
branches;
next	1.17;
commitid	UnsvajcZPqalYyIp;

1.17
date	2015.11.23.19.31.52;	author reyk;	state Exp;
branches;
next	1.16;
commitid	7cxebI3ghebF4Szu;

1.16
date	2015.11.23.16.43.55;	author reyk;	state Exp;
branches;
next	1.15;
commitid	ucvdni0MmvboclfR;

1.15
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.14;
commitid	T3JBYxNT0thPuavp;

1.14
date	2015.10.14.14.51.57;	author reyk;	state Exp;
branches;
next	1.13;
commitid	ULW6QrMMAQqaTBTu;

1.13
date	2014.12.16.03.35.49;	author millert;	state Exp;
branches;
next	1.12;
commitid	nQ60kcXwyMctmczv;

1.12
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.11;
commitid	2uw1UTO4k6erpWzK;

1.11
date	2014.08.18.13.13.42;	author reyk;	state Exp;
branches;
next	1.10;
commitid	SoP35sFKzkBxNqzm;

1.10
date	2014.07.12.14.15.04;	author reyk;	state Exp;
branches;
next	1.9;
commitid	9Lw1doh9INJVoqMv;

1.9
date	2014.05.08.13.04.28;	author blambert;	state Exp;
branches;
next	1.8;

1.8
date	2014.05.06.06.40.03;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2014.05.04.10.34.35;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.21.19.47.27;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.18.21.29.20;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.14.07.18.05;	author blambert;	state Exp;
branches;
next	1.3;

1.3
date	2014.02.14.10.38.09;	author florian;	state Exp;
branches;
next	1.2;

1.2
date	2013.11.13.20.45.19;	author benno;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.17.08.42.44;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.24
log
@sync proc.c changes from relayd/httpd
@
text
@/*	$OpenBSD: proc.c,v 1.23 2017/01/17 22:10:56 krw Exp $	*/

/*
 * Copyright (c) 2010 - 2016 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <pwd.h>
#include <event.h>
#include <imsg.h>

#include "snmpd.h"

void	 proc_exec(struct privsep *, struct privsep_proc *, unsigned int,
	    int, char **);
void	 proc_setup(struct privsep *, struct privsep_proc *, unsigned int);
void	 proc_open(struct privsep *, int, int);
void	 proc_accept(struct privsep *, int, enum privsep_procid,
	    unsigned int);
void	 proc_close(struct privsep *);
int	 proc_ispeer(struct privsep_proc *, unsigned int, enum privsep_procid);
void	 proc_shutdown(struct privsep_proc *);
void	 proc_sig_handler(int, short, void *);
void	 proc_range(struct privsep *, enum privsep_procid, int *, int *);
int	 proc_dispatch_null(int, struct privsep_proc *, struct imsg *);

int
proc_ispeer(struct privsep_proc *procs, unsigned int nproc,
    enum privsep_procid type)
{
	unsigned int	i;

	for (i = 0; i < nproc; i++)
		if (procs[i].p_id == type)
			return (1);
	return (0);
}

enum privsep_procid
proc_getid(struct privsep_proc *procs, unsigned int nproc,
    const char *proc_name)
{
	struct privsep_proc	*p;
	unsigned int		 proc;

	for (proc = 0; proc < nproc; proc++) {
		p = &procs[proc];
		if (strcmp(p->p_title, proc_name))
			continue;

		return (p->p_id);
	}

	return (PROC_MAX);
}

void
proc_exec(struct privsep *ps, struct privsep_proc *procs, unsigned int nproc,
    int argc, char **argv)
{
	unsigned int		 proc, nargc, i, proc_i;
	char			**nargv;
	struct privsep_proc	*p;
	char			 num[32];
	int			 fd;

	/* Prepare the new process argv. */
	nargv = calloc(argc + 5, sizeof(char *));
	if (nargv == NULL)
		fatal("%s: calloc", __func__);

	/* Copy call argument first. */
	nargc = 0;
	nargv[nargc++] = argv[0];

	/* Set process name argument and save the position. */
	nargv[nargc++] = "-P";
	proc_i = nargc;
	nargc++;

	/* Point process instance arg to stack and copy the original args. */
	nargv[nargc++] = "-I";
	nargv[nargc++] = num;
	for (i = 1; i < (unsigned int) argc; i++)
		nargv[nargc++] = argv[i];

	nargv[nargc] = NULL;

	for (proc = 0; proc < nproc; proc++) {
		p = &procs[proc];

		/* Update args with process title. */
		nargv[proc_i] = (char *)(uintptr_t)p->p_title;

		/* Fire children processes. */
		for (i = 0; i < ps->ps_instances[p->p_id]; i++) {
			/* Update the process instance number. */
			snprintf(num, sizeof(num), "%u", i);

			fd = ps->ps_pipes[p->p_id][i].pp_pipes[PROC_PARENT][0];
			ps->ps_pipes[p->p_id][i].pp_pipes[PROC_PARENT][0] = -1;

			switch (fork()) {
			case -1:
				fatal("%s: fork", __func__);
				break;
			case 0:
				/* First create a new session */
				if (setsid() == -1)
					fatal("setsid");

				/* Prepare parent socket. */
				if (fd != PROC_PARENT_SOCK_FILENO) {
					if (dup2(fd, PROC_PARENT_SOCK_FILENO)
					    == -1)
						fatal("dup2");
				} else if (fcntl(fd, F_SETFD, 0) == -1)
					fatal("fcntl");

				execvp(argv[0], nargv);
				fatal("%s: execvp", __func__);
				break;
			default:
				/* Close child end. */
				close(fd);
				break;
			}
		}
	}
	free(nargv);
}

void
proc_connect(struct privsep *ps)
{
	struct imsgev		*iev;
	unsigned int		 src, dst, inst;

	/* Don't distribute any sockets if we are not really going to run. */
	if (ps->ps_noaction)
		return;

	for (dst = 0; dst < PROC_MAX; dst++) {
		/* We don't communicate with ourselves. */
		if (dst == PROC_PARENT)
			continue;

		for (inst = 0; inst < ps->ps_instances[dst]; inst++) {
			iev = &ps->ps_ievs[dst][inst];
			imsg_init(&iev->ibuf, ps->ps_pp->pp_pipes[dst][inst]);
			event_set(&iev->ev, iev->ibuf.fd, iev->events,
			    iev->handler, iev->data);
			event_add(&iev->ev, NULL);
		}
	}

	/* Distribute the socketpair()s for everyone. */
	for (src = 0; src < PROC_MAX; src++)
		for (dst = src; dst < PROC_MAX; dst++) {
			/* Parent already distributed its fds. */
			if (src == PROC_PARENT || dst == PROC_PARENT)
				continue;

			proc_open(ps, src, dst);
		}
}

void
proc_init(struct privsep *ps, struct privsep_proc *procs, unsigned int nproc,
    int argc, char **argv, enum privsep_procid proc_id)
{
	struct privsep_proc	*p = NULL;
	struct privsep_pipes	*pa, *pb;
	unsigned int		 proc;
	unsigned int		 dst;
	int			 fds[2];

	/* Don't initiate anything if we are not really going to run. */
	if (ps->ps_noaction)
		return;

	if (proc_id == PROC_PARENT) {
		privsep_process = PROC_PARENT;
		proc_setup(ps, procs, nproc);

		/*
		 * Create the children sockets so we can use them
		 * to distribute the rest of the socketpair()s using
		 * proc_connect() later.
		 */
		for (dst = 0; dst < PROC_MAX; dst++) {
			/* Don't create socket for ourselves. */
			if (dst == PROC_PARENT)
				continue;

			for (proc = 0; proc < ps->ps_instances[dst]; proc++) {
				pa = &ps->ps_pipes[PROC_PARENT][0];
				pb = &ps->ps_pipes[dst][proc];
				if (socketpair(AF_UNIX,
				    SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
				    PF_UNSPEC, fds) == -1)
					fatal("%s: socketpair", __func__);

				pa->pp_pipes[dst][proc] = fds[0];
				pb->pp_pipes[PROC_PARENT][0] = fds[1];
			}
		}

		/* Engage! */
		proc_exec(ps, procs, nproc, argc, argv);
		return;
	}

	/* Initialize a child */
	for (proc = 0; proc < nproc; proc++) {
		if (procs[proc].p_id != proc_id)
			continue;
		p = &procs[proc];
		break;
	}
	if (p == NULL || p->p_init == NULL)
		fatalx("%s: process %d missing process initialization",
		    __func__, proc_id);

	p->p_init(ps, p);

	fatalx("failed to initiate child process");
}

void
proc_accept(struct privsep *ps, int fd, enum privsep_procid dst,
    unsigned int n)
{
	struct privsep_pipes	*pp = ps->ps_pp;
	struct imsgev		*iev;

	if (ps->ps_ievs[dst] == NULL) {
#if DEBUG > 1
		log_debug("%s: %s src %d %d to dst %d %d not connected",
		    __func__, ps->ps_title[privsep_process],
		    privsep_process, ps->ps_instance + 1,
		    dst, n + 1);
#endif
		close(fd);
		return;
	}

	if (pp->pp_pipes[dst][n] != -1) {
		log_warnx("%s: duplicated descriptor", __func__);
		close(fd);
		return;
	} else
		pp->pp_pipes[dst][n] = fd;

	iev = &ps->ps_ievs[dst][n];
	imsg_init(&iev->ibuf, fd);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev->data);
	event_add(&iev->ev, NULL);
}

void
proc_setup(struct privsep *ps, struct privsep_proc *procs, unsigned int nproc)
{
	unsigned int		 i, j, src, dst, id;
	struct privsep_pipes	*pp;

	/* Initialize parent title, ps_instances and procs. */
	ps->ps_title[PROC_PARENT] = "parent";

	for (src = 0; src < PROC_MAX; src++)
		/* Default to 1 process instance */
		if (ps->ps_instances[src] < 1)
			ps->ps_instances[src] = 1;

	for (src = 0; src < nproc; src++) {
		procs[src].p_ps = ps;
		if (procs[src].p_cb == NULL)
			procs[src].p_cb = proc_dispatch_null;

		id = procs[src].p_id;
		ps->ps_title[id] = procs[src].p_title;
		if ((ps->ps_ievs[id] = calloc(ps->ps_instances[id],
		    sizeof(struct imsgev))) == NULL)
			fatal("%s: calloc", __func__);

		/* With this set up, we are ready to call imsg_init(). */
		for (i = 0; i < ps->ps_instances[id]; i++) {
			ps->ps_ievs[id][i].handler = proc_dispatch;
			ps->ps_ievs[id][i].events = EV_READ;
			ps->ps_ievs[id][i].proc = &procs[src];
			ps->ps_ievs[id][i].data = &ps->ps_ievs[id][i];
		}
	}

	/*
	 * Allocate pipes for all process instances (incl. parent)
	 *
	 * - ps->ps_pipes: N:M mapping
	 * N source processes connected to M destination processes:
	 * [src][instances][dst][instances], for example
	 * [PROC_RELAY][3][PROC_CA][3]
	 *
	 * - ps->ps_pp: per-process 1:M part of ps->ps_pipes
	 * Each process instance has a destination array of socketpair fds:
	 * [dst][instances], for example
	 * [PROC_PARENT][0]
	 */
	for (src = 0; src < PROC_MAX; src++) {
		/* Allocate destination array for each process */
		if ((ps->ps_pipes[src] = calloc(ps->ps_instances[src],
		    sizeof(struct privsep_pipes))) == NULL)
			fatal("%s: calloc", __func__);

		for (i = 0; i < ps->ps_instances[src]; i++) {
			pp = &ps->ps_pipes[src][i];

			for (dst = 0; dst < PROC_MAX; dst++) {
				/* Allocate maximum fd integers */
				if ((pp->pp_pipes[dst] =
				    calloc(ps->ps_instances[dst],
				    sizeof(int))) == NULL)
					fatal("%s: calloc", __func__);

				/* Mark fd as unused */
				for (j = 0; j < ps->ps_instances[dst]; j++)
					pp->pp_pipes[dst][j] = -1;
			}
		}
	}

	ps->ps_pp = &ps->ps_pipes[privsep_process][ps->ps_instance];
}

void
proc_kill(struct privsep *ps)
{
	char		*cause;
	pid_t		 pid;
	int		 len, status;

	if (privsep_process != PROC_PARENT)
		return;

	proc_close(ps);

	do {
		pid = waitpid(WAIT_ANY, &status, 0);
		if (pid <= 0)
			continue;

		if (WIFSIGNALED(status)) {
			len = asprintf(&cause, "terminated; signal %d",
			    WTERMSIG(status));
		} else if (WIFEXITED(status)) {
			if (WEXITSTATUS(status) != 0)
				len = asprintf(&cause, "exited abnormally");
			else
				len = 0;
		} else
			len = -1;

		if (len == 0) {
			/* child exited OK, don't print a warning message */
		} else if (len != -1) {
			log_warnx("lost child: pid %u %s", pid, cause);
			free(cause);
		} else
			log_warnx("lost child: pid %u", pid);
	} while (pid != -1 || (pid == -1 && errno == EINTR));
}

void
proc_open(struct privsep *ps, int src, int dst)
{
	struct privsep_pipes	*pa, *pb;
	struct privsep_fd	 pf;
	int			 fds[2];
	unsigned int		 i, j;

	/* Exchange pipes between process. */
	for (i = 0; i < ps->ps_instances[src]; i++) {
		for (j = 0; j < ps->ps_instances[dst]; j++) {
			/* Don't create sockets for ourself. */
			if (src == dst && i == j)
				continue;

			pa = &ps->ps_pipes[src][i];
			pb = &ps->ps_pipes[dst][j];
			if (socketpair(AF_UNIX,
			    SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
			    PF_UNSPEC, fds) == -1)
				fatal("%s: socketpair", __func__);

			pa->pp_pipes[dst][j] = fds[0];
			pb->pp_pipes[src][i] = fds[1];

			pf.pf_procid = src;
			pf.pf_instance = i;
			if (proc_compose_imsg(ps, dst, j, IMSG_CTL_PROCFD,
			    -1, pb->pp_pipes[src][i], &pf, sizeof(pf)) == -1)
				fatal("%s: proc_compose_imsg", __func__);

			pf.pf_procid = dst;
			pf.pf_instance = j;
			if (proc_compose_imsg(ps, src, i, IMSG_CTL_PROCFD,
			    -1, pa->pp_pipes[dst][j], &pf, sizeof(pf)) == -1)
				fatal("%s: proc_compose_imsg", __func__);

			/*
			 * We have to flush to send the descriptors and close
			 * them to avoid the fd ramp on startup.
			 */
			if (proc_flush_imsg(ps, src, i) == -1 ||
			    proc_flush_imsg(ps, dst, j) == -1)
				fatal("%s: imsg_flush", __func__);
		}
	}
}

void
proc_close(struct privsep *ps)
{
	unsigned int		 dst, n;
	struct privsep_pipes	*pp;

	if (ps == NULL)
		return;

	pp = ps->ps_pp;

	for (dst = 0; dst < PROC_MAX; dst++) {
		if (ps->ps_ievs[dst] == NULL)
			continue;

		for (n = 0; n < ps->ps_instances[dst]; n++) {
			if (pp->pp_pipes[dst][n] == -1)
				continue;

			/* Cancel the fd, close and invalidate the fd */
			event_del(&(ps->ps_ievs[dst][n].ev));
			imsg_clear(&(ps->ps_ievs[dst][n].ibuf));
			close(pp->pp_pipes[dst][n]);
			pp->pp_pipes[dst][n] = -1;
		}
		free(ps->ps_ievs[dst]);
	}
}

void
proc_shutdown(struct privsep_proc *p)
{
	struct privsep	*ps = p->p_ps;

	if (p->p_id == PROC_CONTROL && ps)
		control_cleanup(&ps->ps_csock);

	if (p->p_shutdown != NULL)
		(*p->p_shutdown)();

	proc_close(ps);

	log_info("%s exiting, pid %d", p->p_title, getpid());

	exit(0);
}

void
proc_sig_handler(int sig, short event, void *arg)
{
	struct privsep_proc	*p = arg;

	switch (sig) {
	case SIGINT:
	case SIGTERM:
		proc_shutdown(p);
		break;
	case SIGCHLD:
	case SIGHUP:
	case SIGPIPE:
	case SIGUSR1:
		/* ignore */
		break;
	default:
		fatalx("%s: unexpected signal", __func__);
		/* NOTREACHED */
	}
}

void
proc_run(struct privsep *ps, struct privsep_proc *p,
    struct privsep_proc *procs, unsigned int nproc,
    void (*run)(struct privsep *, struct privsep_proc *, void *), void *arg)
{
	struct passwd		*pw;
	const char		*root;
	struct control_sock	*rcs;

	log_procinit(p->p_title);

	/* Set the process group of the current process */
	setpgid(0, 0);

	if (p->p_id == PROC_CONTROL && ps->ps_instance == 0) {
		if (control_init(ps, &ps->ps_csock) == -1)
			fatalx("%s: control_init", __func__);
		TAILQ_FOREACH(rcs, &ps->ps_rcsocks, cs_entry)
			if (control_init(ps, rcs) == -1)
				fatalx("%s: control_init", __func__);
	}

	/* Use non-standard user */
	if (p->p_pw != NULL)
		pw = p->p_pw;
	else
		pw = ps->ps_pw;

	/* Change root directory */
	if (p->p_chroot != NULL)
		root = p->p_chroot;
	else
		root = pw->pw_dir;

	if (chroot(root) == -1)
		fatal("%s: chroot", __func__);
	if (chdir("/") == -1)
		fatal("%s: chdir(\"/\")", __func__);

	privsep_process = p->p_id;

	setproctitle("%s", p->p_title);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("%s: cannot drop privileges", __func__);

	event_init();

	signal_set(&ps->ps_evsigint, SIGINT, proc_sig_handler, p);
	signal_set(&ps->ps_evsigterm, SIGTERM, proc_sig_handler, p);
	signal_set(&ps->ps_evsigchld, SIGCHLD, proc_sig_handler, p);
	signal_set(&ps->ps_evsighup, SIGHUP, proc_sig_handler, p);
	signal_set(&ps->ps_evsigpipe, SIGPIPE, proc_sig_handler, p);
	signal_set(&ps->ps_evsigusr1, SIGUSR1, proc_sig_handler, p);

	signal_add(&ps->ps_evsigint, NULL);
	signal_add(&ps->ps_evsigterm, NULL);
	signal_add(&ps->ps_evsigchld, NULL);
	signal_add(&ps->ps_evsighup, NULL);
	signal_add(&ps->ps_evsigpipe, NULL);
	signal_add(&ps->ps_evsigusr1, NULL);

	proc_setup(ps, procs, nproc);
	proc_accept(ps, PROC_PARENT_SOCK_FILENO, PROC_PARENT, 0);
	if (p->p_id == PROC_CONTROL && ps->ps_instance == 0) {
		TAILQ_INIT(&ctl_conns);
		if (control_listen(&ps->ps_csock) == -1)
			fatalx("%s: control_listen", __func__);
		TAILQ_FOREACH(rcs, &ps->ps_rcsocks, cs_entry)
			if (control_listen(rcs) == -1)
				fatalx("%s: control_listen", __func__);
	}

	DPRINTF("%s: %s %d/%d, pid %d", __func__, p->p_title,
	    ps->ps_instance + 1, ps->ps_instances[p->p_id], getpid());

	if (run != NULL)
		run(ps, p, arg);

	event_dispatch();

	proc_shutdown(p);
}

void
proc_dispatch(int fd, short event, void *arg)
{
	struct imsgev		*iev = arg;
	struct privsep_proc	*p = iev->proc;
	struct privsep		*ps = p->p_ps;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
	int			 verbose;
	const char		*title;
	struct privsep_fd	 pf;

	title = ps->ps_title[privsep_process];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("%s: imsg_read", __func__);
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("%s: msgbuf_write", __func__);
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("%s: imsg_get", __func__);
		if (n == 0)
			break;

#if DEBUG > 1
		log_debug("%s: %s %d got imsg %d peerid %d from %s %d",
		    __func__, title, ps->ps_instance + 1,
		    imsg.hdr.type, imsg.hdr.peerid, p->p_title, imsg.hdr.pid);
#endif

		/*
		 * Check the message with the program callback
		 */
		if ((p->p_cb)(fd, p, &imsg) == 0) {
			/* Message was handled by the callback, continue */
			imsg_free(&imsg);
			continue;
		}

		/*
		 * Generic message handling
		 */
		switch (imsg.hdr.type) {
		case IMSG_CTL_VERBOSE:
			IMSG_SIZE_CHECK(&imsg, &verbose);
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		case IMSG_CTL_PROCFD:
			IMSG_SIZE_CHECK(&imsg, &pf);
			memcpy(&pf, imsg.data, sizeof(pf));
			proc_accept(ps, imsg.fd, pf.pf_procid,
			    pf.pf_instance);
			break;
		default:
			fatalx("%s: %s %d got invalid imsg %d peerid %d "
			    "from %s %d",
			    __func__, title, ps->ps_instance + 1,
			    imsg.hdr.type, imsg.hdr.peerid,
			    p->p_title, imsg.hdr.pid);
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

int
proc_dispatch_null(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	return (-1);
}

/*
 * imsg helper functions
 */

void
imsg_event_add(struct imsgev *iev)
{
	if (iev->handler == NULL) {
		imsg_flush(&iev->ibuf);
		return;
	}

	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev->data);
	event_add(&iev->ev, NULL);
}

int
imsg_compose_event(struct imsgev *iev, uint16_t type, uint32_t peerid,
    pid_t pid, int fd, void *data, uint16_t datalen)
{
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) == -1)
		return (ret);
	imsg_event_add(iev);
	return (ret);
}

int
imsg_composev_event(struct imsgev *iev, uint16_t type, uint32_t peerid,
    pid_t pid, int fd, const struct iovec *iov, int iovcnt)
{
	int	ret;

	if ((ret = imsg_composev(&iev->ibuf, type, peerid,
	    pid, fd, iov, iovcnt)) == -1)
		return (ret);
	imsg_event_add(iev);
	return (ret);
}

void
proc_range(struct privsep *ps, enum privsep_procid id, int *n, int *m)
{
	if (*n == -1) {
		/* Use a range of all target instances */
		*n = 0;
		*m = ps->ps_instances[id];
	} else {
		/* Use only a single slot of the specified peer process */
		*m = *n + 1;
	}
}

int
proc_compose_imsg(struct privsep *ps, enum privsep_procid id, int n,
    uint16_t type, uint32_t peerid, int fd, void *data, uint16_t datalen)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	for (; n < m; n++) {
		if (imsg_compose_event(&ps->ps_ievs[id][n],
		    type, peerid, ps->ps_instance + 1, fd, data, datalen) == -1)
			return (-1);
	}

	return (0);
}

int
proc_compose(struct privsep *ps, enum privsep_procid id,
    uint16_t type, void *data, uint16_t datalen)
{
	return (proc_compose_imsg(ps, id, -1, type, -1, -1, data, datalen));
}

int
proc_composev_imsg(struct privsep *ps, enum privsep_procid id, int n,
    uint16_t type, uint32_t peerid, int fd, const struct iovec *iov, int iovcnt)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	for (; n < m; n++)
		if (imsg_composev_event(&ps->ps_ievs[id][n],
		    type, peerid, ps->ps_instance + 1, fd, iov, iovcnt) == -1)
			return (-1);

	return (0);
}

int
proc_composev(struct privsep *ps, enum privsep_procid id,
    uint16_t type, const struct iovec *iov, int iovcnt)
{
	return (proc_composev_imsg(ps, id, -1, type, -1, -1, iov, iovcnt));
}

int
proc_forward_imsg(struct privsep *ps, struct imsg *imsg,
    enum privsep_procid id, int n)
{
	return (proc_compose_imsg(ps, id, n, imsg->hdr.type,
	    imsg->hdr.peerid, imsg->fd, imsg->data, IMSG_DATA_SIZE(imsg)));
}

struct imsgbuf *
proc_ibuf(struct privsep *ps, enum privsep_procid id, int n)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	return (&ps->ps_ievs[id][n].ibuf);
}

struct imsgev *
proc_iev(struct privsep *ps, enum privsep_procid id, int n)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	return (&ps->ps_ievs[id][n]);
}

/* This function should only be called with care as it breaks async I/O */
int
proc_flush_imsg(struct privsep *ps, enum privsep_procid id, int n)
{
	struct imsgbuf	*ibuf;
	int		 m, ret = 0;

	proc_range(ps, id, &n, &m);
	for (; n < m; n++) {
		if ((ibuf = proc_ibuf(ps, id, n)) == NULL)
			return (-1);
		do {
			ret = imsg_flush(ibuf);
		} while (ret == -1 && errno == EAGAIN);
		if (ret == -1)
			break;
		imsg_event_add(&ps->ps_ievs[id][n]);
	}

	return (ret);
}
@


1.23
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.22 2017/01/09 14:49:22 reyk Exp $	*/
d508 1
a508 1
		fatalx("proc_sig_handler: unexpected signal");
d548 1
a548 1
		fatal("proc_run: chroot");
d550 1
a550 1
		fatal("proc_run: chdir(\"/\")");
d559 1
a559 1
		fatal("proc_run: cannot drop privileges");
@


1.22
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.21 2016/10/28 09:07:08 rzalamena Exp $	*/
d211 1
a211 1
		 * Create the children sockets so we can use them 
@


1.21
log
@Sync snmpd(8) with other daemons proc.c and teach him how to fork+exec.

ok jca@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.20 2015/12/07 16:05:56 reyk Exp $	*/
d665 1
a665 1
			log_verbose(verbose);
@


1.20
log
@Add imsg "peerid" to debug messages (only within -DDEBUG).
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.4 2015/12/05 17:30:34 claudio Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 - 2014 Reyk Floeter <reyk@@openbsd.org>
d25 1
d38 6
a43 2
void	 proc_open(struct privsep *, struct privsep_proc *,
	    struct privsep_proc *, size_t);
d63 18
d82 2
a83 1
proc_init(struct privsep *ps, struct privsep_proc *procs, unsigned int nproc)
d85 25
a109 2
	unsigned int		 i, j, src, dst;
	struct privsep_pipes	*pp;
d111 1
a111 18
	/*
	 * Allocate pipes for all process instances (incl. parent)
	 *
	 * - ps->ps_pipes: N:M mapping
	 * N source processes connected to M destination processes:
	 * [src][instances][dst][instances], for example
	 * [PROC_RELAY][3][PROC_CA][3]
	 *
	 * - ps->ps_pp: per-process 1:M part of ps->ps_pipes
	 * Each process instance has a destination array of socketpair fds:
	 * [dst][instances], for example
	 * [PROC_PARENT][0]
	 */
	for (src = 0; src < PROC_MAX; src++) {
		/* Allocate destination array for each process */
		if ((ps->ps_pipes[src] = calloc(ps->ps_ninstances,
		    sizeof(struct privsep_pipes))) == NULL)
			fatal("proc_init: calloc");
d113 2
a114 2
		for (i = 0; i < ps->ps_ninstances; i++) {
			pp = &ps->ps_pipes[src][i];
d116 2
a117 6
			for (dst = 0; dst < PROC_MAX; dst++) {
				/* Allocate maximum fd integers */
				if ((pp->pp_pipes[dst] =
				    calloc(ps->ps_ninstances,
				    sizeof(int))) == NULL)
					fatal("proc_init: calloc");
d119 32
a150 3
				/* Mark fd as unused */
				for (j = 0; j < ps->ps_ninstances; j++)
					pp->pp_pipes[dst][j] = -1;
d154 1
a154 22

	/*
	 * Setup and run the parent and its children
	 */
	privsep_process = PROC_PARENT;
	ps->ps_instances[PROC_PARENT] = 1;
	ps->ps_title[PROC_PARENT] = "parent";
	ps->ps_pid[PROC_PARENT] = getpid();
	ps->ps_pp = &ps->ps_pipes[privsep_process][0];

	for (i = 0; i < nproc; i++) {
		/* Default to 1 process instance */
		if (ps->ps_instances[procs[i].p_id] < 1)
			ps->ps_instances[procs[i].p_id] = 1;
		ps->ps_title[procs[i].p_id] = procs[i].p_title;
	}

	proc_open(ps, NULL, procs, nproc);

	/* Engage! */
	for (i = 0; i < nproc; i++)
		ps->ps_pid[procs[i].p_id] = (*procs[i].p_init)(ps, &procs[i]);
d158 1
a158 1
proc_kill(struct privsep *ps)
d160 2
a161 2
	pid_t		 pid;
	unsigned int	 i;
d163 2
a164 1
	if (privsep_process != PROC_PARENT)
d167 3
a169 2
	for (i = 0; i < PROC_MAX; i++) {
		if (ps->ps_pid[i] == 0)
d171 8
a178 1
		killpg(ps->ps_pid[i], SIGTERM);
d181 6
a186 3
	do {
		pid = waitpid(WAIT_ANY, NULL, 0);
	} while (pid != -1 || (pid == -1 && errno == EINTR));
d188 2
a189 1
	proc_close(ps);
d193 2
a194 2
proc_open(struct privsep *ps, struct privsep_proc *p,
    struct privsep_proc *procs, size_t nproc)
d196 1
d198 2
a200 1
	unsigned int		 i, j, src, proc;
d202 3
a204 4
	if (p == NULL)
		src = privsep_process; /* parent */
	else
		src = p->p_id;
d206 3
a208 8
	/*
	 * Open socket pairs for our peers
	 */
	for (proc = 0; proc < nproc; proc++) {
		procs[proc].p_ps = ps;
		procs[proc].p_env = ps->ps_env;
		if (procs[proc].p_cb == NULL)
			procs[proc].p_cb = proc_dispatch_null;
d210 9
a218 9
		for (i = 0; i < ps->ps_instances[src]; i++) {
			for (j = 0; j < ps->ps_instances[procs[proc].p_id];
			    j++) {
				pa = &ps->ps_pipes[src][i];
				pb = &ps->ps_pipes[procs[proc].p_id][j];

				/* Check if fds are already set by peer */
				if (pa->pp_pipes[procs[proc].p_id][j] != -1)
					continue;
d220 3
d224 1
a224 1
				    SOCK_STREAM | SOCK_NONBLOCK,
d226 1
a226 1
					fatal("socketpair");
d228 2
a229 2
				pa->pp_pipes[procs[proc].p_id][j] = fds[0];
				pb->pp_pipes[src][i] = fds[1];
d232 12
d245 7
d255 2
a256 1
proc_listen(struct privsep *ps, struct privsep_proc *procs, size_t nproc)
d258 31
a288 1
	unsigned int		 i, dst, src, n, m;
d291 28
d320 11
a330 1
	 * Close unused pipes
d333 4
a336 5
		for (n = 0; n < ps->ps_instances[src]; n++) {
			/* Ingore current process */
			if (src == (unsigned int)privsep_process &&
			    n == ps->ps_instance)
				continue;
d338 2
a339 1
			pp = &ps->ps_pipes[src][n];
d342 9
a350 10
				if (src == dst)
					continue;
				for (m = 0; m < ps->ps_instances[dst]; m++) {
					if (pp->pp_pipes[dst][m] == -1)
						continue;

					/* Close and invalidate fd */
					close(pp->pp_pipes[dst][m]);
					pp->pp_pipes[dst][m] = -1;
				}
d355 9
a363 2
	src = privsep_process;
	ps->ps_pp = pp = &ps->ps_pipes[src][ps->ps_instance];
d365 9
a373 5
	/*
	 * Listen on appropriate pipes
	 */
	for (i = 0; i < nproc; i++) {
		dst = procs[i].p_id;
d375 20
a394 2
		if (src == dst)
			fatal("proc_listen: cannot peer with oneself");
d396 7
a402 3
		if ((ps->ps_ievs[dst] = calloc(ps->ps_instances[dst],
		    sizeof(struct imsgev))) == NULL)
			fatal("proc_open");
d404 5
a408 2
		for (n = 0; n < ps->ps_instances[dst]; n++) {
			if (pp->pp_pipes[dst][n] == -1)
d411 29
a439 14
			imsg_init(&(ps->ps_ievs[dst][n].ibuf),
			    pp->pp_pipes[dst][n]);
			ps->ps_ievs[dst][n].handler = proc_dispatch;
			ps->ps_ievs[dst][n].events = EV_READ;
			ps->ps_ievs[dst][n].proc = &procs[i];
			ps->ps_ievs[dst][n].data = &ps->ps_ievs[dst][n];
			procs[i].p_instance = n;

			event_set(&(ps->ps_ievs[dst][n].ev),
			    ps->ps_ievs[dst][n].ibuf.fd,
			    ps->ps_ievs[dst][n].events,
			    ps->ps_ievs[dst][n].handler,
			    ps->ps_ievs[dst][n].data);
			event_add(&(ps->ps_ievs[dst][n].ev), NULL);
d488 1
a488 1
	_exit(0);
d513 1
a513 1
pid_t
a517 1
	pid_t			 pid;
a520 1
	unsigned int		 n;
d522 1
a522 11
	if (ps->ps_noaction)
		return (0);

	proc_open(ps, p, procs, nproc);

	/* Fork child handlers */
	switch (pid = fork()) {
	case -1:
		fatal("proc_run: cannot fork");
	case 0:
		log_procinit(p->p_title);
d524 2
a525 8
		/* Set the process group of the current process */
		setpgid(0, 0);
		break;
	default:
		return (pid);
	}

	pw = ps->ps_pw;
d529 1
a529 1
			fatalx(__func__);
d532 1
a532 1
				fatalx(__func__);
d535 6
a560 13
	/* Fork child handlers */
	for (n = 1; n < ps->ps_instances[p->p_id]; n++) {
		if (fork() == 0) {
			ps->ps_instance = p->p_instance = n;
			break;
		}
	}

#ifdef DEBUG
	log_debug("%s: %s %d/%d, pid %d", __func__, p->p_title,
	    ps->ps_instance + 1, ps->ps_instances[p->p_id], getpid());
#endif

d577 2
a578 2
	proc_listen(ps, procs, nproc);

d582 1
a582 1
			fatalx(__func__);
d585 1
a585 1
				fatalx(__func__);
d588 3
a596 2

	return (0);
d610 1
d617 1
a617 1
			fatal(__func__);
d627 8
a634 2
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			fatal(__func__);
d639 1
a639 1
			fatal(__func__);
d646 1
a646 1
		    imsg.hdr.type, imsg.hdr.peerid, p->p_title, p->p_instance);
d667 6
d674 1
a674 1
			log_warnx("%s: %s %d got invalid imsg %d peerid %d "
d678 1
a678 2
			    p->p_title, p->p_instance);
			fatalx(__func__);
d760 1
a760 1
		    type, peerid, 0, fd, data, datalen) == -1)
d783 1
a783 1
		    type, peerid, 0, fd, iov, iovcnt) == -1)
d820 22
@


1.19
log
@Sync proc.c, use proc_composev()
@
text
@d477 1
a477 1
		log_debug("%s: %s %d got imsg %d from %s %d",
d479 1
a479 1
		    imsg.hdr.type, p->p_title, p->p_instance);
d501 2
a502 1
			log_warnx("%s: %s %d got invalid imsg %d from %s %d",
d504 2
a505 1
			    imsg.hdr.type, p->p_title, p->p_instance);
@


1.18
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.17 2015/11/23 19:31:52 reyk Exp $	*/
d579 1
a579 1
    uint16_t type, int fd, void *data, uint16_t datalen)
d586 1
a586 1
		    type, -1, 0, fd, data, datalen) == -1)
d594 7
d602 1
a602 1
    uint16_t type, int fd, const struct iovec *iov, int iovcnt)
d609 1
a609 1
		    type, -1, 0, fd, iov, iovcnt) == -1)
d616 7
d627 1
a627 1
	    imsg->fd, imsg->data, IMSG_DATA_SIZE(imsg)));
@


1.17
log
@Use SOCK_NONBLOCK to replace socket_set_blockmode() and fcntl(..O_NONBLOCK).
(SOCK_CLOEXEC should also be added where it is appropriate, but this is OBnot
done in this commit yet.)

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.16 2015/11/23 16:43:55 reyk Exp $	*/
d455 1
a455 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.16
log
@Sync proc.c with iked
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.23 2015/11/23 16:41:36 reyk Exp $	*/
d177 2
a178 1
				if (socketpair(AF_UNIX, SOCK_STREAM,
a180 3

				socket_set_blockmode(fds[0], BM_NONBLOCK);
				socket_set_blockmode(fds[1], BM_NONBLOCK);
@


1.15
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.21 2015/10/01 12:16:21 reyk Exp $	*/
d44 1
d164 2
d334 1
a334 1
    void (*init)(struct privsep *, struct privsep_proc *, void *), void *arg)
d431 2
a432 2
	if (init != NULL)
		init(ps, p, arg);
d511 6
@


1.14
log
@sync with httpd - no functional change, just C99 types
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.13 2014/12/16 03:35:49 millert Exp $	*/
a23 6
#include <sys/tree.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
d33 1
d349 2
d362 1
a362 1
			fatalx(p->p_title);
d365 1
a365 1
				fatalx(p->p_title);
d422 1
a422 1
			fatalx(p->p_title);
d425 1
a425 1
				fatalx(p->p_title);
d455 1
a455 1
			fatal(title);
d466 1
a466 1
			fatal(title);
d471 1
a471 1
			fatal(title);
d503 1
a503 1
			fatalx(title);
@


1.13
log
@Replace setpgrp(0, getpid()) with setpgid(0, 0).  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.12 2014/10/25 03:23:49 lteo Exp $	*/
d45 1
a45 1
int	 proc_ispeer(struct privsep_proc *, u_int, enum privsep_procid);
d51 2
a52 1
proc_ispeer(struct privsep_proc *procs, u_int nproc, enum privsep_procid type)
d54 1
a54 1
	u_int	i;
d63 1
a63 1
proc_init(struct privsep *ps, struct privsep_proc *procs, u_int nproc)
d65 1
a65 1
	u_int			 i, j, src, dst;
d131 1
a131 1
	u_int		 i;
d155 1
a155 1
	u_int			 i, j, src, proc;
d196 1
a196 1
	u_int			 i, dst, src, n, m;
d205 1
a205 1
			if (src == (u_int)privsep_process &&
d267 1
a267 1
	u_int			 dst, n;
d335 1
a335 1
    struct privsep_proc *procs, u_int nproc,
d342 1
a342 1
	u_int			 n;
d535 2
a536 2
imsg_compose_event(struct imsgev *iev, u_int16_t type, u_int32_t peerid,
    pid_t pid, int fd, void *data, u_int16_t datalen)
d548 1
a548 1
imsg_composev_event(struct imsgev *iev, u_int16_t type, u_int32_t peerid,
d575 1
a575 1
    u_int16_t type, int fd, void *data, u_int16_t datalen)
d591 1
a591 1
    u_int16_t type, int fd, const struct iovec *iov, int iovcnt)
@


1.12
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.11 2014/08/18 13:13:42 reyk Exp $	*/
d354 1
a354 1
		setpgrp(0, getpid());
@


1.11
log
@Sync proc.c with httpd.  httpd needs SIGUSR1 but snmpd will ignore it
now instead of terminating the process.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.4 2014/08/04 15:49:28 reyk Exp $	*/
a26 1
#include <netinet/in_systm.h>
@


1.10
log
@Sync msgbuf_write() changes from relayd.

Please note that proc.c should be kept identical in relayd, iked and
snmpd (currently without the includes).

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.9 2014/05/08 13:04:28 blambert Exp $	*/
a40 2
#include <openssl/ssl.h>

d164 1
a164 1
	 */	
d324 1
d411 1
d418 1
@


1.9
log
@Bring back restricted sockets, inadvertantly removed in
previous proc.c update

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.8 2014/05/06 06:40:03 jsg Exp $	*/
d467 1
a467 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
@


1.8
log
@no need to include rand.h now the RAND_seed() calls are gone.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.7 2014/05/04 10:34:35 reyk Exp $	*/
d339 5
a343 4
	pid_t		 pid;
	struct passwd	*pw;
	const char	*root;
	u_int		 n;
d367 3
d425 3
@


1.7
log
@With the recent change by deraadt@@ to introduce kern.nosuidcoredump=3,
we don't need the horrible debug hack anymore that disabled privdrop
and chroot to get core dumps of privsep processes.  No functional
change for the normal binary, only if it is compiled with the
non-default -DDEBUG option.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.6 2014/04/21 19:47:27 reyk Exp $	*/
a40 1
#include <openssl/rand.h>
@


1.6
log
@Copy the updated proc.c from relayd to use the same file.  Adjust
snmpd accordingly.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.11 2014/04/20 14:48:29 reyk Exp $	*/
a374 1
#ifndef DEBUG
a378 9
#else
#warning disabling privilege revocation and chroot in DEBUG MODE
	if (p->p_chroot != NULL) {
		if (chroot(root) == -1)
			fatal("proc_run: chroot");
		if (chdir("/") == -1)
			fatal("proc_run: chdir(\"/\")");
	}
#endif
a383 1
#ifndef DEBUG
a387 1
#endif
@


1.5
log
@round up some enemy sympathizers found calling RAND_seed().
ok beck reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.4 2014/04/14 07:18:05 blambert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
a22 1
#include <sys/param.h>
d27 4
a31 1
#include <string.h>
d34 2
a35 2
#include <getopt.h>
#include <err.h>
a36 1
#include <event.h>
a37 1
#include <unistd.h>
d39 1
d42 1
d46 4
a49 1
void	 proc_setup(struct privsep *);
d52 12
d66 1
a66 1
proc_init(struct privsep *ps, struct privsep_proc *p, u_int nproc)
d68 2
a69 1
	u_int	 i;
d72 37
a108 1
	 * Called from parent
d111 1
d114 1
d116 8
a123 1
	proc_setup(ps);
d126 2
a127 4
	for (i = 0; i < nproc; i++, p++) {
		ps->ps_title[p->p_id] = p->p_title;
		ps->ps_pid[p->p_id] = (*p->p_init)(ps, p);
	}
d142 1
a142 1
		kill(ps->ps_pid[i], SIGTERM);
d148 2
d153 2
a154 1
proc_setup(struct privsep *ps)
d156 8
a163 1
	int	 i, j, sockpair[2];
d165 27
a191 11
	for (i = 0; i < PROC_MAX; i++)
		for (j = 0; j < PROC_MAX; j++) {
			if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
			    sockpair) == -1)
				fatal("sockpair");
			ps->ps_pipes[i][j] = sockpair[0];
			ps->ps_pipes[j][i] = sockpair[1];
			socket_set_blockmode(ps->ps_pipes[i][j],
			    BM_NONBLOCK);
			socket_set_blockmode(ps->ps_pipes[j][i],
			    BM_NONBLOCK);
d193 1
d197 1
a197 1
proc_config(struct privsep *ps, struct privsep_proc *p, u_int nproc)
d199 2
a200 3
	u_int	 src, dst, i, j, k, found;

	src = privsep_process;
d203 1
a203 1
	 * close unused pipes
d205 19
a223 15
	for (i = 0; i < PROC_MAX; i++) {
		if (i != privsep_process) {
			for (j = 0; j < PROC_MAX; j++) {
				close(ps->ps_pipes[i][j]);
				ps->ps_pipes[i][j] = -1;
			}
		} else {
			for (j = found = 0; j < PROC_MAX; j++, found = 0) {
				for (k = 0; k < nproc; k++) {
					if (p[k].p_id == j)
						found++;
				}
				if (!found) {
					close(ps->ps_pipes[i][j]);
					ps->ps_pipes[i][j] = -1;
d229 3
d233 1
a233 1
	 * listen on appropriate pipes
d235 58
a292 17
	for (i = 0; i < nproc; i++, p++) {
		dst = p->p_id;
		p->p_ps = ps;
		p->p_env = ps->ps_env;

		imsg_init(&ps->ps_ievs[dst].ibuf,
		    ps->ps_pipes[src][dst]);
		ps->ps_ievs[dst].handler = proc_dispatch;
		ps->ps_ievs[dst].events = EV_READ;
		ps->ps_ievs[dst].data = p;
		ps->ps_ievs[dst].name = p->p_title;
		event_set(&ps->ps_ievs[dst].ev,
		    ps->ps_ievs[dst].ibuf.fd,
		    ps->ps_ievs[dst].events,
		    ps->ps_ievs[dst].handler,
		    ps->ps_ievs[dst].data);
		event_add(&ps->ps_ievs[dst].ev, NULL);
d299 4
a302 2
	struct privsep		*ps = p->p_ps;
	struct control_sock	*rcs;
d305 3
a307 1
		(p->p_shutdown)(ps, p);
d309 1
a309 8
	if (p->p_id == PROC_CONTROL && ps) {
		control_cleanup(&ps->ps_csock);
		while ((rcs = TAILQ_FIRST(&ps->ps_rcsocks)) != NULL) {
			TAILQ_REMOVE(&ps->ps_rcsocks, rcs, cs_entry);
			control_cleanup(rcs);
			free(rcs);
		}
	}
a310 1
	log_info("%s exiting", p->p_title);
d338 1
a338 1
    void (*init)(struct privsep *, void *), void *arg)
d343 4
a346 1
	struct control_sock *rcs;
d348 3
d355 2
d364 1
a364 1
	if (p->p_id == PROC_CONTROL) {
a366 3
		TAILQ_FOREACH(rcs, &ps->ps_rcsocks, cs_entry)
			if (control_init(ps, rcs) == -1)
				fatalx(p->p_title);
d401 13
d428 1
a428 1
	proc_config(ps, procs, nproc);
d430 1
a430 1
	if (p->p_id == PROC_CONTROL) {
a433 4
		TAILQ_FOREACH(rcs, &ps->ps_rcsocks, cs_entry)
			if (control_listen(rcs) == -1)
				fatalx(p->p_title);

d437 1
a437 1
		init(ps, arg);
d449 2
a450 1
	struct privsep_proc	*p = (struct privsep_proc *)arg;
a451 1
	struct imsgev		*iev;
a458 1
	iev = &ps->ps_ievs[p->p_id];
d483 6
a503 1

d508 3
a510 2
			log_warnx("%s: %s got imsg %d", __func__, p->p_title,
			    imsg.hdr.type);
d518 4
d565 13
d579 1
a579 1
proc_compose_imsg(struct privsep *ps, enum privsep_procid id,
d582 10
a591 2
	return (imsg_compose_event(&ps->ps_ievs[id],
	    type, -1, 0, fd, data, datalen));
d595 1
a595 1
proc_composev_imsg(struct privsep *ps, enum privsep_procid id,
d598 9
a606 2
	return (imsg_composev_event(&ps->ps_ievs[id],
	    type, -1, 0, fd, iov, iovcnt));
d611 1
a611 1
    enum privsep_procid id)
d613 1
a613 1
	return (proc_compose_imsg(ps, id, imsg->hdr.type,
d615 18
@


1.4
log
@Fix the following idiom in the following way:

        arc4random_buf(seed, sizeof(seed));
        RAND_seed(seed, sizeof(seed));
+       explicit_bzero(seed, sizeof(seed));

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.3 2014/02/14 10:38:09 florian Exp $	*/
a211 1
	u_int32_t	 seed[256];
a279 4

	arc4random_buf(seed, sizeof(seed));
	RAND_seed(seed, sizeof(seed));
	explicit_bzero(seed, sizeof(seed));
@


1.3
log
@remove unused function that distracts from cleaning up the imsg_flush() mess
OK hennig@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.2 2013/11/13 20:45:19 benno Exp $	*/
d284 1
@


1.2
log
@handle msgbuf_write() returning EAGAIN

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.1 2013/10/17 08:42:44 reyk Exp $	*/
a436 6
}

void
proc_flush_imsg(struct privsep *ps, enum privsep_procid id)
{
	imsg_flush(&ps->ps_ievs[id].ibuf);
@


1.1
log
@Update snmpd(8) to use the proc.c privsep style from iked and relayd.

ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.9 2013/03/21 04:30:14 deraadt Exp $	*/
d333 1
a333 1
		if (msgbuf_write(&ibuf->w) == -1)
@

