head	1.41;
access;
symbols
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7;
locks; strict;
comment	@ * @;


1.41
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.40;
commitid	eA8b246voAapPTkX;

1.40
date	2016.11.18.16.16.39;	author jca;	state Exp;
branches;
next	1.39;
commitid	5lrkdv6CJEuqxjzU;

1.39
date	2016.09.02.13.28.36;	author eric;	state Exp;
branches;
next	1.38;
commitid	ejmXptPLj5IaYbLC;

1.38
date	2016.01.25.08.24.30;	author jsg;	state Exp;
branches;
next	1.37;
commitid	LKmYGmH45jtvWSoD;

1.37
date	2015.12.05.13.14.40;	author claudio;	state Exp;
branches;
next	1.36;
commitid	UnsvajcZPqalYyIp;

1.36
date	2015.12.05.06.42.18;	author mmcc;	state Exp;
branches;
next	1.35;
commitid	7b4R1o84KuZAdiL5;

1.35
date	2015.11.23.19.31.52;	author reyk;	state Exp;
branches;
next	1.34;
commitid	7cxebI3ghebF4Szu;

1.34
date	2015.11.21.13.09.47;	author reyk;	state Exp;
branches;
next	1.33;
commitid	BOUp7CEKWK6RD3fw;

1.33
date	2015.10.19.09.32.51;	author reyk;	state Exp;
branches;
next	1.32;
commitid	0bxHONOmYBiEzXnK;

1.32
date	2015.10.19.09.17.23;	author reyk;	state Exp;
branches;
next	1.31;
commitid	LiMMFcoFTJUIqz4F;

1.31
date	2015.10.17.10.20.33;	author reyk;	state Exp;
branches;
next	1.30;
commitid	RaXqaQele7dcQyAs;

1.30
date	2015.10.02.13.13.05;	author reyk;	state Exp;
branches;
next	1.29;
commitid	04Bud1SaEjbiyOcM;

1.29
date	2015.05.28.17.08.09;	author florian;	state Exp;
branches;
next	1.28;
commitid	CuYEPULhoEPTPxJv;

1.28
date	2015.01.16.00.05.13;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	khLbW7SmDyckNaAs;

1.27
date	2014.11.19.10.19.00;	author blambert;	state Exp;
branches;
next	1.26;
commitid	cXioMeUnRYhFJvcH;

1.26
date	2014.07.12.14.15.04;	author reyk;	state Exp;
branches;
next	1.25;
commitid	9Lw1doh9INJVoqMv;

1.25
date	2014.06.03.06.25.47;	author yasuoka;	state Exp;
branches;
next	1.24;
commitid	GbQF0wMbjISLtFeG;

1.24
date	2014.04.25.11.12.14;	author blambert;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.21.19.47.27;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.14.12.55.10;	author blambert;	state Exp;
branches;
next	1.21;

1.21
date	2013.11.26.12.02.22;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2013.11.13.20.45.19;	author benno;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.17.08.42.44;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2012.11.29.14.53.24;	author yasuoka;	state Exp;
branches;
next	1.16;

1.16
date	2012.09.18.08.29.09;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2012.04.11.08.33.53;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2012.04.08.02.57.40;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.14.11.52.19;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.02.19.10.02;	author mk;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.26.17.32.47;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.06.05.52.01;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.25.17.09.55;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.26.15.19.55;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2008.02.07.11.33.26;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.07.11.11.59;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.31.12.17.35;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.16.19.36.06;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.16.09.42.29;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.16.09.36.30;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.05.09.22.44;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@/*	$OpenBSD: control.c,v 1.40 2016/11/18 16:16:39 jca Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/tree.h>

#include <net/if.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include "snmpd.h"

#define	CONTROL_BACKLOG	5

struct ctl_connlist ctl_conns;

static int agentx_sessionid = 1;

void	 control_accept(int, short, void *);
void	 control_close(struct ctl_conn *, const char *, struct imsg *);
void	 control_dispatch_imsg(int, short, void *);
void	 control_dispatch_agentx(int, short, void *);
void	 control_imsg_forward(struct imsg *);
void	 control_event_add(struct ctl_conn *, int, int, struct timeval *);
ssize_t	 imsg_read_nofd(struct imsgbuf *);

int
control_init(struct privsep *ps, struct control_sock *cs)
{
	struct snmpd		*env = ps->ps_env;
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask, mode;

	if (cs->cs_name == NULL)
		return (0);

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, 0)) == -1) {
		log_warn("%s: socket", __func__);
		return (-1);
	}

	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, cs->cs_name,
	    sizeof(sun.sun_path)) >= sizeof(sun.sun_path)) {
		log_warn("%s: %s name too long", __func__, cs->cs_name);
		close(fd);
		return (-1);
	}

	if (unlink(cs->cs_name) == -1)
		if (errno != ENOENT) {
			log_warn("%s: unlink %s", __func__, cs->cs_name);
			close(fd);
			return (-1);
		}

	if (cs->cs_restricted || cs->cs_agentx) {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH;
	} else {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP;
	}

	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("%s: bind: %s", __func__, cs->cs_name);
		close(fd);
		(void)umask(old_umask);
		return (-1);
	}
	(void)umask(old_umask);

	if (chmod(cs->cs_name, mode) == -1) {
		log_warn("%s: chmod", __func__);
		close(fd);
		(void)unlink(cs->cs_name);
		return (-1);
	}

	cs->cs_fd = fd;
	cs->cs_env = env;

	return (0);
}

int
control_listen(struct control_sock *cs)
{
	if (cs->cs_name == NULL)
		return (0);

	if (listen(cs->cs_fd, CONTROL_BACKLOG) == -1) {
		log_warn("%s: listen", __func__);
		return (-1);
	}

	event_set(&cs->cs_ev, cs->cs_fd, EV_READ,
	    control_accept, cs);
	event_add(&cs->cs_ev, NULL);
	evtimer_set(&cs->cs_evt, control_accept, cs);

	return (0);
}

void
control_cleanup(struct control_sock *cs)
{
	if (cs->cs_name == NULL)
		return;
	event_del(&cs->cs_ev);
	event_del(&cs->cs_evt);
}

/* ARGSUSED */
void
control_accept(int listenfd, short event, void *arg)
{
	struct control_sock	*cs = arg;
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*c;

	event_add(&cs->cs_ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	len = sizeof(sun);
	if ((connfd = accept4(listenfd,
	    (struct sockaddr *)&sun, &len, SOCK_NONBLOCK)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&cs->cs_ev);
			evtimer_add(&cs->cs_evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("%s: accept", __func__);
		return;
	}

	if ((c = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		close(connfd);
		log_warn("%s: calloc", __func__);
		return;
	}

	imsg_init(&c->iev.ibuf, connfd);
	if (cs->cs_agentx) {
		c->handle = snmp_agentx_alloc(c->iev.ibuf.fd);
		if (c->handle == NULL) {
			free(c);
			log_warn("%s: agentx", __func__);
			return;
		}
		c->flags |= CTL_CONN_LOCKED;
		c->iev.handler = control_dispatch_agentx;
		TAILQ_INIT(&c->oids);
	} else
		c->iev.handler = control_dispatch_imsg;
	c->iev.events = EV_READ;
	c->iev.data = c;
	c->cs = cs;
	event_set(&c->iev.ev, c->iev.ibuf.fd, c->iev.events,
	    c->iev.handler, c->iev.data);
	event_add(&c->iev.ev, NULL);

	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
}

void
control_close(struct ctl_conn *c, const char *msg, struct imsg *imsg)
{
	struct control_sock *cs = c->cs;

	if (imsg) {
		log_debug("%s: fd %d: %s, imsg %d datalen %zu", __func__,
		    c->iev.ibuf.fd, msg, imsg->hdr.type, IMSG_DATA_SIZE(imsg));
		imsg_free(imsg);
	} else
		log_debug("%s: fd %d: %s", __func__, c->iev.ibuf.fd, msg);

	msgbuf_clear(&c->iev.ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	event_del(&c->iev.ev);
	close(c->iev.ibuf.fd);

	/* Some file descriptors are available again. */
	if (evtimer_pending(&cs->cs_evt, NULL)) {
		evtimer_del(&cs->cs_evt);
		event_add(&cs->cs_ev, NULL);
	}

	free(c);
}

/* ARGSUSED */
void
control_dispatch_imsg(int fd, short event, void *arg)
{
	struct ctl_conn		*c = arg;
	struct control_sock	*cs = c->cs;
	struct snmpd		*env = cs->cs_env;
	struct imsg		 imsg;
	int			 n, v, i;

	if (event & EV_READ) {
		if (((n = imsg_read_nofd(&c->iev.ibuf)) == -1 &&
		    errno != EAGAIN) || n == 0) {
			control_close(c, "could not read imsg", NULL);
			return;
		}
	}
	if (event & EV_WRITE) {
		if (msgbuf_write(&c->iev.ibuf.w) <= 0 && errno != EAGAIN) {
			control_close(c, "could not write imsg", NULL);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
			control_close(c, "could not get imsg", NULL);
			return;
		}

		if (n == 0)
			break;

		if (cs->cs_restricted || (c->flags & CTL_CONN_LOCKED)) {
			switch (imsg.hdr.type) {
			case IMSG_SNMP_AGENTX:
			case IMSG_SNMP_ELEMENT:
			case IMSG_SNMP_END:
			case IMSG_SNMP_LOCK:
				break;
			default:
				control_close(c,
				    "client requested restricted command",
				    &imsg);
				return;
			}
		}

		control_imsg_forward(&imsg);

		switch (imsg.hdr.type) {
		case IMSG_CTL_NOTIFY:
			if (IMSG_DATA_SIZE(&imsg))
				return control_close(c, "invalid size", &imsg);

			if (c->flags & CTL_CONN_NOTIFY) {
				log_debug("%s: "
				    "client requested notify more than once",
				    __func__);
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, 0, -1, NULL, 0);
				break;
			}
			c->flags |= CTL_CONN_NOTIFY;
			break;

		case IMSG_SNMP_LOCK:
			if (IMSG_DATA_SIZE(&imsg))
				return control_close(c, "invalid size", &imsg);

			/* enable restricted control mode */
			c->flags |= CTL_CONN_LOCKED;
			break;

		case IMSG_SNMP_AGENTX:
			if (IMSG_DATA_SIZE(&imsg))
				return control_close(c, "invalid size", &imsg);

			/* rendezvous with the client */
			imsg_compose_event(&c->iev, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
			if (imsg_flush(&c->iev.ibuf) == -1) {
				control_close(c,
				    "could not rendezvous with agentx client",
				    &imsg);
				return;
			}

			/* enable AgentX socket */
			c->handle = snmp_agentx_alloc(c->iev.ibuf.fd);
			if (c->handle == NULL) {
				control_close(c,
				    "could not allocate agentx socket",
				    &imsg);
				return;
			}
			/* disable IMSG notifications */
			c->flags &= ~CTL_CONN_NOTIFY;
			c->flags |= CTL_CONN_LOCKED;
			c->iev.handler = control_dispatch_agentx;
			break;

		case IMSG_CTL_VERBOSE:
			if (IMSG_DATA_SIZE(&imsg) != sizeof(v))
				return control_close(c, "invalid size", &imsg);

			memcpy(&v, imsg.data, sizeof(v));
			log_setverbose(v);

			for (i = 0; i < PROC_MAX; i++) {
				if (privsep_process == PROC_CONTROL)
					continue;
				proc_forward_imsg(&env->sc_ps, &imsg, i, -1);
			}
			break;
		case IMSG_CTL_RELOAD:
			if (IMSG_DATA_SIZE(&imsg))
				return control_close(c, "invalid size", &imsg);
			proc_forward_imsg(&env->sc_ps, &imsg, PROC_PARENT, -1);
			break;
		default:
			control_close(c, "invalid type", &imsg);
			return;
		}

		imsg_free(&imsg);
	}

	imsg_event_add(&c->iev);
}

static void
purge_registered_oids(struct oidlist *oids)
{
	struct oid	*oid;

	while ((oid = TAILQ_FIRST(oids)) != NULL) {
		if (!(oid->o_flags & OID_REGISTERED))
			fatalx("attempting to unregister a static mib");
		smi_delete(oid);
		TAILQ_REMOVE(oids, oid, o_list);
	}
}

/* ARGSUSED */
void
control_dispatch_agentx(int fd, short event, void *arg)
{
	struct ctl_conn			*c = arg;
	struct agentx_handle		*h = c->handle;
	struct agentx_pdu		*pdu;
	struct timeval			 tv;
	struct agentx_open_timeout	 to;
	struct ber_oid			 oid;
	struct agentx_close_request_data clhdr;
	int				 closing = 0;
	int				 evflags = 0;
	int				 timer = 0;
	int				 error = AGENTX_ERR_NONE;
	int				 idx = 0, vcpylen, dlen, uptime;
	char				*descr, *varcpy;

	varcpy = descr = NULL;
	if (h->timeout != 0)
		tv.tv_sec = h->timeout;
	else
		tv.tv_sec = AGENTX_DEFAULT_TIMEOUT;
	tv.tv_usec = 0;

	if (event & EV_TIMEOUT) {
		log_info("subagent session '%i' timed out after %i seconds",
		    h->sessionid, h->timeout);
		goto teardown;
	}

	if (event & EV_WRITE) {
		if (snmp_agentx_send(h, NULL) == -1) {
			if (errno != EAGAIN)
				goto teardown;

			/* short write */
			evflags |= EV_WRITE;
			timer = 1;
		}
	}

	if (event & EV_READ) {
		if ((pdu = snmp_agentx_recv(h)) == NULL) {
			if (h->error) {
				error = h->error;
				goto respond;
			}
			if (errno != EAGAIN)
				goto teardown;

			/* short read */
			timer = 1;
			goto done;
		}

		switch (pdu->hdr->type) {
		case AGENTX_OPEN:
			if (snmp_agentx_read_raw(pdu, &to, sizeof(to)) == -1 ||
			    snmp_agentx_read_oid(pdu,
			    (struct snmp_oid *)&oid) == -1 ||
			    (descr =
			    snmp_agentx_read_octetstr(pdu, &dlen)) == NULL) {
				error = AGENTX_ERR_PARSE_ERROR;
				break;
			}

			log_info("opening AgentX socket for '%.*s'",
			    dlen, descr);

			h->sessionid = pdu->hdr->sessionid =
			    agentx_sessionid++;
			if (to.timeout != 0)
				h->timeout = to.timeout;
			else
				h->timeout = AGENTX_DEFAULT_TIMEOUT;
			break;

		case AGENTX_CLOSE:
			if (snmp_agentx_read_raw(pdu,
			    &clhdr, sizeof(clhdr)) == -1) {
				error = AGENTX_ERR_PARSE_ERROR;
				break;
			}
			closing = 1;
			break;

		case AGENTX_NOTIFY:
			error = trap_agentx(h, pdu, &idx, &varcpy, &vcpylen);
			break;

		case AGENTX_PING:
			/* no processing, just an empty response */
			break;

		case AGENTX_REGISTER: {
			struct agentx_register_hdr	 rhdr;
			struct oidlist			 oids;
			struct oid			*miboid;
			uint32_t			 ubound = 0;

			TAILQ_INIT(&oids);

			if (snmp_agentx_read_raw(pdu,
			    &rhdr, sizeof(rhdr)) == -1 ||
			    snmp_agentx_read_oid(pdu,
			    (struct snmp_oid *)&oid) == -1) {
				error = AGENTX_ERR_PARSE_ERROR;
				break;
			}

			do {
				if ((miboid = calloc(1, sizeof(*miboid))) == NULL) {
					purge_registered_oids(&oids);
					error = AGENTX_ERR_PARSE_ERROR;
					goto dodone;
				}
				bcopy(&oid, &miboid->o_id, sizeof(oid));
				miboid->o_flags = OID_RD|OID_WR|OID_REGISTERED;
				miboid->o_session = c;
				if (smi_insert(miboid) == -1) {
					purge_registered_oids(&oids);
					error = AGENTX_ERR_DUPLICATE_REGISTRATION;
					goto dodone;
				}
				TAILQ_INSERT_TAIL(&oids, miboid, o_list);
			} while (++oid.bo_id[rhdr.subrange] <= ubound);

			while ((miboid = TAILQ_FIRST(&oids)) != NULL) {
				TAILQ_REMOVE(&oids, miboid, o_list);
				TAILQ_INSERT_TAIL(&c->oids, miboid, o_list);
			}
 dodone:
			break;
		}

		case AGENTX_UNREGISTER: {
			struct agentx_unregister_hdr	 uhdr;
			struct oid			*miboid;
			uint32_t			 ubound = 0;

			if (snmp_agentx_read_raw(pdu,
			    &uhdr, sizeof(uhdr)) == -1 ||
			    snmp_agentx_read_oid(pdu,
			    (struct snmp_oid *)&oid) == -1) {
				error = AGENTX_ERR_PARSE_ERROR;
				break;
			}

			do {
				if ((miboid = smi_find((struct oid *)&oid)) == NULL) {
					log_warnx("attempting to remove unregistered MIB");
					continue;
				}
				if (miboid->o_session != c) {
					log_warnx("attempting to remove MIB registered by other session");
					continue;
				}
				smi_delete(miboid);
			} while (++oid.bo_id[uhdr.subrange] <= ubound);
			break;
		}

		case AGENTX_RESPONSE: {
			struct snmp_message		*msg = pdu->request->cookie;
			struct agentx_response_data	 resp;
			struct agentx_varbind_hdr	 vbhdr;
			struct ber_element		**elm, **iter;

			if (snmp_agentx_read_response(pdu, &resp) == -1) {
				msg->sm_error = SNMP_ERROR_GENERR;
				goto dispatch;
			}

			switch (resp.error) {
			case AGENTX_ERR_NONE:
				break;

			/* per RFC, resp.error may be an SNMP error value */
			case SNMP_ERROR_TOOBIG:
			case SNMP_ERROR_NOSUCHNAME:
			case SNMP_ERROR_BADVALUE:
			case SNMP_ERROR_READONLY:
			case SNMP_ERROR_GENERR:
			case SNMP_ERROR_NOACCESS:
			case SNMP_ERROR_WRONGTYPE:
			case SNMP_ERROR_WRONGLENGTH:
			case SNMP_ERROR_WRONGENC:
			case SNMP_ERROR_WRONGVALUE:
			case SNMP_ERROR_NOCREATION:
			case SNMP_ERROR_INCONVALUE:
			case SNMP_ERROR_RESUNAVAIL:
			case SNMP_ERROR_COMMITFAILED:
			case SNMP_ERROR_UNDOFAILED:
			case SNMP_ERROR_AUTHERROR:
			case SNMP_ERROR_NOTWRITABLE:
			case SNMP_ERROR_INCONNAME:
				msg->sm_error = resp.error;
				msg->sm_errorindex = resp.index;
				break;

			case AGENTX_ERR_INDEX_WRONG_TYPE:
			case AGENTX_ERR_UNSUPPORTED_CONTEXT:
			case AGENTX_ERR_PARSE_ERROR:
			case AGENTX_ERR_REQUEST_DENIED:
			case AGENTX_ERR_PROCESSING_ERROR:
			default:
				msg->sm_error = SNMP_ERROR_GENERR;
				msg->sm_errorindex = resp.index;
				break;
			}

			iter = elm = &msg->sm_varbindresp;

			while (pdu->datalen > sizeof(struct agentx_hdr)) {
				if (snmp_agentx_read_raw(pdu, &vbhdr, sizeof(vbhdr)) == -1 ||
				    varbind_convert(pdu, &vbhdr, elm, iter)
				    != AGENTX_ERR_NONE) {
					msg->sm_error = SNMP_ERROR_GENERR;
					msg->sm_errorindex = msg->sm_i;
					goto dispatch;
				}
			}
 dispatch:
			snmpe_dispatchmsg(msg, fd);
			break;
		}

		/* unimplemented, but parse and accept for now */
		case AGENTX_ADD_AGENT_CAPS:
		case AGENTX_REMOVE_AGENT_CAPS:
			break;

		/* unimplemented */
		case AGENTX_GET:
		case AGENTX_GET_NEXT:
		case AGENTX_GET_BULK:
		case AGENTX_TEST_SET:
		case AGENTX_COMMIT_SET:
		case AGENTX_UNDO_SET:
		case AGENTX_CLEANUP_SET:
		case AGENTX_INDEX_ALLOCATE:
		case AGENTX_INDEX_DEALLOCATE:
			error = AGENTX_ERR_REQUEST_DENIED;
			break;

		/* NB: by RFC, this should precede all other checks. */
		default:
			log_info("unknown AgentX type '%i'", pdu->hdr->type);
			error = AGENTX_ERR_PARSE_ERROR;
			break;
		}
 respond:
		if (pdu)
			snmp_agentx_pdu_free(pdu);

		uptime = smi_getticks();
		if ((pdu = snmp_agentx_response_pdu(uptime, error, idx)) == NULL) {
			log_debug("failed to generate response");
			free(varcpy);
			control_event_add(c, fd, EV_WRITE, NULL);	/* XXX -- EV_WRITE? */
			return;
		}

		if (varcpy) {
			snmp_agentx_raw(pdu, varcpy, vcpylen); /* XXX */
			free(varcpy);
			varcpy = NULL;
		}
		snmp_agentx_send(h, pdu);

		/* Request processed, now write out response */
		evflags |= EV_WRITE;
	}

	if (closing)
		goto teardown;
 done:
	control_event_add(c, fd, evflags, timer ? &tv : NULL);
	return;

 teardown:
	log_debug("subagent session '%i' destroyed", h->sessionid);
	snmp_agentx_free(h);
	purge_registered_oids(&c->oids);
	free(varcpy);
	control_close(c, "agentx teardown", NULL);
}

void
control_imsg_forward(struct imsg *imsg)
{
	struct ctl_conn *c;

	TAILQ_FOREACH(c, &ctl_conns, entry)
		if (c->flags & CTL_CONN_NOTIFY)
			imsg_compose_event(&c->iev, imsg->hdr.type,
			    0, imsg->hdr.pid, -1, imsg->data,
			    imsg->hdr.len - IMSG_HEADER_SIZE);
}

void
control_event_add(struct ctl_conn *c, int fd, int wflag, struct timeval *tv)
{
	event_del(&c->iev.ev);
	event_set(&c->iev.ev, fd, EV_READ|wflag, control_dispatch_agentx, c);
	event_add(&c->iev.ev, tv);
}

/* This should go into libutil, from smtpd/mproc.c */
ssize_t
imsg_read_nofd(struct imsgbuf *ibuf)
{
	ssize_t	 n;
	char	*buf;
	size_t	 len;

	buf = ibuf->r.buf + ibuf->r.wpos;
	len = sizeof(ibuf->r.buf) - ibuf->r.wpos;

	while ((n = recv(ibuf->fd, buf, len, 0)) == -1) {
		if (errno != EINTR)
			return (n);
	}

        ibuf->r.wpos += n;
        return (n);
}
@


1.40
log
@Add support for multiple listening sockets

One can now specify multiple "listen on" statements. The default is to
listen on 0.0.0.0 and ::, which means better handling of dual-stack
setups.  ok sthen@@ on a previous version, input and ok reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.39 2016/09/02 13:28:36 eric Exp $	*/
d334 1
a334 1
			log_verbose(v);
@


1.39
log
@use imsg_read_nofd() implementation from bgpd.
let the caller handle EAGAIN.

ok reyk@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.38 2016/01/25 08:24:30 jsg Exp $	*/
d595 1
a595 1
			snmpe_dispatchmsg(msg);
@


1.38
log
@avoid a potential double free
ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.37 2015/12/05 13:14:40 claudio Exp $	*/
d691 3
a693 5
 again:
	if ((n = recv(ibuf->fd, buf, len, 0)) == -1) {
		if (errno != EINTR && errno != EAGAIN)
			goto fail;
		goto again;
a696 1
 fail:
@


1.37
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.36 2015/12/05 06:42:18 mmcc Exp $	*/
d638 1
@


1.36
log
@strings.h -> string.h to prevent an implicit declaration warning. Also
remove a handful of NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.35 2015/11/23 19:31:52 reyk Exp $	*/
d239 2
a240 1
		if ((n = imsg_read_nofd(&c->iev.ibuf)) == -1 || n == 0) {
@


1.35
log
@Use SOCK_NONBLOCK to replace socket_set_blockmode() and fcntl(..O_NONBLOCK).
(SOCK_CLOEXEC should also be added where it is appropriate, but this is OBnot
done in this commit yet.)

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.34 2015/11/21 13:09:47 reyk Exp $	*/
d629 1
a629 2
			if (varcpy)
				free(varcpy);
d654 1
a654 2
	if (varcpy)
		free(varcpy);
@


1.34
log
@While here, fix two size format string warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.33 2015/10/19 09:32:51 reyk Exp $	*/
d63 1
a63 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
a105 1
	socket_set_blockmode(fd, BM_NONBLOCK);
d155 2
a156 2
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
a170 2

	socket_set_blockmode(connfd, BM_NONBLOCK);
@


1.33
log
@Fix control_imsg_forward() by changing imsg_compose() to
imsg_compose_event().  This was done by pyr@@'s in relayd/control.c
-r1.32 (2009/06/05, ok eric@@) but somehow didn't slip into other
daemons that imported control.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.32 2015/10/19 09:17:23 reyk Exp $	*/
d210 1
a210 1
		log_debug("%s: fd %d: %s, imsg %d datalen %u", __func__,
@


1.32
log
@Print control socket client fd in debug message to differentiate between
control connections.  Helps to debug problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.31 2015/10/17 10:20:33 reyk Exp $	*/
d670 1
a670 1
			imsg_compose(&c->iev.ibuf, imsg->hdr.type,
@


1.31
log
@Tighten up snmpd's control socket: do not allow users to terminate the
daemon by sending corrupted imsgs to snmpd.  This is especially
important for the optional world-writeable restricted socket that is
used for AgentX.  In particular, don't fatal() in the daemon when imsg
size checks on control messages fail, do stricter validation of
expected messages (even assert zero-length imsgs), don't continue and
close the control socket on suspicious input, print a debug log
message on error.

OK gilles@@ "the rationale behind it is quite clear"
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.30 2015/10/02 13:13:05 reyk Exp $	*/
a175 1
		log_warn("%s", __func__);
d177 1
d210 2
a211 2
		log_debug("%s: %s, imsg %d datalen %u", __func__, msg,
		    imsg->hdr.type, IMSG_DATA_SIZE(imsg));
d214 1
a214 1
		log_debug("%s: %s", __func__, msg);
@


1.30
log
@Adopt smtpd's imsg_read_nofd() to mitigate the risk of user-injected
file descriptor leakage from the optional world-writable _restricted_
control socket.

OK gilles@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.29 2015/05/28 17:08:09 florian Exp $	*/
d45 1
a45 1
void	 control_close(struct ctl_conn *);
d205 1
a205 1
control_close(struct ctl_conn *c)
d209 7
d243 1
a243 1
			control_close(c);
d249 1
a249 1
			control_close(c);
d256 1
a256 1
			control_close(c);
d271 3
a273 4
				log_debug("control_dispatch_imsg: "
				    "client requested restricted command");
				imsg_free(&imsg);
				control_close(c);
d282 3
d297 3
d305 2
d311 3
a313 4
				log_debug("control_dispatch_imsg: "
				    "could not rendezvous with client");
				imsg_free(&imsg);
				control_close(c);
d320 3
a322 4
				log_debug("control_dispatch_imsg: "
				    "could not allocate restricted socket");
				imsg_free(&imsg);
				control_close(c);
d332 2
a333 1
			IMSG_SIZE_CHECK(&imsg, &v);
d345 2
d350 2
a351 3
			log_debug("%s: error handling imsg %d",
			    __func__, imsg.hdr.type);
			break;
d353 1
d660 1
a660 1
	control_close(c);
@


1.29
log
@Do not try to unlink the control socket in an unprivileged child
process on shutdown.
Found while working on tame(2).
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.28 2015/01/16 00:05:13 deraadt Exp $	*/
d50 1
d235 1
a235 1
		if ((n = imsg_read(&c->iev.ibuf)) == -1 || n == 0) {
d666 23
@


1.28
log
@first batch of cleanup to programs based upon the namespace cleanups
in net/pfvar.h sys/proc.h sys/ucred.h arpa/nameser.h
change to PATH_MAX, reduce use of MIN() and MAX(), HOST_NAME_MAX+1,
LOGIN_NAME_MAX, etc etc
ok millert guenther, some review by doug
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.27 2014/11/19 10:19:00 blambert Exp $	*/
a137 1
	(void)unlink(cs->cs_name);
@


1.27
log
@add support for AgentX subagents in snmpd

snmp requests are now packaged into pseudo-continuations
to allow for being dispatched to seperate processes;
lightly tested for interoperability with NetSNMP, but
doesn't implement the complete set of AgentX messages

while here, clean up return types of mps_get* functions,
and make smi_insert refuse to insert duplicate OIDs

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.26 2014/07/12 14:15:04 reyk Exp $	*/
a20 1
#include <sys/param.h>
@


1.26
log
@Sync msgbuf_write() changes from relayd.

Please note that proc.c should be kept identical in relayd, iked and
snmpd (currently without the includes).

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.25 2014/06/03 06:25:47 yasuoka Exp $	*/
d184 2
a185 2
		c->data = snmp_agentx_alloc(c->iev.ibuf.fd);
		if (c->data == NULL) {
d192 1
d306 2
a307 2
			c->data = snmp_agentx_alloc(c->iev.ibuf.fd);
			if (c->data == NULL) {
d346 13
d364 1
a364 1
	struct agentx_handle		*h = c->data;
d454 134
a587 1
		/* unimplemented */
d590 3
a592 3
		case AGENTX_RESPONSE:
		case AGENTX_REGISTER:
		case AGENTX_UNREGISTER:
d643 1
@


1.25
log
@Handle the event parameter of libevent callback function as a bit
mask.  Also remove redundant imsg_event_add calls.  Fixes come from
usr.sbin/ospfd/control.c

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.24 2014/04/25 11:12:14 blambert Exp $	*/
d241 1
a241 1
		if (msgbuf_write(&c->iev.ibuf.w) < 0 && errno != EAGAIN) {
@


1.24
log
@Remove NULL pointer dereference, which jsg insists I not
call a use-after free, from error path.

found by and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.23 2014/04/21 19:47:27 reyk Exp $	*/
d234 1
a234 2
	switch (event) {
	case EV_READ:
d239 2
a240 2
		break;
	case EV_WRITE:
a244 3
		break;
	default:
		fatalx("unknown event");
@


1.23
log
@Copy the updated proc.c from relayd to use the same file.  Adjust
snmpd accordingly.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.22 2014/04/14 12:55:10 blambert Exp $	*/
d474 1
a474 2
			log_debug("bad response generation: %s",
			    snmp_agentx_type2name(pdu->hdr->type));
@


1.22
log
@Make snmpd use the AgentX protcol for accepting trap requests.
AgentX notifications are the only portion implemented right now;
get in the tree to flesh out the remainder.

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.21 2013/11/26 12:02:22 henning Exp $	*/
d332 1
a332 1
				proc_forward_imsg(&env->sc_ps, &imsg, i);
d336 1
a336 1
			proc_forward_imsg(&env->sc_ps, &imsg, PROC_PARENT);
@


1.21
log
@remove "clever" shortcut that might bite later, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2013/10/17 08:42:44 reyk Exp $	*/
d43 2
d46 1
a46 3
struct ctl_conn
	*control_connbyfd(int);
void	 control_close(int, struct control_sock *);
d48 1
d50 1
d83 1
a83 1
	if (cs->cs_restricted) {
d183 11
a193 1
	c->iev.handler = control_dispatch_imsg;
d195 2
a196 1
	c->iev.data = cs;
a203 12
struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */

	return (c);
}

d205 1
a205 1
control_close(int fd, struct control_sock *cs)
d207 1
a207 6
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("%s: fd %d: not found", __func__, fd);
		return;
	}
d228 2
a229 1
	struct control_sock	*cs = arg;
a230 1
	struct ctl_conn		*c;
a233 5
	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("%s: fd %d: not found", __func__, fd);
		return;
	}

d237 1
a237 1
			control_close(fd, cs);
d243 1
a243 1
			control_close(fd, cs);
d253 1
a253 1
			control_close(fd, cs);
d262 1
a262 1
			case IMSG_SNMP_TRAP:
d271 1
a271 1
				control_close(fd, cs);
d290 1
d295 6
a300 2
		case IMSG_SNMP_TRAP:
			if (trap_imsg(&c->iev, imsg.hdr.pid) == -1) {
d302 1
a302 2
				    "received invalid trap (pid %d)",
				    imsg.hdr.pid);
d304 1
a304 1
				control_close(fd, cs);
d307 14
d322 1
d349 157
d516 8
@


1.20
log
@handle msgbuf_write() returning EAGAIN

ok reyk
@
text
@d255 1
a255 2
		imsg_event_add(&c->iev);
		return;
@


1.19
log
@Update snmpd(8) to use the proc.c privsep style from iked and relayd.

ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2013/03/11 17:40:11 deraadt Exp $	*/
d251 1
a251 1
		if (msgbuf_write(&c->iev.ibuf.w) < 0) {
@


1.18
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.17 2012/11/29 14:53:24 yasuoka Exp $	*/
d4 1
a21 1
#include <sys/types.h>
d43 6
a48 2
struct ctl_conn	*control_connbyfd(int);
void		 control_close(int, struct control_sock *);
d51 1
a51 1
control_init(struct control_sock *cs)
d53 1
d62 1
a62 1
		log_warn("control_init: socket");
d69 1
a69 1
		log_warn("control_init: %s name too long", cs->cs_name);
d76 1
a76 1
			log_warn("control_init: unlink %s", cs->cs_name);
d90 1
a90 1
		log_warn("control_init: bind: %s", cs->cs_name);
d98 1
a98 1
		log_warn("control_init: chmod");
d104 1
a104 1
	session_socket_blockmode(fd, BM_NONBLOCK);
d106 1
d118 1
a118 1
		log_warn("control_listen: listen");
d144 1
a144 1
	struct control_sock	*cs = (struct control_sock *)arg;
d168 1
a168 1
			log_warn("control_accept: accept");
d172 1
a172 1
	session_socket_blockmode(connfd, BM_NONBLOCK);
d175 1
a175 1
		log_warn("control_accept");
d185 1
a185 1
	    c->iev.handler, cs);
d209 1
a209 1
		log_warn("control_close: fd %d: not found", fd);
d232 2
a233 1
	struct control_sock	*cs = (struct control_sock *)arg;
d236 1
a236 1
	int			 n;
d239 1
a239 1
		log_warn("control_dispatch_imsg: fd %d: not found", fd);
d286 2
d291 4
a294 3
				log_debug("control_dispatch_imsg: "
				    "client requested notify more than once");
				imsg_compose(&c->iev.ibuf, IMSG_CTL_FAIL,
d314 15
d330 2
a331 2
			log_debug("control_dispatch_imsg: "
			    "error handling imsg %d", imsg.hdr.type);
d347 2
a348 2
			imsg_compose(&c->iev.ibuf, imsg->hdr.type, 0,
			    imsg->hdr.pid, -1, imsg->data,
a349 17
}

void
session_socket_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
@


1.17
log
@Wrong argument was passed to control_dispatch_imsg().  Use always
(struct imsgev *)->data for the argument of imsgev handlers.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2012/09/18 08:29:09 reyk Exp $	*/
d160 2
a161 1
		} else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.16
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2012/04/11 08:33:53 deraadt Exp $	*/
d176 1
@


1.15
log
@delete excessive evtimer_pending; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2012/04/08 02:57:40 deraadt Exp $	*/
d282 2
a283 2
				imsg_compose(&c->iev.ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
d320 3
a322 2
			imsg_compose(&c->iev.ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
			    -1, imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE);
@


1.14
log
@add the evtimout rate-limiting code for accept() here too.
eyed a little by joel
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2010/05/14 11:52:19 claudio Exp $	*/
d130 1
a130 2
	if (evtimer_pending(&cs->cs_evt, NULL))
		event_del(&cs->cs_evt);
@


1.13
log
@Use calloc() instead of malloc() to allocate the connection structure. This
way the memory is zeroed. This is equivalent to the relayd commit by reyk.
OK reyk, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2009/12/02 19:10:02 mk Exp $	*/
d44 1
a44 1
void		 control_close(int);
d116 1
a116 1
	event_set(&cs->cs_ev, cs->cs_fd, EV_READ | EV_PERSIST,
d119 1
d129 3
d145 4
d152 10
a161 1
		if (errno != EWOULDBLOCK && errno != EINTR)
d197 1
a197 1
control_close(int fd)
d211 7
d238 1
a238 1
			control_close(fd);
d244 1
a244 1
			control_close(fd);
d255 1
a255 1
			control_close(fd);
d273 1
a273 1
				control_close(fd);
d299 1
a299 1
				control_close(fd);
@


1.12
log
@log_warn() consistency.

`OK' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2009/11/26 17:32:47 reyk Exp $	*/
d151 1
a151 1
	if ((c = malloc(sizeof(struct ctl_conn))) == NULL) {
@


1.11
log
@sync snmp_imsg_hdr with imsg_hdr and unbreak the snmp trap interface
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2009/06/06 05:52:01 pyr Exp $	*/
d145 1
a145 1
			log_warn("control_accept");
@


1.10
log
@sync snmpd with the common imsg code, making it lib ready as well.
ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2009/02/25 17:09:55 claudio Exp $	*/
d243 1
@


1.9
log
@Fix an invalid pointer dereference in control_close(). If control_connbyfd()
fails -- which should never happen -- the function does not return and is
accession the NULL set control pointer later on.
Found by Matthew Haub. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2008/09/26 15:19:55 reyk Exp $	*/
d157 6
a162 5
	imsg_init(&c->ibuf, connfd, control_dispatch_imsg);
	c->ibuf.events = EV_READ;
	event_set(&c->ibuf.ev, c->ibuf.fd, c->ibuf.events,
	    c->ibuf.handler, cs);
	event_add(&c->ibuf.ev, NULL);
d172 1
a172 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.fd != fd;
d189 1
a189 1
	msgbuf_clear(&c->ibuf.w);
d192 2
a193 2
	event_del(&c->ibuf.ev);
	close(c->ibuf.fd);
d213 1
a213 1
		if ((n = imsg_read(&c->ibuf)) == -1 || n == 0) {
d219 1
a219 1
		if (msgbuf_write(&c->ibuf.w) < 0) {
d223 1
a223 1
		imsg_event_add(&c->ibuf);
d230 1
a230 1
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1) {
d258 1
a258 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d269 1
a269 1
			if (trap_imsg(&c->ibuf, imsg.hdr.pid) == -1) {
d286 1
a286 1
	imsg_event_add(&c->ibuf);
d296 1
a296 1
			imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
@


1.8
log
@allow to add an additional restricted control socket for trap sending
only (not even show commands).  this allows to place a socket for
traps in another daemon's chroot.

(based on restricted socket support from bgpd)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2008/02/07 11:33:26 reyk Exp $	*/
d183 1
a183 1
	if ((c = control_connbyfd(fd)) == NULL)
d185 2
@


1.7
log
@add a imsg which allows to "lock" the control connection, the
restricted connection will reject any commands except snmp traps.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2008/02/07 11:11:59 reyk Exp $	*/
a45 2
struct imsgbuf	*ibuf_parent = NULL;

d47 1
a47 1
control_init(void)
d51 4
a54 1
	mode_t			 old_umask;
d62 1
a62 1
	if (strlcpy(sun.sun_path, SNMPD_SOCKET,
d64 1
a64 1
		log_warn("control_init: %s name too long", SNMPD_SOCKET);
d69 1
a69 1
	if (unlink(SNMPD_SOCKET) == -1)
d71 1
a71 1
			log_warn("control_init: unlink %s", SNMPD_SOCKET);
d76 8
a83 1
	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
d85 1
a85 1
		log_warn("control_init: bind: %s", SNMPD_SOCKET);
d92 1
a92 1
	if (chmod(SNMPD_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
d95 1
a95 1
		(void)unlink(SNMPD_SOCKET);
d100 1
a100 1
	control_state.fd = fd;
d106 1
a106 1
control_listen(struct snmpd *env, struct imsgbuf *parent)
d108 2
a109 1
	ibuf_parent = parent;
d111 1
a111 1
	if (listen(control_state.fd, CONTROL_BACKLOG) == -1) {
d116 3
a118 3
	event_set(&control_state.ev, control_state.fd, EV_READ | EV_PERSIST,
	    control_accept, env);
	event_add(&control_state.ev, NULL);
d124 1
a124 1
control_cleanup(void)
d126 3
a128 1
	(void)unlink(SNMPD_SOCKET);
d135 1
a139 1
	struct snmpd		*env = arg;
d160 1
a160 1
	    c->ibuf.handler, env);
d198 1
d235 1
a235 1
		if (c->flags & CTL_CONN_LOCKED) {
@


1.6
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2008/01/31 12:17:35 henning Exp $	*/
d223 15
d248 4
@


1.5
log
@do not leak confd on malloc failure in control_accept()
found by Igor Zinovik <zinovik@@cs.karelia.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2008/01/16 19:36:06 reyk Exp $	*/
d128 1
a128 1
	struct snmpd	*env = arg;
@


1.4
log
@implementation of the SNMP trap sender interface
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2008/01/16 09:42:29 reyk Exp $	*/
d142 1
@


1.3
log
@move trap code to an own file; there will be more
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2008/01/16 09:36:30 reyk Exp $	*/
d234 1
a234 1
			if (trap_request(&c->ibuf, imsg.hdr.pid) == -1) {
@


1.2
log
@start working on an interface to send traps via snmpd.sock.  userland
applications will be able to send imsgs defining the trap to snmpd and
the daemon will do the ASN.1/BER encoding before sending traps to the
registered receivers.  there are two advantages of this approach that
a) the applications do not need to handle any ASN.1/BER encoding and
b) snmpd will provide a central interface to define trap receivers.

discussed with thib and others
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2007/12/05 09:22:44 reyk Exp $	*/
d234 1
a234 1
			if (snmpe_trap(&c->ibuf, imsg.hdr.pid) == -1) {
@


1.1
log
@Start working on snmpd(8) and snmpctl(8), a lightweight SNMP implementation
for OpenBSD.  SNMP is a necessary evil.  This is work in progress, don't
expect too much from it yet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2007/11/08 18:05:09 reyk Exp $	*/
d232 10
@

