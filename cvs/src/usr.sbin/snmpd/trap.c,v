head	1.29;
access;
symbols
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.8
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.6
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11;
locks; strict;
comment	@ * @;


1.29
date	2017.04.21.13.46.15;	author jca;	state Exp;
branches;
next	1.28;
commitid	DPzGVVvlVV4VaI9Z;

1.28
date	2016.11.09.20.31.56;	author jca;	state Exp;
branches;
next	1.27;
commitid	W7m2j1sZd5b467J6;

1.27
date	2016.10.28.08.01.53;	author rzalamena;	state Exp;
branches;
next	1.26;
commitid	SMslalgbhOIf4OXA;

1.26
date	2015.12.05.06.42.18;	author mmcc;	state Exp;
branches;
next	1.25;
commitid	7b4R1o84KuZAdiL5;

1.25
date	2015.11.21.13.09.47;	author reyk;	state Exp;
branches;
next	1.24;
commitid	BOUp7CEKWK6RD3fw;

1.24
date	2015.01.16.00.05.13;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	khLbW7SmDyckNaAs;

1.23
date	2014.11.19.10.19.00;	author blambert;	state Exp;
branches;
next	1.22;
commitid	cXioMeUnRYhFJvcH;

1.22
date	2014.04.14.12.55.10;	author blambert;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.19.14.18.39;	author blambert;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.01.12.41.48;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2013.09.26.09.11.30;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2013.09.11.14.58.01;	author blambert;	state Exp;
branches;
next	1.17;

1.17
date	2012.09.17.16.43.59;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2012.02.01.18.44.06;	author camield;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.16.15.30.35;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.06.05.52.01;	author pyr;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.09.14.14.40;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.18.16.57.58;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2008.02.08.12.36.47;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.24.06.36.51;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.18.13.04.28;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.18.02.09.30;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.17.23.36.26;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.17.22.55.07;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.17.17.35.06;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.16.21.43.19;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.16.19.36.06;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.16.09.45.17;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2008.01.16.09.42.29;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Fix uninitialized variable that coult result in a crash.

Fix from Rivo Nurges.
@
text
@/*	$OpenBSD: trap.c,v 1.28 2016/11/09 20:31:56 jca Exp $	*/

/*
 * Copyright (c) 2008 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/tree.h>

#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>

#include "snmpd.h"
#include "mib.h"

void
trap_init(void)
{
	struct ber_oid	 trapoid = OID(MIB_coldStart);

	/*
	 * Send a coldStart to notify that the daemon has been
	 * started and re-initialized.
	 */
	trap_send(&trapoid, NULL);
}

int
trap_agentx(struct agentx_handle *h, struct agentx_pdu *pdu, int *idx,
    char **varcpy, int *vcpylen)
{
	struct agentx_varbind_hdr	 vbhdr;
	u_int32_t			 d;
	struct ber_oid			 o, oid;
	struct ber_oid			 uptime = OID(MIB_sysUpTime);
	struct ber_oid			 trapoid = OID(MIB_snmpTrapOID);
	struct ber_element		*varbind, *iter;
	int				 x = 0, state = 0;
	int				 ret = AGENTX_ERR_NONE;
	int				 seensysuptime, seentrapoid;
	size_t				 len = 0;
	pid_t				 pid = -1;
	char				*v = NULL;

	*varcpy = NULL;
	varbind = NULL;
	iter = NULL;
	seensysuptime = seentrapoid = 0;

	if (pdu->hdr->flags & AGENTX_NON_DEFAULT_CONTEXT) {
		ret = AGENTX_ERR_UNSUPPORTED_CONTEXT;
		goto done;
	}

	if ((v = malloc(pdu->hdr->length)) == NULL ||
	    snmp_agentx_copy_raw(pdu, v, pdu->hdr->length) == -1) {
		ret = AGENTX_ERR_PROCESSING_ERROR;
		goto done;
	}

	while (pdu->datalen > sizeof(struct agentx_hdr)) {
		x++;

		if (snmp_agentx_read_vbhdr(pdu, &vbhdr) == -1) {
			ret = AGENTX_ERR_PARSE_ERROR;
			goto done;
		}

		if (state < 2) {
			if (snmp_agentx_read_oid(pdu, (struct snmp_oid *)&oid) == -1) {
				ret = AGENTX_ERR_PARSE_ERROR;
				goto done;
			}
			if (state == 0 && ber_oid_cmp(&oid, &uptime) == 0) {
				if (snmp_agentx_read_int(pdu, &d) == -1) {
					ret = AGENTX_ERR_PARSE_ERROR;
					goto done;
				}
				state = 1;
				continue;
			} else if (ber_oid_cmp(&oid, &trapoid) == 0) {
				if (snmp_agentx_read_oid(pdu,
				    (struct snmp_oid *)&o) == -1) {
					ret = AGENTX_ERR_PARSE_ERROR;
					goto done;
				}
				state = 2;
				continue;
			} else {
				ret = AGENTX_ERR_PROCESSING_ERROR;
				goto done;
			}
		}

		ret = varbind_convert(pdu, &vbhdr, &varbind, &iter);
		if (ret != AGENTX_ERR_NONE)
			goto done;
	}

	if (varbind != NULL)
		len = ber_calc_len(varbind);
	log_debug("trap_agentx: from pid %u len %zd elements %d",
	    pid, len, x);

	trap_send(&o, varbind);

	*varcpy = v;
	*vcpylen = pdu->hdr->length;

	return (AGENTX_ERR_NONE);
 done:
	if (varbind != NULL)
		ber_free_elements(varbind);
	free(v);
	*idx = x;
	return (ret);
}

int
trap_send(struct ber_oid *oid, struct ber_element *elm)
{
	int			 ret = 0, s;
	struct address		*tr;
	struct ber_element	*root, *b, *c, *trap;
	struct ber		 ber;
	char			*cmn;
	ssize_t			 len;
	u_int8_t		*ptr;
	struct			 ber_oid uptime = OID(MIB_sysUpTime);
	struct			 ber_oid trapoid = OID(MIB_snmpTrapOID);
	char			 ostr[SNMP_MAX_OID_STRLEN];
	struct oid		 oa, ob;

	if (TAILQ_EMPTY(&snmpd_env->sc_trapreceivers))
		return (0);

	smi_scalar_oidlen(&uptime);
	smi_scalar_oidlen(&trapoid);
	smi_scalar_oidlen(oid);

	smi_oid2string(oid, ostr, sizeof(ostr), 0);
	log_debug("trap_send: oid %s", ostr);

	/* Setup OIDs to compare against the trap receiver MIB */
	bzero(&oa, sizeof(oa));
	bcopy(oid->bo_id, &oa.o_oid, sizeof(oa.o_oid));
	oa.o_oidlen = oid->bo_n;
	bzero(&ob, sizeof(ob));
	ob.o_flags = OID_TABLE;

	/* Add mandatory varbind elements */
	trap = ber_add_sequence(NULL);
	c = ber_printf_elements(trap, "{Odt}{OO}",
	    &uptime, smi_getticks(),
	    BER_CLASS_APPLICATION, SNMP_T_TIMETICKS,
	    &trapoid, oid);
	if (elm != NULL)
		ber_link_elements(c, elm);

	bzero(&ber, sizeof(ber));
	ber.fd = -1;

	TAILQ_FOREACH(tr, &snmpd_env->sc_trapreceivers, entry) {
		if (tr->sa_oid != NULL && tr->sa_oid->bo_n) {
			/* The trap receiver may want only a specified MIB */
			bcopy(&tr->sa_oid->bo_id, &ob.o_oid,
			    sizeof(ob.o_oid));
			ob.o_oidlen = tr->sa_oid->bo_n;
			if (smi_oid_cmp(&oa, &ob) != 0)
				continue;
		}

		if ((s = snmpd_socket_af(&tr->ss, htons(tr->port))) == -1) {
			ret = -1;
			goto done;
		}
		if (tr->sa_srcaddr != NULL) {
			if (bind(s, (struct sockaddr *)&tr->sa_srcaddr->ss,
			    tr->sa_srcaddr->ss.ss_len) == -1) {
				ret = -1;
				goto done;
			}
		}

		cmn = tr->sa_community != NULL ?
		    tr->sa_community : snmpd_env->sc_trcommunity;

		/* SNMP header */
		root = ber_add_sequence(NULL);
		b = ber_printf_elements(root, "ds{tddd",
		    SNMP_V2, cmn, BER_CLASS_CONTEXT, SNMP_C_TRAPV2,
		    arc4random(), 0, 0);
		ber_link_elements(b, trap);

#ifdef DEBUG
		smi_debug_elements(root);
#endif
		len = ber_write_elements(&ber, root);
		if (ber_get_writebuf(&ber, (void *)&ptr) > 0 &&
		    sendto(s, ptr, len, 0, (struct sockaddr *)&tr->ss,
		    tr->ss.ss_len) != -1) {
			snmpd_env->sc_stats.snmp_outpkts++;
			ret++;
		}

		close(s);
		ber_unlink_elements(b);
		ber_free_elements(root);
	}

 done:
	ber_free_elements(trap);
	ber_free(&ber);

	return (ret);
}
@


1.28
log
@Improve source IP address handling.

- send replies using a source address equal to the destination address
  of queries, using IP_SENDSRCADDR.  This help in multihomed setups and
  can remove the need to explicitely configure a bind address.
- config knob to set the source address of packets sent to trap
  receivers.  "trap receiver" gains an optional "source-address"
  setting.

Source address issues reported by Andy Lemin.  ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2016/10/28 08:01:53 rzalamena Exp $	*/
d73 1
@


1.27
log
@Use snmpd_env as the only global variable for env to simplify the daemon
and avoid problems.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2015/12/05 06:42:18 mmcc Exp $	*/
d201 7
@


1.26
log
@strings.h -> string.h to prevent an implicit declaration warning. Also
remove a handful of NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2015/11/21 13:09:47 reyk Exp $	*/
a41 2
extern struct snmpd	*env;

d159 1
a159 1
	if (TAILQ_EMPTY(&env->sc_trapreceivers))
d188 1
a188 1
	TAILQ_FOREACH(tr, &env->sc_trapreceivers, entry) {
d204 1
a204 1
		    tr->sa_community : env->sc_trcommunity;
d220 1
a220 1
			env->sc_stats.snmp_outpkts++;
@


1.25
log
@While here, fix two size format string warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2015/01/16 00:05:13 deraadt Exp $	*/
d141 1
a141 2
	if (v)
		free(v);
@


1.24
log
@first batch of cleanup to programs based upon the namespace cleanups
in net/pfvar.h sys/proc.h sys/ucred.h arpa/nameser.h
change to PATH_MAX, reduce use of MIN() and MAX(), HOST_NAME_MAX+1,
LOGIN_NAME_MAX, etc etc
ok millert guenther, some review by doug
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2014/11/19 10:19:00 blambert Exp $	*/
d129 1
a129 1
	log_debug("trap_agentx: from pid %u len %d elements %d",
@


1.23
log
@add support for AgentX subagents in snmpd

snmp requests are now packaged into pseudo-continuations
to allow for being dispatched to seperate processes;
lightly tested for interoperability with NetSNMP, but
doesn't implement the complete set of AgentX messages

while here, clean up return types of mps_get* functions,
and make smi_insert refuse to insert duplicate OIDs

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2014/04/14 12:55:10 blambert Exp $	*/
a19 1
#include <sys/param.h>
@


1.22
log
@Make snmpd use the AgentX protcol for accepting trap requests.
AgentX notifications are the only portion implemented right now;
get in the tree to flesh out the remainder.

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2013/10/19 14:18:39 blambert Exp $	*/
d62 1
d66 1
a66 5
	u_int32_t			 d;
	u_int64_t			 l;
	char				*str;
	int				 slen;
	struct ber_element		*a, *ber, *varbind;
d75 1
a75 1
	ber = varbind = NULL;
d92 1
a92 2
		if (snmp_agentx_read_vbhdr(pdu, &vbhdr) == -1 ||
		    snmp_agentx_read_oid(pdu, (struct snmp_oid *)&oid) == -1) {
d96 1
d98 4
d123 2
a124 56
		ber = ber_add_sequence(ber);
		if (varbind == NULL)
		varbind = ber;

		a = ber_add_oid(ber, &oid);

		switch (vbhdr.type) {
		case AGENTX_NO_SUCH_OBJECT:
		case AGENTX_NO_SUCH_INSTANCE:
		case AGENTX_END_OF_MIB_VIEW:
		case AGENTX_NULL:
			a = ber_add_null(a);
			break;

		case AGENTX_IP_ADDRESS:
		case AGENTX_OPAQUE:
		case AGENTX_OCTET_STRING:
			str = snmp_agentx_read_octetstr(pdu, &slen);
			if (str == NULL) {
				ret = AGENTX_ERR_PARSE_ERROR;
				goto done;
			}
			a = ber_add_nstring(a, str, slen);
			break;

		case AGENTX_OBJECT_IDENTIFIER:
			if (snmp_agentx_read_oid(pdu,
			    (struct snmp_oid *)&oid) == -1) {
				ret = AGENTX_ERR_PARSE_ERROR;
				goto done;
			}
			a = ber_add_oid(a, &oid);
			break;

		case AGENTX_INTEGER:
		case AGENTX_COUNTER32:
		case AGENTX_GAUGE32:
		case AGENTX_TIME_TICKS:
			if (snmp_agentx_read_int(pdu, &d) == -1) {
				ret = AGENTX_ERR_PARSE_ERROR;
				goto done;
			}
			a = ber_add_integer(a, d);
			break;

		case AGENTX_COUNTER64:
			if (snmp_agentx_read_int64(pdu, &l) == -1) {
				ret = AGENTX_ERR_PARSE_ERROR;
				goto done;
			}
			a = ber_add_integer(a, l);
			break;

		default:
			log_debug("unknown data type '%i'", vbhdr.type);
			ret = AGENTX_ERR_PARSE_ERROR;
a125 16
		}

		/* AgentX types correspond to BER types */
		switch (vbhdr.type) {
		case BER_TYPE_INTEGER:
		case BER_TYPE_BITSTRING:
		case BER_TYPE_OCTETSTRING:
		case BER_TYPE_NULL:
		case BER_TYPE_OBJECT:
			/* universal types */
			break;
		default:
			/* application-specific types */
			ber_set_header(a, BER_CLASS_APPLICATION, vbhdr.type);
			break;
		}
@


1.21
log
@Fix receipt of OID varbinds when sending traps

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2013/10/01 12:41:48 reyk Exp $	*/
d58 2
a59 1
trap_imsg(struct imsgev *iev, pid_t pid)
d61 30
a90 20
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	int			 ret = -1, n, x = 0, state = 0;
	int			 done = 0;
	struct snmp_imsg	*sm;
	u_int32_t		 d;
	u_int64_t		 l;
	u_int8_t		*c;
	char			 ostr[SNMP_MAX_OID_LEN];
	struct ber_element	*ber = NULL, *varbind = NULL, *a;
	size_t			 len = 0;
	struct			 ber_oid o;

	ibuf = &iev->ibuf;
	while (!done) {
		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				goto done;
			if (n == 0)
				break;
d92 2
a93 15
			switch (imsg.hdr.type) {
			case IMSG_SNMP_ELEMENT:
				if (imsg.hdr.len < (IMSG_HEADER_SIZE +
				    sizeof(struct snmp_imsg)))
					goto imsgdone;

				sm = (struct snmp_imsg *)imsg.data;

				if (!state++) {
					/* First element must be the trap OID */
					if (sm->snmp_type != SNMP_NULL)
						goto imsgdone;
					ber_string2oid(sm->snmp_oid, &o);
					break;
				}
d95 10
a104 54
				ber = ber_add_sequence(ber);
				if (varbind == NULL)
					varbind = ber;
				a = ber_add_oidstring(ber, sm->snmp_oid);

				switch (sm->snmp_type) {
				case SNMP_OBJECT:
					if (sm->snmp_len > sizeof(ostr) - 1)
						goto imsgdone;
					bzero(&ostr, sizeof(ostr));
					bcopy(sm + 1, &ostr, sm->snmp_len);
					a = ber_add_oidstring(a, ostr);
					break;
				case SNMP_BITSTRING:
					if (sm->snmp_len < 1)
						goto imsgdone;
					/* FALLTHROUGH */
				case SNMP_OCTETSTRING:
				case SNMP_IPADDR:
					if (sm->snmp_len >= SNMPD_MAXSTRLEN)
						goto imsgdone;
					c = (u_int8_t *)(sm + 1);
					if (sm->snmp_type == SNMP_BITSTRING)
						a = ber_add_bitstring(a, c,
						    sm->snmp_len);
					else
						a = ber_add_nstring(a, c,
						    sm->snmp_len);
					break;
				case SNMP_NULL:
					a = ber_add_null(a);
					break;
				case SNMP_INTEGER32:
				case SNMP_COUNTER32:
				case SNMP_GAUGE32:
				case SNMP_TIMETICKS:
				case SNMP_OPAQUE:
				case SNMP_UINTEGER32:
					if (sm->snmp_len != sizeof(d))
						goto imsgdone;
					bcopy(sm + 1, &d, sm->snmp_len);
					a = ber_add_integer(a, d);
					break;
				case SNMP_COUNTER64:
					if (sm->snmp_len != sizeof(l))
						goto imsgdone;
					bcopy(sm + 1, &l, sm->snmp_len);
					a = ber_add_integer(a, l);
					break;
				default:
					log_debug("trap_imsg: illegal type %d",
					    sm->snmp_type);
					imsg_free(&imsg);
					goto imsgdone;
d106 7
a112 13
				switch (sm->snmp_type) {
				case SNMP_INTEGER32:
				case SNMP_BITSTRING:
				case SNMP_OCTETSTRING:
				case SNMP_NULL:
				case SNMP_OBJECT:
					/* universal types */
					break;
				default:
					/* application-specific types */
					ber_set_header(a, BER_CLASS_APPLICATION,
					    sm->snmp_type);
					break;
d114 5
a118 9
				x++;
				break;
			case IMSG_SNMP_END:
				done = 1;
				break;
			default:
				log_debug("trap_imsg: illegal imsg %d",
				    imsg.hdr.type);
				goto imsgdone;
a119 1
			imsg_free(&imsg);
d121 33
a153 1
		if (done)
d155 23
a177 3
		if ((n = imsg_read(ibuf)) == -1)
			goto done;
		if (n == 0)
d179 16
d199 1
a199 1
	log_debug("trap_imsg: from pid %u len %d elements %d",
d201 1
a202 1
	return (0);
d204 4
a207 2
 imsgdone:
	imsg_free(&imsg);
d211 3
d229 1
a229 1
	char			 ostr[SNMP_MAX_OID_LEN];
a288 1

@


1.20
log
@Add initial SNMP client utility to snmpctl(8).
For example, snmpctl snmp walk 127.0.0.1

commit it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2013/09/26 09:11:30 reyk Exp $	*/
d104 1
a104 1
					if (sm->snmp_len != sizeof(ostr))
d106 1
@


1.19
log
@shuffle some snmpd functions to make them visible in smi.c for snmpctl.

ok gerhard@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2013/09/11 14:58:01 blambert Exp $	*/
d222 1
a222 1
	smi_oidstring(oid, ostr, sizeof(ostr));
@


1.18
log
@According to ITU X.690 (ASN.1 definition document), "octet strings"
and derived types are allowed to have 0 content octets, whereas
"bitstrings" are required to have at least 1 content octet. Adjust
the checks in the trap acceptance code to allow for 0-length "octet
strings" in SNMP traps.

okay reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2012/09/17 16:43:59 reyk Exp $	*/
d270 1
a270 1
		snmpe_debug_elements(root);
@


1.17
log
@Update copyright and my email address in snmpd while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2012/02/01 18:44:06 camield Exp $	*/
d110 3
d115 1
a115 2
					if ((sm->snmp_len < 1) ||
					    (sm->snmp_len >= SNMPD_MAXSTRLEN))
@


1.16
log
@Variable bindings need instance identifiers, for scalars this is always .0.
At least NetSNMP and HPOV now understand it.

ok joel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2011/03/16 15:30:35 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Reyk Floeter <reyk@@vantronix.net>
@


1.15
log
@fix trap sending in snmpd by adjusting snmpctl to the imsg libutil
change and fixing the ber element handling in snmpd itself.

tested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 2009/06/06 05:52:01 pyr Exp $	*/
d216 3
a218 3
	smi_oidlen(&uptime);
	smi_oidlen(&trapoid);
	smi_oidlen(oid);
@


1.14
log
@sync snmpd with the common imsg code, making it lib ready as well.
ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 2008/10/09 14:14:40 reyk Exp $	*/
d188 1
a189 1
	ret = 0;
d191 1
a191 2
	if (ret != 0)
		imsg_free(&imsg);
a284 2
	if (elm != NULL)
		ber_unlink_elements(c);
@


1.13
log
@plug memleak by calling ber_free() after sending a trap to cleanup the
BER write buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 2008/03/18 16:57:58 reyk Exp $	*/
d58 1
a58 1
trap_imsg(struct imsgbuf *ibuf, pid_t pid)
d60 1
d73 1
@


1.12
log
@remove ber_add_astring and make it the default behaviour in
ber_add_string, ber_add_nstring, and ber_add_bitstring to allocate and
copy the provided buffer instead of just attaching it to the ber
element.  this may add some overhead but fixes and avoids some bugs
with static buffers and simplifies the ber api again.

From Matthew at Dempsky dot org
With input from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 2008/02/08 12:36:47 reyk Exp $	*/
d287 1
@


1.11
log
@use correct variable for COUNTER64
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 2008/01/24 06:36:51 reyk Exp $	*/
d113 1
a113 4
					if ((c =
					    calloc(1, sm->snmp_len)) == NULL)
						goto imsgdone;
					bcopy(sm + 1, c, sm->snmp_len);
a119 1
					a->be_free = 1;
@


1.10
log
@timeticks type
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 2008/01/18 13:04:28 reyk Exp $	*/
d78 1
d143 1
a143 1
					a = ber_add_integer(a, d);
@


1.9
log
@trap.c
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 2008/01/18 02:09:30 reyk Exp $	*/
d234 1
a234 1
	c = ber_printf_elements(trap, "{Oit}{OO}",
@


1.8
log
@add a snmpctl command to send traps to registered receivers using
snmpd's imsg trap interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 2008/01/17 17:35:06 reyk Exp $	*/
d108 1
a127 1
				case SNMP_IPADDR:
@


1.7
log
@swap arguments
@
text
@@


1.6
log
@the optional trap varbind elements may be null
@
text
@d187 1
a187 1
	    pid, x, len);
@


1.5
log
@allow to configure optional per trap receiver communities and to
restrict the receivers to a specified mib.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 2008/01/16 21:43:19 reyk Exp $	*/
d69 1
a69 1
	size_t			 len;
d184 4
a187 3
	len = ber_calc_len(varbind);
	log_debug("trap_imsg: from pid %u, len %d", pid, len);

@


1.4
log
@send a coldStart trap to registered receivers on startup and cleanup
the trap code a little bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.3 2008/01/16 19:36:06 reyk Exp $	*/
d212 1
d221 11
a242 3
	smi_oidstring(oid, ostr, sizeof(ostr));
	log_debug("trap_send: oid %s", ostr);

d244 8
a251 2
		if (tr->sa_oid != NULL && tr->sa_oid->bo_n)
			/* XXX only send if the OID is specified */;
@


1.3
log
@implementation of the SNMP trap sender interface
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.2 2008/01/16 09:45:17 reyk Exp $	*/
d45 12
d61 1
a61 1
	int			 ret = -1, n, x = 0;
d68 1
a68 1
	struct ber_element	*ber, *trap = NULL, *oid = NULL, *a;
a70 8
	struct			 ber_oid uptime = OID(MIB_sysUpTime);
	struct			 ber_oid trapoid = OID(MIB_snmpTrapOID);

	bzero(&o, sizeof(o));
	smi_oidlen(&uptime);
	ber = trap = ber_printf_elements(NULL, "{{Oit}",
	    &uptime, smi_getticks(),
	    BER_CLASS_APPLICATION, SNMP_T_TIMETICKS);
d86 1
a86 1
				if (oid == NULL) {
a90 3
					smi_oidlen(&trapoid);
					ber = oid = ber_printf_elements(ber,
					    "{OO}", &trapoid, &o);
d94 4
a97 2
				ber = a = ber_add_sequence(ber);
				a = ber_add_oidstring(a, sm->snmp_oid);
d145 1
a145 1
					log_debug("snmpe_trap: illegal type %d",
d170 1
a170 1
				log_debug("snmpe_trap: illegal imsg %d",
d184 2
a185 3
	len = ber_calc_len(trap);
	smi_oidstring(&o, ostr, sizeof(ostr));
	log_debug("trap_imsg: %s, len %d, pid %d", ostr, len, pid);
d187 1
a187 1
	trap_send(trap, &o);
d194 2
a195 1
	ber_free_elements(trap);
d200 1
a200 1
trap_send(struct ber_element *trap, struct ber_oid *oid)
d202 10
a211 7
	int				 ok = 0, s;
	struct address			*tr;
	struct ber_element		*root, *b;
	struct ber			 ber;
	char				*c;
	ssize_t				 len;
	u_int8_t			*ptr;
d216 12
d231 3
d238 4
a241 2
		if ((s = snmpd_socket_af(&tr->ss, htons(tr->port))) == -1)
			return (-1);
d243 1
a243 1
		c = tr->sa_community != NULL ?
d248 2
a249 2
		b = ber_printf_elements(root, "ds{tiii",
		    SNMP_V2, c, BER_CLASS_CONTEXT, SNMP_C_TRAPV2,
d260 1
a260 1
		    tr->ss.ss_len) != -1)
d262 2
d270 6
a275 1
	return (ok);
@


1.2
log
@tweak
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.1 2008/01/16 09:42:29 reyk Exp $	*/
d41 3
d46 1
a46 1
trap_request(struct imsgbuf *ibuf, pid_t pid)
d48 3
a50 3
	struct imsg	 	 imsg;
	int		 	 ret = -1, n, x = 0;
	int		 	 done = 0;
d52 2
a53 2
	u_int32_t	 	 d;
	u_int64_t	 	 l;
d55 1
a55 1
	char			 o[SNMP_MAX_OID_LEN];
d58 9
a66 2

	ber = trap = ber_add_sequence(NULL);
d86 2
d89 1
a89 1
					    "{o0}", sm->snmp_oid);
d98 1
a98 1
					if (sm->snmp_len != sizeof(o))
d100 2
a101 2
					bcopy(sm + 1, &o, sm->snmp_len);
					a = ber_add_oidstring(a, o);
d182 2
a183 1
	log_debug("snmpe_trap: %d bytes from pid %d", len, pid);
d185 1
a185 5
#ifdef DEBUG
	snmpe_debug_elements(trap);
#endif

	/* XXX send trap to registered receivers */
d194 52
@


1.1
log
@move trap code to an own file; there will be more
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d143 1
a143 8
				case SNMP_IPADDR:
				case SNMP_COUNTER32:
				case SNMP_GAUGE32:
				case SNMP_TIMETICKS:
				case SNMP_OPAQUE:
				case SNMP_NSAPADDR:
				case SNMP_COUNTER64:
				case SNMP_UINTEGER32:
a171 2
	/* XXX send trap to registered receivers */

d175 2
@

