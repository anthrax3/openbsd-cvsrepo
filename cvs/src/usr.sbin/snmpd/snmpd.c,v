head	1.36;
access;
symbols
	OPENBSD_6_1:1.35.0.4
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.12
	OPENBSD_5_0:1.9.0.10
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.8
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.6
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5;
locks; strict;
comment	@ * @;


1.36
date	2017.04.04.02.37.15;	author millert;	state Exp;
branches;
next	1.35;
commitid	INN48qyWBGuLvtXZ;

1.35
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.34;
commitid	eA8b246voAapPTkX;

1.34
date	2016.10.28.09.07.08;	author rzalamena;	state Exp;
branches;
next	1.33;
commitid	Uh6U1yLTyYRsvccR;

1.33
date	2016.08.16.18.41.57;	author tedu;	state Exp;
branches;
next	1.32;
commitid	eyeRGwF24702KeRh;

1.32
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.31;
commitid	LQHdRRMF0nq0fugE;

1.31
date	2015.11.23.19.31.52;	author reyk;	state Exp;
branches;
next	1.30;
commitid	7cxebI3ghebF4Szu;

1.30
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.29;
commitid	T3JBYxNT0thPuavp;

1.29
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.28;
commitid	GouatFiJVxwlAVIQ;

1.28
date	2015.05.28.17.08.09;	author florian;	state Exp;
branches;
next	1.27;
commitid	CuYEPULhoEPTPxJv;

1.27
date	2015.02.08.23.28.48;	author tedu;	state Exp;
branches;
next	1.26;
commitid	NcYq5qd3mDexpuG1;

1.26
date	2015.02.08.23.07.49;	author tedu;	state Exp;
branches;
next	1.25;
commitid	20zrpd2ayr2YKJKx;

1.25
date	2015.01.16.00.05.13;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	khLbW7SmDyckNaAs;

1.24
date	2014.08.18.13.13.42;	author reyk;	state Exp;
branches;
next	1.23;
commitid	SoP35sFKzkBxNqzm;

1.23
date	2014.05.23.18.37.20;	author benno;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.28.08.25.05;	author blambert;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.25.06.57.11;	author blambert;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.21.19.47.27;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2014.03.16.18.38.30;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2013.10.17.08.42.44;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2013.10.16.21.15.33;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.16.16.05.03;	author blambert;	state Exp;
branches;
next	1.15;

1.15
date	2012.11.29.14.53.24;	author yasuoka;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.18.08.29.09;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2012.09.17.16.43.59;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2012.09.17.16.30.35;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2012.05.28.20.55.40;	author joel;	state Exp;
branches;
next	1.10;

1.10
date	2012.02.23.03.54.38;	author joel;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.06.05.52.01;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.26.15.19.55;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.16.00.14.47;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.16.22.06.10;	author sobrado;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.16.19.36.06;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.16.09.51.15;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.28.16.59.31;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.05.09.22.44;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Rewrite tohexstr() to use the common idiom of converting a byte
string to hex nybble by nybble.  This avoids using the return value
of snprintf() unchecked.  OK deraadt@@
@
text
@/*	$OpenBSD: snmpd.c,v 1.35 2017/01/09 14:49:22 reyk Exp $	*/

/*
 * Copyright (c) 2007, 2008, 2012 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/tree.h>

#include <net/if.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <signal.h>
#include <syslog.h>
#include <unistd.h>
#include <fcntl.h>
#include <pwd.h>

#include "snmpd.h"
#include "mib.h"

__dead void	 usage(void);

void	 snmpd_shutdown(struct snmpd *);
void	 snmpd_sig_handler(int, short, void *);
int	 snmpd_dispatch_snmpe(int, struct privsep_proc *, struct imsg *);
void	 snmpd_generate_engineid(struct snmpd *);
int	 check_child(pid_t, const char *);

struct snmpd	*snmpd_env;

static struct privsep_proc procs[] = {
	{ "snmpe", PROC_SNMPE, snmpd_dispatch_snmpe, snmpe, snmpe_shutdown },
	{ "traphandler", PROC_TRAP, snmpd_dispatch_traphandler, traphandler,
	    traphandler_shutdown }
};

void
snmpd_sig_handler(int sig, short event, void *arg)
{
	struct privsep	*ps = arg;
	struct snmpd	*env = ps->ps_env;
	int		 die = 0, status, fail, id;
	pid_t		pid;
	char		*cause;

	switch (sig) {
	case SIGTERM:
	case SIGINT:
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		do {
			int len;

			pid = waitpid(WAIT_ANY, &status, WNOHANG);
			if (pid <= 0)
				continue;

			fail = 0;
			if (WIFSIGNALED(status)) {
				fail = 1;
				len = asprintf(&cause, "terminated; signal %d",
				    WTERMSIG(status));
			} else if (WIFEXITED(status)) {
				if (WEXITSTATUS(status) != 0) {
					fail = 1;
					len = asprintf(&cause,
					    "exited abnormally");
				} else
					len = asprintf(&cause, "exited okay");
			} else
				fatalx("unexpected cause of SIGCHLD");

			if (len == -1)
				fatal("asprintf");
			
			for (id = 0; id < PROC_MAX; id++) {
				if (pid == ps->ps_pid[id] &&
				    check_child(ps->ps_pid[id],
				    ps->ps_title[id])) {
					die  = 1;
					if (fail)
						log_warnx("lost child: %s %s",
						    ps->ps_title[id], cause);
					break;
				}
			}
			free(cause);
		} while (pid > 0 || (pid == -1 && errno == EINTR));

		if (die)
			snmpd_shutdown(env);
		break;
	case SIGHUP:
		/* reconfigure */
		break;
	case SIGUSR1:
		/* ignore */
		break;
	default:
		fatalx("unexpected signal");
	}
}

__dead void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr, "usage: %s [-dNnv] [-D macro=value] "
	    "[-f file]\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int		 c;
	struct snmpd	*env;
	int		 debug = 0, verbose = 0;
	u_int		 flags = 0;
	int		 noaction = 0;
	const char	*conffile = CONF_FILE;
	struct privsep	*ps;
	int		 proc_id = PROC_PARENT, proc_instance = 0;
	int		 argc0 = argc;
	char		**argv0 = argv;
	const char	*errp, *title = NULL;

	smi_init();

	/* log to stderr until daemonized */
	log_init(1, LOG_DAEMON);

	while ((c = getopt(argc, argv, "dD:nNf:I:P:v")) != -1) {
		switch (c) {
		case 'd':
			debug++;
			flags |= SNMPD_F_DEBUG;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'n':
			noaction = 1;
			break;
		case 'N':
			flags |= SNMPD_F_NONAMES;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'I':
			proc_instance = strtonum(optarg, 0,
			    PROC_MAX_INSTANCES, &errp);
			if (errp)
				fatalx("invalid process instance");
			break;
		case 'P':
			title = optarg;
			proc_id = proc_getid(procs, nitems(procs), title);
			if (proc_id == PROC_MAX)
				fatalx("invalid process name");
			break;
		case 'v':
			verbose++;
			flags |= SNMPD_F_VERBOSE;
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	if ((env = parse_config(conffile, flags)) == NULL)
		exit(1);

	ps = &env->sc_ps;
	ps->ps_env = env;
	snmpd_env = env;
	ps->ps_instance = proc_instance;
	if (title)
		ps->ps_title[proc_id] = title;

	if (noaction) {
		fprintf(stderr, "configuration ok\n");
		exit(0);
	}

	if (geteuid())
		errx(1, "need root privileges");

	if ((ps->ps_pw = getpwnam(SNMPD_USER)) == NULL)
		errx(1, "unknown user %s", SNMPD_USER);

	log_init(debug, LOG_DAEMON);
	log_setverbose(verbose);

	gettimeofday(&env->sc_starttime, NULL);
	env->sc_engine_boots = 0;

	pf_init();
	snmpd_generate_engineid(env);

	proc_init(ps, procs, nitems(procs), argc0, argv0, proc_id);
	if (!debug && daemon(0, 0) == -1)
		err(1, "failed to daemonize");

	log_procinit("parent");
	log_info("startup");

	event_init();

	signal_set(&ps->ps_evsigint, SIGINT, snmpd_sig_handler, ps);
	signal_set(&ps->ps_evsigterm, SIGTERM, snmpd_sig_handler, ps);
	signal_set(&ps->ps_evsigchld, SIGCHLD, snmpd_sig_handler, ps);
	signal_set(&ps->ps_evsighup, SIGHUP, snmpd_sig_handler, ps);
	signal_set(&ps->ps_evsigpipe, SIGPIPE, snmpd_sig_handler, ps);
	signal_set(&ps->ps_evsigusr1, SIGUSR1, snmpd_sig_handler, ps);

	signal_add(&ps->ps_evsigint, NULL);
	signal_add(&ps->ps_evsigterm, NULL);
	signal_add(&ps->ps_evsigchld, NULL);
	signal_add(&ps->ps_evsighup, NULL);
	signal_add(&ps->ps_evsigpipe, NULL);
	signal_add(&ps->ps_evsigusr1, NULL);

	proc_connect(ps);

	event_dispatch();

	log_debug("%d parent exiting", getpid());

	return (0);
}

void
snmpd_shutdown(struct snmpd *env)
{
	proc_kill(&env->sc_ps);

	if (env->sc_ps.ps_csock.cs_name != NULL)
		(void)unlink(env->sc_ps.ps_csock.cs_name);

	free(env);

	log_info("terminating");
	exit(0);
}

int
check_child(pid_t pid, const char *pname)
{
	int	status;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("check_child: lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("check_child: lost child: %s terminated; "
			    "signal %d", pname, WTERMSIG(status));
			return (1);
		}
	}

	return (0);
}

int
snmpd_dispatch_snmpe(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	switch (imsg->hdr.type) {
	case IMSG_CTL_RELOAD:
		/* XXX notyet */
	default:
		break;
	}

	return (-1);
}

int
snmpd_socket_af(struct sockaddr_storage *ss, in_port_t port)
{
	int	 s;

	switch (ss->ss_family) {
	case AF_INET:
		((struct sockaddr_in *)ss)->sin_port = port;
		((struct sockaddr_in *)ss)->sin_len =
		    sizeof(struct sockaddr_in);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)ss)->sin6_port = port;
		((struct sockaddr_in6 *)ss)->sin6_len =
		    sizeof(struct sockaddr_in6);
		break;
	default:
		return (-1);
	}

	s = socket(ss->ss_family, SOCK_DGRAM, IPPROTO_UDP);
	return (s);
}

void
snmpd_generate_engineid(struct snmpd *env)
{
	u_int32_t		 oid_enterprise, rnd, tim;

	/* RFC 3411 */
	memset(env->sc_engineid, 0, sizeof(env->sc_engineid));
	oid_enterprise = htonl(OIDVAL_openBSD_eid);
	memcpy(env->sc_engineid, &oid_enterprise, sizeof(oid_enterprise));
	env->sc_engineid[0] |= SNMP_ENGINEID_NEW;
	env->sc_engineid_len = sizeof(oid_enterprise);

	/* XXX alternatively configure engine id via snmpd.conf */
	env->sc_engineid[(env->sc_engineid_len)++] = SNMP_ENGINEID_FMT_EID;
	rnd = arc4random();
	memcpy(&env->sc_engineid[env->sc_engineid_len], &rnd, sizeof(rnd));
	env->sc_engineid_len += sizeof(rnd);

	tim = htonl(env->sc_starttime.tv_sec);
	memcpy(&env->sc_engineid[env->sc_engineid_len], &tim, sizeof(tim));
	env->sc_engineid_len += sizeof(tim);
}

u_long
snmpd_engine_time(void)
{
	struct timeval	 now;

	/*
	 * snmpEngineBoots should be stored in a non-volatile storage.
	 * snmpEngineTime is the number of seconds since snmpEngineBoots
	 * was last incremented. We don't rely on non-volatile storage.
	 * snmpEngineBoots is set to zero and snmpEngineTime to the system
	 * clock. Hence, the tuple (snmpEngineBoots, snmpEngineTime) is
	 * still unique and protects us against replay attacks. It only
	 * 'expires' a little bit sooner than the RFC3414 method.
	 */
	gettimeofday(&now, NULL);
	return now.tv_sec;
}

char *
tohexstr(u_int8_t *bstr, int len)
{
#define MAXHEXSTRLEN		256
	static char hstr[2 * MAXHEXSTRLEN + 1];
	static const char hex[] = "0123456789abcdef";
	int i;

	if (len > MAXHEXSTRLEN)
		len = MAXHEXSTRLEN;	/* truncate */
	for (i = 0; i < len; i++) {
		hstr[i + i] = hex[bstr[i] >> 4];
		hstr[i + i + 1] = hex[bstr[i] & 0x0f];
	}
	hstr[i + i] = '\0';
	return hstr;
}
@


1.35
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.34 2016/10/28 09:07:08 rzalamena Exp $	*/
d378 1
a378 1
tohexstr(u_int8_t *str, int len)
d382 2
a383 1
	char *r = hstr;
d387 5
a391 3
	while (len-- > 0)
		r += snprintf(r, len * 2, "%0*x", 2, *str++);
	*r = '\0';
@


1.34
log
@Sync snmpd(8) with other daemons proc.c and teach him how to fork+exec.

ok jca@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.33 2016/08/16 18:41:57 tedu Exp $	*/
d161 1
d225 1
a225 1
	log_verbose(verbose);
@


1.33
log
@stop including sys/param.h for nitems. define locally as needed.
ok natano reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.32 2016/02/02 17:51:11 sthen Exp $	*/
d147 4
d157 1
a157 1
	while ((c = getopt(argc, argv, "dD:nNf:v")) != -1) {
d176 12
d208 3
a225 3
	if (!debug && daemon(0, 0) == -1)
		err(1, "failed to daemonize");

d232 3
a234 2
	ps->ps_ninstances = 1;
	proc_init(ps, procs, nitems(procs));
d255 1
a255 1
	proc_listen(ps, procs, nitems(procs));
@


1.32
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.31 2015/11/23 19:31:52 reyk Exp $	*/
a18 1
#include <sys/param.h>	/* nitems */ 
@


1.31
log
@Use SOCK_NONBLOCK to replace socket_set_blockmode() and fcntl(..O_NONBLOCK).
(SOCK_CLOEXEC should also be added where it is appropriate, but this is OBnot
done in this commit yet.)

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.30 2015/11/22 13:27:13 reyk Exp $	*/
a219 1
	setproctitle("parent");
a220 1

@


1.30
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.29 2015/06/03 02:24:36 millert Exp $	*/
a374 17
}

void
socket_set_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
@


1.29
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.28 2015/05/28 17:08:09 florian Exp $	*/
d36 1
d150 3
a152 1
	log_init(1);	/* log to stderr until daemonized */
d205 1
a205 1
	log_init(debug);
d221 2
@


1.28
log
@Do not try to unlink the control socket in an unprivileged child
process on shutdown.
Found while working on tame(2).
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.27 2015/02/08 23:28:48 tedu Exp $	*/
d75 2
d84 1
a84 1
				asprintf(&cause, "terminated; signal %d",
d89 2
a90 1
					asprintf(&cause, "exited abnormally");
d92 1
a92 1
					asprintf(&cause, "exited okay");
d95 3
@


1.27
log
@revert debug changes. reyk would like debug to remain a counter.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.26 2015/02/08 23:07:49 tedu Exp $	*/
d243 3
@


1.26
log
@flags should be flags, not counters. from martijn van duren
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.25 2015/01/16 00:05:13 deraadt Exp $	*/
d148 1
a148 1
			debug = 1;
@


1.25
log
@first batch of cleanup to programs based upon the namespace cleanups
in net/pfvar.h sys/proc.h sys/ucred.h arpa/nameser.h
change to PATH_MAX, reduce use of MIN() and MAX(), HOST_NAME_MAX+1,
LOGIN_NAME_MAX, etc etc
ok millert guenther, some review by doug
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.24 2014/08/18 13:13:42 reyk Exp $	*/
d148 1
a148 1
			debug++;
d156 1
a156 1
			noaction++;
@


1.24
log
@Sync proc.c with httpd.  httpd needs SIGUSR1 but snmpd will ignore it
now instead of terminating the process.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.23 2014/05/23 18:37:20 benno Exp $	*/
d19 1
a22 1
#include <sys/param.h>
@


1.23
log
@clean up after the traphandler children, otherwise they will live on
as zombies. ok blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.22 2014/04/28 08:25:05 blambert Exp $	*/
d113 3
d221 1
d228 1
@


1.22
log
@better proc id name (it handles traps, not alerts) for the
snmp trap handler
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.21 2014/04/25 06:57:11 blambert Exp $	*/
d64 3
a66 1
	int		 die = 0, id;
d74 33
a106 5
		for (id = 0; id < PROC_MAX; id++) {
			if (check_child(ps->ps_pid[id],
			    ps->ps_title[id]))
				die  = 1;
		}
@


1.21
log
@Support running user-defined actions on receipt of snmp traps.

testing sthen@@
much man page guidance jmc@@
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.20 2014/04/21 19:47:27 reyk Exp $	*/
d55 1
a55 1
	{ "traphandler", PROC_ALERT, snmpd_dispatch_traphandler, traphandler,
@


1.20
log
@Copy the updated proc.c from relayd to use the same file.  Adjust
snmpd accordingly.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.19 2014/03/16 18:38:30 guenther Exp $	*/
d54 3
a56 1
	{ "snmpe", PROC_SNMPE, snmpd_dispatch_snmpe, snmpe, snmpe_shutdown }
@


1.19
log
@lint is dead (long live the lint!), so stop using it as a cpp conditional
(namespace pollution!) or talking about its opinion on code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.18 2013/10/17 08:42:44 reyk Exp $	*/
d173 1
d193 1
a193 1
	proc_config(ps, procs, nitems(procs));
@


1.18
log
@Update snmpd(8) to use the proc.c privsep style from iked and relayd.

ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.17 2013/10/16 21:15:33 jmc Exp $	*/
a85 1
/* __dead is for lint */
@


1.17
log
@no more -r; ok blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.16 2013/10/16 16:05:03 blambert Exp $	*/
d37 1
d45 5
a49 5
void		 snmpd_sig_handler(int, short, void *);
void		 snmpd_shutdown(struct snmpd *);
void		 snmpd_dispatch_snmpe(int, short, void *);
int		 check_child(pid_t, const char *);
void		 snmpd_generate_engineid(struct snmpd *);
d53 3
a55 3
int		 pipe_parent2snmpe[2];
struct imsgev	*iev_snmpe;
pid_t		 snmpe_pid = 0;
d60 3
a62 2
	struct snmpd	*env = arg;
	int			 die = 0;
d70 4
a73 3
		if (check_child(snmpe_pid, "snmp engine")) {
			snmpe_pid = 0;
			die  = 1;
d100 7
a106 10
	int			 c;
	struct snmpd		*env;
	struct event		 ev_sigint;
	struct event		 ev_sigterm;
	struct event		 ev_sigchld;
	struct event		 ev_sighup;
	int			 debug = 0;
	u_int			 flags = 0;
	int			 noaction = 0;
	const char		*conffile = CONF_FILE;
a108 1

d114 1
a114 1
			debug = 1;
d131 1
d146 3
d159 1
a159 1
	if (getpwnam(SNMPD_USER) == NULL)
d163 1
d165 2
a166 4
	if (!debug) {
		if (daemon(1, 0) == -1)
			err(1, "failed to daemonize");
	}
a170 2
	log_info("startup");

d172 1
d174 1
a174 8
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_parent2snmpe) == -1)
		fatal("socketpair");

	session_socket_blockmode(pipe_parent2snmpe[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2snmpe[1], BM_NONBLOCK);

	snmpd_generate_engineid(env);
a175 1
	snmpe_pid = snmpe(env, pipe_parent2snmpe);
d177 1
d181 13
a193 23
	signal_set(&ev_sigint, SIGINT, snmpd_sig_handler, env);
	signal_set(&ev_sigterm, SIGTERM, snmpd_sig_handler, env);
	signal_set(&ev_sigchld, SIGCHLD, snmpd_sig_handler, env);
	signal_set(&ev_sighup, SIGHUP, snmpd_sig_handler, env);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sigchld, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);

	close(pipe_parent2snmpe[1]);

	if ((iev_snmpe = calloc(1, sizeof(struct imsgev))) == NULL)
		fatal(NULL);

	imsg_init(&iev_snmpe->ibuf, pipe_parent2snmpe[0]);
	iev_snmpe->handler = snmpd_dispatch_snmpe;
	iev_snmpe->data = iev_snmpe;

	iev_snmpe->events = EV_READ;
	event_set(&iev_snmpe->ev, iev_snmpe->ibuf.fd, iev_snmpe->events,
	    iev_snmpe->handler, iev_snmpe);
	event_add(&iev_snmpe->ev, NULL);
d197 2
d205 1
a205 2
	struct control_sock *rcs;
	pid_t	pid;
d207 1
a207 2
	if (snmpe_pid)
		kill(snmpe_pid, SIGTERM);
a208 12
	do {
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	control_cleanup(&env->sc_csock);
	while ((rcs = TAILQ_FIRST(&env->sc_rcsocks)) != NULL) {
		TAILQ_REMOVE(&env->sc_rcsocks, rcs, cs_entry);
		control_cleanup(rcs);
		free(rcs);
	}
d233 2
a234 2
void
imsg_event_add(struct imsgev *iev)
d236 4
a239 29
	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev->data);
	event_add(&iev->ev, NULL);
}

void
snmpd_dispatch_snmpe(int fd, short event, void * ptr)
{
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	iev = ptr;
	ibuf = &iev->ibuf;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
a240 7
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
		imsg_event_add(iev);
		return;
	default:
		fatalx("unknown event");
d243 1
a243 15
	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("snmpd_dispatch_relay: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_debug("snmpd_dispatch_relay: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d324 17
@


1.16
log
@ 1) move the creation of 'restricted' communication sockets
    into snmpd.conf
 2) add the ability to specify an alternate 'control' socket location
 3) allow for the creation of multiple 'restricted' sockets (but
    only one control socket, for the time being)

Committing slightly ahead of schedule in order to clear the pipeline
for a few other upcoming changes.

ok reyk@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.15 2012/11/29 14:53:24 yasuoka Exp $	*/
d90 1
a90 1
	    "[-f file] [-r path]\n", __progname);
d112 1
a112 1
	while ((c = getopt(argc, argv, "dD:nNf:r:v")) != -1) {
@


1.15
log
@Wrong argument was passed to control_dispatch_imsg().  Use always
(struct imsgev *)->data for the argument of imsgev handlers.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.14 2012/09/18 08:29:09 reyk Exp $	*/
a106 1
	const char		*rcsock = NULL;
a130 3
		case 'r':
			rcsock = optarg;
			break;
a158 5
	/* Configure the control sockets */
	env->sc_csock.cs_name = SNMPD_SOCKET;
	env->sc_rcsock.cs_name = rcsock;
	env->sc_rcsock.cs_restricted = 1;

d219 1
d232 5
a236 1
	control_cleanup(&env->sc_rcsock);
@


1.14
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.13 2012/09/17 16:43:59 reyk Exp $	*/
d213 1
d273 1
a273 1
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev);
@


1.13
log
@Update copyright and my email address in snmpd while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.12 2012/09/17 16:30:35 reyk Exp $	*/
d353 1
a353 1
	memset(env->sc_engineid, 0, sizeof (env->sc_engineid));
d355 1
a355 1
	memcpy(env->sc_engineid, &oid_enterprise, sizeof (oid_enterprise));
d357 2
a358 1
	env->sc_engineid_len = sizeof (oid_enterprise);
d362 3
a364 2
	memcpy(&env->sc_engineid[env->sc_engineid_len], &rnd, sizeof (rnd));
	env->sc_engineid_len += sizeof (rnd);
d366 2
a367 3
	memcpy(&env->sc_engineid[env->sc_engineid_len], &tim, sizeof (tim));
	env->sc_engineid_len += sizeof (tim);
	return;
@


1.12
log
@Add initial SNMPv3 support to snmpd(8).

Traps are still sent via SNMPv2 protocol. They can neither be
authenticated nor encrypted. - Transport mode is still UDP. Not
additional transport subsystems were added. - Only the User-based
Security Model (USM, RFC3414) is supported.  View-Based Access Control
(VACM, RFC3415) is not included. - Configuration is described in
snmpd.conf(5).

This diff includes a few minor changes to ber.c/h adding a necessary
callback for the USM HMAC calculation and merging it with other
minor changes from ldapd's ber code.

From Gerhard Roth at genua
ok claudio@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.11 2012/05/28 20:55:40 joel Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@vantronix.net>
@


1.11
log
@Plug a couple more fd leaks. As part of the fix, make all the *init
functions return void.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.10 2012/02/23 03:54:38 joel Exp $	*/
d40 1
d48 1
d176 1
d189 2
d347 54
@


1.10
log
@Bring in PF-MIB to snmpd.

ok krw@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.9 2009/06/06 05:52:01 pyr Exp $	*/
d177 1
a177 2
	if (pf_init())
		fatal("cannot open /dev/pf");
@


1.9
log
@sync snmpd with the common imsg code, making it lib ready as well.
ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.8 2008/09/26 15:19:55 reyk Exp $	*/
d176 3
@


1.8
log
@allow to add an additional restricted control socket for trap sending
only (not even show commands).  this allows to place a socket for
traps in another daemon's chroot.

(based on restricted socket support from bgpd)
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.7 2008/05/12 19:15:02 pyr Exp $	*/
d51 1
a51 1
struct imsgbuf	*ibuf_snmpe;
d201 1
a201 1
	if ((ibuf_snmpe = calloc(1, sizeof(struct imsgbuf))) == NULL)
d204 2
a205 1
	imsg_init(ibuf_snmpe, pipe_parent2snmpe[0], snmpd_dispatch_snmpe);
d207 4
a210 4
	ibuf_snmpe->events = EV_READ;
	event_set(&ibuf_snmpe->ev, ibuf_snmpe->fd, ibuf_snmpe->events,
	    ibuf_snmpe->handler, ibuf_snmpe);
	event_add(&ibuf_snmpe->ev, NULL);
d258 1
a258 1
imsg_event_add(struct imsgbuf *ibuf)
d260 7
a266 7
	ibuf->events = EV_READ;
	if (ibuf->w.queued)
		ibuf->events |= EV_WRITE;

	event_del(&ibuf->ev);
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf);
	event_add(&ibuf->ev, NULL);
d272 1
d277 2
a278 1
	ibuf = ptr;
d285 1
a285 1
			event_del(&ibuf->ev);
d293 1
a293 1
		imsg_event_add(ibuf);
d313 1
a313 1
	imsg_event_add(ibuf);
@


1.7
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.6 2008/03/16 00:14:47 dlg Exp $	*/
d87 2
a88 2
	fprintf(stderr, "usage: %s [-dNnv] [-D macro=value] [-f file]\n",
	    __progname);
d105 1
d111 1
a111 1
	while ((c = getopt(argc, argv, "dD:nNf:v")) != -1) {
d130 3
d161 5
d230 2
a231 1
	control_cleanup();
@


1.6
log
@usage statements are preceeded with usage:

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.4 2008/01/16 19:36:06 reyk Exp $	*/
d136 5
@


1.5
log
@sort flags in both synopsis and usage

ok reyk@@
@
text
@d87 2
a88 1
	fprintf(stderr, "%s [-dNnv] [-D macro=value] [-f file]\n", __progname);
@


1.4
log
@implementation of the SNMP trap sender interface
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.3 2008/01/16 09:51:15 reyk Exp $	*/
d87 1
a87 1
	fprintf(stderr, "%s [-dnNv] [-D macro=value] [-f file]\n", __progname);
@


1.3
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.2 2007/12/28 16:59:31 reyk Exp $	*/
d296 25
@


1.2
log
@split code handling the "structure of management information" and the
"message processing subsystem" into separate files smi.c and mps.c
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.1 2007/12/05 09:22:44 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 Reyk Floeter <reyk@@vantronix.net>
@


1.1
log
@Start working on snmpd(8) and snmpctl(8), a lightweight SNMP implementation
for OpenBSD.  SNMP is a necessary evil.  This is work in progress, don't
expect too much from it yet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.c,v 1.3 2007/11/12 17:43:48 reyk Exp $	*/
d105 1
a105 1
	mps_init();
@

